=== Content from discussions.nessus.org_4f9a44ad_20250125_182220.html ===

redirecting user.....


=== Content from www.cl.cam.ac.uk_74f2bfab_20250125_182216.html ===
Minding your p’s and q’s

Ross Anderson1, Serge Vaudenay2

1 Computer Laboratory, Pembroke Street, Cambridge, CB2 3QG, England
2 Ecole Normal Sup´erieure — DMI, 45 rue d’Ulm, 75230 Paris, France

Abstract. Over the last year or two, a large number of attacks have
been found by the authors and others on protocols based on the discrete
logarithm problem, such as ElGamal signature and Diﬃe Hellman key
exchange. These attacks depend on causing variables to assume values
whose discrete logarithms can be calculated, whether by forcing a proto-
col exchange into a smooth subgroup or by choosing degenerate values
directly. We survey these attacks and discuss how to build systems that
are robust against them. In the process we elucidate a number of the
design decisions behind the US Digital Signature Standard.

1

Introduction

The large majority of actual attacks on conventional cryptosystems are due to
blunders in design, implementation and operation, which are typically discovered
by chance and exploited in an opportunistic way [2, 3]. We have not yet accumu-
lated comparable experience of the failure modes of public key cryptosystems,
but the early indications are that nothing much has changed: an implementation
of the Fiat-Shamir identiﬁcation scheme [14] is reported to have failed because
the application always used the same random challenge [22, 23].

Any system can be compromised by a gross blunder of this kind; but public
key systems present a large number of subtle failure modes [5]. Some are variants
on the middleperson attack or exploit the semantics of public key systems in
general, while others depend on the mathematical features of particular systems.
In this paper, we investigate protocols based on the discrete logarithm prob-
lem such as ElGamal signature, Diﬃe-Hellman key exchange and the Chor-Rivest
system. We describe a family of simple attacks, some of them new, which have
been found by the authors and others over the last year or two. These attacks
enable us to explain the design of the US digital signature standard [24].

2 ElGamal and related protocols

The original ElGamal signature uses a large prime p as its modulus and a gen-
erator g of the group Z ∗
p as its base. These values are common, and may be
issued by authority; each user has a secret key x and a corresponding public key
y = gx mod p. To sign a message M , the signer ﬁrst picks a random k which is
coprime to p − 1 and issues the signature (r, s) where

r = gk mod p
M − xr
k

s =

mod p − 1

(1)

(2)

Writing the second equation as sk + xr ≡ M mod p − 1, we see that a valid

signature is checked by verifying

rsyr ≡ gM (mod p)

We shall show that this system is quite insecure, unless considerable care is

taken in the choice of parameters.

2.1 The eﬀect of the choice of p

Suppose that p−1 = qw, where w is smooth (i.e., all its prime factors are small).
This was the case with the primes p and q originally proposed with the US digital
signature standard (DSS):

p − 1
q

= 2703465307251120

(see [1]). Then the group Z ∗
q, in which discrete log is hard, and a subgroup of order w in which it is easy.

p in which we are operating has a subgroup of order

The eﬀect is that keys can be recovered modulo w. An attacker can solve
the equation (gq)z ≡ yq
(mod p) in the group of order w, giving x modulo
w, and then derive every message key k modulo w from equation (2). This was
originally pointed out by van Oorschot and Wiener [32]; and also by Anderson,
Vaudenay, Preneel and Nyberg in the context of subliminal channels, where the
eﬀect is to create one or more broadband covert channels [6]. However, there are
serious practical security implications as well.

In order to generate the message keys k for successive signatures, a random
number generator is required, and the use of ElGamal signatures with the above
prime p has the eﬀect of disclosing 352 out of every 512 bits of the generator’s
output. The typical generator has resonances and other features that can be
exploited (see for example [20]), with the result that further bits of message
keys k might be inferred by an adversary. Once a single key k modulo q is
compromised, the signing key x can easily be calculated.

The amount of information leaked will depend on the choice of p, and in
particular on the factors of p − 1. The above choice of p may be the worst
possible, but even the best possible — say p = 2qr + 1 where both q and r are
prime — will still leak one bit of message key per signature. So the choice of p is
not enough to completely prevent the leakage of key material. A better approach
is to use a base element g that generates a prime order subgroup of Z ∗
p ; then
we are doing our cryptographic operations in a single group, rather than in two

groups at a time. This is exactly the approach taken by the designers of DSS,
which has

r = (gk mod p) mod q
h(M ) + xr
k

mod q

s =

This blocks the above attack, and also (contrary to the popular misconcep-

tion) reduces the bandwidth available for use as a subliminal channel.

2.2 Attacks based on interaction between k and g

After the DSS was introduced, there was some controversy about whether a
trapdoor could be hidden in the primes p and q by, for example, choosing them
to be numbers which could be respresented compactly by a polynomial of degree
four or ﬁve, so that the authority could calculate discrete logarithms using the
number ﬁeld sieve [11].

But no-one seems to have stopped to think about the choice of base g.
A simple forgery attack on ElGamal consists of chosing k = (p − 1)/2. Then
r = p − 1, so the secret key x is hidden by r in the product xr modulo p − 1.
Unfortunately, this cannot work unless M = (p − 1)/2 or M = p − 1 since k is
not invertible modulo p − 1. But the authority can use this idea to provide valid
parameters with a hidden trapdoor.

If the authority chooses the base g such that he knows the discrete logarithm
k of r = (p−1)/2 (for instance by chosing g = r1/k mod p for random invertible k
until it is a generator), then he is able to choose this k which enables to compute
s (he needs to know x mod 2 but this can easily be obtained by checking whether
y is a quadratic residue or not.)

More generally, the authority can isolate a smooth factor w of p−1 and choose
g such that he knows the discrete logarithm k of some j(p − 1)/w between 0 and
p − 1. The ability to compute s from k is then equivalent to the knowledge of
x mod w which, as we have seen, is easy when w is smooth.

A similar forgery attack was recently found by Bleichenbacher. Suppose that
p − 1 = qw as before with w smooth, and that the authority can choose a g
which divides w. Then a valid signature can be forged on any message M as

r = (p − 1)/g
(mod p)
s = (M − ryq)(p − 3)/2

(mod p − 1)

where yq is the smooth part of the public key y (i.e. a solution of (gq)z ≡
yq mod p). This attack will also work in the more general case that the authority
knows a small multiple cq of q with 0 < c < w; see [7, 8] for details.

Bleichenbacher’s attack is particularly pernicious as it means that if an imple-
menter chooses g = 2 for performance reasons, as we understand has happened,
then signatures can be forged independently of the choice of p.

To thwart attacks of this kind, we can check that (p − 1)/ gcd(r, p − 1) is
not too smooth, or, once again, work in a subgroup of prime order. Another
approach is to replace M by h(r, M ) as in the Schnorr signature [27, 28] (see
[26]).

However, even using the DSS does not completely give complete protection,

as we shall see below.

2.3 The design of the digital signature standard

During World War 2, a slogan prominently displayed in a number of the crypt-
analysts’ huts at Bletchley Park was ‘If it’s not checked, it’s wrong’ [15]. This
prudent approach to cryptology is just as valid in the world of discrete logarithm
based systems as it was in the days of rotor machines.

Consider what happens if the veriﬁer’s software does not systematically check
whether 0 ≤ r < p (this is not explicitly demanded in ElGamal’s original paper
[13]). A valid signature can easily be forged for any message as follows. Choose
values for both s and rp−1 and compute

rp = g

M

s y−

rp−1
s

(mod p)

Then it is straightforward to ﬁnd a value r which ﬁts the values of both rp−1
mod p − 1 and rp mod p by using the Chinese Remainder Theorem. Of course,
the typical length of the r we obtain will be twice that of p. This attack has
independently been discovered by Bleichenbacher [7, 8].

We conclude that DSS is simply ElGamal with many of the bugs ﬁxed, and
with a rather simple optimization (the reduction of r modulo q) that reduces
the length of the signature and the amount of arithmetic needed to verify it.

However, DSS is not entirely bug-free. Firstly, the reduction mod q introduces
a new bug: the authority can choose q to be the diﬀerence between h(M ) and
h(M 0) for two known messages M and M 0. These two messages will then have
the same signature [31]. Note that this kind of bug is avoided if M is hashed
together with r, as in the Schnorr signature [27, 28].

Secondly, the authority might issue a base g with small order instead of order
q. Honest signers would be unable to produce a valid signature, but it will be
easy for anyone to forge one (by picking random signatures until one is valid
with this g). So if the application may use a large number of diﬀerent moduli
and bases some of which come from non-trusted parties (as is the case with the
UK government’s new Euroclipper proposal [9]), then the cautious implementer
will check that order of any base he uses for the ﬁrst time. Other attacks based
on the fact that g is not certiﬁed are also possible (see [31]).

The above two weaknesses probably do not matter in most digital signature
applications, but it seems prudent practice to require a proof of origin of the
p and q (for example, that they are generated using known seed values via a
one-way hash function) and to check the order of g.

However, careless designs that permit degenerate values such as in these two

examples can be deadly for Diﬃe Hellman key agreement protocols.

3 Diﬃe Hellman-like protocols

In the original Diﬃe Hellman Protocol, everything works modulo a ﬁxed prime
p. Two participants Alice and Bob ﬁrst agree on this prime and a generator g
p ; then Alice picks a random a and sends ga mod p to Bob, who picks a
of Z ∗
random b and sends gb mod p to Alice. They then compute a shared private key
as gab mod p.

3.1 The middleperson attack

In the traditional middleperson attack, Charlie sits between Alice and Bob. He
sets up one key with Alice (pretending to be Bob), and another key with Bob
(pretending to be Alice). He then acts as a message relay between them, and can
intercept all their traﬃc. Attacks of this kind are a serious pitfall for designers
of public key protocols, and can manifest themselves in various ways.

The traditional countermeasure is a key conﬁrmation protocol in which Alice
and Bob authenticate either the key they think they have just agreed, or the
components they think they exchanged in order to agree it. We shall now show
that these two countermeasures are not in fact equivalent; there are attacks in
which Charlie forces Alice and Bob to share a key that he can calculate.

If a careless implementation does not check the received values, then Charlie
can simply intercept both ga and gb and replace them with 0 or 1. Alice and
Bob end up sharing a ‘secret’ that Charlie knows too.

Assuming as before that p − 1 = qw with w smooth, a more sophisticated
attack is for Charlie to replace the numbers ga with gaq and gb with gbq. In this
way, the exchange is forced into the smooth subgroup of Z ∗
p ; he can then compute
the discrete logarithm of gaq mod p to the base gq and apply it to gbq mod
p, getting the shared key gabq. This attack was discovered by van Oorschot
and Wiener [32]; for more discussion on key agreement protocols, see Just and
Vaudenay [18].

3.2 Attacks on elliptic curve systems

Other variants on Diﬃe Hellman use elliptic curves. A typical system uses curves
of order 4p, where p is prime [30]; in this case, an attacker can use the above
techniques to force the key exchange into a subgroup of order 4, in which discrete
logarithms may be extracted by inspection.

But regardless of whether we are operating in a rational or elliptic curve
group, so long as its order is composite we have to be careful how we fortify the
Diﬃe Hellman protocol against middleperson attacks (in which Charlie simulta-
neously masquerades as Bob to Alice and as Alice to Bob). We shall now discuss
a few of the protocols that are vulnerable in this way.

3.3 Other Diﬃe-Hellman-like protocols

There are many variants of the Diﬃe-Hellman Protocol (see [12, 17, 21] for in-
stance), which fail to specify that prime order bases should be used. We leave
ﬁnding attacks to the reader as a exercise.

We also understand that in some secure telephone products, the two par-
ticipants authenticate the key by reading out a hash of the agreed key. This is
not suﬃcient against attacks of the kind described above, as the participants
would end up authenticating gabq mod p. Even if the base g were the generator
of a prime order subgroup, then the telephone equipment should check that the
received protocol variables were elements of order q, in case degenerate values
had been inserted instead.

When trying to prevent such attacks, designers would be well advised to
follow the principle that robust protocols are explicit ones [5]. As well as choosing
a prime order base and checking received variables, we should also authenticate
not just gab but also ga, gb, and all relevant environmental information such as
Alice’s and Bob’s names and the date.

Mea culpa: one of us disregarded this principle in [4]. There, an authentication
mechanism (of which the details are irrelevant here) was devised that enabled
Alice and Bob to check whether they shared the same session key. This gives no
protection against the above attacks.

4 Chor-Rivest-like Cryptosystems

At the beginning of public key cryptography, knapsack ciphers seemed very
attractive, but almost all of them have been broken by latice reduction techniques
(the Chor-Rivest system [10] remained unbroken until recently [29]).

We have noticed two recent attempts to make cryptosystems based on mul-

tiplicative knapsack problems.

4.1 The Lenstra Cryptosystem

The Lenstra Cryptosystem [19] is inspired by Chor-Rivest. It also works in a
ﬁnite ﬁeld GF(qh), where q is a prime power. Chor-Rivest has the surprising
property of being eﬃcient when computing discrete logarithms in GF(qh) is easy
[10]. Lenstra’s variant is a little less eﬃcient but does not require this property.
It is moreover provably at least as secure as Chor-Rivest.

Basically, given public parameters q, h and s (as well as the representation
of the ﬁelds), the Lenstra Cryptosystem uses public keys v1, . . . , vs in GF(qh).
A message is ﬁrst encoded (by using a public encoding rule) into a sequence
m1, . . . , ms of positive integers such that m1 + . . . + ms = h. Encrypting the
ms in GF(qh). A complicated forgery
message consists in computing v1
algorithm (which involves secret keys for the vi) lets us decrypt.

m1 . . . vs

Here we notice that the order qh − 1 of the multiplicative group may well be
smooth (for instance, for each factor n of h, qn − 1 is a factor of qh − 1). Thus it

may be possible to compute discrete logarithms in GF(qh)∗. But computing wi =
log vi reduces the cipher to a knapsack equation m1w1 + . . . + msws (actually,
a Chor-Rivest problem). Therefore (as mentioned by Lenstra) the ability to
compute discrete logarithms reduces the security to exactly that of Chor-Rivest.

4.2 The Naccache-Stern Cryptosystem

A more complex example is given by a new public-key cryptosystem recently
proposed by Naccache and Stern and based on multiplicative knapsacks [23, 25].
In this protocol, the public parameters are a set of prime numbers p1, . . . , pn and
a prime p such that p > p1 × . . . × pn. The secret key is an exponent s, and the
public key is a set of integers v1, . . . , vn such that vi
(mod p). To encrypt
mn mod p. To decrypt
an n-bit message m1 . . . mn, we compute c = v1
the message, we raise c to the power s and solve cs = p1
mn mod p.
The authors already mentioned an information leakage in the cryptosystem.

s ≡ pi
m1 ×. . .×vn

m1 × . . . × pn

Namely, with the use of the Legendre symbol, the encryption leaks the bit

(cid:19)

(cid:18) c
p

=

(cid:18) v1
p

(cid:19)m1

× . . . ×

(cid:19)mn

(cid:18) vn
p

(3)

This corresponds to the factor two in p − 1. More generally, for any smooth
factor w of p − 1, one can compute the mod w part of the discrete logarithms
w ≡ gai
of all the vi and c: if g is a primitive w-th root of 1 modulo p, let vi
(mod p). By computing all ais and b, we obtain the
(mod p) and c
equation

w ≡ gb

p−1

p−1

b ≡ m1a1 + . . . + mnan

(mod w)

(4)

This is a standard knapsack problem which can be solved by usual latice
reduction tricks [16] provided that w is large enough (typically, larger than 2n).
In [25], the authors propose using quadratic residues pis to ﬁx the problem
of information leakage and to use only a strong prime p (p = 2q + 1) to avoid
this kind of attack.

5 Conclusions

When designing systems based on the discrete logarithm problem, we must be
careful to avoid degenerate cases. If we use a group with smooth subgroups, then
there may be many such cases. In particular, na¨ıve Diﬃe Hellman — whether
modulo a rational prime or over an elliptic curve — can be attacked by forcing
it into a subgroup in which the discrete log problem is easy. Some of the con-
ventional ways of preventing middleperson attacks prevent such forcing attacks,
but many do not.

Even without smooth subgroups, there are many things that can go wrong
if we do not carefully specify the limit values and check them punctiliously at
runtime. The system parameters, the secret keys and the message keys can often

be chosen to be weak, and these weaknesses can interact in ways that are not at
all obvious.

In any case, with all systems based on discrete logarithm problems, it seems
prudent practice to use a group of prime order, unless there are good reasons not
to; such reasons can include using keys for multiple diﬀerent purposes. However,
such advanced applications are dangerous, and designers should take extra care.
Our results have also explained the design of the US digital signature stan-

dard. It is really just ElGamal with most of the bugs ﬁxed.

Finally, what ‘good reasons’ might there be to use a group of composite order?
Well, diﬀerent sets of people may know a secret key in diﬀerent subgroups. We
have already shown in [6] that this can be used to create broadband narrowcast
subliminal channels in signature schemes — by means of which messages may
be sent undetectably to precisely those parties who know a signing key modulo
a speciﬁc factor of p − 1. Composite groups might also be used in applications
such as key escrow protocols, where we might wish the same key to be used for
escrowed encryption and unescrowed signature. However, this will be the subject
of a diﬀerent paper.

References

1. RJ Anderson, “Practical RSA Trapdoor”, in Electronics Letters v 29 no 11

(27/5/93) p 995

2. RJ Anderson, “Why Cryptosystems Fail”, in Communications of the ACM

v 37 no 11 (Nov 94) pp 32–40

3. RJ Anderson, SJ Bezuidenhoudt, “On the Reliability of Electronic Payment
Systems”, in IEEE Transactions on Software Engineering v 22 no 5 (May
1996) pp 294–301

4. RJ Anderson, TMA Lomas, “On fortifying key negotiation schemes with
poorly chosen passwords”, in Electronics letters v 30 no 12 (23rd July 1994)
pp 1040–1041

5. RJ Anderson, RM Needham, “Robustness principles for public key proto-
cols” in Advances in Cryptology — CRYPTO ’95, Springer LNCS v 963 pp
236–247

6. R Anderson, S Vaudenay, B Preneel, K Nyberg, “The Newton Channel”, in
Preproceedings of the First International Workshop on Information Hiding
(30/5-1/6/96, Cambridge, UK) pp 143–148; proceedings to be published in
Springer LNCS series

7. D. Bleichenbacher, “Generating ElGamal Signatures Without Knowing the
Secret Key”, in Advances in Cryptology — Eurocrypt 96, Springer LNCS v
1070 pp 10–18

8. D. Bleichenbacher, ‘Eﬃciency and Security of Cryptosystems based on Num-
ber Theory’ Dissertation ETH No. 11404, Swiss Federal Institute of Tech-
nology, Z¨urich (1996)

9. “Securing Electronic Mail within HMG — part 1: Infrastructure and Proto-

col” 21 March 1996, CESG document T/3113TL/2776/11

10. B Chor, RL Rivest, “A knapsack-type public key cryptosystem based on
arithmetic in ﬁnite ﬁelds”, in IEEE Transactions on Information Theory, v
34 (1988) pp 901–909

11. Y Desmedt, P Landrock, A Lenstra, K McCurley, A Odlyzko, R Rueppel,
M Smid, “The Eurocrypt 92 Controversial Issue — Trapdoor Primes and
Moduli”, in Advances in Cryptology — Eurocrypt 92, Springer LNCS v 658
pp 194–199

12. W Diﬃe, PC van Oorschot, MJ Wiener, “Authentication and authenticated
key exchanges”, in Designs, Codes and Cryptography v 2 (1992) pp 107–125
13. T ElGamal, “A Public Key Cryptosystem and a Signature Scheme based on
Discrete Logarithms”, IEEE Transactions on Information Theory v 31 no 4
(1985) pp 469–472

14. A Fiat, A Shamir, “How to prove yourself: practical solutions to identiﬁca-
tion and signature problems”, in Advances in Cryptology — CRYPTO 86,
Springer LNCS v 263 pp 186–194

15. FH Hinsley, A Stripp, ‘Codebreakers’, OUP 1993
16. A Joux, J Stern, “Lattice Reduction: a Toolbox for the Cryptanalyst”, to

appear in Journal of Cryptology

17. N Jeﬀeries, C Mitchell, M Walker, “A Proposed Architecture for Trusted
Third Party Services”, in Cryptography: Policy and Algorithms, Springer
LNCS v 1029 pp 98–104

18. M Just, S Vaudenay. “Authenticated multi-party key agreement”, in these

proceedings

19. HW Lenstra, Jr., “On the Chor-Rivest Knapsack Cryptosystem”, in Journal

of Cryptology v 3 (1991) pp 149–155

20. L Letham, D Hoﬀ and A Folmsbee, “A 128K EPROM Using Encryption of
Pseudorandom Numbers to Enable Read Access”, in IEEE Journal of Solid
State Circuits v SC-21 (Oct 1986) pp 881 - 888

21. T Matsumoto, Y Takashima, H Imai. “On Seeking Smart Public-Key-
Distribution Systems”. in Transactions of the IECE of Japan (1986) pp
99–106

22. D Naccache, “Unless modiﬁed Fiat-Shamir is insecure”, in Proceedings of the
3rd Symposium on State and Progress of Research in Cryptography: SPRC
93, Rome, Italy 15–16 Feb 1993 pp 172–180, published by Fondazione Ugo
Bordoni

23. D Naccache, ‘Signature Num´erique et Preuves `a Divulgation Nulle, Crypt-
analyse, D´efense et Outils Algorithmiques’, Th`ese de Doctorat de l’Ecole
Nationale Sup´erieure des T´el´ecommunications ENST 95 E 019 (1995)
24. National Institute of Standards and Technology, ‘Digital Signature Stan-

dard’, FIPS Publication 186 (19 May 1994)

25. D Naccache, J Stern, “A new public-key encryption scheme”, presented at

Luminy, September 1995

26. D Pointcheval, J Stern. “Security proofs for signature schemes”, in Advances

in Cryptology — Eurocrypt 96, Springer LNCS v 1070 pp 387–398

27. CP Schnorr, “Eﬃcient identiﬁcation and signature for smart cards”, in Ad-
vances in Cryptology — CRYPTO 89, Springer LNCS v 435 pp 239–252
28. CP Schnorr, “Eﬃcient signature generation by smart cards”, in Journal of

Cryptology v 4 (1991) pp 161–174

29. CP Schnorr, HH H¨orner, “Attacking the Chor-Rivest Cryptosystem by
improved lattice reduction”, in Advances in Cryptology — Eurocrypt 95,
Springer LNCS v 921 pp 1–12

30. R Schroeppel, H Orman, S O’Malley, O Spatschek, “Fast Key Exchange with
Elliptic Curve Systems”, in Advances in Cryptology — Crypto 95, Springer
LNCS v 963 pp 43–56

31. S Vaudenay, “Hidden collisions on DSS”, in Advances in Cryptology —

CRYPTO ’96, Springer LNCS v 1109 pp 83–88

32. P. van Oorschot, M. J. Wiener, “On Diﬃe-Hellman key agreement with short
exponents”, in Advances in Cryptology — Eurocrypt 96, Springer LNCS v
1070 pp 332–343



=== Content from www.nessus.org_abbce814_20250125_182219.html ===


* [![Tenable](https://www.tenable.com/themes/custom/tenable/img/logo.png)](https://www.tenable.com)
* [Plugins](https://www.tenable.com/plugins)

* Settings
  ###### Links

  [Tenable Cloud](https://cloud.tenable.com) [Tenable Community & Support](https://community.tenable.com/login) [Tenable University](https://university.tenable.com/lms/index.php?r=site/sso&sso_type=saml) Severity VPRCVSS v2CVSS v3CVSS v4ThemeLightDarkAutoHelp

* [![Tenable](https://www.tenable.com/themes/custom/tenable/img/logo-teal.png)](https://www.tenable.com)
* Plugins
* [Overview](https://www.tenable.com/plugins)
* [Plugins Pipeline](https://www.tenable.com/plugins/pipeline)
* [Newest](https://www.tenable.com/plugins/newest)
* [Updated](https://www.tenable.com/plugins/updated)
* [Search](https://www.tenable.com/plugins/search)
* [Nessus Families](https://www.tenable.com/plugins/nessus/families?type=nessus)
* [WAS Families](https://www.tenable.com/plugins/was/families?type=was)
* [NNM Families](https://www.tenable.com/plugins/nnm/families?type=nnm)
* [LCE Families](https://www.tenable.com/plugins/lce/families?type=lce)
* [Tenable OT Security Families](https://www.tenable.com/plugins/ot/families?type=ot)
* [About Plugin Families](https://www.tenable.com/plugins/families/about)
* [Release Notes](https://www.tenable.com/plugins/release-notes)
* Audits
* [Overview](https://www.tenable.com/audits)
* [Newest](https://www.tenable.com/audits/newest)
* [Updated](https://www.tenable.com/audits/updated)
* [Search Audit Files](https://www.tenable.com/audits/search)
* [Search Items](https://www.tenable.com/audits/items/search)
* [References](https://www.tenable.com/audits/references)
* [Authorities](https://www.tenable.com/audits/authorities)
* [Documentation](https://www.tenable.com/audits/documentation)
* [Download All Audit Files](https://www.tenable.com/downloads/download-all-compliance-audit-files)
* Indicators
* [Overview](https://www.tenable.com/indicators)
* [Search](https://www.tenable.com/indicators/search)
* [Indicators of Attack](https://www.tenable.com/indicators/ioa)
* [Indicators of Exposure](https://www.tenable.com/indicators/ioe)
* CVEs
* [Overview](https://www.tenable.com/cve)
* [Newest](https://www.tenable.com/cve/newest)
* [Updated](https://www.tenable.com/cve/updated)
* [Search](https://www.tenable.com/cve/search)
* Attack Path Techniques
* [Overview](https://www.tenable.com/attack-path-techniques)
* [Search](https://www.tenable.com/attack-path-techniques/search)

+ Links
+ [Tenable Cloud](https://cloud.tenable.com)
+ [Tenable Community & Support](https://community.tenable.com/login)
+ [Tenable University](https://university.tenable.com/lms/index.php?r=site/sso&sso_type=saml)
+ Settings
+ SeverityVPRCVSS v2CVSS v3CVSS v4
+ ThemeLightDarkAuto
###### Detections

* Plugins
* [Overview](/plugins)
* [Plugins Pipeline](/plugins/pipeline)
* [Release Notes](/plugins/release-notes)
* [Newest](/plugins/newest)
* [Updated](/plugins/updated)
* [Search](/plugins/search)
* [Nessus Families](/plugins/nessus/families)
* [WAS Families](/plugins/was/families)
* [NNM Families](/plugins/nnm/families)
* [LCE Families](/plugins/lce/families)
* [Tenable OT Security Families](/plugins/ot/families)
* [About Plugin Families](/plugins/families/about)
* Audits
* [Overview](/audits)
* [Newest](/audits/newest)
* [Updated](/audits/updated)
* [Search Audit Files](/audits/search)
* [Search Items](/audits/items/search)
* [References](/audits/references)
* [Authorities](/audits/authorities)
* [Documentation](/audits/documentation)
* [Download All Audit Files](https://www.tenable.com/downloads/download-all-compliance-audit-files)
* Indicators
* [Overview](/indicators)
* [Search](/indicators/search)
* [Indicators of Attack](/indicators/ioa)
* [Indicators of Exposure](/indicators/ioe)

###### Analytics

* CVEs
* [Overview](/cve)
* [Newest](/cve/newest)
* [Updated](/cve/updated)
* [Search](/cve/search)
* Attack Path Techniques
* [Overview](/attack-path-techniques)
* [Search](/attack-path-techniques/search)

1. [Plugins](https://www.tenable.com/plugins)
2. [Nessus](https://www.tenable.com/plugins/nessus/families)
3. 53360

1. [Nessus](https://www.tenable.com/plugins/nessus/families)
# SSL Server Accepts Weak Diffie-Hellman Keys

###### info Nessus Plugin ID 53360

Language:

English[日本語](https://jp.tenable.com/plugins/nessus/53360)[简体中文](https://www.tenablecloud.cn/plugins/nessus/53360)[繁體中文](https://zh-tw.tenable.com/plugins/nessus/53360)[English](https://www.tenable.com/plugins/nessus/53360)

* [Information](https://www.tenable.com/plugins/nessus/53360)
* [Dependencies](https://www.tenable.com/plugins/nessus/53360/dependencies)
* [Dependents](https://www.tenable.com/plugins/nessus/53360/dependents)
* [Changelog](https://www.tenable.com/plugins/nessus/53360/changelog)

#### Synopsis

The remote SSL/TLS server accepts a weak Diffie-Hellman public value.
#### Description

The remote SSL/TLS server accepts a weak Diffie-Hellman (DH) public key value.

This flaw may aid an attacker in conducting a man-in-the-middle (MiTM) attack against the remote server since it could enable a forced calculation of a fully predictable Diffie-Hellman secret.

By itself, this flaw is not sufficient to set up a MiTM attack (hence a risk factor of 'None'), as it would require some SSL implementation flaws to affect one of the clients connecting to the remote host.
#### Solution

OpenSSL is affected when compiled in FIPS mode. To resolve this issue, either upgrade to OpenSSL 1.0.0, disable FIPS mode or configure the ciphersuite used by the server to not include any Diffie-Hellman key exchanges.

PolarSSL is affected. To resolve this issue, upgrade to version 0.99-pre3 / 0.14.2 or higher.

If using any other SSL implementation, configure the ciphersuite used by the server to not include any Diffie-Hellman key exchanges or contact your vendor for a patch.
#### See Also

<https://www.cl.cam.ac.uk/~rja14/Papers/psandqs.pdf>

<https://tls.mbed.org/tech-updates/security-advisories/polarssl-security-advisory-2011-01>

#### Plugin Details

**Severity:** Info

**ID:** 53360

**File Name:** polarssl\_dh\_vuln.nasl

**Version:** 1.35

**Type:** remote

**Family:** [General](https://www.tenable.com/plugins/nessus/families/General)

**Published:** 4/11/2011

**Updated:** 6/12/2020

**Supported Sensors:** Nessus

#### Vulnerability Information

**Required KB Items:** SSL/Supported

**Exploited by Nessus:** true

* [Tenable.com](https://www.tenable.com/)
* [Community & Support](https://community.tenable.com)
* [Documentation](https://docs.tenable.com)
* [Education](https://university.tenable.com)

* © 2025 Tenable®, Inc. All Rights Reserved
* [Privacy Policy](https://www.tenable.com/privacy-policy)
* [Legal](https://www.tenable.com/legal)
* [508 Compliance](https://www.tenable.com/section-508-voluntary-product-accessibility)


