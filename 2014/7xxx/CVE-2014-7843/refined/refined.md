```
{
  "cveId": "CVE-2014-7843",
  "relatedContent": [
    {
      "source": "www.kernel.org_3b4eea77_20250125_164801.html",
      "vulnerabilityDetails": [
        {
          "rootCause": "The ARM64 kernel does not properly handle exceptions during single-byte memory clear operations using `strb` instruction in `__clear_user` function.",
          "weaknesses": [
            "Improper exception handling during memory operations."
          ],
          "impact": "A local, unprivileged user can cause a kernel panic (Denial of Service).",
          "attackVectors": [
            "A local user performs a read operation from `/dev/zero` with size `n*PAGE_SIZE + 1`, where `n` is a positive integer."
          ],
          "requiredCapabilities": "A local unprivileged user is required to execute the attack.",
           "additionalDetails": "The vulnerability is triggered when a single byte operation using the `strb` instruction within `__clear_user` function encounters an exception and the kernel does not have the ability to properly fix up this fault.  Specifically the vulnerability occurs when reading from `/dev/zero` which results in uninitialized memory being cleared. The issue is most easily triggered with CONFIG_DEBUG_VM enabled."
        },
          {
          "rootCause": "Multiple issues in the SCTP implementation related to ASCONF chunk processing, handling of duplicate ASCONF chunks, and excessive queueing due to malformed packets.",
          "weaknesses": [
            "Off-by-one error in parameter processing in `sctp_process_asconf`.",
            "Re-queueing a cached ASCONF_ACK chunk in `sctp_cmd_interpreter`.",
           "Missing flush point for output queue in `sctp_do_sm` when receiving malformed packets."
          ],
          "impact": "Remote attackers can cause a kernel crash, denial of service, or excessive memory consumption by sending crafted SCTP packets.",
          "attackVectors": [
            "Sending a specially crafted ASCONF chunk with specific length and parameters after the SCTP handshake.",
            "Sending duplicate ASCONF chunks with the same serial number.",
             "Sending packets with a malformed tail or junk data."
          ],
          "requiredCapabilities": "A remote attacker capable of sending SCTP packets to a vulnerable server."
        },
         {
          "rootCause": "Use of uninitialized variable in `nfs_getattr` leading to spurious error returns.",
           "weaknesses": ["Uninitialized variable usage."],
          "impact": "Spurious error returns.",
           "attackVectors": ["Accessing NFS file attributes."]
          , "requiredCapabilities": "None"
        },
       {
            "rootCause": "Races between `nfs_remove_bad_delegation` and delegation return.",
            "weaknesses": ["Race condition."],
            "impact": "Potential infinite loops in `nfs_end_delegation_return`.",
            "attackVectors": ["Causing a delegation to be revoked while it is being returned."],
             "requiredCapabilities": "None"
        },
          {
            "rootCause": "Failure to call `FREE_STATEID` when NFSv4.x stateids are revoked.",
            "weaknesses": ["Missing state cleanup."],
             "impact": "State recovery process may end up caching open/lock state in a situation where it should not.",
             "attackVectors":["State recovery when delegations are revoked."],
             "requiredCapabilities": "None"
        },
        {
            "rootCause": "Incorrect handling of NFSv4.0 delegations when state has expired.",
             "weaknesses": ["Missing state cleanup."],
              "impact": "Failure to remove NFSv4.0 delegations when state has expired.",
               "attackVectors": ["State recovery when delegations expire."],
             "requiredCapabilities": "None"
        },
       {
          "rootCause": "Incorrect size check in `ip_set_nfnl_get_byindex`.",
           "weaknesses": ["Off-by-one error."],
            "impact": "Incorrect access of `ip_set_list` array.",
             "attackVectors": ["Using the ipset netfilter module."],
             "requiredCapabilities":"None"
         },
        {
          "rootCause": "Missing check for NULL return value in `nf_tables_newchain` pcpu stats allocation.",
           "weaknesses": ["Missing check for NULL pointer."],
            "impact": "Possible kernel crash due to NULL pointer dereference.",
             "attackVectors": ["Using the nf_tables module."],
             "requiredCapabilities":"None"
         },
         {
          "rootCause": "Memory leak in bq2415x_charger driver when DTS parsing fails.",
           "weaknesses": ["Memory leak"],
            "impact": "Memory leak",
             "attackVectors": ["When parsing device tree."],
              "requiredCapabilities":"None"
         },
         {
          "rootCause": "Improper handling of `ENODEV` error in bq2415x_charger when getting power supply by phandle, causing a dereference of an error value.",
          "weaknesses": ["Incorrect error handling, potential null pointer dereference"],
          "impact": "Kernel crash if power supply isn't valid.",
           "attackVectors": ["When parsing device tree."],
             "requiredCapabilities":"None"
        },
        {
          "rootCause": "Accessing invalidated power supply object in charger-manager after charger unbind causing kernel panic.",
            "weaknesses": ["Invalidated object access."],
             "impact": "Kernel crash or undefined behavior",
             "attackVectors": ["Unbinding charger driver while charger-manager is active."],
             "requiredCapabilities":"None"
        },
       {
            "rootCause":"Accessing invalidated power supply in charger-manager after fuel gauge unbind.",
             "weaknesses": ["Invalidated object access"],
            "impact": "Kernel lockup or crash.",
            "attackVectors": ["Unbinding fuel gauge driver while charger-manager is active."],
              "requiredCapabilities":"None"
        },
       {
          "rootCause":"Sleeping under rcu_read_lock in `gss_stringify_acceptor`.",
           "weaknesses": ["Sleeping under rcu_read_lock."],
            "impact": "Kernel BUG",
             "attackVectors": ["Using RPC auth GSS"],
              "requiredCapabilities":"None"
        },
        {
          "rootCause": "Missing policy check before dereferencing it in `__cpufreq_add_dev` during resume from s2ram on SMP without OPP, leading to a NULL pointer dereference.",
           "weaknesses": ["Missing NULL check."],
            "impact": "Kernel crash when resuming on an SMP system without cpufreq operating points.",
             "attackVectors": ["Resuming from suspend-to-ram (s2ram) on SMP systems without OPP"],
             "requiredCapabilities":"None"
        },
        {
            "rootCause":"Potential buffer overflow in `ttusb-dec` ioctl handler.",
            "weaknesses": ["Missing bounds check, buffer overflow"],
             "impact":"Potential buffer overflow and undefined behavior.",
            "attackVectors": ["Sending a malformed ioctl to the driver."],
             "requiredCapabilities":"None"
        },
         {
            "rootCause":"Use of physical address instead of virtual address in `save_microcode_in_initrd_amd` on 32-bit architecture, leading to page fault in `load_microcode_amd`.",
            "weaknesses": ["Incorrect address usage"],
             "impact":"Kernel crash during early microcode loading.",
             "attackVectors": ["Early microcode loading on AMD systems on 32-bit architecture."],
             "requiredCapabilities":"None"
         },
         {
            "rootCause":"Accessing `dis_ucode_ldr` through physical address instead of a pointer on 32-bit architecture.",
             "weaknesses": ["Incorrect address usage"],
              "impact":"Potential kernel issues during microcode loading",
              "attackVectors": ["During microcode loading."],
             "requiredCapabilities":"None"
         },
        {
          "rootCause": "Incorrect handling of EPERM for key type names starting with '.'",
          "weaknesses": [
            "Inconsistent enforcement of key naming restrictions."
          ],
          "impact": "Userspace can add keys of internal types.",
          "attackVectors": [
            "Userspace creating keys with names starting with a dot."
          ],
          "requiredCapabilities": "Userspace access to kernel key management functions."
        },
        {
          "rootCause": "Race condition in `aarch64_insn_patch_text_sync` during patching kernel code",
          "weaknesses": [
              "Race condition due to incorrect synchronization"
          ],
          "impact": "System hang during kernel patching, especially with kprobes enabled.",
          "attackVectors": [
              "Inserting breakpoints into kernel code on aarch64 SMP systems."
            ],
          "requiredCapabilities": "Kernel code patching capabilities."
        },
          {
          "rootCause": "Use-after-free in mac80211 defragmentation logic.",
          "weaknesses": [
            "Use-after-free vulnerability in the mac80211 driver when processing fragmented packets."
          ],
          "impact": "Kernel crash or undefined behavior when processing the last fragment of a packet.",
          "attackVectors": [
            "Receiving the last fragment of a fragmented multicast packet."
          ],
           "requiredCapabilities": "A wireless network."
        }

      ]
    },
    {
        "source": "github.com_c1ebf925_20250125_164804.html",
         "vulnerabilityDetails": [
             {
                "rootCause":"ARM64 kernel does not properly handle exceptions during single-byte memory clear operations using `strb` instruction in `__clear_user` function.",
                "weaknesses":["Improper exception handling during memory operations."],
                "impact":"A local, unprivileged user can cause a kernel panic (Denial of Service).",
                "attackVectors":["A local user performs a read operation from `/dev/zero` with size `n*PAGE_SIZE + 1`, where `n` is a positive integer."],
                "requiredCapabilities":"A local unprivileged user is required to execute the attack.",
                   "additionalDetails": "The vulnerability is triggered when a single byte operation using the `strb` instruction within `__clear_user` function encounters an exception and the kernel does not have the ability to properly fix up this fault.  Specifically the vulnerability occurs when reading from `/dev/zero` which results in uninitialized memory being cleared. The issue is most easily triggered with CONFIG_DEBUG_VM enabled."
             }
            ]
    },
    {
      "source": "access.redhat.com_bd76ede7_20250126_102310.html",
        "vulnerabilityDetails": [
          {
          "rootCause": "The ARM64 kernel does not properly handle exceptions during single-byte memory clear operations using `strb` instruction in `__clear_user` function.",
          "weaknesses": [
            "Improper exception handling during memory operations."
          ],
          "impact": "A local, unprivileged user can cause a kernel panic (Denial of Service).",
          "attackVectors": [
            "A local user performs a read operation from `/dev/zero` with size `n*PAGE_SIZE + 1`, where `n` is a positive integer."
          ],
          "requiredCapabilities": "A local unprivileged user is required to execute the attack.",
           "additionalDetails": "The vulnerability is triggered when a single byte operation using the `strb` instruction within `__clear_user` function encounters an exception and the kernel does not have the ability to properly fix up this fault.  Specifically the vulnerability occurs when reading from `/dev/zero` which results in uninitialized memory being cleared. The issue is most easily triggered with CONFIG_DEBUG_VM enabled."
          }
        ]
    },
    {
        "source":"bugzilla.redhat.com_2c25153f_20250125_164803.html",
         "vulnerabilityDetails": [
          {
          "rootCause": "The ARM64 kernel does not properly handle exceptions during single-byte memory clear operations using `strb` instruction in `__clear_user` function.",
          "weaknesses": [
            "Improper exception handling during memory operations."
          ],
          "impact": "A local, unprivileged user can cause a kernel panic (Denial of Service).",
          "attackVectors": [
            "A local user performs a read operation from `/dev/zero` with size `n*PAGE_SIZE + 1`, where `n` is a positive integer."
          ],
           "requiredCapabilities": "A local unprivileged user is required to execute the attack.",
          "additionalDetails": "The vulnerability is triggered when a single byte operation using the `strb` instruction within `__clear_user` function encounters an exception and the kernel does not have the ability to properly fix up this fault.  Specifically the vulnerability occurs when reading from `/dev/zero` which results in uninitialized memory being cleared. The issue is most easily triggered with CONFIG_DEBUG_VM enabled."
          }
         ]
    },
    {
        "source":"www.openwall.com_f1371e81_20250125_164802.html",
         "vulnerabilityDetails":[
            {
          "rootCause": "The ARM64 kernel does not properly handle exceptions during single-byte memory clear operations using `strb` instruction in `__clear_user` function.",
          "weaknesses": [
            "Improper exception handling during memory operations."
          ],
           "impact": "A local, unprivileged user can cause a kernel panic (Denial of Service).",
           "attackVectors": [
            "A local user performs a read operation from `/dev/zero` with size `n*PAGE_SIZE + 1`, where `n` is a positive integer."
           ],
           "requiredCapabilities": "A local unprivileged user is required to execute the attack.",
              "additionalDetails": "The vulnerability is triggered when a single byte operation using the `strb` instruction within `__clear_user` function encounters an exception and the kernel does not have the ability to properly fix up this fault.  Specifically the vulnerability occurs when reading from `/dev/zero` which results in uninitialized memory being cleared."
          }
        ]
    }
  ]
}
```