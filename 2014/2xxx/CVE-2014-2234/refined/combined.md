=== Content from hynek.me_eb9edda6_20250125_160351.html ===
[Hynek Schlawack](/)[About Me](/about/)[Articles](/articles/)[TIL](/til/)[Talks](/talks/)
# Apple OpenSSL Verification Surprises

03 March 2014

Apple ships a patched version of OpenSSL with macOS. If no precautions are taken, their changes rob you of the power to choose your trusted certificate authorities (CAs) and break the semantics of a callback that can be used for custom checks and verifications in client software.

If OpenSSL‚Äôs certificate verification fails while connecting to a server, Apple‚Äôs code will intercept that error and attempt to verify the certificate chain itself with system trust settings from the keyring, potentially throwing away *your* verification results. Therefore:

* You *can‚Äôt* limit your trust to certain CAs using [`SSL_CTX_load_verify_locations`](https://www.openssl.org/docs/ssl/SSL_CTX_load_verify_locations.html).

  This apparently isn‚Äôt [news](http://daniel.haxx.se/blog/2011/11/05/apples-modified-ca-cert-handling-and-curl/) but doesn‚Äôt appear to be widely known.
* Contrary to [documentation](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/SSL_CTX_set_verify.3ssl.html#//apple_ref/doc/man/3/SSL_CTX_set_verify), returning `0` from [`SSL_CTX_set_verify`](https://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html)‚Äôs callback does *not* make the TLS handshake fail. That makes the callback unsuitable for extra verification purposes (such as hostname verification).

  MITRE has assigned [CVE-2014-2234](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-2234) for this issue.

---

Apple was not interested in my bug report because they [deprecated](http://rentzsch.tumblr.com/post/33696323211/wherein-i-write-apples-technote-about-openssl-on-os-x) their OpenSSL years ago. Hence this summary together with work-arounds.

## The verify callback

OpenSSL‚Äôs [`SSL_CTX_set_verify`](https://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html) allows setting a callback function that is called for each certificate in the chain. It is invoked with the result of OpenSSL‚Äôs own verification of each certificate (`1` for success, `0` for failure) and an `x509_ctx` object that can be used to get the certificate and ‚Äì if applicable ‚Äì verification error in question.

As for the return code of this callback, Apple‚Äôs own [documentation](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/SSL_CTX_set_verify.3ssl.html#//apple_ref/doc/man/3/SSL_CTX_set_verify) says:

> The return value of verify\_callback controls the strategy of the further verification process. **If verify\_callback returns 0**, the verification process is immediately stopped with ‚Äúverification failed‚Äù state. If SSL\_VERIFY\_PEER is set, a verification failure alert is sent to the peer and the TLS/SSL handshake is **terminated**.

---

So technically the callback is useful for two things:

1. Gaining more information about a failure and reacting to it.
2. Additional checks such as hostname verification or a more strict certificate validation. Returning `0` should abort any handshake.

But that‚Äôs not the case.

Instead Apple‚Äôs OpenSSL aborts the chain verification (i.e. the callback doesn‚Äôt get called any further on any remaining certificates in the chain) but does *not* fail the handshake if it decides that the certificate chain of the peer is trustworthy.

**If you rely on the correct behavior and perform important checks within the callback, this behavior exposes you to [meddler-in-the-middle](https://en.wikipedia.org/wiki/Man-in-the-middle_attack) attacks.**

---

You can observe it with the following C code:

```
#include <errno.h>
#include <netdb.h>
#include <resolv.h>
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>
#include <openssl/err.h>
#include <openssl/ssl.h>
int
verify(int ok, X509_STORE_CTX *store)
{
    // Always abort verification with an error.
    return 0;
}
int
main(int argc, char *argv[])
{
    // Initialize OpenSSL
    SSL_library_init();
    SSL_load_error_strings();
    // Create a context
    SSL_CTX *ctx = SSL_CTX_new(TLSv1_client_method());
    if (ctx == NULL) {
        ERR_print_errors_fp(stderr);
        abort();
    }
    // Load trusted CAs from default paths.
    SSL_CTX_set_default_verify_paths(ctx);
    // Set verify function
    SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, verify);
    // Resolve
    struct addrinfo hints, *ai;
    memset(&hints, 0, sizeof hints);
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;
    int ai_error = getaddrinfo("www.apple.com", "https", &hints, &ai);
    if(ai_error != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(ai_error));
        abort();
    }
    // Connect
    int sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
    if(connect(sock, ai->ai_addr, ai->ai_addrlen) != 0) {
        close(sock);
        perror("connect");
        abort();
    }
    // Wrap connection with TLS
    SSL *ssl = SSL_new(ctx);
    if (ssl == NULL) {
        ERR_print_errors_fp(stderr);
        abort();
    }
    SSL_set_fd(ssl, sock);
    if (SSL_connect(ssl) == -1) {
        ERR_print_errors_fp(stderr);
    } else {
        // Should NOT be reached with the verify function from above!
        printf("Connected with cipher %s\n", SSL_get_cipher(ssl));
        SSL_shutdown(ssl);
    }
    SSL_free(ssl);
    close(sock);
    SSL_CTX_free(ctx);
    return 0;
}

```

Compile it using

```
$ cc ssl_client.c -lssl -lcrypto -o ssl_client

```

and run without arguments.

This program succeeds *only* when linked against Apple‚Äôs patched OpenSSL. Any other fails with an error message like:

```
SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed:s3_clnt.c:1166:

```

I have double-checked this back to a vintage 0.9.8e-fips-rhel5 on CentOS 5. It is definitely an Apple-only problem.

## Background

The reason for this unexpected behavior is that Apple is trying to be helpful. Certificate validation and especially trust databases are a hassle and OpenSSL‚Äôs handling of them is rather user-hostile. So Apple [patched](http://opensource.apple.com/source/OpenSSL098/OpenSSL098-35.1/src/crypto/x509/x509_vfy_apple.c) a *Trust Evaluation Agent* (TEA) into their OpenSSL. It gives failed verifications a second chance using the system keyring as trust store.

To follow what happens, it is also necessary to understand that the TLS context that gets passed around carries an *error code* that is distinct from the return code of the verification callback mentioned before. This error code directly affects TEA‚Äôs behavior.

Now, if a client attempts a TLS handshake with a server:

1. TEA first calls OpenSSL‚Äôs original verification function.
2. If OpenSSL‚Äôs verification fails (i.e. because OpenSSL can‚Äôt verify the certificate chain, or because the callback returns something else than `1`), TEA checks the current context‚Äôs error code for one of the following constants:
   * `X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY`,
   * `X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT`,
   * and `X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT`.
3. If one of them matches, TEA will attempt to fix the error by verifying the certificate chain itself. If it succeeds, the handshake succeeds too; no matter what happened within OpenSSL and your verification callback.

---

This is problematic for several reasons:

* Unless you explicitly set your trusted root certificates, the initial verification will always fail with the infamous `X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY` error (`20`). As you can see in my example, even telling OpenSSL to use its default CA locations (line 36) doesn‚Äôt work because they don‚Äôt exist on OS X ‚Äì they‚Äôre well hidden within the keyring.

  Therefore, unless you explicitly change the error code, TEA will *always* think it should try to fix the failed verification. So for instance if you discovered a hostname mismatch within the callback and thus return 0, TEA will *still* just try to verify the certificate chain and ignore your objection if the chain is trustworthy.
* If you want to use one of the error codes above for your extra checks (e.g. for blacklisting certain CAs), Apple‚Äôs OpenSSL will ignore your failures. This can be a rather unexpected behavior since it works correctly on other platforms.
* **Any effort to use certificate pinning or limiting your trust to certain CAs is undermined by TEA re-validating the chain for you.**
* None of this is obvious or documented.

## Solutions

My motivation is not to point fingers; I want to warn and offer solutions. So far I‚Äôve come up with three:

### Disable TEA

If TEA is disabled, it also can‚Äôt overrule your verification decision. You can achieve that by calling

```
X509_TEA_set_state(0);

```

as part of your application‚Äôs initialization.

However, as far as I can tell, that function is not public. At least I couldn‚Äôt find any definition or documentation outside of Apple‚Äôs [source code](http://opensource.apple.com/source/OpenSSL098/OpenSSL098-35.1/src/crypto/x509/x509_vfy_apple.h) of the patch.

Another approach is setting the `OPENSSL_X509_TEA_DISABLE` if you can‚Äôt or don‚Äôt want to change any code. You can try it with the example from above:

```
$ env OPENSSL_X509_TEA_DISABLE=1 ./ssl_client

```

The major drawback is that this approach makes Apple‚Äôs OpenSSL just another hopelessly outdated OpenSSL installation.

### Explicitly set an error code

This is probably the best approach if you have to use the verification callback with Apple‚Äôs OpenSSL. *Always* change the error within the context to something TEA doesn‚Äôt consider fixable. `X509_V_ERR_APPLICATION_VERIFICATION` would be an obvious choice:

```
int
verify(int ok, X509_STORE_CTX *store)
{
    X509_STORE_CTX_set_error(store, X509_V_ERR_APPLICATION_VERIFICATION);
    return 0;
}

```

There are [more](http://www.openssl.org/docs/apps/verify.html#DIAGNOSTICS) to choose from though.

### Compile your own OpenSSL

In their response to my bug report, Apple suggested to use a self-compiled OpenSSL (‚Ä¶until I‚Äôm ready to migrate to their SecureTransport). Generally that‚Äôs good advice because their OpenSSL is wildly out of date.

A practical way is [homebrew](http://brew.sh/) which takes some pain out of compiling software and keeping it up to date:

```
$ brew install openssl

```

Similar alternatives like [MacPorts](http://www.macports.org/) work just as fine of course.

---

This approach has at least two drawbacks though:

1. The software Apple ships is compiled against their OpenSSL (Python, Ruby‚Ä¶). You also have to double-check that your self-compiled software really picks up *your* custom OpenSSL instead of the system one (for example `--with-brewed-openssl` within homebrew).
2. Your OpenSSL has no access to the keyring and thus system trust store. Apple‚Äôs patches were there to help you with that after all. You‚Äôll have to manage your own set of trusted CAs, probably with the help of Mozilla‚Äôs infamous [`cacert.pem`](http://curl.haxx.se/docs/caextract.html). homebrew helps out a bit by [cloning](https://github.com/Homebrew/homebrew/blob/00afa52c222ea97b0e15e8aed315f6eb8aa922b9/Library/Formula/openssl.rb#L71) the system keyring into `/usr/local/etc/openssl/osx_cert.pem` on installation so `SSL_CTX_set_default_verify_paths` works out of the box.

   In any case, now you‚Äôll have to cope with two trust stores: your OpensSSL‚Äôs one, and the system one. This makes everything a bit crude and adds moving parts.

---

Ultimately, this is the long-term way to go. Although OpenSSL is not the [epitome of great software](https://twitter.com/OpenSSLFact), it‚Äôs not going anywhere. Especially because numerous cross-platform software including but not limited to development platforms like [Python](http://docs.python.org/2/library/ssl.html), [Ruby](http://ruby-doc.org/stdlib-2.0/libdoc/openssl/rdoc/OpenSSL.html), or [Node.js](http://nodejs.org/api/tls.html) are all using OpenSSL for their TLS needs.

## Impact

Together with Christian Heimes I‚Äôve analyzed multiple high-profile open source projects with TLS support whether they are affected and require prior notice. None of them seemed to perform validations within the verification callback in an exploitable way. So I consider the publication safe.

That doesn‚Äôt mean that such software doesn‚Äôt exist though. According to the documentation putting verification code into the callback is perfectly legit (for example, Google uses this pattern within [Chromium OS](https://chromium.googlesource.com/chromiumos/platform/update_engine/%2B/factory-2848.B/certificate_checker.cc) and so does [PHP](http://lxr.php.net/xref/PHP_5_6/ext/openssl/openssl.c#5006)) so caution is in order. Most endangered is cross-platform software that assumes that OpenSSL code behaves identically across platforms.

I for one ran into this bug while testing a patch from a bug tracker that worked perfectly fine on Linux.

## Q&A

### Is this related to the MITM bug I‚Äôve heard about on the news?

No.

The temporal proximity with the [bug](https://www.imperialviolet.org/2014/02/22/applebug.html) in SecureTransport that affects both macOS and iOS is coincidental.

I also don‚Äôt try to ride the attention wave provided by it: I filed a bug for this issue in Apple‚Äôs bug database a week before [CVE-2014-1266](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-1266)/[HT6147](http://support.apple.com/kb/HT6147) was published.

### Does this affect iOS?

No.

iOS doesn‚Äôt ship OpenSSL. This is a macOS‚Äìonly issue.

### Does this affect Apple‚Äôs software like Safari or Mail?

No.

Generally, Apple‚Äôs software ‚Äì and most Mac desktop software for that matter ‚Äì is using Apple‚Äôs SecureTransport and not OpenSSL.

## Credits

I‚Äôd like to thank [Laurens Van Houtven](https://twitter.com/lvh), [Christian Heimes](https://twitter.com/ChristianHeimes/), [Jean-Paul Calderone](https://twitter.com/jpcalderone), [Glyph](https://twitter.com/glyph), [Alex Stapleton](https://twitter.com/alexstapleton), Matthew Iversen, and [Matthew Green](https://twitter.com/matthew_d_green) for their assistance while researching and assessing this bug.

This post was made possible by the [donations](/say-thanks/) from people and corporations who appreciate my public work.

Want more content like this? Here's my free, low-volume, non-creepy [*Hynek Did Something* newsletter](https://buttondown.com/hynek)!
It allows me to share my content directly with you and add extra context:

---

[![Hynek Schlawack](https://static.hynek.me/img/avatar_w200h200.jpg?b=0860c9)](/about/)
## Hynek Schlawack

Code Bohemian in ‚ù§Ô∏è with Python üêç, Go üêπ, and DevOps üîß.
[blogger](/articles/) üìù,
[speaker](/talks/) üì¢,
PSF [fellow](https://www.python.org/psf/fellows-roster/) üèÜ,
[big city beach bum](https://www.instagram.com/p/CCWlkRRqjXP/) üèÑüèª,
substance over flash üß†.

Is my content helpful and/or enjoyable to you?
Please consider [supporting me](/say-thanks/)!
Every bit helps to motivate me in creating more.

¬© 2014
Hynek SchlawackAll Rights Reserved‚Ä¢[Impressum & Privacy](/legal/)![](https://m.hynek.me/m.php?idsite=2&rec=1)
