```
{
  "CVE-2014-3707": {
    "description": "libcurl's function curl_easy_duphandle() has a bug that can lead to libcurl eventually sending off sensitive data that was not intended for sending.  When doing an HTTP POST transfer with libcurl, you can use the CURLOPT_COPYPOSTFIELDS option to specify a memory area holding the data to send to the remote server. The memory area's size is set with a separate option, for example CURLOPT_POSTFIELDSIZE.  As the name implies, the data in the specified buffer is copied to a privately held memory buffer that libcurl allocates on the heap. The memory area is associated with the common CURL handle, often referred to as an \"easy handle\".  This handle can be duplicated by an application to create an identical copy, and all the already set options and data is then also similarly cloned and will be associated with the newly returned handle. This also includes the data to send in an HTTP POST request. The internal libcurl function that duplicates options from the old handle to the new, mistakenly treated the post data buffer as if it was a C string. A C string ends with a zero byte, and subsequently strdup() was used to duplicate the post data buffer. A post data buffer can perfectly legitimately contain a zero byte, or it may not contain any zero byte at all (including no trailing one) - leading to strdup() either making a too small duplicate, a too large one or crash due to reading an inaccessible memory area. The strdup() of course allocates memory off the heap.  If strdup finds a zero before the end of the buffer, the copied string ends up shorter than the original buffer but the original buffer size is still kept around. When libcurl subsequently constructs the HTTP POST request and includes data for the protocol body it will memcpy() data from that new pointer using the old size. This makes a read outside of the allocated boundary and can thus lead to libcurl inserting data into the request that happens to be laid out in the heap memory immediately after the post data buffer.",
    "root_cause": "The internal libcurl function that duplicates options from the old handle to the new mistakenly treated the post data buffer as if it was a C string, using `strdup()`, which expects a null-terminated string, instead of a binary copy. Additionally, the pointer used to read from when sending the data was not updated.",
    "weaknesses": [
      "Out-of-bounds read",
      "Incorrect handling of binary data",
       "Improper memory management"
    ],
    "impact": "A read outside of the allocated boundary can occur, which may lead to libcurl inserting sensitive data that was not intended for sending into the HTTP request. This could also lead to a crash due to reading an inaccessible memory area.",
    "attack_vectors": [
      "The vulnerability requires the use of `CURLOPT_COPYPOSTFIELDS` and `curl_easy_duphandle()` in that order, and then the duplicate handle must be used to perform the HTTP POST."
    ],
    "attacker_capabilities": "An attacker would need to control or influence the data being passed to libcurl as the post data, and be able to trigger the creation of a duplicate handle via curl_easy_duphandle()."
  }
}
```