=== Content from lkml.org_b985ef4f_20250125_160958.html ===


| [lkml.org](/) | Â | [[lkml]](/lkml) Â  [[2014]](/lkml/2014) Â  [[Sep]](/lkml/2014/9) Â  [[7]](/lkml/2014/9/7) Â  [[last100]](/lkml/last100) Â  [RSS Feed](/rss.php)Views: [wrap][no wrap] Â  [[headers]](/lkml/mheaders/2014/9/7/29)Â  [[forward]](/lkml/bounce/2014/9/7/29)Â | Â |
| --- | --- | --- | --- |
| Messages in this thread  * [First message in thread](/lkml/2014/9/7/29) * Thomas Gleixner  Patch in this message  * [Get diff 1](/lkml/diff/2014/9/7/29/1) | / | | | Date | Sun, 7 Sep 2014 13:00:40 +0200 (CEST) | | --- | --- | | From | Thomas Gleixner <> | | Subject | [GIT pull] timer updates for 3.17 | |  | | --- | --- | --- | --- | --- | --- | --- | --- |  ``` Linus,please pull the latest timers-urgent-for-linus git tree from:   git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git timers-urgent-for-linusThree fixlets from the timer departement: - Update the timekeeper before updating vsyscall and pvclock. This   fixes the kvm-clock regression reported by Chris and Paolo. - Use the proper irq work interface from NMI. This fixes the   regression reported by Catalin and Dave. - Clarify the compat_nanosleep error handling mechanism to avoid   future confusion.Thanks,	tglx------------------>Frederic Weisbecker (1):      nohz: Restore NMI safe local irq work for local nohz kickThomas Gleixner (2):      compat: nanosleep: Clarify error handling      timekeeping: Update timekeeper before updating vsyscall and pvclock include/linux/tick.h      |  7 +------ kernel/compat.c           | 24 +++++++++++++++++++++--- kernel/time/tick-sched.c  | 14 ++++++++++++++ kernel/time/timekeeping.c |  5 +++-- 4 files changed, 39 insertions(+), 11 deletions(-)diff --git a/include/linux/tick.h b/include/linux/tick.hindex 059052306831..9a82c7dc3fdd 100644--- a/include/linux/tick.h+++ b/include/linux/tick.h@@ -183,13 +183,8 @@ static inline bool tick_nohz_full_cpu(int cpu)  extern void tick_nohz_init(void); extern void __tick_nohz_full_check(void);+extern void tick_nohz_full_kick(void); extern void tick_nohz_full_kick_cpu(int cpu);--static inline void tick_nohz_full_kick(void)-{-	tick_nohz_full_kick_cpu(smp_processor_id());-}- extern void tick_nohz_full_kick_all(void); extern void __tick_nohz_task_switch(struct task_struct *tsk); #elsediff --git a/kernel/compat.c b/kernel/compat.cindex 633394f442f8..ebb3c369d03d 100644--- a/kernel/compat.c+++ b/kernel/compat.c@@ -226,7 +226,7 @@ static long compat_nanosleep_restart(struct restart_block *restart) 	ret = hrtimer_nanosleep_restart(restart); 	set_fs(oldfs); -	if (ret) {+	if (ret == -ERESTART_RESTARTBLOCK) { 		rmtp = restart->nanosleep.compat_rmtp;  		if (rmtp && compat_put_timespec(&rmt, rmtp))@@ -256,7 +256,26 @@ COMPAT_SYSCALL_DEFINE2(nanosleep, struct compat_timespec __user *, rqtp, 				HRTIMER_MODE_REL, CLOCK_MONOTONIC); 	set_fs(oldfs); -	if (ret) {+	/*+	 * hrtimer_nanosleep() can only return 0 or+	 * -ERESTART_RESTARTBLOCK here because:+	 *+	 * - we call it with HRTIMER_MODE_REL and therefor exclude the+	 *   -ERESTARTNOHAND return path.+	 *+	 * - we supply the rmtp argument from the task stack (due to+	 *   the necessary compat conversion. So the update cannot+	 *   fail, which excludes the -EFAULT return path as well. If+	 *   it fails nevertheless we have a bigger problem and wont+	 *   reach this place anymore.+	 *+	 * - if the return value is 0, we do not have to update rmtp+	 *    because there is no remaining time.+	 *+	 * We check for -ERESTART_RESTARTBLOCK nevertheless if the+	 * core implementation decides to return random nonsense.+	 */+	if (ret == -ERESTART_RESTARTBLOCK) { 		struct restart_block *restart 			= &current_thread_info()->restart_block; @@ -266,7 +285,6 @@ COMPAT_SYSCALL_DEFINE2(nanosleep, struct compat_timespec __user *, rqtp, 		if (rmtp && compat_put_timespec(&rmt, rmtp)) 			return -EFAULT; 	}- 	return ret; } diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.cindex 99aa6ee3908f..f654a8a298fa 100644--- a/kernel/time/tick-sched.c+++ b/kernel/time/tick-sched.c@@ -225,6 +225,20 @@ static DEFINE_PER_CPU(struct irq_work, nohz_full_kick_work) = { };  /*+ * Kick this CPU if it's full dynticks in order to force it to+ * re-evaluate its dependency on the tick and restart it if necessary.+ * This kick, unlike tick_nohz_full_kick_cpu() and tick_nohz_full_kick_all(),+ * is NMI safe.+ */+void tick_nohz_full_kick(void)+{+	if (!tick_nohz_full_cpu(smp_processor_id()))+		return;++	irq_work_queue(&__get_cpu_var(nohz_full_kick_work));+}++/*  * Kick the CPU if it's full dynticks in order to force it to  * re-evaluate its dependency on the tick and restart it if necessary.  */diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.cindex fb4a9c2cf8d9..ec1791fae965 100644--- a/kernel/time/timekeeping.c+++ b/kernel/time/timekeeping.c@@ -442,11 +442,12 @@ static void timekeeping_update(struct timekeeper *tk, unsigned int action) 		tk->ntp_error = 0; 		ntp_clear(); 	}-	update_vsyscall(tk);-	update_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);  	tk_update_ktime_data(tk); +	update_vsyscall(tk);+	update_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);+ 	if (action & TK_MIRROR) 		memcpy(&shadow_timekeeper, &tk_core.timekeeper, 		       sizeof(tk_core.timekeeper)); ``` | \ |
| Â |
| Â | \ | Â | / |
| Â | | Last update: 2014-09-07 13:41 Â Â  [from the cache]Â©2003-2020 [Jasper Spaans](http://blog.jasper.es/)|hosted at [Digital Ocean](https://www.digitalocean.com/?refcode=9a8e99d24cf9) and my Meterkast|[Read the blog](http://blog.jasper.es/categories.html#lkml-ref) | Â |


