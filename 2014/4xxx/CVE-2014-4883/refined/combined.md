=== Content from git.savannah.gnu.org_856f7f97_20250125_043052.html ===


| [cgit logo](/cgit/) | [index](/cgit/) : [lwip.git](/cgit/lwip.git/) | DEVEL-1\_4\_1 STABLE-2\_0\_0 STABLE-2\_1\_x master |
| --- | --- | --- |
| lwIP - A Lightweight TCPIP stack |  |

| [summary](/cgit/lwip.git/)[refs](/cgit/lwip.git/refs/?id=9fb46e120655ac481b2af8f865d5ae56c39b831a)[log](/cgit/lwip.git/log/)[tree](/cgit/lwip.git/tree/?id=9fb46e120655ac481b2af8f865d5ae56c39b831a)[commit](/cgit/lwip.git/commit/?id=9fb46e120655ac481b2af8f865d5ae56c39b831a)[diff](/cgit/lwip.git/diff/?id=9fb46e120655ac481b2af8f865d5ae56c39b831a) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Simon Goldschmidt <goldsimon@gmx.de> | 2014-09-15 21:50:41 +0200 |
| --- | --- | --- |
| committer | Simon Goldschmidt <goldsimon@gmx.de> | 2014-09-15 21:50:41 +0200 |
| commit | [9fb46e120655ac481b2af8f865d5ae56c39b831a](/cgit/lwip.git/commit/?id=9fb46e120655ac481b2af8f865d5ae56c39b831a) ([patch](/cgit/lwip.git/patch/?id=9fb46e120655ac481b2af8f865d5ae56c39b831a)) | |
| tree | [d3810414d13ffa7be83f18c560f54317b58c2a28](/cgit/lwip.git/tree/?id=9fb46e120655ac481b2af8f865d5ae56c39b831a) | |
| parent | [8216303524ca786177780a99b006d9d8ef56ed00](/cgit/lwip.git/commit/?id=8216303524ca786177780a99b006d9d8ef56ed00) ([diff](/cgit/lwip.git/diff/?id=9fb46e120655ac481b2af8f865d5ae56c39b831a&id2=8216303524ca786177780a99b006d9d8ef56ed00)) | |
| download | [lwip-9fb46e120655ac481b2af8f865d5ae56c39b831a.tar.gz](/cgit/lwip.git/snapshot/lwip-9fb46e120655ac481b2af8f865d5ae56c39b831a.tar.gz) | |

added source port randomization to make the DNS client more robust (see bug #43144)[Diffstat](/cgit/lwip.git/diff/?id=9fb46e120655ac481b2af8f865d5ae56c39b831a)

| -rw-r--r-- | [CHANGELOG](/cgit/lwip.git/diff/CHANGELOG?id=9fb46e120655ac481b2af8f865d5ae56c39b831a) | 4 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [src/core/dns.c](/cgit/lwip.git/diff/src/core/dns.c?id=9fb46e120655ac481b2af8f865d5ae56c39b831a) | 262 | |  |  |  | | --- | --- | --- | |

2 files changed, 205 insertions, 61 deletions

| diff --git a/CHANGELOG b/CHANGELOGindex 133723de..2b9e4687 100644--- a/[CHANGELOG](/cgit/lwip.git/tree/CHANGELOG?id=8216303524ca786177780a99b006d9d8ef56ed00)+++ b/[CHANGELOG](/cgit/lwip.git/tree/CHANGELOG?id=9fb46e120655ac481b2af8f865d5ae56c39b831a)@@ -6,6 +6,10 @@ HISTORY  ++ New features: + 2014-09-15: Simon Goldschmidt+ \* dns.c: added source port randomization to make the DNS client more robust+ (see bug #43144)+ 2013-09-02: Simon Goldschmidt \* arch.h and many other files: added optional macros PACK\_STRUCT\_FLD\_8() and PACK\_STRUCT\_FLD\_S() to prevent gcc 4 from warning about struct members thatdiff --git a/src/core/dns.c b/src/core/dns.cindex dc20227b..9d545101 100644--- a/[src/core/dns.c](/cgit/lwip.git/tree/src/core/dns.c?id=8216303524ca786177780a99b006d9d8ef56ed00)+++ b/[src/core/dns.c](/cgit/lwip.git/tree/src/core/dns.c?id=9fb46e120655ac481b2af8f865d5ae56c39b831a)@@ -88,14 +88,15 @@ /\* A list of DNS security features follows \*/ #define LWIP\_DNS\_SECURE\_RAND\_XID 1 #define LWIP\_DNS\_SECURE\_NO\_MULTIPLE\_OUTSTANDING 2+#define LWIP\_DNS\_SECURE\_RAND\_SRC\_PORT 4 /\*\* Use all DNS security features by default. \* This is overridable but should only be needed by very small targets \* or when using against non standard DNS servers. \*/ #ifndef LWIP\_DNS\_SECURE-#define LWIP\_DNS\_SECURE (LWIP\_DNS\_SECURE\_RAND\_XID | LWIP\_DNS\_SECURE\_NO\_MULTIPLE\_OUTSTANDING)+#define LWIP\_DNS\_SECURE (LWIP\_DNS\_SECURE\_RAND\_XID | LWIP\_DNS\_SECURE\_NO\_MULTIPLE\_OUTSTANDING | LWIP\_DNS\_SECURE\_RAND\_SRC\_PORT) #endif -/\*\* Random generator function to create random TXIDs for queries \*/+/\*\* Random generator function to create random TXIDs and source ports for queries \*/ #ifndef DNS\_RAND\_TXID #if ((LWIP\_DNS\_SECURE & LWIP\_DNS\_SECURE\_RAND\_XID) != 0) #define DNS\_RAND\_TXID LWIP\_RAND@@ -105,6 +106,11 @@ static u16\_t dns\_txid; #endif #endif +/\*\* Limits the source port to be >= 1024 by default \*/+#ifndef DNS\_PORT\_ALLOWED+#define DNS\_PORT\_ALLOWED(port) ((port) >= 1024)+#endif+ /\*\* DNS server IP address \*/ #ifndef DNS\_SERVER\_ADDRESS #define DNS\_SERVER\_ADDRESS(ipaddr) (ip4\_addr\_set\_u32(ipaddr, ipaddr\_addr("208.67.222.222"))) /\* resolver1.opendns.com \*/@@ -139,6 +145,19 @@ static u16\_t dns\_txid; #define DNS\_MAX\_REQUESTS DNS\_TABLE\_SIZE #endif +/\* The number of UDP source ports used in parallel \*/+#if ((LWIP\_DNS\_SECURE & LWIP\_DNS\_SECURE\_RAND\_SRC\_PORT) != 0)+#ifndef DNS\_MAX\_SOURCE\_PORTS+#define DNS\_MAX\_SOURCE\_PORTS DNS\_MAX\_REQUESTS+#endif+#else+#ifdef DNS\_MAX\_SOURCE\_PORTS+#undef DNS\_MAX\_SOURCE\_PORTS+#endif+#define DNS\_MAX\_SOURCE\_PORTS 1+#endif++ /\* DNS protocol flags \*/ #define DNS\_FLAG1\_RESPONSE 0x80 #define DNS\_FLAG1\_OPCODE\_STATUS 0x10@@ -204,16 +223,18 @@ struct dns\_answer {  /\*\* DNS table entry \*/ struct dns\_table\_entry {+ u32\_t ttl;+ ip\_addr\_t ipaddr;+ u16\_t txid; u8\_t state;- u8\_t numdns;+ u8\_t server\_idx; u8\_t tmr; u8\_t retries; u8\_t seqno;- u8\_t err;- u16\_t txid;- u32\_t ttl;+#if ((LWIP\_DNS\_SECURE & LWIP\_DNS\_SECURE\_RAND\_SRC\_PORT) != 0)+ u8\_t pcb\_idx;+#endif char name[DNS\_MAX\_NAME\_LENGTH];- ip\_addr\_t ipaddr; };  /\*\* DNS request table entry: used when dns\_gehostbyname cannot answer the@@ -264,7 +285,10 @@ static void dns\_check\_entries(void); \*----------------------------------------------------------------------------\*/  /\* DNS variables \*/-static struct udp\_pcb \*dns\_pcb;+static struct udp\_pcb \*dns\_pcbs[DNS\_MAX\_SOURCE\_PORTS];+#if ((LWIP\_DNS\_SECURE & LWIP\_DNS\_SECURE\_RAND\_SRC\_PORT) != 0)+static u8\_t dns\_last\_pcb\_idx;+#endif static u8\_t dns\_seqno; static struct dns\_table\_entry dns\_table[DNS\_TABLE\_SIZE]; static struct dns\_req\_entry dns\_requests[DNS\_MAX\_REQUESTS];@@ -329,23 +353,23 @@ dns\_init() LWIP\_DEBUGF(DNS\_DEBUG, ("dns\_init: initializing\n"));  /\* if dns client not yet initialized... \*/- if (dns\_pcb == NULL) {- dns\_pcb = udp\_new();-- if (dns\_pcb != NULL) {- /\* initialize DNS table not needed (initialized to zero since it is a- \* global variable) \*/- LWIP\_ASSERT("For implicit initialization to work, DNS\_STATE\_UNUSED needs to be 0",- DNS\_STATE\_UNUSED == 0);-- /\* initialize DNS client \*/- udp\_bind(dns\_pcb, IP\_ADDR\_ANY, 0);- udp\_recv(dns\_pcb, dns\_recv, NULL);-- /\* initialize default DNS primary server \*/- dns\_setserver(0, &dnsserver);- }+#if ((LWIP\_DNS\_SECURE & LWIP\_DNS\_SECURE\_RAND\_SRC\_PORT) == 0)+ if (dns\_pcbs[0] == NULL) {+ dns\_pcbs[0] = udp\_new();+ LWIP\_ASSERT("dns\_pcbs[0] != NULL", dns\_pcbs[0] != NULL);++ /\* initialize DNS table not needed (initialized to zero since it is a+ \* global variable) \*/+ LWIP\_ASSERT("For implicit initialization to work, DNS\_STATE\_UNUSED needs to be 0",+ DNS\_STATE\_UNUSED == 0);++ /\* initialize DNS client \*/+ udp\_bind(dns\_pcbs[0], IP\_ADDR\_ANY, 0);+ udp\_recv(dns\_pcbs[0], dns\_recv, NULL); }+#endif+ /\* initialize default DNS primary server \*/+ dns\_setserver(0, &dnsserver); #if DNS\_LOCAL\_HOSTLIST dns\_init\_local(); #endif@@ -360,9 +384,12 @@ dns\_init() void dns\_setserver(u8\_t numdns, ip\_addr\_t \*dnsserver) {- if ((numdns < DNS\_MAX\_SERVERS) && (dns\_pcb != NULL) &&- (dnsserver != NULL) && !ip\_addr\_isany(dnsserver)) {- dns\_servers[numdns] = (\*dnsserver);+ if (numdns < DNS\_MAX\_SERVERS) {+ if (dnsserver != NULL) {+ dns\_servers[numdns] = (\*dnsserver);+ } else {+ dns\_servers[numdns] = \*IP\_ADDR\_ANY;+ } } } @@ -390,10 +417,8 @@ dns\_getserver(u8\_t numdns) void dns\_tmr(void) {- if (dns\_pcb != NULL) {- LWIP\_DEBUGF(DNS\_DEBUG, ("dns\_tmr: dns\_check\_entries\n"));- dns\_check\_entries();- }+ LWIP\_DEBUGF(DNS\_DEBUG, ("dns\_tmr: dns\_check\_entries\n"));+ dns\_check\_entries(); }  #if DNS\_LOCAL\_HOSTLIST@@ -470,7 +495,7 @@ dns\_local\_removehost(const char \*hostname, const ip\_addr\_t \*addr) struct local\_hostlist\_entry \*entry = local\_hostlist\_dynamic; struct local\_hostlist\_entry \*last\_entry = NULL; while (entry != NULL) {- if (((hostname == NULL) || !strcmp(entry->name, hostname)) &&+ if (((hostname == NULL) || !LWIP\_DNS\_STRICMP(entry->name, hostname)) && ((addr == NULL) || ip\_addr\_cmp(&entry->addr, addr))) { struct local\_hostlist\_entry \*free\_entry; if (last\_entry != NULL) {@@ -636,13 +661,11 @@ dns\_parse\_name(char \*query) /\*\* \* Send a DNS query packet. \*- \* @param numdns index of the DNS server in the dns\_servers table- \* @param name hostname to query- \* @param txid transmission id for the query+ \* @param entry the DNS table entry for which to send a request \* @return ERR\_OK if packet is sent; an err\_t indicating the problem otherwise \*/ static err\_t-dns\_send(u8\_t numdns, const char\* name, u16\_t txid)+dns\_send(struct dns\_table\_entry\* entry) { err\_t err; struct dns\_hdr \*hdr;@@ -651,11 +674,12 @@ dns\_send(u8\_t numdns, const char\* name, u16\_t txid) char \*query, \*nptr; const char \*pHostname; u8\_t n;+ u8\_t pcb\_idx;  LWIP\_DEBUGF(DNS\_DEBUG, ("dns\_send: dns\_servers[%"U16\_F"] \"%s\": request\n",- (u16\_t)(numdns), name));- LWIP\_ASSERT("dns server out of array", numdns < DNS\_MAX\_SERVERS);- LWIP\_ASSERT("dns server has no IP address set", !ip\_addr\_isany(&dns\_servers[numdns]));+ (u16\_t)(entry->server\_idx), entry->name));+ LWIP\_ASSERT("dns server out of array", entry->server\_idx < DNS\_MAX\_SERVERS);+ LWIP\_ASSERT("dns server has no IP address set", !ip\_addr\_isany(&dns\_servers[entry->server\_idx]));  /\* if here, we have either a new query or a retry on a previous query to process \*/ p = pbuf\_alloc(PBUF\_TRANSPORT, SIZEOF\_DNS\_HDR + DNS\_MAX\_NAME\_LENGTH + 1 +@@ -666,11 +690,11 @@ dns\_send(u8\_t numdns, const char\* name, u16\_t txid) /\* fill dns header \*/ hdr = (struct dns\_hdr\*)p->payload; memset(hdr, 0, SIZEOF\_DNS\_HDR);- hdr->id = htons(txid);+ hdr->id = htons(entry->txid); hdr->flags1 = DNS\_FLAG1\_RD; hdr->numquestions = PP\_HTONS(1); query = (char\*)hdr + SIZEOF\_DNS\_HDR;- pHostname = name;+ pHostname = entry->name; --pHostname;  /\* convert hostname into suitable query format. \*/@@ -697,11 +721,15 @@ dns\_send(u8\_t numdns, const char\* name, u16\_t txid) LWIP\_ASSERT("p->tot\_len >= realloc\_size", p->tot\_len >= realloc\_size); pbuf\_realloc(p, realloc\_size); - /\* connect to the server for faster receiving \*/- udp\_connect(dns\_pcb, &dns\_servers[numdns], DNS\_SERVER\_PORT);+#if ((LWIP\_DNS\_SECURE & LWIP\_DNS\_SECURE\_RAND\_SRC\_PORT) != 0)+ pcb\_idx = entry->pcb\_idx;+#else+ pcb\_idx = 0;+#endif /\* send dns packet \*/- LWIP\_DEBUGF(DNS\_DEBUG, ("sending DNS request ID %d for name \"%s\" to server %d\r\n", txid, name, numdns));- err = udp\_sendto(dns\_pcb, p, &dns\_servers[numdns], DNS\_SERVER\_PORT);+ LWIP\_DEBUGF(DNS\_DEBUG, ("sending DNS request ID %d for name \"%s\" to server %d\r\n",+ entry->txid, entry->name, entry->server\_idx));+ err = udp\_sendto(dns\_pcbs[pcb\_idx], p, &dns\_servers[entry->server\_idx], DNS\_SERVER\_PORT);  /\* free pbuf \*/ pbuf\_free(p);@@ -712,6 +740,76 @@ dns\_send(u8\_t numdns, const char\* name, u16\_t txid) return err; } +#if ((LWIP\_DNS\_SECURE & LWIP\_DNS\_SECURE\_RAND\_SRC\_PORT) != 0)+static struct udp\_pcb\*+dns\_alloc\_random\_port(void)+{+ err\_t err;+ struct udp\_pcb\* ret;++ ret = udp\_new();+ if (ret == NULL) {+ /\* out of memory, have to reuse an existing pcb \*/+ return NULL;+ }+ do {+ u16\_t port = DNS\_RAND\_TXID();+ if (!DNS\_PORT\_ALLOWED(port)) {+ /\* this port is not allowed, try again \*/+ err = ERR\_USE;+ continue;+ }+ err = udp\_bind(ret, IP\_ADDR\_ANY, port);+ } while(err == ERR\_USE);+ if ((err != ERR\_OK) && (err != ERR\_USE)) {+ udp\_remove(ret);+ return NULL;+ }+ udp\_recv(ret, dns\_recv, NULL);+ return ret;+}++/\*\*+ \* dns\_alloc\_pcb() - allocates a new pcb (or reuses an existing one) to be used+ \* for sending a request+ \*+ \* @return an index into dns\_pcbs+ \*/+static u8\_t+dns\_alloc\_pcb(void)+{+ u8\_t i;+ u8\_t idx;++ for (i = 0; i < DNS\_MAX\_SOURCE\_PORTS; i++) {+ if (dns\_pcbs[i] == NULL) {+ break;+ }+ }+ if (i < DNS\_MAX\_SOURCE\_PORTS) {+ dns\_pcbs[i] = dns\_alloc\_random\_port();+ if (dns\_pcbs[i] != NULL) {+ /\* succeeded \*/+ dns\_last\_pcb\_idx = i;+ return i;+ }+ }+ /\* if we come here, creating a new UDP pcb failed, so we have to use+ an already existing one \*/+ idx = dns\_last\_pcb\_idx + 1;+ for (i = 0; i < DNS\_MAX\_SOURCE\_PORTS; i++) {+ if (idx >= DNS\_MAX\_SOURCE\_PORTS) {+ idx = 0;+ }+ if (dns\_pcbs[idx] != NULL) {+ dns\_last\_pcb\_idx = idx;+ return idx;+ }+ }+ return DNS\_MAX\_SOURCE\_PORTS;+}+#endif /\* ((LWIP\_DNS\_SECURE & LWIP\_DNS\_SECURE\_RAND\_SRC\_PORT) != 0) \*/+ /\*\* \* dns\_call\_found() - call the found callback and check if there are duplicate \* entries for the given hostname. If there are any, their found callback will@@ -723,8 +821,10 @@ dns\_send(u8\_t numdns, const char\* name, u16\_t txid) static void dns\_call\_found(u8\_t idx, ip\_addr\_t\* addr) {-#if ((LWIP\_DNS\_SECURE & LWIP\_DNS\_SECURE\_NO\_MULTIPLE\_OUTSTANDING) != 0) u8\_t i;+ LWIP\_UNUSED\_ARG(i);++#if ((LWIP\_DNS\_SECURE & LWIP\_DNS\_SECURE\_NO\_MULTIPLE\_OUTSTANDING) != 0) for (i = 0; i < DNS\_MAX\_REQUESTS; i++) { if (dns\_requests[i].found && (dns\_requests[i].dns\_table\_idx == idx)) { (\*dns\_requests[i].found)(dns\_table[idx].name, addr, dns\_requests[i].arg);@@ -738,6 +838,27 @@ dns\_call\_found(u8\_t idx, ip\_addr\_t\* addr) } dns\_requests[idx].found = NULL; #endif+#if ((LWIP\_DNS\_SECURE & LWIP\_DNS\_SECURE\_RAND\_SRC\_PORT) != 0)+ /\* close the pcb used unless other request are using it \*/+ for (i = 0; i < DNS\_MAX\_REQUESTS; i++) {+ if (i == idx) {+ continue; /\* only check other requests \*/+ }+ if (dns\_table[i].state == DNS\_STATE\_ASKING) {+ if (dns\_table[i].pcb\_idx == dns\_table[idx].pcb\_idx) {+ /\* another request is still using the same pcb \*/+ dns\_table[idx].pcb\_idx = DNS\_MAX\_SOURCE\_PORTS;+ break;+ }+ }+ }+ if (dns\_table[idx].pcb\_idx < DNS\_MAX\_SOURCE\_PORTS) {+ /\* if we come here, the pcb is not used any more and can be removed \*/+ udp\_remove(dns\_pcbs[dns\_table[idx].pcb\_idx]);+ dns\_pcbs[dns\_table[idx].pcb\_idx] = NULL;+ dns\_table[idx].pcb\_idx = DNS\_MAX\_SOURCE\_PORTS;+ }+#endif }  /\* Create a query transmission ID that is unique for all outstanding queries \*/@@ -786,13 +907,13 @@ dns\_check\_entry(u8\_t i) /\* initialize new entry \*/ txid = dns\_create\_txid(); entry->txid = txid;- entry->state = DNS\_STATE\_ASKING;- entry->numdns = 0;- entry->tmr = 1;+ entry->state = DNS\_STATE\_ASKING;+ entry->server\_idx = 0;+ entry->tmr = 1; entry->retries = 0;  /\* send DNS packet for this entry \*/- err = dns\_send(entry->numdns, entry->name, txid);+ err = dns\_send(entry); if (err != ERR\_OK) { LWIP\_DEBUGF(DNS\_DEBUG | LWIP\_DBG\_LEVEL\_WARNING, ("dns\_send returned error: %s\n", lwip\_strerr(err)));@@ -803,10 +924,10 @@ dns\_check\_entry(u8\_t i) case DNS\_STATE\_ASKING: if (--entry->tmr == 0) { if (++entry->retries == DNS\_MAX\_RETRIES) {- if ((entry->numdns+1<DNS\_MAX\_SERVERS) && !ip\_addr\_isany(&dns\_servers[entry->numdns+1])) {+ if ((entry->server\_idx + 1 < DNS\_MAX\_SERVERS) && !ip\_addr\_isany(&dns\_servers[entry->server\_idx + 1])) { /\* change of server \*/- entry->numdns++;- entry->tmr = 1;+ entry->server\_idx++;+ entry->tmr = 1; entry->retries = 0; break; } else {@@ -814,7 +935,7 @@ dns\_check\_entry(u8\_t i) /\* call specified callback function if provided \*/ dns\_call\_found(i, NULL); /\* flush this entry \*/- entry->state = DNS\_STATE\_UNUSED;+ entry->state = DNS\_STATE\_UNUSED; break; } }@@ -823,7 +944,7 @@ dns\_check\_entry(u8\_t i) entry->tmr = entry->retries;  /\* send DNS packet for this entry \*/- err = dns\_send(entry->numdns, entry->name, entry->txid);+ err = dns\_send(entry); if (err != ERR\_OK) { LWIP\_DEBUGF(DNS\_DEBUG | LWIP\_DBG\_LEVEL\_WARNING, ("dns\_send returned error: %s\n", lwip\_strerr(err)));@@ -904,9 +1025,10 @@ dns\_recv(void \*arg, struct udp\_pcb \*pcb, struct pbuf \*p, ip\_addr\_t \*addr, u16\_t entry\_idx = i; if ((entry->state == DNS\_STATE\_ASKING) && (entry->txid == txid)) {+ u8\_t dns\_err; /\* This entry is now completed. \*/ entry->state = DNS\_STATE\_DONE;- entry->err = hdr->flags2 & DNS\_FLAG2\_ERR\_MASK;+ dns\_err = hdr->flags2 & DNS\_FLAG2\_ERR\_MASK;  /\* We only care about the question(s) and the answers. The authrr and the extrarr are simply discarded. \*/@@ -914,7 +1036,7 @@ dns\_recv(void \*arg, struct udp\_pcb \*pcb, struct pbuf \*p, ip\_addr\_t \*addr, u16\_t nanswers = htons(hdr->numanswers);  /\* Check for error. If so, call callback to inform. \*/- if (((hdr->flags1 & DNS\_FLAG1\_RESPONSE) == 0) || (entry->err != 0) || (nquestions != 1)) {+ if (((hdr->flags1 & DNS\_FLAG1\_RESPONSE) == 0) || (dns\_err != 0) || (nquestions != 1)) { LWIP\_DEBUGF(DNS\_DEBUG, ("dns\_recv: \"%s\": error in flags\n", entry->name)); /\* call callback to indicate error, clean up memory and return \*/ goto responseerr;@@ -922,7 +1044,7 @@ dns\_recv(void \*arg, struct udp\_pcb \*pcb, struct pbuf \*p, ip\_addr\_t \*addr, u16\_t  /\* Check whether response comes from the same network address to which the question was sent. (RFC 5452) \*/- if (!ip\_addr\_cmp(addr, &dns\_servers[entry->numdns])) {+ if (!ip\_addr\_cmp(addr, &dns\_servers[entry->server\_idx])) { /\* call callback to indicate error, clean up memory and return \*/ goto responseerr; }@@ -1078,7 +1200,7 @@ dns\_enqueue(const char \*name, size\_t hostnamelen, dns\_found\_callback found, /\* find a free request entry \*/ req = NULL; for (r = 0; r < DNS\_MAX\_REQUESTS; r++) {- if (dns\_requests[r].found == 0) {+ if (dns\_requests[r].found == NULL) { req = &dns\_requests[r]; break; }@@ -1088,12 +1210,12 @@ dns\_enqueue(const char \*name, size\_t hostnamelen, dns\_found\_callback found, LWIP\_DEBUGF(DNS\_DEBUG, ("dns\_enqueue: \"%s\": DNS request entries table is full\n", name)); return ERR\_MEM; }+ req->dns\_table\_idx = i; #else /\* in this configuration, the entry index is the same as the request index \*/ req = &dns\_requests[i]; #endif - /\* use this entry \*/ LWIP\_DEBUGF(DNS\_DEBUG, ("dns\_enqueue: \"%s\": use DNS entry %"U16\_F"\n", name, (u16\_t)(i))); @@ -1106,6 +1228,18 @@ dns\_enqueue(const char \*name, size\_t hostnamelen, dns\_found\_callback found, MEMCPY(entry->name, name, namelen); entry->name[namelen] = 0; +#if ((LWIP\_DNS\_SECURE & LWIP\_DNS\_SECURE\_RAND\_SRC\_PORT) != 0)+ entry->pcb\_idx = dns\_alloc\_pcb();+ if (entry->pcb\_idx >= DNS\_MAX\_SOURCE\_PORTS) {+ /\* failed to get a UDP pcb \*/+ LWIP\_DEBUGF(DNS\_DEBUG, ("dns\_enqueue: \"%s\": failed to allocate a pcb\n", name));+ entry->state = DNS\_STATE\_UNUSED;+ req->found = NULL;+ return ERR\_MEM;+ }+ LWIP\_DEBUGF(DNS\_DEBUG, ("dns\_enqueue: \"%s\": use DNS pcb %"U16\_F"\n", name, (u16\_t)(entry->pcb\_idx)));+#endif+ dns\_seqno++;  /\* force to send query without waiting timer \*/@@ -1142,12 +1276,18 @@ dns\_gethostbyname(const char \*hostname, ip\_addr\_t \*addr, dns\_found\_callback foun size\_t hostnamelen; /\* not initialized or no valid server yet, or invalid addr pointer \* or invalid hostname or invalid hostname length \*/- if ((dns\_pcb == NULL) || (addr == NULL) ||+ if ((addr == NULL) || (!hostname) || (!hostname[0])) { return ERR\_ARG; }+#if ((LWIP\_DNS\_SECURE & LWIP\_DNS\_SECURE\_RAND\_SRC\_PORT) == 0)+ if (dns\_pcbs[0] == NULL) {+ return ERR\_ARG;+ }+#endif hostnamelen = strlen(hostname); if (hostnamelen >= DNS\_MAX\_NAME\_LENGTH) {+ LWIP\_DEBUGF(DNS\_DEBUG, ("dns\_gethostbyname: name too long to resolve")); return ERR\_ARG; } |
| --- |

generated by [cgit v1.2.3-70-g09d2](https://git.zx2c4.com/cgit/about/) ([git 2.46.0](https://git-scm.com/)) at 2025-01-25 04:30:52 +0000



=== Content from www.kb.cert.org_a5edff8f_20250125_043053.html ===


search

menu

icon-carat-right

cmu-wordmark

* ×
* [Home](/vuls/)
* [Notes](/vuls/bypublished/desc/)
* [Search](/vuls/search/)
* [Report a Vulnerability](/vuls/report/)
* [Disclosure Guidance](/vuls/guidance/)
* [VINCE](/vince/)

[[Carnegie Mellon University](https://www.cmu.edu)](https://www.cmu.edu/)

# [Software Engineering Institute](https://www.sei.cmu.edu/)

## CERT Coordination Center

* [Home](/vuls/)
* [Notes](/vuls/bypublished/desc/)
* [Search](/vuls/search/)
* [Report a Vulnerability](/vuls/report/)
* [Disclosure Guidance](/vuls/guidance/)
* [VINCE](/vince/)

* [Home](/vuls/)
* [Notes](/vuls/bypublished/desc/)
* Current:  VU#210620

## uIP and lwIP DNS resolver vulnerable to cache poisoning

#### Vulnerability Note VU#210620

Original Release Date: 2014-11-03 | Last Revised: 2017-02-13

---

### Overview

The DNS resolver implemented in uIP and lwIP is vulnerable to cache poisoning due to non-randomized transaction IDs (TXIDs) and source port reuse.

### Description

| [**CWE-330**](http://cwe.mitre.org/data/definitions/330.html)**: Use of Insufficiently Random Values** - CVE-2014-4883  The DNS resolver implemented in all versions of uIP, as well as lwIP versions 1.4.1 and earlier, is vulnerable to cache poisoning due to non-randomized transaction IDs (TXIDs) and source port reuse.For more information on the technical details and impact of this vulnerability, please refer to [VU#800113](http://www.kb.cert.org/vuls/id/800113). |
| --- |

### Impact

| A remote, unauthenticated attacker with the ability to conduct a successful cache poisoning attack can cause a nameserver's clients to contact the incorrect, and possibly malicious, hosts for particular services. Consequently, web traffic, email, and other important network data can be redirected to systems under the attacker's control. |
| --- |

### Solution

| **Apply an Update**lwIP has released version 2.0.0 to address this issue. Users and downstream developers are encouraged to upgrade to the [latest release of lwIP](https://savannah.nongnu.org/files/?group=lwip).uIP is now incorporated into the Contiki project. No patch has been made available by Contiki at this time.Please refer to [VU#800113](https://www.kb.cert.org/vuls/id/800113) for additional remediation and mitigation suggestions. |
| --- |

### Vendor Information

210620
Filter by status:
All
Affected
Not Affected
Unknown

Filter by content:
 Additional information available

 Sort by:
Status
Alphabetical

Expand all

**Javascript is disabled. Click [here](/vuls/vendor/VU%23210620/) to view vendors.**
### [Contiki OS](#TLEN-9QANZC) Affected

Notified:  September 01, 2014  Updated: October 27, 2014

### Status

Affected

### Vendor Statement

We have not received a statement from the vendor.

### Vendor Information

We are not aware of further vendor information regarding this vulnerability.

### [Philips Electronics](#BLUU-9NSPMM) Affected

Notified:  September 09, 2014  Updated: August 27, 2015

**Statement Date:   August 26, 2015**

### Status

Affected

### Vendor Statement

The CERT/CC reached out to Philips Electronics after originally discovering the vulnerability in the Philips Hue product, which utilizes lwIP for its TCP/IP stack.

Philips provided the following response:

"This issue has been investigated. Application-layer authentication prevents exploitation affecting confidentiality or integrity of Hue communication, data, firmware updates, etc.

Hue Bridge software update 01018228 that fixes this issue is available since December 2014. Users can upgrade via the Hue app."

### Vendor Information

We are not aware of further vendor information regarding this vulnerability.

### Vendor References

* <http://www2.meethue.com/en-us/>
* <http://www.usa.philips.com/>

### [lwIP](#TLEN-9Q4NEV) Affected

Notified:  August 14, 2014  Updated: October 21, 2014

### Status

Affected

### Vendor Statement

We have not received a statement from the vendor.

### Vendor Information

We are not aware of further vendor information regarding this vulnerability.

### [Thingsquare](#TLEN-9Q4NF2) Unknown

Notified:  September 11, 2014  Updated: October 27, 2014

### Status

Unknown

### Vendor Statement

We have not received a statement from the vendor.

### Vendor Information

We are not aware of further vendor information regarding this vulnerability.

### CVSS Metrics

| Group | Score | Vector |
| --- | --- | --- |
| Base | 6.8 | AV:N/AC:M/Au:N/C:P/I:P/A:P |
| Temporal | 5 | E:U/RL:OF/RC:C |
| Environmental | 5.0 | CDP:ND/TD:ND/CR:ND/IR:ND/AR:ND |

### References

* <http://cwe.mitre.org/data/definitions/330.html>
* <http://savannah.nongnu.org/projects/lwip/>
* <http://git.savannah.gnu.org/cgit/lwip.git/commit/?id=9fb46e120655ac481b2af8f865d5ae56c39b831a>
* <http://www.thingsquare.com/>
* <https://savannah.nongnu.org/files/?group=lwip>
### Acknowledgements

Thanks to Allen D. Householder for reporting this vulnerability.

This document was written by Todd Lewellen.

### Other Information

| **CVE IDs:** | [CVE-2014-4883](http://web.nvd.nist.gov/vuln/detail/CVE-2014-4883) |
| --- | --- |
| **Date Public:** | 2014-11-03 |
| **Date First Published:** | 2014-11-03 |
| **Date Last Updated:** | 2017-02-13 18:21 UTC |
| **Document Revision:** | 25 |

* [About vulnerability notes](https://vuls.cert.org/confluence/display/VIN/Vulnerability%2BNote%2BHelp)
* Contact us about this vulnerability
* [Provide a vendor statement](https://vuls.cert.org/confluence/display/VIN/Case%2BHandling#CaseHandling-Givingavendorstatusandstatement)

Sponsored by [CISA.](https://www.cisa.gov/cybersecurity)

 [Download PGP Key](https://vuls.cert.org/confluence/pages/viewpage.action?pageId=25985026)

[Read CERT/CC Blog](https://insights.sei.cmu.edu/cert/)

[Learn about Vulnerability Analysis](https://www.sei.cmu.edu/research-capabilities/all-work/display.cfm?customel_datapageid_4050=21304)

Carnegie Mellon University

Software Engineering Institute

4500 Fifth Avenue

Pittsburgh, PA 15213-2612

412-268-5800

[Office Locations](http://www.sei.cmu.edu/locations/index.cfm) | [Additional Sites Directory](http://www.sei.cmu.edu/additional-sites-directory/index.cfm) | [Legal](https://vuls.cert.org/confluence/display/VIN/VINCE%2BCode%2Bof%2BConduct#VINCECodeofConduct-TermsofUse) | [Privacy Notice](https://www.sei.cmu.edu/legal/privacy-notice/index.cfm) | [CMU Ethics Hotline](https://www.cmu.edu/hr/ethics-hotline/) | [www.sei.cmu.edu](http://www.sei.cmu.edu)

Â©2022 Carnegie Mellon University

[Contact SEI](https://www.sei.cmu.edu/contact-us/)
#### Contact CERT/CC

 412-268-5800


