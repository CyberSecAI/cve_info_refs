```
{
  "vulnerability_details": {
    "root_cause": "A reentrancy issue in the `CMapElement::Notify` function within Internet Explorer's MSHTML engine. Specifically, the function is not designed to be reentrant, and nested `readystatechange` events can lead to unexpected behavior.",
    "weaknesses": [
      "Use-after-free vulnerability",
        "Non-reentrant function `CMapElement::Notify`",
        "Improper handling of nested `readystatechange` events",
        "Memory corruption due to improper object management"

    ],
    "impact": "Remote code execution through memory corruption. By exploiting this vulnerability, an attacker can gain the same user rights as the current user. If the user has administrative rights, the attacker can take complete control of the system.",
    "attack_vectors": [
      "Specially crafted web page",
      "Compromised websites hosting malicious content",
          "Websites hosting user-provided content or advertisements with malicious content"

    ],
    "attacker_capabilities": "The attacker needs to convince a user to view a specially crafted web page, typically through social engineering tactics like sending a link via email or instant message, or through compromised websites or advertisements. Javascript must be enabled." ,
     "additional_details": "The vulnerability arises from the interaction between `DocumentFragment` manipulation, applet elements, and the firing of `readystatechange` events. When a `DocumentFragment` containing an applet element is added to the DOM, elements receive notifications regarding their removal from and addition to a `CMarkup`. The addition of an applet creates a `CObjectElement` which then triggers a nested `readystatechange` event which interrupts the flow of the first event. Elements following the applet within the `DocumentFragment` may then receive an additional notification to remove them from a `CMarkup` before they are notified of their addition to another one. This sequence can corrupt the linked list used by the CMapElement and lead to a use-after-free condition."
  }
}
```