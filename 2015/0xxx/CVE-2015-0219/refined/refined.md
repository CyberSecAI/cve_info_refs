```
{
  "CVE-2015-0219": {
    "description": "Django before 1.4.18, 1.6.x before 1.6.10, and 1.7.x before 1.7.3 allows remote attackers to spoof WSGI headers by using an _ (underscore) character instead of a - (dash) character in an HTTP header, as demonstrated by an X-Auth_User header.",
    "vulnerability_details": {
      "root_cause": "The WSGI environ normalizes HTTP headers by converting them to uppercase, converting dashes to underscores, and prepending 'HTTP_'. This process makes it impossible to differentiate between headers with dashes and those with underscores.",
      "weaknesses": [
        "WSGI header normalization conflates dashes and underscores."
      ],
       "impact": "An attacker can bypass security measures that rely on specific header names (e.g., 'X-Auth-User') by providing a header with underscores ('X-Auth_User') which will be normalized to the same value ('HTTP_X_AUTH_USER') by WSGI.",
      "attack_vectors": [
        "Sending an HTTP request with a modified header containing underscores instead of dashes."
      ],
        "attacker_capabilities": "The attacker needs to be able to send HTTP requests to the server. The attacker needs no specific access credentials and can be an unauthenticated remote user."
    },
      "affected_versions": [
        "Django before 1.4.18",
        "Django 1.6.x before 1.6.10",
        "Django 1.7.x before 1.7.3"
      ],
        "patches": [
        "Django master development branch",
        "Django 1.7 release branch",
        "Django 1.6 release branch",
        "Django 1.4 release branch"
      ]
  },
  "CVE-2015-0220": {
    "description": "The django.util.http.is_safe_url function in Django before 1.4.18, 1.6.x before 1.6.10, and 1.7.x before 1.7.3 does not properly handle leading whitespaces, which allows remote attackers to conduct cross-site scripting (XSS) attacks via a crafted URL, related to redirect URLs, as demonstrated by a \"\\njavascript:\" URL.",
    "vulnerability_details": {
      "root_cause": "The `is_safe_url()` function in Django does not strip leading whitespace from URLs, which allows crafted URLs like `\\njavascript:...` to be considered safe.",
      "weaknesses": [
        "Insufficient input validation of redirect URLs."
      ],
       "impact": "If a developer uses `is_safe_url()` to sanitize redirect URLs and then uses these URLs in links, an attacker can inject JavaScript, leading to XSS attacks.",
      "attack_vectors": [
        "Sending a request with a crafted redirect URL containing leading whitespaces followed by a malicious JavaScript payload."
      ],
      "attacker_capabilities": "The attacker needs to be able to influence the redirect URL parameter. The attacker needs no specific access credentials and can be an unauthenticated remote user."
    },
    "affected_versions": [
        "Django before 1.4.18",
        "Django 1.6.x before 1.6.10",
        "Django 1.7.x before 1.7.3"
      ],
        "patches": [
        "Django master development branch",
        "Django 1.7 release branch",
        "Django 1.6 release branch",
        "Django 1.4 release branch"
      ]
  },
  "CVE-2015-0221": {
    "description": "The django.views.static.serve view in Django before 1.4.18, 1.6.x before 1.6.10, and 1.7.x before 1.7.3 reads files an entire line at a time, which allows remote attackers to cause a denial of service (memory consumption) via a long line in a file.",
    "vulnerability_details": {
      "root_cause": "The `django.views.static.serve()` view reads files line by line. When a file contains a very long line without any newlines, the memory usage increases to the size of that entire line.",
      "weaknesses": [
        "Inefficient file reading mechanism in `django.views.static.serve()` leads to high memory consumption."
      ],
       "impact": "An attacker can cause a denial-of-service attack by requesting a large file with no newlines. This can result in excessive memory usage and potentially crash the server.",
      "attack_vectors": [
        "Sending HTTP requests for static files containing excessively long lines without newlines."
      ],
       "attacker_capabilities": "The attacker needs to send a large amount of HTTP requests targeting a static file containing excessively long lines without newlines. The attacker needs no specific access credentials and can be an unauthenticated remote user."
    },
    "affected_versions": [
        "Django before 1.4.18",
        "Django 1.6.x before 1.6.10",
        "Django 1.7.x before 1.7.3"
      ],
        "patches": [
        "Django master development branch",
        "Django 1.7 release branch",
        "Django 1.6 release branch",
        "Django 1.4 release branch"
      ]
  },
  "CVE-2015-0222": {
    "description": "ModelMultipleChoiceField in Django 1.6.x before 1.6.10 and 1.7.x before 1.7.3, when show_hidden_initial is set to True, allows remote attackers to cause a denial of service by submitting duplicate values, which triggers a large number of SQL queries.",
    "vulnerability_details": {
      "root_cause": "When a form with `ModelMultipleChoiceField` has `show_hidden_initial=True`, submitting duplicate values for the field's data causes an excessive number of SQL queries.",
      "weaknesses": [
         "Insufficient input validation in ModelMultipleChoiceField, allowing duplicate values."
      ],
       "impact": "An attacker can cause a denial-of-service attack by submitting forms with duplicate values for a `ModelMultipleChoiceField`, leading to a database overload through excessive SQL queries.",
      "attack_vectors": [
        "Submitting a form with duplicate values for fields using `ModelMultipleChoiceField` when `show_hidden_initial=True`."
      ],
       "attacker_capabilities": "The attacker needs to be able to send HTTP requests to the server and be able to manipulate form input. The attacker needs no specific access credentials and can be an unauthenticated remote user."
    },
       "affected_versions": [
        "Django 1.6.x before 1.6.10",
        "Django 1.7.x before 1.7.3"
      ],
        "patches": [
         "Django master development branch",
        "Django 1.7 release branch",
        "Django 1.6 release branch"
      ]
  },
    "CVE-2015-2316": {
    "description": "The utils.html.strip_tags function in Django 1.6.x before 1.6.11, 1.7.x before 1.7.7, and 1.8.x before 1.8c1, when using certain versions of Python, allows remote attackers to cause a denial of service (infinite loop) by increasing the length of the input string.",
       "vulnerability_details": {
          "root_cause": "The `utils.html.strip_tags` function in Django can enter an infinite loop when processing long input strings.",
          "weaknesses": [
            "Inadequate handling of long strings in the `strip_tags` function leads to an infinite loop"
           ],
          "impact": "A remote attacker can cause a denial-of-service attack by submitting a long crafted input string to the `strip_tags` function, which will lead to the function entering an infinite loop.",
          "attack_vectors": [
            "Sending a request with a very long input string to the `strip_tags` function."
            ],
           "attacker_capabilities":"The attacker needs to be able to send a request with a crafted input to the `strip_tags` function. The attacker needs no specific access credentials and can be an unauthenticated remote user."
        },
        "affected_versions": [
            "Django 1.6.x before 1.6.11",
            "Django 1.7.x before 1.7.7",
            "Django 1.8.x before 1.8c1"
          ],
            "patches": [
           "SUSE Enterprise Storage 1.0",
           "SUSE OpenStack Cloud 4",
           "SUSE OpenStack Cloud 5"
          ]
      }
}
```