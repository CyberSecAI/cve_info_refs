```
{
  "CVE-2015-0239": {
    "Description": "The em_sysenter function in arch/x86/kvm/emulate.c in the Linux kernel before 3.18.5, when the guest OS lacks SYSENTER MSR initialization, allows guest OS users to gain guest OS privileges or cause a denial of service (guest OS crash) by triggering use of a 16-bit code segment for emulation of a SYSENTER instruction.",
    "Root cause of vulnerability": "Insufficient sysenter instruction emulation in the Linux kernel's KVM subsystem when invoked from 16-bit code. Specifically, the hypervisor does not check if the IA32_SYSENTER_CS selector is zero in 16-bit mode. Also it does not generate a #GP exception, but instead it sets the guest instruction pointer to zero and changes the code privilege level (CPL) to zero.",
    "Weaknesses": [
      "The KVM subsystem did not properly emulate the SYSENTER instruction when invoked from 16-bit code.",
      "Lack of proper validation of the IA32_SYSENTER_CS selector in 16-bit mode.",
      "Failure to generate a #GP exception as real hardware would."
    ],
    "Impact of exploitation": "An unprivileged guest user can escalate their privileges within the guest OS, or cause a denial of service (guest OS crash). In certain specific setups, privilege escalation can occur if the guest process is able to access the first memory page whose virtual address is zero. Without access to address zero, a guest DoS is possible.",
    "Attack vectors": "An unprivileged guest user can trick the hypervisor into emulating a SYSENTER instruction while in 16-bit mode. This involves crafting specific guest code to trigger the vulnerability. The attack may also be triggered on an SMP guest via a race condition.",
    "Required attacker capabilities/position": "Attacker requires the ability to execute code within a guest OS. The guest OS must not initialize the SYSENTER model-specific registers (MSRs). In the case of privilege escalation, the guest must be able to access the memory page at address zero."
  }
}
```