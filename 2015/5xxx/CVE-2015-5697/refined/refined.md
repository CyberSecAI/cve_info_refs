```
{
  "CVE-2015-5697": {
    "description": "Benjamin Randazzo discovered an information leak in the md (multiple device) driver when the bitmap_info.file is disabled. A local privileged attacker could use this to obtain sensitive information from the kernel. The get_bitmap_file function in drivers/md/md.c in the Linux kernel before 4.1.6 does not initialize a certain bitmap data structure, which allows local users to obtain sensitive information from kernel memory via a GET_BITMAP_FILE ioctl call.",
    "affected_versions": [
      "kernel before 4.1.6",
      "Ubuntu 12.04",
      "Ubuntu 14.04",
       "Ubuntu 15.04"
    ],
    "root_cause": "The md driver's `get_bitmap_file()` function uses `kmalloc()` to allocate memory for a `mdu_bitmap_file_t` structure. When the bitmap feature is disabled, only the first byte of this buffer is zeroed out. The entire buffer is then copied to user space, leading to a kernel memory information leak.",
    "vulnerabilities": [
      "Information Leak"
    ],
    "impact": "A local privileged attacker can read up to 4095 bytes of kernel memory, potentially revealing sensitive information.",
    "attack_vectors": [
      "Local access to the system",
      "Specifically crafted ioctl call (`GET_BITMAP_FILE`)"
    ],
    "attacker_capabilities": [
      "Local privileged access to the system is required."
    ],
       "more_info": "The vulnerability occurs in the `get_bitmap_file()` function of the Linux kernel's md driver (drivers/md/md.c). When the bitmap feature is disabled for a multiple device (md) setup, the function allocates a buffer for mdu_bitmap_file_t using kmalloc, but only zeroes the first byte. Then the function copies the whole buffer to userspace. If the user requests to read bitmap_info.file while bitmap is disabled only the first byte is overwritten with NULL, leaving the rest of uninitialized buffer contents available to the user. This leads to information disclosure of kernel memory. The vulnerability is fixed by allocating the buffer with kzalloc, which ensures that the allocated memory is zeroed."
  },
   "CVE-2015-6252": {
    "description": "Marc-Andr√© Lureau discovered that the vhost driver did not properly release the userspace provided log file descriptor. A privileged attacker could use this to cause a denial of service (resource exhaustion). The vhost_dev_ioctl function in drivers/vhost/vhost.c in the Linux kernel before 4.1.5 allows local users to cause a denial of service (memory consumption) via a VHOST_SET_LOG_FD ioctl call that triggers permanent file-descriptor allocation.",
    "affected_versions": [
      "Linux kernel before 4.1.5",
      "Ubuntu 12.04",
      "Ubuntu 14.04",
        "Ubuntu 15.04"
    ],
      "root_cause": "The vhost driver does not properly release file descriptors provided by user space through the VHOST_SET_LOG_FD ioctl call. Each call to this ioctl leads to a file descriptor allocation, which, when not released, can lead to resource exhaustion.",
      "vulnerabilities": [
        "Resource Exhaustion",
      "Denial of Service"
    ],
      "impact": "A local privileged attacker can cause a denial of service by exhausting kernel memory resources.",
      "attack_vectors": [
        "Local access to the system",
        "Abuse of the VHOST_SET_LOG_FD ioctl call on /dev/vhost-net devices."
      ],
      "attacker_capabilities": [
         "Local privileged access is required."
      ],
          "more_info": "The vulnerability exists in the vhost_dev_ioctl function in drivers/vhost/vhost.c.  The vhost driver does not properly handle the userspace provided file descriptor when a VHOST_SET_LOG_FD ioctl call is made. The file descriptor is allocated but is never properly released, and repeated calls will cause a resource exhaustion. This can be exploited by a privileged user to cause a denial of service."
  },
  "CVE-2015-5156": {
      "description": "It was discovered that virtio networking in the Linux kernel did not handle fragments correctly, leading to kernel memory corruption. A remote attacker could use this to cause a denial of service (system crash) or possibly execute code with administrative privileges. The virtnet_probe function in drivers/net/virtio_net.c in the Linux kernel before 4.2 attempts to support a FRAGLIST feature without proper memory allocation, which allows guest OS users to cause a denial of service (buffer overflow and memory corruption) via a crafted sequence of fragmented packets.",
      "affected_versions": [
          "Linux kernel before 4.2",
          "Ubuntu 14.04 ESM"
      ],
        "root_cause": "The virtio networking driver in the Linux kernel attempts to handle FRAGLIST features without proper memory allocation. When the guest sends multiple fragmented packets, the driver attempts to combine and process them without sufficient allocated buffer space. This leads to a buffer overflow and memory corruption.",
        "vulnerabilities": [
          "Memory Corruption",
        "Buffer Overflow",
          "Denial of Service",
        "Remote Code Execution (Possible)"
        ],
        "impact": "A remote attacker, typically a guest OS user in a virtualized environment, could cause a denial of service (system crash) or potentially execute arbitrary code with administrative privileges within the host.",
        "attack_vectors": [
          "Remote network access",
          "Exploiting virtio networking"
        ],
        "attacker_capabilities": [
          "A guest user able to send network packets.  (Guest-to-host attack)"
        ],
          "more_info": "The vulnerability is triggered in the virtnet_probe function of drivers/net/virtio_net.c. When the virtio network device is probed, the code incorrectly handles the FRAGLIST feature. If a guest system sends fragmented packets to a host with a vulnerable kernel, the system can suffer a buffer overflow which results in denial of service and possibly code execution. The vulnerability occurs when the code attempts to handle multiple network fragments using insufficient memory. This can result in a system crash."
    },
  "CVE-2015-6937": {
      "description": "It was discovered that the Reliable Datagram Sockets (RDS) implementation in the Linux kernel did not verify sockets were properly bound before attempting to send a message, which could cause a NULL pointer dereference. An attacker could use this to cause a denial of service (system crash). The __rds_conn_create function in net/rds/connection.c in the Linux kernel through 4.2.3 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by using a socket that was not properly bound.",
    "affected_versions": [
        "Linux kernel through 4.2.3",
           "Ubuntu 14.04 ESM"
    ],
        "root_cause": "The RDS (Reliable Datagram Sockets) implementation lacks proper verification that a socket is bound before attempting to send a message. A socket that is not properly bound before attempting to send a message leads to a NULL pointer dereference.",
        "vulnerabilities": [
            "NULL Pointer Dereference",
            "Denial of Service"
          ],
        "impact": "A local user can cause a system crash by triggering a NULL pointer dereference.",
        "attack_vectors": [
            "Local access to the system",
           "Using an unbound socket"
        ],
        "attacker_capabilities": [
           "Local user access"
        ],
    "more_info": "The vulnerability exists in the __rds_conn_create function within net/rds/connection.c. If a socket is not properly bound before attempting to send a message, the lack of a check for the underlying transport's existence leads to a NULL pointer dereference. An attacker could exploit this by creating an unbound socket and then triggering the vulnerable code path, causing the system to crash."
  },
  "CVE-2015-7312": {
      "description": "Ben Hutchings discovered that the Advanced Union Filesystem (aufs) for the Linux kernel did not correctly handle references of memory mapped files from an aufs mount. A local attacker could use this to cause a denial of service (system crash) or possibly execute arbitrary code with administrative privileges.",
      "affected_versions": [
          "Linux kernel",
      "Ubuntu 14.04 ESM"
      ],
        "root_cause": "The Advanced Union Filesystem (aufs) does not correctly manage references to memory mapped files when used in an aufs mount. This improper handling could lead to a use-after-free vulnerability when references to mmapped files are released from an aufs mount.",
        "vulnerabilities": [
           "Use-After-Free",
            "Denial of Service",
        "Remote Code Execution (Possible)"
        ],
        "impact": "A local attacker could exploit this flaw to cause a denial of service (system crash) or potentially achieve arbitrary code execution with administrative privileges.",
        "attack_vectors": [
          "Local access to the system",
          "Triggering specific actions with memory mapped files and AUFS mounts."
        ],
        "attacker_capabilities": [
            "Local User Access."
        ],
          "more_info": "The vulnerability arises from incorrect handling of memory mapped files in the aufs filesystem. Specifically, memory mapped files that are part of an aufs mount do not properly manage their references, and can be freed while still being accessed in the system. This use-after-free condition can lead to arbitrary code execution."
  },
    "CVE-2015-5706": {
       "description": "An user triggerable use-after-free vulnerability in path lookup in the Linux kernel could potentially lead to privilege escalation.",
      "affected_versions": [
        "Linux kernel"
        ],
          "root_cause": "The vulnerability is related to a use-after-free condition in the Linux kernel's path lookup mechanism.",
           "vulnerabilities": [
            "Use-After-Free",
          "Privilege Escalation (Possible)"
            ],
           "impact": "A local attacker could potentially exploit this use-after-free to escalate privileges or cause a denial-of-service.",
          "attack_vectors": [
            "Local access to the system"
           ],
           "attacker_capabilities": [
            "Local User Access"
           ],
          "more_info": "This vulnerability is in the Linux kernel's path lookup mechanism, where a use-after-free condition can be triggered. The improper management of memory during path lookup could allow an attacker to cause corruption which would allow for exploitation for privilege escalation."
   },
     "CVE-2015-5283": {
       "description": "The sctp_init function in net/sctp/protocol.c in the Linux kernel before 4.2.3 has an incorrect sequence of protocol-initialization steps, which allows local users to cause a denial of service (panic or memory corruption) by creating SCTP sockets before all of the steps have finished.",
    "affected_versions": [
           "Linux kernel before 4.2.3"
          ],
        "root_cause": "The SCTP initialization routine (`sctp_init`) in the Linux kernel has an incorrect initialization sequence. This race condition allows multiple sockets to be created in parallel before the full initialization process is finished. This leads to a system panic or memory corruption.",
        "vulnerabilities": [
            "Denial of Service",
        "Memory Corruption",
            "Race Condition"
        ],
        "impact": "A local user can cause a system crash by creating multiple SCTP sockets in parallel before all steps have finished.",
        "attack_vectors": [
          "Local access to the system",
           "Creating multiple sockets in parallel"
        ],
         "attacker_capabilities": [
             "Local user access"
           ],
           "more_info": "The vulnerability arises from a race condition during the SCTP protocol initialization in the Linux kernel. The sctp_init function does not properly synchronize steps during the initialization of the SCTP module. This allows multiple threads to create sockets simultaneously before all initialization steps are finished, leading to a NULL pointer dereference, panic or memory corruption. This vulnerability can only be triggered when multiple SCTP sockets are created in parallel while the SCTP module is in the process of loading into the kernel."
        },
        "CVE-2015-5707": {
          "description": "An integer overflow in the SCSI generic driver in the Linux kernel was discovered. A local user with write permission on a SCSI generic device could potentially exploit this flaw for privilege escalation.",
          "affected_versions": [
            "Linux kernel"
          ],
           "root_cause": "An integer overflow exists in the SCSI generic driver of the Linux kernel. An operation that handles a write size from a SCSI generic device does not correctly handle potential overflows.",
            "vulnerabilities": [
           "Integer Overflow",
           "Privilege Escalation (Possible)"
         ],
            "impact": "A local user with write permissions to a SCSI generic device could exploit this flaw to escalate their privileges.",
          "attack_vectors": [
              "Local access to the system",
              "Write permission to a SCSI generic device"
           ],
            "attacker_capabilities": [
               "Local User Access and write permissions to a SCSI generic device."
            ],
             "more_info": "This vulnerability occurs due to an integer overflow in a SCSI generic driver function used to handle the write data length. A local user with write privileges to a SCSI generic device could potentially provide a very large value that overflows internally. This could cause the system to perform an out-of-bounds write in a kernel memory location, allowing a local privileged user to exploit this issue for privilege escalation. "
    },
    "CVE-2015-5366": {
     "description": "It was discovered that the Linux kernel does not properly handle invalid UDP checksums. A remote attacker can cause a denial of service against applications that use epoll by injecting a single packet with an invalid checksum.",
     "affected_versions": [
       "Linux kernel"
     ],
       "root_cause": "The Linux kernel does not correctly process incoming UDP packets with invalid checksums when the application uses epoll. A race condition during the processing of invalid checksum packets can occur.",
      "vulnerabilities": [
           "Denial of Service"
       ],
       "impact": "A remote attacker could trigger this issue with only one crafted UDP packet, causing a denial of service against applications using the epoll functionality.",
        "attack_vectors": [
            "Remote network access",
          "Crafted UDP packet with invalid checksum"
       ],
        "attacker_capabilities": [
          "Remote unauthenticated attacker"
       ],
        "more_info": "This vulnerability involves a flaw in the handling of UDP packets with incorrect checksums within the Linux kernel. If an application uses the epoll function, specifically using EPOLLET, the kernel can enter a race condition while processing packets with bad checksums. This allows a remote unauthenticated attacker to trigger a DoS by sending a specific type of crafted UDP packet."
    },
     "CVE-2015-5364": {
     "description": "It was discovered that the Linux kernel does not properly handle invalid UDP checksums. A remote attacker could exploit this flaw to cause a denial of service using a flood of UDP packets with invalid checksums.",
    "affected_versions": [
        "Linux kernel"
     ],
      "root_cause": "The Linux kernel does not properly handle invalid UDP checksums when receiving a flood of UDP packets. A lack of validation or handling in the kernel when dealing with multiple UDP packets with invalid checksums can lead to a denial of service.",
        "vulnerabilities": [
          "Denial of Service"
          ],
        "impact": "A remote attacker could exploit this flaw by causing a denial of service through a flood of UDP packets with invalid checksums.",
        "attack_vectors": [
            "Remote network access",
          "Flood of UDP packets with invalid checksums."
        ],
        "attacker_capabilities": [
            "Remote unauthenticated attacker"
        ],
      "more_info": "The vulnerability exists in the kernel's handling of UDP packets. If the kernel receives a large number of UDP packets, each having an incorrect checksum, the kernel may become unresponsive. A remote attacker could send such crafted packets in order to cause a denial-of-service condition."
    },
      "CVE-2015-1333": {
     "description": "Colin Ian King discovered a flaw in the add_key function of the Linux kernel's keyring subsystem. A local user can exploit this flaw to cause a denial of service due to memory exhaustion.",
     "affected_versions": [
           "Linux Kernel"
        ],
          "root_cause": "The Linux kernel's keyring subsystem has a flaw in the add_key function, where uncontrolled memory allocations can occur if certain parameters are passed, leading to resource exhaustion.",
        "vulnerabilities": [
           "Resource exhaustion",
            "Denial of Service"
           ],
         "impact": "A local user can exploit this flaw to cause a denial of service by exhausting the system's memory.",
         "attack_vectors": [
           "Local access to the system",
            "Calling the `add_key` operation in specific ways"
          ],
         "attacker_capabilities": [
           "Local User Access"
        ],
          "more_info": "This vulnerability exists in the keyring subsystem of the Linux kernel's add_key function, which does not adequately manage memory allocation when adding a key. By carefully crafting the user-provided input to trigger repeated uncontrolled allocation of memory, an attacker can exhaust memory resources and cause a denial of service on the system."
  },
  "CVE-2015-3212": {
         "description": "Ji Jianwen of Red Hat Engineering discovered a flaw in the handling of the SCTPs automatic handling of dynamic multi-homed connections. A local attacker could use this flaw to cause a crash or potentially for privilege escalation.",
         "affected_versions": [
            "Linux kernel"
         ],
          "root_cause": "There is a vulnerability in the Linux kernel's handling of SCTP connections when used in automatic multi-homing mode. The kernel does not correctly process the parameters or data structures which may lead to an exploitable crash or privilege escalation.",
           "vulnerabilities": [
             "Denial of Service",
           "Privilege Escalation (Possible)"
              ],
           "impact": "A local attacker can crash the system or potentially elevate privileges by exploiting the flawed handling of SCTP multi-homed connections.",
           "attack_vectors": [
             "Local access to the system",
             "Exploitation using specially crafted SCTP connections"
            ],
          "attacker_capabilities": [
             "Local User Access"
            ],
        "more_info": "This vulnerability is in the handling of SCTP when automatic multi-homing is enabled. A local user can exploit a race condition in the SCTP processing that can lead to a denial of service or possible privilege escalation. The kernel did not properly process all the necessary elements required for multi-homing. The specific function is not named in the description, but has been identified within the code path for handling multi-homed SCTP connections."
        },
         "CVE-2015-4692": {
          "description": "A NULL pointer dereference flaw was found in the kvm_apic_has_events function in the KVM subsystem. A unprivileged local user could exploit this flaw to crash the system kernel resulting in denial of service.",
          "affected_versions": [
            "Linux kernel"
            ],
           "root_cause": "The KVM subsystem has a vulnerability in the kvm_apic_has_events function, which lacks a proper null check, resulting in a null pointer dereference.",
           "vulnerabilities": [
              "NULL Pointer Dereference",
             "Denial of Service"
            ],
           "impact": "An unprivileged local user can cause a kernel panic and denial of service by triggering a NULL pointer dereference in the KVM subsystem.",
            "attack_vectors": [
                "Local access to the system",
              "Specific usage of KVM"
           ],
            "attacker_capabilities": [
                "Local user access",
          "Ability to interact with KVM to trigger the specific code path"
             ],
          "more_info": "This vulnerability is due to an incorrect null pointer check in the kvm_apic_has_events() function inside the KVM subsystem. A local user can craft an input or scenario that triggers the faulty logic, and thus causes the kernel to crash via a NULL pointer dereference."
   }
}
```