=== Content from access.redhat.com_0605d26b_20250126_110321.html ===


[Skip to navigation](#pfe-navigation)
[Skip to main content](#cp-main)
### Utilities

* [Subscriptions](https://access.redhat.com/management/)
* [Downloads](https://access.redhat.com/downloads/)
* [Red Hat Console](//console.redhat.com/)
* [Get Support](https://access.redhat.com/support/)

[![Red Hat Customer Portal](https://access.redhat.com/chrome_themes/nimbus/img/red-hat-customer-portal.svg)](https://access.redhat.com/)

* [Subscriptions](https://access.redhat.com/management/)
* [Downloads](https://access.redhat.com/downloads/)
* [Red Hat Console](//console.redhat.com/)
* [Get Support](https://access.redhat.com/support/)
* [Products](https://access.redhat.com/)
  ### Top Products

  + [Red Hat Enterprise Linux](https://access.redhat.com/products/red-hat-enterprise-linux/)
  + [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform)
  + [Red Hat Ansible Automation Platform](https://access.redhat.com/products/red-hat-ansible-automation-platform/)
  [All Products](https://access.redhat.com/products/)

  ### Downloads and Containers

  + [Downloads](https://access.redhat.com/downloads/)
  + [Packages](https://access.redhat.com/downloads/content/package-browser)
  + [Containers](https://catalog.redhat.com/software/containers/explore/)
  ### Top Resources

  + [Documentation](//docs.redhat.com/)
  + [Product Life Cycles](https://access.redhat.com/product-life-cycles/)
  + [Product Compliance](https://access.redhat.com/articles/1202803)
  + [Errata](https://access.redhat.com/errata/)
* [Knowledge](https://access.redhat.com/labs/)
  ### Red Hat Knowledge Center

  + [Knowledgebase Solutions](https://access.redhat.com/search/?q=*&p=1&rows=10&documentKind=Solution)
  + [Knowledgebase Articles](https://access.redhat.com/search/?q=*&p=1&rows=10&documentKind=Article)
  + [Customer Portal Labs](https://access.redhat.com/labs/)
  + [Errata](https://access.redhat.com/errata/)
  ### Top Product Docs

  + [Red Hat Enterprise Linux](//docs.redhat.com/en/documentation/red_hat_enterprise_linux/)
  + [Red Hat OpenShift](//docs.redhat.com/en/documentation/openshift_container_platform/)
  + [Red Hat Ansible Automation Platform](//docs.redhat.com/en/documentation/red_hat_ansible_automation_platform/)
  [All Product Docs](//docs.redhat.com/en/products)

  ### [Training and Certification](//www.redhat.com/en/services/training-and-certification)

  + [About](//www.redhat.com/en/services/training-and-certification)
  + [Course Index](//www.redhat.com/en/services/training/all-courses-exams)
  + [Certification Index](//www.redhat.com/en/services/certifications)
  + [Skill Assessment](//skills.ole.redhat.com/)
* [Security](https://access.redhat.com/security/)
  ### [Red Hat Product Security Center](https://access.redhat.com/security)

  + [Security Updates](https://access.redhat.com/security)
  + [Security Advisories](https://access.redhat.com/security/security-updates/#/security-advisories)
  + [Red Hat CVE Database](https://access.redhat.com/security/security-updates/#/cve)
  + [Errata](https://access.redhat.com/errata/)
  ### References

  + [Security Bulletins](https://access.redhat.com/security/vulnerabilities)
  + [Security Measurement](https://www.redhat.com/security/data/metrics/)
  + [Severity Ratings](https://access.redhat.com/security/updates/classification/)
  + [Security Data](https://access.redhat.com/security/data)
  ### Top Resources

  + [Security Labs](https://access.redhat.com/security/security-updates/#/security-labs)
  + [Backporting Policies](https://access.redhat.com/security/updates/backporting/)
  + [Security Blog](//redhat.com/en/blog/channel/security)
* [Support](https://access.redhat.com/support/)
  ### [Red Hat Support](https://access.redhat.com/support/)

  + [Support Cases](https://access.redhat.com/support/cases/)
  + [Troubleshoot](https://access.redhat.com/support/cases/#/troubleshoot)
  + [Get Support](https://access.redhat.com/support/)
  + [Contact Red Hat Support](https://access.redhat.com/support/contact/)
  ### [Red Hat Community Support](https://access.redhat.com/community)

  + [Customer Portal Community](https://access.redhat.com/community/)
  + [Community Discussions](https://access.redhat.com/discussions/)
  + [Red Hat Accelerator Program](https://access.redhat.com/accelerators/)
  ### Top Resources

  + [Product Life Cycles](https://access.redhat.com/product-life-cycles/)
  + [Customer Portal Labs](https://access.redhat.com/labs/)
  + [Red Hat JBoss Supported Configurations](https://access.redhat.com/support/configurations/jboss)
  + [Red Hat Insights](https://cloud.redhat.com/insights)

Or [troubleshoot an issue](/support/cases/#/troubleshoot).

English

## Select Your Language

* [English](https://access.redhat.com/changeLanguage?language=en)
* [Français](https://access.redhat.com/changeLanguage?language=fr)
* [한국어](https://access.redhat.com/changeLanguage?language=ko)
* [日本語](https://access.redhat.com/changeLanguage?language=ja)
* [中文 (中国)](https://access.redhat.com/changeLanguage?language=zh_CN)

### Infrastructure and Management

* [Red Hat Enterprise Linux](https://access.redhat.com/products/red-hat-enterprise-linux/)
* [Red Hat Satellite](https://access.redhat.com/products/red-hat-satellite/)
* [Red Hat Subscription Management](https://access.redhat.com/products/red-hat-subscription-management/)
* [Red Hat Insights](https://access.redhat.com/products/red-hat-insights/)
* [Red Hat Ansible Automation Platform](https://access.redhat.com/products/red-hat-ansible-automation-platform/)
### Cloud Computing

* [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform)
* [Red Hat OpenStack Platform](https://access.redhat.com/products/red-hat-openstack-platform/)
* [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform/)
* [Red Hat OpenShift AI](https://access.redhat.com/products/red-hat-openshift-ai/)
* [Red Hat OpenShift Dedicated](https://access.redhat.com/products/openshift-dedicated-red-hat/)
* [Red Hat Advanced Cluster Security for Kubernetes](https://access.redhat.com/products/red-hat-advanced-cluster-security-for-kubernetes/)
* [Red Hat Advanced Cluster Management for Kubernetes](https://access.redhat.com/products/red-hat-advanced-cluster-management-for-kubernetes/)
* [Red Hat Quay](https://access.redhat.com/products/red-hat-quay/)
* [Red Hat OpenShift Dev Spaces](https://access.redhat.com/products/red-hat-openshift-dev-spaces)
* [Red Hat OpenShift Service on AWS](https://access.redhat.com/products/red-hat-openshift-service-aws)
### Storage

* [Red Hat Gluster Storage](https://access.redhat.com/products/red-hat-storage/)
* [Red Hat Hyperconverged Infrastructure](https://access.redhat.com/products/red-hat-hyperconverged-infrastructure/)
* [Red Hat Ceph Storage](https://access.redhat.com/products/red-hat-ceph-storage/)
* [Red Hat OpenShift Data Foundation](https://access.redhat.com/products/red-hat-openshift-data-foundation)
### Runtimes

* [Red Hat Runtimes](https://access.redhat.com/products/red-hat-runtimes/)
* [Red Hat JBoss Enterprise Application Platform](https://access.redhat.com/products/red-hat-jboss-enterprise-application-platform/)
* [Red Hat Data Grid](https://access.redhat.com/products/red-hat-data-grid/)
* [Red Hat JBoss Web Server](https://access.redhat.com/products/red-hat-jboss-web-server/)
* [Red Hat build of Keycloak](https://access.redhat.com/products/red-hat-build-of-keycloak/)
* [Red Hat support for Spring Boot](https://access.redhat.com/products/spring-boot/)
* [Red Hat build of Node.js](https://access.redhat.com/products/nodejs/)
* [Red Hat build of Quarkus](https://access.redhat.com/products/quarkus/)
### Integration and Automation

* [Red Hat Application Foundations](https://access.redhat.com/products/red-hat-application-foundations/)
* [Red Hat Fuse](https://access.redhat.com/products/red-hat-fuse/)
* [Red Hat AMQ](https://access.redhat.com/products/red-hat-amq/)
* [Red Hat 3scale API Management](https://access.redhat.com/products/red-hat-3scale/)

[All Products](https://access.redhat.com/products/)

**We're sorry but cve-details doesn't work properly without JavaScript enabled. Please enable it to continue.**

[![Red Hat](https://static.redhat.com/libs/redhat/brand-assets/2/corp/logo--on-dark.svg)](https://redhat.com/en)
[X (formerly Twitter)](https://twitter.com/RedHat)
### Quick Links

* [Downloads](https://access.redhat.com/downloads/)
* [Subscriptions](https://access.redhat.com/management)
* [Support Cases](https://access.redhat.com/support)
* [Customer Service](https://access.redhat.com/support/customer-service)
* [Product Documentation](//docs.redhat.com/)

### Help

* [Contact Us](https://access.redhat.com/support/contact/)
* [Customer Portal FAQ](https://access.redhat.com/articles/33844)
* [Log-in Assistance](https://access.redhat.com/help/login_assistance)

### Site Info

* [Trust Red Hat](https://www.redhat.com/en/trust)
* [Browser Support Policy](https://www.redhat.com/en/about/browser-support)
* [Accessibility](https://www.redhat.com/en/about/digital-accessibility)
* [Awards and Recognition](https://access.redhat.com/recognition/)
* [Colophon](https://access.redhat.com/help/colophon/)

### Related Sites

* [redhat.com](https://www.redhat.com/)
* [developers.redhat.com](http://developers.redhat.com/)
* [connect.redhat.com](https://connect.redhat.com/)
* [cloud.redhat.com](https://cloud.redhat.com/)

### Red Hat legal and privacy links

* [About Red Hat](https://redhat.com/en/about/company)
* [Jobs](https://redhat.com/en/jobs)
* [Events](https://redhat.com/en/events)
* [Locations](https://redhat.com/en/about/office-locations)
* [Contact Red Hat](https://redhat.com/en/contact)
* [Red Hat Blog](https://redhat.com/en/blog)
* [Diversity, equity, and inclusion](https://redhat.com/en/about/our-culture/diversity-equity-inclusion)
* [Cool Stuff Store](https://coolstuff.redhat.com/)
* [Red Hat Summit](https://www.redhat.com/en/summit)

 © 2025 Red Hat, Inc.
### Red Hat legal and privacy links

* [Privacy statement](https://redhat.com/en/about/privacy-policy)
* [Terms of use](https://redhat.com/en/about/terms-use)
* [All policies and guidelines](https://redhat.com/en/about/all-policies-guidelines)
* [Digital accessibility](https://redhat.com/en/about/digital-accessibility)



=== Content from www.openwall.com_f03d815d_20250125_183414.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Hash Suite - Windows password security audit tool. GUI, reports in PDF.](https://hashsuite.openwall.net) | | --- | |
| --- | --- |

[[<prev]](../../../2015/10/02/13) [[next>]](../../../2015/10/04/1) [[<thread-prev]](../../../2015/10/02/8) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-Id: <20151003060708.E1F076C0055@smtpvmsrv1.mitre.org>
Date: Sat,  3 Oct 2015 02:07:08 -0400 (EDT)
From: cve-assign@...re.org
To: qsa@...lys.com
Cc: cve-assign@...re.org, oss-security@...ts.openwall.com
Subject: Re: Qualys Security Advisory - OpenSMTPD Audit Report

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

> (Sorry for the "CVE-2015-ABCD" place-holders in the report, but
> OpenSMTPD's developers were ready with the patches before MITRE was
> ready with the CVE-IDs.)

Qualys had previously sent MITRE a specific disclosure date for the
OpenSMTPD Audit Report that was later than 2015-10-02.

> However, the project is pretty much in its infancy (the first
> stable version, 5.3, was released on March 17, 2013), which explains why
> we discovered various vulnerabilities during our security assessment:

Here are our initial comments:

1. Historically, there have been very few, or perhaps no, other
research reports that identified this volume of distinct bugs and
presented the findings as a complex set of interrelationships among
the bugs.

2. Ideally, we would model this in the normal way (e.g., by
identifying primary and resultant weaknesses); however, it is possible
that we will choose a different approach so that something loosely
resembling a CVE mapping will be available sooner (and remain the
final CVE mapping for this one report).

3. With either of those two options, we feel it is unlikely that the
set of CVE IDs would correspond directly to the CVE-2015-ABCD labels
used in the report.

4. We have been studying some parts of the report and have reached a
tentative conclusion that the use-after-free bug is probably the most
important issue (or among the most important issues) for actual
OpenSMTPD users, because of its role in enabling remote code
execution. At present, this issue has a CVE ID; the remainder of the
report does not yet have a CVE mapping, and we will send another
message here when we have chosen a CVE mapping for it.

Specifically, for this finding:

  - In the IMSG_{SMTP,MTA}_SSL_VERIFY case, PROC_LKA does not reset the
    static pointer req_ca_vrfy_{smtp,mta} to NULL after free(), but trusts
    PROC_PONY to always send an IMSG_{SMTP,MTA}_SSL_VERIFY_CERT (which
    re-initializes this static pointer) before sending an
    IMSG_{SMTP,MTA}_SSL_VERIFY{_CHAIN,} (use-after-free

use CVE-2015-7687.

- --
CVE assignment team, MITRE CVE Numbering Authority
M/S M300
202 Burlington Road, Bedford, MA 01730 USA
[ PGP key available through <http://cve.mitre.org/cve/request_id.html> ]
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQIcBAEBCAAGBQJWD2/1AAoJEL54rhJi8gl5pEcQAL18JC5G0nxCznlCxy22odvc
TCDtrrRXlx6oa5JZebFBdndo1vqVLbe1HY9Mld2WEX+6EvhVaa7zVqXnmEdZbBfF
NXeQZF38hCmVc7JU8AbftfF8Q+au9n2gTBM2nlf07j0dNde7vr9pOS5Ri01O9sRI
vTXCF8b0Yb5qrpevnilp0lRs+A7DcJGciXf+gwQC6Os5isKdmI6L7k9w+g21c5n+
JxeeuuGdviHEl7V/HGu/RmtvfH+7RIi+9sHwkVCC0+/CLXa7FiQ2TGyhnNn4tQCQ
Vq55FKPBOdmya9jDOhRKB1i+pBydn6xS1NRHofIZ+DMg/fckEkI8xQOZaiyr1MoO
oPmbGLH+ZSmCBwuBJoG0NZyP+Tqc8lGsJbgjcAwFcPtz68O6p9l+eCg3qG8rNkEb
yFatKC7v5c8I4KnhahqhcCVbJj/H9Yms5btCcx363DptJlOiEhWl/1lSTggvn0m3
QuBexKBSqn6Cvt4p4CkDbua9QHqAZgQ7tkYJBrFw5x4tFZPvsmeM3gu70TdMCDWW
pWV+fViBcivs1N4anlBTRKRvw5c1lK8vDL+mYYrP2+znoRMYlFcN4zVKbt+UHbHH
wHCuT+jUcfSCw6lO2GMZaNpR2dve2GQe+Ghsz0vRwq9pJsyEU4dUnsw2DdjliE7V
VId8hoQ0y/ovTx8yi8p+
=p4wc
-----END PGP SIGNATURE-----

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from bugzilla.redhat.com_fd81d681_20250125_183416.html ===


* Login
  + Log in using an SSO provider:- [Fedora Account System](saml2_login.cgi?idp=Fedora%20Account%20System&target=show_bug.cgi%3Fid%3D1268793)
    - [Red Hat Associate](saml2_login.cgi?idp=Red%20Hat%20Associate&target=show_bug.cgi%3Fid%3D1268793)
    - [Red Hat Customer](saml2_login.cgi?idp=Red%20Hat%20Customer&target=show_bug.cgi%3Fid%3D1268793)+ Login using a Red Hat Bugzilla account
  + Forgot Password
  + [Create an Account](createaccount.cgi)

Red Hat Bugzilla – Bug 1268793

* [Home](./)
* [New](enter_bug.cgi)
* Search
  + [Simple Search](query.cgi?format=specific)
  + [Advanced Search](query.cgi?format=advanced)
* My Links
  + [Browse](describecomponents.cgi)
  + [Requests](request.cgi)
  + Reports
  + Current State
    - [Search](query.cgi)
    - [Tabular reports](query.cgi?format=report-table)
    - [Graphical reports](query.cgi?format=report-graph)
    - [Duplicates](duplicates.cgi)
  + Other Reports
    - [User Changes](https://bugzilla.redhat.com/page.cgi?id=user_activity.html)
  + Plotly Reports
    - [Bug Status](https://bugzilla.redhat.com/page.cgi?id=bug_status.html)
    - [Bug Severity](https://bugzilla.redhat.com/page.cgi?id=bug_severity.html)
    - [Non-Defaults](https://bugzilla.redhat.com/page.cgi?id=non_defaults.html)
* [Product Dashboard](page.cgi?id=productdashboard.html)

- Help
  * [Page Help!](docs/en/html/using/understanding.html)
  * [Bug Writing Guidelines](page.cgi?id=bug-writing.html)
  * [What's new](page.cgi?id=whats-new.html)
  * [Browser Support Policy](https://access.redhat.com/help/browsers)
  * [5.0.4.rh103 Release notes](page.cgi?id=release-notes.html)
  * [FAQ](page.cgi?id=faq.html)
  * [Guides index](docs/en/html/index.html)
  * [User guide](docs/en/html/using/index.html)
  * [Web Services](docs/en/html/integrating/api/Bugzilla/WebService/Bug.html)
  * [Contact](page.cgi?id=redhat/contact.html)
  * [Legal](page.cgi?id=terms-conditions.html)
- [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")

This site requires JavaScript to be enabled to function correctly, please enable it.

[**Bug 1268793**](show_bug.cgi?id=1268793)
(CVE-2015-7687)
- [CVE-2015-7687](https://access.redhat.com/security/cve/CVE-2015-7687) OpenSMTPD: multiple vulnerabilities fixed in 5.7.2

[Summary:](page.cgi?id=fields.html#short_desc "The bug summary is a short sentence which succinctly describes what the bug is about.")
CVE-2015-7687 OpenSMTPD: multiple vulnerabilities fixed in 5.7.2

| | [Keywords](describekeywords.cgi): | Security | | --- | --- | | [Status](page.cgi?id=fields.html#bug_status): | CLOSED CURRENTRELEASE | | [Alias:](page.cgi?id=fields.html#alias "A short, unique name assigned to a bug in order to assist with looking it up and referring to it in other places in Bugzilla.") | CVE-2015-7687 | | [Product:](describecomponents.cgi "Bugs are categorised into Products and Components. Select a Classification to narrow down this list.") | Security Response | | [Classification:](page.cgi?id=fields.html#classification "Bugs are categorised into Classifications, Products and Components. classifications is the top-level categorisation.") | Other | | [Component:](describecomponents.cgi?product=Security Response "Components are second-level categories; each belongs to a particular Product. Select a Product to narrow down this list.") | vulnerability | | [Sub Component:](page.cgi?id=fields.html#rh_sub_components "The sub component of a specific component") | --- | | [Version:](page.cgi?id=fields.html#version "The version field defines the version of the software the bug was found in.") | unspecified | | [Hardware:](page.cgi?id=fields.html#rep_platform "The hardware platform the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | All | | [OS:](page.cgi?id=fields.html#op_sys "The operating system the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | Linux | | [Priority:](page.cgi?id=fields.html#priority) | high | | [Severity:](page.cgi?id=fields.html#bug_severity) | high | | [Target Milestone:](page.cgi?id=fields.html#target_milestone "The Target Milestone field is used to define when the engineer the bug is assigned to expects to fix it.") | --- | | [Assignee:](page.cgi?id=fields.html#assigned_to "The person in charge of resolving the bug.") | Red Hat Product Security | | [QA Contact:](page.cgi?id=fields.html#qa_contact "The person responsible for confirming this bug if it is unconfirmed, and for verifying the fix once the bug has been resolved.") |  | | [Docs Contact:](page.cgi?id=fields.html#docs_contact "The person responsible for documenting once the bug has been resolved.") |  | | [URL:](page.cgi?id=fields.html#bug_file_loc "Bugs can have a URL associated with them - for example, a pointer to a web site where the problem is seen.") |  | | [Whiteboard:](page.cgi?id=fields.html#status_whiteboard "Each bug has a free-form single line text entry box for adding tags and status information.") |  | | [Depends On:](page.cgi?id=fields.html#dependson "The bugs listed here must be resolved before this bug can be resolved.") | [1268794](show_bug.cgi?id=1268794 "CLOSED ERRATA - CVE-2015-7687 OpenSMTPD: multiple vulnerabilities fixed in 5.7.2 [fedora-all]") [1268795](show_bug.cgi?id=1268795 "CLOSED ERRATA - CVE-2015-7687 OpenSMTPD: multiple vulnerabilities fixed in 5.7.2 [epel-all]") | | [Blocks:](page.cgi?id=fields.html#blocked "This bug must be resolved before the bugs listed in this field can be resolved.") |  | | TreeView+ | [depends on](buglist.cgi?bug_id=1268793&bug_id_type=anddependson&format=tvp) / [blocked](buglist.cgi?bug_id=1268793&bug_id_type=andblocked&format=tvp&tvp_dir=blocked) |  | |  | | [Reported:](page.cgi?id=fields.html#reporter) | 2015-10-05 09:19 UTC by Martin Prpič | | --- | --- | | [Modified:](page.cgi?id=fields.html#modified) | 2021-02-17 04:53 UTC ([History](show_activity.cgi?id=1268793)) | | [CC List:](page.cgi?id=fields.html#cclist) | 3 users (show)  carnil denis jrusnack | | Fixed In Version: | OpenSMTPD 5.7.2 | | | Doc Type: | Bug Fix | | | Doc Text: |  | | | Clone Of: |  | | | Environment: |  | | | Last Closed: | 2015-10-26 19:11:21 UTC | | | Embargoed: |  | | |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| --- | | |

| | Attachments | [(Terms of Use)](page.cgi?id=terms-conditions.html) | | | --- | --- | --- | |  | | | |  |
| --- | --- | --- | --- | --- | --- | --- | --- |

| [Description](show_bug.cgi?id=1268793#c0)  Martin Prpič    2015-10-05 09:19:11 UTC  ``` Several vulnerabilities have been fixed in OpenSMTPD 5.7.2:  - an oversight in the portable version of fgetln() that allows attackers to read and write out-of-bounds memory;  - multiple denial-of-service vulnerabilities that allow local users to kill or hang OpenSMTPD;  - a stack-based buffer overflow that allows local users to crash OpenSMTPD, or execute arbitrary code as the non-chrooted _smtpd user;  - a hardlink attack (or race-conditioned symlink attack) that allows local users to unset the chflags() of arbitrary files;  - a hardlink attack that allows local users to read the first line of arbitrary files (for example, root's hash from /etc/master.passwd);  - a denial-of-service vulnerability that allows remote attackers to fill OpenSMTPD's queue or mailbox hard-disk partition;  - an out-of-bounds memory read that allows remote attackers to crash OpenSMTPD, or leak information and defeat the ASLR protection;  - a use-after-free vulnerability that allows remote attackers to crash OpenSMTPD, or execute arbitrary code as the non-chrooted _smtpd user;  Further details can be found in Qualys' audit report:  <http://seclists.org/oss-sec/2015/q4/17>  MITRE has assigned one CVE for the use-after-free vulnerability; additional CVEs may be assigned:  <http://seclists.org/oss-sec/2015/q4/23>  External References:  <https://www.opensmtpd.org/announces/release-5.7.2.txt> <http://seclists.org/oss-sec/2015/q4/17>   ```  [Comment 1](show_bug.cgi?id=1268793#c1)  Martin Prpič    2015-10-05 09:19:43 UTC  ```  Created opensmtpd tracking bugs for this issue:  Affects: fedora-all [[bug 1268794](show_bug.cgi?id=1268794 "CLOSED ERRATA - CVE-2015-7687 OpenSMTPD: multiple vulnerabilities fixed in 5.7.2 [fedora-all]")] Affects: epel-all [[bug 1268795](show_bug.cgi?id=1268795 "CLOSED ERRATA - CVE-2015-7687 OpenSMTPD: multiple vulnerabilities fixed in 5.7.2 [epel-all]")]   ```  [Comment 2](show_bug.cgi?id=1268793#c2)  Denis Fateyev    2015-10-05 11:38:19 UTC  ``` This update is already in testing. Just edited the descriptions on Bodhi to be more specific on vulnerabilities fixed, and added bugs above.  Everybody interested is encouraged to test the update and give feedback.   ```  [Comment 3](show_bug.cgi?id=1268793#c3)  Denis Fateyev    2015-10-26 19:11:21 UTC  ``` Fixed in opensmtpd version 5.7.3 which is on stable.   ``` |  |
| --- | --- |

---

| Note You need to [log in](show_bug.cgi?id=1268793&GoAheadAndLogIn=1) before you can comment on or make changes to this bug. |
| --- |

---

[Privacy](page.cgi?id=redhat/privacy.html)
[Contact](page.cgi?id=redhat/contact.html)
[FAQ](page.cgi?id=faq.html)
[Legal](page.cgi?id=terms-conditions.html)



=== Content from www.qualys.com_5e818588_20250125_183417.html ===

Qualys Security Advisory
OpenSMTPD Audit Report
========================================================================
Contents
========================================================================
Summary
Approach
Local Vulnerabilities
Remote Vulnerabilities
Inter-Process Vulnerabilities
Miscellaneous Bugs
Acknowledgments
========================================================================
Summary
========================================================================
For the past few months, one of our background projects has been to
audit OpenSMTPD, a free implementation of the server-side Simple Mail
Transfer Protocol (SMTP). OpenSMTPD replaces Sendmail as OpenBSD's
default Mail Transfer Agent (MTA) since OpenBSD 5.6, released on
November 1, 2014.
OpenSMTPD was designed to be secure, reliable, performant, and easy to
configure. Indeed, its codebase lives up to OpenBSD's reputation: it is
clean, modular, privilege-separated, and made our audit easy and really
enjoyable. However, the project is pretty much in its infancy (the first
stable version, 5.3, was released on March 17, 2013), which explains why
we discovered various vulnerabilities during our security assessment:
- an oversight in the portable version of fgetln() that allows attackers
to read and write out-of-bounds memory;
- multiple denial-of-service vulnerabilities that allow local users to
kill or hang OpenSMTPD;
- a stack-based buffer overflow that allows local users to crash
OpenSMTPD, or execute arbitrary code as the non-chrooted \_smtpd user;
- a hardlink attack (or race-conditioned symlink attack) that allows
local users to unset the chflags() of arbitrary files;
- a hardlink attack that allows local users to read the first line of
arbitrary files (for example, root's hash from /etc/master.passwd);
- a denial-of-service vulnerability that allows remote attackers to fill
OpenSMTPD's queue or mailbox hard-disk partition;
- an out-of-bounds memory read that allows remote attackers to crash
OpenSMTPD, or leak information and defeat the ASLR protection;
- a use-after-free vulnerability that allows remote attackers to crash
OpenSMTPD, or execute arbitrary code as the non-chrooted \_smtpd user;
- multiple inter-process vulnerabilities that allow attackers to
escalate from one (already-compromised) OpenSMTPD process to another.
========================================================================
Approach
========================================================================
The OpenSMTPD version that we audited is available at:
https://www.opensmtpd.org/archives/opensmtpd-5.4.4p1.tar.gz
and is installed by default on OpenBSD's latest release (OpenBSD 5.7,
released on May 1, 2015). Unless otherwise noted, the vulnerabilities
that we discovered in OpenSMTPD 5.4.4p1 affect OpenSMTPD's latest
release as well (OpenSMTPD 5.7.1p1, released on June 30, 2015).
The "hybrid approach" that we adopted to review OpenSMTPD is described
in the bible of code auditing, "The Art of Software Security Assessment"
(by Mark Dowd, John McDonald, and Justin Schuh):
- We started with a "top-down approach" and reviewed the high-level
information that we gathered on OpenSMTPD: READMEs, manual pages, web
pages (https://www.opensmtpd.org/presentations/asiabsdcon2013-smtpd/
and https://www.poolp.org/).
This approach allowed us to quickly understand OpenSMTPD's design
(seven privilege-separated, long-running, and event-driven processes
that communicate through UNIX sockets and the imsg API) and identify
its attack surface (local, remote, and inter-process entry points).
- We continued with a "bottom-up approach" and reviewed OpenSMTPD's
implementation: the lowest-level code first (openbsd-compat/ and
smtpd/mproc.c), followed by the higher-level code.
This approach allowed us to quickly identify complex vulnerabilities:
the remote out-of-bounds memory read and use-after-free are actually a
combination of several low-level and high-level bugs.
------------------------------------------------------------------------
Privilege Separation
------------------------------------------------------------------------
--[ PROC\_PARENT ]-------------------------------------------------------
User: root
Chroot: no
Peers: PROC\_CONTROL, PROC\_LKA, PROC\_QUEUE, PROC\_CA, PROC\_PONY
PROC\_PARENT, the "[priv]" process, spawns the six other long-running
processes at startup (by calling fork\_peers() from main()), and the
transient Mail Delivery Agent (MDA) processes on demand (by calling
forkmda() from parent\_imsg()).
If any of its long-running children dies, PROC\_PARENT calls
parent\_shutdown(), kill()s its remaining children, and exit()s, but does
not restart automatically: if we try to exploit a memory corruption, we
have to come up with a one-shot, not a brute-force.
--[ PROC\_CONTROL ]------------------------------------------------------
User: \_smtpd
Chroot: /var/empty
Peers: PROC\_SCHEDULER, PROC\_QUEUE, PROC\_PARENT, PROC\_LKA, PROC\_PONY,
PROC\_CA
PROC\_CONTROL, the "control" process, handles messages from the control
socket "/var/run/smtpd.sock" (by calling control\_dispatch\_ext()), and
gathers statistics from its peers (by calling control\_imsg()).
--[ PROC\_PONY ]---------------------------------------------------------
User: \_smtpd
Chroot: /var/empty
Peers: PROC\_PARENT, PROC\_QUEUE, PROC\_LKA, PROC\_CONTROL, PROC\_CA
PROC\_PONY, the "pony express" process
(https://en.wikipedia.org/wiki/Pony\_Express), handles the server-side
SMTP sessions (by calling smtp\_imsg()), the client-side MTA sessions (by
calling mta\_imsg()), and the local MDA deliveries (by calling
mda\_imsg()).
--[ PROC\_LKA ]----------------------------------------------------------
User: \_smtpd
Chroot: no (needs access to /etc/resolv.conf and /etc/ssl/cert.pem)
Peers: PROC\_PARENT, PROC\_QUEUE, PROC\_CONTROL, PROC\_PONY
PROC\_LKA, the "lookup" process, performs all lookups on behalf of the
other processes: asynchronous DNS resolution (by calling dns\_imsg() and
libasr), user information and credentials lookup, SSL certificate
verification, alias expansion (by calling lka\_imsg()).
--[ PROC\_QUEUE ]--------------------------------------------------------
User: \_smtpq (or \_smtpd if \_smtpq does not exist)
Chroot: /var/spool/smtpd
Peers: PROC\_PARENT, PROC\_CONTROL, PROC\_LKA, PROC\_SCHEDULER, PROC\_PONY
PROC\_QUEUE, the "queue" process, manages the persistent storage of
messages and envelopes (by calling queue\_imsg()). By default, the
smtpd/queue\_fs.c backend is used.
--[ PROC\_SCHEDULER ]----------------------------------------------------
User: \_smtpd
Chroot: /var/empty
Peers: PROC\_CONTROL, PROC\_QUEUE
PROC\_SCHEDULER, the "scheduler" process, knows about all existing
messages and envelopes (by calling scheduler\_imsg()), and decides when
to relay or deliver them. By default, the smtpd/scheduler\_ramqueue.c
backend is used.
--[ PROC\_CA ]-----------------------------------------------------------
User: \_smtpd
Chroot: /var/empty
Peers: PROC\_CONTROL, PROC\_PARENT, PROC\_PONY
PROC\_CA, the "klondike" process
(https://en.wikipedia.org/wiki/Klondike\_Gold\_Rush), performs
privilege-separated RSA encryption and decryption on behalf of PROC\_PONY
(by calling ca\_imsg()).
------------------------------------------------------------------------
Attack Surface
------------------------------------------------------------------------
--[ Local Vectors ]-----------------------------------------------------
----[ .forward
Local users may put a .forward file in their home directory in order to
control how their incoming email is processed and delivered.
When PROC\_PONY receives a CMD\_RCPT\_TO from one of its SMTP clients, it
sends an IMSG\_SMTP\_EXPAND\_RCPT to PROC\_LKA. If the recipient is a local
user, the (unprivileged) PROC\_LKA sends an IMSG\_LKA\_OPEN\_FORWARD to the
(privileged) PROC\_PARENT. If PROC\_PARENT manages to open() the user's
.forward file, it sends its file descriptor back to PROC\_LKA, which
parses and expands its contents.
----[ Control Socket
PROC\_CONTROL calls getpeereid(), or getsockopt(SO\_PEERCRED), in order to
determine the credentials of the clients that connect to its UNIX socket
"/var/run/smtpd.sock". It processes all the messages received from
connections initiated by root, but otherwise processes only the
IMSG\_CTL\_SMTP\_SESSION and forwards it to PROC\_PONY.
Clients normally connect to the control socket with the command-line
program "smtpctl", but we may also connect() to it directly, should we
ever want to exploit a vulnerability in the imsg API, for example.
----[ Offline Directory
The command-line program "smtpctl" can be used to send email (when
invoked as "sendmail"): it connects to the control socket, sends an
IMSG\_CTL\_SMTP\_SESSION to PROC\_CONTROL (which forwards it to PROC\_PONY),
and enqueues the email through this local SMTP session (enqueue() in
smtpd/enqueue.c).
However, if OpenSMTPD is not running, the connection to the control
socket will fail, and "smtpctl" will simply store the email into the
"/var/spool/smtpd/offline" directory, which is mode 01777
(enqueue\_offline() in smtpd/enqueue.c).
Later, when OpenSMTPD restarts, it will execvp() "smtpctl" for each
email stored in the offline directory, exactly as if its owner had just
submitted it for the first time (offline\_enqueue() in smtpd/smtpd.c).
--[ Remote Vectors ]----------------------------------------------------
----[ SMTP Client
By default, OpenSMTPD is configured to accept email from local users,
and connects to remote SMTP servers in order to relay and deliver it.
The code for these client-side MTA sessions (smtpd/mta\_session.c) is
reachable remotely (and is also used for bounces) and represents an
important attack vector.
----[ SMTP Server
OpenSMTPD can be configured to accept email from remote SMTP clients,
and relay or deliver it to local users. The code for these server-side
SMTP sessions (smtpd/smtp\_session.c) is reachable remotely and
represents another important attack vector.
----[ DNS Resolver
The libasr, an asynchronous DNS resolver, is used by OpenSMTPD and
represents yet another remote vector. However, its codebase is pretty
much independent and therefore beyond the scope of our OpenSMTPD audit.
The same can be said of OpenSSL and LibreSSL.
--[ Inter-Process Vectors ]---------------------------------------------
If we ever manage to compromise one of OpenSMTPD's processes, a
vulnerability in the inter-process communication code may allow us to
escalate from an unprivileged, chrooted process to a privileged,
non-chrooted process. For example, pivoting from PROC\_PONY to
PROC\_PARENT, or even PROC\_LKA, would be a good move.
========================================================================
Local Vulnerabilities
========================================================================
------------------------------------------------------------------------
CVE-2015-ABCD - Portable fgetln() can return a zero length
------------------------------------------------------------------------
Constructs similar to the following appear several times throughout
OpenSMTPD's codebase:
while ((buf = fgetln(fp, &len))) {
if (buf[len - 1] == '\n')
buf[len - 1] = '\0';
and:
line = fgetln(s->msgfp, &len);
if (line == NULL) break;
line[len - 1] = '\0';
In theory, if fgetln() succeeds (i.e., does not return NULL) but stores
a 0 length in len, an out-of-bounds memory read and (possibly) write is
triggered. In practice, this is impossible because OpenBSD's libc
implementation of fgetln() guarantees what the manpage says:
The length of the line, including the final newline, is stored
in the memory location to which len points and is guaranteed to
be greater than 0 upon successful completion.
Unfortunately, the portable implementation of fgetln() in
openbsd-compat/fgetln.c (which is used on Linux, at least) offers no
such guarantee:
38 char \*
39 fgetln(stream, len)
40 FILE \*stream;
41 size\_t \*len;
42 {
..
50 if (fgets(buffer, buflen+1, stream) == NULL)
51 return NULL;
52 \*len = strlen(buffer);
..
60 return buffer;
61 }
For example, if fgets() reads the line "\0\n", fgetln() succeeds and
stores a 0 string-length in len (which should be impossible), and the
out-of-bounds memory is accessed upon return.
------------------------------------------------------------------------
CVE-2015-ABCD - Local denial-of-service (invalid imsg)
------------------------------------------------------------------------
The fatalx(NULL) in mproc\_dispatch() can be triggered locally by
connecting directly to the control socket and sending an invalid imsg
(one that is smaller than IMSG\_HEADER\_SIZE or larger than MAX\_IMSGSIZE).
imsg\_get() will fail, fatalx() will be called, and PROC\_CONTROL will
exit() (and, as mentioned earlier, if one OpenSMTPD process dies, all
OpenSMTPD processes die):
187 if ((n = imsg\_get(&p->imsgbuf, &imsg)) == -1) {
188 log\_warn("fatal: %s: error in imsg\_get for %s",
189 proc\_name(smtpd\_process), p->name);
190 fatalx(NULL);
191 }
This local denial-of-service has been discovered independently by
OpenSMTPD's developers and fixed in version 5.4.6p1 (released on June
11, 2015):
188 if ((n = imsg\_get(&p->imsgbuf, &imsg)) == -1) {
189
190 if (smtpd\_process == PROC\_CONTROL &&
191 p->proc == PROC\_CLIENT) {
192 log\_warnx("warn: client sent invalid imsg "
193 "over control socket");
194 p->handler(p, NULL);
195 return;
196 }
197 log\_warn("fatal: %s: error in imsg\_get for %s",
198 proc\_name(smtpd\_process), p->name);
199 fatalx(NULL);
200 }
------------------------------------------------------------------------
CVE-2015-ABCD - Local denial-of-service (file-descriptor exhaustion)
------------------------------------------------------------------------
By connecting locally to the control socket and passing many file
descriptors (~1024) to PROC\_CONTROL (which does not really expect this),
it is possible to exhaust almost all of its available fds.
- In OpenSMTPD 5.4.4p1, PROC\_CONTROL ends up calling fatal("exiting") in
mproc\_dispatch():
153 if ((n = imsg\_read(&p->imsgbuf)) == -1) {
154 log\_warn("warn: %s -> %s: imsg\_read",
155 proc\_name(smtpd\_process), p->name);
156 fatal("exiting");
157 }
- In OpenSMTPD 5.7.1p1, PROC\_CONTROL does not call fatal("exiting")
(thanks to the EAGAIN check at the beginning of mproc\_dispatch()), but
it will never again accept new client connections (because of how
control\_accept() handles file-descriptor exhaustion):
155 if ((n = imsg\_read(&p->imsgbuf)) == -1) {
156 log\_warn("warn: %s -> %s: imsg\_read",
157 proc\_name(smtpd\_process), p->name);
158 if (errno == EAGAIN)
159 return;
160 fatal("exiting");
161 }
There are actually three different ways to trigger this local
denial-of-service:
1/ Send one fd per imsg, with the IMSGF\_HASFD flag turned on: imsg\_get()
will move the fd from ibuf->fds to imsg->fd, but because PROC\_CONTROL
does not expect a fd to be passed, this fd is leaked forever when
imsg\_free() is called by mproc\_dispatch().
2/ Send one fd per imsg, but with the IMSGF\_HASFD flag turned off:
imsg\_get() will leave the fd in ibuf->fds, which are supposed to be
closed when control\_close() is called, but this never happens if all fds
are exhausted first.
3/ Send only one large (>1024) imsg, one byte at a time, with one fd
attached to every single byte sent: this will accumulate all passed fds
into ibuf->fds.
------------------------------------------------------------------------
CVE-2015-ABCD - Local denial-of-service (connection-id wrap)
------------------------------------------------------------------------
In control\_accept(), it is possible to trigger the errx() of the
following tree\_xset() call:
348 c = xcalloc(1, sizeof(\*c), "control\_accept");
349 if (getpeereid(connfd, &c->euid, &c->egid) == -1)
350 fatal("getpeereid");
351 c->id = ++connid;
352 c->mproc.proc = PROC\_CLIENT;
353 c->mproc.handler = control\_dispatch\_ext;
354 c->mproc.data = c;
355 mproc\_init(&c->mproc, connfd);
356 mproc\_enable(&c->mproc);
357 tree\_xset(&ctl\_conns, c->id, c);
If we establish a first connection to the control socket (and keep it
alive), and then establish (and immediately close) new connections in a
loop, the "static uint32\_t connid" will eventually wrap and collide with
our (kept-alive) first connection id, and the exclusive tree\_xset() will
fail and terminate PROC\_CONTROL with errx().
------------------------------------------------------------------------
CVE-2015-ABCD - Local denial-of-service (WIFSTOPPED() child)
------------------------------------------------------------------------
In parent\_sig\_handler(), it is possible to trigger the following
fatalx() call:
366 pid = waitpid(-1, &status, WNOHANG);
367 if (pid <= 0)
368 continue;
...
371 if (WIFSIGNALED(status)) {
...
375 } else if (WIFEXITED(status)) {
...
381 } else
382 fatalx("smtpd: unexpected cause of SIGCHLD");
If the child is ptraced, WIFSIGNALED() and WIFEXITED() can return false,
but WIFSTOPPED() can return true, even if WUNTRACED was not specified in
waitpid(). In order to trigger this in the context of OpenSMTPD, a local
user can add a "|exec /tmp/ptraceme" line to his ~/.forward file, where
ptraceme is a small program that simply calls ptrace(PT\_TRACE\_ME) and
execve() (it does not matter which binary is executed).
------------------------------------------------------------------------
CVE-2015-ABCD - Local denial-of-service (blocking open() call)
------------------------------------------------------------------------
The open() call in parent\_forward\_open() can block forever (if the
~/.forward was created by mkfifo, for example) and this will effectively
block OpenSMTPD as a whole (PROC\_PARENT will not respond to
IMSG\_LKA\_OPEN\_FORWARD and IMSG\_MDA\_FORK requests anymore):
1232 if (! bsnprintf(pathname, sizeof (pathname), "%s/.forward",
1233 directory))
1234 fatal("smtpd: parent\_forward\_open: snprintf");
....
1247 do {
1248 fd = open(pathname, O\_RDONLY);
1249 } while (fd == -1 && errno == EINTR);
------------------------------------------------------------------------
Multiple hardlink attacks in the offline directory
------------------------------------------------------------------------
In the world-writable "/var/spool/smtpd/offline" directory, local users
can create hardlinks to files they do not own, and wait until the server
reboots (or, crash OpenSMTPD with a denial-of-service and wait until the
administrator restarts it) to carry out assorted attacks.
1/ The following code in offline\_enqueue() allows an attacker to
chflags(0) arbitrary files, by hardlinking them to the offline directory
(CVE-2015-ABCD):
1117 if (lstat(path, &sb) == -1) {
1118 log\_warn("warn: smtpd: lstat: %s", path);
1119 \_exit(1);
1120 }
1121
1122 #ifdef HAVE\_CHFLAGS
1123 if (chflags(path, 0) == -1) {
1124 log\_warn("warn: smtpd: chflags: %s", path);
1125 \_exit(1);
1126 }
1127 #endif
2/ The following code in offline\_enqueue() allows an attacker to
execvp() "/usr/sbin/smtpctl" as "sendmail", with a command-line argument
that is the hardlinked file's first line (CVE-2015-ABCD):
1149 if ((fp = fopen(path, "r")) == NULL)
1150 \_exit(1);
....
1160 if ((p = fgetln(fp, &len)) == NULL)
1161 \_exit(1);
....
1167 addargs(&args, "%s", "sendmail");
1168
1169 while ((tmp = strsep(&p, "|")) != NULL)
1170 addargs(&args, "%s", tmp);
....
1179 execvp(PATH\_SMTPCTL, args.list);
1180 \_exit(1);
For example, an attacker can hardlink /etc/master.passwd to the offline
directory, and retrieve its first line (root's encrypted password) by
running ps (or a small program that simply calls sysctl() with
KERN\_FILE\_BYUID and KERN\_PROC\_ARGV) in a loop:
In the attacker's terminal:
$ ln /etc/master.passwd /var/spool/smtpd/offline
$ ./getargs &
[1] 23460
In the administrator's terminal:
# /etc/rc.d/smtpd restart
smtpd(ok)
smtpd(ok)
On the attacker's terminal:
root:$2b$09$pN5WRvGaiPHEXPsrIwSNWe1S0U5iTIvtWqPQgHmd0BAJK02GOYG.W:0:0:daemon:0:0:Charlie &:/root:/bin/ksh
3/ If an attacker controls at least part of another user's file, he can
hardlink this file to the offline directory, and try to exploit one of
the vulnerable fgetln() calls in the enqueue code, which runs with the
privileges of this other user. For example, in offline\_enqueue():
1160 if ((p = fgetln(fp, &len)) == NULL)
1161 \_exit(1);
1162
1163 if (p[len - 1] != '\n')
1164 \_exit(1);
1165 p[len - 1] = '\0';
And in savedeadletter():
898 while ((buf = fgetln(in, &len))) {
899 if (buf[len - 1] == '\n')
900 buf[len - 1] = '\0';
However, we did not investigate this vector any further, because on
OpenBSD (where an attacker is allowed to hardlink another user's file)
fgetln() is not vulnerable, and on Linux (where fgetln() is vulnerable)
an attacker is usually not allowed to hardlink another user's file.
4/ If an attacker is able to reach another user's file (i.e., +x on all
directories that lead to the file) but not read it, he can hardlink the
file to the offline directory, and wait for savedeadletter() to create a
world-readable copy of the file in this other user's home directory:
854 (void)snprintf(buffer, sizeof buffer, "%s/dead.letter", pw->pw\_dir);
...
859 if ((fp = fopen(buffer, "w")) == NULL)
860 return 0;
...
898 while ((buf = fgetln(in, &len))) {
...
909 fprintf(fp, "%s\n", buf);
910 }
However, there are three reasons why this particular vector is useless
in practice:
a) In OpenSMTPD 5.4.4p1, the getlogin() call in enqueue() will always
return "root", which means that the world-readable "dead.letter" will
always be created in /root, unreachable by the attacker (drwx------).
b) In OpenSMTPD 5.4.5p2, smtpctl's -S command-line option was added to
work around the getlogin() problem, but the getopt() string was
incorrectly modified to "RS:" instead of "R:S".
c) In OpenSMTPD 5.7.1p1, the getopt() string was fixed to "R:S", but the
savedeadletter() code was removed altogether.
------------------------------------------------------------------------
CVE-2015-ABCD - .forward stack-based buffer overflow
------------------------------------------------------------------------
In lka\_expand\_format(), the exptoklen bytes returned by
lka\_expand\_token() are memcpy()ed to ptmp (a pointer into the
stack-based tmpbuf) without first checking that there is enough space
left in tmpbuf:
799 exptoklen = lka\_expand\_token(exptok, sizeof exptok, token, ep,
800 ui);
801 if (exptoklen == 0)
802 return 0;
803
804 memcpy(ptmp, exptok, exptoklen);
This stack-based buffer overflow can be triggered locally through
OpenSMTPD's .forward mechanism:
$ whoami
john
$ python -c 'print "/" \* 1014 + "%{sender}"' > ~/.forward
$ python -c 'print "A" \* 255 + "@" + "A" \* 255'
AAA...AAA@AAA...AAA
$ telnet 127.0.0.1 25
EHLO 127.0.0.1
MAIL FROM:
RCPT TO:
Connection closed by foreign host.
As a result, in the logs:
smtpd[9305]: warn: format string error while expanding for user john
smtpd: stack overflow in function lka\_submit
It does not appear to be exploitable on OpenBSD x86 (beyond a local
denial-of-service), where even a one-byte overflow ended up smashing the
stack canary of every smtpd binary we tried. However, it may lead to
arbitrary code execution on other operating systems or platforms.
========================================================================
Remote Vulnerabilities
========================================================================
------------------------------------------------------------------------
CVE-2015-ABCD - Remote denial-of-service (disk-space exhaustion)
------------------------------------------------------------------------
The maximum size of an email, env->sc\_maxsize (by default 35 megabytes),
is enforced in dataline\_callback() for the email's body:
266 len = strlen(line) + 1;
267
268 if (s->datalen + len > env->sc\_maxsize) {
269 s->msgflags |= MF\_ERROR\_SIZE;
270 return;
271 }
...
278 s->datalen += len;
but not in header\_default\_callback() for the email's headers:
243 len = strlen(hdr->name) + 1;
...
248 s->datalen += len;
249
250 TAILQ\_FOREACH(l, &hdr->lines, next) {
251 len = strlen(l->buffer) + 1;
...
256 s->datalen += len;
257 }
It is therefore possible to send a headers-only email (i.e., no empty
line between the last header and the DATA-ending ".") that is much
larger than 35 megabytes, and fill OpenSMTPD's queue or mailbox
hard-disk partition.
------------------------------------------------------------------------
Multiple vulnerabilities in IMSG\_{SMTP,MTA}\_SSL\_VERIFY\*
------------------------------------------------------------------------
These IMSG\_{SMTP,MTA}\_SSL\_VERIFY\* messages are exchanged between
PROC\_PONY and PROC\_LKA:
- after PROC\_PONY successfully established an SSL connection with an
SMTP client (a client-certificate request is always made, but not
necessarily responded to), it calls smtp\_verify\_certificate() and
sends a few IMSG\_SMTP\_SSL\_VERIFY\* messages to PROC\_LKA, which verifies
the client's SSL certificate (if any) on behalf of PROC\_PONY.
- after PROC\_PONY successfully established an SSL connection with an
SMTP server (opportunistic STARTTLS encryption is always attempted,
but not necessarily successful), it calls mta\_verify\_certificate() and
sends a few IMSG\_MTA\_SSL\_VERIFY\* messages to PROC\_LKA, which verifies
the server's SSL certificate on behalf of PROC\_PONY.
In lka\_imsg(), PROC\_LKA blindly trusts the contents of the
req\_ca\_vrfy\_smtp, req\_ca\_vrfy\_mta, and req\_ca\_vrfy\_chain structures that
it receives from PROC\_PONY (although this suggests vulnerabilities that
are inter-process only, they are also triggerable remotely through two
other low-level bugs in imsg and mproc, to be described shortly):
struct ca\_vrfy\_req\_msg {
uint64\_t reqid;
char pkiname[SMTPD\_MAXHOSTNAMELEN];
unsigned char \*cert;
off\_t cert\_len;
size\_t n\_chain;
size\_t chain\_offset;
unsigned char \*\*chain\_cert;
off\_t \*chain\_cert\_len;
};
63 static void
64 lka\_imsg(struct mproc \*p, struct imsg \*imsg)
65 {
..
70 static struct ca\_vrfy\_req\_msg \*req\_ca\_vrfy\_smtp = NULL;
71 static struct ca\_vrfy\_req\_msg \*req\_ca\_vrfy\_mta = NULL;
72 struct ca\_vrfy\_req\_msg \*req\_ca\_vrfy\_chain;
- In the IMSG\_{SMTP,MTA}\_SSL\_VERIFY\_{CERT,CHAIN} cases, PROC\_LKA
attempts to read cert\_len bytes from imsg->data, but does not check
first that PROC\_PONY actually sent this amount of data (out-of-bounds
memory read, CVE-2015-ABCD):
148 case IMSG\_SMTP\_SSL\_VERIFY\_CERT:
149 req\_ca\_vrfy\_smtp = xmemdup(imsg->data, sizeof \*req\_ca\_vrfy\_smtp, "lka:ca\_vrfy");
150 req\_ca\_vrfy\_smtp->cert = xmemdup((char \*)imsg->data +
151 sizeof \*req\_ca\_vrfy\_smtp, req\_ca\_vrfy\_smtp->cert\_len, "lka:ca\_vrfy");
158 case IMSG\_SMTP\_SSL\_VERIFY\_CHAIN:
159 if (req\_ca\_vrfy\_smtp == NULL)
160 fatalx("lka:ca\_vrfy: chain without a certificate");
161 req\_ca\_vrfy\_chain = imsg->data;
162 req\_ca\_vrfy\_smtp->chain\_cert[req\_ca\_vrfy\_smtp->chain\_offset] = xmemdup((char \*)imsg->data +
163 sizeof \*req\_ca\_vrfy\_chain, req\_ca\_vrfy\_chain->cert\_len, "lka:ca\_vrfy");
- In the IMSG\_{SMTP,MTA}\_SSL\_VERIFY\_CERT case, PROC\_LKA does not
sanity-check n\_chain, the number of certificates in the chain that
will be sent by PROC\_PONY:
148 case IMSG\_SMTP\_SSL\_VERIFY\_CERT:
149 req\_ca\_vrfy\_smtp = xmemdup(imsg->data, sizeof \*req\_ca\_vrfy\_smtp, "lka:ca\_vrfy");
150 req\_ca\_vrfy\_smtp->cert = xmemdup((char \*)imsg->data +
151 sizeof \*req\_ca\_vrfy\_smtp, req\_ca\_vrfy\_smtp->cert\_len, "lka:ca\_vrfy");
152 req\_ca\_vrfy\_smtp->chain\_cert = xcalloc(req\_ca\_vrfy\_smtp->n\_chain,
153 sizeof (unsigned char \*), "lka:ca\_vrfy");
154 req\_ca\_vrfy\_smtp->chain\_cert\_len = xcalloc(req\_ca\_vrfy\_smtp->n\_chain,
155 sizeof (off\_t), "lka:ca\_vrfy");
156 return;
- In the IMSG\_{SMTP,MTA}\_SSL\_VERIFY\_{CERT,CHAIN} cases, PROC\_LKA does
not sanity-check chain\_offset (out-of-bounds memory write,
CVE-2015-ABCD):
. in the IMSG\_{SMTP,MTA}\_SSL\_VERIFY\_CERT case, chain\_offset should be
initialized to 0, but PROC\_LKA trusts PROC\_PONY to do so (arbitrary
memory write);
. in the IMSG\_{SMTP,MTA}\_SSL\_VERIFY\_CHAIN case, chain\_offset should be
checked against n\_chain, but PROC\_LKA trusts PROC\_PONY to send no
more than n\_chain certificates (heap-based buffer overflow):
158 case IMSG\_SMTP\_SSL\_VERIFY\_CHAIN:
159 if (req\_ca\_vrfy\_smtp == NULL)
160 fatalx("lka:ca\_vrfy: chain without a certificate");
161 req\_ca\_vrfy\_chain = imsg->data;
162 req\_ca\_vrfy\_smtp->chain\_cert[req\_ca\_vrfy\_smtp->chain\_offset] = xmemdup((char \*)imsg->data +
163 sizeof \*req\_ca\_vrfy\_chain, req\_ca\_vrfy\_chain->cert\_len, "lka:ca\_vrfy");
164 req\_ca\_vrfy\_smtp->chain\_cert\_len[req\_ca\_vrfy\_smtp->chain\_offset] = req\_ca\_vrfy\_chain->cert\_len;
165 req\_ca\_vrfy\_smtp->chain\_offset++;
166 return;
- In the IMSG\_{SMTP,MTA}\_SSL\_VERIFY case, PROC\_LKA does not reset the
static pointer req\_ca\_vrfy\_{smtp,mta} to NULL after free(), but trusts
PROC\_PONY to always send an IMSG\_{SMTP,MTA}\_SSL\_VERIFY\_CERT (which
re-initializes this static pointer) before sending an
IMSG\_{SMTP,MTA}\_SSL\_VERIFY{\_CHAIN,} (use-after-free, CVE-2015-ABCD):
168 case IMSG\_SMTP\_SSL\_VERIFY:
169 if (req\_ca\_vrfy\_smtp == NULL)
170 fatalx("lka:ca\_vrfy: verify without a certificate");
...
185 for (i = 0; i < req\_ca\_vrfy\_smtp->n\_chain; ++i)
186 free(req\_ca\_vrfy\_smtp->chain\_cert[i]);
187 free(req\_ca\_vrfy\_smtp->chain\_cert);
188 free(req\_ca\_vrfy\_smtp->chain\_cert\_len);
189 free(req\_ca\_vrfy\_smtp->cert);
190 free(req\_ca\_vrfy\_smtp);
191 return;
------------------------------------------------------------------------
CVE-2015-ABCD - Integer truncation in the imsg API
------------------------------------------------------------------------
There is a fundamental design flaw in the imsg\_create(), imsg\_add(), and
imsg\_compose() functions (and imsg\_composev(), which calls imsg\_create()
and imsg\_add()): their datalen argument is directly an u\_int16\_t, a fact
that is easily overlooked by their callers and makes them vulnerable to
integer truncation.
In OpenSMTPD, the nearly-identical functions smtp\_verify\_certificate()
and mta\_verify\_certificate() are vulnerable to this integer truncation,
and both are reachable remotely through SSL certificate verification:
2046 static int
2047 smtp\_verify\_certificate(struct smtp\_session \*s)
2048 {
....
2056 x = SSL\_get\_peer\_certificate(s->io.ssl);
....
2059 xchain = SSL\_get\_peer\_cert\_chain(s->io.ssl);
....
2071 /\* Send the client certificate \*/
2072 memset(&req\_ca\_vrfy, 0, sizeof req\_ca\_vrfy);
....
2083 req\_ca\_vrfy.cert\_len = i2d\_X509(x, &req\_ca\_vrfy.cert);
2084 if (xchain)
2085 req\_ca\_vrfy.n\_chain = sk\_X509\_num(xchain);
2086 iov[0].iov\_base = &req\_ca\_vrfy;
2087 iov[0].iov\_len = sizeof(req\_ca\_vrfy);
2088 iov[1].iov\_base = req\_ca\_vrfy.cert;
2089 iov[1].iov\_len = req\_ca\_vrfy.cert\_len;
2090 m\_composev(p\_lka, IMSG\_SMTP\_SSL\_VERIFY\_CERT, 0, 0, -1,
2091 iov, nitems(iov));
....
2095 if (xchain) {
2096 /\* Send the chain, one cert at a time \*/
2097 for (i = 0; i < sk\_X509\_num(xchain); ++i) {
2098 memset(&req\_ca\_vrfy, 0, sizeof req\_ca\_vrfy);
....
2100 x = sk\_X509\_value(xchain, i);
2101 req\_ca\_vrfy.cert\_len = i2d\_X509(x, &req\_ca\_vrfy.cert);
2102 iov[0].iov\_base = &req\_ca\_vrfy;
2103 iov[0].iov\_len = sizeof(req\_ca\_vrfy);
2104 iov[1].iov\_base = req\_ca\_vrfy.cert;
2105 iov[1].iov\_len = req\_ca\_vrfy.cert\_len;
2106 m\_composev(p\_lka, IMSG\_SMTP\_SSL\_VERIFY\_CHAIN, 0, 0, -1,
2107 iov, nitems(iov));
....
2109 }
2110 }
2111
2112 /\* Tell lookup process that it can start verifying, we're done \*/
2113 memset(&req\_ca\_vrfy, 0, sizeof req\_ca\_vrfy);
....
2115 m\_compose(p\_lka, IMSG\_SMTP\_SSL\_VERIFY, 0, 0, -1,
2116 &req\_ca\_vrfy, sizeof req\_ca\_vrfy);
....
2119 }
If the cert\_len returned by i2d\_X509() exceeds 64k, integer truncation
occurs when m\_composev() calls imsg\_composev(). The following #define
from OpenSSL and LibreSSL confirms that this is indeed possible:
#define SSL\_MAX\_CERT\_LIST\_DEFAULT 1024\*100 /\* 100k max cert list :-) \*/
Surprisingly, this integer truncation in PROC\_PONY triggers the
out-of-bounds memory read in PROC\_LKA: xmemdup() tries to read cert\_len
bytes (the non-truncated cert\_len) from imsg->data, which contains only
the truncated number of cert\_len bytes (i.e., xmemdup() tries to read an
extra 64k from imsg->data).
Our initial research suggests that this out-of-bounds memory read can be
transformed into a remote information leak that reveals heap addresses
and defeats the ASLR protection. Linux is almost certainly exploitable,
but OpenBSD's heavily randomized and hardened malloc significantly
raises the bar for successful exploitation.
------------------------------------------------------------------------
CVE-2015-ABCD - Missing return-value checks in the mproc API
------------------------------------------------------------------------
The m\_forward(), m\_compose(), and m\_composev() functions do not check
the return value of imsg\_compose() and imsg\_composev(): if the message
to be sent is larger than MAX\_IMSGSIZE (16k), these three functions will
fail to send the message, but they will not report this failure to their
callers, which have therefore no way of knowing whether the message was
actually sent or not.
Again, smtp\_verify\_certificate() and mta\_verify\_certificate() are
vulnerable: if the peer's certificate is larger than 16k (but smaller
than 64k, in order to avoid the integer truncation), PROC\_PONY will fail
to send the IMSG\_{SMTP,MTA}\_SSL\_VERIFY\_CERT to PROC\_LKA, and the
subsequent IMSG\_{SMTP,MTA}\_SSL\_VERIFY\_CHAIN will trigger the
use-after-free in PROC\_LKA, which in turn will trigger the out-of-bounds
memory write in PROC\_LKA.
Our initial research suggests that this use-after-free (and
out-of-bounds memory write) can be transformed into remote code
execution, when combined with the information leak described above.
Linux is almost certainly exploitable, but again, OpenBSD's heavily
randomized and hardened malloc significantly raises the bar for
successful exploitation.
========================================================================
Inter-Process Vulnerabilities
========================================================================
Although we focused our audit on local and remote vulnerabilities,
nevertheless we identified four classes of common inter-process
vulnerabilities in OpenSMTPD:
- Out-of-bounds memory read: one process X receives a specific type of
structure (or structured data) from another process Y, but does not
check that process Y actually sent enough data; or, checks are
performed, but incorrectly (e.g., because of an integer-wrap).
- Indirect information leak: if such an out-of-bounds memory read
survives (i.e., X does not segfault), and if the partial structure
received by X is sent back to Y as a complete structure, information
from the memory of process X is leaked to process Y.
- Direct information leak: a structure sent by one process to another
process contains uninitialized fields (e.g., union fields, or large
string buffers that are only partially strlcpy()ed to), thus leaking
information from the memory of the sending process to the receiving
process.
- Out-of-bounds memory write: one process receives data from another
process and copies it into a buffer without checking that it actually
fits; or, a structure is received and its contents (e.g., size fields)
are trusted without checks.
------------------------------------------------------------------------
In parent\_imsg(), case IMSG\_LKA\_OPEN\_FORWARD:
169 static void
170 parent\_imsg(struct mproc \*p, struct imsg \*imsg)
171 {
172 struct forward\_req \*fwreq;
...
185 case IMSG\_LKA\_OPEN\_FORWARD:
186 fwreq = imsg->data;
...
196 m\_compose(p, IMSG\_LKA\_OPEN\_FORWARD, 0, 0, fd,
197 fwreq, sizeof \*fwreq);
- Indirect information leak: fwreq.
------------------------------------------------------------------------
In queue\_imsg(), case IMSG\_SCHED\_ENVELOPE\_BOUNCE:
64 static void
65 queue\_imsg(struct mproc \*p, struct imsg \*imsg)
66 {
..
68 struct bounce\_req\_msg \*req\_bounce;
..
238 case IMSG\_SCHED\_ENVELOPE\_BOUNCE:
239 req\_bounce = imsg->data;
...
250 queue\_bounce(&evp, &req\_bounce->bounce);
...
512 static void
513 queue\_bounce(struct envelope \*e, struct delivery\_bounce \*d)
514 {
515 struct envelope b;
...
519 b.agent.bounce = \*d;
...
543 m\_create(p\_scheduler, IMSG\_QUEUE\_ENVELOPE\_SUBMIT, 0, 0, -1);
544 m\_add\_envelope(p\_scheduler, &b);
545 m\_close(p\_scheduler);
- Indirect information leak: req\_bounce->bounce.
------------------------------------------------------------------------
In control\_imsg(), cases IMSG\_STAT\_INCREMENT, IMSG\_STAT\_DECREMENT,
IMSG\_STAT\_SET:
82 static void
83 control\_imsg(struct mproc \*p, struct imsg \*imsg)
84 {
..
86 struct stat\_value val;
87 struct msg m;
88 const char \*key;
89 const void \*data;
90 size\_t sz;
..
165 case IMSG\_STAT\_SET:
166 m\_msg(&m, imsg);
167 m\_get\_string(&m, &key);
168 m\_get\_data(&m, &data, &sz);
169 m\_end(&m);
170 memmove(&val, data, sz);
- Out-of-bounds memory write (stack-based buffer overflow): in the call
to memmove(), the sz returned by m\_get\_data() is blindly trusted to be
equal to the size of the stack-based val structure (CVE-2015-ABCD).
------------------------------------------------------------------------
In mda\_imsg(), case IMSG\_MDA\_LOOKUP\_USERINFO:
114 void
115 mda\_imsg(struct mproc \*p, struct imsg \*imsg)
116 {
...
124 const void \*data;
...
127 size\_t sz;
...
134 case IMSG\_MDA\_LOOKUP\_USERINFO:
135 m\_msg(&m, imsg);
136 m\_get\_id(&m, &reqid);
137 m\_get\_int(&m, (int \*)&status);
138 if (status == LKA\_OK)
139 m\_get\_data(&m, &data, &sz);
140 m\_end(&m);
...
144 if (status == LKA\_TEMPFAIL)
...
148 else if (status == LKA\_PERMFAIL)
...
152 else {
153 memmove(&u->userinfo, data, sz);
- Out-of-bounds memory write (heap-based buffer overflow): in the call
to memmove(), the sz returned by m\_get\_data() is blindly trusted to be
equal to the size of the heap-based u->userinfo structure
(CVE-2015-ABCD).
------------------------------------------------------------------------
In mta\_start\_tls():
1501 static void
1502 mta\_start\_tls(struct mta\_session \*s)
1503 {
1504 struct ca\_cert\_req\_msg req\_ca\_cert;
1505 const char \*certname;
1506
1507 if (s->relay->pki\_name)
1508 certname = s->relay->pki\_name;
1509 else
1510 certname = s->helo;
1511
1512 req\_ca\_cert.reqid = s->id;
1513 (void)strlcpy(req\_ca\_cert.name, certname, sizeof req\_ca\_cert.name);
1514 m\_compose(p\_lka, IMSG\_MTA\_SSL\_INIT, 0, 0, -1,
1515 &req\_ca\_cert, sizeof(req\_ca\_cert));
- Direct information leak: req\_ca\_cert.name is not fully initialized by
strlcpy() (unlike strncpy(), strlcpy() does not fill its destination
buffer with additional null-bytes), and therefore still contains
sensitive information from the stack.
------------------------------------------------------------------------
In mta\_session\_imsg(), case IMSG\_MTA\_SSL\_INIT:
253 struct ca\_cert\_resp\_msg \*resp\_ca\_cert;
...
314 case IMSG\_MTA\_SSL\_INIT:
315 resp\_ca\_cert = imsg->data;
...
336 resp\_ca\_cert = xmemdup(imsg->data, sizeof \*resp\_ca\_cert, "mta:ca\_cert");
337 resp\_ca\_cert->cert = xstrdup((char \*)imsg->data +
338 sizeof \*resp\_ca\_cert, "mta:ca\_cert");
...
343 ssl = ssl\_mta\_init(pkiname,
344 resp\_ca\_cert->cert, resp\_ca\_cert->cert\_len);
...
349 explicit\_bzero(resp\_ca\_cert->cert, resp\_ca\_cert->cert\_len);
- Out-of-bounds memory read: resp\_ca\_cert.
- Out-of-bounds memory read: the string passed to xstrdup() is not
guaranteed to be null-terminated.
- Out-of-bounds memory read: in the call to ssl\_mta\_init(),
resp\_ca\_cert->cert\_len is blindly trusted to be equal to
resp\_ca\_cert->cert's xstrdup()ed length.
- Out-of-bounds memory write: in the call to explicit\_bzero(),
resp\_ca\_cert->cert\_len is blindly trusted to be equal to
resp\_ca\_cert->cert's xstrdup()ed length (CVE-2015-ABCD).
------------------------------------------------------------------------
In mta\_session\_imsg(), case IMSG\_MTA\_SSL\_VERIFY:
252 struct ca\_vrfy\_resp\_msg \*resp\_ca\_vrfy;
...
354 case IMSG\_MTA\_SSL\_VERIFY:
355 resp\_ca\_vrfy = imsg->data;
356 s = mta\_tree\_pop(&wait\_ssl\_verify, resp\_ca\_vrfy->reqid);
...
360 if (resp\_ca\_vrfy->status == CA\_OK)
- Out-of-bounds memory read: resp\_ca\_vrfy.
------------------------------------------------------------------------
In smtp\_session\_imsg(), case IMSG\_SMTP\_SSL\_INIT:
551 struct ca\_cert\_resp\_msg \*resp\_ca\_cert;
...
831 case IMSG\_SMTP\_SSL\_INIT:
832 resp\_ca\_cert = imsg->data;
...
842 resp\_ca\_cert = xmemdup(imsg->data, sizeof \*resp\_ca\_cert, "smtp:ca\_cert");
...
845 resp\_ca\_cert->cert = xstrdup((char \*)imsg->data +
846 sizeof \*resp\_ca\_cert, "smtp:ca\_cert");
...
861 explicit\_bzero(resp\_ca\_cert->cert, resp\_ca\_cert->cert\_len);
- Out-of-bounds memory read: resp\_ca\_cert.
- Out-of-bounds memory read: the string passed to xstrdup() is not
guaranteed to be null-terminated.
- Out-of-bounds memory write: in the call to explicit\_bzero(),
resp\_ca\_cert->cert\_len is blindly trusted to be equal to
resp\_ca\_cert->cert's xstrdup()ed length (CVE-2015-ABCD).
------------------------------------------------------------------------
In smtp\_session\_imsg(), case IMSG\_SMTP\_SSL\_VERIFY:
552 struct ca\_vrfy\_resp\_msg \*resp\_ca\_vrfy;
...
866 case IMSG\_SMTP\_SSL\_VERIFY:
867 resp\_ca\_vrfy = imsg->data;
868 s = tree\_xpop(&wait\_ssl\_verify, resp\_ca\_vrfy->reqid);
869
870 if (resp\_ca\_vrfy->status == CA\_OK)
- Out-of-bounds memory read: resp\_ca\_vrfy.
------------------------------------------------------------------------
In smtp\_mfa\_response() and smtp\_io(), cases IMSG\_SMTP\_REQ\_CONNECT and
IO\_LOWAT, respectively:
888 static void
889 smtp\_mfa\_response(struct smtp\_session \*s, int msg, int status, uint32\_t code,
890 const char \*line)
891 {
892 struct ca\_cert\_req\_msg req\_ca\_cert;
...
905 case IMSG\_SMTP\_REQ\_CONNECT:
...
915 if (s->listener->pki\_name[0])
916 (void)strlcpy(req\_ca\_cert.name, s->listener->pki\_name,
917 sizeof req\_ca\_cert.name);
918 else
919 (void)strlcpy(req\_ca\_cert.name, s->smtpname,
920 sizeof req\_ca\_cert.name);
921 m\_compose(p\_lka, IMSG\_SMTP\_SSL\_INIT, 0, 0, -1,
922 &req\_ca\_cert, sizeof(req\_ca\_cert));
- Direct information leak: req\_ca\_cert.name is not fully initialized by
strlcpy(), and therefore still contains sensitive information from the
stack.
------------------------------------------------------------------------
In lka\_imsg(), case IMSG\_{SMTP,MTA}\_SSL\_INIT:
struct ca\_cert\_resp\_msg {
uint64\_t reqid;
enum ca\_resp\_status status;
char \*cert;
off\_t cert\_len;
};
63 static void
64 lka\_imsg(struct mproc \*p, struct imsg \*imsg)
65 {
..
75 struct ca\_cert\_resp\_msg resp\_ca\_cert;
..
126 case IMSG\_SMTP\_SSL\_INIT:
127 req\_ca\_cert = imsg->data;
128 resp\_ca\_cert.reqid = req\_ca\_cert->reqid;
...
133 if (pki == NULL) {
134 resp\_ca\_cert.status = CA\_FAIL;
135 m\_compose(p, IMSG\_SMTP\_SSL\_INIT, 0, 0, -1, &resp\_ca\_cert,
136 sizeof(resp\_ca\_cert));
137 return;
138 }
- Out-of-bounds memory read: req\_ca\_cert.
- Direct information leak: resp\_ca\_cert's cert and cert\_len fields.
------------------------------------------------------------------------
In ca\_imsg(), case IMSG\_CA\_PRIV{ENC,DEC}:
292 case IMSG\_CA\_PRIVENC:
293 case IMSG\_CA\_PRIVDEC:
294 m\_msg(&m, imsg);
295 m\_get\_id(&m, &id);
296 m\_get\_string(&m, &pkiname);
297 m\_get\_data(&m, &from, &flen);
298 m\_get\_size(&m, &tlen);
299 m\_get\_size(&m, &padding);
300 m\_end(&m);
...
307 if ((to = calloc(1, tlen)) == NULL)
308 fatalx("ca\_imsg: calloc");
309
310 switch (imsg->hdr.type) {
311 case IMSG\_CA\_PRIVENC:
312 ret = RSA\_private\_encrypt(flen, from, to, rsa,
313 padding);
314 break;
315 case IMSG\_CA\_PRIVDEC:
316 ret = RSA\_private\_decrypt(flen, from, to, rsa,
317 padding);
318 break;
319 }
- Out-of-bounds memory write (heap-based buffer overflow): in the call
to RSA\_private\_{enc,dec}rypt(), the size (tlen) of the destination
buffer (to) is blindly trusted to be equal to RSA\_size(rsa)
(CVE-2015-ABCD).
------------------------------------------------------------------------
In m\_get\_typed\_sized():
493 static inline void
494 m\_get\_typed\_sized(struct msg \*m, uint8\_t type, const void \*\*dst, size\_t \*sz)
495 {
496 if (m->pos + 1 + sizeof(\*sz) > m->end)
497 m\_error("msg too short");
498 if (\*m->pos != type)
499 m\_error("msg bad type");
500 memmove(sz, m->pos + 1, sizeof(\*sz));
501 m->pos += sizeof(sz) + 1;
502 if (m->pos + \*sz > m->end)
503 m\_error("msg too short");
504 \*dst = m->pos;
505 m->pos += \*sz;
506 }
- Out-of-bounds memory read: \*sz, the amount of data allegedly received,
is read directly from the wire and sanity-checked, but large \*sz
values can integer-wrap the check.
------------------------------------------------------------------------
In m\_get\_sockaddr():
705 void
706 m\_get\_sockaddr(struct msg \*m, struct sockaddr \*sa)
707 {
708 size\_t s;
709 const void \*d;
710
711 m\_get\_typed\_sized(m, M\_SOCKADDR, &d, &s);
712 memmove(sa, d, s);
713 }
- Out-of-bounds memory write (buffer overflow): in the call to
memmove(), the size s of the data d returned by m\_get\_typed\_sized() is
blindly trusted to be equal to the size of the sockaddr structure sa
(CVE-2015-ABCD).
========================================================================
Miscellaneous Bugs
========================================================================
------------------------------------------------------------------------
In mta\_imsg(), case IMSG\_CTL\_RESUME\_ROUTE, if u64 is 0 ("resuming all
routes"), mta\_route\_unref() may eventually free() route, which is then
used-after-free by SPLAY\_NEXT() in SPLAY\_FOREACH() (there is a SAFE
version of most FOREACH macros, but no SPLAY\_FOREACH\_SAFE()):
419 case IMSG\_CTL\_RESUME\_ROUTE:
420 u64 = \*((uint64\_t \*)imsg->data);
...
426 SPLAY\_FOREACH(route, mta\_route\_tree, &routes) {
427 if (u64 && route->id != u64)
428 continue;
429
430 if (route->flags & ROUTE\_DISABLED) {
...
441 mta\_route\_unref(route); /\* from mta\_route\_disable \*/
442 }
443
444 if (u64)
445 break;
446 }
447 return;
------------------------------------------------------------------------
In parent\_sig\_handler(), the cause pointer should always be initialized
to NULL before the calls to asprintf(), and the return value of these
calls should be checked (on OpenBSD, asprintf() will always reset the
cause pointer to NULL in case of a failure, but this behavior is
implementation-dependent):
351 static void
352 parent\_sig\_handler(int sig, short event, void \*p)
353 {
...
357 char \*cause;
...
365 do {
366 pid = waitpid(-1, &status, WNOHANG);
...
371 if (WIFSIGNALED(status)) {
...
373 asprintf(&cause, "terminated; signal %d",
374 WTERMSIG(status));
375 } else if (WIFEXITED(status)) {
376 if (WEXITSTATUS(status) != 0) {
...
378 asprintf(&cause, "exited abnormally");
379 } else
380 asprintf(&cause, "exited okay");
381 } else
382 fatalx("smtpd: unexpected cause of SIGCHLD");
...
442 free(cause);
443 } while (pid > 0 || (pid == -1 && errno == EINTR));
------------------------------------------------------------------------
Code similar to the following appears several times in OpenSMTPD:
979 (void)strlcpy(sfn, "/tmp/smtpd.out.XXXXXXXXXXX", sizeof(sfn));
980 omode = umask(7077);
981 allout = mkstemp(sfn);
982 umask(omode);
983 if (allout < 0) {
...
991 return;
992 }
993 unlink(sfn);
But 7077 is decimal, not octal; in octal, 7077 is 015645. Luckily, the
call to mkstemp() that always follows uses mode 0600, which results in
the final mode 0000 (0600 & ~015645). This is not a security issue,
because these permissions are even more restrictive than those
originally intended.
------------------------------------------------------------------------
In do\_show\_queue(), chdir(".") should rather be chdir("/"), because the
current working directory may be outside the chroot tree:
652 if (chroot(PATH\_SPOOL) == -1 || chdir(".") == -1)
653 err(1, "%s", PATH\_SPOOL);
However, this is not a security issue either: do\_show\_queue() is an
smtpctl functionality, only root is allowed to run it, and all
subsequent filesystem accesses begin with '/' anyway.
========================================================================
Acknowledgments
========================================================================
We would like to thank OpenSMTPD's developers for their cooperation,
professional work, and minute attention to every detail in our audit
report.


=== Content from www.opensmtpd.org_f47c6b62_20250125_183416.html ===
Subject: Announce: OpenSMTPD 5.7.2 released
OpenSMTPD 5.7.2 has just been released.
OpenSMTPD is a FREE implementation of the SMTP protocol with some common
extensions. It allows ordinary machines to exchange e-mails with systems
speaking the SMTP protocol. It implements a fairly large part of RFC5321
and can already cover a large range of use-cases.
It runs on OpenBSD, NetBSD, FreeBSD, DragonFlyBSD, OSX and Linux.
The archives are now available from the main site at www.OpenSMTPD.org
We would like to thank the OpenSMTPD community for their help in testing
the snapshots, reporting bugs, contributing code and packaging for other
systems.
This is a minor release with security and reliability fixes only.
You are encouraged to update as soon as possible.
The following issues, among others less critical, were discovered during
a code audit performed by Qualys Security [https://www.qualys.com]. This
has been a very impressive and valuable contribution to our project, and
we'd like to thank them again for this ;-)
Issues fixed in this release (since 5.7.1):
===========================================
- an oversight in the portable version of fgetln() that allows attackers
to read and write out-of-bounds memory;
- multiple denial-of-service vulnerabilities that allow local users to
kill or hang OpenSMTPD;
- a stack-based buffer overflow that allows local users to crash
OpenSMTPD, or execute arbitrary code as the non-chrooted \_smtpd user;
- a hardlink attack (or race-conditioned symlink attack) that allows
local users to unset the chflags() of arbitrary files;
- a hardlink attack that allows local users to read the first line of
arbitrary files (for example, root's hash from /etc/master.passwd);
- a denial-of-service vulnerability that allows remote attackers to fill
OpenSMTPD's queue or mailbox hard-disk partition;
- an out-of-bounds memory read that allows remote attackers to crash
OpenSMTPD, or leak information and defeat the ASLR protection;
- a use-after-free vulnerability that allows remote attackers to crash
OpenSMTPD, or execute arbitrary code as the non-chrooted \_smtpd user;
Checksums:
==========
SHA256 (opensmtpd-5.7.2.tar.gz) =
e77bc57a4727233f4d725d06ccec4f89bca69fe6adabca6ee8f5683f8ac453fb
SHA256 (opensmtpd-5.7.2p1.tar.gz) =
daae044488d456b33aa9c84ebcc79aef2f9ab2d17ebe0c0f09e41e1f4b60d992
Verify:
=======
Starting with version 5.7.1, releases are signed with signify(1).
You can obtain the public key from our website, check with our community
that it has not been altered on its way to your machine.
Once you are confident the key is correct, you can verify the release as
described below:
1- get the signature file corresponding to the tarball you're installing
$ wget https://www.opensmtpd.org/archives/opensmtpd-5.7.2.sum.sig
2- check that the tarball matches the checksum:
$ sha256 opensmtpd-5.7.2.tar.gz
SHA256 (opensmtpd-5.7.2.tar.gz) =
e77bc57a4727233f4d725d06ccec4f89bca69fe6adabca6ee8f5683f8ac453fb
$ cat opensmtpd-5.7.2.sum.sig |tail -1
e77bc57a4727233f4d725d06ccec4f89bca69fe6adabca6ee8f5683f8ac453fb
3- verify that the signature file was not forged:
$ signify -V -e -p opensmtpd.pub -m opensmtpd-5.7.2.sum
Signature Verified
Support:
========
You are encouraged to register to our general purpose mailing-list:
http://www.opensmtpd.org/list.html
The "Official" IRC channel for the project is at:
#OpenSMTPD @ irc.freenode.net
Reporting Bugs:
===============
Please read http://www.opensmtpd.org/report.html
Security bugs should be reported directly to security@opensmtpd.org
Other bugs may be reported to bugs@opensmtpd.org
OpenSMTPD is brought to you by Gilles Chehade, Eric Faurot and
Sunil Nimmagadda.

