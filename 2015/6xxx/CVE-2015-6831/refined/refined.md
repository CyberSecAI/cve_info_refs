## Analysis of CVE-2015-6831

Based on the provided information, the root cause of CVE-2015-6831 is a **use-after-free vulnerability** within the `unserialize()` function when used with specific SPL data structures, namely `SplObjectStorage` and `SplDoublyLinkedList`.

Here's a breakdown of the vulnerability:

**Root Cause:**

The vulnerability stems from a flaw in how the `unserialize()` function handles certain serialized data, especially when dealing with `SplObjectStorage` and `SplDoublyLinkedList` objects. Specifically, when a serialized representation of these objects contains references (R: or r:) to previously unserialized zvals, a use-after-free condition can arise. This happens because an allocated zval is prematurely freed and then later accessed via a reference.

**Weaknesses/Vulnerabilities:**

*   **Use-After-Free:** The primary vulnerability is use-after-free. In the `unserialize()` function, a zval (`pcount` or `flags`) is allocated, used to read data, and subsequently freed. However, due to the presence of references in the serialized data stream (R: or r:), the same memory location may be accessed after it has been freed. This leads to a use-after-free condition.
*   **Incorrect Memory Management:**  The core issue lies in the way unserialize() handles references during the deserialization of `SplObjectStorage` and `SplDoublyLinkedList` objects. The freeing of certain zvals is done before ensuring that no references to them are still active in the deserialization process.

**Impact of Exploitation:**

*   **Arbitrary Code Execution:** The use-after-free vulnerability can be exploited to achieve arbitrary code execution. An attacker can craft a malicious serialized string that triggers the vulnerability and allows them to control the freed memory location.
*   **Remote Exploitation:**  The vulnerability can be exploited remotely as the unserialize() function is commonly used in web applications and can be triggered by attacker-controlled input.
*   **Denial of Service:** Even if arbitrary code execution is not achieved, the use-after-free can cause crashes, leading to denial of service.

**Attack Vectors:**

*   **Unserialize() Function:** The primary attack vector is the `unserialize()` function in PHP. An attacker must be able to supply a crafted serialized string to this function.
*   **Crafted Serialized String:**  The attacker needs to construct a specific serialized data string containing an `SplObjectStorage` or `SplDoublyLinkedList` object and including references to freed memory in specific places, such as zval flags or array.
*   **References R: and r:** The attacker relies on the way unserialize() handles references (R: for by-reference and r: for by-value) to access the freed memory.

**Required Attacker Capabilities/Position:**

*   **Ability to Call unserialize():** The attacker needs a way to call the `unserialize()` function with an attacker-controlled input. This is commonly achieved through web application vulnerabilities, such as:
    *   Directly calling `unserialize()` with user supplied data.
    *   Exploiting session deserialization or other data deserialization mechanisms.
*   **Understanding of PHP Internals:** A successful exploitation requires the attacker to have some understanding of how PHP objects are serialized and unserialized, specifically related to SPL data structures.
*   **Crafting Serialized Strings:** The attacker needs the ability to create valid, yet maliciously crafted, serialized strings that include an `SplObjectStorage` or `SplDoublyLinkedList` object, references, and payloads that can exploit the use-after-free condition.

**Additional details:**
* The vulnerability was present in PHP versions 5.4.43, 5.5.x, and 5.6.x.
* Patches involve using `var_push_dtor` to properly destroy the zvals at the end of scope to prevent the use-after-free.
* The vulnerability was present in `spl_observer.c` (for SplObjectStorage), and `spl_dllist.c` (for SplDoublyLinkedList) and `spl_array.c` (for ArrayObject)
* The vulnerability was related to several other similar use after free issues found at the same time.

In summary, CVE-2015-6831 is a use-after-free vulnerability in PHP's unserialize() function related to SPL data structures. By crafting special serialized data, an attacker can trigger a use-after-free condition, potentially leading to arbitrary code execution on a vulnerable server.