```
{
  "CVE-2015-2316": {
    "description": "The utils.html.strip_tags function in Django 1.6.x before 1.6.11, 1.7.x before 1.7.7, and 1.8.x before 1.8c1, when using certain versions of Python, allows remote attackers to cause a denial of service (infinite loop) by increasing the length of the input string.",
    "vulnerability_details": {
      "root_cause": "The `strip_tags()` function was changed to work iteratively. The size of the input string could increase on each iteration causing an infinite loop.",
      "weaknesses": [
        "Denial of Service due to infinite loop"
      ],
      "impact": "Remote attackers could cause a denial of service by triggering an infinite loop.",
       "attack_vectors": [
        "Sending a crafted input string to the `strip_tags()` function"
       ],
      "required_capabilities": "The attacker needs to be able to pass a specially crafted input string to the affected function. This is network accessible."
    },
     "affected_versions": [
        "Django 1.6.x before 1.6.11",
        "Django 1.7.x before 1.7.7",
        "Django 1.8.x before 1.8c1"
     ],
    "fix": "The `strip_tags()` function now returns the original input if it detects the length of the string it's processing increases. Patches available for Django's master development branch and the 1.4, 1.6, 1.7, and 1.8 release branches"
  },
  "CVE-2015-2317": {
    "description": "The utils.http.is_safe_url function in Django before 1.4.20, 1.5.x, 1.6.x before 1.6.11, 1.7.x before 1.7.7, and 1.8.x before 1.8c1 does not properly validate URLs, which allows remote attackers to conduct cross-site scripting (XSS) attacks via a control character in a URL, as demonstrated by a \\x08javascript: URL.",
    "vulnerability_details": {
      "root_cause": "The `is_safe_url()` function accepted URLs with leading control characters, such as `\\x08javascript:...`, which were then considered safe.",
      "weaknesses": [
        "Cross-Site Scripting (XSS) vulnerability due to improper URL validation"
      ],
      "impact": "Remote attackers could conduct cross-site scripting (XSS) attacks by injecting malicious URLs.",
         "attack_vectors": [
          "User-supplied redirect URLs with leading control characters"
        ],
      "required_capabilities": "The attacker needs to be able to provide a crafted URL to the affected function which is network accessible. "
    },
      "affected_versions": [
        "Django before 1.4.20",
        "Django 1.5.x",
        "Django 1.6.x before 1.6.11",
        "Django 1.7.x before 1.7.7",
        "Django 1.8.x before 1.8c1"
      ],
        "fix": "Patches available for Django's master development branch and the 1.4, 1.6, 1.7, and 1.8 release branches. The is_safe_url function now rejects URLs that start with control characters."
  },
    "CVE-2015-0219": {
    "description": "Django before 1.4.18, 1.6.x before 1.6.10, and 1.7.x before 1.7.3 allows remote attackers to spoof WSGI headers by using an _ (underscore) character instead of a - (dash) character in an HTTP header, as demonstrated by an X-Auth_User header.",
      "vulnerability_details": {
      "root_cause": "WSGI normalizes HTTP headers by converting to uppercase, changing dashes to underscores and prepending `HTTP_`. This results in a header such as `X-Auth-User` and `X-Auth_User` being treated identically (`HTTP_X_AUTH_USER`) and indistinguishable.",
      "weaknesses": [
        "WSGI Header Spoofing",
         "Inability to differentiate between underscore and dash in header names"
      ],
      "impact": "An attacker may be able to bypass security protections by providing an underscore version of a header which is stripped by a proxy server that strips the dashed version.",
      "attack_vectors": [
       "Crafted HTTP headers with underscore instead of dashes"
        ],
      "required_capabilities": "The attacker needs to be able to send a crafted HTTP header to a server running a vulnerable Django application. This is network accessible."
    },
     "affected_versions": [
        "Django before 1.4.18",
        "Django 1.6.x before 1.6.10",
        "Django 1.7.x before 1.7.3"
     ],
       "fix": "Django's built-in development server and Nginx and Apache 2.4 now strip all headers containing underscores from incoming requests by default."
  },
   "CVE-2015-0221": {
    "description": "The django.views.static.serve view in Django before 1.4.18, 1.6.x before 1.6.10, and 1.7.x before 1.7.3 reads files an entire line at a time, which allows remote attackers to cause a denial of service (memory consumption) via a long line in a file.",
     "vulnerability_details": {
      "root_cause": "The `django.views.static.serve` view read files one line at a time instead of chunks. A file with no newlines would result in memory usage equal to the file size.",
      "weaknesses": [
        "Denial of Service due to excessive memory consumption"
      ],
      "impact": "An attacker could exploit this and launch a denial-of-service attack by requesting many large files with very long lines.",
          "attack_vectors": [
         "Requesting large files with very long lines"
        ],
       "required_capabilities": "The attacker needs to be able to send HTTP requests to the web server hosting the django application. This is network accessible."
    },
      "affected_versions": [
        "Django before 1.4.18",
        "Django 1.6.x before 1.6.10",
        "Django 1.7.x before 1.7.3"
      ],
      "fix": "The view now reads the file in chunks to prevent large memory usage."
  },
  "CVE-2015-0222": {
    "description": "ModelMultipleChoiceField in Django 1.6.x before 1.6.10 and 1.7.x before 1.7.3, when show_hidden_initial is set to True, allows remote attackers to cause a denial of service by submitting duplicate values, which triggers a large number of SQL queries.",
     "vulnerability_details": {
      "root_cause": "When `ModelMultipleChoiceField` was configured with `show_hidden_initial=True`, it didn't deduplicate submitted values causing an unreasonable number of SQL queries.",
      "weaknesses": [
        "Database Denial of Service"
      ],
      "impact": "Attackers could cause a denial of service by submitting duplicate values for the field's data causing a large number of SQL queries.",
         "attack_vectors": [
          "Submitting duplicate values for a ModelMultipleChoiceField with `show_hidden_initial=True`"
          ],
       "required_capabilities": "The attacker needs to be able to submit a form with duplicate values to a django application. This is network accessible."
    },
     "affected_versions": [
        "Django 1.6.x before 1.6.10",
        "Django 1.7.x before 1.7.3"
       ],
     "fix": "The validation logic in `ModelMultipleChoiceField` now deduplicates submitted values to address this issue."
    }
}
```