```
{
  "CVE-2015-2150": {
    "Root cause": "The Linux kernel and Xen hypervisor do not properly restrict access to PCI command registers.",
    "Weaknesses": [
      "Insufficient restriction of access to PCI command registers"
    ],
    "Impact": "Local guest OS users can cause a denial of service (non-maskable interrupt and host crash) on the host.",
    "Attack vectors": "Local guest OS users can trigger an Unsupported Request (UR) response by disabling the (1) memory or (2) I/O decoding for a PCI Express device, then accessing the device, which triggers an Unsupported Request (UR) response.",
    "Required attacker capabilities/position": "Local guest OS access with the ability to modify PCI command registers"
  },
  "CVE-2015-2830": {
     "Root cause": "The Linux kernel's arch/x86/kernel/entry_64.S does not prevent the TS_COMPAT flag from reaching a user-mode task when a 64-bit task makes a fork(2) or clone(2) system call using int $0x80.",
    "Weaknesses": [
      "Incorrect handling of TS_COMPAT flag",
      "Incorrect seccomp/audit handling due to flag not being cleared"
    ],
    "Impact": "Local users can bypass seccomp or audit protection mechanisms, potentially leading to privilege escalation.",
    "Attack vectors": "A crafted application that uses the fork or close system calls can exploit this vulnerability.",
    "Required attacker capabilities/position": "Local user access"
  },
   "CVE-2015-2922": {
    "Root cause": "The ndisc_router_discovery function in net/ipv6/ndisc.c in the Linux kernel allows remote attackers to reconfigure hop-limit setting.",
     "Weaknesses": [
          "Inadequate input validation of router advertisement hop_limit"
      ],
    "Impact": "Remote attackers can reconfigure a hop-limit setting which can lead to denial of service.",
    "Attack vectors": "Remote attacker sends a crafted Router Advertisement (RA) message with a small hop_limit value.",
     "Required attacker capabilities/position": "Adjacent network access"
   },
   "CVE-2015-3331": {
      "Root cause": "The optimized implementation of RFC4106 GCM for x86 processors in the Linux kernel's arch/x86/crypto/aesni-intel_glue.c miscalculates memory addresses when performing AES-GCM-ESP decryption.",
     "Weaknesses": [
       "Incorrect memory address calculation",
        "Buffer overflow when decrypting data"
      ],
     "Impact": "Remote attackers can cause a denial of service (system crash) or potentially execute arbitrary code by triggering a crypto API call.",
      "Attack vectors": "A remote attacker could trigger a crypto API call with an AF_ALG(aead) socket or configure an IPsec tunnel to use AES-GCM-ESP.",
      "Required attacker capabilities/position": "Remote attacker with the ability to trigger the vulnerable code path. This could be a network attacker if IPsec is used."
  },
    "CVE-2015-2041": {
        "Root cause": "The Linux kernel's net/llc/sysctl_net_llc.c uses an incorrect data type in a sysctl table.",
        "Weaknesses": [
          "Type confusion in sysctl table",
          "Potential information leak from kernel memory"
        ],
      "Impact": "Local users could potentially obtain sensitive information from kernel memory or have other unspecified impacts by accessing a sysctl entry.",
      "Attack vectors": "Local users can access the vulnerable sysctl entries.",
        "Required attacker capabilities/position": "Local access with permission to access sysctl entries"
    },
  "CVE-2015-3636": {
      "Root cause": "The ping_unhash function in net/ipv4/ping.c in the Linux kernel does not initialize a list data structure during an unhash operation.",
      "Weaknesses": [
        "Use-after-free vulnerability",
       "Uninitialized memory",
       "Missing list data structure initialization."
      ],
     "Impact": "Local users can cause a denial of service (use-after-free and system crash) or potentially gain privileges.",
    "Attack vectors": "A local user can leverage the ability to make a SOCK_DGRAM socket system call for the IPPROTO_ICMP or IPPROTO_ICMPV6 protocol and then make a connect system call after a disconnect.",
     "Required attacker capabilities/position": "Local user access, ability to create and connect to SOCK_DGRAM sockets for ICMP and ICMPv6 protocols."
  },
    "CVE-2015-4167": {
        "Root cause": "The udf_read_inode function in fs/udf/inode.c in the Linux kernel does not validate certain length values.",
         "Weaknesses": [
           "Missing bounds check on UDF length values"
        ],
       "Impact": "Local users can cause a denial of service (system crash) by mounting a crafted UDF filesystem.",
        "Attack vectors": "A local user with a corrupted UDF filesystem image can exploit this by mounting the image.",
       "Required attacker capabilities/position": "Local user with access to mount a crafted UDF filesystem."
   },
    "CVE-2015-4700": {
        "Root cause": "A local user can create a bad instruction in the JIT processed BPF code.",
      "Weaknesses": [
        "Lack of proper bounds checking or validation in JIT processed BPF code"
      ],
        "Impact": "Local user can cause a kernel crash",
        "Attack vectors": "Crafted BPF instructions",
        "Required attacker capabilities/position": "Local user access, ability to create a packet filter and load crafted BPF instructions"
    },
      "CVE-2015-1420": {
      "Root cause": "Race condition in the handle_to_path function in fs/fhandle.c of the Linux kernel allows local users to bypass size restrictions.",
    "Weaknesses": [
        "Race condition vulnerability",
        "Lack of proper size restrictions"
    ],
    "Impact": "Local users can trigger read operations on additional memory locations by manipulating the handle_bytes value during execution, leading to information leaks.",
        "Attack vectors": "Local users can change the handle_bytes value of a file handle during the execution of the handle_to_path function.",
       "Required attacker capabilities/position": "Local user access"
      },
        "CVE-2015-1805": {
            "Root cause": "The pipe_read and pipe_write implementations in fs/pipe.c in the Linux kernel do not properly consider the side effects of failed copy_to_user_inatomic and copy_from_user_inatomic calls.",
             "Weaknesses":[
               "Improper error handling of copy_to_user_inatomic and copy_from_user_inatomic calls",
                "Lack of bounds checking leading to I/O vector array overrun"
             ],
         "Impact": "Local users can cause a denial of service (system crash) or potentially gain privileges via a crafted application.",
          "Attack vectors": "Local users can leverage a crafted application to exploit the vulnerability, an “I/O vector array overrun”",
         "Required attacker capabilities/position": "Local user access"
      }
  
}
```