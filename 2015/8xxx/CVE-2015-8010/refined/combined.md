=== Content from www.openwall.com_5568e6b9_20250125_110218.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Follow @Openwall on Twitter for new release announcements and other news](https://twitter.com/openwall) | | --- | |
| --- | --- |

[[<prev]](14) [[next>]](../../../2015/10/30/1) [[<thread-prev]](../../../2015/10/23/15) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-Id: <20151029205104.BDBB4B2E09D@smtpvbsrv1.mitre.org>
Date: Thu, 29 Oct 2015 16:51:04 -0400 (EDT)
From: cve-assign@...re.org
To: ricardo@...chbrothers.com
Cc: cve-assign@...re.org, oss-security@...ts.openwall.com
Subject: Re: CVE request - Icinga 1.13.3 and older are vulnerable to XSS

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

> <https://dev.icinga.org/issues/10453>

> Classic-UI with the CSV export link and pagination feature

> The functions parsed QUERY_STRING from the environment without
> properly sanitizing it.

> /cgi-bin/status.cgi?host=all&[XSS]

Use CVE-2015-8010.

- --
CVE assignment team, MITRE CVE Numbering Authority
M/S M300
202 Burlington Road, Bedford, MA 01730 USA
[ PGP key available through <http://cve.mitre.org/cve/request_id.html> ]
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQIcBAEBCAAGBQJWMoZFAAoJEL54rhJi8gl5Q7oP/A1ALnCznQCfABA13OjO0gPQ
7AAhmJ7ehF75Zhj+5HrGl4AzqxdFQ36jGGVhFvedBBCt6GKEGmdz5w3LXcMW0fUx
oV3Fj5odzUJzscnZhzVvDdoce6hFJaXhuTOtdEhU2TBNr1tf6HwzXhT5nbOcfOAa
lFi5KFVCFhXBtk0yCzufCoFEb6ey6xkNXxTI5xiSxtyngE5rPW6/Iczqsj5cVC5B
FhYwmnLa7L+wrW8wy4/9DaQRedKWYpZpwCpfoFyDykVNuoIFFkRVKlyM53tnBmS0
j7cHHVfQezAJSK/Yr40PcYsSP6lNKydMArzDoo8n5qWMN5TkjSAVFg+B4pq0CHCY
/TjTXM8AMGlMIrQldxfPVrIYvwrU5FYGHgONNf2yFDfaCCUTgbNrwEize4WgwzJV
VsUpKgY/WV00LS5WmfzD6mPhz9kdewKaBiLpOg4lFY5szB+qpjdzhW9a48VOHmQZ
6mut47yGovCoiZZGf2AHmEjwIoaiQu7qYJfUSsU5aRfpKSMlXxatWkR/imwJ4acU
IwCkdbYnORwx/umNqhVGtEgvVonwdSwF3DpIDvduCxnI4TsGgvZ9VF7DbW45/kT2
XuXiaRRD2YS5RFlF7fm3GDe5sXWER8+BgqXZqynkXvo7/ZRc44gWPU/4WKdvbS/+
5zpre8b5xsrn4rroQTOX
=CtNa
-----END PGP SIGNATURE-----

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from www.suse.com_79e273f1_20250126_080747.html ===

![](/assets/img/1px-transparent.gif)
![](/assets/img/1px-transparent.gif)

[![SUSE Logo](https://www.suse.com/assets/img/suse-white-logo-green.svg)
![SUSE Federal Logo](https://www.suse.com/assets/img/fed_logo.png)](https://www.suse.com)
Exit SUSE Federal  >

[Customer Center](https://scc.suse.com/home)

Account

Hello
[Update Your Account](https://www.suse.com/account/update/)
[Log Out](https://www.suse.com/saml2/logout/)

[Login](https://www.suse.com/saml2/login/)
[Create Account](https://www.suse.com/account/create/)
[Update Your Account](https://www.suse.com/account/update/)

English

Language
[Deutsch](https://www.suse.com/de-de/security/cve/CVE-2015-8010.html)
[English](https://www.suse.com/security/cve/CVE-2015-8010.html)
[EspaÃ±ol](https://www.suse.com/es-es/security/cve/CVE-2015-8010.html)
[FranÃ§ais](https://www.suse.com/fr-fr/security/cve/CVE-2015-8010.html)
[ä¸­æ(ç®ä½)](https://www.suse.com/zh-cn/security/cve/CVE-2015-8010.html)
[æ¥æ¬èª](https://www.suse.com/ja-jp/security/cve/CVE-2015-8010.html)
[íêµ­ì´](https://www.suse.com/ko-kr/security/cve/CVE-2015-8010.html)
[PortuguÃªs (Brasil)](https://www.suse.com/pt-br/security/cve/CVE-2015-8010.html)

[Shop](https://www.suse.com/shop/)

[View Cart](https://buy.suse.com/store?Action=DisplayPage&Env=BASE&SiteID=suse&id=ThreePgCheckoutShoppingCartPage)

[![SUSE Logo](https://www.suse.com/assets/img/suse-white-logo-green.svg)](https://www.suse.com)
Exit SUSE Federal  >

[Shop](https://www.suse.com/shop/)
[SUSECON 25](https://www.suse.com/susecon/)
[Customer](https://scc.suse.com/home)

Federal Solutions

Products

Solutions

Support

Partners

Communities

About

[Contact Us](https://www.suse.com/contact/)

[Free Downloads](https://www.suse.com/products/)

 Back

 Back
[![Icon](https://www.suse.com/assets/img/icons/Linux-one-color.svg)
Linux](https://www.suse.com/solutions/business-critical-linux/ "Linux")

* [SUSE Linux Enterprise Server](https://www.suse.com/products/server/)
* [SUSE Linux Enterprise Server

  for SAP Applications](https://www.suse.com/products/sles-for-sap/)
* [SUSE Linux Micro](https://www.suse.com/products/micro/)
* [SUSE Multi-Linux Support](https://www.suse.com/products/multi-linux-support/)
* [SUSE Multi-Linux Manager](https://www.suse.com/products/multi-linux-manager/)

[![Icon](https://www.suse.com/assets/img/icons/Cloud-native-one-color.svg)
Cloud Native](https://www.suse.com/solutions/enterprise-container-management/ "Cloud Native")

* [SUSE Rancher Prime](https://www.suse.com/products/rancher/)
* [Virtualization (Harvester)](https://www.suse.com/products/rancher/virtualization/)
* [Storage (Longhorn)](https://www.suse.com/products/rancher/storage/)
* [Security (NeuVector)](https://www.suse.com/products/rancher/security/)
* [Observability](https://www.suse.com/solutions/observability/)
* [SUSE Cloud Observability](https://www.suse.com/products/cloud/observability/)

[![Icon](https://www.suse.com/assets/img/icons/Edge-one-color.svg)
Edge](https://www.suse.com/solutions/edge-computing/ "Edge")

* [SUSE Edge](https://www.suse.com/products/edge/)
* [SUSE Edge for Telco](https://www.suse.com/products/edge-for-telco/)

[![Icon](https://www.suse.com/assets/img/icons/AI-one-color.svg)
AI](https://www.suse.com/solutions/edge-computing/ "AI")

* [SUSE AI](https://www.suse.com/products/ai/)

[All Products](https://www.suse.com/products/)

 Back
Foundational

* [![Linux](https://www.suse.com/assets/img/icons/Linux-one-color.svg)](https://www.suse.com/solutions/linux/)
* [![Cloud Native](https://www.suse.com/assets/img/icons/Cloud-native-one-color.svg)](https://www.suse.com/solutions/cloud-native/)
* [![Edge](https://www.suse.com/assets/img/icons/Edge-one-color.svg)](https://www.suse.com/solutions/edge/)
* [![AI](https://www.suse.com/assets/img/icons/AI-one-color.svg)](https://www.suse.com/solutions/ai/)

Solutions

* [Run SAP

  Run & secure cloud and on-prem workloads](https://www.suse.com/solutions/run-sap-solutions/)
* [Public Cloud

  Accelerate and innovate across your cloud environment](https://www.suse.com/solutions/public-cloud/)
* [Observability

  Rapid, full-stack visibility in under 5 minutes](https://www.suse.com/solutions/observability/)
* [Security

  Secure your digital enterprise](https://www.suse.com/solutions/security/)

Industries

* [Automotive](https://www.suse.com/sector/automotive/)
* [Telecom](https://www.suse.com/sector/telco/)
* [Banking and Financial Systems](https://www.suse.com/sector/banking-financial-services/)
* [Healthcare](https://www.suse.com/sector/healthcare/)
* [Manufacturing](https://www.suse.com/sector/manufacturing/)
* [Retail](https://www.suse.com/sector/retail/)
* [Technology & Software](https://www.suse.com/sector/technology/)
* [Federal](https://www.ranchergovernment.com/)
* [Pharma](https://www.suse.com/sector/pharma/)
* [Energy](https://www.suse.com/sector/energy/)

 Back
Support

* [Product Support

  SUSE Customer Center](https://scc.suse.com/home)
* [Premium Support Services

  Dedicated support services from a premium team](https://www.suse.com/services/premium/)
* [Long Term Services Support

  Stay on your existing product version](https://www.suse.com/products/long-term-service-pack-support/)
* [Renew Your Support Subscription

  Partners with cloud providers](https://www.suse.com/renewals/)
* [![AWS](https://www.suse.com/assets/img/icons/320px-Amazon3.svg)](https://aws.amazon.com/marketplace/search/results?searchTerms=suse)
* [![Microsoft Azure](https://www.suse.com/assets/img/icons/Microsoft_Azure3.svg)](https://azure.microsoft.com/solutions/linux-on-azure/suse/)
* [![Google](https://www.suse.com/assets/img/icons/lockup_GoogleCloud_FullColor_rgb_139x24px 1.svg)](https://console.cloud.google.com/marketplace/browse?q=SUSE)

Services

* [Consulting Services](https://www.suse.com/services/)
* [Training & Certification](https://www.suse.com/training/)
* [Premium Technical Advisory Services](https://www.suse.com/services/premium-technical-advisory/)

Resources

* [SUSE Support User Guide](https://www.suse.com/support/handbook/)
* [Patches & Updates](https://download.suse.com/patch/finder/)
* [Product Documentation](https://documentation.suse.com/)
* [Knowledgebase](https://www.suse.com/support/kb/)
* [Product Support Life Cycle](https://www.suse.com/lifecycle/)
* [Package Hub

  Community packages for SUSE Linux Enterprise Server](https://packagehub.suse.com/)
* [Driver Search](https://drivers.suse.com/)
* [Support Forums](https://forums.suse.com/forum.php)
* [Developer Services](https://www.suse.com/services/support-offerings/developer-services/)
* [Beta Program](https://www.suse.com/betaprogram/)
* [Security](https://www.suse.com/support/security/)

 Back
Partners

* [Partner Program](https://www.suse.com/partners/)
* [Find a Partner](https://www.suse.com/partners/find-partner/)
* [Become a Partner](https://www.suse.com/partners/become-partner/)
* [Login to the SUSE Partner Portal](https://partner.suse.com/)

 Back
Communities

* [Blog](https://www.suse.com/c/blog/)
* [Forum](https://forums.suse.com/forum.php)
* [Open Source Projects](http://opensource.suse.com/)
* [openSUSE.org](https://www.opensuse.org/)

 Back
About

* [About](https://www.suse.com/company/about/)
* [Leadership](https://www.suse.com/leadership/)
* [Careers](https://jobs.suse.com/)
* [Newsroom](https://www.suse.com/news/)
* [Success Stories](https://www.suse.com/success/)
* [Investor Relations](https://ir.suse.com/)
* [Social Impact](https://www.suse.com/esg/)
* [SUSE Logo and Brand](https://brand.suse.com/)
* [Events](https://www.suse.com/events/)
* [Merchandise Store](https://www.susemerchandise.com/)

# CVE-2015-8010

## Common Vulnerabilities and Exposures

[[Previous]](CVE-2015-8000.html) [[Index]](index.html) [[Next]](CVE-2015-8011.html)

### Upstream information

[CVE-2015-8010 at MITRE](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-8010)

#### Description

Cross-site scripting (XSS) vulnerability in the Classic-UI with the CSV export link and pagination feature in Icinga before 1.14 allows remote attackers to inject arbitrary web script or HTML via the query string to cgi-bin/status.cgi.

---

### [SUSE information](https://www.suse.com/c/cve-pages-self-help-security-issues-suse-linux-enterprise/)

Overall state of this security issue: Resolved

This issue is currently rated as having [moderate](https://www.suse.com/support/security/rating/) severity.

[CVSS v2 Scores](https://nvd.nist.gov/cvss.cfm)
|  | National Vulnerability Database |
| Base Score | 4.3 |
| Vector | AV:N/AC:M/Au:N/C:N/I:P/A:N |
| Access Vector | Network |
| Access Complexity | Medium |
| Authentication | None |
| Confidentiality Impact | None |
| Integrity Impact | Partial |
| Availability Impact | None |

[CVSS v3 Scores](https://nvd.nist.gov/cvss.cfm)
|  | SUSE |
| Base Score | 3.5 |
| Vector | CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:N |
| Attack Vector | Network |
| Attack Complexity | Low |
| Privileges Required | Low |
| User Interaction | Required |
| Scope | Unchanged |
| Confidentiality Impact | Low |
| Integrity Impact | None |
| Availability Impact | None |
| CVSSv3 Version | 3 |

SUSE Bugzilla entry: [952777](https://bugzilla.suse.com/show_bug.cgi?id=952777) [RESOLVED / FIXED]
### SUSE Security Advisories:

* [SUSE-SU-2018:3620-1](https://lists.suse.com/pipermail/sle-security-updates/2018-November/004828.html), published Mon Nov 5 13:08:53 MST 2018
* [openSUSE-SU-2017:0146-1](https://lists.opensuse.org/archives/list/security-announce%40lists.opensuse.org/thread/3Q6N4F4EAYSJ6FNMJTKIZZZLPGW4MV2P/#3Q6N4F4EAYSJ6FNMJTKIZZZLPGW4MV2P), published Fri Dec 8 15:48:36 2023
* [openSUSE-SU-2018:3258-1](https://lists.opensuse.org/archives/list/security-announce%40lists.opensuse.org/thread/IYDTKTNW6AJIKWLKJSYIEMSAQGFCFOXH/#IYDTKTNW6AJIKWLKJSYIEMSAQGFCFOXH), published Fri Dec 8 15:48:40 2023

### List of released packages

| Product(s) | Fixed package version(s) | References |
| --- | --- | --- |
| SUSE Enterprise Storage 4 | * `icinga >= 1.13.3-12.3.1` | Patchnames: SUSE-Storage-4-2018-2580 |
| SUSE Manager Client Tools 12 | * `icinga >= 1.13.3-12.3.1` * `icinga-devel >= 1.13.3-12.3.1` * `icinga-doc >= 1.13.3-12.3.1` * `icinga-idoutils >= 1.13.3-12.3.1` * `icinga-idoutils-mysql >= 1.13.3-12.3.1` * `icinga-idoutils-oracle >= 1.13.3-12.3.1` * `icinga-idoutils-pgsql >= 1.13.3-12.3.1` * `icinga-plugins-downtimes >= 1.13.3-12.3.1` * `icinga-plugins-eventhandlers >= 1.13.3-12.3.1` * `icinga-www >= 1.13.3-12.3.1` * `icinga-www-config >= 1.13.3-12.3.1` * `monitoring-tools >= 1.13.3-12.3.1` | Patchnames: SUSE-SLE-Manager-Tools-12-2018-2580 |

---

### Status of this issue by product and package

Please note that this evaluation state might be work in progress, incomplete or outdated. Also information for service packs in the LTSS phase is only included for issues meeting the LTSS criteria. If in doubt, feel free to contact us for clarification. The updates are grouped by state of their lifecycle. SUSE product lifecycles are documented [on the lifecycle page](https://www.suse.com/lifecycle/).

| Product(s) | Source package | State |
| --- | --- | --- |
| Products under general support and receiving all security fixes. | | |
| SUSE Manager Client Tools 12 | icinga | Released |
| SUSE Manager Client Tools 12-BETA | icinga | Affected |
| SUSE Manager Client Tools for SLE 12 | icinga | Released |
| Products past their end of life and not receiving proactive updates anymore. | | |
| SUSE Enterprise Storage 4 | icinga | Released |

---

### SUSE Timeline for this CVE

CVE page created: Thu Oct 29 23:15:25 2015

CVE page last modified: Fri Nov 15 16:06:29 2024

![SUSE Logo](https://www.suse.com/assets/img/suse-white-logo-green.svg)

* [Careers](https://jobs.suse.com/ "Careers")
* [Legal](https://www.suse.com/company/legal/ "Legal")
* [Anti-Slavery Statement](https://links.imagerelay.com/cdn/3404/ql/811b4f2364b94ff18eb15e315b3e263d/suse_anti_slavery_statement.pdf "Anti-Slavery Statement")
* [Anti-slavery](https://www.suse.com/legal/anti-slavery/ "Anti-slavery")
* [About](https://www.suse.com/company/about/ "About")
* [Communications Preferences](https://www.suse.com/company/subscribe/ "Communications Preferences")
* [Contact Us](https://www.suse.com/contact/ "Contact Us")
* [Let's Chat](#footer-chat-now "Let's Chat")

* [![](https://www.suse.com/assets/img/youtube.png)](https://www.youtube.com/channel/UCHTfqIzPKz4f_dri36lAQGA%20)
* [![](https://www.suse.com/assets/img/fn-fbook-ico-white.png)](https://www.facebook.com/SUSEWorldwide)
* [![](https://www.suse.com/assets/img/logo-black.png)](https://www.twitter.com/SUSE)
* [![](https://www.suse.com/assets/img/fn-link-ico-white.png)](https://www.linkedin.com/company/suse)
* ![WeChat](https://www.suse.com/assets/img/icons/WeChat.png)

![WeChat QR](https://www.suse.com/assets/img/icons/qrcode_for_gh_91d12717ed53_430.jpg)

Support: [Open a Support Case](https://www.suse.com/support/handbook/#open)

©  ©SUSE, All Rights Reserved

Cookie Settings

[Privacy Policy](https://www.suse.com/company/legal/) and
[Cookie Policy](https://www.suse.com/company/legal/cookies-policy/)

X

×



=== Content from github.com_831326a2_20250126_080751.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FIcinga%2Ficinga-core%2Fcommit%2F31dd493a48e335203899a1b2cae473852930e203)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FIcinga%2Ficinga-core%2Fcommit%2F31dd493a48e335203899a1b2cae473852930e203)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fcommit_fragments%2Frepo_layout&source=header-repo&source_repo=Icinga%2Ficinga-core)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

This repository has been archived by the owner on Jan 15, 2019. It is now read-only.

[Icinga](/Icinga)
/
**[icinga-core](/Icinga/icinga-core)**
Public archive

* [Notifications](/login?return_to=%2FIcinga%2Ficinga-core) You must be signed in to change notification settings
* [Fork
  28](/login?return_to=%2FIcinga%2Ficinga-core)
* [Star
   44](/login?return_to=%2FIcinga%2Ficinga-core)

* [Code](/Icinga/icinga-core)
* [Issues
  2](/Icinga/icinga-core/issues)
* [Pull requests
  2](/Icinga/icinga-core/pulls)
* [Actions](/Icinga/icinga-core/actions)
* [Security](/Icinga/icinga-core/security)
* [Insights](/Icinga/icinga-core/pulse)

Additional navigation options

* [Code](/Icinga/icinga-core)
* [Issues](/Icinga/icinga-core/issues)
* [Pull requests](/Icinga/icinga-core/pulls)
* [Actions](/Icinga/icinga-core/actions)
* [Security](/Icinga/icinga-core/security)
* [Insights](/Icinga/icinga-core/pulse)

## Commit

[Permalink](/Icinga/icinga-core/commit/31dd493a48e335203899a1b2cae473852930e203)

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

Merge branch 'fix/xxs-vulnerability-in-classic-ui-10453'

[Browse files](/Icinga/icinga-core/tree/31dd493a48e335203899a1b2cae473852930e203)
Browse the repository at this point in the history

```
fixes: #10453
fixes: [CVE-2015-8010](https://github.com/advisories/GHSA-x57r-7jqf-5w9p "CVE-2015-8010")
```

* Loading branch information

[![@bb-Ricardo](https://avatars.githubusercontent.com/u/771836?s=40&v=4)](/bb-Ricardo)

[bb-Ricardo](/Icinga/icinga-core/commits?author=bb-Ricardo "View all commits by bb-Ricardo")
committed
Oct 30, 2015

2 parents
[a3b767a](/Icinga/icinga-core/commit/a3b767af72dd73570d49daa3ad1b47398c14e6db)
+
[5c816f5](/Icinga/icinga-core/commit/5c816f5d9352c373e9dadb95b63612a96cf96dff)

commit 31dd493

 Show file tree

 Hide file tree

Showing
**17 changed files**
with
**1,482 additions**
and
**1,840 deletions**.

* Whitespace
* Ignore whitespace

* Split
* Unified

* cgi

  + cgi/avail.c
    [avail.c](#diff-0e01d33888184b9dfe71991e0da2d3658bfae657cf2cffc6b5ad63f5ff2abd19)
  + cgi/cgiutils.c
    [cgiutils.c](#diff-04d6fa2365a08ab911e7e03543f4c8e3c4236663b55997f8aa7748f31bfd352a)
  + cgi/cmd.c
    [cmd.c](#diff-af4a2bd1f12fe0e22b1b8683d67a6cbc1c848534be2b5d701d2ed70c5cf3c99c)
  + cgi/config.c
    [config.c](#diff-eff840f7de6c344f94afd6e9ffbd1625aa6cbad014b51764444a4b3c0c2ad91f)
  + cgi/extinfo.c
    [extinfo.c](#diff-235d93c182b89466dd5b41d95b2378bba303d000cdb44f72bbefda32cfa6550d)
  + cgi/getcgi.c
    [getcgi.c](#diff-9381f3b2558f6a6078eb76aefc503505cae27c7976607e59ea9db8af934c2db7)
  + cgi/histogram.c
    [histogram.c](#diff-b0b887a9c9f825216e0840cd7ba206266efdc85c51b240b49ceaa5842e100dd1)
  + cgi/history.c
    [history.c](#diff-6b7434a5c4364cae7a574c72cbef93083f8fb81b6d4b95a01f4c9541c6c1162f)
  + cgi/notifications.c
    [notifications.c](#diff-0555e0ba36244fe2d9f54e48ef13a2428a21160854a4f4e2b0cfe9ddefafe98b)
  + cgi/outages.c
    [outages.c](#diff-af4003fe07154ad01307550cf9f4c1703b560ff6452740072254c20f886e387c)
  + cgi/showlog.c
    [showlog.c](#diff-2295e2b3cf40eb175d700801f073183e228477ad5c9d40d5068c85a2785a1df4)
  + cgi/status.c
    [status.c](#diff-43c30f3dd8fcb2870458e02b7372412844f1616585163ee5b3661e10e9329226)
  + cgi/statusmap.c
    [statusmap.c](#diff-6f1e82e0790f365261975ea38c36187492fd04e88918da934394e896645bc067)
  + cgi/summary.c
    [summary.c](#diff-009dbeb5d0584dccd2956e58b8d205e674bf94074eacf5f052416dc6b7ae76f9)
  + cgi/tac.c
    [tac.c](#diff-08cab4508583fb4c29f5475fa8c0cf2776f1ce0f50b37100147c14d2297a92f9)
  + cgi/trends.c
    [trends.c](#diff-51d1a2e96e6422c78ae0e58c75c026b710e2081bd5ad127aa5f34bad751c30a8)
* include

  + include/getcgi.h
    [getcgi.h](#diff-1507884387d8d5c883d7413810ee19ba9125e6f4654959cc185667c32b049a5e)

## There are no files selected for viewing

323 changes: 133 additions & 190 deletions

323
[cgi/avail.c](#diff-0e01d33888184b9dfe71991e0da2d3658bfae657cf2cffc6b5ad63f5ff2abd19 "cgi/avail.c")

Show comments

[View file](/Icinga/icinga-core/blob/31dd493a48e335203899a1b2cae473852930e203/cgi/avail.c)
Delete file

Load diff

Large diffs are not rendered by default.

Oops, something went wrong.

Retry

196 changes: 89 additions & 107 deletions

196
[cgi/cgiutils.c](#diff-04d6fa2365a08ab911e7e03543f4c8e3c4236663b55997f8aa7748f31bfd352a "cgi/cgiutils.c")

Show comments

[View file](/Icinga/icinga-core/blob/31dd493a48e335203899a1b2cae473852930e203/cgi/cgiutils.c)
Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -31,6 +31,7 @@ |
|  |  | #include "../include/comments.h" |
|  |  |  |
|  |  | #include "../include/cgiutils.h" |
|  |  | #include "../include/getcgi.h" |
|  |  |  |
|  |  | char main\_config\_file[MAX\_FILENAME\_LENGTH]; |
|  |  | char command\_file[MAX\_FILENAME\_LENGTH]; |
| Expand Down  Expand Up | | @@ -208,6 +209,7 @@ extern serviceescalation \*serviceescalation\_list; |
|  |  |  |
|  |  | extern hoststatus \*hoststatus\_list; |
|  |  | extern servicestatus \*servicestatus\_list; |
|  |  | extern html\_request \*html\_request\_list; |
|  |  |  |
|  |  |  |
|  |  | char encoded\_url\_string[4][MAX\_INPUT\_BUFFER]; // 4 to be able to use url\_encode 4 times |
| Expand Down  Expand Up | | @@ -2223,54 +2225,50 @@ void display\_info\_table(char \*title, authdata \*current\_authdata, int daemon\_chec |
|  |  | } |
|  |  |  |
|  |  | void display\_nav\_table(time\_t ts\_start, time\_t ts\_end) { |
|  |  | char \*temp\_buffer; |
|  |  | char temp\_buffer[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char url[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char stripped\_query\_string[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char date\_time[MAX\_INPUT\_BUFFER]; |
|  |  | struct tm \*t; |
|  |  | time\_t ts\_midnight = 0L; |
|  |  | time\_t current\_time = 0L; |
|  |  | html\_request \*temp\_request\_item = NULL; |
|  |  |  |
|  |  | /\* define base url \*/ |
|  |  | switch (CGI\_ID) { |
|  |  | case HISTORY\_CGI\_ID: |
|  |  | strcat(url, HISTORY\_CGI); |
|  |  | strncpy(url, HISTORY\_CGI, sizeof(url)); |
|  |  | break; |
|  |  | case NOTIFICATIONS\_CGI\_ID: |
|  |  | strcat(url, NOTIFICATIONS\_CGI); |
|  |  | strncpy(url, NOTIFICATIONS\_CGI, sizeof(url)); |
|  |  | break; |
|  |  | case SHOWLOG\_CGI\_ID: |
|  |  | strcat(url, SHOWLOG\_CGI); |
|  |  | strncpy(url, SHOWLOG\_CGI, sizeof(url)); |
|  |  | break; |
|  |  | default: |
|  |  | strcat(url, "NO\_URL\_DEFINED"); |
|  |  | strncpy(url, "NO\_URL\_DEFINED", sizeof(url)); |
|  |  | break; |
|  |  | } |
|  |  |  |
|  |  | /\* get url options but filter out "ts\_end", "ts\_start" and "start" \*/ |
|  |  | if (getenv("QUERY\_STRING") != NULL && strcmp(getenv("QUERY\_STRING"), "")) { |
|  |  | if(strlen(getenv("QUERY\_STRING")) > MAX\_INPUT\_BUFFER - 1) { |
|  |  | write\_to\_cgi\_log("display\_nav\_table(): Query string exceeds max length. Returning without displaying nav table.\n"); |
|  |  | return; |
|  |  | url[sizeof(url) - 1] = '\x0'; |
|  |  |  |
|  |  | for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) { |
|  |  |  |
|  |  | if (temp\_request\_item->is\_valid == FALSE || temp\_request\_item->option == NULL) { |
|  |  | continue; |
|  |  | } |
|  |  | strcpy(stripped\_query\_string, getenv("QUERY\_STRING")); |
|  |  | strip\_html\_brackets(stripped\_query\_string); |
|  |  |  |
|  |  | /\* check if concatenated strings exceed MAX\_INPUT\_BUFFER \*/ |
|  |  | if (strlen(url) + strlen(stripped\_query\_string) + 1 > MAX\_INPUT\_BUFFER - 1) { |
|  |  | write\_to\_cgi\_log("display\_nav\_table(): Full query string exceeds max length. Returning without displaying nav table.\n"); |
|  |  | return; |
|  |  | /\* filter out "limit" and "start" \*/ |
|  |  | if (!strcmp(temp\_request\_item->option, "ts\_start") || !strcmp(temp\_request\_item->option, "ts\_end") || !strcmp(temp\_request\_item->option, "start")) { |
|  |  | continue; |
|  |  | } |
|  |  |  |
|  |  | for (temp\_buffer = my\_strtok(stripped\_query\_string, "&"); temp\_buffer != NULL; temp\_buffer = my\_strtok(NULL, "&")) { |
|  |  | if (strncmp(temp\_buffer, "ts\_start=", 9) != 0 && strncmp(temp\_buffer, "ts\_end=", 6) != 0 && strncmp(temp\_buffer, "start=", 6) != 0) { |
|  |  | if (strstr(url, "?")) |
|  |  | strcat(url, "&"); |
|  |  | else |
|  |  | strcat(url, "?"); |
|  |  | strcat(url, temp\_buffer); |
|  |  | } |
|  |  | strncpy(temp\_buffer, url, sizeof(temp\_buffer)); |
|  |  | if (temp\_request\_item->value != NULL) { |
|  |  | snprintf(url, sizeof(url) - 1, "%s%s%s=%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", url\_encode(temp\_request\_item->option), url\_encode(temp\_request\_item->value)); |
|  |  | } else { |
|  |  | snprintf(url, sizeof(url) - 1, "%s%s%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", url\_encode(temp\_request\_item->option)); |
|  |  | } |
|  |  | url[sizeof(url) - 1] = '\x0'; |
|  |  | } |
|  |  |  |
|  |  | /\* get the current time \*/ |
| Expand Down  Expand Up | | @@ -2865,49 +2863,45 @@ void print\_generic\_error\_message(char \*title, char \*text, int returnlevels) { |
|  |  | \* a new page with the desired content. |
|  |  | \*\*/ |
|  |  | void print\_export\_link(int content\_type, char \*cgi, char \*add\_to\_url) { |
|  |  | char stripped\_query\_string[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char link[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char temp\_buffer[MAX\_INPUT\_BUFFER] = ""; |
|  |  | html\_request \*temp\_request\_item = NULL; |
|  |  |  |
|  |  | if (cgi == NULL) |
|  |  | return; |
|  |  |  |
|  |  | strcat(link, cgi); |
|  |  | strncpy(link, cgi, sizeof(link)); |
|  |  | link[sizeof(link) - 1] = '\x0'; |
|  |  |  |
|  |  | /\* just do stuff if some options are requested \*/ |
|  |  | if (getenv("QUERY\_STRING") != NULL && strcmp(getenv("QUERY\_STRING"), "")) { |
|  |  | if(strlen(getenv("QUERY\_STRING")) > MAX\_INPUT\_BUFFER - 1) { |
|  |  | write\_to\_cgi\_log("print\_export\_link(): Query string exceeds max length. Returning without displaying export link.\n"); |
|  |  | return; |
|  |  | } |
|  |  | strcpy(stripped\_query\_string, getenv("QUERY\_STRING")); |
|  |  | strip\_html\_brackets(stripped\_query\_string); |
|  |  | for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) { |
|  |  |  |
|  |  | /\* check if concatenated strings exceed MAX\_INPUT\_BUFFER \*/ |
|  |  | if (strlen(link) + strlen(stripped\_query\_string) + 1 > MAX\_INPUT\_BUFFER - 1) { |
|  |  | write\_to\_cgi\_log("print\_export\_link(): Full query string exceeds max length. Returning without displaying export link.\n"); |
|  |  | return; |
|  |  | if (temp\_request\_item->is\_valid == FALSE || temp\_request\_item->option == NULL) { |
|  |  | continue; |
|  |  | } |
|  |  |  |
|  |  | strcat(link, "?"); |
|  |  | strcat(link, stripped\_query\_string); |
|  |  | strncpy(temp\_buffer, link, sizeof(temp\_buffer)); |
|  |  | if (temp\_request\_item->value != NULL) { |
|  |  | snprintf(link, sizeof(link) - 1, "%s%s%s=%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", url\_encode(temp\_request\_item->option), url\_encode(temp\_request\_item->value)); |
|  |  | } else { |
|  |  | snprintf(link, sizeof(link) - 1, "%s%s%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", url\_encode(temp\_request\_item->option)); |
|  |  | } |
|  |  | link[sizeof(link) - 1] = '\x0'; |
|  |  | } |
|  |  |  |
|  |  | /\* add string to url \*/ |
|  |  | if (add\_to\_url != NULL && strlen(add\_to\_url) != 0 && strlen(link) + strlen(stripped\_query\_string) + strlen(add\_to\_url) + 2 <= MAX\_INPUT\_BUFFER - 1) { |
|  |  | if (strlen(stripped\_query\_string) != 0) |
|  |  | strcat(link, "&"); |
|  |  | else |
|  |  | strcat(link, "?"); |
|  |  | strcat(link, add\_to\_url); |
|  |  | if (add\_to\_url != NULL && strlen(add\_to\_url) != 0) { |
|  |  | strncpy(temp\_buffer, link, sizeof(temp\_buffer)); |
|  |  | snprintf(link, sizeof(link) - 1, "%s%s%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", add\_to\_url); |
|  |  | link[sizeof(link) - 1] = '\x0'; |
|  |  | } |
|  |  |  |
|  |  | /\* print formatted link \*/ |
|  |  | if (content\_type == CSV\_CONTENT) |
|  |  | printf("<a href='%s%scsvoutput' target='\_blank'><img src='%s%s' style='vertical-align: middle;' border='0' alt='%s' title='%s'></a>\n", link, (strlen(stripped\_query\_string) != 0) ? "&" : "?", url\_images\_path, EXPORT\_CSV\_ICON, EXPORT\_CSV\_ICON\_ALT, EXPORT\_CSV\_ICON\_ALT); |
|  |  | printf("<a href='%s%scsvoutput' target='\_blank'><img src='%s%s' style='vertical-align: middle;' border='0' alt='%s' title='%s'></a>\n", link, (strstr(link, "?")) ? "&amp;" : "?", url\_images\_path, EXPORT\_CSV\_ICON, EXPORT\_CSV\_ICON\_ALT, EXPORT\_CSV\_ICON\_ALT); |
|  |  | else if (content\_type == JSON\_CONTENT) |
|  |  | printf("<a href='%s%sjsonoutput' target='\_blank'><img src='%s%s' style='vertical-align: middle;' border='0' alt='%s' title='%s'></a>\n", link, (strlen(stripped\_query\_string) != 0) ? "&" : "?", url\_images\_path, EXPORT\_JSON\_ICON, EXPORT\_JSON\_ICON\_ALT, EXPORT\_JSON\_ICON\_ALT); |
|  |  | printf("<a href='%s%sjsonoutput' target='\_blank'><img src='%s%s' style='vertical-align: middle;' border='0' alt='%s' title='%s'></a>\n", link, (strstr(link, "?")) ? "&amp;" : "?", url\_images\_path, EXPORT\_JSON\_ICON, EXPORT\_JSON\_ICON\_ALT, EXPORT\_JSON\_ICON\_ALT); |
|  |  | else if (content\_type == XML\_CONTENT) |
|  |  | printf("<a href='%s%sxmloutput' target='\_blank'><img src='%s%s' style='vertical-align: middle;' border='0' alt='%s' title='%s'></a>\n", link, (strlen(stripped\_query\_string) != 0) ? "&" : "?", url\_images\_path, EXPORT\_XML\_ICON, EXPORT\_XML\_ICON\_ALT, EXPORT\_XML\_ICON\_ALT); |
|  |  | printf("<a href='%s%sxmloutput' target='\_blank'><img src='%s%s' style='vertical-align: middle;' border='0' alt='%s' title='%s'></a>\n", link, (strstr(link, "?")) ? "&amp;" : "?", url\_images\_path, EXPORT\_XML\_ICON, EXPORT\_XML\_ICON\_ALT, EXPORT\_XML\_ICON\_ALT); |
|  |  | else |
|  |  | printf("<a href='%s' target='\_blank'><img src='%s%s' style='vertical-align: middle;' border='0' alt='%s' title='%s'></a>\n", link, url\_images\_path, EXPORT\_LINK\_ICON, EXPORT\_LINK\_ICON\_ALT, EXPORT\_LINK\_ICON\_ALT); |
|  |  |  |
| Expand Down  Expand Up | | @@ -3662,16 +3656,15 @@ void print\_modified\_attributes(int content\_type, char \*cgi, unsigned long modifi |
|  |  | /\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* pagination functions \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/ |
|  |  | /\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/ |
|  |  | void page\_num\_selector(int result\_start, int total\_entries, int displayed\_entries) { |
|  |  |  |
|  |  | char link[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char stripped\_query\_string[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char \*temp\_buffer; |
|  |  | char temp\_buffer[MAX\_INPUT\_BUFFER] = ""; |
|  |  | int total\_pages = 1; |
|  |  | int current\_page = 1; |
|  |  | //int next\_page = 0; |
|  |  | int previous\_page = 0; |
|  |  | int display\_from = 0; |
|  |  | int display\_to = 0; |
|  |  | html\_request \*temp\_request\_item = NULL; |
|  |  |  |
|  |  | /\* define base url \*/ |
|  |  | switch (CGI\_ID) { |
| Expand All | | @@ -3680,49 +3673,44 @@ void page\_num\_selector(int result\_start, int total\_entries, int displayed\_entrie |
|  |  | // strcat(link, STATUS\_CGI); |
|  |  | // break; |
|  |  | case CONFIG\_CGI\_ID: |
|  |  | strcat(link, CONFIG\_CGI); |
|  |  | strncpy(link, CONFIG\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case EXTINFO\_CGI\_ID: |
|  |  | strcat(link, EXTINFO\_CGI); |
|  |  | strncpy(link, EXTINFO\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case HISTORY\_CGI\_ID: |
|  |  | strcat(link, HISTORY\_CGI); |
|  |  | strncpy(link, HISTORY\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case NOTIFICATIONS\_CGI\_ID: |
|  |  | strcat(link, NOTIFICATIONS\_CGI); |
|  |  | strncpy(link, NOTIFICATIONS\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case SHOWLOG\_CGI\_ID: |
|  |  | strcat(link, SHOWLOG\_CGI); |
|  |  | strncpy(link, SHOWLOG\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | default: |
|  |  | strcat(link, "NO\_URL\_DEFINED"); |
|  |  | strncpy(link, "NO\_URL\_DEFINED", sizeof(link)); |
|  |  | break; |
|  |  | } |
|  |  | link[sizeof(link) - 1] = '\x0'; |
|  |  |  |
|  |  | /\* get url options but filter out "limit" and "status" \*/ |
|  |  | if (getenv("QUERY\_STRING") != NULL && strcmp(getenv("QUERY\_STRING"), "")) { |
|  |  | if(strlen(getenv("QUERY\_STRING")) > MAX\_INPUT\_BUFFER - 1) { |
|  |  | write\_to\_cgi\_log("page\_num\_selector(): Query string exceeds max length. Returning without displaying num selector.\n"); |
|  |  | return; |
|  |  | for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) { |
|  |  |  |
|  |  | if (temp\_request\_item->is\_valid == FALSE || temp\_request\_item->option == NULL) { |
|  |  | continue; |
|  |  | } |
|  |  | strcpy(stripped\_query\_string, getenv("QUERY\_STRING")); |
|  |  | strip\_html\_brackets(stripped\_query\_string); |
|  |  |  |
|  |  | /\* check if concatenated strings exceed MAX\_INPUT\_BUFFER \*/ |
|  |  | if (strlen(link) + strlen(stripped\_query\_string) + 1 > MAX\_INPUT\_BUFFER - 1) { |
|  |  | write\_to\_cgi\_log("page\_num\_selector(): Full query string exceeds max length. Returning without displaying num selector.\n"); |
|  |  | return; |
|  |  | /\* filter out "limit" and "start" \*/ |
|  |  | if (!strcmp(temp\_request\_item->option, "limit") || !strcmp(temp\_request\_item->option, "start")) { |
|  |  | continue; |
|  |  | } |
|  |  |  |
|  |  | for (temp\_buffer = my\_strtok(stripped\_query\_string, "&"); temp\_buffer != NULL; temp\_buffer = my\_strtok(NULL, "&")) { |
|  |  | if (strncmp(temp\_buffer, "limit=", 6) != 0 && strncmp(temp\_buffer, "start=", 6) != 0) { |
|  |  | if (strstr(link, "?")) |
|  |  | strcat(link, "&"); |
|  |  | else |
|  |  | strcat(link, "?"); |
|  |  | strcat(link, temp\_buffer); |
|  |  | } |
|  |  | strncpy(temp\_buffer, link, sizeof(temp\_buffer)); |
|  |  | if (temp\_request\_item->value != NULL) { |
|  |  | snprintf(link, sizeof(link) - 1, "%s%s%s=%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", url\_encode(temp\_request\_item->option), url\_encode(temp\_request\_item->value)); |
|  |  | } else { |
|  |  | snprintf(link, sizeof(link) - 1, "%s%s%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", url\_encode(temp\_request\_item->option)); |
|  |  | } |
|  |  | link[sizeof(link) - 1] = '\x0'; |
|  |  | } |
|  |  |  |
|  |  | /\* calculate pages \*/ |
| Expand Down  Expand Up | | @@ -3791,61 +3779,55 @@ void page\_num\_selector(int result\_start, int total\_entries, int displayed\_entrie |
|  |  | } |
|  |  |  |
|  |  | void page\_limit\_selector(int result\_start) { |
|  |  |  |
|  |  | static int id = 0; // gets every dropdown a single id to activate msdropdown |
|  |  | char link[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char stripped\_query\_string[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char \*temp\_buffer; |
|  |  | char temp\_buffer[MAX\_INPUT\_BUFFER] = ""; |
|  |  | html\_request \*temp\_request\_item = NULL; |
|  |  |  |
|  |  | /\* define base url \*/ |
|  |  | switch (CGI\_ID) { |
|  |  | case STATUS\_CGI\_ID: |
|  |  | strcat(link, STATUS\_CGI); |
|  |  | strncpy(link, STATUS\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case CONFIG\_CGI\_ID: |
|  |  | strcat(link, CONFIG\_CGI); |
|  |  | strncpy(link, CONFIG\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case EXTINFO\_CGI\_ID: |
|  |  | strcat(link, EXTINFO\_CGI); |
|  |  | strncpy(link, EXTINFO\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case HISTORY\_CGI\_ID: |
|  |  | strcat(link, HISTORY\_CGI); |
|  |  | strncpy(link, HISTORY\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case NOTIFICATIONS\_CGI\_ID: |
|  |  | strcat(link, NOTIFICATIONS\_CGI); |
|  |  | strncpy(link, NOTIFICATIONS\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case SHOWLOG\_CGI\_ID: |
|  |  | strcat(link, SHOWLOG\_CGI); |
|  |  | strncpy(link, SHOWLOG\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | default: |
|  |  | strcat(link, "NO\_URL\_DEFINED"); |
|  |  | strncpy(link, "NO\_URL\_DEFINED", sizeof(link)); |
|  |  | break; |
|  |  | } |
|  |  | link[sizeof(link) - 1] = '\x0'; |
|  |  |  |
|  |  | /\* get url options but filter out "limit" and "status" \*/ |
|  |  | if (getenv("QUERY\_STRING") != NULL && strcmp(getenv("QUERY\_STRING"), "")) { |
|  |  | if(strlen(getenv("QUERY\_STRING")) > MAX\_INPUT\_BUFFER - 1) { |
|  |  | write\_to\_cgi\_log("page\_limit\_selector(): Query string exceeds max length. Returning without displaying page limit selector.\n"); |
|  |  | return; |
|  |  | for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) { |
|  |  |  |
|  |  | if (temp\_request\_item->is\_valid == FALSE || temp\_request\_item->option == NULL) { |
|  |  | continue; |
|  |  | } |
|  |  | strcpy(stripped\_query\_string, getenv("QUERY\_STRING")); |
|  |  | strip\_html\_brackets(stripped\_query\_string); |
|  |  |  |
|  |  | /\* check if concatenated strings exceed MAX\_INPUT\_BUFFER \*/ |
|  |  | if (strlen(link) + strlen(stripped\_query\_string) + 1 > MAX\_INPUT\_BUFFER - 1) { |
|  |  | write\_to\_cgi\_log("page\_limit\_selector(): Full query string exceeds max length. Returning without displaying page limit selector.\n"); |
|  |  | return; |
|  |  | /\* filter out "limit" and "start" \*/ |
|  |  | if (!strcmp(temp\_request\_item->option, "limit") || !strcmp(temp\_request\_item->option, "start")) { |
|  |  | continue; |
|  |  | } |
|  |  |  |
|  |  | for (temp\_buffer = my\_strtok(stripped\_query\_string, "&"); temp\_buffer != NULL; temp\_buffer = my\_strtok(NULL, "&")) { |
|  |  | if (strncmp(temp\_buffer, "limit=", 6) != 0 && strncmp(temp\_buffer, "start=", 6) != 0) { |
|  |  | if (strstr(link, "?")) |
|  |  | strcat(link, "&"); |
|  |  | else |
|  |  | strcat(link, "?"); |
|  |  | strcat(link, temp\_buffer); |
|  |  | } |
|  |  | strncpy(temp\_buffer, link, sizeof(temp\_buffer)); |
|  |  | if (temp\_request\_item->value != NULL) { |
|  |  | snprintf(link, sizeof(link) - 1, "%s%s%s=%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", url\_encode(temp\_request\_item->option), url\_encode(temp\_request\_item->value)); |
|  |  | } else { |
|  |  | snprintf(link, sizeof(link) - 1, "%s%s%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", url\_encode(temp\_request\_item->option)); |
|  |  | } |
|  |  | link[sizeof(link) - 1] = '\x0'; |
|  |  | } |
|  |  |  |
|  |  | /\* display drop down menu to select result limit \*/ |
| Expand Down | |  |

 Loading

Oops, something went wrong.
 Retry

Toggle all file notes
Toggle all file annotations

### 0 comments on commit `31dd493`

Please
[sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FIcinga%2Ficinga-core%2Fcommit%2F31dd493a48e335203899a1b2cae473852930e203) to comment.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from www.openwall.com_18d0afeb_20250125_110217.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Follow @Openwall on Twitter for new release announcements and other news](https://twitter.com/openwall) | | --- | |
| --- | --- |

[[<prev]](14) [[next>]](16) [[thread-next>]](../../../2015/10/29/15) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-Id: <42EBFF7E-09FE-4998-9805-A2812EFC83F9@bitchbrothers.com>
Date: Fri, 23 Oct 2015 23:01:55 +0200
From: Ricardo <ricardo@...chbrothers.com>
To: oss-security@...ts.openwall.com
Subject: CVE request - Icinga 1.13.3 and older are vulnerable to XSS

Hi,

there is is a XSS vulnerability in Icinga Classic-UI 1.13.3.

This got originally introduced with this issue <https://dev.icinga.org/issues/593> and version 1.3.

Example: <http://classic.demo.icinga.org/icinga/cgi-bin/status.cgi?host=all&'onmouseover='prompt(25435);'bad='>

More infos can be found in this issue: <https://dev.icinga.org/issues/10453>

Can we get a CVE assigned to track this?

Thanks to T-Systems Germany for finding it. Thanks.

Cheers
Ricardo

Content of type "text/html" skipped

Download attachment "[smime.p7s](15/1)" of type "application/pkcs7-signature" (2538 bytes)

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from bugzilla.suse.com_f24c84d0_20250126_080746.html ===


| Bugzilla – Bug 952777 | VUL-0: CVE-2015-8010: icinga: XSS in Icinga Classic-UI | Last modified: 2019-06-07 15:52:09 UTC |
| --- | --- | --- |

|  |
| --- |

* [Home](./)
* | [New](enter_bug.cgi)
* | [Browse](describecomponents.cgi)
* | [Search](query.cgi)
* |

  [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")
* | [Reports](report.cgi)
* |
  [Requests](request.cgi)
* |
  [IDP Log In](/saml2_login.cgi?idp=IDP&target=show_bug.cgi%3Fid%3D952777)
* |
  [Forgot Password](https://idp-portal.suse.com/univention/self-service/#page=passwordreset)

[**Bug 952777**](show_bug.cgi?id=952777)
(CVE-2015-8010)
- VUL-0: CVE-2015-8010: icinga: XSS in Icinga Classic-UI

[Summary:](page.cgi?id=glossary.html#short_desc "The bug summary is a short sentence which succinctly describes what the bug is about.")
VUL-0: CVE-2015-8010: icinga: XSS in Icinga Classic-UI

| | [Status](page.cgi?id=status_resolution_matrix.html): | RESOLVED FIXED | | --- | --- | |  | | | [Alias:](page.cgi?id=glossary.html#alias "A short, unique name assigned to a bug in order to assist with looking it up and referring to it in other places in Bugzilla.") | CVE-2015-8010 | |  | | | [Product:](describecomponents.cgi "Bugs are categorised into Products and Components. Select a Classification to narrow down this list.") | SUSE Security Incidents | | [Classification:](page.cgi?id=glossary.html#classification "Bugs are categorised into Classifications, Products and Components. classifications is the top-level categorisation.") | Novell Products | | [Component:](describecomponents.cgi?product=SUSE Security Incidents "Components are second-level categories; each belongs to a particular Product. Select a Product to narrow down this list.") | Incidents ([show other bugs](buglist.cgi?component=Incidents&product=SUSE%20Security%20Incidents&bug_status=__open__)) | | [Version:](page.cgi?id=glossary.html#version "The version field defines the version of the software the bug was found in.") | unspecified | | [Hardware:](page.cgi?id=glossary.html#rep_platform "The hardware platform the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | Other Other | |  | | | [Priority](page.cgi?id=glossary.html#priority): | P3 - Medium **Severity**: Normal | | [Target Milestone:](page.cgi?id=glossary.html#target_milestone "The Target Milestone field is used to define when the engineer the bug is assigned to expects to fix it.") | --- | | [Assignee:](page.cgi?id=glossary.html#assigned_to "The person in charge of resolving the bug.") | Lars Vogdt | | [QA Contact:](page.cgi?id=glossary.html#qa_contact "The person responsible for confirming this bug if it is unconfirmed, and for verifying the fix once the bug has been resolved.") | Security Team bot | |  | | | [URL:](page.cgi?id=glossary.html#bug_file_loc "Bugs can have a URL associated with them - for example, a pointer to a web site where the problem is seen.") | <https://smash.suse.de/issue/158393/> | | [Whiteboard:](page.cgi?id=glossary.html#status_whiteboard "Each bug has a free-form single line text entry box for adding tags and status information.") | CVSSv2:NVD:CVE-2015-8010:4.3:(AV:N/AC... | | [Keywords:](describekeywords.cgi "You can add keywords from a defined list to bugs, in order to easily identify and group them.") |  | |  | | | [Depends on:](page.cgi?id=glossary.html#dependson "The bugs listed here must be resolved before this bug can be resolved.") |  | | [Blocks:](page.cgi?id=glossary.html#blocked "This bug must be resolved before the bugs listed in this field can be resolved.") |  | |  | | Reported: | 2015-10-30 08:47 UTC by Johannes Segitz | | --- | --- | | Modified: | 2019-06-07 15:52 UTC ([History](show_activity.cgi?id=952777)) | | CC List: | 5 users (show)  eich lars.vogdt meissner smash\_bz thardeck | |  | | | [See Also:](page.cgi?id=glossary.html#see_also "This allows you to refer to bugs in other installations. You can enter a URL to a bug in the 'Add Bug URLs' field to note that that bug is related to this one. You can enter multiple URLs at once by separating them with whitespace. You should normally use this field to refer to bugs in other installations. For bugs in this installation, it is better to use the Depends on and Blocks fields.") |  | | [Found By:](page.cgi?id=glossary.html#cf_foundby "A custom Drop Down field in this installation of Bugzilla.") | Security Response Team | | [Services Priority:](page.cgi?id=glossary.html#cf_nts_priority "A custom Free Text field in this installation of Bugzilla.") |  | | [Business Priority:](page.cgi?id=glossary.html#cf_biz_priority "A custom Free Text field in this installation of Bugzilla.") |  | | [Blocker:](page.cgi?id=glossary.html#cf_blocker "A custom Drop Down field in this installation of Bugzilla.") | --- | | [Marketing QA Status:](page.cgi?id=glossary.html#cf_marketing_qa_status "A custom Drop Down field in this installation of Bugzilla.") | --- | | [IT Deployment:](page.cgi?id=glossary.html#cf_it_deployment "A custom Drop Down field in this installation of Bugzilla.") | --- | |  | |  * [Clone This Bug](enter_bug.cgi?cloned_bug_id=952777) |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| --- | | |

| | Attachments | | | --- | --- | | [Add an attachment](attachment.cgi?bugid=952777&action=enter) (proposed patch, testcase, etc.) | |   | Note You need to [log in](show_bug.cgi?id=952777&GoAheadAndLogIn=1) before you can comment on or make changes to this bug. | | --- | |  |
| --- | --- | --- | --- | --- | --- | --- |

| [Description](show_bug.cgi?id=952777#c0)  Johannes Segitz   2015-10-30 08:47:53 UTC  ``` CVE-2015-8010  From: Ricardo (no last name) on OSS  there is is a XSS vulnerability in Icinga Classic-UI 1.13.3.  This got originally introduced with this issue <https://dev.icinga.org/issues/593> and version 1.3.  Example: <http://classic.demo.icinga.org/icinga/cgi-bin/status.cgi?host=all&'onmouseover='prompt(25435);'bad>='  More infos can be found in this issue: <https://dev.icinga.org/issues/10453>  ======  Found by T-Systems Germany  openSUSE 13.1, 13.2, 42, Factory and SLE 12 affected  References: <http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-8010> <http://seclists.org/oss-sec/2015/q4/196> <http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-8010> ``` [Comment 1](show_bug.cgi?id=952777#c1)  Swamp Workflow Management   2015-10-30 23:00:15 UTC  ``` bugbot adjusting priority ``` [Comment 2](show_bug.cgi?id=952777#c2)  Swamp Workflow Management   2017-01-16 18:15:28 UTC  ``` openSUSE-SU-2017:0146-1: An update that fixes two vulnerabilities is now available.  Category: security (important) Bug References: 1014637,952777 CVE References: CVE-2015-8010,CVE-2016-9566 Sources used: openSUSE Leap 42.2 (src):    icinga-1.14.0-4.1 openSUSE Leap 42.1 (src):    icinga-1.14.0-3.1 ``` [Comment 4](show_bug.cgi?id=952777#c4)  Bernhard Wiedemann   2017-12-01 23:40:18 UTC  ``` This is an autogenerated message for OBS integration: This bug (952777) was mentioned in <https://build.opensuse.org/request/show/547289> Factory / icinga <https://build.opensuse.org/request/show/547290> 42.2+42.3 / icinga <https://build.opensuse.org/request/show/547295> 42.2+42.3 / icinga ``` [Comment 6](show_bug.cgi?id=952777#c6)  Bernhard Wiedemann   2017-12-02 01:40:32 UTC  ``` This is an autogenerated message for OBS integration: This bug (952777) was mentioned in <https://build.opensuse.org/request/show/547320> 42.2+42.3 / icinga <https://build.opensuse.org/request/show/547321> 42.2+42.3 / icinga <https://build.opensuse.org/request/show/547324> Factory / icinga ``` [Comment 7](show_bug.cgi?id=952777#c7)  Swamp Workflow Management   2017-12-19 15:11:00 UTC  ``` This is an autogenerated message for OBS integration: This bug (952777) was mentioned in <https://build.opensuse.org/request/show/558566> Factory / icinga ``` [Comment 11](show_bug.cgi?id=952777#c11)  Swamp Workflow Management   2018-10-11 10:40:16 UTC  ``` This is an autogenerated message for OBS integration: This bug (952777) was mentioned in <https://build.opensuse.org/request/show/641224> 42.2+42.3 / icinga ``` [Comment 14](show_bug.cgi?id=952777#c14)  Swamp Workflow Management   2018-10-19 16:41:29 UTC  ``` openSUSE-SU-2018:3258-1: An update that fixes four vulnerabilities is now available.  Category: security (moderate) Bug References: 1011630,1018047,952777,961115 CVE References: CVE-2015-8010,CVE-2016-0726,CVE-2016-10089,CVE-2016-8641 Sources used: openSUSE Leap 42.3 (src):    icinga-1.14.0-8.3.2 ``` [Comment 15](show_bug.cgi?id=952777#c15)  Swamp Workflow Management   2018-11-05 20:09:30 UTC  ``` SUSE-SU-2018:3620-1: An update that fixes three vulnerabilities is now available.  Category: security (moderate) Bug References: 1011630,1018047,952777 CVE References: CVE-2015-8010,CVE-2016-10089,CVE-2016-8641 Sources used: SUSE Manager Tools 12 (src):    icinga-1.13.3-12.3.1 SUSE Enterprise Storage 4 (src):    icinga-1.13.3-12.3.1 ``` [Comment 16](show_bug.cgi?id=952777#c16)  Lars Vogdt   2019-06-07 15:52:09 UTC  ``` Closing -> update released ``` |  |
| --- | --- |

---

* [Format For Printing](show_bug.cgi?format=multiple&id=952777)
* - [XML](show_bug.cgi?ctype=xml&id=952777)
* - [Clone This Bug](enter_bug.cgi?cloned_bug_id=952777)
* - Top of page

* + [Home](./)
  + | [New](enter_bug.cgi)
  + | [Browse](describecomponents.cgi)
  + | [Search](query.cgi)
  + |

    [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")
  + | [Reports](report.cgi)
  + |
    [Requests](request.cgi)
  + |
    [IDP Log In](/saml2_login.cgi?idp=IDP&target=show_bug.cgi%3Fid%3D952777)
  + |
    [Forgot Password](https://idp-portal.suse.com/univention/self-service/#page=passwordreset)

+ Legal:
+ [openSUSE](http://en.opensuse.org/Terms_of_site)
+ [SUSE](https://www.suse.com/company/legal/)



=== Content from github.com_c6d6958e_20250126_080753.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FIcinga%2Ficinga-core%2Fissues%3Fq%3Dstate%253Aopen%2520la)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

state:open la

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FIcinga%2Ficinga-core%2Fissues%3Fq%3Dstate%253Aopen%2520la)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fissues%2Findex&source=header-repo&source_repo=Icinga%2Ficinga-core)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

This repository has been archived by the owner on Jan 15, 2019. It is now read-only.

[Icinga](/Icinga)
/
**[icinga-core](/Icinga/icinga-core)**
Public archive

* [Notifications](/login?return_to=%2FIcinga%2Ficinga-core) You must be signed in to change notification settings
* [Fork
  28](/login?return_to=%2FIcinga%2Ficinga-core)
* [Star
   44](/login?return_to=%2FIcinga%2Ficinga-core)

* [Code](/Icinga/icinga-core)
* [Issues
  2](/Icinga/icinga-core/issues)
* [Pull requests
  2](/Icinga/icinga-core/pulls)
* [Actions](/Icinga/icinga-core/actions)
* [Security](/Icinga/icinga-core/security)
* [Insights](/Icinga/icinga-core/pulse)

Additional navigation options

* [Code](/Icinga/icinga-core)
* [Issues](/Icinga/icinga-core/issues)
* [Pull requests](/Icinga/icinga-core/pulls)
* [Actions](/Icinga/icinga-core/actions)
* [Security](/Icinga/icinga-core/security)
* [Insights](/Icinga/icinga-core/pulse)

Preview
# Issues

Search Issuesstate:open laSearch

[Labels](labels)[Milestones](milestones)
## Search results

OpenClosedAuthorLabelsProjectsMilestonesAssigneesTypesNewest

### No results

Try adjusting your search filters.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_69997dcd_20250126_080756.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FIcinga%2Ficinga-core%2Fcommit%2F5c816f5d9352c373e9dadb95b63612a96cf96df)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FIcinga%2Ficinga-core%2Fcommit%2F5c816f5d9352c373e9dadb95b63612a96cf96df)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fcommit_fragments%2Frepo_layout&source=header-repo&source_repo=Icinga%2Ficinga-core)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

This repository has been archived by the owner on Jan 15, 2019. It is now read-only.

[Icinga](/Icinga)
/
**[icinga-core](/Icinga/icinga-core)**
Public archive

* [Notifications](/login?return_to=%2FIcinga%2Ficinga-core) You must be signed in to change notification settings
* [Fork
  28](/login?return_to=%2FIcinga%2Ficinga-core)
* [Star
   44](/login?return_to=%2FIcinga%2Ficinga-core)

* [Code](/Icinga/icinga-core)
* [Issues
  2](/Icinga/icinga-core/issues)
* [Pull requests
  2](/Icinga/icinga-core/pulls)
* [Actions](/Icinga/icinga-core/actions)
* [Security](/Icinga/icinga-core/security)
* [Insights](/Icinga/icinga-core/pulse)

Additional navigation options

* [Code](/Icinga/icinga-core)
* [Issues](/Icinga/icinga-core/issues)
* [Pull requests](/Icinga/icinga-core/pulls)
* [Actions](/Icinga/icinga-core/actions)
* [Security](/Icinga/icinga-core/security)
* [Insights](/Icinga/icinga-core/pulse)

## Commit

[Permalink](/Icinga/icinga-core/commit/5c816f5d9352c373e9dadb95b63612a96cf96dff)

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

Classic-UI: fixes a XXS vulnerability in pagination and export links …

[Browse files](/Icinga/icinga-core/tree/5c816f5d9352c373e9dadb95b63612a96cf96dff)
Browse the repository at this point in the history

```
…#10453

Sorry guys. Due to my bad programming skills I introduced a
XSS vulnerability in Classic-UI with the CSV export link and
pagination feature. The functions parsed QUERY_STRING from
the environment without properly sanitizing it.

The getcgivars() function got a bit reworked. Once the
QUERY_STRING is read and parsed the content survives the
whole lifetime of the cgi execution and gets free’d at
the end. This way we can always build urls from valid parsed
cgi params.

I wonder why I haven't done this earlier.

Also the url param parsing in every cgi was updated and
hopefully everything works as bevor.

Refs: #10453
```

* Loading branch information

[![@bb-Ricardo](https://avatars.githubusercontent.com/u/771836?s=40&v=4)](/bb-Ricardo)

[bb-Ricardo](/Icinga/icinga-core/commits?author=bb-Ricardo "View all commits by bb-Ricardo")
committed
Oct 23, 2015

1 parent
[fb5e3c8](/Icinga/icinga-core/commit/fb5e3c84d6401a2e82815e544bc2cc0c81bc7f8a)

commit 5c816f5

 Show file tree

 Hide file tree

Showing
**17 changed files**
with
**1,482 additions**
and
**1,840 deletions**.

* Whitespace
* Ignore whitespace

* Split
* Unified

* cgi

  + cgi/avail.c
    [avail.c](#diff-0e01d33888184b9dfe71991e0da2d3658bfae657cf2cffc6b5ad63f5ff2abd19)
  + cgi/cgiutils.c
    [cgiutils.c](#diff-04d6fa2365a08ab911e7e03543f4c8e3c4236663b55997f8aa7748f31bfd352a)
  + cgi/cmd.c
    [cmd.c](#diff-af4a2bd1f12fe0e22b1b8683d67a6cbc1c848534be2b5d701d2ed70c5cf3c99c)
  + cgi/config.c
    [config.c](#diff-eff840f7de6c344f94afd6e9ffbd1625aa6cbad014b51764444a4b3c0c2ad91f)
  + cgi/extinfo.c
    [extinfo.c](#diff-235d93c182b89466dd5b41d95b2378bba303d000cdb44f72bbefda32cfa6550d)
  + cgi/getcgi.c
    [getcgi.c](#diff-9381f3b2558f6a6078eb76aefc503505cae27c7976607e59ea9db8af934c2db7)
  + cgi/histogram.c
    [histogram.c](#diff-b0b887a9c9f825216e0840cd7ba206266efdc85c51b240b49ceaa5842e100dd1)
  + cgi/history.c
    [history.c](#diff-6b7434a5c4364cae7a574c72cbef93083f8fb81b6d4b95a01f4c9541c6c1162f)
  + cgi/notifications.c
    [notifications.c](#diff-0555e0ba36244fe2d9f54e48ef13a2428a21160854a4f4e2b0cfe9ddefafe98b)
  + cgi/outages.c
    [outages.c](#diff-af4003fe07154ad01307550cf9f4c1703b560ff6452740072254c20f886e387c)
  + cgi/showlog.c
    [showlog.c](#diff-2295e2b3cf40eb175d700801f073183e228477ad5c9d40d5068c85a2785a1df4)
  + cgi/status.c
    [status.c](#diff-43c30f3dd8fcb2870458e02b7372412844f1616585163ee5b3661e10e9329226)
  + cgi/statusmap.c
    [statusmap.c](#diff-6f1e82e0790f365261975ea38c36187492fd04e88918da934394e896645bc067)
  + cgi/summary.c
    [summary.c](#diff-009dbeb5d0584dccd2956e58b8d205e674bf94074eacf5f052416dc6b7ae76f9)
  + cgi/tac.c
    [tac.c](#diff-08cab4508583fb4c29f5475fa8c0cf2776f1ce0f50b37100147c14d2297a92f9)
  + cgi/trends.c
    [trends.c](#diff-51d1a2e96e6422c78ae0e58c75c026b710e2081bd5ad127aa5f34bad751c30a8)
* include

  + include/getcgi.h
    [getcgi.h](#diff-1507884387d8d5c883d7413810ee19ba9125e6f4654959cc185667c32b049a5e)

## There are no files selected for viewing

323 changes: 133 additions & 190 deletions

323
[cgi/avail.c](#diff-0e01d33888184b9dfe71991e0da2d3658bfae657cf2cffc6b5ad63f5ff2abd19 "cgi/avail.c")

Show comments

[View file](/Icinga/icinga-core/blob/5c816f5d9352c373e9dadb95b63612a96cf96dff/cgi/avail.c)
Delete file

Load diff

Large diffs are not rendered by default.

Oops, something went wrong.

Retry

196 changes: 89 additions & 107 deletions

196
[cgi/cgiutils.c](#diff-04d6fa2365a08ab911e7e03543f4c8e3c4236663b55997f8aa7748f31bfd352a "cgi/cgiutils.c")

Show comments

[View file](/Icinga/icinga-core/blob/5c816f5d9352c373e9dadb95b63612a96cf96dff/cgi/cgiutils.c)
Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -31,6 +31,7 @@ |
|  |  | #include "../include/comments.h" |
|  |  |  |
|  |  | #include "../include/cgiutils.h" |
|  |  | #include "../include/getcgi.h" |
|  |  |  |
|  |  | char main\_config\_file[MAX\_FILENAME\_LENGTH]; |
|  |  | char command\_file[MAX\_FILENAME\_LENGTH]; |
| Expand Down  Expand Up | | @@ -208,6 +209,7 @@ extern serviceescalation \*serviceescalation\_list; |
|  |  |  |
|  |  | extern hoststatus \*hoststatus\_list; |
|  |  | extern servicestatus \*servicestatus\_list; |
|  |  | extern html\_request \*html\_request\_list; |
|  |  |  |
|  |  |  |
|  |  | char encoded\_url\_string[4][MAX\_INPUT\_BUFFER]; // 4 to be able to use url\_encode 4 times |
| Expand Down  Expand Up | | @@ -2223,54 +2225,50 @@ void display\_info\_table(char \*title, authdata \*current\_authdata, int daemon\_chec |
|  |  | } |
|  |  |  |
|  |  | void display\_nav\_table(time\_t ts\_start, time\_t ts\_end) { |
|  |  | char \*temp\_buffer; |
|  |  | char temp\_buffer[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char url[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char stripped\_query\_string[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char date\_time[MAX\_INPUT\_BUFFER]; |
|  |  | struct tm \*t; |
|  |  | time\_t ts\_midnight = 0L; |
|  |  | time\_t current\_time = 0L; |
|  |  | html\_request \*temp\_request\_item = NULL; |
|  |  |  |
|  |  | /\* define base url \*/ |
|  |  | switch (CGI\_ID) { |
|  |  | case HISTORY\_CGI\_ID: |
|  |  | strcat(url, HISTORY\_CGI); |
|  |  | strncpy(url, HISTORY\_CGI, sizeof(url)); |
|  |  | break; |
|  |  | case NOTIFICATIONS\_CGI\_ID: |
|  |  | strcat(url, NOTIFICATIONS\_CGI); |
|  |  | strncpy(url, NOTIFICATIONS\_CGI, sizeof(url)); |
|  |  | break; |
|  |  | case SHOWLOG\_CGI\_ID: |
|  |  | strcat(url, SHOWLOG\_CGI); |
|  |  | strncpy(url, SHOWLOG\_CGI, sizeof(url)); |
|  |  | break; |
|  |  | default: |
|  |  | strcat(url, "NO\_URL\_DEFINED"); |
|  |  | strncpy(url, "NO\_URL\_DEFINED", sizeof(url)); |
|  |  | break; |
|  |  | } |
|  |  |  |
|  |  | /\* get url options but filter out "ts\_end", "ts\_start" and "start" \*/ |
|  |  | if (getenv("QUERY\_STRING") != NULL && strcmp(getenv("QUERY\_STRING"), "")) { |
|  |  | if(strlen(getenv("QUERY\_STRING")) > MAX\_INPUT\_BUFFER - 1) { |
|  |  | write\_to\_cgi\_log("display\_nav\_table(): Query string exceeds max length. Returning without displaying nav table.\n"); |
|  |  | return; |
|  |  | url[sizeof(url) - 1] = '\x0'; |
|  |  |  |
|  |  | for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) { |
|  |  |  |
|  |  | if (temp\_request\_item->is\_valid == FALSE || temp\_request\_item->option == NULL) { |
|  |  | continue; |
|  |  | } |
|  |  | strcpy(stripped\_query\_string, getenv("QUERY\_STRING")); |
|  |  | strip\_html\_brackets(stripped\_query\_string); |
|  |  |  |
|  |  | /\* check if concatenated strings exceed MAX\_INPUT\_BUFFER \*/ |
|  |  | if (strlen(url) + strlen(stripped\_query\_string) + 1 > MAX\_INPUT\_BUFFER - 1) { |
|  |  | write\_to\_cgi\_log("display\_nav\_table(): Full query string exceeds max length. Returning without displaying nav table.\n"); |
|  |  | return; |
|  |  | /\* filter out "limit" and "start" \*/ |
|  |  | if (!strcmp(temp\_request\_item->option, "ts\_start") || !strcmp(temp\_request\_item->option, "ts\_end") || !strcmp(temp\_request\_item->option, "start")) { |
|  |  | continue; |
|  |  | } |
|  |  |  |
|  |  | for (temp\_buffer = my\_strtok(stripped\_query\_string, "&"); temp\_buffer != NULL; temp\_buffer = my\_strtok(NULL, "&")) { |
|  |  | if (strncmp(temp\_buffer, "ts\_start=", 9) != 0 && strncmp(temp\_buffer, "ts\_end=", 6) != 0 && strncmp(temp\_buffer, "start=", 6) != 0) { |
|  |  | if (strstr(url, "?")) |
|  |  | strcat(url, "&"); |
|  |  | else |
|  |  | strcat(url, "?"); |
|  |  | strcat(url, temp\_buffer); |
|  |  | } |
|  |  | strncpy(temp\_buffer, url, sizeof(temp\_buffer)); |
|  |  | if (temp\_request\_item->value != NULL) { |
|  |  | snprintf(url, sizeof(url) - 1, "%s%s%s=%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", url\_encode(temp\_request\_item->option), url\_encode(temp\_request\_item->value)); |
|  |  | } else { |
|  |  | snprintf(url, sizeof(url) - 1, "%s%s%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", url\_encode(temp\_request\_item->option)); |
|  |  | } |
|  |  | url[sizeof(url) - 1] = '\x0'; |
|  |  | } |
|  |  |  |
|  |  | /\* get the current time \*/ |
| Expand Down  Expand Up | | @@ -2865,49 +2863,45 @@ void print\_generic\_error\_message(char \*title, char \*text, int returnlevels) { |
|  |  | \* a new page with the desired content. |
|  |  | \*\*/ |
|  |  | void print\_export\_link(int content\_type, char \*cgi, char \*add\_to\_url) { |
|  |  | char stripped\_query\_string[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char link[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char temp\_buffer[MAX\_INPUT\_BUFFER] = ""; |
|  |  | html\_request \*temp\_request\_item = NULL; |
|  |  |  |
|  |  | if (cgi == NULL) |
|  |  | return; |
|  |  |  |
|  |  | strcat(link, cgi); |
|  |  | strncpy(link, cgi, sizeof(link)); |
|  |  | link[sizeof(link) - 1] = '\x0'; |
|  |  |  |
|  |  | /\* just do stuff if some options are requested \*/ |
|  |  | if (getenv("QUERY\_STRING") != NULL && strcmp(getenv("QUERY\_STRING"), "")) { |
|  |  | if(strlen(getenv("QUERY\_STRING")) > MAX\_INPUT\_BUFFER - 1) { |
|  |  | write\_to\_cgi\_log("print\_export\_link(): Query string exceeds max length. Returning without displaying export link.\n"); |
|  |  | return; |
|  |  | } |
|  |  | strcpy(stripped\_query\_string, getenv("QUERY\_STRING")); |
|  |  | strip\_html\_brackets(stripped\_query\_string); |
|  |  | for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) { |
|  |  |  |
|  |  | /\* check if concatenated strings exceed MAX\_INPUT\_BUFFER \*/ |
|  |  | if (strlen(link) + strlen(stripped\_query\_string) + 1 > MAX\_INPUT\_BUFFER - 1) { |
|  |  | write\_to\_cgi\_log("print\_export\_link(): Full query string exceeds max length. Returning without displaying export link.\n"); |
|  |  | return; |
|  |  | if (temp\_request\_item->is\_valid == FALSE || temp\_request\_item->option == NULL) { |
|  |  | continue; |
|  |  | } |
|  |  |  |
|  |  | strcat(link, "?"); |
|  |  | strcat(link, stripped\_query\_string); |
|  |  | strncpy(temp\_buffer, link, sizeof(temp\_buffer)); |
|  |  | if (temp\_request\_item->value != NULL) { |
|  |  | snprintf(link, sizeof(link) - 1, "%s%s%s=%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", url\_encode(temp\_request\_item->option), url\_encode(temp\_request\_item->value)); |
|  |  | } else { |
|  |  | snprintf(link, sizeof(link) - 1, "%s%s%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", url\_encode(temp\_request\_item->option)); |
|  |  | } |
|  |  | link[sizeof(link) - 1] = '\x0'; |
|  |  | } |
|  |  |  |
|  |  | /\* add string to url \*/ |
|  |  | if (add\_to\_url != NULL && strlen(add\_to\_url) != 0 && strlen(link) + strlen(stripped\_query\_string) + strlen(add\_to\_url) + 2 <= MAX\_INPUT\_BUFFER - 1) { |
|  |  | if (strlen(stripped\_query\_string) != 0) |
|  |  | strcat(link, "&"); |
|  |  | else |
|  |  | strcat(link, "?"); |
|  |  | strcat(link, add\_to\_url); |
|  |  | if (add\_to\_url != NULL && strlen(add\_to\_url) != 0) { |
|  |  | strncpy(temp\_buffer, link, sizeof(temp\_buffer)); |
|  |  | snprintf(link, sizeof(link) - 1, "%s%s%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", add\_to\_url); |
|  |  | link[sizeof(link) - 1] = '\x0'; |
|  |  | } |
|  |  |  |
|  |  | /\* print formatted link \*/ |
|  |  | if (content\_type == CSV\_CONTENT) |
|  |  | printf("<a href='%s%scsvoutput' target='\_blank'><img src='%s%s' style='vertical-align: middle;' border='0' alt='%s' title='%s'></a>\n", link, (strlen(stripped\_query\_string) != 0) ? "&" : "?", url\_images\_path, EXPORT\_CSV\_ICON, EXPORT\_CSV\_ICON\_ALT, EXPORT\_CSV\_ICON\_ALT); |
|  |  | printf("<a href='%s%scsvoutput' target='\_blank'><img src='%s%s' style='vertical-align: middle;' border='0' alt='%s' title='%s'></a>\n", link, (strstr(link, "?")) ? "&amp;" : "?", url\_images\_path, EXPORT\_CSV\_ICON, EXPORT\_CSV\_ICON\_ALT, EXPORT\_CSV\_ICON\_ALT); |
|  |  | else if (content\_type == JSON\_CONTENT) |
|  |  | printf("<a href='%s%sjsonoutput' target='\_blank'><img src='%s%s' style='vertical-align: middle;' border='0' alt='%s' title='%s'></a>\n", link, (strlen(stripped\_query\_string) != 0) ? "&" : "?", url\_images\_path, EXPORT\_JSON\_ICON, EXPORT\_JSON\_ICON\_ALT, EXPORT\_JSON\_ICON\_ALT); |
|  |  | printf("<a href='%s%sjsonoutput' target='\_blank'><img src='%s%s' style='vertical-align: middle;' border='0' alt='%s' title='%s'></a>\n", link, (strstr(link, "?")) ? "&amp;" : "?", url\_images\_path, EXPORT\_JSON\_ICON, EXPORT\_JSON\_ICON\_ALT, EXPORT\_JSON\_ICON\_ALT); |
|  |  | else if (content\_type == XML\_CONTENT) |
|  |  | printf("<a href='%s%sxmloutput' target='\_blank'><img src='%s%s' style='vertical-align: middle;' border='0' alt='%s' title='%s'></a>\n", link, (strlen(stripped\_query\_string) != 0) ? "&" : "?", url\_images\_path, EXPORT\_XML\_ICON, EXPORT\_XML\_ICON\_ALT, EXPORT\_XML\_ICON\_ALT); |
|  |  | printf("<a href='%s%sxmloutput' target='\_blank'><img src='%s%s' style='vertical-align: middle;' border='0' alt='%s' title='%s'></a>\n", link, (strstr(link, "?")) ? "&amp;" : "?", url\_images\_path, EXPORT\_XML\_ICON, EXPORT\_XML\_ICON\_ALT, EXPORT\_XML\_ICON\_ALT); |
|  |  | else |
|  |  | printf("<a href='%s' target='\_blank'><img src='%s%s' style='vertical-align: middle;' border='0' alt='%s' title='%s'></a>\n", link, url\_images\_path, EXPORT\_LINK\_ICON, EXPORT\_LINK\_ICON\_ALT, EXPORT\_LINK\_ICON\_ALT); |
|  |  |  |
| Expand Down  Expand Up | | @@ -3662,16 +3656,15 @@ void print\_modified\_attributes(int content\_type, char \*cgi, unsigned long modifi |
|  |  | /\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* pagination functions \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/ |
|  |  | /\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/ |
|  |  | void page\_num\_selector(int result\_start, int total\_entries, int displayed\_entries) { |
|  |  |  |
|  |  | char link[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char stripped\_query\_string[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char \*temp\_buffer; |
|  |  | char temp\_buffer[MAX\_INPUT\_BUFFER] = ""; |
|  |  | int total\_pages = 1; |
|  |  | int current\_page = 1; |
|  |  | //int next\_page = 0; |
|  |  | int previous\_page = 0; |
|  |  | int display\_from = 0; |
|  |  | int display\_to = 0; |
|  |  | html\_request \*temp\_request\_item = NULL; |
|  |  |  |
|  |  | /\* define base url \*/ |
|  |  | switch (CGI\_ID) { |
| Expand All | | @@ -3680,49 +3673,44 @@ void page\_num\_selector(int result\_start, int total\_entries, int displayed\_entrie |
|  |  | // strcat(link, STATUS\_CGI); |
|  |  | // break; |
|  |  | case CONFIG\_CGI\_ID: |
|  |  | strcat(link, CONFIG\_CGI); |
|  |  | strncpy(link, CONFIG\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case EXTINFO\_CGI\_ID: |
|  |  | strcat(link, EXTINFO\_CGI); |
|  |  | strncpy(link, EXTINFO\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case HISTORY\_CGI\_ID: |
|  |  | strcat(link, HISTORY\_CGI); |
|  |  | strncpy(link, HISTORY\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case NOTIFICATIONS\_CGI\_ID: |
|  |  | strcat(link, NOTIFICATIONS\_CGI); |
|  |  | strncpy(link, NOTIFICATIONS\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case SHOWLOG\_CGI\_ID: |
|  |  | strcat(link, SHOWLOG\_CGI); |
|  |  | strncpy(link, SHOWLOG\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | default: |
|  |  | strcat(link, "NO\_URL\_DEFINED"); |
|  |  | strncpy(link, "NO\_URL\_DEFINED", sizeof(link)); |
|  |  | break; |
|  |  | } |
|  |  | link[sizeof(link) - 1] = '\x0'; |
|  |  |  |
|  |  | /\* get url options but filter out "limit" and "status" \*/ |
|  |  | if (getenv("QUERY\_STRING") != NULL && strcmp(getenv("QUERY\_STRING"), "")) { |
|  |  | if(strlen(getenv("QUERY\_STRING")) > MAX\_INPUT\_BUFFER - 1) { |
|  |  | write\_to\_cgi\_log("page\_num\_selector(): Query string exceeds max length. Returning without displaying num selector.\n"); |
|  |  | return; |
|  |  | for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) { |
|  |  |  |
|  |  | if (temp\_request\_item->is\_valid == FALSE || temp\_request\_item->option == NULL) { |
|  |  | continue; |
|  |  | } |
|  |  | strcpy(stripped\_query\_string, getenv("QUERY\_STRING")); |
|  |  | strip\_html\_brackets(stripped\_query\_string); |
|  |  |  |
|  |  | /\* check if concatenated strings exceed MAX\_INPUT\_BUFFER \*/ |
|  |  | if (strlen(link) + strlen(stripped\_query\_string) + 1 > MAX\_INPUT\_BUFFER - 1) { |
|  |  | write\_to\_cgi\_log("page\_num\_selector(): Full query string exceeds max length. Returning without displaying num selector.\n"); |
|  |  | return; |
|  |  | /\* filter out "limit" and "start" \*/ |
|  |  | if (!strcmp(temp\_request\_item->option, "limit") || !strcmp(temp\_request\_item->option, "start")) { |
|  |  | continue; |
|  |  | } |
|  |  |  |
|  |  | for (temp\_buffer = my\_strtok(stripped\_query\_string, "&"); temp\_buffer != NULL; temp\_buffer = my\_strtok(NULL, "&")) { |
|  |  | if (strncmp(temp\_buffer, "limit=", 6) != 0 && strncmp(temp\_buffer, "start=", 6) != 0) { |
|  |  | if (strstr(link, "?")) |
|  |  | strcat(link, "&"); |
|  |  | else |
|  |  | strcat(link, "?"); |
|  |  | strcat(link, temp\_buffer); |
|  |  | } |
|  |  | strncpy(temp\_buffer, link, sizeof(temp\_buffer)); |
|  |  | if (temp\_request\_item->value != NULL) { |
|  |  | snprintf(link, sizeof(link) - 1, "%s%s%s=%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", url\_encode(temp\_request\_item->option), url\_encode(temp\_request\_item->value)); |
|  |  | } else { |
|  |  | snprintf(link, sizeof(link) - 1, "%s%s%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", url\_encode(temp\_request\_item->option)); |
|  |  | } |
|  |  | link[sizeof(link) - 1] = '\x0'; |
|  |  | } |
|  |  |  |
|  |  | /\* calculate pages \*/ |
| Expand Down  Expand Up | | @@ -3791,61 +3779,55 @@ void page\_num\_selector(int result\_start, int total\_entries, int displayed\_entrie |
|  |  | } |
|  |  |  |
|  |  | void page\_limit\_selector(int result\_start) { |
|  |  |  |
|  |  | static int id = 0; // gets every dropdown a single id to activate msdropdown |
|  |  | char link[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char stripped\_query\_string[MAX\_INPUT\_BUFFER] = ""; |
|  |  | char \*temp\_buffer; |
|  |  | char temp\_buffer[MAX\_INPUT\_BUFFER] = ""; |
|  |  | html\_request \*temp\_request\_item = NULL; |
|  |  |  |
|  |  | /\* define base url \*/ |
|  |  | switch (CGI\_ID) { |
|  |  | case STATUS\_CGI\_ID: |
|  |  | strcat(link, STATUS\_CGI); |
|  |  | strncpy(link, STATUS\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case CONFIG\_CGI\_ID: |
|  |  | strcat(link, CONFIG\_CGI); |
|  |  | strncpy(link, CONFIG\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case EXTINFO\_CGI\_ID: |
|  |  | strcat(link, EXTINFO\_CGI); |
|  |  | strncpy(link, EXTINFO\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case HISTORY\_CGI\_ID: |
|  |  | strcat(link, HISTORY\_CGI); |
|  |  | strncpy(link, HISTORY\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case NOTIFICATIONS\_CGI\_ID: |
|  |  | strcat(link, NOTIFICATIONS\_CGI); |
|  |  | strncpy(link, NOTIFICATIONS\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | case SHOWLOG\_CGI\_ID: |
|  |  | strcat(link, SHOWLOG\_CGI); |
|  |  | strncpy(link, SHOWLOG\_CGI, sizeof(link)); |
|  |  | break; |
|  |  | default: |
|  |  | strcat(link, "NO\_URL\_DEFINED"); |
|  |  | strncpy(link, "NO\_URL\_DEFINED", sizeof(link)); |
|  |  | break; |
|  |  | } |
|  |  | link[sizeof(link) - 1] = '\x0'; |
|  |  |  |
|  |  | /\* get url options but filter out "limit" and "status" \*/ |
|  |  | if (getenv("QUERY\_STRING") != NULL && strcmp(getenv("QUERY\_STRING"), "")) { |
|  |  | if(strlen(getenv("QUERY\_STRING")) > MAX\_INPUT\_BUFFER - 1) { |
|  |  | write\_to\_cgi\_log("page\_limit\_selector(): Query string exceeds max length. Returning without displaying page limit selector.\n"); |
|  |  | return; |
|  |  | for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) { |
|  |  |  |
|  |  | if (temp\_request\_item->is\_valid == FALSE || temp\_request\_item->option == NULL) { |
|  |  | continue; |
|  |  | } |
|  |  | strcpy(stripped\_query\_string, getenv("QUERY\_STRING")); |
|  |  | strip\_html\_brackets(stripped\_query\_string); |
|  |  |  |
|  |  | /\* check if concatenated strings exceed MAX\_INPUT\_BUFFER \*/ |
|  |  | if (strlen(link) + strlen(stripped\_query\_string) + 1 > MAX\_INPUT\_BUFFER - 1) { |
|  |  | write\_to\_cgi\_log("page\_limit\_selector(): Full query string exceeds max length. Returning without displaying page limit selector.\n"); |
|  |  | return; |
|  |  | /\* filter out "limit" and "start" \*/ |
|  |  | if (!strcmp(temp\_request\_item->option, "limit") || !strcmp(temp\_request\_item->option, "start")) { |
|  |  | continue; |
|  |  | } |
|  |  |  |
|  |  | for (temp\_buffer = my\_strtok(stripped\_query\_string, "&"); temp\_buffer != NULL; temp\_buffer = my\_strtok(NULL, "&")) { |
|  |  | if (strncmp(temp\_buffer, "limit=", 6) != 0 && strncmp(temp\_buffer, "start=", 6) != 0) { |
|  |  | if (strstr(link, "?")) |
|  |  | strcat(link, "&"); |
|  |  | else |
|  |  | strcat(link, "?"); |
|  |  | strcat(link, temp\_buffer); |
|  |  | } |
|  |  | strncpy(temp\_buffer, link, sizeof(temp\_buffer)); |
|  |  | if (temp\_request\_item->value != NULL) { |
|  |  | snprintf(link, sizeof(link) - 1, "%s%s%s=%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", url\_encode(temp\_request\_item->option), url\_encode(temp\_request\_item->value)); |
|  |  | } else { |
|  |  | snprintf(link, sizeof(link) - 1, "%s%s%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&amp;" : "?", url\_encode(temp\_request\_item->option)); |
|  |  | } |
|  |  | link[sizeof(link) - 1] = '\x0'; |
|  |  | } |
|  |  |  |
|  |  | /\* display drop down menu to select result limit \*/ |
| Expand Down | |  |

 Loading

Oops, something went wrong.
 Retry

Toggle all file notes
Toggle all file annotations

### 0 comments on commit `5c816f5`

Please
[sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FIcinga%2Ficinga-core%2Fcommit%2F5c816f5d9352c373e9dadb95b63612a96cf96df) to comment.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_7e35b601_20250126_080749.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FIcinga%2Ficinga-core%2Fissues%3Fq%3Dstate%253Aopen%2520label%253A%2522Classic%2520UI%2522)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

state:open label:"Classic UI"

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FIcinga%2Ficinga-core%2Fissues%3Fq%3Dstate%253Aopen%2520label%253A%2522Classic%2520UI%2522)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fissues%2Findex&source=header-repo&source_repo=Icinga%2Ficinga-core)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

This repository has been archived by the owner on Jan 15, 2019. It is now read-only.

[Icinga](/Icinga)
/
**[icinga-core](/Icinga/icinga-core)**
Public archive

* [Notifications](/login?return_to=%2FIcinga%2Ficinga-core) You must be signed in to change notification settings
* [Fork
  28](/login?return_to=%2FIcinga%2Ficinga-core)
* [Star
   44](/login?return_to=%2FIcinga%2Ficinga-core)

* [Code](/Icinga/icinga-core)
* [Issues
  2](/Icinga/icinga-core/issues)
* [Pull requests
  2](/Icinga/icinga-core/pulls)
* [Actions](/Icinga/icinga-core/actions)
* [Security](/Icinga/icinga-core/security)
* [Insights](/Icinga/icinga-core/pulse)

Additional navigation options

* [Code](/Icinga/icinga-core)
* [Issues](/Icinga/icinga-core/issues)
* [Pull requests](/Icinga/icinga-core/pulls)
* [Actions](/Icinga/icinga-core/actions)
* [Security](/Icinga/icinga-core/security)
* [Insights](/Icinga/icinga-core/pulse)

Preview
# Issues

Search Issuesstate:open label:"Classic UI"Search

[Labels](labels)[Milestones](milestones)
## Search results

OpenClosedAuthorLabelsProjectsMilestonesAssigneesTypesNewest

### No results

Try adjusting your search filters.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from www.suse.com_9f45cd46_20250126_080745.html ===

![](/assets/img/1px-transparent.gif)
![](/assets/img/1px-transparent.gif)

[![SUSE Logo](https://www.suse.com/assets/img/suse-white-logo-green.svg)
![SUSE Federal Logo](https://www.suse.com/assets/img/fed_logo.png)](https://www.suse.com)
Exit SUSE Federal  >

[Customer Center](https://scc.suse.com/home)

Account

Hello
[Update Your Account](https://www.suse.com/account/update/)
[Log Out](https://www.suse.com/saml2/logout/)

[Login](https://www.suse.com/saml2/login/)
[Create Account](https://www.suse.com/account/create/)
[Update Your Account](https://www.suse.com/account/update/)

English

Language
[Deutsch](https://www.suse.com/de-de/security/cve/CVE-2016-9566.html)
[English](https://www.suse.com/security/cve/CVE-2016-9566.html)
[EspaÃ±ol](https://www.suse.com/es-es/security/cve/CVE-2016-9566.html)
[FranÃ§ais](https://www.suse.com/fr-fr/security/cve/CVE-2016-9566.html)
[ä¸­æ(ç®ä½)](https://www.suse.com/zh-cn/security/cve/CVE-2016-9566.html)
[æ¥æ¬èª](https://www.suse.com/ja-jp/security/cve/CVE-2016-9566.html)
[íêµ­ì´](https://www.suse.com/ko-kr/security/cve/CVE-2016-9566.html)
[PortuguÃªs (Brasil)](https://www.suse.com/pt-br/security/cve/CVE-2016-9566.html)

[Shop](https://www.suse.com/shop/)

[View Cart](https://buy.suse.com/store?Action=DisplayPage&Env=BASE&SiteID=suse&id=ThreePgCheckoutShoppingCartPage)

[![SUSE Logo](https://www.suse.com/assets/img/suse-white-logo-green.svg)](https://www.suse.com)
Exit SUSE Federal  >

[Shop](https://www.suse.com/shop/)
[SUSECON 25](https://www.suse.com/susecon/)
[Customer](https://scc.suse.com/home)

Federal Solutions

Products

Solutions

Support

Partners

Communities

About

[Contact Us](https://www.suse.com/contact/)

[Free Downloads](https://www.suse.com/products/)

 Back

 Back
[![Icon](https://www.suse.com/assets/img/icons/Linux-one-color.svg)
Linux](https://www.suse.com/solutions/business-critical-linux/ "Linux")

* [SUSE Linux Enterprise Server](https://www.suse.com/products/server/)
* [SUSE Linux Enterprise Server

  for SAP Applications](https://www.suse.com/products/sles-for-sap/)
* [SUSE Linux Micro](https://www.suse.com/products/micro/)
* [SUSE Multi-Linux Support](https://www.suse.com/products/multi-linux-support/)
* [SUSE Multi-Linux Manager](https://www.suse.com/products/multi-linux-manager/)

[![Icon](https://www.suse.com/assets/img/icons/Cloud-native-one-color.svg)
Cloud Native](https://www.suse.com/solutions/enterprise-container-management/ "Cloud Native")

* [SUSE Rancher Prime](https://www.suse.com/products/rancher/)
* [Virtualization (Harvester)](https://www.suse.com/products/rancher/virtualization/)
* [Storage (Longhorn)](https://www.suse.com/products/rancher/storage/)
* [Security (NeuVector)](https://www.suse.com/products/rancher/security/)
* [Observability](https://www.suse.com/solutions/observability/)
* [SUSE Cloud Observability](https://www.suse.com/products/cloud/observability/)

[![Icon](https://www.suse.com/assets/img/icons/Edge-one-color.svg)
Edge](https://www.suse.com/solutions/edge-computing/ "Edge")

* [SUSE Edge](https://www.suse.com/products/edge/)
* [SUSE Edge for Telco](https://www.suse.com/products/edge-for-telco/)

[![Icon](https://www.suse.com/assets/img/icons/AI-one-color.svg)
AI](https://www.suse.com/solutions/edge-computing/ "AI")

* [SUSE AI](https://www.suse.com/products/ai/)

[All Products](https://www.suse.com/products/)

 Back
Foundational

* [![Linux](https://www.suse.com/assets/img/icons/Linux-one-color.svg)](https://www.suse.com/solutions/linux/)
* [![Cloud Native](https://www.suse.com/assets/img/icons/Cloud-native-one-color.svg)](https://www.suse.com/solutions/cloud-native/)
* [![Edge](https://www.suse.com/assets/img/icons/Edge-one-color.svg)](https://www.suse.com/solutions/edge/)
* [![AI](https://www.suse.com/assets/img/icons/AI-one-color.svg)](https://www.suse.com/solutions/ai/)

Solutions

* [Run SAP

  Run & secure cloud and on-prem workloads](https://www.suse.com/solutions/run-sap-solutions/)
* [Public Cloud

  Accelerate and innovate across your cloud environment](https://www.suse.com/solutions/public-cloud/)
* [Observability

  Rapid, full-stack visibility in under 5 minutes](https://www.suse.com/solutions/observability/)
* [Security

  Secure your digital enterprise](https://www.suse.com/solutions/security/)

Industries

* [Automotive](https://www.suse.com/sector/automotive/)
* [Telecom](https://www.suse.com/sector/telco/)
* [Banking and Financial Systems](https://www.suse.com/sector/banking-financial-services/)
* [Healthcare](https://www.suse.com/sector/healthcare/)
* [Manufacturing](https://www.suse.com/sector/manufacturing/)
* [Retail](https://www.suse.com/sector/retail/)
* [Technology & Software](https://www.suse.com/sector/technology/)
* [Federal](https://www.ranchergovernment.com/)
* [Pharma](https://www.suse.com/sector/pharma/)
* [Energy](https://www.suse.com/sector/energy/)

 Back
Support

* [Product Support

  SUSE Customer Center](https://scc.suse.com/home)
* [Premium Support Services

  Dedicated support services from a premium team](https://www.suse.com/services/premium/)
* [Long Term Services Support

  Stay on your existing product version](https://www.suse.com/products/long-term-service-pack-support/)
* [Renew Your Support Subscription

  Partners with cloud providers](https://www.suse.com/renewals/)
* [![AWS](https://www.suse.com/assets/img/icons/320px-Amazon3.svg)](https://aws.amazon.com/marketplace/search/results?searchTerms=suse)
* [![Microsoft Azure](https://www.suse.com/assets/img/icons/Microsoft_Azure3.svg)](https://azure.microsoft.com/solutions/linux-on-azure/suse/)
* [![Google](https://www.suse.com/assets/img/icons/lockup_GoogleCloud_FullColor_rgb_139x24px 1.svg)](https://console.cloud.google.com/marketplace/browse?q=SUSE)

Services

* [Consulting Services](https://www.suse.com/services/)
* [Training & Certification](https://www.suse.com/training/)
* [Premium Technical Advisory Services](https://www.suse.com/services/premium-technical-advisory/)

Resources

* [SUSE Support User Guide](https://www.suse.com/support/handbook/)
* [Patches & Updates](https://download.suse.com/patch/finder/)
* [Product Documentation](https://documentation.suse.com/)
* [Knowledgebase](https://www.suse.com/support/kb/)
* [Product Support Life Cycle](https://www.suse.com/lifecycle/)
* [Package Hub

  Community packages for SUSE Linux Enterprise Server](https://packagehub.suse.com/)
* [Driver Search](https://drivers.suse.com/)
* [Support Forums](https://forums.suse.com/forum.php)
* [Developer Services](https://www.suse.com/services/support-offerings/developer-services/)
* [Beta Program](https://www.suse.com/betaprogram/)
* [Security](https://www.suse.com/support/security/)

 Back
Partners

* [Partner Program](https://www.suse.com/partners/)
* [Find a Partner](https://www.suse.com/partners/find-partner/)
* [Become a Partner](https://www.suse.com/partners/become-partner/)
* [Login to the SUSE Partner Portal](https://partner.suse.com/)

 Back
Communities

* [Blog](https://www.suse.com/c/blog/)
* [Forum](https://forums.suse.com/forum.php)
* [Open Source Projects](http://opensource.suse.com/)
* [openSUSE.org](https://www.opensuse.org/)

 Back
About

* [About](https://www.suse.com/company/about/)
* [Leadership](https://www.suse.com/leadership/)
* [Careers](https://jobs.suse.com/)
* [Newsroom](https://www.suse.com/news/)
* [Success Stories](https://www.suse.com/success/)
* [Investor Relations](https://ir.suse.com/)
* [Social Impact](https://www.suse.com/esg/)
* [SUSE Logo and Brand](https://brand.suse.com/)
* [Events](https://www.suse.com/events/)
* [Merchandise Store](https://www.susemerchandise.com/)

# CVE-2016-9566

## Common Vulnerabilities and Exposures

[[Previous]](CVE-2016-9565.html) [[Index]](index.html) [[Next]](CVE-2016-9572.html)

### Upstream information

[CVE-2016-9566 at MITRE](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-9566)

#### Description

base/logging.c in Nagios Core before 4.2.4 allows local users with access to an account in the nagios group to gain root privileges via a symlink attack on the log file. NOTE: this can be leveraged by remote attackers using CVE-2016-9565.

---

### [SUSE information](https://www.suse.com/c/cve-pages-self-help-security-issues-suse-linux-enterprise/)

Overall state of this security issue: Resolved

This issue is currently rated as having [important](https://www.suse.com/support/security/rating/) severity.

[CVSS v2 Scores](https://nvd.nist.gov/cvss.cfm)
|  | National Vulnerability Database | SUSE |
| Base Score | 7.2 | 6.6 |
| Vector | AV:L/AC:L/Au:N/C:C/I:C/A:C | AV:L/AC:M/Au:S/C:C/I:C/A:C |
| Access Vector | Local | Local |
| Access Complexity | Low | Medium |
| Authentication | None | Single |
| Confidentiality Impact | Complete | Complete |
| Integrity Impact | Complete | Complete |
| Availability Impact | Complete | Complete |

[CVSS v3 Scores](https://nvd.nist.gov/cvss.cfm)
|  | National Vulnerability Database | SUSE |
| Base Score | 7.8 | 7.3 |
| Vector | CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H | CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H |
| Attack Vector | Local | Local |
| Attack Complexity | Low | Low |
| Privileges Required | Low | Low |
| User Interaction | None | Required |
| Scope | Unchanged | Unchanged |
| Confidentiality Impact | High | High |
| Integrity Impact | High | High |
| Availability Impact | High | High |
| CVSSv3 Version | 3 | 3 |

SUSE Bugzilla entry: [1014637](https://bugzilla.suse.com/show_bug.cgi?id=1014637) [RESOLVED / FIXED]
### SUSE Security Advisories:

* [SUSE-SU-2022:3576-1](https://lists.suse.com/pipermail/sle-security-updates/2022-October/012534.html), published Thu Oct 13 13:20:04 UTC 2022
* [SUSE-SU-2024:1629-1](https://lists.suse.com/pipermail/sle-updates/2024-May/035252.html), published Tue May 14 08:30:07 UTC 2024
* [openSUSE-SU-2017:0146-1](https://lists.opensuse.org/archives/list/security-announce%40lists.opensuse.org/thread/3Q6N4F4EAYSJ6FNMJTKIZZZLPGW4MV2P/#3Q6N4F4EAYSJ6FNMJTKIZZZLPGW4MV2P), published Fri Dec 8 15:48:36 2023

### List of released packages

| Product(s) | Fixed package version(s) | References |
| --- | --- | --- |
| Image SLES12-SP5-Azure-BYOS Image SLES12-SP5-Azure-HPC-BYOS Image SLES12-SP5-Azure-SAP-BYOS Image SLES12-SP5-EC2-BYOS Image SLES12-SP5-EC2-SAP-BYOS Image SLES12-SP5-GCE-BYOS Image SLES12-SP5-GCE-SAP-BYOS | * `libzmq3 >= 4.0.4-15.8.1` |  |
| Image SLES12-SP5-Azure-Basic-On-Demand Image SLES12-SP5-Azure-Standard-On-Demand Image SLES12-SP5-EC2-ECS-On-Demand Image SLES12-SP5-EC2-On-Demand Image SLES12-SP5-GCE-On-Demand | * `sysuser-shadow >= 2.0-1.9.1` |  |
| SUSE Linux Enterprise High Performance Computing 12 SUSE Linux Enterprise Server 12 SUSE Linux Enterprise Server 12 SP3 SUSE Linux Enterprise Server 12 SP4 SUSE Linux Enterprise Server for SAP Applications 12 SUSE Linux Enterprise Server for SAP Applications 12 SP3 SUSE Linux Enterprise Server for SAP Applications 12 SP4 | * `libzmq3 >= 4.0.4-15.8.1` * `sysuser-shadow >= 2.0-1.9.1` | Patchnames: SUSE-SLE-Module-Adv-Systems-Management-12-2024-1629SUSE-SLE-Module-Containers-12-2024-1629 |
| SUSE Linux Enterprise Module for Advanced Systems Management 12 | * `libzmq3 >= 4.0.4-15.8.1` | Patchnames: SUSE-SLE-Module-Adv-Systems-Management-12-2024-1629 |
| SUSE Linux Enterprise Module for Containers 12 | * `sysuser-shadow >= 2.0-1.9.1` | Patchnames: SUSE-SLE-Module-Containers-12-2024-1629 |
| SUSE Linux Enterprise Server 12 SP5 | * `libzmq3 >= 4.0.4-15.8.1` * `sysuser-shadow >= 2.0-1.9.1` * `sysuser-tools >= 2.0-1.9.1` * `zeromq-devel >= 4.0.4-15.8.1` | Patchnames: SUSE-SLE-Module-Adv-Systems-Management-12-2024-1629SUSE-SLE-Module-Containers-12-2024-1629SUSE-SLE-SDK-12-SP5-2024-1629SUSE-SLE-SERVER-12-SP5-2024-1629SUSE-SLE-WE-12-SP5-2024-1629 |
| SUSE Linux Enterprise Server for SAP Applications 12 SP5 | * `grafana-ha-cluster-dashboards >= 1.1.0+git.1605027022.a84d536-1.10.1` * `grafana-sap-netweaver-dashboards >= 1.0.3+git.1601889366.9f71957-1.10.1` * `grafana-sap-providers >= 1.1-1.7.1` * `grafana-sleha-provider >= 1.1.0+git.1605027022.a84d536-1.10.1` * `libzmq3 >= 4.0.4-15.8.1` * `sysuser-shadow >= 2.0-1.9.1` * `sysuser-tools >= 2.0-1.9.1` * `zeromq-devel >= 4.0.4-15.8.1` | Patchnames: SUSE-SLE-Module-Adv-Systems-Management-12-2024-1629SUSE-SLE-Module-Containers-12-2024-1629SUSE-SLE-SAP-12-SP5-2024-1629SUSE-SLE-SDK-12-SP5-2024-1629SUSE-SLE-SERVER-12-SP5-2024-1629SUSE-SLE-WE-12-SP5-2024-1629 |
| SUSE Linux Enterprise Software Development Kit 12 SP5 | * `libzmq3 >= 4.0.4-15.8.1` * `zeromq-devel >= 4.0.4-15.8.1` | Patchnames: SUSE-SLE-SDK-12-SP5-2024-1629 |
| SUSE Linux Enterprise Workstation Extension 12 SP5 | * `libzmq3 >= 4.0.4-15.8.1` | Patchnames: SUSE-SLE-WE-12-SP5-2024-1629 |
| SUSE Manager Client Tools 12-BETA | * `grafana-ha-cluster-dashboards >= 1.1.0+git.1605027022.a84d536-1.10.1` * `grafana-sap-netweaver-dashboards >= 1.0.3+git.1601889366.9f71957-1.10.1` * `grafana-sap-providers >= 1.1-1.7.1` * `grafana-sleha-provider >= 1.1.0+git.1605027022.a84d536-1.10.1` * `icinga >= 1.13.3-12.8.1` * `icinga-devel >= 1.13.3-12.8.1` * `icinga-doc >= 1.13.3-12.8.1` * `icinga-idoutils >= 1.13.3-12.8.1` * `icinga-idoutils-mysql >= 1.13.3-12.8.1` * `icinga-idoutils-oracle >= 1.13.3-12.8.1` * `icinga-idoutils-pgsql >= 1.13.3-12.8.1` * `icinga-plugins-downtimes >= 1.13.3-12.8.1` * `icinga-plugins-eventhandlers >= 1.13.3-12.8.1` * `icinga-www >= 1.13.3-12.8.1` * `icinga-www-config >= 1.13.3-12.8.1` * `libzmq3 >= 4.0.4-15.8.1` * `monitoring-tools >= 1.13.3-12.8.1` * `sysuser-shadow >= 2.0-1.9.1` | Patchnames: SUSE-SLE-Manager-Tools-12-BETA-2024-1629 |
| SUSE Manager Client Tools 12 | * `grafana-ha-cluster-dashboards >= 1.1.0+git.1605027022.a84d536-1.10.1` * `grafana-sap-netweaver-dashboards >= 1.0.3+git.1601889366.9f71957-1.10.1` * `grafana-sap-providers >= 1.1-1.7.1` * `grafana-sleha-provider >= 1.1.0+git.1605027022.a84d536-1.10.1` * `hwdata >= 0.314-10.14.1` * `icinga >= 1.13.3-12.8.1` * `icinga-devel >= 1.13.3-12.8.1` * `icinga-doc >= 1.13.3-12.8.1` * `icinga-idoutils >= 1.13.3-12.8.1` * `icinga-idoutils-mysql >= 1.13.3-12.8.1` * `icinga-idoutils-oracle >= 1.13.3-12.8.1` * `icinga-idoutils-pgsql >= 1.13.3-12.8.1` * `icinga-plugins-downtimes >= 1.13.3-12.8.1` * `icinga-plugins-eventhandlers >= 1.13.3-12.8.1` * `icinga-www >= 1.13.3-12.8.1` * `icinga-www-config >= 1.13.3-12.8.1` * `libzmq3 >= 4.0.4-15.8.1` * `monitoring-tools >= 1.13.3-12.8.1` * `sysuser-shadow >= 2.0-1.9.1` | Patchnames: SUSE-SLE-Manager-Tools-12-2022-3576SUSE-SLE-Manager-Tools-12-2024-1629 |
| SUSE Package Hub 15 SP1 | * `nagios >= 4.4.6-bp151.4.6.1` * `nagios-contrib >= 4.4.6-bp151.4.6.1` * `nagios-devel >= 4.4.6-bp151.4.6.1` * `nagios-theme-exfoliation >= 4.4.6-bp151.4.6.1` * `nagios-www >= 4.4.6-bp151.4.6.1` * `nagios-www-dch >= 4.4.6-bp151.4.6.1` | Patchnames: openSUSE-2021-786 |
| openSUSE Tumbleweed | * `nagios >= 4.4.6-2.5` * `nagios-contrib >= 4.4.6-2.5` * `nagios-devel >= 4.4.6-2.5` * `nagios-theme-exfoliation >= 4.4.6-2.5` * `nagios-www >= 4.4.6-2.5` * `nagios-www-dch >= 4.4.6-2.5` | Patchnames: openSUSE-Tumbleweed-2024-11073 |

---

### Status of this issue by product and package

Please note that this evaluation state might be work in progress, incomplete or outdated. Also information for service packs in the LTSS phase is only included for issues meeting the LTSS criteria. If in doubt, feel free to contact us for clarification. The updates are grouped by state of their lifecycle. SUSE product lifecycles are documented [on the lifecycle page](https://www.suse.com/lifecycle/).

| Product(s) | Source package | State |
| --- | --- | --- |
| Products under general support and receiving all security fixes. | | |
| SUSE Linux Enterprise High Performance Computing 12 | sysuser-tools | Released |
| SUSE Linux Enterprise High Performance Computing 12 | zeromq | Released |
| SUSE Manager Client Tools 12 | grafana-ha-cluster-dashboards | Released |
| SUSE Manager Client Tools 12 | grafana-sap-netweaver-dashboards | Released |
| SUSE Manager Client Tools 12 | grafana-sap-providers | Released |
| SUSE Manager Client Tools 12 | hwdata | Released |
| SUSE Manager Client Tools 12 | icinga | Released |
| SUSE Manager Client Tools 12 | sysuser-tools | Released |
| SUSE Manager Client Tools 12 | zeromq | Released |
| SUSE Manager Client Tools 12-BETA | grafana-ha-cluster-dashboards | Released |
| SUSE Manager Client Tools 12-BETA | grafana-sap-netweaver-dashboards | Released |
| SUSE Manager Client Tools 12-BETA | grafana-sap-providers | Released |
| SUSE Manager Client Tools 12-BETA | icinga | Released |
| SUSE Manager Client Tools 12-BETA | sysuser-tools | Released |
| SUSE Manager Client Tools 12-BETA | zeromq | Released |
| SUSE Manager Client Tools for SLE 12 | icinga | Released |
| Products under Long Term Service Pack support and receiving important and critical security fixes. | | |
| SUSE Linux Enterprise Server 12 SP5 | sysuser-tools | Released |
| SUSE Linux Enterprise Server 12 SP5 | zeromq | Released |
| SUSE Linux Enterprise Server for SAP Applications 12 SP5 | grafana-ha-cluster-dashboards | Released |
| SUSE Linux Enterprise Server for SAP Applications 12 SP5 | grafana-sap-netweaver-dashboards | Released |
| SUSE Linux Enterprise Server for SAP Applications 12 SP5 | grafana-sap-providers | Released |
| SUSE Linux Enterprise Server for SAP Applications 12 SP5 | sysuser-tools | Released |
| SUSE Linux Enterprise Server for SAP Applications 12 SP5 | zeromq | Released |
| Products past their end of life and not receiving proactive updates anymore. | | |
| SUSE Enterprise Storage 4 | icinga | Unsupported |
| SUSE Linux Enterprise Desktop 11 SP2 | nagios | Affected |
| SUSE Linux Enterprise Desktop 11 SP3 | nagios | Affected |
| SUSE Linux Enterprise Desktop 11 SP4 | nagios | Affected |
| SUSE Linux Enterprise Module for Advanced Systems Management 12 | zeromq | Released |
| SUSE Linux Enterprise Module for Containers 12 | sysuser-tools | Released |
| SUSE Linux Enterprise Point of Sale 11 SP3 | nagios | Affected |
| SUSE Linux Enterprise Server 11 SP1 | nagios | Unsupported |
| SUSE Linux Enterprise Server 11 SP1-LTSS | nagios | Affected |
| SUSE Linux Enterprise Server 11 SP2 | nagios | Affected |
| SUSE Linux Enterprise Server 11 SP2-LTSS | nagios | Affected |
| SUSE Linux Enterprise Server 11 SP3 | nagios | Unsupported |
| SUSE Linux Enterprise Server 11 SP3-LTSS | nagios | Affected |
| SUSE Linux Enterprise Server 11 SP4 | nagios | Affected |
| SUSE Linux Enterprise Server 11 SP4-LTSS | nagios | Unsupported |
| SUSE Linux Enterprise Server 12 | sysuser-tools | Released |
| SUSE Linux Enterprise Server 12 | zeromq | Released |
| SUSE Linux Enterprise Server 12 SP3 | sysuser-tools | Released |
| SUSE Linux Enterprise Server 12 SP3 | zeromq | Released |
| SUSE Linux Enterprise Server 12 SP4 | sysuser-tools | Released |
| SUSE Linux Enterprise Server 12 SP4 | zeromq | Released |
| SUSE Linux Enterprise Server for SAP Applications 11 SP2 | nagios | Affected |
| SUSE Linux Enterprise Server for SAP Applications 11 SP3 | nagios | Affected |
| SUSE Linux Enterprise Server for SAP Applications 11 SP4 | nagios | Affected |
| SUSE Linux Enterprise Server for SAP Applications 12 | sysuser-tools | Released |
| SUSE Linux Enterprise Server for SAP Applications 12 | zeromq | Released |
| SUSE Linux Enterprise Server for SAP Applications 12 SP3 | sysuser-tools | Released |
| SUSE Linux Enterprise Server for SAP Applications 12 SP3 | zeromq | Released |
| SUSE Linux Enterprise Server for SAP Applications 12 SP4 | sysuser-tools | Released |
| SUSE Linux Enterprise Server for SAP Applications 12 SP4 | zeromq | Released |
| SUSE Linux Enterprise Software Bootstrap Kit 12 | nagios | Unsupported |
| SUSE Linux Enterprise Software Development Kit 11 SP2 | nagios | Affected |
| SUSE Linux Enterprise Software Development Kit 11 SP3 | nagios | Affected |
| SUSE Linux Enterprise Software Development Kit 11 SP4 | nagios | Affected |
| SUSE Linux Enterprise Software Development Kit 12 SP5 | zeromq | Released |
| SUSE Linux Enterprise Workstation Extension 12 SP5 | zeromq | Released |
| SUSE Package Hub 15 SP1 | nagios | Released |

---

### SUSE Timeline for this CVE

CVE page created: Thu Dec 8 16:15:15 2016

CVE page last modified: Fri Nov 15 16:09:50 2024

![SUSE Logo](https://www.suse.com/assets/img/suse-white-logo-green.svg)

* [Careers](https://jobs.suse.com/ "Careers")
* [Legal](https://www.suse.com/company/legal/ "Legal")
* [Anti-Slavery Statement](https://links.imagerelay.com/cdn/3404/ql/811b4f2364b94ff18eb15e315b3e263d/suse_anti_slavery_statement.pdf "Anti-Slavery Statement")
* [Anti-slavery](https://www.suse.com/legal/anti-slavery/ "Anti-slavery")
* [About](https://www.suse.com/company/about/ "About")
* [Communications Preferences](https://www.suse.com/company/subscribe/ "Communications Preferences")
* [Contact Us](https://www.suse.com/contact/ "Contact Us")
* [Let's Chat](#footer-chat-now "Let's Chat")

* [![](https://www.suse.com/assets/img/youtube.png)](https://www.youtube.com/channel/UCHTfqIzPKz4f_dri36lAQGA%20)
* [![](https://www.suse.com/assets/img/fn-fbook-ico-white.png)](https://www.facebook.com/SUSEWorldwide)
* [![](https://www.suse.com/assets/img/logo-black.png)](https://www.twitter.com/SUSE)
* [![](https://www.suse.com/assets/img/fn-link-ico-white.png)](https://www.linkedin.com/company/suse)
* ![WeChat](https://www.suse.com/assets/img/icons/WeChat.png)

![WeChat QR](https://www.suse.com/assets/img/icons/qrcode_for_gh_91d12717ed53_430.jpg)

Support: [Open a Support Case](https://www.suse.com/support/handbook/#open)

©  ©SUSE, All Rights Reserved

Cookie Settings

[Privacy Policy](https://www.suse.com/company/legal/) and
[Cookie Policy](https://www.suse.com/company/legal/cookies-policy/)

X

×



=== Content from dev.icinga.com_4c7fe4aa_20250126_080756.html ===
From 7c1dcebcc688f591a5708ef6062ddeaa9fb905b0 Mon Sep 17 00:00:00 2001
From: Ricardo Bartels
Date: Fri, 30 Oct 2015 21:48:22 +0100
Subject: [PATCH] Classic-UI: fixes a XXS vulnerability in pagination and
export links #10453
Sorry guys. Due to my bad programming skills I introduced a
XSS vulnerability in Classic-UI with the CSV export link and
pagination feature. The functions parsed QUERY\_STRING from
the environment without properly sanitizing it.
The getcgivars() function got a bit reworked. Once the
QUERY\_STRING is read and parsed the content survives the
whole lifetime of the cgi execution and gets free'd at
the end. This way we can always build urls from valid parsed
cgi params.
I wonder why I haven't done this earlier.
Also the url param parsing in every cgi was updated and
hopefully everything works as bevor.
Refs: #10453
fixes: #CVE-2015-8010
---
cgi/avail.c | 323 ++++++++++++++++++++-----------------------------
cgi/cgiutils.c | 196 ++++++++++++++----------------
cgi/cmd.c | 342 ++++++++++++++++++++++++----------------------------
cgi/config.c | 126 ++++++++-----------
cgi/extinfo.c | 153 +++++++++++------------
cgi/getcgi.c | 138 ++++++++++-----------
cgi/histogram.c | 279 ++++++++++++++++++------------------------
cgi/history.c | 171 +++++++++++++-------------
cgi/notifications.c | 188 ++++++++++++-----------------
cgi/outages.c | 70 ++++++-----
cgi/showlog.c | 231 +++++++++++++++--------------------
cgi/status.c | 254 ++++++++++++++++++--------------------
cgi/statusmap.c | 199 +++++++++++++++---------------
cgi/summary.c | 262 ++++++++++++++++------------------------
cgi/tac.c | 81 ++++++-------
cgi/trends.c | 311 +++++++++++++++++++++--------------------------
include/getcgi.h | 17 ++-
17 files changed, 1497 insertions(+), 1844 deletions(-)
diff --git a/cgi/avail.c b/cgi/avail.c
index fafb9ea..068cabc 100644
--- a/cgi/avail.c
+++ b/cgi/avail.c
@@ -230,7 +230,7 @@ void free\_archived\_state\_list(archived\_state \*);
void read\_archived\_state\_data(void);
unsigned long calculate\_total\_time(time\_t, time\_t);
-int process\_cgivars(void);
+void process\_cgivars(void);
int backtrack\_archives = 2;
int earliest\_archive = 0;
@@ -245,6 +245,8 @@ extern char \*csv\_data\_enclosure;
timeperiod \*current\_timeperiod = NULL;
+html\_request \*html\_request\_list = NULL; /\*\*< contains html requested data \*/
+
int CGI\_ID = AVAIL\_CGI\_ID;
int main(int argc, char \*\*argv) {
@@ -1095,43 +1097,28 @@ int main(int argc, char \*\*argv) {
document\_footer(CGI\_ID);
/\* free all other allocated memory \*/
+ free\_html\_request(html\_request\_list);
free\_memory();
return OK;
}
-int process\_cgivars(void) {
- char \*\*variables;
+void process\_cgivars(void) {
char \*temp\_buffer = NULL;
char \*key = NULL;
char \*value = NULL;
- int error = FALSE;
- int x;
+ timeperiod \*temp\_timeperiod = NULL;
+ html\_request \*temp\_request\_item = NULL;
- variables = getcgivars();
+ html\_request\_list = getcgivars();
- for (x = 0; variables[x] != NULL; x+=2) {
- key = variables[x];
- value = variables[x+1];
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
- /\* do some basic length checking on the variable key to prevent buffer overflows \*/
- if (strlen(key) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
- /\* likewise, check the value if present \*/
- if (value != NULL)
- if (strlen(value) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
+ key = temp\_request\_item->option;
+ value = temp\_request\_item->value;
/\* we found the hostgroup argument \*/
- if (!strcmp(key, "hostgroup")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ if (!strcmp(key, "hostgroup") && value != NULL) {
if ((hostgroup\_name = (char \*)strdup(value)) == NULL)
hostgroup\_name = "";
@@ -1139,14 +1126,12 @@ int process\_cgivars(void) {
display\_type = DISPLAY\_HOSTGROUP\_AVAIL;
show\_all\_hostgroups = (strcmp(hostgroup\_name, "all")) ? FALSE : TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the servicegroup argument \*/
- else if (!strcmp(key, "servicegroup")) {
- if (variables[x] == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "servicegroup") && value != NULL) {
if ((servicegroup\_name = (char \*)strdup(value)) == NULL)
servicegroup\_name = "";
@@ -1154,14 +1139,12 @@ int process\_cgivars(void) {
display\_type = DISPLAY\_SERVICEGROUP\_AVAIL;
show\_all\_servicegroups = (strcmp(servicegroup\_name, "all")) ? FALSE : TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the host argument \*/
- else if (!strcmp(key, "host")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "host") && value != NULL) {
if ((host\_name = (char \*)strdup(value)) == NULL)
host\_name = "";
@@ -1171,14 +1154,12 @@ int process\_cgivars(void) {
if (strlen(service\_desc) == 0)
display\_type = DISPLAY\_HOST\_AVAIL;
show\_all\_hosts = (strcmp(host\_name, "all")) ? FALSE : TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the service description argument \*/
- else if (!strcmp(key, "service")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "service") && value != NULL) {
if ((service\_desc = (char \*)strdup(value)) == NULL)
service\_desc = "";
@@ -1186,14 +1167,12 @@ int process\_cgivars(void) {
display\_type = DISPLAY\_SERVICE\_AVAIL;
show\_all\_services = (strcmp(service\_desc, "all")) ? FALSE : TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found a combined host/service \*/
- else if (!strcmp(key, "hostservice")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "hostservice") && value != NULL) {
temp\_buffer = strtok(value, "^");
@@ -1211,110 +1190,90 @@ int process\_cgivars(void) {
display\_type = DISPLAY\_SERVICE\_AVAIL;
show\_all\_services = (strcmp(service\_desc, "all")) ? FALSE : TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found first time argument \*/
- else if (!strcmp(key, "t1")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "t1") && value != NULL) {
t1 = (time\_t)strtoul(value, NULL, 10);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found first time argument \*/
- else if (!strcmp(key, "t2")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "t2") && value != NULL) {
t2 = (time\_t)strtoul(value, NULL, 10);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the assume initial states option \*/
- else if (!strcmp(key, "assumeinitialstates")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "assumeinitialstates") && value != NULL) {
if (!strcmp(value, "yes"))
assume\_initial\_states = TRUE;
else
assume\_initial\_states = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the assume state during program not running option \*/
- else if (!strcmp(key, "assumestatesduringnotrunning")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "assumestatesduringnotrunning") && value != NULL) {
if (!strcmp(value, "yes"))
assume\_states\_during\_notrunning = TRUE;
else
assume\_states\_during\_notrunning = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the initial assumed host state option \*/
- else if (!strcmp(key, "initialassumedhoststate")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "initialassumedhoststate") && value != NULL) {
initial\_assumed\_host\_state = atoi(value);
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the initial assumed service state option \*/
- else if (!strcmp(key, "initialassumedservicestate")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "initialassumedservicestate") && value != NULL) {
initial\_assumed\_service\_state = atoi(value);
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the assume state retention option \*/
- else if (!strcmp(key, "assumestateretention")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "assumestateretention") && value != NULL) {
if (!strcmp(value, "yes"))
assume\_state\_retention = TRUE;
else
assume\_state\_retention = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the include soft states option \*/
- else if (!strcmp(key, "includesoftstates")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "includesoftstates") && value != NULL) {
if (!strcmp(value, "yes"))
include\_soft\_states = TRUE;
else
include\_soft\_states = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the backtrack archives argument \*/
- else if (!strcmp(key, "backtrack")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "backtrack") && value != NULL) {
backtrack\_archives = atoi(value);
if (backtrack\_archives < 0)
@@ -1322,17 +1281,11 @@ int process\_cgivars(void) {
if (backtrack\_archives > MAX\_ARCHIVE\_BACKTRACKS)
backtrack\_archives = MAX\_ARCHIVE\_BACKTRACKS;
-#ifdef DEBUG
- printf("BACKTRACK ARCHIVES: %d\n", backtrack\_archives);
-#endif
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the standard timeperiod argument \*/
- else if (!strcmp(key, "timeperiod")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "timeperiod") && value != NULL) {
if (!strcmp(value, "today"))
timeperiod\_type = TIMEPERIOD\_TODAY;
@@ -1367,40 +1320,50 @@ int process\_cgivars(void) {
convert\_timeperiod\_to\_times(timeperiod\_type, &t1, &t2);
compute\_time\_from\_parts = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the embed option \*/
- else if (!strcmp(key, "embedded"))
+ else if (!strcmp(key, "embedded")) {
embedded = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the noheader option \*/
- else if (!strcmp(key, "noheader"))
+ else if (!strcmp(key, "noheader")) {
display\_header = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the CSV output option \*/
else if (!strcmp(key, "csvoutput")) {
display\_header = FALSE;
content\_type = CSV\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the JSON output option \*/
else if (!strcmp(key, "jsonoutput")) {
display\_header = FALSE;
content\_type = JSON\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the XML output option \*/
else if (!strcmp(key, "xmloutput")) {
display\_header = FALSE;
content\_type = XML\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the content type argument \*/
- else if (!strcmp(key, "content\_type")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "content\_type") && value != NULL) {
if (!strcmp(value, "xml"))
content\_type = XML\_CONTENT;
@@ -1415,26 +1378,34 @@ int process\_cgivars(void) {
if (content\_type != HTML\_CONTENT)
display\_header = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the log entries option \*/
- else if (!strcmp(key, "show\_log\_entries"))
+ else if (!strcmp(key, "show\_log\_entries")) {
show\_log\_entries = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the full log entries option \*/
- else if (!strcmp(key, "full\_log\_entries"))
+ else if (!strcmp(key, "full\_log\_entries")) {
full\_log\_entries = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the get date parts option \*/
- else if (!strcmp(key, "get\_date\_parts"))
+ else if (!strcmp(key, "get\_date\_parts")) {
get\_date\_parts = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the report type selection option \*/
- else if (!strcmp(key, "report\_type")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "report\_type") && value != NULL) {
+
if (!strcmp(value, "hostgroups"))
select\_hostgroups = TRUE;
else if (!strcmp(value, "servicegroups"))
@@ -1443,14 +1414,12 @@ int process\_cgivars(void) {
select\_hosts = TRUE;
else
select\_services = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "smon")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "smon") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1458,14 +1427,12 @@ int process\_cgivars(void) {
start\_month = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "sday")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "sday") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1473,14 +1440,12 @@ int process\_cgivars(void) {
start\_day = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "syear")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "syear") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1488,14 +1453,12 @@ int process\_cgivars(void) {
start\_year = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "smin")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "smin") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1503,14 +1466,12 @@ int process\_cgivars(void) {
start\_minute = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "ssec")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "ssec") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1518,14 +1479,12 @@ int process\_cgivars(void) {
start\_second = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "shour")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "shour") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1533,15 +1492,13 @@ int process\_cgivars(void) {
start\_hour = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "emon")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "emon") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1549,14 +1506,12 @@ int process\_cgivars(void) {
end\_month = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "eday")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "eday") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1564,14 +1519,12 @@ int process\_cgivars(void) {
end\_day = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "eyear")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "eyear") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1579,14 +1532,12 @@ int process\_cgivars(void) {
end\_year = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "emin")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "emin") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1594,14 +1545,12 @@ int process\_cgivars(void) {
end\_minute = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "esec")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "esec") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1609,14 +1558,12 @@ int process\_cgivars(void) {
end\_second = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "ehour")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "ehour") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1624,28 +1571,23 @@ int process\_cgivars(void) {
end\_hour = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the show scheduled downtime option \*/
- else if (!strcmp(key, "showscheduleddowntime")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "showscheduleddowntime") && value != NULL) {
if (!strcmp(value, "yes"))
show\_scheduled\_downtime = TRUE;
else
show\_scheduled\_downtime = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the report timeperiod option \*/
- else if (!strcmp(key, "rpttimeperiod")) {
- timeperiod \*temp\_timeperiod;
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "rpttimeperiod") && value != NULL) {
for (temp\_timeperiod = timeperiod\_list; temp\_timeperiod != NULL; temp\_timeperiod = temp\_timeperiod->next) {
if (!strcmp(url\_encode(temp\_timeperiod->name), value)) {
@@ -1653,18 +1595,19 @@ int process\_cgivars(void) {
break;
}
}
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the nodaemoncheck option \*/
- else if (!strcmp(key, "nodaemoncheck"))
+ else if (!strcmp(key, "nodaemoncheck") && value != NULL) {
daemon\_check = FALSE;
-
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
}
- /\* free memory allocated to the CGI variables \*/
- free\_cgivars(variables);
-
- return error;
+ return;
}
diff --git a/cgi/cgiutils.c b/cgi/cgiutils.c
index d4f7ecd..5d93e75 100644
--- a/cgi/cgiutils.c
+++ b/cgi/cgiutils.c
@@ -31,6 +31,7 @@
#include "../include/comments.h"
#include "../include/cgiutils.h"
+#include "../include/getcgi.h"
char main\_config\_file[MAX\_FILENAME\_LENGTH];
char command\_file[MAX\_FILENAME\_LENGTH];
@@ -206,6 +207,7 @@ extern serviceescalation \*serviceescalation\_list;
extern hoststatus \*hoststatus\_list;
extern servicestatus \*servicestatus\_list;
+extern html\_request \*html\_request\_list;
char encoded\_url\_string[4][MAX\_INPUT\_BUFFER]; // 4 to be able to use url\_encode 4 times
@@ -2219,54 +2221,50 @@ void display\_info\_table(char \*title, authdata \*current\_authdata, int daemon\_chec
}
void display\_nav\_table(time\_t ts\_start, time\_t ts\_end) {
- char \*temp\_buffer;
+ char temp\_buffer[MAX\_INPUT\_BUFFER] = "";
char url[MAX\_INPUT\_BUFFER] = "";
- char stripped\_query\_string[MAX\_INPUT\_BUFFER] = "";
char date\_time[MAX\_INPUT\_BUFFER];
struct tm \*t;
time\_t ts\_midnight = 0L;
time\_t current\_time = 0L;
+ html\_request \*temp\_request\_item = NULL;
/\* define base url \*/
switch (CGI\_ID) {
case HISTORY\_CGI\_ID:
- strcat(url, HISTORY\_CGI);
+ strncpy(url, HISTORY\_CGI, sizeof(url));
break;
case NOTIFICATIONS\_CGI\_ID:
- strcat(url, NOTIFICATIONS\_CGI);
+ strncpy(url, NOTIFICATIONS\_CGI, sizeof(url));
break;
case SHOWLOG\_CGI\_ID:
- strcat(url, SHOWLOG\_CGI);
+ strncpy(url, SHOWLOG\_CGI, sizeof(url));
break;
default:
- strcat(url, "NO\_URL\_DEFINED");
+ strncpy(url, "NO\_URL\_DEFINED", sizeof(url));
break;
}
- /\* get url options but filter out "ts\_end", "ts\_start" and "start" \*/
- if (getenv("QUERY\_STRING") != NULL && strcmp(getenv("QUERY\_STRING"), "")) {
- if(strlen(getenv("QUERY\_STRING")) > MAX\_INPUT\_BUFFER - 1) {
- write\_to\_cgi\_log("display\_nav\_table(): Query string exceeds max length. Returning without displaying nav table.\n");
- return;
+ url[sizeof(url) - 1] = '\x0';
+
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
+
+ if (temp\_request\_item->is\_valid == FALSE || temp\_request\_item->option == NULL) {
+ continue;
}
- strcpy(stripped\_query\_string, getenv("QUERY\_STRING"));
- strip\_html\_brackets(stripped\_query\_string);
- /\* check if concatenated strings exceed MAX\_INPUT\_BUFFER \*/
- if (strlen(url) + strlen(stripped\_query\_string) + 1 > MAX\_INPUT\_BUFFER - 1) {
- write\_to\_cgi\_log("display\_nav\_table(): Full query string exceeds max length. Returning without displaying nav table.\n");
- return;
+ /\* filter out "limit" and "start" \*/
+ if (!strcmp(temp\_request\_item->option, "ts\_start") || !strcmp(temp\_request\_item->option, "ts\_end") || !strcmp(temp\_request\_item->option, "start")) {
+ continue;
}
- for (temp\_buffer = my\_strtok(stripped\_query\_string, "&"); temp\_buffer != NULL; temp\_buffer = my\_strtok(NULL, "&")) {
- if (strncmp(temp\_buffer, "ts\_start=", 9) != 0 && strncmp(temp\_buffer, "ts\_end=", 6) != 0 && strncmp(temp\_buffer, "start=", 6) != 0) {
- if (strstr(url, "?"))
- strcat(url, "&");
- else
- strcat(url, "?");
- strcat(url, temp\_buffer);
- }
+ strncpy(temp\_buffer, url, sizeof(temp\_buffer));
+ if (temp\_request\_item->value != NULL) {
+ snprintf(url, sizeof(url) - 1, "%s%s%s=%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&" : "?", url\_encode(temp\_request\_item->option), url\_encode(temp\_request\_item->value));
+ } else {
+ snprintf(url, sizeof(url) - 1, "%s%s%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&" : "?", url\_encode(temp\_request\_item->option));
}
+ url[sizeof(url) - 1] = '\x0';
}
/\* get the current time \*/
@@ -2861,49 +2859,45 @@ void print\_generic\_error\_message(char \*title, char \*text, int returnlevels) {
\* a new page with the desired content.
\*\*/
void print\_export\_link(int content\_type, char \*cgi, char \*add\_to\_url) {
- char stripped\_query\_string[MAX\_INPUT\_BUFFER] = "";
char link[MAX\_INPUT\_BUFFER] = "";
+ char temp\_buffer[MAX\_INPUT\_BUFFER] = "";
+ html\_request \*temp\_request\_item = NULL;
if (cgi == NULL)
return;
- strcat(link, cgi);
+ strncpy(link, cgi, sizeof(link));
+ link[sizeof(link) - 1] = '\x0';
- /\* just do stuff if some options are requested \*/
- if (getenv("QUERY\_STRING") != NULL && strcmp(getenv("QUERY\_STRING"), "")) {
- if(strlen(getenv("QUERY\_STRING")) > MAX\_INPUT\_BUFFER - 1) {
- write\_to\_cgi\_log("print\_export\_link(): Query string exceeds max length. Returning without displaying export link.\n");
- return;
- }
- strcpy(stripped\_query\_string, getenv("QUERY\_STRING"));
- strip\_html\_brackets(stripped\_query\_string);
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
- /\* check if concatenated strings exceed MAX\_INPUT\_BUFFER \*/
- if (strlen(link) + strlen(stripped\_query\_string) + 1 > MAX\_INPUT\_BUFFER - 1) {
- write\_to\_cgi\_log("print\_export\_link(): Full query string exceeds max length. Returning without displaying export link.\n");
- return;
+ if (temp\_request\_item->is\_valid == FALSE || temp\_request\_item->option == NULL) {
+ continue;
}
- strcat(link, "?");
- strcat(link, stripped\_query\_string);
+ strncpy(temp\_buffer, link, sizeof(temp\_buffer));
+ if (temp\_request\_item->value != NULL) {
+ snprintf(link, sizeof(link) - 1, "%s%s%s=%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&" : "?", url\_encode(temp\_request\_item->option), url\_encode(temp\_request\_item->value));
+ } else {
+ snprintf(link, sizeof(link) - 1, "%s%s%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&" : "?", url\_encode(temp\_request\_item->option));
+ }
+ link[sizeof(link) - 1] = '\x0';
}
/\* add string to url \*/
- if (add\_to\_url != NULL && strlen(add\_to\_url) != 0 && strlen(link) + strlen(stripped\_query\_string) + strlen(add\_to\_url) + 2 <= MAX\_INPUT\_BUFFER - 1) {
- if (strlen(stripped\_query\_string) != 0)
- strcat(link, "&");
- else
- strcat(link, "?");
- strcat(link, add\_to\_url);
+ if (add\_to\_url != NULL && strlen(add\_to\_url) != 0) {
+ strncpy(temp\_buffer, link, sizeof(temp\_buffer));
+ snprintf(link, sizeof(link) - 1, "%s%s%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&" : "?", add\_to\_url);
+ link[sizeof(link) - 1] = '\x0';
}
/\* print formatted link \*/
if (content\_type == CSV\_CONTENT)
- printf("[![%s](%s%s "%s")](%25s%25scsvoutput)\n", link, (strlen(stripped\_query\_string) != 0) ? "&" : "?", url\_images\_path, EXPORT\_CSV\_ICON, EXPORT\_CSV\_ICON\_ALT, EXPORT\_CSV\_ICON\_ALT);
+ printf("[![%s](%s%s "%s")](%25s%25scsvoutput)\n", link, (strstr(link, "?")) ? "&" : "?", url\_images\_path, EXPORT\_CSV\_ICON, EXPORT\_CSV\_ICON\_ALT, EXPORT\_CSV\_ICON\_ALT);
else if (content\_type == JSON\_CONTENT)
- printf("[![%s](%s%s "%s")](%25s%25sjsonoutput)\n", link, (strlen(stripped\_query\_string) != 0) ? "&" : "?", url\_images\_path, EXPORT\_JSON\_ICON, EXPORT\_JSON\_ICON\_ALT, EXPORT\_JSON\_ICON\_ALT);
+ printf("[![%s](%s%s "%s")](%25s%25sjsonoutput)\n", link, (strstr(link, "?")) ? "&" : "?", url\_images\_path, EXPORT\_JSON\_ICON, EXPORT\_JSON\_ICON\_ALT, EXPORT\_JSON\_ICON\_ALT);
else if (content\_type == XML\_CONTENT)
- printf("[![%s](%s%s "%s")](%25s%25sxmloutput)\n", link, (strlen(stripped\_query\_string) != 0) ? "&" : "?", url\_images\_path, EXPORT\_XML\_ICON, EXPORT\_XML\_ICON\_ALT, EXPORT\_XML\_ICON\_ALT);
+ printf("[![%s](%s%s "%s")](%25s%25sxmloutput)\n", link, (strstr(link, "?")) ? "&" : "?", url\_images\_path, EXPORT\_XML\_ICON, EXPORT\_XML\_ICON\_ALT, EXPORT\_XML\_ICON\_ALT);
else
printf("[![%s](%s%s "%s")](%25s)\n", link, url\_images\_path, EXPORT\_LINK\_ICON, EXPORT\_LINK\_ICON\_ALT, EXPORT\_LINK\_ICON\_ALT);
@@ -3658,16 +3652,15 @@ void print\_modified\_attributes(int content\_type, char \*cgi, unsigned long modifi
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* pagination functions \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
void page\_num\_selector(int result\_start, int total\_entries, int displayed\_entries) {
-
char link[MAX\_INPUT\_BUFFER] = "";
- char stripped\_query\_string[MAX\_INPUT\_BUFFER] = "";
- char \*temp\_buffer;
+ char temp\_buffer[MAX\_INPUT\_BUFFER] = "";
int total\_pages = 1;
int current\_page = 1;
//int next\_page = 0;
int previous\_page = 0;
int display\_from = 0;
int display\_to = 0;
+ html\_request \*temp\_request\_item = NULL;
/\* define base url \*/
switch (CGI\_ID) {
@@ -3676,49 +3669,44 @@ void page\_num\_selector(int result\_start, int total\_entries, int displayed\_entrie
// strcat(link, STATUS\_CGI);
// break;
case CONFIG\_CGI\_ID:
- strcat(link, CONFIG\_CGI);
+ strncpy(link, CONFIG\_CGI, sizeof(link));
break;
case EXTINFO\_CGI\_ID:
- strcat(link, EXTINFO\_CGI);
+ strncpy(link, EXTINFO\_CGI, sizeof(link));
break;
case HISTORY\_CGI\_ID:
- strcat(link, HISTORY\_CGI);
+ strncpy(link, HISTORY\_CGI, sizeof(link));
break;
case NOTIFICATIONS\_CGI\_ID:
- strcat(link, NOTIFICATIONS\_CGI);
+ strncpy(link, NOTIFICATIONS\_CGI, sizeof(link));
break;
case SHOWLOG\_CGI\_ID:
- strcat(link, SHOWLOG\_CGI);
+ strncpy(link, SHOWLOG\_CGI, sizeof(link));
break;
default:
- strcat(link, "NO\_URL\_DEFINED");
+ strncpy(link, "NO\_URL\_DEFINED", sizeof(link));
break;
}
+ link[sizeof(link) - 1] = '\x0';
- /\* get url options but filter out "limit" and "status" \*/
- if (getenv("QUERY\_STRING") != NULL && strcmp(getenv("QUERY\_STRING"), "")) {
- if(strlen(getenv("QUERY\_STRING")) > MAX\_INPUT\_BUFFER - 1) {
- write\_to\_cgi\_log("page\_num\_selector(): Query string exceeds max length. Returning without displaying num selector.\n");
- return;
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
+
+ if (temp\_request\_item->is\_valid == FALSE || temp\_request\_item->option == NULL) {
+ continue;
}
- strcpy(stripped\_query\_string, getenv("QUERY\_STRING"));
- strip\_html\_brackets(stripped\_query\_string);
- /\* check if concatenated strings exceed MAX\_INPUT\_BUFFER \*/
- if (strlen(link) + strlen(stripped\_query\_string) + 1 > MAX\_INPUT\_BUFFER - 1) {
- write\_to\_cgi\_log("page\_num\_selector(): Full query string exceeds max length. Returning without displaying num selector.\n");
- return;
+ /\* filter out "limit" and "start" \*/
+ if (!strcmp(temp\_request\_item->option, "limit") || !strcmp(temp\_request\_item->option, "start")) {
+ continue;
}
- for (temp\_buffer = my\_strtok(stripped\_query\_string, "&"); temp\_buffer != NULL; temp\_buffer = my\_strtok(NULL, "&")) {
- if (strncmp(temp\_buffer, "limit=", 6) != 0 && strncmp(temp\_buffer, "start=", 6) != 0) {
- if (strstr(link, "?"))
- strcat(link, "&");
- else
- strcat(link, "?");
- strcat(link, temp\_buffer);
- }
+ strncpy(temp\_buffer, link, sizeof(temp\_buffer));
+ if (temp\_request\_item->value != NULL) {
+ snprintf(link, sizeof(link) - 1, "%s%s%s=%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&" : "?", url\_encode(temp\_request\_item->option), url\_encode(temp\_request\_item->value));
+ } else {
+ snprintf(link, sizeof(link) - 1, "%s%s%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&" : "?", url\_encode(temp\_request\_item->option));
}
+ link[sizeof(link) - 1] = '\x0';
}
/\* calculate pages \*/
@@ -3787,61 +3775,55 @@ void page\_num\_selector(int result\_start, int total\_entries, int displayed\_entrie
}
void page\_limit\_selector(int result\_start) {
-
static int id = 0; // gets every dropdown a single id to activate msdropdown
char link[MAX\_INPUT\_BUFFER] = "";
- char stripped\_query\_string[MAX\_INPUT\_BUFFER] = "";
- char \*temp\_buffer;
+ char temp\_buffer[MAX\_INPUT\_BUFFER] = "";
+ html\_request \*temp\_request\_item = NULL;
/\* define base url \*/
switch (CGI\_ID) {
case STATUS\_CGI\_ID:
- strcat(link, STATUS\_CGI);
+ strncpy(link, STATUS\_CGI, sizeof(link));
break;
case CONFIG\_CGI\_ID:
- strcat(link, CONFIG\_CGI);
+ strncpy(link, CONFIG\_CGI, sizeof(link));
break;
case EXTINFO\_CGI\_ID:
- strcat(link, EXTINFO\_CGI);
+ strncpy(link, EXTINFO\_CGI, sizeof(link));
break;
case HISTORY\_CGI\_ID:
- strcat(link, HISTORY\_CGI);
+ strncpy(link, HISTORY\_CGI, sizeof(link));
break;
case NOTIFICATIONS\_CGI\_ID:
- strcat(link, NOTIFICATIONS\_CGI);
+ strncpy(link, NOTIFICATIONS\_CGI, sizeof(link));
break;
case SHOWLOG\_CGI\_ID:
- strcat(link, SHOWLOG\_CGI);
+ strncpy(link, SHOWLOG\_CGI, sizeof(link));
break;
default:
- strcat(link, "NO\_URL\_DEFINED");
+ strncpy(link, "NO\_URL\_DEFINED", sizeof(link));
break;
}
+ link[sizeof(link) - 1] = '\x0';
- /\* get url options but filter out "limit" and "status" \*/
- if (getenv("QUERY\_STRING") != NULL && strcmp(getenv("QUERY\_STRING"), "")) {
- if(strlen(getenv("QUERY\_STRING")) > MAX\_INPUT\_BUFFER - 1) {
- write\_to\_cgi\_log("page\_limit\_selector(): Query string exceeds max length. Returning without displaying page limit selector.\n");
- return;
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
+
+ if (temp\_request\_item->is\_valid == FALSE || temp\_request\_item->option == NULL) {
+ continue;
}
- strcpy(stripped\_query\_string, getenv("QUERY\_STRING"));
- strip\_html\_brackets(stripped\_query\_string);
- /\* check if concatenated strings exceed MAX\_INPUT\_BUFFER \*/
- if (strlen(link) + strlen(stripped\_query\_string) + 1 > MAX\_INPUT\_BUFFER - 1) {
- write\_to\_cgi\_log("page\_limit\_selector(): Full query string exceeds max length. Returning without displaying page limit selector.\n");
- return;
+ /\* filter out "limit" and "start" \*/
+ if (!strcmp(temp\_request\_item->option, "limit") || !strcmp(temp\_request\_item->option, "start")) {
+ continue;
}
- for (temp\_buffer = my\_strtok(stripped\_query\_string, "&"); temp\_buffer != NULL; temp\_buffer = my\_strtok(NULL, "&")) {
- if (strncmp(temp\_buffer, "limit=", 6) != 0 && strncmp(temp\_buffer, "start=", 6) != 0) {
- if (strstr(link, "?"))
- strcat(link, "&");
- else
- strcat(link, "?");
- strcat(link, temp\_buffer);
- }
+ strncpy(temp\_buffer, link, sizeof(temp\_buffer));
+ if (temp\_request\_item->value != NULL) {
+ snprintf(link, sizeof(link) - 1, "%s%s%s=%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&" : "?", url\_encode(temp\_request\_item->option), url\_encode(temp\_request\_item->value));
+ } else {
+ snprintf(link, sizeof(link) - 1, "%s%s%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&" : "?", url\_encode(temp\_request\_item->option));
}
+ link[sizeof(link) - 1] = '\x0';
}
/\* display drop down menu to select result limit \*/
diff --git a/cgi/cmd.c b/cgi/cmd.c
index cfffa74..03319c3 100644
--- a/cgi/cmd.c
+++ b/cgi/cmd.c
@@ -174,6 +174,7 @@ unsigned long attr = MODATTR\_NONE; /\*\*< default modified\_attributes \*/
double interval = 1.0; /\*\*< default modified \*\_interval \*/
authdata current\_authdata; /\*\*< struct to hold current authentication data \*/
+html\_request \*html\_request\_list = NULL; /\*\*< contains html requested data \*/
/\*\* Initialize the struct \*/
struct hostlist commands[NUMBER\_OF\_STRUCTS];
@@ -279,13 +280,10 @@ void check\_comment\_sanity(int\*);
void check\_time\_sanity(int\*);
/\*\* @brief Parses the requested GET/POST variables
- \* @retval TRUE
- \* @retval FALSE
- \* @return wether parsing was successful or not
\*
\* @n This function parses the request and set's the necessary variables
\*\*/
-int process\_cgivars(void);
+void process\_cgivars(void);
/\*\* @brief Yes we need a main function \*\*/
@@ -305,6 +303,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(get\_cgi\_config\_location(), ERROR\_CGI\_CFG\_FILE, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -314,6 +313,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(main\_config\_file, ERROR\_CGI\_MAIN\_CFG, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -336,6 +336,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_OBJECT\_DATA, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -346,6 +347,7 @@ int main(void) {
print\_error(NULL, ERROR\_CGI\_STATUS\_DATA, FALSE);
document\_footer(CGI\_ID);
free\_memory();
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -403,146 +405,112 @@ int main(void) {
document\_footer(CGI\_ID);
/\* free allocated memory \*/
+ free\_html\_request(html\_request\_list);
free\_memory();
free\_object\_data();
return OK;
}
-int process\_cgivars(void) {
- char \*\*variables;
+void process\_cgivars(void) {
char \*temp\_buffer = NULL;
char \*key = NULL;
char \*value = NULL;
- int error = FALSE;
- int x;
+ int x = 0;
int z = 0;
int sticky\_ack\_set = FALSE; /\* default is TRUE \*/
+ html\_request \*temp\_request\_item = NULL;
- variables = getcgivars();
+ html\_request\_list = getcgivars();
- /\* Process the variables \*/
- for (x = 0; variables[x] != NULL; x+=2) {
- key = variables[x];
- value = variables[x+1];
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
- /\* do some basic length checking on the variable identifier to prevent buffer overflows \*/
- if (strlen(key) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
- /\* likewise, check the value if there is one \*/
- if (value != NULL)
- if (strlen(value) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
+ key = temp\_request\_item->option;
+ value = temp\_request\_item->value;
/\* we found the command type \*/
- if (!strcmp(key, "cmd\_typ")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ if (!strcmp(key, "cmd\_typ") && value != NULL) {
command\_type = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the attr \*/
- else if (!strcmp(key, "attr")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "attr") && value != NULL) {
attr = strtoul(value, NULL, 10);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the attr \*/
- else if (!strcmp(key, "interval")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "interval") && value != NULL) {
#ifdef HAVE\_STRTOF
interval = strtof(value, NULL);
#else
/\* Solaris 8 doesn't have strtof() \*/
interval = (float)strtod(value, NULL);
#endif
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the command mode \*/
- else if (!strcmp(key, "cmd\_mod")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "cmd\_mod") && value != NULL) {
command\_mode = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found a comment id or a downtime id\*/
- else if (!strcmp(key, "com\_id") || !strcmp(key, "down\_id")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if ((!strcmp(key, "com\_id") || !strcmp(key, "down\_id")) && value != NULL) {
multi\_ids[z] = strtoul(value, NULL, 10);
z++;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the notification delay \*/
- else if (!strcmp(key, "not\_dly")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "not\_dly") && value != NULL) {
notification\_delay = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the schedule delay \*/
- else if (!strcmp(key, "sched\_dly")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "sched\_dly") && value != NULL) {
schedule\_delay = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the comment author \*/
- else if (!strcmp(key, "com\_author")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "com\_author") && value != NULL) {
if ((comment\_author = (char \*)strdup(value)) == NULL)
comment\_author = "";
strip\_html\_brackets(comment\_author);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the comment data \*/
- else if (!strcmp(key, "com\_data")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "com\_data") && value != NULL) {
if ((comment\_data = (char \*)strdup(value)) == NULL)
comment\_data = "";
strip\_html\_brackets(comment\_data);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the host name \*/
- else if (!strcmp(key, "host")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "host") && value != NULL) {
if ((host\_name = (char \*)strdup(value)) == NULL)
host\_name = "";
@@ -551,27 +519,24 @@ int process\_cgivars(void) {
/\* Store hostname in struct \*/
commands[x].host\_name = host\_name;
+ x++;
}
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the hostgroup name \*/
- else if (!strcmp(key, "hostgroup")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "hostgroup") && value != NULL) {
if ((hostgroup\_name = (char \*)strdup(value)) == NULL)
hostgroup\_name = "";
strip\_html\_brackets(hostgroup\_name);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the service name \*/
- else if (!strcmp(key, "service")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "service") && value != NULL) {
if ((service\_desc = (char \*)strdup(value)) == NULL)
service\_desc = "";
@@ -579,207 +544,221 @@ int process\_cgivars(void) {
strip\_html\_brackets(service\_desc);
/\* Store service description in struct \*/
- commands[(x-2)].description = service\_desc;
+ commands[(x-1)].description = service\_desc;
}
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found a combined host/service \*/
- else if (!strcmp(key, "hostservice")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "hostservice") && value != NULL) {
temp\_buffer = strtok(value, "^");
- if ((host\_name = (char \*)strdup(temp\_buffer)) == NULL)
- host\_name = "";
- else {
+ if ((host\_name = (char \*)strdup(temp\_buffer)) == NULL) {
+ continue;
+ } else {
strip\_html\_brackets(host\_name);
commands[x].host\_name = host\_name;
}
temp\_buffer = strtok(NULL, "");
- if ((service\_desc = (char \*)strdup(temp\_buffer)) == NULL)
- service\_desc = "";
- else {
+ if ((service\_desc = (char \*)strdup(temp\_buffer)) == NULL) {
+ my\_free(commands[x].host\_name);
+ continue;
+ } else {
strip\_html\_brackets(service\_desc);
commands[x].description = service\_desc;
}
+
+ x++;
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the servicegroup name \*/
- else if (!strcmp(key, "servicegroup")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "servicegroup") && value != NULL) {
if ((servicegroup\_name = (char \*)strdup(value)) == NULL)
servicegroup\_name = "";
strip\_html\_brackets(servicegroup\_name);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we got the persistence option for a comment \*/
- else if (!strcmp(key, "persistent"))
+ else if (!strcmp(key, "persistent")) {
persistent\_comment = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we got the notification option for an acknowledgement \*/
- else if (!strcmp(key, "send\_notification"))
- send\_notification = TRUE;
+ else if (!strcmp(key, "send\_notification")) {
+ send\_notification = (atoi(value) > 0) ? TRUE : FALSE;
+
+ /\* if the value was omitted, assume it is enabled \*/
+ if (value == NULL)
+ send\_notification = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
+ }
/\* we got the acknowledgement type \*/
- else if (!strcmp(key, "sticky\_ack"))
- sticky\_ack\_set = TRUE;
+ else if (!strcmp(key, "sticky\_ack")) {
+ sticky\_ack\_set = (atoi(value) > 0) ? TRUE : FALSE;
+
+ /\* if the value was omitted, assume it is enabled \*/
+ if (value == NULL)
+ sticky\_ack\_set = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
+ }
/\* we use the end\_time as expire time \*/
- else if (!strcmp(key, "use\_ack\_end\_time"))
+ else if (!strcmp(key, "use\_ack\_end\_time")) {
use\_ack\_end\_time = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we use the end\_time as disabled notifcations expire time \*/
- else if (!strcmp(key, "use\_disabled\_notif\_end\_time"))
+ else if (!strcmp(key, "use\_disabled\_notif\_end\_time")) {
use\_disabled\_notif\_end\_time = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we got the service check force option \*/
- else if (!strcmp(key, "force\_check"))
+ else if (!strcmp(key, "force\_check")) {
force\_check = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we got the option to affect host and all its services \*/
- else if (!strcmp(key, "ahas"))
+ else if (!strcmp(key, "ahas")) {
affect\_host\_and\_services = TRUE;
-
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we got the option to propagate to child hosts \*/
- else if (!strcmp(key, "ptc"))
+ else if (!strcmp(key, "ptc")) {
propagate\_to\_children = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we got the option for fixed downtime \*/
- else if (!strcmp(key, "fixed")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "fixed") && value != NULL) {
fixed = (atoi(value) > 0) ? TRUE : FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we got the triggered by downtime option \*/
- else if (!strcmp(key, "trigger")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "trigger") && value != NULL) {
triggered\_by = strtoul(value, NULL, 10);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we got the child options \*/
- else if (!strcmp(key, "childoptions")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "childoptions") && value != NULL) {
child\_options = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the plugin output \*/
- else if (!strcmp(key, "plugin\_output")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "plugin\_output") && value != NULL) {
+
+ strncpy(plugin\_output, value, MAX\_INPUT\_BUFFER);
- strcpy(plugin\_output, value);
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the performance data \*/
- else if (!strcmp(key, "performance\_data")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "performance\_data") && value != NULL) {
+
+ strncpy(performance\_data, value, MAX\_INPUT\_BUFFER);
- strcpy(performance\_data, value);
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the plugin state \*/
- else if (!strcmp(key, "plugin\_state")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "plugin\_state") && value != NULL) {
plugin\_state = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the hour duration \*/
- else if (!strcmp(key, "hours")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "hours") && value != NULL) {
if (atoi(value) < 0) {
- error = TRUE;
- break;
+ continue;
}
duration += (unsigned long)(atoi(value) \* 3600);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the minute duration \*/
- else if (!strcmp(key, "minutes")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "minutes") && value != NULL) {
if (atoi(value) < 0) {
- error = TRUE;
- break;
+ continue;
}
duration += (unsigned long)(atoi(value) \* 60);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the start time \*/
- else if (!strcmp(key, "start\_time")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "start\_time") && value != NULL) {
- start\_time\_string = (char \*)malloc(strlen(value) + 1);
- if (start\_time\_string == NULL)
+ if ((start\_time\_string = (char \*)strdup(value)) == NULL) {
start\_time\_string = "";
- else
- strcpy(start\_time\_string, value);
+ }
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the end time \*/
- else if (!strcmp(key, "end\_time")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "end\_time") && value != NULL) {
- end\_time\_string = (char \*)malloc(strlen(value) + 1);
- if (end\_time\_string == NULL)
+ if ((end\_time\_string = (char \*)strdup(value)) == NULL) {
end\_time\_string = "";
- else
- strcpy(end\_time\_string, value);
+ }
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the forced notification option \*/
- else if (!strcmp(key, "force\_notification"))
+ else if (!strcmp(key, "force\_notification")) {
force\_notification = NOTIFICATION\_OPTION\_FORCED;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the broadcast notification option \*/
- else if (!strcmp(key, "broadcast\_notification"))
+ else if (!strcmp(key, "broadcast\_notification")) {
broadcast\_notification = NOTIFICATION\_OPTION\_BROADCAST;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we got the persistence option for a comment \*/
- else if (!strcmp(key, "nodaemoncheck"))
+ else if (!strcmp(key, "nodaemoncheck")) {
daemon\_check = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
}
@@ -787,10 +766,7 @@ int process\_cgivars(void) {
sticky\_ack = sticky\_ack\_set;
}
- /\* free memory allocated to the CGI variables \*/
- free\_cgivars(variables);
-
- return error;
+ return;
}
void print\_object\_list(int list\_type) {
diff --git a/cgi/config.c b/cgi/config.c
index 44dbd51..eecd6d3 100644
--- a/cgi/config.c
+++ b/cgi/config.c
@@ -144,7 +144,7 @@ extern int use\_ssl\_authentication;
extern int week\_starts\_on\_monday;
-int process\_cgivars(void);
+void process\_cgivars(void);
void display\_options(void);
void display\_hosts(void);
void display\_hostgroups(void);
@@ -179,6 +179,7 @@ char hashed\_color[8];
char \*item\_name = NULL; /\*\*< contains exact name user is looking for \*/
char \*search\_string = NULL; /\*\*< contains search string if user searched something \*/
regex\_t search\_preg; /\*\*< contains compiled regex term to use with regexec() \*/
+html\_request \*html\_request\_list = NULL; /\*\*< contains html requested data \*/
char \*org\_action\_url\_target = "";
char \*org\_authorization\_config\_file = "";
@@ -297,6 +298,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(get\_cgi\_config\_location(), ERROR\_CGI\_CFG\_FILE, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -306,6 +308,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(main\_config\_file, ERROR\_CGI\_MAIN\_CFG, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -315,6 +318,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_OBJECT\_DATA, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -458,6 +462,7 @@ int main(void) {
if (is\_authorized\_for\_configuration\_information(&current\_authdata) == FALSE) {
print\_generic\_error\_message("It appears as though you do not have permission to view the configuration information you requested...", "If you believe this is an error, check the HTTP server authentication requirements for accessing this CGI and check the authorization options in your CGI configuration file.", 0);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return OK;
}
@@ -577,90 +582,62 @@ int main(void) {
page\_num\_selector(result\_start, total\_entries, displayed\_entries);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return OK;
}
-int process\_cgivars(void) {
- char \*\*variables;
+void process\_cgivars(void) {
char \*key = NULL;
char \*value = NULL;
- int error = FALSE;
- int x;
+ html\_request \*temp\_request\_item = NULL;
- variables = getcgivars();
+ html\_request\_list = getcgivars();
to\_expand[0] = '\0';
- for (x = 0; variables[x] != NULL; x+=2) {
- key = variables[x];
- value = variables[x+1];
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
- /\* do some basic length checking on the variable identifier to prevent buffer overflows \*/
- if (strlen(key) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
- /\* likewise, check the value for length if it's present \*/
- if (value != NULL)
- if (strlen(value) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
+ key = temp\_request\_item->option;
+ value = temp\_request\_item->value;
/\* we found the search\_string argument \*/
if (!strcmp(key, "search\_string")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
-
- if (strlen(value) != 0)
+ if (value != NULL && strlen(value) != 0) {
search\_string = strdup(value);
+ temp\_request\_item->is\_valid = TRUE;
+ }
}
/\* we found the item\_name argument \*/
else if (!strcmp(key, "item\_name")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
-
- if (strlen(value) != 0)
+ if (value != NULL && strlen(value) != 0) {
item\_name = strdup(value);
+ temp\_request\_item->is\_valid = TRUE;
+ }
}
/\* we found the host name \*/
- else if (!strcmp(key, "host")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
-
+ else if (!strcmp(key, "host") && value != NULL) {
host\_name = strdup(value);
if (host\_name == NULL)
host\_name = "";
strip\_html\_brackets(host\_name);
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the service name \*/
- else if (!strcmp(key, "service")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
-
+ else if (!strcmp(key, "service") && value != NULL) {
service\_desc = strdup(value);
if (service\_desc == NULL)
service\_desc = "";
strip\_html\_brackets(service\_desc);
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the configuration type argument \*/
- else if (!strcmp(key, "type")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "type") && value != NULL) {
+
+ temp\_request\_item->is\_valid = TRUE;
/\* what information should we display? \*/
if (!strcmp(value, "hosts"))
@@ -695,71 +672,68 @@ int process\_cgivars(void) {
display\_type = DISPLAY\_CGICONFIG;
else if (!strcmp(value, "all"))
display\_type = DISPLAY\_ALL;
+ else
+ temp\_request\_item->is\_valid = FALSE;
}
/\* we found the embed option \*/
- else if (!strcmp(key, "embedded"))
+ else if (!strcmp(key, "embedded")) {
embedded = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the nodaemoncheck option \*/
- else if (!strcmp(key, "nodaemoncheck"))
+ else if (!strcmp(key, "nodaemoncheck")) {
daemon\_check = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the string-to-expand argument \*/
- else if (!strcmp(key, "expand")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "expand") && value != NULL) {
+
strncpy(to\_expand, value, MAX\_COMMAND\_BUFFER);
to\_expand[MAX\_COMMAND\_BUFFER - 1] = '\0';
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the CSV output option \*/
else if (!strcmp(key, "csvoutput")) {
display\_header = FALSE;
content\_type = CSV\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the JSON output option \*/
else if (!strcmp(key, "jsonoutput")) {
display\_header = FALSE;
content\_type = JSON\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* start num results to skip on displaying statusdata \*/
- else if (!strcmp(key, "start")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "start") && value != NULL) {
result\_start = atoi(value);
if (result\_start < 1)
result\_start = 1;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* amount of results to display \*/
- else if (!strcmp(key, "limit")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
-
+ else if (!strcmp(key, "limit") && value != NULL) {
get\_result\_limit = atoi(value);
+ temp\_request\_item->is\_valid = TRUE;
}
-
- /\* we received an invalid argument \*/
- else
- error = TRUE;
-
}
- /\* free memory allocated to the CGI variables \*/
- free\_cgivars(variables);
-
- return error;
+ return;
}
void display\_hosts(void) {
diff --git a/cgi/extinfo.c b/cgi/extinfo.c
index 2f715d0..dc839a9 100644
--- a/cgi/extinfo.c
+++ b/cgi/extinfo.c
@@ -107,7 +107,7 @@ typedef struct sortdata\_struct {
struct sortdata\_struct \*next;
} sortdata;
-int process\_cgivars(void);
+void process\_cgivars(void);
void show\_process\_info(void);
void show\_host\_info(void);
@@ -129,6 +129,8 @@ authdata current\_authdata;
sortdata \*sortdata\_list = NULL;
+html\_request \*html\_request\_list = NULL; /\*\*< contains html requested data \*/
+
char \*host\_name = "";
char \*hostgroup\_name = "";
char \*servicegroup\_name = "";
@@ -186,6 +188,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(get\_cgi\_config\_location(), ERROR\_CGI\_CFG\_FILE, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -195,6 +198,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(main\_config\_file, ERROR\_CGI\_MAIN\_CFG, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -204,6 +208,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_OBJECT\_DATA, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -214,6 +219,7 @@ int main(void) {
print\_error(NULL, ERROR\_CGI\_STATUS\_DATA, FALSE);
document\_footer(CGI\_ID);
free\_memory();
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -797,42 +803,28 @@ int main(void) {
free\_memory();
free\_comment\_data();
free\_downtime\_data();
+ free\_sortdata\_list();
+ free\_html\_request(html\_request\_list);
return OK;
}
-int process\_cgivars(void) {
- char \*\*variables;
+void process\_cgivars(void) {
char \*key = NULL;
char \*value = NULL;
- int error = FALSE;
int temp\_type;
- int x;
+ html\_request \*temp\_request\_item = NULL;
- variables = getcgivars();
+ html\_request\_list = getcgivars();
- for (x = 0; variables[x] != NULL; x+=2) {
- key = variables[x];
- value = variables[x+1];
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
- /\* do some basic length checking on the variable identifier to prevent buffer overflows \*/
- if (strlen(key) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
- /\* likewise, check the value if it exists \*/
- if (value != NULL)
- if (strlen(value) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
+ key = temp\_request\_item->option;
+ value = temp\_request\_item->value;
/\* we found the display type \*/
- if (!strcmp(key, "type")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ if (!strcmp(key, "type") && value != NULL) {
+
temp\_type = atoi(value);
if (temp\_type == DISPLAY\_HOST\_INFO)
display\_type = DISPLAY\_HOST\_INFO;
@@ -852,97 +844,89 @@ int process\_cgivars(void) {
display\_type = DISPLAY\_SCHEDULING\_QUEUE;
else
display\_type = DISPLAY\_PROCESS\_INFO;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the host name \*/
- else if (!strcmp(key, "host")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "host") && value != NULL) {
host\_name = strdup(value);
if (host\_name == NULL)
host\_name = "";
strip\_html\_brackets(host\_name);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the hostgroup name \*/
- else if (!strcmp(key, "hostgroup")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "hostgroup") && value != NULL) {
hostgroup\_name = strdup(value);
if (hostgroup\_name == NULL)
hostgroup\_name = "";
strip\_html\_brackets(hostgroup\_name);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the service name \*/
- else if (!strcmp(key, "service")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "service") && value != NULL) {
service\_desc = strdup(value);
if (service\_desc == NULL)
service\_desc = "";
strip\_html\_brackets(service\_desc);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the servicegroup name \*/
- else if (!strcmp(key, "servicegroup")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "servicegroup") && value != NULL) {
servicegroup\_name = strdup(value);
if (servicegroup\_name == NULL)
servicegroup\_name = "";
strip\_html\_brackets(servicegroup\_name);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the sort type argument \*/
- else if (!strcmp(key, "sorttype")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "sorttype") && value != NULL) {
sort\_type = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the sort option argument \*/
- else if (!strcmp(key, "sortoption")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "sortoption") && value != NULL) {
sort\_option = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the CSV output option \*/
else if (!strcmp(key, "csvoutput")) {
display\_header = FALSE;
content\_type = CSV\_CONTENT;
+
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the JSON output option \*/
else if (!strcmp(key, "jsonoutput")) {
display\_header = FALSE;
content\_type = JSON\_CONTENT;
+
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
- else if (!strcmp(key, "csvtype")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "csvtype") && value != NULL) {
if (!strcmp(value, "comment"))
csv\_type = CSV\_COMMENT;
@@ -950,54 +934,63 @@ int process\_cgivars(void) {
csv\_type = CSV\_DOWNTIME;
else
csv\_type = CSV\_DEFAULT;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the embed option \*/
- else if (!strcmp(key, "embedded"))
+ else if (!strcmp(key, "embedded")) {
embedded = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
+
/\* we found the noheader option \*/
- else if (!strcmp(key, "noheader"))
+ else if (!strcmp(key, "noheader")) {
display\_header = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
+
/\* we found the pause option \*/
- else if (!strcmp(key, "paused"))
+ else if (!strcmp(key, "paused")) {
refresh = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
+
/\* we found the nodaemoncheck option \*/
- else if (!strcmp(key, "nodaemoncheck"))
+ else if (!strcmp(key, "nodaemoncheck")) {
daemon\_check = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
+
/\* start num results to skip on displaying statusdata \*/
- else if (!strcmp(key, "start")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "start") && value != NULL) {
result\_start = atoi(value);
if (result\_start < 1)
result\_start = 1;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* amount of results to display \*/
- else if (!strcmp(key, "limit")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "limit") && value != NULL) {
get\_result\_limit = atoi(value);
- }
+ temp\_request\_item->is\_valid = TRUE;
+ }
}
-
- /\* free memory allocated to the CGI variables \*/
- free\_cgivars(variables);
-
- return error;
+ return;
}
void show\_process\_info(void) {
diff --git a/cgi/getcgi.c b/cgi/getcgi.c
index 56645fd..33d439e 100644
--- a/cgi/getcgi.c
+++ b/cgi/getcgi.c
@@ -138,22 +138,18 @@ void unescape\_cgi\_input(char \*input) {
return;
}
-
-
-/\* read the CGI input and place all name/val pairs into list. returns list containing name1, value1, name2, value2, ... , NULL \*/
-/\* this is a hacked version of a routine I found a long time ago somewhere - can't remember where anymore \*/
-char \*\*getcgivars(void) {
- register int i;
+html\_request \*getcgivars(void) {
char \*request\_method;
char \*content\_type;
char \*content\_length\_string;
int content\_length;
char \*cgiinput;
- char \*\*cgivars;
- char \*\*pairlist;
- int paircount;
char \*nvpair;
char \*eqpos;
+ char \*temp\_pair;
+ html\_request \*new\_html\_request\_list = NULL;
+ html\_request \*new\_request\_item = NULL;
+ html\_request \*last\_request\_item = NULL;
/\* initialize char variable(s) \*/
cgiinput = "";
@@ -237,92 +233,88 @@ char \*\*getcgivars(void) {
exit(1);
}
- /\* first, split on ampersands (&) to extract the name-value pairs into pairlist \*/
- /\* allocate memory for 256 name-value pairs at a time, increasing by same
- amount as necessary... \*/
- pairlist = (char \*\*)malloc(256 \* sizeof(char \*\*));
- if (pairlist == NULL) {
- printf("getcgivars(): Could not allocate memory for name-value pairlist.\n");
- exit(1);
- }
- paircount = 0;
- nvpair = strtok(cgiinput, "&");
+ nvpair = my\_strtok(cgiinput, "&");
while (nvpair) {
- pairlist[paircount] = strdup(nvpair);
- if(pairlist[paircount++] == NULL) {
- printf("getcgivars(): Could not allocate memory for name-value pair element #%d.\n", paircount);
+
+ temp\_pair = strdup(nvpair);
+ if(temp\_pair == NULL) {
+ printf("getcgivars(): Could not allocate memory for name-value pair element %s.\n", nvpair);
exit(1);
}
- if (paircount > MAX\_CGI\_INPUT\_PAIRS)
- break;
- if (!(paircount % 256)) {
- pairlist = (char \*\*)realloc(pairlist, (paircount + 256) \* sizeof(char \*\*));
- if (pairlist == NULL) {
- printf("getcgivars(): Could not re-allocate memory for name-value pairlist.\n");
- exit(1);
- }
- }
- nvpair = strtok(NULL, "&");
- }
- /\* terminate the list \*/
- pairlist[paircount] = '\x0';
+ /\* allocating new memory \*/
+ new\_request\_item = (html\_request \*)malloc(sizeof(html\_request));
+ if(new\_request\_item == NULL) {
+ printf("getcgivars(): Could not allocate memory for new html\_request element.\n");
+ my\_free(temp\_pair);
+ exit(1);
+ }
- /\* extract the names and values from the pairlist \*/
- cgivars = (char \*\*)malloc((paircount \* 2 + 1) \* sizeof(char \*\*));
- if (cgivars == NULL) {
- printf("getcgivars(): Could not allocate memory for name-value list.\n");
- exit(1);
- }
+ new\_request\_item->option = NULL;
+ new\_request\_item->value = NULL;
+ new\_request\_item->is\_valid = FALSE;
+ new\_request\_item->next = NULL;
- for (i = 0; i < paircount; i++) {
- /\* get the variable name preceding the equal (=) sign \*/
- if ((eqpos = strchr(pairlist[i], '=')) != NULL) {
+ /\* get value \*/
+ if ((eqpos = strchr(temp\_pair, '=')) != NULL) {
\*eqpos = '\0';
- cgivars[i\*2+1] = strdup(eqpos + 1);
- if(cgivars[i\*2+1] == NULL) {
- printf("getcgivars(): Could not allocate memory for cgi param value #%d,%s.\n", i,eqpos + 1);
+ new\_request\_item->value = strdup(eqpos + 1);
+ if(new\_request\_item->value == NULL) {
+ printf("getcgivars(): Could not allocate memory for cgi param value: %s=%s.\n", temp\_pair,eqpos + 1);
+ exit(1);
+ }
+ unescape\_cgi\_input(new\_request\_item->value);
+ /\* do some basic length checking \*/
+ if (strlen(new\_request\_item->value) >= MAX\_INPUT\_BUFFER - 1) {
+ printf("getcgivars(): length of cgi param value exceeds MAX\_INPUT\_BUFFER: %d.\n", MAX\_INPUT\_BUFFER);
exit(1);
}
- unescape\_cgi\_input(cgivars[i\*2+1]);
-
- } else {
- cgivars[i\*2+1] = NULL;
}
- /\* get the variable value (or name/value of there was no real "pair" in the first place) \*/
- cgivars[i\*2] = strdup(pairlist[i]);
- if(cgivars[i\*2] == NULL) {
- printf("getcgivars(): Could not allocate memory for cgi param name #%d,%s.\n", i,eqpos + 1);
+ /\* get option name
+ just reuse the temp\_pair pointer without allocating new memory
+ \*/
+ new\_request\_item->option = temp\_pair;
+ unescape\_cgi\_input(new\_request\_item->option);
+ if (strlen(new\_request\_item->option) >= MAX\_INPUT\_BUFFER - 1) {
+ printf("getcgivars(): length of cgi param option exceeds MAX\_INPUT\_BUFFER: %d.\n", MAX\_INPUT\_BUFFER);
exit(1);
}
- unescape\_cgi\_input(cgivars[i\*2]);
- }
- /\* terminate the name-value list \*/
- cgivars[paircount\*2] = '\x0';
+ if (new\_html\_request\_list == NULL) {
+ new\_html\_request\_list = new\_request\_item;
+ new\_html\_request\_list->next = NULL;
+ last\_request\_item = new\_html\_request\_list;
+ } else {
+ last\_request\_item->next = new\_request\_item;
+ last\_request\_item = new\_request\_item;
+ last\_request\_item->next = NULL;
+ }
+
+ nvpair = my\_strtok(NULL, "&");
+ }
/\* free allocated memory \*/
free(cgiinput);
- for (i = 0; pairlist[i] != NULL; i++)
- free(pairlist[i]);
- free(pairlist);
-
- /\* sanitize the name-value strings \*/
- sanitize\_cgi\_input(cgivars);
/\* return the list of name-value strings \*/
- return cgivars;
+ return new\_html\_request\_list;
}
+/\* free() memory allocated to storing the CGI request data \*/
+void free\_html\_request(html\_request \*html\_request\_list) {
+ html\_request \*this\_html\_request = NULL;
+ html\_request \*next\_html\_request = NULL;
+
+ /\* free memory for html request list \*/
+ for (this\_html\_request = html\_request\_list; this\_html\_request != NULL; this\_html\_request = next\_html\_request) {
+ next\_html\_request = this\_html\_request->next;
+ my\_free(this\_html\_request->option);
+ my\_free(this\_html\_request->value);
+ my\_free(this\_html\_request);
+ }
-
-/\* free() memory allocated to storing the CGI variables \*/
-void free\_cgivars(char \*\*cgivars) {
- register int x;
-
- for (x = 0; cgivars[x] != '\x0'; x++)
- free(cgivars[x]);
+ html\_request\_list = NULL;
return;
}
diff --git a/cgi/histogram.c b/cgi/histogram.c
index e8b8c3f..3d5267a 100644
--- a/cgi/histogram.c
+++ b/cgi/histogram.c
@@ -128,6 +128,8 @@ typedef struct timeslice\_data\_struct {
timeslice\_data \*tsdata;
+html\_request \*html\_request\_list = NULL; /\*\*< contains html requested data \*/
+
void compute\_report\_times(void);
void graph\_all\_histogram\_data(void);
void add\_archived\_state(int, time\_t);
@@ -135,7 +137,7 @@ void read\_archived\_state\_data(void);
void draw\_line(int, int, int, int, int);
void draw\_dashed\_line(int, int, int, int, int);
-int process\_cgivars(void);
+void process\_cgivars(void);
time\_t t1;
@@ -235,6 +237,7 @@ int main(int argc, char \*\*argv) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(get\_cgi\_config\_location(), ERROR\_CGI\_CFG\_FILE, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
}
return ERROR;
}
@@ -246,6 +249,7 @@ int main(int argc, char \*\*argv) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(main\_config\_file, ERROR\_CGI\_MAIN\_CFG, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
}
return ERROR;
}
@@ -257,6 +261,7 @@ int main(int argc, char \*\*argv) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_OBJECT\_DATA, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
}
return ERROR;
}
@@ -268,6 +273,7 @@ int main(int argc, char \*\*argv) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_STATUS\_DATA, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
}
free\_memory();
return ERROR;
@@ -497,6 +503,7 @@ int main(int argc, char \*\*argv) {
}
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
free\_memory();
return ERROR;
}
@@ -886,136 +893,114 @@ int main(int argc, char \*\*argv) {
document\_footer(CGI\_ID);
/\* free all other allocated memory \*/
+ free\_html\_request(html\_request\_list);
free\_memory();
return OK;
}
-int process\_cgivars(void) {
- char \*\*variables;
+void process\_cgivars(void) {
char \*key = NULL;
char \*value = NULL;
char \*temp\_buffer = NULL;
- int error = FALSE;
- int x;
+ html\_request \*temp\_request\_item = NULL;
- variables = getcgivars();
+ html\_request\_list = getcgivars();
- for (x = 0; variables[x] != NULL; x+=2) {
- key = variables[x];
- value = variables[x+1];
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
- /\* do some basic length checking on the variable identifier to prevent buffer overflows \*/
- if (strlen(key) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
- /\* likewise, check the value for length if it exists \*/
- if (key != NULL)
- if (strlen(key) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
+ key = temp\_request\_item->option;
+ value = temp\_request\_item->value;
/\* we found the host argument \*/
- if (!strcmp(key, "host")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ if (!strcmp(key, "host") && value != NULL) {
if ((host\_name = (char \*)strdup(value)) == NULL)
host\_name = "";
strip\_html\_brackets(host\_name);
display\_type = DISPLAY\_HOST\_HISTOGRAM;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the node width argument \*/
- else if (!strcmp(key, "service")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "service") && value != NULL) {
if ((service\_desc = (char \*)strdup(value)) == NULL)
service\_desc = "";
strip\_html\_brackets(service\_desc);
display\_type = DISPLAY\_SERVICE\_HISTOGRAM;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found a combined host/service \*/
- else if (!strcmp(key, "hostservice")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "hostservice") && value != NULL) {
temp\_buffer = strtok(value, "^");
- if ((host\_name = (char \*)strdup(temp\_buffer)) == NULL)
- host\_name = "";
- else
+ if ((host\_name = (char \*)strdup(temp\_buffer)) == NULL) {
+ continue;
+ } else {
strip\_html\_brackets(host\_name);
+ }
temp\_buffer = strtok(NULL, "");
- if ((service\_desc = (char \*)strdup(temp\_buffer)) == NULL)
- service\_desc = "";
- else
+ if ((service\_desc = (char \*)strdup(temp\_buffer)) == NULL) {
+ my\_free(host\_name);
+ continue;
+ } else {
strip\_html\_brackets(service\_desc);
+ }
display\_type = DISPLAY\_SERVICE\_HISTOGRAM;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found first time argument \*/
- else if (!strcmp(key, "t1")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "t1") && value != NULL) {
t1 = (time\_t)strtoul(value, NULL, 10);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found first time argument \*/
- else if (!strcmp(key, "t2")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "t2") && value != NULL) {
t2 = (time\_t)strtoul(value, NULL, 10);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the image creation option \*/
else if (!strcmp(key, "createimage")) {
content\_type = IMAGE\_CONTENT;
+
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the backtrack archives argument \*/
- else if (!strcmp(key, "backtrack")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "backtrack") && value != NULL) {
backtrack\_archives = atoi(value);
if (backtrack\_archives < 0)
backtrack\_archives = 0;
if (backtrack\_archives > MAX\_ARCHIVE\_BACKTRACKS)
backtrack\_archives = MAX\_ARCHIVE\_BACKTRACKS;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the standard timeperiod argument \*/
- else if (!strcmp(key, "timeperiod")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "timeperiod") && value != NULL) {
if (!strcmp(value, "today"))
timeperiod\_type = TIMEPERIOD\_TODAY;
@@ -1051,14 +1036,12 @@ int process\_cgivars(void) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
convert\_timeperiod\_to\_times(timeperiod\_type, &t1, &t2);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "smon")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "smon") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1066,14 +1049,12 @@ int process\_cgivars(void) {
start\_month = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "sday")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "sday") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1081,14 +1062,12 @@ int process\_cgivars(void) {
start\_day = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "syear")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "syear") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1096,14 +1075,12 @@ int process\_cgivars(void) {
start\_year = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "smin")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "smin") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1111,14 +1088,12 @@ int process\_cgivars(void) {
start\_minute = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "ssec")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "ssec") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1126,14 +1101,12 @@ int process\_cgivars(void) {
start\_second = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "shour")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "shour") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1141,15 +1114,13 @@ int process\_cgivars(void) {
start\_hour = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "emon")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "emon") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1157,14 +1128,12 @@ int process\_cgivars(void) {
end\_month = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "eday")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "eday") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1172,14 +1141,12 @@ int process\_cgivars(void) {
end\_day = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "eyear")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "eyear") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1187,14 +1154,12 @@ int process\_cgivars(void) {
end\_year = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "emin")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "emin") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1202,14 +1167,12 @@ int process\_cgivars(void) {
end\_minute = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "esec")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "esec") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1217,14 +1180,12 @@ int process\_cgivars(void) {
end\_second = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "ehour")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "ehour") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1232,26 +1193,33 @@ int process\_cgivars(void) {
end\_hour = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the embed option \*/
- else if (!strcmp(key, "embedded"))
+ else if (!strcmp(key, "embedded")) {
embedded = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the noheader option \*/
- else if (!strcmp(key, "noheader"))
+ else if (!strcmp(key, "noheader")) {
display\_header = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the nodaemoncheck option \*/
- else if (!strcmp(key, "nodaemoncheck"))
+ else if (!strcmp(key, "nodaemoncheck")) {
daemon\_check = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the input option \*/
- else if (!strcmp(key, "input")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "input") && value != NULL) {
if (!strcmp(value, "gethost"))
input\_type = GET\_INPUT\_HOST\_TARGET;
@@ -1261,34 +1229,28 @@ int process\_cgivars(void) {
input\_type = GET\_INPUT\_OPTIONS;
else
input\_type = GET\_INPUT\_TARGET\_TYPE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the graph states option \*/
- else if (!strcmp(key, "graphevents")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "graphevents") && value != NULL) {
graph\_events = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the graph state types option \*/
- else if (!strcmp(key, "graphstatetypes")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "graphstatetypes") && value != NULL) {
graph\_statetypes = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the breakdown option \*/
- else if (!strcmp(key, "breakdown")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "breakdown") && value != NULL) {
if (!strcmp(value, "monthly"))
breakdown\_type = BREAKDOWN\_MONTHLY;
@@ -1298,54 +1260,45 @@ int process\_cgivars(void) {
breakdown\_type = BREAKDOWN\_DAY\_OF\_WEEK;
else
breakdown\_type = BREAKDOWN\_HOURLY;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the assume state retention option \*/
- else if (!strcmp(key, "assumestateretention")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "assumestateretention") && value != NULL) {
if (!strcmp(value, "yes"))
assume\_state\_retention = TRUE;
else
assume\_state\_retention = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the initial states logged option \*/
- else if (!strcmp(key, "initialstateslogged")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "initialstateslogged") && value != NULL) {
if (!strcmp(value, "yes"))
initial\_states\_logged = TRUE;
else
initial\_states\_logged = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the new states only option \*/
- else if (!strcmp(key, "newstatesonly")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "newstatesonly") && value != NULL) {
if (!strcmp(value, "yes"))
new\_states\_only = TRUE;
else
new\_states\_only = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
}
}
- /\* free memory allocated to the CGI variables \*/
- free\_cgivars(variables);
-
- return error;
+ return;
}
diff --git a/cgi/history.c b/cgi/history.c
index ccdda96..e275573 100644
--- a/cgi/history.c
+++ b/cgi/history.c
@@ -76,6 +76,8 @@ time\_t ts\_end = 0L; /\*\*< end time as unix timestamp \*/
authdata current\_authdata; /\*\*< struct to hold current authentication data \*/
+html\_request \*html\_request\_list = NULL; /\*\*< contains html requested data \*/
+
int CGI\_ID = HISTORY\_CGI\_ID; /\*\*< ID to identify the cgi for functions in cgiutils.c \*/
/\*\* @} \*/
@@ -87,13 +89,10 @@ int CGI\_ID = HISTORY\_CGI\_ID; /\*\*< ID to identify the cgi for functions in cgiu
void show\_history(void);
/\*\* @brief Parses the requested GET/POST variables
- \* @return wether parsing was successful or not
- \* @retval TRUE
- \* @retval FALSE
\*
\* @n This function parses the request and set's the necessary variables
\*\*/
-int process\_cgivars(void);
+void process\_cgivars(void);
/\*\* @brief Yes we need a main function \*\*/
int main(void) {
@@ -111,6 +110,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(get\_cgi\_config\_location(), ERROR\_CGI\_CFG\_FILE, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -120,6 +120,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(main\_config\_file, ERROR\_CGI\_MAIN\_CFG, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -129,6 +130,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_OBJECT\_DATA, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -310,42 +312,26 @@ int main(void) {
document\_footer(CGI\_ID);
/\* free allocated memory \*/
+ free\_html\_request(html\_request\_list);
free\_memory();
return OK;
}
-int process\_cgivars(void) {
- char \*\*variables;
+void process\_cgivars(void) {
char \*key = NULL;
char \*value = NULL;
- int error = FALSE;
- int x;
+ html\_request \*temp\_request\_item = NULL;
- variables = getcgivars();
+ html\_request\_list = getcgivars();
- for (x = 0; variables[x] != NULL; x+=2) {
- key = variables[x];
- value = variables[x+1];
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
- /\* do some basic length checking on the variable identifier to prevent buffer overflows \*/
- if (strlen(key) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
- /\* likewise, check the value if it exists \*/
- if (value != NULL)
- if (strlen(value) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
+ key = temp\_request\_item->option;
+ value = temp\_request\_item->value;
/\* we found the host argument \*/
- if (!strcmp(key, "host")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ if (!strcmp(key, "host") && value != NULL) {
if ((host\_name = (char \*)strdup(value)) == NULL)
host\_name = "";
@@ -357,159 +343,164 @@ int process\_cgivars(void) {
show\_all\_hosts = TRUE;
else
show\_all\_hosts = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the service argument \*/
- else if (!strcmp(key, "service")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "service") && value != NULL) {
if ((service\_desc = (char \*)strdup(value)) == NULL)
service\_desc = "";
strip\_html\_brackets(service\_desc);
display\_type = DISPLAY\_SERVICES;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the hostgroup argument \*/
- else if (!strcmp(key, "hostgroup")) {
+ else if (!strcmp(key, "hostgroup") && value != NULL) {
display\_type = DISPLAY\_HOSTGROUPS;
- if (value == NULL) {
- error = TRUE;
- break;
- }
+
if ((hostgroup\_name = strdup(value)) == NULL)
hostgroup\_name = "";
strip\_html\_brackets(hostgroup\_name);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the servicegroup argument \*/
- else if (!strcmp(key, "servicegroup")) {
+ else if (!strcmp(key, "servicegroup") && value != NULL) {
display\_type = DISPLAY\_SERVICEGROUPS;
- if (value == NULL) {
- error = TRUE;
- break;
- }
+
if ((servicegroup\_name = strdup(value)) == NULL)
servicegroup\_name = "";
strip\_html\_brackets(servicegroup\_name);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the history type argument \*/
- else if (!strcmp(key, "type")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "type") && value != NULL) {
history\_options = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the history state type argument \*/
- else if (!strcmp(key, "statetype")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "statetype") && value != NULL) {
state\_options = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found first time argument \*/
- else if (!strcmp(key, "ts\_start")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "ts\_start") && value != NULL) {
ts\_start = (time\_t)strtoul(value, NULL, 10);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found last time argument \*/
- else if (!strcmp(key, "ts\_end")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "ts\_end") && value != NULL) {
ts\_end = (time\_t)strtoul(value, NULL, 10);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the order argument \*/
- else if (!strcmp(key, "order")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "order") && value != NULL) {
if (!strcmp(value, "new2old"))
reverse = FALSE;
else if (!strcmp(value, "old2new"))
reverse = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the embed option \*/
- else if (!strcmp(key, "embedded"))
+ else if (!strcmp(key, "embedded")) {
embedded = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the noheader option \*/
- else if (!strcmp(key, "noheader"))
+ else if (!strcmp(key, "noheader")) {
display\_header = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the nodaemoncheck option \*/
- else if (!strcmp(key, "nodaemoncheck"))
+ else if (!strcmp(key, "nodaemoncheck")) {
daemon\_check = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the nofrills option \*/
- else if (!strcmp(key, "nofrills"))
+ else if (!strcmp(key, "nofrills")) {
display\_frills = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the notimebreaks option \*/
- else if (!strcmp(key, "notimebreaks"))
+ else if (!strcmp(key, "notimebreaks")) {
display\_timebreaks = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the no system messages option \*/
- else if (!strcmp(key, "nosystem"))
+ else if (!strcmp(key, "nosystem")) {
display\_system\_messages = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the no flapping alerts option \*/
- else if (!strcmp(key, "noflapping"))
+ else if (!strcmp(key, "noflapping")) {
display\_flapping\_alerts = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the no downtime alerts option \*/
- else if (!strcmp(key, "nodowntime"))
+ else if (!strcmp(key, "nodowntime")) {
display\_downtime\_alerts = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* start num results to skip on displaying statusdata \*/
- else if (!strcmp(key, "start")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "start") && value != NULL) {
result\_start = atoi(value);
if (result\_start < 1)
result\_start = 1;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* amount of results to display \*/
- else if (!strcmp(key, "limit")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "limit") && value != NULL) {
get\_result\_limit = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
}
- /\* free memory allocated to the CGI variables \*/
- free\_cgivars(variables);
-
- return error;
+ return;
}
void show\_history(void) {
diff --git a/cgi/notifications.c b/cgi/notifications.c
index 948d4de..2623a20 100644
--- a/cgi/notifications.c
+++ b/cgi/notifications.c
@@ -75,6 +75,8 @@ time\_t ts\_end = 0L; /\*\*< end time as unix timestamp \*/
authdata current\_authdata; /\*\*< struct to hold current authentication data \*/
+html\_request \*html\_request\_list = NULL; /\*\*< contains html requested data \*/
+
int CGI\_ID = NOTIFICATIONS\_CGI\_ID; /\*\*< ID to identify the cgi for functions in cgiutils.c \*/
/\*\* @} \*/
@@ -86,13 +88,10 @@ int CGI\_ID = NOTIFICATIONS\_CGI\_ID; /\*\*< ID to identify the cgi for functions in
void display\_notifications(void);
/\*\* @brief Parses the requested GET/POST variables
- \* @return wether parsing was successful or not
- \* @retval TRUE
- \* @retval FALSE
\*
\* @n This function parses the request and set's the necessary variables
\*\*/
-int process\_cgivars(void);
+void process\_cgivars(void);
/\*\* @brief Yes we need a main function \*\*/
int main(void) {
@@ -111,6 +110,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(get\_cgi\_config\_location(), ERROR\_CGI\_CFG\_FILE, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -120,6 +120,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(main\_config\_file, ERROR\_CGI\_MAIN\_CFG, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -129,6 +130,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_OBJECT\_DATA, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -348,43 +350,27 @@ int main(void) {
document\_footer(CGI\_ID);
/\* free allocated memory \*/
+ free\_html\_request(html\_request\_list);
free\_memory();
return OK;
}
-int process\_cgivars(void) {
- char \*\*variables;
+void process\_cgivars(void) {
char \*key = NULL;
char \*value = NULL;
- int error = FALSE;
- int x;
+ html\_request \*temp\_request\_item = NULL;
- variables = getcgivars();
+ html\_request\_list = getcgivars();
- for (x = 0; variables[x] != NULL; x+=2) {
- key = variables[x];
- value = variables[x+1];
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
- /\* do some basic length checking on the variable identifier to prevent buffer overflows \*/
- if (strlen(key) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
- /\* likewise, check the value if it exists \*/
- if (value != NULL)
- if (strlen(value) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
+ key = temp\_request\_item->option;
+ value = temp\_request\_item->value;
/\* we found the host argument \*/
- if (!strcmp(key, "host")) {
+ if (!strcmp(key, "host") && value != NULL) {
query\_type = DISPLAY\_HOSTS;
- if (value == NULL) {
- error = TRUE;
- break;
- }
if ((query\_host\_name = strdup(value)) == NULL)
query\_host\_name = "";
@@ -394,15 +380,13 @@ int process\_cgivars(void) {
find\_all = TRUE;
else
find\_all = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the contact argument \*/
- else if (!strcmp(key, "contact")) {
+ else if (!strcmp(key, "contact") && value != NULL) {
query\_type = DISPLAY\_CONTACTS;
- if (value == NULL) {
- error = TRUE;
- break;
- }
if ((query\_contact\_name = strdup(value)) == NULL)
query\_contact\_name = "";
@@ -412,108 +396,89 @@ int process\_cgivars(void) {
find\_all = TRUE;
else
find\_all = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the service argument \*/
- else if (!strcmp(key, "service")) {
+ else if (!strcmp(key, "service") && value != NULL) {
query\_type = DISPLAY\_SERVICES;
- if (value == NULL) {
- error = TRUE;
- break;
- }
+
if ((query\_svc\_description = strdup(value)) == NULL)
query\_svc\_description = "";
strip\_html\_brackets(query\_svc\_description);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the hostgroup argument \*/
- else if (!strcmp(key, "hostgroup")) {
+ else if (!strcmp(key, "hostgroup") && value != NULL) {
query\_type = DISPLAY\_HOSTGROUPS;
- if (value == NULL) {
- error = TRUE;
- break;
- }
+
if ((query\_hostgroup\_name = strdup(value)) == NULL)
query\_hostgroup\_name = "";
strip\_html\_brackets(query\_hostgroup\_name);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the servicegroup argument \*/
- else if (!strcmp(key, "servicegroup")) {
+ else if (!strcmp(key, "servicegroup") && value != NULL) {
query\_type = DISPLAY\_SERVICEGROUPS;
- if (value == NULL) {
- error = TRUE;
- break;
- }
+
if ((query\_servicegroup\_name = strdup(value)) == NULL)
query\_servicegroup\_name = "";
strip\_html\_brackets(query\_servicegroup\_name);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the notification type argument \*/
- else if (!strcmp(key, "type")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "type") && value != NULL) {
notification\_options = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found first time argument \*/
- else if (!strcmp(key, "ts\_start")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "ts\_start") && value != NULL) {
ts\_start = (time\_t)strtoul(value, NULL, 10);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found last time argument \*/
- else if (!strcmp(key, "ts\_end")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "ts\_end") && value != NULL) {
ts\_end = (time\_t)strtoul(value, NULL, 10);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the start time \*/
- else if (!strcmp(key, "start\_time")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "start\_time") && value != NULL) {
- start\_time\_string = (char \*)malloc(strlen(value) + 1);
- if (start\_time\_string == NULL)
+ if ((start\_time\_string = (char \*)strdup(value)) == NULL) {
start\_time\_string = "";
- else
- strcpy(start\_time\_string, value);
+ }
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the end time \*/
- else if (!strcmp(key, "end\_time")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "end\_time") && value != NULL) {
- end\_time\_string = (char \*)malloc(strlen(value) + 1);
- if (end\_time\_string == NULL)
+ if ((end\_time\_string = (char \*)strdup(value)) == NULL) {
end\_time\_string = "";
- else
- strcpy(end\_time\_string, value);
+ }
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the standard timeperiod argument \*/
- else if (!strcmp(key, "timeperiod")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "timeperiod") && value != NULL) {
if (!strcmp(value, "today"))
timeperiod\_type = TIMEPERIOD\_TODAY;
@@ -543,66 +508,76 @@ int process\_cgivars(void) {
continue;
convert\_timeperiod\_to\_times(timeperiod\_type, &ts\_start, &ts\_end);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the order argument \*/
- else if (!strcmp(key, "order")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "order") && value != NULL) {
if (!strcmp(value, "new2old"))
reverse = FALSE;
else if (!strcmp(value, "old2new"))
reverse = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the CSV output option \*/
else if (!strcmp(key, "csvoutput")) {
display\_header = FALSE;
content\_type = CSV\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the JSON output option \*/
else if (!strcmp(key, "jsonoutput")) {
display\_header = FALSE;
content\_type = JSON\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the embed option \*/
- else if (!strcmp(key, "embedded"))
+ else if (!strcmp(key, "embedded")) {
embedded = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the noheader option \*/
- else if (!strcmp(key, "noheader"))
+ else if (!strcmp(key, "noheader")) {
display\_header = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the nodaemoncheck option \*/
- else if (!strcmp(key, "nodaemoncheck"))
+ else if (!strcmp(key, "nodaemoncheck")) {
daemon\_check = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* start num results to skip on displaying statusdata \*/
- else if (!strcmp(key, "start")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "start") && value != NULL) {
result\_start = atoi(value);
if (result\_start < 1)
result\_start = 1;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* amount of results to display \*/
- else if (!strcmp(key, "limit")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "limit") && value != NULL) {
get\_result\_limit = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
}
@@ -622,10 +597,7 @@ int process\_cgivars(void) {
find\_all = TRUE;
}
- /\* free memory allocated to the CGI variables \*/
- free\_cgivars(variables);
-
- return error;
+ return;
}
void display\_notifications(void) {
diff --git a/cgi/outages.c b/cgi/outages.c
index 355df31..e1aa667 100644
--- a/cgi/outages.c
+++ b/cgi/outages.c
@@ -71,7 +71,7 @@ typedef struct hostoutagesort\_struct {
struct hostoutagesort\_struct \*next;
} hostoutagesort;
-int process\_cgivars(void);
+void process\_cgivars(void);
void display\_network\_outages(void);
void find\_hosts\_causing\_outages(void);
@@ -88,6 +88,8 @@ void add\_affected\_host(char \*);
authdata current\_authdata;
+html\_request \*html\_request\_list = NULL; /\*\*< contains html requested data \*/
+
hostoutage \*hostoutage\_list = NULL;
hostoutagesort \*hostoutagesort\_list = NULL;
hostoutage \*currently\_checked\_host = NULL;
@@ -120,6 +122,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(get\_cgi\_config\_location(), ERROR\_CGI\_CFG\_FILE, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -129,6 +132,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(main\_config\_file, ERROR\_CGI\_MAIN\_CFG, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -138,6 +142,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_OBJECT\_DATA, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -147,6 +152,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_STATUS\_DATA, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
free\_memory();
return ERROR;
}
@@ -191,80 +197,80 @@ int main(void) {
free\_comment\_data();
/\* free all allocated memory \*/
+ free\_html\_request(html\_request\_list);
free\_memory();
return OK;
}
-int process\_cgivars(void) {
- char \*\*variables;
+void process\_cgivars(void) {
char \*key = NULL;
char \*value = NULL;
- int error = FALSE;
- int x;
+ html\_request \*temp\_request\_item = NULL;
- variables = getcgivars();
+ html\_request\_list = getcgivars();
- for (x = 0; variables[x] != NULL; x+=2) {
- key = variables[x];
- value = variables[x+1];
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
- /\* do some basic length checking on the variable identifier to prevent buffer overflows \*/
- if (strlen(key) >= MAX\_INPUT\_BUFFER - 1) {
- error = 1;
- break;
- }
- if (value != NULL)
- if (strlen(value) >= MAX\_INPUT\_BUFFER - 1) {
- error = 1;
- break;
- }
+ key = temp\_request\_item->option;
+ value = temp\_request\_item->value;
/\* we found the service severity divisor option \*/
- if (!strcmp(key, "service\_divisor")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ if (!strcmp(key, "service\_divisor") && value != NULL) {
service\_severity\_divisor = atoi(value);
if (service\_severity\_divisor < 1)
service\_severity\_divisor = 1;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the CSV output option \*/
else if (!strcmp(key, "csvoutput")) {
display\_header = FALSE;
content\_type = CSV\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
else if (!strcmp(key, "jsonoutput")) {
display\_header = FALSE;
content\_type = JSON\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the embed option \*/
- else if (!strcmp(key, "embedded"))
+ else if (!strcmp(key, "embedded")) {
embedded = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the noheader option \*/
- else if (!strcmp(key, "noheader"))
+ else if (!strcmp(key, "noheader")) {
display\_header = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the pause option \*/
- else if (!strcmp(key, "paused"))
+ else if (!strcmp(key, "paused")) {
refresh = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the nodaemoncheck option \*/
- else if (!strcmp(key, "nodaemoncheck"))
+ else if (!strcmp(key, "nodaemoncheck")) {
daemon\_check = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
}
- /\* free memory allocated to the CGI variables \*/
- free\_cgivars(variables);
-
- return error;
+ return;
}
/\* shows all hosts that are causing network outages \*/
diff --git a/cgi/showlog.c b/cgi/showlog.c
index b5312b4..063cc96 100644
--- a/cgi/showlog.c
+++ b/cgi/showlog.c
@@ -85,17 +85,16 @@ time\_t ts\_end = 0L; /\*\*< end time as unix timestamp \*/
authdata current\_authdata; /\*\*< struct to hold current authentication data \*/
+html\_request \*html\_request\_list = NULL; /\*\*< contains html requested data \*/
+
int CGI\_ID = SHOWLOG\_CGI\_ID; /\*\*< ID to identify the cgi for functions in cgiutils.c \*/
/\*\* @} \*/
/\*\* @brief Parses the requested GET/POST variables
- \* @return wether parsing was successful or not
- \* @retval TRUE
- \* @retval FALSE
\*
\* @n This function parses the request and set's the necessary variables
\*\*/
-int process\_cgivars(void);
+void process\_cgivars(void);
/\*\* @brief displays the requested log entries
\*
@@ -126,6 +125,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(get\_cgi\_config\_location(), ERROR\_CGI\_CFG\_FILE, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -135,6 +135,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(main\_config\_file, ERROR\_CGI\_MAIN\_CFG, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -144,6 +145,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_OBJECT\_DATA, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -224,102 +226,73 @@ int main(void) {
/\* free allocated memory \*/
free\_memory();
+ free\_html\_request(html\_request\_list);
return OK;
}
-int process\_cgivars(void) {
- char \*\*variables;
+void process\_cgivars(void) {
char \*key = NULL;
char \*value = NULL;
- int error = FALSE;
- int x;
+ html\_request \*temp\_request\_item = NULL;
- variables = getcgivars();
+ html\_request\_list = getcgivars();
- for (x = 0; variables[x] != NULL; x+=2) {
- key = variables[x];
- value = variables[x+1];
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
- /\* do some basic length checking on the variable identifier to prevent buffer overflows \*/
- if (strlen(key) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
- if (value != NULL)
- if (strlen(value) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
+ key = temp\_request\_item->option;
+ value = temp\_request\_item->value;
/\* found query string \*/
- if (!strcmp(key, "query\_string")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ if (!strcmp(key, "query\_string") && value != NULL) {
query\_string = strdup(value);
strip\_html\_brackets(query\_string);
if (strlen(query\_string) == 0)
my\_free(query\_string);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found first time argument \*/
- else if (!strcmp(key, "ts\_start")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "ts\_start") && value != NULL) {
ts\_start = (time\_t)strtoul(value, NULL, 10);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found last time argument \*/
- else if (!strcmp(key, "ts\_end")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "ts\_end") && value != NULL) {
ts\_end = (time\_t)strtoul(value, NULL, 10);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the start time \*/
- else if (!strcmp(key, "start\_time")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "start\_time") && value != NULL) {
- start\_time\_string = (char \*)malloc(strlen(value) + 1);
- if (start\_time\_string == NULL)
+ if ((start\_time\_string = (char \*)strdup(value)) == NULL) {
start\_time\_string = "";
- else
- strcpy(start\_time\_string, value);
+ }
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the end time \*/
- else if (!strcmp(key, "end\_time")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "end\_time") && value != NULL) {
- end\_time\_string = (char \*)malloc(strlen(value) + 1);
- if (end\_time\_string == NULL)
+ if ((end\_time\_string = (char \*)strdup(value)) == NULL) {
end\_time\_string = "";
- else
- strcpy(end\_time\_string, value);
+ }
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the standard timeperiod argument \*/
- else if (!strcmp(key, "timeperiod")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "timeperiod") && value != NULL) {
if (!strcmp(value, "today"))
timeperiod\_type = TIMEPERIOD\_TODAY;
@@ -349,186 +322,174 @@ int process\_cgivars(void) {
continue;
convert\_timeperiod\_to\_times(timeperiod\_type, &ts\_start, &ts\_end);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the order argument \*/
- else if (!strcmp(key, "order")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "order") && value != NULL) {
if (!strcmp(value, "new2old"))
reverse = FALSE;
else if (!strcmp(value, "old2new"))
reverse = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* show filter \*/
- else if (!strcmp(key, "display\_filter")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "display\_filter") && value != NULL) {
if (!strcmp(value, "true"))
display\_filter = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* notification filter \*/
- else if (!strcmp(key, "noti")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "noti") && value != NULL) {
if (!strcmp(value, "off"))
show\_notifications = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* host status filter \*/
- else if (!strcmp(key, "hst")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "hst") && value != NULL) {
if (!strcmp(value, "off"))
show\_host\_status = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* service status filter \*/
- else if (!strcmp(key, "sst")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "sst") && value != NULL) {
if (!strcmp(value, "off"))
show\_service\_status = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* external commands filter \*/
- else if (!strcmp(key, "cmd")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "cmd") && value != NULL) {
if (!strcmp(value, "off"))
show\_external\_commands = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* system messages filter \*/
- else if (!strcmp(key, "sms")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "sms") && value != NULL) {
if (!strcmp(value, "off"))
show\_system\_messages = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* event handler filter \*/
- else if (!strcmp(key, "evh")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "evh") && value != NULL) {
if (!strcmp(value, "off"))
show\_event\_handler = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* flapping filter \*/
- else if (!strcmp(key, "flp")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "flp") && value != NULL) {
if (!strcmp(value, "off"))
show\_flapping = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* downtime filter \*/
- else if (!strcmp(key, "dwn")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "dwn") && value != NULL) {
if (!strcmp(value, "off"))
show\_downtime = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the CSV output option \*/
else if (!strcmp(key, "csvoutput")) {
display\_header = FALSE;
content\_type = CSV\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the CSV output option \*/
else if (!strcmp(key, "jsonoutput")) {
display\_header = FALSE;
content\_type = JSON\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the embed option \*/
- else if (!strcmp(key, "embedded"))
+ else if (!strcmp(key, "embedded")) {
embedded = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the noheader option \*/
- else if (!strcmp(key, "noheader"))
+ else if (!strcmp(key, "noheader")) {
display\_header = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the nofrills option \*/
- else if (!strcmp(key, "nofrills"))
+ else if (!strcmp(key, "nofrills")) {
display\_frills = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the notimebreaks option \*/
- else if (!strcmp(key, "notimebreaks"))
+ else if (!strcmp(key, "notimebreaks")) {
display\_timebreaks = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the nodaemoncheck option \*/
- else if (!strcmp(key, "nodaemoncheck"))
+ else if (!strcmp(key, "nodaemoncheck")) {
daemon\_check = FALSE;
-
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* start num results to skip on displaying statusdata \*/
- else if (!strcmp(key, "start")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "start") && value != NULL) {
result\_start = atoi(value);
if (result\_start < 1)
result\_start = 1;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* amount of results to display \*/
- else if (!strcmp(key, "limit")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "limit") && value != NULL) {
get\_result\_limit = atoi(value);
- }
-
- /\* we received an invalid argument \*/
- else
- error = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ }
}
- /\* free memory allocated to the CGI variables \*/
- free\_cgivars(variables);
-
- return error;
+ return;
}
void display\_logentries() {
diff --git a/cgi/status.c b/cgi/status.c
index 28ccab4..cd3069a 100644
--- a/cgi/status.c
+++ b/cgi/status.c
@@ -288,6 +288,8 @@ time\_t current\_time; /\*\*< current timestamp (calculated once in main) \*/
authdata current\_authdata; /\*\*< struct to hold current authentication data \*/
+html\_request \*html\_request\_list = NULL; /\*\*< contains html requested data \*/
+
struct namedlist req\_hosts[NUM\_NAMED\_ENTRIES]; /\*\*< initialze list of requested hosts \*/
struct namedlist req\_hostgroups[NUM\_NAMED\_ENTRIES]; /\*\*< initialze list of requested hostgroups \*/
struct namedlist req\_servicegroups[NUM\_NAMED\_ENTRIES]; /\*\*< initialze list of requested servicegroups \*/
@@ -562,13 +564,10 @@ void show\_filters(void);
/\*\* @brief Parses the requested GET/POST variables
- \* @retval TRUE
- \* @retval FALSE
- \* @return wether parsing was successful or not
\*
\* @n This function parses the request and set's the necessary variables
\*\*/
-int process\_cgivars(void);
+void process\_cgivars(void);
/\*\* @brief print's the table header for differnt styles
@@ -633,6 +632,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(get\_cgi\_config\_location(), ERROR\_CGI\_CFG\_FILE, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -642,6 +642,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(main\_config\_file, ERROR\_CGI\_MAIN\_CFG, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -651,6 +652,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_OBJECT\_DATA, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -660,6 +662,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_STATUS\_DATA, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
free\_memory();
return ERROR;
}
@@ -1645,6 +1648,7 @@ int main(void) {
document\_footer(CGI\_ID);
/\* free all allocated memory \*/
+ free\_html\_request(html\_request\_list);
free\_memory();
free\_comment\_data();
@@ -1671,66 +1675,47 @@ int main(void) {
return OK;
}
-int process\_cgivars(void) {
- char \*\*variables;
+void process\_cgivars(void) {
char \*temp\_buffer = NULL;
char \*key = NULL;
char \*value = NULL;
- int error = FALSE;
- int x;
+ html\_request \*temp\_request\_item = NULL;
- variables = getcgivars();
+ html\_request\_list = getcgivars();
- for (x = 0; variables[x] != NULL; x+=2) {
- key = variables[x];
- value = variables[x+1];
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
- /\* do some basic length checking on the variable identifier to prevent buffer overflows \*/
- if (strlen(key) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
- /\* likewise, check the value if it exists (NULL is valid if it does not) \*/
- if (value != NULL)
- if (strlen(value) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
+ key = temp\_request\_item->option;
+ value = temp\_request\_item->value;
/\* we found the search\_string argument \*/
- if (!strcmp(key, "search\_string")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ if (!strcmp(key, "search\_string") && value != NULL) {
group\_style\_type = STYLE\_HOST\_SERVICE\_DETAIL;
search\_string = strdup(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the servicefilter argument \*/
- else if (!strcmp(key, "servicefilter")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "servicefilter") && value != NULL) {
service\_filter = (char \*)strdup(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the navbar search argument \*/
/\* kept for backwards compatibility \*/
- else if (!strcmp(key, "navbarsearch")) {
+ else if (!strcmp(key, "navbarsearch") && value != NULL) {
navbar\_search = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the hostgroup argument \*/
- else if (!strcmp(key, "hostgroup")) {
+ else if (!strcmp(key, "hostgroup") && value != NULL) {
display\_type = DISPLAY\_HOSTGROUPS;
- if (value == NULL) {
- error = TRUE;
- break;
- }
temp\_buffer = (char \*)strdup(value);
strip\_html\_brackets(temp\_buffer);
@@ -1739,15 +1724,13 @@ int process\_cgivars(void) {
req\_hostgroups[num\_req\_hostgroups++].entry = strdup(temp\_buffer);
my\_free(temp\_buffer);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the servicegroup argument \*/
- else if (!strcmp(key, "servicegroup")) {
+ else if (!strcmp(key, "servicegroup") && value != NULL) {
display\_type = DISPLAY\_SERVICEGROUPS;
- if (value == NULL) {
- error = TRUE;
- break;
- }
temp\_buffer = strdup(value);
strip\_html\_brackets(temp\_buffer);
@@ -1756,15 +1739,13 @@ int process\_cgivars(void) {
req\_servicegroups[num\_req\_servicegroups++].entry = strdup(temp\_buffer);
my\_free(temp\_buffer);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the host argument \*/
- else if (!strcmp(key, "host")) {
+ else if (!strcmp(key, "host") && value != NULL) {
display\_type = DISPLAY\_HOSTS;
- if (value == NULL) {
- error = TRUE;
- break;
- }
temp\_buffer = strdup(value);
strip\_html\_brackets(temp\_buffer);
@@ -1773,66 +1754,54 @@ int process\_cgivars(void) {
req\_hosts[num\_req\_hosts++].entry = strdup(temp\_buffer);
my\_free(temp\_buffer);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the columns argument \*/
- else if (!strcmp(key, "columns")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "columns") && value != NULL) {
overview\_columns = atoi(value);
if (overview\_columns <= 0)
overview\_columns = 1;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the service status type argument \*/
- else if (!strcmp(key, "servicestatustypes")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "servicestatustypes") && value != NULL) {
service\_status\_types = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the host status type argument \*/
- else if (!strcmp(key, "hoststatustypes")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "hoststatustypes") && value != NULL) {
host\_status\_types = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the service properties argument \*/
- else if (!strcmp(key, "serviceprops")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "serviceprops") && value != NULL) {
service\_properties = strtoul(value, NULL, 10);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the host properties argument \*/
- else if (!strcmp(key, "hostprops")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "hostprops") && value != NULL) {
host\_properties = strtoul(value, NULL, 10);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the host or service group style argument \*/
- else if (!strcmp(key, "style")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "style") && value != NULL) {
if (!strcmp(value, "overview"))
group\_style\_type = STYLE\_OVERVIEW;
@@ -1848,36 +1817,30 @@ int process\_cgivars(void) {
group\_style\_type = STYLE\_HOST\_SERVICE\_DETAIL;
else
group\_style\_type = STYLE\_SERVICE\_DETAIL;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the sort type argument \*/
- else if (!strcmp(key, "sorttype")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "sorttype") && value != NULL) {
sort\_type = atoi(value);
user\_sorted\_manually = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the sort option argument \*/
- else if (!strcmp(key, "sortoption")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "sortoption") && value != NULL) {
sort\_option = atoi(value);
user\_sorted\_manually = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the sort object argument \*/
- else if (!strcmp(key, "sortobject")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "sortobject") && value != NULL) {
if (!strcmp(value, "hosts"))
sort\_object = HOST\_STATUS;
@@ -1885,30 +1848,45 @@ int process\_cgivars(void) {
sort\_object = SERVICE\_STATUS;
user\_sorted\_manually = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the embed option \*/
- else if (!strcmp(key, "embedded"))
+ else if (!strcmp(key, "embedded")) {
embedded = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the noheader option \*/
- else if (!strcmp(key, "noheader"))
+ else if (!strcmp(key, "noheader")) {
display\_header = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the nostatusheader option \*/
- else if (!strcmp(key, "nostatusheader"))
+ else if (!strcmp(key, "nostatusheader")) {
nostatusheader\_option = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the CSV output option \*/
else if (!strcmp(key, "csvoutput")) {
display\_header = FALSE;
content\_type = CSV\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the JSON output option \*/
else if (!strcmp(key, "jsonoutput")) {
display\_header = FALSE;
content\_type = JSON\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the pause option \*/
@@ -1916,45 +1894,55 @@ int process\_cgivars(void) {
return\_live\_search\_data = TRUE;
display\_header = FALSE;
content\_type = JSON\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the pause option \*/
- else if (!strcmp(key, "paused"))
+ else if (!strcmp(key, "paused")) {
refresh = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the nodaemoncheck option \*/
- else if (!strcmp(key, "nodaemoncheck"))
+ else if (!strcmp(key, "nodaemoncheck")) {
daemon\_check = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the nodaemoncheck option \*/
- else if (!strcmp(key, "allunhandledproblems"))
+ else if (!strcmp(key, "allunhandledproblems")) {
display\_all\_unhandled\_problems = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the nodaemoncheck option \*/
- else if (!strcmp(key, "allproblems"))
+ else if (!strcmp(key, "allproblems")) {
display\_all\_problems = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* start num results to skip on displaying statusdata \*/
- else if (!strcmp(key, "start")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "start") && value != NULL) {
result\_start = atoi(value);
if (result\_start < 1)
result\_start = 1;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* amount of results to display \*/
- else if (!strcmp(key, "limit")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "limit") && value != NULL) {
get\_result\_limit = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
}
@@ -1963,10 +1951,7 @@ int process\_cgivars(void) {
req\_servicegroups[num\_req\_servicegroups].entry = NULL;
req\_hosts[num\_req\_hosts].entry = NULL;
- /\* free memory allocated to the CGI variables \*/
- free\_cgivars(variables);
-
- return error;
+ return;
}
@@ -7153,8 +7138,7 @@ void print\_displayed\_names(int style) {
void status\_page\_num\_selector(int local\_result\_start, int status\_type) {
char link[MAX\_INPUT\_BUFFER] = "";
- char stripped\_query\_string[MAX\_INPUT\_BUFFER] = "";
- char \*temp\_buffer;
+ char temp\_buffer[MAX\_INPUT\_BUFFER] = "";
int total\_pages = 1;
int current\_page = 1;
// int next\_page = 0;
@@ -7162,34 +7146,30 @@ void status\_page\_num\_selector(int local\_result\_start, int status\_type) {
int display\_total = 0;
int display\_from = 0;
int display\_to = 0;
+ html\_request \*temp\_request\_item = NULL;
/\* define base url \*/
- strcat(link, STATUS\_CGI);
+ strncat(link, STATUS\_CGI, sizeof(link));
+ link[sizeof(link) - 1] = '\x0';
- /\* get url options but filter out "limit" and "status" \*/
- if (getenv("QUERY\_STRING") != NULL && strcmp(getenv("QUERY\_STRING"), "")) {
- if(strlen(getenv("QUERY\_STRING")) > MAX\_INPUT\_BUFFER - 1) {
- write\_to\_cgi\_log("status\_page\_num\_selector(): Query string exceeds max length. Returning without displaying page num selector.\n");
- return;
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
+
+ if (temp\_request\_item->is\_valid == FALSE || temp\_request\_item->option == NULL) {
+ continue;
}
- strcpy(stripped\_query\_string, getenv("QUERY\_STRING"));
- strip\_html\_brackets(stripped\_query\_string);
- /\* check if concatenated strings exceed MAX\_INPUT\_BUFFER \*/
- if (strlen(link) + strlen(stripped\_query\_string) + 1 > MAX\_INPUT\_BUFFER - 1) {
- write\_to\_cgi\_log("status\_page\_num\_selector(): Full query string exceeds max length. Returning without displaying page num selector.\n");
- return;
+ /\* filter out "limit" and "start" \*/
+ if (!strcmp(temp\_request\_item->option, "limit") || !strcmp(temp\_request\_item->option, "start")) {
+ continue;
}
- for (temp\_buffer = my\_strtok(stripped\_query\_string, "&"); temp\_buffer != NULL; temp\_buffer = my\_strtok(NULL, "&")) {
- if (strncmp(temp\_buffer, "limit=", 6) != 0 && strncmp(temp\_buffer, "start=", 6) != 0) {
- if (strstr(link, "?"))
- strcat(link, "&");
- else
- strcat(link, "?");
- strcat(link, temp\_buffer);
- }
+ strncpy(temp\_buffer, link, sizeof(temp\_buffer));
+ if (temp\_request\_item->value != NULL) {
+ snprintf(link, sizeof(link) - 1, "%s%s%s=%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&" : "?", url\_encode(temp\_request\_item->option), url\_encode(temp\_request\_item->value));
+ } else {
+ snprintf(link, sizeof(link) - 1, "%s%s%s", temp\_buffer, (strstr(temp\_buffer, "?")) ? "&" : "?", url\_encode(temp\_request\_item->option));
}
+ link[sizeof(link) - 1] = '\x0';
}
/\* calculate pages \*/
diff --git a/cgi/statusmap.c b/cgi/statusmap.c
index 6d9bb7a..8914fa4 100644
--- a/cgi/statusmap.c
+++ b/cgi/statusmap.c
@@ -91,7 +91,7 @@ typedef struct layer\_struct {
struct layer\_struct \*next;
} layer;
-int process\_cgivars(void);
+void process\_cgivars(void);
void display\_page\_header(void);
void display\_map(void);
@@ -142,6 +142,8 @@ char physical\_logo\_images\_path[MAX\_FILENAME\_LENGTH];
authdata current\_authdata;
+html\_request \*html\_request\_list = NULL; /\*\*< contains html requested data \*/
+
extern int content\_type;
gdImagePtr unknown\_logo\_image = NULL;
@@ -256,6 +258,7 @@ int main(int argc, char \*\*argv) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(main\_config\_file, ERROR\_CGI\_MAIN\_CFG, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -265,6 +268,7 @@ int main(int argc, char \*\*argv) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_OBJECT\_DATA, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -274,6 +278,7 @@ int main(int argc, char \*\*argv) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_STATUS\_DATA, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
free\_memory();
return ERROR;
}
@@ -293,43 +298,27 @@ int main(int argc, char \*\*argv) {
document\_footer(CGI\_ID);
/\* free all allocated memory \*/
+ free\_html\_request(html\_request\_list);
free\_memory();
free\_layer\_list();
return OK;
}
-int process\_cgivars(void) {
- char \*\*variables;
+void process\_cgivars(void) {
char \*key = NULL;
char \*value = NULL;
- int error = FALSE;
- int x;
+ html\_request \*temp\_request\_item = NULL;
- variables = getcgivars();
+ html\_request\_list = getcgivars();
- for (x = 0; variables[x] != NULL; x+=2) {
- key = variables[x];
- value = variables[x+1];
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
- /\* do some basic length checking on the variable identifier to prevent buffer overflows \*/
- if (strlen(key) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
- /\* likewise, check the value if it exists \*/
- if (value != NULL)
- if (strlen(value) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
+ key = temp\_request\_item->option;
+ value = temp\_request\_item->value;
/\* we found the host argument \*/
- if (!strcmp(key, "host")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ if (!strcmp(key, "host") && value != NULL) {
if ((host\_name = (char \*)strdup(value)) == NULL)
host\_name = "all";
@@ -340,160 +329,174 @@ int process\_cgivars(void) {
show\_all\_hosts = TRUE;
else
show\_all\_hosts = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the image creation option \*/
else if (!strcmp(key, "createimage")) {
content\_type = IMAGE\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the embed option \*/
- else if (!strcmp(key, "embedded"))
+ else if (!strcmp(key, "embedded")) {
embedded = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the noheader option \*/
- else if (!strcmp(key, "noheader"))
+ else if (!strcmp(key, "noheader")) {
display\_header = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the canvas origin \*/
- else if (!strcmp(key, "canvas\_x")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "canvas\_x") && value != NULL) {
+
canvas\_x = atoi(value);
user\_supplied\_canvas = TRUE;
- } else if (!strcmp(key, "canvas\_y")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+
+ temp\_request\_item->is\_valid = TRUE;
+
+ } else if (!strcmp(key, "canvas\_y") && value != NULL) {
+
canvas\_y = atoi(value);
user\_supplied\_canvas = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the canvas size \*/
- else if (!strcmp(key, "canvas\_width")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "canvas\_width") && value != NULL) {
+
canvas\_width = atoi(value);
user\_supplied\_canvas = TRUE;
- } else if (!strcmp(key, "canvas\_height")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+
+ temp\_request\_item->is\_valid = TRUE;
+
+ } else if (!strcmp(key, "canvas\_height") && value != NULL) {
+
canvas\_height = atoi(value);
user\_supplied\_canvas = TRUE;
- } else if (!strcmp(key, "proximity\_width")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+
+ temp\_request\_item->is\_valid = TRUE;
+
+ } else if (!strcmp(key, "proximity\_width") && value != NULL) {
+
proximity\_width = atoi(value);
if (proximity\_width < 0)
proximity\_width = DEFAULT\_PROXIMITY\_WIDTH;
- } else if (!strcmp(key, "proximity\_height")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+
+ temp\_request\_item->is\_valid = TRUE;
+ } else if (!strcmp(key, "proximity\_height") && value != NULL) {
+
proximity\_height = atoi(value);
if (proximity\_height < 0)
proximity\_height = DEFAULT\_PROXIMITY\_HEIGHT;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the scaling factor \*/
- else if (!strcmp(key, "scaling\_factor")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "scaling\_factor") && value != NULL) {
+
user\_scaling\_factor = strtod(value, NULL);
if (user\_scaling\_factor > 0.0)
user\_supplied\_scaling = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the max image size \*/
- else if (!strcmp(key, "max\_width")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "max\_width") && value != NULL) {
+
max\_image\_width = atoi(value);
- } else if (!strcmp(key, "max\_height")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+
+ temp\_request\_item->is\_valid = TRUE;
+
+ } else if (!strcmp(key, "max\_height") && value != NULL) {
+
max\_image\_height = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the layout method option \*/
- else if (!strcmp(key, "layout")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "layout") && value != NULL) {
+
layout\_method = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the no links argument\*/
- else if (!strcmp(key, "nolinks"))
+ else if (!strcmp(key, "nolinks")) {
use\_links = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the no text argument\*/
- else if (!strcmp(key, "notext"))
+ else if (!strcmp(key, "notext")) {
use\_text = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the no highlights argument\*/
- else if (!strcmp(key, "nohighlights"))
+ else if (!strcmp(key, "nohighlights")) {
use\_highlights = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the no popups argument\*/
- else if (!strcmp(key, "nopopups"))
+ else if (!strcmp(key, "nopopups")) {
display\_popups = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the layer inclusion/exclusion argument \*/
- else if (!strcmp(key, "layermode")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "layermode") && value != NULL) {
if (!strcmp(value, "include"))
exclude\_layers = FALSE;
else
exclude\_layers = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the layer argument \*/
- else if (!strcmp(key, "layer")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "layer") && value != NULL) {
strip\_html\_brackets(value);
add\_layer(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the pause option \*/
- else if (!strcmp(key, "paused"))
+ else if (!strcmp(key, "paused")) {
refresh = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the nodaemoncheck option \*/
- else if (!strcmp(key, "nodaemoncheck"))
+ else if (!strcmp(key, "nodaemoncheck")) {
daemon\_check = FALSE;
-
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
}
- /\* free memory allocated to the CGI variables \*/
- free\_cgivars(variables);
-
- return error;
+ return;
}
diff --git a/cgi/summary.c b/cgi/summary.c
index 2942b62..2b85c02 100644
--- a/cgi/summary.c
+++ b/cgi/summary.c
@@ -110,13 +110,15 @@ void display\_recent\_alerts(void);
void display\_top\_alerts(void);
void display\_alerts(void);
-int process\_cgivars(void);
+void process\_cgivars(void);
archived\_event \*event\_list = NULL;
alert\_producer \*producer\_list = NULL;
authdata current\_authdata;
+html\_request \*html\_request\_list = NULL; /\*\*< contains html requested data \*/
+
time\_t t1;
time\_t t2;
@@ -609,6 +611,7 @@ int main(int argc, char \*\*argv) {
document\_footer(CGI\_ID);
/\* free all other allocated memory \*/
+ free\_html\_request(html\_request\_list);
free\_memory();
free\_event\_list();
free\_producer\_list();
@@ -616,61 +619,40 @@ int main(int argc, char \*\*argv) {
return OK;
}
-int process\_cgivars(void) {
- char \*\*variables;
+void process\_cgivars(void) {
char \*key = NULL;
char \*value = NULL;
- int error = FALSE;
- int x;
+ html\_request \*temp\_request\_item = NULL;
- variables = getcgivars();
+ html\_request\_list = getcgivars();
- for (x = 0; variables[x] != NULL; x+=2) {
- key = variables[x];
- value = variables[x+1];
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
- /\* do some basic length checking on the variable identifier to prevent buffer overflows \*/
- if (strlen(key) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
- /\* likewise, check the value if it exists \*/
- if (value != NULL)
- if (strlen(value) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
+ key = temp\_request\_item->option;
+ value = temp\_request\_item->value;
/\* we found first time argument \*/
- if (!strcmp(key, "t1")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ if (!strcmp(key, "t1") && value != NULL) {
t1 = (time\_t)strtoul(value, NULL, 10);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found first time argument \*/
- else if (!strcmp(key, "t2")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "t2") && value != NULL) {
t2 = (time\_t)strtoul(value, NULL, 10);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the standard timeperiod argument \*/
- else if (!strcmp(key, "timeperiod")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "timeperiod") && value != NULL) {
if (!strcmp(value, "today"))
timeperiod\_type = TIMEPERIOD\_TODAY;
@@ -705,38 +687,49 @@ int process\_cgivars(void) {
convert\_timeperiod\_to\_times(timeperiod\_type, &t1, &t2);
compute\_time\_from\_parts = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the CSV output option \*/
else if (!strcmp(key, "csvoutput")) {
display\_header = FALSE;
content\_type = CSV\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the JSON output option \*/
else if (!strcmp(key, "jsonoutput")) {
display\_header = FALSE;
content\_type = JSON\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the embed option \*/
- else if (!strcmp(key, "embedded"))
+ else if (!strcmp(key, "embedded")) {
embedded = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the noheader option \*/
- else if (!strcmp(key, "noheader"))
+ else if (!strcmp(key, "noheader")) {
display\_header = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the nodaemoncheck option \*/
- else if (!strcmp(key, "nodaemoncheck"))
+ else if (!strcmp(key, "nodaemoncheck")) {
daemon\_check = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found time argument \*/
- else if (!strcmp(key, "smon")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "smon") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -744,14 +737,12 @@ int process\_cgivars(void) {
start\_month = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "sday")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "sday") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -759,14 +750,12 @@ int process\_cgivars(void) {
start\_day = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "syear")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "syear") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -774,14 +763,12 @@ int process\_cgivars(void) {
start\_year = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "smin")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "smin") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -789,14 +776,12 @@ int process\_cgivars(void) {
start\_minute = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "ssec")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "ssec") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -804,14 +789,12 @@ int process\_cgivars(void) {
start\_second = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "shour")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "shour") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -819,15 +802,13 @@ int process\_cgivars(void) {
start\_hour = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "emon")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "emon") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -835,14 +816,12 @@ int process\_cgivars(void) {
end\_month = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "eday")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "eday") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -850,14 +829,12 @@ int process\_cgivars(void) {
end\_day = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "eyear")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "eyear") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -865,14 +842,12 @@ int process\_cgivars(void) {
end\_year = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "emin")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "emin") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -880,14 +855,12 @@ int process\_cgivars(void) {
end\_minute = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "esec")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "esec") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -895,14 +868,12 @@ int process\_cgivars(void) {
end\_second = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "ehour")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "ehour") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -910,95 +881,77 @@ int process\_cgivars(void) {
end\_hour = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the item limit argument \*/
- else if (!strcmp(key, "limit")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "limit") && value != NULL) {
item\_limit = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the state types argument \*/
- else if (!strcmp(key, "statetypes")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "statetypes") && value != NULL) {
state\_types = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the alert types argument \*/
- else if (!strcmp(key, "alerttypes")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "alerttypes") && value != NULL) {
alert\_types = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the host states argument \*/
- else if (!strcmp(key, "hoststates")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "hoststates") && value != NULL) {
host\_states = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the service states argument \*/
- else if (!strcmp(key, "servicestates")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "servicestates") && value != NULL) {
service\_states = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the generate report argument \*/
- else if (!strcmp(key, "report")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "report") && value != NULL) {
generate\_report = (atoi(value) > 0) ? TRUE : FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the display type argument \*/
- else if (!strcmp(key, "displaytype")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "displaytype") && value != NULL) {
display\_type = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the standard report argument \*/
- else if (!strcmp(key, "standardreport")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "standardreport") && value != NULL) {
standard\_report = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the hostgroup argument \*/
- else if (!strcmp(key, "hostgroup")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "hostgroup") && value != NULL) {
if ((target\_hostgroup\_name = (char \*)strdup(value)) == NULL)
target\_hostgroup\_name = "";
@@ -1010,14 +963,12 @@ int process\_cgivars(void) {
show\_all\_hostgroups = FALSE;
target\_hostgroup = find\_hostgroup(target\_hostgroup\_name);
}
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the servicegroup argument \*/
- else if (!strcmp(key, "servicegroup")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "servicegroup") && value != NULL) {
if ((target\_servicegroup\_name = (char \*)strdup(value)) == NULL)
target\_servicegroup\_name = "";
@@ -1029,14 +980,12 @@ int process\_cgivars(void) {
show\_all\_servicegroups = FALSE;
target\_servicegroup = find\_servicegroup(target\_servicegroup\_name);
}
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the host argument \*/
- else if (!strcmp(key, "host")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "host") && value != NULL) {
if ((target\_host\_name = (char \*)strdup(value)) == NULL)
target\_host\_name = "";
@@ -1048,13 +997,12 @@ int process\_cgivars(void) {
show\_all\_hosts = FALSE;
target\_host = find\_host(target\_host\_name);
}
+
+ temp\_request\_item->is\_valid = TRUE;
}
}
- /\* free memory allocated to the CGI variables \*/
- free\_cgivars(variables);
-
- return error;
+ return;
}
/\* reads log files for archived event data \*/
diff --git a/cgi/tac.c b/cgi/tac.c
index c1473ee..243b840 100644
--- a/cgi/tac.c
+++ b/cgi/tac.c
@@ -97,6 +97,9 @@ typedef struct hostoutage\_struct {
hostoutage \*hostoutage\_list = NULL; /\*\*< list of all host outage elements \*/
authdata current\_authdata; /\*\*< struct to hold current authentication data \*/
+
+html\_request \*html\_request\_list = NULL; /\*\*< contains html requested data \*/
+
int CGI\_ID = TAC\_CGI\_ID; /\*\*< ID to identify the cgi for functions in cgiutils.c \*/
/\*\* @name outages counters
@@ -345,13 +348,10 @@ int services\_critical\_disabled\_unacknowledged\_host\_down = 0;
/\*\* @brief Parses the requested GET/POST variables
- \* @retval TRUE
- \* @retval FALSE
- \* @return wether parsing was successful or not
\*
\* @n This function parses the request and set's the necessary variables
\*\*/
-int process\_cgivars(void);
+void process\_cgivars(void);
/\*\* @brief fills all the counters
@@ -432,6 +432,7 @@ int main(void) {
if (result == ERROR) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(get\_cgi\_config\_location(), ERROR\_CGI\_CFG\_FILE, tac\_header);
+ free\_html\_request(html\_request\_list);
document\_footer(CGI\_ID);
return ERROR;
}
@@ -446,6 +447,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(main\_config\_file, ERROR\_CGI\_MAIN\_CFG, tac\_header);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -459,6 +461,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_OBJECT\_DATA, tac\_header);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -472,6 +475,7 @@ int main(void) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_STATUS\_DATA, tac\_header);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
free\_memory();
return ERROR;
}
@@ -540,6 +544,7 @@ int main(void) {
free\_hostoutage\_list();
/\* free allocated memory \*/
+ free\_html\_request(html\_request\_list);
free\_memory();
#ifdef DEBUG
@@ -557,69 +562,61 @@ int main(void) {
return OK;
}
-int process\_cgivars(void) {
- char \*\*variables;
+void process\_cgivars(void) {
char \*key = NULL;
- char \*value = NULL;
- int error = FALSE;
- int x;
-
- variables = getcgivars();
-
- for (x = 0; variables[x] != NULL; x+=2) {
- key = variables[x];
- value = variables[x+1];
-
- /\* do some basic length checking on the variable identifier to prevent buffer overflows \*/
- if (strlen(key) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
- /\* likewise, check the value if it exists \*/
- if (value != NULL) {
- if (strlen(value) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
- }
+ html\_request \*temp\_request\_item = NULL;
+ html\_request\_list = getcgivars();
+
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
+
+ key = temp\_request\_item->option;
/\* we found the embed option \*/
- if (!strcmp(key, "embedded"))
+ if (!strcmp(key, "embedded")) {
embedded = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the noheader option \*/
- else if (!strcmp(key, "noheader"))
+ else if (!strcmp(key, "noheader")) {
display\_header = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the pause option \*/
- else if (!strcmp(key, "paused"))
+ else if (!strcmp(key, "paused")) {
refresh = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the nodaemoncheck option \*/
- else if (!strcmp(key, "nodaemoncheck"))
+ else if (!strcmp(key, "nodaemoncheck")) {
daemon\_check = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the tac\_header option \*/
- else if (!strcmp(key, "tac\_header"))
+ else if (!strcmp(key, "tac\_header")) {
tac\_header = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
/\* we found the JSON output option \*/
else if (!strcmp(key, "jsonoutput")) {
display\_header = FALSE;
content\_type = JSON\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
-
- /\* we received an invalid argument \*/
- else
- error = TRUE;
-
}
- /\* free memory allocated to the CGI variables \*/
- free\_cgivars(variables);
-
- return error;
+ return;
}
void analyze\_status\_data(void) {
diff --git a/cgi/trends.c b/cgi/trends.c
index 5ef5983..a65e52b 100644
--- a/cgi/trends.c
+++ b/cgi/trends.c
@@ -86,6 +86,8 @@ extern skiplist \*object\_skiplists[NUM\_OBJECT\_SKIPLISTS];
authdata current\_authdata;
+html\_request \*html\_request\_list = NULL; /\*\*< contains html requested data \*/
+
typedef struct archived\_state\_struct {
time\_t time\_stamp;
int entry\_type;
@@ -151,7 +153,7 @@ void scan\_log\_file\_for\_archived\_state\_data\_old(char \*);
void compute\_report\_times(void);
void get\_time\_breakdown\_string(unsigned long, unsigned long, char \*, char \*buffer, int);
-int process\_cgivars(void);
+void process\_cgivars(void);
gdImagePtr trends\_image = 0;
int color\_white = 0;
@@ -305,6 +307,7 @@ int main(int argc, char \*\*argv) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_OBJECT\_DATA, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
}
return ERROR;
}
@@ -316,6 +319,7 @@ int main(int argc, char \*\*argv) {
document\_header(CGI\_ID, FALSE, "Error");
print\_error(NULL, ERROR\_CGI\_STATUS\_DATA, FALSE);
document\_footer(CGI\_ID);
+ free\_html\_request(html\_request\_list);
}
return ERROR;
}
@@ -617,6 +621,7 @@ int main(int argc, char \*\*argv) {
document\_footer(CGI\_ID);
free\_memory();
+ free\_html\_request(html\_request\_list);
return ERROR;
}
#endif
@@ -626,6 +631,7 @@ int main(int argc, char \*\*argv) {
document\_footer(CGI\_ID);
free\_memory();
+ free\_html\_request(html\_request\_list);
return ERROR;
}
@@ -1101,220 +1107,183 @@ int main(int argc, char \*\*argv) {
free\_archived\_state\_list();
/\* free all other allocated memory \*/
+ free\_html\_request(html\_request\_list);
free\_memory();
return OK;
}
-int process\_cgivars(void) {
- char \*\*variables;
+void process\_cgivars(void) {
char \*key = NULL;
char \*value = NULL;
char \*temp\_buffer = NULL;
- int error = FALSE;
- int x;
+ html\_request \*temp\_request\_item = NULL;
- variables = getcgivars();
+ html\_request\_list = getcgivars();
- for (x = 0; variables[x] != NULL; x+=2) {
- key = variables[x];
- value = variables[x+1];
+ for (temp\_request\_item = html\_request\_list; temp\_request\_item != NULL; temp\_request\_item = temp\_request\_item->next) {
- /\* do some basic length checking on the variable identifier to prevent buffer overflows \*/
- if (strlen(key) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
- /\* likewise check the value if it exists \*/
- if (value != NULL)
- if (strlen(value) >= MAX\_INPUT\_BUFFER - 1) {
- error = TRUE;
- break;
- }
+ key = temp\_request\_item->option;
+ value = temp\_request\_item->value;
/\* we found the host argument \*/
- if (!strcmp(key, "host")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ if (!strcmp(key, "host") && value != NULL) {
if ((host\_name = (char \*)strdup(value)) == NULL)
host\_name = "";
strip\_html\_brackets(host\_name);
display\_type = DISPLAY\_HOST\_TRENDS;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the node width argument \*/
- else if (!strcmp(key, "service")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "service") && value != NULL) {
if ((service\_desc = (char \*)strdup(value)) == NULL)
service\_desc = "";
strip\_html\_brackets(service\_desc);
display\_type = DISPLAY\_SERVICE\_TRENDS;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found a combined host/service \*/
- else if (!strcmp(key, "hostservice")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "hostservice") && value != NULL) {
temp\_buffer = strtok(value, "^");
- if ((host\_name = (char \*)strdup(temp\_buffer)) == NULL)
- host\_name = "";
- else
+ if ((host\_name = (char \*)strdup(temp\_buffer)) == NULL) {
+ continue;
+ } else {
strip\_html\_brackets(host\_name);
+ }
temp\_buffer = strtok(NULL, "");
- if ((service\_desc = (char \*)strdup(temp\_buffer)) == NULL)
- service\_desc = "";
- else
+ if ((service\_desc = (char \*)strdup(temp\_buffer)) == NULL) {
+ my\_free(host\_name);
+ continue;
+ } else {
strip\_html\_brackets(service\_desc);
+ }
display\_type = DISPLAY\_SERVICE\_TRENDS;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found first time argument \*/
- else if (!strcmp(key, "t1")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "t1") && value != NULL) {
t1 = (time\_t)strtoul(value, NULL, 10);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found first time argument \*/
- else if (!strcmp(key, "t2")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "t2") && value != NULL) {
t2 = (time\_t)strtoul(value, NULL, 10);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the image creation option \*/
else if (!strcmp(key, "createimage")) {
content\_type = IMAGE\_CONTENT;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the assume initial states option \*/
- else if (!strcmp(key, "assumeinitialstates")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "assumeinitialstates") && value != NULL) {
if (!strcmp(value, "yes"))
assume\_initial\_states = TRUE;
else
assume\_initial\_states = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the initial assumed host state option \*/
- else if (!strcmp(key, "initialassumedhoststate")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "initialassumedhoststate") && value != NULL) {
initial\_assumed\_host\_state = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the initial assumed service state option \*/
- else if (!strcmp(key, "initialassumedservicestate")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "initialassumedservicestate") && value != NULL) {
initial\_assumed\_service\_state = atoi(value);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the assume state during program not running option \*/
- else if (!strcmp(key, "assumestatesduringnotrunning")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "assumestatesduringnotrunning") && value != NULL) {
if (!strcmp(value, "yes"))
assume\_states\_during\_notrunning = TRUE;
else
assume\_states\_during\_notrunning = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the assume state retention option \*/
- else if (!strcmp(key, "assumestateretention")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "assumestateretention") && value != NULL) {
if (!strcmp(value, "yes"))
assume\_state\_retention = TRUE;
else
assume\_state\_retention = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the include soft states option \*/
- else if (!strcmp(key, "includesoftstates")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "includesoftstates") && value != NULL) {
if (!strcmp(value, "yes"))
include\_soft\_states = TRUE;
else
include\_soft\_states = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the zoom factor argument \*/
- else if (!strcmp(key, "zoom")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "zoom") && value != NULL) {
zoom\_factor = atoi(value);
if (zoom\_factor == 0)
zoom\_factor = 1;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the backtrack archives argument \*/
- else if (!strcmp(key, "backtrack")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "backtrack") && value != NULL) {
backtrack\_archives = atoi(value);
if (backtrack\_archives < 0)
backtrack\_archives = 0;
if (backtrack\_archives > MAX\_ARCHIVE\_BACKTRACKS)
backtrack\_archives = MAX\_ARCHIVE\_BACKTRACKS;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the standard timeperiod argument \*/
- else if (!strcmp(key, "timeperiod")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "timeperiod") && value != NULL) {
if (!strcmp(value, "today"))
timeperiod\_type = TIMEPERIOD\_TODAY;
@@ -1350,14 +1319,12 @@ int process\_cgivars(void) {
continue;
convert\_timeperiod\_to\_times(timeperiod\_type, &t1, &t2);
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "smon")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "smon") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1365,14 +1332,12 @@ int process\_cgivars(void) {
start\_month = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "sday")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "sday") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1380,14 +1345,12 @@ int process\_cgivars(void) {
start\_day = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "syear")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "syear") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1395,14 +1358,12 @@ int process\_cgivars(void) {
start\_year = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "smin")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "smin") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1410,14 +1371,12 @@ int process\_cgivars(void) {
start\_minute = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "ssec")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "ssec") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1425,14 +1384,12 @@ int process\_cgivars(void) {
start\_second = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "shour")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "shour") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1440,15 +1397,13 @@ int process\_cgivars(void) {
start\_hour = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "emon")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "emon") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1456,14 +1411,12 @@ int process\_cgivars(void) {
end\_month = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "eday")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "eday") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1471,14 +1424,12 @@ int process\_cgivars(void) {
end\_day = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "eyear")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "eyear") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1486,14 +1437,12 @@ int process\_cgivars(void) {
end\_year = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "emin")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "emin") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1501,14 +1450,12 @@ int process\_cgivars(void) {
end\_minute = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "esec")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "esec") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1516,14 +1463,12 @@ int process\_cgivars(void) {
end\_second = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found time argument \*/
- else if (!strcmp(key, "ehour")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "ehour") && value != NULL) {
if (timeperiod\_type != TIMEPERIOD\_CUSTOM)
continue;
@@ -1531,32 +1476,45 @@ int process\_cgivars(void) {
end\_hour = atoi(value);
timeperiod\_type = TIMEPERIOD\_CUSTOM;
compute\_time\_from\_parts = TRUE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the embed option \*/
- else if (!strcmp(key, "embedded"))
+ else if (!strcmp(key, "embedded")) {
embedded = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
+
/\* we found the noheader option \*/
- else if (!strcmp(key, "noheader"))
+ else if (!strcmp(key, "noheader")) {
display\_header = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
+
/\* we found the nopopups option \*/
- else if (!strcmp(key, "nopopups"))
+ else if (!strcmp(key, "nopopups")) {
display\_popups = FALSE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
+
/\* we found the nomap option \*/
else if (!strcmp(key, "nomap")) {
display\_popups = FALSE;
use\_map = FALSE;
+
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
}
/\* we found the input option \*/
- else if (!strcmp(key, "input")) {
- if (value == NULL) {
- error = TRUE;
- break;
- }
+ else if (!strcmp(key, "input") && value != NULL) {
if (!strcmp(value, "gethost"))
input\_type = GET\_INPUT\_HOST\_TARGET;
@@ -1566,25 +1524,36 @@ int process\_cgivars(void) {
input\_type = GET\_INPUT\_OPTIONS;
else
input\_type = GET\_INPUT\_TARGET\_TYPE;
+
+ temp\_request\_item->is\_valid = TRUE;
}
/\* we found the small image option \*/
- else if (!strcmp(key, "smallimage"))
+ else if (!strcmp(key, "smallimage")) {
small\_image = TRUE;
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
+
/\* we found the nodaemoncheck option \*/
- else if (!strcmp(key, "nodaemoncheck"))
+ else if (!strcmp(key, "nodaemoncheck")) {
daemon\_check = FALSE;
- else if (!strcmp(key, "ignorerestart"))
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
+
+ else if (!strcmp(key, "ignorerestart")) {
ignore\_daemon\_restart = TRUE;
- }
+ temp\_request\_item->is\_valid = TRUE;
+ my\_free(temp\_request\_item->value);
+ }
- /\* free memory allocated to the CGI variables \*/
- free\_cgivars(variables);
+ }
- return error;
+ return;
}
diff --git a/include/getcgi.h b/include/getcgi.h
index 0e748f2..4d1186b 100644
--- a/include/getcgi.h
+++ b/include/getcgi.h
@@ -22,12 +22,25 @@
\*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
+#include "../include/cgiutils.h"
+
#ifdef \_\_cplusplus
extern "C" {
#endif
-char \*\*getcgivars(void);
-void free\_cgivars(char \*\*);
+/\*\* @brief html request struct
+ \*
+ \* structure to hold html reqest data to prevent XSS attacks
+\*\*/
+typedef struct html\_request\_struct {
+ char \*option; /\*\*< pointer to option string \*/
+ char \*value; /\*\*< pointer to value string \*/
+ int is\_valid; /\*\*< bool to mark if this request is valid \*/
+ struct html\_request\_struct \*next; /\*\*< next html\_request entry \*/
+} html\_request;
+
+html\_request \*getcgivars(void);
+void free\_html\_request(html\_request \*);
void unescape\_cgi\_input(char \*);
void sanitize\_cgi\_input(char \*\*);
unsigned char hex\_to\_char(char \*);
--
2.6.1


=== Content from lists.opensuse.org_e40c0af8_20250125_110217.html ===


[![openSUSE](https://static.opensuse.org/favicon.svg)
Mailing Lists](/archives/ "openSUSE Mailing Lists")

[Sign In](/accounts/login/?next=/archives/list/security-announce%40lists.opensuse.org/message/3Q6N4F4EAYSJ6FNMJTKIZZZLPGW4MV2P/)
[Sign Up](/accounts/signup/?next=/archives/list/security-announce%40lists.opensuse.org/message/3Q6N4F4EAYSJ6FNMJTKIZZZLPGW4MV2P/)

[Manage this list](/manage/lists/security-announce.lists.opensuse.org/)
[Sign In](/accounts/login/?next=/archives/list/security-announce%40lists.opensuse.org/message/3Q6N4F4EAYSJ6FNMJTKIZZZLPGW4MV2P/)
[Sign Up](/accounts/signup/?next=/archives/list/security-announce%40lists.opensuse.org/message/3Q6N4F4EAYSJ6FNMJTKIZZZLPGW4MV2P/)

×
#### Keyboard Shortcuts

### Thread View

* `j`: Next unread message
* `k`: Previous unread message
* `j a`: Jump to all threads* `j l`: Jump to MailingList overview

[thread](/archives/list/security-announce%40lists.opensuse.org/thread/3Q6N4F4EAYSJ6FNMJTKIZZZLPGW4MV2P/#3Q6N4F4EAYSJ6FNMJTKIZZZLPGW4MV2P)

# [security-announce] openSUSE-SU-2017:0146-1: important: Security update for icinga

![](https://seccdn.libravatar.org/avatar/099a17325bdf082b643d1a6bbacde279.jpg?s=120&d=mm&r=g)
## [opensuse-security＠opensuse.org](/archives/users/1b72def497ef4503896cd7a5fe9fb8e0/ "See the profile for opensuse-security＠opensuse.org")

16 Jan
2017

16 Jan
'17

18:14

openSUSE Security Update: Security update for icinga
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
Announcement ID: openSUSE-SU-2017:0146-1
Rating: important
References: #1014637 #952777
Cross-References: CVE-2015-8010 CVE-2016-9566
Affected Products:
openSUSE Leap 42.2
openSUSE Leap 42.1
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
An update that fixes two vulnerabilities is now available.
Description:
This update for icinga includes various upstream fixes and the following
security security fixes:
- icinga was updated to version 1.14.0
- the classic-UI was vulnerable to a cross site scripting attack
(CVE-2015-8010, boo#952777)
- A user with nagios privileges could have gained root privileges by
placing a symbolic link at the logfile location (CVE-2016-9566,
boo#1014637)
Patch Instructions:
To install this openSUSE Security Update use YaST online\_update.
Alternatively you can run the command listed for your product:
- openSUSE Leap 42.2:
zypper in -t patch openSUSE-2017-100=1
- openSUSE Leap 42.1:
zypper in -t patch openSUSE-2017-100=1
To bring your system up-to-date, use "zypper patch".
Package List:
- openSUSE Leap 42.2 (x86\_64):
icinga-1.14.0-4.1
icinga-debuginfo-1.14.0-4.1
icinga-debugsource-1.14.0-4.1
icinga-devel-1.14.0-4.1
icinga-doc-1.14.0-4.1
icinga-idoutils-1.14.0-4.1
icinga-idoutils-debuginfo-1.14.0-4.1
icinga-idoutils-mysql-1.14.0-4.1
icinga-idoutils-oracle-1.14.0-4.1
icinga-idoutils-pgsql-1.14.0-4.1
icinga-plugins-downtimes-1.14.0-4.1
icinga-plugins-eventhandlers-1.14.0-4.1
icinga-www-1.14.0-4.1
icinga-www-config-1.14.0-4.1
icinga-www-debuginfo-1.14.0-4.1
monitoring-tools-1.14.0-4.1
monitoring-tools-debuginfo-1.14.0-4.1
- openSUSE Leap 42.1 (i586 x86\_64):
icinga-1.14.0-3.1
icinga-debuginfo-1.14.0-3.1
icinga-debugsource-1.14.0-3.1
icinga-devel-1.14.0-3.1
icinga-doc-1.14.0-3.1
icinga-idoutils-1.14.0-3.1
icinga-idoutils-debuginfo-1.14.0-3.1
icinga-idoutils-mysql-1.14.0-3.1
icinga-idoutils-oracle-1.14.0-3.1
icinga-idoutils-pgsql-1.14.0-3.1
icinga-plugins-downtimes-1.14.0-3.1
icinga-plugins-eventhandlers-1.14.0-3.1
icinga-www-1.14.0-3.1
icinga-www-config-1.14.0-3.1
icinga-www-debuginfo-1.14.0-3.1
monitoring-tools-1.14.0-3.1
monitoring-tools-debuginfo-1.14.0-3.1
References:
<https://www.suse.com/security/cve/CVE-2015-8010.html>
<https://www.suse.com/security/cve/CVE-2016-9566.html>
<https://bugzilla.suse.com/1014637>
<https://bugzilla.suse.com/952777>
--
To unsubscribe, e-mail: opensuse-security-announce+unsubscribe@opensuse.org
For additional commands, e-mail: opensuse-security-announce+help@opensuse.org

[0](#like "You must be logged-in to vote.")
[0](#dislike "You must be logged-in to vote.")

Reply

[Sign in to reply online](/accounts/login/?next=/archives/list/security-announce%40lists.opensuse.org/message/3Q6N4F4EAYSJ6FNMJTKIZZZLPGW4MV2P/)
Use email software

[Back to the thread](/archives/list/security-announce%40lists.opensuse.org/thread/3Q6N4F4EAYSJ6FNMJTKIZZZLPGW4MV2P/#3Q6N4F4EAYSJ6FNMJTKIZZZLPGW4MV2P)

[Back to the list](/archives/list/security-announce%40lists.opensuse.org/)

![HyperKitty](/static/hyperkitty/img/logo.png)
Powered by [HyperKitty](http://hyperkitty.readthedocs.org) version 1.3.12.



=== Content from bugzilla.suse.com_26a0a96b_20250126_080745.html ===


| Bugzilla – Bug 1014637 | VUL-0: CVE-2016-9566: nagios,icinga: Privilege escalation issue | Last modified: 2024-05-14 08:30:06 UTC |
| --- | --- | --- |

|  |
| --- |

* [Home](./)
* | [New](enter_bug.cgi)
* | [Browse](describecomponents.cgi)
* | [Search](query.cgi)
* |

  [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")
* | [Reports](report.cgi)
* |
  [Requests](request.cgi)
* |
  [IDP Log In](/saml2_login.cgi?idp=IDP&target=show_bug.cgi%3Fid%3D1014637)
* |
  [Forgot Password](https://idp-portal.suse.com/univention/self-service/#page=passwordreset)

[**Bug 1014637**](show_bug.cgi?id=1014637)
(CVE-2016-9566)
- VUL-0: CVE-2016-9566: nagios,icinga: Privilege escalation issue

[Summary:](page.cgi?id=glossary.html#short_desc "The bug summary is a short sentence which succinctly describes what the bug is about.")
VUL-0: CVE-2016-9566: nagios,icinga: Privilege escalation issue

| | [Status](page.cgi?id=status_resolution_matrix.html): | RESOLVED FIXED | | --- | --- | |  | | | [Alias:](page.cgi?id=glossary.html#alias "A short, unique name assigned to a bug in order to assist with looking it up and referring to it in other places in Bugzilla.") | CVE-2016-9566 | |  | | | [Product:](describecomponents.cgi "Bugs are categorised into Products and Components. Select a Classification to narrow down this list.") | SUSE Security Incidents | | [Classification:](page.cgi?id=glossary.html#classification "Bugs are categorised into Classifications, Products and Components. classifications is the top-level categorisation.") | Novell Products | | [Component:](describecomponents.cgi?product=SUSE Security Incidents "Components are second-level categories; each belongs to a particular Product. Select a Product to narrow down this list.") | Incidents ([show other bugs](buglist.cgi?component=Incidents&product=SUSE%20Security%20Incidents&bug_status=__open__)) | | [Version:](page.cgi?id=glossary.html#version "The version field defines the version of the software the bug was found in.") | unspecified | | [Hardware:](page.cgi?id=glossary.html#rep_platform "The hardware platform the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | Other Other | |  | | | [Priority](page.cgi?id=glossary.html#priority): | P3 - Medium **Severity**: Major | | [Target Milestone:](page.cgi?id=glossary.html#target_milestone "The Target Milestone field is used to define when the engineer the bug is assigned to expects to fix it.") | --- | | [Assignee:](page.cgi?id=glossary.html#assigned_to "The person in charge of resolving the bug.") | Lars Vogdt | | [QA Contact:](page.cgi?id=glossary.html#qa_contact "The person responsible for confirming this bug if it is unconfirmed, and for verifying the fix once the bug has been resolved.") | Security Team bot | |  | | | [URL:](page.cgi?id=glossary.html#bug_file_loc "Bugs can have a URL associated with them - for example, a pointer to a web site where the problem is seen.") | <https://smash.suse.de/issue/177303/> | | [Whiteboard:](page.cgi?id=glossary.html#status_whiteboard "Each bug has a free-form single line text entry box for adding tags and status information.") | CVSSv2:SUSE:CVE-2016-9566:6.6:(AV:L/... | | [Keywords:](describekeywords.cgi "You can add keywords from a defined list to bugs, in order to easily identify and group them.") |  | |  | | | [Depends on:](page.cgi?id=glossary.html#dependson "The bugs listed here must be resolved before this bug can be resolved.") |  | | [Blocks:](page.cgi?id=glossary.html#blocked "This bug must be resolved before the bugs listed in this field can be resolved.") |  | |  | | Reported: | 2016-12-08 16:27 UTC by Marcus Meissner | | --- | --- | | Modified: | 2024-05-14 08:30 UTC ([History](show_activity.cgi?id=1014637)) | | CC List: | 11 users (show)  abergmann astieger eich krahmer lars.vogdt matthias.gerstner meissner smash\_bz thardeck thomas.leroy vpereira | |  | | | [See Also:](page.cgi?id=glossary.html#see_also "This allows you to refer to bugs in other installations. You can enter a URL to a bug in the 'Add Bug URLs' field to note that that bug is related to this one. You can enter multiple URLs at once by separating them with whitespace. You should normally use this field to refer to bugs in other installations. For bugs in this installation, it is better to use the Depends on and Blocks fields.") |  | | [Found By:](page.cgi?id=glossary.html#cf_foundby "A custom Drop Down field in this installation of Bugzilla.") | Security Response Team | | [Services Priority:](page.cgi?id=glossary.html#cf_nts_priority "A custom Free Text field in this installation of Bugzilla.") |  | | [Business Priority:](page.cgi?id=glossary.html#cf_biz_priority "A custom Free Text field in this installation of Bugzilla.") |  | | [Blocker:](page.cgi?id=glossary.html#cf_blocker "A custom Drop Down field in this installation of Bugzilla.") | --- | | [Marketing QA Status:](page.cgi?id=glossary.html#cf_marketing_qa_status "A custom Drop Down field in this installation of Bugzilla.") | --- | | [IT Deployment:](page.cgi?id=glossary.html#cf_it_deployment "A custom Drop Down field in this installation of Bugzilla.") | --- | |  | |  * [Clone This Bug](enter_bug.cgi?cloned_bug_id=1014637)  | Flags: | lars.vogdt: SHIP\_STOPPER? | |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| --- | | |

| | Attachments | | | --- | --- | | [Add an attachment](attachment.cgi?bugid=1014637&action=enter) (proposed patch, testcase, etc.) | |   | Note You need to [log in](show_bug.cgi?id=1014637&GoAheadAndLogIn=1) before you can comment on or make changes to this bug. | | --- | |  |
| --- | --- | --- | --- | --- | --- | --- |

| [Description](show_bug.cgi?id=1014637#c0)  Marcus Meissner   2016-12-08 16:27:54 UTC  ``` <https://github.com/NagiosEnterprises/nagioscore/commit/c29557dec91eba2306f5fb11b8da4474ba63f8c4>   +* Fixed another root privilege escalation (CVE-2016-9566) Thanks for bringing this   to our attention go to Dawid Golunski (<http://legalhackers.com>).  also <https://bugzilla.redhat.com/show_bug.cgi?id=1402869>   (It is hard to see if debug_file or log_file can be outside of root owned directories... the default should not be there.) ``` [Comment 1](show_bug.cgi?id=1014637#c1)  Swamp Workflow Management   2016-12-08 23:02:16 UTC  ``` bugbot adjusting priority ``` [Comment 2](show_bug.cgi?id=1014637#c2)  Sebastian Krahmer   2017-01-03 10:17:38 UTC  ``` I am contacting upstream about insufficient patch. They do a lot of wrong things when setting up the logfiles. ``` [Comment 3](show_bug.cgi?id=1014637#c3)  Andreas Stieger   2017-01-04 09:51:08 UTC  ``` (In reply to Sebastian Krahmer from [comment #2](show_bug.cgi?id=1014637#c2)) > I am contacting upstream about insufficient patch. > They do a lot of wrong things when setting up the logfiles.  <http://seclists.org/oss-sec/2017/q1/17> ``` [Comment 4](show_bug.cgi?id=1014637#c4)  Andreas Stieger   2017-01-04 09:53:35 UTC  ``` Just noting that threre is a follow-up commit to <https://github.com/NagiosEnterprises/nagioscore/commit/c29557dec91eba2306f5fb11b8da4474ba63f8c4>  "Wrong filename variable used" <https://github.com/NagiosEnterprises/nagioscore/commit/8e6e1cb29f3c1b933b0e13fb937ad5ca8b448ccc>  This does not address Sebastian's concerns, however. ``` [Comment 5](show_bug.cgi?id=1014637#c5)  Matthias Gerstner   2017-01-09 11:48:17 UTC  ``` icinga took over the insufficient patch from Nagios:  <https://github.com/Icinga/icinga-core/commit/a0eb8471673b6b1e9b37e1b7b91151aa00bedb65>  Additionally they now open the debug log after the privilege drop:  <https://github.com/Icinga/icinga-core/commit/e0f55bc9b17ef1db9aed7393fc34576a5b9501f0>  But there are probably still other code paths that write to the log in root context, as they already stated in their changelog:    This bug affects Icinga 1.x only for opening a debug log, or when a config   error gets logged on startup. ``` [Comment 6](show_bug.cgi?id=1014637#c6)  Swamp Workflow Management   2017-01-16 18:15:10 UTC  ``` openSUSE-SU-2017:0146-1: An update that fixes two vulnerabilities is now available.  Category: security (important) Bug References: 1014637,952777 CVE References: CVE-2015-8010,CVE-2016-9566 Sources used: openSUSE Leap 42.2 (src):    icinga-1.14.0-4.1 openSUSE Leap 42.1 (src):    icinga-1.14.0-3.1 ``` [Comment 10](show_bug.cgi?id=1014637#c10)  Victor Pereira   2018-03-19 09:06:48 UTC  ``` Hi, I see that both MR never did it to our products:  Maintenance request 148057 submitted for nagios on SLES-11 (IBS) declined Maintenance request 148058 submitted for nagios on SLES-12 (IBS) declined  looking the changes of both packages, I don't see any update.. could you please resubmit it again? ``` [Comment 14](show_bug.cgi?id=1014637#c14)  Lars Vogdt   2021-05-11 09:24:19 UTC  ``` Fixes submitted for: * openSUSE:Backports:SLE-15-SP1:Update * openSUSE:Backports:SLE-15-SP2:Update * openSUSE:Backports:SLE-15-SP3 * openSUSE:Leap:15.2:Update   This Nagios upgrade sums up multiple security fixes and other important changes.  Security issues fixed in this upgrade: * [bsc#1172794](http://bugzilla.suse.com/show_bug.cgi?id=1172794) / CVE-2020-13977: Fixed postauth vulnerabilities in                 histogram.js, map.js, trends.js * [bsc#989759](http://bugzilla.suse.com/show_bug.cgi?id=989759) / CVE-2016-6209 : The "corewindow" parameter has been                disabled by default * [bsc#1014637](http://bugzilla.suse.com/show_bug.cgi?id=1014637) / CVE-2016-9566 : Fixed another root privilege escalation * [bsc#1182398](http://bugzilla.suse.com/show_bug.cgi?id=1182398) : nagios_upgrade.sh writing to log file in user controlled                 directory  Additional fixes: * [bsc#1003362](http://bugzilla.suse.com/show_bug.cgi?id=1003362) : new nagios-exec-start-post script * Fixed Map display in Internet Explorer 11 * Fixed duplicate properties appearing in statusjson.cgi * Fixed build process when using GCC 10 * Fixed HARD OK states triggering on the maximum check attempt ``` [Comment 15](show_bug.cgi?id=1014637#c15)  OBSbugzilla Bot   2021-05-11 09:50:05 UTC  ``` This is an autogenerated message for OBS integration: This bug (1014637) was mentioned in <https://build.opensuse.org/request/show/892196> Backports:SLE-15-SP1 / nagios <https://build.opensuse.org/request/show/892197> Backports:SLE-15-SP2 / nagios <https://build.opensuse.org/request/show/892198> Backports:SLE-15-SP3 / nagios <https://build.opensuse.org/request/show/892199> 15.2 / nagios ``` [Comment 16](show_bug.cgi?id=1014637#c16)  Swamp Workflow Management   2021-05-12 19:15:32 UTC  ``` openSUSE-SU-2021:0715-1: An update that solves two vulnerabilities and has three fixes is now available.  Category: security (important) Bug References: 1003362,1014637,1172794,1182398,989759 CVE References: CVE-2016-6209,CVE-2020-13977 JIRA References:  Sources used: openSUSE Leap 15.2 (src):    nagios-4.4.6-lp152.2.3.1 ``` [Comment 17](show_bug.cgi?id=1014637#c17)  Swamp Workflow Management   2021-05-16 01:15:40 UTC  ``` openSUSE-SU-2021:0735-1: An update that solves two vulnerabilities and has three fixes is now available.  Category: security (important) Bug References: 1003362,1014637,1172794,1182398,989759 CVE References: CVE-2016-6209,CVE-2020-13977 JIRA References:  Sources used: openSUSE Backports SLE-15-SP2 (src):    nagios-4.4.6-bp152.2.3.1 ``` [Comment 26](show_bug.cgi?id=1014637#c26)  Swamp Workflow Management   2022-10-13 13:20:09 UTC  ``` SUSE-SU-2022:3576-1: An update that fixes two vulnerabilities is now available.  Category: security (important) Bug References: 1014637,1156309 CVE References: CVE-2016-9566,CVE-2019-3698 JIRA References:  Sources used: SUSE Manager Tools 12 (src):    icinga-1.13.3-12.6.1  NOTE: This line indicates an update has been released for the listed product(s). At times this might be only a partial fix. If you have questions please reach out to maintenance coordination. ``` [Comment 27](show_bug.cgi?id=1014637#c27)  Lars Vogdt   2023-03-16 08:23:13 UTC  ``` Looks like the maintenance bot is not working as I expected. Closing here. ``` [Comment 29](show_bug.cgi?id=1014637#c29)  Maintenance Automation   2024-05-14 08:30:06 UTC  ``` SUSE-SU-2024:1629-1: An update that solves two vulnerabilities and contains one feature can now be installed.  Category: security (moderate) Bug References: 1014637, 1156309 CVE References: CVE-2016-9566, CVE-2019-3698 Jira References: MSQA-775 Maintenance Incident: [SUSE:Maintenance:33763](<https://smelt.suse.de/incident/33763/>) Sources used: SUSE Manager Client Tools for SLE 12 (src):  grafana-sap-providers-1.1-1.7.1, grafana-sap-netweaver-dashboards-1.0.3+git.1601889366.9f71957-1.10.1, icinga-1.13.3-12.8.1, grafana-ha-cluster-dashboards-1.1.0+git.1605027022.a84d536-1.10.1, hwdata-0.314-10.14.1, zeromq-4.0.4-15.8.1, sysuser-tools-2.0-1.9.1 SUSE Manager Client Tools Beta for SLE 12 (src):  grafana-sap-providers-1.1-1.7.1, grafana-sap-netweaver-dashboards-1.0.3+git.1601889366.9f71957-1.10.1, icinga-1.13.3-12.8.1, grafana-ha-cluster-dashboards-1.1.0+git.1605027022.a84d536-1.10.1, zeromq-4.0.4-15.8.1, sysuser-tools-2.0-1.9.1 Advanced Systems Management Module 12 (src):  zeromq-4.0.4-15.8.1 Containers Module 12 (src):  sysuser-tools-2.0-1.9.1 SUSE Linux Enterprise Server for SAP Applications 12 SP5 (src):  sysuser-tools-2.0-1.9.1, grafana-sap-netweaver-dashboards-1.0.3+git.1601889366.9f71957-1.10.1, grafana-ha-cluster-dashboards-1.1.0+git.1605027022.a84d536-1.10.1, grafana-sap-providers-1.1-1.7.1 SUSE Linux Enterprise Software Development Kit 12 SP5 (src):  zeromq-4.0.4-15.8.1 SUSE Linux Enterprise High Performance Computing 12 SP5 (src):  sysuser-tools-2.0-1.9.1 SUSE Linux Enterprise Server 12 SP5 (src):  sysuser-tools-2.0-1.9.1 SUSE Linux Enterprise Workstation Extension 12 12-SP5 (src):  zeromq-4.0.4-15.8.1  NOTE: This line indicates an update has been released for the listed product(s). At times this might be only a partial fix. If you have questions please reach out to maintenance coordination. ``` |  |
| --- | --- |

---

* [Format For Printing](show_bug.cgi?format=multiple&id=1014637)
* - [XML](show_bug.cgi?ctype=xml&id=1014637)
* - [Clone This Bug](enter_bug.cgi?cloned_bug_id=1014637)
* - Top of page

* + [Home](./)
  + | [New](enter_bug.cgi)
  + | [Browse](describecomponents.cgi)
  + | [Search](query.cgi)
  + |

    [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")
  + | [Reports](report.cgi)
  + |
    [Requests](request.cgi)
  + |
    [IDP Log In](/saml2_login.cgi?idp=IDP&target=show_bug.cgi%3Fid%3D1014637)
  + |
    [Forgot Password](https://idp-portal.suse.com/univention/self-service/#page=passwordreset)

+ Legal:
+ [openSUSE](http://en.opensuse.org/Terms_of_site)
+ [SUSE](https://www.suse.com/company/legal/)



=== Content from github.com_bbfbcc04_20250125_110219.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FIcinga%2Ficinga-core%2Fissues%2F1563)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FIcinga%2Ficinga-core%2Fissues%2F1563)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fissues_fragments%2Fissue_layout&source=header-repo&source_repo=Icinga%2Ficinga-core)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

This repository has been archived by the owner on Jan 15, 2019. It is now read-only.

[Icinga](/Icinga)
/
**[icinga-core](/Icinga/icinga-core)**
Public archive

* [Notifications](/login?return_to=%2FIcinga%2Ficinga-core) You must be signed in to change notification settings
* [Fork
  28](/login?return_to=%2FIcinga%2Ficinga-core)
* [Star
   44](/login?return_to=%2FIcinga%2Ficinga-core)

* [Code](/Icinga/icinga-core)
* [Issues
  2](/Icinga/icinga-core/issues)
* [Pull requests
  2](/Icinga/icinga-core/pulls)
* [Actions](/Icinga/icinga-core/actions)
* [Security](/Icinga/icinga-core/security)
* [Insights](/Icinga/icinga-core/pulse)

Additional navigation options

* [Code](/Icinga/icinga-core)
* [Issues](/Icinga/icinga-core/issues)
* [Pull requests](/Icinga/icinga-core/pulls)
* [Actions](/Icinga/icinga-core/actions)
* [Security](/Icinga/icinga-core/security)
* [Insights](/Icinga/icinga-core/pulse)

This repository has been archived by the owner on Jan 15, 2019. It is now read-only.

# [dev.icinga.com #10453] Icinga Classic-UI 1.13.3 and older are vulnerable to XSS - CVE-2015-8010 #1563

[Jump to bottom](#comment-composer-heading)Copy link[Jump to bottom](#comment-composer-heading)Copy linkClosedClosed[[dev.icinga.com #10453] Icinga Classic-UI 1.13.3 and older are vulnerable to XSS - CVE-2015-8010](#top)#1563Copy linkLabels[Classic UI](https://github.com/Icinga/icinga-core/issues?q=state%3Aopen%20label%3A%22Classic%20UI%22)[High](https://github.com/Icinga/icinga-core/issues?q=state%3Aopen%20label%3A%22High%22)[bug](https://github.com/Icinga/icinga-core/issues?q=state%3Aopen%20label%3A%22bug%22)Milestone[1.14](https://github.com/Icinga/icinga-core/milestone/50)[![@icinga-migration](https://avatars.githubusercontent.com/u/25101969?u=1c2dbd45f4d2eb97994340cf910235aa48033aa8&v=4&size=80)](/icinga-migration)
## Description

[![@icinga-migration](https://avatars.githubusercontent.com/u/25101969?u=1c2dbd45f4d2eb97994340cf910235aa48033aa8&v=4&size=48)](/icinga-migration)[icinga-migration](https://github.com/icinga-migration)opened [on Oct 23, 2015](https://github.com/Icinga/icinga-core/issues/1563#issue-201307332)

This issue has been migrated from Redmine: <https://dev.icinga.com/issues/10453>

**Created by ricardo on 2015-10-23 20:24:35 +00:00**

Assignee: *ricardo*

Status: *Resolved* (closed on *2015-10-30 20:10:07 +00:00*)

Target Version: *1.14*

Last Update: *2015-10-30 22:14:06 +00:00 (in Redmine)*

```
Icinga Version: 1.13.3
OS Version: Linux 4.2.3

```

---

Due to my bad programming skills I introduced a XSS vulnerability in Classic-UI with the CSV export link and pagination feature.

This got originally introduced with this issue <https://dev.icinga.org/issues/593> and version 1.3.

Example: <http://classic.demo.icinga.org/icinga/cgi-bin/status.cgi?host=all&'onmouseover='prompt(25435);'bad=>'

I already wrote a fix which just needs to commitet.

Hopefully this fix can make it into 1.14.0.

Thanks to T-Systems Germany for finding it.

Cheers

Ricardo

**Attachments**

* [Icinga\_1.11.6\_fix\_xxs\_CVE-2015-8010.patch](https://dev.icinga.com/attachments/download/2840/Icinga_1.11.6_fix_xxs_CVE-2015-8010.patch) ricardo - *2015-10-30 20:54:35 +00:00*

**Changesets**

*2015-10-23 20:26:12 +00:00* by *ricardo* [5c816f5](https://github.com/Icinga/icinga-core/commit/5c816f5d9352c373e9dadb95b63612a96cf96dff)

```
Classic-UI: fixes a XXS vulnerability in pagination and export links #10453

Sorry guys. Due to my bad programming skills I introduced a
XSS vulnerability in Classic-UI with the CSV export link and
pagination feature. The functions parsed QUERY_STRING from
the environment without properly sanitizing it.

The getcgivars() function got a bit reworked. Once the
QUERY_STRING is read and parsed the content survives the
whole lifetime of the cgi execution and gets free’d at
the end. This way we can always build urls from valid parsed
cgi params.

I wonder why I haven't done this earlier.

Also the url param parsing in every cgi was updated and
hopefully everything works as bevor.

Refs: #10453

```

*2015-10-30 20:05:17 +00:00* by *ricardo* [31dd493](https://github.com/Icinga/icinga-core/commit/31dd493a48e335203899a1b2cae473852930e203)

```
Merge branch 'fix/xxs-vulnerability-in-classic-ui-10453'

fixes: #10453
fixes: CVE-2015-8010

```
## Metadata

### Assignees

No one assigned

### Labels

[Classic UI](https://github.com/Icinga/icinga-core/issues?q=state%3Aopen%20label%3A%22Classic%20UI%22)[High](https://github.com/Icinga/icinga-core/issues?q=state%3Aopen%20label%3A%22High%22)[bug](https://github.com/Icinga/icinga-core/issues?q=state%3Aopen%20label%3A%22bug%22)
### Type

No type
### Projects

No projects
### Milestone

* [1.14](https://github.com/Icinga/icinga-core/milestone/50)
### Relationships

None yet
### Development

No branches or pull requests
## Issue actions

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


