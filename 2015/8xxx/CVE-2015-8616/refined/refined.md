```
{
  "CVE-2015-8616": {
    "related_content": [
      {
        "source": "php.net_99336420_20250125_021618.html",
        "text": "This content is a changelog for PHP versions, and it mentions CVE-2015-8616:\n\n*   Intl:\n    + Fixed bug [#71020](http://bugs.php.net/71020): Use after free in Collator::sortWithSortKeys. (CVE-2015-8616)",
          "vulnerability_details": {
            "root_cause": "A use-after-free vulnerability in the Collator::sortWithSortKeys function within the intl extension.",
            "weaknesses": [
              "Use-after-free"
            ],
            "impact": "The vulnerability can lead to a crash or other undefined behavior due to dereferencing freed memory.",
            "attack_vectors": "The vulnerability can be triggered by calling the `Collator::sortWithSortKeys` function with a specially crafted array as input.",
            "attacker_capabilities": "An attacker needs to be able to call the vulnerable `Collator::sortWithSortKeys` function with a crafted input, thus requiring some control over the PHP application's execution."
          }
      },
     {
        "source": "bugs.php.net_c0d61e6f_20250125_021619.html",
        "text": "This content is a bug report for PHP, and it contains useful information about the CVE-2015-8616:\n\n*   Bug ID #71020: Use after free in Collator::sortWithSortKeys.\n*   Description: This is a vulnerability is in the function Collator::sortWithSortKeys. The vulnerable code is in ext/intl/collator/collator_sort.c \n    1) Given an array, each element (hashData) is being referenced by a pointer in sortKeyIndxBuf[sortKeyCount].zstr (line 493):\n    2) The array is then destroy and it's hashData elements freed (ref count -1).\n    3) The array is then destroy and it's hashData elements freed (ref count -1).\n   Note that at this point sortKeyIndxBuf[sortKeyCount].zstr still contain pointers to the hashData elements which has been freed. In essence, sortKeyIndxBuf[sortKeyCount].zstr are dangling pointers.\n   4) A new array is reinitialized,\n   5) The dangling pointers are then added as elements into the new array:\n   6) I've included a POC that triggers this vulnerability, resulting in a null pointer dereference. \n\n          -an array of 0xbb elements is being passed into the function\n          -sortKeyIndxBuf[0].zstr to sortKeyIndxBuf[0xba].zstr points to the elements in the array\n          -Array is destroyed via zval\_ptr\_dtor( array );\n          -sortKeyIndxBuf[0....0xba].zstr are now dangling pointers\n          -New array initialized (Hashtable with initial element size of 8)\n          -As the dangling pointers are added to array, the size of the Hashtable grows.\n          -As the Hashtable grows, it's allocated more memory via zend\_hash\_do\_resize()\n          -It will then be allocated memory that co-incides with an address pointed to by the dangling pointer sortKeyIndxBuf[j].zstr. Thus sortKeyIndxBuf[j].zstr now no longer points to a valid zval.\n          -When the code below dereferences this address, because it is pointing to an invalid zval, it will access dereference whatever is the value within this \"corrupted zval\". In this case it's a null pointer dereference.\n\n          514:Z_TRY_ADDREF_P( sortKeyIndxBuf[j].zstr );",
         "vulnerability_details": {
            "root_cause": "The root cause is a use-after-free vulnerability in the `Collator::sortWithSortKeys` function. The issue arises when an array's elements are referenced by pointers (`sortKeyIndxBuf[sortKeyCount].zstr`), then the array is destroyed, and these pointers are subsequently used after the memory they point to has been freed.",
            "weaknesses": [
              "Use-after-free",
               "Dangling pointer"
             ],
           "impact": "Exploitation of this vulnerability can lead to a null pointer dereference, which results in a segmentation fault and crashes the PHP process.",
           "attack_vectors": "An attacker can trigger this vulnerability by calling `Collator::sortWithSortKeys` with an array that has specific size and content.",
            "attacker_capabilities": "The attacker must be able to control the data provided to `Collator::sortWithSortKeys`. This can occur if a PHP application accepts user-controlled data for sorting."
          }
      },
      {
        "source": "pecl.php.net_2b7f6a94_20250126_051659.html",
        "text": "This content is related to the intl extension, which is affected by CVE-2015-8616:\n\nThis package is not maintained anymore and has been superseded by . Package has moved to channel <http://php.net/manual/en/book.intl.php>.",
        "vulnerability_details": {
          "root_cause": "The vulnerability is within the intl extension of PHP, specifically in the Collator::sortWithSortKeys function, where a use-after-free error occurs.",
          "weaknesses": [
              "Use-after-free"
            ],
            "impact": "The vulnerability can lead to a crash of the application due to a null pointer dereference or a segmentation fault.",
            "attack_vectors": "The vulnerability is triggered when the Collator::sortWithSortKeys function is called with user-controlled array.",
            "attacker_capabilities": "An attacker would require the ability to control the input to the `Collator::sortWithSortKeys` function to trigger the vulnerability."
        }
      }
    ],
    "summary": "CVE-2015-8616 describes a use-after-free vulnerability in the `Collator::sortWithSortKeys` function within the `intl` extension of PHP.  This vulnerability occurs when an array's elements are referenced, the array is destroyed, and the references to the freed memory are later used, causing a crash. The vulnerability can be triggered with a crafted array input to the vulnerable function. This issue is present in PHP 7.0.0, and has been fixed in later versions by updating the function to properly handle references and memory management. An attacker with the ability to provide input to the vulnerable function can trigger this issue."
  }
}
```