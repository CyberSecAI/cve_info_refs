=== Content from github.com_5f22f28e_20250114_220614.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fenvoyproxy%2Fenvoy%2Fsecurity%2Fadvisories%2FGHSA-5jmv-cw9p-f9rp)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fenvoyproxy%2Fenvoy%2Fsecurity%2Fadvisories%2FGHSA-5jmv-cw9p-f9rp)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=envoyproxy%2Fenvoy)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[envoyproxy](/envoyproxy)
/
**[envoy](/envoyproxy/envoy)**
Public

* [Notifications](/login?return_to=%2Fenvoyproxy%2Fenvoy) You must be signed in to change notification settings
* [Fork
  4.8k](/login?return_to=%2Fenvoyproxy%2Fenvoy)
* [Star
   25.3k](/login?return_to=%2Fenvoyproxy%2Fenvoy)

* [Code](/envoyproxy/envoy)
* [Issues
  1.5k](/envoyproxy/envoy/issues)
* [Pull requests
  129](/envoyproxy/envoy/pulls)
* [Actions](/envoyproxy/envoy/actions)
* [Projects
  0](/envoyproxy/envoy/projects)
* [Wiki](/envoyproxy/envoy/wiki)
* [Security](/envoyproxy/envoy/security)
* [Insights](/envoyproxy/envoy/pulse)

Additional navigation options

* [Code](/envoyproxy/envoy)
* [Issues](/envoyproxy/envoy/issues)
* [Pull requests](/envoyproxy/envoy/pulls)
* [Actions](/envoyproxy/envoy/actions)
* [Projects](/envoyproxy/envoy/projects)
* [Wiki](/envoyproxy/envoy/wiki)
* [Security](/envoyproxy/envoy/security)
* [Insights](/envoyproxy/envoy/pulse)

# Envoy forwards invalid HTTP/2 and HTTP/3 downstream headers

Moderate

[phlax](/phlax)
published
GHSA-5jmv-cw9p-f9rp
Apr 4, 2023

## Package

Envoy
(Envoy)

## Affected versions

< 1.26.0

## Patched versions

1.25.3, 1.24.4, 1.23.6, 1.22.9

## Description

### Impact

Compliant HTTP/1 service should reject malformed request lines.

There is a possibility that non compliant HTTP/1 service may allow malformed requests, potentially leading to a bypass of security policies.

### Affected components

HTTP2/HTTP3.

### Attack vector/s

Attackers can send specifically crafted HTTP/2 or HTTP/3 requests to trigger parsing errors on HTTP/1 upstream service.

### Description

Envoy does not reject HTTP/2 and HTTP/3 requests with the `:method` value which is not a valid token defined in <https://www.rfc-editor.org/rfc/rfc9110#section-5.6.2>.

In addition to the above, based on <https://datatracker.ietf.org/doc/html/rfc9113#section-8.3> and <https://datatracker.ietf.org/doc/html/rfc9114#section-4.3.1>, HTTP/2 and HTTP/3 requests **MUST** include exactly one value for the `:method`, `:scheme`, and `:path` pseudo-header fields, unless the request is a `CONNECT` request which may omit `:scheme` and `:path`.

Allowing invalid characters in pseudo headers can result in sending an invalid request line when proxying from HTTP/2 or HTTP/3 client to HTTP/1 upstream service.

### Example exploit or proof-of-concept

Send an HTTP/2 or HTTP/3 request with invalid `:method` header such as `:method: GET /admin`.

### Detection

Upstream service receives unexpected privileged requests from Envoy.

### Discoverer(s)/Credits

Martin van Kervel Smedshammer mvsmedsh@ifi.uio.no

### Severity

Moderate

5.4

# CVSS overall score

 This score calculates overall vulnerability severity from 0 to 10 and is based on the Common Vulnerability Scoring System (CVSS).

 / 10

#### CVSS v3 base metrics

Attack vector
Network

Attack complexity
Low

Privileges required
None

User interaction
Required

Scope
Unchanged

Confidentiality
Low

Integrity
Low

Availability
None

Learn more about base metrics

# CVSS v3 base metrics

Attack vector:
More severe the more the remote (logically and physically) an attacker can be in order to exploit the vulnerability.

Attack complexity:
More severe for the least complex attacks.

Privileges required:
More severe if no privileges are required.

User interaction:
More severe when no user interaction is required.

Scope:
More severe when a scope change occurs, e.g. one vulnerable component impacts resources in components beyond its security scope.

Confidentiality:
More severe when loss of data confidentiality is highest, measuring the level of data access available to an unauthorized user.

Integrity:
More severe when loss of data integrity is the highest, measuring the consequence of data modification possible by an unauthorized user.

Availability:
More severe when the loss of impacted component availability is highest.

CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N

### CVE ID

CVE-2023-27491

### Weaknesses

[CWE-20](/advisories?query=cwe%3A20)

### Credits

* [![@phlax](https://avatars.githubusercontent.com/u/454682?s=40&v=4)](/phlax)
  [phlax](/phlax)
  Coordinator
* [![@cancecen](https://avatars.githubusercontent.com/u/7796397?s=40&v=4)](/cancecen)
  [cancecen](/cancecen)
  Coordinator
* [![@danzh2010](https://avatars.githubusercontent.com/u/19391170?s=40&v=4)](/danzh2010)
  [danzh2010](/danzh2010)
  Remediation developer

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from datatracker.ietf.org_94089825_20250114_220614.html ===


* Light
* Dark
* Auto

[RFC 9114

Proposed Standard](/doc/rfc9114/)

|  | Title |  | HTTP/3 |
| --- | --- | --- | --- |
| Document | Document type |  | RFC - Proposed Standard  June 2022  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=9114 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") Was [draft-ietf-quic-http](/doc/draft-ietf-quic-http/34/) ([quic WG](/wg/quic/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [00](/doc/html/draft-ietf-quic-http-00) * [01](/doc/html/draft-ietf-quic-http-01) * [02](/doc/html/draft-ietf-quic-http-02) * [03](/doc/html/draft-ietf-quic-http-03) * [04](/doc/html/draft-ietf-quic-http-04) * [05](/doc/html/draft-ietf-quic-http-05) * [06](/doc/html/draft-ietf-quic-http-06) * [07](/doc/html/draft-ietf-quic-http-07) * [08](/doc/html/draft-ietf-quic-http-08) * [09](/doc/html/draft-ietf-quic-http-09) * [10](/doc/html/draft-ietf-quic-http-10) * [11](/doc/html/draft-ietf-quic-http-11) * [12](/doc/html/draft-ietf-quic-http-12) * [13](/doc/html/draft-ietf-quic-http-13) * [14](/doc/html/draft-ietf-quic-http-14) * [15](/doc/html/draft-ietf-quic-http-15) * [16](/doc/html/draft-ietf-quic-http-16) * [17](/doc/html/draft-ietf-quic-http-17) * [18](/doc/html/draft-ietf-quic-http-18) * [19](/doc/html/draft-ietf-quic-http-19) * [20](/doc/html/draft-ietf-quic-http-20) * [21](/doc/html/draft-ietf-quic-http-21) * [22](/doc/html/draft-ietf-quic-http-22) * [23](/doc/html/draft-ietf-quic-http-23) * [24](/doc/html/draft-ietf-quic-http-24) * [25](/doc/html/draft-ietf-quic-http-25) * [26](/doc/html/draft-ietf-quic-http-26) * [27](/doc/html/draft-ietf-quic-http-27) * [28](/doc/html/draft-ietf-quic-http-28) * [29](/doc/html/draft-ietf-quic-http-29) * [30](/doc/html/draft-ietf-quic-http-30) * [31](/doc/html/draft-ietf-quic-http-31) * [32](/doc/html/draft-ietf-quic-http-32) * [33](/doc/html/draft-ietf-quic-http-33) * [34](/doc/html/draft-ietf-quic-http-34) * [RFC 9114](/doc/html/rfc9114) |
|  | Compare versions |  | RFC 9114  draft-ietf-quic-http-34  draft-ietf-quic-http-33  draft-ietf-quic-http-32  draft-ietf-quic-http-31  draft-ietf-quic-http-30  draft-ietf-quic-http-29  draft-ietf-quic-http-28  draft-ietf-quic-http-27  draft-ietf-quic-http-26  draft-ietf-quic-http-25  draft-ietf-quic-http-24  draft-ietf-quic-http-23  draft-ietf-quic-http-22  draft-ietf-quic-http-21  draft-ietf-quic-http-20  draft-ietf-quic-http-19  draft-ietf-quic-http-18  draft-ietf-quic-http-17  draft-ietf-quic-http-16  draft-ietf-quic-http-15  draft-ietf-quic-http-14  draft-ietf-quic-http-13  draft-ietf-quic-http-12  draft-ietf-quic-http-11  draft-ietf-quic-http-10  draft-ietf-quic-http-09  draft-ietf-quic-http-08  draft-ietf-quic-http-07  draft-ietf-quic-http-06  draft-ietf-quic-http-05  draft-ietf-quic-http-04  draft-ietf-quic-http-03  draft-ietf-quic-http-02  draft-ietf-quic-http-01  draft-ietf-quic-http-00   RFC 9114  draft-ietf-quic-http-34  draft-ietf-quic-http-33  draft-ietf-quic-http-32  draft-ietf-quic-http-31  draft-ietf-quic-http-30  draft-ietf-quic-http-29  draft-ietf-quic-http-28  draft-ietf-quic-http-27  draft-ietf-quic-http-26  draft-ietf-quic-http-25  draft-ietf-quic-http-24  draft-ietf-quic-http-23  draft-ietf-quic-http-22  draft-ietf-quic-http-21  draft-ietf-quic-http-20  draft-ietf-quic-http-19  draft-ietf-quic-http-18  draft-ietf-quic-http-17  draft-ietf-quic-http-16  draft-ietf-quic-http-15  draft-ietf-quic-http-14  draft-ietf-quic-http-13  draft-ietf-quic-http-12  draft-ietf-quic-http-11  draft-ietf-quic-http-10  draft-ietf-quic-http-09  draft-ietf-quic-http-08  draft-ietf-quic-http-07  draft-ietf-quic-http-06  draft-ietf-quic-http-05  draft-ietf-quic-http-04  draft-ietf-quic-http-03  draft-ietf-quic-http-02  draft-ietf-quic-http-01  draft-ietf-quic-http-00   Side-by-side  Inline |
|  | Author |  | [Mike Bishop](/person/mbishop%40evequefou.be "Datatracker profile of Mike Bishop")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc9114.txt) [html](https://www.rfc-editor.org/rfc/rfc9114.html) [xml](https://www.rfc-editor.org/rfc/rfc9114.xml) [pdf](https://www.rfc-editor.org/rfc/rfc9114.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc9114.html) [bibtex](/doc/rfc9114/bibtex/) |
|  | Additional resources |  | [Mailing list discussion](https://mailarchive.ietf.org/arch/browse/quic/?q=rfc9114 OR %22draft-ietf-quic-http%22) |
|  |  |  | [Report a bug](https://github.com/ietf-tools/datatracker/issues/new/choose) |

| RFC 9114 | HTTP/3 | June 2022 |
| --- | --- | --- |
| Bishop | Standards Track | [Page] |
| --- | --- | --- |

Stream:
Internet Engineering Task Force (IETF)
RFC:
[9114](https://www.rfc-editor.org/rfc/rfc9114)
Category:
Standards Track
Published:
June 2022

ISSN:
2070-1721
Author:
M. Bishop, Ed.

Akamai

# RFC 9114

# HTTP/3

## [Abstract](#abstract)

The QUIC transport protocol has several features that are desirable in a
transport for HTTP, such as stream multiplexing, per-stream flow control, and
low-latency connection establishment. This document describes a mapping of HTTP
semantics over QUIC. This document also identifies HTTP/2 features that are
subsumed by QUIC and describes how HTTP/2 extensions can be ported to HTTP/3.[¶](#section-abstract-1)

## [Status of This Memo](#name-status-of-this-memo)

This is an Internet Standards Track document.[¶](#section-boilerplate.1-1)

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by
the Internet Engineering Steering Group (IESG). Further
information on Internet Standards is available in Section 2 of
RFC 7841.[¶](#section-boilerplate.1-2)

Information about the current status of this document, any
errata, and how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9114>.[¶](#section-boilerplate.1-3)

## [Copyright Notice](#name-copyright-notice)

Copyright (c) 2022 IETF Trust and the persons identified as the
document authors. All rights reserved.[¶](#section-boilerplate.2-1)

This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents
carefully, as they describe your rights and restrictions with
respect to this document. Code Components extracted from this
document must include Revised BSD License text as described in
Section 4.e of the Trust Legal Provisions and are provided without
warranty as described in the Revised BSD License.[¶](#section-boilerplate.2-2)

▲
## [Table of Contents](#name-table-of-contents)

* [1](#section-1).  [Introduction](#name-introduction)

  + [1.1](#section-1.1).  [Prior Versions of HTTP](#name-prior-versions-of-http)
  + [1.2](#section-1.2).  [Delegation to QUIC](#name-delegation-to-quic)
* [2](#section-2).  [HTTP/3 Protocol Overview](#name-http-3-protocol-overview)

  + [2.1](#section-2.1).  [Document Organization](#name-document-organization)
  + [2.2](#section-2.2).  [Conventions and Terminology](#name-conventions-and-terminology)
* [3](#section-3).  [Connection Setup and Management](#name-connection-setup-and-manage)

  + [3.1](#section-3.1).  [Discovering an HTTP/3 Endpoint](#name-discovering-an-http-3-endpo)

    - [3.1.1](#section-3.1.1).  [HTTP Alternative Services](#name-http-alternative-services)
    - [3.1.2](#section-3.1.2).  [Other Schemes](#name-other-schemes)
  + [3.2](#section-3.2).  [Connection Establishment](#name-connection-establishment)
  + [3.3](#section-3.3).  [Connection Reuse](#name-connection-reuse)
* [4](#section-4).  [Expressing HTTP Semantics in HTTP/3](#name-expressing-http-semantics-i)

  + [4.1](#section-4.1).  [HTTP Message Framing](#name-http-message-framing)

    - [4.1.1](#section-4.1.1).  [Request Cancellation and Rejection](#name-request-cancellation-and-re)
    - [4.1.2](#section-4.1.2).  [Malformed Requests and Responses](#name-malformed-requests-and-resp)
  + [4.2](#section-4.2).  [HTTP Fields](#name-http-fields)

    - [4.2.1](#section-4.2.1).  [Field Compression](#name-field-compression)
    - [4.2.2](#section-4.2.2).  [Header Size Constraints](#name-header-size-constraints)
  + [4.3](#section-4.3).  [HTTP Control Data](#name-http-control-data)

    - [4.3.1](#section-4.3.1).  [Request Pseudo-Header Fields](#name-request-pseudo-header-field)
    - [4.3.2](#section-4.3.2).  [Response Pseudo-Header Fields](#name-response-pseudo-header-fiel)
  + [4.4](#section-4.4).  [The CONNECT Method](#name-the-connect-method)
  + [4.5](#section-4.5).  [HTTP Upgrade](#name-http-upgrade)
  + [4.6](#section-4.6).  [Server Push](#name-server-push)
* [5](#section-5).  [Connection Closure](#name-connection-closure)

  + [5.1](#section-5.1).  [Idle Connections](#name-idle-connections)
  + [5.2](#section-5.2).  [Connection Shutdown](#name-connection-shutdown)
  + [5.3](#section-5.3).  [Immediate Application Closure](#name-immediate-application-closu)
  + [5.4](#section-5.4).  [Transport Closure](#name-transport-closure)
* [6](#section-6).  [Stream Mapping and Usage](#name-stream-mapping-and-usage)

  + [6.1](#section-6.1).  [Bidirectional Streams](#name-bidirectional-streams)
  + [6.2](#section-6.2).  [Unidirectional Streams](#name-unidirectional-streams)

    - [6.2.1](#section-6.2.1).  [Control Streams](#name-control-streams)
    - [6.2.2](#section-6.2.2).  [Push Streams](#name-push-streams)
    - [6.2.3](#section-6.2.3).  [Reserved Stream Types](#name-reserved-stream-types)
* [7](#section-7).  [HTTP Framing Layer](#name-http-framing-layer)

  + [7.1](#section-7.1).  [Frame Layout](#name-frame-layout)
  + [7.2](#section-7.2).  [Frame Definitions](#name-frame-definitions)

    - [7.2.1](#section-7.2.1).  [DATA](#name-data)
    - [7.2.2](#section-7.2.2).  [HEADERS](#name-headers)
    - [7.2.3](#section-7.2.3).  [CANCEL\_PUSH](#name-cancel_push)
    - [7.2.4](#section-7.2.4).  [SETTINGS](#name-settings)
    - [7.2.5](#section-7.2.5).  [PUSH\_PROMISE](#name-push_promise)
    - [7.2.6](#section-7.2.6).  [GOAWAY](#name-goaway)
    - [7.2.7](#section-7.2.7).  [MAX\_PUSH\_ID](#name-max_push_id)
    - [7.2.8](#section-7.2.8).  [Reserved Frame Types](#name-reserved-frame-types)
* [8](#section-8).  [Error Handling](#name-error-handling)

  + [8.1](#section-8.1).  [HTTP/3 Error Codes](#name-http-3-error-codes)
* [9](#section-9).  [Extensions to HTTP/3](#name-extensions-to-http-3)
* [10](#section-10). [Security Considerations](#name-security-considerations)

  + [10.1](#section-10.1).  [Server Authority](#name-server-authority)
  + [10.2](#section-10.2).  [Cross-Protocol Attacks](#name-cross-protocol-attacks)
  + [10.3](#section-10.3).  [Intermediary-Encapsulation Attacks](#name-intermediary-encapsulation-)
  + [10.4](#section-10.4).  [Cacheability of Pushed Responses](#name-cacheability-of-pushed-resp)
  + [10.5](#section-10.5).  [Denial-of-Service Considerations](#name-denial-of-service-considera)

    - [10.5.1](#section-10.5.1).  [Limits on Field Section Size](#name-limits-on-field-section-siz)
    - [10.5.2](#section-10.5.2).  [CONNECT Issues](#name-connect-issues)
  + [10.6](#section-10.6).  [Use of Compression](#name-use-of-compression)
  + [10.7](#section-10.7).  [Padding and Traffic Analysis](#name-padding-and-traffic-analysi)
  + [10.8](#section-10.8).  [Frame Parsing](#name-frame-parsing)
  + [10.9](#section-10.9).  [Early Data](#name-early-data)
  + [10.10](#section-10.10). [Migration](#name-migration)
  + [10.11](#section-10.11). [Privacy Considerations](#name-privacy-considerations)
* [11](#section-11). [IANA Considerations](#name-iana-considerations)

  + [11.1](#section-11.1).  [Registration of HTTP/3 Identification String](#name-registration-of-http-3-iden)
  + [11.2](#section-11.2).  [New Registries](#name-new-registries)

    - [11.2.1](#section-11.2.1).  [Frame Types](#name-frame-types)
    - [11.2.2](#section-11.2.2).  [Settings Parameters](#name-settings-parameters)
    - [11.2.3](#section-11.2.3).  [Error Codes](#name-error-codes)
    - [11.2.4](#section-11.2.4).  [Stream Types](#name-stream-types)
* [12](#section-12). [References](#name-references)

  + [12.1](#section-12.1).  [Normative References](#name-normative-references)
  + [12.2](#section-12.2).  [Informative References](#name-informative-references)
* [Appendix A](#appendix-A).  [Considerations for Transitioning from HTTP/2](#name-considerations-for-transiti)

  + [A.1](#appendix-A.1).  [Streams](#name-streams)
  + [A.2](#appendix-A.2).  [HTTP Frame Types](#name-http-frame-types)

    - [A.2.1](#appendix-A.2.1).  [Prioritization Differences](#name-prioritization-differences)
    - [A.2.2](#appendix-A.2.2).  [Field Compression Differences](#name-field-compression-differenc)
    - [A.2.3](#appendix-A.2.3).  [Flow-Control Differences](#name-flow-control-differences)
    - [A.2.4](#appendix-A.2.4).  [Guidance for New Frame Type Definitions](#name-guidance-for-new-frame-type)
    - [A.2.5](#appendix-A.2.5).  [Comparison of HTTP/2 and HTTP/3 Frame Types](#name-comparison-of-http-2-and-ht)
  + [A.3](#appendix-A.3).  [HTTP/2 SETTINGS Parameters](#name-http-2-settings-parameters)
  + [A.4](#appendix-A.4).  [HTTP/2 Error Codes](#name-http-2-error-codes)

    - [A.4.1](#appendix-A.4.1).  [Mapping between HTTP/2 and HTTP/3 Errors](#name-mapping-between-http-2-and-)
* [Acknowledgments](#name-acknowledgments)
* [Index](#name-index)
* [Author's Address](#name-authors-address)

## [1.](#section-1) [Introduction](#name-introduction)

HTTP semantics ([[HTTP](#RFC9110)]) are used for a broad range of services on the
Internet. These semantics have most commonly been used with HTTP/1.1 and HTTP/2.
HTTP/1.1 has been used over a variety of transport and session layers, while
HTTP/2 has been used primarily with TLS over TCP. HTTP/3 supports the same
semantics over a new transport protocol: QUIC.[¶](#section-1-1)

### [1.1.](#section-1.1) [Prior Versions of HTTP](#name-prior-versions-of-http)

HTTP/1.1 ([[HTTP/1.1](#RFC9112)]) uses whitespace-delimited text fields to convey HTTP
messages. While these exchanges are human readable, using whitespace for
message formatting leads to parsing complexity and excessive tolerance of
variant behavior.[¶](#section-1.1-1)

Because HTTP/1.1 does not include a multiplexing layer, multiple TCP connections
are often used to service requests in parallel. However, that has a negative
impact on congestion control and network efficiency, since TCP does not share
congestion control across multiple connections.[¶](#section-1.1-2)

HTTP/2 ([[HTTP/2](#RFC9113)]) introduced a binary framing and multiplexing layer
to improve latency without modifying the transport layer. However, because the
parallel nature of HTTP/2's multiplexing is not visible to TCP's loss recovery
mechanisms, a lost or reordered packet causes all active transactions to
experience a stall regardless of whether that transaction was directly impacted
by the lost packet.[¶](#section-1.1-3)

### [1.2.](#section-1.2) [Delegation to QUIC](#name-delegation-to-quic)

The QUIC transport protocol incorporates stream multiplexing and per-stream flow
control, similar to that provided by the HTTP/2 framing layer. By providing
reliability at the stream level and congestion control across the entire
connection, QUIC has the capability to improve the performance of HTTP compared
to a TCP mapping. QUIC also incorporates TLS 1.3 ([[TLS](#TLS)]) at the
transport layer, offering comparable confidentiality and integrity to running
TLS over TCP, with the improved connection setup latency of TCP Fast Open
([[TFO](#TFO)]).[¶](#section-1.2-1)

This document defines HTTP/3: a mapping of HTTP semantics over the QUIC
transport protocol, drawing heavily on the design of HTTP/2. HTTP/3 relies on
QUIC to provide confidentiality and integrity protection of data; peer
authentication; and reliable, in-order, per-stream delivery. While delegating
stream lifetime and flow-control issues to QUIC, a binary framing similar to the
HTTP/2 framing is used on each stream. Some HTTP/2 features are subsumed by
QUIC, while other features are implemented atop QUIC.[¶](#section-1.2-2)

QUIC is described in [[QUIC-TRANSPORT](#QUIC-TRANSPORT)]. For a full description of
HTTP/2, see [[HTTP/2](#RFC9113)].[¶](#section-1.2-3)

## [2.](#section-2) [HTTP/3 Protocol Overview](#name-http-3-protocol-overview)

HTTP/3 provides a transport for HTTP semantics using the QUIC transport protocol
and an internal framing layer similar to HTTP/2.[¶](#section-2-1)

Once a client knows that an HTTP/3 server exists at a certain endpoint, it opens
a QUIC connection. QUIC provides protocol negotiation, stream-based
multiplexing, and flow control. Discovery of an HTTP/3 endpoint is described in
[Section 3.1](#discovery).[¶](#section-2-2)

Within each stream, the basic unit of HTTP/3 communication is a frame
([Section 7.2](#frames)). Each frame type serves a different purpose. For example, [HEADERS](#frame-headers)
and [DATA](#frame-data) frames form the basis of HTTP requests and responses
([Section 4.1](#request-response)). Frames that apply to the entire connection are
conveyed on a dedicated [control stream](#control-streams).[¶](#section-2-3)

Multiplexing of requests is performed using the QUIC stream abstraction, which
is described in [Section 2](https://www.rfc-editor.org/rfc/rfc9000#section-2) of [[QUIC-TRANSPORT](#QUIC-TRANSPORT)]. Each request-response pair
consumes a single QUIC stream. Streams are independent of each other, so one
stream that is blocked or suffers packet loss does not prevent progress on other
streams.[¶](#section-2-4)

Server push is an interaction mode introduced in HTTP/2 ([[HTTP/2](#RFC9113)]) that
permits a server to push a request-response exchange to a client in anticipation
of the client making the indicated request. This trades off network usage
against a potential latency gain. Several HTTP/3 frames are used to manage
server push, such as [PUSH\_PROMISE](#frame-push-promise), [MAX\_PUSH\_ID](#frame-max-push-id), and [CANCEL\_PUSH](#frame-cancel-push).[¶](#section-2-5)

As in HTTP/2, request and response fields are compressed for transmission.
Because HPACK ([[HPACK](#HPACK)]) relies on in-order transmission of
compressed field sections (a guarantee not provided by QUIC), HTTP/3 replaces
HPACK with QPACK ([[QPACK](#RFC9204)]). QPACK uses separate unidirectional streams to
modify and track field table state, while encoded field sections refer to the
state of the table without modifying it.[¶](#section-2-6)

### [2.1.](#section-2.1) [Document Organization](#name-document-organization)

The following sections provide a detailed overview of the lifecycle of an HTTP/3
connection:[¶](#section-2.1-1)

* "[Connection Setup and Management](#connection-setup)" ([Section 3](#connection-setup)) covers how an HTTP/3
  endpoint is discovered and an HTTP/3 connection is established.[¶](#section-2.1-2.1)
* "[Expressing HTTP Semantics in HTTP/3](#http-request-lifecycle)" ([Section 4](#http-request-lifecycle)) describes how HTTP
  semantics are expressed using frames.[¶](#section-2.1-2.2)
* "[Connection Closure](#connection-closure)" ([Section 5](#connection-closure)) describes how HTTP/3
  connections are terminated, either gracefully or abruptly.[¶](#section-2.1-2.3)

The details of the wire protocol and interactions with the transport are
described in subsequent sections:[¶](#section-2.1-3)

* "[Stream Mapping and Usage](#stream-mapping)" ([Section 6](#stream-mapping)) describes the way QUIC streams
  are used.[¶](#section-2.1-4.1)
* "[HTTP Framing Layer](#http-framing-layer)" ([Section 7](#http-framing-layer)) describes the frames used
  on most streams.[¶](#section-2.1-4.2)
* "[Error Handling](#errors)" ([Section 8](#errors)) describes how error conditions are handled and
  expressed, either on a particular stream or for the connection as a whole.[¶](#section-2.1-4.3)

Additional resources are provided in the final sections:[¶](#section-2.1-5)

* "[Extensions to HTTP/3](#extensions)" ([Section 9](#extensions)) describes how new capabilities can be
  added in future documents.[¶](#section-2.1-6.1)
* A more detailed comparison between HTTP/2 and HTTP/3 can be found in
  [Appendix A](#h2-considerations).[¶](#section-2.1-6.2)

### [2.2.](#section-2.2) [Conventions and Terminology](#name-conventions-and-terminology)

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 [[RFC2119](#RFC2119)] [[RFC8174](#RFC8174)] when, and only when, they
appear in all capitals, as shown here.[¶](#section-2.2-1)

This document uses the variable-length integer encoding from
[[QUIC-TRANSPORT](#QUIC-TRANSPORT)].[¶](#section-2.2-2)

The following terms are used:[¶](#section-2.2-3)

abort:

An abrupt termination of a connection or stream, possibly due to an error
condition.[¶](#section-2.2-4.2.1)

client:

The endpoint that initiates an HTTP/3 connection. Clients send HTTP requests
and receive HTTP responses.[¶](#section-2.2-4.4.1)

connection:

A transport-layer connection between two endpoints using QUIC as the
transport protocol.[¶](#section-2.2-4.6.1)

[connection error](#errors):

An error that affects the entire HTTP/3 connection.[¶](#section-2.2-4.8.1)

endpoint:

Either the client or server of the connection.[¶](#section-2.2-4.10.1)

frame:

The smallest unit of communication on a stream in HTTP/3, consisting of a
header and a variable-length sequence of bytes structured according to the
frame type.[¶](#section-2.2-4.12.1)

Protocol elements called "frames" exist in both this document and
[[QUIC-TRANSPORT](#QUIC-TRANSPORT)]. Where frames from [[QUIC-TRANSPORT](#QUIC-TRANSPORT)] are referenced, the
frame name will be prefaced with "QUIC". For example, "QUIC CONNECTION\_CLOSE
frames". References without this preface refer to frames defined in
[Section 7.2](#frames).[¶](#section-2.2-4.12.2)

HTTP/3 connection:

A QUIC connection where the negotiated application protocol is HTTP/3.[¶](#section-2.2-4.14.1)

peer:

An endpoint. When discussing a particular endpoint, "peer" refers to the
endpoint that is remote to the primary subject of discussion.[¶](#section-2.2-4.16.1)

receiver:

An endpoint that is receiving frames.[¶](#section-2.2-4.18.1)

sender:

An endpoint that is transmitting frames.[¶](#section-2.2-4.20.1)

server:

The endpoint that accepts an HTTP/3 connection. Servers receive HTTP requests
and send HTTP responses.[¶](#section-2.2-4.22.1)

stream:

A bidirectional or unidirectional bytestream provided by the QUIC transport.
All streams within an HTTP/3 connection can be considered "HTTP/3 streams",
but multiple stream types are defined within HTTP/3.[¶](#section-2.2-4.24.1)

[stream error](#errors):

An application-level error on the individual stream.[¶](#section-2.2-4.26.1)

The term "content" is defined in [Section 6.4](https://www.rfc-editor.org/rfc/rfc9110#section-6.4) of [[HTTP](#RFC9110)].[¶](#section-2.2-5)

Finally, the terms "resource", "message", "user agent", "origin server",
"gateway", "intermediary", "proxy", and "tunnel" are defined in [Section 3](https://www.rfc-editor.org/rfc/rfc9110#section-3) of [[HTTP](#RFC9110)].[¶](#section-2.2-6)

Packet diagrams in this document use the format defined in
[Section 1.3](https://www.rfc-editor.org/rfc/rfc9000#section-1.3) of [[QUIC-TRANSPORT](#QUIC-TRANSPORT)] to illustrate the order and size of fields.[¶](#section-2.2-7)

## [3.](#section-3) [Connection Setup and Management](#name-connection-setup-and-manage)

### [3.1.](#section-3.1) [Discovering an HTTP/3 Endpoint](#name-discovering-an-http-3-endpo)

HTTP relies on the notion of an authoritative response: a response that has been
determined to be the most appropriate response for that request given the state
of the target resource at the time of response message origination by (or at the
direction of) the origin server identified within the target URI. Locating an
authoritative server for an HTTP URI is discussed in [Section 4.3](https://www.rfc-editor.org/rfc/rfc9110#section-4.3) of [[HTTP](#RFC9110)].[¶](#section-3.1-1)

The "https" scheme associates authority with possession of a certificate that
the client considers to be trustworthy for the host identified by the authority
component of the URI. Upon receiving a server certificate in the TLS handshake,
the client MUST
verify that the certificate is an acceptable match for the URI's
origin server using the process described in [Section 4.3.4](https://www.rfc-editor.org/rfc/rfc9110#section-4.3.4) of [[HTTP](#RFC9110)]. If
the certificate cannot be verified with respect to the URI's origin server, the
client MUST NOT
consider the server authoritative for that origin.[¶](#section-3.1-2)

A client MAY
attempt access to a resource with an "https" URI by resolving the
host identifier to an IP address, establishing a QUIC connection to that address
on the indicated port (including validation of the server certificate as
described above), and sending an HTTP/3 request message targeting the URI
to the server over that secured connection. Unless some other mechanism is used
to select HTTP/3, the token "h3" is used in the Application-Layer Protocol
Negotiation (ALPN; see [[RFC7301](#RFC7301)]) extension during the TLS handshake.[¶](#section-3.1-3)

Connectivity problems (e.g., blocking UDP) can result in a failure to establish
a QUIC connection; clients SHOULD
attempt to use TCP-based versions of HTTP
in this case.[¶](#section-3.1-4)

Servers MAY
serve HTTP/3 on any UDP port; an alternative service advertisement
always includes an explicit port, and URIs contain either an explicit port or a
default port associated with the scheme.[¶](#section-3.1-5)

#### [3.1.1.](#section-3.1.1) [HTTP Alternative Services](#name-http-alternative-services)

An HTTP origin can advertise the availability of an equivalent HTTP/3 endpoint
via the Alt-Svc HTTP response header field or the HTTP/2 ALTSVC frame
([[ALTSVC](#ALTSVC)]) using the "h3" ALPN token.[¶](#section-3.1.1-1)

For example, an origin could indicate in an HTTP response that HTTP/3 was
available on UDP port 50781 at the same hostname by including the following
header field:[¶](#section-3.1.1-2)

```

Alt-Svc: h3=":50781"

```
[¶](#section-3.1.1-3)

On receipt of an Alt-Svc record indicating HTTP/3 support, a client MAY
attempt
to establish a QUIC connection to the indicated host and port; if this
connection is successful, the client can send HTTP requests using the mapping
described in this document.[¶](#section-3.1.1-4)

#### [3.1.2.](#section-3.1.2) [Other Schemes](#name-other-schemes)

Although HTTP is independent of the transport protocol, the "http" scheme
associates authority with the ability to receive TCP connections on the
indicated port of whatever host is identified within the authority component.
Because HTTP/3 does not use TCP, HTTP/3 cannot be used for direct access to the
authoritative server for a resource identified by an "http" URI. However,
protocol extensions such as [[ALTSVC](#ALTSVC)] permit the authoritative server
to identify other services that are also authoritative and that might be
reachable over HTTP/3.[¶](#section-3.1.2-1)

Prior to making requests for an origin whose scheme is not "https", the client MUST
ensure the server is willing to serve that scheme. For origins whose scheme
is "http", an experimental method to accomplish this is described in
[[RFC8164](#RFC8164)]. Other mechanisms might be defined for various schemes in the
future.[¶](#section-3.1.2-2)

### [3.2.](#section-3.2) [Connection Establishment](#name-connection-establishment)

HTTP/3 relies on QUIC version 1 as the underlying transport. The use of other
QUIC transport versions with HTTP/3 MAY
be defined by future specifications.[¶](#section-3.2-1)

QUIC version 1 uses TLS version 1.3 or greater as its handshake protocol.
HTTP/3 clients MUST
support a mechanism to indicate the target host to the
server during the TLS handshake. If the server is identified by a domain name
([[DNS-TERMS](#DNS-TERMS)]), clients MUST
send the Server Name Indication (SNI;
[[RFC6066](#RFC6066)]) TLS extension unless an alternative mechanism to indicate the
target host is used.[¶](#section-3.2-2)

QUIC connections are established as described in [[QUIC-TRANSPORT](#QUIC-TRANSPORT)]. During
connection establishment, HTTP/3 support is indicated by selecting the ALPN
token "h3" in the TLS handshake. Support for other application-layer protocols MAY
be offered in the same handshake.[¶](#section-3.2-3)

While connection-level options pertaining to the core QUIC protocol are set in
the initial crypto handshake, settings specific to HTTP/3 are conveyed in the
[SETTINGS](#frame-settings) frame. After the QUIC connection is established, a
[SETTINGS](#frame-settings) frame MUST
be sent by each endpoint as the initial frame of their
respective HTTP [control stream](#control-streams).[¶](#section-3.2-4)

### [3.3.](#section-3.3) [Connection Reuse](#name-connection-reuse)

HTTP/3 connections are persistent across multiple requests. For best
performance, it is expected that clients will not close connections until it is
determined that no further communication with a server is necessary (for
example, when a user navigates away from a particular web page) or until the
server closes the connection.[¶](#section-3.3-1)

Once a connection to a server endpoint exists, this connection MAY
be reused for
requests with multiple different URI authority components. To use an existing
connection for a new origin, clients MUST
validate the certificate presented by
the server for the new origin server using the process described in [Section 4.3.4](https://www.rfc-editor.org/rfc/rfc9110#section-4.3.4) of [[HTTP](#RFC9110)]. This implies that clients will need to retain the
server certificate and any additional information needed to verify that
certificate; clients that do not do so will be unable to reuse the connection
for additional origins.[¶](#section-3.3-2)

If the certificate is not acceptable with regard to the new origin for any
reason, the connection MUST NOT
be reused and a new connection SHOULD
be
established for the new origin. If the reason the certificate cannot be
verified might apply to other origins already associated with the connection,
the client SHOULD
revalidate the server certificate for those origins. For
instance, if validation of a certificate fails because the certificate has
expired or been revoked, this might be used to invalidate all other origins for
which that certificate was used to establish authority.[¶](#section-3.3-3)

Clients SHOULD NOT
open more than one HTTP/3 connection to a given IP address
and UDP port, where the IP address and port might be derived from a URI, a
selected alternative service ([[ALTSVC](#ALTSVC)]), a configured proxy, or name
resolution of any of these. A client MAY
open multiple HTTP/3 connections to the
same IP address and UDP port using different transport or TLS configurations but SHOULD
avoid creating multiple connections with the same configuration.[¶](#section-3.3-4)

Servers are encouraged to maintain open HTTP/3 connections for as long as
possible but are permitted to terminate idle connections if necessary. When
either endpoint chooses to close the HTTP/3 connection, the terminating endpoint SHOULD
first send a [GOAWAY](#frame-goaway) frame ([Section 5.2](#connection-shutdown)) so that both
endpoints can reliably determine whether previously sent frames have been
processed and gracefully complete or terminate any necessary remaining tasks.[¶](#section-3.3-5)

A server that does not wish clients to reuse HTTP/3 connections for a particular
origin can indicate that it is not authoritative for a request by sending a 421
(Misdirected Request) status code in response to the request; see [Section 7.4](https://www.rfc-editor.org/rfc/rfc9110#section-7.4) of [[HTTP](#RFC9110)].[¶](#section-3.3-6)

## [4.](#section-4) [Expressing HTTP Semantics in HTTP/3](#name-expressing-http-semantics-i)

### [4.1.](#section-4.1) [HTTP Message Framing](#name-http-message-framing)

A client sends an HTTP request on a [request stream](#request-streams), which is a client-initiated
bidirectional QUIC stream; see [Section 6.1](#request-streams). A client MUST
send only a
single request on a given stream. A server sends zero or more interim HTTP
responses on the same stream as the request, followed by a single final HTTP
response, as detailed below. See [Section 15](https://www.rfc-editor.org/rfc/rfc9110#section-15) of [[HTTP](#RFC9110)] for a description
of interim and final HTTP responses.[¶](#section-4.1-1)

Pushed responses are sent on a server-initiated unidirectional QUIC stream; see
[Section 6.2.2](#push-streams). A server sends zero or more interim HTTP responses, followed
by a single final HTTP response, in the same manner as a standard response.
Push is described in more detail in [Section 4.6](#server-push).[¶](#section-4.1-2)

On a given stream, receipt of multiple requests or receipt of an additional HTTP
response following a final HTTP response MUST
be treated as [malformed](#malformed).[¶](#section-4.1-3)

An HTTP message (request or response) consists of:[¶](#section-4.1-4)

1. the header section, including message control data, sent as a single [HEADERS](#frame-headers)
   frame,[¶](#section-4.1-5.1)
2. optionally, the content, if present, sent as a series of [DATA](#frame-data) frames, and[¶](#section-4.1-5.2)
3. optionally, the trailer section, if present, sent as a single [HEADERS](#frame-headers) frame.[¶](#section-4.1-5.3)

Header and trailer sections are described in Sections [6.3](https://www.rfc-editor.org/rfc/rfc9110#section-6.3) and [6.5](https://www.rfc-editor.org/rfc/rfc9110#section-6.5) of [[HTTP](#RFC9110)]; the content is described in [Section 6.4](https://www.rfc-editor.org/rfc/rfc9110#section-6.4) of [[HTTP](#RFC9110)].[¶](#section-4.1-6)

Receipt of an invalid sequence of frames MUST
be treated as a [connection error](#errors)
of type [H3\_FRAME\_UNEXPECTED](#H3_FRAME_UNEXPECTED). In particular, a [DATA](#frame-data) frame before
any [HEADERS](#frame-headers) frame, or a [HEADERS](#frame-headers) or [DATA](#frame-data) frame after the trailing [HEADERS](#frame-headers) frame,
is considered invalid. Other frame types, especially unknown frame types,
might be permitted subject to their own rules; see [Section 9](#extensions).[¶](#section-4.1-7)

A server MAY
send one or more [PUSH\_PROMISE](#frame-push-promise) frames
before, after, or interleaved with the frames of a response message. These
[PUSH\_PROMISE](#frame-push-promise) frames are not part of the response; see [Section 4.6](#server-push) for more
details. [PUSH\_PROMISE](#frame-push-promise) frames are not permitted on [push streams](#push-streams); a pushed
response that includes [PUSH\_PROMISE](#frame-push-promise) frames MUST
be treated as a [connection error](#errors)
of type [H3\_FRAME\_UNEXPECTED](#H3_FRAME_UNEXPECTED).[¶](#section-4.1-8)

Frames of unknown types ([Section 9](#extensions)), including reserved frames
([Section 7.2.8](#frame-reserved)) MAY
be sent on a request or [push stream](#push-streams) before, after, or
interleaved with other frames described in this section.[¶](#section-4.1-9)

The [HEADERS](#frame-headers) and [PUSH\_PROMISE](#frame-push-promise) frames might reference updates to the QPACK dynamic
table. While these updates are not directly part of the message exchange, they
must be received and processed before the message can be consumed. See
[Section 4.2](#header-formatting) for more details.[¶](#section-4.1-10)

Transfer codings (see [Section 7](https://www.rfc-editor.org/rfc/rfc9112#section-7) of [[HTTP/1.1](#RFC9112)]) are not defined for HTTP/3;
the Transfer-Encoding header field MUST NOT
be used.[¶](#section-4.1-11)

A response MAY
consist of multiple messages when and only when one or more
interim responses (1xx; see [Section 15.2](https://www.rfc-editor.org/rfc/rfc9110#section-15.2) of [[HTTP](#RFC9110)]) precede a final
response to the same request. Interim responses do not contain content
or trailer sections.[¶](#section-4.1-12)

An HTTP request/response exchange fully consumes a client-initiated
bidirectional QUIC stream. After sending a request, a client MUST
close the
stream for sending. Unless using the CONNECT method (see [Section 4.4](#connect)), clients MUST NOT
make stream closure dependent on receiving a response to their request.
After sending a final response, the server MUST
close the stream for sending. At
this point, the QUIC stream is fully closed.[¶](#section-4.1-13)

When a stream is closed, this indicates the end of the final HTTP message.
Because some messages are large or unbounded, endpoints SHOULD
begin processing
partial HTTP messages once enough of the message has been received to make
progress. If a client-initiated stream terminates without enough of the HTTP
message to provide a complete response, the server SHOULD
abort its response
stream with the error code [H3\_REQUEST\_INCOMPLETE](#H3_REQUEST_INCOMPLETE).[¶](#section-4.1-14)

A server can send a complete response prior to the client sending an entire
request if the response does not depend on any portion of the request that has
not been sent and received. When the server does not need to receive the
remainder of the request, it MAY
abort reading the [request stream](#request-streams), send a
complete response, and cleanly close the sending part of the stream. The error
code [H3\_NO\_ERROR](#H3_NO_ERROR) SHOULD
be used when requesting that the client stop sending on
the [request stream](#request-streams). Clients MUST NOT
discard complete responses as a result of
having their request terminated abruptly, though clients can always discard
responses at their discretion for other reasons. If the server sends a partial
or complete response but does not abort reading the request, clients SHOULD
continue sending the content of the request and close the stream normally.[¶](#section-4.1-15)

#### [4.1.1.](#section-4.1.1) [Request Cancellation and Rejection](#name-request-cancellation-and-re)

Once a [request stream](#request-streams) has been opened, the request MAY
be cancelled by either
endpoint. Clients cancel requests if the response is no longer of interest;
servers cancel requests if they are unable to or choose not to respond. When
possible, it is RECOMMENDED
that servers send an HTTP response with an
appropriate status code rather than cancelling a request it has already begun
processing.[¶](#section-4.1.1-1)

Implementations SHOULD
cancel requests by abruptly terminating any directions of
a stream that are still open. To do so, an implementation resets the sending
parts of streams and aborts reading on the receiving parts of streams; see
[Section 2.4](https://www.rfc-editor.org/rfc/rfc9000#section-2.4) of [[QUIC-TRANSPORT](#QUIC-TRANSPORT)].[¶](#section-4.1.1-2)

When the server cancels a request without performing any application processing,
the request is considered "rejected". The server SHOULD
abort its response
stream with the error code [H3\_REQUEST\_REJECTED](#H3_REQUEST_REJECTED). In this context, "processed"
means that some data from the stream was passed to some higher layer of software
that might have taken some action as a result. The client can treat requests
rejected by the server as though they had never been sent at all, thereby
allowing them to be retried later.[¶](#section-4.1.1-3)

Servers MUST NOT
use the [H3\_REQUEST\_REJECTED](#H3_REQUEST_REJECTED) error code for requests that were
partially or fully processed. When a server abandons a response after partial
processing, it SHOULD
abort its response stream with the error code
[H3\_REQUEST\_CANCELLED](#H3_REQUEST_CANCELLED).[¶](#section-4.1.1-4)

Client SHOULD
use the error code [H3\_REQUEST\_CANCELLED](#H3_REQUEST_CANCELLED) to cancel requests. Upon
receipt of this error code, a server MAY
abruptly terminate the response using
the error code [H3\_REQUEST\_REJECTED](#H3_REQUEST_REJECTED) if no processing was performed. Clients MUST NOT
use the [H3\_REQUEST\_REJECTED](#H3_REQUEST_REJECTED) error code, except when a server has requested
closure of the [request stream](#request-streams) with this error code.[¶](#section-4.1.1-5)

If a stream is cancelled after receiving a complete response, the client MAY
ignore the cancellation and use the response. However, if a stream is cancelled
after receiving a partial response, the response SHOULD NOT
be used. Only
idempotent actions such as GET, PUT, or DELETE can be safely retried; a client SHOULD NOT
automatically retry a request with a non-idempotent method unless it
has some means to know that the request semantics are idempotent
independent of the method or some means to detect that the original request was
never applied. See [Section 9.2.2](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.2) of [[HTTP](#RFC9110)] for more details.[¶](#section-4.1.1-6)

#### [4.1.2.](#section-4.1.2) [Malformed Requests and Responses](#name-malformed-requests-and-resp)

A malformed request or response is one that is an otherwise valid sequence of
frames but is invalid due to:[¶](#section-4.1.2-1)

* the presence of prohibited fields or pseudo-header fields,[¶](#section-4.1.2-2.1)
* the absence of mandatory pseudo-header fields,[¶](#section-4.1.2-2.2)
* invalid values for pseudo-header fields,[¶](#section-4.1.2-2.3)
* pseudo-header fields after fields,[¶](#section-4.1.2-2.4)
* an invalid sequence of HTTP messages,[¶](#section-4.1.2-2.5)
* the inclusion of uppercase field names, or[¶](#section-4.1.2-2.6)
* the inclusion of invalid characters in field names or values.[¶](#section-4.1.2-2.7)

A request or response that is defined as having content when it contains a
Content-Length header field ([Section 8.6](https://www.rfc-editor.org/rfc/rfc9110#section-8.6) of [[HTTP](#RFC9110)]) is malformed if the
value of the Content-Length header field does not equal the sum of the [DATA](#frame-data)
frame lengths received. A response that is defined as never having content, even
when a Content-Length is present, can have a non-zero Content-Length header
field even though no content is included in [DATA](#frame-data) frames.[¶](#section-4.1.2-3)

Intermediaries that process HTTP requests or responses (i.e., any intermediary
not acting as a tunnel) MUST NOT
forward a malformed request or response.
Malformed requests or responses that are detected MUST
be treated as a [stream
error](#errors) of type [H3\_MESSAGE\_ERROR](#H3_MESSAGE_ERROR).[¶](#section-4.1.2-4)

For malformed requests, a server MAY
send an HTTP response indicating the error
prior to closing or resetting the stream. Clients MUST NOT
accept a malformed
response. Note that these requirements are intended to protect against several
types of common attacks against HTTP; they are deliberately strict because being
permissive can expose implementations to these vulnerabilities.[¶](#section-4.1.2-5)

### [4.2.](#section-4.2) [HTTP Fields](#name-http-fields)

HTTP messages carry metadata as a series of key-value pairs called "HTTP
fields"; see Sections [6.3](https://www.rfc-editor.org/rfc/rfc9110#section-6.3) and [6.5](https://www.rfc-editor.org/rfc/rfc9110#section-6.5) of [[HTTP](#RFC9110)]. For a listing of registered
HTTP fields, see the "Hypertext Transfer Protocol (HTTP) Field Name Registry"
maintained at <<https://www.iana.org/assignments/http-fields/>>. Like HTTP/2, HTTP/3 has additional considerations related to
the use of characters in field names, the Connection header field, and
pseudo-header fields.[¶](#section-4.2-1)

Field names are strings containing a subset of ASCII characters. Properties of
HTTP field names and values are discussed in more detail in [Section 5.1](https://www.rfc-editor.org/rfc/rfc9110#section-5.1) of [[HTTP](#RFC9110)]. Characters in field names MUST
be converted to lowercase prior to
their encoding. A request or response containing uppercase characters in field
names MUST
be treated as [malformed](#malformed).[¶](#section-4.2-2)

HTTP/3 does not use the Connection header field to indicate connection-specific
fields; in this protocol, connection-specific metadata is conveyed by other
means. An endpoint MUST NOT
generate an HTTP/3 field section containing
connection-specific fields; any message containing connection-specific fields MUST
be treated as [malformed](#malformed).[¶](#section-4.2-3)

The only exception to this is the TE header field, which MAY
be present in an
HTTP/3 request header; when it is, it MUST NOT
contain any value other than
"trailers".[¶](#section-4.2-4)

An intermediary transforming an HTTP/1.x message to HTTP/3 MUST
remove
connection-specific header fields as discussed in [Section 7.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.6.1) of [[HTTP](#RFC9110)], or their messages will be treated by other HTTP/3 endpoints as
[malformed](#malformed).[¶](#section-4.2-5)

#### [4.2.1.](#section-4.2.1) [Field Compression](#name-field-compression)

[[QPACK](#RFC9204)] describes a variation of HPACK that gives an encoder some control
over how much head-of-line blocking can be caused by compression. This allows
an encoder to balance compression efficiency with latency. HTTP/3 uses QPACK to
compress header and trailer sections, including the control data present in the
header section.[¶](#section-4.2.1-1)

To allow for better compression efficiency, the Cookie header field
([[COOKIES](#COOKIES)]) MAY
be split into separate field lines, each with one or
more cookie-pairs, before compression. If a decompressed field section contains
multiple cookie field lines, these MUST
be concatenated into a single byte
string using the two-byte delimiter of "`;`" (ASCII 0x3b, 0x20) before being
passed into a context other than HTTP/2 or HTTP/3, such as an HTTP/1.1
connection, or a generic HTTP server application.[¶](#section-4.2.1-2)

#### [4.2.2.](#section-4.2.2) [Header Size Constraints](#name-header-size-constraints)

An HTTP/3 implementation MAY
impose a limit on the maximum size of the message
header it will accept on an individual HTTP message. A server that receives a
larger header section than it is willing to handle can send an HTTP 431 (Request
Header Fields Too Large) status code ([[RFC6585](#RFC6585)]). A client can discard
responses that it cannot process. The size of a field list is calculated based
on the uncompressed size of fields, including the length of the name and value
in bytes plus an overhead of 32 bytes for each field.[¶](#section-4.2.2-1)

If an implementation wishes to advise its peer of this limit, it can be conveyed
as a number of bytes in the [SETTINGS\_MAX\_FIELD\_SECTION\_SIZE](#SETTINGS_MAX_FIELD_SECTION_SIZE) parameter. An
implementation that has received this parameter SHOULD NOT
send an HTTP message
header that exceeds the indicated size, as the peer will likely refuse to
process it. However, an HTTP message can traverse one or more intermediaries
before reaching the origin server; see [Section 3.7](https://www.rfc-editor.org/rfc/rfc9110#section-3.7) of [[HTTP](#RFC9110)]. Because
this limit is applied separately by each implementation that processes the
message, messages below this limit are not guaranteed to be accepted.[¶](#section-4.2.2-2)

### [4.3.](#section-4.3) [HTTP Control Data](#name-http-control-data)

Like HTTP/2, HTTP/3 employs a series of pseudo-header fields, where the field
name begins with the `:` character (ASCII 0x3a). These pseudo-header fields
convey message control data; see [Section 6.2](https://www.rfc-editor.org/rfc/rfc9110#section-6.2) of [[HTTP](#RFC9110)].[¶](#section-4.3-1)

Pseudo-header fields are not HTTP fields. Endpoints MUST NOT
generate
pseudo-header fields other than those defined in this document. However, an
extension could negotiate a modification of this restriction; see
[Section 9](#extensions).[¶](#section-4.3-2)

Pseudo-header fields are only valid in the context in which they are defined.
Pseudo-header fields defined for requests MUST NOT
appear in responses;
pseudo-header fields defined for responses MUST NOT
appear in requests.
Pseudo-header fields MUST NOT
appear in trailer sections. Endpoints MUST
treat a
request or response that contains undefined or invalid pseudo-header fields as
[malformed](#malformed).[¶](#section-4.3-3)

All pseudo-header fields MUST
appear in the header section before regular header
fields. Any request or response that contains a pseudo-header field that
appears in a header section after a regular header field MUST
be treated as
[malformed](#malformed).[¶](#section-4.3-4)

#### [4.3.1.](#section-4.3.1) [Request Pseudo-Header Fields](#name-request-pseudo-header-field)

The following pseudo-header fields are defined for requests:[¶](#section-4.3.1-1)

":method":

Contains the HTTP method ([Section 9](https://www.rfc-editor.org/rfc/rfc9110#section-9) of [[HTTP](#RFC9110)])[¶](#section-4.3.1-2.2.1)

":scheme":

Contains the scheme portion of the target URI ([Section 3.1](https://www.rfc-editor.org/rfc/rfc3986#section-3.1) of [[URI](#URI)]).[¶](#section-4.3.1-2.4.1)

The :scheme pseudo-header is not restricted to URIs with scheme "http" and
"https". A proxy or gateway can translate requests for non-HTTP schemes,
enabling the use of HTTP to interact with non-HTTP services.[¶](#section-4.3.1-2.6.1)

See [Section 3.1.2](#other-schemes) for guidance on using a scheme other than "https".[¶](#section-4.3.1-2.8.1)

":authority":

Contains the authority portion of the target URI ([Section 3.2](https://www.rfc-editor.org/rfc/rfc3986#section-3.2) of [[URI](#URI)]).
The authority MUST NOT
include the deprecated userinfo
subcomponent for URIs of scheme "http" or "https".[¶](#section-4.3.1-2.10.1)

To ensure that the HTTP/1.1 request line can be reproduced accurately, this
pseudo-header field MUST
be omitted when translating from an HTTP/1.1
request that has a request target in a method-specific form; see [Section 7.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.1) of [[HTTP](#RFC9110)]. Clients that generate HTTP/3 requests directly SHOULD
use
the :authority pseudo-header field instead of the Host header field. An
intermediary that converts an HTTP/3 request to HTTP/1.1 MUST
create a Host
field if one is not present in a request by copying the value of the
:authority pseudo-header field.[¶](#section-4.3.1-2.12.1)

":path":

Contains the path and query parts of the target URI (the "path-absolute"
production and optionally a `?` character (ASCII 0x3f) followed by the
"query" production; see Sections [3.3](https://www.rfc-editor.org/rfc/rfc3986#section-3.3) and [3.4](https://www.rfc-editor.org/rfc/rfc3986#section-3.4) of [[URI](#URI)].[¶](#section-4.3.1-2.14.1)

This pseudo-header field MUST NOT
be empty for "http" or "https" URIs;
"http" or "https" URIs that do not contain a path component MUST
include a
value of `/` (ASCII 0x2f). An OPTIONS request that does not include a path
component includes the value `*` (ASCII 0x2a) for the :path pseudo-header
field; see [Section 7.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.1) of [[HTTP](#RFC9110)].[¶](#section-4.3.1-2.16.1)

All HTTP/3 requests MUST
include exactly one value for the :method, :scheme,
and :path pseudo-header fields, unless the request is a CONNECT request; see
[Section 4.4](#connect).[¶](#section-4.3.1-3)

If the :scheme pseudo-header field identifies a scheme that has a mandatory
authority component (including "http" and "https"), the request MUST
contain
either an :authority pseudo-header field or a Host header field. If these
fields are present, they MUST NOT
be empty. If both fields are present, they MUST
contain the same value. If the scheme does not have a mandatory authority
component and none is provided in the request target, the request MUST NOT
contain the :authority pseudo-header or Host header fields.[¶](#section-4.3.1-4)

An HTTP request that omits mandatory pseudo-header fields or contains invalid
values for those pseudo-header fields is [malformed](#malformed).[¶](#section-4.3.1-5)

HTTP/3 does not define a way to carry the version identifier that is included in
the HTTP/1.1 request line. HTTP/3 requests implicitly have a protocol version
of "3.0".[¶](#section-4.3.1-6)

#### [4.3.2.](#section-4.3.2) [Response Pseudo-Header Fields](#name-response-pseudo-header-fiel)

For responses, a single ":status" pseudo-header field is defined that carries
the HTTP status code; see [Section 15](https://www.rfc-editor.org/rfc/rfc9110#section-15) of [[HTTP](#RFC9110)]. This pseudo-header
field MUST
be included in all responses; otherwise, the response is [malformed](#malformed)
(see [Section 4.1.2](#malformed)).[¶](#section-4.3.2-1)

HTTP/3 does not define a way to carry the version or reason phrase that is
included in an HTTP/1.1 status line. HTTP/3 responses implicitly have a protocol
version of "3.0".[¶](#section-4.3.2-2)

### [4.4.](#section-4.4) [The CONNECT Method](#name-the-connect-method)

The CONNECT method requests that the recipient establish a tunnel to the
destination origin server identified by the request-target; see [Section 9.3.6](https://www.rfc-editor.org/rfc/rfc9110#section-9.3.6) of [[HTTP](#RFC9110)]. It is primarily used with HTTP proxies to establish a TLS
session with an origin server for the purposes of interacting with "https"
resources.[¶](#section-4.4-1)

In HTTP/1.x, CONNECT is used to convert an entire HTTP connection into a tunnel
to a remote host. In HTTP/2 and HTTP/3, the CONNECT method is used to establish
a tunnel over a single stream.[¶](#section-4.4-2)

A CONNECT request MUST
be constructed as follows:[¶](#section-4.4-3)

* The :method pseudo-header field is set to "CONNECT"[¶](#section-4.4-4.1)
* The :scheme and :path pseudo-header fields are omitted[¶](#section-4.4-4.2)
* The :authority pseudo-header field contains the host and port to connect to
  (equivalent to the authority-form of the request-target of CONNECT requests;
  see [Section 7.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.1) of [[HTTP](#RFC9110)]).[¶](#section-4.4-4.3)

The [request stream](#request-streams) remains open at the end of the request to carry the data to
be transferred. A CONNECT request that does not conform to these restrictions
is [malformed](#malformed).[¶](#section-4.4-5)

A proxy that supports CONNECT establishes a TCP connection ([[RFC0793](#RFC0793)]) to the
server identified in the :authority pseudo-header field. Once this connection
is successfully established, the proxy sends a [HEADERS](#frame-headers) frame containing a 2xx
series status code to the client, as defined in [Section 15.3](https://www.rfc-editor.org/rfc/rfc9110#section-15.3) of [[HTTP](#RFC9110)].[¶](#section-4.4-6)

All [DATA](#frame-data) frames on the stream correspond to data sent or received on the TCP
connection. The payload of any [DATA](#frame-data) frame sent by the client is transmitted by
the proxy to the TCP server; data received from the TCP server is packaged into
[DATA](#frame-data) frames by the proxy. Note that the size and number of TCP segments is not
guaranteed to map predictably to the size and number of HTTP [DATA](#frame-data) or QUIC STREAM
frames.[¶](#section-4.4-7)

Once the CONNECT method has completed, only [DATA](#frame-data) frames are permitted to be sent
on the stream. Extension frames MAY
be used if specifically permitted by the
definition of the extension. Receipt of any other known frame type MUST
be
treated as a [connection error](#errors) of type [H3\_FRAME\_UNEXPECTED](#H3_FRAME_UNEXPECTED).[¶](#section-4.4-8)

The TCP connection can be closed by either peer. When the client ends the
[request stream](#request-streams) (that is, the receive stream at the proxy enters the "Data Recvd"
state), the proxy will set the FIN bit on its connection to the TCP server. When
the proxy receives a packet with the FIN bit set, it will close the send stream
that it sends to the client. TCP connections that remain half closed in a
single direction are not invalid, but are often handled poorly by servers, so
clients SHOULD NOT
close a stream for sending while they still expect to receive
data from the target of the CONNECT.[¶](#section-4.4-9)

A TCP [connection error](#errors) is signaled by abruptly terminating the stream. A proxy
treats any error in the TCP connection, which includes receiving a TCP segment
with the RST bit set, as a [stream error](#errors) of type [H3\_CONNECT\_ERROR](#H3_CONNECT_ERROR).[¶](#section-4.4-10)

Correspondingly, if a proxy detects an error with the stream or the QUIC
connection, it MUST
close the TCP connection. If the proxy detects that the
client has reset the stream or aborted reading from the stream, it MUST
close
the TCP connection. If the stream is reset or reading is aborted by the client,
a proxy SHOULD
perform the same operation on the other direction in order to
ensure that both directions of the stream are cancelled. In all these cases, if
the underlying TCP implementation permits it, the proxy SHOULD
send a TCP
segment with the RST bit set.[¶](#section-4.4-11)

Since CONNECT creates a tunnel to an arbitrary server, proxies that support
CONNECT SHOULD
restrict its use to a set of known ports or a list of safe
request targets; see [Section 9.3.6](https://www.rfc-editor.org/rfc/rfc9110#section-9.3.6) of [[HTTP](#RFC9110)] for more details.[¶](#section-4.4-12)

### [4.5.](#section-4.5) [HTTP Upgrade](#name-http-upgrade)

HTTP/3 does not support the HTTP Upgrade mechanism ([Section 7.8](https://www.rfc-editor.org/rfc/rfc9110#section-7.8) of [[HTTP](#RFC9110)]) or the 101 (Switching Protocols) informational status code
([Section 15.2.2](https://www.rfc-editor.org/rfc/rfc9110#section-15.2.2) of [[HTTP](#RFC9110)]).[¶](#section-4.5-1)

### [4.6.](#section-4.6) [Server Push](#name-server-push)

Server push is an interaction mode that permits a server to push a
request-response exchange to a client in anticipation of the client making the
indicated request. This trades off network usage against a potential latency
gain. HTTP/3 server push is similar to what is described in
[Section 8.2](https://www.rfc-editor.org/rfc/rfc9113#section-8.2) of [[HTTP/2](#RFC9113)], but it uses different mechanisms.[¶](#section-4.6-1)

Each server push is assigned a unique push ID by the server. The push ID is
used to refer to the push in various contexts throughout the lifetime of the
HTTP/3 connection.[¶](#section-4.6-2)

The push ID space begins at zero and ends at a maximum value set by the
[MAX\_PUSH\_ID](#frame-max-push-id) frame. In particular, a server is not
able to push until after the client sends a [MAX\_PUSH\_ID](#frame-max-push-id) frame. A client sends
[MAX\_PUSH\_ID](#frame-max-push-id) frames to control the number of pushes that a server can promise. A
server SHOULD
use push IDs sequentially, beginning from zero. A client MUST
treat receipt of a [push stream](#push-streams) as a [connection error](#errors) of type [H3\_ID\_ERROR](#H3_ID_ERROR)
when no [MAX\_PUSH\_ID](#frame-max-push-id) frame has been sent or when the stream
references a push ID that is greater than the maximum push ID.[¶](#section-4.6-3)

The push ID is used in one or more [PUSH\_PROMISE](#frame-push-promise) frames that carry the control
data and header fields of the request message. These frames are sent on the
[request stream](#request-streams) that generated the push. This allows the server push to be
associated with a client request. When the same push ID is promised on multiple
[request streams](#request-streams), the decompressed request field sections MUST
contain the same
fields in the same order, and both the name and the value in each field MUST
be
identical.[¶](#section-4.6-4)

The push ID is then included with the [push stream](#push-streams) that ultimately fulfills
those promises. The [push stream](#push-streams) identifies the push ID of
the promise that it fulfills, then contains a response to the promised request
as described in [Section 4.1](#request-response).[¶](#section-4.6-5)

Finally, the push ID can be used in [CANCEL\_PUSH](#frame-cancel-push) frames; see
[Section 7.2.3](#frame-cancel-push). Clients use this frame to indicate they do not wish to
receive a promised resource. Servers use this frame to indicate they will not
be fulfilling a previous promise.[¶](#section-4.6-6)

Not all requests can be pushed. A server MAY
push requests that have the
following properties:[¶](#section-4.6-7)

* cacheable; see [Section 9.2.3](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.3) of [[HTTP](#RFC9110)][¶](#section-4.6-8.1)
* safe; see [Section 9.2.1](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.1) of [[HTTP](#RFC9110)][¶](#section-4.6-8.2)
* does not include request content or a trailer section[¶](#section-4.6-8.3)

The server MUST
include a value in the :authority pseudo-header field for
which the server is authoritative. If the client has not yet validated the
connection for the origin indicated by the pushed request, it MUST
perform the
same verification process it would do before sending a request for that origin
on the connection; see [Section 3.3](#connection-reuse). If this verification fails,
the client MUST NOT
consider the server authoritative for that origin.[¶](#section-4.6-9)

Clients SHOULD
send a [CANCEL\_PUSH](#frame-cancel-push) frame upon receipt of a [PUSH\_PROMISE](#frame-push-promise) frame
carrying a request that is not cacheable, is not known to be safe, that
indicates the presence of request content, or for which it does not consider the
server authoritative. Any corresponding responses MUST NOT
be used or cached.[¶](#section-4.6-10)

Each pushed response is associated with one or more client requests. The push
is associated with the [request stream](#request-streams) on which the [PUSH\_PROMISE](#frame-push-promise) frame was
received. The same server push can be associated with additional client
requests using a [PUSH\_PROMISE](#frame-push-promise) frame with the same push ID on multiple [request
streams](#request-streams). These associations do not affect the operation of the protocol, but
they MAY
be considered by user agents when deciding how to use pushed resources.[¶](#section-4.6-11)

Ordering of a [PUSH\_PROMISE](#frame-push-promise) frame in relation to certain parts of the response is
important. The server SHOULD
send [PUSH\_PROMISE](#frame-push-promise) frames prior to sending [HEADERS](#frame-headers)
or [DATA](#frame-data) frames that reference the promised responses. This reduces the chance
that a client requests a resource that will be pushed by the server.[¶](#section-4.6-12)

Due to reordering, [push stream](#push-streams) data can arrive before the corresponding
[PUSH\_PROMISE](#frame-push-promise) frame. When a client receives a new [push stream](#push-streams) with an
as-yet-unknown push ID, both the associated client request and the pushed
request header fields are unknown. The client can buffer the stream data in
expectation of the matching [PUSH\_PROMISE](#frame-push-promise). The client can use stream flow control
([Section 4.1](https://www.rfc-editor.org/rfc/rfc9000#section-4.1) of [[QUIC-TRANSPORT](#QUIC-TRANSPORT)]) to limit the amount of data a server may
commit to the pushed stream. Clients SHOULD
abort reading and discard data
already read from [push streams](#push-streams) if no corresponding [PUSH\_PROMISE](#frame-push-promise) frame is
processed in a reasonable amount of time.[¶](#section-4.6-13)

Push stream data can also arrive after a client has cancelled a push. In this
case, the client can abort reading the stream with an error code of
[H3\_REQUEST\_CANCELLED](#H3_REQUEST_CANCELLED). This asks the server not to transfer additional data and
indicates that it will be discarded upon receipt.[¶](#section-4.6-14)

Pushed responses that are cacheable (see [Section 3](https://www.rfc-editor.org/rfc/rfc9111#section-3) of [[HTTP-CACHING](#RFC9111)]) can be
stored by the client, if it implements an HTTP cache. Pushed responses are
considered successfully validated on the origin server (e.g., if the "no-cache"
cache response directive is present; see [Section 5.2.2.4](https://www.rfc-editor.org/rfc/rfc9111#section-5.2.2.4) of [[HTTP-CACHING](#RFC9111)]) at the
time the pushed response is received.[¶](#section-4.6-15)

Pushed responses that are not cacheable MUST NOT
be stored by any HTTP cache.
They MAY
be made available to the application separately.[¶](#section-4.6-16)

## [5.](#section-5) [Connection Closure](#name-connection-closure)

Once established, an HTTP/3 connection can be used for many requests and
responses over time until the connection is closed. Connection closure can
happen in any of several different ways.[¶](#section-5-1)

### [5.1.](#section-5.1) [Idle Connections](#name-idle-connections)

Each QUIC endpoint declares an idle timeout during the handshake. If the QUIC
connection remains idle (no packets received) for longer than this duration, the
peer will assume that the connection has been closed. HTTP/3 implementations
will need to open a new HTTP/3 connection for new requests if the existing
connection has been idle for longer than the idle timeout negotiated during the
QUIC handshake, and they SHOULD
do so if approaching the idle timeout; see
[Section 10.1](https://www.rfc-editor.org/rfc/rfc9000#section-10.1) of [[QUIC-TRANSPORT](#QUIC-TRANSPORT)].[¶](#section-5.1-1)

HTTP clients are expected to request that the transport keep connections open
while there are responses outstanding for requests or server pushes, as
described in [Section 10.1.2](https://www.rfc-editor.org/rfc/rfc9000#section-10.1.2) of [[QUIC-TRANSPORT](#QUIC-TRANSPORT)]. If the client is not
expecting a response from the server, allowing an idle connection to time out is
preferred over expending effort maintaining a connection that might not be
needed. A gateway MAY
maintain connections in anticipation of need rather than
incur the latency cost of connection establishment to servers. Servers SHOULD NOT
actively keep connections open.[¶](#section-5.1-2)

### [5.2.](#section-5.2) [Connection Shutdown](#name-connection-shutdown)

Even when a connection is not idle, either endpoint can decide to stop using the
connection and initiate a graceful connection close. Endpoints initiate the
graceful shutdown of an HTTP/3 connection by sending a [GOAWAY](#frame-goaway) frame. The [GOAWAY](#frame-goaway)
frame contains an identifier that indicates to the receiver the range of
requests or pushes that were or might be processed in this connection. The
server sends a client-initiated bidirectional stream ID; the client sends a [push
ID](#server-push). Requests or pushes with the indicated identifier or greater are rejected
([Section 4.1.1](#request-cancellation)) by the sender of the [GOAWAY](#frame-goaway). This identifier MAY
be
zero if no requests or pushes were processed.[¶](#section-5.2-1)

The information in the [GOAWAY](#frame-goaway) frame enables a client and server to agree on
which requests or pushes were accepted prior to the shutdown of the HTTP/3
connection. Upon sending a [GOAWAY](#frame-goaway) frame, the endpoint SHOULD
explicitly cancel
(see Sections [4.1.1](#request-cancellation) and [7.2.3](#frame-cancel-push)) any requests
or pushes that have identifiers greater than or equal to the one indicated, in
order to clean up transport state for the affected streams. The endpoint SHOULD
continue to do so as more requests or pushes arrive.[¶](#section-5.2-2)

Endpoints MUST NOT
initiate new requests or promise new pushes on the connection
after receipt of a [GOAWAY](#frame-goaway) frame from the peer. Clients MAY
establish a new
connection to send additional requests.[¶](#section-5.2-3)

Some requests or pushes might already be in transit:[¶](#section-5.2-4)

* Upon receipt of a [GOAWAY](#frame-goaway) frame, if the client has already sent requests with
  a stream ID greater than or equal to the identifier contained in the [GOAWAY](#frame-goaway)
  frame, those requests will not be processed. Clients can safely retry
  unprocessed requests on a different HTTP connection. A client that is
  unable to retry requests loses all requests that are in flight when the
  server closes the connection.[¶](#section-5.2-5.1.1)

  Requests on stream IDs less than the stream ID in a [GOAWAY](#frame-goaway) frame from the
  server might have been processed; their status cannot be known until a
  response is received, the stream is reset individually, another [GOAWAY](#frame-goaway) is
  received with a lower stream ID than that of the request in question,
  or the connection terminates.[¶](#section-5.2-5.1.2)

  Servers MAY
  reject individual requests on streams below the indicated ID if
  these requests were not processed.[¶](#section-5.2-5.1.3)
* If a server receives a [GOAWAY](#frame-goaway) frame after having promised pushes with a [push
  ID](#server-push) greater than or equal to the identifier contained in the [GOAWAY](#frame-goaway) frame,
  those pushes will not be accepted.[¶](#section-5.2-5.2)

Servers SHOULD
send a [GOAWAY](#frame-goaway) frame when the closing of a connection is known
in advance, even if the advance notice is small, so that the remote peer can
know whether or not a request has been partially processed. For example, if an
HTTP client sends a POST at the same time that a server closes a QUIC
connection, the client cannot know if the server started to process that POST
request if the server does not send a [GOAWAY](#frame-goaway) frame to indicate what streams it
might have acted on.[¶](#section-5.2-6)

An endpoint MAY
send multiple [GOAWAY](#frame-goaway) frames indicating different identifiers,
but the identifier in each frame MUST NOT
be greater than the identifier in any
previous frame, since clients might already have retried unprocessed requests on
another HTTP connection. Receiving a [GOAWAY](#frame-goaway) containing a larger identifier than
previously received MUST
be treated as a [connection error](#errors) of type [H3\_ID\_ERROR](#H3_ID_ERROR).[¶](#section-5.2-7)

An endpoint that is attempting to gracefully shut down a connection can send a
[GOAWAY](#frame-goaway) frame with a value set to the maximum possible value (262-4
for servers, 262-1 for clients). This ensures that the peer stops
creating new requests or pushes. After allowing time for any in-flight requests
or pushes to arrive, the endpoint can send another [GOAWAY](#frame-goaway) frame indicating which
requests or pushes it might accept before the end of the connection. This
ensures that a connection can be cleanly shut down without losing requests.[¶](#section-5.2-8)

A client has more flexibility in the value it chooses for the Push ID field in a
[GOAWAY](#frame-goaway) that it sends. A value of 262-1 indicates that the server can
continue fulfilling pushes that have already been promised. A smaller value
indicates the client will reject pushes with push IDs greater than or equal to
this value. Like the server, the client MAY
send subsequent [GOAWAY](#frame-goaway) frames so
long as the specified [push ID](#server-push) is no greater than any previously sent value.[¶](#section-5.2-9)

Even when a [GOAWAY](#frame-goaway) indicates that a given request or push will not be processed
or accepted upon receipt, the underlying transport resources still exist. The
endpoint that initiated these requests can cancel them to clean up transport
state.[¶](#section-5.2-10)

Once all accepted requests and pushes have been processed, the endpoint can
permit the connection to become idle, or it MAY
initiate an immediate closure of
the connection. An endpoint that completes a graceful shutdown SHOULD
use the
[H3\_NO\_ERROR](#H3_NO_ERROR) error code when closing the connection.[¶](#section-5.2-11)

If a client has consumed all available bidirectional stream IDs with requests,
the server need not send a [GOAWAY](#frame-goaway) frame, since the client is unable to make
further requests.[¶](#section-5.2-12)

### [5.3.](#section-5.3) [Immediate Application Closure](#name-immediate-application-closu)

An HTTP/3 implementation can immediately close the QUIC connection at any time.
This results in sending a QUIC CONNECTION\_CLOSE frame to the peer indicating
that the application layer has terminated the connection. The application error
code in this frame indicates to the peer why the connection is being closed.
See [Section 8](#errors) for error codes that can be used when closing a connection in
HTTP/3.[¶](#section-5.3-1)

Before closing the connection, a [GOAWAY](#frame-goaway) frame MAY
be sent to allow the client to
retry some requests. Including the [GOAWAY](#frame-goaway) frame in the same packet as the QUIC
CONNECTION\_CLOSE frame improves the chances of the frame being received by
clients.[¶](#section-5.3-2)

If there are open streams that have not been explicitly closed, they are
implicitly closed when the connection is closed; see
[Section 10.2](https://www.rfc-editor.org/rfc/rfc9000#section-10.2) of [[QUIC-TRANSPORT](#QUIC-TRANSPORT)].[¶](#section-5.3-3)

### [5.4.](#section-5.4) [Transport Closure](#name-transport-closure)

For various reasons, the QUIC transport could indicate to the application layer
that the connection has terminated. This might be due to an explicit closure
by the peer, a transport-level error, or a change in network topology that
interrupts connectivity.[¶](#section-5.4-1)

If a connection terminates without a [GOAWAY](#frame-goaway) frame, clients MUST
assume that any
request that was sent, whether in whole or in part, might have been processed.[¶](#section-5.4-2)

## [6.](#section-6) [Stream Mapping and Usage](#name-stream-mapping-and-usage)

A QUIC stream provides reliable in-order delivery of bytes, but makes no
guarantees about order of delivery with regard to bytes on other streams. In
version 1 of QUIC, the stream data containing HTTP frames is carried by QUIC
STREAM frames, but this framing is invisible to the HTTP framing layer. The
transport layer buffers and orders received stream data, exposing a reliable
byte stream to the application. Although QUIC permits out-of-order delivery
within a stream, HTTP/3 does not make use of this feature.[¶](#section-6-1)

QUIC streams can be either unidirectional, carrying data only from initiator to
receiver, or bidirectional, carrying data in both directions. Streams can be
initiated by either the client or the server. For more detail on QUIC streams,
see [Section 2](https://www.rfc-editor.org/rfc/rfc9000#section-2) of [[QUIC-TRANSPORT](#QUIC-TRANSPORT)].[¶](#section-6-2)

When HTTP fields and data are sent over QUIC, the QUIC layer handles most of
the stream management. HTTP does not need to do any separate multiplexing when
using QUIC: data sent over a QUIC stream always maps to a particular HTTP
transaction or to the entire HTTP/3 connection context.[¶](#section-6-3)

### [6.1.](#section-6.1) [Bidirectional Streams](#name-bidirectional-streams)

All client-initiated bidirectional streams are used for HTTP requests and
responses. A bidirectional stream ensures that the response can be readily
correlated with the request. These streams are referred to as request streams.[¶](#section-6.1-1)

This means that the client's first request occurs on QUIC stream 0, with
subsequent requests on streams 4, 8, and so on. In order to permit these streams
to open, an HTTP/3 server SHOULD
configure non-zero minimum values for the
number of permitted streams and the initial stream flow-control window. So as
to not unnecessarily limit parallelism, at least 100 request streams SHOULD
be
permitted at a time.[¶](#section-6.1-2)

HTTP/3 does not use server-initiated bidirectional streams, though an extension
could define a use for these streams. Clients MUST
treat receipt of a
server-initiated bidirectional stream as a [connection error](#errors) of type
[H3\_STREAM\_CREATION\_ERROR](#H3_STREAM_CREATION_ERROR) unless such an extension has been
negotiated.[¶](#section-6.1-3)

### [6.2.](#section-6.2) [Unidirectional Streams](#name-unidirectional-streams)

Unidirectional streams, in either direction, are used for a range of purposes.
The purpose is indicated by a stream type, which is sent as a variable-length
integer at the start of the stream. The format and structure of data that
follows this integer is determined by the stream type.[¶](#section-6.2-1)

```

Unidirectional Stream Header {
  Stream Type (i),
}

```

[Figure 1](#figure-1):
[Unidirectional Stream Header](#name-unidirectional-stream-heade)

Two stream types are defined in this document: [control streams](#control-streams)
([Section 6.2.1](#control-streams)) and [push streams](#push-streams) ([Section 6.2.2](#push-streams)). [[QPACK](#RFC9204)] defines
two additional stream types. Other stream types can be defined by extensions to
HTTP/3; see [Section 9](#extensions) for more details. Some stream types are reserved
([Section 6.2.3](#stream-grease)).[¶](#section-6.2-3)

The performance of HTTP/3 connections in the early phase of their lifetime is
sensitive to the creation and exchange of data on unidirectional streams.
Endpoints that excessively restrict the number of streams or the flow-control
window of these streams will increase the chance that the remote peer reaches
the limit early and becomes blocked. In particular, implementations should
consider that remote peers may wish to exercise reserved stream behavior
([Section 6.2.3](#stream-grease)) with some of the unidirectional streams they are permitted
to use.[¶](#section-6.2-4)

Each endpoint needs to create at least one unidirectional stream for the HTTP
[control stream](#control-streams). QPACK requires two additional unidirectional streams, and other
extensions might require further streams. Therefore, the transport parameters
sent by both clients and servers MUST
allow the peer to create at least three
unidirectional streams. These transport parameters SHOULD
also provide at least
1,024 bytes of flow-control credit to each unidirectional stream.[¶](#section-6.2-5)

Note that an endpoint is not required to grant additional credits to create more
unidirectional streams if its peer consumes all the initial credits before
creating the critical unidirectional streams. Endpoints SHOULD
create the HTTP
[control stream](#control-streams) as well as the unidirectional streams required by mandatory
extensions (such as the QPACK encoder and decoder streams) first, and then
create additional streams as allowed by their peer.[¶](#section-6.2-6)

If the stream header indicates a stream type that is not supported by the
recipient, the remainder of the stream cannot be consumed as the semantics are
unknown. Recipients of unknown stream types MUST
either abort reading of the
stream or discard incoming data without further processing. If reading is
aborted, the recipient SHOULD
use the [H3\_STREAM\_CREATION\_ERROR](#H3_STREAM_CREATION_ERROR) error code or a
reserved error code ([Section 8.1](#http-error-codes)). The recipient MUST NOT
consider
unknown stream types to be a [connection error](#errors) of any kind.[¶](#section-6.2-7)

As certain stream types can affect connection state, a recipient SHOULD NOT
discard data from incoming unidirectional streams prior to reading the stream
type.[¶](#section-6.2-8)

Implementations MAY
send stream types before knowing whether the peer supports
them. However, stream types that could modify the state or semantics of
existing protocol components, including QPACK or other extensions, MUST NOT
be
sent until the peer is known to support them.[¶](#section-6.2-9)

A sender can close or reset a unidirectional stream unless otherwise specified.
A receiver MUST
tolerate unidirectional streams being closed or reset prior to
the reception of the unidirectional stream header.[¶](#section-6.2-10)

#### [6.2.1.](#section-6.2.1) [Control Streams](#name-control-streams)

A control stream is indicated by a stream type of 0x00. Data on this stream
consists of HTTP/3 frames, as defined in [Section 7.2](#frames).[¶](#section-6.2.1-1)

Each side MUST
initiate a single control stream at the beginning of the
connection and send its [SETTINGS](#frame-settings) frame as the first frame on this stream. If
the first frame of the control stream is any other frame type, this MUST
be
treated as a [connection error](#errors) of type [H3\_MISSING\_SETTINGS](#H3_MISSING_SETTINGS). Only one control
stream per peer is permitted; receipt of a second stream claiming to be a
control stream MUST
be treated as a [connection error](#errors) of type
[H3\_STREAM\_CREATION\_ERROR](#H3_STREAM_CREATION_ERROR). The sender MUST NOT
close the control stream, and the
receiver MUST NOT
request that the sender close the control stream. If either
control stream is closed at any point, this MUST
be treated as a [connection
error](#errors) of type [H3\_CLOSED\_CRITICAL\_STREAM](#H3_CLOSED_CRITICAL_STREAM). Connection errors are described in
[Section 8](#errors).[¶](#section-6.2.1-2)

Because the contents of the control stream are used to manage the behavior of
other streams, endpoints SHOULD
provide enough flow-control credit to keep the
peer's control stream from becoming blocked.[¶](#section-6.2.1-3)

A pair of unidirectional streams is used rather than a single bidirectional
stream. This allows either peer to send data as soon as it is able. Depending
on whether 0-RTT is available on the QUIC connection, either client or server
might be able to send stream data first.[¶](#section-6.2.1-4)

#### [6.2.2.](#section-6.2.2) [Push Streams](#name-push-streams)

Server push is an optional feature introduced in HTTP/2 that allows a server to
initiate a response before a request has been made. See [Section 4.6](#server-push) for
more details.[¶](#section-6.2.2-1)

A push stream is indicated by a stream type of 0x01, followed by the [push ID](#server-push)
of the promise that it fulfills, encoded as a variable-length integer. The
remaining data on this stream consists of HTTP/3 frames, as defined in
[Section 7.2](#frames), and fulfills a promised server push by zero or more interim HTTP
responses followed by a single final HTTP response, as defined in
[Section 4.1](#request-response). Server push and push IDs are described in
[Section 4.6](#server-push).[¶](#section-6.2.2-2)

Only servers can push; if a server receives a client-initiated push stream, this MUST
be treated as a [connection error](#errors) of type [H3\_STREAM\_CREATION\_ERROR](#H3_STREAM_CREATION_ERROR).[¶](#section-6.2.2-3)

```

Push Stream Header {
  Stream Type (i) = 0x01,
  Push ID (i),
}

```

[Figure 2](#figure-2):
[Push Stream Header](#name-push-stream-header)

A client SHOULD NOT
abort reading on a push stream prior to reading the push
stream header, as this could lead to disagreement between client and server on
which push IDs have already been consumed.[¶](#section-6.2.2-5)

Each [push ID](#server-push) MUST
only be used once in a push stream header. If a client detects
that a push stream header includes a [push ID](#server-push) that was used in another push
stream header, the client MUST
treat this as a [connection error](#errors) of type
[H3\_ID\_ERROR](#H3_ID_ERROR).[¶](#section-6.2.2-6)

#### [6.2.3.](#section-6.2.3) [Reserved Stream Types](#name-reserved-stream-types)

Stream types of the format `0x1f * N + 0x21` for non-negative integer values of
`N` are reserved to exercise the requirement that unknown types be ignored.
These streams have no semantics, and they can be sent when application-layer
padding is desired. They MAY
also be sent on connections where no data is
currently being transferred. Endpoints MUST NOT
consider these streams to have
any meaning upon receipt.[¶](#section-6.2.3-1)

The payload and length of the stream are selected in any manner the sending
implementation chooses. When sending a reserved stream type, the implementation MAY
either terminate the stream cleanly or reset it. When resetting the stream,
either the [H3\_NO\_ERROR](#H3_NO_ERROR) error code or a reserved error code
([Section 8.1](#http-error-codes)) SHOULD
be used.[¶](#section-6.2.3-2)

## [7.](#section-7) [HTTP Framing Layer](#name-http-framing-layer)

HTTP frames are carried on QUIC streams, as described in [Section 6](#stream-mapping).
HTTP/3 defines three stream types: [control stream](#control-streams), [request stream](#request-streams), and [push
stream](#push-streams). This section describes HTTP/3 frame formats and their permitted stream
types; see [Table 1](#stream-frame-mapping) for an overview. A comparison between
HTTP/2 and HTTP/3 frames is provided in [Appendix A.2](#h2-frames).[¶](#section-7-1)

[Table 1](#table-1):
[HTTP/3 Frames and Stream Type Overview](#name-http-3-frames-and-stream-ty)

| Frame | Control Stream | Request Stream | Push Stream | Section |
| --- | --- | --- | --- | --- |
| [DATA](#frame-data) | No | Yes | Yes | [Section 7.2.1](#frame-data) |
| [HEADERS](#frame-headers) | No | Yes | Yes | [Section 7.2.2](#frame-headers) |
| [CANCEL\_PUSH](#frame-cancel-push) | Yes | No | No | [Section 7.2.3](#frame-cancel-push) |
| [SETTINGS](#frame-settings) | Yes (1) | No | No | [Section 7.2.4](#frame-settings) |
| [PUSH\_PROMISE](#frame-push-promise) | No | Yes | No | [Section 7.2.5](#frame-push-promise) |
| [GOAWAY](#frame-goaway) | Yes | No | No | [Section 7.2.6](#frame-goaway) |
| [MAX\_PUSH\_ID](#frame-max-push-id) | Yes | No | No | [Section 7.2.7](#frame-max-push-id) |
| Reserved | Yes | Yes | Yes | [Section 7.2.8](#frame-reserved) |

The [SETTINGS](#frame-settings) frame can only occur as the first frame of a Control stream; this
is indicated in [Table 1](#stream-frame-mapping) with a (1). Specific guidance
is provided in the relevant section.[¶](#section-7-3)

Note that, unlike QUIC frames, HTTP/3 frames can span multiple packets.[¶](#section-7-4)

### [7.1.](#section-7.1) [Frame Layout](#name-frame-layout)

All frames have the following format:[¶](#section-7.1-1)

```

HTTP/3 Frame Format {
  Type (i),
  Length (i),
  Frame Payload (..),
}

```

[Figure 3](#figure-3):
[HTTP/3 Frame Format](#name-http-3-frame-format)

A frame includes the following fields:[¶](#section-7.1-3)

Type:

A variable-length integer that identifies the frame type.[¶](#section-7.1-4.2.1)

Length:

A variable-length integer that describes the length in bytes of
the Frame Payload.[¶](#section-7.1-4.4.1)

Frame Payload:

A payload, the semantics of which are determined by the Type field.[¶](#section-7.1-4.6.1)

Each frame's payload MUST
contain exactly the fields identified in its
description. A frame payload that contains additional bytes after the
identified fields or a frame payload that terminates before the end of the
identified fields MUST
be treated as a [connection error](#errors) of type
[H3\_FRAME\_ERROR](#H3_FRAME_ERROR). In particular, redundant length encodings MUST
be verified to be self-consistent; see [Section 10.8](#frame-parsing).[¶](#section-7.1-5)

When a stream terminates cleanly, if the last frame on the stream was truncated,
this MUST
be treated as a [connection error](#errors) of type [H3\_FRAME\_ERROR](#H3_FRAME_ERROR). Streams that
terminate abruptly may be reset at any point in a frame.[¶](#section-7.1-6)

### [7.2.](#section-7.2) [Frame Definitions](#name-frame-definitions)

#### [7.2.1.](#section-7.2.1) [DATA](#name-data)

DATA frames (type=0x00) convey arbitrary, variable-length sequences of bytes
associated with HTTP request or response content.[¶](#section-7.2.1-1)

DATA frames MUST
be associated with an HTTP request or response. If a DATA
frame is received on a [control stream](#control-streams), the recipient MUST
respond with a
[connection error](#errors) of type [H3\_FRAME\_UNEXPECTED](#H3_FRAME_UNEXPECTED).[¶](#section-7.2.1-2)

```

DATA Frame {
  Type (i) = 0x00,
  Length (i),
  Data (..),
}

```

[Figure 4](#figure-4):
[DATA Frame](#name-data-frame)

#### [7.2.2.](#section-7.2.2) [HEADERS](#name-headers)

The HEADERS frame (type=0x01) is used to carry an HTTP field section that is
encoded using QPACK. See [[QPACK](#RFC9204)] for more details.[¶](#section-7.2.2-1)

```

HEADERS Frame {
  Type (i) = 0x01,
  Length (i),
  Encoded Field Section (..),
}

```

[Figure 5](#figure-5):
[HEADERS Frame](#name-headers-frame)

HEADERS frames can only be sent on [request streams](#request-streams) or [push streams](#push-streams). If a
HEADERS frame is received on a [control stream](#control-streams), the recipient MUST
respond with a
[connection error](#errors) of type [H3\_FRAME\_UNEXPECTED](#H3_FRAME_UNEXPECTED).[¶](#section-7.2.2-3)

#### [7.2.3.](#section-7.2.3) [CANCEL\_PUSH](#name-cancel_push)

The CANCEL\_PUSH frame (type=0x03) is used to request cancellation of a server
push prior to the [push stream](#push-streams) being received. The CANCEL\_PUSH frame identifies
a server push by [push ID](#server-push) (see [Section 4.6](#server-push)), encoded as a variable-length
integer.[¶](#section-7.2.3-1)

When a client sends a CANCEL\_PUSH frame, it is indicating that it does not wish
to receive the promised resource. The server SHOULD
abort sending the resource,
but the mechanism to do so depends on the state of the corresponding [push
stream](#push-streams). If the server has not yet created a [push stream](#push-streams), it does not create
one. If the [push stream](#push-streams) is open, the server SHOULD
abruptly terminate that
stream. If the [push stream](#push-streams) has already ended, the server MAY
still abruptly
terminate the stream or MAY
take no action.[¶](#section-7.2.3-2)

A server sends a CANCEL\_PUSH frame to indicate that it will not be fulfilling a
promise that was previously sent. The client cannot expect the corresponding
promise to be fulfilled, unless it has already received and processed the
promised response. Regardless of whether a [push stream](#push-streams) has been opened, a server SHOULD
send a CANCEL\_PUSH frame when it determines that promise will not be
fulfilled. If a stream has already been opened, the server can abort sending on
the stream with an error code of [H3\_REQUEST\_CANCELLED](#H3_REQUEST_CANCELLED).[¶](#section-7.2.3-3)

Sending a CANCEL\_PUSH frame has no direct effect on the state of existing [push
streams](#push-streams). A client SHOULD NOT
send a CANCEL\_PUSH frame when it has already
received a corresponding [push stream](#push-streams). A [push stream](#push-streams) could arrive after a client
has sent a CANCEL\_PUSH frame, because a server might not have processed the
CANCEL\_PUSH. The client SHOULD
abort reading the stream with an error code of
[H3\_REQUEST\_CANCELLED](#H3_REQUEST_CANCELLED).[¶](#section-7.2.3-4)

A CANCEL\_PUSH frame is sent on the [control stream](#control-streams). Receiving a CANCEL\_PUSH
frame on a stream other than the [control stream](#control-streams) MUST
be treated as a [connection
error](#errors) of type [H3\_FRAME\_UNEXPECTED](#H3_FRAME_UNEXPECTED).[¶](#section-7.2.3-5)

```

CANCEL_PUSH Frame {
  Type (i) = 0x03,
  Length (i),
  Push ID (i),
}

```

[Figure 6](#figure-6):
[CANCEL\_PUSH Frame](#name-cancel_push-frame)

The CANCEL\_PUSH frame carries a [push ID](#server-push) encoded as a variable-length integer.
The Push ID field identifies the server push that is being cancelled; see
[Section 4.6](#server-push). If a CANCEL\_PUSH frame is received that references a [push ID](#server-push)
greater than currently allowed on the connection, this MUST
be treated as a
[connection error](#errors) of type [H3\_ID\_ERROR](#H3_ID_ERROR).[¶](#section-7.2.3-7)

If the client receives a CANCEL\_PUSH frame, that frame might identify a [push ID](#server-push)
that has not yet been mentioned by a [PUSH\_PROMISE](#frame-push-promise) frame due to reordering. If a
server receives a CANCEL\_PUSH frame for a [push ID](#server-push) that has not yet been
mentioned by a [PUSH\_PROMISE](#frame-push-promise) frame, this MUST
be treated as a [connection error](#errors) of
type [H3\_ID\_ERROR](#H3_ID_ERROR).[¶](#section-7.2.3-8)

#### [7.2.4.](#section-7.2.4) [SETTINGS](#name-settings)

The SETTINGS frame (type=0x04) conveys configuration parameters that affect how
endpoints communicate, such as preferences and constraints on peer behavior.
Individually, a SETTINGS parameter can also be referred to as a "setting"; the
identifier and value of each setting parameter can be referred to as a "setting
identifier" and a "setting value".[¶](#section-7.2.4-1)

SETTINGS frames always apply to an entire HTTP/3 connection, never a single
stream. A SETTINGS frame MUST
be sent as the first frame of each [control stream](#control-streams)
(see [Section 6.2.1](#control-streams)) by each peer, and it MUST NOT
be sent subsequently. If
an endpoint receives a second SETTINGS frame on the [control stream](#control-streams), the endpoint MUST
respond with a [connection error](#errors) of type [H3\_FRAME\_UNEXPECTED](#H3_FRAME_UNEXPECTED).[¶](#section-7.2.4-2)

SETTINGS frames MUST NOT
be sent on any stream other than the [control stream](#control-streams).
If an endpoint receives a SETTINGS frame on a different stream, the endpoint MUST
respond with a [connection error](#errors) of type [H3\_FRAME\_UNEXPECTED](#H3_FRAME_UNEXPECTED).[¶](#section-7.2.4-3)

SETTINGS parameters are not negotiated; they describe characteristics of the
sending peer that can be used by the receiving peer. However, a negotiation
can be implied by the use of SETTINGS: each peer uses SETTINGS to advertise a
set of supported values. The definition of the setting would describe how each
peer combines the two sets to conclude which choice will be used. SETTINGS does
not provide a mechanism to identify when the choice takes effect.[¶](#section-7.2.4-4)

Different values for the same parameter can be advertised by each peer. For
example, a client might be willing to consume a very large response field
section, while servers are more cautious about request size.[¶](#section-7.2.4-5)

The same setting identifier MUST NOT
occur more than once in the SETTINGS frame.
A receiver MAY
treat the presence of duplicate setting identifiers as a
[connection error](#errors) of type [H3\_SETTINGS\_ERROR](#H3_SETTINGS_ERROR).[¶](#section-7.2.4-6)

The payload of a SETTINGS frame consists of zero or more parameters. Each
parameter consists of a setting identifier and a value, both encoded as QUIC
variable-length integers.[¶](#section-7.2.4-7)

```

Setting {
  Identifier (i),
  Value (i),
}

SETTINGS Frame {
  Type (i) = 0x04,
  Length (i),
  Setting (..) ...,
}

```

[Figure 7](#figure-7):
[SETTINGS Frame](#name-settings-frame)

An implementation MUST
ignore any parameter with an identifier it does
not understand.[¶](#section-7.2.4-9)

##### [7.2.4.1.](#section-7.2.4.1) [Defined SETTINGS Parameters](#name-defined-settings-parameters)

The following settings are defined in HTTP/3:[¶](#section-7.2.4.1-1)

SETTINGS\_MAX\_FIELD\_SECTION\_SIZE (0x06):

The default value is unlimited. See [Section 4.2.2](#header-size-constraints) for usage.[¶](#section-7.2.4.1-2.2.1)

Setting identifiers of the format `0x1f * N + 0x21` for non-negative integer
values of `N` are reserved to exercise the requirement that unknown identifiers
be ignored. Such settings have no defined meaning. Endpoints SHOULD
include at
least one such setting in their SETTINGS frame. Endpoints MUST NOT
consider such
settings to have any meaning upon receipt.[¶](#section-7.2.4.1-3)

Because the setting has no defined meaning, the value of the setting can be any
value the implementation selects.[¶](#section-7.2.4.1-4)

Setting identifiers that were defined in [[HTTP/2](#RFC9113)] where there is no
corresponding HTTP/3 setting have also been reserved ([Section 11.2.2](#iana-settings)). These
reserved settings MUST NOT
be sent, and their receipt MUST
be treated as a
[connection error](#errors) of type [H3\_SETTINGS\_ERROR](#H3_SETTINGS_ERROR).[¶](#section-7.2.4.1-5)

Additional settings can be defined by extensions to HTTP/3; see [Section 9](#extensions)
for more details.[¶](#section-7.2.4.1-6)

##### [7.2.4.2.](#section-7.2.4.2) [Initialization](#name-initialization)

An HTTP implementation MUST NOT
send frames or requests that would be invalid
based on its current understanding of the peer's settings.[¶](#section-7.2.4.2-1)

All settings begin at an initial value. Each endpoint SHOULD
use these initial
values to send messages before the peer's SETTINGS frame has arrived, as packets
carrying the settings can be lost or delayed. When the SETTINGS frame arrives,
any settings are changed to their new values.[¶](#section-7.2.4.2-2)

This removes the need to wait for the SETTINGS frame before sending messages.
Endpoints MUST NOT
require any data to be received from the peer prior to
sending the SETTINGS frame; settings MUST
be sent as soon as the transport is
ready to send data.[¶](#section-7.2.4.2-3)

For servers, the initial value of each client setting is the default value.[¶](#section-7.2.4.2-4)

For clients using a 1-RTT QUIC connection, the initial value of each server
setting is the default value. 1-RTT keys will always become available prior to
the packet containing SETTINGS being processed by QUIC, even if the server sends
SETTINGS immediately. Clients SHOULD NOT
wait indefinitely for SETTINGS to
arrive before sending requests, but they SHOULD
process received datagrams in
order to increase the likelihood of processing SETTINGS before sending the first
request.[¶](#section-7.2.4.2-5)

When a 0-RTT QUIC connection is being used, the initial value of each server
setting is the value used in the previous session. Clients SHOULD
store the
settings the server provided in the HTTP/3 connection where resumption
information was provided, but they MAY
opt not to store settings in certain
cases (e.g., if the session ticket is received before the SETTINGS frame). A
client MUST
comply with stored settings -- or default values if no values are
stored -- when attempting 0-RTT. Once a server has provided new settings,
clients MUST
comply with those values.[¶](#section-7.2.4.2-6)

A server can remember the settings that it advertised or store an
integrity-protected copy of the values in the ticket and recover the information
when accepting 0-RTT data. A server uses the HTTP/3 settings values in
determining whether to accept 0-RTT data. If the server cannot determine that
the settings remembered by a client are compatible with its current settings, it MUST NOT
accept 0-RTT data. Remembered settings are compatible if a client
complying with those settings would not violate the server's current settings.[¶](#section-7.2.4.2-7)

A server MAY
accept 0-RTT and subsequently provide different settings in its
SETTINGS frame. If 0-RTT data is accepted by the server, its SETTINGS frame MUST NOT
reduce any limits or alter any values that might be violated by the client
with its 0-RTT data. The server MUST
include all settings that differ from
their default values. If a server accepts 0-RTT but then sends settings that
are not compatible with the previously specified settings, this MUST
be treated
as a [connection error](#errors) of type [H3\_SETTINGS\_ERROR](#H3_SETTINGS_ERROR). If a server accepts 0-RTT but
then sends a SETTINGS frame that omits a setting value that the client
understands (apart from reserved setting identifiers) that was previously
specified to have a non-default value, this MUST
be treated as a [connection
error](#errors) of type [H3\_SETTINGS\_ERROR](#H3_SETTINGS_ERROR).[¶](#section-7.2.4.2-8)

#### [7.2.5.](#section-7.2.5) [PUSH\_PROMISE](#name-push_promise)

The PUSH\_PROMISE frame (type=0x05) is used to carry a promised request header
section from server to client on a [request stream](#request-streams).[¶](#section-7.2.5-1)

```

PUSH_PROMISE Frame {
  Type (i) = 0x05,
  Length (i),
  Push ID (i),
  Encoded Field Section (..),
}

```

[Figure 8](#figure-8):
[PUSH\_PROMISE Frame](#name-push_promise-frame)

The payload consists of:[¶](#section-7.2.5-3)

Push ID:

A variable-length integer that identifies the server push operation. A [push
ID](#server-push) is used in [push stream](#push-streams) headers ([Section 4.6](#server-push)) and [CANCEL\_PUSH](#frame-cancel-push) frames.[¶](#section-7.2.5-4.2.1)

Encoded Field Section:

QPACK-encoded request header fields for the promised response. See
[[QPACK](#RFC9204)] for more details.[¶](#section-7.2.5-4.4.1)

A server MUST NOT
use a [push ID](#server-push) that is larger than the client has provided in a
[MAX\_PUSH\_ID](#frame-max-push-id) frame ([Section 7.2.7](#frame-max-push-id)). A client MUST
treat receipt of a
PUSH\_PROMISE frame that contains a larger [push ID](#server-push) than the client has advertised
as a [connection error](#errors) of [H3\_ID\_ERROR](#H3_ID_ERROR).[¶](#section-7.2.5-5)

A server MAY
use the same [push ID](#server-push) in multiple PUSH\_PROMISE frames. If so, the
decompressed request header sets MUST
contain the same fields in the same order,
and both the name and the value in each field MUST
be exact matches. Clients SHOULD
compare the request header sections for resources promised multiple
times. If a client receives a [push ID](#server-push) that has already been promised and detects
a mismatch, it MUST
respond with a [connection error](#errors) of type
[H3\_GENERAL\_PROTOCOL\_ERROR](#H3_GENERAL_PROTOCOL_ERROR). If the decompressed field sections match exactly, the
client SHOULD
associate the pushed content with each stream on which a
PUSH\_PROMISE frame was received.[¶](#section-7.2.5-6)

Allowing duplicate references to the same [push ID](#server-push) is primarily to reduce
duplication caused by concurrent requests. A server SHOULD
avoid reusing a [push
ID](#server-push) over a long period. Clients are likely to consume server push responses and
not retain them for reuse over time. Clients that see a PUSH\_PROMISE frame that
uses a [push ID](#server-push) that they have already consumed and discarded are forced to
ignore the promise.[¶](#section-7.2.5-7)

If a PUSH\_PROMISE frame is received on the [control stream](#control-streams), the client MUST
respond with a [connection error](#errors) of type [H3\_FRAME\_UNEXPECTED](#H3_FRAME_UNEXPECTED).[¶](#section-7.2.5-8)

A client MUST NOT
send a PUSH\_PROMISE frame. A server MUST
treat the receipt of
a PUSH\_PROMISE frame as a [connection error](#errors) of type [H3\_FRAME\_UNEXPECTED](#H3_FRAME_UNEXPECTED).[¶](#section-7.2.5-9)

See [Section 4.6](#server-push) for a description of the overall server push mechanism.[¶](#section-7.2.5-10)

#### [7.2.6.](#section-7.2.6) [GOAWAY](#name-goaway)

The GOAWAY frame (type=0x07) is used to initiate graceful shutdown of an HTTP/3
connection by either endpoint. GOAWAY allows an endpoint to stop accepting new
requests or pushes while still finishing processing of previously received
requests and pushes. This enables administrative actions, like server
maintenance. GOAWAY by itself does not close a connection.[¶](#section-7.2.6-1)

```

GOAWAY Frame {
  Type (i) = 0x07,
  Length (i),
  Stream ID/Push ID (i),
}

```

[Figure 9](#figure-9):
[GOAWAY Frame](#name-goaway-frame)

The GOAWAY frame is always sent on the [control stream](#control-streams). In the server-to-client
direction, it carries a QUIC stream ID for a client-initiated bidirectional
stream encoded as a variable-length integer. A client MUST
treat receipt of a
GOAWAY frame containing a stream ID of any other type as a [connection error](#errors) of
type [H3\_ID\_ERROR](#H3_ID_ERROR).[¶](#section-7.2.6-3)

In the client-to-server direction, the GOAWAY frame carries a [push ID](#server-push) encoded as
a variable-length integer.[¶](#section-7.2.6-4)

The GOAWAY frame applies to the entire connection, not a specific stream. A
client MUST
treat a GOAWAY frame on a stream other than the [control stream](#control-streams) as a
[connection error](#errors) of type [H3\_FRAME\_UNEXPECTED](#H3_FRAME_UNEXPECTED).[¶](#section-7.2.6-5)

See [Section 5.2](#connection-shutdown) for more information on the use of the GOAWAY frame.[¶](#section-7.2.6-6)

#### [7.2.7.](#section-7.2.7) [MAX\_PUSH\_ID](#name-max_push_id)

The MAX\_PUSH\_ID frame (type=0x0d) is used by clients to control the number of
server pushes that the server can initiate. This sets the maximum value for a
[push ID](#server-push) that the server can use in [PUSH\_PROMISE](#frame-push-promise) and [CANCEL\_PUSH](#frame-cancel-push) frames.
Consequently, this also limits the number of [push streams](#push-streams) that the server can
initiate in addition to the limit maintained by the QUIC transport.[¶](#section-7.2.7-1)

The MAX\_PUSH\_ID frame is always sent on the [control stream](#control-streams). Receipt of a
MAX\_PUSH\_ID frame on any other stream MUST
be treated as a [connection error](#errors) of
type [H3\_FRAME\_UNEXPECTED](#H3_FRAME_UNEXPECTED).[¶](#section-7.2.7-2)

A server MUST NOT
send a MAX\_PUSH\_ID frame. A client MUST
treat the receipt of
a MAX\_PUSH\_ID frame as a [connection error](#errors) of type [H3\_FRAME\_UNEXPECTED](#H3_FRAME_UNEXPECTED).[¶](#section-7.2.7-3)

The maximum [push ID](#server-push) is unset when an HTTP/3 connection is created, meaning that
a server cannot push until it receives a MAX\_PUSH\_ID frame. A client that
wishes to manage the number of promised server pushes can increase the maximum
[push ID](#server-push) by sending MAX\_PUSH\_ID frames as the server fulfills or cancels server
pushes.[¶](#section-7.2.7-4)

```

MAX_PUSH_ID Frame {
  Type (i) = 0x0d,
  Length (i),
  Push ID (i),
}

```

[Figure 10](#figure-10):
[MAX\_PUSH\_ID Frame](#name-max_push_id-frame)

The MAX\_PUSH\_ID frame carries a single variable-length integer that identifies
the maximum value for a [push ID](#server-push) that the server can use; see [Section 4.6](#server-push). A
MAX\_PUSH\_ID frame cannot reduce the maximum [push ID](#server-push); receipt of a MAX\_PUSH\_ID
frame that contains a smaller value than previously received MUST
be treated as
a [connection error](#errors) of type [H3\_ID\_ERROR](#H3_ID_ERROR).[¶](#section-7.2.7-6)

#### [7.2.8.](#section-7.2.8) [Reserved Frame Types](#name-reserved-frame-types)

Frame types of the format `0x1f * N + 0x21` for non-negative integer values of
`N` are reserved to exercise the requirement that unknown types be ignored
([Section 9](#extensions)). These frames have no semantics, and they MAY
be sent on any
stream where frames are allowed to be sent. This enables their use for
application-layer padding. Endpoints MUST NOT
consider these frames to have any
meaning upon receipt.[¶](#section-7.2.8-1)

The payload and length of the frames are selected in any manner the
implementation chooses.[¶](#section-7.2.8-2)

Frame types that were used in HTTP/2 where there is no corresponding HTTP/3
frame have also been reserved ([Section 11.2.1](#iana-frames)). These frame types MUST NOT
be
sent, and their receipt MUST
be treated as a [connection error](#errors) of type
[H3\_FRAME\_UNEXPECTED](#H3_FRAME_UNEXPECTED).[¶](#section-7.2.8-3)

## [8.](#section-8) [Error Handling](#name-error-handling)

When a stream cannot be completed successfully, QUIC allows the application to
abruptly terminate (reset) that stream and communicate a reason; see [Section 2.4](https://www.rfc-editor.org/rfc/rfc9000#section-2.4) of [[QUIC-TRANSPORT](#QUIC-TRANSPORT)]. This is referred to as a "stream error". An HTTP/3
implementation can decide to close a QUIC stream and communicate the type of
error. Wire encodings of error codes are defined in [Section 8.1](#http-error-codes).
Stream errors are distinct from HTTP status codes that indicate error
conditions. Stream errors indicate that the sender did not transfer or consume
the full request or response, while HTTP status codes indicate the result of a
request that was successfully received.[¶](#section-8-1)

If an entire connection needs to be terminated, QUIC similarly provides
mechanisms to communicate a reason; see [Section 5.3](https://www.rfc-editor.org/rfc/rfc9000#section-5.3) of [[QUIC-TRANSPORT](#QUIC-TRANSPORT)]. This
is referred to as a "connection error". Similar to stream errors, an HTTP/3
implementation can terminate a QUIC connection and communicate the reason using
an error code from [Section 8.1](#http-error-codes).[¶](#section-8-2)

Although the reasons for closing streams and connections are called "errors",
these actions do not necessarily indicate a problem with the connection or
either implementation. For example, a stream can be reset if the requested
resource is no longer needed.[¶](#section-8-3)

An endpoint MAY
choose to treat a stream error as a connection error under
certain circumstances, closing the entire connection in response to a condition
on a single stream. Implementations need to consider the impact on outstanding
requests before making this choice.[¶](#section-8-4)

Because new error codes can be defined without negotiation (see [Section 9](#extensions)),
use of an error code in an unexpected context or receipt of an unknown error
code MUST
be treated as equivalent to [H3\_NO\_ERROR](#H3_NO_ERROR). However, closing a stream
can have other effects regardless of the error code; for example, see
[Section 4.1](#request-response).[¶](#section-8-5)

### [8.1.](#section-8.1) [HTTP/3 Error Codes](#name-http-3-error-codes)

The following error codes are defined for use when abruptly terminating streams,
aborting reading of streams, or immediately closing HTTP/3 connections.[¶](#section-8.1-1)

H3\_NO\_ERROR (0x0100):

No error. This is used when the connection or stream needs to be closed, but
there is no error to signal.[¶](#section-8.1-2.2.1)

H3\_GENERAL\_PROTOCOL\_ERROR (0x0101):

Peer violated protocol requirements in a way that does not match a more
specific error code or endpoint declines to use the more specific error code.[¶](#section-8.1-2.4.1)

H3\_INTERNAL\_ERROR (0x0102):

An internal error has occurred in the HTTP stack.[¶](#section-8.1-2.6.1)

H3\_STREAM\_CREATION\_ERROR (0x0103):

The endpoint detected that its peer created a stream that it will not accept.[¶](#section-8.1-2.8.1)

H3\_CLOSED\_CRITICAL\_STREAM (0x0104):

A stream required by the HTTP/3 connection was closed or reset.[¶](#section-8.1-2.10.1)

H3\_FRAME\_UNEXPECTED (0x0105):

A frame was received that was not permitted in the current state or on the
current stream.[¶](#section-8.1-2.12.1)

H3\_FRAME\_ERROR (0x0106):

A frame that fails to satisfy layout requirements or with an invalid size
was received.[¶](#section-8.1-2.14.1)

H3\_EXCESSIVE\_LOAD (0x0107):

The endpoint detected that its peer is exhibiting a behavior that might be
generating excessive load.[¶](#section-8.1-2.16.1)

H3\_ID\_ERROR (0x0108):

A stream ID or [push ID](#server-push) was used incorrectly, such as exceeding a limit,
reducing a limit, or being reused.[¶](#section-8.1-2.18.1)

H3\_SETTINGS\_ERROR (0x0109):

An endpoint detected an error in the payload of a [SETTINGS](#frame-settings) frame.[¶](#section-8.1-2.20.1)

H3\_MISSING\_SETTINGS (0x010a):

No [SETTINGS](#frame-settings) frame was received at the beginning of the [control stream](#control-streams).[¶](#section-8.1-2.22.1)

H3\_REQUEST\_REJECTED (0x010b):

A server rejected a request without performing any application processing.[¶](#section-8.1-2.24.1)

H3\_REQUEST\_CANCELLED (0x010c):

The request or its response (including pushed response) is cancelled.[¶](#section-8.1-2.26.1)

H3\_REQUEST\_INCOMPLETE (0x010d):

The client's stream terminated without containing a fully formed request.[¶](#section-8.1-2.28.1)

H3\_MESSAGE\_ERROR (0x010e):

An HTTP message was [malformed](#malformed) and cannot be processed.[¶](#section-8.1-2.30.1)

H3\_CONNECT\_ERROR (0x010f):

The TCP connection established in response to a CONNECT request was reset or
abnormally closed.[¶](#section-8.1-2.32.1)

H3\_VERSION\_FALLBACK (0x0110):

The requested operation cannot be served over HTTP/3. The peer should
retry over HTTP/1.1.[¶](#section-8.1-2.34.1)

Error codes of the format `0x1f * N + 0x21` for non-negative integer values of
`N` are reserved to exercise the requirement that unknown error codes be treated
as equivalent to [H3\_NO\_ERROR](#H3_NO_ERROR) ([Section 9](#extensions)). Implementations SHOULD
select an
error code from this space with some probability when they would have sent
[H3\_NO\_ERROR](#H3_NO_ERROR).[¶](#section-8.1-3)

## [9.](#section-9) [Extensions to HTTP/3](#name-extensions-to-http-3)

HTTP/3 permits extension of the protocol. Within the limitations described in
this section, protocol extensions can be used to provide additional services or
alter any aspect of the protocol. Extensions are effective only within the
scope of a single HTTP/3 connection.[¶](#section-9-1)

This applies to the protocol elements defined in this document. This does not
affect the existing options for extending HTTP, such as defining new methods,
status codes, or fields.[¶](#section-9-2)

Extensions are permitted to use new frame types ([Section 7.2](#frames)), new settings
([Section 7.2.4.1](#settings-parameters)), new error codes ([Section 8](#errors)), or new unidirectional
stream types ([Section 6.2](#unidirectional-streams)). Registries are established for
managing these extension points: frame types ([Section 11.2.1](#iana-frames)), settings
([Section 11.2.2](#iana-settings)), error codes ([Section 11.2.3](#iana-error-codes)), and stream types
([Section 11.2.4](#iana-stream-types)).[¶](#section-9-3)

Implementations MUST
ignore unknown or unsupported values in all extensible
protocol elements. Implementations MUST
discard data or abort reading on
unidirectional streams that have unknown or unsupported types. This means that
any of these extension points can be safely used by extensions without prior
arrangement or negotiation. However, where a known frame type is required to be
in a specific location, such as the [SETTINGS](#frame-settings) frame as the first frame of the
[control stream](#control-streams) (see [Section 6.2.1](#control-streams)), an unknown frame type does not satisfy
that requirement and SHOULD
be treated as an error.[¶](#section-9-4)

Extensions that could change the semantics of existing protocol components MUST
be negotiated before being used. For example, an extension that changes the
layout of the [HEADERS](#frame-headers) frame cannot be used until the peer has given a positive
signal that this is acceptable. Coordinating when such a revised layout comes
into effect could prove complex. As such, allocating new identifiers for
new definitions of existing protocol elements is likely to be more effective.[¶](#section-9-5)

This document does not mandate a specific method for negotiating the use of an
extension, but it notes that a setting ([Section 7.2.4.1](#settings-parameters)) could be used
for that purpose. If both peers set a value that indicates willingness to use
the extension, then the extension can be used. If a setting is used for
extension negotiation, the default value MUST
be defined in such a fashion that
the extension is disabled if the setting is omitted.[¶](#section-9-6)

## [10.](#section-10) [Security Considerations](#name-security-considerations)

The security considerations of HTTP/3 should be comparable to those of HTTP/2
with TLS. However, many of the considerations from [Section 10](https://www.rfc-editor.org/rfc/rfc9113#section-10) of [[HTTP/2](#RFC9113)]
apply to [[QUIC-TRANSPORT](#QUIC-TRANSPORT)] and are discussed in that document.[¶](#section-10-1)

### [10.1.](#section-10.1) [Server Authority](#name-server-authority)

HTTP/3 relies on the HTTP definition of authority. The security considerations
of establishing authority are discussed in [Section 17.1](https://www.rfc-editor.org/rfc/rfc9110#section-17.1) of [[HTTP](#RFC9110)].[¶](#section-10.1-1)

### [10.2.](#section-10.2) [Cross-Protocol Attacks](#name-cross-protocol-attacks)

The use of ALPN in the TLS and QUIC handshakes establishes the target
application protocol before application-layer bytes are processed. This ensures
that endpoints have strong assurances that peers are using the same protocol.[¶](#section-10.2-1)

This does not guarantee protection from all cross-protocol attacks. [Section 21.5](https://www.rfc-editor.org/rfc/rfc9000#section-21.5) of [[QUIC-TRANSPORT](#QUIC-TRANSPORT)] describes some ways in which the plaintext of QUIC
packets can be used to perform request forgery against endpoints that don't use
authenticated transports.[¶](#section-10.2-2)

### [10.3.](#section-10.3) [Intermediary-Encapsulation Attacks](#name-intermediary-encapsulation-)

The HTTP/3 field encoding allows the expression of names that are not valid
field names in the syntax used by HTTP ([Section 5.1](https://www.rfc-editor.org/rfc/rfc9110#section-5.1) of [[HTTP](#RFC9110)]). Requests or
responses containing invalid field names MUST
be treated as [malformed](#malformed).
Therefore, an intermediary cannot translate an HTTP/3 request or response
containing an invalid field name into an HTTP/1.1 message.[¶](#section-10.3-1)

Similarly, HTTP/3 can transport field values that are not valid. While most
values that can be encoded will not alter field parsing, carriage return (ASCII
0x0d), line feed (ASCII 0x0a), and the null character (ASCII 0x00) might be
exploited by an attacker if they are translated verbatim. Any request or
response that contains a character not permitted in a field value MUST
be
treated as [malformed](#malformed). Valid characters are defined by the
"field-content" ABNF rule in [Section 5.5](https://www.rfc-editor.org/rfc/rfc9110#section-5.5) of [[HTTP](#RFC9110)].[¶](#section-10.3-2)

### [10.4.](#section-10.4) [Cacheability of Pushed Responses](#name-cacheability-of-pushed-resp)

Pushed responses do not have an explicit request from the client; the request is
provided by the server in the [PUSH\_PROMISE](#frame-push-promise) frame.[¶](#section-10.4-1)

Caching responses that are pushed is possible based on the guidance provided by
the origin server in the Cache-Control header field. However, this can cause
issues if a single server hosts more than one tenant. For example, a server
might offer multiple users each a small portion of its URI space.[¶](#section-10.4-2)

Where multiple tenants share space on the same server, that server MUST
ensure
that tenants are not able to push representations of resources that they do not
have authority over. Failure to enforce this would allow a tenant to provide a
representation that would be served out of cache, overriding the actual
representation that the authoritative tenant provides.[¶](#section-10.4-3)

Clients are required to reject pushed responses for which an origin server is
not authoritative; see [Section 4.6](#server-push).[¶](#section-10.4-4)

### [10.5.](#section-10.5) [Denial-of-Service Considerations](#name-denial-of-service-considera)

An HTTP/3 connection can demand a greater commitment of resources to operate
than an HTTP/1.1 or HTTP/2 connection. The use of field compression and flow
control depend on a commitment of resources for storing a greater amount of
state. Settings for these features ensure that memory commitments for these
features are strictly bounded.[¶](#section-10.5-1)

The number of [PUSH\_PROMISE](#frame-push-promise) frames is constrained in a similar fashion. A client
that accepts server push SHOULD
limit the number of push IDs it issues at a
time.[¶](#section-10.5-2)

Processing capacity cannot be guarded as effectively as state capacity.[¶](#section-10.5-3)

The ability to send undefined protocol elements that the peer is required to
ignore can be abused to cause a peer to expend additional processing time. This
might be done by setting multiple undefined [SETTINGS](#frame-settings) parameters, unknown frame
types, or unknown stream types. Note, however, that some uses are entirely
legitimate, such as optional-to-understand extensions and padding to increase
resistance to traffic analysis.[¶](#section-10.5-4)

Compression of field sections also offers some opportunities to waste processing
resources; see [Section 7](https://www.rfc-editor.org/rfc/rfc9204#section-7) of [[QPACK](#RFC9204)] for more details on potential abuses.[¶](#section-10.5-5)

All these features -- i.e., server push, unknown protocol elements, field
compression -- have legitimate uses. These features become a burden only when
they are used unnecessarily or to excess.[¶](#section-10.5-6)

An endpoint that does not monitor such behavior exposes itself to a risk of
denial-of-service attack. Implementations SHOULD
track the use of these
features and set limits on their use. An endpoint MAY
treat activity that is
suspicious as a [connection error](#errors) of type [H3\_EXCESSIVE\_LOAD](#H3_EXCESSIVE_LOAD), but
false positives will result in disrupting valid connections and requests.[¶](#section-10.5-7)

#### [10.5.1.](#section-10.5.1) [Limits on Field Section Size](#name-limits-on-field-section-siz)

A large field section ([Section 4.1](#request-response)) can cause an implementation to
commit a large amount of state. Header fields that are critical for routing can
appear toward the end of a header section, which prevents streaming of the
header section to its ultimate destination. This ordering and other reasons,
such as ensuring cache correctness, mean that an endpoint likely needs to buffer
the entire header section. Since there is no hard limit to the size of a field
section, some endpoints could be forced to commit a large amount of available
memory for header fields.[¶](#section-10.5.1-1)

An endpoint can use the [SETTINGS\_MAX\_FIELD\_SECTION\_SIZE](#SETTINGS_MAX_FIELD_SECTION_SIZE)
([Section 4.2.2](#header-size-constraints)) setting to advise peers of limits that might apply
on the size of field sections. This setting is only advisory, so endpoints MAY
choose to send field sections that exceed this limit and risk having the request
or response being treated as [malformed](#malformed). This setting is specific to an HTTP/3
connection, so any request or response could encounter a hop with a lower,
unknown limit. An intermediary can attempt to avoid this problem by passing on
values presented by different peers, but they are not obligated to do so.[¶](#section-10.5.1-2)

A server that receives a larger field section than it is willing to handle can
send an HTTP 431 (Request Header Fields Too Large) status code ([[RFC6585](#RFC6585)]).
A client can discard responses that it cannot process.[¶](#section-10.5.1-3)

#### [10.5.2.](#section-10.5.2) [CONNECT Issues](#name-connect-issues)

The CONNECT method can be used to create disproportionate load on a proxy, since
stream creation is relatively inexpensive when compared to the creation and
maintenance of a TCP connection. Therefore, a proxy that supports CONNECT might
be more conservative in the number of simultaneous requests it accepts.[¶](#section-10.5.2-1)

A proxy might also maintain some resources for a TCP connection beyond the
closing of the stream that carries the CONNECT request, since the outgoing TCP
connection remains in the TIME\_WAIT state. To account for this, a proxy might
delay increasing the QUIC stream limits for some time after a TCP connection
terminates.[¶](#section-10.5.2-2)

### [10.6.](#section-10.6) [Use of Compression](#name-use-of-compression)

Compression can allow an attacker to recover secret data when it is compressed
in the same context as data under attacker control. HTTP/3 enables compression
of fields ([Section 4.2](#header-formatting)); the following concerns also apply to the use
of HTTP compressed content-codings; see [Section 8.4.1](https://www.rfc-editor.org/rfc/rfc9110#section-8.4.1) of [[HTTP](#RFC9110)].[¶](#section-10.6-1)

There are demonstrable attacks on compression that exploit the characteristics
of the web (e.g., [[BREACH](#BREACH)]). The attacker induces multiple requests
containing varying plaintext, observing the length of the resulting ciphertext
in each, which reveals a shorter length when a guess about the secret is
correct.[¶](#section-10.6-2)

Implementations communicating on a secure channel MUST NOT
compress content that
includes both confidential and attacker-controlled data unless separate
compression contexts are used for each source of data. Compression MUST NOT
be
used if the source of data cannot be reliably determined.[¶](#section-10.6-3)

Further considerations regarding the compression of field sections are
described in [[QPACK](#RFC9204)].[¶](#section-10.6-4)

### [10.7.](#section-10.7) [Padding and Traffic Analysis](#name-padding-and-traffic-analysi)

Padding can be used to obscure the exact size of frame content and is provided
to mitigate specific attacks within HTTP, for example, attacks where compressed
content includes both attacker-controlled plaintext and secret data (e.g.,
[[BREACH](#BREACH)]).[¶](#section-10.7-1)

Where HTTP/2 employs PADDING frames and Padding fields in other frames to make a
connection more resistant to traffic analysis, HTTP/3 can either rely on
transport-layer padding or employ the reserved frame and stream types discussed
in Sections [7.2.8](#frame-reserved) and [6.2.3](#stream-grease). These methods of
padding produce different results in terms of the granularity of padding, how
padding is arranged in relation to the information that is being protected,
whether padding is applied in the case of packet loss, and how an implementation
might control padding.[¶](#section-10.7-2)

Reserved stream types can be used to give the appearance of sending traffic even
when the connection is idle. Because HTTP traffic often occurs in bursts,
apparent traffic can be used to obscure the timing or duration of such bursts,
even to the point of appearing to send a constant stream of data. However, as
such traffic is still flow controlled by the receiver, a failure to promptly
drain such streams and provide additional flow-control credit can limit the
sender's ability to send real traffic.[¶](#section-10.7-3)

To mitigate attacks that rely on compression, disabling or limiting compression
might be preferable to padding as a countermeasure.[¶](#section-10.7-4)

Use of padding can result in less protection than might seem immediately
obvious. Redundant padding could even be counterproductive. At best, padding
only makes it more difficult for an attacker to infer length information by
increasing the number of frames an attacker has to observe. Incorrectly
implemented padding schemes can be easily defeated. In particular, randomized
padding with a predictable distribution provides very little protection;
similarly, padding payloads to a fixed size exposes information as payload sizes
cross the fixed-sized boundary, which could be possible if an attacker can
control plaintext.[¶](#section-10.7-5)

### [10.8.](#section-10.8) [Frame Parsing](#name-frame-parsing)

Several protocol elements contain nested length elements, typically in the form
of frames with an explicit length containing variable-length integers. This
could pose a security risk to an incautious implementer. An implementation MUST
ensure that the length of a frame exactly matches the length of the fields it
contains.[¶](#section-10.8-1)

### [10.9.](#section-10.9) [Early Data](#name-early-data)

The use of 0-RTT with HTTP/3 creates an exposure to replay attack. The
anti-replay mitigations in [[HTTP-REPLAY](#HTTP-REPLAY)] MUST
be applied when using
HTTP/3 with 0-RTT. When applying [[HTTP-REPLAY](#HTTP-REPLAY)] to HTTP/3, references to the
TLS layer refer to the handshake performed within QUIC, while all references to
application data refer to the contents of streams.[¶](#section-10.9-1)

### [10.10.](#section-10.10) [Migration](#name-migration)

Certain HTTP implementations use the client address for logging or
access-control purposes. Since a QUIC client's address might change during a
connection (and future versions might support simultaneous use of multiple
addresses), such implementations will need to either actively retrieve the
client's current address or addresses when they are relevant or explicitly
accept that the original address might change.[¶](#section-10.10-1)

### [10.11.](#section-10.11) [Privacy Considerations](#name-privacy-considerations)

Several characteristics of HTTP/3 provide an observer an opportunity to
correlate actions of a single client or server over time. These include the
value of settings, the timing of reactions to stimulus, and the handling of any
features that are controlled by settings.[¶](#section-10.11-1)

As far as these create observable differences in behavior, they could be used as
a basis for fingerprinting a specific client.[¶](#section-10.11-2)

HTTP/3's preference for using a single QUIC connection allows correlation of a
user's activity on a site. Reusing connections for different origins allows
for correlation of activity across those origins.[¶](#section-10.11-3)

Several features of QUIC solicit immediate responses and can be used by an
endpoint to measure latency to their peer; this might have privacy implications
in certain scenarios.[¶](#section-10.11-4)

## [11.](#section-11) [IANA Considerations](#name-iana-considerations)

This document registers a new ALPN protocol ID ([Section 11.1](#iana-alpn)) and creates new
registries that manage the assignment of code points in HTTP/3.[¶](#section-11-1)

### [11.1.](#section-11.1) [Registration of HTTP/3 Identification String](#name-registration-of-http-3-iden)

This document creates a new registration for the identification of
HTTP/3 in the "TLS Application-Layer Protocol Negotiation (ALPN)
Protocol IDs" registry established in [[RFC7301](#RFC7301)].[¶](#section-11.1-1)

The "h3" string identifies HTTP/3:[¶](#section-11.1-2)

Protocol:

HTTP/3[¶](#section-11.1-3.2.1)

Identification Sequence:

0x68 0x33 ("h3")[¶](#section-11.1-3.4.1)

Specification:

This document[¶](#section-11.1-3.6.1)

### [11.2.](#section-11.2) [New Registries](#name-new-registries)

New registries created in this document operate under the QUIC registration
policy documented in [Section 22.1](https://www.rfc-editor.org/rfc/rfc9000#section-22.1) of [[QUIC-TRANSPORT](#QUIC-TRANSPORT)]. These registries all
include the common set of fields listed in [Section 22.1.1](https://www.rfc-editor.org/rfc/rfc9000#section-22.1.1) of [[QUIC-TRANSPORT](#QUIC-TRANSPORT)].
These registries are collected under the "Hypertext Transfer Protocol version 3
(HTTP/3)" heading.[¶](#section-11.2-1)

The initial allocations in these registries are all assigned permanent status
and list a change controller of the IETF and a contact of the HTTP working group
(ietf-http-wg@w3.org).[¶](#section-11.2-2)

#### [11.2.1.](#section-11.2.1) [Frame Types](#name-frame-types)

This document establishes a registry for HTTP/3 frame type codes. The "HTTP/3
Frame Types" registry governs a 62-bit space. This registry follows the QUIC
registry policy; see [Section 11.2](#iana-policy). Permanent registrations in this registry
are assigned using the Specification Required policy ([[RFC8126](#RFC8126)]), except for
values between 0x00 and 0x3f (in hexadecimal; inclusive), which are assigned
using Standards Action or IESG Approval as defined in
Sections [4.9](https://www.rfc-editor.org/rfc/rfc8126#section-4.9) and [4.10](https://www.rfc-editor.org/rfc/rfc8126#section-4.10) of [[RFC8126](#RFC8126)].[¶](#section-11.2.1-1)

While this registry is separate from the "HTTP/2 Frame Type" registry defined in
[[HTTP/2](#RFC9113)], it is preferable that the assignments parallel each other where the
code spaces overlap. If an entry is present in only one registry, every effort SHOULD
be made to avoid assigning the corresponding value to an unrelated
operation. Expert reviewers MAY
reject unrelated registrations that would
conflict with the same value in the corresponding registry.[¶](#section-11.2.1-2)

In addition to common fields as described in [Section 11.2](#iana-policy), permanent
registrations in this registry MUST
include the following field:[¶](#section-11.2.1-3)

Frame Type:

A name or label for the frame type.[¶](#section-11.2.1-4.2.1)

Specifications of frame types MUST
include a description of the frame layout and
its semantics, including any parts of the frame that are conditionally present.[¶](#section-11.2.1-5)

The entries in [Table 2](#iana-frame-table) are registered by this document.[¶](#section-11.2.1-6)

[Table 2](#table-2):
[Initial HTTP/3 Frame Types](#name-initial-http-3-frame-types)

| Frame Type | Value | Specification |
| --- | --- | --- |
| [DATA](#frame-data) | 0x00 | [Section 7.2.1](#frame-data) |
| [HEADERS](#frame-headers) | 0x01 | [Section 7.2.2](#frame-headers) |
| Reserved | 0x02 | This document |
| [CANCEL\_PUSH](#frame-cancel-push) | 0x03 | [Section 7.2.3](#frame-cancel-push) |
| [SETTINGS](#frame-settings) | 0x04 | [Section 7.2.4](#frame-settings) |
| [PUSH\_PROMISE](#frame-push-promise) | 0x05 | [Section 7.2.5](#frame-push-promise) |
| Reserved | 0x06 | This document |
| [GOAWAY](#frame-goaway) | 0x07 | [Section 7.2.6](#frame-goaway) |
| Reserved | 0x08 | This document |
| Reserved | 0x09 | This document |
| [MAX\_PUSH\_ID](#frame-max-push-id) | 0x0d | [Section 7.2.7](#frame-max-push-id) |

Each code of the format `0x1f * N + 0x21` for non-negative integer values of `N`
(that is, 0x21, 0x40, ..., through 0x3ffffffffffffffe) MUST NOT
be assigned by
IANA and MUST NOT
appear in the listing of assigned values.[¶](#section-11.2.1-8)

#### [11.2.2.](#section-11.2.2) [Settings Parameters](#name-settings-parameters)

This document establishes a registry for HTTP/3 settings. The "HTTP/3 Settings"
registry governs a 62-bit space. This registry follows the QUIC registry
policy; see [Section 11.2](#iana-policy). Permanent registrations in this registry are
assigned using the Specification Required policy ([[RFC8126](#RFC8126)]), except for
values between 0x00 and 0x3f (in hexadecimal; inclusive), which are assigned
using Standards Action or IESG Approval as defined in
Sections [4.9](https://www.rfc-editor.org/rfc/rfc8126#section-4.9) and [4.10](https://www.rfc-editor.org/rfc/rfc8126#section-4.10) of [[RFC8126](#RFC8126)].[¶](#section-11.2.2-1)

While this registry is separate from the "HTTP/2 Settings" registry defined in
[[HTTP/2](#RFC9113)], it is preferable that the assignments parallel each other. If an
entry is present in only one registry, every effort SHOULD
be made to avoid
assigning the corresponding value to an unrelated operation. Expert reviewers MAY
reject unrelated registrations that would conflict with the same value in
the corresponding registry.[¶](#section-11.2.2-2)

In addition to common fields as described in [Section 11.2](#iana-policy), permanent
registrations in this registry MUST
include the following fields:[¶](#section-11.2.2-3)

Setting Name:

A symbolic name for the setting. Specifying a setting name is optional.[¶](#section-11.2.2-4.2.1)

Default:

The value of the setting unless otherwise indicated. A default SHOULD
be the
most restrictive possible value.[¶](#section-11.2.2-4.4.1)

The entries in [Table 3](#iana-setting-table) are registered by this document.[¶](#section-11.2.2-5)

[Table 3](#table-3):
[Initial HTTP/3 Settings](#name-initial-http-3-settings)

| Setting Name | Value | Specification | Default |
| --- | --- | --- | --- |
| Reserved | 0x00 | This document | N/A |
| Reserved | 0x02 | This document | N/A |
| Reserved | 0x03 | This document | N/A |
| Reserved | 0x04 | This document | N/A |
| Reserved | 0x05 | This document | N/A |
| MAX\_FIELD\_SECTION\_SIZE | 0x06 | [Section 7.2.4.1](#settings-parameters) | Unlimited |

For formatting reasons, setting names can be abbreviated by removing the
'SETTINGS\_' prefix.[¶](#section-11.2.2-7)

Each code of the format `0x1f * N + 0x21` for non-negative integer values of `N`
(that is, 0x21, 0x40, ..., through 0x3ffffffffffffffe) MUST NOT
be assigned by
IANA and MUST NOT
appear in the listing of assigned values.[¶](#section-11.2.2-8)

#### [11.2.3.](#section-11.2.3) [Error Codes](#name-error-codes)

This document establishes a registry for HTTP/3 error codes. The "HTTP/3 Error
Codes" registry manages a 62-bit space. This registry follows the QUIC registry
policy; see [Section 11.2](#iana-policy). Permanent registrations in this registry are
assigned using the Specification Required policy ([[RFC8126](#RFC8126)]), except for
values between 0x00 and 0x3f (in hexadecimal; inclusive), which are assigned
using Standards Action or IESG Approval as defined in
Sections [4.9](https://www.rfc-editor.org/rfc/rfc8126#section-4.9) and [4.10](https://www.rfc-editor.org/rfc/rfc8126#section-4.10) of [[RFC8126](#RFC8126)].[¶](#section-11.2.3-1)

Registrations for error codes are required to include a description of the error
code. An expert reviewer is advised to examine new registrations for possible
duplication with existing error codes. Use of existing registrations is to be
encouraged, but not mandated. Use of values that are registered in the "HTTP/2
Error Code" registry is discouraged, and expert reviewers MAY
reject such
registrations.[¶](#section-11.2.3-2)

In addition to common fields as described in [Section 11.2](#iana-policy), this registry
includes two additional fields. Permanent registrations in this registry MUST
include the following field:[¶](#section-11.2.3-3)

Name:

A name for the error code.[¶](#section-11.2.3-4.2.1)

Description:

A brief description of the error code semantics.[¶](#section-11.2.3-4.4.1)

The entries in [Table 4](#iana-error-table) are registered by this document. These
error codes were selected from the range that operates on a Specification
Required policy to avoid collisions with HTTP/2 error codes.[¶](#section-11.2.3-5)

[Table 4](#table-4):
[Initial HTTP/3 Error Codes](#name-initial-http-3-error-codes)

| Name | Value | Description | Specification |
| --- | --- | --- | --- |
| [H3\_NO\_ERROR](#H3_NO_ERROR) | 0x0100 | No error | [Section 8.1](#http-error-codes) |
| [H3\_GENERAL\_PROTOCOL\_ERROR](#H3_GENERAL_PROTOCOL_ERROR) | 0x0101 | General protocol error | [Section 8.1](#http-error-codes) |
| [H3\_INTERNAL\_ERROR](#H3_INTERNAL_ERROR) | 0x0102 | Internal error | [Section 8.1](#http-error-codes) |
| [H3\_STREAM\_CREATION\_ERROR](#H3_STREAM_CREATION_ERROR) | 0x0103 | Stream creation error | [Section 8.1](#http-error-codes) |
| [H3\_CLOSED\_CRITICAL\_STREAM](#H3_CLOSED_CRITICAL_STREAM) | 0x0104 | Critical stream was closed | [Section 8.1](#http-error-codes) |
| [H3\_FRAME\_UNEXPECTED](#H3_FRAME_UNEXPECTED) | 0x0105 | Frame not permitted in the current state | [Section 8.1](#http-error-codes) |
| [H3\_FRAME\_ERROR](#H3_FRAME_ERROR) | 0x0106 | Frame violated layout or size rules | [Section 8.1](#http-error-codes) |
| [H3\_EXCESSIVE\_LOAD](#H3_EXCESSIVE_LOAD) | 0x0107 | Peer generating excessive load | [Section 8.1](#http-error-codes) |
| [H3\_ID\_ERROR](#H3_ID_ERROR) | 0x0108 | An identifier was used incorrectly | [Section 8.1](#http-error-codes) |
| [H3\_SETTINGS\_ERROR](#H3_SETTINGS_ERROR) | 0x0109 | [SETTINGS](#frame-settings) frame contained invalid values | [Section 8.1](#http-error-codes) |
| [H3\_MISSING\_SETTINGS](#H3_MISSING_SETTINGS) | 0x010a | No [SETTINGS](#frame-settings) frame received | [Section 8.1](#http-error-codes) |
| [H3\_REQUEST\_REJECTED](#H3_REQUEST_REJECTED) | 0x010b | Request not processed | [Section 8.1](#http-error-codes) |
| [H3\_REQUEST\_CANCELLED](#H3_REQUEST_CANCELLED) | 0x010c | Data no longer needed | [Section 8.1](#http-error-codes) |
| [H3\_REQUEST\_INCOMPLETE](#H3_REQUEST_INCOMPLETE) | 0x010d | Stream terminated early | [Section 8.1](#http-error-codes) |
| [H3\_MESSAGE\_ERROR](#H3_MESSAGE_ERROR) | 0x010e | Malformed message | [Section 8.1](#http-error-codes) |
| [H3\_CONNECT\_ERROR](#H3_CONNECT_ERROR) | 0x010f | TCP reset or error on CONNECT request | [Section 8.1](#http-error-codes) |
| [H3\_VERSION\_FALLBACK](#H3_VERSION_FALLBACK) | 0x0110 | Retry over HTTP/1.1 | [Section 8.1](#http-error-codes) |

Each code of the format `0x1f * N + 0x21` for non-negative integer values of `N`
(that is, 0x21, 0x40, ..., through 0x3ffffffffffffffe) MUST NOT
be assigned by
IANA and MUST NOT
appear in the listing of assigned values.[¶](#section-11.2.3-7)

#### [11.2.4.](#section-11.2.4) [Stream Types](#name-stream-types)

This document establishes a registry for HTTP/3 unidirectional stream types. The
"HTTP/3 Stream Types" registry governs a 62-bit space. This registry follows
the QUIC registry policy; see [Section 11.2](#iana-policy). Permanent registrations in this
registry are assigned using the Specification Required policy ([[RFC8126](#RFC8126)]),
except for values between 0x00 and 0x3f (in hexadecimal; inclusive), which are
assigned using Standards Action or IESG Approval as defined in Sections [4.9](https://www.rfc-editor.org/rfc/rfc8126#section-4.9) and [4.10](https://www.rfc-editor.org/rfc/rfc8126#section-4.10) of [[RFC8126](#RFC8126)].[¶](#section-11.2.4-1)

In addition to common fields as described in [Section 11.2](#iana-policy), permanent
registrations in this registry MUST
include the following fields:[¶](#section-11.2.4-2)

Stream Type:

A name or label for the stream type.[¶](#section-11.2.4-3.2.1)

Sender:

Which endpoint on an HTTP/3 connection may initiate a stream of this type.
Values are "Client", "Server", or "Both".[¶](#section-11.2.4-3.4.1)

Specifications for permanent registrations MUST
include a description of the
stream type, including the layout and semantics of the stream contents.[¶](#section-11.2.4-4)

The entries in [Table 5](#iana-stream-type-table) are registered by this document.[¶](#section-11.2.4-5)

[Table 5](#table-5):
[Initial Stream Types](#name-initial-stream-types)

| Stream Type | Value | Specification | Sender |
| --- | --- | --- | --- |
| Control Stream | 0x00 | [Section 6.2.1](#control-streams) | Both |
| Push Stream | 0x01 | [Section 4.6](#server-push) | Server |

Each code of the format `0x1f * N + 0x21` for non-negative integer values of `N`
(that is, 0x21, 0x40, ..., through 0x3ffffffffffffffe) MUST NOT
be assigned by
IANA and MUST NOT
appear in the listing of assigned values.[¶](#section-11.2.4-7)

## [12.](#section-12) [References](#name-references)

### [12.1.](#section-12.1) [Normative References](#name-normative-references)

[ALTSVC]
Nottingham, M., McManus, P., and J. Reschke, "HTTP Alternative Services", RFC 7838, DOI 10.17487/RFC7838, April 2016, <<https://www.rfc-editor.org/info/rfc7838>>.

[COOKIES]
Barth, A., "HTTP State Management Mechanism", RFC 6265, DOI 10.17487/RFC6265, April 2011, <<https://www.rfc-editor.org/info/rfc6265>>.

[HTTP]
Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., "HTTP Semantics", STD 97, RFC 9110, DOI 10.17487/RFC9110, June 2022, <<https://www.rfc-editor.org/info/rfc9110>>.

[HTTP-CACHING]
Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., "HTTP Caching", STD 98, RFC 9111, DOI 10.17487/RFC9111, June 2022, <<https://www.rfc-editor.org/info/rfc9111>>.

[HTTP-REPLAY]
Thomson, M., Nottingham, M., and W. Tarreau, "Using Early Data in HTTP", RFC 8470, DOI 10.17487/RFC8470, September 2018, <<https://www.rfc-editor.org/info/rfc8470>>.

[QPACK]
Krasic, C., Bishop, M., and A. Frindell, Ed., "QPACK: Field Compression for HTTP/3", RFC 9204, DOI 10.17487/RFC9204, June 2022, <<https://www.rfc-editor.org/info/rfc9204>>.

[QUIC-TRANSPORT]
Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based Multiplexed and Secure Transport", RFC 9000, DOI 10.17487/RFC9000, May 2021, <<https://www.rfc-editor.org/info/rfc9000>>.

[RFC0793]
Postel, J., "Transmission Control Protocol", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <<https://www.rfc-editor.org/info/rfc793>>.

[RFC2119]
Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <<https://www.rfc-editor.org/info/rfc2119>>.

[RFC6066]
Eastlake 3rd, D., "Transport Layer Security (TLS) Extensions: Extension Definitions", RFC 6066, DOI 10.17487/RFC6066, January 2011, <<https://www.rfc-editor.org/info/rfc6066>>.

[RFC7301]
Friedl, S., Popov, A., Langley, A., and E. Stephan, "Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301, July 2014, <<https://www.rfc-editor.org/info/rfc7301>>.

[RFC8126]
Cotton, M., Leiba, B., and T. Narten, "Guidelines for Writing an IANA Considerations Section in RFCs", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <<https://www.rfc-editor.org/info/rfc8126>>.

[RFC8174]
Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <<https://www.rfc-editor.org/info/rfc8174>>.

[URI]
Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform Resource Identifier (URI): Generic Syntax", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <<https://www.rfc-editor.org/info/rfc3986>>.

### [12.2.](#section-12.2) [Informative References](#name-informative-references)

[BREACH]
Gluck, Y., Harris, N., and A. Prado, "BREACH: Reviving the CRIME Attack", July 2013, <[http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf](http://breachattack.com/resources/BREACH%20-%20SSL%2C%20gone%20in%2030%20seconds.pdf)>.

[DNS-TERMS]
Hoffman, P., Sullivan, A., and K. Fujiwara, "DNS Terminology", BCP 219, RFC 8499, DOI 10.17487/RFC8499, January 2019, <<https://www.rfc-editor.org/info/rfc8499>>.

[HPACK]
Peon, R. and H. Ruellan, "HPACK: Header Compression for HTTP/2", RFC 7541, DOI 10.17487/RFC7541, May 2015, <<https://www.rfc-editor.org/info/rfc7541>>.

[HTTP/1.1]
Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., "HTTP/1.1", STD 99, RFC 9112, DOI 10.17487/RFC9112, June 2022, <<https://www.rfc-editor.org/info/rfc9112>>.

[HTTP/2]
Thomson, M., Ed. and C. Benfield, Ed., "HTTP/2", RFC 9113, DOI 10.17487/RFC9113, June 2022, <<https://www.rfc-editor.org/info/rfc9113>>.

[RFC6585]
Nottingham, M. and R. Fielding, "Additional HTTP Status Codes", RFC 6585, DOI 10.17487/RFC6585, April 2012, <<https://www.rfc-editor.org/info/rfc6585>>.

[RFC8164]
Nottingham, M. and M. Thomson, "Opportunistic Security for HTTP/2", RFC 8164, DOI 10.17487/RFC8164, May 2017, <<https://www.rfc-editor.org/info/rfc8164>>.

[TFO]
Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, "TCP Fast Open", RFC 7413, DOI 10.17487/RFC7413, December 2014, <<https://www.rfc-editor.org/info/rfc7413>>.

[TLS]
Rescorla, E., "The Transport Layer Security (TLS) Protocol Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018, <<https://www.rfc-editor.org/info/rfc8446>>.

## [Appendix A.](#appendix-A) [Considerations for Transitioning from HTTP/2](#name-considerations-for-transiti)

HTTP/3 is strongly informed by HTTP/2, and it bears many similarities. This
section describes the approach taken to design HTTP/3, points out important
differences from HTTP/2, and describes how to map HTTP/2 extensions into HTTP/3.[¶](#appendix-A-1)

HTTP/3 begins from the premise that similarity to HTTP/2 is preferable, but not
a hard requirement. HTTP/3 departs from HTTP/2 where QUIC differs from TCP,
either to take advantage of QUIC features (like streams) or to accommodate
important shortcomings (such as a lack of total ordering). While HTTP/3 is
similar to HTTP/2 in key aspects, such as the relationship of requests and
responses to streams, the details of the HTTP/3 design are substantially
different from HTTP/2.[¶](#appendix-A-2)

Some important departures are noted in this section.[¶](#appendix-A-3)

### [A.1.](#appendix-A.1) [Streams](#name-streams)

HTTP/3 permits use of a larger number of streams (262-1) than HTTP/2.
The same considerations about exhaustion of stream identifier space apply,
though the space is significantly larger such that it is likely that other
limits in QUIC are reached first, such as the limit on the connection
flow-control window.[¶](#appendix-A.1-1)

In contrast to HTTP/2, stream concurrency in HTTP/3 is managed by QUIC. QUIC
considers a stream closed when all data has been received and sent data has been
acknowledged by the peer. HTTP/2 considers a stream closed when the frame
containing the END\_STREAM bit has been committed to the transport. As a result,
the stream for an equivalent exchange could remain "active" for a longer period
of time. HTTP/3 servers might choose to permit a larger number of concurrent
client-initiated bidirectional streams to achieve equivalent concurrency to
HTTP/2, depending on the expected usage patterns.[¶](#appendix-A.1-2)

In HTTP/2, only request and response bodies (the frame payload of [DATA](#frame-data) frames)
are subject to flow control. All HTTP/3 frames are sent on QUIC streams, so all
frames on all streams are flow controlled in HTTP/3.[¶](#appendix-A.1-3)

Due to the presence of other unidirectional stream types, HTTP/3 does not rely
exclusively on the number of concurrent unidirectional streams to control the
number of concurrent in-flight pushes. Instead, HTTP/3 clients use the
[MAX\_PUSH\_ID](#frame-max-push-id) frame to control the number of pushes received from an HTTP/3
server.[¶](#appendix-A.1-4)

### [A.2.](#appendix-A.2) [HTTP Frame Types](#name-http-frame-types)

Many framing concepts from HTTP/2 can be elided on QUIC, because the transport
deals with them. Because frames are already on a stream, they can omit the
stream number. Because frames do not block multiplexing (QUIC's multiplexing
occurs below this layer), the support for variable-maximum-length packets can be
removed. Because stream termination is handled by QUIC, an END\_STREAM flag is
not required. This permits the removal of the Flags field from the generic
frame layout.[¶](#appendix-A.2-1)

Frame payloads are largely drawn from [[HTTP/2](#RFC9113)]. However, QUIC includes many
features (e.g., flow control) that are also present in HTTP/2. In these cases,
the HTTP mapping does not re-implement them. As a result, several HTTP/2 frame
types are not required in HTTP/3. Where an HTTP/2-defined frame is no longer
used, the frame ID has been reserved in order to maximize portability between
HTTP/2 and HTTP/3 implementations. However, even frame types that appear in
both mappings do not have identical semantics.[¶](#appendix-A.2-2)

Many of the differences arise from the fact that HTTP/2 provides an absolute
ordering between frames across all streams, while QUIC provides this guarantee
on each stream only. As a result, if a frame type makes assumptions that frames
from different streams will still be received in the order sent, HTTP/3 will
break them.[¶](#appendix-A.2-3)

Some examples of feature adaptations are described below, as well as general
guidance to extension frame implementors converting an HTTP/2 extension to
HTTP/3.[¶](#appendix-A.2-4)

#### [A.2.1.](#appendix-A.2.1) [Prioritization Differences](#name-prioritization-differences)

HTTP/2 specifies priority assignments in PRIORITY frames and (optionally) in
[HEADERS](#frame-headers) frames. HTTP/3 does not provide a means of signaling priority.[¶](#appendix-A.2.1-1)

Note that, while there is no explicit signaling for priority, this does not mean
that prioritization is not important for achieving good performance.[¶](#appendix-A.2.1-2)

#### [A.2.2.](#appendix-A.2.2) [Field Compression Differences](#name-field-compression-differenc)

HPACK was designed with the assumption of in-order delivery. A sequence of
encoded field sections must arrive (and be decoded) at an endpoint in the same
order in which they were encoded. This ensures that the dynamic state at the two
endpoints remains in sync.[¶](#appendix-A.2.2-1)

Because this total ordering is not provided by QUIC, HTTP/3 uses a modified
version of HPACK, called QPACK. QPACK uses a single unidirectional stream to
make all modifications to the dynamic table, ensuring a total order of updates.
All frames that contain encoded fields merely reference the table state at a
given time without modifying it.[¶](#appendix-A.2.2-2)

[[QPACK](#RFC9204)] provides additional details.[¶](#appendix-A.2.2-3)

#### [A.2.3.](#appendix-A.2.3) [Flow-Control Differences](#name-flow-control-differences)

HTTP/2 specifies a stream flow-control mechanism. Although all HTTP/2 frames are
delivered on streams, only the [DATA](#frame-data) frame payload is subject to flow control.
QUIC provides flow control for stream data and all HTTP/3 frame types defined in
this document are sent on streams. Therefore, all frame headers and payload are
subject to flow control.[¶](#appendix-A.2.3-1)

#### [A.2.4.](#appendix-A.2.4) [Guidance for New Frame Type Definitions](#name-guidance-for-new-frame-type)

Frame type definitions in HTTP/3 often use the QUIC variable-length integer
encoding. In particular, stream IDs use this encoding, which allows for a
larger range of possible values than the encoding used in HTTP/2. Some frames
in HTTP/3 use an identifier other than a stream ID (e.g., push IDs).
Redefinition of the encoding of extension frame types might be necessary if the
encoding includes a stream ID.[¶](#appendix-A.2.4-1)

Because the Flags field is not present in generic HTTP/3 frames, those frames
that depend on the presence of flags need to allocate space for flags as part
of their frame payload.[¶](#appendix-A.2.4-2)

Other than these issues, frame type HTTP/2 extensions are typically portable to
QUIC simply by replacing stream 0 in HTTP/2 with a [control stream](#control-streams) in HTTP/3.
HTTP/3 extensions will not assume ordering, but would not be harmed by ordering,
and are expected to be portable to HTTP/2.[¶](#appendix-A.2.4-3)

#### [A.2.5.](#appendix-A.2.5) [Comparison of HTTP/2 and HTTP/3 Frame Types](#name-comparison-of-http-2-and-ht)

[DATA](#frame-data) (0x00):

Padding is not defined in HTTP/3 frames. See [Section 7.2.1](#frame-data).[¶](#appendix-A.2.5-1.2.1)

[HEADERS](#frame-headers) (0x01):

The PRIORITY region of [HEADERS](#frame-headers) is not defined in HTTP/3 frames. Padding is not
defined in HTTP/3 frames. See [Section 7.2.2](#frame-headers).[¶](#appendix-A.2.5-1.4.1)

PRIORITY (0x02):

As described in [Appendix A.2.1](#h2-diff-priority), HTTP/3 does not provide a means of
signaling priority.[¶](#appendix-A.2.5-1.6.1)

RST\_STREAM (0x03):

RST\_STREAM frames do not exist in HTTP/3, since QUIC provides stream lifecycle
management. The same code point is used for the [CANCEL\_PUSH](#frame-cancel-push) frame
([Section 7.2.3](#frame-cancel-push)).[¶](#appendix-A.2.5-1.8.1)

[SETTINGS](#frame-settings) (0x04):

[SETTINGS](#frame-settings) frames are sent only at the beginning of the connection. See
[Section 7.2.4](#frame-settings) and [Appendix A.3](#h2-settings).[¶](#appendix-A.2.5-1.10.1)

[PUSH\_PROMISE](#frame-push-promise) (0x05):

The [PUSH\_PROMISE](#frame-push-promise) frame does not reference a stream; instead, the [push stream](#push-streams)
references the [PUSH\_PROMISE](#frame-push-promise) frame using a [push ID](#server-push). See
[Section 7.2.5](#frame-push-promise).[¶](#appendix-A.2.5-1.12.1)

PING (0x06):

PING frames do not exist in HTTP/3, as QUIC provides equivalent
functionality.[¶](#appendix-A.2.5-1.14.1)

[GOAWAY](#frame-goaway) (0x07):

[GOAWAY](#frame-goaway) does not contain an error code. In the client-to-server direction,
it carries a [push ID](#server-push) instead of a server-initiated stream ID.
See [Section 7.2.6](#frame-goaway).[¶](#appendix-A.2.5-1.16.1)

WINDOW\_UPDATE (0x08):

WINDOW\_UPDATE frames do not exist in HTTP/3, since QUIC provides flow control.[¶](#appendix-A.2.5-1.18.1)

CONTINUATION (0x09):

CONTINUATION frames do not exist in HTTP/3; instead, larger
[HEADERS](#frame-headers)/[PUSH\_PROMISE](#frame-push-promise) frames than HTTP/2 are permitted.[¶](#appendix-A.2.5-1.20.1)

Frame types defined by extensions to HTTP/2 need to be separately registered for
HTTP/3 if still applicable. The IDs of frames defined in [[HTTP/2](#RFC9113)] have been
reserved for simplicity. Note that the frame type space in HTTP/3 is
substantially larger (62 bits versus 8 bits), so many HTTP/3 frame types have no
equivalent HTTP/2 code points. See [Section 11.2.1](#iana-frames).[¶](#appendix-A.2.5-2)

### [A.3.](#appendix-A.3) [HTTP/2 SETTINGS Parameters](#name-http-2-settings-parameters)

An important difference from HTTP/2 is that settings are sent once, as the first
frame of the [control stream](#control-streams), and thereafter cannot change. This eliminates many
corner cases around synchronization of changes.[¶](#appendix-A.3-1)

Some transport-level options that HTTP/2 specifies via the [SETTINGS](#frame-settings) frame are
superseded by QUIC transport parameters in HTTP/3. The HTTP-level setting that
is retained in HTTP/3 has the same value as in HTTP/2. The superseded
settings are reserved, and their receipt is an error. See
[Section 7.2.4.1](#settings-parameters) for discussion of both the retained and reserved values.[¶](#appendix-A.3-2)

Below is a listing of how each HTTP/2 [SETTINGS](#frame-settings) parameter is mapped:[¶](#appendix-A.3-3)

SETTINGS\_HEADER\_TABLE\_SIZE (0x01):

See [[QPACK](#RFC9204)].[¶](#appendix-A.3-4.2.1)

SETTINGS\_ENABLE\_PUSH (0x02):

This is removed in favor of the [MAX\_PUSH\_ID](#frame-max-push-id) frame, which provides a more
granular control over server push. Specifying a setting with the identifier
0x02 (corresponding to the SETTINGS\_ENABLE\_PUSH parameter) in the HTTP/3
[SETTINGS](#frame-settings) frame is an error.[¶](#appendix-A.3-4.4.1)

SETTINGS\_MAX\_CONCURRENT\_STREAMS (0x03):

QUIC controls the largest open stream ID as part of its flow-control logic.
Specifying a setting with the identifier 0x03 (corresponding to the
SETTINGS\_MAX\_CONCURRENT\_STREAMS parameter) in the HTTP/3 [SETTINGS](#frame-settings) frame is an
error.[¶](#appendix-A.3-4.6.1)

SETTINGS\_INITIAL\_WINDOW\_SIZE (0x04):

QUIC requires both stream and connection flow-control window sizes to be
specified in the initial transport handshake. Specifying a setting with the
identifier 0x04 (corresponding to the SETTINGS\_INITIAL\_WINDOW\_SIZE parameter)
in the HTTP/3 [SETTINGS](#frame-settings) frame is an error.[¶](#appendix-A.3-4.8.1)

SETTINGS\_MAX\_FRAME\_SIZE (0x05):

This setting has no equivalent in HTTP/3. Specifying a setting with the
identifier 0x05 (corresponding to the SETTINGS\_MAX\_FRAME\_SIZE parameter) in
the HTTP/3 [SETTINGS](#frame-settings) frame is an error.[¶](#appendix-A.3-4.10.1)

SETTINGS\_MAX\_HEADER\_LIST\_SIZE (0x06):

This setting identifier has been renamed [SETTINGS\_MAX\_FIELD\_SECTION\_SIZE](#SETTINGS_MAX_FIELD_SECTION_SIZE).[¶](#appendix-A.3-4.12.1)

In HTTP/3, setting values are variable-length integers (6, 14, 30, or 62 bits
long) rather than fixed-length 32-bit fields as in HTTP/2. This will often
produce a shorter encoding, but can produce a longer encoding for settings that
use the full 32-bit space. Settings ported from HTTP/2 might choose to redefine
their value to limit it to 30 bits for more efficient encoding or to make use
of the 62-bit space if more than 30 bits are required.[¶](#appendix-A.3-5)

Settings need to be defined separately for HTTP/2 and HTTP/3. The IDs of
settings defined in [[HTTP/2](#RFC9113)] have been reserved for simplicity. Note that
the settings identifier space in HTTP/3 is substantially larger (62 bits versus
16 bits), so many HTTP/3 settings have no equivalent HTTP/2 code point. See
[Section 11.2.2](#iana-settings).[¶](#appendix-A.3-6)

As QUIC streams might arrive out of order, endpoints are advised not to wait for
the peers' settings to arrive before responding to other streams. See
[Section 7.2.4.2](#settings-initialization).[¶](#appendix-A.3-7)

### [A.4.](#appendix-A.4) [HTTP/2 Error Codes](#name-http-2-error-codes)

QUIC has the same concepts of "stream" and "connection" errors that HTTP/2
provides. However, the differences between HTTP/2 and HTTP/3 mean that error
codes are not directly portable between versions.[¶](#appendix-A.4-1)

The HTTP/2 error codes defined in [Section 7](https://www.rfc-editor.org/rfc/rfc9113#section-7) of [[HTTP/2](#RFC9113)] logically map to
the HTTP/3 error codes as follows:[¶](#appendix-A.4-2)

NO\_ERROR (0x00):

[H3\_NO\_ERROR](#H3_NO_ERROR) in [Section 8.1](#http-error-codes).[¶](#appendix-A.4-3.2.1)

PROTOCOL\_ERROR (0x01):

This is mapped to [H3\_GENERAL\_PROTOCOL\_ERROR](#H3_GENERAL_PROTOCOL_ERROR) except in cases where more
specific error codes have been defined. Such cases include
[H3\_FRAME\_UNEXPECTED](#H3_FRAME_UNEXPECTED), [H3\_MESSAGE\_ERROR](#H3_MESSAGE_ERROR), and [H3\_CLOSED\_CRITICAL\_STREAM](#H3_CLOSED_CRITICAL_STREAM) defined
in [Section 8.1](#http-error-codes).[¶](#appendix-A.4-3.4.1)

INTERNAL\_ERROR (0x02):

[H3\_INTERNAL\_ERROR](#H3_INTERNAL_ERROR) in [Section 8.1](#http-error-codes).[¶](#appendix-A.4-3.6.1)

FLOW\_CONTROL\_ERROR (0x03):

Not applicable, since QUIC handles flow control.[¶](#appendix-A.4-3.8.1)

SETTINGS\_TIMEOUT (0x04):

Not applicable, since no acknowledgment of [SETTINGS](#frame-settings) is defined.[¶](#appendix-A.4-3.10.1)

STREAM\_CLOSED (0x05):

Not applicable, since QUIC handles stream management.[¶](#appendix-A.4-3.12.1)

FRAME\_SIZE\_ERROR (0x06):

[H3\_FRAME\_ERROR](#H3_FRAME_ERROR) error code defined in [Section 8.1](#http-error-codes).[¶](#appendix-A.4-3.14.1)

REFUSED\_STREAM (0x07):

[H3\_REQUEST\_REJECTED](#H3_REQUEST_REJECTED) (in [Section 8.1](#http-error-codes)) is used to indicate that a
request was not processed. Otherwise, not applicable because QUIC handles
stream management.[¶](#appendix-A.4-3.16.1)

CANCEL (0x08):

[H3\_REQUEST\_CANCELLED](#H3_REQUEST_CANCELLED) in [Section 8.1](#http-error-codes).[¶](#appendix-A.4-3.18.1)

COMPRESSION\_ERROR (0x09):

Multiple error codes are defined in [[QPACK](#RFC9204)].[¶](#appendix-A.4-3.20.1)

CONNECT\_ERROR (0x0a):

[H3\_CONNECT\_ERROR](#H3_CONNECT_ERROR) in [Section 8.1](#http-error-codes).[¶](#appendix-A.4-3.22.1)

ENHANCE\_YOUR\_CALM (0x0b):

[H3\_EXCESSIVE\_LOAD](#H3_EXCESSIVE_LOAD) in [Section 8.1](#http-error-codes).[¶](#appendix-A.4-3.24.1)

INADEQUATE\_SECURITY (0x0c):

Not applicable, since QUIC is assumed to provide sufficient security on all
connections.[¶](#appendix-A.4-3.26.1)

HTTP\_1\_1\_REQUIRED (0x0d):

[H3\_VERSION\_FALLBACK](#H3_VERSION_FALLBACK) in [Section 8.1](#http-error-codes).[¶](#appendix-A.4-3.28.1)

Error codes need to be defined for HTTP/2 and HTTP/3 separately. See
[Section 11.2.3](#iana-error-codes).[¶](#appendix-A.4-4)

#### [A.4.1.](#appendix-A.4.1) [Mapping between HTTP/2 and HTTP/3 Errors](#name-mapping-between-http-2-and-)

An intermediary that converts between HTTP/2 and HTTP/3 may encounter error
conditions from either upstream. It is useful to communicate the occurrence of
errors to the downstream, but error codes largely reflect connection-local
problems that generally do not make sense to propagate.[¶](#appendix-A.4.1-1)

An intermediary that encounters an error from an upstream origin can indicate
this by sending an HTTP status code such as 502 (Bad Gateway), which is suitable
for a broad class of errors.[¶](#appendix-A.4.1-2)

There are some rare cases where it is beneficial to propagate the error by
mapping it to the closest matching error type to the receiver. For example, an
intermediary that receives an HTTP/2 [stream error](#errors) of type REFUSED\_STREAM from
the origin has a clear signal that the request was not processed and that the
request is safe to retry. Propagating this error condition to the client as an
HTTP/3 [stream error](#errors) of type [H3\_REQUEST\_REJECTED](#H3_REQUEST_REJECTED) allows the client to take the
action it deems most appropriate. In the reverse direction, the intermediary
might deem it beneficial to pass on client request cancellations that are
indicated by terminating a stream with [H3\_REQUEST\_CANCELLED](#H3_REQUEST_CANCELLED); see
[Section 4.1.1](#request-cancellation).[¶](#appendix-A.4.1-3)

Conversion between errors is described in the logical mapping. The error codes
are defined in non-overlapping spaces in order to protect against accidental
conversion that could result in the use of inappropriate or unknown error codes
for the target version. An intermediary is permitted to promote [stream errors](#errors) to
[connection errors](#errors) but they should be aware of the cost to the HTTP/3 connection
for what might be a temporary or intermittent error.[¶](#appendix-A.4.1-4)

## [Acknowledgments](#name-acknowledgments)

Robbie Shade and Mike Warres were the authors of
draft-shade-quic-http2-mapping, a precursor of this document.[¶](#appendix-B-1)

The IETF QUIC Working Group received an enormous amount of support from many
people. Among others, the following people provided substantial contributions to
this document:[¶](#appendix-B-2)

* Bence Beky[¶](#appendix-B-3.1.1)
* Daan De Meyer[¶](#appendix-B-3.2.1)
* Martin Duke[¶](#appendix-B-3.3.1)
* Roy Fielding[¶](#appendix-B-3.4.1)
* Alan Frindell[¶](#appendix-B-3.5.1)
* Alessandro Ghedini[¶](#appendix-B-3.6.1)
* Nick Harper[¶](#appendix-B-3.7.1)
* Ryan Hamilton[¶](#appendix-B-3.8.1)
* Christian Huitema[¶](#appendix-B-3.9.1)
* Subodh Iyengar[¶](#appendix-B-3.10.1)
* Robin Marx[¶](#appendix-B-3.11.1)
* Patrick McManus[¶](#appendix-B-3.12.1)
* Luca Niccolini[¶](#appendix-B-3.13.1)
* 奥 一穂 (Kazuho Oku)[¶](#appendix-B-3.14.1)
* Lucas Pardue[¶](#appendix-B-3.15.1)
* Roberto Peon[¶](#appendix-B-3.16.1)
* Julian Reschke[¶](#appendix-B-3.17.1)
* Eric Rescorla[¶](#appendix-B-3.18.1)
* Martin Seemann[¶](#appendix-B-3.19.1)
* Ben Schwartz[¶](#appendix-B-3.20.1)
* Ian Swett[¶](#appendix-B-3.21.1)
* Willy Taureau[¶](#appendix-B-3.22.1)
* Martin Thomson[¶](#appendix-B-3.23.1)
* Dmitri Tikhonov[¶](#appendix-B-3.24.1)
* Tatsuhiro Tsujikawa[¶](#appendix-B-3.25.1)

A portion of Mike Bishop's contribution was supported by Microsoft during
his employment there.[¶](#appendix-B-4)

## [Index](#name-index)

[C](#rfc.index.u67)
[D](#rfc.index.u68)
[G](#rfc.index.u71)
[H](#rfc.index.u72)
[M](#rfc.index.u77)
[P](#rfc.index.u80)
[R](#rfc.index.u82)
[S](#rfc.index.u83)[¶](#appendix-C-1)

* [C](#rfc.index.u67)[¶](#appendix-C-2.1.1)

  + CANCEL\_PUSH

    [Section 2, Paragraph 5](#section-2-5);
    [Section 4.6, Paragraph 6](#section-4.6-6);
    [Section 4.6, Paragraph 10](#section-4.6-10);
    [Table 1](#stream-frame-mapping);
    ***[Section 7.2.3](#frame-cancel-push)***;
    [Section 7.2.5, Paragraph 4.2.1](#section-7.2.5-4.2.1);
    [Section 7.2.7, Paragraph 1](#section-7.2.7-1);
    [Table 2](#iana-frame-table);
    [Appendix A.2.5, Paragraph 1.8.1](#appendix-A.2.5-1.8.1)[¶](#appendix-C-2.1.2.1.1.2.1)

    connection error

    [Section 2.2](#section-2.2-4.7);
    [Section 4.1, Paragraph 7](#section-4.1-7);
    [Section 4.1, Paragraph 8](#section-4.1-8);
    [Section 4.4, Paragraph 8](#section-4.4-8);
    [Section 4.4, Paragraph 10](#section-4.4-10);
    [Section 4.6, Paragraph 3](#section-4.6-3);
    [Section 5.2, Paragraph 7](#section-5.2-7);
    [Section 6.1, Paragraph 3](#section-6.1-3);
    [Section 6.2, Paragraph 7](#section-6.2-7);
    [Section 6.2.1, Paragraph 2](#section-6.2.1-2);
    [Section 6.2.1, Paragraph 2](#section-6.2.1-2);
    [Section 6.2.1, Paragraph 2](#section-6.2.1-2);
    [Section 6.2.2, Paragraph 3](#section-6.2.2-3);
    [Section 6.2.2, Paragraph 6](#section-6.2.2-6);
    [Section 7.1, Paragraph 5](#section-7.1-5);
    [Section 7.1, Paragraph 6](#section-7.1-6);
    [Section 7.2.1, Paragraph 2](#section-7.2.1-2);
    [Section 7.2.2, Paragraph 3](#section-7.2.2-3);
    [Section 7.2.3, Paragraph 5](#section-7.2.3-5);
    [Section 7.2.3, Paragraph 7](#section-7.2.3-7);
    [Section 7.2.3, Paragraph 8](#section-7.2.3-8);
    [Section 7.2.4, Paragraph 2](#section-7.2.4-2);
    [Section 7.2.4, Paragraph 3](#section-7.2.4-3);
    [Section 7.2.4, Paragraph 6](#section-7.2.4-6);
    [Section 7.2.4.1, Paragraph 5](#section-7.2.4.1-5);
    [Section 7.2.4.2, Paragraph 8](#section-7.2.4.2-8);
    [Section 7.2.4.2, Paragraph 8](#section-7.2.4.2-8);
    [Section 7.2.5, Paragraph 5](#section-7.2.5-5);
    [Section 7.2.5, Paragraph 6](#section-7.2.5-6);
    [Section 7.2.5, Paragraph 8](#section-7.2.5-8);
    [Section 7.2.5, Paragraph 9](#section-7.2.5-9);
    [Section 7.2.6, Paragraph 3](#section-7.2.6-3);
    [Section 7.2.6, Paragraph 5](#section-7.2.6-5);
    [Section 7.2.7, Paragraph 2](#section-7.2.7-2);
    [Section 7.2.7, Paragraph 3](#section-7.2.7-3);
    [Section 7.2.7, Paragraph 6](#section-7.2.7-6);
    [Section 7.2.8, Paragraph 3](#section-7.2.8-3);
    ***[Section 8](#errors)***;
    [Section 10.5, Paragraph 7](#section-10.5-7);
    [Appendix A.4.1, Paragraph 4](#appendix-A.4.1-4)[¶](#appendix-C-2.1.2.1.1.4.1)

    control stream

    [Section 2, Paragraph 3](#section-2-3);
    [Section 3.2, Paragraph 4](#section-3.2-4);
    [Section 6.2, Paragraph 3](#section-6.2-3);
    [Section 6.2, Paragraph 5](#section-6.2-5);
    [Section 6.2, Paragraph 6](#section-6.2-6);
    ***[Section 6.2.1](#control-streams)***;
    [Section 7, Paragraph 1](#section-7-1);
    [Section 7.2.1, Paragraph 2](#section-7.2.1-2);
    [Section 7.2.2, Paragraph 3](#section-7.2.2-3);
    [Section 7.2.3, Paragraph 5](#section-7.2.3-5);
    [Section 7.2.3, Paragraph 5](#section-7.2.3-5);
    [Section 7.2.4, Paragraph 2](#section-7.2.4-2);
    [Section 7.2.4, Paragraph 2](#section-7.2.4-2);
    [Section 7.2.4, Paragraph 3](#section-7.2.4-3);
    [Section 7.2.5, Paragraph 8](#section-7.2.5-8);
    [Section 7.2.6, Paragraph 3](#section-7.2.6-3);
    [Section 7.2.6, Paragraph 5](#section-7.2.6-5);
    [Section 7.2.7, Paragraph 2](#section-7.2.7-2);
    [Section 8.1, Paragraph 2.22.1](#H3_MISSING_SETTINGS);
    [Section 9, Paragraph 4](#section-9-4);
    [Appendix A.2.4, Paragraph 3](#appendix-A.2.4-3);
    [Appendix A.3, Paragraph 1](#appendix-A.3-1)[¶](#appendix-C-2.1.2.1.1.6.1)
* [D](#rfc.index.u68)[¶](#appendix-C-2.2.1)

  + DATA

    [Section 2, Paragraph 3](#section-2-3);
    [Section 4.1, Paragraph 5, Item 2](#section-4.1-5.2);
    [Section 4.1, Paragraph 7](#section-4.1-7);
    [Section 4.1, Paragraph 7](#section-4.1-7);
    [Section 4.1.2, Paragraph 3](#section-4.1.2-3);
    [Section 4.1.2, Paragraph 3](#section-4.1.2-3);
    [Section 4.4, Paragraph 7](#section-4.4-7);
    [Section 4.4, Paragraph 7](#section-4.4-7);
    [Section 4.4, Paragraph 7](#section-4.4-7);
    [Section 4.4, Paragraph 7](#section-4.4-7);
    [Section 4.4, Paragraph 8](#section-4.4-8);
    [Section 4.6, Paragraph 12](#section-4.6-12);
    [Table 1](#stream-frame-mapping);
    ***[Section 7.2.1](#frame-data)***;
    [Table 2](#iana-frame-table);
    [Appendix A.1, Paragraph 3](#appendix-A.1-3);
    [Appendix A.2.3, Paragraph 1](#appendix-A.2.3-1);
    [Appendix A.2.5](#appendix-A.2.5-1.1)[¶](#appendix-C-2.2.2.1.1.2.1)
* [G](#rfc.index.u71)[¶](#appendix-C-2.3.1)

  + GOAWAY

    [Section 3.3, Paragraph 5](#section-3.3-5);
    [Section 5.2, Paragraph 1](#section-5.2-1);
    [Section 5.2, Paragraph 1](#section-5.2-1);
    [Section 5.2, Paragraph 1](#section-5.2-1);
    [Section 5.2, Paragraph 2](#section-5.2-2);
    [Section 5.2, Paragraph 2](#section-5.2-2);
    [Section 5.2, Paragraph 3](#section-5.2-3);
    [Section 5.2, Paragraph 5.1.1](#section-5.2-5.1.1);
    [Section 5.2, Paragraph 5.1.1](#section-5.2-5.1.1);
    [Section 5.2, Paragraph 5.1.2](#section-5.2-5.1.2);
    [Section 5.2, Paragraph 5.1.2](#section-5.2-5.1.2);
    [Section 5.2, Paragraph 5, Item 2](#section-5.2-5.2);
    [Section 5.2, Paragraph 5, Item 2](#section-5.2-5.2);
    [Section 5.2, Paragraph 6](#section-5.2-6);
    [Section 5.2, Paragraph 6](#section-5.2-6);
    [Section 5.2, Paragraph 7](#section-5.2-7);
    [Section 5.2, Paragraph 7](#section-5.2-7);
    [Section 5.2, Paragraph 8](#section-5.2-8);
    [Section 5.2, Paragraph 8](#section-5.2-8);
    [Section 5.2, Paragraph 9](#section-5.2-9);
    [Section 5.2, Paragraph 9](#section-5.2-9);
    [Section 5.2, Paragraph 10](#section-5.2-10);
    [Section 5.2, Paragraph 12](#section-5.2-12);
    [Section 5.3, Paragraph 2](#section-5.3-2);
    [Section 5.3, Paragraph 2](#section-5.3-2);
    [Section 5.4, Paragraph 2](#section-5.4-2);
    [Table 1](#stream-frame-mapping);
    ***[Section 7.2.6](#frame-goaway)***;
    [Table 2](#iana-frame-table);
    [Appendix A.2.5](#appendix-A.2.5-1.15);
    [Appendix A.2.5, Paragraph 1.16.1](#appendix-A.2.5-1.16.1)[¶](#appendix-C-2.3.2.1.1.2.1)
* [H](#rfc.index.u72)[¶](#appendix-C-2.4.1)

  + H3\_CLOSED\_CRITICAL\_STREAM

    [Section 6.2.1, Paragraph 2](#section-6.2.1-2);
    [Section 8.1](#section-8.1-2.9);
    [Table 4](#iana-error-table);
    [Appendix A.4, Paragraph 3.4.1](#appendix-A.4-3.4.1)[¶](#appendix-C-2.4.2.1.1.2.1)

    H3\_CONNECT\_ERROR

    [Section 4.4, Paragraph 10](#section-4.4-10);
    [Section 8.1](#section-8.1-2.31);
    [Table 4](#iana-error-table);
    [Appendix A.4, Paragraph 3.22.1](#appendix-A.4-3.22.1)[¶](#appendix-C-2.4.2.1.1.4.1)

    H3\_EXCESSIVE\_LOAD

    [Section 8.1](#section-8.1-2.15);
    [Section 10.5, Paragraph 7](#section-10.5-7);
    [Table 4](#iana-error-table);
    [Appendix A.4, Paragraph 3.24.1](#appendix-A.4-3.24.1)[¶](#appendix-C-2.4.2.1.1.6.1)

    H3\_FRAME\_ERROR

    [Section 7.1, Paragraph 5](#section-7.1-5);
    [Section 7.1, Paragraph 6](#section-7.1-6);
    [Section 8.1](#section-8.1-2.13);
    [Table 4](#iana-error-table);
    [Appendix A.4, Paragraph 3.14.1](#appendix-A.4-3.14.1)[¶](#appendix-C-2.4.2.1.1.8.1)

    H3\_FRAME\_UNEXPECTED

    [Section 4.1, Paragraph 7](#section-4.1-7);
    [Section 4.1, Paragraph 8](#section-4.1-8);
    [Section 4.4, Paragraph 8](#section-4.4-8);
    [Section 7.2.1, Paragraph 2](#section-7.2.1-2);
    [Section 7.2.2, Paragraph 3](#section-7.2.2-3);
    [Section 7.2.3, Paragraph 5](#section-7.2.3-5);
    [Section 7.2.4, Paragraph 2](#section-7.2.4-2);
    [Section 7.2.4, Paragraph 3](#section-7.2.4-3);
    [Section 7.2.5, Paragraph 8](#section-7.2.5-8);
    [Section 7.2.5, Paragraph 9](#section-7.2.5-9);
    [Section 7.2.6, Paragraph 5](#section-7.2.6-5);
    [Section 7.2.7, Paragraph 2](#section-7.2.7-2);
    [Section 7.2.7, Paragraph 3](#section-7.2.7-3);
    [Section 7.2.8, Paragraph 3](#section-7.2.8-3);
    [Section 8.1](#section-8.1-2.11);
    [Table 4](#iana-error-table);
    [Appendix A.4, Paragraph 3.4.1](#appendix-A.4-3.4.1)[¶](#appendix-C-2.4.2.1.1.10.1)

    H3\_GENERAL\_PROTOCOL\_ERROR

    [Section 7.2.5, Paragraph 6](#section-7.2.5-6);
    [Section 8.1](#section-8.1-2.3);
    [Table 4](#iana-error-table);
    [Appendix A.4, Paragraph 3.4.1](#appendix-A.4-3.4.1)[¶](#appendix-C-2.4.2.1.1.12.1)

    H3\_ID\_ERROR

    [Section 4.6, Paragraph 3](#section-4.6-3);
    [Section 5.2, Paragraph 7](#section-5.2-7);
    [Section 6.2.2, Paragraph 6](#section-6.2.2-6);
    [Section 7.2.3, Paragraph 7](#section-7.2.3-7);
    [Section 7.2.3, Paragraph 8](#section-7.2.3-8);
    [Section 7.2.5, Paragraph 5](#section-7.2.5-5);
    [Section 7.2.6, Paragraph 3](#section-7.2.6-3);
    [Section 7.2.7, Paragraph 6](#section-7.2.7-6);
    [Section 8.1](#section-8.1-2.17);
    [Table 4](#iana-error-table)[¶](#appendix-C-2.4.2.1.1.14.1)

    H3\_INTERNAL\_ERROR

    [Section 8.1](#section-8.1-2.5);
    [Table 4](#iana-error-table);
    [Appendix A.4, Paragraph 3.6.1](#appendix-A.4-3.6.1)[¶](#appendix-C-2.4.2.1.1.16.1)

    H3\_MESSAGE\_ERROR

    [Section 4.1.2, Paragraph 4](#section-4.1.2-4);
    [Section 8.1](#section-8.1-2.29);
    [Table 4](#iana-error-table);
    [Appendix A.4, Paragraph 3.4.1](#appendix-A.4-3.4.1)[¶](#appendix-C-2.4.2.1.1.18.1)

    H3\_MISSING\_SETTINGS

    [Section 6.2.1, Paragraph 2](#section-6.2.1-2);
    [Section 8.1](#section-8.1-2.21);
    [Table 4](#iana-error-table)[¶](#appendix-C-2.4.2.1.1.20.1)

    H3\_NO\_ERROR

    [Section 4.1, Paragraph 15](#section-4.1-15);
    [Section 5.2, Paragraph 11](#section-5.2-11);
    [Section 6.2.3, Paragraph 2](#section-6.2.3-2);
    [Section 8, Paragraph 5](#section-8-5);
    [Section 8.1](#section-8.1-2.1);
    [Section 8.1, Paragraph 3](#section-8.1-3);
    [Section 8.1, Paragraph 3](#section-8.1-3);
    [Table 4](#iana-error-table);
    [Appendix A.4, Paragraph 3.2.1](#appendix-A.4-3.2.1)[¶](#appendix-C-2.4.2.1.1.22.1)

    H3\_REQUEST\_CANCELLED

    [Section 4.1.1, Paragraph 4](#section-4.1.1-4);
    [Section 4.1.1, Paragraph 5](#section-4.1.1-5);
    [Section 4.6, Paragraph 14](#section-4.6-14);
    [Section 7.2.3, Paragraph 3](#section-7.2.3-3);
    [Section 7.2.3, Paragraph 4](#section-7.2.3-4);
    [Section 8.1](#section-8.1-2.25);
    [Table 4](#iana-error-table);
    [Appendix A.4, Paragraph 3.18.1](#appendix-A.4-3.18.1);
    [Appendix A.4.1, Paragraph 3](#appendix-A.4.1-3)[¶](#appendix-C-2.4.2.1.1.24.1)

    H3\_REQUEST\_INCOMPLETE

    [Section 4.1, Paragraph 14](#section-4.1-14);
    [Section 8.1](#section-8.1-2.27);
    [Table 4](#iana-error-table)[¶](#appendix-C-2.4.2.1.1.26.1)

    H3\_REQUEST\_REJECTED

    [Section 4.1.1, Paragraph 3](#section-4.1.1-3);
    [Section 4.1.1, Paragraph 4](#section-4.1.1-4);
    [Section 4.1.1, Paragraph 5](#section-4.1.1-5);
    [Section 4.1.1, Paragraph 5](#section-4.1.1-5);
    [Section 8.1](#section-8.1-2.23);
    [Table 4](#iana-error-table);
    [Appendix A.4, Paragraph 3.16.1](#appendix-A.4-3.16.1);
    [Appendix A.4.1, Paragraph 3](#appendix-A.4.1-3)[¶](#appendix-C-2.4.2.1.1.28.1)

    H3\_SETTINGS\_ERROR

    [Section 7.2.4, Paragraph 6](#section-7.2.4-6);
    [Section 7.2.4.1, Paragraph 5](#section-7.2.4.1-5);
    [Section 7.2.4.2, Paragraph 8](#section-7.2.4.2-8);
    [Section 7.2.4.2, Paragraph 8](#section-7.2.4.2-8);
    [Section 8.1](#section-8.1-2.19);
    [Table 4](#iana-error-table)[¶](#appendix-C-2.4.2.1.1.30.1)

    H3\_STREAM\_CREATION\_ERROR

    [Section 6.1, Paragraph 3](#section-6.1-3);
    [Section 6.2, Paragraph 7](#section-6.2-7);
    [Section 6.2.1, Paragraph 2](#section-6.2.1-2);
    [Section 6.2.2, Paragraph 3](#section-6.2.2-3);
    [Section 8.1](#section-8.1-2.7);
    [Table 4](#iana-error-table)[¶](#appendix-C-2.4.2.1.1.32.1)

    H3\_VERSION\_FALLBACK

    [Section 8.1](#section-8.1-2.33);
    [Table 4](#iana-error-table);
    [Appendix A.4, Paragraph 3.28.1](#appendix-A.4-3.28.1)[¶](#appendix-C-2.4.2.1.1.34.1)

    HEADERS

    [Section 2, Paragraph 3](#section-2-3);
    [Section 4.1, Paragraph 5, Item 1](#section-4.1-5.1);
    [Section 4.1, Paragraph 5, Item 3](#section-4.1-5.3);
    [Section 4.1, Paragraph 7](#section-4.1-7);
    [Section 4.1, Paragraph 7](#section-4.1-7);
    [Section 4.1, Paragraph 7](#section-4.1-7);
    [Section 4.1, Paragraph 10](#section-4.1-10);
    [Section 4.4, Paragraph 6](#section-4.4-6);
    [Section 4.6, Paragraph 12](#section-4.6-12);
    [Table 1](#stream-frame-mapping);
    ***[Section 7.2.2](#frame-headers)***;
    [Section 9, Paragraph 5](#section-9-5);
    [Table 2](#iana-frame-table);
    [Appendix A.2.1, Paragraph 1](#appendix-A.2.1-1);
    [Appendix A.2.5](#appendix-A.2.5-1.3);
    [Appendix A.2.5, Paragraph 1.4.1](#appendix-A.2.5-1.4.1);
    [Appendix A.2.5, Paragraph 1.20.1](#appendix-A.2.5-1.20.1)[¶](#appendix-C-2.4.2.1.1.36.1)
* [M](#rfc.index.u77)[¶](#appendix-C-2.5.1)

  + malformed

    [Section 4.1, Paragraph 3](#section-4.1-3);
    ***[Section 4.1.2](#malformed)***;
    [Section 4.2, Paragraph 2](#section-4.2-2);
    [Section 4.2, Paragraph 3](#section-4.2-3);
    [Section 4.2, Paragraph 5](#section-4.2-5);
    [Section 4.3, Paragraph 3](#section-4.3-3);
    [Section 4.3, Paragraph 4](#section-4.3-4);
    [Section 4.3.1, Paragraph 5](#section-4.3.1-5);
    [Section 4.3.2, Paragraph 1](#section-4.3.2-1);
    [Section 4.4, Paragraph 5](#section-4.4-5);
    [Section 8.1, Paragraph 2.30.1](#H3_MESSAGE_ERROR);
    [Section 10.3, Paragraph 1](#section-10.3-1);
    [Section 10.3, Paragraph 2](#section-10.3-2);
    [Section 10.5.1, Paragraph 2](#section-10.5.1-2)[¶](#appendix-C-2.5.2.1.1.2.1)

    MAX\_PUSH\_ID

    [Section 2, Paragraph 5](#section-2-5);
    [Section 4.6, Paragraph 3](#section-4.6-3);
    [Section 4.6, Paragraph 3](#section-4.6-3);
    [Section 4.6, Paragraph 3](#section-4.6-3);
    [Section 4.6, Paragraph 3](#section-4.6-3);
    [Table 1](#stream-frame-mapping);
    [Section 7.2.5, Paragraph 5](#section-7.2.5-5);
    ***[Section 7.2.7](#frame-max-push-id)***;
    [Table 2](#iana-frame-table);
    [Appendix A.1, Paragraph 4](#appendix-A.1-4);
    [Appendix A.3, Paragraph 4.4.1](#appendix-A.3-4.4.1)[¶](#appendix-C-2.5.2.1.1.4.1)
* [P](#rfc.index.u80)[¶](#appendix-C-2.6.1)

  + push ID

    ***[Section 4.6](#server-push)***;
    [Section 5.2, Paragraph 1](#section-5.2-1);
    [Section 5.2, Paragraph 5, Item 2](#section-5.2-5.2);
    [Section 5.2, Paragraph 9](#section-5.2-9);
    [Section 6.2.2, Paragraph 2](#section-6.2.2-2);
    [Section 6.2.2, Paragraph 6](#section-6.2.2-6);
    [Section 6.2.2, Paragraph 6](#section-6.2.2-6);
    [Section 7.2.3, Paragraph 1](#section-7.2.3-1);
    [Section 7.2.3, Paragraph 7](#section-7.2.3-7);
    [Section 7.2.3, Paragraph 7](#section-7.2.3-7);
    [Section 7.2.3, Paragraph 8](#section-7.2.3-8);
    [Section 7.2.3, Paragraph 8](#section-7.2.3-8);
    [Section 7.2.5, Paragraph 4.2.1](#section-7.2.5-4.2.1);
    [Section 7.2.5, Paragraph 5](#section-7.2.5-5);
    [Section 7.2.5, Paragraph 5](#section-7.2.5-5);
    [Section 7.2.5, Paragraph 6](#section-7.2.5-6);
    [Section 7.2.5, Paragraph 6](#section-7.2.5-6);
    [Section 7.2.5, Paragraph 7](#section-7.2.5-7);
    [Section 7.2.5, Paragraph 7](#section-7.2.5-7);
    [Section 7.2.5, Paragraph 7](#section-7.2.5-7);
    [Section 7.2.6, Paragraph 4](#section-7.2.6-4);
    [Section 7.2.7, Paragraph 1](#section-7.2.7-1);
    [Section 7.2.7, Paragraph 4](#section-7.2.7-4);
    [Section 7.2.7, Paragraph 4](#section-7.2.7-4);
    [Section 7.2.7, Paragraph 6](#section-7.2.7-6);
    [Section 7.2.7, Paragraph 6](#section-7.2.7-6);
    [Section 8.1, Paragraph 2.18.1](#H3_ID_ERROR);
    [Appendix A.2.5, Paragraph 1.12.1](#appendix-A.2.5-1.12.1);
    [Appendix A.2.5, Paragraph 1.16.1](#appendix-A.2.5-1.16.1)[¶](#appendix-C-2.6.2.1.1.2.1)

    push stream

    [Section 4.1, Paragraph 8](#section-4.1-8);
    [Section 4.1, Paragraph 9](#section-4.1-9);
    [Section 4.6, Paragraph 3](#section-4.6-3);
    [Section 4.6, Paragraph 5](#section-4.6-5);
    [Section 4.6, Paragraph 5](#section-4.6-5);
    [Section 4.6, Paragraph 13](#section-4.6-13);
    [Section 4.6, Paragraph 13](#section-4.6-13);
    [Section 4.6, Paragraph 13](#section-4.6-13);
    [Section 6.2, Paragraph 3](#section-6.2-3);
    ***[Section 6.2.2](#push-streams)***;
    [Section 7, Paragraph 1](#section-7-1);
    [Section 7.2.2, Paragraph 3](#section-7.2.2-3);
    [Section 7.2.3, Paragraph 1](#section-7.2.3-1);
    [Section 7.2.3, Paragraph 2](#section-7.2.3-2);
    [Section 7.2.3, Paragraph 2](#section-7.2.3-2);
    [Section 7.2.3, Paragraph 2](#section-7.2.3-2);
    [Section 7.2.3, Paragraph 2](#section-7.2.3-2);
    [Section 7.2.3, Paragraph 3](#section-7.2.3-3);
    [Section 7.2.3, Paragraph 4](#section-7.2.3-4);
    [Section 7.2.3, Paragraph 4](#section-7.2.3-4);
    [Section 7.2.3, Paragraph 4](#section-7.2.3-4);
    [Section 7.2.5, Paragraph 4.2.1](#section-7.2.5-4.2.1);
    [Section 7.2.7, Paragraph 1](#section-7.2.7-1);
    [Appendix A.2.5, Paragraph 1.12.1](#appendix-A.2.5-1.12.1)[¶](#appendix-C-2.6.2.1.1.4.1)

    PUSH\_PROMISE

    [Section 2, Paragraph 5](#section-2-5);
    [Section 4.1, Paragraph 8](#section-4.1-8);
    [Section 4.1, Paragraph 8](#section-4.1-8);
    [Section 4.1, Paragraph 8](#section-4.1-8);
    [Section 4.1, Paragraph 8](#section-4.1-8);
    [Section 4.1, Paragraph 10](#section-4.1-10);
    [Section 4.6, Paragraph 4](#section-4.6-4);
    [Section 4.6, Paragraph 10](#section-4.6-10);
    [Section 4.6, Paragraph 11](#section-4.6-11);
    [Section 4.6, Paragraph 11](#section-4.6-11);
    [Section 4.6, Paragraph 12](#section-4.6-12);
    [Section 4.6, Paragraph 12](#section-4.6-12);
    [Section 4.6, Paragraph 13](#section-4.6-13);
    [Section 4.6, Paragraph 13](#section-4.6-13);
    [Section 4.6, Paragraph 13](#section-4.6-13);
    [Table 1](#stream-frame-mapping);
    [Section 7.2.3, Paragraph 8](#section-7.2.3-8);
    [Section 7.2.3, Paragraph 8](#section-7.2.3-8);
    ***[Section 7.2.5](#frame-push-promise)***;
    [Section 7.2.7, Paragraph 1](#section-7.2.7-1);
    [Section 10.4, Paragraph 1](#section-10.4-1);
    [Section 10.5, Paragraph 2](#section-10.5-2);
    [Table 2](#iana-frame-table);
    [Appendix A.2.5](#appendix-A.2.5-1.11);
    [Appendix A.2.5, Paragraph 1.12.1](#appendix-A.2.5-1.12.1);
    [Appendix A.2.5, Paragraph 1.12.1](#appendix-A.2.5-1.12.1);
    [Appendix A.2.5, Paragraph 1.20.1](#appendix-A.2.5-1.20.1)[¶](#appendix-C-2.6.2.1.1.6.1)
* [R](#rfc.index.u82)[¶](#appendix-C-2.7.1)

  + request stream

    [Section 4.1, Paragraph 1](#section-4.1-1);
    [Section 4.1, Paragraph 15](#section-4.1-15);
    [Section 4.1, Paragraph 15](#section-4.1-15);
    [Section 4.1.1, Paragraph 1](#section-4.1.1-1);
    [Section 4.1.1, Paragraph 5](#section-4.1.1-5);
    [Section 4.4, Paragraph 5](#section-4.4-5);
    [Section 4.4, Paragraph 9](#section-4.4-9);
    [Section 4.6, Paragraph 4](#section-4.6-4);
    [Section 4.6, Paragraph 4](#section-4.6-4);
    [Section 4.6, Paragraph 11](#section-4.6-11);
    [Section 4.6, Paragraph 11](#section-4.6-11);
    ***[Section 6.1](#request-streams)***;
    [Section 7, Paragraph 1](#section-7-1);
    [Section 7.2.2, Paragraph 3](#section-7.2.2-3);
    [Section 7.2.5, Paragraph 1](#section-7.2.5-1)[¶](#appendix-C-2.7.2.1.1.2.1)
* [S](#rfc.index.u83)[¶](#appendix-C-2.8.1)

  + SETTINGS

    [Section 3.2, Paragraph 4](#section-3.2-4);
    [Section 3.2, Paragraph 4](#section-3.2-4);
    [Section 6.2.1, Paragraph 2](#section-6.2.1-2);
    [Table 1](#stream-frame-mapping);
    [Section 7, Paragraph 3](#section-7-3);
    ***[Section 7.2.4](#frame-settings)***;
    [Section 8.1, Paragraph 2.20.1](#H3_SETTINGS_ERROR);
    [Section 8.1, Paragraph 2.22.1](#H3_MISSING_SETTINGS);
    [Section 9, Paragraph 4](#section-9-4);
    [Section 10.5, Paragraph 4](#section-10.5-4);
    [Table 2](#iana-frame-table);
    [Table 4](#iana-error-table);
    [Table 4](#iana-error-table);
    [Appendix A.2.5](#appendix-A.2.5-1.9);
    [Appendix A.2.5, Paragraph 1.10.1](#appendix-A.2.5-1.10.1);
    [Appendix A.3, Paragraph 2](#appendix-A.3-2);
    [Appendix A.3, Paragraph 3](#appendix-A.3-3);
    [Appendix A.3, Paragraph 4.4.1](#appendix-A.3-4.4.1);
    [Appendix A.3, Paragraph 4.6.1](#appendix-A.3-4.6.1);
    [Appendix A.3, Paragraph 4.8.1](#appendix-A.3-4.8.1);
    [Appendix A.3, Paragraph 4.10.1](#appendix-A.3-4.10.1);
    [Appendix A.4, Paragraph 3.10.1](#appendix-A.4-3.10.1)[¶](#appendix-C-2.8.2.1.1.2.1)

    SETTINGS\_MAX\_FIELD\_SECTION\_SIZE

    [Section 4.2.2, Paragraph 2](#section-4.2.2-2);
    [Section 7.2.4.1](#section-7.2.4.1-2.1);
    [Section 10.5.1, Paragraph 2](#section-10.5.1-2);
    [Appendix A.3, Paragraph 4.12.1](#appendix-A.3-4.12.1)[¶](#appendix-C-2.8.2.1.1.4.1)

    stream error

    [Section 2.2](#section-2.2-4.25);
    [Section 4.1.2, Paragraph 4](#section-4.1.2-4);
    [Section 4.4, Paragraph 10](#section-4.4-10);
    ***[Section 8](#errors)***;
    [Appendix A.4.1, Paragraph 3](#appendix-A.4.1-3);
    [Appendix A.4.1, Paragraph 3](#appendix-A.4.1-3);
    [Appendix A.4.1, Paragraph 4](#appendix-A.4.1-4)[¶](#appendix-C-2.8.2.1.1.6.1)

## [Author's Address](#name-authors-address)

Mike Bishop (editor)
Akamai
Email:
mbishop@evequefou.be

[Datatracker](/doc/rfc9114/)

RFC 9114

RFC
- Proposed Standard

* Info
* Contents
* Prefs

| Document | Document type |  | RFC - Proposed Standard  June 2022  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=9114 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") Was [draft-ietf-quic-http](/doc/draft-ietf-quic-http/34/) ([quic WG](/wg/quic/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [00](/doc/html/draft-ietf-quic-http-00) * [01](/doc/html/draft-ietf-quic-http-01) * [02](/doc/html/draft-ietf-quic-http-02) * [03](/doc/html/draft-ietf-quic-http-03) * [04](/doc/html/draft-ietf-quic-http-04) * [05](/doc/html/draft-ietf-quic-http-05) * [06](/doc/html/draft-ietf-quic-http-06) * [07](/doc/html/draft-ietf-quic-http-07) * [08](/doc/html/draft-ietf-quic-http-08) * [09](/doc/html/draft-ietf-quic-http-09) * [10](/doc/html/draft-ietf-quic-http-10) * [11](/doc/html/draft-ietf-quic-http-11) * [12](/doc/html/draft-ietf-quic-http-12) * [13](/doc/html/draft-ietf-quic-http-13) * [14](/doc/html/draft-ietf-quic-http-14) * [15](/doc/html/draft-ietf-quic-http-15) * [16](/doc/html/draft-ietf-quic-http-16) * [17](/doc/html/draft-ietf-quic-http-17) * [18](/doc/html/draft-ietf-quic-http-18) * [19](/doc/html/draft-ietf-quic-http-19) * [20](/doc/html/draft-ietf-quic-http-20) * [21](/doc/html/draft-ietf-quic-http-21) * [22](/doc/html/draft-ietf-quic-http-22) * [23](/doc/html/draft-ietf-quic-http-23) * [24](/doc/html/draft-ietf-quic-http-24) * [25](/doc/html/draft-ietf-quic-http-25) * [26](/doc/html/draft-ietf-quic-http-26) * [27](/doc/html/draft-ietf-quic-http-27) * [28](/doc/html/draft-ietf-quic-http-28) * [29](/doc/html/draft-ietf-quic-http-29) * [30](/doc/html/draft-ietf-quic-http-30) * [31](/doc/html/draft-ietf-quic-http-31) * [32](/doc/html/draft-ietf-quic-http-32) * [33](/doc/html/draft-ietf-quic-http-33) * [34](/doc/html/draft-ietf-quic-http-34) * [RFC 9114](/doc/html/rfc9114) |
|  | Compare versions |  | RFC 9114  draft-ietf-quic-http-34  draft-ietf-quic-http-33  draft-ietf-quic-http-32  draft-ietf-quic-http-31  draft-ietf-quic-http-30  draft-ietf-quic-http-29  draft-ietf-quic-http-28  draft-ietf-quic-http-27  draft-ietf-quic-http-26  draft-ietf-quic-http-25  draft-ietf-quic-http-24  draft-ietf-quic-http-23  draft-ietf-quic-http-22  draft-ietf-quic-http-21  draft-ietf-quic-http-20  draft-ietf-quic-http-19  draft-ietf-quic-http-18  draft-ietf-quic-http-17  draft-ietf-quic-http-16  draft-ietf-quic-http-15  draft-ietf-quic-http-14  draft-ietf-quic-http-13  draft-ietf-quic-http-12  draft-ietf-quic-http-11  draft-ietf-quic-http-10  draft-ietf-quic-http-09  draft-ietf-quic-http-08  draft-ietf-quic-http-07  draft-ietf-quic-http-06  draft-ietf-quic-http-05  draft-ietf-quic-http-04  draft-ietf-quic-http-03  draft-ietf-quic-http-02  draft-ietf-quic-http-01  draft-ietf-quic-http-00   RFC 9114  draft-ietf-quic-http-34  draft-ietf-quic-http-33  draft-ietf-quic-http-32  draft-ietf-quic-http-31  draft-ietf-quic-http-30  draft-ietf-quic-http-29  draft-ietf-quic-http-28  draft-ietf-quic-http-27  draft-ietf-quic-http-26  draft-ietf-quic-http-25  draft-ietf-quic-http-24  draft-ietf-quic-http-23  draft-ietf-quic-http-22  draft-ietf-quic-http-21  draft-ietf-quic-http-20  draft-ietf-quic-http-19  draft-ietf-quic-http-18  draft-ietf-quic-http-17  draft-ietf-quic-http-16  draft-ietf-quic-http-15  draft-ietf-quic-http-14  draft-ietf-quic-http-13  draft-ietf-quic-http-12  draft-ietf-quic-http-11  draft-ietf-quic-http-10  draft-ietf-quic-http-09  draft-ietf-quic-http-08  draft-ietf-quic-http-07  draft-ietf-quic-http-06  draft-ietf-quic-http-05  draft-ietf-quic-http-04  draft-ietf-quic-http-03  draft-ietf-quic-http-02  draft-ietf-quic-http-01  draft-ietf-quic-http-00   Side-by-side  Inline |
|  | Author |  | [Mike Bishop](/person/mbishop%40evequefou.be "Datatracker profile of Mike Bishop")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc9114.txt) [html](https://www.rfc-editor.org/rfc/rfc9114.html) [xml](https://www.rfc-editor.org/rfc/rfc9114.xml) [pdf](https://www.rfc-editor.org/rfc/rfc9114.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc9114.html) [bibtex](/doc/rfc9114/bibtex/) |
|  | Additional resources |  | [Mailing list discussion](https://mailarchive.ietf.org/arch/browse/quic/?q=rfc9114 OR %22draft-ietf-quic-http%22) |

[Report a datatracker bug](https://github.com/ietf-tools/datatracker/issues/new/choose)

Show sidebar by default

Yes

No

Tab to show by default

Info

Contents

HTMLization configuration

HTMLize the plaintext

Plaintextify the HTML

Maximum font size

Page dependencies

Inline

Reference

Citation links

 Go to reference section

Go to linked document

![](//analytics.ietf.org/piwik.php?idsite=7)



=== Content from www.rfc-editor.org_2a73bc17_20250114_220616.html ===


| RFC 9110 | HTTP Semantics | June 2022 |
| --- | --- | --- |
| Fielding, et al. | Standards Track | [Page] |
| --- | --- | --- |

Stream:
Internet Engineering Task Force (IETF)
RFC:
[9110](https://www.rfc-editor.org/rfc/rfc9110)
STD:
97
Obsoletes:
[2818](https://www.rfc-editor.org/rfc/rfc2818), [7230](https://www.rfc-editor.org/rfc/rfc7230), [7231](https://www.rfc-editor.org/rfc/rfc7231), [7232](https://www.rfc-editor.org/rfc/rfc7232), [7233](https://www.rfc-editor.org/rfc/rfc7233), [7235](https://www.rfc-editor.org/rfc/rfc7235), [7538](https://www.rfc-editor.org/rfc/rfc7538), [7615](https://www.rfc-editor.org/rfc/rfc7615), [7694](https://www.rfc-editor.org/rfc/rfc7694)
Updates:
[3864](https://www.rfc-editor.org/rfc/rfc3864)
Category:
Standards Track
Published:
June 2022

ISSN:
2070-1721
Authors:
R. Fielding, Ed.

Adobe

M. Nottingham, Ed.

Fastly

J. Reschke, Ed.

greenbytes

# RFC 9110

# HTTP Semantics

## [Abstract](#abstract)

The Hypertext Transfer Protocol (HTTP) is a stateless application-level
protocol for distributed, collaborative, hypertext information systems.
This document describes the overall architecture of HTTP, establishes common
terminology, and defines aspects of the protocol that are shared by all
versions. In this definition are core protocol elements, extensibility
mechanisms, and the "http" and "https" Uniform Resource Identifier (URI)
schemes.[¶](#section-abstract-1)

This document updates RFC 3864 and
obsoletes RFCs 2818, 7231, 7232, 7233,
7235, 7538, 7615, 7694, and portions of 7230.[¶](#section-abstract-2)

## [Status of This Memo](#name-status-of-this-memo)

This is an Internet Standards Track document.[¶](#section-boilerplate.1-1)

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by
the Internet Engineering Steering Group (IESG). Further
information on Internet Standards is available in Section 2 of
RFC 7841.[¶](#section-boilerplate.1-2)

Information about the current status of this document, any
errata, and how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9110>.[¶](#section-boilerplate.1-3)

## [Copyright Notice](#name-copyright-notice)

Copyright (c) 2022 IETF Trust and the persons identified as the
document authors. All rights reserved.[¶](#section-boilerplate.2-1)

This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents
carefully, as they describe your rights and restrictions with
respect to this document. Code Components extracted from this
document must include Revised BSD License text as described in
Section 4.e of the Trust Legal Provisions and are provided without
warranty as described in the Revised BSD License.[¶](#section-boilerplate.2-2)

This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008. The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s)
controlling the copyright in such materials, this document may not
be modified outside the IETF Standards Process, and derivative
works of it may not be created outside the IETF Standards Process,
except to format it for publication as an RFC or to translate it
into languages other than English.[¶](#section-boilerplate.2-3)

▲
## [Table of Contents](#name-table-of-contents)

* [1](#section-1).  [Introduction](#name-introduction)

  + [1.1](#section-1.1).  [Purpose](#name-purpose)
  + [1.2](#section-1.2).  [History and Evolution](#name-history-and-evolution)
  + [1.3](#section-1.3).  [Core Semantics](#name-core-semantics)
  + [1.4](#section-1.4).  [Specifications Obsoleted by This Document](#name-specifications-obsoleted-by)
* [2](#section-2).  [Conformance](#name-conformance)

  + [2.1](#section-2.1).  [Syntax Notation](#name-syntax-notation)
  + [2.2](#section-2.2).  [Requirements Notation](#name-requirements-notation)
  + [2.3](#section-2.3).  [Length Requirements](#name-length-requirements)
  + [2.4](#section-2.4).  [Error Handling](#name-error-handling)
  + [2.5](#section-2.5).  [Protocol Version](#name-protocol-version)
* [3](#section-3).  [Terminology and Core Concepts](#name-terminology-and-core-concep)

  + [3.1](#section-3.1).  [Resources](#name-resources)
  + [3.2](#section-3.2).  [Representations](#name-representations)
  + [3.3](#section-3.3).  [Connections, Clients, and Servers](#name-connections-clients-and-ser)
  + [3.4](#section-3.4).  [Messages](#name-messages)
  + [3.5](#section-3.5).  [User Agents](#name-user-agents)
  + [3.6](#section-3.6).  [Origin Server](#name-origin-server)
  + [3.7](#section-3.7).  [Intermediaries](#name-intermediaries)
  + [3.8](#section-3.8).  [Caches](#name-caches)
  + [3.9](#section-3.9).  [Example Message Exchange](#name-example-message-exchange)
* [4](#section-4).  [Identifiers in HTTP](#name-identifiers-in-http)

  + [4.1](#section-4.1).  [URI References](#name-uri-references)
  + [4.2](#section-4.2).  [HTTP-Related URI Schemes](#name-http-related-uri-schemes)

    - [4.2.1](#section-4.2.1).  [http URI Scheme](#name-http-uri-scheme)
    - [4.2.2](#section-4.2.2).  [https URI Scheme](#name-https-uri-scheme)
    - [4.2.3](#section-4.2.3).  [http(s) Normalization and Comparison](#name-https-normalization-and-com)
    - [4.2.4](#section-4.2.4).  [Deprecation of userinfo in http(s) URIs](#name-deprecation-of-userinfo-in-)
    - [4.2.5](#section-4.2.5).  [http(s) References with Fragment Identifiers](#name-https-references-with-fragm)
  + [4.3](#section-4.3).  [Authoritative Access](#name-authoritative-access)

    - [4.3.1](#section-4.3.1).  [URI Origin](#name-uri-origin)
    - [4.3.2](#section-4.3.2).  [http Origins](#name-http-origins)
    - [4.3.3](#section-4.3.3).  [https Origins](#name-https-origins)
    - [4.3.4](#section-4.3.4).  [https Certificate Verification](#name-https-certificate-verificat)
    - [4.3.5](#section-4.3.5).  [IP-ID Reference Identity](#name-ip-id-reference-identity)
* [5](#section-5).  [Fields](#name-fields)

  + [5.1](#section-5.1).  [Field Names](#name-field-names)
  + [5.2](#section-5.2).  [Field Lines and Combined Field Value](#name-field-lines-and-combined-fi)
  + [5.3](#section-5.3).  [Field Order](#name-field-order)
  + [5.4](#section-5.4).  [Field Limits](#name-field-limits)
  + [5.5](#section-5.5).  [Field Values](#name-field-values)
  + [5.6](#section-5.6).  [Common Rules for Defining Field Values](#name-common-rules-for-defining-f)

    - [5.6.1](#section-5.6.1).  [Lists (#rule ABNF Extension)](#name-lists-rule-abnf-extension)

      * [5.6.1.1](#section-5.6.1.1).  [Sender Requirements](#name-sender-requirements)
      * [5.6.1.2](#section-5.6.1.2).  [Recipient Requirements](#name-recipient-requirements)
    - [5.6.2](#section-5.6.2).  [Tokens](#name-tokens)
    - [5.6.3](#section-5.6.3).  [Whitespace](#name-whitespace)
    - [5.6.4](#section-5.6.4).  [Quoted Strings](#name-quoted-strings)
    - [5.6.5](#section-5.6.5).  [Comments](#name-comments)
    - [5.6.6](#section-5.6.6).  [Parameters](#name-parameters)
    - [5.6.7](#section-5.6.7).  [Date/Time Formats](#name-date-time-formats)
* [6](#section-6).  [Message Abstraction](#name-message-abstraction)

  + [6.1](#section-6.1).  [Framing and Completeness](#name-framing-and-completeness)
  + [6.2](#section-6.2).  [Control Data](#name-control-data)
  + [6.3](#section-6.3).  [Header Fields](#name-header-fields)
  + [6.4](#section-6.4).  [Content](#name-content)

    - [6.4.1](#section-6.4.1).  [Content Semantics](#name-content-semantics)
    - [6.4.2](#section-6.4.2).  [Identifying Content](#name-identifying-content)
  + [6.5](#section-6.5).  [Trailer Fields](#name-trailer-fields)

    - [6.5.1](#section-6.5.1).  [Limitations on Use of Trailers](#name-limitations-on-use-of-trail)
    - [6.5.2](#section-6.5.2).  [Processing Trailer Fields](#name-processing-trailer-fields)
  + [6.6](#section-6.6).  [Message Metadata](#name-message-metadata)

    - [6.6.1](#section-6.6.1).  [Date](#name-date)
    - [6.6.2](#section-6.6.2).  [Trailer](#name-trailer)
* [7](#section-7).  [Routing HTTP Messages](#name-routing-http-messages)

  + [7.1](#section-7.1).  [Determining the Target Resource](#name-determining-the-target-reso)
  + [7.2](#section-7.2).  [Host and :authority](#name-host-and-authority)
  + [7.3](#section-7.3).  [Routing Inbound Requests](#name-routing-inbound-requests)

    - [7.3.1](#section-7.3.1).  [To a Cache](#name-to-a-cache)
    - [7.3.2](#section-7.3.2).  [To a Proxy](#name-to-a-proxy)
    - [7.3.3](#section-7.3.3).  [To the Origin](#name-to-the-origin)
  + [7.4](#section-7.4).  [Rejecting Misdirected Requests](#name-rejecting-misdirected-reque)
  + [7.5](#section-7.5).  [Response Correlation](#name-response-correlation)
  + [7.6](#section-7.6).  [Message Forwarding](#name-message-forwarding)

    - [7.6.1](#section-7.6.1).  [Connection](#name-connection)
    - [7.6.2](#section-7.6.2).  [Max-Forwards](#name-max-forwards)
    - [7.6.3](#section-7.6.3).  [Via](#name-via)
  + [7.7](#section-7.7).  [Message Transformations](#name-message-transformations)
  + [7.8](#section-7.8).  [Upgrade](#name-upgrade)
* [8](#section-8).  [Representation Data and Metadata](#name-representation-data-and-met)

  + [8.1](#section-8.1).  [Representation Data](#name-representation-data)
  + [8.2](#section-8.2).  [Representation Metadata](#name-representation-metadata)
  + [8.3](#section-8.3).  [Content-Type](#name-content-type)

    - [8.3.1](#section-8.3.1).  [Media Type](#name-media-type)
    - [8.3.2](#section-8.3.2).  [Charset](#name-charset)
    - [8.3.3](#section-8.3.3).  [Multipart Types](#name-multipart-types)
  + [8.4](#section-8.4).  [Content-Encoding](#name-content-encoding)

    - [8.4.1](#section-8.4.1).  [Content Codings](#name-content-codings)

      * [8.4.1.1](#section-8.4.1.1).  [Compress Coding](#name-compress-coding)
      * [8.4.1.2](#section-8.4.1.2).  [Deflate Coding](#name-deflate-coding)
      * [8.4.1.3](#section-8.4.1.3).  [Gzip Coding](#name-gzip-coding)
  + [8.5](#section-8.5).  [Content-Language](#name-content-language)

    - [8.5.1](#section-8.5.1).  [Language Tags](#name-language-tags)
  + [8.6](#section-8.6).  [Content-Length](#name-content-length)
  + [8.7](#section-8.7).  [Content-Location](#name-content-location)
  + [8.8](#section-8.8).  [Validator Fields](#name-validator-fields)

    - [8.8.1](#section-8.8.1).  [Weak versus Strong](#name-weak-versus-strong)
    - [8.8.2](#section-8.8.2).  [Last-Modified](#name-last-modified)

      * [8.8.2.1](#section-8.8.2.1).  [Generation](#name-generation)
      * [8.8.2.2](#section-8.8.2.2).  [Comparison](#name-comparison)
    - [8.8.3](#section-8.8.3).  [ETag](#name-etag)

      * [8.8.3.1](#section-8.8.3.1).  [Generation](#name-generation-2)
      * [8.8.3.2](#section-8.8.3.2).  [Comparison](#name-comparison-2)
      * [8.8.3.3](#section-8.8.3.3).  [Example: Entity Tags Varying on Content-Negotiated Resources](#name-example-entity-tags-varying)
* [9](#section-9).  [Methods](#name-methods)

  + [9.1](#section-9.1).  [Overview](#name-overview)
  + [9.2](#section-9.2).  [Common Method Properties](#name-common-method-properties)

    - [9.2.1](#section-9.2.1).  [Safe Methods](#name-safe-methods)
    - [9.2.2](#section-9.2.2).  [Idempotent Methods](#name-idempotent-methods)
    - [9.2.3](#section-9.2.3).  [Methods and Caching](#name-methods-and-caching)
  + [9.3](#section-9.3).  [Method Definitions](#name-method-definitions)

    - [9.3.1](#section-9.3.1).  [GET](#name-get)
    - [9.3.2](#section-9.3.2).  [HEAD](#name-head)
    - [9.3.3](#section-9.3.3).  [POST](#name-post)
    - [9.3.4](#section-9.3.4).  [PUT](#name-put)
    - [9.3.5](#section-9.3.5).  [DELETE](#name-delete)
    - [9.3.6](#section-9.3.6).  [CONNECT](#name-connect)
    - [9.3.7](#section-9.3.7).  [OPTIONS](#name-options)
    - [9.3.8](#section-9.3.8).  [TRACE](#name-trace)
* [10](#section-10). [Message Context](#name-message-context)

  + [10.1](#section-10.1).  [Request Context Fields](#name-request-context-fields)

    - [10.1.1](#section-10.1.1).  [Expect](#name-expect)
    - [10.1.2](#section-10.1.2).  [From](#name-from)
    - [10.1.3](#section-10.1.3).  [Referer](#name-referer)
    - [10.1.4](#section-10.1.4).  [TE](#name-te)
    - [10.1.5](#section-10.1.5).  [User-Agent](#name-user-agent)
  + [10.2](#section-10.2).  [Response Context Fields](#name-response-context-fields)

    - [10.2.1](#section-10.2.1).  [Allow](#name-allow)
    - [10.2.2](#section-10.2.2).  [Location](#name-location)
    - [10.2.3](#section-10.2.3).  [Retry-After](#name-retry-after)
    - [10.2.4](#section-10.2.4).  [Server](#name-server)
* [11](#section-11). [HTTP Authentication](#name-http-authentication)

  + [11.1](#section-11.1).  [Authentication Scheme](#name-authentication-scheme)
  + [11.2](#section-11.2).  [Authentication Parameters](#name-authentication-parameters)
  + [11.3](#section-11.3).  [Challenge and Response](#name-challenge-and-response)
  + [11.4](#section-11.4).  [Credentials](#name-credentials)
  + [11.5](#section-11.5).  [Establishing a Protection Space (Realm)](#name-establishing-a-protection-s)
  + [11.6](#section-11.6).  [Authenticating Users to Origin Servers](#name-authenticating-users-to-ori)

    - [11.6.1](#section-11.6.1).  [WWW-Authenticate](#name-www-authenticate)
    - [11.6.2](#section-11.6.2).  [Authorization](#name-authorization)
    - [11.6.3](#section-11.6.3).  [Authentication-Info](#name-authentication-info)
  + [11.7](#section-11.7).  [Authenticating Clients to Proxies](#name-authenticating-clients-to-p)

    - [11.7.1](#section-11.7.1).  [Proxy-Authenticate](#name-proxy-authenticate)
    - [11.7.2](#section-11.7.2).  [Proxy-Authorization](#name-proxy-authorization)
    - [11.7.3](#section-11.7.3).  [Proxy-Authentication-Info](#name-proxy-authentication-info)
* [12](#section-12). [Content Negotiation](#name-content-negotiation)

  + [12.1](#section-12.1).  [Proactive Negotiation](#name-proactive-negotiation)
  + [12.2](#section-12.2).  [Reactive Negotiation](#name-reactive-negotiation)
  + [12.3](#section-12.3).  [Request Content Negotiation](#name-request-content-negotiation)
  + [12.4](#section-12.4).  [Content Negotiation Field Features](#name-content-negotiation-field-f)

    - [12.4.1](#section-12.4.1).  [Absence](#name-absence)
    - [12.4.2](#section-12.4.2).  [Quality Values](#name-quality-values)
    - [12.4.3](#section-12.4.3).  [Wildcard Values](#name-wildcard-values)
  + [12.5](#section-12.5).  [Content Negotiation Fields](#name-content-negotiation-fields)

    - [12.5.1](#section-12.5.1).  [Accept](#name-accept)
    - [12.5.2](#section-12.5.2).  [Accept-Charset](#name-accept-charset)
    - [12.5.3](#section-12.5.3).  [Accept-Encoding](#name-accept-encoding)
    - [12.5.4](#section-12.5.4).  [Accept-Language](#name-accept-language)
    - [12.5.5](#section-12.5.5).  [Vary](#name-vary)
* [13](#section-13). [Conditional Requests](#name-conditional-requests)

  + [13.1](#section-13.1).  [Preconditions](#name-preconditions)

    - [13.1.1](#section-13.1.1).  [If-Match](#name-if-match)
    - [13.1.2](#section-13.1.2).  [If-None-Match](#name-if-none-match)
    - [13.1.3](#section-13.1.3).  [If-Modified-Since](#name-if-modified-since)
    - [13.1.4](#section-13.1.4).  [If-Unmodified-Since](#name-if-unmodified-since)
    - [13.1.5](#section-13.1.5).  [If-Range](#name-if-range)
  + [13.2](#section-13.2).  [Evaluation of Preconditions](#name-evaluation-of-preconditions)

    - [13.2.1](#section-13.2.1).  [When to Evaluate](#name-when-to-evaluate)
    - [13.2.2](#section-13.2.2).  [Precedence of Preconditions](#name-precedence-of-preconditions)
* [14](#section-14). [Range Requests](#name-range-requests)

  + [14.1](#section-14.1).  [Range Units](#name-range-units)

    - [14.1.1](#section-14.1.1).  [Range Specifiers](#name-range-specifiers)
    - [14.1.2](#section-14.1.2).  [Byte Ranges](#name-byte-ranges)
  + [14.2](#section-14.2).  [Range](#name-range)
  + [14.3](#section-14.3).  [Accept-Ranges](#name-accept-ranges)
  + [14.4](#section-14.4).  [Content-Range](#name-content-range)
  + [14.5](#section-14.5).  [Partial PUT](#name-partial-put)
  + [14.6](#section-14.6).  [Media Type multipart/byteranges](#name-media-type-multipart-bytera)
* [15](#section-15). [Status Codes](#name-status-codes)

  + [15.1](#section-15.1).  [Overview of Status Codes](#name-overview-of-status-codes)
  + [15.2](#section-15.2).  [Informational 1xx](#name-informational-1xx)

    - [15.2.1](#section-15.2.1).  [100 Continue](#name-100-continue)
    - [15.2.2](#section-15.2.2).  [101 Switching Protocols](#name-101-switching-protocols)
  + [15.3](#section-15.3).  [Successful 2xx](#name-successful-2xx)

    - [15.3.1](#section-15.3.1).  [200 OK](#name-200-ok)
    - [15.3.2](#section-15.3.2).  [201 Created](#name-201-created)
    - [15.3.3](#section-15.3.3).  [202 Accepted](#name-202-accepted)
    - [15.3.4](#section-15.3.4).  [203 Non-Authoritative Information](#name-203-non-authoritative-infor)
    - [15.3.5](#section-15.3.5).  [204 No Content](#name-204-no-content)
    - [15.3.6](#section-15.3.6).  [205 Reset Content](#name-205-reset-content)
    - [15.3.7](#section-15.3.7).  [206 Partial Content](#name-206-partial-content)

      * [15.3.7.1](#section-15.3.7.1).  [Single Part](#name-single-part)
      * [15.3.7.2](#section-15.3.7.2).  [Multiple Parts](#name-multiple-parts)
      * [15.3.7.3](#section-15.3.7.3).  [Combining Parts](#name-combining-parts)
  + [15.4](#section-15.4).  [Redirection 3xx](#name-redirection-3xx)

    - [15.4.1](#section-15.4.1).  [300 Multiple Choices](#name-300-multiple-choices)
    - [15.4.2](#section-15.4.2).  [301 Moved Permanently](#name-301-moved-permanently)
    - [15.4.3](#section-15.4.3).  [302 Found](#name-302-found)
    - [15.4.4](#section-15.4.4).  [303 See Other](#name-303-see-other)
    - [15.4.5](#section-15.4.5).  [304 Not Modified](#name-304-not-modified)
    - [15.4.6](#section-15.4.6).  [305 Use Proxy](#name-305-use-proxy)
    - [15.4.7](#section-15.4.7).  [306 (Unused)](#name-306-unused)
    - [15.4.8](#section-15.4.8).  [307 Temporary Redirect](#name-307-temporary-redirect)
    - [15.4.9](#section-15.4.9).  [308 Permanent Redirect](#name-308-permanent-redirect)
  + [15.5](#section-15.5).  [Client Error 4xx](#name-client-error-4xx)

    - [15.5.1](#section-15.5.1).  [400 Bad Request](#name-400-bad-request)
    - [15.5.2](#section-15.5.2).  [401 Unauthorized](#name-401-unauthorized)
    - [15.5.3](#section-15.5.3).  [402 Payment Required](#name-402-payment-required)
    - [15.5.4](#section-15.5.4).  [403 Forbidden](#name-403-forbidden)
    - [15.5.5](#section-15.5.5).  [404 Not Found](#name-404-not-found)
    - [15.5.6](#section-15.5.6).  [405 Method Not Allowed](#name-405-method-not-allowed)
    - [15.5.7](#section-15.5.7).  [406 Not Acceptable](#name-406-not-acceptable)
    - [15.5.8](#section-15.5.8).  [407 Proxy Authentication Required](#name-407-proxy-authentication-re)
    - [15.5.9](#section-15.5.9).  [408 Request Timeout](#name-408-request-timeout)
    - [15.5.10](#section-15.5.10). [409 Conflict](#name-409-conflict)
    - [15.5.11](#section-15.5.11). [410 Gone](#name-410-gone)
    - [15.5.12](#section-15.5.12). [411 Length Required](#name-411-length-required)
    - [15.5.13](#section-15.5.13). [412 Precondition Failed](#name-412-precondition-failed)
    - [15.5.14](#section-15.5.14). [413 Content Too Large](#name-413-content-too-large)
    - [15.5.15](#section-15.5.15). [414 URI Too Long](#name-414-uri-too-long)
    - [15.5.16](#section-15.5.16). [415 Unsupported Media Type](#name-415-unsupported-media-type)
    - [15.5.17](#section-15.5.17). [416 Range Not Satisfiable](#name-416-range-not-satisfiable)
    - [15.5.18](#section-15.5.18). [417 Expectation Failed](#name-417-expectation-failed)
    - [15.5.19](#section-15.5.19). [418 (Unused)](#name-418-unused)
    - [15.5.20](#section-15.5.20). [421 Misdirected Request](#name-421-misdirected-request)
    - [15.5.21](#section-15.5.21). [422 Unprocessable Content](#name-422-unprocessable-content)
    - [15.5.22](#section-15.5.22). [426 Upgrade Required](#name-426-upgrade-required)
  + [15.6](#section-15.6).  [Server Error 5xx](#name-server-error-5xx)

    - [15.6.1](#section-15.6.1).  [500 Internal Server Error](#name-500-internal-server-error)
    - [15.6.2](#section-15.6.2).  [501 Not Implemented](#name-501-not-implemented)
    - [15.6.3](#section-15.6.3).  [502 Bad Gateway](#name-502-bad-gateway)
    - [15.6.4](#section-15.6.4).  [503 Service Unavailable](#name-503-service-unavailable)
    - [15.6.5](#section-15.6.5).  [504 Gateway Timeout](#name-504-gateway-timeout)
    - [15.6.6](#section-15.6.6).  [505 HTTP Version Not Supported](#name-505-http-version-not-suppor)
* [16](#section-16). [Extending HTTP](#name-extending-http)

  + [16.1](#section-16.1).  [Method Extensibility](#name-method-extensibility)

    - [16.1.1](#section-16.1.1).  [Method Registry](#name-method-registry)
    - [16.1.2](#section-16.1.2).  [Considerations for New Methods](#name-considerations-for-new-meth)
  + [16.2](#section-16.2).  [Status Code Extensibility](#name-status-code-extensibility)

    - [16.2.1](#section-16.2.1).  [Status Code Registry](#name-status-code-registry)
    - [16.2.2](#section-16.2.2).  [Considerations for New Status Codes](#name-considerations-for-new-stat)
  + [16.3](#section-16.3).  [Field Extensibility](#name-field-extensibility)

    - [16.3.1](#section-16.3.1).  [Field Name Registry](#name-field-name-registry)
    - [16.3.2](#section-16.3.2).  [Considerations for New Fields](#name-considerations-for-new-fiel)

      * [16.3.2.1](#section-16.3.2.1).  [Considerations for New Field Names](#name-considerations-for-new-field)
      * [16.3.2.2](#section-16.3.2.2).  [Considerations for New Field Values](#name-considerations-for-new-field-)
  + [16.4](#section-16.4).  [Authentication Scheme Extensibility](#name-authentication-scheme-exten)

    - [16.4.1](#section-16.4.1).  [Authentication Scheme Registry](#name-authentication-scheme-regis)
    - [16.4.2](#section-16.4.2).  [Considerations for New Authentication Schemes](#name-considerations-for-new-auth)
  + [16.5](#section-16.5).  [Range Unit Extensibility](#name-range-unit-extensibility)

    - [16.5.1](#section-16.5.1).  [Range Unit Registry](#name-range-unit-registry)
    - [16.5.2](#section-16.5.2).  [Considerations for New Range Units](#name-considerations-for-new-rang)
  + [16.6](#section-16.6).  [Content Coding Extensibility](#name-content-coding-extensibilit)

    - [16.6.1](#section-16.6.1).  [Content Coding Registry](#name-content-coding-registry)
    - [16.6.2](#section-16.6.2).  [Considerations for New Content Codings](#name-considerations-for-new-cont)
  + [16.7](#section-16.7).  [Upgrade Token Registry](#name-upgrade-token-registry)
* [17](#section-17). [Security Considerations](#name-security-considerations)

  + [17.1](#section-17.1).  [Establishing Authority](#name-establishing-authority)
  + [17.2](#section-17.2).  [Risks of Intermediaries](#name-risks-of-intermediaries)
  + [17.3](#section-17.3).  [Attacks Based on File and Path Names](#name-attacks-based-on-file-and-p)
  + [17.4](#section-17.4).  [Attacks Based on Command, Code, or Query Injection](#name-attacks-based-on-command-co)
  + [17.5](#section-17.5).  [Attacks via Protocol Element Length](#name-attacks-via-protocol-elemen)
  + [17.6](#section-17.6).  [Attacks Using Shared-Dictionary Compression](#name-attacks-using-shared-dictio)
  + [17.7](#section-17.7).  [Disclosure of Personal Information](#name-disclosure-of-personal-info)
  + [17.8](#section-17.8).  [Privacy of Server Log Information](#name-privacy-of-server-log-infor)
  + [17.9](#section-17.9).  [Disclosure of Sensitive Information in URIs](#name-disclosure-of-sensitive-inf)
  + [17.10](#section-17.10). [Application Handling of Field Names](#name-application-handling-of-fie)
  + [17.11](#section-17.11). [Disclosure of Fragment after Redirects](#name-disclosure-of-fragment-afte)
  + [17.12](#section-17.12). [Disclosure of Product Information](#name-disclosure-of-product-infor)
  + [17.13](#section-17.13). [Browser Fingerprinting](#name-browser-fingerprinting)
  + [17.14](#section-17.14). [Validator Retention](#name-validator-retention)
  + [17.15](#section-17.15). [Denial-of-Service Attacks Using Range](#name-denial-of-service-attacks-u)
  + [17.16](#section-17.16). [Authentication Considerations](#name-authentication-consideratio)

    - [17.16.1](#section-17.16.1).  [Confidentiality of Credentials](#name-confidentiality-of-credenti)
    - [17.16.2](#section-17.16.2).  [Credentials and Idle Clients](#name-credentials-and-idle-client)
    - [17.16.3](#section-17.16.3).  [Protection Spaces](#name-protection-spaces)
    - [17.16.4](#section-17.16.4).  [Additional Response Fields](#name-additional-response-fields)
* [18](#section-18). [IANA Considerations](#name-iana-considerations)

  + [18.1](#section-18.1).  [URI Scheme Registration](#name-uri-scheme-registration)
  + [18.2](#section-18.2).  [Method Registration](#name-method-registration)
  + [18.3](#section-18.3).  [Status Code Registration](#name-status-code-registration)
  + [18.4](#section-18.4).  [Field Name Registration](#name-field-name-registration)
  + [18.5](#section-18.5).  [Authentication Scheme Registration](#name-authentication-scheme-regist)
  + [18.6](#section-18.6).  [Content Coding Registration](#name-content-coding-registration)
  + [18.7](#section-18.7).  [Range Unit Registration](#name-range-unit-registration)
  + [18.8](#section-18.8).  [Media Type Registration](#name-media-type-registration)
  + [18.9](#section-18.9).  [Port Registration](#name-port-registration)
  + [18.10](#section-18.10). [Upgrade Token Registration](#name-upgrade-token-registration)
* [19](#section-19). [References](#name-references)

  + [19.1](#section-19.1).  [Normative References](#name-normative-references)
  + [19.2](#section-19.2).  [Informative References](#name-informative-references)
* [Appendix A](#appendix-A).  [Collected ABNF](#name-collected-abnf)
* [Appendix B](#appendix-B).  [Changes from Previous RFCs](#name-changes-from-previous-rfcs)

  + [B.1](#appendix-B.1).  [Changes from RFC 2818](#name-changes-from-rfc-2818)
  + [B.2](#appendix-B.2).  [Changes from RFC 7230](#name-changes-from-rfc-7230)
  + [B.3](#appendix-B.3).  [Changes from RFC 7231](#name-changes-from-rfc-7231)
  + [B.4](#appendix-B.4).  [Changes from RFC 7232](#name-changes-from-rfc-7232)
  + [B.5](#appendix-B.5).  [Changes from RFC 7233](#name-changes-from-rfc-7233)
  + [B.6](#appendix-B.6).  [Changes from RFC 7235](#name-changes-from-rfc-7235)
  + [B.7](#appendix-B.7).  [Changes from RFC 7538](#name-changes-from-rfc-7538)
  + [B.8](#appendix-B.8).  [Changes from RFC 7615](#name-changes-from-rfc-7615)
  + [B.9](#appendix-B.9).  [Changes from RFC 7694](#name-changes-from-rfc-7694)
* [Acknowledgements](#name-acknowledgements)
* [Index](#name-index)
* [Authors' Addresses](#name-authors-addresses)

## [1.](#section-1) [Introduction](#name-introduction)

### [1.1.](#section-1.1) [Purpose](#name-purpose)

The Hypertext Transfer Protocol (HTTP) is a family of stateless,
application-level, request/response protocols that share a generic interface,
extensible semantics, and self-descriptive messages to enable flexible
interaction with network-based hypertext information systems.[¶](#section-1.1-1)

HTTP hides the details of how a service is implemented by presenting a
uniform interface to clients that is independent of the types of resources
provided. Likewise, servers do not need to be aware of each client's
purpose: a request can be considered in isolation rather than being
associated with a specific type of client or a predetermined sequence of
application steps. This allows general-purpose implementations to be used
effectively in many different contexts, reduces interaction complexity, and
enables independent evolution over time.[¶](#section-1.1-2)

HTTP is also designed for use as an intermediation protocol, wherein
proxies and gateways can translate non-HTTP information systems into a
more generic interface.[¶](#section-1.1-3)

One consequence of this flexibility is that the protocol cannot be
defined in terms of what occurs behind the interface. Instead, we
are limited to defining the syntax of communication, the intent
of received communication, and the expected behavior of recipients.
If the communication is considered in isolation, then successful
actions ought to be reflected in corresponding changes to the
observable interface provided by servers. However, since multiple
clients might act in parallel and perhaps at cross-purposes, we
cannot require that such changes be observable beyond the scope
of a single response.[¶](#section-1.1-4)

### [1.2.](#section-1.2) [History and Evolution](#name-history-and-evolution)

HTTP has been the primary information transfer protocol for the World
Wide Web since its introduction in 1990. It began as a trivial
mechanism for low-latency requests, with a single method (GET) to
request transfer of a presumed hypertext document identified by a given pathname.
As the Web grew, HTTP was extended to enclose requests and responses within
messages, transfer arbitrary data formats using MIME-like media types, and
route requests through intermediaries. These protocols were eventually
defined as HTTP/0.9 and HTTP/1.0 (see [[HTTP/1.0](#HTTP10)]).[¶](#section-1.2-1)

HTTP/1.1 was designed to refine the protocol's features while retaining
compatibility with the existing text-based messaging syntax, improving
its interoperability, scalability, and robustness across the Internet.
This included length-based data delimiters for both fixed and dynamic
(chunked) content, a consistent framework for content negotiation,
opaque validators for conditional requests, cache controls for better
cache consistency, range requests for partial updates, and default
persistent connections. HTTP/1.1 was introduced in 1995 and published on
the Standards Track in 1997 [[RFC2068](#RFC2068)], revised in
1999 [[RFC2616](#RFC2616)], and revised again in 2014
([[RFC7230](#RFC7230)] through [[RFC7235](#RFC7235)]).[¶](#section-1.2-2)

HTTP/2 ([[HTTP/2](#HTTP2)]) introduced a multiplexed session layer
on top of the existing TLS and TCP protocols for exchanging concurrent
HTTP messages with efficient field compression and server push.
HTTP/3 ([[HTTP/3](#HTTP3)]) provides greater independence for concurrent
messages by using QUIC as a secure multiplexed transport over UDP instead of
TCP.[¶](#section-1.2-3)

All three major versions of HTTP rely on the semantics defined by
this document. They have not obsoleted each other because each one has
specific benefits and limitations depending on the context of use.
Implementations are expected to choose the most appropriate transport and
messaging syntax for their particular context.[¶](#section-1.2-4)

This revision of HTTP separates the definition of semantics (this document)
and caching ([[CACHING](#CACHING)]) from the current HTTP/1.1 messaging
syntax ([[HTTP/1.1](#HTTP11)]) to allow each major protocol version
to progress independently while referring to the same core semantics.[¶](#section-1.2-5)

### [1.3.](#section-1.3) [Core Semantics](#name-core-semantics)

HTTP provides a uniform interface for interacting with a resource
([Section 3.1](#resources)) -- regardless of its type, nature, or
implementation -- by sending messages that manipulate or transfer
representations ([Section 3.2](#representations)).[¶](#section-1.3-1)

Each message is either a request or a response. A client constructs request
messages that communicate its intentions and routes those messages toward
an identified origin server. A server listens for requests, parses each
message received, interprets the message semantics in relation to the
identified target resource, and responds to that request with one or more
response messages. The client examines received responses to see if its
intentions were carried out, determining what to do next based on the
status codes and content received.[¶](#section-1.3-2)

HTTP semantics include the intentions defined by each request method
([Section 9](#methods)), extensions to those semantics that might be
described in request header fields,
status codes that describe the response ([Section 15](#status.codes)), and
other control data and resource metadata that might be given in response
fields.[¶](#section-1.3-3)

Semantics also include representation metadata that describe how
content is intended to be interpreted by a recipient, request header
fields that might influence content selection, and the various selection
algorithms that are collectively referred to as
"content negotiation" ([Section 12](#content.negotiation)).[¶](#section-1.3-4)

### [1.4.](#section-1.4) [Specifications Obsoleted by This Document](#name-specifications-obsoleted-by)

[Table 1](#table-1)
| Title | Reference | See |
| --- | --- | --- |
| HTTP Over TLS | [[RFC2818](#RFC2818)] | [B.1](#changes.from.rfc.2818) |
| HTTP/1.1 Message Syntax and Routing [\*] | [[RFC7230](#RFC7230)] | [B.2](#changes.from.rfc.7230) |
| HTTP/1.1 Semantics and Content | [[RFC7231](#RFC7231)] | [B.3](#changes.from.rfc.7231) |
| HTTP/1.1 Conditional Requests | [[RFC7232](#RFC7232)] | [B.4](#changes.from.rfc.7232) |
| HTTP/1.1 Range Requests | [[RFC7233](#RFC7233)] | [B.5](#changes.from.rfc.7233) |
| HTTP/1.1 Authentication | [[RFC7235](#RFC7235)] | [B.6](#changes.from.rfc.7235) |
| HTTP Status Code 308 (Permanent Redirect) | [[RFC7538](#RFC7538)] | [B.7](#changes.from.rfc.7538) |
| HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields | [[RFC7615](#RFC7615)] | [B.8](#changes.from.rfc.7615) |
| HTTP Client-Initiated Content-Encoding | [[RFC7694](#RFC7694)] | [B.9](#changes.from.rfc.7694) |

[\*] This document only obsoletes the portions of
[RFC 7230](#RFC7230) that are independent of
the HTTP/1.1 messaging syntax and connection management; the remaining
bits of [RFC 7230](#RFC7230) are
obsoleted by "HTTP/1.1" [[HTTP/1.1](#HTTP11)].[¶](#section-1.4-2)

## [2.](#section-2) [Conformance](#name-conformance)

### [2.1.](#section-2.1) [Syntax Notation](#name-syntax-notation)

This specification uses the Augmented Backus-Naur Form (ABNF) notation of
[[RFC5234](#RFC5234)], extended with the notation for case-sensitivity
in strings defined in [[RFC7405](#RFC7405)].[¶](#section-2.1-1)

It also uses a list extension, defined in [Section 5.6.1](#abnf.extension),
that allows for compact definition of comma-separated lists using a "#"
operator (similar to how the "\*" operator indicates repetition). [Appendix A](#collected.abnf) shows the collected grammar with all list
operators expanded to standard ABNF notation.[¶](#section-2.1-2)

As a convention, ABNF rule names prefixed with "obs-" denote
obsolete grammar rules that appear for historical reasons.[¶](#section-2.1-3)

The following core rules are included by
reference, as defined in [Appendix B.1](https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1) of [[RFC5234](#RFC5234)]:
ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls),
DIGIT (decimal 0-9), DQUOTE (double quote),
HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed),
OCTET (any 8-bit sequence of data), SP (space), and
VCHAR (any visible US-ASCII character).[¶](#section-2.1-4)

[Section 5.6](#fields.components) defines some generic syntactic
components for field values.[¶](#section-2.1-5)

This specification uses the terms
"character",
"character encoding scheme",
"charset", and
"protocol element"
as they are defined in [[RFC6365](#RFC6365)].[¶](#section-2.1-6)

### [2.2.](#section-2.2) [Requirements Notation](#name-requirements-notation)

The key words "MUST", "MUST NOT",
"REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT",
"RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be
interpreted as described in BCP 14 [[RFC2119](#RFC2119)] [[RFC8174](#RFC8174)] when, and only when, they appear in all capitals, as
shown here.[¶](#section-2.2-1)

This specification targets conformance criteria according to the role of
a participant in HTTP communication. Hence, requirements are placed
on senders, recipients, clients, servers, user agents, intermediaries,
origin servers, proxies, gateways, or caches, depending on what behavior
is being constrained by the requirement. Additional requirements
are placed on implementations, resource owners, and protocol element
registrations when they apply beyond the scope of a single communication.[¶](#section-2.2-2)

The verb "generate" is used instead of "send" where a requirement applies
only to implementations that create the protocol element, rather than an
implementation that forwards a received element downstream.[¶](#section-2.2-3)

An implementation is considered conformant if it complies with all of the
requirements associated with the roles it partakes in HTTP.[¶](#section-2.2-4)

A sender MUST NOT generate protocol elements that do not match the grammar
defined by the corresponding ABNF rules.
Within a given message, a sender MUST NOT generate protocol elements or
syntax alternatives that are only allowed to be generated by participants in
other roles (i.e., a role that the sender does not have for that message).[¶](#section-2.2-5)

Conformance to HTTP includes both conformance to the particular messaging
syntax of the protocol version in use and conformance to the semantics of
protocol elements sent. For example, a client that claims conformance to
HTTP/1.1 but fails to recognize the features required of HTTP/1.1
recipients will fail to interoperate with servers that adjust their
responses in accordance with those claims.
Features that reflect user choices, such as content negotiation and
user-selected extensions, can impact application behavior beyond the
protocol stream; sending protocol elements that inaccurately reflect a
user's choices will confuse the user and inhibit choice.[¶](#section-2.2-6)

When an implementation fails semantic conformance, recipients of that
implementation's messages will eventually develop workarounds to adjust
their behavior accordingly. A recipient MAY employ such workarounds while
remaining conformant to this protocol if the workarounds are limited to the
implementations at fault. For example, servers often scan portions of the
User-Agent field value, and user agents often scan the Server field value,
to adjust their own behavior with respect to known bugs or poorly chosen
defaults.[¶](#section-2.2-7)

### [2.3.](#section-2.3) [Length Requirements](#name-length-requirements)

A recipient SHOULD parse a received protocol element defensively, with
only marginal expectations that the element will conform to its ABNF
grammar and fit within a reasonable buffer size.[¶](#section-2.3-1)

HTTP does not have specific length limitations for many of its protocol
elements because the lengths that might be appropriate will vary widely,
depending on the deployment context and purpose of the implementation.
Hence, interoperability between senders and recipients depends on shared
expectations regarding what is a reasonable length for each protocol
element. Furthermore, what is commonly understood to be a reasonable length
for some protocol elements has changed over the course of the past three
decades of HTTP use and is expected to continue changing in the future.[¶](#section-2.3-2)

At a minimum, a recipient MUST be able to parse and process protocol
element lengths that are at least as long as the values that it generates
for those same protocol elements in other messages. For example, an origin
server that publishes very long URI references to its own resources needs
to be able to parse and process those same references when received as a
target URI.[¶](#section-2.3-3)

Many received protocol elements are only parsed to the extent necessary to
identify and forward that element downstream. For example, an intermediary
might parse a received field into its field name and field value components,
but then forward the field without further parsing inside the field value.[¶](#section-2.3-4)

### [2.4.](#section-2.4) [Error Handling](#name-error-handling)

A recipient MUST interpret a received protocol element according to the
semantics defined for it by this specification, including extensions to
this specification, unless the recipient has determined (through experience
or configuration) that the sender incorrectly implements what is implied by
those semantics.
For example, an origin server might disregard the contents of a received
[Accept-Encoding](#field.accept-encoding) header field if inspection of the
[User-Agent](#field.user-agent) header field indicates a specific implementation
version that is known to fail on receipt of certain content codings.[¶](#section-2.4-1)

Unless noted otherwise, a recipient MAY attempt to recover a usable
protocol element from an invalid construct. HTTP does not define
specific error handling mechanisms except when they have a direct impact
on security, since different applications of the protocol require
different error handling strategies. For example, a Web browser might
wish to transparently recover from a response where the
[Location](#field.location) header field doesn't parse according to the ABNF,
whereas a systems control client might consider any form of error recovery
to be dangerous.[¶](#section-2.4-2)

Some requests can be automatically retried by a client in the event of
an underlying connection failure, as described in
[Section 9.2.2](#idempotent.methods).[¶](#section-2.4-3)

### [2.5.](#section-2.5) [Protocol Version](#name-protocol-version)

HTTP's version number consists of two decimal digits separated by a "."
(period or decimal point). The first digit (major version) indicates the
messaging syntax, whereas the second digit (minor version)
indicates the highest minor version within that major version to which the
sender is conformant (able to understand for future communication).[¶](#section-2.5-1)

While HTTP's core semantics don't change between protocol versions, their
expression "on the wire" can change, and so the
HTTP version number changes when incompatible changes are made to the wire
format. Additionally, HTTP allows incremental, backwards-compatible
changes to be made to the protocol without changing its version through
the use of defined extension points ([Section 16](#extending)).[¶](#section-2.5-2)

The protocol version as a whole indicates the sender's conformance with
the set of requirements laid out in that version's corresponding
specification(s).
For example, the version "HTTP/1.1" is defined by the combined
specifications of this document, "HTTP Caching" [[CACHING](#CACHING)],
and "HTTP/1.1" [[HTTP/1.1](#HTTP11)].[¶](#section-2.5-3)

HTTP's major version number is incremented when an incompatible message
syntax is introduced. The minor number is incremented when changes made to
the protocol have the effect of adding to the message semantics or
implying additional capabilities of the sender.[¶](#section-2.5-4)

The minor version advertises the sender's communication capabilities even
when the sender is only using a backwards-compatible subset of the
protocol, thereby letting the recipient know that more advanced features
can be used in response (by servers) or in future requests (by clients).[¶](#section-2.5-5)

When a major version of HTTP does not define any minor versions, the minor
version "0" is implied. The "0" is used when referring to that protocol
within elements that require a minor version identifier.[¶](#section-2.5-6)

## [3.](#section-3) [Terminology and Core Concepts](#name-terminology-and-core-concep)

HTTP was created for the World Wide Web (WWW) architecture
and has evolved over time to support the scalability needs of a worldwide
hypertext system. Much of that architecture is reflected in the terminology
used to define HTTP.[¶](#section-3-1)

### [3.1.](#section-3.1) [Resources](#name-resources)

The target of an HTTP request is called a "resource".
HTTP does not limit the nature of a resource; it merely
defines an interface that might be used to interact with resources.
Most resources are identified by a Uniform Resource Identifier (URI), as
described in [Section 4](#uri).[¶](#section-3.1-1)

One design goal of HTTP is to separate resource identification from
request semantics, which is made possible by vesting the request
semantics in the request method ([Section 9](#methods)) and a few
request-modifying header fields.
A resource cannot treat a request in a manner inconsistent with the
semantics of the method of the request. For example, though the URI of a
resource might imply semantics that are not safe, a client can expect the
resource to avoid actions that are unsafe when processing a request with a
safe method (see [Section 9.2.1](#safe.methods)).[¶](#section-3.1-2)

HTTP relies upon the Uniform Resource Identifier (URI)
standard [[URI](#URI)] to indicate the target resource
([Section 7.1](#target.resource)) and relationships between resources.[¶](#section-3.1-3)

### [3.2.](#section-3.2) [Representations](#name-representations)

A "representation" is information
that is intended to reflect a past, current, or desired state of a given
resource, in a format that can be readily communicated via the protocol.
A representation consists of a set of representation metadata and a
potentially unbounded stream of representation data
([Section 8](#representation.data.and.metadata)).[¶](#section-3.2-1)

HTTP allows "information hiding" behind its uniform interface by defining
communication with respect to a transferable representation of the resource
state, rather than transferring the resource itself. This allows the
resource identified by a URI to be anything, including temporal functions
like "the current weather in Laguna Beach", while potentially providing
information that represents that resource at the time a message is
generated [[REST](#REST)].[¶](#section-3.2-2)

The uniform interface is similar to a window through which one can observe
and act upon a thing only through the communication of messages to an
independent actor on the other side. A shared abstraction is needed to
represent ("take the place of") the current or desired state of that thing
in our communications. When a representation is hypertext, it can provide
both a representation of the resource state and processing instructions
that help guide the recipient's future interactions.[¶](#section-3.2-3)

A [target resource](#target.resource) might be provided with, or be capable of
generating, multiple representations that are each intended to reflect the
resource's current state. An algorithm, usually based on
[content negotiation](#content.negotiation) ([Section 12](#content.negotiation)),
would be used to select one of those representations as being most
applicable to a given request.
This "selected representation" provides the data and metadata
for evaluating conditional requests ([Section 13](#conditional.requests))
and constructing the content for [200 (OK)](#status.200),
[206 (Partial Content)](#status.206), and
[304 (Not Modified)](#status.304) responses to GET ([Section 9.3.1](#GET)).[¶](#section-3.2-4)

### [3.3.](#section-3.3) [Connections, Clients, and Servers](#name-connections-clients-and-ser)

HTTP is a client/server protocol that operates over a reliable
transport- or session-layer "connection".[¶](#section-3.3-1)

An HTTP "client" is a program that establishes a connection
to a server for the purpose of sending one or more HTTP requests.
An HTTP "server" is a program that accepts connections
in order to service HTTP requests by sending HTTP responses.[¶](#section-3.3-2)

The terms client and server refer only to the roles that
these programs perform for a particular connection. The same program
might act as a client on some connections and a server on others.[¶](#section-3.3-3)

HTTP is defined as a stateless protocol, meaning that each request message's semantics
can be understood in isolation, and that the relationship between connections
and messages on them has no impact on the interpretation of those messages.
For example, a CONNECT request ([Section 9.3.6](#CONNECT)) or a request with
the Upgrade header field ([Section 7.8](#field.upgrade)) can occur at any time,
not just in the first message on a connection. Many implementations depend on
HTTP's stateless design in order to reuse proxied connections or dynamically
load balance requests across multiple servers.[¶](#section-3.3-4)

As a result, a server MUST NOT
assume that two requests on the same connection are from the same user
agent unless the connection is secured and specific to that agent.
Some non-standard HTTP extensions (e.g., [[RFC4559](#RFC4559)]) have
been known to violate this requirement, resulting in security and
interoperability problems.[¶](#section-3.3-5)

### [3.4.](#section-3.4) [Messages](#name-messages)

HTTP is a stateless request/response protocol for exchanging
"messages" across a [connection](#connections).
The terms "sender" and "recipient" refer to
any implementation that sends or receives a given message, respectively.[¶](#section-3.4-1)

A client sends requests to a server in the form of a "request"
message with a method ([Section 9](#methods)) and request target
([Section 7.1](#target.resource)). The request might also contain
header fields ([Section 6.3](#header.fields)) for request modifiers,
client information, and representation metadata,
content ([Section 6.4](#content)) intended for processing
in accordance with the method, and
trailer fields ([Section 6.5](#trailer.fields)) to communicate information
collected while sending the content.[¶](#section-3.4-2)

A server responds to a client's request by sending one or more
"response" messages, each including a status
code ([Section 15](#status.codes)). The response might also contain
header fields for server information, resource metadata, and representation
metadata, content to be interpreted in accordance with the status
code, and trailer fields to communicate information
collected while sending the content.[¶](#section-3.4-3)

### [3.5.](#section-3.5) [User Agents](#name-user-agents)

The term "user agent" refers to any of the various
client programs that initiate a request.[¶](#section-3.5-1)

The most familiar form of user agent is the general-purpose Web browser, but
that's only a small percentage of implementations. Other common user agents
include spiders (web-traversing robots), command-line tools, billboard
screens, household appliances, scales, light bulbs, firmware update scripts,
mobile apps, and communication devices in a multitude of shapes and sizes.[¶](#section-3.5-2)

Being a user agent does not imply that there is a human user directly
interacting with the software agent at the time of a request. In many
cases, a user agent is installed or configured to run in the background
and save its results for later inspection (or save only a subset of those
results that might be interesting or erroneous). Spiders, for example, are
typically given a start URI and configured to follow certain behavior while
crawling the Web as a hypertext graph.[¶](#section-3.5-3)

Many user agents cannot, or choose not to,
make interactive suggestions to their user or provide adequate warning for
security or privacy concerns. In the few cases where this
specification requires reporting of errors to the user, it is acceptable
for such reporting to only be observable in an error console or log file.
Likewise, requirements that an automated action be confirmed by the user
before proceeding might be met via advance configuration choices,
run-time options, or simple avoidance of the unsafe action; confirmation
does not imply any specific user interface or interruption of normal
processing if the user has already made that choice.[¶](#section-3.5-4)

### [3.6.](#section-3.6) [Origin Server](#name-origin-server)

The term "origin server" refers to a program that can
originate authoritative responses for a given target resource.[¶](#section-3.6-1)

The most familiar form of origin server are large public websites.
However, like user agents being equated with browsers, it is easy to be
misled into thinking that all origin servers are alike.
Common origin servers also include home automation units, configurable
networking components, office machines, autonomous robots, news feeds,
traffic cameras, real-time ad selectors, and video-on-demand platforms.[¶](#section-3.6-2)

Most HTTP communication consists of a retrieval request (GET) for
a representation of some resource identified by a URI. In the
simplest case, this might be accomplished via a single bidirectional
connection (===) between the user agent (UA) and the origin server (O).[¶](#section-3.6-3)

```

         request   >
    UA ======================================= O
                                <   response

```

[Figure 1](#figure-1)

### [3.7.](#section-3.7) [Intermediaries](#name-intermediaries)

HTTP enables the use of intermediaries to satisfy requests through
a chain of connections. There are three common forms of HTTP
"intermediary": proxy, gateway, and tunnel. In some cases,
a single intermediary might act as an origin server, proxy, gateway,
or tunnel, switching behavior based on the nature of each request.[¶](#section-3.7-1)

```

         >             >             >             >
    UA =========== A =========== B =========== C =========== O
               <             <             <             <

```

[Figure 2](#figure-2)

The figure above shows three intermediaries (A, B, and C) between the
user agent and origin server. A request or response message that
travels the whole chain will pass through four separate connections.
Some HTTP communication options
might apply only to the connection with the nearest, non-tunnel
neighbor, only to the endpoints of the chain, or to all connections
along the chain. Although the diagram is linear, each participant might
be engaged in multiple, simultaneous communications. For example, B
might be receiving requests from many clients other than A, and/or
forwarding requests to servers other than C, at the same time that it
is handling A's request. Likewise, later requests might be sent through a
different path of connections, often based on dynamic configuration for
load balancing.[¶](#section-3.7-3)

The terms "upstream" and "downstream" are
used to describe directional requirements in relation to the message flow:
all messages flow from upstream to downstream.
The terms "inbound" and "outbound" are used to describe directional
requirements in relation to the request route:
inbound means "toward the origin server", whereas
outbound means "toward the user agent".[¶](#section-3.7-4)

A "proxy" is a message-forwarding agent that is chosen by the
client, usually via local configuration rules, to receive requests
for some type(s) of absolute URI and attempt to satisfy those
requests via translation through the HTTP interface. Some translations
are minimal, such as for proxy requests for "http" URIs, whereas
other requests might require translation to and from entirely different
application-level protocols. Proxies are often used to group an
organization's HTTP requests through a common intermediary for the
sake of security services, annotation services, or shared caching. Some
proxies are designed to apply transformations to selected messages or
content while they are being forwarded, as described in
[Section 7.7](#message.transformations).[¶](#section-3.7-5)

A "gateway" (a.k.a. "reverse proxy") is an
intermediary that acts as an origin server for the outbound connection but
translates received requests and forwards them inbound to another server or
servers. Gateways are often used to encapsulate legacy or untrusted
information services, to improve server performance through
"accelerator" caching, and to enable partitioning or load
balancing of HTTP services across multiple machines.[¶](#section-3.7-6)

All HTTP requirements applicable to an origin server
also apply to the outbound communication of a gateway.
A gateway communicates with inbound servers using any protocol that
it desires, including private extensions to HTTP that are outside
the scope of this specification. However, an HTTP-to-HTTP gateway
that wishes to interoperate with third-party HTTP servers needs to conform
to user agent requirements on the gateway's inbound connection.[¶](#section-3.7-7)

A "tunnel" acts as a blind relay between two connections
without changing the messages. Once active, a tunnel is not
considered a party to the HTTP communication, though the tunnel might
have been initiated by an HTTP request. A tunnel ceases to exist when
both ends of the relayed connection are closed. Tunnels are used to
extend a virtual connection through an intermediary, such as when
Transport Layer Security (TLS, [[TLS13](#TLS13)]) is used to
establish confidential communication through a shared firewall proxy.[¶](#section-3.7-8)

The above categories for intermediary only consider those acting as
participants in the HTTP communication. There are also intermediaries
that can act on lower layers of the network protocol stack, filtering or
redirecting HTTP traffic without the knowledge or permission of message
senders. Network intermediaries are indistinguishable (at a protocol level)
from an on-path attacker, often introducing security flaws or
interoperability problems due to mistakenly violating HTTP semantics.[¶](#section-3.7-9)

For example, an "interception proxy" [[RFC3040](#RFC3040)] (also commonly
known as a "transparent proxy" [[RFC1919](#RFC1919)])
differs from an HTTP proxy because it is not chosen by the client.
Instead, an interception proxy filters or redirects outgoing TCP port 80
packets (and occasionally other common port traffic).
Interception proxies are commonly found on public network access points,
as a means of enforcing account subscription prior to allowing use of
non-local Internet services, and within corporate firewalls to enforce
network usage policies.[¶](#section-3.7-10)

### [3.8.](#section-3.8) [Caches](#name-caches)

A "cache" is a local store of previous response messages and the
subsystem that controls its message storage, retrieval, and deletion.
A cache stores cacheable responses in order to reduce the response
time and network bandwidth consumption on future, equivalent
requests. Any client or server MAY employ a cache, though a cache
cannot be used while acting as a tunnel.[¶](#section-3.8-1)

The effect of a cache is that the request/response chain is shortened
if one of the participants along the chain has a cached response
applicable to that request. The following illustrates the resulting
chain if B has a cached copy of an earlier response from O (via C)
for a request that has not been cached by UA or A.[¶](#section-3.8-2)

```

            >             >
       UA =========== A =========== B - - - - - - C - - - - - - O
                  <             <

```

[Figure 3](#figure-3)

A response is "cacheable" if a cache is allowed to store a copy of
the response message for use in answering subsequent requests.
Even when a response is cacheable, there might be additional
constraints placed by the client or by the origin server on when
that cached response can be used for a particular request. HTTP
requirements for cache behavior and cacheable responses are
defined in [[CACHING](#CACHING)].[¶](#section-3.8-4)

There is a wide variety of architectures and configurations
of caches deployed across the World Wide Web and
inside large organizations. These include national hierarchies
of proxy caches to save bandwidth and reduce latency, content delivery
networks that use gateway caching to optimize regional and global distribution of popular sites,
collaborative systems that
broadcast or multicast cache entries, archives of pre-fetched cache
entries for use in off-line or high-latency environments, and so on.[¶](#section-3.8-5)

### [3.9.](#section-3.9) [Example Message Exchange](#name-example-message-exchange)

The following example illustrates a typical HTTP/1.1 message exchange for a
GET request ([Section 9.3.1](#GET)) on the URI "http://www.example.com/hello.txt":[¶](#section-3.9-1)

Client request:[¶](#section-3.9-2)

```
GET /hello.txt HTTP/1.1
User-Agent: curl/7.64.1
Host: www.example.com
Accept-Language: en, mi

```
[¶](#section-3.9-3)

Server response:[¶](#section-3.9-4)

```
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain

Hello World! My content includes a trailing CRLF.

```
[¶](#section-3.9-5)

## [4.](#section-4) [Identifiers in HTTP](#name-identifiers-in-http)

Uniform Resource Identifiers (URIs) [[URI](#URI)] are used
throughout HTTP as the means for identifying resources ([Section 3.1](#resources)).[¶](#section-4-1)

### [4.1.](#section-4.1) [URI References](#name-uri-references)

URI references are used to target requests, indicate redirects, and define
relationships.[¶](#section-4.1-1)

The definitions of "URI-reference",
"absolute-URI", "relative-part", "authority", "port", "host",
"path-abempty", "segment", and "query" are adopted from the
URI generic syntax.
An "absolute-path" rule is defined for protocol elements that can contain a
non-empty path component. (This rule differs slightly from the path-abempty
rule of RFC 3986, which allows for an empty path,
and path-absolute rule, which does not allow paths that begin with "//".)
A "partial-URI" rule is defined for protocol elements
that can contain a relative URI but not a fragment component.[¶](#section-4.1-2)

```
  URI-reference = <URI-reference, see [URI], Section 4.1>
  absolute-URI  = <absolute-URI, see [URI], Section 4.3>
  relative-part = <relative-part, see [URI], Section 4.2>
  authority     = <authority, see [URI], Section 3.2>
  uri-host      = <host, see [URI], Section 3.2.2>
  port          = <port, see [URI], Section 3.2.3>
  path-abempty  = <path-abempty, see [URI], Section 3.3>
  segment       = <segment, see [URI], Section 3.3>
  query         = <query, see [URI], Section 3.4>

  absolute-path = 1*( "/" segment )
  partial-URI   = relative-part [ "?" query ]

```
[¶](#section-4.1-3)

Each protocol element in HTTP that allows a URI reference will indicate
in its ABNF production whether the element allows any form of reference
(URI-reference), only a URI in absolute form (absolute-URI), only the
path and optional query components (partial-URI),
or some combination of the above.
Unless otherwise indicated, URI references are parsed
relative to the target URI ([Section 7.1](#target.resource)).[¶](#section-4.1-4)

It is RECOMMENDED that all senders and recipients support, at a minimum,
URIs with lengths of 8000 octets in protocol elements. Note that this
implies some structures and on-wire representations (for example, the
request line in HTTP/1.1) will necessarily be larger in some cases.[¶](#section-4.1-5)

### [4.2.](#section-4.2) [HTTP-Related URI Schemes](#name-http-related-uri-schemes)

IANA maintains the registry of URI Schemes [[BCP35](#BCP35)] at
<<https://www.iana.org/assignments/uri-schemes/>>.
Although requests might target any URI scheme, the following schemes are
inherent to HTTP servers:[¶](#section-4.2-1)

[Table 2](#table-2)
| URI Scheme | Description | Section |
| --- | --- | --- |
| http | Hypertext Transfer Protocol | [4.2.1](#http.uri) |
| https | Hypertext Transfer Protocol Secure | [4.2.2](#https.uri) |

Note that the presence of an "http" or "https" URI does not imply that
there is always an HTTP server at the identified origin listening for
connections. Anyone can mint a URI, whether or not a server exists and
whether or not that server currently maps that identifier to a resource.
The delegated nature of registered names and IP addresses creates a
federated namespace whether or not an HTTP server is present.[¶](#section-4.2-3)

#### [4.2.1.](#section-4.2.1) [http URI Scheme](#name-http-uri-scheme)

The "http" URI scheme is hereby defined for minting identifiers within the
hierarchical namespace governed by a potential HTTP origin server
listening for TCP ([[TCP](#TCP)]) connections on a given port.[¶](#section-4.2.1-1)

```
  http-URI = "http" "://" authority path-abempty [ "?" query ]

```
[¶](#section-4.2.1-2)

The origin server for an "http" URI is identified by the
[authority](#uri.references) component, which includes a host identifier
([[URI](#URI)], [Section 3.2.2](https://www.rfc-editor.org/rfc/rfc3986#section-3.2.2))
and optional port number ([[URI](#URI)], [Section 3.2.3](https://www.rfc-editor.org/rfc/rfc3986#section-3.2.3)).
If the port subcomponent is empty or not given, TCP port 80 (the
reserved port for WWW services) is the default.
The origin determines who has the right to respond authoritatively to
requests that target the identified resource, as defined in
[Section 4.3.2](#http.origin).[¶](#section-4.2.1-3)

A sender MUST NOT generate an "http" URI with an empty host identifier.
A recipient that processes such a URI reference MUST reject it as invalid.[¶](#section-4.2.1-4)

The hierarchical path component and optional query component identify the
target resource within that origin server's namespace.[¶](#section-4.2.1-5)

#### [4.2.2.](#section-4.2.2) [https URI Scheme](#name-https-uri-scheme)

The "https" URI scheme is hereby defined for minting identifiers within the
hierarchical namespace governed by a potential origin server listening for
TCP connections on a given port and capable of establishing a TLS
([[TLS13](#TLS13)]) connection that has been secured for HTTP
communication. In this context, "secured" specifically
means that the server has been authenticated as acting on behalf of the
identified authority and all HTTP communication with that server has
confidentiality and integrity protection that is acceptable to both client
and server.[¶](#section-4.2.2-1)

```
  https-URI = "https" "://" authority path-abempty [ "?" query ]

```
[¶](#section-4.2.2-2)

The origin server for an "https" URI is identified by the
[authority](#uri.references) component, which includes a host identifier
([[URI](#URI)], [Section 3.2.2](https://www.rfc-editor.org/rfc/rfc3986#section-3.2.2))
and optional port number ([[URI](#URI)], [Section 3.2.3](https://www.rfc-editor.org/rfc/rfc3986#section-3.2.3)).
If the port subcomponent is empty or not given, TCP port 443
(the reserved port for HTTP over TLS) is the default.
The origin determines who has the right to respond authoritatively to
requests that target the identified resource, as defined in
[Section 4.3.3](#https.origin).[¶](#section-4.2.2-3)

A sender MUST NOT generate an "https" URI with an empty host identifier.
A recipient that processes such a URI reference MUST reject it as invalid.[¶](#section-4.2.2-4)

The hierarchical path component and optional query component identify the
target resource within that origin server's namespace.[¶](#section-4.2.2-5)

A client MUST ensure that its HTTP requests for an "https" resource are
secured, prior to being communicated, and that it only accepts secured
responses to those requests. Note that the definition of what cryptographic
mechanisms are acceptable to client and server are usually negotiated and
can change over time.[¶](#section-4.2.2-6)

Resources made available via the "https" scheme have no shared identity
with the "http" scheme. They are distinct origins with separate namespaces.
However, extensions to HTTP that are defined as applying to all origins with
the same host, such as the Cookie protocol [[COOKIE](#COOKIE)],
allow information set by one service to impact communication with other
services within a matching group of host domains. Such extensions ought to
be designed with great care to prevent information obtained from a secured
connection being inadvertently exchanged within an unsecured context.[¶](#section-4.2.2-7)

#### [4.2.3.](#section-4.2.3) [http(s) Normalization and Comparison](#name-https-normalization-and-com)

URIs with an "http" or "https" scheme are normalized and compared according to the
methods defined in [Section 6](https://www.rfc-editor.org/rfc/rfc3986#section-6) of [[URI](#URI)], using
the defaults described above for each scheme.[¶](#section-4.2.3-1)

HTTP does not require the use of a specific method for determining
equivalence. For example, a cache key might be compared as a simple
string, after syntax-based normalization, or after scheme-based
normalization.[¶](#section-4.2.3-2)

Scheme-based normalization ([Section 6.2.3](https://www.rfc-editor.org/rfc/rfc3986#section-6.2.3) of [[URI](#URI)]) of "http" and "https" URIs involves the following
additional rules:[¶](#section-4.2.3-3)

* If the port is equal to the default port for a scheme, the normal form
  is to omit the port subcomponent.[¶](#section-4.2.3-4.1)
* When not being used as the target of an OPTIONS request, an empty path
  component is equivalent to an absolute path of "/", so the normal form is
  to provide a path of "/" instead.[¶](#section-4.2.3-4.2)
* The scheme and host are case-insensitive and normally provided in
  lowercase; all other components are compared in a case-sensitive
  manner.[¶](#section-4.2.3-4.3)
* Characters other than those in the "reserved" set are equivalent to
  their percent-encoded octets: the normal form is to not encode them (see
  Sections [2.1](https://www.rfc-editor.org/rfc/rfc3986#section-2.1) and [2.2](https://www.rfc-editor.org/rfc/rfc3986#section-2.2) of [[URI](#URI)]).[¶](#section-4.2.3-4.4)

For example, the following three URIs are equivalent:[¶](#section-4.2.3-5)

```

   http://example.com:80/~smith/home.html
   http://EXAMPLE.com/%7Esmith/home.html
   http://EXAMPLE.com:/%7esmith/home.html

```
[¶](#section-4.2.3-6)

Two HTTP URIs that are equivalent after normalization (using any method)
can be assumed to identify the same resource, and any HTTP component MAY
perform normalization. As a result, distinct resources SHOULD NOT be
identified by HTTP URIs that are equivalent after normalization (using any
method defined in [Section 6.2](https://www.rfc-editor.org/rfc/rfc3986#section-6.2) of [[URI](#URI)]).[¶](#section-4.2.3-7)

#### [4.2.4.](#section-4.2.4) [Deprecation of userinfo in http(s) URIs](#name-deprecation-of-userinfo-in-)

The URI generic syntax for authority also includes a userinfo subcomponent
([[URI](#URI)], [Section 3.2.1](https://www.rfc-editor.org/rfc/rfc3986#section-3.2.1)) for including user
authentication information in the URI. In that subcomponent, the
use of the format "user:password" is deprecated.[¶](#section-4.2.4-1)

Some implementations make use of the userinfo component for internal
configuration of authentication information, such as within command
invocation options, configuration files, or bookmark lists, even
though such usage might expose a user identifier or password.[¶](#section-4.2.4-2)

A sender MUST NOT generate the userinfo subcomponent (and its "@"
delimiter) when an "http" or "https" URI reference is generated within a
message as a target URI or field value.[¶](#section-4.2.4-3)

Before making use of an "http" or "https" URI reference received from an untrusted
source, a recipient SHOULD parse for userinfo and treat its presence as
an error; it is likely being used to obscure the authority for the sake of
phishing attacks.[¶](#section-4.2.4-4)

#### [4.2.5.](#section-4.2.5) [http(s) References with Fragment Identifiers](#name-https-references-with-fragm)

Fragment identifiers allow for indirect identification
of a secondary resource, independent of the URI scheme, as defined in
[Section 3.5](https://www.rfc-editor.org/rfc/rfc3986#section-3.5) of [[URI](#URI)].
Some protocol elements that refer to a URI allow inclusion of a fragment,
while others do not. They are distinguished by use of the ABNF rule for
elements where fragment is allowed; otherwise, a specific rule that excludes
fragments is used.[¶](#section-4.2.5-1)

**Note:** The fragment identifier component is not part of the scheme
definition for a URI scheme (see [Section 4.3](https://www.rfc-editor.org/rfc/rfc3986#section-4.3) of [[URI](#URI)]),
thus does not appear in the ABNF definitions for the "http" and "https"
URI schemes above.[¶](#section-4.2.5-2.1)

### [4.3.](#section-4.3) [Authoritative Access](#name-authoritative-access)

Authoritative access refers to dereferencing a given identifier,
for the sake of access to the identified resource, in a way that the client
believes is authoritative (controlled by the resource owner). The process
for determining whether access is granted is defined by the URI scheme and often uses
data within the URI components, such as the authority component when
the generic syntax is used. However, authoritative access is not limited to
the identified mechanism.[¶](#section-4.3-1)

[Section 4.3.1](#origin) defines the concept of an origin as an aid to
such uses, and the subsequent subsections explain how to establish that a
peer has the authority to represent an origin.[¶](#section-4.3-2)

See [Section 17.1](#establishing.authority) for security considerations
related to establishing authority.[¶](#section-4.3-3)

#### [4.3.1.](#section-4.3.1) [URI Origin](#name-uri-origin)

The "origin" for a given URI is the triple of scheme, host,
and port after normalizing the scheme and host to lowercase and
normalizing the port to remove any leading zeros. If port is elided from
the URI, the default port for that scheme is used. For example, the URI[¶](#section-4.3.1-1)

```

   https://Example.Com/happy.js

```
[¶](#section-4.3.1-2)

would have the origin[¶](#section-4.3.1-3)

```

   { "https", "example.com", "443" }

```
[¶](#section-4.3.1-4)

which can also be described as the normalized URI prefix with port always
present:[¶](#section-4.3.1-5)

```

   https://example.com:443

```
[¶](#section-4.3.1-6)

Each origin defines its own namespace and controls how identifiers
within that namespace are mapped to resources. In turn, how the origin
responds to valid requests, consistently over time, determines the
semantics that users will associate with a URI, and the usefulness of
those semantics is what ultimately transforms these mechanisms into a
resource for users to reference and access in the future.[¶](#section-4.3.1-7)

Two origins are distinct if they differ in scheme, host, or port. Even
when it can be verified that the same entity controls two distinct origins,
the two namespaces under those origins are distinct unless explicitly
aliased by a server authoritative for that origin.[¶](#section-4.3.1-8)

Origin is also used within HTML and related Web protocols, beyond the
scope of this document, as described in [[RFC6454](#RFC6454)].[¶](#section-4.3.1-9)

#### [4.3.2.](#section-4.3.2) [http Origins](#name-http-origins)

Although HTTP is independent of the transport protocol, the "http" scheme
([Section 4.2.1](#http.uri)) is specific to associating authority with
whomever controls the origin
server listening for TCP connections on the indicated port of whatever
host is identified within the authority component. This is a very weak
sense of authority because it depends on both client-specific name
resolution mechanisms and communication that might not be secured from
an on-path attacker. Nevertheless, it is a sufficient minimum for
binding "http" identifiers to an origin server for consistent resolution
within a trusted environment.[¶](#section-4.3.2-1)

If the host identifier is provided as an IP address, the origin server is
the listener (if any) on the indicated TCP port at that IP address.
If host is a registered name, the registered name is an indirect identifier
for use with a name resolution service, such as DNS, to find an address for
an appropriate origin server.[¶](#section-4.3.2-2)

When an "http" URI is used within a context that calls for access to the
indicated resource, a client MAY attempt access by resolving the host
identifier to an IP address, establishing a TCP connection to that
address on the indicated port, and sending over that connection an HTTP
request message containing a request target that matches the client's
target URI ([Section 7.1](#target.resource)).[¶](#section-4.3.2-3)

If the server responds to such a request with a non-interim HTTP response
message, as described in [Section 15](#status.codes), then that response
is considered an authoritative answer to the client's request.[¶](#section-4.3.2-4)

Note, however, that the above is not the only means for obtaining an
authoritative response, nor does it imply that an authoritative response
is always necessary (see [[CACHING](#CACHING)]).
For example, the Alt-Svc header field [[ALTSVC](#ALTSVC)] allows an
origin server to identify other services that are also authoritative for
that origin. Access to "http" identified resources might also be provided
by protocols outside the scope of this document.[¶](#section-4.3.2-5)

#### [4.3.3.](#section-4.3.3) [https Origins](#name-https-origins)

The "https" scheme ([Section 4.2.2](#https.uri)) associates authority based
on the ability of a server to use the private key corresponding to a
certificate that the client considers to be trustworthy for the identified
origin server. The client usually relies upon a chain of trust, conveyed
from some prearranged or configured trust anchor, to deem a certificate
trustworthy ([Section 4.3.4](#https.verify)).[¶](#section-4.3.3-1)

In HTTP/1.1 and earlier, a client will only attribute authority to a server
when they are communicating over a successfully established and secured
connection specifically to that URI origin's host. The connection
establishment and certificate verification are used as proof of authority.[¶](#section-4.3.3-2)

In HTTP/2 and HTTP/3, a client will attribute authority to a server when
they are communicating over a successfully established and secured
connection if the URI origin's host matches any of the hosts present in the
server's certificate and the client believes that it could open a connection
to that host for that URI. In practice, a client will make a DNS query to
check that the origin's host contains the same server IP address as the
established connection. This restriction can be removed by the origin server
sending an equivalent ORIGIN frame [[RFC8336](#RFC8336)].[¶](#section-4.3.3-3)

The request target's host and port value are passed within each HTTP
request, identifying the origin and distinguishing it from other namespaces
that might be controlled by the same server ([Section 7.2](#field.host)).
It is the origin's responsibility to ensure that any services provided with
control over its certificate's private key are equally responsible for
managing the corresponding "https" namespaces or at least prepared to
reject requests that appear to have been misdirected
([Section 7.4](#routing.reject)).[¶](#section-4.3.3-4)

An origin server might be unwilling to process requests for certain target
URIs even when they have the authority to do so. For example, when a host
operates distinct services on different ports (e.g., 443 and 8000), checking
the target URI at the origin server is necessary (even after the connection
has been secured) because a network attacker might cause connections for one
port to be received at some other port. Failing to check the target URI
might allow such an attacker to replace a response to one target URI
(e.g., "https://example.com/foo") with a seemingly authoritative response
from the other port (e.g., "https://example.com:8000/foo").[¶](#section-4.3.3-5)

Note that the "https" scheme does not rely on TCP and the connected port
number for associating authority, since both are outside the secured
communication and thus cannot be trusted as definitive. Hence, the HTTP
communication might take place over any channel that has been secured,
as defined in [Section 4.2.2](#https.uri), including protocols that don't
use TCP.[¶](#section-4.3.3-6)

When an "https" URI is used within a context that calls for access to
the indicated resource, a client MAY attempt access by resolving the
host identifier to an IP address, establishing a TCP connection to that
address on the indicated port, securing the connection end-to-end by
successfully initiating TLS over TCP with confidentiality and integrity
protection, and sending over that connection an HTTP request message
containing a request target that matches the client's target URI
([Section 7.1](#target.resource)).[¶](#section-4.3.3-7)

If the server responds to such a request with a non-interim HTTP response
message, as described in [Section 15](#status.codes), then that response
is considered an authoritative answer to the client's request.[¶](#section-4.3.3-8)

Note, however, that the above is not the only means for obtaining an
authoritative response, nor does it imply that an authoritative response
is always necessary (see [[CACHING](#CACHING)]).[¶](#section-4.3.3-9)

#### [4.3.4.](#section-4.3.4) [https Certificate Verification](#name-https-certificate-verificat)

To establish a [secured](#https.uri) connection to dereference a URI,
a client MUST verify that the service's identity is an acceptable
match for the URI's origin server. Certificate verification is used to
prevent server impersonation by an on-path attacker or by an attacker
that controls name resolution. This process requires that a client be
configured with a set of trust anchors.[¶](#section-4.3.4-1)

In general, a client MUST verify the service identity using the
verification process defined in
[Section 6](https://www.rfc-editor.org/rfc/rfc6125#section-6) of [[RFC6125](#RFC6125)]. The client MUST construct
a reference identity from the service's host: if the host is a literal IP address
([Section 4.3.5](#https.ip-id)), the reference identity is an IP-ID, otherwise
the host is a name and the reference identity is a DNS-ID.[¶](#section-4.3.4-2)

A reference identity of type CN-ID MUST NOT be used by clients. As noted
in [Section 6.2.1](https://www.rfc-editor.org/rfc/rfc6125#section-6.2.1) of [[RFC6125](#RFC6125)], a reference
identity of type CN-ID might be used by older clients.[¶](#section-4.3.4-3)

A client might be specially configured to accept an alternative form of
server identity verification. For example, a client might be connecting
to a server whose address and hostname are dynamic, with an expectation that
the service will present a specific certificate (or a certificate matching
some externally defined reference identity) rather than one matching the
target URI's origin.[¶](#section-4.3.4-4)

In special cases, it might be appropriate for
a client to simply ignore the server's identity, but it must be
understood that this leaves a connection open to active attack.[¶](#section-4.3.4-5)

If the certificate is not valid for the target URI's origin,
a user agent MUST either obtain confirmation from the user
before proceeding (see [Section 3.5](#user.agent)) or
terminate the connection with a bad certificate error. Automated
clients MUST log the error to an appropriate audit log (if available)
and SHOULD terminate the connection (with a bad certificate error).
Automated clients MAY provide a configuration setting that disables
this check, but MUST provide a setting which enables it.[¶](#section-4.3.4-6)

#### [4.3.5.](#section-4.3.5) [IP-ID Reference Identity](#name-ip-id-reference-identity)

A server that is identified using an IP address literal in the "host" field
of an "https" URI has a reference identity of type IP-ID. An IP version 4
address uses the "IPv4address" ABNF rule, and an IP version 6 address uses
the "IP-literal" production with the "IPv6address" option; see
[Section 3.2.2](https://www.rfc-editor.org/rfc/rfc3986#section-3.2.2) of [[URI](#URI)]. A reference identity of
IP-ID contains the decoded bytes of the IP address.[¶](#section-4.3.5-1)

An IP version 4 address is 4 octets, and an IP version 6 address is 16 octets.
Use of IP-ID is not defined for any other IP version. The iPAddress
choice in the certificate subjectAltName extension does not explicitly
include the IP version and so relies on the length of the address to
distinguish versions; see
[Section 4.2.1.6](https://www.rfc-editor.org/rfc/rfc5280#section-4.2.1.6) of [[RFC5280](#RFC5280)].[¶](#section-4.3.5-2)

A reference identity of type IP-ID matches if the address is identical to
an iPAddress value of the subjectAltName extension of the certificate.[¶](#section-4.3.5-3)

## [5.](#section-5) [Fields](#name-fields)

HTTP uses "fields" to provide data in the form of extensible
name/value pairs with a registered key namespace. Fields are sent and
received within the header and trailer sections of messages
([Section 6](#message.abstraction)).[¶](#section-5-1)

### [5.1.](#section-5.1) [Field Names](#name-field-names)

A field name labels the corresponding field value as having the
semantics defined by that name. For example, the [Date](#field.date)
header field is defined in [Section 6.6.1](#field.date) as containing the
origination timestamp for the message in which it appears.[¶](#section-5.1-1)

```
  field-name     = token

```
[¶](#section-5.1-2)

Field names are case-insensitive and ought to be registered within the
"Hypertext Transfer Protocol (HTTP) Field Name Registry"; see [Section 16.3.1](#fields.registry).[¶](#section-5.1-3)

The interpretation of a field does not change between minor
versions of the same major HTTP version, though the default behavior of a
recipient in the absence of such a field can change. Unless specified
otherwise, fields are defined for all versions of HTTP.
In particular, the [Host](#field.host) and [Connection](#field.connection)
fields ought to be recognized by all HTTP implementations
whether or not they advertise conformance with HTTP/1.1.[¶](#section-5.1-4)

New fields can be introduced without changing the protocol version if
their defined semantics allow them to be safely ignored by recipients
that do not recognize them; see [Section 16.3](#fields.extensibility).[¶](#section-5.1-5)

A proxy MUST forward unrecognized header fields unless the
field name is listed in the [Connection](#field.connection) header field
([Section 7.6.1](#field.connection)) or the proxy is specifically
configured to block, or otherwise transform, such fields.
Other recipients SHOULD ignore unrecognized header and trailer fields.
Adhering to these requirements allows HTTP's functionality to be extended
without updating or removing deployed intermediaries.[¶](#section-5.1-6)

### [5.2.](#section-5.2) [Field Lines and Combined Field Value](#name-field-lines-and-combined-fi)

Field sections are composed of any number of "field lines",
each with a "field name" (see [Section 5.1](#fields.names))
identifying the field, and a "field line value" that conveys
data for that instance of the field.[¶](#section-5.2-1)

When a field name is only present once in a section, the combined
"field value" for that field consists of the corresponding
field line value.
When a field name is repeated within a section, its combined field value
consists of the list of corresponding field line values within that section,
concatenated in order, with each field line value separated by a comma.[¶](#section-5.2-2)

For example, this section:[¶](#section-5.2-3)

```
Example-Field: Foo, Bar
Example-Field: Baz

```
[¶](#section-5.2-4)

contains two field lines, both with the field name "Example-Field". The
first field line has a field line value of "Foo, Bar", while the second
field line value is "Baz". The field value for "Example-Field" is the list
"Foo, Bar, Baz".[¶](#section-5.2-5)

### [5.3.](#section-5.3) [Field Order](#name-field-order)

A recipient MAY combine multiple field lines within a field section that
have the same field name
into one field line, without changing the semantics of the message, by
appending each subsequent field line value to the initial field line value
in order, separated by a comma (",") and optional whitespace
([OWS](#whitespace), defined in [Section 5.6.3](#whitespace)).
For consistency, use comma SP.[¶](#section-5.3-1)

The order in which field lines with the
same name are received is therefore significant to the interpretation of
the field value; a proxy MUST NOT change the order of these field line
values when forwarding a message.[¶](#section-5.3-2)

This means that, aside from the well-known exception noted below, a sender
MUST NOT generate multiple field lines with the same name in a message
(whether in the headers or trailers) or append a field line when a field
line of the same name already exists in the message, unless that field's
definition allows multiple field line values to be recombined as a
comma-separated list (i.e., at least one alternative of the field's
definition allows a comma-separated list, such as an ABNF rule of
#(values) defined in [Section 5.6.1](#abnf.extension)).[¶](#section-5.3-3)

**Note:** In practice, the "Set-Cookie" header field ([[COOKIE](#COOKIE)])
often appears in a response message across multiple field lines and does not
use the list syntax, violating the above requirements on multiple field lines
with the same field name. Since it cannot be combined into a single field
value, recipients ought to handle "Set-Cookie" as a special case while
processing fields. (See Appendix A.2.3 of [[Kri2001](#Kri2001)] for
details.)[¶](#section-5.3-4.1)

The order in which field lines with differing field names are received in a
section is not significant. However, it is good practice to send header
fields that contain additional control data first, such as
[Host](#field.host) on requests and [Date](#field.date) on responses, so
that implementations can decide when not to handle a message as early as
possible.[¶](#section-5.3-5)

A server MUST NOT apply a request to the target resource until it
receives the entire request header section, since later header field lines
might include conditionals, authentication credentials, or deliberately
misleading duplicate header fields that could impact request processing.[¶](#section-5.3-6)

### [5.4.](#section-5.4) [Field Limits](#name-field-limits)

HTTP does not place a predefined limit on the length of each field line, field value,
or on the length of a header or trailer section as a whole, as described in
[Section 2](#conformance). Various ad hoc limitations on individual
lengths are found in practice, often depending on the specific
field's semantics.[¶](#section-5.4-1)

A server that receives a request header field line, field value, or set of
fields larger than it wishes to process MUST respond with an appropriate
[4xx (Client Error)](#status.4xx) status code. Ignoring such header fields
would increase the server's vulnerability to request smuggling attacks
([Section 11.2](https://www.rfc-editor.org/rfc/rfc9112#section-11.2) of [[HTTP/1.1](#HTTP11)]).[¶](#section-5.4-2)

A client MAY discard or truncate received field lines that are larger
than the client wishes to process if the field semantics are such that the
dropped value(s) can be safely ignored without changing the
message framing or response semantics.[¶](#section-5.4-3)

### [5.5.](#section-5.5) [Field Values](#name-field-values)

HTTP field values consist of a sequence of characters in a format defined
by the field's grammar. Each field's grammar is usually defined using
ABNF ([[RFC5234](#RFC5234)]).[¶](#section-5.5-1)

```
  field-value    = *field-content
  field-content  = field-vchar
                   [ 1*( SP / HTAB / field-vchar ) field-vchar ]
  field-vchar    = VCHAR / obs-text
  obs-text       = %x80-FF

```
[¶](#section-5.5-2)

A field value does not include leading or trailing whitespace. When a
specific version of HTTP allows such whitespace to appear in a message,
a field parsing implementation MUST exclude such whitespace prior to
evaluating the field value.[¶](#section-5.5-3)

Field values are usually constrained to the range of US-ASCII characters
[[USASCII](#USASCII)].
Fields needing a greater range of characters can use an encoding,
such as the one defined in [[RFC8187](#RFC8187)].
Historically, HTTP allowed field content with text in the ISO-8859-1
charset [[ISO-8859-1](#ISO-8859-1)], supporting other charsets only
through use of [[RFC2047](#RFC2047)] encoding.
Specifications for newly defined fields SHOULD limit their values to
visible US-ASCII octets (VCHAR), SP, and HTAB.
A recipient SHOULD treat other allowed octets in field content
(i.e., [obs-text](#fields.values)) as opaque data.[¶](#section-5.5-4)

Field values containing CR, LF, or NUL characters are invalid and dangerous,
due to the varying ways that implementations might parse and interpret
those characters; a recipient of CR, LF, or NUL within a field value MUST
either reject the message or replace each of those characters with SP
before further processing or forwarding of that message. Field values
containing other CTL characters are also invalid; however,
recipients MAY retain such characters for the sake of robustness when
they appear within a safe context (e.g., an application-specific quoted
string that will not be processed by any downstream HTTP parser).[¶](#section-5.5-5)

Fields that only anticipate a single member as the field value are
referred to as "singleton fields".[¶](#section-5.5-6)

Fields that allow multiple members as the field value are referred to as
"list-based fields". The list operator extension of
[Section 5.6.1](#abnf.extension) is used as a common notation for defining
field values that can contain multiple members.[¶](#section-5.5-7)

Because commas (",") are used as the delimiter between members, they need
to be treated with care if they are allowed as data within a member. This
is true for both list-based and singleton fields, since a singleton field
might be erroneously sent with multiple members and detecting such errors
improves interoperability. Fields that expect to contain a
comma within a member, such as within an [HTTP-date](#http.date) or
[URI-reference](#uri.references)
element, ought to be defined with delimiters around that element to
distinguish any comma within that data from potential list separators.[¶](#section-5.5-8)

For example, a textual date and a URI (either of which might contain a comma)
could be safely carried in list-based field values like these:[¶](#section-5.5-9)

```
Example-URIs: "http://example.com/a.html,foo",
              "http://without-a-comma.example.com/"
Example-Dates: "Sat, 04 May 1996", "Wed, 14 Sep 2005"

```
[¶](#section-5.5-10)

Note that double-quote delimiters are almost always used with the
quoted-string production ([Section 5.6.4](#quoted.strings)); using a different syntax inside double-quotes
will likely cause unnecessary confusion.[¶](#section-5.5-11)

Many fields (such as [Content-Type](#field.content-type), defined in
[Section 8.3](#field.content-type)) use a common syntax for parameters
that allows both unquoted (token) and quoted (quoted-string) syntax for
a parameter value ([Section 5.6.6](#parameter)). Use of common syntax
allows recipients to reuse existing parser components. When allowing both
forms, the meaning of a parameter value ought to be the same whether it
was received as a token or a quoted string.[¶](#section-5.5-12)

**Note:** For defining field value syntax, this specification uses an ABNF
rule named after the field name to define the allowed grammar for that
field's value (after said value has been extracted from the underlying
messaging syntax and multiple instances combined into a list).[¶](#section-5.5-13.1)

### [5.6.](#section-5.6) [Common Rules for Defining Field Values](#name-common-rules-for-defining-f)

#### [5.6.1.](#section-5.6.1) [Lists (#rule ABNF Extension)](#name-lists-rule-abnf-extension)

A #rule extension to the ABNF rules of [[RFC5234](#RFC5234)] is used to
improve readability in the definitions of some list-based field values.[¶](#section-5.6.1-1)

A construct "#" is defined, similar to "\*", for defining comma-delimited
lists of elements. The full form is "<n>#<m>element" indicating
at least <n> and at most <m> elements, each separated by a single
comma (",") and optional whitespace ([OWS](#whitespace),
defined in [Section 5.6.3](#whitespace)).[¶](#section-5.6.1-2)

##### [5.6.1.1.](#section-5.6.1.1) [Sender Requirements](#name-sender-requirements)

In any production that uses the list construct, a sender MUST NOT
generate empty list elements. In other words, a sender has to generate
lists that satisfy the following syntax:[¶](#section-5.6.1.1-1)

```

  1#element => element *( OWS "," OWS element )

```
[¶](#section-5.6.1.1-2)

and:[¶](#section-5.6.1.1-3)

```

  #element => [ 1#element ]

```
[¶](#section-5.6.1.1-4)

and for n >= 1 and m > 1:[¶](#section-5.6.1.1-5)

```

  <n>#<m>element => element <n-1>*<m-1>( OWS "," OWS element )

```
[¶](#section-5.6.1.1-6)

[Appendix A](#collected.abnf) shows the collected ABNF for senders
after the list constructs have been expanded.[¶](#section-5.6.1.1-7)

##### [5.6.1.2.](#section-5.6.1.2) [Recipient Requirements](#name-recipient-requirements)

Empty elements do not contribute to the count of elements present.
A recipient MUST parse and ignore
a reasonable number of empty list elements: enough to handle common mistakes
by senders that merge values, but not so much that they could be used as a
denial-of-service mechanism. In other words, a recipient MUST accept lists
that satisfy the following syntax:[¶](#section-5.6.1.2-1)

```

  #element => [ element ] *( OWS "," OWS [ element ] )

```
[¶](#section-5.6.1.2-2)

Note that because of the potential presence of empty list elements, the
RFC 5234 ABNF cannot enforce the cardinality of list elements, and
consequently all cases are mapped as if there was no cardinality specified.[¶](#section-5.6.1.2-3)

For example, given these ABNF productions:[¶](#section-5.6.1.2-4)

```

  example-list      = 1#example-list-elmt
  example-list-elmt = token ; see Section 5.6.2

```
[¶](#section-5.6.1.2-5)

Then the following are valid values for example-list (not including the
double quotes, which are present for delimitation only):[¶](#section-5.6.1.2-6)

```

  "foo,bar"
  "foo ,bar,"
  "foo , ,bar,charlie"

```
[¶](#section-5.6.1.2-7)

In contrast, the following values would be invalid, since at least one
non-empty element is required by the example-list production:[¶](#section-5.6.1.2-8)

```

  ""
  ","
  ",   ,"

```
[¶](#section-5.6.1.2-9)

#### [5.6.2.](#section-5.6.2) [Tokens](#name-tokens)

Tokens are short textual identifiers that do not include whitespace or
delimiters.[¶](#section-5.6.2-1)

```
  token          = 1*tchar

  tchar          = "!" / "#" / "$" / "%" / "&" / "'" / "*"
                 / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
                 / DIGIT / ALPHA
                 ; any VCHAR, except delimiters

```
[¶](#section-5.6.2-2)

Many HTTP field values are defined using common syntax
components, separated by whitespace or specific delimiting characters.
Delimiters are chosen from the set of US-ASCII visual characters not
allowed in a [token](#rule.token.separators) (DQUOTE and "(),/:;<=>?@[\]{}").[¶](#section-5.6.2-3)

#### [5.6.3.](#section-5.6.3) [Whitespace](#name-whitespace)

This specification uses three rules to denote the use of linear
whitespace: OWS (optional whitespace), RWS (required whitespace), and
BWS ("bad" whitespace).[¶](#section-5.6.3-1)

The OWS rule is used where zero or more linear whitespace octets might
appear. For protocol elements where optional whitespace is preferred to
improve readability, a sender SHOULD generate the optional whitespace
as a single SP; otherwise, a sender SHOULD NOT generate optional
whitespace except as needed to overwrite invalid or unwanted protocol
elements during in-place message filtering.[¶](#section-5.6.3-2)

The RWS rule is used when at least one linear whitespace octet is required
to separate field tokens. A sender SHOULD generate RWS as a single SP.[¶](#section-5.6.3-3)

OWS and RWS have the same semantics as a single SP. Any content known to
be defined as OWS or RWS MAY be replaced with a single SP before
interpreting it or forwarding the message downstream.[¶](#section-5.6.3-4)

The BWS rule is used where the grammar allows optional whitespace only for
historical reasons. A sender MUST NOT generate BWS in messages.
A recipient MUST parse for such bad whitespace and remove it before
interpreting the protocol element.[¶](#section-5.6.3-5)

BWS has no semantics. Any content known to be
defined as BWS MAY be removed before interpreting it or forwarding the
message downstream.[¶](#section-5.6.3-6)

```
  OWS            = *( SP / HTAB )
                 ; optional whitespace
  RWS            = 1*( SP / HTAB )
                 ; required whitespace
  BWS            = OWS
                 ; "bad" whitespace

```
[¶](#section-5.6.3-7)

#### [5.6.4.](#section-5.6.4) [Quoted Strings](#name-quoted-strings)

A string of text is parsed as a single value if it is quoted using
double-quote marks.[¶](#section-5.6.4-1)

```
  quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
  qdtext         = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text

```
[¶](#section-5.6.4-2)

The backslash octet ("\") can be used as a single-octet
quoting mechanism within quoted-string and comment constructs.
Recipients that process the value of a quoted-string MUST handle a
quoted-pair as if it were replaced by the octet following the backslash.[¶](#section-5.6.4-3)

```
  quoted-pair    = "\" ( HTAB / SP / VCHAR / obs-text )

```
[¶](#section-5.6.4-4)

A sender SHOULD NOT generate a quoted-pair in a quoted-string except
where necessary to quote DQUOTE and backslash octets occurring within that
string.
A sender SHOULD NOT generate a quoted-pair in a comment except
where necessary to quote parentheses ["(" and ")"] and backslash octets
occurring within that comment.[¶](#section-5.6.4-5)

#### [5.6.5.](#section-5.6.5) [Comments](#name-comments)

Comments can be included in some HTTP fields by surrounding
the comment text with parentheses. Comments are only allowed in
fields containing "comment" as part of their field value definition.[¶](#section-5.6.5-1)

```
  comment        = "(" *( ctext / quoted-pair / comment ) ")"
  ctext          = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text

```
[¶](#section-5.6.5-2)

#### [5.6.6.](#section-5.6.6) [Parameters](#name-parameters)

Parameters are instances of name/value pairs; they are often used in field
values as a common syntax for appending auxiliary information to an item.
Each parameter is usually delimited by an immediately preceding semicolon.[¶](#section-5.6.6-1)

```
  parameters      = *( OWS ";" OWS [ parameter ] )
  parameter       = parameter-name "=" parameter-value
  parameter-name  = token
  parameter-value = ( token / quoted-string )

```
[¶](#section-5.6.6-2)

Parameter names are case-insensitive. Parameter values might or might
not be case-sensitive, depending on the semantics of the parameter
name. Examples of parameters and some equivalent forms can be seen in
media types ([Section 8.3.1](#media.type)) and the Accept header field
([Section 12.5.1](#field.accept)).[¶](#section-5.6.6-3)

A parameter value that matches the [token](#rule.token.separators) production can be
transmitted either as a token or within a quoted-string. The quoted and
unquoted values are equivalent.[¶](#section-5.6.6-4)

**Note:** Parameters do not allow whitespace (not even "bad" whitespace)
around the "=" character.[¶](#section-5.6.6-5.1)

#### [5.6.7.](#section-5.6.7) [Date/Time Formats](#name-date-time-formats)

Prior to 1995, there were three different formats commonly used by servers
to communicate timestamps. For compatibility with old implementations, all
three are defined here. The preferred format is a fixed-length and
single-zone subset of the date and time specification used by the
Internet Message Format [[RFC5322](#RFC5322)].[¶](#section-5.6.7-1)

```
  HTTP-date    = IMF-fixdate / obs-date

```
[¶](#section-5.6.7-2)

An example of the preferred format is[¶](#section-5.6.7-3)

```

  Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate

```
[¶](#section-5.6.7-4)

Examples of the two obsolete formats are[¶](#section-5.6.7-5)

```

  Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete RFC 850 format
  Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format

```
[¶](#section-5.6.7-6)

A recipient that parses a timestamp value in an HTTP field MUST
accept all three HTTP-date formats. When a sender generates a field
that contains one or more timestamps defined as HTTP-date,
the sender MUST generate those timestamps in the IMF-fixdate format.[¶](#section-5.6.7-7)

An HTTP-date value represents time as an instance of Coordinated
Universal Time (UTC). The first two formats indicate UTC by the
three-letter abbreviation for Greenwich Mean Time, "GMT", a predecessor
of the UTC name; values in the asctime format are assumed to be in UTC.[¶](#section-5.6.7-8)

A "clock" is an implementation capable of providing a
reasonable approximation of the current instant in UTC.
A clock implementation ought to use NTP ([[RFC5905](#RFC5905)]),
or some similar protocol, to synchronize with UTC.[¶](#section-5.6.7-9)

Preferred format:[¶](#section-5.6.7-10)

```
  IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
  ; fixed length/zone/capitalization subset of the format
  ; see Section 3.3 of [RFC5322]

  day-name     = %s"Mon" / %s"Tue" / %s"Wed"
               / %s"Thu" / %s"Fri" / %s"Sat" / %s"Sun"

  date1        = day SP month SP year
               ; e.g., 02 Jun 1982

  day          = 2DIGIT
  month        = %s"Jan" / %s"Feb" / %s"Mar" / %s"Apr"
               / %s"May" / %s"Jun" / %s"Jul" / %s"Aug"
               / %s"Sep" / %s"Oct" / %s"Nov" / %s"Dec"
  year         = 4DIGIT

  GMT          = %s"GMT"

  time-of-day  = hour ":" minute ":" second
               ; 00:00:00 - 23:59:60 (leap second)

  hour         = 2DIGIT
  minute       = 2DIGIT
  second       = 2DIGIT

```
[¶](#section-5.6.7-11)

Obsolete formats:[¶](#section-5.6.7-12)

```
  obs-date     = rfc850-date / asctime-date

```
[¶](#section-5.6.7-13)

```
  rfc850-date  = day-name-l "," SP date2 SP time-of-day SP GMT
  date2        = day "-" month "-" 2DIGIT
               ; e.g., 02-Jun-82

  day-name-l   = %s"Monday" / %s"Tuesday" / %s"Wednesday"
               / %s"Thursday" / %s"Friday" / %s"Saturday"
               / %s"Sunday"

```
[¶](#section-5.6.7-14)

```
  asctime-date = day-name SP date3 SP time-of-day SP year
  date3        = month SP ( 2DIGIT / ( SP 1DIGIT ))
               ; e.g., Jun  2

```
[¶](#section-5.6.7-15)

HTTP-date is case sensitive. Note that [Section 4.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.2) of [[CACHING](#CACHING)] relaxes this for cache recipients.[¶](#section-5.6.7-16)

A sender MUST NOT generate additional whitespace in an HTTP-date beyond
that specifically included as SP in the grammar.
The semantics of [day-name](#preferred.date.format), [day](#preferred.date.format),
[month](#preferred.date.format), [year](#preferred.date.format), and [time-of-day](#preferred.date.format)
are the same as those defined for the Internet Message Format constructs
with the corresponding name ([[RFC5322](#RFC5322)], [Section 3.3](https://www.rfc-editor.org/rfc/rfc5322#section-3.3)).[¶](#section-5.6.7-17)

Recipients of a timestamp value in rfc850-date format, which uses a
two-digit year, MUST interpret a timestamp that appears to be more
than 50 years in the future as representing the most recent year in the
past that had the same last two digits.[¶](#section-5.6.7-18)

Recipients of timestamp values are encouraged to be robust in parsing
timestamps unless otherwise restricted by the field definition.
For example, messages are occasionally forwarded over HTTP from a non-HTTP
source that might generate any of the date and time specifications defined
by the Internet Message Format.[¶](#section-5.6.7-19)

**Note:** HTTP requirements for timestamp formats apply only
to their usage within the protocol stream. Implementations are
not required to use these formats for user presentation, request
logging, etc.[¶](#section-5.6.7-20.1)

## [6.](#section-6) [Message Abstraction](#name-message-abstraction)

Each major version of HTTP defines its own syntax for communicating
messages. This section defines an abstract data type for HTTP messages
based on a generalization of those message characteristics, common structure,
and capacity for conveying semantics. This abstraction is used to define
requirements on senders and recipients that are independent of the HTTP
version, such that a message in one version can be relayed through other
versions without changing its meaning.[¶](#section-6-1)

A "message" consists of the following:[¶](#section-6-2)

* control data to describe and route the message,[¶](#section-6-3.1)
* a headers lookup table of name/value pairs for extending that control
  data and conveying additional information about the sender, message,
  content, or context,[¶](#section-6-3.2)
* a potentially unbounded stream of content, and[¶](#section-6-3.3)
* a trailers lookup table of name/value pairs for communicating information
  obtained while sending the content.[¶](#section-6-3.4)

Framing and control data is sent first, followed by a header section
containing fields for the headers table. When a message includes content,
the content is sent after the header section, potentially followed by a
trailer section that might contain fields for the trailers table.[¶](#section-6-4)

Messages are expected to be processed as a stream, wherein the purpose of
that stream and its continued processing is revealed while being read.
Hence, control data describes what the recipient needs to know immediately,
header fields describe what needs to be known before receiving content,
the content (when present) presumably contains what the recipient wants or
needs to fulfill the message semantics, and trailer fields provide
optional metadata that was unknown prior to sending the content.[¶](#section-6-5)

Messages are intended to be "self-descriptive":
everything a recipient needs to know about the message can be determined by
looking at the message itself, after decoding or reconstituting parts that
have been compressed or elided in transit, without requiring an
understanding of the sender's current application state (established via
prior messages). However, a client MUST retain knowledge of the request when
parsing, interpreting, or caching a corresponding response. For example,
responses to the [HEAD](#HEAD) method look just like the beginning of a
response to [GET](#GET) but cannot be parsed in the same manner.[¶](#section-6-6)

Note that this message abstraction is a generalization across many versions
of HTTP, including features that might not be found in some versions. For
example, trailers were introduced within the HTTP/1.1 chunked transfer
coding as a trailer section after the content. An equivalent feature is
present in HTTP/2 and HTTP/3 within the header block that terminates each
stream.[¶](#section-6-7)

### [6.1.](#section-6.1) [Framing and Completeness](#name-framing-and-completeness)

Message framing indicates how each message begins and ends, such that each
message can be distinguished from other messages or noise on the same
connection. Each major version of HTTP defines its own framing mechanism.[¶](#section-6.1-1)

HTTP/0.9 and early deployments of HTTP/1.0 used closure of the underlying
connection to end a response. For backwards compatibility, this implicit
framing is also allowed in HTTP/1.1. However, implicit framing can fail to
distinguish an incomplete response if the connection closes early. For
that reason, almost all modern implementations use explicit framing in
the form of length-delimited sequences of message data.[¶](#section-6.1-2)

A message is considered "complete" when all of the octets
indicated by its framing are available. Note that,
when no explicit framing is used, a response message that is ended
by the underlying connection's close is considered complete even though it
might be indistinguishable from an incomplete response, unless a
transport-level error indicates that it is not complete.[¶](#section-6.1-3)

### [6.2.](#section-6.2) [Control Data](#name-control-data)

Messages start with control data that describe its primary purpose. Request
message control data includes a request method ([Section 9](#methods)),
request target ([Section 7.1](#target.resource)), and protocol version
([Section 2.5](#protocol.version)). Response message control data includes
a status code ([Section 15](#status.codes)), optional reason phrase, and
protocol version.[¶](#section-6.2-1)

In HTTP/1.1 ([[HTTP/1.1](#HTTP11)]) and earlier, control data is sent
as the first line of a message. In HTTP/2 ([[HTTP/2](#HTTP2)]) and
HTTP/3 ([[HTTP/3](#HTTP3)]), control data is sent as pseudo-header
fields with a reserved name prefix (e.g., ":authority").[¶](#section-6.2-2)

Every HTTP message has a protocol version. Depending on the version in use,
it might be identified within the message explicitly or inferred by the
connection over which the message is received. Recipients use that version
information to determine limitations or potential for later communication
with that sender.[¶](#section-6.2-3)

When a message is forwarded by an intermediary, the protocol version is
updated to reflect the version used by that intermediary.
The [Via](#field.via) header field ([Section 7.6.3](#field.via)) is used to
communicate upstream protocol information within a forwarded message.[¶](#section-6.2-4)

A client SHOULD send a request version equal to the highest
version to which the client is conformant and
whose major version is no higher than the highest version supported
by the server, if this is known. A client MUST NOT send a
version to which it is not conformant.[¶](#section-6.2-5)

A client MAY send a lower request version if it is known that
the server incorrectly implements the HTTP specification, but only
after the client has attempted at least one normal request and determined
from the response status code or header fields (e.g., [Server](#field.server)) that
the server improperly handles higher request versions.[¶](#section-6.2-6)

A server SHOULD send a response version equal to the highest version to
which the server is conformant that has a major version less than or equal
to the one received in the request.
A server MUST NOT send a version to which it is not conformant.
A server can send a [505 (HTTP Version Not Supported)](#status.505)
response if it wishes, for any reason, to refuse service of the client's
major protocol version.[¶](#section-6.2-7)

A recipient that receives a message with a major version number that it
implements and a minor version number higher than what it implements
SHOULD process the message as if it
were in the highest minor version within that major version to which the
recipient is conformant. A recipient can assume that a message with a
higher minor version, when sent to a recipient that has not yet indicated
support for that higher version, is sufficiently backwards-compatible to be
safely processed by any implementation of the same major version.[¶](#section-6.2-8)

### [6.3.](#section-6.3) [Header Fields](#name-header-fields)

Fields ([Section 5](#fields)) that are sent or received before the content
are referred to as "header fields" (or just "headers", colloquially).[¶](#section-6.3-1)

The "header section" of a message consists of a sequence of
header field lines. Each header field might modify or extend message
semantics, describe the sender, define the content, or provide additional
context.[¶](#section-6.3-2)

**Note:** We refer to named fields specifically as a "header field" when they
are only allowed to be sent in the header section.[¶](#section-6.3-3.1)

### [6.4.](#section-6.4) [Content](#name-content)

HTTP messages often transfer a complete or partial representation as the
message "content": a stream of octets sent after the header
section, as delineated by the message framing.[¶](#section-6.4-1)

This abstract definition of content reflects the data after it has been
extracted from the message framing. For example, an HTTP/1.1 message body
([Section 6](https://www.rfc-editor.org/rfc/rfc9112#section-6) of [[HTTP/1.1](#HTTP11)]) might consist of a stream of data encoded
with the chunked transfer coding -- a sequence of data chunks, one
zero-length chunk, and a trailer section -- whereas
the content of that same message
includes only the data stream after the transfer coding has been decoded;
it does not include the chunk lengths, chunked framing syntax, nor the
trailer fields ([Section 6.5](#trailer.fields)).[¶](#section-6.4-2)

**Note:** Some field names have a "Content-" prefix. This is an informal
convention; while some of these fields refer to the content of the
message, as defined above, others are scoped to the selected representation
([Section 3.2](#representations)). See the individual field's
definition to disambiguate.[¶](#section-6.4-3.1)

#### [6.4.1.](#section-6.4.1) [Content Semantics](#name-content-semantics)

The purpose of content in a request is defined by the method semantics
([Section 9](#methods)).[¶](#section-6.4.1-1)

For example, a representation in the content of a PUT request
([Section 9.3.4](#PUT)) represents the desired state of the
[target resource](#target.resource) after the request is successfully applied,
whereas a representation in the content of a POST request
([Section 9.3.3](#POST)) represents information to be processed by the
target resource.[¶](#section-6.4.1-2)

In a response, the content's purpose is defined by the request method,
response status code ([Section 15](#status.codes)), and response
fields describing that content.
For example, the content of a [200 (OK)](#status.200) response to GET
([Section 9.3.1](#GET)) represents the current state of the
[target resource](#target.resource), as observed at the time of the message
origination date ([Section 6.6.1](#field.date)), whereas the content of
the same status code in a response to POST might represent either the
processing result or the new state of the target resource after applying
the processing.[¶](#section-6.4.1-3)

The content of a [206 (Partial Content)](#status.206) response to GET
contains either a single part of the selected representation or a
multipart message body containing multiple parts of that representation,
as described in [Section 15.3.7](#status.206).[¶](#section-6.4.1-4)

Response messages with an error status code usually contain content that
represents the error condition, such that the content describes the
error state and what steps are suggested for resolving it.[¶](#section-6.4.1-5)

Responses to the HEAD request method ([Section 9.3.2](#HEAD)) never include
content; the associated response header fields indicate only
what their values would have been if the request method had been GET
([Section 9.3.1](#GET)).[¶](#section-6.4.1-6)

[2xx (Successful)](#status.2xx) responses to a CONNECT request method
([Section 9.3.6](#CONNECT)) switch the connection to tunnel mode instead of
having content.[¶](#section-6.4.1-7)

All [1xx (Informational)](#status.1xx), [204 (No Content)](#status.204), and
[304 (Not Modified)](#status.304) responses do not include content.[¶](#section-6.4.1-8)

All other responses do include content, although that content
might be of zero length.[¶](#section-6.4.1-9)

#### [6.4.2.](#section-6.4.2) [Identifying Content](#name-identifying-content)

When a complete or partial representation is transferred as message
content, it is often desirable for the sender to supply, or the recipient
to determine, an identifier for a resource corresponding to that specific
representation. For example, a client making a GET request on a resource
for "the current weather report" might want an identifier specific to the
content returned (e.g., "weather report for Laguna Beach at 20210720T1711").
This can be useful for sharing or bookmarking content from resources that
are expected to have changing representations over time.[¶](#section-6.4.2-1)

For a request message:[¶](#section-6.4.2-2)

* If the request has a [Content-Location](#field.content-location) header field,
  then the sender asserts that the content is a representation of the
  resource identified by the Content-Location field value. However,
  such an assertion cannot be trusted unless it can be verified by
  other means (not defined by this specification). The information
  might still be useful for revision history links.[¶](#section-6.4.2-3.1)
* Otherwise, the content is unidentified by HTTP, but a more specific
  identifier might be supplied within the content itself.[¶](#section-6.4.2-3.2)

For a response message, the following rules are applied in order until a
match is found:[¶](#section-6.4.2-4)

1. If the request method is HEAD or the response status code is
   [204 (No Content)](#status.204) or [304 (Not Modified)](#status.304),
   there is no content in the response.[¶](#section-6.4.2-5.1)
2. If the request method is GET and the response status code is
   [200 (OK)](#status.200),
   the content is a representation of the [target resource](#target.resource) ([Section 7.1](#target.resource)).[¶](#section-6.4.2-5.2)
3. If the request method is GET and the response status code is
   [203 (Non-Authoritative Information)](#status.203), the content is
   a potentially modified or enhanced representation of the
   [target resource](#target.resource) as provided by an intermediary.[¶](#section-6.4.2-5.3)
4. If the request method is GET and the response status code is
   [206 (Partial Content)](#status.206),
   the content is one or more parts of a representation of the
   target resource.[¶](#section-6.4.2-5.4)
5. If the response has a [Content-Location](#field.content-location) header field
   and its field value is a reference to the same URI as the target URI,
   the content is a representation of the target resource.[¶](#section-6.4.2-5.5)
6. If the response has a [Content-Location](#field.content-location) header field
   and its field value is a reference to a URI different from the
   target URI, then the sender asserts that the content is a
   representation of the resource identified by the Content-Location
   field value. However, such an assertion cannot be trusted unless
   it can be verified by other means (not defined by this specification).[¶](#section-6.4.2-5.6)
7. Otherwise, the content is unidentified by HTTP, but a more specific
   identifier might be supplied within the content itself.[¶](#section-6.4.2-5.7)

### [6.5.](#section-6.5) [Trailer Fields](#name-trailer-fields)

Fields ([Section 5](#fields)) that are located within a
"trailer section" are referred to as "trailer fields"
(or just "trailers", colloquially).
Trailer fields can be useful for supplying message integrity checks, digital
signatures, delivery metrics, or post-processing status information.[¶](#section-6.5-1)

Trailer fields ought to be processed and stored separately from the fields
in the header section to avoid contradicting message semantics known at
the time the header section was complete. The presence or absence of
certain header fields might impact choices made for the routing or
processing of the message as a whole before the trailers are received;
those choices cannot be unmade by the later discovery of trailer fields.[¶](#section-6.5-2)

#### [6.5.1.](#section-6.5.1) [Limitations on Use of Trailers](#name-limitations-on-use-of-trail)

A trailer section is only possible when supported by the version
of HTTP in use and enabled by an explicit framing mechanism.
For example, the chunked transfer coding in HTTP/1.1 allows a trailer section to be
sent after the content ([Section 7.1.2](https://www.rfc-editor.org/rfc/rfc9112#section-7.1.2) of [[HTTP/1.1](#HTTP11)]).[¶](#section-6.5.1-1)

Many fields cannot be processed outside the header section because
their evaluation is necessary prior to receiving the content, such as
those that describe message framing, routing, authentication,
request modifiers, response controls, or content format.
A sender MUST NOT generate a trailer field unless the sender knows the
corresponding header field name's definition permits the field to be sent
in trailers.[¶](#section-6.5.1-2)

Trailer fields can be difficult to process by intermediaries that forward
messages from one protocol version to another. If the entire message can be
buffered in transit, some intermediaries could merge trailer fields into
the header section (as appropriate) before it is forwarded. However, in
most cases, the trailers are simply discarded.
A recipient MUST NOT merge a trailer field into a header section unless
the recipient understands the corresponding header field definition and
that definition explicitly permits and defines how trailer field values
can be safely merged.[¶](#section-6.5.1-3)

The presence of the keyword "trailers" in the TE header field ([Section 10.1.4](#field.te)) of a request indicates that the client is willing to
accept trailer fields, on behalf of itself and any downstream clients. For
requests from an intermediary, this implies that all
downstream clients are willing to accept trailer fields in the forwarded
response. Note that the presence of "trailers" does not mean that the
client(s) will process any particular trailer field in the response; only
that the trailer section(s) will not be dropped by any of the clients.[¶](#section-6.5.1-4)

Because of the potential for trailer fields to be discarded in transit, a
server SHOULD NOT generate trailer fields that it believes are necessary
for the user agent to receive.[¶](#section-6.5.1-5)

#### [6.5.2.](#section-6.5.2) [Processing Trailer Fields](#name-processing-trailer-fields)

The "Trailer" header field ([Section 6.6.2](#field.trailer)) can be sent
to indicate fields likely to be sent in the trailer section, which allows
recipients to prepare for their receipt before processing the content.
For example, this could be useful if a field name indicates that a dynamic
checksum should be calculated as the content is received and then
immediately checked upon receipt of the trailer field value.[¶](#section-6.5.2-1)

Like header fields, trailer fields with the same name are processed in the
order received; multiple trailer field lines with the same name have the
equivalent semantics as appending the multiple values as a list of members.
Trailer fields that might be generated more than once during a message
MUST be defined as a list-based field even if each member value is only
processed once per field line received.[¶](#section-6.5.2-2)

At the end of a message, a recipient MAY treat the set of received
trailer fields as a data structure of name/value pairs, similar to (but
separate from) the header fields. Additional processing expectations, if
any, can be defined within the field specification for a field intended
for use in trailers.[¶](#section-6.5.2-3)

### [6.6.](#section-6.6) [Message Metadata](#name-message-metadata)

Fields that describe the message itself, such as when and how the
message has been generated, can appear in both requests and responses.[¶](#section-6.6-1)

#### [6.6.1.](#section-6.6.1) [Date](#name-date)

The "Date" header field represents the date and time at which
the message was originated, having the same semantics as the Origination
Date Field (orig-date) defined in [Section 3.6.1](https://www.rfc-editor.org/rfc/rfc5322#section-3.6.1) of [[RFC5322](#RFC5322)].
The field value is an HTTP-date, as defined in [Section 5.6.7](#http.date).[¶](#section-6.6.1-1)

```
  Date = HTTP-date

```
[¶](#section-6.6.1-2)

An example is[¶](#section-6.6.1-3)

```
Date: Tue, 15 Nov 1994 08:12:31 GMT

```
[¶](#section-6.6.1-4)

A sender that generates a Date header field SHOULD generate its
field value as the best available approximation of the date and time of
message generation. In theory, the date ought to represent the moment just
before generating the message content. In practice, a sender can generate
the date value at any time during message origination.[¶](#section-6.6.1-5)

An origin server with a clock (as defined in
[Section 5.6.7](#http.date)) MUST generate a Date header field in
all [2xx (Successful)](#status.2xx), [3xx (Redirection)](#status.3xx),
and [4xx (Client Error)](#status.4xx) responses,
and MAY generate a Date header field in
[1xx (Informational)](#status.1xx) and
[5xx (Server Error)](#status.5xx) responses.[¶](#section-6.6.1-6)

An origin server without a clock MUST NOT generate a Date header field.[¶](#section-6.6.1-7)

A recipient with a clock that receives a response message without a Date
header field MUST record the time it was received and append a
corresponding Date header field to the message's header section if it is
cached or forwarded downstream.[¶](#section-6.6.1-8)

A recipient with a clock that receives a response with an invalid Date
header field value MAY replace that value with the time that
response was received.[¶](#section-6.6.1-9)

A user agent MAY send a Date header field in a request, though generally
will not do so unless it is believed to convey useful information to the
server. For example, custom applications of HTTP might convey a Date if
the server is expected to adjust its interpretation of the user's request
based on differences between the user agent and server clocks.[¶](#section-6.6.1-10)

#### [6.6.2.](#section-6.6.2) [Trailer](#name-trailer)

The "Trailer" header field provides a list of field names that the sender
anticipates sending as trailer fields within that message. This allows a
recipient to prepare for receipt of the indicated metadata before it starts
processing the content.[¶](#section-6.6.2-1)

```
  Trailer = #field-name

```
[¶](#section-6.6.2-2)

For example, a sender might indicate that a signature will
be computed as the content is being streamed and provide the final
signature as a trailer field. This allows a recipient to perform the same
check on the fly as it receives the content.[¶](#section-6.6.2-3)

A sender that intends to generate one or more trailer fields in a message
SHOULD generate a [Trailer](#field.trailer) header field in the header
section of that message to indicate which fields might be present in the
trailers.[¶](#section-6.6.2-4)

If an intermediary discards the trailer section in transit, the
[Trailer](#field.trailer) field could provide a hint of what metadata
was lost, though there is no guarantee that a sender of Trailer
will always follow through by sending the named fields.[¶](#section-6.6.2-5)

## [7.](#section-7) [Routing HTTP Messages](#name-routing-http-messages)

HTTP request message routing is determined by each client based on the
target resource, the client's proxy configuration, and
establishment or reuse of an inbound connection. The corresponding
response routing follows the same connection chain back to the client.[¶](#section-7-1)

### [7.1.](#section-7.1) [Determining the Target Resource](#name-determining-the-target-reso)

Although HTTP is used in a wide variety of applications, most clients rely
on the same resource identification mechanism and configuration techniques
as general-purpose Web browsers. Even when communication options are
hard-coded in a client's configuration, we can think of their combined
effect as a URI reference ([Section 4.1](#uri.references)).[¶](#section-7.1-1)

A URI reference is resolved to its absolute form in order to obtain the
"target URI". The target URI excludes the reference's
fragment component, if any, since fragment identifiers are reserved for
client-side processing ([[URI](#URI)], [Section 3.5](https://www.rfc-editor.org/rfc/rfc3986#section-3.5)).[¶](#section-7.1-2)

To perform an action on a "target resource", the client sends
a request message containing enough components of its parsed target URI to
enable recipients to identify that same resource. For historical reasons,
the parsed target URI components, collectively referred to as the
"request target", are sent within the message control data
and the [Host](#field.host) header field ([Section 7.2](#field.host)).[¶](#section-7.1-3)

There are two unusual cases for which the request target components are in
a method-specific form:[¶](#section-7.1-4)

* For CONNECT ([Section 9.3.6](#CONNECT)), the request target is the host
  name and port number of the tunnel destination, separated by a colon.[¶](#section-7.1-5.1)
* For OPTIONS ([Section 9.3.7](#OPTIONS)), the request target can be a
  single asterisk ("\*").[¶](#section-7.1-5.2)

See the respective method definitions for details. These forms MUST NOT
be used with other methods.[¶](#section-7.1-6)

Upon receipt of a client's request, a server reconstructs the target URI
from the received components in accordance with their local configuration
and incoming connection context. This reconstruction is specific to each
major protocol version. For example,
[Section 3.3](https://www.rfc-editor.org/rfc/rfc9112#section-3.3) of [[HTTP/1.1](#HTTP11)] defines how a server
determines the target URI of an HTTP/1.1 request.[¶](#section-7.1-7)

**Note:** Previous specifications defined the recomposed target URI as a
distinct concept, the "effective request URI".[¶](#section-7.1-8.1)

### [7.2.](#section-7.2) [Host and :authority](#name-host-and-authority)

The "Host" header field in a request provides the host and port
information from the target URI, enabling the origin
server to distinguish among resources while servicing requests
for multiple host names.[¶](#section-7.2-1)

In HTTP/2 [[HTTP/2](#HTTP2)] and HTTP/3 [[HTTP/3](#HTTP3)], the
Host header field is, in some cases, supplanted by the ":authority"
pseudo-header field of a request's control data.[¶](#section-7.2-2)

```
  Host = uri-host [ ":" port ] ; Section 4

```
[¶](#section-7.2-3)

The target URI's authority information is critical for handling a
request. A user agent MUST generate a Host header field in a request
unless it sends that information as an ":authority" pseudo-header field.
A user agent that sends Host SHOULD send it as the first field in the
header section of a request.[¶](#section-7.2-4)

For example, a GET request to the origin server for
<http://www.example.org/pub/WWW/> would begin with:[¶](#section-7.2-5)

```
GET /pub/WWW/ HTTP/1.1
Host: www.example.org

```
[¶](#section-7.2-6)

Since the host and port information acts as an application-level routing
mechanism, it is a frequent target for malware seeking to poison
a shared cache or redirect a request to an unintended server.
An interception proxy is particularly vulnerable if it relies on
the host and port information for redirecting requests to internal
servers, or for use as a cache key in a shared cache, without
first verifying that the intercepted connection is targeting a
valid IP address for that host.[¶](#section-7.2-7)

### [7.3.](#section-7.3) [Routing Inbound Requests](#name-routing-inbound-requests)

Once the target URI and its origin are determined, a client decides whether
a network request is necessary to accomplish the desired semantics and,
if so, where that request is to be directed.[¶](#section-7.3-1)

#### [7.3.1.](#section-7.3.1) [To a Cache](#name-to-a-cache)

If the client has a cache [[CACHING](#CACHING)] and the request can be
satisfied by it, then the request is
usually directed there first.[¶](#section-7.3.1-1)

#### [7.3.2.](#section-7.3.2) [To a Proxy](#name-to-a-proxy)

If the request is not satisfied by a cache, then a typical client will
check its configuration to determine whether a proxy is to be used to
satisfy the request. Proxy configuration is implementation-dependent,
but is often based on URI prefix matching, selective authority matching,
or both, and the proxy itself is usually identified by an "http" or
"https" URI.[¶](#section-7.3.2-1)

If an "http" or "https" proxy is applicable, the client connects
inbound by establishing (or reusing) a connection to that proxy and
then sending it an HTTP request message containing a request target
that matches the client's target URI.[¶](#section-7.3.2-2)

#### [7.3.3.](#section-7.3.3) [To the Origin](#name-to-the-origin)

If no proxy is applicable, a typical client will invoke a handler
routine (specific to the target URI's scheme) to obtain access to the
identified resource. How that is accomplished is dependent on the
target URI scheme and defined by its associated specification.[¶](#section-7.3.3-1)

[Section 4.3.2](#http.origin) defines how to obtain access to an
"http" resource by establishing (or reusing) an inbound connection to
the identified origin server and then sending it an HTTP request message
containing a request target that matches the client's target URI.[¶](#section-7.3.3-2)

[Section 4.3.3](#https.origin) defines how to obtain access to an
"https" resource by establishing (or reusing) an inbound secured
connection to an origin server that is authoritative for the identified
origin and then sending it an HTTP request message containing a request
target that matches the client's target URI.[¶](#section-7.3.3-3)

### [7.4.](#section-7.4) [Rejecting Misdirected Requests](#name-rejecting-misdirected-reque)

Once a request is received by a server and parsed sufficiently to determine
its target URI, the server decides whether to process the request itself,
forward the request to another server, redirect the client to a different
resource, respond with an error, or drop the connection. This decision can
be influenced by anything about the request or connection context, but is
specifically directed at whether the server has been configured to process
requests for that target URI and whether the connection context is
appropriate for that request.[¶](#section-7.4-1)

For example, a request might have been misdirected,
deliberately or accidentally, such that the information within a received
[Host](#field.host) header field differs from the connection's host or port.
If the connection is from a trusted gateway, such inconsistency might
be expected; otherwise, it might indicate an attempt to bypass security
filters, trick the server into delivering non-public content, or poison a
cache. See [Section 17](#security.considerations) for security
considerations regarding message routing.[¶](#section-7.4-2)

Unless the connection is from a trusted gateway,
an origin server MUST reject a request if any scheme-specific requirements
for the target URI are not met. In particular,
a request for an "https" resource MUST be rejected unless it has been
received over a connection that has been secured via a certificate
valid for that target URI's origin, as defined by [Section 4.2.2](#https.uri).[¶](#section-7.4-3)

The [421 (Misdirected Request)](#status.421) status code in a response
indicates that the origin server has rejected the request because it
appears to have been misdirected ([Section 15.5.20](#status.421)).[¶](#section-7.4-4)

### [7.5.](#section-7.5) [Response Correlation](#name-response-correlation)

A connection might be used for multiple request/response exchanges. The
mechanism used to correlate between request and response messages is
version dependent; some versions of HTTP use implicit ordering of
messages, while others use an explicit identifier.[¶](#section-7.5-1)

All responses, regardless of the status code (including [interim](#final.interim)
responses) can be sent at any time after a request is received, even if the
request is not yet complete. A response can complete before its
corresponding request is complete ([Section 6.1](#message.framing)). Likewise, clients are not expected
to wait any specific amount of time for a response. Clients
(including intermediaries) might abandon a request if the response is not
received within a reasonable period of time.[¶](#section-7.5-2)

A client that receives a response while it is still sending the associated
request SHOULD continue sending that request unless it receives
an explicit indication to the contrary (see, e.g., [Section 9.5](https://www.rfc-editor.org/rfc/rfc9112#section-9.5) of [[HTTP/1.1](#HTTP11)] and [Section 6.4](https://www.rfc-editor.org/rfc/rfc9113#section-6.4) of [[HTTP/2](#HTTP2)]).[¶](#section-7.5-3)

### [7.6.](#section-7.6) [Message Forwarding](#name-message-forwarding)

As described in [Section 3.7](#intermediaries), intermediaries can serve
a variety of roles in the processing of HTTP requests and responses.
Some intermediaries are used to improve performance or availability.
Others are used for access control or to filter content.
Since an HTTP stream has characteristics similar to a pipe-and-filter
architecture, there are no inherent limits to the extent an intermediary
can enhance (or interfere) with either direction of the stream.[¶](#section-7.6-1)

Intermediaries are expected to forward messages even when protocol elements
are not recognized (e.g., new methods, status codes, or field names) since that
preserves extensibility for downstream recipients.[¶](#section-7.6-2)

An intermediary not acting as a tunnel MUST implement the
[Connection](#field.connection) header field, as specified in
[Section 7.6.1](#field.connection), and exclude fields from being forwarded
that are only intended for the incoming connection.[¶](#section-7.6-3)

An intermediary MUST NOT forward a message to itself unless it is
protected from an infinite request loop. In general, an intermediary ought
to recognize its own server names, including any aliases, local variations,
or literal IP addresses, and respond to such requests directly.[¶](#section-7.6-4)

An HTTP message can be parsed as a stream for incremental processing or
forwarding downstream.
However, senders and recipients cannot rely on incremental
delivery of partial messages, since some implementations will buffer or
delay message forwarding for the sake of network efficiency, security
checks, or content transformations.[¶](#section-7.6-5)

#### [7.6.1.](#section-7.6.1) [Connection](#name-connection)

The "Connection" header field allows the sender to list desired
control options for the current connection.[¶](#section-7.6.1-1)

```
  Connection        = #connection-option
  connection-option = token

```
[¶](#section-7.6.1-2)

Connection options are case-insensitive.[¶](#section-7.6.1-3)

When a field aside from Connection is used to supply control
information for or about the current connection, the sender MUST list
the corresponding field name within the Connection header field.
Note that some versions of HTTP prohibit the use of fields for such
information, and therefore do not allow the Connection field.[¶](#section-7.6.1-4)

Intermediaries MUST parse a received Connection
header field before a message is forwarded and, for each
connection-option in this field, remove any header or trailer field(s) from
the message with the same name as the connection-option, and then
remove the Connection header field itself (or replace it with the
intermediary's own control options for the forwarded message).[¶](#section-7.6.1-5)

Hence, the Connection header field provides a declarative way of
distinguishing fields that are only intended for the
immediate recipient ("hop-by-hop") from those fields that are
intended for all recipients on the chain ("end-to-end"), enabling the
message to be self-descriptive and allowing future connection-specific
extensions to be deployed without fear that they will be blindly
forwarded by older intermediaries.[¶](#section-7.6.1-6)

Furthermore, intermediaries SHOULD remove or replace fields
that are known to require removal before forwarding, whether or not they appear as a
connection-option, after applying those fields' semantics. This includes but is not limited to:[¶](#section-7.6.1-7)

* Proxy-Connection ([Appendix C.2.2](https://www.rfc-editor.org/rfc/rfc9112#appendix-C.2.2) of [[HTTP/1.1](#HTTP11)])[¶](#section-7.6.1-8.1)
* Keep-Alive ([Section 19.7.1](https://www.rfc-editor.org/rfc/rfc2068#section-19.7.1) of [[RFC2068](#RFC2068)])[¶](#section-7.6.1-8.2)
* TE ([Section 10.1.4](#field.te))[¶](#section-7.6.1-8.3)
* Transfer-Encoding ([Section 6.1](https://www.rfc-editor.org/rfc/rfc9112#section-6.1) of [[HTTP/1.1](#HTTP11)])[¶](#section-7.6.1-8.4)
* Upgrade ([Section 7.8](#field.upgrade))[¶](#section-7.6.1-8.5)

A sender MUST NOT send a connection option corresponding to a
field that is intended for all recipients of the content.
For example, Cache-Control is never appropriate as a
connection option ([Section 5.2](https://www.rfc-editor.org/rfc/rfc9111#section-5.2) of [[CACHING](#CACHING)]).[¶](#section-7.6.1-9)

Connection options do not always correspond to a field
present in the message, since a connection-specific field
might not be needed if there are no parameters associated with a
connection option. In contrast, a connection-specific field
received without a corresponding connection option usually indicates
that the field has been improperly forwarded by an intermediary and
ought to be ignored by the recipient.[¶](#section-7.6.1-10)

When defining a new connection option that does not correspond to a field,
specification authors ought to reserve the corresponding field name
anyway in order to avoid later collisions. Such reserved field names are
registered in the "Hypertext Transfer Protocol (HTTP) Field Name Registry"
([Section 16.3.1](#fields.registry)).[¶](#section-7.6.1-11)

#### [7.6.2.](#section-7.6.2) [Max-Forwards](#name-max-forwards)

The "Max-Forwards" header field provides a mechanism with the
TRACE ([Section 9.3.8](#TRACE)) and OPTIONS ([Section 9.3.7](#OPTIONS))
request methods to limit the number of times that the request is forwarded by
proxies. This can be useful when the client is attempting to
trace a request that appears to be failing or looping mid-chain.[¶](#section-7.6.2-1)

```
  Max-Forwards = 1*DIGIT

```
[¶](#section-7.6.2-2)

The Max-Forwards value is a decimal integer indicating the remaining
number of times this request message can be forwarded.[¶](#section-7.6.2-3)

Each intermediary that receives a TRACE or OPTIONS request containing a
Max-Forwards header field MUST check and update its value prior to
forwarding the request. If the received value is zero (0), the intermediary
MUST NOT forward the request; instead, the intermediary MUST respond as
the final recipient. If the received Max-Forwards value is greater than
zero, the intermediary MUST generate an updated Max-Forwards field in the
forwarded message with a field value that is the lesser of a) the received
value decremented by one (1) or b) the recipient's maximum supported value
for Max-Forwards.[¶](#section-7.6.2-4)

A recipient MAY ignore a Max-Forwards header field received with any
other request methods.[¶](#section-7.6.2-5)

#### [7.6.3.](#section-7.6.3) [Via](#name-via)

The "Via" header field indicates the presence of intermediate protocols and
recipients between the user agent and the server (on requests) or between
the origin server and the client (on responses), similar to the
"Received" header field in email
([Section 3.6.7](https://www.rfc-editor.org/rfc/rfc5322#section-3.6.7) of [[RFC5322](#RFC5322)]).
Via can be used for tracking message forwards,
avoiding request loops, and identifying the protocol capabilities of
senders along the request/response chain.[¶](#section-7.6.3-1)

```
  Via = #( received-protocol RWS received-by [ RWS comment ] )

  received-protocol = [ protocol-name "/" ] protocol-version
                    ; see Section 7.8
  received-by       = pseudonym [ ":" port ]
  pseudonym         = token

```
[¶](#section-7.6.3-2)

Each member of the Via field value represents a proxy or gateway that has
forwarded the message. Each intermediary appends its own information
about how the message was received, such that the end result is ordered
according to the sequence of forwarding recipients.[¶](#section-7.6.3-3)

A proxy MUST send an appropriate Via header field, as described below, in
each message that it forwards.
An HTTP-to-HTTP gateway MUST send an appropriate Via header field in
each inbound request message and MAY send a Via header field in
forwarded response messages.[¶](#section-7.6.3-4)

For each intermediary, the received-protocol indicates the protocol and
protocol version used by the upstream sender of the message. Hence, the
Via field value records the advertised protocol capabilities of the
request/response chain such that they remain visible to downstream
recipients; this can be useful for determining what backwards-incompatible
features might be safe to use in response, or within a later request, as
described in [Section 2.5](#protocol.version). For brevity, the protocol-name
is omitted when the received protocol is HTTP.[¶](#section-7.6.3-5)

The received-by portion is normally the host and optional
port number of a recipient server or client that subsequently forwarded the
message.
However, if the real host is considered to be sensitive information, a
sender MAY replace it with a pseudonym. If a port is not provided,
a recipient MAY interpret that as meaning it was received on the default
port, if any, for the received-protocol.[¶](#section-7.6.3-6)

A sender MAY generate comments to identify the
software of each recipient, analogous to the [User-Agent](#field.user-agent) and
[Server](#field.server) header fields. However, comments in Via
are optional, and a recipient MAY remove them prior to forwarding the
message.[¶](#section-7.6.3-7)

For example, a request message could be sent from an HTTP/1.0 user
agent to an internal proxy code-named "fred", which uses HTTP/1.1 to
forward the request to a public proxy at p.example.net, which completes
the request by forwarding it to the origin server at www.example.com.
The request received by www.example.com would then have the following
Via header field:[¶](#section-7.6.3-8)

```
Via: 1.0 fred, 1.1 p.example.net

```
[¶](#section-7.6.3-9)

An intermediary used as a portal through a network firewall
SHOULD NOT forward the names and ports of hosts within the firewall
region unless it is explicitly enabled to do so. If not enabled, such an
intermediary SHOULD replace each received-by host of any host behind the
firewall by an appropriate pseudonym for that host.[¶](#section-7.6.3-10)

An intermediary MAY combine an ordered subsequence of Via header
field list members into a single member if the entries have identical
received-protocol values. For example,[¶](#section-7.6.3-11)

```
Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

```
[¶](#section-7.6.3-12)

could be collapsed to[¶](#section-7.6.3-13)

```
Via: 1.0 ricky, 1.1 mertz, 1.0 lucy

```
[¶](#section-7.6.3-14)

A sender SHOULD NOT combine multiple list members unless they are all
under the same organizational control and the hosts have already been
replaced by pseudonyms. A sender MUST NOT combine members that
have different received-protocol values.[¶](#section-7.6.3-15)

### [7.7.](#section-7.7) [Message Transformations](#name-message-transformations)

Some intermediaries include features for transforming messages and their
content. A proxy might, for example, convert between image formats in
order to save cache space or to reduce the amount of traffic on a slow
link. However, operational problems might occur when these transformations
are applied to content intended for critical applications, such as medical
imaging or scientific data analysis, particularly when integrity checks or
digital signatures are used to ensure that the content received is
identical to the original.[¶](#section-7.7-1)

An HTTP-to-HTTP proxy is called a "transforming proxy"
if it is designed or configured to modify messages in a semantically
meaningful way (i.e., modifications, beyond those required by normal
HTTP processing, that change the message in a way that would be
significant to the original sender or potentially significant to
downstream recipients). For example, a transforming proxy might be
acting as a shared annotation server (modifying responses to include
references to a local annotation database), a malware filter, a
format transcoder, or a privacy filter. Such transformations are presumed
to be desired by whichever client (or client organization) chose the
proxy.[¶](#section-7.7-2)

If a proxy receives a target URI with a host name that is not a
fully qualified domain name, it MAY add its own domain to the host name
it received when forwarding the request. A proxy MUST NOT change the
host name if the target URI contains a fully qualified domain name.[¶](#section-7.7-3)

A proxy MUST NOT modify the "absolute-path" and "query" parts of the
received target URI when forwarding it to the next inbound server except
as required by that forwarding protocol. For example, a proxy forwarding
a request to an origin server via HTTP/1.1 will replace an empty path with
"/" ([Section 3.2.1](https://www.rfc-editor.org/rfc/rfc9112#section-3.2.1) of [[HTTP/1.1](#HTTP11)]) or "\*" ([Section 3.2.4](https://www.rfc-editor.org/rfc/rfc9112#section-3.2.4) of [[HTTP/1.1](#HTTP11)]),
depending on the request method.[¶](#section-7.7-4)

A proxy MUST NOT transform the content ([Section 6.4](#content)) of a
response message that contains a no-transform cache directive
([Section 5.2.2.6](https://www.rfc-editor.org/rfc/rfc9111#section-5.2.2.6) of [[CACHING](#CACHING)]). Note that this
does not apply to message transformations that do not change the content,
such as the addition or removal of transfer codings
([Section 7](https://www.rfc-editor.org/rfc/rfc9112#section-7) of [[HTTP/1.1](#HTTP11)]).[¶](#section-7.7-5)

A proxy MAY transform the content of a message
that does not contain a no-transform cache directive.
A proxy that transforms the content of a [200 (OK)](#status.200) response
can inform downstream recipients that a transformation has been
applied by changing the response status code to
[203 (Non-Authoritative Information)](#status.203) ([Section 15.3.4](#status.203)).[¶](#section-7.7-6)

A proxy SHOULD NOT modify header fields that provide information about
the endpoints of the communication chain, the resource state, or the
[selected representation](#selected.representation) (other than the content) unless the field's
definition specifically allows such modification or the modification is
deemed necessary for privacy or security.[¶](#section-7.7-7)

### [7.8.](#section-7.8) [Upgrade](#name-upgrade)

The "Upgrade" header field is intended to provide a simple mechanism
for transitioning from HTTP/1.1 to some other protocol on the same
connection.[¶](#section-7.8-1)

A client MAY send a list of protocol names in the Upgrade header field
of a request to invite the server to switch to one or more of the named
protocols, in order of descending preference, before sending
the final response. A server MAY ignore a received Upgrade header field
if it wishes to continue using the current protocol on that connection.
Upgrade cannot be used to insist on a protocol change.[¶](#section-7.8-2)

```
  Upgrade          = #protocol

  protocol         = protocol-name ["/" protocol-version]
  protocol-name    = token
  protocol-version = token

```
[¶](#section-7.8-3)

Although protocol names are registered with a preferred case,
recipients SHOULD use case-insensitive comparison when matching each
protocol-name to supported protocols.[¶](#section-7.8-4)

A server that sends a [101 (Switching Protocols)](#status.101) response
MUST send an Upgrade header field to indicate the new protocol(s) to
which the connection is being switched; if multiple protocol layers are
being switched, the sender MUST list the protocols in layer-ascending
order. A server MUST NOT switch to a protocol that was not indicated by
the client in the corresponding request's Upgrade header field.
A server MAY choose to ignore the order of preference indicated by the
client and select the new protocol(s) based on other factors, such as the
nature of the request or the current load on the server.[¶](#section-7.8-5)

A server that sends a [426 (Upgrade Required)](#status.426) response
MUST send an Upgrade header field to indicate the acceptable protocols,
in order of descending preference.[¶](#section-7.8-6)

A server MAY send an Upgrade header field in any other response to
advertise that it implements support for upgrading to the listed protocols,
in order of descending preference, when appropriate for a future request.[¶](#section-7.8-7)

The following is a hypothetical example sent by a client:[¶](#section-7.8-8)

```
GET /hello HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: websocket, IRC/6.9, RTA/x11

```
[¶](#section-7.8-9)

The capabilities and nature of the
application-level communication after the protocol change is entirely
dependent upon the new protocol(s) chosen. However, immediately after
sending the [101 (Switching Protocols)](#status.101) response, the server is expected to continue responding to
the original request as if it had received its equivalent within the new
protocol (i.e., the server still has an outstanding request to satisfy
after the protocol has been changed, and is expected to do so without
requiring the request to be repeated).[¶](#section-7.8-10)

For example, if the Upgrade header field is received in a GET request
and the server decides to switch protocols, it first responds
with a [101 (Switching Protocols)](#status.101) message in HTTP/1.1 and
then immediately follows that with the new protocol's equivalent of a
response to a GET on the target resource. This allows a connection to be
upgraded to protocols with the same semantics as HTTP without the
latency cost of an additional round trip. A server MUST NOT switch
protocols unless the received message semantics can be honored by the new
protocol; an OPTIONS request can be honored by any protocol.[¶](#section-7.8-11)

The following is an example response to the above hypothetical request:[¶](#section-7.8-12)

```
HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: websocket

[... data stream switches to websocket with an appropriate response
(as defined by new protocol) to the "GET /hello" request ...]

```
[¶](#section-7.8-13)

A sender of Upgrade MUST also send an "Upgrade" connection option in the
[Connection](#field.connection) header field ([Section 7.6.1](#field.connection))
to inform intermediaries not to forward this field.
A server that receives an Upgrade header field in an HTTP/1.0 request
MUST ignore that Upgrade field.[¶](#section-7.8-14)

A client cannot begin using an upgraded protocol on the connection until
it has completely sent the request message (i.e., the client can't change
the protocol it is sending in the middle of a message).
If a server receives both an Upgrade and an [Expect](#field.expect) header field
with the "100-continue" expectation ([Section 10.1.1](#field.expect)), the
server MUST send a [100 (Continue)](#status.100) response before sending
a [101 (Switching Protocols)](#status.101) response.[¶](#section-7.8-15)

The Upgrade header field only applies to switching protocols on top of the
existing connection; it cannot be used to switch the underlying connection
(transport) protocol, nor to switch the existing communication to a
different connection. For those purposes, it is more appropriate to use a
[3xx (Redirection)](#status.3xx) response ([Section 15.4](#status.3xx)).[¶](#section-7.8-16)

This specification only defines the protocol name "HTTP" for use by
the family of Hypertext Transfer Protocols, as defined by the HTTP
version rules of [Section 2.5](#protocol.version) and future updates to this
specification. Additional protocol names ought to be registered using the
registration procedure defined in [Section 16.7](#upgrade.token.registry).[¶](#section-7.8-17)

## [8.](#section-8) [Representation Data and Metadata](#name-representation-data-and-met)

### [8.1.](#section-8.1) [Representation Data](#name-representation-data)

The representation data associated with an HTTP message is
either provided as the content of the message or
referred to by the message semantics and the target
URI. The representation data is in a format and encoding defined by
the representation metadata header fields.[¶](#section-8.1-1)

The data type of the representation data is determined via the header fields
[Content-Type](#field.content-type) and [Content-Encoding](#field.content-encoding).
These define a two-layer, ordered encoding model:[¶](#section-8.1-2)

```

  representation-data := Content-Encoding( Content-Type( data ) )

```
[¶](#section-8.1-3)

### [8.2.](#section-8.2) [Representation Metadata](#name-representation-metadata)

Representation header fields provide metadata about the representation.
When a message includes content, the representation header fields
describe how to interpret that data. In a response to a HEAD request, the
representation header fields describe the representation data that would
have been enclosed in the content if the same request had been a GET.[¶](#section-8.2-1)

### [8.3.](#section-8.3) [Content-Type](#name-content-type)

The "Content-Type" header field indicates the media type of the
associated representation: either the representation enclosed in
the message content or the [selected representation](#selected.representation), as determined by the
message semantics. The indicated media type defines both the data format
and how that data is intended to be processed by a recipient, within the
scope of the received message semantics, after any content codings
indicated by [Content-Encoding](#field.content-encoding) are decoded.[¶](#section-8.3-1)

```
  Content-Type = media-type

```
[¶](#section-8.3-2)

Media types are defined in [Section 8.3.1](#media.type). An example of the
field is[¶](#section-8.3-3)

```
Content-Type: text/html; charset=ISO-8859-4

```
[¶](#section-8.3-4)

A sender that generates a message containing content SHOULD
generate a Content-Type header field in that message unless the intended
media type of the enclosed representation is unknown to the sender.
If a Content-Type header field is not present, the recipient MAY either
assume a media type of
"application/octet-stream" ([[RFC2046](#RFC2046)], [Section 4.5.1](https://www.rfc-editor.org/rfc/rfc2046#section-4.5.1))
or examine the data to determine its type.[¶](#section-8.3-5)

In practice, resource owners do not always properly configure their origin
server to provide the correct Content-Type for a given representation.
Some user agents examine the content and, in certain cases,
override the received type (for example, see [[Sniffing](#Sniffing)]).
This "MIME sniffing" risks drawing incorrect conclusions about the data,
which might expose the user to additional security risks
(e.g., "privilege escalation").
Furthermore, distinct media types often share a common data format,
differing only in how the data is intended to be processed, which is
impossible to distinguish by inspecting the data alone.
When sniffing is implemented, implementers are encouraged to provide a
means for the user to disable it.[¶](#section-8.3-6)

Although Content-Type is defined as a singleton field, it is
sometimes incorrectly generated multiple times, resulting in a combined
field value that appears to be a list.
Recipients often attempt to handle this error by using the last
syntactically valid member of the list, leading to potential
interoperability and security issues if different implementations
have different error handling behaviors.[¶](#section-8.3-7)

#### [8.3.1.](#section-8.3.1) [Media Type](#name-media-type)

HTTP uses media types [[RFC2046](#RFC2046)] in the
[Content-Type](#field.content-type) ([Section 8.3](#field.content-type))
and [Accept](#field.accept) ([Section 12.5.1](#field.accept)) header fields in
order to provide open and extensible data typing and type negotiation.
Media types define both a data format and various processing models:
how to process that data in accordance with the message context.[¶](#section-8.3.1-1)

```
  media-type = type "/" subtype parameters
  type       = token
  subtype    = token

```
[¶](#section-8.3.1-2)

The type and subtype tokens are case-insensitive.[¶](#section-8.3.1-3)

The type/subtype MAY be followed by semicolon-delimited parameters
([Section 5.6.6](#parameter)) in the form of name/value pairs.
The presence or absence of a parameter might be significant to the
processing of a media type, depending on its definition within the media
type registry.
Parameter values might or might not be case-sensitive, depending on the
semantics of the parameter name.[¶](#section-8.3.1-4)

For example, the following media types are equivalent in describing HTML
text data encoded in the UTF-8 character encoding scheme, but the first is
preferred for consistency (the "charset" parameter value is defined as
being case-insensitive in [[RFC2046](#RFC2046)], [Section 4.1.2](https://www.rfc-editor.org/rfc/rfc2046#section-4.1.2)):[¶](#section-8.3.1-5)

```

  text/html;charset=utf-8
  Text/HTML;Charset="utf-8"
  text/html; charset="utf-8"
  text/html;charset=UTF-8

```
[¶](#section-8.3.1-6)

Media types ought to be registered with IANA according to the
procedures defined in [[BCP13](#BCP13)].[¶](#section-8.3.1-7)

#### [8.3.2.](#section-8.3.2) [Charset](#name-charset)

HTTP uses "charset" names to indicate or negotiate the
character encoding scheme ([[RFC6365](#RFC6365)], [Section 2](https://www.rfc-editor.org/rfc/rfc6365#section-2))
of a textual representation. In the fields defined by this document,
charset names appear either in parameters ([Content-Type](#field.content-type)),
or, for [Accept-Encoding](#field.accept-encoding), in the form of a plain [token](#rule.token.separators).
In both cases, charset names are matched case-insensitively.[¶](#section-8.3.2-1)

Charset names ought to be registered in the IANA "Character Sets" registry
(<<https://www.iana.org/assignments/character-sets>>)
according to the procedures defined in [Section 2](https://www.rfc-editor.org/rfc/rfc2978#section-2) of [[RFC2978](#RFC2978)].[¶](#section-8.3.2-2)

**Note:** In theory, charset names are defined by the "mime-charset" ABNF
rule defined in [Section 2.3](https://www.rfc-editor.org/rfc/rfc2978#section-2.3) of [[RFC2978](#RFC2978)] (as
corrected in [[Err1912](#Err1912)]). That rule allows two characters
that are not included in "token" ("{" and "}"), but no charset name
registered at the time of this writing includes braces
(see [[Err5433](#Err5433)]).[¶](#section-8.3.2-3.1)

#### [8.3.3.](#section-8.3.3) [Multipart Types](#name-multipart-types)

MIME provides for a number of "multipart" types -- encapsulations of
one or more representations within a single message body. All multipart
types share a common syntax, as defined in [Section 5.1.1](https://www.rfc-editor.org/rfc/rfc2046#section-5.1.1) of [[RFC2046](#RFC2046)],
and include a boundary parameter as part of the media type
value. The message body is itself a protocol element; a sender MUST
generate only CRLF to represent line breaks between body parts.[¶](#section-8.3.3-1)

HTTP message framing does not use the multipart boundary as an indicator
of message body length, though it might be used by implementations that
generate or process the content. For example, the "multipart/form-data"
type is often used for carrying form data in a request, as described in
[[RFC7578](#RFC7578)], and the "multipart/byteranges" type is defined
by this specification for use in some [206 (Partial Content)](#status.206)
responses (see [Section 15.3.7](#status.206)).[¶](#section-8.3.3-2)

### [8.4.](#section-8.4) [Content-Encoding](#name-content-encoding)

The "Content-Encoding" header field indicates what content codings
have been applied to the representation, beyond those inherent in the media
type, and thus what decoding mechanisms have to be applied in order to
obtain data in the media type referenced by the [Content-Type](#field.content-type)
header field.
Content-Encoding is primarily used to allow a representation's data to be
compressed without losing the identity of its underlying media type.[¶](#section-8.4-1)

```
  Content-Encoding = #content-coding

```
[¶](#section-8.4-2)

An example of its use is[¶](#section-8.4-3)

```
Content-Encoding: gzip

```
[¶](#section-8.4-4)

If one or more encodings have been applied to a representation, the sender
that applied the encodings MUST generate a Content-Encoding header field
that lists the content codings in the order in which they were applied.
Note that the coding named "identity" is reserved for its special role
in [Accept-Encoding](#field.accept-encoding) and thus SHOULD NOT be included.[¶](#section-8.4-5)

Additional information about the encoding parameters can be provided
by other header fields not defined by this specification.[¶](#section-8.4-6)

Unlike Transfer-Encoding ([Section 6.1](https://www.rfc-editor.org/rfc/rfc9112#section-6.1) of [[HTTP/1.1](#HTTP11)]), the codings listed
in Content-Encoding are a characteristic of the representation; the
representation is defined in terms of the coded form, and all other
metadata about the representation is about the coded form unless otherwise
noted in the metadata definition. Typically, the representation is only
decoded just prior to rendering or analogous usage.[¶](#section-8.4-7)

If the media type includes an inherent encoding, such as a data format
that is always compressed, then that encoding would not be restated in
Content-Encoding even if it happens to be the same algorithm as one
of the content codings. Such a content coding would only be listed if,
for some bizarre reason, it is applied a second time to form the
representation. Likewise, an origin server might choose to publish the
same data as multiple representations that differ only in whether
the coding is defined as part of [Content-Type](#field.content-type) or
Content-Encoding, since some user agents will behave differently in their
handling of each response (e.g., open a "Save as ..." dialog instead of
automatic decompression and rendering of content).[¶](#section-8.4-8)

An origin server MAY respond with a status code of
[415 (Unsupported Media Type)](#status.415) if a representation in the
request message has a content coding that is not acceptable.[¶](#section-8.4-9)

#### [8.4.1.](#section-8.4.1) [Content Codings](#name-content-codings)

Content coding values indicate an encoding transformation that has
been or can be applied to a representation. Content codings are primarily
used to allow a representation to be compressed or otherwise usefully
transformed without losing the identity of its underlying media type
and without loss of information. Frequently, the representation is stored
in coded form, transmitted directly, and only decoded by the final recipient.[¶](#section-8.4.1-1)

```
  content-coding   = token

```
[¶](#section-8.4.1-2)

All content codings are case-insensitive and ought to be registered
within the "HTTP Content Coding Registry", as described in
[Section 16.6](#content.coding.extensibility)[¶](#section-8.4.1-3)

Content-coding values are used in the
[Accept-Encoding](#field.accept-encoding) ([Section 12.5.3](#field.accept-encoding))
and [Content-Encoding](#field.content-encoding) ([Section 8.4](#field.content-encoding))
header fields.[¶](#section-8.4.1-4)

##### [8.4.1.1.](#section-8.4.1.1) [Compress Coding](#name-compress-coding)

The "compress" coding is an adaptive Lempel-Ziv-Welch (LZW) coding
[[Welch](#Welch)] that is commonly produced by the UNIX file
compression program "compress".
A recipient SHOULD consider "x-compress" to be equivalent to "compress".[¶](#section-8.4.1.1-1)

##### [8.4.1.2.](#section-8.4.1.2) [Deflate Coding](#name-deflate-coding)

The "deflate" coding is a "zlib" data format [[RFC1950](#RFC1950)]
containing a "deflate" compressed data stream [[RFC1951](#RFC1951)]
that uses a combination of the Lempel-Ziv (LZ77) compression algorithm and
Huffman coding.[¶](#section-8.4.1.2-1)

**Note:** Some non-conformant implementations send the "deflate"
compressed data without the zlib wrapper.[¶](#section-8.4.1.2-2.1)

##### [8.4.1.3.](#section-8.4.1.3) [Gzip Coding](#name-gzip-coding)

The "gzip" coding is an LZ77 coding with a 32-bit Cyclic Redundancy Check
(CRC) that is commonly
produced by the gzip file compression program [[RFC1952](#RFC1952)].
A recipient SHOULD consider "x-gzip" to be equivalent to "gzip".[¶](#section-8.4.1.3-1)

### [8.5.](#section-8.5) [Content-Language](#name-content-language)

The "Content-Language" header field describes the natural
language(s) of the intended audience for the representation. Note that this might
not be equivalent to all the languages used within the representation.[¶](#section-8.5-1)

```
  Content-Language = #language-tag

```
[¶](#section-8.5-2)

Language tags are defined in [Section 8.5.1](#language.tags). The primary purpose of
Content-Language is to allow a user to identify and differentiate
representations according to the users' own preferred language. Thus, if the
content is intended only for a Danish-literate audience, the
appropriate field is[¶](#section-8.5-3)

```
Content-Language: da

```
[¶](#section-8.5-4)

If no Content-Language is specified, the default is that the content
is intended for all language audiences. This might mean that the
sender does not consider it to be specific to any natural language,
or that the sender does not know for which language it is intended.[¶](#section-8.5-5)

Multiple languages MAY be listed for content that is intended for
multiple audiences. For example, a rendition of the "Treaty of
Waitangi", presented simultaneously in the original Maori and English
versions, would call for[¶](#section-8.5-6)

```
Content-Language: mi, en

```
[¶](#section-8.5-7)

However, just because multiple languages are present within a representation
does not mean that it is intended for multiple linguistic audiences.
An example would be a beginner's language primer, such as "A First
Lesson in Latin", which is clearly intended to be used by an
English-literate audience. In this case, the Content-Language would
properly only include "en".[¶](#section-8.5-8)

Content-Language MAY be applied to any media type -- it is not
limited to textual documents.[¶](#section-8.5-9)

#### [8.5.1.](#section-8.5.1) [Language Tags](#name-language-tags)

A language tag, as defined in [[RFC5646](#RFC5646)], identifies a
natural language spoken, written, or otherwise conveyed by human beings for
communication of information to other human beings. Computer languages are
explicitly excluded.[¶](#section-8.5.1-1)

HTTP uses language tags within the [Accept-Language](#field.accept-language) and
[Content-Language](#field.content-language) header fields.
[Accept-Language](#field.accept-language) uses the broader language-range production
defined in [Section 12.5.4](#field.accept-language), whereas
[Content-Language](#field.content-language) uses the language-tag production defined
below.[¶](#section-8.5.1-2)

```
  language-tag = <Language-Tag, see [RFC5646], Section 2.1>

```
[¶](#section-8.5.1-3)

A language tag is a sequence of one or more case-insensitive subtags, each
separated by a hyphen character ("-", %x2D). In most cases, a language tag
consists of a primary language subtag that identifies a broad family of
related languages (e.g., "en" = English), which is optionally followed by a
series of subtags that refine or narrow that language's range (e.g.,
"en-CA" = the variety of English as communicated in Canada).
Whitespace is not allowed within a language tag.
Example tags include:[¶](#section-8.5.1-4)

```

  fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN

```
[¶](#section-8.5.1-5)

See [[RFC5646](#RFC5646)] for further information.[¶](#section-8.5.1-6)

### [8.6.](#section-8.6) [Content-Length](#name-content-length)

The "Content-Length" header field indicates the associated representation's
data length as a decimal non-negative integer number of octets.
When transferring a representation as content, Content-Length refers
specifically to the amount of data enclosed so that it can be used to
delimit framing (e.g., [Section 6.2](https://www.rfc-editor.org/rfc/rfc9112#section-6.2) of [[HTTP/1.1](#HTTP11)]).
In other cases, Content-Length indicates the selected representation's
current length, which can be used by recipients to estimate transfer time
or to compare with previously stored representations.[¶](#section-8.6-1)

```
  Content-Length = 1*DIGIT

```
[¶](#section-8.6-2)

An example is[¶](#section-8.6-3)

```
Content-Length: 3495

```
[¶](#section-8.6-4)

A user agent SHOULD send Content-Length in a request when the method
defines a meaning for enclosed content and it is not sending
Transfer-Encoding.
For example, a user agent normally sends Content-Length in a POST request
even when the value is 0 (indicating empty content).
A user agent SHOULD NOT send a
Content-Length header field when the request message does not contain
content and the method semantics do not anticipate such data.[¶](#section-8.6-5)

A server MAY send a Content-Length header field in a response to a HEAD
request ([Section 9.3.2](#HEAD)); a server MUST NOT send Content-Length in such a
response unless its field value equals the decimal number of octets that
would have been sent in the content of a response if the same
request had used the GET method.[¶](#section-8.6-6)

A server MAY send a Content-Length header field in a
[304 (Not Modified)](#status.304) response to a conditional GET request
([Section 15.4.5](#status.304)); a server MUST NOT send Content-Length in such a
response unless its field value equals the decimal number of octets that
would have been sent in the content of a [200 (OK)](#status.200)
response to the same request.[¶](#section-8.6-7)

A server MUST NOT send a Content-Length header field in any response
with a status code of
[1xx (Informational)](#status.1xx) or [204 (No Content)](#status.204).
A server MUST NOT send a Content-Length header field in any
[2xx (Successful)](#status.2xx) response to a CONNECT request ([Section 9.3.6](#CONNECT)).[¶](#section-8.6-8)

Aside from the cases defined above, in the absence of Transfer-Encoding,
an origin server SHOULD send a Content-Length header field when the
content size is known prior to sending the complete header section.
This will allow downstream recipients to measure transfer progress,
know when a received message is complete, and potentially reuse the
connection for additional requests.[¶](#section-8.6-9)

Any Content-Length field value greater than or equal to zero is valid.
Since there is no predefined limit to the length of content, a
recipient MUST anticipate potentially large decimal numerals and
prevent parsing errors due to integer conversion overflows
or precision loss due to integer conversion
([Section 17.5](#attack.protocol.element.length)).[¶](#section-8.6-10)

Because Content-Length is used for message delimitation in HTTP/1.1,
its field value can impact how the message is parsed by downstream
recipients even when the immediate connection is not using HTTP/1.1.
If the message is forwarded by a downstream intermediary, a Content-Length
field value that is inconsistent with the received message framing might
cause a security failure due to request smuggling or response splitting.[¶](#section-8.6-11)

As a result, a sender MUST NOT forward a message with a
Content-Length header field value that is known to be incorrect.[¶](#section-8.6-12)

Likewise, a sender MUST NOT forward a message with a Content-Length
header field value that does not match the ABNF above, with one exception:
a recipient of a Content-Length header field value consisting of the same
decimal value repeated as a comma-separated list (e.g,
"Content-Length: 42, 42") MAY either reject the message as invalid or
replace that invalid field value with a single instance of the decimal
value, since this likely indicates that a duplicate was generated or
combined by an upstream message processor.[¶](#section-8.6-13)

### [8.7.](#section-8.7) [Content-Location](#name-content-location)

The "Content-Location" header field references a URI that can be used
as an identifier for a specific resource corresponding to the
representation in this message's content.
In other words, if one were to perform a GET request on this URI at the time
of this message's generation, then a [200 (OK)](#status.200) response would
contain the same representation that is enclosed as content in this message.[¶](#section-8.7-1)

```
  Content-Location = absolute-URI / partial-URI

```
[¶](#section-8.7-2)

The field value is either an [absolute-URI](#uri.references) or a
[partial-URI](#uri.references). In the latter case ([Section 4](#uri)),
the referenced URI is relative to the target URI
([[URI](#URI)], [Section 5](https://www.rfc-editor.org/rfc/rfc3986#section-5)).[¶](#section-8.7-3)

The Content-Location value is not a replacement for the target URI
([Section 7.1](#target.resource)). It is representation metadata.
It has the same syntax and semantics as the header field of the same name
defined for MIME body parts in [Section 4](https://www.rfc-editor.org/rfc/rfc2557#section-4) of [[RFC2557](#RFC2557)].
However, its appearance in an HTTP message has some special implications
for HTTP recipients.[¶](#section-8.7-4)

If Content-Location is included in a [2xx (Successful)](#status.2xx)
response message and its value refers (after conversion to absolute form)
to a URI that is the same as the target URI, then
the recipient MAY consider the content to be a current representation of
that resource at the time indicated by the message origination date.
For a GET ([Section 9.3.1](#GET)) or HEAD ([Section 9.3.2](#HEAD)) request,
this is the same as the default semantics when no Content-Location is
provided by the server.
For a state-changing request like PUT ([Section 9.3.4](#PUT)) or
POST ([Section 9.3.3](#POST)), it implies that the server's response
contains the new representation of that resource, thereby distinguishing it
from representations that might only report about the action
(e.g., "It worked!").
This allows authoring applications to update their local copies without
the need for a subsequent GET request.[¶](#section-8.7-5)

If Content-Location is included in a [2xx (Successful)](#status.2xx)
response message and its field value refers to a URI that differs from the
target URI, then the origin server claims that the URI
is an identifier for a different resource corresponding to the enclosed
representation. Such a claim can only be trusted if both identifiers share
the same resource owner, which cannot be programmatically determined via
HTTP.[¶](#section-8.7-6)

* For a response to a GET or HEAD request, this is an indication that the
  target URI refers to a resource that is subject to content
  negotiation and the Content-Location field value is a more specific
  identifier for the [selected representation](#selected.representation).[¶](#section-8.7-7.1)
* For a [201 (Created)](#status.201) response to a state-changing method,
  a Content-Location field value that is identical to the
  [Location](#field.location) field value indicates that this content is a
  current representation of the newly created resource.[¶](#section-8.7-7.2)
* Otherwise, such a Content-Location indicates that this content is a
  representation reporting on the requested action's status and that the
  same report is available (for future access with GET) at the given URI.
  For example, a purchase transaction made via a POST request might
  include a receipt document as the content of the [200 (OK)](#status.200)
  response; the Content-Location field value provides an identifier for
  retrieving a copy of that same receipt in the future.[¶](#section-8.7-7.3)

A user agent that sends Content-Location in a request message is stating
that its value refers to where the user agent originally obtained the
content of the enclosed representation (prior to any modifications made by
that user agent). In other words, the user agent is providing a back link
to the source of the original representation.[¶](#section-8.7-8)

An origin server that receives a Content-Location field in a request
message MUST treat the information as transitory request context rather
than as metadata to be saved verbatim as part of the representation.
An origin server MAY use that context to guide in processing the
request or to save it for other uses, such as within source links or
versioning metadata. However, an origin server MUST NOT use such context
information to alter the request semantics.[¶](#section-8.7-9)

For example, if a client makes a PUT request on a negotiated resource and
the origin server accepts that PUT (without redirection), then the new
state of that resource is expected to be consistent with the one
representation supplied in that PUT; the Content-Location cannot be used as
a form of reverse content selection identifier to update only one of the
negotiated representations. If the user agent had wanted the latter
semantics, it would have applied the PUT directly to the Content-Location
URI.[¶](#section-8.7-10)

### [8.8.](#section-8.8) [Validator Fields](#name-validator-fields)

Resource metadata is referred to as a "validator" if it
can be used within a precondition ([Section 13.1](#preconditions)) to
make a conditional request ([Section 13](#conditional.requests)).
Validator fields convey a current validator for the
[selected representation](#selected.representation)
([Section 3.2](#representations)).[¶](#section-8.8-1)

In responses to safe requests, validator fields describe the selected
representation chosen by the origin server while handling the response.
Note that, depending on the method and status code semantics, the
selected representation for a given response is not
necessarily the same as the representation enclosed as response content.[¶](#section-8.8-2)

In a successful response to a state-changing request, validator fields
describe the new representation that has replaced the prior
[selected representation](#selected.representation) as a result of processing the
request.[¶](#section-8.8-3)

For example, an ETag field in a [201 (Created)](#status.201) response
communicates the entity tag of the newly created resource's
representation, so that the entity tag can be used as a validator in
later conditional requests to prevent the "lost update" problem.[¶](#section-8.8-4)

This specification defines two forms of metadata that are commonly used
to observe resource state and test for preconditions: modification dates
([Section 8.8.2](#field.last-modified)) and opaque entity tags
([Section 8.8.3](#field.etag)).
Additional metadata that reflects resource state
has been defined by various extensions of HTTP, such as Web Distributed
Authoring and Versioning [[WEBDAV](#WEBDAV)], that are beyond the
scope of this specification.[¶](#section-8.8-5)

#### [8.8.1.](#section-8.8.1) [Weak versus Strong](#name-weak-versus-strong)

Validators come in two flavors: strong or weak. Weak validators are easy
to generate but are far less useful for comparisons. Strong validators
are ideal for comparisons but can be very difficult (and occasionally
impossible) to generate efficiently. Rather than impose that all forms
of resource adhere to the same strength of validator, HTTP exposes the
type of validator in use and imposes restrictions on when weak validators
can be used as preconditions.[¶](#section-8.8.1-1)

A "strong validator" is representation metadata that changes value whenever
a change occurs to the representation data that would be observable in the
content of a [200 (OK)](#status.200) response to GET.[¶](#section-8.8.1-2)

A strong validator might change for reasons other than a change to the
representation data, such as when a
semantically significant part of the representation metadata is changed
(e.g., [Content-Type](#field.content-type)), but it is in the best interests of the
origin server to only change the value when it is necessary to invalidate
the stored responses held by remote caches and authoring tools.[¶](#section-8.8.1-3)

Cache entries might persist for arbitrarily long periods, regardless
of expiration times. Thus, a cache might attempt to validate an
entry using a validator that it obtained in the distant past.
A strong validator is unique across all versions of all
representations associated with a particular resource over time.
However, there is no implication of uniqueness across representations
of different resources (i.e., the same strong validator might be
in use for representations of multiple resources at the same time
and does not imply that those representations are equivalent).[¶](#section-8.8.1-4)

There are a variety of strong validators used in practice. The best are
based on strict revision control, wherein each change to a representation
always results in a unique node name and revision identifier being assigned
before the representation is made accessible to GET.
A collision-resistant hash
function applied to the representation data is also sufficient if the data
is available prior to the response header fields being sent and the digest
does not need to be recalculated every time a validation request is
received. However, if a resource has distinct representations that differ
only in their metadata, such as might occur with content negotiation over
media types that happen to share the same data format, then the origin
server needs to incorporate additional information in the validator to
distinguish those representations.[¶](#section-8.8.1-5)

In contrast, a "weak validator" is representation metadata
that might not change for every change to the representation data. This
weakness might be due to limitations in how the value is calculated
(e.g., clock resolution), an inability to ensure uniqueness for all
possible representations of the resource, or a desire of the resource
owner to group representations by some self-determined set of
equivalency rather than unique sequences of data.[¶](#section-8.8.1-6)

An origin server SHOULD change a weak entity tag whenever it
considers prior representations to be unacceptable as a substitute for
the current representation. In other words, a weak entity tag ought to
change whenever the origin server wants caches to invalidate old
responses.[¶](#section-8.8.1-7)

For example, the representation of a weather report that changes in
content every second, based on dynamic measurements, might be grouped
into sets of equivalent representations (from the origin server's
perspective) with the same weak validator in order to allow cached
representations to be valid for a reasonable period of time (perhaps
adjusted dynamically based on server load or weather quality).
Likewise, a representation's modification time, if defined with only
one-second resolution, might be a weak validator if it is possible
for the representation to be modified twice during a single second and
retrieved between those modifications.[¶](#section-8.8.1-8)

Likewise, a validator is weak if it is shared by two or more
representations of a given resource at the same time, unless those
representations have identical representation data. For example, if the
origin server sends the same validator for a representation with a gzip
content coding applied as it does for a representation with no content
coding, then that validator is weak. However, two simultaneous
representations might share the same strong validator if they differ only
in the representation metadata, such as when two different media types are
available for the same representation data.[¶](#section-8.8.1-9)

Strong validators are usable for all conditional requests, including cache
validation, partial content ranges, and "lost update" avoidance.
Weak validators are only usable when the client does not require exact
equality with previously obtained representation data, such as when
validating a cache entry or limiting a web traversal to recent changes.[¶](#section-8.8.1-10)

#### [8.8.2.](#section-8.8.2) [Last-Modified](#name-last-modified)

The "Last-Modified" header field in a response provides a timestamp
indicating the date and time at which the origin server believes the
[selected representation](#selected.representation) was last modified, as determined at the conclusion
of handling the request.[¶](#section-8.8.2-1)

```
  Last-Modified = HTTP-date

```
[¶](#section-8.8.2-2)

An example of its use is[¶](#section-8.8.2-3)

```
Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT

```
[¶](#section-8.8.2-4)

##### [8.8.2.1.](#section-8.8.2.1) [Generation](#name-generation)

An origin server SHOULD send Last-Modified for any selected
representation for which a last modification date can be reasonably
and consistently determined, since its use in conditional requests
and evaluating cache freshness ([[CACHING](#CACHING)]) can
substantially reduce unnecessary transfers and significantly
improve service availability and scalability.[¶](#section-8.8.2.1-1)

A representation is typically the sum of many parts behind the
resource interface. The last-modified time would usually be
the most recent time that any of those parts were changed.
How that value is determined for any given resource is an
implementation detail beyond the scope of this specification.[¶](#section-8.8.2.1-2)

An origin server SHOULD obtain the Last-Modified value of the
representation as close as possible to the time that it generates the
[Date](#field.date) field value for its response. This allows a recipient to
make an accurate assessment of the representation's modification time,
especially if the representation changes near the time that the
response is generated.[¶](#section-8.8.2.1-3)

An origin server with a clock (as defined in [Section 5.6.7](#http.date))
MUST NOT generate a Last-Modified date that is later than the
server's time of message origination
([Date](#field.date), [Section 6.6.1](#field.date)).
If the last modification time is derived from implementation-specific
metadata that evaluates to some time in the future, according to the
origin server's clock, then the origin server MUST replace that
value with the message origination date. This prevents a future
modification date from having an adverse impact on cache validation.[¶](#section-8.8.2.1-4)

An origin server without a clock MUST NOT generate a Last-Modified
date for a response unless that date value was assigned to the resource
by some other system (presumably one with a clock).[¶](#section-8.8.2.1-5)

##### [8.8.2.2.](#section-8.8.2.2) [Comparison](#name-comparison)

A Last-Modified time, when used as a validator in a request, is
implicitly weak unless it is possible to deduce that it is strong,
using the following rules:[¶](#section-8.8.2.2-1)

* The validator is being compared by an origin server to the
  actual current validator for the representation and,[¶](#section-8.8.2.2-2.1)
* That origin server reliably knows that the associated representation did
  not change twice during the second covered by the presented
  validator;[¶](#section-8.8.2.2-2.2)

or[¶](#section-8.8.2.2-3)

* The validator is about to be used by a client in an
  [If-Modified-Since](#field.if-modified-since),
  [If-Unmodified-Since](#field.if-unmodified-since), or [If-Range](#field.if-range) header
  field, because the client has a cache entry for the associated
  representation, and[¶](#section-8.8.2.2-4.1)
* That cache entry includes a [Date](#field.date) value which is
  at least one second after the Last-Modified value and
  the client has reason to believe that they were generated by the
  same clock or that there is enough difference between the Last-Modified
  and Date values to make clock synchronization issues unlikely;[¶](#section-8.8.2.2-4.2)

or[¶](#section-8.8.2.2-5)

* The validator is being compared by an intermediate cache to the
  validator stored in its cache entry for the representation, and[¶](#section-8.8.2.2-6.1)
* That cache entry includes a [Date](#field.date) value which is
  at least one second after the Last-Modified value and
  the cache has reason to believe that they were generated by the
  same clock or that there is enough difference between the Last-Modified
  and Date values to make clock synchronization issues unlikely.[¶](#section-8.8.2.2-6.2)

This method relies on the fact that if two different responses were
sent by the origin server during the same second, but both had the
same Last-Modified time, then at least one of those responses would
have a [Date](#field.date) value equal to its Last-Modified time.[¶](#section-8.8.2.2-7)

#### [8.8.3.](#section-8.8.3) [ETag](#name-etag)

The "ETag" field in a response provides the current entity tag for
the [selected representation](#selected.representation), as determined at the conclusion of handling
the request.
An entity tag is an opaque validator for differentiating between
multiple representations of the same resource, regardless of whether
those multiple representations are due to resource state changes over
time, content negotiation resulting in multiple representations being
valid at the same time, or both. An entity tag consists of an opaque
quoted string, possibly prefixed by a weakness indicator.[¶](#section-8.8.3-1)

```
  ETag       = entity-tag

  entity-tag = [ weak ] opaque-tag
  weak       = %s"W/"
  opaque-tag = DQUOTE *etagc DQUOTE
  etagc      = %x21 / %x23-7E / obs-text
             ; VCHAR except double quotes, plus obs-text

```
[¶](#section-8.8.3-2)

**Note:** Previously, opaque-tag was defined to be a quoted-string
([[RFC2616](#RFC2616)], [Section 3.11](https://www.rfc-editor.org/rfc/rfc2616#section-3.11)); thus, some recipients
might perform backslash unescaping. Servers therefore ought to avoid
backslash characters in entity tags.[¶](#section-8.8.3-3.1)

An entity tag can be more reliable for validation than a modification
date in situations where it is inconvenient to store modification
dates, where the one-second resolution of HTTP-date values is not
sufficient, or where modification dates are not consistently maintained.[¶](#section-8.8.3-4)

Examples:[¶](#section-8.8.3-5)

```
ETag: "xyzzy"
ETag: W/"xyzzy"
ETag: ""

```
[¶](#section-8.8.3-6)

An entity tag can be either a weak or strong validator, with
strong being the default. If an origin server provides an entity tag
for a representation and the generation of that entity tag does not satisfy
all of the characteristics of a strong validator
([Section 8.8.1](#weak.and.strong.validators)), then the origin server
MUST mark the entity tag as weak by prefixing its opaque value
with "W/" (case-sensitive).[¶](#section-8.8.3-7)

A sender MAY send the ETag field in a trailer section (see
[Section 6.5](#trailer.fields)). However, since trailers are often
ignored, it is preferable to send ETag as a header field unless the
entity tag is generated while sending the content.[¶](#section-8.8.3-8)

##### [8.8.3.1.](#section-8.8.3.1) [Generation](#name-generation-2)

The principle behind entity tags is that only the service author
knows the implementation of a resource well enough to select the
most accurate and efficient validation mechanism for that resource,
and that any such mechanism can be mapped to a simple sequence of
octets for easy comparison. Since the value is opaque, there is no
need for the client to be aware of how each entity tag is constructed.[¶](#section-8.8.3.1-1)

For example, a resource that has implementation-specific versioning
applied to all changes might use an internal revision number, perhaps
combined with a variance identifier for content negotiation, to
accurately differentiate between representations.
Other implementations might use a collision-resistant hash of
representation content, a combination of various file attributes, or
a modification timestamp that has sub-second resolution.[¶](#section-8.8.3.1-2)

An origin server SHOULD send an ETag for any selected representation
for which detection of changes can be reasonably and consistently
determined, since the entity tag's use in conditional requests and
evaluating cache freshness ([[CACHING](#CACHING)]) can
substantially reduce unnecessary transfers and significantly
improve service availability, scalability, and reliability.[¶](#section-8.8.3.1-3)

##### [8.8.3.2.](#section-8.8.3.2) [Comparison](#name-comparison-2)

There are two entity tag comparison functions, depending on whether or not
the comparison context allows the use of weak validators:[¶](#section-8.8.3.2-1)

"Strong comparison":

two entity tags are equivalent if both are not weak and their opaque-tags
match character-by-character.[¶](#section-8.8.3.2-2.2)

"Weak comparison":

two entity tags are equivalent if their opaque-tags match
character-by-character, regardless of either or both being tagged as "weak".[¶](#section-8.8.3.2-2.4)

The example below shows the results for a set of entity tag pairs and both
the weak and strong comparison function results:[¶](#section-8.8.3.2-3)

[Table 3](#table-3)
| ETag 1 | ETag 2 | Strong Comparison | Weak Comparison |
| --- | --- | --- | --- |
| W/"1" | W/"1" | no match | match |
| W/"1" | W/"2" | no match | no match |
| W/"1" | "1" | no match | match |
| "1" | "1" | match | match |

##### [8.8.3.3.](#section-8.8.3.3) [Example: Entity Tags Varying on Content-Negotiated Resources](#name-example-entity-tags-varying)

Consider a resource that is subject to content negotiation
([Section 12](#content.negotiation)), and where the representations sent in response to
a GET request vary based on the [Accept-Encoding](#field.accept-encoding) request
header field ([Section 12.5.3](#field.accept-encoding)):[¶](#section-8.8.3.3-1)

>> Request:[¶](#section-8.8.3.3-2)

```
GET /index HTTP/1.1
Host: www.example.com
Accept-Encoding: gzip

```
[¶](#section-8.8.3.3-3)

In this case, the response might or might not use the gzip content coding.
If it does not, the response might look like:[¶](#section-8.8.3.3-4)

>> Response:[¶](#section-8.8.3.3-5)

```
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-a"
Content-Length: 70
Vary: Accept-Encoding
Content-Type: text/plain

Hello World!
Hello World!
Hello World!
Hello World!
Hello World!

```
[¶](#section-8.8.3.3-6)

An alternative representation that does use gzip content coding would be:[¶](#section-8.8.3.3-7)

>> Response:[¶](#section-8.8.3.3-8)

```
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-b"
Content-Length: 43
Vary: Accept-Encoding
Content-Type: text/plain
Content-Encoding: gzip

...binary data...
```
[¶](#section-8.8.3.3-9)

**Note:** Content codings are a property of the representation data,
so a strong entity tag for a content-encoded representation has to be
distinct from the entity tag of an unencoded representation to prevent
potential conflicts during cache updates and range requests. In contrast,
transfer codings ([Section 7](https://www.rfc-editor.org/rfc/rfc9112#section-7) of [[HTTP/1.1](#HTTP11)]) apply only during message transfer
and do not result in distinct entity tags.[¶](#section-8.8.3.3-10.1)

## [9.](#section-9) [Methods](#name-methods)

### [9.1.](#section-9.1) [Overview](#name-overview)

The request method token is the primary source of request semantics;
it indicates the purpose for which the client has made this request
and what is expected by the client as a successful result.[¶](#section-9.1-1)

The request method's semantics might be further specialized by the
semantics of some header fields when present in a request
if those additional semantics do not conflict with the method.
For example, a client can send conditional request header fields
([Section 13.1](#preconditions)) to make the requested
action conditional on the current state of the target resource.[¶](#section-9.1-2)

HTTP is designed to be usable as an interface to distributed
object systems. The request method invokes an action to be applied to
a [target resource](#target.resource) in much the same way that a remote
method invocation can be sent to an identified object.[¶](#section-9.1-3)

```
  method = token

```
[¶](#section-9.1-4)

The method token is case-sensitive because it might be used as a gateway
to object-based systems with case-sensitive method names. By convention,
standardized methods are defined in all-uppercase US-ASCII letters.[¶](#section-9.1-5)

Unlike distributed objects, the standardized request methods in HTTP are
not resource-specific, since uniform interfaces provide for better
visibility and reuse in network-based systems [[REST](#REST)].
Once defined, a standardized method ought to have the same semantics when
applied to any resource, though each resource determines for itself
whether those semantics are implemented or allowed.[¶](#section-9.1-6)

This specification defines a number of standardized methods that are
commonly used in HTTP, as outlined by the following table.[¶](#section-9.1-7)

[Table 4](#table-4)
| Method Name | Description | Section |
| --- | --- | --- |
| GET | Transfer a current representation of the target resource. | [9.3.1](#GET) |
| HEAD | Same as GET, but do not transfer the response content. | [9.3.2](#HEAD) |
| POST | Perform resource-specific processing on the request content. | [9.3.3](#POST) |
| PUT | Replace all current representations of the target resource with the request content. | [9.3.4](#PUT) |
| DELETE | Remove all current representations of the target resource. | [9.3.5](#DELETE) |
| CONNECT | Establish a tunnel to the server identified by the target resource. | [9.3.6](#CONNECT) |
| OPTIONS | Describe the communication options for the target resource. | [9.3.7](#OPTIONS) |
| TRACE | Perform a message loop-back test along the path to the target resource. | [9.3.8](#TRACE) |

All general-purpose servers MUST support the methods GET and HEAD.
All other methods are OPTIONAL.[¶](#section-9.1-9)

The set of methods allowed by a target resource can be listed in an
[Allow](#field.allow) header field ([Section 10.2.1](#field.allow)).
However, the set of allowed methods can change dynamically.
An origin server that receives a request method that is unrecognized or
not implemented SHOULD respond with the
[501 (Not Implemented)](#status.501) status code.
An origin server that receives a request method that is recognized and
implemented, but not allowed for the target resource, SHOULD respond
with the [405 (Method Not Allowed)](#status.405) status code.[¶](#section-9.1-10)

Additional methods, outside the scope of this specification, have been
specified for use in HTTP. All such methods ought to be registered
within the "Hypertext Transfer Protocol (HTTP) Method Registry",
as described in [Section 16.1](#method.extensibility).[¶](#section-9.1-11)

### [9.2.](#section-9.2) [Common Method Properties](#name-common-method-properties)

#### [9.2.1.](#section-9.2.1) [Safe Methods](#name-safe-methods)

Request methods are considered "safe" if
their defined semantics are essentially read-only; i.e., the client does
not request, and does not expect, any state change on the origin server
as a result of applying a safe method to a target resource. Likewise,
reasonable use of a safe method is not expected to cause any harm,
loss of property, or unusual burden on the origin server.[¶](#section-9.2.1-1)

This definition of safe methods does not prevent an implementation from
including behavior that is potentially harmful, that is not entirely read-only,
or that causes side effects while invoking a safe method. What is
important, however, is that the client did not request that additional
behavior and cannot be held accountable for it. For example,
most servers append request information to access log files at the
completion of every response, regardless of the method, and that is
considered safe even though the log storage might become full and cause
the server to fail. Likewise, a safe request initiated by selecting an
advertisement on the Web will often have the side effect of charging an
advertising account.[¶](#section-9.2.1-2)

Of the request methods defined by this specification, the
[GET](#GET), [HEAD](#HEAD), [OPTIONS](#OPTIONS), and
[TRACE](#TRACE) methods are defined to be safe.[¶](#section-9.2.1-3)

The purpose of distinguishing between safe and unsafe methods is to
allow automated retrieval processes (spiders) and cache performance
optimization (pre-fetching) to work without fear of causing harm.
In addition, it allows a user agent to apply appropriate constraints
on the automated use of unsafe methods when processing potentially
untrusted content.[¶](#section-9.2.1-4)

A user agent SHOULD distinguish between safe and unsafe methods when
presenting potential actions to a user, such that the user can be made
aware of an unsafe action before it is requested.[¶](#section-9.2.1-5)

When a resource is constructed such that parameters within the target URI
have the effect of selecting an action, it is the resource
owner's responsibility to ensure that the action is consistent with the
request method semantics.
For example, it is common for Web-based content editing software
to use actions within query parameters, such as "page?do=delete".
If the purpose of such a resource is to perform an unsafe action, then
the resource owner MUST disable or disallow that action when it is
accessed using a safe request method. Failure to do so will result in
unfortunate side effects when automated processes perform a GET on
every URI reference for the sake of link maintenance, pre-fetching,
building a search index, etc.[¶](#section-9.2.1-6)

#### [9.2.2.](#section-9.2.2) [Idempotent Methods](#name-idempotent-methods)

A request method is considered "idempotent"
if the intended effect on the server of multiple identical requests with
that method is the same as the effect for a single such request.
Of the request methods defined by this
specification, [PUT](#PUT), [DELETE](#DELETE), and safe request
methods are idempotent.[¶](#section-9.2.2-1)

Like the definition of safe, the idempotent property only applies to
what has been requested by the user; a server is free to log each request
separately, retain a revision control history, or implement other
non-idempotent side effects for each idempotent request.[¶](#section-9.2.2-2)

Idempotent methods are distinguished because the request can be repeated
automatically if a communication failure occurs before the client is
able to read the server's response. For example, if a client sends a PUT
request and the underlying connection is closed before any response is
received, then the client can establish a new connection and retry the
idempotent request. It knows that repeating the request will have
the same intended effect, even if the original request succeeded, though
the response might differ.[¶](#section-9.2.2-3)

A client SHOULD NOT automatically retry a request with a non-idempotent
method unless it has some means to know that the request semantics are
actually idempotent, regardless of the method, or some means to detect that
the original request was never applied.[¶](#section-9.2.2-4)

For example, a user agent can repeat a POST request automatically if it
knows (through design or configuration) that the request is safe for that
resource. Likewise, a user agent designed specifically to operate on
a version control repository might be able to recover from partial failure
conditions by checking the target resource revision(s) after a failed
connection, reverting or fixing any changes that were partially applied,
and then automatically retrying the requests that failed.[¶](#section-9.2.2-5)

Some clients take a riskier approach and attempt to guess when an
automatic retry is possible. For example, a client might automatically
retry a POST request if the underlying transport connection closed before
any part of a response is received, particularly if an idle persistent
connection was used.[¶](#section-9.2.2-6)

A proxy MUST NOT automatically retry non-idempotent requests.
A client SHOULD NOT automatically retry a failed automatic retry.[¶](#section-9.2.2-7)

#### [9.2.3.](#section-9.2.3) [Methods and Caching](#name-methods-and-caching)

For a cache to store and use a response, the associated method needs to
explicitly allow caching and to detail under what conditions a response can
be used to satisfy subsequent requests; a method definition that does not
do so cannot be cached. For additional requirements see [[CACHING](#CACHING)].[¶](#section-9.2.3-1)

This specification defines caching semantics for GET, HEAD, and POST,
although the overwhelming majority of cache implementations only support
GET and HEAD.[¶](#section-9.2.3-2)

### [9.3.](#section-9.3) [Method Definitions](#name-method-definitions)

#### [9.3.1.](#section-9.3.1) [GET](#name-get)

The GET method requests transfer of a current
[selected representation](#selected.representation) for the
[target resource](#target.resource).
A successful response reflects the quality of "sameness" identified by
the target URI ([Section 1.2.2](https://www.rfc-editor.org/rfc/rfc3986#section-1.2.2) of [[URI](#URI)]). Hence,
retrieving identifiable information via HTTP is usually performed by
making a GET request on an identifier associated with the potential for
providing that information in a [200 (OK)](#status.200) response.[¶](#section-9.3.1-1)

GET is the primary mechanism of information retrieval and the focus of
almost all performance optimizations. Applications that produce a URI for
each important resource can benefit from those optimizations while enabling
their reuse by other applications, creating a network effect that promotes
further expansion of the Web.[¶](#section-9.3.1-2)

It is tempting to think of resource identifiers as remote file system
pathnames and of representations as being a copy of the contents of such
files. In fact, that is how many resources are implemented (see
[Section 17.3](#attack.pathname) for related security considerations).
However, there are no such limitations in practice.[¶](#section-9.3.1-3)

The HTTP interface for
a resource is just as likely to be implemented as a tree of content
objects, a programmatic view on various database records, or a gateway to
other information systems. Even when the URI mapping mechanism is tied to a
file system, an origin server might be configured to execute the files with
the request as input and send the output as the representation rather than
transfer the files directly. Regardless, only the origin server needs to
know how each resource identifier corresponds to an implementation
and how that implementation manages to select and send a current
representation of the target resource.[¶](#section-9.3.1-4)

A client can alter the semantics of GET to be a "range request", requesting
transfer of only some part(s) of the selected representation, by sending a
[Range](#field.range) header field in the request ([Section 14.2](#field.range)).[¶](#section-9.3.1-5)

Although request message framing is independent of the method used,
content received in a GET request has no generally defined semantics,
cannot alter the meaning or target of the request, and might lead some
implementations to reject the request and close the connection because of
its potential as a request smuggling attack
([Section 11.2](https://www.rfc-editor.org/rfc/rfc9112#section-11.2) of [[HTTP/1.1](#HTTP11)]).
A client SHOULD NOT generate content in a GET request unless it is
made directly to an origin server that has previously indicated,
in or out of band, that such a request has a purpose and will be adequately
supported. An origin server SHOULD NOT rely on private agreements to
receive content, since participants in HTTP communication are often
unaware of intermediaries along the request chain.[¶](#section-9.3.1-6)

The response to a GET request is cacheable; a cache MAY use it to satisfy
subsequent GET and HEAD requests unless otherwise indicated by the
Cache-Control header field ([Section 5.2](https://www.rfc-editor.org/rfc/rfc9111#section-5.2) of [[CACHING](#CACHING)]).[¶](#section-9.3.1-7)

When information retrieval is performed with a mechanism that constructs a
target URI from user-provided information, such as the query fields of a
form using GET, potentially sensitive data might be provided that would not
be appropriate for disclosure within a URI
(see [Section 17.9](#sensitive.information.in.uris)). In some cases, the
data can be filtered or transformed such that it would not reveal such
information. In others, particularly when there is no benefit from caching
a response, using the POST method ([Section 9.3.3](#POST)) instead of GET
can transmit such information in the request content rather than within
the target URI.[¶](#section-9.3.1-8)

#### [9.3.2.](#section-9.3.2) [HEAD](#name-head)

The HEAD method is identical to GET except that the server MUST NOT
send content in the response. HEAD is used to obtain metadata about the
[selected representation](#selected.representation) without transferring its
representation data, often for the sake of testing hypertext links or
finding recent modifications.[¶](#section-9.3.2-1)

The server SHOULD send the same header fields in response to a HEAD
request as it would have sent if the request method had been GET.
However, a server MAY omit header fields for which a value is determined
only while generating the content. For example, some servers buffer a
dynamic response to GET until a minimum amount of data is generated so
that they can more efficiently delimit small responses or make late
decisions with regard to content selection. Such a response to GET might
contain [Content-Length](#field.content-length) and [Vary](#field.vary) fields, for
example, that are not generated within a HEAD response. These minor
inconsistencies are considered preferable to generating and discarding the
content for a HEAD request, since HEAD is usually requested for the
sake of efficiency.[¶](#section-9.3.2-2)

Although request message framing is independent of the method used,
content received in a HEAD request has no generally defined semantics,
cannot alter the meaning or target of the request, and might lead some
implementations to reject the request and close the connection because of
its potential as a request smuggling attack
([Section 11.2](https://www.rfc-editor.org/rfc/rfc9112#section-11.2) of [[HTTP/1.1](#HTTP11)]).
A client SHOULD NOT generate content in a HEAD request unless it is
made directly to an origin server that has previously indicated,
in or out of band, that such a request has a purpose and will be adequately
supported. An origin server SHOULD NOT rely on private agreements to
receive content, since participants in HTTP communication are often
unaware of intermediaries along the request chain.[¶](#section-9.3.2-3)

The response to a HEAD request is cacheable; a cache MAY use it to
satisfy subsequent HEAD requests unless otherwise indicated by the
Cache-Control header field ([Section 5.2](https://www.rfc-editor.org/rfc/rfc9111#section-5.2) of [[CACHING](#CACHING)]).
A HEAD response might also affect previously cached responses to GET;
see [Section 4.3.5](https://www.rfc-editor.org/rfc/rfc9111#section-4.3.5) of [[CACHING](#CACHING)].[¶](#section-9.3.2-4)

#### [9.3.3.](#section-9.3.3) [POST](#name-post)

The POST method requests that the [target resource](#target.resource) process
the representation enclosed in the request according to the resource's own
specific semantics. For example, POST is used for the following functions
(among others):[¶](#section-9.3.3-1)

* Providing a block of data, such as the fields entered into an HTML
  form, to a data-handling process;[¶](#section-9.3.3-2.1)
* Posting a message to a bulletin board, newsgroup, mailing list, blog,
  or similar group of articles;[¶](#section-9.3.3-2.2)
* Creating a new resource that has yet to be identified by the origin
  server; and[¶](#section-9.3.3-2.3)
* Appending data to a resource's existing representation(s).[¶](#section-9.3.3-2.4)

An origin server indicates response semantics by choosing an appropriate
status code depending on the result of processing the POST request;
almost all of the status codes defined by this specification could be
received in a response to POST (the exceptions being [206 (Partial Content)](#status.206),
[304 (Not Modified)](#status.304), and [416 (Range Not Satisfiable)](#status.416)).[¶](#section-9.3.3-3)

If one or more resources has been created on the origin server as a result
of successfully processing a POST request, the origin server SHOULD send
a [201 (Created)](#status.201) response containing a [Location](#field.location)
header field that provides an identifier for the primary resource created
([Section 10.2.2](#field.location)) and a representation that describes the
status of the request while referring to the new resource(s).[¶](#section-9.3.3-4)

Responses to POST requests are only cacheable when they include explicit
freshness information (see [Section 4.2.1](https://www.rfc-editor.org/rfc/rfc9111#section-4.2.1) of [[CACHING](#CACHING)]) and a
[Content-Location](#field.content-location) header field that has the same value as
the POST's target URI ([Section 8.7](#field.content-location)). A cached POST response can be reused
to satisfy a later GET or HEAD request. In contrast, a POST request cannot
be satisfied by a cached POST response because POST is potentially unsafe;
see [Section 4](https://www.rfc-editor.org/rfc/rfc9111#section-4) of [[CACHING](#CACHING)].[¶](#section-9.3.3-5)

If the result of processing a POST would be equivalent to a representation
of an existing resource, an origin server MAY redirect the user agent to
that resource by sending a [303 (See Other)](#status.303) response with the
existing resource's identifier in the [Location](#field.location) field.
This has the benefits of providing the user agent a resource identifier
and transferring the representation via a method more amenable to shared
caching, though at the cost of an extra request if the user agent does not
already have the representation cached.[¶](#section-9.3.3-6)

#### [9.3.4.](#section-9.3.4) [PUT](#name-put)

The PUT method requests that the state of the [target resource](#target.resource)
be created or replaced with the state defined by the representation
enclosed in the request message content. A successful PUT of a given
representation would suggest that a subsequent GET on that same target
resource will result in an equivalent representation being sent in
a [200 (OK)](#status.200) response. However, there is no guarantee that
such a state change will be observable, since the target resource might be
acted upon by other user agents in parallel, or might be subject to dynamic
processing by the origin server, before any subsequent GET is received.
A successful response only implies that the user agent's intent was
achieved at the time of its processing by the origin server.[¶](#section-9.3.4-1)

If the target resource does not have a current representation and
the PUT successfully creates one, then the origin server MUST inform
the user agent by sending a [201 (Created)](#status.201) response. If the
target resource does have a current representation and that representation is
successfully modified in accordance with the state of the enclosed
representation, then the origin server MUST send either a
[200 (OK)](#status.200) or a [204 (No Content)](#status.204) response to
indicate successful completion of the request.[¶](#section-9.3.4-2)

An origin server SHOULD verify that the PUT representation is consistent
with its configured constraints for the target resource. For example, if
an origin server determines a resource's representation metadata based on
the URI, then the origin server needs to ensure that the content received
in a successful PUT request is consistent with that metadata. When a PUT
representation is inconsistent with the target resource, the origin
server SHOULD either make them consistent, by transforming the
representation or changing the resource configuration, or respond
with an appropriate error message containing sufficient information
to explain why the representation is unsuitable. The
[409 (Conflict)](#status.409) or [415 (Unsupported Media Type)](#status.415)
status codes are suggested, with the latter being specific to constraints on
[Content-Type](#field.content-type) values.[¶](#section-9.3.4-3)

For example, if the target resource is configured to always have a
[Content-Type](#field.content-type) of "text/html" and the representation being PUT
has a Content-Type of "image/jpeg", the origin server ought to do one of:[¶](#section-9.3.4-4)

1. reconfigure the target resource to reflect the new media type;[¶](#section-9.3.4-5.1)
2. transform the PUT representation to a format consistent with that
   of the resource before saving it as the new resource state; or,[¶](#section-9.3.4-5.2)
3. reject the request with a [415 (Unsupported Media Type)](#status.415)
   response indicating that the target resource is limited to "text/html",
   perhaps including a link to a different resource that would be a
   suitable target for the new representation.[¶](#section-9.3.4-5.3)

HTTP does not define exactly how a PUT method affects the state
of an origin server beyond what can be expressed by the intent of
the user agent request and the semantics of the origin server response.
It does not define what a resource might be, in any sense of that
word, beyond the interface provided via HTTP. It does not define
how resource state is "stored", nor how such storage might change
as a result of a change in resource state, nor how the origin server
translates resource state into representations. Generally speaking,
all implementation details behind the resource interface are
intentionally hidden by the server.[¶](#section-9.3.4-6)

This extends to how header and trailer fields are stored; while common
header fields like [Content-Type](#field.content-type) will typically be stored
and returned upon subsequent GET requests, header and trailer field
handling is specific to the resource that received the request. As a result,
an origin server SHOULD ignore unrecognized header and trailer fields
received in a PUT request (i.e., not save them as part of the resource
state).[¶](#section-9.3.4-7)

An origin server MUST NOT send a validator field
([Section 8.8](#response.validator)), such as an [ETag](#field.etag) or
[Last-Modified](#field.last-modified) field, in a successful response to PUT unless
the request's representation data was saved without any transformation
applied to the content (i.e., the resource's new representation data is
identical to the content received in the PUT request) and the
validator field value reflects the new representation.
This requirement allows a user agent to know when the representation it
sent (and retains in memory) is the result of the PUT, and thus it doesn't
need to be retrieved again from the origin server. The new validator(s)
received in the response can be used for future conditional requests in
order to prevent accidental overwrites ([Section 13.1](#preconditions)).[¶](#section-9.3.4-8)

The fundamental difference between the POST and PUT methods is
highlighted by the different intent for the enclosed representation.
The target resource in a POST request is intended to handle the
enclosed representation according to the resource's own semantics,
whereas the enclosed representation in a PUT request is defined as
replacing the state of the target resource. Hence, the intent of PUT is
idempotent and visible to intermediaries, even though the exact effect is
only known by the origin server.[¶](#section-9.3.4-9)

Proper interpretation of a PUT request presumes that the user agent knows
which target resource is desired. A service that selects a proper URI on
behalf of the client, after receiving a state-changing request, SHOULD be
implemented using the POST method rather than PUT. If the origin server
will not make the requested PUT state change to the target resource and
instead wishes to have it applied to a different resource, such as when the
resource has been moved to a different URI, then the origin server MUST
send an appropriate [3xx (Redirection)](#status.3xx) response; the
user agent MAY then make its own decision regarding whether or not to
redirect the request.[¶](#section-9.3.4-10)

A PUT request applied to the target resource can have side effects
on other resources. For example, an article might have a URI for
identifying "the current version" (a resource) that is separate
from the URIs identifying each particular version (different
resources that at one point shared the same state as the current version
resource). A successful PUT request on "the current version" URI might
therefore create a new version resource in addition to changing the
state of the target resource, and might also cause links to be added
between the related resources.[¶](#section-9.3.4-11)

Some origin servers support use of the [Content-Range](#field.content-range) header
field ([Section 14.4](#field.content-range)) as a request modifier to
perform a partial PUT, as described in [Section 14.5](#partial.PUT).[¶](#section-9.3.4-12)

Responses to the PUT method are not cacheable. If a successful PUT request
passes through a cache that has one or more stored responses for the
target URI, those stored responses will be invalidated
(see [Section 4.4](https://www.rfc-editor.org/rfc/rfc9111#section-4.4) of [[CACHING](#CACHING)]).[¶](#section-9.3.4-13)

#### [9.3.5.](#section-9.3.5) [DELETE](#name-delete)

The DELETE method requests that the origin server remove the association
between the [target resource](#target.resource) and its current functionality.
In effect, this method is similar to the "rm" command in UNIX: it expresses a
deletion operation on the URI mapping of the origin server rather than an
expectation that the previously associated information be deleted.[¶](#section-9.3.5-1)

If the target resource has one or more current representations, they might
or might not be destroyed by the origin server, and the associated storage
might or might not be reclaimed, depending entirely on the nature of the
resource and its implementation by the origin server (which are beyond the
scope of this specification). Likewise, other implementation aspects of a
resource might need to be deactivated or archived as a result of a DELETE,
such as database or gateway connections. In general, it is assumed that the
origin server will only allow DELETE on resources for which it has a
prescribed mechanism for accomplishing the deletion.[¶](#section-9.3.5-2)

Relatively few resources allow the DELETE method -- its primary use
is for remote authoring environments, where the user has some direction
regarding its effect. For example, a resource that was previously created
using a PUT request, or identified via the Location header field after a
[201 (Created)](#status.201) response to a POST request, might allow a
corresponding DELETE request to undo those actions. Similarly, custom
user agent implementations that implement an authoring function, such as
revision control clients using HTTP for remote operations, might use
DELETE based on an assumption that the server's URI space has been crafted
to correspond to a version repository.[¶](#section-9.3.5-3)

If a DELETE method is successfully applied, the origin server SHOULD send[¶](#section-9.3.5-4)

* a [202 (Accepted)](#status.202) status code if the action will likely succeed but
  has not yet been enacted,[¶](#section-9.3.5-5.1)
* a [204 (No Content)](#status.204) status code if the action has been
  enacted and no further information is to be supplied, or[¶](#section-9.3.5-5.2)
* a [200 (OK)](#status.200) status code if the action has been enacted and
  the response message includes a representation describing the status.[¶](#section-9.3.5-5.3)

Although request message framing is independent of the method used,
content received in a DELETE request has no generally defined semantics,
cannot alter the meaning or target of the request, and might lead some
implementations to reject the request and close the connection because of
its potential as a request smuggling attack
([Section 11.2](https://www.rfc-editor.org/rfc/rfc9112#section-11.2) of [[HTTP/1.1](#HTTP11)]).
A client SHOULD NOT generate content in a DELETE request unless it is
made directly to an origin server that has previously indicated,
in or out of band, that such a request has a purpose and will be adequately
supported. An origin server SHOULD NOT rely on private agreements to
receive content, since participants in HTTP communication are often
unaware of intermediaries along the request chain.[¶](#section-9.3.5-6)

Responses to the DELETE method are not cacheable. If a successful DELETE
request passes through a cache that has one or more stored responses for
the target URI, those stored responses will be invalidated (see
[Section 4.4](https://www.rfc-editor.org/rfc/rfc9111#section-4.4) of [[CACHING](#CACHING)]).[¶](#section-9.3.5-7)

#### [9.3.6.](#section-9.3.6) [CONNECT](#name-connect)

The CONNECT method requests that the recipient establish a tunnel to the
destination origin server identified by the request target and, if
successful, thereafter restrict its behavior to blind forwarding of
data, in both directions, until the tunnel is closed.
Tunnels are commonly used to create an end-to-end virtual connection,
through one or more proxies, which can then be secured using TLS
(Transport Layer Security, [[TLS13](#TLS13)]).[¶](#section-9.3.6-1)

CONNECT uses a special form of request target, unique to this method,
consisting of only the host and port number of the tunnel destination,
separated by a colon. There is no default port; a client MUST send the
port number even if the CONNECT request is based on a URI reference that
contains an authority component with an elided port
([Section 4.1](#uri.references)). For example,[¶](#section-9.3.6-2)

```
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com

```
[¶](#section-9.3.6-3)

A server MUST reject a CONNECT request that targets an empty or invalid
port number, typically by responding with a 400 (Bad Request) status code.[¶](#section-9.3.6-4)

Because CONNECT changes the request/response nature of an HTTP connection,
specific HTTP versions might have different ways of mapping its semantics
into the protocol's wire format.[¶](#section-9.3.6-5)

CONNECT is intended for use in requests to a proxy.
The recipient can establish a tunnel either by directly connecting to
the server identified by the request target or, if configured to use
another proxy, by forwarding the CONNECT request to the next inbound proxy.
An origin server MAY accept a CONNECT request, but most origin servers
do not implement CONNECT.[¶](#section-9.3.6-6)

Any [2xx (Successful)](#status.2xx) response indicates
that the sender (and all inbound proxies) will switch to tunnel mode
immediately after the response header section; data received after that
header section is from the server identified by the request target.
Any response other than a successful response indicates that the tunnel
has not yet been formed.[¶](#section-9.3.6-7)

A tunnel is closed when a tunnel intermediary detects that either side
has closed its connection: the intermediary MUST attempt to send any
outstanding data that came from the closed side to the other side, close
both connections, and then discard any remaining data left undelivered.[¶](#section-9.3.6-8)

Proxy authentication might be used to establish the
authority to create a tunnel. For example,[¶](#section-9.3.6-9)

```
CONNECT server.example.com:443 HTTP/1.1
Host: server.example.com:443
Proxy-Authorization: basic aGVsbG86d29ybGQ=

```
[¶](#section-9.3.6-10)

There are significant risks in establishing a tunnel to arbitrary servers,
particularly when the destination is a well-known or reserved TCP port that
is not intended for Web traffic. For example, a CONNECT to
"example.com:25" would suggest that the proxy connect to the reserved
port for SMTP traffic; if allowed, that could trick the proxy into
relaying spam email. Proxies that support CONNECT SHOULD restrict its
use to a limited set of known ports or a configurable list of safe
request targets.[¶](#section-9.3.6-11)

A server MUST NOT send any Transfer-Encoding or
[Content-Length](#field.content-length) header fields in a
[2xx (Successful)](#status.2xx) response to CONNECT.
A client MUST ignore any Content-Length or Transfer-Encoding header
fields received in a successful response to CONNECT.[¶](#section-9.3.6-12)

A CONNECT request message does not have content. The interpretation of
data sent after the header section of the CONNECT request message is
specific to the version of HTTP in use.[¶](#section-9.3.6-13)

Responses to the CONNECT method are not cacheable.[¶](#section-9.3.6-14)

#### [9.3.7.](#section-9.3.7) [OPTIONS](#name-options)

The OPTIONS method requests information about the communication options
available for the target resource, at either the origin server or an
intervening intermediary. This method allows a client to determine the
options and/or requirements associated with a resource, or the capabilities
of a server, without implying a resource action.[¶](#section-9.3.7-1)

An OPTIONS request with an asterisk ("\*") as the request target
([Section 7.1](#target.resource)) applies to the server in general rather than to a
specific resource. Since a server's communication options typically depend
on the resource, the "\*" request is only useful as a "ping" or "no-op"
type of method; it does nothing beyond allowing the client to test
the capabilities of the server. For example, this can be used to test
a proxy for HTTP/1.1 conformance (or lack thereof).[¶](#section-9.3.7-2)

If the request target is not an asterisk, the OPTIONS request applies
to the options that are available when communicating with the target
resource.[¶](#section-9.3.7-3)

A server generating a successful response to OPTIONS SHOULD send any
header that might indicate optional features implemented by the
server and applicable to the target resource (e.g., [Allow](#field.allow)),
including potential extensions not defined by this specification.
The response content, if any, might also describe the communication options
in a machine or human-readable representation. A standard format for such a
representation is not defined by this specification, but might be defined by
future extensions to HTTP.[¶](#section-9.3.7-4)

A client MAY send a [Max-Forwards](#field.max-forwards) header field in an
OPTIONS request to target a specific recipient in the request chain (see
[Section 7.6.2](#field.max-forwards)). A proxy MUST NOT generate a
Max-Forwards header field while forwarding a request unless that request
was received with a Max-Forwards field.[¶](#section-9.3.7-5)

A client that generates an OPTIONS request containing content
MUST send a valid [Content-Type](#field.content-type) header field describing
the representation media type. Note that this specification does not define
any use for such content.[¶](#section-9.3.7-6)

Responses to the OPTIONS method are not cacheable.[¶](#section-9.3.7-7)

#### [9.3.8.](#section-9.3.8) [TRACE](#name-trace)

The TRACE method requests a remote, application-level loop-back of the
request message. The final recipient of the request SHOULD reflect the
message received, excluding some fields described below, back to the client
as the content of a [200 (OK)](#status.200) response. The "message/http"
format ([Section 10.1](https://www.rfc-editor.org/rfc/rfc9112#section-10.1) of [[HTTP/1.1](#HTTP11)]) is one way to do so.
The final recipient is either the origin server or the first server to
receive a [Max-Forwards](#field.max-forwards) value of zero (0) in the request
([Section 7.6.2](#field.max-forwards)).[¶](#section-9.3.8-1)

A client MUST NOT generate fields in a TRACE request containing
sensitive data that might be disclosed by the response. For example, it
would be foolish for a user agent to send stored user credentials
([Section 11](#authentication)) or cookies [[COOKIE](#COOKIE)] in a TRACE
request. The final recipient of the request SHOULD exclude any request
fields that are likely to contain sensitive data when that recipient
generates the response content.[¶](#section-9.3.8-2)

TRACE allows the client to see what is being received at the other
end of the request chain and use that data for testing or diagnostic
information. The value of the [Via](#field.via) header field ([Section 7.6.3](#field.via))
is of particular interest, since it acts as a trace of the request chain.
Use of the [Max-Forwards](#field.max-forwards) header field allows the client to
limit the length of the request chain, which is useful for testing a chain
of proxies forwarding messages in an infinite loop.[¶](#section-9.3.8-3)

A client MUST NOT send content in a TRACE request.[¶](#section-9.3.8-4)

Responses to the TRACE method are not cacheable.[¶](#section-9.3.8-5)

## [10.](#section-10) [Message Context](#name-message-context)

### [10.1.](#section-10.1) [Request Context Fields](#name-request-context-fields)

The request header fields below provide additional information about the
request context, including information about the user, user agent, and
resource behind the request.[¶](#section-10.1-1)

#### [10.1.1.](#section-10.1.1) [Expect](#name-expect)

The "Expect" header field in a request indicates a certain set of
behaviors (expectations) that need to be supported by the server in
order to properly handle this request.[¶](#section-10.1.1-1)

```
  Expect =      #expectation
  expectation = token [ "=" ( token / quoted-string ) parameters ]

```
[¶](#section-10.1.1-2)

The Expect field value is case-insensitive.[¶](#section-10.1.1-3)

The only expectation defined by this specification is "100-continue"
(with no defined parameters).[¶](#section-10.1.1-4)

A server that receives an Expect field value containing a member other than
[100-continue](#field.expect)
MAY respond with a
[417 (Expectation Failed)](#status.417) status code to indicate that the
unexpected expectation cannot be met.[¶](#section-10.1.1-5)

A "100-continue" expectation informs recipients that the
client is about to send (presumably large) content in this request
and wishes to receive a [100 (Continue)](#status.100) interim response if
the method, target URI, and header fields are not sufficient to cause an immediate
success, redirect, or error response. This allows the client to wait for an
indication that it is worthwhile to send the content before actually
doing so, which can improve efficiency when the data is huge or
when the client anticipates that an error is likely (e.g., when sending a
state-changing method, for the first time, without previously verified
authentication credentials).[¶](#section-10.1.1-6)

For example, a request that begins with[¶](#section-10.1.1-7)

```
PUT /somewhere/fun HTTP/1.1
Host: origin.example.com
Content-Type: video/h264
Content-Length: 1234567890987
Expect: 100-continue

```
[¶](#section-10.1.1-8)

allows the origin server to immediately respond with an error message, such
as [401 (Unauthorized)](#status.401) or [405 (Method Not Allowed)](#status.405),
before the client starts filling the pipes with an unnecessary data
transfer.[¶](#section-10.1.1-9)

Requirements for clients:[¶](#section-10.1.1-10)

* A client MUST NOT generate a 100-continue expectation in a request that
  does not include content.[¶](#section-10.1.1-11.1)
* A client that will wait for a [100 (Continue)](#status.100) response
  before sending the request content MUST send an
  [Expect](#field.expect) header field containing a 100-continue expectation.[¶](#section-10.1.1-11.2)
* A client that sends a 100-continue expectation is not required to wait
  for any specific length of time; such a client MAY proceed to send the
  content even if it has not yet received a response. Furthermore,
  since [100 (Continue)](#status.100) responses cannot be sent through an
  HTTP/1.0 intermediary, such a client SHOULD NOT wait for an indefinite
  period before sending the content.[¶](#section-10.1.1-11.3)
* A client that receives a [417 (Expectation Failed)](#status.417) status
  code in response to a request containing a 100-continue expectation
  SHOULD repeat that request without a 100-continue expectation, since
  the 417 response merely indicates that the response chain does not
  support expectations (e.g., it passes through an HTTP/1.0 server).[¶](#section-10.1.1-11.4)

Requirements for servers:[¶](#section-10.1.1-12)

* A server that receives a 100-continue expectation in an HTTP/1.0 request
  MUST ignore that expectation.[¶](#section-10.1.1-13.1)
* A server MAY omit sending a [100 (Continue)](#status.100) response if
  it has already received some or all of the content for the
  corresponding request, or if the framing indicates that there is no
  content.[¶](#section-10.1.1-13.2)
* A server that sends a [100 (Continue)](#status.100) response MUST
  ultimately send a final status code, once it receives and processes the
  request content, unless the connection is closed prematurely.[¶](#section-10.1.1-13.3)
* A server that responds with a final status code before reading the
  entire request content SHOULD indicate whether it intends to
  close the connection (e.g., see [Section 9.6](https://www.rfc-editor.org/rfc/rfc9112#section-9.6) of [[HTTP/1.1](#HTTP11)]) or
  continue reading the request content.[¶](#section-10.1.1-13.4)

Upon receiving an HTTP/1.1 (or later) request that has a method, target URI,
and complete header section that contains a 100-continue expectation and
an indication that request content will follow, an origin server MUST
send either:[¶](#section-10.1.1-14)

* an immediate response with a final status code, if that status can be
  determined by examining just the method, target URI, and header fields, or[¶](#section-10.1.1-15.1)
* an immediate [100 (Continue)](#status.100) response to encourage the client
  to send the request content.[¶](#section-10.1.1-15.2)

The origin server MUST NOT wait for the content
before sending the [100 (Continue)](#status.100) response.[¶](#section-10.1.1-16)

Upon receiving an HTTP/1.1 (or later) request that has a method, target URI,
and complete header section that contains a 100-continue expectation and
indicates a request content will follow, a proxy MUST either:[¶](#section-10.1.1-17)

* send an immediate
  response with a final status code, if that status can be determined by
  examining just the method, target URI, and header fields, or[¶](#section-10.1.1-18.1)
* forward the request toward the origin server by sending a corresponding
  request-line and header section to the next inbound server.[¶](#section-10.1.1-18.2)

If the proxy believes (from configuration or past interaction) that the
next inbound server only supports HTTP/1.0, the proxy MAY generate an
immediate [100 (Continue)](#status.100) response to encourage the client to
begin sending the content.[¶](#section-10.1.1-19)

#### [10.1.2.](#section-10.1.2) [From](#name-from)

The "From" header field contains an Internet email address for a human
user who controls the requesting user agent. The address ought to be
machine-usable, as defined by "mailbox"
in [Section 3.4](https://www.rfc-editor.org/rfc/rfc5322#section-3.4) of [[RFC5322](#RFC5322)]:[¶](#section-10.1.2-1)

```
  From    = mailbox

  mailbox = <mailbox, see [RFC5322], Section 3.4>

```
[¶](#section-10.1.2-2)

An example is:[¶](#section-10.1.2-3)

```
From: spider-admin@example.org

```
[¶](#section-10.1.2-4)

The From header field is rarely sent by non-robotic user agents.
A user agent SHOULD NOT send a From header field without explicit
configuration by the user, since that might conflict with the user's
privacy interests or their site's security policy.[¶](#section-10.1.2-5)

A robotic user agent SHOULD send a valid From header field so that the
person responsible for running the robot can be contacted if problems
occur on servers, such as if the robot is sending excessive, unwanted,
or invalid requests.[¶](#section-10.1.2-6)

A server SHOULD NOT use the From header field for access control or
authentication, since its value is expected to be visible to anyone
receiving or observing the request and is often recorded within logfiles
and error reports without any expectation of privacy.[¶](#section-10.1.2-7)

#### [10.1.3.](#section-10.1.3) [Referer](#name-referer)

The "Referer" [sic] header field allows the user agent to specify a URI
reference for the resource from which the [target URI](#target.resource) was
obtained (i.e., the "referrer", though the field name is misspelled).
A user agent MUST NOT include the fragment and userinfo components
of the URI reference [[URI](#URI)], if any, when generating the
Referer field value.[¶](#section-10.1.3-1)

```
  Referer = absolute-URI / partial-URI

```
[¶](#section-10.1.3-2)

The field value is either an [absolute-URI](#uri.references) or a
[partial-URI](#uri.references). In the latter case ([Section 4](#uri)),
the referenced URI is relative to the target URI
([[URI](#URI)], [Section 5](https://www.rfc-editor.org/rfc/rfc3986#section-5)).[¶](#section-10.1.3-3)

The Referer header field allows servers to generate back-links to other
resources for simple analytics, logging, optimized caching, etc. It also
allows obsolete or mistyped links to be found for maintenance. Some servers
use the Referer header field as a means of denying links from other sites
(so-called "deep linking") or restricting cross-site request forgery (CSRF),
but not all requests contain it.[¶](#section-10.1.3-4)

Example:[¶](#section-10.1.3-5)

```
Referer: http://www.example.org/hypertext/Overview.html

```
[¶](#section-10.1.3-6)

If the target URI was obtained from a source that does not have its own
URI (e.g., input from the user keyboard, or an entry within the user's
bookmarks/favorites), the user agent MUST either exclude the Referer header field
or send it with a value of "about:blank".[¶](#section-10.1.3-7)

The Referer header field value need not convey the full URI of the referring
resource; a user agent MAY truncate parts other than the referring origin.[¶](#section-10.1.3-8)

The Referer header field has the potential to reveal information about the request
context or browsing history of the user, which is a privacy concern if the
referring resource's identifier reveals personal information (such as an
account name) or a resource that is supposed to be confidential (such as
behind a firewall or internal to a secured service). Most general-purpose
user agents do not send the Referer header field when the referring
resource is a local "file" or "data" URI. A user agent SHOULD NOT send a
[Referer](#field.referer) header field if the referring resource was accessed with
a secure protocol and the request target has an origin differing from that
of the referring resource, unless the referring resource explicitly allows
Referer to be sent. A user agent MUST NOT send a
[Referer](#field.referer) header field in an unsecured HTTP request if the
referring resource was accessed with a secure protocol.
See [Section 17.9](#sensitive.information.in.uris) for additional
security considerations.[¶](#section-10.1.3-9)

Some intermediaries have been known to indiscriminately remove Referer
header fields from outgoing requests. This has the unfortunate side effect
of interfering with protection against CSRF attacks, which can be far
more harmful to their users. Intermediaries and user agent extensions that
wish to limit information disclosure in Referer ought to restrict their
changes to specific edits, such as replacing internal domain names with
pseudonyms or truncating the query and/or path components.
An intermediary SHOULD NOT modify or delete the Referer header field when
the field value shares the same scheme and host as the target URI.[¶](#section-10.1.3-10)

#### [10.1.4.](#section-10.1.4) [TE](#name-te)

The "TE" header field describes capabilities of the client with regard to
transfer codings and trailer sections.[¶](#section-10.1.4-1)

As described in [Section 6.5](#trailer.fields),
a TE field with a "trailers" member sent in a request indicates that the
client will not discard trailer fields.[¶](#section-10.1.4-2)

TE is also used within HTTP/1.1 to advise servers about which transfer
codings the client is able to accept in a response.
As of publication, only HTTP/1.1 uses transfer codings
(see [Section 7](https://www.rfc-editor.org/rfc/rfc9112#section-7) of [[HTTP/1.1](#HTTP11)]).[¶](#section-10.1.4-3)

The TE field value is a list of members, with each member (aside from
"trailers") consisting of a transfer coding name token with an optional
weight indicating the client's relative preference for that
transfer coding ([Section 12.4.2](#quality.values)) and
optional parameters for that transfer coding.[¶](#section-10.1.4-4)

```
  TE                 = #t-codings
  t-codings          = "trailers" / ( transfer-coding [ weight ] )
  transfer-coding    = token *( OWS ";" OWS transfer-parameter )
  transfer-parameter = token BWS "=" BWS ( token / quoted-string )

```
[¶](#section-10.1.4-5)

A sender of TE MUST also send a "TE" connection option within the
[Connection](#field.connection) header field ([Section 7.6.1](#field.connection))
to inform intermediaries not to forward this field.[¶](#section-10.1.4-6)

#### [10.1.5.](#section-10.1.5) [User-Agent](#name-user-agent)

The "User-Agent" header field contains information about the user agent
originating the request, which is often used by servers to help identify
the scope of reported interoperability problems, to work around or tailor
responses to avoid particular user agent limitations, and for analytics
regarding browser or operating system use. A user agent SHOULD send
a User-Agent header field in each request unless specifically configured not
to do so.[¶](#section-10.1.5-1)

```
  User-Agent = product *( RWS ( product / comment ) )

```
[¶](#section-10.1.5-2)

The User-Agent field value consists of one or more product identifiers,
each followed by zero or more comments ([Section 5.6.5](#comments)), which together
identify the user agent software and its significant subproducts.
By convention, the product identifiers are listed in decreasing order of
their significance for identifying the user agent software. Each product
identifier consists of a name and optional version.[¶](#section-10.1.5-3)

```
  product         = token ["/" product-version]
  product-version = token

```
[¶](#section-10.1.5-4)

A sender SHOULD limit generated product identifiers to what is necessary
to identify the product; a sender MUST NOT generate advertising or other
nonessential information within the product identifier.
A sender SHOULD NOT generate information in [product-version](#field.user-agent)
that is not a version identifier (i.e., successive versions of the same
product name ought to differ only in the product-version portion of the
product identifier).[¶](#section-10.1.5-5)

Example:[¶](#section-10.1.5-6)

```
User-Agent: CERN-LineMode/2.15 libwww/2.17b3

```
[¶](#section-10.1.5-7)

A user agent SHOULD NOT generate a User-Agent header field containing needlessly
fine-grained detail and SHOULD limit the addition of subproducts by third
parties. Overly long and detailed User-Agent field values increase request
latency and the risk of a user being identified against their wishes
("fingerprinting").[¶](#section-10.1.5-8)

Likewise, implementations are encouraged not to use the product tokens of
other implementations in order to declare compatibility with them, as this
circumvents the purpose of the field. If a user agent masquerades as a
different user agent, recipients can assume that the user intentionally
desires to see responses tailored for that identified user agent, even
if they might not work as well for the actual user agent being used.[¶](#section-10.1.5-9)

### [10.2.](#section-10.2) [Response Context Fields](#name-response-context-fields)

The response header fields below provide additional information about the
response, beyond what is implied by the status code, including information
about the server, about the [target resource](#target.resource), or about related
resources.[¶](#section-10.2-1)

#### [10.2.1.](#section-10.2.1) [Allow](#name-allow)

The "Allow" header field lists the set of methods advertised as
supported by the [target resource](#target.resource). The purpose of this field
is strictly to inform the recipient of valid request methods associated
with the resource.[¶](#section-10.2.1-1)

```
  Allow = #method

```
[¶](#section-10.2.1-2)

Example of use:[¶](#section-10.2.1-3)

```
Allow: GET, HEAD, PUT

```
[¶](#section-10.2.1-4)

The actual set of allowed methods is defined by the origin server at the
time of each request. An origin server MUST generate an Allow header field in a
[405 (Method Not Allowed)](#status.405) response and MAY do so in any
other response. An empty Allow field value indicates that the resource
allows no methods, which might occur in a 405 response if the resource has
been temporarily disabled by configuration.[¶](#section-10.2.1-5)

A proxy MUST NOT modify the Allow header field -- it does not need
to understand all of the indicated methods in order to handle them
according to the generic message handling rules.[¶](#section-10.2.1-6)

#### [10.2.2.](#section-10.2.2) [Location](#name-location)

The "Location" header field is used in some responses to refer to a
specific resource in relation to the response. The type of relationship is
defined by the combination of request method and status code semantics.[¶](#section-10.2.2-1)

```
  Location = URI-reference

```
[¶](#section-10.2.2-2)

The field value consists of a single URI-reference. When it has the form
of a relative reference ([[URI](#URI)], [Section 4.2](https://www.rfc-editor.org/rfc/rfc3986#section-4.2)),
the final value is computed by resolving it against the target
URI ([[URI](#URI)], [Section 5](https://www.rfc-editor.org/rfc/rfc3986#section-5)).[¶](#section-10.2.2-3)

For [201 (Created)](#status.201) responses, the Location value refers to
the primary resource created by the request.
For [3xx (Redirection)](#status.3xx) responses, the Location value refers
to the preferred target resource for automatically redirecting the request.[¶](#section-10.2.2-4)

If the Location value provided in a [3xx (Redirection)](#status.3xx)
response does not have a fragment component, a user agent MUST process the
redirection as if the value inherits the fragment component of the URI
reference used to generate the target URI (i.e., the redirection
inherits the original reference's fragment, if any).[¶](#section-10.2.2-5)

For example, a GET request generated for the URI reference
"http://www.example.org/~tim" might result in a
[303 (See Other)](#status.303) response containing the header field:[¶](#section-10.2.2-6)

```
Location: /People.html#tim

```
[¶](#section-10.2.2-7)

which suggests that the user agent redirect to
"http://www.example.org/People.html#tim"[¶](#section-10.2.2-8)

Likewise, a GET request generated for the URI reference
"http://www.example.org/index.html#larry" might result in a
[301 (Moved Permanently)](#status.301) response containing the header
field:[¶](#section-10.2.2-9)

```
Location: http://www.example.net/index.html

```
[¶](#section-10.2.2-10)

which suggests that the user agent redirect to
"http://www.example.net/index.html#larry", preserving the original fragment
identifier.[¶](#section-10.2.2-11)

There are circumstances in which a fragment identifier in a Location
value would not be appropriate. For example, the Location header field in a
[201 (Created)](#status.201) response is supposed to provide a URI that is
specific to the created resource.[¶](#section-10.2.2-12)

**Note:** Some recipients attempt to recover from Location header fields
that are not valid URI references. This specification does not mandate or
define such processing, but does allow it for the sake of robustness.
A Location field value cannot allow a list of members because the comma list separator
is a valid data character within a URI-reference. If an invalid message is sent with multiple
Location field lines, a recipient along the path might combine those field lines into
one value. Recovery of a valid Location field value from that situation is difficult and not
interoperable across implementations.[¶](#section-10.2.2-13.1)

**Note:** The [Content-Location](#field.content-location) header field
([Section 8.7](#field.content-location)) differs from Location in that the
Content-Location refers to the most specific resource corresponding to the
enclosed representation. It is therefore possible for a response to contain
both the Location and Content-Location header fields.[¶](#section-10.2.2-14.1)

#### [10.2.3.](#section-10.2.3) [Retry-After](#name-retry-after)

Servers send the "Retry-After" header field to indicate how long the user
agent ought to wait before making a follow-up request. When sent with a
[503 (Service Unavailable)](#status.503) response, Retry-After indicates
how long the service is expected to be unavailable to the client.
When sent with any [3xx (Redirection)](#status.3xx) response, Retry-After
indicates the minimum time that the user agent is asked to wait before
issuing the redirected request.[¶](#section-10.2.3-1)

The Retry-After field value can be either an HTTP-date or a number
of seconds to delay after receiving the response.[¶](#section-10.2.3-2)

```
  Retry-After = HTTP-date / delay-seconds

```
[¶](#section-10.2.3-3)

A delay-seconds value is a non-negative decimal integer, representing time
in seconds.[¶](#section-10.2.3-4)

```
  delay-seconds  = 1*DIGIT

```
[¶](#section-10.2.3-5)

Two examples of its use are[¶](#section-10.2.3-6)

```
Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
Retry-After: 120

```
[¶](#section-10.2.3-7)

In the latter example, the delay is 2 minutes.[¶](#section-10.2.3-8)

#### [10.2.4.](#section-10.2.4) [Server](#name-server)

The "Server" header field contains information about the
software used by the origin server to handle the request, which is often
used by clients to help identify the scope of reported interoperability
problems, to work around or tailor requests to avoid particular server
limitations, and for analytics regarding server or operating system use.
An origin server MAY generate a Server header field in its responses.[¶](#section-10.2.4-1)

```
  Server = product *( RWS ( product / comment ) )

```
[¶](#section-10.2.4-2)

The Server header field value consists of one or more product identifiers, each
followed by zero or more comments ([Section 5.6.5](#comments)), which together
identify the origin server software and its significant subproducts.
By convention, the product identifiers are listed in decreasing order of
their significance for identifying the origin server software. Each product
identifier consists of a name and optional version, as defined in
[Section 10.1.5](#field.user-agent).[¶](#section-10.2.4-3)

Example:[¶](#section-10.2.4-4)

```
Server: CERN/3.0 libwww/2.17

```
[¶](#section-10.2.4-5)

An origin server SHOULD NOT generate a Server header field containing needlessly
fine-grained detail and SHOULD limit the addition of subproducts by third
parties. Overly long and detailed Server field values increase response
latency and potentially reveal internal implementation details that might
make it (slightly) easier for attackers to find and exploit known security
holes.[¶](#section-10.2.4-6)

## [11.](#section-11) [HTTP Authentication](#name-http-authentication)

### [11.1.](#section-11.1) [Authentication Scheme](#name-authentication-scheme)

HTTP provides a general framework for access control and authentication,
via an extensible set of challenge-response authentication schemes, which
can be used by a server to challenge a client request and by a client to
provide authentication information. It uses a case-insensitive
token to identify the authentication scheme:[¶](#section-11.1-1)

```
  auth-scheme    = token

```
[¶](#section-11.1-2)

Aside from the general framework, this document does not specify any
authentication schemes. New and existing authentication schemes are
specified independently and ought to be registered within the
"Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry".
For example, the "basic" and "digest" authentication schemes are defined by
[[RFC7617](#RFC7617)] and
[[RFC7616](#RFC7616)], respectively.[¶](#section-11.1-3)

### [11.2.](#section-11.2) [Authentication Parameters](#name-authentication-parameters)

The authentication scheme is followed by additional information necessary
for achieving authentication via that scheme as either a
comma-separated list of parameters or a single sequence of characters
capable of holding base64-encoded information.[¶](#section-11.2-1)

```
  token68        = 1*( ALPHA / DIGIT /
                       "-" / "." / "_" / "~" / "+" / "/" ) *"="

```
[¶](#section-11.2-2)

The token68 syntax allows the 66 unreserved URI characters
([[URI](#URI)]), plus a few others, so that it can hold a
base64, base64url (URL and filename safe alphabet), base32, or base16 (hex)
encoding, with or without padding, but excluding whitespace
([[RFC4648](#RFC4648)]).[¶](#section-11.2-3)

Authentication parameters are name/value pairs, where the name token is
matched case-insensitively
and each parameter name MUST only occur once per challenge.[¶](#section-11.2-4)

```
  auth-param     = token BWS "=" BWS ( token / quoted-string )

```
[¶](#section-11.2-5)

Parameter values can be expressed either as "token" or as "quoted-string"
([Section 5.6](#fields.components)).
Authentication scheme definitions need to accept both notations, both for
senders and recipients, to allow recipients to use generic parsing
components regardless of the authentication scheme.[¶](#section-11.2-6)

For backwards compatibility, authentication scheme definitions can restrict
the format for senders to one of the two variants. This can be important
when it is known that deployed implementations will fail when encountering
one of the two formats.[¶](#section-11.2-7)

### [11.3.](#section-11.3) [Challenge and Response](#name-challenge-and-response)

A [401 (Unauthorized)](#status.401) response message is used by an origin
server to challenge the authorization of a user agent, including a
[WWW-Authenticate](#field.www-authenticate) header field containing at least one
challenge applicable to the requested resource.[¶](#section-11.3-1)

A [407 (Proxy Authentication Required)](#status.407) response message is
used by a proxy to challenge the authorization of a client, including a
[Proxy-Authenticate](#field.proxy-authenticate) header field containing at least one
challenge applicable to the proxy for the requested resource.[¶](#section-11.3-2)

```
  challenge   = auth-scheme [ 1*SP ( token68 / #auth-param ) ]

```
[¶](#section-11.3-3)

**Note:** Many clients fail to parse a challenge that contains an unknown
scheme. A workaround for this problem is to list well-supported schemes
(such as "basic") first.[¶](#section-11.3-4.1)

A user agent that wishes to authenticate itself with an origin server
-- usually, but not necessarily, after receiving a
[401 (Unauthorized)](#status.401) -- can do so by including an
[Authorization](#field.authorization) header field with the request.[¶](#section-11.3-5)

A client that wishes to authenticate itself with a proxy -- usually,
but not necessarily, after receiving a
[407 (Proxy Authentication Required)](#status.407) -- can do so by
including a [Proxy-Authorization](#field.proxy-authorization) header field with the
request.[¶](#section-11.3-6)

### [11.4.](#section-11.4) [Credentials](#name-credentials)

Both the [Authorization](#field.authorization) field value and the
[Proxy-Authorization](#field.proxy-authorization) field value contain the client's
credentials for the realm of the resource being requested, based upon a
challenge received in a response (possibly at some point in the past).
When creating their values, the user agent ought to do so by selecting the
challenge with what it considers to be the most secure auth-scheme that it
understands, obtaining credentials from the user as appropriate.
Transmission of credentials within header field values implies significant
security considerations regarding the confidentiality of the underlying
connection, as described in
[Section 17.16.1](#confidentiality.of.credentials).[¶](#section-11.4-1)

```
  credentials = auth-scheme [ 1*SP ( token68 / #auth-param ) ]

```
[¶](#section-11.4-2)

Upon receipt of a request for a protected resource that omits credentials,
contains invalid credentials (e.g., a bad password) or partial credentials
(e.g., when the authentication scheme requires more than one round trip),
an origin server SHOULD send a [401 (Unauthorized)](#status.401) response
that contains a [WWW-Authenticate](#field.www-authenticate) header field with at least
one (possibly new) challenge applicable to the requested resource.[¶](#section-11.4-3)

Likewise, upon receipt of a request that omits proxy credentials or
contains invalid or partial proxy credentials, a proxy that requires
authentication SHOULD generate a
[407 (Proxy Authentication Required)](#status.407) response that contains
a [Proxy-Authenticate](#field.proxy-authenticate) header field with at least one
(possibly new) challenge applicable to the proxy.[¶](#section-11.4-4)

A server that receives valid credentials that are not adequate to gain
access ought to respond with the [403 (Forbidden)](#status.403) status
code ([Section 15.5.4](#status.403)).[¶](#section-11.4-5)

HTTP does not restrict applications to this simple challenge-response
framework for access authentication. Additional mechanisms can be used,
such as authentication at the transport level or via message encapsulation,
and with additional header fields specifying authentication information.
However, such additional mechanisms are not defined by this specification.[¶](#section-11.4-6)

Note that various custom mechanisms for user authentication use the
Set-Cookie and Cookie header fields, defined in [[COOKIE](#COOKIE)],
for passing tokens related to authentication.[¶](#section-11.4-7)

### [11.5.](#section-11.5) [Establishing a Protection Space (Realm)](#name-establishing-a-protection-s)

The "realm" authentication parameter is reserved for use by
authentication schemes that wish to indicate a scope of protection.[¶](#section-11.5-1)

A "protection space" is defined by the origin (see
[Section 4.3.1](#origin)) of the
server being accessed, in combination with the realm value if present.
These realms allow the protected resources on a server to be
partitioned into a set of protection spaces, each with its own
authentication scheme and/or authorization database. The realm value
is a string, generally assigned by the origin server, that can have
additional semantics specific to the authentication scheme. Note that a
response can have multiple challenges with the same auth-scheme but
with different realms.[¶](#section-11.5-2)

The protection space determines the domain over which credentials can
be automatically applied. If a prior request has been authorized, the
user agent MAY reuse the same credentials for all other requests within
that protection space for a period of time determined by the authentication
scheme, parameters, and/or user preferences (such as a configurable
inactivity timeout).[¶](#section-11.5-3)

The extent of a protection space, and therefore the requests to which
credentials might be automatically applied, is not necessarily known to
clients without additional information. An authentication scheme might
define parameters that describe the extent of a protection space. Unless
specifically allowed by the authentication scheme, a single protection
space cannot extend outside the scope of its server.[¶](#section-11.5-4)

For historical reasons, a sender MUST only generate the quoted-string syntax.
Recipients might have to support both token and quoted-string syntax for
maximum interoperability with existing clients that have been accepting both
notations for a long time.[¶](#section-11.5-5)

### [11.6.](#section-11.6) [Authenticating Users to Origin Servers](#name-authenticating-users-to-ori)

#### [11.6.1.](#section-11.6.1) [WWW-Authenticate](#name-www-authenticate)

The "WWW-Authenticate" response header field indicates the authentication
scheme(s) and parameters applicable to the target resource.[¶](#section-11.6.1-1)

```
  WWW-Authenticate = #challenge

```
[¶](#section-11.6.1-2)

A server generating a [401 (Unauthorized)](#status.401) response
MUST send a WWW-Authenticate header field containing at least one
challenge. A server MAY generate a WWW-Authenticate header field
in other response messages to indicate that supplying credentials
(or different credentials) might affect the response.[¶](#section-11.6.1-3)

A proxy forwarding a response MUST NOT modify any
[WWW-Authenticate](#field.www-authenticate) header fields in that response.[¶](#section-11.6.1-4)

User agents are advised to take special care in parsing the field value, as
it might contain more than one challenge, and each challenge can contain a
comma-separated list of authentication parameters. Furthermore, the header
field itself can occur multiple times.[¶](#section-11.6.1-5)

For instance:[¶](#section-11.6.1-6)

```
WWW-Authenticate: Basic realm="simple", Newauth realm="apps",
                 type=1, title="Login to \"apps\""

```
[¶](#section-11.6.1-7)

This header field contains two challenges, one for the "Basic" scheme with
a realm value of "simple" and another for the "Newauth" scheme with a
realm value of "apps". It also contains two additional parameters, "type" and "title".[¶](#section-11.6.1-8)

Some user agents do not recognize this form, however. As a result, sending
a WWW-Authenticate field value with more than one member on the same field
line might not be interoperable.[¶](#section-11.6.1-9)

**Note:** The challenge grammar production uses the list syntax as
well. Therefore, a sequence of comma, whitespace, and comma can be
considered either as applying to the preceding challenge, or to be an
empty entry in the list of challenges. In practice, this ambiguity
does not affect the semantics of the header field value and thus is
harmless.[¶](#section-11.6.1-10.1)

#### [11.6.2.](#section-11.6.2) [Authorization](#name-authorization)

The "Authorization" header field allows a user agent to authenticate itself
with an origin server -- usually, but not necessarily, after receiving
a [401 (Unauthorized)](#status.401) response. Its value consists of
credentials containing the authentication information of the user agent for
the realm of the resource being requested.[¶](#section-11.6.2-1)

```
  Authorization = credentials

```
[¶](#section-11.6.2-2)

If a request is authenticated and a realm specified, the same credentials
are presumed to be valid for all other requests within this realm (assuming
that the authentication scheme itself does not require otherwise, such as
credentials that vary according to a challenge value or using synchronized
clocks).[¶](#section-11.6.2-3)

A proxy forwarding a request MUST NOT modify any
[Authorization](#field.authorization) header fields in that request.
See [Section 3.5](https://www.rfc-editor.org/rfc/rfc9111#section-3.5) of [[CACHING](#CACHING)] for details of and requirements
pertaining to handling of the Authorization header field by HTTP caches.[¶](#section-11.6.2-4)

#### [11.6.3.](#section-11.6.3) [Authentication-Info](#name-authentication-info)

HTTP authentication schemes can use the "Authentication-Info" response
field to communicate information after the client's authentication credentials have been accepted.
This information can include a finalization message from the server (e.g., it can contain the
server authentication).[¶](#section-11.6.3-1)

The field value is a list of parameters (name/value pairs), using the "auth-param"
syntax defined in [Section 11.3](#challenge.and.response).
This specification only describes the generic format; authentication schemes
using Authentication-Info will define the individual parameters. The "Digest"
Authentication Scheme, for instance, defines multiple parameters in
[Section 3.5](https://www.rfc-editor.org/rfc/rfc7616#section-3.5) of [[RFC7616](#RFC7616)].[¶](#section-11.6.3-2)

```
  Authentication-Info = #auth-param

```
[¶](#section-11.6.3-3)

The Authentication-Info field can be used in any HTTP response,
independently of request method and status code. Its semantics are defined
by the authentication scheme indicated by the [Authorization](#field.authorization) header field
([Section 11.6.2](#field.authorization)) of the corresponding request.[¶](#section-11.6.3-4)

A proxy forwarding a response is not allowed to modify the field value in any
way.[¶](#section-11.6.3-5)

Authentication-Info can be sent as a trailer field
([Section 6.5](#trailer.fields))
when the authentication scheme explicitly allows this.[¶](#section-11.6.3-6)

### [11.7.](#section-11.7) [Authenticating Clients to Proxies](#name-authenticating-clients-to-p)

#### [11.7.1.](#section-11.7.1) [Proxy-Authenticate](#name-proxy-authenticate)

The "Proxy-Authenticate" header field consists of at least one
challenge that indicates the authentication scheme(s) and parameters
applicable to the proxy for this request.
A proxy MUST send at least one Proxy-Authenticate header field in
each [407 (Proxy Authentication Required)](#status.407) response that it
generates.[¶](#section-11.7.1-1)

```
  Proxy-Authenticate = #challenge

```
[¶](#section-11.7.1-2)

Unlike [WWW-Authenticate](#field.www-authenticate), the Proxy-Authenticate header field
applies only to the next outbound client on the response chain.
This is because only the client that chose a given proxy is likely to have
the credentials necessary for authentication. However, when multiple
proxies are used within the same administrative domain, such as office and
regional caching proxies within a large corporate network, it is common
for credentials to be generated by the user agent and passed through the
hierarchy until consumed. Hence, in such a configuration, it will appear
as if Proxy-Authenticate is being forwarded because each proxy will send
the same challenge set.[¶](#section-11.7.1-3)

Note that the parsing considerations for [WWW-Authenticate](#field.www-authenticate)
apply to this header field as well; see [Section 11.6.1](#field.www-authenticate)
for details.[¶](#section-11.7.1-4)

#### [11.7.2.](#section-11.7.2) [Proxy-Authorization](#name-proxy-authorization)

The "Proxy-Authorization" header field allows the client to
identify itself (or its user) to a proxy that requires
authentication. Its value consists of credentials containing the
authentication information of the client for the proxy and/or realm of the
resource being requested.[¶](#section-11.7.2-1)

```
  Proxy-Authorization = credentials

```
[¶](#section-11.7.2-2)

Unlike [Authorization](#field.authorization), the Proxy-Authorization header field
applies only to the next inbound proxy that demanded authentication using
the [Proxy-Authenticate](#field.proxy-authenticate) header field. When multiple proxies are used
in a chain, the Proxy-Authorization header field is consumed by the first
inbound proxy that was expecting to receive credentials. A proxy MAY
relay the credentials from the client request to the next proxy if that is
the mechanism by which the proxies cooperatively authenticate a given
request.[¶](#section-11.7.2-3)

#### [11.7.3.](#section-11.7.3) [Proxy-Authentication-Info](#name-proxy-authentication-info)

The "Proxy-Authentication-Info" response header field is equivalent to
[Authentication-Info](#field.authentication-info), except that it applies to proxy authentication ([Section 11.3](#challenge.and.response))
and its semantics are defined by the
authentication scheme indicated by the Proxy-Authorization header field
([Section 11.7.2](#field.proxy-authorization))
of the corresponding request:[¶](#section-11.7.3-1)

```
  Proxy-Authentication-Info = #auth-param

```
[¶](#section-11.7.3-2)

However, unlike [Authentication-Info](#field.authentication-info), the Proxy-Authentication-Info header
field applies only to the next outbound client on the response chain. This is
because only the client that chose a given proxy is likely to have the
credentials necessary for authentication. However, when multiple proxies are
used within the same administrative domain, such as office and regional
caching proxies within a large corporate network, it is common for
credentials to be generated by the user agent and passed through the
hierarchy until consumed. Hence, in such a configuration, it will appear as
if Proxy-Authentication-Info is being forwarded because each proxy will send
the same field value.[¶](#section-11.7.3-3)

Proxy-Authentication-Info can be sent as a trailer field
([Section 6.5](#trailer.fields))
when the authentication scheme explicitly allows this.[¶](#section-11.7.3-4)

## [12.](#section-12) [Content Negotiation](#name-content-negotiation)

When responses convey content, whether indicating a success or
an error, the origin server often has different ways of representing that
information; for example, in different formats, languages, or encodings.
Likewise, different users or user agents might have differing capabilities,
characteristics, or preferences that could influence which representation,
among those available, would be best to deliver. For this reason, HTTP
provides mechanisms for [content negotiation](#content.negotiation).[¶](#section-12-1)

This specification defines three patterns of content negotiation that can
be made visible within the protocol:
"proactive" negotiation, where the server selects the representation based
upon the user agent's stated preferences; "reactive" negotiation,
where the server provides a list of representations for the user agent to
choose from; and "request content" negotiation, where the user agent
selects the representation for a future request based upon the server's
stated preferences in past responses.[¶](#section-12-2)

Other patterns of content negotiation include
"conditional content", where the representation consists of multiple
parts that are selectively rendered based on user agent parameters,
"active content", where the representation contains a script that
makes additional (more specific) requests based on the user agent
characteristics, and "Transparent Content Negotiation"
([[RFC2295](#RFC2295)]), where content selection is performed by
an intermediary. These patterns are not mutually exclusive, and each has
trade-offs in applicability and practicality.[¶](#section-12-3)

Note that, in all cases, HTTP is not aware of the resource semantics.
The consistency with which an origin server responds to requests, over time
and over the varying dimensions of content negotiation, and thus the
"sameness" of a resource's observed representations over time, is
determined entirely by whatever entity or algorithm selects or generates
those responses.[¶](#section-12-4)

### [12.1.](#section-12.1) [Proactive Negotiation](#name-proactive-negotiation)

When content negotiation preferences are sent by the user agent in a
request to encourage an algorithm located at the server to
select the preferred representation, it is called
"proactive negotiation"
(a.k.a., "server-driven negotiation"). Selection is based on
the available representations for a response (the dimensions over which it
might vary, such as language, content coding, etc.) compared to various
information supplied in the request, including both the explicit
negotiation header fields below and implicit
characteristics, such as the client's network address or parts of the
[User-Agent](#field.user-agent) field.[¶](#section-12.1-1)

Proactive negotiation is advantageous when the algorithm for
selecting from among the available representations is difficult to
describe to a user agent, or when the server desires to send its
"best guess" to the user agent along with the first response (when that
"best guess" is good enough for the user, this avoids the round-trip
delay of a subsequent request). In order to improve the server's
guess, a user agent MAY send request header fields that describe
its preferences.[¶](#section-12.1-2)

Proactive negotiation has serious disadvantages:[¶](#section-12.1-3)

* It is impossible for the server to accurately determine what
  might be "best" for any given user, since that would require
  complete knowledge of both the capabilities of the user agent
  and the intended use for the response (e.g., does the user want
  to view it on screen or print it on paper?);[¶](#section-12.1-4.1)
* Having the user agent describe its capabilities in every
  request can be both very inefficient (given that only a small
  percentage of responses have multiple representations) and a
  potential risk to the user's privacy;[¶](#section-12.1-4.2)
* It complicates the implementation of an origin server and the
  algorithms for generating responses to a request; and,[¶](#section-12.1-4.3)
* It limits the reusability of responses for shared caching.[¶](#section-12.1-4.4)

A user agent cannot rely on proactive negotiation preferences being
consistently honored, since the origin server might not implement proactive
negotiation for the requested resource or might decide that sending a
response that doesn't conform to the user agent's preferences is better
than sending a [406 (Not Acceptable)](#status.406) response.[¶](#section-12.1-5)

A [Vary](#field.vary) header field ([Section 12.5.5](#field.vary)) is
often sent in a response subject to proactive negotiation to indicate what
parts of the request information were used in the selection algorithm.[¶](#section-12.1-6)

The request header fields [Accept](#field.accept),
[Accept-Charset](#field.accept-charset), [Accept-Encoding](#field.accept-encoding), and
[Accept-Language](#field.accept-language) are defined below for a user agent to engage
in [proactive negotiation](#proactive.negotiation) of the response content.
The preferences sent in these
fields apply to any content in the response, including representations of
the target resource, representations of error or processing status, and
potentially even the miscellaneous text strings that might appear within
the protocol.[¶](#section-12.1-7)

### [12.2.](#section-12.2) [Reactive Negotiation](#name-reactive-negotiation)

With "reactive negotiation" (a.k.a., "agent-driven negotiation"), selection of
content (regardless of the status code) is performed by
the user agent after receiving an initial response. The mechanism for
reactive negotiation might be as simple as a list of references to
alternative representations.[¶](#section-12.2-1)

If the user agent is not satisfied by the initial response content,
it can perform a GET request on one or more of the alternative resources
to obtain a different representation. Selection of such alternatives might
be performed automatically (by the user agent) or manually (e.g., by the
user selecting from a hypertext menu).[¶](#section-12.2-2)

A server might choose not to send an initial representation, other than
the list of alternatives, and thereby indicate that reactive
negotiation by the user agent is preferred. For example, the alternatives
listed in responses with the [300 (Multiple Choices)](#status.300) and
[406 (Not Acceptable)](#status.406) status codes include information about
available representations so that the user or user agent can react by
making a selection.[¶](#section-12.2-3)

Reactive negotiation is advantageous when the response would vary
over commonly used dimensions (such as type, language, or encoding),
when the origin server is unable to determine a user agent's
capabilities from examining the request, and generally when public
caches are used to distribute server load and reduce network usage.[¶](#section-12.2-4)

Reactive negotiation suffers from the disadvantages of transmitting
a list of alternatives to the user agent, which degrades user-perceived
latency if transmitted in the header section, and needing a second request
to obtain an alternate representation. Furthermore, this specification
does not define a mechanism for supporting automatic selection, though it
does not prevent such a mechanism from being developed.[¶](#section-12.2-5)

### [12.3.](#section-12.3) [Request Content Negotiation](#name-request-content-negotiation)

When content negotiation preferences are sent in a server's response, the
listed preferences are called "request content negotiation"
because they intend to influence selection of an appropriate content for
subsequent requests to that resource. For example,
the [Accept](#field.accept) ([Section 12.5.1](#field.accept)) and
[Accept-Encoding](#field.accept-encoding) ([Section 12.5.3](#field.accept-encoding))
header fields can be sent in a response to indicate preferred media types
and content codings for subsequent requests to that resource.[¶](#section-12.3-1)

Similarly, [Section 3.1](https://www.rfc-editor.org/rfc/rfc5789#section-3.1) of [[RFC5789](#RFC5789)] defines
the "Accept-Patch" response header field, which allows discovery of
which content types are accepted in PATCH requests.[¶](#section-12.3-2)

### [12.4.](#section-12.4) [Content Negotiation Field Features](#name-content-negotiation-field-f)

#### [12.4.1.](#section-12.4.1) [Absence](#name-absence)

For each of the content negotiation fields, a request that does not contain
the field implies that the sender has no preference on that dimension of
negotiation.[¶](#section-12.4.1-1)

If a content negotiation header field is present in a request and none of
the available
representations for the response can be considered acceptable according to
it, the origin server can either honor the header field by sending a
[406 (Not Acceptable)](#status.406) response or disregard the header field
by treating the response as if it is not subject to content negotiation
for that request header field. This does not imply, however, that the
client will be able to use the representation.[¶](#section-12.4.1-2)

**Note:** A user agent sending these header fields makes it easier for a
server to identify an individual by virtue of the user agent's request
characteristics ([Section 17.13](#fingerprinting)).[¶](#section-12.4.1-3.1)

#### [12.4.2.](#section-12.4.2) [Quality Values](#name-quality-values)

The content negotiation fields defined by this specification
use a common parameter, named "q" (case-insensitive), to assign a relative
"weight" to the preference for that associated kind of content.
This weight is referred to as a "quality value" (or "qvalue") because
the same parameter name is often used within server configurations to
assign a weight to the relative quality of the various representations
that can be selected for a resource.[¶](#section-12.4.2-1)

The weight is normalized to a real number in the range 0 through 1,
where 0.001 is the least preferred and 1 is the most preferred;
a value of 0 means "not acceptable". If no "q" parameter is present,
the default weight is 1.[¶](#section-12.4.2-2)

```
  weight = OWS ";" OWS "q=" qvalue
  qvalue = ( "0" [ "." 0*3DIGIT ] )
         / ( "1" [ "." 0*3("0") ] )

```
[¶](#section-12.4.2-3)

A sender of qvalue MUST NOT generate more than three digits after the
decimal point. User configuration of these values ought to be limited in
the same fashion.[¶](#section-12.4.2-4)

#### [12.4.3.](#section-12.4.3) [Wildcard Values](#name-wildcard-values)

Most of these header fields, where indicated, define a wildcard value ("\*")
to select unspecified values. If no wildcard is present, values that are
not explicitly mentioned in the field are considered unacceptable.
Within [Vary](#field.vary), the wildcard value means that the variance
is unlimited.[¶](#section-12.4.3-1)

**Note:** In practice, using wildcards in content negotiation has limited
practical value because it is seldom useful to say, for example, "I
prefer image/\* more or less than (some other specific value)". By sending Accept: \*/\*;q=0, clients can
explicitly request a [406 (Not Acceptable)](#status.406) response if a
more preferred format is not available, but
they still need to be able to handle a different response since the
server is allowed to ignore their preference.[¶](#section-12.4.3-2.1)

### [12.5.](#section-12.5) [Content Negotiation Fields](#name-content-negotiation-fields)

#### [12.5.1.](#section-12.5.1) [Accept](#name-accept)

The "Accept" header field can be used by user agents to specify their
preferences regarding response media types. For example, Accept header
fields can be used to indicate that the request is specifically limited to
a small set of desired types, as in the case of a request for an in-line
image.[¶](#section-12.5.1-1)

When sent by a server in a response, Accept provides information
about which content types are preferred in the content of a subsequent
request to the same resource.[¶](#section-12.5.1-2)

```
  Accept = #( media-range [ weight ] )

  media-range    = ( "*/*"
                     / ( type "/" "*" )
                     / ( type "/" subtype )
                   ) parameters

```
[¶](#section-12.5.1-3)

The asterisk "\*" character is used to group media types into ranges,
with "\*/\*" indicating all media types and "type/\*" indicating all
subtypes of that type. The media-range can include media type
parameters that are applicable to that range.[¶](#section-12.5.1-4)

Each media-range might be followed by optional applicable media type
parameters (e.g., [charset](#charset)), followed by an optional "q"
parameter for indicating a relative weight ([Section 12.4.2](#quality.values)).[¶](#section-12.5.1-5)

Previous specifications allowed additional extension parameters to appear
after the weight parameter. The accept extension grammar (accept-params, accept-ext) has
been removed because it had a complicated definition, was not being used in
practice, and is more easily deployed through new header fields. Senders
using weights SHOULD send "q" last (after all media-range parameters).
Recipients SHOULD process any parameter named "q" as weight, regardless of
parameter ordering.[¶](#section-12.5.1-6)

**Note:** Use of the "q" parameter name to control content negotiation
would interfere with any media type parameter having the same name.
Hence, the media type registry disallows parameters named "q".[¶](#section-12.5.1-7.1)

The example[¶](#section-12.5.1-8)

```
Accept: audio/*; q=0.2, audio/basic

```
[¶](#section-12.5.1-9)

is interpreted as "I prefer audio/basic, but send me any audio
type if it is the best available after an 80% markdown in quality".[¶](#section-12.5.1-10)

A more elaborate example is[¶](#section-12.5.1-11)

```
Accept: text/plain; q=0.5, text/html,
       text/x-dvi; q=0.8, text/x-c

```
[¶](#section-12.5.1-12)

Verbally, this would be interpreted as "text/html and text/x-c are
the equally preferred media types, but if they do not exist, then send the
text/x-dvi representation, and if that does not exist, send the text/plain
representation".[¶](#section-12.5.1-13)

Media ranges can be overridden by more specific media ranges or
specific media types. If more than one media range applies to a given
type, the most specific reference has precedence. For example,[¶](#section-12.5.1-14)

```
Accept: text/*, text/plain, text/plain;format=flowed, */*

```
[¶](#section-12.5.1-15)

have the following precedence:[¶](#section-12.5.1-16)

1. text/plain;format=flowed[¶](#section-12.5.1-17.1)
2. text/plain[¶](#section-12.5.1-17.2)
3. text/\*[¶](#section-12.5.1-17.3)
4. \*/\*[¶](#section-12.5.1-17.4)

The media type quality factor associated with a given type is
determined by finding the media range with the highest precedence
that matches the type. For example,[¶](#section-12.5.1-18)

```
Accept: text/*;q=0.3, text/plain;q=0.7, text/plain;format=flowed,
       text/plain;format=fixed;q=0.4, */*;q=0.5

```
[¶](#section-12.5.1-19)

would cause the following values to be associated:[¶](#section-12.5.1-20)

[Table 5](#table-5)
| Media Type | Quality Value |
| --- | --- |
| text/plain;format=flowed | 1 |
| text/plain | 0.7 |
| text/html | 0.3 |
| image/jpeg | 0.5 |
| text/plain;format=fixed | 0.4 |
| text/html;level=3 | 0.7 |

**Note:** A user agent might be provided with a default set of quality
values for certain media ranges. However, unless the user agent is
a closed system that cannot interact with other rendering agents,
this default set ought to be configurable by the user.[¶](#section-12.5.1-22.1)

#### [12.5.2.](#section-12.5.2) [Accept-Charset](#name-accept-charset)

The "Accept-Charset" header field can be sent by a user agent to indicate
its preferences for charsets in textual response content. For example,
this field allows user agents capable of understanding more comprehensive
or special-purpose charsets to signal that capability to an origin server
that is capable of representing information in those charsets.[¶](#section-12.5.2-1)

```
  Accept-Charset = #( ( token / "*" ) [ weight ] )

```
[¶](#section-12.5.2-2)

Charset names are defined in [Section 8.3.2](#charset).
A user agent MAY associate a quality value with each charset to indicate
the user's relative preference for that charset, as defined in [Section 12.4.2](#quality.values).
An example is[¶](#section-12.5.2-3)

```
Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

```
[¶](#section-12.5.2-4)

The special value "\*", if present in the Accept-Charset header field,
matches every charset that is not mentioned elsewhere in the
field.[¶](#section-12.5.2-5)

**Note:** Accept-Charset is deprecated because UTF-8 has become nearly
ubiquitous and sending a detailed list of user-preferred charsets wastes
bandwidth, increases latency, and makes passive fingerprinting far too
easy ([Section 17.13](#fingerprinting)). Most general-purpose user agents
do not send Accept-Charset unless specifically configured to do so.[¶](#section-12.5.2-6.1)

#### [12.5.3.](#section-12.5.3) [Accept-Encoding](#name-accept-encoding)

The "Accept-Encoding" header field can be used to indicate preferences
regarding the use of content codings ([Section 8.4.1](#content.codings)).[¶](#section-12.5.3-1)

When sent by a user agent in a request, Accept-Encoding indicates the
content codings acceptable in a response.[¶](#section-12.5.3-2)

When sent by a server in a response, Accept-Encoding provides information
about which content codings are preferred in the content of a subsequent
request to the same resource.[¶](#section-12.5.3-3)

An "identity" token is used as a synonym for
"no encoding" in order to communicate when no encoding is preferred.[¶](#section-12.5.3-4)

```
  Accept-Encoding  = #( codings [ weight ] )
  codings          = content-coding / "identity" / "*"

```
[¶](#section-12.5.3-5)

Each codings value MAY be given an associated quality value (weight)
representing the preference for that encoding, as defined in [Section 12.4.2](#quality.values).
The asterisk "\*" symbol in an Accept-Encoding field matches any available
content coding not explicitly listed in the field.[¶](#section-12.5.3-6)

Examples:[¶](#section-12.5.3-7)

```
Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

```
[¶](#section-12.5.3-8)

A server tests whether a content coding for a given representation is
acceptable using these rules:[¶](#section-12.5.3-9)

1. If no Accept-Encoding header field is in the request, any content coding is
   considered acceptable by the user agent.[¶](#section-12.5.3-10.1)
2. If the representation has no content coding, then it is acceptable
   by default unless specifically excluded by the Accept-Encoding header field
   stating either "identity;q=0" or "\*;q=0" without a more specific
   entry for "identity".[¶](#section-12.5.3-10.2)
3. If the representation's content coding is one of the content codings
   listed in the Accept-Encoding field value, then it is acceptable unless
   it is accompanied by a qvalue of 0. (As defined in [Section 12.4.2](#quality.values), a
   qvalue of 0 means "not acceptable".)[¶](#section-12.5.3-10.3)

A representation could be encoded with multiple content codings. However, most
content codings are alternative ways to accomplish the same purpose
(e.g., data compression). When selecting between multiple content codings that
have the same purpose, the acceptable content coding with the highest
non-zero qvalue is preferred.[¶](#section-12.5.3-11)

An Accept-Encoding header field with a field value that is empty
implies that the user agent does not want any content coding in response.
If a non-empty Accept-Encoding header field is present in a request and none of the
available representations for the response have a content coding that
is listed as acceptable, the origin server SHOULD send a response
without any content coding unless the identity coding is indicated as unacceptable.[¶](#section-12.5.3-12)

When the Accept-Encoding header field is present in a response, it indicates
what content codings the resource was willing to accept in the associated
request. The field value is evaluated the same way as in a request.[¶](#section-12.5.3-13)

Note that this information is specific to the associated request; the set of
supported encodings might be different for other resources on the same
server and could change over time or depend on other aspects of the request
(such as the request method).[¶](#section-12.5.3-14)

Servers that fail a request due to an unsupported content coding ought to
respond with a [415 (Unsupported Media Type)](#status.415) status and
include an Accept-Encoding header field in that response, allowing
clients to distinguish between issues related to content codings and media
types. In order to avoid confusion with issues related to media types,
servers that fail a request with a 415 status for reasons unrelated to
content codings MUST NOT include the Accept-Encoding header
field.[¶](#section-12.5.3-15)

The most common use of Accept-Encoding is in responses with a
[415 (Unsupported Media Type)](#status.415) status code, in response to
optimistic use of a content coding by clients. However, the header field
can also be used to indicate to clients that content codings are supported in order
to optimize future interactions. For example, a resource might include it
in a [2xx (Successful)](#status.2xx) response when the request content was
big enough to justify use of a compression coding but the client failed do
so.[¶](#section-12.5.3-16)

#### [12.5.4.](#section-12.5.4) [Accept-Language](#name-accept-language)

The "Accept-Language" header field can be used by user agents to
indicate the set of natural languages that are preferred in the response.
Language tags are defined in [Section 8.5.1](#language.tags).[¶](#section-12.5.4-1)

```
  Accept-Language = #( language-range [ weight ] )
  language-range  =
            <language-range, see [RFC4647], Section 2.1>

```
[¶](#section-12.5.4-2)

Each language-range can be given an associated quality value
representing an estimate of the user's preference for the languages
specified by that range, as defined in [Section 12.4.2](#quality.values). For example,[¶](#section-12.5.4-3)

```
Accept-Language: da, en-gb;q=0.8, en;q=0.7

```
[¶](#section-12.5.4-4)

would mean: "I prefer Danish, but will accept British English and
other types of English".[¶](#section-12.5.4-5)

Note that some recipients treat the order in which language tags are listed
as an indication of descending priority, particularly for tags that are
assigned equal quality values (no value is the same as q=1). However, this
behavior cannot be relied upon. For consistency and to maximize
interoperability, many user agents assign each language tag a unique
quality value while also listing them in order of decreasing quality.
Additional discussion of language priority lists can be found in
[Section 2.3](https://www.rfc-editor.org/rfc/rfc4647#section-2.3) of [[RFC4647](#RFC4647)].[¶](#section-12.5.4-6)

For matching, [Section 3](https://www.rfc-editor.org/rfc/rfc4647#section-3) of [[RFC4647](#RFC4647)] defines
several matching schemes. Implementations can offer the most appropriate
matching scheme for their requirements. The "Basic Filtering" scheme
([[RFC4647](#RFC4647)], [Section 3.3.1](https://www.rfc-editor.org/rfc/rfc4647#section-3.3.1)) is identical to the
matching scheme that was previously defined for HTTP in
[Section 14.4](https://www.rfc-editor.org/rfc/rfc2616#section-14.4) of [[RFC2616](#RFC2616)].[¶](#section-12.5.4-7)

It might be contrary to the privacy expectations of the user to send
an Accept-Language header field with the complete linguistic preferences of
the user in every request ([Section 17.13](#fingerprinting)).[¶](#section-12.5.4-8)

Since intelligibility is highly dependent on the individual user, user
agents need to allow user control over the linguistic preference (either
through configuration of the user agent itself or by defaulting to a user
controllable system setting).
A user agent that does not provide such control to the user MUST NOT
send an Accept-Language header field.[¶](#section-12.5.4-9)

**Note:** User agents ought to provide guidance to users when setting a
preference, since users are rarely familiar with the details of language
matching as described above. For example, users might assume that on
selecting "en-gb", they will be served any kind of English document if
British English is not available. A user agent might suggest, in such a
case, to add "en" to the list for better matching behavior.[¶](#section-12.5.4-10.1)

#### [12.5.5.](#section-12.5.5) [Vary](#name-vary)

The "Vary" header field in a response describes what parts of a request
message, aside from the method and target URI, might have influenced the
origin server's process for selecting the content of this response.[¶](#section-12.5.5-1)

```
  Vary = #( "*" / field-name )

```
[¶](#section-12.5.5-2)

A Vary field value is either the wildcard member "\*" or a list of
request field names, known as the selecting header fields, that might
have had a role in selecting the representation for this response.
Potential selecting header fields are not limited to fields defined by
this specification.[¶](#section-12.5.5-3)

A list containing the member "\*" signals that other aspects of the
request might have played a role in selecting the response representation,
possibly including aspects outside the message syntax (e.g., the
client's network address).
A recipient will not be able to determine whether this response is
appropriate for a later request without forwarding the request to the
origin server. A proxy MUST NOT generate "\*" in a Vary field value.[¶](#section-12.5.5-4)

For example, a response that contains[¶](#section-12.5.5-5)

```
Vary: accept-encoding, accept-language

```
[¶](#section-12.5.5-6)

indicates that the origin server might have used the request's
[Accept-Encoding](#field.accept-encoding) and [Accept-Language](#field.accept-language)
header fields (or lack thereof) as determining factors while choosing
the content for this response.[¶](#section-12.5.5-7)

A Vary field containing a list of field names has two purposes:[¶](#section-12.5.5-8)

1. To inform cache recipients that they MUST NOT use this response
   to satisfy a later request unless the later request has the
   same values for the listed header fields as the original request
   ([Section 4.1](https://www.rfc-editor.org/rfc/rfc9111#section-4.1) of [[CACHING](#CACHING)]) or reuse of the
   response has been validated by the origin server.
   In other words, Vary expands the cache key
   required to match a new request to the stored cache entry.[¶](#section-12.5.5-9.1.1)
2. To inform user agent recipients that this response was subject to
   content negotiation ([Section 12](#content.negotiation)) and a
   different representation might be sent in a subsequent request if
   other values are provided in the listed header fields
   ([proactive negotiation](#proactive.negotiation)).[¶](#section-12.5.5-9.2.1)

An origin server SHOULD generate a Vary header field on a cacheable
response when it wishes that response to be selectively reused for
subsequent requests. Generally, that is the case when the response
content has been tailored to better fit the preferences expressed by
those selecting header fields, such as when an origin server has
selected the response's language based on the request's
[Accept-Language](#field.accept-language) header field.[¶](#section-12.5.5-10)

Vary might be elided when an origin server considers variance in
content selection to be less significant than Vary's performance impact
on caching, particularly when reuse is already limited by cache
response directives ([Section 5.2](https://www.rfc-editor.org/rfc/rfc9111#section-5.2) of [[CACHING](#CACHING)]).[¶](#section-12.5.5-11)

There is no need to send the Authorization field name in Vary because
reuse of that response for a different user is prohibited by the field
definition ([Section 11.6.2](#field.authorization)).
Likewise, if the response content has been selected or influenced by
network region, but the origin server wants the cached response to be
reused even if recipients move from one region to another, then there
is no need for the origin server to indicate such variance in Vary.[¶](#section-12.5.5-12)

## [13.](#section-13) [Conditional Requests](#name-conditional-requests)

A conditional request is an HTTP request with one or more request header
fields that indicate a precondition to be tested before
applying the request method to the target resource.
[Section 13.2](#evaluation) defines when to evaluate preconditions and
their order of precedence when more than one precondition is present.[¶](#section-13-1)

Conditional GET requests are the most efficient mechanism for HTTP
cache updates [[CACHING](#CACHING)]. Conditionals can also be
applied to state-changing methods, such as PUT and DELETE, to prevent
the "lost update" problem: one client accidentally overwriting
the work of another client that has been acting in parallel.[¶](#section-13-2)

### [13.1.](#section-13.1) [Preconditions](#name-preconditions)

Preconditions are usually defined with respect to a state of the target
resource as a whole (its current value set) or the state as observed in a
previously obtained representation (one value in that set). If a resource
has multiple current representations, each with its own observable state,
a precondition will assume that the mapping of each request to a
[selected representation](#selected.representation) ([Section 3.2](#representations))
is consistent over time.
Regardless, if the mapping is inconsistent or the server is unable to
select an appropriate representation, then no harm will result when the
precondition evaluates to false.[¶](#section-13.1-1)

Each precondition defined below consists of a comparison between a
set of validators obtained from prior representations of the target
resource to the current state of validators for the selected
representation ([Section 8.8](#response.validator)). Hence, these
preconditions evaluate whether the state of the target resource has
changed since a given state known by the client. The effect of such an
evaluation depends on the method semantics and choice of conditional, as
defined in [Section 13.2](#evaluation).[¶](#section-13.1-2)

Other preconditions, defined by other specifications as extension fields,
might place conditions on all recipients, on the state of the target
resource in general, or on a group of resources. For instance, the "If"
header field in WebDAV can make a request conditional on various aspects
of multiple resources, such as locks, if the recipient understands and
implements that field ([[WEBDAV](#WEBDAV)], [Section 10.4](https://www.rfc-editor.org/rfc/rfc4918#section-10.4)).[¶](#section-13.1-3)

Extensibility of preconditions is only possible when the precondition can
be safely ignored if unknown (like [If-Modified-Since](#field.if-modified-since)), when
deployment can be assumed for a given use case, or when implementation
is signaled by some other property of the target resource. This encourages
a focus on mutually agreed deployment of common standards.[¶](#section-13.1-4)

#### [13.1.1.](#section-13.1.1) [If-Match](#name-if-match)

The "If-Match" header field makes the request method conditional on the
recipient origin server either having at least one current
representation of the target resource, when the field value is "\*", or
having a current representation of the target resource that has an
entity tag matching a member of the list of entity tags provided in the
field value.[¶](#section-13.1.1-1)

An origin server MUST use the strong comparison function when comparing
entity tags for If-Match ([Section 8.8.3.2](#entity.tag.comparison)), since
the client intends this precondition to prevent the method from being
applied if there have been any changes to the representation data.[¶](#section-13.1.1-2)

```
  If-Match = "*" / #entity-tag

```
[¶](#section-13.1.1-3)

Examples:[¶](#section-13.1.1-4)

```
If-Match: "xyzzy"
If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-Match: *

```
[¶](#section-13.1.1-5)

If-Match is most often used with state-changing methods (e.g., POST, PUT,
DELETE) to prevent accidental overwrites when multiple user agents might be
acting in parallel on the same resource (i.e., to prevent the "lost update"
problem). In general, it can be used with any method that involves the
selection or modification of a representation to abort the request if the
[selected representation](#selected.representation)'s current entity tag is not a
member within the If-Match field value.[¶](#section-13.1.1-6)

When an origin server receives a request that selects a representation
and that request includes an If-Match header field,
the origin server MUST evaluate the If-Match condition per
[Section 13.2](#evaluation) prior to performing the method.[¶](#section-13.1.1-7)

To evaluate a received If-Match header field:[¶](#section-13.1.1-8)

1. If the field value is "\*", the condition is true if the origin server
   has a current representation for the target resource.[¶](#section-13.1.1-9.1)
2. If the field value is a list of entity tags, the condition is true if
   any of the listed tags match the entity tag of the selected representation.[¶](#section-13.1.1-9.2)
3. Otherwise, the condition is false.[¶](#section-13.1.1-9.3)

An origin server that evaluates an If-Match condition MUST NOT perform
the requested method if the condition evaluates to false. Instead,
the origin server MAY
indicate that the conditional request failed by responding with a
[412 (Precondition Failed)](#status.412) status code. Alternatively,
if the request is a state-changing operation that appears to have already
been applied to the selected representation, the origin server MAY respond
with a [2xx (Successful)](#status.2xx) status code
(i.e., the change requested by the user agent has already succeeded, but
the user agent might not be aware of it, perhaps because the prior response
was lost or an equivalent change was made by some other user agent).[¶](#section-13.1.1-10)

Allowing an origin server to send a success response when a change request
appears to have already been applied is more efficient for many authoring
use cases, but comes with some risk if multiple user agents are making
change requests that are very similar but not cooperative.
For example, multiple user agents writing to a common resource as a
semaphore (e.g., a nonatomic increment) are likely to collide and
potentially lose important state transitions. For those kinds of resources,
an origin server is better off being stringent in sending 412 for every
failed precondition on an unsafe method.
In other cases, excluding the ETag field from a success response might
encourage the user agent to perform a GET as its next request to eliminate
confusion about the resource's current state.[¶](#section-13.1.1-11)

A client MAY send an If-Match header field in a
[GET](#GET) request to indicate that it would prefer a
[412 (Precondition Failed)](#status.412) response if the selected
representation does not match. However, this is only useful in range
requests ([Section 14](#range.requests)) for completing a previously
received partial representation when there is no desire for a new
representation. [If-Range](#field.if-range) ([Section 13.1.5](#field.if-range))
is better suited for range requests when the client prefers to receive a
new representation.[¶](#section-13.1.1-12)

A cache or intermediary MAY ignore If-Match because its
interoperability features are only necessary for an origin server.[¶](#section-13.1.1-13)

Note that an If-Match header field with a list value containing "\*" and
other values (including other instances of "\*") is syntactically
invalid (therefore not allowed to be generated) and furthermore is
unlikely to be interoperable.[¶](#section-13.1.1-14)

#### [13.1.2.](#section-13.1.2) [If-None-Match](#name-if-none-match)

The "If-None-Match" header field makes the request method conditional on
a recipient cache or origin server either not having any current
representation of the target resource, when the field value is "\*", or
having a [selected representation](#selected.representation) with an entity tag that does not match any
of those listed in the field value.[¶](#section-13.1.2-1)

A recipient MUST use the weak comparison function when comparing
entity tags for If-None-Match ([Section 8.8.3.2](#entity.tag.comparison)),
since weak entity tags can be used for cache validation even if there have
been changes to the representation data.[¶](#section-13.1.2-2)

```
  If-None-Match = "*" / #entity-tag

```
[¶](#section-13.1.2-3)

Examples:[¶](#section-13.1.2-4)

```
If-None-Match: "xyzzy"
If-None-Match: W/"xyzzy"
If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
If-None-Match: *

```
[¶](#section-13.1.2-5)

If-None-Match is primarily used in conditional GET requests to enable
efficient updates of cached information with a minimum amount of
transaction overhead. When a client desires to update one or more stored
responses that have entity tags, the client SHOULD generate an
If-None-Match header field containing a list of those entity tags when
making a GET request; this allows recipient servers to send a
[304 (Not Modified)](#status.304) response to indicate when one of those
stored responses matches the selected representation.[¶](#section-13.1.2-6)

If-None-Match can also be used with a value of "\*" to prevent an unsafe
request method (e.g., PUT) from inadvertently modifying an existing
representation of the target resource when the client believes that
the resource does not have a current representation ([Section 9.2.1](#safe.methods)).
This is a variation on the "lost update" problem that might arise if more
than one client attempts to create an initial representation for the target
resource.[¶](#section-13.1.2-7)

When an origin server receives a request that selects a representation
and that request includes an If-None-Match header field,
the origin server MUST evaluate the If-None-Match condition per
[Section 13.2](#evaluation) prior to performing the method.[¶](#section-13.1.2-8)

To evaluate a received If-None-Match header field:[¶](#section-13.1.2-9)

1. If the field value is "\*", the condition is false if the origin server
   has a current representation for the target resource.[¶](#section-13.1.2-10.1)
2. If the field value is a list of entity tags, the condition is false if
   one of the listed tags matches the entity tag of the selected representation.[¶](#section-13.1.2-10.2)
3. Otherwise, the condition is true.[¶](#section-13.1.2-10.3)

An origin server that evaluates an If-None-Match condition MUST NOT
perform the requested method if the condition evaluates to false; instead,
the origin server MUST respond with either
a) the [304 (Not Modified)](#status.304) status code if the request method
is GET or HEAD or b) the [412 (Precondition Failed)](#status.412) status
code for all other request methods.[¶](#section-13.1.2-11)

Requirements on cache handling of a received If-None-Match header field
are defined in [Section 4.3.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.3.2) of [[CACHING](#CACHING)].[¶](#section-13.1.2-12)

Note that an If-None-Match header field with a list value containing "\*" and
other values (including other instances of "\*") is syntactically
invalid (therefore not allowed to be generated) and furthermore is
unlikely to be interoperable.[¶](#section-13.1.2-13)

#### [13.1.3.](#section-13.1.3) [If-Modified-Since](#name-if-modified-since)

The "If-Modified-Since" header field makes a GET or HEAD request method
conditional on the [selected representation](#selected.representation)'s modification
date being more
recent than the date provided in the field value. Transfer of the selected
representation's data is avoided if that data has not changed.[¶](#section-13.1.3-1)

```
  If-Modified-Since = HTTP-date

```
[¶](#section-13.1.3-2)

An example of the field is:[¶](#section-13.1.3-3)

```
If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

```
[¶](#section-13.1.3-4)

A recipient MUST ignore If-Modified-Since if the request contains an
[If-None-Match](#field.if-none-match) header field; the condition in
[If-None-Match](#field.if-none-match) is considered to be a more accurate
replacement for the condition in If-Modified-Since, and the two are only
combined for the sake of interoperating with older intermediaries that
might not implement [If-None-Match](#field.if-none-match).[¶](#section-13.1.3-5)

A recipient MUST ignore the If-Modified-Since header field if the
received field value is not a valid HTTP-date, the field value has more than
one member, or if the request method is neither GET nor HEAD.[¶](#section-13.1.3-6)

A recipient MUST ignore the If-Modified-Since header field if the
resource does not have a modification date available.[¶](#section-13.1.3-7)

A recipient MUST interpret an If-Modified-Since field value's timestamp
in terms of the origin server's clock.[¶](#section-13.1.3-8)

If-Modified-Since is typically used for two distinct purposes:
1) to allow efficient updates of a cached representation that does not
have an entity tag and 2) to limit the scope of a web traversal to resources
that have recently changed.[¶](#section-13.1.3-9)

When used for cache updates, a cache will typically use the value of the
cached message's [Last-Modified](#field.last-modified) header field to generate the field
value of If-Modified-Since. This behavior is most interoperable for cases
where clocks are poorly synchronized or when the server has chosen to only
honor exact timestamp matches (due to a problem with Last-Modified dates
that appear to go "back in time" when the origin server's clock is
corrected or a representation is restored from an archived backup).
However, caches occasionally generate the field value based on other data,
such as the [Date](#field.date) header field of the cached message or the
clock time at which the message was received, particularly when the
cached message does not contain a [Last-Modified](#field.last-modified) header field.[¶](#section-13.1.3-10)

When used for limiting the scope of retrieval to a recent time window, a
user agent will generate an If-Modified-Since field value based on either
its own clock or a [Date](#field.date) header field received from the
server in a prior response. Origin servers that choose an exact
timestamp match based on the selected representation's
[Last-Modified](#field.last-modified)
header field will not be able to help the user agent limit its data
transfers to only those changed during the specified window.[¶](#section-13.1.3-11)

When an origin server receives a request that selects a representation
and that request includes an If-Modified-Since header field without an
[If-None-Match](#field.if-none-match) header field, the origin server SHOULD
evaluate the If-Modified-Since condition per
[Section 13.2](#evaluation) prior to performing the method.[¶](#section-13.1.3-12)

To evaluate a received If-Modified-Since header field:[¶](#section-13.1.3-13)

1. If the selected representation's last modification date is earlier or
   equal to the date provided in the field value, the condition is false.[¶](#section-13.1.3-14.1)
2. Otherwise, the condition is true.[¶](#section-13.1.3-14.2)

An origin server that evaluates an If-Modified-Since condition
SHOULD NOT perform the requested method if the condition evaluates to
false; instead,
the origin server SHOULD generate a [304 (Not Modified)](#status.304)
response, including only those metadata that are useful for identifying or
updating a previously cached response.[¶](#section-13.1.3-15)

Requirements on cache handling of a received If-Modified-Since header field
are defined in [Section 4.3.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.3.2) of [[CACHING](#CACHING)].[¶](#section-13.1.3-16)

#### [13.1.4.](#section-13.1.4) [If-Unmodified-Since](#name-if-unmodified-since)

The "If-Unmodified-Since" header field makes the request method conditional
on the [selected representation](#selected.representation)'s last modification date being
earlier than or equal to the date provided in the field value.
This field accomplishes the
same purpose as [If-Match](#field.if-match) for cases where the user agent does
not have an entity tag for the representation.[¶](#section-13.1.4-1)

```
  If-Unmodified-Since = HTTP-date

```
[¶](#section-13.1.4-2)

An example of the field is:[¶](#section-13.1.4-3)

```
If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

```
[¶](#section-13.1.4-4)

A recipient MUST ignore If-Unmodified-Since if the request contains an
[If-Match](#field.if-match) header field; the condition in
[If-Match](#field.if-match) is considered to be a more accurate replacement for
the condition in If-Unmodified-Since, and the two are only combined for the
sake of interoperating with older intermediaries that might not implement
[If-Match](#field.if-match).[¶](#section-13.1.4-5)

A recipient MUST ignore the If-Unmodified-Since header field if the
received field value is not a valid HTTP-date (including when the field
value appears to be a list of dates).[¶](#section-13.1.4-6)

A recipient MUST ignore the If-Unmodified-Since header field if the
resource does not have a modification date available.[¶](#section-13.1.4-7)

A recipient MUST interpret an If-Unmodified-Since field value's timestamp
in terms of the origin server's clock.[¶](#section-13.1.4-8)

If-Unmodified-Since is most often used with state-changing methods
(e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple
user agents might be acting in parallel on a resource that does
not supply entity tags with its representations (i.e., to prevent the
"lost update" problem).
In general, it can be used with any method that involves the selection
or modification of a representation to abort the request if the
[selected representation](#selected.representation)'s last modification date has
changed since the date provided in the If-Unmodified-Since field value.[¶](#section-13.1.4-9)

When an origin server receives a request that selects a representation
and that request includes an If-Unmodified-Since header field without
an [If-Match](#field.if-match) header field,
the origin server MUST evaluate the If-Unmodified-Since condition per
[Section 13.2](#evaluation) prior to performing the method.[¶](#section-13.1.4-10)

To evaluate a received If-Unmodified-Since header field:[¶](#section-13.1.4-11)

1. If the selected representation's last modification date is earlier than or
   equal to the date provided in the field value, the condition is true.[¶](#section-13.1.4-12.1)
2. Otherwise, the condition is false.[¶](#section-13.1.4-12.2)

An origin server that evaluates an If-Unmodified-Since condition MUST NOT
perform the requested method if the condition evaluates to false.
Instead, the origin server MAY indicate that the conditional request
failed by responding with a [412 (Precondition Failed)](#status.412)
status code. Alternatively, if the request is a state-changing operation
that appears to have already been applied to the selected representation,
the origin server MAY respond with a [2xx (Successful)](#status.2xx)
status code
(i.e., the change requested by the user agent has already succeeded, but
the user agent might not be aware of it, perhaps because the prior response
was lost or an equivalent change was made by some other user agent).[¶](#section-13.1.4-13)

Allowing an origin server to send a success response when a change request
appears to have already been applied is more efficient for many authoring
use cases, but comes with some risk if multiple user agents are making
change requests that are very similar but not cooperative.
In those cases, an origin server is better off being stringent in sending
412 for every failed precondition on an unsafe method.[¶](#section-13.1.4-14)

A client MAY send an If-Unmodified-Since header field in a
[GET](#GET) request to indicate that it would prefer a
[412 (Precondition Failed)](#status.412) response if the selected
representation has been modified. However, this is only useful in range
requests ([Section 14](#range.requests)) for completing a previously
received partial representation when there is no desire for a new
representation. [If-Range](#field.if-range) ([Section 13.1.5](#field.if-range))
is better suited for range requests when the client prefers to receive a
new representation.[¶](#section-13.1.4-15)

A cache or intermediary MAY ignore If-Unmodified-Since because its
interoperability features are only necessary for an origin server.[¶](#section-13.1.4-16)

#### [13.1.5.](#section-13.1.5) [If-Range](#name-if-range)

The "If-Range" header field provides a special conditional request
mechanism that is similar to the [If-Match](#field.if-match) and
[If-Unmodified-Since](#field.if-unmodified-since) header fields but that instructs the
recipient to ignore the [Range](#field.range) header field if the validator
doesn't match, resulting in transfer of the new [selected representation](#selected.representation)
instead of a [412 (Precondition Failed)](#status.412) response.[¶](#section-13.1.5-1)

If a client has a partial copy of a representation and wishes
to have an up-to-date copy of the entire representation, it could use the
[Range](#field.range) header field with a conditional GET (using
either or both of [If-Unmodified-Since](#field.if-unmodified-since) and
[If-Match](#field.if-match).) However, if the precondition fails because the
representation has been modified, the client would then have to make a
second request to obtain the entire current representation.[¶](#section-13.1.5-2)

The "If-Range" header field allows a client to "short-circuit" the second
request. Informally, its meaning is as follows: if the representation is unchanged,
send me the part(s) that I am requesting in Range; otherwise, send me the
entire representation.[¶](#section-13.1.5-3)

```
  If-Range = entity-tag / HTTP-date

```
[¶](#section-13.1.5-4)

A valid [entity-tag](#field.etag) can be distinguished from a valid
[HTTP-date](#http.date) by examining the first three characters for a
DQUOTE.[¶](#section-13.1.5-5)

A client MUST NOT generate an If-Range header field in a request that
does not contain a [Range](#field.range) header field.
A server MUST ignore an If-Range header field received in a request that
does not contain a [Range](#field.range) header field.
An origin server MUST ignore an If-Range header field received in a
request for a target resource that does not support Range requests.[¶](#section-13.1.5-6)

A client MUST NOT generate an If-Range header field containing an
entity tag that is marked as weak.
A client MUST NOT generate an If-Range header field containing an
[HTTP-date](#http.date) unless the client has no entity tag for
the corresponding representation and the date is a strong validator
in the sense defined by [Section 8.8.2.2](#lastmod.comparison).[¶](#section-13.1.5-7)

A server that receives an If-Range header field on a Range request MUST
evaluate the condition per [Section 13.2](#evaluation) prior to
performing the method.[¶](#section-13.1.5-8)

To evaluate a received If-Range header field containing an
[HTTP-date](#http.date):[¶](#section-13.1.5-9)

1. If the [HTTP-date](#http.date) validator provided is not a
   strong validator in the sense defined by
   [Section 8.8.2.2](#lastmod.comparison), the condition is false.[¶](#section-13.1.5-10.1)
2. If the [HTTP-date](#http.date) validator provided exactly matches
   the [Last-Modified](#field.last-modified) field value for the selected
   representation, the condition is true.[¶](#section-13.1.5-10.2)
3. Otherwise, the condition is false.[¶](#section-13.1.5-10.3)

To evaluate a received If-Range header field containing an
[entity-tag](#field.etag):[¶](#section-13.1.5-11)

1. If the [entity-tag](#field.etag) validator provided exactly matches
   the [ETag](#field.etag) field value for the selected representation
   using the strong comparison function
   ([Section 8.8.3.2](#entity.tag.comparison)), the condition is true.[¶](#section-13.1.5-12.1)
2. Otherwise, the condition is false.[¶](#section-13.1.5-12.2)

A recipient of an If-Range header field MUST ignore the
[Range](#field.range) header field if the If-Range condition
evaluates to false. Otherwise, the recipient SHOULD process the
[Range](#field.range) header field as requested.[¶](#section-13.1.5-13)

Note that the If-Range comparison is by exact match, including when the
validator is an [HTTP-date](#http.date), and so it
differs from the "earlier than or equal to" comparison used when evaluating
an [If-Unmodified-Since](#field.if-unmodified-since) conditional.[¶](#section-13.1.5-14)

### [13.2.](#section-13.2) [Evaluation of Preconditions](#name-evaluation-of-preconditions)

#### [13.2.1.](#section-13.2.1) [When to Evaluate](#name-when-to-evaluate)

Except when excluded below, a recipient cache or origin server MUST
evaluate received request preconditions after it has successfully performed
its normal request checks and just before it would process the request content
(if any) or perform the action associated with the request method.
A server MUST ignore all received preconditions if its response to the
same request without those conditions, prior to processing the request content,
would have been a status code other than a [2xx (Successful)](#status.2xx)
or [412 (Precondition Failed)](#status.412).
In other words, redirects and failures that can be detected before
significant processing occurs take precedence over the evaluation
of preconditions.[¶](#section-13.2.1-1)

A server that is not the origin server for the target resource and cannot
act as a cache for requests on the target resource MUST NOT evaluate the
conditional request header fields defined by this specification, and it
MUST forward them if the request is forwarded, since the generating
client intends that they be evaluated by a server that can provide a
current representation.
Likewise, a server MUST ignore the conditional request header fields
defined by this specification when received with a request method that does
not involve the selection or modification of a
[selected representation](#selected.representation), such as CONNECT, OPTIONS, or TRACE.[¶](#section-13.2.1-2)

Note that protocol extensions can modify the conditions under which
preconditions are evaluated or the consequences of their evaluation.
For example, the immutable cache directive
(defined by [[RFC8246](#RFC8246)]) instructs caches to forgo
forwarding conditional requests when they hold a fresh response.[¶](#section-13.2.1-3)

Although conditional request header fields are defined as being usable with
the HEAD method (to keep HEAD's semantics consistent with those of GET),
there is no point in sending a conditional HEAD because a successful
response is around the same size as a [304 (Not Modified)](#status.304)
response and more useful than a [412 (Precondition Failed)](#status.412)
response.[¶](#section-13.2.1-4)

#### [13.2.2.](#section-13.2.2) [Precedence of Preconditions](#name-precedence-of-preconditions)

When more than one conditional request header field is present in a request,
the order in which the fields are evaluated becomes important. In practice,
the fields defined in this document are consistently implemented in a
single, logical order, since "lost update" preconditions have more strict
requirements than cache validation, a validated cache is more efficient
than a partial response, and entity tags are presumed to be more accurate
than date validators.[¶](#section-13.2.2-1)

A recipient cache or origin server MUST evaluate the request
preconditions defined by this specification in the following order:[¶](#section-13.2.2-2)

1. When recipient is the origin server and
   [If-Match](#field.if-match) is present,
   evaluate the [If-Match](#field.if-match) precondition:[¶](#section-13.2.2-3.1.1)

   * if true, continue to step [3](#precedence3)[¶](#section-13.2.2-3.1.2.1)
   * if false, respond [412 (Precondition Failed)](#status.412) unless
     it can be determined that the state-changing request has already
     succeeded (see [Section 13.1.1](#field.if-match))[¶](#section-13.2.2-3.1.2.2)
2. When recipient is the origin server,
   [If-Match](#field.if-match) is not present, and
   [If-Unmodified-Since](#field.if-unmodified-since) is present,
   evaluate the [If-Unmodified-Since](#field.if-unmodified-since) precondition:[¶](#section-13.2.2-3.2.1)

   * if true, continue to step [3](#precedence3)[¶](#section-13.2.2-3.2.2.1)
   * if false, respond [412 (Precondition Failed)](#status.412) unless
     it can be determined that the state-changing request has already
     succeeded (see [Section 13.1.4](#field.if-unmodified-since))[¶](#section-13.2.2-3.2.2.2)
3. When [If-None-Match](#field.if-none-match) is present,
   evaluate the [If-None-Match](#field.if-none-match) precondition:[¶](#section-13.2.2-3.3.1)

   * if true, continue to step [5](#precedence5)[¶](#section-13.2.2-3.3.2.1)
   * if false for GET/HEAD, respond [304 (Not Modified)](#status.304)[¶](#section-13.2.2-3.3.2.2)
   * if false for other methods, respond [412 (Precondition Failed)](#status.412)[¶](#section-13.2.2-3.3.2.3)
4. When the method is GET or HEAD,
   [If-None-Match](#field.if-none-match) is not present, and
   [If-Modified-Since](#field.if-modified-since) is present,
   evaluate the [If-Modified-Since](#field.if-modified-since) precondition:[¶](#section-13.2.2-3.4.1)

   * if true, continue to step [5](#precedence5)[¶](#section-13.2.2-3.4.2.1)
   * if false, respond [304 (Not Modified)](#status.304)[¶](#section-13.2.2-3.4.2.2)
5. When the method is GET and both
   [Range](#field.range) and [If-Range](#field.if-range) are present,
   evaluate the [If-Range](#field.if-range) precondition:[¶](#section-13.2.2-3.5.1)

   * if true and the [Range](#field.range) is
     applicable to the [selected representation](#selected.representation),
     respond [206 (Partial Content)](#status.206)[¶](#section-13.2.2-3.5.2.1)
   * otherwise, ignore the [Range](#field.range) header field
     and respond [200 (OK)](#status.200)[¶](#section-13.2.2-3.5.2.2)
6. Otherwise,[¶](#section-13.2.2-3.6.1)

   * perform the requested method and
     respond according to its success or failure.[¶](#section-13.2.2-3.6.2.1)

Any extension to HTTP that defines additional conditional request
header fields ought to define the order
for evaluating such fields in relation to those defined in this document
and other conditionals that might be found in practice.[¶](#section-13.2.2-4)

## [14.](#section-14) [Range Requests](#name-range-requests)

Clients often encounter interrupted data
transfers as a result of canceled requests or dropped connections. When a
client has stored a partial representation, it is desirable to request the
remainder of that representation in a subsequent request rather than
transfer the entire representation. Likewise, devices with limited local
storage might benefit from being able to request only a subset of a larger
representation, such as a single page of a very large document, or the
dimensions of an embedded image.[¶](#section-14-1)

Range requests are an OPTIONAL feature
of HTTP, designed so that recipients not implementing this feature (or not
supporting it for the target resource) can respond as if it is a normal
GET request without impacting interoperability. Partial responses are
indicated by a distinct status code to not be mistaken for full responses
by caches that might not implement the feature.[¶](#section-14-2)

### [14.1.](#section-14.1) [Range Units](#name-range-units)

Representation data can be partitioned into subranges when there are
addressable structural units inherent to that data's content coding or
media type. For example, octet (a.k.a. byte) boundaries are a structural
unit common to all representation data, allowing partitions of the data to
be identified as a range of bytes at some offset from the start or end of
that data.[¶](#section-14.1-1)

This general notion of a "range unit" is used
in the [Accept-Ranges](#field.accept-ranges) ([Section 14.3](#field.accept-ranges))
response header field to advertise support for range requests, the
[Range](#field.range) ([Section 14.2](#field.range)) request header field
to delineate the parts of a representation that are requested, and the
[Content-Range](#field.content-range) ([Section 14.4](#field.content-range))
header field to describe which part of a representation is being
transferred.[¶](#section-14.1-2)

```
  range-unit       = token

```
[¶](#section-14.1-3)

All range unit names are case-insensitive and ought to be registered
within the "HTTP Range Unit Registry", as defined in
[Section 16.5.1](#range.unit.registry).[¶](#section-14.1-4)

Range units are intended to be extensible, as described in
[Section 16.5](#range.unit.extensibility).[¶](#section-14.1-5)

#### [14.1.1.](#section-14.1.1) [Range Specifiers](#name-range-specifiers)

Ranges are expressed in terms of a range unit paired with a set of range
specifiers. The range unit name determines what kinds of range-spec
are applicable to its own specifiers. Hence, the following grammar is
generic: each range unit is expected to specify requirements on when
[int-range](#rule.int-range), [suffix-range](#rule.suffix-range), and
[other-range](#rule.other-range) are allowed.[¶](#section-14.1.1-1)

A range request can specify a single range or a set
of ranges within a single representation.[¶](#section-14.1.1-2)

```
  ranges-specifier = range-unit "=" range-set
  range-set        = 1#range-spec
  range-spec       = int-range
                   / suffix-range
                   / other-range

```
[¶](#section-14.1.1-3)

An [int-range](#rule.int-range) is a range expressed as two non-negative
integers or as one non-negative integer through to the end of the
representation data.
The range unit specifies what the integers mean (e.g., they might indicate
unit offsets from the beginning, inclusive numbered parts, etc.).[¶](#section-14.1.1-4)

```
  int-range     = first-pos "-" [ last-pos ]
  first-pos     = 1*DIGIT
  last-pos      = 1*DIGIT

```
[¶](#section-14.1.1-5)

An [int-range](#rule.int-range) is invalid if the
[last-pos](#rule.int-range) value is present and less than the
[first-pos](#rule.int-range).[¶](#section-14.1.1-6)

A [suffix-range](#rule.suffix-range) is a range expressed as a suffix of the
representation data with the provided non-negative integer maximum length
(in range units). In other words, the last N units of the representation
data.[¶](#section-14.1.1-7)

```
  suffix-range  = "-" suffix-length
  suffix-length = 1*DIGIT

```
[¶](#section-14.1.1-8)

To provide for extensibility, the [other-range](#rule.other-range) rule is a
mostly unconstrained grammar that allows application-specific or future
range units to define additional range specifiers.[¶](#section-14.1.1-9)

```
  other-range   = 1*( %x21-2B / %x2D-7E )
                ; 1*(VCHAR excluding comma)

```
[¶](#section-14.1.1-10)

A [ranges-specifier](#rule.ranges-specifier) is invalid if it contains any
[range-spec](#rule.ranges-specifier) that is invalid or undefined for the indicated
[range-unit](#range.units).[¶](#section-14.1.1-11)

A valid [ranges-specifier](#rule.ranges-specifier) is "satisfiable"
if it contains at least one [range-spec](#rule.ranges-specifier) that is
satisfiable, as defined by the indicated [range-unit](#range.units).
Otherwise, the [ranges-specifier](#rule.ranges-specifier) is
"unsatisfiable".[¶](#section-14.1.1-12)

#### [14.1.2.](#section-14.1.2) [Byte Ranges](#name-byte-ranges)

The "bytes" range unit is used to express subranges of a representation
data's octet sequence.
Each byte range is expressed as an integer range at some offset, relative
to either the beginning ([int-range](#rule.int-range)) or end
([suffix-range](#rule.suffix-range)) of the representation data.
Byte ranges do not use the [other-range](#rule.other-range) specifier.[¶](#section-14.1.2-1)

The [first-pos](#rule.int-range) value in a bytes [int-range](#rule.int-range)
gives the offset of the first byte in a range.
The [last-pos](#rule.int-range) value gives the offset of the last
byte in the range; that is, the byte positions specified are inclusive.
Byte offsets start at zero.[¶](#section-14.1.2-2)

If the representation data has a content coding applied, each byte range is
calculated with respect to the encoded sequence of bytes, not the sequence
of underlying bytes that would be obtained after decoding.[¶](#section-14.1.2-3)

Examples of bytes range specifiers:[¶](#section-14.1.2-4)

* The first 500 bytes (byte offsets 0-499, inclusive):[¶](#section-14.1.2-5.1.1)

  ```

       bytes=0-499

  ```
  [¶](#section-14.1.2-5.1.2)
* The second 500 bytes (byte offsets 500-999, inclusive):[¶](#section-14.1.2-5.2.1)

  ```

       bytes=500-999

  ```
  [¶](#section-14.1.2-5.2.2)

A client can limit the number of bytes requested without knowing the size
of the [selected representation](#selected.representation).
If the [last-pos](#rule.int-range) value is absent, or if the value is
greater than or equal to the current length of the representation data, the
byte range is interpreted as the remainder of the representation (i.e., the
server replaces the value of [last-pos](#rule.int-range) with a value that
is one less than the current length of the selected representation).[¶](#section-14.1.2-6)

A client can refer to the last N bytes (N > 0) of the selected
representation using a [suffix-range](#rule.suffix-range).
If the selected representation is shorter than the specified
[suffix-length](#rule.suffix-range), the entire representation is used.[¶](#section-14.1.2-7)

Additional examples, assuming a representation of length 10000:[¶](#section-14.1.2-8)

* The final 500 bytes (byte offsets 9500-9999, inclusive):[¶](#section-14.1.2-9.1.1)

  ```

       bytes=-500

  ```
  [¶](#section-14.1.2-9.1.2)

  Or:[¶](#section-14.1.2-9.1.3)

  ```

       bytes=9500-

  ```
  [¶](#section-14.1.2-9.1.4)
* The first and last bytes only (bytes 0 and 9999):[¶](#section-14.1.2-9.2.1)

  ```

       bytes=0-0,-1

  ```
  [¶](#section-14.1.2-9.2.2)
* The first, middle, and last 1000 bytes:[¶](#section-14.1.2-9.3.1)

  ```

       bytes= 0-999, 4500-5499, -1000

  ```
  [¶](#section-14.1.2-9.3.2)
* Other valid (but not canonical) specifications of the second 500
  bytes (byte offsets 500-999, inclusive):[¶](#section-14.1.2-9.4.1)

  ```

       bytes=500-600,601-999
       bytes=500-700,601-999

  ```
  [¶](#section-14.1.2-9.4.2)

For a [GET](#GET) request, a valid bytes [range-spec](#rule.ranges-specifier)
is [satisfiable](#satisfiable) if it is either:[¶](#section-14.1.2-10)

* an [int-range](#rule.int-range) with a [first-pos](#rule.int-range) that
  is less than the current length of the selected representation
  or[¶](#section-14.1.2-11.1)
* a [suffix-range](#rule.suffix-range) with a non-zero
  [suffix-length](#rule.suffix-range).[¶](#section-14.1.2-11.2)

When a selected representation has zero length, the only
[satisfiable](#satisfiable) form of [range-spec](#rule.ranges-specifier) in a
[GET](#GET) request is a [suffix-range](#rule.suffix-range) with a
non-zero [suffix-length](#rule.suffix-range).[¶](#section-14.1.2-12)

In the byte-range syntax, [first-pos](#rule.int-range),
[last-pos](#rule.int-range), and [suffix-length](#rule.suffix-range) are
expressed as decimal number of octets. Since there is no predefined limit
to the length of content, recipients MUST anticipate potentially
large decimal numerals and prevent parsing errors due to integer conversion
overflows.[¶](#section-14.1.2-13)

### [14.2.](#section-14.2) [Range](#name-range)

The "Range" header field on a GET request modifies the method semantics to
request transfer of only one or more subranges of the
selected representation data ([Section 8.1](#representation.data)),
rather than the entire [selected representation](#selected.representation).[¶](#section-14.2-1)

```
  Range = ranges-specifier

```
[¶](#section-14.2-2)

A server MAY ignore the Range header field. However, origin servers and
intermediate caches ought to support byte ranges when possible, since they
support efficient recovery from partially failed transfers and partial
retrieval of large representations.[¶](#section-14.2-3)

A server MUST ignore a Range header field received with a request method
that is unrecognized or for which range handling is not defined. For this
specification, [GET](#GET) is the only method for which range handling
is defined.[¶](#section-14.2-4)

An origin server MUST ignore a Range header field that contains a range
unit it does not understand. A proxy MAY discard a Range header
field that contains a range unit it does not understand.[¶](#section-14.2-5)

A server that supports range requests MAY ignore or reject a
[Range](#field.range) header field that contains an invalid
[ranges-specifier](#rule.ranges-specifier) ([Section 14.1.1](#range.specifiers)),
a [ranges-specifier](#rule.ranges-specifier) with more than two overlapping ranges,
or a set of many small ranges that are not listed in ascending order,
since these are indications of either a broken client or a deliberate
denial-of-service attack ([Section 17.15](#overlapping.ranges)).
A client SHOULD NOT request multiple ranges that are inherently less
efficient to process and transfer than a single range that encompasses the
same data.[¶](#section-14.2-6)

A server that supports range requests MAY ignore a [Range](#field.range)
header field when the selected representation has no content
(i.e., the selected representation's data is of zero length).[¶](#section-14.2-7)

A client that is requesting multiple ranges SHOULD list those ranges in
ascending order (the order in which they would typically be received in a
complete representation) unless there is a specific need to request a later
part earlier. For example, a user agent processing a large representation
with an internal catalog of parts might need to request later parts first,
particularly if the representation consists of pages stored in reverse
order and the user agent wishes to transfer one page at a time.[¶](#section-14.2-8)

The Range header field is evaluated after evaluating the precondition header
fields defined in [Section 13.1](#preconditions), and only if the result in absence
of the Range header field would be a [200 (OK)](#status.200) response. In
other words, Range is ignored when a conditional GET would result in a
[304 (Not Modified)](#status.304) response.[¶](#section-14.2-9)

The If-Range header field ([Section 13.1.5](#field.if-range)) can be used as
a precondition to applying the Range header field.[¶](#section-14.2-10)

If all of the preconditions are true, the server supports the Range header
field for the target resource, the received Range field-value contains a
valid [ranges-specifier](#rule.ranges-specifier) with a [range-unit](#range.units)
supported for that target resource, and that
[ranges-specifier](#rule.ranges-specifier) is [satisfiable](#satisfiable) with respect
to the selected representation,
the server SHOULD send a [206 (Partial Content)](#status.206) response
with content containing one or more partial representations
that correspond to the satisfiable [range-spec](#rule.ranges-specifier)(s) requested.[¶](#section-14.2-11)

The above does not imply that a server will send all requested ranges.
In some cases, it may only be possible (or efficient) to send a portion of
the requested ranges first, while expecting the client to re-request the
remaining portions later if they are still desired
(see [Section 15.3.7](#status.206)).[¶](#section-14.2-12)

If all of the preconditions are true, the server supports the Range header
field for the target resource, the received Range field-value contains a
valid [ranges-specifier](#rule.ranges-specifier), and either the
[range-unit](#range.units) is not supported for that target resource or
the [ranges-specifier](#rule.ranges-specifier) is unsatisfiable with respect to
the selected representation, the server SHOULD send a
[416 (Range Not Satisfiable)](#status.416) response.[¶](#section-14.2-13)

### [14.3.](#section-14.3) [Accept-Ranges](#name-accept-ranges)

The "Accept-Ranges" field in a response indicates whether an upstream
server supports range requests for the target resource.[¶](#section-14.3-1)

```
  Accept-Ranges     = acceptable-ranges
  acceptable-ranges = 1#range-unit

```
[¶](#section-14.3-2)

For example, a server that supports
[byte-range requests](#byte.ranges) ([Section 14.1.2](#byte.ranges)) can send the field[¶](#section-14.3-3)

```
Accept-Ranges: bytes

```
[¶](#section-14.3-4)

to indicate that it supports byte range requests for that target resource,
thereby encouraging its use by the client for future partial requests on
the same request path.
Range units are defined in [Section 14.1](#range.units).[¶](#section-14.3-5)

A client MAY generate range requests regardless of having received an
Accept-Ranges field. The information only provides advice for the sake of
improving performance and reducing unnecessary network transfers.[¶](#section-14.3-6)

Conversely, a client MUST NOT assume that receiving an Accept-Ranges field
means that future range requests will return partial responses. The content might
change, the server might only support range requests at certain times or under
certain conditions, or a different intermediary might process the next request.[¶](#section-14.3-7)

A server that does not support any kind of range request for the target
resource MAY send[¶](#section-14.3-8)

```
Accept-Ranges: none

```
[¶](#section-14.3-9)

to advise the client not to attempt a range request on the same request path.
The range unit "none" is reserved for this purpose.[¶](#section-14.3-10)

The Accept-Ranges field MAY be sent in a trailer section, but is preferred
to be sent as a header field because the information is particularly useful
for restarting large information transfers that have failed in mid-content
(before the trailer section is received).[¶](#section-14.3-11)

### [14.4.](#section-14.4) [Content-Range](#name-content-range)

The "Content-Range" header field is sent in a single part
[206 (Partial Content)](#status.206) response to indicate the partial range
of the [selected representation](#selected.representation) enclosed as the message content, sent in
each part of a multipart 206 response to indicate the range enclosed within
each body part ([Section 14.6](#multipart.byteranges)), and sent in [416 (Range Not Satisfiable)](#status.416)
responses to provide information about the selected representation.[¶](#section-14.4-1)

```
  Content-Range       = range-unit SP
                        ( range-resp / unsatisfied-range )

  range-resp          = incl-range "/" ( complete-length / "*" )
  incl-range          = first-pos "-" last-pos
  unsatisfied-range   = "*/" complete-length

  complete-length     = 1*DIGIT

```
[¶](#section-14.4-2)

If a [206 (Partial Content)](#status.206) response contains a
[Content-Range](#field.content-range) header field with a [range unit](#range.units)
([Section 14.1](#range.units)) that the recipient does not understand, the
recipient MUST NOT attempt to recombine it with a stored representation.
A proxy that receives such a message SHOULD forward it downstream.[¶](#section-14.4-3)

Content-Range might also be sent as a request modifier to request a
partial PUT, as described in [Section 14.5](#partial.PUT), based on private
agreements between client and origin server.
A server MUST ignore a Content-Range header field received in a request
with a method for which Content-Range support is not defined.[¶](#section-14.4-4)

For byte ranges, a sender SHOULD indicate the complete length of the
representation from which the range has been extracted, unless the complete
length is unknown or difficult to determine. An asterisk character ("\*") in
place of the complete-length indicates that the representation length was
unknown when the header field was generated.[¶](#section-14.4-5)

The following example illustrates when the complete length of the selected
representation is known by the sender to be 1234 bytes:[¶](#section-14.4-6)

```
Content-Range: bytes 42-1233/1234

```
[¶](#section-14.4-7)

and this second example illustrates when the complete length is unknown:[¶](#section-14.4-8)

```
Content-Range: bytes 42-1233/*

```
[¶](#section-14.4-9)

A Content-Range field value is invalid if it contains a
[range-resp](#field.content-range) that has a [last-pos](#rule.int-range)
value less than its [first-pos](#rule.int-range) value, or a
[complete-length](#field.content-range) value less than or equal to its
[last-pos](#rule.int-range) value. The recipient of an invalid
[Content-Range](#field.content-range)
MUST NOT attempt to recombine the received
content with a stored representation.[¶](#section-14.4-10)

A server generating a [416 (Range Not Satisfiable)](#status.416) response
to a byte-range request SHOULD send a Content-Range header field with an
[unsatisfied-range](#field.content-range) value, as in the following example:[¶](#section-14.4-11)

```
Content-Range: bytes */1234

```
[¶](#section-14.4-12)

The complete-length in a 416 response indicates the current length of the
selected representation.[¶](#section-14.4-13)

The Content-Range header field has no meaning for status codes that do
not explicitly describe its semantic. For this specification, only the
[206 (Partial Content)](#status.206) and
[416 (Range Not Satisfiable)](#status.416) status codes describe a meaning
for Content-Range.[¶](#section-14.4-14)

The following are examples of Content-Range values in which the
selected representation contains a total of 1234 bytes:[¶](#section-14.4-15)

* The first 500 bytes:[¶](#section-14.4-16.1.1)

  ```
  Content-Range: bytes 0-499/1234

  ```
  [¶](#section-14.4-16.1.2)
* The second 500 bytes:[¶](#section-14.4-16.2.1)

  ```
  Content-Range: bytes 500-999/1234

  ```
  [¶](#section-14.4-16.2.2)
* All except for the first 500 bytes:[¶](#section-14.4-16.3.1)

  ```
  Content-Range: bytes 500-1233/1234

  ```
  [¶](#section-14.4-16.3.2)
* The last 500 bytes:[¶](#section-14.4-16.4.1)

  ```
  Content-Range: bytes 734-1233/1234

  ```
  [¶](#section-14.4-16.4.2)

### [14.5.](#section-14.5) [Partial PUT](#name-partial-put)

Some origin servers support [PUT](#PUT) of a partial representation
when the user agent sends a [Content-Range](#field.content-range) header field
([Section 14.4](#field.content-range)) in the request, though
such support is inconsistent and depends on private agreements with
user agents. In general, it requests that the state of the
[target resource](#target.resource) be partly replaced with the enclosed content
at an offset and length indicated by the Content-Range value, where the
offset is relative to the current selected representation.[¶](#section-14.5-1)

An origin server SHOULD respond with a [400 (Bad Request)](#status.400)
status code if it receives [Content-Range](#field.content-range) on a PUT for a
target resource that does not support partial PUT requests.[¶](#section-14.5-2)

Partial PUT is not backwards compatible with the original definition of PUT.
It may result in the content being written as a complete replacement for the
current representation.[¶](#section-14.5-3)

Partial resource updates are also possible by targeting a separately
identified resource with state that overlaps or extends a portion of the
larger resource, or by using a different method that has been specifically
defined for partial updates (for example, the PATCH method defined in
[[RFC5789](#RFC5789)]).[¶](#section-14.5-4)

### [14.6.](#section-14.6) [Media Type multipart/byteranges](#name-media-type-multipart-bytera)

When a [206 (Partial Content)](#status.206) response message includes the
content of multiple ranges, they are transmitted as body parts in a
multipart message body ([[RFC2046](#RFC2046)], [Section 5.1](https://www.rfc-editor.org/rfc/rfc2046#section-5.1))
with the media type of "multipart/byteranges".[¶](#section-14.6-1)

The "multipart/byteranges" media type includes one or more body parts, each
with its own [Content-Type](#field.content-type) and [Content-Range](#field.content-range)
fields. The required boundary parameter specifies the boundary string used
to separate each body part.[¶](#section-14.6-2)

Implementation Notes:[¶](#section-14.6-3)

1. Additional CRLFs might precede the first boundary string in the body.[¶](#section-14.6-4.1)
2. Although [[RFC2046](#RFC2046)] permits the boundary string to be
   quoted, some existing implementations handle a quoted boundary
   string incorrectly.[¶](#section-14.6-4.2)
3. A number of clients and servers were coded to an early draft
   of the byteranges specification that used a media type of
   "multipart/x-byteranges",
   which is almost (but not quite) compatible with this type.[¶](#section-14.6-4.3)

Despite the name, the "multipart/byteranges" media type is not limited to
byte ranges. The following example uses an "exampleunit" range unit:[¶](#section-14.6-5)

```
HTTP/1.1 206 Partial Content
Date: Tue, 14 Nov 1995 06:25:24 GMT
Last-Modified: Tue, 14 July 04:58:08 GMT
Content-Length: 2331785
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: video/example
Content-Range: exampleunit 1.2-4.3/25

...the first range...
--THIS_STRING_SEPARATES
Content-Type: video/example
Content-Range: exampleunit 11.2-14.3/25

...the second range
--THIS_STRING_SEPARATES--

```
[¶](#section-14.6-6)

The following information serves as the registration form for the
"multipart/byteranges" media type.[¶](#section-14.6-7)

Type name:
multipart[¶](#section-14.6-8.2)

Subtype name:
byteranges[¶](#section-14.6-8.4)

Required parameters:
boundary[¶](#section-14.6-8.6)

Optional parameters:
N/A[¶](#section-14.6-8.8)

Encoding considerations:
only "7bit", "8bit", or "binary" are permitted[¶](#section-14.6-8.10)

Security considerations:
see [Section 17](#security.considerations)[¶](#section-14.6-8.12)

Interoperability considerations:
N/A[¶](#section-14.6-8.14)

Published specification:
RFC 9110 (see [Section 14.6](#multipart.byteranges))[¶](#section-14.6-8.16)

Applications that use this media type:
HTTP components supporting multiple ranges in a single request[¶](#section-14.6-8.18)

Fragment identifier considerations:
N/A[¶](#section-14.6-8.20)

Additional information:
Deprecated alias names for this type:
N/A[¶](#section-14.6-8.22.1.2)

Magic number(s):
N/A[¶](#section-14.6-8.22.1.4)

File extension(s):
N/A[¶](#section-14.6-8.22.1.6)

Macintosh file type code(s):
N/A[¶](#section-14.6-8.22.1.8)

Person and email address to contact for further information:
See Authors' Addresses section.[¶](#section-14.6-8.24)

Intended usage:
COMMON[¶](#section-14.6-8.26)

Restrictions on usage:
N/A[¶](#section-14.6-8.28)

Author:
See Authors' Addresses section.[¶](#section-14.6-8.30)

Change controller:
IESG[¶](#section-14.6-8.32)

## [15.](#section-15) [Status Codes](#name-status-codes)

The status code of a response is a three-digit integer code that describes
the result of the request and the semantics of the response, including
whether the request was successful and what content is enclosed (if any).
All valid status codes are within the range of 100 to 599, inclusive.[¶](#section-15-1)

The first digit of the status code defines the class of response. The
last two digits do not have any categorization role. There are five
values for the first digit:[¶](#section-15-2)

* [1xx (Informational)](#status.1xx): The request was received, continuing
  process[¶](#section-15-3.1)
* [2xx (Successful)](#status.2xx): The request was successfully received,
  understood, and accepted[¶](#section-15-3.2)
* [3xx (Redirection)](#status.3xx): Further action needs to be taken in order to
  complete the request[¶](#section-15-3.3)
* [4xx (Client Error)](#status.4xx): The request contains bad syntax or cannot
  be fulfilled[¶](#section-15-3.4)
* [5xx (Server Error)](#status.5xx): The server failed to fulfill an apparently
  valid request[¶](#section-15-3.5)

HTTP status codes are extensible. A client is not required to understand
the meaning of all registered status codes, though such understanding is
obviously desirable. However, a client MUST understand the class of any
status code, as indicated by the first digit, and treat an unrecognized
status code as being equivalent to the x00 status code of that class.[¶](#section-15-4)

For example, if a client receives an unrecognized status code of 471,
it can see from the first digit that there was something wrong with its
request and treat the response as if it had received a
[400 (Bad Request)](#status.400) status code. The response
message will usually contain a representation that explains the status.[¶](#section-15-5)

Values outside the range 100..599 are invalid. Implementations often use
three-digit integer values outside of that range (i.e., 600..999) for
internal communication of non-HTTP status (e.g., library errors). A client
that receives a response with an invalid status code SHOULD process the
response as if it had a [5xx (Server Error)](#status.5xx) status code.[¶](#section-15-6)

A single request can have multiple associated responses: zero or more
"interim" (non-final) responses with status codes in the
"informational" ([1xx](#status.1xx)) range, followed by exactly one
"final" response with a status code in one of the other ranges.[¶](#section-15-7)

### [15.1.](#section-15.1) [Overview of Status Codes](#name-overview-of-status-codes)

The status codes listed below are defined in this specification.
The reason phrases listed here are only recommendations -- they can be
replaced by local equivalents or left out altogether without affecting the
protocol.[¶](#section-15.1-1)

Responses with status codes that are defined as heuristically cacheable
(e.g., 200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, and 501 in this
specification) can be reused by a cache with heuristic expiration unless
otherwise indicated by the method definition or explicit cache controls
[[CACHING](#CACHING)]; all other status codes are not heuristically cacheable.[¶](#section-15.1-2)

Additional status codes, outside the scope of this specification, have been
specified for use in HTTP. All such status codes ought to be registered
within the "Hypertext Transfer Protocol (HTTP) Status Code Registry",
as described in [Section 16.2](#status.code.extensibility).[¶](#section-15.1-3)

### [15.2.](#section-15.2) [Informational 1xx](#name-informational-1xx)

The 1xx (Informational) class of status code indicates an
interim response for communicating connection status or request progress
prior to completing the requested action and sending a final response.
Since HTTP/1.0 did not define any 1xx status codes, a server MUST NOT send
a 1xx response to an HTTP/1.0 client.[¶](#section-15.2-1)

A 1xx response is terminated by the end of the header section;
it cannot contain content or trailers.[¶](#section-15.2-2)

A client MUST be able to parse one or more 1xx responses received
prior to a final response, even if the client does not expect one.
A user agent MAY ignore unexpected 1xx responses.[¶](#section-15.2-3)

A proxy MUST forward 1xx responses unless the proxy itself
requested the generation of the 1xx response. For example, if a
proxy adds an "Expect: 100-continue" header field when it forwards a request,
then it need not forward the corresponding [100 (Continue)](#status.100)
response(s).[¶](#section-15.2-4)

#### [15.2.1.](#section-15.2.1) [100 Continue](#name-100-continue)

The 100 (Continue) status code indicates that the initial
part of a request has been received and has not yet been rejected by the
server. The server intends to send a final response after the request has
been fully received and acted upon.[¶](#section-15.2.1-1)

When the request contains an [Expect](#field.expect) header field that
includes a [100-continue](#field.expect) expectation, the 100 response
indicates that the server wishes to receive the request content,
as described in [Section 10.1.1](#field.expect). The client
ought to continue sending the request and discard the 100 response.[¶](#section-15.2.1-2)

If the request did not contain an [Expect](#field.expect) header field
containing the [100-continue](#field.expect) expectation,
the client can simply discard this interim response.[¶](#section-15.2.1-3)

#### [15.2.2.](#section-15.2.2) [101 Switching Protocols](#name-101-switching-protocols)

The 101 (Switching Protocols) status code indicates that the
server understands and is willing to comply with the client's request,
via the [Upgrade](#field.upgrade) header field ([Section 7.8](#field.upgrade)), for
a change in the application protocol being used on this connection.
The server MUST generate an Upgrade header field in the response that
indicates which protocol(s) will be in effect after this response.[¶](#section-15.2.2-1)

It is assumed that the server will only agree to switch protocols when
it is advantageous to do so. For example, switching to a newer version of
HTTP might be advantageous over older versions, and switching to a
real-time, synchronous protocol might be advantageous when delivering
resources that use such features.[¶](#section-15.2.2-2)

### [15.3.](#section-15.3) [Successful 2xx](#name-successful-2xx)

The 2xx (Successful) class of status code indicates that
the client's request was successfully received, understood, and accepted.[¶](#section-15.3-1)

#### [15.3.1.](#section-15.3.1) [200 OK](#name-200-ok)

The 200 (OK) status code indicates that the request has
succeeded. The content sent in a 200 response depends on the request
method. For the methods defined by this specification, the intended meaning
of the content can be summarized as:[¶](#section-15.3.1-1)

[Table 6](#table-6)
| Request Method | Response content is a representation of: |
| --- | --- |
| GET | the [target resource](#target.resource) |
| HEAD | the [target resource](#target.resource), like GET, but without transferring the representation data |
| POST | the status of, or results obtained from, the action |
| PUT, DELETE | the status of the action |
| OPTIONS | communication options for the target resource |
| TRACE | the request message as received by the server returning the trace |

Aside from responses to CONNECT, a 200 response is expected to contain
message content unless the message framing explicitly indicates that the
content has zero length. If some aspect of the request indicates a
preference for no content upon success, the origin server ought to send a
204 (No Content) response instead.
For CONNECT, there is no content because the successful result is a
tunnel, which begins immediately after the 200 response header section.[¶](#section-15.3.1-3)

A 200 response is heuristically cacheable; i.e., unless otherwise indicated by
the method definition or explicit cache controls (see [Section 4.2.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.2.2) of [[CACHING](#CACHING)]).[¶](#section-15.3.1-4)

In 200 responses to GET or HEAD, an origin server SHOULD send any
available validator fields ([Section 8.8](#response.validator)) for the
[selected representation](#selected.representation), with both a strong entity tag and
a [Last-Modified](#field.last-modified) date being preferred.[¶](#section-15.3.1-5)

In 200 responses to state-changing methods, any validator fields
([Section 8.8](#response.validator)) sent in the response convey the
current validators for the new representation formed as a result of
successfully applying the request semantics. Note that the PUT method
([Section 9.3.4](#PUT)) has additional requirements that might preclude
sending such validators.[¶](#section-15.3.1-6)

#### [15.3.2.](#section-15.3.2) [201 Created](#name-201-created)

The 201 (Created) status code indicates that the request has
been fulfilled and has resulted in one or more new resources being created.
The primary resource created by the request is identified by either a
[Location](#field.location) header field in the response or, if no
[Location](#field.location) header field is received, by the target URI.[¶](#section-15.3.2-1)

The 201 response content typically describes and links to the resource(s)
created. Any validator fields ([Section 8.8](#response.validator))
sent in the response convey the current validators for a new
representation created by the request. Note that the PUT method
([Section 9.3.4](#PUT)) has additional requirements that might preclude
sending such validators.[¶](#section-15.3.2-2)

#### [15.3.3.](#section-15.3.3) [202 Accepted](#name-202-accepted)

The 202 (Accepted) status code indicates that the request
has been accepted for processing, but the processing has not been
completed. The request might or might not eventually be acted upon, as it
might be disallowed when processing actually takes place. There is no
facility in HTTP for re-sending a status code from an asynchronous
operation.[¶](#section-15.3.3-1)

The 202 response is intentionally noncommittal. Its purpose is to
allow a server to accept a request for some other process (perhaps a
batch-oriented process that is only run once per day) without
requiring that the user agent's connection to the server persist
until the process is completed. The representation sent with this
response ought to describe the request's current status and point to
(or embed) a status monitor that can provide the user with an estimate of
when the request will be fulfilled.[¶](#section-15.3.3-2)

#### [15.3.4.](#section-15.3.4) [203 Non-Authoritative Information](#name-203-non-authoritative-infor)

The 203 (Non-Authoritative Information) status code
indicates that the request was successful but the enclosed content has been
modified from that of the origin server's [200 (OK)](#status.200) response
by a transforming proxy ([Section 7.7](#message.transformations)). This status code allows the
proxy to notify recipients when a transformation has been applied, since
that knowledge might impact later decisions regarding the content. For
example, future cache validation requests for the content might only be
applicable along the same request path (through the same proxies).[¶](#section-15.3.4-1)

A 203 response is heuristically cacheable; i.e., unless otherwise indicated by
the method definition or explicit cache controls (see [Section 4.2.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.2.2) of [[CACHING](#CACHING)]).[¶](#section-15.3.4-2)

#### [15.3.5.](#section-15.3.5) [204 No Content](#name-204-no-content)

The 204 (No Content) status code indicates that the server
has successfully fulfilled the request and that there is no additional
content to send in the response content. Metadata in the response
header fields refer to the [target resource](#target.resource) and its
[selected representation](#selected.representation) after the requested action was applied.[¶](#section-15.3.5-1)

For example, if a 204 status code is received in response to a PUT
request and the response contains an [ETag](#field.etag) field, then
the PUT was successful and the ETag field value contains the entity tag for
the new representation of that target resource.[¶](#section-15.3.5-2)

The 204 response allows a server to indicate that the action has been
successfully applied to the target resource, while implying that the
user agent does not need to traverse away from its current "document view"
(if any). The server assumes that the user agent will provide some
indication of the success to its user, in accord with its own interface,
and apply any new or updated metadata in the response to its active
representation.[¶](#section-15.3.5-3)

For example, a 204 status code is commonly used with document editing
interfaces corresponding to a "save" action, such that the document
being saved remains available to the user for editing. It is also
frequently used with interfaces that expect automated data transfers
to be prevalent, such as within distributed version control systems.[¶](#section-15.3.5-4)

A 204 response is terminated by the end of the header section;
it cannot contain content or trailers.[¶](#section-15.3.5-5)

A 204 response is heuristically cacheable; i.e., unless otherwise indicated by
the method definition or explicit cache controls (see [Section 4.2.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.2.2) of [[CACHING](#CACHING)]).[¶](#section-15.3.5-6)

#### [15.3.6.](#section-15.3.6) [205 Reset Content](#name-205-reset-content)

The 205 (Reset Content) status code indicates that the
server has fulfilled the request and desires that the user agent reset the
"document view", which caused the request to be sent, to its original state
as received from the origin server.[¶](#section-15.3.6-1)

This response is intended to support a common data entry use case where
the user receives content that supports data entry (a form, notepad,
canvas, etc.), enters or manipulates data in that space, causes the entered
data to be submitted in a request, and then the data entry mechanism is
reset for the next entry so that the user can easily initiate another
input action.[¶](#section-15.3.6-2)

Since the 205 status code implies that no additional content will be
provided, a server MUST NOT generate content in a 205 response.[¶](#section-15.3.6-3)

#### [15.3.7.](#section-15.3.7) [206 Partial Content](#name-206-partial-content)

The 206 (Partial Content) status code indicates that the
server is successfully fulfilling a range request for the target resource
by transferring one or more parts of the
[selected representation](#selected.representation).[¶](#section-15.3.7-1)

A server that supports range requests ([Section 14](#range.requests)) will
usually attempt to satisfy all of the requested ranges, since sending
less data will likely result in another client request for the remainder.
However, a server might want to send only a subset of the data requested
for reasons of its own, such as temporary unavailability, cache efficiency,
load balancing, etc. Since a 206 response is self-descriptive, the client
can still understand a response that only partially satisfies its range
request.[¶](#section-15.3.7-2)

A client MUST inspect a 206 response's [Content-Type](#field.content-type) and
[Content-Range](#field.content-range) field(s) to determine what parts are enclosed
and whether additional requests are needed.[¶](#section-15.3.7-3)

A server that generates a 206 response MUST generate the following
header fields, in addition to those required in the subsections below,
if the field would
have been sent in a [200 (OK)](#status.200) response to the same request:
[Date](#field.date), Cache-Control, [ETag](#field.etag),
Expires, [Content-Location](#field.content-location), and
[Vary](#field.vary).[¶](#section-15.3.7-4)

A [Content-Length](#field.content-length) header field present in a 206 response
indicates the number of octets in the content of this message, which is
usually not the complete length of the selected representation.
Each [Content-Range](#field.content-range) header field includes information about the
selected representation's complete length.[¶](#section-15.3.7-5)

A sender that generates a 206 response to a request with an [If-Range](#field.if-range)
header field SHOULD NOT generate other representation header
fields beyond those required because the client
already has a prior response containing those header fields.
Otherwise, a sender MUST generate all of the representation header
fields that would have been sent in a [200 (OK)](#status.200) response
to the same request.[¶](#section-15.3.7-6)

A 206 response is heuristically cacheable; i.e., unless otherwise indicated by
explicit cache controls (see [Section 4.2.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.2.2) of [[CACHING](#CACHING)]).[¶](#section-15.3.7-7)

##### [15.3.7.1.](#section-15.3.7.1) [Single Part](#name-single-part)

If a single part is being transferred, the server generating the 206
response MUST generate a [Content-Range](#field.content-range) header field,
describing what range of the selected representation is enclosed, and a
content consisting of the range. For example:[¶](#section-15.3.7.1-1)

```
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Range: bytes 21010-47021/47022
Content-Length: 26012
Content-Type: image/gif

... 26012 bytes of partial image data ...

```
[¶](#section-15.3.7.1-2)

##### [15.3.7.2.](#section-15.3.7.2) [Multiple Parts](#name-multiple-parts)

If multiple parts are being transferred, the server generating the 206
response MUST generate "multipart/byteranges" content, as defined
in [Section 14.6](#multipart.byteranges), and a
[Content-Type](#field.content-type) header field containing the
"multipart/byteranges" media type and its required boundary parameter.
To avoid confusion with single-part responses, a server MUST NOT generate
a [Content-Range](#field.content-range) header field in the HTTP header section of a
multiple part response (this field will be sent in each part instead).[¶](#section-15.3.7.2-1)

Within the header area of each body part in the multipart content, the
server MUST generate a [Content-Range](#field.content-range) header field
corresponding to the range being enclosed in that body part.
If the selected representation would have had a [Content-Type](#field.content-type)
header field in a [200 (OK)](#status.200) response, the server SHOULD
generate that same [Content-Type](#field.content-type) header field in the header area of
each body part. For example:[¶](#section-15.3.7.2-2)

```
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Length: 1741
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 500-999/8000

...the first range...
--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 7000-7999/8000

...the second range
--THIS_STRING_SEPARATES--

```
[¶](#section-15.3.7.2-3)

When multiple ranges are requested, a server MAY coalesce any of the
ranges that overlap, or that are separated by a gap that is smaller than the
overhead of sending multiple parts, regardless of the order in which the
corresponding range-spec appeared in the received [Range](#field.range)
header field. Since the typical overhead between each part of a
"multipart/byteranges" is around 80 bytes, depending on the selected
representation's media type and the chosen boundary parameter length, it
can be less efficient to transfer many small disjoint parts than it is to
transfer the entire selected representation.[¶](#section-15.3.7.2-4)

A server MUST NOT generate a multipart response to a request for a single
range, since a client that does not request multiple parts might not
support multipart responses. However, a server MAY generate a
"multipart/byteranges" response with only a single body part if multiple
ranges were requested and only one range was found to be satisfiable or
only one range remained after coalescing.
A client that cannot process a "multipart/byteranges" response MUST NOT
generate a request that asks for multiple ranges.[¶](#section-15.3.7.2-5)

A server that generates a multipart response SHOULD send
the parts in the same order that the corresponding range-spec appeared
in the received [Range](#field.range) header field, excluding those ranges
that were deemed unsatisfiable or that were coalesced into other ranges.
A client that receives a multipart response MUST inspect the
[Content-Range](#field.content-range) header field present in each body part in
order to determine which range is contained in that body part; a client
cannot rely on receiving the same ranges that it requested, nor the same
order that it requested.[¶](#section-15.3.7.2-6)

##### [15.3.7.3.](#section-15.3.7.3) [Combining Parts](#name-combining-parts)

A response might transfer only a subrange of a representation if the
connection closed prematurely or if the request used one or more Range
specifications. After several such transfers, a client might have
received several ranges of the same representation. These ranges can only
be safely combined if they all have in common the same strong validator
([Section 8.8.1](#weak.and.strong.validators)).[¶](#section-15.3.7.3-1)

A client that has received multiple partial responses to GET requests on a
target resource MAY combine those responses into a larger continuous
range if they share the same strong validator.[¶](#section-15.3.7.3-2)

If the most recent response is an incomplete [200 (OK)](#status.200)
response, then the header fields of that response are used for any
combined response and replace those of the matching stored responses.[¶](#section-15.3.7.3-3)

If the most recent response is a [206 (Partial Content)](#status.206)
response and at least one of the matching stored responses is a
[200 (OK)](#status.200), then the combined response header fields consist
of the most recent 200 response's header fields. If all of the matching
stored responses are 206 responses, then the stored response with the most
recent header fields is used as the source of header fields for the
combined response, except that the client MUST use other header fields
provided in the new response, aside from [Content-Range](#field.content-range), to
replace all instances of the corresponding header fields in the stored
response.[¶](#section-15.3.7.3-4)

The combined response content consists of the union of partial content
ranges within the new response and all of the matching stored responses.
If the union consists of the entire range of the representation, then the
client MUST process the combined response as if it were a complete
[200 (OK)](#status.200) response, including a [Content-Length](#field.content-length)
header field that reflects the complete length.
Otherwise, the client MUST process the set of continuous ranges as one of
the following:
an incomplete [200 (OK)](#status.200) response if the combined response is
a prefix of the representation,
a single [206 (Partial Content)](#status.206) response containing
"multipart/byteranges" content, or
multiple [206 (Partial Content)](#status.206) responses, each with one
continuous range that is indicated by a [Content-Range](#field.content-range) header
field.[¶](#section-15.3.7.3-5)

### [15.4.](#section-15.4) [Redirection 3xx](#name-redirection-3xx)

The 3xx (Redirection) class of status code indicates that
further action needs to be taken by the user agent in order to fulfill the
request. There are several types of redirects:[¶](#section-15.4-1)

1. Redirects that indicate this resource might be available at a
   different URI, as provided by the [Location](#field.location) header field,
   as in the status codes [301 (Moved Permanently)](#status.301),
   [302 (Found)](#status.302), [307 (Temporary Redirect)](#status.307), and
   [308 (Permanent Redirect)](#status.308).[¶](#section-15.4-2.1)
2. Redirection that offers a choice among matching resources capable
   of representing this resource, as in the
   [300 (Multiple Choices)](#status.300) status code.[¶](#section-15.4-2.2)
3. Redirection to a different resource, identified by the
   [Location](#field.location) header field, that can represent an indirect
   response to the request, as in the [303 (See Other)](#status.303)
   status code.[¶](#section-15.4-2.3)
4. Redirection to a previously stored result, as in the
   [304 (Not Modified)](#status.304) status code.[¶](#section-15.4-2.4)

**Note:** In HTTP/1.0, the status codes [301 (Moved Permanently)](#status.301)
and [302 (Found)](#status.302) were originally defined as method-preserving
([[HTTP/1.0](#HTTP10)], [Section 9.3](https://www.rfc-editor.org/rfc/rfc1945#section-9.3)) to match their implementation
at CERN; [303 (See Other)](#status.303) was defined for a redirection that
changed its method to GET. However, early user agents split on whether to
redirect POST requests as POST (according to then-current specification)
or as GET (the safer alternative when redirected to a different site).
Prevailing practice eventually converged on changing the method to GET.
[307 (Temporary Redirect)](#status.307) and
[308 (Permanent Redirect)](#status.308)
[[RFC7538](#RFC7538)] were
later added to unambiguously indicate method-preserving redirects, and status codes
[301](#status.301) and [302](#status.302) have been adjusted to allow a POST
request to be redirected as GET.[¶](#section-15.4-3.1)

If a [Location](#field.location) header field
([Section 10.2.2](#field.location)) is provided, the user agent MAY
automatically redirect its request to the URI referenced by the Location
field value, even if the specific status code is not understood.
Automatic redirection needs to be done with care for methods not known to be
[safe](#safe.methods), as defined in [Section 9.2.1](#safe.methods), since
the user might not wish to redirect an unsafe request.[¶](#section-15.4-4)

When automatically following a redirected request, the user agent SHOULD
resend the original request message with the following modifications:[¶](#section-15.4-5)

1. Replace the target URI with the URI referenced by the redirection response's
   [Location](#field.location) header field value after resolving it relative to the original
   request's target URI.[¶](#section-15.4-6.1.1)
2. Remove header fields that were automatically generated by the implementation,
   replacing them with updated values as appropriate to the new request. This
   includes:[¶](#section-15.4-6.2.1)

   1. Connection-specific header fields (see [Section 7.6.1](#field.connection)),[¶](#section-15.4-6.2.2.1)
   2. Header fields specific to the client's proxy configuration,
      including (but not limited to) [Proxy-Authorization](#field.proxy-authorization),[¶](#section-15.4-6.2.2.2)
   3. Origin-specific header fields (if any), including (but not
      limited to) [Host](#field.host),[¶](#section-15.4-6.2.2.3)
   4. Validating header fields that were added by the implementation's
      cache (e.g., [If-None-Match](#field.if-none-match),
      [If-Modified-Since](#field.if-modified-since)), and[¶](#section-15.4-6.2.2.4)
   5. Resource-specific header fields, including (but not limited to)
      [Referer](#field.referer), Origin,
      [Authorization](#field.authorization), and Cookie.[¶](#section-15.4-6.2.2.5)
3. Consider removing header fields that were not automatically generated by the
   implementation (i.e., those present in the request because they were added
   by the calling context) where there are security implications; this
   includes but is not limited to [Authorization](#field.authorization) and Cookie.[¶](#section-15.4-6.3.1)
4. Change the request method according to the redirecting status code's
   semantics, if applicable.[¶](#section-15.4-6.4.1)
5. If the request method has been changed to GET or HEAD, remove
   content-specific header fields, including (but not limited to)
   [Content-Encoding](#field.content-encoding),
   [Content-Language](#field.content-language), [Content-Location](#field.content-location),
   [Content-Type](#field.content-type), [Content-Length](#field.content-length),
   Digest, [Last-Modified](#field.last-modified).[¶](#section-15.4-6.5.1)

A client SHOULD detect and intervene in cyclical redirections (i.e.,
"infinite" redirection loops).[¶](#section-15.4-7)

**Note:** An earlier version of this specification recommended a
maximum of five redirections ([[RFC2068](#RFC2068)], [Section 10.3](https://www.rfc-editor.org/rfc/rfc2068#section-10.3)).
Content developers need to be aware that some clients might
implement such a fixed limitation.[¶](#section-15.4-8.1)

#### [15.4.1.](#section-15.4.1) [300 Multiple Choices](#name-300-multiple-choices)

The 300 (Multiple Choices) status code indicates that the
[target resource](#target.resource) has more than one representation, each with
its own more specific identifier, and information about the alternatives is
being provided so that the user (or user agent) can select a preferred
representation by redirecting its request to one or more of those
identifiers. In other words, the server desires that the user agent engage
in reactive negotiation to select the most appropriate representation(s)
for its needs ([Section 12](#content.negotiation)).[¶](#section-15.4.1-1)

If the server has a preferred choice, the server SHOULD generate a
[Location](#field.location) header field containing a preferred choice's URI
reference. The user agent MAY use the Location field value for automatic
redirection.[¶](#section-15.4.1-2)

For request methods other than HEAD, the server SHOULD generate content
in the 300 response containing a list of representation metadata and URI
reference(s) from which the user or user agent can choose the one most
preferred. The user agent MAY make a selection from that list
automatically if it understands the provided media type. A specific format
for automatic selection is not defined by this specification because HTTP
tries to remain orthogonal to the definition of its content.
In practice, the representation is provided in some easily parsed format
believed to be acceptable to the user agent, as determined by shared design
or content negotiation, or in some commonly accepted hypertext format.[¶](#section-15.4.1-3)

A 300 response is heuristically cacheable; i.e., unless otherwise indicated by
the method definition or explicit cache controls (see [Section 4.2.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.2.2) of [[CACHING](#CACHING)]).[¶](#section-15.4.1-4)

**Note:** The original proposal for the 300 status code defined the URI header field as
providing a list of alternative representations, such that it would be
usable for 200, 300, and 406 responses and be transferred in responses to
the HEAD method. However, lack of deployment and disagreement over syntax
led to both URI and Alternates (a subsequent proposal) being dropped from
this specification. It is possible to communicate the list as a
Link header field value [[RFC8288](#RFC8288)] whose members have a relationship of
"alternate", though deployment is a chicken-and-egg problem.[¶](#section-15.4.1-5.1)

#### [15.4.2.](#section-15.4.2) [301 Moved Permanently](#name-301-moved-permanently)

The 301 (Moved Permanently) status code indicates that the
[target resource](#target.resource) has been assigned a new permanent URI and
any future references to this resource ought to use one of the enclosed
URIs. The server is suggesting that a user agent with link-editing capability
can permanently replace references to the target URI with one of the
new references sent by the server. However, this suggestion is usually
ignored unless the user agent is actively editing references
(e.g., engaged in authoring content), the connection is secured, and
the origin server is a trusted authority for the content being edited.[¶](#section-15.4.2-1)

The server SHOULD generate a [Location](#field.location) header field in the
response containing a preferred URI reference for the new permanent URI.
The user agent MAY use the Location field value for automatic redirection.
The server's response content usually contains a short hypertext note with
a hyperlink to the new URI(s).[¶](#section-15.4.2-2)

**Note:** For historical reasons, a user agent MAY change the
request method from POST to GET for the subsequent request. If this
behavior is undesired, the [308 (Permanent Redirect)](#status.308)
status code can be used instead.[¶](#section-15.4.2-3.1)

A 301 response is heuristically cacheable; i.e., unless otherwise indicated by
the method definition or explicit cache controls (see [Section 4.2.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.2.2) of [[CACHING](#CACHING)]).[¶](#section-15.4.2-4)

#### [15.4.3.](#section-15.4.3) [302 Found](#name-302-found)

The 302 (Found) status code indicates that the target
resource resides temporarily under a different URI. Since the redirection
might be altered on occasion, the client ought to continue to use the
target URI for future requests.[¶](#section-15.4.3-1)

The server SHOULD generate a [Location](#field.location) header field in the
response containing a URI reference for the different URI.
The user agent MAY use the Location field value for automatic redirection.
The server's response content usually contains a short hypertext note with
a hyperlink to the different URI(s).[¶](#section-15.4.3-2)

**Note:** For historical reasons, a user agent MAY change the
request method from POST to GET for the subsequent request. If this
behavior is undesired, the [307 (Temporary Redirect)](#status.307)
status code can be used instead.[¶](#section-15.4.3-3.1)

#### [15.4.4.](#section-15.4.4) [303 See Other](#name-303-see-other)

The 303 (See Other) status code indicates that the server is
redirecting the user agent to a different resource, as indicated by a URI
in the [Location](#field.location) header field, which is intended to provide
an indirect response to the original request. A user agent can perform a
retrieval request targeting that URI (a GET or HEAD request if using HTTP),
which might also be redirected, and present the eventual result as an
answer to the original request. Note that the new URI in the Location
header field is not considered equivalent to the target URI.[¶](#section-15.4.4-1)

This status code is applicable to any HTTP method. It is
primarily used to allow the output of a POST action to redirect
the user agent to a different resource, since doing so provides the
information corresponding to the POST response as a resource that
can be separately identified, bookmarked, and cached.[¶](#section-15.4.4-2)

A 303 response to a GET request indicates that the origin server does not
have a representation of the [target resource](#target.resource) that can be
transferred by the server over HTTP. However, the
[Location](#field.location) field value refers to a resource that is
descriptive of the target resource, such that making a retrieval request
on that other resource might result in a representation that is useful to
recipients without implying that it represents the original target resource.
Note that answers to the questions of what can be represented, what
representations are adequate, and what might be a useful description are
outside the scope of HTTP.[¶](#section-15.4.4-3)

Except for responses to a HEAD request, the representation of a 303
response ought to contain a short hypertext note with a hyperlink to the
same URI reference provided in the [Location](#field.location) header field.[¶](#section-15.4.4-4)

#### [15.4.5.](#section-15.4.5) [304 Not Modified](#name-304-not-modified)

The 304 (Not Modified) status code indicates that a
conditional GET or HEAD request has been
received and would have resulted in a [200 (OK)](#status.200) response
if it were not for the fact that the condition evaluated to false.
In other words, there is no need for the server to transfer a
representation of the target resource because the request indicates that
the client, which made the request conditional, already has a valid
representation; the server is therefore redirecting the client to make
use of that stored representation as if it were the content of a
[200 (OK)](#status.200) response.[¶](#section-15.4.5-1)

The server generating a 304 response MUST generate any of the following
header fields that would have been sent in a [200 (OK)](#status.200)
response to the same request:[¶](#section-15.4.5-2)

* [Content-Location](#field.content-location), [Date](#field.date), [ETag](#field.etag),
  and [Vary](#field.vary)[¶](#section-15.4.5-3.1)
* Cache-Control and Expires (see
  [[CACHING](#CACHING)])[¶](#section-15.4.5-3.2)

Since the goal of a 304 response is to minimize information transfer
when the recipient already has one or more cached representations,
a sender SHOULD NOT generate representation metadata other
than the above listed fields unless said metadata exists for the
purpose of guiding cache updates (e.g., [Last-Modified](#field.last-modified) might
be useful if the response does not have an [ETag](#field.etag) field).[¶](#section-15.4.5-4)

Requirements on a cache that receives a 304 response are defined in
[Section 4.3.4](https://www.rfc-editor.org/rfc/rfc9111#section-4.3.4) of [[CACHING](#CACHING)]. If the conditional request originated with an
outbound client, such as a user agent with its own cache sending a
conditional GET to a shared proxy, then the proxy SHOULD forward the
304 response to that client.[¶](#section-15.4.5-5)

A 304 response is terminated by the end of the header section;
it cannot contain content or trailers.[¶](#section-15.4.5-6)

#### [15.4.6.](#section-15.4.6) [305 Use Proxy](#name-305-use-proxy)

The 305 (Use Proxy) status code was defined in a previous
version of this specification and is now deprecated ([Appendix B](https://www.rfc-editor.org/rfc/rfc7231#appendix-B) of [[RFC7231](#RFC7231)]).[¶](#section-15.4.6-1)

#### [15.4.7.](#section-15.4.7) [306 (Unused)](#name-306-unused)

The 306 status code was defined in a previous version of this
specification, is no longer used, and the code is reserved.[¶](#section-15.4.7-1)

#### [15.4.8.](#section-15.4.8) [307 Temporary Redirect](#name-307-temporary-redirect)

The 307 (Temporary Redirect) status code indicates that the
[target resource](#target.resource) resides temporarily under a different URI
and the user agent MUST NOT change the request method if it performs an
automatic redirection to that URI.
Since the redirection can change over time, the client ought to continue
using the original target URI for future requests.[¶](#section-15.4.8-1)

The server SHOULD generate a [Location](#field.location) header field in the
response containing a URI reference for the different URI.
The user agent MAY use the Location field value for automatic redirection.
The server's response content usually contains a short hypertext note with
a hyperlink to the different URI(s).[¶](#section-15.4.8-2)

#### [15.4.9.](#section-15.4.9) [308 Permanent Redirect](#name-308-permanent-redirect)

The 308 (Permanent Redirect) status code indicates that the
[target resource](#target.resource) has been assigned a new permanent URI and
any future references to this resource ought to use one of the enclosed
URIs. The server is suggesting that a user agent with link-editing capability
can permanently replace references to the target URI with one of the
new references sent by the server. However, this suggestion is usually
ignored unless the user agent is actively editing references
(e.g., engaged in authoring content), the connection is secured, and
the origin server is a trusted authority for the content being edited.[¶](#section-15.4.9-1)

The server SHOULD generate a [Location](#field.location) header field in the
response containing a preferred URI reference for the new permanent URI.
The user agent MAY use the Location field value for automatic redirection.
The server's response content usually contains a short hypertext note with
a hyperlink to the new URI(s).[¶](#section-15.4.9-2)

A 308 response is heuristically cacheable; i.e., unless otherwise indicated by
the method definition or explicit cache controls (see [Section 4.2.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.2.2) of [[CACHING](#CACHING)]).[¶](#section-15.4.9-3)

**Note:** This status code is much younger (June 2014) than its sibling codes and thus
might not be recognized everywhere. See [Section 4](https://www.rfc-editor.org/rfc/rfc7538#section-4) of [[RFC7538](#RFC7538)]
for deployment considerations.[¶](#section-15.4.9-4.1)

### [15.5.](#section-15.5) [Client Error 4xx](#name-client-error-4xx)

The 4xx (Client Error) class of status code indicates that
the client seems to have erred. Except when responding to a HEAD request,
the server SHOULD send a representation containing an explanation of
the error situation, and whether it is a temporary or permanent condition.
These status codes are applicable to any request method. User agents
SHOULD display any included representation to the user.[¶](#section-15.5-1)

#### [15.5.1.](#section-15.5.1) [400 Bad Request](#name-400-bad-request)

The 400 (Bad Request) status code indicates that the server
cannot or will not process the request due to something that is perceived
to be a client error (e.g., malformed request syntax, invalid request
message framing, or deceptive request routing).[¶](#section-15.5.1-1)

#### [15.5.2.](#section-15.5.2) [401 Unauthorized](#name-401-unauthorized)

The 401 (Unauthorized) status code indicates that the
request has not been applied because it lacks valid authentication
credentials for the target resource.
The server generating a 401 response MUST send a
[WWW-Authenticate](#field.www-authenticate) header field
([Section 11.6.1](#field.www-authenticate))
containing at least one challenge applicable to the target resource.[¶](#section-15.5.2-1)

If the request included authentication credentials, then the 401 response
indicates that authorization has been refused for those credentials.
The user agent MAY repeat the request with a new or replaced
[Authorization](#field.authorization) header field ([Section 11.6.2](#field.authorization)).
If the 401 response contains the same challenge as the prior response, and
the user agent has already attempted authentication at least once, then the
user agent SHOULD present the enclosed representation to the user, since
it usually contains relevant diagnostic information.[¶](#section-15.5.2-2)

#### [15.5.3.](#section-15.5.3) [402 Payment Required](#name-402-payment-required)

The 402 (Payment Required) status code is reserved for
future use.[¶](#section-15.5.3-1)

#### [15.5.4.](#section-15.5.4) [403 Forbidden](#name-403-forbidden)

The 403 (Forbidden) status code indicates that the
server understood the request but refuses to fulfill it.
A server that wishes to make public why the request has been forbidden
can describe that reason in the response content (if any).[¶](#section-15.5.4-1)

If authentication credentials were provided in the request, the
server considers them insufficient to grant access.
The client SHOULD NOT automatically repeat the request with the same
credentials.
The client MAY repeat the request with new or different credentials.
However, a request might be forbidden for reasons unrelated to the
credentials.[¶](#section-15.5.4-2)

An origin server that wishes to "hide" the current existence of a forbidden
[target resource](#target.resource)
MAY instead respond with a status
code of [404 (Not Found)](#status.404).[¶](#section-15.5.4-3)

#### [15.5.5.](#section-15.5.5) [404 Not Found](#name-404-not-found)

The 404 (Not Found) status code indicates that the origin
server did not find a current representation for the
[target resource](#target.resource) or is not willing to disclose that one
exists. A 404 status code does not indicate whether this lack of representation
is temporary or permanent; the [410 (Gone)](#status.410) status code is
preferred over 404 if the origin server knows, presumably through some
configurable means, that the condition is likely to be permanent.[¶](#section-15.5.5-1)

A 404 response is heuristically cacheable; i.e., unless otherwise indicated by
the method definition or explicit cache controls (see [Section 4.2.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.2.2) of [[CACHING](#CACHING)]).[¶](#section-15.5.5-2)

#### [15.5.6.](#section-15.5.6) [405 Method Not Allowed](#name-405-method-not-allowed)

The 405 (Method Not Allowed) status code indicates that the
method received in the request-line is known by the origin server but
not supported by the [target resource](#target.resource).
The origin server MUST generate an [Allow](#field.allow) header field in
a 405 response containing a list of the target resource's currently
supported methods.[¶](#section-15.5.6-1)

A 405 response is heuristically cacheable; i.e., unless otherwise indicated by
the method definition or explicit cache controls (see [Section 4.2.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.2.2) of [[CACHING](#CACHING)]).[¶](#section-15.5.6-2)

#### [15.5.7.](#section-15.5.7) [406 Not Acceptable](#name-406-not-acceptable)

The 406 (Not Acceptable) status code indicates that the
[target resource](#target.resource) does not have a current representation that
would be acceptable to the user agent, according to the
[proactive negotiation](#proactive.negotiation) header fields received in the request
([Section 12.1](#proactive.negotiation)), and the server is unwilling to supply a
default representation.[¶](#section-15.5.7-1)

The server SHOULD generate content containing a list of available
representation characteristics and corresponding resource identifiers from
which the user or user agent can choose the one most appropriate.
A user agent MAY automatically select the most appropriate choice from
that list. However, this specification does not define any standard for
such automatic selection, as described in [Section 15.4.1](#status.300).[¶](#section-15.5.7-2)

#### [15.5.8.](#section-15.5.8) [407 Proxy Authentication Required](#name-407-proxy-authentication-re)

The 407 (Proxy Authentication Required) status code is
similar to [401 (Unauthorized)](#status.401), but it indicates that the client
needs to authenticate itself in order to use a proxy for this request.
The proxy MUST send a [Proxy-Authenticate](#field.proxy-authenticate) header field
([Section 11.7.1](#field.proxy-authenticate)) containing a challenge
applicable to that proxy for the request. The client MAY repeat
the request with a new or replaced [Proxy-Authorization](#field.proxy-authorization)
header field ([Section 11.7.2](#field.proxy-authorization)).[¶](#section-15.5.8-1)

#### [15.5.9.](#section-15.5.9) [408 Request Timeout](#name-408-request-timeout)

The 408 (Request Timeout) status code indicates
that the server did not receive a complete request message within the time
that it was prepared to wait.[¶](#section-15.5.9-1)

If the client has an outstanding request in transit, it MAY repeat that
request. If the current connection is not usable (e.g., as it would be in
HTTP/1.1 because request delimitation is lost), a new connection will be
used.[¶](#section-15.5.9-2)

#### [15.5.10.](#section-15.5.10) [409 Conflict](#name-409-conflict)

The 409 (Conflict) status code indicates that the request
could not be completed due to a conflict with the current state of the target
resource. This code is used in situations where the user might be able to
resolve the conflict and resubmit the request. The server SHOULD generate
content that includes enough information for a user to recognize the
source of the conflict.[¶](#section-15.5.10-1)

Conflicts are most likely to occur in response to a PUT request. For
example, if versioning were being used and the representation being PUT
included changes to a resource that conflict with those made by an
earlier (third-party) request, the origin server might use a 409 response
to indicate that it can't complete the request. In this case, the response
representation would likely contain information useful for merging the
differences based on the revision history.[¶](#section-15.5.10-2)

#### [15.5.11.](#section-15.5.11) [410 Gone](#name-410-gone)

The 410 (Gone) status code indicates that access to the
[target resource](#target.resource) is no longer available at the origin
server and that this condition is likely to be permanent. If the origin
server does not know, or has no facility to determine, whether or not the
condition is permanent, the status code [404 (Not Found)](#status.404)
ought to be used instead.[¶](#section-15.5.11-1)

The 410 response is primarily intended to assist the task of web
maintenance by notifying the recipient that the resource is
intentionally unavailable and that the server owners desire that
remote links to that resource be removed. Such an event is common for
limited-time, promotional services and for resources belonging to
individuals no longer associated with the origin server's site. It is not
necessary to mark all permanently unavailable resources as "gone" or
to keep the mark for any length of time -- that is left to the
discretion of the server owner.[¶](#section-15.5.11-2)

A 410 response is heuristically cacheable; i.e., unless otherwise indicated by
the method definition or explicit cache controls (see [Section 4.2.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.2.2) of [[CACHING](#CACHING)]).[¶](#section-15.5.11-3)

#### [15.5.12.](#section-15.5.12) [411 Length Required](#name-411-length-required)

The 411 (Length Required) status code indicates that the
server refuses to accept the request without a defined
[Content-Length](#field.content-length) ([Section 8.6](#field.content-length)).
The client MAY repeat the request if it adds a valid Content-Length
header field containing the length of the request content.[¶](#section-15.5.12-1)

#### [15.5.13.](#section-15.5.13) [412 Precondition Failed](#name-412-precondition-failed)

The 412 (Precondition Failed) status code indicates that one
or more conditions given in the request header fields evaluated to false
when tested on the server ([Section 13](#conditional.requests)). This
response status code allows the client to place preconditions on the
current resource state (its current representations and metadata) and,
thus, prevent the request method from being applied if the target resource
is in an unexpected state.[¶](#section-15.5.13-1)

#### [15.5.14.](#section-15.5.14) [413 Content Too Large](#name-413-content-too-large)

The 413 (Content Too Large) status code indicates
that the server is refusing to process a request because the request
content is larger than the server is willing or able to process.
The server MAY terminate the request, if the protocol version in use
allows it; otherwise, the server MAY close the connection.[¶](#section-15.5.14-1)

If the condition is temporary, the server SHOULD generate a
[Retry-After](#field.retry-after) header field to indicate that it is temporary
and after what time the client MAY try again.[¶](#section-15.5.14-2)

#### [15.5.15.](#section-15.5.15) [414 URI Too Long](#name-414-uri-too-long)

The 414 (URI Too Long) status code indicates that the server
is refusing to service the request because the
target URI is longer than the server is willing to
interpret. This rare condition is only likely to occur when a client has
improperly converted a POST request to a GET request with long query
information, when the client has descended into an infinite loop of
redirection (e.g., a redirected URI prefix that points to a suffix of
itself) or when the server is under attack by a client attempting to
exploit potential security holes.[¶](#section-15.5.15-1)

A 414 response is heuristically cacheable; i.e., unless otherwise indicated by
the method definition or explicit cache controls (see [Section 4.2.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.2.2) of [[CACHING](#CACHING)]).[¶](#section-15.5.15-2)

#### [15.5.16.](#section-15.5.16) [415 Unsupported Media Type](#name-415-unsupported-media-type)

The 415 (Unsupported Media Type) status code indicates that
the origin server is refusing to service the request because the content is
in a format not supported by this method on the [target resource](#target.resource).[¶](#section-15.5.16-1)

The format problem might be due to the request's indicated
[Content-Type](#field.content-type) or [Content-Encoding](#field.content-encoding), or as a
result of inspecting the data directly.[¶](#section-15.5.16-2)

If the problem was caused by an unsupported content coding, the
[Accept-Encoding](#field.accept-encoding) response header field
([Section 12.5.3](#field.accept-encoding)) ought to be
used to indicate which (if any) content codings would have been accepted
in the request.[¶](#section-15.5.16-3)

On the other hand, if the cause was an unsupported media type, the
[Accept](#field.accept) response header field ([Section 12.5.1](#field.accept))
can be used to indicate which media types would have been accepted
in the request.[¶](#section-15.5.16-4)

#### [15.5.17.](#section-15.5.17) [416 Range Not Satisfiable](#name-416-range-not-satisfiable)

The 416 (Range Not Satisfiable) status code indicates that
the set of ranges in the request's [Range](#field.range) header field
([Section 14.2](#field.range)) has been rejected either because none of
the requested ranges are satisfiable or because the client has requested
an excessive number of small or overlapping ranges (a potential denial of
service attack).[¶](#section-15.5.17-1)

Each range unit defines what is required for its own range sets to be
satisfiable. For example, [Section 14.1.2](#byte.ranges) defines what makes
a bytes range set satisfiable.[¶](#section-15.5.17-2)

A server that generates a 416 response to a byte-range request SHOULD
generate a [Content-Range](#field.content-range) header field
specifying the current length of the selected representation
([Section 14.4](#field.content-range)).[¶](#section-15.5.17-3)

For example:[¶](#section-15.5.17-4)

```
HTTP/1.1 416 Range Not Satisfiable
Date: Fri, 20 Jan 2012 15:41:54 GMT
Content-Range: bytes */47022

```
[¶](#section-15.5.17-5)

**Note:** Because servers are free to ignore [Range](#field.range), many
implementations will respond with the entire selected representation
in a [200 (OK)](#status.200) response. That is partly because
most clients are prepared to receive a [200 (OK)](#status.200) to
complete the task (albeit less efficiently) and partly because clients
might not stop making an invalid range request until they have received
a complete representation. Thus, clients cannot depend on receiving a
[416 (Range Not Satisfiable)](#status.416) response even when it is most
appropriate.[¶](#section-15.5.17-6.1)

#### [15.5.18.](#section-15.5.18) [417 Expectation Failed](#name-417-expectation-failed)

The 417 (Expectation Failed) status code indicates that the
expectation given in the request's [Expect](#field.expect) header field
([Section 10.1.1](#field.expect)) could not be met by at least one of the
inbound servers.[¶](#section-15.5.18-1)

#### [15.5.19.](#section-15.5.19) [418 (Unused)](#name-418-unused)

[[RFC2324](#RFC2324)] was an April 1 RFC that lampooned the various ways
HTTP was abused; one such abuse was the definition of an
application-specific 418 status code, which has been deployed as a joke
often enough for the code to be unusable for any future use.[¶](#section-15.5.19-1)

Therefore, the 418 status code is reserved in the IANA HTTP Status Code
Registry. This indicates that the status code cannot be assigned to other
applications currently. If future circumstances require its use (e.g.,
exhaustion of 4NN status codes), it can be re-assigned to another use.[¶](#section-15.5.19-2)

#### [15.5.20.](#section-15.5.20) [421 Misdirected Request](#name-421-misdirected-request)

The 421 (Misdirected Request) status code indicates that the request was
directed at a server that is unable or unwilling to produce an
authoritative response for the target URI. An origin server (or gateway
acting on behalf of the origin server) sends 421 to reject a target URI
that does not match an [origin](#origin) for which the server has been
configured ([Section 4.3.1](#origin)) or does not match the connection
context over which the request was received
([Section 7.4](#routing.reject)).[¶](#section-15.5.20-1)

A client that receives a 421 (Misdirected Request) response MAY retry the
request, whether or not the request method is idempotent, over a different
connection, such as a fresh connection specific to the target resource's
origin, or via an alternative service [[ALTSVC](#ALTSVC)].[¶](#section-15.5.20-2)

A proxy MUST NOT generate a 421 response.[¶](#section-15.5.20-3)

#### [15.5.21.](#section-15.5.21) [422 Unprocessable Content](#name-422-unprocessable-content)

The 422 (Unprocessable Content) status code indicates that the server
understands the content type of the request content (hence a
[415 (Unsupported Media Type)](#status.415) status code is inappropriate),
and the syntax of the request content is correct, but it was unable to process
the contained instructions. For example, this status code can be sent if
an XML request content contains well-formed (i.e., syntactically correct), but
semantically erroneous XML instructions.[¶](#section-15.5.21-1)

#### [15.5.22.](#section-15.5.22) [426 Upgrade Required](#name-426-upgrade-required)

The 426 (Upgrade Required) status code indicates that the
server refuses to perform the request using the current protocol but might
be willing to do so after the client upgrades to a different protocol.
The server MUST send an [Upgrade](#field.upgrade) header field in a 426
response to indicate the required protocol(s) ([Section 7.8](#field.upgrade)).[¶](#section-15.5.22-1)

Example:[¶](#section-15.5.22-2)

```
HTTP/1.1 426 Upgrade Required
Upgrade: HTTP/3.0
Connection: Upgrade
Content-Length: 53
Content-Type: text/plain

This service requires use of the HTTP/3.0 protocol.

```
[¶](#section-15.5.22-3)

### [15.6.](#section-15.6) [Server Error 5xx](#name-server-error-5xx)

The 5xx (Server Error) class of status code indicates that
the server is aware that it has erred or is incapable of performing the
requested method.
Except when responding to a HEAD request, the server SHOULD send a
representation containing an explanation of the error situation, and
whether it is a temporary or permanent condition.
A user agent SHOULD display any included representation to the user.
These status codes are applicable to any request method.[¶](#section-15.6-1)

#### [15.6.1.](#section-15.6.1) [500 Internal Server Error](#name-500-internal-server-error)

The 500 (Internal Server Error) status code indicates that
the server encountered an unexpected condition that prevented it from
fulfilling the request.[¶](#section-15.6.1-1)

#### [15.6.2.](#section-15.6.2) [501 Not Implemented](#name-501-not-implemented)

The 501 (Not Implemented) status code indicates that the
server does not support the functionality required to fulfill the request.
This is the appropriate response when the server does not recognize the
request method and is not capable of supporting it for any resource.[¶](#section-15.6.2-1)

A 501 response is heuristically cacheable; i.e., unless otherwise indicated by
the method definition or explicit cache controls (see [Section 4.2.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.2.2) of [[CACHING](#CACHING)]).[¶](#section-15.6.2-2)

#### [15.6.3.](#section-15.6.3) [502 Bad Gateway](#name-502-bad-gateway)

The 502 (Bad Gateway) status code indicates that the server,
while acting as a gateway or proxy, received an invalid response from an
inbound server it accessed while attempting to fulfill the request.[¶](#section-15.6.3-1)

#### [15.6.4.](#section-15.6.4) [503 Service Unavailable](#name-503-service-unavailable)

The 503 (Service Unavailable) status code indicates that the
server is currently unable to handle the request due to a temporary overload
or scheduled maintenance, which will likely be alleviated after some delay.
The server MAY send a [Retry-After](#field.retry-after) header field
([Section 10.2.3](#field.retry-after)) to suggest an appropriate
amount of time for the client to wait before retrying the request.[¶](#section-15.6.4-1)

**Note:** The existence of the 503 status code does not imply that a
server has to use it when becoming overloaded. Some servers might
simply refuse the connection.[¶](#section-15.6.4-2.1)

#### [15.6.5.](#section-15.6.5) [504 Gateway Timeout](#name-504-gateway-timeout)

The 504 (Gateway Timeout) status code indicates that the
server, while acting as a gateway or proxy, did not receive a timely
response from an upstream server it needed to access in order to
complete the request.[¶](#section-15.6.5-1)

#### [15.6.6.](#section-15.6.6) [505 HTTP Version Not Supported](#name-505-http-version-not-suppor)

The 505 (HTTP Version Not Supported) status code indicates
that the server does not support, or refuses to support, the major version
of HTTP that was used in the request message. The server is indicating that
it is unable or unwilling to complete the request using the same major
version as the client, as described in [Section 2.5](#protocol.version), other than with this
error message. The server SHOULD generate a representation for the 505
response that describes why that version is not supported and what other
protocols are supported by that server.[¶](#section-15.6.6-1)

## [16.](#section-16) [Extending HTTP](#name-extending-http)

HTTP defines a number of generic extension points that can be used to
introduce capabilities to the protocol without introducing a new version,
including methods, status codes, field names, and further extensibility
points within defined fields, such as authentication schemes and
cache directives (see Cache-Control extensions in [Section 5.2.3](https://www.rfc-editor.org/rfc/rfc9111#section-5.2.3) of [[CACHING](#CACHING)]). Because the semantics of HTTP are
not versioned, these extension points are persistent; the version of the
protocol in use does not affect their semantics.[¶](#section-16-1)

Version-independent extensions are discouraged from depending on or
interacting with the specific version of the protocol in use. When this is
unavoidable, careful consideration needs to be given to how the extension
can interoperate across versions.[¶](#section-16-2)

Additionally, specific versions of HTTP might have their own extensibility
points, such as transfer codings in HTTP/1.1 ([Section 6.1](https://www.rfc-editor.org/rfc/rfc9112#section-6.1) of [[HTTP/1.1](#HTTP11)]) and HTTP/2 SETTINGS or frame types
([[HTTP/2](#HTTP2)]). These extension points are specific to the
version of the protocol they occur within.[¶](#section-16-3)

Version-specific extensions cannot override or modify the semantics of
a version-independent mechanism or extension point (like a method or
header field) without explicitly being allowed by that protocol element. For
example, the CONNECT method ([Section 9.3.6](#CONNECT)) allows this.[¶](#section-16-4)

These guidelines assure that the protocol operates correctly and
predictably, even when parts of the path implement different versions of
HTTP.[¶](#section-16-5)

### [16.1.](#section-16.1) [Method Extensibility](#name-method-extensibility)

#### [16.1.1.](#section-16.1.1) [Method Registry](#name-method-registry)

The "Hypertext Transfer Protocol (HTTP) Method Registry", maintained by
IANA at <<https://www.iana.org/assignments/http-methods>>,
registers [method](#method.overview) names.[¶](#section-16.1.1-1)

HTTP method registrations MUST include the following fields:[¶](#section-16.1.1-2)

* Method Name (see [Section 9](#methods))[¶](#section-16.1.1-3.1)
* Safe ("yes" or "no", see [Section 9.2.1](#safe.methods))[¶](#section-16.1.1-3.2)
* Idempotent ("yes" or "no", see [Section 9.2.2](#idempotent.methods))[¶](#section-16.1.1-3.3)
* Pointer to specification text[¶](#section-16.1.1-3.4)

Values to be added to this namespace require IETF Review
(see [[RFC8126](#RFC8126)], [Section 4.8](https://www.rfc-editor.org/rfc/rfc8126#section-4.8)).[¶](#section-16.1.1-4)

#### [16.1.2.](#section-16.1.2) [Considerations for New Methods](#name-considerations-for-new-meth)

Standardized methods are generic; that is, they are potentially
applicable to any resource, not just one particular media type, kind of
resource, or application. As such, it is preferred that new methods
be registered in a document that isn't specific to a single application or
data format, since orthogonal technologies deserve orthogonal specification.[¶](#section-16.1.2-1)

Since message parsing ([Section 6](#message.abstraction)) needs to be
independent of method
semantics (aside from responses to HEAD), definitions of new methods
cannot change the parsing algorithm or prohibit the presence of content
on either the request or the response message.
Definitions of new methods can specify that only a zero-length content
is allowed by requiring a Content-Length header field with a value of "0".[¶](#section-16.1.2-2)

Likewise, new methods cannot use the special host:port and asterisk forms of
request target that are allowed for [CONNECT](#CONNECT) and
[OPTIONS](#OPTIONS), respectively ([Section 7.1](#target.resource)).
A full URI in absolute form is needed for the target URI, which means either
the request target needs to be sent in absolute form or the target URI will
be reconstructed from the request context in the same way it is for other
methods.[¶](#section-16.1.2-3)

A new method definition needs to indicate whether it is safe ([Section 9.2.1](#safe.methods)), idempotent ([Section 9.2.2](#idempotent.methods)),
cacheable ([Section 9.2.3](#cacheable.methods)), what
semantics are to be associated with the request content (if any), and what
refinements the method makes to header field or status code semantics.
If the new method is cacheable, its definition ought to describe how, and
under what conditions, a cache can store a response and use it to satisfy a
subsequent request.
The new method ought to describe whether it can be made conditional
([Section 13.1](#preconditions)) and, if so, how a server responds
when the condition is false.
Likewise, if the new method might have some use for partial response
semantics ([Section 14.2](#field.range)), it ought to document this, too.[¶](#section-16.1.2-4)

**Note:** Avoid defining a method name that starts with "M-", since that
prefix might be misinterpreted as having the semantics assigned to it
by [[RFC2774](#RFC2774)].[¶](#section-16.1.2-5.1)

### [16.2.](#section-16.2) [Status Code Extensibility](#name-status-code-extensibility)

#### [16.2.1.](#section-16.2.1) [Status Code Registry](#name-status-code-registry)

The "Hypertext Transfer Protocol (HTTP) Status Code Registry", maintained
by IANA at <<https://www.iana.org/assignments/http-status-codes>>,
registers status code numbers.[¶](#section-16.2.1-1)

A registration MUST include the following fields:[¶](#section-16.2.1-2)

* Status Code (3 digits)[¶](#section-16.2.1-3.1)
* Short Description[¶](#section-16.2.1-3.2)
* Pointer to specification text[¶](#section-16.2.1-3.3)

Values to be added to the HTTP status code namespace require IETF Review
(see [[RFC8126](#RFC8126)], [Section 4.8](https://www.rfc-editor.org/rfc/rfc8126#section-4.8)).[¶](#section-16.2.1-4)

#### [16.2.2.](#section-16.2.2) [Considerations for New Status Codes](#name-considerations-for-new-stat)

When it is necessary to express semantics for a response that are not
defined by current status codes, a new status code can be registered.
Status codes are generic; they are potentially applicable to any resource,
not just one particular media type, kind of resource, or application of
HTTP. As such, it is preferred that new status codes be registered in a
document that isn't specific to a single application.[¶](#section-16.2.2-1)

New status codes are required to fall under one of the categories
defined in [Section 15](#status.codes). To allow existing parsers to
process the response message, new status codes cannot disallow content,
although they can mandate a zero-length content.[¶](#section-16.2.2-2)

Proposals for new status codes that are not yet widely deployed ought to
avoid allocating a specific number for the code until there is clear
consensus that it will be registered; instead, early drafts can use a
notation such as "4NN", or "3N0" .. "3N9", to indicate the class
of the proposed status code(s) without consuming a number prematurely.[¶](#section-16.2.2-3)

The definition of a new status code ought to explain the request
conditions that would cause a response containing that status code (e.g.,
combinations of request header fields and/or method(s)) along with any
dependencies on response header fields (e.g., what fields are required,
what fields can modify the semantics, and what field semantics are
further refined when used with the new status code).[¶](#section-16.2.2-4)

By default, a status code applies only to the request corresponding to the
response it occurs within. If a status code applies to a larger scope of
applicability -- for example, all requests to the resource in question or
all requests to a server -- this must be explicitly specified. When doing
so, it should be noted that not all clients can be expected to
consistently apply a larger scope because they might not understand the
new status code.[¶](#section-16.2.2-5)

The definition of a new final status code ought to specify whether or not it
is heuristically cacheable. Note that any response with a final status code
can be cached if the response has explicit freshness information. A status
code defined as heuristically cacheable is allowed to be cached without
explicit freshness information.
Likewise, the definition of a status code can place
constraints upon cache behavior if the must-understand cache
directive is used. See [[CACHING](#CACHING)] for more information.[¶](#section-16.2.2-6)

Finally, the definition of a new status code ought to indicate whether the
content has any implied association with an identified resource ([Section 6.4.2](#identifying.content)).[¶](#section-16.2.2-7)

### [16.3.](#section-16.3) [Field Extensibility](#name-field-extensibility)

HTTP's most widely used extensibility point is the definition of new header and
trailer fields.[¶](#section-16.3-1)

New fields can be defined such that, when they are understood by a
recipient, they override or enhance the interpretation of previously
defined fields, define preconditions on request evaluation, or
refine the meaning of responses.[¶](#section-16.3-2)

However, defining a field doesn't guarantee its deployment or recognition
by recipients. Most fields are designed with the expectation that a recipient
can safely ignore (but forward downstream) any field not recognized.
In other cases, the sender's ability to understand a given field might be
indicated by its prior communication, perhaps in the protocol version
or fields that it sent in prior messages, or its use of a specific media type.
Likewise, direct inspection of support might be possible through an
OPTIONS request or by interacting with a defined well-known URI
[[RFC8615](#RFC8615)] if such inspection is defined along with
the field being introduced.[¶](#section-16.3-3)

#### [16.3.1.](#section-16.3.1) [Field Name Registry](#name-field-name-registry)

The "Hypertext Transfer Protocol (HTTP) Field Name Registry" defines the
namespace for HTTP field names.[¶](#section-16.3.1-1)

Any party can request registration of an HTTP field. See [Section 16.3.2](#considerations.for.new.fields) for considerations to take
into account when creating a new HTTP field.[¶](#section-16.3.1-2)

The "Hypertext Transfer Protocol (HTTP) Field Name Registry" is located at
<<https://www.iana.org/assignments/http-fields/>>.
Registration requests can be made by following the instructions located
there or by sending an email to the "ietf-http-wg@w3.org" mailing list.[¶](#section-16.3.1-3)

Field names are registered on the advice of a designated expert
(appointed by the IESG or their delegate). Fields with the status
'permanent' are Specification Required
([[RFC8126](#RFC8126)], [Section 4.6](https://www.rfc-editor.org/rfc/rfc8126#section-4.6)).[¶](#section-16.3.1-4)

Registration requests consist of the following information:[¶](#section-16.3.1-5)

Field name:
The requested field name. It MUST conform to the
field-name syntax defined in [Section 5.1](#fields.names), and it SHOULD be
restricted to just letters, digits, and hyphen ('-')
characters, with the first character being a letter.[¶](#section-16.3.1-6.2)

Status:
"permanent", "provisional", "deprecated", or "obsoleted".[¶](#section-16.3.1-6.4)

Specification document(s):
Reference to the document that specifies
the field, preferably including a URI that can be used to retrieve
a copy of the document. Optional but encouraged for provisional registrations.
An indication of the relevant section(s) can also be included, but is not required.[¶](#section-16.3.1-6.6)

And optionally:[¶](#section-16.3.1-7)

Comments:
Additional information, such as about reserved entries.[¶](#section-16.3.1-8.2)

The expert(s) can define additional fields to be collected in the
registry, in consultation with the community.[¶](#section-16.3.1-9)

Standards-defined names have a status of "permanent". Other names can also
be registered as permanent if the expert(s) finds that they are in use, in
consultation with the community. Other names should be registered as
"provisional".[¶](#section-16.3.1-10)

Provisional entries can be removed by the expert(s) if -- in consultation
with the community -- the expert(s) find that they are not in use. The
expert(s) can change a provisional entry's status to permanent at any time.[¶](#section-16.3.1-11)

Note that names can be registered by third parties (including the
expert(s)) if the expert(s) determines that an unregistered name is widely
deployed and not likely to be registered in a timely manner otherwise.[¶](#section-16.3.1-12)

#### [16.3.2.](#section-16.3.2) [Considerations for New Fields](#name-considerations-for-new-fiel)

HTTP header and trailer fields are a widely used extension point for the protocol.
While they can be used in an ad hoc fashion, fields that are intended for
wider use need to be carefully documented to ensure interoperability.[¶](#section-16.3.2-1)

In particular, authors of specifications defining new fields are advised to consider
and, where appropriate, document the following aspects:[¶](#section-16.3.2-2)

* Under what conditions the field can be used; e.g., only in
  responses or requests, in all messages, only on responses to a
  particular request method, etc.[¶](#section-16.3.2-3.1)
* Whether the field semantics are further refined by their context,
  such as their use with certain request methods or status codes.[¶](#section-16.3.2-3.2)
* The scope of applicability for the information conveyed.
  By default, fields apply only to the message they are
  associated with, but some response fields are designed to apply to all
  representations of a resource, the resource itself, or an even broader
  scope. Specifications that expand the scope of a response field will
  need to carefully consider issues such as content negotiation, the time
  period of applicability, and (in some cases) multi-tenant server
  deployments.[¶](#section-16.3.2-3.3)
* Under what conditions intermediaries are allowed to insert,
  delete, or modify the field's value.[¶](#section-16.3.2-3.4)
* If the field is allowable in trailers; by
  default, it will not be (see [Section 6.5.1](#trailers.limitations)).[¶](#section-16.3.2-3.5)
* Whether it is appropriate or even required to list the field name in the
  [Connection](#field.connection) header field (i.e., if the field is to
  be hop-by-hop; see [Section 7.6.1](#field.connection)).[¶](#section-16.3.2-3.6)
* Whether the field introduces any additional security considerations, such
  as disclosure of privacy-related data.[¶](#section-16.3.2-3.7)

Request header fields have additional considerations that need to be documented
if the default behavior is not appropriate:[¶](#section-16.3.2-4)

* If it is appropriate to list the field name in a
  [Vary](#field.vary) response header field (e.g., when the request header
  field is used by an origin server's content selection algorithm; see
  [Section 12.5.5](#field.vary)).[¶](#section-16.3.2-5.1)
* If the field is intended to be stored when received in a PUT
  request (see [Section 9.3.4](#PUT)).[¶](#section-16.3.2-5.2)
* If the field ought to be removed when automatically redirecting a
  request due to security concerns (see [Section 15.4](#status.3xx)).[¶](#section-16.3.2-5.3)

##### [16.3.2.1.](#section-16.3.2.1) [Considerations for New Field Names](#name-considerations-for-new-field)

Authors of specifications defining new fields are advised to choose a short
but descriptive field name. Short names avoid needless data transmission;
descriptive names avoid confusion and "squatting" on names that might have
broader uses.[¶](#section-16.3.2.1-1)

To that end, limited-use fields (such as a header confined to a single
application or use case) are encouraged to use a name that includes that use
(or an abbreviation) as a prefix; for example, if the Foo Application needs
a Description field, it might use "Foo-Desc"; "Description" is too generic,
and "Foo-Description" is needlessly long.[¶](#section-16.3.2.1-2)

While the field-name syntax is defined to allow any token character, in
practice some implementations place limits on the characters they accept
in field-names. To be interoperable, new field names SHOULD constrain
themselves to alphanumeric characters, "-", and ".", and SHOULD
begin with a letter. For example, the underscore
("\_") character can be problematic when passed through non-HTTP
gateway interfaces (see [Section 17.10](#underscore.in.fields)).[¶](#section-16.3.2.1-3)

Field names ought not be prefixed with "X-"; see
[[BCP178](#BCP178)] for further information.[¶](#section-16.3.2.1-4)

Other prefixes are sometimes used in HTTP field names; for example,
"Accept-" is used in many content negotiation headers, and "Content-" is used
as explained in [Section 6.4](#content). These prefixes are
only an aid to recognizing the purpose of a field and do not
trigger automatic processing.[¶](#section-16.3.2.1-5)

##### [16.3.2.2.](#section-16.3.2.2) [Considerations for New Field Values](#name-considerations-for-new-field-)

A major task in the definition of a new HTTP field is the specification of
the field value syntax: what senders should generate, and how recipients
should infer semantics from what is received.[¶](#section-16.3.2.2-1)

Authors are encouraged (but not required) to use either the ABNF rules in
this specification or those in [[RFC8941](#RFC8941)] to define the syntax
of new field values.[¶](#section-16.3.2.2-2)

Authors are advised to carefully consider how the combination of multiple
field lines will impact them (see [Section 5.3](#fields.order)). Because
senders might erroneously send multiple values, and both intermediaries
and HTTP libraries can perform combination automatically, this applies to
all field values -- even when only a single value is anticipated.[¶](#section-16.3.2.2-3)

Therefore, authors are advised to delimit or encode values that contain
commas (e.g., with the [quoted-string](#rule.quoted-string) rule of
[Section 5.6.4](#quoted.strings), the String data type of
[[RFC8941](#RFC8941)], or a field-specific encoding).
This ensures that commas within field data are not confused
with the commas that delimit a list value.[¶](#section-16.3.2.2-4)

For example, the [Content-Type](#field.content-type) field value only allows commas
inside quoted strings, which can be reliably parsed even when multiple
values are present. The [Location](#field.location) field value provides a
counter-example that should not be emulated: because URIs can include
commas, it is not possible to reliably distinguish between a single value
that includes a comma from two values.[¶](#section-16.3.2.2-5)

Authors of fields with a singleton value (see [Section 5.5](#fields.values)) are additionally advised to document how to treat
messages where the multiple members are present (a sensible default would
be to ignore the field, but this might not always be the right choice).[¶](#section-16.3.2.2-6)

### [16.4.](#section-16.4) [Authentication Scheme Extensibility](#name-authentication-scheme-exten)

#### [16.4.1.](#section-16.4.1) [Authentication Scheme Registry](#name-authentication-scheme-regis)

The "Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry"
defines the namespace for the authentication schemes in challenges and
credentials. It is maintained
at <<https://www.iana.org/assignments/http-authschemes>>.[¶](#section-16.4.1-1)

Registrations MUST include the following fields:[¶](#section-16.4.1-2)

* Authentication Scheme Name[¶](#section-16.4.1-3.1)
* Pointer to specification text[¶](#section-16.4.1-3.2)
* Notes (optional)[¶](#section-16.4.1-3.3)

Values to be added to this namespace require IETF Review
(see [[RFC8126](#RFC8126)], [Section 4.8](https://www.rfc-editor.org/rfc/rfc8126#section-4.8)).[¶](#section-16.4.1-4)

#### [16.4.2.](#section-16.4.2) [Considerations for New Authentication Schemes](#name-considerations-for-new-auth)

There are certain aspects of the HTTP Authentication framework that put
constraints on how new authentication schemes can work:[¶](#section-16.4.2-1)

* HTTP authentication is presumed to be stateless: all of the information
  necessary to authenticate a request MUST be provided in the request,
  rather than be dependent on the server remembering prior requests.
  Authentication based on, or bound to, the underlying connection is
  outside the scope of this specification and inherently flawed unless
  steps are taken to ensure that the connection cannot be used by any
  party other than the authenticated user
  (see [Section 3.3](#connections)).[¶](#section-16.4.2-2.1.1)
* The authentication parameter "realm" is reserved for defining protection
  spaces as described in [Section 11.5](#protection.space). New schemes
  MUST NOT use it in a way incompatible with that definition.[¶](#section-16.4.2-2.2.1)
* The "token68" notation was introduced for compatibility with existing
  authentication schemes and can only be used once per challenge or credential.
  Thus, new schemes ought to use the auth-param syntax instead, because
  otherwise future extensions will be impossible.[¶](#section-16.4.2-2.3.1)
* The parsing of challenges and credentials is defined by this specification
  and cannot be modified by new authentication schemes. When the auth-param
  syntax is used, all parameters ought to support both token and
  quoted-string syntax, and syntactical constraints ought to be defined on
  the field value after parsing (i.e., quoted-string processing). This is
  necessary so that recipients can use a generic parser that applies to
  all authentication schemes.[¶](#section-16.4.2-2.4.1)

  **Note:** The fact that the value syntax for the "realm" parameter
  is restricted to quoted-string was a bad design choice not to be repeated
  for new parameters.[¶](#section-16.4.2-2.4.2)
* Definitions of new schemes ought to define the treatment of unknown
  extension parameters. In general, a "must-ignore" rule is preferable
  to a "must-understand" rule, because otherwise it will be hard to introduce
  new parameters in the presence of legacy recipients. Furthermore,
  it's good to describe the policy for defining new parameters (such
  as "update the specification" or "use this registry").[¶](#section-16.4.2-2.5.1)
* Authentication schemes need to document whether they are usable in
  origin-server authentication (i.e., using [WWW-Authenticate](#field.www-authenticate)),
  and/or proxy authentication (i.e., using [Proxy-Authenticate](#field.proxy-authenticate)).[¶](#section-16.4.2-2.6.1)
* The credentials carried in an [Authorization](#field.authorization) header field are specific to
  the user agent and, therefore, have the same effect on HTTP caches as the
  "private" cache response directive ([Section 5.2.2.7](https://www.rfc-editor.org/rfc/rfc9111#section-5.2.2.7) of [[CACHING](#CACHING)]),
  within the scope of the request in which they appear.[¶](#section-16.4.2-2.7.1)

  Therefore, new authentication schemes that choose not to carry
  credentials in the [Authorization](#field.authorization) header field (e.g., using a newly defined
  header field) will need to explicitly disallow caching, by mandating the use of
  cache response directives (e.g., "private").[¶](#section-16.4.2-2.7.2)
* Schemes using [Authentication-Info](#field.authentication-info), [Proxy-Authentication-Info](#field.proxy-authentication-info),
  or any other authentication related response header field need to
  consider and document the related security considerations (see
  [Section 17.16.4](#security.auth.add.resp)).[¶](#section-16.4.2-2.8.1)

### [16.5.](#section-16.5) [Range Unit Extensibility](#name-range-unit-extensibility)

#### [16.5.1.](#section-16.5.1) [Range Unit Registry](#name-range-unit-registry)

The "HTTP Range Unit Registry" defines the namespace for the range
unit names and refers to their corresponding specifications.
It is maintained at
<<https://www.iana.org/assignments/http-parameters>>.[¶](#section-16.5.1-1)

Registration of an HTTP Range Unit MUST include the following fields:[¶](#section-16.5.1-2)

* Name[¶](#section-16.5.1-3.1)
* Description[¶](#section-16.5.1-3.2)
* Pointer to specification text[¶](#section-16.5.1-3.3)

Values to be added to this namespace require IETF Review
(see [[RFC8126](#RFC8126)], [Section 4.8](https://www.rfc-editor.org/rfc/rfc8126#section-4.8)).[¶](#section-16.5.1-4)

#### [16.5.2.](#section-16.5.2) [Considerations for New Range Units](#name-considerations-for-new-rang)

Other range units, such as format-specific boundaries like pages,
sections, records, rows, or time, are potentially usable in HTTP for
application-specific purposes, but are not commonly used in practice.
Implementors of alternative range units ought to consider how they would
work with content codings and general-purpose intermediaries.[¶](#section-16.5.2-1)

### [16.6.](#section-16.6) [Content Coding Extensibility](#name-content-coding-extensibilit)

#### [16.6.1.](#section-16.6.1) [Content Coding Registry](#name-content-coding-registry)

The "HTTP Content Coding Registry", maintained by
IANA at <<https://www.iana.org/assignments/http-parameters/>>,
registers [content-coding](#content.codings) names.[¶](#section-16.6.1-1)

Content coding registrations MUST include the following fields:[¶](#section-16.6.1-2)

* Name[¶](#section-16.6.1-3.1)
* Description[¶](#section-16.6.1-3.2)
* Pointer to specification text[¶](#section-16.6.1-3.3)

Names of content codings MUST NOT overlap with names of transfer codings
(per the "HTTP Transfer Coding Registry" located at
<<https://www.iana.org/assignments/http-parameters/>>) unless
the encoding transformation is
identical (as is the case for the compression codings defined in
[Section 8.4.1](#content.codings)).[¶](#section-16.6.1-4)

Values to be added to this namespace require IETF Review
(see [Section 4.8](https://www.rfc-editor.org/rfc/rfc8126#section-4.8) of [[RFC8126](#RFC8126)]) and MUST
conform to the purpose of content coding defined in
[Section 8.4.1](#content.codings).[¶](#section-16.6.1-5)

#### [16.6.2.](#section-16.6.2) [Considerations for New Content Codings](#name-considerations-for-new-cont)

New content codings ought to be self-descriptive whenever possible, with
optional parameters discoverable within the coding format itself, rather
than rely on external metadata that might be lost during transit.[¶](#section-16.6.2-1)

### [16.7.](#section-16.7) [Upgrade Token Registry](#name-upgrade-token-registry)

The "Hypertext Transfer Protocol (HTTP) Upgrade Token Registry" defines
the namespace for protocol-name tokens used to identify protocols in the
[Upgrade](#field.upgrade) header field. The registry is maintained at
<<https://www.iana.org/assignments/http-upgrade-tokens>>.[¶](#section-16.7-1)

Each registered protocol name is associated with contact information
and an optional set of specifications that details how the connection
will be processed after it has been upgraded.[¶](#section-16.7-2)

Registrations happen on a "First Come First Served" basis (see
[Section 4.4](https://www.rfc-editor.org/rfc/rfc8126#section-4.4) of [[RFC8126](#RFC8126)]) and are subject to the
following rules:[¶](#section-16.7-3)

1. A protocol-name token, once registered, stays registered forever.[¶](#section-16.7-4.1)
2. A protocol-name token is case-insensitive and registered with the
   preferred case to be generated by senders.[¶](#section-16.7-4.2)
3. The registration MUST name a responsible party for the
   registration.[¶](#section-16.7-4.3)
4. The registration MUST name a point of contact.[¶](#section-16.7-4.4)
5. The registration MAY name a set of specifications associated with
   that token. Such specifications need not be publicly available.[¶](#section-16.7-4.5)
6. The registration SHOULD name a set of expected "protocol-version"
   tokens associated with that token at the time of registration.[¶](#section-16.7-4.6)
7. The responsible party MAY change the registration at any time.
   The IANA will keep a record of all such changes, and make them
   available upon request.[¶](#section-16.7-4.7)
8. The IESG MAY reassign responsibility for a protocol token.
   This will normally only be used in the case when a
   responsible party cannot be contacted.[¶](#section-16.7-4.8)

## [17.](#section-17) [Security Considerations](#name-security-considerations)

This section is meant to inform developers, information providers, and
users of known security concerns relevant to HTTP semantics and its
use for transferring information over the Internet. Considerations related
to caching are discussed in [Section 7](https://www.rfc-editor.org/rfc/rfc9111#section-7) of [[CACHING](#CACHING)],
and considerations related to HTTP/1.1 message syntax and parsing are
discussed in [Section 11](https://www.rfc-editor.org/rfc/rfc9112#section-11) of [[HTTP/1.1](#HTTP11)].[¶](#section-17-1)

The list of considerations below is not exhaustive. Most security concerns
related to HTTP semantics are about securing server-side applications (code
behind the HTTP interface), securing user agent processing of content
received via HTTP, or secure use of the Internet in general, rather than
security of the protocol. The security considerations for URIs, which
are fundamental to HTTP operation, are discussed in
[Section 7](https://www.rfc-editor.org/rfc/rfc3986#section-7) of [[URI](#URI)]. Various organizations maintain
topical information and links to current research on Web application
security (e.g., [[OWASP](#OWASP)]).[¶](#section-17-2)

### [17.1.](#section-17.1) [Establishing Authority](#name-establishing-authority)

HTTP relies on the notion of an "authoritative response": a
response that has been determined by (or at the direction of) the origin
server identified within the target URI to be the most appropriate response
for that request given the state of the target resource at the time of
response message origination.[¶](#section-17.1-1)

When a registered name is used in the authority component, the "http" URI
scheme ([Section 4.2.1](#http.uri)) relies on the user's local name
resolution service to determine where it can find authoritative responses.
This means that any attack on a user's network host table, cached names,
or name resolution libraries becomes an avenue for attack on establishing
authority for "http" URIs. Likewise, the user's choice of server for
Domain Name Service (DNS), and the hierarchy of servers from which it
obtains resolution results, could impact the authenticity of address
mappings; DNS Security Extensions (DNSSEC, [[RFC4033](#RFC4033)]) are
one way to improve authenticity, as are the various mechanisms for making
DNS requests over more secure transfer protocols.[¶](#section-17.1-2)

Furthermore, after an IP address is obtained, establishing authority for
an "http" URI is vulnerable to attacks on Internet Protocol routing.[¶](#section-17.1-3)

The "https" scheme ([Section 4.2.2](#https.uri)) is intended to prevent
(or at least reveal) many of these potential attacks on establishing
authority, provided that the negotiated connection is secured and
the client properly verifies that the communicating server's identity
matches the target URI's authority component
([Section 4.3.4](#https.verify)). Correctly implementing such verification
can be difficult (see [[Georgiev](#Georgiev)]).[¶](#section-17.1-4)

Authority for a given origin server can be delegated through protocol
extensions; for example, [[ALTSVC](#ALTSVC)]. Likewise, the set of
servers for which a connection is considered authoritative can be changed
with a protocol extension like [[RFC8336](#RFC8336)].[¶](#section-17.1-5)

Providing a response from a non-authoritative source, such as a shared
proxy cache, is often useful to improve performance and availability, but
only to the extent that the source can be trusted or the distrusted
response can be safely used.[¶](#section-17.1-6)

Unfortunately, communicating authority to users can be difficult.
For example, "phishing" is an attack on the user's perception
of authority, where that perception can be misled by presenting similar
branding in hypertext, possibly aided by userinfo obfuscating the authority
component (see [Section 4.2.1](#http.uri)).
User agents can reduce the impact of phishing attacks by enabling users to
easily inspect a target URI prior to making an action, by prominently
distinguishing (or rejecting) userinfo when present, and by not sending
stored credentials and cookies when the referring document is from an
unknown or untrusted source.[¶](#section-17.1-7)

### [17.2.](#section-17.2) [Risks of Intermediaries](#name-risks-of-intermediaries)

HTTP intermediaries are inherently situated for on-path attacks.
Compromise of
the systems on which the intermediaries run can result in serious security
and privacy problems. Intermediaries might have access to security-related
information, personal information about individual users and
organizations, and proprietary information belonging to users and
content providers. A compromised intermediary, or an intermediary
implemented or configured without regard to security and privacy
considerations, might be used in the commission of a wide range of
potential attacks.[¶](#section-17.2-1)

Intermediaries that contain a shared cache are especially vulnerable
to cache poisoning attacks, as described in [Section 7](https://www.rfc-editor.org/rfc/rfc9111#section-7) of [[CACHING](#CACHING)].[¶](#section-17.2-2)

Implementers need to consider the privacy and security
implications of their design and coding decisions, and of the
configuration options they provide to operators (especially the
default configuration).[¶](#section-17.2-3)

Intermediaries are no more trustworthy than the people and policies
under which they operate; HTTP cannot solve this problem.[¶](#section-17.2-4)

### [17.3.](#section-17.3) [Attacks Based on File and Path Names](#name-attacks-based-on-file-and-p)

Origin servers frequently make use of their local file system to manage the
mapping from target URI to resource representations.
Most file systems are not designed to protect against malicious file
or path names. Therefore, an origin server needs to avoid accessing
names that have a special significance to the system when mapping the
target resource to files, folders, or directories.[¶](#section-17.3-1)

For example, UNIX, Microsoft Windows, and other operating systems use ".."
as a path component to indicate a directory level above the current one,
and they use specially named paths or file names to send data to system devices.
Similar naming conventions might exist within other types of storage
systems. Likewise, local storage systems have an annoying tendency to
prefer user-friendliness over security when handling invalid or unexpected
characters, recomposition of decomposed characters, and case-normalization
of case-insensitive names.[¶](#section-17.3-2)

Attacks based on such special names tend to focus on either denial-of-service
(e.g., telling the server to read from a COM port) or disclosure
of configuration and source files that are not meant to be served.[¶](#section-17.3-3)

### [17.4.](#section-17.4) [Attacks Based on Command, Code, or Query Injection](#name-attacks-based-on-command-co)

Origin servers often use parameters within the URI as a
means of identifying system services, selecting database entries, or
choosing a data source. However, data received in a request cannot be
trusted. An attacker could construct any of the request data elements
(method, target URI, header fields, or content) to contain data that might
be misinterpreted as a command, code, or query when passed through a
command invocation, language interpreter, or database interface.[¶](#section-17.4-1)

For example, SQL injection is a common attack wherein additional query
language is inserted within some part of the target URI or header
fields (e.g., [Host](#field.host), [Referer](#field.referer), etc.).
If the received data is used directly within a SELECT statement, the
query language might be interpreted as a database command instead of a
simple string value. This type of implementation vulnerability is extremely
common, in spite of being easy to prevent.[¶](#section-17.4-2)

In general, resource implementations ought to avoid use of request data
in contexts that are processed or interpreted as instructions. Parameters
ought to be compared to fixed strings and acted upon as a result of that
comparison, rather than passed through an interface that is not prepared
for untrusted data. Received data that isn't based on fixed parameters
ought to be carefully filtered or encoded to avoid being misinterpreted.[¶](#section-17.4-3)

Similar considerations apply to request data when it is stored and later
processed, such as within log files, monitoring tools, or when included
within a data format that allows embedded scripts.[¶](#section-17.4-4)

### [17.5.](#section-17.5) [Attacks via Protocol Element Length](#name-attacks-via-protocol-elemen)

Because HTTP uses mostly textual, character-delimited fields, parsers are
often vulnerable to attacks based on sending very long (or very slow)
streams of data, particularly where an implementation is expecting a
protocol element with no predefined length
([Section 2.3](#length.requirements)).[¶](#section-17.5-1)

To promote interoperability, specific recommendations are made for minimum
size limits on fields ([Section 5.4](#fields.limits)). These are
minimum recommendations, chosen to be supportable even by implementations
with limited resources; it is expected that most implementations will
choose substantially higher limits.[¶](#section-17.5-2)

A server can reject a message that
has a target URI that is too long ([Section 15.5.15](#status.414)) or request content
that is too large ([Section 15.5.14](#status.413)). Additional status codes related to
capacity limits have been defined by extensions to HTTP
[[RFC6585](#RFC6585)].[¶](#section-17.5-3)

Recipients ought to carefully limit the extent to which they process other
protocol elements, including (but not limited to) request methods, response
status phrases, field names, numeric values, and chunk lengths.
Failure to limit such processing can result in arbitrary code execution due to
buffer or arithmetic
overflows, and increased vulnerability to denial-of-service attacks.[¶](#section-17.5-4)

### [17.6.](#section-17.6) [Attacks Using Shared-Dictionary Compression](#name-attacks-using-shared-dictio)

Some attacks on encrypted protocols use the differences in size created by
dynamic compression to reveal confidential information; for example, [[BREACH](#BREACH)]. These attacks rely on creating a redundancy between
attacker-controlled content and the confidential information, such that a
dynamic compression algorithm using the same dictionary for both content
will compress more efficiently when the attacker-controlled content matches
parts of the confidential content.[¶](#section-17.6-1)

HTTP messages can be compressed in a number of ways, including using TLS
compression, content codings, transfer codings, and other extension or
version-specific mechanisms.[¶](#section-17.6-2)

The most effective mitigation for this risk is to disable compression on
sensitive data, or to strictly separate sensitive data from attacker-controlled
data so that they cannot share the same compression dictionary. With
careful design, a compression scheme can be designed in a way that is not
considered exploitable in limited use cases, such as HPACK ([[HPACK](#HPACK)]).[¶](#section-17.6-3)

### [17.7.](#section-17.7) [Disclosure of Personal Information](#name-disclosure-of-personal-info)

Clients are often privy to large amounts of personal information,
including both information provided by the user to interact with resources
(e.g., the user's name, location, mail address, passwords, encryption
keys, etc.) and information about the user's browsing activity over
time (e.g., history, bookmarks, etc.). Implementations need to
prevent unintentional disclosure of personal information.[¶](#section-17.7-1)

### [17.8.](#section-17.8) [Privacy of Server Log Information](#name-privacy-of-server-log-infor)

A server is in the position to save personal data about a user's requests
over time, which might identify their reading patterns or subjects of
interest. In particular, log information gathered at an intermediary
often contains a history of user agent interaction, across a multitude
of sites, that can be traced to individual users.[¶](#section-17.8-1)

HTTP log information is confidential in nature; its handling is often
constrained by laws and regulations. Log information needs to be securely
stored and appropriate guidelines followed for its analysis.
Anonymization of personal information within individual entries helps,
but it is generally not sufficient to prevent real log traces from being
re-identified based on correlation with other access characteristics.
As such, access traces that are keyed to a specific client are unsafe to
publish even if the key is pseudonymous.[¶](#section-17.8-2)

To minimize the risk of theft or accidental publication, log information
ought to be purged of personally identifiable information, including
user identifiers, IP addresses, and user-provided query parameters,
as soon as that information is no longer necessary to support operational
needs for security, auditing, or fraud control.[¶](#section-17.8-3)

### [17.9.](#section-17.9) [Disclosure of Sensitive Information in URIs](#name-disclosure-of-sensitive-inf)

URIs are intended to be shared, not secured, even when they identify secure
resources. URIs are often shown on displays, added to templates when a page
is printed, and stored in a variety of unprotected bookmark lists.
Many servers, proxies, and user agents log or display the target URI
in places where it might be visible to third parties.
It is therefore unwise to include information within a URI that
is sensitive, personally identifiable, or a risk to disclose.[¶](#section-17.9-1)

When an application uses client-side mechanisms to construct a target URI
out of user-provided information, such as the query fields of a form using
GET, potentially sensitive data might be provided that would not be
appropriate for disclosure within a URI. POST is often preferred in such
cases because it usually doesn't construct a URI; instead, POST of a form
transmits the potentially sensitive data in the request content. However, this
hinders caching and uses an unsafe method for what would otherwise be a safe
request. Alternative workarounds include transforming the user-provided data
prior to constructing the URI or filtering the data to only include common
values that are not sensitive. Likewise, redirecting the result of a query
to a different (server-generated) URI can remove potentially sensitive data
from later links and provide a cacheable response for later reuse.[¶](#section-17.9-2)

Since the [Referer](#field.referer) header field tells a target site about the
context that resulted in a request, it has the potential to reveal
information about the user's immediate browsing history and any personal
information that might be found in the referring resource's URI.
Limitations on the Referer header field are described in [Section 10.1.3](#field.referer) to
address some of its security considerations.[¶](#section-17.9-3)

### [17.10.](#section-17.10) [Application Handling of Field Names](#name-application-handling-of-fie)

Servers often use non-HTTP gateway interfaces and frameworks to process a received
request and produce content for the response. For historical reasons, such interfaces
often pass received field names as external variable names, using a name mapping
suitable for environment variables.[¶](#section-17.10-1)

For example, the Common Gateway Interface (CGI) mapping of protocol-specific
meta-variables, defined by [Section 4.1.18](https://www.rfc-editor.org/rfc/rfc3875#section-4.1.18) of [[RFC3875](#RFC3875)],
is applied to received header fields that do not correspond to one of CGI's
standard variables; the mapping consists of prepending "HTTP\_" to each name
and changing all instances of hyphen ("-") to underscore ("\_"). This same mapping
has been inherited by many other application frameworks in order to simplify
moving applications from one platform to the next.[¶](#section-17.10-2)

In CGI, a received [Content-Length](#field.content-length) field would be passed
as the meta-variable "CONTENT\_LENGTH" with a string value matching the
received field's value. In contrast, a received "Content\_Length" header field would
be passed as the protocol-specific meta-variable "HTTP\_CONTENT\_LENGTH",
which might lead to some confusion if an application mistakenly reads the
protocol-specific meta-variable instead of the default one. (This historical practice
is why [Section 16.3.2.1](#considerations.for.new.field.names) discourages the creation
of new field names that contain an underscore.)[¶](#section-17.10-3)

Unfortunately, mapping field names to different interface names can lead to
security vulnerabilities if the mapping is incomplete or ambiguous. For example,
if an attacker were to send a field named "Transfer\_Encoding", a naive interface
might map that to the same variable name as the "Transfer-Encoding" field, resulting
in a potential request smuggling vulnerability ([Section 11.2](https://www.rfc-editor.org/rfc/rfc9112#section-11.2) of [[HTTP/1.1](#HTTP11)]).[¶](#section-17.10-4)

To mitigate the associated risks, implementations that perform such
mappings are advised to make the mapping unambiguous and complete
for the full range of potential octets received as a name (including those
that are discouraged or forbidden by the HTTP grammar).
For example, a field with an unusual name character might
result in the request being blocked, the specific field being removed,
or the name being passed with a different prefix to distinguish it from
other fields.[¶](#section-17.10-5)

### [17.11.](#section-17.11) [Disclosure of Fragment after Redirects](#name-disclosure-of-fragment-afte)

Although fragment identifiers used within URI references are not sent
in requests, implementers ought to be aware that they will be visible to
the user agent and any extensions or scripts running as a result of the
response. In particular, when a redirect occurs and the original request's
fragment identifier is inherited by the new reference in
[Location](#field.location) ([Section 10.2.2](#field.location)), this might
have the effect of disclosing one site's fragment to another site.
If the first site uses personal information in fragments, it ought to
ensure that redirects to other sites include a (possibly empty) fragment
component in order to block that inheritance.[¶](#section-17.11-1)

### [17.12.](#section-17.12) [Disclosure of Product Information](#name-disclosure-of-product-infor)

The [User-Agent](#field.user-agent) ([Section 10.1.5](#field.user-agent)),
[Via](#field.via) ([Section 7.6.3](#field.via)), and
[Server](#field.server) ([Section 10.2.4](#field.server)) header fields often
reveal information about the respective sender's software systems.
In theory, this can make it easier for an attacker to exploit known
security holes; in practice, attackers tend to try all potential holes
regardless of the apparent software versions being used.[¶](#section-17.12-1)

Proxies that serve as a portal through a network firewall ought to take
special precautions regarding the transfer of header information that might
identify hosts behind the firewall. The [Via](#field.via) header field
allows intermediaries to replace sensitive machine names with pseudonyms.[¶](#section-17.12-2)

### [17.13.](#section-17.13) [Browser Fingerprinting](#name-browser-fingerprinting)

Browser fingerprinting is a set of techniques for identifying a specific
user agent over time through its unique set of characteristics. These
characteristics might include information related to how it uses the underlying
transport protocol,
feature capabilities, and scripting environment, though of particular
interest here is the set of unique characteristics that might be
communicated via HTTP. Fingerprinting is considered a privacy concern
because it enables tracking of a user agent's behavior over time
([[Bujlow](#Bujlow)]) without
the corresponding controls that the user might have over other forms of
data collection (e.g., cookies). Many general-purpose user agents
(i.e., Web browsers) have taken steps to reduce their fingerprints.[¶](#section-17.13-1)

There are a number of request header fields that might reveal information
to servers that is sufficiently unique to enable fingerprinting.
The [From](#field.from) header field is the most obvious, though it is
expected that From will only be sent when self-identification is desired by
the user. Likewise, Cookie header fields are deliberately designed to
enable re-identification, so fingerprinting concerns only apply to
situations where cookies are disabled or restricted by the user agent's
configuration.[¶](#section-17.13-2)

The [User-Agent](#field.user-agent) header field might contain enough information
to uniquely identify a specific device, usually when combined with other
characteristics, particularly if the user agent sends excessive details
about the user's system or extensions. However, the source of unique
information that is least expected by users is
[proactive negotiation](#proactive.negotiation) ([Section 12.1](#proactive.negotiation)),
including the [Accept](#field.accept), [Accept-Charset](#field.accept-charset),
[Accept-Encoding](#field.accept-encoding), and [Accept-Language](#field.accept-language)
header fields.[¶](#section-17.13-3)

In addition to the fingerprinting concern, detailed use of the
[Accept-Language](#field.accept-language) header field can reveal information the
user might consider to be of a private nature. For example, understanding
a given language set might be strongly correlated to membership in a
particular ethnic group.
An approach that limits such loss of privacy would be for a user agent
to omit the sending of Accept-Language except for sites that have been
explicitly permitted, perhaps via interaction after detecting a [Vary](#field.vary)
header field that indicates language negotiation might be useful.[¶](#section-17.13-4)

In environments where proxies are used to enhance privacy, user agents
ought to be conservative in sending proactive negotiation header fields.
General-purpose user agents that provide a high degree of header field
configurability ought to inform users about the loss of privacy that might
result if too much detail is provided. As an extreme privacy measure,
proxies could filter the proactive negotiation header fields in relayed
requests.[¶](#section-17.13-5)

### [17.14.](#section-17.14) [Validator Retention](#name-validator-retention)

The validators defined by this specification are not intended to ensure
the validity of a representation, guard against malicious changes, or
detect on-path attacks. At best, they enable more efficient cache
updates and optimistic concurrent writes when all participants are behaving
nicely. At worst, the conditions will fail and the client will receive a
response that is no more harmful than an HTTP exchange without conditional
requests.[¶](#section-17.14-1)

An entity tag can be abused in ways that create privacy risks. For example,
a site might deliberately construct a semantically invalid entity tag that
is unique to the user or user agent, send it in a cacheable response with a
long freshness time, and then read that entity tag in later conditional
requests as a means of re-identifying that user or user agent. Such an
identifying tag would become a persistent identifier for as long as the
user agent retained the original cache entry. User agents that cache
representations ought to ensure that the cache is cleared or replaced
whenever the user performs privacy-maintaining actions, such as clearing
stored cookies or changing to a private browsing mode.[¶](#section-17.14-2)

### [17.15.](#section-17.15) [Denial-of-Service Attacks Using Range](#name-denial-of-service-attacks-u)

Unconstrained multiple range requests are susceptible to denial-of-service
attacks because the effort required to request many overlapping ranges of
the same data is tiny compared to the time, memory, and bandwidth consumed
by attempting to serve the requested data in many parts.
Servers ought to ignore, coalesce, or reject egregious range requests, such
as requests for more than two overlapping ranges or for many small ranges
in a single set, particularly when the ranges are requested out of order
for no apparent reason. Multipart range requests are not designed to
support random access.[¶](#section-17.15-1)

### [17.16.](#section-17.16) [Authentication Considerations](#name-authentication-consideratio)

Everything about the topic of HTTP authentication is a security
consideration, so the list of considerations below is not exhaustive.
Furthermore, it is limited to security considerations regarding the
authentication framework, in general, rather than discussing all of the
potential considerations for specific authentication schemes (which ought
to be documented in the specifications that define those schemes).
Various organizations maintain topical information and links to current
research on Web application security (e.g., [[OWASP](#OWASP)]),
including common pitfalls for implementing and using the authentication
schemes found in practice.[¶](#section-17.16-1)

#### [17.16.1.](#section-17.16.1) [Confidentiality of Credentials](#name-confidentiality-of-credenti)

The HTTP authentication framework does not define a single mechanism for
maintaining the confidentiality of credentials; instead, each
authentication scheme defines how the credentials are encoded prior to
transmission. While this provides flexibility for the development of future
authentication schemes, it is inadequate for the protection of existing
schemes that provide no confidentiality on their own, or that do not
sufficiently protect against replay attacks. Furthermore, if the server
expects credentials that are specific to each individual user, the exchange
of those credentials will have the effect of identifying that user even if
the content within credentials remains confidential.[¶](#section-17.16.1-1)

HTTP depends on the security properties of the underlying transport- or
session-level connection to provide confidential transmission of
fields. Services that depend on individual user authentication require a
[secured](#https.uri) connection prior to exchanging credentials
([Section 4.2.2](#https.uri)).[¶](#section-17.16.1-2)

#### [17.16.2.](#section-17.16.2) [Credentials and Idle Clients](#name-credentials-and-idle-client)

Existing HTTP clients and user agents typically retain authentication
information indefinitely. HTTP does not provide a mechanism for the
origin server to direct clients to discard these cached credentials, since
the protocol has no awareness of how credentials are obtained or managed
by the user agent. The mechanisms for expiring or revoking credentials can
be specified as part of an authentication scheme definition.[¶](#section-17.16.2-1)

Circumstances under which credential caching can interfere with the
application's security model include but are not limited to:[¶](#section-17.16.2-2)

* Clients that have been idle for an extended period, following
  which the server might wish to cause the client to re-prompt the
  user for credentials.[¶](#section-17.16.2-3.1)
* Applications that include a session termination indication
  (such as a "logout" or "commit" button on a page) after which
  the server side of the application "knows" that there is no
  further reason for the client to retain the credentials.[¶](#section-17.16.2-3.2)

User agents that cache credentials are encouraged to provide a readily
accessible mechanism for discarding cached credentials under user control.[¶](#section-17.16.2-4)

#### [17.16.3.](#section-17.16.3) [Protection Spaces](#name-protection-spaces)

Authentication schemes that solely rely on the "realm" mechanism for
establishing a protection space will expose credentials to all resources on
an origin server. Clients that have successfully made authenticated requests
with a resource can use the same authentication credentials for other
resources on the same origin server. This makes it possible for a different
resource to harvest authentication credentials for other resources.[¶](#section-17.16.3-1)

This is of particular concern when an origin server hosts resources for multiple
parties under the same origin ([Section 11.5](#protection.space)).
Possible mitigation strategies include restricting direct access to
authentication credentials (i.e., not making the content of the
[Authorization](#field.authorization) request header field available), and separating protection
spaces by using a different host name (or port number) for each party.[¶](#section-17.16.3-2)

#### [17.16.4.](#section-17.16.4) [Additional Response Fields](#name-additional-response-fields)

Adding information to responses that are sent over an unencrypted
channel can affect security and privacy. The presence of the
[Authentication-Info](#field.authentication-info) and [Proxy-Authentication-Info](#field.proxy-authentication-info)
header fields alone indicates that HTTP authentication is in use. Additional
information could be exposed by the contents of the authentication-scheme
specific parameters; this will have to be considered in the definitions of these
schemes.[¶](#section-17.16.4-1)

## [18.](#section-18) [IANA Considerations](#name-iana-considerations)

The change controller for the following registrations is:
"IETF (iesg@ietf.org) - Internet Engineering Task Force".[¶](#section-18-1)

### [18.1.](#section-18.1) [URI Scheme Registration](#name-uri-scheme-registration)

IANA has updated the "Uniform Resource Identifier (URI) Schemes" registry [[BCP35](#BCP35)] at
<<https://www.iana.org/assignments/uri-schemes/>> with the
permanent schemes listed in [Table 2](#uri.scheme.table) in [Section 4.2](#uri.schemes).[¶](#section-18.1-1)

### [18.2.](#section-18.2) [Method Registration](#name-method-registration)

IANA has updated the "Hypertext Transfer Protocol (HTTP) Method Registry" at
<<https://www.iana.org/assignments/http-methods>> with the
registration procedure of [Section 16.1.1](#method.registry) and the method
names summarized in the following table.[¶](#section-18.2-1)

[Table 7](#table-7)
| Method | Safe | Idempotent | Section |
| --- | --- | --- | --- |
| CONNECT | no | no | [9.3.6](#CONNECT) |
| DELETE | no | yes | [9.3.5](#DELETE) |
| GET | yes | yes | [9.3.1](#GET) |
| HEAD | yes | yes | [9.3.2](#HEAD) |
| OPTIONS | yes | yes | [9.3.7](#OPTIONS) |
| POST | no | no | [9.3.3](#POST) |
| PUT | no | yes | [9.3.4](#PUT) |
| TRACE | yes | yes | [9.3.8](#TRACE) |
| \* | no | no | [18.2](#method.registration) |

The method name "\*" is reserved because using "\*" as a method name would
conflict with its usage as a wildcard in some fields (e.g.,
"Access-Control-Request-Method").[¶](#section-18.2-3)

### [18.3.](#section-18.3) [Status Code Registration](#name-status-code-registration)

IANA has updated the "Hypertext Transfer Protocol (HTTP) Status Code Registry"
at <<https://www.iana.org/assignments/http-status-codes>> with
the registration procedure of [Section 16.2.1](#status.code.registry) and the
status code values summarized in the following table.[¶](#section-18.3-1)

[Table 8](#table-8)
| Value | Description | Section |
| --- | --- | --- |
| 100 | Continue | [15.2.1](#status.100) |
| 101 | Switching Protocols | [15.2.2](#status.101) |
| 200 | OK | [15.3.1](#status.200) |
| 201 | Created | [15.3.2](#status.201) |
| 202 | Accepted | [15.3.3](#status.202) |
| 203 | Non-Authoritative Information | [15.3.4](#status.203) |
| 204 | No Content | [15.3.5](#status.204) |
| 205 | Reset Content | [15.3.6](#status.205) |
| 206 | Partial Content | [15.3.7](#status.206) |
| 300 | Multiple Choices | [15.4.1](#status.300) |
| 301 | Moved Permanently | [15.4.2](#status.301) |
| 302 | Found | [15.4.3](#status.302) |
| 303 | See Other | [15.4.4](#status.303) |
| 304 | Not Modified | [15.4.5](#status.304) |
| 305 | Use Proxy | [15.4.6](#status.305) |
| 306 | (Unused) | [15.4.7](#status.306) |
| 307 | Temporary Redirect | [15.4.8](#status.307) |
| 308 | Permanent Redirect | [15.4.9](#status.308) |
| 400 | Bad Request | [15.5.1](#status.400) |
| 401 | Unauthorized | [15.5.2](#status.401) |
| 402 | Payment Required | [15.5.3](#status.402) |
| 403 | Forbidden | [15.5.4](#status.403) |
| 404 | Not Found | [15.5.5](#status.404) |
| 405 | Method Not Allowed | [15.5.6](#status.405) |
| 406 | Not Acceptable | [15.5.7](#status.406) |
| 407 | Proxy Authentication Required | [15.5.8](#status.407) |
| 408 | Request Timeout | [15.5.9](#status.408) |
| 409 | Conflict | [15.5.10](#status.409) |
| 410 | Gone | [15.5.11](#status.410) |
| 411 | Length Required | [15.5.12](#status.411) |
| 412 | Precondition Failed | [15.5.13](#status.412) |
| 413 | Content Too Large | [15.5.14](#status.413) |
| 414 | URI Too Long | [15.5.15](#status.414) |
| 415 | Unsupported Media Type | [15.5.16](#status.415) |
| 416 | Range Not Satisfiable | [15.5.17](#status.416) |
| 417 | Expectation Failed | [15.5.18](#status.417) |
| 418 | (Unused) | [15.5.19](#status.418) |
| 421 | Misdirected Request | [15.5.20](#status.421) |
| 422 | Unprocessable Content | [15.5.21](#status.422) |
| 426 | Upgrade Required | [15.5.22](#status.426) |
| 500 | Internal Server Error | [15.6.1](#status.500) |
| 501 | Not Implemented | [15.6.2](#status.501) |
| 502 | Bad Gateway | [15.6.3](#status.502) |
| 503 | Service Unavailable | [15.6.4](#status.503) |
| 504 | Gateway Timeout | [15.6.5](#status.504) |
| 505 | HTTP Version Not Supported | [15.6.6](#status.505) |

### [18.4.](#section-18.4) [Field Name Registration](#name-field-name-registration)

This specification updates the HTTP-related aspects of the existing
registration procedures for message header fields defined in [[RFC3864](#RFC3864)].
It replaces the old procedures as they relate to HTTP by defining a new
registration procedure and moving HTTP field definitions into a separate
registry.[¶](#section-18.4-1)

IANA has created a new registry titled "Hypertext Transfer Protocol (HTTP)
Field Name Registry" as outlined in [Section 16.3.1](#fields.registry).[¶](#section-18.4-2)

IANA has moved all entries in the "Permanent Message Header Field
Names" and "Provisional Message Header Field Names" registries (see
<<https://www.iana.org/assignments/message-headers/>>) with the
protocol 'http' to this registry and has applied the following changes:[¶](#section-18.4-3)

1. The 'Applicable Protocol' field has been omitted.[¶](#section-18.4-4.1)
2. Entries that had a status of 'standard', 'experimental', 'reserved', or
   'informational' have been made to have a status of 'permanent'.[¶](#section-18.4-4.2)
3. Provisional entries without a status have been made to have a status of
   'provisional'.[¶](#section-18.4-4.3)
4. Permanent entries without a status (after confirmation that the
   registration document did not define one) have been made to have a status of
   'provisional'. The expert(s) can choose to update the entries' status if there is
   evidence that another is more appropriate.[¶](#section-18.4-4.4)

IANA has annotated the "Permanent Message Header Field
Names" and "Provisional Message Header Field Names" registries with the
following note to indicate that HTTP field name registrations have moved:[¶](#section-18.4-5)

**Note**[¶](#section-18.4-6.1)

HTTP field name registrations have been moved to
[<https://www.iana.org/assignments/http-fields>] per
[RFC9110].[¶](#section-18.4-6.2)

IANA has updated the "Hypertext Transfer Protocol (HTTP) Field Name Registry"
with the field names listed in the following table.[¶](#section-18.4-7)

[Table 9](#table-9)
| Field Name | Status | Section | Comments |
| --- | --- | --- | --- |
| Accept | permanent | [12.5.1](#field.accept) |  |
| Accept-Charset | deprecated | [12.5.2](#field.accept-charset) |  |
| Accept-Encoding | permanent | [12.5.3](#field.accept-encoding) |  |
| Accept-Language | permanent | [12.5.4](#field.accept-language) |  |
| Accept-Ranges | permanent | [14.3](#field.accept-ranges) |  |
| Allow | permanent | [10.2.1](#field.allow) |  |
| Authentication-Info | permanent | [11.6.3](#field.authentication-info) |  |
| Authorization | permanent | [11.6.2](#field.authorization) |  |
| Connection | permanent | [7.6.1](#field.connection) |  |
| Content-Encoding | permanent | [8.4](#field.content-encoding) |  |
| Content-Language | permanent | [8.5](#field.content-language) |  |
| Content-Length | permanent | [8.6](#field.content-length) |  |
| Content-Location | permanent | [8.7](#field.content-location) |  |
| Content-Range | permanent | [14.4](#field.content-range) |  |
| Content-Type | permanent | [8.3](#field.content-type) |  |
| Date | permanent | [6.6.1](#field.date) |  |
| ETag | permanent | [8.8.3](#field.etag) |  |
| Expect | permanent | [10.1.1](#field.expect) |  |
| From | permanent | [10.1.2](#field.from) |  |
| Host | permanent | [7.2](#field.host) |  |
| If-Match | permanent | [13.1.1](#field.if-match) |  |
| If-Modified-Since | permanent | [13.1.3](#field.if-modified-since) |  |
| If-None-Match | permanent | [13.1.2](#field.if-none-match) |  |
| If-Range | permanent | [13.1.5](#field.if-range) |  |
| If-Unmodified-Since | permanent | [13.1.4](#field.if-unmodified-since) |  |
| Last-Modified | permanent | [8.8.2](#field.last-modified) |  |
| Location | permanent | [10.2.2](#field.location) |  |
| Max-Forwards | permanent | [7.6.2](#field.max-forwards) |  |
| Proxy-Authenticate | permanent | [11.7.1](#field.proxy-authenticate) |  |
| Proxy-Authentication-Info | permanent | [11.7.3](#field.proxy-authentication-info) |  |
| Proxy-Authorization | permanent | [11.7.2](#field.proxy-authorization) |  |
| Range | permanent | [14.2](#field.range) |  |
| Referer | permanent | [10.1.3](#field.referer) |  |
| Retry-After | permanent | [10.2.3](#field.retry-after) |  |
| Server | permanent | [10.2.4](#field.server) |  |
| TE | permanent | [10.1.4](#field.te) |  |
| Trailer | permanent | [6.6.2](#field.trailer) |  |
| Upgrade | permanent | [7.8](#field.upgrade) |  |
| User-Agent | permanent | [10.1.5](#field.user-agent) |  |
| Vary | permanent | [12.5.5](#field.vary) |  |
| Via | permanent | [7.6.3](#field.via) |  |
| WWW-Authenticate | permanent | [11.6.1](#field.www-authenticate) |  |
| \* | permanent | [12.5.5](#field.vary) | (reserved) |

The field name "\*" is reserved because using that name as
an HTTP header field might conflict with its special semantics in the
[Vary](#field.vary) header field ([Section 12.5.5](#field.vary)).[¶](#section-18.4-9)

IANA has updated the "Content-MD5" entry in the new registry to have
a status of 'obsoleted' with references to
[Section 14.15](https://www.rfc-editor.org/rfc/rfc2616#section-14.15) of [[RFC2616](#RFC2616)] (for the definition
of the header field) and
[Appendix B](https://www.rfc-editor.org/rfc/rfc7231#appendix-B) of [[RFC7231](#RFC7231)] (which removed the field
definition from the updated specification).[¶](#section-18.4-10)

### [18.5.](#section-18.5) [Authentication Scheme Registration](#name-authentication-scheme-regist)

IANA has updated the
"Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry"
at <<https://www.iana.org/assignments/http-authschemes>> with
the registration procedure of [Section 16.4.1](#auth.scheme.registry).
No authentication schemes are defined in this document.[¶](#section-18.5-1)

### [18.6.](#section-18.6) [Content Coding Registration](#name-content-coding-registration)

IANA has updated the "HTTP Content Coding Registry" at
<<https://www.iana.org/assignments/http-parameters/>>
with the registration procedure of [Section 16.6.1](#content.coding.registry)
and the content coding names summarized in the table below.[¶](#section-18.6-1)

[Table 10](#table-10)
| Name | Description | Section |
| --- | --- | --- |
| compress | UNIX "compress" data format [[Welch](#Welch)] | [8.4.1.1](#compress.coding) |
| deflate | "deflate" compressed data ([[RFC1951](#RFC1951)]) inside the "zlib" data format ([[RFC1950](#RFC1950)]) | [8.4.1.2](#deflate.coding) |
| gzip | GZIP file format [[RFC1952](#RFC1952)] | [8.4.1.3](#gzip.coding) |
| identity | Reserved | [12.5.3](#field.accept-encoding) |
| x-compress | Deprecated (alias for compress) | [8.4.1.1](#compress.coding) |
| x-gzip | Deprecated (alias for gzip) | [8.4.1.3](#gzip.coding) |

### [18.7.](#section-18.7) [Range Unit Registration](#name-range-unit-registration)

IANA has updated the "HTTP Range Unit Registry" at
<<https://www.iana.org/assignments/http-parameters/>>
with the registration procedure of [Section 16.5.1](#range.unit.registry)
and the range unit names summarized in the table below.[¶](#section-18.7-1)

[Table 11](#table-11)
| Range Unit Name | Description | Section |
| --- | --- | --- |
| bytes | a range of octets | [14.1.2](#byte.ranges) |
| none | reserved as keyword to indicate range requests are not supported | [14.3](#field.accept-ranges) |

### [18.8.](#section-18.8) [Media Type Registration](#name-media-type-registration)

IANA has updated the "Media Types" registry at
<<https://www.iana.org/assignments/media-types>>
with the registration information in
[Section 14.6](#multipart.byteranges)
for the media type "multipart/byteranges".[¶](#section-18.8-1)

IANA has updated the registry note about "q" parameters with
a link to [Section 12.5.1](#field.accept) of this document.[¶](#section-18.8-2)

### [18.9.](#section-18.9) [Port Registration](#name-port-registration)

IANA has updated the "Service Name and Transport Protocol Port Number
Registry" at <<https://www.iana.org/assignments/service-names-port-numbers/>>
for the services on ports 80 and 443 that use UDP or TCP to:[¶](#section-18.9-1)

1. use this document as "Reference", and[¶](#section-18.9-2.1)
2. when currently unspecified, set "Assignee" to "IESG" and "Contact" to
   "IETF\_Chair".[¶](#section-18.9-2.2)

### [18.10.](#section-18.10) [Upgrade Token Registration](#name-upgrade-token-registration)

IANA has updated the
"Hypertext Transfer Protocol (HTTP) Upgrade Token Registry" at
<<https://www.iana.org/assignments/http-upgrade-tokens>>
with the registration procedure described in [Section 16.7](#upgrade.token.registry)
and the upgrade token names summarized in the following table.[¶](#section-18.10-1)

[Table 12](#table-12)
| Name | Description | Expected Version Tokens | Section |
| --- | --- | --- | --- |
| HTTP | Hypertext Transfer Protocol | any DIGIT.DIGIT (e.g., "2.0") | [2.5](#protocol.version) |

## [19.](#section-19) [References](#name-references)

### [19.1.](#section-19.1) [Normative References](#name-normative-references)

[CACHING]
Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., "HTTP Caching", STD 98, RFC 9111, DOI 10.17487/RFC9111, June 2022, <<https://www.rfc-editor.org/info/rfc9111>>.

[RFC1950]
Deutsch, P. and J-L. Gailly, "ZLIB Compressed Data Format Specification version 3.3", RFC 1950, DOI 10.17487/RFC1950, May 1996, <<https://www.rfc-editor.org/info/rfc1950>>.

[RFC1951]
Deutsch, P., "DEFLATE Compressed Data Format Specification version 1.3", RFC 1951, DOI 10.17487/RFC1951, May 1996, <<https://www.rfc-editor.org/info/rfc1951>>.

[RFC1952]
Deutsch, P., "GZIP file format specification version 4.3", RFC 1952, DOI 10.17487/RFC1952, May 1996, <<https://www.rfc-editor.org/info/rfc1952>>.

[RFC2046]
Freed, N. and N. Borenstein, "Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types", RFC 2046, DOI 10.17487/RFC2046, November 1996, <<https://www.rfc-editor.org/info/rfc2046>>.

[RFC2119]
Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <<https://www.rfc-editor.org/info/rfc2119>>.

[RFC4647]
Phillips, A., Ed. and M. Davis, Ed., "Matching of Language Tags", BCP 47, RFC 4647, DOI 10.17487/RFC4647, September 2006, <<https://www.rfc-editor.org/info/rfc4647>>.

[RFC4648]
Josefsson, S., "The Base16, Base32, and Base64 Data Encodings", RFC 4648, DOI 10.17487/RFC4648, October 2006, <<https://www.rfc-editor.org/info/rfc4648>>.

[RFC5234]
Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax Specifications: ABNF", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <<https://www.rfc-editor.org/info/rfc5234>>.

[RFC5280]
Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, "Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008, <<https://www.rfc-editor.org/info/rfc5280>>.

[RFC5322]
Resnick, P., Ed., "Internet Message Format", RFC 5322, DOI 10.17487/RFC5322, October 2008, <<https://www.rfc-editor.org/info/rfc5322>>.

[RFC5646]
Phillips, A., Ed. and M. Davis, Ed., "Tags for Identifying Languages", BCP 47, RFC 5646, DOI 10.17487/RFC5646, September 2009, <<https://www.rfc-editor.org/info/rfc5646>>.

[RFC6125]
Saint-Andre, P. and J. Hodges, "Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)", RFC 6125, DOI 10.17487/RFC6125, March 2011, <<https://www.rfc-editor.org/info/rfc6125>>.

[RFC6365]
Hoffman, P. and J. Klensin, "Terminology Used in Internationalization in the IETF", BCP 166, RFC 6365, DOI 10.17487/RFC6365, September 2011, <<https://www.rfc-editor.org/info/rfc6365>>.

[RFC7405]
Kyzivat, P., "Case-Sensitive String Support in ABNF", RFC 7405, DOI 10.17487/RFC7405, December 2014, <<https://www.rfc-editor.org/info/rfc7405>>.

[RFC8174]
Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <<https://www.rfc-editor.org/info/rfc8174>>.

[TCP]
Postel, J., "Transmission Control Protocol", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <<https://www.rfc-editor.org/info/rfc793>>.

[TLS13]
Rescorla, E., "The Transport Layer Security (TLS) Protocol Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018, <<https://www.rfc-editor.org/info/rfc8446>>.

[URI]
Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform Resource Identifier (URI): Generic Syntax", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <<https://www.rfc-editor.org/info/rfc3986>>.

[USASCII]
American National Standards Institute, "Coded Character Set -- 7-bit American Standard Code for Information Interchange", ANSI X3.4, 1986.

[Welch]
Welch, T., "A Technique for High-Performance Data Compression", IEEE Computer 17(6), DOI 10.1109/MC.1984.1659158, June 1984, <<https://ieeexplore.ieee.org/document/1659158/>>.

### [19.2.](#section-19.2) [Informative References](#name-informative-references)

[ALTSVC]
Nottingham, M., McManus, P., and J. Reschke, "HTTP Alternative Services", RFC 7838, DOI 10.17487/RFC7838, April 2016, <<https://www.rfc-editor.org/info/rfc7838>>.

[BCP13]
Freed, N. and J. Klensin, "Multipurpose Internet Mail Extensions (MIME) Part Four: Registration Procedures", BCP 13, RFC 4289, December 2005.
Freed, N., Klensin, J., and T. Hansen, "Media Type Specifications and Registration Procedures", BCP 13, RFC 6838, January 2013.
<<https://www.rfc-editor.org/info/bcp13>>

[BCP178]
Saint-Andre, P., Crocker, D., and M. Nottingham, "Deprecating the "X-" Prefix and Similar Constructs in Application Protocols", BCP 178, RFC 6648, June 2012.
<<https://www.rfc-editor.org/info/bcp178>>

[BCP35]
Thaler, D., Ed., Hansen, T., and T. Hardie, "Guidelines and Registration Procedures for URI Schemes", BCP 35, RFC 7595, June 2015.
<<https://www.rfc-editor.org/info/bcp35>>

[BREACH]
Gluck, Y., Harris, N., and A. Prado, "BREACH: Reviving the CRIME Attack", July 2013, <[http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf](http://breachattack.com/resources/BREACH%20-%20SSL%2C%20gone%20in%2030%20seconds.pdf)>.

[Bujlow]
Bujlow, T., Carela-Español, V., Solé-Pareta, J., and P. Barlet-Ros, "A Survey on Web Tracking: Mechanisms, Implications, and Defenses", In Proceedings of the IEEE 105(8), DOI 10.1109/JPROC.2016.2637878, August 2017, <<https://doi.org/10.1109/JPROC.2016.2637878>>.

[COOKIE]
Barth, A., "HTTP State Management Mechanism", RFC 6265, DOI 10.17487/RFC6265, April 2011, <<https://www.rfc-editor.org/info/rfc6265>>.

[Err1912]
RFC Errata, Erratum ID 1912, RFC 2978, <<https://www.rfc-editor.org/errata/eid1912>>.

[Err5433]
RFC Errata, Erratum ID 5433, RFC 2978, <<https://www.rfc-editor.org/errata/eid5433>>.

[Georgiev]
Georgiev, M., Iyengar, S., Jana, S., Anubhai, R., Boneh, D., and V. Shmatikov, "The Most Dangerous Code in the World: Validating SSL Certificates in Non-Browser Software", In Proceedings of the 2012 ACM Conference on Computer and Communications Security (CCS '12), pp. 38-49, DOI 10.1145/2382196.2382204, October 2012, <<https://doi.org/10.1145/2382196.2382204>>.

[HPACK]
Peon, R. and H. Ruellan, "HPACK: Header Compression for HTTP/2", RFC 7541, DOI 10.17487/RFC7541, May 2015, <<https://www.rfc-editor.org/info/rfc7541>>.

[HTTP/1.0]
Berners-Lee, T., Fielding, R., and H. Frystyk, "Hypertext Transfer Protocol -- HTTP/1.0", RFC 1945, DOI 10.17487/RFC1945, May 1996, <<https://www.rfc-editor.org/info/rfc1945>>.

[HTTP/1.1]
Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., "HTTP/1.1", STD 99, RFC 9112, DOI 10.17487/RFC9112, June 2022, <<https://www.rfc-editor.org/info/rfc9112>>.

[HTTP/2]
Thomson, M., Ed. and C. Benfield, Ed., "HTTP/2", RFC 9113, DOI 10.17487/RFC9113, June 2022, <<https://www.rfc-editor.org/info/rfc9113>>.

[HTTP/3]
Bishop, M., Ed., "HTTP/3", RFC 9114, DOI 10.17487/RFC9114, June 2022, <<https://www.rfc-editor.org/info/rfc9114>>.

[ISO-8859-1]
International Organization for Standardization, "Information technology -- 8-bit single-byte coded graphic character sets -- Part 1: Latin alphabet No. 1", ISO/IEC 8859-1:1998, 1998.

[Kri2001]
Kristol, D., "HTTP Cookies: Standards, Privacy, and Politics", ACM Transactions on Internet Technology 1(2), November 2001, <<http://arxiv.org/abs/cs.SE/0105018>>.

[OWASP]
The Open Web Application Security Project, <<https://www.owasp.org/>>.

[REST]
Fielding, R.T., "Architectural Styles and the Design of Network-based Software Architectures", Doctoral Dissertation, University of California, Irvine, September 2000, <<https://roy.gbiv.com/pubs/dissertation/top.htm>>.

[RFC1919]
Chatel, M., "Classical versus Transparent IP Proxies", RFC 1919, DOI 10.17487/RFC1919, March 1996, <<https://www.rfc-editor.org/info/rfc1919>>.

[RFC2047]
Moore, K., "MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text", RFC 2047, DOI 10.17487/RFC2047, November 1996, <<https://www.rfc-editor.org/info/rfc2047>>.

[RFC2068]
Fielding, R., Gettys, J., Mogul, J., Frystyk, H., and T. Berners-Lee, "Hypertext Transfer Protocol -- HTTP/1.1", RFC 2068, DOI 10.17487/RFC2068, January 1997, <<https://www.rfc-editor.org/info/rfc2068>>.

[RFC2145]
Mogul, J. C., Fielding, R., Gettys, J., and H. Frystyk, "Use and Interpretation of HTTP Version Numbers", RFC 2145, DOI 10.17487/RFC2145, May 1997, <<https://www.rfc-editor.org/info/rfc2145>>.

[RFC2295]
Holtman, K. and A. Mutz, "Transparent Content Negotiation in HTTP", RFC 2295, DOI 10.17487/RFC2295, March 1998, <<https://www.rfc-editor.org/info/rfc2295>>.

[RFC2324]
Masinter, L., "Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)", RFC 2324, DOI 10.17487/RFC2324, 1 April 1998, <<https://www.rfc-editor.org/info/rfc2324>>.

[RFC2557]
Palme, J., Hopmann, A., and N. Shelness, "MIME Encapsulation of Aggregate Documents, such as HTML (MHTML)", RFC 2557, DOI 10.17487/RFC2557, March 1999, <<https://www.rfc-editor.org/info/rfc2557>>.

[RFC2616]
Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext Transfer Protocol -- HTTP/1.1", RFC 2616, DOI 10.17487/RFC2616, June 1999, <<https://www.rfc-editor.org/info/rfc2616>>.

[RFC2617]
Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., and L. Stewart, "HTTP Authentication: Basic and Digest Access Authentication", RFC 2617, DOI 10.17487/RFC2617, June 1999, <<https://www.rfc-editor.org/info/rfc2617>>.

[RFC2774]
Nielsen, H., Leach, P., and S. Lawrence, "An HTTP Extension Framework", RFC 2774, DOI 10.17487/RFC2774, February 2000, <<https://www.rfc-editor.org/info/rfc2774>>.

[RFC2818]
Rescorla, E., "HTTP Over TLS", RFC 2818, DOI 10.17487/RFC2818, May 2000, <<https://www.rfc-editor.org/info/rfc2818>>.

[RFC2978]
Freed, N. and J. Postel, "IANA Charset Registration Procedures", BCP 19, RFC 2978, DOI 10.17487/RFC2978, October 2000, <<https://www.rfc-editor.org/info/rfc2978>>.

[RFC3040]
Cooper, I., Melve, I., and G. Tomlinson, "Internet Web Replication and Caching Taxonomy", RFC 3040, DOI 10.17487/RFC3040, January 2001, <<https://www.rfc-editor.org/info/rfc3040>>.

[RFC3864]
Klyne, G., Nottingham, M., and J. Mogul, "Registration Procedures for Message Header Fields", BCP 90, RFC 3864, DOI 10.17487/RFC3864, September 2004, <<https://www.rfc-editor.org/info/rfc3864>>.

[RFC3875]
Robinson, D. and K. Coar, "The Common Gateway Interface (CGI) Version 1.1", RFC 3875, DOI 10.17487/RFC3875, October 2004, <<https://www.rfc-editor.org/info/rfc3875>>.

[RFC4033]
Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, "DNS Security Introduction and Requirements", RFC 4033, DOI 10.17487/RFC4033, March 2005, <<https://www.rfc-editor.org/info/rfc4033>>.

[RFC4559]
Jaganathan, K., Zhu, L., and J. Brezak, "SPNEGO-based Kerberos and NTLM HTTP Authentication in Microsoft Windows", RFC 4559, DOI 10.17487/RFC4559, June 2006, <<https://www.rfc-editor.org/info/rfc4559>>.

[RFC5789]
Dusseault, L. and J. Snell, "PATCH Method for HTTP", RFC 5789, DOI 10.17487/RFC5789, March 2010, <<https://www.rfc-editor.org/info/rfc5789>>.

[RFC5905]
Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch, "Network Time Protocol Version 4: Protocol and Algorithms Specification", RFC 5905, DOI 10.17487/RFC5905, June 2010, <<https://www.rfc-editor.org/info/rfc5905>>.

[RFC6454]
Barth, A., "The Web Origin Concept", RFC 6454, DOI 10.17487/RFC6454, December 2011, <<https://www.rfc-editor.org/info/rfc6454>>.

[RFC6585]
Nottingham, M. and R. Fielding, "Additional HTTP Status Codes", RFC 6585, DOI 10.17487/RFC6585, April 2012, <<https://www.rfc-editor.org/info/rfc6585>>.

[RFC7230]
Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing", RFC 7230, DOI 10.17487/RFC7230, June 2014, <<https://www.rfc-editor.org/info/rfc7230>>.

[RFC7231]
Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content", RFC 7231, DOI 10.17487/RFC7231, June 2014, <<https://www.rfc-editor.org/info/rfc7231>>.

[RFC7232]
Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests", RFC 7232, DOI 10.17487/RFC7232, June 2014, <<https://www.rfc-editor.org/info/rfc7232>>.

[RFC7233]
Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., "Hypertext Transfer Protocol (HTTP/1.1): Range Requests", RFC 7233, DOI 10.17487/RFC7233, June 2014, <<https://www.rfc-editor.org/info/rfc7233>>.

[RFC7234]
Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., "Hypertext Transfer Protocol (HTTP/1.1): Caching", RFC 7234, DOI 10.17487/RFC7234, June 2014, <<https://www.rfc-editor.org/info/rfc7234>>.

[RFC7235]
Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer Protocol (HTTP/1.1): Authentication", RFC 7235, DOI 10.17487/RFC7235, June 2014, <<https://www.rfc-editor.org/info/rfc7235>>.

[RFC7538]
Reschke, J., "The Hypertext Transfer Protocol Status Code 308 (Permanent Redirect)", RFC 7538, DOI 10.17487/RFC7538, April 2015, <<https://www.rfc-editor.org/info/rfc7538>>.

[RFC7540]
Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext Transfer Protocol Version 2 (HTTP/2)", RFC 7540, DOI 10.17487/RFC7540, May 2015, <<https://www.rfc-editor.org/info/rfc7540>>.

[RFC7578]
Masinter, L., "Returning Values from Forms: multipart/form-data", RFC 7578, DOI 10.17487/RFC7578, July 2015, <<https://www.rfc-editor.org/info/rfc7578>>.

[RFC7615]
Reschke, J., "HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields", RFC 7615, DOI 10.17487/RFC7615, September 2015, <<https://www.rfc-editor.org/info/rfc7615>>.

[RFC7616]
Shekh-Yusef, R., Ed., Ahrens, D., and S. Bremer, "HTTP Digest Access Authentication", RFC 7616, DOI 10.17487/RFC7616, September 2015, <<https://www.rfc-editor.org/info/rfc7616>>.

[RFC7617]
Reschke, J., "The 'Basic' HTTP Authentication Scheme", RFC 7617, DOI 10.17487/RFC7617, September 2015, <<https://www.rfc-editor.org/info/rfc7617>>.

[RFC7694]
Reschke, J., "Hypertext Transfer Protocol (HTTP) Client-Initiated Content-Encoding", RFC 7694, DOI 10.17487/RFC7694, November 2015, <<https://www.rfc-editor.org/info/rfc7694>>.

[RFC8126]
Cotton, M., Leiba, B., and T. Narten, "Guidelines for Writing an IANA Considerations Section in RFCs", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <<https://www.rfc-editor.org/info/rfc8126>>.

[RFC8187]
Reschke, J., "Indicating Character Encoding and Language for HTTP Header Field Parameters", RFC 8187, DOI 10.17487/RFC8187, September 2017, <<https://www.rfc-editor.org/info/rfc8187>>.

[RFC8246]
McManus, P., "HTTP Immutable Responses", RFC 8246, DOI 10.17487/RFC8246, September 2017, <<https://www.rfc-editor.org/info/rfc8246>>.

[RFC8288]
Nottingham, M., "Web Linking", RFC 8288, DOI 10.17487/RFC8288, October 2017, <<https://www.rfc-editor.org/info/rfc8288>>.

[RFC8336]
Nottingham, M. and E. Nygren, "The ORIGIN HTTP/2 Frame", RFC 8336, DOI 10.17487/RFC8336, March 2018, <<https://www.rfc-editor.org/info/rfc8336>>.

[RFC8615]
Nottingham, M., "Well-Known Uniform Resource Identifiers (URIs)", RFC 8615, DOI 10.17487/RFC8615, May 2019, <<https://www.rfc-editor.org/info/rfc8615>>.

[RFC8941]
Nottingham, M. and P-H. Kamp, "Structured Field Values for HTTP", RFC 8941, DOI 10.17487/RFC8941, February 2021, <<https://www.rfc-editor.org/info/rfc8941>>.

[Sniffing]
WHATWG, "MIME Sniffing", <<https://mimesniff.spec.whatwg.org>>.

[WEBDAV]
Dusseault, L., Ed., "HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)", RFC 4918, DOI 10.17487/RFC4918, June 2007, <<https://www.rfc-editor.org/info/rfc4918>>.

## [Appendix A.](#appendix-A) [Collected ABNF](#name-collected-abnf)

In the collected ABNF below, list rules are expanded per [Section 5.6.1](#abnf.extension).[¶](#appendix-A-1)

```
Accept = [ ( media-range [ weight ] ) *( OWS "," OWS ( media-range [
 weight ] ) ) ]
Accept-Charset = [ ( ( token / "*" ) [ weight ] ) *( OWS "," OWS ( (
 token / "*" ) [ weight ] ) ) ]
Accept-Encoding = [ ( codings [ weight ] ) *( OWS "," OWS ( codings [
 weight ] ) ) ]
Accept-Language = [ ( language-range [ weight ] ) *( OWS "," OWS (
 language-range [ weight ] ) ) ]
Accept-Ranges = acceptable-ranges
Allow = [ method *( OWS "," OWS method ) ]
Authentication-Info = [ auth-param *( OWS "," OWS auth-param ) ]
Authorization = credentials

BWS = OWS

Connection = [ connection-option *( OWS "," OWS connection-option )
 ]
Content-Encoding = [ content-coding *( OWS "," OWS content-coding )
 ]
Content-Language = [ language-tag *( OWS "," OWS language-tag ) ]
Content-Length = 1*DIGIT
Content-Location = absolute-URI / partial-URI
Content-Range = range-unit SP ( range-resp / unsatisfied-range )
Content-Type = media-type

Date = HTTP-date

ETag = entity-tag
Expect = [ expectation *( OWS "," OWS expectation ) ]

From = mailbox

GMT = %x47.4D.54 ; GMT

HTTP-date = IMF-fixdate / obs-date
Host = uri-host [ ":" port ]

IMF-fixdate = day-name "," SP date1 SP time-of-day SP GMT
If-Match = "*" / [ entity-tag *( OWS "," OWS entity-tag ) ]
If-Modified-Since = HTTP-date
If-None-Match = "*" / [ entity-tag *( OWS "," OWS entity-tag ) ]
If-Range = entity-tag / HTTP-date
If-Unmodified-Since = HTTP-date

Last-Modified = HTTP-date
Location = URI-reference

Max-Forwards = 1*DIGIT

OWS = *( SP / HTAB )

Proxy-Authenticate = [ challenge *( OWS "," OWS challenge ) ]
Proxy-Authentication-Info = [ auth-param *( OWS "," OWS auth-param )
 ]
Proxy-Authorization = credentials

RWS = 1*( SP / HTAB )
Range = ranges-specifier
Referer = absolute-URI / partial-URI
Retry-After = HTTP-date / delay-seconds

Server = product *( RWS ( product / comment ) )

TE = [ t-codings *( OWS "," OWS t-codings ) ]
Trailer = [ field-name *( OWS "," OWS field-name ) ]

URI-reference = <URI-reference, see [URI], Section 4.1>
Upgrade = [ protocol *( OWS "," OWS protocol ) ]
User-Agent = product *( RWS ( product / comment ) )

Vary = [ ( "*" / field-name ) *( OWS "," OWS ( "*" / field-name ) )
 ]
Via = [ ( received-protocol RWS received-by [ RWS comment ] ) *( OWS
 "," OWS ( received-protocol RWS received-by [ RWS comment ] ) ) ]

WWW-Authenticate = [ challenge *( OWS "," OWS challenge ) ]

absolute-URI = <absolute-URI, see [URI], Section 4.3>
absolute-path = 1*( "/" segment )
acceptable-ranges = range-unit *( OWS "," OWS range-unit )
asctime-date = day-name SP date3 SP time-of-day SP year
auth-param = token BWS "=" BWS ( token / quoted-string )
auth-scheme = token
authority = <authority, see [URI], Section 3.2>

challenge = auth-scheme [ 1*SP ( token68 / [ auth-param *( OWS ","
 OWS auth-param ) ] ) ]
codings = content-coding / "identity" / "*"
comment = "(" *( ctext / quoted-pair / comment ) ")"
complete-length = 1*DIGIT
connection-option = token
content-coding = token
credentials = auth-scheme [ 1*SP ( token68 / [ auth-param *( OWS ","
 OWS auth-param ) ] ) ]
ctext = HTAB / SP / %x21-27 ; '!'-'''
 / %x2A-5B ; '*'-'['
 / %x5D-7E ; ']'-'~'
 / obs-text

date1 = day SP month SP year
date2 = day "-" month "-" 2DIGIT
date3 = month SP ( 2DIGIT / ( SP DIGIT ) )
day = 2DIGIT
day-name = %x4D.6F.6E ; Mon
 / %x54.75.65 ; Tue
 / %x57.65.64 ; Wed
 / %x54.68.75 ; Thu
 / %x46.72.69 ; Fri
 / %x53.61.74 ; Sat
 / %x53.75.6E ; Sun
day-name-l = %x4D.6F.6E.64.61.79 ; Monday
 / %x54.75.65.73.64.61.79 ; Tuesday
 / %x57.65.64.6E.65.73.64.61.79 ; Wednesday
 / %x54.68.75.72.73.64.61.79 ; Thursday
 / %x46.72.69.64.61.79 ; Friday
 / %x53.61.74.75.72.64.61.79 ; Saturday
 / %x53.75.6E.64.61.79 ; Sunday
delay-seconds = 1*DIGIT

entity-tag = [ weak ] opaque-tag
etagc = "!" / %x23-7E ; '#'-'~'
 / obs-text
expectation = token [ "=" ( token / quoted-string ) parameters ]

field-content = field-vchar [ 1*( SP / HTAB / field-vchar )
 field-vchar ]
field-name = token
field-value = *field-content
field-vchar = VCHAR / obs-text
first-pos = 1*DIGIT

hour = 2DIGIT
http-URI = "http://" authority path-abempty [ "?" query ]
https-URI = "https://" authority path-abempty [ "?" query ]

incl-range = first-pos "-" last-pos
int-range = first-pos "-" [ last-pos ]

language-range = <language-range, see [RFC4647], Section 2.1>
language-tag = <Language-Tag, see [RFC5646], Section 2.1>
last-pos = 1*DIGIT

mailbox = <mailbox, see [RFC5322], Section 3.4>
media-range = ( "*/*" / ( type "/*" ) / ( type "/" subtype ) )
 parameters
media-type = type "/" subtype parameters
method = token
minute = 2DIGIT
month = %x4A.61.6E ; Jan
 / %x46.65.62 ; Feb
 / %x4D.61.72 ; Mar
 / %x41.70.72 ; Apr
 / %x4D.61.79 ; May
 / %x4A.75.6E ; Jun
 / %x4A.75.6C ; Jul
 / %x41.75.67 ; Aug
 / %x53.65.70 ; Sep
 / %x4F.63.74 ; Oct
 / %x4E.6F.76 ; Nov
 / %x44.65.63 ; Dec

obs-date = rfc850-date / asctime-date
obs-text = %x80-FF
opaque-tag = DQUOTE *etagc DQUOTE
other-range = 1*( %x21-2B ; '!'-'+'
 / %x2D-7E ; '-'-'~'
 )

parameter = parameter-name "=" parameter-value
parameter-name = token
parameter-value = ( token / quoted-string )
parameters = *( OWS ";" OWS [ parameter ] )
partial-URI = relative-part [ "?" query ]
path-abempty = <path-abempty, see [URI], Section 3.3>
port = <port, see [URI], Section 3.2.3>
product = token [ "/" product-version ]
product-version = token
protocol = protocol-name [ "/" protocol-version ]
protocol-name = token
protocol-version = token
pseudonym = token

qdtext = HTAB / SP / "!" / %x23-5B ; '#'-'['
 / %x5D-7E ; ']'-'~'
 / obs-text
query = <query, see [URI], Section 3.4>
quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
qvalue = ( "0" [ "." *3DIGIT ] ) / ( "1" [ "." *3"0" ] )

range-resp = incl-range "/" ( complete-length / "*" )
range-set = range-spec *( OWS "," OWS range-spec )
range-spec = int-range / suffix-range / other-range
range-unit = token
ranges-specifier = range-unit "=" range-set
received-by = pseudonym [ ":" port ]
received-protocol = [ protocol-name "/" ] protocol-version
relative-part = <relative-part, see [URI], Section 4.2>
rfc850-date = day-name-l "," SP date2 SP time-of-day SP GMT

second = 2DIGIT
segment = <segment, see [URI], Section 3.3>
subtype = token
suffix-length = 1*DIGIT
suffix-range = "-" suffix-length

t-codings = "trailers" / ( transfer-coding [ weight ] )
tchar = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." /
 "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
time-of-day = hour ":" minute ":" second
token = 1*tchar
token68 = 1*( ALPHA / DIGIT / "-" / "." / "_" / "~" / "+" / "/" )
 *"="
transfer-coding = token *( OWS ";" OWS transfer-parameter )
transfer-parameter = token BWS "=" BWS ( token / quoted-string )
type = token

unsatisfied-range = "*/" complete-length
uri-host = <host, see [URI], Section 3.2.2>

weak = %x57.2F ; W/
weight = OWS ";" OWS "q=" qvalue

year = 4DIGIT

```
[¶](#appendix-A-2)

## [Appendix B.](#appendix-B) [Changes from Previous RFCs](#name-changes-from-previous-rfcs)

### [B.1.](#appendix-B.1) [Changes from RFC 2818](#name-changes-from-rfc-2818)

None.[¶](#appendix-B.1-1)

### [B.2.](#appendix-B.2) [Changes from RFC 7230](#name-changes-from-rfc-7230)

The sections introducing HTTP's design goals, history, architecture,
conformance criteria, protocol versioning, URIs, message routing, and
header fields have been moved here.[¶](#appendix-B.2-1)

The requirement on semantic conformance has been replaced with permission to
ignore or work around implementation-specific failures.
([Section 2.2](#requirements.notation))[¶](#appendix-B.2-2)

The description of an origin and authoritative access to origin servers has
been extended for both "http" and "https" URIs to account for alternative
services and secured connections that are not necessarily based on TCP.
(Sections [4.2.1](#http.uri), [4.2.2](#https.uri),
[4.3.1](#origin), and [7.3.3](#routing.origin))[¶](#appendix-B.2-3)

Explicit requirements have been added to check the target URI scheme's semantics
and reject requests that don't meet any associated requirements.
([Section 7.4](#routing.reject))[¶](#appendix-B.2-4)

Parameters in media type, media range, and expectation can be empty via
one or more trailing semicolons.
([Section 5.6.6](#parameter))[¶](#appendix-B.2-5)

"Field value" now refers to the value after multiple field lines are combined
with commas -- by far the most common use. To refer to a single header
line's value, use "field line value".
([Section 6.3](#header.fields))[¶](#appendix-B.2-6)

Trailer field semantics now transcend the specifics of chunked transfer coding.
The use of trailer fields has been further limited to allow generation
as a trailer field only when the sender knows the field defines that usage and
to allow merging into the header section only if the recipient knows the
corresponding field definition permits and defines how to merge. In all
other cases, implementations are encouraged either to store the trailer
fields separately or to discard them instead of merging.
([Section 6.5.1](#trailers.limitations))[¶](#appendix-B.2-7)

The priority of the absolute form of the request URI over the Host
header field by origin servers has been made explicit to align with proxy handling.
([Section 7.2](#field.host))[¶](#appendix-B.2-8)

The grammar definition for the Via field's "received-by" was
expanded in RFC 7230 due to changes in the URI grammar for host
[[URI](#URI)] that are not desirable for Via. For simplicity,
we have removed uri-host from the received-by production because it can
be encompassed by the existing grammar for pseudonym. In particular, this
change removed comma from the allowed set of characters for a host name in
received-by.
([Section 7.6.3](#field.via))[¶](#appendix-B.2-9)

### [B.3.](#appendix-B.3) [Changes from RFC 7231](#name-changes-from-rfc-7231)

Minimum URI lengths to be supported by implementations are now recommended.
([Section 4.1](#uri.references))[¶](#appendix-B.3-1)

The following have been clarified: CR and NUL in field values are to be rejected or
mapped to SP, and leading and trailing whitespace needs to be
stripped from field values before they are consumed.
([Section 5.5](#fields.values))[¶](#appendix-B.3-2)

Parameters in media type, media range, and expectation can be empty via
one or more trailing semicolons.
([Section 5.6.6](#parameter))[¶](#appendix-B.3-3)

An abstract data type for HTTP messages has been introduced to define the
components of a message and their semantics as an abstraction across
multiple HTTP versions, rather than in terms of the specific syntax form of
HTTP/1.1 in [[HTTP/1.1](#HTTP11)], and reflect the contents after the
message is parsed. This makes it easier to distinguish between requirements
on the content (what is conveyed) versus requirements on the messaging
syntax (how it is conveyed) and avoids baking limitations of early protocol
versions into the future of HTTP. ([Section 6](#message.abstraction))[¶](#appendix-B.3-4)

The terms "payload" and "payload body" have been replaced with "content", to better
align with its usage elsewhere (e.g., in field names) and to avoid confusion
with frame payloads in HTTP/2 and HTTP/3.
([Section 6.4](#content))[¶](#appendix-B.3-5)

The term "effective request URI" has been replaced with "target URI".
([Section 7.1](#target.resource))[¶](#appendix-B.3-6)

Restrictions on client retries have been loosened to reflect implementation
behavior.
([Section 9.2.2](#idempotent.methods))[¶](#appendix-B.3-7)

The fact that request bodies on GET, HEAD, and DELETE are not interoperable has been clarified.
(Sections [9.3.1](#GET), [9.3.2](#HEAD), and [9.3.5](#DELETE))[¶](#appendix-B.3-8)

The use of the [Content-Range](#field.content-range) header field
([Section 14.4](#field.content-range)) as a request modifier on PUT is allowed.
([Section 9.3.4](#PUT))[¶](#appendix-B.3-9)

A superfluous requirement about setting [Content-Length](#field.content-length)
has been removed from the description of the OPTIONS method.
([Section 9.3.7](#OPTIONS))[¶](#appendix-B.3-10)

The normative requirement to use the "message/http" media type in
TRACE responses has been removed.
([Section 9.3.8](#TRACE))[¶](#appendix-B.3-11)

List-based grammar for [Expect](#field.expect) has been restored for compatibility with
RFC 2616.
([Section 10.1.1](#field.expect))[¶](#appendix-B.3-12)

[Accept](#field.accept) and [Accept-Encoding](#field.accept-encoding) are allowed in response
messages; the latter was introduced by [[RFC7694](#RFC7694)].
([Section 12.3](#request.content.negotiation))[¶](#appendix-B.3-13)

"Accept Parameters" (accept-params and accept-ext ABNF production) have
been removed from the definition of the Accept field.
([Section 12.5.1](#field.accept))[¶](#appendix-B.3-14)

The Accept-Charset field is now deprecated.
([Section 12.5.2](#field.accept-charset))[¶](#appendix-B.3-15)

The semantics of "\*" in the [Vary](#field.vary) header field when other
values are present was clarified.
([Section 12.5.5](#field.vary))[¶](#appendix-B.3-16)

Range units are compared in a case-insensitive fashion.
([Section 14.1](#range.units))[¶](#appendix-B.3-17)

The use of the Accept-Ranges field is not restricted to origin servers.
([Section 14.3](#field.accept-ranges))[¶](#appendix-B.3-18)

The process of creating a redirected request has been clarified.
([Section 15.4](#status.3xx))[¶](#appendix-B.3-19)

Status code 308 (previously defined in [[RFC7538](#RFC7538)])
has been added so that it's defined closer to status codes 301, 302, and 307.
([Section 15.4.9](#status.308))[¶](#appendix-B.3-20)

Status code 421 (previously defined in
[Section 9.1.2](https://www.rfc-editor.org/rfc/rfc7540#section-9.1.2) of [[RFC7540](#RFC7540)]) has been added because of its general
applicability. 421 is no longer defined as heuristically cacheable since
the response is specific to the connection (not the target resource).
([Section 15.5.20](#status.421))[¶](#appendix-B.3-21)

Status code 422 (previously defined in
[Section 11.2](https://www.rfc-editor.org/rfc/rfc4918#section-11.2) of [[WEBDAV](#WEBDAV)]) has been added because of its general
applicability.
([Section 15.5.21](#status.422))[¶](#appendix-B.3-22)

### [B.4.](#appendix-B.4) [Changes from RFC 7232](#name-changes-from-rfc-7232)

Previous revisions of HTTP imposed an arbitrary 60-second limit on the
determination of whether Last-Modified was a strong validator to guard
against the possibility that the Date and Last-Modified values are
generated from different clocks or at somewhat different times during the
preparation of the response. This specification has relaxed that to allow
reasonable discretion.
([Section 8.8.2.2](#lastmod.comparison))[¶](#appendix-B.4-1)

An edge-case requirement on If-Match and If-Unmodified-Since
has been removed that required a validator not to be sent in a 2xx
response if validation fails because the change request has already
been applied.
(Sections [13.1.1](#field.if-match) and
[13.1.4](#field.if-unmodified-since))[¶](#appendix-B.4-2)

The fact that If-Unmodified-Since does not apply to a resource without a
concept of modification time has been clarified.
([Section 13.1.4](#field.if-unmodified-since))[¶](#appendix-B.4-3)

Preconditions can now be evaluated before the request content is processed
rather than waiting until the response would otherwise be successful.
([Section 13.2](#evaluation))[¶](#appendix-B.4-4)

### [B.5.](#appendix-B.5) [Changes from RFC 7233](#name-changes-from-rfc-7233)

Refactored the range-unit and ranges-specifier grammars to simplify
and reduce artificial distinctions between bytes and other
(extension) range units, removing the overlapping grammar of
other-range-unit by defining range units generically as a token and
placing extensions within the scope of a range-spec (other-range).
This disambiguates the role of list syntax (commas) in all range sets,
including extension range units, for indicating a range-set of more than
one range. Moving the extension grammar into range specifiers also allows
protocol specific to byte ranges to be specified separately.[¶](#appendix-B.5-1)

It is now possible to define Range handling on extension methods.
([Section 14.2](#field.range))[¶](#appendix-B.5-2)

Described use of the [Content-Range](#field.content-range) header field
([Section 14.4](#field.content-range)) as a request modifier to perform a
partial PUT.
([Section 14.5](#partial.PUT))[¶](#appendix-B.5-3)

### [B.6.](#appendix-B.6) [Changes from RFC 7235](#name-changes-from-rfc-7235)

None.[¶](#appendix-B.6-1)

### [B.7.](#appendix-B.7) [Changes from RFC 7538](#name-changes-from-rfc-7538)

None.[¶](#appendix-B.7-1)

### [B.8.](#appendix-B.8) [Changes from RFC 7615](#name-changes-from-rfc-7615)

None.[¶](#appendix-B.8-1)

### [B.9.](#appendix-B.9) [Changes from RFC 7694](#name-changes-from-rfc-7694)

This specification includes the extension defined in [[RFC7694](#RFC7694)]
but leaves out examples and deployment considerations.[¶](#appendix-B.9-1)

## [Acknowledgements](#name-acknowledgements)

Aside from the current editors, the following individuals deserve special
recognition for their contributions to early aspects of HTTP and its
core specifications:
Marc Andreessen, Tim Berners-Lee, Robert Cailliau, Daniel W. Connolly,
Bob Denny, John Franks, Jim Gettys,
Jean-François Groff,
Phillip M. Hallam-Baker,
Koen Holtman, Jeffery L. Hostetler, Shel Kaphan,
Dave Kristol, Yves Lafon, Scott D. Lawrence,
Paul J. Leach, Håkon W. Lie,
Ari Luotonen, Larry Masinter, Rob McCool,
Jeffrey C. Mogul, Lou Montulli,
David Morris, Henrik Frystyk Nielsen, Dave Raggett, Eric Rescorla,
Tony Sanders, Lawrence C. Stewart,
Marc VanHeyningen, and Steve Zilles.[¶](#appendix-C-1)

This document builds on the many contributions
that went into past specifications of HTTP, including
[[HTTP/1.0](#HTTP10)],
[[RFC2068](#RFC2068)],
[[RFC2145](#RFC2145)],
[[RFC2616](#RFC2616)],
[[RFC2617](#RFC2617)],
[[RFC2818](#RFC2818)],
[[RFC7230](#RFC7230)],
[[RFC7231](#RFC7231)],
[[RFC7232](#RFC7232)],
[[RFC7233](#RFC7233)],
[[RFC7234](#RFC7234)], and
[[RFC7235](#RFC7235)].
The acknowledgements within those documents still apply.[¶](#appendix-C-2)

Since 2014, the following contributors have helped improve this
specification by reporting bugs, asking smart questions, drafting or
reviewing text, and evaluating issues:[¶](#appendix-C-3)

Alan Egerton,
Alex Rousskov,
Amichai Rothman,
Amos Jeffries,
Anders Kaseorg,
Andreas Gebhardt,
Anne van Kesteren,
Armin Abfalterer,
Aron Duby,
Asanka Herath,
Asbjørn Ulsberg,
Asta Olofsson,
Attila Gulyas,
Austin Wright,
Barry Pollard,
Ben Burkert,
Benjamin Kaduk,
Björn Höhrmann,
Brad Fitzpatrick,
Chris Pacejo,
Colin Bendell,
Cory Benfield,
Cory Nelson,
Daisuke Miyakawa,
Dale Worley,
Daniel Stenberg,
Danil Suits,
David Benjamin,
David Matson,
David Schinazi,
Дилян Палаузов (Dilyan Palauzov),
Eric Anderson,
Eric Rescorla,
Éric Vyncke,
Erik Kline,
Erwin Pe,
Etan Kissling,
Evert Pot,
Evgeny Vrublevsky,
Florian Best,
Francesca Palombini,
Igor Lubashev,
James Callahan,
James Peach,
Jeffrey Yasskin,
Kalin Gyokov,
Kannan Goundan,
奥 一穂 (Kazuho Oku),
Ken Murchison,
Krzysztof Maczyński,
Lars Eggert,
Lucas Pardue,
Martin Duke,
Martin Dürst,
Martin Thomson,
Martynas Jusevičius,
Matt Menke,
Matthias Pigulla,
Mattias Grenfeldt,
Michael Osipov,
Mike Bishop,
Mike Pennisi,
Mike Taylor,
Mike West,
Mohit Sethi,
Murray Kucherawy,
Nathaniel J. Smith,
Nicholas Hurley,
Nikita Prokhorov,
Patrick McManus,
Piotr Sikora,
Poul-Henning Kamp,
Rick van Rein,
Robert Wilton,
Roberto Polli,
Roman Danyliw,
Samuel Williams,
Semyon Kholodnov,
Simon Pieters,
Simon Schüppel,
Stefan Eissing,
Taylor Hunt,
Todd Greer,
Tommy Pauly,
Vasiliy Faronov,
Vladimir Lashchev,
Wenbo Zhu,
William A. Rowe Jr.,
Willy Tarreau,
Xingwei Liu,
Yishuai Li, and
Zaheduzzaman Sarker.[¶](#appendix-C-4)

## [Index](#name-index)

[1](#rfc.index.u49)
[2](#rfc.index.u50)
[3](#rfc.index.u51)
[4](#rfc.index.u52)
[5](#rfc.index.u53)
[A](#rfc.index.u65)
[B](#rfc.index.u66)
[C](#rfc.index.u67)
[D](#rfc.index.u68)
[E](#rfc.index.u69)
[F](#rfc.index.u70)
[G](#rfc.index.u71)
[H](#rfc.index.u72)
[I](#rfc.index.u73)
[L](#rfc.index.u76)
[M](#rfc.index.u77)
[N](#rfc.index.u78)
[O](#rfc.index.u79)
[P](#rfc.index.u80)
[R](#rfc.index.u82)
[S](#rfc.index.u83)
[T](#rfc.index.u84)
[U](#rfc.index.u85)
[V](#rfc.index.u86)
[W](#rfc.index.u87)
[X](#rfc.index.u88)[¶](#appendix-D-1)

* [1](#rfc.index.u49)[¶](#appendix-D-2.1.1)

  + 100 Continue (status code)

    ***[Section 15.2.1](#status.100)***[¶](#appendix-D-2.1.2.1.1.2.1)

    100-continue (expect value)

    ***[Section 10.1.1](#field.expect)***[¶](#appendix-D-2.1.2.1.1.4.1)

    101 Switching Protocols (status code)

    ***[Section 15.2.2](#status.101)***[¶](#appendix-D-2.1.2.1.1.6.1)

    1xx Informational (status code class)

    ***[Section 15.2](#status.1xx)***[¶](#appendix-D-2.1.2.1.1.8.1)
* [2](#rfc.index.u50)[¶](#appendix-D-2.2.1)

  + 200 OK (status code)

    ***[Section 15.3.1](#status.200)***[¶](#appendix-D-2.2.2.1.1.2.1)

    201 Created (status code)

    ***[Section 15.3.2](#status.201)***[¶](#appendix-D-2.2.2.1.1.4.1)

    202 Accepted (status code)

    ***[Section 15.3.3](#status.202)***[¶](#appendix-D-2.2.2.1.1.6.1)

    203 Non-Authoritative Information (status code)

    ***[Section 15.3.4](#status.203)***[¶](#appendix-D-2.2.2.1.1.8.1)

    204 No Content (status code)

    ***[Section 15.3.5](#status.204)***[¶](#appendix-D-2.2.2.1.1.10.1)

    205 Reset Content (status code)

    ***[Section 15.3.6](#status.205)***[¶](#appendix-D-2.2.2.1.1.12.1)

    206 Partial Content (status code)

    ***[Section 15.3.7](#status.206)***[¶](#appendix-D-2.2.2.1.1.14.1)

    2xx Successful (status code class)

    ***[Section 15.3](#status.2xx)***[¶](#appendix-D-2.2.2.1.1.16.1)
* [3](#rfc.index.u51)[¶](#appendix-D-2.3.1)

  + 300 Multiple Choices (status code)

    ***[Section 15.4.1](#status.300)***[¶](#appendix-D-2.3.2.1.1.2.1)

    301 Moved Permanently (status code)

    ***[Section 15.4.2](#status.301)***[¶](#appendix-D-2.3.2.1.1.4.1)

    302 Found (status code)

    ***[Section 15.4.3](#status.302)***[¶](#appendix-D-2.3.2.1.1.6.1)

    303 See Other (status code)

    ***[Section 15.4.4](#status.303)***[¶](#appendix-D-2.3.2.1.1.8.1)

    304 Not Modified (status code)

    ***[Section 15.4.5](#status.304)***[¶](#appendix-D-2.3.2.1.1.10.1)

    305 Use Proxy (status code)

    ***[Section 15.4.6](#status.305)***[¶](#appendix-D-2.3.2.1.1.12.1)

    306 (Unused) (status code)

    ***[Section 15.4.7](#status.306)***[¶](#appendix-D-2.3.2.1.1.14.1)

    307 Temporary Redirect (status code)

    ***[Section 15.4.8](#status.307)***[¶](#appendix-D-2.3.2.1.1.16.1)

    308 Permanent Redirect (status code)

    ***[Section 15.4.9](#status.308)***[¶](#appendix-D-2.3.2.1.1.18.1)

    3xx Redirection (status code class)

    ***[Section 15.4](#status.3xx)***[¶](#appendix-D-2.3.2.1.1.20.1)
* [4](#rfc.index.u52)[¶](#appendix-D-2.4.1)

  + 400 Bad Request (status code)

    ***[Section 15.5.1](#status.400)***[¶](#appendix-D-2.4.2.1.1.2.1)

    401 Unauthorized (status code)

    ***[Section 15.5.2](#status.401)***[¶](#appendix-D-2.4.2.1.1.4.1)

    402 Payment Required (status code)

    ***[Section 15.5.3](#status.402)***[¶](#appendix-D-2.4.2.1.1.6.1)

    403 Forbidden (status code)

    ***[Section 15.5.4](#status.403)***[¶](#appendix-D-2.4.2.1.1.8.1)

    404 Not Found (status code)

    ***[Section 15.5.5](#status.404)***[¶](#appendix-D-2.4.2.1.1.10.1)

    405 Method Not Allowed (status code)

    ***[Section 15.5.6](#status.405)***[¶](#appendix-D-2.4.2.1.1.12.1)

    406 Not Acceptable (status code)

    ***[Section 15.5.7](#status.406)***[¶](#appendix-D-2.4.2.1.1.14.1)

    407 Proxy Authentication Required (status code)

    ***[Section 15.5.8](#status.407)***[¶](#appendix-D-2.4.2.1.1.16.1)

    408 Request Timeout (status code)

    ***[Section 15.5.9](#status.408)***[¶](#appendix-D-2.4.2.1.1.18.1)

    409 Conflict (status code)

    ***[Section 15.5.10](#status.409)***[¶](#appendix-D-2.4.2.1.1.20.1)

    410 Gone (status code)

    ***[Section 15.5.11](#status.410)***[¶](#appendix-D-2.4.2.1.1.22.1)

    411 Length Required (status code)

    ***[Section 15.5.12](#status.411)***[¶](#appendix-D-2.4.2.1.1.24.1)

    412 Precondition Failed (status code)

    ***[Section 15.5.13](#status.412)***[¶](#appendix-D-2.4.2.1.1.26.1)

    413 Content Too Large (status code)

    ***[Section 15.5.14](#status.413)***[¶](#appendix-D-2.4.2.1.1.28.1)

    414 URI Too Long (status code)

    ***[Section 15.5.15](#status.414)***[¶](#appendix-D-2.4.2.1.1.30.1)

    415 Unsupported Media Type (status code)

    ***[Section 15.5.16](#status.415)***[¶](#appendix-D-2.4.2.1.1.32.1)

    416 Range Not Satisfiable (status code)

    ***[Section 15.5.17](#status.416)***[¶](#appendix-D-2.4.2.1.1.34.1)

    417 Expectation Failed (status code)

    ***[Section 15.5.18](#status.417)***[¶](#appendix-D-2.4.2.1.1.36.1)

    418 (Unused) (status code)

    ***[Section 15.5.19](#status.418)***[¶](#appendix-D-2.4.2.1.1.38.1)

    421 Misdirected Request (status code)

    ***[Section 15.5.20](#status.421)***[¶](#appendix-D-2.4.2.1.1.40.1)

    422 Unprocessable Content (status code)

    ***[Section 15.5.21](#status.422)***[¶](#appendix-D-2.4.2.1.1.42.1)

    426 Upgrade Required (status code)

    ***[Section 15.5.22](#status.426)***[¶](#appendix-D-2.4.2.1.1.44.1)

    4xx Client Error (status code class)

    ***[Section 15.5](#status.4xx)***[¶](#appendix-D-2.4.2.1.1.46.1)
* [5](#rfc.index.u53)[¶](#appendix-D-2.5.1)

  + 500 Internal Server Error (status code)

    ***[Section 15.6.1](#status.500)***[¶](#appendix-D-2.5.2.1.1.2.1)

    501 Not Implemented (status code)

    ***[Section 15.6.2](#status.501)***[¶](#appendix-D-2.5.2.1.1.4.1)

    502 Bad Gateway (status code)

    ***[Section 15.6.3](#status.502)***[¶](#appendix-D-2.5.2.1.1.6.1)

    503 Service Unavailable (status code)

    ***[Section 15.6.4](#status.503)***[¶](#appendix-D-2.5.2.1.1.8.1)

    504 Gateway Timeout (status code)

    ***[Section 15.6.5](#status.504)***[¶](#appendix-D-2.5.2.1.1.10.1)

    505 HTTP Version Not Supported (status code)

    ***[Section 15.6.6](#status.505)***[¶](#appendix-D-2.5.2.1.1.12.1)

    5xx Server Error (status code class)

    ***[Section 15.6](#status.5xx)***[¶](#appendix-D-2.5.2.1.1.14.1)
* [A](#rfc.index.u65)[¶](#appendix-D-2.6.1)

  + accelerator

    ***[Section 3.7, Paragraph 6](#section-3.7-6)***[¶](#appendix-D-2.6.2.1.1.2.1)

    Accept header field

    ***[Section 12.5.1](#field.accept)***[¶](#appendix-D-2.6.2.1.1.4.1)

    Accept-Charset header field

    ***[Section 12.5.2](#field.accept-charset)***[¶](#appendix-D-2.6.2.1.1.6.1)

    Accept-Encoding header field

    ***[Section 12.5.3](#field.accept-encoding)***[¶](#appendix-D-2.6.2.1.1.8.1)

    Accept-Language header field

    ***[Section 12.5.4](#field.accept-language)***[¶](#appendix-D-2.6.2.1.1.10.1)

    Accept-Ranges header field

    ***[Section 14.3](#field.accept-ranges)***[¶](#appendix-D-2.6.2.1.1.12.1)

    Allow header field

    ***[Section 10.2.1](#field.allow)***[¶](#appendix-D-2.6.2.1.1.14.1)

    Authentication-Info header field

    ***[Section 11.6.3](#field.authentication-info)***[¶](#appendix-D-2.6.2.1.1.16.1)

    authoritative response

    ***[Section 17.1](#establishing.authority)***[¶](#appendix-D-2.6.2.1.1.18.1)

    Authorization header field

    ***[Section 11.6.2](#field.authorization)***[¶](#appendix-D-2.6.2.1.1.20.1)
* [B](#rfc.index.u66)[¶](#appendix-D-2.7.1)

  + browser

    ***[Section 3.5](#user.agent)***[¶](#appendix-D-2.7.2.1.1.2.1)
* [C](#rfc.index.u67)[¶](#appendix-D-2.8.1)

  + cache

    ***[Section 3.8](#caches)***[¶](#appendix-D-2.8.2.1.1.2.1)

    cacheable

    ***[Section 3.8, Paragraph 4](#section-3.8-4)***[¶](#appendix-D-2.8.2.1.1.4.1)

    client

    ***[Section 3.3](#connections)***[¶](#appendix-D-2.8.2.1.1.6.1)

    clock

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.8.2.1.1.8.1)

    complete

    ***[Section 6.1](#message.framing)***[¶](#appendix-D-2.8.2.1.1.10.1)

    compress (Coding Format)

    [Section 8.4.1.1](#compress.coding)[¶](#appendix-D-2.8.2.1.1.12.1)

    compress (content coding)

    ***[Section 8.4.1](#content.codings)***[¶](#appendix-D-2.8.2.1.1.14.1)

    conditional request

    ***[Section 13](#conditional.requests)***[¶](#appendix-D-2.8.2.1.1.16.1)

    CONNECT method

    ***[Section 9.3.6](#CONNECT)***[¶](#appendix-D-2.8.2.1.1.18.1)

    connection

    ***[Section 3.3](#connections)***[¶](#appendix-D-2.8.2.1.1.20.1)

    Connection header field

    ***[Section 7.6.1](#field.connection)***[¶](#appendix-D-2.8.2.1.1.22.1)

    content

    [Section 6.4](#content)[¶](#appendix-D-2.8.2.1.1.24.1)

    content coding

    ***[Section 8.4.1](#content.codings)***[¶](#appendix-D-2.8.2.1.1.26.1)

    content negotiation

    [Section 1.3, Paragraph 4](#section-1.3-4)[¶](#appendix-D-2.8.2.1.1.28.1)

    Content-Encoding header field

    ***[Section 8.4](#field.content-encoding)***[¶](#appendix-D-2.8.2.1.1.30.1)

    Content-Language header field

    ***[Section 8.5](#field.content-language)***[¶](#appendix-D-2.8.2.1.1.32.1)

    Content-Length header field

    ***[Section 8.6](#field.content-length)***[¶](#appendix-D-2.8.2.1.1.34.1)

    Content-Location header field

    ***[Section 8.7](#field.content-location)***[¶](#appendix-D-2.8.2.1.1.36.1)

    Content-MD5 header field

    ***[Section 18.4, Paragraph 10](#section-18.4-10)***[¶](#appendix-D-2.8.2.1.1.38.1)

    Content-Range header field

    ***[Section 14.4](#field.content-range)***;
    [Section 14.5](#partial.PUT)[¶](#appendix-D-2.8.2.1.1.40.1)

    Content-Type header field

    ***[Section 8.3](#field.content-type)***[¶](#appendix-D-2.8.2.1.1.42.1)

    control data

    ***[Section 6.2](#message.control.data)***[¶](#appendix-D-2.8.2.1.1.44.1)
* [D](#rfc.index.u68)[¶](#appendix-D-2.9.1)

  + Date header field

    ***[Section 6.6.1](#field.date)***[¶](#appendix-D-2.9.2.1.1.2.1)

    deflate (Coding Format)

    [Section 8.4.1.2](#deflate.coding)[¶](#appendix-D-2.9.2.1.1.4.1)

    deflate (content coding)

    ***[Section 8.4.1](#content.codings)***[¶](#appendix-D-2.9.2.1.1.6.1)

    DELETE method

    ***[Section 9.3.5](#DELETE)***[¶](#appendix-D-2.9.2.1.1.8.1)

    Delimiters

    [Section 5.6.2, Paragraph 3](#delimiters)[¶](#appendix-D-2.9.2.1.1.10.1)

    downstream

    ***[Section 3.7, Paragraph 4](#section-3.7-4)***[¶](#appendix-D-2.9.2.1.1.12.1)
* [E](#rfc.index.u69)[¶](#appendix-D-2.10.1)

  + effective request URI

    ***[Section 7.1, Paragraph 8.1](#section-7.1-8.1)***[¶](#appendix-D-2.10.2.1.1.2.1)

    ETag field

    ***[Section 8.8.3](#field.etag)***[¶](#appendix-D-2.10.2.1.1.4.1)

    Expect header field

    ***[Section 10.1.1](#field.expect)***[¶](#appendix-D-2.10.2.1.1.6.1)
* [F](#rfc.index.u70)[¶](#appendix-D-2.11.1)

  + field

    ***[Section 5](#fields)***;
    [Section 6.3](#header.fields)[¶](#appendix-D-2.11.2.1.1.2.1)

    field line

    [Section 5.2, Paragraph 1](#section-5.2-1)[¶](#appendix-D-2.11.2.1.1.4.1)

    field line value

    [Section 5.2, Paragraph 1](#section-5.2-1)[¶](#appendix-D-2.11.2.1.1.6.1)

    field name

    [Section 5.2, Paragraph 1](#section-5.2-1)[¶](#appendix-D-2.11.2.1.1.8.1)

    field value

    [Section 5.2, Paragraph 2](#section-5.2-2)[¶](#appendix-D-2.11.2.1.1.10.1)

    Fields

    \*

    ***[Section 18.4, Paragraph 9](#field.asterisk)***[¶](#appendix-D-2.11.2.1.1.14.1.2.1)

    Accept

    ***[Section 12.5.1](#field.accept)***[¶](#appendix-D-2.11.2.1.1.14.1.4.1)

    Accept-Charset

    ***[Section 12.5.2](#field.accept-charset)***[¶](#appendix-D-2.11.2.1.1.14.1.6.1)

    Accept-Encoding

    ***[Section 12.5.3](#field.accept-encoding)***[¶](#appendix-D-2.11.2.1.1.14.1.8.1)

    Accept-Language

    ***[Section 12.5.4](#field.accept-language)***[¶](#appendix-D-2.11.2.1.1.14.1.10.1)

    Accept-Ranges

    ***[Section 14.3](#field.accept-ranges)***[¶](#appendix-D-2.11.2.1.1.14.1.12.1)

    Allow

    ***[Section 10.2.1](#field.allow)***[¶](#appendix-D-2.11.2.1.1.14.1.14.1)

    Authentication-Info

    ***[Section 11.6.3](#field.authentication-info)***[¶](#appendix-D-2.11.2.1.1.14.1.16.1)

    Authorization

    ***[Section 11.6.2](#field.authorization)***[¶](#appendix-D-2.11.2.1.1.14.1.18.1)

    Connection

    ***[Section 7.6.1](#field.connection)***[¶](#appendix-D-2.11.2.1.1.14.1.20.1)

    Content-Encoding

    ***[Section 8.4](#field.content-encoding)***[¶](#appendix-D-2.11.2.1.1.14.1.22.1)

    Content-Language

    ***[Section 8.5](#field.content-language)***[¶](#appendix-D-2.11.2.1.1.14.1.24.1)

    Content-Length

    ***[Section 8.6](#field.content-length)***[¶](#appendix-D-2.11.2.1.1.14.1.26.1)

    Content-Location

    ***[Section 8.7](#field.content-location)***[¶](#appendix-D-2.11.2.1.1.14.1.28.1)

    Content-MD5

    ***[Section 18.4, Paragraph 10](#section-18.4-10)***[¶](#appendix-D-2.11.2.1.1.14.1.30.1)

    Content-Range

    ***[Section 14.4](#field.content-range)***;
    [Section 14.5](#partial.PUT)[¶](#appendix-D-2.11.2.1.1.14.1.32.1)

    Content-Type

    ***[Section 8.3](#field.content-type)***[¶](#appendix-D-2.11.2.1.1.14.1.34.1)

    Date

    ***[Section 6.6.1](#field.date)***[¶](#appendix-D-2.11.2.1.1.14.1.36.1)

    ETag

    ***[Section 8.8.3](#field.etag)***[¶](#appendix-D-2.11.2.1.1.14.1.38.1)

    Expect

    ***[Section 10.1.1](#field.expect)***[¶](#appendix-D-2.11.2.1.1.14.1.40.1)

    From

    ***[Section 10.1.2](#field.from)***[¶](#appendix-D-2.11.2.1.1.14.1.42.1)

    Host

    ***[Section 7.2](#field.host)***[¶](#appendix-D-2.11.2.1.1.14.1.44.1)

    If-Match

    ***[Section 13.1.1](#field.if-match)***[¶](#appendix-D-2.11.2.1.1.14.1.46.1)

    If-Modified-Since

    ***[Section 13.1.3](#field.if-modified-since)***[¶](#appendix-D-2.11.2.1.1.14.1.48.1)

    If-None-Match

    ***[Section 13.1.2](#field.if-none-match)***[¶](#appendix-D-2.11.2.1.1.14.1.50.1)

    If-Range

    ***[Section 13.1.5](#field.if-range)***[¶](#appendix-D-2.11.2.1.1.14.1.52.1)

    If-Unmodified-Since

    ***[Section 13.1.4](#field.if-unmodified-since)***[¶](#appendix-D-2.11.2.1.1.14.1.54.1)

    Last-Modified

    ***[Section 8.8.2](#field.last-modified)***[¶](#appendix-D-2.11.2.1.1.14.1.56.1)

    Location

    ***[Section 10.2.2](#field.location)***[¶](#appendix-D-2.11.2.1.1.14.1.58.1)

    Max-Forwards

    ***[Section 7.6.2](#field.max-forwards)***[¶](#appendix-D-2.11.2.1.1.14.1.60.1)

    Proxy-Authenticate

    ***[Section 11.7.1](#field.proxy-authenticate)***[¶](#appendix-D-2.11.2.1.1.14.1.62.1)

    Proxy-Authentication-Info

    ***[Section 11.7.3](#field.proxy-authentication-info)***[¶](#appendix-D-2.11.2.1.1.14.1.64.1)

    Proxy-Authorization

    ***[Section 11.7.2](#field.proxy-authorization)***[¶](#appendix-D-2.11.2.1.1.14.1.66.1)

    Range

    ***[Section 14.2](#field.range)***[¶](#appendix-D-2.11.2.1.1.14.1.68.1)

    Referer

    ***[Section 10.1.3](#field.referer)***[¶](#appendix-D-2.11.2.1.1.14.1.70.1)

    Retry-After

    ***[Section 10.2.3](#field.retry-after)***[¶](#appendix-D-2.11.2.1.1.14.1.72.1)

    Server

    ***[Section 10.2.4](#field.server)***[¶](#appendix-D-2.11.2.1.1.14.1.74.1)

    TE

    ***[Section 10.1.4](#field.te)***[¶](#appendix-D-2.11.2.1.1.14.1.76.1)

    Trailer

    ***[Section 6.6.2](#field.trailer)***[¶](#appendix-D-2.11.2.1.1.14.1.78.1)

    Upgrade

    ***[Section 7.8](#field.upgrade)***[¶](#appendix-D-2.11.2.1.1.14.1.80.1)

    User-Agent

    ***[Section 10.1.5](#field.user-agent)***[¶](#appendix-D-2.11.2.1.1.14.1.82.1)

    Vary

    ***[Section 12.5.5](#field.vary)***[¶](#appendix-D-2.11.2.1.1.14.1.84.1)

    Via

    ***[Section 7.6.3](#field.via)***[¶](#appendix-D-2.11.2.1.1.14.1.86.1)

    WWW-Authenticate

    ***[Section 11.6.1](#field.www-authenticate)***[¶](#appendix-D-2.11.2.1.1.14.1.88.1)

    Fragment Identifiers

    [Section 4.2.5](#uri.fragment.identifiers)[¶](#appendix-D-2.11.2.1.1.16.1)

    From header field

    ***[Section 10.1.2](#field.from)***[¶](#appendix-D-2.11.2.1.1.18.1)
* [G](#rfc.index.u71)[¶](#appendix-D-2.12.1)

  + gateway

    ***[Section 3.7, Paragraph 6](#section-3.7-6)***[¶](#appendix-D-2.12.2.1.1.2.1)

    GET method

    ***[Section 9.3.1](#GET)***[¶](#appendix-D-2.12.2.1.1.4.1)

    Grammar

    ALPHA

    ***[Section 2.1](#notation)***[¶](#appendix-D-2.12.2.1.1.8.1.2.1)

    Accept

    ***[Section 12.5.1](#field.accept)***[¶](#appendix-D-2.12.2.1.1.8.1.4.1)

    Accept-Charset

    ***[Section 12.5.2](#field.accept-charset)***[¶](#appendix-D-2.12.2.1.1.8.1.6.1)

    Accept-Encoding

    ***[Section 12.5.3](#field.accept-encoding)***[¶](#appendix-D-2.12.2.1.1.8.1.8.1)

    Accept-Language

    ***[Section 12.5.4](#field.accept-language)***[¶](#appendix-D-2.12.2.1.1.8.1.10.1)

    Accept-Ranges

    ***[Section 14.3](#field.accept-ranges)***[¶](#appendix-D-2.12.2.1.1.8.1.12.1)

    Allow

    ***[Section 10.2.1](#field.allow)***[¶](#appendix-D-2.12.2.1.1.8.1.14.1)

    Authentication-Info

    ***[Section 11.6.3](#field.authentication-info)***[¶](#appendix-D-2.12.2.1.1.8.1.16.1)

    Authorization

    ***[Section 11.6.2](#field.authorization)***[¶](#appendix-D-2.12.2.1.1.8.1.18.1)

    BWS

    ***[Section 5.6.3](#whitespace)***[¶](#appendix-D-2.12.2.1.1.8.1.20.1)

    CR

    ***[Section 2.1](#notation)***[¶](#appendix-D-2.12.2.1.1.8.1.22.1)

    CRLF

    ***[Section 2.1](#notation)***[¶](#appendix-D-2.12.2.1.1.8.1.24.1)

    CTL

    ***[Section 2.1](#notation)***[¶](#appendix-D-2.12.2.1.1.8.1.26.1)

    Connection

    ***[Section 7.6.1](#field.connection)***[¶](#appendix-D-2.12.2.1.1.8.1.28.1)

    Content-Encoding

    ***[Section 8.4](#field.content-encoding)***[¶](#appendix-D-2.12.2.1.1.8.1.30.1)

    Content-Language

    ***[Section 8.5](#field.content-language)***[¶](#appendix-D-2.12.2.1.1.8.1.32.1)

    Content-Length

    ***[Section 8.6](#field.content-length)***[¶](#appendix-D-2.12.2.1.1.8.1.34.1)

    Content-Location

    ***[Section 8.7](#field.content-location)***[¶](#appendix-D-2.12.2.1.1.8.1.36.1)

    Content-Range

    ***[Section 14.4](#field.content-range)***[¶](#appendix-D-2.12.2.1.1.8.1.38.1)

    Content-Type

    ***[Section 8.3](#field.content-type)***[¶](#appendix-D-2.12.2.1.1.8.1.40.1)

    DIGIT

    ***[Section 2.1](#notation)***[¶](#appendix-D-2.12.2.1.1.8.1.42.1)

    DQUOTE

    ***[Section 2.1](#notation)***[¶](#appendix-D-2.12.2.1.1.8.1.44.1)

    Date

    ***[Section 6.6.1](#field.date)***[¶](#appendix-D-2.12.2.1.1.8.1.46.1)

    ETag

    ***[Section 8.8.3](#field.etag)***[¶](#appendix-D-2.12.2.1.1.8.1.48.1)

    Expect

    ***[Section 10.1.1](#field.expect)***[¶](#appendix-D-2.12.2.1.1.8.1.50.1)

    From

    ***[Section 10.1.2](#field.from)***[¶](#appendix-D-2.12.2.1.1.8.1.52.1)

    GMT

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.12.2.1.1.8.1.54.1)

    HEXDIG

    ***[Section 2.1](#notation)***[¶](#appendix-D-2.12.2.1.1.8.1.56.1)

    HTAB

    ***[Section 2.1](#notation)***[¶](#appendix-D-2.12.2.1.1.8.1.58.1)

    HTTP-date

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.12.2.1.1.8.1.60.1)

    Host

    ***[Section 7.2](#field.host)***[¶](#appendix-D-2.12.2.1.1.8.1.62.1)

    IMF-fixdate

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.12.2.1.1.8.1.64.1)

    If-Match

    ***[Section 13.1.1](#field.if-match)***[¶](#appendix-D-2.12.2.1.1.8.1.66.1)

    If-Modified-Since

    ***[Section 13.1.3](#field.if-modified-since)***[¶](#appendix-D-2.12.2.1.1.8.1.68.1)

    If-None-Match

    ***[Section 13.1.2](#field.if-none-match)***[¶](#appendix-D-2.12.2.1.1.8.1.70.1)

    If-Range

    ***[Section 13.1.5](#field.if-range)***[¶](#appendix-D-2.12.2.1.1.8.1.72.1)

    If-Unmodified-Since

    ***[Section 13.1.4](#field.if-unmodified-since)***[¶](#appendix-D-2.12.2.1.1.8.1.74.1)

    LF

    ***[Section 2.1](#notation)***[¶](#appendix-D-2.12.2.1.1.8.1.76.1)

    Last-Modified

    ***[Section 8.8.2](#field.last-modified)***[¶](#appendix-D-2.12.2.1.1.8.1.78.1)

    Location

    ***[Section 10.2.2](#field.location)***[¶](#appendix-D-2.12.2.1.1.8.1.80.1)

    Max-Forwards

    ***[Section 7.6.2](#field.max-forwards)***[¶](#appendix-D-2.12.2.1.1.8.1.82.1)

    OCTET

    ***[Section 2.1](#notation)***[¶](#appendix-D-2.12.2.1.1.8.1.84.1)

    OWS

    ***[Section 5.6.3](#whitespace)***[¶](#appendix-D-2.12.2.1.1.8.1.86.1)

    Proxy-Authenticate

    ***[Section 11.7.1](#field.proxy-authenticate)***[¶](#appendix-D-2.12.2.1.1.8.1.88.1)

    Proxy-Authentication-Info

    ***[Section 11.7.3](#field.proxy-authentication-info)***[¶](#appendix-D-2.12.2.1.1.8.1.90.1)

    Proxy-Authorization

    ***[Section 11.7.2](#field.proxy-authorization)***[¶](#appendix-D-2.12.2.1.1.8.1.92.1)

    RWS

    ***[Section 5.6.3](#whitespace)***[¶](#appendix-D-2.12.2.1.1.8.1.94.1)

    Range

    ***[Section 14.2](#field.range)***[¶](#appendix-D-2.12.2.1.1.8.1.96.1)

    Referer

    ***[Section 10.1.3](#field.referer)***[¶](#appendix-D-2.12.2.1.1.8.1.98.1)

    Retry-After

    ***[Section 10.2.3](#field.retry-after)***[¶](#appendix-D-2.12.2.1.1.8.1.100.1)

    SP

    ***[Section 2.1](#notation)***[¶](#appendix-D-2.12.2.1.1.8.1.102.1)

    Server

    ***[Section 10.2.4](#field.server)***[¶](#appendix-D-2.12.2.1.1.8.1.104.1)

    TE

    ***[Section 10.1.4](#field.te)***[¶](#appendix-D-2.12.2.1.1.8.1.106.1)

    Trailer

    ***[Section 6.6.2](#field.trailer)***[¶](#appendix-D-2.12.2.1.1.8.1.108.1)

    URI-reference

    ***[Section 4.1](#uri.references)***[¶](#appendix-D-2.12.2.1.1.8.1.110.1)

    Upgrade

    ***[Section 7.8](#field.upgrade)***[¶](#appendix-D-2.12.2.1.1.8.1.112.1)

    User-Agent

    ***[Section 10.1.5](#field.user-agent)***[¶](#appendix-D-2.12.2.1.1.8.1.114.1)

    VCHAR

    ***[Section 2.1](#notation)***[¶](#appendix-D-2.12.2.1.1.8.1.116.1)

    Vary

    ***[Section 12.5.5](#field.vary)***[¶](#appendix-D-2.12.2.1.1.8.1.118.1)

    Via

    ***[Section 7.6.3](#field.via)***[¶](#appendix-D-2.12.2.1.1.8.1.120.1)

    WWW-Authenticate

    ***[Section 11.6.1](#field.www-authenticate)***[¶](#appendix-D-2.12.2.1.1.8.1.122.1)

    absolute-URI

    ***[Section 4.1](#uri.references)***[¶](#appendix-D-2.12.2.1.1.8.1.124.1)

    absolute-path

    ***[Section 4.1](#uri.references)***[¶](#appendix-D-2.12.2.1.1.8.1.126.1)

    acceptable-ranges

    ***[Section 14.3](#field.accept-ranges)***[¶](#appendix-D-2.12.2.1.1.8.1.128.1)

    asctime-date

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.12.2.1.1.8.1.130.1)

    auth-param

    ***[Section 11.2](#auth.params)***[¶](#appendix-D-2.12.2.1.1.8.1.132.1)

    auth-scheme

    ***[Section 11.1](#auth.scheme)***[¶](#appendix-D-2.12.2.1.1.8.1.134.1)

    authority

    ***[Section 4.1](#uri.references)***[¶](#appendix-D-2.12.2.1.1.8.1.136.1)

    challenge

    ***[Section 11.3](#challenge.and.response)***[¶](#appendix-D-2.12.2.1.1.8.1.138.1)

    codings

    ***[Section 12.5.3](#field.accept-encoding)***[¶](#appendix-D-2.12.2.1.1.8.1.140.1)

    comment

    ***[Section 5.6.5](#comments)***[¶](#appendix-D-2.12.2.1.1.8.1.142.1)

    complete-length

    ***[Section 14.4](#field.content-range)***[¶](#appendix-D-2.12.2.1.1.8.1.144.1)

    connection-option

    ***[Section 7.6.1](#field.connection)***[¶](#appendix-D-2.12.2.1.1.8.1.146.1)

    content-coding

    ***[Section 8.4.1](#content.codings)***[¶](#appendix-D-2.12.2.1.1.8.1.148.1)

    credentials

    ***[Section 11.4](#credentials)***[¶](#appendix-D-2.12.2.1.1.8.1.150.1)

    ctext

    ***[Section 5.6.5](#comments)***[¶](#appendix-D-2.12.2.1.1.8.1.152.1)

    date1

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.12.2.1.1.8.1.154.1)

    day

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.12.2.1.1.8.1.156.1)

    day-name

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.12.2.1.1.8.1.158.1)

    day-name-l

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.12.2.1.1.8.1.160.1)

    delay-seconds

    ***[Section 10.2.3](#field.retry-after)***[¶](#appendix-D-2.12.2.1.1.8.1.162.1)

    entity-tag

    ***[Section 8.8.3](#field.etag)***[¶](#appendix-D-2.12.2.1.1.8.1.164.1)

    etagc

    ***[Section 8.8.3](#field.etag)***[¶](#appendix-D-2.12.2.1.1.8.1.166.1)

    field-content

    ***[Section 5.5](#fields.values)***[¶](#appendix-D-2.12.2.1.1.8.1.168.1)

    field-name

    ***[Section 5.1](#fields.names)***;
    [Section 6.6.2](#field.trailer)[¶](#appendix-D-2.12.2.1.1.8.1.170.1)

    field-value

    ***[Section 5.5](#fields.values)***[¶](#appendix-D-2.12.2.1.1.8.1.172.1)

    field-vchar

    ***[Section 5.5](#fields.values)***[¶](#appendix-D-2.12.2.1.1.8.1.174.1)

    first-pos

    ***[Section 14.1.1](#range.specifiers)***;
    [Section 14.4](#field.content-range)[¶](#appendix-D-2.12.2.1.1.8.1.176.1)

    hour

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.12.2.1.1.8.1.178.1)

    http-URI

    ***[Section 4.2.1](#http.uri)***[¶](#appendix-D-2.12.2.1.1.8.1.180.1)

    https-URI

    ***[Section 4.2.2](#https.uri)***[¶](#appendix-D-2.12.2.1.1.8.1.182.1)

    incl-range

    ***[Section 14.4](#field.content-range)***[¶](#appendix-D-2.12.2.1.1.8.1.184.1)

    int-range

    ***[Section 14.1.1](#range.specifiers)***[¶](#appendix-D-2.12.2.1.1.8.1.186.1)

    language-range

    ***[Section 12.5.4](#field.accept-language)***[¶](#appendix-D-2.12.2.1.1.8.1.188.1)

    language-tag

    ***[Section 8.5.1](#language.tags)***[¶](#appendix-D-2.12.2.1.1.8.1.190.1)

    last-pos

    ***[Section 14.1.1](#range.specifiers)***;
    [Section 14.4](#field.content-range)[¶](#appendix-D-2.12.2.1.1.8.1.192.1)

    media-range

    ***[Section 12.5.1](#field.accept)***[¶](#appendix-D-2.12.2.1.1.8.1.194.1)

    media-type

    ***[Section 8.3.1](#media.type)***[¶](#appendix-D-2.12.2.1.1.8.1.196.1)

    method

    ***[Section 9.1](#method.overview)***[¶](#appendix-D-2.12.2.1.1.8.1.198.1)

    minute

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.12.2.1.1.8.1.200.1)

    month

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.12.2.1.1.8.1.202.1)

    obs-date

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.12.2.1.1.8.1.204.1)

    obs-text

    ***[Section 5.5](#fields.values)***[¶](#appendix-D-2.12.2.1.1.8.1.206.1)

    opaque-tag

    ***[Section 8.8.3](#field.etag)***[¶](#appendix-D-2.12.2.1.1.8.1.208.1)

    other-range

    ***[Section 14.1.1](#range.specifiers)***[¶](#appendix-D-2.12.2.1.1.8.1.210.1)

    parameter

    ***[Section 5.6.6](#parameter)***[¶](#appendix-D-2.12.2.1.1.8.1.212.1)

    parameter-name

    ***[Section 5.6.6](#parameter)***[¶](#appendix-D-2.12.2.1.1.8.1.214.1)

    parameter-value

    ***[Section 5.6.6](#parameter)***[¶](#appendix-D-2.12.2.1.1.8.1.216.1)

    parameters

    ***[Section 5.6.6](#parameter)***[¶](#appendix-D-2.12.2.1.1.8.1.218.1)

    partial-URI

    ***[Section 4.1](#uri.references)***[¶](#appendix-D-2.12.2.1.1.8.1.220.1)

    port

    ***[Section 4.1](#uri.references)***[¶](#appendix-D-2.12.2.1.1.8.1.222.1)

    product

    ***[Section 10.1.5](#field.user-agent)***[¶](#appendix-D-2.12.2.1.1.8.1.224.1)

    product-version

    ***[Section 10.1.5](#field.user-agent)***[¶](#appendix-D-2.12.2.1.1.8.1.226.1)

    protocol-name

    ***[Section 7.6.3](#field.via)***[¶](#appendix-D-2.12.2.1.1.8.1.228.1)

    protocol-version

    ***[Section 7.6.3](#field.via)***[¶](#appendix-D-2.12.2.1.1.8.1.230.1)

    pseudonym

    ***[Section 7.6.3](#field.via)***[¶](#appendix-D-2.12.2.1.1.8.1.232.1)

    qdtext

    ***[Section 5.6.4](#quoted.strings)***[¶](#appendix-D-2.12.2.1.1.8.1.234.1)

    query

    ***[Section 4.1](#uri.references)***[¶](#appendix-D-2.12.2.1.1.8.1.236.1)

    quoted-pair

    ***[Section 5.6.4](#quoted.strings)***[¶](#appendix-D-2.12.2.1.1.8.1.238.1)

    quoted-string

    ***[Section 5.6.4](#quoted.strings)***[¶](#appendix-D-2.12.2.1.1.8.1.240.1)

    qvalue

    ***[Section 12.4.2](#quality.values)***[¶](#appendix-D-2.12.2.1.1.8.1.242.1)

    range-resp

    ***[Section 14.4](#field.content-range)***[¶](#appendix-D-2.12.2.1.1.8.1.244.1)

    range-set

    ***[Section 14.1.1](#range.specifiers)***[¶](#appendix-D-2.12.2.1.1.8.1.246.1)

    range-spec

    ***[Section 14.1.1](#range.specifiers)***[¶](#appendix-D-2.12.2.1.1.8.1.248.1)

    range-unit

    ***[Section 14.1](#range.units)***[¶](#appendix-D-2.12.2.1.1.8.1.250.1)

    ranges-specifier

    ***[Section 14.1.1](#range.specifiers)***[¶](#appendix-D-2.12.2.1.1.8.1.252.1)

    received-by

    ***[Section 7.6.3](#field.via)***[¶](#appendix-D-2.12.2.1.1.8.1.254.1)

    received-protocol

    ***[Section 7.6.3](#field.via)***[¶](#appendix-D-2.12.2.1.1.8.1.256.1)

    rfc850-date

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.12.2.1.1.8.1.258.1)

    second

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.12.2.1.1.8.1.260.1)

    segment

    ***[Section 4.1](#uri.references)***[¶](#appendix-D-2.12.2.1.1.8.1.262.1)

    subtype

    ***[Section 8.3.1](#media.type)***[¶](#appendix-D-2.12.2.1.1.8.1.264.1)

    suffix-length

    ***[Section 14.1.1](#range.specifiers)***[¶](#appendix-D-2.12.2.1.1.8.1.266.1)

    suffix-range

    ***[Section 14.1.1](#range.specifiers)***[¶](#appendix-D-2.12.2.1.1.8.1.268.1)

    t-codings

    ***[Section 10.1.4](#field.te)***[¶](#appendix-D-2.12.2.1.1.8.1.270.1)

    tchar

    ***[Section 5.6.2](#tokens)***[¶](#appendix-D-2.12.2.1.1.8.1.272.1)

    time-of-day

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.12.2.1.1.8.1.274.1)

    token

    ***[Section 5.6.2](#tokens)***[¶](#appendix-D-2.12.2.1.1.8.1.276.1)

    token68

    ***[Section 11.2](#auth.params)***[¶](#appendix-D-2.12.2.1.1.8.1.278.1)

    transfer-coding

    ***[Section 10.1.4](#field.te)***[¶](#appendix-D-2.12.2.1.1.8.1.280.1)

    transfer-parameter

    ***[Section 10.1.4](#field.te)***[¶](#appendix-D-2.12.2.1.1.8.1.282.1)

    type

    ***[Section 8.3.1](#media.type)***[¶](#appendix-D-2.12.2.1.1.8.1.284.1)

    unsatisfied-range

    ***[Section 14.4](#field.content-range)***[¶](#appendix-D-2.12.2.1.1.8.1.286.1)

    uri-host

    ***[Section 4.1](#uri.references)***[¶](#appendix-D-2.12.2.1.1.8.1.288.1)

    weak

    ***[Section 8.8.3](#field.etag)***[¶](#appendix-D-2.12.2.1.1.8.1.290.1)

    weight

    ***[Section 12.4.2](#quality.values)***[¶](#appendix-D-2.12.2.1.1.8.1.292.1)

    year

    ***[Section 5.6.7](#http.date)***[¶](#appendix-D-2.12.2.1.1.8.1.294.1)

    gzip (Coding Format)

    [Section 8.4.1.3](#gzip.coding)[¶](#appendix-D-2.12.2.1.1.10.1)

    gzip (content coding)

    ***[Section 8.4.1](#content.codings)***[¶](#appendix-D-2.12.2.1.1.12.1)
* [H](#rfc.index.u72)[¶](#appendix-D-2.13.1)

  + HEAD method

    ***[Section 9.3.2](#HEAD)***[¶](#appendix-D-2.13.2.1.1.2.1)

    Header Fields

    Accept

    ***[Section 12.5.1](#field.accept)***[¶](#appendix-D-2.13.2.1.1.6.1.2.1)

    Accept-Charset

    ***[Section 12.5.2](#field.accept-charset)***[¶](#appendix-D-2.13.2.1.1.6.1.4.1)

    Accept-Encoding

    ***[Section 12.5.3](#field.accept-encoding)***[¶](#appendix-D-2.13.2.1.1.6.1.6.1)

    Accept-Language

    ***[Section 12.5.4](#field.accept-language)***[¶](#appendix-D-2.13.2.1.1.6.1.8.1)

    Accept-Ranges

    ***[Section 14.3](#field.accept-ranges)***[¶](#appendix-D-2.13.2.1.1.6.1.10.1)

    Allow

    ***[Section 10.2.1](#field.allow)***[¶](#appendix-D-2.13.2.1.1.6.1.12.1)

    Authentication-Info

    ***[Section 11.6.3](#field.authentication-info)***[¶](#appendix-D-2.13.2.1.1.6.1.14.1)

    Authorization

    ***[Section 11.6.2](#field.authorization)***[¶](#appendix-D-2.13.2.1.1.6.1.16.1)

    Connection

    ***[Section 7.6.1](#field.connection)***[¶](#appendix-D-2.13.2.1.1.6.1.18.1)

    Content-Encoding

    ***[Section 8.4](#field.content-encoding)***[¶](#appendix-D-2.13.2.1.1.6.1.20.1)

    Content-Language

    ***[Section 8.5](#field.content-language)***[¶](#appendix-D-2.13.2.1.1.6.1.22.1)

    Content-Length

    ***[Section 8.6](#field.content-length)***[¶](#appendix-D-2.13.2.1.1.6.1.24.1)

    Content-Location

    ***[Section 8.7](#field.content-location)***[¶](#appendix-D-2.13.2.1.1.6.1.26.1)

    Content-MD5

    ***[Section 18.4, Paragraph 10](#section-18.4-10)***[¶](#appendix-D-2.13.2.1.1.6.1.28.1)

    Content-Range

    ***[Section 14.4](#field.content-range)***;
    [Section 14.5](#partial.PUT)[¶](#appendix-D-2.13.2.1.1.6.1.30.1)

    Content-Type

    ***[Section 8.3](#field.content-type)***[¶](#appendix-D-2.13.2.1.1.6.1.32.1)

    Date

    ***[Section 6.6.1](#field.date)***[¶](#appendix-D-2.13.2.1.1.6.1.34.1)

    ETag

    ***[Section 8.8.3](#field.etag)***[¶](#appendix-D-2.13.2.1.1.6.1.36.1)

    Expect

    ***[Section 10.1.1](#field.expect)***[¶](#appendix-D-2.13.2.1.1.6.1.38.1)

    From

    ***[Section 10.1.2](#field.from)***[¶](#appendix-D-2.13.2.1.1.6.1.40.1)

    Host

    ***[Section 7.2](#field.host)***[¶](#appendix-D-2.13.2.1.1.6.1.42.1)

    If-Match

    ***[Section 13.1.1](#field.if-match)***[¶](#appendix-D-2.13.2.1.1.6.1.44.1)

    If-Modified-Since

    ***[Section 13.1.3](#field.if-modified-since)***[¶](#appendix-D-2.13.2.1.1.6.1.46.1)

    If-None-Match

    ***[Section 13.1.2](#field.if-none-match)***[¶](#appendix-D-2.13.2.1.1.6.1.48.1)

    If-Range

    ***[Section 13.1.5](#field.if-range)***[¶](#appendix-D-2.13.2.1.1.6.1.50.1)

    If-Unmodified-Since

    ***[Section 13.1.4](#field.if-unmodified-since)***[¶](#appendix-D-2.13.2.1.1.6.1.52.1)

    Last-Modified

    ***[Section 8.8.2](#field.last-modified)***[¶](#appendix-D-2.13.2.1.1.6.1.54.1)

    Location

    ***[Section 10.2.2](#field.location)***[¶](#appendix-D-2.13.2.1.1.6.1.56.1)

    Max-Forwards

    ***[Section 7.6.2](#field.max-forwards)***[¶](#appendix-D-2.13.2.1.1.6.1.58.1)

    Proxy-Authenticate

    ***[Section 11.7.1](#field.proxy-authenticate)***[¶](#appendix-D-2.13.2.1.1.6.1.60.1)

    Proxy-Authentication-Info

    ***[Section 11.7.3](#field.proxy-authentication-info)***[¶](#appendix-D-2.13.2.1.1.6.1.62.1)

    Proxy-Authorization

    ***[Section 11.7.2](#field.proxy-authorization)***[¶](#appendix-D-2.13.2.1.1.6.1.64.1)

    Range

    ***[Section 14.2](#field.range)***[¶](#appendix-D-2.13.2.1.1.6.1.66.1)

    Referer

    ***[Section 10.1.3](#field.referer)***[¶](#appendix-D-2.13.2.1.1.6.1.68.1)

    Retry-After

    ***[Section 10.2.3](#field.retry-after)***[¶](#appendix-D-2.13.2.1.1.6.1.70.1)

    Server

    ***[Section 10.2.4](#field.server)***[¶](#appendix-D-2.13.2.1.1.6.1.72.1)

    TE

    ***[Section 10.1.4](#field.te)***[¶](#appendix-D-2.13.2.1.1.6.1.74.1)

    Trailer

    ***[Section 6.6.2](#field.trailer)***[¶](#appendix-D-2.13.2.1.1.6.1.76.1)

    Upgrade

    ***[Section 7.8](#field.upgrade)***[¶](#appendix-D-2.13.2.1.1.6.1.78.1)

    User-Agent

    ***[Section 10.1.5](#field.user-agent)***[¶](#appendix-D-2.13.2.1.1.6.1.80.1)

    Vary

    ***[Section 12.5.5](#field.vary)***[¶](#appendix-D-2.13.2.1.1.6.1.82.1)

    Via

    ***[Section 7.6.3](#field.via)***[¶](#appendix-D-2.13.2.1.1.6.1.84.1)

    WWW-Authenticate

    ***[Section 11.6.1](#field.www-authenticate)***[¶](#appendix-D-2.13.2.1.1.6.1.86.1)

    header section

    ***[Section 6.3](#header.fields)***[¶](#appendix-D-2.13.2.1.1.8.1)

    Host header field

    ***[Section 7.2](#field.host)***[¶](#appendix-D-2.13.2.1.1.10.1)

    http URI scheme

    ***[Section 4.2.1](#http.uri)***[¶](#appendix-D-2.13.2.1.1.12.1)

    https URI scheme

    ***[Section 4.2.2](#https.uri)***[¶](#appendix-D-2.13.2.1.1.14.1)
* [I](#rfc.index.u73)[¶](#appendix-D-2.14.1)

  + idempotent

    ***[Section 9.2.2](#idempotent.methods)***[¶](#appendix-D-2.14.2.1.1.2.1)

    If-Match header field

    ***[Section 13.1.1](#field.if-match)***[¶](#appendix-D-2.14.2.1.1.4.1)

    If-Modified-Since header field

    ***[Section 13.1.3](#field.if-modified-since)***[¶](#appendix-D-2.14.2.1.1.6.1)

    If-None-Match header field

    ***[Section 13.1.2](#field.if-none-match)***[¶](#appendix-D-2.14.2.1.1.8.1)

    If-Range header field

    ***[Section 13.1.5](#field.if-range)***[¶](#appendix-D-2.14.2.1.1.10.1)

    If-Unmodified-Since header field

    ***[Section 13.1.4](#field.if-unmodified-since)***[¶](#appendix-D-2.14.2.1.1.12.1)

    inbound

    ***[Section 3.7, Paragraph 4](#section-3.7-4)***[¶](#appendix-D-2.14.2.1.1.14.1)

    incomplete

    ***[Section 6.1](#message.framing)***[¶](#appendix-D-2.14.2.1.1.16.1)

    interception proxy

    ***[Section 3.7, Paragraph 10](#section-3.7-10)***[¶](#appendix-D-2.14.2.1.1.18.1)

    intermediary

    ***[Section 3.7](#intermediaries)***[¶](#appendix-D-2.14.2.1.1.20.1)
* [L](#rfc.index.u76)[¶](#appendix-D-2.15.1)

  + Last-Modified header field

    ***[Section 8.8.2](#field.last-modified)***[¶](#appendix-D-2.15.2.1.1.2.1)

    list-based field

    [Section 5.5, Paragraph 7](#section-5.5-7)[¶](#appendix-D-2.15.2.1.1.4.1)

    Location header field

    ***[Section 10.2.2](#field.location)***[¶](#appendix-D-2.15.2.1.1.6.1)
* [M](#rfc.index.u77)[¶](#appendix-D-2.16.1)

  + Max-Forwards header field

    ***[Section 7.6.2](#field.max-forwards)***[¶](#appendix-D-2.16.2.1.1.2.1)

    Media Type

    multipart/byteranges

    ***[Section 14.6](#multipart.byteranges)***[¶](#appendix-D-2.16.2.1.1.6.1.2.1)

    multipart/x-byteranges

    [Section 14.6, Paragraph 4, Item 3](#section-14.6-4.3)[¶](#appendix-D-2.16.2.1.1.6.1.4.1)

    message

    [Section 3.4](#messages);
    ***[Section 6](#message.abstraction)***[¶](#appendix-D-2.16.2.1.1.8.1)

    message abstraction

    ***[Section 6](#message.abstraction)***[¶](#appendix-D-2.16.2.1.1.10.1)

    messages

    ***[Section 3.4](#messages)***[¶](#appendix-D-2.16.2.1.1.12.1)

    metadata

    ***[Section 8.8](#response.validator)***[¶](#appendix-D-2.16.2.1.1.14.1)

    Method

    \*

    ***[Section 18.2, Paragraph 3](#section-18.2-3)***[¶](#appendix-D-2.16.2.1.1.18.1.2.1)

    CONNECT

    ***[Section 9.3.6](#CONNECT)***[¶](#appendix-D-2.16.2.1.1.18.1.4.1)

    DELETE

    ***[Section 9.3.5](#DELETE)***[¶](#appendix-D-2.16.2.1.1.18.1.6.1)

    GET

    ***[Section 9.3.1](#GET)***[¶](#appendix-D-2.16.2.1.1.18.1.8.1)

    HEAD

    ***[Section 9.3.2](#HEAD)***[¶](#appendix-D-2.16.2.1.1.18.1.10.1)

    OPTIONS

    ***[Section 9.3.7](#OPTIONS)***[¶](#appendix-D-2.16.2.1.1.18.1.12.1)

    POST

    ***[Section 9.3.3](#POST)***[¶](#appendix-D-2.16.2.1.1.18.1.14.1)

    PUT

    ***[Section 9.3.4](#PUT)***[¶](#appendix-D-2.16.2.1.1.18.1.16.1)

    TRACE

    ***[Section 9.3.8](#TRACE)***[¶](#appendix-D-2.16.2.1.1.18.1.18.1)

    multipart/byteranges Media Type

    ***[Section 14.6](#multipart.byteranges)***[¶](#appendix-D-2.16.2.1.1.20.1)

    multipart/x-byteranges Media Type

    [Section 14.6, Paragraph 4, Item 3](#section-14.6-4.3)[¶](#appendix-D-2.16.2.1.1.22.1)
* [N](#rfc.index.u78)[¶](#appendix-D-2.17.1)

  + non-transforming proxy

    ***[Section 7.7](#message.transformations)***[¶](#appendix-D-2.17.2.1.1.2.1)
* [O](#rfc.index.u79)[¶](#appendix-D-2.18.1)

  + OPTIONS method

    ***[Section 9.3.7](#OPTIONS)***[¶](#appendix-D-2.18.2.1.1.2.1)

    origin

    ***[Section 4.3.1](#origin)***;
    [Section 11.5](#protection.space)[¶](#appendix-D-2.18.2.1.1.4.1)

    origin server

    ***[Section 3.6](#origin.server)***[¶](#appendix-D-2.18.2.1.1.6.1)

    outbound

    ***[Section 3.7, Paragraph 4](#section-3.7-4)***[¶](#appendix-D-2.18.2.1.1.8.1)
* [P](#rfc.index.u80)[¶](#appendix-D-2.19.1)

  + phishing

    ***[Section 17.1](#establishing.authority)***[¶](#appendix-D-2.19.2.1.1.2.1)

    POST method

    ***[Section 9.3.3](#POST)***[¶](#appendix-D-2.19.2.1.1.4.1)

    Protection Space

    [Section 11.5](#protection.space)[¶](#appendix-D-2.19.2.1.1.6.1)

    proxy

    ***[Section 3.7, Paragraph 5](#section-3.7-5)***[¶](#appendix-D-2.19.2.1.1.8.1)

    Proxy-Authenticate header field

    ***[Section 11.7.1](#field.proxy-authenticate)***[¶](#appendix-D-2.19.2.1.1.10.1)

    Proxy-Authentication-Info header field

    ***[Section 11.7.3](#field.proxy-authentication-info)***[¶](#appendix-D-2.19.2.1.1.12.1)

    Proxy-Authorization header field

    ***[Section 11.7.2](#field.proxy-authorization)***[¶](#appendix-D-2.19.2.1.1.14.1)

    PUT method

    ***[Section 9.3.4](#PUT)***[¶](#appendix-D-2.19.2.1.1.16.1)
* [R](#rfc.index.u82)[¶](#appendix-D-2.20.1)

  + Range header field

    ***[Section 14.2](#field.range)***[¶](#appendix-D-2.20.2.1.1.2.1)

    Realm

    [Section 11.5](#protection.space)[¶](#appendix-D-2.20.2.1.1.4.1)

    recipient

    ***[Section 3.4](#messages)***[¶](#appendix-D-2.20.2.1.1.6.1)

    Referer header field

    ***[Section 10.1.3](#field.referer)***[¶](#appendix-D-2.20.2.1.1.8.1)

    representation

    ***[Section 3.2](#representations)***[¶](#appendix-D-2.20.2.1.1.10.1)

    request

    ***[Section 3.4](#messages)***[¶](#appendix-D-2.20.2.1.1.12.1)

    request target

    ***[Section 7.1](#target.resource)***[¶](#appendix-D-2.20.2.1.1.14.1)

    resource

    ***[Section 3.1](#resources)***;
    [Section 4](#uri)[¶](#appendix-D-2.20.2.1.1.16.1)

    response

    ***[Section 3.4](#messages)***[¶](#appendix-D-2.20.2.1.1.18.1)

    Retry-After header field

    ***[Section 10.2.3](#field.retry-after)***[¶](#appendix-D-2.20.2.1.1.20.1)

    reverse proxy

    ***[Section 3.7, Paragraph 6](#section-3.7-6)***[¶](#appendix-D-2.20.2.1.1.22.1)
* [S](#rfc.index.u83)[¶](#appendix-D-2.21.1)

  + safe

    ***[Section 9.2.1](#safe.methods)***[¶](#appendix-D-2.21.2.1.1.2.1)

    satisfiable range

    ***[Section 14.1.1](#range.specifiers)***[¶](#appendix-D-2.21.2.1.1.4.1)

    secured

    ***[Section 4.2.2](#https.uri)***[¶](#appendix-D-2.21.2.1.1.6.1)

    selected representation

    ***[Section 3.2, Paragraph 4](#selected.representation)***;
    [Section 8.8](#response.validator);
    [Section 13.1](#preconditions)[¶](#appendix-D-2.21.2.1.1.8.1)

    self-descriptive

    ***[Section 6](#message.abstraction)***[¶](#appendix-D-2.21.2.1.1.10.1)

    sender

    ***[Section 3.4](#messages)***[¶](#appendix-D-2.21.2.1.1.12.1)

    server

    ***[Section 3.3](#connections)***[¶](#appendix-D-2.21.2.1.1.14.1)

    Server header field

    ***[Section 10.2.4](#field.server)***[¶](#appendix-D-2.21.2.1.1.16.1)

    singleton field

    [Section 5.5, Paragraph 6](#section-5.5-6)[¶](#appendix-D-2.21.2.1.1.18.1)

    spider

    ***[Section 3.5](#user.agent)***[¶](#appendix-D-2.21.2.1.1.20.1)

    Status Code

    [Section 15](#status.codes)[¶](#appendix-D-2.21.2.1.1.22.1)

    Status Codes

    Final

    [Section 15, Paragraph 7](#final.interim)[¶](#appendix-D-2.21.2.1.1.26.1.2.1)

    Informational

    [Section 15, Paragraph 7](#final.interim)[¶](#appendix-D-2.21.2.1.1.26.1.4.1)

    Interim

    [Section 15, Paragraph 7](#final.interim)[¶](#appendix-D-2.21.2.1.1.26.1.6.1)

    Status Codes Classes

    1xx Informational

    ***[Section 15.2](#status.1xx)***[¶](#appendix-D-2.21.2.1.1.30.1.2.1)

    2xx Successful

    ***[Section 15.3](#status.2xx)***[¶](#appendix-D-2.21.2.1.1.30.1.4.1)

    3xx Redirection

    ***[Section 15.4](#status.3xx)***[¶](#appendix-D-2.21.2.1.1.30.1.6.1)

    4xx Client Error

    ***[Section 15.5](#status.4xx)***[¶](#appendix-D-2.21.2.1.1.30.1.8.1)

    5xx Server Error

    ***[Section 15.6](#status.5xx)***[¶](#appendix-D-2.21.2.1.1.30.1.10.1)
* [T](#rfc.index.u84)[¶](#appendix-D-2.22.1)

  + target resource

    ***[Section 7.1](#target.resource)***[¶](#appendix-D-2.22.2.1.1.2.1)

    target URI

    ***[Section 7.1](#target.resource)***[¶](#appendix-D-2.22.2.1.1.4.1)

    TE header field

    ***[Section 10.1.4](#field.te)***[¶](#appendix-D-2.22.2.1.1.6.1)

    TRACE method

    ***[Section 9.3.8](#TRACE)***[¶](#appendix-D-2.22.2.1.1.8.1)

    Trailer Fields

    ***[Section 6.5](#trailer.fields)***[¶](#appendix-D-2.22.2.1.1.10.1)

    ETag

    ***[Section 8.8.3](#field.etag)***[¶](#appendix-D-2.22.2.1.1.12.1.2.1)

    Trailer header field

    ***[Section 6.6.2](#field.trailer)***[¶](#appendix-D-2.22.2.1.1.14.1)

    trailer section

    ***[Section 6.5](#trailer.fields)***[¶](#appendix-D-2.22.2.1.1.16.1)

    trailers

    ***[Section 6.5](#trailer.fields)***[¶](#appendix-D-2.22.2.1.1.18.1)

    transforming proxy

    ***[Section 7.7](#message.transformations)***[¶](#appendix-D-2.22.2.1.1.20.1)

    transparent proxy

    ***[Section 3.7, Paragraph 10](#section-3.7-10)***[¶](#appendix-D-2.22.2.1.1.22.1)

    tunnel

    ***[Section 3.7, Paragraph 8](#section-3.7-8)***[¶](#appendix-D-2.22.2.1.1.24.1)
* [U](#rfc.index.u85)[¶](#appendix-D-2.23.1)

  + unsatisfiable range

    ***[Section 14.1.1](#range.specifiers)***[¶](#appendix-D-2.23.2.1.1.2.1)

    Upgrade header field

    ***[Section 7.8](#field.upgrade)***[¶](#appendix-D-2.23.2.1.1.4.1)

    upstream

    ***[Section 3.7, Paragraph 4](#section-3.7-4)***[¶](#appendix-D-2.23.2.1.1.6.1)

    URI

    ***[Section 4](#uri)***[¶](#appendix-D-2.23.2.1.1.8.1)

    origin

    ***[Section 4.3.1](#origin)***[¶](#appendix-D-2.23.2.1.1.10.1.2.1)

    URI reference

    ***[Section 4.1](#uri.references)***[¶](#appendix-D-2.23.2.1.1.12.1)

    URI scheme

    http

    ***[Section 4.2.1](#http.uri)***[¶](#appendix-D-2.23.2.1.1.16.1.2.1)

    https

    ***[Section 4.2.2](#https.uri)***[¶](#appendix-D-2.23.2.1.1.16.1.4.1)

    user agent

    ***[Section 3.5](#user.agent)***[¶](#appendix-D-2.23.2.1.1.18.1)

    User-Agent header field

    ***[Section 10.1.5](#field.user-agent)***[¶](#appendix-D-2.23.2.1.1.20.1)
* [V](#rfc.index.u86)[¶](#appendix-D-2.24.1)

  + validator

    ***[Section 8.8](#response.validator)***[¶](#appendix-D-2.24.2.1.1.2.1)

    strong

    ***[Section 8.8.1](#weak.and.strong.validators)***[¶](#appendix-D-2.24.2.1.1.4.1.2.1)

    weak

    ***[Section 8.8.1](#weak.and.strong.validators)***[¶](#appendix-D-2.24.2.1.1.4.1.4.1)

    Vary header field

    ***[Section 12.5.5](#field.vary)***[¶](#appendix-D-2.24.2.1.1.6.1)

    Via header field

    ***[Section 7.6.3](#field.via)***[¶](#appendix-D-2.24.2.1.1.8.1)
* [W](#rfc.index.u87)[¶](#appendix-D-2.25.1)

  + WWW-Authenticate header field

    ***[Section 11.6.1](#field.www-authenticate)***[¶](#appendix-D-2.25.2.1.1.2.1)
* [X](#rfc.index.u88)[¶](#appendix-D-2.26.1)

  + x-compress (content coding)

    ***[Section 8.4.1](#content.codings)***[¶](#appendix-D-2.26.2.1.1.2.1)

    x-gzip (content coding)

    ***[Section 8.4.1](#content.codings)***[¶](#appendix-D-2.26.2.1.1.4.1)

## [Authors' Addresses](#name-authors-addresses)

Roy T. Fielding (editor)
Adobe
345 Park Ave
San Jose, CA 95110
United States of America
Email:
fielding@gbiv.com

URI:
<https://roy.gbiv.com/>

Mark Nottingham (editor)
Fastly
Prahran
Australia
Email:
mnot@mnot.net

URI:
<https://www.mnot.net/>

Julian Reschke (editor)
greenbytes GmbH
Hafenweg 16
48155 Münster
Germany
Email:
julian.reschke@greenbytes.de

URI:
<https://greenbytes.de/tech/webdav/>



=== Content from datatracker.ietf.org_d526ac0b_20250114_220612.html ===


* Light
* Dark
* Auto

[RFC 9113

Proposed Standard](/doc/rfc9113/)

|  | Title |  | HTTP/2 |
| --- | --- | --- | --- |
| Document | Document type |  | RFC - Proposed Standard  June 2022  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=9113 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") Obsoletes [RFC 8740](/doc/html/rfc8740 "Using TLS 1.3 with HTTP/2"), [RFC 7540](/doc/html/rfc7540 "Hypertext Transfer Protocol Version 2 (HTTP/2)") Was [draft-ietf-httpbis-http2bis](/doc/draft-ietf-httpbis-http2bis/07/) ([httpbis WG](/wg/httpbis/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [00](/doc/html/draft-ietf-httpbis-http2bis-00) * [01](/doc/html/draft-ietf-httpbis-http2bis-01) * [02](/doc/html/draft-ietf-httpbis-http2bis-02) * [03](/doc/html/draft-ietf-httpbis-http2bis-03) * [04](/doc/html/draft-ietf-httpbis-http2bis-04) * [05](/doc/html/draft-ietf-httpbis-http2bis-05) * [06](/doc/html/draft-ietf-httpbis-http2bis-06) * [07](/doc/html/draft-ietf-httpbis-http2bis-07) * [RFC 9113](/doc/html/rfc9113) |
|  | Compare versions |  | RFC 9113  draft-ietf-httpbis-http2bis-07  draft-ietf-httpbis-http2bis-06  draft-ietf-httpbis-http2bis-05  draft-ietf-httpbis-http2bis-04  draft-ietf-httpbis-http2bis-03  draft-ietf-httpbis-http2bis-02  draft-ietf-httpbis-http2bis-01  draft-ietf-httpbis-http2bis-00   RFC 9113  draft-ietf-httpbis-http2bis-07  draft-ietf-httpbis-http2bis-06  draft-ietf-httpbis-http2bis-05  draft-ietf-httpbis-http2bis-04  draft-ietf-httpbis-http2bis-03  draft-ietf-httpbis-http2bis-02  draft-ietf-httpbis-http2bis-01  draft-ietf-httpbis-http2bis-00   Side-by-side  Inline |
|  | Authors |  | [Martin Thomson](/person/mt%40lowentropy.net "Datatracker profile of Martin Thomson") , [Cory Benfield](/person/cbenfield%40apple.com "Datatracker profile of Cory Benfield")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc9113.txt) [html](https://www.rfc-editor.org/rfc/rfc9113.html) [xml](https://www.rfc-editor.org/rfc/rfc9113.xml) [pdf](https://www.rfc-editor.org/rfc/rfc9113.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc9113.html) [bibtex](/doc/rfc9113/bibtex/) |
|  | Additional resources |  | [Mailing list discussion](http://lists.w3.org/Archives/Public/ietf-http-wg/) |
|  |  |  | [Report a bug](https://github.com/ietf-tools/datatracker/issues/new/choose) |

| RFC 9113 | HTTP/2 | June 2022 |
| --- | --- | --- |
| Thomson & Benfield | Standards Track | [Page] |
| --- | --- | --- |

Stream:
Internet Engineering Task Force (IETF)
RFC:
[9113](https://www.rfc-editor.org/rfc/rfc9113)
Obsoletes:
[7540](https://www.rfc-editor.org/rfc/rfc7540), [8740](https://www.rfc-editor.org/rfc/rfc8740)
Category:
Standards Track
Published:
June 2022

ISSN:
2070-1721
Authors:
M. Thomson, Ed.

Mozilla

C. Benfield, Ed.

Apple Inc.

# RFC 9113

# HTTP/2

## [Abstract](#abstract)

This specification describes an optimized expression of the semantics of the Hypertext
Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more
efficient use of network resources and a
reduced latency by introducing field compression and allowing multiple
concurrent exchanges on the same connection.[¶](#section-abstract-1)

This document obsoletes RFCs 7540 and 8740.[¶](#section-abstract-2)

## [Status of This Memo](#name-status-of-this-memo)

This is an Internet Standards Track document.[¶](#section-boilerplate.1-1)

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by
the Internet Engineering Steering Group (IESG). Further
information on Internet Standards is available in Section 2 of
RFC 7841.[¶](#section-boilerplate.1-2)

Information about the current status of this document, any
errata, and how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9113>.[¶](#section-boilerplate.1-3)

## [Copyright Notice](#name-copyright-notice)

Copyright (c) 2022 IETF Trust and the persons identified as the
document authors. All rights reserved.[¶](#section-boilerplate.2-1)

This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents
carefully, as they describe your rights and restrictions with
respect to this document. Code Components extracted from this
document must include Revised BSD License text as described in
Section 4.e of the Trust Legal Provisions and are provided without
warranty as described in the Revised BSD License.[¶](#section-boilerplate.2-2)

▲
## [Table of Contents](#name-table-of-contents)

* [1](#section-1).  [Introduction](#name-introduction)
* [2](#section-2).  [HTTP/2 Protocol Overview](#name-http-2-protocol-overview)

  + [2.1](#section-2.1).  [Document Organization](#name-document-organization)
  + [2.2](#section-2.2).  [Conventions and Terminology](#name-conventions-and-terminology)
* [3](#section-3).  [Starting HTTP/2](#name-starting-http-2)

  + [3.1](#section-3.1).  [HTTP/2 Version Identification](#name-http-2-version-identificati)
  + [3.2](#section-3.2).  [Starting HTTP/2 for "`https`" URIs](#name-starting-http-2-for-https-u)
  + [3.3](#section-3.3).  [Starting HTTP/2 with Prior Knowledge](#name-starting-http-2-with-prior-)
  + [3.4](#section-3.4).  [HTTP/2 Connection Preface](#name-http-2-connection-preface)
* [4](#section-4).  [HTTP Frames](#name-http-frames)

  + [4.1](#section-4.1).  [Frame Format](#name-frame-format)
  + [4.2](#section-4.2).  [Frame Size](#name-frame-size)
  + [4.3](#section-4.3).  [Field Section Compression and Decompression](#name-field-section-compression-a)

    - [4.3.1](#section-4.3.1).  [Compression State](#name-compression-state)
* [5](#section-5).  [Streams and Multiplexing](#name-streams-and-multiplexing)

  + [5.1](#section-5.1).  [Stream States](#name-stream-states)

    - [5.1.1](#section-5.1.1).  [Stream Identifiers](#name-stream-identifiers)
    - [5.1.2](#section-5.1.2).  [Stream Concurrency](#name-stream-concurrency)
  + [5.2](#section-5.2).  [Flow Control](#name-flow-control)

    - [5.2.1](#section-5.2.1).  [Flow-Control Principles](#name-flow-control-principles)
    - [5.2.2](#section-5.2.2).  [Appropriate Use of Flow Control](#name-appropriate-use-of-flow-con)
    - [5.2.3](#section-5.2.3).  [Flow-Control Performance](#name-flow-control-performance)
  + [5.3](#section-5.3).  [Prioritization](#name-prioritization)

    - [5.3.1](#section-5.3.1).  [Background on Priority in RFC 7540](#name-background-on-priority-in-r)
    - [5.3.2](#section-5.3.2).  [Priority Signaling in This Document](#name-priority-signaling-in-this-)
  + [5.4](#section-5.4).  [Error Handling](#name-error-handling)

    - [5.4.1](#section-5.4.1).  [Connection Error Handling](#name-connection-error-handling)
    - [5.4.2](#section-5.4.2).  [Stream Error Handling](#name-stream-error-handling)
    - [5.4.3](#section-5.4.3).  [Connection Termination](#name-connection-termination)
  + [5.5](#section-5.5).  [Extending HTTP/2](#name-extending-http-2)
* [6](#section-6).  [Frame Definitions](#name-frame-definitions)

  + [6.1](#section-6.1).  [DATA](#name-data)
  + [6.2](#section-6.2).  [HEADERS](#name-headers)
  + [6.3](#section-6.3).  [PRIORITY](#name-priority)
  + [6.4](#section-6.4).  [RST\_STREAM](#name-rst_stream)
  + [6.5](#section-6.5).  [SETTINGS](#name-settings)

    - [6.5.1](#section-6.5.1).  [SETTINGS Format](#name-settings-format)
    - [6.5.2](#section-6.5.2).  [Defined Settings](#name-defined-settings)
    - [6.5.3](#section-6.5.3).  [Settings Synchronization](#name-settings-synchronization)
  + [6.6](#section-6.6).  [PUSH\_PROMISE](#name-push_promise)
  + [6.7](#section-6.7).  [PING](#name-ping)
  + [6.8](#section-6.8).  [GOAWAY](#name-goaway)
  + [6.9](#section-6.9).  [WINDOW\_UPDATE](#name-window_update)

    - [6.9.1](#section-6.9.1).  [The Flow-Control Window](#name-the-flow-control-window)
    - [6.9.2](#section-6.9.2).  [Initial Flow-Control Window Size](#name-initial-flow-control-window)
    - [6.9.3](#section-6.9.3).  [Reducing the Stream Window Size](#name-reducing-the-stream-window-)
  + [6.10](#section-6.10). [CONTINUATION](#name-continuation)
* [7](#section-7).  [Error Codes](#name-error-codes)
* [8](#section-8).  [Expressing HTTP Semantics in HTTP/2](#name-expressing-http-semantics-i)

  + [8.1](#section-8.1).  [HTTP Message Framing](#name-http-message-framing)

    - [8.1.1](#section-8.1.1).  [Malformed Messages](#name-malformed-messages)
  + [8.2](#section-8.2).  [HTTP Fields](#name-http-fields)

    - [8.2.1](#section-8.2.1).  [Field Validity](#name-field-validity)
    - [8.2.2](#section-8.2.2).  [Connection-Specific Header Fields](#name-connection-specific-header-)
    - [8.2.3](#section-8.2.3).  [Compressing the Cookie Header Field](#name-compressing-the-cookie-head)
  + [8.3](#section-8.3).  [HTTP Control Data](#name-http-control-data)

    - [8.3.1](#section-8.3.1).  [Request Pseudo-Header Fields](#name-request-pseudo-header-field)
    - [8.3.2](#section-8.3.2).  [Response Pseudo-Header Fields](#name-response-pseudo-header-fiel)
  + [8.4](#section-8.4).  [Server Push](#name-server-push)

    - [8.4.1](#section-8.4.1).  [Push Requests](#name-push-requests)
    - [8.4.2](#section-8.4.2).  [Push Responses](#name-push-responses)
  + [8.5](#section-8.5).  [The CONNECT Method](#name-the-connect-method)
  + [8.6](#section-8.6).  [The Upgrade Header Field](#name-the-upgrade-header-field)
  + [8.7](#section-8.7).  [Request Reliability](#name-request-reliability)
  + [8.8](#section-8.8).  [Examples](#name-examples)

    - [8.8.1](#section-8.8.1).  [Simple Request](#name-simple-request)
    - [8.8.2](#section-8.8.2).  [Simple Response](#name-simple-response)
    - [8.8.3](#section-8.8.3).  [Complex Request](#name-complex-request)
    - [8.8.4](#section-8.8.4).  [Response with Body](#name-response-with-body)
    - [8.8.5](#section-8.8.5).  [Informational Responses](#name-informational-responses)
* [9](#section-9).  [HTTP/2 Connections](#name-http-2-connections)

  + [9.1](#section-9.1).  [Connection Management](#name-connection-management)

    - [9.1.1](#section-9.1.1).  [Connection Reuse](#name-connection-reuse)
  + [9.2](#section-9.2).  [Use of TLS Features](#name-use-of-tls-features)

    - [9.2.1](#section-9.2.1).  [TLS 1.2 Features](#name-tls-12-features)
    - [9.2.2](#section-9.2.2).  [TLS 1.2 Cipher Suites](#name-tls-12-cipher-suites)
    - [9.2.3](#section-9.2.3).  [TLS 1.3 Features](#name-tls-13-features)
* [10](#section-10). [Security Considerations](#name-security-considerations)

  + [10.1](#section-10.1).  [Server Authority](#name-server-authority)
  + [10.2](#section-10.2).  [Cross-Protocol Attacks](#name-cross-protocol-attacks)
  + [10.3](#section-10.3).  [Intermediary Encapsulation Attacks](#name-intermediary-encapsulation-)
  + [10.4](#section-10.4).  [Cacheability of Pushed Responses](#name-cacheability-of-pushed-resp)
  + [10.5](#section-10.5).  [Denial-of-Service Considerations](#name-denial-of-service-considera)

    - [10.5.1](#section-10.5.1).  [Limits on Field Block Size](#name-limits-on-field-block-size)
    - [10.5.2](#section-10.5.2).  [CONNECT Issues](#name-connect-issues)
  + [10.6](#section-10.6).  [Use of Compression](#name-use-of-compression)
  + [10.7](#section-10.7).  [Use of Padding](#name-use-of-padding)
  + [10.8](#section-10.8).  [Privacy Considerations](#name-privacy-considerations)
  + [10.9](#section-10.9).  [Remote Timing Attacks](#name-remote-timing-attacks)
* [11](#section-11). [IANA Considerations](#name-iana-considerations)

  + [11.1](#section-11.1).  [HTTP2-Settings Header Field Registration](#name-http2-settings-header-field)
  + [11.2](#section-11.2).  [The h2c Upgrade Token](#name-the-h2c-upgrade-token)
* [12](#section-12). [References](#name-references)

  + [12.1](#section-12.1).  [Normative References](#name-normative-references)
  + [12.2](#section-12.2).  [Informative References](#name-informative-references)
* [Appendix A](#appendix-A).  [Prohibited TLS 1.2 Cipher Suites](#name-prohibited-tls-12-cipher-su)
* [Appendix B](#appendix-B).  [Changes from RFC 7540](#name-changes-from-rfc-7540)
* [Acknowledgments](#name-acknowledgments)
* [Contributors](#name-contributors)
* [Authors' Addresses](#name-authors-addresses)

## [1.](#section-1) [Introduction](#name-introduction)

The performance of applications using the Hypertext Transfer Protocol
(HTTP, [[HTTP](#RFC9110)]) is linked to how each version of HTTP uses the underlying
transport, and the conditions under which the transport operates.[¶](#section-1-1)

Making multiple concurrent requests can reduce latency and improve
application performance. HTTP/1.0 allowed only one request to be
outstanding at a time on a given TCP [[TCP](#RFC0793)] connection. HTTP/1.1 [[HTTP/1.1](#RFC9112)]
added request pipelining, but this only partially addressed request
concurrency and still suffers from application-layer head-of-line
blocking. Therefore, HTTP/1.0 and HTTP/1.1 clients use multiple connections
to a server to make concurrent requests.[¶](#section-1-2)

Furthermore, HTTP fields are often repetitive and verbose, causing unnecessary
network traffic as well as causing the initial TCP congestion
window to quickly fill. This can result in excessive latency when multiple requests are
made on a new TCP connection.[¶](#section-1-3)

HTTP/2 addresses these issues by defining an optimized mapping of HTTP's semantics to an
underlying connection. Specifically, it allows interleaving of messages on the same
connection and uses an efficient coding for HTTP fields. It also allows prioritization of
requests, letting more important requests complete more quickly, further improving
performance.[¶](#section-1-4)

The resulting protocol is more friendly to the network because fewer TCP connections can
be used in comparison to HTTP/1.x. This means less competition with other flows and
longer-lived connections, which in turn lead to better utilization of available network
capacity. Note, however, that TCP head-of-line blocking is not addressed by this protocol.[¶](#section-1-5)

Finally, HTTP/2 also enables more efficient processing of messages through use of binary
message framing.[¶](#section-1-6)

This document obsoletes RFCs 7540 and 8740. [Appendix B](#revision-updates) lists notable changes.[¶](#section-1-7)

## [2.](#section-2) [HTTP/2 Protocol Overview](#name-http-2-protocol-overview)

HTTP/2 provides an optimized transport for HTTP semantics. HTTP/2 supports all of the core
features of HTTP but aims to be more efficient than HTTP/1.1.[¶](#section-2-1)

HTTP/2 is a connection-oriented application-layer protocol that runs over a TCP connection
([[TCP](#RFC0793)]). The client is the TCP connection initiator.[¶](#section-2-2)

The basic protocol unit in HTTP/2 is a [frame](#FrameHeader) ([Section 4.1](#FrameHeader)). Each frame
type serves a different purpose. For example, [HEADERS](#HEADERS) and
[DATA](#DATA) frames form the basis of [HTTP requests and
responses](#HttpFraming) ([Section 8.1](#HttpFraming)); other frame types like [SETTINGS](#SETTINGS),
[WINDOW\_UPDATE](#WINDOW_UPDATE), and [PUSH\_PROMISE](#PUSH_PROMISE) are used in support of other
HTTP/2 features.[¶](#section-2-3)

Multiplexing of requests is achieved by having each HTTP request/response exchange
associated with its own [stream](#StreamsLayer) ([Section 5](#StreamsLayer)). Streams are largely
independent of each other, so a blocked or stalled request or response does not prevent
progress on other streams.[¶](#section-2-4)

Effective use of multiplexing depends on flow control and prioritization. [Flow control](#FlowControl) ([Section 5.2](#FlowControl)) ensures that it is possible to efficiently use
multiplexed streams by restricting data that is transmitted to what the receiver is able to
handle. [Prioritization](#StreamPriority) ([Section 5.3](#StreamPriority)) ensures that limited resources
are used most effectively. This revision of HTTP/2 deprecates the priority signaling scheme
from [[RFC7540](#RFC7540)].[¶](#section-2-5)

Because HTTP fields used in a connection can contain large amounts of redundant
data, frames that contain them are [compressed](#FieldBlock) ([Section 4.3](#FieldBlock)). This has
especially advantageous impact upon request sizes in the common case, allowing many
requests to be compressed into one packet.[¶](#section-2-6)

Finally, HTTP/2 adds a new, optional interaction mode whereby a server can [push
responses to a client](#PushResources) ([Section 8.4](#PushResources)). This is intended to allow a server to speculatively send data to a
client that the server anticipates the client will need, trading off some network usage
against a potential latency gain. The server does this by synthesizing a request, which it
sends as a [PUSH\_PROMISE](#PUSH_PROMISE) frame. The server is then able to send a response to
the synthetic request on a separate stream.[¶](#section-2-7)

### [2.1.](#section-2.1) [Document Organization](#name-document-organization)

The HTTP/2 specification is split into four parts:[¶](#section-2.1-1)

* [Starting HTTP/2](#starting) ([Section 3](#starting)) covers how an HTTP/2 connection is
  initiated.[¶](#section-2.1-2.1)
* The [frame](#FramingLayer) ([Section 4](#FramingLayer)) and [stream](#StreamsLayer) ([Section 5](#StreamsLayer)) layers describe the way HTTP/2 frames are
  structured and formed into multiplexed streams.[¶](#section-2.1-2.2)
* [Frame](#FrameTypes) ([Section 6](#FrameTypes)) and [error](#ErrorCodes) ([Section 7](#ErrorCodes))
  definitions include details of the frame and error types used in HTTP/2.[¶](#section-2.1-2.3)
* [HTTP mappings](#HttpLayer) ([Section 8](#HttpLayer)) and [additional
  requirements](#HttpExtra) ([Section 9](#HttpExtra)) describe how HTTP semantics are expressed using frames and
  streams.[¶](#section-2.1-2.4)

While some of the frame- and stream-layer concepts are isolated from HTTP, this
specification does not define a completely generic frame layer. The frame and stream
layers are tailored to the needs of HTTP.[¶](#section-2.1-3)

### [2.2.](#section-2.2) [Conventions and Terminology](#name-conventions-and-terminology)

The key words "MUST", "MUST NOT",
"REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED",
"NOT RECOMMENDED", "MAY", and "OPTIONAL" in
this document are to be interpreted as described in BCP 14 [[RFC2119](#RFC2119)] [[RFC8174](#RFC8174)] when, and only when, they
appear in all capitals, as shown here.[¶](#section-2.2-1)

All numeric values are in network byte order. Values are unsigned unless otherwise
indicated. Literal values are provided in decimal or hexadecimal as appropriate.
Hexadecimal literals are prefixed with "`0x`" to distinguish them
from decimal literals.[¶](#section-2.2-2)

This specification describes binary formats using the conventions described in [Section 1.3](https://www.rfc-editor.org/rfc/rfc9000#section-1.3) of RFC 9000 [[QUIC](#RFC9000)]. Note that this format uses network byte
order and that high-valued bits are listed before low-valued bits.[¶](#section-2.2-3)

The following terms are used:[¶](#section-2.2-4)

client:
The endpoint that initiates an HTTP/2 connection. Clients send HTTP requests and
receive HTTP responses.[¶](#section-2.2-5.2)

connection:
A transport-layer connection between two endpoints.[¶](#section-2.2-5.4)

connection error:
An error that affects the entire HTTP/2 connection.[¶](#section-2.2-5.6)

endpoint:
Either the client or server of the connection.[¶](#section-2.2-5.8)

frame:
The smallest unit of communication within an HTTP/2 connection, consisting of a header
and a variable-length sequence of octets structured according to the frame type.[¶](#section-2.2-5.10)

peer:
An endpoint. When discussing a particular endpoint, "peer" refers to the endpoint
that is remote to the primary subject of discussion.[¶](#section-2.2-5.12)

receiver:
An endpoint that is receiving frames.[¶](#section-2.2-5.14)

sender:
An endpoint that is transmitting frames.[¶](#section-2.2-5.16)

server:
The endpoint that accepts an HTTP/2 connection. Servers receive HTTP requests and
send HTTP responses.[¶](#section-2.2-5.18)

stream:
A bidirectional flow of frames within the HTTP/2 connection.[¶](#section-2.2-5.20)

stream error:
An error on the individual HTTP/2 stream.[¶](#section-2.2-5.22)

Finally, the terms "gateway", "intermediary", "proxy", and "tunnel" are defined in
[Section 3.7](https://www.rfc-editor.org/rfc/rfc9110#section-3.7) of [[HTTP](#RFC9110)]. Intermediaries act as both client
and server at different times.[¶](#section-2.2-6)

The term "content" as it applies to message bodies is defined in [Section 6.4](https://www.rfc-editor.org/rfc/rfc9110#section-6.4) of [[HTTP](#RFC9110)].[¶](#section-2.2-7)

## [3.](#section-3) [Starting HTTP/2](#name-starting-http-2)

Implementations that generate HTTP requests need to discover whether a server supports
HTTP/2.[¶](#section-3-1)

HTTP/2 uses the "`http`" and "`https`" URI schemes defined in [Section 4.2](https://www.rfc-editor.org/rfc/rfc9110#section-4.2) of [[HTTP](#RFC9110)], with the same default port numbers as HTTP/1.1 [[HTTP/1.1](#RFC9112)]. These URIs do not include any indication about what HTTP versions an
upstream server (the immediate peer to which the client wishes to establish a connection)
supports.[¶](#section-3-2)

The means by which support for HTTP/2 is determined is different for "`http`" and "`https`"
URIs. Discovery for "`https`" URIs is described in [Section 3.2](#discover-https). HTTP/2
support for "`http`" URIs can only be discovered by out-of-band means and requires prior knowledge
of the support as described in [Section 3.3](#known-http).[¶](#section-3-3)

### [3.1.](#section-3.1) [HTTP/2 Version Identification](#name-http-2-version-identificati)

The protocol defined in this document has two identifiers. Creating a connection based on
either implies the use of the transport, framing, and message semantics described in this
document.[¶](#section-3.1-1)

* The string "h2" identifies the protocol where HTTP/2 uses Transport Layer Security
  (TLS); see [Section 9.2](#TLSUsage). This identifier is used in the [TLS Application-Layer Protocol Negotiation (ALPN) extension](#RFC7301) [[TLS-ALPN](#RFC7301)]
  field and in any place where HTTP/2 over TLS is identified.[¶](#section-3.1-2.1.1)

  The "h2" string is serialized into an ALPN protocol identifier as the two-octet
  sequence: 0x68, 0x32.[¶](#section-3.1-2.1.2)
* The "h2c" string was previously used as a token for use in the HTTP Upgrade
  mechanism's Upgrade header field ([Section 7.8](https://www.rfc-editor.org/rfc/rfc9110#section-7.8) of [[HTTP](#RFC9110)]). This usage
  was never widely deployed and is deprecated by this document. The same applies to the
  HTTP2-Settings header field, which was used with the upgrade to "h2c".[¶](#section-3.1-2.2.1)

### [3.2.](#section-3.2) [Starting HTTP/2 for "`https`" URIs](#name-starting-http-2-for-https-u)

A client that makes a request to an "`https`" URI uses [TLS](#RFC8446) [[TLS13](#RFC8446)] with
the [ALPN extension](#RFC7301) [[TLS-ALPN](#RFC7301)].[¶](#section-3.2-1)

HTTP/2 over TLS uses the "h2" protocol identifier. The "h2c" protocol identifier MUST NOT
be sent by a client or selected by a server; the "h2c" protocol identifier describes a
protocol that does not use TLS.[¶](#section-3.2-2)

Once TLS negotiation is complete, both the client and the server MUST send a [connection preface](#preface) ([Section 3.4](#preface)).[¶](#section-3.2-3)

### [3.3.](#section-3.3) [Starting HTTP/2 with Prior Knowledge](#name-starting-http-2-with-prior-)

A client can learn that a particular server supports HTTP/2 by other means. For example,
a client could be configured with knowledge that a server supports HTTP/2.[¶](#section-3.3-1)

A client that knows that a server supports HTTP/2 can establish a TCP connection and send
the [connection preface](#preface) ([Section 3.4](#preface)) followed by HTTP/2 frames.
Servers can identify these connections by the presence of the connection preface. This
only affects the establishment of HTTP/2 connections over cleartext TCP; HTTP/2 connections
over TLS MUST use [protocol negotiation in
TLS](#RFC7301) [[TLS-ALPN](#RFC7301)].[¶](#section-3.3-2)

Likewise, the server MUST send a [connection preface](#preface) ([Section 3.4](#preface)).[¶](#section-3.3-3)

Without additional information, prior support for HTTP/2 is not a strong signal that a
given server will support HTTP/2 for future connections. For example, it is possible for
server configurations to change, for configurations to differ between instances in
clustered servers, or for network conditions to change.[¶](#section-3.3-4)

### [3.4.](#section-3.4) [HTTP/2 Connection Preface](#name-http-2-connection-preface)

In HTTP/2, each endpoint is required to send a connection preface as a final confirmation
of the protocol in use and to establish the initial settings for the HTTP/2 connection.
The client and server each send a different connection preface.[¶](#section-3.4-1)

The client connection preface starts with a sequence of 24 octets, which in hex notation
is:[¶](#section-3.4-2)

```

  0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a

```
[¶](#section-3.4-3)

That is, the connection preface starts with the string "`PRI *
HTTP/2.0\r\n\r\nSM\r\n\r\n`". This sequence
MUST be followed by a [SETTINGS](#SETTINGS) frame ([Section 6.5](#SETTINGS)), which
MAY be empty. The client sends the client connection preface as the first
application data octets of a connection.[¶](#section-3.4-4)

Note:
The client connection preface is selected so that a large proportion of HTTP/1.1 or
HTTP/1.0 servers and intermediaries do not attempt to process further frames. Note
that this does not address the concerns raised in [[TALKING](#TALKING)].[¶](#section-3.4-5.1)

The server connection preface consists of a potentially empty [SETTINGS](#SETTINGS)
frame ([Section 6.5](#SETTINGS)) that MUST be the first frame the server sends in the
HTTP/2 connection.[¶](#section-3.4-6)

The [SETTINGS](#SETTINGS) frames received from a peer as part of the connection preface
MUST be acknowledged (see [Section 6.5.3](#SettingsSync)) after sending the connection
preface.[¶](#section-3.4-7)

To avoid unnecessary latency, clients are permitted to send additional frames to the
server immediately after sending the client connection preface, without waiting to receive
the server connection preface. It is important to note, however, that the server
connection preface [SETTINGS](#SETTINGS) frame might include settings that necessarily
alter how a client is expected to communicate with the server. Upon receiving the
[SETTINGS](#SETTINGS) frame, the client is expected to honor any settings established.
In some configurations, it is possible for the server to transmit [SETTINGS](#SETTINGS)
before the client sends additional frames, providing an opportunity to avoid this issue.[¶](#section-3.4-8)

Clients and servers MUST treat an invalid connection preface as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR). A [GOAWAY](#GOAWAY) frame ([Section 6.8](#GOAWAY))
MAY be omitted in this case, since an invalid preface indicates that the peer is not using
HTTP/2.[¶](#section-3.4-9)

## [4.](#section-4) [HTTP Frames](#name-http-frames)

Once the HTTP/2 connection is established, endpoints can begin exchanging frames.[¶](#section-4-1)

### [4.1.](#section-4.1) [Frame Format](#name-frame-format)

All frames begin with a fixed 9-octet header followed by a variable-length frame payload.[¶](#section-4.1-1)

```

HTTP Frame {
  Length (24),
  Type (8),

  Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Frame Payload (..),
}

```

[Figure 1](#figure-1):
[Frame Layout](#name-frame-layout)

The fields of the frame header are defined as:[¶](#section-4.1-3)

Length:

The length of the frame payload expressed as an unsigned 24-bit integer in units of octets. Values
greater than 214 (16,384) MUST NOT be sent unless the receiver has
set a larger value for [SETTINGS\_MAX\_FRAME\_SIZE](#SETTINGS_MAX_FRAME_SIZE).[¶](#section-4.1-4.2.1)

The 9 octets of the frame header are not included in this value.[¶](#section-4.1-4.2.2)

Type:

The 8-bit type of the frame. The frame type determines the format and semantics of
the frame. Frames defined in this document are listed in [Section 6](#FrameTypes).
Implementations MUST ignore and discard frames of unknown types.[¶](#section-4.1-4.4.1)

Flags:

An 8-bit field reserved for boolean flags specific to the frame type.[¶](#section-4.1-4.6.1)

Flags are assigned semantics specific to the indicated frame type. Unused flags are
those that have no defined semantics for a particular frame type. Unused flags MUST be
ignored on receipt and MUST be left unset (0x00) when sending.[¶](#section-4.1-4.6.2)

Reserved:

A reserved 1-bit field. The semantics of this bit are undefined, and the bit MUST
remain unset (0x00) when sending and MUST be ignored when receiving.[¶](#section-4.1-4.8.1)

Stream Identifier:

A stream identifier (see [Section 5.1.1](#StreamIdentifiers)) expressed as an
unsigned 31-bit integer. The value 0x00 is reserved for frames that are associated
with the connection as a whole as opposed to an individual stream.[¶](#section-4.1-4.10.1)

The structure and content of the frame payload are dependent entirely on the frame type.[¶](#section-4.1-5)

### [4.2.](#section-4.2) [Frame Size](#name-frame-size)

The size of a frame payload is limited by the maximum size that a receiver advertises in
the [SETTINGS\_MAX\_FRAME\_SIZE](#SETTINGS_MAX_FRAME_SIZE) setting. This setting can have any value
between 214 (16,384) and 224-1 (16,777,215) octets,
inclusive.[¶](#section-4.2-1)

All implementations MUST be capable of receiving and minimally processing frames up to
214 octets in length, plus the 9-octet [frame
header](#FrameHeader) ([Section 4.1](#FrameHeader)). The size of the frame header is not included when describing frame sizes.[¶](#section-4.2-2)

Note: Certain frame types, such as [PING](#PING) ([Section 6.7](#PING)), impose additional limits
on the amount of frame payload data allowed.[¶](#section-4.2-3.1)

An endpoint MUST send an error code of [FRAME\_SIZE\_ERROR](#FRAME_SIZE_ERROR) if a frame exceeds the size defined in [SETTINGS\_MAX\_FRAME\_SIZE](#SETTINGS_MAX_FRAME_SIZE), exceeds any
limit defined for the frame type, or is too small to contain mandatory frame data. A frame
size error in a frame that could alter the state of the entire connection MUST be treated
as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)); this includes any
frame carrying a [field block](#FieldBlock) ([Section 4.3](#FieldBlock)) (that is, [HEADERS](#HEADERS), [PUSH\_PROMISE](#PUSH_PROMISE), and [CONTINUATION](#CONTINUATION)), a [SETTINGS](#SETTINGS) frame, and any frame with a stream identifier of 0.[¶](#section-4.2-4)

Endpoints are not obligated to use all available space in a frame. Responsiveness can be
improved by using frames that are smaller than the permitted maximum size. Sending large
frames can result in delays in sending time-sensitive frames (such as
[RST\_STREAM](#RST_STREAM), [WINDOW\_UPDATE](#WINDOW_UPDATE), or [PRIORITY](#PRIORITY)),
which, if blocked by the transmission of a large frame, could affect performance.[¶](#section-4.2-5)

### [4.3.](#section-4.3) [Field Section Compression and Decompression](#name-field-section-compression-a)

Field section compression is the process of compressing a set of field lines ([Section 5.2](https://www.rfc-editor.org/rfc/rfc9110#section-5.2) of [[HTTP](#RFC9110)]) to form a
field block. Field section decompression is the process of decoding a field block into a
set of field lines. Details of HTTP/2 field section compression and decompression are
defined in [[COMPRESSION](#RFC7541)], which, for historical reasons, refers to these
processes as header compression and decompression.[¶](#section-4.3-1)

Each field block carries all of the compressed field lines of a single field section.
Header sections also include control data associated with the message in the form of [pseudo-header fields](#PseudoHeaderFields) ([Section 8.3](#PseudoHeaderFields)) that use the same format as a
field line.[¶](#section-4.3-2)

Note: [RFC 7540](#RFC7540) [[RFC7540](#RFC7540)] used the term "header block" in place of
the more generic "field block".[¶](#section-4.3-3.1)

Field blocks carry control data and header sections for requests, responses, promised
requests, and pushed responses (see [Section 8.4](#PushResources)). All these messages,
except for interim responses and requests contained in [PUSH\_PROMISE](#PUSH_PROMISE) ([Section 6.6](#PUSH_PROMISE)) frames, can optionally include a field block that
carries a trailer section.[¶](#section-4.3-4)

A field section is a collection of field lines. Each of the field lines in a
field block carries a single value. The serialized field block is then divided into one or
more octet sequences, called field block fragments. The first field block fragment is transmitted within the frame
payload of [HEADERS](#HEADERS) ([Section 6.2](#HEADERS)) or [PUSH\_PROMISE](#PUSH_PROMISE) ([Section 6.6](#PUSH_PROMISE)), each of which could be followed by [CONTINUATION](#CONTINUATION) ([Section 6.10](#CONTINUATION)) frames to carry subsequent field block fragments.[¶](#section-4.3-5)

The [Cookie header field](#RFC6265) [[COOKIE](#RFC6265)] is treated specially by the HTTP
mapping (see [Section 8.2.3](#CompressCookie)).[¶](#section-4.3-6)

A receiving endpoint reassembles the field block by concatenating its fragments and then
decompresses the block to reconstruct the field section.[¶](#section-4.3-7)

A complete field section consists of either:[¶](#section-4.3-8)

* a single [HEADERS](#HEADERS) or [PUSH\_PROMISE](#PUSH_PROMISE) frame,
  with the END\_HEADERS flag set, or[¶](#section-4.3-9.1)
* a [HEADERS](#HEADERS) or [PUSH\_PROMISE](#PUSH_PROMISE) frame with the END\_HEADERS
  flag unset and one or more [CONTINUATION](#CONTINUATION) frames,
  where the last [CONTINUATION](#CONTINUATION) frame has the END\_HEADERS flag set.[¶](#section-4.3-9.2)

Each field block is processed as a discrete unit.
Field blocks MUST be transmitted as a contiguous sequence of frames, with no interleaved
frames of any other type or from any other stream. The last frame in a sequence of
[HEADERS](#HEADERS) or [CONTINUATION](#CONTINUATION) frames has the END\_HEADERS flag set.
The last frame in a sequence of [PUSH\_PROMISE](#PUSH_PROMISE) or [CONTINUATION](#CONTINUATION)
frames has the END\_HEADERS flag set. This allows a field block to be logically
equivalent to a single frame.[¶](#section-4.3-10)

Field block fragments can only be sent as the frame payload of [HEADERS](#HEADERS),
[PUSH\_PROMISE](#PUSH_PROMISE), or [CONTINUATION](#CONTINUATION) frames because these frames
carry data that can modify the compression context maintained by a receiver. An endpoint
receiving [HEADERS](#HEADERS), [PUSH\_PROMISE](#PUSH_PROMISE), or
[CONTINUATION](#CONTINUATION) frames needs to reassemble field blocks and perform
decompression even if the frames are to be discarded. A receiver MUST terminate the
connection with a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[COMPRESSION\_ERROR](#COMPRESSION_ERROR) if it does not decompress a field block.[¶](#section-4.3-11)

A decoding error in a field block MUST be treated as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type [COMPRESSION\_ERROR](#COMPRESSION_ERROR).[¶](#section-4.3-12)

#### [4.3.1.](#section-4.3.1) [Compression State](#name-compression-state)

Field compression is stateful. Each endpoint has an HPACK encoder context and an HPACK
decoder context that are used for encoding and decoding all field blocks on a
connection. [Section 4](https://www.rfc-editor.org/rfc/rfc7541#section-4) of [[COMPRESSION](#RFC7541)] defines the dynamic table, which
is the primary state for each context.[¶](#section-4.3.1-1)

The dynamic table has a maximum size that is set by an HPACK decoder. An endpoint
communicates the size chosen by its HPACK decoder context using the
SETTINGS\_HEADER\_TABLE\_SIZE setting; see [Section 6.5.2](#SettingValues). When a
connection is established, the dynamic table size for the HPACK decoder and encoder at
both endpoints starts at 4,096 bytes, the initial value of the
SETTINGS\_HEADER\_TABLE\_SIZE setting.[¶](#section-4.3.1-2)

Any change to the maximum value set using SETTINGS\_HEADER\_TABLE\_SIZE takes effect when
the endpoint [acknowledges settings](#SettingsSync) ([Section 6.5.3](#SettingsSync)). The HPACK
encoder at that endpoint can set the dynamic table to any size up to the maximum value
set by the decoder. An HPACK encoder declares the size of the dynamic table with a
Dynamic Table Size Update instruction ([Section 6.3](https://www.rfc-editor.org/rfc/rfc7541#section-6.3) of [[COMPRESSION](#RFC7541)]).[¶](#section-4.3.1-3)

Once an endpoint acknowledges a change to SETTINGS\_HEADER\_TABLE\_SIZE that reduces the
maximum below the current size of the dynamic table, its HPACK encoder MUST start the
next field block with a Dynamic Table Size Update instruction that sets the dynamic
table to a size that is less than or equal to the reduced maximum; see [Section 4.2](https://www.rfc-editor.org/rfc/rfc7541#section-4.2) of [[COMPRESSION](#RFC7541)]. An endpoint MUST treat a field block that follows
an acknowledgment of the reduction to the maximum dynamic table size as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type [COMPRESSION\_ERROR](#COMPRESSION_ERROR) if it does not start
with a conformant Dynamic Table Size Update instruction.[¶](#section-4.3.1-4)

Implementers are advised that reducing the value of SETTINGS\_HEADER\_TABLE\_SIZE is not
widely interoperable. Use of the connection preface to reduce the value below the
initial value of 4,096 is somewhat better supported, but this might fail with some
implementations.[¶](#section-4.3.1-5.1)

## [5.](#section-5) [Streams and Multiplexing](#name-streams-and-multiplexing)

A "stream" is an independent, bidirectional sequence of frames exchanged between the client
and server within an HTTP/2 connection. Streams have several important characteristics:[¶](#section-5-1)

* A single HTTP/2 connection can contain multiple concurrently open streams, with either
  endpoint interleaving frames from multiple streams.[¶](#section-5-2.1)
* Streams can be established and used unilaterally or shared by either endpoint.[¶](#section-5-2.2)
* Streams can be closed by either endpoint.[¶](#section-5-2.3)
* The order in which frames are sent is significant. Recipients process frames
  in the order they are received. In particular, the order of [HEADERS](#HEADERS)
  and [DATA](#DATA) frames is semantically significant.[¶](#section-5-2.4)
* Streams are identified by an integer. Stream identifiers are assigned to streams by the
  endpoint initiating the stream.[¶](#section-5-2.5)

### [5.1.](#section-5.1) [Stream States](#name-stream-states)

The lifecycle of a stream is shown in [Figure 2](#StreamStatesFigure).[¶](#section-5.1-1)

send PP
recv PP
idle
send H /
reserved
recv H
reserved
(local)
(remote)
recv ES
send ES
send H
open
recv H
half-
half-
closed
send R /
closed
(remote)
recv R
(local)
send ES /
recv ES /
send R /
send R /
recv R
recv R
send R /
send R /
recv R
closed
recv R

[¶](#section-5.1-2.1.1)

[Figure 2](#figure-2):
[Stream States](#name-stream-states-2)

`send`:
endpoint sends this frame[¶](#section-5.1-3.2)

`recv`:
endpoint receives this frame[¶](#section-5.1-3.4)

`H`:
[HEADERS](#HEADERS) frame (with implied [CONTINUATION](#CONTINUATION) frames)[¶](#section-5.1-3.6)

`ES`:
END\_STREAM flag[¶](#section-5.1-3.8)

`R`:
[RST\_STREAM](#RST_STREAM) frame[¶](#section-5.1-3.10)

`PP`:
[PUSH\_PROMISE](#PUSH_PROMISE) frame (with implied [CONTINUATION](#CONTINUATION) frames); state transitions are for the promised stream[¶](#section-5.1-3.12)

Note that this diagram shows stream state transitions and the frames and flags that affect
those transitions only. In this regard, [CONTINUATION](#CONTINUATION) frames do not result
in state transitions; they are effectively part of the [HEADERS](#HEADERS) or
[PUSH\_PROMISE](#PUSH_PROMISE) that they follow. For the purpose of state transitions, the
END\_STREAM flag is processed as a separate event to the frame that bears it; a
[HEADERS](#HEADERS) frame with the END\_STREAM flag set can cause two state transitions.[¶](#section-5.1-4)

Both endpoints have a subjective view of the state of a stream that could be different
when frames are in transit. Endpoints do not coordinate the creation of streams; they are
created unilaterally by either endpoint. The negative consequences of a mismatch in
states are limited to the "closed" state after sending [RST\_STREAM](#RST_STREAM), where
frames might be received for some time after closing.[¶](#section-5.1-5)

Streams have the following states:[¶](#section-5.1-6)

idle:

All streams start in the "idle" state.[¶](#section-5.1-7.2.1)

The following transitions are valid from this state:[¶](#section-5.1-7.2.2)

* Sending a [HEADERS](#HEADERS) frame as a client, or receiving a HEADERS frame
  as a server, causes the stream to become "open". The stream identifier is selected as described in
  [Section 5.1.1](#StreamIdentifiers). The same [HEADERS](#HEADERS) frame can also
  cause a stream to immediately become "half-closed".[¶](#section-5.1-7.2.3.1)
* Sending a [PUSH\_PROMISE](#PUSH_PROMISE) frame on another stream reserves the idle
  stream that is identified for later use. The stream state for the reserved
  stream transitions to "reserved (local)". Only a server may send [PUSH\_PROMISE](#PUSH_PROMISE) frames.[¶](#section-5.1-7.2.3.2)
* Receiving a [PUSH\_PROMISE](#PUSH_PROMISE) frame on another stream reserves an idle
  stream that is identified for later use. The stream state for the reserved
  stream transitions to "reserved (remote)". Only a client may receive [PUSH\_PROMISE](#PUSH_PROMISE) frames.[¶](#section-5.1-7.2.3.3)
* Note that the [PUSH\_PROMISE](#PUSH_PROMISE) frame is not sent on the idle
  stream but references the newly reserved stream in the Promised Stream ID
  field.[¶](#section-5.1-7.2.3.4)
* Opening a stream with a higher-valued stream identifier causes the stream to
  transition immediately to a "closed" state; note that this transition is not shown
  in the diagram.[¶](#section-5.1-7.2.3.5)

Receiving any frame other than [HEADERS](#HEADERS) or [PRIORITY](#PRIORITY) on
a stream in this state MUST be treated as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR). If this stream is initiated by the server, as described in
[Section 5.1.1](#StreamIdentifiers), then receiving a [HEADERS](#HEADERS) frame MUST also
be treated as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-5.1-7.2.4)

reserved (local):

A stream in the "reserved (local)" state is one that has been promised by sending a
[PUSH\_PROMISE](#PUSH_PROMISE) frame. A [PUSH\_PROMISE](#PUSH_PROMISE) frame reserves an
idle stream by associating the stream with an open stream that was initiated by the
remote peer (see [Section 8.4](#PushResources)).[¶](#section-5.1-7.4.1)

In this state, only the following transitions are possible:[¶](#section-5.1-7.4.2)

* The endpoint can send a [HEADERS](#HEADERS) frame. This causes the stream to
  open in a "half-closed (remote)" state.[¶](#section-5.1-7.4.3.1)
* Either endpoint can send a [RST\_STREAM](#RST_STREAM) frame to cause the stream
  to become "closed". This releases the stream reservation.[¶](#section-5.1-7.4.3.2)

An endpoint MUST NOT send any type of frame other than [HEADERS](#HEADERS),
[RST\_STREAM](#RST_STREAM), or [PRIORITY](#PRIORITY) in this state.[¶](#section-5.1-7.4.4)

A [PRIORITY](#PRIORITY) or [WINDOW\_UPDATE](#WINDOW_UPDATE) frame MAY be received in
this state. Receiving any type of frame other than [RST\_STREAM](#RST_STREAM),
[PRIORITY](#PRIORITY), or [WINDOW\_UPDATE](#WINDOW_UPDATE) on a stream in this state
MUST be treated as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler))
of type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-5.1-7.4.5)

reserved (remote):

A stream in the "reserved (remote)" state has been reserved by a remote peer.[¶](#section-5.1-7.6.1)

In this state, only the following transitions are possible:[¶](#section-5.1-7.6.2)

* Receiving a [HEADERS](#HEADERS) frame causes the stream to transition to
  "half-closed (local)".[¶](#section-5.1-7.6.3.1)
* Either endpoint can send a [RST\_STREAM](#RST_STREAM) frame to cause the stream
  to become "closed". This releases the stream reservation.[¶](#section-5.1-7.6.3.2)

An endpoint MUST NOT send any type of frame other than [RST\_STREAM](#RST_STREAM), [WINDOW\_UPDATE](#WINDOW_UPDATE), or [PRIORITY](#PRIORITY) in this state.[¶](#section-5.1-7.6.4)

Receiving any type of frame other than [HEADERS](#HEADERS),
[RST\_STREAM](#RST_STREAM), or [PRIORITY](#PRIORITY) on a stream in this state MUST
be treated as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of
type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-5.1-7.6.5)

open:

A stream in the "open" state may be used by both peers to send frames of any type.
In this state, sending peers observe advertised [stream-level
flow-control limits](#FlowControl) ([Section 5.2](#FlowControl)).[¶](#section-5.1-7.8.1)

From this state, either endpoint can send a frame with an END\_STREAM flag set, which
causes the stream to transition into one of the "half-closed" states. An endpoint
sending an END\_STREAM flag causes the stream state to become "half-closed (local)";
an endpoint receiving an END\_STREAM flag causes the stream state to become "half-closed
(remote)".[¶](#section-5.1-7.8.2)

Either endpoint can send a [RST\_STREAM](#RST_STREAM) frame from this state, causing
it to transition immediately to "closed".[¶](#section-5.1-7.8.3)

half-closed (local):

A stream that is in the "half-closed (local)" state cannot be used for sending
frames other than [WINDOW\_UPDATE](#WINDOW_UPDATE), [PRIORITY](#PRIORITY), and
[RST\_STREAM](#RST_STREAM).[¶](#section-5.1-7.10.1)

A stream transitions from this state to "closed" when a frame is received with the
END\_STREAM flag set or when either peer sends a [RST\_STREAM](#RST_STREAM)
frame.[¶](#section-5.1-7.10.2)

An endpoint can receive any type of frame in this state. Providing flow-control
credit using [WINDOW\_UPDATE](#WINDOW_UPDATE) frames is necessary to continue receiving
flow-controlled frames. In this state, a receiver can ignore [WINDOW\_UPDATE](#WINDOW_UPDATE) frames,
which might arrive for a short period after a frame with the END\_STREAM flag set is sent.[¶](#section-5.1-7.10.3)

[PRIORITY](#PRIORITY) frames can be received in this state.[¶](#section-5.1-7.10.4)

half-closed (remote):

A stream that is "half-closed (remote)" is no longer being used by the peer to send
frames. In this state, an endpoint is no longer obligated to maintain a receiver
flow-control window.[¶](#section-5.1-7.12.1)

If an endpoint receives additional frames, other
than [WINDOW\_UPDATE](#WINDOW_UPDATE), [PRIORITY](#PRIORITY), or
[RST\_STREAM](#RST_STREAM), for a stream that is in this state, it MUST respond with a [stream error](#StreamErrorHandler) ([Section 5.4.2](#StreamErrorHandler)) of type
[STREAM\_CLOSED](#STREAM_CLOSED).[¶](#section-5.1-7.12.2)

A stream that is "half-closed (remote)" can be used by the endpoint to send frames
of any type. In this state, the endpoint continues to observe advertised [stream-level flow-control limits](#FlowControl) ([Section 5.2](#FlowControl)).[¶](#section-5.1-7.12.3)

A stream can transition from this state to "closed" by sending a frame with the
END\_STREAM flag set or when either peer sends a [RST\_STREAM](#RST_STREAM) frame.[¶](#section-5.1-7.12.4)

closed:

The "closed" state is the terminal state.[¶](#section-5.1-7.14.1)

A stream enters the "closed" state after an endpoint both sends and receives a frame
with an END\_STREAM flag set. A stream also enters the "closed" state after an endpoint
either sends or receives a [RST\_STREAM](#RST_STREAM)
frame.[¶](#section-5.1-7.14.2)

An endpoint MUST NOT send frames other than [PRIORITY](#PRIORITY) on a closed stream. An endpoint MAY treat receipt of
any other type of frame on a closed stream as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type [STREAM\_CLOSED](#STREAM_CLOSED), except as noted below.[¶](#section-5.1-7.14.3)

An endpoint that sends a frame with the END\_STREAM flag set or a [RST\_STREAM](#RST_STREAM) frame might receive a [WINDOW\_UPDATE](#WINDOW_UPDATE) or [RST\_STREAM](#RST_STREAM) frame from its peer in the time before the peer
receives and processes the frame that closes the stream.[¶](#section-5.1-7.14.4)

An endpoint that sends a [RST\_STREAM](#RST_STREAM)
frame on a stream that is in the "open" or "half-closed (local)" state could receive any type of frame. The
peer might have sent or enqueued for sending these frames before processing the [RST\_STREAM](#RST_STREAM) frame. An endpoint MUST minimally
process and then discard any frames it receives in this state. This means updating
header compression state for [HEADERS](#HEADERS) and
[PUSH\_PROMISE](#PUSH_PROMISE) frames. Receiving a [PUSH\_PROMISE](#PUSH_PROMISE) frame also causes the promised
stream to become "reserved (remote)", even when the [PUSH\_PROMISE](#PUSH_PROMISE) frame is received on a closed stream. Additionally, the
content of [DATA](#DATA) frames counts toward the
connection flow-control window.[¶](#section-5.1-7.14.5)

An endpoint can perform this minimal processing for all streams that are in the
"closed" state. Endpoints MAY use other signals to detect that a peer has received
the frames that caused the stream to enter the "closed" state and treat receipt of any frame other
than [PRIORITY](#PRIORITY) as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type [PROTOCOL\_ERROR](#PROTOCOL_ERROR). Endpoints can use frames
that indicate that the peer has received the closing signal to drive this. Endpoints
SHOULD NOT use timers for this purpose. For example, an endpoint that sends a [SETTINGS](#SETTINGS) frame after closing a stream can
safely treat receipt of a [DATA](#DATA) frame on that
stream as an error after receiving an acknowledgment of the settings. Other things
that might be used are [PING](#PING) frames, receiving
data on streams that were created after closing the stream, or responses to requests
created after closing the stream.[¶](#section-5.1-7.14.6)

In the absence of more specific rules, implementations SHOULD treat the receipt of a frame
that is not expressly permitted in the description of a state as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type [PROTOCOL\_ERROR](#PROTOCOL_ERROR). Note that [PRIORITY](#PRIORITY) can be sent and received in any stream
state.[¶](#section-5.1-8)

The rules in this section only apply to frames defined in this document. Receipt of
frames for which the semantics are unknown cannot be treated as an error, as the conditions
for sending and receiving those frames are also unknown; see [Section 5.5](#extensibility).[¶](#section-5.1-9)

An example of the state transitions for an HTTP request/response exchange can be found in
[Section 8.8](#HttpExamples). An example of the state transitions for server push can be
found in Sections [8.4.1](#PushRequests) and [8.4.2](#PushResponses).[¶](#section-5.1-10)

#### [5.1.1.](#section-5.1.1) [Stream Identifiers](#name-stream-identifiers)

Streams are identified by an unsigned 31-bit integer. Streams initiated by a client
MUST use odd-numbered stream identifiers; those initiated by the server MUST use
even-numbered stream identifiers. A stream identifier of zero (0x00) is used for
connection control messages; the stream identifier of zero cannot be used to establish a
new stream.[¶](#section-5.1.1-1)

The identifier of a newly established stream MUST be numerically greater than all
streams that the initiating endpoint has opened or reserved. This governs streams that
are opened using a [HEADERS](#HEADERS) frame and streams that are reserved using
[PUSH\_PROMISE](#PUSH_PROMISE). An endpoint that receives an unexpected stream identifier
MUST respond with a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of
type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-5.1.1-2)

A [HEADERS](#HEADERS) frame will transition the client-initiated stream identified
by the stream identifier in the frame header from "idle" to "open". A [PUSH\_PROMISE](#PUSH_PROMISE)
frame will transition the server-initiated stream identified by the Promised Stream ID field in the frame payload from "idle" to "reserved (local)" or "reserved (remote)". When
a stream transitions out of the "idle" state, all streams in the "idle" state that might have been opened by the peer with a lower-valued
stream identifier immediately transition to "closed". That is, an endpoint may skip a stream identifier, with the
effect being that the skipped stream is immediately closed.[¶](#section-5.1.1-3)

Stream identifiers cannot be reused. Long-lived connections can result in an endpoint
exhausting the available range of stream identifiers. A client that is unable to
establish a new stream identifier can establish a new connection for new streams. A
server that is unable to establish a new stream identifier can send a
[GOAWAY](#GOAWAY) frame so that the client is forced to open a new connection for
new streams.[¶](#section-5.1.1-4)

#### [5.1.2.](#section-5.1.2) [Stream Concurrency](#name-stream-concurrency)

A peer can limit the number of concurrently active streams using the
[SETTINGS\_MAX\_CONCURRENT\_STREAMS](#SETTINGS_MAX_CONCURRENT_STREAMS) parameter (see [Section 6.5.2](#SettingValues)) within a [SETTINGS](#SETTINGS) frame. The maximum concurrent
streams setting is specific to each endpoint and applies only to the peer that receives
the setting. That is, clients specify the maximum number of concurrent streams the
server can initiate, and servers specify the maximum number of concurrent streams the
client can initiate.[¶](#section-5.1.2-1)

Streams that are in the "open" state or in either of the "half-closed" states count toward
the maximum number of streams that an endpoint is permitted to open. Streams in any of
these three states count toward the limit advertised in the
[SETTINGS\_MAX\_CONCURRENT\_STREAMS](#SETTINGS_MAX_CONCURRENT_STREAMS) setting. Streams in either of the
"reserved" states do not count toward the stream limit.[¶](#section-5.1.2-2)

Endpoints MUST NOT exceed the limit set by their peer. An endpoint that receives a
[HEADERS](#HEADERS) frame that causes its advertised concurrent stream limit to be
exceeded MUST treat this as a [stream error](#StreamErrorHandler) ([Section 5.4.2](#StreamErrorHandler)) of
type [PROTOCOL\_ERROR](#PROTOCOL_ERROR) or [REFUSED\_STREAM](#REFUSED_STREAM). The choice of
error code determines whether the endpoint wishes to enable automatic retry (see [Section 8.7](#Reliability) for details).[¶](#section-5.1.2-3)

An endpoint that wishes to reduce the value of
[SETTINGS\_MAX\_CONCURRENT\_STREAMS](#SETTINGS_MAX_CONCURRENT_STREAMS) to a value that is below the current
number of open streams can either close streams that exceed the new value or allow
streams to complete.[¶](#section-5.1.2-4)

### [5.2.](#section-5.2) [Flow Control](#name-flow-control)

Using streams for multiplexing introduces contention over use of the TCP connection,
resulting in blocked streams. A flow-control scheme ensures that streams on the same
connection do not destructively interfere with each other. Flow control is used for both
individual streams and the connection as a whole.[¶](#section-5.2-1)

HTTP/2 provides for flow control through use of the [WINDOW\_UPDATE frame](#WINDOW_UPDATE) ([Section 6.9](#WINDOW_UPDATE)).[¶](#section-5.2-2)

#### [5.2.1.](#section-5.2.1) [Flow-Control Principles](#name-flow-control-principles)

HTTP/2 stream flow control aims to allow a variety of flow-control algorithms to be
used without requiring protocol changes. Flow control in HTTP/2 has the following
characteristics:[¶](#section-5.2.1-1)

1. Flow control is specific to a connection. HTTP/2 flow control operates between
   the endpoints of a single hop and not over the entire end-to-end path.[¶](#section-5.2.1-2.1)
2. Flow control is based on [WINDOW\_UPDATE](#WINDOW_UPDATE) frames. Receivers advertise how many octets
   they are prepared to receive on a stream and for the entire connection. This is a
   credit-based scheme.[¶](#section-5.2.1-2.2)
3. Flow control is directional with overall control provided by the receiver. A
   receiver MAY choose to set any window size that it desires for each stream and for
   the entire connection. A sender MUST respect flow-control limits imposed by a
   receiver. Clients, servers, and intermediaries all independently advertise their
   flow-control window as a receiver and abide by the flow-control limits set by
   their peer when sending.[¶](#section-5.2.1-2.3)
4. The initial value for the flow-control window is 65,535 octets for both new streams
   and the overall connection.[¶](#section-5.2.1-2.4)
5. The frame type determines whether flow control applies to a frame. Of the frames
   specified in this document, only [DATA](#DATA) frames are subject to flow
   control; all other frame types do not consume space in the advertised flow-control
   window. This ensures that important control frames are not blocked by flow control.[¶](#section-5.2.1-2.5)
6. An endpoint can choose to disable its own flow control, but an endpoint cannot ignore
   flow-control signals from its peer.[¶](#section-5.2.1-2.6)
7. HTTP/2 defines only the format and semantics of the [WINDOW\_UPDATE](#WINDOW_UPDATE)
   frame ([Section 6.9](#WINDOW_UPDATE)). This document does not stipulate how a
   receiver decides when to send this frame or the value that it sends, nor does it
   specify how a sender chooses to send packets. Implementations are able to select
   any algorithm that suits their needs.[¶](#section-5.2.1-2.7)

Implementations are also responsible for prioritizing the sending of requests and
responses, choosing how to avoid head-of-line blocking for requests, and managing the
creation of new streams. Algorithm choices for these could interact with any
flow-control algorithm.[¶](#section-5.2.1-3)

#### [5.2.2.](#section-5.2.2) [Appropriate Use of Flow Control](#name-appropriate-use-of-flow-con)

Flow control is defined to protect endpoints that are operating under resource
constraints. For example, a proxy needs to share memory between many connections and
also might have a slow upstream connection and a fast downstream one. Flow control
addresses cases where the receiver is unable to process data on one stream yet wants to
continue to process other streams in the same connection.[¶](#section-5.2.2-1)

Deployments that do not require this capability can advertise a flow-control window of
the maximum size (231-1) and can maintain this window by sending a
[WINDOW\_UPDATE](#WINDOW_UPDATE) frame when any data is received. This effectively disables
flow control for that receiver. Conversely, a sender is always subject to the
flow-control window advertised by the receiver.[¶](#section-5.2.2-2)

Deployments with constrained resources (for example, memory) can employ flow control to
limit the amount of memory a peer can consume. Note, however, that this can lead to
suboptimal use of available network resources if flow control is enabled without
knowledge of the bandwidth \* delay product (see [[RFC7323](#RFC7323)]).[¶](#section-5.2.2-3)

Even with full awareness of the current bandwidth \* delay product, implementation of
flow control can be difficult. Endpoints MUST read and process HTTP/2 frames from the
TCP receive buffer as soon as data is available. Failure to read promptly could lead to
a deadlock when critical frames, such as [WINDOW\_UPDATE](#WINDOW_UPDATE), are not read and acted upon. Reading frames promptly
does not expose endpoints to resource exhaustion attacks, as HTTP/2 flow control limits
resource commitments.[¶](#section-5.2.2-4)

#### [5.2.3.](#section-5.2.3) [Flow-Control Performance](#name-flow-control-performance)

If an endpoint cannot ensure that its peer always has available flow-control window
space that is greater than the peer's bandwidth \* delay product on this connection, its
receive throughput will be limited by HTTP/2 flow control. This will result in degraded
performance.[¶](#section-5.2.3-1)

Sending timely [WINDOW\_UPDATE](#WINDOW_UPDATE) frames
can improve performance. Endpoints will want to balance the need to improve receive
throughput with the need to manage resource exhaustion risks and should take careful
note of [Section 10.5](#dos) in defining their strategy to manage window sizes.[¶](#section-5.2.3-2)

### [5.3.](#section-5.3) [Prioritization](#name-prioritization)

In a multiplexed protocol like HTTP/2, prioritizing allocation of bandwidth and
computation resources to streams can be critical to attaining good performance. A poor
prioritization scheme can result in HTTP/2 providing poor performance. With no parallelism
at the TCP layer, performance could be significantly worse than HTTP/1.1.[¶](#section-5.3-1)

A good prioritization scheme benefits from the application of contextual knowledge such as
the content of resources, how resources are interrelated, and how those resources will be
used by a peer. In particular, clients can possess knowledge about the priority of
requests that is relevant to server prioritization. In those cases, having clients
provide priority information can improve performance.[¶](#section-5.3-2)

#### [5.3.1.](#section-5.3.1) [Background on Priority in RFC 7540](#name-background-on-priority-in-r)

RFC 7540 defined a rich system for signaling priority of requests. However, this system
proved to be complex, and it was not uniformly implemented.[¶](#section-5.3.1-1)

The flexible scheme meant that it was possible for clients to express priorities in very
different ways, with little consistency in the approaches that were adopted. For
servers, implementing generic support for the scheme was complex. Implementation of
priorities was uneven in both clients and servers. Many server deployments ignored
client signals when prioritizing their handling of requests.[¶](#section-5.3.1-2)

In short, the prioritization signaling in [RFC 7540](#RFC7540) [[RFC7540](#RFC7540)] was not
successful.[¶](#section-5.3.1-3)

#### [5.3.2.](#section-5.3.2) [Priority Signaling in This Document](#name-priority-signaling-in-this-)

This update to HTTP/2 deprecates the priority signaling defined in [RFC 7540](#RFC7540) [[RFC7540](#RFC7540)]. The bulk of the text related to priority signals is
not included in this document. The description of frame fields and some of the
mandatory handling is retained to ensure that implementations of this document remain
interoperable with implementations that use the priority signaling described in RFC
7540.[¶](#section-5.3.2-1)

A thorough description of the RFC 7540 priority scheme remains in [Section 5.3](https://www.rfc-editor.org/rfc/rfc7540#section-5.3) of [[RFC7540](#RFC7540)].[¶](#section-5.3.2-2)

Signaling priority information is necessary to attain good performance in many cases.
Where signaling priority information is important, endpoints are encouraged to use an
alternative scheme, such as the scheme described in [[HTTP-PRIORITY](#RFC9218)].[¶](#section-5.3.2-3)

Though the priority signaling from RFC 7540 was not widely adopted, the information it
provides can still be useful in the absence of better information. Endpoints that
receive priority signals in [HEADERS](#HEADERS) or [PRIORITY](#PRIORITY) frames can benefit from applying that
information. In particular, implementations that consume these signals would not
benefit from discarding these priority signals in the absence of alternatives.[¶](#section-5.3.2-4)

Servers SHOULD use other contextual information in determining priority of requests in
the absence of any priority signals. Servers MAY interpret the complete absence of
signals as an indication that the client has not implemented the feature. The defaults
described in [Section 5.3.5](https://www.rfc-editor.org/rfc/rfc7540#section-5.3.5) of [[RFC7540](#RFC7540)] are known to have poor performance
under most conditions, and their use is unlikely to be deliberate.[¶](#section-5.3.2-5)

### [5.4.](#section-5.4) [Error Handling](#name-error-handling)

HTTP/2 framing permits two classes of errors:[¶](#section-5.4-1)

* An error condition that renders the entire connection unusable is a connection error.[¶](#section-5.4-2.1)
* An error in an individual stream is a stream error.[¶](#section-5.4-2.2)

A list of error codes is included in [Section 7](#ErrorCodes).[¶](#section-5.4-3)

It is possible that an endpoint will encounter frames that would cause multiple errors. Implementations MAY discover
multiple errors during processing, but they SHOULD report at most one stream and one connection error as a result.[¶](#section-5.4-4)

The first stream error reported for a given stream prevents any other errors on that stream from being reported.
In comparison, the protocol permits multiple [GOAWAY](#GOAWAY) frames, though an
endpoint SHOULD report just one type of connection error unless an error is encountered during graceful shutdown.
If this occurs, an endpoint MAY send an additional GOAWAY frame with the new error code, in addition to any prior
GOAWAY that contained [NO\_ERROR](#NO_ERROR).[¶](#section-5.4-5)

If an endpoint detects multiple different errors, it MAY choose to report any one of those
errors. If a frame causes a connection error, that error MUST be reported. Additionally,
an endpoint MAY use any applicable error code when it detects an error condition; a
generic error code (such as [PROTOCOL\_ERROR](#PROTOCOL_ERROR) or [INTERNAL\_ERROR](#INTERNAL_ERROR)) can always be used in place of more specific error
codes.[¶](#section-5.4-6)

#### [5.4.1.](#section-5.4.1) [Connection Error Handling](#name-connection-error-handling)

A connection error is any error that prevents further processing of the frame
layer or corrupts any connection state.[¶](#section-5.4.1-1)

An endpoint that encounters a connection error SHOULD first send a [GOAWAY](#GOAWAY)
frame ([Section 6.8](#GOAWAY)) with the stream identifier of the last stream that it
successfully received from its peer. The [GOAWAY](#GOAWAY) frame includes an [error
code](#ErrorCodes) ([Section 7](#ErrorCodes)) that indicates why the connection is terminating. After sending the
[GOAWAY](#GOAWAY) frame for an error condition, the endpoint MUST close the TCP
connection.[¶](#section-5.4.1-2)

It is possible that the [GOAWAY](#GOAWAY) will not be reliably received by the
receiving endpoint. In the event of a connection error,
[GOAWAY](#GOAWAY) only provides a best-effort attempt to communicate with the peer
about why the connection is being terminated.[¶](#section-5.4.1-3)

An endpoint can end a connection at any time. In particular, an endpoint MAY choose to
treat a stream error as a connection error. Endpoints SHOULD send a
[GOAWAY](#GOAWAY) frame when ending a connection, providing that circumstances
permit it.[¶](#section-5.4.1-4)

#### [5.4.2.](#section-5.4.2) [Stream Error Handling](#name-stream-error-handling)

A stream error is an error related to a specific stream that does not affect processing
of other streams.[¶](#section-5.4.2-1)

An endpoint that detects a stream error sends a [RST\_STREAM](#RST_STREAM) frame ([Section 6.4](#RST_STREAM)) that contains the stream identifier of the stream where the error
occurred. The [RST\_STREAM](#RST_STREAM) frame includes an error code that indicates the
type of error.[¶](#section-5.4.2-2)

A [RST\_STREAM](#RST_STREAM) is the last frame that an endpoint can send on a stream.
The peer that sends the [RST\_STREAM](#RST_STREAM) frame MUST be prepared to receive any
frames that were sent or enqueued for sending by the remote peer. These frames can be
ignored, except where they modify connection state (such as the state maintained for
[field section compression](#FieldBlock) ([Section 4.3](#FieldBlock)) or flow control).[¶](#section-5.4.2-3)

Normally, an endpoint SHOULD NOT send more than one [RST\_STREAM](#RST_STREAM) frame for
any stream. However, an endpoint MAY send additional [RST\_STREAM](#RST_STREAM) frames if
it receives frames on a closed stream after more than a round-trip time. This behavior
is permitted to deal with misbehaving implementations.[¶](#section-5.4.2-4)

To avoid looping, an endpoint MUST NOT send a [RST\_STREAM](#RST_STREAM) in response to a
[RST\_STREAM](#RST_STREAM) frame.[¶](#section-5.4.2-5)

#### [5.4.3.](#section-5.4.3) [Connection Termination](#name-connection-termination)

If the TCP connection is closed or reset while streams remain in the "open" or "half-closed"
states, then the affected streams cannot be automatically retried (see [Section 8.7](#Reliability) for details).[¶](#section-5.4.3-1)

### [5.5.](#section-5.5) [Extending HTTP/2](#name-extending-http-2)

HTTP/2 permits extension of the protocol. Within the limitations described in this
section, protocol extensions can be used to provide additional services or alter
any aspect of the protocol. Extensions are effective only within the scope of a single HTTP/2
connection.[¶](#section-5.5-1)

This applies to the protocol elements defined in this document. This does not affect the
existing options for extending HTTP, such as defining new methods, status codes, or fields
(see [Section 16](https://www.rfc-editor.org/rfc/rfc9110#section-16) of [[HTTP](#RFC9110)]).[¶](#section-5.5-2)

Extensions are permitted to use new [frame types](#FrameHeader) ([Section 4.1](#FrameHeader)), new
[settings](#SETTINGS) ([Section 6.5](#SETTINGS)), or new [error
codes](#ErrorCodes) ([Section 7](#ErrorCodes)). Registries for managing these extension points are defined in [Section 11](https://www.rfc-editor.org/rfc/rfc7540#section-11) of [[RFC7540](#RFC7540)].[¶](#section-5.5-3)

Implementations MUST ignore unknown or unsupported values in all extensible protocol
elements. Implementations MUST discard frames that have unknown or unsupported types.
This means that any of these extension points can be safely used by extensions without
prior arrangement or negotiation. However, extension frames that appear in the middle of
a [field block](#FieldBlock) ([Section 4.3](#FieldBlock)) are not permitted; these MUST be treated
as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-5.5-4)

Extensions SHOULD avoid changing protocol elements defined in this document or
elements for which no extension mechanism is defined. This includes changes to the
layout of frames, additions or changes to the way that frames are composed into [HTTP messages](#HttpFraming) ([Section 8.1](#HttpFraming)), the definition of pseudo-header fields, or
changes to any protocol element that a compliant endpoint might treat as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)).[¶](#section-5.5-5)

An extension that changes existing protocol elements or state MUST be negotiated before
being used. For example, an extension that changes the layout of the [HEADERS](#HEADERS) frame cannot be used until the peer has
given a positive signal that this is acceptable. In this case, it could also be necessary
to coordinate when the revised layout comes into effect. For example, treating frames
other than [DATA](#DATA) frames as flow controlled
requires a change in semantics that both endpoints need to understand, so this can only be
done through negotiation.[¶](#section-5.5-6)

This document doesn't mandate a specific method for negotiating the use of an extension
but notes that a [setting](#SettingValues) ([Section 6.5.2](#SettingValues)) could be used for that
purpose. If both peers set a value that indicates willingness to use the extension, then
the extension can be used. If a setting is used for extension negotiation, the initial
value MUST be defined in such a fashion that the extension is initially disabled.[¶](#section-5.5-7)

## [6.](#section-6) [Frame Definitions](#name-frame-definitions)

This specification defines a number of frame types, each identified by a unique 8-bit type
code. Each frame type serves a distinct purpose in the establishment and management of either
the connection as a whole or individual streams.[¶](#section-6-1)

The transmission of specific frame types can alter the state of a connection. If endpoints
fail to maintain a synchronized view of the connection state, successful communication
within the connection will no longer be possible. Therefore, it is important that endpoints
have a shared comprehension of how the state is affected by the use of any given frame.[¶](#section-6-2)

### [6.1.](#section-6.1) [DATA](#name-data)

DATA frames (type=0x00) convey arbitrary, variable-length sequences of octets associated
with a stream. One or more DATA frames are used, for instance, to carry HTTP request or
response message contents.[¶](#section-6.1-1)

DATA frames MAY also contain padding. Padding can be added to DATA frames to obscure the
size of messages. Padding is a security feature; see [Section 10.7](#padding).[¶](#section-6.1-2)

```

DATA Frame {
  Length (24),
  Type (8) = 0x00,

  Unused Flags (4),
  PADDED Flag (1),
  Unused Flags (2),
  END_STREAM Flag (1),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  Data (..),
  Padding (..2040),
}

```

[Figure 3](#figure-3):
[DATA Frame Format](#name-data-frame-format)

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in [Section 4](#FramingLayer).
The DATA frame contains the following additional fields:[¶](#section-6.1-4)

Pad Length:
An 8-bit field containing the length of the frame padding in units of octets. This
field is conditional and is only present if the PADDED flag is set.[¶](#section-6.1-5.2)

Data:
Application data. The amount of data is the remainder of the frame payload after
subtracting the length of the other fields that are present.[¶](#section-6.1-5.4)

Padding:
Padding octets that contain no application semantic value. Padding octets MUST be set
to zero when sending. A receiver is not obligated to verify padding but MAY treat
non-zero padding as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of
type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.1-5.6)

The DATA frame defines the following flags:[¶](#section-6.1-6)

PADDED (0x08):
When set, the PADDED flag indicates that the Pad Length field and any padding that it describes
are present.[¶](#section-6.1-7.2)

END\_STREAM (0x01):
When set, the END\_STREAM flag indicates that this frame is the last that the endpoint will send for
the identified stream. Setting this flag causes the stream to enter one of [the "half-closed" states or the "closed" state](#StreamStates) ([Section 5.1](#StreamStates)).[¶](#section-6.1-7.4)

Note: An endpoint that learns of stream closure after sending all data can close a
stream by sending a STREAM frame with a zero-length Data field and the END\_STREAM flag
set. This is only possible if the endpoint does not send trailers, as the END\_STREAM
flag appears on a HEADERS frame in that case; see [Section 8.1](#HttpFraming).[¶](#section-6.1-8.1)

DATA frames MUST be associated with a stream. If a DATA frame is received whose Stream
Identifier field is 0x00, the recipient MUST respond with a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.1-9)

DATA frames are subject to flow control and can only be sent when a stream is in the
"open" or "half-closed (remote)" state. The entire DATA frame payload is included in flow
control, including the Pad Length and Padding fields if present. If a DATA frame is received
whose stream is not in the "open" or "half-closed (local)" state, the recipient MUST respond
with a [stream error](#StreamErrorHandler) ([Section 5.4.2](#StreamErrorHandler)) of type
[STREAM\_CLOSED](#STREAM_CLOSED).[¶](#section-6.1-10)

The total number of padding octets is determined by the value of the Pad Length field. If
the length of the padding is the length of the frame payload or greater, the recipient
MUST treat this as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of
type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.1-11)

Note:
A frame can be increased in size by one octet by including a Pad Length field with a
value of zero.[¶](#section-6.1-12.1)

### [6.2.](#section-6.2) [HEADERS](#name-headers)

The HEADERS frame (type=0x01) is used to [open a stream](#StreamStates) ([Section 5.1](#StreamStates)),
and additionally carries a field block fragment. Despite the name, a HEADERS frame can carry
a header section or a trailer section. HEADERS frames can be sent on a stream
in the "idle", "reserved (local)", "open", or "half-closed (remote)" state.[¶](#section-6.2-1)

```

HEADERS Frame {
  Length (24),
  Type (8) = 0x01,

  Unused Flags (2),
  PRIORITY Flag (1),
  Unused Flag (1),
  PADDED Flag (1),
  END_HEADERS Flag (1),
  Unused Flag (1),
  END_STREAM Flag (1),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  [Exclusive (1)],
  [Stream Dependency (31)],
  [Weight (8)],
  Field Block Fragment (..),
  Padding (..2040),
}

```

[Figure 4](#figure-4):
[HEADERS Frame Format](#name-headers-frame-format)

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in [Section 4](#FramingLayer).
The HEADERS frame payload has the following additional fields:[¶](#section-6.2-3)

Pad Length:
An 8-bit field containing the length of the frame padding in units of octets. This
field is only present if the PADDED flag is set.[¶](#section-6.2-4.2)

Exclusive:
A single-bit flag. This field is only present if the PRIORITY flag is set. Priority
signals in HEADERS frames are deprecated; see [Section 5.3.2](#PriorityHere).[¶](#section-6.2-4.4)

Stream Dependency:
A 31-bit stream identifier. This field is only present if the PRIORITY flag is set.[¶](#section-6.2-4.6)

Weight:
An unsigned 8-bit integer. This field is only present if the PRIORITY flag is set.[¶](#section-6.2-4.8)

Field Block Fragment:
A [field block fragment](#FieldBlock) ([Section 4.3](#FieldBlock)).[¶](#section-6.2-4.10)

Padding:
Padding octets that contain no application semantic value. Padding octets MUST be set
to zero when sending. A receiver is not obligated to verify padding but MAY treat
non-zero padding as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of
type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.2-4.12)

The HEADERS frame defines the following flags:[¶](#section-6.2-5)

PRIORITY (0x20):

When set, the PRIORITY flag indicates that the Exclusive, Stream Dependency, and Weight
fields are present.[¶](#section-6.2-6.2.1)

PADDED (0x08):

When set, the PADDED flag indicates that the Pad Length field and any padding that it
describes are present.[¶](#section-6.2-6.4.1)

END\_HEADERS (0x04):

When set, the END\_HEADERS flag indicates that this frame contains an entire [field block](#FieldBlock) ([Section 4.3](#FieldBlock)) and is not followed by any
[CONTINUATION](#CONTINUATION) frames.[¶](#section-6.2-6.6.1)

A HEADERS frame without the END\_HEADERS flag set MUST be followed by a
[CONTINUATION](#CONTINUATION) frame for the same stream. A receiver MUST treat the
receipt of any other type of frame or a frame on a different stream as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.2-6.6.2)

END\_STREAM (0x01):

When set, the END\_STREAM flag indicates that the [field block](#FieldBlock) ([Section 4.3](#FieldBlock)) is
the last that the endpoint will send for the identified stream.[¶](#section-6.2-6.8.1)

A HEADERS frame with the END\_STREAM flag set signals the end of a stream.
However, a HEADERS frame with the END\_STREAM flag set can be followed by
[CONTINUATION](#CONTINUATION) frames on the same stream. Logically, the
[CONTINUATION](#CONTINUATION) frames are part of the HEADERS frame.[¶](#section-6.2-6.8.2)

The frame payload of a HEADERS frame contains a [field block
fragment](#FieldBlock) ([Section 4.3](#FieldBlock)). A field block that does not fit within a HEADERS frame is continued in
a [CONTINUATION frame](#CONTINUATION) ([Section 6.10](#CONTINUATION)).[¶](#section-6.2-7)

HEADERS frames MUST be associated with a stream. If a HEADERS frame is received whose
Stream Identifier field is 0x00, the recipient MUST respond with a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.2-8)

The HEADERS frame changes the connection state as described in [Section 4.3](#FieldBlock).[¶](#section-6.2-9)

The total number of padding octets is determined by the value of the Pad Length field. If
the length of the padding is the length of the frame payload or greater, the recipient
MUST treat this as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of
type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.2-10)

Note:
A frame can be increased in size by one octet by including a Pad Length field with a
value of zero.[¶](#section-6.2-11.1)

### [6.3.](#section-6.3) [PRIORITY](#name-priority)

The PRIORITY frame (type=0x02) is deprecated; see [Section 5.3.2](#PriorityHere). A
PRIORITY frame can be sent in any stream state, including idle or closed streams.[¶](#section-6.3-1)

```

PRIORITY Frame {
  Length (24) = 0x05,
  Type (8) = 0x02,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Exclusive (1),
  Stream Dependency (31),
  Weight (8),
}

```

[Figure 5](#figure-5):
[PRIORITY Frame Format](#name-priority-frame-format)

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in [Section 4](#FramingLayer).
The frame payload of a PRIORITY frame contains the following additional fields:[¶](#section-6.3-3)

Exclusive:
A single-bit flag.[¶](#section-6.3-4.2)

Stream Dependency:
A 31-bit stream identifier.[¶](#section-6.3-4.4)

Weight:
An unsigned 8-bit integer.[¶](#section-6.3-4.6)

The PRIORITY frame does not define any flags.[¶](#section-6.3-5)

The PRIORITY frame always identifies a stream. If a PRIORITY frame is received with a
stream identifier of 0x00, the recipient MUST respond with a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.3-6)

Sending or receiving a PRIORITY frame does not affect the state of any stream ([Section 5.1](#StreamStates)). The PRIORITY frame can be sent on a stream in any state,
including "idle" or "closed". A PRIORITY frame cannot be sent between consecutive frames
that comprise a single [field block](#FieldBlock) ([Section 4.3](#FieldBlock)).[¶](#section-6.3-7)

A PRIORITY frame with a length other than 5 octets MUST be treated as a [stream error](#StreamErrorHandler) ([Section 5.4.2](#StreamErrorHandler)) of type [FRAME\_SIZE\_ERROR](#FRAME_SIZE_ERROR).[¶](#section-6.3-8)

### [6.4.](#section-6.4) [RST\_STREAM](#name-rst_stream)

The RST\_STREAM frame (type=0x03) allows for immediate termination of a stream. RST\_STREAM
is sent to request cancellation of a stream or to indicate that an error condition has
occurred.[¶](#section-6.4-1)

```

RST_STREAM Frame {
  Length (24) = 0x04,
  Type (8) = 0x03,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Error Code (32),
}

```

[Figure 6](#figure-6):
[RST\_STREAM Frame Format](#name-rst_stream-frame-format)

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in [Section 4](#FramingLayer).
Additionally, the RST\_STREAM frame contains a single unsigned, 32-bit integer identifying the [error code](#ErrorCodes) ([Section 7](#ErrorCodes)). The error code indicates why the stream is being
terminated.[¶](#section-6.4-3)

The RST\_STREAM frame does not define any flags.[¶](#section-6.4-4)

The RST\_STREAM frame fully terminates the referenced stream and causes it to enter the
"closed" state. After receiving a RST\_STREAM on a stream, the receiver MUST NOT send
additional frames for that stream, except for [PRIORITY](#PRIORITY). However,
after sending the RST\_STREAM, the sending endpoint MUST be prepared to receive and process
additional frames sent on the stream that might have been sent by the peer prior to the
arrival of the RST\_STREAM.[¶](#section-6.4-5)

RST\_STREAM frames MUST be associated with a stream. If a RST\_STREAM frame is received
with a stream identifier of 0x00, the recipient MUST treat this as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.4-6)

RST\_STREAM frames MUST NOT be sent for a stream in the "idle" state. If a RST\_STREAM
frame identifying an idle stream is received, the recipient MUST treat this as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.4-7)

A RST\_STREAM frame with a length other than 4 octets MUST be treated as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[FRAME\_SIZE\_ERROR](#FRAME_SIZE_ERROR).[¶](#section-6.4-8)

### [6.5.](#section-6.5) [SETTINGS](#name-settings)

The SETTINGS frame (type=0x04) conveys configuration parameters that affect how endpoints
communicate, such as preferences and constraints on peer behavior. The SETTINGS frame is
also used to acknowledge the receipt of those settings. Individually, a configuration
parameter from a SETTINGS frame is referred to as a "setting".[¶](#section-6.5-1)

Settings are not negotiated; they describe characteristics of the sending peer,
which are used by the receiving peer. Different values for the same setting can be
advertised by each peer. For example, a client might set a high initial flow-control
window, whereas a server might set a lower value to conserve resources.[¶](#section-6.5-2)

A SETTINGS frame MUST be sent by both endpoints at the start of a connection and MAY be
sent at any other time by either endpoint over the lifetime of the connection.
Implementations MUST support all of the settings defined by this specification.[¶](#section-6.5-3)

Each parameter in a SETTINGS frame replaces any existing value for that parameter.
Settings are processed in the order in which they appear, and a receiver of a SETTINGS
frame does not need to maintain any state other than the current value of each setting.
Therefore, the value of a SETTINGS parameter is the last value that is seen by
a receiver.[¶](#section-6.5-4)

SETTINGS frames are acknowledged by the receiving peer. To enable this, the SETTINGS
frame defines the ACK flag:[¶](#section-6.5-5)

ACK (0x01):
When set, the ACK flag indicates that this frame acknowledges receipt and application of the
peer's SETTINGS frame. When this bit is set, the frame payload of the SETTINGS frame MUST
be empty. Receipt of a SETTINGS frame with the ACK flag set and a length field value
other than 0 MUST be treated as a [connection
error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type [FRAME\_SIZE\_ERROR](#FRAME_SIZE_ERROR). For more information, see [Section 6.5.3](#SettingsSync) ("[Settings Synchronization](#SettingsSync)").[¶](#section-6.5-6.2)

SETTINGS frames always apply to a connection, never a single stream. The stream
identifier for a SETTINGS frame MUST be zero (0x00). If an endpoint receives a SETTINGS
frame whose Stream Identifier field is anything other than 0x00, the endpoint MUST respond
with a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.5-7)

The SETTINGS frame affects connection state. A badly formed or incomplete SETTINGS frame
MUST be treated as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.5-8)

A SETTINGS frame with a length other than a multiple of 6 octets MUST be treated as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[FRAME\_SIZE\_ERROR](#FRAME_SIZE_ERROR).[¶](#section-6.5-9)

#### [6.5.1.](#section-6.5.1) [SETTINGS Format](#name-settings-format)

The frame payload of a SETTINGS frame consists of zero or more settings, each consisting of
an unsigned 16-bit setting identifier and an unsigned 32-bit value.[¶](#section-6.5.1-1)

```

SETTINGS Frame {
  Length (24),
  Type (8) = 0x04,

  Unused Flags (7),
  ACK Flag (1),

  Reserved (1),
  Stream Identifier (31) = 0,

  Setting (48) ...,
}

Setting {
  Identifier (16),
  Value (32),
}

```

[Figure 7](#figure-7):
[SETTINGS Frame Format](#name-settings-frame-format)

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described
in [Section 4](#FramingLayer). The frame payload of a SETTINGS frame contains any
number of Setting fields, each of which consists of:[¶](#section-6.5.1-3)

Identifier:
A 16-bit setting identifier; see [Section 6.5.2](#SettingValues).[¶](#section-6.5.1-4.2)

Value:
A 32-bit value for the setting.[¶](#section-6.5.1-4.4)

#### [6.5.2.](#section-6.5.2) [Defined Settings](#name-defined-settings)

The following settings are defined:[¶](#section-6.5.2-1)

SETTINGS\_HEADER\_TABLE\_SIZE (0x01):

This setting allows the sender to inform the remote endpoint of the maximum size of the
compression table used to decode field blocks, in units of octets. The encoder can select
any size equal to or less than this value by using signaling specific to the
compression format inside a field block (see [[COMPRESSION](#RFC7541)]). The initial value is 4,096 octets.[¶](#section-6.5.2-2.2.1)

SETTINGS\_ENABLE\_PUSH (0x02):

This setting can be used to enable or disable server push. A server MUST NOT send a
[PUSH\_PROMISE](#PUSH_PROMISE) frame if it receives
this parameter set to a value of 0; see [Section 8.4](#PushResources). A client
that has both set this parameter to 0 and had it acknowledged MUST treat the receipt
of a [PUSH\_PROMISE](#PUSH_PROMISE) frame as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.5.2-2.4.1)

The initial value of SETTINGS\_ENABLE\_PUSH is 1. For a client, this value indicates that it
is willing to receive PUSH\_PROMISE frames. For a server, this initial value has no effect, and
is equivalent to the value 0. Any value other than 0 or 1 MUST be treated as a
[connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.5.2-2.4.2)

A server MUST NOT explicitly set this value to 1. A server MAY choose to omit this
setting when it sends a SETTINGS frame, but if a server does include a value, it MUST
be 0. A client MUST treat receipt of a SETTINGS frame with SETTINGS\_ENABLE\_PUSH set
to 1 as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.5.2-2.4.3)

SETTINGS\_MAX\_CONCURRENT\_STREAMS (0x03):

This setting indicates the maximum number of concurrent streams that the sender will allow.
This limit is directional: it applies to the number of streams that the sender
permits the receiver to create. Initially, there is no limit to this value. It is
recommended that this value be no smaller than 100, so as to not unnecessarily
limit parallelism.[¶](#section-6.5.2-2.6.1)

A value of 0 for SETTINGS\_MAX\_CONCURRENT\_STREAMS SHOULD NOT be treated as special
by endpoints. A zero value does prevent the creation of new streams; however, this
can also happen for any limit that is exhausted with active streams. Servers
SHOULD only set a zero value for short durations; if a server does not wish to
accept requests, closing the connection is more appropriate.[¶](#section-6.5.2-2.6.2)

SETTINGS\_INITIAL\_WINDOW\_SIZE (0x04):

This setting indicates the sender's initial window size (in units of octets) for stream-level flow
control. The initial value is 216-1 (65,535) octets.[¶](#section-6.5.2-2.8.1)

This setting affects the window size of all streams (see [Section 6.9.2](#InitialWindowSize)).[¶](#section-6.5.2-2.8.2)

Values above the maximum flow-control window size of 231-1 MUST
be treated as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of
type [FLOW\_CONTROL\_ERROR](#FLOW_CONTROL_ERROR).[¶](#section-6.5.2-2.8.3)

SETTINGS\_MAX\_FRAME\_SIZE (0x05):

This setting indicates the size of the largest frame payload that the sender is willing to
receive, in units of octets.[¶](#section-6.5.2-2.10.1)

The initial value is 214 (16,384) octets. The value advertised by
an endpoint MUST be between this initial value and the maximum allowed frame size
(224-1 or 16,777,215 octets), inclusive. Values outside this range
MUST be treated as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler))
of type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.5.2-2.10.2)

SETTINGS\_MAX\_HEADER\_LIST\_SIZE (0x06):

This advisory setting informs a peer of the maximum field section size that the
sender is prepared to accept, in units of octets. The value is based on the uncompressed
size of field lines, including the length of the name and value in units of octets plus
an overhead of 32 octets for each field line.[¶](#section-6.5.2-2.12.1)

For any given request, a lower limit than what is advertised MAY be enforced. The
initial value of this setting is unlimited.[¶](#section-6.5.2-2.12.2)

An endpoint that receives a SETTINGS frame with any unknown or unsupported identifier
MUST ignore that setting.[¶](#section-6.5.2-3)

#### [6.5.3.](#section-6.5.3) [Settings Synchronization](#name-settings-synchronization)

Most values in SETTINGS benefit from or require an understanding of when the peer has
received and applied the changed parameter values. In order to provide such
synchronization timepoints, the recipient of a SETTINGS frame in which the ACK flag is
not set MUST apply the updated settings as soon as possible upon receipt. SETTINGS
frames are acknowledged in the order in which they are received.[¶](#section-6.5.3-1)

The values in the SETTINGS frame MUST be processed in the order they appear, with no
other frame processing between values. Unsupported settings MUST be ignored. Once
all values have been processed, the recipient MUST immediately emit a SETTINGS frame
with the ACK flag set. Upon receiving a SETTINGS frame with the ACK flag set, the sender
of the altered settings can rely on the values from the oldest unacknowledged SETTINGS frame
having been applied.[¶](#section-6.5.3-2)

If the sender of a SETTINGS frame does not receive an acknowledgment within a
reasonable amount of time, it MAY issue a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type [SETTINGS\_TIMEOUT](#SETTINGS_TIMEOUT). In setting a timeout,
some allowance needs to be made for processing delays at the peer; a timeout that is
solely based on the round-trip time between endpoints might result in spurious errors.[¶](#section-6.5.3-3)

### [6.6.](#section-6.6) [PUSH\_PROMISE](#name-push_promise)

The PUSH\_PROMISE frame (type=0x05) is used to notify the peer endpoint in advance of
streams the sender intends to initiate. The PUSH\_PROMISE frame includes the unsigned
31-bit identifier of the stream the endpoint plans to create along with a field section
that provides additional context for the stream. [Section 8.4](#PushResources) contains a
thorough description of the use of PUSH\_PROMISE frames.[¶](#section-6.6-1)

```

PUSH_PROMISE Frame {
  Length (24),
  Type (8) = 0x05,

  Unused Flags (4),
  PADDED Flag (1),
  END_HEADERS Flag (1),
  Unused Flags (2),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  Reserved (1),
  Promised Stream ID (31),
  Field Block Fragment (..),
  Padding (..2040),
}

```

[Figure 8](#figure-8):
[PUSH\_PROMISE Frame Format](#name-push_promise-frame-format)

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in [Section 4](#FramingLayer).
The PUSH\_PROMISE frame payload has the following additional fields:[¶](#section-6.6-3)

Pad Length:
An 8-bit field containing the length of the frame padding in units of octets. This
field is only present if the PADDED flag is set.[¶](#section-6.6-4.2)

Promised Stream ID:
An unsigned 31-bit integer that identifies the stream that is reserved by the
PUSH\_PROMISE. The promised stream identifier MUST be a valid choice for the next
stream sent by the sender (see "new stream identifier" in [Section 5.1.1](#StreamIdentifiers)).[¶](#section-6.6-4.4)

Field Block Fragment:
A [field block fragment](#FieldBlock) ([Section 4.3](#FieldBlock)) containing the request control
data and a header section.[¶](#section-6.6-4.6)

Padding:
Padding octets that contain no application semantic value. Padding octets MUST be set
to zero when sending. A receiver is not obligated to verify padding but MAY treat
non-zero padding as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of
type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.6-4.8)

The PUSH\_PROMISE frame defines the following flags:[¶](#section-6.6-5)

PADDED (0x08):

When set, the PADDED flag indicates that the Pad Length field and any padding that it
describes are present.[¶](#section-6.6-6.2.1)

END\_HEADERS (0x04):

When set, the END\_HEADERS flag indicates that this frame contains an entire [field block](#FieldBlock) ([Section 4.3](#FieldBlock)) and is not followed by any
[CONTINUATION](#CONTINUATION) frames.[¶](#section-6.6-6.4.1)

A PUSH\_PROMISE frame without the END\_HEADERS flag set MUST be followed by a
CONTINUATION frame for the same stream. A receiver MUST treat the receipt of any
other type of frame or a frame on a different stream as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.6-6.4.2)

PUSH\_PROMISE frames MUST only be sent on a peer-initiated stream that is in either the
"open" or "half-closed (remote)" state. The stream identifier of a PUSH\_PROMISE frame
indicates the stream it is associated with. If the Stream Identifier field specifies the
value 0x00, a recipient MUST respond with a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.6-7)

Promised streams are not required to be used in the order they are promised. The
PUSH\_PROMISE only reserves stream identifiers for later use.[¶](#section-6.6-8)

PUSH\_PROMISE MUST NOT be sent if the [SETTINGS\_ENABLE\_PUSH](#SETTINGS_ENABLE_PUSH) setting of the
peer endpoint is set to 0. An endpoint that has set this setting and has received
acknowledgment MUST treat the receipt of a PUSH\_PROMISE frame as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.6-9)

Recipients of PUSH\_PROMISE frames can choose to reject promised streams by returning a
[RST\_STREAM](#RST_STREAM) referencing the promised stream identifier back to the sender of
the PUSH\_PROMISE.[¶](#section-6.6-10)

A PUSH\_PROMISE frame modifies the connection state in two ways. First, the inclusion of a [field block](#FieldBlock) ([Section 4.3](#FieldBlock)) potentially modifies the state maintained for
field section compression. Second, PUSH\_PROMISE also reserves a stream for later use, causing the
promised stream to enter the "reserved (local)" or "reserved (remote)" state. A sender MUST NOT send a PUSH\_PROMISE on a
stream unless that stream is either "open" or "half-closed (remote)"; the sender MUST
ensure that the promised stream is a valid choice for a [new stream identifier](#StreamIdentifiers) ([Section 5.1.1](#StreamIdentifiers)) (that is, the promised stream MUST
be in the "idle" state).[¶](#section-6.6-11)

Since PUSH\_PROMISE reserves a stream, ignoring a PUSH\_PROMISE frame causes the stream
state to become indeterminate. A receiver MUST treat the receipt of a PUSH\_PROMISE on a
stream that is neither "open" nor "half-closed (local)" as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR). However, an endpoint that has sent
[RST\_STREAM](#RST_STREAM) on the associated stream MUST handle PUSH\_PROMISE frames that
might have been created before the [RST\_STREAM](#RST_STREAM) frame is received and
processed.[¶](#section-6.6-12)

A receiver MUST treat the receipt of a PUSH\_PROMISE that promises an [illegal stream identifier](#StreamIdentifiers) ([Section 5.1.1](#StreamIdentifiers)) as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR). Note that an illegal stream identifier
is an identifier for a stream that is not currently in the "idle" state.[¶](#section-6.6-13)

The total number of padding octets is determined by the value of the Pad Length field. If
the length of the padding is the length of the frame payload or greater, the recipient
MUST treat this as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of
type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.6-14)

Note:
A frame can be increased in size by one octet by including a Pad Length field with a
value of zero.[¶](#section-6.6-15.1)

### [6.7.](#section-6.7) [PING](#name-ping)

The PING frame (type=0x06) is a mechanism for measuring a minimal round-trip time from the
sender, as well as determining whether an idle connection is still functional. PING
frames can be sent from any endpoint.[¶](#section-6.7-1)

```

PING Frame {
  Length (24) = 0x08,
  Type (8) = 0x06,

  Unused Flags (7),
  ACK Flag (1),

  Reserved (1),
  Stream Identifier (31) = 0,

  Opaque Data (64),
}

```

[Figure 9](#figure-9):
[PING Frame Format](#name-ping-frame-format)

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in [Section 4](#FramingLayer).[¶](#section-6.7-3)

In addition to the frame header, PING frames MUST contain 8 octets of opaque data in the frame payload.
A sender can include any value it chooses and use those octets in any fashion.[¶](#section-6.7-4)

Receivers of a PING frame that does not include an ACK flag MUST send a PING frame with
the ACK flag set in response, with an identical frame payload. PING responses SHOULD be given
higher priority than any other frame.[¶](#section-6.7-5)

The PING frame defines the following flags:[¶](#section-6.7-6)

ACK (0x01):
When set, the ACK flag indicates that this PING frame is a PING response. An endpoint MUST
set this flag in PING responses. An endpoint MUST NOT respond to PING frames
containing this flag.[¶](#section-6.7-7.2)

PING frames are not associated with any individual stream. If a PING frame is received
with a Stream Identifier field value other than 0x00, the recipient MUST respond with a
[connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.7-8)

Receipt of a PING frame with a length field value other than 8 MUST be treated as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[FRAME\_SIZE\_ERROR](#FRAME_SIZE_ERROR).[¶](#section-6.7-9)

### [6.8.](#section-6.8) [GOAWAY](#name-goaway)

The GOAWAY frame (type=0x07) is used to initiate shutdown of a connection or to signal
serious error conditions. GOAWAY allows an endpoint to gracefully stop accepting new
streams while still finishing processing of previously established streams. This enables
administrative actions, like server maintenance.[¶](#section-6.8-1)

There is an inherent race condition between an endpoint starting new streams and the
remote peer sending a GOAWAY frame. To deal with this case, the GOAWAY contains the stream
identifier of the last peer-initiated stream that was or might be processed on the
sending endpoint in this connection. For instance, if the server sends a GOAWAY frame,
the identified stream is the highest-numbered stream initiated by the client.[¶](#section-6.8-2)

Once the GOAWAY is sent, the sender will ignore frames sent on streams initiated by the
receiver if the stream has an identifier higher than the included last stream identifier.
Receivers of a GOAWAY frame MUST NOT open additional streams on the connection, although a
new connection can be established for new streams.[¶](#section-6.8-3)

If the receiver of the GOAWAY has sent data on streams with a higher stream identifier
than what is indicated in the GOAWAY frame, those streams are not or will not be
processed. The receiver of the GOAWAY frame can treat the streams as though they had
never been created at all, thereby allowing those streams to be retried later on a new
connection.[¶](#section-6.8-4)

Endpoints SHOULD always send a GOAWAY frame before closing a connection so that the remote
peer can know whether a stream has been partially processed or not. For example, if an
HTTP client sends a POST at the same time that a server closes a connection, the client
cannot know if the server started to process that POST request if the server does not send
a GOAWAY frame to indicate what streams it might have acted on.[¶](#section-6.8-5)

An endpoint might choose to close a connection without sending a GOAWAY for misbehaving
peers.[¶](#section-6.8-6)

A GOAWAY frame might not immediately precede closing of the connection; a receiver of a
GOAWAY that has no more use for the connection SHOULD still send a GOAWAY frame before
terminating the connection.[¶](#section-6.8-7)

```

GOAWAY Frame {
  Length (24),
  Type (8) = 0x07,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31) = 0,

  Reserved (1),
  Last-Stream-ID (31),
  Error Code (32),
  Additional Debug Data (..),
}

```

[Figure 10](#figure-10):
[GOAWAY Frame Format](#name-goaway-frame-format)

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in [Section 4](#FramingLayer).[¶](#section-6.8-9)

The GOAWAY frame does not define any flags.[¶](#section-6.8-10)

The GOAWAY frame applies to the connection, not a specific stream. An endpoint MUST treat
a [GOAWAY](#GOAWAY) frame with a stream identifier other than 0x00 as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.8-11)

The last stream identifier in the GOAWAY frame contains the highest-numbered stream
identifier for which the sender of the GOAWAY frame might have taken some action on or
might yet take action on. All streams up to and including the identified stream might
have been processed in some way. The last stream identifier can be set to 0 if no streams
were processed.[¶](#section-6.8-12)

Note:
In this context, "processed" means that some data from the stream was passed to some
higher layer of software that might have taken some action as a result.[¶](#section-6.8-13.1)

If a connection terminates without a GOAWAY frame, the last stream identifier is
effectively the highest possible stream identifier.[¶](#section-6.8-14)

On streams with lower- or equal-numbered identifiers that were not closed completely prior
to the connection being closed, reattempting requests, transactions, or any protocol
activity is not possible, except for idempotent actions like HTTP GET, PUT, or
DELETE. Any protocol activity that uses higher-numbered streams can be safely retried
using a new connection.[¶](#section-6.8-15)

Activity on streams numbered lower than or equal to the last stream identifier might still
complete successfully. The sender of a GOAWAY frame might gracefully shut down a
connection by sending a GOAWAY frame, maintaining the connection in an "open" state until
all in-progress streams complete.[¶](#section-6.8-16)

An endpoint MAY send multiple GOAWAY frames if circumstances change. For instance, an
endpoint that sends GOAWAY with [NO\_ERROR](#NO_ERROR) during graceful shutdown could
subsequently encounter a condition that requires immediate termination of the connection.
The last stream identifier from the last GOAWAY frame received indicates which streams
could have been acted upon. Endpoints MUST NOT increase the value they send in the last
stream identifier, since the peers might already have retried unprocessed requests on
another connection.[¶](#section-6.8-17)

A client that is unable to retry requests loses all requests that are in flight when the
server closes the connection. This is especially true for intermediaries that might not
be serving clients using HTTP/2. A server that is attempting to gracefully shut down a
connection SHOULD send an initial GOAWAY frame with the last stream identifier set to
231-1 and a [NO\_ERROR](#NO_ERROR) code. This signals to the client that
a shutdown is imminent and that initiating further requests is prohibited. After allowing
time for any in-flight stream creation (at least one round-trip time), the server MAY
send another GOAWAY frame with an updated last stream identifier. This ensures that a
connection can be cleanly shut down without losing requests.[¶](#section-6.8-18)

After sending a GOAWAY frame, the sender can discard frames for streams initiated by the
receiver with identifiers higher than the identified last stream. However, any frames
that alter connection state cannot be completely ignored. For instance,
[HEADERS](#HEADERS), [PUSH\_PROMISE](#PUSH_PROMISE), and [CONTINUATION](#CONTINUATION) frames
MUST be minimally processed to ensure that the state maintained for field section compression is
consistent (see [Section 4.3](#FieldBlock)); similarly, DATA frames MUST be counted
toward the connection flow-control window. Failure to process these frames can cause flow
control or field section compression state to become unsynchronized.[¶](#section-6.8-19)

The GOAWAY frame also contains a 32-bit [error code](#ErrorCodes) ([Section 7](#ErrorCodes)) that
contains the reason for closing the connection.[¶](#section-6.8-20)

Endpoints MAY append opaque data to the frame payload of any GOAWAY frame. Additional debug
data is intended for diagnostic purposes only and carries no semantic value. Debug
information could contain security- or privacy-sensitive data. Logged or otherwise
persistently stored debug data MUST have adequate safeguards to prevent unauthorized
access.[¶](#section-6.8-21)

### [6.9.](#section-6.9) [WINDOW\_UPDATE](#name-window_update)

The WINDOW\_UPDATE frame (type=0x08) is used to implement flow control; see [Section 5.2](#FlowControl) for an overview.[¶](#section-6.9-1)

Flow control operates at two levels: on each individual stream and on the entire
connection.[¶](#section-6.9-2)

Both types of flow control are hop by hop, that is, only between the two endpoints.
Intermediaries do not forward WINDOW\_UPDATE frames between dependent connections.
However, throttling of data transfer by any receiver can indirectly cause the propagation
of flow-control information toward the original sender.[¶](#section-6.9-3)

Flow control only applies to frames that are identified as being subject to flow control.
Of the frame types defined in this document, this includes only [DATA](#DATA) frames.
Frames that are exempt from flow control MUST be accepted and processed, unless the
receiver is unable to assign resources to handling the frame. A receiver MAY respond with
a [stream error](#StreamErrorHandler) ([Section 5.4.2](#StreamErrorHandler)) or [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[FLOW\_CONTROL\_ERROR](#FLOW_CONTROL_ERROR) if it is unable to accept a frame.[¶](#section-6.9-4)

```

WINDOW_UPDATE Frame {
  Length (24) = 0x04,
  Type (8) = 0x08,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Reserved (1),
  Window Size Increment (31),
}

```

[Figure 11](#figure-11):
[WINDOW\_UPDATE Frame Format](#name-window_update-frame-format)

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in [Section 4](#FramingLayer).
The frame payload of a WINDOW\_UPDATE frame is one reserved bit plus an unsigned 31-bit integer
indicating the number of octets that the sender can transmit in addition to the existing
flow-control window. The legal range for the increment to the flow-control window is 1 to
231-1 (2,147,483,647) octets.[¶](#section-6.9-6)

The WINDOW\_UPDATE frame does not define any flags.[¶](#section-6.9-7)

The WINDOW\_UPDATE frame can be specific to a stream or to the entire connection. In the
former case, the frame's stream identifier indicates the affected stream; in the latter,
the value "0" indicates that the entire connection is the subject of the frame.[¶](#section-6.9-8)

A receiver MUST treat the receipt of a WINDOW\_UPDATE frame with a flow-control window
increment of 0 as a [stream error](#StreamErrorHandler) ([Section 5.4.2](#StreamErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR); errors on the connection flow-control window MUST be
treated as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)).[¶](#section-6.9-9)

WINDOW\_UPDATE can be sent by a peer that has sent a frame with the END\_STREAM flag set.
This means that a receiver could receive a WINDOW\_UPDATE frame on a stream in a "half-closed (remote)"
or "closed" state. A receiver MUST NOT treat this as an error (see [Section 5.1](#StreamStates)).[¶](#section-6.9-10)

A receiver that receives a flow-controlled frame MUST always account for its contribution
against the connection flow-control window, unless the receiver treats this as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)). This is necessary even if the
frame is in error. The sender counts the frame toward the flow-control window, but if
the receiver does not, the flow-control window at the sender and receiver can become
different.[¶](#section-6.9-11)

A WINDOW\_UPDATE frame with a length other than 4 octets MUST be treated as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[FRAME\_SIZE\_ERROR](#FRAME_SIZE_ERROR).[¶](#section-6.9-12)

#### [6.9.1.](#section-6.9.1) [The Flow-Control Window](#name-the-flow-control-window)

Flow control in HTTP/2 is implemented using a window kept by each sender on every
stream. The flow-control window is a simple integer value that indicates how many octets
of data the sender is permitted to transmit; as such, its size is a measure of the
buffering capacity of the receiver.[¶](#section-6.9.1-1)

Two flow-control windows are applicable: the stream flow-control window and the
connection flow-control window. The sender MUST NOT send a flow-controlled frame with a
length that exceeds the space available in either of the flow-control windows advertised
by the receiver. Frames with zero length with the END\_STREAM flag set (that is, an
empty [DATA](#DATA) frame) MAY be sent if there is no available space in either
flow-control window.[¶](#section-6.9.1-2)

For flow-control calculations, the 9-octet frame header is not counted.[¶](#section-6.9.1-3)

After sending a flow-controlled frame, the sender reduces the space available in both
windows by the length of the transmitted frame.[¶](#section-6.9.1-4)

The receiver of a frame sends a WINDOW\_UPDATE frame as it consumes data and frees up
space in flow-control windows. Separate WINDOW\_UPDATE frames are sent for the stream-
and connection-level flow-control windows. Receivers are advised to have mechanisms in
place to avoid sending WINDOW\_UPDATE frames with very small increments; see [Section 4.2.3.3](https://www.rfc-editor.org/rfc/rfc1122#section-4.2.3.3) of [[RFC1122](#RFC1122)].[¶](#section-6.9.1-5)

A sender that receives a WINDOW\_UPDATE frame updates the corresponding window by the
amount specified in the frame.[¶](#section-6.9.1-6)

A sender MUST NOT allow a flow-control window to exceed 231-1 octets.
If a sender receives a WINDOW\_UPDATE that causes a flow-control window to exceed this
maximum, it MUST terminate either the stream or the connection, as appropriate. For
streams, the sender sends a [RST\_STREAM](#RST_STREAM) with an error code of
[FLOW\_CONTROL\_ERROR](#FLOW_CONTROL_ERROR); for the connection, a [GOAWAY](#GOAWAY)
frame with an error code of [FLOW\_CONTROL\_ERROR](#FLOW_CONTROL_ERROR) is sent.[¶](#section-6.9.1-7)

Flow-controlled frames from the sender and WINDOW\_UPDATE frames from the receiver are
completely asynchronous with respect to each other. This property allows a receiver to
aggressively update the window size kept by the sender to prevent streams from stalling.[¶](#section-6.9.1-8)

#### [6.9.2.](#section-6.9.2) [Initial Flow-Control Window Size](#name-initial-flow-control-window)

When an HTTP/2 connection is first established, new streams are created with an initial
flow-control window size of 65,535 octets. The connection flow-control window is also 65,535
octets. Both endpoints can adjust the initial window size for new streams by including
a value for [SETTINGS\_INITIAL\_WINDOW\_SIZE](#SETTINGS_INITIAL_WINDOW_SIZE) in the [SETTINGS](#SETTINGS)
frame. The connection flow-control window can
only be changed using WINDOW\_UPDATE frames.[¶](#section-6.9.2-1)

Prior to receiving a [SETTINGS](#SETTINGS) frame that sets a value for
[SETTINGS\_INITIAL\_WINDOW\_SIZE](#SETTINGS_INITIAL_WINDOW_SIZE), an endpoint can only use the default
initial window size when sending flow-controlled frames. Similarly, the connection flow-control
window is set based on the default initial window size until a WINDOW\_UPDATE frame is
received.[¶](#section-6.9.2-2)

In addition to changing the flow-control window for streams that are not yet active, a
[SETTINGS](#SETTINGS) frame can alter the initial flow-control window size for streams
with active flow-control windows (that is, streams in the "open" or "half-closed
(remote)" state). When the value of [SETTINGS\_INITIAL\_WINDOW\_SIZE](#SETTINGS_INITIAL_WINDOW_SIZE)
changes, a receiver MUST adjust the size of all stream flow-control windows that it
maintains by the difference between the new value and the old value.[¶](#section-6.9.2-3)

A change to [SETTINGS\_INITIAL\_WINDOW\_SIZE](#SETTINGS_INITIAL_WINDOW_SIZE) can cause the available space in
a flow-control window to become negative. A sender MUST track the negative flow-control
window and MUST NOT send new flow-controlled frames until it receives WINDOW\_UPDATE
frames that cause the flow-control window to become positive.[¶](#section-6.9.2-4)

For example, if the client sends 60 KB immediately on connection establishment and the
server sets the initial window size to be 16 KB, the client will recalculate the
available flow-control window to be -44 KB on receipt of the [SETTINGS](#SETTINGS)
frame. The client retains a negative flow-control window until WINDOW\_UPDATE frames
restore the window to being positive, after which the client can resume sending.[¶](#section-6.9.2-5)

A [SETTINGS](#SETTINGS) frame cannot alter the connection flow-control window.[¶](#section-6.9.2-6)

An endpoint MUST treat a change to [SETTINGS\_INITIAL\_WINDOW\_SIZE](#SETTINGS_INITIAL_WINDOW_SIZE) that
causes any flow-control window to exceed the maximum size as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[FLOW\_CONTROL\_ERROR](#FLOW_CONTROL_ERROR).[¶](#section-6.9.2-7)

#### [6.9.3.](#section-6.9.3) [Reducing the Stream Window Size](#name-reducing-the-stream-window-)

A receiver that wishes to use a smaller flow-control window than the current size can
send a new [SETTINGS](#SETTINGS) frame. However, the receiver MUST be prepared to
receive data that exceeds this window size, since the sender might send data that
exceeds the lower limit prior to processing the [SETTINGS](#SETTINGS) frame.[¶](#section-6.9.3-1)

After sending a SETTINGS frame that reduces the initial flow-control window size, a
receiver MAY continue to process streams that exceed flow-control limits. Allowing
streams to continue does not allow the receiver to immediately reduce the space it
reserves for flow-control windows. Progress on these streams can also stall, since
[WINDOW\_UPDATE](#WINDOW_UPDATE) frames are needed to allow the sender to resume sending.
The receiver MAY instead send a [RST\_STREAM](#RST_STREAM) with an error code of
[FLOW\_CONTROL\_ERROR](#FLOW_CONTROL_ERROR) for the affected streams.[¶](#section-6.9.3-2)

### [6.10.](#section-6.10) [CONTINUATION](#name-continuation)

The CONTINUATION frame (type=0x09) is used to continue a sequence of [field block fragments](#FieldBlock) ([Section 4.3](#FieldBlock)). Any number of CONTINUATION frames can
be sent, as long as the preceding frame is on the same stream and is a
[HEADERS](#HEADERS), [PUSH\_PROMISE](#PUSH_PROMISE), or CONTINUATION frame without the
END\_HEADERS flag set.[¶](#section-6.10-1)

```

CONTINUATION Frame {
  Length (24),
  Type (8) = 0x09,

  Unused Flags (5),
  END_HEADERS Flag (1),
  Unused Flags (2),

  Reserved (1),
  Stream Identifier (31),

  Field Block Fragment (..),
}

```

[Figure 12](#figure-12):
[CONTINUATION Frame Format](#name-continuation-frame-format)

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in [Section 4](#FramingLayer).
The CONTINUATION frame payload contains a [field block
fragment](#FieldBlock) ([Section 4.3](#FieldBlock)).[¶](#section-6.10-3)

The CONTINUATION frame defines the following flag:[¶](#section-6.10-4)

END\_HEADERS (0x04):

When set, the END\_HEADERS flag indicates that this frame ends a [field
block](#FieldBlock) ([Section 4.3](#FieldBlock)).[¶](#section-6.10-5.2.1)

If the END\_HEADERS flag is not set, this frame MUST be followed by another
CONTINUATION frame. A receiver MUST treat the receipt of any other type of frame or
a frame on a different stream as a [connection
error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.10-5.2.2)

The CONTINUATION frame changes the connection state as defined in [Section 4.3](#FieldBlock).[¶](#section-6.10-6)

CONTINUATION frames MUST be associated with a stream. If a CONTINUATION frame is received
with a Stream Identifier field of 0x00, the recipient MUST respond with a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type PROTOCOL\_ERROR.[¶](#section-6.10-7)

A CONTINUATION frame MUST be preceded by a [HEADERS](#HEADERS),
[PUSH\_PROMISE](#PUSH_PROMISE) or CONTINUATION frame without the END\_HEADERS flag set. A
recipient that observes violation of this rule MUST respond with a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-6.10-8)

## [7.](#section-7) [Error Codes](#name-error-codes)

Error codes are 32-bit fields that are used in [RST\_STREAM](#RST_STREAM) and
[GOAWAY](#GOAWAY) frames to convey the reasons for the stream or connection error.[¶](#section-7-1)

Error codes share a common code space. Some error codes apply only to either streams or the
entire connection and have no defined semantics in the other context.[¶](#section-7-2)

The following error codes are defined:[¶](#section-7-3)

NO\_ERROR (0x00):
The associated condition is not a result of an error. For example, a
[GOAWAY](#GOAWAY) might include this code to indicate graceful shutdown of a
connection.[¶](#NO_ERROR)

PROTOCOL\_ERROR (0x01):
The endpoint detected an unspecific protocol error. This error is for use when a more
specific error code is not available.[¶](#PROTOCOL_ERROR)

INTERNAL\_ERROR (0x02):
The endpoint encountered an unexpected internal error.[¶](#INTERNAL_ERROR)

FLOW\_CONTROL\_ERROR (0x03):
The endpoint detected that its peer violated the flow-control protocol.[¶](#FLOW_CONTROL_ERROR)

SETTINGS\_TIMEOUT (0x04):
The endpoint sent a [SETTINGS](#SETTINGS) frame but did not receive a response in a
timely manner. See [Section 6.5.3](#SettingsSync) ("Settings Synchronization").[¶](#SETTINGS_TIMEOUT)

STREAM\_CLOSED (0x05):
The endpoint received a frame after a stream was half-closed.[¶](#STREAM_CLOSED)

FRAME\_SIZE\_ERROR (0x06):
The endpoint received a frame with an invalid size.[¶](#FRAME_SIZE_ERROR)

REFUSED\_STREAM (0x07):
The endpoint refused the stream prior to performing any application processing (see
[Section 8.7](#Reliability) for details).[¶](#REFUSED_STREAM)

CANCEL (0x08):
The endpoint uses this error code to indicate that the stream is no longer needed.[¶](#CANCEL)

COMPRESSION\_ERROR (0x09):
The endpoint is unable to maintain the field section compression context for the
connection.[¶](#COMPRESSION_ERROR)

CONNECT\_ERROR (0x0a):
The connection established in response to a [CONNECT
request](#CONNECT) ([Section 8.5](#CONNECT)) was reset or abnormally closed.[¶](#CONNECT_ERROR)

ENHANCE\_YOUR\_CALM (0x0b):
The endpoint detected that its peer is exhibiting a behavior that might be generating
excessive load.[¶](#ENHANCE_YOUR_CALM)

INADEQUATE\_SECURITY (0x0c):
The underlying transport has properties that do not meet minimum security
requirements (see [Section 9.2](#TLSUsage)).[¶](#INADEQUATE_SECURITY)

HTTP\_1\_1\_REQUIRED (0x0d):
The endpoint requires that HTTP/1.1 be used instead of HTTP/2.[¶](#HTTP_1_1_REQUIRED)

Unknown or unsupported error codes MUST NOT trigger any special behavior. These MAY be
treated by an implementation as being equivalent to [INTERNAL\_ERROR](#INTERNAL_ERROR).[¶](#section-7-5)

## [8.](#section-8) [Expressing HTTP Semantics in HTTP/2](#name-expressing-http-semantics-i)

HTTP/2 is an instantiation of the HTTP message abstraction ([Section 6](https://www.rfc-editor.org/rfc/rfc9110#section-6) of [[HTTP](#RFC9110)]).[¶](#section-8-1)

### [8.1.](#section-8.1) [HTTP Message Framing](#name-http-message-framing)

A client sends an HTTP request on a new stream, using a previously unused [stream identifier](#StreamIdentifiers) ([Section 5.1.1](#StreamIdentifiers)). A server sends an HTTP response on
the same stream as the request.[¶](#section-8.1-1)

An HTTP message (request or response) consists of:[¶](#section-8.1-2)

1. one [HEADERS](#HEADERS) frame (followed by zero or
   more [CONTINUATION](#CONTINUATION) frames) containing
   the header section (see [Section 6.3](https://www.rfc-editor.org/rfc/rfc9110#section-6.3) of [[HTTP](#RFC9110)]),[¶](#section-8.1-3.1)
2. zero or more [DATA](#DATA) frames containing the
   message content (see [Section 6.4](https://www.rfc-editor.org/rfc/rfc9110#section-6.4) of [[HTTP](#RFC9110)]), and[¶](#section-8.1-3.2)
3. optionally, one [HEADERS](#HEADERS) frame (followed by
   zero or more [CONTINUATION](#CONTINUATION) frames)
   containing the trailer section, if present (see [Section 6.5](https://www.rfc-editor.org/rfc/rfc9110#section-6.5) of [[HTTP](#RFC9110)]).[¶](#section-8.1-3.3)

For a response only, a server MAY send any number of interim responses before the [HEADERS](#HEADERS) frame containing a final response. An
interim response consists of a [HEADERS](#HEADERS) frame
(which might be followed by zero or more [CONTINUATION](#CONTINUATION) frames) containing the control data and header section
of an interim (1xx) HTTP response (see [Section 15](https://www.rfc-editor.org/rfc/rfc9110#section-15) of [[HTTP](#RFC9110)]). A [HEADERS](#HEADERS) frame with the END\_STREAM flag set that carries
an informational status code is [malformed](#malformed) ([Section 8.1.1](#malformed)).[¶](#section-8.1-4)

The last frame in the sequence bears an END\_STREAM flag, noting that a [HEADERS](#HEADERS) frame with the END\_STREAM flag set can be
followed by [CONTINUATION](#CONTINUATION) frames that
carry any remaining fragments of the field block.[¶](#section-8.1-5)

Other frames (from any stream) MUST NOT occur between the [HEADERS](#HEADERS) frame
and any [CONTINUATION](#CONTINUATION) frames that might follow.[¶](#section-8.1-6)

HTTP/2 uses DATA frames to carry message content. The `chunked` transfer encoding
defined in [Section 7.1](https://www.rfc-editor.org/rfc/rfc9112#section-7.1) of [[HTTP/1.1](#RFC9112)] cannot be used in HTTP/2; see [Section 8.2.2](#ConnectionSpecific).[¶](#section-8.1-7)

Trailer fields are carried in a field block that also terminates the stream. That is,
trailer fields comprise a sequence starting with a [HEADERS](#HEADERS) frame, followed by zero or more [CONTINUATION](#CONTINUATION) frames, where the [HEADERS](#HEADERS) frame bears an END\_STREAM flag. Trailers MUST NOT include
[pseudo-header fields](#PseudoHeaderFields) ([Section 8.3](#PseudoHeaderFields)). An endpoint that receives
pseudo-header fields in trailers MUST treat the request or response as [malformed](#malformed) ([Section 8.1.1](#malformed)).[¶](#section-8.1-8)

An endpoint that receives a [HEADERS](#HEADERS) frame
without the END\_STREAM flag set after receiving the [HEADERS](#HEADERS) frame that opens a request or after receiving a final
(non-informational) status code MUST treat the corresponding request or response as [malformed](#malformed) ([Section 8.1.1](#malformed)).[¶](#section-8.1-9)

An HTTP request/response exchange fully consumes a single stream. A request starts with
the [HEADERS](#HEADERS) frame that puts the stream into
the "open" state. The request ends with a frame with the END\_STREAM flag set, which causes the
stream to become "half-closed (local)" for the client and "half-closed (remote)" for the
server. A response stream starts with zero or more interim responses in [HEADERS](#HEADERS) frames, followed by a [HEADERS](#HEADERS) frame containing a final status code.[¶](#section-8.1-10)

An HTTP response is complete after the server sends -- or the client receives -- a frame
with the END\_STREAM flag set (including any [CONTINUATION](#CONTINUATION) frames needed to complete a field block). A server can
send a complete response prior to the client sending an entire request if the response
does not depend on any portion of the request that has not been sent and received. When
this is true, a server MAY request that the client abort transmission of a request
without error by sending a [RST\_STREAM](#RST_STREAM) with
an error code of [NO\_ERROR](#NO_ERROR) after sending a
complete response (i.e., a frame with the END\_STREAM flag set). Clients MUST NOT discard
responses as a result of receiving such a [RST\_STREAM](#RST_STREAM), though clients can always discard responses at their
discretion for other reasons.[¶](#section-8.1-11)

#### [8.1.1.](#section-8.1.1) [Malformed Messages](#name-malformed-messages)

A malformed request or response is one that is an otherwise valid sequence of HTTP/2
frames but is invalid due to the presence of extraneous frames, prohibited fields or
pseudo-header fields, the absence of mandatory pseudo-header fields, the inclusion of
uppercase field names, or invalid field names and/or values (in certain circumstances;
see [Section 8.2](#HttpHeaders)).[¶](#section-8.1.1-1)

A request or response that includes message content can include a
`content-length` header field. A request or response is also malformed if the
value of a `content-length` header field does not equal the sum of the [DATA](#DATA) frame payload lengths that form the content,
unless the message is defined as having no content. For example, 204 or 304 responses
contain no content, as does the response to a HEAD request. A response that is defined
to have no content, as described in [Section 6.4.1](https://www.rfc-editor.org/rfc/rfc9110#section-6.4.1) of [[HTTP](#RFC9110)], MAY have a
non-zero `content-length` header field, even though no content is included in
[DATA](#DATA) frames.[¶](#section-8.1.1-2)

Intermediaries that process HTTP requests or responses (i.e., any intermediary not
acting as a tunnel) MUST NOT forward a malformed request or response. Malformed
requests or responses that are detected MUST be treated as a [stream error](#StreamErrorHandler) ([Section 5.4.2](#StreamErrorHandler)) of type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-8.1.1-3)

For malformed requests, a server MAY send an HTTP response prior to closing or
resetting the stream. Clients MUST NOT accept a malformed response.[¶](#section-8.1.1-4)

Endpoints that progressively process messages might have performed some processing
before identifying a request or response as malformed. For instance, it might be
possible to generate an informational or 404 status code without having received a
complete request. Similarly, intermediaries might forward incomplete messages before
detecting errors. A server MAY generate a final response before receiving an entire
request when the response does not depend on the remainder of the request being
correct.[¶](#section-8.1.1-5)

These requirements are intended to protect against several types of common attacks
against HTTP; they are deliberately strict because being permissive can expose
implementations to these vulnerabilities.[¶](#section-8.1.1-6)

### [8.2.](#section-8.2) [HTTP Fields](#name-http-fields)

HTTP fields ([Section 5](https://www.rfc-editor.org/rfc/rfc9110#section-5) of [[HTTP](#RFC9110)]) are conveyed by HTTP/2 in the HEADERS,
CONTINUATION, and PUSH\_PROMISE frames, compressed with [HPACK](#RFC7541) [[COMPRESSION](#RFC7541)].[¶](#section-8.2-1)

Field names MUST be converted to lowercase when constructing an HTTP/2 message.[¶](#section-8.2-2)

#### [8.2.1.](#section-8.2.1) [Field Validity](#name-field-validity)

The definitions of field names and values in HTTP prohibit some characters that HPACK
might be able to convey. HTTP/2 implementations SHOULD validate field names and values
according to their definitions in Sections [5.1](https://www.rfc-editor.org/rfc/rfc9110#section-5.1) and [5.5](https://www.rfc-editor.org/rfc/rfc9110#section-5.5) of [[HTTP](#RFC9110)], respectively, and treat messages that contain prohibited characters as
[malformed](#malformed) ([Section 8.1.1](#malformed)).[¶](#section-8.2.1-1)

Failure to validate fields can be exploited for request smuggling attacks. In
particular, unvalidated fields might enable attacks when messages are forwarded using
[HTTP/1.1](#RFC9112) [[HTTP/1.1](#RFC9112)], where characters such as carriage return (CR), line feed (LF), and COLON are
used as delimiters. Implementations MUST perform the following minimal validation of
field names and values:[¶](#section-8.2.1-2)

* A field name MUST NOT contain characters in the ranges 0x00-0x20, 0x41-0x5a, or
  0x7f-0xff (all ranges inclusive). This specifically excludes all non-visible ASCII
  characters, ASCII SP (0x20), and uppercase characters ('A' to 'Z', ASCII 0x41 to
  0x5a).[¶](#section-8.2.1-3.1)
* With the exception of [pseudo-header fields](#PseudoHeaderFields) ([Section 8.3](#PseudoHeaderFields)),
  which have a name that starts with a single colon, field names MUST NOT include a
  colon (ASCII COLON, 0x3a).[¶](#section-8.2.1-3.2)
* A field value MUST NOT contain the zero value (ASCII NUL, 0x00), line feed (ASCII LF,
  0x0a), or carriage return (ASCII CR, 0x0d) at any position.[¶](#section-8.2.1-3.3)
* A field value MUST NOT start or end with an ASCII whitespace character (ASCII SP or
  HTAB, 0x20 or 0x09).[¶](#section-8.2.1-3.4)

Note: An implementation that validates fields according to the definitions in Sections
[5.1](https://www.rfc-editor.org/rfc/rfc9110#section-5.1) and [5.5](https://www.rfc-editor.org/rfc/rfc9110#section-5.5) of [[HTTP](#RFC9110)] only needs an additional check
that field names do not include uppercase characters.[¶](#section-8.2.1-4.1)

A request or response that contains a field that violates any of these conditions MUST
be treated as [malformed](#malformed) ([Section 8.1.1](#malformed)). In particular, an intermediary
that does not process fields when forwarding messages MUST NOT forward fields that
contain any of the values that are listed as prohibited above.[¶](#section-8.2.1-5)

When a request message violates one of these requirements, an implementation SHOULD
generate a 400 (Bad Request) status code (see [Section 15.5.1](https://www.rfc-editor.org/rfc/rfc9110#section-15.5.1) of [[HTTP](#RFC9110)]),
unless a more suitable status code is defined or the status code cannot be sent (e.g.,
because the error occurs in a trailer field).[¶](#section-8.2.1-6)

Note: Field values that are not valid according to the definition of the corresponding
field do not cause a request to be [malformed](#malformed); the requirements above only apply to the generic
syntax for fields as defined in [Section 5](https://www.rfc-editor.org/rfc/rfc9110#section-5) of [[HTTP](#RFC9110)].[¶](#section-8.2.1-7.1)

#### [8.2.2.](#section-8.2.2) [Connection-Specific Header Fields](#name-connection-specific-header-)

HTTP/2 does not use the `Connection` header field ([Section 7.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.6.1) of [[HTTP](#RFC9110)]) to indicate connection-specific header fields; in this protocol,
connection-specific metadata is conveyed by other means. An endpoint MUST NOT generate
an HTTP/2 message containing connection-specific header fields. This includes the
`Connection` header field and those listed as having connection-specific
semantics in [Section 7.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.6.1) of [[HTTP](#RFC9110)] (that is, `Proxy-Connection`,
`Keep-Alive`, `Transfer-Encoding`, and `Upgrade`). Any message
containing connection-specific header fields MUST be treated as [malformed](#malformed) ([Section 8.1.1](#malformed)).[¶](#section-8.2.2-1)

The only exception to this is the TE header field, which MAY be present in an HTTP/2
request; when it is, it MUST NOT contain any value other than "trailers".[¶](#section-8.2.2-2)

An intermediary transforming an HTTP/1.x message to HTTP/2 MUST remove connection-specific
header fields as discussed in [Section 7.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.6.1) of [[HTTP](#RFC9110)],
or their messages will be treated by other HTTP/2 endpoints as [malformed](#malformed) ([Section 8.1.1](#malformed)).[¶](#section-8.2.2-3)

Note:
HTTP/2 purposefully does not support upgrade to another protocol. The handshake
methods described in [Section 3](#starting) are believed sufficient to
negotiate the use of alternative protocols.[¶](#section-8.2.2-4.1)

#### [8.2.3.](#section-8.2.3) [Compressing the Cookie Header Field](#name-compressing-the-cookie-head)

The [Cookie header field](#RFC6265) [[COOKIE](#RFC6265)] uses a semicolon (";") to delimit
cookie-pairs (or "crumbs"). This header field contains multiple values, but does not use
a COMMA (",") as a separator, thereby preventing cookie-pairs from being sent on
multiple field lines (see [Section 5.2](https://www.rfc-editor.org/rfc/rfc9110#section-5.2) of [[HTTP](#RFC9110)]). This can significantly
reduce compression efficiency, as updates to individual cookie-pairs would invalidate any
field lines that are stored in the HPACK table.[¶](#section-8.2.3-1)

To allow for better compression efficiency, the Cookie header field MAY be split into
separate header fields, each with one or more cookie-pairs. If there are multiple
Cookie header fields after decompression, these MUST be concatenated into a single
octet string using the two-octet delimiter of 0x3b, 0x20 (the ASCII string "; ")
before being passed into a non-HTTP/2 context, such as an HTTP/1.1 connection, or a
generic HTTP server application.[¶](#section-8.2.3-2)

Therefore, the following two lists of Cookie header fields are semantically
equivalent.[¶](#section-8.2.3-3)

```

cookie: a=b; c=d; e=f

cookie: a=b
cookie: c=d
cookie: e=f

```
[¶](#section-8.2.3-4)

### [8.3.](#section-8.3) [HTTP Control Data](#name-http-control-data)

HTTP/2 uses special pseudo-header fields beginning with a ':' character (ASCII 0x3a) to
convey message control data (see [Section 6.2](https://www.rfc-editor.org/rfc/rfc9110#section-6.2) of [[HTTP](#RFC9110)]).[¶](#section-8.3-1)

Pseudo-header fields are not HTTP header fields. Endpoints MUST NOT generate
pseudo-header fields other than those defined in this document. Note that an
extension could negotiate the use of additional pseudo-header fields; see
[Section 5.5](#extensibility).[¶](#section-8.3-2)

Pseudo-header fields are only valid in the context in which they are defined.
Pseudo-header fields defined for requests MUST NOT appear in responses; pseudo-header
fields defined for responses MUST NOT appear in requests. Pseudo-header fields MUST NOT appear in a trailer section. Endpoints MUST treat a request or response that contains
undefined or invalid pseudo-header fields as [malformed](#malformed) ([Section 8.1.1](#malformed)).[¶](#section-8.3-3)

All pseudo-header fields MUST appear in a field block before all regular field lines.
Any request or response that contains a pseudo-header field that appears in a field
block after a regular field line MUST be treated as [malformed](#malformed) ([Section 8.1.1](#malformed)).[¶](#section-8.3-4)

The same pseudo-header field name MUST NOT appear more than once in a field block. A
field block for an HTTP request or response that contains a repeated pseudo-header field
name MUST be treated as [malformed](#malformed) ([Section 8.1.1](#malformed)).[¶](#section-8.3-5)

#### [8.3.1.](#section-8.3.1) [Request Pseudo-Header Fields](#name-request-pseudo-header-field)

The following pseudo-header fields are defined for HTTP/2 requests:[¶](#section-8.3.1-1)

* The "`:method`" pseudo-header field includes the HTTP
  method ([Section 9](https://www.rfc-editor.org/rfc/rfc9110#section-9) of [[HTTP](#RFC9110)]).[¶](#section-8.3.1-2.1.1)
* The "`:scheme`" pseudo-header field includes the scheme portion of the request
  target. The scheme is taken from the target URI ([Section 3.1](https://www.rfc-editor.org/rfc/rfc3986#section-3.1) of [[RFC3986](#RFC3986)]) when generating a request directly, or from the scheme of a
  translated request (for example, see [Section 3.3](https://www.rfc-editor.org/rfc/rfc9112#section-3.3) of [[HTTP/1.1](#RFC9112)]). Scheme
  is omitted for [CONNECT requests](#CONNECT) ([Section 8.5](#CONNECT)).[¶](#section-8.3.1-2.2.1)

  "`:scheme`" is not restricted to "`http`" and "`https`" schemed
  URIs. A proxy or gateway can translate requests for non-HTTP schemes, enabling
  the use of HTTP to interact with non-HTTP services.[¶](#section-8.3.1-2.2.2)
* The "`:authority`" pseudo-header field conveys the authority portion ([Section 3.2](https://www.rfc-editor.org/rfc/rfc3986#section-3.2) of [[RFC3986](#RFC3986)]) of the target URI ([Section 7.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.1) of [[HTTP](#RFC9110)]). The recipient of an HTTP/2 request MUST NOT use the `Host`
  header field to determine the target URI if "`:authority`" is present.[¶](#section-8.3.1-2.3.1)

  Clients that generate HTTP/2 requests directly MUST use the "`:authority`"
  pseudo-header field to convey authority information, unless there is no authority
  information to convey (in which case it MUST NOT generate "`:authority`").[¶](#section-8.3.1-2.3.2)

  Clients MUST NOT generate a request with a `Host` header field that differs
  from the "`:authority`" pseudo-header field. A
  server SHOULD treat a request as malformed if it contains a `Host` header
  field that identifies an entity that differs from the entity in the "`:authority`" pseudo-header
  field. The values of fields need to be normalized to compare them (see [Section 6.2](https://www.rfc-editor.org/rfc/rfc3986#section-6.2) of [[RFC3986](#RFC3986)]). An origin server can apply any normalization
  method, whereas other servers MUST perform scheme-based normalization (see [Section 6.2.3](https://www.rfc-editor.org/rfc/rfc3986#section-6.2.3) of [[RFC3986](#RFC3986)]) of the two fields.[¶](#section-8.3.1-2.3.3)

  An intermediary that forwards a request over HTTP/2 MUST construct an
  "`:authority`" pseudo-header field using the authority information from the
  control data of the original request, unless the original request's target URI
  does not contain authority information (in which case it MUST NOT generate
  "`:authority`"). Note that the `Host` header field is not the sole
  source of this information; see [Section 7.2](https://www.rfc-editor.org/rfc/rfc9110#section-7.2) of [[HTTP](#RFC9110)].[¶](#section-8.3.1-2.3.4)

  An intermediary that needs to generate a `Host` header field (which might be
  necessary to construct an HTTP/1.1 request) MUST use the value from the "`:authority`"
  pseudo-header field as the value of the `Host` field,
  unless the intermediary also changes the request target. This replaces any existing
  `Host` field to avoid potential vulnerabilities in HTTP routing.[¶](#section-8.3.1-2.3.5)

  An intermediary that forwards a request over HTTP/2 MAY retain any `Host`
  header field.[¶](#section-8.3.1-2.3.6)

  Note that request targets for CONNECT or asterisk-form OPTIONS requests never
  include authority information; see Sections [7.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.1) and [7.2](https://www.rfc-editor.org/rfc/rfc9110#section-7.2)
  of [[HTTP](#RFC9110)].[¶](#section-8.3.1-2.3.7)

  "`:authority`" MUST NOT include the deprecated userinfo subcomponent for
  "`http`" or "`https`" schemed URIs.[¶](#section-8.3.1-2.3.8)
* The "`:path`" pseudo-header field includes the path and
  query parts of the target URI (the `absolute-path`
  production and, optionally, a '?' character followed by the
  `query` production; see [Section 4.1](https://www.rfc-editor.org/rfc/rfc9110#section-4.1) of [[HTTP](#RFC9110)]).
  A request in asterisk form (for OPTIONS) includes the value '\*' for the
  "`:path`" pseudo-header field.[¶](#section-8.3.1-2.4.1)

  This pseudo-header field MUST NOT be empty for "`http`" or "`https`"
  URIs; "`http`" or "`https`" URIs that do not contain a path component
  MUST include a value of '/'. The exceptions to this rule are:[¶](#section-8.3.1-2.4.2)

  + an OPTIONS request for an "`http`" or "`https`" URI that does not include a path
    component; these MUST include a "`:path`" pseudo-header field with a value
    of '\*' (see [Section 7.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.1) of [[HTTP](#RFC9110)]).[¶](#section-8.3.1-2.4.3.1)
  + [CONNECT requests](#CONNECT) ([Section 8.5](#CONNECT)), where the "`:path`" pseudo-header field is omitted.[¶](#section-8.3.1-2.4.3.2)

All HTTP/2 requests MUST include exactly one valid value for the "`:method`",
"`:scheme`", and "`:path`" pseudo-header fields, unless they are [CONNECT requests](#CONNECT) ([Section 8.5](#CONNECT)). An HTTP request that omits mandatory
pseudo-header fields is [malformed](#malformed) ([Section 8.1.1](#malformed)).[¶](#section-8.3.1-3)

Individual HTTP/2 requests do not carry an explicit indicator of protocol version.
All HTTP/2 requests implicitly have a protocol version of "2.0" (see
[Section 6.2](https://www.rfc-editor.org/rfc/rfc9110#section-6.2) of [[HTTP](#RFC9110)]).[¶](#section-8.3.1-4)

#### [8.3.2.](#section-8.3.2) [Response Pseudo-Header Fields](#name-response-pseudo-header-fiel)

For HTTP/2 responses, a single "`:status`" pseudo-header
field is defined that carries the HTTP status code field (see
[Section 15](https://www.rfc-editor.org/rfc/rfc9110#section-15) of [[HTTP](#RFC9110)]). This pseudo-header field MUST be included in all
responses, including interim responses; otherwise, the response is
[malformed](#malformed) ([Section 8.1.1](#malformed)).[¶](#section-8.3.2-1)

HTTP/2 responses implicitly have a protocol version of "2.0".[¶](#section-8.3.2-2)

### [8.4.](#section-8.4) [Server Push](#name-server-push)

HTTP/2 allows a server to preemptively send (or "push") responses (along with
corresponding "promised" requests) to a client in association with a previous
client-initiated request.[¶](#section-8.4-1)

Server push was designed to allow a server to improve client-perceived performance by
predicting what requests will follow those that it receives, thereby removing a round
trip for them. For example, a request for HTML is often followed by requests
for stylesheets and scripts referenced by that page. When these requests
are pushed, the client does not need to wait to receive the references to them in the HTML
and issue separate requests.[¶](#section-8.4-2)

In practice, server push is difficult to use effectively, because it requires the
server to correctly anticipate the additional requests the client will make, taking into
account factors such as caching, content negotiation, and user behavior. Errors in
prediction can lead to performance degradation, due to the opportunity cost that the
additional data on the wire represents. In particular, pushing any significant amount of
data can cause contention issues with responses that are more important.[¶](#section-8.4-3)

A client can request that server push be disabled, though this is negotiated for each hop
independently. The [SETTINGS\_ENABLE\_PUSH](#SETTINGS_ENABLE_PUSH) setting can be set to 0 to indicate that server
push is disabled.[¶](#section-8.4-4)

Promised requests MUST be safe (see [Section 9.2.1](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.1) of [[HTTP](#RFC9110)]) and cacheable
(see [Section 9.2.3](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.3) of [[HTTP](#RFC9110)]). Promised requests cannot include any content
or a trailer section. Clients that receive a promised request that is not cacheable, that
is not known to be safe, or that indicates the presence of request content MUST reset the
promised stream with a [stream error](#StreamErrorHandler) ([Section 5.4.2](#StreamErrorHandler)) of type
[PROTOCOL\_ERROR](#PROTOCOL_ERROR). Note that this could result
in the promised stream being reset if the client does not recognize a newly defined
method as being safe.[¶](#section-8.4-5)

Pushed responses that are cacheable (see [Section 3](https://www.rfc-editor.org/rfc/rfc9111#section-3) of [[CACHING](#RFC9111)]) can be
stored by the client, if it implements an HTTP cache. Pushed responses are considered
successfully validated on the origin server (e.g., if the "no-cache" cache response
directive is present; see [Section 5.2.2.4](https://www.rfc-editor.org/rfc/rfc9111#section-5.2.2.4) of [[CACHING](#RFC9111)]) while the stream
identified by the promised stream identifier is still open.[¶](#section-8.4-6)

Pushed responses that are not cacheable MUST NOT be stored by any HTTP cache. They MAY
be made available to the application separately.[¶](#section-8.4-7)

The server MUST include a value in the "`:authority`" pseudo-header field for which
the server is authoritative (see [Section 10.1](#authority)). A client MUST treat a [PUSH\_PROMISE](#PUSH_PROMISE) for which the server is not
authoritative as a [stream error](#StreamErrorHandler) ([Section 5.4.2](#StreamErrorHandler)) of type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-8.4-8)

An intermediary can receive pushes from the server and choose not to forward them on to
the client. In other words, how to make use of the pushed information is up to that
intermediary. Equally, the intermediary might choose to make additional pushes to the
client, without any action taken by the server.[¶](#section-8.4-9)

A client cannot push. Thus, servers MUST treat the receipt of a [PUSH\_PROMISE](#PUSH_PROMISE) frame as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type [PROTOCOL\_ERROR](#PROTOCOL_ERROR). A server cannot set the
[SETTINGS\_ENABLE\_PUSH](#SETTINGS_ENABLE_PUSH) setting to
a value other than 0 (see [Section 6.5.2](#SettingValues)).[¶](#section-8.4-10)

#### [8.4.1.](#section-8.4.1) [Push Requests](#name-push-requests)

Server push is semantically equivalent to a server responding to a request; however, in
this case, that request is also sent by the server, as a [PUSH\_PROMISE](#PUSH_PROMISE)
frame.[¶](#section-8.4.1-1)

The [PUSH\_PROMISE](#PUSH_PROMISE) frame includes a
field block that contains control data and a complete
set of request header fields that the server attributes to the request. It is not
possible to push a response to a request that includes message content.[¶](#section-8.4.1-2)

Promised requests are always associated with an explicit request from the client. The
[PUSH\_PROMISE](#PUSH_PROMISE) frames sent by the server are sent on that explicit
request's stream. The [PUSH\_PROMISE](#PUSH_PROMISE) frame also includes a promised stream
identifier, chosen from the stream identifiers available to the server (see [Section 5.1.1](#StreamIdentifiers)).[¶](#section-8.4.1-3)

The header fields in [PUSH\_PROMISE](#PUSH_PROMISE) and
any subsequent [CONTINUATION](#CONTINUATION) frames MUST
be a valid and complete set of [request header
fields](#HttpRequest) ([Section 8.3.1](#HttpRequest)). The server MUST include a method in the "`:method`" pseudo-header
field that is safe and cacheable. If a client receives a [PUSH\_PROMISE](#PUSH_PROMISE) that does not include a complete and valid set of
header fields or the "`:method`" pseudo-header field identifies a method that is
not safe, it MUST respond on the promised stream with a [stream error](#StreamErrorHandler) ([Section 5.4.2](#StreamErrorHandler)) of type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-8.4.1-4)

The server SHOULD send [PUSH\_PROMISE](#PUSH_PROMISE)
([Section 6.6](#PUSH_PROMISE)) frames prior to sending any frames that reference the
promised responses. This avoids a race where clients issue requests prior to receiving
any [PUSH\_PROMISE](#PUSH_PROMISE) frames.[¶](#section-8.4.1-5)

For example, if the server receives a request for a document containing embedded links
to multiple image files and the server chooses to push those additional images to the
client, sending [PUSH\_PROMISE](#PUSH_PROMISE) frames
before the [DATA](#DATA) frames that contain the image
links ensures that the client is able to see that a resource will be pushed before
discovering embedded links. Similarly, if the server pushes resources referenced by the
field block (for instance, in Link header fields), sending a [PUSH\_PROMISE](#PUSH_PROMISE) before sending the header
ensures that clients do not request those resources.[¶](#section-8.4.1-6)

[PUSH\_PROMISE](#PUSH_PROMISE) frames MUST NOT be sent by the client.[¶](#section-8.4.1-7)

[PUSH\_PROMISE](#PUSH_PROMISE) frames can be sent by the server on any
client-initiated stream, but the stream MUST be in either the "open" or "half-closed
(remote)" state with respect to the server. [PUSH\_PROMISE](#PUSH_PROMISE) frames are
interspersed with the frames that comprise a response, though they cannot be
interspersed with [HEADERS](#HEADERS) and [CONTINUATION](#CONTINUATION) frames that
comprise a single field block.[¶](#section-8.4.1-8)

Sending a [PUSH\_PROMISE](#PUSH_PROMISE) frame creates a new stream and puts the stream
into the "reserved (local)" state for the server and the "reserved (remote)" state for
the client.[¶](#section-8.4.1-9)

#### [8.4.2.](#section-8.4.2) [Push Responses](#name-push-responses)

After sending the [PUSH\_PROMISE](#PUSH_PROMISE) frame,
the server can begin delivering the pushed response as a [response](#HttpResponse) ([Section 8.3.2](#HttpResponse)) on a server-initiated stream that uses the
promised stream identifier. The server uses this stream to transmit an HTTP response,
using the same sequence of frames as that defined in [Section 8.1](#HttpFraming). This
stream becomes ["half-closed" to the client](#StreamStates) ([Section 5.1](#StreamStates)) after the
initial [HEADERS](#HEADERS) frame is sent.[¶](#section-8.4.2-1)

Once a client receives a [PUSH\_PROMISE](#PUSH_PROMISE) frame and chooses to accept the
pushed response, the client SHOULD NOT issue any requests for the promised response
until after the promised stream has closed.[¶](#section-8.4.2-2)

If the client determines, for any reason, that it does not wish to receive the pushed
response from the server or if the server takes too long to begin sending the promised
response, the client can send a [RST\_STREAM](#RST_STREAM) frame, using either the [CANCEL](#CANCEL) or [REFUSED\_STREAM](#REFUSED_STREAM) code and referencing the pushed stream's identifier.[¶](#section-8.4.2-3)

A client can use the [SETTINGS\_MAX\_CONCURRENT\_STREAMS](#SETTINGS_MAX_CONCURRENT_STREAMS) setting to limit the number of
responses that can be concurrently pushed by a server. Advertising a [SETTINGS\_MAX\_CONCURRENT\_STREAMS](#SETTINGS_MAX_CONCURRENT_STREAMS) value of zero prevents the server
from opening the streams necessary to push responses. However, this does not prevent the
server from reserving streams using [PUSH\_PROMISE](#PUSH_PROMISE) frames, because reserved streams do not count toward
the concurrent stream limit. Clients that do not wish to receive pushed resources need
to reset any unwanted reserved streams or set [SETTINGS\_ENABLE\_PUSH](#SETTINGS_ENABLE_PUSH) to 0.[¶](#section-8.4.2-4)

Clients receiving a pushed response MUST validate that either the server is
authoritative (see [Section 10.1](#authority)) or the proxy that provided the pushed
response is configured for the corresponding request. For example, a server that offers
a certificate for only the `example.com` DNS-ID (see [[RFC6125](#RFC6125)])
is not permitted to push a response for <`https://www.example.org/doc`>.[¶](#section-8.4.2-5)

The response for a [PUSH\_PROMISE](#PUSH_PROMISE) stream begins with a
[HEADERS](#HEADERS) frame, which immediately puts the stream into the "half-closed
(remote)" state for the server and "half-closed (local)" state for the client, and ends
with a frame with the END\_STREAM flag set, which places the stream in the "closed" state.[¶](#section-8.4.2-6)

Note:
The client never sends a frame with the END\_STREAM flag set for a server push.[¶](#section-8.4.2-7.1)

### [8.5.](#section-8.5) [The CONNECT Method](#name-the-connect-method)

The CONNECT method ([Section 9.3.6](https://www.rfc-editor.org/rfc/rfc9110#section-9.3.6) of [[HTTP](#RFC9110)]) is
used to convert an HTTP connection into a tunnel to a remote host.
CONNECT is primarily used with HTTP proxies to establish a TLS session with an origin
server for the purposes of interacting with "`https`" resources.[¶](#section-8.5-1)

In HTTP/2, the CONNECT method establishes a tunnel over a single HTTP/2 stream to a
remote host, rather than converting the entire connection to a tunnel. A CONNECT header
section is constructed as defined in [Section 8.3.1](#HttpRequest) ("[Request Pseudo-Header Fields](#HttpRequest)"), with a few differences. Specifically:[¶](#section-8.5-2)

* The "`:method`" pseudo-header field is set to `CONNECT`.[¶](#section-8.5-3.1)
* The "`:scheme`" and "`:path`" pseudo-header
  fields MUST be omitted.[¶](#section-8.5-3.2)
* The "`:authority`" pseudo-header field contains the host and port to
  connect to (equivalent to the authority-form of the request-target of CONNECT
  requests; see [Section 3.2.3](https://www.rfc-editor.org/rfc/rfc9112#section-3.2.3) of [[HTTP/1.1](#RFC9112)]).[¶](#section-8.5-3.3)

A CONNECT request that does not conform to these restrictions is [malformed](#malformed) ([Section 8.1.1](#malformed)).[¶](#section-8.5-4)

A proxy that supports CONNECT establishes a [TCP connection](#RFC0793) [[TCP](#RFC0793)] to
the host and port identified in the "`:authority`" pseudo-header field. Once
this connection is successfully established, the proxy sends a [HEADERS](#HEADERS)
frame containing a 2xx-series status code to the client, as defined in [Section 9.3.6](https://www.rfc-editor.org/rfc/rfc9110#section-9.3.6) of [[HTTP](#RFC9110)].[¶](#section-8.5-5)

After the initial [HEADERS](#HEADERS) frame sent by each
peer, all subsequent [DATA](#DATA) frames correspond to
data sent on the TCP connection. The frame payload of any [DATA](#DATA) frames sent by the client is transmitted by the proxy to the
TCP server; data received from the TCP server is assembled into [DATA](#DATA) frames by the proxy. Frame types other than [DATA](#DATA) or stream management frames ([RST\_STREAM](#RST_STREAM), [WINDOW\_UPDATE](#WINDOW_UPDATE), and [PRIORITY](#PRIORITY)) MUST NOT be sent on a connected stream and MUST be treated
as a [stream error](#StreamErrorHandler) ([Section 5.4.2](#StreamErrorHandler)) if received.[¶](#section-8.5-6)

The TCP connection can be closed by either peer. The END\_STREAM flag on a
[DATA](#DATA) frame is treated as being equivalent to the TCP FIN bit. A client is
expected to send a [DATA](#DATA) frame with the END\_STREAM flag set after receiving
a frame with the END\_STREAM flag set. A proxy that receives a [DATA](#DATA) frame
with the END\_STREAM flag set sends the attached data with the FIN bit set on the last TCP
segment. A proxy that receives a TCP segment with the FIN bit set sends a
[DATA](#DATA) frame with the END\_STREAM flag set. Note that the final TCP segment
or [DATA](#DATA) frame could be empty.[¶](#section-8.5-7)

A TCP connection error is signaled with [RST\_STREAM](#RST_STREAM). A proxy treats any
error in the TCP connection, which includes receiving a TCP segment with the RST bit set,
as a [stream error](#StreamErrorHandler) ([Section 5.4.2](#StreamErrorHandler)) of type
[CONNECT\_ERROR](#CONNECT_ERROR). Correspondingly, a proxy MUST send a TCP segment with the
RST bit set if it detects an error with the stream or the HTTP/2 connection.[¶](#section-8.5-8)

### [8.6.](#section-8.6) [The Upgrade Header Field](#name-the-upgrade-header-field)

HTTP/2 does not support the 101 (Switching Protocols) informational status code
([Section 15.2.2](https://www.rfc-editor.org/rfc/rfc9110#section-15.2.2) of [[HTTP](#RFC9110)]).[¶](#section-8.6-1)

The semantics of 101 (Switching Protocols) aren't applicable to a multiplexed protocol.
Similar functionality might be enabled through the use of [extended
CONNECT](#RFC8441) [[RFC8441](#RFC8441)], and other protocols are able to use the same mechanisms that HTTP/2 uses to
negotiate their use (see [Section 3](#starting)).[¶](#section-8.6-2)

### [8.7.](#section-8.7) [Request Reliability](#name-request-reliability)

In general, an HTTP client is unable to retry a non-idempotent request when an error
occurs because there is no means to determine the nature of the error (see [Section 9.2.2](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.2) of [[HTTP](#RFC9110)]). It is possible
that some server processing occurred prior to the error, which could result in
undesirable effects if the request were reattempted.[¶](#section-8.7-1)

HTTP/2 provides two mechanisms for providing a guarantee to a client that a request has
not been processed:[¶](#section-8.7-2)

* The [GOAWAY](#GOAWAY) frame indicates the highest stream number that might have
  been processed. Requests on streams with higher numbers are therefore guaranteed to
  be safe to retry.[¶](#section-8.7-3.1)
* The [REFUSED\_STREAM](#REFUSED_STREAM) error code can be included in a
  [RST\_STREAM](#RST_STREAM) frame to indicate that the stream is being closed prior to
  any processing having occurred. Any request that was sent on the reset stream can
  be safely retried.[¶](#section-8.7-3.2)

Requests that have not been processed have not failed; clients MAY automatically retry
them, even those with non-idempotent methods.[¶](#section-8.7-4)

A server MUST NOT indicate that a stream has not been processed unless it can guarantee
that fact. If frames that are on a stream are passed to the application layer for any
stream, then [REFUSED\_STREAM](#REFUSED_STREAM) MUST NOT be used for that stream, and a
[GOAWAY](#GOAWAY) frame MUST include a stream identifier that is greater than or
equal to the given stream identifier.[¶](#section-8.7-5)

In addition to these mechanisms, the [PING](#PING) frame provides a way for a
client to easily test a connection. Connections that remain idle can become broken, because
some middleboxes (for instance, network address translators or load balancers) silently
discard connection bindings. The [PING](#PING) frame allows a client to safely
test whether a connection is still active without sending a request.[¶](#section-8.7-6)

### [8.8.](#section-8.8) [Examples](#name-examples)

This section shows HTTP/1.1 requests and responses, with illustrations of equivalent
HTTP/2 requests and responses.[¶](#section-8.8-1)

#### [8.8.1.](#section-8.8.1) [Simple Request](#name-simple-request)

An HTTP GET request includes control data and a request header with no message content and is therefore
transmitted as a single [HEADERS](#HEADERS) frame, followed by zero or more
[CONTINUATION](#CONTINUATION) frames containing the serialized block of request header
fields. The [HEADERS](#HEADERS) frame in the following has both the END\_HEADERS and
END\_STREAM flags set; no [CONTINUATION](#CONTINUATION) frames are sent.[¶](#section-8.8.1-1)

```

  GET /resource HTTP/1.1           HEADERS
  Host: example.org          ==>     + END_STREAM
  Accept: image/jpeg                 + END_HEADERS
                                       :method = GET
                                       :scheme = https
                                       :authority = example.org
                                       :path = /resource
                                       host = example.org
                                       accept = image/jpeg

```
[¶](#section-8.8.1-2)

#### [8.8.2.](#section-8.8.2) [Simple Response](#name-simple-response)

Similarly, a response that includes only control data and a response header is transmitted as a
[HEADERS](#HEADERS) frame (again, followed by zero or more
[CONTINUATION](#CONTINUATION) frames) containing the serialized block of response header
fields.[¶](#section-8.8.2-1)

```

  HTTP/1.1 304 Not Modified        HEADERS
  ETag: "xyzzy"              ==>     + END_STREAM
  Expires: Thu, 23 Jan ...           + END_HEADERS
                                       :status = 304
                                       etag = "xyzzy"
                                       expires = Thu, 23 Jan ...

```
[¶](#section-8.8.2-2)

#### [8.8.3.](#section-8.8.3) [Complex Request](#name-complex-request)

An HTTP POST request that includes control data and a request header with message content is transmitted
as one [HEADERS](#HEADERS) frame, followed by zero or more
[CONTINUATION](#CONTINUATION) frames containing the request header, followed by one
or more [DATA](#DATA) frames, with the last [CONTINUATION](#CONTINUATION) (or
[HEADERS](#HEADERS)) frame having the END\_HEADERS flag set and the final
[DATA](#DATA) frame having the END\_STREAM flag set:[¶](#section-8.8.3-1)

```

  POST /resource HTTP/1.1          HEADERS
  Host: example.org          ==>     - END_STREAM
  Content-Type: image/jpeg           - END_HEADERS
  Content-Length: 123                  :method = POST
                                       :authority = example.org
                                       :path = /resource
  {binary data}                        :scheme = https

                                   CONTINUATION
                                     + END_HEADERS
                                       content-type = image/jpeg
                                       host = example.org
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}

```
[¶](#section-8.8.3-2)

Note that data contributing to any given field line could be spread between field
block fragments. The allocation of field lines to frames in this example is
illustrative only.[¶](#section-8.8.3-3)

#### [8.8.4.](#section-8.8.4) [Response with Body](#name-response-with-body)

A response that includes control data and a response header with message content is
transmitted as a [HEADERS](#HEADERS) frame, followed by
zero or more [CONTINUATION](#CONTINUATION) frames,
followed by one or more [DATA](#DATA) frames, with the
last [DATA](#DATA) frame in the sequence having the
END\_STREAM flag set:[¶](#section-8.8.4-1)

```

  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==>     - END_STREAM
  Content-Length: 123                + END_HEADERS
                                       :status = 200
  {binary data}                        content-type = image/jpeg
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}

```
[¶](#section-8.8.4-2)

#### [8.8.5.](#section-8.8.5) [Informational Responses](#name-informational-responses)

An informational response using a 1xx status code other than 101 is transmitted as a
[HEADERS](#HEADERS) frame, followed by zero or more
[CONTINUATION](#CONTINUATION) frames.[¶](#section-8.8.5-1)

A trailer section is sent as a field block after both the request or response
field block and all the [DATA](#DATA) frames have been sent. The
[HEADERS](#HEADERS) frame starting the field block that comprises
the trailer section has the END\_STREAM flag set.[¶](#section-8.8.5-2)

The following example includes both a 100 (Continue) status code, which is sent in
response to a request containing a "100-continue" token in the Expect header field,
and a trailer section:[¶](#section-8.8.5-3)

```

  HTTP/1.1 100 Continue            HEADERS
  Extension-Field: bar       ==>     - END_STREAM
                                     + END_HEADERS
                                       :status = 100
                                       extension-field = bar

  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==>     - END_STREAM
  Transfer-Encoding: chunked         + END_HEADERS
  Trailer: Foo                         :status = 200
                                       content-type = image/jpeg
  123                                  trailer = Foo
  {binary data}
  0                                DATA
  Foo: bar                           - END_STREAM
                                   {binary data}

                                   HEADERS
                                     + END_STREAM
                                     + END_HEADERS
                                       foo = bar

```
[¶](#section-8.8.5-4)

## [9.](#section-9) [HTTP/2 Connections](#name-http-2-connections)

This section outlines attributes of HTTP that improve interoperability, reduce exposure to
known security vulnerabilities, or reduce the potential for implementation variation.[¶](#section-9-1)

### [9.1.](#section-9.1) [Connection Management](#name-connection-management)

HTTP/2 connections are persistent. For best performance, it is expected that clients will not
close connections until it is determined that no further communication with a server is
necessary (for example, when a user navigates away from a particular web page) or until
the server closes the connection.[¶](#section-9.1-1)

Clients SHOULD NOT open more than one HTTP/2 connection to a given host and port pair,
where the host is derived from a URI, a selected [alternative
service](#RFC7838) [[ALT-SVC](#RFC7838)], or a configured proxy.[¶](#section-9.1-2)

A client can create additional connections as replacements, either to replace connections
that are near to exhausting the available [stream
identifier space](#StreamIdentifiers) ([Section 5.1.1](#StreamIdentifiers)), to refresh the keying material for a TLS connection, or to
replace connections that have encountered [errors](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)).[¶](#section-9.1-3)

A client MAY open multiple connections to the same IP address and TCP port using different
[Server Name Indication](#RFC6066) [[TLS-EXT](#RFC6066)] values or to provide different TLS
client certificates but SHOULD avoid creating multiple connections with the same
configuration.[¶](#section-9.1-4)

Servers are encouraged to maintain open connections for as long as possible but are
permitted to terminate idle connections if necessary. When either endpoint chooses to
close the transport-layer TCP connection, the terminating endpoint SHOULD first send a
[GOAWAY](#GOAWAY) ([Section 6.8](#GOAWAY)) frame so that both endpoints can reliably
determine whether previously sent frames have been processed and gracefully complete or
terminate any necessary remaining tasks.[¶](#section-9.1-5)

#### [9.1.1.](#section-9.1.1) [Connection Reuse](#name-connection-reuse)

Connections that are made to an origin server, either directly or through a tunnel
created using the [CONNECT method](#CONNECT) ([Section 8.5](#CONNECT)), MAY be reused for
requests with multiple different URI authority components. A connection can be reused
as long as the origin server is [authoritative](#authority) ([Section 10.1](#authority)). For TCP
connections without TLS, this depends on the host having resolved to the same IP
address.[¶](#section-9.1.1-1)

For "`https`" resources, connection reuse additionally depends
on having a certificate that is valid for the host in the URI. The certificate
presented by the server MUST satisfy any checks that the client would perform when
forming a new TLS connection for the host in the URI. A single certificate can be
used to establish authority for multiple origins. [Section 4.3](https://www.rfc-editor.org/rfc/rfc9110#section-4.3) of [[HTTP](#RFC9110)]
describes how a client determines whether a server is authoritative for a URI.[¶](#section-9.1.1-2)

In some deployments, reusing a connection for multiple origins can result in requests
being directed to the wrong origin server. For example, TLS termination might be
performed by a middlebox that uses the TLS [Server Name
Indication](#RFC6066) [[TLS-EXT](#RFC6066)] extension to select an origin server. This means that it is possible
for clients to send requests to servers that might not be the intended target for the
request, even though the server is otherwise authoritative.[¶](#section-9.1.1-3)

A server that does not wish clients to reuse connections can indicate that it is not
authoritative for a request by sending a 421 (Misdirected Request) status code in response
to the request (see [Section 15.5.20](https://www.rfc-editor.org/rfc/rfc9110#section-15.5.20) of [[HTTP](#RFC9110)]).[¶](#section-9.1.1-4)

A client that is configured to use a proxy over HTTP/2 directs requests to that proxy
through a single connection. That is, all requests sent via a proxy reuse the
connection to the proxy.[¶](#section-9.1.1-5)

### [9.2.](#section-9.2) [Use of TLS Features](#name-use-of-tls-features)

Implementations of HTTP/2 MUST use [TLS version 1.2](#RFC5246) [[TLS12](#RFC5246)] or higher
for HTTP/2 over TLS. The general TLS usage guidance in [[TLSBCP](#RFC7525)] SHOULD be
followed, with some additional restrictions that are specific to HTTP/2.[¶](#section-9.2-1)

The TLS implementation MUST support the [Server Name Indication
(SNI)](#RFC6066) [[TLS-EXT](#RFC6066)] extension to TLS. If the server is identified by a [domain name](#RFC8499) [[DNS-TERMS](#RFC8499)], clients MUST send the server\_name TLS extension
unless an alternative mechanism to indicate the target host is used.[¶](#section-9.2-2)

Requirements for deployments of HTTP/2 that negotiate [TLS 1.3](#RFC8446) [[TLS13](#RFC8446)]
are included in [Section 9.2.3](#tls13features). Deployments of TLS 1.2 are subject to
the requirements in Sections [9.2.1](#tls12features) and [9.2.2](#tls12ciphers).
Implementations are encouraged to provide defaults that comply, but it is recognized that
deployments are ultimately responsible for compliance.[¶](#section-9.2-3)

#### [9.2.1.](#section-9.2.1) [TLS 1.2 Features](#name-tls-12-features)

This section describes restrictions on the TLS 1.2 feature set that can be used with
HTTP/2. Due to deployment limitations, it might not be possible to fail TLS negotiation
when these restrictions are not met. An endpoint MAY immediately terminate an HTTP/2
connection that does not meet these TLS requirements with a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type [INADEQUATE\_SECURITY](#INADEQUATE_SECURITY).[¶](#section-9.2.1-1)

A deployment of HTTP/2 over TLS 1.2 MUST disable compression. TLS compression can lead
to the exposure of information that would not otherwise be revealed [[RFC3749](#RFC3749)]. Generic compression is unnecessary, since HTTP/2 provides
compression features that are more aware of context and therefore likely to be more
appropriate for use for performance, security, or other reasons.[¶](#section-9.2.1-2)

A deployment of HTTP/2 over TLS 1.2 MUST disable renegotiation. An endpoint MUST treat
a TLS renegotiation as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler))
of type [PROTOCOL\_ERROR](#PROTOCOL_ERROR). Note that
disabling renegotiation can result in long-lived connections becoming unusable due to
limits on the number of messages the underlying cipher suite can encipher.[¶](#section-9.2.1-3)

An endpoint MAY use renegotiation to provide confidentiality protection for client
credentials offered in the handshake, but any renegotiation MUST occur prior to sending
the connection preface. A server SHOULD request a client certificate if it sees a
renegotiation request immediately after establishing a connection.[¶](#section-9.2.1-4)

This effectively prevents the use of renegotiation in response to a request for a
specific protected resource. A future specification might provide a way to support this
use case. Alternatively, a server might use an [error](#ErrorHandler) ([Section 5.4](#ErrorHandler)) of type [HTTP\_1\_1\_REQUIRED](#HTTP_1_1_REQUIRED) to request that the client
use a protocol that supports renegotiation.[¶](#section-9.2.1-5)

Implementations MUST support ephemeral key exchange sizes of at least 2048 bits for
cipher suites that use ephemeral finite field Diffie-Hellman (DHE) ([Section 8.1.2](https://www.rfc-editor.org/rfc/rfc5246#section-8.1.2) of [[TLS12](#RFC5246)]) and 224 bits for cipher suites that use ephemeral elliptic curve
Diffie-Hellman (ECDHE) [[RFC8422](#RFC8422)]. Clients MUST accept DHE sizes of up to
4096 bits. Endpoints MAY treat negotiation of key sizes smaller than the lower limits
as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type [INADEQUATE\_SECURITY](#INADEQUATE_SECURITY).[¶](#section-9.2.1-6)

#### [9.2.2.](#section-9.2.2) [TLS 1.2 Cipher Suites](#name-tls-12-cipher-suites)

A deployment of HTTP/2 over TLS 1.2 SHOULD NOT use any of the prohibited cipher suites listed in [Appendix A](#BadCipherSuites).[¶](#section-9.2.2-1)

Endpoints MAY choose to generate a [connection
error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type [INADEQUATE\_SECURITY](#INADEQUATE_SECURITY) if one of the prohibited cipher suites is
negotiated. A deployment that chooses to use a prohibited cipher suite risks triggering
a connection error unless the set of potential peers is known to accept that cipher
suite.[¶](#section-9.2.2-2)

Implementations MUST NOT generate this error in reaction to the negotiation of a cipher
suite that is not prohibited. Consequently, when clients offer a cipher suite
that is not prohibited, they have to be prepared to use that cipher suite with
HTTP/2.[¶](#section-9.2.2-3)

The list of prohibited cipher suites includes the cipher suite that TLS 1.2 makes
mandatory, which means that TLS 1.2 deployments could have non-intersecting sets of
permitted cipher suites. To avoid this problem, which causes TLS handshake failures,
deployments of HTTP/2 that use TLS 1.2 MUST support
TLS\_ECDHE\_RSA\_WITH\_AES\_128\_GCM\_SHA256 [[TLS-ECDHE](#RFC5289)] with the P-256 elliptic
curve [[RFC8422](#RFC8422)].[¶](#section-9.2.2-4)

Note that clients might advertise support of cipher suites that are prohibited in
order to allow for connection to servers that do not support HTTP/2. This allows
servers to select HTTP/1.1 with a cipher suite that is prohibited in HTTP/2.
However, this can result in HTTP/2 being negotiated with a prohibited cipher suite if
the application protocol and cipher suite are independently selected.[¶](#section-9.2.2-5)

#### [9.2.3.](#section-9.2.3) [TLS 1.3 Features](#name-tls-13-features)

TLS 1.3 includes a number of features not available in earlier versions. This section
discusses the use of these features.[¶](#section-9.2.3-1)

HTTP/2 servers MUST NOT send post-handshake TLS 1.3 CertificateRequest messages. HTTP/2
clients MUST treat a TLS post-handshake CertificateRequest message as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type [PROTOCOL\_ERROR](#PROTOCOL_ERROR).[¶](#section-9.2.3-2)

The prohibition on post-handshake authentication applies even if the client offered the
"post\_handshake\_auth" TLS extension. Post-handshake authentication support might be
advertised independently of [ALPN](#RFC7301) [[TLS-ALPN](#RFC7301)]. Clients might offer
the capability for use in other protocols, but inclusion of the extension cannot imply
support within HTTP/2.[¶](#section-9.2.3-3)

[[TLS13](#RFC8446)] defines other post-handshake messages, NewSessionTicket and
KeyUpdate, which can be used as they have no direct interaction with HTTP/2. Unless the
use of a new type of TLS message depends on an interaction with the application-layer
protocol, that TLS message can be sent after the handshake completes.[¶](#section-9.2.3-4)

TLS early data MAY be used to send requests, provided that the guidance in [[RFC8470](#RFC8470)] is observed. Clients send requests in early data assuming initial
values for all server settings.[¶](#section-9.2.3-5)

## [10.](#section-10) [Security Considerations](#name-security-considerations)

The use of TLS is necessary to provide many of the security properties of this protocol.
Many of the claims in this section do not hold unless TLS is used as described in [Section 9.2](#TLSUsage).[¶](#section-10-1)

### [10.1.](#section-10.1) [Server Authority](#name-server-authority)

HTTP/2 relies on the HTTP definition of authority for determining whether a server is
authoritative in providing a given response (see [Section 4.3](https://www.rfc-editor.org/rfc/rfc9110#section-4.3) of [[HTTP](#RFC9110)]).
This relies on local name resolution for the "`http`" URI scheme and the authenticated server
identity for the "`https`" scheme.[¶](#section-10.1-1)

### [10.2.](#section-10.2) [Cross-Protocol Attacks](#name-cross-protocol-attacks)

In a cross-protocol attack, an attacker causes a client to initiate a transaction in one
protocol toward a server that understands a different protocol. An attacker might be able
to cause the transaction to appear as a valid transaction in the second protocol. In
combination with the capabilities of the web context, this can be used to interact with
poorly protected servers in private networks.[¶](#section-10.2-1)

Completing a TLS handshake with an ALPN identifier for HTTP/2 can be considered sufficient
protection against cross-protocol attacks. ALPN provides a positive indication that a
server is willing to proceed with HTTP/2, which prevents attacks on other TLS-based
protocols.[¶](#section-10.2-2)

The encryption in TLS makes it difficult for attackers to control the data that could be
used in a cross-protocol attack on a cleartext protocol.[¶](#section-10.2-3)

The cleartext version of HTTP/2 has minimal protection against cross-protocol attacks.
The [connection preface](#preface) ([Section 3.4](#preface)) contains a string that is
designed to confuse HTTP/1.1 servers, but no special protection is offered for other
protocols.[¶](#section-10.2-4)

### [10.3.](#section-10.3) [Intermediary Encapsulation Attacks](#name-intermediary-encapsulation-)

HPACK permits encoding of field names and values that might be treated as delimiters in
other HTTP versions. An intermediary that translates an HTTP/2 request or response MUST
validate fields according to the rules in [Section 8.2](#HttpHeaders) before
translating a message to another HTTP version. Translating a field that includes invalid
delimiters could be used to cause recipients to incorrectly interpret a message, which
could be exploited by an attacker.[¶](#section-10.3-1)

[Section 8.2](#HttpHeaders) does not include specific rules for validation of
pseudo-header fields. If the values of these fields are used, additional validation is
necessary. This is particularly important where "`:scheme`", "`:authority`", and
"`:path`" are combined to form a single URI string [[RFC3986](#RFC3986)]. Similar problems might occur when that URI or just "`:path`" is
combined with "`:method`" to construct a request line (as in [Section 3](https://www.rfc-editor.org/rfc/rfc9112#section-3) of [[HTTP/1.1](#RFC9112)]). Simple concatenation is not secure unless the input values are fully
validated.[¶](#section-10.3-2)

An intermediary can reject fields that contain invalid field names or values for other
reasons -- in particular, those fields that do not conform to the HTTP ABNF grammar from [Section 5](https://www.rfc-editor.org/rfc/rfc9110#section-5) of [[HTTP](#RFC9110)]. Intermediaries that do not perform any validation of fields
other than the minimum required by [Section 8.2](#HttpHeaders) could forward messages
that contain invalid field names or values.[¶](#section-10.3-3)

An intermediary that receives any fields that require removal before forwarding
(see [Section 7.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.6.1) of [[HTTP](#RFC9110)]) MUST remove or replace those header fields when
forwarding messages. Additionally, intermediaries should take care when forwarding messages
containing `Content-Length` fields to ensure that the message is [well-formed](#malformed) ([Section 8.1.1](#malformed)).
This ensures that if the message is translated into HTTP/1.1 at any point, the framing will be correct.[¶](#section-10.3-4)

### [10.4.](#section-10.4) [Cacheability of Pushed Responses](#name-cacheability-of-pushed-resp)

Pushed responses do not have an explicit request from the client; the request
is provided by the server in the [PUSH\_PROMISE](#PUSH_PROMISE) frame.[¶](#section-10.4-1)

Caching responses that are pushed is possible based on the guidance provided by the origin
server in the Cache-Control header field. However, this can cause issues if a single
server hosts more than one tenant. For example, a server might offer multiple users each
a small portion of its URI space.[¶](#section-10.4-2)

Where multiple tenants share space on the same server, that server MUST ensure that
tenants are not able to push representations of resources that they do not have authority
over. Failure to enforce this would allow a tenant to provide a representation that would
be served out of cache, overriding the actual representation that the authoritative tenant
provides.[¶](#section-10.4-3)

Pushed responses for which an origin server is not authoritative (see
[Section 10.1](#authority)) MUST NOT be used or cached.[¶](#section-10.4-4)

### [10.5.](#section-10.5) [Denial-of-Service Considerations](#name-denial-of-service-considera)

An HTTP/2 connection can demand a greater commitment of resources to operate than an
HTTP/1.1 connection. Both field section compression and flow control depend on a
commitment of a greater amount of state. Settings for these
features ensure that memory commitments for these features are strictly bounded.[¶](#section-10.5-1)

The number of [PUSH\_PROMISE](#PUSH_PROMISE) frames is not
constrained in the same fashion. A client that accepts server push SHOULD limit the
number of streams it allows to be in the "reserved (remote)" state. An excessive number
of server push streams can be treated as a [stream
error](#StreamErrorHandler) ([Section 5.4.2](#StreamErrorHandler)) of type [ENHANCE\_YOUR\_CALM](#ENHANCE_YOUR_CALM).[¶](#section-10.5-2)

A number of HTTP/2 implementations were found to be vulnerable to denial of service [[NFLX-2019-002](#NFLX-2019-002)]. Below is a list of known ways that implementations might be
subject to denial-of-service attacks:[¶](#section-10.5-3)

* Inefficient tracking of outstanding outbound frames can lead to overload if an adversary can
  cause large numbers of frames to be enqueued for sending. A peer could use one of
  several techniques to cause large numbers of frames to be generated:[¶](#section-10.5-4.1.1)

  + Providing tiny increments to flow control in [WINDOW\_UPDATE](#WINDOW_UPDATE) frames can cause a sender to generate a large
    number of [DATA](#DATA) frames.[¶](#section-10.5-4.1.2.1)
  + An endpoint is required to respond to a [PING](#PING) frame.[¶](#section-10.5-4.1.2.2)
  + Each [SETTINGS](#SETTINGS) frame requires
    acknowledgment.[¶](#section-10.5-4.1.2.3)
  + An invalid request (or server push) can cause a peer to send [RST\_STREAM](#RST_STREAM) frames in response.[¶](#section-10.5-4.1.2.4)
* An attacker can provide large amounts of flow-control credit at the HTTP/2 layer but
  withhold credit at the TCP layer, preventing frames from being sent. An endpoint that
  constructs and remembers frames for sending without considering TCP limits might be
  subject to resource exhaustion.[¶](#section-10.5-4.2)
* Large numbers of small or empty frames can be abused to cause a peer to expend time
  processing frame headers. Caution is required here as some uses of small frames are
  entirely legitimate, such as the sending of an empty [DATA](#DATA) or [CONTINUATION](#CONTINUATION) frame at the end of a stream.[¶](#section-10.5-4.3)
* The [SETTINGS](#SETTINGS) frame might also be abused to
  cause a peer to expend additional processing time. This might be done by pointlessly
  changing settings, sending multiple undefined settings, or changing the
  same setting multiple times in the same frame.[¶](#section-10.5-4.4)
* Handling reprioritization with [PRIORITY](#PRIORITY)
  frames can require significant processing time and can lead to overload if many [PRIORITY](#PRIORITY) frames are sent.[¶](#section-10.5-4.5)
* Field section compression also provides opportunities for an attacker to waste
  processing resources; see [Section 7](https://www.rfc-editor.org/rfc/rfc7541#section-7) of [[COMPRESSION](#RFC7541)] for more details on
  potential abuses.[¶](#section-10.5-4.6)
* Limits in [SETTINGS](#SETTINGS) cannot be reduced
  instantaneously, which leaves an endpoint exposed to behavior from a peer that could
  exceed the new limits. In particular, immediately after establishing a connection,
  limits set by a server are not known to clients and could be exceeded without being an
  obvious protocol violation.[¶](#section-10.5-4.7)

Most of the features that might be exploited for denial of service -- such as [SETTINGS](#SETTINGS) changes, small frames, field section
compression -- have legitimate uses. These features become a burden only when they are
used unnecessarily or to excess.[¶](#section-10.5-5)

An endpoint that doesn't monitor use of these features exposes itself to a risk of
denial of service. Implementations SHOULD track the use of these features and set
limits on their use. An endpoint MAY treat activity that is suspicious as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type [ENHANCE\_YOUR\_CALM](#ENHANCE_YOUR_CALM).[¶](#section-10.5-6)

#### [10.5.1.](#section-10.5.1) [Limits on Field Block Size](#name-limits-on-field-block-size)

A large [field block](#FieldBlock) ([Section 4.3](#FieldBlock)) can cause an implementation to
commit a large amount of state. Field lines that are critical for routing can appear
toward the end of a field block, which prevents streaming of fields to their
ultimate destination. This ordering and other reasons, such as ensuring cache
correctness, mean that an endpoint might need to buffer the entire field block. Since
there is no hard limit to the size of a field block, some endpoints could be forced to
commit a large amount of available memory for field blocks.[¶](#section-10.5.1-1)

An endpoint can use the [SETTINGS\_MAX\_HEADER\_LIST\_SIZE](#SETTINGS_MAX_HEADER_LIST_SIZE) to advise peers of
limits that might apply on the size of uncompressed field blocks. This setting is only advisory, so
endpoints MAY choose to send field blocks that exceed this limit and risk the
request or response being treated as malformed. This setting is specific to a
connection, so any request or response could encounter a hop with a lower, unknown
limit. An intermediary can attempt to avoid this problem by passing on values presented
by different peers, but they are not obliged to do so.[¶](#section-10.5.1-2)

A server that receives a larger field block than it is willing to handle can send an
HTTP 431 (Request Header Fields Too Large) status code [[RFC6585](#RFC6585)]. A
client can discard responses that it cannot process. The field block MUST be processed
to ensure a consistent connection state, unless the connection is closed.[¶](#section-10.5.1-3)

#### [10.5.2.](#section-10.5.2) [CONNECT Issues](#name-connect-issues)

The CONNECT method can be used to create disproportionate load on a proxy, since stream
creation is relatively inexpensive when compared to the creation and maintenance of a
TCP connection. A proxy might also maintain some resources for a TCP connection beyond
the closing of the stream that carries the CONNECT request, since the outgoing TCP
connection remains in the TIME\_WAIT state. Therefore, a proxy cannot rely on
[SETTINGS\_MAX\_CONCURRENT\_STREAMS](#SETTINGS_MAX_CONCURRENT_STREAMS) alone to limit the resources consumed by
CONNECT requests.[¶](#section-10.5.2-1)

### [10.6.](#section-10.6) [Use of Compression](#name-use-of-compression)

Compression can allow an attacker to recover secret data when it is compressed in the same
context as data under attacker control. HTTP/2 enables compression of field lines
([Section 4.3](#FieldBlock)); the following concerns also apply to the use of HTTP
compressed content-codings ([Section 8.4.1](https://www.rfc-editor.org/rfc/rfc9110#section-8.4.1) of [[HTTP](#RFC9110)]).[¶](#section-10.6-1)

There are demonstrable attacks on compression that exploit the characteristics of the Web
(e.g., [[BREACH](#BREACH)]). The attacker induces multiple requests containing
varying plaintext, observing the length of the resulting ciphertext in each, which
reveals a shorter length when a guess about the secret is correct.[¶](#section-10.6-2)

Implementations communicating on a secure channel MUST NOT compress content that includes
both confidential and attacker-controlled data unless separate compression dictionaries
are used for each source of data. Compression MUST NOT be used if the source of data
cannot be reliably determined. Generic stream compression, such as that provided by TLS,
MUST NOT be used with HTTP/2 (see [Section 9.2](#TLSUsage)).[¶](#section-10.6-3)

Further considerations regarding the compression of header fields are described in [[COMPRESSION](#RFC7541)].[¶](#section-10.6-4)

### [10.7.](#section-10.7) [Use of Padding](#name-use-of-padding)

Padding within HTTP/2 is not intended as a replacement for general purpose padding, such
as that provided by [TLS](#RFC8446) [[TLS13](#RFC8446)]. Redundant padding could even be
counterproductive. Correct application can depend on having specific knowledge of the
data that is being padded.[¶](#section-10.7-1)

To mitigate attacks that rely on compression, disabling or limiting compression might be
preferable to padding as a countermeasure.[¶](#section-10.7-2)

Padding can be used to obscure the exact size of frame content and is provided to
mitigate specific attacks within HTTP -- for example, attacks where compressed content
includes both attacker-controlled plaintext and secret data (e.g., [[BREACH](#BREACH)]).[¶](#section-10.7-3)

Use of padding can result in less protection than might seem immediately obvious. At
best, padding only makes it more difficult for an attacker to infer length information by
increasing the number of frames an attacker has to observe. Incorrectly implemented
padding schemes can be easily defeated. In particular, randomized padding with a
predictable distribution provides very little protection; similarly, padding frame payloads to a
fixed size exposes information as frame payload sizes cross the fixed-sized boundary, which could
be possible if an attacker can control plaintext.[¶](#section-10.7-4)

Intermediaries SHOULD retain padding for [DATA](#DATA) frames but MAY drop padding
for [HEADERS](#HEADERS) and [PUSH\_PROMISE](#PUSH_PROMISE) frames. A valid reason for an
intermediary to change the amount of padding of frames is to improve the protections that
padding provides.[¶](#section-10.7-5)

### [10.8.](#section-10.8) [Privacy Considerations](#name-privacy-considerations)

Several characteristics of HTTP/2 provide an observer an opportunity to correlate actions
of a single client or server over time. These include the values of settings, the manner
in which flow-control windows are managed, the way priorities are allocated to streams,
the timing of reactions to stimulus, and the handling of any features that are controlled by
settings.[¶](#section-10.8-1)

As far as these create observable differences in behavior, they could be used as a basis
for fingerprinting a specific client, as defined in [Section 3.2](https://www.rfc-editor.org/rfc/rfc6973#section-3.2) of [[PRIVACY](#RFC6973)].[¶](#section-10.8-2)

HTTP/2's preference for using a single TCP connection allows correlation of a user's
activity on a site. Reusing connections for different origins allows tracking
across those origins.[¶](#section-10.8-3)

Because the PING and SETTINGS frames solicit immediate responses, they can be used by an
endpoint to measure latency to their peer. This might have privacy implications in
certain scenarios.[¶](#section-10.8-4)

### [10.9.](#section-10.9) [Remote Timing Attacks](#name-remote-timing-attacks)

Remote timing attacks extract secrets from servers by observing variations in the time
that servers take when processing requests that use secrets. HTTP/2 enables concurrent
request creation and processing, which can give attackers better control over when request
processing commences. Multiple HTTP/2 requests can be included in the same IP packet or
TLS record. HTTP/2 can therefore make remote timing attacks more efficient by eliminating
variability in request delivery, leaving only request order and the delivery of responses
as sources of timing variability.[¶](#section-10.9-1)

Ensuring that processing time is not dependent on the value of a secret is the best
defense against any form of timing attack.[¶](#section-10.9-2)

## [11.](#section-11) [IANA Considerations](#name-iana-considerations)

This revision of HTTP/2 marks the `HTTP2-Settings` header field and the
`h2c` upgrade token, both defined in [[RFC7540](#RFC7540)], as obsolete.[¶](#section-11-1)

[Section 11](https://www.rfc-editor.org/rfc/rfc7540#section-11) of [[RFC7540](#RFC7540)] registered the `h2` and `h2c` ALPN
identifiers along with the `PRI` HTTP method. RFC 7540 also established a registry
for frame types, settings, and error codes. These registrations and registries apply to
HTTP/2, but are not redefined in this document.[¶](#section-11-2)

IANA has updated references to RFC 7540 in the
following registries to refer to this document: "TLS
Application-Layer Protocol Negotiation (ALPN) Protocol IDs",
"HTTP/2 Frame Type", "HTTP/2 Settings", "HTTP/2 Error Code",
and "HTTP Method Registry". The registration of the
`PRI` method has been updated to refer to [Section 3.4](#preface); all other section numbers have not
changed.[¶](#section-11-3)

IANA has changed the policy on those portions of the "HTTP/2
Frame Type" and "HTTP/2 Settings" registries that were
reserved for Experimental Use in RFC 7540. These portions of
the registries shall operate on the same policy as the
remainder of each registry.[¶](#section-11-4)

### [11.1.](#section-11.1) [HTTP2-Settings Header Field Registration](#name-http2-settings-header-field)

This section marks the `HTTP2-Settings` header field registered by [Section 11.5](https://www.rfc-editor.org/rfc/rfc7540#section-11.5) of [[RFC7540](#RFC7540)] in the "Hypertext Transfer Protocol (HTTP) Field Name
Registry" as obsolete. This capability has been removed: see [Section 3.1](#versioning).
The registration is updated to include the details as required by [Section 18.4](https://www.rfc-editor.org/rfc/rfc9110#section-18.4) of [[HTTP](#RFC9110)]:[¶](#section-11.1-1)

Field Name:
HTTP2-Settings[¶](#section-11.1-2.2)

Status:
obsoleted[¶](#section-11.1-2.4)

Reference:
[Section 3.2.1](https://www.rfc-editor.org/rfc/rfc7540#section-3.2.1) of [[RFC7540](#RFC7540)][¶](#section-11.1-2.6)

Comments:
Obsolete; see [Section 11.1](#HTTP2-Settings) of this document.[¶](#section-11.1-2.8)

### [11.2.](#section-11.2) [The h2c Upgrade Token](#name-the-h2c-upgrade-token)

This section records the `h2c` upgrade token registered by [Section 11.8](https://www.rfc-editor.org/rfc/rfc7540#section-11.8) of [[RFC7540](#RFC7540)] in the "Hypertext Transfer Protocol (HTTP) Upgrade Token Registry" as
obsolete. This capability has been removed: see [Section 3.1](#versioning). The
registration is updated as follows:[¶](#section-11.2-1)

Value:
h2c[¶](#section-11.2-2.2)

Description:
(OBSOLETE) Hypertext Transfer Protocol version 2 (HTTP/2)[¶](#section-11.2-2.4)

Expected Version Tokens:
None[¶](#section-11.2-2.6)

Reference:
[Section 3.1](#versioning) of this document[¶](#section-11.2-2.8)

## [12.](#section-12) [References](#name-references)

### [12.1.](#section-12.1) [Normative References](#name-normative-references)

[CACHING]
Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., "HTTP Caching", STD 98, RFC 9111, DOI 10.17487/RFC9111, June 2022, <<https://www.rfc-editor.org/info/rfc9111>>.

[COMPRESSION]
Peon, R. and H. Ruellan, "HPACK: Header Compression for HTTP/2", RFC 7541, DOI 10.17487/RFC7541, May 2015, <<https://www.rfc-editor.org/info/rfc7541>>.

[COOKIE]
Barth, A., "HTTP State Management Mechanism", RFC 6265, DOI 10.17487/RFC6265, April 2011, <<https://www.rfc-editor.org/info/rfc6265>>.

[HTTP]
Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., "HTTP Semantics", STD 97, RFC 9110, DOI 10.17487/RFC9110, June 2022, <<https://www.rfc-editor.org/info/rfc9110>>.

[QUIC]
Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based Multiplexed and Secure Transport", RFC 9000, DOI 10.17487/RFC9000, May 2021, <<https://www.rfc-editor.org/info/rfc9000>>.

[RFC2119]
Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <<https://www.rfc-editor.org/info/rfc2119>>.

[RFC3986]
Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform Resource Identifier (URI): Generic Syntax", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <<https://www.rfc-editor.org/info/rfc3986>>.

[RFC8174]
Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <<https://www.rfc-editor.org/info/rfc8174>>.

[RFC8422]
Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, "Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier", RFC 8422, DOI 10.17487/RFC8422, August 2018, <<https://www.rfc-editor.org/info/rfc8422>>.

[RFC8470]
Thomson, M., Nottingham, M., and W. Tarreau, "Using Early Data in HTTP", RFC 8470, DOI 10.17487/RFC8470, September 2018, <<https://www.rfc-editor.org/info/rfc8470>>.

[TCP]
Postel, J., "Transmission Control Protocol", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <<https://www.rfc-editor.org/info/rfc793>>.

[TLS-ALPN]
Friedl, S., Popov, A., Langley, A., and E. Stephan, "Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301, July 2014, <<https://www.rfc-editor.org/info/rfc7301>>.

[TLS-ECDHE]
Rescorla, E., "TLS Elliptic Curve Cipher Suites with SHA-256/384 and AES Galois Counter Mode (GCM)", RFC 5289, DOI 10.17487/RFC5289, August 2008, <<https://www.rfc-editor.org/info/rfc5289>>.

[TLS-EXT]
Eastlake 3rd, D., "Transport Layer Security (TLS) Extensions: Extension Definitions", RFC 6066, DOI 10.17487/RFC6066, January 2011, <<https://www.rfc-editor.org/info/rfc6066>>.

[TLS12]
Dierks, T. and E. Rescorla, "The Transport Layer Security (TLS) Protocol Version 1.2", RFC 5246, DOI 10.17487/RFC5246, August 2008, <<https://www.rfc-editor.org/info/rfc5246>>.

[TLS13]
Rescorla, E., "The Transport Layer Security (TLS) Protocol Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018, <<https://www.rfc-editor.org/info/rfc8446>>.

[TLSBCP]
Sheffer, Y., Holz, R., and P. Saint-Andre, "Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May 2015, <<https://www.rfc-editor.org/info/rfc7525>>.

### [12.2.](#section-12.2) [Informative References](#name-informative-references)

[ALT-SVC]
Nottingham, M., McManus, P., and J. Reschke, "HTTP Alternative Services", RFC 7838, DOI 10.17487/RFC7838, April 2016, <<https://www.rfc-editor.org/info/rfc7838>>.

[BREACH]
Gluck, Y., Harris, N., and A. Prado, "BREACH: Reviving the CRIME Attack", 12 July 2013, <[https://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf](https://breachattack.com/resources/BREACH%20-%20SSL%2C%20gone%20in%2030%20seconds.pdf)>.

[DNS-TERMS]
Hoffman, P., Sullivan, A., and K. Fujiwara, "DNS Terminology", BCP 219, RFC 8499, DOI 10.17487/RFC8499, January 2019, <<https://www.rfc-editor.org/info/rfc8499>>.

[HTTP-PRIORITY]
Oku, K. and L. Pardue, "Extensible Prioritization Scheme for HTTP", RFC 9218, DOI 10.17487/RFC9218, June 2022, <<https://www.rfc-editor.org/info/rfc9218>>.

[HTTP/1.1]
Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., "HTTP/1.1", STD 99, RFC 9112, DOI 10.17487/RFC9112, June 2022, <<https://www.rfc-editor.org/info/rfc9112>>.

[NFLX-2019-002]
Netflix, "HTTP/2 Denial of Service Advisory", 13 August 2019, <<https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md>>.

[PRIVACY]
Cooper, A., Tschofenig, H., Aboba, B., Peterson, J., Morris, J., Hansen, M., and R. Smith, "Privacy Considerations for Internet Protocols", RFC 6973, DOI 10.17487/RFC6973, July 2013, <<https://www.rfc-editor.org/info/rfc6973>>.

[RFC1122]
Braden, R., Ed., "Requirements for Internet Hosts - Communication Layers", STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, <<https://www.rfc-editor.org/info/rfc1122>>.

[RFC3749]
Hollenbeck, S., "Transport Layer Security Protocol Compression Methods", RFC 3749, DOI 10.17487/RFC3749, May 2004, <<https://www.rfc-editor.org/info/rfc3749>>.

[RFC6125]
Saint-Andre, P. and J. Hodges, "Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)", RFC 6125, DOI 10.17487/RFC6125, March 2011, <<https://www.rfc-editor.org/info/rfc6125>>.

[RFC6585]
Nottingham, M. and R. Fielding, "Additional HTTP Status Codes", RFC 6585, DOI 10.17487/RFC6585, April 2012, <<https://www.rfc-editor.org/info/rfc6585>>.

[RFC7323]
Borman, D., Braden, B., Jacobson, V., and R. Scheffenegger, Ed., "TCP Extensions for High Performance", RFC 7323, DOI 10.17487/RFC7323, September 2014, <<https://www.rfc-editor.org/info/rfc7323>>.

[RFC7540]
Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext Transfer Protocol Version 2 (HTTP/2)", RFC 7540, DOI 10.17487/RFC7540, May 2015, <<https://www.rfc-editor.org/info/rfc7540>>.

[RFC8441]
McManus, P., "Bootstrapping WebSockets with HTTP/2", RFC 8441, DOI 10.17487/RFC8441, September 2018, <<https://www.rfc-editor.org/info/rfc8441>>.

[RFC8740]
Benjamin, D., "Using TLS 1.3 with HTTP/2", RFC 8740, DOI 10.17487/RFC8740, February 2020, <<https://www.rfc-editor.org/info/rfc8740>>.

[TALKING]
Huang, L., Chen, E., Barth, A., Rescorla, E., and C. Jackson, "Talking to Yourself for Fun and Profit", 2011, <<https://www.adambarth.com/papers/2011/huang-chen-barth-rescorla-jackson.pdf>>.

## [Appendix A.](#appendix-A) [Prohibited TLS 1.2 Cipher Suites](#name-prohibited-tls-12-cipher-su)

An HTTP/2 implementation MAY treat the negotiation of any of the following cipher suites
with TLS 1.2 as a [connection error](#ConnectionErrorHandler) ([Section 5.4.1](#ConnectionErrorHandler)) of type
[INADEQUATE\_SECURITY](#INADEQUATE_SECURITY):[¶](#appendix-A-1)

* TLS\_NULL\_WITH\_NULL\_NULL[¶](#appendix-A-2.1)
* TLS\_RSA\_WITH\_NULL\_MD5[¶](#appendix-A-2.2)
* TLS\_RSA\_WITH\_NULL\_SHA[¶](#appendix-A-2.3)
* TLS\_RSA\_EXPORT\_WITH\_RC4\_40\_MD5[¶](#appendix-A-2.4)
* TLS\_RSA\_WITH\_RC4\_128\_MD5[¶](#appendix-A-2.5)
* TLS\_RSA\_WITH\_RC4\_128\_SHA[¶](#appendix-A-2.6)
* TLS\_RSA\_EXPORT\_WITH\_RC2\_CBC\_40\_MD5[¶](#appendix-A-2.7)
* TLS\_RSA\_WITH\_IDEA\_CBC\_SHA[¶](#appendix-A-2.8)
* TLS\_RSA\_EXPORT\_WITH\_DES40\_CBC\_SHA[¶](#appendix-A-2.9)
* TLS\_RSA\_WITH\_DES\_CBC\_SHA[¶](#appendix-A-2.10)
* TLS\_RSA\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.11)
* TLS\_DH\_DSS\_EXPORT\_WITH\_DES40\_CBC\_SHA[¶](#appendix-A-2.12)
* TLS\_DH\_DSS\_WITH\_DES\_CBC\_SHA[¶](#appendix-A-2.13)
* TLS\_DH\_DSS\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.14)
* TLS\_DH\_RSA\_EXPORT\_WITH\_DES40\_CBC\_SHA[¶](#appendix-A-2.15)
* TLS\_DH\_RSA\_WITH\_DES\_CBC\_SHA[¶](#appendix-A-2.16)
* TLS\_DH\_RSA\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.17)
* TLS\_DHE\_DSS\_EXPORT\_WITH\_DES40\_CBC\_SHA[¶](#appendix-A-2.18)
* TLS\_DHE\_DSS\_WITH\_DES\_CBC\_SHA[¶](#appendix-A-2.19)
* TLS\_DHE\_DSS\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.20)
* TLS\_DHE\_RSA\_EXPORT\_WITH\_DES40\_CBC\_SHA[¶](#appendix-A-2.21)
* TLS\_DHE\_RSA\_WITH\_DES\_CBC\_SHA[¶](#appendix-A-2.22)
* TLS\_DHE\_RSA\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.23)
* TLS\_DH\_anon\_EXPORT\_WITH\_RC4\_40\_MD5[¶](#appendix-A-2.24)
* TLS\_DH\_anon\_WITH\_RC4\_128\_MD5[¶](#appendix-A-2.25)
* TLS\_DH\_anon\_EXPORT\_WITH\_DES40\_CBC\_SHA[¶](#appendix-A-2.26)
* TLS\_DH\_anon\_WITH\_DES\_CBC\_SHA[¶](#appendix-A-2.27)
* TLS\_DH\_anon\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.28)
* TLS\_KRB5\_WITH\_DES\_CBC\_SHA[¶](#appendix-A-2.29)
* TLS\_KRB5\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.30)
* TLS\_KRB5\_WITH\_RC4\_128\_SHA[¶](#appendix-A-2.31)
* TLS\_KRB5\_WITH\_IDEA\_CBC\_SHA[¶](#appendix-A-2.32)
* TLS\_KRB5\_WITH\_DES\_CBC\_MD5[¶](#appendix-A-2.33)
* TLS\_KRB5\_WITH\_3DES\_EDE\_CBC\_MD5[¶](#appendix-A-2.34)
* TLS\_KRB5\_WITH\_RC4\_128\_MD5[¶](#appendix-A-2.35)
* TLS\_KRB5\_WITH\_IDEA\_CBC\_MD5[¶](#appendix-A-2.36)
* TLS\_KRB5\_EXPORT\_WITH\_DES\_CBC\_40\_SHA[¶](#appendix-A-2.37)
* TLS\_KRB5\_EXPORT\_WITH\_RC2\_CBC\_40\_SHA[¶](#appendix-A-2.38)
* TLS\_KRB5\_EXPORT\_WITH\_RC4\_40\_SHA[¶](#appendix-A-2.39)
* TLS\_KRB5\_EXPORT\_WITH\_DES\_CBC\_40\_MD5[¶](#appendix-A-2.40)
* TLS\_KRB5\_EXPORT\_WITH\_RC2\_CBC\_40\_MD5[¶](#appendix-A-2.41)
* TLS\_KRB5\_EXPORT\_WITH\_RC4\_40\_MD5[¶](#appendix-A-2.42)
* TLS\_PSK\_WITH\_NULL\_SHA[¶](#appendix-A-2.43)
* TLS\_DHE\_PSK\_WITH\_NULL\_SHA[¶](#appendix-A-2.44)
* TLS\_RSA\_PSK\_WITH\_NULL\_SHA[¶](#appendix-A-2.45)
* TLS\_RSA\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.46)
* TLS\_DH\_DSS\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.47)
* TLS\_DH\_RSA\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.48)
* TLS\_DHE\_DSS\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.49)
* TLS\_DHE\_RSA\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.50)
* TLS\_DH\_anon\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.51)
* TLS\_RSA\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.52)
* TLS\_DH\_DSS\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.53)
* TLS\_DH\_RSA\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.54)
* TLS\_DHE\_DSS\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.55)
* TLS\_DHE\_RSA\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.56)
* TLS\_DH\_anon\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.57)
* TLS\_RSA\_WITH\_NULL\_SHA256[¶](#appendix-A-2.58)
* TLS\_RSA\_WITH\_AES\_128\_CBC\_SHA256[¶](#appendix-A-2.59)
* TLS\_RSA\_WITH\_AES\_256\_CBC\_SHA256[¶](#appendix-A-2.60)
* TLS\_DH\_DSS\_WITH\_AES\_128\_CBC\_SHA256[¶](#appendix-A-2.61)
* TLS\_DH\_RSA\_WITH\_AES\_128\_CBC\_SHA256[¶](#appendix-A-2.62)
* TLS\_DHE\_DSS\_WITH\_AES\_128\_CBC\_SHA256[¶](#appendix-A-2.63)
* TLS\_RSA\_WITH\_CAMELLIA\_128\_CBC\_SHA[¶](#appendix-A-2.64)
* TLS\_DH\_DSS\_WITH\_CAMELLIA\_128\_CBC\_SHA[¶](#appendix-A-2.65)
* TLS\_DH\_RSA\_WITH\_CAMELLIA\_128\_CBC\_SHA[¶](#appendix-A-2.66)
* TLS\_DHE\_DSS\_WITH\_CAMELLIA\_128\_CBC\_SHA[¶](#appendix-A-2.67)
* TLS\_DHE\_RSA\_WITH\_CAMELLIA\_128\_CBC\_SHA[¶](#appendix-A-2.68)
* TLS\_DH\_anon\_WITH\_CAMELLIA\_128\_CBC\_SHA[¶](#appendix-A-2.69)
* TLS\_DHE\_RSA\_WITH\_AES\_128\_CBC\_SHA256[¶](#appendix-A-2.70)
* TLS\_DH\_DSS\_WITH\_AES\_256\_CBC\_SHA256[¶](#appendix-A-2.71)
* TLS\_DH\_RSA\_WITH\_AES\_256\_CBC\_SHA256[¶](#appendix-A-2.72)
* TLS\_DHE\_DSS\_WITH\_AES\_256\_CBC\_SHA256[¶](#appendix-A-2.73)
* TLS\_DHE\_RSA\_WITH\_AES\_256\_CBC\_SHA256[¶](#appendix-A-2.74)
* TLS\_DH\_anon\_WITH\_AES\_128\_CBC\_SHA256[¶](#appendix-A-2.75)
* TLS\_DH\_anon\_WITH\_AES\_256\_CBC\_SHA256[¶](#appendix-A-2.76)
* TLS\_RSA\_WITH\_CAMELLIA\_256\_CBC\_SHA[¶](#appendix-A-2.77)
* TLS\_DH\_DSS\_WITH\_CAMELLIA\_256\_CBC\_SHA[¶](#appendix-A-2.78)
* TLS\_DH\_RSA\_WITH\_CAMELLIA\_256\_CBC\_SHA[¶](#appendix-A-2.79)
* TLS\_DHE\_DSS\_WITH\_CAMELLIA\_256\_CBC\_SHA[¶](#appendix-A-2.80)
* TLS\_DHE\_RSA\_WITH\_CAMELLIA\_256\_CBC\_SHA[¶](#appendix-A-2.81)
* TLS\_DH\_anon\_WITH\_CAMELLIA\_256\_CBC\_SHA[¶](#appendix-A-2.82)
* TLS\_PSK\_WITH\_RC4\_128\_SHA[¶](#appendix-A-2.83)
* TLS\_PSK\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.84)
* TLS\_PSK\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.85)
* TLS\_PSK\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.86)
* TLS\_DHE\_PSK\_WITH\_RC4\_128\_SHA[¶](#appendix-A-2.87)
* TLS\_DHE\_PSK\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.88)
* TLS\_DHE\_PSK\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.89)
* TLS\_DHE\_PSK\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.90)
* TLS\_RSA\_PSK\_WITH\_RC4\_128\_SHA[¶](#appendix-A-2.91)
* TLS\_RSA\_PSK\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.92)
* TLS\_RSA\_PSK\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.93)
* TLS\_RSA\_PSK\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.94)
* TLS\_RSA\_WITH\_SEED\_CBC\_SHA[¶](#appendix-A-2.95)
* TLS\_DH\_DSS\_WITH\_SEED\_CBC\_SHA[¶](#appendix-A-2.96)
* TLS\_DH\_RSA\_WITH\_SEED\_CBC\_SHA[¶](#appendix-A-2.97)
* TLS\_DHE\_DSS\_WITH\_SEED\_CBC\_SHA[¶](#appendix-A-2.98)
* TLS\_DHE\_RSA\_WITH\_SEED\_CBC\_SHA[¶](#appendix-A-2.99)
* TLS\_DH\_anon\_WITH\_SEED\_CBC\_SHA[¶](#appendix-A-2.100)
* TLS\_RSA\_WITH\_AES\_128\_GCM\_SHA256[¶](#appendix-A-2.101)
* TLS\_RSA\_WITH\_AES\_256\_GCM\_SHA384[¶](#appendix-A-2.102)
* TLS\_DH\_RSA\_WITH\_AES\_128\_GCM\_SHA256[¶](#appendix-A-2.103)
* TLS\_DH\_RSA\_WITH\_AES\_256\_GCM\_SHA384[¶](#appendix-A-2.104)
* TLS\_DH\_DSS\_WITH\_AES\_128\_GCM\_SHA256[¶](#appendix-A-2.105)
* TLS\_DH\_DSS\_WITH\_AES\_256\_GCM\_SHA384[¶](#appendix-A-2.106)
* TLS\_DH\_anon\_WITH\_AES\_128\_GCM\_SHA256[¶](#appendix-A-2.107)
* TLS\_DH\_anon\_WITH\_AES\_256\_GCM\_SHA384[¶](#appendix-A-2.108)
* TLS\_PSK\_WITH\_AES\_128\_GCM\_SHA256[¶](#appendix-A-2.109)
* TLS\_PSK\_WITH\_AES\_256\_GCM\_SHA384[¶](#appendix-A-2.110)
* TLS\_RSA\_PSK\_WITH\_AES\_128\_GCM\_SHA256[¶](#appendix-A-2.111)
* TLS\_RSA\_PSK\_WITH\_AES\_256\_GCM\_SHA384[¶](#appendix-A-2.112)
* TLS\_PSK\_WITH\_AES\_128\_CBC\_SHA256[¶](#appendix-A-2.113)
* TLS\_PSK\_WITH\_AES\_256\_CBC\_SHA384[¶](#appendix-A-2.114)
* TLS\_PSK\_WITH\_NULL\_SHA256[¶](#appendix-A-2.115)
* TLS\_PSK\_WITH\_NULL\_SHA384[¶](#appendix-A-2.116)
* TLS\_DHE\_PSK\_WITH\_AES\_128\_CBC\_SHA256[¶](#appendix-A-2.117)
* TLS\_DHE\_PSK\_WITH\_AES\_256\_CBC\_SHA384[¶](#appendix-A-2.118)
* TLS\_DHE\_PSK\_WITH\_NULL\_SHA256[¶](#appendix-A-2.119)
* TLS\_DHE\_PSK\_WITH\_NULL\_SHA384[¶](#appendix-A-2.120)
* TLS\_RSA\_PSK\_WITH\_AES\_128\_CBC\_SHA256[¶](#appendix-A-2.121)
* TLS\_RSA\_PSK\_WITH\_AES\_256\_CBC\_SHA384[¶](#appendix-A-2.122)
* TLS\_RSA\_PSK\_WITH\_NULL\_SHA256[¶](#appendix-A-2.123)
* TLS\_RSA\_PSK\_WITH\_NULL\_SHA384[¶](#appendix-A-2.124)
* TLS\_RSA\_WITH\_CAMELLIA\_128\_CBC\_SHA256[¶](#appendix-A-2.125)
* TLS\_DH\_DSS\_WITH\_CAMELLIA\_128\_CBC\_SHA256[¶](#appendix-A-2.126)
* TLS\_DH\_RSA\_WITH\_CAMELLIA\_128\_CBC\_SHA256[¶](#appendix-A-2.127)
* TLS\_DHE\_DSS\_WITH\_CAMELLIA\_128\_CBC\_SHA256[¶](#appendix-A-2.128)
* TLS\_DHE\_RSA\_WITH\_CAMELLIA\_128\_CBC\_SHA256[¶](#appendix-A-2.129)
* TLS\_DH\_anon\_WITH\_CAMELLIA\_128\_CBC\_SHA256[¶](#appendix-A-2.130)
* TLS\_RSA\_WITH\_CAMELLIA\_256\_CBC\_SHA256[¶](#appendix-A-2.131)
* TLS\_DH\_DSS\_WITH\_CAMELLIA\_256\_CBC\_SHA256[¶](#appendix-A-2.132)
* TLS\_DH\_RSA\_WITH\_CAMELLIA\_256\_CBC\_SHA256[¶](#appendix-A-2.133)
* TLS\_DHE\_DSS\_WITH\_CAMELLIA\_256\_CBC\_SHA256[¶](#appendix-A-2.134)
* TLS\_DHE\_RSA\_WITH\_CAMELLIA\_256\_CBC\_SHA256[¶](#appendix-A-2.135)
* TLS\_DH\_anon\_WITH\_CAMELLIA\_256\_CBC\_SHA256[¶](#appendix-A-2.136)
* TLS\_EMPTY\_RENEGOTIATION\_INFO\_SCSV[¶](#appendix-A-2.137)
* TLS\_ECDH\_ECDSA\_WITH\_NULL\_SHA[¶](#appendix-A-2.138)
* TLS\_ECDH\_ECDSA\_WITH\_RC4\_128\_SHA[¶](#appendix-A-2.139)
* TLS\_ECDH\_ECDSA\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.140)
* TLS\_ECDH\_ECDSA\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.141)
* TLS\_ECDH\_ECDSA\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.142)
* TLS\_ECDHE\_ECDSA\_WITH\_NULL\_SHA[¶](#appendix-A-2.143)
* TLS\_ECDHE\_ECDSA\_WITH\_RC4\_128\_SHA[¶](#appendix-A-2.144)
* TLS\_ECDHE\_ECDSA\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.145)
* TLS\_ECDHE\_ECDSA\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.146)
* TLS\_ECDHE\_ECDSA\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.147)
* TLS\_ECDH\_RSA\_WITH\_NULL\_SHA[¶](#appendix-A-2.148)
* TLS\_ECDH\_RSA\_WITH\_RC4\_128\_SHA[¶](#appendix-A-2.149)
* TLS\_ECDH\_RSA\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.150)
* TLS\_ECDH\_RSA\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.151)
* TLS\_ECDH\_RSA\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.152)
* TLS\_ECDHE\_RSA\_WITH\_NULL\_SHA[¶](#appendix-A-2.153)
* TLS\_ECDHE\_RSA\_WITH\_RC4\_128\_SHA[¶](#appendix-A-2.154)
* TLS\_ECDHE\_RSA\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.155)
* TLS\_ECDHE\_RSA\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.156)
* TLS\_ECDHE\_RSA\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.157)
* TLS\_ECDH\_anon\_WITH\_NULL\_SHA[¶](#appendix-A-2.158)
* TLS\_ECDH\_anon\_WITH\_RC4\_128\_SHA[¶](#appendix-A-2.159)
* TLS\_ECDH\_anon\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.160)
* TLS\_ECDH\_anon\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.161)
* TLS\_ECDH\_anon\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.162)
* TLS\_SRP\_SHA\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.163)
* TLS\_SRP\_SHA\_RSA\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.164)
* TLS\_SRP\_SHA\_DSS\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.165)
* TLS\_SRP\_SHA\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.166)
* TLS\_SRP\_SHA\_RSA\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.167)
* TLS\_SRP\_SHA\_DSS\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.168)
* TLS\_SRP\_SHA\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.169)
* TLS\_SRP\_SHA\_RSA\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.170)
* TLS\_SRP\_SHA\_DSS\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.171)
* TLS\_ECDHE\_ECDSA\_WITH\_AES\_128\_CBC\_SHA256[¶](#appendix-A-2.172)
* TLS\_ECDHE\_ECDSA\_WITH\_AES\_256\_CBC\_SHA384[¶](#appendix-A-2.173)
* TLS\_ECDH\_ECDSA\_WITH\_AES\_128\_CBC\_SHA256[¶](#appendix-A-2.174)
* TLS\_ECDH\_ECDSA\_WITH\_AES\_256\_CBC\_SHA384[¶](#appendix-A-2.175)
* TLS\_ECDHE\_RSA\_WITH\_AES\_128\_CBC\_SHA256[¶](#appendix-A-2.176)
* TLS\_ECDHE\_RSA\_WITH\_AES\_256\_CBC\_SHA384[¶](#appendix-A-2.177)
* TLS\_ECDH\_RSA\_WITH\_AES\_128\_CBC\_SHA256[¶](#appendix-A-2.178)
* TLS\_ECDH\_RSA\_WITH\_AES\_256\_CBC\_SHA384[¶](#appendix-A-2.179)
* TLS\_ECDH\_ECDSA\_WITH\_AES\_128\_GCM\_SHA256[¶](#appendix-A-2.180)
* TLS\_ECDH\_ECDSA\_WITH\_AES\_256\_GCM\_SHA384[¶](#appendix-A-2.181)
* TLS\_ECDH\_RSA\_WITH\_AES\_128\_GCM\_SHA256[¶](#appendix-A-2.182)
* TLS\_ECDH\_RSA\_WITH\_AES\_256\_GCM\_SHA384[¶](#appendix-A-2.183)
* TLS\_ECDHE\_PSK\_WITH\_RC4\_128\_SHA[¶](#appendix-A-2.184)
* TLS\_ECDHE\_PSK\_WITH\_3DES\_EDE\_CBC\_SHA[¶](#appendix-A-2.185)
* TLS\_ECDHE\_PSK\_WITH\_AES\_128\_CBC\_SHA[¶](#appendix-A-2.186)
* TLS\_ECDHE\_PSK\_WITH\_AES\_256\_CBC\_SHA[¶](#appendix-A-2.187)
* TLS\_ECDHE\_PSK\_WITH\_AES\_128\_CBC\_SHA256[¶](#appendix-A-2.188)
* TLS\_ECDHE\_PSK\_WITH\_AES\_256\_CBC\_SHA384[¶](#appendix-A-2.189)
* TLS\_ECDHE\_PSK\_WITH\_NULL\_SHA[¶](#appendix-A-2.190)
* TLS\_ECDHE\_PSK\_WITH\_NULL\_SHA256[¶](#appendix-A-2.191)
* TLS\_ECDHE\_PSK\_WITH\_NULL\_SHA384[¶](#appendix-A-2.192)
* TLS\_RSA\_WITH\_ARIA\_128\_CBC\_SHA256[¶](#appendix-A-2.193)
* TLS\_RSA\_WITH\_ARIA\_256\_CBC\_SHA384[¶](#appendix-A-2.194)
* TLS\_DH\_DSS\_WITH\_ARIA\_128\_CBC\_SHA256[¶](#appendix-A-2.195)
* TLS\_DH\_DSS\_WITH\_ARIA\_256\_CBC\_SHA384[¶](#appendix-A-2.196)
* TLS\_DH\_RSA\_WITH\_ARIA\_128\_CBC\_SHA256[¶](#appendix-A-2.197)
* TLS\_DH\_RSA\_WITH\_ARIA\_256\_CBC\_SHA384[¶](#appendix-A-2.198)
* TLS\_DHE\_DSS\_WITH\_ARIA\_128\_CBC\_SHA256[¶](#appendix-A-2.199)
* TLS\_DHE\_DSS\_WITH\_ARIA\_256\_CBC\_SHA384[¶](#appendix-A-2.200)
* TLS\_DHE\_RSA\_WITH\_ARIA\_128\_CBC\_SHA256[¶](#appendix-A-2.201)
* TLS\_DHE\_RSA\_WITH\_ARIA\_256\_CBC\_SHA384[¶](#appendix-A-2.202)
* TLS\_DH\_anon\_WITH\_ARIA\_128\_CBC\_SHA256[¶](#appendix-A-2.203)
* TLS\_DH\_anon\_WITH\_ARIA\_256\_CBC\_SHA384[¶](#appendix-A-2.204)
* TLS\_ECDHE\_ECDSA\_WITH\_ARIA\_128\_CBC\_SHA256[¶](#appendix-A-2.205)
* TLS\_ECDHE\_ECDSA\_WITH\_ARIA\_256\_CBC\_SHA384[¶](#appendix-A-2.206)
* TLS\_ECDH\_ECDSA\_WITH\_ARIA\_128\_CBC\_SHA256[¶](#appendix-A-2.207)
* TLS\_ECDH\_ECDSA\_WITH\_ARIA\_256\_CBC\_SHA384[¶](#appendix-A-2.208)
* TLS\_ECDHE\_RSA\_WITH\_ARIA\_128\_CBC\_SHA256[¶](#appendix-A-2.209)
* TLS\_ECDHE\_RSA\_WITH\_ARIA\_256\_CBC\_SHA384[¶](#appendix-A-2.210)
* TLS\_ECDH\_RSA\_WITH\_ARIA\_128\_CBC\_SHA256[¶](#appendix-A-2.211)
* TLS\_ECDH\_RSA\_WITH\_ARIA\_256\_CBC\_SHA384[¶](#appendix-A-2.212)
* TLS\_RSA\_WITH\_ARIA\_128\_GCM\_SHA256[¶](#appendix-A-2.213)
* TLS\_RSA\_WITH\_ARIA\_256\_GCM\_SHA384[¶](#appendix-A-2.214)
* TLS\_DH\_RSA\_WITH\_ARIA\_128\_GCM\_SHA256[¶](#appendix-A-2.215)
* TLS\_DH\_RSA\_WITH\_ARIA\_256\_GCM\_SHA384[¶](#appendix-A-2.216)
* TLS\_DH\_DSS\_WITH\_ARIA\_128\_GCM\_SHA256[¶](#appendix-A-2.217)
* TLS\_DH\_DSS\_WITH\_ARIA\_256\_GCM\_SHA384[¶](#appendix-A-2.218)
* TLS\_DH\_anon\_WITH\_ARIA\_128\_GCM\_SHA256[¶](#appendix-A-2.219)
* TLS\_DH\_anon\_WITH\_ARIA\_256\_GCM\_SHA384[¶](#appendix-A-2.220)
* TLS\_ECDH\_ECDSA\_WITH\_ARIA\_128\_GCM\_SHA256[¶](#appendix-A-2.221)
* TLS\_ECDH\_ECDSA\_WITH\_ARIA\_256\_GCM\_SHA384[¶](#appendix-A-2.222)
* TLS\_ECDH\_RSA\_WITH\_ARIA\_128\_GCM\_SHA256[¶](#appendix-A-2.223)
* TLS\_ECDH\_RSA\_WITH\_ARIA\_256\_GCM\_SHA384[¶](#appendix-A-2.224)
* TLS\_PSK\_WITH\_ARIA\_128\_CBC\_SHA256[¶](#appendix-A-2.225)
* TLS\_PSK\_WITH\_ARIA\_256\_CBC\_SHA384[¶](#appendix-A-2.226)
* TLS\_DHE\_PSK\_WITH\_ARIA\_128\_CBC\_SHA256[¶](#appendix-A-2.227)
* TLS\_DHE\_PSK\_WITH\_ARIA\_256\_CBC\_SHA384[¶](#appendix-A-2.228)
* TLS\_RSA\_PSK\_WITH\_ARIA\_128\_CBC\_SHA256[¶](#appendix-A-2.229)
* TLS\_RSA\_PSK\_WITH\_ARIA\_256\_CBC\_SHA384[¶](#appendix-A-2.230)
* TLS\_PSK\_WITH\_ARIA\_128\_GCM\_SHA256[¶](#appendix-A-2.231)
* TLS\_PSK\_WITH\_ARIA\_256\_GCM\_SHA384[¶](#appendix-A-2.232)
* TLS\_RSA\_PSK\_WITH\_ARIA\_128\_GCM\_SHA256[¶](#appendix-A-2.233)
* TLS\_RSA\_PSK\_WITH\_ARIA\_256\_GCM\_SHA384[¶](#appendix-A-2.234)
* TLS\_ECDHE\_PSK\_WITH\_ARIA\_128\_CBC\_SHA256[¶](#appendix-A-2.235)
* TLS\_ECDHE\_PSK\_WITH\_ARIA\_256\_CBC\_SHA384[¶](#appendix-A-2.236)
* TLS\_ECDHE\_ECDSA\_WITH\_CAMELLIA\_128\_CBC\_SHA256[¶](#appendix-A-2.237)
* TLS\_ECDHE\_ECDSA\_WITH\_CAMELLIA\_256\_CBC\_SHA384[¶](#appendix-A-2.238)
* TLS\_ECDH\_ECDSA\_WITH\_CAMELLIA\_128\_CBC\_SHA256[¶](#appendix-A-2.239)
* TLS\_ECDH\_ECDSA\_WITH\_CAMELLIA\_256\_CBC\_SHA384[¶](#appendix-A-2.240)
* TLS\_ECDHE\_RSA\_WITH\_CAMELLIA\_128\_CBC\_SHA256[¶](#appendix-A-2.241)
* TLS\_ECDHE\_RSA\_WITH\_CAMELLIA\_256\_CBC\_SHA384[¶](#appendix-A-2.242)
* TLS\_ECDH\_RSA\_WITH\_CAMELLIA\_128\_CBC\_SHA256[¶](#appendix-A-2.243)
* TLS\_ECDH\_RSA\_WITH\_CAMELLIA\_256\_CBC\_SHA384[¶](#appendix-A-2.244)
* TLS\_RSA\_WITH\_CAMELLIA\_128\_GCM\_SHA256[¶](#appendix-A-2.245)
* TLS\_RSA\_WITH\_CAMELLIA\_256\_GCM\_SHA384[¶](#appendix-A-2.246)
* TLS\_DH\_RSA\_WITH\_CAMELLIA\_128\_GCM\_SHA256[¶](#appendix-A-2.247)
* TLS\_DH\_RSA\_WITH\_CAMELLIA\_256\_GCM\_SHA384[¶](#appendix-A-2.248)
* TLS\_DH\_DSS\_WITH\_CAMELLIA\_128\_GCM\_SHA256[¶](#appendix-A-2.249)
* TLS\_DH\_DSS\_WITH\_CAMELLIA\_256\_GCM\_SHA384[¶](#appendix-A-2.250)
* TLS\_DH\_anon\_WITH\_CAMELLIA\_128\_GCM\_SHA256[¶](#appendix-A-2.251)
* TLS\_DH\_anon\_WITH\_CAMELLIA\_256\_GCM\_SHA384[¶](#appendix-A-2.252)
* TLS\_ECDH\_ECDSA\_WITH\_CAMELLIA\_128\_GCM\_SHA256[¶](#appendix-A-2.253)
* TLS\_ECDH\_ECDSA\_WITH\_CAMELLIA\_256\_GCM\_SHA384[¶](#appendix-A-2.254)
* TLS\_ECDH\_RSA\_WITH\_CAMELLIA\_128\_GCM\_SHA256[¶](#appendix-A-2.255)
* TLS\_ECDH\_RSA\_WITH\_CAMELLIA\_256\_GCM\_SHA384[¶](#appendix-A-2.256)
* TLS\_PSK\_WITH\_CAMELLIA\_128\_GCM\_SHA256[¶](#appendix-A-2.257)
* TLS\_PSK\_WITH\_CAMELLIA\_256\_GCM\_SHA384[¶](#appendix-A-2.258)
* TLS\_RSA\_PSK\_WITH\_CAMELLIA\_128\_GCM\_SHA256[¶](#appendix-A-2.259)
* TLS\_RSA\_PSK\_WITH\_CAMELLIA\_256\_GCM\_SHA384[¶](#appendix-A-2.260)
* TLS\_PSK\_WITH\_CAMELLIA\_128\_CBC\_SHA256[¶](#appendix-A-2.261)
* TLS\_PSK\_WITH\_CAMELLIA\_256\_CBC\_SHA384[¶](#appendix-A-2.262)
* TLS\_DHE\_PSK\_WITH\_CAMELLIA\_128\_CBC\_SHA256[¶](#appendix-A-2.263)
* TLS\_DHE\_PSK\_WITH\_CAMELLIA\_256\_CBC\_SHA384[¶](#appendix-A-2.264)
* TLS\_RSA\_PSK\_WITH\_CAMELLIA\_128\_CBC\_SHA256[¶](#appendix-A-2.265)
* TLS\_RSA\_PSK\_WITH\_CAMELLIA\_256\_CBC\_SHA384[¶](#appendix-A-2.266)
* TLS\_ECDHE\_PSK\_WITH\_CAMELLIA\_128\_CBC\_SHA256[¶](#appendix-A-2.267)
* TLS\_ECDHE\_PSK\_WITH\_CAMELLIA\_256\_CBC\_SHA384[¶](#appendix-A-2.268)
* TLS\_RSA\_WITH\_AES\_128\_CCM[¶](#appendix-A-2.269)
* TLS\_RSA\_WITH\_AES\_256\_CCM[¶](#appendix-A-2.270)
* TLS\_RSA\_WITH\_AES\_128\_CCM\_8[¶](#appendix-A-2.271)
* TLS\_RSA\_WITH\_AES\_256\_CCM\_8[¶](#appendix-A-2.272)
* TLS\_PSK\_WITH\_AES\_128\_CCM[¶](#appendix-A-2.273)
* TLS\_PSK\_WITH\_AES\_256\_CCM[¶](#appendix-A-2.274)
* TLS\_PSK\_WITH\_AES\_128\_CCM\_8[¶](#appendix-A-2.275)
* TLS\_PSK\_WITH\_AES\_256\_CCM\_8[¶](#appendix-A-2.276)

Note: This list was assembled from the set of registered TLS cipher suites when
[[RFC7540](#RFC7540)] was developed. This list includes those cipher suites that do not
offer an ephemeral key exchange and those that are based on the TLS null, stream, or block
cipher type (as defined in [Section 6.2.3](https://www.rfc-editor.org/rfc/rfc5246#section-6.2.3) of [[TLS12](#RFC5246)]). Additional cipher suites
with these properties could be defined; these would not be explicitly prohibited.[¶](#appendix-A-3.1)

For more details, see [Section 9.2.2](#tls12ciphers).[¶](#appendix-A-4)

## [Appendix B.](#appendix-B) [Changes from RFC 7540](#name-changes-from-rfc-7540)

This revision includes the following substantive changes:[¶](#appendix-B-1)

* Use of TLS 1.3 was defined based on [[RFC8740](#RFC8740)], which this document obsoletes.[¶](#appendix-B-2.1)
* The priority scheme defined in RFC 7540 is deprecated. Definitions for the format of the
  [PRIORITY](#PRIORITY) frame and the priority fields in the
  [HEADERS](#HEADERS) frame have been retained, plus the
  rules governing when [PRIORITY](#PRIORITY) frames can be
  sent and received, but the semantics of these fields are only described in RFC 7540. The
  priority signaling scheme from RFC 7540 was not successful. Using the simpler signaling
  in [[HTTP-PRIORITY](#RFC9218)] is recommended.[¶](#appendix-B-2.2)
* The HTTP/1.1 Upgrade mechanism is deprecated and no longer specified in this document. It
  was never widely deployed, with plaintext HTTP/2 users choosing to use the prior-knowledge
  implementation instead.[¶](#appendix-B-2.3)
* Validation for field names and values has been narrowed. The validation that is mandatory
  for intermediaries is precisely defined, and error reporting for requests has been amended
  to encourage sending 400-series status codes.[¶](#appendix-B-2.4)
* The ranges of codepoints for settings and frame types that were reserved for Experimental
  Use are now available for general use.[¶](#appendix-B-2.5)
* Connection-specific header fields -- which are prohibited -- are more precisely and
  comprehensively identified.[¶](#appendix-B-2.6)
* `Host` and "`:authority`" are no longer permitted to disagree.[¶](#appendix-B-2.7)
* Rules for sending Dynamic Table Size Update instructions after changes in settings have
  been clarified in [Section 4.3.1](#dynamic-table).[¶](#appendix-B-2.8)

Editorial changes are also included. In particular, changes to terminology and document
structure are in response to updates to [core HTTP
semantics](#RFC9110) [[HTTP](#RFC9110)]. Those documents now include some concepts that were first defined in RFC
7540, such as the 421 status code or connection coalescing.[¶](#appendix-B-3)

## [Acknowledgments](#name-acknowledgments)

Credit for non-trivial input to this document is owed to a large number of people who have
contributed to the HTTP Working Group over the years. [[RFC7540](#RFC7540)] contains a
more extensive list of people that deserve acknowledgment for their contributions.[¶](#appendix-C-1)

## [Contributors](#name-contributors)

Mike Belshe and Roberto Peon authored the text that this document is based on.[¶](#appendix-D-1)

## [Authors' Addresses](#name-authors-addresses)

Martin Thomson (editor)
Mozilla
Australia
Email:
mt@lowentropy.net

Cory Benfield (editor)
Apple Inc.
Email:
cbenfield@apple.com

[Datatracker](/doc/rfc9113/)

RFC 9113

RFC
- Proposed Standard

* Info
* Contents
* Prefs

| Document | Document type |  | RFC - Proposed Standard  June 2022  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=9113 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") Obsoletes [RFC 8740](/doc/html/rfc8740 "Using TLS 1.3 with HTTP/2"), [RFC 7540](/doc/html/rfc7540 "Hypertext Transfer Protocol Version 2 (HTTP/2)") Was [draft-ietf-httpbis-http2bis](/doc/draft-ietf-httpbis-http2bis/07/) ([httpbis WG](/wg/httpbis/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [00](/doc/html/draft-ietf-httpbis-http2bis-00) * [01](/doc/html/draft-ietf-httpbis-http2bis-01) * [02](/doc/html/draft-ietf-httpbis-http2bis-02) * [03](/doc/html/draft-ietf-httpbis-http2bis-03) * [04](/doc/html/draft-ietf-httpbis-http2bis-04) * [05](/doc/html/draft-ietf-httpbis-http2bis-05) * [06](/doc/html/draft-ietf-httpbis-http2bis-06) * [07](/doc/html/draft-ietf-httpbis-http2bis-07) * [RFC 9113](/doc/html/rfc9113) |
|  | Compare versions |  | RFC 9113  draft-ietf-httpbis-http2bis-07  draft-ietf-httpbis-http2bis-06  draft-ietf-httpbis-http2bis-05  draft-ietf-httpbis-http2bis-04  draft-ietf-httpbis-http2bis-03  draft-ietf-httpbis-http2bis-02  draft-ietf-httpbis-http2bis-01  draft-ietf-httpbis-http2bis-00   RFC 9113  draft-ietf-httpbis-http2bis-07  draft-ietf-httpbis-http2bis-06  draft-ietf-httpbis-http2bis-05  draft-ietf-httpbis-http2bis-04  draft-ietf-httpbis-http2bis-03  draft-ietf-httpbis-http2bis-02  draft-ietf-httpbis-http2bis-01  draft-ietf-httpbis-http2bis-00   Side-by-side  Inline |
|  | Authors |  | [Martin Thomson](/person/mt%40lowentropy.net "Datatracker profile of Martin Thomson") , [Cory Benfield](/person/cbenfield%40apple.com "Datatracker profile of Cory Benfield")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc9113.txt) [html](https://www.rfc-editor.org/rfc/rfc9113.html) [xml](https://www.rfc-editor.org/rfc/rfc9113.xml) [pdf](https://www.rfc-editor.org/rfc/rfc9113.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc9113.html) [bibtex](/doc/rfc9113/bibtex/) |
|  | Additional resources |  | [Mailing list discussion](http://lists.w3.org/Archives/Public/ietf-http-wg/) |

[Report a datatracker bug](https://github.com/ietf-tools/datatracker/issues/new/choose)

Show sidebar by default

Yes

No

Tab to show by default

Info

Contents

HTMLization configuration

HTMLize the plaintext

Plaintextify the HTML

Maximum font size

Page dependencies

Inline

Reference

Citation links

 Go to reference section

Go to linked document

![](//analytics.ietf.org/piwik.php?idsite=7)


