=== Content from ctrl-c.club_31a9527e_20250114_224107.html ===




=== Content from www.madefornet.com_c8449d20_20250114_224108.html ===


| | | [Home](index.html)[RSS](rss.html)[Sitemap](sitemap.html) |  | | --- | --- | | | --- | --- | --- | |
| | | | MadeForNet OU Harju maakond, Tallinn, Kesklinna linnaosa, Ahtri tn 12, 10151  Toll-free: +1 (833) 577-1212 | | | **MadeForNet** **Products**  | [HTTP Debugger Pro](http://www.httpdebugger.com) The HTTP Debugger Pro is our flagman product that helps web developers, IT managers, and system and network administrators to locate and eliminate website errors and to identify performance bottlenecks. The software is used in many well-known Fortune-100 companies including Google, Casio, Symantec and others. | | --- | | [Web Development Tools](http://www.xibl.com) Web development tools, articles, tutorials and howtos. | | [Porta Plus](http://www.portaplus.com) The Porta Plus programs are specially created for Windows Mobile and Pocket PC devices. Those applications include an FTP Client, a Personal Information Manager and a WebSite Monitor and few free programs for fun. | | [Parental Tools](http://www.parentaltools.net) The ParentalTools.net is a web site developed and maintained by MadeForNet. It provides Free Internet Filter with the source code, articles and tutorials, Internet safety tips and other materials related to parenting, children and the Internet. | | [Search Refiner, R&D Project](http://www.searchrefiner.com) This is our patent pending R&D project, a working prototype with an innovative approach to search in the Internet. Your individual search results will be delivered based on your professional interests and/or hobbies. | | | --- | --- | --- | --- | --- | --- | | | --- | --- | --- | --- | --- | --- | --- | --- | --- | | | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | | | Copyright © 2022 MadeForNet.com [Privacy Policy](privacy.html) | [About](about.html)       |        [Products](products.html)       |        [Legal](legal.html)       |        [Contacts](contact.html) | | |



=== Content from www.michaelrowley.dev_18625fb4_20250114_224108.html ===


[BACK](https://www.michaelrowley.dev/)
# Bypassing Driver Security With Race Conditions

## Background

[NetFilterSDK](https://netfiltersdk.com/) is a software development kit (SDK) that enables developers to use a kernel-mode driver and
user-mode API (library) to interact with network devices/events on a host device. It is sold to companies as a tool that
can be embedded within their own programs and as such, the SDK seems to be pretty widely deployed in a number of environments.

It's probably also worth noting that the binary name 'NetFilterSDK' was used by
[malware that ended up being signed by Microsoft](https://www.gdatasoftware.com/blog/microsoft-signed-a-malicious-netfilter-rootkit), leading to a substantial amount of name-confusion between the virus and legitimate product online.

There are two main vulnerabilities that are outlined in this writeup: a lack of security level properties applied to
a repackaged NetFilterSDK driver, and the NetFilterSDK's race condition in enforcing security parameters.
The former provides access to a machine's live networking traffic (including possible SSL decryption) as signed by an
unnamed vendor, and the latter provides similar access to any driver based on the SDK regardless of security parameters.

*EDIT: Six months after initially attempting to contact the product owner, [CVE-2023-35863](https://nvd.nist.gov/vuln/detail/CVE-2023-35863)
has been published which names the vendor as [MADEFORNET](https://madefornet.com/). The vulnerability
remains unpatched and no response was ever received to my initial email to the company.*
## Finding an Interesting Driver

Let's take a look at what [PE-Imports](https://github.com/michaellrowley/PE-Imports) would output if it was used to
scan the driver in question (reordered listing for readability):

IMPORTS LISTING
[link](https://github.com/michaellrowley/PE-Imports)

---

`driver_name.sys    ntoskrnl.exe!ZwSetSecurityObject/null    ntoskrnl.exe!MmBuildMdlForNonPagedPool/null    ntoskrnl.exe!MmMapLockedPagesSpecifyCache/null    ntoskrnl.exe!RtlCreateSecurityDescriptor/null    ntoskrnl.exe!RtlSetDaclSecurityDescriptor/null    ntoskrnl.exe!MmUnmapLockedPages/null    ntoskrnl.exe!MmAllocatePagesForMdl/null    ntoskrnl.exe!RtlLengthSid/null    ntoskrnl.exe!RtlCreateAcl/null    ntoskrnl.exe!RtlAddAccessAllowedAce/null    ntoskrnl.exe!IofCompleteRequest/null    ntoskrnl.exe!IoCreateDevice/null    ntoskrnl.exe!IoCreateSymbolicLink/null    ntoskrnl.exe!MmFreePagesFromMdl/null    ntoskrnl.exe!PsCreateSystemThread/null    ntoskrnl.exe!PsTerminateSystemThread/null    ntoskrnl.exe!IoAllocateMdl/null    ntoskrnl.exe!IoDeleteDevice/null    ntoskrnl.exe!IoDeleteSymbolicLink/null    ntoskrnl.exe!IoFreeMdl/null    ntoskrnl.exe!IoReleaseCancelSpinLock/null    ntoskrnl.exe!ExFreePoolWithTag/null    ntoskrnl.exe!ExQueryDepthSList/null    ntoskrnl.exe!ExpInterlockedPopEntrySList/null    ntoskrnl.exe!ExpInterlockedPushEntrySList/null    ntoskrnl.exe!ExInitializeNPagedLookasideList/null    ntoskrnl.exe!ExDeleteNPagedLookasideList/null    ntoskrnl.exe!ObReferenceObjectByHandle/null    ntoskrnl.exe!ObfDereferenceObject/null    ntoskrnl.exe!ZwClose/null    ntoskrnl.exe!ZwOpenKey/null    ntoskrnl.exe!ZwQueryValueKey/null    ntoskrnl.exe!PsGetCurrentProcessId/null    ntoskrnl.exe!ZwSetInformationThread/null    ntoskrnl.exe!PsLookupProcessByProcessId/null    ntoskrnl.exe!ObOpenObjectByPointer/null    ntoskrnl.exe!__C_specific_handler/null    ntoskrnl.exe!SeExports/null    fwpkclnt.sys!FwpmTransactionBegin0/null    fwpkclnt.sys!FwpmTransactionCommit0/null    fwpkclnt.sys!FwpmTransactionAbort0/null    fwpkclnt.sys!FwpmProviderAdd0/null    fwpkclnt.sys!FwpmProviderContextDeleteByKey0/null    fwpkclnt.sys!FwpmSubLayerAdd0/null    fwpkclnt.sys!FwpmSubLayerCreateEnumHandle0/null    ...`

First of all, there are some references to functions with 'Mdl' or references to 'mapping' in the name,
these imports refer to interactions with a ['memory descriptor listing'](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/using-mdls)
where Windows can map physical memory pages to virtual memory buffers - this is a pretty important function as, if misused,
it is capable of acting as a privilege escalation vector (this is how most instances of such user-to-kernel escalations happen).

Being able to load data into arbitrary kernel regions isn't useful if the attacker already needs to be running as an administrator, and given
the driver's nature (intercepting and possibly even decrypting host machine traffic) there isn't a huge amount of capability that a kernel
implant could deliver beyond what is already included in the NetFilterSDK driver.
In order to interact with the driver and intercept traffic, the attacker will need to acquire a handle to the
['device object'](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-device-objects) - this
is where the next set of 'good' imports comes in; [IoCreateDevice](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice)
creates a device object which the user-mode API will later interact with (it should be noted that most drivers use
the DeviceCharacteristics argument to pass in FILE\_DEVICE\_SECURE\_OPEN
to limit security access), [IoCreateSymbolicLink](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatesymboliclink)
establishes a symbolic link that the user-mode application can use to communicate with the driver (another great sign if we hope to access the driver), and finally
[IofCompleteRequest](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iocompleterequest) which
implies that the driver - to some degree - can handle [IRPs](https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/i-o-request-packets) (the main
way that handle-owners can communicate with drivers, often passing buffers that require delicate translation between kernel and user-mode memory).

On the not-so-great side, the driver appears to make use of a number of functions that setup/verify/assign security descriptors to events/objects,
possibly meaning that any access to the driver could be subject to a security routine.

## Reverse Engineering

This section covers reversing the driver, the environment used was primarily comprised of a
[VMware](https://www.vmware.com/uk/products/workstation-pro.html) Windows 11 instance
with a [WinDbg](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/windbg-overview) kernel pipe and
some other tools. In addition to dynamic analysis programs, I used Ghidra to actually take
a look into the binary of the '.sys' file and once I'd figured out that the driver was from NetFilterSDK, the API's '.dll' file
(choosing Ghidra over the [Rizin Cutter](https://cutter.re/) project was due to the inherent KMDF support that could be imported through ['gdt'](https://github.com/0x6d696368/ghidra-data) files,
and chosing it over [IDA Pro](https://hex-rays.com/ida-pro/) came down to my need to work across multiple devices which a [self-hosted server](https://byte.how/posts/collaborative-reverse-engineering/) could support).

Whenever any binary image is loaded to be run on Windows, an entrypoint function is called (unless compiled not to export a default entrypoint) -
this can be [WinMain](https://learn.microsoft.com/en-us/windows/win32/learnwin32/winmain--the-application-entry-point),
[DllMain](https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain), or in the instance
of kernel-mode drivers, [DriverEntry](https://learn.microsoft.com/en-us/windows-hardware/drivers/wdf/driverentry-for-kmdf-drivers).

DriverEntry has two parameters: a [DRIVER\_OBJECT](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_driver_object)\*,
and a [UNICODE\_STRING](https://learn.microsoft.com/en-us/windows/win32/api/subauth/ns-subauth-unicode_string)\*
with the former referring to the driver whose entrypoint is being called, and the latter containing its 'registry path'.
When this entrypoint is called in the driver being analysed, two functions are called: one checks the state of some global variables
and the other function (FUN\_000208e0/*'DriverInitFn'*) is called with the driver object and
registry path being passed in through RCX and RDX, respectively:

---

### Dispatch Setup

ASSEMBLYDriverInitFn (FUN\_000208e0)

---

`0001133d         LEA        RDI,[RCX + 0x70]00011341         LEA        RAX,[FUN_0001813c]00011348         MOV        ECX,0x1c0001134d         STOSQ.REP  RDI=>FUN_0001813c00011350         LEA        RAX,[FUN_000112e4]00011357         MOV        qword ptr [RCX + 0x68],RAX=>FUN_000112e4`

This segment of code takes the structure at DRIVER\_OBJECT + 0x70 -- the
[DRIVER\_DISPATCH](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nc-wdm-driver_dispatch) list --
and loads its address to RDI and then loads the pointer to another function (FUN\_0001813c/MajorIRPHandler)
into RAX before setting ECX to 0x1C. All of these
assignments are essentially setting up a call to STOSQ.REP. The STOSQ instruction on its
own can be thought of as your CPU's interpretation of [memcpy](https://cplusplus.com/reference/cstring/memcpy/)(RDI, RAX, sizeof(void\*))
but when the 'REP'-suffixed version is used, it essentially loops the aforementioned operation ECX times.

After getting that far into the assembly, it becomes apparent that the above code loops over the local driver's dispatch table and sets all of the [major IRP functions](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-major-function-codes)
to a single handler, MajorIRPHandler, at FUN\_0001813c. More on that later!

In addition, the final two instructions just load a pointer to the function as FUN\_000112e4 into
the member at 0x68 of the DRIVER\_OBJECT object; thus setting
the [DRIVER\_UNLOAD](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nc-wdm-driver_unload)
dispatch to call FUN\_000112e4.

---

### Device Initialization

As previously mentioned, in order to interact with this kernel-mode driver via IRPs, we need a handle to an exposed
device object where a handle can be opened from user-mode - preferably from an unprivileged perspective.

Immediately following the setup of the dispatch functions, FUN\_000112e4 is called. This function
is where the interactivity capability is established by calling IoCreateDevice
with a semi-hardcoded name (\Device\CtrlSMVARIABLE)
and unfortunately for a would-be attacker, this function is called with the flag FILE\_DEVICE\_SECURE\_OPEN.

By default, Windows will let any user *try* to open a handle to any device (there are still a couple of ways that handle creation can be selectively blocked
by hooking handle creation or by blocking [IRP\_MJ\_CREATE](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-mj-create) but that isn't what this driver does).
The operating system allows drivers the ability to limit access to its devices using functions like [IoCreateDeviceSecure](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdmsec/nf-wdmsec-wdmlibiocreatedevicesecure)
and the [FILE\_DEVICE\_SECURE\_OPEN](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/controlling-device-namespace-access) device characteristics
which essentially mirrors access control restrictions from the driver object to any attempts to access the device from user-mode. This means that we now need to confirm
that those security descriptor functions aren't appropriately used in the environment that this driver is running (otherwise, interaction with the targeted driver
is confined to other functions, mostly in the form of system-wide callbacks which are heavily sanitized by the OS).

Next up, a symbolic link is created between the device and \DosDevices\CtrlSMVARIABLE, pretty standard for
any driver that wants to handle inter-process communication.
We drop into FUN\_000138dc which checks the seclevel member at [HKEY\_LOCAL\_MACHINE\SYSTEM\CurrentControlSet\Services\](https://www.netfiltersdk.com/help/nfsdk2/nfapi_registry.htm)VARIABLE.
If the seclevel value isn't set to allow universal access, *another* function is called.

In conclusion, as long as the driver doesn't set the seclevel registry key to 1 or 2,
opening a handle is fine from Windows' verification perspective. In case you were wondering, here's the flow of the IRP\_MJ\_CREATE handler, which could have
been used to reject an unauthorised handle request but simply prevents multiple handles being issued using a spinlock (a.k.a 'fancy kernel mutex'):

## Exploitation

The end goal for this writeup is gaining a handle, from an unprivileged user-mode application, to the vendor-compiled NetFilterSDK driver.
From that point, a malicious application would be able to make legitimate API calls that deliver access to raw TCP/UDP streams as well as
intercepting system-wide network traffic (including HTTPS) without on-system security products flagging anything suspicious.
In the third-party application that I discovered this issue on, an administrative service application launched the driver using
[CreateServiceA](https://learn.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-createservicea)
and subsequently [StartServiceA](https://learn.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-startservicea)
to launch the driver after installing it, I didn't identify any modification of the seclevel value however there seemed
to be some form of attempt to prevent unprivileged access through the usage of [SetSecurityDescriptorSacl](https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-setsecuritydescriptorsacl),
[SetSecurityDescriptorDacl](https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-setsecuritydescriptordacl), [InitializeSecurityDescriptor](https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-initializesecuritydescriptor),
[ConvertStringSecurityDescriptorToSecurityDescriptorA](https://learn.microsoft.com/en-us/windows/win32/api/sddl/nf-sddl-convertstringsecuritydescriptortosecuritydescriptora), and [LookupAccountSidA](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupaccountsida) to
apply the SDDL S:(ML;;NW;;;LW).

In either case, this application has a gap between starting the driver's service and actually getting the single handle to that driver. This
timing gap is what we'll exploit by rapidly making attempts at claiming the driver's handle in order to hope that our 'malicious' user-mode application
is able to complete a request between the time it takes for the official service to create the driver server and send its own request.

This proof-of-concept allows the process to get a handle to the repackaged NetFilterSDK driver installed by the third party vendor, from there - an attacker can
intercept almost any networking traffic on the system but in the PoC script just calls the IOCTL 0x12C800 to allocate
and map some kernel-mode memory into the calling process' address space.

A (slightly redacted) demonstration of the exploit with 'seclevel' set to only allow admins.

## Conclusion

There seems to be a lack of awareness about how device interaction could be limited throughout this application, ranging from the vendor failing to use seclevel
to the fact that the key probably wouldn't have changed much as the security descriptors are applied *after* the
device is setup, a symbolic link is applied, and an IRP dispatch handler is assigned.

When I first discovered this vulnerability, I was unaware that the vendor had repackaged the NetFilterSDK binary and so I emailed them a couple of times a few months ago
to no reply.
After finding out that the driver was from NetFilterSDK I reached out to the owner of NetFilterSDK who confirmed that the behaviour was expected and that the third-party could
patch the issue by using the aforementioned registry key to limit access (again, something that seems unlikely due to the order of applying the security policy).

No patch is currently available for this as the third-party didn't acknowledge any emails. Additionally, this vendor seems to be a primarily B2B company that lists
a number of fortune 500 companies as its customers, making it unlikely that an individual subscriber such as myself will get a response from their support team any time soon.


