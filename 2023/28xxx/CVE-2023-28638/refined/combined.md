=== Content from github.com_f9341123_20250114_230150.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fbrantburnett%2FSnappier%2Fsecurity%2Fadvisories%2FGHSA-838x-pcvx-6p5w)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fbrantburnett%2FSnappier%2Fsecurity%2Fadvisories%2FGHSA-838x-pcvx-6p5w)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=brantburnett%2FSnappier)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[brantburnett](/brantburnett)
/
**[Snappier](/brantburnett/Snappier)**
Public

* [Notifications](/login?return_to=%2Fbrantburnett%2FSnappier) You must be signed in to change notification settings
* [Fork
  7](/login?return_to=%2Fbrantburnett%2FSnappier)
* [Star
   72](/login?return_to=%2Fbrantburnett%2FSnappier)

* [Code](/brantburnett/Snappier)
* [Issues
  0](/brantburnett/Snappier/issues)
* [Pull requests
  0](/brantburnett/Snappier/pulls)
* [Actions](/brantburnett/Snappier/actions)
* [Security](/brantburnett/Snappier/security)
* [Insights](/brantburnett/Snappier/pulse)

Additional navigation options

* [Code](/brantburnett/Snappier)
* [Issues](/brantburnett/Snappier/issues)
* [Pull requests](/brantburnett/Snappier/pulls)
* [Actions](/brantburnett/Snappier/actions)
* [Security](/brantburnett/Snappier/security)
* [Insights](/brantburnett/Snappier/pulse)

# Short-lived stack references to locations outside buffers may become invalid if they exist during a GC compaction

High

[brantburnett](/brantburnett)
published
GHSA-838x-pcvx-6p5w
Mar 27, 2023

## Package

nuget

Snappier
([NuGet](/advisories?query=ecosystem%3Anuget))

## Affected versions

= 1.1.0

## Patched versions

1.1.1

## Description

### Impact

This is a buffer overrun vulnerability that can affect any user of Snappier 1.1.0. In this release, much of the code was rewritten to use byte references rather than pointers to pinned buffers. This change generally improves performance and reduces workload on the garbage collector. However, when the garbage collector performs compaction and rearranges memory, it must update any byte references on the stack to refer to the updated location. The .NET garbage collector can only update these byte references if they still point within the buffer or to a point one byte past the end of the buffer. If they point outside this area, the buffer itself may be moved while the byte reference stays the same.

There are several places in 1.1.0 where byte references very briefly point outside the valid areas of buffers. These are at locations in the code being used for buffer range checks. While the invalid references are never dereferenced directly, if a GC compaction were to occur during the brief window when they are on the stack then it could invalidate the buffer range check and allow other operations to overrun the buffer.

This should be very difficult for an attacker to trigger intentionally. It would require a repetitive bulk attack with the hope that a GC compaction would occur at precisely the right moment during one of the requests. However, one of the range checks with this problem is a check based on input data in the decompression buffer, meaning malformed input data could be used to increase the chance of success.

Note that any resulting buffer overrun is likely to cause access to protected memory, which will then cause an exception and the process to be terminated. Therefore, the most likely result of an attack is a denial of service.

### Patches

This is patched in release 1.1.1.

### Workarounds

Pinning any buffers to a fixed location before using them for compression or decompression should mitigate some, but not all, of these cases. At least one temporary decompression buffer is internal to the library and never pinned.

### Severity

High

7.0

# CVSS overall score

 This score calculates overall vulnerability severity from 0 to 10 and is based on the Common Vulnerability Scoring System (CVSS).

 / 10

#### CVSS v3 base metrics

Attack vector
Network

Attack complexity
High

Privileges required
None

User interaction
None

Scope
Unchanged

Confidentiality
Low

Integrity
Low

Availability
High

Learn more about base metrics

# CVSS v3 base metrics

Attack vector:
More severe the more the remote (logically and physically) an attacker can be in order to exploit the vulnerability.

Attack complexity:
More severe for the least complex attacks.

Privileges required:
More severe if no privileges are required.

User interaction:
More severe when no user interaction is required.

Scope:
More severe when a scope change occurs, e.g. one vulnerable component impacts resources in components beyond its security scope.

Confidentiality:
More severe when loss of data confidentiality is highest, measuring the level of data access available to an unauthorized user.

Integrity:
More severe when loss of data integrity is the highest, measuring the consequence of data modification possible by an unauthorized user.

Availability:
More severe when the loss of impacted component availability is highest.

CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:H

### CVE ID

CVE-2023-28638

### Weaknesses

[CWE-119](/advisories?query=cwe%3A119)

### Credits

* [![@brantburnett](https://avatars.githubusercontent.com/u/7118719?s=40&v=4)](/brantburnett)
  [brantburnett](/brantburnett)
  Remediation developer

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_023200b8_20250114_230149.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fbrantburnett%2FSnappier%2Fcommit%2Fd7ac5267b5b18439e6d108f8138edf48c436b32f)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fbrantburnett%2FSnappier%2Fcommit%2Fd7ac5267b5b18439e6d108f8138edf48c436b32f)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fcommit_fragments%2Frepo_layout&source=header-repo&source_repo=brantburnett%2FSnappier)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[brantburnett](/brantburnett)
/
**[Snappier](/brantburnett/Snappier)**
Public

* [Notifications](/login?return_to=%2Fbrantburnett%2FSnappier) You must be signed in to change notification settings
* [Fork
  7](/login?return_to=%2Fbrantburnett%2FSnappier)
* [Star
   72](/login?return_to=%2Fbrantburnett%2FSnappier)

* [Code](/brantburnett/Snappier)
* [Issues
  0](/brantburnett/Snappier/issues)
* [Pull requests
  0](/brantburnett/Snappier/pulls)
* [Actions](/brantburnett/Snappier/actions)
* [Security](/brantburnett/Snappier/security)
* [Insights](/brantburnett/Snappier/pulse)

Additional navigation options

* [Code](/brantburnett/Snappier)
* [Issues](/brantburnett/Snappier/issues)
* [Pull requests](/brantburnett/Snappier/pulls)
* [Actions](/brantburnett/Snappier/actions)
* [Security](/brantburnett/Snappier/security)
* [Insights](/brantburnett/Snappier/pulse)

## Commit

[Permalink](/brantburnett/Snappier/commit/d7ac5267b5b18439e6d108f8138edf48c436b32f)

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

Allow ref byte to point just past the end of spans ([#73](https://github.com/brantburnett/Snappier/pull/73))

[Browse files](/brantburnett/Snappier/tree/d7ac5267b5b18439e6d108f8138edf48c436b32f)
Browse the repository at this point in the history

```
Motivation
----------
I was under the impression that `ref byte` should never point past the
end of a `Span<byte>` or `ReadOnlySpan<byte>` because then GC couldn't
recognize the pointer and adjust it during GC moves. However, this there
is a specific exception that allows `ref byte` to point precisely one
byte past the end and still be recognized to allow pointer arithmetic
scenarios like the ones in this algorithm.

Modifications
-------------
Where there is more complex logic (compared to the reference C++
implementation) to allow buffer end pointers to point to the last byte
in the buffer simplify this logic and point one byte past the end of the
buffer.

Also ensure that comparison operations that ensure a certain length
don't involve an intermediate pointer that moves off the beginning of
the buffer.

Results
-------
We're now back to closer to the reference C++ implementation but still
have memory safety.
```

* Loading branch information

[![@brantburnett](https://avatars.githubusercontent.com/u/7118719?s=40&v=4)](/brantburnett)

[brantburnett](/brantburnett/Snappier/commits?author=brantburnett "View all commits by brantburnett")
authored
Mar 26, 2023

1 parent
[e3c9834](/brantburnett/Snappier/commit/e3c98344b3cb1681982427142f2def16b36035b8)

commit d7ac526

 Show file tree

 Hide file tree

Showing
**4 changed files**
with
**45 additions**
and
**56 deletions**.

* Whitespace
* Ignore whitespace

* Split
* Unified

* Snappier.Benchmarks

  + Snappier.Benchmarks/FindMatchLength.cs
    [FindMatchLength.cs](#diff-b308907059674c6c4c59f8fea74855efba9809ebe30faca1ccbd1ff8245b5224)
* Snappier.Tests/Internal

  + Snappier.Tests/Internal/SnappyCompressorTests.cs
    [SnappyCompressorTests.cs](#diff-4a9e6b7f8dc39a0bfa5b272a51d9e564117dd8cb7b6fbc325ed96cd2537aec12)
* Snappier/Internal

  + Snappier/Internal/SnappyCompressor.cs
    [SnappyCompressor.cs](#diff-34518769d76289a7cca8b946014c494aa733bad8743668d573a6e6f8309f77c5)
  + Snappier/Internal/SnappyDecompressor.cs
    [SnappyDecompressor.cs](#diff-a607ba1ddae96f4ed621e792edb17786af6b892f5631572d880665926b313bf4)

## There are no files selected for viewing

2 changes: 1 addition & 1 deletion

2
[Snappier.Benchmarks/FindMatchLength.cs](#diff-b308907059674c6c4c59f8fea74855efba9809ebe30faca1ccbd1ff8245b5224 "Snappier.Benchmarks/FindMatchLength.cs")

Show comments

[View file](/brantburnett/Snappier/blob/d7ac5267b5b18439e6d108f8138edf48c436b32f/Snappier.Benchmarks/FindMatchLength.cs)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -64,7 +64,7 @@ public void GlobalSetup() |
|  |  |  |
|  |  | ref byte s1 = ref \_array[0]; |
|  |  | ref byte s2 = ref Unsafe.Add(ref s1, 12); |
|  |  | ref byte s2Limit = ref Unsafe.Add(ref s1, \_array.Length - 1); |
|  |  | ref byte s2Limit = ref Unsafe.Add(ref s1, \_array.Length); |
|  |  |  |
|  |  | return SnappyCompressor.FindMatchLength(ref s1, ref s2, ref s2Limit, ref data); |
|  |  | } |
| Expand Down | |  |

2 changes: 1 addition & 1 deletion

2
[Snappier.Tests/Internal/SnappyCompressorTests.cs](#diff-4a9e6b7f8dc39a0bfa5b272a51d9e564117dd8cb7b6fbc325ed96cd2537aec12 "Snappier.Tests/Internal/SnappyCompressorTests.cs")

Show comments

[View file](/brantburnett/Snappier/blob/d7ac5267b5b18439e6d108f8138edf48c436b32f/Snappier.Tests/Internal/SnappyCompressorTests.cs)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -92,7 +92,7 @@ public void FindMatchLength(int expectedResult, string s1String, string s2String |
|  |  | ref byte s2 = ref Unsafe.Add(ref s1, s1String.Length); |
|  |  |  |
|  |  | var result = |
|  |  | SnappyCompressor.FindMatchLength(ref s1, ref s2, ref Unsafe.Add(ref s2, length - 1), ref data); |
|  |  | SnappyCompressor.FindMatchLength(ref s1, ref s2, ref Unsafe.Add(ref s2, length), ref data); |
|  |  |  |
|  |  | Assert.Equal(result.matchLength < 8, result.matchLengthLessThan8); |
|  |  | Assert.Equal(expectedResult, result.matchLength); |
| Expand Down | |  |

40 changes: 17 additions & 23 deletions

40
[Snappier/Internal/SnappyCompressor.cs](#diff-34518769d76289a7cca8b946014c494aa733bad8743668d573a6e6f8309f77c5 "Snappier/Internal/SnappyCompressor.cs")

Show comments

[View file](/brantburnett/Snappier/blob/d7ac5267b5b18439e6d108f8138edf48c436b32f/Snappier/Internal/SnappyCompressor.cs)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -125,16 +125,15 @@ private static int CompressFragment(ReadOnlySpan<byte> input, Span<byte> output, |
|  |  | uint mask = (uint)(2 \* (tableSpan.Length - 1)); |
|  |  |  |
|  |  | ref byte inputStart = ref Unsafe.AsRef(in input[0]); |
|  |  | // Last byte of the input, not one byte past the end, to avoid issues on GC moves |
|  |  | ref byte inputEnd = ref Unsafe.Add(ref inputStart, input.Length - 1); |
|  |  | ref byte inputEnd = ref Unsafe.Add(ref inputStart, input.Length); |
|  |  | ref byte ip = ref inputStart; |
|  |  |  |
|  |  | ref byte op = ref output[0]; |
|  |  | ref ushort table = ref tableSpan[0]; |
|  |  |  |
|  |  | if (input.Length >= Constants.InputMarginBytes) |
|  |  | { |
|  |  | ref byte ipLimit = ref Unsafe.Subtract(ref inputEnd, Constants.InputMarginBytes - 1); |
|  |  | ref byte ipLimit = ref Unsafe.Subtract(ref inputEnd, Constants.InputMarginBytes); |
|  |  |  |
|  |  | for (uint preload = Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref ip, 1));;) |
|  |  | { |
| Expand Down  Expand Up | | @@ -288,7 +287,7 @@ private static int CompressFragment(ReadOnlySpan<byte> input, Span<byte> output, |
|  |  | // Step 2: A 4-byte match has been found. We'll later see if more |
|  |  | // than 4 bytes match. But, prior to the match, input |
|  |  | // bytes [next\_emit, ip) are unmatched. Emit them as "literal bytes." |
|  |  | Debug.Assert(!Unsafe.IsAddressGreaterThan(ref Unsafe.Add(ref nextEmit, 16), ref Unsafe.Add(ref inputEnd, 1))); |
|  |  | Debug.Assert(!Unsafe.IsAddressGreaterThan(ref Unsafe.Add(ref nextEmit, 16), ref inputEnd)); |
|  |  | op = ref EmitLiteralFast(ref op, ref nextEmit, (uint) Unsafe.ByteOffset(ref nextEmit, ref ip)); |
|  |  |  |
|  |  | // Step 3: Call EmitCopy, and then see if another EmitCopy could |
| Expand Down  Expand Up | | @@ -350,9 +349,9 @@ private static int CompressFragment(ReadOnlySpan<byte> input, Span<byte> output, |
|  |  |  |
|  |  | emit\_remainder: |
|  |  | // Emit the remaining bytes as a literal |
|  |  | if (!Unsafe.IsAddressGreaterThan(ref ip, ref inputEnd)) |
|  |  | if (Unsafe.IsAddressLessThan(ref ip, ref inputEnd)) |
|  |  | { |
|  |  | op = ref EmitLiteralSlow(ref op, ref ip, (uint) Unsafe.ByteOffset(ref ip, ref inputEnd) + 1); |
|  |  | op = ref EmitLiteralSlow(ref op, ref ip, (uint) Unsafe.ByteOffset(ref ip, ref inputEnd)); |
|  |  | } |
|  |  |  |
|  |  | return (int) Unsafe.ByteOffset(ref output[0], ref op); |
| Expand Down  Expand Up | | @@ -490,28 +489,23 @@ private static ref byte EmitCopyLenGreaterThanOrEqualTo12(ref byte op, long offs |
|  |  | /// Find the largest n such that |
|  |  | /// |
|  |  | /// s1[0,n-1] == s2[0,n-1] |
|  |  | /// and n &lt;= (s2\_limit - s2 + 1). |
|  |  | /// and n &lt;= (s2\_limit - s2). |
|  |  | /// |
|  |  | /// Return (n, n &lt; 8). |
|  |  | /// Reads up to and including \*s2\_limit but not beyond. |
|  |  | /// Does not read \*(s1 + (s2\_limit - s2 + 1)) or beyond. |
|  |  | /// Requires that s2\_limit+1 &gt;= s2. |
|  |  | /// Does not read \*(s1 + (s2\_limit - s2)) or beyond. |
|  |  | /// Requires that s2\_limit &gt;= s2. |
|  |  | /// |
|  |  | /// In addition populate \*data with the next 5 bytes from the end of the match. |
|  |  | /// This is only done if 8 bytes are available (s2\_limit - s2 &gt;= 8). The point is |
|  |  | /// that on some arch's this can be done faster in this routine than subsequent |
|  |  | /// loading from s2 + n. |
|  |  | /// </summary> |
|  |  | /// <remarks> |
|  |  | /// The reference implementation has s2Limit as one byte past the end of the input, |
|  |  | /// but this implementation has it at the end of the input. This ensures that it always |
|  |  | /// points within the array in case GC moves the array. |
|  |  | /// </remarks> |
|  |  | [MethodImpl(MethodImplOptions.AggressiveInlining)] |
|  |  | internal static (int matchLength, bool matchLengthLessThan8) FindMatchLength( |
|  |  | ref byte s1, ref byte s2, ref byte s2Limit, ref ulong data) |
|  |  | { |
|  |  | Debug.Assert(!Unsafe.IsAddressLessThan(ref Unsafe.Add(ref s2Limit, 1), ref s2)); |
|  |  | Debug.Assert(!Unsafe.IsAddressLessThan(ref s2Limit, ref s2)); |
|  |  |  |
|  |  | if (BitConverter.IsLittleEndian && IntPtr.Size == 8) |
|  |  | { |
| Expand All | | @@ -521,14 +515,14 @@ internal static (int matchLength, bool matchLengthLessThan8) FindMatchLength( |
|  |  |  |
|  |  | int matched = 0; |
|  |  |  |
|  |  | while (!Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 3)) |
|  |  | while (Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)4 |
|  |  | && Helpers.UnsafeReadUInt32(ref s2) == Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref s1, matched))) |
|  |  | { |
|  |  | s2 = ref Unsafe.Add(ref s2, 4); |
|  |  | matched += 4; |
|  |  | } |
|  |  |  |
|  |  | if (BitConverter.IsLittleEndian && !Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 3))) |
|  |  | if (BitConverter.IsLittleEndian && Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)4) |
|  |  | { |
|  |  | uint x = Helpers.UnsafeReadUInt32(ref s2) ^ Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref s1, matched)); |
|  |  | int matchingBits = Helpers.FindLsbSetNonZero(x); |
| Expand All | | @@ -537,14 +531,14 @@ internal static (int matchLength, bool matchLengthLessThan8) FindMatchLength( |
|  |  | } |
|  |  | else |
|  |  | { |
|  |  | while (!Unsafe.IsAddressGreaterThan(ref s2, ref s2Limit) && Unsafe.Add(ref s1, matched) == s2) |
|  |  | while (Unsafe.IsAddressLessThan(ref s2, ref s2Limit) && Unsafe.Add(ref s1, matched) == s2) |
|  |  | { |
|  |  | s2 = ref Unsafe.Add(ref s2, 1); |
|  |  | ++matched; |
|  |  | } |
|  |  | } |
|  |  |  |
|  |  | if (!Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 7))) |
|  |  | if (Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)8) |
|  |  | { |
|  |  | data = Helpers.UnsafeReadUInt64(ref s2); |
|  |  | } |
| Expand All | | @@ -562,7 +556,7 @@ private static (int matchLength, bool matchLengthLessThan8) FindMatchLengthX64( |
|  |  | // immediately. As an optimization though, it is useful. It creates some not |
|  |  | // uncommon code paths that determine, without extra effort, whether the match |
|  |  | // length is less than 8. |
|  |  | if (!Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 15))) |
|  |  | if (Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)16) |
|  |  | { |
|  |  | ulong a1 = Helpers.UnsafeReadUInt64(ref s1); |
|  |  | ulong a2 = Helpers.UnsafeReadUInt64(ref s2); |
| Expand Down  Expand Up | | @@ -590,7 +584,7 @@ private static (int matchLength, bool matchLengthLessThan8) FindMatchLengthX64( |
|  |  | // time until we find a 64-bit block that doesn't match; then we find |
|  |  | // the first non-matching bit and use that to calculate the total |
|  |  | // length of the match. |
|  |  | while (!Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 15))) |
|  |  | while (Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)16) |
|  |  | { |
|  |  | ulong a1 = Helpers.UnsafeReadUInt64(ref Unsafe.Add(ref s1, matched)); |
|  |  | ulong a2 = Helpers.UnsafeReadUInt64(ref s2); |
| Expand All | | @@ -615,7 +609,7 @@ private static (int matchLength, bool matchLengthLessThan8) FindMatchLengthX64( |
|  |  | } |
|  |  | } |
|  |  |  |
|  |  | while (!Unsafe.IsAddressGreaterThan(ref s2, ref s2Limit)) |
|  |  | while (Unsafe.IsAddressLessThan(ref s2, ref s2Limit)) |
|  |  | { |
|  |  | if (Unsafe.Add(ref s1, matched) == s2) |
|  |  | { |
| Expand All | | @@ -624,7 +618,7 @@ private static (int matchLength, bool matchLengthLessThan8) FindMatchLengthX64( |
|  |  | } |
|  |  | else |
|  |  | { |
|  |  | if (!Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 7))) |
|  |  | if (Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)8) |
|  |  | { |
|  |  | data = Helpers.UnsafeReadUInt64(ref s2); |
|  |  | } |
| Expand Down | |  |

57 changes: 26 additions & 31 deletions

57
[Snappier/Internal/SnappyDecompressor.cs](#diff-a607ba1ddae96f4ed621e792edb17786af6b892f5631572d880665926b313bf4 "Snappier/Internal/SnappyDecompressor.cs")

Show comments

[View file](/brantburnett/Snappier/blob/d7ac5267b5b18439e6d108f8138edf48c436b32f/Snappier/Internal/SnappyDecompressor.cs)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -186,17 +186,11 @@ internal void DecompressAllTags(ReadOnlySpan<byte> inputSpan) |
|  |  | unchecked |
|  |  | { |
|  |  | ref byte input = ref Unsafe.AsRef(in inputSpan[0]); |
|  |  |  |
|  |  | // The reference Snappy implementation uses inputEnd as a pointer one byte past the end of the buffer. |
|  |  | // However, this is not safe when using ref locals. The ref must point to somewhere within the array |
|  |  | // so that GC can adjust the ref if the memory is moved. |
|  |  | ref byte inputEnd = ref Unsafe.Add(ref input, inputSpan.Length - 1); |
|  |  | ref byte inputEnd = ref Unsafe.Add(ref input, inputSpan.Length); |
|  |  |  |
|  |  | // Track the point in the input before which input is guaranteed to have at least Constants.MaxTagLength bytes left |
|  |  | ref byte inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd, Math.Min(inputSpan.Length, Constants.MaximumTagLength - 1) - 1); |
|  |  | ref byte inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd, Math.Min(inputSpan.Length, Constants.MaximumTagLength - 1)); |
|  |  |  |
|  |  | // We always allocate buffer with at least one extra byte on the end, so bufferEnd doesn't have the same |
|  |  | // restrictions as inputEnd. |
|  |  | ref byte buffer = ref \_lookbackBuffer.Span[0]; |
|  |  | ref byte bufferEnd = ref Unsafe.Add(ref buffer, \_lookbackBuffer.Length); |
|  |  | ref byte op = ref Unsafe.Add(ref buffer, \_lookbackPosition); |
| Expand Down  Expand Up | | @@ -239,9 +233,9 @@ internal void DecompressAllTags(ReadOnlySpan<byte> inputSpan) |
|  |  | { |
|  |  | // Data has been moved to the scratch buffer |
|  |  | input = ref scratch; |
|  |  | inputEnd = ref Unsafe.Add(ref input, newScratchLength - 1); |
|  |  | inputEnd = ref Unsafe.Add(ref input, newScratchLength); |
|  |  | inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd, |
|  |  | Math.Min(newScratchLength, Constants.MaximumTagLength - 1) - 1); |
|  |  | Math.Min(newScratchLength, Constants.MaximumTagLength - 1)); |
|  |  | } |
|  |  | } |
|  |  |  |
| Expand All | | @@ -256,7 +250,7 @@ internal void DecompressAllTags(ReadOnlySpan<byte> inputSpan) |
|  |  | { |
|  |  | nint literalLength = unchecked((c >> 2) + 1); |
|  |  |  |
|  |  | if (TryFastAppend(ref op, ref bufferEnd, in input, Unsafe.ByteOffset(ref input, ref inputEnd) + 1, literalLength)) |
|  |  | if (TryFastAppend(ref op, ref bufferEnd, in input, Unsafe.ByteOffset(ref input, ref inputEnd), literalLength)) |
|  |  | { |
|  |  | Debug.Assert(literalLength < 61); |
|  |  | op = ref Unsafe.Add(ref op, literalLength); |
| Expand All | | @@ -280,7 +274,7 @@ internal void DecompressAllTags(ReadOnlySpan<byte> inputSpan) |
|  |  | input = ref Unsafe.Add(ref input, literalLengthLength); |
|  |  | } |
|  |  |  |
|  |  | nint inputRemaining = Unsafe.ByteOffset(ref input, ref inputEnd) + 1; |
|  |  | nint inputRemaining = Unsafe.ByteOffset(ref input, ref inputEnd); |
|  |  | if (inputRemaining < literalLength) |
|  |  | { |
|  |  | Append(ref op, ref bufferEnd, in input, inputRemaining); |
| Expand All | | @@ -306,9 +300,9 @@ internal void DecompressAllTags(ReadOnlySpan<byte> inputSpan) |
|  |  | { |
|  |  | // Data has been moved to the scratch buffer |
|  |  | input = ref scratch; |
|  |  | inputEnd = ref Unsafe.Add(ref input, newScratchLength - 1); |
|  |  | inputEnd = ref Unsafe.Add(ref input, newScratchLength); |
|  |  | inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd, |
|  |  | Math.Min(newScratchLength, Constants.MaximumTagLength - 1) - 1); |
|  |  | Math.Min(newScratchLength, Constants.MaximumTagLength - 1)); |
|  |  |  |
|  |  | } |
|  |  | } |
| Expand Down  Expand Up | | @@ -367,9 +361,9 @@ internal void DecompressAllTags(ReadOnlySpan<byte> inputSpan) |
|  |  | { |
|  |  | // Data has been moved to the scratch buffer |
|  |  | input = ref scratch; |
|  |  | inputEnd = ref Unsafe.Add(ref input, newScratchLength - 1); |
|  |  | inputEnd = ref Unsafe.Add(ref input, newScratchLength); |
|  |  | inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd, |
|  |  | Math.Min(newScratchLength, Constants.MaximumTagLength - 1) - 1); |
|  |  | Math.Min(newScratchLength, Constants.MaximumTagLength - 1)); |
|  |  | } |
|  |  | } |
|  |  |  |
| Expand Down  Expand Up | | @@ -415,7 +409,7 @@ internal void DecompressAllTags(ReadOnlySpan<byte> inputSpan) |
|  |  | (int) literalLengthLength) + 1; |
|  |  | } |
|  |  |  |
|  |  | nint inputRemaining = Unsafe.ByteOffset(ref input, ref inputEnd) + 1; |
|  |  | nint inputRemaining = Unsafe.ByteOffset(ref input, ref inputEnd); |
|  |  | if (inputRemaining < literalLength) |
|  |  | { |
|  |  | Append(ref op, ref bufferEnd, in input, inputRemaining); |
| Expand Down  Expand Up | | @@ -468,7 +462,7 @@ private uint RefillTagFromScratch(ref byte input, ref byte inputEnd, ref byte sc |
|  |  | { |
|  |  | Debug.Assert(\_scratchLength > 0); |
|  |  |  |
|  |  | if (Unsafe.IsAddressGreaterThan(ref input, ref inputEnd)) |
|  |  | if (!Unsafe.IsAddressLessThan(ref input, ref inputEnd)) |
|  |  | { |
|  |  | return 0; |
|  |  | } |
| Expand All | | @@ -477,7 +471,7 @@ private uint RefillTagFromScratch(ref byte input, ref byte inputEnd, ref byte sc |
|  |  | uint entry = Constants.CharTable[scratch]; |
|  |  | uint needed = (entry >> 11) + 1; // +1 byte for 'c' |
|  |  |  |
|  |  | uint toCopy = Math.Min((uint)Unsafe.ByteOffset(ref input, ref inputEnd) + 1, needed - \_scratchLength); |
|  |  | uint toCopy = Math.Min((uint)Unsafe.ByteOffset(ref input, ref inputEnd), needed - \_scratchLength); |
|  |  | Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref scratch, \_scratchLength), ref input, toCopy); |
|  |  |  |
|  |  | \_scratchLength += toCopy; |
| Expand All | | @@ -502,7 +496,7 @@ private uint RefillTagFromScratch(ref byte input, ref byte inputEnd, ref byte sc |
|  |  | // always have some extra bytes on the end so we don't risk buffer overruns. |
|  |  | private uint RefillTag(ref byte input, ref byte inputEnd, ref byte scratch) |
|  |  | { |
|  |  | if (Unsafe.IsAddressGreaterThan(ref input, ref inputEnd)) |
|  |  | if (!Unsafe.IsAddressLessThan(ref input, ref inputEnd)) |
|  |  | { |
|  |  | return uint.MaxValue; |
|  |  | } |
| Expand All | | @@ -511,7 +505,7 @@ private uint RefillTag(ref byte input, ref byte inputEnd, ref byte scratch) |
|  |  | uint entry = Constants.CharTable[input]; |
|  |  | uint needed = (entry >> 11) + 1; // +1 byte for 'c' |
|  |  |  |
|  |  | uint inputLength = (uint)Unsafe.ByteOffset(ref input, ref inputEnd) + 1; |
|  |  | uint inputLength = (uint)Unsafe.ByteOffset(ref input, ref inputEnd); |
|  |  | if (inputLength < needed) |
|  |  | { |
|  |  | // Data is insufficient, copy to scratch |
| Expand Down  Expand Up | | @@ -555,11 +549,8 @@ private int? ExpectedLength |
|  |  | ArrayPool<byte>.Shared.Return(\_lookbackBufferArray); |
|  |  | } |
|  |  |  |
|  |  | // Always pad the lookback buffer with an extra byte that we don't use. This allows a "ref byte" reference past |
|  |  | // the end of the perceived buffer that still points within the array. This is a requirement so that GC can recognize |
|  |  | // the "ref byte" points within the array and adjust it if the array is moved. |
|  |  | \_lookbackBufferArray = ArrayPool<byte>.Shared.Rent(value.GetValueOrDefault() + 1); |
|  |  | \_lookbackBuffer = \_lookbackBufferArray.AsMemory(0, \_lookbackBufferArray.Length - 1); |
|  |  | \_lookbackBufferArray = ArrayPool<byte>.Shared.Rent(value.GetValueOrDefault()); |
|  |  | \_lookbackBuffer = \_lookbackBufferArray.AsMemory(0, \_lookbackBufferArray.Length); |
|  |  | } |
|  |  | } |
|  |  | } |
| Expand Down  Expand Up | | @@ -595,7 +586,7 @@ private void Append(ReadOnlySpan<byte> input) |
|  |  | } |
|  |  |  |
|  |  | [MethodImpl(MethodImplOptions.AggressiveInlining)] |
|  |  | private void Append(ref byte op, ref byte bufferEnd, in byte input, nint length) |
|  |  | private static void Append(ref byte op, ref byte bufferEnd, in byte input, nint length) |
|  |  | { |
|  |  | if (length > Unsafe.ByteOffset(ref op, ref bufferEnd)) |
|  |  | { |
| Expand All | | @@ -606,7 +597,7 @@ private void Append(ref byte op, ref byte bufferEnd, in byte input, nint length) |
|  |  | } |
|  |  |  |
|  |  | [MethodImpl(MethodImplOptions.AggressiveInlining)] |
|  |  | private bool TryFastAppend(ref byte op, ref byte bufferEnd, in byte input, nint available, nint length) |
|  |  | private static bool TryFastAppend(ref byte op, ref byte bufferEnd, in byte input, nint available, nint length) |
|  |  | { |
|  |  | if (length <= 16 && available >= 16 + Constants.MaximumTagLength && |
|  |  | Unsafe.ByteOffset(ref op, ref bufferEnd) >= (nint) 16) |
| Expand All | | @@ -619,10 +610,13 @@ private bool TryFastAppend(ref byte op, ref byte bufferEnd, in byte input, nint |
|  |  | } |
|  |  |  |
|  |  | [MethodImpl(MethodImplOptions.AggressiveInlining)] |
|  |  | private void AppendFromSelf(ref byte op, ref byte buffer, ref byte bufferEnd, uint copyOffset, nint length) |
|  |  | private static void AppendFromSelf(ref byte op, ref byte buffer, ref byte bufferEnd, uint copyOffset, nint length) |
|  |  | { |
|  |  | ref byte source = ref Unsafe.Subtract(ref op, copyOffset); |
|  |  | if (!Unsafe.IsAddressLessThan(ref source, ref op) || Unsafe.IsAddressLessThan(ref source, ref buffer)) |
|  |  | // ToInt64() ensures that this logic works correctly on x86 (with a slight perf hit on x86, though). This is because |
|  |  | // nint is only 32-bit on x86, so casting uint copyOffset to an nint for the comparison can result in a negative number with some |
|  |  | // forms of illegal data. This would then bypass the exception and cause unsafe memory access. Performing the comparison |
|  |  | // as a long ensures we have enough bits to not lose data. On 64-bit platforms this is effectively a no-op. |
|  |  | if (copyOffset == 0 || Unsafe.ByteOffset(ref buffer, ref op).ToInt64() < copyOffset) |
|  |  | { |
|  |  | ThrowHelper.ThrowInvalidDataException("Invalid copy offset"); |
|  |  | } |
| Expand All | | @@ -632,6 +626,7 @@ private void AppendFromSelf(ref byte op, ref byte buffer, ref byte bufferEnd, ui |
|  |  | ThrowHelper.ThrowInvalidDataException("Data too long"); |
|  |  | } |
|  |  |  |
|  |  | ref byte source = ref Unsafe.Subtract(ref op, copyOffset); |
|  |  | CopyHelpers.IncrementalCopy(ref source, ref op, |
|  |  | ref Unsafe.Add(ref op, length), ref bufferEnd); |
|  |  | } |
| Expand Down | |  |

Toggle all file notes
Toggle all file annotations

### 0 comments on commit `d7ac526`

Please
[sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fbrantburnett%2FSnappier%2Fcommit%2Fd7ac5267b5b18439e6d108f8138edf48c436b32f) to comment.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


