=== Content from developer.arm.com_07102a03_20250115_191812.html ===
You need to enable JavaScript to run this app.[Skip Navigation (Press Enter)](#header)[Skip to Content (Press Enter)](#content)HomeArm Security Center
# GCC Stack Protector Vulnerability AArch64

Entitlements could not be checked due to an error reaching the service. Showing non-confidential search results only.
## Report Security Vulnerabilities

###

Arm takes security issues seriously and welcomes feedback from researchers and the security community in order to improve the security of its products and services. We operate a coordinated disclosure policy for disclosing vulnerabilities and other security issues.

##### Reporting and Validation Process

* Report
* Acknowledge, evaluate, and verify.
* Resolve
* Communicate and disclose
[Report Security Vulnerabilities](https://developer.arm.com/documentation/102850/ "Report Security Vulnerabilities")![arm](https://developer.arm.com//-/media/global/logos/arm-logo-white-rgb.svg?rev=d98f22d309c84813a9d8434c89710774&revision=d98f22d3-09c8-4813-a9d8-434c89710774)Copyright Â© 1995-2025 Arm Limited (or its affiliates). All rights reserved.

=== Content from rtx.meta.security_ddc10e5d_20250115_191813.html ===
xml version="1.0" encoding="UTF-8" standalone="no"?

code

0x00400780

main (int argc, char \*\*argv);
; var int64\_t stack\_canary @ x29+0x18
; arg int argc @ x0
; arg char \*\*argv @ x1
stp   x29, x30, [sp, -0x20]!
adrp  x2, 0x41f000
add   x2, x2, 0xdd0
mov   x29, sp
ldr   x3, [x2]
str   x3, [x29, 0x18]
movz  x3, 0
movz  w2, 0x1
cmp   w0, 2
b.eq  0x4007d0

0x004007d0

ldr   x0, [x1, 8]
movz  w2, 0xa
movz  x1, 0
bl    sym.imp.strtol
sxtw  x0, w0
adrp  x3, reloc.\_\_libc\_start\_main
add   x0, x0, 0xf
and   x0, x0, 0xfffffffffffffff0
movz  x2, 0x1000
ldr   x3, [x3, 0x60]
sub   sp, sp, x0
movz  x1, 0x1
mov   x0, sp
bl    sym.imp.fread
mov   x2, x0
adrp  x1, reloc.\_\_libc\_start\_main
mov   x0, sp
ldr   x3, [x1, 0x50]
movz  x1, 0x1
bl    sym.imp.fwrite
movz  w2, 0
b     0x4007a8

0x00400780->0x004007d0

0x004007a8

adrp  x0, 0x41f000
ldr   x3, [x29, 0x18]
ldr   x1, [x0, 0xdd0]
subs  x3, x3, x1
movz  x1, 0
b.ne  0x400828

0x00400780->0x004007a8

0x004007d0->0x004007a8

0x00400828

bl    sym.imp.\_\_stack\_chk\_fail

0x004007a8->0x00400828

0x004007c0

mov   sp, x29
mov   w0, w2
ldp   x29, x30, [sp], 0x20
ret

0x004007a8->0x004007c0



=== Content from rtx.meta.security_864e7266_20250115_191814.html ===

[![]( "Meta Red Team X")
Meta Red Team X](/)

[BUGS](/bugs.html)[ABOUT](/about.html)[HOME](/)

Light

Dark

# CVE-2023-4039: GCC's -fstack-protector fails to guard dynamic stack allocations on ARM64

##

 Sep 12, 2023
 Tom Hebb, Red Team X
 About 18 mins

GCC’s stack smashing protection, which keeps attackers from exploiting stack buffer overflow bugs in code it compiles, has no effect when the vulnerable buffer is a variable-length array or `alloca()` allocation and the target architecture is 64-bit ARM. This issue is a mitigation weakness and is not exploitable directly. [A fix is now available on GCC’s mailing list.](https://gcc.gnu.org/pipermail/gcc-patches/2023-September/630054.html) All versions of GCC are affected, so we recommend you incorporate that fix if you distribute GCC or ARM64 binaries compiled with GCC.

## Background

[Memory safety bugs cause most security vulnerabilities in C and C++ programs.](https://www.memorysafety.org/docs/memory-safety/#how-common-are-memory-safety-vulnerabilities) A common and easily-exploitable type of memory safety bug is the **stack buffer overflow**, in which a program fails to check that an attacker-controlled length or offset is within the bounds of a local (i.e. stack-allocated) array, allowing the attacker to write to memory past the end of that array:

1. Stack buffer overflows are common because C makes bounds checking hard. The only way to pass an array to a function in C is to pass a pointer to the beginning of that array, which discards its length. Well-written functions take the length as a separate parameter so they can perform bounds checks, but many functions (e.g. `gets()` and `strcpy()` in libc) aren’t well-written. Even ones that are have no way to verify that the length is correct and not, say, derived from an attacker-controlled input.
2. Stack buffer overflows are easily exploitable because they usually let an attacker control execution instead of just data. The stack, which holds local variables of each running function, also holds each function’s **return address**, which tells it where it was called from so it can go back there once it’s done. By changing the return address, the attacker can make the program run code of their choosing.

Compiler warnings and static analysis tools help solve #1 by flagging safety bugs when code is written, but the nature of C and C++ makes both false positives and false negatives inevitable. (Safe languages like Rust fully solve #1, but it’ll be a while yet before the average person relies on no security-critical C or C++ in their daily life.)

As such, modern C/C++ compilers also try to solve #2 by making stack buffer overflows harder to exploit in the programs they compile. They do so using [various techniques](https://en.wikipedia.org/wiki/Buffer_overflow_protection), but the one we’ll discuss today is known as **stack smashing protection**.

Functions compiled with stack smashing protection place a secret, randomly-generated value known as a **stack guard** or **stack canary** in their stack frame, between their local variables and their return address. Right before they return, they check if the guard has changed and (in most runtimes) abort the program immediately if it has. The compiler automatically inserts the instructions to set and check the guard, so no source code changes are needed.

Such a drastic response is warranted because, if the stack guard changes, there’s a 100% chance that a buffer overflow has occurred. The reverse is not true, though: stack guards only reliably detect **contiguous** overflow bugs, in which an attacker controls the length of data written to a local array but not the offset. If they do control the offset, they can selectively overwrite the return address while leaving the guard and other intervening bytes unchanged. Many real-world bugs allow only contiguous overflows, though; for those, stack guards are effective.

[GCC](https://gcc.gnu.org/) is one of the most popular C/C++ compilers in the world. It protects against stack smashing exactly as just described when invoked with the `-fstack-protector` flag or one of its variants. AArch64 is the 64-bit version of the ARM architecture and powers most modern handheld devices.

## Vulnerability details

On AArch64 targets, GCC’s stack smashing protection does not detect or defend against overflows of dynamically-sized local variables. In C, dynamically-sized variables include both [variable-length arrays](https://en.wikipedia.org/wiki/Variable-length_array) and buffers allocated using `alloca()`. GCC’s AArch64 stack frames place such variables immediately below saved register values like the return address with no intervening stack guard. All versions of GCC that support the pertinent features are affected.

The reason this happens for AArch64 but not for other GCC targets is because GCC’s AArch64 backend lays out stack frames in an unconventional way: instead of saving the return address at the top of a frame (i.e. at the highest address, pushed before anything else) like most other backends and compilers, it saves it near the bottom of the frame, *below* the local variables. [This comment](https://gcc.gnu.org/git/?p=gcc.git&a=blob&f=gcc%2Fconfig%2Faarch64%2Faarch64.cc&h=44935e80565f#l9940) from GCC’s source documents the frame layout:

```
/* AArch64 stack frames generated by this compiler look like:

	+-------------------------------+
	|                               |
	|  incoming stack arguments     |
	|                               |
	+-------------------------------+
	|                               | <-- incoming stack pointer (aligned)
	|  callee-allocated save area   |
	|  for register varargs         |
	|                               |
	+-------------------------------+
	|  local variables              | <-- frame_pointer_rtx
	|                               |
	+-------------------------------+
	|  padding                      | \
	+-------------------------------+  |
	|  callee-saved registers       |  | frame.saved_regs_size
	+-------------------------------+  |
	|  LR'                          |  |
	+-------------------------------+  |
	|  FP'                          |  |
	+-------------------------------+  |<- hard_frame_pointer_rtx (aligned)
	|  SVE vector registers         |  | \
	+-------------------------------+  |  | below_hard_fp_saved_regs_size
	|  SVE predicate registers      | /  /
	+-------------------------------+
	|  dynamic allocation           |
	+-------------------------------+
	|  padding                      |
	+-------------------------------+
	|  outgoing stack arguments     | <-- arg_pointer
	|                               |
	+-------------------------------+
	|                               | <-- stack_pointer_rtx (aligned)

```

`LR'` is the return address, so named because it’s saved from the [LR](https://developer.arm.com/documentation/dui0801/l/Overview-of-AArch64-state/Link-registers) register, and is the target of nearly all stack smashing attacks. It may then seem like a feature, not a bug, to put it at a lower address than the locals: a contiguous overflow only lets an attacker write to memory past the vulnerable local, so this layout keeps the return address out of their reach! In practice though, the memory immediately past a function’s stack frame is almost always another stack frame (belonging to the calling function) with its own saved LR value that the attacker can manipulate to the same effect.

You may notice that the layout above makes no mention of a stack guard. That’s because GCC’s architecture-independent code treats the stack guard as a local, [placing it](https://gcc.gnu.org/git/?p=gcc.git&a=blob&f=gcc%2Fcfgexpand.cc&h=85a93a547c0b#l2286) at the very top of the local area without any input from the target backend. Implicit in that placement is an assumption that locals will always occupy one contiguous region with no saved registers interspersed. But that assumption doesn’t hold on AArch64: as shown in the diagram, dynamic allocations live at the very bottom of the stack frame, below the saved registers, with no intervening guard.

Dynamic allocations are just as susceptible to overflows as other locals. In fact, they’re arguably more susceptible because they’re almost always arrays, whereas fixed locals are often integers, pointers, or other types to which variable-length data is never written. GCC’s own heuristics for when to use a stack guard reflect this, with its man page saying this about `-fstack-protector` (emphasis ours):

> Emit extra code to check for buffer overflows … by adding a guard variable to functions with vulnerable objects. This includes **functions that call “alloca”**, and functions with buffers larger than or equal to 8 bytes.

## Demonstration

The following C program is vulnerable to a contiguous stack overflow attack even when compiled with `-fstack-protector` or `-fstack-protector-all`:

```
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
    if (argc != 2)
        return 1;

    // Variable-length array
    uint8_t input[atoi(argv[1])];

    size_t n = fread(input, 1, 4096, stdin);
    fwrite(input, 1, n, stdout);

    return 0;
}

```

We cross-compiled this program for AArch64 using Arm’s GCC 12.2.Rel1 [prebuilt toolchain](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads) and then ran it under QEMU, with debugging enabled, on an x86\_64 host:

```
$ aarch64-none-linux-gnu-gcc -fstack-protector-all -O3 -static -Wall -Wextra -pedantic -o example-dynamic example-dynamic.c
$ echo -n 'DDDDDDDDPPPPPPPPFFFFFFFFAAAAAAAA' | qemu-aarch64 -g 5555 example-dynamic 8

```

We ask the program to make a dynamic allocation of size 8, which GCC rounds up to 16. The exploit payload mirrors the stack layout, with the eight “D”s representing the non-overflowing data, the eight “P”s padding out the actual allocation, the eight “F”s overwriting the saved frame pointer, and the eight “A”s overwriting the saved return address.

Attaching a debugger and resuming the program results in an immediate segfault with PC set to the address from our payload, showing we have full control over execution flow despite the stack guard:

```
$ gdb example-dynamic
GNU gdb (GDB) Fedora Linux 13.1-3.fc37
<snip>
(gdb) target remote :5555
Remote debugging using :5555
<snip>
(gdb) continue
Continuing.

Program received signal SIGBUS, Bus error.
0x0041414141414141 in ?? ()
(gdb) print/a $pc
$1 = 0x41414141414141

```

For comparison, the following program, which uses a fixed allocation of size 8 instead of a dynamic one, detects the overflow correctly (the “G”s in the payload overwrite the guard):

```
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    uint8_t input[8];

    size_t n = fread(input, 1, 4096, stdin);
    fwrite(input, 1, n, stdout);

    return 0;
}

```

```
$ aarch64-none-linux-gnu-gcc -fstack-protector-all -O3 -static -Wall -Wextra -pedantic -o example-static example-static.c
$ echo -n 'DDDDDDDDGGGGGGGG' | qemu-aarch64 example-static
*** stack smashing detected ***: terminated
Aborted (core dumped)

```
## Response

Meta’s Red Team X reported this issue privately to Arm on May 31st, 2023. We would have preferred to report the issue to GCC, but at that time GCC had no documented private disclosure process. Progress has since been made on [creating one](https://gcc.gnu.org/pipermail/gcc-patches/2023-August/626529.html). Since every AArch64 maintainer in GCC’s `MAINTAINERS` file has an @arm.com email address, Arm was our next best choice.

Arm acknowledged our report immediately, and their compiler team confirmed our findings within a day. They had a fix ready by August 1st and met with us to agree on a coordinated disclosure process. Over the following month, Arm shared the patch with widely-used Linux distributions and other partners of theirs, both to get extra eyes on the patch and to allow those partners time to rebuild their software repositories. As it happens, one partner found an issue with Arm’s initial fix—involving a missing barrier against instruction reordering—that made it inadequate in certain cases. We delayed our initial disclosure date to allow Arm to distribute a revised version of the patch.

Arm has been extremely responsive throughout the process and has taken the lead to get the fix where it needs to go. We’d like to thank them for their professionalism.

Because GCC development happens in the open, we were unable to coordinate with GCC to announce new releases simultaneous with this post and other disclosures. However, [Arm’s patches for the issue](https://gcc.gnu.org/pipermail/gcc-patches/2023-September/630054.html) are now on GCC’s mailing list, and we expect releases to follow in short order. The following other disclosures will also appear:

* [CVE-2023-4039](https://www.cve.org/CVERecord?id=CVE-2023-4039)
* [Arm’s security bulletin](https://developer.arm.com/Arm%20Security%20Center/GCC%20Stack%20Protector%20Vulnerability%20AArch64)
* [Meta’s disclosure](https://github.com/metaredteam/external-disclosures/security/advisories/GHSA-x7ch-h5rf-w2mf)

## Prior work

GCC’s ARM stack guards have a history of subtle correctness issues:

* [Faulty Stack Smashing Protection on ARM Systems](https://blog.inhq.net/posts/faulty-stack-canary-arm-systems/) by Christian Reitter: writeup of a GCC bug that caused AArch32 stack guards to hold the address of the guard value rather than the value itself, making it much easier to guess.
* [CVE-2018-12886](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85434): a GCC bug that in certain cases let an attacker control what value an AArch32 stack guard was compared against by overwriting a different stack variable that was not itself protected.

## Appendix: assembly analysis

We graphed the proof-of-concept binaries from above using [Rizin](https://rizin.re/)’s [`agfd` command](https://book.rizin.re/analysis/graphs.html) to illustrate how the problem manifests in assembly. This is the disassembly graph of the buggy `example-dynamic`:

!["Control flow graph for dynamic allocation"](https://rtx.meta.security/assets/images/CVE-2023-4039/example-dynamic-main.svg)

There’s a lot happening, but the **bold** lines are the ones to focus on. The very first instruction in the function, `stp x29, x30, [sp, -0x20]!`, decrements the `sp` register by `0x20` (the `!` means modify `sp` instead of just calculating an offset), thereby reserving space for the function’s stack frame, then **st**ores a **p**air of registers at the bottom of that reserved space. Those registers, `x29` and `x30`, are the frame pointer and link register (LR) respectively. Recall that LR holds the return address that an attacker aims to control.

A few instructions later, `str x3, [x29, 0x18]` places the 8-byte stack guard at the top of the stack space. `x29`, the frame pointer, has been updated to match the decremented `sp`, a value it retains for the rest of the function. At this point, the stack looks like this (offsets relative to `x29`):

```
 0x18 stack guard
 0x10 padding
 0x08 saved x29
 0x00 saved x30 (LR)  	<-- x29, sp

```

`sp`, on the other hand, doesn’t keep its value: to allocate the dynamically-sized `input` array, it’s decremented by `input`’s size (`sub sp, sp, x0`). It’s then passed as the first argument to `fread()`, which populates it with user-controlled data. Assuming a dynamic size of 8 (which GCC pads to 16), the stack now looks like this:

```
 0x18 stack guard
 0x10 padding
 0x08 saved x29
 0x00 saved x30 (LR)  	<-- x29
-0x08 padding
-0x10 input[8]          <-- sp

```

At this point, the issue is clear: an contiguous overflow of `input` reaches the saved LR before it even gets close to the stack guard, making the guard ineffective for detecting that overflow.

---

For comparison, here’s the disassembly graph of `example-static`, which does not perform any dynamic allocation:

!["Control flow graph for static allocation"](https://rtx.meta.security/assets/images/CVE-2023-4039/example-static-main.svg)

The function begins exactly the same way, storing saved registers at the bottom of the frame and the stack guard at the top. But when it comes time to read user input, `sp` isn’t decremented again. Instead, the first argument to `fread()` is within the already-allocated space, *above* the saved registers (`add x0, sp, 0x10`). So we have a stack layout like this:

```
 0x18 stack guard
 0x10 input[8]
 0x08 saved x29
 0x00 saved x30 (LR)  	<-- x29, sp

```

Here, the stack guard works just as it’s designed: since it immediately follows `input`, an attacker can’t manipulate anything further up the stack using a contiguous overflow without also changing the guard’s value.

## Appendix: disclosure timeline

* April 27th, 2023: During an [Azeria Labs](https://azeria-labs.com/) ARM exploitation training, we notice that one of the demo binaries has a misplaced stack canary and investigate the cause.
* May 31st, 2023: We disclose the issue privately to Arm, as GCC has no security contact and every MAINTAINER of GCC’s AArch64 backend is Arm-affiliated.
* May 31st, 2023: Arm’s Product Security Incident Response Team acknowledges and triages the report.
* June 1st, 2023: Arm confirms that the report is valid and asks if we intend to issue a CVE or if they should. We respond that we prefer the latter.
* July 13th, 2023: We remind Arm that the 90-day disclosure window is nearly halfway past and ask for a progress update.
* August 1st, 2023: Arm indicates they have a fix ready and requests a call with Meta to discuss coordinated disclosure.
* August 3rd, 2023: Arm and RTX meet. Arm proposes notifying distros and hyperscale partners prior to public disclosure. Meta agrees to that plan.
* August 21st, 2023: Arm and RTX meet again to finalize the disclosure timeline. We agree to make all advisories and patches public on August 29th, 90 days after RTX’s initial report, unless any of Arm’s partners request an extension.
* August 23rd, 2023: One of Arm’s partners requests disclosure be postponed by a week, so we set the new date to September 5th.
* August 30th, 2023: Arm notifies us that a compiler partner found a weakness in the patched mitigation and that they’ll need to revise their patch. We agree to postpone disclosure by another week, to September 12th, to allow time for that.
* September 12th, 2023: This post, [our disclosure](https://github.com/metaredteam/external-disclosures/security/advisories/GHSA-x7ch-h5rf-w2mf) [Arm’s security advisory](https://developer.arm.com/Arm%20Security%20Center/GCC%20Stack%20Protector%20Vulnerability%20AArch64), [CVE-2023-4039](https://developer.arm.com/Arm%20Security%20Center/GCC%20Stack%20Protector%20Vulnerability%20AArch64), and [patches on GCC’s mailing list](https://gcc.gnu.org/pipermail/gcc-patches/2023-September/630054.html) all go live simultaneously.

[Sandboxing ImageIO media parsing in macOS...](/mitigation/2023/09/11/Sandboxing-ImageIO-in-macOS.html "Sandboxing ImageIO media parsing in macOS")[Missing signs: how several brands forgot...](/exploitation/2024/01/30/Android-vendors-APEX-test-keys.html "Missing signs: how several brands forgot to secure a key piece of Android")
Related Articles

* [In-Memory Execution in macOS: the Old and the New
  TOP
  NEW](/post-exploitation/2022/12/19/In-Memory-Execution-in-macOS.html "In-Memory Execution in macOS: the Old and the New")
* [Becoming any Android app via Zygote command injection
  TOP
  NEW](/exploitation/2024/06/03/Android-Zygote-injection.html "Becoming any Android app via Zygote command injection")
* [The many meanings of "system app" in modern Android
  TOP
  NEW](/reference/2024/07/03/Android-system-apps.html "The many meanings of \"system app\" in modern Android")
* [Uncovering Hidden .NET Assemblies
  TOP
  NEW](/reversing/2022/09/21/Uncovering_Hidden_NET_Assemblies.html "Uncovering Hidden .NET Assemblies")

TOC

© 2022-2024 Meta Red Team X
Powered by [Jekyll](https://jekyllrb.com/ "Jekyll is a simple, blog-aware, static site
      generator.") & [Yat Theme](https://github.com/jeffreytse/jekyll-theme-yat "Yat, yet
      another theme.").
Subscribe [via RSS](/feed.xml)



=== Content from avatars.githubusercontent.com_85f3d69e_20250115_191814.html ===
�PNG

   
IHDR   (   (   ���m    pHYs  �  ��+  �IDATX�}��od�u�wxS��5�ܭV�Ȇ%%B`�p���{�]d �D��J�l��� 2-8Q�$[�;�d���A����\�"k���=Y�Wd�M�j��{�=�w��?��
(@�R( J�����(�B ?N����)!�2����o�gA綡�{x����|�q�%"|�ύ�x�����/Â:���':1@T�
�[��"�&�xv\)�+�E���]�\_�r��a��~Њ��!��SuZ�#�������0<
�䧓��s�ߜo�T�{E�:�
�|q��RL�V�ٳ 2�x���ˋԧ���5�s��M�!;�y��3PI�s���}��
��.�v�����'������6;;{���u�("�����:oa���;E�C9��\P���U���v�F���~k,�y� `���.Ci�Қ��&���{kܻ��9(�Ph��\_\#��0�E!=�Q��\_�����uR�{ ��0f)��h�ɼ#�Ql�^8��I�^�G�R�kk���{ON`�\�E�"� |�?D��9�`�a��Ŋ!3��J�D!�4��^�f�٢E(���C���{�0� ��Nk��w�����}�F�ec�����'�2\*q�\��+�+\~a���Y�qB:2�R��o�k~����<��v��~���h���\_��L(d��WoR-%x��h��$qH|����,L�׿��WV���&�b� @kE��d.��+\_�?���|��4c�e8�O�O.0�|����\*Zkʥ�RbQh��!�v��̖+��������MV������aDc��!�;����kߤ���g�Q��a{&�.�aFM �J; �
#\*��g�XY��m�X���\���F)�(���
Z��x��u���-��4GC�0�Ш��)����ȩ$��t@(�4�sPk
6��\*O/�F� �,Jy��(� m@5)��r|��Γ��<
q�h�B H��,W�+o���h�`���2| 8/�e,ʘ��T>�!�R�������ф�Z�1��`'Q� U��)��XkQ����q/�9���wm�f$����k��[�(%1��{|�h
c4e騏s�/7�8<�!"p��rye�KKg9��|��y(J��!�d�0�<�G�/�g�C^w��j�ϧ��>�����gT���z���<�^��a�f���@�y}�o\A�����R|~�K�iz�Vk�oq���2^�<��K�G�R�b������o���ޛo��+\*@Ъ(���R��WHg9�X>ޥ՛��ws3 � <(7��
�)G�D���1ӵ9�]��Pk[����3�����;|J��b8p�������bq��bq~�j%�y�av��t����z������7/\_c��e�n�z'�ZKuf�p��M�;`���V��j�(�<�:
�2W��l�
&��E2���2֞lG �j��O�ZK`-���Ao���6�R�ՙ9�1���8=�R��6����?$K�����2�9l� u��,$��V��PDN
�֬�,��
ғ/ʕ��
S������'`\_2��.pkn�P[�y�w�����u�
�Ģ�VX��$�L�H����x�������\�z��?J���k���?�y����%o~�[��I�V��{�����K3u�� ˄8T���ZMd}��r&�r=��pb
��o;y3aL:���m^]x���y������G�y��w�2�hKR\*S�������݇���8��@ἐ��F�刑�f�\qxl�л"g�[$��飑ck��2A�p��
t����Ո�(�0;3����̡�"5G]G9�x�����9�K�EB�!��W�7���1�P���f����D�%�^`0h���ϞmP��Ak��q���SS��8L����FzEW�Nd�sc��#��/<�τ<�v�̳}�gc���ӵ]�#GYiʵ\v� �v6q�ˌ�p�u4�f��Z%�:�A�(6a���j�Zt�d�O��cM����2�)ų�>��E!:G�������#\*�:6.%%����H����A&2�g��sTc��L�r)B������;œ}�Ӄ6I \_[�Y���"x�����}�>�x�1��Z��fJ��� J[� �J��V�6�|�nJ)�x�ů���4����'����(����9��N`�B� '��q���B3K�Z�y����!�L#X�hD4J[��(ڄ[e���.��K���˿�)���Æw��;w�Z����.��>&�rƬ4ژ��y/d^��a����58I1A{���=6F8���\�蓕�b�yWU��!�j�,a�px4�3���런������6�&�0�<��
F�~ޖS�>/Bm&�2x�M�(=%��?��<�K�R���V�=�e=�}�gڜt�ƞ�}���Y�n��$/��i�� �܋����aD������=z}����6,��]�2Q�s�cm����=�
�5�Xl�M��}mL�,o���q�9�&�.���w�sp�/�{���8Mš��    IEND�B`�

=== Content from github.com_32ea9219_20250114_214410.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fmetaredteam%2Fexternal-disclosures%2Fsecurity%2Fadvisories%2FGHSA-x7ch-h5rf-w2mf)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fmetaredteam%2Fexternal-disclosures%2Fsecurity%2Fadvisories%2FGHSA-x7ch-h5rf-w2mf)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=metaredteam%2Fexternal-disclosures)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[metaredteam](/metaredteam)
/
**[external-disclosures](/metaredteam/external-disclosures)**
Public

* [Notifications](/login?return_to=%2Fmetaredteam%2Fexternal-disclosures) You must be signed in to change notification settings
* [Fork
  3](/login?return_to=%2Fmetaredteam%2Fexternal-disclosures)
* [Star
   27](/login?return_to=%2Fmetaredteam%2Fexternal-disclosures)

* [Code](/metaredteam/external-disclosures)
* [Pull requests
  0](/metaredteam/external-disclosures/pulls)
* [Security](/metaredteam/external-disclosures/security)
* [Insights](/metaredteam/external-disclosures/pulse)

Additional navigation options

* [Code](/metaredteam/external-disclosures)
* [Pull requests](/metaredteam/external-disclosures/pulls)
* [Security](/metaredteam/external-disclosures/security)
* [Insights](/metaredteam/external-disclosures/pulse)

# GCC's -fstack-protector fails to guard dynamic stack allocations on ARM64

Moderate

[tchebb](/tchebb)
published
GHSA-x7ch-h5rf-w2mf
Sep 12, 2023

## Package

GCC
(C)

## Affected versions

All, as of disclosure

## Patched versions

None

## Description

**For more detailed analysis of this issue, see [Red Team X's blog post about it](https://rtx.meta.security/mitigation/2023/09/12/CVE-2023-4039.html).**

GCC's stack smashing protection, which keeps attackers from exploiting stack buffer overflow bugs in code it compiles, has no effect when the vulnerable buffer is a variable-length array or `alloca()` allocation and the target architecture is 64-bit ARM. This issue is a mitigation weakness and is not exploitable directly. [A fix is now available on GCC's mailing list.](https://gcc.gnu.org/pipermail/gcc-patches/2023-September/630054.html) All versions of GCC are affected, so we recommend you incorporate that fix if you distribute GCC or ARM64 binaries compiled with GCC.

# Vulnerability details

On AArch64 targets, GCC's stack smashing protection does not detect or defend against overflows of dynamically-sized local variables. In C, dynamically-sized variables include both [variable-length arrays](https://en.wikipedia.org/wiki/Variable-length_array) and buffers allocated using `alloca()`. GCC's AArch64 stack frames place such variables immediately below saved register values like the return address with no intervening stack guard. All versions of GCC that we tested, from 5.4.0 to trunk as of 2023-05-15, are affected.

The reason this happens for AArch64 but not for other GCC targets is because GCC's AArch64 backend lays out stack frames in an unconventional way: instead of saving the return address at the top of a frame (i.e. at the highest address, pushed before anything else) like most other backends and compilers, it saves it near the bottom of the frame, *below* the local variables. [This comment](https://gcc.gnu.org/git/?p=gcc.git&a=blob&f=gcc%2Fconfig%2Faarch64%2Faarch64.cc&h=44935e80565f#l9940) from GCC's source documents the frame layout:

```
/* AArch64 stack frames generated by this compiler look like:

	+-------------------------------+
	|                               |
	|  incoming stack arguments     |
	|                               |
	+-------------------------------+
	|                               | <-- incoming stack pointer (aligned)
	|  callee-allocated save area   |
	|  for register varargs         |
	|                               |
	+-------------------------------+
	|  local variables              | <-- frame_pointer_rtx
	|                               |
	+-------------------------------+
	|  padding                      | \
	+-------------------------------+  |
	|  callee-saved registers       |  | frame.saved_regs_size
	+-------------------------------+  |
	|  LR'                          |  |
	+-------------------------------+  |
	|  FP'                          |  |
	+-------------------------------+  |<- hard_frame_pointer_rtx (aligned)
	|  SVE vector registers         |  | \
	+-------------------------------+  |  | below_hard_fp_saved_regs_size
	|  SVE predicate registers      | /  /
	+-------------------------------+
	|  dynamic allocation           |
	+-------------------------------+
	|  padding                      |
	+-------------------------------+
	|  outgoing stack arguments     | <-- arg_pointer
	|                               |
	+-------------------------------+
	|                               | <-- stack_pointer_rtx (aligned)
*/
```

`LR'` is the return address, so named because it's saved from the [LR](https://developer.arm.com/documentation/dui0801/l/Overview-of-AArch64-state/Link-registers) register, and is the target of nearly all stack smashing attacks. It may then seem like a feature, not a bug, to put it at a lower address than the locals: a contiguous overflow only lets an attacker write to memory past the vulnerable local, so this layout keeps the return address out of their reach! In practice though, the memory immediately past a function's stack frame is almost always another stack frame (belonging to the calling function) with its own saved LR value that the attacker can manipulate to the same effect.

You may notice that the layout above makes no mention of a stack guard. That's because GCC's architecture-independent code treats the stack guard as a local, [placing it](https://gcc.gnu.org/git/?p=gcc.git&a=blob&f=gcc%2Fcfgexpand.cc&h=85a93a547c0b#l2286) at the very top of the local area without any input from the target backend. Implicit in that placement is an assumption that locals will always occupy one contiguous region with no saved registers interspersed. But that assumption doesn't hold on AArch64: as shown in the diagram, dynamic allocations live at the very bottom of the stack frame, below the saved registers, with no intervening guard.

Dynamic allocations are just as susceptible to overflows as other locals. In fact, they're arguably more susceptible because they're almost always arrays, whereas fixed locals are often integers, pointers, or other types to which variable-length data is never written. GCC's own heuristics for when to use a stack guard reflect this, with its man page saying this about `-fstack-protector` (emphasis ours):

> Emit extra code to check for buffer overflows … by adding a guard variable to functions with vulnerable objects. This includes **functions that call "alloca"**, and functions with buffers larger than or equal to 8 bytes.

# Proof of concept

The following C program is vulnerable to a contiguous stack overflow attack even when compiled with `-fstack-protector` or `-fstack-protector-all`:

```
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
    if (argc != 2)
        return 1;

    // Variable-length array
    uint8_t input[atoi(argv[1])];

    size_t n = fread(input, 1, 4096, stdin);
    fwrite(input, 1, n, stdout);

    return 0;
}
```

We cross-compiled this program for AArch64 using Arm's GCC 12.2.Rel1 [prebuilt toolchain](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads) and then ran it under QEMU, with debugging enabled, on an x86\_64 host:

```
$ aarch64-none-linux-gnu-gcc -fstack-protector-all -O3 -static -Wall -Wextra -pedantic -o example-dynamic example-dynamic.c
$ echo -n 'DDDDDDDDPPPPPPPPFFFFFFFFAAAAAAAA' | qemu-aarch64 -g 5555 example-dynamic 8

```

We ask the program to make a dynamic allocation of size 8, which GCC rounds up to 16. The exploit payload mirrors the stack layout, with the eight "D"s representing the non-overflowing data, the eight "P"s padding out the actual allocation, the eight "F"s overwriting the saved frame pointer, and the eight "A"s overwriting the saved return address.

Attaching a debugger and resuming the program results in an immediate segfault with PC set to the address from our payload, showing we have full control over execution flow despite the stack guard:

```
$ gdb example-dynamic
GNU gdb (GDB) Fedora Linux 13.1-3.fc37
<snip>
(gdb) target remote :5555
Remote debugging using :5555
<snip>
(gdb) continue
Continuing.

Program received signal SIGBUS, Bus error.
0x0041414141414141 in ?? ()
(gdb) print/a $pc
$1 = 0x41414141414141

```

For comparison, the following program, which uses a fixed allocation of size 8 instead of a dynamic one, detects the overflow correctly (the "G"s in the payload overwrite the guard):

```
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    uint8_t input[8];

    size_t n = fread(input, 1, 4096, stdin);
    fwrite(input, 1, n, stdout);

    return 0;
}
```

```
$ aarch64-none-linux-gnu-gcc -fstack-protector-all -O3 -static -Wall -Wextra -pedantic -o example-static example-static.c
$ echo -n 'DDDDDDDDGGGGGGGG' | qemu-aarch64 example-static
*** stack smashing detected ***: terminated
Aborted (core dumped)

```

### Severity

Moderate

4.8

# CVSS overall score

 This score calculates overall vulnerability severity from 0 to 10 and is based on the Common Vulnerability Scoring System (CVSS).

 / 10

#### CVSS v3 base metrics

Attack vector
Network

Attack complexity
High

Privileges required
None

User interaction
None

Scope
Unchanged

Confidentiality
Low

Integrity
Low

Availability
None

Learn more about base metrics

# CVSS v3 base metrics

Attack vector:
More severe the more the remote (logically and physically) an attacker can be in order to exploit the vulnerability.

Attack complexity:
More severe for the least complex attacks.

Privileges required:
More severe if no privileges are required.

User interaction:
More severe when no user interaction is required.

Scope:
More severe when a scope change occurs, e.g. one vulnerable component impacts resources in components beyond its security scope.

Confidentiality:
More severe when loss of data confidentiality is highest, measuring the level of data access available to an unauthorized user.

Integrity:
More severe when loss of data integrity is the highest, measuring the consequence of data modification possible by an unauthorized user.

Availability:
More severe when the loss of impacted component availability is highest.

CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N

### CVE ID

CVE-2023-4039

### Weaknesses

[CWE-119](/advisories?query=cwe%3A119) [CWE-358](/advisories?query=cwe%3A358)

### Credits

* [![@tchebb](https://avatars.githubusercontent.com/u/1082640?s=40&v=4)](/tchebb)
  [tchebb](/tchebb)
  Finder
* [![@azeria-labs](https://avatars.githubusercontent.com/u/26645463?s=40&v=4)](/azeria-labs)
  [azeria-labs](/azeria-labs)
  Finder

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from rtx.meta.security_cb0933f7_20250115_191813.html ===
xml version="1.0" encoding="UTF-8" standalone="no"?

code

0x00400740

main ();
; var int64\_t stack\_canary @ sp+0x18
stp   x29, x30, [sp, -0x20]!
adrp  x1, reloc.\_\_libc\_start\_main
adrp  x0, 0x41f000
mov   x29, sp
ldr   x3, [x1, 0x50]
add   x0, x0, 0xdd0
ldr   x1, [x0]
str   x1, [sp, 0x18]
movz  x1, 0
movz  x2, 0x1000
movz  x1, 0x1
add   x0, sp, 0x10
bl    sym.imp.fread
mov   x2, x0
adrp  x3, reloc.\_\_libc\_start\_main
movz  x1, 0x1
add   x0, sp, 0x10
ldr   x3, [x3, 0x40]
bl    sym.imp.fwrite
adrp  x0, 0x41f000
ldr   x2, [sp, 0x18]
ldr   x1, [x0, 0xdd0]
subs  x2, x2, x1
movz  x1, 0
b.ne  0x4007b0

0x004007b0

bl    sym.imp.\_\_stack\_chk\_fail

0x00400740->0x004007b0

0x004007a4

movz  w0, 0
ldp   x29, x30, [sp], 0x20
ret

0x00400740->0x004007a4


