```json
{
  "CVE-2023-4155": {
    "Description": "A KVM guest using SEV-ES or SEV-SNP with multiple vCPUs can trigger a double fetch race condition vulnerability and invoke the VMGEXIT handler recursively.  sev_handle_vmgexit() maps the GHCB page using kvm_vcpu_map() and then fetches the exit code using ghcb_get_sw_exit_code(). Soon after, sev_es_validate_vmgexit() fetches the exit code again. Since the GHCB page is shared with the guest, the guest is able to quickly swap the values with another vCPU and hence bypass the validation. One vmexit code that can be rejected by sev_es_validate_vmgexit() is SVM_EXIT_VMGEXIT; if sev_handle_vmgexit() observes it in the second fetch, the call to svm_invoke_exit_handler() will invoke sev_handle_vmgexit() again recursively.",
    "Root cause": "Double fetch race condition on GHCB shared memory, where the guest can modify the GHCB data between fetches",
    "Weaknesses": [
      "Time-of-check time-of-use vulnerability",
      "Double fetch of shared memory",
      "Recursive invocation of the VMGEXIT handler due to lack of proper validation"
    ],
    "Impact": "An attacker can cause a denial of service by triggering a stack overflow. Guest to host escape is possible if stack guard pages are disabled",
    "Attack vectors": [
      "A malicious KVM guest using SEV-ES or SEV-SNP"
    ],
    "Required attacker capabilities": "The attacker needs to control a guest OS and have the ability to modify the GHCB shared memory. Requires multiple vCPUs"
  }
}
```