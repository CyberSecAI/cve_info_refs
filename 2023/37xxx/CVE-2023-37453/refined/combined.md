=== Content from git.kernel.org_1a9011c9_20250114_225408.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Alan Stern <stern@rowland.harvard.edu> | 2023-08-04 15:14:14 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-08-08 10:45:32 +0200 |
| commit | [ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b)) | |
| tree | [7b422b0776b0070f995cd02215f85561f7d9b207](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b) | |
| parent | [de28e469da75359a2bb8cd8778b78aa64b1be1f4](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b&id2=de28e469da75359a2bb8cd8778b78aa64b1be1f4)) | |
| download | [linux-ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b.tar.gz) | |

USB: core: Fix race by not overwriting udev->descriptor in hub\_port\_init()Syzbot reported an out-of-bounds read in sysfs.c:read\_descriptors():
BUG: KASAN: slab-out-of-bounds in read\_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
Read of size 8 at addr ffff88801e78b8c8 by task udevd/5011
CPU: 0 PID: 5011 Comm: udevd Not tainted 6.4.0-rc6-syzkaller-00195-g40f71e7cd3c6 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023
Call Trace:
<TASK>
\_\_dump\_stack lib/dump\_stack.c:88 [inline]
dump\_stack\_lvl+0xd9/0x150 lib/dump\_stack.c:106
print\_address\_description.constprop.0+0x2c/0x3c0 mm/kasan/report.c:351
print\_report mm/kasan/report.c:462 [inline]
kasan\_report+0x11c/0x130 mm/kasan/report.c:572
read\_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
...
Allocated by task 758:
...
\_\_do\_kmalloc\_node mm/slab\_common.c:966 [inline]
\_\_kmalloc+0x5e/0x190 mm/slab\_common.c:979
kmalloc include/linux/slab.h:563 [inline]
kzalloc include/linux/slab.h:680 [inline]
usb\_get\_configuration+0x1f7/0x5170 drivers/usb/core/config.c:887
usb\_enumerate\_device drivers/usb/core/hub.c:2407 [inline]
usb\_new\_device+0x12b0/0x19d0 drivers/usb/core/hub.c:2545
As analyzed by Khazhy Kumykov, the cause of this bug is a race between
read\_descriptors() and hub\_port\_init(): The first routine uses a field
in udev->descriptor, not expecting it to change, while the second
overwrites it.
Prior to commit 45bf39f8df7f ("USB: core: Don't hold device lock while
reading the "descriptors" sysfs file") this race couldn't occur,
because the routines were mutually exclusive thanks to the device
locking. Removing that locking from read\_descriptors() exposed it to
the race.
The best way to fix the bug is to keep hub\_port\_init() from changing
udev->descriptor once udev has been initialized and registered.
Drivers expect the descriptors stored in the kernel to be immutable;
we should not undermine this expectation. In fact, this change should
have been made long ago.
So now hub\_port\_init() will take an additional argument, specifying a
buffer in which to store the device descriptor it reads. (If udev has
not yet been initialized, the buffer pointer will be NULL and then
hub\_port\_init() will store the device descriptor in udev as before.)
This eliminates the data race responsible for the out-of-bounds read.
The changes to hub\_port\_init() appear more extensive than they really
are, because of indentation changes resulting from an attempt to avoid
writing to other parts of the usb\_device structure after it has been
initialized. Similar changes should be made to the code that reads
the BOS descriptor, but that can be handled in a separate patch later
on. This patch is sufficient to fix the bug found by syzbot.
Reported-and-tested-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com
Closes: https://lore.kernel.org/linux-usb/000000000000c0ffe505fe86c9ca@google.com/#r
Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Cc: Khazhy Kumykov <khazhy@google.com>
Fixes: 45bf39f8df7f ("USB: core: Don't hold device lock while reading the "descriptors" sysfs file")
Cc: stable@vger.kernel.org
Link: [https://lore.kernel.org/r/b958b47a-9a46-4c22-a9f9-e42e42c31251@rowland.harvard.edu](https://lore.kernel.org/r/b958b47a-9a46-4c22-a9f9-e42e42c31251%40rowland.harvard.edu)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b)

| -rw-r--r-- | [drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/usb/core/hub.c?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b) | 114 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 70 insertions, 44 deletions

| diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.cindex 9279c8ccbcf250..878913f4b4b3c7 100644--- a/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hub.c?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4)+++ b/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hub.c?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b)@@ -4816,10 +4816,17 @@ static int get\_bMaxPacketSize0(struct usb\_device \*udev, \* the port lock. For a newly detected device that is not accessible \* through any global pointers, it's not necessary to lock the device, \* but it is still necessary to lock the port.+ \*+ \* For a newly detected device, @dev\_descr must be NULL. The device+ \* descriptor retrieved from the device will then be stored in+ \* @udev->descriptor. For an already existing device, @dev\_descr+ \* must be non-NULL. The device descriptor will be stored there,+ \* not in @udev->descriptor, because descriptors for registered+ \* devices are meant to be immutable. \*/ static int hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,- int retry\_counter)+ int retry\_counter, struct usb\_device\_descriptor \*dev\_descr) { struct usb\_device \*hdev = hub->hdev; struct usb\_hcd \*hcd = bus\_to\_hcd(hdev->bus);@@ -4831,6 +4838,7 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, int devnum = udev->devnum; const char \*driver\_name; bool do\_new\_scheme;+ const bool initial = !dev\_descr; int maxp0; struct usb\_device\_descriptor \*buf, \*descr; @@ -4869,32 +4877,34 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } oldspeed = udev->speed; - /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...- \* it's fixed size except for full speed devices.- \* For Wireless USB devices, ep0 max packet is always 512 (tho- \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1].- \*/- switch (udev->speed) {- case USB\_SPEED\_SUPER\_PLUS:- case USB\_SPEED\_SUPER:- case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512);- break;- case USB\_SPEED\_HIGH: /\* fixed at 64 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- break;- case USB\_SPEED\_FULL: /\* 8, 16, 32, or 64 \*/- /\* to determine the ep0 maxpacket size, try to read- \* the device descriptor to get bMaxPacketSize0 and- \* then correct our initial guess.+ if (initial) {+ /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...+ \* it's fixed size except for full speed devices.+ \* For Wireless USB devices, ep0 max packet is always 512 (tho+ \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1]. \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- break;- case USB\_SPEED\_LOW: /\* fixed at 8 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(8);- break;- default:- goto fail;+ switch (udev->speed) {+ case USB\_SPEED\_SUPER\_PLUS:+ case USB\_SPEED\_SUPER:+ case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512);+ break;+ case USB\_SPEED\_HIGH: /\* fixed at 64 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);+ break;+ case USB\_SPEED\_FULL: /\* 8, 16, 32, or 64 \*/+ /\* to determine the ep0 maxpacket size, try to read+ \* the device descriptor to get bMaxPacketSize0 and+ \* then correct our initial guess.+ \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);+ break;+ case USB\_SPEED\_LOW: /\* fixed at 8 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(8);+ break;+ default:+ goto fail;+ } }  if (udev->speed == USB\_SPEED\_WIRELESS)@@ -4917,22 +4927,24 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, if (udev->speed < USB\_SPEED\_SUPER) dev\_info(&udev->dev, "%s %s USB device number %d using %s\n",- (udev->config) ? "reset" : "new", speed,+ (initial ? "new" : "reset"), speed, devnum, driver\_name); - /\* Set up TT records, if needed \*/- if (hdev->tt) {- udev->tt = hdev->tt;- udev->ttport = hdev->ttport;- } else if (udev->speed != USB\_SPEED\_HIGH- && hdev->speed == USB\_SPEED\_HIGH) {- if (!hub->tt.hub) {- dev\_err(&udev->dev, "parent hub has no TT\n");- retval = -EINVAL;- goto fail;+ if (initial) {+ /\* Set up TT records, if needed \*/+ if (hdev->tt) {+ udev->tt = hdev->tt;+ udev->ttport = hdev->ttport;+ } else if (udev->speed != USB\_SPEED\_HIGH+ && hdev->speed == USB\_SPEED\_HIGH) {+ if (!hub->tt.hub) {+ dev\_err(&udev->dev, "parent hub has no TT\n");+ retval = -EINVAL;+ goto fail;+ }+ udev->tt = &hub->tt;+ udev->ttport = port1; }- udev->tt = &hub->tt;- udev->ttport = port1; }  /\* Why interleave GET\_DESCRIPTOR and SET\_ADDRESS this way?@@ -4966,6 +4978,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,  maxp0 = get\_bMaxPacketSize0(udev, buf, GET\_DESCRIPTOR\_BUFSIZE, retries == 0);+ if (maxp0 > 0 && !initial &&+ maxp0 != udev->descriptor.bMaxPacketSize0) {+ dev\_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");+ retval = -ENODEV;+ goto fail;+ }  retval = hub\_port\_reset(hub, port1, udev, delay, false); if (retval < 0) /\* error or disconnect \*/@@ -5039,6 +5057,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } else { u32 delay; + if (!initial && maxp0 != udev->descriptor.bMaxPacketSize0) {+ dev\_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");+ retval = -ENODEV;+ goto fail;+ }+ delay = udev->parent->hub\_delay; udev->hub\_delay = min\_t(u32, delay, USB\_TP\_TRANSMISSION\_DELAY\_MAX);@@ -5082,7 +5106,10 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, retval); goto fail; }- udev->descriptor = \*descr;+ if (initial)+ udev->descriptor = \*descr;+ else+ \*dev\_descr = \*descr; kfree(descr);  /\*@@ -5392,7 +5419,7 @@ static void hub\_port\_connect(struct usb\_hub \*hub, int port1, u16 portstatus, }  /\* reset (non-USB 3.0 devices) and get descriptor \*/- status = hub\_port\_init(hub, udev, port1, i);+ status = hub\_port\_init(hub, udev, port1, i, NULL); if (status < 0) goto loop; @@ -6022,7 +6049,7 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) struct usb\_device \*parent\_hdev = udev->parent; struct usb\_hub \*parent\_hub; struct usb\_hcd \*hcd = bus\_to\_hcd(udev->bus);- struct usb\_device\_descriptor descriptor = udev->descriptor;+ struct usb\_device\_descriptor descriptor; struct usb\_host\_bos \*bos; int i, j, ret = 0; int port1 = udev->portnum;@@ -6058,7 +6085,7 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) /\* ep0 maxpacket size may change; let the HCD know about it. \* Other endpoints will be handled by re-enumeration. \*/ usb\_ep0\_reinit(udev);- ret = hub\_port\_init(parent\_hub, udev, port1, i);+ ret = hub\_port\_init(parent\_hub, udev, port1, i, &descriptor); if (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV) break; }@@ -6070,7 +6097,6 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) /\* Device might have changed firmware (DFU or similar) \*/ if (descriptors\_changed(udev, &descriptor, bos)) { dev\_info(&udev->dev, "device firmware changed\n");- udev->descriptor = descriptor; /\* for disconnect() calls \*/ goto re\_enumerate; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 22:52:45 +0000



=== Content from lore.kernel.org_2b9124cb_20250114_225409.html ===

```
[All of lore.kernel.org](../../?t=20191022145414)
 [help](../../_/text/help/) / [color](../../_/text/color/) / [mirror](../../_/text/mirror/) / [Atom feed](../../new.atom)
```
```
[*](#eee54bc45c39d77a778d73324f842c580e47a330a) KASAN: slab-out-of-bounds Read in read_descriptors
@ 2019-10-22 14:54 syzbot
  [0 siblings, 0 replies; only message in thread](#ree54bc45c39d77a778d73324f842c580e47a330a)
From: syzbot @ 2019-10-22 14:54 UTC ([permalink](../../000000000000e56434059580f86e%40google.com/) / [raw](../../000000000000e56434059580f86e%40google.com/raw))
  To: andreyknvl, gregkh, kai.heng.feng, [linux-kernel](../../../lkml/?t=20191022145414), [linux-usb](../../../linux-usb/?t=20191022145414),
	syzkaller-bugs, tweek

Hello,

syzbot found the following crash on:

HEAD commit:    22be26f7 usb-fuzzer: main usb gadget fuzzer driver
git tree:       <https://github.com/google/kasan.git> usb-fuzzer
console output: <https://syzkaller.appspot.com/x/log.txt?x=17bf83e8e00000>
kernel config:  <https://syzkaller.appspot.com/x/.config?x=387eccb7ac68ec5>
dashboard link: <https://syzkaller.appspot.com/bug?extid=11eed0a63c4f31acd096>
compiler:       gcc (GCC) 9.0.0 20181231 (experimental)

Unfortunately, I don't have any reproducer for this crash yet.

IMPORTANT: if you fix the bug, please add the following tag to the commit:
Reported-by: syzbot+11eed0a63c4f31acd096@syzkaller.appspotmail.com

==================================================================
BUG: KASAN: slab-out-of-bounds in read_descriptors+0x256/0x270
drivers/usb/core/sysfs.c:903
Read of size 8 at addr ffff8881ce6e4350 by task udevd/9454

CPU: 1 PID: 9454 Comm: udevd Not tainted 5.4.0-rc3+ #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS
Google 01/01/2011
Call Trace:
  __dump_stack lib/dump_stack.c:77 [inline]
  dump_stack+0xca/0x13e lib/dump_stack.c:113
  print_address_description.constprop.0+0x36/0x50 mm/kasan/report.c:374
  __kasan_report.cold+0x1a/0x33 mm/kasan/report.c:506
  kasan_report+0xe/0x20 mm/kasan/common.c:634
  read_descriptors+0x256/0x270 drivers/usb/core/sysfs.c:903
  sysfs_kf_bin_read+0x196/0x270 fs/sysfs/file.c:99
  kernfs_file_direct_read fs/kernfs/file.c:213 [inline]
  kernfs_fop_read+0x2eb/0x560 fs/kernfs/file.c:253
  __vfs_read+0x76/0x100 fs/read_write.c:425
  vfs_read+0x1ea/0x430 fs/read_write.c:461
  ksys_read+0x127/0x250 fs/read_write.c:587
  do_syscall_64+0xb7/0x580 arch/x86/entry/common.c:290
  entry_SYSCALL_64_after_hwframe+0x49/0xbe
RIP: 0033:0x7f10f2702310
Code: 73 01 c3 48 8b 0d 28 4b 2b 00 31 d2 48 29 c2 64 89 11 48 83 c8 ff eb
ea 90 90 83 3d e5 a2 2b 00 00 75 10 b8 00 00 00 00 0f 05 <48> 3d 01 f0 ff
ff 73 31 c3 48 83 ec 08 e8 6e 8a 01 00 48 89 04 24
RSP: 002b:00007ffd6a810e48 EFLAGS: 00000246 ORIG_RAX: 0000000000000000
RAX: ffffffffffffffda RBX: 0000000000000005 RCX: 00007f10f2702310
RDX: 0000000000010011 RSI: 00007ffd6a810e80 RDI: 0000000000000005
RBP: 000000000174e640 R08: 000000000000000c R09: 75642f6d726f6674
R10: 2e6463685f796d6d R11: 0000000000000246 R12: 00007ffd6a821590
R13: 0000000001741250 R14: 0000000000000000 R15: 00000000017421c0

Allocated by task 22:
  save_stack+0x1b/0x80 mm/kasan/common.c:69
  set_track mm/kasan/common.c:77 [inline]
  __kasan_kmalloc mm/kasan/common.c:510 [inline]
  __kasan_kmalloc.constprop.0+0xbf/0xd0 mm/kasan/common.c:483
  kmalloc include/linux/slab.h:561 [inline]
  kzalloc include/linux/slab.h:690 [inline]
  usb_get_configuration+0x184/0x3050 drivers/usb/core/config.c:825
  usb_enumerate_device drivers/usb/core/hub.c:2369 [inline]
  usb_new_device+0xd3/0x160 drivers/usb/core/hub.c:2505
  hub_port_connect drivers/usb/core/hub.c:5183 [inline]
  hub_port_connect_change drivers/usb/core/hub.c:5323 [inline]
  port_event drivers/usb/core/hub.c:5469 [inline]
  hub_event+0x1dd0/0x37e0 drivers/usb/core/hub.c:5551
  process_one_work+0x92b/0x1530 kernel/workqueue.c:2269
  worker_thread+0x96/0xe20 kernel/workqueue.c:2415
  kthread+0x318/0x420 kernel/kthread.c:255
  ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:352

Freed by task 2807:
  save_stack+0x1b/0x80 mm/kasan/common.c:69
  set_track mm/kasan/common.c:77 [inline]
  kasan_set_free_info mm/kasan/common.c:332 [inline]
  __kasan_slab_free+0x130/0x180 mm/kasan/common.c:471
  slab_free_hook mm/slub.c:1424 [inline]
  slab_free_freelist_hook mm/slub.c:1475 [inline]
  slab_free mm/slub.c:3018 [inline]
  kfree+0xe4/0x320 mm/slub.c:3967
  usb_set_configuration+0xba8/0x1670 drivers/usb/core/message.c:1962
  generic_probe+0x9d/0xd5 drivers/usb/core/generic.c:210
  usb_probe_device+0x99/0x100 drivers/usb/core/driver.c:266
  really_probe+0x281/0x6d0 drivers/base/dd.c:548
  driver_probe_device+0x104/0x210 drivers/base/dd.c:721
  __device_attach_driver+0x1c2/0x220 drivers/base/dd.c:828
  bus_for_each_drv+0x162/0x1e0 drivers/base/bus.c:430
  __device_attach+0x217/0x360 drivers/base/dd.c:894
  bus_probe_device+0x1e4/0x290 drivers/base/bus.c:490
  device_add+0xae6/0x16f0 drivers/base/core.c:2201
  usb_new_device.cold+0x6a4/0xe79 drivers/usb/core/hub.c:2536
  hub_port_connect drivers/usb/core/hub.c:5183 [inline]
  hub_port_connect_change drivers/usb/core/hub.c:5323 [inline]
  port_event drivers/usb/core/hub.c:5469 [inline]
  hub_event+0x1dd0/0x37e0 drivers/usb/core/hub.c:5551
  process_one_work+0x92b/0x1530 kernel/workqueue.c:2269
  worker_thread+0x96/0xe20 kernel/workqueue.c:2415
  kthread+0x318/0x420 kernel/kthread.c:255
  ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:352

The buggy address belongs to the object at ffff8881ce6e4348
  which belongs to the cache kmalloc-8 of size 8
The buggy address is located 0 bytes to the right of
  8-byte region [ffff8881ce6e4348, ffff8881ce6e4350)
The buggy address belongs to the page:
page:ffffea000739b900 refcount:1 mapcount:0 mapping:ffff8881da003900
index:0x0
flags: 0x200000000000200(slab)
raw: 0200000000000200 ffffea0007632e40 0000000a0000000a ffff8881da003900
raw: 0000000000000000 0000000000aa00aa 00000001ffffffff 0000000000000000
page dumped because: kasan: bad access detected

Memory state around the buggy address:
  ffff8881ce6e4200: fc fc fb fc fc fb fc fc fb fc fc fb fc fc fb fc
  ffff8881ce6e4280: fc fb fc fc fb fc fc fb fc fc fb fc fc fb fc fc
> ffff8881ce6e4300: fb fc fc fb fc fc fb fc fc 00 fc fc fb fc fc fb
                                                  ^
  ffff8881ce6e4380: fc fc fb fc fc fb fc fc fb fc fc fb fc fc fb fc
  ffff8881ce6e4400: fc fb fc fc fb fc fc fb fc fc fb fc fc fb fc fc
==================================================================

---
This bug is generated by a bot. It may contain errors.
See <https://goo.gl/tpsmEJ> for more information about syzbot.
syzbot engineers can be reached at syzkaller@googlegroups.com.

syzbot will keep track of this bug report. See:
<https://goo.gl/tpsmEJ#status> for how to communicate with syzbot.

[^](#mee54bc45c39d77a778d73324f842c580e47a330a) [permalink](../../000000000000e56434059580f86e%40google.com/) [raw](../../000000000000e56434059580f86e%40google.com/raw) [reply](../../000000000000e56434059580f86e%40google.com/#R)	[[flat](../../000000000000e56434059580f86e%40google.com/T/#u)|[nested](../../000000000000e56434059580f86e%40google.com/t/#u)] [only message in thread](#ree54bc45c39d77a778d73324f842c580e47a330a)
```

---

```
only message in thread, other threads:[[~2019-10-22 14:54 UTC](../../?t=20191022145414) | [newest](../../)]

Thread overview: (only message) (download: [mbox.gz](../t.mbox.gz) follow: [Atom feed](../t.atom)
-- links below jump to the message on this page --
2019-10-22 14:54 [KASAN: slab-out-of-bounds Read in read_descriptors](#mee54bc45c39d77a778d73324f842c580e47a330a) syzbot

```

---

```
This is an external index of several public inboxes,
see [mirroring instructions](../../_/text/mirror/) on how to clone and mirror
all data and code used by this external index.
```


=== Content from git.kernel.org_1e8d2ec2_20250114_225406.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Alan Stern <stern@rowland.harvard.edu> | 2023-08-08 20:44:18 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-08-09 14:17:06 +0200 |
| commit | [1e4c574225cc5a0553115e5eb5787d1474db5b0f](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)) | |
| tree | [d8635c8f7594e6b423edf57fd8275b4d07d65639](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | |
| parent | [12e6ac69cc7e7d3367599ae26a92a0f9a18bc728](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f&id2=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)) | |
| download | [linux-1e4c574225cc5a0553115e5eb5787d1474db5b0f.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-1e4c574225cc5a0553115e5eb5787d1474db5b0f.tar.gz) | |

USB: Remove remnants of Wireless USB and UWBWireless USB has long been defunct, and kernel support for it was
removed in 2020 by commit caa6772db4c1 ("Staging: remove wusbcore and
UWB from the kernel tree.").
Nevertheless, some vestiges of the old implementation still clutter up
the USB subsystem and one or two other places. Let's get rid of them
once and for all.
The only parts still left are the user-facing APIs in
include/uapi/linux/usb/ch9.h. (There are also a couple of misleading
instances, such as the Sierra Wireless USB modem, which is a USB modem
made by Sierra Wireless.)
Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Link: [https://lore.kernel.org/r/b4f2710f-a2de-4fb0-b50f-76776f3a961b@rowland.harvard.edu](https://lore.kernel.org/r/b4f2710f-a2de-4fb0-b50f-76776f3a961b%40rowland.harvard.edu)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)

| -rw-r--r-- | [drivers/net/wireless/mediatek/mt76/usb.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/net/wireless/mediatek/mt76/usb.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | 3 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/usb/core/config.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/usb/core/config.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/usb/core/devices.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/usb/core/devices.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/usb/core/hcd.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/usb/core/hcd.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | 40 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/usb/core/hub.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | 155 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/usb/core/sysfs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/usb/core/sysfs.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/usb/core/urb.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/usb/core/urb.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | 27 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/usb/core/usb.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/usb/core/usb.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | 11 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/usb/host/xhci-mem.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/usb/host/xhci-mem.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/usb/host/xhci.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/usb/host/xhci.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | 11 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/usb.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/usb.h?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/usb/ch9.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/usb/ch9.h?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/usb/composite.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/usb/composite.h?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | 23 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/usb/hcd.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/usb/hcd.h?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/uapi/linux/usb/ch11.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/uapi/linux/usb/ch11.h?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/uapi/linux/usb/ch9.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/uapi/linux/usb/ch9.h?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f) | 5 | |  |  |  | | --- | --- | --- | |

16 files changed, 62 insertions, 248 deletions

| diff --git a/drivers/net/wireless/mediatek/mt76/usb.c b/drivers/net/wireless/mediatek/mt76/usb.cindex 5e5c7bf51174ac..1584665fe3cb68 100644--- a/[drivers/net/wireless/mediatek/mt76/usb.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/net/wireless/mediatek/mt76/usb.c?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)+++ b/[drivers/net/wireless/mediatek/mt76/usb.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/net/wireless/mediatek/mt76/usb.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)@@ -286,8 +286,7 @@ static bool mt76u\_check\_sg(struct mt76\_dev \*dev) struct usb\_device \*udev = interface\_to\_usbdev(uintf);  return (!disable\_usb\_sg && udev->bus->sg\_tablesize > 0 &&- (udev->bus->no\_sg\_constraint ||- udev->speed == USB\_SPEED\_WIRELESS));+ udev->bus->no\_sg\_constraint); }  static intdiff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.cindex 725b8dbcfe5f06..b19e38d5fd10c1 100644--- a/[drivers/usb/core/config.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/config.c?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)+++ b/[drivers/usb/core/config.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/config.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)@@ -1051,9 +1051,6 @@ int usb\_get\_bos\_descriptor(struct usb\_device \*dev) }  switch (cap\_type) {- case USB\_CAP\_TYPE\_WIRELESS\_USB:- /\* Wireless USB cap descriptor is handled by wusb \*/- break; case USB\_CAP\_TYPE\_EXT: dev->bos->ext\_cap = (struct usb\_ext\_cap\_descriptor \*)buffer;diff --git a/drivers/usb/core/devices.c b/drivers/usb/core/devices.cindex 2c14a963605637..a247da73f34d7d 100644--- a/[drivers/usb/core/devices.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/devices.c?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)+++ b/[drivers/usb/core/devices.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/devices.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)@@ -424,7 +424,6 @@ static ssize\_t usb\_device\_dump(char \_\_user \*\*buffer, size\_t \*nbytes, case USB\_SPEED\_UNKNOWN: /\* usb 1.1 root hub code \*/ case USB\_SPEED\_FULL: speed = "12"; break;- case USB\_SPEED\_WIRELESS: /\* Wireless has no real fixed speed \*/ case USB\_SPEED\_HIGH: speed = "480"; break; case USB\_SPEED\_SUPER:diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.cindex 6af0a31ff14758..12b6dfeaf658c9 100644--- a/[drivers/usb/core/hcd.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hcd.c?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)+++ b/[drivers/usb/core/hcd.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hcd.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)@@ -156,27 +156,6 @@ static const u8 usb3\_rh\_dev\_descriptor[18] = { 0x01 /\* \_\_u8 bNumConfigurations; \*/ }; -/\* usb 2.5 (wireless USB 1.0) root hub device descriptor \*/-static const u8 usb25\_rh\_dev\_descriptor[18] = {- 0x12, /\* \_\_u8 bLength; \*/- USB\_DT\_DEVICE, /\* \_\_u8 bDescriptorType; Device \*/- 0x50, 0x02, /\* \_\_le16 bcdUSB; v2.5 \*/-- 0x09, /\* \_\_u8 bDeviceClass; HUB\_CLASSCODE \*/- 0x00, /\* \_\_u8 bDeviceSubClass; \*/- 0x00, /\* \_\_u8 bDeviceProtocol; [ usb 2.0 no TT ] \*/- 0xFF, /\* \_\_u8 bMaxPacketSize0; always 0xFF (WUSB Spec 7.4.1). \*/-- 0x6b, 0x1d, /\* \_\_le16 idVendor; Linux Foundation 0x1d6b \*/- 0x02, 0x00, /\* \_\_le16 idProduct; device 0x0002 \*/- KERNEL\_VER, KERNEL\_REL, /\* \_\_le16 bcdDevice \*/-- 0x03, /\* \_\_u8 iManufacturer; \*/- 0x02, /\* \_\_u8 iProduct; \*/- 0x01, /\* \_\_u8 iSerialNumber; \*/- 0x01 /\* \_\_u8 bNumConfigurations; \*/-};- /\* usb 2.0 root hub device descriptor \*/ static const u8 usb2\_rh\_dev\_descriptor[18] = { 0x12, /\* \_\_u8 bLength; \*/@@ -368,7 +347,7 @@ static const u8 ss\_rh\_config\_descriptor[] = { };  /\* authorized\_default behaviour:- \* -1 is authorized for all devices except wireless (old behaviour)+ \* -1 is authorized for all devices (leftover from wireless USB) \* 0 is unauthorized for all devices \* 1 is authorized for all devices \* 2 is authorized for internal devices@@ -383,7 +362,7 @@ module\_param(authorized\_default, int, S\_IRUGO|S\_IWUSR); MODULE\_PARM\_DESC(authorized\_default, "Default USB device authorization: 0 is not authorized, 1 is " "authorized, 2 is authorized for internal devices, -1 is "- "authorized except for wireless USB (default, old behaviour)");+ "authorized (default, same as 1)"); /\*-------------------------------------------------------------------------\*/  /\*\*@@ -578,9 +557,6 @@ static int rh\_call\_control (struct usb\_hcd \*hcd, struct urb \*urb) case HCD\_USB3: bufp = usb3\_rh\_dev\_descriptor; break;- case HCD\_USB25:- bufp = usb25\_rh\_dev\_descriptor;- break; case HCD\_USB2: bufp = usb2\_rh\_dev\_descriptor; break;@@ -602,7 +578,6 @@ static int rh\_call\_control (struct usb\_hcd \*hcd, struct urb \*urb) bufp = ss\_rh\_config\_descriptor; len = sizeof ss\_rh\_config\_descriptor; break;- case HCD\_USB25: case HCD\_USB2: bufp = hs\_rh\_config\_descriptor; len = sizeof hs\_rh\_config\_descriptor;@@ -2848,18 +2823,14 @@ int usb\_add\_hcd(struct usb\_hcd \*hcd, hcd->dev\_policy = USB\_DEVICE\_AUTHORIZE\_NONE; break; - case USB\_AUTHORIZE\_ALL:- hcd->dev\_policy = USB\_DEVICE\_AUTHORIZE\_ALL;- break;- case USB\_AUTHORIZE\_INTERNAL: hcd->dev\_policy = USB\_DEVICE\_AUTHORIZE\_INTERNAL; break; + case USB\_AUTHORIZE\_ALL: case USB\_AUTHORIZE\_WIRED: default:- hcd->dev\_policy = hcd->wireless ?- USB\_DEVICE\_AUTHORIZE\_NONE : USB\_DEVICE\_AUTHORIZE\_ALL;+ hcd->dev\_policy = USB\_DEVICE\_AUTHORIZE\_ALL; break; } @@ -2903,9 +2874,6 @@ int usb\_add\_hcd(struct usb\_hcd \*hcd, case HCD\_USB2: rhdev->speed = USB\_SPEED\_HIGH; break;- case HCD\_USB25:- rhdev->speed = USB\_SPEED\_WIRELESS;- break; case HCD\_USB3: rhdev->speed = USB\_SPEED\_SUPER; break;diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.cindex 878913f4b4b3c7..b3c09e4c84928d 100644--- a/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hub.c?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)+++ b/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hub.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)@@ -2140,22 +2140,6 @@ EXPORT\_SYMBOL\_GPL(usb\_set\_device\_state); \* USB-3.0 buses the address is assigned by the controller hardware \* and it usually is not the same as the device number. \*- \* WUSB devices are simple: they have no hubs behind, so the mapping- \* device <-> virtual port number becomes 1:1. Why? to simplify the- \* life of the device connection logic in- \* drivers/usb/wusbcore/devconnect.c. When we do the initial secret- \* handshake we need to assign a temporary address in the unauthorized- \* space. For simplicity we use the first virtual port number found to- \* be free [drivers/usb/wusbcore/devconnect.c:wusbhc\_devconnect\_ack()]- \* and that becomes it's address [X < 128] or its unauthorized address- \* [X | 0x80].- \*- \* We add 1 as an offset to the one-based USB-stack port number- \* (zero-based wusb virtual port index) for two reasons: (a) dev addr- \* 0 is reserved by USB for default address; (b) Linux's USB stack- \* uses always #1 for the root hub of the controller. So USB stack's- \* port #1, which is wusb virtual-port #0 has address #2.- \* \* Devices connected under xHCI are not as simple. The host controller \* supports virtualization, so the hardware assigns device addresses and \* the HCD must setup data structures before issuing a set address@@ -2168,19 +2152,13 @@ static void choose\_devnum(struct usb\_device \*udev)  /\* be safe when more hub events are proceed in parallel \*/ mutex\_lock(&bus->devnum\_next\_mutex);- if (udev->wusb) {- devnum = udev->portnum + 1;- BUG\_ON(test\_bit(devnum, bus->devmap.devicemap));- } else {- /\* Try to allocate the next devnum beginning at- \* bus->devnum\_next. \*/- devnum = find\_next\_zero\_bit(bus->devmap.devicemap, 128,- bus->devnum\_next);- if (devnum >= 128)- devnum = find\_next\_zero\_bit(bus->devmap.devicemap,- 128, 1);- bus->devnum\_next = (devnum >= 127 ? 1 : devnum + 1);- }++ /\* Try to allocate the next devnum beginning at bus->devnum\_next. \*/+ devnum = find\_next\_zero\_bit(bus->devmap.devicemap, 128,+ bus->devnum\_next);+ if (devnum >= 128)+ devnum = find\_next\_zero\_bit(bus->devmap.devicemap, 128, 1);+ bus->devnum\_next = (devnum >= 127 ? 1 : devnum + 1); if (devnum < 128) { set\_bit(devnum, bus->devmap.devicemap); udev->devnum = devnum;@@ -2198,9 +2176,7 @@ static void release\_devnum(struct usb\_device \*udev)  static void update\_devnum(struct usb\_device \*udev, int devnum) {- /\* The address for a WUSB device is managed by wusbcore. \*/- if (!udev->wusb)- udev->devnum = devnum;+ udev->devnum = devnum; if (!udev->devaddr) udev->devaddr = (u8)devnum; }@@ -2693,20 +2669,6 @@ int usb\_authorize\_device(struct usb\_device \*usb\_dev) goto error\_autoresume; } - if (usb\_dev->wusb) {- struct usb\_device\_descriptor \*descr;-- descr = usb\_get\_device\_descriptor(usb\_dev);- if (IS\_ERR(descr)) {- result = PTR\_ERR(descr);- dev\_err(&usb\_dev->dev, "can't re-read device descriptor for "- "authorization: %d\n", result);- goto error\_device\_descriptor;- }- usb\_dev->descriptor = \*descr;- kfree(descr);- }- usb\_dev->authorized = 1; /\* Choose and set the configuration. This registers the interfaces \* with the driver core and lets interface drivers bind to them.@@ -2723,7 +2685,6 @@ int usb\_authorize\_device(struct usb\_device \*usb\_dev) } dev\_info(&usb\_dev->dev, "authorized to connect\n"); -error\_device\_descriptor: usb\_autosuspend\_device(usb\_dev); error\_autoresume: out\_authorized:@@ -2806,17 +2767,6 @@ out: return USB\_SSP\_GEN\_UNKNOWN; } -/\* Returns 1 if @hub is a WUSB root hub, 0 otherwise \*/-static unsigned hub\_is\_wusb(struct usb\_hub \*hub)-{- struct usb\_hcd \*hcd;- if (hub->hdev->parent != NULL) /\* not a root hub? \*/- return 0;- hcd = bus\_to\_hcd(hub->hdev->bus);- return hcd->wireless;-}-- #ifdef CONFIG\_USB\_FEW\_INIT\_RETRIES #define PORT\_RESET\_TRIES 2 #define SET\_ADDRESS\_TRIES 1@@ -2969,9 +2919,7 @@ static int hub\_port\_wait\_reset(struct usb\_hub \*hub, int port1, udev->tx\_lanes = 1; udev->ssp\_rate = USB\_SSP\_GEN\_UNKNOWN; }- if (hub\_is\_wusb(hub))- udev->speed = USB\_SPEED\_WIRELESS;- else if (udev->ssp\_rate != USB\_SSP\_GEN\_UNKNOWN)+ if (udev->ssp\_rate != USB\_SSP\_GEN\_UNKNOWN) udev->speed = USB\_SPEED\_SUPER\_PLUS; else if (hub\_is\_superspeed(hub->hdev)) udev->speed = USB\_SPEED\_SUPER;@@ -4880,13 +4828,10 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, if (initial) { /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ... \* it's fixed size except for full speed devices.- \* For Wireless USB devices, ep0 max packet is always 512 (tho- \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1]. \*/ switch (udev->speed) { case USB\_SPEED\_SUPER\_PLUS: case USB\_SPEED\_SUPER:- case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512); break; case USB\_SPEED\_HIGH: /\* fixed at 64 \*/@@ -4907,10 +4852,7 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } } - if (udev->speed == USB\_SPEED\_WIRELESS)- speed = "variable speed Wireless";- else- speed = usb\_speed\_string(udev->speed);+ speed = usb\_speed\_string(udev->speed);  /\* \* The controller driver may be NULL if the controller device@@ -5003,50 +4945,44 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } } + for (operations = 0; operations < SET\_ADDRESS\_TRIES; ++operations) {+ retval = hub\_set\_address(udev, devnum);+ if (retval >= 0)+ break;+ msleep(200);+ }+ if (retval < 0) {+ if (retval != -ENODEV)+ dev\_err(&udev->dev, "device not accepting address %d, error %d\n",+ devnum, retval);+ goto fail;+ }+ if (udev->speed >= USB\_SPEED\_SUPER) {+ devnum = udev->devnum;+ dev\_info(&udev->dev,+ "%s SuperSpeed%s%s USB device number %d using %s\n",+ (udev->config) ? "reset" : "new",+ (udev->speed == USB\_SPEED\_SUPER\_PLUS) ?+ " Plus" : "",+ (udev->ssp\_rate == USB\_SSP\_GEN\_2x2) ?+ " Gen 2x2" :+ (udev->ssp\_rate == USB\_SSP\_GEN\_2x1) ?+ " Gen 2x1" :+ (udev->ssp\_rate == USB\_SSP\_GEN\_1x2) ?+ " Gen 1x2" : "",+ devnum, driver\_name);+ }+ /\*- \* If device is WUSB, we already assigned an- \* unauthorized address in the Connect Ack sequence;- \* authorization will assign the final address.+ \* cope with hardware quirkiness:+ \* - let SET\_ADDRESS settle, some device hardware wants it+ \* - read ep0 maxpacket even for high and low speed, \*/- if (udev->wusb == 0) {- for (operations = 0; operations < SET\_ADDRESS\_TRIES; ++operations) {- retval = hub\_set\_address(udev, devnum);- if (retval >= 0)- break;- msleep(200);- }- if (retval < 0) {- if (retval != -ENODEV)- dev\_err(&udev->dev, "device not accepting address %d, error %d\n",- devnum, retval);- goto fail;- }- if (udev->speed >= USB\_SPEED\_SUPER) {- devnum = udev->devnum;- dev\_info(&udev->dev,- "%s SuperSpeed%s%s USB device number %d using %s\n",- (udev->config) ? "reset" : "new",- (udev->speed == USB\_SPEED\_SUPER\_PLUS) ?- " Plus" : "",- (udev->ssp\_rate == USB\_SSP\_GEN\_2x2) ?- " Gen 2x2" :- (udev->ssp\_rate == USB\_SSP\_GEN\_2x1) ?- " Gen 2x1" :- (udev->ssp\_rate == USB\_SSP\_GEN\_1x2) ?- " Gen 1x2" : "",- devnum, driver\_name);- }+ msleep(10); - /\* cope with hardware quirkiness:- \* - let SET\_ADDRESS settle, some device hardware wants it- \* - read ep0 maxpacket even for high and low speed,- \*/- msleep(10);- if (do\_new\_scheme)- break;- }+ if (do\_new\_scheme)+ break; - /\* !do\_new\_scheme || wusb \*/ maxp0 = get\_bMaxPacketSize0(udev, buf, 8, retries == 0); if (maxp0 < 0) { retval = maxp0;@@ -5128,7 +5064,7 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,  usb\_detect\_quirks(udev); - if (udev->wusb == 0 && le16\_to\_cpu(udev->descriptor.bcdUSB) >= 0x0201) {+ if (le16\_to\_cpu(udev->descriptor.bcdUSB) >= 0x0201) { retval = usb\_get\_bos\_descriptor(udev); if (!retval) { udev->lpm\_capable = usb\_device\_supports\_lpm(udev);@@ -5404,7 +5340,6 @@ static void hub\_port\_connect(struct usb\_hub \*hub, int port1, u16 portstatus, usb\_set\_device\_state(udev, USB\_STATE\_POWERED); udev->bus\_mA = hub->mA\_per\_port; udev->level = hdev->level + 1;- udev->wusb = hub\_is\_wusb(hub);  /\* Devices connected to SuperSpeed hubs are USB 3.0 or later \*/ if (hub\_is\_superspeed(hub->hdev))diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.cindex 323dc02becbe25..5d21718afb05cf 100644--- a/[drivers/usb/core/sysfs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/sysfs.c?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)+++ b/[drivers/usb/core/sysfs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/sysfs.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)@@ -161,9 +161,6 @@ static ssize\_t speed\_show(struct device \*dev, struct device\_attribute \*attr, case USB\_SPEED\_HIGH: speed = "480"; break;- case USB\_SPEED\_WIRELESS:- speed = "480";- break; case USB\_SPEED\_SUPER: speed = "5000"; break;diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.cindex 9f3c54032556ed..7576920e2d5a3e 100644--- a/[drivers/usb/core/urb.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/urb.c?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)+++ b/[drivers/usb/core/urb.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/urb.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)@@ -480,8 +480,7 @@ int usb\_submit\_urb(struct urb \*urb, gfp\_t mem\_flags) urb->iso\_frame\_desc[n].status = -EXDEV; urb->iso\_frame\_desc[n].actual\_length = 0; }- } else if (urb->num\_sgs && !urb->dev->bus->no\_sg\_constraint &&- dev->speed != USB\_SPEED\_WIRELESS) {+ } else if (urb->num\_sgs && !urb->dev->bus->no\_sg\_constraint) { struct scatterlist \*sg; int i; @@ -540,17 +539,9 @@ int usb\_submit\_urb(struct urb \*urb, gfp\_t mem\_flags) case USB\_ENDPOINT\_XFER\_ISOC: case USB\_ENDPOINT\_XFER\_INT: /\* too small? \*/- switch (dev->speed) {- case USB\_SPEED\_WIRELESS:- if ((urb->interval < 6)- && (xfertype == USB\_ENDPOINT\_XFER\_INT))- return -EINVAL;- fallthrough;- default:- if (urb->interval <= 0)- return -EINVAL;- break;- }+ if (urb->interval <= 0)+ return -EINVAL;+ /\* too big? \*/ switch (dev->speed) { case USB\_SPEED\_SUPER\_PLUS:@@ -560,10 +551,6 @@ int usb\_submit\_urb(struct urb \*urb, gfp\_t mem\_flags) return -EINVAL; max = 1 << 15; break;- case USB\_SPEED\_WIRELESS:- if (urb->interval > 16)- return -EINVAL;- break; case USB\_SPEED\_HIGH: /\* units are microframes \*/ /\* NOTE usb handles 2^15 \*/ if (urb->interval > (1024 \* 8))@@ -587,10 +574,8 @@ int usb\_submit\_urb(struct urb \*urb, gfp\_t mem\_flags) default: return -EINVAL; }- if (dev->speed != USB\_SPEED\_WIRELESS) {- /\* Round down to a power of 2, no more than max \*/- urb->interval = min(max, 1 << ilog2(urb->interval));- }+ /\* Round down to a power of 2, no more than max \*/+ urb->interval = min(max, 1 << ilog2(urb->interval)); }  return usb\_hcd\_submit\_urb(urb, mem\_flags);diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.cindex bba87e5b7f8a61..0945ff8df500fc 100644--- a/[drivers/usb/core/usb.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/usb.c?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)+++ b/[drivers/usb/core/usb.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/usb.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)@@ -602,14 +602,6 @@ struct device\_type usb\_device\_type = { #endif }; --/\* Returns 1 if @usb\_bus is WUSB, 0 otherwise \*/-static unsigned usb\_bus\_is\_wusb(struct usb\_bus \*bus)-{- struct usb\_hcd \*hcd = bus\_to\_hcd(bus);- return hcd->wireless;-}- static bool usb\_dev\_authorized(struct usb\_device \*dev, struct usb\_hcd \*hcd) { struct usb\_hub \*hub;@@ -749,9 +741,6 @@ struct usb\_device \*usb\_alloc\_dev(struct usb\_device \*parent, #endif  dev->authorized = usb\_dev\_authorized(dev, usb\_hcd);- if (!root\_hub)- dev->wusb = usb\_bus\_is\_wusb(bus) ? 1 : 0;- return dev; } EXPORT\_SYMBOL\_GPL(usb\_alloc\_dev);diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.cindex 19a402123de02f..8714ab5bf04d6b 100644--- a/[drivers/usb/host/xhci-mem.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/host/xhci-mem.c?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)+++ b/[drivers/usb/host/xhci-mem.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/host/xhci-mem.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)@@ -1108,9 +1108,6 @@ int xhci\_setup\_addressable\_virt\_dev(struct xhci\_hcd \*xhci, struct usb\_device \*ud slot\_ctx->dev\_info |= cpu\_to\_le32(SLOT\_SPEED\_LS); max\_packets = MAX\_PACKET(8); break;- case USB\_SPEED\_WIRELESS:- xhci\_dbg(xhci, "FIXME xHCI doesn't support wireless speeds\n");- return -EINVAL; default: /\* Speed was set earlier, this shouldn't happen. \*/ return -EINVAL;diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.cindex fae994f679d45b..e1b1b64a072329 100644--- a/[drivers/usb/host/xhci.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/host/xhci.c?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)+++ b/[drivers/usb/host/xhci.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/host/xhci.c?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)@@ -2194,7 +2194,6 @@ static unsigned int xhci\_get\_block\_size(struct usb\_device \*udev) case USB\_SPEED\_SUPER\_PLUS: return SS\_BLOCK; case USB\_SPEED\_UNKNOWN:- case USB\_SPEED\_WIRELESS: default: /\* Should never happen \*/ return 1;@@ -2555,10 +2554,7 @@ static void xhci\_drop\_ep\_from\_interval\_table(struct xhci\_hcd \*xhci, case USB\_SPEED\_HIGH: interval\_bw->overhead[HS\_OVERHEAD\_TYPE] -= 1; break;- case USB\_SPEED\_SUPER:- case USB\_SPEED\_SUPER\_PLUS:- case USB\_SPEED\_UNKNOWN:- case USB\_SPEED\_WIRELESS:+ default: /\* Should never happen because only LS/FS/HS endpoints will get \* added to the endpoint list. \*/@@ -2615,10 +2611,7 @@ static void xhci\_add\_ep\_to\_interval\_table(struct xhci\_hcd \*xhci, case USB\_SPEED\_HIGH: interval\_bw->overhead[HS\_OVERHEAD\_TYPE] += 1; break;- case USB\_SPEED\_SUPER:- case USB\_SPEED\_SUPER\_PLUS:- case USB\_SPEED\_UNKNOWN:- case USB\_SPEED\_WIRELESS:+ default: /\* Should never happen because only LS/FS/HS endpoints will get \* added to the endpoint list. \*/diff --git a/include/linux/usb.h b/include/linux/usb.hindex 25f8e62a30ecac..a21074861f91fe 100644--- a/[include/linux/usb.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/usb.h?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)+++ b/[include/linux/usb.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/usb.h?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)@@ -25,7 +25,6 @@  struct usb\_device; struct usb\_driver;-struct wusb\_dev;  /\*-------------------------------------------------------------------------\*/ @@ -425,7 +424,6 @@ struct usb\_host\_config { struct usb\_host\_bos { struct usb\_bos\_descriptor \*desc; - /\* wireless cap descriptor is handled by wusb \*/ struct usb\_ext\_cap\_descriptor \*ext\_cap; struct usb\_ss\_cap\_descriptor \*ss\_cap; struct usb\_ssp\_cap\_descriptor \*ssp\_cap;@@ -612,7 +610,6 @@ struct usb3\_lpm\_parameters { \* WUSB devices are not, until we authorize them from user space. \* FIXME -- complete doc \* @authenticated: Crypto authentication passed- \* @wusb: device is Wireless USB \* @lpm\_capable: device supports LPM \* @lpm\_devinit\_allow: Allow USB3 device initiated LPM, exit latency is in range \* @usb2\_hw\_lpm\_capable: device can perform USB2 hardware LPM@@ -634,8 +631,6 @@ struct usb3\_lpm\_parameters { \* @do\_remote\_wakeup: remote wakeup should be enabled \* @reset\_resume: needs reset instead of resume \* @port\_is\_suspended: the upstream port is suspended (L2 or U3)- \* @wusb\_dev: if this is a Wireless USB device, link to the WUSB- \* specific data for the device. \* @slot\_id: Slot ID assigned by xHCI \* @removable: Device can be physically removed from this port \* @l1\_params: best effor service latency for USB2 L1 LPM state, and L1 timeout.@@ -696,7 +691,6 @@ struct usb\_device { unsigned have\_langid:1; unsigned authorized:1; unsigned authenticated:1;- unsigned wusb:1; unsigned lpm\_capable:1; unsigned lpm\_devinit\_allow:1; unsigned usb2\_hw\_lpm\_capable:1;@@ -727,7 +721,6 @@ struct usb\_device { unsigned reset\_resume:1; unsigned port\_is\_suspended:1; - struct wusb\_dev \*wusb\_dev; int slot\_id; struct usb2\_lpm\_parameters l1\_params; struct usb3\_lpm\_parameters u1\_params;@@ -1742,11 +1735,6 @@ static inline void usb\_fill\_bulk\_urb(struct urb \*urb, \* encoding of the endpoint interval, and express polling intervals in \* microframes (eight per millisecond) rather than in frames (one per \* millisecond).- \*- \* Wireless USB also uses the logarithmic encoding, but specifies it in units of- \* 128us instead of 125us. For Wireless USB devices, the interval is passed- \* through to the host controller, rather than being translated into microframe- \* units. \*/ static inline void usb\_fill\_int\_urb(struct urb \*urb, struct usb\_device \*dev,diff --git a/include/linux/usb/ch9.h b/include/linux/usb/ch9.hindex 969e7dba6358e2..c93b410b314a16 100644--- a/[include/linux/usb/ch9.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/usb/ch9.h?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)+++ b/[include/linux/usb/ch9.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/usb/ch9.h?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)@@ -3,7 +3,7 @@ \* This file holds USB constants and structures that are needed for \* USB device APIs. These are used by the USB device model, which is \* defined in chapter 9 of the USB 2.0 specification and in the- \* Wireless USB 1.0 (spread around). Linux has several APIs in C that+ \* Wireless USB 1.0 spec (now defunct). Linux has several APIs in C that \* need these: \* \* - the host side Linux-USB kernel driver API;@@ -14,9 +14,6 @@ \* act either as a USB host or as a USB device. That means the host and \* device side APIs benefit from working well together. \*- \* There's also "Wireless USB", using low power short range radios for- \* peripheral interconnection but otherwise building on the USB framework.- \* \* Note all descriptors are declared '\_\_attribute\_\_((packed))' so that: \* \* [a] they never get padded, either internally (USB spec writersdiff --git a/include/linux/usb/composite.h b/include/linux/usb/composite.hindex 07531c4f435040..6014340ba980de 100644--- a/[include/linux/usb/composite.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/usb/composite.h?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)+++ b/[include/linux/usb/composite.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/usb/composite.h?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)@@ -450,29 +450,6 @@ static inline struct usb\_composite\_driver \*to\_cdriver( \* \* One of these devices is allocated and initialized before the \* associated device driver's bind() is called.- \*- \* OPEN ISSUE: it appears that some WUSB devices will need to be- \* built by combining a normal (wired) gadget with a wireless one.- \* This revision of the gadget framework should probably try to make- \* sure doing that won't hurt too much.- \*- \* One notion for how to handle Wireless USB devices involves:- \*- \* (a) a second gadget here, discovery mechanism TBD, but likely- \* needing separate "register/unregister WUSB gadget" calls;- \* (b) updates to usb\_gadget to include flags "is it wireless",- \* "is it wired", plus (presumably in a wrapper structure)- \* bandgroup and PHY info;- \* (c) presumably a wireless\_ep wrapping a usb\_ep, and reporting- \* wireless-specific parameters like maxburst and maxsequence;- \* (d) configurations that are specific to wireless links;- \* (e) function drivers that understand wireless configs and will- \* support wireless for (additional) function instances;- \* (f) a function to support association setup (like CBAF), not- \* necessarily requiring a wireless adapter;- \* (g) composite device setup that can create one or more wireless- \* configs, including appropriate association setup support;- \* (h) more, TBD. \*/ struct usb\_composite\_dev { struct usb\_gadget \*gadget;diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.hindex 4e9623e8492b38..61d4f0b793dcdc 100644--- a/[include/linux/usb/hcd.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/usb/hcd.h?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)+++ b/[include/linux/usb/hcd.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/usb/hcd.h?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)@@ -154,7 +154,6 @@ struct usb\_hcd { /\* The next flag is a stopgap, to be removed when all the HCDs \* support the new root-hub polling mechanism. \*/ unsigned uses\_new\_polling:1;- unsigned wireless:1; /\* Wireless USB HCD \*/ unsigned has\_tt:1; /\* Integrated TT in root hub \*/ unsigned amd\_resume\_bug:1; /\* AMD remote wakeup quirk \*/ unsigned can\_do\_streams:1; /\* HC supports streams \*/@@ -249,7 +248,6 @@ struct hc\_driver { #define HCD\_SHARED 0x0004 /\* Two (or more) usb\_hcds share HW \*/ #define HCD\_USB11 0x0010 /\* USB 1.1 \*/ #define HCD\_USB2 0x0020 /\* USB 2.0 \*/-#define HCD\_USB25 0x0030 /\* Wireless USB 1.0 (USB 2.5)\*/ #define HCD\_USB3 0x0040 /\* USB 3.0 \*/ #define HCD\_USB31 0x0050 /\* USB 3.1 \*/ #define HCD\_USB32 0x0060 /\* USB 3.2 \*/diff --git a/include/uapi/linux/usb/ch11.h b/include/uapi/linux/usb/ch11.hindex fb0cd24c392c0d..ce4c83f2e66ac1 100644--- a/[include/uapi/linux/usb/ch11.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/usb/ch11.h?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)+++ b/[include/uapi/linux/usb/ch11.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/usb/ch11.h?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)@@ -15,10 +15,8 @@ /\* This is arbitrary. \* From USB 2.0 spec Table 11-13, offset 7, a hub can \* have up to 255 ports. The most yet reported is 10.- \*- \* Current Wireless USB host hardware (Intel i1480 for example) allows- \* up to 22 devices to connect. Upcoming hardware might raise that- \* limit. Because the arrays need to add a bit for hub status data, we+ \* Upcoming hardware might raise that limit.+ \* Because the arrays need to add a bit for hub status data, we \* use 31, so plus one evens out to four bytes. \*/ #define USB\_MAXCHILDREN 31diff --git a/include/uapi/linux/usb/ch9.h b/include/uapi/linux/usb/ch9.hindex 62d318377379e1..8a147abfc68065 100644--- a/[include/uapi/linux/usb/ch9.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/usb/ch9.h?id=12e6ac69cc7e7d3367599ae26a92a0f9a18bc728)+++ b/[include/uapi/linux/usb/ch9.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/usb/ch9.h?id=1e4c574225cc5a0553115e5eb5787d1474db5b0f)@@ -3,7 +3,7 @@ \* This file holds USB constants and structures that are needed for \* USB device APIs. These are used by the USB device model, which is \* defined in chapter 9 of the USB 2.0 specification and in the- \* Wireless USB 1.0 (spread around). Linux has several APIs in C that+ \* Wireless USB 1.0 spec (now defunct). Linux has several APIs in C that \* need these: \* \* - the master/host side Linux-USB kernel driver API;@@ -14,9 +14,6 @@ \* act either as a USB master/host or as a USB slave/device. That means \* the master and slave side APIs benefit from working well together. \*- \* There's also "Wireless USB", using low power short range radios for- \* peripheral interconnection but otherwise building on the USB framework.- \* \* Note all descriptors are declared '\_\_attribute\_\_((packed))' so that: \* \* [a] they never get padded, either internally (USB spec writers |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 22:52:44 +0000



=== Content from lore.kernel.org_e57fad0c_20250114_225408.html ===

```
[All of lore.kernel.org](../../?t=20230803063409)
 [help](../../_/text/help/) / [color](../../_/text/color/) / [mirror](../../_/text/mirror/) / [Atom feed](../../new.atom)
```
```
[*](#ed5fb727b19bd829948177dafed0e7f4be241ff86) [syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)
@ 2023-06-20  2:55 syzbot
  2023-07-21 18:10 ` [Khazhy Kumykov](#mc79c976f308450b04f646243f791ae214d7d2f1c)
  [0 siblings, 1 reply; 15+ messages in thread](#rd5fb727b19bd829948177dafed0e7f4be241ff86)
From: syzbot @ 2023-06-20  2:55 UTC ([permalink](../../000000000000c0ffe505fe86c9ca%40google.com/) / [raw](../../000000000000c0ffe505fe86c9ca%40google.com/raw))
  To: gregkh, [linux-kernel](../../../lkml/?t=20230620025553), [linux-usb](../../../linux-usb/?t=20230620025553), syzkaller-bugs

Hello,

syzbot found the following issue on:

HEAD commit:    40f71e7cd3c6 Merge tag 'net-6.4-rc7' of git://git.kernel.o..
git tree:       upstream
console+strace: <https://syzkaller.appspot.com/x/log.txt?x=1581445b280000>
kernel config:  <https://syzkaller.appspot.com/x/.config?x=ac246111fb601aec>
dashboard link: <https://syzkaller.appspot.com/bug?extid=18996170f8096c6174d0>
compiler:       gcc (Debian 10.2.1-6) 10.2.1 20210110, GNU ld (GNU Binutils for Debian) 2.35.2
syz repro:      <https://syzkaller.appspot.com/x/repro.syz?x=15d23487280000>
C reproducer:   <https://syzkaller.appspot.com/x/repro.c?x=16613ed3280000>

Downloadable assets:
disk image: <https://storage.googleapis.com/syzbot-assets/30922ad38c58/disk-40f71e7c.raw.xz>
vmlinux: <https://storage.googleapis.com/syzbot-assets/3bd12e7503b8/vmlinux-40f71e7c.xz>
kernel image: <https://storage.googleapis.com/syzbot-assets/1dcd340b18d4/bzImage-40f71e7c.xz>

IMPORTANT: if you fix the issue, please add the following tag to the commit:
Reported-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com

==================================================================
BUG: KASAN: slab-out-of-bounds in read_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
Read of size 8 at addr ffff88801e78b8c8 by task udevd/5011

CPU: 0 PID: 5011 Comm: udevd Not tainted 6.4.0-rc6-syzkaller-00195-g40f71e7cd3c6 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:88 [inline]
 dump_stack_lvl+0xd9/0x150 lib/dump_stack.c:106
 print_address_description.constprop.0+0x2c/0x3c0 mm/kasan/report.c:351
 print_report mm/kasan/report.c:462 [inline]
 kasan_report+0x11c/0x130 mm/kasan/report.c:572
 read_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
 sysfs_kf_bin_read+0x19a/0x270 fs/sysfs/file.c:97
 kernfs_file_read_iter fs/kernfs/file.c:251 [inline]
 kernfs_fop_read_iter+0x387/0x690 fs/kernfs/file.c:280
 call_read_iter include/linux/fs.h:1862 [inline]
 new_sync_read fs/read_write.c:389 [inline]
 vfs_read+0x4b1/0x8a0 fs/read_write.c:470
 ksys_read+0x12b/0x250 fs/read_write.c:613
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x63/0xcd
RIP: 0033:0x7f07c7916b6a
Code: 00 3d 00 00 41 00 75 0d 50 48 8d 3d 2d 08 0a 00 e8 ea 7d 01 00 31 c0 e9 07 ff ff ff 64 8b 04 25 18 00 00 00 85 c0 75 1b 0f 05 <48> 3d 00 f0 ff ff 76 6c 48 8b 15 8f a2 0d 00 f7 d8 64 89 02 48 83
RSP: 002b:00007ffdf34973d8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000
RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f07c7916b6a
RDX: 0000000000010011 RSI: 00007ffdf3497407 RDI: 0000000000000008
RBP: 0000000000000008 R08: 0000000000000003 R09: f4f13e10193fbafe
R10: 0000000000000000 R11: 0000000000000246 R12: 000055be37470e10
R13: 00007ffdf34a7ae8 R14: 00007ffdf34a8138 R15: 00007ffdf3497407
 </TASK>

Allocated by task 758:
 kasan_save_stack+0x22/0x40 mm/kasan/common.c:45
 kasan_set_track+0x25/0x30 mm/kasan/common.c:52
 ____kasan_kmalloc mm/kasan/common.c:374 [inline]
 ____kasan_kmalloc mm/kasan/common.c:333 [inline]
 __kasan_kmalloc+0xa2/0xb0 mm/kasan/common.c:383
 kasan_kmalloc include/linux/kasan.h:196 [inline]
 __do_kmalloc_node mm/slab_common.c:966 [inline]
 __kmalloc+0x5e/0x190 mm/slab_common.c:979
 kmalloc include/linux/slab.h:563 [inline]
 kzalloc include/linux/slab.h:680 [inline]
 usb_get_configuration+0x1f7/0x5170 drivers/usb/core/config.c:887
 usb_enumerate_device drivers/usb/core/hub.c:2407 [inline]
 usb_new_device+0x12b0/0x19d0 drivers/usb/core/hub.c:2545
 hub_port_connect drivers/usb/core/hub.c:5407 [inline]
 hub_port_connect_change drivers/usb/core/hub.c:5551 [inline]
 port_event drivers/usb/core/hub.c:5711 [inline]
 hub_event+0x2d9e/0x4e40 drivers/usb/core/hub.c:5793
 process_one_work+0x99a/0x15e0 kernel/workqueue.c:2405
 worker_thread+0x67d/0x10c0 kernel/workqueue.c:2552
 kthread+0x344/0x440 kernel/kthread.c:379
 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:308

The buggy address belongs to the object at ffff88801e78b8c0
 which belongs to the cache kmalloc-8 of size 8
The buggy address is located 0 bytes to the right of
 allocated 8-byte region [ffff88801e78b8c0, ffff88801e78b8c8)

The buggy address belongs to the physical page:
page:ffffea000079e2c0 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1e78b
anon flags: 0xfff00000000200(slab|node=0|zone=1|lastcpupid=0x7ff)
page_type: 0xffffffff()
raw: 00fff00000000200 ffff888012441280 0000000000000000 dead000000000001
raw: 0000000000000000 0000000000660066 00000001ffffffff 0000000000000000
page dumped because: kasan: bad access detected
page_owner tracks the page as allocated
page last allocated via order 0, migratetype Unmovable, gfp_mask 0x12cc0(GFP_KERNEL|__GFP_NOWARN|__GFP_NORETRY), pid 1, tgid 1 (swapper/0), ts 8298345549, free_ts 8292702290
 set_page_owner include/linux/page_owner.h:31 [inline]
 post_alloc_hook+0x2db/0x350 mm/page_alloc.c:1731
 prep_new_page mm/page_alloc.c:1738 [inline]
 get_page_from_freelist+0xf41/0x2c00 mm/page_alloc.c:3502
 __alloc_pages+0x1cb/0x4a0 mm/page_alloc.c:4768
 alloc_page_interleave+0x1e/0x200 mm/mempolicy.c:2112
 alloc_pages+0x233/0x270 mm/mempolicy.c:2274
 alloc_slab_page mm/slub.c:1851 [inline]
 allocate_slab+0x25f/0x390 mm/slub.c:1998
 new_slab mm/slub.c:2051 [inline]
 ___slab_alloc+0xa91/0x1400 mm/slub.c:3192
 __slab_alloc.constprop.0+0x56/0xa0 mm/slub.c:3291
 __slab_alloc_node mm/slub.c:3344 [inline]
 slab_alloc_node mm/slub.c:3441 [inline]
 __kmem_cache_alloc_node+0x136/0x320 mm/slub.c:3490
 __do_kmalloc_node mm/slab_common.c:965 [inline]
 __kmalloc_node_track_caller+0x4f/0x1a0 mm/slab_common.c:986
 kstrdup+0x3f/0x70 mm/util.c:62
 kstrdup_const+0x57/0x80 mm/util.c:85
 kvasprintf_const+0x10c/0x190 lib/kasprintf.c:48
 kobject_set_name_vargs+0x5a/0x150 lib/kobject.c:267
 dev_set_name+0xbf/0xf0 drivers/base/core.c:3429
 tty_register_device_attr+0x301/0x7d0 drivers/tty/tty_io.c:3243
page last free stack trace:
 reset_page_owner include/linux/page_owner.h:24 [inline]
 free_pages_prepare mm/page_alloc.c:1302 [inline]
 free_unref_page_prepare+0x62e/0xcb0 mm/page_alloc.c:2564
 free_unref_page+0x33/0x370 mm/page_alloc.c:2659
 vfree+0x180/0x7e0 mm/vmalloc.c:2798
 delayed_vfree_work+0x57/0x70 mm/vmalloc.c:2719
 process_one_work+0x99a/0x15e0 kernel/workqueue.c:2405
 worker_thread+0x67d/0x10c0 kernel/workqueue.c:2552
 kthread+0x344/0x440 kernel/kthread.c:379
 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:308

Memory state around the buggy address:
 ffff88801e78b780: 00 fc fc fc fc fa fc fc fc fc fa fc fc fc fc fa
 ffff88801e78b800: fc fc fc fc 00 fc fc fc fc fa fc fc fc fc fa fc
>ffff88801e78b880: fc fc fc fa fc fc fc fc 00 fc fc fc fc 00 fc fc
                                              ^
 ffff88801e78b900: fc fc 00 fc fc fc fc fa fc fc fc fc 00 fc fc fc
 ffff88801e78b980: fc 00 fc fc fc fc fa fc fc fc fc 00 fc fc fc fc
==================================================================

---
This report is generated by a bot. It may contain errors.
See <https://goo.gl/tpsmEJ> for more information about syzbot.
syzbot engineers can be reached at syzkaller@googlegroups.com.

syzbot will keep track of this issue. See:
<https://goo.gl/tpsmEJ#status> for how to communicate with syzbot.

If the bug is already fixed, let syzbot know by replying with:
#syz fix: exact-commit-title

If you want syzbot to run the reproducer, reply with:
#syz test: git://repo/address.git branch-or-commit-hash
If you attach or paste a git patch, syzbot will apply it before testing.

If you want to change bug's subsystems, reply with:
#syz set subsystems: new-subsystem
(See the list of subsystem names on the web dashboard)

If the bug is a duplicate of another bug, reply with:
#syz dup: exact-subject-of-another-report

If you want to undo deduplication, reply with:
#syz undup

[^](#md5fb727b19bd829948177dafed0e7f4be241ff86) [permalink](../../000000000000c0ffe505fe86c9ca%40google.com/) [raw](../../000000000000c0ffe505fe86c9ca%40google.com/raw) [reply](../../000000000000c0ffe505fe86c9ca%40google.com/#R)	[[flat](../../000000000000c0ffe505fe86c9ca%40google.com/T/#u)|[nested](../../000000000000c0ffe505fe86c9ca%40google.com/t/#u)] [15+ messages in thread](#rd5fb727b19bd829948177dafed0e7f4be241ff86)
```

---

```
[*](#ec79c976f308450b04f646243f791ae214d7d2f1c) Re: [syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)
  2023-06-20  2:55 [[syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)](#md5fb727b19bd829948177dafed0e7f4be241ff86) syzbot
@ 2023-07-21 18:10 ` Khazhy Kumykov
  2023-07-21 18:23   ` [Khazhy Kumykov](#mcfbd21bc069b1007f363b61b24e989c65dbc08d4)
  [0 siblings, 1 reply; 15+ messages in thread](#rc79c976f308450b04f646243f791ae214d7d2f1c)
From: Khazhy Kumykov @ 2023-07-21 18:10 UTC ([permalink](../../CACGdZYJVYXA1gYTx%2BfvLa6H443%2B4SXLgG-iJcE7wQYSh%2B0aOzg%40mail.gmail.com/) / [raw](../../CACGdZYJVYXA1gYTx%2BfvLa6H443%2B4SXLgG-iJcE7wQYSh%2B0aOzg%40mail.gmail.com/raw))
  To: syzbot; +Cc: gregkh, [linux-kernel](../../../lkml/?t=20230721181045), [linux-usb](../../../linux-usb/?t=20230721181045), syzkaller-bugs

[[-- Attachment #1: Type: text/plain, Size: 10160 bytes --]](../../CACGdZYJVYXA1gYTx%2BfvLa6H443%2B4SXLgG-iJcE7wQYSh%2B0aOzg%40mail.gmail.com/1-a.txt)

On Mon, Jun 19, 2023 at 7:56PM syzbot
<syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com> wrote:
>
> Hello,
>
> syzbot found the following issue on:
>
> HEAD commit:    40f71e7cd3c6 Merge tag 'net-6.4-rc7' of git://git.kernel.o..
> git tree:       upstream
> console+strace: <https://syzkaller.appspot.com/x/log.txt?x=1581445b280000>
> kernel config:  <https://syzkaller.appspot.com/x/.config?x=ac246111fb601aec>
> dashboard link: <https://syzkaller.appspot.com/bug?extid=18996170f8096c6174d0>
> compiler:       gcc (Debian 10.2.1-6) 10.2.1 20210110, GNU ld (GNU Binutils for Debian) 2.35.2
> syz repro:      <https://syzkaller.appspot.com/x/repro.syz?x=15d23487280000>
> C reproducer:   <https://syzkaller.appspot.com/x/repro.c?x=16613ed3280000>
>
> Downloadable assets:
> disk image: <https://storage.googleapis.com/syzbot-assets/30922ad38c58/disk-40f71e7c.raw.xz>
> vmlinux: <https://storage.googleapis.com/syzbot-assets/3bd12e7503b8/vmlinux-40f71e7c.xz>
> kernel image: <https://storage.googleapis.com/syzbot-assets/1dcd340b18d4/bzImage-40f71e7c.xz>
>
> IMPORTANT: if you fix the issue, please add the following tag to the commit:
> Reported-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com
>
> ==================================================================
> BUG: KASAN: slab-out-of-bounds in read_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
> Read of size 8 at addr ffff88801e78b8c8 by task udevd/5011
>
> CPU: 0 PID: 5011 Comm: udevd Not tainted 6.4.0-rc6-syzkaller-00195-g40f71e7cd3c6 #0
> Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023
> Call Trace:
>  <TASK>
>  __dump_stack lib/dump_stack.c:88 [inline]
>  dump_stack_lvl+0xd9/0x150 lib/dump_stack.c:106
>  print_address_description.constprop.0+0x2c/0x3c0 mm/kasan/report.c:351
>  print_report mm/kasan/report.c:462 [inline]
>  kasan_report+0x11c/0x130 mm/kasan/report.c:572

"src = udev->rawdescriptors[cfgno]" (so, just reading rawdescriptors)

>  read_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
>  sysfs_kf_bin_read+0x19a/0x270 fs/sysfs/file.c:97
>  kernfs_file_read_iter fs/kernfs/file.c:251 [inline]
>  kernfs_fop_read_iter+0x387/0x690 fs/kernfs/file.c:280
>  call_read_iter include/linux/fs.h:1862 [inline]
>  new_sync_read fs/read_write.c:389 [inline]
>  vfs_read+0x4b1/0x8a0 fs/read_write.c:470
>  ksys_read+0x12b/0x250 fs/read_write.c:613
>  do_syscall_x64 arch/x86/entry/common.c:50 [inline]
>  do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80
>  entry_SYSCALL_64_after_hwframe+0x63/0xcd
> RIP: 0033:0x7f07c7916b6a
> Code: 00 3d 00 00 41 00 75 0d 50 48 8d 3d 2d 08 0a 00 e8 ea 7d 01 00 31 c0 e9 07 ff ff ff 64 8b 04 25 18 00 00 00 85 c0 75 1b 0f 05 <48> 3d 00 f0 ff ff 76 6c 48 8b 15 8f a2 0d 00 f7 d8 64 89 02 48 83
> RSP: 002b:00007ffdf34973d8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000
> RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f07c7916b6a
> RDX: 0000000000010011 RSI: 00007ffdf3497407 RDI: 0000000000000008
> RBP: 0000000000000008 R08: 0000000000000003 R09: f4f13e10193fbafe
> R10: 0000000000000000 R11: 0000000000000246 R12: 000055be37470e10
> R13: 00007ffdf34a7ae8 R14: 00007ffdf34a8138 R15: 00007ffdf3497407
>  </TASK>
>
> Allocated by task 758:
>  kasan_save_stack+0x22/0x40 mm/kasan/common.c:45
>  kasan_set_track+0x25/0x30 mm/kasan/common.c:52
>  ____kasan_kmalloc mm/kasan/common.c:374 [inline]
>  ____kasan_kmalloc mm/kasan/common.c:333 [inline]
>  __kasan_kmalloc+0xa2/0xb0 mm/kasan/common.c:383
>  kasan_kmalloc include/linux/kasan.h:196 [inline]
>  __do_kmalloc_node mm/slab_common.c:966 [inline]
>  __kmalloc+0x5e/0x190 mm/slab_common.c:979
>  kmalloc include/linux/slab.h:563 [inline]
>  kzalloc include/linux/slab.h:680 [inline]

kzmalloc(length) -> this length derived from dev->descriptor.bNumConfigurations

The corresponding kfree is in usb_destroy_configuration (makes sense)
- we also set rawdescriptors to NULL here. If this race was happening,
I'd also expect some sort of null deref report...

Stumbled upon [https://lore.kernel.org/all/1599201467-11000-1-git-send-email-prime.zeng@hisilicon.com/T/](https://lore.kernel.org/all/1599201467-11000-1-git-send-email-prime.zeng%40hisilicon.com/T/),
which suggests that we can, instead, race with a descriptor change,
which sounds plausible - descriptor changes, bNumConfigurations no
longer lines up with our kmalloc... so we may run past the end of it.

Looking at hub_port_connect_change(), we seem to read directly into
udev->descriptor, check if it changed, and if it did, set
udev->descriptor back to the old one...? If we have an ongoing sysfs
read, which directly touches udev->descriptor, there might be
trouble...

I see this is called in both hub_port_connect_change() and
usb_reset_and_verify_device()... which both seem to lock the port_dev?
("port_dev->status_lock"). This looks like a different lock than
usb_lock_device_interruptible would grab, maybe the code has changed
since that was reported in 2020. But it seems to suggest we want to
grab this lock in sysfs to safely read from udev->descriptor.

(I'm not clear on when the sysfs gets added/removed, since it happens
in usb_bus_notify()..., the above two functions that touch
udev->descriptor don't look like they send the
BUS_NOTIFY_ADD/DEL_DEVICE to me, so the race seems plausible)

>  usb_get_configuration+0x1f7/0x5170 drivers/usb/core/config.c:887
>  usb_enumerate_device drivers/usb/core/hub.c:2407 [inline]
>  usb_new_device+0x12b0/0x19d0 drivers/usb/core/hub.c:2545
>  hub_port_connect drivers/usb/core/hub.c:5407 [inline]
>  hub_port_connect_change drivers/usb/core/hub.c:5551 [inline]
>  port_event drivers/usb/core/hub.c:5711 [inline]
>  hub_event+0x2d9e/0x4e40 drivers/usb/core/hub.c:5793
>  process_one_work+0x99a/0x15e0 kernel/workqueue.c:2405
>  worker_thread+0x67d/0x10c0 kernel/workqueue.c:2552
>  kthread+0x344/0x440 kernel/kthread.c:379
>  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:308
>
> The buggy address belongs to the object at ffff88801e78b8c0
>  which belongs to the cache kmalloc-8 of size 8
> The buggy address is located 0 bytes to the right of
>  allocated 8-byte region [ffff88801e78b8c0, ffff88801e78b8c8)
>
> The buggy address belongs to the physical page:
> page:ffffea000079e2c0 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1e78b
> anon flags: 0xfff00000000200(slab|node=0|zone=1|lastcpupid=0x7ff)
> page_type: 0xffffffff()
> raw: 00fff00000000200 ffff888012441280 0000000000000000 dead000000000001
> raw: 0000000000000000 0000000000660066 00000001ffffffff 0000000000000000
> page dumped because: kasan: bad access detected
> page_owner tracks the page as allocated
> page last allocated via order 0, migratetype Unmovable, gfp_mask 0x12cc0(GFP_KERNEL|__GFP_NOWARN|__GFP_NORETRY), pid 1, tgid 1 (swapper/0), ts 8298345549, free_ts 8292702290
>  set_page_owner include/linux/page_owner.h:31 [inline]
>  post_alloc_hook+0x2db/0x350 mm/page_alloc.c:1731
>  prep_new_page mm/page_alloc.c:1738 [inline]
>  get_page_from_freelist+0xf41/0x2c00 mm/page_alloc.c:3502
>  __alloc_pages+0x1cb/0x4a0 mm/page_alloc.c:4768
>  alloc_page_interleave+0x1e/0x200 mm/mempolicy.c:2112
>  alloc_pages+0x233/0x270 mm/mempolicy.c:2274
>  alloc_slab_page mm/slub.c:1851 [inline]
>  allocate_slab+0x25f/0x390 mm/slub.c:1998
>  new_slab mm/slub.c:2051 [inline]
>  ___slab_alloc+0xa91/0x1400 mm/slub.c:3192
>  __slab_alloc.constprop.0+0x56/0xa0 mm/slub.c:3291
>  __slab_alloc_node mm/slub.c:3344 [inline]
>  slab_alloc_node mm/slub.c:3441 [inline]
>  __kmem_cache_alloc_node+0x136/0x320 mm/slub.c:3490
>  __do_kmalloc_node mm/slab_common.c:965 [inline]
>  __kmalloc_node_track_caller+0x4f/0x1a0 mm/slab_common.c:986
>  kstrdup+0x3f/0x70 mm/util.c:62
>  kstrdup_const+0x57/0x80 mm/util.c:85
>  kvasprintf_const+0x10c/0x190 lib/kasprintf.c:48
>  kobject_set_name_vargs+0x5a/0x150 lib/kobject.c:267
>  dev_set_name+0xbf/0xf0 drivers/base/core.c:3429
>  tty_register_device_attr+0x301/0x7d0 drivers/tty/tty_io.c:3243
> page last free stack trace:
>  reset_page_owner include/linux/page_owner.h:24 [inline]
>  free_pages_prepare mm/page_alloc.c:1302 [inline]
>  free_unref_page_prepare+0x62e/0xcb0 mm/page_alloc.c:2564
>  free_unref_page+0x33/0x370 mm/page_alloc.c:2659
Huh, why did our page get vfree'd, when it was kmalloc'd? Maybe the
memory was reused multiple times before generating this report...?
>  vfree+0x180/0x7e0 mm/vmalloc.c:2798
>  delayed_vfree_work+0x57/0x70 mm/vmalloc.c:2719
>  process_one_work+0x99a/0x15e0 kernel/workqueue.c:2405
>  worker_thread+0x67d/0x10c0 kernel/workqueue.c:2552
>  kthread+0x344/0x440 kernel/kthread.c:379
>  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:308
>
> Memory state around the buggy address:
>  ffff88801e78b780: 00 fc fc fc fc fa fc fc fc fc fa fc fc fc fc fa
>  ffff88801e78b800: fc fc fc fc 00 fc fc fc fc fa fc fc fc fc fa fc
> >ffff88801e78b880: fc fc fc fa fc fc fc fc 00 fc fc fc fc 00 fc fc
>                                               ^
>  ffff88801e78b900: fc fc 00 fc fc fc fc fa fc fc fc fc 00 fc fc fc
>  ffff88801e78b980: fc 00 fc fc fc fc fa fc fc fc fc 00 fc fc fc fc
> ==================================================================
>
>
> ---
> This report is generated by a bot. It may contain errors.
> See <https://goo.gl/tpsmEJ> for more information about syzbot.
> syzbot engineers can be reached at syzkaller@googlegroups.com.
>
> syzbot will keep track of this issue. See:
> <https://goo.gl/tpsmEJ#status> for how to communicate with syzbot.
>
> If the bug is already fixed, let syzbot know by replying with:
> #syz fix: exact-commit-title
>
> If you want syzbot to run the reproducer, reply with:
> #syz test: git://repo/address.git branch-or-commit-hash
> If you attach or paste a git patch, syzbot will apply it before testing.
>
> If you want to change bug's subsystems, reply with:
> #syz set subsystems: new-subsystem
> (See the list of subsystem names on the web dashboard)
>
> If the bug is a duplicate of another bug, reply with:
> #syz dup: exact-subject-of-another-report
>
> If you want to undo deduplication, reply with:
> #syz undup

[[-- Attachment #2: S/MIME Cryptographic Signature --]
[-- Type: application/pkcs7-signature, Size: 3999 bytes --]](../../CACGdZYJVYXA1gYTx%2BfvLa6H443%2B4SXLgG-iJcE7wQYSh%2B0aOzg%40mail.gmail.com/2-smime.p7s)

[^](#mc79c976f308450b04f646243f791ae214d7d2f1c) [permalink](../../CACGdZYJVYXA1gYTx%2BfvLa6H443%2B4SXLgG-iJcE7wQYSh%2B0aOzg%40mail.gmail.com/) [raw](../../CACGdZYJVYXA1gYTx%2BfvLa6H443%2B4SXLgG-iJcE7wQYSh%2B0aOzg%40mail.gmail.com/raw) [reply](../../CACGdZYJVYXA1gYTx%2BfvLa6H443%2B4SXLgG-iJcE7wQYSh%2B0aOzg%40mail.gmail.com/#R)	[[flat](../../CACGdZYJVYXA1gYTx%2BfvLa6H443%2B4SXLgG-iJcE7wQYSh%2B0aOzg%40mail.gmail.com/T/#u)|[nested](../../CACGdZYJVYXA1gYTx%2BfvLa6H443%2B4SXLgG-iJcE7wQYSh%2B0aOzg%40mail.gmail.com/t/#u)] [15+ messages in thread](#rc79c976f308450b04f646243f791ae214d7d2f1c)
```

---

```
[*](#ecfbd21bc069b1007f363b61b24e989c65dbc08d4) Re: [syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)
  2023-07-21 18:10 ` [Khazhy Kumykov](#mc79c976f308450b04f646243f791ae214d7d2f1c)
@ 2023-07-21 18:23   ` Khazhy Kumykov
  2023-07-21 18:56     ` [Alan Stern](#m7d6dde2f092063d51a8e5de813a19565fee957aa)
  [0 siblings, 1 reply; 15+ messages in thread](#rcfbd21bc069b1007f363b61b24e989c65dbc08d4)
From: Khazhy Kumykov @ 2023-07-21 18:23 UTC ([permalink](../../CACGdZYK8FupYqA2CoqoDjS4i%3DFvG1%2Bie7fG2MENHtuxspC0-Dg%40mail.gmail.com/) / [raw](../../CACGdZYK8FupYqA2CoqoDjS4i%3DFvG1%2Bie7fG2MENHtuxspC0-Dg%40mail.gmail.com/raw))
  To: syzbot; +Cc: gregkh, [linux-kernel](../../../lkml/?t=20230721182328), [linux-usb](../../../linux-usb/?t=20230721182328), syzkaller-bugs

[[-- Attachment #1: Type: text/plain, Size: 11168 bytes --]](../../CACGdZYK8FupYqA2CoqoDjS4i%3DFvG1%2Bie7fG2MENHtuxspC0-Dg%40mail.gmail.com/1-a.txt)

On Fri, Jul 21, 2023 at 11:10AM Khazhy Kumykov <khazhy@google.com> wrote:
>
> On Mon, Jun 19, 2023 at 7:56PM syzbot
> <syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com> wrote:
> >
> > Hello,
> >
> > syzbot found the following issue on:
> >
> > HEAD commit:    40f71e7cd3c6 Merge tag 'net-6.4-rc7' of git://git.kernel.o..
> > git tree:       upstream
> > console+strace: <https://syzkaller.appspot.com/x/log.txt?x=1581445b280000>
> > kernel config:  <https://syzkaller.appspot.com/x/.config?x=ac246111fb601aec>
> > dashboard link: <https://syzkaller.appspot.com/bug?extid=18996170f8096c6174d0>
> > compiler:       gcc (Debian 10.2.1-6) 10.2.1 20210110, GNU ld (GNU Binutils for Debian) 2.35.2
> > syz repro:      <https://syzkaller.appspot.com/x/repro.syz?x=15d23487280000>
> > C reproducer:   <https://syzkaller.appspot.com/x/repro.c?x=16613ed3280000>
> >
> > Downloadable assets:
> > disk image: <https://storage.googleapis.com/syzbot-assets/30922ad38c58/disk-40f71e7c.raw.xz>
> > vmlinux: <https://storage.googleapis.com/syzbot-assets/3bd12e7503b8/vmlinux-40f71e7c.xz>
> > kernel image: <https://storage.googleapis.com/syzbot-assets/1dcd340b18d4/bzImage-40f71e7c.xz>
> >
> > IMPORTANT: if you fix the issue, please add the following tag to the commit:
> > Reported-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com
> >
> > ==================================================================
> > BUG: KASAN: slab-out-of-bounds in read_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
> > Read of size 8 at addr ffff88801e78b8c8 by task udevd/5011
> >
> > CPU: 0 PID: 5011 Comm: udevd Not tainted 6.4.0-rc6-syzkaller-00195-g40f71e7cd3c6 #0
> > Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023
> > Call Trace:
> >  <TASK>
> >  __dump_stack lib/dump_stack.c:88 [inline]
> >  dump_stack_lvl+0xd9/0x150 lib/dump_stack.c:106
> >  print_address_description.constprop.0+0x2c/0x3c0 mm/kasan/report.c:351
> >  print_report mm/kasan/report.c:462 [inline]
> >  kasan_report+0x11c/0x130 mm/kasan/report.c:572
>
> "src = udev->rawdescriptors[cfgno]" (so, just reading rawdescriptors)
>
> >  read_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
> >  sysfs_kf_bin_read+0x19a/0x270 fs/sysfs/file.c:97
> >  kernfs_file_read_iter fs/kernfs/file.c:251 [inline]
> >  kernfs_fop_read_iter+0x387/0x690 fs/kernfs/file.c:280
> >  call_read_iter include/linux/fs.h:1862 [inline]
> >  new_sync_read fs/read_write.c:389 [inline]
> >  vfs_read+0x4b1/0x8a0 fs/read_write.c:470
> >  ksys_read+0x12b/0x250 fs/read_write.c:613
> >  do_syscall_x64 arch/x86/entry/common.c:50 [inline]
> >  do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80
> >  entry_SYSCALL_64_after_hwframe+0x63/0xcd
> > RIP: 0033:0x7f07c7916b6a
> > Code: 00 3d 00 00 41 00 75 0d 50 48 8d 3d 2d 08 0a 00 e8 ea 7d 01 00 31 c0 e9 07 ff ff ff 64 8b 04 25 18 00 00 00 85 c0 75 1b 0f 05 <48> 3d 00 f0 ff ff 76 6c 48 8b 15 8f a2 0d 00 f7 d8 64 89 02 48 83
> > RSP: 002b:00007ffdf34973d8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000
> > RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f07c7916b6a
> > RDX: 0000000000010011 RSI: 00007ffdf3497407 RDI: 0000000000000008
> > RBP: 0000000000000008 R08: 0000000000000003 R09: f4f13e10193fbafe
> > R10: 0000000000000000 R11: 0000000000000246 R12: 000055be37470e10
> > R13: 00007ffdf34a7ae8 R14: 00007ffdf34a8138 R15: 00007ffdf3497407
> >  </TASK>
> >
> > Allocated by task 758:
> >  kasan_save_stack+0x22/0x40 mm/kasan/common.c:45
> >  kasan_set_track+0x25/0x30 mm/kasan/common.c:52
> >  ____kasan_kmalloc mm/kasan/common.c:374 [inline]
> >  ____kasan_kmalloc mm/kasan/common.c:333 [inline]
> >  __kasan_kmalloc+0xa2/0xb0 mm/kasan/common.c:383
> >  kasan_kmalloc include/linux/kasan.h:196 [inline]
> >  __do_kmalloc_node mm/slab_common.c:966 [inline]
> >  __kmalloc+0x5e/0x190 mm/slab_common.c:979
> >  kmalloc include/linux/slab.h:563 [inline]
> >  kzalloc include/linux/slab.h:680 [inline]
>
> kzmalloc(length) -> this length derived from dev->descriptor.bNumConfigurations
>
> The corresponding kfree is in usb_destroy_configuration (makes sense)
> - we also set rawdescriptors to NULL here. If this race was happening,
> I'd also expect some sort of null deref report...
>
> Stumbled upon [https://lore.kernel.org/all/1599201467-11000-1-git-send-email-prime.zeng@hisilicon.com/T/](https://lore.kernel.org/all/1599201467-11000-1-git-send-email-prime.zeng%40hisilicon.com/T/),
> which suggests that we can, instead, race with a descriptor change,
> which sounds plausible - descriptor changes, bNumConfigurations no
> longer lines up with our kmalloc... so we may run past the end of it.
Ah yeah, the syzbot C repro does something like this, it has a virtual
usb and keeps changing the descs -> which may end up calling
hub_port_connect_change()
>
> Looking at hub_port_connect_change(), we seem to read directly into
> udev->descriptor, check if it changed, and if it did, set
> udev->descriptor back to the old one...? If we have an ongoing sysfs
> read, which directly touches udev->descriptor, there might be
> trouble...
>
> I see this is called in both hub_port_connect_change() and
> usb_reset_and_verify_device()... which both seem to lock the port_dev?
> ("port_dev->status_lock"). This looks like a different lock than
> usb_lock_device_interruptible would grab, maybe the code has changed
> since that was reported in 2020. But it seems to suggest we want to
> grab this lock in sysfs to safely read from udev->descriptor.
>
> (I'm not clear on when the sysfs gets added/removed, since it happens
> in usb_bus_notify()..., the above two functions that touch
> udev->descriptor don't look like they send the
> BUS_NOTIFY_ADD/DEL_DEVICE to me, so the race seems plausible)

Ah yeah - in hub_port_connect_change() we call hub_port_connect() if
the descriptor changed, which notifies us of device remove *after* we
already directly messed with udev->descriptor for a potentially live
device.

I do see there's several sysfs files that directly read
udev->descriptor with no locking - should these all need to grab the
port_dev->status_lock?

>
> >  usb_get_configuration+0x1f7/0x5170 drivers/usb/core/config.c:887
> >  usb_enumerate_device drivers/usb/core/hub.c:2407 [inline]
> >  usb_new_device+0x12b0/0x19d0 drivers/usb/core/hub.c:2545
> >  hub_port_connect drivers/usb/core/hub.c:5407 [inline]
> >  hub_port_connect_change drivers/usb/core/hub.c:5551 [inline]
> >  port_event drivers/usb/core/hub.c:5711 [inline]
> >  hub_event+0x2d9e/0x4e40 drivers/usb/core/hub.c:5793
> >  process_one_work+0x99a/0x15e0 kernel/workqueue.c:2405
> >  worker_thread+0x67d/0x10c0 kernel/workqueue.c:2552
> >  kthread+0x344/0x440 kernel/kthread.c:379
> >  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:308
> >
> > The buggy address belongs to the object at ffff88801e78b8c0
> >  which belongs to the cache kmalloc-8 of size 8
> > The buggy address is located 0 bytes to the right of
> >  allocated 8-byte region [ffff88801e78b8c0, ffff88801e78b8c8)
> >
> > The buggy address belongs to the physical page:
> > page:ffffea000079e2c0 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1e78b
> > anon flags: 0xfff00000000200(slab|node=0|zone=1|lastcpupid=0x7ff)
> > page_type: 0xffffffff()
> > raw: 00fff00000000200 ffff888012441280 0000000000000000 dead000000000001
> > raw: 0000000000000000 0000000000660066 00000001ffffffff 0000000000000000
> > page dumped because: kasan: bad access detected
> > page_owner tracks the page as allocated
> > page last allocated via order 0, migratetype Unmovable, gfp_mask 0x12cc0(GFP_KERNEL|__GFP_NOWARN|__GFP_NORETRY), pid 1, tgid 1 (swapper/0), ts 8298345549, free_ts 8292702290
> >  set_page_owner include/linux/page_owner.h:31 [inline]
> >  post_alloc_hook+0x2db/0x350 mm/page_alloc.c:1731
> >  prep_new_page mm/page_alloc.c:1738 [inline]
> >  get_page_from_freelist+0xf41/0x2c00 mm/page_alloc.c:3502
> >  __alloc_pages+0x1cb/0x4a0 mm/page_alloc.c:4768
> >  alloc_page_interleave+0x1e/0x200 mm/mempolicy.c:2112
> >  alloc_pages+0x233/0x270 mm/mempolicy.c:2274
> >  alloc_slab_page mm/slub.c:1851 [inline]
> >  allocate_slab+0x25f/0x390 mm/slub.c:1998
> >  new_slab mm/slub.c:2051 [inline]
> >  ___slab_alloc+0xa91/0x1400 mm/slub.c:3192
> >  __slab_alloc.constprop.0+0x56/0xa0 mm/slub.c:3291
> >  __slab_alloc_node mm/slub.c:3344 [inline]
> >  slab_alloc_node mm/slub.c:3441 [inline]
> >  __kmem_cache_alloc_node+0x136/0x320 mm/slub.c:3490
> >  __do_kmalloc_node mm/slab_common.c:965 [inline]
> >  __kmalloc_node_track_caller+0x4f/0x1a0 mm/slab_common.c:986
> >  kstrdup+0x3f/0x70 mm/util.c:62
> >  kstrdup_const+0x57/0x80 mm/util.c:85
> >  kvasprintf_const+0x10c/0x190 lib/kasprintf.c:48
> >  kobject_set_name_vargs+0x5a/0x150 lib/kobject.c:267
> >  dev_set_name+0xbf/0xf0 drivers/base/core.c:3429
> >  tty_register_device_attr+0x301/0x7d0 drivers/tty/tty_io.c:3243
> > page last free stack trace:
> >  reset_page_owner include/linux/page_owner.h:24 [inline]
> >  free_pages_prepare mm/page_alloc.c:1302 [inline]
> >  free_unref_page_prepare+0x62e/0xcb0 mm/page_alloc.c:2564
> >  free_unref_page+0x33/0x370 mm/page_alloc.c:2659
> Huh, why did our page get vfree'd, when it was kmalloc'd? Maybe the
> memory was reused multiple times before generating this report...?
> >  vfree+0x180/0x7e0 mm/vmalloc.c:2798
> >  delayed_vfree_work+0x57/0x70 mm/vmalloc.c:2719
> >  process_one_work+0x99a/0x15e0 kernel/workqueue.c:2405
> >  worker_thread+0x67d/0x10c0 kernel/workqueue.c:2552
> >  kthread+0x344/0x440 kernel/kthread.c:379
> >  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:308
> >
> > Memory state around the buggy address:
> >  ffff88801e78b780: 00 fc fc fc fc fa fc fc fc fc fa fc fc fc fc fa
> >  ffff88801e78b800: fc fc fc fc 00 fc fc fc fc fa fc fc fc fc fa fc
> > >ffff88801e78b880: fc fc fc fa fc fc fc fc 00 fc fc fc fc 00 fc fc
> >                                               ^
> >  ffff88801e78b900: fc fc 00 fc fc fc fc fa fc fc fc fc 00 fc fc fc
> >  ffff88801e78b980: fc 00 fc fc fc fc fa fc fc fc fc 00 fc fc fc fc
> > ==================================================================
> >
> >
> > ---
> > This report is generated by a bot. It may contain errors.
> > See <https://goo.gl/tpsmEJ> for more information about syzbot.
> > syzbot engineers can be reached at syzkaller@googlegroups.com.
> >
> > syzbot will keep track of this issue. See:
> > <https://goo.gl/tpsmEJ#status> for how to communicate with syzbot.
> >
> > If the bug is already fixed, let syzbot know by replying with:
> > #syz fix: exact-commit-title
> >
> > If you want syzbot to run the reproducer, reply with:
> > #syz test: git://repo/address.git branch-or-commit-hash
> > If you attach or paste a git patch, syzbot will apply it before testing.
> >
> > If you want to change bug's subsystems, reply with:
> > #syz set subsystems: new-subsystem
> > (See the list of subsystem names on the web dashboard)
> >
> > If the bug is a duplicate of another bug, reply with:
> > #syz dup: exact-subject-of-another-report
> >
> > If you want to undo deduplication, reply with:
> > #syz undup

[[-- Attachment #2: S/MIME Cryptographic Signature --]
[-- Type: application/pkcs7-signature, Size: 3999 bytes --]](../../CACGdZYK8FupYqA2CoqoDjS4i%3DFvG1%2Bie7fG2MENHtuxspC0-Dg%40mail.gmail.com/2-smime.p7s)

[^](#mcfbd21bc069b1007f363b61b24e989c65dbc08d4) [permalink](../../CACGdZYK8FupYqA2CoqoDjS4i%3DFvG1%2Bie7fG2MENHtuxspC0-Dg%40mail.gmail.com/) [raw](../../CACGdZYK8FupYqA2CoqoDjS4i%3DFvG1%2Bie7fG2MENHtuxspC0-Dg%40mail.gmail.com/raw) [reply](../../CACGdZYK8FupYqA2CoqoDjS4i%3DFvG1%2Bie7fG2MENHtuxspC0-Dg%40mail.gmail.com/#R)	[[flat](../../CACGdZYK8FupYqA2CoqoDjS4i%3DFvG1%2Bie7fG2MENHtuxspC0-Dg%40mail.gmail.com/T/#u)|[nested](../../CACGdZYK8FupYqA2CoqoDjS4i%3DFvG1%2Bie7fG2MENHtuxspC0-Dg%40mail.gmail.com/t/#u)] [15+ messages in thread](#rcfbd21bc069b1007f363b61b24e989c65dbc08d4)
```

---

```
[*](#e7d6dde2f092063d51a8e5de813a19565fee957aa) Re: [syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)
  2023-07-21 18:23   ` [Khazhy Kumykov](#mcfbd21bc069b1007f363b61b24e989c65dbc08d4)
@ 2023-07-21 18:56     ` Alan Stern
  2023-07-21 22:40       ` [Khazhy Kumykov](#md7ffc1e0ca26611f72de4ac23ceef919b0e38bfb)
  [0 siblings, 1 reply; 15+ messages in thread](#r7d6dde2f092063d51a8e5de813a19565fee957aa)
From: Alan Stern @ 2023-07-21 18:56 UTC ([permalink](../../69cddb70-771c-4ded-a14e-b46ce6413eb4%40rowland.harvard.edu/) / [raw](../../69cddb70-771c-4ded-a14e-b46ce6413eb4%40rowland.harvard.edu/raw))
  To: Khazhy Kumykov; +Cc: syzbot, gregkh, [linux-kernel](../../../lkml/?t=20230721185658), [linux-usb](../../../linux-usb/?t=20230721185658), syzkaller-bugs

On Fri, Jul 21, 2023 at 11:23:10AM -0700, Khazhy Kumykov wrote:
> On Fri, Jul 21, 2023 at 11:10AM Khazhy Kumykov <khazhy@google.com> wrote:
> >
> > On Mon, Jun 19, 2023 at 7:56PM syzbot
> > <syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com> wrote:
> > >
> > > Hello,
> > >
> > > syzbot found the following issue on:
> > >
> > > HEAD commit:    40f71e7cd3c6 Merge tag 'net-6.4-rc7' of git://git.kernel.o..
> > > git tree:       upstream
> > > console+strace: <https://syzkaller.appspot.com/x/log.txt?x=1581445b280000>
> > > kernel config:  <https://syzkaller.appspot.com/x/.config?x=ac246111fb601aec>
> > > dashboard link: <https://syzkaller.appspot.com/bug?extid=18996170f8096c6174d0>
> > > compiler:       gcc (Debian 10.2.1-6) 10.2.1 20210110, GNU ld (GNU Binutils for Debian) 2.35.2
> > > syz repro:      <https://syzkaller.appspot.com/x/repro.syz?x=15d23487280000>
> > > C reproducer:   <https://syzkaller.appspot.com/x/repro.c?x=16613ed3280000>
> > >
> > > Downloadable assets:
> > > disk image: <https://storage.googleapis.com/syzbot-assets/30922ad38c58/disk-40f71e7c.raw.xz>
> > > vmlinux: <https://storage.googleapis.com/syzbot-assets/3bd12e7503b8/vmlinux-40f71e7c.xz>
> > > kernel image: <https://storage.googleapis.com/syzbot-assets/1dcd340b18d4/bzImage-40f71e7c.xz>
> > >
> > > IMPORTANT: if you fix the issue, please add the following tag to the commit:
> > > Reported-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com
> > >
> > > ==================================================================
> > > BUG: KASAN: slab-out-of-bounds in read_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
> > > Read of size 8 at addr ffff88801e78b8c8 by task udevd/5011
> > >
> > > CPU: 0 PID: 5011 Comm: udevd Not tainted 6.4.0-rc6-syzkaller-00195-g40f71e7cd3c6 #0
> > > Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023
> > > Call Trace:
> > >  <TASK>
> > >  __dump_stack lib/dump_stack.c:88 [inline]
> > >  dump_stack_lvl+0xd9/0x150 lib/dump_stack.c:106
> > >  print_address_description.constprop.0+0x2c/0x3c0 mm/kasan/report.c:351
> > >  print_report mm/kasan/report.c:462 [inline]
> > >  kasan_report+0x11c/0x130 mm/kasan/report.c:572
> >
> > "src = udev->rawdescriptors[cfgno]" (so, just reading rawdescriptors)
> >
> > >  read_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
> > >  sysfs_kf_bin_read+0x19a/0x270 fs/sysfs/file.c:97
> > >  kernfs_file_read_iter fs/kernfs/file.c:251 [inline]
> > >  kernfs_fop_read_iter+0x387/0x690 fs/kernfs/file.c:280
> > >  call_read_iter include/linux/fs.h:1862 [inline]
> > >  new_sync_read fs/read_write.c:389 [inline]
> > >  vfs_read+0x4b1/0x8a0 fs/read_write.c:470
> > >  ksys_read+0x12b/0x250 fs/read_write.c:613
> > >  do_syscall_x64 arch/x86/entry/common.c:50 [inline]
> > >  do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80
> > >  entry_SYSCALL_64_after_hwframe+0x63/0xcd
> > > RIP: 0033:0x7f07c7916b6a
> > > Code: 00 3d 00 00 41 00 75 0d 50 48 8d 3d 2d 08 0a 00 e8 ea 7d 01 00 31 c0 e9 07 ff ff ff 64 8b 04 25 18 00 00 00 85 c0 75 1b 0f 05 <48> 3d 00 f0 ff ff 76 6c 48 8b 15 8f a2 0d 00 f7 d8 64 89 02 48 83
> > > RSP: 002b:00007ffdf34973d8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000
> > > RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f07c7916b6a
> > > RDX: 0000000000010011 RSI: 00007ffdf3497407 RDI: 0000000000000008
> > > RBP: 0000000000000008 R08: 0000000000000003 R09: f4f13e10193fbafe
> > > R10: 0000000000000000 R11: 0000000000000246 R12: 000055be37470e10
> > > R13: 00007ffdf34a7ae8 R14: 00007ffdf34a8138 R15: 00007ffdf3497407
> > >  </TASK>
> > >
> > > Allocated by task 758:
> > >  kasan_save_stack+0x22/0x40 mm/kasan/common.c:45
> > >  kasan_set_track+0x25/0x30 mm/kasan/common.c:52
> > >  ____kasan_kmalloc mm/kasan/common.c:374 [inline]
> > >  ____kasan_kmalloc mm/kasan/common.c:333 [inline]
> > >  __kasan_kmalloc+0xa2/0xb0 mm/kasan/common.c:383
> > >  kasan_kmalloc include/linux/kasan.h:196 [inline]
> > >  __do_kmalloc_node mm/slab_common.c:966 [inline]
> > >  __kmalloc+0x5e/0x190 mm/slab_common.c:979
> > >  kmalloc include/linux/slab.h:563 [inline]
> > >  kzalloc include/linux/slab.h:680 [inline]
> >
> > kzmalloc(length) -> this length derived from dev->descriptor.bNumConfigurations
> >
> > The corresponding kfree is in usb_destroy_configuration (makes sense)
> > - we also set rawdescriptors to NULL here. If this race was happening,
> > I'd also expect some sort of null deref report...
> >
> > Stumbled upon [https://lore.kernel.org/all/1599201467-11000-1-git-send-email-prime.zeng@hisilicon.com/T/](https://lore.kernel.org/all/1599201467-11000-1-git-send-email-prime.zeng%40hisilicon.com/T/),
> > which suggests that we can, instead, race with a descriptor change,
> > which sounds plausible - descriptor changes, bNumConfigurations no
> > longer lines up with our kmalloc... so we may run past the end of it.
> Ah yeah, the syzbot C repro does something like this, it has a virtual
> usb and keeps changing the descs -> which may end up calling
> hub_port_connect_change()

Yes, that sounds right.

The problem-causing commit is 45bf39f8df7f ("USB: core: Don't hold
device lock while reading the "descriptors" sysfs file").  When writing
the commit message I only considered changes to the rawdescriptors; it
didn't occur to me that the device descriptor might also change, which
would be just as dangerous.

> > Looking at hub_port_connect_change(), we seem to read directly into
> > udev->descriptor, check if it changed, and if it did, set
> > udev->descriptor back to the old one...? If we have an ongoing sysfs
> > read, which directly touches udev->descriptor, there might be
> > trouble...
> >
> > I see this is called in both hub_port_connect_change() and
> > usb_reset_and_verify_device()... which both seem to lock the port_dev?
> > ("port_dev->status_lock"). This looks like a different lock than
> > usb_lock_device_interruptible would grab, maybe the code has changed
> > since that was reported in 2020. But it seems to suggest we want to
> > grab this lock in sysfs to safely read from udev->descriptor.
> >
> > (I'm not clear on when the sysfs gets added/removed, since it happens
> > in usb_bus_notify()..., the above two functions that touch
> > udev->descriptor don't look like they send the
> > BUS_NOTIFY_ADD/DEL_DEVICE to me, so the race seems plausible)
>
> Ah yeah - in hub_port_connect_change() we call hub_port_connect() if
> the descriptor changed, which notifies us of device remove *after* we
> already directly messed with udev->descriptor for a potentially live
> device.
>
> I do see there's several sysfs files that directly read
> udev->descriptor with no locking - should these all need to grab the
> port_dev->status_lock?

I suppose some of them should.  (For others, the caller will already
hold the device lock.)

On the other hand, it would almost certainly be simpler if
hub_port_connect_change() and the other places calling
usb_get_device_descriptor() would read into a temporary buffer instead
of directly into udev->descriptor.  Do you think the problem could be
solved this way?  It would be cleaner in the end.

Alan Stern

[^](#m7d6dde2f092063d51a8e5de813a19565fee957aa) [permalink](../../69cddb70-771c-4ded-a14e-b46ce6413eb4%40rowland.harvard.edu/) [raw](../../69cddb70-771c-4ded-a14e-b46ce6413eb4%40rowland.harvard.edu/raw) [reply](../../69cddb70-771c-4ded-a14e-b46ce6413eb4%40rowland.harvard.edu/#R)	[[flat](../../69cddb70-771c-4ded-a14e-b46ce6413eb4%40rowland.harvard.edu/T/#u)|[nested](../../69cddb70-771c-4ded-a14e-b46ce6413eb4%40rowland.harvard.edu/t/#u)] [15+ messages in thread](#r7d6dde2f092063d51a8e5de813a19565fee957aa)
```

---

```
[*](#ed7ffc1e0ca26611f72de4ac23ceef919b0e38bfb) Re: [syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)
  2023-07-21 18:56     ` [Alan Stern](#m7d6dde2f092063d51a8e5de813a19565fee957aa)
@ 2023-07-21 22:40       ` Khazhy Kumykov
  2023-07-23  2:01         ` [Alan Stern](#m53cf18f5dda9e712a29095b6be66a98a11a50152)
  [0 siblings, 1 reply; 15+ messages in thread](#rd7ffc1e0ca26611f72de4ac23ceef919b0e38bfb)
From: Khazhy Kumykov @ 2023-07-21 22:40 UTC ([permalink](../../CACGdZYJexQYh8T_5vpanWvjADuGQYW82gdV-51N%3Dnk5HTtcDwg%40mail.gmail.com/) / [raw](../../CACGdZYJexQYh8T_5vpanWvjADuGQYW82gdV-51N%3Dnk5HTtcDwg%40mail.gmail.com/raw))
  To: Alan Stern; +Cc: syzbot, gregkh, [linux-kernel](../../../lkml/?t=20230721224019), [linux-usb](../../../linux-usb/?t=20230721224019), syzkaller-bugs

[[-- Attachment #1: Type: text/plain, Size: 8241 bytes --]](../../CACGdZYJexQYh8T_5vpanWvjADuGQYW82gdV-51N%3Dnk5HTtcDwg%40mail.gmail.com/1-a.txt)

On Fri, Jul 21, 2023 at 11:56AM Alan Stern <stern@rowland.harvard.edu> wrote:
>
> On Fri, Jul 21, 2023 at 11:23:10AM -0700, Khazhy Kumykov wrote:
> > On Fri, Jul 21, 2023 at 11:10AM Khazhy Kumykov <khazhy@google.com> wrote:
> > >
> > > On Mon, Jun 19, 2023 at 7:56PM syzbot
> > > <syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com> wrote:
> > > >
> > > > Hello,
> > > >
> > > > syzbot found the following issue on:
> > > >
> > > > HEAD commit:    40f71e7cd3c6 Merge tag 'net-6.4-rc7' of git://git.kernel.o..
> > > > git tree:       upstream
> > > > console+strace: <https://syzkaller.appspot.com/x/log.txt?x=1581445b280000>
> > > > kernel config:  <https://syzkaller.appspot.com/x/.config?x=ac246111fb601aec>
> > > > dashboard link: <https://syzkaller.appspot.com/bug?extid=18996170f8096c6174d0>
> > > > compiler:       gcc (Debian 10.2.1-6) 10.2.1 20210110, GNU ld (GNU Binutils for Debian) 2.35.2
> > > > syz repro:      <https://syzkaller.appspot.com/x/repro.syz?x=15d23487280000>
> > > > C reproducer:   <https://syzkaller.appspot.com/x/repro.c?x=16613ed3280000>
> > > >
> > > > Downloadable assets:
> > > > disk image: <https://storage.googleapis.com/syzbot-assets/30922ad38c58/disk-40f71e7c.raw.xz>
> > > > vmlinux: <https://storage.googleapis.com/syzbot-assets/3bd12e7503b8/vmlinux-40f71e7c.xz>
> > > > kernel image: <https://storage.googleapis.com/syzbot-assets/1dcd340b18d4/bzImage-40f71e7c.xz>
> > > >
> > > > IMPORTANT: if you fix the issue, please add the following tag to the commit:
> > > > Reported-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com
> > > >
> > > > ==================================================================
> > > > BUG: KASAN: slab-out-of-bounds in read_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
> > > > Read of size 8 at addr ffff88801e78b8c8 by task udevd/5011
> > > >
> > > > CPU: 0 PID: 5011 Comm: udevd Not tainted 6.4.0-rc6-syzkaller-00195-g40f71e7cd3c6 #0
> > > > Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023
> > > > Call Trace:
> > > >  <TASK>
> > > >  __dump_stack lib/dump_stack.c:88 [inline]
> > > >  dump_stack_lvl+0xd9/0x150 lib/dump_stack.c:106
> > > >  print_address_description.constprop.0+0x2c/0x3c0 mm/kasan/report.c:351
> > > >  print_report mm/kasan/report.c:462 [inline]
> > > >  kasan_report+0x11c/0x130 mm/kasan/report.c:572
> > >
> > > "src = udev->rawdescriptors[cfgno]" (so, just reading rawdescriptors)
> > >
> > > >  read_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
> > > >  sysfs_kf_bin_read+0x19a/0x270 fs/sysfs/file.c:97
> > > >  kernfs_file_read_iter fs/kernfs/file.c:251 [inline]
> > > >  kernfs_fop_read_iter+0x387/0x690 fs/kernfs/file.c:280
> > > >  call_read_iter include/linux/fs.h:1862 [inline]
> > > >  new_sync_read fs/read_write.c:389 [inline]
> > > >  vfs_read+0x4b1/0x8a0 fs/read_write.c:470
> > > >  ksys_read+0x12b/0x250 fs/read_write.c:613
> > > >  do_syscall_x64 arch/x86/entry/common.c:50 [inline]
> > > >  do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80
> > > >  entry_SYSCALL_64_after_hwframe+0x63/0xcd
> > > > RIP: 0033:0x7f07c7916b6a
> > > > Code: 00 3d 00 00 41 00 75 0d 50 48 8d 3d 2d 08 0a 00 e8 ea 7d 01 00 31 c0 e9 07 ff ff ff 64 8b 04 25 18 00 00 00 85 c0 75 1b 0f 05 <48> 3d 00 f0 ff ff 76 6c 48 8b 15 8f a2 0d 00 f7 d8 64 89 02 48 83
> > > > RSP: 002b:00007ffdf34973d8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000
> > > > RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f07c7916b6a
> > > > RDX: 0000000000010011 RSI: 00007ffdf3497407 RDI: 0000000000000008
> > > > RBP: 0000000000000008 R08: 0000000000000003 R09: f4f13e10193fbafe
> > > > R10: 0000000000000000 R11: 0000000000000246 R12: 000055be37470e10
> > > > R13: 00007ffdf34a7ae8 R14: 00007ffdf34a8138 R15: 00007ffdf3497407
> > > >  </TASK>
> > > >
> > > > Allocated by task 758:
> > > >  kasan_save_stack+0x22/0x40 mm/kasan/common.c:45
> > > >  kasan_set_track+0x25/0x30 mm/kasan/common.c:52
> > > >  ____kasan_kmalloc mm/kasan/common.c:374 [inline]
> > > >  ____kasan_kmalloc mm/kasan/common.c:333 [inline]
> > > >  __kasan_kmalloc+0xa2/0xb0 mm/kasan/common.c:383
> > > >  kasan_kmalloc include/linux/kasan.h:196 [inline]
> > > >  __do_kmalloc_node mm/slab_common.c:966 [inline]
> > > >  __kmalloc+0x5e/0x190 mm/slab_common.c:979
> > > >  kmalloc include/linux/slab.h:563 [inline]
> > > >  kzalloc include/linux/slab.h:680 [inline]
> > >
> > > kzmalloc(length) -> this length derived from dev->descriptor.bNumConfigurations
> > >
> > > The corresponding kfree is in usb_destroy_configuration (makes sense)
> > > - we also set rawdescriptors to NULL here. If this race was happening,
> > > I'd also expect some sort of null deref report...
> > >
> > > Stumbled upon [https://lore.kernel.org/all/1599201467-11000-1-git-send-email-prime.zeng@hisilicon.com/T/](https://lore.kernel.org/all/1599201467-11000-1-git-send-email-prime.zeng%40hisilicon.com/T/),
> > > which suggests that we can, instead, race with a descriptor change,
> > > which sounds plausible - descriptor changes, bNumConfigurations no
> > > longer lines up with our kmalloc... so we may run past the end of it.
> > Ah yeah, the syzbot C repro does something like this, it has a virtual
> > usb and keeps changing the descs -> which may end up calling
> > hub_port_connect_change()
>
> Yes, that sounds right.
>
> The problem-causing commit is 45bf39f8df7f ("USB: core: Don't hold
> device lock while reading the "descriptors" sysfs file").  When writing
> the commit message I only considered changes to the rawdescriptors; it
> didn't occur to me that the device descriptor might also change, which
> would be just as dangerous.
>
> > > Looking at hub_port_connect_change(), we seem to read directly into
> > > udev->descriptor, check if it changed, and if it did, set
> > > udev->descriptor back to the old one...? If we have an ongoing sysfs
> > > read, which directly touches udev->descriptor, there might be
> > > trouble...
> > >
> > > I see this is called in both hub_port_connect_change() and
> > > usb_reset_and_verify_device()... which both seem to lock the port_dev?
> > > ("port_dev->status_lock"). This looks like a different lock than
> > > usb_lock_device_interruptible would grab, maybe the code has changed
> > > since that was reported in 2020. But it seems to suggest we want to
> > > grab this lock in sysfs to safely read from udev->descriptor.
> > >
> > > (I'm not clear on when the sysfs gets added/removed, since it happens
> > > in usb_bus_notify()..., the above two functions that touch
> > > udev->descriptor don't look like they send the
> > > BUS_NOTIFY_ADD/DEL_DEVICE to me, so the race seems plausible)
> >
> > Ah yeah - in hub_port_connect_change() we call hub_port_connect() if
> > the descriptor changed, which notifies us of device remove *after* we
> > already directly messed with udev->descriptor for a potentially live
> > device.
> >
> > I do see there's several sysfs files that directly read
> > udev->descriptor with no locking - should these all need to grab the
> > port_dev->status_lock?
>
> I suppose some of them should.  (For others, the caller will already
> hold the device lock.)
>
> On the other hand, it would almost certainly be simpler if
> hub_port_connect_change() and the other places calling
> usb_get_device_descriptor() would read into a temporary buffer instead
> of directly into udev->descriptor.  Do you think the problem could be
> solved this way?  It would be cleaner in the end.

Simpler... It'll probably be cleaner in the end, but we're
snapshotting and resetting udev->descriptor several call frames above
where we're calling usb_get_device_descriptor in the case of
usb_reset_and_verify_device().. For hub_port_connect_change() it
should be straightforward - use the on-stack descriptor as the buf for
usb_get_descriptor(), and bail out like we do already.

For usb_reset_and_verify_device... we're calling hub_port_init, which
is directly modifying a bunch of the usb struct, fetches the
descriptor, validates it, and we rely on the return here to decide
whether or not to simulate a disconnect...

I'd personally lean to reverting 45bf39f8df7f, but I'm not that
familiar with the code here. :)

>
> Alan Stern

[[-- Attachment #2: S/MIME Cryptographic Signature --]
[-- Type: application/pkcs7-signature, Size: 3999 bytes --]](../../CACGdZYJexQYh8T_5vpanWvjADuGQYW82gdV-51N%3Dnk5HTtcDwg%40mail.gmail.com/2-smime.p7s)

[^](#md7ffc1e0ca26611f72de4ac23ceef919b0e38bfb) [permalink](../../CACGdZYJexQYh8T_5vpanWvjADuGQYW82gdV-51N%3Dnk5HTtcDwg%40mail.gmail.com/) [raw](../../CACGdZYJexQYh8T_5vpanWvjADuGQYW82gdV-51N%3Dnk5HTtcDwg%40mail.gmail.com/raw) [reply](../../CACGdZYJexQYh8T_5vpanWvjADuGQYW82gdV-51N%3Dnk5HTtcDwg%40mail.gmail.com/#R)	[[flat](../../CACGdZYJexQYh8T_5vpanWvjADuGQYW82gdV-51N%3Dnk5HTtcDwg%40mail.gmail.com/T/#u)|[nested](../../CACGdZYJexQYh8T_5vpanWvjADuGQYW82gdV-51N%3Dnk5HTtcDwg%40mail.gmail.com/t/#u)] [15+ messages in thread](#rd7ffc1e0ca26611f72de4ac23ceef919b0e38bfb)
```

---

```
[*](#e53cf18f5dda9e712a29095b6be66a98a11a50152) Re: [syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)
  2023-07-21 22:40       ` [Khazhy Kumykov](#md7ffc1e0ca26611f72de4ac23ceef919b0e38bfb)
@ 2023-07-23  2:01         ` Alan Stern
  2023-07-23  2:21           ` [syzbot](#m8ed752822c9f8dd9a8b08ea04933429747edf601)
  [0 siblings, 1 reply; 15+ messages in thread](#r53cf18f5dda9e712a29095b6be66a98a11a50152)
From: Alan Stern @ 2023-07-23  2:01 UTC ([permalink](../../e5a6c3be-6dd3-4c85-9c5b-f9fb7aca0b36%40rowland.harvard.edu/) / [raw](../../e5a6c3be-6dd3-4c85-9c5b-f9fb7aca0b36%40rowland.harvard.edu/raw))
  To: Khazhy Kumykov; +Cc: syzbot, gregkh, [linux-kernel](../../../lkml/?t=20230723020117), [linux-usb](../../../linux-usb/?t=20230723020117), syzkaller-bugs

On Fri, Jul 21, 2023 at 03:40:01PM -0700, Khazhy Kumykov wrote:
> On Fri, Jul 21, 2023 at 11:56AM Alan Stern <stern@rowland.harvard.edu> wrote:

> > On the other hand, it would almost certainly be simpler if
> > hub_port_connect_change() and the other places calling
> > usb_get_device_descriptor() would read into a temporary buffer instead
> > of directly into udev->descriptor.  Do you think the problem could be
> > solved this way?  It would be cleaner in the end.
>
> Simpler... It'll probably be cleaner in the end, but we're
> snapshotting and resetting udev->descriptor several call frames above
> where we're calling usb_get_device_descriptor in the case of
> usb_reset_and_verify_device().. For hub_port_connect_change() it
> should be straightforward - use the on-stack descriptor as the buf for
> usb_get_descriptor(), and bail out like we do already.
>
> For usb_reset_and_verify_device... we're calling hub_port_init, which
> is directly modifying a bunch of the usb struct, fetches the
> descriptor, validates it, and we rely on the return here to decide
> whether or not to simulate a disconnect...
>
> I'd personally lean to reverting 45bf39f8df7f, but I'm not that
> familiar with the code here. :)

Let's see what syzbot has to say about this patch...

Alan Stern

#syz test: <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/> v6.5-rc2

 drivers/usb/core/hcd.c     |    3
 drivers/usb/core/hub.c     |  167 +++++++++++++++++++++++++--------------------
 drivers/usb/core/message.c |   37 ---------
 drivers/usb/core/usb.h     |    8 +-
 4 files changed, 104 insertions(+), 111 deletions(-)

Index: usb-devel/drivers/usb/core/hcd.c
===================================================================
--- usb-devel.orig/drivers/usb/core/hcd.c
+++ usb-devel/drivers/usb/core/hcd.c
@@ -994,7 +994,8 @@ static int register_root_hub(struct usb_
 	mutex_lock(&usb_bus_idr_lock);

 	usb_dev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);
-	retval = usb_get_device_descriptor(usb_dev, USB_DT_DEVICE_SIZE);
+	retval = usb_get_device_descriptor(usb_dev,
+			&usb_dev->descriptor, USB_DT_DEVICE_SIZE);
 	if (retval != sizeof usb_dev->descriptor) {
 		mutex_unlock(&usb_bus_idr_lock);
 		dev_dbg (parent_dev, "can't read %s device descriptor %d\n",
Index: usb-devel/drivers/usb/core/message.c
===================================================================
--- usb-devel.orig/drivers/usb/core/message.c
+++ usb-devel/drivers/usb/core/message.c
@@ -1040,43 +1040,6 @@ char *usb_cache_string(struct usb_device
 EXPORT_SYMBOL_GPL(usb_cache_string);

 /*
- * usb_get_device_descriptor - (re)reads the device descriptor (usbcore)
- * @dev: the device whose device descriptor is being updated
- * @size: how much of the descriptor to read
- *
- * Context: task context, might sleep.
- *
- * Updates the copy of the device descriptor stored in the device structure,
- * which dedicates space for this purpose.
- *
- * Not exported, only for use by the core.  If drivers really want to read
- * the device descriptor directly, they can call usb_get_descriptor() with
- * type = USB_DT_DEVICE and index = 0.
- *
- * This call is synchronous, and may not be used in an interrupt context.
- *
- * Return: The number of bytes received on success, or else the status code
- * returned by the underlying usb_control_msg() call.
- */
-int usb_get_device_descriptor(struct usb_device *dev, unsigned int size)
-{
-	struct usb_device_descriptor *desc;
-	int ret;
-
-	if (size > sizeof(*desc))
-		return -EINVAL;
-	desc = kmalloc(sizeof(*desc), GFP_NOIO);
-	if (!desc)
-		return -ENOMEM;
-
-	ret = usb_get_descriptor(dev, USB_DT_DEVICE, 0, desc, size);
-	if (ret >= 0)
-		memcpy(&dev->descriptor, desc, size);
-	kfree(desc);
-	return ret;
-}
-
-/*
  * usb_set_isoch_delay - informs the device of the packet transmit delay
  * @dev: the device whose delay is to be informed
  * Context: task context, might sleep
Index: usb-devel/drivers/usb/core/usb.h
===================================================================
--- usb-devel.orig/drivers/usb/core/usb.h
+++ usb-devel/drivers/usb/core/usb.h
@@ -43,8 +43,6 @@ extern bool usb_endpoint_is_ignored(stru
 		struct usb_endpoint_descriptor *epd);
 extern int usb_remove_device(struct usb_device *udev);

-extern int usb_get_device_descriptor(struct usb_device *dev,
-		unsigned int size);
 extern int usb_set_isoch_delay(struct usb_device *dev);
 extern int usb_get_bos_descriptor(struct usb_device *dev);
 extern void usb_release_bos_descriptor(struct usb_device *dev);
@@ -57,6 +55,12 @@ extern int usb_generic_driver_suspend(st
 extern int usb_generic_driver_resume(struct usb_device *udev,
 		pm_message_t msg);

+static inline int usb_get_device_descriptor(struct usb_device *dev,
+		struct usb_device_descriptor *desc, unsigned int size)
+{
+	return usb_get_descriptor(dev, USB_DT_DEVICE, 0, desc, size);
+}
+
 static inline unsigned usb_get_max_power(struct usb_device *udev,
 		struct usb_host_config *c)
 {
Index: usb-devel/drivers/usb/core/hub.c
===================================================================
--- usb-devel.orig/drivers/usb/core/hub.c
+++ usb-devel/drivers/usb/core/hub.c
@@ -2671,12 +2671,19 @@ int usb_authorize_device(struct usb_devi
 	}

 	if (usb_dev->wusb) {
-		result = usb_get_device_descriptor(usb_dev, sizeof(usb_dev->descriptor));
+		struct usb_device_descriptor desc;
+
+		result = usb_get_device_descriptor(usb_dev, &desc, sizeof(desc));
 		if (result < 0) {
 			dev_err(&usb_dev->dev, "can't re-read device descriptor for "
 				"authorization: %d\n", result);
 			goto error_device_descriptor;
 		}
+		if (memcmp(&usb_dev->descriptor, &desc, sizeof(desc)) != 0) {
+			dev_err(&usb_dev->dev, "device descriptor changed before authorization: %d\n",
+					result);
+			goto error_device_descriptor;
+		}
 	}

 	usb_dev->authorized = 1;
@@ -4730,7 +4737,7 @@ static int hub_enable_device(struct usb_
  */
 static int
 hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
-		int retry_counter)
+		int retry_counter, struct usb_device_descriptor *dev_descr)
 {
 	struct usb_device	*hdev = hub->hdev;
 	struct usb_hcd		*hcd = bus_to_hcd(hdev->bus);
@@ -4742,6 +4749,12 @@ hub_port_init(struct usb_hub *hub, struc
 	int			devnum = udev->devnum;
 	const char		*driver_name;
 	bool			do_new_scheme;
+	const bool		reinit = !!dev_descr;
+	union {
+		struct usb_device_descriptor	d;
+#define GET_DESCRIPTOR_BUFSIZE	64
+		u8				raw[GET_DESCRIPTOR_BUFSIZE];
+	}			buf;

 	/* root hub ports have a slightly longer reset period
 	 * (from USB 2.0 spec, section 7.1.7.5)
@@ -4774,32 +4787,34 @@ hub_port_init(struct usb_hub *hub, struc
 	}
 	oldspeed = udev->speed;

-	/* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...
-	 * it's fixed size except for full speed devices.
-	 * For Wireless USB devices, ep0 max packet is always 512 (tho
-	 * reported as 0xff in the device descriptor). WUSB1.0[4.8.1].
-	 */
-	switch (udev->speed) {
-	case USB_SPEED_SUPER_PLUS:
-	case USB_SPEED_SUPER:
-	case USB_SPEED_WIRELESS:	/* fixed at 512 */
-		udev->ep0.desc.wMaxPacketSize = cpu_to_le16(512);
-		break;
-	case USB_SPEED_HIGH:		/* fixed at 64 */
-		udev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);
-		break;
-	case USB_SPEED_FULL:		/* 8, 16, 32, or 64 */
-		/* to determine the ep0 maxpacket size, try to read
-		 * the device descriptor to get bMaxPacketSize0 and
-		 * then correct our initial guess.
-		 */
-		udev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);
-		break;
-	case USB_SPEED_LOW:		/* fixed at 8 */
-		udev->ep0.desc.wMaxPacketSize = cpu_to_le16(8);
-		break;
-	default:
-		goto fail;
+	if (!reinit) {
+		/* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...
+		 * it's fixed size except for full speed devices.
+		 * For Wireless USB devices, ep0 max packet is always 512 (tho
+		 * reported as 0xff in the device descriptor). WUSB1.0[4.8.1].
+		 */
+		switch (udev->speed) {
+		case USB_SPEED_SUPER_PLUS:
+		case USB_SPEED_SUPER:
+		case USB_SPEED_WIRELESS:	/* fixed at 512 */
+			udev->ep0.desc.wMaxPacketSize = cpu_to_le16(512);
+			break;
+		case USB_SPEED_HIGH:		/* fixed at 64 */
+			udev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);
+			break;
+		case USB_SPEED_FULL:		/* 8, 16, 32, or 64 */
+			/* to determine the ep0 maxpacket size, try to read
+			 * the device descriptor to get bMaxPacketSize0 and
+			 * then correct our initial guess.
+			 */
+			udev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);
+			break;
+		case USB_SPEED_LOW:		/* fixed at 8 */
+			udev->ep0.desc.wMaxPacketSize = cpu_to_le16(8);
+			break;
+		default:
+			goto fail;
+		}
 	}

 	if (udev->speed == USB_SPEED_WIRELESS)
@@ -4822,22 +4837,24 @@ hub_port_init(struct usb_hub *hub, struc
 	if (udev->speed < USB_SPEED_SUPER)
 		dev_info(&udev->dev,
 				"%s %s USB device number %d using %s\n",
-				(udev->config) ? "reset" : "new", speed,
+				(reinit ? "reset" : "new"), speed,
 				devnum, driver_name);

-	/* Set up TT records, if needed  */
-	if (hdev->tt) {
-		udev->tt = hdev->tt;
-		udev->ttport = hdev->ttport;
-	} else if (udev->speed != USB_SPEED_HIGH
-			&& hdev->speed == USB_SPEED_HIGH) {
-		if (!hub->tt.hub) {
-			dev_err(&udev->dev, "parent hub has no TT\n");
-			retval = -EINVAL;
-			goto fail;
+	if (!reinit) {
+		/* Set up TT records, if needed  */
+		if (hdev->tt) {
+			udev->tt = hdev->tt;
+			udev->ttport = hdev->ttport;
+		} else if (udev->speed != USB_SPEED_HIGH
+				&& hdev->speed == USB_SPEED_HIGH) {
+			if (!hub->tt.hub) {
+				dev_err(&udev->dev, "parent hub has no TT\n");
+				retval = -EINVAL;
+				goto fail;
+			}
+			udev->tt = &hub->tt;
+			udev->ttport = port1;
 		}
-		udev->tt = &hub->tt;
-		udev->ttport = port1;
 	}

 	/* Why interleave GET_DESCRIPTOR and SET_ADDRESS this way?
@@ -4861,7 +4878,6 @@ hub_port_init(struct usb_hub *hub, struc
 		}

 		if (do_new_scheme) {
-			struct usb_device_descriptor *buf;
 			int r = 0;

 			retval = hub_enable_device(udev);
@@ -4872,28 +4888,21 @@ hub_port_init(struct usb_hub *hub, struc
 				goto fail;
 			}

-#define GET_DESCRIPTOR_BUFSIZE	64
-			buf = kmalloc(GET_DESCRIPTOR_BUFSIZE, GFP_NOIO);
-			if (!buf) {
-				retval = -ENOMEM;
-				continue;
-			}
-
 			/* Retry on all errors; some devices are flakey.
 			 * 255 is for WUSB devices, we actually need to use
 			 * 512 (WUSB1.0[4.8.1]).
 			 */
 			for (operations = 0; operations < GET_MAXPACKET0_TRIES;
 					++operations) {
-				buf->bMaxPacketSize0 = 0;
+				buf.d.bMaxPacketSize0 = 0;
 				r = usb_control_msg(udev, usb_rcvaddr0pipe(),
 					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
 					USB_DT_DEVICE << 8, 0,
-					buf, GET_DESCRIPTOR_BUFSIZE,
+					buf.raw, GET_DESCRIPTOR_BUFSIZE,
 					initial_descriptor_timeout);
-				switch (buf->bMaxPacketSize0) {
+				switch (buf.d.bMaxPacketSize0) {
 				case 8: case 16: case 32: case 64: case 255:
-					if (buf->bDescriptorType ==
+					if (buf.d.bDescriptorType ==
 							USB_DT_DEVICE) {
 						r = 0;
 						break;
@@ -4915,9 +4924,15 @@ hub_port_init(struct usb_hub *hub, struc
 						udev->speed > USB_SPEED_FULL))
 					break;
 			}
-			udev->descriptor.bMaxPacketSize0 =
-					buf->bMaxPacketSize0;
-			kfree(buf);
+			if (!reinit) {
+				udev->descriptor.bMaxPacketSize0 =
+						buf.d.bMaxPacketSize0;
+			} else if (udev->descriptor.bMaxPacketSize0 !=
+					buf.d.bMaxPacketSize0) {
+				dev_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");
+				retval = -ENODEV;
+				goto fail;
+			}

 			retval = hub_port_reset(hub, port1, udev, delay, false);
 			if (retval < 0)		/* error or disconnect */
@@ -4981,7 +4996,8 @@ hub_port_init(struct usb_hub *hub, struc
 				break;
 		}

-		retval = usb_get_device_descriptor(udev, 8);
+		/* !do_new_scheme || wusb */
+		retval = usb_get_device_descriptor(udev, &buf.d, 8);
 		if (retval < 8) {
 			if (retval != -ENODEV)
 				dev_err(&udev->dev,
@@ -4992,6 +5008,15 @@ hub_port_init(struct usb_hub *hub, struc
 		} else {
 			u32 delay;

+			if (!reinit) {
+				udev->descriptor.bMaxPacketSize0 =
+						buf.d.bMaxPacketSize0;
+			} else if (udev->descriptor.bMaxPacketSize0 !=
+					buf.d.bMaxPacketSize0) {
+				dev_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");
+				retval = -ENODEV;
+				goto fail;
+			}
 			retval = 0;

 			delay = udev->parent->hub_delay;
@@ -5046,8 +5071,8 @@ hub_port_init(struct usb_hub *hub, struc
 		usb_ep0_reinit(udev);
 	}

-	retval = usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE);
-	if (retval < (signed)sizeof(udev->descriptor)) {
+	retval = usb_get_device_descriptor(udev, &buf.d, sizeof(buf.d));
+	if (retval < (signed)sizeof(buf.d)) {
 		if (retval != -ENODEV)
 			dev_err(&udev->dev, "device descriptor read/all, error %d\n",
 					retval);
@@ -5055,6 +5080,10 @@ hub_port_init(struct usb_hub *hub, struc
 			retval = -ENOMSG;
 		goto fail;
 	}
+	if (!reinit)
+		udev->descriptor = buf.d;
+	else
+		*dev_descr = buf.d;

 	usb_detect_quirks(udev);

@@ -5158,7 +5187,7 @@ hub_power_remaining(struct usb_hub *hub)

 static int descriptors_changed(struct usb_device *udev,
-		struct usb_device_descriptor *old_device_descriptor,
+		struct usb_device_descriptor *new_device_descriptor,
 		struct usb_host_bos *old_bos)
 {
 	int		changed = 0;
@@ -5169,8 +5198,8 @@ static int descriptors_changed(struct us
 	int		length;
 	char		*buf;

-	if (memcmp(&udev->descriptor, old_device_descriptor,
-			sizeof(*old_device_descriptor)) != 0)
+	if (memcmp(&udev->descriptor, new_device_descriptor,
+			sizeof(*new_device_descriptor)) != 0)
 		return 1;

 	if ((old_bos && !udev->bos) || (!old_bos && udev->bos))
@@ -5348,7 +5377,7 @@ static void hub_port_connect(struct usb_
 		}

 		/* reset (non-USB 3.0 devices) and get descriptor */
-		status = hub_port_init(hub, udev, port1, i);
+		status = hub_port_init(hub, udev, port1, i, NULL);
 		if (status < 0)
 			goto loop;

@@ -5524,9 +5553,8 @@ static void hub_port_connect_change(stru
 			 * changed device descriptors before resuscitating the
 			 * device.
 			 */
-			descriptor = udev->descriptor;
-			retval = usb_get_device_descriptor(udev,
-					sizeof(udev->descriptor));
+			retval = usb_get_device_descriptor(udev, &descriptor,
+					sizeof(descriptor));
 			if (retval < 0) {
 				dev_dbg(&udev->dev,
 						"can't read device descriptor %d\n",
@@ -5536,8 +5564,6 @@ static void hub_port_connect_change(stru
 						udev->bos)) {
 					dev_dbg(&udev->dev,
 							"device descriptor has changed\n");
-					/* for disconnect() calls */
-					udev->descriptor = descriptor;
 				} else {
 					status = 0; /* Nothing to do */
 				}
@@ -5982,7 +6008,7 @@ static int usb_reset_and_verify_device(s
 	struct usb_device		*parent_hdev = udev->parent;
 	struct usb_hub			*parent_hub;
 	struct usb_hcd			*hcd = bus_to_hcd(udev->bus);
-	struct usb_device_descriptor	descriptor = udev->descriptor;
+	struct usb_device_descriptor	descriptor;
 	struct usb_host_bos		*bos;
 	int				i, j, ret = 0;
 	int				port1 = udev->portnum;
@@ -6018,7 +6044,7 @@ static int usb_reset_and_verify_device(s
 		/* ep0 maxpacket size may change; let the HCD know about it.
 		 * Other endpoints will be handled by re-enumeration. */
 		usb_ep0_reinit(udev);
-		ret = hub_port_init(parent_hub, udev, port1, i);
+		ret = hub_port_init(parent_hub, udev, port1, i, &descriptor);
 		if (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)
 			break;
 	}
@@ -6030,7 +6056,6 @@ static int usb_reset_and_verify_device(s
 	/* Device might have changed firmware (DFU or similar) */
 	if (descriptors_changed(udev, &descriptor, bos)) {
 		dev_info(&udev->dev, "device firmware changed\n");
-		udev->descriptor = descriptor;	/* for disconnect() calls */
 		goto re_enumerate;
 	}

[^](#m53cf18f5dda9e712a29095b6be66a98a11a50152) [permalink](../../e5a6c3be-6dd3-4c85-9c5b-f9fb7aca0b36%40rowland.harvard.edu/) [raw](../../e5a6c3be-6dd3-4c85-9c5b-f9fb7aca0b36%40rowland.harvard.edu/raw) [reply](../../e5a6c3be-6dd3-4c85-9c5b-f9fb7aca0b36%40rowland.harvard.edu/#R)	[[flat](../../e5a6c3be-6dd3-4c85-9c5b-f9fb7aca0b36%40rowland.harvard.edu/T/#u)|[nested](../../e5a6c3be-6dd3-4c85-9c5b-f9fb7aca0b36%40rowland.harvard.edu/t/#u)] [15+ messages in thread](#r53cf18f5dda9e712a29095b6be66a98a11a50152)
```

---

```
[*](#e8ed752822c9f8dd9a8b08ea04933429747edf601) Re: [syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)
  2023-07-23  2:01         ` [Alan Stern](#m53cf18f5dda9e712a29095b6be66a98a11a50152)
@ 2023-07-23  2:21           ` syzbot
  2023-07-25 19:26             ` [Alan Stern](#m51a496d4914a8b0c2cf0a20d2be4c53e66789254)
  [0 siblings, 1 reply; 15+ messages in thread](#r8ed752822c9f8dd9a8b08ea04933429747edf601)
From: syzbot @ 2023-07-23  2:21 UTC ([permalink](../../0000000000007fc04d06011e274f%40google.com/) / [raw](../../0000000000007fc04d06011e274f%40google.com/raw))
  To: gregkh, khazhy, [linux-kernel](../../../lkml/?t=20230723022127), [linux-usb](../../../linux-usb/?t=20230723022127), stern, syzkaller-bugs

Hello,

syzbot has tested the proposed patch and the reproducer did not trigger any issue:

Reported-and-tested-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com

Tested on:

commit:         fdf0eaf1 Linux 6.5-rc2
git tree:       <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/> v6.5-rc2
console output: <https://syzkaller.appspot.com/x/log.txt?x=158187d1a80000>
kernel config:  <https://syzkaller.appspot.com/x/.config?x=77b9a3cf8f44c6da>
dashboard link: <https://syzkaller.appspot.com/bug?extid=18996170f8096c6174d0>
compiler:       gcc (Debian 12.2.0-14) 12.2.0, GNU ld (GNU Binutils for Debian) 2.40
patch:          <https://syzkaller.appspot.com/x/patch.diff?x=1120305ea80000>

Note: testing is done by a robot and is best-effort only.

[^](#m8ed752822c9f8dd9a8b08ea04933429747edf601) [permalink](../../0000000000007fc04d06011e274f%40google.com/) [raw](../../0000000000007fc04d06011e274f%40google.com/raw) [reply](../../0000000000007fc04d06011e274f%40google.com/#R)	[[flat](../../0000000000007fc04d06011e274f%40google.com/T/#u)|[nested](../../0000000000007fc04d06011e274f%40google.com/t/#u)] [15+ messages in thread](#r8ed752822c9f8dd9a8b08ea04933429747edf601)
```

---

```
[*](#e51a496d4914a8b0c2cf0a20d2be4c53e66789254) Re: [syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)
  2023-07-23  2:21           ` [syzbot](#m8ed752822c9f8dd9a8b08ea04933429747edf601)
@ 2023-07-25 19:26             ` Alan Stern
  2023-07-25 20:42               ` [Khazhy Kumykov](#mcbd7d76466d9dfc8915d25e66f4e68adedcdbc12)
  2023-07-25 20:54               ` [syzbot](#mb60707f27ed3bcbc25254759aff11ea6ab273c2a)
  [0 siblings, 2 replies; 15+ messages in thread](#r51a496d4914a8b0c2cf0a20d2be4c53e66789254)
From: Alan Stern @ 2023-07-25 19:26 UTC ([permalink](../../c9bb72e0-8e02-4568-bd43-6897f9c94d12%40rowland.harvard.edu/) / [raw](../../c9bb72e0-8e02-4568-bd43-6897f9c94d12%40rowland.harvard.edu/raw))
  To: syzbot; +Cc: gregkh, khazhy, [linux-kernel](../../../lkml/?t=20230725192624), [linux-usb](../../../linux-usb/?t=20230725192624), syzkaller-bugs

On Sat, Jul 22, 2023 at 07:21:23PM -0700, syzbot wrote:
> Hello,
>
> syzbot has tested the proposed patch and the reproducer did not trigger any issue:
>
> Reported-and-tested-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com

Here's a revised version of the patch, with some mistakes fixed.  If
this works, I'll split it into three parts and submit them.

Alan Stern

#syz test: <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/> v6.5-rc3

Index: usb-devel/drivers/usb/core/hub.c
===================================================================
--- usb-devel.orig/drivers/usb/core/hub.c
+++ usb-devel/drivers/usb/core/hub.c
@@ -2671,12 +2671,17 @@ int usb_authorize_device(struct usb_devi
 	}

 	if (usb_dev->wusb) {
-		result = usb_get_device_descriptor(usb_dev, sizeof(usb_dev->descriptor));
-		if (result < 0) {
+		struct usb_device_descriptor *descr;
+
+		descr = usb_get_device_descriptor(usb_dev);
+		if (IS_ERR(descr)) {
+			result = PTR_ERR(descr);
 			dev_err(&usb_dev->dev, "can't re-read device descriptor for "
 				"authorization: %d\n", result);
 			goto error_device_descriptor;
 		}
+		usb_dev->descriptor = *descr;
+		kfree(descr);
 	}

 	usb_dev->authorized = 1;
@@ -4718,6 +4723,67 @@ static int hub_enable_device(struct usb_
 	return hcd->driver->enable_device(hcd, udev);
 }

+/*
+ * Get the bMaxPacketSize0 value during initialization by reading the
+ * device's device descriptor.  Since we don't already know this value,
+ * the transfer is unsafe and it ignores I/O errors, only testing for
+ * reasonable received values.
+ *
+ * For "old scheme" initialization size will be 8, so we read just the
+ * start of the device descriptor, which should work okay regardless of
+ * the actual bMaxPacketSize0 value.  For "new scheme" initialization,
+ * size will be 64 (and buf will point to a sufficiently large buffer),
+ * which might not be kosher according to the USB spec but it's what
+ * Windows does and what many devices expect.
+ *
+ * Returns bMaxPacketSize0 or a negative error code.
+ */
+static int get_bMaxPacketSize0(struct usb_device *udev,
+		struct usb_device_descriptor *buf, int size, bool first_time)
+{
+	int i, rc;
+
+	/*
+	 * Retry on all errors; some devices are flakey.
+	 * 255 is for WUSB devices, we actually need to use
+	 * 512 (WUSB1.0[4.8.1]).
+	 */
+	for (i = 0; i < GET_MAXPACKET0_TRIES; ++i) {
+		/* Start with invalid values in case the transfer fails */
+		buf->bDescriptorType = buf->bMaxPacketSize0 = 0;
+		rc = usb_control_msg(udev, usb_rcvaddr0pipe(),
+				USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
+				USB_DT_DEVICE << 8, 0,
+				buf, size,
+				initial_descriptor_timeout);
+		switch (buf->bMaxPacketSize0) {
+		case 8: case 16: case 32: case 64: case 255:
+			if (buf->bDescriptorType == USB_DT_DEVICE) {
+				rc = buf->bMaxPacketSize0;
+				break;
+			}
+			fallthrough;
+		default:
+			if (rc >= 0)
+				rc = -EPROTO;
+			break;
+		}
+
+		/*
+		 * Some devices time out if they are powered on
+		 * when already connected. They need a second
+		 * reset, so return early. But only on the first
+		 * attempt, lest we get into a time-out/reset loop.
+		 */
+		if (rc > 0 || (rc == -ETIMEDOUT && first_time &&
+				udev->speed > USB_SPEED_FULL))
+			break;
+	}
+	return rc;
+}
+
+#define GET_DESCRIPTOR_BUFSIZE	64
+
 /* Reset device, (re)assign address, get device descriptor.
  * Device connection must be stable, no more debouncing needed.
  * Returns device in USB_STATE_ADDRESS, except on error.
@@ -4727,10 +4793,17 @@ static int hub_enable_device(struct usb_
  * the port lock.  For a newly detected device that is not accessible
  * through any global pointers, it's not necessary to lock the device,
  * but it is still necessary to lock the port.
+ *
+ * For a newly detected device, @dev_descr must be NULL.  The device
+ * descriptor retrieved from the device will then be stored in
+ * @udev->descriptor.  For an already existing device, @dev_descr
+ * must be non-NULL.  The device descriptor will be stored there,
+ * not in @udev->descriptor, because descriptors for registered
+ * devices are meant to be immutable.
  */
 static int
 hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
-		int retry_counter)
+		int retry_counter, struct usb_device_descriptor *dev_descr)
 {
 	struct usb_device	*hdev = hub->hdev;
 	struct usb_hcd		*hcd = bus_to_hcd(hdev->bus);
@@ -4742,6 +4815,13 @@ hub_port_init(struct usb_hub *hub, struc
 	int			devnum = udev->devnum;
 	const char		*driver_name;
 	bool			do_new_scheme;
+	const bool		initial = !dev_descr;
+	int			maxp0;
+	struct usb_device_descriptor	*buf, *descr;
+
+	buf = kmalloc(GET_DESCRIPTOR_BUFSIZE, GFP_NOIO);
+	if (!buf)
+		return -ENOMEM;

 	/* root hub ports have a slightly longer reset period
 	 * (from USB 2.0 spec, section 7.1.7.5)
@@ -4774,32 +4854,34 @@ hub_port_init(struct usb_hub *hub, struc
 	}
 	oldspeed = udev->speed;

-	/* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...
-	 * it's fixed size except for full speed devices.
-	 * For Wireless USB devices, ep0 max packet is always 512 (tho
-	 * reported as 0xff in the device descriptor). WUSB1.0[4.8.1].
-	 */
-	switch (udev->speed) {
-	case USB_SPEED_SUPER_PLUS:
-	case USB_SPEED_SUPER:
-	case USB_SPEED_WIRELESS:	/* fixed at 512 */
-		udev->ep0.desc.wMaxPacketSize = cpu_to_le16(512);
-		break;
-	case USB_SPEED_HIGH:		/* fixed at 64 */
-		udev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);
-		break;
-	case USB_SPEED_FULL:		/* 8, 16, 32, or 64 */
-		/* to determine the ep0 maxpacket size, try to read
-		 * the device descriptor to get bMaxPacketSize0 and
-		 * then correct our initial guess.
-		 */
-		udev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);
-		break;
-	case USB_SPEED_LOW:		/* fixed at 8 */
-		udev->ep0.desc.wMaxPacketSize = cpu_to_le16(8);
-		break;
-	default:
-		goto fail;
+	if (initial) {
+		/* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...
+		 * it's fixed size except for full speed devices.
+		 * For Wireless USB devices, ep0 max packet is always 512 (tho
+		 * reported as 0xff in the device descriptor). WUSB1.0[4.8.1].
+		 */
+		switch (udev->speed) {
+		case USB_SPEED_SUPER_PLUS:
+		case USB_SPEED_SUPER:
+		case USB_SPEED_WIRELESS:	/* fixed at 512 */
+			udev->ep0.desc.wMaxPacketSize = cpu_to_le16(512);
+			break;
+		case USB_SPEED_HIGH:		/* fixed at 64 */
+			udev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);
+			break;
+		case USB_SPEED_FULL:		/* 8, 16, 32, or 64 */
+			/* to determine the ep0 maxpacket size, try to read
+			 * the device descriptor to get bMaxPacketSize0 and
+			 * then correct our initial guess.
+			 */
+			udev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);
+			break;
+		case USB_SPEED_LOW:		/* fixed at 8 */
+			udev->ep0.desc.wMaxPacketSize = cpu_to_le16(8);
+			break;
+		default:
+			goto fail;
+		}
 	}

 	if (udev->speed == USB_SPEED_WIRELESS)
@@ -4822,22 +4904,24 @@ hub_port_init(struct usb_hub *hub, struc
 	if (udev->speed < USB_SPEED_SUPER)
 		dev_info(&udev->dev,
 				"%s %s USB device number %d using %s\n",
-				(udev->config) ? "reset" : "new", speed,
+				(initial ? "new" : "reset"), speed,
 				devnum, driver_name);

-	/* Set up TT records, if needed  */
-	if (hdev->tt) {
-		udev->tt = hdev->tt;
-		udev->ttport = hdev->ttport;
-	} else if (udev->speed != USB_SPEED_HIGH
-			&& hdev->speed == USB_SPEED_HIGH) {
-		if (!hub->tt.hub) {
-			dev_err(&udev->dev, "parent hub has no TT\n");
-			retval = -EINVAL;
-			goto fail;
+	if (initial) {
+		/* Set up TT records, if needed  */
+		if (hdev->tt) {
+			udev->tt = hdev->tt;
+			udev->ttport = hdev->ttport;
+		} else if (udev->speed != USB_SPEED_HIGH
+				&& hdev->speed == USB_SPEED_HIGH) {
+			if (!hub->tt.hub) {
+				dev_err(&udev->dev, "parent hub has no TT\n");
+				retval = -EINVAL;
+				goto fail;
+			}
+			udev->tt = &hub->tt;
+			udev->ttport = port1;
 		}
-		udev->tt = &hub->tt;
-		udev->ttport = port1;
 	}

 	/* Why interleave GET_DESCRIPTOR and SET_ADDRESS this way?
@@ -4861,9 +4945,6 @@ hub_port_init(struct usb_hub *hub, struc
 		}

 		if (do_new_scheme) {
-			struct usb_device_descriptor *buf;
-			int r = 0;
-
 			retval = hub_enable_device(udev);
 			if (retval < 0) {
 				dev_err(&udev->dev,
@@ -4872,52 +4953,14 @@ hub_port_init(struct usb_hub *hub, struc
 				goto fail;
 			}

-#define GET_DESCRIPTOR_BUFSIZE	64
-			buf = kmalloc(GET_DESCRIPTOR_BUFSIZE, GFP_NOIO);
-			if (!buf) {
-				retval = -ENOMEM;
-				continue;
-			}
-
-			/* Retry on all errors; some devices are flakey.
-			 * 255 is for WUSB devices, we actually need to use
-			 * 512 (WUSB1.0[4.8.1]).
-			 */
-			for (operations = 0; operations < GET_MAXPACKET0_TRIES;
-					++operations) {
-				buf->bMaxPacketSize0 = 0;
-				r = usb_control_msg(udev, usb_rcvaddr0pipe(),
-					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
-					USB_DT_DEVICE << 8, 0,
-					buf, GET_DESCRIPTOR_BUFSIZE,
-					initial_descriptor_timeout);
-				switch (buf->bMaxPacketSize0) {
-				case 8: case 16: case 32: case 64: case 255:
-					if (buf->bDescriptorType ==
-							USB_DT_DEVICE) {
-						r = 0;
-						break;
-					}
-					fallthrough;
-				default:
-					if (r == 0)
-						r = -EPROTO;
-					break;
-				}
-				/*
-				 * Some devices time out if they are powered on
-				 * when already connected. They need a second
-				 * reset. But only on the first attempt,
-				 * lest we get into a time out/reset loop
-				 */
-				if (r == 0 || (r == -ETIMEDOUT &&
-						retries == 0 &&
-						udev->speed > USB_SPEED_FULL))
-					break;
+			maxp0 = get_bMaxPacketSize0(udev, buf,
+					GET_DESCRIPTOR_BUFSIZE, retries == 0);
+			if (maxp0 > 0 && !initial &&
+					maxp0 != udev->descriptor.bMaxPacketSize0) {
+				dev_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");
+				retval = -ENODEV;
+				goto fail;
 			}
-			udev->descriptor.bMaxPacketSize0 =
-					buf->bMaxPacketSize0;
-			kfree(buf);

 			retval = hub_port_reset(hub, port1, udev, delay, false);
 			if (retval < 0)		/* error or disconnect */
@@ -4928,14 +4971,13 @@ hub_port_init(struct usb_hub *hub, struc
 				retval = -ENODEV;
 				goto fail;
 			}
-			if (r) {
-				if (r != -ENODEV)
+			if (maxp0 < 0) {
+				if (maxp0 != -ENODEV)
 					dev_err(&udev->dev, "device descriptor read/64, error %d\n",
-							r);
-				retval = -EMSGSIZE;
+							maxp0);
+				retval = maxp0;
 				continue;
 			}
-#undef GET_DESCRIPTOR_BUFSIZE
 		}

 		/*
@@ -4981,18 +5023,22 @@ hub_port_init(struct usb_hub *hub, struc
 				break;
 		}

-		retval = usb_get_device_descriptor(udev, 8);
-		if (retval < 8) {
+		/* !do_new_scheme || wusb */
+		maxp0 = get_bMaxPacketSize0(udev, buf, 8, retries == 0);
+		if (maxp0 < 0) {
+			retval = maxp0;
 			if (retval != -ENODEV)
 				dev_err(&udev->dev,
 					"device descriptor read/8, error %d\n",
 					retval);
-			if (retval >= 0)
-				retval = -EMSGSIZE;
 		} else {
 			u32 delay;

-			retval = 0;
+			if (!initial && maxp0 != udev->descriptor.bMaxPacketSize0) {
+				dev_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");
+				retval = -ENODEV;
+				goto fail;
+			}

 			delay = udev->parent->hub_delay;
 			udev->hub_delay = min_t(u32, delay,
@@ -5010,27 +5056,10 @@ hub_port_init(struct usb_hub *hub, struc
 	if (retval)
 		goto fail;

-	/*
-	 * Some superspeed devices have finished the link training process
-	 * and attached to a superspeed hub port, but the device descriptor
-	 * got from those devices show they aren't superspeed devices. Warm
-	 * reset the port attached by the devices can fix them.
-	 */
-	if ((udev->speed >= USB_SPEED_SUPER) &&
-			(le16_to_cpu(udev->descriptor.bcdUSB) < 0x0300)) {
-		dev_err(&udev->dev, "got a wrong device descriptor, "
-				"warm reset device\n");
-		hub_port_reset(hub, port1, udev,
-				HUB_BH_RESET_TIME, true);
-		retval = -EINVAL;
-		goto fail;
-	}
-
-	if (udev->descriptor.bMaxPacketSize0 == 0xff ||
-			udev->speed >= USB_SPEED_SUPER)
+	if (maxp0 == 0xff || udev->speed >= USB_SPEED_SUPER)
 		i = 512;
 	else
-		i = udev->descriptor.bMaxPacketSize0;
+		i = maxp0;
 	if (usb_endpoint_maxp(&udev->ep0.desc) != i) {
 		if (udev->speed == USB_SPEED_LOW ||
 				!(i == 8 || i == 16 || i == 32 || i == 64)) {
@@ -5046,13 +5075,33 @@ hub_port_init(struct usb_hub *hub, struc
 		usb_ep0_reinit(udev);
 	}

-	retval = usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE);
-	if (retval < (signed)sizeof(udev->descriptor)) {
+	descr = usb_get_device_descriptor(udev);
+	if (IS_ERR(descr)) {
+		retval = PTR_ERR(descr);
 		if (retval != -ENODEV)
 			dev_err(&udev->dev, "device descriptor read/all, error %d\n",
 					retval);
-		if (retval >= 0)
-			retval = -ENOMSG;
+		goto fail;
+	}
+	if (initial)
+		udev->descriptor = *descr;
+	else
+		*dev_descr = *descr;
+	kfree(descr);
+
+	/*
+	 * Some superspeed devices have finished the link training process
+	 * and attached to a superspeed hub port, but the device descriptor
+	 * got from those devices show they aren't superspeed devices. Warm
+	 * reset the port attached by the devices can fix them.
+	 */
+	if ((udev->speed >= USB_SPEED_SUPER) &&
+			(le16_to_cpu(udev->descriptor.bcdUSB) < 0x0300)) {
+		dev_err(&udev->dev, "got a wrong device descriptor, "
+				"warm reset device\n");
+		hub_port_reset(hub, port1, udev,
+				HUB_BH_RESET_TIME, true);
+		retval = -EINVAL;
 		goto fail;
 	}

@@ -5078,6 +5127,7 @@ fail:
 		hub_port_disable(hub, port1, 0);
 		update_devnum(udev, devnum);	/* for disconnect processing */
 	}
+	kfree(buf);
 	return retval;
 }

@@ -5158,7 +5208,7 @@ hub_power_remaining(struct usb_hub *hub)

 static int descriptors_changed(struct usb_device *udev,
-		struct usb_device_descriptor *old_device_descriptor,
+		struct usb_device_descriptor *new_device_descriptor,
 		struct usb_host_bos *old_bos)
 {
 	int		changed = 0;
@@ -5169,8 +5219,8 @@ static int descriptors_changed(struct us
 	int		length;
 	char		*buf;

-	if (memcmp(&udev->descriptor, old_device_descriptor,
-			sizeof(*old_device_descriptor)) != 0)
+	if (memcmp(&udev->descriptor, new_device_descriptor,
+			sizeof(*new_device_descriptor)) != 0)
 		return 1;

 	if ((old_bos && !udev->bos) || (!old_bos && udev->bos))
@@ -5348,7 +5398,7 @@ static void hub_port_connect(struct usb_
 		}

 		/* reset (non-USB 3.0 devices) and get descriptor */
-		status = hub_port_init(hub, udev, port1, i);
+		status = hub_port_init(hub, udev, port1, i, NULL);
 		if (status < 0)
 			goto loop;

@@ -5495,9 +5545,8 @@ static void hub_port_connect_change(stru
 {
 	struct usb_port *port_dev = hub->ports[port1 - 1];
 	struct usb_device *udev = port_dev->child;
-	struct usb_device_descriptor descriptor;
+	struct usb_device_descriptor *descr;
 	int status = -ENODEV;
-	int retval;

 	dev_dbg(&port_dev->dev, "status %04x, change %04x, %s\n", portstatus,
 			portchange, portspeed(hub, portstatus));
@@ -5524,23 +5573,20 @@ static void hub_port_connect_change(stru
 			 * changed device descriptors before resuscitating the
 			 * device.
 			 */
-			descriptor = udev->descriptor;
-			retval = usb_get_device_descriptor(udev,
-					sizeof(udev->descriptor));
-			if (retval < 0) {
+			descr = usb_get_device_descriptor(udev);
+			if (IS_ERR(descr)) {
 				dev_dbg(&udev->dev,
-						"can't read device descriptor %d\n",
-						retval);
+						"can't read device descriptor %ld\n",
+						PTR_ERR(descr));
 			} else {
-				if (descriptors_changed(udev, &descriptor,
+				if (descriptors_changed(udev, descr,
 						udev->bos)) {
 					dev_dbg(&udev->dev,
 							"device descriptor has changed\n");
-					/* for disconnect() calls */
-					udev->descriptor = descriptor;
 				} else {
 					status = 0; /* Nothing to do */
 				}
+				kfree(descr);
 			}
 #ifdef CONFIG_PM
 		} else if (udev->state == USB_STATE_SUSPENDED &&
@@ -5982,7 +6028,7 @@ static int usb_reset_and_verify_device(s
 	struct usb_device		*parent_hdev = udev->parent;
 	struct usb_hub			*parent_hub;
 	struct usb_hcd			*hcd = bus_to_hcd(udev->bus);
-	struct usb_device_descriptor	descriptor = udev->descriptor;
+	struct usb_device_descriptor	descriptor;
 	struct usb_host_bos		*bos;
 	int				i, j, ret = 0;
 	int				port1 = udev->portnum;
@@ -6018,7 +6064,7 @@ static int usb_reset_and_verify_device(s
 		/* ep0 maxpacket size may change; let the HCD know about it.
 		 * Other endpoints will be handled by re-enumeration. */
 		usb_ep0_reinit(udev);
-		ret = hub_port_init(parent_hub, udev, port1, i);
+		ret = hub_port_init(parent_hub, udev, port1, i, &descriptor);
 		if (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)
 			break;
 	}
@@ -6030,7 +6076,6 @@ static int usb_reset_and_verify_device(s
 	/* Device might have changed firmware (DFU or similar) */
 	if (descriptors_changed(udev, &descriptor, bos)) {
 		dev_info(&udev->dev, "device firmware changed\n");
-		udev->descriptor = descriptor;	/* for disconnect() calls */
 		goto re_enumerate;
 	}

Index: usb-devel/drivers/usb/core/hcd.c
===================================================================
--- usb-devel.orig/drivers/usb/core/hcd.c
+++ usb-devel/drivers/usb/core/hcd.c
@@ -983,6 +983,7 @@ static int register_root_hub(struct usb_
 {
 	struct device *parent_dev = hcd->self.controller;
 	struct usb_device *usb_dev = hcd->self.root_hub;
+	struct usb_device_descriptor *descr;
 	const int devnum = 1;
 	int retval;

@@ -994,13 +995,16 @@ static int register_root_hub(struct usb_
 	mutex_lock(&usb_bus_idr_lock);

 	usb_dev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);
-	retval = usb_get_device_descriptor(usb_dev, USB_DT_DEVICE_SIZE);
-	if (retval != sizeof usb_dev->descriptor) {
+	descr = usb_get_device_descriptor(usb_dev);
+	if (IS_ERR(descr)) {
+		retval = PTR_ERR(descr);
 		mutex_unlock(&usb_bus_idr_lock);
 		dev_dbg (parent_dev, "can't read %s device descriptor %d\n",
 				dev_name(&usb_dev->dev), retval);
-		return (retval < 0) ? retval : -EMSGSIZE;
+		return retval;
 	}
+	usb_dev->descriptor = *descr;
+	kfree(descr);

 	if (le16_to_cpu(usb_dev->descriptor.bcdUSB) >= 0x0201) {
 		retval = usb_get_bos_descriptor(usb_dev);
Index: usb-devel/drivers/usb/core/message.c
===================================================================
--- usb-devel.orig/drivers/usb/core/message.c
+++ usb-devel/drivers/usb/core/message.c
@@ -1040,40 +1040,35 @@ char *usb_cache_string(struct usb_device
 EXPORT_SYMBOL_GPL(usb_cache_string);

 /*
- * usb_get_device_descriptor - (re)reads the device descriptor (usbcore)
- * @dev: the device whose device descriptor is being updated
- * @size: how much of the descriptor to read
+ * usb_get_device_descriptor - read the device descriptor
+ * @udev: the device whose device descriptor should be read
  *
  * Context: task context, might sleep.
  *
- * Updates the copy of the device descriptor stored in the device structure,
- * which dedicates space for this purpose.
- *
  * Not exported, only for use by the core.  If drivers really want to read
  * the device descriptor directly, they can call usb_get_descriptor() with
  * type = USB_DT_DEVICE and index = 0.
  *
- * This call is synchronous, and may not be used in an interrupt context.
- *
- * Return: The number of bytes received on success, or else the status code
- * returned by the underlying usb_control_msg() call.
+ * Returns: a pointer to a dynamically allocated usb_device_descriptor
+ * structure (which the caller must deallocate), or an ERR_PTR value.
  */
-int usb_get_device_descriptor(struct usb_device *dev, unsigned int size)
+struct usb_device_descriptor *usb_get_device_descriptor(struct usb_device *udev)
 {
 	struct usb_device_descriptor *desc;
 	int ret;

-	if (size > sizeof(*desc))
-		return -EINVAL;
 	desc = kmalloc(sizeof(*desc), GFP_NOIO);
 	if (!desc)
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
+
+	ret = usb_get_descriptor(udev, USB_DT_DEVICE, 0, desc, sizeof(*desc));
+	if (ret == sizeof(*desc))
+		return desc;

-	ret = usb_get_descriptor(dev, USB_DT_DEVICE, 0, desc, size);
 	if (ret >= 0)
-		memcpy(&dev->descriptor, desc, size);
+		ret = -EMSGSIZE;
 	kfree(desc);
-	return ret;
+	return ERR_PTR(ret);
 }

 /*
Index: usb-devel/drivers/usb/core/usb.h
===================================================================
--- usb-devel.orig/drivers/usb/core/usb.h
+++ usb-devel/drivers/usb/core/usb.h
@@ -43,8 +43,8 @@ extern bool usb_endpoint_is_ignored(stru
 		struct usb_endpoint_descriptor *epd);
 extern int usb_remove_device(struct usb_device *udev);

-extern int usb_get_device_descriptor(struct usb_device *dev,
-		unsigned int size);
+extern struct usb_device_descriptor *usb_get_device_descriptor(
+		struct usb_device *udev);
 extern int usb_set_isoch_delay(struct usb_device *dev);
 extern int usb_get_bos_descriptor(struct usb_device *dev);
 extern void usb_release_bos_descriptor(struct usb_device *dev);

[^](#m51a496d4914a8b0c2cf0a20d2be4c53e66789254) [permalink](../../c9bb72e0-8e02-4568-bd43-6897f9c94d12%40rowland.harvard.edu/) [raw](../../c9bb72e0-8e02-4568-bd43-6897f9c94d12%40rowland.harvard.edu/raw) [reply](../../c9bb72e0-8e02-4568-bd43-6897f9c94d12%40rowland.harvard.edu/#R)	[[flat](../../c9bb72e0-8e02-4568-bd43-6897f9c94d12%40rowland.harvard.edu/T/#u)|[nested](../../c9bb72e0-8e02-4568-bd43-6897f9c94d12%40rowland.harvard.edu/t/#u)] [15+ messages in thread](#r51a496d4914a8b0c2cf0a20d2be4c53e66789254)
```

---

```
[*](#ecbd7d76466d9dfc8915d25e66f4e68adedcdbc12) Re: [syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)
  2023-07-25 19:26             ` [Alan Stern](#m51a496d4914a8b0c2cf0a20d2be4c53e66789254)
@ 2023-07-25 20:42               ` Khazhy Kumykov
  2023-07-25 21:30                 ` [Alan Stern](#m0e507d1cb7470200f8b847a36a69846c0c6faa54)
  2023-07-25 20:54               ` [syzbot](#mb60707f27ed3bcbc25254759aff11ea6ab273c2a)
  [1 sibling, 1 reply; 15+ messages in thread](#rcbd7d76466d9dfc8915d25e66f4e68adedcdbc12)
From: Khazhy Kumykov @ 2023-07-25 20:42 UTC ([permalink](../../CACGdZYL_dPFp-yHWHGC3vxyv4R4dYtSJe5GPcN0NjG2qaz%2Bxmg%40mail.gmail.com/) / [raw](../../CACGdZYL_dPFp-yHWHGC3vxyv4R4dYtSJe5GPcN0NjG2qaz%2Bxmg%40mail.gmail.com/raw))
  To: Alan Stern; +Cc: syzbot, gregkh, [linux-kernel](../../../lkml/?t=20230725204304), [linux-usb](../../../linux-usb/?t=20230725204304), syzkaller-bugs

[[-- Attachment #1: Type: text/plain, Size: 30748 bytes --]](../../CACGdZYL_dPFp-yHWHGC3vxyv4R4dYtSJe5GPcN0NjG2qaz%2Bxmg%40mail.gmail.com/1-a.txt)

On Tue, Jul 25, 2023 at 12:26PM Alan Stern <stern@rowland.harvard.edu> wrote:
>
> On Sat, Jul 22, 2023 at 07:21:23PM -0700, syzbot wrote:
> > Hello,
> >
> > syzbot has tested the proposed patch and the reproducer did not trigger any issue:
> >
> > Reported-and-tested-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com
>
> Here's a revised version of the patch, with some mistakes fixed.  If
> this works, I'll split it into three parts and submit them.
>
> Alan Stern
>
> #syz test: <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/> v6.5-rc3
>
> Index: usb-devel/drivers/usb/core/hub.c
> ===================================================================
> --- usb-devel.orig/drivers/usb/core/hub.c
> +++ usb-devel/drivers/usb/core/hub.c
> @@ -2671,12 +2671,17 @@ int usb_authorize_device(struct usb_devi
>         }
>
>         if (usb_dev->wusb) {
> -               result = usb_get_device_descriptor(usb_dev, sizeof(usb_dev->descriptor));
> -               if (result < 0) {
> +               struct usb_device_descriptor *descr;
> +
> +               descr = usb_get_device_descriptor(usb_dev);
> +               if (IS_ERR(descr)) {
> +                       result = PTR_ERR(descr);
>                         dev_err(&usb_dev->dev, "can't re-read device descriptor for "
>                                 "authorization: %d\n", result);
>                         goto error_device_descriptor;
>                 }
> +               usb_dev->descriptor = *descr;
Hmm, in your first patch you rejected diffs to the descriptor here,
which might be necessary - since we don't re-initialize the device so
can get a similar issue if the bad usb device decides to change
bNumConfigurations to cause a buffer overrun. (This also stuck out to
me as an exception to the "descriptors should be immutable" comment
later in the patch.
> +               kfree(descr);
>         }
>
>         usb_dev->authorized = 1;
> @@ -4718,6 +4723,67 @@ static int hub_enable_device(struct usb_
>         return hcd->driver->enable_device(hcd, udev);
>  }
>
> +/*
> + * Get the bMaxPacketSize0 value during initialization by reading the
> + * device's device descriptor.  Since we don't already know this value,
> + * the transfer is unsafe and it ignores I/O errors, only testing for
> + * reasonable received values.
> + *
> + * For "old scheme" initialization size will be 8, so we read just the
> + * start of the device descriptor, which should work okay regardless of
> + * the actual bMaxPacketSize0 value.  For "new scheme" initialization,
> + * size will be 64 (and buf will point to a sufficiently large buffer),
> + * which might not be kosher according to the USB spec but it's what
> + * Windows does and what many devices expect.
> + *
> + * Returns bMaxPacketSize0 or a negative error code.
> + */
> +static int get_bMaxPacketSize0(struct usb_device *udev,
> +               struct usb_device_descriptor *buf, int size, bool first_time)
> +{
> +       int i, rc;
> +
> +       /*
> +        * Retry on all errors; some devices are flakey.
> +        * 255 is for WUSB devices, we actually need to use
> +        * 512 (WUSB1.0[4.8.1]).
> +        */
> +       for (i = 0; i < GET_MAXPACKET0_TRIES; ++i) {
> +               /* Start with invalid values in case the transfer fails */
> +               buf->bDescriptorType = buf->bMaxPacketSize0 = 0;
> +               rc = usb_control_msg(udev, usb_rcvaddr0pipe(),
> +                               USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
> +                               USB_DT_DEVICE << 8, 0,
> +                               buf, size,
> +                               initial_descriptor_timeout);
> +               switch (buf->bMaxPacketSize0) {
> +               case 8: case 16: case 32: case 64: case 255:
> +                       if (buf->bDescriptorType == USB_DT_DEVICE) {
> +                               rc = buf->bMaxPacketSize0;
> +                               break;
> +                       }
> +                       fallthrough;
> +               default:
> +                       if (rc >= 0)
> +                               rc = -EPROTO;
> +                       break;
> +               }
> +
> +               /*
> +                * Some devices time out if they are powered on
> +                * when already connected. They need a second
> +                * reset, so return early. But only on the first
> +                * attempt, lest we get into a time-out/reset loop.
> +                */
> +               if (rc > 0 || (rc == -ETIMEDOUT && first_time &&
> +                               udev->speed > USB_SPEED_FULL))
> +                       break;
> +       }
> +       return rc;
> +}
> +
> +#define GET_DESCRIPTOR_BUFSIZE 64
> +
>  /* Reset device, (re)assign address, get device descriptor.
>   * Device connection must be stable, no more debouncing needed.
>   * Returns device in USB_STATE_ADDRESS, except on error.
> @@ -4727,10 +4793,17 @@ static int hub_enable_device(struct usb_
>   * the port lock.  For a newly detected device that is not accessible
>   * through any global pointers, it's not necessary to lock the device,
>   * but it is still necessary to lock the port.
> + *
> + * For a newly detected device, @dev_descr must be NULL.  The device
> + * descriptor retrieved from the device will then be stored in
> + * @udev->descriptor.  For an already existing device, @dev_descr
> + * must be non-NULL.  The device descriptor will be stored there,
> + * not in @udev->descriptor, because descriptors for registered
> + * devices are meant to be immutable.
>   */
>  static int
>  hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
> -               int retry_counter)
> +               int retry_counter, struct usb_device_descriptor *dev_descr)
>  {
>         struct usb_device       *hdev = hub->hdev;
>         struct usb_hcd          *hcd = bus_to_hcd(hdev->bus);
> @@ -4742,6 +4815,13 @@ hub_port_init(struct usb_hub *hub, struc
>         int                     devnum = udev->devnum;
>         const char              *driver_name;
>         bool                    do_new_scheme;
> +       const bool              initial = !dev_descr;
> +       int                     maxp0;
> +       struct usb_device_descriptor    *buf, *descr;
> +
> +       buf = kmalloc(GET_DESCRIPTOR_BUFSIZE, GFP_NOIO);
> +       if (!buf)
> +               return -ENOMEM;
>
>         /* root hub ports have a slightly longer reset period
>          * (from USB 2.0 spec, section 7.1.7.5)
> @@ -4774,32 +4854,34 @@ hub_port_init(struct usb_hub *hub, struc
>         }
>         oldspeed = udev->speed;
>
> -       /* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...
> -        * it's fixed size except for full speed devices.
> -        * For Wireless USB devices, ep0 max packet is always 512 (tho
> -        * reported as 0xff in the device descriptor). WUSB1.0[4.8.1].
> -        */
> -       switch (udev->speed) {
> -       case USB_SPEED_SUPER_PLUS:
> -       case USB_SPEED_SUPER:
> -       case USB_SPEED_WIRELESS:        /* fixed at 512 */
> -               udev->ep0.desc.wMaxPacketSize = cpu_to_le16(512);
> -               break;
> -       case USB_SPEED_HIGH:            /* fixed at 64 */
> -               udev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);
> -               break;
> -       case USB_SPEED_FULL:            /* 8, 16, 32, or 64 */
> -               /* to determine the ep0 maxpacket size, try to read
> -                * the device descriptor to get bMaxPacketSize0 and
> -                * then correct our initial guess.
> -                */
> -               udev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);
> -               break;
> -       case USB_SPEED_LOW:             /* fixed at 8 */
> -               udev->ep0.desc.wMaxPacketSize = cpu_to_le16(8);
> -               break;
> -       default:
> -               goto fail;
> +       if (initial) {
> +               /* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...
> +                * it's fixed size except for full speed devices.
> +                * For Wireless USB devices, ep0 max packet is always 512 (tho
> +                * reported as 0xff in the device descriptor). WUSB1.0[4.8.1].
> +                */
> +               switch (udev->speed) {
> +               case USB_SPEED_SUPER_PLUS:
> +               case USB_SPEED_SUPER:
> +               case USB_SPEED_WIRELESS:        /* fixed at 512 */
> +                       udev->ep0.desc.wMaxPacketSize = cpu_to_le16(512);
> +                       break;
> +               case USB_SPEED_HIGH:            /* fixed at 64 */
> +                       udev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);
> +                       break;
> +               case USB_SPEED_FULL:            /* 8, 16, 32, or 64 */
> +                       /* to determine the ep0 maxpacket size, try to read
> +                        * the device descriptor to get bMaxPacketSize0 and
> +                        * then correct our initial guess.
> +                        */
> +                       udev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);
> +                       break;
> +               case USB_SPEED_LOW:             /* fixed at 8 */
> +                       udev->ep0.desc.wMaxPacketSize = cpu_to_le16(8);
> +                       break;
> +               default:
> +                       goto fail;
> +               }
>         }
>
>         if (udev->speed == USB_SPEED_WIRELESS)
> @@ -4822,22 +4904,24 @@ hub_port_init(struct usb_hub *hub, struc
>         if (udev->speed < USB_SPEED_SUPER)
>                 dev_info(&udev->dev,
>                                 "%s %s USB device number %d using %s\n",
> -                               (udev->config) ? "reset" : "new", speed,
> +                               (initial ? "new" : "reset"), speed,
>                                 devnum, driver_name);
>
> -       /* Set up TT records, if needed  */
> -       if (hdev->tt) {
> -               udev->tt = hdev->tt;
> -               udev->ttport = hdev->ttport;
> -       } else if (udev->speed != USB_SPEED_HIGH
> -                       && hdev->speed == USB_SPEED_HIGH) {
> -               if (!hub->tt.hub) {
> -                       dev_err(&udev->dev, "parent hub has no TT\n");
> -                       retval = -EINVAL;
> -                       goto fail;
> +       if (initial) {
> +               /* Set up TT records, if needed  */
> +               if (hdev->tt) {
> +                       udev->tt = hdev->tt;
> +                       udev->ttport = hdev->ttport;
> +               } else if (udev->speed != USB_SPEED_HIGH
> +                               && hdev->speed == USB_SPEED_HIGH) {
> +                       if (!hub->tt.hub) {
> +                               dev_err(&udev->dev, "parent hub has no TT\n");
> +                               retval = -EINVAL;
> +                               goto fail;
> +                       }
> +                       udev->tt = &hub->tt;
> +                       udev->ttport = port1;
>                 }
> -               udev->tt = &hub->tt;
> -               udev->ttport = port1;
>         }
>
>         /* Why interleave GET_DESCRIPTOR and SET_ADDRESS this way?
> @@ -4861,9 +4945,6 @@ hub_port_init(struct usb_hub *hub, struc
>                 }
>
>                 if (do_new_scheme) {
> -                       struct usb_device_descriptor *buf;
> -                       int r = 0;
> -
>                         retval = hub_enable_device(udev);
>                         if (retval < 0) {
>                                 dev_err(&udev->dev,
> @@ -4872,52 +4953,14 @@ hub_port_init(struct usb_hub *hub, struc
>                                 goto fail;
>                         }
>
> -#define GET_DESCRIPTOR_BUFSIZE 64
> -                       buf = kmalloc(GET_DESCRIPTOR_BUFSIZE, GFP_NOIO);
> -                       if (!buf) {
> -                               retval = -ENOMEM;
> -                               continue;
> -                       }
> -
> -                       /* Retry on all errors; some devices are flakey.
> -                        * 255 is for WUSB devices, we actually need to use
> -                        * 512 (WUSB1.0[4.8.1]).
> -                        */
> -                       for (operations = 0; operations < GET_MAXPACKET0_TRIES;
> -                                       ++operations) {
> -                               buf->bMaxPacketSize0 = 0;
> -                               r = usb_control_msg(udev, usb_rcvaddr0pipe(),
> -                                       USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
> -                                       USB_DT_DEVICE << 8, 0,
> -                                       buf, GET_DESCRIPTOR_BUFSIZE,
> -                                       initial_descriptor_timeout);
> -                               switch (buf->bMaxPacketSize0) {
> -                               case 8: case 16: case 32: case 64: case 255:
> -                                       if (buf->bDescriptorType ==
> -                                                       USB_DT_DEVICE) {
> -                                               r = 0;
> -                                               break;
> -                                       }
> -                                       fallthrough;
> -                               default:
> -                                       if (r == 0)
> -                                               r = -EPROTO;
> -                                       break;
> -                               }
> -                               /*
> -                                * Some devices time out if they are powered on
> -                                * when already connected. They need a second
> -                                * reset. But only on the first attempt,
> -                                * lest we get into a time out/reset loop
> -                                */
> -                               if (r == 0 || (r == -ETIMEDOUT &&
> -                                               retries == 0 &&
> -                                               udev->speed > USB_SPEED_FULL))
> -                                       break;
> +                       maxp0 = get_bMaxPacketSize0(udev, buf,
> +                                       GET_DESCRIPTOR_BUFSIZE, retries == 0);
> +                       if (maxp0 > 0 && !initial &&
> +                                       maxp0 != udev->descriptor.bMaxPacketSize0) {
> +                               dev_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");
> +                               retval = -ENODEV;
> +                               goto fail;
>                         }
> -                       udev->descriptor.bMaxPacketSize0 =
> -                                       buf->bMaxPacketSize0;
> -                       kfree(buf);
>
>                         retval = hub_port_reset(hub, port1, udev, delay, false);
>                         if (retval < 0)         /* error or disconnect */
> @@ -4928,14 +4971,13 @@ hub_port_init(struct usb_hub *hub, struc
>                                 retval = -ENODEV;
>                                 goto fail;
>                         }
> -                       if (r) {
> -                               if (r != -ENODEV)
> +                       if (maxp0 < 0) {
> +                               if (maxp0 != -ENODEV)
>                                         dev_err(&udev->dev, "device descriptor read/64, error %d\n",
> -                                                       r);
> -                               retval = -EMSGSIZE;
> +                                                       maxp0);
> +                               retval = maxp0;
>                                 continue;
>                         }
> -#undef GET_DESCRIPTOR_BUFSIZE
>                 }
>
>                 /*
> @@ -4981,18 +5023,22 @@ hub_port_init(struct usb_hub *hub, struc
>                                 break;
>                 }
>
> -               retval = usb_get_device_descriptor(udev, 8);
> -               if (retval < 8) {
> +               /* !do_new_scheme || wusb */
> +               maxp0 = get_bMaxPacketSize0(udev, buf, 8, retries == 0);
> +               if (maxp0 < 0) {
> +                       retval = maxp0;
>                         if (retval != -ENODEV)
>                                 dev_err(&udev->dev,
>                                         "device descriptor read/8, error %d\n",
>                                         retval);
> -                       if (retval >= 0)
> -                               retval = -EMSGSIZE;
>                 } else {
>                         u32 delay;
>
> -                       retval = 0;
> +                       if (!initial && maxp0 != udev->descriptor.bMaxPacketSize0) {
> +                               dev_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");
> +                               retval = -ENODEV;
> +                               goto fail;
> +                       }
>
>                         delay = udev->parent->hub_delay;
>                         udev->hub_delay = min_t(u32, delay,
> @@ -5010,27 +5056,10 @@ hub_port_init(struct usb_hub *hub, struc
>         if (retval)
>                 goto fail;
>
> -       /*
> -        * Some superspeed devices have finished the link training process
> -        * and attached to a superspeed hub port, but the device descriptor
> -        * got from those devices show they aren't superspeed devices. Warm
> -        * reset the port attached by the devices can fix them.
> -        */
> -       if ((udev->speed >= USB_SPEED_SUPER) &&
> -                       (le16_to_cpu(udev->descriptor.bcdUSB) < 0x0300)) {
> -               dev_err(&udev->dev, "got a wrong device descriptor, "
> -                               "warm reset device\n");
> -               hub_port_reset(hub, port1, udev,
> -                               HUB_BH_RESET_TIME, true);
> -               retval = -EINVAL;
> -               goto fail;
> -       }
> -
> -       if (udev->descriptor.bMaxPacketSize0 == 0xff ||
> -                       udev->speed >= USB_SPEED_SUPER)
> +       if (maxp0 == 0xff || udev->speed >= USB_SPEED_SUPER)
>                 i = 512;
>         else
> -               i = udev->descriptor.bMaxPacketSize0;
> +               i = maxp0;
>         if (usb_endpoint_maxp(&udev->ep0.desc) != i) {
>                 if (udev->speed == USB_SPEED_LOW ||
>                                 !(i == 8 || i == 16 || i == 32 || i == 64)) {
> @@ -5046,13 +5075,33 @@ hub_port_init(struct usb_hub *hub, struc
>                 usb_ep0_reinit(udev);
>         }
>
> -       retval = usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE);
> -       if (retval < (signed)sizeof(udev->descriptor)) {
> +       descr = usb_get_device_descriptor(udev);
> +       if (IS_ERR(descr)) {
> +               retval = PTR_ERR(descr);
>                 if (retval != -ENODEV)
>                         dev_err(&udev->dev, "device descriptor read/all, error %d\n",
>                                         retval);
> -               if (retval >= 0)
> -                       retval = -ENOMSG;
> +               goto fail;
> +       }
> +       if (initial)
> +               udev->descriptor = *descr;
> +       else
> +               *dev_descr = *descr;
> +       kfree(descr);
> +
> +       /*
> +        * Some superspeed devices have finished the link training process
> +        * and attached to a superspeed hub port, but the device descriptor
> +        * got from those devices show they aren't superspeed devices. Warm
> +        * reset the port attached by the devices can fix them.
> +        */
> +       if ((udev->speed >= USB_SPEED_SUPER) &&
> +                       (le16_to_cpu(udev->descriptor.bcdUSB) < 0x0300)) {
> +               dev_err(&udev->dev, "got a wrong device descriptor, "
> +                               "warm reset device\n");
> +               hub_port_reset(hub, port1, udev,
> +                               HUB_BH_RESET_TIME, true);
> +               retval = -EINVAL;
>                 goto fail;
>         }
>
> @@ -5078,6 +5127,7 @@ fail:
>                 hub_port_disable(hub, port1, 0);
>                 update_devnum(udev, devnum);    /* for disconnect processing */
>         }
> +       kfree(buf);
>         return retval;
>  }
>
> @@ -5158,7 +5208,7 @@ hub_power_remaining(struct usb_hub *hub)
>
>
>  static int descriptors_changed(struct usb_device *udev,
> -               struct usb_device_descriptor *old_device_descriptor,
> +               struct usb_device_descriptor *new_device_descriptor,
>                 struct usb_host_bos *old_bos)
>  {
>         int             changed = 0;
> @@ -5169,8 +5219,8 @@ static int descriptors_changed(struct us
>         int             length;
>         char            *buf;
>
> -       if (memcmp(&udev->descriptor, old_device_descriptor,
> -                       sizeof(*old_device_descriptor)) != 0)
> +       if (memcmp(&udev->descriptor, new_device_descriptor,
> +                       sizeof(*new_device_descriptor)) != 0)
>                 return 1;
>
>         if ((old_bos && !udev->bos) || (!old_bos && udev->bos))
> @@ -5348,7 +5398,7 @@ static void hub_port_connect(struct usb_
>                 }
>
>                 /* reset (non-USB 3.0 devices) and get descriptor */
> -               status = hub_port_init(hub, udev, port1, i);
> +               status = hub_port_init(hub, udev, port1, i, NULL);
>                 if (status < 0)
>                         goto loop;
>
> @@ -5495,9 +5545,8 @@ static void hub_port_connect_change(stru
>  {
>         struct usb_port *port_dev = hub->ports[port1 - 1];
>         struct usb_device *udev = port_dev->child;
> -       struct usb_device_descriptor descriptor;
> +       struct usb_device_descriptor *descr;
>         int status = -ENODEV;
> -       int retval;
>
>         dev_dbg(&port_dev->dev, "status %04x, change %04x, %s\n", portstatus,
>                         portchange, portspeed(hub, portstatus));
> @@ -5524,23 +5573,20 @@ static void hub_port_connect_change(stru
>                          * changed device descriptors before resuscitating the
>                          * device.
>                          */
> -                       descriptor = udev->descriptor;
> -                       retval = usb_get_device_descriptor(udev,
> -                                       sizeof(udev->descriptor));
> -                       if (retval < 0) {
> +                       descr = usb_get_device_descriptor(udev);
> +                       if (IS_ERR(descr)) {
>                                 dev_dbg(&udev->dev,
> -                                               "can't read device descriptor %d\n",
> -                                               retval);
> +                                               "can't read device descriptor %ld\n",
> +                                               PTR_ERR(descr));
>                         } else {
> -                               if (descriptors_changed(udev, &descriptor,
> +                               if (descriptors_changed(udev, descr,
>                                                 udev->bos)) {
>                                         dev_dbg(&udev->dev,
>                                                         "device descriptor has changed\n");
> -                                       /* for disconnect() calls */
> -                                       udev->descriptor = descriptor;
>                                 } else {
>                                         status = 0; /* Nothing to do */
>                                 }
> +                               kfree(descr);
>                         }
>  #ifdef CONFIG_PM
>                 } else if (udev->state == USB_STATE_SUSPENDED &&
> @@ -5982,7 +6028,7 @@ static int usb_reset_and_verify_device(s
>         struct usb_device               *parent_hdev = udev->parent;
>         struct usb_hub                  *parent_hub;
>         struct usb_hcd                  *hcd = bus_to_hcd(udev->bus);
> -       struct usb_device_descriptor    descriptor = udev->descriptor;
> +       struct usb_device_descriptor    descriptor;
>         struct usb_host_bos             *bos;
>         int                             i, j, ret = 0;
>         int                             port1 = udev->portnum;
> @@ -6018,7 +6064,7 @@ static int usb_reset_and_verify_device(s
>                 /* ep0 maxpacket size may change; let the HCD know about it.
>                  * Other endpoints will be handled by re-enumeration. */
>                 usb_ep0_reinit(udev);
> -               ret = hub_port_init(parent_hub, udev, port1, i);
> +               ret = hub_port_init(parent_hub, udev, port1, i, &descriptor);
Looks like this is the only caller that passes &descriptor, and it
just checks that it didn't change. Would it make sense to put the
enitre descriptors_changed stanza in hub_port_init, for the re-init
case?

>                 if (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)
>                         break;
>         }
> @@ -6030,7 +6076,6 @@ static int usb_reset_and_verify_device(s
>         /* Device might have changed firmware (DFU or similar) */
>         if (descriptors_changed(udev, &descriptor, bos)) {
>                 dev_info(&udev->dev, "device firmware changed\n");
> -               udev->descriptor = descriptor;  /* for disconnect() calls */
>                 goto re_enumerate;
>         }
>
> Index: usb-devel/drivers/usb/core/hcd.c
> ===================================================================
> --- usb-devel.orig/drivers/usb/core/hcd.c
> +++ usb-devel/drivers/usb/core/hcd.c
> @@ -983,6 +983,7 @@ static int register_root_hub(struct usb_
>  {
>         struct device *parent_dev = hcd->self.controller;
>         struct usb_device *usb_dev = hcd->self.root_hub;
> +       struct usb_device_descriptor *descr;
>         const int devnum = 1;
>         int retval;
>
> @@ -994,13 +995,16 @@ static int register_root_hub(struct usb_
>         mutex_lock(&usb_bus_idr_lock);
>
>         usb_dev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);
> -       retval = usb_get_device_descriptor(usb_dev, USB_DT_DEVICE_SIZE);
> -       if (retval != sizeof usb_dev->descriptor) {
> +       descr = usb_get_device_descriptor(usb_dev);
> +       if (IS_ERR(descr)) {
> +               retval = PTR_ERR(descr);
>                 mutex_unlock(&usb_bus_idr_lock);
>                 dev_dbg (parent_dev, "can't read %s device descriptor %d\n",
>                                 dev_name(&usb_dev->dev), retval);
> -               return (retval < 0) ? retval : -EMSGSIZE;
> +               return retval;
>         }
> +       usb_dev->descriptor = *descr;
> +       kfree(descr);
>
>         if (le16_to_cpu(usb_dev->descriptor.bcdUSB) >= 0x0201) {
>                 retval = usb_get_bos_descriptor(usb_dev);
> Index: usb-devel/drivers/usb/core/message.c
> ===================================================================
> --- usb-devel.orig/drivers/usb/core/message.c
> +++ usb-devel/drivers/usb/core/message.c
> @@ -1040,40 +1040,35 @@ char *usb_cache_string(struct usb_device
>  EXPORT_SYMBOL_GPL(usb_cache_string);
>
>  /*
> - * usb_get_device_descriptor - (re)reads the device descriptor (usbcore)
> - * @dev: the device whose device descriptor is being updated
> - * @size: how much of the descriptor to read
> + * usb_get_device_descriptor - read the device descriptor
> + * @udev: the device whose device descriptor should be read
>   *
>   * Context: task context, might sleep.
>   *
> - * Updates the copy of the device descriptor stored in the device structure,
> - * which dedicates space for this purpose.
> - *
>   * Not exported, only for use by the core.  If drivers really want to read
>   * the device descriptor directly, they can call usb_get_descriptor() with
>   * type = USB_DT_DEVICE and index = 0.
>   *
> - * This call is synchronous, and may not be used in an interrupt context.
> - *
> - * Return: The number of bytes received on success, or else the status code
> - * returned by the underlying usb_control_msg() call.
> + * Returns: a pointer to a dynamically allocated usb_device_descriptor
> + * structure (which the caller must deallocate), or an ERR_PTR value.
>   */
> -int usb_get_device_descriptor(struct usb_device *dev, unsigned int size)
> +struct usb_device_descriptor *usb_get_device_descriptor(struct usb_device *udev)
>  {
>         struct usb_device_descriptor *desc;
>         int ret;
>
> -       if (size > sizeof(*desc))
> -               return -EINVAL;
>         desc = kmalloc(sizeof(*desc), GFP_NOIO);
>         if (!desc)
> -               return -ENOMEM;
> +               return ERR_PTR(-ENOMEM);
> +
> +       ret = usb_get_descriptor(udev, USB_DT_DEVICE, 0, desc, sizeof(*desc));
> +       if (ret == sizeof(*desc))
> +               return desc;
>
> -       ret = usb_get_descriptor(dev, USB_DT_DEVICE, 0, desc, size);
>         if (ret >= 0)
> -               memcpy(&dev->descriptor, desc, size);
> +               ret = -EMSGSIZE;
>         kfree(desc);
> -       return ret;
> +       return ERR_PTR(ret);
>  }
>
>  /*
> Index: usb-devel/drivers/usb/core/usb.h
> ===================================================================
> --- usb-devel.orig/drivers/usb/core/usb.h
> +++ usb-devel/drivers/usb/core/usb.h
> @@ -43,8 +43,8 @@ extern bool usb_endpoint_is_ignored(stru
>                 struct usb_endpoint_descriptor *epd);
>  extern int usb_remove_device(struct usb_device *udev);
>
> -extern int usb_get_device_descriptor(struct usb_device *dev,
> -               unsigned int size);
> +extern struct usb_device_descriptor *usb_get_device_descriptor(
> +               struct usb_device *udev);
>  extern int usb_set_isoch_delay(struct usb_device *dev);
>  extern int usb_get_bos_descriptor(struct usb_device *dev);
>  extern void usb_release_bos_descriptor(struct usb_device *dev);

[[-- Attachment #2: S/MIME Cryptographic Signature --]
[-- Type: application/pkcs7-signature, Size: 3999 bytes --]](../../CACGdZYL_dPFp-yHWHGC3vxyv4R4dYtSJe5GPcN0NjG2qaz%2Bxmg%40mail.gmail.com/2-smime.p7s)

[^](#mcbd7d76466d9dfc8915d25e66f4e68adedcdbc12) [permalink](../../CACGdZYL_dPFp-yHWHGC3vxyv4R4dYtSJe5GPcN0NjG2qaz%2Bxmg%40mail.gmail.com/) [raw](../../CACGdZYL_dPFp-yHWHGC3vxyv4R4dYtSJe5GPcN0NjG2qaz%2Bxmg%40mail.gmail.com/raw) [reply](../../CACGdZYL_dPFp-yHWHGC3vxyv4R4dYtSJe5GPcN0NjG2qaz%2Bxmg%40mail.gmail.com/#R)	[[flat](../../CACGdZYL_dPFp-yHWHGC3vxyv4R4dYtSJe5GPcN0NjG2qaz%2Bxmg%40mail.gmail.com/T/#u)|[nested](../../CACGdZYL_dPFp-yHWHGC3vxyv4R4dYtSJe5GPcN0NjG2qaz%2Bxmg%40mail.gmail.com/t/#u)] [15+ messages in thread](#rcbd7d76466d9dfc8915d25e66f4e68adedcdbc12)
```

---

```
[*](#eb60707f27ed3bcbc25254759aff11ea6ab273c2a) Re: [syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)
  2023-07-25 19:26             ` [Alan Stern](#m51a496d4914a8b0c2cf0a20d2be4c53e66789254)
  2023-07-25 20:42               ` [Khazhy Kumykov](#mcbd7d76466d9dfc8915d25e66f4e68adedcdbc12)
@ 2023-07-25 20:54               ` syzbot
  [1 sibling, 0 replies; 15+ messages in thread](#rb60707f27ed3bcbc25254759aff11ea6ab273c2a)
From: syzbot @ 2023-07-25 20:54 UTC ([permalink](../../00000000000000276a060155f0a5%40google.com/) / [raw](../../00000000000000276a060155f0a5%40google.com/raw))
  To: gregkh, khazhy, [linux-kernel](../../../lkml/?t=20230725205434), [linux-usb](../../../linux-usb/?t=20230725205434), stern, syzkaller-bugs

Hello,

syzbot has tested the proposed patch and the reproducer did not trigger any issue:

Reported-and-tested-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com

Tested on:

commit:         6eaae198 Linux 6.5-rc3
git tree:       <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/> v6.5-rc3
console output: <https://syzkaller.appspot.com/x/log.txt?x=13d77b76a80000>
kernel config:  <https://syzkaller.appspot.com/x/.config?x=c7b1aac4a6659b6d>
dashboard link: <https://syzkaller.appspot.com/bug?extid=18996170f8096c6174d0>
compiler:       gcc (Debian 12.2.0-14) 12.2.0, GNU ld (GNU Binutils for Debian) 2.40
patch:          <https://syzkaller.appspot.com/x/patch.diff?x=1339684aa80000>

Note: testing is done by a robot and is best-effort only.

[^](#mb60707f27ed3bcbc25254759aff11ea6ab273c2a) [permalink](../../00000000000000276a060155f0a5%40google.com/) [raw](../../00000000000000276a060155f0a5%40google.com/raw) [reply](../../00000000000000276a060155f0a5%40google.com/#R)	[[flat](../../00000000000000276a060155f0a5%40google.com/T/#u)|[nested](../../00000000000000276a060155f0a5%40google.com/t/#u)] [15+ messages in thread](#rb60707f27ed3bcbc25254759aff11ea6ab273c2a)
```

---

```
[*](#e0e507d1cb7470200f8b847a36a69846c0c6faa54) Re: [syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)
  2023-07-25 20:42               ` [Khazhy Kumykov](#mcbd7d76466d9dfc8915d25e66f4e68adedcdbc12)
@ 2023-07-25 21:30                 ` Alan Stern
  2023-07-25 21:46                   ` [Khazhy Kumykov](#m3ec14338733450f5ede31989d68022d0700554a0)
  [0 siblings, 1 reply; 15+ messages in thread](#r0e507d1cb7470200f8b847a36a69846c0c6faa54)
From: Alan Stern @ 2023-07-25 21:30 UTC ([permalink](../../248d9759-aef7-45ce-b0a4-6c1cafee76c9%40rowland.harvard.edu/) / [raw](../../248d9759-aef7-45ce-b0a4-6c1cafee76c9%40rowland.harvard.edu/raw))
  To: Khazhy Kumykov; +Cc: syzbot, gregkh, [linux-kernel](../../../lkml/?t=20230725213054), [linux-usb](../../../linux-usb/?t=20230725213054), syzkaller-bugs

On Tue, Jul 25, 2023 at 01:42:01PM -0700, Khazhy Kumykov wrote:
> On Tue, Jul 25, 2023 at 12:26PM Alan Stern <stern@rowland.harvard.edu> wrote:

> > @@ -2671,12 +2671,17 @@ int usb_authorize_device(struct usb_devi
> >         }
> >
> >         if (usb_dev->wusb) {
> > -               result = usb_get_device_descriptor(usb_dev, sizeof(usb_dev->descriptor));
> > -               if (result < 0) {
> > +               struct usb_device_descriptor *descr;
> > +
> > +               descr = usb_get_device_descriptor(usb_dev);
> > +               if (IS_ERR(descr)) {
> > +                       result = PTR_ERR(descr);
> >                         dev_err(&usb_dev->dev, "can't re-read device descriptor for "
> >                                 "authorization: %d\n", result);
> >                         goto error_device_descriptor;
> >                 }
> > +               usb_dev->descriptor = *descr;
> Hmm, in your first patch you rejected diffs to the descriptor here,
> which might be necessary - since we don't re-initialize the device so
> can get a similar issue if the bad usb device decides to change
> bNumConfigurations to cause a buffer overrun. (This also stuck out to
> me as an exception to the "descriptors should be immutable" comment
> later in the patch.

I removed that part of the previous patch because there's no point to
it.  None of this code ever gets executed; the usb_dev->wusb test can
never succeed because the kernel doesn't support wireless USB any more.
(I asked Greg KH about that in a separate email thread:
<[https://lore.kernel.org/linux-usb/2a21cefa-99a7-497c-901f-3ea097361a80@rowland.harvard.edu/#r](https://lore.kernel.org/linux-usb/2a21cefa-99a7-497c-901f-3ea097361a80%40rowland.harvard.edu/#r)>.)

A later patch will remove all of the wireless USB stuff.  The only real
reason for leaving this much of the code there now is to prevent
compilation errors and keep the form looking right.

> > @@ -6018,7 +6064,7 @@ static int usb_reset_and_verify_device(s
> >                 /* ep0 maxpacket size may change; let the HCD know about it.
> >                  * Other endpoints will be handled by re-enumeration. */
> >                 usb_ep0_reinit(udev);
> > -               ret = hub_port_init(parent_hub, udev, port1, i);
> > +               ret = hub_port_init(parent_hub, udev, port1, i, &descriptor);
> Looks like this is the only caller that passes &descriptor, and it
> just checks that it didn't change. Would it make sense to put the
> enitre descriptors_changed stanza in hub_port_init, for the re-init
> case?

The descriptors_changed check has to be _somewhere_, either here or
there.  I don't see what difference it makes whether the check is done
in this routine or in hub_port_init.  Since it doesn't matter, why
change the existing code?

Alan Stern

[^](#m0e507d1cb7470200f8b847a36a69846c0c6faa54) [permalink](../../248d9759-aef7-45ce-b0a4-6c1cafee76c9%40rowland.harvard.edu/) [raw](../../248d9759-aef7-45ce-b0a4-6c1cafee76c9%40rowland.harvard.edu/raw) [reply](../../248d9759-aef7-45ce-b0a4-6c1cafee76c9%40rowland.harvard.edu/#R)	[[flat](../../248d9759-aef7-45ce-b0a4-6c1cafee76c9%40rowland.harvard.edu/T/#u)|[nested](../../248d9759-aef7-45ce-b0a4-6c1cafee76c9%40rowland.harvard.edu/t/#u)] [15+ messages in thread](#r0e507d1cb7470200f8b847a36a69846c0c6faa54)
```

---

```
[*](#e3ec14338733450f5ede31989d68022d0700554a0) Re: [syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)
  2023-07-25 21:30                 ` [Alan Stern](#m0e507d1cb7470200f8b847a36a69846c0c6faa54)
@ 2023-07-25 21:46                   ` Khazhy Kumykov
  2023-07-26  4:00                     ` [Greg KH](#m1ea654afd02649bdba5c398e6bd02c40ac37f3bf)
  [0 siblings, 1 reply; 15+ messages in thread](#r3ec14338733450f5ede31989d68022d0700554a0)
From: Khazhy Kumykov @ 2023-07-25 21:46 UTC ([permalink](../../CACGdZY%2BqJ7P8FZj6ZGmcDkf2YH7LRBnfvuwiro4ZF37%2BowHo9g%40mail.gmail.com/) / [raw](../../CACGdZY%2BqJ7P8FZj6ZGmcDkf2YH7LRBnfvuwiro4ZF37%2BowHo9g%40mail.gmail.com/raw))
  To: Alan Stern; +Cc: syzbot, gregkh, [linux-kernel](../../../lkml/?t=20230725214652), [linux-usb](../../../linux-usb/?t=20230725214652), syzkaller-bugs

[[-- Attachment #1: Type: text/plain, Size: 3336 bytes --]](../../CACGdZY%2BqJ7P8FZj6ZGmcDkf2YH7LRBnfvuwiro4ZF37%2BowHo9g%40mail.gmail.com/1-a.txt)

On Tue, Jul 25, 2023 at 2:30PM Alan Stern <stern@rowland.harvard.edu> wrote:
>
> On Tue, Jul 25, 2023 at 01:42:01PM -0700, Khazhy Kumykov wrote:
> > On Tue, Jul 25, 2023 at 12:26PM Alan Stern <stern@rowland.harvard.edu> wrote:
>
> > > @@ -2671,12 +2671,17 @@ int usb_authorize_device(struct usb_devi
> > >         }
> > >
> > >         if (usb_dev->wusb) {
> > > -               result = usb_get_device_descriptor(usb_dev, sizeof(usb_dev->descriptor));
> > > -               if (result < 0) {
> > > +               struct usb_device_descriptor *descr;
> > > +
> > > +               descr = usb_get_device_descriptor(usb_dev);
> > > +               if (IS_ERR(descr)) {
> > > +                       result = PTR_ERR(descr);
> > >                         dev_err(&usb_dev->dev, "can't re-read device descriptor for "
> > >                                 "authorization: %d\n", result);
> > >                         goto error_device_descriptor;
> > >                 }
> > > +               usb_dev->descriptor = *descr;
> > Hmm, in your first patch you rejected diffs to the descriptor here,
> > which might be necessary - since we don't re-initialize the device so
> > can get a similar issue if the bad usb device decides to change
> > bNumConfigurations to cause a buffer overrun. (This also stuck out to
> > me as an exception to the "descriptors should be immutable" comment
> > later in the patch.
>
> I removed that part of the previous patch because there's no point to
> it.  None of this code ever gets executed; the usb_dev->wusb test can
> never succeed because the kernel doesn't support wireless USB any more.
> (I asked Greg KH about that in a separate email thread:
> <[https://lore.kernel.org/linux-usb/2a21cefa-99a7-497c-901f-3ea097361a80@rowland.harvard.edu/#r](https://lore.kernel.org/linux-usb/2a21cefa-99a7-497c-901f-3ea097361a80%40rowland.harvard.edu/#r)>.)
>
> A later patch will remove all of the wireless USB stuff.  The only real
> reason for leaving this much of the code there now is to prevent
> compilation errors and keep the form looking right.
Ah ok, cool.

>
> > > @@ -6018,7 +6064,7 @@ static int usb_reset_and_verify_device(s
> > >                 /* ep0 maxpacket size may change; let the HCD know about it.
> > >                  * Other endpoints will be handled by re-enumeration. */
> > >                 usb_ep0_reinit(udev);
> > > -               ret = hub_port_init(parent_hub, udev, port1, i);
> > > +               ret = hub_port_init(parent_hub, udev, port1, i, &descriptor);
> > Looks like this is the only caller that passes &descriptor, and it
> > just checks that it didn't change. Would it make sense to put the
> > enitre descriptors_changed stanza in hub_port_init, for the re-init
> > case?
>
> The descriptors_changed check has to be _somewhere_, either here or
> there.  I don't see what difference it makes whether the check is done
> in this routine or in hub_port_init.  Since it doesn't matter, why
> change the existing code?
No strong feelings, but it lets us remove the variable in
usb_reset_and_verify_device() and directly check on the malloc'd copy,
instead of copying back up to here.

Overall, looks good to my naive eyes.

CVE-2023-37453 was filed for this syzbot report, I'm not sure how that
system gets tracked, but might be good to mention for folks looking
for a fix.

Thanks,
Khazhy

[[-- Attachment #2: S/MIME Cryptographic Signature --]
[-- Type: application/pkcs7-signature, Size: 3999 bytes --]](../../CACGdZY%2BqJ7P8FZj6ZGmcDkf2YH7LRBnfvuwiro4ZF37%2BowHo9g%40mail.gmail.com/2-smime.p7s)

[^](#m3ec14338733450f5ede31989d68022d0700554a0) [permalink](../../CACGdZY%2BqJ7P8FZj6ZGmcDkf2YH7LRBnfvuwiro4ZF37%2BowHo9g%40mail.gmail.com/) [raw](../../CACGdZY%2BqJ7P8FZj6ZGmcDkf2YH7LRBnfvuwiro4ZF37%2BowHo9g%40mail.gmail.com/raw) [reply](../../CACGdZY%2BqJ7P8FZj6ZGmcDkf2YH7LRBnfvuwiro4ZF37%2BowHo9g%40mail.gmail.com/#R)	[[flat](../../CACGdZY%2BqJ7P8FZj6ZGmcDkf2YH7LRBnfvuwiro4ZF37%2BowHo9g%40mail.gmail.com/T/#u)|[nested](../../CACGdZY%2BqJ7P8FZj6ZGmcDkf2YH7LRBnfvuwiro4ZF37%2BowHo9g%40mail.gmail.com/t/#u)] [15+ messages in thread](#r3ec14338733450f5ede31989d68022d0700554a0)
```

---

```
[*](#e1ea654afd02649bdba5c398e6bd02c40ac37f3bf) Re: [syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)
  2023-07-25 21:46                   ` [Khazhy Kumykov](#m3ec14338733450f5ede31989d68022d0700554a0)
@ 2023-07-26  4:00                     ` Greg KH
  2023-08-02 20:00                       ` [Alan Stern](#m5b2b878c42ec29081a82d7bc401095764c889152)
  [0 siblings, 1 reply; 15+ messages in thread](#r1ea654afd02649bdba5c398e6bd02c40ac37f3bf)
From: Greg KH @ 2023-07-26  4:00 UTC ([permalink](../../2023072648-exclaim-crisply-9d8a%40gregkh/) / [raw](../../2023072648-exclaim-crisply-9d8a%40gregkh/raw))
  To: Khazhy Kumykov
  Cc: Alan Stern, syzbot, [linux-kernel](../../../lkml/?t=20230726040119), [linux-usb](../../../linux-usb/?t=20230726040119), syzkaller-bugs

On Tue, Jul 25, 2023 at 02:46:37PM -0700, Khazhy Kumykov wrote:
> On Tue, Jul 25, 2023 at 2:30PM Alan Stern <stern@rowland.harvard.edu> wrote:
> >
> > On Tue, Jul 25, 2023 at 01:42:01PM -0700, Khazhy Kumykov wrote:
> > > On Tue, Jul 25, 2023 at 12:26PM Alan Stern <stern@rowland.harvard.edu> wrote:
> >
> > > > @@ -2671,12 +2671,17 @@ int usb_authorize_device(struct usb_devi
> > > >         }
> > > >
> > > >         if (usb_dev->wusb) {
> > > > -               result = usb_get_device_descriptor(usb_dev, sizeof(usb_dev->descriptor));
> > > > -               if (result < 0) {
> > > > +               struct usb_device_descriptor *descr;
> > > > +
> > > > +               descr = usb_get_device_descriptor(usb_dev);
> > > > +               if (IS_ERR(descr)) {
> > > > +                       result = PTR_ERR(descr);
> > > >                         dev_err(&usb_dev->dev, "can't re-read device descriptor for "
> > > >                                 "authorization: %d\n", result);
> > > >                         goto error_device_descriptor;
> > > >                 }
> > > > +               usb_dev->descriptor = *descr;
> > > Hmm, in your first patch you rejected diffs to the descriptor here,
> > > which might be necessary - since we don't re-initialize the device so
> > > can get a similar issue if the bad usb device decides to change
> > > bNumConfigurations to cause a buffer overrun. (This also stuck out to
> > > me as an exception to the "descriptors should be immutable" comment
> > > later in the patch.
> >
> > I removed that part of the previous patch because there's no point to
> > it.  None of this code ever gets executed; the usb_dev->wusb test can
> > never succeed because the kernel doesn't support wireless USB any more.
> > (I asked Greg KH about that in a separate email thread:
> > <[https://lore.kernel.org/linux-usb/2a21cefa-99a7-497c-901f-3ea097361a80@rowland.harvard.edu/#r](https://lore.kernel.org/linux-usb/2a21cefa-99a7-497c-901f-3ea097361a80%40rowland.harvard.edu/#r)>.)
> >
> > A later patch will remove all of the wireless USB stuff.  The only real
> > reason for leaving this much of the code there now is to prevent
> > compilation errors and keep the form looking right.
> Ah ok, cool.
>
> >
> > > > @@ -6018,7 +6064,7 @@ static int usb_reset_and_verify_device(s
> > > >                 /* ep0 maxpacket size may change; let the HCD know about it.
> > > >                  * Other endpoints will be handled by re-enumeration. */
> > > >                 usb_ep0_reinit(udev);
> > > > -               ret = hub_port_init(parent_hub, udev, port1, i);
> > > > +               ret = hub_port_init(parent_hub, udev, port1, i, &descriptor);
> > > Looks like this is the only caller that passes &descriptor, and it
> > > just checks that it didn't change. Would it make sense to put the
> > > enitre descriptors_changed stanza in hub_port_init, for the re-init
> > > case?
> >
> > The descriptors_changed check has to be _somewhere_, either here or
> > there.  I don't see what difference it makes whether the check is done
> > in this routine or in hub_port_init.  Since it doesn't matter, why
> > change the existing code?
> No strong feelings, but it lets us remove the variable in
> usb_reset_and_verify_device() and directly check on the malloc'd copy,
> instead of copying back up to here.
>
> Overall, looks good to my naive eyes.
>
> CVE-2023-37453 was filed for this syzbot report, I'm not sure how that
> system gets tracked, but might be good to mention for folks looking
> for a fix.

Who filed CVEs for random syzbot reports?  That's crazy, and no, we
aren't going to track it as CVEs mean nothing for the kernel as I've
said many times.

thanks,

greg k-h

[^](#m1ea654afd02649bdba5c398e6bd02c40ac37f3bf) [permalink](../../2023072648-exclaim-crisply-9d8a%40gregkh/) [raw](../../2023072648-exclaim-crisply-9d8a%40gregkh/raw) [reply](../../2023072648-exclaim-crisply-9d8a%40gregkh/#R)	[[flat](../../2023072648-exclaim-crisply-9d8a%40gregkh/T/#u)|[nested](../../2023072648-exclaim-crisply-9d8a%40gregkh/t/#u)] [15+ messages in thread](#r1ea654afd02649bdba5c398e6bd02c40ac37f3bf)
```

---

```
[*](#e5b2b878c42ec29081a82d7bc401095764c889152) Re: [syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)
  2023-07-26  4:00                     ` [Greg KH](#m1ea654afd02649bdba5c398e6bd02c40ac37f3bf)
@ 2023-08-02 20:00                       ` Alan Stern
  2023-08-03  6:34                         ` [Greg KH](#me45ba5d22948e679c23d55b832f4791eebeaf117)
  [0 siblings, 1 reply; 15+ messages in thread](#r5b2b878c42ec29081a82d7bc401095764c889152)
From: Alan Stern @ 2023-08-02 20:00 UTC ([permalink](../../58e8a28b-ab24-4449-9072-e0fb7ed39196%40rowland.harvard.edu/) / [raw](../../58e8a28b-ab24-4449-9072-e0fb7ed39196%40rowland.harvard.edu/raw))
  To: Greg KH; +Cc: Khazhy Kumykov, syzbot, [linux-usb](../../../linux-usb/?t=20230802200034), syzkaller-bugs

Greg:

I'm putting together a series of three patches to deal with this
problem.  The first two do some preparatory work, and the bug found by
syzbot actually gets fixed by the third patch.

In view of this, how should I tag the patches?  They should all get into
the -stable trees eventually, but only the third one really deserves a
Fixes: or Reported-by: tag.

What's your advice?

Alan Stern

[^](#m5b2b878c42ec29081a82d7bc401095764c889152) [permalink](../../58e8a28b-ab24-4449-9072-e0fb7ed39196%40rowland.harvard.edu/) [raw](../../58e8a28b-ab24-4449-9072-e0fb7ed39196%40rowland.harvard.edu/raw) [reply](../../58e8a28b-ab24-4449-9072-e0fb7ed39196%40rowland.harvard.edu/#R)	[[flat](../../58e8a28b-ab24-4449-9072-e0fb7ed39196%40rowland.harvard.edu/T/#u)|[nested](../../58e8a28b-ab24-4449-9072-e0fb7ed39196%40rowland.harvard.edu/t/#u)] [15+ messages in thread](#r5b2b878c42ec29081a82d7bc401095764c889152)
```

---

```
[*](#ee45ba5d22948e679c23d55b832f4791eebeaf117) Re: [syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)
  2023-08-02 20:00                       ` [Alan Stern](#m5b2b878c42ec29081a82d7bc401095764c889152)
@ 2023-08-03  6:34                         ` Greg KH
  [0 siblings, 0 replies; 15+ messages in thread](#re45ba5d22948e679c23d55b832f4791eebeaf117)
From: Greg KH @ 2023-08-03  6:34 UTC ([permalink](../../2023080309-economist-each-6f51%40gregkh/) / [raw](../../2023080309-economist-each-6f51%40gregkh/raw))
  To: Alan Stern; +Cc: Khazhy Kumykov, syzbot, [linux-usb](../../../linux-usb/?t=20230803063409), syzkaller-bugs

On Wed, Aug 02, 2023 at 04:00:28PM -0400, Alan Stern wrote:
> Greg:
>
> I'm putting together a series of three patches to deal with this
> problem.  The first two do some preparatory work, and the bug found by
> syzbot actually gets fixed by the third patch.
>
> In view of this, how should I tag the patches?  They should all get into
> the -stable trees eventually, but only the third one really deserves a
> Fixes: or Reported-by: tag.
>
> What's your advice?

Sounds correct, just tag the last one with a reported-by:  Same for the
fixes: tag, we deal with this in the stable tree a lot, and can figure
out the dependancies like this for patch series.

thanks,

greg k-h

[^](#me45ba5d22948e679c23d55b832f4791eebeaf117) [permalink](../../2023080309-economist-each-6f51%40gregkh/) [raw](../../2023080309-economist-each-6f51%40gregkh/raw) [reply](../../2023080309-economist-each-6f51%40gregkh/#R)	[[flat](../../2023080309-economist-each-6f51%40gregkh/T/#u)|[nested](../../2023080309-economist-each-6f51%40gregkh/t/#u)] [15+ messages in thread](#re45ba5d22948e679c23d55b832f4791eebeaf117)
```

---

```
end of thread, other threads:[[~2023-08-03  6:34 UTC](../../?t=20230803063409) | [newest](../../)]

Thread overview: 15+ messages (download: [mbox.gz](../t.mbox.gz) follow: [Atom feed](../t.atom)
-- links below jump to the message on this page --
2023-06-20  2:55 [[syzbot] [usb?] KASAN: slab-out-of-bounds Read in read_descriptors (3)](#md5fb727b19bd829948177dafed0e7f4be241ff86) syzbot
2023-07-21 18:10 ` [Khazhy Kumykov](#mc79c976f308450b04f646243f791ae214d7d2f1c)
2023-07-21 18:23   ` [Khazhy Kumykov](#mcfbd21bc069b1007f363b61b24e989c65dbc08d4)
2023-07-21 18:56     ` [Alan Stern](#m7d6dde2f092063d51a8e5de813a19565fee957aa)
2023-07-21 22:40       ` [Khazhy Kumykov](#md7ffc1e0ca26611f72de4ac23ceef919b0e38bfb)
2023-07-23  2:01         ` [Alan Stern](#m53cf18f5dda9e712a29095b6be66a98a11a50152)
2023-07-23  2:21           ` [syzbot](#m8ed752822c9f8dd9a8b08ea04933429747edf601)
2023-07-25 19:26             ` [Alan Stern](#m51a496d4914a8b0c2cf0a20d2be4c53e66789254)
2023-07-25 20:42               ` [Khazhy Kumykov](#mcbd7d76466d9dfc8915d25e66f4e68adedcdbc12)
2023-07-25 21:30                 ` [Alan Stern](#m0e507d1cb7470200f8b847a36a69846c0c6faa54)
2023-07-25 21:46                   ` [Khazhy Kumykov](#m3ec14338733450f5ede31989d68022d0700554a0)
2023-07-26  4:00                     ` [Greg KH](#m1ea654afd02649bdba5c398e6bd02c40ac37f3bf)
2023-08-02 20:00                       ` [Alan Stern](#m5b2b878c42ec29081a82d7bc401095764c889152)
2023-08-03  6:34                         ` [Greg KH](#me45ba5d22948e679c23d55b832f4791eebeaf117)
2023-07-25 20:54               ` [syzbot](#mb60707f27ed3bcbc25254759aff11ea6ab273c2a)

```

---

```
This is an external index of several public inboxes,
see [mirroring instructions](../../_/text/mirror/) on how to clone and mirror
all data and code used by this external index.
```


=== Content from git.kernel.org_dc6a2501_20250114_225407.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Alan Stern <stern@rowland.harvard.edu> | 2023-08-04 15:12:21 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-08-08 10:45:32 +0200 |
| commit | [de28e469da75359a2bb8cd8778b78aa64b1be1f4](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4)) | |
| tree | [7bb3ea32ca3bb69414eb43633ec50529b347f087](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4) | |
| parent | [85d07c55621676d47d873d2749b88f783cd4d5a1](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=85d07c55621676d47d873d2749b88f783cd4d5a1) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4&id2=85d07c55621676d47d873d2749b88f783cd4d5a1)) | |
| download | [linux-de28e469da75359a2bb8cd8778b78aa64b1be1f4.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-de28e469da75359a2bb8cd8778b78aa64b1be1f4.tar.gz) | |

USB: core: Change usb\_get\_device\_descriptor() APIThe usb\_get\_device\_descriptor() routine reads the device descriptor
from the udev device and stores it directly in udev->descriptor. This
interface is error prone, because the USB subsystem expects in-memory
copies of a device's descriptors to be immutable once the device has
been initialized.
The interface is changed so that the device descriptor is left in a
kmalloc-ed buffer, not copied into the usb\_device structure. A
pointer to the buffer is returned to the caller, who is then
responsible for kfree-ing it. The corresponding changes needed in the
various callers are fairly small.
Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Link: [https://lore.kernel.org/r/d0111bb6-56c1-4f90-adf2-6cfe152f6561@rowland.harvard.edu](https://lore.kernel.org/r/d0111bb6-56c1-4f90-adf2-6cfe152f6561%40rowland.harvard.edu)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4)

| -rw-r--r-- | [drivers/usb/core/hcd.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/usb/core/hcd.c?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4) | 10 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/usb/core/hub.c?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4) | 44 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/usb/core/message.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/usb/core/message.c?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4) | 29 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/usb/core/usb.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/usb/core/usb.h?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4) | 4 | |  |  |  | | --- | --- | --- | |

4 files changed, 44 insertions, 43 deletions

| diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.cindex 8300baedafd20e..6af0a31ff14758 100644--- a/[drivers/usb/core/hcd.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hcd.c?id=85d07c55621676d47d873d2749b88f783cd4d5a1)+++ b/[drivers/usb/core/hcd.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hcd.c?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4)@@ -983,6 +983,7 @@ static int register\_root\_hub(struct usb\_hcd \*hcd) { struct device \*parent\_dev = hcd->self.controller; struct usb\_device \*usb\_dev = hcd->self.root\_hub;+ struct usb\_device\_descriptor \*descr; const int devnum = 1; int retval; @@ -994,13 +995,16 @@ static int register\_root\_hub(struct usb\_hcd \*hcd) mutex\_lock(&usb\_bus\_idr\_lock);  usb\_dev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- retval = usb\_get\_device\_descriptor(usb\_dev, USB\_DT\_DEVICE\_SIZE);- if (retval != sizeof usb\_dev->descriptor) {+ descr = usb\_get\_device\_descriptor(usb\_dev);+ if (IS\_ERR(descr)) {+ retval = PTR\_ERR(descr); mutex\_unlock(&usb\_bus\_idr\_lock); dev\_dbg (parent\_dev, "can't read %s device descriptor %d\n", dev\_name(&usb\_dev->dev), retval);- return (retval < 0) ? retval : -EMSGSIZE;+ return retval; }+ usb\_dev->descriptor = \*descr;+ kfree(descr);  if (le16\_to\_cpu(usb\_dev->descriptor.bcdUSB) >= 0x0201) { retval = usb\_get\_bos\_descriptor(usb\_dev);diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.cindex 91abcd904d0448..9279c8ccbcf250 100644--- a/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hub.c?id=85d07c55621676d47d873d2749b88f783cd4d5a1)+++ b/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hub.c?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4)@@ -2694,12 +2694,17 @@ int usb\_authorize\_device(struct usb\_device \*usb\_dev) }  if (usb\_dev->wusb) {- result = usb\_get\_device\_descriptor(usb\_dev, sizeof(usb\_dev->descriptor));- if (result < 0) {+ struct usb\_device\_descriptor \*descr;++ descr = usb\_get\_device\_descriptor(usb\_dev);+ if (IS\_ERR(descr)) {+ result = PTR\_ERR(descr); dev\_err(&usb\_dev->dev, "can't re-read device descriptor for " "authorization: %d\n", result); goto error\_device\_descriptor; }+ usb\_dev->descriptor = \*descr;+ kfree(descr); }  usb\_dev->authorized = 1;@@ -4827,7 +4832,7 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, const char \*driver\_name; bool do\_new\_scheme; int maxp0;- struct usb\_device\_descriptor \*buf;+ struct usb\_device\_descriptor \*buf, \*descr;  buf = kmalloc(GET\_DESCRIPTOR\_BUFSIZE, GFP\_NOIO); if (!buf)@@ -5069,15 +5074,16 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, usb\_ep0\_reinit(udev); } - retval = usb\_get\_device\_descriptor(udev, USB\_DT\_DEVICE\_SIZE);- if (retval < (signed)sizeof(udev->descriptor)) {+ descr = usb\_get\_device\_descriptor(udev);+ if (IS\_ERR(descr)) {+ retval = PTR\_ERR(descr); if (retval != -ENODEV) dev\_err(&udev->dev, "device descriptor read/all, error %d\n", retval);- if (retval >= 0)- retval = -ENOMSG; goto fail; }+ udev->descriptor = \*descr;+ kfree(descr);  /\* \* Some superspeed devices have finished the link training process@@ -5196,7 +5202,7 @@ hub\_power\_remaining(struct usb\_hub \*hub)   static int descriptors\_changed(struct usb\_device \*udev,- struct usb\_device\_descriptor \*old\_device\_descriptor,+ struct usb\_device\_descriptor \*new\_device\_descriptor, struct usb\_host\_bos \*old\_bos) { int changed = 0;@@ -5207,8 +5213,8 @@ static int descriptors\_changed(struct usb\_device \*udev, int length; char \*buf; - if (memcmp(&udev->descriptor, old\_device\_descriptor,- sizeof(\*old\_device\_descriptor)) != 0)+ if (memcmp(&udev->descriptor, new\_device\_descriptor,+ sizeof(\*new\_device\_descriptor)) != 0) return 1;  if ((old\_bos && !udev->bos) || (!old\_bos && udev->bos))@@ -5533,9 +5539,8 @@ static void hub\_port\_connect\_change(struct usb\_hub \*hub, int port1, { struct usb\_port \*port\_dev = hub->ports[port1 - 1]; struct usb\_device \*udev = port\_dev->child;- struct usb\_device\_descriptor descriptor;+ struct usb\_device\_descriptor \*descr; int status = -ENODEV;- int retval;  dev\_dbg(&port\_dev->dev, "status %04x, change %04x, %s\n", portstatus, portchange, portspeed(hub, portstatus));@@ -5562,23 +5567,20 @@ static void hub\_port\_connect\_change(struct usb\_hub \*hub, int port1, \* changed device descriptors before resuscitating the \* device. \*/- descriptor = udev->descriptor;- retval = usb\_get\_device\_descriptor(udev,- sizeof(udev->descriptor));- if (retval < 0) {+ descr = usb\_get\_device\_descriptor(udev);+ if (IS\_ERR(descr)) { dev\_dbg(&udev->dev,- "can't read device descriptor %d\n",- retval);+ "can't read device descriptor %ld\n",+ PTR\_ERR(descr)); } else {- if (descriptors\_changed(udev, &descriptor,+ if (descriptors\_changed(udev, descr, udev->bos)) { dev\_dbg(&udev->dev, "device descriptor has changed\n");- /\* for disconnect() calls \*/- udev->descriptor = descriptor; } else { status = 0; /\* Nothing to do \*/ }+ kfree(descr); } #ifdef CONFIG\_PM } else if (udev->state == USB\_STATE\_SUSPENDED &&diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.cindex 0d2bfc909019b8..077dfe48d01c1c 100644--- a/[drivers/usb/core/message.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/message.c?id=85d07c55621676d47d873d2749b88f783cd4d5a1)+++ b/[drivers/usb/core/message.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/message.c?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4)@@ -1041,40 +1041,35 @@ char \*usb\_cache\_string(struct usb\_device \*udev, int index) EXPORT\_SYMBOL\_GPL(usb\_cache\_string);  /\*- \* usb\_get\_device\_descriptor - (re)reads the device descriptor (usbcore)- \* @dev: the device whose device descriptor is being updated- \* @size: how much of the descriptor to read+ \* usb\_get\_device\_descriptor - read the device descriptor+ \* @udev: the device whose device descriptor should be read \* \* Context: task context, might sleep. \*- \* Updates the copy of the device descriptor stored in the device structure,- \* which dedicates space for this purpose.- \* \* Not exported, only for use by the core. If drivers really want to read \* the device descriptor directly, they can call usb\_get\_descriptor() with \* type = USB\_DT\_DEVICE and index = 0. \*- \* This call is synchronous, and may not be used in an interrupt context.- \*- \* Return: The number of bytes received on success, or else the status code- \* returned by the underlying usb\_control\_msg() call.+ \* Returns: a pointer to a dynamically allocated usb\_device\_descriptor+ \* structure (which the caller must deallocate), or an ERR\_PTR value. \*/-int usb\_get\_device\_descriptor(struct usb\_device \*dev, unsigned int size)+struct usb\_device\_descriptor \*usb\_get\_device\_descriptor(struct usb\_device \*udev) { struct usb\_device\_descriptor \*desc; int ret; - if (size > sizeof(\*desc))- return -EINVAL; desc = kmalloc(sizeof(\*desc), GFP\_NOIO); if (!desc)- return -ENOMEM;+ return ERR\_PTR(-ENOMEM);++ ret = usb\_get\_descriptor(udev, USB\_DT\_DEVICE, 0, desc, sizeof(\*desc));+ if (ret == sizeof(\*desc))+ return desc; - ret = usb\_get\_descriptor(dev, USB\_DT\_DEVICE, 0, desc, size); if (ret >= 0)- memcpy(&dev->descriptor, desc, size);+ ret = -EMSGSIZE; kfree(desc);- return ret;+ return ERR\_PTR(ret); }  /\*diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.hindex 69ca59841083b3..60363153fc3f38 100644--- a/[drivers/usb/core/usb.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/usb.h?id=85d07c55621676d47d873d2749b88f783cd4d5a1)+++ b/[drivers/usb/core/usb.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/usb.h?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4)@@ -43,8 +43,8 @@ extern bool usb\_endpoint\_is\_ignored(struct usb\_device \*udev, struct usb\_endpoint\_descriptor \*epd); extern int usb\_remove\_device(struct usb\_device \*udev); -extern int usb\_get\_device\_descriptor(struct usb\_device \*dev,- unsigned int size);+extern struct usb\_device\_descriptor \*usb\_get\_device\_descriptor(+ struct usb\_device \*udev); extern int usb\_set\_isoch\_delay(struct usb\_device \*dev); extern int usb\_get\_bos\_descriptor(struct usb\_device \*dev); extern void usb\_release\_bos\_descriptor(struct usb\_device \*dev); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 22:52:45 +0000



=== Content from syzkaller.appspot.com_a407016b_20250114_225410.html ===


| [syzbot](/upstream) | Android 5.10 Android 5.15 Android 5.4 Android 6.1 FreeBSD Linux Linux 5.15 Linux 6.1 NetBSD OpenBSD gVisor | [sign-in](https://syzkaller.appspot.com/_ah/conflogin?continue=https://syzkaller.appspot.com/bug%3Fextid%3D18996170f8096c6174d0) | [mailing list](https://groups.google.com/forum/#!forum/syzkaller) | [source](https://github.com/google/syzkaller) | [docs](https://github.com/google/syzkaller/blob/master/docs/syzbot.md) |
| --- | --- | --- |

[ Open [1663]](/upstream)

[ Subsystems](/upstream/subsystems)

[ Fixed [5974]](/upstream/fixed)

[ Invalid [14657]](/upstream/invalid)

[ Missing Backports [127]](/upstream/backports)

[ Crashes](/upstream/graph/crashes)

Graphs
[KernelHealth](/upstream/graph/bugs)
[Bugs/Month](/upstream/graph/found-bugs)
[BugLifetimes](/upstream/graph/lifetimes)
[Fuzzing](/upstream/graph/fuzzing)

Coverage
[Total](/upstream/graph/coverage?period=quarter)
[RepoHeatmap](/upstream/graph/coverage_heatmap?period=month)
[SubsystemsHeatmap](/upstream/graph/coverage_subsystems_heatmap?period=month)

 Send us feedback

**KASAN: slab-out-of-bounds Read in read\_descriptors (3)**

Status: [fixed on 2023/10/12 12:48](https://groups.google.com/d/msgid/syzkaller-bugs/000000000000c0ffe505fe86c9ca%40google.com)

Subsystems:
[usb](/upstream/s/usb)

[[Documentation on labels]](https://github.com/google/syzkaller/blob/master/docs/syzbot.md#labels)

Reported-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com

**Fix commit:**
ff33299ec8bb
[USB: core: Fix race by not overwriting udev->descriptor in hub\_port\_init()](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b)

First crash: 578d, last: 547d

**Cause bisection: failed**
**([error log](https://syzkaller.appspot.com/x/error.txt?x=10e37337280000), [bisect log](https://syzkaller.appspot.com/x/bisect.txt?x=17637337280000))**



Discussions (2)

| Title | Replies (including bot) | Last reply |
| --- | --- | --- |
| [[PATCH 3/3] USB: core: Fix race by not overwriting udev->descriptor in hub\_port\_init()](https://lore.kernel.org/all/b958b47a-9a46-4c22-a9f9-e42e42c31251%40rowland.harvard.edu/T/) | 1 (1) | 2023/08/04 19:14 |
| [[syzbot] [usb?] KASAN: slab-out-of-bounds Read in read\_descriptors (3)](https://lore.kernel.org/all/000000000000c0ffe505fe86c9ca%40google.com/T/) | 12 (15) | 2023/08/03 06:34 |



Similar bugs (6)

| Kernel | Title | Repro | Cause bisect | Fix bisect | Count | Last | Reported | Patched | Status |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| linux-6.1 | [KASAN: slab-out-of-bounds Read in read\_descriptors](/bug?id=550194458b91b9c1a5676a2041f19cb045e76fa5) [origin:upstream](/linux-6.1?label=origin%3Aupstream) | C |  | error | 1 | 533d | [577d](https://groups.google.com/d/msgid/syzkaller-lts-bugs/00000000000084d8fe05fe4e845d%40google.com) | 0/3 | [auto-obsoleted due to no activity on 2023/11/08 10:43](https://groups.google.com/d/msgid/syzkaller-lts-bugs/00000000000084d8fe05fe4e845d%40google.com) |
| linux-5.15 | [KASAN: slab-out-of-bounds Read in read\_descriptors](/bug?id=83cb58a7f93334c6ec9aedd1ed3d1ae57f7e338a) [origin:upstream](/linux-5.15?label=origin%3Aupstream) [missing-backport](/linux-5.15?label=missing-backport) | C |  | error | 2 | 487d | [577d](https://groups.google.com/d/msgid/syzkaller-lts-bugs/0000000000001af1a805fe4eca66%40google.com) | 0/3 | [auto-obsoleted due to no activity on 2024/10/04 16:22](https://groups.google.com/d/msgid/syzkaller-lts-bugs/0000000000001af1a805fe4eca66%40google.com) |
| upstream | [KASAN: slab-out-of-bounds Read in read\_descriptors (2)](/bug?extid=256e56ddde8b8957eabd) [usb](/upstream/s/usb) |  |  |  | 1 | 1607d | [1603d](https://groups.google.com/d/msgid/syzkaller-bugs/000000000000c139e505adad7558%40google.com) | 15/28 | [fixed on 2020/10/10 01:52](https://groups.google.com/d/msgid/syzkaller-bugs/000000000000c139e505adad7558%40google.com) |
| upstream | [KASAN: slab-out-of-bounds Read in read\_descriptors](/bug?id=c5017f8f448bcc804491aae6ea4adf725c0ff632) [usb](/upstream/s/usb) |  |  |  | 1 | 1912d | [1911d](https://groups.google.com/d/msgid/syzkaller-bugs/000000000000e56434059580f86e%40google.com) | 0/28 | [auto-closed as invalid on 2020/02/18 03:02](https://groups.google.com/d/msgid/syzkaller-bugs/000000000000e56434059580f86e%40google.com) |
| upstream | [KMSAN: uninit-value in read\_descriptors (2)](/bug?id=0641b8ef1aa35a0ef802c138505114307bf0ec2a) [usb](/upstream/s/usb) |  |  |  | 1 | 674d | 674d | 0/28 | auto-obsoleted due to no activity on 2023/06/10 07:49 |
| upstream | [KMSAN: uninit-value in read\_descriptors](/bug?id=38d8bb4bdfe2c3d95dc09dcf3e5d10abf7f7ca0f) [usb](/upstream/s/usb) |  |  |  | 1 | 1043d | 1043d | 0/28 | auto-closed as invalid on 2022/06/06 09:45 |



Last patch testing requests (3)

| Created | Duration | User | Patch | Repo | Result |
| --- | --- | --- | --- | --- | --- |
| 2023/07/25 19:26 | 19m | stern@rowland.harvard.edu | [patch](/text?tag=Patch&x=1339684aa80000) | [https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/ v6.5-rc3](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git//commit/?id=6eaae198076080886b9e7d57f4ae06fa782f90ef) | OK [log](https://syzkaller.appspot.com/x/log.txt?x=13d77b76a80000) |
| 2023/07/23 02:01 | 19m | stern@rowland.harvard.edu | [patch](/text?tag=Patch&x=1120305ea80000) | [https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/ v6.5-rc2](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git//commit/?id=fdf0eaf11452d72945af31804e2a1048ee1b574c) | OK [log](https://syzkaller.appspot.com/x/log.txt?x=158187d1a80000) |
| 2023/07/22 07:08 | 12m | mukattreyee@gmail.com |  | [https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git master](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d192f5382581d972c4ae1b4d72e0b59b34cadeb9) | [report](https://syzkaller.appspot.com/x/report.txt?x=17de1fe1a80000) [log](https://syzkaller.appspot.com/x/log.txt?x=13de1fe1a80000) |

**Sample crash report:**

```
==================================================================
BUG: KASAN: slab-out-of-bounds in read_descriptors+0x27e/0x290 [drivers/usb/core/sysfs.c:883](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/sysfs.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n883)
Read of size 8 at addr ffff888022cc59e0 by task udevd/5030

CPU: 1 PID: 5030 Comm: udevd Not tainted 6.5.0-rc1-syzkaller-00276-g20edcec23f92 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 07/03/2023
Call Trace:
 <TASK>
 __dump_stack [lib/dump_stack.c:88](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/lib/dump_stack.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n88) [inline]
 dump_stack_lvl+0xd9/0x1b0 [lib/dump_stack.c:106](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/lib/dump_stack.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n106)
 print_address_description [mm/kasan/report.c:364](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/kasan/report.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n364) [inline]
 print_report+0xc4/0x620 [mm/kasan/report.c:475](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/kasan/report.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n475)
 kasan_report+0xda/0x110 [mm/kasan/report.c:588](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/kasan/report.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n588)
 read_descriptors+0x27e/0x290 [drivers/usb/core/sysfs.c:883](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/sysfs.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n883)
 sysfs_kf_bin_read+0x1a0/0x270 [fs/sysfs/file.c:97](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/sysfs/file.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n97)
 kernfs_file_read_iter [fs/kernfs/file.c:251](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/kernfs/file.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n251) [inline]
 kernfs_fop_read_iter+0x37c/0x680 [fs/kernfs/file.c:280](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/kernfs/file.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n280)
 call_read_iter [include/linux/fs.h:1865](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/fs.h?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n1865) [inline]
 new_sync_read [fs/read_write.c:389](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/read_write.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n389) [inline]
 vfs_read+0x4e0/0x930 [fs/read_write.c:470](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/read_write.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n470)
 ksys_read+0x12f/0x250 [fs/read_write.c:613](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/read_write.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n613)
 do_syscall_x64 [arch/x86/entry/common.c:50](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/entry/common.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n50) [inline]
 do_syscall_64+0x38/0xb0 [arch/x86/entry/common.c:80](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/entry/common.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n80)
 entry_SYSCALL_64_after_hwframe+0x63/0xcd
RIP: 0033:0x7f0570b99b6a
Code: 00 3d 00 00 41 00 75 0d 50 48 8d 3d 2d 08 0a 00 e8 ea 7d 01 00 31 c0 e9 07 ff ff ff 64 8b 04 25 18 00 00 00 85 c0 75 1b 0f 05 <48> 3d 00 f0 ff ff 76 6c 48 8b 15 8f a2 0d 00 f7 d8 64 89 02 48 83
RSP: 002b:00007ffff72ef498 EFLAGS: 00000246 ORIG_RAX: 0000000000000000
RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f0570b99b6a
RDX: 0000000000010011 RSI: 00007ffff72ef4c7 RDI: 0000000000000008
RBP: 0000000000000008 R08: 0000000000000003 R09: b4d8a3e856476f50
R10: 0000000000000000 R11: 0000000000000246 R12: 000055f8f5d42550
R13: 00007ffff72ffba8 R14: 00007ffff73001f8 R15: 00007ffff72ef4c7
 </TASK>

Allocated by task 9:
 kasan_save_stack+0x33/0x50 [mm/kasan/common.c:45](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/kasan/common.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n45)
 kasan_set_track+0x25/0x30 [mm/kasan/common.c:52](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/kasan/common.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n52)
 ____kasan_kmalloc [mm/kasan/common.c:374](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/kasan/common.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n374) [inline]
 __kasan_kmalloc+0xa2/0xb0 [mm/kasan/common.c:383](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/kasan/common.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n383)
 kasan_kmalloc [include/linux/kasan.h:196](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/kasan.h?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n196) [inline]
 __do_kmalloc_node [mm/slab_common.c:985](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/slab_common.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n985) [inline]
 __kmalloc+0x5d/0x100 [mm/slab_common.c:998](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/slab_common.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n998)
 kmalloc [include/linux/slab.h:586](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/slab.h?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n586) [inline]
 kzalloc [include/linux/slab.h:703](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/slab.h?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n703) [inline]
 usb_get_configuration+0x191/0x5640 [drivers/usb/core/config.c:887](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/config.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n887)
 usb_enumerate_device [drivers/usb/core/hub.c:2422](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hub.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n2422) [inline]
 usb_new_device+0x1115/0x1960 [drivers/usb/core/hub.c:2560](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hub.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n2560)
 hub_port_connect [drivers/usb/core/hub.c:5422](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hub.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n5422) [inline]
 hub_port_connect_change [drivers/usb/core/hub.c:5566](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hub.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n5566) [inline]
 port_event [drivers/usb/core/hub.c:5726](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hub.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n5726) [inline]
 hub_event+0x307f/0x5230 [drivers/usb/core/hub.c:5808](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hub.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n5808)
 process_one_work+0xaa2/0x16f0 [kernel/workqueue.c:2597](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/workqueue.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n2597)
 worker_thread+0x687/0x1110 [kernel/workqueue.c:2748](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/workqueue.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n2748)
 kthread+0x33a/0x430 [kernel/kthread.c:389](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/kthread.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n389)
 ret_from_fork+0x2c/0x70 [arch/x86/kernel/process.c:145](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kernel/process.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n145)
 ret_from_fork_asm+0x11/0x20 [arch/x86/entry/entry_64.S:296](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/entry/entry_64.S?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n296)

The buggy address belongs to the object at ffff888022cc59d8
 which belongs to the cache kmalloc-8 of size 8
The buggy address is located 0 bytes to the right of
 allocated 8-byte region [ffff888022cc59d8, ffff888022cc59e0)

The buggy address belongs to the physical page:
page:ffffea00008b3140 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x22cc5
anon flags: 0xfff00000000200(slab|node=0|zone=1|lastcpupid=0x7ff)
page_type: 0xffffffff()
raw: 00fff00000000200 ffff888012841280 0000000000000000 dead000000000001
raw: 0000000000000000 0000000000660066 00000001ffffffff 0000000000000000
page dumped because: kasan: bad access detected
page_owner tracks the page as allocated
page last allocated via order 0, migratetype Unmovable, gfp_mask 0x12c00(GFP_NOIO|__GFP_NOWARN|__GFP_NORETRY), pid 1, tgid 1 (swapper/0), ts 6838668391, free_ts 0
 set_page_owner [include/linux/page_owner.h:31](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/page_owner.h?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n31) [inline]
 post_alloc_hook+0x2d2/0x350 [mm/page_alloc.c:1570](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/page_alloc.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n1570)
 prep_new_page [mm/page_alloc.c:1577](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/page_alloc.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n1577) [inline]
 get_page_from_freelist+0x10a9/0x31e0 [mm/page_alloc.c:3221](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/page_alloc.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n3221)
 __alloc_pages+0x1d0/0x4a0 [mm/page_alloc.c:4477](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/page_alloc.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n4477)
 alloc_page_interleave+0x1e/0x250 [mm/mempolicy.c:2112](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/mempolicy.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n2112)
 alloc_pages+0x22a/0x270 [mm/mempolicy.c:2274](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/mempolicy.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n2274)
 alloc_slab_page [mm/slub.c:1862](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/slub.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n1862) [inline]
 allocate_slab+0x24e/0x380 [mm/slub.c:2009](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/slub.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n2009)
 new_slab [mm/slub.c:2062](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/slub.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n2062) [inline]
 ___slab_alloc+0x8bc/0x1570 [mm/slub.c:3215](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/slub.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n3215)
 __slab_alloc.constprop.0+0x56/0xa0 [mm/slub.c:3314](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/slub.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n3314)
 __slab_alloc_node [mm/slub.c:3367](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/slub.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n3367) [inline]
 slab_alloc_node [mm/slub.c:3460](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/slub.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n3460) [inline]
 __kmem_cache_alloc_node+0x137/0x350 [mm/slub.c:3509](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/slub.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n3509)
 kmalloc_trace+0x25/0xe0 [mm/slab_common.c:1076](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/slab_common.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n1076)
 kmalloc [include/linux/slab.h:582](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/slab.h?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n582) [inline]
 usb_control_msg+0xbd/0x4a0 [drivers/usb/core/message.c:143](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/message.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n143)
 set_port_feature [drivers/usb/core/hub.c:443](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hub.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n443) [inline]
 hub_suspend+0x8a0/0xa80 [drivers/usb/core/hub.c:3906](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hub.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n3906)
 usb_suspend_interface [drivers/usb/core/driver.c:1308](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/driver.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n1308) [inline]
 usb_suspend_both+0x295/0x9b0 [drivers/usb/core/driver.c:1413](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/driver.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n1413)
 usb_runtime_suspend+0x49/0x170 [drivers/usb/core/driver.c:1952](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/driver.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n1952)
 __rpm_callback+0xc5/0x4c0 [drivers/base/power/runtime.c:392](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/base/power/runtime.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n392)
 rpm_callback+0x1da/0x220 [drivers/base/power/runtime.c:446](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/base/power/runtime.c?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7#n446)
page_owner free stack trace missing

Memory state around the buggy address:
 ffff888022cc5880: fc fc fc 06 fc fc fc fc 06 fc fc fc fc 06 fc fc
 ffff888022cc5900: fc fc fa fc fc fc fc 00 fc fc fc fc 00 fc fc fc
>ffff888022cc5980: fc 00 fc fc fc fc 00 fc fc fc fc 00 fc fc fc fc
                                                       ^
 ffff888022cc5a00: 00 fc fc fc fc fa fc fc fc fc fa fc fc fc fc 04
 ffff888022cc5a80: fc fc fc fc 04 fc fc fc fc 06 fc fc fc fc 04 fc
==================================================================

```

Crashes (7):
| Time | Kernel | Commit | Syzkaller | Config | Log | Report | Syz repro | C repro | VM info | Assets ([help?](https://github.com/google/syzkaller/blob/master/docs/syzbot_assets.md)) | Manager | Title |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 2023/07/17 04:30 | upstream | [20edcec23f92](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?id=20edcec23f92db47ca1ab33b4c6025bb8b3db7d7) | [35d9ecc5](https://github.com/google/syzkaller/commits/35d9ecc508aef508b67ee7986a7abb0864e74f8e) | [.config](/text?tag=KernelConfig&x=4a9506b1ca57ae9f) | [strace log](/text?tag=CrashLog&x=1597c424a80000) | [report](/text?tag=CrashReport&x=159d3f0ea80000) | [syz](/text?tag=ReproSyz&x=161be70aa80000) | [C](/text?tag=ReproC&x=1150cb7ca80000) |  | [[disk image](https://storage.googleapis.com/syzbot-assets/85d16ab2092e/disk-20edcec2.raw.xz)] [[vmlinux](https://storage.googleapis.com/syzbot-assets/d332400343f7/vmlinux-20edcec2.xz)] [[kernel image](https://storage.googleapis.com/syzbot-assets/683a753bafa3/bzImage-20edcec2.xz)] | ci-upstream-kasan-gce-root | KASAN: slab-out-of-bounds Read in read\_descriptors |
| 2023/06/17 02:15 | upstream | [40f71e7cd3c6](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?id=40f71e7cd3c6ac04293556ab0504a372393838ff) | [f3921d4d](https://github.com/google/syzkaller/commits/f3921d4d63f97d1f1fb49a69ea85744bb7ef184b) | [.config](/text?tag=KernelConfig&x=ac246111fb601aec) | [strace log](/text?tag=CrashLog&x=1581445b280000) | [report](/text?tag=CrashReport&x=12fed0a7280000) | [syz](/text?tag=ReproSyz&x=15d23487280000) | [C](/text?tag=ReproC&x=16613ed3280000) |  | [[disk image](https://storage.googleapis.com/syzbot-assets/30922ad38c58/disk-40f71e7c.raw.xz)] [[vmlinux](https://storage.googleapis.com/syzbot-assets/3bd12e7503b8/vmlinux-40f71e7c.xz)] [[kernel image](https://storage.googleapis.com/syzbot-assets/1dcd340b18d4/bzImage-40f71e7c.xz)] | ci-upstream-kasan-gce | KASAN: slab-out-of-bounds Read in read\_descriptors |
| 2023/06/17 06:10 | git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux.git for-kernelci | [177239177378](https://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux.git/log/?id=1772391773787ce9d62ec715de7817f7cb9e932f) | [f3921d4d](https://github.com/google/syzkaller/commits/f3921d4d63f97d1f1fb49a69ea85744bb7ef184b) | [.config](/text?tag=KernelConfig&x=8776b67768a3c9af) | [console log](/text?tag=CrashLog&x=12cf9b7f280000) | [report](/text?tag=CrashReport&x=139bbae3280000) | [syz](/text?tag=ReproSyz&x=14180df7280000) | [C](/text?tag=ReproC&x=13b1a137280000) |  | [[disk image](https://storage.googleapis.com/syzbot-assets/0c47a40dd633/disk-17723917.raw.xz)] [[vmlinux](https://storage.googleapis.com/syzbot-assets/0ff319b6fb50/vmlinux-17723917.xz)] [[kernel image](https://storage.googleapis.com/syzbot-assets/3ce1ea9e3b7e/Image-17723917.gz.xz)] | ci-upstream-gce-arm64 | KASAN: slab-out-of-bounds Read in read\_descriptors |
| 2023/06/17 01:35 | upstream | [40f71e7cd3c6](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?id=40f71e7cd3c6ac04293556ab0504a372393838ff) | [f3921d4d](https://github.com/google/syzkaller/commits/f3921d4d63f97d1f1fb49a69ea85744bb7ef184b) | [.config](/text?tag=KernelConfig&x=ac246111fb601aec) | [console log](/text?tag=CrashLog&x=141d2acf280000) | [report](/text?tag=CrashReport&x=1767123d280000) |  |  | [info](/text?tag=MachineInfo&x=304a5510ec8fb2c8) | [[disk image](https://storage.googleapis.com/syzbot-assets/30922ad38c58/disk-40f71e7c.raw.xz)] [[vmlinux](https://storage.googleapis.com/syzbot-assets/3bd12e7503b8/vmlinux-40f71e7c.xz)] [[kernel image](https://storage.googleapis.com/syzbot-assets/1dcd340b18d4/bzImage-40f71e7c.xz)] | ci-upstream-kasan-gce | KASAN: slab-out-of-bounds Read in read\_descriptors |
| 2023/06/16 02:50 | upstream | [b6dad5178cea](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?id=b6dad5178ceaf23f369c3711062ce1f2afc33644) | [757d26ed](https://github.com/google/syzkaller/commits/757d26edba7d7de8c564a87a262a0b1321ddf804) | [.config](/text?tag=KernelConfig&x=ac246111fb601aec) | [console log](/text?tag=CrashLog&x=1498cbab280000) | [report](/text?tag=CrashReport&x=15068e03280000) |  |  | [info](/text?tag=MachineInfo&x=449499851b57756b) | [[disk image](https://storage.googleapis.com/syzbot-assets/23addb9842bd/disk-b6dad517.raw.xz)] [[vmlinux](https://storage.googleapis.com/syzbot-assets/53a1d8a12854/vmlinux-b6dad517.xz)] [[kernel image](https://storage.googleapis.com/syzbot-assets/e77ac3950549/bzImage-b6dad517.xz)] | ci-upstream-kasan-gce | KASAN: slab-out-of-bounds Read in read\_descriptors |
| 2023/06/28 01:07 | https://github.com/google/kmsan.git master | [257152fe29be](https://github.com/google/kmsan/commits/257152fe29be882ed42f1996153aebc750e44cca) | [4cd5bb25](https://github.com/google/syzkaller/commits/4cd5bb25a2752a9a5b25597d1da34656681f07a6) | [.config](/text?tag=KernelConfig&x=c7bdd043d54243c) | [console log](/text?tag=CrashLog&x=14c65ebf280000) | [report](/text?tag=CrashReport&x=142edfaf280000) |  |  | [info](/text?tag=MachineInfo&x=9bd4b28ace4ddee4) | [[disk image](https://storage.googleapis.com/syzbot-assets/91b0a7453de1/disk-257152fe.raw.xz)] [[vmlinux](https://storage.googleapis.com/syzbot-assets/351331f6c017/vmlinux-257152fe.xz)] [[kernel image](https://storage.googleapis.com/syzbot-assets/75b8124a7743/bzImage-257152fe.xz)] | ci-upstream-kmsan-gce | KMSAN: uninit-value in read\_descriptors |
| 2023/06/26 11:16 | https://github.com/google/kmsan.git master | [e6bc8833d80f](https://github.com/google/kmsan/commits/e6bc8833d80fb695515a8144aa1dc13468db9d4d) | [09ffe269](https://github.com/google/syzkaller/commits/09ffe269727719aad37ea8145eb57fefb0097165) | [.config](/text?tag=KernelConfig&x=6a7e173060c804ee) | [console log](/text?tag=CrashLog&x=1168c73f280000) | [report](/text?tag=CrashReport&x=14ad6c8f280000) |  |  | [info](/text?tag=MachineInfo&x=431eac4fd048c55b) | [[disk image](https://storage.googleapis.com/syzbot-assets/8354b76ebe94/disk-e6bc8833.raw.xz)] [[vmlinux](https://storage.googleapis.com/syzbot-assets/727dc9e32912/vmlinux-e6bc8833.xz)] [[kernel image](https://storage.googleapis.com/syzbot-assets/37f2335dd29c/bzImage-e6bc8833.xz)] | ci-upstream-kmsan-gce | KMSAN: uninit-value in read\_descriptors |

*\* ~~Struck through~~ repros no longer work on HEAD.*


=== Content from git.kernel.org_daa6d982_20250114_225407.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=85d07c55621676d47d873d2749b88f783cd4d5a1)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=85d07c55621676d47d873d2749b88f783cd4d5a1)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=85d07c55621676d47d873d2749b88f783cd4d5a1)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=85d07c55621676d47d873d2749b88f783cd4d5a1)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Alan Stern <stern@rowland.harvard.edu> | 2023-08-04 15:10:59 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-08-08 10:45:32 +0200 |
| commit | [85d07c55621676d47d873d2749b88f783cd4d5a1](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=85d07c55621676d47d873d2749b88f783cd4d5a1) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=85d07c55621676d47d873d2749b88f783cd4d5a1)) | |
| tree | [e500742941bee4108efc5513a1e5d80b48963390](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=85d07c55621676d47d873d2749b88f783cd4d5a1) | |
| parent | [af6248afd7653924d224b3fa8843fc93fdbb93b6](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=af6248afd7653924d224b3fa8843fc93fdbb93b6) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=85d07c55621676d47d873d2749b88f783cd4d5a1&id2=af6248afd7653924d224b3fa8843fc93fdbb93b6)) | |
| download | [linux-85d07c55621676d47d873d2749b88f783cd4d5a1.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-85d07c55621676d47d873d2749b88f783cd4d5a1.tar.gz) | |

USB: core: Unite old scheme and new scheme descriptor readsIn preparation for reworking the usb\_get\_device\_descriptor() routine,
it is desirable to unite the two different code paths responsible for
initially determining endpoint 0's maximum packet size in a newly
discovered USB device. Making this determination presents a
chicken-and-egg sort of problem, in that the only way to learn the
maxpacket value is to get it from the device descriptor retrieved from
the device, but communicating with the device to retrieve a descriptor
requires us to know beforehand the ep0 maxpacket size.
In practice this problem is solved in two different ways, referred to
in hub.c as the "old scheme" and the "new scheme". The old scheme
(which is the approach recommended by the USB-2 spec) involves asking
the device to send just the first eight bytes of its device
descriptor. Such a transfer uses packets containing no more than
eight bytes each, and every USB device must have an ep0 maxpacket size
>= 8, so this should succeed. Since the bMaxPacketSize0 field of the
device descriptor lies within the first eight bytes, this is all we
need.
The new scheme is an imitation of the technique used in an early
Windows USB implementation, giving it the happy advantage of working
with a wide variety of devices (some of them at the time would not
work with the old scheme, although that's probably less true now). It
involves making an initial guess of the ep0 maxpacket size, asking the
device to send up to 64 bytes worth of its device descriptor (which is
only 18 bytes long), and then resetting the device to clear any error
condition that might have resulted from the guess being wrong. The
initial guess is determined by the connection speed; it should be
correct in all cases other than full speed, for which the allowed
values are 8, 16, 32, and 64 (in this case the initial guess is 64).
The reason for this patch is that the old- and new-scheme parts of
hub\_port\_init() use different code paths, one involving
usb\_get\_device\_descriptor() and one not, for their initial reads of
the device descriptor. Since these reads have essentially the same
purpose and are made under essentially the same circumstances, this is
illogical. It makes more sense to have both of them use a common
subroutine.
This subroutine does basically what the new scheme's code did, because
that approach is more general than the one used by the old scheme. It
only needs to know how many bytes to transfer and whether or not it is
being called for the first iteration of a retry loop (in case of
certain time-out errors). There are two main differences from the
former code:
We initialize the bDescriptorType field of the transfer buffer
to 0 before performing the transfer, to avoid possibly
accessing an uninitialized value afterward.
We read the device descriptor into a temporary buffer rather
than storing it directly into udev->descriptor, which the old
scheme implementation used to do.
Since the whole point of this first read of the device descriptor is
to determine the bMaxPacketSize0 value, that is what the new routine
returns (or an error code). The value is stored in a local variable
rather than in udev->descriptor. As a side effect, this necessitates
moving a section of code that checks the bcdUSB field for SuperSpeed
devices until after the full device descriptor has been retrieved.
Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Cc: Oliver Neukum <oneukum@suse.com>
Link: [https://lore.kernel.org/r/495cb5d4-f956-4f4a-a875-1e67e9489510@rowland.harvard.edu](https://lore.kernel.org/r/495cb5d4-f956-4f4a-a875-1e67e9489510%40rowland.harvard.edu)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=85d07c55621676d47d873d2749b88f783cd4d5a1)

| -rw-r--r-- | [drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/usb/core/hub.c?id=85d07c55621676d47d873d2749b88f783cd4d5a1) | 173 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 94 insertions, 79 deletions

| diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.cindex fcbad9e8632868..91abcd904d0448 100644--- a/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hub.c?id=af6248afd7653924d224b3fa8843fc93fdbb93b6)+++ b/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/core/hub.c?id=85d07c55621676d47d873d2749b88f783cd4d5a1)@@ -4741,6 +4741,67 @@ static int hub\_enable\_device(struct usb\_device \*udev) return hcd->driver->enable\_device(hcd, udev); } +/\*+ \* Get the bMaxPacketSize0 value during initialization by reading the+ \* device's device descriptor. Since we don't already know this value,+ \* the transfer is unsafe and it ignores I/O errors, only testing for+ \* reasonable received values.+ \*+ \* For "old scheme" initialization, size will be 8 so we read just the+ \* start of the device descriptor, which should work okay regardless of+ \* the actual bMaxPacketSize0 value. For "new scheme" initialization,+ \* size will be 64 (and buf will point to a sufficiently large buffer),+ \* which might not be kosher according to the USB spec but it's what+ \* Windows does and what many devices expect.+ \*+ \* Returns: bMaxPacketSize0 or a negative error code.+ \*/+static int get\_bMaxPacketSize0(struct usb\_device \*udev,+ struct usb\_device\_descriptor \*buf, int size, bool first\_time)+{+ int i, rc;++ /\*+ \* Retry on all errors; some devices are flakey.+ \* 255 is for WUSB devices, we actually need to use+ \* 512 (WUSB1.0[4.8.1]).+ \*/+ for (i = 0; i < GET\_MAXPACKET0\_TRIES; ++i) {+ /\* Start with invalid values in case the transfer fails \*/+ buf->bDescriptorType = buf->bMaxPacketSize0 = 0;+ rc = usb\_control\_msg(udev, usb\_rcvaddr0pipe(),+ USB\_REQ\_GET\_DESCRIPTOR, USB\_DIR\_IN,+ USB\_DT\_DEVICE << 8, 0,+ buf, size,+ initial\_descriptor\_timeout);+ switch (buf->bMaxPacketSize0) {+ case 8: case 16: case 32: case 64: case 255:+ if (buf->bDescriptorType == USB\_DT\_DEVICE) {+ rc = buf->bMaxPacketSize0;+ break;+ }+ fallthrough;+ default:+ if (rc >= 0)+ rc = -EPROTO;+ break;+ }++ /\*+ \* Some devices time out if they are powered on+ \* when already connected. They need a second+ \* reset, so return early. But only on the first+ \* attempt, lest we get into a time-out/reset loop.+ \*/+ if (rc > 0 || (rc == -ETIMEDOUT && first\_time &&+ udev->speed > USB\_SPEED\_FULL))+ break;+ }+ return rc;+}++#define GET\_DESCRIPTOR\_BUFSIZE 64+ /\* Reset device, (re)assign address, get device descriptor. \* Device connection must be stable, no more debouncing needed. \* Returns device in USB\_STATE\_ADDRESS, except on error.@@ -4765,6 +4826,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, int devnum = udev->devnum; const char \*driver\_name; bool do\_new\_scheme;+ int maxp0;+ struct usb\_device\_descriptor \*buf;++ buf = kmalloc(GET\_DESCRIPTOR\_BUFSIZE, GFP\_NOIO);+ if (!buf)+ return -ENOMEM;  /\* root hub ports have a slightly longer reset period \* (from USB 2.0 spec, section 7.1.7.5)@@ -4884,9 +4951,6 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, }  if (do\_new\_scheme) {- struct usb\_device\_descriptor \*buf;- int r = 0;- retval = hub\_enable\_device(udev); if (retval < 0) { dev\_err(&udev->dev,@@ -4895,52 +4959,8 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, goto fail; } -#define GET\_DESCRIPTOR\_BUFSIZE 64- buf = kmalloc(GET\_DESCRIPTOR\_BUFSIZE, GFP\_NOIO);- if (!buf) {- retval = -ENOMEM;- continue;- }-- /\* Retry on all errors; some devices are flakey.- \* 255 is for WUSB devices, we actually need to use- \* 512 (WUSB1.0[4.8.1]).- \*/- for (operations = 0; operations < GET\_MAXPACKET0\_TRIES;- ++operations) {- buf->bMaxPacketSize0 = 0;- r = usb\_control\_msg(udev, usb\_rcvaddr0pipe(),- USB\_REQ\_GET\_DESCRIPTOR, USB\_DIR\_IN,- USB\_DT\_DEVICE << 8, 0,- buf, GET\_DESCRIPTOR\_BUFSIZE,- initial\_descriptor\_timeout);- switch (buf->bMaxPacketSize0) {- case 8: case 16: case 32: case 64: case 255:- if (buf->bDescriptorType ==- USB\_DT\_DEVICE) {- r = 0;- break;- }- fallthrough;- default:- if (r == 0)- r = -EPROTO;- break;- }- /\*- \* Some devices time out if they are powered on- \* when already connected. They need a second- \* reset. But only on the first attempt,- \* lest we get into a time out/reset loop- \*/- if (r == 0 || (r == -ETIMEDOUT &&- retries == 0 &&- udev->speed > USB\_SPEED\_FULL))- break;- }- udev->descriptor.bMaxPacketSize0 =- buf->bMaxPacketSize0;- kfree(buf);+ maxp0 = get\_bMaxPacketSize0(udev, buf,+ GET\_DESCRIPTOR\_BUFSIZE, retries == 0);  retval = hub\_port\_reset(hub, port1, udev, delay, false); if (retval < 0) /\* error or disconnect \*/@@ -4951,14 +4971,13 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, retval = -ENODEV; goto fail; }- if (r) {- if (r != -ENODEV)+ if (maxp0 < 0) {+ if (maxp0 != -ENODEV) dev\_err(&udev->dev, "device descriptor read/64, error %d\n",- r);- retval = -EMSGSIZE;+ maxp0);+ retval = maxp0; continue; }-#undef GET\_DESCRIPTOR\_BUFSIZE }  /\*@@ -5004,19 +5023,17 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, break; } - retval = usb\_get\_device\_descriptor(udev, 8);- if (retval < 8) {+ /\* !do\_new\_scheme || wusb \*/+ maxp0 = get\_bMaxPacketSize0(udev, buf, 8, retries == 0);+ if (maxp0 < 0) {+ retval = maxp0; if (retval != -ENODEV) dev\_err(&udev->dev, "device descriptor read/8, error %d\n", retval);- if (retval >= 0)- retval = -EMSGSIZE; } else { u32 delay; - retval = 0;- delay = udev->parent->hub\_delay; udev->hub\_delay = min\_t(u32, delay, USB\_TP\_TRANSMISSION\_DELAY\_MAX);@@ -5033,27 +5050,10 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, if (retval) goto fail; - /\*- \* Some superspeed devices have finished the link training process- \* and attached to a superspeed hub port, but the device descriptor- \* got from those devices show they aren't superspeed devices. Warm- \* reset the port attached by the devices can fix them.- \*/- if ((udev->speed >= USB\_SPEED\_SUPER) &&- (le16\_to\_cpu(udev->descriptor.bcdUSB) < 0x0300)) {- dev\_err(&udev->dev, "got a wrong device descriptor, "- "warm reset device\n");- hub\_port\_reset(hub, port1, udev,- HUB\_BH\_RESET\_TIME, true);- retval = -EINVAL;- goto fail;- }-- if (udev->descriptor.bMaxPacketSize0 == 0xff ||- udev->speed >= USB\_SPEED\_SUPER)+ if (maxp0 == 0xff || udev->speed >= USB\_SPEED\_SUPER) i = 512; else- i = udev->descriptor.bMaxPacketSize0;+ i = maxp0; if (usb\_endpoint\_maxp(&udev->ep0.desc) != i) { if (udev->speed == USB\_SPEED\_LOW || !(i == 8 || i == 16 || i == 32 || i == 64)) {@@ -5079,6 +5079,20 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, goto fail; } + /\*+ \* Some superspeed devices have finished the link training process+ \* and attached to a superspeed hub port, but the device descriptor+ \* got from those devices show they aren't superspeed devices. Warm+ \* reset the port attached by the devices can fix them.+ \*/+ if ((udev->speed >= USB\_SPEED\_SUPER) &&+ (le16\_to\_cpu(udev->descriptor.bcdUSB) < 0x0300)) {+ dev\_err(&udev->dev, "got a wrong device descriptor, warm reset device\n");+ hub\_port\_reset(hub, port1, udev, HUB\_BH\_RESET\_TIME, true);+ retval = -EINVAL;+ goto fail;+ }+ usb\_detect\_quirks(udev);  if (udev->wusb == 0 && le16\_to\_cpu(udev->descriptor.bcdUSB) >= 0x0201) {@@ -5101,6 +5115,7 @@ fail: hub\_port\_disable(hub, port1, 0); update\_devnum(udev, devnum); /\* for disconnect processing \*/ }+ kfree(buf); return retval; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 22:52:44 +0000


