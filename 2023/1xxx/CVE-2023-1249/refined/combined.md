=== Content from patchwork.kernel.org_949de10e_20250114_213910.html ===

Toggle navigation

[Patchwork](/)
Linux FS Development

* [Patches](/project/linux-fsdevel/list/)
* [Bundles](/project/linux-fsdevel/bundles/)
* [About this project](/project/linux-fsdevel/)

* [Login](/user/login/)
* [Register](/register/)
* [Mail settings](/mail/)

12731028

[diff](/project/linux-fsdevel/patch/87iltzn3nd.fsf_-_%40email.froward.int.ebiederm.org/raw/ "Download patch diff")
[mbox](/project/linux-fsdevel/patch/87iltzn3nd.fsf_-_%40email.froward.int.ebiederm.org/mbox/ "Download patch mbox")
[series](/series/610125/mbox/ "Download patch mbox with dependencies")
# [5/5] coredump: Use the vma snapshot in fill\_files\_note

| Message ID | 87iltzn3nd.fsf\_-\_@email.froward.int.ebiederm.org ([mailing list archive](https://lore.kernel.org/r/87iltzn3nd.fsf_-_%40email.froward.int.ebiederm.org)) |
| --- | --- |
| State | New, archived |
| Headers | show ``` Return-Path: <linux-fsdevel-owner@kernel.org> X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on 	aws-us-west-2-korg-lkml-1.web.codeaurora.org Received: from vger.kernel.org (vger.kernel.org [23.128.96.18]) 	by smtp.lore.kernel.org (Postfix) with ESMTP id 3696CC433EF 	for <linux-fsdevel@archiver.kernel.org>;  Mon, 31 Jan 2022 18:48:00 +0000 (UTC) Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand         id S1357895AbiAaSr7 (ORCPT         <rfc822;linux-fsdevel@archiver.kernel.org>);         Mon, 31 Jan 2022 13:47:59 -0500 Received: from out02.mta.xmission.com ([166.70.13.232]:59644 "EHLO         out02.mta.xmission.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org         with ESMTP id S1357716AbiAaSro (ORCPT         <rfc822;linux-fsdevel@vger.kernel.org>);         Mon, 31 Jan 2022 13:47:44 -0500 Received: from in02.mta.xmission.com ([166.70.13.52]:42370)         by out02.mta.xmission.com with esmtps  (TLS1.3) tls  TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384         (Exim 4.93)         (envelope-from <ebiederm@xmission.com>)         id 1nEbiI-00HXSu-1F; Mon, 31 Jan 2022 11:47:43 -0700 Received: from ip68-110-24-146.om.om.cox.net ([68.110.24.146]:56392  helo=email.froward.int.ebiederm.org.xmission.com)         by in02.mta.xmission.com with esmtpsa  (TLS1.3) tls  TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384         (Exim 4.93)         (envelope-from <ebiederm@xmission.com>)         id 1nEbiG-007mQf-FJ; Mon, 31 Jan 2022 11:47:41 -0700 From: "Eric W. Biederman" <ebiederm@xmission.com> To: Jann Horn <jannh@google.com> Cc: Matthew Wilcox <willy@infradead.org>,         linux-fsdevel@vger.kernel.org, linux-kernel@vger.kernel.org,         Alexander Viro <viro@zeniv.linux.org.uk>,         Denys Vlasenko <vda.linux@googlemail.com>,         Kees Cook <keescook@chromium.org>,         Vlastimil Babka <vbabka@suse.cz>,         "Liam R . Howlett" <liam.howlett@oracle.com> References: <20220131153740.2396974-1-willy@infradead.org>         <871r0nriy4.fsf@email.froward.int.ebiederm.org>         <YfgKw5z2uswzMVRQ@casper.infradead.org>         <877dafq3bw.fsf@email.froward.int.ebiederm.org>         <YfgPwPvopO1aqcVC@casper.infradead.org>         <CAG48ez3MCs8d8hjBfRSQxwUTW3o64iaSwxF=UEVtk+SEme0chQ@mail.gmail.com>         <87bkzroica.fsf_-_@email.froward.int.ebiederm.org> Date: Mon, 31 Jan 2022 12:47:34 -0600 In-Reply-To: <87bkzroica.fsf_-_@email.froward.int.ebiederm.org> (Eric         W. Biederman's message of "Mon, 31 Jan 2022 12:44:53 -0600") Message-ID: <87iltzn3nd.fsf_-_@email.froward.int.ebiederm.org> User-Agent: Gnus/5.13 (Gnus v5.13) Emacs/27.1 (gnu/linux) MIME-Version: 1.0 Content-Type: text/plain X-XM-SPF:   eid=1nEbiG-007mQf-FJ;;;mid=<87iltzn3nd.fsf_-_@email.froward.int.ebiederm.org>;;;hst=in02.mta.xmission.com;;;ip=68.110.24.146;;;frm=ebiederm@xmission.com;;;spf=neutral X-XM-AID: U2FsdGVkX1/oGpZ9UFLzbnQWhkV7XiMYkWr0BtePZic= X-SA-Exim-Connect-IP: 68.110.24.146 X-SA-Exim-Mail-From: ebiederm@xmission.com Subject: [PATCH 5/5] coredump: Use the vma snapshot in fill_files_note X-SA-Exim-Version: 4.2.1 (built Sat, 08 Feb 2020 21:53:50 +0000) X-SA-Exim-Scanned: Yes (on in02.mta.xmission.com) Precedence: bulk List-ID: <linux-fsdevel.vger.kernel.org> X-Mailing-List: linux-fsdevel@vger.kernel.org ``` |
| Series | [Fix fill\_files\_note](/project/linux-fsdevel/list/?series=610125) | expand  * [[0/5] Fix fill\_files\_note](/project/linux-fsdevel/cover/87bkzroica.fsf_-_%40email.froward.int.ebiederm.org/) * [[1/5] coredump: Move definition of struct coredump\_params into coredump.h](/project/linux-fsdevel/patch/875ypzoiae.fsf_-_%40email.froward.int.ebiederm.org/) * [[2/5] coredump: Snapshot the vmas in do\_coredump](/project/linux-fsdevel/patch/87zgnbn3pd.fsf_-_%40email.froward.int.ebiederm.org/) * [[3/5] coredump: Remove the WARN\_ON in dump\_vma\_snapshot](/project/linux-fsdevel/patch/87tudjn3or.fsf_-_%40email.froward.int.ebiederm.org/) * [[4/5] coredump/elf: Pass coredump\_params into fill\_note\_info](/project/linux-fsdevel/patch/87o83rn3ny.fsf_-_%40email.froward.int.ebiederm.org/) * [5/5] coredump: Use the vma snapshot in fill\_files\_note |

## Commit Message

[Eric W. Biederman](/project/linux-fsdevel/list/?submitter=156)
Jan. 31, 2022, 6:47 p.m. UTC
```

Matthew Wilcox reported that there is a missing mmap_lock in
file_files_note that could possibly lead to a user after free.

Solve this by using the existing vma snapshot for consistency
and to avoid the need to take the mmap_lock anywhere in the
coredump code except for dump_vma_snapshot.

Update the dump_vma_snapshot to capture vm_pgoff and vm_file
that are neeeded by fill_files_note.

Add free_vma_snapshot to free the captured values of vm_file.

Reported-by: Matthew Wilcox <willy@infradead.org>
Link: https://lkml.kernel.org/r/20220131153740.2396974-1-willy@infradead.org
Cc: stable@vger.kernel.org
Fixes: a07279c9a8cd ("binfmt_elf, binfmt_elf_fdpic: use a VMA list snapshot")
Fixes: 2aa362c49c31 ("coredump: extend core dump note section to contain file names of mapped files")
Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
---
 fs/binfmt_elf.c          | 19 ++++++++++---------
 fs/coredump.c            | 22 +++++++++++++++++++++-
 include/linux/coredump.h |  2 ++
 3 files changed, 33 insertions(+), 10 deletions(-)

```
## Comments

[Jann Horn](/project/linux-fsdevel/list/?submitter=168903)
Feb. 1, 2022, 7:02 p.m. UTC | [#1](/comment/24720141/)
```

On Mon, Jan 31, 2022 at 7:47 PM Eric W. Biederman <ebiederm@xmission.com> wrote:
> Matthew Wilcox reported that there is a missing mmap_lock in
> file_files_note that could possibly lead to a user after free.
>
> Solve this by using the existing vma snapshot for consistency
> and to avoid the need to take the mmap_lock anywhere in the
> coredump code except for dump_vma_snapshot.
>
> Update the dump_vma_snapshot to capture vm_pgoff and vm_file
> that are neeeded by fill_files_note.
>
> Add free_vma_snapshot to free the captured values of vm_file.
>
> Reported-by: Matthew Wilcox <willy@infradead.org>
> Link: https://lkml.kernel.org/r/20220131153740.2396974-1-willy@infradead.org
> Cc: stable@vger.kernel.org
> Fixes: a07279c9a8cd ("binfmt_elf, binfmt_elf_fdpic: use a VMA list snapshot")
> Fixes: 2aa362c49c31 ("coredump: extend core dump note section to contain file names of mapped files")
> Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
[...]
> +static int fill_files_note(struct memelfnote *note, struct coredump_params *cprm)
>  {
>         struct mm_struct *mm = current->mm;
> -       struct vm_area_struct *vma;
>         unsigned count, size, names_ofs, remaining, n;
>         user_long_t *data;
>         user_long_t *start_end_ofs;
>         char *name_base, *name_curpos;
> +       int i;
>
>         /* *Estimated* file count and total data size needed */
>         count = mm->map_count;

This function is still looking at mm->map_count in two spots, please
change those spots to also look at cprm->vma_count. In particular the
second one looks like it can cause memory corruption if the map_count
changed since we created the snapshot.

[...]
> +static void free_vma_snapshot(struct coredump_params *cprm)
> +{
> +       if (cprm->vma_meta) {
> +               int i;
> +               for (i = 0; i < cprm->vma_count; i++) {
> +                       struct file *file = cprm->vma_meta[i].file;
> +                       if (file)
> +                               fput(file);
> +               }
> +               kvfree(cprm->vma_meta);
> +               cprm->vma_meta = NULL;

(this NULL write is superfluous, but it also doesn't hurt)
> +       }
> +}

```

[Eric W. Biederman](/project/linux-fsdevel/list/?submitter=156)
Feb. 2, 2022, 2:46 p.m. UTC | [#2](/comment/24721442/)
```

Jann Horn <jannh@google.com> writes:
> On Mon, Jan 31, 2022 at 7:47 PM Eric W. Biederman <ebiederm@xmission.com> wrote:
>> Matthew Wilcox reported that there is a missing mmap_lock in
>> file_files_note that could possibly lead to a user after free.
>>
>> Solve this by using the existing vma snapshot for consistency
>> and to avoid the need to take the mmap_lock anywhere in the
>> coredump code except for dump_vma_snapshot.
>>
>> Update the dump_vma_snapshot to capture vm_pgoff and vm_file
>> that are neeeded by fill_files_note.
>>
>> Add free_vma_snapshot to free the captured values of vm_file.
>>
>> Reported-by: Matthew Wilcox <willy@infradead.org>
>> Link: https://lkml.kernel.org/r/20220131153740.2396974-1-willy@infradead.org
>> Cc: stable@vger.kernel.org
>> Fixes: a07279c9a8cd ("binfmt_elf, binfmt_elf_fdpic: use a VMA list snapshot")
>> Fixes: 2aa362c49c31 ("coredump: extend core dump note section to contain file names of mapped files")
>> Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
> [...]
>> +static int fill_files_note(struct memelfnote *note, struct coredump_params *cprm)
>>  {
>>         struct mm_struct *mm = current->mm;
>> -       struct vm_area_struct *vma;
>>         unsigned count, size, names_ofs, remaining, n;
>>         user_long_t *data;
>>         user_long_t *start_end_ofs;
>>         char *name_base, *name_curpos;
>> +       int i;
>>
>>         /* *Estimated* file count and total data size needed */
>>         count = mm->map_count;
>
> This function is still looking at mm->map_count in two spots, please
> change those spots to also look at cprm->vma_count. In particular the
> second one looks like it can cause memory corruption if the map_count
> changed since we created the snapshot.

Could catch I will fix that.  Correcting it not to use mm->map_count
looks like a fundamental part of the fix, and I missed it.  Oops!
> [...]
>> +static void free_vma_snapshot(struct coredump_params *cprm)
>> +{
>> +       if (cprm->vma_meta) {
>> +               int i;
>> +               for (i = 0; i < cprm->vma_count; i++) {
>> +                       struct file *file = cprm->vma_meta[i].file;
>> +                       if (file)
>> +                               fput(file);
>> +               }
>> +               kvfree(cprm->vma_meta);
>> +               cprm->vma_meta = NULL;
>
> (this NULL write is superfluous, but it also doesn't hurt)

Agreed.  It just makes the possible failure modes nicer.

Eric

```

12731028

[diff](/project/linux-fsdevel/patch/87iltzn3nd.fsf_-_%40email.froward.int.ebiederm.org/raw/ "Download patch diff")
[mbox](/project/linux-fsdevel/patch/87iltzn3nd.fsf_-_%40email.froward.int.ebiederm.org/mbox/ "Download patch mbox")
[series](/series/610125/mbox/ "Download patch mbox with dependencies")
## Patch

```

diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
index 272032b1f9a2..5fcaa01d211e 100644
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -1619,14 +1619,14 @@  static void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,
  *   long file_ofs
  * followed by COUNT filenames in ASCII: "FILE1" NUL "FILE2" NUL...
  */
-static int fill_files_note(struct memelfnote *note)
+static int fill_files_note(struct memelfnote *note, struct coredump_params *cprm)
 {
 	struct mm_struct *mm = current->mm;
-	struct vm_area_struct *vma;
 	unsigned count, size, names_ofs, remaining, n;
 	user_long_t *data;
 	user_long_t *start_end_ofs;
 	char *name_base, *name_curpos;
+	int i;

 	/* *Estimated* file count and total data size needed */
 	count = mm->map_count;
@@ -1651,11 +1651,12 @@  static int fill_files_note(struct memelfnote *note)
 	name_base = name_curpos = ((char *)data) + names_ofs;
 	remaining = size - names_ofs;
 	count = 0;
-	for (vma = mm->mmap; vma != NULL; vma = vma->vm_next) {
+	for (i = 0; i < cprm->vma_count; i++) {
+		struct core_vma_metadata *m = &cprm->vma_meta[i];
 		struct file *file;
 		const char *filename;

-		file = vma->vm_file;
+		file = m->file;
 		if (!file)
 			continue;
 		filename = file_path(file, name_curpos, remaining);
@@ -1675,9 +1676,9 @@  static int fill_files_note(struct memelfnote *note)
 		memmove(name_curpos, filename, n);
 		name_curpos += n;

-		*start_end_ofs++ = vma->vm_start;
-		*start_end_ofs++ = vma->vm_end;
-		*start_end_ofs++ = vma->vm_pgoff;
+		*start_end_ofs++ = m->start;
+		*start_end_ofs++ = m->end;
+		*start_end_ofs++ = m->pgoff;
 		count++;
 	}

@@ -1887,7 +1888,7 @@  static int fill_note_info(struct elfhdr *elf, int phdrs,
 	fill_auxv_note(&info->auxv, current->mm);
 	info->size += notesize(&info->auxv);

-	if (fill_files_note(&info->files) == 0)
+	if (fill_files_note(&info->files, cprm) == 0)
 		info->size += notesize(&info->files);

 	return 1;
@@ -2076,7 +2077,7 @@  static int fill_note_info(struct elfhdr *elf, int phdrs,
 	fill_auxv_note(info->notes + 3, current->mm);
 	info->numnote = 4;

-	if (fill_files_note(info->notes + info->numnote) == 0) {
+	if (fill_files_note(info->notes + info->numnote, cprm) == 0) {
 		info->notes_files = info->notes + info->numnote;
 		info->numnote++;
 	}
diff --git a/fs/coredump.c b/fs/coredump.c
index c5e7d63525c6..6a97a8ea7295 100644
--- a/fs/coredump.c
+++ b/fs/coredump.c
@@ -54,6 +54,7 @@
 #include <trace/events/sched.h>

 static bool dump_vma_snapshot(struct coredump_params *cprm);
+static void free_vma_snapshot(struct coredump_params *cprm);

 static int core_uses_pid;
 static unsigned int core_pipe_limit;
@@ -764,7 +765,7 @@  void do_coredump(const kernel_siginfo_t *siginfo)
 			dump_emit(&cprm, "", 1);
 		}
 		file_end_write(cprm.file);
-		kvfree(cprm.vma_meta);
+		free_vma_snapshot(&cprm);
 	}
 	if (ispipe && core_pipe_limit)
 		wait_for_dump_helpers(cprm.file);
@@ -1085,6 +1086,20 @@  static struct vm_area_struct *next_vma(struct vm_area_struct *this_vma,
 	return gate_vma;
 }

+static void free_vma_snapshot(struct coredump_params *cprm)
+{
+	if (cprm->vma_meta) {
+		int i;
+		for (i = 0; i < cprm->vma_count; i++) {
+			struct file *file = cprm->vma_meta[i].file;
+			if (file)
+				fput(file);
+		}
+		kvfree(cprm->vma_meta);
+		cprm->vma_meta = NULL;
+	}
+}
+
 /*
  * Under the mmap_lock, take a snapshot of relevant information about the task's
  * VMAs.
@@ -1121,6 +1136,11 @@  static bool dump_vma_snapshot(struct coredump_params *cprm)
 		m->end = vma->vm_end;
 		m->flags = vma->vm_flags;
 		m->dump_size = vma_dump_size(vma, cprm->mm_flags);
+		m->pgoff = vma->vm_pgoff;
+
+		m->file = vma->vm_file;
+		if (m->file)
+			get_file(m->file);

 		cprm->vma_data_size += m->dump_size;
 	}
diff --git a/include/linux/coredump.h b/include/linux/coredump.h
index 7d05370e555e..08a1d3e7e46d 100644
--- a/include/linux/coredump.h
+++ b/include/linux/coredump.h
@@ -12,6 +12,8 @@  struct core_vma_metadata {
 	unsigned long start, end;
 	unsigned long flags;
 	unsigned long dump_size;
+	unsigned long pgoff;
+	struct file   *file;
 };

 struct coredump_params {

```

[patchwork](http://jk.ozlabs.org/projects/patchwork/)
patch tracking system | version v2.2.6 | [about patchwork](/about/)



=== Content from packetstormsecurity.com_eb2c7440_20250114_213908.html ===

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

![](/logos/linegray.png)

 [About](/help/view/4) |
[Terms](/tos/) |
[Copyright](/help/view/7) |
[Privacy](/help/view/6) |
[BlueSky](https://bsky.app/profile/packetstorm.bsky.social) |
[X](https://x.com/packet_storm) |
[Mastodon](https://infosec.exchange/%40packet_storm/)


