=== Content from github.com_769a6f1a_20250114_192722.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Fmaster%2Fsys%2Fnet%2Fgnrc%2Fnetwork_layer%2Fsixlowpan%2Ffrag%2Fsfr%2Fgnrc_sixlowpan_frag_sfr.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Fmaster%2Fsys%2Fnet%2Fgnrc%2Fnetwork_layer%2Fsixlowpan%2Ffrag%2Fsfr%2Fgnrc_sixlowpan_frag_sfr.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  388](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_1b299d27_20250114_192720.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Ff41b4b67b6affca0a8b32edced7f51088696869a%2Fsys%2Fnet%2Fgnrc%2Fnetwork_layer%2Fsixlowpan%2Ffrag%2Fsfr%2Fgnrc_sixlowpan_frag_sfr.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Ff41b4b67b6affca0a8b32edced7f51088696869a%2Fsys%2Fnet%2Fgnrc%2Fnetwork_layer%2Fsixlowpan%2Ffrag%2Fsfr%2Fgnrc_sixlowpan_frag_sfr.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  388](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

## Files

 f41b4b6
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a)
2. /[sys](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys)
3. /[net](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net)
4. /[gnrc](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc)
5. /[network\_layer](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer)
6. /[sixlowpan](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan)
7. /[frag](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag)
8. /[sfr](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr)
/
# gnrc\_sixlowpan\_frag\_sfr.c

Copy path Blame  Blame
## Latest commit

## History

[History](/RIOT-OS/RIOT/commits/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c)1873 lines (1726 loc) · 70.5 KB f41b4b6
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a)
2. /[sys](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys)
3. /[net](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net)
4. /[gnrc](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc)
5. /[network\_layer](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer)
6. /[sixlowpan](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan)
7. /[frag](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag)
8. /[sfr](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr)
/
# gnrc\_sixlowpan\_frag\_sfr.c

Top
## File metadata and controls

* Code
* Blame

1873 lines (1726 loc) · 70.5 KB[Raw](https://github.com/RIOT-OS/RIOT/raw/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* Copyright (C) 2019 Freie Universität Berlin \* \* This file is subject to the terms and conditions of the GNU Lesser \* General Public License v2.1. See the file LICENSE in the top level \* directory for more details. \*/
/\*\* \* @{ \* \* @file \* @author Martine Lenders <m.lenders@fu-berlin.de> \*/
#include <stddef.h>
#include "irq.h"#include "kernel\_defines.h"#ifdef MODULE\_GNRC\_IPV6\_NIB#include "net/ipv6/addr.h"#endif#ifdef MODULE\_GNRC\_IPV6#include "net/ipv6/hdr.h"#endif#include "net/gnrc/neterr.h"#include "net/gnrc/netif/internal.h"#include "net/gnrc/netif/pktq.h"#include "net/gnrc/pkt.h"#include "net/gnrc/sixlowpan.h"#include "net/gnrc/sixlowpan/config.h"#include "net/gnrc/sixlowpan/frag/fb.h"#include "net/gnrc/sixlowpan/frag/rb.h"#include "net/gnrc/sixlowpan/frag/vrb.h"#include "net/gnrc/tx\_sync.h"#include "net/sixlowpan/sfr.h"#include "thread.h"#include "unaligned.h"#include "xtimer.h"
#include "net/gnrc/sixlowpan/frag/sfr.h"#include "net/gnrc/sixlowpan/frag/sfr/congure.h"
#define ENABLE\_DEBUG 0#include "debug.h"
#define FRAG\_DESCS\_POOL\_SIZE (CONFIG\_GNRC\_SIXLOWPAN\_FRAG\_FB\_SIZE \* \ CONFIG\_GNRC\_SIXLOWPAN\_SFR\_MAX\_WIN\_SIZE)#define FRAME\_QUEUE\_POOL\_SIZE (FRAG\_DESCS\_POOL\_SIZE + \ CONFIG\_GNRC\_SIXLOWPAN\_FRAG\_VRB\_SIZE)
typedef struct { congure\_snd\_msg\_t super; /\*\*< CongURE message parent \*/ /\*\* \* @brief Acknowledgment request flag, sequence number, and fragment size \*/ uint16\_t ar\_seq\_fs; uint16\_t offset; /\*\*< offset of the fragment \*/} \_frag\_desc\_t;
typedef struct { clist\_node\_t super; /\*\*< list parent instance \*/ gnrc\_pktsnip\_t \*frame; /\*\*< frame in the queue \*/ uint8\_t datagram\_tag; /\*\*< tag for identification \*/ uint8\_t page; /\*\*< parsing page context for the frame \*/} \_frame\_queue\_t;
typedef struct { enum { \_UNDEF = 0, \_RB, \_VRB, } type; union { gnrc\_sixlowpan\_frag\_rb\_base\_t \*base; gnrc\_sixlowpan\_frag\_rb\_t \*rb; gnrc\_sixlowpan\_frag\_vrb\_t \*vrb; } entry;} \_generic\_rb\_entry\_t;
#ifdef MODULE\_GNRC\_IPV6\_NIBstatic char addr\_str[IPV6\_ADDR\_MAX\_STR\_LEN];#else /\* MODULE\_GNRC\_IPV6\_NIB \*/static char addr\_str[GNRC\_NETIF\_HDR\_L2ADDR\_PRINT\_LEN];#endif /\* MODULE\_GNRC\_IPV6\_NIB \*/
static evtimer\_msg\_t \_arq\_timer;static xtimer\_t \_if\_gap\_timer = { 0 };static msg\_t \_if\_gap\_msg = { .type = GNRC\_SIXLOWPAN\_FRAG\_SFR\_INTER\_FRAG\_GAP\_MSG };static uint32\_t \_last\_frame\_sent = 0U;
static \_frag\_desc\_t \_frag\_descs\_pool[FRAG\_DESCS\_POOL\_SIZE];static \_frame\_queue\_t \_frame\_queue\_pool[FRAME\_QUEUE\_POOL\_SIZE];
static clist\_node\_t \_frag\_descs\_free;static clist\_node\_t \_frame\_queue\_free;static clist\_node\_t \_frame\_queue;
static const gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t \_full\_bitmap = { .u32 = UINT32\_MAX };static const gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t \_null\_bitmap = { .u32 = 0U };
static gnrc\_sixlowpan\_frag\_sfr\_stats\_t \_stats;
/\*\* \* @brief Converts a @ref sys\_bitmap based bitmap to a \* gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t \* \* @param[in] bitmap A @ref sys\_bitmap \* \* @return A gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t. \*/static inline gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t \*\_get\_bitmap(gnrc\_sixlowpan\_frag\_rb\_t \*frag\_rb);
/\*\* \* @brief Checks if fragment represented by a fragment descriptor requested an \* ACK \*/static inline bool \_frag\_ack\_req(\_frag\_desc\_t \*frag);/\*\* \* @brief Returns sequence number for fragment represented by fragment \* descriptor \*/static inline uint8\_t \_frag\_seq(\_frag\_desc\_t \*frag);
/\*\* \* @brief Returns fragment size for fragment represented by fragment \* descriptor \*/static inline uint16\_t \_frag\_size(\_frag\_desc\_t \*frag);
/\*\* \* @brief Cleans up a fragmentation buffer entry and all state related to its \* datagram. \* \* @param[in] fbuf A fragmentation buffer entry \* @param[in] error An errno to provide to an upper layer as the reason for why \* gnrc\_sixlowpan\_frag\_fb\_t::pkt of @p fbuf was released. \*/static void \_clean\_up\_fbuf(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, int error);
/\*\* \* @brief Send first fragment. \* \* @param[in] netif Network interface to send fragment over \* @param[in] fbuf Fragmentation buffer for the datagram to fragment \* @param[in] page Current 6Lo dispatch parsing page. \* @param[in,out] tx\_sync Packet snip used to synchronize with transmission, if gnrc\_tx\_sync is \* used \* \* @return Size of the fragment \*/static uint16\_t \_send\_1st\_fragment(gnrc\_netif\_t \*netif, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, unsigned page, gnrc\_pktsnip\_t \*\*tx\_sync);
/\*\* \* @brief Send subsequent fragment. \* \* @param[in] netif Network interface to send fragment over \* @param[in] fbuf Fragmentation buffer for the datagram to fragment \* @param[in] page Current 6Lo dispatch parsing page. \* @param[in,out] tx\_sync Packet snip used to synchronize with transmission, if gnrc\_tx\_sync is \* used \* \* @return Size of the fragment \*/static uint16\_t \_send\_nth\_fragment(gnrc\_netif\_t \*netif, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, unsigned page, gnrc\_pktsnip\_t \*\*tx\_sync);
/\*\* \* @brief Send a abort pseudo fragment for datagram identified by @p tag \* \* @param[in] pkt Datagram that is to be aborted. \* @param[in] fbuf Fragmentation buffer for @p pkt. \* @param[in] req\_ack Request ACK for pseudo fragment from receive \* @param[in] page Current 6Lo dispatch parsing page. \* \* @return true, if abort pseudo fragment was sent. \* @return false, if abort pseudo fragment was unable to be sent. \*/static bool \_send\_abort\_frag(gnrc\_pktsnip\_t \*pkt, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, bool req\_ack, unsigned page);
/\*\* \* @brief Adapts currently sent number of fragments to current window size \* \* Balances `fbuf->sfr.window` with `fbuf->sfr.congure->cwnd` \* \* @param[in] fbuf Fragmentation buffer to adapt window for \*/static void \_shrink\_window(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf);
/\*\* \* @brief Re-send a fragment \* \* @param[in] node The fragment descriptor for the fragment to be \* resend \* @param[in] fbuf\_ptr Fragmentation buffer for the datagram to fragment \* \* Used as a `clist\_foreach()` iterator function \* \* return true when fragment was resent \* return false on error \*/static int \_resend\_frag(clist\_node\_t \*node, void \*fbuf\_ptr);
/\*\* \* @brief Retry to send the complete datagram \* \* @param[in] fbuf Fragmentation buffer for the datagram \*/static void \_retry\_datagram(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf);
/\*\* \* @brief Cleans up state for the causing RFRAG and optionally also sends an \* abort ACK (NULL-bitmap ACK). \* \* @param[in] pkt The packet causing the abort. Will be released \* by this function. gnrc\_pktsnip\_t::data of @p pkt is \* expected to point to an RFRAG packet. \* @param[in] entry (Virtual) reassembly buffer entry to abort. \* @param[in] netif\_hdr NETIF header of @p pkt. \* @param[in] send\_ack Send an abort ACK. \*/static void \_abort\_rb(gnrc\_pktsnip\_t \*pkt, \_generic\_rb\_entry\_t \*entry, gnrc\_netif\_hdr\_t \*netif\_hdr, bool send\_ack);
/\*\* \* @brief Sends an RFRAG-ACK \* \* @param[in] netif Network interface to send ACK over \* @param[in] dst Destination address of ACK. \* @param[in] dst\_len Length of @p dst. \* @param[in] rfrag The RFRAG to ACK \* @param[in] bitmap The bitmap for the ACK. \*/static void \_send\_ack(gnrc\_netif\_t \*netif, const uint8\_t \*dst, uint8\_t dst\_len, const sixlowpan\_sfr\_t \*rfrag, const uint8\_t \*bitmap);
/\*\* \* @brief Schedule next frame (RFRAG or RFRAG-ACK) with \* @ref GNRC\_SIXLOWPAN\_FRAG\_SFR\_INTER\_FRAG\_GAP\_MSG \* \* @param[in] fbuf A fragmentation buffer holding the state of the datagram \* and recoverable fragments. \*/static void \_sched\_next\_frame(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf);
/\*\* \* @brief Schedule ARQ timeout \* \* @param[in] fbuf A fragmentation buffer holding the state of the datagram \* and recoverable fragments. \* @param[in] offset Offset for the ARQ timeout in milliseconds. \*/static void \_sched\_arq\_timeout(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, uint32\_t offset);
/\*\* \* @brief Schedule ARQ timeout for an abort fragment pseudo fragment \* \* @param[in,out] fbuf A fragmentation buffer. All state information will be \* cleared when called, except for identifying the ACK. \*/static void \_sched\_abort\_timeout(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf);
/\*\* \* @brief Handle a received RFRAG packet \* \* @param[in] netif\_hdr NETIF header of @p pkt \* @param[in] pkt An RFRAG packet \* @param[in] page Current 6Lo dispatch parsing page. \*/static void \_handle\_rfrag(gnrc\_netif\_hdr\_t \*netif\_hdr, gnrc\_pktsnip\_t \*pkt, unsigned page);
/\*\* \* @brief Handle a received RFRAG-ACK \* \* @param[in] netif\_hdr NETIF header of @p pkt \* @param[in] pkt An RFRAG-ACK \* @param[in] page Current 6Lo dispatch parsing page. \*/static void \_handle\_ack(gnrc\_netif\_hdr\_t \*netif\_hdr, gnrc\_pktsnip\_t \*pkt, unsigned page);
/\*\* \* @brief Forward a RFRAG \* \* @pre `entry->type == \_VRB` \* \* @param[in] pkt The RFRAG to forward (without NETIF header) \* @param[in] entry The VRB entry to determine the route \* @param[in] offset Offset (from the incoming RFRAG's field) of the RFRAG. \* for offset > 0 this will be adapted for the offset \* difference from the first fragment due to recompression \* @param[in] page Current 6Lo dispatch parsing page. \* \* @return 0 on success, \* @return -ENOMEM, when packet buffer is too full to prepare packet for \* forwarding. @p pkt is released in that case. \*/static int \_forward\_rfrag(gnrc\_pktsnip\_t \*pkt, \_generic\_rb\_entry\_t \*entry, uint16\_t offset, unsigned page);
/\* ====== PUBLIC FUNCTION DEFINITIONS ====== \*/void gnrc\_sixlowpan\_frag\_sfr\_init(void){ if (gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_has\_inter\_frame\_gap()) { for (unsigned i = 0; i < FRAME\_QUEUE\_POOL\_SIZE; i++) { clist\_rpush(&\_frame\_queue\_free, &\_frame\_queue\_pool[i].super); } } for (unsigned i = 0; i < FRAG\_DESCS\_POOL\_SIZE; i++) { clist\_rpush(&\_frag\_descs\_free, &\_frag\_descs\_pool[i].super.super); }}
void gnrc\_sixlowpan\_frag\_sfr\_send(gnrc\_pktsnip\_t \*pkt, void \*ctx, unsigned page){ gnrc\_sixlowpan\_frag\_fb\_t \*fbuf = ctx; gnrc\_netif\_t \*netif; int error\_no = GNRC\_NETERR\_SUCCESS; gnrc\_pktsnip\_t \*tx\_sync = NULL; uint16\_t res;
 assert((fbuf != NULL) && ((fbuf->pkt == pkt) || (pkt == NULL))); DEBUG("6lo sfr: (re-)sending fragmented datagram %u\n", fbuf->tag); pkt = fbuf->pkt; assert(pkt->type == GNRC\_NETTYPE\_NETIF); netif = gnrc\_netif\_hdr\_get\_netif(pkt->data); assert(netif != NULL);
 if (IS\_USED(MODULE\_GNRC\_TX\_SYNC)) { tx\_sync = gnrc\_tx\_sync\_split(pkt); }
 if (fbuf->offset == 0) { DEBUG("6lo sfr: sending first fragment\n"); gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_setup(fbuf); res = \_send\_1st\_fragment(netif, fbuf, page, &tx\_sync); if (res == 0) { DEBUG("6lo sfr: error sending first fragment\n"); /\* \_send\_1st\_fragment only returns 0 if there is a memory problem \*/ error\_no = ENOMEM; goto error; } } else if (!gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_in\_cwnd(fbuf)) { DEBUG("6lo sfr: frags\_sent not within congestion window: " "don't send more\n"); return; } else if (fbuf->offset < fbuf->datagram\_size) { DEBUG("6lo sfr: sending subsequent fragment\n");#if IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_CONGURE) assert(fbuf->sfr.congure); assert(fbuf->sfr.congure->driver);#endif res = \_send\_nth\_fragment(netif, fbuf, page, &tx\_sync); if (res == 0) { DEBUG("6lo sfr: error sending subsequent fragment (offset = %u)\n", fbuf->offset); /\* \_send\_nth\_fragment only returns 0 if there is a memory problem \*/ error\_no = ENOMEM; goto error; } } else { /\* offset is greater or equal to datagram size \* => we are done sending fragments (not an error, but we can release \* the fragmentation buffer now) \*/ goto error; } gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_report\_frag\_sent(fbuf); fbuf->offset += res;
 if (gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_in\_cwnd(fbuf) && (fbuf->offset < fbuf->datagram\_size) && !gnrc\_sixlowpan\_frag\_fb\_send(fbuf)) { /\* the queue of the 6LoWPAN thread is full \*/ error\_no = ENOMEM; /\* go back offset to not send abort on first fragment \*/ fbuf->offset -= res; gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_report\_frag\_discard(fbuf); goto error; } /\* check if last fragment sent requested an ACK \*/ \_frag\_desc\_t \*frag\_desc = (\_frag\_desc\_t \*)clist\_rpeek(&fbuf->sfr.window); DEBUG("6lo sfr: last sent fragment (tag: %u, X: %i, seq: %u, " "frag\_size: %u, offset: %u)\n", (uint8\_t)fbuf->tag, \_frag\_ack\_req(frag\_desc), \_frag\_seq(frag\_desc), \_frag\_size(frag\_desc), frag\_desc->offset); if (\_frag\_ack\_req(frag\_desc)) { /\* initialize \_arq\_timer if not yet done \*/ if (\_arq\_timer.callback == NULL) { evtimer\_init\_msg(&\_arq\_timer); } \_sched\_arq\_timeout(fbuf, fbuf->sfr.arq\_timeout); }
 if (IS\_USED(MODULE\_GNRC\_TX\_SYNC) && tx\_sync) { /\* re-attach tx\_sync to allow releasing it at end \* of transmission, or transmission failure \*/ gnrc\_pkt\_append(pkt, tx\_sync); } thread\_yield(); return;error: /\* don't send abort for first fragment, the network does not know about \* the datagram \*/ if ((fbuf->offset > 0) && \_send\_abort\_frag(fbuf->pkt, fbuf, true, 0)) { /\* wait for ACK before fbuf is deleted \*/ \_sched\_abort\_timeout(fbuf); } else { \_clean\_up\_fbuf(fbuf, error\_no); } if (IS\_USED(MODULE\_GNRC\_TX\_SYNC) && tx\_sync) { gnrc\_pktbuf\_release(tx\_sync); }}
void gnrc\_sixlowpan\_frag\_sfr\_recv(gnrc\_pktsnip\_t \*pkt, void \*ctx, unsigned page){ sixlowpan\_sfr\_t \*hdr; gnrc\_netif\_hdr\_t \*netif\_hdr;
 (void)ctx; DEBUG("6lo sfr: received selective fragment forwarding message\n"); assert(pkt != NULL); hdr = pkt->data; assert(pkt->next != NULL); netif\_hdr = pkt->next->data; assert(netif\_hdr != NULL); if (page != 0) { DEBUG("6lo sfr: Invalid page %u\n", page); gnrc\_pktbuf\_release(pkt); } else if (sixlowpan\_sfr\_rfrag\_is(hdr)) { \_handle\_rfrag(netif\_hdr, pkt, page); } else if (sixlowpan\_sfr\_ack\_is(hdr)) { \_handle\_ack(netif\_hdr, pkt, page); } else { DEBUG("6lo sfr: Unknown dispatch: %02x\n", hdr->disp\_ecn & SIXLOWPAN\_SFR\_DISP\_MASK); gnrc\_pktbuf\_release(pkt); }}
int gnrc\_sixlowpan\_frag\_sfr\_forward(gnrc\_pktsnip\_t \*pkt, sixlowpan\_sfr\_rfrag\_t \*rfrag, gnrc\_sixlowpan\_frag\_vrb\_t \*vrbe, unsigned page){ \_generic\_rb\_entry\_t entry = { .type = \_VRB, .entry = { .vrb = vrbe } }; gnrc\_pktsnip\_t \*hdrsnip = gnrc\_pktbuf\_add(pkt, rfrag, sizeof(\*rfrag), GNRC\_NETTYPE\_SIXLOWPAN);
 /\* free all intervals associated to the VRB entry, as we don't need them \* with SFR, so throw them out, to save this resource \*/ while (vrbe->super.ints) { vrbe->super.ints->end = 0U; vrbe->super.ints = vrbe->super.ints->next; } if (hdrsnip == NULL) { DEBUG("6lo sfr: Unable to allocate new rfrag header\n"); gnrc\_pktbuf\_release(pkt); return -ENOMEM; } DEBUG("6lo sfr: adapting old fragment size (%u) for forwarding to %u\n", sixlowpan\_sfr\_rfrag\_get\_frag\_size(hdrsnip->data), (unsigned)gnrc\_pkt\_len(pkt)); /\* due to compression, packet length of the original fragment might have \* changed \*/ sixlowpan\_sfr\_rfrag\_set\_frag\_size(hdrsnip->data, gnrc\_pkt\_len(pkt)); /\* offset is adapted in `\_forward\_rfrag()` \*/ return \_forward\_rfrag(hdrsnip, &entry, sixlowpan\_sfr\_rfrag\_get\_offset(rfrag), page);}
static int \_report\_non\_ack\_req\_window\_sent(clist\_node\_t \*node, void \*fbuf\_ptr){ \_frag\_desc\_t \*frag\_desc = (\_frag\_desc\_t \*)node; if (!\_frag\_ack\_req(frag\_desc)) { gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_report\_frag\_sent(fbuf\_ptr); } return 0;}
void gnrc\_sixlowpan\_frag\_sfr\_arq\_timeout(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf){ uint32\_t now = xtimer\_now\_usec() / US\_PER\_MS; \_frag\_desc\_t \*frag\_desc = (\_frag\_desc\_t \*)fbuf->sfr.window.next; uint32\_t next\_arq\_offset = fbuf->sfr.arq\_timeout; bool reschedule\_arq\_timeout = false; int error\_no = ETIMEDOUT; /\* assume time out for fbuf->pkt \*/
 DEBUG("6lo sfr: ARQ timeout for datagram %u\n", fbuf->tag); fbuf->sfr.arq\_timeout\_event.msg.content.ptr = NULL; if (IS\_ACTIVE(CONFIG\_GNRC\_SIXLOWPAN\_SFR\_MOCK\_ARQ\_TIMER)) { /\* mock-up to emulate time having passed beyond (1us) the ARQ timeout \*/ now -= (fbuf->sfr.arq\_timeout \* US\_PER\_MS) + 1; } if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_CONGURE) && frag\_desc) { /\* report timeout to CongURE state \*/ gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_report\_frags\_timeout(fbuf); \_shrink\_window(fbuf); /\* potentially shrink window \*/ /\* reassign frag\_desc, in case window head changed \*/ frag\_desc = (\_frag\_desc\_t \*)fbuf->sfr.window.next; } /\* copying clist\_foreach because we can't work just in function context \*/ \_frag\_desc\_t \* const head = frag\_desc; if (frag\_desc) { do { uint32\_t diff;
 frag\_desc = (\_frag\_desc\_t \*)frag\_desc->super.super.next; diff = now - frag\_desc->super.send\_time; if (diff < fbuf->sfr.arq\_timeout) { /\* this fragment's last was last sent < fbuf->sfr.arq\_timeout \* ago \*/ uint32\_t offset = fbuf->sfr.arq\_timeout - diff;
 DEBUG("6lo sfr: wait for fragment %u in next reschedule\n", \_frag\_seq(frag\_desc)); if (offset < next\_arq\_offset) { /\* wait for this fragments ACK next \*/ next\_arq\_offset = offset; DEBUG(" (next ARQ timeout in %lu)\n", (long unsigned)next\_arq\_offset); } /\* this fragment is still waiting for its ACK, \* reschedule the next ACK timeout to the difference \* of the ACK timeout and the time of its last send \*/ reschedule\_arq\_timeout = true; } else if (\_frag\_ack\_req(frag\_desc)) { /\* for this fragment we requested an ACK which was not received \* yet. Try to resend it \*/ if ((frag\_desc->super.resends++) < CONFIG\_GNRC\_SIXLOWPAN\_SFR\_FRAG\_RETRIES) { /\* we have retries left for this fragment \*/ DEBUG("6lo sfr: %u retries left for fragment (tag: %u, " "X: %i, seq: %u, frag\_size: %u, offset: %u)\n", CONFIG\_GNRC\_SIXLOWPAN\_SFR\_FRAG\_RETRIES - (frag\_desc->super.resends - 1), (uint8\_t)fbuf->tag, \_frag\_ack\_req(frag\_desc), \_frag\_seq(frag\_desc), \_frag\_size(frag\_desc), frag\_desc->offset); if (\_resend\_frag(&frag\_desc->super.super, fbuf) != 0) { /\* \_resend\_frag failed due to a memory resource \* problem \*/ error\_no = ENOMEM; goto error; } else { if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_CONGURE)) { /\* fragment was resent successfully, report this to CongURE state \* object \*/ gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_report\_frag\_sent(fbuf); } if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_STATS)) { /\* fragment was resent successfully, note this done \* in the statistics \*/ \_stats.fragment\_resends.by\_timeout++; } } /\* fragment was resent successfully, schedule next ACK \* timeout \*/ reschedule\_arq\_timeout = true; } else { /\* out of retries \*/ DEBUG("6lo sfr: no retries left for fragment " "(tag: %u, X: %i, seq: %u, frag\_size: %u, " "offset: %u)\n", (uint8\_t)fbuf->tag, \_frag\_ack\_req(frag\_desc), \_frag\_seq(frag\_desc), \_frag\_size(frag\_desc), frag\_desc->offset); /\* we are out of retries on the fragment level, but we \* might be able to retry the datagram if retries for the \* datagram are configured. \*/ \_retry\_datagram(fbuf); return; } } else { /\* Do not resend fragments that were not explicitly asking for \* an ACK from the reassembling endpoint on ACK timeout. \* If this is true for all fragments remaining in the fragment \* buffer, the datagram is to be considered timed out, so \* error\_no should remain ETIMEDOUT \*/ DEBUG("6lo sfr: nothing to do for fragment %u\n", \_frag\_seq(frag\_desc)); } } while (frag\_desc != head); /\* report all non-ack\_req fragments in window also as sent, since even \* the lost fragments are still in flight (even though they were \* previously marked as timed out) \*/ clist\_foreach(&fbuf->sfr.window, \_report\_non\_ack\_req\_window\_sent, fbuf); } else { /\* No fragments to resend, we can assume the packet was delivered \* successfully \*/ error\_no = GNRC\_NETERR\_SUCCESS; } assert(fbuf->sfr.frags\_sent == clist\_count(&fbuf->sfr.window)); if (reschedule\_arq\_timeout) { \_sched\_arq\_timeout(fbuf, next\_arq\_offset); return; }error: /\* don't check return value, as we don't want to wait for an ACK again ;-) \*/ \_send\_abort\_frag(fbuf->pkt, fbuf, false, 0); \_clean\_up\_fbuf(fbuf, error\_no);}
void gnrc\_sixlowpan\_frag\_sfr\_inter\_frame\_gap(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf){ if (gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_has\_inter\_frame\_gap()) { \_frame\_queue\_t \*node = (\_frame\_queue\_t \*)clist\_lpop(&\_frame\_queue);
 if (node != NULL) { \_last\_frame\_sent = xtimer\_now\_usec(); gnrc\_sixlowpan\_dispatch\_send(node->frame, NULL, node->page); /\* unset packet just to be safe \*/ node->frame = NULL; clist\_rpush(&\_frame\_queue\_free, &node->super); } if (clist\_lpeek(&\_frame\_queue) != NULL) { \_sched\_next\_frame(fbuf); } }}
void gnrc\_sixlowpan\_frag\_sfr\_stats\_get(gnrc\_sixlowpan\_frag\_sfr\_stats\_t \*stats){ if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_STATS)) { \*stats = \_stats; }}
/\* ====== INTERNAL FUNCTION DEFINITIONS ====== \*/static inline uint16\_t \_min(uint16\_t a, size\_t b){ return (a < b) ? a : (uint16\_t)b;}
static inline kernel\_pid\_t \_getpid(void){ /\* in production, only the 6LoWPAN thread is supposed to call the API \* functions, so just get the current thread's PID for sending messages. \* When testing, those functions might however be called by the testing \* thread (usually the main thread), so indirect over the 6LoWPAN thread in \* that case \*/ return IS\_ACTIVE(TEST\_SUITES) ? gnrc\_sixlowpan\_get\_pid() : thread\_getpid();}
/\* \* @brief Returns the datagram in @p fbuf to its original state \* \* This function can be both used to clean up the fragmentation buffer on \* failure without releasing @p fbuf's gnrc\_sixlowpan\_frag\_fb\_t::pkt and to \* reset a datagram for a datagram retry. \* \* @param[in] fbuf The fragmentation buffer entry to clean up \*/static void \_clean\_slate\_datagram(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf){ clist\_node\_t new\_queue = { .next = NULL };
 fbuf->sfr.arq\_timeout\_event.msg.content.ptr = NULL; /\* remove potentially scheduled timers for this datagram \*/ evtimer\_del((evtimer\_t \*)(&\_arq\_timer), &fbuf->sfr.arq\_timeout\_event.event); fbuf->sfr.arq\_timeout\_event.event.next = NULL; if (gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_has\_inter\_frame\_gap()) { for (clist\_node\_t \*node = clist\_lpop(&\_frame\_queue); node != NULL; node = clist\_lpop(&\_frame\_queue)) { \_frame\_queue\_t \*entry = (\_frame\_queue\_t \*)node; /\* remove frames of this datagram from frame queue \*/ if (entry->datagram\_tag == fbuf->tag) { gnrc\_pktbuf\_release(entry->frame); /\* unset packet just to be safe \*/ entry->frame = NULL; clist\_rpush(&\_frag\_descs\_free, node); } else { clist\_rpush(&new\_queue, node); } } /\* reset frame queue with remaining frames \*/ \_frame\_queue = new\_queue; } fbuf->offset = 0U; fbuf->sfr.cur\_seq = 0U; fbuf->sfr.frags\_sent = 0U; for (clist\_node\_t \*node = clist\_lpop(&fbuf->sfr.window); node != NULL; node = clist\_lpop(&fbuf->sfr.window)) { clist\_rpush(&\_frag\_descs\_free, node); }}
static gnrc\_pktsnip\_t \*\_build\_rfrag(uint8\_t tag, bool ack\_req, uint16\_t size, uint8\_t seq){ sixlowpan\_sfr\_rfrag\_t \*hdr; gnrc\_pktsnip\_t \*frag = gnrc\_pktbuf\_add(NULL, NULL, sizeof(sixlowpan\_sfr\_rfrag\_t) + size, GNRC\_NETTYPE\_SIXLOWPAN);
 if (frag == NULL) { return NULL; } sixlowpan\_sfr\_rfrag\_set\_disp(frag->data);
 hdr = frag->data; hdr->base.tag = tag; if (ack\_req) { sixlowpan\_sfr\_rfrag\_set\_ack\_req(hdr); } else { sixlowpan\_sfr\_rfrag\_clear\_ack\_req(hdr); } sixlowpan\_sfr\_rfrag\_set\_frag\_size(hdr, size); sixlowpan\_sfr\_rfrag\_set\_seq(hdr, seq); /\* set offset / datagram\_size in callers \*/ return frag;}
static gnrc\_pktsnip\_t \*\_build\_frag\_pkt(gnrc\_netif\_hdr\_t \*old\_netif\_hdr, uint8\_t tag, bool ack\_req, uint16\_t size, uint8\_t seq){ gnrc\_netif\_hdr\_t \*new\_netif\_hdr; gnrc\_pktsnip\_t \*netif, \*res;
 DEBUG("6lo sfr: building fragment (tag: %u, X: %i, seq: %u, frag\_size: %u)\n", tag, ack\_req, seq, size); netif = gnrc\_netif\_hdr\_build(gnrc\_netif\_hdr\_get\_src\_addr(old\_netif\_hdr), old\_netif\_hdr->src\_l2addr\_len, gnrc\_netif\_hdr\_get\_dst\_addr(old\_netif\_hdr), old\_netif\_hdr->dst\_l2addr\_len); if (netif == NULL) { return NULL; }
 new\_netif\_hdr = netif->data; \*new\_netif\_hdr = \*old\_netif\_hdr; res = \_build\_rfrag(tag, ack\_req, size, seq); if (res == NULL) { gnrc\_pktbuf\_release(netif); return NULL; } return gnrc\_pkt\_prepend(res, netif);}
static gnrc\_pktsnip\_t \*\_build\_frag\_from\_fbuf(gnrc\_pktsnip\_t \*pkt, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, uint16\_t frag\_size){ return \_build\_frag\_pkt(pkt->data, (uint8\_t)fbuf->tag, ((frag\_size + fbuf->offset) >= fbuf->datagram\_size) || /\* we only can send the next fragment we build here, \* so request ACK for it \*/ !gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_next\_in\_cwnd(fbuf), frag\_size, fbuf->sfr.cur\_seq);}
static uint16\_t \_copy\_pkt\_to\_frag(uint8\_t \*data, const gnrc\_pktsnip\_t \*pkt, uint16\_t frag\_size, uint16\_t init\_offset){ uint16\_t offset = init\_offset;
 while ((pkt != NULL) && (offset < frag\_size)) { uint16\_t len = \_min(frag\_size - offset, pkt->size);
 memcpy(data + offset, pkt->data, len);
 offset += len; pkt = pkt->next; } return offset;}
static uint16\_t \_find\_offset\_and\_copy\_rest(uint8\_t \*data, gnrc\_pktsnip\_t \*\*pkt, uint16\_t frag\_size, uint16\_t offset){ uint16\_t offset\_count = 0, cur\_frag\_size = 0; while ((\*pkt != NULL) && (offset\_count != offset)) { /\* go to offset \*/ uint16\_t pkt\_size = (uint16\_t)(\*pkt)->size; offset\_count += pkt\_size;
 if (offset\_count > offset) { /\* we overshot \*/ /\* => copy rest of partly send packet snip \*/ uint16\_t pkt\_offset = offset - (offset\_count - pkt\_size); size\_t clen = \_min(frag\_size, pkt\_size - pkt\_offset);
 memcpy(data, ((uint8\_t \*)(\*pkt)->data) + pkt\_offset, clen); cur\_frag\_size = clen; \*pkt = (\*pkt)->next; break; } \*pkt = (\*pkt)->next; } return cur\_frag\_size;}
static void \_check\_for\_ecn(gnrc\_pktsnip\_t \*frame){ if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_ECN) && (sixlowpan\_sfr\_rfrag\_is(frame->next->data))) { int queue\_state = 0; int queue\_size = 0;
 if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_ECN\_IF\_IN)) { gnrc\_netif\_t \*netif = gnrc\_netif\_hdr\_get\_netif(frame->data);
 assert(frame->type == GNRC\_NETTYPE\_NETIF); assert(frame->next->type == GNRC\_NETTYPE\_SIXLOWPAN); queue\_state = msg\_avail\_thread(netif->pid); queue\_size = msg\_queue\_capacity(netif->pid); assert(queue\_size > 0);
 if ((queue\_state \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_IF\_IN\_DEN) > (queue\_size \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_IF\_IN\_NUM)) { sixlowpan\_sfr\_set\_ecn(frame->next->data); } }
 if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_ECN\_IF\_OUT)) { queue\_state = gnrc\_netif\_pktq\_usage(); queue\_size = CONFIG\_GNRC\_NETIF\_PKTQ\_POOL\_SIZE;
 if ((queue\_state \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_IF\_OUT\_DEN) > (queue\_size \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_IF\_OUT\_NUM)) { sixlowpan\_sfr\_set\_ecn(frame->next->data); } }
 if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_ECN\_FQUEUE)) { queue\_state = clist\_count(&\_frame\_queue); queue\_size = FRAME\_QUEUE\_POOL\_SIZE;
 if ((queue\_state \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_FQUEUE\_DEN) > (queue\_size \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_FQUEUE\_NUM)) { sixlowpan\_sfr\_set\_ecn(frame->next->data); } } }}
static bool \_send\_frame(gnrc\_pktsnip\_t \*frame, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, void \*ctx, unsigned page){ uint32\_t now; uint32\_t if\_gap = gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_inter\_frame\_gap(fbuf);
 \_check\_for\_ecn(frame); now = xtimer\_now\_usec(); if ((if\_gap == 0) || ((now - \_last\_frame\_sent) > if\_gap)) { DEBUG("6lo sfr: dispatch frame to network interface\n"); \_last\_frame\_sent = now; gnrc\_sixlowpan\_dispatch\_send(frame, ctx, page); return true; } else { \_frame\_queue\_t \*node = (\_frame\_queue\_t \*)clist\_lpop(&\_frame\_queue\_free);
 if (node != NULL) { sixlowpan\_sfr\_t \*hdr = frame->next->data;
 assert(sixlowpan\_sfr\_is(hdr)); node->frame = frame; node->datagram\_tag = hdr->tag; node->page = page; clist\_rpush(&\_frame\_queue, &node->super); \_sched\_next\_frame(fbuf); } return (node != NULL); }}
static bool \_send\_fragment(gnrc\_pktsnip\_t \*frag, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, unsigned page, uint16\_t offset){ sixlowpan\_sfr\_rfrag\_t \*hdr = frag->next->data; \_frag\_desc\_t \*frag\_desc = (\_frag\_desc\_t \*)clist\_lpop(&\_frag\_descs\_free); bool res;
 if (frag\_desc == NULL) { DEBUG("6lo sfr: could not remember fragment to send\n"); gnrc\_pktbuf\_release(frag); return false; } frag\_desc->ar\_seq\_fs = byteorder\_ntohs(hdr->ar\_seq\_fs); frag\_desc->offset = offset; frag\_desc->super.size = 1; frag\_desc->super.resends = 0; clist\_rpush(&fbuf->sfr.window, &frag\_desc->super.super); if ((res = \_send\_frame(frag, fbuf, NULL, page))) { if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_STATS)) { \_stats.fragments\_sent.usual++; } frag\_desc->super.send\_time = \_last\_frame\_sent / US\_PER\_MS; fbuf->sfr.cur\_seq++; fbuf->sfr.frags\_sent++; } return res;}
static gnrc\_pktsnip\_t \*\_build\_ack(gnrc\_netif\_t \*netif, const uint8\_t \*dst, uint8\_t dst\_len, const sixlowpan\_sfr\_t \*hdr, const uint8\_t \*bitmap){ gnrc\_pktsnip\_t \*ack\_snip, \*ack\_netif; sixlowpan\_sfr\_ack\_t \*ack;
 ack\_netif = gnrc\_netif\_hdr\_build(NULL, 0, dst, dst\_len); if (ack\_netif == NULL) { DEBUG("6lo sfr: can't allocate netif header for ACK for (%s, %02x).\n", gnrc\_netif\_addr\_to\_str(dst, dst\_len, addr\_str), hdr->tag); return NULL; } gnrc\_netif\_hdr\_set\_netif(ack\_netif->data, netif);
 ack\_snip = gnrc\_pktbuf\_add(NULL, NULL, sizeof(sixlowpan\_sfr\_ack\_t), GNRC\_NETTYPE\_SIXLOWPAN);
 if (ack\_snip == NULL) { DEBUG("6lo sfr: can't allocate ACK for (%s, %02x).\n", gnrc\_netif\_addr\_to\_str(dst, dst\_len, addr\_str), hdr->tag); gnrc\_pktbuf\_release(ack\_netif); return NULL; } ack = ack\_snip->data; /\* https://tools.ietf.org/html/rfc8931#section-6: \* The Datagram\_Tag in the RFRAG\_ACK is unique to the reassembling endpoint \* and is enough information for an intermediate hop to locate the VRB that \* contains the Datagram\_Tag used by the previous hop and the Layer-2 \* information associated with it (interface and Link-Layer address).. \* [...] The reassembling endpoint of a fragment with the 'E' (ECN) flag set \* MUST echo that information at most once by setting the 'E' (ECN) flag in \* the next RFRAG\_ACK. \* \* => base except dispatch are the same as ack'd RFRAG. \*/ ack->base = \*hdr; sixlowpan\_sfr\_ack\_set\_disp(&ack->base); memcpy(ack->bitmap, bitmap, sizeof(ack->bitmap)); ack\_netif->next = ack\_snip; return ack\_netif;}
static void \_clean\_up\_rb\_entry(\_generic\_rb\_entry\_t \*entry){ if (entry != NULL) { switch (entry->type) { case \_RB: gnrc\_pktbuf\_release(entry->entry.rb->pkt); gnrc\_sixlowpan\_frag\_rb\_remove(entry->entry.rb); break; case \_VRB: gnrc\_sixlowpan\_frag\_vrb\_rm(entry->entry.vrb); break; default: break; } }}
static void \_try\_reassembly(gnrc\_netif\_hdr\_t \*netif\_hdr, gnrc\_pktsnip\_t \*rfrag, unsigned offset, \_generic\_rb\_entry\_t \*entry, unsigned page){ gnrc\_sixlowpan\_frag\_vrb\_t \*vrbe; const gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t \*bitmap; sixlowpan\_sfr\_rfrag\_t \*hdr = rfrag->data; gnrc\_pktsnip\_t \*netif\_snip = rfrag->next; /\* copy base for ACK \*/ sixlowpan\_sfr\_t base = hdr->base; int8\_t ack\_req = sixlowpan\_sfr\_rfrag\_ack\_req(hdr); uint8\_t seq = sixlowpan\_sfr\_rfrag\_get\_seq(hdr);
 assert(netif\_snip->data == netif\_hdr); gnrc\_pktbuf\_hold(netif\_snip, 1); /\* hold netif header to use it with \* dispatch\_when\_complete() \* (rb\_add() releases `pkt`) \*/ entry->entry.rb = gnrc\_sixlowpan\_frag\_rb\_add(netif\_hdr, rfrag,[View remainder of file in raw view](https://github.com/RIOT-OS/RIOT/raw/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_3534434b_20250114_192721.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Fmaster%2Fsys%2Fnet%2Fgnrc%2Fnetwork_layer%2Fsixlowpan%2Ffrag%2Fsfr%2Fgnrc_sixlowpan_frag_sfr.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Fmaster%2Fsys%2Fnet%2Fgnrc%2Fnetwork_layer%2Fsixlowpan%2Ffrag%2Fsfr%2Fgnrc_sixlowpan_frag_sfr.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  388](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_ca877f72_20250114_192725.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fpull%2F19679)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fpull%2F19679)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fpull_requests_fragments%2Fpull_request_layout&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  388](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

New issue

**Have a question about this project?** Sign up for a free GitHub account to open an issue and contact its maintainers and the community.

 [Sign up for GitHub](/signup?return_to=%2FRIOT-OS%2FRIOT%2Fissues%2Fnew%2Fchoose)

By clicking “Sign up for GitHub”, you agree to our [terms of service](https://docs.github.com/terms) and
[privacy statement](https://docs.github.com/privacy). We’ll occasionally send you account related emails.

Already on GitHub?
[Sign in](/login?return_to=%2FRIOT-OS%2FRIOT%2Fissues%2Fnew%2Fchoose)
to your account

[Jump to bottom](#issue-comment-box)

# gnrc\_sixlowpan\_frag\_sfr: fix ARQ scheduler race-condition #19679

 Merged

[bors](/apps/bors)
merged 1 commit into
[RIOT-OS:master](/RIOT-OS/RIOT/tree/master "RIOT-OS/RIOT:master")
from
[miri64:gnrc\_sixlowpan\_frag\_sfr/bug/arq-scheduler-race](/miri64/RIOT/tree/gnrc_sixlowpan_frag_sfr/bug/arq-scheduler-race "miri64/RIOT:gnrc_sixlowpan_frag_sfr/bug/arq-scheduler-race")

May 30, 2023

 Merged

# [gnrc\_sixlowpan\_frag\_sfr: fix ARQ scheduler race-condition](#top) #19679

[bors](/apps/bors)
merged 1 commit into
[RIOT-OS:master](/RIOT-OS/RIOT/tree/master "RIOT-OS/RIOT:master")
from
[miri64:gnrc\_sixlowpan\_frag\_sfr/bug/arq-scheduler-race](/miri64/RIOT/tree/gnrc_sixlowpan_frag_sfr/bug/arq-scheduler-race "miri64/RIOT:gnrc_sixlowpan_frag_sfr/bug/arq-scheduler-race")

May 30, 2023

[Conversation
8](/RIOT-OS/RIOT/pull/19679)
[Commits
1](/RIOT-OS/RIOT/pull/19679/commits)
[Checks
0](/RIOT-OS/RIOT/pull/19679/checks)
[Files changed](/RIOT-OS/RIOT/pull/19679/files)

## Conversation

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

[![miri64](https://avatars.githubusercontent.com/u/675644?s=60&v=4)](/miri64)

Copy link

Member

### @miri64 **[miri64](/miri64)** commented [May 30, 2023](#issue-1732165915)

### Contribution description

See [GHSA-8m3w-mphf-wxm8](https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-8m3w-mphf-wxm8 "GHSA-8m3w-mphf-wxm8")

### Testing procedure

### Issues/PRs references

Sorry, something went wrong.

All reactions

 [![@miri64](https://avatars.githubusercontent.com/u/675644?s=40&u=ddc0fa64e6b79aeadc94b7061bef6e052be4d8c7&v=4)](/miri64)
[miri64](/miri64)
requested review from
[haukepetersen](/haukepetersen),
[PeterKietzmann](/PeterKietzmann) and
[cgundogan](/cgundogan)
as [code owners](/RIOT-OS/RIOT/blob/e690ef4c1298d90bc323b765c000bb090544fb9f/CODEOWNERS#L130)
[May 30, 2023 12:32](#event-9377926149)

[![@github-actions](https://avatars.githubusercontent.com/in/15368?s=40&v=4)](/apps/github-actions)
[github-actions](/apps/github-actions)
bot
added
[Area: network](/RIOT-OS/RIOT/labels/Area%3A%20network)
Area: Networking
[Area: sys](/RIOT-OS/RIOT/labels/Area%3A%20sys)
Area: System
labels
[May 30, 2023](#event-9377932190)

[![benpicco](https://avatars.githubusercontent.com/u/1301112?s=60&v=4)](/benpicco)

**[benpicco](/benpicco)**
reviewed
[May 30, 2023](#pullrequestreview-1450838292)

 [View reviewed changes](/RIOT-OS/RIOT/pull/19679/files)

[sys/net/gnrc/network\_layer/sixlowpan/frag/sfr/gnrc\_sixlowpan\_frag\_sfr.c](/RIOT-OS/RIOT/pull/19679/files#diff-7220f6289fca939f524330842b477b6ea8661661f8928d9c6536766e0f198dd8)

Show resolved

Hide resolved

 [![@miri64](https://avatars.githubusercontent.com/u/675644?s=40&u=ddc0fa64e6b79aeadc94b7061bef6e052be4d8c7&v=4)](/miri64)
[miri64](/miri64)
[force-pushed](/RIOT-OS/RIOT/compare/5b913e2d59b3ad36d60b9ea621012740cd17a992..377bc51be326e5c35f239b422dd888c8b6804c3a)
the
gnrc\_sixlowpan\_frag\_sfr/bug/arq-scheduler-race

branch
from
[`5b913e2`](/RIOT-OS/RIOT/commit/5b913e2d59b3ad36d60b9ea621012740cd17a992) to
[`377bc51`](/RIOT-OS/RIOT/commit/377bc51be326e5c35f239b422dd888c8b6804c3a)  [Compare](/RIOT-OS/RIOT/compare/5b913e2d59b3ad36d60b9ea621012740cd17a992..377bc51be326e5c35f239b422dd888c8b6804c3a)
[May 30, 2023 12:43](#event-9378030786)

[![@miri64](https://avatars.githubusercontent.com/u/675644?s=40&u=ddc0fa64e6b79aeadc94b7061bef6e052be4d8c7&v=4)](/miri64)
[miri64](/miri64)
added
the
[Type: bug](/RIOT-OS/RIOT/labels/Type%3A%20bug)
The issue reports a bug / The PR fixes a bug (including spelling errors)
label
[May 30, 2023](#event-9378054991)

 [![@miri64](https://avatars.githubusercontent.com/u/675644?s=40&u=ddc0fa64e6b79aeadc94b7061bef6e052be4d8c7&v=4)](/miri64)
[miri64](/miri64)
[force-pushed](/RIOT-OS/RIOT/compare/377bc51be326e5c35f239b422dd888c8b6804c3a..7c28616910892d2af21d7ef8c28ff9a60b4ea941)
the
gnrc\_sixlowpan\_frag\_sfr/bug/arq-scheduler-race

branch
from
[`377bc51`](/RIOT-OS/RIOT/commit/377bc51be326e5c35f239b422dd888c8b6804c3a) to
[`7c28616`](/RIOT-OS/RIOT/commit/7c28616910892d2af21d7ef8c28ff9a60b4ea941)  [Compare](/RIOT-OS/RIOT/compare/377bc51be326e5c35f239b422dd888c8b6804c3a..7c28616910892d2af21d7ef8c28ff9a60b4ea941)
[May 30, 2023 12:50](#event-9378096555)

[![benpicco](https://avatars.githubusercontent.com/u/1301112?s=60&v=4)](/benpicco)

**[benpicco](/benpicco)**
approved these changes
[May 30, 2023](#pullrequestreview-1450926600)

 [View reviewed changes](/RIOT-OS/RIOT/pull/19679/files)

[![@miri64](https://avatars.githubusercontent.com/u/675644?s=40&u=ddc0fa64e6b79aeadc94b7061bef6e052be4d8c7&v=4)](/miri64)
[miri64](/miri64)
added
the
[CI: ready for build](/RIOT-OS/RIOT/labels/CI%3A%20ready%20for%20build)
If set, CI server will compile all applications for all available boards for the labeled PR
label
[May 30, 2023](#event-9378461615)

[![@riot-ci](https://avatars.githubusercontent.com/u/12257278?s=80&u=8e74a8bce7471107cc680bcc956b1dcaeea4756d&v=4)](/riot-ci)

Copy link

### **[riot-ci](/riot-ci)** commented [May 30, 2023](#issuecomment-1568449587) • edited Loading

|  |  |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Murdock results ✔️ [PASSED](https://ci.riot-os.org/details/4713913fc6d1414691da03713dbc1baa)  [31c6191](https://github.com/RIOT-OS/RIOT/commit/31c6191f6196f1a05c9765cffeadba868e3b0723) gnrc\_sixlowpan\_frag\_sfr: fix ARQ scheduler race-condition   | Success | Failures | Total | Runtime | | --- | --- | --- | --- | | 6933 | 0 | 6933 | 16m:54s |  Artifacts  * [Documentation preview](https://ci.riot-os.org/results/4713913fc6d1414691da03713dbc1baa/doc-preview/) |

All reactions

Sorry, something went wrong.

[![@miri64](https://avatars.githubusercontent.com/u/675644?s=80&u=ddc0fa64e6b79aeadc94b7061bef6e052be4d8c7&v=4)](/miri64)

Copy link

Member

Author

### **[miri64](/miri64)** commented [May 30, 2023](#issuecomment-1568526281) • edited Loading

|  |  |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Murdock results ❌ [FAILED](https://ci.riot-os.org/details/8bc8678a27694e7c887b6764198f0a9b)  [7c28616](https://github.com/RIOT-OS/RIOT/commit/7c28616910892d2af21d7ef8c28ff9a60b4ea941) gnrc\_sixlowpan\_frag\_sfr: fix ARQ scheduler race-condition   | Success | Failures | Total | Runtime | | --- | --- | --- | --- | | 4235 | 0 | 6933 | 06m:11s |  Artifacts  Someone forgot to mention the failures? (/cc [@aabadie](https://github.com/aabadie)) |

All reactions

Sorry, something went wrong.

[![@miri64](https://avatars.githubusercontent.com/u/675644?s=40&v=4)](/miri64)

`[gnrc_sixlowpan_frag_sfr: fix ARQ scheduler race-condition](/RIOT-OS/RIOT/pull/19679/commits/31c6191f6196f1a05c9765cffeadba868e3b0723 "gnrc_sixlowpan_frag_sfr: fix ARQ scheduler race-condition")`

`[31c6191](/RIOT-OS/RIOT/pull/19679/commits/31c6191f6196f1a05c9765cffeadba868e3b0723)`

 [![@miri64](https://avatars.githubusercontent.com/u/675644?s=40&u=ddc0fa64e6b79aeadc94b7061bef6e052be4d8c7&v=4)](/miri64)
[miri64](/miri64)
[force-pushed](/RIOT-OS/RIOT/compare/a10b2777b421db1dae481a6a17408fb06ab5c157..31c6191f6196f1a05c9765cffeadba868e3b0723)
the
gnrc\_sixlowpan\_frag\_sfr/bug/arq-scheduler-race

branch
from
[`a10b277`](/RIOT-OS/RIOT/commit/a10b2777b421db1dae481a6a17408fb06ab5c157) to
[`31c6191`](/RIOT-OS/RIOT/commit/31c6191f6196f1a05c9765cffeadba868e3b0723)  [Compare](/RIOT-OS/RIOT/compare/a10b2777b421db1dae481a6a17408fb06ab5c157..31c6191f6196f1a05c9765cffeadba868e3b0723)
[May 30, 2023 14:42](#event-9379390139)

[![@maribu](https://avatars.githubusercontent.com/u/2041729?s=80&u=6e8b59db6160b2d4929809e19f5cf223ba5943f6&v=4)](/maribu)

Copy link

Member

### **[maribu](/maribu)** commented [May 30, 2023](#issuecomment-1568781638)

| bors merge |
| --- |

All reactions

Sorry, something went wrong.

[bors](/apps/bors) bot
added a commit
that referenced
this pull request
[May 30, 2023](#ref-commit-b3e221c)
[![@bors](https://avatars.githubusercontent.com/in/1847?s=40&v=4)](/apps/bors) [![@kfessel](https://avatars.githubusercontent.com/u/814189?s=40&v=4)](/kfessel) [![@miri64](https://avatars.githubusercontent.com/u/675644?s=40&u=ddc0fa64e6b79aeadc94b7061bef6e052be4d8c7&v=4)](/miri64)

`[Merge](/RIOT-OS/RIOT/commit/b3e221cd694e888a58ac48406e8cdc75a432d949 "Merge #19610 #19670 #19678 #19679 #19680 #19681

19610: drivers/periph/rtc: improve doc on rtc_set_alarm r=maribu a=maribu

### Contribution description

- point out behavior on denormalized time stamps
- use errno codes to indicate errors (and adapt the few instances of actual error handling to use them)

19670: cpu/stm32: stm32f4 BRR from BSRR r=maribu a=kfessel

### Contribution description

sometimes one wants to save one instruction :)
just write the bits we need to write.

### Testing procedure

tests/periph/gpio_ll tests this

### Issues/PRs references

`@maribu` might know some reference

maybe #19407

19678: gnrc_sixlowpan_iphc: fix NULL pointer dereference r=maribu a=miri64

19679: gnrc_sixlowpan_frag_sfr: fix ARQ scheduler race-condition r=maribu a=miri64

19680: gnrc_sixlowpan_frag_rb: fix OOB write in _rbuf_add r=maribu a=miri64

19681: sys/xtimer: improve documentation r=maribu a=maribu

### Contribution description

- Add a warning that xtimer is deprecated, so that new code hopefully starts using ztimer
- Add a hint that `ztimer_xtimer_compat` can be used even after `xtimer` is gone

Co-authored-by: Marian Buschsieweke <marian.buschsieweke@ovgu.de>
Co-authored-by: Karl Fessel <karl.fessel@ovgu.de>
Co-authored-by: Martine Lenders <m.lenders@fu-berlin.de>") [#19610](https://github.com/RIOT-OS/RIOT/pull/19610) [#19670](https://github.com/RIOT-OS/RIOT/pull/19670) [#19678](https://github.com/RIOT-OS/RIOT/pull/19678) [#19679](https://github.com/RIOT-OS/RIOT/pull/19679) [#19680](https://github.com/RIOT-OS/RIOT/pull/19680) [#19681](https://github.com/RIOT-OS/RIOT/pull/19681)`
…

`[b3e221c](/RIOT-OS/RIOT/commit/b3e221cd694e888a58ac48406e8cdc75a432d949)`

```
19610: drivers/periph/rtc: improve doc on rtc_set_alarm r=maribu a=maribu

### Contribution description

- point out behavior on denormalized time stamps
- use errno codes to indicate errors (and adapt the few instances of actual error handling to use them)

19670: cpu/stm32: stm32f4 BRR from BSRR r=maribu a=kfessel

### Contribution description

sometimes one wants to save one instruction :)
just write the bits we need to write.

### Testing procedure

tests/periph/gpio_ll tests this

### Issues/PRs references

`@maribu` might know some reference

maybe [#19407](https://github.com/RIOT-OS/RIOT/pull/19407)

19678: gnrc_sixlowpan_iphc: fix NULL pointer dereference r=maribu a=miri64

19679: gnrc_sixlowpan_frag_sfr: fix ARQ scheduler race-condition r=maribu a=miri64

19680: gnrc_sixlowpan_frag_rb: fix OOB write in _rbuf_add r=maribu a=miri64

19681: sys/xtimer: improve documentation r=maribu a=maribu

### Contribution description

- Add a warning that xtimer is deprecated, so that new code hopefully starts using ztimer
- Add a hint that `ztimer_xtimer_compat` can be used even after `xtimer` is gone

Co-authored-by: Marian Buschsieweke <marian.buschsieweke@ovgu.de>
Co-authored-by: Karl Fessel <karl.fessel@ovgu.de>
Co-authored-by: Martine Lenders <m.lenders@fu-berlin.de>
```

[![@bors](https://avatars.githubusercontent.com/in/1847?s=80&v=4)](/apps/bors)

Copy link

Contributor

### **[bors](/apps/bors) bot** commented [May 30, 2023](#issuecomment-1568784927)

| This PR was included in a batch that was canceled, it will be automatically retried |
| --- |

All reactions

Sorry, something went wrong.

[![@bors](https://avatars.githubusercontent.com/in/1847?s=80&v=4)](/apps/bors)

Copy link

Contributor

### **[bors](/apps/bors) bot** commented [May 30, 2023](#issuecomment-1569012177)

| Build succeeded!  The publicly hosted instance of bors-ng is deprecated and will go away soon.  If you want to self-host your own instance, [instructions are here](https://github.com/bors-ng/bors-ng#how-to-set-up-your-own-real-instance). For more help, visit [the forum](https://forum.bors.tech).  If you want to switch to GitHub's built-in merge queue, visit [their help page](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue).   * [Murdock](https://ci.riot-os.org/details/fb540a7fea3d482dbf15b594aaf08a39) * [static-tests](https://github.com/RIOT-OS/RIOT/actions/runs/5124347194/jobs/9216073113) * [tools-build-success](https://github.com/RIOT-OS/RIOT/actions/runs/5124347197/jobs/9216103309) |
| --- |

All reactions

Sorry, something went wrong.

[![@bors](https://avatars.githubusercontent.com/in/1847?s=40&v=4)](/apps/bors)
[bors](/apps/bors)
bot
merged commit [`00b5bc1`](/RIOT-OS/RIOT/commit/00b5bc12a219e4076418e59aaa2457acb6eb7f08)
into
RIOT-OS:master

[May 30, 2023](https://github.com/RIOT-OS/RIOT/pull/19679#event-9382459388)

 [![@miri64](https://avatars.githubusercontent.com/u/675644?s=40&u=ddc0fa64e6b79aeadc94b7061bef6e052be4d8c7&v=4)](/miri64)
[miri64](/miri64)
deleted the
gnrc\_sixlowpan\_frag\_sfr/bug/arq-scheduler-race

branch
[May 30, 2023 20:29](#event-9382717098)

[![@benpicco](https://avatars.githubusercontent.com/u/1301112?s=40&v=4)](/benpicco)
[benpicco](/benpicco)
added this to the [Release 2023.07](/RIOT-OS/RIOT/milestone/43) milestone
[Aug 2, 2023](#event-9987149114)

[Sign up for free](/join?source=comment-repo)
**to join this conversation on GitHub**.
Already have an account?
[Sign in to comment](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fpull%2F19679)

Reviewers

[![@benpicco](https://avatars.githubusercontent.com/u/1301112?s=40&v=4)](/benpicco) [benpicco](/benpicco)

benpicco approved these changes

[![@haukepetersen](https://avatars.githubusercontent.com/u/620834?s=40&v=4)](/haukepetersen) [haukepetersen](/haukepetersen)

 Awaiting requested review from haukepetersen

[![@PeterKietzmann](https://avatars.githubusercontent.com/u/7765855?s=40&v=4)](/PeterKietzmann) [PeterKietzmann](/PeterKietzmann)

 Awaiting requested review from PeterKietzmann

 PeterKietzmann is a code owner

[![@cgundogan](https://avatars.githubusercontent.com/u/739129?s=40&v=4)](/cgundogan) [cgundogan](/cgundogan)

 Awaiting requested review from cgundogan

Assignees

No one assigned

Labels

[Area: network](/RIOT-OS/RIOT/labels/Area%3A%20network)
Area: Networking
[Area: sys](/RIOT-OS/RIOT/labels/Area%3A%20sys)
Area: System
[CI: ready for build](/RIOT-OS/RIOT/labels/CI%3A%20ready%20for%20build)
If set, CI server will compile all applications for all available boards for the labeled PR
[Type: bug](/RIOT-OS/RIOT/labels/Type%3A%20bug)
The issue reports a bug / The PR fixes a bug (including spelling errors)

Projects

None yet

Milestone

 [**Release 2023.07**](/RIOT-OS/RIOT/milestone/43 "Release 2023.07")

Development

Successfully merging this pull request may close these issues.

4 participants

[![@miri64](https://avatars.githubusercontent.com/u/675644?s=52&v=4)](/miri64) [![@riot-ci](https://avatars.githubusercontent.com/u/12257278?s=52&v=4)](/riot-ci) [![@maribu](https://avatars.githubusercontent.com/u/2041729?s=52&v=4)](/maribu) [![@benpicco](https://avatars.githubusercontent.com/u/1301112?s=52&v=4)](/benpicco)

Add this suggestion to a batch that can be applied as a single commit.
This suggestion is invalid because no changes were made to the code.
Suggestions cannot be applied while the pull request is closed.
Suggestions cannot be applied while viewing a subset of changes.
Only one suggestion per line can be applied in a batch.
Add this suggestion to a batch that can be applied as a single commit.
Applying suggestions on deleted lines is not supported.
You must change the existing code in this line in order to create a valid suggestion.
Outdated suggestions cannot be applied.
This suggestion has been applied or marked resolved.
Suggestions cannot be applied from pending reviews.
Suggestions cannot be applied on multi-line comments.
Suggestions cannot be applied while the pull request is queued to merge.
Suggestion cannot be applied right now. Please check back later.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_6b8d6602_20250114_192713.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Ff41b4b67b6affca0a8b32edced7f51088696869a%2Fsys%2Fnet%2Fgnrc%2Fnetwork_layer%2Fsixlowpan%2Ffrag%2Fsfr%2Fgnrc_sixlowpan_frag_sfr.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Ff41b4b67b6affca0a8b32edced7f51088696869a%2Fsys%2Fnet%2Fgnrc%2Fnetwork_layer%2Fsixlowpan%2Ffrag%2Fsfr%2Fgnrc_sixlowpan_frag_sfr.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  388](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

## Files

 f41b4b6
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a)
2. /[sys](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys)
3. /[net](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net)
4. /[gnrc](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc)
5. /[network\_layer](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer)
6. /[sixlowpan](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan)
7. /[frag](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag)
8. /[sfr](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr)
/
# gnrc\_sixlowpan\_frag\_sfr.c

Copy path Blame  Blame
## Latest commit

## History

[History](/RIOT-OS/RIOT/commits/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c)1873 lines (1726 loc) · 70.5 KB f41b4b6
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a)
2. /[sys](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys)
3. /[net](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net)
4. /[gnrc](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc)
5. /[network\_layer](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer)
6. /[sixlowpan](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan)
7. /[frag](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag)
8. /[sfr](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr)
/
# gnrc\_sixlowpan\_frag\_sfr.c

Top
## File metadata and controls

* Code
* Blame

1873 lines (1726 loc) · 70.5 KB[Raw](https://github.com/RIOT-OS/RIOT/raw/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* Copyright (C) 2019 Freie Universität Berlin \* \* This file is subject to the terms and conditions of the GNU Lesser \* General Public License v2.1. See the file LICENSE in the top level \* directory for more details. \*/
/\*\* \* @{ \* \* @file \* @author Martine Lenders <m.lenders@fu-berlin.de> \*/
#include <stddef.h>
#include "irq.h"#include "kernel\_defines.h"#ifdef MODULE\_GNRC\_IPV6\_NIB#include "net/ipv6/addr.h"#endif#ifdef MODULE\_GNRC\_IPV6#include "net/ipv6/hdr.h"#endif#include "net/gnrc/neterr.h"#include "net/gnrc/netif/internal.h"#include "net/gnrc/netif/pktq.h"#include "net/gnrc/pkt.h"#include "net/gnrc/sixlowpan.h"#include "net/gnrc/sixlowpan/config.h"#include "net/gnrc/sixlowpan/frag/fb.h"#include "net/gnrc/sixlowpan/frag/rb.h"#include "net/gnrc/sixlowpan/frag/vrb.h"#include "net/gnrc/tx\_sync.h"#include "net/sixlowpan/sfr.h"#include "thread.h"#include "unaligned.h"#include "xtimer.h"
#include "net/gnrc/sixlowpan/frag/sfr.h"#include "net/gnrc/sixlowpan/frag/sfr/congure.h"
#define ENABLE\_DEBUG 0#include "debug.h"
#define FRAG\_DESCS\_POOL\_SIZE (CONFIG\_GNRC\_SIXLOWPAN\_FRAG\_FB\_SIZE \* \ CONFIG\_GNRC\_SIXLOWPAN\_SFR\_MAX\_WIN\_SIZE)#define FRAME\_QUEUE\_POOL\_SIZE (FRAG\_DESCS\_POOL\_SIZE + \ CONFIG\_GNRC\_SIXLOWPAN\_FRAG\_VRB\_SIZE)
typedef struct { congure\_snd\_msg\_t super; /\*\*< CongURE message parent \*/ /\*\* \* @brief Acknowledgment request flag, sequence number, and fragment size \*/ uint16\_t ar\_seq\_fs; uint16\_t offset; /\*\*< offset of the fragment \*/} \_frag\_desc\_t;
typedef struct { clist\_node\_t super; /\*\*< list parent instance \*/ gnrc\_pktsnip\_t \*frame; /\*\*< frame in the queue \*/ uint8\_t datagram\_tag; /\*\*< tag for identification \*/ uint8\_t page; /\*\*< parsing page context for the frame \*/} \_frame\_queue\_t;
typedef struct { enum { \_UNDEF = 0, \_RB, \_VRB, } type; union { gnrc\_sixlowpan\_frag\_rb\_base\_t \*base; gnrc\_sixlowpan\_frag\_rb\_t \*rb; gnrc\_sixlowpan\_frag\_vrb\_t \*vrb; } entry;} \_generic\_rb\_entry\_t;
#ifdef MODULE\_GNRC\_IPV6\_NIBstatic char addr\_str[IPV6\_ADDR\_MAX\_STR\_LEN];#else /\* MODULE\_GNRC\_IPV6\_NIB \*/static char addr\_str[GNRC\_NETIF\_HDR\_L2ADDR\_PRINT\_LEN];#endif /\* MODULE\_GNRC\_IPV6\_NIB \*/
static evtimer\_msg\_t \_arq\_timer;static xtimer\_t \_if\_gap\_timer = { 0 };static msg\_t \_if\_gap\_msg = { .type = GNRC\_SIXLOWPAN\_FRAG\_SFR\_INTER\_FRAG\_GAP\_MSG };static uint32\_t \_last\_frame\_sent = 0U;
static \_frag\_desc\_t \_frag\_descs\_pool[FRAG\_DESCS\_POOL\_SIZE];static \_frame\_queue\_t \_frame\_queue\_pool[FRAME\_QUEUE\_POOL\_SIZE];
static clist\_node\_t \_frag\_descs\_free;static clist\_node\_t \_frame\_queue\_free;static clist\_node\_t \_frame\_queue;
static const gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t \_full\_bitmap = { .u32 = UINT32\_MAX };static const gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t \_null\_bitmap = { .u32 = 0U };
static gnrc\_sixlowpan\_frag\_sfr\_stats\_t \_stats;
/\*\* \* @brief Converts a @ref sys\_bitmap based bitmap to a \* gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t \* \* @param[in] bitmap A @ref sys\_bitmap \* \* @return A gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t. \*/static inline gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t \*\_get\_bitmap(gnrc\_sixlowpan\_frag\_rb\_t \*frag\_rb);
/\*\* \* @brief Checks if fragment represented by a fragment descriptor requested an \* ACK \*/static inline bool \_frag\_ack\_req(\_frag\_desc\_t \*frag);/\*\* \* @brief Returns sequence number for fragment represented by fragment \* descriptor \*/static inline uint8\_t \_frag\_seq(\_frag\_desc\_t \*frag);
/\*\* \* @brief Returns fragment size for fragment represented by fragment \* descriptor \*/static inline uint16\_t \_frag\_size(\_frag\_desc\_t \*frag);
/\*\* \* @brief Cleans up a fragmentation buffer entry and all state related to its \* datagram. \* \* @param[in] fbuf A fragmentation buffer entry \* @param[in] error An errno to provide to an upper layer as the reason for why \* gnrc\_sixlowpan\_frag\_fb\_t::pkt of @p fbuf was released. \*/static void \_clean\_up\_fbuf(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, int error);
/\*\* \* @brief Send first fragment. \* \* @param[in] netif Network interface to send fragment over \* @param[in] fbuf Fragmentation buffer for the datagram to fragment \* @param[in] page Current 6Lo dispatch parsing page. \* @param[in,out] tx\_sync Packet snip used to synchronize with transmission, if gnrc\_tx\_sync is \* used \* \* @return Size of the fragment \*/static uint16\_t \_send\_1st\_fragment(gnrc\_netif\_t \*netif, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, unsigned page, gnrc\_pktsnip\_t \*\*tx\_sync);
/\*\* \* @brief Send subsequent fragment. \* \* @param[in] netif Network interface to send fragment over \* @param[in] fbuf Fragmentation buffer for the datagram to fragment \* @param[in] page Current 6Lo dispatch parsing page. \* @param[in,out] tx\_sync Packet snip used to synchronize with transmission, if gnrc\_tx\_sync is \* used \* \* @return Size of the fragment \*/static uint16\_t \_send\_nth\_fragment(gnrc\_netif\_t \*netif, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, unsigned page, gnrc\_pktsnip\_t \*\*tx\_sync);
/\*\* \* @brief Send a abort pseudo fragment for datagram identified by @p tag \* \* @param[in] pkt Datagram that is to be aborted. \* @param[in] fbuf Fragmentation buffer for @p pkt. \* @param[in] req\_ack Request ACK for pseudo fragment from receive \* @param[in] page Current 6Lo dispatch parsing page. \* \* @return true, if abort pseudo fragment was sent. \* @return false, if abort pseudo fragment was unable to be sent. \*/static bool \_send\_abort\_frag(gnrc\_pktsnip\_t \*pkt, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, bool req\_ack, unsigned page);
/\*\* \* @brief Adapts currently sent number of fragments to current window size \* \* Balances `fbuf->sfr.window` with `fbuf->sfr.congure->cwnd` \* \* @param[in] fbuf Fragmentation buffer to adapt window for \*/static void \_shrink\_window(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf);
/\*\* \* @brief Re-send a fragment \* \* @param[in] node The fragment descriptor for the fragment to be \* resend \* @param[in] fbuf\_ptr Fragmentation buffer for the datagram to fragment \* \* Used as a `clist\_foreach()` iterator function \* \* return true when fragment was resent \* return false on error \*/static int \_resend\_frag(clist\_node\_t \*node, void \*fbuf\_ptr);
/\*\* \* @brief Retry to send the complete datagram \* \* @param[in] fbuf Fragmentation buffer for the datagram \*/static void \_retry\_datagram(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf);
/\*\* \* @brief Cleans up state for the causing RFRAG and optionally also sends an \* abort ACK (NULL-bitmap ACK). \* \* @param[in] pkt The packet causing the abort. Will be released \* by this function. gnrc\_pktsnip\_t::data of @p pkt is \* expected to point to an RFRAG packet. \* @param[in] entry (Virtual) reassembly buffer entry to abort. \* @param[in] netif\_hdr NETIF header of @p pkt. \* @param[in] send\_ack Send an abort ACK. \*/static void \_abort\_rb(gnrc\_pktsnip\_t \*pkt, \_generic\_rb\_entry\_t \*entry, gnrc\_netif\_hdr\_t \*netif\_hdr, bool send\_ack);
/\*\* \* @brief Sends an RFRAG-ACK \* \* @param[in] netif Network interface to send ACK over \* @param[in] dst Destination address of ACK. \* @param[in] dst\_len Length of @p dst. \* @param[in] rfrag The RFRAG to ACK \* @param[in] bitmap The bitmap for the ACK. \*/static void \_send\_ack(gnrc\_netif\_t \*netif, const uint8\_t \*dst, uint8\_t dst\_len, const sixlowpan\_sfr\_t \*rfrag, const uint8\_t \*bitmap);
/\*\* \* @brief Schedule next frame (RFRAG or RFRAG-ACK) with \* @ref GNRC\_SIXLOWPAN\_FRAG\_SFR\_INTER\_FRAG\_GAP\_MSG \* \* @param[in] fbuf A fragmentation buffer holding the state of the datagram \* and recoverable fragments. \*/static void \_sched\_next\_frame(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf);
/\*\* \* @brief Schedule ARQ timeout \* \* @param[in] fbuf A fragmentation buffer holding the state of the datagram \* and recoverable fragments. \* @param[in] offset Offset for the ARQ timeout in milliseconds. \*/static void \_sched\_arq\_timeout(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, uint32\_t offset);
/\*\* \* @brief Schedule ARQ timeout for an abort fragment pseudo fragment \* \* @param[in,out] fbuf A fragmentation buffer. All state information will be \* cleared when called, except for identifying the ACK. \*/static void \_sched\_abort\_timeout(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf);
/\*\* \* @brief Handle a received RFRAG packet \* \* @param[in] netif\_hdr NETIF header of @p pkt \* @param[in] pkt An RFRAG packet \* @param[in] page Current 6Lo dispatch parsing page. \*/static void \_handle\_rfrag(gnrc\_netif\_hdr\_t \*netif\_hdr, gnrc\_pktsnip\_t \*pkt, unsigned page);
/\*\* \* @brief Handle a received RFRAG-ACK \* \* @param[in] netif\_hdr NETIF header of @p pkt \* @param[in] pkt An RFRAG-ACK \* @param[in] page Current 6Lo dispatch parsing page. \*/static void \_handle\_ack(gnrc\_netif\_hdr\_t \*netif\_hdr, gnrc\_pktsnip\_t \*pkt, unsigned page);
/\*\* \* @brief Forward a RFRAG \* \* @pre `entry->type == \_VRB` \* \* @param[in] pkt The RFRAG to forward (without NETIF header) \* @param[in] entry The VRB entry to determine the route \* @param[in] offset Offset (from the incoming RFRAG's field) of the RFRAG. \* for offset > 0 this will be adapted for the offset \* difference from the first fragment due to recompression \* @param[in] page Current 6Lo dispatch parsing page. \* \* @return 0 on success, \* @return -ENOMEM, when packet buffer is too full to prepare packet for \* forwarding. @p pkt is released in that case. \*/static int \_forward\_rfrag(gnrc\_pktsnip\_t \*pkt, \_generic\_rb\_entry\_t \*entry, uint16\_t offset, unsigned page);
/\* ====== PUBLIC FUNCTION DEFINITIONS ====== \*/void gnrc\_sixlowpan\_frag\_sfr\_init(void){ if (gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_has\_inter\_frame\_gap()) { for (unsigned i = 0; i < FRAME\_QUEUE\_POOL\_SIZE; i++) { clist\_rpush(&\_frame\_queue\_free, &\_frame\_queue\_pool[i].super); } } for (unsigned i = 0; i < FRAG\_DESCS\_POOL\_SIZE; i++) { clist\_rpush(&\_frag\_descs\_free, &\_frag\_descs\_pool[i].super.super); }}
void gnrc\_sixlowpan\_frag\_sfr\_send(gnrc\_pktsnip\_t \*pkt, void \*ctx, unsigned page){ gnrc\_sixlowpan\_frag\_fb\_t \*fbuf = ctx; gnrc\_netif\_t \*netif; int error\_no = GNRC\_NETERR\_SUCCESS; gnrc\_pktsnip\_t \*tx\_sync = NULL; uint16\_t res;
 assert((fbuf != NULL) && ((fbuf->pkt == pkt) || (pkt == NULL))); DEBUG("6lo sfr: (re-)sending fragmented datagram %u\n", fbuf->tag); pkt = fbuf->pkt; assert(pkt->type == GNRC\_NETTYPE\_NETIF); netif = gnrc\_netif\_hdr\_get\_netif(pkt->data); assert(netif != NULL);
 if (IS\_USED(MODULE\_GNRC\_TX\_SYNC)) { tx\_sync = gnrc\_tx\_sync\_split(pkt); }
 if (fbuf->offset == 0) { DEBUG("6lo sfr: sending first fragment\n"); gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_setup(fbuf); res = \_send\_1st\_fragment(netif, fbuf, page, &tx\_sync); if (res == 0) { DEBUG("6lo sfr: error sending first fragment\n"); /\* \_send\_1st\_fragment only returns 0 if there is a memory problem \*/ error\_no = ENOMEM; goto error; } } else if (!gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_in\_cwnd(fbuf)) { DEBUG("6lo sfr: frags\_sent not within congestion window: " "don't send more\n"); return; } else if (fbuf->offset < fbuf->datagram\_size) { DEBUG("6lo sfr: sending subsequent fragment\n");#if IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_CONGURE) assert(fbuf->sfr.congure); assert(fbuf->sfr.congure->driver);#endif res = \_send\_nth\_fragment(netif, fbuf, page, &tx\_sync); if (res == 0) { DEBUG("6lo sfr: error sending subsequent fragment (offset = %u)\n", fbuf->offset); /\* \_send\_nth\_fragment only returns 0 if there is a memory problem \*/ error\_no = ENOMEM; goto error; } } else { /\* offset is greater or equal to datagram size \* => we are done sending fragments (not an error, but we can release \* the fragmentation buffer now) \*/ goto error; } gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_report\_frag\_sent(fbuf); fbuf->offset += res;
 if (gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_in\_cwnd(fbuf) && (fbuf->offset < fbuf->datagram\_size) && !gnrc\_sixlowpan\_frag\_fb\_send(fbuf)) { /\* the queue of the 6LoWPAN thread is full \*/ error\_no = ENOMEM; /\* go back offset to not send abort on first fragment \*/ fbuf->offset -= res; gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_report\_frag\_discard(fbuf); goto error; } /\* check if last fragment sent requested an ACK \*/ \_frag\_desc\_t \*frag\_desc = (\_frag\_desc\_t \*)clist\_rpeek(&fbuf->sfr.window); DEBUG("6lo sfr: last sent fragment (tag: %u, X: %i, seq: %u, " "frag\_size: %u, offset: %u)\n", (uint8\_t)fbuf->tag, \_frag\_ack\_req(frag\_desc), \_frag\_seq(frag\_desc), \_frag\_size(frag\_desc), frag\_desc->offset); if (\_frag\_ack\_req(frag\_desc)) { /\* initialize \_arq\_timer if not yet done \*/ if (\_arq\_timer.callback == NULL) { evtimer\_init\_msg(&\_arq\_timer); } \_sched\_arq\_timeout(fbuf, fbuf->sfr.arq\_timeout); }
 if (IS\_USED(MODULE\_GNRC\_TX\_SYNC) && tx\_sync) { /\* re-attach tx\_sync to allow releasing it at end \* of transmission, or transmission failure \*/ gnrc\_pkt\_append(pkt, tx\_sync); } thread\_yield(); return;error: /\* don't send abort for first fragment, the network does not know about \* the datagram \*/ if ((fbuf->offset > 0) && \_send\_abort\_frag(fbuf->pkt, fbuf, true, 0)) { /\* wait for ACK before fbuf is deleted \*/ \_sched\_abort\_timeout(fbuf); } else { \_clean\_up\_fbuf(fbuf, error\_no); } if (IS\_USED(MODULE\_GNRC\_TX\_SYNC) && tx\_sync) { gnrc\_pktbuf\_release(tx\_sync); }}
void gnrc\_sixlowpan\_frag\_sfr\_recv(gnrc\_pktsnip\_t \*pkt, void \*ctx, unsigned page){ sixlowpan\_sfr\_t \*hdr; gnrc\_netif\_hdr\_t \*netif\_hdr;
 (void)ctx; DEBUG("6lo sfr: received selective fragment forwarding message\n"); assert(pkt != NULL); hdr = pkt->data; assert(pkt->next != NULL); netif\_hdr = pkt->next->data; assert(netif\_hdr != NULL); if (page != 0) { DEBUG("6lo sfr: Invalid page %u\n", page); gnrc\_pktbuf\_release(pkt); } else if (sixlowpan\_sfr\_rfrag\_is(hdr)) { \_handle\_rfrag(netif\_hdr, pkt, page); } else if (sixlowpan\_sfr\_ack\_is(hdr)) { \_handle\_ack(netif\_hdr, pkt, page); } else { DEBUG("6lo sfr: Unknown dispatch: %02x\n", hdr->disp\_ecn & SIXLOWPAN\_SFR\_DISP\_MASK); gnrc\_pktbuf\_release(pkt); }}
int gnrc\_sixlowpan\_frag\_sfr\_forward(gnrc\_pktsnip\_t \*pkt, sixlowpan\_sfr\_rfrag\_t \*rfrag, gnrc\_sixlowpan\_frag\_vrb\_t \*vrbe, unsigned page){ \_generic\_rb\_entry\_t entry = { .type = \_VRB, .entry = { .vrb = vrbe } }; gnrc\_pktsnip\_t \*hdrsnip = gnrc\_pktbuf\_add(pkt, rfrag, sizeof(\*rfrag), GNRC\_NETTYPE\_SIXLOWPAN);
 /\* free all intervals associated to the VRB entry, as we don't need them \* with SFR, so throw them out, to save this resource \*/ while (vrbe->super.ints) { vrbe->super.ints->end = 0U; vrbe->super.ints = vrbe->super.ints->next; } if (hdrsnip == NULL) { DEBUG("6lo sfr: Unable to allocate new rfrag header\n"); gnrc\_pktbuf\_release(pkt); return -ENOMEM; } DEBUG("6lo sfr: adapting old fragment size (%u) for forwarding to %u\n", sixlowpan\_sfr\_rfrag\_get\_frag\_size(hdrsnip->data), (unsigned)gnrc\_pkt\_len(pkt)); /\* due to compression, packet length of the original fragment might have \* changed \*/ sixlowpan\_sfr\_rfrag\_set\_frag\_size(hdrsnip->data, gnrc\_pkt\_len(pkt)); /\* offset is adapted in `\_forward\_rfrag()` \*/ return \_forward\_rfrag(hdrsnip, &entry, sixlowpan\_sfr\_rfrag\_get\_offset(rfrag), page);}
static int \_report\_non\_ack\_req\_window\_sent(clist\_node\_t \*node, void \*fbuf\_ptr){ \_frag\_desc\_t \*frag\_desc = (\_frag\_desc\_t \*)node; if (!\_frag\_ack\_req(frag\_desc)) { gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_report\_frag\_sent(fbuf\_ptr); } return 0;}
void gnrc\_sixlowpan\_frag\_sfr\_arq\_timeout(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf){ uint32\_t now = xtimer\_now\_usec() / US\_PER\_MS; \_frag\_desc\_t \*frag\_desc = (\_frag\_desc\_t \*)fbuf->sfr.window.next; uint32\_t next\_arq\_offset = fbuf->sfr.arq\_timeout; bool reschedule\_arq\_timeout = false; int error\_no = ETIMEDOUT; /\* assume time out for fbuf->pkt \*/
 DEBUG("6lo sfr: ARQ timeout for datagram %u\n", fbuf->tag); fbuf->sfr.arq\_timeout\_event.msg.content.ptr = NULL; if (IS\_ACTIVE(CONFIG\_GNRC\_SIXLOWPAN\_SFR\_MOCK\_ARQ\_TIMER)) { /\* mock-up to emulate time having passed beyond (1us) the ARQ timeout \*/ now -= (fbuf->sfr.arq\_timeout \* US\_PER\_MS) + 1; } if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_CONGURE) && frag\_desc) { /\* report timeout to CongURE state \*/ gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_report\_frags\_timeout(fbuf); \_shrink\_window(fbuf); /\* potentially shrink window \*/ /\* reassign frag\_desc, in case window head changed \*/ frag\_desc = (\_frag\_desc\_t \*)fbuf->sfr.window.next; } /\* copying clist\_foreach because we can't work just in function context \*/ \_frag\_desc\_t \* const head = frag\_desc; if (frag\_desc) { do { uint32\_t diff;
 frag\_desc = (\_frag\_desc\_t \*)frag\_desc->super.super.next; diff = now - frag\_desc->super.send\_time; if (diff < fbuf->sfr.arq\_timeout) { /\* this fragment's last was last sent < fbuf->sfr.arq\_timeout \* ago \*/ uint32\_t offset = fbuf->sfr.arq\_timeout - diff;
 DEBUG("6lo sfr: wait for fragment %u in next reschedule\n", \_frag\_seq(frag\_desc)); if (offset < next\_arq\_offset) { /\* wait for this fragments ACK next \*/ next\_arq\_offset = offset; DEBUG(" (next ARQ timeout in %lu)\n", (long unsigned)next\_arq\_offset); } /\* this fragment is still waiting for its ACK, \* reschedule the next ACK timeout to the difference \* of the ACK timeout and the time of its last send \*/ reschedule\_arq\_timeout = true; } else if (\_frag\_ack\_req(frag\_desc)) { /\* for this fragment we requested an ACK which was not received \* yet. Try to resend it \*/ if ((frag\_desc->super.resends++) < CONFIG\_GNRC\_SIXLOWPAN\_SFR\_FRAG\_RETRIES) { /\* we have retries left for this fragment \*/ DEBUG("6lo sfr: %u retries left for fragment (tag: %u, " "X: %i, seq: %u, frag\_size: %u, offset: %u)\n", CONFIG\_GNRC\_SIXLOWPAN\_SFR\_FRAG\_RETRIES - (frag\_desc->super.resends - 1), (uint8\_t)fbuf->tag, \_frag\_ack\_req(frag\_desc), \_frag\_seq(frag\_desc), \_frag\_size(frag\_desc), frag\_desc->offset); if (\_resend\_frag(&frag\_desc->super.super, fbuf) != 0) { /\* \_resend\_frag failed due to a memory resource \* problem \*/ error\_no = ENOMEM; goto error; } else { if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_CONGURE)) { /\* fragment was resent successfully, report this to CongURE state \* object \*/ gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_report\_frag\_sent(fbuf); } if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_STATS)) { /\* fragment was resent successfully, note this done \* in the statistics \*/ \_stats.fragment\_resends.by\_timeout++; } } /\* fragment was resent successfully, schedule next ACK \* timeout \*/ reschedule\_arq\_timeout = true; } else { /\* out of retries \*/ DEBUG("6lo sfr: no retries left for fragment " "(tag: %u, X: %i, seq: %u, frag\_size: %u, " "offset: %u)\n", (uint8\_t)fbuf->tag, \_frag\_ack\_req(frag\_desc), \_frag\_seq(frag\_desc), \_frag\_size(frag\_desc), frag\_desc->offset); /\* we are out of retries on the fragment level, but we \* might be able to retry the datagram if retries for the \* datagram are configured. \*/ \_retry\_datagram(fbuf); return; } } else { /\* Do not resend fragments that were not explicitly asking for \* an ACK from the reassembling endpoint on ACK timeout. \* If this is true for all fragments remaining in the fragment \* buffer, the datagram is to be considered timed out, so \* error\_no should remain ETIMEDOUT \*/ DEBUG("6lo sfr: nothing to do for fragment %u\n", \_frag\_seq(frag\_desc)); } } while (frag\_desc != head); /\* report all non-ack\_req fragments in window also as sent, since even \* the lost fragments are still in flight (even though they were \* previously marked as timed out) \*/ clist\_foreach(&fbuf->sfr.window, \_report\_non\_ack\_req\_window\_sent, fbuf); } else { /\* No fragments to resend, we can assume the packet was delivered \* successfully \*/ error\_no = GNRC\_NETERR\_SUCCESS; } assert(fbuf->sfr.frags\_sent == clist\_count(&fbuf->sfr.window)); if (reschedule\_arq\_timeout) { \_sched\_arq\_timeout(fbuf, next\_arq\_offset); return; }error: /\* don't check return value, as we don't want to wait for an ACK again ;-) \*/ \_send\_abort\_frag(fbuf->pkt, fbuf, false, 0); \_clean\_up\_fbuf(fbuf, error\_no);}
void gnrc\_sixlowpan\_frag\_sfr\_inter\_frame\_gap(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf){ if (gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_has\_inter\_frame\_gap()) { \_frame\_queue\_t \*node = (\_frame\_queue\_t \*)clist\_lpop(&\_frame\_queue);
 if (node != NULL) { \_last\_frame\_sent = xtimer\_now\_usec(); gnrc\_sixlowpan\_dispatch\_send(node->frame, NULL, node->page); /\* unset packet just to be safe \*/ node->frame = NULL; clist\_rpush(&\_frame\_queue\_free, &node->super); } if (clist\_lpeek(&\_frame\_queue) != NULL) { \_sched\_next\_frame(fbuf); } }}
void gnrc\_sixlowpan\_frag\_sfr\_stats\_get(gnrc\_sixlowpan\_frag\_sfr\_stats\_t \*stats){ if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_STATS)) { \*stats = \_stats; }}
/\* ====== INTERNAL FUNCTION DEFINITIONS ====== \*/static inline uint16\_t \_min(uint16\_t a, size\_t b){ return (a < b) ? a : (uint16\_t)b;}
static inline kernel\_pid\_t \_getpid(void){ /\* in production, only the 6LoWPAN thread is supposed to call the API \* functions, so just get the current thread's PID for sending messages. \* When testing, those functions might however be called by the testing \* thread (usually the main thread), so indirect over the 6LoWPAN thread in \* that case \*/ return IS\_ACTIVE(TEST\_SUITES) ? gnrc\_sixlowpan\_get\_pid() : thread\_getpid();}
/\* \* @brief Returns the datagram in @p fbuf to its original state \* \* This function can be both used to clean up the fragmentation buffer on \* failure without releasing @p fbuf's gnrc\_sixlowpan\_frag\_fb\_t::pkt and to \* reset a datagram for a datagram retry. \* \* @param[in] fbuf The fragmentation buffer entry to clean up \*/static void \_clean\_slate\_datagram(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf){ clist\_node\_t new\_queue = { .next = NULL };
 fbuf->sfr.arq\_timeout\_event.msg.content.ptr = NULL; /\* remove potentially scheduled timers for this datagram \*/ evtimer\_del((evtimer\_t \*)(&\_arq\_timer), &fbuf->sfr.arq\_timeout\_event.event); fbuf->sfr.arq\_timeout\_event.event.next = NULL; if (gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_has\_inter\_frame\_gap()) { for (clist\_node\_t \*node = clist\_lpop(&\_frame\_queue); node != NULL; node = clist\_lpop(&\_frame\_queue)) { \_frame\_queue\_t \*entry = (\_frame\_queue\_t \*)node; /\* remove frames of this datagram from frame queue \*/ if (entry->datagram\_tag == fbuf->tag) { gnrc\_pktbuf\_release(entry->frame); /\* unset packet just to be safe \*/ entry->frame = NULL; clist\_rpush(&\_frag\_descs\_free, node); } else { clist\_rpush(&new\_queue, node); } } /\* reset frame queue with remaining frames \*/ \_frame\_queue = new\_queue; } fbuf->offset = 0U; fbuf->sfr.cur\_seq = 0U; fbuf->sfr.frags\_sent = 0U; for (clist\_node\_t \*node = clist\_lpop(&fbuf->sfr.window); node != NULL; node = clist\_lpop(&fbuf->sfr.window)) { clist\_rpush(&\_frag\_descs\_free, node); }}
static gnrc\_pktsnip\_t \*\_build\_rfrag(uint8\_t tag, bool ack\_req, uint16\_t size, uint8\_t seq){ sixlowpan\_sfr\_rfrag\_t \*hdr; gnrc\_pktsnip\_t \*frag = gnrc\_pktbuf\_add(NULL, NULL, sizeof(sixlowpan\_sfr\_rfrag\_t) + size, GNRC\_NETTYPE\_SIXLOWPAN);
 if (frag == NULL) { return NULL; } sixlowpan\_sfr\_rfrag\_set\_disp(frag->data);
 hdr = frag->data; hdr->base.tag = tag; if (ack\_req) { sixlowpan\_sfr\_rfrag\_set\_ack\_req(hdr); } else { sixlowpan\_sfr\_rfrag\_clear\_ack\_req(hdr); } sixlowpan\_sfr\_rfrag\_set\_frag\_size(hdr, size); sixlowpan\_sfr\_rfrag\_set\_seq(hdr, seq); /\* set offset / datagram\_size in callers \*/ return frag;}
static gnrc\_pktsnip\_t \*\_build\_frag\_pkt(gnrc\_netif\_hdr\_t \*old\_netif\_hdr, uint8\_t tag, bool ack\_req, uint16\_t size, uint8\_t seq){ gnrc\_netif\_hdr\_t \*new\_netif\_hdr; gnrc\_pktsnip\_t \*netif, \*res;
 DEBUG("6lo sfr: building fragment (tag: %u, X: %i, seq: %u, frag\_size: %u)\n", tag, ack\_req, seq, size); netif = gnrc\_netif\_hdr\_build(gnrc\_netif\_hdr\_get\_src\_addr(old\_netif\_hdr), old\_netif\_hdr->src\_l2addr\_len, gnrc\_netif\_hdr\_get\_dst\_addr(old\_netif\_hdr), old\_netif\_hdr->dst\_l2addr\_len); if (netif == NULL) { return NULL; }
 new\_netif\_hdr = netif->data; \*new\_netif\_hdr = \*old\_netif\_hdr; res = \_build\_rfrag(tag, ack\_req, size, seq); if (res == NULL) { gnrc\_pktbuf\_release(netif); return NULL; } return gnrc\_pkt\_prepend(res, netif);}
static gnrc\_pktsnip\_t \*\_build\_frag\_from\_fbuf(gnrc\_pktsnip\_t \*pkt, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, uint16\_t frag\_size){ return \_build\_frag\_pkt(pkt->data, (uint8\_t)fbuf->tag, ((frag\_size + fbuf->offset) >= fbuf->datagram\_size) || /\* we only can send the next fragment we build here, \* so request ACK for it \*/ !gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_next\_in\_cwnd(fbuf), frag\_size, fbuf->sfr.cur\_seq);}
static uint16\_t \_copy\_pkt\_to\_frag(uint8\_t \*data, const gnrc\_pktsnip\_t \*pkt, uint16\_t frag\_size, uint16\_t init\_offset){ uint16\_t offset = init\_offset;
 while ((pkt != NULL) && (offset < frag\_size)) { uint16\_t len = \_min(frag\_size - offset, pkt->size);
 memcpy(data + offset, pkt->data, len);
 offset += len; pkt = pkt->next; } return offset;}
static uint16\_t \_find\_offset\_and\_copy\_rest(uint8\_t \*data, gnrc\_pktsnip\_t \*\*pkt, uint16\_t frag\_size, uint16\_t offset){ uint16\_t offset\_count = 0, cur\_frag\_size = 0; while ((\*pkt != NULL) && (offset\_count != offset)) { /\* go to offset \*/ uint16\_t pkt\_size = (uint16\_t)(\*pkt)->size; offset\_count += pkt\_size;
 if (offset\_count > offset) { /\* we overshot \*/ /\* => copy rest of partly send packet snip \*/ uint16\_t pkt\_offset = offset - (offset\_count - pkt\_size); size\_t clen = \_min(frag\_size, pkt\_size - pkt\_offset);
 memcpy(data, ((uint8\_t \*)(\*pkt)->data) + pkt\_offset, clen); cur\_frag\_size = clen; \*pkt = (\*pkt)->next; break; } \*pkt = (\*pkt)->next; } return cur\_frag\_size;}
static void \_check\_for\_ecn(gnrc\_pktsnip\_t \*frame){ if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_ECN) && (sixlowpan\_sfr\_rfrag\_is(frame->next->data))) { int queue\_state = 0; int queue\_size = 0;
 if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_ECN\_IF\_IN)) { gnrc\_netif\_t \*netif = gnrc\_netif\_hdr\_get\_netif(frame->data);
 assert(frame->type == GNRC\_NETTYPE\_NETIF); assert(frame->next->type == GNRC\_NETTYPE\_SIXLOWPAN); queue\_state = msg\_avail\_thread(netif->pid); queue\_size = msg\_queue\_capacity(netif->pid); assert(queue\_size > 0);
 if ((queue\_state \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_IF\_IN\_DEN) > (queue\_size \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_IF\_IN\_NUM)) { sixlowpan\_sfr\_set\_ecn(frame->next->data); } }
 if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_ECN\_IF\_OUT)) { queue\_state = gnrc\_netif\_pktq\_usage(); queue\_size = CONFIG\_GNRC\_NETIF\_PKTQ\_POOL\_SIZE;
 if ((queue\_state \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_IF\_OUT\_DEN) > (queue\_size \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_IF\_OUT\_NUM)) { sixlowpan\_sfr\_set\_ecn(frame->next->data); } }
 if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_ECN\_FQUEUE)) { queue\_state = clist\_count(&\_frame\_queue); queue\_size = FRAME\_QUEUE\_POOL\_SIZE;
 if ((queue\_state \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_FQUEUE\_DEN) > (queue\_size \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_FQUEUE\_NUM)) { sixlowpan\_sfr\_set\_ecn(frame->next->data); } } }}
static bool \_send\_frame(gnrc\_pktsnip\_t \*frame, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, void \*ctx, unsigned page){ uint32\_t now; uint32\_t if\_gap = gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_inter\_frame\_gap(fbuf);
 \_check\_for\_ecn(frame); now = xtimer\_now\_usec(); if ((if\_gap == 0) || ((now - \_last\_frame\_sent) > if\_gap)) { DEBUG("6lo sfr: dispatch frame to network interface\n"); \_last\_frame\_sent = now; gnrc\_sixlowpan\_dispatch\_send(frame, ctx, page); return true; } else { \_frame\_queue\_t \*node = (\_frame\_queue\_t \*)clist\_lpop(&\_frame\_queue\_free);
 if (node != NULL) { sixlowpan\_sfr\_t \*hdr = frame->next->data;
 assert(sixlowpan\_sfr\_is(hdr)); node->frame = frame; node->datagram\_tag = hdr->tag; node->page = page; clist\_rpush(&\_frame\_queue, &node->super); \_sched\_next\_frame(fbuf); } return (node != NULL); }}
static bool \_send\_fragment(gnrc\_pktsnip\_t \*frag, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, unsigned page, uint16\_t offset){ sixlowpan\_sfr\_rfrag\_t \*hdr = frag->next->data; \_frag\_desc\_t \*frag\_desc = (\_frag\_desc\_t \*)clist\_lpop(&\_frag\_descs\_free); bool res;
 if (frag\_desc == NULL) { DEBUG("6lo sfr: could not remember fragment to send\n"); gnrc\_pktbuf\_release(frag); return false; } frag\_desc->ar\_seq\_fs = byteorder\_ntohs(hdr->ar\_seq\_fs); frag\_desc->offset = offset; frag\_desc->super.size = 1; frag\_desc->super.resends = 0; clist\_rpush(&fbuf->sfr.window, &frag\_desc->super.super); if ((res = \_send\_frame(frag, fbuf, NULL, page))) { if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_STATS)) { \_stats.fragments\_sent.usual++; } frag\_desc->super.send\_time = \_last\_frame\_sent / US\_PER\_MS; fbuf->sfr.cur\_seq++; fbuf->sfr.frags\_sent++; } return res;}
static gnrc\_pktsnip\_t \*\_build\_ack(gnrc\_netif\_t \*netif, const uint8\_t \*dst, uint8\_t dst\_len, const sixlowpan\_sfr\_t \*hdr, const uint8\_t \*bitmap){ gnrc\_pktsnip\_t \*ack\_snip, \*ack\_netif; sixlowpan\_sfr\_ack\_t \*ack;
 ack\_netif = gnrc\_netif\_hdr\_build(NULL, 0, dst, dst\_len); if (ack\_netif == NULL) { DEBUG("6lo sfr: can't allocate netif header for ACK for (%s, %02x).\n", gnrc\_netif\_addr\_to\_str(dst, dst\_len, addr\_str), hdr->tag); return NULL; } gnrc\_netif\_hdr\_set\_netif(ack\_netif->data, netif);
 ack\_snip = gnrc\_pktbuf\_add(NULL, NULL, sizeof(sixlowpan\_sfr\_ack\_t), GNRC\_NETTYPE\_SIXLOWPAN);
 if (ack\_snip == NULL) { DEBUG("6lo sfr: can't allocate ACK for (%s, %02x).\n", gnrc\_netif\_addr\_to\_str(dst, dst\_len, addr\_str), hdr->tag); gnrc\_pktbuf\_release(ack\_netif); return NULL; } ack = ack\_snip->data; /\* https://tools.ietf.org/html/rfc8931#section-6: \* The Datagram\_Tag in the RFRAG\_ACK is unique to the reassembling endpoint \* and is enough information for an intermediate hop to locate the VRB that \* contains the Datagram\_Tag used by the previous hop and the Layer-2 \* information associated with it (interface and Link-Layer address).. \* [...] The reassembling endpoint of a fragment with the 'E' (ECN) flag set \* MUST echo that information at most once by setting the 'E' (ECN) flag in \* the next RFRAG\_ACK. \* \* => base except dispatch are the same as ack'd RFRAG. \*/ ack->base = \*hdr; sixlowpan\_sfr\_ack\_set\_disp(&ack->base); memcpy(ack->bitmap, bitmap, sizeof(ack->bitmap)); ack\_netif->next = ack\_snip; return ack\_netif;}
static void \_clean\_up\_rb\_entry(\_generic\_rb\_entry\_t \*entry){ if (entry != NULL) { switch (entry->type) { case \_RB: gnrc\_pktbuf\_release(entry->entry.rb->pkt); gnrc\_sixlowpan\_frag\_rb\_remove(entry->entry.rb); break; case \_VRB: gnrc\_sixlowpan\_frag\_vrb\_rm(entry->entry.vrb); break; default: break; } }}
static void \_try\_reassembly(gnrc\_netif\_hdr\_t \*netif\_hdr, gnrc\_pktsnip\_t \*rfrag, unsigned offset, \_generic\_rb\_entry\_t \*entry, unsigned page){ gnrc\_sixlowpan\_frag\_vrb\_t \*vrbe; const gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t \*bitmap; sixlowpan\_sfr\_rfrag\_t \*hdr = rfrag->data; gnrc\_pktsnip\_t \*netif\_snip = rfrag->next; /\* copy base for ACK \*/ sixlowpan\_sfr\_t base = hdr->base; int8\_t ack\_req = sixlowpan\_sfr\_rfrag\_ack\_req(hdr); uint8\_t seq = sixlowpan\_sfr\_rfrag\_get\_seq(hdr);
 assert(netif\_snip->data == netif\_hdr); gnrc\_pktbuf\_hold(netif\_snip, 1); /\* hold netif header to use it with \* dispatch\_when\_complete() \* (rb\_add() releases `pkt`) \*/ entry->entry.rb = gnrc\_sixlowpan\_frag\_rb\_add(netif\_hdr, rfrag,[View remainder of file in raw view](https://github.com/RIOT-OS/RIOT/raw/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_96d221db_20250114_192717.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Ff41b4b67b6affca0a8b32edced7f51088696869a%2Fsys%2Fnet%2Fgnrc%2Fnetwork_layer%2Fsixlowpan%2Ffrag%2Fsfr%2Fgnrc_sixlowpan_frag_sfr.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Ff41b4b67b6affca0a8b32edced7f51088696869a%2Fsys%2Fnet%2Fgnrc%2Fnetwork_layer%2Fsixlowpan%2Ffrag%2Fsfr%2Fgnrc_sixlowpan_frag_sfr.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  388](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

## Files

 f41b4b6
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a)
2. /[sys](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys)
3. /[net](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net)
4. /[gnrc](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc)
5. /[network\_layer](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer)
6. /[sixlowpan](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan)
7. /[frag](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag)
8. /[sfr](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr)
/
# gnrc\_sixlowpan\_frag\_sfr.c

Copy path Blame  Blame
## Latest commit

## History

[History](/RIOT-OS/RIOT/commits/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c)1873 lines (1726 loc) · 70.5 KB f41b4b6
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a)
2. /[sys](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys)
3. /[net](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net)
4. /[gnrc](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc)
5. /[network\_layer](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer)
6. /[sixlowpan](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan)
7. /[frag](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag)
8. /[sfr](/RIOT-OS/RIOT/tree/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr)
/
# gnrc\_sixlowpan\_frag\_sfr.c

Top
## File metadata and controls

* Code
* Blame

1873 lines (1726 loc) · 70.5 KB[Raw](https://github.com/RIOT-OS/RIOT/raw/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* Copyright (C) 2019 Freie Universität Berlin \* \* This file is subject to the terms and conditions of the GNU Lesser \* General Public License v2.1. See the file LICENSE in the top level \* directory for more details. \*/
/\*\* \* @{ \* \* @file \* @author Martine Lenders <m.lenders@fu-berlin.de> \*/
#include <stddef.h>
#include "irq.h"#include "kernel\_defines.h"#ifdef MODULE\_GNRC\_IPV6\_NIB#include "net/ipv6/addr.h"#endif#ifdef MODULE\_GNRC\_IPV6#include "net/ipv6/hdr.h"#endif#include "net/gnrc/neterr.h"#include "net/gnrc/netif/internal.h"#include "net/gnrc/netif/pktq.h"#include "net/gnrc/pkt.h"#include "net/gnrc/sixlowpan.h"#include "net/gnrc/sixlowpan/config.h"#include "net/gnrc/sixlowpan/frag/fb.h"#include "net/gnrc/sixlowpan/frag/rb.h"#include "net/gnrc/sixlowpan/frag/vrb.h"#include "net/gnrc/tx\_sync.h"#include "net/sixlowpan/sfr.h"#include "thread.h"#include "unaligned.h"#include "xtimer.h"
#include "net/gnrc/sixlowpan/frag/sfr.h"#include "net/gnrc/sixlowpan/frag/sfr/congure.h"
#define ENABLE\_DEBUG 0#include "debug.h"
#define FRAG\_DESCS\_POOL\_SIZE (CONFIG\_GNRC\_SIXLOWPAN\_FRAG\_FB\_SIZE \* \ CONFIG\_GNRC\_SIXLOWPAN\_SFR\_MAX\_WIN\_SIZE)#define FRAME\_QUEUE\_POOL\_SIZE (FRAG\_DESCS\_POOL\_SIZE + \ CONFIG\_GNRC\_SIXLOWPAN\_FRAG\_VRB\_SIZE)
typedef struct { congure\_snd\_msg\_t super; /\*\*< CongURE message parent \*/ /\*\* \* @brief Acknowledgment request flag, sequence number, and fragment size \*/ uint16\_t ar\_seq\_fs; uint16\_t offset; /\*\*< offset of the fragment \*/} \_frag\_desc\_t;
typedef struct { clist\_node\_t super; /\*\*< list parent instance \*/ gnrc\_pktsnip\_t \*frame; /\*\*< frame in the queue \*/ uint8\_t datagram\_tag; /\*\*< tag for identification \*/ uint8\_t page; /\*\*< parsing page context for the frame \*/} \_frame\_queue\_t;
typedef struct { enum { \_UNDEF = 0, \_RB, \_VRB, } type; union { gnrc\_sixlowpan\_frag\_rb\_base\_t \*base; gnrc\_sixlowpan\_frag\_rb\_t \*rb; gnrc\_sixlowpan\_frag\_vrb\_t \*vrb; } entry;} \_generic\_rb\_entry\_t;
#ifdef MODULE\_GNRC\_IPV6\_NIBstatic char addr\_str[IPV6\_ADDR\_MAX\_STR\_LEN];#else /\* MODULE\_GNRC\_IPV6\_NIB \*/static char addr\_str[GNRC\_NETIF\_HDR\_L2ADDR\_PRINT\_LEN];#endif /\* MODULE\_GNRC\_IPV6\_NIB \*/
static evtimer\_msg\_t \_arq\_timer;static xtimer\_t \_if\_gap\_timer = { 0 };static msg\_t \_if\_gap\_msg = { .type = GNRC\_SIXLOWPAN\_FRAG\_SFR\_INTER\_FRAG\_GAP\_MSG };static uint32\_t \_last\_frame\_sent = 0U;
static \_frag\_desc\_t \_frag\_descs\_pool[FRAG\_DESCS\_POOL\_SIZE];static \_frame\_queue\_t \_frame\_queue\_pool[FRAME\_QUEUE\_POOL\_SIZE];
static clist\_node\_t \_frag\_descs\_free;static clist\_node\_t \_frame\_queue\_free;static clist\_node\_t \_frame\_queue;
static const gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t \_full\_bitmap = { .u32 = UINT32\_MAX };static const gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t \_null\_bitmap = { .u32 = 0U };
static gnrc\_sixlowpan\_frag\_sfr\_stats\_t \_stats;
/\*\* \* @brief Converts a @ref sys\_bitmap based bitmap to a \* gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t \* \* @param[in] bitmap A @ref sys\_bitmap \* \* @return A gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t. \*/static inline gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t \*\_get\_bitmap(gnrc\_sixlowpan\_frag\_rb\_t \*frag\_rb);
/\*\* \* @brief Checks if fragment represented by a fragment descriptor requested an \* ACK \*/static inline bool \_frag\_ack\_req(\_frag\_desc\_t \*frag);/\*\* \* @brief Returns sequence number for fragment represented by fragment \* descriptor \*/static inline uint8\_t \_frag\_seq(\_frag\_desc\_t \*frag);
/\*\* \* @brief Returns fragment size for fragment represented by fragment \* descriptor \*/static inline uint16\_t \_frag\_size(\_frag\_desc\_t \*frag);
/\*\* \* @brief Cleans up a fragmentation buffer entry and all state related to its \* datagram. \* \* @param[in] fbuf A fragmentation buffer entry \* @param[in] error An errno to provide to an upper layer as the reason for why \* gnrc\_sixlowpan\_frag\_fb\_t::pkt of @p fbuf was released. \*/static void \_clean\_up\_fbuf(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, int error);
/\*\* \* @brief Send first fragment. \* \* @param[in] netif Network interface to send fragment over \* @param[in] fbuf Fragmentation buffer for the datagram to fragment \* @param[in] page Current 6Lo dispatch parsing page. \* @param[in,out] tx\_sync Packet snip used to synchronize with transmission, if gnrc\_tx\_sync is \* used \* \* @return Size of the fragment \*/static uint16\_t \_send\_1st\_fragment(gnrc\_netif\_t \*netif, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, unsigned page, gnrc\_pktsnip\_t \*\*tx\_sync);
/\*\* \* @brief Send subsequent fragment. \* \* @param[in] netif Network interface to send fragment over \* @param[in] fbuf Fragmentation buffer for the datagram to fragment \* @param[in] page Current 6Lo dispatch parsing page. \* @param[in,out] tx\_sync Packet snip used to synchronize with transmission, if gnrc\_tx\_sync is \* used \* \* @return Size of the fragment \*/static uint16\_t \_send\_nth\_fragment(gnrc\_netif\_t \*netif, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, unsigned page, gnrc\_pktsnip\_t \*\*tx\_sync);
/\*\* \* @brief Send a abort pseudo fragment for datagram identified by @p tag \* \* @param[in] pkt Datagram that is to be aborted. \* @param[in] fbuf Fragmentation buffer for @p pkt. \* @param[in] req\_ack Request ACK for pseudo fragment from receive \* @param[in] page Current 6Lo dispatch parsing page. \* \* @return true, if abort pseudo fragment was sent. \* @return false, if abort pseudo fragment was unable to be sent. \*/static bool \_send\_abort\_frag(gnrc\_pktsnip\_t \*pkt, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, bool req\_ack, unsigned page);
/\*\* \* @brief Adapts currently sent number of fragments to current window size \* \* Balances `fbuf->sfr.window` with `fbuf->sfr.congure->cwnd` \* \* @param[in] fbuf Fragmentation buffer to adapt window for \*/static void \_shrink\_window(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf);
/\*\* \* @brief Re-send a fragment \* \* @param[in] node The fragment descriptor for the fragment to be \* resend \* @param[in] fbuf\_ptr Fragmentation buffer for the datagram to fragment \* \* Used as a `clist\_foreach()` iterator function \* \* return true when fragment was resent \* return false on error \*/static int \_resend\_frag(clist\_node\_t \*node, void \*fbuf\_ptr);
/\*\* \* @brief Retry to send the complete datagram \* \* @param[in] fbuf Fragmentation buffer for the datagram \*/static void \_retry\_datagram(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf);
/\*\* \* @brief Cleans up state for the causing RFRAG and optionally also sends an \* abort ACK (NULL-bitmap ACK). \* \* @param[in] pkt The packet causing the abort. Will be released \* by this function. gnrc\_pktsnip\_t::data of @p pkt is \* expected to point to an RFRAG packet. \* @param[in] entry (Virtual) reassembly buffer entry to abort. \* @param[in] netif\_hdr NETIF header of @p pkt. \* @param[in] send\_ack Send an abort ACK. \*/static void \_abort\_rb(gnrc\_pktsnip\_t \*pkt, \_generic\_rb\_entry\_t \*entry, gnrc\_netif\_hdr\_t \*netif\_hdr, bool send\_ack);
/\*\* \* @brief Sends an RFRAG-ACK \* \* @param[in] netif Network interface to send ACK over \* @param[in] dst Destination address of ACK. \* @param[in] dst\_len Length of @p dst. \* @param[in] rfrag The RFRAG to ACK \* @param[in] bitmap The bitmap for the ACK. \*/static void \_send\_ack(gnrc\_netif\_t \*netif, const uint8\_t \*dst, uint8\_t dst\_len, const sixlowpan\_sfr\_t \*rfrag, const uint8\_t \*bitmap);
/\*\* \* @brief Schedule next frame (RFRAG or RFRAG-ACK) with \* @ref GNRC\_SIXLOWPAN\_FRAG\_SFR\_INTER\_FRAG\_GAP\_MSG \* \* @param[in] fbuf A fragmentation buffer holding the state of the datagram \* and recoverable fragments. \*/static void \_sched\_next\_frame(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf);
/\*\* \* @brief Schedule ARQ timeout \* \* @param[in] fbuf A fragmentation buffer holding the state of the datagram \* and recoverable fragments. \* @param[in] offset Offset for the ARQ timeout in milliseconds. \*/static void \_sched\_arq\_timeout(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, uint32\_t offset);
/\*\* \* @brief Schedule ARQ timeout for an abort fragment pseudo fragment \* \* @param[in,out] fbuf A fragmentation buffer. All state information will be \* cleared when called, except for identifying the ACK. \*/static void \_sched\_abort\_timeout(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf);
/\*\* \* @brief Handle a received RFRAG packet \* \* @param[in] netif\_hdr NETIF header of @p pkt \* @param[in] pkt An RFRAG packet \* @param[in] page Current 6Lo dispatch parsing page. \*/static void \_handle\_rfrag(gnrc\_netif\_hdr\_t \*netif\_hdr, gnrc\_pktsnip\_t \*pkt, unsigned page);
/\*\* \* @brief Handle a received RFRAG-ACK \* \* @param[in] netif\_hdr NETIF header of @p pkt \* @param[in] pkt An RFRAG-ACK \* @param[in] page Current 6Lo dispatch parsing page. \*/static void \_handle\_ack(gnrc\_netif\_hdr\_t \*netif\_hdr, gnrc\_pktsnip\_t \*pkt, unsigned page);
/\*\* \* @brief Forward a RFRAG \* \* @pre `entry->type == \_VRB` \* \* @param[in] pkt The RFRAG to forward (without NETIF header) \* @param[in] entry The VRB entry to determine the route \* @param[in] offset Offset (from the incoming RFRAG's field) of the RFRAG. \* for offset > 0 this will be adapted for the offset \* difference from the first fragment due to recompression \* @param[in] page Current 6Lo dispatch parsing page. \* \* @return 0 on success, \* @return -ENOMEM, when packet buffer is too full to prepare packet for \* forwarding. @p pkt is released in that case. \*/static int \_forward\_rfrag(gnrc\_pktsnip\_t \*pkt, \_generic\_rb\_entry\_t \*entry, uint16\_t offset, unsigned page);
/\* ====== PUBLIC FUNCTION DEFINITIONS ====== \*/void gnrc\_sixlowpan\_frag\_sfr\_init(void){ if (gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_has\_inter\_frame\_gap()) { for (unsigned i = 0; i < FRAME\_QUEUE\_POOL\_SIZE; i++) { clist\_rpush(&\_frame\_queue\_free, &\_frame\_queue\_pool[i].super); } } for (unsigned i = 0; i < FRAG\_DESCS\_POOL\_SIZE; i++) { clist\_rpush(&\_frag\_descs\_free, &\_frag\_descs\_pool[i].super.super); }}
void gnrc\_sixlowpan\_frag\_sfr\_send(gnrc\_pktsnip\_t \*pkt, void \*ctx, unsigned page){ gnrc\_sixlowpan\_frag\_fb\_t \*fbuf = ctx; gnrc\_netif\_t \*netif; int error\_no = GNRC\_NETERR\_SUCCESS; gnrc\_pktsnip\_t \*tx\_sync = NULL; uint16\_t res;
 assert((fbuf != NULL) && ((fbuf->pkt == pkt) || (pkt == NULL))); DEBUG("6lo sfr: (re-)sending fragmented datagram %u\n", fbuf->tag); pkt = fbuf->pkt; assert(pkt->type == GNRC\_NETTYPE\_NETIF); netif = gnrc\_netif\_hdr\_get\_netif(pkt->data); assert(netif != NULL);
 if (IS\_USED(MODULE\_GNRC\_TX\_SYNC)) { tx\_sync = gnrc\_tx\_sync\_split(pkt); }
 if (fbuf->offset == 0) { DEBUG("6lo sfr: sending first fragment\n"); gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_setup(fbuf); res = \_send\_1st\_fragment(netif, fbuf, page, &tx\_sync); if (res == 0) { DEBUG("6lo sfr: error sending first fragment\n"); /\* \_send\_1st\_fragment only returns 0 if there is a memory problem \*/ error\_no = ENOMEM; goto error; } } else if (!gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_in\_cwnd(fbuf)) { DEBUG("6lo sfr: frags\_sent not within congestion window: " "don't send more\n"); return; } else if (fbuf->offset < fbuf->datagram\_size) { DEBUG("6lo sfr: sending subsequent fragment\n");#if IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_CONGURE) assert(fbuf->sfr.congure); assert(fbuf->sfr.congure->driver);#endif res = \_send\_nth\_fragment(netif, fbuf, page, &tx\_sync); if (res == 0) { DEBUG("6lo sfr: error sending subsequent fragment (offset = %u)\n", fbuf->offset); /\* \_send\_nth\_fragment only returns 0 if there is a memory problem \*/ error\_no = ENOMEM; goto error; } } else { /\* offset is greater or equal to datagram size \* => we are done sending fragments (not an error, but we can release \* the fragmentation buffer now) \*/ goto error; } gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_report\_frag\_sent(fbuf); fbuf->offset += res;
 if (gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_in\_cwnd(fbuf) && (fbuf->offset < fbuf->datagram\_size) && !gnrc\_sixlowpan\_frag\_fb\_send(fbuf)) { /\* the queue of the 6LoWPAN thread is full \*/ error\_no = ENOMEM; /\* go back offset to not send abort on first fragment \*/ fbuf->offset -= res; gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_report\_frag\_discard(fbuf); goto error; } /\* check if last fragment sent requested an ACK \*/ \_frag\_desc\_t \*frag\_desc = (\_frag\_desc\_t \*)clist\_rpeek(&fbuf->sfr.window); DEBUG("6lo sfr: last sent fragment (tag: %u, X: %i, seq: %u, " "frag\_size: %u, offset: %u)\n", (uint8\_t)fbuf->tag, \_frag\_ack\_req(frag\_desc), \_frag\_seq(frag\_desc), \_frag\_size(frag\_desc), frag\_desc->offset); if (\_frag\_ack\_req(frag\_desc)) { /\* initialize \_arq\_timer if not yet done \*/ if (\_arq\_timer.callback == NULL) { evtimer\_init\_msg(&\_arq\_timer); } \_sched\_arq\_timeout(fbuf, fbuf->sfr.arq\_timeout); }
 if (IS\_USED(MODULE\_GNRC\_TX\_SYNC) && tx\_sync) { /\* re-attach tx\_sync to allow releasing it at end \* of transmission, or transmission failure \*/ gnrc\_pkt\_append(pkt, tx\_sync); } thread\_yield(); return;error: /\* don't send abort for first fragment, the network does not know about \* the datagram \*/ if ((fbuf->offset > 0) && \_send\_abort\_frag(fbuf->pkt, fbuf, true, 0)) { /\* wait for ACK before fbuf is deleted \*/ \_sched\_abort\_timeout(fbuf); } else { \_clean\_up\_fbuf(fbuf, error\_no); } if (IS\_USED(MODULE\_GNRC\_TX\_SYNC) && tx\_sync) { gnrc\_pktbuf\_release(tx\_sync); }}
void gnrc\_sixlowpan\_frag\_sfr\_recv(gnrc\_pktsnip\_t \*pkt, void \*ctx, unsigned page){ sixlowpan\_sfr\_t \*hdr; gnrc\_netif\_hdr\_t \*netif\_hdr;
 (void)ctx; DEBUG("6lo sfr: received selective fragment forwarding message\n"); assert(pkt != NULL); hdr = pkt->data; assert(pkt->next != NULL); netif\_hdr = pkt->next->data; assert(netif\_hdr != NULL); if (page != 0) { DEBUG("6lo sfr: Invalid page %u\n", page); gnrc\_pktbuf\_release(pkt); } else if (sixlowpan\_sfr\_rfrag\_is(hdr)) { \_handle\_rfrag(netif\_hdr, pkt, page); } else if (sixlowpan\_sfr\_ack\_is(hdr)) { \_handle\_ack(netif\_hdr, pkt, page); } else { DEBUG("6lo sfr: Unknown dispatch: %02x\n", hdr->disp\_ecn & SIXLOWPAN\_SFR\_DISP\_MASK); gnrc\_pktbuf\_release(pkt); }}
int gnrc\_sixlowpan\_frag\_sfr\_forward(gnrc\_pktsnip\_t \*pkt, sixlowpan\_sfr\_rfrag\_t \*rfrag, gnrc\_sixlowpan\_frag\_vrb\_t \*vrbe, unsigned page){ \_generic\_rb\_entry\_t entry = { .type = \_VRB, .entry = { .vrb = vrbe } }; gnrc\_pktsnip\_t \*hdrsnip = gnrc\_pktbuf\_add(pkt, rfrag, sizeof(\*rfrag), GNRC\_NETTYPE\_SIXLOWPAN);
 /\* free all intervals associated to the VRB entry, as we don't need them \* with SFR, so throw them out, to save this resource \*/ while (vrbe->super.ints) { vrbe->super.ints->end = 0U; vrbe->super.ints = vrbe->super.ints->next; } if (hdrsnip == NULL) { DEBUG("6lo sfr: Unable to allocate new rfrag header\n"); gnrc\_pktbuf\_release(pkt); return -ENOMEM; } DEBUG("6lo sfr: adapting old fragment size (%u) for forwarding to %u\n", sixlowpan\_sfr\_rfrag\_get\_frag\_size(hdrsnip->data), (unsigned)gnrc\_pkt\_len(pkt)); /\* due to compression, packet length of the original fragment might have \* changed \*/ sixlowpan\_sfr\_rfrag\_set\_frag\_size(hdrsnip->data, gnrc\_pkt\_len(pkt)); /\* offset is adapted in `\_forward\_rfrag()` \*/ return \_forward\_rfrag(hdrsnip, &entry, sixlowpan\_sfr\_rfrag\_get\_offset(rfrag), page);}
static int \_report\_non\_ack\_req\_window\_sent(clist\_node\_t \*node, void \*fbuf\_ptr){ \_frag\_desc\_t \*frag\_desc = (\_frag\_desc\_t \*)node; if (!\_frag\_ack\_req(frag\_desc)) { gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_report\_frag\_sent(fbuf\_ptr); } return 0;}
void gnrc\_sixlowpan\_frag\_sfr\_arq\_timeout(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf){ uint32\_t now = xtimer\_now\_usec() / US\_PER\_MS; \_frag\_desc\_t \*frag\_desc = (\_frag\_desc\_t \*)fbuf->sfr.window.next; uint32\_t next\_arq\_offset = fbuf->sfr.arq\_timeout; bool reschedule\_arq\_timeout = false; int error\_no = ETIMEDOUT; /\* assume time out for fbuf->pkt \*/
 DEBUG("6lo sfr: ARQ timeout for datagram %u\n", fbuf->tag); fbuf->sfr.arq\_timeout\_event.msg.content.ptr = NULL; if (IS\_ACTIVE(CONFIG\_GNRC\_SIXLOWPAN\_SFR\_MOCK\_ARQ\_TIMER)) { /\* mock-up to emulate time having passed beyond (1us) the ARQ timeout \*/ now -= (fbuf->sfr.arq\_timeout \* US\_PER\_MS) + 1; } if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_CONGURE) && frag\_desc) { /\* report timeout to CongURE state \*/ gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_report\_frags\_timeout(fbuf); \_shrink\_window(fbuf); /\* potentially shrink window \*/ /\* reassign frag\_desc, in case window head changed \*/ frag\_desc = (\_frag\_desc\_t \*)fbuf->sfr.window.next; } /\* copying clist\_foreach because we can't work just in function context \*/ \_frag\_desc\_t \* const head = frag\_desc; if (frag\_desc) { do { uint32\_t diff;
 frag\_desc = (\_frag\_desc\_t \*)frag\_desc->super.super.next; diff = now - frag\_desc->super.send\_time; if (diff < fbuf->sfr.arq\_timeout) { /\* this fragment's last was last sent < fbuf->sfr.arq\_timeout \* ago \*/ uint32\_t offset = fbuf->sfr.arq\_timeout - diff;
 DEBUG("6lo sfr: wait for fragment %u in next reschedule\n", \_frag\_seq(frag\_desc)); if (offset < next\_arq\_offset) { /\* wait for this fragments ACK next \*/ next\_arq\_offset = offset; DEBUG(" (next ARQ timeout in %lu)\n", (long unsigned)next\_arq\_offset); } /\* this fragment is still waiting for its ACK, \* reschedule the next ACK timeout to the difference \* of the ACK timeout and the time of its last send \*/ reschedule\_arq\_timeout = true; } else if (\_frag\_ack\_req(frag\_desc)) { /\* for this fragment we requested an ACK which was not received \* yet. Try to resend it \*/ if ((frag\_desc->super.resends++) < CONFIG\_GNRC\_SIXLOWPAN\_SFR\_FRAG\_RETRIES) { /\* we have retries left for this fragment \*/ DEBUG("6lo sfr: %u retries left for fragment (tag: %u, " "X: %i, seq: %u, frag\_size: %u, offset: %u)\n", CONFIG\_GNRC\_SIXLOWPAN\_SFR\_FRAG\_RETRIES - (frag\_desc->super.resends - 1), (uint8\_t)fbuf->tag, \_frag\_ack\_req(frag\_desc), \_frag\_seq(frag\_desc), \_frag\_size(frag\_desc), frag\_desc->offset); if (\_resend\_frag(&frag\_desc->super.super, fbuf) != 0) { /\* \_resend\_frag failed due to a memory resource \* problem \*/ error\_no = ENOMEM; goto error; } else { if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_CONGURE)) { /\* fragment was resent successfully, report this to CongURE state \* object \*/ gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_report\_frag\_sent(fbuf); } if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_STATS)) { /\* fragment was resent successfully, note this done \* in the statistics \*/ \_stats.fragment\_resends.by\_timeout++; } } /\* fragment was resent successfully, schedule next ACK \* timeout \*/ reschedule\_arq\_timeout = true; } else { /\* out of retries \*/ DEBUG("6lo sfr: no retries left for fragment " "(tag: %u, X: %i, seq: %u, frag\_size: %u, " "offset: %u)\n", (uint8\_t)fbuf->tag, \_frag\_ack\_req(frag\_desc), \_frag\_seq(frag\_desc), \_frag\_size(frag\_desc), frag\_desc->offset); /\* we are out of retries on the fragment level, but we \* might be able to retry the datagram if retries for the \* datagram are configured. \*/ \_retry\_datagram(fbuf); return; } } else { /\* Do not resend fragments that were not explicitly asking for \* an ACK from the reassembling endpoint on ACK timeout. \* If this is true for all fragments remaining in the fragment \* buffer, the datagram is to be considered timed out, so \* error\_no should remain ETIMEDOUT \*/ DEBUG("6lo sfr: nothing to do for fragment %u\n", \_frag\_seq(frag\_desc)); } } while (frag\_desc != head); /\* report all non-ack\_req fragments in window also as sent, since even \* the lost fragments are still in flight (even though they were \* previously marked as timed out) \*/ clist\_foreach(&fbuf->sfr.window, \_report\_non\_ack\_req\_window\_sent, fbuf); } else { /\* No fragments to resend, we can assume the packet was delivered \* successfully \*/ error\_no = GNRC\_NETERR\_SUCCESS; } assert(fbuf->sfr.frags\_sent == clist\_count(&fbuf->sfr.window)); if (reschedule\_arq\_timeout) { \_sched\_arq\_timeout(fbuf, next\_arq\_offset); return; }error: /\* don't check return value, as we don't want to wait for an ACK again ;-) \*/ \_send\_abort\_frag(fbuf->pkt, fbuf, false, 0); \_clean\_up\_fbuf(fbuf, error\_no);}
void gnrc\_sixlowpan\_frag\_sfr\_inter\_frame\_gap(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf){ if (gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_has\_inter\_frame\_gap()) { \_frame\_queue\_t \*node = (\_frame\_queue\_t \*)clist\_lpop(&\_frame\_queue);
 if (node != NULL) { \_last\_frame\_sent = xtimer\_now\_usec(); gnrc\_sixlowpan\_dispatch\_send(node->frame, NULL, node->page); /\* unset packet just to be safe \*/ node->frame = NULL; clist\_rpush(&\_frame\_queue\_free, &node->super); } if (clist\_lpeek(&\_frame\_queue) != NULL) { \_sched\_next\_frame(fbuf); } }}
void gnrc\_sixlowpan\_frag\_sfr\_stats\_get(gnrc\_sixlowpan\_frag\_sfr\_stats\_t \*stats){ if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_STATS)) { \*stats = \_stats; }}
/\* ====== INTERNAL FUNCTION DEFINITIONS ====== \*/static inline uint16\_t \_min(uint16\_t a, size\_t b){ return (a < b) ? a : (uint16\_t)b;}
static inline kernel\_pid\_t \_getpid(void){ /\* in production, only the 6LoWPAN thread is supposed to call the API \* functions, so just get the current thread's PID for sending messages. \* When testing, those functions might however be called by the testing \* thread (usually the main thread), so indirect over the 6LoWPAN thread in \* that case \*/ return IS\_ACTIVE(TEST\_SUITES) ? gnrc\_sixlowpan\_get\_pid() : thread\_getpid();}
/\* \* @brief Returns the datagram in @p fbuf to its original state \* \* This function can be both used to clean up the fragmentation buffer on \* failure without releasing @p fbuf's gnrc\_sixlowpan\_frag\_fb\_t::pkt and to \* reset a datagram for a datagram retry. \* \* @param[in] fbuf The fragmentation buffer entry to clean up \*/static void \_clean\_slate\_datagram(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf){ clist\_node\_t new\_queue = { .next = NULL };
 fbuf->sfr.arq\_timeout\_event.msg.content.ptr = NULL; /\* remove potentially scheduled timers for this datagram \*/ evtimer\_del((evtimer\_t \*)(&\_arq\_timer), &fbuf->sfr.arq\_timeout\_event.event); fbuf->sfr.arq\_timeout\_event.event.next = NULL; if (gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_has\_inter\_frame\_gap()) { for (clist\_node\_t \*node = clist\_lpop(&\_frame\_queue); node != NULL; node = clist\_lpop(&\_frame\_queue)) { \_frame\_queue\_t \*entry = (\_frame\_queue\_t \*)node; /\* remove frames of this datagram from frame queue \*/ if (entry->datagram\_tag == fbuf->tag) { gnrc\_pktbuf\_release(entry->frame); /\* unset packet just to be safe \*/ entry->frame = NULL; clist\_rpush(&\_frag\_descs\_free, node); } else { clist\_rpush(&new\_queue, node); } } /\* reset frame queue with remaining frames \*/ \_frame\_queue = new\_queue; } fbuf->offset = 0U; fbuf->sfr.cur\_seq = 0U; fbuf->sfr.frags\_sent = 0U; for (clist\_node\_t \*node = clist\_lpop(&fbuf->sfr.window); node != NULL; node = clist\_lpop(&fbuf->sfr.window)) { clist\_rpush(&\_frag\_descs\_free, node); }}
static gnrc\_pktsnip\_t \*\_build\_rfrag(uint8\_t tag, bool ack\_req, uint16\_t size, uint8\_t seq){ sixlowpan\_sfr\_rfrag\_t \*hdr; gnrc\_pktsnip\_t \*frag = gnrc\_pktbuf\_add(NULL, NULL, sizeof(sixlowpan\_sfr\_rfrag\_t) + size, GNRC\_NETTYPE\_SIXLOWPAN);
 if (frag == NULL) { return NULL; } sixlowpan\_sfr\_rfrag\_set\_disp(frag->data);
 hdr = frag->data; hdr->base.tag = tag; if (ack\_req) { sixlowpan\_sfr\_rfrag\_set\_ack\_req(hdr); } else { sixlowpan\_sfr\_rfrag\_clear\_ack\_req(hdr); } sixlowpan\_sfr\_rfrag\_set\_frag\_size(hdr, size); sixlowpan\_sfr\_rfrag\_set\_seq(hdr, seq); /\* set offset / datagram\_size in callers \*/ return frag;}
static gnrc\_pktsnip\_t \*\_build\_frag\_pkt(gnrc\_netif\_hdr\_t \*old\_netif\_hdr, uint8\_t tag, bool ack\_req, uint16\_t size, uint8\_t seq){ gnrc\_netif\_hdr\_t \*new\_netif\_hdr; gnrc\_pktsnip\_t \*netif, \*res;
 DEBUG("6lo sfr: building fragment (tag: %u, X: %i, seq: %u, frag\_size: %u)\n", tag, ack\_req, seq, size); netif = gnrc\_netif\_hdr\_build(gnrc\_netif\_hdr\_get\_src\_addr(old\_netif\_hdr), old\_netif\_hdr->src\_l2addr\_len, gnrc\_netif\_hdr\_get\_dst\_addr(old\_netif\_hdr), old\_netif\_hdr->dst\_l2addr\_len); if (netif == NULL) { return NULL; }
 new\_netif\_hdr = netif->data; \*new\_netif\_hdr = \*old\_netif\_hdr; res = \_build\_rfrag(tag, ack\_req, size, seq); if (res == NULL) { gnrc\_pktbuf\_release(netif); return NULL; } return gnrc\_pkt\_prepend(res, netif);}
static gnrc\_pktsnip\_t \*\_build\_frag\_from\_fbuf(gnrc\_pktsnip\_t \*pkt, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, uint16\_t frag\_size){ return \_build\_frag\_pkt(pkt->data, (uint8\_t)fbuf->tag, ((frag\_size + fbuf->offset) >= fbuf->datagram\_size) || /\* we only can send the next fragment we build here, \* so request ACK for it \*/ !gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_next\_in\_cwnd(fbuf), frag\_size, fbuf->sfr.cur\_seq);}
static uint16\_t \_copy\_pkt\_to\_frag(uint8\_t \*data, const gnrc\_pktsnip\_t \*pkt, uint16\_t frag\_size, uint16\_t init\_offset){ uint16\_t offset = init\_offset;
 while ((pkt != NULL) && (offset < frag\_size)) { uint16\_t len = \_min(frag\_size - offset, pkt->size);
 memcpy(data + offset, pkt->data, len);
 offset += len; pkt = pkt->next; } return offset;}
static uint16\_t \_find\_offset\_and\_copy\_rest(uint8\_t \*data, gnrc\_pktsnip\_t \*\*pkt, uint16\_t frag\_size, uint16\_t offset){ uint16\_t offset\_count = 0, cur\_frag\_size = 0; while ((\*pkt != NULL) && (offset\_count != offset)) { /\* go to offset \*/ uint16\_t pkt\_size = (uint16\_t)(\*pkt)->size; offset\_count += pkt\_size;
 if (offset\_count > offset) { /\* we overshot \*/ /\* => copy rest of partly send packet snip \*/ uint16\_t pkt\_offset = offset - (offset\_count - pkt\_size); size\_t clen = \_min(frag\_size, pkt\_size - pkt\_offset);
 memcpy(data, ((uint8\_t \*)(\*pkt)->data) + pkt\_offset, clen); cur\_frag\_size = clen; \*pkt = (\*pkt)->next; break; } \*pkt = (\*pkt)->next; } return cur\_frag\_size;}
static void \_check\_for\_ecn(gnrc\_pktsnip\_t \*frame){ if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_ECN) && (sixlowpan\_sfr\_rfrag\_is(frame->next->data))) { int queue\_state = 0; int queue\_size = 0;
 if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_ECN\_IF\_IN)) { gnrc\_netif\_t \*netif = gnrc\_netif\_hdr\_get\_netif(frame->data);
 assert(frame->type == GNRC\_NETTYPE\_NETIF); assert(frame->next->type == GNRC\_NETTYPE\_SIXLOWPAN); queue\_state = msg\_avail\_thread(netif->pid); queue\_size = msg\_queue\_capacity(netif->pid); assert(queue\_size > 0);
 if ((queue\_state \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_IF\_IN\_DEN) > (queue\_size \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_IF\_IN\_NUM)) { sixlowpan\_sfr\_set\_ecn(frame->next->data); } }
 if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_ECN\_IF\_OUT)) { queue\_state = gnrc\_netif\_pktq\_usage(); queue\_size = CONFIG\_GNRC\_NETIF\_PKTQ\_POOL\_SIZE;
 if ((queue\_state \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_IF\_OUT\_DEN) > (queue\_size \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_IF\_OUT\_NUM)) { sixlowpan\_sfr\_set\_ecn(frame->next->data); } }
 if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_ECN\_FQUEUE)) { queue\_state = clist\_count(&\_frame\_queue); queue\_size = FRAME\_QUEUE\_POOL\_SIZE;
 if ((queue\_state \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_FQUEUE\_DEN) > (queue\_size \* CONFIG\_GNRC\_SIXLOWPAN\_SFR\_ECN\_FQUEUE\_NUM)) { sixlowpan\_sfr\_set\_ecn(frame->next->data); } } }}
static bool \_send\_frame(gnrc\_pktsnip\_t \*frame, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, void \*ctx, unsigned page){ uint32\_t now; uint32\_t if\_gap = gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_inter\_frame\_gap(fbuf);
 \_check\_for\_ecn(frame); now = xtimer\_now\_usec(); if ((if\_gap == 0) || ((now - \_last\_frame\_sent) > if\_gap)) { DEBUG("6lo sfr: dispatch frame to network interface\n"); \_last\_frame\_sent = now; gnrc\_sixlowpan\_dispatch\_send(frame, ctx, page); return true; } else { \_frame\_queue\_t \*node = (\_frame\_queue\_t \*)clist\_lpop(&\_frame\_queue\_free);
 if (node != NULL) { sixlowpan\_sfr\_t \*hdr = frame->next->data;
 assert(sixlowpan\_sfr\_is(hdr)); node->frame = frame; node->datagram\_tag = hdr->tag; node->page = page; clist\_rpush(&\_frame\_queue, &node->super); \_sched\_next\_frame(fbuf); } return (node != NULL); }}
static bool \_send\_fragment(gnrc\_pktsnip\_t \*frag, gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, unsigned page, uint16\_t offset){ sixlowpan\_sfr\_rfrag\_t \*hdr = frag->next->data; \_frag\_desc\_t \*frag\_desc = (\_frag\_desc\_t \*)clist\_lpop(&\_frag\_descs\_free); bool res;
 if (frag\_desc == NULL) { DEBUG("6lo sfr: could not remember fragment to send\n"); gnrc\_pktbuf\_release(frag); return false; } frag\_desc->ar\_seq\_fs = byteorder\_ntohs(hdr->ar\_seq\_fs); frag\_desc->offset = offset; frag\_desc->super.size = 1; frag\_desc->super.resends = 0; clist\_rpush(&fbuf->sfr.window, &frag\_desc->super.super); if ((res = \_send\_frame(frag, fbuf, NULL, page))) { if (IS\_USED(MODULE\_GNRC\_SIXLOWPAN\_FRAG\_SFR\_STATS)) { \_stats.fragments\_sent.usual++; } frag\_desc->super.send\_time = \_last\_frame\_sent / US\_PER\_MS; fbuf->sfr.cur\_seq++; fbuf->sfr.frags\_sent++; } return res;}
static gnrc\_pktsnip\_t \*\_build\_ack(gnrc\_netif\_t \*netif, const uint8\_t \*dst, uint8\_t dst\_len, const sixlowpan\_sfr\_t \*hdr, const uint8\_t \*bitmap){ gnrc\_pktsnip\_t \*ack\_snip, \*ack\_netif; sixlowpan\_sfr\_ack\_t \*ack;
 ack\_netif = gnrc\_netif\_hdr\_build(NULL, 0, dst, dst\_len); if (ack\_netif == NULL) { DEBUG("6lo sfr: can't allocate netif header for ACK for (%s, %02x).\n", gnrc\_netif\_addr\_to\_str(dst, dst\_len, addr\_str), hdr->tag); return NULL; } gnrc\_netif\_hdr\_set\_netif(ack\_netif->data, netif);
 ack\_snip = gnrc\_pktbuf\_add(NULL, NULL, sizeof(sixlowpan\_sfr\_ack\_t), GNRC\_NETTYPE\_SIXLOWPAN);
 if (ack\_snip == NULL) { DEBUG("6lo sfr: can't allocate ACK for (%s, %02x).\n", gnrc\_netif\_addr\_to\_str(dst, dst\_len, addr\_str), hdr->tag); gnrc\_pktbuf\_release(ack\_netif); return NULL; } ack = ack\_snip->data; /\* https://tools.ietf.org/html/rfc8931#section-6: \* The Datagram\_Tag in the RFRAG\_ACK is unique to the reassembling endpoint \* and is enough information for an intermediate hop to locate the VRB that \* contains the Datagram\_Tag used by the previous hop and the Layer-2 \* information associated with it (interface and Link-Layer address).. \* [...] The reassembling endpoint of a fragment with the 'E' (ECN) flag set \* MUST echo that information at most once by setting the 'E' (ECN) flag in \* the next RFRAG\_ACK. \* \* => base except dispatch are the same as ack'd RFRAG. \*/ ack->base = \*hdr; sixlowpan\_sfr\_ack\_set\_disp(&ack->base); memcpy(ack->bitmap, bitmap, sizeof(ack->bitmap)); ack\_netif->next = ack\_snip; return ack\_netif;}
static void \_clean\_up\_rb\_entry(\_generic\_rb\_entry\_t \*entry){ if (entry != NULL) { switch (entry->type) { case \_RB: gnrc\_pktbuf\_release(entry->entry.rb->pkt); gnrc\_sixlowpan\_frag\_rb\_remove(entry->entry.rb); break; case \_VRB: gnrc\_sixlowpan\_frag\_vrb\_rm(entry->entry.vrb); break; default: break; } }}
static void \_try\_reassembly(gnrc\_netif\_hdr\_t \*netif\_hdr, gnrc\_pktsnip\_t \*rfrag, unsigned offset, \_generic\_rb\_entry\_t \*entry, unsigned page){ gnrc\_sixlowpan\_frag\_vrb\_t \*vrbe; const gnrc\_sixlowpan\_frag\_sfr\_bitmap\_t \*bitmap; sixlowpan\_sfr\_rfrag\_t \*hdr = rfrag->data; gnrc\_pktsnip\_t \*netif\_snip = rfrag->next; /\* copy base for ACK \*/ sixlowpan\_sfr\_t base = hdr->base; int8\_t ack\_req = sixlowpan\_sfr\_rfrag\_ack\_req(hdr); uint8\_t seq = sixlowpan\_sfr\_rfrag\_get\_seq(hdr);
 assert(netif\_snip->data == netif\_hdr); gnrc\_pktbuf\_hold(netif\_snip, 1); /\* hold netif header to use it with \* dispatch\_when\_complete() \* (rb\_add() releases `pkt`) \*/ entry->entry.rb = gnrc\_sixlowpan\_frag\_rb\_add(netif\_hdr, rfrag,[View remainder of file in raw view](https://github.com/RIOT-OS/RIOT/raw/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_22460a64_20250114_192727.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fsecurity%2Fadvisories%2FGHSA-8m3w-mphf-wxm8)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fsecurity%2Fadvisories%2FGHSA-8m3w-mphf-wxm8)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  388](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

# Race Condition in SFR Timeout

High

[miri64](/miri64)
published
GHSA-8m3w-mphf-wxm8
May 30, 2023

## Package

RIOT-OS

## Affected versions

<= 2023.01

## Patched versions

None

## Description

### Impact

RIOT-OS contains a network stack with the ability to process 6LoWPAN frames. An attacker can send multiple crafted frames to the device to trigger a race condition. The race condition invalidates assumptions about the program state and leads to an invalid memory access resulting in denial of service.

### Patches

None

### Workarounds

* None

### For more information

If you have any questions or comments about this advisory:

* Open an issue in [RIOT](https://github.com/RIOT-OS/RIOT/issues)
* Email us at RIOT-security

### Bug Details

Triggering this bug requires a specific series of events. The following will describe what happens in chronological order.

1. A 6LoWPAN SFR fragment is send by calling `gnrc_sixlowpan_frag_sfr_send`. The fragment requires an ACK and thus `_sched_arq_timeout` is called ([source](https://github.com/RIOT-OS/RIOT/blob/master/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c#L404)):
   ```
   if (_frag_ack_req(frag_desc)) {
       ...
       _sched_arq_timeout(fbuf, fbuf->sfr.arq_timeout);
   }

   ```
2. The timeout expires and the corresponding event function `_evtimer_msg_handler` is called. The handler sends a message to the 6LoWPAN thread to inform it about the expired timer.
3. The 6LoWPAN thread is still processing another packet. During this processing the timer on fragment buffer is set again, e.g., because the fragment is [resend](https://github.com/RIOT-OS/RIOT/blob/master/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c#L1586).
4. The message from 2. is now processed by the 6LoWPAN thread. In `gnrc_sixlowpan_frag_sfr_arq_timeout` the event content pointer is set to `NULL` without checking if the timer is currently in use ([source](https://github.com/RIOT-OS/RIOT/blob/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c#L509)):
   ```
   fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;

   ```
5. In the end the timer can be scheduled again ([source](https://github.com/RIOT-OS/RIOT/blob/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c#L617)):
   ```
   if (reschedule_arq_timeout) {
       _sched_arq_timeout(fbuf, next_arq_offset);
       return;
   }

   ```
6. The check to assure that the timer is not already scheduled is now ineffective as it depends on the event content pointer ([source](https://github.com/RIOT-OS/RIOT/blob/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c#L1717)):
   ```
   if (fbuf->sfr.arq_timeout_event.msg.content.ptr != NULL) {
       DEBUG("6lo sfr: ARQ timeout for datagram %u already scheduled\n",
             (uint8_t)fbuf->tag);
       return;
   }

   ```

The timer is thus scheduled two times which creates two problems:

1. The next pointer of the event points to itself creating an infinite loop once the timeout expires.
2. The event function modifies the event object on the first call and creates an invalid memory access in the second call.

### Severity

High

7.5

# CVSS overall score

 This score calculates overall vulnerability severity from 0 to 10 and is based on the Common Vulnerability Scoring System (CVSS).

 / 10

#### CVSS v3 base metrics

Attack vector
Network

Attack complexity
Low

Privileges required
None

User interaction
None

Scope
Unchanged

Confidentiality
None

Integrity
None

Availability
High

Learn more about base metrics

# CVSS v3 base metrics

Attack vector:
More severe the more the remote (logically and physically) an attacker can be in order to exploit the vulnerability.

Attack complexity:
More severe for the least complex attacks.

Privileges required:
More severe if no privileges are required.

User interaction:
More severe when no user interaction is required.

Scope:
More severe when a scope change occurs, e.g. one vulnerable component impacts resources in components beyond its security scope.

Confidentiality:
More severe when loss of data confidentiality is highest, measuring the level of data access available to an unauthorized user.

Integrity:
More severe when loss of data integrity is the highest, measuring the consequence of data modification possible by an unauthorized user.

Availability:
More severe when the loss of impacted component availability is highest.

CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H

### CVE ID

CVE-2023-33974

### Weaknesses

[CWE-362](/advisories?query=cwe%3A362)

### Credits

* [![@Diff-fusion](https://avatars.githubusercontent.com/u/47172717?s=40&v=4)](/Diff-fusion)
  [Diff-fusion](/Diff-fusion)
  Reporter
* [![@SWW13](https://avatars.githubusercontent.com/u/1280142?s=40&v=4)](/SWW13)
  [SWW13](/SWW13)
  Analyst
* [![@Scepticz](https://avatars.githubusercontent.com/u/18148299?s=40&v=4)](/Scepticz)
  [Scepticz](/Scepticz)
  Analyst

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_2c1fae62_20250114_192723.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fcommit%2F31c6191f6196f1a05c9765cffeadba868e3b0723)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fcommit%2F31c6191f6196f1a05c9765cffeadba868e3b0723)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fcommit_fragments%2Frepo_layout&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  388](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

## Commit

[Permalink](/RIOT-OS/RIOT/commit/31c6191f6196f1a05c9765cffeadba868e3b0723)

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

gnrc\_sixlowpan\_frag\_sfr: fix ARQ scheduler race-condition

[Browse files](/RIOT-OS/RIOT/tree/31c6191f6196f1a05c9765cffeadba868e3b0723)
Browse the repository at this point in the history

* Loading branch information

[![@miri64](https://avatars.githubusercontent.com/u/675644?s=40&v=4)](/miri64)

[miri64](/RIOT-OS/RIOT/commits?author=miri64 "View all commits by miri64")
committed
May 30, 2023

1 parent
[e690ef4](/RIOT-OS/RIOT/commit/e690ef4c1298d90bc323b765c000bb090544fb9f)

commit 31c6191

Showing
**1 changed file**
with
**14 additions**
and
**4 deletions**.

* Whitespace
* Ignore whitespace

* Split
* Unified

## There are no files selected for viewing

18 changes: 14 additions & 4 deletions

18
[sys/net/gnrc/network\_layer/sixlowpan/frag/sfr/gnrc\_sixlowpan\_frag\_sfr.c](#diff-7220f6289fca939f524330842b477b6ea8661661f8928d9c6536766e0f198dd8 "sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c")

Show comments

[View file](/RIOT-OS/RIOT/blob/31c6191f6196f1a05c9765cffeadba868e3b0723/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -506,7 +506,6 @@ void gnrc\_sixlowpan\_frag\_sfr\_arq\_timeout(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf) |
|  |  | int error\_no = ETIMEDOUT; /\* assume time out for fbuf->pkt \*/ |
|  |  |  |
|  |  | DEBUG("6lo sfr: ARQ timeout for datagram %u\n", fbuf->tag); |
|  |  | fbuf->sfr.arq\_timeout\_event.msg.content.ptr = NULL; |
|  |  | if (IS\_ACTIVE(CONFIG\_GNRC\_SIXLOWPAN\_SFR\_MOCK\_ARQ\_TIMER)) { |
|  |  | /\* mock-up to emulate time having passed beyond (1us) the ARQ timeout \*/ |
|  |  | now -= (fbuf->sfr.arq\_timeout \* US\_PER\_MS) + 1; |
| Expand Down  Expand Up | | @@ -681,7 +680,6 @@ static void \_clean\_slate\_datagram(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf) |
|  |  | /\* remove potentially scheduled timers for this datagram \*/ |
|  |  | evtimer\_del((evtimer\_t \*)(&\_arq\_timer), |
|  |  | &fbuf->sfr.arq\_timeout\_event.event); |
|  |  | fbuf->sfr.arq\_timeout\_event.event.next = NULL; |
|  |  | if (gnrc\_sixlowpan\_frag\_sfr\_congure\_snd\_has\_inter\_frame\_gap()) { |
|  |  | for (clist\_node\_t \*node = clist\_lpop(&\_frame\_queue); |
|  |  | node != NULL; node = clist\_lpop(&\_frame\_queue)) { |
| Expand Down  Expand Up | | @@ -1708,13 +1706,26 @@ static void \_sched\_next\_frame(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf) |
|  |  | } |
|  |  | } |
|  |  |  |
|  |  | static inline bool \_arq\_scheduled(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf) |
|  |  | { |
|  |  | evtimer\_event\_t \*ptr = \_arq\_timer.events; |
|  |  | evtimer\_event\_t \*event = &fbuf->sfr.arq\_timeout\_event.event; |
|  |  | while (ptr) { |
|  |  | if (ptr == event) { |
|  |  | return true; |
|  |  | } |
|  |  | ptr = ptr->next; |
|  |  | } |
|  |  | return false; |
|  |  | } |
|  |  |  |
|  |  | static void \_sched\_arq\_timeout(gnrc\_sixlowpan\_frag\_fb\_t \*fbuf, uint32\_t offset) |
|  |  | { |
|  |  | if (IS\_ACTIVE(CONFIG\_GNRC\_SIXLOWPAN\_SFR\_MOCK\_ARQ\_TIMER)) { |
|  |  | /\* mock does not need to be scheduled \*/ |
|  |  | return; |
|  |  | } |
|  |  | if (fbuf->sfr.arq\_timeout\_event.msg.content.ptr != NULL) { |
|  |  | if (\_arq\_scheduled(fbuf)) { |
|  |  | DEBUG("6lo sfr: ARQ timeout for datagram %u already scheduled\n", |
|  |  | (uint8\_t)fbuf->tag); |
|  |  | return; |
| Expand Down  Expand Up | | @@ -1804,7 +1815,6 @@ static void \_handle\_ack(gnrc\_netif\_hdr\_t \*netif\_hdr, gnrc\_pktsnip\_t \*pkt, |
|  |  | DEBUG("6lo sfr: cancelling ARQ timeout\n"); |
|  |  | evtimer\_del((evtimer\_t \*)(&\_arq\_timer), |
|  |  | &fbuf->sfr.arq\_timeout\_event.event); |
|  |  | fbuf->sfr.arq\_timeout\_event.msg.content.ptr = NULL; |
|  |  | if ((unaligned\_get\_u32(hdr->bitmap) == \_null\_bitmap.u32)) { |
|  |  | /\* ACK indicates the reassembling endpoint canceled reassembly |
|  |  | \*/ |
| Expand Down | |  |

Toggle all file notes
Toggle all file annotations

### 0 comments on commit `31c6191`

Please
[sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fcommit%2F31c6191f6196f1a05c9765cffeadba868e3b0723) to comment.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


