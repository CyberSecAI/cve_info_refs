=== Content from ethz.ch_e0035db2_20250114_182027.html ===
Cryptography in the Wild: Briar

Semester Project

Yuanming Song

March 5, 2023

Advisor: Prof. Dr. Kenny Paterson

Applied Cryptography Group
Institute of Information Security
Department of Computer Science, ETH Z¨urich

Abstract

Briar is a secure peer-to-peer messaging application for higher-risk
users. Briar users communicate directly by exchanging encrypted mes-
sages via Bluetooth, WiFi, Tor, etc. Briar can also synchronize mes-
sages among private group members or forum/blog subscribers via
encrypted peer-to-peer communication.

The Briar team claims that Briar meets very high security standards,
including conﬁdentiality of message metadata and content, forward
security, and resistance to denial-of-service attacks. To this end, they
designed and implemented a set of protocols tailored to delay-tolerant
peer-to-peer communication for Briar. However, there is little attention
on whether these protocols are actually secure as claimed.

In this project, we examine Briar’s use of cryptography and analyze the
security of protocols in Briar. Our main contributions are as follows:

1. We provide a detailed documentation of Briar’s protocol stack;

2. We give a series of arguments in favor of Briar’s security by check-
ing against possible attacks and performing formal veriﬁcation.
The overall positive results partly support Briar’s security claims;

3. We discover three new vulnerabilities in Briar’s protocol design
and implementaion, and suggest possible ﬁxes. The vulnera-
bilites are: 1) Bramble Handshake Protocol (BHP) is not forward
secure, 2) the implementation of Bramble Synchronisation Proto-
col (BSP) is susceptible to denial-of-service attacks from malicious
contacts, and 3) a malicious insider of a private group, forum, or
blog can duplicate messages from any member as many times as
desired. In addition, we identify the issue that the lack of out-of-
band veriﬁcation could lead to active man-in-the-middle attacks
on introducing contacts in Briar. This issue was already known to
Briar.

i

Contents

Contents

1

Introduction

2 Preliminaries

2.1 Strings and byte arrays . . . . . . . . . . . . . . . . . . . . . . .
2.2 Encoding and decoding . . . . . . . . . . . . . . . . . . . . . .
2.3 Cryptographic primitives
. . . . . . . . . . . . . . . . . . . . .
2.4 Binary Data Format (BDF) . . . . . . . . . . . . . . . . . . . . .

3 Overview of Briar

3.1 Who’s who in Briar .
. . . . . . . . . . . . . . . . . . . . . . .
3.2 Protocol stack overview . . . . . . . . . . . . . . . . . . . . . .
3.3 Account creation and adding contact
. . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . .
3.4 Communication .

.

.

.

.

4 Bramble QR Code Protocol (BQP)

.

.

.

4.1 Constants .
.
.
4.2 Preparation and connection establishment
.
.
4.3 Key agreement
.
.
.
4.4 Notes .

. . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . .

.
.

.
.

.

.

.

.

.

.

5 Bramble Handshake Protocol (BHP)

. . . . . . . . . . . . . . . . . . . . . . .
5.1 The protocol .
5.2 Lack of forward security . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . .
5.3 Notes .

.

.

.

.

.

.

.

.

.

.

.

.

.

.

6 Contact Exchange

6.1 The protocol .
.
6.2 Notes .

.

.

.

.
.

.
.

.
.

.
.

.
.

. . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . .

iii

1

5
5
5
6
6

9
9
10
11
11

13
13
13
14
16

17
17
18
19

21
21
22

iii

Contents

7 Bramble Transport Protocol (BTP)

7.2 Wire protocol

7.1 Key management protocol . . . . . . . . . . . . . . . . . . . . .
7.1.1 Constants . . . . .
. . . . . . . . . . . . . . . . . . . . .
7.1.2 Handshake mode . . . . . . . . . . . . . . . . . . . . . .
7.1.3 Rotation mode . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
Stream and tag . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . .
Stream header . . .
Frame . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

7.2.1
7.2.2
7.2.3
7.3 Notes .

.

.

.

.

8 Bramble Synchronisation Protocol (BSP)
.

8.1 Concepts .
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
8.2 Denial-of-service attack . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
8.3 Notes .

.

.

.

.

.

9 Introduction Client
9.1 The protocol .
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.2 Active man-in-the-middle attack . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.3 Notes .

.

.

.

.

10 Briar Functionalities

10.1 Transport key agreement client . . . . . . . . . . . . . . . . . .
10.2 Messaging .
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
10.3 Private groups, forums, and blogs . . . . . . . . . . . . . . . .
10.3.1 Message duplication attack . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . .
10.3.2 Notes .

.

.

11 Discussion

12 Conclusion

A Tamarin code

A.1 Tamarin code for BQP . . . . . . . . . . . . . . . . . . . . . . .
A.2 Tamarin code for BHP . . . . . . . . . . . . . . . . . . . . . . .
A.3 Tamarin code for Briar introduction . . . . . . . . . . . . . . .

B Code examples for message duplication

Bibliography

iv

25
25
25
25
26
27
28
28
29
30

33
33
34
35

37
37
40
40

43
43
44
45
45
47

49

51

53
53
54
57

61

63

Chapter 1

Introduction

Briar1 is a secure peer-to-peer messaging application designed to protect
journalists, protestors and other higher risk groups of users against censor-
ship and surveillance. In Briar, peers communicate directly by exchanging
encrypted messages via a range of transports, including Bluetooth, WiFi,
and Tor.2 Briar also supports private groups, forums, and blogs, where it
synchronizes messages among members or subscribers via encrypted peer-
to-peer communication [14]. Notably, Briar does not adopt existing key
agreement or communication protocols like TLS or the Signal protocol,3 but
instead develops a set of cryptographic protocols tailored for delay-tolerant
peer-to-peer communication, including BQP (Chapter 4), BHP (Chapter 5),
and BTP (Chapter 7).

As a messaging application designed against potentially powerful adver-
saries (e.g., nation-states), Briar claims to achieve a set of very strong security
standards. In Briar, the trafﬁc between peers is end-to-end encrypted and
should be resistant against eavesdropping, tampering, and trafﬁc analysis.
Briar also claims to offer forward security for both bidirectional and uni-
directional communications [10]. Finally, the decentralized nature of Briar
should make it resistant to takedown orders, denial-of-service attacks, and
Internet blackouts [14]. These claims, if true, would mean that Briar offers a
higher level of security than almost all existing messaging applications.

The high risk of Briar’s target user groups, the use of custom cryptographic
protocols and the strong claims of security all motivate a thorough exami-
nation on the cryptography used in Briar. Furthermore, recent attacks [1, 3]
on Bridgefy,4 a mesh messaging application that shares many similarities to
Briar, shows the importance of independent security assessments of Briar’s

1https://briarproject.org/
2https://www.torproject.org/
3https://signal.org/docs/
4https://bridgefy.me/

1

1.

Introduction

cryptography. However, to our knowledge, the only public security analysis
of Briar up to now is a security audit performed by Heiderich et al. from
Cure53 [4], which was conducted around six years ago on a development
version of Briar, covering only a subset of Briar’s cryptographic protocols
currently in use. Heiderich et al. also suggested in their report that per-
forming another audit on Briar after its release was “highly advisable” [4].

We examined Briar’s use of cryptography and Briar’s protocols over a pe-
riod of approximately ﬁve months as a semester project. The object of our
security analysis is Briar for Android; Briar Mailbox5 and Briar Desktop6
are outside the scope of our analysis, as they are still under active develop-
ment. However, the issues we discovered would all apply to Briar Desktop.
Our documentation and ﬁndings in this report are valid for Briar 1.4.20,7 re-
leased on 01-30-2023; for convenience, we refer to them in the present tense
even if they may no longer be valid for newer versions of Briar.

The attack scenarios we consider in our analysis are 1) network attackers
within the Dolev-Yao model [5], who have full control of the communication
channel between Briar users, 2) loss of forward security, where attackers
with compromised session keys or long-term secrets try to break security
of past sessions, and 3) malicious insiders or contacts. Note that we did
not consider compelled access or loss of post-compromise security, because
Briar does not claim to be resistant to these attacks [11].

We manually reviewed Briar’s speciﬁcations8 and source code,9 all of which
are publicly available thanks to the Briar team. We also used the Tamarin
prover,10 a tool for automated protocol veriﬁcation, to analyze selected pro-
tocols in Briar. In addition, we experimented on test devices to understand
better Briar’s inner workings and verify our attacks; no Briar users in real
life were affected by our experiments.

In this report, we document in detail Briar’s use of cryptography and Briar’s
protocol stack. Our report could serve as a reference for people interested
in how Briar works to offer secure communication.

Our analysis shows that Briar generally follows good cryptography practices
in its design and implementation; as a result, Briar is resistant to a number
of attacks we have envisaged, which partly validates Briar’s security claims.
We present in this report a series of arguments in favor of Briar’s security,
including failed attacks and formal veriﬁcation results.

5https://code.briarproject.org/briar/briar-mailbox/
6https://code.briarproject.org/briar/briar-desktop/
7https://code.briarproject.org/briar/briar/-/commits/release-1.4.20
8https://code.briarproject.org/briar/briar-spec/
9https://code.briarproject.org/briar/briar/
10http://tamarin-prover.github.io/

2

Nevertheless, we were able to discover four issues in Briar’s protocol design
and implementation that could undermine the security of Briar users:

1. Bramble Handshake Protocol (BHP) does not perform Difﬁe-Hellman
key exchange between the ephemeral keys of the peers, and therefore
fails to provide forward security when the handshake secret keys of
both parties are compromised (Section 5.2);

2. The lack of out-of-band authentication gives a way for a malicious
introducer to perform an active man-in-the-middle attack on the intro-
duction of new contacts. The developers of Briar had already noticed
this issue before our discovery but have not yet ﬁxed it (Section 9.2);

3. The implementation of Bramble Synchronisation Protocol (BSP) is sus-
ceptible to a denial-of-service attack, where a victim’s remote contact
can cause the victim’s application to crash repeatedly by sending large
messages (Section 8.2);

4. In private groups, forums, and blogs, a malicious insider can dupli-
cate messages (i.e., replay messages without modifying the timestamp)
from any member as many times as the adversary desires.

We also give suggestions on how to ﬁx these issues.

We contacted the developers of Briar on 14-02-2023, and notiﬁed them about
our ﬁndings on 17-02-2023, where we suggested a 90-day disclosure period.
The developers conﬁrmed receipt and acknowledged the vulnerabilities on
17-02-2023. They ﬁxed issues 3 and 4 in Briar 1.4.22 on 23-02-2023,11 and
plan to ﬁx issue 1 within the 90-day deadline.

Chapter 2 lists some notations and primitives used in Briar protocols for ref-
erence. Chapter 3 provides a glossary and an overview of Briar’s protocol
stack. The subsequent chapters mainly document Bramble QR Code Proto-
col (BQP) (Chapter 4), Bramble Handshake Protocol (BHP) (Chapter 5), con-
tact exchange (Chapter 6), Briar Transport Protocol (BTP) (Chapter 7), Bram-
ble Synchronisation Protocol (BSP) (Chapter 8), introduction client (Chap-
ter 9), and some Briar functionalities (Chapter 10). Finally, we discuss our
ﬁndings in Chapter 11, and conclude our report in Chapter 12. We include
the Tamarin code for formal veriﬁcation in Appendix A, and example code
snippets for message duplication in Appendix B.

11https://code.briarproject.org/briar/briar/-/commits/release-1.4.22

3

Chapter 2

Preliminaries

This chapter lists some notations and cryptographic primitives to appear in
the following chapters.

2.1 Strings and byte arrays

• "...": a string literal (e.g., "briar");

• [...]: a byte array (e.g., [0x62, 0x72, 0x69, 0x61, 0x72]);

• len(a): the number of bytes in the byte array a;

• a(cid:107)b: the concatenation of byte arrays a and b;

• a[x]: the x-th byte (0-indexed) in the byte array a;

• a[x:y]: a byte array [a[x], a[x+1], ..., a[y]]; x (resp. y) can be

omitted when it takes the value 0 (resp. len(a)-1).

2.2 Encoding and decoding

• int16(x)/int32(x)/int64(x)/intk (x): the big-endian encoding of

an unsigned 16/32/64/k-bit integer x;

• utf-8(x): the UTF-8 encoding of a string x;

• ISO-8859-1-decode(a): the ISO 8859-11 decoding of a byte array a;

• BDF-encode(x)/BDF-decode(a): the encoding of a string x / decoding
of a byte array a as speciﬁed in Briar’s Binary Data Format (BDF) (see
Section 2.4).

1https://en.wikipedia.org/wiki/ISO/IEC_8859-1

5

2. Preliminaries

2.3 Cryptographic primitives

• BLAKE2b-256(x): the BLAKE2b-2562 digest of a byte array x;

• BLAKE2b-256(k, x): the BLAKE2b-256 digest of a byte array x with a

32-byte key k;

• hash(label, x1, ..., xn): BLAKE2b-256(int32(len(utf-8(label)))(cid:107)

utf-8(label)(cid:107)int32(len(x1))(cid:107)x1(cid:107)...(cid:107)int32(len(xn))(cid:107)xn);

• mac(label, k, x1, ..., xn): BLAKE2b-256(k, int32(len(utf-8(label)))(cid:107)

utf-8(label)(cid:107)int32(len(x1))(cid:107)x1(cid:107)...(cid:107)int32(len(xn))(cid:107)xn);

• KDF(label, k, x1, ..., xn) : mac(label, k, x1, ..., xn);

• PRF(k, x) : BLAKE2b-256(k, x);

• ed25519-sign(sk, m): produces an Ed255193 signature of a message m

with the signing key sk;

• ed25519-verify(sig, vk, m): checks if sig is a valid Ed25519 signature

of message m using the veriﬁcation key vk;

• sign(label, m, sk): ed25519-sign(sk, int32(len(utf-8(label)))(cid:107)

utf-8(label)(cid:107)int32(len(m))(cid:107)m);

• verify(sig, label, m, pk): ed25519-verify(sig, pk,

int32(len(utf-8(label)))(cid:107)utf-8(label)(cid:107)int32(len(m))(cid:107)m);

• ENC(k, n, m): encrypts message a m with key k and nonce n using the

XSalsa20Poly1305 cipher;4

• DEC(k, n, c): decrypts a ciphertext c with key k and nonce n using the

XSalsa20Poly1305 cipher;

• keyGen() : generates a Curve255195 key pair (pk, sk);

• DH(sk, pk): performs X25519 key exchange, checks in constant time if

the result is zero, aborting if so;

• verifyMac(m, label, k, x1, ..., xn): checks in constant time if m is equal

to mac(label, k, x1, ..., xn).

2.4 Binary Data Format (BDF)

Binary Data Format (BDF) is a data format used in Briar for serialization. It
supports the encoding and decoding of integers, ﬂoats, strings, byte arrays,
as well as lists and dictionaries [6].

2https://www.blake2.net/
3https://ed25519.cr.yp.to/
4https://nacl.cr.yp.to/secretbox.html
5https://cr.yp.to/ecdh.html

6

2.4. Binary Data Format (BDF)

In BDF, each encoded object starts with a byte that speciﬁes its type, and,
for some types, the length or the length-of-length of the encoded object. For
example, INT 8 (0x21) indicates an integer of one byte, while INT 16 (0x22)
indicates an integer of two bytes; the byte STRING 8 (0x41) indicates a BDF
string whose length (after UTF-8 encoding) is represented as an one-byte
integer. This byte is followed by an optional length ﬁeld in case the length-
of-length is speciﬁed, and then followed by the data of the speciﬁed length.

A BDF list starts with a byte LIST (0x60), which does not contain its length
or length-of-length. It is followed by BDF encodings of elements in the list,
and ﬁnally, an END (0x80) byte that represents the end of the list. Similarly,
a BDF dictionary starts with a byte DICTIONARY (0x70), which is followed
by pairs of keys and values, represented respectively as BDF strings and
BDF-encoded objects. It also ends with the byte END (0x80). Both lists and
dictionaries support nesting.

Table 2.1 shows the (canonical) BDF encoding of a BDF list that contains two
elements, "eth" and 2023.

Table 2.1: The canonical BDF encoding of the BDF list of "eth" and 2023.

Raw
Decoded

0x70
LIST

0x41
STRING 8

0x03
3

0x65
e

0x74
t

0x68
h

0x22
INT 16

0x07

0xe7

2023

0x80
END

BSP clients (messaging, private groups, etc.) typically exchange messages
between peers as encrypted BDF lists. In order to mitigate denial-of-sevice
atatcks, Briar sets a nesting depth limit of 5 and a maximum buffer size of
64KiB for BDF-encoded messages received. The Briar speciﬁcation stresses
that “if data is to be hashed or signed, integers and lengths should be rep-
resented using the minimum number of bytes, and dictionary keys should
be unique and sorted in lexicographic order” [6].

One can see that there is a certain level of ﬂexibility in BDF. In fact, it is easy
to ﬁnd different BDF encodings that decode to the same object, provided that
at most one of them does not contain invalid UTF-8 encodings and follows
the rules described in the BDF speciﬁcation (i.e., canonical). However, as we
will see in Chapter 10, no such checks were in place for incoming messages
as of Briar 1.4.20. Possible ways to produce different BDF encodings in-
clude leveraging integer overﬂow, increasing the length-of-length ﬁeld (e.g.,
use INT 32 to represent a INT 16 value), and inserting unmappable or mal-
formed bytes (e.g., 0x80) into the UTF-8 encoding of BDF strings (which is
ignored by the decoder).

7

Chapter 3

Overview of Briar

3.1 Who’s who in Briar

For readers’ reference, we compiled a list of terms and their meanings in
Briar from the Briar Wiki [13].

• Binary Data Format (BDF): A data format used in Briar for data seri-

alization (Section 2.4);

• Bramble: The underlying framework of Briar for building decentral-

ized applications;

• Bramble Handshake Protocol (BHP): A key agreement protocol in
Briar that allows two peers having exchanged their handshake public
keys to establish a shared secret key remotely (Chapter 5);

• Bramble QR Code Protocol (BQP): A key agreement protocol in Briar
that allows two peers to establish an ephemeral shared key locally by
scanning each other’s QR code (Chapter 4);

• Bramble Rendezvous Protocol (BRP): A discovery protocol in Briar
that allows two peers having exchanged their public keys to connect
to each other in Tor;

• Bramble Synchronisation Protocol (BSP): An application layer data
synchronization protocol in Briar that allows members of the same
group to synchronize messages over delay-tolerant networks (Chap-
ter 8);

• BSP Client: An application component in Briar that uses BSP to syn-

chronize data between users;

• Bramble Transport Protocol (BTP): A transport layer security protocol

in Briar (Chapter 7);

9

3. Overview of Briar

BQP

mk

Introduction Client

mk, info

tid

Contact Exchange

mk, info

BTP Key Manager

Transport Key
Agreement Client

mk

transport keys

mk

BHP

BTP Wire Protocol

Figure 3.1: Relations between key agreement and contact exchange protocols in Briar. Here mk
denotes the shared secret key, info denotes contact information (name, public key, etc.), and
tid denotes the transport identiﬁer.

• Contact Exchange: A protocol that allows peers having agreed on a
shared secret key to exchange and verify contact details via BTP (Chap-
ter 6).

• Introduction Client: A BSP client that allows a Briar user to introduce

two of the user’s contacts to each other (Chapter 9);

• Transport Key Agreement Client: A BSP client that establishes trans-
port keys between two peers for transports that are added after their
contact exchange (Section 10.1).

3.2 Protocol stack overview

Table 3.1: The Briar protocol stack.

BQP
-
Bluetooth/WiFi

BRP
-

BHP
BTP (handshake)

Contact Exchange
BTP (undocumented)1

BSP Clients (Messaging,...)
BSP
BTP (rotation)

Tor

Bluetooth, WiFi, Tor, ...

Table 3.1 provides a schematic overview of the Briar protocol stack; see also
the wiki page about the Briar protocol stack [16] for more details. Figure 3.1
outlines the relations between key agreement and contact exchange proto-
cols in Briar.

In the remaining sections of the chapter, we describe in a high level how
Briar works. Readers may also refer to the Briar user manual [12].

1The way to manage BTP keys in the contact exchange protocol is undocumented in the

Briar speciﬁcations and is likely an ad hoc solution; see Chapter 6.

10

3.3. Account creation and adding contact

3.3 Account creation and adding contact

When opening Briar for the ﬁrst time, the user would be prompted to create
an account by setting a nickname and a password. Briar creates the ac-
count and generates a signing key pair (spk, ssk) and a handshake key pair
(hpk, hsk) for the account locally. There is no way to back up the account
or tranfer the account to other devices; if the user forgets her password
or loses her device, she would lose access to the account permanently and
would have to register a new account.

After creating an account, the user may proceed to add contacts in the fol-
lowing ways:

1. Via QR code. Two peers nearby ﬁrst scan each other’s QR code, which
contains a commitment to a ephemeral public key epk and transport
descriptiors, and then derive a shared secret key mk in the key agree-
ment phase of Bramble QR Code Protocol (BQP) over Bluetooth or
WiFi. Note like unlike many other messaging applications, the QR
code is re-generated every time and it is necessary for both parties to
scan the QR code of their peer;

2. Via handshake links. Two peers exchange their handshake links out-
of-band, which contain their handshake public keys. They then use
Bramble Rendezvous Protocol (BRP) to establish a connection over Tor
protected by a static key, and run Bramble Handshake Protocol (BHP)
over the connection to derive a shared secret key mk;

3. Via introduction. A Briar user may introduce two of her contacts by
ﬁrst sending requests to them. If both contacts accept the introduction,
the introducer may relay protocol messages between the contacts via
established connections. In the introduction protocol, the contacts can
derive a shared secret key mk unknown to the introducer and exchange
their contact information.

For the ﬁrst two options, the peers need to additionally perform contact
exchange, where they exchange contact information records, signed with ssk
and encrypted with a key derived from mk. This step is used to verify the
peer’s identity, exchange contact information, and negotiate the timestamp.

3.4 Communication

After adding a contact, the user may send messages to or receive messages
from the contact. The messaging functionality is implemented as a BSP
client, which synchronizes messages between the peers using Bramble Syn-
chronisation Protocol (BSP).

11

3. Overview of Briar

Briar also supports private groups, forums, and blogs. They are also imple-
mented as BSP clients, which synchronize messages between members or
subscribers in the same BSP group. Only the creator can invite new mem-
bers to a private group by sending a signed invitation token, while any
forum subscriber may invite new subscribers to the forum. A blog is visible
precisely to the user’s contacts. While all members or subscribers of the pri-
vate group/forum/blog can see all messages in the group, they may only
perform syncrhonization between direct contacts in the group to whom they
revealed the membership. Messages in the private group/forum/blog are
BSP messages that generally include the group identiﬁer, timestamp, and a
BDF list of the message type, content, and the author’s signature.

In a lower level, BSP runs over Bramble Transport Protocol (BTP), which
secures the trasmitted data using session keys derived from the master key.
BTP rotates session keys peroidically to provide forward security. BTP runs
over Bluetooth, WiFi, or Tor connections between the peers.

12

Chapter 4

Bramble QR Code Protocol (BQP)

Bramble QR Code Protocol (BQP) is a protocol used in Briar to add contacts
nearby. Two peers ﬁrst scan each other’s QR code, and then use the infor-
mation from the QR code to establish communication and derive a shared
secret key.
In Briar, the peers use the key derived from BQP to perform
contact exchange (Chapter 6) and set the key as the root key in Bramble
Transport Protocol (BTP) rotation mode (Section 7.1.3). Readers may also
refer to the BQP speciﬁcation [8].

4.1 Constants

The current version of BQP is 4. The record types in BQP are KEY (0x00),
CONFIRM (0x01), and ABORT (0x02). Labels in BQP are namespaced strings
of the form "org.briarproject.bramble.keyagreement/ABC", where ABC
is the label name; we omit "org.briarproject.bramble.keyagreement" in
the following sections for simplicity.

4.2 Preparation and connection establishment

Each peer ﬁrst runs Algorithm 1 to generate a ephemeral key pair and de-
rive a QR code containing a commitment to the ephemeral public key and
transport descriptors. The commitment is the ﬁrst 16 bytes of the labeled
hash of the ephemeral public key. The peers then scan each other’s QR code
and parse the payload, rejecting payloads from different protocol versions.

After parsing payloads, the peers compare the lexicographical order of their
commitments locally to determine their roles in the protocol, and try to use
the transport descriptors to establish a connection within 60 seconds.

13

4. Bramble QR Code Protocol (BQP)

Algorithm 1: Generate key pair and QR code.
(epk, esk) = keyGen();
comm = hash(".../COMMIT", epk)[0:15];
descriptors = list((id1, transportDescriptor1), ..);
payload = 0x04(cid:107)BDF-encode(list(comm) + descriptors);
createQrCode(ISO-8859-1-decode(payload));

4.3 Key agreement

Figure 4.1 shows the key agreement phase of BQP. Values sent and received
here are BQP records of the form 0x04(cid:107)type(cid:107)int16(len(payload))(cid:107)payload,
where type ∈ {KEY, CONFIRM, ABORT}. Algorithm 2 checks BQP records, abort-
ing when the type of incoming record is ABORT or unexpected. The party
that aborts should send a record with type ABORT to its peer, who should
also abort on receiving the record.

Algorithm 2: readRecord(reader, expectedType)
record = reader.readRecord(4);
if record == null then abort;
type = record.getRecordType();
if type == ABORT or type (cid:54)= expectedType then abort;
return record.getPayload();

Alice ﬁrst sends her ephemeral public key epkA to Bob, who checks that it
matches the commitment commA from the QR code payload of Alice. Bob
then sends epkB to Alice, who checks the it matches commB. After receiv-
ing each other’s public key, Alice and Bob respectively calculate the X25519
key exchange result of the local private key with the remote public key,
raw = DH(eskA, epkB) = DH(eskB, epkA). The raw secret is hashed together with
the label, the protocol version, and the ephemeral public keys, to produce
the shared secret s.

To conﬁrm that they have received the correct public key, Alice and Bob
each derives a conﬁrmation key ck from s, and computes a message authen-
tication code over the QR code payloads and ephemeral public keys, the
difference being the exact order. Each party sends the conﬁrmation to its
peer for veriﬁcation; if the veriﬁcation fails, then the peer aborts the proto-
col. Finally, the master key mk is derived from the shared secret s.

14

4.3. Key agreement

Alice
(epkA, eskA) = keyGen()
scan QR code and parse payloadB, commB

Bob
(epkB, eskB) = keyGen()
scan QR code and parse payloadA, commA

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . key exchange . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

epkA

epkB

comm(cid:48)
if comm(cid:48)

A = hash(”.../COMMIT”, epkA)[0 : 15]

A (cid:54)= commA then abort

B = hash(”.../COMMIT”, epkB)[0 : 15]

B (cid:54)= commB then abort

comm(cid:48)
if comm(cid:48)
raw = DH(eskA, epkB)
s = hash(”.../SHARED SECRET”, raw,

0x04, epkA, epkB)

raw = DH(eskB, epkA)
s = hash(”.../SHARED SECRET”, raw,

0x04, epkA, epkB)

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . conﬁrmation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

ck = KDF(”.../CONFIRMATION KEY”, s)
confirmA = mac(”.../CONFIRMATION MAC”, ck,
payloadA, epkA, payloadB, epkB)

ck = KDF(”.../CONFIRMATION KEY”, s)
confirmA = mac(”.../CONFIRMATION MAC”, ck,
payloadA, epkA, payloadB, epkB)

confirmB = mac(”.../CONFIRMATION MAC”, ck,
payloadB, epkB, payloadA, epkA)

(A)
confirm
A

(B)
confirm
B

(A)
(cid:54)= confirm
B

(B)
if confirm
B
mk = KDF(”.../MASTER KEY”, s)
return mk

then abort

(B)
(cid:54)= confirm
A

(A)
if confirm
A
confirmB = mac(”.../CONFIRMATION MAC”, ck,
payloadB, epkB, payloadA, epkA)

then abort

mk = KDF(”.../MASTER KEY”, s)
return mk

Figure 4.1: Key agreement phase of Bramble QR Code Protocol (BQP). Note that peers would
check that records received are well-formed and abort if not.

15

4. Bramble QR Code Protocol (BQP)

4.4 Notes

• Reversing commitment. As the commitments have 128 bits, it should be
infeasible to recover the committed ephemeral public key, but feasible
to ﬁnd two ephemeral public keys committed to the same value. The
latter case, however, is not useful for the attacker, as the attacker cannot
inﬂuence the ephemeral keys of the honest users. [8]

• Role confusion. The peers determine their roles by comparing the lex-
icographical order of their commitments, so a role confusion is not
possible. However, it could be the case that two peers derive the same
commitment value (one party cheating, or with negligible probability).
As a result, each party thinks she is Bob and and waits for the remote
peer, so the protocol times out after 60 seconds.

• Reﬂection attack. A reﬂection attack is not possible because the reﬂected
party always thinks she is Bob and would ask for the committed public
key ﬁrst.

• Small order subgroup attack. A small order subgroup attack is unlikely
because the private keys are clamped on generation, the raw X25519
key exchange aborts on zero result (Curve25519 also maps the inﬁn-
ity point to 0), and the ephemeral keys are also included in the hash
for producing the shared key. The developers also noticed this when
migrating to Curve25519.1

• Labels and keys. The labels for cryptographic operations in BQP are
peoperly namespaced and not reused elsewhere. Briar generates a
fresh ephemeral key pair each time and does not store the private key.

• State machine. The state machine of BQP is relatively simple and seems

well-formed.

• Formal veriﬁcation. A simpliﬁed version of BQP is veriﬁed by Tamarin,
where we ignore the payloads and assume the commitments are ex-
changed over an authenticated channel (Appendix A.1). The simpli-
ﬁed protocol satisﬁes key secrecy (that the attacker cannot recover the
shared key mk) and injective agreement. The deﬁnition for injective
agreement is quoted here in verbatim: “Whenever a completes a run
of the protocol, apparently with b in role B, then b has previously been
running the protocol, apparently with a, and b was acting in role B in
his run, and the two principals agreed on the message t. Additionally,
there is a unique matching partner instance for each completed run
of an agent” [18]. The deﬁnitions and more information about these
security properties can be found in Chapter “Property Speciﬁcation”
of the Tamarin prover manual [18].

1https://code.briarproject.org/briar/briar/-/issues/1163

16

Chapter 5

Bramble Handshake Protocol (BHP)

Bramble Handshake Protocol (BHP) is a protocol used in Briar to add remote
contacts. Before running BHP, the peers should have exchanged their long-
term public keys. This is done in Briar via exchanging the handshake link
(Section 5.1) between peers. BHP runs on top of Bramble Transport Protocol
(BTP) handshake mode (Section 7.1.2) and establishes an ephemeral shared
secret key between two peers. Similar to BQP, the Briar peers use the derived
key from BHP to perform contact exchange (Chapter 6) and set up transport
keys (Section 7.1.3). Readers may also refer to the BHP speciﬁcation [7].

5.1 The protocol

The current version of BHP is 0. The record types are EPHEMERAL PUBLIC KEY
(0x00) and PROOF OF OWNERSHIP (0x01). Labels in BHP are namespaced
strings of the form "org.briarproject.bramble.handshake/ABC", where
ABC is the label name. We omit "org.briarproject.bramble.handshake"
in the following sections for simplicity.

The handshake link should be of the form (briar://)?([a-z2-7]{53}).1
The latter part is the Base32 encoding of 0x00||pk, where 0x00 is the format
version of the handshake link. The handshake key pair and the handshake
link stay unchanged for a Briar identity after creation, and there is currently
no way to create a new handshake link except from creating a new account.

Assume that the peers have exchanged their handshake links and estab-
lished a connection via Tor, which is done using Bramble Randezvous Pro-
tocol (BRP) in Briar. The connection is set up in BTP handshake mode,
where the keys are statically derived from the long term handshake keys
(see Section 7.1.2). Before starting the handshake, each peer compares the
lexicographic order of the local public key and remote public key as byte

1An example: briar://adplpxapai4rx37brjgiml3ixbufvof56baq7yz63gkxhhibm6qae

17

5. Bramble Handshake Protocol (BHP)

arrays, taking the role of Alice if and only if the local public key is smaller.
Let (hpkA, hskA) and (hpkB, hskB) be the static handshake key pairs of Alice
and Bob, respectively. The protocol is shown in Figure 5.1.

First, Alice and Bob each generates an ephemeral key pair (epkA, eskA), and
(epkB, eskB), and sends the ephemeral public key to its peer. Then, each party
calculates the X25519 raw shared secret of the static keys and two pairs of
static-ephemeral keys. The raw secrets are hashed together with the label,
long term public keys, and ephemeral public keys to produce the master
key mk.

Alice and Bob then prove to each other they derived the correct master key.
Each party calculates a message authentication code over its label with the
master key and sends it to its peer. The peer aborts if the veriﬁcation fails.
Finally, if the proof matches, each party returns the derived master key mk.

Similar to BQP, values sent and received are encrypted records of the form
0x00(cid:107)type(cid:107)int16(len(payload))(cid:107)payload, where 0x00 is the protocol ver-
sion in bytes, and type ∈ {EPHEMERAL PUBLIC KEY, PROOF OF OWNERSHIP}.
Only records with the same version and expected types are accepted.

5.2 Lack of forward security

The BHP speciﬁcation claims that “the shared key produced by BHP can
be used to upgrade BTP to transport mode, which provides forward se-
crecy” [7]. However, for some unknown reason,2 BHP is not forward secure
as claimed.

If the long-term hanshake secret keys of Alice and Bob, hpkA and hpkB, are
both compromised, then the attacker could easily recompute from the pro-
tocol transcript the three X25519 key exchange results, raw0, raw1, raw2, and
recover the master key mk. The reason is that an ephemeral-to-ephemeral
key exchange secret, DH(eskA, epkB), or equivalently, DH(eskB, epkA), is miss-
ing from the hash input. As a result, BHP is not forward secure, and BTP
rotation mode initialized with the master key from BHP also fails to provide
forward security. Note that while showing a design ﬂaw in BHP, it should
be difﬁcult for attackers to exploit this vulnerability in practice, as attackers
have to obtain the protocol transcript sent over Tor.

A simple ﬁx would be to also incorporate DH(eskA, epkB) = DH(eskB, epkA) to
the hash input for key derivation, and optionally remove DH(hskA, hpkB) =
DH(hskB, hpkA) from the hash input. For users that have performed hand-
shakes before the ﬁx, Briar could either revoke old handshake key pairs, or

2A guess would be that BHP was added later than other protocols and is not yet thor-

oughly analyzed [11].

18

5.3. Notes

Alice
handshake key pair (hpkA, hskA)
obtains hpkB from Bob’s handshake link

Bob
handshake key pair (hpkB, hskB)
obtains hpkA from Alice’s handshake link

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . key derivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

(epkA, eskA) = keyGen()

(epkB, eskB) = keyGen()

{epkA}

{epkB}

raw0 = DH(hskA, hpkB)
raw1 = DH(hskA, epkB)
raw2 = DH(eskA, hpkB)
mk = hash(”.../MASTER KEY”, raw0, raw1,
raw2, hpkA, hpkB, epkA, epkB)

raw0 = DH(hskB, hpkA)
raw1 = DH(eskB, hpkA)
raw2 = DH(hskB, epkA)
mk = hash(”.../MASTER KEY”, raw0, raw1,
raw2, hpkA, hpkB, epkA, epkB)

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . proof of ownership . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

proofA = mac(”.../ALICE PROOF”, mk)

proofB = mac(”.../BOB PROOF”, mk)

{proofA}

{proofB}

verifyMac(proofB, ”.../BOB PROOF”, mk)
if verifyMac fails then abort
return mk

verifyMac(proofA, ”.../ALICE PROOF”, mk)
if verifyMac fails then abort
return mk

Figure 5.1: Bramble Handshake Protocol (BHP). Values on wire are encrypted in BTP hand-
shake mode. Peers would check if records received are well-formed after decryption and abort if
not.

derive fresh keys for all affected transports using the transport key agree-
ment client (Section 10.1).

5.3 Notes

• Self-handshake. As Base32 encodes every ﬁve bits to one character, the
handshake link can actually encode 53 · 5 = 265 bits of information,
one bit more than the 33 · 8 = 264 bits being encoded. The extra bit
is discarded during decoding and is not strictly enforced to be zero.
Therefore, there are two equivalent ways of encoding the same hand-
shake public keys that only differ by the last character (e.g., chang-
ing from e to f). This introduces the possibility of performing a self-
handshake, as Briar only rejects handshake links that are exactly the

19

5. Bramble Handshake Protocol (BHP)

same as the user’s own handshake link (after prepending briar://
if needed). However, in this case, Briar cannot connect to the remote
party via BRP, where each party performs a static key exchange on
the handshake keys and derives an address according to their roles to
establish a Tor hidden service. Since the attacker does not know the
user’s handshake private key and square-DH is assumed to be hard in
Curve25519, the attacker cannot derive the hidden service address for
the other role and therefore cannot connect to the user.

• Duplicate handshake links. Briar would check the parsed handshake
public key from the link and see if it comes from an existing contact
or pending contact (which is a remote peer to be added as a contact
via BHP); if so, Briar asks the user if the two links come from the same
person, and warns the user about a possible contact discovery attempt
if the user answers no. Briar removes the new link in both cases.

• Small order subgroup attack. This is unlikely following the similar rea-

soning for BQP in Section 4.4.

• Reﬂection. It might be tempting to add a small order element to the
public key, but then the derived keys in BTP handshake mode would
still be different because the public keys are included in the hash input
for deriving transport keys; see Section 7.1.2.

• Labels and keys. The labels for cryptographic operations in BHP are
peoperly namespaced and not reused elsewhere. The long-term hand-
shake private keys are stored in an encrypted database, the key of
which is again encrypted with the user’s password. Briar generates a
fresh ephemeral key pair for a new handshake and does not store it.

• State machine. The state machine of BHP is simpler than BQP and

seems well-formed.

• Formal veriﬁcation. We veriﬁed a simpliﬁed version of BHP with Tamarin
(Appendix A.2), which shows that BHP satisﬁes key secrecy and injec-
tive agreement, but does not provide forward security.

20

Chapter 6

Contact Exchange

Having derived a shared serect key mk via BQP (Chapter 4) or BHP (Chap-
ter 5), Alice and Bob (keeping their roles in the previous protocol) start ex-
changing contact information via the same channel used for key agreement.
This protocol is not covered in the Briar speciﬁcations.

6.1 The protocol

The current version of the protocol is 1. All records in contact exchange are
of the type CONTACT INFO (0x00). Labels are namespaced strings of the form
"org.briarproject.bramble.contact/ABC", where ABC is the label name.
We omit "org.briarproject.bramble.contact" in the following sections
for simplicity.

A hardwired mimimum reasonable time MIN REASONABLE TIME MS =
1,609,459,200,000 (which represents 1 Jan. 2021, 00:00:00 UTC) is in place
to avoid too old timestamps from being negotiated. This also mitigates
denial-of-service attacks from excessive key rotations.

The peers keep their roles of Alice and Bob in the previous protocol (BQP or
BHP) used to derive the master key. Let (spkA, sskA), (spkB, sskB) be Ed25519
signing key pairs of the peers. The protocol is shown in Figure 6.1. Two
peers ﬁrst use the keys derived from the master key to set up a bidirec-
tional secure communication channel via BTP. All subsequent communica-
tions in the protocol are via the encrypted channel. Then, each peer proves
it owns the signing key pair by signing a nonce (a MAC over its label with
mk) with its signing private key ssk. Each party packs the signing pub-
lic key, the signature and some other contact information (transport prop-
erties, timestamp, ...)
into a record and send the encrypted record to its
peer. The peer checks that the entries in the record are correctly format-
ted and veriﬁes the signature. The peers agree on a timestamp and abort

21

6. Contact Exchange

if the agreed timestamp is too old. Finally, each party adds contact infor-
mation of its peer and uses mk as the root key to derive key sets in BTP
rotation mode. Values sent and received are encrypted records of the form
0x01(cid:107)CONTACT INFO(cid:107)int16(len(payload))(cid:107)payload.

Alice
hkA = KDF(”.../ALICE HEADER KEY”,

mk, 0x01)
hkB = KDF(”.../BOB HEADER KEY”,
mk, 0x01)

nA = mac(”.../ALICE NONCE”, mk, 0x01)
nB = mac(”.../BOB NONCE”, mk, 0x01)
sigA = sign(”.../EXCHANGE”, nA, sskA)
tA = timestamp()

check(infoB format), spkB = infoB.pk
check(spkB valid, tB ≥ 0)
if any check fails then abort
verify(sigB, ”.../EXCHANGE”, nB, spkB)
if verify fails then abort
t = min(tA, tB)
if t < MIN REASONABLE TIME MS

then abort

addContact(infoB, mk, t, ...)

{infoA, sigA, tA}hkA

{infoB, sigB, tB}hkB

Bob
hkA = KDF(”.../ALICE HEADER KEY”,

mk, 0x01)
hkB = KDF(”.../BOB HEADER KEY”,
mk, 0x01)

nA = mac(”.../ALICE NONCE”, mk, 0x01)
nB = mac(”.../BOB NONCE”, mk, 0x01)
sigB = sign(”.../EXCHANGE”, nB, sskB)
tB = timestamp()

check(infoA format), spkA = infoA.pk
check(spkA valid, tA ≥ 0)
if any check fails then abort

verify(sigA, ”.../EXCHANGE”, nA, spkA)
if verify fails then abort
t = min(tA, tB)
if t < MIN REASONABLE TIME MS

then abort

addContact(infoA, mk, t, ...)

Figure 6.1: Briar contact exchange. Values on wire are records encrypted using BTP with the
header keys speciﬁed in subscripts.

6.2 Notes

• Custom BTP mode. As mentioned before, the contact exchange protocol
uses an ad hoc method of managing key sets for the underlying BTP,
which is undocumented in the speciﬁcation. However, it is not obvious
that this would lead to any attacks.

• Weak signature. It is possible that one party deliberately uses a weak
Ed25519 signing key pair such that she can create a valid signature
without knowing the message (nonce here) to be signed, but it is not
clear how this is going to be useful, since sending a well-formed record

22

already implies knowledge of the BTP keys and therefore knowledge
of the master key and the nonce derived from it.

6.2. Notes

23

Chapter 7

Bramble Transport Protocol (BTP)

Bramble Transport Protocol (BTP) is a transport layer security protocol that
allows two peers to build a secure channel for communication over some
unidirectional or bidirectional transport. The underlying transport should
be able to deliver in order a sequence of bytes (called a connection in Briar)
on a best-effort basis. Connections may be discarded or reordered. Readers
may also refer to the BTP speciﬁcation [10].

7.1 Key management protocol

For each available transport, the peers create and maintain a set of keys us-
ing a time-based key management protocol described here. The transport
properties used in key derivation and management are transport identiﬁer
id (e.g., "org.briarproject.bramble.bluetooth" for Bluetooth) and max-
imum latency L (e.g., hard-coded as 30,000 milliseconds, or 30 seconds, for
Bluetooth, and usually 30 seconds for other transports).

7.1.1 Constants

The maximum clock difference MAX CLOCK DIFFERENCE is 86,400,000, which
is 24 hours in milliseconds. The clock difference could be a result of peo-
ple not setting their time zones correctly. Labels in BTP are namespaced
strings of the form "org.briarproject.bramble.transport/ABC", where
ABC is the label name. We omit "org.briarproject.bramble.transport"
in the following sections for simplicity.

7.1.2 Handshake mode

Each party compares the lexicographical order of its handshake public key
with the remote peer’s handshake public key to decide on taking the role

25

7. Bramble Transport Protocol (BTP)

of Alice or Bob. We denote the handshake key pairs of Alice and Bob as
(hpkA, hskA) and (hpkB, hskB), respectively.

The key derivation process for Alice and Bob is shown in Algorithm 3; func-
tion clock() returns the elapsed time since the Unix epoch (1 Jan. 1970,
00:00:00 UTC) in milliseconds. To match the rotation mode, the key man-
ager keeps incoming keys for the previous, current, and next time period
and outgoing keys only for the current period. For the case where Alice and
Bob have already added each other as a contact (still not fully implemented
in Briar), we replace the label for deriving the pending contact root key pcrk
with ".../CONTACT ROOT KEY". Algorithm 4 shows how to derive the header
key and the tag key from the pending contact root key. As we also store the
root key in handshake mode, the key sets can be easily updated at each
interval by shifting key sets and computing new keys from the root key.

Algorithm 3: Key derivation in BTP handshake mode.
weAreAlice = hpklocal < hpkremote;
raw = weAreAlice ? DH(hskA, hpkB) : DH(hskB, hpkA);
smk = hash(".../STATIC MASTER KEY", raw, hpkA, hpkB);
pcrk = mac(".../PENDING CONTACT ROOT KEY", smk);
foreach transport (id, L) do

P = (cid:98)clock() / (L + MAX CLOCK DIFFERENCE)(cid:99);
if P < 1 then abort;
inPrev = deriveHandshakeKeys(id, pcrk, !weAreAlice, P-1);
inCurr = deriveHandshakeKeys(id, pcrk, !weAreAlice, P);
inNext = deriveHandshakeKeys(id, pcrk, !weAreAlice, P+1);
outCurr = deriveHandshakeKeys(id, pcrk, weAreAlice, P);
addKeys(id, inPrev, inCurr, inNext, outCurr, pcrk, weAreAlice);

Algorithm 4: deriveHandshakeKeys(id, pcrk, isAlice, P)
TAG LABEL = isAlice ?

".../ALICE HANDSHAKE TAG KEY":

".../BOB HANDSHAKE TAG KEY";

HEADER LABEL = isAlice ?

".../ALICE HANDSHAKE HEADER KEY":

".../BOB HANDSHAKE HEADER KEY";
ktag = KDF(TAG LABEL, pcrk, utf-8(id), int64(P));
kheader = KDF(HEADER LABEL, pcrk, utf-8(id), int64(P));
return (ktag, kheader);

7.1.3 Rotation mode

Assume the peers have previously established a shared secret key rk and a
timestamp timestamp (counted from the Unix epoch in milliseconds), and
that they keep their respective roles of Alice and Bob in the previous pro-

26

7.2. Wire protocol

tocol. The timestamp is negotiated by the peers to reduce the number of
rounds for key rotation; otherwise they may have to rotate the keys start-
ing from the Unix epoch, which has a higher cost and can be vulnerable to
denial-of-service attacks.

Algorithm 5 shows the key derivation process. The key manager keeps in-
coming keys for the previous, current, and next period, because incoming
messages should always fall into one of these three periods if our assump-
tions are correct. Algorithm 6 shows the key update process, in which we
keep rotating the keys until we reach the current period. Algorithm 7 shows
how we derive the header key and the tag key from the root key. Algo-
rithm 8 rotates the key sets by computing the labeled hash with time period
for each key respectively.

Algorithm 5: Key derivation in BTP rotation mode.
foreach transport (id, L) do

P = (cid:98)timestamp / (L + MAX CLOCK DIFFERENCE)(cid:99);
inPrev = deriveRotationKeys(id, rk, !weAreAlice);
outPrev = deriveRotationKeys(id, rk, weAreAlice);
inCurr = rotateKeys(inPrev, P);
inNext = rotateKeys(inCurr, P+1);
outCurr = rotateKeys(outPrev, P);
keys = TransportKeys(id, inPrev, inCurr, inNext, outCurr, P);
curP = (cid:98)clock() / (L + MAX CLOCK DIFFERENCE)(cid:99);
updatedKeys = updateTransportKeys(keys, curP);
addKeys(id, updatedKeys);

updateTransportKeys(k=(id, inPrev, inCurr,

6:

Algorithm
inNext, outCurr, P), curP)
if k.P >= curP then return k;
for p = k.P+1 to curP do

inPrev, inCurr = inCurr, inNext;
inNext = rotateKeys(inNext, p+1);
outCurr = rotateKeys(outCurr, p);

return (id, inPrev, inCurr, inNext, outCurr, curP);

7.2 Wire protocol

The wire protocol delivers encrypted streams of data over some possibly in-
secure connections. Note that the protocol is not intended to deliver streams
of data reliably; the data might be delayed, reordered, or deleted.

27

7. Bramble Transport Protocol (BTP)

Algorithm 7: deriveRotationKeys(id, rk, isAlice)
TAG LABEL = isAlice ?
HEADER LABEL = isAlice ? ".../ALICE HEADER KEY": ".../BOB HEADER KEY";
ktag = KDF(TAG LABEL, rk, utf-8(id));
kheader = KDF(HEADER LABEL, rk, utf-8(id));
return (ktag, kheader);

".../ALICE TAG KEY": ".../BOB TAG KEY";

Algorithm 8: rotateKeys((ktag, kheader), P)
k(cid:48)
tag = KDF(".../ROTATE", ktag, int64(P));
k(cid:48)
header = KDF(".../ROTATE", kheader, int64(P));
return (k(cid:48)

tag, k(cid:48)

header);

The current protocol version is 4.

7.2.1 Stream and tag

The underlying transport of BTP should be able to deliver a sequence of
bytes in order, which is called a connection in Briar. BTP uses a connection
to carry a sequence of encrypted and authenticated data, which is called a
stream.

Each stream has a 32-bit stream number (encoded as a 64-bit integer), as-
signed by the key manager of the transport. Stream numbers are counted
starting from zero in each time period. A stream consists of a tag, a stream
header (Section 7.2.2), and one or more frames (Section 7.2.3).

A stream starts with a pseudo-random tag of TAG LEN = 16 bytes, which is
of the form PRF(ktag, [0x00, 0x04]||int64(streamNumber))[:TAG LEN-1].
The function PRF is implemented with BLAKE2b (see Section 2.3). Each
peer maintains a reordering window of size 32 for each time period (or to
say each set of keys in use) to recognize a possibly out-of-order stream and
avoid stream replays.

7.2.2 Stream header

The pseudo-random tag is followed by a stream header, which is of the form
nonce||ENC(kheader, nonce, [0x00, 0x04]||int64(streamNumber)||frameKey),
where nonce is a secure random byte array of length 24, and frameKey is a
secure random byte array of length 32. We see that the plaintext of a stream
header has 2+8+32=42 bytes, and the stream header itself has 24+(42+16) =
82 bytes (the length of Poly1305 output is 16 bytes). Algorithm 9 shows the
process of decrypting a stream header, which mostly follows the deﬁnition
of the stream header.

28

7.2. Wire protocol

Algorithm 9: readStreamHeader()
ciphertext = read(0, 82);
nonce = ciphertext[0:23];
plaintext = DEC(kheader, nonce, ciphertext[24:]);
if len(plaintext) != 32 then abort;
if plaintext[0:1] != [0x00, 0x04] then abort;
if plaintext[2:9] != int64(streamNumber) then abort;
frameKey = plaintext[10:];

7.2.3 Frame

Some frame constants are listed below.

NONCE_LEN = 24;
FRAME_HEADER_PLAINTEXT_LENGTH = 4;
FRAME_HEADER_LENGTH = 20;
MAX_FRAME_LENGTH = 1024;
MAX_PAYLOAD_LENGTH = 988;

The remainder of the stream consists of one or more frames, numbered from
0 to 263 − 1. Each frame has a ﬁxed-length frame header and a variable-
length frame body that may contain data and an optional padding. The
optional padding is implemented but not used in Briar. The header and data
are both encrypted and authenticated with frameKey in the stream header,
albeit with different deterministic nonces. Nonces are not sent over the wire.

The frame header is of the form ENC(frameKey, headerNonce,
final||int15(len(data))||int16(len(padding))). Field headerNonce is
a byte array of length 24, with ﬁrst 8 bytes set to int64(frameNumber), the
ﬁrst (most signiﬁcant) bit then set to 1, and the rest of the bytes set to 0x00.
Field final is a one-bit ﬂag indicating if the current frame is the ﬁnal frame.
The frame header plaintext has 4 bytes and the frame header has 4+16=20
bytes. Note that we can overlap the frame number ﬁeld with an additional
ﬂag in the nonce because the most signiﬁcant bit is unused.

The frame data is of the form ENC(frameKey, dataNonce, data||padding),
where dataNonce is a byte array of length 24, with ﬁrst 8 bytes set to
int64(frameNumber), and the rest of the bytes set as 0x00. The maximum
length of the encrypted frame is 1,024 bytes, so we have 1,024-20-16=988
bytes remaining for payload and optional padding in plaintext.

Algorithm 10 shows the process of reading a frame, where read(x, y) de-
notes reading y bytes starting from the x-th byte, ∨ denotes a bitwise-OR
operation, and [0x00]*(NONCE LEN-8) denotes an all-zero byte array of 16

29

7. Bramble Transport Protocol (BTP)

bytes. On abort speciﬁed in the algorithm or error within the cryptographic
primitives (decryption error in this case), the connection would be closed.

Algorithm 10: readFrame()
if finalFrame then return null;
if frameNumber < 0 then abort;
ciphertext = read(0, FRAME HEADER LENGTH);
nonce = int64(frameNumber)||[0x00]*(NONCE LEN-8);
nonce[0] = nonce ∨ 0x80 ;
frameHeader = DEC(frameKey, nonce, ciphertext);
if len(frameHeader) != FRAME HEADER PLAINTEXT LENGTH then abort;
finalFrame, payloadLen, paddingLen = decode(frameHeader);
if payloadLen + paddingLen > MAX PAYLOAD LENGTH then abort;
frameLen = FRAME HEADER LENGTH + payloadLen + paddingLen + 16;
ciphertext = read(FRAME HEADER LENGTH, frameLen);
nonce = int64(frameNumber)||[0x00]*(NONCE LEN-8);
payload = DEC(frameKey, nonce, ciphertext);
if len(payload) != payloadLen + paddingLen then abort;
for i = 0 to paddingLen-1 do

if payload[payloadLen + i] != 0x00 then abort;

frameNumber++;
return payload;

7.3 Notes

• Underlying transport. BTP operates on a sequence of bytes that can
be delivered in order, so UDP should not be used for the underlying
transport. Note that having an unreliable underlying transport such
as UDP would not harm the security of BTP, as a malformed stream
should cause BTP to abort and close the connection.

• Payload length. We can set the payload length in the frame header to be
larger than the actual payload length, but we cannot hope to use this
to read the program memory of the remote machine, because 1) Java
is memory safe, 2) the function read() only returns the available bytes
in the input stream, so readFrame() can only read bytes from the con-
nection, and 3) with high probability the authenticated cipher would
fail to decrypt the malformed payload and throw an error, causing the
connection to be closed.

• Deletion and truncation. Each of the stream can be deleted or indef-
initely delayed separately. Within a stream, the last frames can be
truncated, but then the ﬁnal frame ﬂag would go missing. However,
there seems to be no active checks on whether the ﬁnal frame ﬂag is

30

7.3. Notes

raised in the end (we can always think of the ﬁnal frame as not yet
arrived).

• Duplication. Since we keep a reordering window for each time period,
the streams cannot be replayed. Frames within a stream cannot be
duplicated either, because otherwise they would be decrypted with
incorrect nonces.

• Tag collision. In an honest execution, the tags would only collide with
negligible probability. An attacker may be able to create a tag collision
intentionally (e.g., by brute-forcing the BTP handshake mode ofﬂine),
but it would not be useful to the attacker, as the tag would be recog-
nized as the context added more recently.

• Key robustness. As XSalsa20Poly1305 is used for encryption, it is pos-
sible for attackers to create two valid streams that differ in the tag
and stream header but have the same frames. However, this does not
beneﬁt the attacker in any obvious way. We note that when Briar for-
wards a message received from a BSP group, the message would stay
the same, but the underlying BTP stream sent would be different (and
looks independent) from the BTP stream it received.

31

Chapter 8

Bramble Synchronisation Protocol
(BSP)

Bramble Synchronisation Protocol (BSP) is an application layer data syn-
chronization protocol in Briar that allows members of the same group to
synchronize messages over delay-tolerant networks. Although, as the name
suggests, there is very little cryptography involved in BSP, it may still be
interesting to discuss how BSP provides security, since the underlying BTP
can be unreliable. Readers may also refer to the BSP speciﬁcation [9].

8.1 Concepts

Basically, BSP synchronizes messages among clients within the same group.

A BSP client is an application component in Briar that uses BSP to achieve
its functionalities, such as the messaging client and the introduction client.
Each type of BSP client has a client identiﬁer, a major version number, and
a minor version number. For example, the client identiﬁer of the messaging
client in Briar is "org.briarproject.briar.messaging", and the current
major and minor version numbers of the messaging client are respectively 0
and 3. BSP clients may only synchronize messages with other BSP clients of
the same major version.

A group consists of one or more BSP clients of the same client identiﬁer
client id and major version major. The group identiﬁer is computed by
each BSP client locally as hash("org.briarproject.bramble/GROUP ID",
0x01, int32(major), descriptor), where 0x01 is the group format ver-
sion, and descriptor is the group descriptor decided by the clients. For
example, the group descriptor of the messaging client is a BDF list of sorted
author identﬁers of the two peers, cast to a byte array.

A message in BSP consists of a group identiﬁer group id, a timestamp (a

33

8. Bramble Synchronisation Protocol (BSP)

64-bit integer cast to bytes that denotes milliseconds elapsed from the Unix
epoch) timestamp, and the message body body. Each message has a mes-
sage identiﬁer message id, which is not included in the message but can be
uniquely computed as hash("org.briarproject.bramble/MESSAGE ID", 0x01,
group id, timestamp, root hash), where 0x01 is the message format ver-
sion, and root hash is hash("org.briarproject.bramble/MESSAGE BLOCK",
0x01, body). It should be computationally infeasible to produce two differ-
ent messages with the same message identiﬁer if we assume that BLAKE2b
is collision-resistant. Each client validates the received message according
to the validation policy speciﬁed by the BSP client.

The wire protocol synchronizes messages using records of the form
0x00(cid:107)type(cid:107)int16(len(payload))(cid:107)payload, where 0x00 is the current ver-
sion of BSP, and type is one of {ACK, MESSAGE, OFFER, REQUEST, VERSIONS,
PRIORITY}. As the name suggests, ACK, OFFER, and REQUEST records contain
a list of message identiﬁers to acknowledge receipt, offer to the remote client,
and request to the remote client, respectively. The MESSAGE record contains
a BSP message. The VERSIONS record is implemented for future BSP pro-
tocols to be able to negotiate supported versions but is never sent by the
current BSP protocol. The PRIORITY record type is not documented in the
speciﬁcation and is used to choose between redundant connections.

Messages in BSP can also have dependencies, represented as message iden-
tiﬁers. The exact way of representing and handling message dependencies is
decided by the respective BSP client. For example, the messaging client does
not implement any dependencies, while in the private group client, each
post message depends on the previous message from the same author, and
optionally, its parent message in the thread. A message with dependencies
is ﬁrst validated by the client, and then put on hold until all dependencies
have arrived.

A BSP client only synchronizes messages in a group with a remote client if
the remote client is controlled by a direct contact of the local identity, they
are in the same group, and the local client shares the group to the remote
client. The sharing policy is decided by each BSP client. Nevertheless, every
member in the same group is entitled to view all messages within the group,
and would eventually arrive at the same view if the synchronization network
is connected.

8.2 Denial-of-service attack

The maximum record payload in BSP is 48KiB, which can be reached by ACK,
OFFER, and REQUEST records. In contrast, a message has a 40-byte header and
a body of at most 32KiB. The BSP record reader implementation in Briar

34

8.3. Notes

does not check if a message is too long before parsing.1

A remote contact can send a MESSAGE record of size between 32,809 bytes
(32KiB+41B) and 49,152 bytes (48KiB) to the victim. The victim’s application
will throw an IllegalArgumentException when trying to parse this mes-
sage,2 which will halt the application. As long as the victim does not delete
the malicious contact and they are both online, the malicious contact can
repeatedly launch this attack, rendering the victim’s application unusable.

To ﬁx this issue, Briar could check whether the message is too long before
parsing, or change/catch the IllegalArgumentException thrown from the
aforementioned code.

8.3 Notes

• Contact probing. It might be tempting to (ab)use OFFER and REQUEST
records or message dependencies to probe the message identiﬁers of
the other groups. If we know the group identiﬁer, the rough content
and time interval of the message, we would have a good probability of
reversing the message content by brute-forcing the message identiﬁer,
but this is not possible because the underlying database implementa-
tion separates the message space of different groups. For OFFER and
REQUEST records, the client only looks for messages shared to the re-
mote client; for dependencies, a dependency is only satisﬁed if the
parent message has the speciﬁed identiﬁer and is in the same group.
It would also not work to change the group identiﬁer in the message
to the target group, because then the validation would fail.

1https://code.briarproject.org/briar/briar/-/blob/release-1.

4.20/bramble-core/src/main/java/org/briarproject/bramble/sync/
SyncRecordReaderImpl.java#L123

2https://code.briarproject.org/briar/briar/-/blob/release-1.4.20/

bramble-core/src/main/java/org/briarproject/bramble/sync/MessageFactoryImpl.
java#L57

35

Chapter 9

Introduction Client

In Briar, the introduction client is a BSP client that allows a Briar user to in-
troduce two contacts to each other. Recall that a BSP client is an application
component that uses Bramble Synchronisation Protocol (BSP) to synchronize
data. A Briar user can act as an introducer by sending requests to two of its
contacts (introducees). If both introducees accept the introduction, they can
establish a shared secret key and exchange contact information by commu-
nicating with the introducer via the introduction client. Readers may also
refer to the speciﬁcation of the introduction client [15].

9.1 The protocol

All labels in the introduction client except AUTHOR ID are of the form
"org.briarproject.briar.introduction/"+LABEL NAME. As an exception,
we have AUTHOR ID = "org.briarproject.bramble/AUTHOR ID".

Like in the contact exchange protocol (Section 6.1), a hardwired mimimum
reasonable time MIN REASONABLE TIME MS = 1,609,459,200,000 (which rep-
resents 1 Jan. 2021, 00:00:00 UTC) is in place to avoid too old timestamps
from being negotiated.

Each participant has a nickname name, a signing key pair (spk, ssk), and a
unique identiﬁer id = hash(AUTHOR ID, int32(1), utf-8(name), spk). A user
knows the nickname, the signing public key and the identiﬁer of its contacts.

Suppose that a user, as an introducer, would like to introduce two of the
contacts to each other. The introducer compares the lexicographical order
of the identiﬁers to decide who takes the role of each introducee, with the
smaller one being Alice and the other being Bob. We use subscripts I, A,
B to denote the values of or computed by the introducer, Alice, and Bob,
respectively.

37

9.

Introduction Client

Messages are sent and received in this protocol via BSP, which runs over an
encrypted and authenticated channel via Bramble Transport Protocol (BTP).
The message body is a Bramble Data Format (BDF) list containing the mes-
sage type, the session id hash(SESSION ID, idI, idA, idB), the identiﬁer of the
previous message, and other elements shown in the protocol description.
We do not write down the complete record in the protocol description for
simplicity.

The introducer ﬁst sends a REQUEST message to each introducee, which con-
tains the nickname and signing public key of its peer, and a text string (max.
31KiB) explaining the reason for introduction. Each introducee computes lo-
cally the identiﬁer of the remote peer and decide on taking the role of Alice
and Bob, and chooses to accept or decline the request.

Figure 9.1 shows the protocol of Briar introduction client when both intro-
ducees accepts the introduction. Each introducee sends an ACCEPT message
to the introducer, which contains its ephemeral public key, timestamp, and
transport properties. The introducer forwards the ACCEPT message to the
other introducee.

In the case where one or more introducee declines, each declining introducee
sends a DECLINE message to the introducer, which forwards the message
and resets the state. The introducee receiving a DECLINE message should
also reset the state if she has not already done so.

If both introducees accept and have received an ACCEPT message, then they
would compute the shared secret key from the ephemeral key exchange.
Each introducee then derives a MAC key ck from the shared key, uses the
MAC key to authenticate the contact information tomac, uses the long-term
signing key ssk to sign a nonce n derived from the mac key, and sends an
AUTH message containing the message authentication code h and the signa-
ture sig to the introducer, who forwards it to the other introducee.

After sending and receiving the forwarded AUTH message, each introducee
checks its validity and adds the remote introducee as a contact if it is valid.
The introducee then sends an ACTIVATE message to the introducer that for-
wards it to the other introducee, and waits for the remote ACTIVATE message
to be forwarded. On receiving the remote ACTIVATE message, the introducee
checks that it is valid and sets the transport keys as active if necessary.

If the introducer aborts, possibly for a bad protocol state or wrong message
format, then she would send an ABORT message to each of the introducee,
who should also abort. An introducee that aborts would also send an ABORT
message to the introducer, who forwards the ABORT message to the other
introducee and aborts.

38

9.1. The protocol

Alice

Introducer

Bob

(nameB, spkB), text

(nameA, spkA), text

epkA, tA, pA

epkA, tA, pA

epkB, tB, pB

epkB, tB, pB

hA, sigA

hB, sigB

hA, sigA

hB, sigB

idB = hash(AUTHOR ID, int32(1),

utf-8(nameB), spkB)

(epkA, eskA) = keyGen()
tA = timestamp()
pA = transportProperties()

infoA = (idA, tA, epkA, pA)
infoB = (idB, tB, epkB, pB)
raw = DH(eskA, epkB)
mk = hash(MASTER KEY, raw,
[0x01], epkA, epkB)
ckA = KDF(ALICE MAC KEY, mk)
ckB = KDF(BOB MAC KEY, mk)
tomacA = BDF-encode((idI, infoA,

infoB))

tomacB = BDF-encode((idI, infoB,

infoA))

hA = mac(AUTH MAC, ckA, tomacA)
nA = mac(AUTH NONCE, ckA)
sigA = sign(AUTH SIGN, nA, sskA)

if !verifyMac(hB, AUTH MAC, ckB,

tomacB) then abort
nB = mac(AUTH NONCE, ckB)
verify(sigB, AUTH SIGN, nB, spkB)
if verify fails then abort
t = min(tA, tB)
if t < MIN REASONABLE TIME MS

then abort

CB = addContact(infoB, mk, t)
ackA = mac(ACTIVATE MAC, ckA)

idA = hash(AUTHOR ID, int32(1),

utf-8(nameA), spkA)

(epkB, eskB) = keyGen()
tB = timestamp()
pB = transportProperties()

infoA = (idA, tA, epkA, pA)
infoB = (idB, tB, epkB, pB)
raw = DH(eskB, epkA)
mk = hash(MASTER KEY, raw,
[0x01], epkA, epkB)
ckA = KDF(ALICE MAC KEY, mk)
ckB = KDF(BOB MAC KEY, mk)
tomacA = BDF-encode((idI, infoA,

infoB))

tomacB = BDF-encode((idI, infoB,

infoA))

hB = mac(AUTH MAC, ckB, tomacB)
nB = mac(AUTH NONCE, ckB)
sigB = sign(AUTH SIGN, nB, sskB)

if !verifyMac(hA, AUTH MAC, ckA,

tomacA) then abort
nA = mac(AUTH NONCE, ckA)
verify(sigA, AUTH SIGN, nA, spkA)
if verify fails then abort
t = min(tA, tB)
if t < MIN REASONABLE TIME MS

then abort

CA = addContact(infoA, mk, t)
ackB = mac(ACTIVATE MAC, ckB)

ackA

ackB

ackA

ackB

if !verifyMac(ackB, ACTIVATE MAC,

if !verifyMac(ackA, ACTIVATE MAC,

ckB) then abort
CB.activateKey()

ckA) then abort
CA.activateKey()

Figure 9.1: A protocol run of the Briar introduction client, where both introducees accept the
introduction.

39

9.

Introduction Client

9.2 Active man-in-the-middle attack

As there is no out-of-band veriﬁcation for the public keys (and thus iden-
tities) of the introducees, the introducer could launch a man-in-the-middle
attack. However, because of the non-zero check on X25519 key exchange
and the inclusion of key pairs into the hash input for key derivation, the
introducer can only derive different master keys for the introducees, which
is not preventable without introducing further ways of veriﬁcation. This
attack model is realistic as Briar is designed for high-risk individuals (e.g.,
protestors), so an inﬁltrator could ﬁrst introduce two peers to each other
with different master keys known to the inﬁltrator, and subsequently con-
duct a man-in-the-middle attack on the peers’ communicatons.

In Briar, a trust indicator is shown beside each contact, which is VERIFIED
(three green bars) for contacts added by BQP, and UNVERIFIED (two orange
bars) for contacts added by all other methods. The developers also realized
the lack of veriﬁcation possibility for contacts added via introduction, but
argued that the veriﬁcation could be hard to implement, and QR-code based
veriﬁcation methods would still not resolve the fundamental issue here, as
the malicious introducer could modify the introducee’s negotiation of off-
line veriﬁcation on Briar, such that each introducee meets with an attacker-
controlled person ofﬂine instead of the perceived remote introducee.1

While out-of-band veriﬁcations could also be susceptible to some sophisti-
cated attacks, it could still be a good idea to at least provide some form of
out-of-band veriﬁcations and let the users decide, instead of relying on users
to perform makeshift veriﬁcations themselves.

9.3 Notes

• Similarity with BQP. The introduction client is, in essence, BQP coupled
with the contact exchange protocol. Therefore, the protocol in itself
would not be easily exploitable if we assume the security of BQP and
the contact exchange protocol.

• Reﬂection attack. A reﬂection attack is not possible because of the dif-
ferent labels used for the MAC keys of Alice and Bob, and the different
order of the data to be authenticated.

• Role confusion. A difference between the introduction client and BQP is
that how each introducee takes roles is independent from the ephemeral
key pair, so it might be tempting for the introducer to modify the name
to make both parties think they are Bob (or Alice), but ultimately the
signature or MAC value would not pass veriﬁcation.

1https://code.briarproject.org/briar/briar/-/issues/513

40

9.3. Notes

• State machine. The state machine is much more complicated than the

previous protocols mentioned but seems well-formed.

• Formal veriﬁcation. As expected, a simpliﬁed version of the introduction
protocol in Tamarin (Appendix A.3) fails checks for key secrecy, injec-
tive agreement and forward security, but satisﬁes all these properties
if we let the signing public keys be distributed by a trusted public-key
infrastructure.

41

Chapter 10

Briar Functionalities

Most of the functionalities in Briar are implemented as BSP clients, which are
at the topmost level of the protocol stack. Because of the asynchronous na-
ture of Briar, these functionalities can be rather constrained and sometimes
behave differently from other messaging applications. The Briar speciﬁca-
tion provides documentations for most of the BSP clients used in Briar.1

10.1 Transport key agreement client

The transport key agreement client is a BSP client that establishes keys for
newly added transports [17]. As Briar uses separate key sets for different
transports, when a new transport is added or supported by the peers after
adding contact, it is necessary for the peers to agree on new keys for it.

Basically, each party ﬁrst generates an ephemeral key pair and sends the
ephemeral public key to its peer via BSP, which is again over BTP rotation
mode on some existing connection. The parties use the lexicographic order
of the ephemeral public keys to assign the roles of Alice and Bob. We denote
the ephemeral key pairs of Alice and Bob as (epkA, eskA) and (epkB, eskB), re-
spectively. Each party calculates the X25519 key exchange of the local private
key with the remote public key, raw = DH(eskA, epkB) = DH(eskB, epkA). The
raw secret is hashed together with the label and the ephemeral public keys
to produce the master key mk, which is then used to derive keys for the new
transport.

Assuming that the underlying protocols are secure and the state machine
of the transport key agreement client is correct, the key agreement process
should be secure and provide forward security.

1https://code.briarproject.org/briar/briar-spec/-/tree/master/clients

43

10. Briar Functionalities

10.2 Messaging

Two peers use a dedicated BSP group to synchronize private messages be-
tween them. To this end, each peer maintains a separate BSP client, called
the messaging client, for each of its contacts. The client identiﬁer is
"org.briarproject.briar.messaging", and the group descriptor is a BDF
list (cast to a byte array) of sorted author identﬁers of the two peers (see also
Chapter 8). The messages are of the type PRIVATE MESSAGE or ATTACHMENT.
A PRIVATE MESSAGE message contains the UTF-8 encoding of a text message
(max. 30KiB after encoding), up to ten optional attachment headers, and an
optional auto-delete timer. An attachment header consists of the message
identiﬁer of the respective attachment and the content type. An ATTACHMENT
message contains of a byte array of the attachment and the content type.
Note that Briar only supports attachments for private messages, not for pri-
vate groups, forums or blogs, and the security implication of attachments is
(recently) included in the Briar threat model [11] but not yet analyzed.

For each incoming message, the client checks that it is correctly formed,
and that the timestamp is not too far in the future (max. 24 hours from
now). There are no additional integrity checks involved, such as signatures.
Messages are sorted according to their timestamps on display. The client
tracks the lastest timestamp t among all conversations (messaging, group
invitation, or sharing) with the remote peer, and sets the timestamp for the
next outgoing message to be the maximum of the system clock and t+1.

Notes

• Network attacks. Assuming the security of BSP layered on BTP, the
attacker can only drop messages or reorder the sequence of the mes-
sage; in the latter case, the messages would eventually be displayed in
the correct order. The attacker cannot drop parts of some particular
message because no preﬁx of the encoded message is valid.

• Message collision. Two messages in the same group would have the
same message identiﬁer if they have the same timestamp and content
(see Chapter 8). The direction of the message is irrelevant.
In this
case, BSP would think the two messages are the same and rejects the
later message. This should be rather unlikely to happen in an honest
execution. The developers noticed this and suggested incorporating a
salt into the message or at the sync layer.2

• Out-of-order timestamps. A malicious peer may set arbitrary (valid)
timestamps for her messages, but they would eventually be displayed
in one ﬁxed order. The sorting algorithm used in Briar is stable.

2https://code.briarproject.org/briar/briar/issues/1907

44

10.3. Private groups, forums, and blogs

• Attachment probing. The messaging client explicitly checks whether an
attachment header refers to an attachment in the same group, so we
can not probe if an attachment is sent between two other parties.

10.3 Private groups, forums, and blogs

Private groups, forums, and blogs are quite similar except from how their
members are controlled. As quoted from Briar FAQ, “A private group is a
group chat where the admin decides who to invite. A forum is similar, but
anyone can invite new members. A blog is a bit like a Telegram channel:
you can write posts that all your contacts can see, and they can reshare
individual posts or invite their contacts to subscribe to your feed.”3

We take private groups as an example. The private group client is used to
synchronize messages in the private group among devices. The client identi-
ﬁer is "org.briarproject.briar.privategroup", and the group descriptor
is a BDF list (cast to a byte array) of the creator information (format version,
name, and sigining public key), group name, and a 32-byte salt. The mes-
sage types include JOIN and POST. A JOIN message includes the member in-
formation, the invite token, and a member signature that includes the group
identiﬁer, timestamp, member information, and the group invite. The invite
token is obtained using an additional private group sharing client between
the creator and the invitee, which (in a simpliﬁed view) incorporates the
invite timestamp, identiﬁers of the creator and the invitee, and the group
identiﬁer. A POST message includes the member information, an optional
parent message identiﬁer, the identiﬁer of the previous message, text, and a
signature additionally covering the group identiﬁer and timestamp.

The forum client is similar to the private group client. It only has one mes-
sage type, which is the same as the private group client except from not
including the message type and the previous message identiﬁer. The blog
client only allows the blog author to create posts or comments, but the blog
author may reblog posts or comments from other blogs, which are wrapped
in the author’s blog and should also be validated by subscribers.

10.3.1 Message duplication attack

The Bramble Synchronisation Protocol (BSP) synchronizes messages between
clients within the same group, where each message has a unique identiﬁer,
which is a labeled hash digest that depends on the message format ver-
sion, group identiﬁer, timestamp, and the message body (see Chapter 8).
BSP treats messages with the same identiﬁer as duplicates, which prevents
BSP clients from handling the same message multiple times. However, by

3https://code.briarproject.org/briar/briar/wikis/FAQ

45

10. Briar Functionalities

tweaking the message encoding, it is possible for a malicious member or
subscriber of a private group/forum/blog to duplicate messages from any
author in the BSP group as many times as the adversary desires, without
practical limit.

As mentioned in Section 2.4, it is easy to ﬁnd different Binary Data For-
mat (BDF) encodings that decode to the same data. Possible methods of
producing different BDF encodings include leveraging integer overﬂows,
increasing the length-of-length ﬁeld, and inserting unmappable bytes into
the UTF-8 encoding of strings (which is ignored by the decoder).

A malicious member could use these methods to alter the encoding of any
message to produce a message with the same content and a different mes-
sage body. By deﬁnition, the message identiﬁer will also change for the
modiﬁed message. As a result, the modiﬁed message would be perceived
as a valid new message and shared within the private group/forum/blog
along with the original message.

Take private groups as an example. The private group client produces a
message by ﬁrst computing the signature, and then encoding the message
body as a BDF list. We can obtain a new message with a different message
identiﬁer and a valid signature by setting the message type as a very large
number (e.g., 232 + 1), which is regarded as valid because of integer over-
ﬂow. We can also insert 0x80 arbitrarily into the encoded text, or use INT 16
instead of INT 8 to encode the author format version, so on and so forth.

We include example code snippets for modifying private group posts (List-
ing B.1), forum posts (Listing B.2), and blog posts (Listing B.3). They do not
cover all possible ways of duplicating messages.

A malicious insider can share the modiﬁed messages within the group. As
long as the original message is valid, the modiﬁed messages would be valid.
Members in the group will treat these two messages as different and display
both messages in the application. For this attack to work in private groups,
note that the private group client allows multiple messages with the same
previous message id.

This attack can be used to create disruption to private groups/forums/blogs
without exposing the identity of the culprit. Duplicate messages may also
genuinely confuse users that only synchronize messages periodically, or are
new to an existing private group/forum/blog.

Fixes with backward compatibility would be to compare the serialized mes-
sage with its canonical serialization, look for possible overﬂows, and throw
an exception for UTF-8 decoding errors. In the long run, it is probably a
better idea to compute the signature only after serialization.

46

10.3. Private groups, forums, and blogs

10.3.2 Notes

• Circular dependency. It might be tempting to create a circular structure
in the thread, such that the application would run out of stack memory
and crash when performing a depth-ﬁrst search in order to render the
threads. However, this is not possible because ﬁnding such a circle
would break the underlying hash function used to compute message
identiﬁers.

• Timestamp overﬂow. The private group client checks whether the times-
tamp is too far from the future, preventing a timestamp overﬂow pos-
sibly caused by a malicious member in the group, which would block
the victim from communicating with other parties in the group.

• Leaving a group. A group member may announce to its peers or the
creator that she is leaving the group, in which case the peers or the
creator would stop sharing messages to the member. However, there is
no real way of deﬁnitively leaving a group, as the leave message is not
broadcast and can be reverted, and the invite token can be replayed.

47

Chapter 11

Discussion

We can attribute the overall security of Briar to the following factors:

• Security and privacy by design. Briar is a good example of security and
privacy by design. Briar only implements a small subset of functions
that would typically be available to most modern messaging appli-
cations. This signiﬁcantly narrows Briar’s attack vector. For example,
Briar offers no security backup or account transfer as of today1 in order
to provide forward security, which is rather uncommon for messaging
applications. In contrast, security backup is a common source of vul-
nerabilities in other messaging applications (e.g., Matrix [2]). It should
be noted that the functionalities provided by Briar are sufﬁcient for
higher-risk users to perform basic activities.

• Good cryptography practices. The developers of Briar are evidently ex-
perienced with cryptography and peer-to-peer messaging. This can be
seen from their wise choice of cryptographic primitives, good domain
separations, and well-designed interaction and layering of a complex
set of protocols. The redundancy in Briar’s protocols weakens our
attacks, and the versioning system in Briar smooths security updates.

On the other hand, the issues we identiﬁed also share some common pitfalls:

• Insider attacks. Three of the four vulnerabilities we identiﬁed are mounted
by malicious insiders; that is, the attacker has to either be a contact of
the victim, or in the same group as the victim. These are practical
threats given the target group of Briar, but Briar seem to have paid less
attention to them.

• Input validation. The peer-to-peer nature of Briar puts a heavier burden
on Briar clients for input validation, from which we discovered two
vulnerabilities.

1https://code.briarproject.org/briar/briar/-/issues/887

49

11. Discussion

• Encoding. We identiﬁed an attack that originates from the encoding
ﬂexibility in BDF, and a potential issue that involves Base32 encoding.
It is not the ﬁrst time that Briar reported a bug related to its custom
encoding format.2 This may warn future developers against “rolling
your own encoding” in addition to “rolling your own crypto.”

• Usable security. From the usability perspective, Briar may need more
work to nudge users to improve their security, especially for users
that are not knowledgeable enough in security and privacy. For ex-
ample, the current password policy in Briar is based on the number of
unique characters in passwords, which accepts passwords with at least
6 unique characters, and ﬂags passwords with at least 9 unique char-
acters as “quite strong” (green bar). A look at the 10 most common
passwords in the infamous RockYou leak shows that 9 of them would
be accepted by Briar, and one ("123456789") is even labeled as quite
strong. While Briar has no central servers, ofﬂine password recovery is
still a tangible threat given the high risk of compelled access for Briar’s
target user groups.

2https://code.briarproject.org/briar/briar/-/issues/1277

50

Chapter 12

Conclusion

In this project, we examined Briar’s use of cryptography and analyzed the
security of protocols in Briar. First, we provided a detailed documentation
of Briar’s protocol stack, which may be useful for future security analyses
of Briar. Second, we gave a series of arguments in favor of Briar’s security;
the overall positive result partly supports Briar’s security claims and may
prompt more people to adopt Briar. Finally, we discovered several issues in
Briar’s protocol design and implementaion, and suggested possible ﬁxes.

We conclude that Briar’s use of cryptography is in general secure, and that
Briar is suitable for higher-risk individuals from the cryptographic point of
view. However, due to the author’s lack of experience and time, we would
still suggest another round of analysis on Briar’s use of cryptography.

Some directions for future work include 1) formally proving the security of
Briar’s cryptographic protocols, especially BQP, BHP, and BTP, 2) exploring
the possibility of cross-protocol interaction attacks, 3) investigating to what
extent Briar protects the privacy of its users, including the feasibility of traf-
ﬁc analysis and tracing, and 4) analyzing the security of Briar Mailbox.

51

Appendix A

Tamarin code

A.1 Tamarin code for BQP

Listing A.1: BQP.spthy

theory BQP
begin

builtins : diffie - hellman , hashing

functions : commit /1 , MAC /2

rule Init :

let epkA = ’g ’^~ eskA

epkB = ’g ’^~ eskB

in
[ Fr (~ eskA ) , Fr (~ eskB ) ]
-->
[ Alice_Init ( $A , ~ eskA , epkA , $B , commit ( epkB ) ) ,
Bob_Init ( $B , ~ eskB , epkB , $A , commit ( epkA ) ) ]

rule Alice_Sends_Pk :

[ Alice_Init ( $A , ~ eskA , epkA , $B , commB ) ]
-->
[ Out ( epkA ) ,

Alice_Awaits_Pk ( $A , ~ eskA , epkA , $B , commB ) ]

rule Bob_Derives_Key :

let commA = commit ( epkA )
raw = epkA ^~ eskB
s = h ( < ’ SHARED_SECRET ’ , raw , epkA , epkB >)
ck = MAC ( ’ CONFIRMATION_KEY ’ , s )
confa = MAC ( < ’ CONFIRMATION_MAC ’ , epkA , epkB > , ck )
mk = MAC ( ’ MASTER_KEY ’ , s )

in
[ Bob_Init ( $B , ~ eskB , epkB , $A , commA ) ,

In ( epkA ) ]

- -[ Neq ( raw , 1) , RunningR ( $B , $A , mk ) ] - >
[ Out ( epkB ) ,

B ob _Awaits_Conf ( $B , ~ eskB , epkB , $A , epkA , s , ck , mk , confa ) ]

rule A li ce_ Der ives _Ke y :

let commB = commit ( epkB )
raw = epkB ^~ eskA
s = h ( < ’ SHARED_SECRET ’ , raw , epkA , epkB >)
ck = MAC ( ’ CONFIRMATION_KEY ’ , s )
confa = MAC ( < ’ CONFIRMATION_MAC ’ , epkA , epkB > , ck )
mk = MAC ( ’ MASTER_KEY ’ , s )

in
[ A lic e_Awaits_Pk ( $A , ~ eskA , epkA , $B , commB ) ,

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45

53

A. Tamarin code

46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110

In ( epkB ) ]

- -[ Neq ( raw , 1) , RunningI ( $A , $B , mk ) ] - >
[ Out ( confa ) ,

Al ice _Aw ait s_Co nf ( $A , ~ eskA , epkA , $B , epkB , s , ck , mk ) ]

rule Bob _Re cei ves _Con f :

let confb = MAC ( < ’ CONFIRMATION_MAC ’ , epkB , epkA > , ck )
in
[ Bob_Awaits_Conf ( $B , ~ eskB , epkB , $A , epkA , s , ck , mk , confa ) ,

In ( confa ) ]

- -[ FinishedR ( $B ) ,

SecretR ( $A , $B , mk ) ,
CommitR ( $B , $A , mk )

] - >

[ Out ( confb ) ]

rule A l i c e _ R e ce i v e s _ C o n f :

let confb = MAC ( < ’ CONFIRMATION_MAC ’ , epkB , epkA > , ck )
in
[ Al ice _Aw aits _Co nf ( $A , ~ eskA , epkA , $B , epkB , s , ck , mk ) ,

In ( confb ) ]

- -[ FinishedI ( $A ) ,

SecretI ( $A , $B , mk ) ,
CommitI ( $A , $B , mk )

] - >

[]

restriction Inequality :

" All x # i . Neq (x , x ) @ # i == > F "

lemma executableI :
exists - trace " Ex # i A . FinishedI ( A ) @ i "

lemma executableR :
exists - trace " Ex # i B . FinishedR ( B ) @ i "

lemma key_secrecyI :
" All # i A B k .

( SecretI (A , B , k ) @ i ) == > not ( Ex # j . K ( k ) @ j ) "

lemma key_secrecyR :
" All # i A B k .

( SecretR (A , B , k ) @ i ) == > not ( Ex # j . K ( k ) @ j ) "

lemma agreementR :
" All # i A B k .

( CommitR (B , A , k ) @ i )
== > ( Ex # j . RunningI (A , B , k ) @ j

& j < i
& not ( Ex A2 B2 # i2 . CommitR ( B2 , A2 , k ) @i2

& not (# i2 = # i )
)

) "

lemma agreementI :
" All # i A B k .

( CommitI (A , B , k ) @ i )
== > ( Ex # j . RunningR (B , A , k ) @ j

& j < i
& not ( Ex A2 B2 # i2 . CommitI ( A2 , B2 , k ) @i2

& not (# i2 = # i )
)

) "

end

A.2 Tamarin code for BHP

Listing A.2: BHP.spthy

1
2

theory BHP
begin

54

A.2. Tamarin code for BHP

3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76

builtins : diffie - hellman , symmetric - encryption , hashing

functions : MAC /2

rule genkey :
let pkA = ’g ’^~ kA in

[ Fr (~ kA ) ]
-->
[ ! Key ( $A , ~ kA ) ,
! Pk ( $A , pkA ) ,
Out ( pkA ) ]

rule Alice_Sends_Pk :

let epkA = ’g ’^~ eskA
raw = hpkB ^~ hskA
hsk = h ( < ’ STATIC_MASTER_KEY ’ , raw , hpkA , hpkB >)

in
[ Fr (~ eskA ) ,

! Key ( $A , ~ hskA ) ,
! Pk ( $A , hpkA ) ,
! Pk ( $B , hpkB )

]
- -[ Neq ( raw , 1) ] - >
[ Out ( senc ( epkA , hsk ) ) ,

Alice_Awaits_Pk ( $A , ~ hskA , hpkA , ~ eskA , epkA , $B , hpkB , hsk ) ]

rule Bob_Responds_Pk :

let epkB = ’g ’^~ eskB
raw = hpkA ^~ hskB
hsk = h ( < ’ STATIC_MASTER_KEY ’ , raw , hpkA , hpkB >)
epkA = sdec ( CepkA , hsk )
raw1 = hpkA ^~ eskB
raw2 = epkA ^~ hskB
mk = h ( < ’ MASTER_KEY ’ , raw , raw1 , raw2 , hpkA , hpkB , epkA , epkB >)

in
[ Fr (~ eskB ) ,

! Key ( $B , ~ hskB ) ,
! Pk ( $A , hpkA ) ,
! Pk ( $B , hpkB ) ,
In ( CepkA )

]
- -[ Neq ( raw , 1) , Neq ( raw1 , 1) , Neq ( raw2 , 1) ,

RunningR ( $B , $A , mk ) ] - >

[ Out ( senc ( epkB , hsk ) ) ,

Bob_Awaits_Proof ( $B , ~ hskB , ~ eskB , epkB , $A , hpkA , epkA , hsk , mk ) ]

rule Ali ce_ Der ive s_K ey :

let epkB = sdec ( CepkB , hsk )

raw = hpkB ^~ hskA
raw1 = epkB ^~ hskA
raw2 = hpkB ^~ eskA
mk = h ( < ’ MASTER_KEY ’ , raw , raw1 , raw2 , hpkA , hpkB , epkA , epkB >)
proofA = MAC ( ’ ALICE_PROOF ’ , mk )

in
[ Alice_Awaits_Pk ( $A , ~ hskA , hpkA , ~ eskA , epkA , $B , hpkB , hsk ) ,

In ( CepkB )

]
- -[ Neq ( raw , 1) , Neq ( raw1 , 1) , Neq ( raw2 , 1) ,

RunningI ( $A , $B , mk ) ] - >

[ Out ( senc ( proofA , hsk ) ) ,

A l i c e_ Aw a it s _P ro o f ( $A , ~ hskA , hpkA , ~ eskA , epkA , $B , hpkB , epkB , hsk , mk ) ]

rule Bob _Sends_Proof :

let proofA = sdec ( CpA , hsk )

proofB = MAC ( ’ BOB_PROOF ’ , mk )

in
[ B o b_Awaits_Proof ( $B , ~ hskB , ~ eskB , epkB , $A , hpkA , epkA , hsk , mk ) ,

In ( CpA ) ]

-->
[ Out ( senc ( proofB , hsk ) ) ,

B o b _ Ve ri f ie s _P ro o f ( $B , ~ hskB , ~ eskB , epkB , $A , hpkA , epkA , hsk , mk , proofA ) ]

rule Bob_Finishes :

55

A. Tamarin code

[ B o b_ Ve r if i es _P r oo f ( $B , ~ hskB , ~ eskB , epkB , $A , hpkA , epkA , hsk , mk , proofA ) ]
- -[ Eq ( proofA , MAC ( ’ ALICE_PROOF ’ , mk ) ) ,

FinishedR ( $B ) ,
SecretR ( $A , $B , mk ) ,
CommitR ( $B , $A , mk )

] - >

[]

rule Alice_Finishes :

let proofB = sdec ( CpB , hsk ) in
[ A l ic e_ A wa i ts _P r oo f ( $A , ~ hskA , hpkA , ~ eskA , epkA , $B , hpkB , epkB , hsk , mk ) ,

In ( CpB ) ]

- -[ Eq ( proofB , MAC ( ’ BOB_PROOF ’ , mk ) ) ,

FinishedI ( $A ) ,
SecretI ( $A , $B , mk ) ,
CommitI ( $A , $B , mk )

] - >

[]

rule Compromise :
[ ! Key (A , ~ skA ) ]
- -[ Compromised ( A ) ] - >
[ Out (~ skA ) ]

restriction equality :
" All x y # i . Eq (x , y ) @i == > x = y "

restriction Inequality :

" All x # i . Neq (x , x ) @ # i == > F "

lemma executableI :
exists - trace " Ex # i A . FinishedI ( A ) @ i & not ( Ex # j B . Compromised ( B ) @j ) "

lemma executableR :
exists - trace " Ex # i B . FinishedR ( B ) @ i & not ( Ex # j B . Compromised ( B ) @j ) "

lemma key_secrecyI :
" All # i A B k .

( SecretI (A , B , k ) @ i &

not (( Ex # l . Compromised ( A ) @ l ) | ( Ex # m . Compromised ( B ) @ m ) ) )
== > not ( Ex # j . K ( k ) @ j ) "

lemma key_secrecyR :
" All # i A B k .

( SecretR (A , B , k ) @ i &

not (( Ex # l . Compromised ( A ) @ l ) | ( Ex # m . Compromised ( B ) @ m ) ) )
== > not ( Ex # j . K ( k ) @ j ) "

lemma agreementR :
" All # i A B k .

( CommitR ( B , A , k ) @ i &

not (( Ex # l . Compromised ( A ) @ l ) | ( Ex # m . Compromised ( B ) @ m ) ) )
== > ( Ex # j . RunningI (A , B , k ) @ j & j < i ) "

lemma agreementI :
" All # i A B k .

( CommitI ( A , B , k ) @ i &

not (( Ex # l . Compromised ( A ) @ l ) | ( Ex # m . Compromised ( B ) @ m ) ) )
== > ( Ex # j . RunningR (B , A , k ) @ j & j < i ) "

lemma injectiveR :
" All A B k # i .

( CommitR (B , A , k ) @i &
not (( Ex # l . Compromised ( A ) @ l ) | ( Ex # m . Compromised ( B ) @ m ) ) )
== > ( Ex # j . RunningI (A , B , k ) @j

& j < i
& not ( Ex A2 B2 # i2 . CommitR ( B2 , A2 , k ) @i2

& not (# i2 = # i ) ) ) "

lemma injectiveI :
" All A B k # i .

( CommitI (A , B , k ) @i &
not (( Ex # l . Compromised ( A ) @ l ) | ( Ex # m . Compromised ( B ) @ m ) ) )
== > ( Ex # j . RunningR (B , A , k ) @j

77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150

56

A.3. Tamarin code for Briar introduction

& j < i
& not ( Ex A2 B2 # i2 . CommitI ( A2 , B2 , k ) @i2

& not (# i2 = # i ) ) ) "

lemma secrecy_PFS_R :

" All A B k # i .

SecretR (A , B , k ) @i &

not (( Ex # l . ( Compromised ( A ) @ l & l < i ) ) | ( Ex # m . ( Compromised ( B ) @ m & m

< i ) ) )

== > not ( Ex # j . K ( k ) @j ) "

lemma secrecy_PFS_I :

" All A B k # i .

SecretI (A , B , k ) @i &

not (( Ex # l . ( Compromised ( A ) @ l & l < i ) ) | ( Ex # m . ( Compromised ( B ) @ m & m

< i ) ) )

== > not ( Ex # j . K ( k ) @j ) "

end

A.3 Tamarin code for Briar introduction

Listing A.3: introduction.spthy

// grossly simplified
theory BIC
begin

builtins : diffie - hellman , signing , hashing

functions :

MAC /2

rule genkey :

[ Fr (~ kA ) ]
-->
[ ! Key ( $A , ~ kA ) ,

! Pk ( $A , pk (~ kA ) ) ,
Out ( pk (~ kA ) ) ]

rule I n t r o d u c e r _ S e n d s _ R e q u e s t :

[ ! Pk ( $A , spkA ) ,

! Pk ( $B , spkB ) ]

-->
[ Out ( spkA ) , Out ( spkB ) ]

rule Alice_Accepts :

let epkA = ’g ’^~ eskA in
[ Fr (~ eskA ) ,
In ( spkB )
//! Pk ( $B , spkB )
]
-->
[ Out ( epkA ) ,

A l ic e_Awaits_Epk ( $A , ~ eskA , epkA , $B , spkB ) ]

rule Bob_Accepts :

let epkB = ’g ’^~ eskB in
[ Fr (~ eskB ) ,
In ( spkA )
//! Pk ( $A , spkA )

]
-->
[ Out ( epkB ) ,

Bob_Awaits_Epk ( $B , ~ eskB , epkB , $A , spkA ) ]

rule A l i c e _ A u t he n t i c a t e s :
let raw = epkB ^~ eskA

mk = h ( < ’ MASTER_KEY ’ , raw , epkA , epkB >)
ckA = MAC ( ’ ALICE_MAC_KEY ’ , mk )
ckB = MAC ( ’ BOB_MAC_KEY ’ , mk )
hA = MAC ( < ’ AUTH_MAC ’ , epkA , epkB > , ckA )

151
152
153
154
155
156
157
158

159
160
161
162
163
164

165
166
167

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48

57

A. Tamarin code

nA = MAC ( ’ AUTH_NONCE ’ , ckA )
sigA = sign ( < ’ AUTH_SIGN ’ , nA > , ~ sskA )

in
[ Alice_Awaits_Epk ( $A , ~ eskA , epkA , $B , spkB ) ,

! Key ( $A , ~ sskA ) ,
In ( epkB ) ]

- -[ Neq ( raw , 1) , RunningI ( pk (~ sskA ) , spkB , mk )

// RunningI ( $A , $B , mk )

] - >

[ Out ( < hA , sigA >) ,

Al ice _Aw ait s_Au th ( $A , ~ sskA , ~ eskA , epkA , $B , spkB , epkB , mk , ckA , ckB ) ]

rule Bob _Au the ntic ate s :
let raw = epkA ^~ eskB

mk = h ( < ’ MASTER_KEY ’ , raw , epkA , epkB >)
ckA = MAC ( ’ ALICE_MAC_KEY ’ , mk )
ckB = MAC ( ’ BOB_MAC_KEY ’ , mk )
hB = MAC ( < ’ AUTH_MAC ’ , epkA , epkB > , ckB )
nB = MAC ( ’ AUTH_NONCE ’ , ckB )
sigB = sign ( < ’ AUTH_SIGN ’ , nB > , ~ sskB )

in
[ Bob_Awaits_Epk ( $B , ~ eskB , epkB , $A , spkA ) ,

! Key ( $B , ~ sskB ) ,
In ( epkA ) ]

- -[ Neq ( raw , 1) , RunningR ( pk (~ sskB ) , spkA , mk )

// RunningR ( $B , $A , mk )

] - >

[ Out ( < hB , sigB >) ,

Bob_Awaits_Auth ( $B , ~ sskB , ~ eskB , epkB , $A , spkA , epkA , mk , ckA , ckB ) ]

rule Alice_Acks :

let nB = MAC ( ’ AUTH_NONCE ’ , ckB )

ackA = MAC ( ’ ACTIVATE_MAC ’ , ckA )

in
[ Al ice _Awa its _Au th ( $A , ~ sskA , ~ eskA , epkA , $B , spkB , epkB , mk , ckA , ckB ) ,

In ( < hB , sigB >) ]

- -[ Eq ( MAC ( < ’ AUTH_MAC ’ , epkA , epkB > , ckB ) , hB ) ,

Eq ( verify ( sigB , <’ AUTH_SIGN ’ , nB > , spkB ) , true ) ] - >

[ Out ( ackA ) ,

Alice_Awaits_Ack ( $A , ~ sskA , ~ eskA , epkA , $B , spkB , epkB , mk , ckA , ckB ) ]

rule Bob_Acks :

let nA = MAC ( ’ AUTH_NONCE ’ , ckA )

ackB = MAC ( ’ ACTIVATE_MAC ’ , ckB )

in
[ Bob_Awaits_Auth ( $B , ~ sskB , ~ eskB , epkB , $A , spkA , epkA , mk , ckA , ckB ) ,

In ( < hA , sigA >) ]

- -[ Eq ( MAC ( < ’ AUTH_MAC ’ , epkA , epkB > , ckA ) , hA ) ,

Eq ( verify ( sigA , <’ AUTH_SIGN ’ , nA > , spkA ) , true ) ] - >

[ Out ( ackB ) ,

Bob_Awaits_Ack ( $B , ~ sskB , ~ eskB , epkB , $A , spkA , epkA , mk , ckA , ckB ) ]

rule Alice_Finishes :

[ Alice_Awaits_Ack ( $A , ~ sskA , ~ eskA , epkA , $B , spkB , epkB , mk , ckA , ckB ) ,

In ( ackB ) ]

- -[ Eq ( MAC ( ’ ACTIVATE_MAC ’ , ckB ) , ackB ) ,

FinishedI ( pk (~ sskA ) ) , SecretI ( pk (~ sskA ) , spkB , mk ) , CommitI ( pk (~ sskA ) , spkB ,

mk )

// FinishedI ( $A ) , SecretI ( $A , $B , mk ) , CommitI ( $A , $B , mk )

] - >

[]

rule Bob_Finishes :

[ Bob_Awaits_Ack ( $B , ~ sskB , ~ eskB , epkB , $A , spkA , epkA , mk , ckA , ckB ) ,

In ( ackA ) ]

- -[ Eq ( MAC ( ’ ACTIVATE_MAC ’ , ckA ) , ackA ) ,

FinishedR ( pk (~ sskB ) ) , SecretR ( pk (~ sskB ) , spkA , mk ) , CommitR ( pk (~ sskB ) , spkA ,

mk )

// FinishedR ( $B ) , SecretR ( $A , $B , mk ) , CommitR ( $B , $A , mk )

] - >

[]

rule Compromise :
[ ! Key (A , ~ skA ) ]

49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105

106
107
108
109
110
111
112
113
114

115
116
117
118
119
120

58

A.3. Tamarin code for Briar introduction

121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183

184
185
186
187
188
189

190
191
192

- -[ Compromised ( pk (~ skA ) ) // Compromised ( A )

] - >

[ Out (~ skA ) ]

restriction equality :

" All x y # i . Eq (x , y ) @i == > x = y "

restriction Inequality :

" All x # i . Neq (x , x ) @ # i == > F "

lemma executableI :
exists - trace " Ex # i A . FinishedI ( A ) @ i & not ( Ex # j B . Compromised ( B ) @j ) "

lemma executableR :
exists - trace " Ex # i B . FinishedR ( B ) @ i & not ( Ex # j B . Compromised ( B ) @j ) "

lemma key_secrecyI :
" All # i A B k .

( SecretI (A , B , k ) @ i &

not (( Ex # l . Compromised ( A ) @ l ) | ( Ex # m . Compromised ( B ) @ m ) ) )
== > not ( Ex # j . K ( k ) @ j ) "

lemma key_secrecyR :
" All # i A B k .

( SecretR (A , B , k ) @ i &

not (( Ex # l . Compromised ( A ) @ l ) | ( Ex # m . Compromised ( B ) @ m ) ) )
== > not ( Ex # j . K ( k ) @ j ) "

lemma agreementR :
" All # i A B k .

( CommitR ( B , A , k ) @ i &

not (( Ex # l . Compromised ( A ) @ l ) | ( Ex # m . Compromised ( B ) @ m ) ) )
== > ( Ex # j . RunningI (A , B , k ) @ j & j < i ) "

lemma agreementI :
" All # i A B k .

( CommitI ( A , B , k ) @ i &

not (( Ex # l . Compromised ( A ) @ l ) | ( Ex # m . Compromised ( B ) @ m ) ) )
== > ( Ex # j . RunningR (B , A , k ) @ j & j < i ) "

lemma injectiveR :
" All A B k # i .

( CommitR (B , A , k ) @i &
not (( Ex # l . Compromised ( A ) @ l ) | ( Ex # m . Compromised ( B ) @ m ) ) )
== > ( Ex # j . RunningI (A , B , k ) @j

& j < i
& not ( Ex A2 B2 # i2 . CommitR ( B2 , A2 , k ) @i2

& not (# i2 = # i ) ) ) "

lemma injectiveI :
" All A B k # i .

( CommitI (A , B , k ) @i &
not (( Ex # l . Compromised ( A ) @ l ) | ( Ex # m . Compromised ( B ) @ m ) ) )
== > ( Ex # j . RunningR (B , A , k ) @j

& j < i
& not ( Ex A2 B2 # i2 . CommitI ( A2 , B2 , k ) @i2

& not (# i2 = # i ) ) ) "

lemma secrecy_PFS_R :

" All A B k # i .

SecretR (A , B , k ) @i &

not (( Ex # l . ( Compromised ( A ) @ l & l < i ) ) | ( Ex # m . ( Compromised ( B ) @ m & m

< i ) ) )

== > not ( Ex # j . K ( k ) @j ) "

lemma secrecy_PFS_I :

" All A B k # i .

SecretI (A , B , k ) @i &

not (( Ex # l . ( Compromised ( A ) @ l & l < i ) ) | ( Ex # m . ( Compromised ( B ) @ m & m

< i ) ) )

== > not ( Ex # j . K ( k ) @j ) "

end

59

Appendix B

Code examples for message
duplication

Listing B.1: Duplicating private group posts by representing the message type (POST, or 1) with
INT 16 instead of INT 8.

private Message dupGroupPost ( Message m ) throws FormatException {
BdfList body = clientHelper . toList ( m . getBody () ) ;

BdfList memberList = body . getList (1) ;
byte [] parentId = body . getOptionalRaw (2) ;
byte [] previousMessageId = body . getRaw (3) ;
String text = body . getString (4) ;
byte [] signature = body . getRaw (5) ;

BdfList newBody = BdfList . of (

2023 , // placeholder for INT_16
memberList ,
parentId ,
previousMessageId ,
text ,
signature

) ;

byte [] raw = clientHelper . toByteArray ( newBody ) ;
// LIST_START (0 th ) , INT_16 (1 st ) , value (2 nd -3 rd ) , ....
raw [2] = 0 x00 ;
raw [3] = 0 x01 ;
Message newMessage = clientHelper . createMessage ( m .

getGroupId () , m . getTimestamp () , raw ) ;

return newMessage ;

}

Listing B.2: Duplicating forum posts by appending 0x80 to the end of the UTF-8 encoded text.

private Message dupForumPost ( Message m , BdfList body ) throws

FormatException {

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

1

2

61

B. Code examples for message duplication

3

4

5

6

7

8

9

10

11

12

13

14

15

1

2

3

4

5

6

7

8

9

byte [] parent = body . getOptionalRaw (0) ;
BdfList authorList = body . getList (1) ;
String text = body . getString (2) ;
byte [] sig = body . getRaw (3) ;

BdfList newBody = BdfList . of ( parent , authorList , text + ’

a ’ , sig ) ;

byte [] raw = clientHelper . toByteArray ( newBody ) ;
// ... ’a ’, RAW_8 , RAW_LEN , sig , END
int offset = raw . length - sig . length - 4;
raw [ offset ] = ( byte ) 0 x80 ;
Message newMessage = clientHelper . createMessage ( m .

getGroupId () , m . getTimestamp () , raw ) ;

return newMessage ;

}

Listing B.3: Duplicating blog posts or comments by overﬂowing the message type ﬁeld.

private Message d u pBl ogPostOrComment ( Message m , BdfList body )

throws FormatException {

BdfList newBody = new BdfList ( body ) ;
int type = body . getLong (0) . intValue () ;
Long newType = 4294967296 L + type ;
newBody . remove (0) ;
newBody . add (0 , newType ) ;

byte [] raw = clientHelper . toByteArray ( newBody ) ;
Message newMessage = clientHelper . createMessage ( m .

getGroupId () , m . getTimestamp () , raw ) ;

10

11

}

return newMessage ;

62

Bibliography

[1] Martin R. Albrecht,

Jorge Blasco, Rikke Bjerg Jensen, and Lenka
Marekov´a. Mesh messaging in large-scale protests: Breaking Bridgefy.
In CT-RSA, volume 12704 of Lecture Notes in Computer Science, pages
375–398. Springer, 2021.

[2] Martin R Albrecht, Sof´ıa Celi, Benjamin Dowling, and Daniel Jones.
Practically-exploitable cryptographic vulnerabilities in Matrix. In 2023
IEEE Symposium on Security and Privacy (SP), pages 1419–1436. IEEE
Computer Society, 2022.

[3] Martin R. Albrecht, Raphael Eikenberg, and Kenneth G. Paterson.
Breaking Bridgefy, again: Adopting libsignal is not enough. In USENIX
Security Symposium, pages 269–286. USENIX Association, 2022.

[4] Cure53, M. Heiderich, A. Aranguren, A. Inf ¨uhr, F. F¨aßler, C. Kean, and
N. Kobeissi. Pentest-Report Briar Project App & Protocol 03.2017, March
2017. https://cure53.de/pentest-report_briar.pdf.

[5] Danny Dolev and Andrew Chi-Chih Yao. On the security of public key

protocols. IEEE Trans. Inf. Theory, 29(2):198–207, 1983.

[6] The Briar Team.

Binary Data Format,
//code.briarproject.org/briar/briar-spec/blob/master/BDF.md
(retrieved 05-03-2023).

version 1.

https:

[7] The Briar Team.

Bramble Handshake Protocol,

version

0.

https://code.briarproject.org/briar/briar-spec/blob/master/
protocols/BHP.md (retrieved 05-03-2023).

[8] The Briar Team.

Bramble QR Code Protocol, version 4.

https:

//code.briarproject.org/briar/briar-spec/-/blob/master/
protocols/BQP.md (retrieved 05-03-2023).

63

Bibliography

[9] The Briar Team.

Bramble Synchronisation Protocol,

version 0.

https://code.briarproject.org/briar/briar-spec/blob/master/
protocols/BSP.md (retrieved 05-03-2023).

[10] The Briar Team.

Bramble Transport Protocol, version 4.

https:

//code.briarproject.org/briar/briar-spec/blob/master/
protocols/BTP.md (retrieved 05-03-2023).

[11] The Briar Team. Briar Threat Model. https://code.briarproject.org/

briar/briar/-/wikis/threat-model (retrieved 05-03-2023).

[12] The Briar Team. Briar User Manual.

https://briarproject.org/

manual/ (retrieved 05-03-2023).

[13] The Briar Team. Briar Wiki. https://code.briarproject.org/briar/

briar/-/wikis/home (retrieved 05-03-2023).

[14] The Briar Team.

How it works.
how-it-works/ (retrieved 05-03-2023).

https://briarproject.org/

[15] The Briar Team. Introduction Client. https://code.briarproject.org/
briar/briar-spec/-/blob/master/clients/Introduction-Client.
md (retrieved 05-03-2023).

[16] The Briar Team.

A Quick Overview of

the Protocol Stack.

https://code.briarproject.org/briar/briar/-/wikis/
A-Quick-Overview-of-the-Protocol-Stack (retrieved 05-03-2023).

[17] The Briar Team.

Transport Key Agreement Client.

https:

//code.briarproject.org/briar/briar-spec/blob/master/
clients/Transport-Key-Agreement-Client.md
(retrieved
2023).

05-03-

[18] The Tamarin Team. Tamarin-Prover Manual. https://tamarin-prover.

github.io/manual/tex/tamarin-manual.pdf (retrieved 05-03-2023).

64



=== Content from briarproject.org_4d633c52_20250114_182022.html ===


[![Briar](/img/briar-logo-header.svg)](/)

* [News](/news/)
* [How it works](/how-it-works/)
* [About](/about/)
* [Get Involved](/get-involved/)
* [Download](/download-briar/)

![](/img/bars-solid.svg)
![](/img/xmark-solid.svg)

* [News](/news/)
* [How it works](/how-it-works/)
* [About](/about/)
* [Get Involved](/get-involved/)
* [Download](/download-briar/)

May 24, 2023

# Three security issues found and fixed

In February of this year, security researchers at
[ETH ZÃ¼rich](https://appliedcrypto.ethz.ch/) notified us that they had found
three security issues in the Briar app. Two of these issues were fixed in
version 1.4.22 of Briar, which was released in February. The third issue was
fixed in version 1.5.3, which is being released today. All users are
encouraged to upgrade to version 1.5.3 of the app as soon as possible.

We have not received any reports of these bugs being exploited in the wild,
and the third issue is not exploitable.

We would like to apologise for the design and implementation mistakes that led
to these issues, and to thank Yuanming Song and Prof. Kenny Paterson for
finding the issues and responsibly disclosing them to us.

We have requested an independent security audit of Briar’s protocol stack to
ensure that no other issues remain undiscovered.

For those who are interested in the details, a description of each issue is
given below. The researchers’ report can be found [here](https://ethz.ch/content/dam/ethz/special-interest/infk/inst-infsec/appliedcrypto/education/theses/report_YuanmingSong.pdf).

## Issue 1: Receiving invalid message would have caused app to exit

The first issue (fixed in Briar 1.4.22) would have allowed a malicious user to
prevent their contacts from using Briar by repeatedly sending them invalid
messages that would cause the app to exit.

Receiving a message longer than the maximum allowed length should have raised
an error that would cause the invalid message to be discarded. Instead, the
check raised a different type of error that would cause the app to exit.

There was no risk of memory corruption, as the length check took place in
memory-safe Java code. Invalid messages were not stored or forwarded to other
users.

## Issue 2: Message duplication in blogs, forums and private groups

The second issue (fixed in Briar 1.4.22) would have allowed a malicious user
to create duplicates of messages written by other users in blogs, forums and
private groups. The duplicates would have had the same content and timestamps
as the originals, but would have appeared alongside the originals as though
they were separate messages from the same authors.

To explain this issue we need to give some background information about the
structure of Briar messages.

Every message in Briar consists of a timestamp, a group identifier and a
message body. Each message has a unique identifier that is calculated by
hashing these fields.

Different features of the app use these fields in different ways. The blog,
forum and private group features make use of digital signatures: the body of
each message contains some content along with a digital signature by the
author of the content. The signature covers the content as well as the
timestamp, the group identifier and the author’s Briar identity.

When verifying the signature on a message, Briar deserialises the message body
to extract the content and signature, then serialises the content, timestamp,
group identifier and author’s Briar identity to recreate the exact information
that was originally signed. This ensures that none of these fields can be
altered without invalidating the signature.

The ETH ZÃ¼rich researchers discovered that this process of deserialising the
message body and then reserialising the content to verify the signature made
it possible to take a message signed by another user and produce a message
with a different body (and therefore a different unique identifier) that would
nevertheless be identical to the original after deserialisation and
reserialisation. Thus the signature from the original message would still be
valid, and there would appear to be two identical messages signed by the same
author.

It would not have been possible to alter the content, timestamp, group
identifier or Briar identity without invalidating the signature, but the
duplicate messages might have caused confusion.

This issue occurred because Briar did not check that the message body was
serialised in canonical form before deserialising it, so it was possible to
create multiple non-canonical representations of the same message body, which
would all be converted into the same canonical form after deserialisation and
reserialisation.

Fortunately, genuine messages in blogs, forums and private groups have always
been created in canonical form, so the issue was solved by rejecting any
messages that were not in canonical form.

## Issue 3: Poorly designed cryptographic handshake

The third issue (fixed in Briar 1.5.3) involved a poorly designed
cryptographic handshake. At first it appeared that design flaws in this
handshake could have allowed network traffic between Briar users to be
decrypted by an attacker who had successfully carried out a specific set of
other attacks against those users. Fortunately, we were able to confirm that
this was not possible thanks to an extra layer of cryptographic protection
provided by the Tor network. The issue was not exploitable and there was no
danger to users. Even so, Briar 1.5.3 replaces the insecure handshake with a
more secure version.

The handshake in question is part of the Bramble Handshake Protocol (BHP),
which is used when users add each other as contacts by exchanging Briar links.
The purpose of BHP is to derive a shared secret that is known to both users
but not to anyone else, include anyone who may be eavesdropping on the network
connection used for the handshake. The shared secret is ephemeral, meaning
that it should not be possible to recreate the shared secret using any
information that is retained by the users after the handshake.

BHP did not meet these design criteria. An adversary who was able to eavesdrop
on the connection that was used for the handshake, and was later able to
compromise both users’ Briar accounts, could have decrypted network traffic
between the users that was sent between the time of the handshake and the time
of the account compromises.

Fortunately, we were able to confirm that the eavesdropping part of the attack
was not achievable. The connections used for BHP handshakes are always made
via the Tor network, using version 3 of Tor’s hidden service protocol. Through
discussions with the developers of Tor we were able to confirm that this
protocol uses strong encryption that would have prevented an adversary from
eavesdropping on BHP handshakes. Without being able to eavesdrop, an adversary
could not later decrypt past network traffic even if both users’ accounts were
compromised.

The poor design of the BHP handshake was a serious mistake on our part.
Fortunately, thanks to the extra layer of protection provided by Tor, users
were not put at risk by this mistake.

Briar 1.5.3 replaces the insecure handshake with a more secure version, and we
have requested an independent security audit of the whole protocol stack to
ensure that no other mistakes of this kind were made.

## About Briar

Briar is a messaging app designed for activists, journalists, and anyone else
who needs a safe, easy and robust way to communicate. Unlike traditional
messaging tools such as email, Twitter or Telegram, Briar doesn’t rely on a
central server - messages are synchronized directly between the users'
devices. If the internet’s down, Briar can sync via Bluetooth or Wi-Fi,
keeping the information flowing in a crisis. If the internet’s up, Briar can
sync via the Tor network, protecting users and their relationships from
surveillance.

Briar has received funding from
the [Small Media Foundation](https://smallmedia.org.uk/),
the [Open Internet Tools Project](https://web.archive.org/web/20160413063937/https%3A//www.openitp.org/),
[Access Now](https://accessnow.org/),
the [Open Technology Fund](https://www.opentech.fund/),
the [Prototype Fund](https://prototypefund.de/),
[Internews](https://www.internews.org/),
the [NLnet Foundation](https://nlnet.nl/),
the [Next Generation Internet](https://ngi.eu) programme,
the [ISC Project](https://www.counterpart.org/our-work/the-isc-project/)
and [eQualit.ie](https://equalit.ie/).

### Contact

Torsten Grote <torsten@briarproject.org>
[[PGP key](https://grobox.de/gpg/0x74DCA8A36C52F833.asc)]

Michael Rogers <contact@briarproject.org>
[[PGP key](/keys/contact.asc)]

Twitter: [@BriarApp](https://twitter.com/BriarApp)

Mastodon: [@Briar](https://fosstodon.org/%40briar)

[#### â Previous](/news/2023-briar-mailbox-released/)
[#### Next â](/news/2023-simulating-internet-shutdowns/)

#### Read also

[- Briar Desktop 0.6.0-beta released - blogs](/news/2023-briar-desktop-0.6.0-released/)
[- Briar Desktop 0.5.0-beta released - macOS support, private groups and Briar Mailbox](/news/2023-briar-desktop-0.5.0-released/)
[- Briar Mailbox released to improve connectivity](/news/2023-briar-mailbox-released/)
[- Three security issues found and fixed](/news/2023-three-security-issues-found-and-fixed/)
[- Researching Android's behavior during Internet shutdowns](/news/2023-simulating-internet-shutdowns/)
[- Briar Desktop 0.4.0-beta released - Windows support and forums](/news/2023-briar-desktop-0.4.0-released/)
[- Briar Desktop got another round of funding](/news/2022-briar-desktop-nlnet-funding/)
[- Briar is available on Google Play again](/news/2022-briar-removed-from-google-play/)

![Briar Logo Gray](/img/briar-gray.svg)
[Subscribe to updates â](https://sourceforge.net/projects/briar/lists/briar-announce)

* [Copyright](/copyright)
* [Privacy](/privacy-policy)
* [Governance](/governance)
* [Code of Conduct](/code-of-conduct)
* [Press](/press)
* [Jobs](/hiring)

[![Donate Here](/img/liberapay.svg)](https://liberapay.com/Briar/donate)

Bitcoin and BCH: 1NZCKkUCtJV2U2Y9hDb9uq8S7ksFCFGR6K


