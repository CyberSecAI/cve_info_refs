```text
### Relevant Content:
The provided content relates to CVE-2016-1744.

**Root cause of vulnerability:** Incorrect locking mechanisms in the Intel GPU driver when handling user memory mappings. Specifically, the `unmap_user_memory` methods in `IGAccelGLContext` and `IGAccelCLContext` call `contains`, `get`, and `remove` on a hashmap before taking the context's IOLock.

**Weaknesses/vulnerabilities present:**
  - **Race Condition:** Two threads can race to unmap the same user pointer.
  - **Double Free:** Two threads in the `::remove` method can concurrently call `IOFree` on the same hash bucket list entry, leading to a double free.
  - **Use-After-Free:** After the call to `::remove`, both threads may still hold a pointer to the same `IGAccelMemoryMap`. The first thread may call `::release`, freeing the object, and the second thread will use the freed object before calling `::release` again.
  - **Lack of Thread Safety:** Methods accessing the hashmap are not thread safe.

**Impact of exploitation:**
  - Denial of service (DoS) via double free or use-after-free conditions leading to a kernel panic.
  - Possibility of arbitrary code execution (indirectly implied due to the memory corruption).

**Attack vectors:**
  - User-space application (including sandboxed processes like Safari renderer or Chrome GPU process) can trigger the vulnerability.
  - The exploit requires the use of the `IOAccelerator` service and its client to map and unmap memory.

**Required attacker capabilities/position:**
  - Ability to execute code on the target system.
  - Access to the `IOAccelerator` service through a user client connection.
  - Ability to create threads and interact with IOKit functionalities.
```