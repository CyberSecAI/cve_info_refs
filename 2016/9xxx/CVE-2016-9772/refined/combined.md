=== Content from www.openafs.org_d6602254_20250126_032637.html ===
diff --git a/src/afs/afs\_buffer.c b/src/afs/afs\_buffer.c
index 7d856c2..83a30fc 100644
--- a/src/afs/afs\_buffer.c
+++ b/src/afs/afs\_buffer.c
@@ -368,6 +368,8 @@ afs\_newslot(struct dcache \*adc, afs\_int32 apage, struct buffer \*lp)
AFS\_STATS(afs\_stats\_cmperf.bufFlushDirty++);
}
+ /\* Zero out the data so we don't leak something we shouldn't. \*/
+ memset(lp->data, 0, AFS\_BUFFER\_PAGESIZE);
/\* Now fill in the header. \*/
lp->fid = adc->index;
afs\_copy\_inode(&lp->inode, &adc->f.inode);
diff --git a/src/bozo/bos.c b/src/bozo/bos.c
index b65961d..8d0cb68 100644
--- a/src/bozo/bos.c
+++ b/src/bozo/bos.c
@@ -1562,9 +1562,18 @@ SalvageCmd(struct cmd\_syndesc \*as, void \*arock)
for (i = MRAFS\_OFFSET; i < ADDPARMOFFSET; i++) {
if (as->parms[i].items) {
- printf(" %s only possible for MR-AFS fileserver.\n",
- as->parms[i].name);
- stop = 1;
+ if (i == MRAFS\_OFFSET + 5) { /\* -salvagedirs \*/
+ if (as->parms[4].items) { /\* -all \*/
+ mrafsParm.Optsalvagedirs = 1; /\* Let this one slide. \*/
+ } else {
+ printf(" -salvagedirs only possible with -all.\n");
+ stop = 1;
+ }
+ } else {
+ printf(" %s only possible for MR-AFS fileserver.\n",
+ as->parms[i].name);
+ stop = 1;
+ }
}
}
if (stop)
diff --git a/src/dir/buffer.c b/src/dir/buffer.c
index 3379159..e4df861 100644
--- a/src/dir/buffer.c
+++ b/src/dir/buffer.c
@@ -11,6 +11,7 @@
#include
+#include
#include
#include
@@ -449,7 +450,9 @@ DNew(afs\_int32 \*fid, int page)
}
ObtainWriteLock(&tb->lock);
tb->lockers++;
+ memset(tb->data, 0, BUFFER\_PAGE\_SIZE); /\* don't leak other people's dirs \*/
ReleaseWriteLock(&afs\_bufferLock);
ReleaseWriteLock(&tb->lock);
+
return tb->data;
}
diff --git a/src/dir/dir.c b/src/dir/dir.c
index 51a78eb..1b8ec5c 100644
--- a/src/dir/dir.c
+++ b/src/dir/dir.c
@@ -206,7 +206,9 @@ Delete(void \*dir, char \*entry)
DRelease(previtem, 1);
index = DVOffset(firstitem) / 32;
nitems = NameBlobs(firstitem->name);
- DRelease(firstitem, 0);
+ /\* Clear entire DirEntry and any DirXEntry extensions \*/
+ memset(firstitem, 0, nitems \* sizeof(\*firstitem));
+ DRelease(firstitem, 1);
FreeBlobs(dir, index, nitems);
return 0;
}
diff --git a/src/vol/salvaged.c b/src/vol/salvaged.c
index cd33dab..014fcd3 100644
--- a/src/vol/salvaged.c
+++ b/src/vol/salvaged.c
@@ -206,6 +206,8 @@ handleit(struct cmd\_syndesc \*as, void \*arock)
OKToZap = 1;
if (as->parms[6].items) /\* -rootinodes \*/
ShowRootFiles = 1;
+ if (as->parms[7].items) /\* -salvagedirs \*/
+ RebuildDirs = 1;
if (as->parms[8].items) /\* -ForceReads \*/
forceR = 1;
if ((ti = as->parms[9].items)) { /\* -Parallel # \*/


=== Content from www.openwall.com_5a3cb338_20250124_205116.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Follow @Openwall on Twitter for new release announcements and other news](https://twitter.com/openwall) | | --- | |
| --- | --- |

[[<prev]](8) [[next>]](10) [[<thread-prev]](../../../2016/12/01/12) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <9d50e9bb03ad40c1aa9547b96436ce27@imshyb02.MITRE.ORG>
Date: Fri, 2 Dec 2016 13:04:21 -0500
From: <cve-assign@...re.org>
To: <carnil@...ian.org>
CC: <cve-assign@...re.org>, <oss-security@...ts.openwall.com>
Subject: Re: CVE Request: OpenAFS: directory information leaks (OPENAFS-SA-2016-003)

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

> <https://www.openafs.org/pages/security/OPENAFS-SA-2016-003.txt>
> <https://www.openafs.org/pages/security/openafs-sa-2016-003.patch>
> <https://www.openafs.org/pages/security/openafs-sa-2016-003-master.patch>

Use CVE-2016-9772.

(There may have been a reason to have multiple CVE IDs; however, we
were unable to determine a multiple ID mapping in a reasonable amount
of time. We will be staying with the single CVE ID.)

- --
CVE Assignment Team
M/S M300, 202 Burlington Road, Bedford, MA 01730 USA
[ A PGP key is available for encrypted communications at
  <http://cve.mitre.org/cve/request_id.html> ]
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQIcBAEBCAAGBQJYQbY0AAoJEHb/MwWLVhi2rCYP/R06PGsESKbHs4M06OIodwOn
OQpxBbMkwNUzXj//H6VZT67nwKG2AvOracpXA4ZBn7T7CqfCEc0sVFZFqztAz1NF
racpIH5B01hRSXkz60wVbyUuAsoz4+lhf1+PpVg9y715nPDXwE52tD6DRnOCX4dl
GK6gzoP1ALPXZMYjpMEjfhI/VsmLVOrKj5muLEdnidg2eRo82E0uEA4i35LcQsIk
uKVwTcx4ExTrZg1BaeD3988A7nqX8dU+VBNEr9GW7FKnYwULYg8Fy4Df7M4FOJxH
zQ+4FG54WbN6cziWEZ95r6yQMK9FhgLAsLZ/QkdrFtCDhple3mmwKCoPHJuo7yEC
V2qPicsHeXamira2k6YOuUm0BQhQIQGDt6q92XyvEEJTJgjjT5Nrlk8Ynd27hv3e
8INrtJU548dZ7rV9epvhAjO90AVk6QxZ1wyXgLe/9MKRRglkxeFOXrKibvHzGamX
PkXRh+s1kjrfwG7Il0JxXyRI9Mr+BLKU9406qZoni8ZW2Li2nvAtk8vyKl+zaorL
jYvMLtyv+65Q9lcFFrEVT4HcSz5PcRNbZUpYvffj8XAbt/EbH+GtihI3ITAp3U6w
NTVr60XmYfd0LktB/K08j3E8hFWQokqd16nBM6xwepSTYDQyQQtPV6/g52bNXv7Q
LkhL31PKC9peRd39a3Ve
=j/50
-----END PGP SIGNATURE-----

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from www.openafs.org_fa1b69c5_20250124_205117.html ===
OpenAFS Security Advisory 2016-003
Topic: directory information leakage
Issued: 30 November, 2016
Affected: OpenAFS client versions 1.0 through 1.6.19
OpenAFS servers versions 1.0 through 1.6.19
The contents of OpenAFS directories may be leaked in client cache partitions,
in fileserver vice partitions, and on the wire for certain RPCs.
SUMMARY
=======
Due to incomplete initialization or clearing of reused memory, OpenAFS
directory objects are likely to contain "dead" directory entry information.
This extraneous information is not active - that is, it is logically invisible
to the fileserver and client. However, the leaked information is physically
visible on the fileserver vice partition, on the wire in FetchData replies and
other RPCs, and on the client cache partition. This constitutes a leak of
directory information.
CHARACTERIZATION
================
There are three different kinds of "dead" residual directory entry leaks, each
with a different cause:
1. There may be partial name data after the null terminator in a live directory
entry. This happens when a previously used directory entry becomes free, then
is reused for a directory entry with a shorter name.
2. "Dead" directory entries are left uncleared after an object is deleted or
renamed.
3. Residual directory entries may be inadvertently picked up when a new
directory is created or an existing directory is extended by a 2kiBi page.
This happens because the fileserver shares a buffer pool for directories of all
AFS users, but does not clear each buffer upon reuse. This is the most severe
problem because the leaked information may be from other directories or volumes
for which the AFS user is not authorized.
IMPACT
======
This is primarily a client and fileserver issue. However, directory
information is also manipulated or transmitted by volume operations (e.g.,
dump, restore, release) and by salvage operations. The fixes included in this
advisory address all known issues with directory information leaks.
The leaked information may only be viewed via access to at least one of the
following:
- unencrypted OpenAFS wire traffic
- a fileserver vice partition
- a cache manager cache partition
Any AFS user authorized to read directories may passively exploit this leak by
capturing wire traffic or examining his local cache as he/she performs
authorized reads on existing directories. Any leaked data will be for other
directories the fileserver had in the buffer pool at the time the authorized
directories were created or extended.
Any AFS user authorized to write a new directory may actively exploit this leak
by creating a new directory, flushing cache, then re-reading the newly created
directory. Any leaked data will be for other directories the fileserver had in
the buffer pool within the last few seconds. In this way an authorized user may
sample current fileserver directory buffer contents for as long as he/she
desires, without being detected.
Directories already containing leaked data may themselves be leaked, leading to
multiple layers of leaked data propagating with every new or extended
directory. The names of files and directories are the most obvious source of
information in this leak, but the FID vnode and uniqueid are leaked as well.
Careful examination of the sequences of leaked vnode numbers and uniqueids may
allow an attacker to:
- Discern each layer of old directories by observing breaks in consecutive runs
of vnode and/or uniqueid numbers.
- Infer which objects may reside on the same volume.
- Discover the order in which objects were created (vnode) or modified
(uniqueid).
- Know whether an object is a file (even vnode) or a directory (odd vnode).
AFFECTED SOFTWARE
=================
All releases of OpenAFS prior to 1.6.19 are affected.
FIXES
=====
The OpenAFS project recommends that adminstrators upgrade all fileservers and
cache managers to OpenAFS 1.6.20 (Unix). Additionally, patch files are
provided for the master and 1.6.x branches. This will prevent new leaks from
occurring.
We further recommend that adminstrators salvage all volumes with the
-salvagedirs option, in order to remove existing leaks.
This announcement and code patches related to it may be found on the
OpenAFS security advisory page at:
http://www.openafs.org/security/
The main OpenAFS web page is at:
http://www.openafs.org/
DETAILS
=======
The fixes ensure that both client and fileserver clear directory entries upon
deletion, and that the fileserver clears internal directory buffers before
reuse. In addition, fixes are included to allow administrators to remove
existing leaks by salvaging volumes and partitions with the -salvagedirs option,
ACKNOWLEGEMENTS
===============
This issue was reported by Mark Vitale.


=== Content from www.openafs.org_acf37d7c_20250126_032637.html ===
diff --git a/src/afs/afs\_buffer.c b/src/afs/afs\_buffer.c
index 4399473..2220ae3 100644
--- a/src/afs/afs\_buffer.c
+++ b/src/afs/afs\_buffer.c
@@ -379,6 +379,8 @@ afs\_newslot(struct dcache \*adc, afs\_int32 apage, struct buffer \*lp)
AFS\_STATS(afs\_stats\_cmperf.bufFlushDirty++);
}
+ /\* Zero out the data so we don't leak something we shouldn't. \*/
+ memset(lp->data, 0, AFS\_BUFFER\_PAGESIZE);
/\* Now fill in the header. \*/
lp->fid = adc->index;
afs\_copy\_inode(&lp->inode, &adc->f.inode);
diff --git a/src/bozo/bos.c b/src/bozo/bos.c
index 54935a2..0e2e3f4 100644
--- a/src/bozo/bos.c
+++ b/src/bozo/bos.c
@@ -41,7 +41,7 @@ static int DoStat(char \*aname, struct rx\_connection \*aconn,
#include "bosprototypes.h"
/\* command offsets for bos salvage command \*/
-#define ADDPARMOFFSET 10
+#define ADDPARMOFFSET 11
/\* dummy routine for the audit work. It should do nothing since audits \*/
/\* occur at the server level and bos is not a server. \*/
@@ -1039,7 +1039,7 @@ StopServer(struct cmd\_syndesc \*as, void \*arock)
static afs\_int32
DoSalvage(struct rx\_connection \* aconn, char \* aparm1, char \* aparm2,
char \* aoutName, afs\_int32 showlog, char \* parallel,
- char \* atmpDir, char \* orphans, int dafs)
+ char \* atmpDir, char \* orphans, int dafs, int dodirs)
{
afs\_int32 code;
char \*parms[6];
@@ -1170,6 +1170,14 @@ DoSalvage(struct rx\_connection \* aconn, char \* aparm1, char \* aparm2,
strcat(tbuffer, " -orphans ");
strcat(tbuffer, orphans);
}
+ /\* add the salvagedirs option if given \*/
+ if (dodirs) {
+ if (strlen(tbuffer) + 14 > BOZO\_BSSIZE) {
+ fprintf(stderr, "bos: command line too big\n");
+ return (E2BIG);
+ }
+ strcat(tbuffer, " -salvagedirs");
+ }
}
parms[0] = tbuffer;
@@ -1307,6 +1315,7 @@ SalvageCmd(struct cmd\_syndesc \*as, void \*arock)
afs\_int32 newID;
extern struct ubik\_client \*cstruct;
afs\_int32 curGoal, showlog = 0, dafs = 0;
+ int dodirs = 0;
char \*parallel;
char \*tmpDir;
char \*orphans;
@@ -1371,6 +1380,15 @@ SalvageCmd(struct cmd\_syndesc \*as, void \*arock)
}
}
+ if (as->parms[10].items) { /\* -salvagedirs \*/
+ if (as->parms[4].items) { /\* -all \*/
+ dodirs = 1;
+ } else {
+ fprintf(stderr, " -salvagedirs only possible with -all.\n");
+ return EINVAL;
+ }
+ }
+
if (as->parms[4].items) {
/\* salvage whole enchilada \*/
curGoal = GetServerGoal(tconn, serviceName);
@@ -1389,7 +1407,7 @@ SalvageCmd(struct cmd\_syndesc \*as, void \*arock)
/\* now do the salvage operation \*/
printf("Starting salvage.\n");
rc = DoSalvage(tconn, NULL, NULL, outName, showlog, parallel, tmpDir,
- orphans, dafs);
+ orphans, dafs, dodirs);
if (curGoal == BSTAT\_NORMAL) {
printf("bos: restarting %s.\n", serviceName);
code = BOZO\_SetTStatus(tconn, serviceName, BSTAT\_NORMAL);
@@ -1431,7 +1449,7 @@ SalvageCmd(struct cmd\_syndesc \*as, void \*arock)
/\* now do the salvage operation \*/
printf("Starting salvage.\n");
rc = DoSalvage(tconn, as->parms[1].items->data, NULL, outName,
- showlog, parallel, tmpDir, orphans, dafs);
+ showlog, parallel, tmpDir, orphans, dafs, 0);
if (curGoal == BSTAT\_NORMAL) {
printf("bos: restarting '%s'.\n", serviceName);
code = BOZO\_SetTStatus(tconn, serviceName, BSTAT\_NORMAL);
@@ -1490,7 +1508,7 @@ SalvageCmd(struct cmd\_syndesc \*as, void \*arock)
}
printf("Starting salvage.\n");
rc = DoSalvage(tconn, as->parms[1].items->data, tname, outName,
- showlog, parallel, tmpDir, orphans, dafs);
+ showlog, parallel, tmpDir, orphans, dafs, 0);
if (rc)
return rc;
}
@@ -1918,6 +1936,8 @@ main(int argc, char \*\*argv)
"ignore | remove | attach");
cmd\_AddParm(ts, "-forceDAFS", CMD\_FLAG, CMD\_OPTIONAL,
"(DAFS) force salvage of demand attach fileserver");
+ cmd\_AddParm(ts, "-salvagedirs", CMD\_FLAG, CMD\_OPTIONAL,
+ "Force rebuild/salvage of all directories");
add\_std\_args(ts);
ts = cmd\_CreateSyntax("getrestricted", GetRestrict, NULL, 0,
diff --git a/src/dir/buffer.c b/src/dir/buffer.c
index 889f07e..1a8da8f 100644
--- a/src/dir/buffer.c
+++ b/src/dir/buffer.c
@@ -313,6 +313,7 @@ newslot(dir\_file\_t dir, afs\_int32 apage, struct buffer \*lp)
/\* Now fill in the header. \*/
FidZap(bufferDir(lp));
FidCpy(bufferDir(lp), dir); /\* set this \*/
+ memset(lp->data, 0, BUFFER\_PAGE\_SIZE); /\* Don't leak stale data. \*/
lp->page = apage;
lp->accesstime = ++timecounter;
diff --git a/src/dir/dir.c b/src/dir/dir.c
index f930adc..6db96b2 100644
--- a/src/dir/dir.c
+++ b/src/dir/dir.c
@@ -191,7 +191,9 @@ afs\_dir\_Delete(dir\_file\_t dir, char \*entry)
DRelease(&prevbuf, 1);
index = DVOffset(&entrybuf) / 32;
nitems = afs\_dir\_NameBlobs(firstitem->name);
- DRelease(&entrybuf, 0);
+ /\* Clear entire DirEntry and any DirXEntry extensions \*/
+ memset(firstitem, 0, nitems \* sizeof(\*firstitem));
+ DRelease(&entrybuf, 1);
FreeBlobs(dir, index, nitems);
return 0;
}
diff --git a/src/vol/salvaged.c b/src/vol/salvaged.c
index 753fc18..23239d7 100644
--- a/src/vol/salvaged.c
+++ b/src/vol/salvaged.c
@@ -212,6 +212,7 @@ handleit(struct cmd\_syndesc \*opts, void \*arock)
cmd\_OptionAsFlag(opts, OPT\_inodes, &ListInodeOption);
cmd\_OptionAsFlag(opts, OPT\_oktozap, &OKToZap);
cmd\_OptionAsFlag(opts, OPT\_rootinodes, &ShowRootFiles);
+ cmd\_OptionAsFlag(opts, OPT\_salvagedirs, &RebuildDirs);
cmd\_OptionAsFlag(opts, OPT\_blockreads, &forceR);
if (cmd\_OptionAsString(opts, OPT\_parallel, &optstring) == 0) {
if (strncmp(optstring, "all", 3) == 0) {

