=== Content from tools.ietf.org_a80eb027_20250126_054631.html ===


* Light
* Dark
* Auto

[RFC 4253

Proposed Standard](/doc/rfc4253/)

|  | Title |  | The Secure Shell (SSH) Transport Layer Protocol |
| --- | --- | --- | --- |
| Document | Document type |  | RFC - Proposed Standard  January 2006  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=4253 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") [IPR](/ipr/search/?submit=draft&id=rfc4253 "Click to view IPR declarations.") Updated by [RFC 8268](/doc/html/rfc8268 "More Modular Exponentiation (MODP) Diffie-Hellman (DH) Key Exchange (KEX) Groups for Secure Shell (SSH)"), [RFC 8308](/doc/html/rfc8308 "Extension Negotiation in the Secure Shell (SSH) Protocol"), [RFC 8332](/doc/html/rfc8332 "Use of RSA Keys with SHA-256 and SHA-512 in the Secure Shell (SSH) Protocol"), [RFC 8709](/doc/html/rfc8709 "Ed25519 and Ed448 Public Key Algorithms for the Secure Shell (SSH) Protocol"), [RFC 8758](/doc/html/rfc8758 "Deprecating RC4 in Secure Shell (SSH)"), [RFC 9142](/doc/html/rfc9142 "Key Exchange (KEX) Method Updates and Recommendations for Secure Shell (SSH)"), [RFC 6668](/doc/html/rfc6668 "SHA-2 Data Integrity Verification for the Secure Shell (SSH) Transport Layer Protocol") Was [draft-ietf-secsh-transport](/doc/draft-ietf-secsh-transport/24/) ([secsh WG](/wg/secsh/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [24](/doc/html/draft-ietf-secsh-transport-24) * [RFC 4253](/doc/html/rfc4253) |
|  | Compare versions |  | RFC 4253  draft-ietf-secsh-transport-24  draft-ietf-secsh-transport-23  draft-ietf-secsh-transport-22  draft-ietf-secsh-transport-21  draft-ietf-secsh-transport-20  draft-ietf-secsh-transport-19  draft-ietf-secsh-transport-18  draft-ietf-secsh-transport-17  draft-ietf-secsh-transport-16  draft-ietf-secsh-transport-15  draft-ietf-secsh-transport-14  draft-ietf-secsh-transport-13  draft-ietf-secsh-transport-12  draft-ietf-secsh-transport-11  draft-ietf-secsh-transport-10  draft-ietf-secsh-transport-09  draft-ietf-secsh-transport-08  draft-ietf-secsh-transport-07  draft-ietf-secsh-transport-06  draft-ietf-secsh-transport-05  draft-ietf-secsh-transport-04  draft-ietf-secsh-transport-03  draft-ietf-secsh-transport-02  draft-ietf-secsh-transport-01  draft-ietf-secsh-transport-00   RFC 4253  draft-ietf-secsh-transport-24  draft-ietf-secsh-transport-23  draft-ietf-secsh-transport-22  draft-ietf-secsh-transport-21  draft-ietf-secsh-transport-20  draft-ietf-secsh-transport-19  draft-ietf-secsh-transport-18  draft-ietf-secsh-transport-17  draft-ietf-secsh-transport-16  draft-ietf-secsh-transport-15  draft-ietf-secsh-transport-14  draft-ietf-secsh-transport-13  draft-ietf-secsh-transport-12  draft-ietf-secsh-transport-11  draft-ietf-secsh-transport-10  draft-ietf-secsh-transport-09  draft-ietf-secsh-transport-08  draft-ietf-secsh-transport-07  draft-ietf-secsh-transport-06  draft-ietf-secsh-transport-05  draft-ietf-secsh-transport-04  draft-ietf-secsh-transport-03  draft-ietf-secsh-transport-02  draft-ietf-secsh-transport-01  draft-ietf-secsh-transport-00   Side-by-side  Inline |
|  | Authors |  | [Chris M. Lonvick](/person/lonvick.ietf%40gmail.com "Datatracker profile of Chris M. Lonvick") , [Tatu Ylonen](/person/ylo%40ssh.com "Datatracker profile of Tatu Ylonen")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc4253.txt) [html](https://www.rfc-editor.org/rfc/rfc4253.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc4253.txt.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc4253.html) [bibtex](/doc/rfc4253/bibtex/) |
|  | Additional resources |  | Mailing list discussion |
|  |  |  | [Report a bug](https://github.com/ietf-tools/datatracker/issues/new/choose) |

```
Network Working Group                                          T. Ylonen
Request for Comments: 4253              SSH Communications Security Corp
Category: Standards Track                                C. Lonvick, Ed.
                                                     Cisco Systems, Inc.
                                                            January 2006

            The Secure Shell (SSH) Transport Layer Protocol

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2006).

Abstract

   The Secure Shell (SSH) is a protocol for secure remote login and
   other secure network services over an insecure network.

   This document describes the SSH transport layer protocol, which
   typically runs on top of TCP/IP.  The protocol can be used as a basis
   for a number of secure network services.  It provides strong
   encryption, server authentication, and integrity protection.  It may
   also provide compression.

   Key exchange method, public key algorithm, symmetric encryption
   algorithm, message authentication algorithm, and hash algorithm are
   all negotiated.

   This document also describes the Diffie-Hellman key exchange method
   and the minimal set of algorithms that are needed to implement the
   SSH transport layer protocol.

Ylonen &  Lonvick           Standards Track                     [Page 1]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

Table of Contents

   [1](#section-1). Introduction ....................................................[3](#page-3)
   [2](#section-2). Contributors ....................................................[3](#page-3)
   [3](#section-3). Conventions Used in This Document ...............................[3](#page-3)
   [4](#section-4). Connection Setup ................................................[4](#page-4)
      [4.1](#section-4.1). Use over TCP/IP ............................................[4](#page-4)
      [4.2](#section-4.2). Protocol Version Exchange ..................................[4](#page-4)
   [5](#section-5). Compatibility With Old SSH Versions .............................[5](#page-5)
      [5.1](#section-5.1). Old Client, New Server .....................................[6](#page-6)
      [5.2](#section-5.2). New Client, Old Server .....................................[6](#page-6)
      [5.3](#section-5.3). Packet Size and Overhead ...................................[6](#page-6)
   [6](#section-6). Binary Packet Protocol ..........................................[7](#page-7)
      [6.1](#section-6.1). Maximum Packet Length ......................................[8](#page-8)
      [6.2](#section-6.2). Compression ................................................[8](#page-8)
      [6.3](#section-6.3). Encryption .................................................[9](#page-9)
      [6.4](#section-6.4). Data Integrity ............................................[12](#page-12)
      [6.5](#section-6.5). Key Exchange Methods ......................................[13](#page-13)
      [6.6](#section-6.6). Public Key Algorithms .....................................[13](#page-13)
   [7](#section-7). Key Exchange ...................................................[15](#page-15)
      [7.1](#section-7.1). Algorithm Negotiation .....................................[17](#page-17)
      [7.2](#section-7.2). Output from Key Exchange ..................................[20](#page-20)
      [7.3](#section-7.3). Taking Keys Into Use ......................................[21](#page-21)
   [8](#section-8). Diffie-Hellman Key Exchange ....................................[21](#page-21)
      [8.1](#section-8.1). diffie-hellman-group1-sha1 ................................[23](#page-23)
      [8.2](#section-8.2). diffie-hellman-group14-sha1 ...............................[23](#page-23)
   [9](#section-9). Key Re-Exchange ................................................[23](#page-23)
   [10](#section-10). Service Request ...............................................[24](#page-24)
   [11](#section-11). Additional Messages ...........................................[25](#page-25)
      [11.1](#section-11.1). Disconnection Message ....................................[25](#page-25)
      [11.2](#section-11.2). Ignored Data Message .....................................[26](#page-26)
      [11.3](#section-11.3). Debug Message ............................................[26](#page-26)
      [11.4](#section-11.4). Reserved Messages ........................................[27](#page-27)
   [12](#section-12). Summary of Message Numbers ....................................[27](#page-27)
   [13](#section-13). IANA Considerations ...........................................[27](#page-27)
   [14](#section-14). Security Considerations .......................................[28](#page-28)
   [15](#section-15). References ....................................................[29](#page-29)
      [15.1](#section-15.1). Normative References .....................................[29](#page-29)
      [15.2](#section-15.2). Informative References ...................................[30](#page-30)
   Authors' Addresses ................................................[31](#page-31)
   Trademark Notice ..................................................[31](#page-31)

Ylonen &  Lonvick           Standards Track                     [Page 2]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

[1](#section-1).  Introduction

   The SSH transport layer is a secure, low level transport protocol.
   It provides strong encryption, cryptographic host authentication, and
   integrity protection.

   Authentication in this protocol level is host-based; this protocol
   does not perform user authentication.  A higher level protocol for
   user authentication can be designed on top of this protocol.

   The protocol has been designed to be simple and flexible to allow
   parameter negotiation, and to minimize the number of round-trips.
   The key exchange method, public key algorithm, symmetric encryption
   algorithm, message authentication algorithm, and hash algorithm are
   all negotiated.  It is expected that in most environments, only 2
   round-trips will be needed for full key exchange, server
   authentication, service request, and acceptance notification of
   service request.  The worst case is 3 round-trips.

[2](#section-2).  Contributors

   The major original contributors of this set of documents have been:
   Tatu Ylonen, Tero Kivinen, Timo J. Rinne, Sami Lehtinen (all of SSH
   Communications Security Corp), and Markku-Juhani O. Saarinen
   (University of Jyvaskyla).  Darren Moffat was the original editor of
   this set of documents and also made very substantial contributions.

   Many people contributed to the development of this document over the
   years.  People who should be acknowledged include Mats Andersson, Ben
   Harris, Bill Sommerfeld, Brent McClure, Niels Moller, Damien Miller,
   Derek Fawcus, Frank Cusack, Heikki Nousiainen, Jakob Schlyter, Jeff
   Van Dyke, Jeffrey Altman, Jeffrey Hutzelman, Jon Bright, Joseph
   Galbraith, Ken Hornstein, Markus Friedl, Martin Forssen, Nicolas
   Williams, Niels Provos, Perry Metzger, Peter Gutmann, Simon
   Josefsson, Simon Tatham, Wei Dai, Denis Bider, der Mouse, and
   Tadayoshi Kohno.  Listing their names here does not mean that they
   endorse this document, but that they have contributed to it.

[3](#section-3).  Conventions Used in This Document

   All documents related to the SSH protocols shall use the keywords
   "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
   "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" to describe
   requirements.  These keywords are to be interpreted as described in
   [[RFC2119](/doc/html/rfc2119 "\"Key words for use in RFCs to Indicate Requirement Levels\"")].

Ylonen &  Lonvick           Standards Track                     [Page 3]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   The keywords "PRIVATE USE", "HIERARCHICAL ALLOCATION", "FIRST COME
   FIRST SERVED", "EXPERT REVIEW", "SPECIFICATION REQUIRED", "IESG
   APPROVAL", "IETF CONSENSUS", and "STANDARDS ACTION" that appear in
   this document when used to describe namespace allocation are to be
   interpreted as described in [[RFC2434](/doc/html/rfc2434)].

   Protocol fields and possible values to fill them are defined in this
   set of documents.  Protocol fields will be defined in the message
   definitions.  As an example, SSH_MSG_CHANNEL_DATA is defined as
   follows.

      byte      SSH_MSG_CHANNEL_DATA
      uint32    recipient channel
      string    data

   Throughout these documents, when the fields are referenced, they will
   appear within single quotes.  When values to fill those fields are
   referenced, they will appear within double quotes.  Using the above
   example, possible values for 'data' are "foo" and "bar".

[4](#section-4).  Connection Setup

   SSH works over any 8-bit clean, binary-transparent transport.  The
   underlying transport SHOULD protect against transmission errors, as
   such errors cause the SSH connection to terminate.

   The client initiates the connection.

[4.1](#section-4.1).  Use over TCP/IP

   When used over TCP/IP, the server normally listens for connections on
   port 22.  This port number has been registered with the IANA, and has
   been officially assigned for SSH.

[4.2](#section-4.2).  Protocol Version Exchange

   When the connection has been established, both sides MUST send an
   identification string.  This identification string MUST be

      SSH-protoversion-softwareversion SP comments CR LF

   Since the protocol being defined in this set of documents is version
   2.0, the 'protoversion' MUST be "2.0".  The 'comments' string is
   OPTIONAL.  If the 'comments' string is included, a 'space' character
   (denoted above as SP, ASCII 32) MUST separate the 'softwareversion'
   and 'comments' strings.  The identification MUST be terminated by a
   single Carriage Return (CR) and a single Line Feed (LF) character
   (ASCII 13 and 10, respectively).  Implementers who wish to maintain

Ylonen &  Lonvick           Standards Track                     [Page 4]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   compatibility with older, undocumented versions of this protocol may
   want to process the identification string without expecting the
   presence of the carriage return character for reasons described in
   [Section 5](#section-5) of this document.  The null character MUST NOT be sent.
   The maximum length of the string is 255 characters, including the
   Carriage Return and Line Feed.

   The part of the identification string preceding the Carriage Return
   and Line Feed is used in the Diffie-Hellman key exchange (see [Section](#section-8)
   [8](#section-8)).

   The server MAY send other lines of data before sending the version
   string.  Each line SHOULD be terminated by a Carriage Return and Line
   Feed.  Such lines MUST NOT begin with "SSH-", and SHOULD be encoded
   in ISO-10646 UTF-8 [[RFC3629](/doc/html/rfc3629 "\"UTF-8, a transformation format of ISO 10646\"")] (language is not specified).  Clients
   MUST be able to process such lines.  Such lines MAY be silently
   ignored, or MAY be displayed to the client user.  If they are
   displayed, control character filtering, as discussed in [[SSH-ARCH](#ref-SSH-ARCH "\"The Secure Shell (SSH) Protocol Architecture\"")],
   SHOULD be used.  The primary use of this feature is to allow TCP-
   wrappers to display an error message before disconnecting.

   Both the 'protoversion' and 'softwareversion' strings MUST consist of
   printable US-ASCII characters, with the exception of whitespace
   characters and the minus sign (-).  The 'softwareversion' string is
   primarily used to trigger compatibility extensions and to indicate
   the capabilities of an implementation.  The 'comments' string SHOULD
   contain additional information that might be useful in solving user
   problems.  As such, an example of a valid identification string is

      SSH-2.0-billsSSH_3.6.3q3<CR><LF>

   This identification string does not contain the optional 'comments'
   string and is thus terminated by a CR and LF immediately after the
   'softwareversion' string.

   Key exchange will begin immediately after sending this identifier.
   All packets following the identification string SHALL use the binary
   packet protocol, which is described in [Section 6](#section-6).

[5](#section-5).  Compatibility With Old SSH Versions

   As stated earlier, the 'protoversion' specified for this protocol is
   "2.0".  Earlier versions of this protocol have not been formally
   documented, but it is widely known that they use 'protoversion' of
   "1.x" (e.g., "1.5" or "1.3").  At the time of this writing, many
   implementations of SSH are utilizing protocol version 2.0, but it is
   known that there are still devices using the previous versions.
   During the transition period, it is important to be able to work in a

Ylonen &  Lonvick           Standards Track                     [Page 5]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   way that is compatible with the installed SSH clients and servers
   that use the older version of the protocol.  Information in this
   section is only relevant for implementations supporting compatibility
   with SSH versions 1.x.  For those interested, the only known
   documentation of the 1.x protocol is contained in README files that
   are shipped along with the source code [[ssh-1.2.30](#ref-ssh-1.2.30 "\"ssh-1.2.30/RFC\"")].

[5.1](#section-5.1).  Old Client, New Server

   Server implementations MAY support a configurable compatibility flag
   that enables compatibility with old versions.  When this flag is on,
   the server SHOULD identify its 'protoversion' as "1.99".  Clients
   using protocol 2.0 MUST be able to identify this as identical to
   "2.0".  In this mode, the server SHOULD NOT send the Carriage Return
   character (ASCII 13) after the identification string.

   In the compatibility mode, the server SHOULD NOT send any further
   data after sending its identification string until it has received an
   identification string from the client.  The server can then determine
   whether the client is using an old protocol, and can revert to the
   old protocol if required.  In the compatibility mode, the server MUST
   NOT send additional data before the identification string.

   When compatibility with old clients is not needed, the server MAY
   send its initial key exchange data immediately after the
   identification string.

[5.2](#section-5.2).  New Client, Old Server

   Since the new client MAY immediately send additional data after its
   identification string (before receiving the server's identification
   string), the old protocol may already be corrupt when the client
   learns that the server is old.  When this happens, the client SHOULD
   close the connection to the server, and reconnect using the old
   protocol.

[5.3](#section-5.3).  Packet Size and Overhead

   Some readers will worry about the increase in packet size due to new
   headers, padding, and the Message Authentication Code (MAC).  The
   minimum packet size is in the order of 28 bytes (depending on
   negotiated algorithms).  The increase is negligible for large
   packets, but very significant for one-byte packets (telnet-type
   sessions).  There are, however, several factors that make this a
   non-issue in almost all cases:

   o  The minimum size of a TCP/IP header is 32 bytes.  Thus, the
      increase is actually from 33 to 51 bytes (roughly).

Ylonen &  Lonvick           Standards Track                     [Page 6]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   o  The minimum size of the data field of an Ethernet packet is 46
      bytes [[RFC0894](/doc/html/rfc0894 "\"Standard for the transmission of IP datagrams over Ethernet networks\"")].  Thus, the increase is no more than 5 bytes.
      When Ethernet headers are considered, the increase is less than 10
      percent.

   o  The total fraction of telnet-type data in the Internet is
      negligible, even with increased packet sizes.

   The only environment where the packet size increase is likely to have
   a significant effect is PPP [[RFC1661](/doc/html/rfc1661 "\"The Point-to-Point Protocol (PPP)\"")] over slow modem lines (PPP
   compresses the TCP/IP headers, emphasizing the increase in packet
   size).  However, with modern modems, the time needed to transfer is
   in the order of 2 milliseconds, which is a lot faster than people can
   type.

   There are also issues related to the maximum packet size.  To
   minimize delays in screen updates, one does not want excessively
   large packets for interactive sessions.  The maximum packet size is
   negotiated separately for each channel.

[6](#section-6).  Binary Packet Protocol

   Each packet is in the following format:

      uint32    packet_length
      byte      padding_length
      byte[n1]  payload; n1 = packet_length - padding_length - 1
      byte[n2]  random padding; n2 = padding_length
      byte[m]   mac (Message Authentication Code - MAC); m = mac_length

      packet_length
         The length of the packet in bytes, not including 'mac' or the
         'packet_length' field itself.

      padding_length
         Length of 'random padding' (bytes).

      payload
         The useful contents of the packet.  If compression has been
         negotiated, this field is compressed.  Initially, compression
         MUST be "none".

      random padding
         Arbitrary-length padding, such that the total length of
         (packet_length || padding_length || payload || random padding)
         is a multiple of the cipher block size or 8, whichever is

Ylonen &  Lonvick           Standards Track                     [Page 7]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

         larger.  There MUST be at least four bytes of padding.  The
         padding SHOULD consist of random bytes.  The maximum amount of
         padding is 255 bytes.

      mac
         Message Authentication Code.  If message authentication has
         been negotiated, this field contains the MAC bytes.  Initially,
         the MAC algorithm MUST be "none".

   Note that the length of the concatenation of 'packet_length',
   'padding_length', 'payload', and 'random padding' MUST be a multiple
   of the cipher block size or 8, whichever is larger.  This constraint
   MUST be enforced, even when using stream ciphers.  Note that the
   'packet_length' field is also encrypted, and processing it requires
   special care when sending or receiving packets.  Also note that the
   insertion of variable amounts of 'random padding' may help thwart
   traffic analysis.

   The minimum size of a packet is 16 (or the cipher block size,
   whichever is larger) bytes (plus 'mac').  Implementations SHOULD
   decrypt the length after receiving the first 8 (or cipher block size,
   whichever is larger) bytes of a packet.

[6.1](#section-6.1).  Maximum Packet Length

   All implementations MUST be able to process packets with an
   uncompressed payload length of 32768 bytes or less and a total packet
   size of 35000 bytes or less (including 'packet_length',
   'padding_length', 'payload', 'random padding', and 'mac').  The
   maximum of 35000 bytes is an arbitrarily chosen value that is larger
   than the uncompressed length noted above.  Implementations SHOULD
   support longer packets, where they might be needed.  For example, if
   an implementation wants to send a very large number of certificates,
   the larger packets MAY be sent if the identification string indicates
   that the other party is able to process them.  However,
   implementations SHOULD check that the packet length is reasonable in
   order for the implementation to avoid denial of service and/or buffer
   overflow attacks.

[6.2](#section-6.2).  Compression

   If compression has been negotiated, the 'payload' field (and only it)
   will be compressed using the negotiated algorithm.  The
   'packet_length' field and 'mac' will be computed from the compressed
   payload.  Encryption will be done after compression.

Ylonen &  Lonvick           Standards Track                     [Page 8]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   Compression MAY be stateful, depending on the method.  Compression
   MUST be independent for each direction, and implementations MUST
   allow independent choosing of the algorithm for each direction.  In
   practice however, it is RECOMMENDED that the compression method be
   the same in both directions.

   The following compression methods are currently defined:

      none     REQUIRED        no compression
      zlib     OPTIONAL        ZLIB (LZ77) compression

   The "zlib" compression is described in [[RFC1950](/doc/html/rfc1950 "\"ZLIB Compressed Data Format Specification version 3.3\"")] and in [[RFC1951](/doc/html/rfc1951 "\"DEFLATE Compressed Data Format Specification version 1.3\"")].
   The compression context is initialized after each key exchange, and
   is passed from one packet to the next, with only a partial flush
   being performed at the end of each packet.  A partial flush means
   that the current compressed block is ended and all data will be
   output.  If the current block is not a stored block, one or more
   empty blocks are added after the current block to ensure that there
   are at least 8 bits, counting from the start of the end-of-block code
   of the current block to the end of the packet payload.

   Additional methods may be defined as specified in [[SSH-ARCH](#ref-SSH-ARCH "\"The Secure Shell (SSH) Protocol Architecture\"")] and
   [[SSH-NUMBERS](#ref-SSH-NUMBERS "\"The Secure Shell (SSH) Protocol Assigned Numbers\"")].

[6.3](#section-6.3).  Encryption

   An encryption algorithm and a key will be negotiated during the key
   exchange.  When encryption is in effect, the packet length, padding
   length, payload, and padding fields of each packet MUST be encrypted
   with the given algorithm.

   The encrypted data in all packets sent in one direction SHOULD be
   considered a single data stream.  For example, initialization vectors
   SHOULD be passed from the end of one packet to the beginning of the
   next packet.  All ciphers SHOULD use keys with an effective key
   length of 128 bits or more.

   The ciphers in each direction MUST run independently of each other.
   Implementations MUST allow the algorithm for each direction to be
   independently selected, if multiple algorithms are allowed by local
   policy.  In practice however, it is RECOMMENDED that the same
   algorithm be used in both directions.

Ylonen &  Lonvick           Standards Track                     [Page 9]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   The following ciphers are currently defined:

      3des-cbc         REQUIRED          three-key 3DES in CBC mode
      blowfish-cbc     OPTIONAL          Blowfish in CBC mode
      twofish256-cbc   OPTIONAL          Twofish in CBC mode,
                                         with a 256-bit key
      twofish-cbc      OPTIONAL          alias for "twofish256-cbc"
                                         (this is being retained
                                         for historical reasons)
      twofish192-cbc   OPTIONAL          Twofish with a 192-bit key
      twofish128-cbc   OPTIONAL          Twofish with a 128-bit key
      aes256-cbc       OPTIONAL          AES in CBC mode,
                                         with a 256-bit key
      aes192-cbc       OPTIONAL          AES with a 192-bit key
      aes128-cbc       RECOMMENDED       AES with a 128-bit key
      serpent256-cbc   OPTIONAL          Serpent in CBC mode, with
                                         a 256-bit key
      serpent192-cbc   OPTIONAL          Serpent with a 192-bit key
      serpent128-cbc   OPTIONAL          Serpent with a 128-bit key
      arcfour          OPTIONAL          the ARCFOUR stream cipher
                                         with a 128-bit key
      idea-cbc         OPTIONAL          IDEA in CBC mode
      cast128-cbc      OPTIONAL          CAST-128 in CBC mode
      none             OPTIONAL          no encryption; NOT RECOMMENDED

   The "3des-cbc" cipher is three-key triple-DES (encrypt-decrypt-
   encrypt), where the first 8 bytes of the key are used for the first
   encryption, the next 8 bytes for the decryption, and the following 8
   bytes for the final encryption.  This requires 24 bytes of key data
   (of which 168 bits are actually used).  To implement CBC mode, outer
   chaining MUST be used (i.e., there is only one initialization
   vector).  This is a block cipher with 8-byte blocks.  This algorithm
   is defined in [[FIPS-46-3](#ref-FIPS-46-3 "\"Data Encryption Standard (DES)\"")].  Note that since this algorithm only has
   an effective key length of 112 bits ([[SCHNEIER](#ref-SCHNEIER "\"Applied Cryptography Second Edition: protocols algorithms and source in code in C\"")]), it does not meet
   the specifications that SSH encryption algorithms should use keys of
   128 bits or more.  However, this algorithm is still REQUIRED for
   historical reasons; essentially, all known implementations at the
   time of this writing support this algorithm, and it is commonly used
   because it is the fundamental interoperable algorithm.  At some
   future time, it is expected that another algorithm, one with better
   strength, will become so prevalent and ubiquitous that the use of
   "3des-cbc" will be deprecated by another STANDARDS ACTION.

   The "blowfish-cbc" cipher is Blowfish in CBC mode, with 128-bit keys
   [[SCHNEIER](#ref-SCHNEIER "\"Applied Cryptography Second Edition: protocols algorithms and source in code in C\"")].  This is a block cipher with 8-byte blocks.

Ylonen &  Lonvick           Standards Track                    [Page 10]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   The "twofish-cbc" or "twofish256-cbc" cipher is Twofish in CBC mode,
   with 256-bit keys as described [[TWOFISH](#ref-TWOFISH "\"The Twofish Encryptions Algorithm: A 128-Bit Block Cipher, 1st Edition\"")].  This is a block cipher
   with 16-byte blocks.

   The "twofish192-cbc" cipher is the same as above, but with a 192-bit
   key.

   The "twofish128-cbc" cipher is the same as above, but with a 128-bit
   key.

   The "aes256-cbc" cipher is AES (Advanced Encryption Standard)
   [[FIPS-197](#ref-FIPS-197 "\"Advanced Encryption Standard (AES)\"")], in CBC mode.  This version uses a 256-bit key.

   The "aes192-cbc" cipher is the same as above, but with a 192-bit key.

   The "aes128-cbc" cipher is the same as above, but with a 128-bit key.

   The "serpent256-cbc" cipher in CBC mode, with a 256-bit key as
   described in the Serpent AES submission.

   The "serpent192-cbc" cipher is the same as above, but with a 192-bit
   key.

   The "serpent128-cbc" cipher is the same as above, but with a 128-bit
   key.

   The "arcfour" cipher is the Arcfour stream cipher with 128-bit keys.
   The Arcfour cipher is believed to be compatible with the RC4 cipher
   [[SCHNEIER](#ref-SCHNEIER "\"Applied Cryptography Second Edition: protocols algorithms and source in code in C\"")].  Arcfour (and RC4) has problems with weak keys, and
   should be used with caution.

   The "idea-cbc" cipher is the IDEA cipher in CBC mode [[SCHNEIER](#ref-SCHNEIER "\"Applied Cryptography Second Edition: protocols algorithms and source in code in C\"")].

   The "cast128-cbc" cipher is the CAST-128 cipher in CBC mode with a
   128-bit key [[RFC2144](/doc/html/rfc2144 "\"The CAST-128 Encryption Algorithm\"")].

   The "none" algorithm specifies that no encryption is to be done.
   Note that this method provides no confidentiality protection, and it
   is NOT RECOMMENDED.  Some functionality (e.g., password
   authentication) may be disabled for security reasons if this cipher
   is chosen.

   Additional methods may be defined as specified in [[SSH-ARCH](#ref-SSH-ARCH "\"The Secure Shell (SSH) Protocol Architecture\"")] and in
   [[SSH-NUMBERS](#ref-SSH-NUMBERS "\"The Secure Shell (SSH) Protocol Assigned Numbers\"")].

Ylonen &  Lonvick           Standards Track                    [Page 11]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

[6.4](#section-6.4).  Data Integrity

   Data integrity is protected by including with each packet a MAC that
   is computed from a shared secret, packet sequence number, and the
   contents of the packet.

   The message authentication algorithm and key are negotiated during
   key exchange.  Initially, no MAC will be in effect, and its length
   MUST be zero.  After key exchange, the 'mac' for the selected MAC
   algorithm will be computed before encryption from the concatenation
   of packet data:

      mac = MAC(key, sequence_number || unencrypted_packet)

   where unencrypted_packet is the entire packet without 'mac' (the
   length fields, 'payload' and 'random padding'), and sequence_number
   is an implicit packet sequence number represented as uint32.  The
   sequence_number is initialized to zero for the first packet, and is
   incremented after every packet (regardless of whether encryption or
   MAC is in use).  It is never reset, even if keys/algorithms are
   renegotiated later.  It wraps around to zero after every 2^32
   packets.  The packet sequence_number itself is not included in the
   packet sent over the wire.

   The MAC algorithms for each direction MUST run independently, and
   implementations MUST allow choosing the algorithm independently for
   both directions.  In practice however, it is RECOMMENDED that the
   same algorithm be used in both directions.

   The value of 'mac' resulting from the MAC algorithm MUST be
   transmitted without encryption as the last part of the packet.  The
   number of 'mac' bytes depends on the algorithm chosen.

   The following MAC algorithms are currently defined:

      hmac-sha1    REQUIRED        HMAC-SHA1 (digest length = key
                                   length = 20)
      hmac-sha1-96 RECOMMENDED     first 96 bits of HMAC-SHA1 (digest
                                   length = 12, key length = 20)
      hmac-md5     OPTIONAL        HMAC-MD5 (digest length = key
                                   length = 16)
      hmac-md5-96  OPTIONAL        first 96 bits of HMAC-MD5 (digest
                                   length = 12, key length = 16)
      none         OPTIONAL        no MAC; NOT RECOMMENDED

   The "hmac-*" algorithms are described in [[RFC2104](/doc/html/rfc2104 "\"HMAC: Keyed-Hashing for Message Authentication\"")].  The "*-n" MACs
   use only the first n bits of the resulting value.

Ylonen &  Lonvick           Standards Track                    [Page 12]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   SHA-1 is described in [[FIPS-180-2](#ref-FIPS-180-2 "\"Secure Hash Standard (SHS)\"")] and MD5 is described in [[RFC1321](/doc/html/rfc1321 "\"The MD5 Message-Digest Algorithm \"")].

   Additional methods may be defined, as specified in [[SSH-ARCH](#ref-SSH-ARCH "\"The Secure Shell (SSH) Protocol Architecture\"")] and in
   [[SSH-NUMBERS](#ref-SSH-NUMBERS "\"The Secure Shell (SSH) Protocol Assigned Numbers\"")].

[6.5](#section-6.5).  Key Exchange Methods

   The key exchange method specifies how one-time session keys are
   generated for encryption and for authentication, and how the server
   authentication is done.

   Two REQUIRED key exchange methods have been defined:

      diffie-hellman-group1-sha1 REQUIRED
      diffie-hellman-group14-sha1 REQUIRED

   These methods are described in [Section 8](#section-8).

   Additional methods may be defined as specified in [[SSH-NUMBERS](#ref-SSH-NUMBERS "\"The Secure Shell (SSH) Protocol Assigned Numbers\"")].  The
   name "diffie-hellman-group1-sha1" is used for a key exchange method
   using an Oakley group, as defined in [[RFC2409](/doc/html/rfc2409 "\"The Internet Key Exchange (IKE)\"")].  SSH maintains its
   own group identifier space that is logically distinct from Oakley
   [[RFC2412](/doc/html/rfc2412 "\"The OAKLEY Key Determination Protocol\"")] and IKE; however, for one additional group, the Working
   Group adopted the number assigned by [[RFC3526](/doc/html/rfc3526 "\"More Modular Exponential (MODP) Diffie-Hellman groups for Internet Key Exchange (IKE)\"")], using diffie-
   hellman-group14-sha1 for the name of the second defined group.
   Implementations should treat these names as opaque identifiers and
   should not assume any relationship between the groups used by SSH and
   the groups defined for IKE.

[6.6](#section-6.6).  Public Key Algorithms

   This protocol has been designed to operate with almost any public key
   format, encoding, and algorithm (signature and/or encryption).

   There are several aspects that define a public key type:

   o  Key format: how is the key encoded and how are certificates
      represented.  The key blobs in this protocol MAY contain
      certificates in addition to keys.

   o  Signature and/or encryption algorithms.  Some key types may not
      support both signing and encryption.  Key usage may also be
      restricted by policy statements (e.g., in certificates).  In this
      case, different key types SHOULD be defined for the different
      policy alternatives.

   o  Encoding of signatures and/or encrypted data.  This includes but
      is not limited to padding, byte order, and data formats.

Ylonen &  Lonvick           Standards Track                    [Page 13]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   The following public key and/or certificate formats are currently
   defined:

   ssh-dss           REQUIRED     sign   Raw DSS Key
   ssh-rsa           RECOMMENDED  sign   Raw RSA Key
   pgp-sign-rsa      OPTIONAL     sign   OpenPGP certificates (RSA key)
   pgp-sign-dss      OPTIONAL     sign   OpenPGP certificates (DSS key)

   Additional key types may be defined, as specified in [[SSH-ARCH](#ref-SSH-ARCH "\"The Secure Shell (SSH) Protocol Architecture\"")] and
   in [[SSH-NUMBERS](#ref-SSH-NUMBERS "\"The Secure Shell (SSH) Protocol Assigned Numbers\"")].

   The key type MUST always be explicitly known (from algorithm
   negotiation or some other source).  It is not normally included in
   the key blob.

   Certificates and public keys are encoded as follows:

      string    certificate or public key format identifier
      byte[n]   key/certificate data

   The certificate part may be a zero length string, but a public key is
   required.  This is the public key that will be used for
   authentication.  The certificate sequence contained in the
   certificate blob can be used to provide authorization.

   Public key/certificate formats that do not explicitly specify a
   signature format identifier MUST use the public key/certificate
   format identifier as the signature identifier.

   Signatures are encoded as follows:

      string    signature format identifier (as specified by the
                public key/certificate format)
      byte[n]   signature blob in format specific encoding.

   The "ssh-dss" key format has the following specific encoding:

      string    "ssh-dss"
      mpint     p
      mpint     q
      mpint     g
      mpint     y

   Here, the 'p', 'q', 'g', and 'y' parameters form the signature key
   blob.

Ylonen &  Lonvick           Standards Track                    [Page 14]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   Signing and verifying using this key format is done according to the
   Digital Signature Standard [[FIPS-186-2](#ref-FIPS-186-2 "\"Digital Signature Standard (DSS)\"")] using the SHA-1 hash
   [[FIPS-180-2](#ref-FIPS-180-2 "\"Secure Hash Standard (SHS)\"")].

   The resulting signature is encoded as follows:

      string    "ssh-dss"
      string    dss_signature_blob

   The value for 'dss_signature_blob' is encoded as a string containing
   r, followed by s (which are 160-bit integers, without lengths or
   padding, unsigned, and in network byte order).

   The "ssh-rsa" key format has the following specific encoding:

      string    "ssh-rsa"
      mpint     e
      mpint     n

   Here the 'e' and 'n' parameters form the signature key blob.

   Signing and verifying using this key format is performed according to
   the RSASSA-PKCS1-v1_5 scheme in [[RFC3447](/doc/html/rfc3447 "\"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1\"")] using the SHA-1 hash.

   The resulting signature is encoded as follows:

      string    "ssh-rsa"
      string    rsa_signature_blob

   The value for 'rsa_signature_blob' is encoded as a string containing
   s (which is an integer, without lengths or padding, unsigned, and in
   network byte order).

   The "pgp-sign-rsa" method indicates the certificates, the public key,
   and the signature are in OpenPGP compatible binary format
   ([[RFC2440](/doc/html/rfc2440 "\"OpenPGP Message Format\"")]).  This method indicates that the key is an RSA-key.

   The "pgp-sign-dss" is as above, but indicates that the key is a
   DSS-key.

[7](#section-7).  Key Exchange

   Key exchange (kex) begins by each side sending name-lists of
   supported algorithms.  Each side has a preferred algorithm in each
   category, and it is assumed that most implementations, at any given
   time, will use the same preferred algorithm.  Each side MAY guess

Ylonen &  Lonvick           Standards Track                    [Page 15]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   which algorithm the other side is using, and MAY send an initial key
   exchange packet according to the algorithm, if appropriate for the
   preferred method.

   The guess is considered wrong if:

   o  the kex algorithm and/or the host key algorithm is guessed wrong
      (server and client have different preferred algorithm), or

   o  if any of the other algorithms cannot be agreed upon (the
      procedure is defined below in [Section 7.1](#section-7.1)).

   Otherwise, the guess is considered to be right, and the
   optimistically sent packet MUST be handled as the first key exchange
   packet.

   However, if the guess was wrong, and a packet was optimistically sent
   by one or both parties, such packets MUST be ignored (even if the
   error in the guess would not affect the contents of the initial
   packet(s)), and the appropriate side MUST send the correct initial
   packet.

   A key exchange method uses explicit server authentication if the key
   exchange messages include a signature or other proof of the server's
   authenticity.  A key exchange method uses implicit server
   authentication if, in order to prove its authenticity, the server
   also has to prove that it knows the shared secret, K, by sending a
   message and a corresponding MAC that the client can verify.

   The key exchange method defined by this document uses explicit server
   authentication.  However, key exchange methods with implicit server
   authentication MAY be used with this protocol.  After a key exchange
   with implicit server authentication, the client MUST wait for a
   response to its service request message before sending any further
   data.

Ylonen &  Lonvick           Standards Track                    [Page 16]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

[7.1](#section-7.1).  Algorithm Negotiation

   Key exchange begins by each side sending the following packet:

      byte         SSH_MSG_KEXINIT
      byte[16]     cookie (random bytes)
      name-list    kex_algorithms
      name-list    server_host_key_algorithms
      name-list    encryption_algorithms_client_to_server
      name-list    encryption_algorithms_server_to_client
      name-list    mac_algorithms_client_to_server
      name-list    mac_algorithms_server_to_client
      name-list    compression_algorithms_client_to_server
      name-list    compression_algorithms_server_to_client
      name-list    languages_client_to_server
      name-list    languages_server_to_client
      boolean      first_kex_packet_follows
      uint32       0 (reserved for future extension)

   Each of the algorithm name-lists MUST be a comma-separated list of
   algorithm names (see Algorithm Naming in [[SSH-ARCH](#ref-SSH-ARCH "\"The Secure Shell (SSH) Protocol Architecture\"")] and additional
   information in [[SSH-NUMBERS](#ref-SSH-NUMBERS "\"The Secure Shell (SSH) Protocol Assigned Numbers\"")]).  Each supported (allowed) algorithm
   MUST be listed in order of preference, from most to least.

   The first algorithm in each name-list MUST be the preferred (guessed)
   algorithm.  Each name-list MUST contain at least one algorithm name.

      cookie
         The 'cookie' MUST be a random value generated by the sender.
         Its purpose is to make it impossible for either side to fully
         determine the keys and the session identifier.

      kex_algorithms
         Key exchange algorithms were defined above.  The first
         algorithm MUST be the preferred (and guessed) algorithm.  If
         both sides make the same guess, that algorithm MUST be used.
         Otherwise, the following algorithm MUST be used to choose a key
         exchange method: Iterate over client's kex algorithms, one at a
         time.  Choose the first algorithm that satisfies the following
         conditions:

         +  the server also supports the algorithm,

         +  if the algorithm requires an encryption-capable host key,
            there is an encryption-capable algorithm on the server's
            server_host_key_algorithms that is also supported by the
            client, and

Ylonen &  Lonvick           Standards Track                    [Page 17]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

         +  if the algorithm requires a signature-capable host key,
            there is a signature-capable algorithm on the server's
            server_host_key_algorithms that is also supported by the
            client.

      If no algorithm satisfying all these conditions can be found, the
      connection fails, and both sides MUST disconnect.

      server_host_key_algorithms
         A name-list of the algorithms supported for the server host
         key.  The server lists the algorithms for which it has host
         keys; the client lists the algorithms that it is willing to
         accept.  There MAY be multiple host keys for a host, possibly
         with different algorithms.

         Some host keys may not support both signatures and encryption
         (this can be determined from the algorithm), and thus not all
         host keys are valid for all key exchange methods.

         Algorithm selection depends on whether the chosen key exchange
         algorithm requires a signature or an encryption-capable host
         key.  It MUST be possible to determine this from the public key
         algorithm name.  The first algorithm on the client's name-list
         that satisfies the requirements and is also supported by the
         server MUST be chosen.  If there is no such algorithm, both
         sides MUST disconnect.

      encryption_algorithms
         A name-list of acceptable symmetric encryption algorithms (also
         known as ciphers) in order of preference.  The chosen
         encryption algorithm to each direction MUST be the first
         algorithm on the client's name-list that is also on the
         server's name-list.  If there is no such algorithm, both sides
         MUST disconnect.

         Note that "none" must be explicitly listed if it is to be
         acceptable.  The defined algorithm names are listed in [Section](#section-6.3)
         [6.3](#section-6.3).

      mac_algorithms
         A name-list of acceptable MAC algorithms in order of
         preference.  The chosen MAC algorithm MUST be the first
         algorithm on the client's name-list that is also on the
         server's name-list.  If there is no such algorithm, both sides
         MUST disconnect.

         Note that "none" must be explicitly listed if it is to be
         acceptable.  The MAC algorithm names are listed in [Section 6.4](#section-6.4).

Ylonen &  Lonvick           Standards Track                    [Page 18]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

      compression_algorithms
         A name-list of acceptable compression algorithms in order of
         preference.  The chosen compression algorithm MUST be the first
         algorithm on the client's name-list that is also on the
         server's name-list.  If there is no such algorithm, both sides
         MUST disconnect.

         Note that "none" must be explicitly listed if it is to be
         acceptable.  The compression algorithm names are listed in
         [Section 6.2](#section-6.2).

      languages
         This is a name-list of language tags in order of preference
         [[RFC3066](/doc/html/rfc3066 "\"Tags for the Identification of Languages\"")].  Both parties MAY ignore this name-list.  If there
         are no language preferences, this name-list SHOULD be empty as
         defined in Section 5 of [[SSH-ARCH](#ref-SSH-ARCH "\"The Secure Shell (SSH) Protocol Architecture\"")].  Language tags SHOULD NOT
         be present unless they are known to be needed by the sending
         party.

      first_kex_packet_follows
         Indicates whether a guessed key exchange packet follows.  If a
         guessed packet will be sent, this MUST be TRUE.  If no guessed
         packet will be sent, this MUST be FALSE.

         After receiving the SSH_MSG_KEXINIT packet from the other side,
         each party will know whether their guess was right.  If the
         other party's guess was wrong, and this field was TRUE, the
         next packet MUST be silently ignored, and both sides MUST then
         act as determined by the negotiated key exchange method.  If
         the guess was right, key exchange MUST continue using the
         guessed packet.

   After the SSH_MSG_KEXINIT message exchange, the key exchange
   algorithm is run.  It may involve several packet exchanges, as
   specified by the key exchange method.

   Once a party has sent a SSH_MSG_KEXINIT message for key exchange or
   re-exchange, until it has sent a SSH_MSG_NEWKEYS message ([Section](#section-7.3)
   [7.3](#section-7.3)), it MUST NOT send any messages other than:

   o  Transport layer generic messages (1 to 19) (but
      SSH_MSG_SERVICE_REQUEST and SSH_MSG_SERVICE_ACCEPT MUST NOT be
      sent);

   o  Algorithm negotiation messages (20 to 29) (but further
      SSH_MSG_KEXINIT messages MUST NOT be sent);

   o  Specific key exchange method messages (30 to 49).

Ylonen &  Lonvick           Standards Track                    [Page 19]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   The provisions of [Section 11](#section-11) apply to unrecognized messages.

   Note, however, that during a key re-exchange, after sending a
   SSH_MSG_KEXINIT message, each party MUST be prepared to process an
   arbitrary number of messages that may be in-flight before receiving a
   SSH_MSG_KEXINIT message from the other party.

[7.2](#section-7.2).  Output from Key Exchange

   The key exchange produces two values: a shared secret K, and an
   exchange hash H.  Encryption and authentication keys are derived from
   these.  The exchange hash H from the first key exchange is
   additionally used as the session identifier, which is a unique
   identifier for this connection.  It is used by authentication methods
   as a part of the data that is signed as a proof of possession of a
   private key.  Once computed, the session identifier is not changed,
   even if keys are later re-exchanged.

   Each key exchange method specifies a hash function that is used in
   the key exchange.  The same hash algorithm MUST be used in key
   derivation.  Here, we'll call it HASH.

   Encryption keys MUST be computed as HASH, of a known value and K, as
   follows:

   o  Initial IV client to server: HASH(K || H || "A" || session_id)
      (Here K is encoded as mpint and "A" as byte and session_id as raw
      data.  "A" means the single character A, ASCII 65).

   o  Initial IV server to client: HASH(K || H || "B" || session_id)

   o  Encryption key client to server: HASH(K || H || "C" || session_id)

   o  Encryption key server to client: HASH(K || H || "D" || session_id)

   o  Integrity key client to server: HASH(K || H || "E" || session_id)

   o  Integrity key server to client: HASH(K || H || "F" || session_id)

   Key data MUST be taken from the beginning of the hash output.  As
   many bytes as needed are taken from the beginning of the hash value.
   If the key length needed is longer than the output of the HASH, the
   key is extended by computing HASH of the concatenation of K and H and
   the entire key so far, and appending the resulting bytes (as many as
   HASH generates) to the key.  This process is repeated until enough
   key material is available; the key is taken from the beginning of
   this value.  In other words:

Ylonen &  Lonvick           Standards Track                    [Page 20]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

      K1 = HASH(K || H || X || session_id)   (X is e.g., "A")
      K2 = HASH(K || H || K1)
      K3 = HASH(K || H || K1 || K2)
      ...
      key = K1 || K2 || K3 || ...

   This process will lose entropy if the amount of entropy in K is
   larger than the internal state size of HASH.

[7.3](#section-7.3).  Taking Keys Into Use

   Key exchange ends by each side sending an SSH_MSG_NEWKEYS message.
   This message is sent with the old keys and algorithms.  All messages
   sent after this message MUST use the new keys and algorithms.

   When this message is received, the new keys and algorithms MUST be
   used for receiving.

   The purpose of this message is to ensure that a party is able to
   respond with an SSH_MSG_DISCONNECT message that the other party can
   understand if something goes wrong with the key exchange.

      byte      SSH_MSG_NEWKEYS

[8](#section-8).  Diffie-Hellman Key Exchange

   The Diffie-Hellman (DH) key exchange provides a shared secret that
   cannot be determined by either party alone.  The key exchange is
   combined with a signature with the host key to provide host
   authentication.  This key exchange method provides explicit server
   authentication as defined in [Section 7](#section-7).

   The following steps are used to exchange a key.  In this, C is the
   client; S is the server; p is a large safe prime; g is a generator
   for a subgroup of GF(p); q is the order of the subgroup; V_S is S's
   identification string; V_C is C's identification string; K_S is S's
   public host key; I_C is C's SSH_MSG_KEXINIT message and I_S is S's
   SSH_MSG_KEXINIT message that have been exchanged before this part
   begins.

   1. C generates a random number x (1 < x < q) and computes
      e = g^x mod p.  C sends e to S.

Ylonen &  Lonvick           Standards Track                    [Page 21]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   2. S generates a random number y (0 < y < q) and computes
      f = g^y mod p.  S receives e.  It computes K = e^y mod p,
      H = hash(V_C || V_S || I_C || I_S || K_S || e || f || K)
      (these elements are encoded according to their types; see below),
      and signature s on H with its private host key.  S sends
      (K_S || f || s) to C.  The signing operation may involve a
      second hashing operation.

   3. C verifies that K_S really is the host key for S (e.g., using
      certificates or a local database).  C is also allowed to accept
      the key without verification; however, doing so will render the
      protocol insecure against active attacks (but may be desirable for
      practical reasons in the short term in many environments).  C then
      computes K = f^x mod p, H = hash(V_C || V_S || I_C || I_S || K_S
      || e || f || K), and verifies the signature s on H.

   Values of 'e' or 'f' that are not in the range [1, p-1] MUST NOT be
   sent or accepted by either side.  If this condition is violated, the
   key exchange fails.

   This is implemented with the following messages.  The hash algorithm
   for computing the exchange hash is defined by the method name, and is
   called HASH.  The public key algorithm for signing is negotiated with
   the SSH_MSG_KEXINIT messages.

   First, the client sends the following:

      byte      SSH_MSG_KEXDH_INIT
      mpint     e

   The server then responds with the following:

      byte      SSH_MSG_KEXDH_REPLY
      string    server public host key and certificates (K_S)
      mpint     f
      string    signature of H

Ylonen &  Lonvick           Standards Track                    [Page 22]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   The hash H is computed as the HASH hash of the concatenation of the
   following:

      string    V_C, the client's identification string (CR and LF
                excluded)
      string    V_S, the server's identification string (CR and LF
                excluded)
      string    I_C, the payload of the client's SSH_MSG_KEXINIT
      string    I_S, the payload of the server's SSH_MSG_KEXINIT
      string    K_S, the host key
      mpint     e, exchange value sent by the client
      mpint     f, exchange value sent by the server
      mpint     K, the shared secret

   This value is called the exchange hash, and it is used to
   authenticate the key exchange.  The exchange hash SHOULD be kept
   secret.

   The signature algorithm MUST be applied over H, not the original
   data.  Most signature algorithms include hashing and additional
   padding (e.g., "ssh-dss" specifies SHA-1 hashing).  In that case, the
   data is first hashed with HASH to compute H, and H is then hashed
   with SHA-1 as part of the signing operation.

[8.1](#section-8.1).  diffie-hellman-group1-sha1

   The "diffie-hellman-group1-sha1" method specifies the Diffie-Hellman
   key exchange with SHA-1 as HASH, and Oakley Group 2 [[RFC2409](/doc/html/rfc2409 "\"The Internet Key Exchange (IKE)\"")] (1024-
   bit MODP Group).  This method MUST be supported for interoperability
   as all of the known implementations currently support it.  Note that
   this method is named using the phrase "group1", even though it
   specifies the use of Oakley Group 2.

[8.2](#section-8.2).  diffie-hellman-group14-sha1

   The "diffie-hellman-group14-sha1" method specifies a Diffie-Hellman
   key exchange with SHA-1 as HASH and Oakley Group 14 [[RFC3526](/doc/html/rfc3526 "\"More Modular Exponential (MODP) Diffie-Hellman groups for Internet Key Exchange (IKE)\"")] (2048-
   bit MODP Group), and it MUST also be supported.

[9](#section-9).  Key Re-Exchange

   Key re-exchange is started by sending an SSH_MSG_KEXINIT packet when
   not already doing a key exchange (as described in [Section 7.1](#section-7.1)).  When
   this message is received, a party MUST respond with its own
   SSH_MSG_KEXINIT message, except when the received SSH_MSG_KEXINIT
   already was a reply.  Either party MAY initiate the re-exchange, but
   roles MUST NOT be changed (i.e., the server remains the server, and
   the client remains the client).

Ylonen &  Lonvick           Standards Track                    [Page 23]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   Key re-exchange is performed using whatever encryption was in effect
   when the exchange was started.  Encryption, compression, and MAC
   methods are not changed before a new SSH_MSG_NEWKEYS is sent after
   the key exchange (as in the initial key exchange).  Re-exchange is
   processed identically to the initial key exchange, except for the
   session identifier that will remain unchanged.  It is permissible to
   change some or all of the algorithms during the re-exchange.  Host
   keys can also change.  All keys and initialization vectors are
   recomputed after the exchange.  Compression and encryption contexts
   are reset.

   It is RECOMMENDED that the keys be changed after each gigabyte of
   transmitted data or after each hour of connection time, whichever
   comes sooner.  However, since the re-exchange is a public key
   operation, it requires a fair amount of processing power and should
   not be performed too often.

   More application data may be sent after the SSH_MSG_NEWKEYS packet
   has been sent; key exchange does not affect the protocols that lie
   above the SSH transport layer.

[10](#section-10).  Service Request

   After the key exchange, the client requests a service.  The service
   is identified by a name.  The format of names and procedures for
   defining new names are defined in [[SSH-ARCH](#ref-SSH-ARCH "\"The Secure Shell (SSH) Protocol Architecture\"")] and [[SSH-NUMBERS](#ref-SSH-NUMBERS "\"The Secure Shell (SSH) Protocol Assigned Numbers\"")].

   Currently, the following names have been reserved:

      ssh-userauth
      ssh-connection

   Similar local naming policy is applied to the service names, as is
   applied to the algorithm names.  A local service should use the
   PRIVATE USE syntax of "servicename@domain".

      byte      SSH_MSG_SERVICE_REQUEST
      string    service name

   If the server rejects the service request, it SHOULD send an
   appropriate SSH_MSG_DISCONNECT message and MUST disconnect.

   When the service starts, it may have access to the session identifier
   generated during the key exchange.

Ylonen &  Lonvick           Standards Track                    [Page 24]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   If the server supports the service (and permits the client to use
   it), it MUST respond with the following:

      byte      SSH_MSG_SERVICE_ACCEPT
      string    service name

   Message numbers used by services should be in the area reserved for
   them (see [[SSH-ARCH](#ref-SSH-ARCH "\"The Secure Shell (SSH) Protocol Architecture\"")] and [[SSH-NUMBERS](#ref-SSH-NUMBERS "\"The Secure Shell (SSH) Protocol Assigned Numbers\"")]).  The transport level will
   continue to process its own messages.

   Note that after a key exchange with implicit server authentication,
   the client MUST wait for a response to its service request message
   before sending any further data.

[11](#section-11).  Additional Messages

   Either party may send any of the following messages at any time.

[11.1](#section-11.1).  Disconnection Message

      byte      SSH_MSG_DISCONNECT
      uint32    reason code
      string    description in ISO-10646 UTF-8 encoding [[RFC3629](/doc/html/rfc3629 "\"UTF-8, a transformation format of ISO 10646\"")]
      string    language tag [[RFC3066](/doc/html/rfc3066 "\"Tags for the Identification of Languages\"")]

   This message causes immediate termination of the connection.  All
   implementations MUST be able to process this message; they SHOULD be
   able to send this message.

   The sender MUST NOT send or receive any data after this message, and
   the recipient MUST NOT accept any data after receiving this message.
   The Disconnection Message 'description' string gives a more specific
   explanation in a human-readable form.  The Disconnection Message
   'reason code' gives the reason in a more machine-readable format
   (suitable for localization), and can have the values as displayed in
   the table below.  Note that the decimal representation is displayed
   in this table for readability, but the values are actually uint32
   values.

Ylonen &  Lonvick           Standards Track                    [Page 25]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

           Symbolic name                                reason code
           -------------                                -----------
      SSH_DISCONNECT_HOST_NOT_ALLOWED_TO_CONNECT             1
      SSH_DISCONNECT_PROTOCOL_ERROR                          2
      SSH_DISCONNECT_KEY_EXCHANGE_FAILED                     3
      SSH_DISCONNECT_RESERVED                                4
      SSH_DISCONNECT_MAC_ERROR                               5
      SSH_DISCONNECT_COMPRESSION_ERROR                       6
      SSH_DISCONNECT_SERVICE_NOT_AVAILABLE                   7
      SSH_DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED          8
      SSH_DISCONNECT_HOST_KEY_NOT_VERIFIABLE                 9
      SSH_DISCONNECT_CONNECTION_LOST                        10
      SSH_DISCONNECT_BY_APPLICATION                         11
      SSH_DISCONNECT_TOO_MANY_CONNECTIONS                   12
      SSH_DISCONNECT_AUTH_CANCELLED_BY_USER                 13
      SSH_DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE         14
      SSH_DISCONNECT_ILLEGAL_USER_NAME                      15

   If the 'description' string is displayed, the control character
   filtering discussed in [[SSH-ARCH](#ref-SSH-ARCH "\"The Secure Shell (SSH) Protocol Architecture\"")] should be used to avoid attacks by
   sending terminal control characters.

   Requests for assignments of new Disconnection Message 'reason code'
   values (and associated 'description' text) in the range of 0x00000010
   to 0xFDFFFFFF MUST be done through the IETF CONSENSUS method, as
   described in [[RFC2434](/doc/html/rfc2434)].  The Disconnection Message 'reason code'
   values in the range of 0xFE000000 through 0xFFFFFFFF are reserved for
   PRIVATE USE.  As noted, the actual instructions to the IANA are in
   [[SSH-NUMBERS](#ref-SSH-NUMBERS "\"The Secure Shell (SSH) Protocol Assigned Numbers\"")].

[11.2](#section-11.2).  Ignored Data Message

      byte      SSH_MSG_IGNORE
      string    data

   All implementations MUST understand (and ignore) this message at any
   time (after receiving the identification string).  No implementation
   is required to send them.  This message can be used as an additional
   protection measure against advanced traffic analysis techniques.

[11.3](#section-11.3).  Debug Message

      byte      SSH_MSG_DEBUG
      boolean   always_display
      string    message in ISO-10646 UTF-8 encoding [[RFC3629](/doc/html/rfc3629 "\"UTF-8, a transformation format of ISO 10646\"")]
      string    language tag [[RFC3066](/doc/html/rfc3066 "\"Tags for the Identification of Languages\"")]

Ylonen &  Lonvick           Standards Track                    [Page 26]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   All implementations MUST understand this message, but they are
   allowed to ignore it.  This message is used to transmit information
   that may help debugging.  If 'always_display' is TRUE, the message
   SHOULD be displayed.  Otherwise, it SHOULD NOT be displayed unless
   debugging information has been explicitly requested by the user.

   The 'message' doesn't need to contain a newline.  It is, however,
   allowed to consist of multiple lines separated by CRLF (Carriage
   Return - Line Feed) pairs.

   If the 'message' string is displayed, the terminal control character
   filtering discussed in [[SSH-ARCH](#ref-SSH-ARCH "\"The Secure Shell (SSH) Protocol Architecture\"")] should be used to avoid attacks by
   sending terminal control characters.

[11.4](#section-11.4).  Reserved Messages

   An implementation MUST respond to all unrecognized messages with an
   SSH_MSG_UNIMPLEMENTED message in the order in which the messages were
   received.  Such messages MUST be otherwise ignored.  Later protocol
   versions may define other meanings for these message types.

      byte      SSH_MSG_UNIMPLEMENTED
      uint32    packet sequence number of rejected message

[12](#section-12).  Summary of Message Numbers

   The following is a summary of messages and their associated message
   number.

         SSH_MSG_DISCONNECT             1
         SSH_MSG_IGNORE                 2
         SSH_MSG_UNIMPLEMENTED          3
         SSH_MSG_DEBUG                  4
         SSH_MSG_SERVICE_REQUEST        5
         SSH_MSG_SERVICE_ACCEPT         6
         SSH_MSG_KEXINIT                20
         SSH_MSG_NEWKEYS                21

   Note that numbers 30-49 are used for kex packets.  Different kex
   methods may reuse message numbers in this range.

[13](#section-13).  IANA Considerations

   This document is part of a set.  The IANA considerations for the SSH
   protocol as defined in [[SSH-ARCH](#ref-SSH-ARCH "\"The Secure Shell (SSH) Protocol Architecture\"")], [[SSH-USERAUTH](#ref-SSH-USERAUTH "\"The Secure Shell (SSH) Authentication Protocol\"")], [[SSH-CONNECT](#ref-SSH-CONNECT "\"The Secure Shell (SSH) Connection Protocol\"")], and
   this document, are detailed in [[SSH-NUMBERS](#ref-SSH-NUMBERS "\"The Secure Shell (SSH) Protocol Assigned Numbers\"")].

Ylonen &  Lonvick           Standards Track                    [Page 27]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

[14](#section-14).  Security Considerations

   This protocol provides a secure encrypted channel over an insecure
   network.  It performs server host authentication, key exchange,
   encryption, and integrity protection.  It also derives a unique
   session ID that may be used by higher-level protocols.

   Full security considerations for this protocol are provided in
   [[SSH-ARCH](#ref-SSH-ARCH "\"The Secure Shell (SSH) Protocol Architecture\"")].

Ylonen &  Lonvick           Standards Track                    [Page 28]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

[15](#section-15).  References

[15.1](#section-15.1).  Normative References

   [SSH-ARCH]     Ylonen, T. and C. Lonvick, Ed., "The Secure Shell
                  (SSH) Protocol Architecture", [RFC 4251](/doc/html/rfc4251), January 2006.

   [SSH-USERAUTH] Ylonen, T. and C. Lonvick, Ed., "The Secure Shell
                  (SSH) Authentication Protocol", [RFC 4252](/doc/html/rfc4252), January
                  2006.

   [SSH-CONNECT]  Ylonen, T. and C. Lonvick, Ed., "The Secure Shell
                  (SSH) Connection Protocol", [RFC 4254](/doc/html/rfc4254), January 2006.

   [SSH-NUMBERS]  Lehtinen, S. and C. Lonvick, Ed., "The Secure Shell
                  (SSH) Protocol Assigned Numbers", [RFC 4250](/doc/html/rfc4250), January
                  2006.

   [RFC1321]      Rivest, R., "The MD5 Message-Digest Algorithm ", [RFC](/doc/html/rfc1321)
                  [1321](/doc/html/rfc1321), April 1992.

   [RFC1950]      Deutsch, P. and J-L. Gailly, "ZLIB Compressed Data
                  Format Specification version 3.3", [RFC 1950](/doc/html/rfc1950), May 1996.

   [RFC1951]      Deutsch, P., "DEFLATE Compressed Data Format
                  Specification version 1.3", [RFC 1951](/doc/html/rfc1951), May 1996.

   [RFC2104]      Krawczyk, H., Bellare, M., and R. Canetti, "HMAC:
                  Keyed-Hashing for Message Authentication", [RFC 2104](/doc/html/rfc2104),
                  February 1997.

   [RFC2119]      Bradner, S., "Key words for use in RFCs to Indicate
                  Requirement Levels", [BCP 14](/doc/html/bcp14), [RFC 2119](/doc/html/rfc2119), March 1997.

   [RFC2144]      Adams, C., "The CAST-128 Encryption Algorithm", [RFC](/doc/html/rfc2144)
                  [2144](/doc/html/rfc2144), May 1997.

   [RFC2409]      Harkins, D. and D. Carrel, "The Internet Key Exchange
                  (IKE)", [RFC 2409](/doc/html/rfc2409), November 1998.

   [RFC2434]      Narten, T. and H. Alvestrand, "Guidelines for Writing
                  an IANA Considerations Section in RFCs", [BCP 26](/doc/html/bcp26), [RFC](/doc/html/rfc2434)
                  [2434](/doc/html/rfc2434), October 1998.

   [RFC2440]      Callas, J., Donnerhacke, L., Finney, H., and R.
                  Thayer, "OpenPGP Message Format", [RFC 2440](/doc/html/rfc2440), November
                  1998.

Ylonen &  Lonvick           Standards Track                    [Page 29]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   [RFC3066]      Alvestrand, H., "Tags for the Identification of
                  Languages", [BCP 47](/doc/html/bcp47), [RFC 3066](/doc/html/rfc3066), January 2001.

   [RFC3447]      Jonsson, J. and B. Kaliski, "Public-Key Cryptography
                  Standards (PKCS) #1: RSA Cryptography Specifications
                  Version 2.1", [RFC 3447](/doc/html/rfc3447), February 2003.

   [RFC3526]      Kivinen, T. and M. Kojo, "More Modular Exponential
                  (MODP) Diffie-Hellman groups for Internet Key Exchange
                  (IKE)", [RFC 3526](/doc/html/rfc3526), May 2003.

   [RFC3629]      Yergeau, F., "UTF-8, a transformation format of ISO
                  10646", STD 63, [RFC 3629](/doc/html/rfc3629), November 2003.

   [FIPS-180-2]   US National Institute of Standards and Technology,
                  "Secure Hash Standard (SHS)", Federal Information
                  Processing Standards Publication 180-2, August 2002.

   [FIPS-186-2]   US National Institute of Standards and Technology,
                  "Digital Signature Standard (DSS)", Federal
                  Information Processing Standards Publication 186-2,
                  January 2000.

   [FIPS-197]     US National Institute of Standards and Technology,
                  "Advanced Encryption Standard (AES)", Federal
                  Information Processing Standards Publication 197,
                  November 2001.

   [FIPS-46-3]    US National Institute of Standards and Technology,
                  "Data Encryption Standard (DES)", Federal Information
                  Processing Standards Publication 46-3, October 1999.

   [SCHNEIER]     Schneier, B., "Applied Cryptography Second Edition:
                  protocols algorithms and source in code in C", John
                  Wiley and Sons, New York, NY, 1996.

   [TWOFISH]      Schneier, B., "The Twofish Encryptions Algorithm: A
                  128-Bit Block Cipher, 1st Edition", March 1999.

[15.2](#section-15.2).  Informative References

   [RFC0894]      Hornig, C., "Standard for the transmission of IP
                  datagrams over Ethernet networks", STD 41, [RFC 894](/doc/html/rfc894),
                  April 1984.

   [RFC1661]      Simpson, W., "The Point-to-Point Protocol (PPP)", STD
                  51, [RFC 1661](/doc/html/rfc1661), July 1994.

Ylonen &  Lonvick           Standards Track                    [Page 30]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

   [RFC2412]      Orman, H., "The OAKLEY Key Determination Protocol",
                  [RFC 2412](/doc/html/rfc2412), November 1998.

   [ssh-1.2.30]   Ylonen, T., "ssh-1.2.30/RFC", File within compressed
                  tarball ftp://ftp.funet.fi/pub/unix/security/
                  login/ssh/ssh-1.2.30.tar.gz, November 1995.

Authors' Addresses

   Tatu Ylonen
   SSH Communications Security Corp
   Valimotie 17
   00380 Helsinki
   Finland

   EMail: ylo@ssh.com

   Chris Lonvick (editor)
   Cisco Systems, Inc.
   12515 Research Blvd.
   Austin  78759
   USA

   EMail: clonvick@cisco.com

Trademark Notice

   "ssh" is a registered trademark in the United States and/or other
   countries.

Ylonen &  Lonvick           Standards Track                    [Page 31]
```

---

```

[RFC 4253](/doc/html/rfc4253)              SSH Transport Layer Protocol          January 2006

Full Copyright Statement

   Copyright (C) The Internet Society (2006).

   This document is subject to the rights, licenses and restrictions
   contained in [BCP 78](/doc/html/bcp78), and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in [BCP 78](/doc/html/bcp78) and [BCP 79](/doc/html/bcp79).

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <http://www.ietf.org/ipr>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is provided by the IETF
   Administrative Support Activity (IASA).

Ylonen &  Lonvick           Standards Track                    [Page 32]

```

[Datatracker](/doc/rfc4253/)

RFC 4253

RFC
- Proposed Standard

* Info
* Contents
* Prefs

| Document | Document type |  | RFC - Proposed Standard  January 2006  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=4253 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") [IPR](/ipr/search/?submit=draft&id=rfc4253 "Click to view IPR declarations.") Updated by [RFC 8268](/doc/html/rfc8268 "More Modular Exponentiation (MODP) Diffie-Hellman (DH) Key Exchange (KEX) Groups for Secure Shell (SSH)"), [RFC 8308](/doc/html/rfc8308 "Extension Negotiation in the Secure Shell (SSH) Protocol"), [RFC 8332](/doc/html/rfc8332 "Use of RSA Keys with SHA-256 and SHA-512 in the Secure Shell (SSH) Protocol"), [RFC 8709](/doc/html/rfc8709 "Ed25519 and Ed448 Public Key Algorithms for the Secure Shell (SSH) Protocol"), [RFC 8758](/doc/html/rfc8758 "Deprecating RC4 in Secure Shell (SSH)"), [RFC 9142](/doc/html/rfc9142 "Key Exchange (KEX) Method Updates and Recommendations for Secure Shell (SSH)"), [RFC 6668](/doc/html/rfc6668 "SHA-2 Data Integrity Verification for the Secure Shell (SSH) Transport Layer Protocol") Was [draft-ietf-secsh-transport](/doc/draft-ietf-secsh-transport/24/) ([secsh WG](/wg/secsh/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [24](/doc/html/draft-ietf-secsh-transport-24) * [RFC 4253](/doc/html/rfc4253) |
|  | Compare versions |  | RFC 4253  draft-ietf-secsh-transport-24  draft-ietf-secsh-transport-23  draft-ietf-secsh-transport-22  draft-ietf-secsh-transport-21  draft-ietf-secsh-transport-20  draft-ietf-secsh-transport-19  draft-ietf-secsh-transport-18  draft-ietf-secsh-transport-17  draft-ietf-secsh-transport-16  draft-ietf-secsh-transport-15  draft-ietf-secsh-transport-14  draft-ietf-secsh-transport-13  draft-ietf-secsh-transport-12  draft-ietf-secsh-transport-11  draft-ietf-secsh-transport-10  draft-ietf-secsh-transport-09  draft-ietf-secsh-transport-08  draft-ietf-secsh-transport-07  draft-ietf-secsh-transport-06  draft-ietf-secsh-transport-05  draft-ietf-secsh-transport-04  draft-ietf-secsh-transport-03  draft-ietf-secsh-transport-02  draft-ietf-secsh-transport-01  draft-ietf-secsh-transport-00   RFC 4253  draft-ietf-secsh-transport-24  draft-ietf-secsh-transport-23  draft-ietf-secsh-transport-22  draft-ietf-secsh-transport-21  draft-ietf-secsh-transport-20  draft-ietf-secsh-transport-19  draft-ietf-secsh-transport-18  draft-ietf-secsh-transport-17  draft-ietf-secsh-transport-16  draft-ietf-secsh-transport-15  draft-ietf-secsh-transport-14  draft-ietf-secsh-transport-13  draft-ietf-secsh-transport-12  draft-ietf-secsh-transport-11  draft-ietf-secsh-transport-10  draft-ietf-secsh-transport-09  draft-ietf-secsh-transport-08  draft-ietf-secsh-transport-07  draft-ietf-secsh-transport-06  draft-ietf-secsh-transport-05  draft-ietf-secsh-transport-04  draft-ietf-secsh-transport-03  draft-ietf-secsh-transport-02  draft-ietf-secsh-transport-01  draft-ietf-secsh-transport-00   Side-by-side  Inline |
|  | Authors |  | [Chris M. Lonvick](/person/lonvick.ietf%40gmail.com "Datatracker profile of Chris M. Lonvick") , [Tatu Ylonen](/person/ylo%40ssh.com "Datatracker profile of Tatu Ylonen")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc4253.txt) [html](https://www.rfc-editor.org/rfc/rfc4253.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc4253.txt.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc4253.html) [bibtex](/doc/rfc4253/bibtex/) |
|  | Additional resources |  | Mailing list discussion |

[Report a datatracker bug](https://github.com/ietf-tools/datatracker/issues/new/choose)

Show sidebar by default

Yes

No

Tab to show by default

Info

Contents

HTMLization configuration

HTMLize the plaintext

Plaintextify the HTML

Maximum font size

Page dependencies

Inline

Reference

Citation links

 Go to reference section

Go to linked document

![](//analytics.ietf.org/piwik.php?idsite=7)



=== Content from h20566.www2.hpe.com_d036b144_20250125_034344.html ===




=== Content from www-01.ibm.com_31119c15_20250125_034338.html ===


[IBM Support](https://www.ibm.com/mysupport/)

##

No results were found for your search query.

---

##### **Tips**

To return expected results, you can:

* **Reduce the number of search terms.** Each term you use focuses the search further.
* **Check your spelling.** A single misspelled or incorrectly typed term can change your result.
* **Try substituting synonyms for your original terms.** For example, instead of searching for "java classes", try "java training"
* **Did you search for an IBM acquired or sold product ?** If so, follow the appropriate link below to find the content you need.

Our apologies

Search results are not available at this time. Please try again later or use one of the other support options on this page.

# Security Bulletin: IBM i is affected by several vulnerabilities (CVE-2016-2183 and CVE-2016-6329)

### Security Bulletin

## Summary

IBM i is vulnerable to several security vulnerabilities. IBM i has addressed these vulnerabilities.

## Vulnerability Details

**CVEID:** [CVE-2016-2183](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-2183)

## Affected Products and Versions

Releases 6.1, 7.1, 7.2 and 7.3 of IBM i are affected.

## Remediation/Fixes

**The issue can be fixed for some applications by applying PTF’s to IBM i. For the remaining applications, follow the steps in the Workarounds and Mitigations section.**

Releases 6.1, 7.1, 7.2 and 7.3 of IBM i are supported and will be fixed.

<http://www-933.ibm.com/support/fixcentral/>

The IBM i PTF numbers are:

**IBM i OS and options:**

Release 6.1 – MF62786, SI62465

Release 6.1.1 – MF62785

Release 7.1 – MF62779, SI62463, SI62623

Release 7.2 – MF62778, SI62464, SI62622

Release 7.3 – MF62780, SI62586, SI62622

5770UME

CIM V1R3M0 supports IBM i 6.1 and 7.1 - SI62358

CIM V1R4M0 supports IBM i 6.1, 7.1, 7.2 and7.3 - SI62412

***Important note:*** *IBM recommends that all users running unsupported versions of affected products upgrade to supported and fixed version of affected products.*

## Workarounds and Mitigations

You should verify applying this configuration change does not cause any compatibility issues. Not disabling the Triple DES (3DES) cipher or algorithm will expose yourself to the attack described above. IBM recommends that you review your entire environment to identify other areas where you have enabled the 3DES cipher or algorithm and take appropriate mitigation and remediation actions. If 3DES must be used, ensure less than 32GB of data is sent or received using the same symmetric key. To accomplish this, end the secure connection and create a new connection or force a re-key operation prior to crossing the 32GB threshold.

**Mitigation instructions for IBM i**:

There are at least four different TLS implementations used on IBM i.

- IBM i System SSL/TLS

- OpenSSL in PASE

- IBMJSSE2 – The default Java JSSE implementation

- Domino – contains an embedded SSL implementation. Also uses System SSL/TLS in some configurations.

- Other – Any 3rd party application could include an internal TLS implementation

**IBM i System SSL/TLS**

IBM i System SSL/TLS is a set of generic services provided in the IBM i Licensed Internal Code (LIC) to protect TCP/IP communications using the SSL/TLS protocol.

System SSL/TLS is accessible to application developers from the following programming interfaces and JSSE implementation:

- Global Security Kit (GSKit) APIs

- Integrated IBM i SSL\_ APIs

- Integrated IBM i JSSE implementation (IBMi5OSJSSEProvider)

TLS applications created by IBM, IBM business partners, independent software vendors (ISV), or customers that use one of the three System SSL/TLS interfaces listed above will use System SSL/TLS. For example, FTP and Telnet are IBM applications that use System SSL/TLS. Not all TLS enabled applications running on IBM i use System SSL/TLS.

System SSL/TLS supports and uses by default up to three 3DES cipher suites based on release level.

\*ECDHE\_ECDSA\_3DES\_EDE\_CBC\_SHA (default in 7.2/7.3 \*TLSV1.2)

\*ECDHE\_RSA\_3DES\_EDE\_CBC\_SHA (default in 7.2/7.3 \*TLSV1.2)

\*RSA\_3DES\_EDE\_CBC\_SHA (default in 6.1/7.1/7.2/7.3 All protocol versions)

The application developer determines which cipher suites/algorithms are supported by the application when it is designed.

- Some applications expose the cipher suite configuration to the end user. For those applications 3DES can be disabled through that application specific configuration.

- Many applications do not provide a configuration option for controlling the cipher suites. It is difficult to determine if these applications support 3DES.

- Many applications use the System SSL/TLS default cipher suites such as FTP and Telnet.

After loading the System SSL/TLS fixes listed in this bulletin, applications coded to use the default values will no longer negotiate the use of 3DES cipher suites with peers.

If 3DES support is required by peers of such an application after this PTF is applied, the values can be added back to the System SSL/TLS eligible default cipher suite list using System Service Tools (SST) Advanced Analysis Command SSLCONFIG. To change the System SSL/TLS settings with the Start System Service Tools (STRSST) command, follow these steps:

1. Open a character based interface.

2. On the command line, type STRSST.

3. Type your service tools user name and password.

4. Select option 1 (Start a service tool).

5. Select option 4 (Display/Alter/Dump).

6. Select option 1 (Display/Alter storage).

7. Select option 2 (Licensed Internal Code (LIC) data).

8. Select option 14 (Advanced analysis).

9. Select option 1 (SSLCONFIG).

10. Enter -h

This will show the help screen that describes the input strings to change the new System SSL/TLS setting for –eligibleDefaultCipherSuites.

System SSL/TLS’s support of 3DES can be completely disabled at the system level using the system value QSSLCSL. In this case, 3DES is disabled for all applications including those with user configuration available for cipher suites.

**How to change the QSSLCSL system value:**

From a 5250 command line:

**WRKSYSVAL SYSVAL(QSSLCSLCTL)**

 Enter 5 to display **QSSLCSLCTL:** This will display one of two things:

 \*OPSYS: Which indicates QSSLCSL is controlled by the OS.

 \*USRDFN: Which indicates QSSLCSL is editable and controlled by the user.

 If current value is \*OPSYS; Enter 2 to edit **QSSLCSLCTL:** \*OPSYS is the default value. Change the value to \*USRDFN.

**WRKSYSVAL SYSVAL(QSSLCSL)**

 Enter 5 to display **QSSLCSL:** This will display the current ordered list of cipher suites.

 If a cipher suite is in the list that contains the 3DES keyword; Enter 2 to edit **QSSLCSL:**

 To remove a cipher suite, space over cipher suite name. Press Enter.

**QSSLCSL value recommendation at the time of publish by release:**

R730

\*ECDHE\_ECDSA\_AES\_128\_GCM\_SHA256

\*ECDHE\_ECDSA\_AES\_256\_GCM\_SHA384

\*ECDHE\_RSA\_AES\_128\_GCM\_SHA256

\*ECDHE\_RSA\_AES\_256\_GCM\_SHA384

\*RSA\_AES\_128\_GCM\_SHA256

\*RSA\_AES\_256\_GCM\_SHA384

\*ECDHE\_ECDSA\_AES\_128\_CBC\_SHA256

\*ECDHE\_ECDSA\_AES\_256\_CBC\_SHA384

\*ECDHE\_RSA\_AES\_128\_CBC\_SHA256

\*ECDHE\_RSA\_AES\_256\_CBC\_SHA384

\*RSA\_AES\_128\_CBC\_SHA256

\*RSA\_AES\_128\_CBC\_SHA

\*RSA\_AES\_256\_CBC\_SHA256

\*RSA\_AES\_256\_CBC\_SHA

R720

\*ECDHE\_ECDSA\_AES\_128\_GCM\_SHA256

\*ECDHE\_ECDSA\_AES\_256\_GCM\_SHA384

\*ECDHE\_RSA\_AES\_128\_GCM\_SHA256

\*ECDHE\_RSA\_AES\_256\_GCM\_SHA384

\*RSA\_AES\_128\_GCM\_SHA256

\*RSA\_AES\_256\_GCM\_SHA384

\*ECDHE\_ECDSA\_AES\_128\_CBC\_SHA256

\*ECDHE\_ECDSA\_AES\_256\_CBC\_SHA384

\*ECDHE\_RSA\_AES\_128\_CBC\_SHA256

\*ECDHE\_RSA\_AES\_256\_CBC\_SHA384

\*RSA\_AES\_128\_CBC\_SHA256

\*RSA\_AES\_128\_CBC\_SHA

\*RSA\_AES\_256\_CBC\_SHA256

\*RSA\_AES\_256\_CBC\_SHA

R710

\*RSA\_AES\_128\_CBC\_SHA256 (requires TR6 or later is installed and \*TLSv1.2)

\*RSA\_AES\_128\_CBC\_SHA

\*RSA\_AES\_256\_CBC\_SHA256 (requires TR6 or later is installed and \*TLSv1.2)

\*RSA\_AES\_256\_CBC\_SHA

R611 / R610

\*RSA\_AES\_128\_CBC\_SHA

\*RSA\_AES\_256\_CBC\_SHA

**Application configuration through Digital Certificate Manager (DCM)**

7.1 TR6, 7.2 and 7.3 have DCM options for controlling the cipher suites used for specific applications such as Telnet and FTP. Applications with a DCM application definition can use the DCM Update Application Definition panel to configure which cipher suites are supported by the application. If the DCM value includes a cipher suite disabled by QSSLCSL, that cipher suite value will silently be discarded by System SSL/TLS.

For IBM HTTP Server for i, the cipher suite version cannot be controlled by the DCM application ID.

**IBM i Virtual Private Networking**

The VPN key manager uses two distinct phases in its implementation. IKE phase 1 establishes the keys that protect the messages that flow in the subsequent phase 2 negotiations. The Internet Key Exchange (IKE) policy defines what level of authentication and encryption protection IKE uses during phase 1 negotiations. A data policy defines what level of authentication or encryption protects data as it flows through the VPN. The communicating systems agree on these attributes during the IKE protocol phase 2 negotiations.

The Sweet 32 vulnerability affects VPN connection configurations where the data policy is configured to use the 3DES encryption algorithm. There are two options to mitigate this configuration.

1. Modify the data policy to use AES instead of Triple DES (3DES). Consider changing the IKE policy to use AES if R710 or newer.

2. Set the attribute lifesize for the data policy to less than 32GB.

**How to replace 3DES with AES in data policy:**

The Triple DES (3DES) encryption algorithms should be replaced with an AES algorithm in existing data policy configurations. The default IBM® Universal Connection VPN configuration is a configuration that uses 3DES for encryption in the IKE policy and the data policy.

To check if a VPN data policy is using 3DES and change the encryption algorithm, follow these steps:

1. In IBM Navigator for i, expand Network > IP Policies > Virtual Private Networking and click IP Security Policies.

2. Right-click Data Policies and select Open.

3. Right-click on the data policy you want to check and select Properties.

4. Click on the Proposals tab.

5. Select any of the data protection proposals that are using the ESP protocol and click Edit.

6. Click on the Transforms tab.

7. Select any transforms from the list that use the ESP protocol and click Edit.

8. If the Encryption algorithm has the value 3DES, your VPN configuration is affected by this security vulnerability.

9. To change the encryption algorithm, select AES from the Encryption algorithm drop-down menu, and click OK.

**How to change the lifesize attribute in a data policy:**

VPN attributes data policy key lifetime and/or lifesize control how frequently encryption keys are negotiated. Phase 1 negotiations are negotiated once a day, while phase 2 negotiations are refreshed every 60 minutes or as often as every five minutes. Phase 2 negotiations can also be refreshed based on size limits. Setting a data size limit smaller than 32GB results in new encryption keys being generated and used thereby mitigating Sweet 32.

To change the value of the data policy key lifetime or lifesize, follow these steps:

1. In IBM Navigator for i, expand Network > IP Policies > Virtual Private Networking and click IP Security Policies.

2. Right-click Data Policies and select Open.

3. Right-click on the data policy you want to check and select Properties.

4. Click on the Proposals tab.

5. Select any of the data protection proposals that are using the ESP protocol and click Edit.

6. Click on the General tab.

7. Set the key lifetime in the Expire after field. The default is 1 hour.

8. Set the key lifesize in the Expire at size limit field. The default is no size limit.

**How to replace 3DES with AES in IKE policy:**

<AES is only available in R710 and newer releases>

The amount of data encrypted with the IKE policy 3DES key is under 32GB making its replacement optional. To check if VPN IKE policy is using 3DES and change the encryption algorithm, follow these steps:

1. In IBM Navigator for i, expand Network > IP Policies > Virtual Private Networking and click IP Security Policies.

2. Right-click Internet Key Exchange Policies and select Open.

3. Right-click on the IKE policy you want to check and select Properties.

4. Click on the Transforms tab.

5. If any of the transforms in the list has the value 3DES in the Encryption Algorithm column, your VPN configuration is affected by this security vulnerability.

6. To change the encryption algorithm, select a transform from the list that uses 3DES and click Edit.

7. Select AES-CBC from the Encryption algorithm drop-down menu, and click OK.

## Get Notified about Future Security Bulletins

Subscribe to [My Notifications](https://www.ibm.com/support/pages/node/718119) to be notified of important product support alerts like this.

### References

[Complete CVSS v2 Guide](http://www.first.org/cvss/v2/guide "Link resides outside of ibm.com")

[On-line Calculator v2](http://nvd.nist.gov/CVSS-v2-Calculator "Link resides outside of ibm.com")

[Complete CVSS v3 Guide](http://www.first.org/cvss/user-guide "Link resides outside of ibm.com")

[On-line Calculator v3](http://www.first.org/cvss/calculator/3.0 "Link resides outside of ibm.com")

Off

## Related Information

[IBM Secure Engineering Web Portal](http://www.ibm.com/security/secure-engineering/bulletins.html)

[IBM Product Security Incident Response Blog](http://www.ibm.com/blogs/psirt)

## Acknowledgement

None

\*The CVSS Environment Score is customer environment specific and will ultimately impact the Overall CVSS Score. Customers can evaluate the impact of this vulnerability in their environments by accessing the links in the Reference section of this Security Bulletin.

## Disclaimer

Review the [IBM security bulletin disclaimer and definitions](https://www.ibm.com/support/pages/node/6610583#disclaimer) regarding your responsibilities for assessing potential impact of security vulnerabilities to your environment.

[{"Type":"MASTER","Line of Business":{"code":"LOB68","label":"Power HW"},"Business Unit":{"code":"BU070","label":"IBM Infrastructure"},"Product":{"code":"SWG60","label":"IBM i"},"ARM Category":[{"code":"a8m0z0000000CT6AAM","label":"Security-\u003EPSIRT CVE"}],"ARM Case Number":"","Platform":[{"code":"PF012","label":"IBM i"}],"Version":"6.1.0;7.1.0;7.2.0;7.3.0"}]

## Was this topic helpful?

### Document Information

**Modified date:**

04 October 2024

## UID

nas8N1021697

Page Feedback

## Share your feedback

### Need support?

* Submit feedback to IBM Support
* 1-800-IBM-7378 (**USA**)
* [Directory of worldwide contacts](//www.ibm.com/planetwide/index.html#region)



=== Content from eprint.iacr.org_312a5dc2_20250126_054630.html ===
A Cryptographic Tour of the IPsec Standards

Kenneth G. Paterson,
Information Security Group,
Royal Holloway, University of London,
Egham, Surrey, TW20 0EX, UK
kenny.paterson@rhul.ac.uk

Abstract

In this article, we provide an overview of cryptography and cryptographic key man-
agement as they are speciﬁed in IPsec, a popular suite of standards for providing commu-
nications security and network access control for Internet communications. We focus on
the latest generation of the IPsec standards, recently published as Request for Comments
4301–4309 by the Internet Engineering Task Force, and how they have evolved from earlier
versions of the standards.
Keywords: IP; IPsec; network security; cryptography; key management.

1 Introduction

IPsec provides security at the IP network layer of the TCP/IP protocol stack. This means
that all IP packets can be protected, irrespective of the upper layer protocol being carried in
the packet payloads, and that no re-engineering of applications is required in order to take
advantage of the security provided by IPsec. The security provided by IPsec can also be
made transparent to end users. For these reasons, IPsec forms the basis of many Virtual
Private Networking (VPN) solutions, where it is used to provide security for communications
over an untrusted network such as the Internet. IPsec has also been used by many vendors
to build Remote Access Solutions (RAS), allowing organizations to control the access of
roaming users to internal networks and hosts.
IPsec has seen widespread deployment in
recent years. For example, implementations of IPsec exist in Microsoft Windows 2000 and
XP, HP’s proprietary operating system HPUX, IBM’s AIX operating system, and in the
Linux kernel. Several other open source projects are also developing IPsec implementations
and IPsec is now widely supported in commercial networking hardware. IPsec is mandatory
in IPv6 (though we will focus on IPsec in IPv4 in this article).

IPsec is formally speciﬁed in a number of “standards” each of which is known as a Request
For Comments (RFC) and is published by the Internet Engineering Task Force (IETF). They
are all freely available from the IETF website at www.ietf.org. The majority of these
IPsec documents are a result of a collaborative process coordinated by the IETF’s IPsec
working group. The ﬁrst two generations of these documents (principally RFCs 1825–1829,
published in 1995, and 2401–2412, published in 1998) are really only intended to provide a
guide for implementors and are notoriously complex, diﬃcult to interpret and lacking in overall
structure. Ferguson and Schneier [39] provide a detailed critique of these and other perceived
ﬂaws in the IPsec standards. This lack of clarity has arguably hampered the adoption of

1

IPsec, in particular because of its impact on the interoperability of diﬀerent vendors’ IPsec
implementations. The interested reader is invited to consult [38, 42] for introductions to
IPsec that are more accessible than the RFCs themselves. The third and latest incarnation
of the core IPsec standards were published as RFCs 4301–4309 in December 2005, and are
somewhat more accessible. RFC 4301 [21], the architectural document for IPsec, gives a good
overview of the design goals and the overall architecture of IPsec. However, the new RFCs
are still a long and complex set of documents, totalling over 300 pages.

The set of security services oﬀered by IPsec includes access control, connectionless in-
tegrity, data origin authentication, detection and rejection of replays (a form of partial se-
quence integrity), conﬁdentiality (via encryption), and limited traﬃc ﬂow conﬁdentiality.
These are all delivered using symmetric key techniques. The IPsec protocols also support au-
tomated key management, with key exchange protocols using both symmetric and asymmetric
cryptographic techniques. Whilst commonly viewed as providing integrity and conﬁdentiality
services for data in transit, Section 3.1 of RFC 4301 makes it clear that the primary purpose
of IPsec is to provide a form of access control for network traﬃc, by deﬁning a boundary
at which IP packets can be compared to IPsec policies, and either cross the boundary un-
changed, have IPsec security mechanisms applied, or be discarded altogether. The eﬀect of
this IPsec processing, determined by policy, is to create a ﬂexible method of implementing
traﬃc separation and allow a limited form of ﬁrewalling.

In this paper, we discuss cryptography and cryptographic key management in the latest
versions of the IPsec standards and attempt to explain the ways in which these aspects have
developed from the earlier generations of standards.
In particular, we trace the evolution
of integrity protection and encryption mechanisms in IPsec, seeing how new algorithms have
been adopted and how authenticated encryption is now an integral part of IPsec. We examine
how IPsec handles key management via security policy, security associations and the IKE
(and now IKEv2) key exchange protocol. We also comment on some of the ways in which
cryptography in IPsec might develop in future.

Readers should bear in mind that the scope of this article is actually rather narrow:
cryptography is an important component of IPsec, but it is only one of many aspects of a
complex system of interacting components. Nor is our coverage of cryptography in IPsec
comprehensive: only the RFCs tell the whole story.

2 Basic IPsec Concepts and Terminology

The IPsec protocols can be deployed in two basic modes: tunnel and transport. In tunnel
mode cryptographic protection is provided for entire IP packets. In essence, a whole packet
plus security ﬁelds is treated as the new payload of an outer IP packet, with its own header,
called the outer header. The original, or inner, IP packet is said to be encapsulated within the
outer IP packet. In tunnel mode, IPsec processing is typically performed at security gateways
on behalf of endpoint hosts. The gateways could be perimeter ﬁrewalls or routers. The use
of gateways means that hosts need not be IPsec-aware, but that security is provided from
gateway-to-gateway rather than in an end-to-end fashion. By contrast, in transport mode,
the header of the original packet itself is preserved, some security ﬁelds are inserted, and
the payload together with some header ﬁelds undergo cryptographic processing. Transport
mode is typically used when end-to-end security services are needed, and provides protection
mostly for the packet payload. In either mode, one can think of the IPsec implementation as

2

intercepting normal IP packets and performing processing on them before passing them on
(to the network interface layer in the case of outbound processing, or to the upper layers in
the case of inbound processing).

There are two main IPsec protocols which specify the actual cryptographic processing
applied to packets. These are called Authentication Header (AH) and Encapsulating Security
Payload (ESP). AH provides integrity protection, data origin authentication and anti-replay
services for packets through the application of MAC algorithms and the inclusion of sequence
numbers in packets. AH is discussed in more detail in Section 3. ESP provides similar services
to AH (though the coverage of integrity protection is more limited) and in addition provides
conﬁdentiality and traﬃc ﬂow conﬁdentiality services through symmetric key encryption and
variable length padding of packets. ESP is discussed in more detail in Section 4.

IPsec policy acts in concert with these modes and protocols to determine the actual
protocols (ESP or AH), modes of processing (tunnel or transport), algorithms, keys, and other
cryptographic parameters which are used to cryptographically transform packets. Multiple
nested layers of IPsec processing are allowed, and through this, complex transform sets can
be built up. The topic of policy for IPsec is a large one and mostly beyond the scope of
this article. However, we will need some of the basic concepts later when discussing key
management aspects of IPsec. Essentially, each IPsec implementation contains a Security
Policy Database (SPD), each entry of which deﬁnes processing rules for certain types of
traﬃc. Each entry in the SPD points to one or more Security Associations (SAs) (or the need
to establish new SAs). In turn, each SA gives the detailed parameters needed to determine
the actual processing to be applied to an IP packet. Thus, IP packets are intercepted and
compared to the SPD, each match with an SPD entry identiﬁes a policy and a collection of
SAs that implement the policy, and these SAs are “applied” to the packets. For more details
of this process, the reader should consult RFC 4301 [21].

Naturally, appropriate and consistent entries in SPDs need to be in place at communicating
endpoints before the security available in IPsec can be aﬀorded to packets. The SAs that
determine actual processing also need to be put in place at the endpoints. The SAs contain
(amongst other information) cryptographic keys, intialization vectors and anti-replay counters
for AH and ESP, and so we have stumbled across the IPsec key management problem. This
problem can be solved manually, and this approach works well for small-scale deployments
or testing purposes. However, for larger scale and more robust use of IPsec, an automated
method is needed. The Internet Key Exchange (IKE) Protocol provides the preferred method
for SA negotiation and associated cryptographic parameter establishment. The latest version
of IKE, named IKEv2, provides a ﬂexible set of methods for authentication and establishment
of keys and other parameters, supporting both asymmetric and symmetric cryptographic
methods. IKEv2 supersedes the original version of IKE speciﬁed in [9, 10, 11]. We examine
IKEv2 and its evolution from the original IKE in Section 5.

2.1 IPsec document roadmap

As we have noted above, the IPsec documents are many, long and complex. We provide here
a summary of the contents of RFCs 4301-4309 as a handy reference point. Our summary is
extended from the one given in [21].

• Security architecture – RFC 4301 [21], explaining the architecture and components of

IPsec and their interactions, as well as providing the overall philosophy of IPsec.

3

• Security protocols – RFCs 4302 [22] and 4303 [23], describing the AH and ESP protocols.

• Automated key management – RFC 4306 [26] deﬁning IKEv2.

• Cryptographic algorithms for integrity and encryption – RFC 4305 [25], deﬁning the
mandatory, default algorithms for use with AH and ESP, plus a separate RFC for each
cryptographic algorithm, e.g. RFC 4309 [29].

• Cryptographic algorithms and parameters for key exchange – RFC 4307 [27], deﬁning
the mandatory algorithms for use with IKEv2, and RFC 4304 [24], describing how
extended sequence numbers can be negotiated in IKE.

• Cryptographic suites – RFC 4308 [28] providing recommendations for collections of

algorithms (or suites) that can be adopted by system administrators.

The above list illustrates an important cryptographic design principle in IPsec: the sepa-
ration of protocols (such as ESP, AH and IKEv2) from the algorithms used in those protocols.
The speciﬁcation of mandatory algorithms is needed to ensure interoperability and ease de-
ployment, but the intention is that RFCs 4305 and 4307 will be updated from time-to-time
to reﬂect the state-of-the-art in cryptography. The separation means that any updating can
be done without necessitating any changes to the “core” IPsec protocols. The ﬁrst genera-
tion of IPsec RFCs did not feature this separation: the process of separating protocols and
algorithms was begun in the second generation of IPsec RFCs and completed in the third.

3 Authentication Header

The new version of AH is speciﬁed in RFC 4302 [22] and is little changed from the previous
version in RFC 2402 [4]. Essentially, it provides integrity protection and data origin authen-
tication for as much of the IP packet as is possible using a MAC algorithm. It also provides
an optional anti-replay service. Certain ﬁelds of the IP packet header cannot be input to the
MAC calculation because they may change during the packet’s transit across a network and
so are unpredictable to the receiver. The AH protocol adds its cryptographic protection by
inserting a bit sequence called the Authentication Header into IP packets; this header has
the particular format shown in Figure 1. We discuss the most important of these ﬁelds in the
remainder of this section and give brief notes on the other ﬁelds. Detailed discussion of all
the ﬁelds can be found in [22, Section 2].

3.1 AH Integrity Check Value Field and MAC algorithms

The Authentication Header contains an Integrity Check Value (ICV) or MAC value. Since
the scope of the MAC calculation includes both the IP packet header and the Authentication
Header containing the MAC value, the mutable ﬁelds and the MAC value are both set to zero
for the purposes of MAC calculation and conﬁrmation.

The length of the MAC depends on the particular MAC algorithm in use. Restrictions
are that the MAC value must be an integral number of 32 bits in length and that the overall
authentication header must be a multiple of 32 bits in length for IPv4, or a multiple of 64 bits
in length for IPv6. A MAC value of 96 bits ensures that these criteria are all satisﬁed; oth-
erwise some form of additional padding may be needed, which would potentially be wasteful
of precious non-payload bytes.

4

2

3

1

|

Payload Len

0
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Next Header
|
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
|
|
+
|
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Integrity Check Value-ICV (variable)

Security Parameters Index (SPI)

Sequence Number Field

RESERVED

Figure 1: AH format according to RFC 4302 [22].

RFC 4302 does not specify any MAC algorithms itself. As with RFC 2402, this task is
deferred to subsequent RFCs. RFC 4305 [25] speciﬁes a number of MAC algorithms which
are mandatory to implement for AH, or which may become mandatory in future. These are
listed in Table 1. Notice that all three entries in this table refer to MAC algorithms with 96
bit outputs. Two of the MAC algorithms rely on the HMAC construction of RFC 2104 [2]
(see also [32]), while the third uses a mode of operation of AES [48].

The second column of this table refers to the extent to which AH implementations are
required to implement the various algorithms. The exact meanings of these entries are deﬁned
in [25]; the modiﬁer “+” on “SHOULD” means that the requirement is likely to become a
“MUST” at some future point. One change to note from RFC 2402 is that HMAC-MD5-96
has moved from a “MUST” implement to a “MAY” implement, reﬂecting weaknesses that
have recently become apparent in the MD5 hash algorithm [53], even though these attacks do
not currently appear to weaken the security of HMAC based on MD5. It is notable though
that support for HMAC-SHA1-96 is still a “MUST”, even after recent cryptanalytic results
concerning SHA-1 [54] and when NIST has indicated that SHA-1 be gradually phased out of
use in US Federal applications [47]. We expect to see the newer generation of SHA algorithms
(SHA-256, SHA-384, and SHA-512) appearing in IPsec-related RFCs in future. Additional
algorithms are certainly allowed. For example, a fourth MAC algorithm HMAC-RIPEMD-
160-96 is speciﬁed for use with AH in RFC 2857 [14] but not mandated for support in [25].

All of the above mandated algorithms have a 96 bit MAC value, which may seem a little
short given the expected lifetime of the IPsec standards. However, as have noted above, the
choice of MAC output lengths is constrained in various ways, and a 96 bit output probably
represents a reasonable compromise between competing demands of security and minimization
of packet overheads.

3.2 AH Sequence Number Field

The Sequence Number Field is used to provide an optional anti-replay service. The service
operates roughly as follows (both for AH and for ESP when an integrity service is oﬀered by
ESP). When an AH SA is ﬁrst established and the anti-replay service is selected, a counter

5

Algorithm
HMAC-SHA1-96
AES-XCBC-MAC-96
HMAC-MD5-96

Requirement Key size (bits) Output size (bits)

MUST
SHOULD+
MAY

160
128
128

96
96
96

Reference
RFC 2404 [6]
RFC 3566 [16]
RFC 2403 [5]

Table 1: Mandatory MAC algorithms for AH speciﬁed in RFC 4305

stored in the SA is set to zero. It is then incremented for each packet that is processed by
that SA, and the least signiﬁcant 32 bits are inserted in the Sequence Number Field. The
recipient maintains a sliding window of recently received sequence number values, and accepts
only those packets whose sequence number lies within the window and which are not marked
as having already been received. Only if the sequence number test passes does the MAC
veriﬁcation take place. The reason to use a sliding window instead of just a single counter at
the recipient is that packets frequently arrive out of order in IP networks, and so rejecting all
“old” packets would have a severe performance impact, with many packets being dropped.
The fact that the Sequence Number Field is protected by a MAC means that it is infeasible
for an attacker to construct a packet that will be accepted as both recent (within the window)
and valid (having a correct MAC). Note that even though anti-replay is an optional service,
the Sequence Number Field must be included in AH. The receiver may simply choose to
ignore it.

There are signiﬁcant diﬀerences in the handling of sequence numbers in RFC 2402 and
RFC 4302. The counters used in RFC 2402 are only 32 bits long, so the entire counter is
transmitted in the Authentication Header. An overﬂow of the counter is not allowed, and
an attempt to transmit a packet that would result in an overﬂow is an auditable event if
anti-replay has been selected. Instead, typical behaviour is for the sender to anticipate the
overﬂow and attempt to establish a new SA ahead of this event. RFC 4302 allows an optional
Extended Sequence Number (ESN) to be used. This is helpful in high-speed networks, where
a 32-bit counter could easily overﬂow during normal operations. ESNs are 64 bits long, and
the entire 64 bits is used in the MAC calculation by AH even though only the least signiﬁcant
32 bits of the ESN are carried in the Sequence Number Field. For the purposes of MAC
calculation, the most signiﬁcant 32 bits are placed after the payload, meaning that the ESN
is actually split into two parts rather than appearing as a sequence of 64 consecutive bits in
the input to the MAC. This is somewhat unusual, but does allow the AH format to remain the
same as that speciﬁed in RFC 2402 when 32 bit sequence numbers are used. The transmission
of only half the ESN in AH leads to the need for a synchronization mechanism in the event
that more than 232 consecutive packets are lost. This is addressed in [22, Appendix B3]. RFC
4302 indicates that the default setting is to use ESNs rather than 32 bit sequence numbers;
RFC 4304 [24] explains how IKE can be modiﬁed to allow negotation of ESNs.

3.3 Other ﬁelds in AH

The Next Header ﬁeld in AH is a one byte (8-bit) ﬁeld indicating the type of the payload
following the Authentication Header. For example, a value of 4 indicates that what follows
is an IPv4 packet, while a value of 6 indicates TCP.

The Payload Length ﬁeld indicates the length of the Authentication Header in 32-bit
words, minus 2. It is needed because the header can contain a MAC value of variable length.

6

The Security Parameters Index (SPI) ﬁeld is a 32 bit value identifying the SA that was
used during outbound AH processing. The SPI is shared between sender and recipient at
the time of SA establishment and allows the recipient to quickly obtain the cryptographic
parameters necessary to perform inbound processing.

3.4 The future of AH

As we shall see below, the cryptographic services provided by AH can also largely be provided
by ESP (with one notable diﬀerence being the reduced coverage of integrity protection in
ESP). Since ESP can also provide conﬁdentiality services that AH cannot, one might expect
to see AH playing a diminishing role in IPsec in future. Indeed this duplication led Ferguson
and Schneier to suggest that AH be eliminated altogether as early as 1999 [39]. The NIST
guide to IPsec VPNs [42] notes that some IPsec implementations no longer support AH, and
according to RFC 4301 [21], “Support for AH has been downgraded to MAY because experience
has shown that there are very few contexts in which ESP cannot provide the requisite security
services.” Thus support for AH is no longer a required part of IPsec implementations.

4 Encapsulating Security Payload

The new version of ESP is speciﬁed in RFC 4303 [23]. There have been some quite signiﬁcant
changes to the cryptographic elements of ESP since the previous version in RFC 2406 [8]
and the ﬁrst version in RFC 1827 [1]. The major innovation in RFC 4303 is the inclusion of
support for what are called combined mode algorithms. These are cryptographic transforms
that oﬀer both conﬁdentiality and integrity services in one package, more commonly called
authenticated encryption algorithms in the cryptographic literature. As with RFC 2406,
RFC 4303 also allows the use of one or both (but not neither) of an encryption algorithm
and a MAC algorithm. By contrast, RFC 1827 only included support for encryption in ESP,
with integrity protection coming from AH. We will discuss integrity protection in ESP in
more detail in Section 4.4, and combined mode algorithm support in Section 4.5. Another
diﬀerence from earlier versions of ESP is that RFC 4303 includes mechanisms for arbitrary
length traﬃc padding as well as generation and processing of dummy packets. These features
allow for limited traﬃc ﬂow conﬁdentiality, and we discuss them in Section 4.3. Before all
that, however, we begin with discussion of encryption in ESP (Section 4.1) and of how ESP
handles sequence numbers (Section 4.2).

4.1 ESP encryption

It is clear from the evolution of ESP that its primary purpose is to provide a conﬁdentiality
service. In transport mode, ESP encryption transforms an IP packet by encrypting speciﬁed
parts of the packet and then inserting an ESP header and an ESP trailer into the packet.
In tunnel mode, the operation is similar, except that the encrypted portion includes the
entire inner packet and a new outer header is created. The resulting output (excluding the
packet header) is illustrated in Figure 2. Note, however, that this diagram does not apply for
combined mode algorithms, which may not have explicit IV or ICV ﬁelds, for example.

The ESP header consists of the SPI and Sequence Number Fields. This is followed by
the IV (if any) and the encrypted data. The scope of encryption includes any padding, the
Pad Length ﬁeld and the Next Header ﬁeld. The ICV (MAC value), if present, comes last.

7

3

1

2

IV (optional)

Sequence Number

Rest of Payload Data

Security Parameters Index (SPI)

0
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--------
^e
|
| ^ p
|n
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | a
|c
| | y
|
|r
~ | l
~
|y
|
| | o
|p
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | a
+
|t
| v d
TFC Padding * (optional, variable)
|
|
|i
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---
+-+-+-+-+-+-+-+-+
|o
|
|
|n
+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
v
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--------
|
|
~
~
|
|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
|

Integrity Check Value-ICV

Padding (0-255 bytes)

| Next Header

(variable)

(variable)

Pad Length

Figure 2: ESP format according to RFC 4303 [23], modiﬁed to show scope of encryption.

8

Algorithm
NULL
TripleDES-CBC
AES-CBC
AES-CTR
DES-CBC

Requirement
MUST
MUST−
SHOULD+
SHOULD
SHOULD NOT

Key size (bits) Block size (bits)

0
192
128
128
56

N/A
64
128
N/A
64

Reference
RFC 2410 [12]
RFC 2451 [13]
RFC 3602 [17]
RFC 3686 [19]
RFC 2405 [7]

Table 2: Mandatory encryption algorithms for ESP speciﬁed in RFC 4305

The Security Parameters Index (SPI) ﬁeld in the ESP header is used in the same way as the
SPI ﬁeld in AH. The same is true of the Next Header ﬁeld. We will discuss ESP sequence
numbers in Section 4.2 and the ICV ﬁeld in Section 4.4.

As with RFC 4302, RFC 4303 does not discuss any speciﬁc encryption algorithms. How-
ever, RFC 4305 [25] speciﬁes a number of encryption algorithms which are now mandatory
to implement for ESP and these are listed in Table 2. Other algorithms are allowed. For
example, RFC 2451 [13] speciﬁes a number of other algorithms that could be used with ESP,
while [30] is an RFC describing how the block cipher Camellia can be used with ESP.

Some comments on Table 2 are in order. Since ESP encryption is optional, support for
the “NULL” algorithm is required. This algorithm is speciﬁed in its own RFC, RFC 2410, a
document which has some amusement value. Concerning DES-CBC, RFC 4305 states: “DES,
with its small key size and publicly demonstrated and open-design special-purpose cracking
hardware, is of questionable security for general use.” Our view is that this statement itself
is questionable: 56 bits of security is adequate for many everyday applications, DES is still
a broadly trusted algorithm, and inclusion of only algorithms with longer key lengths could
potentially raise export control issues. Support for TripleDES-CBC is rated “MUST−”,
meaning that it is likely to be down-graded in future. This is the only algorithm in the list
for which the RFCs state that a key larger than 128 bits must be supported, but the use of
TripleDES with 48 rounds of encryption usually imposes a performance penalty. Therefore
it would seem prudent to promote another high-strength algorithm (say AES-CBC with 256
bit keys) to “MUST”, whether or not the down-grading of TripleDES-CBC takes place. RFC
3686 states that if AES-CTR is used in ESP, then it must be accompanied by a non-NULL
integrity protection algorithm. This is because AES-CTR uses a mode of operation of AES
to create a stream cipher, and so is consequently vulnerable to simple plaintext manipulation
without some additional integrity protection.

As is apparent from Figure 2, two types of padding may be present in an ESP-protected
packet. We will discuss TFC padding in Section 4.3. The remaining padding is included
so that the total number of bytes in the processed sequence is a multiple of the number of
bytes in a block of the encryption algorithm (for example, 8 for DES and 16 for AES). It is
permissable for the padding to be of variable length and to extend over multiple blocks. This
might aid in preventing traﬃc analysis. The Pad Length ﬁeld must be included and indicates
the total number of padding bytes (excluding the Pad Length byte itself). An ESP encryption
algorithm may specify its own padding rule; otherwise a default rule is speciﬁed in [23, Section
2.4]. According to RFC 4303, when this rule is used, the receiver should inspect the padding
ﬁelds, but the RFC does not specify what should happen in the event of an error. Possible
actions involve dropping the packet silently, logging an error, or even reporting an error to
the sender. However, it can be inferred from the text of [23, Section 2.4] that the oﬀending

9

packet should at least be dropped. We know of one IPsec implementation (the Linux kernel
implementation) where the padding is inspected but no action taken in the event of an error.
Work of Vaudenay [52] and Canvel et al. [37] shows that improper handling of padding errors
can undermine security.

4.2 ESP Sequence Number Field

Sequence numbers, including Extended Sequence Numbers (ESNs), are treated in largely the
same way in RFC 4303 as they are in the AH RFC, RFC 4302. In particular, their use by the
receiver is optional, but their inclusion in ESP headers is mandatory. The only real diﬀerence
is that sequence numbers must be ignored by the recipient if the relevant ESP SA speciﬁes
the NULL integrity protection algorithm (in other words, if the SA only oﬀers encryption).
In this situation, ESP cannot oﬀer an anti-replay service. If a combined mode algorithm is
in use, the most signiﬁcant bits of an ESN may actually be transmitted; if separate integrity
and encryption algorithms are used, these bits are not transmitted, but are included in the
MAC calculation by placing them in the ESP trailer, so they are split into two parts (as in
AH).

4.3 Traﬃc ﬂow conﬁdentiality

ESP in RFC 4303 now has two mechanisms for providing traﬃc ﬂow conﬁdentiality, that is,
the provision of spurious traﬃc to frustrate an attacker’s attempts to gather information from
the mere existence of IPsec protected traﬃc, or from statistics concerning that traﬃc. These
mechanisms are variable length padding and dummy packets.

As we’ve seen above, the ESP padding is limited to 255 bytes, and this may not be
suﬃcient to meet traﬃc ﬂow conﬁdentiality requirements. Section 2.7 of RFC 4303 outlines
how special padding, called TFC padding, can be inserted after the payload data. This is in
addition to the normal ESP padding. However, TFC padding can only be used if the receiver
is able to unambiguously remove it using information about the proper payload length that
is embedded in the payload itself. This will be possible, for example, in tunnel mode, where
the Total Length ﬁeld in the inner packet header gives the needed information.

Dummy packets can be indicated simply by using 59 for the protocol value in the Next
Header ﬁeld and otherwise creating a normal ESP header and trailer. (Recall that the Next
Header ﬁeld will be encrypted if encryption is selected, and so is hidden from the attacker.)
Traditionally, this ﬁeld indicated “No next header”. According to RFC 4303, a receiver must
discard any such packet without generating an error message.

The earlier version of ESP in RFC 2406 supported neither of these mechanisms, but did
allow variable length padding up to a maximum of 255 bytes as part of the ESP encryption
process.

4.4 Integrity protection in ESP

As we have noted above, the original version of ESP in RFC 1827 included only support for
encryption and not integrity protection. Work of Bellovin [35] was inﬂuential in persuading
the IPsec standards community of the need for strong integrity protection as an adjunct
to encryption, in order to prevent active attacks from defeating the conﬁdentiality services
oﬀered by ESP. For eﬃciency reasons, it was decided to include support for an optional

10

Algorithm
HMAC-SHA1-96
NULL
AES-XCBC-MAC-96
HMAC-MD5-96

Requirement Key size (bits) Output size (bits)

MUST
MUST
SHOULD+
MAY

160
N/A
128
128

96
0
96
96

Reference
RFC 2404 [6]

RFC 3566 [16]
RFC 2403 [5]

Table 3: Mandatory MAC Algorithms for ESP speciﬁed in RFC 4305

integrity service along with conﬁdentiality services in the second version of ESP, RFC 2406.
This support has been preserved in RFC 4303.

As with AH, the integrity service in ESP is provided by a MAC algorithm. The inputs
to the MAC calculation are the ﬁelds in the ESP header, payload and trailer, with the ICV
bytes being set to zero for the purposes of MAC calculation. The calculation will include all
ESN bits as noted above, allowing an anti-replay service to be oﬀered if integrity protection is
present. Details of how this service is implemented are largely as for AH, with the calculated
MAC being placed in the ICV ﬁeld. However, notice that no ﬁelds of the IP packet header are
protected by the MAC in ESP, in contrast to AH. Thus the protection oﬀered by the MAC
algorithm is somewhat less than in AH. However, a roughly equivalent level of protection
can be arranged for an IP header by using ESP in tunnel mode, in which case the integrity
protection will cover the entire inner packet, including all the header ﬁelds.

When ESP provides both encryption and integrity protection, the encryption is performed
ﬁrst and then the MAC algorithm is applied. This allows rapid rejection of corrupted packets
by the recipient, as the MAC will be checked before decryption needs to be performed. If the
MAC fails, the receiver must reject the packet. Moreover, this is an auditable event [23].

In keeping with the separation principle, RFC 4305 [25] (rather than RFC 4303) speciﬁes
which MAC algorithms must be supported by IPsec implementations. The list of algorithms
is replicated in Table 3. Notice that the algorithms are identical to those mandated for AH
except for the inclusion of the NULL algorithm here. The NULL algorithm is needed to allow
“encryption-only” operation of ESP. Note that while authentication and encryption can each
be NULL in ESP, they must not both be NULL: ESP can oﬀer one or both of encryption and
integrity protection, but not neither. There is no RFC specifying the NULL MAC algorithm.
It might appear surprising that RFC 4303 still allows encryption-only operation of ESP,
especially after Bellovin’s work [35] demonstrating its security ﬂaws. There is also signiﬁcant
theoretical work supporting the general adoption of integrity protection along with encryption
[33, 34, 43, 44]. It appears that the need for backward compatibility with RFC 1827 meant
that support for encryption-only conﬁgurations of ESP was mandated in RFC 2406. As com-
pensation, the second generation of RFCs are explicit in spelling out the dangers of using
encryption-only conﬁgurations. RFC 4303 removes the mandatory aspect, stating that im-
plementations may support encryption-only, and repeats the warnings of RFC 2406. However,
RFC 4303 indicates that ESP allows encryption-only because it “may provide better perfor-
mance and still provide adequate security, e.g., when a higher-layer authentication/integrity
protection is oﬀered independently.” In fact, in recent work [49], it has been shown that at
least one implementation of IPsec is fatally weak in tunnel mode, encryption-only conﬁgu-
rations: active attacks that are ciphertext-only and that can operate in essentially real-time
have been demonstrated in the laboratory under realistic networking conditions against the

11

Linux kernel implementation of IPsec. It is argued in [49] that placing warnings of the dan-
gers of encryption-only ESP in RFCs is probably insuﬃcient to prevent inexpert end-users
from selecting such conﬁgurations; indeed there exist many on-line conﬁguration guides which
either do not warn of the dangers or which actively encourage users to select encryption-only.
It is also shown in [49] that provision of higher-layer integrity protection can not prevent the
attacks. Thus the advice concerning such provision in RFC 4303 may be misleading. It should
be noted, however, that the attacks in [49] are not attacks against the RFCs themselves. This
is because they rely for their success on the failure of the Linux implementation to properly
implement post-cryptographic processing checks speciﬁed in the architectural RFCs 2401 [3]
and 4301 [21]. See also [46] for unimplemented sketches of similar kinds of attacks against
transport mode ESP.

4.5 Combined mode algorithms

Combined mode algorithms oﬀering both conﬁdentiality and integrity services are new to
ESP in RFC 4303. Under many circumstances, combined mode algorithms should provide
signiﬁcant eﬃciency gains compared to sequential execution of encryption and MACing. But
their inclusion in ESP is not completely straightforward, because it is desirable to integrity
protect more ﬁelds than need to be encrypted, and not all combined mode algorithms will
support this requirement. In current cryptographic terminology, algorithms that do are said
to solve the “authenticated encryption with associated-data” (AEAD) problem. Reference
[51] provides a pragmatic overview of recent work in this area.

In order to accommodate the range of possible combined mode algorithms (those solving
the AEAD problem and those not), no detailed ESP format is speciﬁed for combined mode.
Instead, issues such as details of IVs, padding requirements, possible replication of SPI and
Sequence Number ﬁelds in the processed payload, and whether or not an ICV ﬁeld is needed,
are deferred to RFCs for individual combined mode algorithms. Patents are an important
aspect here, with many of the “popular” designs for combined mode algorithms being en-
cumbered. Perhaps this explains in part why RFC 4305 neither mandates nor suggests any
speciﬁc combined mode algorithms for use in ESP. However, one suitable algorithm that ap-
pear to be free of patents already exists as an RFC: AES CCM mode, as speciﬁed in RFC
4309 [29]. There is no version number in ESP, and no mechanism for a peer to discover which
version of ESP another peer is using. Thus another reason for not mandating support for
combined mode algorithms is that it assists in making ESP as speciﬁed in RFC 4303 backward
compatible with earlier versions of ESP.

5 Cryptographic Key Management in IPsec

So far in our discussion of IPsec, we have assumed that all necessary cryptographic parameters,
including keys and algorithms, are already in place before AH or ESP processing begins. In
this section, we give a brief overview of how IPsec handles management of cryptographic keys
and other parameters.

We have already noted that SAs are used as a repository for cryptographic parameters
(including keys), and that SPIs provide a link between SAs and IPsec-protected packets
themselves. At a higher level, the SPD deﬁnes policies for applying IPsec and links to SAs
for implementing those policies. Typically, the SPD is populated by hand (usually via a
vendor-supplied GUI) at each IPsec aware host. This is a reasonable approach, though the

12

likelihood of misconﬁguration resulting in security failures or accidental denial of service is
quite high because of the number and complexity of options available. It is also possible, but
much less convenient, to set up the individual SAs manually, using static keys. This approach
is reasonable for testing purposes or small-scale deployment of IPsec, but does not scale at all
well. Moreover, it makes no provision for rekeying, the need for which can be triggered by a
number of events including sequence number overﬂow, or an SA exceeding its lifetime (which
can be determined, for example, by using a timer, or by IPsec reaching a pre-set limit on the
amount of data the SA is allowed to process). A better approach is to use IKE or IKEv2,
which provide automated mechanisms for setting up and managing SAs in accordance with
policies in the SPD. We discuss IKE and IKEv2 next.

5.1 Internet Key Exchange

The IKEv2 protocol as deﬁned in RFC4306 [26] is a very complex and ﬂexible speciﬁcation
which had a long gestation period in the IPsec working group. We will only provide an
overview of its features and a brief comparison with IKEv1 here. Further discussion of the
IKEv2 design and features can be found in [40].

At a high level, IKEv2 is a cryptographic protocol involving the exchange of pairs of
messages between two peers. In the ﬁrst exchange, called the IKE SA INIT exchange, the
two peers exchange information concerning cryptographic algorithms and other security pa-
rameters they are willing to use along with nonces and Diﬃe-Hellman (DH) values. The
DH values are used to create keying material SKEYSEED from which a variety of keys are
derived using a pseudo-random function (PRF). Included amongst these are keys for encryp-
tion and integrity protection algorithms for a special SA called the IKE SA. This SA deﬁnes
parameters for a secure channel between the peers over which subsequent message exchanges
take place. It provides ESP-like cryptographic processing of IKEv2 payloads (though without
any support for combined mode algorithms). In the second exchange, now protected by the
IKE SA and called the IKE AUTH exchange, the two parties authenticate one another and
set up a ﬁrst SA to be placed in the SADB and used for protecting ordinary (i.e. non-IKE)
communications between the peers. Thus four messages are needed to establish the ﬁrst SA
for general use.

Subsequent exchanges are known as CREATE CHILD SA and INFORMATIONAL ex-
changes. The ﬁrst of these can be used to establish further SAs for protecting traﬃc, and may
involve an exchange of new, ephemeral Diﬃe-Hellman values to provide perfect forward secu-
rity (PFS). The second is used to exchange management information, IKEv2 error messages
and so on.

The IKE SA INIT exchange allows two peers to negotiate many features of the ensuing
exchanges, including parameters for the Diﬃe-Hellman exchange, algorithms to be used in the
IKE SA, acceptable authentication methods, and so on. There are three main authentication
methods supported by IKEv2: signature-based, MAC-based, and EAP-based. The ﬁrst of
these implies the use of public key cryptography and a PKI to support this; the second requires
a pre-established symmetric key to be in place between the two peers (but note that, because
of the structure of IKEv2, this key can be used to authenticate the negotiation of many SAs).
A good discussion of the pros and cons of these two competing approaches can be found in
[42, Section 4.2.2]. The third approach makes use of the Extensible Authentication Protocol
(EAP) as deﬁned in [20]. This allows a wide range of legacy authentication methods to be
integrated with IKEv2.

13

All of the IKEv2 payloads comprising the above exchanges are speciﬁed at a bit/byte
level in [26, Section 3]. Keeping in mind the degree of ﬂexibility oﬀered by IKEv2, it is then
perhaps not so surprising that the IKEv2 speciﬁcation is as long as it is.

RFC 4307 [27] speciﬁes algorithms and parameters for use in IKEv2 which are mandatory
to implement. Thus it is a counterpart to RFC 4305 which does the same job for AH and ESP.
RFC 4307 identiﬁes two Diﬃe-Hellman groups, one with a 1024-bit modulus from [11] and
the other with a 2048-bit modulus from [15]. It also lists the same encryption and integrity
protection algorithms (with the same levels of support) as are recommended for use with
ESP in RFC 4305, see Tables 2 and 3. Finally, it lists three PRFs, PRF HMAC MD5 and
PRF HMAC SHA1 from [2], and PRF AES128 CBC from [18, 31]. This last PRF is identical
to the function AES-XCBC-MAC-96 from [16] except that it does not truncate the output to
96 bits. PRFs are used for various purposes in IKEv2, including key derivation. RFC 4308
[28] deﬁnes two suites of cryptographic algorithms that are optional to implement. Each suite
deﬁnes a full set of algorithms (including DH groups) needed for ESP encryption/integrity
protection and for IKEv1/IKEv2.

Some of the major similarities and diﬀerences between the IKEv1 and IKEv2 protocols

are as follows:

• Both protocols operate in two phases: Phase 1 (in main mode or aggressive mode)
and Phase 2 (quick mode) in IKEv1 are comparable to IKEv2’s IKE SA INIT and
IKE AUTH exchanges, respectively.

• Both protocols have options for identity-protection (via encryption of identity-related

data), anti-denial-of-service (via cookies), and perfect forward security.

• Phase 1 of IKEv1 allows four diﬀerent authentication methods in its two diﬀerent modes,
with a quite diﬀerent message syntaxes being possible in the various cases. It is claimed
that the equivalent function in IKEv2 is much simpler, with a single four-message pro-
tocol made up of two exchanges. However, the EAP authentication method does involve
modifying the message structure of IKEv2 to some extent.

• IKEv1’s quick mode is roughly equivalent to IKEv2’s CREATE CHILD SA, though

IKEv2 uses one message less than IKEv1.

• IKEv2 is more eﬃcient in setting up the ﬁrst non-IKE SA: this SA can be established
as part of the IKE AUTH exchange after four messages, while IKEv1 requires at least
six messages (using aggressive mode’s three messages followed by three more for quick
mode).

• IKEv1 and IKEv2 both run over the unreliable UDP protocol, but IKEv2 adds retrans-

mission and acknowledgement functions, so it is more reliable than IKEv1.

• IKEv2 uses an ESP-like transform to protect IKE payloads after the IKE SA INIT ex-
change, whereas IKEv1 uses somewhat diﬀerent methods deﬁned for the general purpose
protocol ISAKMP in [10].

A more detailed list of diﬀerences between IKEv1 and IKEv2 can be found in [26, Appendix
A].

It was intended at the outset of the IKEv2 design process that it should produce a leaner,
cleaner, more complete and more easily understood design. By these measures, IKEv2 has

14

been only partially successful: it is still a fairly complex protocol, and bringing in support for
EAP along with signature-based and MAC-based methods has led to some loss of clarity in
the protocol description. Eﬀorts are already underway to address certain deﬁciencies of the
IKEv2 speciﬁcation in IKEv2.1 [41].

6 Concluding Remarks

It seems fair to say that the diﬀerent generations of IPsec RFCs represent a cryptographic
evolution rather than a revolution. Some new features have been added (notably combined
mode algorithms in ESP), and new algorithms and key lengths have been brought into play.
The overall clarity and quality of the standards has deﬁnitely improved, perhaps as a con-
sequence of having a better-informed pool of experts in the working group coupled with a
greater understanding of the need to address interoperability through clearer speciﬁcation.

The development of the RFCs does seem to have been constrained by the need to main-
tain backward compatibility. This is evident, for example, in the way that ESP still allows
encryption-only conﬁgurations but does not mandate support for combined mode algorithms.
This seems like a missed opportunity. The attempt to improve IKE has succeeded in many
respects: IKEv2 is simpler and more self-contained, and the speciﬁcation is more explicit. But
including support for EAP has also introduced complexity, an almost inevitable consequence
of the desire for ﬂexibility.

IPsec has been analyzed from a cryptographic perspective over the years – see for example
[50, 39]. There is also some evidence that the provable security philosophy has now had an
inﬂuence on the IPsec RFCs. As examples, HMAC, deﬁned and proven secure in [32] is heavily
used in IPsec algorithms, while RFC 4303 cites [44] for evidence of the security issues of
applying a MAC to data before encryption, and SIGMA, as deﬁned in [36, 45] forms the basis
for the design of IKEv2’s signature-based authentication mode. Yet few of the cryptographic
design features in the IPsec RFCs appear to have been chosen because they have a ﬁrm
theoretical basis. Thus IPsec presents many interesting challenges for theoreticians seeking
motivation from real-world security problems. The complexity of IKEv2 means that only
simpliﬁed versions have been amenable to analysis to date [36, 45]. The full IKEv2 protocol
surely deserves a formal analysis. (Protocols studied in theory tend to be describable in six
lines or less – compare this to the nearly 100 pages needed to fully specify IKEv2 in RFC
4306!) The development of further, preferably patent-free, AEAD algorithms suitable for use
in ESP would be useful. Studying the impact of recent cryptanalysis of hash functions on the
security of HMAC could also be an interesting exercise: how severe can the attacks on the
underlying hash function be while still maintaining a reasonable level of security for HMAC?
The IPsec working group has now been wound up after completing its eﬀorts on the new
generation of IPsec standards. But IETF standardization activity is likely to continue for
sometime in three related areas concerned with deployment and ﬂexibility of IPsec. The
PKI4IPsec working group is developing PKI and certiﬁcate standards for IPsec, with the aim
of eventually increasing the use of public key authentication methods in IPsec deployments.
The IKE Mobility working group is working on extensions to IKEv2 protocol to enable its
use in multihoming, mobile and roaming contexts. The Better-Than-Nothing Security (btns)
working group is tasked with specifying extensions to the IPsec architecture to allow IPsec
to support the use of unauthenticated SAs, with the goal of enabling simpler and more rapid
deployment of IPsec in contexts where use of such unauthenticated SAs is appropriate.

15

In closing, we reiterate that cryptography is only one part of the IPsec puzzle. However,
getting the cryptography right is vital in ensuring that IPsec delivers the security expected
of it. We hope that this article will open up the new family of IPsec RFCs to a wider range
of cryptographic researchers, encouraging them to work in a fascinating area located at the
boundary between theory and practice. We also hope that this article has provided a useful
and accessible summary of recent developments in IPsec for non-cryptographers.

References

[1] R. Atkinson, “IP Encapsulating Security Payload (ESP).” RFC 1827, August 1995.

[2] H. Krawczyk, M. Bellare and R. Canetti, “HMAC: Keyed-Hashing for Message Authen-

tication.” RFC 2104, Feb. 1997.

[3] S. Kent and R. Atkinson, “Security Architecture for the Internet Protocol.” RFC 2401,

Nov. 1998.

[4] S. Kent and R. Atkinson, “IP Authentication Header.” RFC 2402, Nov. 1998.

[5] C. Madson and R. Glenn, “The Use of HMAC-MD5-96 within ESP and AH.” RFC 2403,

Nov. 1998.

[6] C. Madson and R. Glenn, “The Use of HMAC-SHA-1-96 within ESP and AH.” RFC

2404, Nov. 1998.

[7] C. Madson and N. Doraswamy, “The ESP DES-CBC Cipher Algorithm With Explicit

IV.” RFC 2405, Nov. 1998.

[8] S. Kent and R. Atkinson, “IP Encapsulating Security Payload (ESP).” RFC 2406, Nov.

1998.

[9] D. Piper, “The Internet IP Security Domain of Interpretation for ISAKMP.” RFC 2407,

Nov. 1998.

[10] D. Maughan, M. Schertler, M. Schneider and J. Turner, “Internet Security Association

and Key Management Protocol (ISAKMP).” RFC 2408, Nov. 1998.

[11] D. Harkins and D. Carrel, “The Internet Key Exchange (IKE).” RFC 2409, Nov. 1998.

[12] R. Glenn and S. Kent, “The NULL Encryption Algorithm and Its Use With IPsec.” RFC

2410, Nov. 1998.

[13] R. Pereira and R. Adams, “The ESP CBC-Mode Cipher Algorithms.” RFC 2451, Nov.

1998.

[14] A. Keromytis and N. Provos, “The Use of HMAC-RIPEMD-160-96 within ESP and AH.”

RFC 2857, June 2000.

[15] M. Kojo and T. Kivinen, “More Modular Exponential (MODP) Diﬃe-Hellman groups

for Internet Key Exchange (IKE).” RFC 3526, May 2003.

16

[16] S. Frankel and H. Herbert, “The AES-XCBC-MAC-96 Algorithm and Its Use With

IPsec.” RFC 3566, Sept. 2003.

[17] S. Frankel, R. Glenn and S. Kelly, “The AES-CBC Cipher Algorithm and Its Use with

IPsec.” RFC 3602, Sept. 2003.

[18] P. Hoﬀman, “The AES-XCBC-PRF-128 Algorithm for the Internet Key Exchange Pro-

tocol (IKE).” RFC 3664, Jan. 2004.

[19] R. Housley, “Using Advanced Encryption Standard (AES) Counter Mode With IPsec

Encapsulating Security Payload (ESP).” RFC 3686, Jan. 2004.

[20] B. Aboba, L. Blunk, J. Vollbrecht, J. Carlson and H. Levkowetz, Ed., “Extensible Au-

thentication Protocol (EAP).” RFC 3748, June 2004.

[21] S. Kent and K. Seo, “Security Architecture for the Internet Protocol.” RFC 4301, Dec.

2005.

[22] S. Kent, “IP Authentication Header.” RFC 4302, Dec. 2005.

[23] S. Kent, “IP Encapsulating Security Payload (ESP).” RFC 4303, Dec. 2005.

[24] S. Kent, “Extended Sequence Number (ESN) Addendum to IPsec Domain of Interpreta-
tion (DOI) for Internet Security Association and Key Management Protocol (ISAKMP).”
RFC 4304, Dec. 2005.

[25] D. Eastlake 3rd, “Cryptographic Algorithm Implementation Requirements for Encap-
sulating Security Payload (ESP) and Authentication Header (AH).” RFC 4305, Dec.
2005.

[26] C. Kaufman (ed.), “Internet Key Exchange (IKEv2) Protocol.” RFC 4306, Dec. 2005.

[27] J. Schiller, “Cryptographic Algorithms for Use in the Internet Key Exchange Version 2

(IKEv2).” RFC 4307, Dec. 2005.

[28] P. Hoﬀman, “Cryptographic Suites for IPsec.” RFC 4308, Dec. 2005.

[29] R. Housley, “Using Advanced Encryption Standard (AES) CCM Mode with IPsec En-

capsulating Security Payload (ESP).” RFC 4309, Dec. 2005.

[30] A. Kato, S. Moriai and M. Kanda, “The Camellia Cipher Algorithm and Its Use With

IPsec.” RFC 4312, Dec. 2005.

[31] P. Hoﬀman, “The AES-XCBC-PRF-128 Algorithm for the Internet Key Exchange Pro-

tocol (IKE).” RFC 4434, Feb. 2006.

[32] M. Bellare, R. Canetti and H. Krawczyk, “Keying hash functions for message authen-
tication.” In N. Koblitz (ed.), Advances in Cryptology – CRYPTO’96, LNCS Vol. 1109,
Springer-Verlag, 1996, pp. 1–15.

[33] M. Bellare and C. Namprempre, “Authenticated Encryption: Relations among notions
and analysis of the generic composition paradigm.” In T. Okamoto (ed.), Advances in
Cryptology – ASIACRYPT 2000, LNCS Vol. 1976, Springer-Verlag, 2000, pp. 531–545.

17

[34] M. Bellare and P. Rogaway, “Encode-then-encipher encryption: How to exploit nonces
or redundancy in plaintexts for eﬃcient cryptography.” In T. Okamoto (ed.), Advances
in Cryptology – ASIACRYPT 2000, LNCS Vol. 1976, Springer-Verlag, 2000, pp.317–330.

[35] S. Bellovin, “Problem Areas for the IP Security Protocols.” In Proceedings of the Sixth

Usenix Unix Security Symposium, pp. 1–16, San Jose, CA, July 1996.

[36] R. Canetti and H. Krawczyk, “Security Analysis of IKE’s Signature-based Key-Exchange
Protocol.” In V. Shoup (ed.), Advances in Cryptology – CRYPTO 2002, LNCS Vol. 3621,
Springer-Verlag, 2002, pp. 143–161.

[37] B. Canvel, A.P. Hiltgen, S. Vaudenay and M. Vuagnoux, “Password Interception in a
SSL/TLS Channel.” In D. Boneh (ed.), Advances in Cryptology – CRYPTO 2003, LNCS
Vol. 2729, Springer-Verlag, 2003, pp. 583–599.

[38] N. Doraswamy and D. Harkins. IPsec: the new security standard for the Internet, In-

tranets and Virtual Private Networks (second edition), Prentice Hall PTR, 2003.

[39] N. Ferguson and B. Schneier, “A cryptographic evaluation of IPsec.” Unpublished

manuscript available from http://www.schneier.com/paper-ipsec.html, Feb. 1999.

[40] D. Harkins, C. Kaufman, T. Kivinen, S. Kent and R. Perlman, “Design Ra-
tionale for IKEv2.” Internet draft, available from http://tools.ietf.org/html/
draft-ietf-ipsec-ikev2-rationale-00.txt, expired Aug. 2002.

[41] P. Hoﬀman, “Internet Key Exchange Protocol:

IKEv2.1.” Internet draft avail-
able from http://www.ietf.org/internet-drafts/draft-hoffman-ikev2-1-00.txt,
Jan. 2006, expires 5th July, 2006.

[42] S. Frankel, K. Kent, R. Lewkowski, A.D. Orebaugh, R.W. Ritchey and S.R. Sharma,
“Guide to IPsec VPNs.” NIST Special Publication 800-77 (Draft), January 2005.

[43] J. Katz and M. Yung, “Unforgeable encryption and chosen ciphertext secure modes of
operation.” In B. Schneier (ed.), FSE 2000, LNCS Vol. 1978, Springer-Verlag, 2001, pp.
284–299.

[44] H. Krawczyk, “The Order of Encryption and Authentication for Protecting Communica-
tions (Or: How Secure Is SSL?).” In J. Kilian (ed.), Advances in Cryptology – CRYPTO
2001, LNCS Vol. 2139, Springer-Verlag, 2001, pp. 310–331.

[45] H. Krawczyk, “SIGMA: The ‘SIGn-and-MAc’ Approach to Authenticated Diﬃe-Hellman
and Its Use in the IKE-Protocols.” In D. Boneh (ed.), Advances in Cryptology – CRYPTO
2003, LNCS Vol. 2729, Springer-Verlag, 2003, pp. 400–425.

[46] C.B. McCubbin, A.A. Selcuk and D. Sidhu, “Initialization vector attacks on the IPsec
protocol suite.” In 9th IEEE International Workshops on Enabling Technologies: Infras-
tructure for Collaborative Enterprises (WETICE 2000), IEEE Computer Society, 2000,
pp. 171–175.

[47] NIST, “Brief Comments on Recent Cryptanalytic Attacks on Secure Hashing Functions
and the Continued Security Provided by SHA-1.” Available from http://www.csrc.
nist.gov/hash standards comments.pdf, 25th August 2004.

18

[48] NIST Federal Information Processing Standards Publication 197, “Speciﬁcation for the

Advanced Encryption Standard (AES).” 26th Nov. 2001.

[49] K.G. Paterson and A.K.L. Yau, “Cryptography in Theory and Practice: The Case of
Encryption in IPsec.” In S. Vaudenay (ed.), Advances in Cryptology – EUROCRYPT
2006, LNCS Volume 4004, Springer-Verlag, to appear. Full version available from http:
//eprint.iacr.org/2005/416.

[50] P.

Rogaway,

“Problems
from
draft
draft-rogaway-ipsec-comments-00.txt, April 1995.

Proposed

available

with

Internet
http://www.cs.ucdavis.edu/∼rogaway/papers/

Cryptography.”

IP

[51] G.

Rose,

“Combining

Encryption.”
http://www.qualcomm.com.au/PublicationsDocs/Enc+MAC%20paper.pdf.

Unpublished

Message
manuscript

Authentication
available

and
from

[52] S. Vaudenay, “Security ﬂaws induced by CBC padding – applications to SSL, IPSEC,
WTLS...” In L.R. Knudsen (ed.), Advances in Cryptology – EUROCRYPT 2002, LNCS
Vol. 2332, Springer-Verlag, 2002, pp. 534–545.

[53] X. Wang, D. Feng, X. Lai and H. Yu, “Collisions for Hash Functions MD4, MD5, HAVAL-
128 and RIPEMD.” Cryptology ePrint Archive: Report 2004/199, available from http:
//eprint.iacr.org/2004/199, 2004.

[54] X. Wang, Y.L. Yin and H. Yu, “Finding Collisions in the Full SHA-1.” In V. Shoup (ed.),
Advances in Cryptology – CRYPTO 2005, LNCS 3621, Springer-Verlag, 2005, pp. 17–36.

19



=== Content from bugs.gentoo.org_0a0abf2a_20250126_054632.html ===

[![Gentoo Websites Logo](extensions/Gentoo/web/gentoo_org.png)](/ "Go to the Gentoo Bugzilla homepage")
Go to:
[Gentoo Home](https://www.gentoo.org/)
[Documentation](https://www.gentoo.org/support/documentation/)
[Forums](https://forums.gentoo.org/)
[Lists](https://www.gentoo.org/get-involved/mailing-lists/)
[Bugs](/)
[Planet](https://planet.gentoo.org/)
[Store](https://www.gentoo.org/inside-gentoo/stores/)
[Wiki](https://wiki.gentoo.org/)
**[Get Gentoo!](https://www.gentoo.org/downloads/)**

Gentoo's Bugzilla – Search by bug number

* [Home](./)
* | [New](enter_bug.cgi?format=guided)–[[Ex]](enter_bug.cgi)
* | [Browse](describecomponents.cgi)
* | [Search](query.cgi)
* | [Privacy Policy](https://wiki.gentoo.org/wiki/Foundation%3APrivacy_Policy)
* |

  [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")
* | [Reports](report.cgi)
* |
  [Requests](request.cgi)
* |
  [New Account](createaccount.cgi)
* |
  [Log In](show_bug.cgi?GoAheadAndLogIn=1)

  [x]
* |
  [Forgot Password](show_bug.cgi?GoAheadAndLogIn=1#forgot)
  Login:

  [x]

You may find a single bug by entering its bug id here:

* + [Home](./)
  + | [New](enter_bug.cgi?format=guided)–[[Ex]](enter_bug.cgi)
  + | [Browse](describecomponents.cgi)
  + | [Search](query.cgi)
  + | [Privacy Policy](https://wiki.gentoo.org/wiki/Foundation%3APrivacy_Policy)
  + |

    [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")
  + | [Reports](report.cgi)
  + |
    [Requests](request.cgi)
  + |
    [New Account](createaccount.cgi)
  + |
    [Log In](show_bug.cgi?GoAheadAndLogIn=1)

    [x]
  + |
    [Forgot Password](show_bug.cgi?GoAheadAndLogIn=1#forgot)
    Login:

    [x]



=== Content from sweet32.info_7925193f_20250125_034344.html ===

# Sweet32: Birthday attacks on 64-bit block ciphers in TLS and OpenVPN

## CVE-2016-2183, CVE-2016-6329

Cryptographic protocols
like [TLS](https://tools.ietf.org/html/rfc5246), [SSH](https://tools.ietf.org/html/rfc4253), [IPsec](https://eprint.iacr.org/2006/097.pdf),
and [OpenVPN](https://openvpn.net/) commonly
use [block
cipher](https://en.wikipedia.org/wiki/Block_cipher) algorithms, such as AES, Triple-DES, and Blowfish, to
encrypt data between clients and servers. To use such algorithms, the
data is broken into fixed-length chunks, called blocks, and each block is
encrypted separately according to a [mode of operation](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation).
Older block ciphers, such as Triple-DES and
Blowfish use a block size of 64 bits, whereas AES uses a block size
of 128 bits.

It is well-known in the cryptographic community that a short block
size makes a block cipher vulnerable to
[birthday](http://web.cs.ucdavis.edu/~rogaway/papers/modes.pdf)
[attacks](https://eprint.iacr.org/2012/623), even if there
are no cryptographic attacks against the block cipher itself.
We observe that such attacks have now become practical for the common usage of
64-bit block ciphers in popular protocols like TLS and OpenVPN.
Still, such ciphers are widely enabled on the Internet.
Blowfish is currently the default cipher in OpenVPN, and Triple-DES
is supported by nearly all HTTPS web servers, and currently used for
roughly 1-2% of HTTPS connections between mainstream browsers and
web servers.

We show that a network attacker who can monitor a long-lived
Triple-DES HTTPS connection between a web browser and a website can
recover secure HTTP cookies by capturing around 785 GB of
traffic. In our proof-of-concept demo, this attack currently takes
less than two days, using malicious Javascript to generate traffic. Keeping a web connection alive for two days may not
seem very practical, but it worked easily in the lab. In terms of computational complexity, this
attack is comparable to the recent [attacks](http://www.isg.rhul.ac.uk/tls/)
on [RC4](http://www.rc4nomore.com/). We also demonstrate
a similar attack on VPNs that use 64-bit ciphers, such as OpenVPN,
where long-lived Blowfish connections are the norm.

Countermeasures are currently being implemented by browser vendors,
OpenSSL, and the OpenVPN team, and we advise users to update to the
latest available versions.

Our results are described in the following technical paper, presented at [ACM CCS 2016](https://www.sigsac.org/ccs/CCS2016/):

[![[article]](article.png "download article")](SWEET32_CCS16.pdf)
[![[slides]](presentation.png "download presentation")](SWEET32_CCS16_slides.pdf)
### [On the Practical (In-)Security of 64-bit Block Ciphers — Collision Attacks on HTTP over TLS and OpenVPN](SWEET32_CCS16.pdf)

Karthikeyan Bhargavan, GaÃ«tan Leurent

## Block Ciphers and the Birthday Bound

The security of a block cipher is often reduced to the key size *k*: the
best attack should be the exhaustive search of the key, with complexity
2*k*. However, the block size *n* is also an important security
parameter, defining the amount of data that can be encrypted under the
same key. This is particularly important when using common modes of
operation: we require block ciphers to be secure with up to 2*n*
queries, but most modes of operation (e.g. CBC, CTR, GCM,
OCB, etc.) are unsafe with more than 2*n*/2 blocks of message (the
birthday bound).

With a modern block cipher with 128-bit blocks such as AES, the
birthday bound corresponds to 256 EB.
However, for a block cipher with 64-bit
blocks, the birthday bound corresponds to only 32 GB, which is easily reached in practice. When the amount of data
encrypted under a fixed key approaches this limit, the security guarantees
of the mode of operation start to crumble. This problem is
well-known by cryptographers, who always require keys to be
changed **well before** 2n/2 blocks. However
it is often minimized by practitioners
because the attacks require known plaintext, and reveal only little
information.
Indeed, standard bodies only recommend to change the
key just before 2n/2 blocks, and many implementations don't
enforce any limit on the use of a key.

In particular, there are many uses of block ciphers with 64-bit blocks
where large amount of data are potentially encrypted under the same key, such as:

* 3G telephony (UMTS), encrypted with KASUMI;
* OpenVPN, which uses Blowfish as the default cipher;
* many Internet protocols, such as TLS, IPSec and SSH, support Triple-DES
  as a legacy cipher.

In all these scenarios, 32 GB of data can be transferred in less than one
hour with a fast connection.

## Exploiting Block Cipher Collisions

![](CBC.svg)

In practice, block ciphers are used with a mode of operation in order to
deal with messages of arbitrary length.
The CBC mode is one of the oldest encryption modes, and still widely
used. The message *M* is divided into blocks *mi* and is
encrypted as:
 *ci = Ek(mi ⊕ ci-1)*,
where *c-1* is an initialization
value usually denoted as IV.
We now explain the impact of collisions on the CBC mode.

CBC has been proven secure up to 2*n*/2 of
messages.
On the other hand there is a simple birthday attack against CBC: after
2*n*/2 message blocks encrypted with the same key (in the same
message or in different messages), a collision between two ciphertext
blocks *ci = cj* is expected. Since *Ek* is a
permutation, a collision in the output means that the inputs are the
same (*mi ⊕ ci-1 = mj ⊕ cj-1*)
which reveals the xor of two plaintext blocks:
*mi ⊕ mj = ci-1 ⊕ cj-1*.

With 2*d* blocks of data the expected number of collisions
is roughly 22*d-n-*1 (following the birthday paradox).

### Practical impact

In many contexts, recovering only the xor between
two plaintext blocks is not sufficient for an attack with a
practical impact. However, an attack can be mounted when the following
conditions are fulfilled:

* a fixed secret is sent repeatedly;
* some fraction of the plaintext is known.

In this case, there is a chance that a
collision leaks the xor between the fixed secret and the known
plaintext; this would immediately reveal the secret. More precisely,
this attack is expected to succeed with high probability as soon as
2s copies of the secret and 2t known blocks are encrypted,
with *s+t ≥ n*.

In particular, this is applicable to the security of encrypted HTTP
connections, when an authentication token is send with every request.
A man-in-the-browser attacker can generate a large
number of requests, and recover the authentication token, using the fact
that most headers in the request are predictable or even controlled by
the attacker.

## 64-bit Block Cipher Usage on the Internet

Many of the most influential Internet security protocols, such as TLS,
SSH, and IPsec were standardized at a time when 64-bit block ciphers,
such as Triple-DES and Blowfish, were still considered
strong.
For example, in TLS 1.0 and 1.1, Triple-DES is the mandatory encryption
algorithm, so all TLS libraries implement it and a vast majority of
web servers support it. In addition, until we disclosed the
attacks in this paper, OpenSSL included Triple-DES ciphersuites in its
HIGH-security list (it has now been moved to MEDIUM).

### Triple-DES and Blowfish usage in VPNs.

IPSec Most IPSec-based VPN clients support
Triple-DES for interoperability. In particular, some versions of
Microsoft's L2TP VPN client
use [Triple-DES
by default](https://support.microsoft.com/en-us/kb/325158).

OpenVPN
[OpenVPN](https://openvpn.net) is a popular open-source VPN solution
originally written by James Yonan. The **default encryption** for the
transport protocol of OpenVPN **is Blowfish – a 64-bit cipher –** with the
CBC mode. OpenVPN supports two different modes to generate session keys
to encrypt the messages:

* In **pre-shared-key mode**, static keys are used for all the traffic.
  In particular, there is no limit to the lifetime of those keys.
* In **TLS mode**, session keys are generated with a TLS handshake,
  using certificates to authenticate the peers. The session keys are
  updated periodically, with limits on the number of packets, the number
  of bytes, or a session time. The default configuration rekeys the
  tunnel every hour.

### Triple-DES usage in HTTPS.

Triple-DES is the second most widely supported cipher (after AES) in HTTPS
servers, with about [87% of servers supporting
it](https://securitypitfalls.wordpress.com/2016/04/17/february-2016-scan-results-incomplete/).
Furthermore, all popular web browsers support Triple-DES. The cipher that
is actually negotiated for a TLS connection is chosen by the server,
based on its local preference order and on the order in which the
client advertises its ciphersuites. Since most modern browsers and servers
prefer AES over Triple-DES one may expect only a negligible number of connections
to negotiate Triple-DES. However, we find evidence that 1-2% of
all TLS connections likely use Triple-DES in CBC mode, as described below.

Firefox Telemetry
[Telemetry data from Mozilla Firefox](https://mzl.la/2bkLMFA)
show that Triple-DES is used for close to 1% of HTTPS connections from
Firefox browsers (0.76% with beta 49). The use of Triple-DES with Firefox
is slowly decreasing, and peaked with the removal of RC4 from
the list of supported ciphers in version 36. Indeed a number of servers
are configured to use, in order of preference, first RC4, then Triple-DES,
and now use Triple-DES with Firefox. Since all modern browsers have
deprecated RC4 between 2013 and 2015 (following
RFC 7465), they will also use
a Triple-DES ciphersuite in this situation.

Scanning the Top 1M Websites
We performed a scan of the top 1 million servers as listed by
Alexa using the [cipherscan](https://github.com/jvehent/cipherscan)
tool. We
found that 86% of the servers that support TLS include Triple-DES as one
of the supported ciphers. Moreover, 1.2% of these servers are configured
in such a way that they will actually pick a
Triple-DES based ciphersuite with a modern browser, even though better alternatives are available.
(In particular many of these servers support AES-based ciphersuites, but use Triple-DES or RC4 preferentially.)

Windows XP Clients and Windows 2003 Servers
The Windows Server 2003 operating system does not support AES-based
ciphersuites in its default configuration, although support for AES can
be added with an optional [hotfix](https://support.microsoft.com/en-us/kb/948963). The Windows XP operating system with
security update [MS10-049](https://support.microsoft.com/en-us/kb/980436) supports
AES-based ciphersuites.
If AES-based ciphersuites have not been added, these operating systems support only
RC4, Triple-DES, DES, and RC2-40. While they are not supported
anymore by Microsoft, they still have some users, and this creates
situations where the best available cipher is Triple-DES.

### Long-lived HTTPS connection

An important requirement for the attack is to send a large number of
requests in the same TLS connection.
Therefore, we need to find client and
servers that not only negotiate the use of Triple-DES, but also exchange a
large number of HTTP request in the same TLS connection (without
rekeying). This is possible using a persistent HTTP connection, as
defined in HTTP/1.1 (Keep-Alive).
On the client side, all browsers
that we tested (Firefox, Chrome, Opera) will reuse a TLS connection as
long as the server keeps it open.

On the server side,
we found that a number of HTTP servers will close the TLS connection
even when it is still active. In particular, Apache and Nginx
limit the number of requests sent in the same connection, with a maximum
of 100 in the default configuration. On the other hand, IIS does not
seem to have such a limit. In practice, many high profile servers
accept a very large number of requests in a single TLS connection.

Vulnerable Websites
For a better estimate of the number of vulnerable servers, we tested
servers from Alexa's top 10k that negotiate Triple-DES with a modern
client. We identified 11483 different HTTPS servers, and found that 226 of them (1.9%) negotiate Triple-DES
with a modern client. Moreover, 72 of these (0.6% of the total) also
accept to keep a connection open for at least 800k requests.
Consequently, the duration of the attack is not unrealistic, at least
from the viewpoint of browsers and servers, and we estimate that at
least 0.6% of HTTPS connections are vulnerable to our attacks.

For advice about how to check a website's
configuration and configure it properly, see the [FAQ](#faq).

## Attacking Authenticated HTTP over TLS and OpenVPN

We now demonstrate concrete attacks against authenticated HTTP sessions even
when they are secured by TLS or OpenVPN.
First, we identify a few examples of secret authentication credentials
that are repeatedly sent by the browser on every request. We then
show how we can recover these secrets using block cipher collisions.

### HTTP Bearer Tokens

Cookie-based Sessions
Modern HTTPS websites use a variety of methods to manage authenticated
sessions with their clients. The most popular mechanism is secure
*cookies* as specified in RFC6265. Once a user has logged in, the
server sets a cookie containing a secret value on the user's
browser. The browser will then send the cookie on all subsequent
requests to the website, implicitly authenticating the user.

Cookies are sensitive, because an attacker who obtains a session cookie
can then log in as the user from a different browser. The cookie acts
as a *bearer token* that carries the user's delegated credential.

A cookie for a website is normally included in all requests to that
website whether that request was initiated by the user, or a script on
the website, or even by a different website. Browsers sometimes impose
stricter rules for this last category of requests, called cross-origin
or cross-domain requests. For example, XmlHttpRequests sent from one
domain to another may not have cookies attached. However, cross-domain
requests for images or iframes will still send cookies.

HTTP BasicAuth
Apart from cookies, there are other mechanisms for a website to
authenticate the user. In the HTTP Basic Authentication mechanism
specified in RFC7617, the browser asks the user to enter a username
and password into a special dialog and then sends this information (in
plaintext) as an HTTP header of the form:

```

Authorization: Basic dGVzdDoxMjPCow=

```

Once a user has entered his login information once, the browser will typically
cache this information and use it on all subsequent requests to the server.
Notably, even if a different website creates a cross-domain request to the
authenticated server, the BasicAuth credentials will be automatically sent
by the browser.
BasicAuth credentials contain the user's password and are hence security-critical.
One should only use this authentication mechanism over HTTPS but a number of
corporate websites use BasicAuth over HTTP, under the assumption that their
users can only access the website over a VPN or some other secure connection.

![](Attack.svg)
### The Beastly Attack Scenario

Our attack scenario, is similar to the setup used in recent attacks on RC4.
The attacker wants to steal some bearer token that is being repeatedly
sent by a browser to a website secured with HTTPS, or an HTTP website
accessed through a VPN. We assume that the attacker can
control some JavaScript on a web page loaded by the user's browser,
either by actively tampering with an HTTP response on the wire, or by
hosting a malicious website that the user is fooled into visiting. We
also assume that the attacker can observe all the encrypted traffic between the
target browser and the secure website.

We further assume that the data is encrypted with a 64-bit block cipher
in CBC mode (either an HTTPS connection where the client and server have
negotiated Triple-DES, or an HTTP connection though a VPN encrypted with Blowfish or Triple-DES). Suppose the victim is already logged in to a
website and has a session cookie. The attacker runs malicious
JavaScript code on the victim's browser that repeatedly sends HTTP
queries to the target website server, each containing the session
cookie. If he sends close to 232 queries, a collision is
expected between a ciphertext block corresponding to the cookie
(*ci*), and a known block (*cj*), containing a known part of the
query. The collision attack against CBC reveals the session cookie:
*pi = pj ⊕ ci-1 ⊕ cj-1*.

Note that most of the traffic generated by the attacker is known or
predictable. The requested URL is chosen by the attacker, and all the
headers excepted the cookie are predictable and can be observed in any
HTTP traffic.

```
<html>
  <body>
    <script>
    var W = new Array;
    for (var i=0; i<8; i++) {
        var x = new Worker("worker.js");
        W.push(x);
    }
    </script>
  </body>
</html>

```

*attack.html*

```
var url = "https://10.0.0.1/index.html";
var xhr = new XMLHttpRequest;

// Expand URL to ~4kB using a query string
// Alternatively, force a large cookie
url += "?";
var x = 10000000;
for (var i=0; i<=500; i++) {
    url += x++;
}

while(true) {
    xhr.open("HEAD", url, false);
    xhr.withCredentials = true;
    xhr.send();
    xhr.abort();
}

```

*worker.js*

### Proof-of-Concept Attack Demo

The attacker code consists of two parts: a JavaScript program that
sends a large number of HTTP requests, and a network
adversary who processes the resulting ciphertext to recovers a 16-byte secret.

Man-in-the-browser code The attacker code is
shown on the right: it uses Web workers to
issue XmlHttpRequests, using
the withCredentials property to make sure that cookies are
send in the cross-origin request.
We experimented with several browsers, and we obtained the best
results with Firefox Developer Edition 47.0a2.

Recovering collisions
We captured the encrypted packets with tcpdump and used a
C++ program to extract the ciphertext blocks (using libpcap).
In both the HTTPS attack and the OpenVPN attack, each HTTP query is sent in a
separate encrypted record, which contain the plaintext at a fixed
position, as well as some extra information (packet number, padding,
MAC, ...). Therefore, it is easy to know to which plaintext block
corresponds each ciphertext block, and to align the cookie to a block limit.
After capturing all the traffic, the C++ program sorts the ciphertext
blocks in order to locate collisions. Since the amount of data is quite
large (hundreds of gigabytes), we use the external sort implementation of the
stxxl library. With a NAS storage, sorting the data took
around four hours.

### Attacking Basic Auth over OpenVPN

To demonstrate the attack against OpenVPN, we use a pre-shared-key
tunnel between two physical machines running Linux, with Firefox
Developer Edition 47.0a2 on one side, and an nginx server on the other
side. Access to the server is protected by BasicAuth, and the user
has entered his credentials. Using the default OpenVPN settings, the
tunnel is encrypted with Blowfish in CBC mode.

We use the Javascript code described in the previous section to send a
large number of requests to the server though the tunnel. We found
that increasing the size of the request to 4~kB does not significantly
reduce the query rate, but reduces the number of queries required for
the attack. In our setting, the browser generates about 2900 requests
per second, using several web Worker running in parallel. We expect
the first collision after roughly
232.3 blocks (40 GB), *i.e.* one hour.
In practice, we detected the first collision
early, after only 30 minutes (231.3 blocks); as expected, the
predicted xor difference was correct. The full attack needs about
236.6 blocks (785 GB) to recover a two-block secret out of 4 kB
messages; this should take about 19 hours in this setting. **In our
demo, it took 18.6 hours and 705 GB, and we successfully
recovered the 16-byte authentication token.**

### Attacking Secure Cookies over HTTPS

The attack against HTTPS connection is very similar to the attack
against OpenVPN, as long as we have a client and server that negotiate
Triple-DES, and that keep a connection open for a long time.

Vulnerable Websites As detailed above, about 0.6% of the top Alexa 100K
websites support Triple-DES and allow long-lived HTTPS connections. This
list contains many high-profile e-commerce and banking websites.

We use the Javascript code described above,
but we note that with several Workers running in
parallel, modern browsers open a few parallel connections to
the server and split the requests over these connections.
For our attack, we need to maximize the throughput over a *single*
connection. This can be achieved by disturbing some of the connections
so that most of request are send in a single. In our setup, we used
iptables rules to limit the rate of all connections except one.
In a real attack, this would be done by an active man-in-the-middle, but
a passive man-in-the-middle can also mount the attack -- it will just
take more time to collect the data.

Proof-of-Concept Attack Demo
In our setup we use Firefox Developer Edition 47.0a2 running
on Linux and an IIS 6.0 server
in a Windows Server 2003 R2 SP2 Virtual machine. The default configuration of
IIS 6.0 with all recommended updates offers only RC4 and Triple-DES ciphers,
and will use Triple-DES with Firefox and other recent browsers where RC4 is
disabled. Moreover, IIS 6.0 supports HTTP/1.1 and keeps an active connection open
for an arbitrary long time.

On Firefox Developer Edition 47.0a2, with a few dozen
Workers running in parallel, we can send up to 2000 requests
per second in a single TLS connection.
In our experiment, we were lucky to detect the first collision after
only 25 minutes (220.1 requests), and we verified that the
collision revealed the xor of two plaintexts blocks. As seen
previously, the full attack should require 236.6 blocks (785 GB) to
recover a two-block cookie, which should take 38 hours in our setting.
**Experimentally, we have recovered a two-block cookie from an HTTPS trace
of only 610 GB, captured in 30.5 hours.**

## Impact and Mitigation

We have demonstrated the first concrete attacks on mainstream Internet
protocols that exploit block cipher collisions. Our attacks can
recover valuable secrets such as HTTP cookies and passwords in under
40 hours. Our attacks impact a majority of OpenVPN connections and an
estimated 0.6% of HTTPS connections to popular websites. We expect
that our attacks also impact a number of SSH and IPsec connections,
but we do not have concrete measurements for these protocols. Like
many recent attacks on TLS, such a BEAST and RC4 NOMORE, the
underlying principles behind our attacks were well known to
cryptographers. Our goal is to raise awareness among practitioners
about the vulnerabilities of short block ciphers and on safe ways of
using them.

### Comparison with RC4 attacks

Our attack scenario is very similar to the setup of the recent
attacks on the use of RC4 in HTTPS. We use
the same man-in-the-browser setting to generate a large number of HTTP
requests, and the data complexity of the attack is comparable.
Our attack requires only 229.1 short queries of 512 bytes
(280 GB in total), which
can be reduced to 227.6 longer queries of 4 kB
(785 GB in total).
However, these numbers are for the
case when all the data is encrypted within the same session. Even if
the amount of data sent on a single connection is limited, as long as
the limit is close enough to the birthday bound, we can still mount
our attacks across multiple parallel and sequential sessions, albeit
with a higher data and time complexity.

### Mitigation

The obvious way to avoid these attacks is to stop using legacy 64-bit
block ciphers. Alternatively, the attack can be mitigated by rekeying
the session frequently.

Concretely, we recommend the following measures to prevent
our attack:

* Web servers and VPNs should be configured to prefer
  128-bit ciphers. According to our scans, about 1.1% of the top 100k
  web server from Alexa, and 0.5% of the top 1 million, support AES but
  prefer to use 3DES.
* Web browsers should offer 3DES as a fallback-only cipher, to
  avoid using it with servers that support AES but prefer 3DES.
* TLS libraries and applications should limit the length
  of TLS sessions with a 64-bit cipher. This could be done with TLS
  renegotiation, or in some cases by closing the connection and starting
  a new one (i.e. limiting HTTP/1.1 Keep-Alive, SPDY, and HTTP/2
  with 3DES ciphersuites).
* OpenVPN users can change the cipher from the default Blowfish to AES, using
  for instance `cipher AES-128-CBC` on the client and
  server configuration. If they don't control the server
  configuration, they can mitigate the attack by forcing frequent
  rekeying with `reneg-bytes 64000000`.

### Responsible disclosure

We have communicated our results and concerns to the OpenVPN team, and
to various website owners, browser vendors, and TLS libraries. They all
acknowledged the
issue, and are working on implementing countermeasures. The TLS
vulnerability received CVE number CVE-2016-2183, and the OpenVPN
vulnerability is tracked as CVE-2016-6329.

**NIST** is working on
[deprecation
of 3DES](http://csrc.nist.gov/news_events/index.html#jul11). They plan to limit the use of 3DES to
220 blocks with a given key, and to disallow 3DES in TLS,
IPsec, and possibly other protocols.

**OpenVPN** [2.3.12](http://www.mail-archive.com/openvpn-announce%40lists.sourceforge.net/msg00000.html) will [display](https://www.mail-archive.com/openvpn-devel%40lists.sourceforge.net/msg00029.html) a
[warning](https://www.mail-archive.com/openvpn-devel%40lists.sourceforge.net/msg00030.html) to users who choose to use 64-bit ciphers and encourage them
to transition to AES (cipher
negotiation is also being implemented in the 2.4 branch). It will also
implement a default
renegotiation limit of 64MB when used in TLS mode in a future version. A [wiki entry](https://community.openvpn.net/openvpn/wiki/SWEET32) provides further details.

**OpenSSL** has moved 3DES ciphersuites from the
HIGH category to
MEDIUM in the [1.0.1](https://github.com/openssl/openssl/commit/e95f5e03f6f1f8d3f6cbe4b7fa48e57b4cf8fd60) and [1.0.2](https://github.com/openssl/openssl/commit/0fff5065884d5ac61123a604bbcee30a53c808ff) branches, and will disable it by default in
the upcoming [1.1.0](https://github.com/openssl/openssl/commit/ef28891bab7054667f2f6739f6d376c38b3ca1cc) release.
They have a [blog entry](https://www.openssl.org/blog/blog/2016/08/24/sweet32/) with further details.

**Akamai** will offer an option for web server
administrators to drop 3DES
from the offered ciphers.

**Apple** has disabled 3DES on icloud.com and is
recommending that
all its customers disable 3DES on their websites.

Currently, most browsers see about 1% of their connections using
3DES, and vendors consider this number too high to simply disable
3DES on the client side, since too many websites would be broken.
So, they are instead considering implementing data limits per
connection to force rekeying, or offering 3DES ciphersuites only in a
fallback negotiation if no AES ciphersuite is acceptable to the
server.

**Mozilla** is [implementing](https://bugzilla.mozilla.org/show_bug.cgi?id=1267899) [data limits](https://bugzilla.mozilla.org/show_bug.cgi?id=1268745) for all
ciphersuites. This has been integrated into [NSS 3.27](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_3.27_release_notes), which should be used in Firefox 51.

**Microsoft** has [removed](https://technet.microsoft.com/library/security/3155527.aspx) 3DES from the False Start
whitelist.

More details about implemented countermeasures
will be added to this webpage as they become
available.

### On the Web

The attack has been mentionned on
[Threatpost](https://threatpost.com/new-collision-attacks-against-3des-blowfish-allow-for-cookie-decryption/120087/),
[Ars Technica](http://arstechnica.com/security/2016/08/new-attack-can-pluck-secrets-from-1-of-https-traffic-affects-top-sites/),
[Matthew Green's blog](http://blog.cryptographyengineering.com/2016/08/attack-of-week-64-bit-ciphers-in-tls.html),
[Tom's hardware](https://nakedsecurity.sophos.com/2016/08/25/anatomy-of-a-cryptographic-collision-the-sweet32-attack/),
[Softpedia](http://news.softpedia.com/news/sweet32-attack-3des-and-blowfish-ciphers-considered-insecure-507631.shtml),
[Naked Security](https://nakedsecurity.sophos.com/2016/08/25/anatomy-of-a-cryptographic-collision-the-sweet32-attack/),
[The Register](http://www.theregister.co.uk/2016/08/29/big_data_busts_crypto_sweet32_captures_collisions_in_old_ciphers/),
[inira.fr](https://www.inria.fr/actualite/actualites-inria/nouvelle-demonstration-de-la-vulnerabilite-de-protocoles-de-securite-internet), and
[ZDnet.fr](http://www.zdnet.fr/actualites/sweet32-les-vieux-algos-se-cachent-pour-mourir-39841068.htm), among others...
.

## FAQ

### Why is 3DES still used with a modern browser?

Because more than 1% of the web servers are poorly configured, and prefer using 3DES rather than AES.

### How can I check if my server is well configured?

You can use
the [scanning tool](https://www.ssllabs.com/ssltest/)
form Qualys SSL Labs. In the "Handshake Simulation" section, you
should see 3DES or RC4 only with browsers that don't support
stronger ciphersuites, like IE6/XP and IE8/XP. If you have 3DES
ciphersuites at the bottom of the "Cipher Suites" section, you can
try to remove them, but it's not an immediate security issue.
Removing 3DES will protect you against potential downgrade attack,
but it will also break connections from older clients.

### How can I fix my server's configuration

You can follow the advice
from [Mozilla](https://wiki.mozilla.org/Security/Server_Side_TLS),
and their [Configuration generator](https://mozilla.github.io/server-side-tls/ssl-config-generator/).

### I'm using Blowfish-256, is it safe?

No, the attack is independent of the key length. It work on
Blowfish with any key length, and Triple-DES with 3 independent keys
(168 bits in total).

### Why Sweet32?

It's a stupid pun, based on
the [sweet
sixteen](https://en.wikipedia.org/wiki/Sweet_sixteen_%28birthday%29) birthday celebration. Our attack is a birthday
attack (taking its name from the [birthday paradox](https://en.wikipedia.org/wiki/Birthday_problem)) with complexity 232. You could also say that
232 is the *sweet spot* where attacks become practical.

### Can I use your logo to talk about the attack?

Yes, you can. To the extent possible under law, GaÃ«tan Leurent
has [waived
all copyright and related or neighboring rights](http://creativecommons.org/publicdomain/zero/1.0/) to
the [Sweet32 logo](sweet32.svg).

## About us

We are a pair of researchers from INRIA, the French national research
institute for computer science. You can contact us at our email addresses:
[FirstName].[LastName]@inria.fr (use our names without any accents.)

* [Karthikeyan Bhargavan](http://prosecco.inria.fr/personal/karthik/)
* [GaÃ«tan Leurent](https://who.rocq.inria.fr/Gaetan.Leurent/)

## Sweet32

![[Sweet32 Logo]](sweet32.svg)

* [Block Ciphers and the Birthday Bound](#intro)
* [Exploiting Block Cipher Collisions](#CBC)
* [64-bit Block Cipher Usage on the Internet](#usage)
* [Attacking Authenticated HTTP over TLS and OpenVPN](#demo)
* [Impact and Mitigation](#impact)
* [FAQ](#faq)
* [About us](#about)
* [Paper](SWEET32_CCS16.pdf)
* [Slides](SWEET32_CCS16_slides.pdf)



=== Content from tools.ietf.org_be610006_20250126_054628.html ===


* Light
* Dark
* Auto

[RFC 5246

Proposed Standard](/doc/rfc5246/)

|  | Title |  | The Transport Layer Security (TLS) Protocol Version 1.2 |
| --- | --- | --- | --- |
| Document | Document type |  | RFC - Proposed Standard  August 2008  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=5246 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") [IPR](/ipr/search/?submit=draft&id=rfc5246 "Click to view IPR declarations.") Obsoleted by [RFC 8446](/doc/html/rfc8446 "The Transport Layer Security (TLS) Protocol Version 1.3") Updated by [RFC 7627](/doc/html/rfc7627 "Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension"), [RFC 9155](/doc/html/rfc9155 "Deprecating MD5 and SHA-1 Signature Hashes in TLS 1.2 and DTLS 1.2"), [RFC 5878](/doc/html/rfc5878 "Transport Layer Security (TLS) Authorization Extensions"), [RFC 5746](/doc/html/rfc5746 "Transport Layer Security (TLS) Renegotiation Indication Extension"), [RFC 6176](/doc/html/rfc6176 "Prohibiting Secure Sockets Layer (SSL) Version 2.0"), [RFC 7465](/doc/html/rfc7465 "Prohibiting RC4 Cipher Suites"), [RFC 7507](/doc/html/rfc7507 "TLS Fallback Signaling Cipher Suite Value (SCSV) for Preventing Protocol Downgrade Attacks"), [RFC 7568](/doc/html/rfc7568 "Deprecating Secure Sockets Layer Version 3.0"), [RFC 7685](/doc/html/rfc7685 "A Transport Layer Security (TLS) ClientHello Padding Extension"), [RFC 7905](/doc/html/rfc7905 "ChaCha20-Poly1305 Cipher Suites for Transport Layer Security (TLS)"), [RFC 7919](/doc/html/rfc7919 "Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)"), [RFC 8447](/doc/html/rfc8447 "IANA Registry Updates for TLS and DTLS") Obsoletes [RFC 4346](/doc/html/rfc4346 "The Transport Layer Security (TLS) Protocol Version 1.1"), [RFC 4366](/doc/html/rfc4366 "Transport Layer Security (TLS) Extensions"), [RFC 3268](/doc/html/rfc3268 "Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)") Updates [RFC 4492](/doc/html/rfc4492 "Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)") Was [draft-ietf-tls-rfc4346-bis](/doc/draft-ietf-tls-rfc4346-bis/10/) ([tls WG](/wg/tls/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [10](/doc/html/draft-ietf-tls-rfc4346-bis-10) * [RFC 5246](/doc/html/rfc5246) |
|  | Compare versions |  | RFC 5246  draft-ietf-tls-rfc4346-bis-10  draft-ietf-tls-rfc4346-bis-09  draft-ietf-tls-rfc4346-bis-08  draft-ietf-tls-rfc4346-bis-07  draft-ietf-tls-rfc4346-bis-06  draft-ietf-tls-rfc4346-bis-05  draft-ietf-tls-rfc4346-bis-04  draft-ietf-tls-rfc4346-bis-03  draft-ietf-tls-rfc4346-bis-02  draft-ietf-tls-rfc4346-bis-01  draft-ietf-tls-rfc4346-bis-00   RFC 5246  draft-ietf-tls-rfc4346-bis-10  draft-ietf-tls-rfc4346-bis-09  draft-ietf-tls-rfc4346-bis-08  draft-ietf-tls-rfc4346-bis-07  draft-ietf-tls-rfc4346-bis-06  draft-ietf-tls-rfc4346-bis-05  draft-ietf-tls-rfc4346-bis-04  draft-ietf-tls-rfc4346-bis-03  draft-ietf-tls-rfc4346-bis-02  draft-ietf-tls-rfc4346-bis-01  draft-ietf-tls-rfc4346-bis-00   Side-by-side  Inline |
|  | Authors |  | [Eric Rescorla](/person/ekr%40rtfm.com "Datatracker profile of Eric Rescorla") , [Tim Dierks](/person/tim%40dierks.org "Datatracker profile of Tim Dierks")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc5246.txt) [html](https://www.rfc-editor.org/rfc/rfc5246.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc5246.txt.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc5246.html) [bibtex](/doc/rfc5246/bibtex/) |
|  | Additional resources |  | [Mailing list discussion](https://mailarchive.ietf.org/arch/browse/tls/?q=rfc5246 OR %22draft-ietf-tls-rfc4346-bis%22) |
|  |  |  | [Report a bug](https://github.com/ietf-tools/datatracker/issues/new/choose) |

```
Network Working Group                                          T. Dierks
Request for Comments: 5246                                   Independent
Obsoletes: [3268](/doc/html/rfc3268), [4346](/doc/html/rfc4346), [4366](/doc/html/rfc4366)                                  E. Rescorla
Updates: [4492](/doc/html/rfc4492)                                                 RTFM, Inc.
Category: Standards Track                                    August 2008

              The Transport Layer Security (TLS) Protocol
                              Version 1.2

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   This document specifies Version 1.2 of the Transport Layer Security
   (TLS) protocol.  The TLS protocol provides communications security
   over the Internet.  The protocol allows client/server applications to
   communicate in a way that is designed to prevent eavesdropping,
   tampering, or message forgery.

Table of Contents

   [1](#section-1). Introduction ....................................................[4](#page-4)
      [1.1](#section-1.1). Requirements Terminology ...................................[5](#page-5)
      [1.2](#section-1.2). Major Differences from TLS 1.1 .............................[5](#page-5)
   [2](#section-2). Goals ...........................................................[6](#page-6)
   [3](#section-3). Goals of This Document ..........................................[7](#page-7)
   [4](#section-4). Presentation Language ...........................................[7](#page-7)
      [4.1](#section-4.1). Basic Block Size ...........................................[7](#page-7)
      [4.2](#section-4.2). Miscellaneous ..............................................[8](#page-8)
      [4.3](#section-4.3). Vectors ....................................................[8](#page-8)
      [4.4](#section-4.4). Numbers ....................................................[9](#page-9)
      [4.5](#section-4.5). Enumerateds ................................................[9](#page-9)
      [4.6](#section-4.6). Constructed Types .........................................[10](#page-10)
           [4.6.1](#section-4.6.1). Variants ...........................................[10](#page-10)
      [4.7](#section-4.7). Cryptographic Attributes ..................................[12](#page-12)
      [4.8](#section-4.8). Constants .................................................[14](#page-14)
   [5](#section-5). HMAC and the Pseudorandom Function .............................[14](#page-14)
   [6](#section-6). The TLS Record Protocol ........................................[15](#page-15)
      [6.1](#section-6.1). Connection States .........................................[16](#page-16)
      [6.2](#section-6.2). Record Layer ..............................................[19](#page-19)
           [6.2.1](#section-6.2.1). Fragmentation ......................................[19](#page-19)

Dierks & Rescorla           Standards Track                     [Page 1]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

           [6.2.2](#section-6.2.2). Record Compression and Decompression ...............[20](#page-20)
           [6.2.3](#section-6.2.3). Record Payload Protection ..........................[21](#page-21)
                  [6.2.3.1](#section-6.2.3.1). Null or Standard Stream Cipher ............[22](#page-22)
                  [6.2.3.2](#section-6.2.3.2). CBC Block Cipher ..........................[22](#page-22)
                  [6.2.3.3](#section-6.2.3.3). AEAD Ciphers ..............................[24](#page-24)
      [6.3](#section-6.3). Key Calculation ...........................................[25](#page-25)
   [7](#section-7). The TLS Handshaking Protocols ..................................[26](#page-26)
      [7.1](#section-7.1). Change Cipher Spec Protocol ...............................[27](#page-27)
      [7.2](#section-7.2). Alert Protocol ............................................[28](#page-28)
           [7.2.1](#section-7.2.1). Closure Alerts .....................................[29](#page-29)
           [7.2.2](#section-7.2.2). Error Alerts .......................................[30](#page-30)
      [7.3](#section-7.3). Handshake Protocol Overview ...............................[33](#page-33)
      [7.4](#section-7.4). Handshake Protocol ........................................[37](#page-37)
           [7.4.1](#section-7.4.1). Hello Messages .....................................[38](#page-38)
                  [7.4.1.1](#section-7.4.1.1). Hello Request .............................[38](#page-38)
                  [7.4.1.2](#section-7.4.1.2). Client Hello ..............................[39](#page-39)
                  [7.4.1.3](#section-7.4.1.3). Server Hello ..............................[42](#page-42)
                  [7.4.1.4](#section-7.4.1.4). Hello Extensions ..........................[44](#page-44)
                           [7.4.1.4.1](#section-7.4.1.4.1). Signature Algorithms ...........[45](#page-45)
           [7.4.2](#section-7.4.2). Server Certificate .................................[47](#page-47)
           [7.4.3](#section-7.4.3). Server Key Exchange Message ........................[50](#page-50)
           [7.4.4](#section-7.4.4). Certificate Request ................................[53](#page-53)
           [7.4.5](#section-7.4.5). Server Hello Done ..................................[55](#page-55)
           [7.4.6](#section-7.4.6). Client Certificate .................................[55](#page-55)
           [7.4.7](#section-7.4.7). Client Key Exchange Message ........................[57](#page-57)
                  [7.4.7.1](#section-7.4.7.1). RSA-Encrypted Premaster Secret Message ....[58](#page-58)
                  [7.4.7.2](#section-7.4.7.2). Client Diffie-Hellman Public Value ........[61](#page-61)
           [7.4.8](#section-7.4.8). Certificate Verify .................................[62](#page-62)
           [7.4.9](#section-7.4.9). Finished ...........................................[63](#page-63)
   [8](#section-8). Cryptographic Computations .....................................[64](#page-64)
      [8.1](#section-8.1). Computing the Master Secret ...............................[64](#page-64)
           [8.1.1](#section-8.1.1). RSA ................................................[65](#page-65)
           [8.1.2](#section-8.1.2). Diffie-Hellman .....................................[65](#page-65)
   [9](#section-9). Mandatory Cipher Suites ........................................[65](#page-65)
   [10](#section-10). Application Data Protocol .....................................[65](#page-65)
   [11](#section-11). Security Considerations .......................................[65](#page-65)
   [12](#section-12). IANA Considerations ...........................................[65](#page-65)
   [Appendix A](#appendix-A). Protocol Data Structures and Constant Values ..........[68](#page-68)
      [A.1](#appendix-A.1). Record Layer ..............................................[68](#page-68)
      [A.2](#appendix-A.2). Change Cipher Specs Message ...............................[69](#page-69)
      [A.3](#appendix-A.3). Alert Messages ............................................[69](#page-69)
      [A.4](#appendix-A.4). Handshake Protocol ........................................[70](#page-70)
           [A.4.1](#appendix-A.4.1). Hello Messages .....................................[71](#page-71)
           [A.4.2](#appendix-A.4.2). Server Authentication and Key Exchange Messages ....[72](#page-72)
           [A.4.3](#appendix-A.4.3). Client Authentication and Key Exchange Messages ....[74](#page-74)
           [A.4.4](#appendix-A.4.4). Handshake Finalization Message .....................[74](#page-74)
      [A.5](#appendix-A.5). The Cipher Suite ..........................................[75](#page-75)
      [A.6](#appendix-A.6). The Security Parameters ...................................[77](#page-77)

Dierks & Rescorla           Standards Track                     [Page 2]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      [A.7](#appendix-A.7). Changes to [RFC 4492](/doc/html/rfc4492) .......................................[78](#page-78)
   [Appendix B](#appendix-B). Glossary ..............................................[78](#page-78)
   [Appendix C](#appendix-C). Cipher Suite Definitions ..............................[83](#page-83)
   [Appendix D](#appendix-D). Implementation Notes ..................................[85](#page-85)
      [D.1](#appendix-D.1). Random Number Generation and Seeding ......................[85](#page-85)
      [D.2](#appendix-D.2). Certificates and Authentication ...........................[85](#page-85)
      [D.3](#appendix-D.3). Cipher Suites .............................................[85](#page-85)
      [D.4](#appendix-D.4). Implementation Pitfalls ...................................[85](#page-85)
   [Appendix E](#appendix-E). Backward Compatibility ................................[87](#page-87)
      [E.1](#appendix-E.1). Compatibility with TLS 1.0/1.1 and SSL 3.0 ................[87](#page-87)
      [E.2](#appendix-E.2). Compatibility with SSL 2.0 ................................[88](#page-88)
      [E.3](#appendix-E.3). Avoiding Man-in-the-Middle Version Rollback ...............[90](#page-90)
   [Appendix F](#appendix-F). Security Analysis .....................................[91](#page-91)
      [F.1](#appendix-F.1). Handshake Protocol ........................................[91](#page-91)
           [F.1.1](#appendix-F.1.1). Authentication and Key Exchange ....................[91](#page-91)
                  [F.1.1.1](#appendix-F.1.1.1). Anonymous Key Exchange ....................[91](#page-91)
                  [F.1.1.2](#appendix-F.1.1.2). RSA Key Exchange and Authentication .......[92](#page-92)
                  F.1.1.3. Diffie-Hellman Key Exchange with
                           Authentication ............................[92](#page-92)
           [F.1.2](#appendix-F.1.2). Version Rollback Attacks ...........................[93](#page-93)
           [F.1.3](#appendix-F.1.3). Detecting Attacks Against the Handshake Protocol ...[94](#page-94)
           [F.1.4](#appendix-F.1.4). Resuming Sessions ..................................[94](#page-94)
      [F.2](#appendix-F.2). Protecting Application Data ...............................[94](#page-94)
      [F.3](#appendix-F.3). Explicit IVs ..............................................[95](#page-95)
      [F.4](#appendix-F.4). Security of Composite Cipher Modes ........................[95](#page-95)
      [F.5](#appendix-F.5). Denial of Service .........................................[96](#page-96)
      [F.6](#appendix-F.6). Final Notes ...............................................[96](#page-96)
   Normative References ..............................................[97](#page-97)
   Informative References ............................................[98](#page-98)
   Working Group Information ........................................[101](#page-101)
   Contributors .....................................................[101](#page-101)

Dierks & Rescorla           Standards Track                     [Page 3]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[1](#section-1).  Introduction

   The primary goal of the TLS protocol is to provide privacy and data
   integrity between two communicating applications.  The protocol is
   composed of two layers: the TLS Record Protocol and the TLS Handshake
   Protocol.  At the lowest level, layered on top of some reliable
   transport protocol (e.g., TCP [[TCP](#ref-TCP)]), is the TLS Record Protocol.
   The TLS Record Protocol provides connection security that has two
   basic properties:

   -  The connection is private.  Symmetric cryptography is used for
      data encryption (e.g., AES [[AES](#ref-AES)], RC4 [[SCH](#ref-SCH)], etc.).  The keys for
      this symmetric encryption are generated uniquely for each
      connection and are based on a secret negotiated by another
      protocol (such as the TLS Handshake Protocol).  The Record
      Protocol can also be used without encryption.

   -  The connection is reliable.  Message transport includes a message
      integrity check using a keyed MAC.  Secure hash functions (e.g.,
      SHA-1, etc.) are used for MAC computations.  The Record Protocol
      can operate without a MAC, but is generally only used in this mode
      while another protocol is using the Record Protocol as a transport
      for negotiating security parameters.

   The TLS Record Protocol is used for encapsulation of various higher-
   level protocols.  One such encapsulated protocol, the TLS Handshake
   Protocol, allows the server and client to authenticate each other and
   to negotiate an encryption algorithm and cryptographic keys before
   the application protocol transmits or receives its first byte of
   data.  The TLS Handshake Protocol provides connection security that
   has three basic properties:

   -  The peer's identity can be authenticated using asymmetric, or
      public key, cryptography (e.g., RSA [[RSA](#ref-RSA)], DSA [[DSS](#ref-DSS)], etc.).  This
      authentication can be made optional, but is generally required for
      at least one of the peers.

   -  The negotiation of a shared secret is secure: the negotiated
      secret is unavailable to eavesdroppers, and for any authenticated
      connection the secret cannot be obtained, even by an attacker who
      can place himself in the middle of the connection.

   -  The negotiation is reliable: no attacker can modify the
      negotiation communication without being detected by the parties to
      the communication.

Dierks & Rescorla           Standards Track                     [Page 4]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   One advantage of TLS is that it is application protocol independent.
   Higher-level protocols can layer on top of the TLS protocol
   transparently.  The TLS standard, however, does not specify how
   protocols add security with TLS; the decisions on how to initiate TLS
   handshaking and how to interpret the authentication certificates
   exchanged are left to the judgment of the designers and implementors
   of protocols that run on top of TLS.

[1.1](#section-1.1).  Requirements Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC 2119](/doc/html/rfc2119) [[REQ](#ref-REQ)].

[1.2](#section-1.2).  Major Differences from TLS 1.1

   This document is a revision of the TLS 1.1 [[TLS1.1](#ref-TLS1.1)] protocol which
   contains improved flexibility, particularly for negotiation of
   cryptographic algorithms.  The major changes are:

   -  The MD5/SHA-1 combination in the pseudorandom function (PRF) has
      been replaced with cipher-suite-specified PRFs.  All cipher suites
      in this document use P_SHA256.

   -  The MD5/SHA-1 combination in the digitally-signed element has been
      replaced with a single hash.  Signed elements now include a field
      that explicitly specifies the hash algorithm used.

   -  Substantial cleanup to the client's and server's ability to
      specify which hash and signature algorithms they will accept.
      Note that this also relaxes some of the constraints on signature
      and hash algorithms from previous versions of TLS.

   -  Addition of support for authenticated encryption with additional
      data modes.

   -  TLS Extensions definition and AES Cipher Suites were merged in
      from external [[TLSEXT](#ref-TLSEXT)] and [[TLSAES](#ref-TLSAES)].

   -  Tighter checking of EncryptedPreMasterSecret version numbers.

   -  Tightened up a number of requirements.

   -  Verify_data length now depends on the cipher suite (default is
      still 12).

   -  Cleaned up description of Bleichenbacher/Klima attack defenses.

Dierks & Rescorla           Standards Track                     [Page 5]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   -  Alerts MUST now be sent in many cases.

   -  After a certificate_request, if no certificates are available,
      clients now MUST send an empty certificate list.

   -  TLS_RSA_WITH_AES_128_CBC_SHA is now the mandatory to implement
      cipher suite.

   -  Added HMAC-SHA256 cipher suites.

   -  Removed IDEA and DES cipher suites.  They are now deprecated and
      will be documented in a separate document.

   -  Support for the SSLv2 backward-compatible hello is now a MAY, not
      a SHOULD, with sending it a SHOULD NOT.  Support will probably
      become a SHOULD NOT in the future.

   -  Added limited "fall-through" to the presentation language to allow
      multiple case arms to have the same encoding.

   -  Added an Implementation Pitfalls sections

   -  The usual clarifications and editorial work.

[2](#section-2).  Goals

   The goals of the TLS protocol, in order of priority, are as follows:

   1. Cryptographic security: TLS should be used to establish a secure
      connection between two parties.

   2. Interoperability: Independent programmers should be able to
      develop applications utilizing TLS that can successfully exchange
      cryptographic parameters without knowledge of one another's code.

   3. Extensibility: TLS seeks to provide a framework into which new
      public key and bulk encryption methods can be incorporated as
      necessary.  This will also accomplish two sub-goals: preventing
      the need to create a new protocol (and risking the introduction of
      possible new weaknesses) and avoiding the need to implement an
      entire new security library.

   4. Relative efficiency: Cryptographic operations tend to be highly
      CPU intensive, particularly public key operations.  For this
      reason, the TLS protocol has incorporated an optional session
      caching scheme to reduce the number of connections that need to be
      established from scratch.  Additionally, care has been taken to
      reduce network activity.

Dierks & Rescorla           Standards Track                     [Page 6]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[3](#section-3).  Goals of This Document

   This document and the TLS protocol itself are based on the SSL 3.0
   Protocol Specification as published by Netscape.  The differences
   between this protocol and SSL 3.0 are not dramatic, but they are
   significant enough that the various versions of TLS and SSL 3.0 do
   not interoperate (although each protocol incorporates a mechanism by
   which an implementation can back down to prior versions).  This
   document is intended primarily for readers who will be implementing
   the protocol and for those doing cryptographic analysis of it.  The
   specification has been written with this in mind, and it is intended
   to reflect the needs of those two groups.  For that reason, many of
   the algorithm-dependent data structures and rules are included in the
   body of the text (as opposed to in an appendix), providing easier
   access to them.

   This document is not intended to supply any details of service
   definition or of interface definition, although it does cover select
   areas of policy as they are required for the maintenance of solid
   security.

[4](#section-4).  Presentation Language

   This document deals with the formatting of data in an external
   representation.  The following very basic and somewhat casually
   defined presentation syntax will be used.  The syntax draws from
   several sources in its structure.  Although it resembles the
   programming language "C" in its syntax and XDR [[XDR](#ref-XDR)] in both its
   syntax and intent, it would be risky to draw too many parallels.  The
   purpose of this presentation language is to document TLS only; it has
   no general application beyond that particular goal.

[4.1](#section-4.1).  Basic Block Size

   The representation of all data items is explicitly specified.  The
   basic data block size is one byte (i.e., 8 bits).  Multiple byte data
   items are concatenations of bytes, from left to right, from top to
   bottom.  From the byte stream, a multi-byte item (a numeric in the
   example) is formed (using C notation) by:

      value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |
              ... | byte[n-1];

   This byte ordering for multi-byte values is the commonplace network
   byte order or big-endian format.

Dierks & Rescorla           Standards Track                     [Page 7]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[4.2](#section-4.2).  Miscellaneous

   Comments begin with "/*" and end with "*/".

   Optional components are denoted by enclosing them in "[[ ]]" double
   brackets.

   Single-byte entities containing uninterpreted data are of type
   opaque.

[4.3](#section-4.3).  Vectors

   A vector (single-dimensioned array) is a stream of homogeneous data
   elements.  The size of the vector may be specified at documentation
   time or left unspecified until runtime.  In either case, the length
   declares the number of bytes, not the number of elements, in the
   vector.  The syntax for specifying a new type, T', that is a fixed-
   length vector of type T is

      T T'[n];

   Here, T' occupies n bytes in the data stream, where n is a multiple
   of the size of T.  The length of the vector is not included in the
   encoded stream.

   In the following example, Datum is defined to be three consecutive
   bytes that the protocol does not interpret, while Data is three
   consecutive Datum, consuming a total of nine bytes.

      opaque Datum[3];      /* three uninterpreted bytes */
      Datum Data[9];        /* 3 consecutive 3 byte vectors */

   Variable-length vectors are defined by specifying a subrange of legal
   lengths, inclusively, using the notation <floor..ceiling>.  When
   these are encoded, the actual length precedes the vector's contents
   in the byte stream.  The length will be in the form of a number
   consuming as many bytes as required to hold the vector's specified
   maximum (ceiling) length.  A variable-length vector with an actual
   length field of zero is referred to as an empty vector.

      T T'<floor..ceiling>;

   In the following example, mandatory is a vector that must contain
   between 300 and 400 bytes of type opaque.  It can never be empty.
   The actual length field consumes two bytes, a uint16, which is
   sufficient to represent the value 400 (see [Section 4.4](#section-4.4)).  On the
   other hand, longer can represent up to 800 bytes of data, or 400
   uint16 elements, and it may be empty.  Its encoding will include a

Dierks & Rescorla           Standards Track                     [Page 8]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   two-byte actual length field prepended to the vector.  The length of
   an encoded vector must be an even multiple of the length of a single
   element (for example, a 17-byte vector of uint16 would be illegal).

      opaque mandatory<300..400>;
            /* length field is 2 bytes, cannot be empty */
      uint16 longer<0..800>;
            /* zero to 400 16-bit unsigned integers */

[4.4](#section-4.4).  Numbers

   The basic numeric data type is an unsigned byte (uint8).  All larger
   numeric data types are formed from fixed-length series of bytes
   concatenated as described in [Section 4.1](#section-4.1) and are also unsigned.  The
   following numeric types are predefined.

      uint8 uint16[2];
      uint8 uint24[3];
      uint8 uint32[4];
      uint8 uint64[8];

   All values, here and elsewhere in the specification, are stored in
   network byte (big-endian) order; the uint32 represented by the hex
   bytes 01 02 03 04 is equivalent to the decimal value 16909060.

   Note that in some cases (e.g., DH parameters) it is necessary to
   represent integers as opaque vectors.  In such cases, they are
   represented as unsigned integers (i.e., leading zero octets are not
   required even if the most significant bit is set).

[4.5](#section-4.5).  Enumerateds

   An additional sparse data type is available called enum.  A field of
   type enum can only assume the values declared in the definition.
   Each definition is a different type.  Only enumerateds of the same
   type may be assigned or compared.  Every element of an enumerated
   must be assigned a value, as demonstrated in the following example.
   Since the elements of the enumerated are not ordered, they can be
   assigned any unique value, in any order.

      enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;

   An enumerated occupies as much space in the byte stream as would its
   maximal defined ordinal value.  The following definition would cause
   one byte to be used to carry fields of type Color.

      enum { red(3), blue(5), white(7) } Color;

Dierks & Rescorla           Standards Track                     [Page 9]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   One may optionally specify a value without its associated tag to
   force the width definition without defining a superfluous element.

   In the following example, Taste will consume two bytes in the data
   stream but can only assume the values 1, 2, or 4.

      enum { sweet(1), sour(2), bitter(4), (32000) } Taste;

   The names of the elements of an enumeration are scoped within the
   defined type.  In the first example, a fully qualified reference to
   the second element of the enumeration would be Color.blue.  Such
   qualification is not required if the target of the assignment is well
   specified.

      Color color = Color.blue;     /* overspecified, legal */
      Color color = blue;           /* correct, type implicit */

   For enumerateds that are never converted to external representation,
   the numerical information may be omitted.

      enum { low, medium, high } Amount;

[4.6](#section-4.6).  Constructed Types

   Structure types may be constructed from primitive types for
   convenience.  Each specification declares a new, unique type.  The
   syntax for definition is much like that of C.

      struct {
          T1 f1;
          T2 f2;
          ...
          Tn fn;
      } [[T]];

   The fields within a structure may be qualified using the type's name,
   with a syntax much like that available for enumerateds.  For example,
   T.f2 refers to the second field of the previous declaration.
   Structure definitions may be embedded.

[4.6.1](#section-4.6.1).  Variants

   Defined structures may have variants based on some knowledge that is
   available within the environment.  The selector must be an enumerated
   type that defines the possible variants the structure defines.  There
   must be a case arm for every element of the enumeration declared in
   the select.  Case arms have limited fall-through: if two case arms
   follow in immediate succession with no fields in between, then they

Dierks & Rescorla           Standards Track                    [Page 10]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   both contain the same fields.  Thus, in the example below, "orange"
   and "banana" both contain V2.  Note that this is a new piece of
   syntax in TLS 1.2.

   The body of the variant structure may be given a label for reference.
   The mechanism by which the variant is selected at runtime is not
   prescribed by the presentation language.

      struct {
          T1 f1;
          T2 f2;
          ....
          Tn fn;
           select (E) {
               case e1: Te1;
               case e2: Te2;
               case e3: case e4: Te3;
               ....
               case en: Ten;
           } [[fv]];
      } [[Tv]];

   For example:

      enum { apple, orange, banana } VariantTag;

      struct {
          uint16 number;
          opaque string<0..10>; /* variable length */
      } V1;

      struct {
          uint32 number;
          opaque string[10];    /* fixed length */
      } V2;

      struct {
          select (VariantTag) { /* value of selector is implicit */
              case apple:
                V1;   /* VariantBody, tag = apple */
              case orange:
              case banana:
                V2;   /* VariantBody, tag = orange or banana */
          } variant_body;       /* optional label on variant */
      } VariantRecord;

Dierks & Rescorla           Standards Track                    [Page 11]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[4.7](#section-4.7).  Cryptographic Attributes

   The five cryptographic operations -- digital signing, stream cipher
   encryption, block cipher encryption, authenticated encryption with
   additional data (AEAD) encryption, and public key encryption -- are
   designated digitally-signed, stream-ciphered, block-ciphered, aead-
   ciphered, and public-key-encrypted, respectively.  A field's
   cryptographic processing is specified by prepending an appropriate
   key word designation before the field's type specification.
   Cryptographic keys are implied by the current session state (see
   [Section 6.1](#section-6.1)).

   A digitally-signed element is encoded as a struct DigitallySigned:

      struct {
         SignatureAndHashAlgorithm algorithm;
         opaque signature<0..2^16-1>;
      } DigitallySigned;

   The algorithm field specifies the algorithm used (see [Section](#section-7.4.1.4.1)
   [7.4.1.4.1](#section-7.4.1.4.1) for the definition of this field).  Note that the
   introduction of the algorithm field is a change from previous
   versions.  The signature is a digital signature using those
   algorithms over the contents of the element.  The contents themselves
   do not appear on the wire but are simply calculated.  The length of
   the signature is specified by the signing algorithm and key.

   In RSA signing, the opaque vector contains the signature generated
   using the RSASSA-PKCS1-v1_5 signature scheme defined in [[PKCS1](#ref-PKCS1)].  As
   discussed in [[PKCS1](#ref-PKCS1)], the DigestInfo MUST be DER-encoded [[X680](#ref-X680)]
   [[X690](#ref-X690)].  For hash algorithms without parameters (which includes
   SHA-1), the DigestInfo.AlgorithmIdentifier.parameters field MUST be
   NULL, but implementations MUST accept both without parameters and
   with NULL parameters.  Note that earlier versions of TLS used a
   different RSA signature scheme that did not include a DigestInfo
   encoding.

   In DSA, the 20 bytes of the SHA-1 hash are run directly through the
   Digital Signing Algorithm with no additional hashing.  This produces
   two values, r and s.  The DSA signature is an opaque vector, as
   above, the contents of which are the DER encoding of:

      Dss-Sig-Value ::= SEQUENCE {
          r INTEGER,
          s INTEGER
      }

Dierks & Rescorla           Standards Track                    [Page 12]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Note: In current terminology, DSA refers to the Digital Signature
   Algorithm and DSS refers to the NIST standard.  In the original SSL
   and TLS specs, "DSS" was used universally.  This document uses "DSA"
   to refer to the algorithm, "DSS" to refer to the standard, and it
   uses "DSS" in the code point definitions for historical continuity.

   In stream cipher encryption, the plaintext is exclusive-ORed with an
   identical amount of output generated from a cryptographically secure
   keyed pseudorandom number generator.

   In block cipher encryption, every block of plaintext encrypts to a
   block of ciphertext.  All block cipher encryption is done in CBC
   (Cipher Block Chaining) mode, and all items that are block-ciphered
   will be an exact multiple of the cipher block length.

   In AEAD encryption, the plaintext is simultaneously encrypted and
   integrity protected.  The input may be of any length, and aead-
   ciphered output is generally larger than the input in order to
   accommodate the integrity check value.

   In public key encryption, a public key algorithm is used to encrypt
   data in such a way that it can be decrypted only with the matching
   private key.  A public-key-encrypted element is encoded as an opaque
   vector <0..2^16-1>, where the length is specified by the encryption
   algorithm and key.

   RSA encryption is done using the RSAES-PKCS1-v1_5 encryption scheme
   defined in [[PKCS1](#ref-PKCS1)].

   In the following example

      stream-ciphered struct {
          uint8 field1;
          uint8 field2;
          digitally-signed opaque {
            uint8 field3<0..255>;
            uint8 field4;
          };
      } UserType;

   The contents of the inner struct (field3 and field4) are used as
   input for the signature/hash algorithm, and then the entire structure
   is encrypted with a stream cipher.  The length of this structure, in
   bytes, would be equal to two bytes for field1 and field2, plus two
   bytes for the signature and hash algorithm, plus two bytes for the
   length of the signature, plus the length of the output of the signing

Dierks & Rescorla           Standards Track                    [Page 13]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   algorithm.  The length of the signature is known because the
   algorithm and key used for the signing are known prior to encoding or
   decoding this structure.

[4.8](#section-4.8).  Constants

   Typed constants can be defined for purposes of specification by
   declaring a symbol of the desired type and assigning values to it.

   Under-specified types (opaque, variable-length vectors, and
   structures that contain opaque) cannot be assigned values.  No fields
   of a multi-element structure or vector may be elided.

   For example:

      struct {
          uint8 f1;
          uint8 f2;
      } Example1;

      Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */

[5](#section-5).  HMAC and the Pseudorandom Function

   The TLS record layer uses a keyed Message Authentication Code (MAC)
   to protect message integrity.  The cipher suites defined in this
   document use a construction known as HMAC, described in [[HMAC](#ref-HMAC)], which
   is based on a hash function.  Other cipher suites MAY define their
   own MAC constructions, if needed.

   In addition, a construction is required to do expansion of secrets
   into blocks of data for the purposes of key generation or validation.
   This pseudorandom function (PRF) takes as input a secret, a seed, and
   an identifying label and produces an output of arbitrary length.

   In this section, we define one PRF, based on HMAC.  This PRF with the
   SHA-256 hash function is used for all cipher suites defined in this
   document and in TLS documents published prior to this document when
   TLS 1.2 is negotiated.  New cipher suites MUST explicitly specify a
   PRF and, in general, SHOULD use the TLS PRF with SHA-256 or a
   stronger standard hash function.

   First, we define a data expansion function, P_hash(secret, data),
   that uses a single hash function to expand a secret and seed into an
   arbitrary quantity of output:

Dierks & Rescorla           Standards Track                    [Page 14]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
                             HMAC_hash(secret, A(2) + seed) +
                             HMAC_hash(secret, A(3) + seed) + ...

   where + indicates concatenation.

   A() is defined as:

      A(0) = seed
      A(i) = HMAC_hash(secret, A(i-1))

   P_hash can be iterated as many times as necessary to produce the
   required quantity of data.  For example, if P_SHA256 is being used to
   create 80 bytes of data, it will have to be iterated three times
   (through A(3)), creating 96 bytes of output data; the last 16 bytes
   of the final iteration will then be discarded, leaving 80 bytes of
   output data.

   TLS's PRF is created by applying P_hash to the secret as:

      PRF(secret, label, seed) = P_<hash>(secret, label + seed)

   The label is an ASCII string.  It should be included in the exact
   form it is given without a length byte or trailing null character.
   For example, the label "slithy toves" would be processed by hashing
   the following bytes:

      73 6C 69 74 68 79 20 74 6F 76 65 73

[6](#section-6).  The TLS Record Protocol

   The TLS Record Protocol is a layered protocol.  At each layer,
   messages may include fields for length, description, and content.
   The Record Protocol takes messages to be transmitted, fragments the
   data into manageable blocks, optionally compresses the data, applies
   a MAC, encrypts, and transmits the result.  Received data is
   decrypted, verified, decompressed, reassembled, and then delivered to
   higher-level clients.

   Four protocols that use the record protocol are described in this
   document: the handshake protocol, the alert protocol, the change
   cipher spec protocol, and the application data protocol.  In order to
   allow extension of the TLS protocol, additional record content types
   can be supported by the record protocol.  New record content type
   values are assigned by IANA in the TLS Content Type Registry as
   described in [Section 12](#section-12).

Dierks & Rescorla           Standards Track                    [Page 15]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Implementations MUST NOT send record types not defined in this
   document unless negotiated by some extension.  If a TLS
   implementation receives an unexpected record type, it MUST send an
   unexpected_message alert.

   Any protocol designed for use over TLS must be carefully designed to
   deal with all possible attacks against it.  As a practical matter,
   this means that the protocol designer must be aware of what security
   properties TLS does and does not provide and cannot safely rely on
   the latter.

   Note in particular that type and length of a record are not protected
   by encryption.  If this information is itself sensitive, application
   designers may wish to take steps (padding, cover traffic) to minimize
   information leakage.

[6.1](#section-6.1).  Connection States

   A TLS connection state is the operating environment of the TLS Record
   Protocol.  It specifies a compression algorithm, an encryption
   algorithm, and a MAC algorithm.  In addition, the parameters for
   these algorithms are known: the MAC key and the bulk encryption keys
   for the connection in both the read and the write directions.
   Logically, there are always four connection states outstanding: the
   current read and write states, and the pending read and write states.
   All records are processed under the current read and write states.
   The security parameters for the pending states can be set by the TLS
   Handshake Protocol, and the ChangeCipherSpec can selectively make
   either of the pending states current, in which case the appropriate
   current state is disposed of and replaced with the pending state; the
   pending state is then reinitialized to an empty state.  It is illegal
   to make a state that has not been initialized with security
   parameters a current state.  The initial current state always
   specifies that no encryption, compression, or MAC will be used.

   The security parameters for a TLS Connection read and write state are
   set by providing the following values:

   connection end
      Whether this entity is considered the "client" or the "server" in
      this connection.

   PRF algorithm
      An algorithm used to generate keys from the master secret (see
      Sections [5](#section-5) and [6.3](#section-6.3)).

Dierks & Rescorla           Standards Track                    [Page 16]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   bulk encryption algorithm
      An algorithm to be used for bulk encryption.  This specification
      includes the key size of this algorithm, whether it is a block,
      stream, or AEAD cipher, the block size of the cipher (if
      appropriate), and the lengths of explicit and implicit
      initialization vectors (or nonces).

   MAC algorithm
      An algorithm to be used for message authentication.  This
      specification includes the size of the value returned by the MAC
      algorithm.

   compression algorithm
      An algorithm to be used for data compression.  This specification
      must include all information the algorithm requires to do
      compression.

   master secret
      A 48-byte secret shared between the two peers in the connection.

   client random
      A 32-byte value provided by the client.

   server random
      A 32-byte value provided by the server.

      These parameters are defined in the presentation language as:

      enum { server, client } ConnectionEnd;

      enum { tls_prf_sha256 } PRFAlgorithm;

      enum { null, rc4, 3des, aes }
        BulkCipherAlgorithm;

      enum { stream, block, aead } CipherType;

      enum { null, hmac_md5, hmac_sha1, hmac_sha256,
           hmac_sha384, hmac_sha512} MACAlgorithm;

      enum { null(0), (255) } CompressionMethod;

      /* The algorithms specified in CompressionMethod, PRFAlgorithm,
         BulkCipherAlgorithm, and MACAlgorithm may be added to. */

Dierks & Rescorla           Standards Track                    [Page 17]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      struct {
          ConnectionEnd          entity;
          PRFAlgorithm           prf_algorithm;
          BulkCipherAlgorithm    bulk_cipher_algorithm;
          CipherType             cipher_type;
          uint8                  enc_key_length;
          uint8                  block_length;
          uint8                  fixed_iv_length;
          uint8                  record_iv_length;
          MACAlgorithm           mac_algorithm;
          uint8                  mac_length;
          uint8                  mac_key_length;
          CompressionMethod      compression_algorithm;
          opaque                 master_secret[48];
          opaque                 client_random[32];
          opaque                 server_random[32];
      } SecurityParameters;

   The record layer will use the security parameters to generate the
   following six items (some of which are not required by all ciphers,
   and are thus empty):

      client write MAC key
      server write MAC key
      client write encryption key
      server write encryption key
      client write IV
      server write IV

   The client write parameters are used by the server when receiving and
   processing records and vice versa.  The algorithm used for generating
   these items from the security parameters is described in [Section 6.3](#section-6.3).

   Once the security parameters have been set and the keys have been
   generated, the connection states can be instantiated by making them
   the current states.  These current states MUST be updated for each
   record processed.  Each connection state includes the following
   elements:

   compression state
      The current state of the compression algorithm.

   cipher state
      The current state of the encryption algorithm.  This will consist
      of the scheduled key for that connection.  For stream ciphers,
      this will also contain whatever state information is necessary to
      allow the stream to continue to encrypt or decrypt data.

Dierks & Rescorla           Standards Track                    [Page 18]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   MAC key
      The MAC key for this connection, as generated above.

   sequence number
      Each connection state contains a sequence number, which is
      maintained separately for read and write states.  The sequence
      number MUST be set to zero whenever a connection state is made the
      active state.  Sequence numbers are of type uint64 and may not
      exceed 2^64-1.  Sequence numbers do not wrap.  If a TLS
      implementation would need to wrap a sequence number, it must
      renegotiate instead.  A sequence number is incremented after each
      record: specifically, the first record transmitted under a
      particular connection state MUST use sequence number 0.

[6.2](#section-6.2).  Record Layer

   The TLS record layer receives uninterpreted data from higher layers
   in non-empty blocks of arbitrary size.

[6.2.1](#section-6.2.1).  Fragmentation

   The record layer fragments information blocks into TLSPlaintext
   records carrying data in chunks of 2^14 bytes or less.  Client
   message boundaries are not preserved in the record layer (i.e.,
   multiple client messages of the same ContentType MAY be coalesced
   into a single TLSPlaintext record, or a single message MAY be
   fragmented across several records).

      struct {
          uint8 major;
          uint8 minor;
      } ProtocolVersion;

      enum {
          change_cipher_spec(20), alert(21), handshake(22),
          application_data(23), (255)
      } ContentType;

      struct {
          ContentType type;
          ProtocolVersion version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;

   type
      The higher-level protocol used to process the enclosed fragment.

Dierks & Rescorla           Standards Track                    [Page 19]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   version
      The version of the protocol being employed.  This document
      describes TLS Version 1.2, which uses the version { 3, 3 }.  The
      version value 3.3 is historical, deriving from the use of {3, 1}
      for TLS 1.0.  (See [Appendix A.1](#appendix-A.1).)  Note that a client that
      supports multiple versions of TLS may not know what version will
      be employed before it receives the ServerHello.  See [Appendix E](#appendix-E)
      for discussion about what record layer version number should be
      employed for ClientHello.

   length
      The length (in bytes) of the following TLSPlaintext.fragment.  The
      length MUST NOT exceed 2^14.

   fragment
      The application data.  This data is transparent and treated as an
      independent block to be dealt with by the higher-level protocol
      specified by the type field.

   Implementations MUST NOT send zero-length fragments of Handshake,
   Alert, or ChangeCipherSpec content types.  Zero-length fragments of
   Application data MAY be sent as they are potentially useful as a
   traffic analysis countermeasure.

   Note: Data of different TLS record layer content types MAY be
   interleaved.  Application data is generally of lower precedence for
   transmission than other content types.  However, records MUST be
   delivered to the network in the same order as they are protected by
   the record layer.  Recipients MUST receive and process interleaved
   application layer traffic during handshakes subsequent to the first
   one on a connection.

[6.2.2](#section-6.2.2).  Record Compression and Decompression

   All records are compressed using the compression algorithm defined in
   the current session state.  There is always an active compression
   algorithm; however, initially it is defined as
   CompressionMethod.null.  The compression algorithm translates a
   TLSPlaintext structure into a TLSCompressed structure.  Compression
   functions are initialized with default state information whenever a
   connection state is made active.  [[RFC3749](/doc/html/rfc3749)] describes compression
   algorithms for TLS.

   Compression must be lossless and may not increase the content length
   by more than 1024 bytes.  If the decompression function encounters a
   TLSCompressed.fragment that would decompress to a length in excess of
   2^14 bytes, it MUST report a fatal decompression failure error.

Dierks & Rescorla           Standards Track                    [Page 20]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      struct {
          ContentType type;       /* same as TLSPlaintext.type */
          ProtocolVersion version;/* same as TLSPlaintext.version */
          uint16 length;
          opaque fragment[TLSCompressed.length];
      } TLSCompressed;

   length
      The length (in bytes) of the following TLSCompressed.fragment.
      The length MUST NOT exceed 2^14 + 1024.

   fragment
      The compressed form of TLSPlaintext.fragment.

      Note: A CompressionMethod.null operation is an identity operation;
      no fields are altered.

      Implementation note: Decompression functions are responsible for
      ensuring that messages cannot cause internal buffer overflows.

[6.2.3](#section-6.2.3).  Record Payload Protection

      The encryption and MAC functions translate a TLSCompressed
      structure into a TLSCiphertext.  The decryption functions reverse
      the process.  The MAC of the record also includes a sequence
      number so that missing, extra, or repeated messages are
      detectable.

      struct {
          ContentType type;
          ProtocolVersion version;
          uint16 length;
          select (SecurityParameters.cipher_type) {
              case stream: GenericStreamCipher;
              case block:  GenericBlockCipher;
              case aead:   GenericAEADCipher;
          } fragment;
      } TLSCiphertext;

   type
      The type field is identical to TLSCompressed.type.

   version
      The version field is identical to TLSCompressed.version.

   length
      The length (in bytes) of the following TLSCiphertext.fragment.
      The length MUST NOT exceed 2^14 + 2048.

Dierks & Rescorla           Standards Track                    [Page 21]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   fragment
      The encrypted form of TLSCompressed.fragment, with the MAC.

[6.2.3.1](#section-6.2.3.1).  Null or Standard Stream Cipher

   Stream ciphers (including BulkCipherAlgorithm.null; see [Appendix A.6](#appendix-A.6))
   convert TLSCompressed.fragment structures to and from stream
   TLSCiphertext.fragment structures.

      stream-ciphered struct {
          opaque content[TLSCompressed.length];
          opaque MAC[SecurityParameters.mac_length];
      } GenericStreamCipher;

   The MAC is generated as:

      MAC(MAC_write_key, seq_num +
                            TLSCompressed.type +
                            TLSCompressed.version +
                            TLSCompressed.length +
                            TLSCompressed.fragment);

   where "+" denotes concatenation.

   seq_num
      The sequence number for this record.

   MAC
      The MAC algorithm specified by SecurityParameters.mac_algorithm.

   Note that the MAC is computed before encryption.  The stream cipher
   encrypts the entire block, including the MAC.  For stream ciphers
   that do not use a synchronization vector (such as RC4), the stream
   cipher state from the end of one record is simply used on the
   subsequent packet.  If the cipher suite is TLS_NULL_WITH_NULL_NULL,
   encryption consists of the identity operation (i.e., the data is not
   encrypted, and the MAC size is zero, implying that no MAC is used).
   For both null and stream ciphers, TLSCiphertext.length is
   TLSCompressed.length plus SecurityParameters.mac_length.

[6.2.3.2](#section-6.2.3.2).  CBC Block Cipher

   For block ciphers (such as 3DES or AES), the encryption and MAC
   functions convert TLSCompressed.fragment structures to and from block
   TLSCiphertext.fragment structures.

Dierks & Rescorla           Standards Track                    [Page 22]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      struct {
          opaque IV[SecurityParameters.record_iv_length];
          block-ciphered struct {
              opaque content[TLSCompressed.length];
              opaque MAC[SecurityParameters.mac_length];
              uint8 padding[GenericBlockCipher.padding_length];
              uint8 padding_length;
          };
      } GenericBlockCipher;

   The MAC is generated as described in [Section 6.2.3.1](#section-6.2.3.1).

   IV
      The Initialization Vector (IV) SHOULD be chosen at random, and
      MUST be unpredictable.  Note that in versions of TLS prior to 1.1,
      there was no IV field, and the last ciphertext block of the
      previous record (the "CBC residue") was used as the IV.  This was
      changed to prevent the attacks described in [[CBCATT](#ref-CBCATT)].  For block
      ciphers, the IV length is of length
      SecurityParameters.record_iv_length, which is equal to the
      SecurityParameters.block_size.

   padding
      Padding that is added to force the length of the plaintext to be
      an integral multiple of the block cipher's block length.  The
      padding MAY be any length up to 255 bytes, as long as it results
      in the TLSCiphertext.length being an integral multiple of the
      block length.  Lengths longer than necessary might be desirable to
      frustrate attacks on a protocol that are based on analysis of the
      lengths of exchanged messages.  Each uint8 in the padding data
      vector MUST be filled with the padding length value.  The receiver
      MUST check this padding and MUST use the bad_record_mac alert to
      indicate padding errors.

   padding_length
      The padding length MUST be such that the total size of the
      GenericBlockCipher structure is a multiple of the cipher's block
      length.  Legal values range from zero to 255, inclusive.  This
      length specifies the length of the padding field exclusive of the
      padding_length field itself.

   The encrypted data length (TLSCiphertext.length) is one more than the
   sum of SecurityParameters.block_length, TLSCompressed.length,
   SecurityParameters.mac_length, and padding_length.

   Example: If the block length is 8 bytes, the content length
   (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes,
   then the length before padding is 82 bytes (this does not include the

Dierks & Rescorla           Standards Track                    [Page 23]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   IV.  Thus, the padding length modulo 8 must be equal to 6 in order to
   make the total length an even multiple of 8 bytes (the block length).
   The padding length can be 6, 14, 22, and so on, through 254.  If the
   padding length were the minimum necessary, 6, the padding would be 6
   bytes, each containing the value 6.  Thus, the last 8 octets of the
   GenericBlockCipher before block encryption would be xx 06 06 06 06 06
   06 06, where xx is the last octet of the MAC.

   Note: With block ciphers in CBC mode (Cipher Block Chaining), it is
   critical that the entire plaintext of the record be known before any
   ciphertext is transmitted.  Otherwise, it is possible for the
   attacker to mount the attack described in [[CBCATT](#ref-CBCATT)].

   Implementation note: Canvel et al. [[CBCTIME](#ref-CBCTIME)] have demonstrated a
   timing attack on CBC padding based on the time required to compute
   the MAC.  In order to defend against this attack, implementations
   MUST ensure that record processing time is essentially the same
   whether or not the padding is correct.  In general, the best way to
   do this is to compute the MAC even if the padding is incorrect, and
   only then reject the packet.  For instance, if the pad appears to be
   incorrect, the implementation might assume a zero-length pad and then
   compute the MAC.  This leaves a small timing channel, since MAC
   performance depends to some extent on the size of the data fragment,
   but it is not believed to be large enough to be exploitable, due to
   the large block size of existing MACs and the small size of the
   timing signal.

[6.2.3.3](#section-6.2.3.3).  AEAD Ciphers

   For AEAD [[AEAD](#ref-AEAD)] ciphers (such as [[CCM](#ref-CCM)] or [[GCM](#ref-GCM)]), the AEAD function
   converts TLSCompressed.fragment structures to and from AEAD
   TLSCiphertext.fragment structures.

      struct {
         opaque nonce_explicit[SecurityParameters.record_iv_length];
         aead-ciphered struct {
             opaque content[TLSCompressed.length];
         };
      } GenericAEADCipher;

   AEAD ciphers take as input a single key, a nonce, a plaintext, and
   "additional data" to be included in the authentication check, as
   described in Section 2.1 of [[AEAD](#ref-AEAD)].  The key is either the
   client_write_key or the server_write_key.  No MAC key is used.

   Each AEAD cipher suite MUST specify how the nonce supplied to the
   AEAD operation is constructed, and what is the length of the
   GenericAEADCipher.nonce_explicit part.  In many cases, it is

Dierks & Rescorla           Standards Track                    [Page 24]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   appropriate to use the partially implicit nonce technique described
   in Section 3.2.1 of [[AEAD](#ref-AEAD)]; with record_iv_length being the length of
   the explicit part.  In this case, the implicit part SHOULD be derived
   from key_block as client_write_iv and server_write_iv (as described
   in [Section 6.3](#section-6.3)), and the explicit part is included in
   GenericAEAEDCipher.nonce_explicit.

   The plaintext is the TLSCompressed.fragment.

   The additional authenticated data, which we denote as
   additional_data, is defined as follows:

      additional_data = seq_num + TLSCompressed.type +
                        TLSCompressed.version + TLSCompressed.length;

   where "+" denotes concatenation.

   The aead_output consists of the ciphertext output by the AEAD
   encryption operation.  The length will generally be larger than
   TLSCompressed.length, but by an amount that varies with the AEAD
   cipher.  Since the ciphers might incorporate padding, the amount of
   overhead could vary with different TLSCompressed.length values.  Each
   AEAD cipher MUST NOT produce an expansion of greater than 1024 bytes.
   Symbolically,

      AEADEncrypted = AEAD-Encrypt(write_key, nonce, plaintext,
                                   additional_data)

   In order to decrypt and verify, the cipher takes as input the key,
   nonce, the "additional_data", and the AEADEncrypted value.  The
   output is either the plaintext or an error indicating that the
   decryption failed.  There is no separate integrity check.  That is:

      TLSCompressed.fragment = AEAD-Decrypt(write_key, nonce,
                                            AEADEncrypted,
                                            additional_data)

   If the decryption fails, a fatal bad_record_mac alert MUST be
   generated.

[6.3](#section-6.3).  Key Calculation

   The Record Protocol requires an algorithm to generate keys required
   by the current connection state (see [Appendix A.6](#appendix-A.6)) from the security
   parameters provided by the handshake protocol.

Dierks & Rescorla           Standards Track                    [Page 25]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   The master secret is expanded into a sequence of secure bytes, which
   is then split to a client write MAC key, a server write MAC key, a
   client write encryption key, and a server write encryption key.  Each
   of these is generated from the byte sequence in that order.  Unused
   values are empty.  Some AEAD ciphers may additionally require a
   client write IV and a server write IV (see [Section 6.2.3.3](#section-6.2.3.3)).

   When keys and MAC keys are generated, the master secret is used as an
   entropy source.

   To generate the key material, compute

      key_block = PRF(SecurityParameters.master_secret,
                      "key expansion",
                      SecurityParameters.server_random +
                      SecurityParameters.client_random);

   until enough output has been generated.  Then, the key_block is
   partitioned as follows:

      client_write_MAC_key[SecurityParameters.mac_key_length]
      server_write_MAC_key[SecurityParameters.mac_key_length]
      client_write_key[SecurityParameters.enc_key_length]
      server_write_key[SecurityParameters.enc_key_length]
      client_write_IV[SecurityParameters.fixed_iv_length]
      server_write_IV[SecurityParameters.fixed_iv_length]

   Currently, the client_write_IV and server_write_IV are only generated
   for implicit nonce techniques as described in Section 3.2.1 of
   [[AEAD](#ref-AEAD)].

   Implementation note: The currently defined cipher suite which
   requires the most material is AES_256_CBC_SHA256.  It requires 2 x 32
   byte keys and 2 x 32 byte MAC keys, for a total 128 bytes of key
   material.

[7](#section-7).  The TLS Handshaking Protocols

   TLS has three subprotocols that are used to allow peers to agree upon
   security parameters for the record layer, to authenticate themselves,
   to instantiate negotiated security parameters, and to report error
   conditions to each other.

   The Handshake Protocol is responsible for negotiating a session,
   which consists of the following items:

Dierks & Rescorla           Standards Track                    [Page 26]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   session identifier
      An arbitrary byte sequence chosen by the server to identify an
      active or resumable session state.

   peer certificate
      X509v3 [[PKIX](#ref-PKIX)] certificate of the peer.  This element of the state
      may be null.

   compression method
      The algorithm used to compress data prior to encryption.

   cipher spec
      Specifies the pseudorandom function (PRF) used to generate keying
      material, the bulk data encryption algorithm (such as null, AES,
      etc.) and the MAC algorithm (such as HMAC-SHA1).  It also defines
      cryptographic attributes such as the mac_length.  (See [Appendix](#appendix-A.6)
      [A.6](#appendix-A.6) for formal definition.)

   master secret
      48-byte secret shared between the client and server.

   is resumable
      A flag indicating whether the session can be used to initiate new
      connections.

   These items are then used to create security parameters for use by
   the record layer when protecting application data.  Many connections
   can be instantiated using the same session through the resumption
   feature of the TLS Handshake Protocol.

[7.1](#section-7.1).  Change Cipher Spec Protocol

   The change cipher spec protocol exists to signal transitions in
   ciphering strategies.  The protocol consists of a single message,
   which is encrypted and compressed under the current (not the pending)
   connection state.  The message consists of a single byte of value 1.

      struct {
          enum { change_cipher_spec(1), (255) } type;
      } ChangeCipherSpec;

   The ChangeCipherSpec message is sent by both the client and the
   server to notify the receiving party that subsequent records will be
   protected under the newly negotiated CipherSpec and keys.  Reception
   of this message causes the receiver to instruct the record layer to
   immediately copy the read pending state into the read current state.
   Immediately after sending this message, the sender MUST instruct the
   record layer to make the write pending state the write active state.

Dierks & Rescorla           Standards Track                    [Page 27]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   (See [Section 6.1](#section-6.1).)  The ChangeCipherSpec message is sent during the
   handshake after the security parameters have been agreed upon, but
   before the verifying Finished message is sent.

   Note: If a rehandshake occurs while data is flowing on a connection,
   the communicating parties may continue to send data using the old
   CipherSpec.  However, once the ChangeCipherSpec has been sent, the
   new CipherSpec MUST be used.  The first side to send the
   ChangeCipherSpec does not know that the other side has finished
   computing the new keying material (e.g., if it has to perform a
   time-consuming public key operation).  Thus, a small window of time,
   during which the recipient must buffer the data, MAY exist.  In
   practice, with modern machines this interval is likely to be fairly
   short.

[7.2](#section-7.2).  Alert Protocol

   One of the content types supported by the TLS record layer is the
   alert type.  Alert messages convey the severity of the message
   (warning or fatal) and a description of the alert.  Alert messages
   with a level of fatal result in the immediate termination of the
   connection.  In this case, other connections corresponding to the
   session may continue, but the session identifier MUST be invalidated,
   preventing the failed session from being used to establish new
   connections.  Like other messages, alert messages are encrypted and
   compressed, as specified by the current connection state.

      enum { warning(1), fatal(2), (255) } AlertLevel;

      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          decryption_failed_RESERVED(21),
          record_overflow(22),
          decompression_failure(30),
          handshake_failure(40),
          no_certificate_RESERVED(41),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),

Dierks & Rescorla           Standards Track                    [Page 28]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

          export_restriction_RESERVED(60),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          user_canceled(90),
          no_renegotiation(100),
          unsupported_extension(110),
          (255)
      } AlertDescription;

      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;

[7.2.1](#section-7.2.1).  Closure Alerts

   The client and the server must share knowledge that the connection is
   ending in order to avoid a truncation attack.  Either party may
   initiate the exchange of closing messages.

   close_notify
      This message notifies the recipient that the sender will not send
      any more messages on this connection.  Note that as of TLS 1.1,
      failure to properly close a connection no longer requires that a
      session not be resumed.  This is a change from TLS 1.0 to conform
      with widespread implementation practice.

   Either party may initiate a close by sending a close_notify alert.
   Any data received after a closure alert is ignored.

   Unless some other fatal alert has been transmitted, each party is
   required to send a close_notify alert before closing the write side
   of the connection.  The other party MUST respond with a close_notify
   alert of its own and close down the connection immediately,
   discarding any pending writes.  It is not required for the initiator
   of the close to wait for the responding close_notify alert before
   closing the read side of the connection.

   If the application protocol using TLS provides that any data may be
   carried over the underlying transport after the TLS connection is
   closed, the TLS implementation must receive the responding
   close_notify alert before indicating to the application layer that
   the TLS connection has ended.  If the application protocol will not
   transfer any additional data, but will only close the underlying
   transport connection, then the implementation MAY choose to close the
   transport without waiting for the responding close_notify.  No part

Dierks & Rescorla           Standards Track                    [Page 29]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   of this standard should be taken to dictate the manner in which a
   usage profile for TLS manages its data transport, including when
   connections are opened or closed.

   Note: It is assumed that closing a connection reliably delivers
   pending data before destroying the transport.

[7.2.2](#section-7.2.2).  Error Alerts

   Error handling in the TLS Handshake protocol is very simple.  When an
   error is detected, the detecting party sends a message to the other
   party.  Upon transmission or receipt of a fatal alert message, both
   parties immediately close the connection.  Servers and clients MUST
   forget any session-identifiers, keys, and secrets associated with a
   failed connection.  Thus, any connection terminated with a fatal
   alert MUST NOT be resumed.

   Whenever an implementation encounters a condition which is defined as
   a fatal alert, it MUST send the appropriate alert prior to closing
   the connection.  For all errors where an alert level is not
   explicitly specified, the sending party MAY determine at its
   discretion whether to treat this as a fatal error or not.  If the
   implementation chooses to send an alert but intends to close the
   connection immediately afterwards, it MUST send that alert at the
   fatal alert level.

   If an alert with a level of warning is sent and received, generally
   the connection can continue normally.  If the receiving party decides
   not to proceed with the connection (e.g., after having received a
   no_renegotiation alert that it is not willing to accept), it SHOULD
   send a fatal alert to terminate the connection.  Given this, the
   sending party cannot, in general, know how the receiving party will
   behave.  Therefore, warning alerts are not very useful when the
   sending party wants to continue the connection, and thus are
   sometimes omitted.  For example, if a peer decides to accept an
   expired certificate (perhaps after confirming this with the user) and
   wants to continue the connection, it would not generally send a
   certificate_expired alert.

   The following error alerts are defined:

   unexpected_message
      An inappropriate message was received.  This alert is always fatal
      and should never be observed in communication between proper
      implementations.

Dierks & Rescorla           Standards Track                    [Page 30]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   bad_record_mac
      This alert is returned if a record is received with an incorrect
      MAC.  This alert also MUST be returned if an alert is sent because
      a TLSCiphertext decrypted in an invalid way: either it wasn't an
      even multiple of the block length, or its padding values, when
      checked, weren't correct.  This message is always fatal and should
      never be observed in communication between proper implementations
      (except when messages were corrupted in the network).

   decryption_failed_RESERVED
      This alert was used in some earlier versions of TLS, and may have
      permitted certain attacks against the CBC mode [[CBCATT](#ref-CBCATT)].  It MUST
      NOT be sent by compliant implementations.

   record_overflow
      A TLSCiphertext record was received that had a length more than
      2^14+2048 bytes, or a record decrypted to a TLSCompressed record
      with more than 2^14+1024 bytes.  This message is always fatal and
      should never be observed in communication between proper
      implementations (except when messages were corrupted in the
      network).

   decompression_failure
      The decompression function received improper input (e.g., data
      that would expand to excessive length).  This message is always
      fatal and should never be observed in communication between proper
      implementations.

   handshake_failure
      Reception of a handshake_failure alert message indicates that the
      sender was unable to negotiate an acceptable set of security
      parameters given the options available.  This is a fatal error.

   no_certificate_RESERVED
      This alert was used in SSLv3 but not any version of TLS.  It MUST
      NOT be sent by compliant implementations.

   bad_certificate
      A certificate was corrupt, contained signatures that did not
      verify correctly, etc.

   unsupported_certificate
      A certificate was of an unsupported type.

   certificate_revoked
      A certificate was revoked by its signer.

Dierks & Rescorla           Standards Track                    [Page 31]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   certificate_expired
      A certificate has expired or is not currently valid.

   certificate_unknown
      Some other (unspecified) issue arose in processing the
      certificate, rendering it unacceptable.

   illegal_parameter
      A field in the handshake was out of range or inconsistent with
      other fields.  This message is always fatal.

   unknown_ca
      A valid certificate chain or partial chain was received, but the
      certificate was not accepted because the CA certificate could not
      be located or couldn't be matched with a known, trusted CA.  This
      message is always fatal.

   access_denied
      A valid certificate was received, but when access control was
      applied, the sender decided not to proceed with negotiation.  This
      message is always fatal.

   decode_error
      A message could not be decoded because some field was out of the
      specified range or the length of the message was incorrect.  This
      message is always fatal and should never be observed in
      communication between proper implementations (except when messages
      were corrupted in the network).

   decrypt_error
      A handshake cryptographic operation failed, including being unable
      to correctly verify a signature or validate a Finished message.
      This message is always fatal.

   export_restriction_RESERVED
      This alert was used in some earlier versions of TLS.  It MUST NOT
      be sent by compliant implementations.

   protocol_version
      The protocol version the client has attempted to negotiate is
      recognized but not supported.  (For example, old protocol versions
      might be avoided for security reasons.)  This message is always
      fatal.

Dierks & Rescorla           Standards Track                    [Page 32]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   insufficient_security
      Returned instead of handshake_failure when a negotiation has
      failed specifically because the server requires ciphers more
      secure than those supported by the client.  This message is always
      fatal.

   internal_error
      An internal error unrelated to the peer or the correctness of the
      protocol (such as a memory allocation failure) makes it impossible
      to continue.  This message is always fatal.

   user_canceled
      This handshake is being canceled for some reason unrelated to a
      protocol failure.  If the user cancels an operation after the
      handshake is complete, just closing the connection by sending a
      close_notify is more appropriate.  This alert should be followed
      by a close_notify.  This message is generally a warning.

   no_renegotiation
      Sent by the client in response to a hello request or by the server
      in response to a client hello after initial handshaking.  Either
      of these would normally lead to renegotiation; when that is not
      appropriate, the recipient should respond with this alert.  At
      that point, the original requester can decide whether to proceed
      with the connection.  One case where this would be appropriate is
      where a server has spawned a process to satisfy a request; the
      process might receive security parameters (key length,
      authentication, etc.) at startup, and it might be difficult to
      communicate changes to these parameters after that point.  This
      message is always a warning.

   unsupported_extension
      sent by clients that receive an extended server hello containing
      an extension that they did not put in the corresponding client
      hello.  This message is always fatal.

   New Alert values are assigned by IANA as described in [Section 12](#section-12).

[7.3](#section-7.3).  Handshake Protocol Overview

   The cryptographic parameters of the session state are produced by the
   TLS Handshake Protocol, which operates on top of the TLS record
   layer.  When a TLS client and server first start communicating, they
   agree on a protocol version, select cryptographic algorithms,
   optionally authenticate each other, and use public-key encryption
   techniques to generate shared secrets.

Dierks & Rescorla           Standards Track                    [Page 33]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   The TLS Handshake Protocol involves the following steps:

   -  Exchange hello messages to agree on algorithms, exchange random
      values, and check for session resumption.

   -  Exchange the necessary cryptographic parameters to allow the
      client and server to agree on a premaster secret.

   -  Exchange certificates and cryptographic information to allow the
      client and server to authenticate themselves.

   -  Generate a master secret from the premaster secret and exchanged
      random values.

   -  Provide security parameters to the record layer.

   -  Allow the client and server to verify that their peer has
      calculated the same security parameters and that the handshake
      occurred without tampering by an attacker.

   Note that higher layers should not be overly reliant on whether TLS
   always negotiates the strongest possible connection between two
   peers.  There are a number of ways in which a man-in-the-middle
   attacker can attempt to make two entities drop down to the least
   secure method they support.  The protocol has been designed to
   minimize this risk, but there are still attacks available: for
   example, an attacker could block access to the port a secure service
   runs on, or attempt to get the peers to negotiate an unauthenticated
   connection.  The fundamental rule is that higher levels must be
   cognizant of what their security requirements are and never transmit
   information over a channel less secure than what they require.  The
   TLS protocol is secure in that any cipher suite offers its promised
   level of security: if you negotiate 3DES with a 1024-bit RSA key
   exchange with a host whose certificate you have verified, you can
   expect to be that secure.

   These goals are achieved by the handshake protocol, which can be
   summarized as follows: The client sends a ClientHello message to
   which the server must respond with a ServerHello message, or else a
   fatal error will occur and the connection will fail.  The ClientHello
   and ServerHello are used to establish security enhancement
   capabilities between client and server.  The ClientHello and
   ServerHello establish the following attributes: Protocol Version,
   Session ID, Cipher Suite, and Compression Method.  Additionally, two
   random values are generated and exchanged: ClientHello.random and
   ServerHello.random.

Dierks & Rescorla           Standards Track                    [Page 34]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   The actual key exchange uses up to four messages: the server
   Certificate, the ServerKeyExchange, the client Certificate, and the
   ClientKeyExchange.  New key exchange methods can be created by
   specifying a format for these messages and by defining the use of the
   messages to allow the client and server to agree upon a shared
   secret.  This secret MUST be quite long; currently defined key
   exchange methods exchange secrets that range from 46 bytes upwards.

   Following the hello messages, the server will send its certificate in
   a Certificate message if it is to be authenticated.  Additionally, a
   ServerKeyExchange message may be sent, if it is required (e.g., if
   the server has no certificate, or if its certificate is for signing
   only).  If the server is authenticated, it may request a certificate
   from the client, if that is appropriate to the cipher suite selected.
   Next, the server will send the ServerHelloDone message, indicating
   that the hello-message phase of the handshake is complete.  The
   server will then wait for a client response.  If the server has sent
   a CertificateRequest message, the client MUST send the Certificate
   message.  The ClientKeyExchange message is now sent, and the content
   of that message will depend on the public key algorithm selected
   between the ClientHello and the ServerHello.  If the client has sent
   a certificate with signing ability, a digitally-signed
   CertificateVerify message is sent to explicitly verify possession of
   the private key in the certificate.

   At this point, a ChangeCipherSpec message is sent by the client, and
   the client copies the pending Cipher Spec into the current Cipher
   Spec.  The client then immediately sends the Finished message under
   the new algorithms, keys, and secrets.  In response, the server will
   send its own ChangeCipherSpec message, transfer the pending to the
   current Cipher Spec, and send its Finished message under the new
   Cipher Spec.  At this point, the handshake is complete, and the
   client and server may begin to exchange application layer data.  (See
   flow chart below.)  Application data MUST NOT be sent prior to the
   completion of the first handshake (before a cipher suite other than
   TLS_NULL_WITH_NULL_NULL is established).

Dierks & Rescorla           Standards Track                    [Page 35]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      Client                                               Server

      ClientHello                  -------->
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   <--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     -------->
                                               [ChangeCipherSpec]
                                   <--------             Finished
      Application Data             <------->     Application Data

             Figure 1.  Message flow for a full handshake

   * Indicates optional or situation-dependent messages that are not
   always sent.

   Note: To help avoid pipeline stalls, ChangeCipherSpec is an
   independent TLS protocol content type, and is not actually a TLS
   handshake message.

   When the client and server decide to resume a previous session or
   duplicate an existing session (instead of negotiating new security
   parameters), the message flow is as follows:

   The client sends a ClientHello using the Session ID of the session to
   be resumed.  The server then checks its session cache for a match.
   If a match is found, and the server is willing to re-establish the
   connection under the specified session state, it will send a
   ServerHello with the same Session ID value.  At this point, both
   client and server MUST send ChangeCipherSpec messages and proceed
   directly to Finished messages.  Once the re-establishment is
   complete, the client and server MAY begin to exchange application
   layer data.  (See flow chart below.)  If a Session ID match is not
   found, the server generates a new session ID, and the TLS client and
   server perform a full handshake.

Dierks & Rescorla           Standards Track                    [Page 36]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      Client                                                Server

      ClientHello                   -------->
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    <--------             Finished
      [ChangeCipherSpec]
      Finished                      -------->
      Application Data              <------->     Application Data

          Figure 2.  Message flow for an abbreviated handshake

   The contents and significance of each message will be presented in
   detail in the following sections.

[7.4](#section-7.4).  Handshake Protocol

   The TLS Handshake Protocol is one of the defined higher-level clients
   of the TLS Record Protocol.  This protocol is used to negotiate the
   secure attributes of a session.  Handshake messages are supplied to
   the TLS record layer, where they are encapsulated within one or more
   TLSPlaintext structures, which are processed and transmitted as
   specified by the current active session state.

      enum {
          hello_request(0), client_hello(1), server_hello(2),
          certificate(11), server_key_exchange (12),
          certificate_request(13), server_hello_done(14),
          certificate_verify(15), client_key_exchange(16),
          finished(20), (255)
      } HandshakeType;

      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (HandshakeType) {
              case hello_request:       HelloRequest;
              case client_hello:        ClientHello;
              case server_hello:        ServerHello;
              case certificate:         Certificate;
              case server_key_exchange: ServerKeyExchange;
              case certificate_request: CertificateRequest;
              case server_hello_done:   ServerHelloDone;
              case certificate_verify:  CertificateVerify;
              case client_key_exchange: ClientKeyExchange;
              case finished:            Finished;
          } body;
      } Handshake;

Dierks & Rescorla           Standards Track                    [Page 37]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   The handshake protocol messages are presented below in the order they
   MUST be sent; sending handshake messages in an unexpected order
   results in a fatal error.  Unneeded handshake messages can be
   omitted, however.  Note one exception to the ordering: the
   Certificate message is used twice in the handshake (from server to
   client, then from client to server), but described only in its first
   position.  The one message that is not bound by these ordering rules
   is the HelloRequest message, which can be sent at any time, but which
   SHOULD be ignored by the client if it arrives in the middle of a
   handshake.

   New handshake message types are assigned by IANA as described in
   [Section 12](#section-12).

[7.4.1](#section-7.4.1).  Hello Messages

   The hello phase messages are used to exchange security enhancement
   capabilities between the client and server.  When a new session
   begins, the record layer's connection state encryption, hash, and
   compression algorithms are initialized to null.  The current
   connection state is used for renegotiation messages.

[7.4.1.1](#section-7.4.1.1).  Hello Request

   When this message will be sent:

      The HelloRequest message MAY be sent by the server at any time.

   Meaning of this message:

      HelloRequest is a simple notification that the client should begin
      the negotiation process anew.  In response, the client should send
      a ClientHello message when convenient.  This message is not
      intended to establish which side is the client or server but
      merely to initiate a new negotiation.  Servers SHOULD NOT send a
      HelloRequest immediately upon the client's initial connection.  It
      is the client's job to send a ClientHello at that time.

      This message will be ignored by the client if the client is
      currently negotiating a session.  This message MAY be ignored by
      the client if it does not wish to renegotiate a session, or the
      client may, if it wishes, respond with a no_renegotiation alert.
      Since handshake messages are intended to have transmission
      precedence over application data, it is expected that the
      negotiation will begin before no more than a few records are
      received from the client.  If the server sends a HelloRequest but
      does not receive a ClientHello in response, it may close the
      connection with a fatal alert.

Dierks & Rescorla           Standards Track                    [Page 38]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      After sending a HelloRequest, servers SHOULD NOT repeat the
      request until the subsequent handshake negotiation is complete.

   Structure of this message:

      struct { } HelloRequest;

   This message MUST NOT be included in the message hashes that are
   maintained throughout the handshake and used in the Finished messages
   and the certificate verify message.

[7.4.1.2](#section-7.4.1.2).  Client Hello

   When this message will be sent:

      When a client first connects to a server, it is required to send
      the ClientHello as its first message.  The client can also send a
      ClientHello in response to a HelloRequest or on its own initiative
      in order to renegotiate the security parameters in an existing
      connection.

   Structure of this message:

      The ClientHello message includes a random structure, which is used
      later in the protocol.

         struct {
             uint32 gmt_unix_time;
             opaque random_bytes[28];
         } Random;

      gmt_unix_time
         The current time and date in standard UNIX 32-bit format
         (seconds since the midnight starting Jan 1, 1970, UTC, ignoring
         leap seconds) according to the sender's internal clock.  Clocks
         are not required to be set correctly by the basic TLS protocol;
         higher-level or application protocols may define additional
         requirements.  Note that, for historical reasons, the data
         element is named using GMT, the predecessor of the current
         worldwide time base, UTC.

      random_bytes
         28 bytes generated by a secure random number generator.

   The ClientHello message includes a variable-length session
   identifier.  If not empty, the value identifies a session between the
   same client and server whose security parameters the client wishes to
   reuse.  The session identifier MAY be from an earlier connection,

Dierks & Rescorla           Standards Track                    [Page 39]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   this connection, or from another currently active connection.  The
   second option is useful if the client only wishes to update the
   random structures and derived values of a connection, and the third
   option makes it possible to establish several independent secure
   connections without repeating the full handshake protocol.  These
   independent connections may occur sequentially or simultaneously; a
   SessionID becomes valid when the handshake negotiating it completes
   with the exchange of Finished messages and persists until it is
   removed due to aging or because a fatal error was encountered on a
   connection associated with the session.  The actual contents of the
   SessionID are defined by the server.

      opaque SessionID<0..32>;

   Warning: Because the SessionID is transmitted without encryption or
   immediate MAC protection, servers MUST NOT place confidential
   information in session identifiers or let the contents of fake
   session identifiers cause any breach of security.  (Note that the
   content of the handshake as a whole, including the SessionID, is
   protected by the Finished messages exchanged at the end of the
   handshake.)

   The cipher suite list, passed from the client to the server in the
   ClientHello message, contains the combinations of cryptographic
   algorithms supported by the client in order of the client's
   preference (favorite choice first).  Each cipher suite defines a key
   exchange algorithm, a bulk encryption algorithm (including secret key
   length), a MAC algorithm, and a PRF.  The server will select a cipher
   suite or, if no acceptable choices are presented, return a handshake
   failure alert and close the connection.  If the list contains cipher
   suites the server does not recognize, support, or wish to use, the
   server MUST ignore those cipher suites, and process the remaining
   ones as usual.

      uint8 CipherSuite[2];    /* Cryptographic suite selector */

   The ClientHello includes a list of compression algorithms supported
   by the client, ordered according to the client's preference.

      enum { null(0), (255) } CompressionMethod;

Dierks & Rescorla           Standards Track                    [Page 40]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      struct {
          ProtocolVersion client_version;
          Random random;
          SessionID session_id;
          CipherSuite cipher_suites<2..2^16-2>;
          CompressionMethod compression_methods<1..2^8-1>;
          select (extensions_present) {
              case false:
                  struct {};
              case true:
                  Extension extensions<0..2^16-1>;
          };
      } ClientHello;

   TLS allows extensions to follow the compression_methods field in an
   extensions block.  The presence of extensions can be detected by
   determining whether there are bytes following the compression_methods
   at the end of the ClientHello.  Note that this method of detecting
   optional data differs from the normal TLS method of having a
   variable-length field, but it is used for compatibility with TLS
   before extensions were defined.

   client_version
      The version of the TLS protocol by which the client wishes to
      communicate during this session.  This SHOULD be the latest
      (highest valued) version supported by the client.  For this
      version of the specification, the version will be 3.3 (see
      [Appendix E](#appendix-E) for details about backward compatibility).

   random
      A client-generated random structure.

   session_id
      The ID of a session the client wishes to use for this connection.
      This field is empty if no session_id is available, or if the
      client wishes to generate new security parameters.

   cipher_suites
      This is a list of the cryptographic options supported by the
      client, with the client's first preference first.  If the
      session_id field is not empty (implying a session resumption
      request), this vector MUST include at least the cipher_suite from
      that session.  Values are defined in [Appendix A.5](#appendix-A.5).

   compression_methods
      This is a list of the compression methods supported by the client,
      sorted by client preference.  If the session_id field is not empty
      (implying a session resumption request), it MUST include the

Dierks & Rescorla           Standards Track                    [Page 41]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      compression_method from that session.  This vector MUST contain,
      and all implementations MUST support, CompressionMethod.null.
      Thus, a client and server will always be able to agree on a
      compression method.

   extensions
      Clients MAY request extended functionality from servers by sending
      data in the extensions field.  The actual "Extension" format is
      defined in [Section 7.4.1.4](#section-7.4.1.4).

   In the event that a client requests additional functionality using
   extensions, and this functionality is not supplied by the server, the
   client MAY abort the handshake.  A server MUST accept ClientHello
   messages both with and without the extensions field, and (as for all
   other messages) it MUST check that the amount of data in the message
   precisely matches one of these formats; if not, then it MUST send a
   fatal "decode_error" alert.

   After sending the ClientHello message, the client waits for a
   ServerHello message.  Any handshake message returned by the server,
   except for a HelloRequest, is treated as a fatal error.

[7.4.1.3](#section-7.4.1.3).  Server Hello

   When this message will be sent:

      The server will send this message in response to a ClientHello
      message when it was able to find an acceptable set of algorithms.
      If it cannot find such a match, it will respond with a handshake
      failure alert.

   Structure of this message:

      struct {
          ProtocolVersion server_version;
          Random random;
          SessionID session_id;
          CipherSuite cipher_suite;
          CompressionMethod compression_method;
          select (extensions_present) {
              case false:
                  struct {};
              case true:
                  Extension extensions<0..2^16-1>;
          };
      } ServerHello;

Dierks & Rescorla           Standards Track                    [Page 42]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   The presence of extensions can be detected by determining whether
   there are bytes following the compression_method field at the end of
   the ServerHello.

   server_version
      This field will contain the lower of that suggested by the client
      in the client hello and the highest supported by the server.  For
      this version of the specification, the version is 3.3.  (See
      [Appendix E](#appendix-E) for details about backward compatibility.)

   random
      This structure is generated by the server and MUST be
      independently generated from the ClientHello.random.

   session_id
      This is the identity of the session corresponding to this
      connection.  If the ClientHello.session_id was non-empty, the
      server will look in its session cache for a match.  If a match is
      found and the server is willing to establish the new connection
      using the specified session state, the server will respond with
      the same value as was supplied by the client.  This indicates a
      resumed session and dictates that the parties must proceed
      directly to the Finished messages.  Otherwise, this field will
      contain a different value identifying the new session.  The server
      may return an empty session_id to indicate that the session will
      not be cached and therefore cannot be resumed.  If a session is
      resumed, it must be resumed using the same cipher suite it was
      originally negotiated with.  Note that there is no requirement
      that the server resume any session even if it had formerly
      provided a session_id.  Clients MUST be prepared to do a full
      negotiation -- including negotiating new cipher suites -- during
      any handshake.

   cipher_suite
      The single cipher suite selected by the server from the list in
      ClientHello.cipher_suites.  For resumed sessions, this field is
      the value from the state of the session being resumed.

   compression_method
      The single compression algorithm selected by the server from the
      list in ClientHello.compression_methods.  For resumed sessions,
      this field is the value from the resumed session state.

   extensions
      A list of extensions.  Note that only extensions offered by the
      client can appear in the server's list.

Dierks & Rescorla           Standards Track                    [Page 43]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[7.4.1.4](#section-7.4.1.4).  Hello Extensions

   The extension format is:

      struct {
          ExtensionType extension_type;
          opaque extension_data<0..2^16-1>;
      } Extension;

      enum {
          signature_algorithms(13), (65535)
      } ExtensionType;

   Here:

   -  "extension_type" identifies the particular extension type.

   -  "extension_data" contains information specific to the particular
      extension type.

   The initial set of extensions is defined in a companion document
   [[TLSEXT](#ref-TLSEXT)].  The list of extension types is maintained by IANA as
   described in [Section 12](#section-12).

   An extension type MUST NOT appear in the ServerHello unless the same
   extension type appeared in the corresponding ClientHello.  If a
   client receives an extension type in ServerHello that it did not
   request in the associated ClientHello, it MUST abort the handshake
   with an unsupported_extension fatal alert.

   Nonetheless, "server-oriented" extensions may be provided in the
   future within this framework.  Such an extension (say, of type x)
   would require the client to first send an extension of type x in a
   ClientHello with empty extension_data to indicate that it supports
   the extension type.  In this case, the client is offering the
   capability to understand the extension type, and the server is taking
   the client up on its offer.

   When multiple extensions of different types are present in the
   ClientHello or ServerHello messages, the extensions MAY appear in any
   order.  There MUST NOT be more than one extension of the same type.

   Finally, note that extensions can be sent both when starting a new
   session and when requesting session resumption.  Indeed, a client
   that requests session resumption does not in general know whether the
   server will accept this request, and therefore it SHOULD send the
   same extensions as it would send if it were not attempting
   resumption.

Dierks & Rescorla           Standards Track                    [Page 44]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   In general, the specification of each extension type needs to
   describe the effect of the extension both during full handshake and
   session resumption.  Most current TLS extensions are relevant only
   when a session is initiated: when an older session is resumed, the
   server does not process these extensions in Client Hello, and does
   not include them in Server Hello.  However, some extensions may
   specify different behavior during session resumption.

   There are subtle (and not so subtle) interactions that may occur in
   this protocol between new features and existing features which may
   result in a significant reduction in overall security.  The following
   considerations should be taken into account when designing new
   extensions:

   -  Some cases where a server does not agree to an extension are error
      conditions, and some are simply refusals to support particular
      features.  In general, error alerts should be used for the former,
      and a field in the server extension response for the latter.

   -  Extensions should, as far as possible, be designed to prevent any
      attack that forces use (or non-use) of a particular feature by
      manipulation of handshake messages.  This principle should be
      followed regardless of whether the feature is believed to cause a
      security problem.

      Often the fact that the extension fields are included in the
      inputs to the Finished message hashes will be sufficient, but
      extreme care is needed when the extension changes the meaning of
      messages sent in the handshake phase.  Designers and implementors
      should be aware of the fact that until the handshake has been
      authenticated, active attackers can modify messages and insert,
      remove, or replace extensions.

   -  It would be technically possible to use extensions to change major
      aspects of the design of TLS; for example the design of cipher
      suite negotiation.  This is not recommended; it would be more
      appropriate to define a new version of TLS -- particularly since
      the TLS handshake algorithms have specific protection against
      version rollback attacks based on the version number, and the
      possibility of version rollback should be a significant
      consideration in any major design change.

[7.4.1.4.1](#section-7.4.1.4.1).  Signature Algorithms

   The client uses the "signature_algorithms" extension to indicate to
   the server which signature/hash algorithm pairs may be used in
   digital signatures.  The "extension_data" field of this extension
   contains a "supported_signature_algorithms" value.

Dierks & Rescorla           Standards Track                    [Page 45]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      enum {
          none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
          sha512(6), (255)
      } HashAlgorithm;

      enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }
        SignatureAlgorithm;

      struct {
            HashAlgorithm hash;
            SignatureAlgorithm signature;
      } SignatureAndHashAlgorithm;

      SignatureAndHashAlgorithm
        supported_signature_algorithms<2..2^16-2>;

   Each SignatureAndHashAlgorithm value lists a single hash/signature
   pair that the client is willing to verify.  The values are indicated
   in descending order of preference.

   Note: Because not all signature algorithms and hash algorithms may be
   accepted by an implementation (e.g., DSA with SHA-1, but not
   SHA-256), algorithms here are listed in pairs.

   hash
      This field indicates the hash algorithm which may be used.  The
      values indicate support for unhashed data, MD5 [[MD5](#ref-MD5)], SHA-1,
      SHA-224, SHA-256, SHA-384, and SHA-512 [[SHS](#ref-SHS)], respectively.  The
      "none" value is provided for future extensibility, in case of a
      signature algorithm which does not require hashing before signing.

   signature
      This field indicates the signature algorithm that may be used.
      The values indicate anonymous signatures, RSASSA-PKCS1-v1_5
      [[PKCS1](#ref-PKCS1)] and DSA [[DSS](#ref-DSS)], and ECDSA [[ECDSA](#ref-ECDSA)], respectively.  The
      "anonymous" value is meaningless in this context but used in
      [Section 7.4.3](#section-7.4.3).  It MUST NOT appear in this extension.

   The semantics of this extension are somewhat complicated because the
   cipher suite indicates permissible signature algorithms but not hash
   algorithms.  Sections [7.4.2](#section-7.4.2) and [7.4.3](#section-7.4.3) describe the appropriate rules.

   If the client supports only the default hash and signature algorithms
   (listed in this section), it MAY omit the signature_algorithms
   extension.  If the client does not support the default algorithms, or
   supports other hash and signature algorithms (and it is willing to
   use them for verifying messages sent by the server, i.e., server
   certificates and server key exchange), it MUST send the

Dierks & Rescorla           Standards Track                    [Page 46]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   signature_algorithms extension, listing the algorithms it is willing
   to accept.

   If the client does not send the signature_algorithms extension, the
   server MUST do the following:

   -  If the negotiated key exchange algorithm is one of (RSA, DHE_RSA,
      DH_RSA, RSA_PSK, ECDH_RSA, ECDHE_RSA), behave as if client had
      sent the value {sha1,rsa}.

   -  If the negotiated key exchange algorithm is one of (DHE_DSS,
      DH_DSS), behave as if the client had sent the value {sha1,dsa}.

   -  If the negotiated key exchange algorithm is one of (ECDH_ECDSA,
      ECDHE_ECDSA), behave as if the client had sent value {sha1,ecdsa}.

   Note: this is a change from TLS 1.1 where there are no explicit
   rules, but as a practical matter one can assume that the peer
   supports MD5 and SHA-1.

   Note: this extension is not meaningful for TLS versions prior to 1.2.
   Clients MUST NOT offer it if they are offering prior versions.
   However, even if clients do offer it, the rules specified in [[TLSEXT](#ref-TLSEXT)]
   require servers to ignore extensions they do not understand.

   Servers MUST NOT send this extension.  TLS servers MUST support
   receiving this extension.

   When performing session resumption, this extension is not included in
   Server Hello, and the server ignores the extension in Client Hello
   (if present).

[7.4.2](#section-7.4.2).  Server Certificate

   When this message will be sent:

      The server MUST send a Certificate message whenever the agreed-
      upon key exchange method uses certificates for authentication
      (this includes all key exchange methods defined in this document
      except DH_anon).  This message will always immediately follow the
      ServerHello message.

   Meaning of this message:

      This message conveys the server's certificate chain to the client.

      The certificate MUST be appropriate for the negotiated cipher
      suite's key exchange algorithm and any negotiated extensions.

Dierks & Rescorla           Standards Track                    [Page 47]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Structure of this message:

      opaque ASN.1Cert<1..2^24-1>;

      struct {
          ASN.1Cert certificate_list<0..2^24-1>;
      } Certificate;

   certificate_list
      This is a sequence (chain) of certificates.  The sender's
      certificate MUST come first in the list.  Each following
      certificate MUST directly certify the one preceding it.  Because
      certificate validation requires that root keys be distributed
      independently, the self-signed certificate that specifies the root
      certificate authority MAY be omitted from the chain, under the
      assumption that the remote end must already possess it in order to
      validate it in any case.

   The same message type and structure will be used for the client's
   response to a certificate request message.  Note that a client MAY
   send no certificates if it does not have an appropriate certificate
   to send in response to the server's authentication request.

   Note: PKCS #7 [[PKCS7](#ref-PKCS7)] is not used as the format for the certificate
   vector because PKCS #6 [[PKCS6](#ref-PKCS6)] extended certificates are not used.
   Also, PKCS #7 defines a SET rather than a SEQUENCE, making the task
   of parsing the list more difficult.

   The following rules apply to the certificates sent by the server:

   -  The certificate type MUST be X.509v3, unless explicitly negotiated
      otherwise (e.g., [[TLSPGP](#ref-TLSPGP)]).

   -  The end entity certificate's public key (and associated
      restrictions) MUST be compatible with the selected key exchange
      algorithm.

      Key Exchange Alg.  Certificate Key Type

      RSA                RSA public key; the certificate MUST allow the
      RSA_PSK            key to be used for encryption (the
                         keyEncipherment bit MUST be set if the key
                         usage extension is present).
                         Note: RSA_PSK is defined in [[TLSPSK](#ref-TLSPSK)].

Dierks & Rescorla           Standards Track                    [Page 48]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      DHE_RSA            RSA public key; the certificate MUST allow the
      ECDHE_RSA          key to be used for signing (the
                         digitalSignature bit MUST be set if the key
                         usage extension is present) with the signature
                         scheme and hash algorithm that will be employed
                         in the server key exchange message.
                         Note: ECDHE_RSA is defined in [[TLSECC](#ref-TLSECC)].

      DHE_DSS            DSA public key; the certificate MUST allow the
                         key to be used for signing with the hash
                         algorithm that will be employed in the server
                         key exchange message.

      DH_DSS             Diffie-Hellman public key; the keyAgreement bit
      DH_RSA             MUST be set if the key usage extension is
                         present.

      ECDH_ECDSA         ECDH-capable public key; the public key MUST
      ECDH_RSA           use a curve and point format supported by the
                         client, as described in [[TLSECC](#ref-TLSECC)].

      ECDHE_ECDSA        ECDSA-capable public key; the certificate MUST
                         allow the key to be used for signing with the
                         hash algorithm that will be employed in the
                         server key exchange message.  The public key
                         MUST use a curve and point format supported by
                         the client, as described in  [[TLSECC](#ref-TLSECC)].

   -  The "server_name" and "trusted_ca_keys" extensions [[TLSEXT](#ref-TLSEXT)] are
      used to guide certificate selection.

   If the client provided a "signature_algorithms" extension, then all
   certificates provided by the server MUST be signed by a
   hash/signature algorithm pair that appears in that extension.  Note
   that this implies that a certificate containing a key for one
   signature algorithm MAY be signed using a different signature
   algorithm (for instance, an RSA key signed with a DSA key).  This is
   a departure from TLS 1.1, which required that the algorithms be the
   same.  Note that this also implies that the DH_DSS, DH_RSA,
   ECDH_ECDSA, and ECDH_RSA key exchange algorithms do not restrict the
   algorithm used to sign the certificate.  Fixed DH certificates MAY be
   signed with any hash/signature algorithm pair appearing in the
   extension.  The names DH_DSS, DH_RSA, ECDH_ECDSA, and ECDH_RSA are
   historical.

Dierks & Rescorla           Standards Track                    [Page 49]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   If the server has multiple certificates, it chooses one of them based
   on the above-mentioned criteria (in addition to other criteria, such
   as transport layer endpoint, local configuration and preferences,
   etc.).  If the server has a single certificate, it SHOULD attempt to
   validate that it meets these criteria.

   Note that there are certificates that use algorithms and/or algorithm
   combinations that cannot be currently used with TLS.  For example, a
   certificate with RSASSA-PSS signature key (id-RSASSA-PSS OID in
   SubjectPublicKeyInfo) cannot be used because TLS defines no
   corresponding signature algorithm.

   As cipher suites that specify new key exchange methods are specified
   for the TLS protocol, they will imply the certificate format and the
   required encoded keying information.

[7.4.3](#section-7.4.3).  Server Key Exchange Message

   When this message will be sent:

      This message will be sent immediately after the server Certificate
      message (or the ServerHello message, if this is an anonymous
      negotiation).

      The ServerKeyExchange message is sent by the server only when the
      server Certificate message (if sent) does not contain enough data
      to allow the client to exchange a premaster secret.  This is true
      for the following key exchange methods:

         DHE_DSS
         DHE_RSA
         DH_anon

      It is not legal to send the ServerKeyExchange message for the
      following key exchange methods:

         RSA
         DH_DSS
         DH_RSA

      Other key exchange algorithms, such as those defined in [[TLSECC](#ref-TLSECC)],
      MUST specify whether the ServerKeyExchange message is sent or not;
      and if the message is sent, its contents.

Dierks & Rescorla           Standards Track                    [Page 50]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Meaning of this message:

      This message conveys cryptographic information to allow the client
      to communicate the premaster secret: a Diffie-Hellman public key
      with which the client can complete a key exchange (with the result
      being the premaster secret) or a public key for some other
      algorithm.

   Structure of this message:

      enum { dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa
            /* may be extended, e.g., for ECDH -- see [[TLSECC](#ref-TLSECC)] */
           } KeyExchangeAlgorithm;

      struct {
          opaque dh_p<1..2^16-1>;
          opaque dh_g<1..2^16-1>;
          opaque dh_Ys<1..2^16-1>;
      } ServerDHParams;     /* Ephemeral DH parameters */

      dh_p
         The prime modulus used for the Diffie-Hellman operation.

      dh_g
         The generator used for the Diffie-Hellman operation.

      dh_Ys
         The server's Diffie-Hellman public value (g^X mod p).

Dierks & Rescorla           Standards Track                    [Page 51]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      struct {
          select (KeyExchangeAlgorithm) {
              case dh_anon:
                  ServerDHParams params;
              case dhe_dss:
              case dhe_rsa:
                  ServerDHParams params;
                  digitally-signed struct {
                      opaque client_random[32];
                      opaque server_random[32];
                      ServerDHParams params;
                  } signed_params;
              case rsa:
              case dh_dss:
              case dh_rsa:
                  struct {} ;
                 /* message is omitted for rsa, dh_dss, and dh_rsa */
              /* may be extended, e.g., for ECDH -- see [[TLSECC](#ref-TLSECC)] */
          };
      } ServerKeyExchange;

      params
         The server's key exchange parameters.

      signed_params
         For non-anonymous key exchanges, a signature over the server's
         key exchange parameters.

   If the client has offered the "signature_algorithms" extension, the
   signature algorithm and hash algorithm MUST be a pair listed in that
   extension.  Note that there is a possibility for inconsistencies
   here.  For instance, the client might offer DHE_DSS key exchange but
   omit any DSA pairs from its "signature_algorithms" extension.  In
   order to negotiate correctly, the server MUST check any candidate
   cipher suites against the "signature_algorithms" extension before
   selecting them.  This is somewhat inelegant but is a compromise
   designed to minimize changes to the original cipher suite design.

   In addition, the hash and signature algorithms MUST be compatible
   with the key in the server's end-entity certificate.  RSA keys MAY be
   used with any permitted hash algorithm, subject to restrictions in
   the certificate, if any.

   Because DSA signatures do not contain any secure indication of hash
   algorithm, there is a risk of hash substitution if multiple hashes
   may be used with any key.  Currently, DSA [[DSS](#ref-DSS)] may only be used with
   SHA-1.  Future revisions of DSS [[DSS-3](#ref-DSS-3)] are expected to allow the use
   of other digest algorithms with DSA, as well as guidance as to which

Dierks & Rescorla           Standards Track                    [Page 52]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   digest algorithms should be used with each key size.  In addition,
   future revisions of [[PKIX](#ref-PKIX)] may specify mechanisms for certificates to
   indicate which digest algorithms are to be used with DSA.

   As additional cipher suites are defined for TLS that include new key
   exchange algorithms, the server key exchange message will be sent if
   and only if the certificate type associated with the key exchange
   algorithm does not provide enough information for the client to
   exchange a premaster secret.

[7.4.4](#section-7.4.4).  Certificate Request

   When this message will be sent:

       A non-anonymous server can optionally request a certificate from
       the client, if appropriate for the selected cipher suite.  This
       message, if sent, will immediately follow the ServerKeyExchange
       message (if it is sent; otherwise, this message follows the
       server's Certificate message).

   Structure of this message:

      enum {
          rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
          rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
          fortezza_dms_RESERVED(20), (255)
      } ClientCertificateType;

      opaque DistinguishedName<1..2^16-1>;

      struct {
          ClientCertificateType certificate_types<1..2^8-1>;
          SignatureAndHashAlgorithm
            supported_signature_algorithms<2^16-1>;
          DistinguishedName certificate_authorities<0..2^16-1>;
      } CertificateRequest;

   certificate_types
      A list of the types of certificate types that the client may
      offer.

         rsa_sign        a certificate containing an RSA key
         dss_sign        a certificate containing a DSA key
         rsa_fixed_dh    a certificate containing a static DH key.
         dss_fixed_dh    a certificate containing a static DH key

Dierks & Rescorla           Standards Track                    [Page 53]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   supported_signature_algorithms
      A list of the hash/signature algorithm pairs that the server is
      able to verify, listed in descending order of preference.

   certificate_authorities
      A list of the distinguished names [[X501](#ref-X501)] of acceptable
      certificate_authorities, represented in DER-encoded format.  These
      distinguished names may specify a desired distinguished name for a
      root CA or for a subordinate CA; thus, this message can be used to
      describe known roots as well as a desired authorization space.  If
      the certificate_authorities list is empty, then the client MAY
      send any certificate of the appropriate ClientCertificateType,
      unless there is some external arrangement to the contrary.

   The interaction of the certificate_types and
   supported_signature_algorithms fields is somewhat complicated.
   certificate_types has been present in TLS since SSLv3, but was
   somewhat underspecified.  Much of its functionality is superseded by
   supported_signature_algorithms.  The following rules apply:

   -  Any certificates provided by the client MUST be signed using a
      hash/signature algorithm pair found in
      supported_signature_algorithms.

   -  The end-entity certificate provided by the client MUST contain a
      key that is compatible with certificate_types.  If the key is a
      signature key, it MUST be usable with some hash/signature
      algorithm pair in supported_signature_algorithms.

   -  For historical reasons, the names of some client certificate types
      include the algorithm used to sign the certificate.  For example,
      in earlier versions of TLS, rsa_fixed_dh meant a certificate
      signed with RSA and containing a static DH key.  In TLS 1.2, this
      functionality has been obsoleted by the
      supported_signature_algorithms, and the certificate type no longer
      restricts the algorithm used to sign the certificate.  For
      example, if the server sends dss_fixed_dh certificate type and
      {{sha1, dsa}, {sha1, rsa}} signature types, the client MAY reply
      with a certificate containing a static DH key, signed with RSA-
      SHA1.

   New ClientCertificateType values are assigned by IANA as described in
   [Section 12](#section-12).

   Note: Values listed as RESERVED may not be used.  They were used in
   SSLv3.

Dierks & Rescorla           Standards Track                    [Page 54]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Note: It is a fatal handshake_failure alert for an anonymous server
   to request client authentication.

[7.4.5](#section-7.4.5).  Server Hello Done

   When this message will be sent:

      The ServerHelloDone message is sent by the server to indicate the
      end of the ServerHello and associated messages.  After sending
      this message, the server will wait for a client response.

   Meaning of this message:

      This message means that the server is done sending messages to
      support the key exchange, and the client can proceed with its
      phase of the key exchange.

      Upon receipt of the ServerHelloDone message, the client SHOULD
      verify that the server provided a valid certificate, if required,
      and check that the server hello parameters are acceptable.

   Structure of this message:

      struct { } ServerHelloDone;

[7.4.6](#section-7.4.6).  Client Certificate

   When this message will be sent:

      This is the first message the client can send after receiving a
      ServerHelloDone message.  This message is only sent if the server
      requests a certificate.  If no suitable certificate is available,
      the client MUST send a certificate message containing no
      certificates.  That is, the certificate_list structure has a
      length of zero.  If the client does not send any certificates, the
      server MAY at its discretion either continue the handshake without
      client authentication, or respond with a fatal handshake_failure
      alert.  Also, if some aspect of the certificate chain was
      unacceptable (e.g., it was not signed by a known, trusted CA), the
      server MAY at its discretion either continue the handshake
      (considering the client unauthenticated) or send a fatal alert.

      Client certificates are sent using the Certificate structure
      defined in [Section 7.4.2](#section-7.4.2).

Dierks & Rescorla           Standards Track                    [Page 55]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Meaning of this message:

      This message conveys the client's certificate chain to the server;
      the server will use it when verifying the CertificateVerify
      message (when the client authentication is based on signing) or
      calculating the premaster secret (for non-ephemeral Diffie-
      Hellman).  The certificate MUST be appropriate for the negotiated
      cipher suite's key exchange algorithm, and any negotiated
      extensions.

   In particular:

   -  The certificate type MUST be X.509v3, unless explicitly negotiated
      otherwise (e.g., [[TLSPGP](#ref-TLSPGP)]).

   -  The end-entity certificate's public key (and associated
      restrictions) has to be compatible with the certificate types
      listed in CertificateRequest:

      Client Cert. Type   Certificate Key Type

      rsa_sign            RSA public key; the certificate MUST allow the
                          key to be used for signing with the signature
                          scheme and hash algorithm that will be
                          employed in the certificate verify message.

      dss_sign            DSA public key; the certificate MUST allow the
                          key to be used for signing with the hash
                          algorithm that will be employed in the
                          certificate verify message.

      ecdsa_sign          ECDSA-capable public key; the certificate MUST
                          allow the key to be used for signing with the
                          hash algorithm that will be employed in the
                          certificate verify message; the public key
                          MUST use a curve and point format supported by
                          the server.

      rsa_fixed_dh        Diffie-Hellman public key; MUST use the same
      dss_fixed_dh        parameters as server's key.

      rsa_fixed_ecdh      ECDH-capable public key; MUST use the
      ecdsa_fixed_ecdh    same curve as the server's key, and MUST use a
                          point format supported by the server.

   -  If the certificate_authorities list in the certificate request
      message was non-empty, one of the certificates in the certificate
      chain SHOULD be issued by one of the listed CAs.

Dierks & Rescorla           Standards Track                    [Page 56]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   -  The certificates MUST be signed using an acceptable hash/
      signature algorithm pair, as described in [Section 7.4.4](#section-7.4.4).  Note
      that this relaxes the constraints on certificate-signing
      algorithms found in prior versions of TLS.

   Note that, as with the server certificate, there are certificates
   that use algorithms/algorithm combinations that cannot be currently
   used with TLS.

[7.4.7](#section-7.4.7).  Client Key Exchange Message

   When this message will be sent:

      This message is always sent by the client.  It MUST immediately
      follow the client certificate message, if it is sent.  Otherwise,
      it MUST be the first message sent by the client after it receives
      the ServerHelloDone message.

   Meaning of this message:

      With this message, the premaster secret is set, either by direct
      transmission of the RSA-encrypted secret or by the transmission of
      Diffie-Hellman parameters that will allow each side to agree upon
      the same premaster secret.

      When the client is using an ephemeral Diffie-Hellman exponent,
      then this message contains the client's Diffie-Hellman public
      value.  If the client is sending a certificate containing a static
      DH exponent (i.e., it is doing fixed_dh client authentication),
      then this message MUST be sent but MUST be empty.

   Structure of this message:

      The choice of messages depends on which key exchange method has
      been selected.  See [Section 7.4.3](#section-7.4.3) for the KeyExchangeAlgorithm
      definition.

Dierks & Rescorla           Standards Track                    [Page 57]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      struct {
          select (KeyExchangeAlgorithm) {
              case rsa:
                  EncryptedPreMasterSecret;
              case dhe_dss:
              case dhe_rsa:
              case dh_dss:
              case dh_rsa:
              case dh_anon:
                  ClientDiffieHellmanPublic;
          } exchange_keys;
      } ClientKeyExchange;

[7.4.7.1](#section-7.4.7.1).  RSA-Encrypted Premaster Secret Message

   Meaning of this message:

      If RSA is being used for key agreement and authentication, the
      client generates a 48-byte premaster secret, encrypts it using the
      public key from the server's certificate, and sends the result in
      an encrypted premaster secret message.  This structure is a
      variant of the ClientKeyExchange message and is not a message in
      itself.

   Structure of this message:

      struct {
          ProtocolVersion client_version;
          opaque random[46];
      } PreMasterSecret;

      client_version
         The latest (newest) version supported by the client.  This is
         used to detect version rollback attacks.

      random
         46 securely-generated random bytes.

      struct {
          public-key-encrypted PreMasterSecret pre_master_secret;
      } EncryptedPreMasterSecret;

      pre_master_secret
         This random value is generated by the client and is used to
         generate the master secret, as specified in [Section 8.1](#section-8.1).

Dierks & Rescorla           Standards Track                    [Page 58]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Note: The version number in the PreMasterSecret is the version
   offered by the client in the ClientHello.client_version, not the
   version negotiated for the connection.  This feature is designed to
   prevent rollback attacks.  Unfortunately, some old implementations
   use the negotiated version instead, and therefore checking the
   version number may lead to failure to interoperate with such
   incorrect client implementations.

   Client implementations MUST always send the correct version number in
   PreMasterSecret.  If ClientHello.client_version is TLS 1.1 or higher,
   server implementations MUST check the version number as described in
   the note below.  If the version number is TLS 1.0 or earlier, server
   implementations SHOULD check the version number, but MAY have a
   configuration option to disable the check.  Note that if the check
   fails, the PreMasterSecret SHOULD be randomized as described below.

   Note: Attacks discovered by Bleichenbacher [[BLEI](#ref-BLEI)] and Klima et al.
   [[KPR03](#ref-KPR03)] can be used to attack a TLS server that reveals whether a
   particular message, when decrypted, is properly PKCS#1 formatted,
   contains a valid PreMasterSecret structure, or has the correct
   version number.

   As described by Klima [[KPR03](#ref-KPR03)], these vulnerabilities can be avoided
   by treating incorrectly formatted message blocks and/or mismatched
   version numbers in a manner indistinguishable from correctly
   formatted RSA blocks.  In other words:

      1. Generate a string R of 46 random bytes

      2. Decrypt the message to recover the plaintext M

      3. If the PKCS#1 padding is not correct, or the length of message
         M is not exactly 48 bytes:
            pre_master_secret = ClientHello.client_version || R
         else If ClientHello.client_version <= TLS 1.0, and version
         number check is explicitly disabled:
            pre_master_secret = M
         else:
            pre_master_secret = ClientHello.client_version || M[2..47]

   Note that explicitly constructing the pre_master_secret with the
   ClientHello.client_version produces an invalid master_secret if the
   client has sent the wrong version in the original pre_master_secret.

   An alternative approach is to treat a version number mismatch as a
   PKCS-1 formatting error and randomize the premaster secret
   completely:

Dierks & Rescorla           Standards Track                    [Page 59]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      1. Generate a string R of 48 random bytes

      2. Decrypt the message to recover the plaintext M

      3. If the PKCS#1 padding is not correct, or the length of message
         M is not exactly 48 bytes:
            pre_master_secret = R
         else If ClientHello.client_version <= TLS 1.0, and version
         number check is explicitly disabled:
            premaster secret = M
         else If M[0..1] != ClientHello.client_version:
            premaster secret = R
         else:
            premaster secret = M

   Although no practical attacks against this construction are known,
   Klima et al. [[KPR03](#ref-KPR03)] describe some theoretical attacks, and therefore
   the first construction described is RECOMMENDED.

   In any case, a TLS server MUST NOT generate an alert if processing an
   RSA-encrypted premaster secret message fails, or the version number
   is not as expected.  Instead, it MUST continue the handshake with a
   randomly generated premaster secret.  It may be useful to log the
   real cause of failure for troubleshooting purposes; however, care
   must be taken to avoid leaking the information to an attacker
   (through, e.g., timing, log files, or other channels.)

   The RSAES-OAEP encryption scheme defined in [[PKCS1](#ref-PKCS1)] is more secure
   against the Bleichenbacher attack.  However, for maximal
   compatibility with earlier versions of TLS, this specification uses
   the RSAES-PKCS1-v1_5 scheme.  No variants of the Bleichenbacher
   attack are known to exist provided that the above recommendations are
   followed.

   Implementation note: Public-key-encrypted data is represented as an
   opaque vector <0..2^16-1> (see [Section 4.7](#section-4.7)).  Thus, the RSA-encrypted
   PreMasterSecret in a ClientKeyExchange is preceded by two length
   bytes.  These bytes are redundant in the case of RSA because the
   EncryptedPreMasterSecret is the only data in the ClientKeyExchange
   and its length can therefore be unambiguously determined.  The SSLv3
   specification was not clear about the encoding of public-key-
   encrypted data, and therefore many SSLv3 implementations do not
   include the length bytes -- they encode the RSA-encrypted data
   directly in the ClientKeyExchange message.

   This specification requires correct encoding of the
   EncryptedPreMasterSecret complete with length bytes.  The resulting
   PDU is incompatible with many SSLv3 implementations.  Implementors

Dierks & Rescorla           Standards Track                    [Page 60]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   upgrading from SSLv3 MUST modify their implementations to generate
   and accept the correct encoding.  Implementors who wish to be
   compatible with both SSLv3 and TLS should make their implementation's
   behavior dependent on the protocol version.

   Implementation note: It is now known that remote timing-based attacks
   on TLS are possible, at least when the client and server are on the
   same LAN.  Accordingly, implementations that use static RSA keys MUST
   use RSA blinding or some other anti-timing technique, as described in
   [[TIMING](#ref-TIMING)].

[7.4.7.2](#section-7.4.7.2).  Client Diffie-Hellman Public Value

   Meaning of this message:

      This structure conveys the client's Diffie-Hellman public value
      (Yc) if it was not already included in the client's certificate.
      The encoding used for Yc is determined by the enumerated
      PublicValueEncoding.  This structure is a variant of the client
      key exchange message, and not a message in itself.

   Structure of this message:

      enum { implicit, explicit } PublicValueEncoding;

      implicit
         If the client has sent a certificate which contains a suitable
         Diffie-Hellman key (for fixed_dh client authentication), then
         Yc is implicit and does not need to be sent again.  In this
         case, the client key exchange message will be sent, but it MUST
         be empty.

      explicit
         Yc needs to be sent.

      struct {
          select (PublicValueEncoding) {
              case implicit: struct { };
              case explicit: opaque dh_Yc<1..2^16-1>;
          } dh_public;
      } ClientDiffieHellmanPublic;

      dh_Yc
         The client's Diffie-Hellman public value (Yc).

Dierks & Rescorla           Standards Track                    [Page 61]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[7.4.8](#section-7.4.8).  Certificate Verify

   When this message will be sent:

      This message is used to provide explicit verification of a client
      certificate.  This message is only sent following a client
      certificate that has signing capability (i.e., all certificates
      except those containing fixed Diffie-Hellman parameters).  When
      sent, it MUST immediately follow the client key exchange message.

   Structure of this message:

      struct {
           digitally-signed struct {
               opaque handshake_messages[handshake_messages_length];
           }
      } CertificateVerify;

      Here handshake_messages refers to all handshake messages sent or
      received, starting at client hello and up to, but not including,
      this message, including the type and length fields of the
      handshake messages.  This is the concatenation of all the
      Handshake structures (as defined in [Section 7.4](#section-7.4)) exchanged thus
      far.  Note that this requires both sides to either buffer the
      messages or compute running hashes for all potential hash
      algorithms up to the time of the CertificateVerify computation.
      Servers can minimize this computation cost by offering a
      restricted set of digest algorithms in the CertificateRequest
      message.

      The hash and signature algorithms used in the signature MUST be
      one of those present in the supported_signature_algorithms field
      of the CertificateRequest message.  In addition, the hash and
      signature algorithms MUST be compatible with the key in the
      client's end-entity certificate.  RSA keys MAY be used with any
      permitted hash algorithm, subject to restrictions in the
      certificate, if any.

      Because DSA signatures do not contain any secure indication of
      hash algorithm, there is a risk of hash substitution if multiple
      hashes may be used with any key.  Currently, DSA [[DSS](#ref-DSS)] may only be
      used with SHA-1.  Future revisions of DSS [[DSS-3](#ref-DSS-3)] are expected to
      allow the use of other digest algorithms with DSA, as well as
      guidance as to which digest algorithms should be used with each
      key size.  In addition, future revisions of [[PKIX](#ref-PKIX)] may specify
      mechanisms for certificates to indicate which digest algorithms
      are to be used with DSA.

Dierks & Rescorla           Standards Track                    [Page 62]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[7.4.9](#section-7.4.9).  Finished

   When this message will be sent:

      A Finished message is always sent immediately after a change
      cipher spec message to verify that the key exchange and
      authentication processes were successful.  It is essential that a
      change cipher spec message be received between the other handshake
      messages and the Finished message.

   Meaning of this message:

      The Finished message is the first one protected with the just
      negotiated algorithms, keys, and secrets.  Recipients of Finished
      messages MUST verify that the contents are correct.  Once a side
      has sent its Finished message and received and validated the
      Finished message from its peer, it may begin to send and receive
      application data over the connection.

   Structure of this message:

      struct {
          opaque verify_data[verify_data_length];
      } Finished;

      verify_data
         PRF(master_secret, finished_label, Hash(handshake_messages))
            [0..verify_data_length-1];

      finished_label
         For Finished messages sent by the client, the string
         "client finished".  For Finished messages sent by the server,
         the string "server finished".

      Hash denotes a Hash of the handshake messages.  For the PRF
      defined in [Section 5](#section-5), the Hash MUST be the Hash used as the basis
      for the PRF.  Any cipher suite which defines a different PRF MUST
      also define the Hash to use in the Finished computation.

      In previous versions of TLS, the verify_data was always 12 octets
      long.  In the current version of TLS, it depends on the cipher
      suite.  Any cipher suite which does not explicitly specify
      verify_data_length has a verify_data_length equal to 12.  This
      includes all existing cipher suites.  Note that this
      representation has the same encoding as with previous versions.
      Future cipher suites MAY specify other lengths but such length
      MUST be at least 12 bytes.

Dierks & Rescorla           Standards Track                    [Page 63]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      handshake_messages
         All of the data from all messages in this handshake (not
         including any HelloRequest messages) up to, but not including,
         this message.  This is only data visible at the handshake layer
         and does not include record layer headers.  This is the
         concatenation of all the Handshake structures as defined in
         [Section 7.4](#section-7.4), exchanged thus far.

   It is a fatal error if a Finished message is not preceded by a
   ChangeCipherSpec message at the appropriate point in the handshake.

   The value handshake_messages includes all handshake messages starting
   at ClientHello up to, but not including, this Finished message.  This
   may be different from handshake_messages in [Section 7.4.8](#section-7.4.8) because it
   would include the CertificateVerify message (if sent).  Also, the
   handshake_messages for the Finished message sent by the client will
   be different from that for the Finished message sent by the server,
   because the one that is sent second will include the prior one.

   Note: ChangeCipherSpec messages, alerts, and any other record types
   are not handshake messages and are not included in the hash
   computations.  Also, HelloRequest messages are omitted from handshake
   hashes.

[8](#section-8).  Cryptographic Computations

   In order to begin connection protection, the TLS Record Protocol
   requires specification of a suite of algorithms, a master secret, and
   the client and server random values.  The authentication, encryption,
   and MAC algorithms are determined by the cipher_suite selected by the
   server and revealed in the ServerHello message.  The compression
   algorithm is negotiated in the hello messages, and the random values
   are exchanged in the hello messages.  All that remains is to
   calculate the master secret.

[8.1](#section-8.1).  Computing the Master Secret

   For all key exchange methods, the same algorithm is used to convert
   the pre_master_secret into the master_secret.  The pre_master_secret
   should be deleted from memory once the master_secret has been
   computed.

      master_secret = PRF(pre_master_secret, "master secret",
                          ClientHello.random + ServerHello.random)
                          [0..47];

   The master secret is always exactly 48 bytes in length.  The length
   of the premaster secret will vary depending on key exchange method.

Dierks & Rescorla           Standards Track                    [Page 64]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[8.1.1](#section-8.1.1).  RSA

   When RSA is used for server authentication and key exchange, a 48-
   byte pre_master_secret is generated by the client, encrypted under
   the server's public key, and sent to the server.  The server uses its
   private key to decrypt the pre_master_secret.  Both parties then
   convert the pre_master_secret into the master_secret, as specified
   above.

[8.1.2](#section-8.1.2).  Diffie-Hellman

   A conventional Diffie-Hellman computation is performed.  The
   negotiated key (Z) is used as the pre_master_secret, and is converted
   into the master_secret, as specified above.  Leading bytes of Z that
   contain all zero bits are stripped before it is used as the
   pre_master_secret.

   Note: Diffie-Hellman parameters are specified by the server and may
   be either ephemeral or contained within the server's certificate.

[9](#section-9).  Mandatory Cipher Suites

   In the absence of an application profile standard specifying
   otherwise, a TLS-compliant application MUST implement the cipher
   suite TLS_RSA_WITH_AES_128_CBC_SHA (see [Appendix A.5](#appendix-A.5) for the
   definition).

[10](#section-10).  Application Data Protocol

   Application data messages are carried by the record layer and are
   fragmented, compressed, and encrypted based on the current connection
   state.  The messages are treated as transparent data to the record
   layer.

[11](#section-11).  Security Considerations

   Security issues are discussed throughout this memo, especially in
   Appendices D, E, and F.

[12](#section-12).  IANA Considerations

   This document uses several registries that were originally created in
   [[TLS1.1](#ref-TLS1.1)].  IANA has updated these to reference this document.  The
   registries and their allocation policies (unchanged from [[TLS1.1](#ref-TLS1.1)])
   are listed below.

Dierks & Rescorla           Standards Track                    [Page 65]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   -  TLS ClientCertificateType Identifiers Registry: Future values in
      the range 0-63 (decimal) inclusive are assigned via Standards
      Action [[RFC2434](/doc/html/rfc2434)].  Values in the range 64-223 (decimal) inclusive
      are assigned via Specification Required [[RFC2434](/doc/html/rfc2434)].  Values from
      224-255 (decimal) inclusive are reserved for Private Use
      [[RFC2434](/doc/html/rfc2434)].

   -  TLS Cipher Suite Registry: Future values with the first byte in
      the range 0-191 (decimal) inclusive are assigned via Standards
      Action [[RFC2434](/doc/html/rfc2434)].  Values with the first byte in the range 192-254
      (decimal) are assigned via Specification Required [[RFC2434](/doc/html/rfc2434)].
      Values with the first byte 255 (decimal) are reserved for Private
      Use [[RFC2434](/doc/html/rfc2434)].

   -  This document defines several new HMAC-SHA256-based cipher suites,
      whose values (in [Appendix A.5](#appendix-A.5)) have been allocated from the TLS
      Cipher Suite registry.

   -  TLS ContentType Registry: Future values are allocated via
      Standards Action [[RFC2434](/doc/html/rfc2434)].

   -  TLS Alert Registry: Future values are allocated via Standards
      Action [[RFC2434](/doc/html/rfc2434)].

   -  TLS HandshakeType Registry: Future values are allocated via
      Standards Action [[RFC2434](/doc/html/rfc2434)].

   This document also uses a registry originally created in [[RFC4366](/doc/html/rfc4366)].
   IANA has updated it to reference this document.  The registry and its
   allocation policy (unchanged from [[RFC4366](/doc/html/rfc4366)]) is listed below:

   -  TLS ExtensionType Registry: Future values are allocated via IETF
      Consensus [[RFC2434](/doc/html/rfc2434)].  IANA has updated this registry to include
      the signature_algorithms extension and its corresponding value
      (see [Section 7.4.1.4](#section-7.4.1.4)).

   In addition, this document defines two new registries to be
   maintained by IANA:

   -  TLS SignatureAlgorithm Registry: The registry has been initially
      populated with the values described in [Section 7.4.1.4.1](#section-7.4.1.4.1).  Future
      values in the range 0-63 (decimal) inclusive are assigned via
      Standards Action [[RFC2434](/doc/html/rfc2434)].  Values in the range 64-223 (decimal)
      inclusive are assigned via Specification Required [[RFC2434](/doc/html/rfc2434)].
      Values from 224-255 (decimal) inclusive are reserved for Private
      Use [[RFC2434](/doc/html/rfc2434)].

Dierks & Rescorla           Standards Track                    [Page 66]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   -  TLS HashAlgorithm Registry: The registry has been initially
      populated with the values described in [Section 7.4.1.4.1](#section-7.4.1.4.1).  Future
      values in the range 0-63 (decimal) inclusive are assigned via
      Standards Action [[RFC2434](/doc/html/rfc2434)].  Values in the range 64-223 (decimal)
      inclusive are assigned via Specification Required [[RFC2434](/doc/html/rfc2434)].
      Values from 224-255 (decimal) inclusive are reserved for Private
      Use [[RFC2434](/doc/html/rfc2434)].

      This document also uses the TLS Compression Method Identifiers
      Registry, defined in [[RFC3749](/doc/html/rfc3749)].  IANA has allocated value 0 for
      the "null" compression method.

Dierks & Rescorla           Standards Track                    [Page 67]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[Appendix A](#appendix-A).  Protocol Data Structures and Constant Values

   This section describes protocol types and constants.

[A.1](#appendix-A.1).  Record Layer

   struct {
       uint8 major;
       uint8 minor;
   } ProtocolVersion;

   ProtocolVersion version = { 3, 3 };     /* TLS v1.2*/

   enum {
       change_cipher_spec(20), alert(21), handshake(22),
       application_data(23), (255)
   } ContentType;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque fragment[TLSPlaintext.length];
   } TLSPlaintext;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque fragment[TLSCompressed.length];
   } TLSCompressed;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       select (SecurityParameters.cipher_type) {
           case stream: GenericStreamCipher;
           case block:  GenericBlockCipher;
           case aead:   GenericAEADCipher;
       } fragment;
   } TLSCiphertext;

   stream-ciphered struct {
       opaque content[TLSCompressed.length];
       opaque MAC[SecurityParameters.mac_length];
   } GenericStreamCipher;

Dierks & Rescorla           Standards Track                    [Page 68]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   struct {
       opaque IV[SecurityParameters.record_iv_length];
       block-ciphered struct {
           opaque content[TLSCompressed.length];
           opaque MAC[SecurityParameters.mac_length];
           uint8 padding[GenericBlockCipher.padding_length];
           uint8 padding_length;
       };
   } GenericBlockCipher;

   struct {
      opaque nonce_explicit[SecurityParameters.record_iv_length];
      aead-ciphered struct {
          opaque content[TLSCompressed.length];
      };
   } GenericAEADCipher;

[A.2](#appendix-A.2).  Change Cipher Specs Message

   struct {
       enum { change_cipher_spec(1), (255) } type;
   } ChangeCipherSpec;

[A.3](#appendix-A.3).  Alert Messages

   enum { warning(1), fatal(2), (255) } AlertLevel;

   enum {
       close_notify(0),
       unexpected_message(10),
       bad_record_mac(20),
       decryption_failed_RESERVED(21),
       record_overflow(22),
       decompression_failure(30),
       handshake_failure(40),
       no_certificate_RESERVED(41),
       bad_certificate(42),
       unsupported_certificate(43),
       certificate_revoked(44),
       certificate_expired(45),
       certificate_unknown(46),
       illegal_parameter(47),
       unknown_ca(48),
       access_denied(49),
       decode_error(50),
       decrypt_error(51),
       export_restriction_RESERVED(60),
       protocol_version(70),

Dierks & Rescorla           Standards Track                    [Page 69]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

       insufficient_security(71),
       internal_error(80),
       user_canceled(90),
       no_renegotiation(100),
       unsupported_extension(110),           /* new */
       (255)
   } AlertDescription;

   struct {
       AlertLevel level;
       AlertDescription description;
   } Alert;

[A.4](#appendix-A.4).  Handshake Protocol

   enum {
       hello_request(0), client_hello(1), server_hello(2),
       certificate(11), server_key_exchange (12),
       certificate_request(13), server_hello_done(14),
       certificate_verify(15), client_key_exchange(16),
       finished(20)
       (255)
   } HandshakeType;

   struct {
       HandshakeType msg_type;
       uint24 length;
       select (HandshakeType) {
           case hello_request:       HelloRequest;
           case client_hello:        ClientHello;
           case server_hello:        ServerHello;
           case certificate:         Certificate;
           case server_key_exchange: ServerKeyExchange;
           case certificate_request: CertificateRequest;
           case server_hello_done:   ServerHelloDone;
           case certificate_verify:  CertificateVerify;
           case client_key_exchange: ClientKeyExchange;
           case finished:            Finished;
       } body;
   } Handshake;

Dierks & Rescorla           Standards Track                    [Page 70]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[A.4.1](#appendix-A.4.1).  Hello Messages

   struct { } HelloRequest;

   struct {
       uint32 gmt_unix_time;
       opaque random_bytes[28];
   } Random;

   opaque SessionID<0..32>;

   uint8 CipherSuite[2];

   enum { null(0), (255) } CompressionMethod;

   struct {
       ProtocolVersion client_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suites<2..2^16-2>;
       CompressionMethod compression_methods<1..2^8-1>;
       select (extensions_present) {
           case false:
               struct {};
           case true:
               Extension extensions<0..2^16-1>;
       };
   } ClientHello;

   struct {
       ProtocolVersion server_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suite;
       CompressionMethod compression_method;
       select (extensions_present) {
           case false:
               struct {};
           case true:
               Extension extensions<0..2^16-1>;
       };
   } ServerHello;

   struct {
       ExtensionType extension_type;
       opaque extension_data<0..2^16-1>;
   } Extension;

Dierks & Rescorla           Standards Track                    [Page 71]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   enum {
       signature_algorithms(13), (65535)
   } ExtensionType;

   enum{
       none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
       sha512(6), (255)
   } HashAlgorithm;
   enum {
      anonymous(0), rsa(1), dsa(2), ecdsa(3), (255)
   } SignatureAlgorithm;

   struct {
         HashAlgorithm hash;
         SignatureAlgorithm signature;
   } SignatureAndHashAlgorithm;

   SignatureAndHashAlgorithm
    supported_signature_algorithms<2..2^16-1>;

[A.4.2](#appendix-A.4.2).  Server Authentication and Key Exchange Messages

   opaque ASN.1Cert<2^24-1>;

   struct {
       ASN.1Cert certificate_list<0..2^24-1>;
   } Certificate;

   enum { dhe_dss, dhe_rsa, dh_anon, rsa,dh_dss, dh_rsa
          /* may be extended, e.g., for ECDH -- see [[TLSECC](#ref-TLSECC)] */
        } KeyExchangeAlgorithm;

   struct {
       opaque dh_p<1..2^16-1>;
       opaque dh_g<1..2^16-1>;
       opaque dh_Ys<1..2^16-1>;
   } ServerDHParams;     /* Ephemeral DH parameters */

Dierks & Rescorla           Standards Track                    [Page 72]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   struct {
       select (KeyExchangeAlgorithm) {
           case dh_anon:
               ServerDHParams params;
           case dhe_dss:
           case dhe_rsa:
               ServerDHParams params;
               digitally-signed struct {
                   opaque client_random[32];
                   opaque server_random[32];
                   ServerDHParams params;
               } signed_params;
           case rsa:
           case dh_dss:
           case dh_rsa:
               struct {} ;
              /* message is omitted for rsa, dh_dss, and dh_rsa */
           /* may be extended, e.g., for ECDH -- see [[TLSECC](#ref-TLSECC)] */
   } ServerKeyExchange;

   enum {
       rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
       rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
       fortezza_dms_RESERVED(20),
       (255)
   } ClientCertificateType;

   opaque DistinguishedName<1..2^16-1>;

   struct {
       ClientCertificateType certificate_types<1..2^8-1>;
       DistinguishedName certificate_authorities<0..2^16-1>;
   } CertificateRequest;

   struct { } ServerHelloDone;

Dierks & Rescorla           Standards Track                    [Page 73]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[A.4.3](#appendix-A.4.3).  Client Authentication and Key Exchange Messages

   struct {
       select (KeyExchangeAlgorithm) {
           case rsa:
               EncryptedPreMasterSecret;
           case dhe_dss:
           case dhe_rsa:
           case dh_dss:
           case dh_rsa:
           case dh_anon:
               ClientDiffieHellmanPublic;
       } exchange_keys;
   } ClientKeyExchange;

   struct {
       ProtocolVersion client_version;
       opaque random[46];
   } PreMasterSecret;

   struct {
       public-key-encrypted PreMasterSecret pre_master_secret;
   } EncryptedPreMasterSecret;

   enum { implicit, explicit } PublicValueEncoding;

   struct {
       select (PublicValueEncoding) {
           case implicit: struct {};
           case explicit: opaque DH_Yc<1..2^16-1>;
       } dh_public;
   } ClientDiffieHellmanPublic;

   struct {
        digitally-signed struct {
            opaque handshake_messages[handshake_messages_length];
        }
   } CertificateVerify;

[A.4.4](#appendix-A.4.4).  Handshake Finalization Message

   struct {
       opaque verify_data[verify_data_length];
   } Finished;

Dierks & Rescorla           Standards Track                    [Page 74]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[A.5](#appendix-A.5).  The Cipher Suite

   The following values define the cipher suite codes used in the
   ClientHello and ServerHello messages.

   A cipher suite defines a cipher specification supported in TLS
   Version 1.2.

   TLS_NULL_WITH_NULL_NULL is specified and is the initial state of a
   TLS connection during the first handshake on that channel, but MUST
   NOT be negotiated, as it provides no more protection than an
   unsecured connection.

      CipherSuite TLS_NULL_WITH_NULL_NULL               = { 0x00,0x00 };

   The following CipherSuite definitions require that the server provide
   an RSA certificate that can be used for key exchange.  The server may
   request any signature-capable certificate in the certificate request
   message.

      CipherSuite TLS_RSA_WITH_NULL_MD5                 = { 0x00,0x01 };
      CipherSuite TLS_RSA_WITH_NULL_SHA                 = { 0x00,0x02 };
      CipherSuite TLS_RSA_WITH_NULL_SHA256              = { 0x00,0x3B };
      CipherSuite TLS_RSA_WITH_RC4_128_MD5              = { 0x00,0x04 };
      CipherSuite TLS_RSA_WITH_RC4_128_SHA              = { 0x00,0x05 };
      CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA         = { 0x00,0x0A };
      CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA          = { 0x00,0x2F };
      CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA          = { 0x00,0x35 };
      CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256       = { 0x00,0x3C };
      CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256       = { 0x00,0x3D };

   The following cipher suite definitions are used for server-
   authenticated (and optionally client-authenticated) Diffie-Hellman.
   DH denotes cipher suites in which the server's certificate contains
   the Diffie-Hellman parameters signed by the certificate authority
   (CA).  DHE denotes ephemeral Diffie-Hellman, where the Diffie-Hellman
   parameters are signed by a signature-capable certificate, which has
   been signed by the CA.  The signing algorithm used by the server is
   specified after the DHE component of the CipherSuite name.  The
   server can request any signature-capable certificate from the client
   for client authentication, or it may request a Diffie-Hellman
   certificate.  Any Diffie-Hellman certificate provided by the client
   must use the parameters (group and generator) described by the
   server.

Dierks & Rescorla           Standards Track                    [Page 75]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x0D };
      CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x10 };
      CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x13 };
      CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x16 };
      CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA       = { 0x00,0x30 };
      CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA       = { 0x00,0x31 };
      CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA      = { 0x00,0x32 };
      CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA      = { 0x00,0x33 };
      CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA       = { 0x00,0x36 };
      CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA       = { 0x00,0x37 };
      CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA      = { 0x00,0x38 };
      CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA      = { 0x00,0x39 };
      CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256    = { 0x00,0x3E };
      CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256    = { 0x00,0x3F };
      CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256   = { 0x00,0x40 };
      CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256   = { 0x00,0x67 };
      CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256    = { 0x00,0x68 };
      CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256    = { 0x00,0x69 };
      CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256   = { 0x00,0x6A };
      CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256   = { 0x00,0x6B };

   The following cipher suites are used for completely anonymous
   Diffie-Hellman communications in which neither party is
   authenticated.  Note that this mode is vulnerable to man-in-the-
   middle attacks.  Using this mode therefore is of limited use: These
   cipher suites MUST NOT be used by TLS 1.2 implementations unless the
   application layer has specifically requested to allow anonymous key
   exchange.  (Anonymous key exchange may sometimes be acceptable, for
   example, to support opportunistic encryption when no set-up for
   authentication is in place, or when TLS is used as part of more
   complex security protocols that have other means to ensure
   authentication.)

      CipherSuite TLS_DH_anon_WITH_RC4_128_MD5          = { 0x00,0x18 };
      CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x1B };
      CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA      = { 0x00,0x34 };
      CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA      = { 0x00,0x3A };
      CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256   = { 0x00,0x6C };
      CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256   = { 0x00,0x6D };

   Note that using non-anonymous key exchange without actually verifying
   the key exchange is essentially equivalent to anonymous key exchange,
   and the same precautions apply.  While non-anonymous key exchange
   will generally involve a higher computational and communicational
   cost than anonymous key exchange, it may be in the interest of
   interoperability not to disable non-anonymous key exchange when the
   application layer is allowing anonymous key exchange.

Dierks & Rescorla           Standards Track                    [Page 76]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   New cipher suite values have been assigned by IANA as described in
   [Section 12](#section-12).

   Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are
   reserved to avoid collision with Fortezza-based cipher suites in
   SSL 3.

[A.6](#appendix-A.6).  The Security Parameters

   These security parameters are determined by the TLS Handshake
   Protocol and provided as parameters to the TLS record layer in order
   to initialize a connection state.  SecurityParameters includes:

   enum { null(0), (255) } CompressionMethod;

   enum { server, client } ConnectionEnd;

   enum { tls_prf_sha256 } PRFAlgorithm;

   enum { null, rc4, 3des, aes } BulkCipherAlgorithm;

   enum { stream, block, aead } CipherType;

   enum { null, hmac_md5, hmac_sha1, hmac_sha256, hmac_sha384,
     hmac_sha512} MACAlgorithm;

   /* Other values may be added to the algorithms specified in
   CompressionMethod, PRFAlgorithm, BulkCipherAlgorithm, and
   MACAlgorithm. */

   struct {
       ConnectionEnd          entity;
       PRFAlgorithm           prf_algorithm;
       BulkCipherAlgorithm    bulk_cipher_algorithm;
       CipherType             cipher_type;
       uint8                  enc_key_length;
       uint8                  block_length;
       uint8                  fixed_iv_length;
       uint8                  record_iv_length;
       MACAlgorithm           mac_algorithm;
       uint8                  mac_length;
       uint8                  mac_key_length;
       CompressionMethod      compression_algorithm;
       opaque                 master_secret[48];
       opaque                 client_random[32];
       opaque                 server_random[32];
   } SecurityParameters;

Dierks & Rescorla           Standards Track                    [Page 77]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[A.7](#appendix-A.7).  Changes to [RFC 4492](/doc/html/rfc4492)

   [RFC 4492](/doc/html/rfc4492) [[TLSECC](#ref-TLSECC)] adds Elliptic Curve cipher suites to TLS.  This
   document changes some of the structures used in that document.  This
   section details the required changes for implementors of both [RFC](/doc/html/rfc4492)
   [4492](/doc/html/rfc4492) and TLS 1.2.  Implementors of TLS 1.2 who are not implementing
   [RFC 4492](/doc/html/rfc4492) do not need to read this section.

   This document adds a "signature_algorithm" field to the digitally-
   signed element in order to identify the signature and digest
   algorithms used to create a signature.  This change applies to
   digital signatures formed using ECDSA as well, thus allowing ECDSA
   signatures to be used with digest algorithms other than SHA-1,
   provided such use is compatible with the certificate and any
   restrictions imposed by future revisions of [[PKIX](#ref-PKIX)].

   As described in Sections [7.4.2](#section-7.4.2) and [7.4.6](#section-7.4.6), the restrictions on the
   signature algorithms used to sign certificates are no longer tied to
   the cipher suite (when used by the server) or the
   ClientCertificateType (when used by the client).  Thus, the
   restrictions on the algorithm used to sign certificates specified in
   Sections [2](#section-2) and [3](#section-3) of [RFC 4492](/doc/html/rfc4492) are also relaxed.  As in this document,
   the restrictions on the keys in the end-entity certificate remain.

[Appendix B](#appendix-B).  Glossary

   Advanced Encryption Standard (AES)
      AES [[AES](#ref-AES)] is a widely used symmetric encryption algorithm.  AES is
      a block cipher with a 128-, 192-, or 256-bit keys and a 16-byte
      block size.  TLS currently only supports the 128- and 256-bit key
      sizes.

   application protocol
      An application protocol is a protocol that normally layers
      directly on top of the transport layer (e.g., TCP/IP).  Examples
      include HTTP, TELNET, FTP, and SMTP.

   asymmetric cipher
      See public key cryptography.

   authenticated encryption with additional data (AEAD)
      A symmetric encryption algorithm that simultaneously provides
      confidentiality and message integrity.

   authentication
      Authentication is the ability of one entity to determine the
      identity of another entity.

Dierks & Rescorla           Standards Track                    [Page 78]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   block cipher
      A block cipher is an algorithm that operates on plaintext in
      groups of bits, called blocks.  64 bits was, and 128 bits is, a
      common block size.

   bulk cipher
      A symmetric encryption algorithm used to encrypt large quantities
      of data.

   cipher block chaining (CBC)
      CBC is a mode in which every plaintext block encrypted with a
      block cipher is first exclusive-ORed with the previous ciphertext
      block (or, in the case of the first block, with the initialization
      vector).  For decryption, every block is first decrypted, then
      exclusive-ORed with the previous ciphertext block (or IV).

   certificate
      As part of the X.509 protocol (a.k.a. ISO Authentication
      framework), certificates are assigned by a trusted Certificate
      Authority and provide a strong binding between a party's identity
      or some other attributes and its public key.

   client
      The application entity that initiates a TLS connection to a
      server.  This may or may not imply that the client initiated the
      underlying transport connection.  The primary operational
      difference between the server and client is that the server is
      generally authenticated, while the client is only optionally
      authenticated.

   client write key
      The key used to encrypt data written by the client.

   client write MAC key
      The secret data used to authenticate data written by the client.

   connection
      A connection is a transport (in the OSI layering model definition)
      that provides a suitable type of service.  For TLS, such
      connections are peer-to-peer relationships.  The connections are
      transient.  Every connection is associated with one session.

   Data Encryption Standard
      DES [[DES](#ref-DES)] still is a very widely used symmetric encryption
      algorithm although it is considered as rather weak now.  DES is a
      block cipher with a 56-bit key and an 8-byte block size.  Note
      that in TLS, for key generation purposes, DES is treated as having
      an 8-byte key length (64 bits), but it still only provides 56 bits

Dierks & Rescorla           Standards Track                    [Page 79]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

      of protection.  (The low bit of each key byte is presumed to be
      set to produce odd parity in that key byte.)  DES can also be
      operated in a mode [[3DES](#ref-3DES)] where three independent keys and three
      encryptions are used for each block of data; this uses 168 bits of
      key (24 bytes in the TLS key generation method) and provides the
      equivalent of 112 bits of security.

   Digital Signature Standard (DSS)
      A standard for digital signing, including the Digital Signing
      Algorithm, approved by the National Institute of Standards and
      Technology, defined in NIST FIPS PUB 186-2, "Digital Signature
      Standard", published January 2000 by the U.S. Department of
      Commerce [[DSS](#ref-DSS)].  A significant update [[DSS-3](#ref-DSS-3)] has been drafted and
      was published in March 2006.

   digital signatures
      Digital signatures utilize public key cryptography and one-way
      hash functions to produce a signature of the data that can be
      authenticated, and is difficult to forge or repudiate.

   handshake An initial negotiation between client and server that
      establishes the parameters of their transactions.

   Initialization Vector (IV)
      When a block cipher is used in CBC mode, the initialization vector
      is exclusive-ORed with the first plaintext block prior to
      encryption.

   Message Authentication Code (MAC)
      A Message Authentication Code is a one-way hash computed from a
      message and some secret data.  It is difficult to forge without
      knowing the secret data.  Its purpose is to detect if the message
      has been altered.

   master secret
      Secure secret data used for generating encryption keys, MAC
      secrets, and IVs.

   MD5
      MD5 [[MD5](#ref-MD5)] is a hashing function that converts an arbitrarily long
      data stream into a hash of fixed size (16 bytes).  Due to
      significant progress in cryptanalysis, at the time of publication
      of this document, MD5 no longer can be considered a 'secure'
      hashing function.

Dierks & Rescorla           Standards Track                    [Page 80]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   public key cryptography
      A class of cryptographic techniques employing two-key ciphers.
      Messages encrypted with the public key can only be decrypted with
      the associated private key.  Conversely, messages signed with the
      private key can be verified with the public key.

   one-way hash function
      A one-way transformation that converts an arbitrary amount of data
      into a fixed-length hash.  It is computationally hard to reverse
      the transformation or to find collisions.  MD5 and SHA are
      examples of one-way hash functions.

   RC4
      A stream cipher invented by Ron Rivest.  A compatible cipher is
      described in [[SCH](#ref-SCH)].

   RSA
      A very widely used public key algorithm that can be used for
      either encryption or digital signing.  [[RSA](#ref-RSA)]

   server
      The server is the application entity that responds to requests for
      connections from clients.  See also "client".

   session
      A TLS session is an association between a client and a server.
      Sessions are created by the handshake protocol.  Sessions define a
      set of cryptographic security parameters that can be shared among
      multiple connections.  Sessions are used to avoid the expensive
      negotiation of new security parameters for each connection.

   session identifier
      A session identifier is a value generated by a server that
      identifies a particular session.

   server write key
      The key used to encrypt data written by the server.

   server write MAC key
      The secret data used to authenticate data written by the server.

   SHA
      The Secure Hash Algorithm [[SHS](#ref-SHS)] is defined in FIPS PUB 180-2.  It
      produces a 20-byte output.  Note that all references to SHA
      (without a numerical suffix) actually use the modified SHA-1
      algorithm.

Dierks & Rescorla           Standards Track                    [Page 81]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   SHA-256
      The 256-bit Secure Hash Algorithm is defined in FIPS PUB 180-2.
      It produces a 32-byte output.

   SSL
      Netscape's Secure Socket Layer protocol [[SSL3](#ref-SSL3)].  TLS is based on
      SSL Version 3.0.

   stream cipher
      An encryption algorithm that converts a key into a
      cryptographically strong keystream, which is then exclusive-ORed
      with the plaintext.

   symmetric cipher
      See bulk cipher.

   Transport Layer Security (TLS)
      This protocol; also, the Transport Layer Security working group of
      the Internet Engineering Task Force (IETF).  See "Working Group
      Information" at the end of this document (see page 99).

Dierks & Rescorla           Standards Track                    [Page 82]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[Appendix C](#appendix-C).  Cipher Suite Definitions

Cipher Suite                            Key        Cipher         Mac
                                        Exchange

TLS_NULL_WITH_NULL_NULL                 NULL         NULL         NULL
TLS_RSA_WITH_NULL_MD5                   RSA          NULL         MD5
TLS_RSA_WITH_NULL_SHA                   RSA          NULL         SHA
TLS_RSA_WITH_NULL_SHA256                RSA          NULL         SHA256
TLS_RSA_WITH_RC4_128_MD5                RSA          RC4_128      MD5
TLS_RSA_WITH_RC4_128_SHA                RSA          RC4_128      SHA
TLS_RSA_WITH_3DES_EDE_CBC_SHA           RSA          3DES_EDE_CBC SHA
TLS_RSA_WITH_AES_128_CBC_SHA            RSA          AES_128_CBC  SHA
TLS_RSA_WITH_AES_256_CBC_SHA            RSA          AES_256_CBC  SHA
TLS_RSA_WITH_AES_128_CBC_SHA256         RSA          AES_128_CBC  SHA256
TLS_RSA_WITH_AES_256_CBC_SHA256         RSA          AES_256_CBC  SHA256
TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA        DH_DSS       3DES_EDE_CBC SHA
TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA        DH_RSA       3DES_EDE_CBC SHA
TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA       DHE_DSS      3DES_EDE_CBC SHA
TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA       DHE_RSA      3DES_EDE_CBC SHA
TLS_DH_anon_WITH_RC4_128_MD5            DH_anon      RC4_128      MD5
TLS_DH_anon_WITH_3DES_EDE_CBC_SHA       DH_anon      3DES_EDE_CBC SHA
TLS_DH_DSS_WITH_AES_128_CBC_SHA         DH_DSS       AES_128_CBC  SHA
TLS_DH_RSA_WITH_AES_128_CBC_SHA         DH_RSA       AES_128_CBC  SHA
TLS_DHE_DSS_WITH_AES_128_CBC_SHA        DHE_DSS      AES_128_CBC  SHA
TLS_DHE_RSA_WITH_AES_128_CBC_SHA        DHE_RSA      AES_128_CBC  SHA
TLS_DH_anon_WITH_AES_128_CBC_SHA        DH_anon      AES_128_CBC  SHA
TLS_DH_DSS_WITH_AES_256_CBC_SHA         DH_DSS       AES_256_CBC  SHA
TLS_DH_RSA_WITH_AES_256_CBC_SHA         DH_RSA       AES_256_CBC  SHA
TLS_DHE_DSS_WITH_AES_256_CBC_SHA        DHE_DSS      AES_256_CBC  SHA
TLS_DHE_RSA_WITH_AES_256_CBC_SHA        DHE_RSA      AES_256_CBC  SHA
TLS_DH_anon_WITH_AES_256_CBC_SHA        DH_anon      AES_256_CBC  SHA
TLS_DH_DSS_WITH_AES_128_CBC_SHA256      DH_DSS       AES_128_CBC  SHA256
TLS_DH_RSA_WITH_AES_128_CBC_SHA256      DH_RSA       AES_128_CBC  SHA256
TLS_DHE_DSS_WITH_AES_128_CBC_SHA256     DHE_DSS      AES_128_CBC  SHA256
TLS_DHE_RSA_WITH_AES_128_CBC_SHA256     DHE_RSA      AES_128_CBC  SHA256
TLS_DH_anon_WITH_AES_128_CBC_SHA256     DH_anon      AES_128_CBC  SHA256
TLS_DH_DSS_WITH_AES_256_CBC_SHA256      DH_DSS       AES_256_CBC  SHA256
TLS_DH_RSA_WITH_AES_256_CBC_SHA256      DH_RSA       AES_256_CBC  SHA256
TLS_DHE_DSS_WITH_AES_256_CBC_SHA256     DHE_DSS      AES_256_CBC  SHA256
TLS_DHE_RSA_WITH_AES_256_CBC_SHA256     DHE_RSA      AES_256_CBC  SHA256
TLS_DH_anon_WITH_AES_256_CBC_SHA256     DH_anon      AES_256_CBC  SHA256

Dierks & Rescorla           Standards Track                    [Page 83]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

                        Key      IV   Block
Cipher        Type    Material  Size  Size
------------  ------  --------  ----  -----
NULL          Stream      0       0    N/A
RC4_128       Stream     16       0    N/A
3DES_EDE_CBC  Block      24       8      8
AES_128_CBC   Block      16      16     16
AES_256_CBC   Block      32      16     16

MAC       Algorithm    mac_length  mac_key_length
--------  -----------  ----------  --------------
NULL      N/A              0             0
MD5       HMAC-MD5        16            16
SHA       HMAC-SHA1       20            20
SHA256    HMAC-SHA256     32            32

   Type
      Indicates whether this is a stream cipher or a block cipher
      running in CBC mode.

   Key Material
      The number of bytes from the key_block that are used for
      generating the write keys.

   IV Size
      The amount of data needed to be generated for the initialization
      vector.  Zero for stream ciphers; equal to the block size for
      block ciphers (this is equal to
      SecurityParameters.record_iv_length).

   Block Size
      The amount of data a block cipher enciphers in one chunk; a block
      cipher running in CBC mode can only encrypt an even multiple of
      its block size.

Dierks & Rescorla           Standards Track                    [Page 84]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[Appendix D](#appendix-D).  Implementation Notes

   The TLS protocol cannot prevent many common security mistakes.  This
   section provides several recommendations to assist implementors.

[D.1](#appendix-D.1).  Random Number Generation and Seeding

   TLS requires a cryptographically secure pseudorandom number generator
   (PRNG).  Care must be taken in designing and seeding PRNGs.  PRNGs
   based on secure hash operations, most notably SHA-1, are acceptable,
   but cannot provide more security than the size of the random number
   generator state.

   To estimate the amount of seed material being produced, add the
   number of bits of unpredictable information in each seed byte.  For
   example, keystroke timing values taken from a PC compatible's 18.2 Hz
   timer provide 1 or 2 secure bits each, even though the total size of
   the counter value is 16 bits or more.  Seeding a 128-bit PRNG would
   thus require approximately 100 such timer values.

   [RANDOM] provides guidance on the generation of random values.

[D.2](#appendix-D.2).  Certificates and Authentication

   Implementations are responsible for verifying the integrity of
   certificates and should generally support certificate revocation
   messages.  Certificates should always be verified to ensure proper
   signing by a trusted Certificate Authority (CA).  The selection and
   addition of trusted CAs should be done very carefully.  Users should
   be able to view information about the certificate and root CA.

[D.3](#appendix-D.3).  Cipher Suites

   TLS supports a range of key sizes and security levels, including some
   that provide no or minimal security.  A proper implementation will
   probably not support many cipher suites.  For instance, anonymous
   Diffie-Hellman is strongly discouraged because it cannot prevent man-
   in-the-middle attacks.  Applications should also enforce minimum and
   maximum key sizes.  For example, certificate chains containing 512-
   bit RSA keys or signatures are not appropriate for high-security
   applications.

[D.4](#appendix-D.4).  Implementation Pitfalls

   Implementation experience has shown that certain parts of earlier TLS
   specifications are not easy to understand, and have been a source of
   interoperability and security problems.  Many of these areas have

Dierks & Rescorla           Standards Track                    [Page 85]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   been clarified in this document, but this appendix contains a short
   list of the most important things that require special attention from
   implementors.

   TLS protocol issues:

   -  Do you correctly handle handshake messages that are fragmented to
      multiple TLS records (see [Section 6.2.1](#section-6.2.1))? Including corner cases
      like a ClientHello that is split to several small fragments? Do
      you fragment handshake messages that exceed the maximum fragment
      size? In particular, the certificate and certificate request
      handshake messages can be large enough to require fragmentation.

   -  Do you ignore the TLS record layer version number in all TLS
      records before ServerHello (see [Appendix E.1](#appendix-E.1))?

   -  Do you handle TLS extensions in ClientHello correctly, including
      omitting the extensions field completely?

   -  Do you support renegotiation, both client and server initiated?
      While renegotiation is an optional feature, supporting it is
      highly recommended.

   -  When the server has requested a client certificate, but no
      suitable certificate is available, do you correctly send an empty
      Certificate message, instead of omitting the whole message (see
      [Section 7.4.6](#section-7.4.6))?

   Cryptographic details:

   -  In the RSA-encrypted Premaster Secret, do you correctly send and
      verify the version number? When an error is encountered, do you
      continue the handshake to avoid the Bleichenbacher attack (see
      [Section 7.4.7.1](#section-7.4.7.1))?

   -  What countermeasures do you use to prevent timing attacks against
      RSA decryption and signing operations (see [Section 7.4.7.1](#section-7.4.7.1))?

   -  When verifying RSA signatures, do you accept both NULL and missing
      parameters (see [Section 4.7](#section-4.7))? Do you verify that the RSA padding
      doesn't have additional data after the hash value?  [[FI06](#ref-FI06)]

   -  When using Diffie-Hellman key exchange, do you correctly strip
      leading zero bytes from the negotiated key (see [Section 8.1.2](#section-8.1.2))?

   -  Does your TLS client check that the Diffie-Hellman parameters sent
      by the server are acceptable (see Section F.1.1.3)?

Dierks & Rescorla           Standards Track                    [Page 86]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   -  How do you generate unpredictable IVs for CBC mode ciphers (see
      [Section 6.2.3.2](#section-6.2.3.2))?

   -  Do you accept long CBC mode padding (up to 255 bytes; see [Section](#section-6.2.3.2)
      [6.2.3.2](#section-6.2.3.2))?

   -  How do you address CBC mode timing attacks ([Section 6.2.3.2](#section-6.2.3.2))?

   -  Do you use a strong and, most importantly, properly seeded random
      number generator (see [Appendix D.1](#appendix-D.1)) for generating the premaster
      secret (for RSA key exchange), Diffie-Hellman private values, the
      DSA "k" parameter, and other security-critical values?

[Appendix E](#appendix-E).  Backward Compatibility

[E.1](#appendix-E.1).  Compatibility with TLS 1.0/1.1 and SSL 3.0

   Since there are various versions of TLS (1.0, 1.1, 1.2, and any
   future versions) and SSL (2.0 and 3.0), means are needed to negotiate
   the specific protocol version to use.  The TLS protocol provides a
   built-in mechanism for version negotiation so as not to bother other
   protocol components with the complexities of version selection.

   TLS versions 1.0, 1.1, and 1.2, and SSL 3.0 are very similar, and use
   compatible ClientHello messages; thus, supporting all of them is
   relatively easy.  Similarly, servers can easily handle clients trying
   to use future versions of TLS as long as the ClientHello format
   remains compatible, and the client supports the highest protocol
   version available in the server.

   A TLS 1.2 client who wishes to negotiate with such older servers will
   send a normal TLS 1.2 ClientHello, containing { 3, 3 } (TLS 1.2) in
   ClientHello.client_version.  If the server does not support this
   version, it will respond with a ServerHello containing an older
   version number.  If the client agrees to use this version, the
   negotiation will proceed as appropriate for the negotiated protocol.

   If the version chosen by the server is not supported by the client
   (or not acceptable), the client MUST send a "protocol_version" alert
   message and close the connection.

   If a TLS server receives a ClientHello containing a version number
   greater than the highest version supported by the server, it MUST
   reply according to the highest version supported by the server.

   A TLS server can also receive a ClientHello containing a version
   number smaller than the highest supported version.  If the server
   wishes to negotiate with old clients, it will proceed as appropriate

Dierks & Rescorla           Standards Track                    [Page 87]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   for the highest version supported by the server that is not greater
   than ClientHello.client_version.  For example, if the server supports
   TLS 1.0, 1.1, and 1.2, and client_version is TLS 1.0, the server will
   proceed with a TLS 1.0 ServerHello.  If server supports (or is
   willing to use) only versions greater than client_version, it MUST
   send a "protocol_version" alert message and close the connection.

   Whenever a client already knows the highest protocol version known to
   a server (for example, when resuming a session), it SHOULD initiate
   the connection in that native protocol.

   Note: some server implementations are known to implement version
   negotiation incorrectly.  For example, there are buggy TLS 1.0
   servers that simply close the connection when the client offers a
   version newer than TLS 1.0.  Also, it is known that some servers will
   refuse the connection if any TLS extensions are included in
   ClientHello.  Interoperability with such buggy servers is a complex
   topic beyond the scope of this document, and may require multiple
   connection attempts by the client.

   Earlier versions of the TLS specification were not fully clear on
   what the record layer version number (TLSPlaintext.version) should
   contain when sending ClientHello (i.e., before it is known which
   version of the protocol will be employed).  Thus, TLS servers
   compliant with this specification MUST accept any value {03,XX} as
   the record layer version number for ClientHello.

   TLS clients that wish to negotiate with older servers MAY send any
   value {03,XX} as the record layer version number.  Typical values
   would be {03,00}, the lowest version number supported by the client,
   and the value of ClientHello.client_version.  No single value will
   guarantee interoperability with all old servers, but this is a
   complex topic beyond the scope of this document.

[E.2](#appendix-E.2).  Compatibility with SSL 2.0

   TLS 1.2 clients that wish to support SSL 2.0 servers MUST send
   version 2.0 CLIENT-HELLO messages defined in [[SSL2](#ref-SSL2)].  The message
   MUST contain the same version number as would be used for ordinary
   ClientHello, and MUST encode the supported TLS cipher suites in the
   CIPHER-SPECS-DATA field as described below.

   Warning: The ability to send version 2.0 CLIENT-HELLO messages will
   be phased out with all due haste, since the newer ClientHello format
   provides better mechanisms for moving to newer versions and
   negotiating extensions.  TLS 1.2 clients SHOULD NOT support SSL 2.0.

Dierks & Rescorla           Standards Track                    [Page 88]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   However, even TLS servers that do not support SSL 2.0 MAY accept
   version 2.0 CLIENT-HELLO messages.  The message is presented below in
   sufficient detail for TLS server implementors; the true definition is
   still assumed to be [[SSL2](#ref-SSL2)].

   For negotiation purposes, 2.0 CLIENT-HELLO is interpreted the same
   way as a ClientHello with a "null" compression method and no
   extensions.  Note that this message MUST be sent directly on the
   wire, not wrapped as a TLS record.  For the purposes of calculating
   Finished and CertificateVerify, the msg_length field is not
   considered to be a part of the handshake message.

      uint8 V2CipherSpec[3];
      struct {
          uint16 msg_length;
          uint8 msg_type;
          Version version;
          uint16 cipher_spec_length;
          uint16 session_id_length;
          uint16 challenge_length;
          V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];
          opaque session_id[V2ClientHello.session_id_length];
          opaque challenge[V2ClientHello.challenge_length;
      } V2ClientHello;

   msg_length
      The highest bit MUST be 1; the remaining bits contain the length
      of the following data in bytes.

   msg_type
      This field, in conjunction with the version field, identifies a
      version 2 ClientHello message.  The value MUST be 1.

   version
      Equal to ClientHello.client_version.

   cipher_spec_length
      This field is the total length of the field cipher_specs.  It
      cannot be zero and MUST be a multiple of the V2CipherSpec length
      (3).

   session_id_length
      This field MUST have a value of zero for a client that claims to
      support TLS 1.2.

Dierks & Rescorla           Standards Track                    [Page 89]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   challenge_length
      The length in bytes of the client's challenge to the server to
      authenticate itself.  Historically, permissible values are between
      16 and 32 bytes inclusive.  When using the SSLv2 backward-
      compatible handshake the client SHOULD use a 32-byte challenge.

   cipher_specs
      This is a list of all CipherSpecs the client is willing and able
      to use.  In addition to the 2.0 cipher specs defined in [[SSL2](#ref-SSL2)],
      this includes the TLS cipher suites normally sent in
      ClientHello.cipher_suites, with each cipher suite prefixed by a
      zero byte.  For example, the TLS cipher suite {0x00,0x0A} would be
      sent as {0x00,0x00,0x0A}.

   session_id
      This field MUST be empty.

   challenge
      Corresponds to ClientHello.random.  If the challenge length is
      less than 32, the TLS server will pad the data with leading (note:
      not trailing) zero bytes to make it 32 bytes long.

   Note: Requests to resume a TLS session MUST use a TLS client hello.

[E.3](#appendix-E.3).  Avoiding Man-in-the-Middle Version Rollback

   When TLS clients fall back to Version 2.0 compatibility mode, they
   MUST use special PKCS#1 block formatting.  This is done so that TLS
   servers will reject Version 2.0 sessions with TLS-capable clients.

   When a client negotiates SSL 2.0 but also supports TLS, it MUST set
   the right-hand (least-significant) 8 random bytes of the PKCS padding
   (not including the terminal null of the padding) for the RSA
   encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY
   to 0x03 (the other padding bytes are random).

   When a TLS-capable server negotiates SSL 2.0 it SHOULD, after
   decrypting the ENCRYPTED-KEY-DATA field, check that these 8 padding
   bytes are 0x03.  If they are not, the server SHOULD generate a random
   value for SECRET-KEY-DATA, and continue the handshake (which will
   eventually fail since the keys will not match).  Note that reporting
   the error situation to the client could make the server vulnerable to
   attacks described in [[BLEI](#ref-BLEI)].

Dierks & Rescorla           Standards Track                    [Page 90]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

[Appendix F](#appendix-F).  Security Analysis

   The TLS protocol is designed to establish a secure connection between
   a client and a server communicating over an insecure channel.  This
   document makes several traditional assumptions, including that
   attackers have substantial computational resources and cannot obtain
   secret information from sources outside the protocol.  Attackers are
   assumed to have the ability to capture, modify, delete, replay, and
   otherwise tamper with messages sent over the communication channel.
   This appendix outlines how TLS has been designed to resist a variety
   of attacks.

[F.1](#appendix-F.1).  Handshake Protocol

   The handshake protocol is responsible for selecting a cipher spec and
   generating a master secret, which together comprise the primary
   cryptographic parameters associated with a secure session.  The
   handshake protocol can also optionally authenticate parties who have
   certificates signed by a trusted certificate authority.

[F.1.1](#appendix-F.1.1).  Authentication and Key Exchange

   TLS supports three authentication modes: authentication of both
   parties, server authentication with an unauthenticated client, and
   total anonymity.  Whenever the server is authenticated, the channel
   is secure against man-in-the-middle attacks, but completely anonymous
   sessions are inherently vulnerable to such attacks.  Anonymous
   servers cannot authenticate clients.  If the server is authenticated,
   its certificate message must provide a valid certificate chain
   leading to an acceptable certificate authority.  Similarly,
   authenticated clients must supply an acceptable certificate to the
   server.  Each party is responsible for verifying that the other's
   certificate is valid and has not expired or been revoked.

   The general goal of the key exchange process is to create a
   pre_master_secret known to the communicating parties and not to
   attackers.  The pre_master_secret will be used to generate the
   master_secret (see [Section 8.1](#section-8.1)).  The master_secret is required to
   generate the Finished messages, encryption keys, and MAC keys (see
   Sections [7.4.9](#section-7.4.9) and [6.3](#section-6.3)).  By sending a correct Finished message,
   parties thus prove that they know the correct pre_master_secret.

[F.1.1.1](#appendix-F.1.1.1).  Anonymous Key Exchange

   Completely anonymous sessions can be established using Diffie-Hellman
   for key exchange.  The server's public parameters are contained in
   the server key exchange message, and the client's are sent in the

Dierks & Rescorla           Standards Track                    [Page 91]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   client key exchange message.  Eavesdroppers who do not know the
   private values should not be able to find the Diffie-Hellman result
   (i.e., the pre_master_secret).

   Warning: Completely anonymous connections only provide protection
   against passive eavesdropping.  Unless an independent tamper-proof
   channel is used to verify that the Finished messages were not
   replaced by an attacker, server authentication is required in
   environments where active man-in-the-middle attacks are a concern.

[F.1.1.2](#appendix-F.1.1.2).  RSA Key Exchange and Authentication

   With RSA, key exchange and server authentication are combined.  The
   public key is contained in the server's certificate.  Note that
   compromise of the server's static RSA key results in a loss of
   confidentiality for all sessions protected under that static key.
   TLS users desiring Perfect Forward Secrecy should use DHE cipher
   suites.  The damage done by exposure of a private key can be limited
   by changing one's private key (and certificate) frequently.

   After verifying the server's certificate, the client encrypts a
   pre_master_secret with the server's public key.  By successfully
   decoding the pre_master_secret and producing a correct Finished
   message, the server demonstrates that it knows the private key
   corresponding to the server certificate.

   When RSA is used for key exchange, clients are authenticated using
   the certificate verify message (see [Section 7.4.8](#section-7.4.8)).  The client signs
   a value derived from all preceding handshake messages.  These
   handshake messages include the server certificate, which binds the
   signature to the server, and ServerHello.random, which binds the
   signature to the current handshake process.

[F.1.1.3](#appendix-F.1.1.3).  Diffie-Hellman Key Exchange with Authentication

   When Diffie-Hellman key exchange is used, the server can either
   supply a certificate containing fixed Diffie-Hellman parameters or
   use the server key exchange message to send a set of temporary
   Diffie-Hellman parameters signed with a DSA or RSA certificate.
   Temporary parameters are hashed with the hello.random values before
   signing to ensure that attackers do not replay old parameters.  In
   either case, the client can verify the certificate or signature to
   ensure that the parameters belong to the server.

   If the client has a certificate containing fixed Diffie-Hellman
   parameters, its certificate contains the information required to
   complete the key exchange.  Note that in this case the client and
   server will generate the same Diffie-Hellman result (i.e.,

Dierks & Rescorla           Standards Track                    [Page 92]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   pre_master_secret) every time they communicate.  To prevent the
   pre_master_secret from staying in memory any longer than necessary,
   it should be converted into the master_secret as soon as possible.
   Client Diffie-Hellman parameters must be compatible with those
   supplied by the server for the key exchange to work.

   If the client has a standard DSA or RSA certificate or is
   unauthenticated, it sends a set of temporary parameters to the server
   in the client key exchange message, then optionally uses a
   certificate verify message to authenticate itself.

   If the same DH keypair is to be used for multiple handshakes, either
   because the client or server has a certificate containing a fixed DH
   keypair or because the server is reusing DH keys, care must be taken
   to prevent small subgroup attacks.  Implementations SHOULD follow the
   guidelines found in [[SUBGROUP](#ref-SUBGROUP)].

   Small subgroup attacks are most easily avoided by using one of the
   DHE cipher suites and generating a fresh DH private key (X) for each
   handshake.  If a suitable base (such as 2) is chosen, g^X mod p can
   be computed very quickly; therefore, the performance cost is
   minimized.  Additionally, using a fresh key for each handshake
   provides Perfect Forward Secrecy.  Implementations SHOULD generate a
   new X for each handshake when using DHE cipher suites.

   Because TLS allows the server to provide arbitrary DH groups, the
   client should verify that the DH group is of suitable size as defined
   by local policy.  The client SHOULD also verify that the DH public
   exponent appears to be of adequate size.  [[KEYSIZ](#ref-KEYSIZ)] provides a useful
   guide to the strength of various group sizes.  The server MAY choose
   to assist the client by providing a known group, such as those
   defined in [[IKEALG](#ref-IKEALG)] or [[MODP](#ref-MODP)].  These can be verified by simple
   comparison.

[F.1.2](#appendix-F.1.2).  Version Rollback Attacks

   Because TLS includes substantial improvements over SSL Version 2.0,
   attackers may try to make TLS-capable clients and servers fall back
   to Version 2.0.  This attack can occur if (and only if) two TLS-
   capable parties use an SSL 2.0 handshake.

   Although the solution using non-random PKCS #1 block type 2 message
   padding is inelegant, it provides a reasonably secure way for Version
   3.0 servers to detect the attack.  This solution is not secure
   against attackers who can brute-force the key and substitute a new
   ENCRYPTED-KEY-DATA message containing the same key (but with normal
   padding) before the application-specified wait threshold has expired.
   Altering the padding of the least-significant 8 bytes of the PKCS

Dierks & Rescorla           Standards Track                    [Page 93]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   padding does not impact security for the size of the signed hashes
   and RSA key lengths used in the protocol, since this is essentially
   equivalent to increasing the input block size by 8 bytes.

[F.1.3](#appendix-F.1.3).  Detecting Attacks Against the Handshake Protocol

   An attacker might try to influence the handshake exchange to make the
   parties select different encryption algorithms than they would
   normally choose.

   For this attack, an attacker must actively change one or more
   handshake messages.  If this occurs, the client and server will
   compute different values for the handshake message hashes.  As a
   result, the parties will not accept each others' Finished messages.
   Without the master_secret, the attacker cannot repair the Finished
   messages, so the attack will be discovered.

[F.1.4](#appendix-F.1.4).  Resuming Sessions

   When a connection is established by resuming a session, new
   ClientHello.random and ServerHello.random values are hashed with the
   session's master_secret.  Provided that the master_secret has not
   been compromised and that the secure hash operations used to produce
   the encryption keys and MAC keys are secure, the connection should be
   secure and effectively independent from previous connections.
   Attackers cannot use known encryption keys or MAC secrets to
   compromise the master_secret without breaking the secure hash
   operations.

   Sessions cannot be resumed unless both the client and server agree.
   If either party suspects that the session may have been compromised,
   or that certificates may have expired or been revoked, it should
   force a full handshake.  An upper limit of 24 hours is suggested for
   session ID lifetimes, since an attacker who obtains a master_secret
   may be able to impersonate the compromised party until the
   corresponding session ID is retired.  Applications that may be run in
   relatively insecure environments should not write session IDs to
   stable storage.

[F.2](#appendix-F.2).  Protecting Application Data

   The master_secret is hashed with the ClientHello.random and
   ServerHello.random to produce unique data encryption keys and MAC
   secrets for each connection.

   Outgoing data is protected with a MAC before transmission.  To
   prevent message replay or modification attacks, the MAC is computed
   from the MAC key, the sequence number, the message length, the

Dierks & Rescorla           Standards Track                    [Page 94]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   message contents, and two fixed character strings.  The message type
   field is necessary to ensure that messages intended for one TLS
   record layer client are not redirected to another.  The sequence
   number ensures that attempts to delete or reorder messages will be
   detected.  Since sequence numbers are 64 bits long, they should never
   overflow.  Messages from one party cannot be inserted into the
   other's output, since they use independent MAC keys.  Similarly, the
   server write and client write keys are independent, so stream cipher
   keys are used only once.

   If an attacker does break an encryption key, all messages encrypted
   with it can be read.  Similarly, compromise of a MAC key can make
   message-modification attacks possible.  Because MACs are also
   encrypted, message-alteration attacks generally require breaking the
   encryption algorithm as well as the MAC.

   Note: MAC keys may be larger than encryption keys, so messages can
   remain tamper resistant even if encryption keys are broken.

[F.3](#appendix-F.3).  Explicit IVs

   [CBCATT] describes a chosen plaintext attack on TLS that depends on
   knowing the IV for a record.  Previous versions of TLS [[TLS1.0](#ref-TLS1.0)] used
   the CBC residue of the previous record as the IV and therefore
   enabled this attack.  This version uses an explicit IV in order to
   protect against this attack.

[F.4](#appendix-F.4).  Security of Composite Cipher Modes

   TLS secures transmitted application data via the use of symmetric
   encryption and authentication functions defined in the negotiated
   cipher suite.  The objective is to protect both the integrity and
   confidentiality of the transmitted data from malicious actions by
   active attackers in the network.  It turns out that the order in
   which encryption and authentication functions are applied to the data
   plays an important role for achieving this goal [[ENCAUTH](#ref-ENCAUTH)].

   The most robust method, called encrypt-then-authenticate, first
   applies encryption to the data and then applies a MAC to the
   ciphertext.  This method ensures that the integrity and
   confidentiality goals are obtained with ANY pair of encryption and
   MAC functions, provided that the former is secure against chosen
   plaintext attacks and that the MAC is secure against chosen-message
   attacks.  TLS uses another method, called authenticate-then-encrypt,
   in which first a MAC is computed on the plaintext and then the
   concatenation of plaintext and MAC is encrypted.  This method has
   been proven secure for CERTAIN combinations of encryption functions
   and MAC functions, but it is not guaranteed to be secure in general.

Dierks & Rescorla           Standards Track                    [Page 95]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   In particular, it has been shown that there exist perfectly secure
   encryption functions (secure even in the information-theoretic sense)
   that combined with any secure MAC function, fail to provide the
   confidentiality goal against an active attack.  Therefore, new cipher
   suites and operation modes adopted into TLS need to be analyzed under
   the authenticate-then-encrypt method to verify that they achieve the
   stated integrity and confidentiality goals.

   Currently, the security of the authenticate-then-encrypt method has
   been proven for some important cases.  One is the case of stream
   ciphers in which a computationally unpredictable pad of the length of
   the message, plus the length of the MAC tag, is produced using a
   pseudorandom generator and this pad is exclusive-ORed with the
   concatenation of plaintext and MAC tag.  The other is the case of CBC
   mode using a secure block cipher.  In this case, security can be
   shown if one applies one CBC encryption pass to the concatenation of
   plaintext and MAC and uses a new, independent, and unpredictable IV
   for each new pair of plaintext and MAC.  In versions of TLS prior to
   1.1, CBC mode was used properly EXCEPT that it used a predictable IV
   in the form of the last block of the previous ciphertext.  This made
   TLS open to chosen plaintext attacks.  This version of the protocol
   is immune to those attacks.  For exact details in the encryption
   modes proven secure, see [[ENCAUTH](#ref-ENCAUTH)].

[F.5](#appendix-F.5).  Denial of Service

   TLS is susceptible to a number of denial-of-service (DoS) attacks.
   In particular, an attacker who initiates a large number of TCP
   connections can cause a server to consume large amounts of CPU for
   doing RSA decryption.  However, because TLS is generally used over
   TCP, it is difficult for the attacker to hide his point of origin if
   proper TCP SYN randomization is used [[SEQNUM](#ref-SEQNUM)] by the TCP stack.

   Because TLS runs over TCP, it is also susceptible to a number of DoS
   attacks on individual connections.  In particular, attackers can
   forge RSTs, thereby terminating connections, or forge partial TLS
   records, thereby causing the connection to stall.  These attacks
   cannot in general be defended against by a TCP-using protocol.
   Implementors or users who are concerned with this class of attack
   should use IPsec AH [[AH](#ref-AH)] or ESP [[ESP](#ref-ESP)].

[F.6](#appendix-F.6).  Final Notes

   For TLS to be able to provide a secure connection, both the client
   and server systems, keys, and applications must be secure.  In
   addition, the implementation must be free of security errors.

Dierks & Rescorla           Standards Track                    [Page 96]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   The system is only as strong as the weakest key exchange and
   authentication algorithm supported, and only trustworthy
   cryptographic functions should be used.  Short public keys and
   anonymous servers should be used with great caution.  Implementations
   and users must be careful when deciding which certificates and
   certificate authorities are acceptable; a dishonest certificate
   authority can do tremendous damage.

Normative References

   [AES]      National Institute of Standards and Technology,
              "Specification for the Advanced Encryption Standard (AES)"
              FIPS 197.  November 26, 2001.

   [3DES]     National Institute of Standards and Technology,
              "Recommendation for the Triple Data Encryption Algorithm
              (TDEA) Block Cipher", NIST Special Publication 800-67, May
              2004.

   [DSS]      NIST FIPS PUB 186-2, "Digital Signature Standard",
              National Institute of Standards and Technology, U.S.
              Department of Commerce, 2000.

   [HMAC]     Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", [RFC 2104](/doc/html/rfc2104), February
              1997.

   [MD5]      Rivest, R., "The MD5 Message-Digest Algorithm", [RFC 1321](/doc/html/rfc1321),
              April 1992.

   [PKCS1]    Jonsson, J. and B. Kaliski, "Public-Key Cryptography
              Standards (PKCS) #1: RSA Cryptography Specifications
              Version 2.1", [RFC 3447](/doc/html/rfc3447), February 2003.

   [PKIX]     Housley, R., Polk, W., Ford, W., and D. Solo, "Internet
              X.509 Public Key Infrastructure Certificate and
              Certificate Revocation List (CRL) Profile", [RFC 3280](/doc/html/rfc3280),
              April 2002.

   [SCH]      B. Schneier. "Applied Cryptography: Protocols, Algorithms,
              and Source Code in C, 2nd ed.", Published by John Wiley &
              Sons, Inc. 1996.

   [SHS]      NIST FIPS PUB 180-2, "Secure Hash Standard", National
              Institute of Standards and Technology, U.S. Department of
              Commerce, August 2002.

Dierks & Rescorla           Standards Track                    [Page 97]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   [REQ]      Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", [BCP 14](/doc/html/bcp14), [RFC 2119](/doc/html/rfc2119), March 1997.

   [RFC2434]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", [BCP 26](/doc/html/bcp26), [RFC 2434](/doc/html/rfc2434),
              October 1998.

   [X680]     ITU-T Recommendation X.680 (2002) | ISO/IEC 8824-1:2002,
              Information technology - Abstract Syntax Notation One
              (ASN.1): Specification of basic notation.

   [X690]     ITU-T Recommendation X.690 (2002) | ISO/IEC 8825-1:2002,
              Information technology - ASN.1 encoding Rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER).

Informative References

   [AEAD]     McGrew, D., "An Interface and Algorithms for Authenticated
              Encryption", [RFC 5116](/doc/html/rfc5116), January 2008.

   [AH]       Kent, S., "IP Authentication Header", [RFC 4302](/doc/html/rfc4302), December
              2005.

   [BLEI]     Bleichenbacher D., "Chosen Ciphertext Attacks against
              Protocols Based on RSA Encryption Standard PKCS #1" in
              Advances in Cryptology -- CRYPTO'98, LNCS vol. 1462,
              pages:  1-12, 1998.

   [CBCATT]   Moeller, B., "Security of CBC Ciphersuites in SSL/TLS:
              Problems and Countermeasures",
              [http://www.openssl.org/~bodo/tls-cbc.txt](https://www.openssl.org/~bodo/tls-cbc.txt).

   [CBCTIME]  Canvel, B., Hiltgen, A., Vaudenay, S., and M. Vuagnoux,
              "Password Interception in a SSL/TLS Channel", Advances in
              Cryptology -- CRYPTO 2003, LNCS vol. 2729, 2003.

   [CCM]      "NIST Special Publication 800-38C: The CCM Mode for
              Authentication and Confidentiality",
              [http://csrc.nist.gov/publications/nistpubs/800-38C/](http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C.pdf)
              [SP800-38C.pdf](http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C.pdf)

   [DES]      National Institute of Standards and Technology, "Data
              Encryption Standard (DES)", FIPS PUB 46-3, October 1999.

Dierks & Rescorla           Standards Track                    [Page 98]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   [DSS-3]    NIST FIPS PUB 186-3 Draft, "Digital Signature Standard",
              National Institute of Standards and Technology, U.S.
              Department of Commerce, 2006.

   [ECDSA]    American National Standards Institute, "Public Key
              Cryptography for the Financial Services Industry: The
              Elliptic Curve Digital Signature Algorithm (ECDSA)", ANS
              X9.62-2005, November 2005.

   [ENCAUTH]  Krawczyk, H., "The Order of Encryption and Authentication
              for Protecting Communications (Or: How Secure is SSL?)",
              Crypto 2001.

   [ESP]      Kent, S., "IP Encapsulating Security Payload (ESP)", [RFC](/doc/html/rfc4303)
              [4303](/doc/html/rfc4303), December 2005.

   [FI06]     Hal Finney, "Bleichenbacher's RSA signature forgery based
              on implementation error", ietf-openpgp@imc.org mailing
              list, 27 August 2006, [http://www.imc.org/ietf-openpgp/](http://www.imc.org/ietf-openpgp/mail-archive/msg14307.html)
              [mail-archive/msg14307.html](http://www.imc.org/ietf-openpgp/mail-archive/msg14307.html).

   [GCM]      Dworkin, M., NIST Special Publication 800-38D,
              "Recommendation for Block Cipher Modes of Operation:
              Galois/Counter Mode (GCM) and GMAC", November 2007.

   [IKEALG]   Schiller, J., "Cryptographic Algorithms for Use in the
              Internet Key Exchange Version 2 (IKEv2)", [RFC 4307](/doc/html/rfc4307),
              December 2005.

   [KEYSIZ]   Orman, H. and P. Hoffman, "Determining Strengths For
              Public Keys Used For Exchanging Symmetric Keys", [BCP 86](/doc/html/bcp86),
              [RFC 3766](/doc/html/rfc3766), April 2004.

   [KPR03]    Klima, V., Pokorny, O., Rosa, T., "Attacking RSA-based
              Sessions in SSL/TLS", <http://eprint.iacr.org/2003/052/>,
              March 2003.

   [MODP]     Kivinen, T. and M. Kojo, "More Modular Exponential (MODP)
              Diffie-Hellman groups for Internet Key Exchange (IKE)",
              [RFC 3526](/doc/html/rfc3526), May 2003.

   [PKCS6]    RSA Laboratories, "PKCS #6: RSA Extended Certificate
              Syntax Standard", version 1.5, November 1993.

   [PKCS7]    RSA Laboratories, "PKCS #7: RSA Cryptographic Message
              Syntax Standard", version 1.5, November 1993.

Dierks & Rescorla           Standards Track                    [Page 99]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   [RANDOM]   Eastlake, D., 3rd, Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", [BCP 106](/doc/html/bcp106), [RFC 4086](/doc/html/rfc4086),
              June 2005.

   [RFC3749]  Hollenbeck, S., "Transport Layer Security Protocol
              Compression Methods", [RFC 3749](/doc/html/rfc3749), May 2004.

   [RFC4366]  Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,
              and T. Wright, "Transport Layer Security (TLS)
              Extensions", [RFC 4366](/doc/html/rfc4366), April 2006.

   [RSA]      R. Rivest, A. Shamir, and L. M. Adleman, "A Method for
              Obtaining Digital Signatures and Public-Key
              Cryptosystems", Communications of the ACM, v. 21, n. 2,
              Feb 1978, pp. 120-126.

   [SEQNUM]   Bellovin, S., "Defending Against Sequence Number Attacks",
              [RFC 1948](/doc/html/rfc1948), May 1996.

   [SSL2]     Hickman, Kipp, "The SSL Protocol", Netscape Communications
              Corp., Feb 9, 1995.

   [SSL3]     A. Freier, P. Karlton, and P. Kocher, "The SSL 3.0
              Protocol", Netscape Communications Corp., Nov 18, 1996.

   [SUBGROUP] Zuccherato, R., "Methods for Avoiding the "Small-Subgroup"
              Attacks on the Diffie-Hellman Key Agreement Method for
              S/MIME", [RFC 2785](/doc/html/rfc2785), March 2000.

   [TCP]      Postel, J., "Transmission Control Protocol", STD 7, [RFC](/doc/html/rfc793)
              [793](/doc/html/rfc793), September 1981.

   [TIMING]   Boneh, D., Brumley, D., "Remote timing attacks are
              practical", USENIX Security Symposium 2003.

   [TLSAES]   Chown, P., "Advanced Encryption Standard (AES)
              Ciphersuites for Transport Layer Security (TLS)", [RFC](/doc/html/rfc3268)
              [3268](/doc/html/rfc3268), June 2002.

   [TLSECC]   Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.
              Moeller, "Elliptic Curve Cryptography (ECC) Cipher Suites
              for Transport Layer Security (TLS)", [RFC 4492](/doc/html/rfc4492), May 2006.

   [TLSEXT]   Eastlake, D., 3rd, "Transport Layer Security (TLS)
              Extensions:  Extension Definitions", Work in Progress,
              February 2008.

Dierks & Rescorla           Standards Track                   [Page 100]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   [TLSPGP]   Mavrogiannopoulos, N., "Using OpenPGP Keys for Transport
              Layer Security (TLS) Authentication", [RFC 5081](/doc/html/rfc5081), November
              2007.

   [TLSPSK]   Eronen, P., Ed., and H. Tschofenig, Ed., "Pre-Shared Key
              Ciphersuites for Transport Layer Security (TLS)", [RFC](/doc/html/rfc4279)
              [4279](/doc/html/rfc4279), December 2005.

   [TLS1.0]   Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
              [RFC 2246](/doc/html/rfc2246), January 1999.

   [TLS1.1]   Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.1", [RFC 4346](/doc/html/rfc4346), April 2006.

   [X501]     ITU-T Recommendation X.501: Information Technology - Open
              Systems Interconnection - The Directory: Models, 1993.

   [XDR]      Eisler, M., Ed., "XDR: External Data Representation
              Standard", STD 67, [RFC 4506](/doc/html/rfc4506), May 2006.

Working Group Information

   The discussion list for the IETF TLS working group is located at the
   e-mail address <tls@ietf.org>. Information on the group and
   information on how to subscribe to the list is at
   <<https://www1.ietf.org/mailman/listinfo/tls>>

   Archives of the list can be found at:
   <<http://www.ietf.org/mail-archive/web/tls/current/index.html>>

Contributors

   Christopher Allen (co-editor of TLS 1.0)
   Alacrity Ventures
   ChristopherA@AlacrityManagement.com

   Martin Abadi
   University of California, Santa Cruz
   abadi@cs.ucsc.edu

   Steven M. Bellovin
   Columbia University
   smb@cs.columbia.edu

   Simon Blake-Wilson
   BCI
   sblakewilson@bcisse.com

Dierks & Rescorla           Standards Track                   [Page 101]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Ran Canetti
   IBM
   canetti@watson.ibm.com

   Pete Chown
   Skygate Technology Ltd
   pc@skygate.co.uk

   Taher Elgamal
   taher@securify.com
   Securify

   Pasi Eronen
   pasi.eronen@nokia.com
   Nokia

   Anil Gangolli
   anil@busybuddha.org

   Kipp Hickman

   Alfred Hoenes

   David Hopwood
   Independent Consultant
   david.hopwood@blueyonder.co.uk

   Phil Karlton (co-author of SSLv3)

   Paul Kocher (co-author of SSLv3)
   Cryptography Research
   paul@cryptography.com

   Hugo Krawczyk
   IBM
   hugo@ee.technion.ac.il

   Jan Mikkelsen
   Transactionware
   janm@transactionware.com

   Magnus Nystrom
   RSA Security
   magnus@rsasecurity.com

   Robert Relyea
   Netscape Communications
   relyea@netscape.com

Dierks & Rescorla           Standards Track                   [Page 102]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

   Jim Roskind
   Netscape Communications
   jar@netscape.com

   Michael Sabin

   Dan Simon
   Microsoft, Inc.
   dansimon@microsoft.com

   Tom Weinstein

   Tim Wright
   Vodafone
   timothy.wright@vodafone.com

Editors' Addresses

   Tim Dierks
   Independent
   EMail: tim@dierks.org

   Eric Rescorla
   RTFM, Inc.
   EMail: ekr@rtfm.com

Dierks & Rescorla           Standards Track                   [Page 103]
```

---

```

[RFC 5246](/doc/html/rfc5246)                          TLS                        August 2008

Full Copyright Statement

   Copyright (C) The IETF Trust (2008).

   This document is subject to the rights, licenses and restrictions
   contained in [BCP 78](/doc/html/bcp78), and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in [BCP 78](/doc/html/bcp78) and [BCP 79](/doc/html/bcp79).

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <http://www.ietf.org/ipr>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

Dierks & Rescorla           Standards Track                   [Page 104]

```

[Datatracker](/doc/rfc5246/)

RFC 5246

RFC
- Proposed Standard

* Info
* Contents
* Prefs

| Document | Document type |  | RFC - Proposed Standard  August 2008  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=5246 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") [IPR](/ipr/search/?submit=draft&id=rfc5246 "Click to view IPR declarations.") Obsoleted by [RFC 8446](/doc/html/rfc8446 "The Transport Layer Security (TLS) Protocol Version 1.3") Updated by [RFC 7627](/doc/html/rfc7627 "Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension"), [RFC 9155](/doc/html/rfc9155 "Deprecating MD5 and SHA-1 Signature Hashes in TLS 1.2 and DTLS 1.2"), [RFC 5878](/doc/html/rfc5878 "Transport Layer Security (TLS) Authorization Extensions"), [RFC 5746](/doc/html/rfc5746 "Transport Layer Security (TLS) Renegotiation Indication Extension"), [RFC 6176](/doc/html/rfc6176 "Prohibiting Secure Sockets Layer (SSL) Version 2.0"), [RFC 7465](/doc/html/rfc7465 "Prohibiting RC4 Cipher Suites"), [RFC 7507](/doc/html/rfc7507 "TLS Fallback Signaling Cipher Suite Value (SCSV) for Preventing Protocol Downgrade Attacks"), [RFC 7568](/doc/html/rfc7568 "Deprecating Secure Sockets Layer Version 3.0"), [RFC 7685](/doc/html/rfc7685 "A Transport Layer Security (TLS) ClientHello Padding Extension"), [RFC 7905](/doc/html/rfc7905 "ChaCha20-Poly1305 Cipher Suites for Transport Layer Security (TLS)"), [RFC 7919](/doc/html/rfc7919 "Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)"), [RFC 8447](/doc/html/rfc8447 "IANA Registry Updates for TLS and DTLS") Obsoletes [RFC 4346](/doc/html/rfc4346 "The Transport Layer Security (TLS) Protocol Version 1.1"), [RFC 4366](/doc/html/rfc4366 "Transport Layer Security (TLS) Extensions"), [RFC 3268](/doc/html/rfc3268 "Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)") Updates [RFC 4492](/doc/html/rfc4492 "Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)") Was [draft-ietf-tls-rfc4346-bis](/doc/draft-ietf-tls-rfc4346-bis/10/) ([tls WG](/wg/tls/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [10](/doc/html/draft-ietf-tls-rfc4346-bis-10) * [RFC 5246](/doc/html/rfc5246) |
|  | Compare versions |  | RFC 5246  draft-ietf-tls-rfc4346-bis-10  draft-ietf-tls-rfc4346-bis-09  draft-ietf-tls-rfc4346-bis-08  draft-ietf-tls-rfc4346-bis-07  draft-ietf-tls-rfc4346-bis-06  draft-ietf-tls-rfc4346-bis-05  draft-ietf-tls-rfc4346-bis-04  draft-ietf-tls-rfc4346-bis-03  draft-ietf-tls-rfc4346-bis-02  draft-ietf-tls-rfc4346-bis-01  draft-ietf-tls-rfc4346-bis-00   RFC 5246  draft-ietf-tls-rfc4346-bis-10  draft-ietf-tls-rfc4346-bis-09  draft-ietf-tls-rfc4346-bis-08  draft-ietf-tls-rfc4346-bis-07  draft-ietf-tls-rfc4346-bis-06  draft-ietf-tls-rfc4346-bis-05  draft-ietf-tls-rfc4346-bis-04  draft-ietf-tls-rfc4346-bis-03  draft-ietf-tls-rfc4346-bis-02  draft-ietf-tls-rfc4346-bis-01  draft-ietf-tls-rfc4346-bis-00   Side-by-side  Inline |
|  | Authors |  | [Eric Rescorla](/person/ekr%40rtfm.com "Datatracker profile of Eric Rescorla") , [Tim Dierks](/person/tim%40dierks.org "Datatracker profile of Tim Dierks")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc5246.txt) [html](https://www.rfc-editor.org/rfc/rfc5246.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc5246.txt.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc5246.html) [bibtex](/doc/rfc5246/bibtex/) |
|  | Additional resources |  | [Mailing list discussion](https://mailarchive.ietf.org/arch/browse/tls/?q=rfc5246 OR %22draft-ietf-tls-rfc4346-bis%22) |

[Report a datatracker bug](https://github.com/ietf-tools/datatracker/issues/new/choose)

Show sidebar by default

Yes

No

Tab to show by default

Info

Contents

HTMLization configuration

HTMLize the plaintext

Plaintextify the HTML

Maximum font size

Page dependencies

Inline

Reference

Citation links

 Go to reference section

Go to linked document

![](//analytics.ietf.org/piwik.php?idsite=7)



=== Content from cert-portal.siemens.com_060c4425_20250125_034341.html ===
Siemens Security Advisory by Siemens ProductCERT

SSA-556833: TLS Vulnerabilities in SIMATIC RF6XXR

Publication Date:
Last Update:
Current Version:
CVSS v3.0 Base Score: 5.9

2019-07-09
2019-07-09
V1.0

SUMMARY

The latest update for SIMATIC RF6XXR ﬁxes multiple vulnerabilities related to outdated TLS versions
that are still supported by the product.

Siemens has released a ﬁxed version for the SIMATIC RF6XXR and recommends updating.

AFFECTED PRODUCTS AND SOLUTION

Affected Product and Versions

Remediation

SIMATIC RF615R:
All versions < V3.2.1

SIMATIC RF68XR:
All versions < V3.2.1

Update to V3.2.1
https://support.industry.siemens.com/cs/ww/en/
view/109768501

Update to V3.2.1
https://support.industry.siemens.com/cs/ww/en/
view/109768501

WORKAROUNDS AND MITIGATIONS

Siemens has identiﬁed the following speciﬁc workarounds and mitigations that customers can apply to
reduce the risk:

• Restrict network access to the device to the extent possible

GENERAL SECURITY RECOMMENDATIONS

As a general security measure, Siemens strongly recommends to protect network access to devices
with appropriate mechanisms. In order to operate the devices in a protected IT environment, Siemens
recommends to conﬁgure the environment according to Siemens’ operational guidelines for Industrial
Security (Download: https://www.siemens.com/cert/operational-guidelines-industrial-security), and to
follow the recommendations in the product manuals.

Additional information on Industrial Security by Siemens can be found at: https://www.siemens.com/
industrialsecurity

PRODUCT DESCRIPTION

SIMATIC RF600 Readers are used for the contactless identiﬁcation of every kind of object, e.g. transport
containers, pallets, production goods, or it can be generally used for recording goods in bulk.

SSA-556833

© Siemens AG 2019

Page 1 of 3

Siemens Security Advisory by Siemens ProductCERT

VULNERABILITY CLASSIFICATION

The vulnerability classiﬁcation has been performed by using the CVSS scoring system in version 3.0
(CVSS v3.0) (https://www.ﬁrst.org/cvss/). The CVSS environmental score is speciﬁc to the customer’s
environment and will impact the overall CVSS score. The environmental score should therefore be
individually deﬁned by the customer to accomplish ﬁnal scoring.

Vulnerability CVE-2011-3389

The SSL protocol encrypts data by using CBC mode with chained initialization vectors, which allows
man-in-the-middle attackers to obtain plaintext HTTP headers via a blockwise chosen-boundary
attack (BCBA) on an HTTPS session, in conjunction with JavaScript code that uses e.g. the HTML5
WebSocket API, the Java URLConnection API, or the Silverlight WebClient API, aka a “BEAST” attack.

The security vulnerability could be exploited by an attacker with network access to the affected systems.
Successful exploitation requires no system privileges and no user interaction. An attacker could use
the vulnerability to compromise conﬁdentiality of the device.

CVSS v3.0 Base Score
CVSS Vector

5.9
CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N/E:P/RL:O/RC:C

Vulnerability CVE-2016-6329

TLS, when used with a 64-bit block cipher, could allow remote attackers to obtain cleartext data by
leveraging a birthday attack against a long-duration encrypted session, aka a “Sweet32” attack.

The security vulnerability could be exploited by an attacker with network access to the affected systems.
Successful exploitation requires no system privileges and no user interaction. An attacker could use
the vulnerability to compromise conﬁdentiality of the device.

CVSS v3.0 Base Score
CVSS Vector

5.9
CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N/E:P/RL:O/RC:C

Vulnerability CVE-2013-0169

TLS and DTLS versions 1.1 and 1.2, as used in the affected product, do not properly consider timing
side-channel attacks on a MAC check requirement during the processing of malformed CBC padding,
which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via
statistical analysis of timing data for crafted packets, aka the “Lucky Thirteen” issue.

The security vulnerability could be exploited by an attacker with network access to the affected systems.
Successful exploitation requires no system privileges and no user interaction. An attacker could use
the vulnerability to compromise conﬁdentiality of the device.

CVSS v3.0 Base Score
CVSS Vector

5.9
CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N/E:P/RL:O/RC:C

ACKNOWLEDGMENTS

Siemens thanks the following parties for their efforts:

• Wendy Parrington from United Utilities for coordinated disclosure

SSA-556833

© Siemens AG 2019

Page 2 of 3

Siemens Security Advisory by Siemens ProductCERT

ADDITIONAL INFORMATION

For further inquiries on security vulnerabilities in Siemens products and solutions, please contact the
Siemens ProductCERT:

https://www.siemens.com/cert/advisories

HISTORY DATA

V1.0 (2019-07-09):

Publication Date

TERMS OF USE

Siemens Security Advisories are subject to the terms and conditions contained in Siemens’ underlying
license terms or other applicable agreements previously agreed to with Siemens (hereinafter "License
Terms"). To the extent applicable to information, software or documentation made available in or through
a Siemens Security Advisory, the Terms of Use of Siemens’ Global Website (https://www.siemens.com/
terms_of_use, hereinafter "Terms of Use"), in particular Sections 8-10 of the Terms of Use, shall apply
additionally. In case of conﬂicts, the License Terms shall prevail over the Terms of Use.

SSA-556833

© Siemens AG 2019

Page 3 of 3



=== Content from openvpn.net_adfade77_20250126_054628.html ===
NEW[Webinar: Using IPsec for Secure Networking](https://hs.openvpn.net/simplifying-secure-networking-with-ipsec-webinar-registration)[Community](https://openvpn.net/community/)[Support](https://support.openvpn.com/)[Log In](https://openvpn.net/sign-in/)

---

[![OpenVPN Logo](/_next/static/media/open-vpn-logo.238dc4d9.svg)](/)

* Products
* Solutions
* Resources
* Partners
[Apps](https://openvpn.net/vpn-client/)[Pricing](https://openvpn.net/pricing/)[Request a Demo](https://hs.openvpn.net/request-demo)[Get Started for Free](https://openvpn.net/product-select/)NEW[Webinar: Using IPsec for Secure Networking](https://hs.openvpn.net/simplifying-secure-networking-with-ipsec-webinar-registration)[![OpenVPN Logo](/_next/static/media/open-vpn-logo.238dc4d9.svg)](/)
# Deliver **secure access** to your hybrid workforce

Give your teams the freedom to work securely anywhere with [private access](https://openvpn.net/solutions/use-cases/enforcing-zero-trust/), [secure web access](https://openvpn.net/solutions/use-cases/secure-internet-access/), and [SaaS protection](https://openvpn.net/solutions/use-cases/protecting-access-to-saas/) from OpenVPN.

[Get Started for Free](https://openvpn.net/product-select/)![Secure Access](/_next/static/media/hero.75999374.webp)

Trusted by nearly 20,000 customers worldwide, and all major cloud providers.

![Oracle logo](/_next/static/media/oracle.0caa6a0b.svg)![Google Cloud logo](/_next/static/media/gcloud.80c0c462.svg)![AWS logo](/_next/static/media/aws.ac43b6b7.svg)![Azure logo](/_next/static/media/azure.5539b47c.svg)![Digital Ocean logo](/_next/static/media/docean.b892ddb2.svg)
## Private Access

Your hybrid workforce needs secure access to private resources, regardless of location or if the application is hosted on-prem or in the cloud.

[Learn more](https://openvpn.net/solutions/use-cases/enforcing-zero-trust/)![icon](/_next/static/media/Private_Access.1c530a8c.webp)
## Secure Web Access

OpenVPN provides secure web access without a proxy web server, blocks access to undesirable content, and can route all internet traffic to third-party secure internet gateways for deep-packet inspection.

[Learn more](https://openvpn.net/solutions/use-cases/secure-internet-access/)![icon](/_next/static/media/Internet_Access.486cc2d5.webp)
## SaaS Protection

OpenVPNâs secure networking solutions isolate your SaaS applications from internet accessâexcept for your authorized employees.

[Learn more](https://openvpn.net/solutions/use-cases/protecting-access-to-saas/)![icon](/_next/static/media/SaaS_Protection.dd3e1cb1.webp)![Icon Lock](/_next/static/media/icon-lock.5b06ce62.svg)

Deliver secure
remote access anywhere

Whether youâre trying to access private resources, SaaS apps, or the internet â OpenVPN delivers remote access easily and securely.

[Learn About Secure Remote Access](https://openvpn.net/solutions/use-cases/secure-remote-access/)![Icon Cloud with Lock](/_next/static/media/icon-cloud-lock.c86a7c27.svg)

Seamlessly transition from
perimeter-based to zero trust access

Transitioning to ZTNA isnât something that happens overnight â OpenVPN can support you wherever you are in your security evolution.

[Read About Enforcing Zero Trust](https://openvpn.net/solutions/use-cases/enforcing-zero-trust/)![Icon Money](/_next/static/media/icon-money.caacff4a.svg)

Cost-effectively
reduce your attack surface

Protect critical apps in private networks with identity-based access for authorized devices and users. Reduce your attack surface using secure, transparent OpenVPN protocol.

[Compare Pricing](https://openvpn.net/pricing/)
## Network security is in a **new era**.

Hybrid workforces, workloads moving to the cloud, the growth in SaaS, and apps distributed in multiple environments. The complexity that your security, IT, and network teams are facing is off the charts. Luckily, the answer doesnât have to be complicated.
OpenVPN is here to bring simple, flexible, and cost-effective secure remote access to companies of all sizes, regardless of where their resources are located.

Cloud-delivered and self-hosted solutions

Choose based on your business criteria. Both options are available for the same price from the company you trust.

[Compare Our Products](https://openvpn.net/product-comparison/)

Network access with built-in security

Remote access should not provide access to the entire network. Implement network segmentation, role and attribute-based access control, device identity checks, IDS/IPS, and Secure Web Gateway (SWG) without additional costs.

[Read More Product Features](https://openvpn.net/product-comparison/)

Cost-effective pricing

Your hybrid workforce is only sometimes remote. Our economical pricing model allows you to pay only for the number of connections you use for increased saving.

[Get Started Today](https://openvpn.net/pricing/)

On-demand scalability and simplified management

Our offerings prioritize ease of use and scalability for your users, while providing centralized configuration, visibility, and management. Features include the ability to import connection configuration profiles through a URL, route based on application domain names, and more.

[Check Out an Interactive Demo](https://openvpn.navattic.com/xc9o01il)
## Two Secure Networking Solutions. **Which is right for you?**

![Access Server Logo](/_next/static/media/access-server.4804fa0c.svg)

Self-hosted secure access solution giving you more control over your network security. **Get started with 2 free connections.**

---

Choose Access Server if you want to:

* ![asListIcon0](/_next/static/media/as-list-icon-0.ce6029f3.svg)Have complete control over the solutionâs [deployment, configuration, and management](https://openvpn.net/as-docs/general.html).
* ![asListIcon1](/_next/static/media/as-list-icon-1.de8d6b09.svg)Always have the tunnel terminate on networks that you own and control to ensure the data traffic stays in your domain of control.
[Get Started for Free](https://myaccount.openvpn.com/signup/as)![CloudConnexa Logo](/_next/static/media/cloud-connexa.0285d31c.svg)

Cloud-delivered service to connect private networks, devices and servers. **Get started with 3 free connections.**

---

Choose CloudConnexa if you want to:

* ![ccListIcon0](/_next/static/media/cc-list-icon-0.0c7a50f0.svg)Share the responsibility of maintaining the virtual [network](https://openvpn.net/cloud-docs/owner/networks/networks---networks/about-networks.html#related-documents-146403) with [OpenVPN Inc.](https://openvpn.net/about/) provides the cloud-based virtual networking platform, with built-in security functions, offered as a service from its various worldwide data centers and you are responsible for the connections to it.
[Get Started for Free](https://myaccount.openvpn.com/signup/cc)Or compare the two products to see whatâs right for you.[Compare the Products](https://openvpn.net/product-comparison/)
## How do I use OpenVPN for remote access?

1. with Access Server
2. with CloudConnexaâ¢
Signup![Signup](/_next/static/media/006_1_Signup.72218110.svg)Get Access Server for your
deployment type![](/_next/static/media/arrow-desktop.fa079b74.svg)![](/_next/static/media/arrow-mobile.a82561b4.svg)Install on
your network![Install on
your network](/_next/static/media/006_2_Install.6f2fcf23.svg)Install client and import
profile![](/_next/static/media/arrow-desktop.fa079b74.svg)![](/_next/static/media/arrow-mobile.a82561b4.svg)Connect to
Access Server![Connect to
Access Server](/_next/static/media/006_3_Connect-AS.ffdbbd56.svg)Access private
applications![](/_next/static/media/arrow-desktop.fa079b74.svg)![](/_next/static/media/arrow-mobile.a82561b4.svg)Add more users and
configure access control![Add more users and
configure access control](/_next/static/media/006_4_Add Users.f3bdda4b.svg)[Get Started with Access Server](https://openvpn.net/access-server/)
## See what nearly 20,000 customers, hundreds of partners, and all major cloud providers already know.

1. ![Jason K.](/_next/static/media/jason-k.40bb4f9b.png)Jason K. REPAYEasy to configure options, add users, and that it has two factor authentication built in. You can configure the system to allow connections on common ports so that you're able to connect from pretty much anywhere in the world.
2. ![Johnathan B.](/_next/static/media/johnathan-b.927c0bd7.png)Johnathan B. Surry TelephoneConfiguring and updating my own server is super simple. In my experience, I've always had some difficulty setting up hardware VPN appliances, but OpenVPN was no-nonsense.
3. ![Alex H.](/_next/static/media/alex-h.c1aa6220.png)Alex H. DGDeanThe OpenVPN Access Server AMI is a great out of the box VPN solution for your AWS VPC...
4. ![John G.](/_next/static/media/john-g.30d4df7e.png)John G. Anovys, LLCOpenVPN offers users a very simple and secure VPN option that is both economical and quick to install. Users are able to easily install it on their client devices.
5. ![Jeremy F.](/_next/static/media/jeremy-f.3e07c1f1.png)Jeremy F. Intelligent PathwaysThe availability of client software for all operating systems and mobile devices means my customers can connect regardless of their setup.
6. ![Josh Wc.](/_next/static/media/josh-w.91de050c.png)Josh Wc. nexgen|packaging, LLCExcellent, flexible solution for our Azure environment.

VPN Client

## OpenVPN Connect

Download our free and full-featured VPN client to connect to CloudConnexaÂ®, Access Server, or any OpenVPN protocol compatible server.[Download for Windows](https://openvpn.net/downloads/openvpn-connect-v3-windows.msi)![Connect Stats screenshot](/_next/static/media/connect.69e86815.svg)
## Word on the Street.

News and insights from the OpenVPN team.BlogGet expert insights, network security news, and product updates.[Read](https://blog.openvpn.net)EventsSee where OpenVPN has been recently, and the events weâre going to in the future.[Connect with Us](https://blog.openvpn.net/tag/events)Customer StoriesSee real-world results from some of the thousands of OpenVPN customers.[Explore](https://blog.openvpn.net/tag/customer-success-stories)Get started â
no credit card required.Our Technical Support team is available 24/7 to guide you through every step of set-up and configuration. But we doubt youâll need us.[Create Your Account](https://openvpn.net/product-select/)![Get started with OpenVPN](/_next/static/media/footer.2ffc804e.webp)[Access Server](https://openvpn.net/access-server)[Plugins](https://openvpn.net/access-server/plugins)[Release Notes](https://openvpn.net/vpn-server-resources/release-notes)[Documentation](https://openvpn.net/vpn-server-resources)[CloudConnexaÂ®](https://openvpn.net/cloud-vpn)[Features](https://openvpn.net/cloud-vpn/features)[Cyber Shield](https://openvpn.net/cloud-vpn/cyber-shield)[Quick Start Guide](https://openvpn.net/cloud-vpn/quick-start)[Documentation](https://openvpn.net/cloud-docs)[Company](https://openvpn.net/about)[About Us](https://openvpn.net/about)[Careers](https://openvpn.net/about/careers)[Newsroom](https://openvpn.net/about/media)[Compliance](https://openvpn.net/openvpn-compliance)[Contact](https://openvpn.net/contact)[Resources](https://openvpn.net/resource-center)[Support Center](https://support.openvpn.com/hc/en-us)[What is a VPN?](https://openvpn.net/what-is-a-vpn)[Resource Center](https://openvpn.net/resource-center)[OpenVPN Referral Program](https://affiliate.openvpn.com/signup/27008)[Use Cases](https://openvpn.net/solutions/use-cases/)[Secure Remote Access](https://openvpn.net/solutions/use-cases/secure-remote-access/)[Secure IoT Communications](https://openvpn.net/solutions/use-cases/iot-communications/)[Protect Access to SaaS Apps](https://openvpn.net/solutions/use-cases/protecting-access-to-saas/)[Site-to-Site Networking](https://openvpn.net/solutions/use-cases/site-to-site-networking/)[Enforce Zero Trust Access](https://openvpn.net/solutions/use-cases/enforcing-zero-trust/)[Secure DNS](https://openvpn.net/solutions/use-cases/secure-dns/)[Restrict Internet Access](https://openvpn.net/solutions/use-cases/restricted-internet-access/)![OpenVPN Logo](/_next/static/media/logo.5522c686.svg)[Service Status](https://status.openvpn.com/)

---

[Privacy Policy](https://openvpn.net/privacy-policy)[Legal](https://openvpn.net/legal)Your Privacy SettingsÂ© Copyright 2025 OpenVPN | OpenVPN is a registered trademark of OpenVPN, Inc. | CloudConnexa is a registered trademark of OpenVPN, Inc.![](https://www.facebook.com/tr?id=6402664643185987&ev=PageView&noscript=1)

=== Content from www-01.ibm.com_5f9062b0_20250125_034340.html ===


[IBM Support](https://www.ibm.com/mysupport/)

##

No results were found for your search query.

---

##### **Tips**

To return expected results, you can:

* **Reduce the number of search terms.** Each term you use focuses the search further.
* **Check your spelling.** A single misspelled or incorrectly typed term can change your result.
* **Try substituting synonyms for your original terms.** For example, instead of searching for "java classes", try "java training"
* **Did you search for an IBM acquired or sold product ?** If so, follow the appropriate link below to find the content you need.

Our apologies

Search results are not available at this time. Please try again later or use one of the other support options on this page.

# Security Bulletin: OpenSSL and OpenVPN vulnerabilities affect IBM Rational Team Concert (CVE-2016-2183, CVE-2016-6329)

### Security Bulletin

## Summary

OpenSSL and OpenVPN vulnerabilities affect IBM Rational Team Concert. OpenSSL and OpenVPN are used by Rational BuildForge Agent shipped with IBM Rational Team Concert.

## Vulnerability Details

**CVEID:** [CVE-2016-2183](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-2183) OpenSSL could allow a remote attacker to obtain sensitive information, caused by an error in the in the Triple-DES on 64-bit block cipher, used as a part of the SSL/TLS protocol. By capturing large amounts of encrypted traffic between the SSL/TLS server and the client, a remote attacker able to conduct a man-in-the-middle attack could exploit this vulnerability to recover the plaintext data and obtain sensitive information. This vulnerability is known as the SWEET32 Birthday attack.

CVSS Base Score: 3.7

CVSS Temporal Score: See <https://exchange.xforce.ibmcloud.com/vulnerabilities/116337> for the current score

CVSS Environmental Score\*: Undefined

CVSS Vector: (CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N)

**CVEID:** [CVE-2016-6329](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-6329) **DESCRIPTION:** OpenVPN could allow a remote attacker to obtain sensitive information, caused by an error in the in the Triple-DES on 64-bit block cipher, used as a part of the SSL/TLS protocol. By capturing large amounts of encrypted traffic between the SSL/TLS server and the client, a remote attacker able to conduct a man-in-the-middle attack could exploit this vulnerability to recover the plaintext data and obtain sensitive information. This vulnerability is known as the SWEET32 Birthday attack.

CVSS Base Score: 3.7

CVSS Temporal Score: See <https://exchange.xforce.ibmcloud.com/vulnerabilities/116341> for the current score

CVSS Environmental Score\*: Undefined

CVSS Vector: (CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N)

## Affected Products and Versions

Rational Team Concert 4.0 - 4.0.7

Rational Team Concert 5.0 - 5.0.2

Rational Team Concert 6.0 - 6.0.2

## Remediation/Fixes

The remediation for this Security issues is to disable triple-DES.

In the Build Forge Agent when triple-DES is enabled, it also enables SSL.

In order to disable triple-DES follow steps below:

1. Open bfagent.conf file, the file can be located at:

   *Windows default: C:\Program Files\IBM\Build Forge\Agent\BFAgent.conf

   UNIX and Linux default: /etc/bfagent.conf*

2. Add the following line in bfagent.conf after the line of "SSLProtocol": ***SSLCipherSuite ALL:!ADH:!aNULL:!eNULL:!LOW:!EXP:!RC4:!DES-CBC3:+HIGH:+MEDIUM***

Note: if the build forge agent is not using SSL, comment out this line.

## Workarounds and Mitigations

None

## Get Notified about Future Security Bulletins

Subscribe to [My Notifications](https://www.ibm.com/support/pages/node/718119) to be notified of important product support alerts like this.

## Important Note

IBM strongly suggests that all System z customers be subscribed to the System z Security Portal to receive the latest critical System z security and integrity service. If you are not subscribed, see the instructions on the [System z Security web site](http://www.ibm.com/systems/z/solutions/security_subintegrity.html). Security and integrity APARs and associated fixes will be posted to this portal. IBM suggests reviewing the CVSS scores and applying all security or integrity fixes as soon as possible to minimize any potential risk.

### References

[Complete CVSS v2 Guide](http://www.first.org/cvss/v2/guide "Link resides outside of ibm.com")

[On-line Calculator v2](http://nvd.nist.gov/CVSS-v2-Calculator "Link resides outside of ibm.com")

[Complete CVSS v3 Guide](http://www.first.org/cvss/user-guide "Link resides outside of ibm.com")

[On-line Calculator v3](http://www.first.org/cvss/calculator/3.0 "Link resides outside of ibm.com")

Off

## Related Information

[IBM Secure Engineering Web Portal](http://www.ibm.com/security/secure-engineering/bulletins.html)

[IBM Product Security Incident Response Blog](http://www.ibm.com/blogs/psirt)

## Change History

Initial Publication: 07 October 2016

\*The CVSS Environment Score is customer environment specific and will ultimately impact the Overall CVSS Score. Customers can evaluate the impact of this vulnerability in their environments by accessing the links in the Reference section of this Security Bulletin.

## Disclaimer

Review the [IBM security bulletin disclaimer and definitions](https://www.ibm.com/support/pages/node/6610583#disclaimer) regarding your responsibilities for assessing potential impact of security vulnerabilities to your environment.

[{"Product":{"code":"SSUC3U","label":"IBM Engineering Workflow Management"},"Business Unit":{"code":"BU059","label":"IBM Software w\/o TPS"},"Component":"General Information","Platform":[{"code":"PF002","label":"AIX"},{"code":"PF012","label":"IBM i"},{"code":"PF016","label":"Linux"},{"code":"PF027","label":"Solaris"},{"code":"PF033","label":"Windows"},{"code":"PF022","label":"OS X"}],"Version":"4.0;4.0.0.1;4.0.0.2;4.0.1;4.0.2;4.0.3;4.0.4;4.0.5;4.0.6;4.0.7;5.0;5.0.1;5.0.2;6.0;6.0.1;6.0.2","Edition":"","Line of Business":{"code":"LOB59","label":"Sustainability Software"}}]

## Product Synonym

Rational Team Concert

## Was this topic helpful?

### Document Information

**Modified date:**

17 June 2018

## UID

swg21991482

Page Feedback

## Share your feedback

### Need support?

* Submit feedback to IBM Support
* 1-800-IBM-7378 (**USA**)
* [Directory of worldwide contacts](//www.ibm.com/planetwide/index.html#region)



=== Content from security.gentoo.org_3bebe48b_20250125_034344.html ===

[![Gentoo](https://assets.gentoo.org/tyrian/v2/site-logo.png)](/ "Back to the homepage")
Security

[**Get Gentoo!**](https://get.gentoo.org/)
gentoo.org sites
[gentoo.org](https://www.gentoo.org/ "Main Gentoo website")
[Wiki](https://wiki.gentoo.org/ "Find and contribute documentation")
[Bugs](https://bugs.gentoo.org/ "Report issues and find common issues")
[Forums](https://forums.gentoo.org/ "Discuss with the community")
[Packages](https://packages.gentoo.org/ "Find software for your Gentoo")

[Planet](https://planet.gentoo.org/ "Find out what's going on in the developer community")
[Archives](https://archives.gentoo.org/ "Read up on past discussions")
[Sources](https://sources.gentoo.org/ "Browse our source code")

[Infra Status](https://infra-status.gentoo.org/ "Get updates on the services provided by Gentoo")

* [Home](/)
* [Stay informed](/subscribe)
* [Advisories](/glsa)

# OpenVPN: Multiple vulnerabilities — GLSA **201611-02**

Multiple vulnerabilities have been found in OpenVPN, the worst of
which allows remote attackers to read encrypted traffic.

### Affected packages

| Package | **net-misc/openvpn** on all architectures |
| --- | --- |
| Affected versions | < **2.3.12** |
| Unaffected versions | >= **2.3.12** |

### Background

OpenVPN is a multi-platform, full-featured SSL VPN solution.

### Description

Multiple vulnerabilities have been discovered in OpenVPN. Please review
the CVE identifiers referenced below for details.

### Impact

A remote attacker may be able to recover plaintext from encrypted
communications.

### Workaround

There is no known workaround at this time.

### Resolution

All OpenVPN users should upgrade to the latest version:

```
 # emerge --sync
 # emerge --ask --oneshot --verbose ">=net-misc/openvpn-2.3.12"

```
### References

* [CVE-2016-6329](https://nvd.nist.gov/nvd.cfm?cvename=CVE-2016-6329)

**Release date**

November 01, 2016

**Latest revision**

November 01, 2016: 1

**Severity**

normal

**Exploitable**

remote

**Bugzilla entries**

* [582902](https://bugs.gentoo.org/show_bug.cgi?id=582902)
* [592070](https://bugs.gentoo.org/show_bug.cgi?id=592070)

### Questions or comments?

Please feel free to contact us.

**© 2001–2020 Gentoo Foundation, Inc.**


