=== Content from github.com_543ebe0c_20250125_195137.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpuiterwijk%2Fflask-oidc%2Fblob%2Fmaster%2Fflask_oidc%2F__init__.py)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpuiterwijk%2Fflask-oidc%2Fblob%2Fmaster%2Fflask_oidc%2F__init__.py)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=puiterwijk%2Fflask-oidc)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[puiterwijk](/puiterwijk)
/
**[flask-oidc](/puiterwijk/flask-oidc)**
Public

* [Notifications](/login?return_to=%2Fpuiterwijk%2Fflask-oidc) You must be signed in to change notification settings
* [Fork
  217](/login?return_to=%2Fpuiterwijk%2Fflask-oidc)
* [Star
   159](/login?return_to=%2Fpuiterwijk%2Fflask-oidc)

* [Code](/puiterwijk/flask-oidc)
* [Issues
  57](/puiterwijk/flask-oidc/issues)
* [Pull requests
  21](/puiterwijk/flask-oidc/pulls)
* [Actions](/puiterwijk/flask-oidc/actions)
* [Projects
  0](/puiterwijk/flask-oidc/projects)
* [Wiki](/puiterwijk/flask-oidc/wiki)
* [Security](/puiterwijk/flask-oidc/security)
* [Insights](/puiterwijk/flask-oidc/pulse)

Additional navigation options

* [Code](/puiterwijk/flask-oidc)
* [Issues](/puiterwijk/flask-oidc/issues)
* [Pull requests](/puiterwijk/flask-oidc/pulls)
* [Actions](/puiterwijk/flask-oidc/actions)
* [Projects](/puiterwijk/flask-oidc/projects)
* [Wiki](/puiterwijk/flask-oidc/wiki)
* [Security](/puiterwijk/flask-oidc/security)
* [Insights](/puiterwijk/flask-oidc/pulse)

## Files

 master
## Breadcrumbs

1. [flask-oidc](/puiterwijk/flask-oidc/tree/master)
2. /[flask\_oidc](/puiterwijk/flask-oidc/tree/master/flask_oidc)
/
# \_\_init\_\_.py

Copy path Blame  Blame
## Latest commit

## History

[History](/puiterwijk/flask-oidc/commits/master/flask_oidc/__init__.py)926 lines (788 loc) · 35.4 KB master
## Breadcrumbs

1. [flask-oidc](/puiterwijk/flask-oidc/tree/master)
2. /[flask\_oidc](/puiterwijk/flask-oidc/tree/master/flask_oidc)
/
# \_\_init\_\_.py

Top
## File metadata and controls

* Code
* Blame

926 lines (788 loc) · 35.4 KB[Raw](https://github.com/puiterwijk/flask-oidc/raw/refs/heads/master/flask_oidc/__init__.py)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926# Copyright (c) 2014-2015, Erica Ehrhardt# Copyright (c) 2016, Patrick Uiterwijk <patrick@puiterwijk.org># All rights reserved.## Redistribution and use in source and binary forms, with or without# modification, are permitted provided that the following conditions are met:## \* Redistributions of source code must retain the above copyright notice, this# list of conditions and the following disclaimer.## \* Redistributions in binary form must reproduce the above copyright notice,# this list of conditions and the following disclaimer in the documentation# and/or other materials provided with the distribution.## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
from functools import wrapsimport osimport jsonfrom base64 import b64encode, b64decode, urlsafe\_b64encode, urlsafe\_b64decodeimport timefrom copy import copyimport loggingfrom warnings import warnimport calendar
from six.moves.urllib.parse import urlencodefrom flask import request, session, redirect, url\_for, g, current\_app, abortfrom oauth2client.client import flow\_from\_clientsecrets, OAuth2WebServerFlow,\ AccessTokenRefreshError, OAuth2Credentialsimport httplib2from itsdangerous import JSONWebSignatureSerializer, BadSignature
\_\_all\_\_ = ['OpenIDConnect', 'MemoryCredentials']
logger = logging.getLogger(\_\_name\_\_)
def \_json\_loads(content): if not isinstance(content, str): content = content.decode('utf-8') return json.loads(content)
class MemoryCredentials(dict): """ Non-persistent local credentials store. Use this if you only have one app server, and don't mind making everyone log in again after a restart. """ pass
class DummySecretsCache(object): """ oauth2client secrets cache """ def \_\_init\_\_(self, client\_secrets): self.client\_secrets = client\_secrets
 def get(self, filename, namespace): return self.client\_secrets
class ErrStr(str): """ This is a class to work around the time I made a terrible API decision.
 Basically, the validate\_token() function returns a boolean True if all went right, but a string with an error message if something went wrong.
 The problem here is that this means that "if validate\_token(...)" will always be True, even with an invalid token, and users had to do "if validate\_token(...) is True:".
 This is counter-intuitive, so let's "fix" this by returning instances of this ErrStr class, which are basic strings except for their bool() results: they return False. """ def \_\_nonzero\_\_(self): """The py2 method for bool().""" return False
 def \_\_bool\_\_(self): """The py3 method for bool().""" return False
GOOGLE\_ISSUERS = ['accounts.google.com', 'https://accounts.google.com']
class OpenIDConnect(object): """ The core OpenID Connect client object. """ def \_\_init\_\_(self, app=None, credentials\_store=None, http=None, time=None, urandom=None): self.credentials\_store = credentials\_store\ if credentials\_store is not None\ else MemoryCredentials()
 if http is not None: warn('HTTP argument is deprecated and unused', DeprecationWarning) if time is not None: warn('time argument is deprecated and unused', DeprecationWarning) if urandom is not None: warn('urandom argument is deprecated and unused', DeprecationWarning)
 # By default, we do not have a custom callback self.\_custom\_callback = None
 # get stuff from the app's config, which may override stuff set above if app is not None: self.init\_app(app)
 def init\_app(self, app): """ Do setup that requires a Flask app.
 :param app: The application to initialize. :type app: Flask """ secrets = self.load\_secrets(app) self.client\_secrets = list(secrets.values())[0] secrets\_cache = DummySecretsCache(secrets)
 # Set some default configuration options app.config.setdefault('OIDC\_SCOPES', ['openid', 'email']) app.config.setdefault('OIDC\_GOOGLE\_APPS\_DOMAIN', None) app.config.setdefault('OIDC\_ID\_TOKEN\_COOKIE\_NAME', 'oidc\_id\_token') app.config.setdefault('OIDC\_ID\_TOKEN\_COOKIE\_PATH', '/') app.config.setdefault('OIDC\_ID\_TOKEN\_COOKIE\_TTL', 7 \* 86400) # 7 days # should ONLY be turned off for local debugging app.config.setdefault('OIDC\_COOKIE\_SECURE', True) app.config.setdefault('OIDC\_VALID\_ISSUERS', (self.client\_secrets.get('issuer') or GOOGLE\_ISSUERS)) app.config.setdefault('OIDC\_CLOCK\_SKEW', 60) # 1 minute app.config.setdefault('OIDC\_REQUIRE\_VERIFIED\_EMAIL', False) app.config.setdefault('OIDC\_OPENID\_REALM', None) app.config.setdefault('OIDC\_USER\_INFO\_ENABLED', True) app.config.setdefault('OIDC\_CALLBACK\_ROUTE', '/oidc\_callback') app.config.setdefault('OVERWRITE\_REDIRECT\_URI', False) app.config.setdefault("OIDC\_EXTRA\_REQUEST\_AUTH\_PARAMS", {}) # Configuration for resource servers app.config.setdefault('OIDC\_RESOURCE\_SERVER\_ONLY', False) app.config.setdefault('OIDC\_RESOURCE\_CHECK\_AUD', False)
 # We use client\_secret\_post, because that's what the Google # oauth2client library defaults to app.config.setdefault('OIDC\_INTROSPECTION\_AUTH\_METHOD', 'client\_secret\_post') app.config.setdefault('OIDC\_TOKEN\_TYPE\_HINT', 'access\_token')
 if not 'openid' in app.config['OIDC\_SCOPES']: raise ValueError('The value "openid" must be in the OIDC\_SCOPES')
 # register callback route and cookie-setting decorator if not app.config['OIDC\_RESOURCE\_SERVER\_ONLY']: app.route(app.config['OIDC\_CALLBACK\_ROUTE'])(self.\_oidc\_callback) app.before\_request(self.\_before\_request) app.after\_request(self.\_after\_request)
 # Initialize oauth2client self.flow = flow\_from\_clientsecrets( app.config['OIDC\_CLIENT\_SECRETS'], scope=app.config['OIDC\_SCOPES'], cache=secrets\_cache) assert isinstance(self.flow, OAuth2WebServerFlow)
 # create signers using the Flask secret key self.extra\_data\_serializer = JSONWebSignatureSerializer( app.config['SECRET\_KEY'], salt='flask-oidc-extra-data') self.cookie\_serializer = JSONWebSignatureSerializer( app.config['SECRET\_KEY'], salt='flask-oidc-cookie')
 try: self.credentials\_store = app.config['OIDC\_CREDENTIALS\_STORE'] except KeyError: pass
 def load\_secrets(self, app): # Load client\_secrets.json to pre-initialize some configuration content = app.config['OIDC\_CLIENT\_SECRETS'] if isinstance(content, dict): return content else: return \_json\_loads(open(content, 'r').read())
 @property def user\_loggedin(self): """ Represents whether the user is currently logged in.
 Returns: bool: Whether the user is logged in with Flask-OIDC.
 .. versionadded:: 1.0 """ return g.oidc\_id\_token is not None
 def user\_getfield(self, field, access\_token=None): """ Request a single field of information about the user.
 :param field: The name of the field requested. :type field: str :returns: The value of the field. Depending on the type, this may be a string, list, dict, or something else. :rtype: object
 .. versionadded:: 1.0 """ info = self.user\_getinfo([field], access\_token) return info.get(field)
 def user\_getinfo(self, fields, access\_token=None): """ Request multiple fields of information about the user.
 :param fields: The names of the fields requested. :type fields: list :returns: The values of the current user for the fields requested. The keys are the field names, values are the values of the fields as indicated by the OpenID Provider. Note that fields that were not provided by the Provider are absent. :rtype: dict :raises Exception: If the user was not authenticated. Check this with user\_loggedin.
 .. versionadded:: 1.0 """ if g.oidc\_id\_token is None and access\_token is None: raise Exception('User was not authenticated') info = {} all\_info = None for field in fields: if access\_token is None and field in g.oidc\_id\_token: info[field] = g.oidc\_id\_token[field] elif current\_app.config['OIDC\_USER\_INFO\_ENABLED']: # This was not in the id\_token. Let's get user information if all\_info is None: all\_info = self.\_retrieve\_userinfo(access\_token) if all\_info is None: # To make sure we don't retry for every field all\_info = {} if field in all\_info: info[field] = all\_info[field] else: # We didn't get this information pass return info
 def get\_access\_token(self): """Method to return the current requests' access\_token.
 :returns: Access token or None :rtype: str
 .. versionadded:: 1.2 """ try: credentials = OAuth2Credentials.from\_json( self.credentials\_store[g.oidc\_id\_token['sub']]) return credentials.access\_token except KeyError: logger.debug("Expired ID token, credentials missing", exc\_info=True) return None
 def get\_refresh\_token(self): """Method to return the current requests' refresh\_token.
 :returns: Access token or None :rtype: str
 .. versionadded:: 1.2 """ try: credentials = OAuth2Credentials.from\_json( self.credentials\_store[g.oidc\_id\_token['sub']]) return credentials.refresh\_token except KeyError: logger.debug("Expired ID token, credentials missing", exc\_info=True) return None
 def \_retrieve\_userinfo(self, access\_token=None): """ Requests extra user information from the Provider's UserInfo and returns the result.
 :returns: The contents of the UserInfo endpoint. :rtype: dict """ if 'userinfo\_uri' not in self.client\_secrets: logger.debug('Userinfo uri not specified') raise AssertionError('UserInfo URI not specified')
 # Cache the info from this request if '\_oidc\_userinfo' in g: return g.\_oidc\_userinfo
 http = httplib2.Http() if access\_token is None: try: credentials = OAuth2Credentials.from\_json( self.credentials\_store[g.oidc\_id\_token['sub']]) except KeyError: logger.debug("Expired ID token, credentials missing", exc\_info=True) return None credentials.authorize(http) resp, content = http.request(self.client\_secrets['userinfo\_uri']) else: # We have been manually overriden with an access token resp, content = http.request( self.client\_secrets['userinfo\_uri'], "POST", body=urlencode({"access\_token": access\_token}), headers={'Content-Type': 'application/x-www-form-urlencoded'})
 logger.debug('Retrieved user info: %s' % content) info = \_json\_loads(content)
 g.\_oidc\_userinfo = info
 return info
 def get\_cookie\_id\_token(self): """ .. deprecated:: 1.0 Use :func:`user\_getinfo` instead. """ warn('You are using a deprecated function (get\_cookie\_id\_token). ' 'Please reconsider using this', DeprecationWarning) return self.\_get\_cookie\_id\_token()
 def \_get\_cookie\_id\_token(self): try: id\_token\_cookie = request.cookies.get(current\_app.config[ 'OIDC\_ID\_TOKEN\_COOKIE\_NAME']) if not id\_token\_cookie: # Do not error if we were unable to get the cookie. # The user can debug this themselves. return None return self.cookie\_serializer.loads(id\_token\_cookie) except SignatureExpired: logger.debug("Invalid ID token cookie", exc\_info=True) return None except BadSignature: logger.info("Signature invalid for ID token cookie", exc\_info=True) return None
 def set\_cookie\_id\_token(self, id\_token): """ .. deprecated:: 1.0 """ warn('You are using a deprecated function (set\_cookie\_id\_token). ' 'Please reconsider using this', DeprecationWarning) return self.\_set\_cookie\_id\_token(id\_token)
 def \_set\_cookie\_id\_token(self, id\_token): """ Cooperates with @after\_request to set a new ID token cookie. """ g.oidc\_id\_token = id\_token g.oidc\_id\_token\_dirty = True
 def \_after\_request(self, response): """ Set a new ID token cookie if the ID token has changed. """ # This means that if either the new or the old are False, we set # insecure cookies. # We don't define OIDC\_ID\_TOKEN\_COOKIE\_SECURE in init\_app, because we # don't want people to find it easily. cookie\_secure = (current\_app.config['OIDC\_COOKIE\_SECURE'] and current\_app.config.get('OIDC\_ID\_TOKEN\_COOKIE\_SECURE', True))
 if getattr(g, 'oidc\_id\_token\_dirty', False): if g.oidc\_id\_token: signed\_id\_token = self.cookie\_serializer.dumps(g.oidc\_id\_token) response.set\_cookie( current\_app.config['OIDC\_ID\_TOKEN\_COOKIE\_NAME'], signed\_id\_token, secure=cookie\_secure, httponly=True, max\_age=current\_app.config['OIDC\_ID\_TOKEN\_COOKIE\_TTL']) else: # This was a log out response.set\_cookie( current\_app.config['OIDC\_ID\_TOKEN\_COOKIE\_NAME'], '', path=current\_app.config['OIDC\_ID\_TOKEN\_COOKIE\_PATH'], secure=cookie\_secure, httponly=True, expires=0) return response
 def \_before\_request(self): g.oidc\_id\_token = None self.authenticate\_or\_redirect()
 def authenticate\_or\_redirect(self): """ Helper function suitable for @app.before\_request and @check. Sets g.oidc\_id\_token to the ID token if the user has successfully authenticated, else returns a redirect object so they can go try to authenticate.
 :returns: A redirect object, or None if the user is logged in. :rtype: Redirect
 .. deprecated:: 1.0 Use :func:`require\_login` instead. """ # the auth callback and error pages don't need user to be authenticated if request.endpoint in frozenset(['\_oidc\_callback', '\_oidc\_error']): return None
 # retrieve signed ID token cookie id\_token = self.\_get\_cookie\_id\_token() if id\_token is None: return self.redirect\_to\_auth\_server(request.url)
 # ID token expired # when Google is the IdP, this happens after one hour if time.time() >= id\_token['exp']: # get credentials from store try: credentials = OAuth2Credentials.from\_json( self.credentials\_store[id\_token['sub']]) except KeyError: logger.debug("Expired ID token, credentials missing", exc\_info=True) return self.redirect\_to\_auth\_server(request.url)
 # refresh and store credentials try: credentials.refresh(httplib2.Http()) if credentials.id\_token: id\_token = credentials.id\_token else: # It is not guaranteed that we will get a new ID Token on # refresh, so if we do not, let's just update the id token # expiry field and reuse the existing ID Token. if credentials.token\_expiry is None: logger.debug('Expired ID token, no new expiry. Falling' ' back to assuming 1 hour') id\_token['exp'] = time.time() + 3600 else: id\_token['exp'] = calendar.timegm( credentials.token\_expiry.timetuple()) self.credentials\_store[id\_token['sub']] = credentials.to\_json() self.\_set\_cookie\_id\_token(id\_token) except AccessTokenRefreshError: # Can't refresh. Wipe credentials and redirect user to IdP # for re-authentication. logger.debug("Expired ID token, can't refresh credentials", exc\_info=True) del self.credentials\_store[id\_token['sub']] return self.redirect\_to\_auth\_server(request.url)
 # make ID token available to views g.oidc\_id\_token = id\_token
 return None
 def require\_login(self, view\_func): """ Use this to decorate view functions that require a user to be logged in. If the user is not already logged in, they will be sent to the Provider to log in, after which they will be returned.
 .. versionadded:: 1.0 This was :func:`check` before. """ @wraps(view\_func) def decorated(\*args, \*\*kwargs): if g.oidc\_id\_token is None: return self.redirect\_to\_auth\_server(request.url) return view\_func(\*args, \*\*kwargs) return decorated # Backwards compatibility check = require\_login """ .. deprecated:: 1.0 Use :func:`require\_login` instead. """
 def require\_keycloak\_role(self, client, role): """ Function to check for a KeyCloak client role in JWT access token.
 This is intended to be replaced with a more generic 'require this value in token or claims' system, at which point backwards compatibility will be added.
 .. versionadded:: 1.5.0 """ def wrapper(view\_func): @wraps(view\_func) def decorated(\*args, \*\*kwargs): pre, tkn, post = self.get\_access\_token().split('.') access\_token = json.loads(b64decode(tkn)) if role in access\_token['resource\_access'][client]['roles']: return view\_func(\*args, \*\*kwargs) else: return abort(403) return decorated return wrapper
 def flow\_for\_request(self): """ .. deprecated:: 1.0 Use :func:`require\_login` instead. """ warn('You are using a deprecated function (flow\_for\_request). ' 'Please reconsider using this', DeprecationWarning) return self.\_flow\_for\_request()
 def \_flow\_for\_request(self): """ Build a flow with the correct absolute callback URL for this request. :return: """ flow = copy(self.flow) redirect\_uri = current\_app.config['OVERWRITE\_REDIRECT\_URI'] if not redirect\_uri: flow.redirect\_uri = url\_for('\_oidc\_callback', \_external=True) else: flow.redirect\_uri = redirect\_uri return flow
 def redirect\_to\_auth\_server(self, destination=None, customstate=None): """ Set a CSRF token in the session, and redirect to the IdP.
 :param destination: The page that the user was going to, before we noticed they weren't logged in. :type destination: Url to return the client to if a custom handler is not used. Not available with custom callback. :param customstate: The custom data passed via the ODIC state. Note that this only works with a custom\_callback, and this will ignore destination. :type customstate: Anything that can be serialized :returns: A redirect response to start the login process. :rtype: Flask Response
 .. deprecated:: 1.0 Use :func:`require\_login` instead. """ if not self.\_custom\_callback and customstate: raise ValueError('Custom State is only avilable with a custom ' 'handler') if 'oidc\_csrf\_token' not in session: csrf\_token = urlsafe\_b64encode(os.urandom(24)).decode('utf-8') session['oidc\_csrf\_token'] = csrf\_token state = { 'csrf\_token': session['oidc\_csrf\_token'], } statefield = 'destination' statevalue = destination if customstate is not None: statefield = 'custom' statevalue = customstate state[statefield] = self.extra\_data\_serializer.dumps( statevalue).decode('utf-8')
 extra\_params = { 'state': urlsafe\_b64encode(json.dumps(state).encode('utf-8')), } extra\_params.update(current\_app.config['OIDC\_EXTRA\_REQUEST\_AUTH\_PARAMS']) if current\_app.config['OIDC\_GOOGLE\_APPS\_DOMAIN']: extra\_params['hd'] = current\_app.config['OIDC\_GOOGLE\_APPS\_DOMAIN'] if current\_app.config['OIDC\_OPENID\_REALM']: extra\_params['openid.realm'] = current\_app.config[ 'OIDC\_OPENID\_REALM']
 flow = self.\_flow\_for\_request() auth\_url = '{url}&{extra\_params}'.format( url=flow.step1\_get\_authorize\_url(), extra\_params=urlencode(extra\_params)) # if the user has an ID token, it's invalid, or we wouldn't be here self.\_set\_cookie\_id\_token(None) return redirect(auth\_url)
 def \_is\_id\_token\_valid(self, id\_token): """ Check if `id\_token` is a current ID token for this application, was issued by the Apps domain we expected, and that the email address has been verified.
 @see: http://openid.net/specs/openid-connect-core-1\_0.html#IDTokenValidation """ if not id\_token: return False
 # step 2: check issuer if id\_token['iss'] not in current\_app.config['OIDC\_VALID\_ISSUERS']: logger.error('id\_token issued by non-trusted issuer: %s' % id\_token['iss']) return False
 if isinstance(id\_token['aud'], list): # step 3 for audience list if self.flow.client\_id not in id\_token['aud']: logger.error('We are not a valid audience') return False # step 4 if 'azp' not in id\_token and len(id\_token['aud']) > 1: logger.error('Multiple audiences and not authorized party') return False else: # step 3 for single audience if id\_token['aud'] != self.flow.client\_id: logger.error('We are not the audience') return False
 # step 5 if 'azp' in id\_token and id\_token['azp'] != self.flow.client\_id: logger.error('Authorized Party is not us') return False
 # step 6-8: TLS checked
 # step 9: check exp if int(time.time()) >= int(id\_token['exp']): logger.error('Token has expired') return False
 # step 10: check iat if id\_token['iat'] < (time.time() - current\_app.config['OIDC\_CLOCK\_SKEW']): logger.error('Token issued in the past') return False
 # (not required if using HTTPS?) step 11: check nonce
 # step 12-13: not requested acr or auth\_time, so not needed to test
 # additional steps specific to our usage if current\_app.config['OIDC\_GOOGLE\_APPS\_DOMAIN'] and \ id\_token.get('hd') != current\_app.config[ 'OIDC\_GOOGLE\_APPS\_DOMAIN']: logger.error('Invalid google apps domain') return False
 if not id\_token.get('email\_verified', False) and \ current\_app.config['OIDC\_REQUIRE\_VERIFIED\_EMAIL']: logger.error('Email not verified') return False
 return True
 WRONG\_GOOGLE\_APPS\_DOMAIN = 'WRONG\_GOOGLE\_APPS\_DOMAIN'
 def custom\_callback(self, view\_func): """ Wrapper function to use a custom callback. The custom OIDC callback will get the custom state field passed in with redirect\_to\_auth\_server. """ @wraps(view\_func) def decorated(\*args, \*\*kwargs): plainreturn, data = self.\_process\_callback('custom') if plainreturn: return data else: return view\_func(data, \*args, \*\*kwargs) self.\_custom\_callback = decorated return decorated
 def \_oidc\_callback(self): plainreturn, data = self.\_process\_callback('destination') if plainreturn: return data else: return redirect(data)
 def \_process\_callback(self, statefield): """ Exchange the auth code for actual credentials, then redirect to the originally requested page. """ # retrieve session and callback variables try: session\_csrf\_token = session.get('oidc\_csrf\_token')
 state = \_json\_loads(urlsafe\_b64decode(request.args['state'].encode('utf-8'))) csrf\_token = state['csrf\_token']
 code = request.args['code'] except (KeyError, ValueError): logger.debug("Can't retrieve CSRF token, state, or code", exc\_info=True) return True, self.\_oidc\_error()
 # check callback CSRF token passed to IdP # against session CSRF token held by user if csrf\_token != session\_csrf\_token: logger.debug("CSRF token mismatch") return True, self.\_oidc\_error()
 # make a request to IdP to exchange the auth code for OAuth credentials flow = self.\_flow\_for\_request() credentials = flow.step2\_exchange(code) id\_token = credentials.id\_token if not self.\_is\_id\_token\_valid(id\_token): logger.debug("Invalid ID token") if id\_token.get('hd') != current\_app.config[ 'OIDC\_GOOGLE\_APPS\_DOMAIN']: return True, self.\_oidc\_error( "You must log in with an account from the {0} domain." .format(current\_app.config['OIDC\_GOOGLE\_APPS\_DOMAIN']), self.WRONG\_GOOGLE\_APPS\_DOMAIN) return True, self.\_oidc\_error()
 # store credentials by subject # when Google is the IdP, the subject is their G+ account number self.credentials\_store[id\_token['sub']] = credentials.to\_json()
 # Retrieve the extra statefield data try: response = self.extra\_data\_serializer.loads(state[statefield]) except BadSignature: logger.error('State field was invalid') return True, self.\_oidc\_error()
 # set a persistent signed cookie containing the ID token # and redirect to the final destination self.\_set\_cookie\_id\_token(id\_token) return False, response
 def \_oidc\_error(self, message='Not Authorized', code=None): return (message, 401, { 'Content-Type': 'text/plain', })
 def logout(self): """ Request the browser to please forget the cookie we set, to clear the current session.
 Note that as described in [1], this will not log out in the case of a browser that doesn't clear cookies when requested to, and the user could be automatically logged in when they hit any authenticated endpoint.
 [1]: https://github.com/puiterwijk/flask-oidc/issues/5#issuecomment-86187023
 .. versionadded:: 1.0 """ # TODO: Add single logout self.\_set\_cookie\_id\_token(None)
 # Below here is for resource servers to validate tokens def validate\_token(self, token, scopes\_required=None): """ This function can be used to validate tokens.
 Note that this only works if a token introspection url is configured, as that URL will be queried for the validity and scopes of a token.
 :param scopes\_required: List of scopes that are required to be granted by the token before returning True. :type scopes\_required: list
 :returns: True if the token was valid and contained the required scopes. An ErrStr (subclass of string for which bool() is False) if an error occured. :rtype: Boolean or String
 .. versionadded:: 1.1 """ valid = self.\_validate\_token(token, scopes\_required) if valid is True: return True else: return ErrStr(valid)
 def \_validate\_token(self, token, scopes\_required=None): """The actual implementation of validate\_token.""" if scopes\_required is None: scopes\_required = [] scopes\_required = set(scopes\_required)
 token\_info = None valid\_token = False has\_required\_scopes = False if token: try: token\_info = self.\_get\_token\_info(token) except Exception as ex: token\_info = {'active': False} logger.error('ERROR: Unable to get token info') logger.error(str(ex))
 valid\_token = token\_info.get('active', False)
 if 'aud' in token\_info and \ current\_app.config['OIDC\_RESOURCE\_CHECK\_AUD']: valid\_audience = False aud = token\_info['aud'] clid = self.client\_secrets['client\_id'] if isinstance(aud, list): valid\_audience = clid in aud else: valid\_audience = clid == aud
 if not valid\_audience: logger.error('Refused token because of invalid ' 'audience') valid\_token = False
 if valid\_token: token\_scopes = token\_info.get('scope', '').split(' ') else: token\_scopes = [] has\_required\_scopes = scopes\_required.issubset( set(token\_scopes))
 if not has\_required\_scopes: logger.debug('Token missed required scopes')
 if (valid\_token and has\_required\_scopes): g.oidc\_token\_info = token\_info return True
 if not valid\_token: return 'Token required but invalid' elif not has\_required\_scopes: return 'Token does not have required scopes' else: return 'Something went wrong checking your token'
 def accept\_token(self, require\_token=False, scopes\_required=None, render\_errors=True): """ Use this to decorate view functions that should accept OAuth2 tokens, this will most likely apply to API functions.
 Tokens are accepted as part of the query URL (access\_token value) or a POST form value (access\_token).
 Note that this only works if a token introspection url is configured, as that URL will be queried for the validity and scopes of a token.
 :param require\_token: Whether a token is required for the current function. If this is True, we will abort the request if there was no token provided. :type require\_token: bool :param scopes\_required: List of scopes that are required to be granted by the token before being allowed to call the protected function. :type scopes\_required: list :param render\_errors: Whether or not to eagerly render error objects as JSON API responses. Set to False to pass the error object back unmodified for later rendering. :type render\_errors: callback(obj) or None
 .. versionadded:: 1.0 """
 def wrapper(view\_func): @wraps(view\_func) def decorated(\*args, \*\*kwargs): token = None if 'Authorization' in request.headers and request.headers['Authorization'].startswith('Bearer '): token = request.headers['Authorization'].split(None,1)[1].strip() if 'access\_token' in request.form: token = request.form['access\_token'] elif 'access\_token' in request.args: token = request.args['access\_token']
 validity = self.validate\_token(token, scopes\_required) if (validity is True) or (not require\_token): return view\_func(\*args, \*\*kwargs) else: response\_body = {'error': 'invalid\_token', 'error\_description': validity} if render\_errors: response\_body = json.dumps(response\_body) return response\_body, 401, {'WWW-Authenticate': 'Bearer'}
 return decorated return wrapper
 def \_get\_token\_info(self, token): # We hardcode to use client\_secret\_post, because that's what the Google # oauth2client library defaults to request = {'token': token} headers = {'Content-type': 'application/x-www-form-urlencoded'}
 hint = current\_app.config['OIDC\_TOKEN\_TYPE\_HINT'] if hint != 'none': request['token\_type\_hint'] = hint
 auth\_method = current\_app.config['OIDC\_INTROSPECTION\_AUTH\_METHOD']  if (auth\_method == 'client\_secret\_basic'): basic\_auth\_string = '%s:%s' % (self.client\_secrets['client\_id'], self.client\_secrets['client\_secret']) basic\_auth\_bytes = bytearray(basic\_auth\_string, 'utf-8') headers['Authorization'] = 'Basic %s' % b64encode(basic\_auth\_bytes).decode('utf-8') elif (auth\_method == 'bearer'): headers['Authorization'] = 'Bearer %s' % token elif (auth\_method == 'client\_secret\_post'): request['client\_id'] = self.client\_secrets['client\_id'] if self.client\_secrets['client\_secret'] is not None: request['client\_secret'] = self.client\_secrets['client\_secret']
 resp, content = httplib2.Http().request( self.client\_secrets['token\_introspection\_uri'], 'POST', urlencode(request), headers=headers) # TODO: Cache this reply return \_json\_loads(content)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


