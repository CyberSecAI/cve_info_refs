```json
{
  "CVE-2016-7910": {
    "description": "A flaw was found in the Linux kernel's implementation of seq_file where a local attacker could manipulate memory in the put() function pointer. This could lead to memory corruption and possible privileged escalation.",
    "root_cause": "The `disk_seqf_stop` function in `block/genhd.c` didn't reset the `seqf->private` pointer to NULL after freeing the memory pointed to by it, leading to a use-after-free vulnerability if a subsequent call to `disk_seqf_start` failed.",
    "vulnerabilities": [
      "Use-after-free vulnerability"
    ],
    "impact": "Memory corruption and possible privilege escalation due to use of a dangling pointer within kernel space.",
     "attack_vectors": [
       "Local exploitation by a user able to trigger a sequence of open, pread, and a failing kmalloc."
     ],
    "required_capabilities": "Ability to open and `pread` a seq file. Trigger a failed `kmalloc` to cause `seqf->private` not be be reset, and subsequent access to the dangling pointer.",
        "additional_info": "The vulnerability can occur in the following scenario:\n\n1.  `open()`\n2.  `pread()`\n    1. `seq_start()`\n        - `iter = kmalloc()` succeeds\n        - `seqf->private = iter`\n    2. `seq_stop()`\n        - `kfree(seqf->private)`\n3. `pread()`\n    1. `seq_start()`\n        - `iter = kmalloc()` fails\n    2. `seq_stop()`\n        - `class_dev_iter_exit(seqf->private)` // boom! old pointer\n\nWhen stop is called even if start failed, the private pointer was not reset to NULL when seq iteration stopped.\n\nAn alternative fix would have been to set the private pointer to NULL when the `kmalloc()` in `disk_seqf_start()` fails."
  }
}
```