=== Content from blog.fuzzing-project.org_d5fe30f4_20250126_070412.html ===

[Skip to content](#content)
[# The Fuzzing Project

Blog and Advisories](https://blog.fuzzing-project.org/)

Quicksearch

## Navigation

* [Back to main page](https://fuzzing-project.org/)
* [Software list](https://fuzzing-project.org/software.html)

## [When your Memory Allocator hides Security Bugs](/65-When-your-Memory-Allocator-hides-Security-Bugs.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Wednesday, January 30. 2019

![Memory](/uploads/ram.jpg)Recently I shared some information about potential [memory safety bugs in the Apache web server together with Craig Young](https://github.com/hannob/apache-uaf). One issue that came up in that context is the so-called pool allocator Apache is using.

What is this [pool allocator](https://apr.apache.org/docs/apr/1.6/group__apr__pools.html)? Apache’s APR library has a feature where you can allocate a pool, which is a larger area of memory, and then do memory allocations within that pool. It’s essentially a separate memory allocation functionality by the library. Similar concepts exist in other software.

Why would anyone do that? It might bring performance benefits to have memory allocation that’s optimized for a specific application. It also can make programming more convenient when you can allocate many small buffers in a pool and then not bothering about freeing each one of then and instead just free the whole pool with all allocations within.

There’s a disadvantage with the pool allocator, and that is that it may hide bugs. Let’s look at a simple code example:

#include <apr\_pools.h>

#include <stdio.h>

#include <string.h>

int main() {

apr\_pool\_t \*p;

char \*b1, \*b2;

apr\_initialize();

apr\_pool\_create(&p, NULL);

b1 = apr\_palloc(p, 6);

b2 = apr\_palloc(p, 6);

strcpy(b1, "This is too long");

strcpy(b2, "Short");

printf("%s %s\n", b1, b2);

}

We can compile this with:

`gcc $(pkg-config --cflags --libs apr-1) input.c`

What we’re doing here is that we create a pool p and we create two buffers (b1, b2) within that pool, each six byte. Now we fill those buffers with strings. However for b1 we fill it with a string that is larger than its size. This is thus a classic buffer overflow. The `printf` at the end which outputs both strings will show garbled output, because the two buffers interfere.

Now the question is how do we find such bugs? Of course we can carefully analyze the code, and in the simple example above this is easy to do. But in complex software such bugs are hard to find manually, therefore there are tools to detect unsafe memory access (e.g. buffer overflows, use after free) during execution. The state of the art tool is Address Sanitizer (ASAN). If you write C code and don’t use it for testing yet, you should start doing so now.

Address Sanitizer is part of both the gcc and clang compiler and it can be enabled by passing `-fsanitize=address` on the command line. We’ll also add -g, which adds debugging information and will give us better error messages. So let’s try:

`gcc -g -fsanitize=address $(pkg-config --cflags --libs apr-1) input.c`

If you try this you will find out that nothing has changed. We still see the garbled string and Address Sanitizer has not detected the buffer overflow.

Let’s try rewriting the above code in plain C without the pool allocator:

#include <stdio.h>

#include <string.h>

#include <stdlib.h>

int main() {

char \*b1, \*b2;

b1 = malloc(6);

b2 = malloc(6);

strcpy(b1, "This is too long");

strcpy(b2, "Short");

printf("%s %s\n", b1, b2);

}

If we compile and run this with ASAN it will give us a nice error message that tells us what’s going on:

==9319==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000016 at pc 0x7f81fdd08c9d bp 0x7ffe82881930 sp 0x7ffe828810d8

WRITE of size 17 at 0x602000000016 thread T0

#0 0x7f81fdd08c9c in \_\_interceptor\_memcpy /var/tmp/portage/sys-devel/gcc-8.2.0-r6/work/gcc-8.2.0/libsanitizer/sanitizer\_common/sanitizer\_common\_interceptors.inc:737

#1 0x5636994851e0 in main /tmp/input.c:10

#2 0x7f81fdb204ea in \_\_libc\_start\_main (/lib64/libc.so.6+0x244ea)

#3 0x5636994850e9 in \_start (/tmp/a.out+0x10e9)

0x602000000016 is located 0 bytes to the right of 6-byte region [0x602000000010,0x602000000016)

allocated by thread T0 here:

#0 0x7f81fddb6b10 in \_\_interceptor\_malloc /var/tmp/portage/sys-devel/gcc-8.2.0-r6/work/gcc-8.2.0/libsanitizer/asan/asan\_malloc\_linux.cc:86

#1 0x5636994851b6 in main /tmp/input.c:7

#2 0x7f81fdb204ea in \_\_libc\_start\_main (/lib64/libc.so.6+0x244ea)

So why didn’t the error show up when we used the pool allocator? The reason is that ASAN is built on top of the normal C memory allocation functions like `malloc`/`free`. It does not know anything about APR’s pools. From ASAN’s point of view the pool is just one large block of memory, and what’s happening inside is not relevant.

Thus we have a buffer overflow, but the state of the art tool to detect buffer overflows is unable to detect it. This is obviously not good, it means the pool allocator takes one of the most effective ways to discover an important class of security bugs away from us.

If you’re looking for solutions for that problem you may [find old documentation about "Debugging Memory Allocation in APR"](http://download.vikis.lt/manual/developer/debugging.html). However it relies on flags that have been removed from the APR library, so it’s not helpful. However there’s a not very well documented option of the APR library that allows us to gain memory safety checks back. Passing `--enable-pool-debug=yes` to the configure script will effectively disable the pool allocator and create a separate memory allocation for each call to the pool allocator.

If we compile our first example again, this time with the pool debugger and ASAN, we’ll see the error:

==20228==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000016 at pc 0x7fe2e625dc9d bp 0x7ffe8419a180 sp 0x7ffe84199928

WRITE of size 17 at 0x602000000016 thread T0

#0 0x7fe2e625dc9c in \_\_interceptor\_memcpy /var/tmp/portage/sys-devel/gcc-8.2.0-r6/work/gcc-8.2.0/libsanitizer/sanitizer\_common/sanitizer\_common\_interceptors.inc:737

#1 0x55fe439d132c in main /tmp/input.c:15

#2 0x7fe2e5fc34ea in \_\_libc\_start\_main (/lib64/libc.so.6+0x244ea)

#3 0x55fe439d1129 in \_start (/tmp/a.out+0x1129)

0x602000000016 is located 0 bytes to the right of 6-byte region [0x602000000010,0x602000000016)

allocated by thread T0 here:

#0 0x7fe2e630bb10 in \_\_interceptor\_malloc /var/tmp/portage/sys-devel/gcc-8.2.0-r6/work/gcc-8.2.0/libsanitizer/asan/asan\_malloc\_linux.cc:86

#1 0x7fe2e6203157 (/usr/lib64/libapr-1.so.0+0x1f157)

#2 0x7fe2e5fc34ea in \_\_libc\_start\_main (/lib64/libc.so.6+0x244ea)

Apache is not alone in having a custom memory allocation that can hide bugs. Mozilla’s NSPR and NSS libraries have something called an Arena Pool, Glib has memory slices and PHP has the Zend allocator. All of them have the potential of hiding memory safety bugs from ASAN, yet luckily all have an option to be turned off for testing. I maintain [a collection of information about such custom allocators and how to disable them](https://fuzzing-project.org/tutorial-malloc.html).

But back to Apache. When we started reporting use after free bugs we saw with the debugging option for the pool allocator we learned from the Apache developers that there are incompatibilities with the http2 module and the pool debugger. This has led to replies after our disclosure that these [are non-issues](https://icing.github.io/mod_h2/pool-debugging.html), because nobody should run the pool debugger in production.

It should be noted that we were also able to reproduce some bugs without the pool debugger in the latest Apache version (we have shared this information with Apache and will share it publicly later), and that indeed it seems some people did run the pool debugger in production (OpenBSD).

But I have another problem with this. If we consider that parts of the current Apache code are incompatible with the APR pool debugger then we end up with an unfortunate situation: If a tool like ASAN reports memory safety bugs with the pool debugger we don’t know if they are real issues or just incompatibilities. If we turn off the pool debugger we won’t see most of the memory safety bugs.

That’s a situation where testing Apache for memory safety bugs becomes practically very difficult. In my opinion that by itself is a worrying and severe security issue.

*Image source: [Dreamstime, CC0](https://www.dreamstime.com/ddr2-sdram-stands-double-data-rate-synchronous-dynamic-random-access-memory-interface-modules-used-desktop-pcs-public-domain-image-free-87854911)*

[0 Comments](/65-When-your-Memory-Allocator-hides-Security-Bugs.html#comments "0 Comments, 0 Trackbacks")

## [Stack buffer overflow in WolfSSL before 3.13.0](/63-Stack-buffer-overflow-in-WolfSSL-before-3.13.0.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Saturday, March 24. 2018

During some tests of TLS libraries I found a stack buffer overflow vulnerability in the WolfSSL library.

Finding this one was surprisingly simple: I had a wolfssl server that was compiled with address sanitizer and ran the SSL Labs test against it.

The bug happens in the parsing of the signature hash algorithm list that is sent in a ClientHello and is basically a textbook stack buffer overflow. WolfSSL simply tries to store that in an array with 32 elements. If one sends more than 32 hash algorithms it overflows.

With the SSL Labs scan the bug only causes WolfSSL to terminate if it's compiled with address sanitizer, but if one sends a very large list of hash algorithms it also crashes in a normal compile. In situations where WolfSSL is used without ASLR this bug is probably trivially exploitable.

I have created a simple [bash proof of concept](https://github.com/hannob/wolfoverflow) (using netcat and xxd) that crashes a WolfSSL server.

The bug was fixed in [this commit](https://github.com/wolfSSL/wolfssl/pull/1231/commits/9f7e40ad5c8097ff38d7caff4a9989db260981cc) and in version 3.13.0 of WolfSSL.

Categories: [advisories](https://blog.fuzzing-project.org/categories/1-advisories) | [0 Comments](/63-Stack-buffer-overflow-in-WolfSSL-before-3.13.0.html#comments "0 Comments, 0 Trackbacks")

## [FLIMP! The GIMP has some security problems](/62-FLIMP%21-The-GIMP-has-some-security-problems.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Tuesday, December 19. 2017

I recently got an E-Mail from Tobias Stöckmann, who reminded me of some bugs I had almost forgotten. When I started the Fuzzing Project I reported two bugs in import parsers of the GIMP. Tobias managed to write an exploit for one of them.

See [FLIMP!](https://flimp.fuzzing-project.org/) for more info.

[0 Comments](/62-FLIMP%21-The-GIMP-has-some-security-problems.html#comments "0 Comments, 0 Trackbacks")

## [How Optionsbleed wasn't found in 2014](/61-How-Optionsbleed-wasnt-found-in-2014.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Wednesday, September 20. 2017

Shortly after I [published details about the Optionsbleed bug](https://blog.fuzzing-project.org/60-Optionsbleed-HTTP-OPTIONS-method-can-leak-Apaches-server-memory.html) I learned about something quite surprising: Others had already discovered this bug before, but have neither pinned it down to Apache nor recognized that it is a security vulnerability.

A paper published in 2014 on Arxiv titled ["Support for Various HTTP Methods on the Web"](https://arxiv.org/pdf/1405.2330.pdf) mentions servers sending malformed Allow headers. It has examples listed that very clearly look like the output you get from a server vulnerable to Optionsbleed.

This alone would be noteworthy enough, but there's something that makes this even more surprising. This paper was published in May 2014, about a month after the Heartbleed bug was found. Heartbleed gained a lot of attention, not just in the tech scene, it was widely covered in the mainstream media. It can be assumed that almost everyone working in IT had heard of it.

So we have a situation where a major bug hit the news - and several people must have had evidence of a very similar bug in front of their eyes shortly afterwards. Yet nobody has recognized it as such. One of the authors [mentioned in a comment](https://blog.fuzzing-project.org/60-Optionsbleed-HTTP-OPTIONS-method-can-leak-Apaches-server-memory.html#c989) that they hadn't looked at it from a security perspective, but still you'd think that someone should have noticed.

While it's always problematic to interpret too much into single anecdotes, it still makes me wonder things. Are we just terribly bad at explaining security issues? My personal impression is that Heartbleed is actually an issue that is relatively simple to grasp (of course best explained by [XKCD](https://xkcd.com/1354/)). Going from there to the idea that seeing random garbage in HTTP headers indicates a very similar bug doesn't seem so far fetched to me. But the facts seem to disprove that.

[0 Comments](/61-How-Optionsbleed-wasnt-found-in-2014.html#comments "0 Comments, 0 Trackbacks")

## [Optionsbleed - HTTP OPTIONS method can leak Apache's server memory](/60-Optionsbleed-HTTP-OPTIONS-method-can-leak-Apaches-server-memory.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Monday, September 18. 2017

[![optionsbleed](/uploads/optionsbleed.serendipityThumb.png)](/uploads/optionsbleed.png)If you're using the HTTP protocol in everday Internet use you are usually only using two of its methods: GET and POST. However HTTP has a number of other methods, so I wondered what you can do with them and if there are any vulnerabilities.![](https://ssl-vg03.met.vgwort.de/na/cebfb3b02359461ab9ecf10beb28e327)
Categories: [advisories](https://blog.fuzzing-project.org/categories/1-advisories) | [16 Comments](/60-Optionsbleed-HTTP-OPTIONS-method-can-leak-Apaches-server-memory.html#comments "16 Comments, 2 Trackbacks")

## [Six year old PDF loop bug affects most major implementations](/59-Six-year-old-PDF-loop-bug-affects-most-major-implementations.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Sunday, September 3. 2017

![Endless Loop](/uploads/moebius-endless-loop.jpg)I recently did some testing of the qpdf library with afl and libfuzzer. I discovered an input sample that would generate a high CPU load spike and eventually after several minutes cause an out of memory error. It looked like the parser was caught in some kind of endless loop.

This reminded me of something. In [2011 at the Chaos Communication Camp Andreas Bogk gave a talk about creating a formally verified PDF parser with Ocaml and Coq](https://media.ccc.de/v/cccamp11-4426-certified_programming_with_dependent_types-en). In that talk he mentioned that one could create a PDF file with cross-referencing xref tables. A naive parser would get caught in an endless loop. He showed that the evince thumbnailer process was affected by this.

This was eventually fixed in evince's underlying rendering library poppler. But it seems this issue hasn't reached many other PDF parser libraries. The qpdf issue I had seen was exactly the [same bug](https://github.com/qpdf/qpdf/issues/149). The sample file can [be found here](https://github.com/andreas23/pdfparser/blob/master/tests/loop_edited.pdf). If you follow that link you'll immediately notice that Github's Javascript PDF viewer is also affected.

How about Mozilla Firefox? [Affected](https://bugzilla.mozilla.org/show_bug.cgi?id=1393476). (They use pdf.js, which is the same code Github uses.) What about Chrome / Chromium, which uses a library called PDFium? [Affected](https://bugs.chromium.org/p/pdfium/issues/detail?id=875). (Notably they already had a test PDF for this, but the function that causes the loop wasn't tested.) Microsoft Edge? [Affected](https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/13534806/). Ghostscript, which is the other major PDF parser used by many free and open source tools? [Also affected](https://bugs.ghostscript.com/show_bug.cgi?id=698409). For completeness, Adobe Reader and Apple's OS X internal PDF viewer were unaffected.

To make this clear: This isn't a major security issue, the impact is a denial of service. But it is certainly something undesirable that should be fixed.

It is remarkable that a bug that was discovered six years ago affected the majority of widely used PDF implementations. But it falls into a pattern of IT security: Very often discovering security issues means rediscovering old issues. In general this is a difficult problem to solve, as it touches complex questions about knowledge transfer.

However in this specific case - an input file that causes a bug in one implementation also causes the same bug in other implementations - there are things that can be done.

I report fuzzing-related bugs on a very regular basis and I always share a sample file that triggers the bug. In the best cases the maintainers of the affected software take the bug triggering sample and use it in their test suite. I think this should be a standard practice.

However that only prevents regressions in the same software. But maintainers of parsers for common file formats could also take a look at their competitors and check their test suites. While the PDF standard probably isn't well defined enough to allow a visual comparison of rendering output, it's surely obvious that no input file should cause a crash, an invalid memory access or an endless loop.

Looking at the common PDF libraries the situation with test cases was quite mixed. Mozilla's pdf.js had the most [extensive collection of files](https://github.com/mozilla/pdf.js/tree/master/test/pdfs), many of them examples from previous bugs. However one should know that about a third of them are not part of their code repository. They're referenced as links (all of them pointing to their own bug tracker or to the Internet archive, so I guess they're reasonably stable).

PDFium, used by Google Chrome, has a far less extensive test suite with only 96 PDF files. I have reported a bunch of PDFium bugs myself in the past (Examples: [[1]](https://bugs.chromium.org/p/chromium/issues/detail?id=450871), [[2]](https://bugs.chromium.org/p/chromium/issues/detail?id=457493), [[3]](https://bugs.chromium.org/p/chromium/issues/detail?id=450971)) and the test cases I provided never got added to the test suite.

QPDF is doing very well: They ship 278 test PDFs and for all the bugs I reported lately they added the provided sample files.

Ghostscript has only three PDF example files in its code (other PDFs in the code seem to be documentation, not test cases). Poppler's code has no PDFs bundled at all. They have a separate [test repository](https://cgit.freedesktop.org/poppler/test/) for that with 35 files, but it hasn't been updated since 2009. There's definitely lots of room for improvement in that area.

[Image Source](https://commons.wikimedia.org/wiki/File%3ACircle_Wind_Sculpture.jpg)

[9 Comments](/59-Six-year-old-PDF-loop-bug-affects-most-major-implementations.html#comments "9 Comments, 0 Trackbacks")

## [exiv2: multiple memory safety issues](/58-exiv2-multiple-memory-safety-issues.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Monday, July 3. 2017

*This post first appeared on [oss-security](http://www.openwall.com/lists/oss-security/2017/06/30/1).*

I'm reporting three issues here in exiv2, a parser libary for image metadata. These are only examples, exiv2 is full of memory safety bugs that can trivially be found by running afl with asan for a few hours.

I have not reported those issues upstream. When I previously tried to report bugs in exiv2 found via fuzzing the upstream author made it clear to me that he has little interest in fixing those issues and doesn't consider his software suitable to parse defect files (which basically means it's unsuitable for untrusted input). The [discussion can be read here](http://dev.exiv2.org/issues/1248). (the page is sometimes not available, searching for it in the google cache usually works though)

exiv2 is to my knowledge used by the major Linux Desktops GNOME and KDE. I'll also inform their security teams. I leave it up to Linux distros how to handle this, but it certainly is problematic that a crucial parser used by major desktop applications is not interested in fixing potential security issues.

**Heap overflow (write) in tiff parser**

A [malformed tiff file](https://crashes.fuzzing-project.org/exiv2-heap-oob-write.tiff) can cause a one byte heap overflow in exiv2.

Stack trace:

`==22873==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000df1 at pc 0x000000842091 bp 0x7fff51b3ee70 sp 0x7fff51b3ee68

WRITE of size 1 at 0x602000000df1 thread T0

#0 0x842090 in Exiv2::ul2Data(unsigned char*, unsigned int, Exiv2::ByteOrder) /f/exiv2-trunk/src/types.cpp:362:20

#1 0x68beac in long Exiv2::toData<unsigned int>(unsigned char*, unsigned int, Exiv2::ByteOrder) /f/exiv2-trunk/src/../include/exiv2/value.hpp:1459:16

#2 0x68beac in Exiv2::ValueType<unsigned int>::copy(unsigned char*, Exiv2::ByteOrder) const /f/exiv2-trunk/src/../include/exiv2/value.hpp:1612

#3 0x6742b2 in Exiv2::Exifdatum::copy(unsigned char*, Exiv2::ByteOrder) const /f/exiv2-trunk/src/exif.cpp:362:48

#4 0x7f794d in Exiv2::TiffImage::readMetadata() /f/exiv2-trunk/src/tiffimage.cpp:204:18

#5 0x59786a in Action::Print::printSummary() /f/exiv2-trunk/src/actions.cpp:289:16

#6 0x596ef8 in Action::Print::run(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /f/exiv2-trunk/src/actions.cpp:244:44

#7 0x55fb3f in main /f/exiv2-trunk/src/exiv2.cpp:170:25

#8 0x7f91c1e571d0 in __libc_start_main /var/tmp/portage/sys-libs/glibc-2.24-r2/work/glibc-2.24/csu/../csu/libc-start.c:289

#9 0x468979 in _start (/r/exiv2/exiv2+0x468979)

0x602000000df1 is located 0 bytes to the right of 1-byte region [0x602000000df0,0x602000000df1)

allocated by thread T0 here:

#0 0x55af00 in operator new[](unsigned long) (/r/exiv2/exiv2+0x55af00)

#1 0x83fadf in Exiv2::DataBuf::alloc(long) /f/exiv2-trunk/src/types.cpp:158:22`

**Heap out of bounds read in jp2 / JPEG2000 parser**

A [malformed jpeg2000 file](https://crashes.fuzzing-project.org/exiv2-heap-oob-read.jp2) causes a (large) out of bounds read.

Stack trace:

`==32038==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x7f5e099e6838 at pc 0x00000050f22c bp 0x7ffdf7f3dcd0 sp 0x7ffdf7f3d480

READ of size 808464432 at 0x7f5e099e6838 thread T0

#0 0x50f22b in __asan_memcpy (/r/exiv2/exiv2+0x50f22b)

#1 0x6e82bc in Exiv2::Jp2Image::readMetadata() /f/exiv2-trunk/src/jp2image.cpp:277:29

#2 0x59786a in Action::Print::printSummary() /f/exiv2-trunk/src/actions.cpp:289:16

#3 0x596ef8 in Action::Print::run(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /f/exiv2-trunk/src/actions.cpp:244:44

#4 0x55fb3f in main /f/exiv2-trunk/src/exiv2.cpp:170:25

#5 0x7f5e130a71d0 in __libc_start_main /var/tmp/portage/sys-libs/glibc-2.24-r2/work/glibc-2.24/csu/../csu/libc-start.c:289

#6 0x468979 in _start (/r/exiv2/exiv2+0x468979)

0x7f5e099e6838 is located 0 bytes to the right of 808452152-byte region [0x7f5dd96e6800,0x7f5e099e6838)

allocated by thread T0 here:

#0 0x55af00 in operator new[](unsigned long) (/r/exiv2/exiv2+0x55af00)

#1 0x6e8176 in Exiv2::DataBuf::DataBuf(long) /f/exiv2-trunk/src/../include/exiv2/types.hpp:204:46

#2 0x6e8176 in Exiv2::Jp2Image::readMetadata() /f/exiv2-trunk/src/jp2image.cpp:273

#3 0x59786a in Action::Print::printSummary() /f/exiv2-trunk/src/actions.cpp:289:16

#4 0x596ef8 in Action::Print::run(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /f/exiv2-trunk/src/actions.cpp:244:44

#5 0x7f5e130a71d0 in

__libc_start_main /var/tmp/portage/sys-libs/glibc-2.24-r2/work/glibc-2.24/csu/../csu/libc-start.c:289`

**Stack out of bounds read in webp parser**

A [malformed webp file](https://crashes.fuzzing-project.org/exiv2-stack-oob-read.webp) causes a six bytes stack out of bounds read.

Stack trace:

`==598==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffcc12aa054 at pc 0x0000004fe311 bp 0x7ffcc12a9f90 sp 0x7ffcc12a9740

READ of size 6 at 0x7ffcc12aa054 thread T0

#0 0x4fe310 in __interceptor_memcmp.part.76 (/r/exiv2/exiv2+0x4fe310)

#1 0x8889d0 in Exiv2::WebPImage::getHeaderOffset(unsigned char*, long, unsigned char*, long) /f/exiv2-trunk/src/webpimage.cpp:798:17

#2 0x8889d0 in Exiv2::WebPImage::decodeChunks(unsigned long) /f/exiv2-trunk/src/webpimage.cpp:601

#3 0x884ff2 in Exiv2::WebPImage::readMetadata() /f/exiv2-trunk/src/webpimage.cpp:496:20

#4 0x59786a in Action::Print::printSummary() /f/exiv2-trunk/src/actions.cpp:289:16

#5 0x596ef8 in Action::Print::run(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /f/exiv2-trunk/src/actions.cpp:244:44

#6 0x55fb3f in main /f/exiv2-trunk/src/exiv2.cpp:170:25

#7 0x7f7f9cc9f1d0 in __libc_start_main /var/tmp/portage/sys-libs/glibc-2.24-r2/work/glibc-2.24/csu/../csu/libc-start.c:289

#8 0x468979 in _start (/r/exiv2/exiv2+0x468979)

Address 0x7ffcc12aa054 is located in stack of thread T0 at offset 180 in frame

#0 0x885a0f in Exiv2::WebPImage::decodeChunks(unsigned long) /f/exiv2-trunk/src/webpimage.cpp:501

This frame has 13 object(s):

[32, 36) 'size_buff' (line 503)

[48, 64) 'payload' (line 516)

[80, 84) 'size_buf' (line 520)

[96, 100) 'size_buf48' (line 536)

[112, 114) 'size_buf_w' (line 551)

[128, 131) 'size_buf_h' (line 552)

[144, 148) 'size_buf112' (line 568)

[160, 162) 'size_buff152' (line 587)

[176, 180) 'exifLongHeader295' (line 588) <== Memory access at offset 180 overflows this variable

[192, 196) 'exifTiffBEHeader297' (line 591)

[208, 272) 'xmpData' (line 650)

[304, 688) 'temp.lvalue'

[752, 1136) 'temp.lvalue232'

HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext

(longjmp and C++ exceptions are supported)`

Categories: [advisories](https://blog.fuzzing-project.org/categories/1-advisories) | [0 Comments](/58-exiv2-multiple-memory-safety-issues.html#comments "0 Comments, 0 Trackbacks")

## [Diving into Control Flow Integrity](/57-Diving-into-Control-Flow-Integrity.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Friday, March 31. 2017

To improve security, modern systems contain many mitigation strategies that try to make it harder to exploit security vulnerabilities. Commonly used strategies include stack canaries, address space layout randomization (ASLR) and nonexecutable memory pages. Unfortunately the Linux distributions have been slow in adopting ASLR, but this is finally changing.

A new set of mitigation technologies has been discussed for a while under the umbrella term "Control Flow Integrity" (CFI). I won't get into technical details, but the very general idea is to add additional checks to the code that prohibit jumps to code parts that are not supposed to happen in the normal operation of a software.

LLVM's Clang compiler supports a form of CFI since version 3.7. Other forms of CFI are available under windows in Visual Studio ([CFGuard](https://msdn.microsoft.com/en-us/library/windows/desktop/mt637065%28v%3Dvs.85%29.aspx)) and with Grsecurity ([RAP](https://grsecurity.net/rap_announce.php)).

Recently I experimented a bit with the Clang version of CFI. It's been one of those situations where you dig into a topic and find out that it's really hard to Google for advice. The information out there is relatively limited: There's the [official LLVM documentation](https://clang.llvm.org/docs/ControlFlowIntegrity.html), a [talk by Kostya Serebryany that briefly mentions CFI in the second half](https://www.youtube.com/watch?v=qTkYDA0En6U) and [two](https://blog.trailofbits.com/2016/10/17/lets-talk-about-cfi-clang-edition/) [blog](https://blog.trailofbits.com/2017/02/20/the-challenges-of-deploying-security-mitigations/) posts by the company Trail of Bits. Also [Chrome is using a subset of the CFI functionality and there's a list of bugs found with it](https://www.chromium.org/developers/testing/control-flow-integrity).

Given the relatively scarce information when starting to use it you will experience situations where things fail and you won't find any help via Google.

So why would you want to use CFI? One possibility would be to create a super-hardened Linux system where, beyond using the "old" exploit mitigations like ASLR, one would also enable CFI. The computational costs of doing so are relatively small (Kostya Serebryany mentions in the talk above that they were unable to measure the CPU cost in Chrome). The executables grow in size and likely use more memory, but not in extraordinary amounts (below 10 percent). So from a performance side this is doable.

I started by compiling some small applications with CFI to see what happens. In some cases they "just work". In most cases I ended up having strange linker errors that were nontrivial to debug. Interesting for Linux distributions: There seems to be no dependency chain that needs to be considered (which is different from many of Clang's Sanitizer features). It's possible to have an executable built with CFI that depends on libraries not using CFI and it's also possible to have libraries using CFI that are used by executables not using CFI. This is good: If we'd strive for our super-hardened Linux we can easily exclude packages that create too many problems or start by including packages where we think they'd profit most from such extra protection.

CFI itself is enabled with the flag *-fsanitize=cfi*. It needs two other compiler and linker flags to work: *-fvisibility=hidden* for the compiler, which hides unnecessary symbols, and *-flto* for the linker to enable Link Time Optimization. The latter one needs the Gold linker, depending on your system you may need to install the LLVM gold plugin. If Gold isn't your default linker you can pass *-fuse-ld=gold*. Furthermore if you want to debug things you want to add *-fno-sanitize-trap=all* and enable extended debugging with *-g*, this will give you useful error messages in case CFI stops your application. (However you probably don't want to do that in production systems, as the error reporting can introduce additional bugs.)

In theory some of these flags only need to be passed to the compiler and others to the linker, but compilation systems aren't always strict in separating those, so we just add all of them to both.

So we can start compiling the current version of curl (7.53.1):
```
./configure CC=clang CXX=clang++ LD=clang CFLAGS="-fsanitize=cfi -fvisibility=hidden -fuse-ld=gold -flto" CXXFLAGS="-fsanitize=cfi -fvisibility=hidden -fuse-ld=gold -flto" LDFLAGS="-fsanitize=cfi -fvisibility=hidden -fuse-ld=gold -flto"

make
```

However we'll end up getting an error when it tries to link to the shared library. I guess it's a libtool problem, but I haven't digged into it. For now we can just disable the shared library by adding *--disable-shared*:
```
./configure CC=clang CXX=clang++ LD=clang CFLAGS="-fsanitize=cfi -fvisibility=hidden -fuse-ld=gold -flto" CXXFLAGS="-fsanitize=cfi -fvisibility=hidden -fuse-ld=gold -flto" LDFLAGS="-fsanitize=cfi -fvisibility=hidden -fuse-ld=gold -flto" --disable-shared
make
```

[0 Comments](/57-Diving-into-Control-Flow-Integrity.html#comments "0 Comments, 1 Trackback")

## [htpasswDoS: Local Denial of Service via Apache httpd password hashes](/56-htpasswDoS-Local-Denial-of-Service-via-Apache-httpd-password-hashes.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Tuesday, January 10. 2017

![Apache logo](/uploads/apache-httpd-logo.png)The way the Apache httpd web server handles password hashes can be abused by a malicious user on a server to cause resource exhaustion and denial of service of the web server. I reported this a while ago to the Apache security team - which led to a lengthy discussion where I was a bit appalled about some of the statements I got from the Apache developers. They can be summed up in a way that major use cases of Apache - especially in web hosting environments - are not recommended by their developers.![](https://ssl-vg03.met.vgwort.de/na/18d199e9596c4bdb82d4b86de95bc498)
Categories: [advisories](https://blog.fuzzing-project.org/categories/1-advisories) | [0 Comments](/56-htpasswDoS-Local-Denial-of-Service-via-Apache-httpd-password-hashes.html#comments "0 Comments, 0 Trackbacks")

## [Fuzzing Irssi with Perl Scripts](/55-Fuzzing-Irssi-with-Perl-Scripts.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Friday, January 6. 2017

When using fuzzing tools like afl a common challenge is how you can pass input to the interesting parts of the application you want to fuzz. In easy situations we have a tool that will accept our input as a file or via stdin. However sometimes this is not easily possible.

Let's have a look at Irssi, an irc chat client. The only input you can pass on the command line is a config file. Fuzzing Irssi 0.8.10 easily led to [a segfault caused by a null pointer access](https://github.com/irssi/irssi/issues/550). However while bugs in config file parsers probably still should be fixed, usually they are not very interesting. (There [can be exceptions](https://blog.fuzzing-project.org/8-Why-it-can-make-sense-to-fuzz-config-files-two-out-of-bounds-vulnerabilities-in-curl-TFPA-0042015.html).)

So what else might be interesting? Irssi does some parsing on all output, e.g. due to [color codes](https://irssi.org/documentation/settings/#a_d). However we can't just print text that is passed via the command line as an input file. We have to abuse Irssi's perl scripting capability for that.

We can place a [simple perl script](https://gitlab.com/hanno/irssi-fuzzing/blob/master/fuzz-print.pl) that will read a file (`fuzzp.txt`) and print it into Irssi's autorun directory (default location is ~/.Irssi/scripts/autorun/). We can then place some [examples of Irssi color codes](https://gitlab.com/hanno/irssi-fuzzing/blob/master/irssi-example-colorcodes.txt) into the directory "in/". I have installed an afl/asan-instrumented Irssi into my system to `/usr/local/`, because for running perl scripts it needs more than just the executable. So we can run afl like this:

`afl-fuzz -i in -o out -m none -f fuzzp.txt Irssi`

afl will put the fuzzed output into `fuzzp.txt` and our autoload script will read it from there. Doing this lets us learn that the sequence "%[" causes Irssi to read an invalid memory byte. For reasons unclear to me this only happens if a script outputs this sequence, not if a user types it in. (This issue got [CVE-2017-5196](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5196) assigned.)

We can go further and do a [similar script that executes input as a command](https://gitlab.com/hanno/irssi-fuzzing/blob/master/fuzz-command.pl). Commands are things like "/QUIT" that control the application and the channel behavior. I named the input file `fuzzc.txt`, so we can place some [simple Irssi commands](https://gitlab.com/hanno/irssi-fuzzing/blob/master/fuzz-command.pl) into `in/` and run:

`afl-fuzz -i in -o out -m none -f fuzzc.txt Irssi`

Thus we will now fuzz Irssi's command processing.

As we have seen, scripting functionality can be used to fuzz an application. So if you want to fuzz something and don't know how to pass input: See if there's a scripting functionality.

*Irssi has issued a [security advisory for several security vulnerabilities](https://irssi.org/security/irssi_sa_2017_01.txt), including the out of bounds read mentioned above. All vulnerabilities and the config file parser segfault are fixed in 0.8.21 and 1.0.0.*

Categories: [advisories](https://blog.fuzzing-project.org/categories/1-advisories) | [0 Comments](/55-Fuzzing-Irssi-with-Perl-Scripts.html#comments "0 Comments, 0 Trackbacks")

## [Update on MatrixSSL miscalculation (CVE-2016-8671, incomplete fix for CVE-2016-6887)](/54-Update-on-MatrixSSL-miscalculation-CVE-2016-8671%2C-incomplete-fix-for-CVE-2016-6887.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Saturday, October 15. 2016

I recently reported how I found [various bugs in the bignum implementation of MatrixSSL](https://blog.fuzzing-project.org/51-Fun-with-Bignums-Crashing-MatrixSSL-and-more.html), some of them leading to remotely exploitable vulnerabilities.

One of the bugs was that the modular exponentiation function - pstm\_exptmod() - produced wrong results for some inputs . This wasn't really fixed, but only worked around by restricting the allowed size of the modulus. Not surprisingly it is still possible to find inputs that cause miscalculations ([code](https://github.com/hannob/bignum-fuzz/blob/master/matrixssl-exptmod-bug-variant2.c)). I reported this to MatrixSSL on August 1st.

Recently MatrixSSL released another update (3.8.6) [fixing several vulnerabilities reported by Craig Young from Tripwire](http://www.tripwire.com/state-of-security/security-data-protection/cyber-security/flawed-matrixssl-code-highlights-need-for-better-iot-update-practices/). However the pstm\_exptmod() bug is still there. (The incomplete fix got assigned [CVE-2016-8671](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-8671).)

It is unclear how exploitable such bugs are, but given that it's used in the context of cryptographic functions handling secret key material this is clearly a reason for concern.

MatrixSSL has long advertised itself as a safer alternative to OpenSSL, because it didn't suffer from the same kind of high severity bugs. I think it has been sufficiently shown that this was due to the fact that nobody was looking. But what's more worrying is that bugs they knew about for several months now don't get fixed properly.

[0 Comments](/54-Update-on-MatrixSSL-miscalculation-CVE-2016-8671%2C-incomplete-fix-for-CVE-2016-6887.html#comments "0 Comments, 0 Trackbacks")

## [Out of bounds heap bugs in glib, heap buffer overflow in gnome-session](/53-Out-of-bounds-heap-bugs-in-glib%2C-heap-buffer-overflow-in-gnome-session.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Friday, September 16. 2016

By testing GNOME-related packages with Address Sanitizer I recently discovered several trivial to find bugs.

Two out of bounds bugs in the glib library were uncovered by running the test suite with Address Sanitizer enabled. One heap buffer overflow in the parameter parsing of gnome-session was uncovered by trying to start GNOME. Given that these bugs weren't discovered earlier means that most likely nobody ever used Address Sanitizer to test GNOME components.

I strongly recommend to GNOME and to other software communities to use Address Sanitizer testing in order to improve the quality of their software.

Out of bounds read in g\_unichar\_iswide\_bsearch() / glib

[Upstream bug report](https://bugzilla.gnome.org/show_bug.cgi?id=762493) (again reported [here](https://bugzilla.gnome.org/show_bug.cgi?id=766211))

[Commit / fix](https://git.gnome.org/browse/glib/commit/?id=bcbd8d7)

Fixed in 2.48.2.

Out of bounds read in token\_stream\_prepare() / glib

[Upstream bug report](https://bugzilla.gnome.org/show_bug.cgi?id=762417)

[Commit / fix](https://git.gnome.org/browse/glib/commit/glib/gvariant-parser.c?id=aead1c046dd39748cca449b55ec300ba5f025365)

Fixed in 2.48.0.

Heap buffer overflow in gnome-session

[Upstream bug report](https://bugzilla.gnome.org/show_bug.cgi?id=768441)

[Commit / fix](https://git.gnome.org/browse/gnome-session/commit/?h=gnome-3-20&id=634ab70d9f03b1650be4b8259091ca3036f0fbf9)

Fixed in 3.20.2.

Categories: [advisories](https://blog.fuzzing-project.org/categories/1-advisories) | [0 Comments](/53-Out-of-bounds-heap-bugs-in-glib%2C-heap-buffer-overflow-in-gnome-session.html#comments "0 Comments, 0 Trackbacks")

## [Multiple vulnerabilities in RPM – and a rant](/52-Multiple-vulnerabilities-in-RPM-and-a-rant.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Friday, August 26. 2016

Last year in November I decided that it might be a good idea to fuzz the parsers of package management tools in Linux distributions. I quickly found a couple of issues in DPKG and RPM. For DPKG the process went very smooth. I reported them to Debian's security team, eight days later fixes and security advisories were published by both Debian and Ubuntu, the main distributions using DPKG. For RPM the process was a bit more difficult.

If you want to report a bug to RPM you first may wonder where to report it. The RPM webpage [1] is a trac installation which has its own bug tracker. However if you try to register an account there you'll get forwarded to an HTTPS site with an expired certificate that doesn't match the domain name. In case you are brave and tell your browser to ignore all warnings you'll be greeted by a broken-looking trac without any CSS. Should you proceed and create an account you will learn that this doesn't help you, because in order to be allowed to report a bug you first have to ask on the mailing list or in the IRC channel for permission [2]. That's probably the point where many well-meaning bug reporters give up.

Okay, but RPM originally stood for “Red Hat package manager” (I've been told that today it stands for RPM Package Manager), so maybe Red Hat feels responsible. So I reported three bugs with sample files triggering them to the Red Hat security team on November 20th. The answer was – to put it mildly – a bit dissatisfying. I'll just fully quote it: “Thanks for the report. We also received about 30+ crash reports in RPM from

a different reporter recently so processing all of them (yours and the

others) will take quite a bit of time. We simply don't have the resources

to spend hours upon hours analyzing all crash reports.”

Okay, so I wasn't the only one fuzzing RPM and the maybe bugs will be fixed some day. I waited. In the meantime I got contacted by another person who also had tried to report fuzzing bugs in RPM and who has made similar experiences (maybe the same person who reported the 30+ crashers, I don't know).

In February I decided to ask what the state of things is. I also gave them a 30 day period until I'd publish the bugs (I know that it's now long past that, I shouldn't have let this issue wait so long). I ended up having a call with a Red Hat security team member and exchanged a couple of mails. I learned that RPM has a Github repository [3], which contains fixes for some (but not all) of the issues I reported, however that's nowhere referenced on its webpage. I then fuzzed the current RPM git code again and found two more issues I also reported to the Red Hat security team.

Status today is that the latest release of RPM on its webpage – 4.12.0.1 - is from July 2015, so all of the bugs still affect this release. However it seems there is an unofficial 4.13 release that's nowhere to be found on the RPM webpage, but Red Hat is using it together with some fixes [4]. And the Github repository says the latest release is 4.12.0, so according to three different sources three different versions are the current one (4.12.0, 4.12.0.1, 4.13).

One of the bugs – a stack overflow (write) - is still present in the latest code on Github.

**Commend and Conclusion**

This blog post probably reads like a big rant about how unprofessional Red Hat is in handling potential security issues. But this is contrary to my usual experience. I often see Red Hat developers being very active in the free software security community and often contributing in a positive way. Quite simply I expect better from Red Hat. This is not some dubious Enterprise vendor where I wouldn't be the least bit surprised of such a reaction.

The development process of RPM seems to be totally chaotic, it's neither clear where one reports bugs nor where one gets the latest code and security bugs don't get fixed within a reasonable time.

There's been some recent events that make me feel especially worried about this: An unknown person has created an entry in the Libarchive issue tracker [5] that points to an anonymous document [6] with a very detailed description of various security weaknesses in the FreeBSD update process (most of them are still unfixed). The most worrying thing about this is however that the anonymous post mentions the existence similar documents affecting multiple Linux distributions. These documents haven't shown up publicly yet and given the unclear nature of this incident it's hard to know whether they ever will become public or exist at all. But this should still be reason enough to have a closer look at potential security vulnerabilities in all pieces of Linux package management systems.

I haven't analyzed the RPM installation process in detail, so I can't say how likely it is that the RPM tool ever sees a malformed input file. It seems downloads happen over HTTP, but the first thing that happens is a signature check. As the signature is part of the RPM file it already needs to be parsed for this. The exact impact of these bugs would require further analysis. But independent of how likely this is I think the parser in such a crucial piece of software should be robust. It should be safe to use the rpm tool to show info about a file on the command line.

[1] <http://rpm.org/>

[2] <http://rpm.org/wiki/ReportingBugs>

[3] <https://github.com/rpm-software-management/rpm>

[4] <http://pkgs.fedoraproject.org/cgit/rpms/rpm.git/diff/rpm-4.13.0-rpmtd-out-of-bounds.patch?h=f22&id=165614f3dd42caa188f78b55e7723dad2900b2f4>

[5] <https://github.com/libarchive/libarchive/issues/743>

[6] <https://gist.github.com/anonymous/e48209b03f1dd9625a992717e7b89c4f>

All bugs were found with the help of american fuzzy lop. Here are the bugs:

Stack Overflow in glob() / rpmglob.c.

Sample file (test with rpm -i [input]):

<https://crashes.fuzzing-project.org/rpm-stackoverflow-glob.rpm>

Unfixed in the current Git code.

Heap out of bounds read in headerVerifyInfo() / header.c.

Sample file (test with “rpm -i [input]”):

<https://crashes.fuzzing-project.org/rpm-heap-oob-read-headerVerifyInfo.rpm>

Git commit:

<https://github.com/rpm-software-management/rpm/commit/8e847d52c811e9a57239e18672d40f781e0ec48e>

Null pointer access / segfault in stringFormat() / formats.c

Sample file (test with “rpm -i [input]”):

<https://crashes.fuzzing-project.org/rpm-nullptr-rpmtdFormat.rpm>

Git commit:

<https://github.com/rpm-software-management/rpm/commit/cddf43a56f19711866371f02f378dc4095b0fadd>

Out of bounds read in rpmtdGetNumber() / rpmtd.c

Sample file (test with “rpm -qi -p -- [input]”)

<https://crashes.fuzzing-project.org/rpm-heap-oob-read-rpmtdGetNumber.rpm>

Git commit:

<https://github.com/rpm-software-management/rpm/commit/b722cf86200505b3e3fcbb2095c4ff61f1f5a2ab>

Finally one annoying thing to admit: In my original report I included another segfault in headerVerifyInfo() with unclear reasons. However I am now unable to reproduce this one. It may be due to compiler options, different command line parameters or dependencies on my system that have changed. For completeness I'm still providing the sample file:

<https://crashes.fuzzing-project.org/rpm-segfault-headerVerifyInfo.rpm>

(Ideally the RPM developers should include all those sample files in a test suite they regularly run against an address sanitizer build of RPM.)

Please also note that I expect this list to be incomplete and there are likely more issues that could be uncovered with further fuzzing. I'll test that once all the existing issues are fixed.

Categories: [advisories](https://blog.fuzzing-project.org/categories/1-advisories) | [11 Comments](/52-Multiple-vulnerabilities-in-RPM-and-a-rant.html#comments "11 Comments, 0 Trackbacks")

## [Fun with Bignums: Crashing MatrixSSL and more](/51-Fun-with-Bignums-Crashing-MatrixSSL-and-more.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Sunday, July 31. 2016

If you've been following my fuzzing work you will be aware that I've fuzzed various bignum libraries and found several bugs by comparing implementations against each other.

I recently had a look at the MatrixSSL's modular exponentiation function, for reasons I'll explain later. I wrote [a wrapper, similar to previous experiments, comparing its result to OpenSSL](https://github.com/hannob/bignum-fuzz/blob/master/openssl-vs-matrixssl-modexp.c).

I immediately noted that the pstm\_exptmod() function of MatrixSSL has certain limitations that weren't documented. If one tries to calculate a modular exponentiation with the base equal to the modulus (a^b mod a, [code](https://github.com/hannob/bignum-fuzz/blob/master/matrixssl-base-equals-modulus.c)) it would return an error. If one tries to calculate a modular exponentiation with the base zero (0^b mod a, [code](https://github.com/hannob/bignum-fuzz/blob/master/matrixssl-base-zero.c), [CVE-2016-6885](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-6885)) it would crash with an invalid free operation, potentially leading to memory corruption.

In normal cryptographic operations these values should never appear. But these values are in many situations attacker controlled. One situation is during an RSA key exchange. What happens here is that a client encrypts a random secret with the server's key. However a malicious client could simply send a zero or the key's modulus here. I created a [patch against openssl that allows to test this](https://github.com/hannob/bignum-fuzz/blob/master/openssl-break-rsa-values.diff). Both values crash the MatrixSSL server. However the crash seems not to happen in pstm\_exptmod(), it hits another bug earlier ([CVE-2016-6886](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-6886)). In both cases the crash happens due to an invalid memory read in the function pstm\_reverse(), which is not prepared for zero-sized inputs and will underflow the len variable.

The crashes [have been fixed in 3.8.4](http://www.matrixssl.org/blog/releases/matrixssl_3_8_4), but the pstm\_exptmod() function still doesn't accept these inputs. However it no longer crashes with a zero base. It may be possible that these issues can be triggered through other code paths. I haven't tested Diffie Hellman key exchanges, which also allows putting attacker-controlled values into a modular exponentiation.

This is an interesting class of bugs. Bignum functions often aren't designed to handle all inputs and only consider values that make sense in the context of the cryptographic operations. However if they are attacker-controlled this may lead to problems. I just discovered a [somewhat similar issue in Nettle](https://lists.lysator.liu.se/pipermail/nettle-bugs/2016/003104.html). They switched their RSA implementation from GMP's mpz\_powm() function to mpz\_powm\_sec(), which is supposed to be sidechannel resistant. However mpz\_powm\_sec() is no drop-in replacement. Unlike mpz\_pown() it doesn't accept even moduli and crashes with a floating point error. Therefore when trying to use a specifically crafted RSA key with an even modulus this will crash. Fortunately this was discovered before the change made it into a release.

But back to MatrixSSL: Independent of these corner case values that lead to failures I was able to identify an input value that caused a wrong calculation result ([code](https://github.com/hannob/bignum-fuzz/blob/master/matrixssl-exptmod-bug.c),[CVE-2016-6887](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-6887).

There's a particularly severe risk with calculation errors in the modulo exponentiation when it comes to the RSA algorithm. A common way to speed up the calculation of RSA signatures is an algorithm based on the chinese remainder theorem (CRT) that splits it up into two smaller calculations. However if one of these calculations goes wrong an attacker can learn the private key. Last year [Florian Weimer observed that various devices had this error](https://access.redhat.com/blogs/766093/posts/1976703) and he could extract their keys. He recently mentioned on the [oss-security mailing list that he also observed this in devices using MatrixSSL](http://www.openwall.com/lists/oss-security/2016/06/27/1).

The way the MatrixSSL team "fixed" the miscalculation issue is not really satisfying: They now restrict the input to the pstm\_exptmod() function to a set of bit sizes (512, 1024, 1536, 2048, 3072, 4096). My test input had a different bit size, therefore I cannot reproduce the miscalculation any more, but the underlying bug is most likely still there. I've tried to find inputs matching these restrictions and still causing wrong results, but without success yet. Independent of that the restriction means that connections to sites with unusual key sizes or Diffie Hellman moduli will no longer work. While they are not common, there is no rule that RSA keys or Diffie Hellman moduli need to have certain sizes.

Despite the fact that the bug may be still there the CRT attack will probably no longer work. A protection mechanism against that was implemented in version 3.8.3.

I got told by the MatrixSSL developers that their bignum code is based on libtommath. Therefore I also checked if the same bugs appeared there. That wasn't the case. The test input causing wrong results in MatrixSSL were correctly calculated by libtommath and it was also capable of correctly using a zero base or a base equal to the modulus.

[0 Comments](/51-Fun-with-Bignums-Crashing-MatrixSSL-and-more.html#comments "0 Comments, 1 Trackback")

## [Use after free in my\_login() function of DBD::mysql (Perl module)](/50-Use-after-free-in-my_login-function-of-DBDmysql-Perl-module.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Monday, July 25. 2016

DBD::mysql versions 4.033 and earlier have a use after free bug in the my\_login() function. DBD::mysql is a Perl module providing bindings to the mysql database. The issue was fixed in version 4.034.

This issue was discovered with Address Sanitizer.

[Pull request / patch](https://github.com/perl5-dbi/DBD-mysql/pull/45)

[CVE-2015-8949](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-8949)

[0 Comments](/50-Use-after-free-in-my_login-function-of-DBDmysql-Perl-module.html#comments "0 Comments, 0 Trackbacks")

## Pagination

* Page 1 of 5, totaling 64 entries
* [next page →](https://blog.fuzzing-project.org/authors/1-H/P2.html)

## Sidebar

### The Fuzzing Project

You may want to go [back to the Fuzzing Project's main page](https://fuzzing-project.org/) or [software list](https://fuzzing-project.org/software/).

### Archives

* [January 2025](/archives/2025/01.html "January 2025")
* [December 2024](/archives/2024/12.html "December 2024")
* [November 2024](/archives/2024/11.html "November 2024")
* [Recent...](/index.php?frontpage)
* [Older...](https://blog.fuzzing-project.org/archive)

### Categories

* [![XML](/templates/2k11/img/xml.gif)](/feeds/categories/1-advisories.rss) [advisories](/categories/1-advisories)

### Syndicate This Blog

* [![XML](/templates/2k11/img/subtome.png)](https://blog.fuzzing-project.org/feeds/index.rss2)
* [![XML](/templates/2k11/img/xml.gif)](https://blog.fuzzing-project.org/feeds/comments.rss2)
  [Comments](https://blog.fuzzing-project.org/feeds/comments.rss2)

Powered by [Serendipity](http://s9y.org) & the *2k11* theme.



=== Content from blog.fuzzing-project.org_3020080d_20250125_070614.html ===

[Skip to content](#content)
[# The Fuzzing Project

Blog and Advisories](https://blog.fuzzing-project.org/)

Quicksearch

## Navigation

* [Back to main page](https://fuzzing-project.org/)
* [Software list](https://fuzzing-project.org/software.html)

## [Update on MatrixSSL miscalculation (CVE-2016-8671, incomplete fix for CVE-2016-6887)](/54-Update-on-MatrixSSL-miscalculation-CVE-2016-8671%2C-incomplete-fix-for-CVE-2016-6887.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Saturday, October 15. 2016

I recently reported how I found [various bugs in the bignum implementation of MatrixSSL](https://blog.fuzzing-project.org/51-Fun-with-Bignums-Crashing-MatrixSSL-and-more.html), some of them leading to remotely exploitable vulnerabilities.

One of the bugs was that the modular exponentiation function - pstm\_exptmod() - produced wrong results for some inputs . This wasn't really fixed, but only worked around by restricting the allowed size of the modulus. Not surprisingly it is still possible to find inputs that cause miscalculations ([code](https://github.com/hannob/bignum-fuzz/blob/master/matrixssl-exptmod-bug-variant2.c)). I reported this to MatrixSSL on August 1st.

Recently MatrixSSL released another update (3.8.6) [fixing several vulnerabilities reported by Craig Young from Tripwire](http://www.tripwire.com/state-of-security/security-data-protection/cyber-security/flawed-matrixssl-code-highlights-need-for-better-iot-update-practices/). However the pstm\_exptmod() bug is still there. (The incomplete fix got assigned [CVE-2016-8671](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-8671).)

It is unclear how exploitable such bugs are, but given that it's used in the context of cryptographic functions handling secret key material this is clearly a reason for concern.

MatrixSSL has long advertised itself as a safer alternative to OpenSSL, because it didn't suffer from the same kind of high severity bugs. I think it has been sufficiently shown that this was due to the fact that nobody was looking. But what's more worrying is that bugs they knew about for several months now don't get fixed properly.

[0 Comments](/54-Update-on-MatrixSSL-miscalculation-CVE-2016-8671%2C-incomplete-fix-for-CVE-2016-6887.html#comments "0 Comments, 0 Trackbacks")

### Trackbacks

[Trackback specific URI for this entry](https://blog.fuzzing-project.org/comment.php?type=trackback&entry_id=54 "This link is not meant to be clicked. It contains the trackback URI for this entry. You can use this URI to send ping- & trackbacks from your own blog to this entry. To copy the link, right click and select \"Copy Shortcut\" in Internet Explorer or \"Copy Link Location\" in Mozilla.")

No Trackbacks

### Comments

Display comments as
[Linear](/index.php?url=54-Update-on-MatrixSSL-miscalculation-CVE-2016-8671,-incomplete-fix-for-CVE-2016-6887.html&serendipity%5Bcview%5D=linear#comments) | Threaded

No comments

### Add Comment

Name

Email

Homepage

Comment

In reply to
[ Top level ]

Phone\*

What is three plus two?

Enclosing asterisks marks text as bold (\*word\*), underscore are made via \_word\_.Standard emoticons like :-) and ;-) are converted to images.E-Mail addresses will not be displayed and will only be used for E-Mail notifications.

To prevent automated Bots from commentspamming, please enter the string you see in the image below in the appropriate input box. Your comment will only be submitted if the strings match. Please ensure that your browser supports and accepts cookies, or your comment cannot be verified correctly.
![CAPTCHA](https://blog.fuzzing-project.org/plugin/captcha_a649c0933b7f9c0ecc7f1402859e739d "Enter the string you see here in the input box!")
Enter the string from the spam-prevention image above:

Form options
Remember Information?

Subscribe to this entry

## Sidebar

### The Fuzzing Project

You may want to go [back to the Fuzzing Project's main page](https://fuzzing-project.org/) or [software list](https://fuzzing-project.org/software/).

### Archives

* [January 2025](/archives/2025/01.html "January 2025")
* [December 2024](/archives/2024/12.html "December 2024")
* [November 2024](/archives/2024/11.html "November 2024")
* [Recent...](/index.php?frontpage)
* [Older...](https://blog.fuzzing-project.org/archive)

### Categories

* [![XML](/templates/2k11/img/xml.gif)](/feeds/categories/1-advisories.rss) [advisories](/categories/1-advisories)

### Syndicate This Blog

* [![XML](/templates/2k11/img/subtome.png)](https://blog.fuzzing-project.org/feeds/index.rss2)
* [![XML](/templates/2k11/img/xml.gif)](https://blog.fuzzing-project.org/feeds/comments.rss2)
  [Comments](https://blog.fuzzing-project.org/feeds/comments.rss2)

Powered by [Serendipity](http://s9y.org) & the *2k11* theme.



=== Content from fuzzing-project.org_71481b52_20250126_070409.html ===

The Fuzzing Project - Background

[The Fuzzing Project](/)

* [tutorials](tutorials.html)* [background](background.html)* [resources](resources.html)* [faq](faq.html)* [links](links.html)* [about](about.html)

* [blog / advisories](https://blog.fuzzing-project.org/)

### The Fuzzing Project

![american fuzzy lop](afl500.png)

Fuzzing is a powerful strategy to find bugs in software. The idea
is quite simple: Generate a large number of randomly malformed inputs
for a software to parse and see what happens. If the program crashes then
something is likely wrong.
While fuzzing is a well-known strategy, it is surprisingly easy
to find bugs, often with security implications, in widely used software.

Memory access errors are the errors most likely to be exposed when fuzzing software that is written in C/C++.
While they differ in the details (stack overflow,
heap overflow, use after free, ...), the core problem is often the same:
A software reads or writes to wrong memory locations.

A modern Linux or BSD system ships a large number of basic tools that
do some kind of file displaying and parsing.
In their current state most of these tools are not suitable for
untrusted inputs.

On the other hand we have powerful tools these days that allow us
to find and analyze these bugs, notably the fuzzing tool
american fuzzy lop
and the Address Sanitizer feature of gcc and clang.

The Fuzzing Project is trying to improve the state of things. I
maintain
some helpful pointers how you can join the effort to improve
the state of security in free software.

[![CC0](cc-zero.png)](https://creativecommons.org/publicdomain/zero/1.0/)

The Fuzzing Project is run by [Hanno Böck](https://hboeck.de/)



=== Content from www.openwall.com_c40187af_20250125_070614.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Hash Suite - Windows password security audit tool. GUI, reports in PDF.](https://hashsuite.openwall.net) | | --- | |
| --- | --- |

[[<prev]](1) [[next>]](3) [[thread-next>]](8) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <20161015173558.657276ad@pc1>
Date: Sat, 15 Oct 2016 17:35:58 +0200
From: Hanno Böck <hanno@...eck.de>
To: oss-security@...ts.openwall.com
Cc: cve-assign@...re.org
Subject: Update on MatrixSSL miscalculation (incomplete fix for
 CVE-2016-6887)

<https://blog.fuzzing-project.org/54-Update-on-MatrixSSL-miscalculation-incomplete-fix-for-CVE-2016-6887.html>

CVE-assigners: I think this could get a CVE as an incomplete fix for
CVE-2016-6887

----------

I recently [1] reported how I found various bugs in the bignum
implementation of MatrixSSL, some of them leading to remotely
exploitable vulnerabilities.

One of the bugs was that the modular exponentiation function -
pstm_exptmod() - produced wrong results for some inputs . This wasn't
really fixed, but only worked around by restricting the allowed size of
the modulus. Not surprisingly it is still possible to find inputs that
cause miscalculations (code). I reported this to MatrixSSL on August
1st.

Recently MatrixSSL released another update (3.8.6) fixing several
vulnerabilities reported by Craig Young from Tripwire [2]. However the
pstm_exptmod() bug is still there.

It is unclear how exploitable such bugs are, but given that it's used
in the context of cryptographic functions handling secret key material
this is clearly a reason for concern.

MatrixSSL has long advertised itself as a safer alternative to OpenSSL,
because it didn't suffer from the same kind of high severity bugs. I
think it has been sufficiently shown that this was due to the fact that
nobody was looking. But what's more worrying is that bugs they knew
about for several months now don't get fixed properly.

[1]
<https://blog.fuzzing-project.org/51-Fun-with-Bignums-Crashing-MatrixSSL-and-more.html>
[2]
<http://www.tripwire.com/state-of-security/security-data-protection/cyber-security/flawed-matrixssl-code-highlights-need-for-better-iot-update-practices/>

--
Hanno Böck
<https://hboeck.de/>

mail/jabber: hanno@...eck.de
GPG: FE73757FA60E4E21B937579FA5880072BBB51E42

View attachment "[matrixssl-exptmod-bug-variant2.c](2/1)" of type "text/x-c++src" (4564 bytes)

Content of type "application/pgp-signature" skipped

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from blog.fuzzing-project.org_ca789c8d_20250126_070411.html ===
xml version="1.0" encoding="iso-8859-1"?
1
Danger Will Robinson, trackback failed.


=== Content from blog.fuzzing-project.org_608e4ce0_20250126_070411.html ===

[Skip to content](#content)
[# The Fuzzing Project

Blog and Advisories](https://blog.fuzzing-project.org/)

Quicksearch

## Navigation

* [Back to main page](https://fuzzing-project.org/)
* [Software list](https://fuzzing-project.org/software.html)

## [When your Memory Allocator hides Security Bugs](/65-When-your-Memory-Allocator-hides-Security-Bugs.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Wednesday, January 30. 2019

![Memory](/uploads/ram.jpg)Recently I shared some information about potential [memory safety bugs in the Apache web server together with Craig Young](https://github.com/hannob/apache-uaf). One issue that came up in that context is the so-called pool allocator Apache is using.

What is this [pool allocator](https://apr.apache.org/docs/apr/1.6/group__apr__pools.html)? Apache’s APR library has a feature where you can allocate a pool, which is a larger area of memory, and then do memory allocations within that pool. It’s essentially a separate memory allocation functionality by the library. Similar concepts exist in other software.

Why would anyone do that? It might bring performance benefits to have memory allocation that’s optimized for a specific application. It also can make programming more convenient when you can allocate many small buffers in a pool and then not bothering about freeing each one of then and instead just free the whole pool with all allocations within.

There’s a disadvantage with the pool allocator, and that is that it may hide bugs. Let’s look at a simple code example:

#include <apr\_pools.h>

#include <stdio.h>

#include <string.h>

int main() {

apr\_pool\_t \*p;

char \*b1, \*b2;

apr\_initialize();

apr\_pool\_create(&p, NULL);

b1 = apr\_palloc(p, 6);

b2 = apr\_palloc(p, 6);

strcpy(b1, "This is too long");

strcpy(b2, "Short");

printf("%s %s\n", b1, b2);

}

We can compile this with:

`gcc $(pkg-config --cflags --libs apr-1) input.c`

What we’re doing here is that we create a pool p and we create two buffers (b1, b2) within that pool, each six byte. Now we fill those buffers with strings. However for b1 we fill it with a string that is larger than its size. This is thus a classic buffer overflow. The `printf` at the end which outputs both strings will show garbled output, because the two buffers interfere.

Now the question is how do we find such bugs? Of course we can carefully analyze the code, and in the simple example above this is easy to do. But in complex software such bugs are hard to find manually, therefore there are tools to detect unsafe memory access (e.g. buffer overflows, use after free) during execution. The state of the art tool is Address Sanitizer (ASAN). If you write C code and don’t use it for testing yet, you should start doing so now.

Address Sanitizer is part of both the gcc and clang compiler and it can be enabled by passing `-fsanitize=address` on the command line. We’ll also add -g, which adds debugging information and will give us better error messages. So let’s try:

`gcc -g -fsanitize=address $(pkg-config --cflags --libs apr-1) input.c`

If you try this you will find out that nothing has changed. We still see the garbled string and Address Sanitizer has not detected the buffer overflow.

Let’s try rewriting the above code in plain C without the pool allocator:

#include <stdio.h>

#include <string.h>

#include <stdlib.h>

int main() {

char \*b1, \*b2;

b1 = malloc(6);

b2 = malloc(6);

strcpy(b1, "This is too long");

strcpy(b2, "Short");

printf("%s %s\n", b1, b2);

}

If we compile and run this with ASAN it will give us a nice error message that tells us what’s going on:

==9319==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000016 at pc 0x7f81fdd08c9d bp 0x7ffe82881930 sp 0x7ffe828810d8

WRITE of size 17 at 0x602000000016 thread T0

#0 0x7f81fdd08c9c in \_\_interceptor\_memcpy /var/tmp/portage/sys-devel/gcc-8.2.0-r6/work/gcc-8.2.0/libsanitizer/sanitizer\_common/sanitizer\_common\_interceptors.inc:737

#1 0x5636994851e0 in main /tmp/input.c:10

#2 0x7f81fdb204ea in \_\_libc\_start\_main (/lib64/libc.so.6+0x244ea)

#3 0x5636994850e9 in \_start (/tmp/a.out+0x10e9)

0x602000000016 is located 0 bytes to the right of 6-byte region [0x602000000010,0x602000000016)

allocated by thread T0 here:

#0 0x7f81fddb6b10 in \_\_interceptor\_malloc /var/tmp/portage/sys-devel/gcc-8.2.0-r6/work/gcc-8.2.0/libsanitizer/asan/asan\_malloc\_linux.cc:86

#1 0x5636994851b6 in main /tmp/input.c:7

#2 0x7f81fdb204ea in \_\_libc\_start\_main (/lib64/libc.so.6+0x244ea)

So why didn’t the error show up when we used the pool allocator? The reason is that ASAN is built on top of the normal C memory allocation functions like `malloc`/`free`. It does not know anything about APR’s pools. From ASAN’s point of view the pool is just one large block of memory, and what’s happening inside is not relevant.

Thus we have a buffer overflow, but the state of the art tool to detect buffer overflows is unable to detect it. This is obviously not good, it means the pool allocator takes one of the most effective ways to discover an important class of security bugs away from us.

If you’re looking for solutions for that problem you may [find old documentation about "Debugging Memory Allocation in APR"](http://download.vikis.lt/manual/developer/debugging.html). However it relies on flags that have been removed from the APR library, so it’s not helpful. However there’s a not very well documented option of the APR library that allows us to gain memory safety checks back. Passing `--enable-pool-debug=yes` to the configure script will effectively disable the pool allocator and create a separate memory allocation for each call to the pool allocator.

If we compile our first example again, this time with the pool debugger and ASAN, we’ll see the error:

==20228==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000016 at pc 0x7fe2e625dc9d bp 0x7ffe8419a180 sp 0x7ffe84199928

WRITE of size 17 at 0x602000000016 thread T0

#0 0x7fe2e625dc9c in \_\_interceptor\_memcpy /var/tmp/portage/sys-devel/gcc-8.2.0-r6/work/gcc-8.2.0/libsanitizer/sanitizer\_common/sanitizer\_common\_interceptors.inc:737

#1 0x55fe439d132c in main /tmp/input.c:15

#2 0x7fe2e5fc34ea in \_\_libc\_start\_main (/lib64/libc.so.6+0x244ea)

#3 0x55fe439d1129 in \_start (/tmp/a.out+0x1129)

0x602000000016 is located 0 bytes to the right of 6-byte region [0x602000000010,0x602000000016)

allocated by thread T0 here:

#0 0x7fe2e630bb10 in \_\_interceptor\_malloc /var/tmp/portage/sys-devel/gcc-8.2.0-r6/work/gcc-8.2.0/libsanitizer/asan/asan\_malloc\_linux.cc:86

#1 0x7fe2e6203157 (/usr/lib64/libapr-1.so.0+0x1f157)

#2 0x7fe2e5fc34ea in \_\_libc\_start\_main (/lib64/libc.so.6+0x244ea)

Apache is not alone in having a custom memory allocation that can hide bugs. Mozilla’s NSPR and NSS libraries have something called an Arena Pool, Glib has memory slices and PHP has the Zend allocator. All of them have the potential of hiding memory safety bugs from ASAN, yet luckily all have an option to be turned off for testing. I maintain [a collection of information about such custom allocators and how to disable them](https://fuzzing-project.org/tutorial-malloc.html).

But back to Apache. When we started reporting use after free bugs we saw with the debugging option for the pool allocator we learned from the Apache developers that there are incompatibilities with the http2 module and the pool debugger. This has led to replies after our disclosure that these [are non-issues](https://icing.github.io/mod_h2/pool-debugging.html), because nobody should run the pool debugger in production.

It should be noted that we were also able to reproduce some bugs without the pool debugger in the latest Apache version (we have shared this information with Apache and will share it publicly later), and that indeed it seems some people did run the pool debugger in production (OpenBSD).

But I have another problem with this. If we consider that parts of the current Apache code are incompatible with the APR pool debugger then we end up with an unfortunate situation: If a tool like ASAN reports memory safety bugs with the pool debugger we don’t know if they are real issues or just incompatibilities. If we turn off the pool debugger we won’t see most of the memory safety bugs.

That’s a situation where testing Apache for memory safety bugs becomes practically very difficult. In my opinion that by itself is a worrying and severe security issue.

*Image source: [Dreamstime, CC0](https://www.dreamstime.com/ddr2-sdram-stands-double-data-rate-synchronous-dynamic-random-access-memory-interface-modules-used-desktop-pcs-public-domain-image-free-87854911)*

[0 Comments](/65-When-your-Memory-Allocator-hides-Security-Bugs.html#comments "0 Comments, 0 Trackbacks")

## [Stack buffer overflow in WolfSSL before 3.13.0](/63-Stack-buffer-overflow-in-WolfSSL-before-3.13.0.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Saturday, March 24. 2018

During some tests of TLS libraries I found a stack buffer overflow vulnerability in the WolfSSL library.

Finding this one was surprisingly simple: I had a wolfssl server that was compiled with address sanitizer and ran the SSL Labs test against it.

The bug happens in the parsing of the signature hash algorithm list that is sent in a ClientHello and is basically a textbook stack buffer overflow. WolfSSL simply tries to store that in an array with 32 elements. If one sends more than 32 hash algorithms it overflows.

With the SSL Labs scan the bug only causes WolfSSL to terminate if it's compiled with address sanitizer, but if one sends a very large list of hash algorithms it also crashes in a normal compile. In situations where WolfSSL is used without ASLR this bug is probably trivially exploitable.

I have created a simple [bash proof of concept](https://github.com/hannob/wolfoverflow) (using netcat and xxd) that crashes a WolfSSL server.

The bug was fixed in [this commit](https://github.com/wolfSSL/wolfssl/pull/1231/commits/9f7e40ad5c8097ff38d7caff4a9989db260981cc) and in version 3.13.0 of WolfSSL.

Categories: [advisories](https://blog.fuzzing-project.org/categories/1-advisories) | [0 Comments](/63-Stack-buffer-overflow-in-WolfSSL-before-3.13.0.html#comments "0 Comments, 0 Trackbacks")

## [FLIMP! The GIMP has some security problems](/62-FLIMP%21-The-GIMP-has-some-security-problems.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Tuesday, December 19. 2017

I recently got an E-Mail from Tobias Stöckmann, who reminded me of some bugs I had almost forgotten. When I started the Fuzzing Project I reported two bugs in import parsers of the GIMP. Tobias managed to write an exploit for one of them.

See [FLIMP!](https://flimp.fuzzing-project.org/) for more info.

[0 Comments](/62-FLIMP%21-The-GIMP-has-some-security-problems.html#comments "0 Comments, 0 Trackbacks")

## [How Optionsbleed wasn't found in 2014](/61-How-Optionsbleed-wasnt-found-in-2014.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Wednesday, September 20. 2017

Shortly after I [published details about the Optionsbleed bug](https://blog.fuzzing-project.org/60-Optionsbleed-HTTP-OPTIONS-method-can-leak-Apaches-server-memory.html) I learned about something quite surprising: Others had already discovered this bug before, but have neither pinned it down to Apache nor recognized that it is a security vulnerability.

A paper published in 2014 on Arxiv titled ["Support for Various HTTP Methods on the Web"](https://arxiv.org/pdf/1405.2330.pdf) mentions servers sending malformed Allow headers. It has examples listed that very clearly look like the output you get from a server vulnerable to Optionsbleed.

This alone would be noteworthy enough, but there's something that makes this even more surprising. This paper was published in May 2014, about a month after the Heartbleed bug was found. Heartbleed gained a lot of attention, not just in the tech scene, it was widely covered in the mainstream media. It can be assumed that almost everyone working in IT had heard of it.

So we have a situation where a major bug hit the news - and several people must have had evidence of a very similar bug in front of their eyes shortly afterwards. Yet nobody has recognized it as such. One of the authors [mentioned in a comment](https://blog.fuzzing-project.org/60-Optionsbleed-HTTP-OPTIONS-method-can-leak-Apaches-server-memory.html#c989) that they hadn't looked at it from a security perspective, but still you'd think that someone should have noticed.

While it's always problematic to interpret too much into single anecdotes, it still makes me wonder things. Are we just terribly bad at explaining security issues? My personal impression is that Heartbleed is actually an issue that is relatively simple to grasp (of course best explained by [XKCD](https://xkcd.com/1354/)). Going from there to the idea that seeing random garbage in HTTP headers indicates a very similar bug doesn't seem so far fetched to me. But the facts seem to disprove that.

[0 Comments](/61-How-Optionsbleed-wasnt-found-in-2014.html#comments "0 Comments, 0 Trackbacks")

## [Optionsbleed - HTTP OPTIONS method can leak Apache's server memory](/60-Optionsbleed-HTTP-OPTIONS-method-can-leak-Apaches-server-memory.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Monday, September 18. 2017

[![optionsbleed](/uploads/optionsbleed.serendipityThumb.png)](/uploads/optionsbleed.png)If you're using the HTTP protocol in everday Internet use you are usually only using two of its methods: GET and POST. However HTTP has a number of other methods, so I wondered what you can do with them and if there are any vulnerabilities.![](https://ssl-vg03.met.vgwort.de/na/cebfb3b02359461ab9ecf10beb28e327)
Categories: [advisories](https://blog.fuzzing-project.org/categories/1-advisories) | [16 Comments](/60-Optionsbleed-HTTP-OPTIONS-method-can-leak-Apaches-server-memory.html#comments "16 Comments, 2 Trackbacks")

## [Six year old PDF loop bug affects most major implementations](/59-Six-year-old-PDF-loop-bug-affects-most-major-implementations.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Sunday, September 3. 2017

![Endless Loop](/uploads/moebius-endless-loop.jpg)I recently did some testing of the qpdf library with afl and libfuzzer. I discovered an input sample that would generate a high CPU load spike and eventually after several minutes cause an out of memory error. It looked like the parser was caught in some kind of endless loop.

This reminded me of something. In [2011 at the Chaos Communication Camp Andreas Bogk gave a talk about creating a formally verified PDF parser with Ocaml and Coq](https://media.ccc.de/v/cccamp11-4426-certified_programming_with_dependent_types-en). In that talk he mentioned that one could create a PDF file with cross-referencing xref tables. A naive parser would get caught in an endless loop. He showed that the evince thumbnailer process was affected by this.

This was eventually fixed in evince's underlying rendering library poppler. But it seems this issue hasn't reached many other PDF parser libraries. The qpdf issue I had seen was exactly the [same bug](https://github.com/qpdf/qpdf/issues/149). The sample file can [be found here](https://github.com/andreas23/pdfparser/blob/master/tests/loop_edited.pdf). If you follow that link you'll immediately notice that Github's Javascript PDF viewer is also affected.

How about Mozilla Firefox? [Affected](https://bugzilla.mozilla.org/show_bug.cgi?id=1393476). (They use pdf.js, which is the same code Github uses.) What about Chrome / Chromium, which uses a library called PDFium? [Affected](https://bugs.chromium.org/p/pdfium/issues/detail?id=875). (Notably they already had a test PDF for this, but the function that causes the loop wasn't tested.) Microsoft Edge? [Affected](https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/13534806/). Ghostscript, which is the other major PDF parser used by many free and open source tools? [Also affected](https://bugs.ghostscript.com/show_bug.cgi?id=698409). For completeness, Adobe Reader and Apple's OS X internal PDF viewer were unaffected.

To make this clear: This isn't a major security issue, the impact is a denial of service. But it is certainly something undesirable that should be fixed.

It is remarkable that a bug that was discovered six years ago affected the majority of widely used PDF implementations. But it falls into a pattern of IT security: Very often discovering security issues means rediscovering old issues. In general this is a difficult problem to solve, as it touches complex questions about knowledge transfer.

However in this specific case - an input file that causes a bug in one implementation also causes the same bug in other implementations - there are things that can be done.

I report fuzzing-related bugs on a very regular basis and I always share a sample file that triggers the bug. In the best cases the maintainers of the affected software take the bug triggering sample and use it in their test suite. I think this should be a standard practice.

However that only prevents regressions in the same software. But maintainers of parsers for common file formats could also take a look at their competitors and check their test suites. While the PDF standard probably isn't well defined enough to allow a visual comparison of rendering output, it's surely obvious that no input file should cause a crash, an invalid memory access or an endless loop.

Looking at the common PDF libraries the situation with test cases was quite mixed. Mozilla's pdf.js had the most [extensive collection of files](https://github.com/mozilla/pdf.js/tree/master/test/pdfs), many of them examples from previous bugs. However one should know that about a third of them are not part of their code repository. They're referenced as links (all of them pointing to their own bug tracker or to the Internet archive, so I guess they're reasonably stable).

PDFium, used by Google Chrome, has a far less extensive test suite with only 96 PDF files. I have reported a bunch of PDFium bugs myself in the past (Examples: [[1]](https://bugs.chromium.org/p/chromium/issues/detail?id=450871), [[2]](https://bugs.chromium.org/p/chromium/issues/detail?id=457493), [[3]](https://bugs.chromium.org/p/chromium/issues/detail?id=450971)) and the test cases I provided never got added to the test suite.

QPDF is doing very well: They ship 278 test PDFs and for all the bugs I reported lately they added the provided sample files.

Ghostscript has only three PDF example files in its code (other PDFs in the code seem to be documentation, not test cases). Poppler's code has no PDFs bundled at all. They have a separate [test repository](https://cgit.freedesktop.org/poppler/test/) for that with 35 files, but it hasn't been updated since 2009. There's definitely lots of room for improvement in that area.

[Image Source](https://commons.wikimedia.org/wiki/File%3ACircle_Wind_Sculpture.jpg)

[9 Comments](/59-Six-year-old-PDF-loop-bug-affects-most-major-implementations.html#comments "9 Comments, 0 Trackbacks")

## [exiv2: multiple memory safety issues](/58-exiv2-multiple-memory-safety-issues.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Monday, July 3. 2017

*This post first appeared on [oss-security](http://www.openwall.com/lists/oss-security/2017/06/30/1).*

I'm reporting three issues here in exiv2, a parser libary for image metadata. These are only examples, exiv2 is full of memory safety bugs that can trivially be found by running afl with asan for a few hours.

I have not reported those issues upstream. When I previously tried to report bugs in exiv2 found via fuzzing the upstream author made it clear to me that he has little interest in fixing those issues and doesn't consider his software suitable to parse defect files (which basically means it's unsuitable for untrusted input). The [discussion can be read here](http://dev.exiv2.org/issues/1248). (the page is sometimes not available, searching for it in the google cache usually works though)

exiv2 is to my knowledge used by the major Linux Desktops GNOME and KDE. I'll also inform their security teams. I leave it up to Linux distros how to handle this, but it certainly is problematic that a crucial parser used by major desktop applications is not interested in fixing potential security issues.

**Heap overflow (write) in tiff parser**

A [malformed tiff file](https://crashes.fuzzing-project.org/exiv2-heap-oob-write.tiff) can cause a one byte heap overflow in exiv2.

Stack trace:

`==22873==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000df1 at pc 0x000000842091 bp 0x7fff51b3ee70 sp 0x7fff51b3ee68

WRITE of size 1 at 0x602000000df1 thread T0

#0 0x842090 in Exiv2::ul2Data(unsigned char*, unsigned int, Exiv2::ByteOrder) /f/exiv2-trunk/src/types.cpp:362:20

#1 0x68beac in long Exiv2::toData<unsigned int>(unsigned char*, unsigned int, Exiv2::ByteOrder) /f/exiv2-trunk/src/../include/exiv2/value.hpp:1459:16

#2 0x68beac in Exiv2::ValueType<unsigned int>::copy(unsigned char*, Exiv2::ByteOrder) const /f/exiv2-trunk/src/../include/exiv2/value.hpp:1612

#3 0x6742b2 in Exiv2::Exifdatum::copy(unsigned char*, Exiv2::ByteOrder) const /f/exiv2-trunk/src/exif.cpp:362:48

#4 0x7f794d in Exiv2::TiffImage::readMetadata() /f/exiv2-trunk/src/tiffimage.cpp:204:18

#5 0x59786a in Action::Print::printSummary() /f/exiv2-trunk/src/actions.cpp:289:16

#6 0x596ef8 in Action::Print::run(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /f/exiv2-trunk/src/actions.cpp:244:44

#7 0x55fb3f in main /f/exiv2-trunk/src/exiv2.cpp:170:25

#8 0x7f91c1e571d0 in __libc_start_main /var/tmp/portage/sys-libs/glibc-2.24-r2/work/glibc-2.24/csu/../csu/libc-start.c:289

#9 0x468979 in _start (/r/exiv2/exiv2+0x468979)

0x602000000df1 is located 0 bytes to the right of 1-byte region [0x602000000df0,0x602000000df1)

allocated by thread T0 here:

#0 0x55af00 in operator new[](unsigned long) (/r/exiv2/exiv2+0x55af00)

#1 0x83fadf in Exiv2::DataBuf::alloc(long) /f/exiv2-trunk/src/types.cpp:158:22`

**Heap out of bounds read in jp2 / JPEG2000 parser**

A [malformed jpeg2000 file](https://crashes.fuzzing-project.org/exiv2-heap-oob-read.jp2) causes a (large) out of bounds read.

Stack trace:

`==32038==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x7f5e099e6838 at pc 0x00000050f22c bp 0x7ffdf7f3dcd0 sp 0x7ffdf7f3d480

READ of size 808464432 at 0x7f5e099e6838 thread T0

#0 0x50f22b in __asan_memcpy (/r/exiv2/exiv2+0x50f22b)

#1 0x6e82bc in Exiv2::Jp2Image::readMetadata() /f/exiv2-trunk/src/jp2image.cpp:277:29

#2 0x59786a in Action::Print::printSummary() /f/exiv2-trunk/src/actions.cpp:289:16

#3 0x596ef8 in Action::Print::run(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /f/exiv2-trunk/src/actions.cpp:244:44

#4 0x55fb3f in main /f/exiv2-trunk/src/exiv2.cpp:170:25

#5 0x7f5e130a71d0 in __libc_start_main /var/tmp/portage/sys-libs/glibc-2.24-r2/work/glibc-2.24/csu/../csu/libc-start.c:289

#6 0x468979 in _start (/r/exiv2/exiv2+0x468979)

0x7f5e099e6838 is located 0 bytes to the right of 808452152-byte region [0x7f5dd96e6800,0x7f5e099e6838)

allocated by thread T0 here:

#0 0x55af00 in operator new[](unsigned long) (/r/exiv2/exiv2+0x55af00)

#1 0x6e8176 in Exiv2::DataBuf::DataBuf(long) /f/exiv2-trunk/src/../include/exiv2/types.hpp:204:46

#2 0x6e8176 in Exiv2::Jp2Image::readMetadata() /f/exiv2-trunk/src/jp2image.cpp:273

#3 0x59786a in Action::Print::printSummary() /f/exiv2-trunk/src/actions.cpp:289:16

#4 0x596ef8 in Action::Print::run(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /f/exiv2-trunk/src/actions.cpp:244:44

#5 0x7f5e130a71d0 in

__libc_start_main /var/tmp/portage/sys-libs/glibc-2.24-r2/work/glibc-2.24/csu/../csu/libc-start.c:289`

**Stack out of bounds read in webp parser**

A [malformed webp file](https://crashes.fuzzing-project.org/exiv2-stack-oob-read.webp) causes a six bytes stack out of bounds read.

Stack trace:

`==598==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffcc12aa054 at pc 0x0000004fe311 bp 0x7ffcc12a9f90 sp 0x7ffcc12a9740

READ of size 6 at 0x7ffcc12aa054 thread T0

#0 0x4fe310 in __interceptor_memcmp.part.76 (/r/exiv2/exiv2+0x4fe310)

#1 0x8889d0 in Exiv2::WebPImage::getHeaderOffset(unsigned char*, long, unsigned char*, long) /f/exiv2-trunk/src/webpimage.cpp:798:17

#2 0x8889d0 in Exiv2::WebPImage::decodeChunks(unsigned long) /f/exiv2-trunk/src/webpimage.cpp:601

#3 0x884ff2 in Exiv2::WebPImage::readMetadata() /f/exiv2-trunk/src/webpimage.cpp:496:20

#4 0x59786a in Action::Print::printSummary() /f/exiv2-trunk/src/actions.cpp:289:16

#5 0x596ef8 in Action::Print::run(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /f/exiv2-trunk/src/actions.cpp:244:44

#6 0x55fb3f in main /f/exiv2-trunk/src/exiv2.cpp:170:25

#7 0x7f7f9cc9f1d0 in __libc_start_main /var/tmp/portage/sys-libs/glibc-2.24-r2/work/glibc-2.24/csu/../csu/libc-start.c:289

#8 0x468979 in _start (/r/exiv2/exiv2+0x468979)

Address 0x7ffcc12aa054 is located in stack of thread T0 at offset 180 in frame

#0 0x885a0f in Exiv2::WebPImage::decodeChunks(unsigned long) /f/exiv2-trunk/src/webpimage.cpp:501

This frame has 13 object(s):

[32, 36) 'size_buff' (line 503)

[48, 64) 'payload' (line 516)

[80, 84) 'size_buf' (line 520)

[96, 100) 'size_buf48' (line 536)

[112, 114) 'size_buf_w' (line 551)

[128, 131) 'size_buf_h' (line 552)

[144, 148) 'size_buf112' (line 568)

[160, 162) 'size_buff152' (line 587)

[176, 180) 'exifLongHeader295' (line 588) <== Memory access at offset 180 overflows this variable

[192, 196) 'exifTiffBEHeader297' (line 591)

[208, 272) 'xmpData' (line 650)

[304, 688) 'temp.lvalue'

[752, 1136) 'temp.lvalue232'

HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext

(longjmp and C++ exceptions are supported)`

Categories: [advisories](https://blog.fuzzing-project.org/categories/1-advisories) | [0 Comments](/58-exiv2-multiple-memory-safety-issues.html#comments "0 Comments, 0 Trackbacks")

## [Diving into Control Flow Integrity](/57-Diving-into-Control-Flow-Integrity.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Friday, March 31. 2017

To improve security, modern systems contain many mitigation strategies that try to make it harder to exploit security vulnerabilities. Commonly used strategies include stack canaries, address space layout randomization (ASLR) and nonexecutable memory pages. Unfortunately the Linux distributions have been slow in adopting ASLR, but this is finally changing.

A new set of mitigation technologies has been discussed for a while under the umbrella term "Control Flow Integrity" (CFI). I won't get into technical details, but the very general idea is to add additional checks to the code that prohibit jumps to code parts that are not supposed to happen in the normal operation of a software.

LLVM's Clang compiler supports a form of CFI since version 3.7. Other forms of CFI are available under windows in Visual Studio ([CFGuard](https://msdn.microsoft.com/en-us/library/windows/desktop/mt637065%28v%3Dvs.85%29.aspx)) and with Grsecurity ([RAP](https://grsecurity.net/rap_announce.php)).

Recently I experimented a bit with the Clang version of CFI. It's been one of those situations where you dig into a topic and find out that it's really hard to Google for advice. The information out there is relatively limited: There's the [official LLVM documentation](https://clang.llvm.org/docs/ControlFlowIntegrity.html), a [talk by Kostya Serebryany that briefly mentions CFI in the second half](https://www.youtube.com/watch?v=qTkYDA0En6U) and [two](https://blog.trailofbits.com/2016/10/17/lets-talk-about-cfi-clang-edition/) [blog](https://blog.trailofbits.com/2017/02/20/the-challenges-of-deploying-security-mitigations/) posts by the company Trail of Bits. Also [Chrome is using a subset of the CFI functionality and there's a list of bugs found with it](https://www.chromium.org/developers/testing/control-flow-integrity).

Given the relatively scarce information when starting to use it you will experience situations where things fail and you won't find any help via Google.

So why would you want to use CFI? One possibility would be to create a super-hardened Linux system where, beyond using the "old" exploit mitigations like ASLR, one would also enable CFI. The computational costs of doing so are relatively small (Kostya Serebryany mentions in the talk above that they were unable to measure the CPU cost in Chrome). The executables grow in size and likely use more memory, but not in extraordinary amounts (below 10 percent). So from a performance side this is doable.

I started by compiling some small applications with CFI to see what happens. In some cases they "just work". In most cases I ended up having strange linker errors that were nontrivial to debug. Interesting for Linux distributions: There seems to be no dependency chain that needs to be considered (which is different from many of Clang's Sanitizer features). It's possible to have an executable built with CFI that depends on libraries not using CFI and it's also possible to have libraries using CFI that are used by executables not using CFI. This is good: If we'd strive for our super-hardened Linux we can easily exclude packages that create too many problems or start by including packages where we think they'd profit most from such extra protection.

CFI itself is enabled with the flag *-fsanitize=cfi*. It needs two other compiler and linker flags to work: *-fvisibility=hidden* for the compiler, which hides unnecessary symbols, and *-flto* for the linker to enable Link Time Optimization. The latter one needs the Gold linker, depending on your system you may need to install the LLVM gold plugin. If Gold isn't your default linker you can pass *-fuse-ld=gold*. Furthermore if you want to debug things you want to add *-fno-sanitize-trap=all* and enable extended debugging with *-g*, this will give you useful error messages in case CFI stops your application. (However you probably don't want to do that in production systems, as the error reporting can introduce additional bugs.)

In theory some of these flags only need to be passed to the compiler and others to the linker, but compilation systems aren't always strict in separating those, so we just add all of them to both.

So we can start compiling the current version of curl (7.53.1):
```
./configure CC=clang CXX=clang++ LD=clang CFLAGS="-fsanitize=cfi -fvisibility=hidden -fuse-ld=gold -flto" CXXFLAGS="-fsanitize=cfi -fvisibility=hidden -fuse-ld=gold -flto" LDFLAGS="-fsanitize=cfi -fvisibility=hidden -fuse-ld=gold -flto"

make
```

However we'll end up getting an error when it tries to link to the shared library. I guess it's a libtool problem, but I haven't digged into it. For now we can just disable the shared library by adding *--disable-shared*:
```
./configure CC=clang CXX=clang++ LD=clang CFLAGS="-fsanitize=cfi -fvisibility=hidden -fuse-ld=gold -flto" CXXFLAGS="-fsanitize=cfi -fvisibility=hidden -fuse-ld=gold -flto" LDFLAGS="-fsanitize=cfi -fvisibility=hidden -fuse-ld=gold -flto" --disable-shared
make
```

[0 Comments](/57-Diving-into-Control-Flow-Integrity.html#comments "0 Comments, 1 Trackback")

## [htpasswDoS: Local Denial of Service via Apache httpd password hashes](/56-htpasswDoS-Local-Denial-of-Service-via-Apache-httpd-password-hashes.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Tuesday, January 10. 2017

![Apache logo](/uploads/apache-httpd-logo.png)The way the Apache httpd web server handles password hashes can be abused by a malicious user on a server to cause resource exhaustion and denial of service of the web server. I reported this a while ago to the Apache security team - which led to a lengthy discussion where I was a bit appalled about some of the statements I got from the Apache developers. They can be summed up in a way that major use cases of Apache - especially in web hosting environments - are not recommended by their developers.![](https://ssl-vg03.met.vgwort.de/na/18d199e9596c4bdb82d4b86de95bc498)
Categories: [advisories](https://blog.fuzzing-project.org/categories/1-advisories) | [0 Comments](/56-htpasswDoS-Local-Denial-of-Service-via-Apache-httpd-password-hashes.html#comments "0 Comments, 0 Trackbacks")

## [Fuzzing Irssi with Perl Scripts](/55-Fuzzing-Irssi-with-Perl-Scripts.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Friday, January 6. 2017

When using fuzzing tools like afl a common challenge is how you can pass input to the interesting parts of the application you want to fuzz. In easy situations we have a tool that will accept our input as a file or via stdin. However sometimes this is not easily possible.

Let's have a look at Irssi, an irc chat client. The only input you can pass on the command line is a config file. Fuzzing Irssi 0.8.10 easily led to [a segfault caused by a null pointer access](https://github.com/irssi/irssi/issues/550). However while bugs in config file parsers probably still should be fixed, usually they are not very interesting. (There [can be exceptions](https://blog.fuzzing-project.org/8-Why-it-can-make-sense-to-fuzz-config-files-two-out-of-bounds-vulnerabilities-in-curl-TFPA-0042015.html).)

So what else might be interesting? Irssi does some parsing on all output, e.g. due to [color codes](https://irssi.org/documentation/settings/#a_d). However we can't just print text that is passed via the command line as an input file. We have to abuse Irssi's perl scripting capability for that.

We can place a [simple perl script](https://gitlab.com/hanno/irssi-fuzzing/blob/master/fuzz-print.pl) that will read a file (`fuzzp.txt`) and print it into Irssi's autorun directory (default location is ~/.Irssi/scripts/autorun/). We can then place some [examples of Irssi color codes](https://gitlab.com/hanno/irssi-fuzzing/blob/master/irssi-example-colorcodes.txt) into the directory "in/". I have installed an afl/asan-instrumented Irssi into my system to `/usr/local/`, because for running perl scripts it needs more than just the executable. So we can run afl like this:

`afl-fuzz -i in -o out -m none -f fuzzp.txt Irssi`

afl will put the fuzzed output into `fuzzp.txt` and our autoload script will read it from there. Doing this lets us learn that the sequence "%[" causes Irssi to read an invalid memory byte. For reasons unclear to me this only happens if a script outputs this sequence, not if a user types it in. (This issue got [CVE-2017-5196](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5196) assigned.)

We can go further and do a [similar script that executes input as a command](https://gitlab.com/hanno/irssi-fuzzing/blob/master/fuzz-command.pl). Commands are things like "/QUIT" that control the application and the channel behavior. I named the input file `fuzzc.txt`, so we can place some [simple Irssi commands](https://gitlab.com/hanno/irssi-fuzzing/blob/master/fuzz-command.pl) into `in/` and run:

`afl-fuzz -i in -o out -m none -f fuzzc.txt Irssi`

Thus we will now fuzz Irssi's command processing.

As we have seen, scripting functionality can be used to fuzz an application. So if you want to fuzz something and don't know how to pass input: See if there's a scripting functionality.

*Irssi has issued a [security advisory for several security vulnerabilities](https://irssi.org/security/irssi_sa_2017_01.txt), including the out of bounds read mentioned above. All vulnerabilities and the config file parser segfault are fixed in 0.8.21 and 1.0.0.*

Categories: [advisories](https://blog.fuzzing-project.org/categories/1-advisories) | [0 Comments](/55-Fuzzing-Irssi-with-Perl-Scripts.html#comments "0 Comments, 0 Trackbacks")

## [Update on MatrixSSL miscalculation (CVE-2016-8671, incomplete fix for CVE-2016-6887)](/54-Update-on-MatrixSSL-miscalculation-CVE-2016-8671%2C-incomplete-fix-for-CVE-2016-6887.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Saturday, October 15. 2016

I recently reported how I found [various bugs in the bignum implementation of MatrixSSL](https://blog.fuzzing-project.org/51-Fun-with-Bignums-Crashing-MatrixSSL-and-more.html), some of them leading to remotely exploitable vulnerabilities.

One of the bugs was that the modular exponentiation function - pstm\_exptmod() - produced wrong results for some inputs . This wasn't really fixed, but only worked around by restricting the allowed size of the modulus. Not surprisingly it is still possible to find inputs that cause miscalculations ([code](https://github.com/hannob/bignum-fuzz/blob/master/matrixssl-exptmod-bug-variant2.c)). I reported this to MatrixSSL on August 1st.

Recently MatrixSSL released another update (3.8.6) [fixing several vulnerabilities reported by Craig Young from Tripwire](http://www.tripwire.com/state-of-security/security-data-protection/cyber-security/flawed-matrixssl-code-highlights-need-for-better-iot-update-practices/). However the pstm\_exptmod() bug is still there. (The incomplete fix got assigned [CVE-2016-8671](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-8671).)

It is unclear how exploitable such bugs are, but given that it's used in the context of cryptographic functions handling secret key material this is clearly a reason for concern.

MatrixSSL has long advertised itself as a safer alternative to OpenSSL, because it didn't suffer from the same kind of high severity bugs. I think it has been sufficiently shown that this was due to the fact that nobody was looking. But what's more worrying is that bugs they knew about for several months now don't get fixed properly.

[0 Comments](/54-Update-on-MatrixSSL-miscalculation-CVE-2016-8671%2C-incomplete-fix-for-CVE-2016-6887.html#comments "0 Comments, 0 Trackbacks")

## [Out of bounds heap bugs in glib, heap buffer overflow in gnome-session](/53-Out-of-bounds-heap-bugs-in-glib%2C-heap-buffer-overflow-in-gnome-session.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Friday, September 16. 2016

By testing GNOME-related packages with Address Sanitizer I recently discovered several trivial to find bugs.

Two out of bounds bugs in the glib library were uncovered by running the test suite with Address Sanitizer enabled. One heap buffer overflow in the parameter parsing of gnome-session was uncovered by trying to start GNOME. Given that these bugs weren't discovered earlier means that most likely nobody ever used Address Sanitizer to test GNOME components.

I strongly recommend to GNOME and to other software communities to use Address Sanitizer testing in order to improve the quality of their software.

Out of bounds read in g\_unichar\_iswide\_bsearch() / glib

[Upstream bug report](https://bugzilla.gnome.org/show_bug.cgi?id=762493) (again reported [here](https://bugzilla.gnome.org/show_bug.cgi?id=766211))

[Commit / fix](https://git.gnome.org/browse/glib/commit/?id=bcbd8d7)

Fixed in 2.48.2.

Out of bounds read in token\_stream\_prepare() / glib

[Upstream bug report](https://bugzilla.gnome.org/show_bug.cgi?id=762417)

[Commit / fix](https://git.gnome.org/browse/glib/commit/glib/gvariant-parser.c?id=aead1c046dd39748cca449b55ec300ba5f025365)

Fixed in 2.48.0.

Heap buffer overflow in gnome-session

[Upstream bug report](https://bugzilla.gnome.org/show_bug.cgi?id=768441)

[Commit / fix](https://git.gnome.org/browse/gnome-session/commit/?h=gnome-3-20&id=634ab70d9f03b1650be4b8259091ca3036f0fbf9)

Fixed in 3.20.2.

Categories: [advisories](https://blog.fuzzing-project.org/categories/1-advisories) | [0 Comments](/53-Out-of-bounds-heap-bugs-in-glib%2C-heap-buffer-overflow-in-gnome-session.html#comments "0 Comments, 0 Trackbacks")

## [Multiple vulnerabilities in RPM – and a rant](/52-Multiple-vulnerabilities-in-RPM-and-a-rant.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Friday, August 26. 2016

Last year in November I decided that it might be a good idea to fuzz the parsers of package management tools in Linux distributions. I quickly found a couple of issues in DPKG and RPM. For DPKG the process went very smooth. I reported them to Debian's security team, eight days later fixes and security advisories were published by both Debian and Ubuntu, the main distributions using DPKG. For RPM the process was a bit more difficult.

If you want to report a bug to RPM you first may wonder where to report it. The RPM webpage [1] is a trac installation which has its own bug tracker. However if you try to register an account there you'll get forwarded to an HTTPS site with an expired certificate that doesn't match the domain name. In case you are brave and tell your browser to ignore all warnings you'll be greeted by a broken-looking trac without any CSS. Should you proceed and create an account you will learn that this doesn't help you, because in order to be allowed to report a bug you first have to ask on the mailing list or in the IRC channel for permission [2]. That's probably the point where many well-meaning bug reporters give up.

Okay, but RPM originally stood for “Red Hat package manager” (I've been told that today it stands for RPM Package Manager), so maybe Red Hat feels responsible. So I reported three bugs with sample files triggering them to the Red Hat security team on November 20th. The answer was – to put it mildly – a bit dissatisfying. I'll just fully quote it: “Thanks for the report. We also received about 30+ crash reports in RPM from

a different reporter recently so processing all of them (yours and the

others) will take quite a bit of time. We simply don't have the resources

to spend hours upon hours analyzing all crash reports.”

Okay, so I wasn't the only one fuzzing RPM and the maybe bugs will be fixed some day. I waited. In the meantime I got contacted by another person who also had tried to report fuzzing bugs in RPM and who has made similar experiences (maybe the same person who reported the 30+ crashers, I don't know).

In February I decided to ask what the state of things is. I also gave them a 30 day period until I'd publish the bugs (I know that it's now long past that, I shouldn't have let this issue wait so long). I ended up having a call with a Red Hat security team member and exchanged a couple of mails. I learned that RPM has a Github repository [3], which contains fixes for some (but not all) of the issues I reported, however that's nowhere referenced on its webpage. I then fuzzed the current RPM git code again and found two more issues I also reported to the Red Hat security team.

Status today is that the latest release of RPM on its webpage – 4.12.0.1 - is from July 2015, so all of the bugs still affect this release. However it seems there is an unofficial 4.13 release that's nowhere to be found on the RPM webpage, but Red Hat is using it together with some fixes [4]. And the Github repository says the latest release is 4.12.0, so according to three different sources three different versions are the current one (4.12.0, 4.12.0.1, 4.13).

One of the bugs – a stack overflow (write) - is still present in the latest code on Github.

**Commend and Conclusion**

This blog post probably reads like a big rant about how unprofessional Red Hat is in handling potential security issues. But this is contrary to my usual experience. I often see Red Hat developers being very active in the free software security community and often contributing in a positive way. Quite simply I expect better from Red Hat. This is not some dubious Enterprise vendor where I wouldn't be the least bit surprised of such a reaction.

The development process of RPM seems to be totally chaotic, it's neither clear where one reports bugs nor where one gets the latest code and security bugs don't get fixed within a reasonable time.

There's been some recent events that make me feel especially worried about this: An unknown person has created an entry in the Libarchive issue tracker [5] that points to an anonymous document [6] with a very detailed description of various security weaknesses in the FreeBSD update process (most of them are still unfixed). The most worrying thing about this is however that the anonymous post mentions the existence similar documents affecting multiple Linux distributions. These documents haven't shown up publicly yet and given the unclear nature of this incident it's hard to know whether they ever will become public or exist at all. But this should still be reason enough to have a closer look at potential security vulnerabilities in all pieces of Linux package management systems.

I haven't analyzed the RPM installation process in detail, so I can't say how likely it is that the RPM tool ever sees a malformed input file. It seems downloads happen over HTTP, but the first thing that happens is a signature check. As the signature is part of the RPM file it already needs to be parsed for this. The exact impact of these bugs would require further analysis. But independent of how likely this is I think the parser in such a crucial piece of software should be robust. It should be safe to use the rpm tool to show info about a file on the command line.

[1] <http://rpm.org/>

[2] <http://rpm.org/wiki/ReportingBugs>

[3] <https://github.com/rpm-software-management/rpm>

[4] <http://pkgs.fedoraproject.org/cgit/rpms/rpm.git/diff/rpm-4.13.0-rpmtd-out-of-bounds.patch?h=f22&id=165614f3dd42caa188f78b55e7723dad2900b2f4>

[5] <https://github.com/libarchive/libarchive/issues/743>

[6] <https://gist.github.com/anonymous/e48209b03f1dd9625a992717e7b89c4f>

All bugs were found with the help of american fuzzy lop. Here are the bugs:

Stack Overflow in glob() / rpmglob.c.

Sample file (test with rpm -i [input]):

<https://crashes.fuzzing-project.org/rpm-stackoverflow-glob.rpm>

Unfixed in the current Git code.

Heap out of bounds read in headerVerifyInfo() / header.c.

Sample file (test with “rpm -i [input]”):

<https://crashes.fuzzing-project.org/rpm-heap-oob-read-headerVerifyInfo.rpm>

Git commit:

<https://github.com/rpm-software-management/rpm/commit/8e847d52c811e9a57239e18672d40f781e0ec48e>

Null pointer access / segfault in stringFormat() / formats.c

Sample file (test with “rpm -i [input]”):

<https://crashes.fuzzing-project.org/rpm-nullptr-rpmtdFormat.rpm>

Git commit:

<https://github.com/rpm-software-management/rpm/commit/cddf43a56f19711866371f02f378dc4095b0fadd>

Out of bounds read in rpmtdGetNumber() / rpmtd.c

Sample file (test with “rpm -qi -p -- [input]”)

<https://crashes.fuzzing-project.org/rpm-heap-oob-read-rpmtdGetNumber.rpm>

Git commit:

<https://github.com/rpm-software-management/rpm/commit/b722cf86200505b3e3fcbb2095c4ff61f1f5a2ab>

Finally one annoying thing to admit: In my original report I included another segfault in headerVerifyInfo() with unclear reasons. However I am now unable to reproduce this one. It may be due to compiler options, different command line parameters or dependencies on my system that have changed. For completeness I'm still providing the sample file:

<https://crashes.fuzzing-project.org/rpm-segfault-headerVerifyInfo.rpm>

(Ideally the RPM developers should include all those sample files in a test suite they regularly run against an address sanitizer build of RPM.)

Please also note that I expect this list to be incomplete and there are likely more issues that could be uncovered with further fuzzing. I'll test that once all the existing issues are fixed.

Categories: [advisories](https://blog.fuzzing-project.org/categories/1-advisories) | [11 Comments](/52-Multiple-vulnerabilities-in-RPM-and-a-rant.html#comments "11 Comments, 0 Trackbacks")

## [Fun with Bignums: Crashing MatrixSSL and more](/51-Fun-with-Bignums-Crashing-MatrixSSL-and-more.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Sunday, July 31. 2016

If you've been following my fuzzing work you will be aware that I've fuzzed various bignum libraries and found several bugs by comparing implementations against each other.

I recently had a look at the MatrixSSL's modular exponentiation function, for reasons I'll explain later. I wrote [a wrapper, similar to previous experiments, comparing its result to OpenSSL](https://github.com/hannob/bignum-fuzz/blob/master/openssl-vs-matrixssl-modexp.c).

I immediately noted that the pstm\_exptmod() function of MatrixSSL has certain limitations that weren't documented. If one tries to calculate a modular exponentiation with the base equal to the modulus (a^b mod a, [code](https://github.com/hannob/bignum-fuzz/blob/master/matrixssl-base-equals-modulus.c)) it would return an error. If one tries to calculate a modular exponentiation with the base zero (0^b mod a, [code](https://github.com/hannob/bignum-fuzz/blob/master/matrixssl-base-zero.c), [CVE-2016-6885](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-6885)) it would crash with an invalid free operation, potentially leading to memory corruption.

In normal cryptographic operations these values should never appear. But these values are in many situations attacker controlled. One situation is during an RSA key exchange. What happens here is that a client encrypts a random secret with the server's key. However a malicious client could simply send a zero or the key's modulus here. I created a [patch against openssl that allows to test this](https://github.com/hannob/bignum-fuzz/blob/master/openssl-break-rsa-values.diff). Both values crash the MatrixSSL server. However the crash seems not to happen in pstm\_exptmod(), it hits another bug earlier ([CVE-2016-6886](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-6886)). In both cases the crash happens due to an invalid memory read in the function pstm\_reverse(), which is not prepared for zero-sized inputs and will underflow the len variable.

The crashes [have been fixed in 3.8.4](http://www.matrixssl.org/blog/releases/matrixssl_3_8_4), but the pstm\_exptmod() function still doesn't accept these inputs. However it no longer crashes with a zero base. It may be possible that these issues can be triggered through other code paths. I haven't tested Diffie Hellman key exchanges, which also allows putting attacker-controlled values into a modular exponentiation.

This is an interesting class of bugs. Bignum functions often aren't designed to handle all inputs and only consider values that make sense in the context of the cryptographic operations. However if they are attacker-controlled this may lead to problems. I just discovered a [somewhat similar issue in Nettle](https://lists.lysator.liu.se/pipermail/nettle-bugs/2016/003104.html). They switched their RSA implementation from GMP's mpz\_powm() function to mpz\_powm\_sec(), which is supposed to be sidechannel resistant. However mpz\_powm\_sec() is no drop-in replacement. Unlike mpz\_pown() it doesn't accept even moduli and crashes with a floating point error. Therefore when trying to use a specifically crafted RSA key with an even modulus this will crash. Fortunately this was discovered before the change made it into a release.

But back to MatrixSSL: Independent of these corner case values that lead to failures I was able to identify an input value that caused a wrong calculation result ([code](https://github.com/hannob/bignum-fuzz/blob/master/matrixssl-exptmod-bug.c),[CVE-2016-6887](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-6887).

There's a particularly severe risk with calculation errors in the modulo exponentiation when it comes to the RSA algorithm. A common way to speed up the calculation of RSA signatures is an algorithm based on the chinese remainder theorem (CRT) that splits it up into two smaller calculations. However if one of these calculations goes wrong an attacker can learn the private key. Last year [Florian Weimer observed that various devices had this error](https://access.redhat.com/blogs/766093/posts/1976703) and he could extract their keys. He recently mentioned on the [oss-security mailing list that he also observed this in devices using MatrixSSL](http://www.openwall.com/lists/oss-security/2016/06/27/1).

The way the MatrixSSL team "fixed" the miscalculation issue is not really satisfying: They now restrict the input to the pstm\_exptmod() function to a set of bit sizes (512, 1024, 1536, 2048, 3072, 4096). My test input had a different bit size, therefore I cannot reproduce the miscalculation any more, but the underlying bug is most likely still there. I've tried to find inputs matching these restrictions and still causing wrong results, but without success yet. Independent of that the restriction means that connections to sites with unusual key sizes or Diffie Hellman moduli will no longer work. While they are not common, there is no rule that RSA keys or Diffie Hellman moduli need to have certain sizes.

Despite the fact that the bug may be still there the CRT attack will probably no longer work. A protection mechanism against that was implemented in version 3.8.3.

I got told by the MatrixSSL developers that their bignum code is based on libtommath. Therefore I also checked if the same bugs appeared there. That wasn't the case. The test input causing wrong results in MatrixSSL were correctly calculated by libtommath and it was also capable of correctly using a zero base or a base equal to the modulus.

[0 Comments](/51-Fun-with-Bignums-Crashing-MatrixSSL-and-more.html#comments "0 Comments, 1 Trackback")

## [Use after free in my\_login() function of DBD::mysql (Perl module)](/50-Use-after-free-in-my_login-function-of-DBDmysql-Perl-module.html)

Posted by [Hanno Böck](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck) on Monday, July 25. 2016

DBD::mysql versions 4.033 and earlier have a use after free bug in the my\_login() function. DBD::mysql is a Perl module providing bindings to the mysql database. The issue was fixed in version 4.034.

This issue was discovered with Address Sanitizer.

[Pull request / patch](https://github.com/perl5-dbi/DBD-mysql/pull/45)

[CVE-2015-8949](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-8949)

[0 Comments](/50-Use-after-free-in-my_login-function-of-DBDmysql-Perl-module.html#comments "0 Comments, 0 Trackbacks")

## Pagination

* Page 1 of 5, totaling 64 entries
* [next page →](https://blog.fuzzing-project.org/authors/1-Hanno-Boeck/P2.html)

## Sidebar

### The Fuzzing Project

You may want to go [back to the Fuzzing Project's main page](https://fuzzing-project.org/) or [software list](https://fuzzing-project.org/software/).

### Archives

* [January 2025](/archives/2025/01.html "January 2025")
* [December 2024](/archives/2024/12.html "December 2024")
* [November 2024](/archives/2024/11.html "November 2024")
* [Recent...](/index.php?frontpage)
* [Older...](https://blog.fuzzing-project.org/archive)

### Categories

* [![XML](/templates/2k11/img/xml.gif)](/feeds/categories/1-advisories.rss) [advisories](/categories/1-advisories)

### Syndicate This Blog

* [![XML](/templates/2k11/img/subtome.png)](https://blog.fuzzing-project.org/feeds/index.rss2)
* [![XML](/templates/2k11/img/xml.gif)](https://blog.fuzzing-project.org/feeds/comments.rss2)
  [Comments](https://blog.fuzzing-project.org/feeds/comments.rss2)

Powered by [Serendipity](http://s9y.org) & the *2k11* theme.



=== Content from www.openwall.com_04a45b08_20250125_070614.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Follow @Openwall on Twitter for new release announcements and other news](https://twitter.com/openwall) | | --- | |
| --- | --- |

[[<prev]](7) [[next>]](9) [[<thread-prev]](2) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-Id: <20161015165046.C3C9842E192@smtpvbsrv1.mitre.org>
Date: Sat, 15 Oct 2016 12:50:46 -0400 (EDT)
From: cve-assign@...re.org
To: hanno@...eck.de
Cc: cve-assign@...re.org, oss-security@...ts.openwall.com
Subject: Re: Update on MatrixSSL miscalculation (incomplete fix for CVE-2016-6887)

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

> <https://blog.fuzzing-project.org/54-Update-on-MatrixSSL-miscalculation-incomplete-fix-for-CVE-2016-6887.html>
>
> This wasn't
> really fixed, but only worked around by restricting the allowed size of
> the modulus. Not surprisingly it is still possible to find inputs that
> cause miscalculations

Use CVE-2016-8671.

- --
CVE Assignment Team
M/S M300, 202 Burlington Road, Bedford, MA 01730 USA
[ A PGP key is available for encrypted communications at
  <http://cve.mitre.org/cve/request_id.html> ]
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQIcBAEBCAAGBQJYAltIAAoJEHb/MwWLVhi2zbEP/2dfjbYAydVRa5AoGGA7TPmb
xILs2/DjLQhrk9/jLLwQ64Is/c9JrGHTSt7repvMcitLMAhDgVrlH+6LFa7z7inx
WPx1eqz4hI84Rs8/56MlGSjXTjLEiTQm5curt42r8VnVy66P+kAYRYmgSn6viHti
dnWeyY1nHM0Bj7xbh2rDS+WGiMdyKbD58JE1M9c/x40ypA7PHeyiOaEQiI0kkV/g
GBV74nCAljX+4pznRutKPQTJr8gSo7KzBKCRMhZJUIMcIEWITHxZ4bhDSOvGE5ZV
jtKDs4ALgYOh04IcYXam+TsnpO0TWtUE6IcbmvnBsnzKOt92sypRNQg/7ieMzvuk
qqFPKi5yjR2jDkCi0AXpfciWEOFeJECbxoKS5Q8TIuToC/DbMndN57BuaSaL/g+6
sffL7qTjUdYtOjOLjGt/pAUjWCYu6mkoxiT+naD/oBU1UVQsBgBuYCQ4z99Joa7D
da22R9nUvL+khiic6nvQTCVMP2CqJji4TAoe6zbBTX7HxYGW53e7HvH0Lk7UAIF6
nHgbB+3uf6PetCTA7lPkc/UHdFhYoV8VtpLQA4KOu2fqkGByhb8HifJvYS6YMZCt
NH9CYar381eIYh5/w7+rzFLF0jTwxjKrbMrkcHPq3jvoBfRbHk+Fatbt1w6vv2Ww
0RWeF3ma0TjarX46TTMB
=PwKE
-----END PGP SIGNATURE-----

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from fuzzing-project.org_cea1a41d_20250126_070410.html ===

The Fuzzing Project - apps

[The Fuzzing Project](/)

* [tutorials](tutorials.html)* [background](background.html)* [resources](resources.html)* [faq](faq.html)* [links](links.html)* [about](about.html)

* [blog / advisories](https://blog.fuzzing-project.org/)

I'm no longer maintaining this list, as it was extremely outdated.

[![CC0](cc-zero.png)](https://creativecommons.org/publicdomain/zero/1.0/)

The Fuzzing Project is run by [Hanno Böck](https://hboeck.de/)


