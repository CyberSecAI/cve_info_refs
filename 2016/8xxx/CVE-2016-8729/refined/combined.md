=== Content from www.talosintelligence.com_ae9500e2_20250126_000937.html ===


* [Cisco Login](/users/auth/saml)

* [Intelligence Center](/reputation)

  + [# Intelligence Center](/reputation)
  + BACK
  + [Intelligence Search](/reputation_center)
  + [Email & Spam Trends](/reputation_center/email_rep)
* [Vulnerability Research](/vulnerability_info)

  + [# Vulnerability Research](/vulnerability_info)
  + BACK
  + [Vulnerability Reports](/vulnerability_reports)
  + [Microsoft Advisories](/ms_advisories)
* [Incident Response](/incident_response)

  + [# Incident Response](/incident_response)
  + BACK
  + [Reactive Services](/incident_response/services#reactive-services)
  + [Proactive Services](/incident_response/services#proactive-services)
  + Emergency Support
* [Blog](https://blog.talosintelligence.com)
* [Support](https://support.talosintelligence.com)

More

* Security Resources

  # Security Resources

  + BACK
  Security Resources
  + [Open Source Security Tools](/software)
  + [Intelligence Categories Reference](/categories)
  + [Secure Endpoint Naming Reference](/secure-endpoint-naming)
* Media

  # Media

  + BACK
  Media
  + [Talos Intelligence Blog](https://blog.talosintelligence.com)
  + [Threat Source Newsletter](https://blog.talosintelligence.com/category/threat-source-newsletter/)
  + [Beers with Talos Podcast](/podcasts/shows/beers_with_talos)
  + [Talos Takes Podcast](/podcasts/shows/talos_takes)
  + [Talos Videos](https://www.youtube.com/channel/UCPZ1DtzQkStYBSG3GTNoyfg/featured)
* Company

  # Company

  + BACK
  Company
  + [About Talos](/about)
  + [Careers](/careers)

* Under Attack?
* [Cisco Login](/users/auth/saml)

## Contact Cisco Talos Incident Response

×

Close

This form is for Incident Response service inquiries only, including emergency network security needs.

For reputation or categorization inquiries, visit the [Talos Support site](/support).
For emergency DDoS mitigation assistance, please contact the [Cisco Secure DDoS Protection Team](https://www.cisco.com/c/en/us/products/collateral/security/ddos-emergency-attack-mitigation-aag.pdf).

Name

Company (optional)

Email address

Phone number

Preferred communication:

Email

Phone

What Incident Response Service are you interested in?
General Talos IR services and retainer information
Emergency Response
IR Plan
IR Playbooks
IR Readiness Assessment
Tabletop Exercises
Compromise Assessment
Threat Hunting
Cyber Range Training
Intelligence on Demand

Please provide as much detail as possible so we can best address your needs

I acknowledge that this is an inquiry for Incident Response services and that any other use of this form will not receive a response.

Send Email
Cancel

# Talos Vulnerability Report

### TALOS-2016-0243

## Artifex MuPDf JBIG2 Parser Code Execution Vulnerability

##### May 15, 2017

##### CVE Number

CVE-2016-8729

### Summary

An exploitable memory corruption vulnerability exists in the JBIG2 parser of Artifex MuPDF 1.9. A specially crafted PDF can cause a negative number to be passed to a memset resulting in memory corruption and potential code execution. An attacker can specially craft a PDF and send to the victim to trigger this vulnerability.

### Tested Versions

MuPDF 1.9
MuPDF 1.10 RC2

### Product URLs

<http://mupdf.com/>

### CVSSv3 Score

7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H

### CWE

CWE-122: Heap-based Buffer Overflow

### Details

MuPDF is a lightweight PDF, XPS, and E-Book viewer that has packages available for Windows as well as Android, iPad, and iPhone.

During the parsing of a JBIG2 image embedded in a PDF, each image segment is handled based on the flags for that particular segment. Segments with flags 38 or 39 are handled by calling `jbig2_immediate_generic_region` on the current segment [0].

```
thirdparty/jbig2dec/jbig2_segment.c:227
/* general segment parsing dispatch */
int
jbig2_parse_segment(Jbig2Ctx *ctx, Jbig2Segment *segment, const uint8_t *segment_data)
{
    jbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number,
                "Segment %d, flags=%x, type=%d, data_length=%d", segment->number, segment->flags, segment->flags & 63, segment->data_length);
    switch (segment->flags & 63) {
    ...
        case 38:                   /* immediate generic region */
        case 39:                   /* immediate lossless generic region */
            return jbig2_immediate_generic_region(ctx, segment, segment_data); [0]

```

Each segment is lifted into a `Jbig2RegionSegmentInfo` object by reading the segment header information. Two key values are extracted during `jbig2_get_region_segment_info` [1]: width and height [2].

```
thirdparty/jbig2dec/jbig2_segment.c:227
    /**
    * Handler for immediate generic region segments
    */
    int
    jbig2_immediate_generic_region(Jbig2Ctx *ctx, Jbig2Segment *segment, const byte *segment_data)
    {
        Jbig2RegionSegmentInfo rsi;
        ...
        jbig2_get_region_segment_info(&rsi, segment_data); [1]
        ...
        image = jbig2_image_new(ctx, rsi.width, rsi.height); [3]

thirdparty/jbig2dec/jbig2_segment.c:186
    void
    jbig2_get_region_segment_info(Jbig2RegionSegmentInfo *info, const uint8_t *segment_data)
    {
        /* 7.4.1 */
        info->width = jbig2_get_int32(segment_data);      [2]
        info->height = jbig2_get_int32(segment_data + 4); [2]
        info->x = jbig2_get_int32(segment_data + 8);
        info->y = jbig2_get_int32(segment_data + 12);
        info->flags = segment_data[16];
        info->op = (Jbig2ComposeOp)(info->flags & 0x7);
    }

```

After extracting the width and height from the segment, `jbig2_image_new` is called [3]. A `stride` value is calculated from the width and subsequently checked to ensure a multiplication overflow won’t occur [4]. Assuming this check is passed, the resulting stride value is stored in an image object and returned.

```
thirdparty/jbig2dec/jbig2_image.c:34
Jbig2Image *
jbig2_image_new(Jbig2Ctx *ctx, int width, int height)
{
    Jbig2Image *image;
	...
	stride = ((width - 1) >> 3) + 1;    /* generate a byte-aligned stride */
	/* check for integer multiplication overflow */
	check = ((int64_t) stride) * ((int64_t) height); [4]
	if (check != (int)check) {
		jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, "integer multiplication overflow from stride(%d)*height(%d)", stride, height);
		jbig2_free(ctx->allocator, image);
		return NULL;
	}
	...
	image->stride = stride; [5]
    ...
    return image;
}

```

If the `MMR` flag is set in the image segment flags, then the resulting image is passed to `jbig2_decode_generic_mmr`. During this decoding, the `stride` value is used directly as the `size` value in a `memset` [6].

```
int
jbig2_decode_generic_mmr(Jbig2Ctx *ctx, Jbig2Segment *segment, const Jbig2GenericRegionParams *params, const byte *data, size_t size, Jbig2Image *image)
{
	Jbig2MmrCtx mmr;
	const int rowstride = image->stride;
	...

	for (y = 0; y < image->height; y++) {
		memset(dst, 0, rowstride); [6]
		...
	}
}

```

Using the calculation of `stride = ((width - 1) >> 3) + 1;`, a negative value for `stride` can be achieved. Passing this negative value to `memset` results in a buffer overflow condition that could possibly be leveraged to gain code execution.

### Crash Information

Dr. Memory output

```
~~Dr.M~~ Error #1: UNADDRESSABLE ACCESS beyond heap bounds: writing 0x0000000002a7f350-0x0000000002a7f354 4 byte(s)
~~Dr.M~~ # 0 replace_memset                                 [/work/drmemory_package/drmemory/replace.c:201]
~~Dr.M~~ # 1 jbig2_decode_generic_mmr                       [thirdparty/jbig2dec/jbig2_mmr.c:1021]
~~Dr.M~~ # 2 jbig2_immediate_generic_region                 [thirdparty/jbig2dec/jbig2_generic.c:766]
~~Dr.M~~ # 3 jbig2_parse_segment                            [thirdparty/jbig2dec/jbig2_segment.c:249]
~~Dr.M~~ # 4 jbig2_data_in                                  [thirdparty/jbig2dec/jbig2.c:312]
~~Dr.M~~ # 5 fz_load_jbig2_globals                          [source/fitz/filter-jbig2.c:350]
~~Dr.M~~ # 6 pdf_load_jbig2_globals                         [source/pdf/pdf-stream.c:72]
~~Dr.M~~ # 7 build_filter                                   [source/pdf/pdf-stream.c:181]
~~Dr.M~~ # 8 pdf_open_filter                                [source/pdf/pdf-stream.c:313]
~~Dr.M~~ # 9 pdf_open_image_stream                          [source/pdf/pdf-stream.c:412]
~~Dr.M~~ #10 pdf_load_image_stream                          [source/pdf/pdf-stream.c:569]
~~Dr.M~~ #11 pdf_load_compressed_stream                     [source/pdf/pdf-stream.c:612]
~~Dr.M~~ #12 pdf_load_image_imp                             [source/pdf/pdf-image.c:160]
~~Dr.M~~ #13 pdf_load_image                                 [source/pdf/pdf-image.c:283]
~~Dr.M~~ #14 pdf_process_Do                                 [source/pdf/pdf-interpret.c:555]
~~Dr.M~~ #15 pdf_process_keyword                            [source/pdf/pdf-interpret.c:992]
~~Dr.M~~ #16 pdf_process_stream                             [source/pdf/pdf-interpret.c:1170]
~~Dr.M~~ #17 pdf_process_contents                           [source/pdf/pdf-interpret.c:1242]
~~Dr.M~~ #18 pdf_run_page_contents_with_usage               [source/pdf/pdf-run.c:41]
~~Dr.M~~ #19 pdf_run_page_contents                          [source/pdf/pdf-run.c:62]
~~Dr.M~~ Note: @0:00:00.538 in thread 16021
~~Dr.M~~ Note: refers to 0 byte(s) beyond last valid byte in prior malloc
~~Dr.M~~ Note: prev lower malloc:  0x0000000002a7f350-0x0000000002a7f350
~~Dr.M~~ Note: allocated here:
~~Dr.M~~ Note: # 0 replace_malloc                               [/work/drmemory_package/common/alloc_replace.c:2576]
~~Dr.M~~ Note: # 1 jbig2_default_alloc                          [thirdparty/jbig2dec/jbig2.c:36]
~~Dr.M~~ Note: # 2 jbig2_alloc                                  [thirdparty/jbig2dec/jbig2.c:63]
~~Dr.M~~ Note: # 3 jbig2_image_new                              [thirdparty/jbig2dec/jbig2_image.c:56]
~~Dr.M~~ Note: # 4 jbig2_immediate_generic_region               [thirdparty/jbig2dec/jbig2_generic.c:760]
~~Dr.M~~ Note: # 5 jbig2_parse_segment                          [thirdparty/jbig2dec/jbig2_segment.c:249]
~~Dr.M~~ Note: # 6 jbig2_data_in                                [thirdparty/jbig2dec/jbig2.c:312]
~~Dr.M~~ Note: # 7 fz_load_jbig2_globals                        [source/fitz/filter-jbig2.c:350]
~~Dr.M~~ Note: # 8 pdf_load_jbig2_globals                       [source/pdf/pdf-stream.c:72]
~~Dr.M~~ Note: # 9 build_filter                                 [source/pdf/pdf-stream.c:181]
~~Dr.M~~ Note: #10 pdf_open_filter                              [source/pdf/pdf-stream.c:313]
~~Dr.M~~ Note: #11 pdf_open_image_stream                        [source/pdf/pdf-stream.c:412]
~~Dr.M~~ Note: instruction: mov    %eax -> (%rbx)

```

Valgrind output

```
==19258== Memcheck, a memory error detector
==19258== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==19258== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==19258== Command: ./build/release/mutool convert -o /tmp/asdfasdf -F png ../smart_jbig_crashes_mupdf/04637126fea55ca2a3bf243a3ccfe2858922d943.pdf
==19258==
warning: jbig2dec warning: MMR is 1, but GBTEMPLATE is not 0 (segment 0)
==19258== Invalid write of size 8
==19258==    at 0x4C3453F: memset (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==19258==    by 0x5A697F: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x5A3939: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x5451E0: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x4D4DE6: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x4A5614: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x4A5942: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x4A5EBD: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x4A5F9A: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x4A6108: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x4A63CC: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x4AF887: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==  Address 0x5799f60 is 0 bytes after a block of size 0 alloc'd
==19258==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==19258==    by 0x5457E0: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x5A3745: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x5451E0: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x4D4DE6: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x4A5614: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x4A5942: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x4A5EBD: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x4A5F9A: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x4A6108: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x4A63CC: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)
==19258==    by 0x4AF887: ??? (in /home/vagrant/fuzzing/mupdf/mupdf-orig/build/release/mutool)

```
### Timeline

2016-11-29 - Vendor Disclosure

2017-05-15 - Public Release

##### Credit

Discovered by Aleksandar Nikolic and Cory Duplantis of Cisco Talos

---

[Vulnerability Reports](/vulnerability_reports) [Next Report

TALOS-2016-0242](/vulnerability_reports/TALOS-2016-0242) [Previous Report

TALOS-2017-0320](/vulnerability_reports/TALOS-2017-0320)

* + ###### [Intelligence Center](/reputation)
  + [Intelligence Search](/reputation_center)
  + [Email & Spam Trends](/reputation_center/email_rep)
* + ###### [Vulnerability Research](/vulnerability_info)
  + [Vulnerability Reports](/vulnerability_reports)
  + [Microsoft Advisories](/ms_advisories)
* + ###### [Incident Response](/incident_response)
  + [Reactive Services](/incident_response/services#reactive-services)
  + [Proactive Services](/incident_response/services#proactive-services)
  + Emergency Support
* + ###### Security Resources
  + [Open Source Security Tools](/software)
  + [Intelligence Categories Reference](/categories)
  + [Secure Endpoint Naming Reference](/secure-endpoint-naming)
* + ###### Media
  + [Talos Intelligence Blog](https://blog.talosintelligence.com)
  + [Threat Source Newsletter](https://blog.talosintelligence.com/category/threat-source-newsletter/)
  + [Beers with Talos Podcast](/podcasts/shows/beers_with_talos)
  + [Talos Takes Podcast](/podcasts/shows/talos_takes)
  + [Talos Videos](https://www.youtube.com/channel/UCPZ1DtzQkStYBSG3GTNoyfg/featured)
* + ###### Support
  + [Support Documentation](https://support.talosintelligence.com)
* + ###### Company
  + [About Talos](/about)
  + [Careers](/careers)
  + [Cisco Security](https://www.cisco.com/c/en/us/products/security/product-listing.html)

###### Follow us

[![Cisco](/assets/logo_cisco_white-d87b7f7d3152ad412e48aad924a972cc5b802b7a53cb56b0792a4456c9b7b3a5.svg)](http://tools.cisco.com/security/center/home.x)

©
2025
Cisco Systems, Inc. and/or its affiliates. All rights
reserved. View our
[Privacy Policy.](http://www.cisco.com/web/siteassets/legal/privacy_full.html)



=== Content from bugs.ghostscript.com_9207c9c0_20250126_000933.html ===


Bugzilla – Bug 697395
Artifex MuPDf JBIG2 Parser Code Execution Vulnerability
Last modified: 2024-09-13 16:12:09 UTC

* [Home](./)
* | [New](enter_bug.cgi)
* | [Browse](describecomponents.cgi)
* | [Search](query.cgi)
* |

  [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")
* | [Reports](report.cgi)
* |
  [Help](https://bugzilla.readthedocs.org/en/5.0/using/understanding.html)
* |
  [New Account](createaccount.cgi)
* |
  [Log In](show_bug.cgi?id=697395&GoAheadAndLogIn=1)

  [x]
* |
  [Forgot Password](show_bug.cgi?id=697395&GoAheadAndLogIn=1#forgot)
  Login:

  [x]

[**Bug 697395**](show_bug.cgi?id=697395)
- Artifex MuPDf JBIG2 Parser Code Execution Vulnerability

[Summary:](page.cgi?id=fields.html#short_desc "The bug summary is a short sentence which succinctly describes what the bug is about.")
Artifex MuPDf JBIG2 Parser Code Execution Vulnerability

| | [Status](page.cgi?id=fields.html#bug_status): | RESOLVED FIXED | | --- | --- | |  | | | [Alias:](page.cgi?id=fields.html#alias "A short, unique name assigned to a bug in order to assist with looking it up and referring to it in other places in Bugzilla.") | None | |  | | | [Product:](describecomponents.cgi "Bugs are categorised into Products and Components.") | MuPDF | | [Classification:](page.cgi?id=fields.html#classification "Bugs are categorised into Classifications, Products and Components. classifications is the top-level categorisation.") | Unclassified | | [Component:](describecomponents.cgi?product=MuPDF "Components are second-level categories; each belongs to a particular Product. Select a Product to narrow down this list.") | mupdf ([show other bugs](buglist.cgi?component=mupdf&product=MuPDF&bug_status=__open__)) | | [Version:](page.cgi?id=fields.html#version "The version field defines the version of the software the bug was found in.") | unspecified | | [Hardware:](page.cgi?id=fields.html#rep_platform "The hardware platform the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | PC All | |  | | | [Importance](page.cgi?id=fields.html#importance): | P2 normal | | [Assignee:](page.cgi?id=fields.html#assigned_to "The person in charge of resolving the bug.") | Robin Watts | |  | | | [URL:](page.cgi?id=fields.html#bug_file_loc "Bugs can have a URL associated with them - for example, a pointer to a web site where the problem is seen.") |  | | [Keywords:](describekeywords.cgi "You can add keywords from a defined list to bugs, in order to easily identify and group them.") |  | |  | | | [Depends on:](page.cgi?id=fields.html#dependson "The bugs listed here must be resolved before this bug can be resolved.") |  | | [Blocks:](page.cgi?id=fields.html#blocked "This bug must be resolved before the bugs listed in this field can be resolved.") |  | |  | | Reported: | 2016-11-29 12:51 UTC by regiwils | | --- | --- | | Modified: | 2024-09-13 16:12 UTC ([History](show_activity.cgi?id=697395)) | | CC List: | 4 users (show)  henry.stiles michael.vrhel regiwils sebastian.rasmussen | |  | | | [See Also:](page.cgi?id=fields.html#see_also "This allows you to refer to bugs in other installations. You can enter a URL to a bug in the 'Add Bug URLs' field to note that that bug is related to this one. You can enter multiple URLs at once by separating them with whitespace. You should normally use this field to refer to bugs in other installations. For bugs in this installation, it is better to use the Depends on and Blocks fields.") |  | | [Customer:](page.cgi?id=fields.html#cf_customer "A custom Free Text field in this installation of Bugzilla.") |  | | [Word Size:](page.cgi?id=fields.html#cf_wordsize "For example x86 would be 32 and x86_64 would be 64.") | --- | |  | | |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| --- | | |

| | Attachments | | | --- | --- | | [Add an attachment](attachment.cgi?bugid=697395&action=enter) (proposed patch, testcase, etc.) | |   | Note You need to [log in](show_bug.cgi?id=697395&GoAheadAndLogIn=1) before you can comment on or make changes to this bug. | | --- | |  |
| --- | --- | --- | --- | --- | --- | --- |

| [Comment 7](show_bug.cgi?id=697395#c7)  Robin Watts    2017-02-28 09:19:33 UTC  ``` Proposed fix:  <http://git.ghostscript.com/?p=user/robin/mupdf.git;a=commitdiff;h=29f0e3a6ea0cb02ae0c20a2d0f19561804af01ec>  Doesn't appear to be a JBIG2 issue at all, rather a scaling issue.  Will retry with the 1.9 source in case it appears differently. ```  [Comment 8](show_bug.cgi?id=697395#c8)  Robin Watts    2017-03-01 06:03:54 UTC  ``` file_1.pdf problem fixed with:  commit [0c86abf954ca4a5f00c26f6600acac93f9fc3538](http://www.ghostscript.com/cgi-bin/findgit.cgi?0c86abf954ca4a5f00c26f6600acac93f9fc3538) Author: Robin Watts <robin.watts@artifex.com> Date:   Tue Feb 28 17:15:40 2017 +0000      [Bug 697395](show_bug.cgi?id=697395 "RESOLVED FIXED - Artifex MuPDf JBIG2 Parser Code Execution Vulnerability"): Fix underflow in special case scaler.      When scaling a single row pixmap with a flip, I was getting     the offset to the far end of the line wrong due to forgetting     to allow for the alpha plane.      Fixed here.  file_2.pdf problem does not reproduce, hence closing.  Thanks for the report. Please reopen with new information if it still misbehaves for you. ```  [Comment 9](show_bug.cgi?id=697395#c9)  Sebastian Rasmussen    2024-09-13 16:12:09 UTC  ``` (In reply to Robin Watts from [comment #8](show_bug.cgi?id=697395#c8)) > file_2.pdf problem does not reproduce, hence closing.  I can successfully reproduce the issue with modern valgrind, and bisecting reveals that jbig2dec fixed this in  commit [e698d5c11d27212aa1098bc5b1673a3378563092](http://www.ghostscript.com/cgi-bin/findgit.cgi?e698d5c11d27212aa1098bc5b1673a3378563092) (HEAD) Author: Robin Watts <robin.watts@artifex.com> Date:   Mon Dec 12 17:47:17 2016 +0000      Squash signed/unsigned warnings in MSVC jbig2 build.      Also rename "new" to "new_dict", because "new" is a bad     variable name.  Which was later included in  commit [1a7ef61410884daff8ff8391ddcecc3102acd989](http://www.ghostscript.com/cgi-bin/findgit.cgi?1a7ef61410884daff8ff8391ddcecc3102acd989) Author: Tor Andersson <tor.andersson@artifex.com> Date:   Tue Dec 27 15:07:32 2016 +0100      Update jbig2dec. ``` |  |
| --- | --- |

---

* [Format For Printing](show_bug.cgi?format=multiple&id=697395)
* - [XML](show_bug.cgi?ctype=xml&id=697395)
* - [Clone This Bug](enter_bug.cgi?cloned_bug_id=697395)
* - Top of page

* + [Home](./)
  + | [New](enter_bug.cgi)
  + | [Browse](describecomponents.cgi)
  + | [Search](query.cgi)
  + |

    [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")
  + | [Reports](report.cgi)
  + |
    [Help](https://bugzilla.readthedocs.org/en/5.0/using/understanding.html)
  + |
    [New Account](createaccount.cgi)
  + |
    [Log In](show_bug.cgi?id=697395&GoAheadAndLogIn=1)

    [x]
  + |
    [Forgot Password](show_bug.cgi?id=697395&GoAheadAndLogIn=1#forgot)
    Login:

    [x]



=== Content from cgit.ghostscript.com_656fe9ff_20250126_000936.html ===


| [cgit logo](/cgi-bin/cgit.cgi/) | [index](/cgi-bin/cgit.cgi/) : [mupdf.git](/cgi-bin/cgit.cgi/mupdf.git/ "mupdf.git") | 1.18.x 1.19.x 1.20.x 1.21.x 1.22.x 1.23.x 1.24.x 1.25.x android-muso android-muso-signing android-openjpeg-2.3.1 css fontconfig java-empty-store lcms lcms2 line\_art\_filter master muso muso-3.9-release muso-temporary-hack objc-openjpeg-2.3.1 release-1.10a release\_1.8 so so-tess2 stext-flags win-openjpeg-2.3.1 winRT winphone |
| --- | --- | --- |
| MuPDF library | Chris Liddell |

| [summary](/cgi-bin/cgit.cgi/mupdf.git/)[refs](/cgi-bin/cgit.cgi/mupdf.git/refs/?id=1a7ef61410884daff8ff8391ddcecc3102acd989)[log](/cgi-bin/cgit.cgi/mupdf.git/log/)[tree](/cgi-bin/cgit.cgi/mupdf.git/tree/?id=1a7ef61410884daff8ff8391ddcecc3102acd989)[commit](/cgi-bin/cgit.cgi/mupdf.git/commit/?id=1a7ef61410884daff8ff8391ddcecc3102acd989)[diff](/cgi-bin/cgit.cgi/mupdf.git/diff/?id=1a7ef61410884daff8ff8391ddcecc3102acd989) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Tor Andersson <tor.andersson@artifex.com> | 2016-12-27 15:07:32 +0100 |
| --- | --- | --- |
| committer | Tor Andersson <tor.andersson@artifex.com> | 2016-12-27 15:07:32 +0100 |
| commit | [1a7ef61410884daff8ff8391ddcecc3102acd989](/cgi-bin/cgit.cgi/mupdf.git/commit/?id=1a7ef61410884daff8ff8391ddcecc3102acd989) ([patch](/cgi-bin/cgit.cgi/mupdf.git/patch/?id=1a7ef61410884daff8ff8391ddcecc3102acd989)) | |
| tree | [32627467ada4724e38377fde23f087806300c482](/cgi-bin/cgit.cgi/mupdf.git/tree/?id=1a7ef61410884daff8ff8391ddcecc3102acd989) | |
| parent | [6975007f314a4c392e2cb616e7c3297ed167c2a7](/cgi-bin/cgit.cgi/mupdf.git/commit/?id=6975007f314a4c392e2cb616e7c3297ed167c2a7) ([diff](/cgi-bin/cgit.cgi/mupdf.git/diff/?id=1a7ef61410884daff8ff8391ddcecc3102acd989&id2=6975007f314a4c392e2cb616e7c3297ed167c2a7)) | |

Update jbig2dec.[Diffstat](/cgi-bin/cgit.cgi/mupdf.git/diff/?id=1a7ef61410884daff8ff8391ddcecc3102acd989)

| m--------- | [thirdparty/jbig2dec](/cgi-bin/cgit.cgi/mupdf.git/diff/thirdparty/jbig2dec?id=1a7ef61410884daff8ff8391ddcecc3102acd989) | 0 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 0 insertions, 0 deletions

| diff --git a/thirdparty/jbig2dec b/thirdparty/jbig2dec-Subproject e698d5c11d27212aa1098bc5b1673a337856309+Subproject 9d2c4f3bdb0bd003deae788e7187c0f86e62454 |
| --- |

generated by [cgit v1.2.3](https://git.zx2c4.com/cgit/about/) ([git 2.25.1](https://git-scm.com/)) at 2025-01-26 00:09:35 +0000



=== Content from cgit.ghostscript.com_e9414187_20250126_000935.html ===


| [cgit logo](/cgi-bin/cgit.cgi/) | [index](/cgi-bin/cgit.cgi/) : [jbig2dec.git](/cgi-bin/cgit.cgi/jbig2dec.git/ "jbig2dec.git") | jbig2dec-0.17 master |
| --- | --- | --- |
| JBIG2 Decoder library | Tor Andersson |

| [summary](/cgi-bin/cgit.cgi/jbig2dec.git/)[refs](/cgi-bin/cgit.cgi/jbig2dec.git/refs/?id=e698d5c11d27212aa1098bc5b1673a3378563092)[log](/cgi-bin/cgit.cgi/jbig2dec.git/log/)[tree](/cgi-bin/cgit.cgi/jbig2dec.git/tree/?id=e698d5c11d27212aa1098bc5b1673a3378563092)[commit](/cgi-bin/cgit.cgi/jbig2dec.git/commit/?id=e698d5c11d27212aa1098bc5b1673a3378563092)[diff](/cgi-bin/cgit.cgi/jbig2dec.git/diff/?id=e698d5c11d27212aa1098bc5b1673a3378563092) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Robin Watts <robin.watts@artifex.com> | 2016-12-12 17:47:17 +0000 |
| --- | --- | --- |
| committer | Robin Watts <robin.watts@artifex.com> | 2016-12-13 00:21:55 +0000 |
| commit | [e698d5c11d27212aa1098bc5b1673a3378563092](/cgi-bin/cgit.cgi/jbig2dec.git/commit/?id=e698d5c11d27212aa1098bc5b1673a3378563092) ([patch](/cgi-bin/cgit.cgi/jbig2dec.git/patch/?id=e698d5c11d27212aa1098bc5b1673a3378563092)) | |
| tree | [8d92900606438857a0266f749a5510174fc29dd3](/cgi-bin/cgit.cgi/jbig2dec.git/tree/?id=e698d5c11d27212aa1098bc5b1673a3378563092) | |
| parent | [1369359f21a1c8a055cc745f920b17fbc3f30efd](/cgi-bin/cgit.cgi/jbig2dec.git/commit/?id=1369359f21a1c8a055cc745f920b17fbc3f30efd) ([diff](/cgi-bin/cgit.cgi/jbig2dec.git/diff/?id=e698d5c11d27212aa1098bc5b1673a3378563092&id2=1369359f21a1c8a055cc745f920b17fbc3f30efd)) | |

Squash signed/unsigned warnings in MSVC jbig2 build.Also rename "new" to "new\_dict", because "new" is a bad
variable name.
[Diffstat](/cgi-bin/cgit.cgi/jbig2dec.git/diff/?id=e698d5c11d27212aa1098bc5b1673a3378563092)

| -rw-r--r-- | [jbig2.c](/cgi-bin/cgit.cgi/jbig2dec.git/diff/jbig2.c?id=e698d5c11d27212aa1098bc5b1673a3378563092) | 4 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [jbig2.h](/cgi-bin/cgit.cgi/jbig2dec.git/diff/jbig2.h?id=e698d5c11d27212aa1098bc5b1673a3378563092) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [jbig2\_generic.c](/cgi-bin/cgit.cgi/jbig2dec.git/diff/jbig2_generic.c?id=e698d5c11d27212aa1098bc5b1673a3378563092) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [jbig2\_halftone.c](/cgi-bin/cgit.cgi/jbig2dec.git/diff/jbig2_halftone.c?id=e698d5c11d27212aa1098bc5b1673a3378563092) | 24 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [jbig2\_huffman.c](/cgi-bin/cgit.cgi/jbig2dec.git/diff/jbig2_huffman.c?id=e698d5c11d27212aa1098bc5b1673a3378563092) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [jbig2\_huffman.h](/cgi-bin/cgit.cgi/jbig2dec.git/diff/jbig2_huffman.h?id=e698d5c11d27212aa1098bc5b1673a3378563092) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [jbig2\_image.c](/cgi-bin/cgit.cgi/jbig2dec.git/diff/jbig2_image.c?id=e698d5c11d27212aa1098bc5b1673a3378563092) | 32 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [jbig2\_mmr.c](/cgi-bin/cgit.cgi/jbig2dec.git/diff/jbig2_mmr.c?id=e698d5c11d27212aa1098bc5b1673a3378563092) | 66 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [jbig2\_page.c](/cgi-bin/cgit.cgi/jbig2dec.git/diff/jbig2_page.c?id=e698d5c11d27212aa1098bc5b1673a3378563092) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [jbig2\_priv.h](/cgi-bin/cgit.cgi/jbig2dec.git/diff/jbig2_priv.h?id=e698d5c11d27212aa1098bc5b1673a3378563092) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [jbig2\_segment.c](/cgi-bin/cgit.cgi/jbig2dec.git/diff/jbig2_segment.c?id=e698d5c11d27212aa1098bc5b1673a3378563092) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [jbig2\_symbol\_dict.c](/cgi-bin/cgit.cgi/jbig2dec.git/diff/jbig2_symbol_dict.c?id=e698d5c11d27212aa1098bc5b1673a3378563092) | 73 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [jbig2\_symbol\_dict.h](/cgi-bin/cgit.cgi/jbig2dec.git/diff/jbig2_symbol_dict.h?id=e698d5c11d27212aa1098bc5b1673a3378563092) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [jbig2\_text.c](/cgi-bin/cgit.cgi/jbig2dec.git/diff/jbig2_text.c?id=e698d5c11d27212aa1098bc5b1673a3378563092) | 16 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [jbig2\_text.h](/cgi-bin/cgit.cgi/jbig2dec.git/diff/jbig2_text.h?id=e698d5c11d27212aa1098bc5b1673a3378563092) | 2 | |  |  |  | | --- | --- | --- | |

15 files changed, 134 insertions, 131 deletions

| diff --git a/jbig2.c b/jbig2.cindex f729e29..e51380f 100644--- a/[jbig2.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2.c?id=1369359f21a1c8a055cc745f920b17fbc3f30efd)+++ b/[jbig2.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2.c?id=e698d5c11d27212aa1098bc5b1673a3378563092)@@ -379,7 +379,7 @@ typedef struct { } Jbig2WordStreamBuf;  static int-jbig2\_word\_stream\_buf\_get\_next\_word(Jbig2WordStream \*self, int offset, uint32\_t \*word)+jbig2\_word\_stream\_buf\_get\_next\_word(Jbig2WordStream \*self, size\_t offset, uint32\_t \*word) { Jbig2WordStreamBuf \*z = (Jbig2WordStreamBuf \*) self; const byte \*data = z->data;@@ -390,7 +390,7 @@ jbig2\_word\_stream\_buf\_get\_next\_word(Jbig2WordStream \*self, int offset, uint32\_t else if (offset > z->size) return -1; else {- int i;+ size\_t i;  result = 0; for (i = 0; i < z->size - offset; i++)diff --git a/jbig2.h b/jbig2.hindex d5aa52f..624e0ed 100644--- a/[jbig2.h](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2.h?id=1369359f21a1c8a055cc745f920b17fbc3f30efd)+++ b/[jbig2.h](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2.h?id=e698d5c11d27212aa1098bc5b1673a3378563092)@@ -56,17 +56,19 @@ typedef struct \_Jbig2SymbolDictionary Jbig2SymbolDictionary; \*/  struct \_Jbig2Image {- int width, height, stride;+ uint32\_t width;+ uint32\_t height;+ uint32\_t stride; uint8\_t \*data; int refcount; }; -Jbig2Image \*jbig2\_image\_new(Jbig2Ctx \*ctx, int width, int height);+Jbig2Image \*jbig2\_image\_new(Jbig2Ctx \*ctx, uint32\_t width, uint32\_t height); Jbig2Image \*jbig2\_image\_clone(Jbig2Ctx \*ctx, Jbig2Image \*image); void jbig2\_image\_release(Jbig2Ctx \*ctx, Jbig2Image \*image); void jbig2\_image\_free(Jbig2Ctx \*ctx, Jbig2Image \*image); void jbig2\_image\_clear(Jbig2Ctx \*ctx, Jbig2Image \*image, int value);-Jbig2Image \*jbig2\_image\_resize(Jbig2Ctx \*ctx, Jbig2Image \*image, int width, int height);+Jbig2Image \*jbig2\_image\_resize(Jbig2Ctx \*ctx, Jbig2Image \*image, uint32\_t width, uint32\_t height);  /\* errors are returned from the library via a callback. If no callback is provided (a NULL argument is passed ot jbig2\_ctx\_new) a defaultdiff --git a/jbig2\_generic.c b/jbig2\_generic.cindex 02fdbfb..9656198 100644--- a/[jbig2\_generic.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_generic.c?id=1369359f21a1c8a055cc745f920b17fbc3f30efd)+++ b/[jbig2\_generic.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_generic.c?id=e698d5c11d27212aa1098bc5b1673a3378563092)@@ -718,7 +718,7 @@ jbig2\_immediate\_generic\_region(Jbig2Ctx \*ctx, Jbig2Segment \*segment, const byte byte seg\_flags; int8\_t gbat[8]; int offset;- int gbat\_bytes = 0;+ uint32\_t gbat\_bytes = 0; Jbig2GenericRegionParams params; int code = 0; Jbig2Image \*image = NULL;diff --git a/jbig2\_halftone.c b/jbig2\_halftone.cindex aeab576..acfbc56 100644--- a/[jbig2\_halftone.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_halftone.c?id=1369359f21a1c8a055cc745f920b17fbc3f30efd)+++ b/[jbig2\_halftone.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_halftone.c?id=e698d5c11d27212aa1098bc5b1673a3378563092)@@ -257,8 +257,8 @@ jbig2\_decode\_gray\_scale\_image(Jbig2Ctx \*ctx, Jbig2Segment \*segment, { uint8\_t \*\*GSVALS = NULL; size\_t consumed\_bytes = 0;- int i, j, code, stride;- int x, y;+ uint32\_t i, j, stride, x, y;+ int code; Jbig2Image \*\*GSPLANES; Jbig2GenericRegionParams rparams; Jbig2WordStream \*ws = NULL;@@ -276,9 +276,8 @@ jbig2\_decode\_gray\_scale\_image(Jbig2Ctx \*ctx, Jbig2Segment \*segment, if (GSPLANES[i] == NULL) { jbig2\_error(ctx, JBIG2\_SEVERITY\_FATAL, segment->number, "failed to allocate %dx%d image for GSPLANES", GSW, GSH); /\* free already allocated \*/- for (j = i - 1; j >= 0; --j) {- jbig2\_image\_release(ctx, GSPLANES[j]);- }+ for (j = i; j > 0;)+ jbig2\_image\_release(ctx, GSPLANES[--j]); jbig2\_free(ctx->allocator, GSPLANES); return NULL; }@@ -323,9 +322,10 @@ jbig2\_decode\_gray\_scale\_image(Jbig2Ctx \*ctx, Jbig2Segment \*segment, }  /\* C.5 step 2. Set j = GSBPP-2 \*/- j = GSBPP - 2;+ j = GSBPP - 1; /\* C.5 step 3. decode loop \*/- while (j >= 0) {+ while (j > 0) {+ j--; /\* C.5 step 3. (a) \*/ if (GSMMR) { code = jbig2\_decode\_halftone\_mmr(ctx, &rparams, data + consumed\_bytes, size - consumed\_bytes, GSPLANES[j], &consumed\_bytes);@@ -345,7 +345,6 @@ jbig2\_decode\_gray\_scale\_image(Jbig2Ctx \*ctx, Jbig2Segment \*segment, GSPLANES[j]->data[i] ^= GSPLANES[j + 1]->data[i];  /\* C.5 step 3. (c) \*/- --j; }  /\* allocate GSVALS \*/@@ -359,9 +358,8 @@ jbig2\_decode\_gray\_scale\_image(Jbig2Ctx \*ctx, Jbig2Segment \*segment, if (GSVALS[i] == NULL) { jbig2\_error(ctx, JBIG2\_SEVERITY\_FATAL, segment->number, "failed to allocate GSVALS: %d bytes", GSH \* GSW); /\* free already allocated \*/- for (j = i - 1; j >= 0; --j) {- jbig2\_free(ctx->allocator, GSVALS[j]);- }+ for (j = i; j > 0;)+ jbig2\_free(ctx->allocator, GSVALS[--j]); jbig2\_free(ctx->allocator, GSVALS); GSVALS = NULL; goto cleanup;@@ -450,7 +448,7 @@ jbig2\_decode\_halftone\_region(Jbig2Ctx \*ctx, Jbig2Segment \*segment, uint8\_t \*\*GI; Jbig2Image \*HSKIP = NULL; Jbig2PatternDict \*HPATS;- int i;+ uint32\_t i; uint32\_t mg, ng; int32\_t x, y; uint8\_t gray\_val;@@ -476,7 +474,7 @@ jbig2\_decode\_halftone\_region(Jbig2Ctx \*ctx, Jbig2Segment \*segment,  /\* calculate ceil(log2(HNUMPATS)) \*/ HBPP = 0;- while (HNUMPATS > (1 << ++HBPP));+ while (HNUMPATS > (1U << ++HBPP));  /\* 6.6.5 point 4. decode gray-scale image as mentioned in annex C \*/ GI = jbig2\_decode\_gray\_scale\_image(ctx, segment, data, size,diff --git a/jbig2\_huffman.c b/jbig2\_huffman.cindex 4521b48..f77981b 100644--- a/[jbig2\_huffman.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_huffman.c?id=1369359f21a1c8a055cc745f920b17fbc3f30efd)+++ b/[jbig2\_huffman.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_huffman.c?id=e698d5c11d27212aa1098bc5b1673a3378563092)@@ -47,16 +47,16 @@ struct \_Jbig2HuffmanState { is (offset + 4) \* 8. \*/ uint32\_t this\_word; uint32\_t next\_word;- int offset\_bits;- int offset;- int offset\_limit;+ uint32\_t offset\_bits;+ uint32\_t offset;+ uint32\_t offset\_limit;  Jbig2WordStream \*ws; Jbig2Ctx \*ctx; };  static uint32\_t-huff\_get\_next\_word(Jbig2HuffmanState \*hs, int offset)+huff\_get\_next\_word(Jbig2HuffmanState \*hs, uint32\_t offset) { uint32\_t word = 0; Jbig2WordStream \*ws = hs->ws;@@ -213,7 +213,7 @@ jbig2\_huffman\_advance(Jbig2HuffmanState \*hs, int offset) /\* return the offset of the huffman decode pointer (in bytes) \* from the beginning of the WordStream \*/-int+uint32\_t jbig2\_huffman\_offset(Jbig2HuffmanState \*hs) { return hs->offset + (hs->offset\_bits >> 3);diff --git a/jbig2\_huffman.h b/jbig2\_huffman.hindex 5d1e6e0..cfda9e0 100644--- a/[jbig2\_huffman.h](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_huffman.h?id=1369359f21a1c8a055cc745f920b17fbc3f30efd)+++ b/[jbig2\_huffman.h](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_huffman.h?id=e698d5c11d27212aa1098bc5b1673a3378563092)@@ -64,7 +64,7 @@ void jbig2\_huffman\_skip(Jbig2HuffmanState \*hs);  void jbig2\_huffman\_advance(Jbig2HuffmanState \*hs, int offset); -int jbig2\_huffman\_offset(Jbig2HuffmanState \*hs);+uint32\_t jbig2\_huffman\_offset(Jbig2HuffmanState \*hs);  int32\_t jbig2\_huffman\_get(Jbig2HuffmanState \*hs, const Jbig2HuffmanTable \*table, bool \*oob); diff --git a/jbig2\_image.c b/jbig2\_image.cindex 1ae614e..94e5a4c 100644--- a/[jbig2\_image.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_image.c?id=1369359f21a1c8a055cc745f920b17fbc3f30efd)+++ b/[jbig2\_image.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_image.c?id=e698d5c11d27212aa1098bc5b1673a3378563092)@@ -32,10 +32,10 @@  /\* allocate a Jbig2Image structure and its associated bitmap \*/ Jbig2Image \*-jbig2\_image\_new(Jbig2Ctx \*ctx, int width, int height)+jbig2\_image\_new(Jbig2Ctx \*ctx, uint32\_t width, uint32\_t height) { Jbig2Image \*image;- int stride;+ uint32\_t stride; int64\_t check;  image = jbig2\_new(ctx, Jbig2Image, 1);@@ -99,7 +99,7 @@ jbig2\_image\_free(Jbig2Ctx \*ctx, Jbig2Image \*image)  /\* resize a Jbig2Image \*/ Jbig2Image \*-jbig2\_image\_resize(Jbig2Ctx \*ctx, Jbig2Image \*image, int width, int height)+jbig2\_image\_resize(Jbig2Ctx \*ctx, Jbig2Image \*image, uint32\_t width, uint32\_t height) { if (width == image->width) { /\* check for integer multiplication overflow \*/@@ -133,11 +133,11 @@ jbig2\_image\_resize(Jbig2Ctx \*ctx, Jbig2Image \*image, int width, int height) static int jbig2\_image\_compose\_unopt(Jbig2Ctx \*ctx, Jbig2Image \*dst, Jbig2Image \*src, int x, int y, Jbig2ComposeOp op) {- int i, j;- int sw = src->width;- int sh = src->height;- int sx = 0;- int sy = 0;+ uint32\_t i, j;+ uint32\_t sw = src->width;+ uint32\_t sh = src->height;+ uint32\_t sx = 0;+ uint32\_t sy = 0;  /\* clip to the dst image boundaries \*/ if (x < 0) {@@ -200,10 +200,10 @@ jbig2\_image\_compose\_unopt(Jbig2Ctx \*ctx, Jbig2Image \*dst, Jbig2Image \*src, int x int jbig2\_image\_compose(Jbig2Ctx \*ctx, Jbig2Image \*dst, Jbig2Image \*src, int x, int y, Jbig2ComposeOp op) {- int i, j;- int w, h;- int leftbyte, rightbyte;- int shift;+ uint32\_t i, j;+ uint32\_t w, h;+ uint32\_t leftbyte, rightbyte;+ uint32\_t shift; uint8\_t \*s, \*ss; uint8\_t \*d, \*dd; uint8\_t mask, rightmask;@@ -226,8 +226,8 @@ jbig2\_image\_compose(Jbig2Ctx \*ctx, Jbig2Image \*dst, Jbig2Image \*src, int x, int h += y; y = 0; }- w = (x + w < dst->width) ? w : dst->width - x;- h = (y + h < dst->height) ? h : dst->height - y;+ w = ((uint32\_t)x + w < dst->width) ? w : ((dst->width >= (uint32\_t)x) ? dst->width - (uint32\_t)x : 0);+ h = ((uint32\_t)y + h < dst->height) ? h : ((dst->height >= (uint32\_t)y) ? dst->height - (uint32\_t)y : 0); #ifdef JBIG2\_DEBUG jbig2\_error(ctx, JBIG2\_SEVERITY\_DEBUG, -1, "compositing %dx%d at (%d, %d) after clipping\n", w, h, x, y); #endif@@ -249,8 +249,8 @@ jbig2\_image\_compose(Jbig2Ctx \*ctx, Jbig2Image \*dst, Jbig2Image \*src, int x, int } #endif - leftbyte = x >> 3;- rightbyte = (x + w - 1) >> 3;+ leftbyte = (uint32\_t)x >> 3;+ rightbyte = ((uint32\_t)x + w - 1) >> 3; shift = x & 7;  /\* general OR case \*/diff --git a/jbig2\_mmr.c b/jbig2\_mmr.cindex d4cd3a2..390e27c 100644--- a/[jbig2\_mmr.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_mmr.c?id=1369359f21a1c8a055cc745f920b17fbc3f30efd)+++ b/[jbig2\_mmr.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_mmr.c?id=e698d5c11d27212aa1098bc5b1673a3378563092)@@ -38,19 +38,21 @@ #include "jbig2\_mmr.h"  typedef struct {- int width;- int height;+ uint32\_t width;+ uint32\_t height; const byte \*data; size\_t size;- int data\_index;- int bit\_index;+ uint32\_t data\_index;+ uint32\_t bit\_index; uint32\_t word; } Jbig2MmrCtx; +#define MINUS1 ((uint32\_t)-1)+ static void jbig2\_decode\_mmr\_init(Jbig2MmrCtx \*mmr, int width, int height, const byte \*data, size\_t size) {- int i;+ size\_t i; uint32\_t word = 0;  mmr->width = width;@@ -732,14 +734,14 @@ const mmr\_table\_node jbig2\_mmr\_black\_decode[] = { #define getbit(buf, x) ( ( buf[x >> 3] >> ( 7 - (x & 7) ) ) & 1 )  static int-jbig2\_find\_changing\_element(const byte \*line, int x, int w)+jbig2\_find\_changing\_element(const byte \*line, uint32\_t x, uint32\_t w) { int a, b;  if (line == 0)- return w;+ return (int)w; - if (x == -1) {+ if (x == MINUS1) { a = 0; x = 0; } else {@@ -758,7 +760,7 @@ jbig2\_find\_changing\_element(const byte \*line, int x, int w) }  static int-jbig2\_find\_changing\_element\_of\_color(const byte \*line, int x, int w, int color)+jbig2\_find\_changing\_element\_of\_color(const byte \*line, uint32\_t x, uint32\_t w, int color) { if (line == 0) return w;@@ -772,9 +774,9 @@ static const byte lm[8] = { 0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01 }; static const byte rm[8] = { 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE };  static void-jbig2\_set\_bits(byte \*line, int x0, int x1)+jbig2\_set\_bits(byte \*line, uint32\_t x0, uint32\_t x1) {- int a0, a1, b0, b1, a;+ uint32\_t a0, a1, b0, b1, a;  a0 = x0 >> 3; a1 = x1 >> 3;@@ -831,8 +833,8 @@ jbig2\_decode\_get\_run(Jbig2MmrCtx \*mmr, const mmr\_table\_node \*table, int initial\_ static int jbig2\_decode\_mmr\_line(Jbig2MmrCtx \*mmr, const byte \*ref, byte \*dst) {- int a0 = -1;- int a1, a2, b1, b2;+ uint32\_t a0 = MINUS1;+ uint32\_t a1, a2, b1, b2; int c = 0; /\* 0 is white, black is 1 \*/  while (1) {@@ -840,7 +842,7 @@ jbig2\_decode\_mmr\_line(Jbig2MmrCtx \*mmr, const byte \*ref, byte \*dst)  /\* printf ("%08x\n", word); \*/ - if (a0 >= mmr->width)+ if (a0 != MINUS1 && a0 >= mmr->width) break;  if ((word >> (32 - 3)) == 1) {@@ -848,7 +850,7 @@ jbig2\_decode\_mmr\_line(Jbig2MmrCtx \*mmr, const byte \*ref, byte \*dst)  jbig2\_decode\_mmr\_consume(mmr, 3); - if (a0 == -1)+ if (a0 == MINUS1) a0 = 0;  if (c == 0) {@@ -860,7 +862,7 @@ jbig2\_decode\_mmr\_line(Jbig2MmrCtx \*mmr, const byte \*ref, byte \*dst) a1 = mmr->width; if (a2 > mmr->width) a2 = mmr->width;- if (a2 < a1 || a1 < 0)+ if (a1 == MINUS1 || a2 < a1) return -1; jbig2\_set\_bits(dst, a1, a2); a0 = a2;@@ -874,7 +876,7 @@ jbig2\_decode\_mmr\_line(Jbig2MmrCtx \*mmr, const byte \*ref, byte \*dst) a1 = mmr->width; if (a2 > mmr->width) a2 = mmr->width;- if (a1 < a0 || a0 < 0)+ if (a0 == MINUS1 || a1 < a0) return -1; jbig2\_set\_bits(dst, a0, a1); a0 = a2;@@ -888,7 +890,7 @@ jbig2\_decode\_mmr\_line(Jbig2MmrCtx \*mmr, const byte \*ref, byte \*dst) b1 = jbig2\_find\_changing\_element\_of\_color(ref, a0, mmr->width, !c); b2 = jbig2\_find\_changing\_element(ref, b1, mmr->width); if (c) {- if (b2 < a0 || a0 < 0)+ if (a0 == MINUS1 || b2 < a0) return -1; jbig2\_set\_bits(dst, a0, b2); }@@ -900,7 +902,7 @@ jbig2\_decode\_mmr\_line(Jbig2MmrCtx \*mmr, const byte \*ref, byte \*dst) jbig2\_decode\_mmr\_consume(mmr, 1); b1 = jbig2\_find\_changing\_element\_of\_color(ref, a0, mmr->width, !c); if (c) {- if (b1 < a0 || a0 < 0)+ if (a0 == MINUS1 || b1 < a0) return -1; jbig2\_set\_bits(dst, a0, b1); }@@ -915,7 +917,7 @@ jbig2\_decode\_mmr\_line(Jbig2MmrCtx \*mmr, const byte \*ref, byte \*dst) if (b1 + 1 > mmr->width) break; if (c) {- if (b1 + 1 < a0 || a0 < 0)+ if (a0 == MINUS1 || b1 + 1 < a0) return -1; jbig2\_set\_bits(dst, a0, b1 + 1); }@@ -930,7 +932,7 @@ jbig2\_decode\_mmr\_line(Jbig2MmrCtx \*mmr, const byte \*ref, byte \*dst) if (b1 + 2 > mmr->width) break; if (c) {- if (b1 + 2 < a0 || a0 < 0)+ if (a0 == MINUS1 || b1 + 2 < a0) return -1; jbig2\_set\_bits(dst, a0, b1 + 2); }@@ -942,10 +944,10 @@ jbig2\_decode\_mmr\_line(Jbig2MmrCtx \*mmr, const byte \*ref, byte \*dst) /\* printf ("VR(3)\n"); \*/ jbig2\_decode\_mmr\_consume(mmr, 7); b1 = jbig2\_find\_changing\_element\_of\_color(ref, a0, mmr->width, !c);- if (b1 + 3 > mmr->width)+ if (b1 + 3 > (int)mmr->width) break; if (c) {- if (b1 + 3 < a0 || a0 < 0)+ if (a0 == MINUS1 || b1 + 3 < a0) return -1; jbig2\_set\_bits(dst, a0, b1 + 3); }@@ -957,10 +959,10 @@ jbig2\_decode\_mmr\_line(Jbig2MmrCtx \*mmr, const byte \*ref, byte \*dst) /\* printf ("VL(1)\n"); \*/ jbig2\_decode\_mmr\_consume(mmr, 3); b1 = jbig2\_find\_changing\_element\_of\_color(ref, a0, mmr->width, !c);- if (b1 - 1 < 0)+ if (b1 < 1) break; if (c) {- if (b1 - 1 < a0 || a0 < 0)+ if (a0 == MINUS1 || b1 - 1 < a0) return -1; jbig2\_set\_bits(dst, a0, b1 - 1); }@@ -972,7 +974,7 @@ jbig2\_decode\_mmr\_line(Jbig2MmrCtx \*mmr, const byte \*ref, byte \*dst) /\* printf ("VL(2)\n"); \*/ jbig2\_decode\_mmr\_consume(mmr, 6); b1 = jbig2\_find\_changing\_element\_of\_color(ref, a0, mmr->width, !c);- if (b1 - 2 < 0)+ if (b1 < 2) break; if (c) { if (b1 - 2 < a0 || a0 < 0)@@ -987,10 +989,10 @@ jbig2\_decode\_mmr\_line(Jbig2MmrCtx \*mmr, const byte \*ref, byte \*dst) /\* printf ("VL(3)\n"); \*/ jbig2\_decode\_mmr\_consume(mmr, 7); b1 = jbig2\_find\_changing\_element\_of\_color(ref, a0, mmr->width, !c);- if (b1 - 3 < 0)+ if (b1 < 3) break; if (c) {- if (b1 - 3 < a0 || a0 < 0)+ if (a0 == MINUS1 || b1 - 3 < a0) return -1; jbig2\_set\_bits(dst, a0, b1 - 3); }@@ -1009,10 +1011,10 @@ int jbig2\_decode\_generic\_mmr(Jbig2Ctx \*ctx, Jbig2Segment \*segment, const Jbig2GenericRegionParams \*params, const byte \*data, size\_t size, Jbig2Image \*image) { Jbig2MmrCtx mmr;- const int rowstride = image->stride;+ const uint32\_t rowstride = image->stride; byte \*dst = image->data; byte \*ref = NULL;- int y;+ uint32\_t y; int code = 0;  jbig2\_decode\_mmr\_init(&mmr, image->width, image->height, data, size);@@ -1047,10 +1049,10 @@ int jbig2\_decode\_halftone\_mmr(Jbig2Ctx \*ctx, const Jbig2GenericRegionParams \*params, const byte \*data, size\_t size, Jbig2Image \*image, size\_t \*consumed\_bytes) { Jbig2MmrCtx mmr;- const int rowstride = image->stride;+ const uint32\_t rowstride = image->stride; byte \*dst = image->data; byte \*ref = NULL;- int y;+ uint32\_t y; int code = 0; const uint32\_t EOFB = 0x001001; diff --git a/jbig2\_page.c b/jbig2\_page.cindex 110ff7c..1ed1c8a 100644--- a/[jbig2\_page.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_page.c?id=1369359f21a1c8a055cc745f920b17fbc3f30efd)+++ b/[jbig2\_page.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_page.c?id=e698d5c11d27212aa1098bc5b1673a3378563092)@@ -155,9 +155,9 @@ int jbig2\_end\_of\_stripe(Jbig2Ctx \*ctx, Jbig2Segment \*segment, const uint8\_t \*segment\_data) { Jbig2Page page = ctx->pages[ctx->current\_page];- int end\_row;+ uint32\_t end\_row; - end\_row = jbig2\_get\_int32(segment\_data);+ end\_row = jbig2\_get\_uint32(segment\_data); if (end\_row < page.end\_row) { jbig2\_error(ctx, JBIG2\_SEVERITY\_WARNING, segment->number, "end of stripe segment with non-positive end row advance" " (new end row %d vs current end row %d)", end\_row, page.end\_row);@@ -248,7 +248,7 @@ jbig2\_page\_add\_result(Jbig2Ctx \*ctx, Jbig2Page \*page, Jbig2Image \*image, int x,  /\* grow the page to accomodate a new stripe if necessary \*/ if (page->striped) {- int new\_height = y + image->height + page->end\_row;+ uint32\_t new\_height = y + image->height + page->end\_row;  if (page->image->height < new\_height) { jbig2\_error(ctx, JBIG2\_SEVERITY\_DEBUG, -1, "growing page buffer to %d rows " "to accomodate new stripe", new\_height);diff --git a/jbig2\_priv.h b/jbig2\_priv.hindex 42ba496..3d44b42 100644--- a/[jbig2\_priv.h](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_priv.h?id=1369359f21a1c8a055cc745f920b17fbc3f30efd)+++ b/[jbig2\_priv.h](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_priv.h?id=e698d5c11d27212aa1098bc5b1673a3378563092)@@ -132,7 +132,7 @@ struct \_Jbig2Page { uint32\_t x\_resolution, y\_resolution; /\* in pixels per meter \*/ uint16\_t stripe\_size; bool striped;- int end\_row;+ uint32\_t end\_row; uint8\_t flags; Jbig2Image \*image; };@@ -182,7 +182,7 @@ int jbig2\_halftone\_region(Jbig2Ctx \*ctx, Jbig2Segment \*segment, const byte \*segm typedef struct \_Jbig2WordStream Jbig2WordStream;  struct \_Jbig2WordStream {- int (\*get\_next\_word)(Jbig2WordStream \*self, int offset, uint32\_t \*word);+ int (\*get\_next\_word)(Jbig2WordStream \*self, size\_t offset, uint32\_t \*word); };  Jbig2WordStream \*jbig2\_word\_stream\_buf\_new(Jbig2Ctx \*ctx, const byte \*data, size\_t size);diff --git a/jbig2\_segment.c b/jbig2\_segment.cindex 2e0db67..5b63706 100644--- a/[jbig2\_segment.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_segment.c?id=1369359f21a1c8a055cc745f920b17fbc3f30efd)+++ b/[jbig2\_segment.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_segment.c?id=e698d5c11d27212aa1098bc5b1673a3378563092)@@ -39,10 +39,10 @@ jbig2\_parse\_segment\_header(Jbig2Ctx \*ctx, uint8\_t \*buf, size\_t buf\_size, size\_t uint8\_t rtscarf; uint32\_t rtscarf\_long; uint32\_t \*referred\_to\_segments;- int referred\_to\_segment\_count;- int referred\_to\_segment\_size;- int pa\_size;- int offset;+ uint32\_t referred\_to\_segment\_count;+ uint32\_t referred\_to\_segment\_size;+ uint32\_t pa\_size;+ uint32\_t offset;  /\* minimum possible size of a jbig2 segment header \*/ if (buf\_size < 11)@@ -83,7 +83,7 @@ jbig2\_parse\_segment\_header(Jbig2Ctx \*ctx, uint8\_t \*buf, size\_t buf\_size, size\_t  /\* 7.2.5 \*/ if (referred\_to\_segment\_count) {- int i;+ uint32\_t i;  referred\_to\_segments = jbig2\_new(ctx, uint32\_t, referred\_to\_segment\_count \* referred\_to\_segment\_size); if (referred\_to\_segments == NULL) {diff --git a/jbig2\_symbol\_dict.c b/jbig2\_symbol\_dict.cindex 2c71a4c..11a2252 100644--- a/[jbig2\_symbol\_dict.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_symbol_dict.c?id=1369359f21a1c8a055cc745f920b17fbc3f30efd)+++ b/[jbig2\_symbol\_dict.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_symbol_dict.c?id=e698d5c11d27212aa1098bc5b1673a3378563092)@@ -88,40 +88,40 @@ jbig2\_dump\_symbol\_dict(Jbig2Ctx \*ctx, Jbig2Segment \*segment)  /\* return a new empty symbol dict \*/ Jbig2SymbolDict \*-jbig2\_sd\_new(Jbig2Ctx \*ctx, int n\_symbols)+jbig2\_sd\_new(Jbig2Ctx \*ctx, uint32\_t n\_symbols) {- Jbig2SymbolDict \*new = NULL;+ Jbig2SymbolDict \*new\_dict = NULL;  if (n\_symbols < 0) { jbig2\_error(ctx, JBIG2\_SEVERITY\_FATAL, -1, "Negative number of symbols in symbol dict: %d", n\_symbols); return NULL; } - new = jbig2\_new(ctx, Jbig2SymbolDict, 1);- if (new != NULL) {- new->glyphs = jbig2\_new(ctx, Jbig2Image \*, n\_symbols);- new->n\_symbols = n\_symbols;+ new\_dict = jbig2\_new(ctx, Jbig2SymbolDict, 1);+ if (new\_dict != NULL) {+ new\_dict->glyphs = jbig2\_new(ctx, Jbig2Image \*, n\_symbols);+ new\_dict->n\_symbols = n\_symbols; } else { jbig2\_error(ctx, JBIG2\_SEVERITY\_FATAL, -1, "unable to allocate new empty symbol dict"); return NULL; } - if (new->glyphs != NULL) {- memset(new->glyphs, 0, n\_symbols \* sizeof(Jbig2Image \*));+ if (new\_dict->glyphs != NULL) {+ memset(new\_dict->glyphs, 0, n\_symbols \* sizeof(Jbig2Image \*)); } else { jbig2\_error(ctx, JBIG2\_SEVERITY\_FATAL, -1, "unable to allocate glyphs for new empty symbol dict");- jbig2\_free(ctx->allocator, new);+ jbig2\_free(ctx->allocator, new\_dict); return NULL; } - return new;+ return new\_dict; }  /\* release the memory associated with a symbol dict \*/ void jbig2\_sd\_release(Jbig2Ctx \*ctx, Jbig2SymbolDict \*dict) {- int i;+ uint32\_t i;  if (dict == NULL) return;@@ -142,12 +142,12 @@ jbig2\_sd\_glyph(Jbig2SymbolDict \*dict, unsigned int id) }  /\* count the number of dictionary segments referred to by the given segment \*/-int+uint32\_t jbig2\_sd\_count\_referred(Jbig2Ctx \*ctx, Jbig2Segment \*segment) { int index; Jbig2Segment \*rsegment;- int n\_dicts = 0;+ uint32\_t n\_dicts = 0;  for (index = 0; index < segment->referred\_to\_segment\_count; index++) { rsegment = jbig2\_find\_segment(ctx, segment->referred\_to\_segments[index]);@@ -166,8 +166,8 @@ jbig2\_sd\_list\_referred(Jbig2Ctx \*ctx, Jbig2Segment \*segment) int index; Jbig2Segment \*rsegment; Jbig2SymbolDict \*\*dicts;- int n\_dicts = jbig2\_sd\_count\_referred(ctx, segment);- int dindex = 0;+ uint32\_t n\_dicts = jbig2\_sd\_count\_referred(ctx, segment);+ uint32\_t dindex = 0;  dicts = jbig2\_new(ctx, Jbig2SymbolDict \*, n\_dicts); if (dicts == NULL) {@@ -195,10 +195,10 @@ jbig2\_sd\_list\_referred(Jbig2Ctx \*ctx, Jbig2Segment \*segment) /\* generate a new symbol dictionary by concatenating a list of existing dictionaries \*/ Jbig2SymbolDict \*-jbig2\_sd\_cat(Jbig2Ctx \*ctx, int n\_dicts, Jbig2SymbolDict \*\*dicts)+jbig2\_sd\_cat(Jbig2Ctx \*ctx, uint32\_t n\_dicts, Jbig2SymbolDict \*\*dicts) {- int i, j, k, symbols;- Jbig2SymbolDict \*new = NULL;+ uint32\_t i, j, k, symbols;+ Jbig2SymbolDict \*new\_dict = NULL;  /\* count the imported symbols and allocate a new array \*/ symbols = 0;@@ -206,17 +206,17 @@ jbig2\_sd\_cat(Jbig2Ctx \*ctx, int n\_dicts, Jbig2SymbolDict \*\*dicts) symbols += dicts[i]->n\_symbols;  /\* fill a new array with cloned glyph pointers \*/- new = jbig2\_sd\_new(ctx, symbols);- if (new != NULL) {+ new\_dict = jbig2\_sd\_new(ctx, symbols);+ if (new\_dict != NULL) { k = 0; for (i = 0; i < n\_dicts; i++) for (j = 0; j < dicts[i]->n\_symbols; j++)- new->glyphs[k++] = jbig2\_image\_clone(ctx, dicts[i]->glyphs[j]);+ new\_dict->glyphs[k++] = jbig2\_image\_clone(ctx, dicts[i]->glyphs[j]); } else { jbig2\_error(ctx, JBIG2\_SEVERITY\_WARNING, -1, "failed to allocate new symbol dictionary"); } - return new;+ return new\_dict; }  /\* Decoding routines \*/@@ -431,7 +431,7 @@ jbig2\_decode\_symbol\_dict(Jbig2Ctx \*ctx,  if (REFAGGNINST > 1) { Jbig2Image \*image;- int i;+ uint32\_t i;  if (tparams == NULL) { /\* First time through, we need to initialise the \*/@@ -512,7 +512,7 @@ jbig2\_decode\_symbol\_dict(Jbig2Ctx \*ctx, uint32\_t ID; int32\_t RDX, RDY; int BMSIZE = 0;- int ninsyms = params->SDNUMINSYMS;+ uint32\_t ninsyms = params->SDNUMINSYMS; int code1 = 0; int code2 = 0; int code3 = 0;@@ -609,8 +609,9 @@ jbig2\_decode\_symbol\_dict(Jbig2Ctx \*ctx, if (params->SDHUFF && !params->SDREFAGG) { /\* 6.5.9 \*/ Jbig2Image \*image;- int BMSIZE = jbig2\_huffman\_get(hs, params->SDHUFFBMSIZE, &code);- int j, x;+ uint32\_t BMSIZE = jbig2\_huffman\_get(hs, params->SDHUFFBMSIZE, &code);+ uint32\_t j;+ int x;  if (code || (BMSIZE < 0)) { jbig2\_error(ctx, JBIG2\_SEVERITY\_FATAL, segment->number, "error decoding size of collective bitmap!");@@ -700,22 +701,22 @@ jbig2\_decode\_symbol\_dict(Jbig2Ctx \*ctx, jbig2\_error(ctx, JBIG2\_SEVERITY\_FATAL, segment->number, "failed to allocate symbols exported from symbols dictionary"); goto cleanup4; } else {- int i = 0;- int j = 0;- int k;+ uint32\_t i = 0;+ uint32\_t j = 0;+ uint32\_t k; int exflag = 0;- int64\_t limit = params->SDNUMINSYMS + params->SDNUMNEWSYMS;- int32\_t exrunlength;+ uint32\_t limit = params->SDNUMINSYMS + params->SDNUMNEWSYMS;+ uint32\_t exrunlength; int zerolength = 0;  while (i < limit) { if (params->SDHUFF) exrunlength = jbig2\_huffman\_get(hs, SBHUFFRSIZE, &code); else- code = jbig2\_arith\_int\_decode(IAEX, as, &exrunlength);+ code = jbig2\_arith\_int\_decode(IAEX, as, (int32\_t \*)&exrunlength); /\* prevent infinite loop \*/ zerolength = exrunlength > 0 ? 0 : zerolength + 1;- if (code || (exrunlength > limit - i) || (exrunlength < 0) || (zerolength > 4) || (exflag && (exrunlength > params->SDNUMEXSYMS - j))) {+ if (code || (exrunlength > limit - i) || (exrunlength < 0) || (zerolength > 4) || (exflag && (exrunlength + j > params->SDNUMEXSYMS))) { if (code) jbig2\_error(ctx, JBIG2\_SEVERITY\_FATAL, segment->number, "failed to decode exrunlength for exported symbols"); else if (exrunlength <= 0)@@ -797,8 +798,8 @@ jbig2\_symbol\_dictionary(Jbig2Ctx \*ctx, Jbig2Segment \*segment, const byte \*segmen { Jbig2SymbolDictParams params; uint16\_t flags;- int sdat\_bytes;- int offset;+ uint32\_t sdat\_bytes;+ uint32\_t offset; Jbig2ArithCx \*GB\_stats = NULL; Jbig2ArithCx \*GR\_stats = NULL; int table\_index = 0;@@ -951,7 +952,7 @@ jbig2\_symbol\_dictionary(Jbig2Ctx \*ctx, Jbig2Segment \*segment, const byte \*segmen  /\* 7.4.2.2 (2) \*/ {- int n\_dicts = jbig2\_sd\_count\_referred(ctx, segment);+ uint32\_t n\_dicts = jbig2\_sd\_count\_referred(ctx, segment); Jbig2SymbolDict \*\*dicts = NULL;  if (n\_dicts > 0) {diff --git a/jbig2\_symbol\_dict.h b/jbig2\_symbol\_dict.hindex d56d62d..30211d4 100644--- a/[jbig2\_symbol\_dict.h](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_symbol_dict.h?id=1369359f21a1c8a055cc745f920b17fbc3f30efd)+++ b/[jbig2\_symbol\_dict.h](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_symbol_dict.h?id=e698d5c11d27212aa1098bc5b1673a3378563092)@@ -32,18 +32,18 @@ int jbig2\_symbol\_dictionary(Jbig2Ctx \*ctx, Jbig2Segment \*segment, const byte \*se Jbig2Image \*jbig2\_sd\_glyph(Jbig2SymbolDict \*dict, unsigned int id);  /\* return a new empty symbol dict \*/-Jbig2SymbolDict \*jbig2\_sd\_new(Jbig2Ctx \*ctx, int n\_symbols);+Jbig2SymbolDict \*jbig2\_sd\_new(Jbig2Ctx \*ctx, uint32\_t n\_symbols);  /\* release the memory associated with a symbol dict \*/ void jbig2\_sd\_release(Jbig2Ctx \*ctx, Jbig2SymbolDict \*dict);  /\* generate a new symbol dictionary by concatenating a list of existing dictionaries \*/-Jbig2SymbolDict \*jbig2\_sd\_cat(Jbig2Ctx \*ctx, int n\_dicts, Jbig2SymbolDict \*\*dicts);+Jbig2SymbolDict \*jbig2\_sd\_cat(Jbig2Ctx \*ctx, uint32\_t n\_dicts, Jbig2SymbolDict \*\*dicts);  /\* count the number of dictionary segments referred to by the given segment \*/-int jbig2\_sd\_count\_referred(Jbig2Ctx \*ctx, Jbig2Segment \*segment);+uint32\_t jbig2\_sd\_count\_referred(Jbig2Ctx \*ctx, Jbig2Segment \*segment);  /\* return an array of pointers to symbol dictionaries referred to by a segment \*/diff --git a/jbig2\_text.c b/jbig2\_text.cindex 5c99640..e77460f 100644--- a/[jbig2\_text.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_text.c?id=1369359f21a1c8a055cc745f920b17fbc3f30efd)+++ b/[jbig2\_text.c](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_text.c?id=e698d5c11d27212aa1098bc5b1673a3378563092)@@ -55,7 +55,7 @@ int jbig2\_decode\_text\_region(Jbig2Ctx \*ctx, Jbig2Segment \*segment, const Jbig2TextRegionParams \*params,- const Jbig2SymbolDict \*const \*dicts, const int n\_dicts,+ const Jbig2SymbolDict \*const \*dicts, const uint32\_t n\_dicts, Jbig2Image \*image, const byte \*data, const size\_t size, Jbig2ArithCx \*GR\_stats, Jbig2ArithState \*as, Jbig2WordStream \*ws) { /\* relevent bits of 6.4.4 \*/@@ -476,19 +476,19 @@ cleanup2: int jbig2\_text\_region(Jbig2Ctx \*ctx, Jbig2Segment \*segment, const byte \*segment\_data) {- int offset = 0;+ uint32\_t offset = 0; Jbig2RegionSegmentInfo region\_info; Jbig2TextRegionParams params; Jbig2Image \*image = NULL; Jbig2SymbolDict \*\*dicts = NULL;- int n\_dicts = 0;+ uint32\_t n\_dicts = 0; uint16\_t flags = 0; uint16\_t huffman\_flags = 0; Jbig2ArithCx \*GR\_stats = NULL; int code = 0; Jbig2WordStream \*ws = NULL; Jbig2ArithState \*as = NULL;- int table\_index = 0;+ uint32\_t table\_index = 0; const Jbig2HuffmanParams \*huffman\_params = NULL;  /\* 7.4.1 \*/@@ -779,7 +779,7 @@ jbig2\_text\_region(Jbig2Ctx \*ctx, Jbig2Segment \*segment, const byte \*segment\_data code = jbig2\_error(ctx, JBIG2\_SEVERITY\_FATAL, segment->number, "unable to retrive symbol dictionaries! previous parsing error?"); goto cleanup1; } else {- int index;+ uint32\_t index;  if (dicts[0] == NULL) { code = jbig2\_error(ctx, JBIG2\_SEVERITY\_WARNING, segment->number, "unable to find first referenced symbol dictionary!");@@ -823,8 +823,8 @@ jbig2\_text\_region(Jbig2Ctx \*ctx, Jbig2Segment \*segment, const byte \*segment\_data }  if (!params.SBHUFF) {- int SBSYMCODELEN, index;- int SBNUMSYMS = 0;+ uint32\_t SBSYMCODELEN, index;+ uint32\_t SBNUMSYMS = 0;  for (index = 0; index < n\_dicts; index++) { SBNUMSYMS += dicts[index]->n\_symbols;@@ -840,7 +840,7 @@ jbig2\_text\_region(Jbig2Ctx \*ctx, Jbig2Segment \*segment, const byte \*segment\_data }  /\* Table 31 \*/- for (SBSYMCODELEN = 0; (1 << SBSYMCODELEN) < SBNUMSYMS; SBSYMCODELEN++) {+ for (SBSYMCODELEN = 0; (1U << SBSYMCODELEN) < SBNUMSYMS; SBSYMCODELEN++) { } params.IAID = jbig2\_arith\_iaid\_ctx\_new(ctx, SBSYMCODELEN); params.IARI = jbig2\_arith\_int\_ctx\_new(ctx);diff --git a/jbig2\_text.h b/jbig2\_text.hindex aec2732..51d242e 100644--- a/[jbig2\_text.h](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_text.h?id=1369359f21a1c8a055cc745f920b17fbc3f30efd)+++ b/[jbig2\_text.h](/cgi-bin/cgit.cgi/jbig2dec.git/tree/jbig2_text.h?id=e698d5c11d27212aa1098bc5b1673a3378563092)@@ -70,5 +70,5 @@ typedef struct { int jbig2\_decode\_text\_region(Jbig2Ctx \*ctx, Jbig2Segment \*segment, const Jbig2TextRegionParams \*params,- const Jbig2SymbolDict \*const \*dicts, const int n\_dicts,+ const Jbig2SymbolDict \*const \*dicts, const uint32\_t n\_dicts, Jbig2Image \*image, const byte \*data, const size\_t size, Jbig2ArithCx \*GR\_stats, Jbig2ArithState \*as, Jbig2WordStream \*ws); |
| --- |

generated by [cgit v1.2.3](https://git.zx2c4.com/cgit/about/) ([git 2.25.1](https://git-scm.com/)) at 2025-01-26 00:09:34 +0000


