=== Content from www.iacr.org_ac6035dd_20250124_191003.html ===
Security Flaws Induced by CBC Padding
Applications to SSL, IPSEC, WTLS...

Serge Vaudenay

Swiss Federal Institute of Technology (EPFL)
Serge.Vaudenay@epfl.ch

Abstract. In many standards, e.g. SSL/TLS, IPSEC, WTLS, messages
are ﬂrst pre-formatted, then encrypted in CBC mode with a block cipher.
Decryption needs to check if the format is valid. Validity of the format is
easily leaked from communication protocols in a chosen ciphertext attack
since the receiver usually sends an acknowledgment or an error message.
This is a side channel.
In this paper we show various ways to perform an e–cient side channel
attack. We discuss potential applications, extensions to other padding
schemes and various ways to ﬂx the problem.

1

Introduction

Variable input length encryption is traditionally constructed from a ﬂxed input
length encryption (namely a block cipher) in a special mode of operation. In
RFC2040 [2], the RC5-CBC-PAD algorithm is proposed, based on RC5 which
enables the encryption of blocks of b = 8 words where words are bytes. Encryp-
tion of any word sequence with an RC5 secret key K is performed as follows.

1. Pad the word sequence with n words, all being equal to n, such that 1
and the padded sequence has a length which is a multiple of b.

n

b

•

•

2. Write the padded word sequence as a block sequence x1; : : : ; xN in which

each block xi consists of b words.

3. Encrypt the block sequence in CBC mode with a (either ﬂxed or random or

secret) IV with a permutation C deﬂned by RC5 with key K: get

y1 = C(IV

'

x1); yi = C(yi¡1

'

xi); i = 2; : : : ; N

(1)

where

'

denotes the XOR operation.

The encryption of the message is the block sequence y1; : : : ; yN .

Although decryption is not clearly deﬂned in RFC2040 [2], it makes sense to
assume that the receiver of an encrypted message ﬂrst decrypts in CBC mode,
then checks if the padding is correct and ﬂnally removes it. The question is: how
must the receiver behave if the padding is not correct? Although the receiver
should not tell the sender that the padding is not correct, it is meaningful that
non-procession of a decrypted message ultimately leaks this bit of information.

This leads to an attack that uses an oracle for which any block sequence tells if
the padding of the corresponding CBC-decrypted sequence is correct according
to the above algorithm. The attack works within a complexity of O(N bW ) in
order to decrypt the message where W is the number of possible words (typically
W = 256).

A similar attack model was used by Bleichenbacher against PKCS#1 v1.5 [5]
and by Manger against PKCS#1 v2.0 [13]. This paper shows that similar attacks
are feasible in the symmetric key world.

The paper is organized as follows. We ﬂrst recall some well known properties and
security issues for the CBC mode. We describe several attacks against RC5-CBC-
PAD and we introduce the notion of bomb oracle. We then discuss extensions
to other schemes: ESP, random padding, ... and applications in real life such as
SSL, IPSEC, WTLS, SSH2. Next we present some possible ﬂxes which do not
actually work like replacing the CBC mode by a double CBC mode, the HCBC
mode or other modes which were proposed by the standard process run by NIST.
We further propose a ﬂx which does work.

2 CBC Properties

Several security properties of the CBC mode are already known. We think it is
useful to recall them in order to remind ourselves of the intrinsic security limits
of the CBC mode.

2.1 E–ciency

CBC mode is e–cient in practice because we can encrypt or decrypt a stream of
inﬂnite length with a constant memory in linear time. E–ciency is comparable
to the Electronic Code Book (ECB) mode where each block is encrypted in
the same way. The diﬁerence between ECB and CBC is a single exclusive or
operation. Since the ECB mode is not suitable in most applications because
of ciphertext manipulation attacks, and lack of increased message entropy, we
prefer to use CBC mode. (See e.g. [14, p. 230] for more details.)

Exhaustive search against CBC mode is related to the length of the secret key.
We have yet other bounds related to the block length. First of all, the electronic
code book attack has a complexity of W b. We have other speciﬂc attacks related
to the intrinsic security of the CBC mode no matter which block cipher is used.
These are detailed in following sections.

2.2 Conﬂdentiality Limits

Conﬂdentiality has security (cid:176)aws. Obviously, when using a ﬂxed IV, one can
easily see when two diﬁerent messages have a common preﬂx block sequence by
just looking at the two ciphertexts.

More generally, when two ciphertext blocks yi and yj are equal, one can
xj.1 We can then exploit the
yj¡1 = xi
deduce from Eq. (1) that yi¡1
'
redundancy in the plaintext in order to recover xi and xj from yi¡1
yj¡1. This
(cid:176)aw is however quite negligible: since the ciphertext blocks get a distribution
which is usually indistinguishable from a uniform distribution, the probability
that two b-words blocks out of N are equal is given by the birthday paradox
theorem

'

'

p

1

¡

…

2 N 2:W ¡b

e¡ 1

where W is the number of possible words. The attack is e–cient when N reaches
the order of magnitude of pW b. Therefore, for b = 8 and W = 256, we need
about 235 bytes (32GigaBytes) in order to get a probability of success equal to
39% for this attack which leaks information on 16 Bytes only.

2.3 Authentication Limits

The CBC mode can be used to create message authentication codes (MAC).
Raw CBC-MAC (i.e. taking the last encrypted block as a MAC) is well known
to have security (cid:176)aws: with the MAC of three messages m1; m2; m3 where m2
consists of m1 augmented with an extra block, we can forge the MAC of a
fourth message which consists of m3 augmented with an extra block. This is
ﬂxed by re-encrypting the raw CBC-MAC, but this new scheme still has attacks
of complexity essentially pW b. (See [15,16,19].)

3 The Attack

Let b be the block length in words, and W be the number of possible words. (We
assume that W
b and that all integers between 1 and b can unambiguously be
encoded into words in order to make the CBC-PAD scheme feasible.)

‚

We say that a block sequence x1; x2; : : : ; xN has a correct padding if the last
block xN ends with a word string of n words equal to n with n > 0: 1, or 22, or
333, ... Given a block sequence y1; y2; : : : ; yN , we deﬂne an oracle
which yields
1 if the decryption in CBC mode has a correct padding. Decryption is totally
deﬂned by a block encryption function C and IV. Oracle
is thus deﬂned by C
and IV.

O

O

3.1 Last Word Oracle

For any block y, we want to compute the last word of C ¡1(y). We call it the
\last word oracle".

Let r1; : : : ; rb be random words, and let r = r1 : : : rb. We forge a fake cipher-
text r
r
ends with a valid padding. In this case, the most likely valid padding is the
one which ends with 1. This means that the last word of C ¡1(y) is rb
1. If

y by concatenating the two blocks r and y. If
j

y) = 1, then C ¡1(y)
j

(r

O

'

'

1 This property was notably mentioned in [12, p. 43].

(r

O
the same one twice is not worthwhile).

y) = 0, we can try again (by making sure that we pick another rb: picking
j
If we are lucky (with probability W ¡1), we ﬂnd the last word with the ﬂrst
try. Otherwise we have to try many rbs. On average, we have to try W=2 values.
Odd cases occur when the valid padding found is not 1. This is easy to
detect. The following program eventually halts with the last words of y: one in
the typical case, several if we are lucky.

1. pick a few random words r1; : : : ; rb and take i = 0
2. pick r = r1 : : : rb¡1(rb
y) = 0 then increment i and go back to the previous step
3. if
j
4. replace rb by rb
5. for n = b down to 2 do

(r

O

'

'

i)

i

(a) take r = r1 : : : rb¡n(rb¡n+1
(r
(b) if
6. output rb

1)rb¡n+2 : : : rb
y) = 0 then stop and output (rb¡n+1
j
'

O

'

1

n) : : : (rb

n)

'

'

3.2 Block Decryption Oracle
Now we want to implement an oracle which computes C ¡1(y) for any y: a \block
decryption oracle".

Let a = a1 : : : ab be the word sequence of C ¡1(y). We can get ab by using the
last word oracle. Assuming that we already managed to get aj : : : ab for some
b, the following program gets aj¡1, so that we can iterate until we recover
j
the whole sequence.

•

¡

'

(b

j + 2) for k = j; : : : ; b

1. take rk = ak
2. pick r1; : : : ; rj¡1 at random and take i = 0
3. take r = r1 : : : rj¡2(rj¡1
4. if
(r
5. output rj¡1

i)rj : : : rb

j + 2)

(b

O

'

i

y) = 0 then increment i and go back to the previous step
j

'

'

¡

We need W=2 trials on average. We can thus recover an additional word within
W=2 trials. Since there are b words per block, we need bW=2 trials on average in
order to implement the C ¡1 oracle.

3.3 Decryption Oracle

Now we want to decrypt any message y1; : : : ; yN with the help of
. It can be
done with N bW=2 2-block oracle calls on average. We just have to call the block
decryption oracle on each block yi and perform the CBC decryption.

O

One problem remains in the case where IV is secret. Here we cannot decrypt
the ﬂrst block. We can however get the ﬂrst plaintext block up to an unknown
constant. In particular, if two messages are encrypted with the same IV, we can
compute the XOR of the two ﬂrst plaintext blocks.

The attack has a complexity of O(N bW ). As an example for b = 8 and
W = 256 we obtain that we can decrypt any N -block ciphertext by making
1024N oracle calls on average. The attack is thus extremely e–cient.

3.4 Postﬂx Equality Check Oracle

There are reasons which will be made clear for which we can be interested in
bomb oracles as deﬂned below. A bomb oracle is an oracle which either gives
an answer or explodes depending on the input. Of course, the bomb oracle is no
longer available after explosion. An attack which uses a bomb oracle fails if the
0 which either
oracle explodes. For instance, we are interested in a bomb oracle
answers 1 or explodes when
answers 1 when

answers 0.

O

Given a ciphertext y1; : : : ; yN and a word sequence w1 : : : wm, we want to
implement a bomb oracle which checks if w1 : : : wm is a postﬂx of the decryption
0. Let us ﬂrst consider that m
of y1; : : : ; yN by using
b. We perform the
following process.

O

•

O

O

m for k = 1; : : : ; m

0 where r = r1 : : : rb

'

1. pick a few random words r1 : : : rb¡m
2. take rb¡m+k = wk
3. send r
yN to the oracle
j
4. if m = 1 then
{ take r0
otherwise
{ take r0

k = rk for k = 1; : : : ; b

k = rk for k = 1; : : : ; b

O

¡

5. send r0
yN to the oracle
j
6. output 1

O

2; b and take r0

b¡1 = rb¡1

1

'

¡
0 where r0 = r0

1 and take r0
1 : : : r0
b

b = wm

1

'

The second oracle call is used in order to eliminate odd cases which are not
eliminated by the ﬂrst one, for instance when wm
1 is a postﬂx. Obviously,
this is a bomb oracle which checks whether w1 : : : wm is a postﬂx or not.

m

'

'

For m > b, we can cut the ciphertext and use the above oracle

times on
each block. As will be noticed, some CBC-PAD variants allow to have paddings
1), so we can generalize the previous oracle
longer than b (namely at most W
¡
and check postﬂxes within a single
oracle call. This will be used against
SSL/TLS in Section 5.1.

O

d

m
b e

4 Other Padding Schemes

In Schneier [17, pp. 190{191], a slightly diﬁerent padding scheme is proposed:
only the last word is equal to the padding length, and all other padded words
are equal to zero. The padded sequence is thus 00 : : : 0n instead of nn : : : n.
Obviously, a similar attack holds.

IP Encapsulating Security Payload (ESP) [10] uses another slightly diﬁer-
ent padding: the padded sequence is 1234: : : n instead of nn : : : n. Obviously, a
similar attack holds.

Another padding scheme consists of padding with a non blank word then the
necessary number of blank words. This is suggested, for instance by NIST [8,
App. A] with W = 2 (here the blank word is the bit 0). Obviously, a similar
attack holds.

One can propose to have the last word equal to the padding length and all
other padded words chosen at random (like SSH2). The attack still enables the

decryption of the last word of any block. We also have another security (cid:176)aw: if
the same message is encrypted twice, it is unlikely that the last encrypted blocks
are equal, but in the case where the padding is of length one. We can thus guess
the padding length when the ciphertexts are equal.

5 The Attack in Real Life

Here we discuss various applications. In most of cases, the attack can be (and
is) avoided by using appropriate parameters. However, since this is not carefully
speciﬂed in the standards, our aim is to warn the users about possible bad
conﬂgurations.

5.1 SSL/TLS

O

Like in SSL, TLS v1.0 [7] uses the CBC-PAD scheme with W = 256 when using
block ciphers (default cipher being the RC4 stream cipher though). The only
diﬁerence is that the padding length is not necessarily less than b but can be
longer (but less than W
1) in order to hide the real length of the plaintext.
We can thus expect to use a TLS server like the

oracle.

¡

TLS v1.0 also provides an optional MAC which failed to thwart the attack:
when the server ﬂgures out that the MAC is wrong, it yields the bad_record_mac
error. However, the message padding is performed after the MAC algorithm, so
the MAC does not preclude our attack since it cannot be checked before the
padding in the decryption. The situation is a little diﬁerent in SSL v3.0 since
both wrong MAC both invalid padding return the same error. However, the
question whether the client can distinguish the two types of error is debatable.
The reason why the attack is not so practical is because the padding format
error (the decryption_failed error) is a fatal alert and the session must abort.
The server thus stops (or \explodes") as soon as the oracle outputs 0. For this
0. We can thus perform the postﬂx equality
reason we consider the bomb oracle
check oracle described in Section 3.4. It can be used in order to decrypt by
random trial the last word of a block with a probability of success of W ¡1, the
last two words of a block with a probability of success of W ¡2, ...

O

Interestingly, TLS wants to hide the real message length itself. We can easily
frustrate this feature by implementing a \length equality check bomb oracle" in
a very same way: if we want to check whether or not the padding length is equal
to n, we take the last ciphertext block y, and we send r
y to the server where the
j
1 and the others are random. Acceptance by
rightmost word of r is set to n
W ¡1. Rejection

'
0 means that the right length is n with probability at least 1

O
means that n is not the right length for sure.

¡

Since the padding length is between 1 and W , the above oracle may not look
so useful. We can still implement another bomb oracle which answers whether or
not the padding length is greater than b, i.e. if the length hiding feature of TLS
was used: let y1 and y2 be the last two ciphertext blocks. We just send r
y2
0. Acceptance means that the padding length is at
with a random block r to

y1

j

j

O

most b with probability at least 1
length is at least b + 1 for sure.

¡

W ¡1. Rejection means that the padding

5.2

IPSEC

IPSEC [9] can use CBC-PAD. Default padding scheme is similar, as speciﬂed in
ESP [10]. Standards clearly mention that the padding should be checked, but
the standard behavior in the case of invalid padding is quite strange: the server
just discards the invalid message and adds a notiﬂcation in log ﬂles for audit
and nothing else. This simply means that errors are processed according to non
standard rules or by another protocol layer. It is reasonable to assume that the
lack of activity of the receiver in this case, or the activity of the auditor, can be
converted into one bit of information. So our attack may be applicable.

IPSEC provides an optional authentication mechanism which could protect
against our attack, provided that the authentication check is performed before the
format check of the plaintext. Although used in most of practical applications,
this mechanism still has an optional status in IPSEC. As already recommended
by Bellovin [4], authentication should be mandatory. Bellovin actually used a side
channel which tells the validity of the TCP checksum. His attack was recently
extended to the WEP protocol for 802.11 wireless LANs by Borisov et al. [6].

5.3 WTLS

O

WTLS [1] (which is the SSL variant for WAP) perfectly implements the ora-
by sending decryption_failed warnings in clear. Actually since mobile
cle
telephones have a limited power and CPU resources, key establishment proto-
cols with public key cryptography are limited. So we try to limit the number
of session initializations and to avoid breaking them. So seldom errors are fatal
alerts. Some implementations of WTLS can however limit the tolerance number
of errors within the same session, which can limit the e–ciency of the attack.
This is however non standard.

In the case of mobile telephones (which is the main application of WTLS),
WTLS is usually encapsulated in other protocols which may provide their own
encryption protocol, for instance GSM. In this case, the extra encryption layer
needs to be bypassed by the attacker.

5.4 SSH2

In SSH2, the MAC is optional. When not used, our attack is feasible, but only
recovers one word since the padding is mostly random. When used, the MAC is
computed on the padded message. Therefore, it is checked before the padding
format, which protects against our attack.

6 Fixes which Do not Work

6.1 Padding Before the Message

One can propose to put the padding in the ﬂrst block. This only works for
CBC modes in which IV is not sent in clear with the ciphertext (otherwise the
same attack holds). This also requires to know the total length (modulo b) of
the message that we want to encrypt before starting the encryption. When the
plaintext is a word stream, this assumption is not usually satisﬂed. Therefore we
believe that this ﬂx is not satisfactory.

6.2 CBCCBC Mode

Another possibility consists of replacing the CBC mode by a double CBC en-
cryption (i.e. by re-encrypting the y1; : : : ; yN sequence in CBC mode). We call
it the CBCCBC mode.

C ¡1(y

Unfortunately, a similar attack holds: given y and z we can recover the value
of u = C ¡1(y)
z trials to the oracle. This is
y
j
j
'
enough in order to decrypt messages: if y is the (i
1)th ciphertext block, z is
the ith ciphertext block, and if t is the (i
2)th ciphertext block, then the ith
plaintext block is nothing but t

C ¡1(z)) by sending r

u!

'

¡

¡

The same attack holds with a triple CBC mode...

'

6.3 On-Line Ciphers and HCBC Mode

We can look for another mode of operation which \provably" leaks no informa-
tion. One should however try to keep the advantages of the CBC mode: being
able to encrypt a stream without knowing the total length, without having to
keep an expanding memory, ... In [3], Bellare et al. presented the notion of on-line
cipher. This notion is well adapted for these advantages of the CBC mode.

They also proposed the HCBC mode as a secure on-line cipher against chosen

plaintext attacks. The idea consists in replacing Eq. (1) by

yi = C(H(yi¡1)

xi)

'

¡

where H is a XOR-universal hash function which includes part of the secret key.
For instance one can propose H(x) = K1x in GF(W b) where K1
= 0 is part of
the secret key. (For any ﬂxed a; b; c with a
H(b) = c]
= b, we have Pr[H(a)
1=(W b

1) if K1 is uniformly distributed, thus H is XOR-universal.)

•

'

One problem is that this does not protect against the kind of attack we
y messages
proposed. For instance we notice that if we get several accepted ri
x ends with a valid padding for an
with a ﬂxed y, then we deduce that H(ri)
H(rj) is likely to end with the word zero.
unknown but ﬂxed x. Hence H(ri)
Since this is the last word of K1(ri
rj), we deduce K1 from several (i; j) pairs.
With the knowledge of K1 we then adapt the attack against the raw CBC. It is
even more dramatic here since we indeed recover a part of the secret key.

'
'

'

j

6
6
We outline that with the particular choice of XOR-universal hash function,
the claimed security result collapses. Of course, there is no contradiction with
the security result since our attack gets extra information from the side channel
oracle
, which was not allowed in the security model of [3]: the notion of on-
line cipher resistant against chosen plaintext attacks does not capture security
against the kind of cryptanalysis that we have proposed.

O

6.4 Other Modes of Operation

The ﬂrst stage of the standardization process on modes of operation launched
by NIST also contained problematic proposals.2 Several of the proposals could
be generalized as follows. The CBC mode is modiﬂed in order to have a XOR
before and after the block cipher encryption, depending on all previous ciphertext
blocks and all previous plaintext blocks. We replace Eq. (1) by

yi = C(xi

fi(x; y))

gi(x; y)

'

'

with public fi(x; y) and gi(x; y) functions which only depend on i and all xj
and yj for j = 1; : : : ; i
1. (Note that HCBC is not an example since fi is not
public.)

¡

: : :

Assuming that an attacker knows several (xj; yj) plaintext-ciphertext pairs
yj
xj
written xj = xj
, and she wants to compute C ¡1(y)
: : :
1j
‘j
‘j
j
j
for some given y, she can submit some yj
yj
‘j,
–) ciphertexts where k
: : :
1j
kj
j
– = gk+1(xj; yj). Acceptance would mean that the block C ¡1(y)
fk+1(xj; yj)
ends with a valid padding. Therefore we can decrypt the rightmost word with
W samples, two words with W 2 samples, ...

and yj = yj
1j

(y

'

'

•

6.5 CBC-PAD with Integrity Check

One can propose to add a cryptographic checkable redundancy code (crypto-
CRC) of the whole padded message (like a hashed value) in the plaintext and
encrypt

padding
message
j

h(message
j

padding):
j

This way, any forged ciphertext will have a negligible probability to be accepted
as a valid ciphertext. Basically, attackers are no longer able to forge valid cipher-
texts, so the scheme is virtually resistant against chosen ciphertext attacks.

Obviously it is important to pad before hashing: padding after hashing would

lead to the a similar attack. The right enciphering sequence is thus

pad, hash, encrypt

Conversely, the right deciphering sequence consists of decrypting, checking the
hashed value, then checking the padding value. Invalid hashed value must abort
the decipherment.

2 See http://csrc.nist.gov/encryption/modes/

There is still a nice security (cid:176)aw discovered by David Wagner for this scheme
in a subtle attack model.3 We perform a \semi-chosen plaintext attack": we
assume that we can convince the sender to send a message consisting of an
unknown x (of known length) concatenated by a chosen postﬂx, and the goal is
to get information on x. We can implement a guess check oracle: if g is a guess
y) where y is such that
h(g
for x, we ask the sender to concatenate x with y
j
j
g
y) (with a constant
h(g
y
y is a valid padded message. The sender then pads x
j
j
j
j
block bb : : : b), appends a message digest, and encrypts the whole sequence in
CBC mode. The attacker can then truncate the ciphertext after the h(g
y). If
the receiver accepts the truncated message, it means that the guess was right!

j

7 A Fix which May Work

The author of this paper ﬂrst thought that using authentication in the CBC-
PAD in order to thwart the attacks was an overkill. Wagner’s attack demon-
strates that it actually is not. We thus propose to replace the CBC encryption
by a scheme which simultaneously provides authentication and conﬂdentiality.
As having padding in between authentication and encryption (as is done in
TLS) is not a fortunate idea, the authentication-encryption scheme must apply
on padded plaintexts:

1. take the cleartext
2. pad the message and take the padded message x
3. authenticate and encrypt x
4. transmit the result y

Similarly, the authentication check and decryption must be performed before the
padding check:

1. decrypt and check the authenticity of y
2. take the plaintext x
3. check the padding of x
4. extract the padding and get the cleartext

(Note: we used the subtle diﬁerence between \cleartext" and \plaintext" as
speciﬂed in RFC 2828 [18]: the cleartext is the original message in clear, and the
plaintext is the input of the encryption process.)

The question whether authentication must be done before encryption or not
is another problem. As an example, Krawczyk [11] recently demonstrated the
security of the authenticate-then-CBC-encrypt scheme. We must however be
careful about the meaning of this security result: in this proof, attackers are not
assumed to have access to side channel oracles like in our model. Therefore the
security result may collapse when using an appropriate oracle as for the HCBC
mode. Therefore it is not quite clear how this result extends in a model where
we can have side channel. We leave this as an open problem.

Despite the lack of formal security result, we believe that this scheme oﬁers

the required security.
3 Private communication from David Wagner.

8 Conclusion

We have shown that several popular padding schemes which are used in order to
transform block ciphers into variable-input-length encryption schemes introduce
an important security (cid:176)aw. Correctness of the plaintext format is indeed a hard
core bit which easily leaks out from the communication protocol.

It conﬂrms that security analysis must not be limited to the block cipher
but must rather be considered within the whole environment: as was raised by
Bellovin [4] and Borisov et al. [6], we can really have insecure standards which use
unbroken cryptographic primitives. This was already well known in the public
key cryptography world. We have demonstrated that the situation of symmetric
cryptography is virtually the same.

Acknowledgments

I would like to thank Pascal Junod for helpful discussions. I also thank my stu-
dents from EPFL for having suﬁered on this attack as an examination topic.
After this attack was released at the Rump session of CRYPTO’01, several peo-
ple provided valuable feedback. I would in particular like to thank Bodo M˜oller,
Alain Hiltgen, Wenbo Mao, Ulrich K˜uhn, Tom St Denis, David Wagner, and
Martin Hirt. I also thank the anonymous referees for their extensive and perti-
nent comments.

References

1. Wireless Transport Layer Security. Wireless Application Protocol WAP-261-

WTLS-20010406-a. Wireless Application Protocol Forum, 2001.
http://www.wapforum.org/

2. R. Baldwin, R. Rivest. The RC5, RC5-CBC, RC5-CBC-Pad, and RC5-CTS Algo-

rithms RFC 2040, 1996.

3. M. Bellare, A. Boldyreva, L. Knudsen, C Namprempre. Online Ciphers and the
In Advances in Cryptology CRYPTO’01, Santa Bar-
Hash-CBC Construction.
bara, California, U.S.A., Lectures Notes in Computer Science 2139, pp. 292{309,
Springer-Verlag, 2001.

4. S. Bellovin. Problem Areas for the IP Security Protocols. In Proceedings of the 6th

Usenix UNIX Security Symposium, San Jose, California, USENIX, 1996.

5. D. Bleichenbacher. Chosen Ciphertext Attacks Against Protocols Based on the
In Advances in Cryptology CRYPTO’98,
RSA Encryption Standard PKCS#1.
Santa Barbara, California, U.S.A., Lectures Notes in Computer Science 1462, pp.
1{12, Springer-Verlag, 1998.

6. N. Borisov, I. Goldberg, D. Wagner. Intercepting Mobile Communications: The
Insecurity of 802.11. In Proceedings of the 7th Annual International Conference on
Mobile Computing and Networking, ACM Press, 2001.

7. T. Dierks, C. Allen. The TLS Protocol Version 1.0. RFC 2246, standard tracks,

the Internet Society, 1999.

8. M. Dworkin. Recommendation for Block Cipher Modes of Operation. US Depart-

ment of Commerce, NIST Special Publication 800-38A, 2001.

9. S. Kent, R. Atkinson. Security Architecture for the Internet Protocol. RFC 2401,

standard tracks, the Internet Society, 1998.

10. S. Kent, R. Atkinson. IP Encapsulating Security Payload (ESP). RFC 2406, stan-

dard tracks, the Internet Society, 1998.

11. H. Krawczyk. The Order of Encryption and Authentication for Protecting Com-
In Advances in Cryptology CRYPTO’01,
munications (or: How Secure is SSL?).
Santa Barbara, California, U.S.A., Lectures Notes in Computer Science 2139, pp.
310{331, Springer-Verlag, 2001.

12. L.R. Knudsen. Block Ciphers | Analysis, Design and Applications, Aarhus Uni-

versity, 1994.

13. J. Manger. A Chosen Ciphertext Attack on RSA Optimal Asymmetric Encryption
In Advances in Cryptology
Padding (OAEP) as Standardized in PKCS#1 v2.0.
CRYPTO’01, Santa Barbara, California, U.S.A., Lectures Notes in Computer Sci-
ence 2139, pp. 230{238, Springer-Verlag, 2001.

14. A.J. Menezes, P.C. van Oorschot, S.A. Vanston. Handbook of Applied Cryptography,

CRC, 1997.

15. E. Petrank, C. Rackoﬁ. CBC MAC for Real-Time Data Sources. Journal of Cryp-

tology, vol. 13, pp. 315{338, 2000.

16. B. Preneel, P. C. van Oorschot. Mdx-MAC and Building Fast MACs from Hash
In Advances in Cryptology CRYPTO’95, Santa Barbara, California,

Functions.
U.S.A., Lectures Notes in Computer Science 963, pp. 1{14, Springer-Verlag, 1995.

17. B. Schneier. Applied Cryptography, 2nd Edition, John Wiley & Sons, 1996.
18. R. Shirey. Internet Security Glossary. RFC 2828, the Internet Society, 2000.
19. S. Vaudenay. Decorrelation over Inﬂnite Domains: the Encrypted CBC-MAC Case.
In Selected Areas in Cryptography’00, Waterloo, Ontario, Canada, Lectures Notes
in Computer Science 2012, pp. 189{201, Springer-Verlag, 2001.
Journal version:
Communications in Information and Systems, vol. 1, pp. 75{85, 2001.



=== Content from h20566.www2.hpe.com_a5cb5916_20250124_191001.html ===


[**Support Center**](/connect/s/)


