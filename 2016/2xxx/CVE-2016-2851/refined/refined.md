```json
{
  "CVE-2016-2851": {
    "Description": "Integer overflow in proto.c in libotr before 4.1.1 on 64-bit platforms allows remote attackers to cause a denial of service (memory corruption and application crash) or execute arbitrary code via a series of large OTR messages, which triggers a heap-based buffer overflow.",
    "Root cause": "Integer overflow due to storing sizes of incoming messages in variables of type `int` or `unsigned int` instead of `size_t`.",
     "Weaknesses": [
        "Integer Overflow",
        "Heap buffer overflow"
      ],
    "Impact": "A remote attacker can cause a denial of service (application crash) or potentially execute arbitrary code on the user's machine.",
    "Attack vectors": "Sending specially crafted, large OTR messages over a network.",
    "Required attacker capabilities": "Ability to send messages to a vulnerable libotr instance. No special user interaction or authorization is necessary in default configurations.",
        "Additional Information": "The vulnerability is triggered if a value of 0xFFFFFFFF (MAX_UINT) is read from the message buffer. As datalen is of size 32-bit (unsigned int) the operation datalen+1 will wrap around before being passed to malloc. This will effectively result in a zero allocation (malloc(0)) which is valid in common implementations of malloc on the x86_64 architecture. As no addition is done in the value passed to the call to memmove, 4 gigabytes of data are copied out of bounds to the heap location pointed to by data. The vulnerability can be triggered by sending fragmented messages."
  }
}
```