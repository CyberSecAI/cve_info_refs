```
{
  "guidelines": "1. First verify if the content relates to the CVE specified based on the official description\n2. If the content does not relate to this CVE, respond with \"UNRELATED\"\n3. If no useful vulnerability information is found, respond with \"NOINFO\" \n4. For relevant content, extract:\n   - Root cause of vulnerability\n   - Weaknesses/vulnerabilities present\n   - Impact of exploitation\n   - Attack vectors\n   - Required attacker capabilities/position\n\nAdditional instructions:\n- Preserve original technical details and descriptions\n- Remove unrelated content\n- Translate non-English content to English\n- Note if the content provides more detail than the official CVE description",
  "response": {
    "CVE-2016-3706": [
      {
        "content": "Stack-based buffer overflow in the glob implementation in GNU C Library (aka glibc) before 2.24, when GLOB_ALTDIRFUNC is used, allows context-dependent attackers to cause a denial of service (crash) via a long name.",
        "root cause": "Stack-based buffer overflow in the glob implementation when GLOB_ALTDIRFUNC is used.",
        "weaknesses": [
          "Stack-based buffer overflow"
        ],
        "impact": "Denial of service (crash).",
        "attack vectors": "Long name when GLOB_ALTDIRFUNC is used.",
         "required capabilities": "Context-dependent attacker"
      },
       {
        "content": "When converting a struct hostent response to struct gaih_addrtuple, the gethosts macro (which is called from gaih_inet) uses alloca, without malloc fallback for large responses.  This code path is used with AF_INET and AF_INET6 queries, not AF_UNSPEC queries.  In essence, this is an incomplete fix for CVE-2013-4458 ([bug 16072](show_bug.cgi?id=16072 \"RESOLVED FIXED - Segmentation fault in getaddrinfo() when processing entry mapping to long list of AF_INET6 address structures\")).  The buffer passed to the NSS module is relocated to the heap, but data from it is still copied to the stack.  Over DNS, at most 4095 addresses can arrive, and per address, a net 40 bytes of stack space are needed, so with usual stack sizes and system configurations, the bug cannot be triggered over the network.",
        "root cause": "The `gethosts` macro, used for converting `struct hostent` to `struct gaih_addrtuple` when called from `gaih_inet`, uses `alloca` without a `malloc` fallback for large responses. This results in a stack-based buffer overflow. Although the initial buffer from NSS modules was moved to the heap, the data was copied back to the stack.",
        "weaknesses": [
          "Stack-based buffer overflow due to the usage of alloca without malloc fallback"
        ],
        "impact": "A stack overflow could occur.",
        "attack vectors": "The vulnerability is triggered during AF_INET and AF_INET6 queries when converting a large struct hostent response. While technically it can be triggered over DNS, the limit of 4095 addresses per response and the usual stack sizes of systems means that it cannot be triggered over the network.",
         "required capabilities": "Attacker needs to make the system resolve queries with very long responses."
      },
      {
        "content": "Previously, getaddrinfo copied large amounts of address data to the stack, even after the fix for CVE-2013-4458 has been applied, potentially resulting in a stack overflow. getaddrinfo now uses a heap allocation instead. Reported by Michael Petlan. (CVE-2016-3706)",
        "root cause": "The `getaddrinfo` function was copying large amounts of address data to the stack, which led to a stack overflow vulnerability. This was despite prior attempt to fix CVE-2013-4458.",
          "weaknesses": [
          "Stack-based buffer overflow due to copying data to the stack in getaddrinfo."
          ],
          "impact": "A stack overflow, leading to application crash.",
          "attack vectors": "Processing of a large address data in `getaddrinfo`.",
         "required capabilities": "None specified."
      },
       {
        "content": "When converting a struct hostent response to struct gaih_addrtuple, the gethosts macro (which is called from gaih_inet) used alloca, without malloc fallback for large responses.  This commit changes this code to use calloc unconditionally.",
        "root cause": "The gethosts macro uses alloca without a malloc fallback. ",
        "weaknesses": [
          "Stack overflow"
        ],
       "impact": "Stack overflow",
         "attack vectors": "Conversion of struct hostent response to struct gaih_addrtuple, specifically during the use of `gethosts` macro called from `gaih_inet`.",
        "required capabilities": "None specified"
      },
      {
        "content": "The glob function suffered from a stack-based buffer overflow when it was called with the GLOB_ALTDIRFUNC flag and encountered a long file name. Reported by Alexander Cherepanov. (CVE-2016-1234)",
        "root cause": "Stack-based buffer overflow in `glob` due to improper handling of long file names when `GLOB_ALTDIRFUNC` is set.",
        "weaknesses": [
          "Stack-based buffer overflow"
        ],
        "impact": "Denial of Service (crash)",
        "attack vectors": "Calling `glob` with `GLOB_ALTDIRFUNC` flag on a directory containing long filenames.",
       "required capabilities": "Attacker must be able to influence the file system."
      }
    ],
      "CVE-2016-3075": [
        {
           "content": "Stack-based buffer overflow in the nss_dns implementation of the getnetbyname function in GNU C Library (aka glibc) before 2.24 allows context-dependent attackers to cause a denial of service (stack consumption and application crash) via a long name.",
            "root cause": "Stack-based buffer overflow in the `nss_dns` implementation of `getnetbyname`.",
            "weaknesses": [
              "Stack-based buffer overflow"
            ],
            "impact": "Denial of service (stack consumption and application crash).",
            "attack vectors": "A long name passed to `getnetbyname`.",
            "required capabilities": "Context-dependent attacker needs to resolve a long network name"
        },
          {
           "content": "An unnecessary stack copy in _nss_dns_getnetbyname_r was removed.  It   could result in a stack overflow when getnetbyname was called with an overly long name.  (CVE-2016-3075)",
            "root cause": "Unnecessary stack copy in the `_nss_dns_getnetbyname_r` function.",
            "weaknesses": [
              "Stack-based buffer overflow"
            ],
            "impact": "Stack overflow and application crash when `getnetbyname` is called with an overly long name.",
             "attack vectors": "Calling `getnetbyname` with an excessively long name.",
        "required capabilities": "Attacker must be able to influence the name that needs to be resolved."
        },
        {
        "content": "nss-dns-getnetbyname.patch: fix stack overflow in _nss_dns_getnetbyname_r (CVE-2016-3075, boo#973164, BZ #19879)",
        "root cause": "Stack buffer overflow in _nss_dns_getnetbyname_r.",
        "weaknesses": [
          "Stack overflow"
         ],
        "impact": "Stack overflow when resolving names using DNS.",
        "attack vectors": "DNS name resolution.",
          "required capabilities": "Attacker must control a domain name and its DNS records."
      }
     ],
     "CVE-2016-4429": [
      {
        "content": "Stack-based buffer overflow in the clntudp_call function in sunrpc/clnt_udp.c in the GNU C Library (aka glibc or libc6) allows remote servers to cause a denial of service (crash) or possibly unspecified other impact via a flood of crafted ICMP and UDP packets.",
         "root cause": "Stack-based buffer overflow in `clntudp_call` function.",
        "weaknesses": [
         "Stack-based buffer overflow"
        ],
        "impact": "Denial of Service (crash) or other unspecified impacts.",
        "attack vectors": "Remote servers flooding crafted ICMP and UDP packets.",
         "required capabilities": "Attacker must be able to send a flood of crafted ICMP/UDP packets."
      },
     {
         "content": "The Sun RPC UDP client could exhaust all available stack space when   flooded with crafted ICMP and UDP messages.  Reported by Aldy Hernandez'   alloca plugin for GCC.  (CVE-2016-4429)",
          "root cause": "The Sun RPC UDP client could exhaust available stack space when processing crafted ICMP and UDP messages.",
           "weaknesses": [
          "Stack exhaustion"
          ],
          "impact": "Exhaustion of stack space, possibly leading to denial of service.",
         "attack vectors": "Flooding crafted ICMP and UDP messages to the Sun RPC UDP client.",
         "required capabilities": "Attacker has to be able to send UDP/ICMP packets"
        },
      {
        "content": "sunrpc: Do not use alloca in clntudp_call [BZ #20112]",
         "root cause": "The Sun RPC UDP client was using `alloca`, without a size check, to allocate buffer, leading to stack overflow if excessive data is received.",
        "weaknesses": [
          "Stack overflow."
        ],
       "impact": "Stack exhaustion and denial of service.",
         "attack vectors": "Sending crafted ICMP and UDP packets towards `clntudp_call` function.",
       "required capabilities": "Attacker can send crafted UDP/ICMP packets."
      }
    ],
  "CVE-2016-1234": [
        {
          "content": "Stack-based buffer overflow in the glob implementation in GNU C Library (aka glibc) before 2.24, when GLOB_ALTDIRFUNC is used, allows context-dependent attackers to cause a denial of service (crash) via a long name.",
         "root cause": "Stack-based buffer overflow in the `glob` implementation when called with `GLOB_ALTDIRFUNC`.",
          "weaknesses": [
            "Stack-based buffer overflow."
           ],
          "impact": "Denial of service (crash).",
         "attack vectors": "Using a long name when the `glob` function with the `GLOB_ALTDIRFUNC` option is used.",
          "required capabilities": "Attacker can control the directory structure passed to glob."
        },
    {
      "content": "The glob function suffered from a stack-based buffer overflow when it was called with the GLOB_ALTDIRFUNC flag and encountered a long file name. Reported by Alexander Cherepanov. (CVE-2016-1234)",
        "root cause": "Stack-based buffer overflow in the `glob` function when called with the `GLOB_ALTDIRFUNC` flag, and encountering a long filename.",
        "weaknesses": [
          "Stack overflow"
         ],
        "impact": "Denial of service (application crash).",
       "attack vectors": "Calling glob with GLOB_ALTDIRFUNC and an overlong file name.",
         "required capabilities": "None specified"
      }
    ]
    }
}
```