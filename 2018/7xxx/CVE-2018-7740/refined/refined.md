```
{
  "CVE-2018-7740": {
    "description": "Multiple integer overflows existed in the hugetlbfs implementation in the Linux kernel. A local attacker could use this to cause a denial of service (system crash).",
    "root_cause": "The hugetlbfs filesystem's mmap operation did not properly range-check the file offset. The pgoff argument passed to remap_file_pages() is a page offset, however, the hugetlbfs code converts it to a byte offset using '<< PAGE_SHIFT', which can lead to an overflow if the argument is too large. This results in a range with a 'from' offset greater than the 'to' offset during reservation process, causing the code to think there is an error, and prevents the reservation process from completing which causes the kernel to crash.",
    "weaknesses": [
      "Integer Overflow",
      "Improper Input Validation",
	    "Incorrect offset calculation"
    ],
    "impact": "Denial of service (system crash)",
    "attack_vectors": [
      "Local access",
	  "mmap system calls",
      "remap_file_pages system call"
    ],
    "required_capabilities": [
      "Local user access to files on a hugetlbfs filesystem",
	    "Ability to call mmap and remap_file_pages syscalls"
    ],
	"additional_details": "The issue is triggered when the pgoff argument passed to remap_file_pages() is 0x20000000000000. When this large offset is converted to a byte offset by '<< PAGE_SHIFT' an overflow occurs. In the process of converting this to a page offset and putting it in vm_pgoff, and then converting back to bytes to compute mapping length, it results in a 0. This results in the code passing page offsets into hugetlbfs where the start offset is greater than the end offset. The negative range looks like an error and the huge page reservation code doesn't complete. This leaves 'adds_in_progress' flag set and later triggers the VM_BUG_ON leading to a kernel crash."
  }
}
```