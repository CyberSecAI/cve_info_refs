=== Content from www.okta.com_62a040ff_20250125_073238.html ===
This site works best with JavaScript enabled. [Security](/articles)[Go to Okta.com ↗](https://www.okta.com)[‹ Back to blog](/articles)June 12, 2018
# I can be Apple, and so can you

![](data:image/svg+xml;charset=utf-8...)![]()![](https://images.ctfassets.net/kbkgmx9upatd/mIaduB5YDBYLqypFMGoOY/533314f952aca53f7e475678954fd2d0/Josh_2520Pitts.jpg?w=58&h=58&fl=progressive&q=50&fm=jpg)Josh Pitts
#### *A Public Disclosure of Issues Around Third Party Code Signing Checks*

**Summary:**

* A bypass found in third party developers’ interpretation of code signing API allowed for unsigned malicious code to appear to be signed by Apple.
* Known affected vendors and open source projects have been notified *and patches are available.*
* However, more third party security, forensics, and incident response tools that use the official code signing APIs are possibly affected.
* Developers are responsible for using the code signing API properly, POCs are released to help developers test their own code.
* The bypass affects Fat/Universal file format and the lack of verification of nested formats.
* Affects only macOS and older versions of OSX.

**Affected Vendors:**

* VirusTotal – CVE-2018-10408
* Google – Santa, molcodesignchecker – CVE-2018-10405
* Facebook – OSQuery - CVE-2018-6336
* Objective Development – LittleSnitch – CVE-2018-10470
* F-Secure - xFence (also LittleFlocker) CVE-2018-10403
* Objective-See – WhatsYourSign, ProcInfo, KnockKnock, LuLu, TaskExplorer (and others). – CVE-2018-10404
* Yelp - OSXCollector – CVE-2018-10406
* Carbon Black – Cb Response – CVE-2018-10407

**The Importance of Code Signing and How it Works on \*OS**

Code signing is a security construct that uses public key infrastructure to digitally sign compiled code or even scripting languages to ensure a trusted origin and to ensure that the deployed code has not been modified. On Windows you can cryptographically sign just about everything from .NET binaries to PowerShell scripts. On macOS/iOS, code signing focuses on the Mach-O binary and application bundles to ensure only trusted code is executed in memory.

Security, incident response, and forensics processes and personnel use code signing to weed out trusted code from untrusted code. By verifying signed code, detection and response personnel can speed up investigations by separating trusted code from untrusted code. Different types of tools and products use code signing to implement actionable security; this includes whitelisting, antivirus, incident response, and threat hunting products. To undermine a code signing implementation for a major OS would break a core security construct that many depend on for day to day security operations.

Code signing is not without its problems([1](https://specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf), [2](https://github.com/secretsquirrel/SigThief), [3](https://github.com/secretsquirrel/Shmoocon2016/blob/master/preso_shmoocon_2016.pdf), [4](https://www.usenix.org/system/files/conference/usenixsecurity13/sec13-paper_wang-updated-8-23-13.pdf), [5](https://github.com/kpwn/935csbypass)). Unlike some of the prior work, this current vulnerability does not require admin access, does not require JIT’ing code, or memory corruption to bypass code signing checks. All that is required is a properly formatted Fat/Universal file and code signing checks return valid.

**Vulnerability Details**

This vulnerability exists in the difference between how the Mach-O loader loads signed code vs how improperly used Code Signing APIs check signed code and is exploited via a malformed Universal/Fat Binary.

*What is a Fat/Universal file?*

A Fat/Universal file is a binary format that contains several Mach-O (an executable, dyld, or bundle) files with each targeting a specific native CPU architecture (example: i386, x86\_64, or PPC).

**Conditions for the vulnerability to work:**

* The first Mach-O in the Fat/Universal file must be signed by Apple, can be i386, x86\_64, or even PPC.
* The malicious binary, or non-Apple supplied code, must be adhoc signed and i386 compiled for an x86\_64 bit target macOS.
* The CPU\_TYPE in the Fat header of the Apple binary must be set to an invalid type or a CPU Type that is not native to the host chipset.

Without passing the proper [SecRequirementRef](https://developer.apple.com/documentation/security/secrequirementref?language=objc) and [SecCSFlags](https://developer.apple.com/documentation/security/seccsflags?language=objc), the code signing API ([SecCodeCheckValidity](https://developer.apple.com/documentation/security/1396726-seccodecheckvalidity?language=objc)) will check the first binary in the Fat/Universal file for who signed the executable (e.g. Apple) and verify no tampering via the cryptographic signature; then the API will check each of the following binaries in the Fat/Universal file to ensure the Team Identifiers match and verify no tampering via containing cryptographic signature **but without checking the CA root of trust**. The reason the malicious code, or “unsigned” code, must be i386, is that the code signing API has a preference for the native CPU architecture (x86\_64) for code signing checks and will default to checking the unsigned code if it is x86\_64.

Part of the reason why adhoc signing of the malicious code works is because the TeamIdentifier equals “not set” even for core Apple signed binaries. Figure 1 shows a valid Apple signed Mach-O (python.x64) vs an adhoc signed Mach-O (ncat.i386) where both `TeamIdentifier=not set`.

![](//images.ctfassets.net/kbkgmx9upatd/5lrz4FtUKZt45RrWggMluh/f3882265e06479e85a68814242e6e4af/Okta-Security-Blog-CodeSigning-BlogPost1.jpg)

For example, I used a developer ID to sign a file and tried using lipo to create a single Fat/Universal file with an Apple signed binary. This failed to verify with codesign when used.

![](//images.ctfassets.net/kbkgmx9upatd/7EdSF4L9Klav3Oa7LoYgH0/1b956d1955d7d98ad037155095454184/Okta-Security-Blog-CodeSigning-BlogPost2.jpg)

My initial POC, was a ncat (from nmap) example I called ncat.frankenstein, where I added the python x86\_64 Apple-signed binary and ncat i386 adhoc signed binary into one Fat file. Creating an adhoc signed binary is as easy as `codesign -s - target\_mach-o\_or\_fat\_binary`. If viewed in [MachOView](https://sourceforge.net/projects/machoview/):

![](//images.ctfassets.net/kbkgmx9upatd/40BCMVFXSuJFnF4BIylCjK/fe4a3b17d5bd4e2c9546622792987747/Okta-Security-Blog-CodeSigning-BlogPost3.jpg)

At this point if I attempt to execute this file, the python x86\_64 binary will execute:

![](//images.ctfassets.net/kbkgmx9upatd/ZC4LRyXLPzDbJ7PIssthu/c975ad2262ef13e1a65c2f0418985b1a/Okta-Security-Blog-CodeSigning-BlogPost4.jpg)

And the code signature verifies as valid:

![](//images.ctfassets.net/kbkgmx9upatd/2utkRS0gKFN33TkIsdOiXs/0f6f275ce9a4481a656348adaf0dfe3d/Okta-Security-Blog-CodeSigning-BlogPost5.jpg)

How can I have the self-signed/adhoc-signed ncat binary executed?

By setting the CPU\_Type to an invalid type or valid not native CPU type (example: PPC), the Mach-O loader will skip over the validly signed Mach-O binary and execute the malicious (non-Apple signed) code:

![](//images.ctfassets.net/kbkgmx9upatd/6ZSay652JlLyzlrvHbxJSs/fbef053851bb08133e6e73f5462af5e5/Okta-Security-Blog-CodeSigning-BlogPost6.jpg)

And then ncat.frankenstein will execute and the strict checking result will show as ‘valid’:

![](//images.ctfassets.net/kbkgmx9upatd/1lGecztFYoQd2jOP7fu1qa/fd37e51f859059728d9c8144f3f92437/Okta-Security-Blog-CodeSigning-BlogPost7.jpg)

We are [providing](https://github.com/OktaSecurityLabs/CodeSigningSamples) the ncat.frankenstein example and four other examples for developers to test if their products are affected.

| **Sample Name** | **SHA-256 Hash** | **Notes** |
| --- | --- | --- |
| bash\_not\_signed | 5daba6c40be028d2139d1c7246f7ea2d86adedf44daf05f7be47307ebc6a572e | Sample Not signed, malformed header |
| Bash\_ppc\_adhoc | 67884b18faa1225903a3cc0a5ec6acc8b73b2b0d61d0935eb6510de11abd0cc7 | PPC, adhoc signed, non-malformed header |
| Bash\_adhoc | 9dc5b06c50a2566de5fc695f1d18fc2c5efb273fd4e957db68708c052f805751 | Adhoc signed, malformed header |
| Terminal.app (requires Sierra macOS 10.12 to execute) | Terminal.app.zip 9b33dc17555663b378fe7ea698be0cb857fc739c23fc6a46b39617228b04c0cc | Application Bundle, Adhoc signed, malformed header |
| ncat.frankenstein | daa81c2858d58a071fe7a8cad2afc95e67d4271fd1149e997ff0cb5132300699 | Adhoc signed, malformed header |

**Recommendation:**

*Via Command line*

It depends on how you check signed code. If you use codesign, you are probably already familiar with the following commands:

* `codesign –dvvvv` - This will dump the CA authority and TeamIdentifier (developer ID).
* `codesign –vv` - This will do strict checking and validate all architectures.

However, to properly check for this type of abuse you need to add an anchor certificate requirement via the following [commands:](https://developer.apple.com/library/content/documentation/Security/Conceptual/CodeSigningGuide/RequirementLang/RequirementLang.html)

* codesign -vv -R='anchor apple' ./some\_application\_or\_mach-o # for Apple signed code
* codesign -vv -R='anchor apple generic' ./some\_application\_or\_mach-o # for Apple signed code and Apple developer signed code

Doing so will result in a proper failure to satisfy the requirement:

![](//images.ctfassets.net/kbkgmx9upatd/5nJXUz0RGmFwfjWiqfpXP2/cc27aa663c946af7b5746c4d506b5f2f/Okta-Security-Blog-CodeSigning-BlogPost8.jpg)

The command `spctl` could be used, but careful analysis of the command output is required. For example, a valid Apple Signed Mach-O binary /bin/ls and Safari returns the following:

![](//images.ctfassets.net/kbkgmx9upatd/69qfmke6jwmilnLi5l7Wgm/96cb26583c6e77c1951fdcb272af6243/Okta-Security-Blog-CodeSigning-BlogPost9.jpg)

With a normal output from a valid Apple signed application bundle:

![](//images.ctfassets.net/kbkgmx9upatd/w3k2kQQJInKeoVYuGoONe/d71195c1b267f59a0f97573c7ba58bf9/Okta-Security-Blog-CodeSigning-BlogPost10.jpg)

Notice the following string “(the code is valid but does not seem to be an app)” for /bin/ls while being rejected. Conversely, the ncat.frankenstein Fat/Universal file:

![](//images.ctfassets.net/kbkgmx9upatd/6IssyVNDKtN0ARPO1FpKzN/37cf8f3cd6b09b2dc9bf7e5c2a47145f/Okta-Security-Blog-CodeSigning-BlogPost11.jpg)

With the ncat.frankenstein Fat/Universal file there is no output stating that the code is valid. So, I cannot recommend spctl for manual verification of standalone Mach-O binaries, just use codesign with the requirements flag.

*For developers*

Typically, a developer would check the a Mach-O binary or Fat/Universal binary with the following APIs [SecStaticCodeCheckValidityWithErrors](https://developer.apple.com/documentation/security/1395272-seccodecheckvaliditywitherrors?language=objc)() or [SecStaticCodeCheckValidity](https://developer.apple.com/documentation/security/1395784-secstaticcodecheckvalidity?language=objc)() with the following flags:

* [kSecCSStrictValidate](https://developer.apple.com/documentation/security/kseccsstrictvalidate)
* [KSecCSCheckAllArchitectures](https://developer.apple.com/documentation/security/kseccscheckallarchitectures)

These flags are supposed to ensure that all the code in a Mach-O or Fat/Universal file that is loaded into memory is cryptographically signed. However, these APIs fall short by default, and third party developers will need to carve out and verify each architecture in the Fat/Universal file and verify that the identities match and are cryptographically sound.

The best way to check each nested architecture in a Fat/Universal file is to first call [SecRequirementCreateWithString](https://github.com/objective-see/WhatsYourSign/blob/29aec698696d58cb1d1d6f0cc9dbeb0340d6bd78/WhatsYourSignExt/FinderSync/Signing.m#L324) with the requirement “anchor apple” then [SecStaticCodeCheckValidity](https://github.com/objective-see/WhatsYourSign/blob/29aec698696d58cb1d1d6f0cc9dbeb0340d6bd78/WhatsYourSignExt/FinderSync/Signing.m#L334) with the following flags [kSecCSDefaultFlags | kSecCSCheckNestedCode | kSecCSCheckAllArchitectures | kSecCSEnforceRevocationChecks](https://github.com/objective-see/WhatsYourSign/blob/29aec698696d58cb1d1d6f0cc9dbeb0340d6bd78/WhatsYourSignExt/FinderSync/Item.m#L338) with the requirement reference; as demoed in Patrick Wardle’s patched [WhatsYourSign](https://objective-see.com/products/whatsyoursign.html) source code.

By passing “anchor apple” to the SecRequirmentCreateWithString function, this acts in a similar way to codesign -vv -R=’anchor apple’ requiring the Apple Software Signing chain of trust across all nested binaries in the Fat/Universal file. Furthermore by passing the noted flags and the requirement to SecStaticCodeCheckValidity, all architectures are checked for the requirement and revocations checks are applied.

**Proof of Concepts:**

Apple’s ‘codesign’ tool and why one should use the requirements flag (-R).

![](//images.ctfassets.net/kbkgmx9upatd/5KPqwcPqAv1z67hoIt74xM/6150f7c4c92af31cbe4d319c29dbc3b2/Okta-Security-Blog-CodeSigning-BlogPost12.jpg)

LittleSnitch – Verification of the Fat/Universal file failed on-disk, however, LittleSnitch does correctly check the process mapped into memory.

![](//images.ctfassets.net/kbkgmx9upatd/4zAnNXlKeaAslbiJ7pyVFN/d69f285b4211f5189035caf91c64c815/Okta-Security-Blog-CodeSigning-BlogPost13.jpg)![](//images.ctfassets.net/kbkgmx9upatd/35F8lDhzUQd9Wqj9KAyktc/f82b0c88d230791f0de6a9f8af888efd/Okta-Security-Blog-CodeSigning-BlogPost14.jpg)

LittleFlocker – F-Secure bought LittleFlocker and is now xFence.

![](//images.ctfassets.net/kbkgmx9upatd/3IRps4WSmD1phE8q8BIjmL/b965dd586d128a74cac238d647b942c2/Okta-Security-Blog-CodeSigning-BlogPost15.jpg)

F-Secure xFence (formerly LittleFlocker)

![](//images.ctfassets.net/kbkgmx9upatd/4esK0P11vWXKcQmoSTQITP/7f8d92cbc55e2a3ac7204a0df7e81fba/Okta-Security-Blog-CodeSigning-BlogPost16.jpg)

Objective-See Tools

* TaskExplorer

![](//images.ctfassets.net/kbkgmx9upatd/5RZ3duHxgq16l3gOZW4TyY/f4c7820a26120b5169bf51521230817a/Okta-Security-Blog-CodeSigning-BlogPost17.jpg)![](//images.ctfassets.net/kbkgmx9upatd/7Axjp1XdE9MWZWskBcxRH4/b405966207a343c1f946dc6e256386a8/Okta-Security-Blog-CodeSigning-BlogPost18.jpg)

* WhatsYourSign

![](//images.ctfassets.net/kbkgmx9upatd/3WFhlLGIBCgiBwaRXss4Yn/8e2492b9457f5f00555b45fae4f59ba5/Okta-Security-Blog-CodeSigning-BlogPost19.jpg)

Facebook OSquery – checks against the malicious samples with /bin/ls as a valid example.

![](//images.ctfassets.net/kbkgmx9upatd/1QDpCU7KEtnqack1SifdDb/1b490a5eac080b8449bcb68041e98c5e/Okta-Security-Blog-CodeSigning-BlogPost20.jpg)

Google Santa – Fileinfo output showing the ncat.frankenstein is whitelisted.

![](//images.ctfassets.net/kbkgmx9upatd/4HIy5qF9KF9Drji7Tzcwbj/f48d262dc035f860d0ce7d036907fb74/Okta-Security-Blog-CodeSigning-BlogPost21.jpg)

Showing the execution deny of ncat (unsigned) and a execution allow of ncat.frankenstein:

![](//images.ctfassets.net/kbkgmx9upatd/4OYAh59ad1uf9pOqba4qLz/b1ef02b52645fe005b28b5d81b929bed/Okta-Security-Blog-CodeSigning-BlogPost22.jpg)

Detailed output of santa.log showing event actions on prior examples:

![](//images.ctfassets.net/kbkgmx9upatd/4QDbmv7Uatt5dMB49tpDCt/ca1b98b75e7e542323b414f15accaca0/Okta-Security-Blog-CodeSigning-BlogPost23.jpg)

Carbon Black Response

![](//images.ctfassets.net/kbkgmx9upatd/CtHrrkuAZpdUQcIdEQSSI/36fe3411b53238fa234467c7430bb7ed/Okta-Security-Blog-CodeSigning-BlogPost24.jpg)

Virus Total – Example of bash\_ppc\_adhoc before patching by Virustotal:

![](//images.ctfassets.net/kbkgmx9upatd/6xe87AmYd8QgwpNTUW871z/0ea5a9b0caf8e041973dd65d39300e15/Okta-Security-Blog-CodeSigning-BlogPost25.jpg)

**Disclosure Timeline**

February 22, 2018 – Submitted to Apple a report and a POC that was able to bypass third party security tools.

March 1, 2018 – Apple responded that third party developers should use kSecCSCheckAllArchitectures and kSecCSStrictValidate with SecStaticCodeCheckValidity API and developer documentation will be updated.

March 6, 2018 – Submitted a report and POC to Apple that bypasses both flags and “codesign” strict checking.

March 16, 2018 – Submitted additional information to Apple.

March 20, 2018 – Apple stated they did not see this as a security issue that they should directly address.

March 29, 2018 – Apple stated that documentation could be updated and new features could be pushed out, but: “[…], third-party developers will need to do additional work to verify that all of the identities in a universal binary are the same if they want to present a meaningful result.”

April 2, 2018 – Initial contact with CERT/CC and subsequent collaboration to clarify the scope and impact of the vulnerability.

April 9, 2018 – All known affected third party developers are notified in coordination with CERT/CC.

April 18, 2018 – Last contact with CERT/CC recommending that a public disclosure via blog post is the best for reaching remaining third parties that use code signing APIs in a private manner.

June 05, 2018 – Final Developer contact before publication.

June 12, 2018 – Disclosure publication

**In closing**

Thanks to all the third party developers and their hard work and professionalism to address this issue. Code signing vulnerabilities can be particularly demoralizing especially for companies that are trying to provide assurance beyond the default state of operating system security. For those interested in the details to how I found this vulnerability, please attend my [Shakacon](https://www.shakacon.org/i-can-be-apple-and-so-can-you-by-josh-pitts/) talk next month in Oahu, Hawaii.

![](data:image/svg+xml;charset=utf-8...)![]()![](https://images.ctfassets.net/kbkgmx9upatd/mIaduB5YDBYLqypFMGoOY/533314f952aca53f7e475678954fd2d0/Josh_2520Pitts.jpg?w=58&h=58&fl=progressive&q=50&fm=jpg)Josh PittsPrincipal Hacker, Offsec Team

Josh Pitts is a Principal Hacker at Okta on our offsec team. He has over 15 years' experience conducting physical and IT security assessments, IT security operations support, penetration testing, malware analysis, reverse engineering, and forensics. Josh also served in the US Marines working in SIGINT.

* [Subscribe to RSS](https://sec.okta.com/rss.xml)
* [trust.okta.com](https://trust.okta.com)
* [sec.okta.com](https://sec.okta.com)
* [okta.com](https://okta.com)

