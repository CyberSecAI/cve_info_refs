```
{
  "CVE-2018-18397": {
    "description": "Jann Horn discovered that the userfaultd implementation in the Linux kernel did not properly restrict access to certain ioctls. A local attacker could use this possibly to modify files.",
    "fixes": [
      "After the VMA to register the uffd onto is found, check that it has VM_MAYWRITE set before allowing registration. This way we inherit all common code checks before allowing to fill file holes in shmem and hugetlbfs with UFFDIO_COPY.\nThe userfaultfd memory model is not applicable for readonly files unless it's a MAP_PRIVATE.",
      "Fix it by always doing truncate_inode_pages which is already ready for nrpages == 0 && nrexceptional == 0 case and just invalidates inode.",
       "With MAP_SHARED: recheck the i_size after taking the PT lock, to serialize against truncate with the PT lock. Delete the page from the pagecache if the i_size_read check fails.\nWith MAP_PRIVATE: check the i_size after the PT lock before mapping anonymous memory or zeropages into the MAP_PRIVATE shmem mapping.\nA mostly irrelevant cleanup: like we do the delete_from_page_cache() pagecache removal after dropping the PT lock, the PT lock is a spinlock so drop it before the sleepable page lock.",
      "Set the page dirty if VM_WRITE is not set because in such case the pte won't be marked dirty and the page would be reclaimed without writepage (i.e. swapout in the shmem case).",
      "The userfaultfd memory model is not applicable for readonly files unless it's a MAP_PRIVATE.",
      "Fix the shmem-backed implementation of UFFDIO_COPY to create private\nmemory for MAP_PRIVATE mappings. The hugetlbfs-backed implementation\nwas already correct.",
       "We internally used EFAULT to communicate with the caller, switch to\nENOENT, so EFAULT can be used as a non internal retval.",
      "shmem_replace_page() has been wrong since the day I wrote it: good enough to work on swap \"type\" 0, which is all most people ever use (especially those few who need shmem_replace_page() at all), but broken once there are any non-0 swp_type bits set in the higher order bits"
    ],
    "vulnerabilities": [
      "userfaultfd implementation in the Linux kernel did not properly restrict access to certain ioctls",
       "A use-after-free flaw can occur in the Linux kernel due to a race condition between packet_do_bind() and packet_notifier() functions called for an AF_PACKET socket. An unprivileged, local user could use this flaw to induce kernel memory corruption on the system, leading to an unresponsive system or to a crash. Due to the nature of the flaw, privilege escalation cannot be fully ruled out.",
        "With MAP_SHARED: recheck the i_size after taking the PT lock, to\nserialize against truncate with the PT lock.  Delete the page from the\npagecache if the i_size_read check fails.\nWith MAP_PRIVATE: check the i_size after the PT lock before mapping\nanonymous memory or zeropages into the MAP_PRIVATE shmem mapping.",
         "Set the page dirty if VM_WRITE is not set because in such case the pte\nwon't be marked dirty and the page would be reclaimed without writepage\n(i.e. swapout in the shmem case).",
          "Userfaultfd did not create private memory when UFFDIO_COPY was invoked\non a MAP_PRIVATE shmem mapping. Instead it wrote to the shmem file,\neven when that had not been opened for writing. Though, fortunately,\nthat could only happen where there was a hole in the file."
    ],
    "impact": "A local attacker could use this possibly to modify files. These way when reading the new file created with same inode we may get these trash leftover pages from cleancache and see wrong data instead of the contents of the new file, Set the page dirty if VM_WRITE is not set because in such case the pte won't be marked dirty and the page would be reclaimed without writepage (i.e. swapout in the shmem case). Userfaultfd did not create private memory when UFFDIO_COPY was invoked on a MAP_PRIVATE shmem mapping",
    "attack_vectors": [
      "Local access"
    ],
    "attacker_capabilities": "local unprivileged attacker",
    "references": [
        "http://lkml.kernel.org/r/20181126173452.26955-4-aarcange@redhat.com",
        "http://lkml.kernel.org/r/20181126173452.26955-3-aarcange@redhat.com",
        "http://lkml.kernel.org/r/20181126173452.26955-2-aarcange@redhat.com",
         "http://lkml.kernel.org/r/20181112095734.17979-1-ptikhomirov@virtuozzo.com",
         "http://lkml.kernel.org/r/20181126173452.26955-6-aarcange@redhat.com",
        "http://lkml.kernel.org/r/20181126173452.26955-5-aarcange@redhat.com",
        "http://lkml.kernel.org/r/20181126173452.26955-4-aarcange@redhat.com"

    ]
  }
}
```