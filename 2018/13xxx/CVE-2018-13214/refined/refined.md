```
function sell(uint256 amount) {
    if (balanceOf[msg.sender] < amount ) throw;        // checks if the sender has enough to sell
    balanceOf[this] += amount;                         // adds the amount to owners balance
    balanceOf[msg.sender] -= amount;                   // subtracts the amount from sellers balance
    if (!msg.sender.send(amount * sellPrice)) {        // sends ether to the seller. Its important
      throw;                                         // to do this last to avoid recursion attacks
    } else {
      Transfer(msg.sender, this, amount);            // executes an event reflecting on the change
    }
  }
```

**Root cause of vulnerability:** Integer overflow in the `sell` function.

**Weaknesses/vulnerabilities present:**
- Integer overflow vulnerability: The multiplication of `amount * sellPrice` can result in an integer overflow, causing the amount of ETH sent to the seller to be less than expected (or zero) without triggering an error.

**Impact of exploitation:**
- Loss of funds for the seller: When an integer overflow occurs, the seller will lose their tokens and receive little or no ETH in return.
- Unsafe tokens: The contract is deemed unsafe as the owner can manipulate the `sellPrice` to trigger the overflow and effectively steal the tokens.

**Attack vectors:**
- Setting a high `sellPrice`: The contract owner can manipulate the `sellPrice` to a large value, such that when multiplied by a typical `amount` it overflows.
- Triggering the overflow: A user can call the `sell` function with an amount which when multiplied by the malicious sell price, overflows.

**Required attacker capabilities/position:**
- The attacker needs to be the owner of the contract or be able to influence the contract owner to set a large `sellPrice`.
- Any user can exploit the overflow vulnerability by calling the `sell()` function with a suitable `amount` parameter.