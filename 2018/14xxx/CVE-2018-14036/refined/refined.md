Based on the provided information, here's a breakdown of the CVE-2018-14036 vulnerability:

*   **Vulnerability:** Insufficient path check in `user_change_icon_file_authorized_cb()` function within accountsservice.

*   **Root Cause:** The `user_change_icon_file_authorized_cb()` function attempts to safely set the user icon file property. It's designed to either use the provided path directly (if it points to a world-readable file in `/usr/share`) or copy the file to `/var/lib/AccountsService/icons`. However, the prefix check to determine if the file is within `/usr/share` is insufficient.

*   **Weakness:** The prefix check in the following `if` clause can be bypassed using relative path components like `../`:

    ```c
    if ((mode & S_IROTH) == 0 ||
        (!g_str_has_prefix (filename, DATADIR) &&
         !g_str_has_prefix (filename, ICONDIR))) {
    ```

*   **Attack Vector:** A local attacker (regular user) can exploit this by using the `dbus-send` command to set the icon file to a path containing `../` components.

    Example:

    ```bash
    $ touch /tmp/test
    $ dbus-send --system --print-reply --dest=org.freedesktop.Accounts \
    	/org/freedesktop.Accounts/User1000 \
    	org.freedesktop.Accounts.User.SetIconFile \
    	string:/usr/share/../../tmp/test
    $ rm /tmp/test
    $ ln -s /root/.bash_history /tmp/test
    ```

*   **Impact:** By exploiting this vulnerability, an attacker can cause the accountsservice to store a user-controlled path.  A third-party application that trusts the icon file path obtained from accountsservice could then be tricked into accessing a sensitive file (e.g., `/root/.bash_history`) when it attempts to interpret the icon file.  While the Cinnamon desktop environment attempts to read the icon file as an image, preventing simple file copying, other clients might have more severe consequences.

*   **Attacker Capabilities:**  A regular user with the ability to use `dbus-send` to change their own account data. The Polkit rule for `org.freedesktop.accounts.change-own-user-data` allows this by default.

*   **Fix:**  The suggested fix, which was implemented, is to normalize the user-supplied filename using `realpath()` before performing the prefix check.

    ```c
    filename = g_file_get_path (file);
    ```

    This canonicalizes the input path, preventing the bypass using relative path components.