=== Content from lists.apache.org_bb2dfc22_20250125_194748.html ===


[![Foal logo](images/logo.png)](./)

* ![Display Settings](images/cog.png "Display Settings")
  **Email display mode:**

  ---

   Modern rendering

   Legacy rendering
* ![Logged out](images/user_loggedout.png "Not logged in")

This site requires JavaScript enabled. Please enable it.



=== Content from spark.apache.org_36467fe5_20250125_194748.html ===

[![](/images/spark-logo-rev.svg)](/)

* [Download](/downloads.html)
* Libraries
  + [SQL and DataFrames](/sql/)
  + [Spark Connect](/spark-connect/)
  + [Spark Streaming](/streaming/)
  + [pandas on Spark](/pandas-on-spark/)
  + [MLlib (machine learning)](/mllib/)
  + [GraphX (graph)](/graphx/)
  + ---
  + [Third-Party Projects](/third-party-projects.html)
* Documentation
  + [Latest Release](/docs/latest/)
  + [Older Versions and Other Resources](/documentation.html)
  + [Frequently Asked Questions](/faq.html)
* [Examples](/examples.html)
* Community
  + [Mailing Lists & Resources](/community.html)
  + [Contributing to Spark](/contributing.html)
  + [Improvement Proposals (SPIP)](/improvement-proposals.html)
  + [Issue Tracker](https://issues.apache.org/jira/browse/SPARK)
  + [Powered By](/powered-by.html)
  + [Project Committers](/committers.html)
  + [Project History](/history.html)
* Developers
  + [Useful Developer Tools](/developer-tools.html)
  + [Versioning Policy](/versioning-policy.html)
  + [Release Process](/release-process.html)
  + [Security](/security.html)
* GitHub
  + [spark](https://github.com/apache/spark)
  + [spark-connect-go](https://github.com/apache/spark-connect-go)
  + [spark-docker](https://github.com/apache/spark-docker)
  + [spark-kubernetes-operator](https://github.com/apache/spark-kubernetes-operator)
  + [spark-website](https://github.com/apache/spark-website)

* Apache Software Foundation
  + [Apache Homepage](https://www.apache.org/)
  + [License](https://www.apache.org/licenses/)
  + [Sponsorship](https://www.apache.org/foundation/sponsorship.html)
  + [Thanks](https://www.apache.org/foundation/thanks.html)
  + [Security](https://www.apache.org/security/)
  + [Event](https://www.apache.org/events/current-event)

## Reporting security issues

Apache Spark uses the standard process outlined by the [Apache Security Team](https://www.apache.org/security/)
for reporting vulnerabilities. Note that vulnerabilities should not be publicly disclosed until the project has
responded.

To report a possible security vulnerability, please email `security@spark.apache.org`. This is a
non-public list that will reach the Apache Security team, as well as the Spark PMC.

## Known security issues

### CVE-2023-32007: Apache Spark shell command injection vulnerability via Spark UI

This CVE is only an update to [CVE-2022-33891](#CVE-2022-33891) to clarify that version 3.1.3 is also
affected. It is otherwise not a new vulnerability. Note that Apache Spark 3.1.x is EOL now.

### CVE-2023-22946: Apache Spark proxy-user privilege escalation from malicious configuration class

Severity: Medium

Vendor: The Apache Software Foundation

Versions Affected:

* Versions prior to 3.4.0

Description:

In Apache Spark versions prior to 3.4.0, applications using spark-submit can specify a ‘proxy-user’ to run as,
limiting privileges. The application can execute code with the privileges of the submitting user, however, by
providing malicious configuration-related classes on the classpath. This affects architectures relying on
proxy-user, for example those using Apache Livy to manage submitted applications.

This issue is being tracked as SPARK-41958

Mitigation:

* Update to Apache Spark 3.4.0 or later, and ensure that `spark.submit.proxyUser.allowCustomClasspathInClusterMode` is set to its default of “false”, and is not overridden by submitted applications.

Credit:

* Hideyuki Furue (finder)
* Yi Wu (Databricks) (remediation developer)

### CVE-2022-31777: Apache Spark XSS vulnerability in log viewer UI Javascript

Severity: Medium

Vendor: The Apache Software Foundation

Versions Affected:

* 3.2.1 and earlier
* 3.3.0

Description:

A stored cross-site scripting (XSS) vulnerability in Apache Spark 3.2.1 and earlier, and 3.3.0, allows remote
attackers to execute arbitrary JavaScript in the web browser of a user, by including a malicious payload into
the logs which would be returned in logs rendered in the UI.

Mitigation:

* Upgrade to Spark 3.2.2, or 3.3.1 or later

Credit:

* Florian Walter (Veracode)

### CVE-2022-33891: Apache Spark shell command injection vulnerability via Spark UI

Severity: Important

Vendor: The Apache Software Foundation

Versions Affected:

* 3.1.3 and earlier (previously, this was marked as fixed in 3.1.3; this change is tracked as [CVE-2023-32007](#CVE-2023-32007))
* 3.2.0 to 3.2.1

Description:

The Apache Spark UI offers the possibility to enable ACLs via the configuration option spark.acls.enable.
With an authentication filter, this checks whether a user has access permissions to view or modify the application.
If ACLs are enabled, a code path in HttpSecurityFilter can allow someone to perform impersonation by providing an
arbitrary user name. A malicious user might then be able to reach a permission check function that will ultimately
build a Unix shell command based on their input, and execute it. This will result in arbitrary shell command
execution as the user Spark is currently running as.

Mitigation

* Update to Spark 3.2.2, or 3.3.0 or later

Credit:

* Kostya Torchinsky (Databricks)

### CVE-2021-38296: Apache Spark™ Key Negotiation Vulnerability

Severity: Medium

Vendor: The Apache Software Foundation

Versions Affected:

* Apache Spark 3.1.2 and earlier

Description:

Apache Spark supports end-to-end encryption of RPC connections via `spark.authenticate` and `spark.network.crypto.enabled`.
In versions 3.1.2 and earlier, it uses a bespoke mutual authentication protocol that allows for full encryption key
recovery. After an initial interactive attack, this would allow someone to decrypt plaintext traffic offline.
Note that this does not affect security mechanisms controlled by `spark.authenticate.enableSaslEncryption`,
`spark.io.encryption.enabled`, `spark.ssl`, `spark.ui.strictTransportSecurity`.

Mitigation:

* Update to Spark 3.1.3 or later

Credit:

* Steve Weis (Databricks)

### CVE-2020-9480: Apache Spark™ RCE vulnerability in auth-enabled standalone master

Severity: Important

Vendor: The Apache Software Foundation

Versions Affected:

* Apache Spark 2.4.5 and earlier

Description:

In Apache Spark 2.4.5 and earlier, a standalone resource manager’s master may
be configured to require authentication (`spark.authenticate`) via a
shared secret. When enabled, however, a specially-crafted RPC to the
master can succeed in starting an application’s resources on the Spark
cluster, even without the shared key. This can be leveraged to execute
shell commands on the host machine.

This does not affect Spark clusters using other resource managers
(YARN, Mesos, etc).

Mitigation:

* Users should update to Spark 2.4.6 or 3.0.0.
* Where possible, network access to the cluster machines should be restricted to trusted hosts only.

Credit:

* Ayoub Elaassal

### CVE-2019-10099: Apache Spark™ unencrypted data on local disk

Severity: Important

Vendor: The Apache Software Foundation

Versions affected:

* All Spark 1.x, Spark 2.0.x, Spark 2.1.x, and 2.2.x versions
* Spark 2.3.0 to 2.3.2

Description:

Prior to Spark 2.3.3, in certain situations Spark would write user data to local disk unencrypted, even if `spark.io.encryption.enabled=true`. This includes cached blocks that are fetched to disk (controlled by `spark.maxRemoteBlockSizeFetchToMem`); in SparkR, using parallelize; in Pyspark, using broadcast and parallelize; and use of python udfs.

Mitigation:

* 1.x, 2.0.x, 2.1.x, 2.2.x, 2.3.x users should upgrade to 2.3.3 or newer, including 2.4.x

Credit:

* This issue was reported by Thomas Graves of NVIDIA.

### CVE-2018-11760: Apache Spark™ local privilege escalation vulnerability

Severity: Important

Vendor: The Apache Software Foundation

Versions affected:

* All Spark 1.x, Spark 2.0.x, and Spark 2.1.x versions
* Spark 2.2.0 to 2.2.2
* Spark 2.3.0 to 2.3.1

Description:

When using PySpark, it’s possible for a different local user
to connect to the Spark application and impersonate the user running
the Spark application. This affects versions 1.x, 2.0.x, 2.1.x, 2.2.0 to 2.2.2, and 2.3.0 to 2.3.1.

Mitigation:

* 1.x, 2.0.x, 2.1.x, and 2.2.x users should upgrade to 2.2.3 or newer
* 2.3.x users should upgrade to 2.3.2 or newer
* Otherwise, affected users should avoid using PySpark in
  multi-user environments.

Credit:

* Luca Canali and Jose Carlos Luna Duran, CERN

### CVE-2018-17190: Unsecured Apache Spark™ standalone executes user code

Severity: Low

Vendor: The Apache Software Foundation

Versions Affected:

* All versions of Apache Spark

Description:

Spark’s standalone resource manager accepts code to execute on a ‘master’ host, that then runs that code on
‘worker’ hosts. The master itself does not, by design, execute user code. A specially-crafted request to the
master can, however, cause the master to execute code too. Note that this does not affect standalone clusters
with authentication enabled. While the master host typically has less outbound access to other resources
than a worker, the execution of code on the master is nevertheless unexpected.

Mitigation:

Enable authentication on any Spark standalone cluster that is not otherwise secured
from unwanted access, for example by network-level restrictions. Use `spark.authenticate`
and related security properties described at <https://spark.apache.org/docs/latest/security.html>

Credit:

* Andre Protas, Apple Information Security

### CVE-2018-11804: Apache Spark™ build/mvn runs zinc, and can expose information from build machines

Severity: Low

Vendor: The Apache Software Foundation

Versions Affected

* 2.1.x release branch and earlier
* 2.2.x release branch before Spark 2.2.3
* 2.3.x release branch before Spark 2.3.3

Description:

Spark’s Apache Maven-based build includes a convenience script, ‘build/mvn’,
that downloads and runs a zinc server to speed up compilation. This server
will accept connections from external hosts by default. A specially-crafted
request to the zinc server could cause it to reveal information in files
readable to the developer account running the build. Note that this issue
does not affect end users of Spark, only developers building Spark from
source code.

Mitigation:

* Spark users are not affected, as zinc is only a part of the build process.
* Spark developers may simply use a local Maven installation’s ‘mvn’ command to build, and avoid running build/mvn and zinc.
* Spark developers building actively-developed branches (2.2.x, 2.3.x, 2.4.x, master) may update their branches to receive mitigations already patched onto the build/mvn script
* Spark developers running zinc separately may include “-server 127.0.0.1” in its command line, and consider additional flags like “-idle-timeout 30m” to achieve similar mitigation.

Credit:

* Andre Protas, Apple Information Security

### CVE-2018-11770: Apache Spark™ standalone master, Mesos REST APIs not controlled by authentication

Severity: Medium

Vendor: The Apache Software Foundation

Versions Affected:

* Spark versions from 1.3.0, running standalone master with REST API enabled, or running Mesos master with cluster mode enabled; suggested mitigations resolved the issue as of Spark 2.4.0.

Description:

From version 1.3.0 onward, Spark’s standalone master exposes a REST API for job submission, in addition
to the submission mechanism used by `spark-submit`. In standalone, the config property
`spark.authenticate.secret` establishes a shared secret for authenticating requests to submit jobs via
`spark-submit`. However, the REST API does not use this or any other authentication mechanism, and this is
not adequately documented. In this case, a user would be able to run a driver program without authenticating,
but not launch executors, using the REST API. This REST API is also used by Mesos, when set up to run in
cluster mode (i.e., when also running `MesosClusterDispatcher`), for job submission. Future versions of Spark
will improve documentation on these points, and prohibit setting `spark.authenticate.secret` when running
the REST APIs, to make this clear. Future versions will also disable the REST API by default in the
standalone master by changing the default value of `spark.master.rest.enabled` to `false`.

Mitigation:

For standalone masters, disable the REST API by setting `spark.master.rest.enabled` to `false` if it is unused,
and/or ensure that all network access to the REST API (port 6066 by default) is restricted to hosts that are
trusted to submit jobs. Mesos users can stop the `MesosClusterDispatcher`, though that will prevent them
from running jobs in cluster mode. Alternatively, they can ensure access to the `MesosRestSubmissionServer`
(port 7077 by default) is restricted to trusted hosts.

Credit:

* Imran Rashid, Cloudera
* Fengwei Zhang, Alibaba Cloud Security Team

### CVE-2018-8024: Apache Spark™ XSS vulnerability in UI

Severity: Medium

Versions Affected:

* Spark 2.1.0 through 2.1.2
* Spark 2.2.0 through 2.2.1
* Spark 2.3.0

Description:

In Apache Spark 2.1.0 to 2.1.2, 2.2.0 to 2.2.1, and 2.3.0, it’s possible for a malicious
user to construct a URL pointing to a Spark cluster’s UI’s job and stage info pages, and if a user can
be tricked into accessing the URL, can be used to cause script to execute and expose information from
the user’s view of the Spark UI. While some browsers like recent versions of Chrome and Safari are
able to block this type of attack, current versions of Firefox (and possibly others) do not.

Mitigation:

* 2.1.x users should upgrade to 2.1.3 or newer
* 2.2.x users should upgrade to 2.2.2 or newer
* 2.3.x users should upgrade to 2.3.1 or newer

Credit:

* Spencer Gietzen, Rhino Security Labs

### CVE-2018-1334: Apache Spark™ local privilege escalation vulnerability

Severity: High

Vendor: The Apache Software Foundation

Versions affected:

* Spark versions through 2.1.2
* Spark 2.2.0 to 2.2.1
* Spark 2.3.0

Description:

In Apache Spark up to and including 2.1.2, 2.2.0 to 2.2.1, and 2.3.0, when using PySpark or SparkR,
it’s possible for a different local user to connect to the Spark application and impersonate the
user running the Spark application.

Mitigation:

* 1.x, 2.0.x, and 2.1.x users should upgrade to 2.1.3 or newer
* 2.2.x users should upgrade to 2.2.2 or newer
* 2.3.x users should upgrade to 2.3.1 or newer
* Otherwise, affected users should avoid using PySpark and SparkR in multi-user environments.

Credit:

* NehmÃ© TohmÃ©, Cloudera, Inc.

### CVE-2017-12612 Unsafe deserialization in Apache Spark™ launcher API

JIRA: [SPARK-20922](https://issues.apache.org/jira/browse/SPARK-20922)

Severity: Medium

Vendor: The Apache Software Foundation

Versions Affected:

* Versions of Apache Spark from 1.6.0 until 2.1.1

Description:

In Apache Spark 1.6.0 until 2.1.1, the launcher API performs unsafe
deserialization of data received by its socket. This makes applications
launched programmatically using the launcher API potentially
vulnerable to arbitrary code execution by an attacker with access to any user
account on the local machine. It does not affect apps run by spark-submit or
spark-shell. The attacker would be able to execute code as the user that ran
the Spark application. Users are encouraged to update to version 2.1.2, 2.2.0 or
later.

Mitigation:

Update to Apache Spark 2.1.2, 2.2.0 or later.

Credit:

* Aditya Sharad, Semmle

### CVE-2017-7678 Apache Spark™ XSS web UI MHTML vulnerability

JIRA: [SPARK-20393](https://issues.apache.org/jira/browse/SPARK-20393)

Severity: Medium

Vendor: The Apache Software Foundation

Versions Affected:

* Versions of Apache Spark before 2.1.2, 2.2.0

Description:

It is possible for an attacker to take advantage of a user’s trust in the server to trick them into
visiting a link that points to a shared Spark cluster and submits data including MHTML to the Spark
master, or history server. This data, which could contain a script, would then be reflected back to
the user and could be evaluated and executed by MS Windows-based clients. It is not an attack on Spark
itself, but on the user, who may then execute the script inadvertently when viewing elements of the
Spark web UIs.

Mitigation:

Update to Apache Spark 2.1.2, 2.2.0 or later.

Example:

Request:

```
GET /app/?appId=Content-Type:%20multipart/related;%20boundary=_AppScan%0d%0a--
_AppScan%0d%0aContent-Location:foo%0d%0aContent-Transfer-
Encoding:base64%0d%0a%0d%0aPGh0bWw%2bPHNjcmlwdD5hbGVydCgiWFNTIik8L3NjcmlwdD48L2h0bWw%2b%0d%0a
HTTP/1.1

```

Excerpt from response:

```
<div class="row-fluid">No running application with ID Content-Type: multipart/related;
boundary=_AppScan
--_AppScan
Content-Location:foo
Content-Transfer-Encoding:base64
PGh0bWw+PHNjcmlwdD5hbGVydCgiWFNTIik8L3NjcmlwdD48L2h0bWw+
</div>

```

Result: In the above payload the BASE64 data decodes as:

```
<html><script>alert("XSS")</script></html>

```

Credit:

* Mike Kasper, Nicholas Marion
* IBM z Systems Center for Secure Engineering

##### Latest News

* [Spark 3.5.4 released](/news/spark-3-5-4-released.html)
  (Dec 20, 2024)
* [Spark 3.4.4 released](/news/spark-3-4-4-released.html)
  (Oct 27, 2024)
* [Preview release of Spark 4.0](/news/spark-4.0.0-preview2.html)
  (Sep 26, 2024)
* [Spark 3.5.3 released](/news/spark-3-5-3-released.html)
  (Sep 24, 2024)

[Archive](/news/index.html)

[![](https://www.apache.org/events/current-event-234x60.png)](https://www.apache.org/events/current-event.html)

[Download Spark](/downloads.html)

Built-in Libraries:

* [SQL and DataFrames](/sql/)
* [Spark Streaming](/streaming/)
* [MLlib (machine learning)](/mllib/)
* [GraphX (graph)](/graphx/)

[Third-Party Projects](/third-party-projects.html)

---

Apache Spark, Spark, Apache, the Apache feather logo, and the Apache Spark project logo are either registered
trademarks or trademarks of The Apache Software Foundation in the United States and other countries.
See guidance on use of Apache Spark [trademarks](/trademarks.html).
All other marks mentioned may be trademarks or registered trademarks of their respective owners.
Copyright © 2018 The Apache Software Foundation, Licensed under the
[Apache License, Version 2.0](https://www.apache.org/licenses/).



=== Content from spark.apache.org_c290f935_20250126_112919.html ===


[![](img/spark-logo-rev.svg)](index.html)3.5.4

* [Overview](index.html)
* Programming Guides
  [Quick Start](quick-start.html)
  [RDDs, Accumulators, Broadcasts Vars](rdd-programming-guide.html)
  [SQL, DataFrames, and Datasets](sql-programming-guide.html)
  [Structured Streaming](structured-streaming-programming-guide.html)
  [Spark Streaming (DStreams)](streaming-programming-guide.html)
  [MLlib (Machine Learning)](ml-guide.html)
  [GraphX (Graph Processing)](graphx-programming-guide.html)
  [SparkR (R on Spark)](sparkr.html)
  [PySpark (Python on Spark)](api/python/getting_started/index.html)
* API Docs
  [Scala](api/scala/org/apache/spark/index.html)
  [Java](api/java/index.html)
  [Python](api/python/index.html)
  [R](api/R/index.html)
  [SQL, Built-in Functions](api/sql/index.html)
* Deploying
  [Overview](cluster-overview.html)
  [Submitting Applications](submitting-applications.html)

  [Spark Standalone](spark-standalone.html)
  [Mesos](running-on-mesos.html)
  [YARN](running-on-yarn.html)
  [Kubernetes](running-on-kubernetes.html)
* More
  [Configuration](configuration.html)
  [Monitoring](monitoring.html)
  [Tuning Guide](tuning.html)
  [Job Scheduling](job-scheduling.html)
  [Security](security.html)
  [Hardware Provisioning](hardware-provisioning.html)
  [Migration Guide](migration-guide.html)

  [Building Spark](building-spark.html)
  [Contributing to Spark](https://spark.apache.org/contributing.html)
  [Third Party Projects](https://spark.apache.org/third-party-projects.html)

# Spark Security

* [Spark Security: Things You Need To Know](#spark-security-things-you-need-to-know)
* [Spark RPC (Communication protocol between Spark processes)](#spark-rpc-communication-protocol-between-spark-processes)
  + [Authentication](#authentication)
    - [YARN](#yarn)
    - [Kubernetes](#kubernetes)
  + [Encryption](#encryption)
* [Local Storage Encryption](#local-storage-encryption)
* [Web UI](#web-ui)
  + [Authentication and Authorization](#authentication-and-authorization)
  + [Spark History Server ACLs](#spark-history-server-acls)
  + [SSL Configuration](#ssl-configuration)
  + [Preparing the key stores](#preparing-the-key-stores)
    - [YARN mode](#yarn-mode)
    - [Standalone mode](#standalone-mode)
    - [Mesos mode](#mesos-mode)
  + [HTTP Security Headers](#http-security-headers)
* [Configuring Ports for Network Security](#configuring-ports-for-network-security)
  + [Standalone mode only](#standalone-mode-only)
  + [All cluster managers](#all-cluster-managers)
* [Kerberos](#kerberos)
  + [Long-Running Applications](#long-running-applications)
    - [Using a Keytab](#using-a-keytab)
    - [Using a ticket cache](#using-a-ticket-cache)
  + [Secure Interaction with Kubernetes](#secure-interaction-with-kubernetes)
* [Event Logging](#event-logging)
* [Persisting driver logs in client mode](#persisting-driver-logs-in-client-mode)

# Spark Security: Things You Need To Know

Security features like authentication are not enabled by default. When deploying a cluster that is open to the internet
or an untrusted network, it’s important to secure access to the cluster to prevent unauthorized applications
from running on the cluster.

Spark supports multiple deployments types and each one supports different levels of security. Not
all deployment types will be secure in all environments and none are secure by default. Be
sure to evaluate your environment, what Spark supports, and take the appropriate measure to secure
your Spark deployment.

There are many different types of security concerns. Spark does not necessarily protect against
all things. Listed below are some of the things Spark supports. Also check the deployment
documentation for the type of deployment you are using for deployment specific settings. Anything
not documented, Spark does not support.

# Spark RPC (Communication protocol between Spark processes)

## Authentication

Spark currently supports authentication for RPC channels using a shared secret. Authentication can
be turned on by setting the `spark.authenticate` configuration parameter.

The exact mechanism used to generate and distribute the shared secret is deployment-specific. Unless
specified below, the secret must be defined by setting the `spark.authenticate.secret` config
option. The same secret is shared by all Spark applications and daemons in that case, which limits
the security of these deployments, especially on multi-tenant clusters.

The REST Submission Server and the MesosClusterDispatcher do not support authentication. You should
ensure that all network access to the REST API & MesosClusterDispatcher (port 6066 and 7077
respectively by default) are restricted to hosts that are trusted to submit jobs.

### YARN

For Spark on [YARN](running-on-yarn.html), Spark will automatically handle generating and
distributing the shared secret. Each application will use a unique shared secret. In
the case of YARN, this feature relies on YARN RPC encryption being enabled for the distribution of
secrets to be secure.

| Property Name | Default | Meaning | Since Version |
| --- | --- | --- | --- |
| `spark.yarn.shuffle.server.recovery.disabled` | false | Set to true for applications that have higher security requirements and prefer that their secret is not saved in the db. The shuffle data of such applications wll not be recovered after the External Shuffle Service restarts. | 3.5.0 |

### Kubernetes

On Kubernetes, Spark will also automatically generate an authentication secret unique to each
application. The secret is propagated to executor pods using environment variables. This means
that any user that can list pods in the namespace where the Spark application is running can
also see their authentication secret. Access control rules should be properly set up by the
Kubernetes admin to ensure that Spark authentication is secure.

| Property Name | Default | Meaning | Since Version |
| --- | --- | --- | --- |
| `spark.authenticate` | false | Whether Spark authenticates its internal connections. | 1.0.0 |
| `spark.authenticate.secret` | None | The secret key used authentication. See above for when this configuration should be set. | 1.0.0 |

Alternatively, one can mount authentication secrets using files and Kubernetes secrets that
the user mounts into their pods.

| Property Name | Default | Meaning | Since Version |
| --- | --- | --- | --- |
| `spark.authenticate.secret.file` | None | Path pointing to the secret key to use for securing connections. Ensure that the contents of the file have been securely generated. This file is loaded on both the driver and the executors unless other settings override this (see below). | 3.0.0 |
| `spark.authenticate.secret.driver.file` | The value of `spark.authenticate.secret.file` | When specified, overrides the location that the Spark driver reads to load the secret. Useful when in client mode, when the location of the secret file may differ in the pod versus the node the driver is running in. When this is specified, `spark.authenticate.secret.executor.file` must be specified so that the driver and the executors can both use files to load the secret key. Ensure that the contents of the file on the driver is identical to the contents of the file on the executors. | 3.0.0 |
| `spark.authenticate.secret.executor.file` | The value of `spark.authenticate.secret.file` | When specified, overrides the location that the Spark executors read to load the secret. Useful in client mode, when the location of the secret file may differ in the pod versus the node the driver is running in. When this is specified, `spark.authenticate.secret.driver.file` must be specified so that the driver and the executors can both use files to load the secret key. Ensure that the contents of the file on the driver is identical to the contents of the file on the executors. | 3.0.0 |

Note that when using files, Spark will not mount these files into the containers for you. It is up
you to ensure that the secret files are deployed securely into your containers and that the driver’s
secret file agrees with the executors’ secret file.

## Encryption

Spark supports AES-based encryption for RPC connections. For encryption to be enabled, RPC
authentication must also be enabled and properly configured. AES encryption uses the
[Apache Commons Crypto](https://commons.apache.org/proper/commons-crypto/) library, and Spark’s
configuration system allows access to that library’s configuration for advanced users.

This protocol has two mutually incompatible versions. Version 1 omits applying key derivation function
(KDF) to the key exchange protocol’s output, while version 2 applies a KDF to ensure that the derived
session key is uniformly distributed. Version 1 is default for backward compatibility. It is
**recommended to use version 2** for better security properties. The version can be configured by setting
`spark.network.crypto.authEngineVersion` to 1 or 2 respectively.

There is also support for SASL-based encryption, although it should be considered deprecated. It
is still required when talking to shuffle services from Spark versions older than 2.2.0.

The following table describes the different options available for configuring this feature.

| Property Name | Default | Meaning | Since Version |
| --- | --- | --- | --- |
| `spark.network.crypto.enabled` | false | Enable AES-based RPC encryption, including the new authentication protocol added in 2.2.0. | 2.2.0 |
| `spark.network.crypto.cipher` | AES/CTR/NoPadding | Cipher mode to use. Defaults "AES/CTR/NoPadding" for backward compatibility, which is not authenticated. Recommended to use "AES/GCM/NoPadding", which is an authenticated encryption mode. | 4.0.0, 3.5.2, 3.4.4 |
| `spark.network.crypto.authEngineVersion` | 1 | Version of AES-based RPC encryption to use. Valid versions are 1 or 2. Version 2 is recommended. | 3.4.3, 3.5.2 |
| `spark.network.crypto.config.*` | None | Configuration values for the commons-crypto library, such as which cipher implementations to use. The config name should be the name of commons-crypto configuration without the `commons.crypto` prefix. | 2.2.0 |
| `spark.network.crypto.saslFallback` | true | Whether to fall back to SASL authentication if authentication fails using Spark's internal mechanism. This is useful when the application is connecting to old shuffle services that do not support the internal Spark authentication protocol. On the shuffle service side, disabling this feature will block older clients from authenticating. | 2.2.0 |
| `spark.authenticate.enableSaslEncryption` | false | Enable SASL-based encrypted communication. | 2.2.0 |
| `spark.network.sasl.serverAlwaysEncrypt` | false | Disable unencrypted connections for ports using SASL authentication. This will deny connections from clients that have authentication enabled, but do not request SASL-based encryption. | 1.4.0 |

# Local Storage Encryption

Spark supports encrypting temporary data written to local disks. This covers shuffle files, shuffle
spills and data blocks stored on disk (for both caching and broadcast variables). It does not cover
encrypting output data generated by applications with APIs such as `saveAsHadoopFile` or
`saveAsTable`. It also may not cover temporary files created explicitly by the user.

The following settings cover enabling encryption for data written to disk:

| Property Name | Default | Meaning | Since Version |
| --- | --- | --- | --- |
| `spark.io.encryption.enabled` | false | Enable local disk I/O encryption. Currently supported by all modes except Mesos. It's strongly recommended that RPC encryption be enabled when using this feature. | 2.1.0 |
| `spark.io.encryption.keySizeBits` | 128 | IO encryption key size in bits. Supported values are 128, 192 and 256. | 2.1.0 |
| `spark.io.encryption.keygen.algorithm` | HmacSHA1 | The algorithm to use when generating the IO encryption key. The supported algorithms are described in the KeyGenerator section of the Java Cryptography Architecture Standard Algorithm Name Documentation. | 2.1.0 |
| `spark.io.encryption.commons.config.*` | None | Configuration values for the commons-crypto library, such as which cipher implementations to use. The config name should be the name of commons-crypto configuration without the `commons.crypto` prefix. | 2.1.0 |

# Web UI

## Authentication and Authorization

Enabling authentication for the Web UIs is done using [javax servlet filters](https://docs.oracle.com/javaee/6/api/javax/servlet/Filter.html).
You will need a filter that implements the authentication method you want to deploy. Spark does not
provide any built-in authentication filters.

Spark also supports access control to the UI when an authentication filter is present. Each
application can be configured with its own separate access control lists (ACLs). Spark
differentiates between “view” permissions (who is allowed to see the application’s UI), and “modify”
permissions (who can do things like kill jobs in a running application).

ACLs can be configured for either users or groups. Configuration entries accept comma-separated
lists as input, meaning multiple users or groups can be given the desired privileges. This can be
used if you run on a shared cluster and have a set of administrators or developers who need to
monitor applications they may not have started themselves. A wildcard (`*`) added to specific ACL
means that all users will have the respective privilege. By default, only the user submitting the
application is added to the ACLs.

Group membership is established by using a configurable group mapping provider. The mapper is
configured using the `spark.user.groups.mapping` config option, described in the table
below.

The following options control the authentication of Web UIs:

| Property Name | Default | Meaning | Since Version |
| --- | --- | --- | --- |
| `spark.ui.allowFramingFrom` | `SAMEORIGIN` | Allow framing for a specific named URI via `X-Frame-Options`. By default, allow only from the same origin. | 1.6.0 |
| `spark.ui.filters` | None | See the [Spark UI](configuration.html#spark-ui) configuration for how to configure filters. | 1.0.0 |
| `spark.acls.enable` | false | Whether UI ACLs should be enabled. If enabled, this checks to see if the user has access permissions to view or modify the application. Note this requires the user to be authenticated, so if no authentication filter is installed, this option does not do anything. | 1.1.0 |
| `spark.admin.acls` | None | Comma-separated list of users that have view and modify access to the Spark application. | 1.1.0 |
| `spark.admin.acls.groups` | None | Comma-separated list of groups that have view and modify access to the Spark application. | 2.0.0 |
| `spark.modify.acls` | None | Comma-separated list of users that have modify access to the Spark application. | 1.1.0 |
| `spark.modify.acls.groups` | None | Comma-separated list of groups that have modify access to the Spark application. | 2.0.0 |
| `spark.ui.view.acls` | None | Comma-separated list of users that have view access to the Spark application. | 1.0.0 |
| `spark.ui.view.acls.groups` | None | Comma-separated list of groups that have view access to the Spark application. | 2.0.0 |
| `spark.user.groups.mapping` | `org.apache.spark.security.ShellBasedGroupsMappingProvider` | The list of groups for a user is determined by a group mapping service defined by the trait `org.apache.spark.security.GroupMappingServiceProvider`, which can be configured by this property. By default, a Unix shell-based implementation is used, which collects this information from the host OS. *Note:* This implementation supports only Unix/Linux-based environments. Windows environment is currently **not** supported. However, a new platform/protocol can be supported by implementing the trait mentioned above. | 2.0.0 |

On YARN, the view and modify ACLs are provided to the YARN service when submitting applications, and
control who has the respective privileges via YARN interfaces.

## Spark History Server ACLs

Authentication for the SHS Web UI is enabled the same way as for regular applications, using
servlet filters.

To enable authorization in the SHS, a few extra options are used:

| Property Name | Default | Meaning | Since Version |
| --- | --- | --- | --- |
| `spark.history.ui.acls.enable` | false | Specifies whether ACLs should be checked to authorize users viewing the applications in the history server. If enabled, access control checks are performed regardless of what the individual applications had set for `spark.ui.acls.enable`. The application owner will always have authorization to view their own application and any users specified via `spark.ui.view.acls` and groups specified via `spark.ui.view.acls.groups` when the application was run will also have authorization to view that application. If disabled, no access control checks are made for any application UIs available through the history server. | 1.0.1 |
| `spark.history.ui.admin.acls` | None | Comma separated list of users that have view access to all the Spark applications in history server. | 2.1.1 |
| `spark.history.ui.admin.acls.groups` | None | Comma separated list of groups that have view access to all the Spark applications in history server. | 2.1.1 |

The SHS uses the same options to configure the group mapping provider as regular applications.
In this case, the group mapping provider will apply to all UIs server by the SHS, and individual
application configurations will be ignored.

## SSL Configuration

Configuration for SSL is organized hierarchically. The user can configure the default SSL settings
which will be used for all the supported communication protocols unless they are overwritten by
protocol-specific settings. This way the user can easily provide the common settings for all the
protocols without disabling the ability to configure each one individually. The following table
describes the SSL configuration namespaces:

| Config Namespace | Component |
| --- | --- |
| `spark.ssl` | The default SSL configuration. These values will apply to all namespaces below, unless explicitly overridden at the namespace level. |
| `spark.ssl.ui` | Spark application Web UI |
| `spark.ssl.standalone` | Standalone Master / Worker Web UI |
| `spark.ssl.historyServer` | History Server Web UI |

The full breakdown of available SSL options can be found below. The `${ns}` placeholder should be
replaced with one of the above namespaces.

| Property Name | Default | Meaning |
| --- | --- | --- |
| `${ns}.enabled` | false | Enables SSL. When enabled, `${ns}.ssl.protocol` is required. |
| `${ns}.port` | None | The port where the SSL service will listen on. The port must be defined within a specific namespace configuration. The default namespace is ignored when reading this configuration. When not set, the SSL port will be derived from the non-SSL port for the same service. A value of "0" will make the service bind to an ephemeral port. |
| `${ns}.enabledAlgorithms` | None | A comma-separated list of ciphers. The specified ciphers must be supported by JVM. The reference list of protocols can be found in the "JSSE Cipher Suite Names" section of the Java security guide. The list for Java 8 can be found at [this](https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#ciphersuites) page. Note: If not set, the default cipher suite for the JRE will be used. |
| `${ns}.keyPassword` | None | The password to the private key in the key store. |
| `${ns}.keyStore` | None | Path to the key store file. The path can be absolute or relative to the directory in which the process is started. |
| `${ns}.keyStorePassword` | None | Password to the key store. |
| `${ns}.keyStoreType` | JKS | The type of the key store. |
| `${ns}.protocol` | None | TLS protocol to use. The protocol must be supported by JVM. The reference list of protocols can be found in the "Additional JSSE Standard Names" section of the Java security guide. For Java 8, the list can be found at [this](https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#jssenames) page. |
| `${ns}.needClientAuth` | false | Whether to require client authentication. |
| `${ns}.trustStore` | None | Path to the trust store file. The path can be absolute or relative to the directory in which the process is started. |
| `${ns}.trustStorePassword` | None | Password for the trust store. |
| `${ns}.trustStoreType` | JKS | The type of the trust store. |

Spark also supports retrieving `${ns}.keyPassword`, `${ns}.keyStorePassword` and `${ns}.trustStorePassword` from
[Hadoop Credential Providers](https://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/CredentialProviderAPI.html).
User could store password into credential file and make it accessible by different components, like:

```
hadoop credential create spark.ssl.keyPassword -value password \
    -provider jceks://hdfs@nn1.example.com:9001/user/backup/ssl.jceks

```

To configure the location of the credential provider, set the `hadoop.security.credential.provider.path`
config option in the Hadoop configuration used by Spark, like:

```
  <property>
    <name>hadoop.security.credential.provider.path</name>
    <value>jceks://hdfs@nn1.example.com:9001/user/backup/ssl.jceks</value>
  </property>

```

Or via SparkConf “spark.hadoop.hadoop.security.credential.provider.path=jceks://hdfs@nn1.example.com:9001/user/backup/ssl.jceks”.

## Preparing the key stores

Key stores can be generated by `keytool` program. The reference documentation for this tool for
Java 8 is [here](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html).
The most basic steps to configure the key stores and the trust store for a Spark Standalone
deployment mode is as follows:

* Generate a key pair for each node
* Export the public key of the key pair to a file on each node
* Import all exported public keys into a single trust store
* Distribute the trust store to the cluster nodes

### YARN mode

To provide a local trust store or key store file to drivers running in cluster mode, they can be
distributed with the application using the `--files` command line argument (or the equivalent
`spark.files` configuration). The files will be placed on the driver’s working directory, so the TLS
configuration should just reference the file name with no absolute path.

Distributing local key stores this way may require the files to be staged in HDFS (or other similar
distributed file system used by the cluster), so it’s recommended that the underlying file system be
configured with security in mind (e.g. by enabling authentication and wire encryption).

### Standalone mode

The user needs to provide key stores and configuration options for master and workers. They have to
be set by attaching appropriate Java system properties in `SPARK_MASTER_OPTS` and in
`SPARK_WORKER_OPTS` environment variables, or just in `SPARK_DAEMON_JAVA_OPTS`.

The user may allow the executors to use the SSL settings inherited from the worker process. That
can be accomplished by setting `spark.ssl.useNodeLocalConf` to `true`. In that case, the settings
provided by the user on the client side are not used.

### Mesos mode

Mesos 1.3.0 and newer supports `Secrets` primitives as both file-based and environment based
secrets. Spark allows the specification of file-based and environment variable based secrets with
`spark.mesos.driver.secret.filenames` and `spark.mesos.driver.secret.envkeys`, respectively.

Depending on the secret store backend secrets can be passed by reference or by value with the
`spark.mesos.driver.secret.names` and `spark.mesos.driver.secret.values` configuration properties,
respectively.

Reference type secrets are served by the secret store and referred to by name, for example
`/mysecret`. Value type secrets are passed on the command line and translated into their
appropriate files or environment variables.

## HTTP Security Headers

Apache Spark can be configured to include HTTP headers to aid in preventing Cross Site Scripting
(XSS), Cross-Frame Scripting (XFS), MIME-Sniffing, and also to enforce HTTP Strict Transport
Security.

| Property Name | Default | Meaning | Since Version |
| --- | --- | --- | --- |
| `spark.ui.xXssProtection` | `1; mode=block` | Value for HTTP X-XSS-Protection response header. You can choose appropriate value from below:  * `0` (Disables XSS filtering) * `1` (Enables XSS filtering. If a cross-site scripting attack is detected,   the browser will sanitize the page.) * `1; mode=block` (Enables XSS filtering. The browser will prevent rendering   of the page if an attack is detected.) | 2.3.0 |
| `spark.ui.xContentTypeOptions.enabled` | `true` | When enabled, X-Content-Type-Options HTTP response header will be set to "nosniff". | 2.3.0 |
| `spark.ui.strictTransportSecurity` | None | Value for HTTP Strict Transport Security (HSTS) Response Header. You can choose appropriate value from below and set `expire-time` accordingly. This option is only used when SSL/TLS is enabled.  * `max-age=<expire-time>` * `max-age=<expire-time>; includeSubDomains` * `max-age=<expire-time>; preload` | 2.3.0 |

# Configuring Ports for Network Security

Generally speaking, a Spark cluster and its services are not deployed on the public internet.
They are generally private services, and should only be accessible within the network of the
organization that deploys Spark. Access to the hosts and ports used by Spark services should
be limited to origin hosts that need to access the services.

Below are the primary ports that Spark uses for its communication and how to
configure those ports.

## Standalone mode only

| From | To | Default Port | Purpose | Configuration Setting | Notes |
| --- | --- | --- | --- | --- | --- |
| Browser | Standalone Master | 8080 | Web UI | `spark.master.ui.port / SPARK_MASTER_WEBUI_PORT` | Jetty-based. Standalone mode only. |
| Browser | Standalone Worker | 8081 | Web UI | `spark.worker.ui.port / SPARK_WORKER_WEBUI_PORT` | Jetty-based. Standalone mode only. |
| Driver / Standalone Worker | Standalone Master | 7077 | Submit job to cluster / Join cluster | `SPARK_MASTER_PORT` | Set to "0" to choose a port randomly. Standalone mode only. |
| External Service | Standalone Master | 6066 | Submit job to cluster via REST API | `spark.master.rest.port` | Use `spark.master.rest.enabled` to enable/disable this service. Standalone mode only. |
| Standalone Master | Standalone Worker | (random) | Schedule executors | `SPARK_WORKER_PORT` | Set to "0" to choose a port randomly. Standalone mode only. |

## All cluster managers

| From | To | Default Port | Purpose | Configuration Setting | Notes |
| --- | --- | --- | --- | --- | --- |
| Browser | Application | 4040 | Web UI | `spark.ui.port` | Jetty-based |
| Browser | History Server | 18080 | Web UI | `spark.history.ui.port` | Jetty-based |
| Executor / Standalone Master | Driver | (random) | Connect to application / Notify executor state changes | `spark.driver.port` | Set to "0" to choose a port randomly. |
| Executor / Driver | Executor / Driver | (random) | Block Manager port | `spark.blockManager.port` | Raw socket via ServerSocketChannel |

# Kerberos

Spark supports submitting applications in environments that use Kerberos for authentication.
In most cases, Spark relies on the credentials of the current logged in user when authenticating
to Kerberos-aware services. Such credentials can be obtained by logging in to the configured KDC
with tools like `kinit`.

When talking to Hadoop-based services, Spark needs to obtain delegation tokens so that non-local
processes can authenticate. Spark ships with support for HDFS and other Hadoop file systems, Hive
and HBase.

When using a Hadoop filesystem (such HDFS or WebHDFS), Spark will acquire the relevant tokens
for the service hosting the user’s home directory.

An HBase token will be obtained if HBase is in the application’s classpath, and the HBase
configuration has Kerberos authentication turned (`hbase.security.authentication=kerberos`).

Similarly, a Hive token will be obtained if Hive is in the classpath, and the configuration includes
URIs for remote metastore services (`hive.metastore.uris` is not empty).

If an application needs to interact with other secure Hadoop filesystems, their URIs need to be
explicitly provided to Spark at launch time. This is done by listing them in the
`spark.kerberos.access.hadoopFileSystems` property, described in the configuration section below.

Spark also supports custom delegation token providers using the Java Services
mechanism (see `java.util.ServiceLoader`). Implementations of
`org.apache.spark.security.HadoopDelegationTokenProvider` can be made available to Spark
by listing their names in the corresponding file in the jar’s `META-INF/services` directory.

Delegation token support is currently only supported in YARN, Kubernetes and Mesos modes. Consult the
deployment-specific page for more information.

The following options provides finer-grained control for this feature:

| Property Name | Default | Meaning | Since Version |
| --- | --- | --- | --- |
| `spark.security.credentials.${service}.enabled` | `true` | Controls whether to obtain credentials for services when security is enabled. By default, credentials for all supported services are retrieved when those services are configured, but it's possible to disable that behavior if it somehow conflicts with the application being run. | 2.3.0 |
| `spark.kerberos.access.hadoopFileSystems` | (none) | A comma-separated list of secure Hadoop filesystems your Spark application is going to access. For example, `spark.kerberos.access.hadoopFileSystems=hdfs://nn1.com:8032,hdfs://nn2.com:8032, webhdfs://nn3.com:50070`. The Spark application must have access to the filesystems listed and Kerberos must be properly configured to be able to access them (either in the same realm or in a trusted realm). Spark acquires security tokens for each of the filesystems so that the Spark application can access those remote Hadoop filesystems. | 3.0.0 |

Users can exclude Kerberos delegation token renewal at resource scheduler. Currently it is only supported
on YARN. The configuration is covered in the [Running Spark on YARN](running-on-yarn.html#yarn-specific-kerberos-configuration) page.

## Long-Running Applications

Long-running applications may run into issues if their run time exceeds the maximum delegation
token lifetime configured in services it needs to access.

This feature is not available everywhere. In particular, it’s only implemented
on YARN and Kubernetes (both client and cluster modes), and on Mesos when using client mode.

Spark supports automatically creating new tokens for these applications. There are two ways to
enable this functionality.

### Using a Keytab

By providing Spark with a principal and keytab (e.g. using `spark-submit` with `--principal`
and `--keytab` parameters), the application will maintain a valid Kerberos login that can be
used to retrieve delegation tokens indefinitely.

Note that when using a keytab in cluster mode, it will be copied over to the machine running the
Spark driver. In the case of YARN, this means using HDFS as a staging area for the keytab, so it’s
strongly recommended that both YARN and HDFS be secured with encryption, at least.

### Using a ticket cache

By setting `spark.kerberos.renewal.credentials` to `ccache` in Spark’s configuration, the local
Kerberos ticket cache will be used for authentication. Spark will keep the ticket renewed during its
renewable life, but after it expires a new ticket needs to be acquired (e.g. by running `kinit`).

It’s up to the user to maintain an updated ticket cache that Spark can use.

The location of the ticket cache can be customized by setting the `KRB5CCNAME` environment
variable.

## Secure Interaction with Kubernetes

When talking to Hadoop-based services behind Kerberos, it was noted that Spark needs to obtain delegation tokens
so that non-local processes can authenticate. These delegation tokens in Kubernetes are stored in Secrets that are
shared by the Driver and its Executors. As such, there are three ways of submitting a Kerberos job:

In all cases you must define the environment variable: `HADOOP_CONF_DIR` or
`spark.kubernetes.hadoop.configMapName.`

It also important to note that the KDC needs to be visible from inside the containers.

If a user wishes to use a remote HADOOP\_CONF directory, that contains the Hadoop configuration files, this could be
achieved by setting `spark.kubernetes.hadoop.configMapName` to a pre-existing ConfigMap.

1. Submitting with a $kinit that stores a TGT in the Local Ticket Cache:
   ```
   /usr/bin/kinit -kt <keytab_file> <username>/<krb5 realm>
   /opt/spark/bin/spark-submit \
    --deploy-mode cluster \
    --class org.apache.spark.examples.HdfsTest \
    --master k8s://<KUBERNETES_MASTER_ENDPOINT> \
    --conf spark.executor.instances=1 \
    --conf spark.app.name=spark-hdfs \
    --conf spark.kubernetes.container.image=spark:latest \
    --conf spark.kubernetes.kerberos.krb5.path=/etc/krb5.conf \
    local:///opt/spark/examples/jars/spark-examples_<VERSION>.jar \
    <HDFS_FILE_LOCATION>

   ```
2. Submitting with a local Keytab and Principal
   ```
   /opt/spark/bin/spark-submit \
    --deploy-mode cluster \
    --class org.apache.spark.examples.HdfsTest \
    --master k8s://<KUBERNETES_MASTER_ENDPOINT> \
    --conf spark.executor.instances=1 \
    --conf spark.app.name=spark-hdfs \
    --conf spark.kubernetes.container.image=spark:latest \
    --conf spark.kerberos.keytab=<KEYTAB_FILE> \
    --conf spark.kerberos.principal=<PRINCIPAL> \
    --conf spark.kubernetes.kerberos.krb5.path=/etc/krb5.conf \
    local:///opt/spark/examples/jars/spark-examples_<VERSION>.jar \
    <HDFS_FILE_LOCATION>

   ```
3. Submitting with pre-populated secrets, that contain the Delegation Token, already existing within the namespace
   ```
   /opt/spark/bin/spark-submit \
    --deploy-mode cluster \
    --class org.apache.spark.examples.HdfsTest \
    --master k8s://<KUBERNETES_MASTER_ENDPOINT> \
    --conf spark.executor.instances=1 \
    --conf spark.app.name=spark-hdfs \
    --conf spark.kubernetes.container.image=spark:latest \
    --conf spark.kubernetes.kerberos.tokenSecret.name=<SECRET_TOKEN_NAME> \
    --conf spark.kubernetes.kerberos.tokenSecret.itemKey=<SECRET_ITEM_KEY> \
    --conf spark.kubernetes.kerberos.krb5.path=/etc/krb5.conf \
    local:///opt/spark/examples/jars/spark-examples_<VERSION>.jar \
    <HDFS_FILE_LOCATION>

   ```

3b. Submitting like in (3) however specifying a pre-created krb5 ConfigMap and pre-created `HADOOP_CONF_DIR` ConfigMap

```
/opt/spark/bin/spark-submit \
    --deploy-mode cluster \
    --class org.apache.spark.examples.HdfsTest \
    --master k8s://<KUBERNETES_MASTER_ENDPOINT> \
    --conf spark.executor.instances=1 \
    --conf spark.app.name=spark-hdfs \
    --conf spark.kubernetes.container.image=spark:latest \
    --conf spark.kubernetes.kerberos.tokenSecret.name=<SECRET_TOKEN_NAME> \
    --conf spark.kubernetes.kerberos.tokenSecret.itemKey=<SECRET_ITEM_KEY> \
    --conf spark.kubernetes.hadoop.configMapName=<HCONF_CONFIG_MAP_NAME> \
    --conf spark.kubernetes.kerberos.krb5.configMapName=<KRB_CONFIG_MAP_NAME> \
    local:///opt/spark/examples/jars/spark-examples_<VERSION>.jar \
    <HDFS_FILE_LOCATION>

```
# Event Logging

If your applications are using event logging, the directory where the event logs go
(`spark.eventLog.dir`) should be manually created with proper permissions. To secure the log files,
the directory permissions should be set to `drwxrwxrwxt`. The owner and group of the directory
should correspond to the super user who is running the Spark History Server.

This will allow all users to write to the directory but will prevent unprivileged users from
reading, removing or renaming a file unless they own it. The event log files will be created by
Spark with permissions such that only the user and group have read and write access.

# Persisting driver logs in client mode

If your applications persist driver logs in client mode by enabling `spark.driver.log.persistToDfs.enabled`,
the directory where the driver logs go (`spark.driver.log.dfsDir`) should be manually created with proper
permissions. To secure the log files, the directory permissions should be set to `drwxrwxrwxt`. The owner
and group of the directory should correspond to the super user who is running the Spark History Server.

This will allow all users to write to the directory but will prevent unprivileged users from
reading, removing or renaming a file unless they own it. The driver log files will be created by
Spark with permissions such that only the user and group have read and write access.


