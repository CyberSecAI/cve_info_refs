=== Content from subversion.apache.org_d30c8f8e_20250125_125542.html ===
 Remotely triggerable DoS vulnerability in svnserve 'get-deleted-rev'.
Summary:
========
Subversion's svnserve server process may exit when a well-formed
read-only request produces a particular answer.
This can lead to disruption for users of the server.
Known vulnerable:
=================
Subversion svnserve servers through 1.9.10 (inclusive).
Subversion svnserve servers 1.10.0 through 1.10.4 (inclusive).
Subversion svnserve servers 1.11.0 through 1.11.1 (inclusive).
Subversion svnserve servers 1.12.0 through 1.12.0 (inclusive).
mod\_dav\_svn (any version) is not affected.
Known fixed:
============
Subversion svnserve servers 1.9.11
Subversion svnserve servers 1.10.5
Subversion svnserve servers 1.12.1
(Subversion 1.11.x is not a supported release line.)
Details:
========
Subversion svn:// connections, including svn+ssh:// and svn+://, use
a custom network protocol [1] with Lisp-like syntax. The code implementing
the protocol has dedicated codepaths for serialization of revision numbers
into protocol integers. A particular client query could cause the server to
attempt to reply with a revision number whose value is the invalid revision
number constant `SVN\_INVALID\_REVNUM`, thereby triggering an assertion failure
in the the serialization layer.
[1] https://svn.apache.org/repos/asf/subversion/tags/1.10.0/subversion/libsvn\_ra\_svn/protocol
Severity:
=========
CVSSv3 Base Score: 6.5 (Medium)
CVSSv3 Base Vector: CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
Exploitation results in denial of service by crashing an svnserve
process. The impact of this differs depending on how svnserve is
launched, including the different run modes selected by options such
as "svnserve -d", "svnserve -T -d", "svnserve -t", and "svnserve -i".
Recommendations:
================
We recommend all users to upgrade to a known fixed release of the
Subversion svnserve server.
The same releases also include changes in the client side. These
client-side changes are not needed to fix the server vulnerability.
Upgrading the clients to one of these releases provides an ordinary bug
fix that make the case in question work correctly when operating against
an upgraded server.
- With a new client against a new server, such queries are now handled
correctly.
- With an old client against a new server, the client will report a more
informative error message, and the server will not crash.
- With a new client against an old server, the behaviour is the same as
with an old client against an old server.
Users who are unable to upgrade may apply the included patches.
References:
===========
CVE-2018-11782 (Subversion)
Reported by:
============
Ace Olszowka, Build Master, Computers Unlimited
Patches:
========
Patch against Subversion 1.12.0, 1.10.4:
[[[
Index: subversion/libsvn\_ra\_svn/client.c
===================================================================
--- subversion/libsvn\_ra\_svn/client.c
+++ subversion/libsvn\_ra\_svn/client.c
@@ -3102,25 +3102,38 @@ ra\_svn\_get\_deleted\_rev(svn\_ra\_session\_t
svn\_revnum\_t \*revision\_deleted,
apr\_pool\_t \*pool)
{
svn\_ra\_svn\_\_session\_baton\_t \*sess\_baton = session->priv;
svn\_ra\_svn\_conn\_t \*conn = sess\_baton->conn;
+ svn\_error\_t \*err;
path = reparent\_path(session, path, pool);
/\* Transmit the parameters. \*/
SVN\_ERR(svn\_ra\_svn\_\_write\_cmd\_get\_deleted\_rev(conn, pool, path,
peg\_revision, end\_revision));
/\* Servers before 1.6 don't support this command. Check for this here. \*/
SVN\_ERR(handle\_unsupported\_cmd(handle\_auth\_request(sess\_baton, pool),
N\_("'get-deleted-rev' not implemented")));
- return svn\_error\_trace(svn\_ra\_svn\_\_read\_cmd\_response(conn, pool, "r",
- revision\_deleted));
+ err = svn\_error\_trace(svn\_ra\_svn\_\_read\_cmd\_response(conn, pool, "r",
+ revision\_deleted));
+ /\* The protocol does not allow for a reply of SVN\_INVALID\_REVNUM directly.
+ Instead, a new enough server returns SVN\_ERR\_ENTRY\_MISSING\_REVISION to
+ indicate the answer to the query is SVN\_INVALID\_REVNUM. (An older server
+ closes the connection and returns SVN\_ERR\_RA\_SVN\_CONNECTION\_CLOSED.) \*/
+ if (err && err->apr\_err == SVN\_ERR\_ENTRY\_MISSING\_REVISION)
+ {
+ \*revision\_deleted = SVN\_INVALID\_REVNUM;
+ svn\_error\_clear(err);
+ }
+ else
+ SVN\_ERR(err);
+ return SVN\_NO\_ERROR;
}
static svn\_error\_t \*
ra\_svn\_register\_editor\_shim\_callbacks(svn\_ra\_session\_t \*session,
svn\_delta\_shim\_callbacks\_t \*callbacks)
{
Index: subversion/svnserve/serve.c
===================================================================
--- subversion/svnserve/serve.c
+++ subversion/svnserve/serve.c
@@ -3513,14 +3513,27 @@ get\_deleted\_rev(svn\_ra\_svn\_conn\_t \*conn,
SVN\_ERR(svn\_ra\_svn\_\_parse\_tuple(params, "crr",
&path, &peg\_revision, &end\_revision));
full\_path = svn\_fspath\_\_join(b->repository->fs\_path->data,
svn\_relpath\_canonicalize(path, pool), pool);
SVN\_ERR(log\_command(b, conn, pool, "get-deleted-rev"));
SVN\_ERR(trivial\_auth\_request(conn, pool, b));
- SVN\_ERR(svn\_repos\_deleted\_rev(b->repository->fs, full\_path, peg\_revision,
- end\_revision, &revision\_deleted, pool));
+ SVN\_CMD\_ERR(svn\_repos\_deleted\_rev(b->repository->fs, full\_path, peg\_revision,
+ end\_revision, &revision\_deleted, pool));
+
+ /\* The protocol does not allow for a reply of SVN\_INVALID\_REVNUM directly.
+ Instead, return SVN\_ERR\_ENTRY\_MISSING\_REVISION. A new enough client
+ knows that this means the answer to the query is SVN\_INVALID\_REVNUM.
+ (An older client reports this as an error.) \*/
+ if (revision\_deleted == SVN\_INVALID\_REVNUM)
+ SVN\_CMD\_ERR(svn\_error\_createf(SVN\_ERR\_ENTRY\_MISSING\_REVISION, NULL,
+ "svn protocol command 'get-deleted-rev': "
+ "path '%s' was not deleted in r%ld-%ld; "
+ "NOTE: newer clients handle this case "
+ "and do not report it as an error",
+ full\_path, peg\_revision, end\_revision));
+
SVN\_ERR(svn\_ra\_svn\_\_write\_cmd\_response(conn, pool, "r", revision\_deleted));
return SVN\_NO\_ERROR;
}
static svn\_error\_t \*
get\_inherited\_props(svn\_ra\_svn\_conn\_t \*conn,
Index: subversion/tests/libsvn\_ra/ra-test.c
===================================================================
--- subversion/tests/libsvn\_ra/ra-test.c
+++ subversion/tests/libsvn\_ra/ra-test.c
@@ -91,12 +91,47 @@ commit\_changes(svn\_ra\_session\_t \*session
SVN\_ERR(editor->close\_directory(dir\_baton, pool));
SVN\_ERR(editor->close\_directory(root\_baton, pool));
SVN\_ERR(editor->close\_edit(edit\_baton, pool));
return SVN\_NO\_ERROR;
}
+/\* Commit two revisions: add 'B', then delete 'A' \*/
+static svn\_error\_t \*
+commit\_two\_changes(svn\_ra\_session\_t \*session,
+ apr\_pool\_t \*pool)
+{
+ apr\_hash\_t \*revprop\_table = apr\_hash\_make(pool);
+ const svn\_delta\_editor\_t \*editor;
+ void \*edit\_baton;
+ void \*root\_baton, \*dir\_baton;
+
+ /\* mkdir B \*/
+ SVN\_ERR(svn\_ra\_get\_commit\_editor3(session, &editor, &edit\_baton,
+ revprop\_table,
+ NULL, NULL, NULL, TRUE, pool));
+ SVN\_ERR(editor->open\_root(edit\_baton, SVN\_INVALID\_REVNUM,
+ pool, &root\_baton));
+ SVN\_ERR(editor->add\_directory("B", root\_baton, NULL, SVN\_INVALID\_REVNUM,
+ pool, &dir\_baton));
+ SVN\_ERR(editor->close\_directory(dir\_baton, pool));
+ SVN\_ERR(editor->close\_directory(root\_baton, pool));
+ SVN\_ERR(editor->close\_edit(edit\_baton, pool));
+
+ /\* delete A \*/
+ SVN\_ERR(svn\_ra\_get\_commit\_editor3(session, &editor, &edit\_baton,
+ revprop\_table,
+ NULL, NULL, NULL, TRUE, pool));
+ SVN\_ERR(editor->open\_root(edit\_baton, SVN\_INVALID\_REVNUM,
+ pool, &root\_baton));
+ SVN\_ERR(editor->delete\_entry("A", SVN\_INVALID\_REVNUM, root\_baton, pool));
+ SVN\_ERR(editor->close\_directory(root\_baton, pool));
+ SVN\_ERR(editor->close\_edit(edit\_baton, pool));
+
+ return SVN\_NO\_ERROR;
+}
+
static svn\_error\_t \*
commit\_tree(svn\_ra\_session\_t \*session,
apr\_pool\_t \*pool)
{
apr\_hash\_t \*revprop\_table = apr\_hash\_make(pool);
const svn\_delta\_editor\_t \*editor;
@@ -1781,12 +1816,62 @@ commit\_locked\_file(const svn\_test\_opts\_t
SVN\_TEST\_ASSERT(propval);
SVN\_TEST\_STRING\_ASSERT(propval->data, "propval");
return SVN\_NO\_ERROR;
}
+/\* Cases of 'get-deleted-rev' that should return SVN\_INVALID\_REVNUM. \*/
+static svn\_error\_t \*
+test\_get\_deleted\_rev\_no\_delete(const svn\_test\_opts\_t \*opts,
+ apr\_pool\_t \*pool)
+{
+ svn\_ra\_session\_t \*ra\_session;
+ svn\_revnum\_t revision\_deleted;
+
+ SVN\_ERR(make\_and\_open\_repos(&ra\_session,
+ "test-repo-get-deleted-rev-no-delete", opts,
+ pool));
+ SVN\_ERR(commit\_changes(ra\_session, pool));
+ SVN\_ERR(commit\_two\_changes(ra\_session, pool));
+
+ /\* expect 'no deletion' in the range up to r2, when it is deleted in r3 \*/
+ /\* This was failing over RA-SVN where the 'get-deleted-rev' wire command's
+ prototype cannot directly represent that result. A new enough client and
+ server collaborate on a work-around implemented using an error code. \*/
+ SVN\_ERR(svn\_ra\_get\_deleted\_rev(ra\_session, "A", 1, 2,
+ &revision\_deleted, pool));
+ SVN\_TEST\_INT\_ASSERT(revision\_deleted, SVN\_INVALID\_REVNUM);
+
+ /\* this connection should still be open: a simple case should still work \*/
+ SVN\_ERR(svn\_ra\_get\_deleted\_rev(ra\_session, "A", 1, 3,
+ &revision\_deleted, pool));
+ SVN\_TEST\_INT\_ASSERT(revision\_deleted, 3);
+
+ return SVN\_NO\_ERROR;
+}
+
+/\* Cases of 'get-deleted-rev' that should return an error. \*/
+static svn\_error\_t \*
+test\_get\_deleted\_rev\_errors(const svn\_test\_opts\_t \*opts,
+ apr\_pool\_t \*pool)
+{
+ svn\_ra\_session\_t \*ra\_session;
+ svn\_revnum\_t revision\_deleted;
+
+ SVN\_ERR(make\_and\_open\_repos(&ra\_session,
+ "test-repo-get-deleted-rev-errors", opts, pool));
+ SVN\_ERR(commit\_changes(ra\_session, pool));
+
+ /\* expect an error when searching up to r3, when repository head is r1 \*/
+ SVN\_TEST\_ASSERT\_ERROR(svn\_ra\_get\_deleted\_rev(ra\_session, "A", 1, 3,
+ &revision\_deleted, pool),
+ SVN\_ERR\_FS\_NO\_SUCH\_REVISION);
+
+ return SVN\_NO\_ERROR;
+}
+
/\* The test table. \*/
static int max\_threads = 4;
static struct svn\_test\_descriptor\_t test\_funcs[] =
@@ -1817,10 +1902,14 @@ static struct svn\_test\_descriptor\_t test
SVN\_TEST\_OPTS\_PASS(tunnel\_run\_checkout,
"verify checkout over a tunnel"),
SVN\_TEST\_OPTS\_PASS(commit\_empty\_last\_change,
"check how last change applies to empty commit"),
SVN\_TEST\_OPTS\_PASS(commit\_locked\_file,
"check commit editor for a locked file"),
+ SVN\_TEST\_OPTS\_PASS(test\_get\_deleted\_rev\_no\_delete,
+ "test get-deleted-rev no delete"),
+ SVN\_TEST\_OPTS\_PASS(test\_get\_deleted\_rev\_errors,
+ "test get-deleted-rev errors"),
SVN\_TEST\_NULL
};
SVN\_TEST\_MAIN
]]]
Patch against Subversion 1.9.10
[[[
Index: subversion/libsvn\_ra\_svn/client.c
===================================================================
--- subversion/libsvn\_ra\_svn/client.c
+++ subversion/libsvn\_ra\_svn/client.c
@@ -2837,6 +2837,7 @@
{
svn\_ra\_svn\_\_session\_baton\_t \*sess\_baton = session->priv;
svn\_ra\_svn\_conn\_t \*conn = sess\_baton->conn;
+ svn\_error\_t \*err;
/\* Transmit the parameters. \*/
SVN\_ERR(svn\_ra\_svn\_\_write\_cmd\_get\_deleted\_rev(conn, pool, path,
@@ -2846,8 +2847,20 @@
SVN\_ERR(handle\_unsupported\_cmd(handle\_auth\_request(sess\_baton, pool),
N\_("'get-deleted-rev' not implemented")));
- return svn\_error\_trace(svn\_ra\_svn\_\_read\_cmd\_response(conn, pool, "r",
- revision\_deleted));
+ err = svn\_error\_trace(svn\_ra\_svn\_\_read\_cmd\_response(conn, pool, "r",
+ revision\_deleted));
+ /\* The protocol does not allow for a reply of SVN\_INVALID\_REVNUM directly.
+ Instead, a new enough server returns SVN\_ERR\_ENTRY\_MISSING\_REVISION to
+ indicate the answer to the query is SVN\_INVALID\_REVNUM. (An older server
+ closes the connection and returns SVN\_ERR\_RA\_SVN\_CONNECTION\_CLOSED.) \*/
+ if (err && err->apr\_err == SVN\_ERR\_ENTRY\_MISSING\_REVISION)
+ {
+ \*revision\_deleted = SVN\_INVALID\_REVNUM;
+ svn\_error\_clear(err);
+ }
+ else
+ SVN\_ERR(err);
+ return SVN\_NO\_ERROR;
}
static svn\_error\_t \*
Index: subversion/svnserve/serve.c
===================================================================
--- subversion/svnserve/serve.c
+++ subversion/svnserve/serve.c
@@ -3296,8 +3296,21 @@
svn\_relpath\_canonicalize(path, pool), pool);
SVN\_ERR(log\_command(b, conn, pool, "get-deleted-rev"));
SVN\_ERR(trivial\_auth\_request(conn, pool, b));
- SVN\_ERR(svn\_repos\_deleted\_rev(b->repository->fs, full\_path, peg\_revision,
- end\_revision, &revision\_deleted, pool));
+ SVN\_CMD\_ERR(svn\_repos\_deleted\_rev(b->repository->fs, full\_path, peg\_revision,
+ end\_revision, &revision\_deleted, pool));
+
+ /\* The protocol does not allow for a reply of SVN\_INVALID\_REVNUM directly.
+ Instead, return SVN\_ERR\_ENTRY\_MISSING\_REVISION. A new enough client
+ knows that this means the answer to the query is SVN\_INVALID\_REVNUM.
+ (An older client reports this as an error.) \*/
+ if (revision\_deleted == SVN\_INVALID\_REVNUM)
+ SVN\_CMD\_ERR(svn\_error\_createf(SVN\_ERR\_ENTRY\_MISSING\_REVISION, NULL,
+ "svn protocol command 'get-deleted-rev': "
+ "path '%s' was not deleted in r%ld-%ld; "
+ "NOTE: newer clients handle this case "
+ "and do not report it as an error",
+ full\_path, peg\_revision, end\_revision));
+
SVN\_ERR(svn\_ra\_svn\_\_write\_cmd\_response(conn, pool, "r", revision\_deleted));
return SVN\_NO\_ERROR;
}
@@ -3768,7 +3781,7 @@
serve\_params\_t \*params,
apr\_pool\_t \*scratch\_pool)
{
- svn\_error\_t \*err, \*io\_err;
+ svn\_error\_t \*err;
apr\_uint64\_t ver;
const char \*client\_url, \*ra\_client\_string, \*client\_string;
apr\_array\_header\_t \*caplist;
@@ -3900,11 +3913,12 @@
}
if (err)
{
- log\_error(err, b);
- io\_err = svn\_ra\_svn\_\_write\_cmd\_failure(conn, scratch\_pool, err);
- svn\_error\_clear(err);
- SVN\_ERR(io\_err);
- return svn\_ra\_svn\_\_flush(conn, scratch\_pool);
+ /\* Report these errors to the client before closing the connection. \*/
+ err = svn\_error\_compose\_create(err,
+ svn\_ra\_svn\_\_write\_cmd\_failure(conn, scratch\_pool, err));
+ err = svn\_error\_compose\_create(err,
+ svn\_ra\_svn\_\_flush(conn, scratch\_pool));
+ return err;
}
SVN\_ERR(svn\_fs\_get\_uuid(b->repository->fs, &b->repository->uuid,
Index: subversion/tests/libsvn\_ra/ra-test.c
===================================================================
--- subversion/tests/libsvn\_ra/ra-test.c
+++ subversion/tests/libsvn\_ra/ra-test.c
@@ -93,6 +93,41 @@
return SVN\_NO\_ERROR;
}
+/\* Commit two revisions: add 'B', then delete 'A' \*/
+static svn\_error\_t \*
+commit\_two\_changes(svn\_ra\_session\_t \*session,
+ apr\_pool\_t \*pool)
+{
+ apr\_hash\_t \*revprop\_table = apr\_hash\_make(pool);
+ const svn\_delta\_editor\_t \*editor;
+ void \*edit\_baton;
+ void \*root\_baton, \*dir\_baton;
+
+ /\* mkdir B \*/
+ SVN\_ERR(svn\_ra\_get\_commit\_editor3(session, &editor, &edit\_baton,
+ revprop\_table,
+ NULL, NULL, NULL, TRUE, pool));
+ SVN\_ERR(editor->open\_root(edit\_baton, SVN\_INVALID\_REVNUM,
+ pool, &root\_baton));
+ SVN\_ERR(editor->add\_directory("B", root\_baton, NULL, SVN\_INVALID\_REVNUM,
+ pool, &dir\_baton));
+ SVN\_ERR(editor->close\_directory(dir\_baton, pool));
+ SVN\_ERR(editor->close\_directory(root\_baton, pool));
+ SVN\_ERR(editor->close\_edit(edit\_baton, pool));
+
+ /\* delete A \*/
+ SVN\_ERR(svn\_ra\_get\_commit\_editor3(session, &editor, &edit\_baton,
+ revprop\_table,
+ NULL, NULL, NULL, TRUE, pool));
+ SVN\_ERR(editor->open\_root(edit\_baton, SVN\_INVALID\_REVNUM,
+ pool, &root\_baton));
+ SVN\_ERR(editor->delete\_entry("A", SVN\_INVALID\_REVNUM, root\_baton, pool));
+ SVN\_ERR(editor->close\_directory(root\_baton, pool));
+ SVN\_ERR(editor->close\_edit(edit\_baton, pool));
+
+ return SVN\_NO\_ERROR;
+}
+
static svn\_error\_t \*
commit\_tree(svn\_ra\_session\_t \*session,
apr\_pool\_t \*pool)
@@ -842,6 +877,63 @@
}

+/\* Cases of 'get-deleted-rev' that should return SVN\_INVALID\_REVNUM. \*/
+static svn\_error\_t \*
+test\_get\_deleted\_rev\_no\_delete(const svn\_test\_opts\_t \*opts,
+ apr\_pool\_t \*pool)
+{
+ svn\_ra\_session\_t \*ra\_session;
+ svn\_revnum\_t revision\_deleted;
+
+ SVN\_ERR(make\_and\_open\_repos(&ra\_session,
+ "test-repo-get-deleted-rev-no-delete", opts,
+ pool));
+ SVN\_ERR(commit\_changes(ra\_session, pool));
+ SVN\_ERR(commit\_two\_changes(ra\_session, pool));
+
+ /\* expect 'no deletion' in the range up to r2, when it is deleted in r3 \*/
+ /\* This was failing over RA-SVN where the 'get-deleted-rev' wire command's
+ prototype cannot directly represent that result. A new enough client and
+ server collaborate on a work-around implemented using an error code. \*/
+ SVN\_ERR(svn\_ra\_get\_deleted\_rev(ra\_session, "A", 1, 2,
+ &revision\_deleted, pool));
+ SVN\_TEST\_INT\_ASSERT(revision\_deleted, SVN\_INVALID\_REVNUM);
+
+ /\* this connection should still be open: a simple case should still work \*/
+ SVN\_ERR(svn\_ra\_get\_deleted\_rev(ra\_session, "A", 1, 3,
+ &revision\_deleted, pool));
+ SVN\_TEST\_INT\_ASSERT(revision\_deleted, 3);
+
+ return SVN\_NO\_ERROR;
+}
+
+/\* Cases of 'get-deleted-rev' that should return an error. \*/
+static svn\_error\_t \*
+test\_get\_deleted\_rev\_errors(const svn\_test\_opts\_t \*opts,
+ apr\_pool\_t \*pool)
+{
+ svn\_ra\_session\_t \*ra\_session;
+ svn\_revnum\_t revision\_deleted;
+ svn\_error\_t \*err;
+
+ SVN\_ERR(make\_and\_open\_repos(&ra\_session,
+ "test-repo-get-deleted-rev-errors", opts, pool));
+ SVN\_ERR(commit\_changes(ra\_session, pool));
+
+ /\* expect an error when searching up to r3, when repository head is r1 \*/
+ err = svn\_ra\_get\_deleted\_rev(ra\_session, "A", 1, 3, &revision\_deleted, pool);
+
+ /\* mod\_dav\_svn returns a generic error code for "500 Internal Server Error";
+ \* the other RA layers return the specific error code for "no such revision".
+ \* We should make these consistent, but for now that's how it is. \*/
+ if (opts->repos\_url && strncmp(opts->repos\_url, "http", 4) == 0)
+ SVN\_TEST\_ASSERT\_ERROR(err, SVN\_ERR\_RA\_DAV\_REQUEST\_FAILED);
+ else
+ SVN\_TEST\_ASSERT\_ERROR(err, SVN\_ERR\_FS\_NO\_SUCH\_REVISION);
+
+ return SVN\_NO\_ERROR;
+}
+
/\* The test table. \*/
static int max\_threads = 2;
@@ -867,6 +959,10 @@
"check list has\_props performance"),
SVN\_TEST\_OPTS\_PASS(tunnel\_run\_checkout,
"verify checkout over a tunnel"),
+ SVN\_TEST\_OPTS\_PASS(test\_get\_deleted\_rev\_no\_delete,
+ "test get-deleted-rev no delete"),
+ SVN\_TEST\_OPTS\_PASS(test\_get\_deleted\_rev\_errors,
+ "test get-deleted-rev errors"),
SVN\_TEST\_NULL
};
]]]

