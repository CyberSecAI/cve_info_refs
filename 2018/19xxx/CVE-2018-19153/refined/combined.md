=== Content from medium.com_87f2902f_20250125_232605.html ===
[Open in app](https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2Fb8b05723f806&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderUser&source=---top_nav_layout_nav----------------------------------)

Sign up

[Sign in](/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2F%40dsl_uiuc%2Ffake-stake-attacks-on-chain-based-proof-of-stake-cryptocurrencies-b8b05723f806&source=post_page---top_nav_layout_nav-----------------------global_nav-----------)

[Write](/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---top_nav_layout_nav-----------------------new_post_topnav-----------)

Sign up

[Sign in](/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2F%40dsl_uiuc%2Ffake-stake-attacks-on-chain-based-proof-of-stake-cryptocurrencies-b8b05723f806&source=post_page---top_nav_layout_nav-----------------------global_nav-----------)

![](https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png)
# “Fake Stake” attacks on chain-based Proof-of-Stake cryptocurrencies

[![Decentralized Systems Lab](https://miro.medium.com/v2/resize:fill:88:88/1*WQZaQemwNYQajxjz6v_0DA.png)](/%40dsl_uiuc?source=post_page---byline--b8b05723f806--------------------------------)

[Decentralized Systems Lab](/%40dsl_uiuc?source=post_page---byline--b8b05723f806--------------------------------)

·

[Follow](/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F899bd972569d&operation=register&redirect=https%3A%2F%2Fmedium.com%2F%40dsl_uiuc%2Ffake-stake-attacks-on-chain-based-proof-of-stake-cryptocurrencies-b8b05723f806&user=Decentralized+Systems+Lab&userId=899bd972569d&source=post_page-899bd972569d--byline--b8b05723f806---------------------post_header-----------)

14 min read·Jan 22, 2019

--

23

Listen

Share

This article is the public disclosure of a series of resource exhaustion vulnerabilities investigated by a team of students consisting of Sanket Kanjalkar ([sanket1729](https://twitter.com/sanket1729), smk7@illinois.edu), Yunqi Li, Yuguang Chen, Joseph Kuo, and our adviser Andrew Miller([socrates1024](https://twitter.com/socrates1024)) in the Decentralized Systems Lab @ UIUC. These vulnerabilities have affected 26+ Proof-of-Stake cryptocurrencies in total and would allow a network attacker with a very small amount of stake to crash any of the network nodes running the corresponding software. We began a coordinated disclosure in October 2018 to notify development teams of affected cryptocurrencies ahead of this public release. The majority of them (weighted by marketcap) have already deployed mitigations.

Proof-of-Stake (PoS) cryptocurrencies, particularly those based on chain-based PoSv3 ([Proof-of-Stake version 3](http://earlz.net/view/2017/07/27/1904/the-missing-explanation-of-proof-of-stake-version)), are similar to Bitcoin in that they use the UTXO model and longest chain consensus rules. The key difference is that they replace the Proof-of-Work with proof-of-ownership of coins. Potential benefits of the PoS approach range from reducing environmental impact to better security against 51% attacks. Many cryptocurrencies are in fact forks (or at least descendants) of Bitcoin’s codebase, with the PoS functionality grafted in. However, some design ideas are copied over insecurely, leading to new vulnerabilities that did not exist in the parent codebase.

We call the vulnerabilities we found “Fake Stake” attacks. Essentially, they work because PoSv3 implementations do not adequately validate network data before committing precious resources (disk and RAM). The consequence is that an attacker without much stake (in some cases none at all) can cause a victim node to crash by filling up its disk or RAM with bogus data. We believe that all currencies based on the UTXO and longest chain Proof-of-Stake model are vulnerable to these “Fake Stake” attacks. A list of the cryptocurrencies we investigated and believe to be affected are shown towards the end of the article.

In the rest of this post, we’ll explain the vulnerabilities and attacks in detail, because they have some subtle consequences. While the flaw itself is simple in hindsight, solving the problem completely is tricky and the mitigations employed so far come at the cost of a chain split risk (more on this later).

# Background:

Before going into the details of the vulnerabilities, we give some background on the relevant parts of how chain-based proof-of-stake works.

## Proof-of-Stake Mining:

Similar to Proof-of-Work mining, mining in PoS consists of comparing the hash of a block header to a difficulty target. The high-level goal of PoS is to ensure that each stakeholder’s chance of mining the next block is proportional to the number of coins they control. To achieve this, in chain-based PoS the hash depends on not just the block header, but also the quantity of coins included in a special “coinstake” transaction inserted in the block by the stakeholder. The exact details of PoS mining can be a bit involved, and a thorough explanation can be found in earlz’s blog [post](http://earlz.net/view/2017/07/27/1904/the-missing-explanation-of-proof-of-stake-version). For this post, what matters is that checking the PoS depends on 1) the coinstake transaction and 2) the UTXO being spent by the coinstake transaction.

## The role of Proof-of-Work in guarding block validation resources:

It’s well understood that Proof-of-Work (PoW) plays an essential role in Bitcoin consensus. But Proof-of-Work also plays a second, somewhat less appreciated role, which is guarding access to a node’s limited resources, such as disk, bandwidth, memory, and CPU. In a permissionless cryptocurrency network, peers must not be trusted. So, to prevent against resource exhaustion attacks, Bitcoin nodes first check the PoW for any received blocks before committing more resources, such as storing the block in RAM or on disk. However, it turns out that checking a Proof-of-Stake is a lot more complicated and context-sensitive than validating a Proof-of-Work. As a result, many chain-based PoS implementations have skimped on the appropriate validation.

To understand how this leads to a resource exhaustion vulnerability, we have to give a bit of detail on how blocks are stored before being validated. A node must not only keep track of the longest chain at the current instant, but also a tree of fork chains (any of them may turn out to be the longest chain, in which case the node needs to “reorg” to switch to it). This can happen, for example, during a botched upgrade, a double spend attack ([ETC under 51% attack](https://blog.coinbase.com/ethereum-classic-etc-is-currently-being-51-attacked-33be13ce32de)), or a temporary network partition.

Validating these off-the-main-chain blocks is difficult. To fully validate the block, you need the set of unspent coins (UTXOs) at the time of the previous block. Bitcoin keeps the UTXO set for the current tip of the best chain, but not for all the other past blocks a fork could start from. There are two main approaches for full validation of blocks on a fork:

1. “roll back” the current view (UTXO set) to the point before the fork begins, or
2. store copies of the UTXO set for all the earlier blocks.

Bitcoin’s codebase doesn’t support Option 2, and even if it did this would impose an additional storage cost (Bitcoin node performance relies on aggressively pruning unneeded data). Option 1 is exactly how the Bitcoin codebase currently handles a reorg. However, this can be very expensive, so the roll back and full validation are deferred to the last possible moment when the Proof-of-Work in the fork is already greater than the current main chain. So instead, when a peer first receives a block or header that is not part of the longest chain, full validation is skipped and the block is saved to local storage.

Before storing the block to disk, the Bitcoin codebase performs some preliminary validation based on the PoW (but ignoring the transactions). This preliminary check only depends on previous block header and current header, so a node can do this very quickly. And it’s an effective defense because generating a valid PoW that passes it is very expensive. For example, although it’s possible to trick a Bitcoin node into storing an invalid block on disk, it’s prohibitively expensive to mount a resource exhaustion attack this way.

The analogous preliminary check in PoS is to validate the coinstake transaction and check that it passes the difficulty target when hashed with the kernel of the previous block. Computing the hash of the coinstake transaction is easy, but the hard part is checking whether the input UTXO to the coinstake transaction is valid and unspent, since this requires checking the UTXO set, which as mentioned earlier, is not available for past blocks. Because fully validating the coinstake transaction is difficult, most chain-based PoS implementations provide a heuristic or approximate check instead. It turns out that these approximations are often inadequate and can be exploited.

# Vulnerability #1: “I Can’t Believe it’s not Stake”

When we first investigated this problem, we found that five cryptocurrencies, Qtum, Particl, Navcoin, HTMLcoin, and Emercoin, exhibited a fairly trivial form of this vulnerability: namely, they fail to check any coinstake transaction at all before committing a block to RAM or disk. What these five cryptocurrencies have in common is that they have adopted Bitcoin’s “headers first” feature, in which block propagation was split into two separate messages, Block and Header. Nodes only ask for Block after Header passes the PoW checks AND it is a longest (or longer) chain. Since the coinstake transaction is present only in Block but not the Header, a node cannot validate the Header on its own. Instead, it directly stores the header to an in-memory data structure (mapBlockIndex). ***As a result, any network attacker, even with no stake whatsoever, can fill up a victim node’s RAM.***

The second variation of this attack can be carried out against the same codebases, although it works in a slightly different manner and targets a different resource, the victim’s disk rather than RAM. Arguably an attack involving disk is more harmful to the victim: If RAM is filled up and the node crashes, it can simply be restarted. However, if the disk is full, manual intervention would be required (for example, to run an [external script](https://github.com/bitcoin/bitcoin/tree/master/contrib/linearize) to clean up stale blocks from disk).

Different preliminary checks are performed when receiving a block rather than receiving a header. Ideally, since the block **does** contain the coinstake transaction, the node software should check the coinstake transaction before committing the block to disk. However, as mentioned, if the block is on a fork, there is no easy way for a node to access the UTXO spent by the coinstake transaction. Perhaps for this reason, these codebases do not validate the coinstake transaction.

Exploiting either of these vulnerabilities can be carried out without having any stake in the affected cryptocurrency at all. The RAM version of the attack is particularly trivial, but for technical reasons, the disk version of the attack requires slightly more care (*though still no stake is required)*. The details are explained in a short paper to be presented at [Financial Cryptography 2019](http://fc19.ifca.ai/preproceedings/180-preproceedings.pdf).

# Vulnerability #2 and the Spent Stake attack

By tracing the lineage of these codebases, we noticed that vulnerability #1 was originally introduced when merging Bitcoin’s “header-first” feature into the PoSv3 codebase. The attack does not work on earlier versions (for example, Peercoin) because there are two additional preliminary checks prior to storing blocks on disk:

1. Check if the output being spent exists in the main chain.
2. Check if the PoS kernel hash meets the difficulty target.

Check 1 is accomplished by a lookup in the transaction database (TxDB), which keeps track of all the transactions in the current main chain so far. In other words, the preliminary validation is better than no validation, but still a heuristic and incomplete approximation of full validation. If you’re following the explanation up to this point, two concerns may jump right out at you:

*Concern A*: Check 1 ensures that the coin exists, but NOT that it is unspent. This insight immediately leads to the vulnerability we discuss next.

*Concern B*: Even if we’re validating a block on a fork of the main chain, the coinstake transaction is validated against the TxDB for the main chain itself.

Based on Concern A, we found a way to fool these checks as well, using a more subtle attack we call the “**spent** **stake attack**.” To get around Check 1, we use an output that is seen by the node but is already spent. Typically, in order to get around Check 2, we would need to mine a valid block that passes the difficulty target, which in turn would require a large amount of stake. As it turns out, however, we can abuse the incomplete validation to generate an arbitrary amount of ***apparent stake*** using a technique we call “**stake amplification**.”

# Stake Amplification

To carry out the attack starting from a small amount of stake, the attacker must amplify their amount of apparent stake. ***Apparent stake*** refers to the total candidate stake outputs, even the ones that are already spent. If an attacker starts with a UTXO of amount **k,** then the attacker can create multiple transactions spending the coins back to the attacker as shown in the figure below. Only UTXO**(n+1**) should be allowed for staking, but because of Check 2 above we are able to stake with all UTXO from **1** through **n+1**, thereby increasing the apparent stake by **n\*k**. This increases the chances of finding a PoS block since the attacker can keep on doing this to increase his apparent stake. This is illustrated as “**stake amplification step**” on the left side of the illustration below.

![]()

Stake Amplification and Spent Stake Attack

For example, even with 0.01% stake in the system, the attacker only needs 5000 transactions to mine blocks with 50% apparent stake power. After the attacker has collected a large amount of apparent stake, he then proceeds to mine PoS blocks at a past time using the freshly collected *apparent stake* outputs. Finally, the attacker fills the disk of the victim peer with the invalid blocks as shown on the right part of the illustration above. An attacker could, for example, buy some coins from an exchange, amplify the stake through self-spends as we described, and then sell those coins back to the exchange, performing the attack at any later date. The only cost incurred to the attacker would be the transaction fees.

# Coordinated Vulnerability Disclosure

We first investigated Vulnerability #1 in the context of Particl and Qtum cryptocurrencies.¹ To determine the extent of this vulnerability, we collected a list of known cryptocurrencies from coinmarketcap.com (on Aug. 9th, 2018), sorted by market cap, and filtered by chain-based PoS consensus type. We only looked at cryptocurrencies whose codebase was forked from (a descendant of) Bitcoin, i.e. in C++. In total, we examined 26 cryptocurrencies and found that only five cryptocurrencies (Qtum, Navcoin, HTMLcoin, Emercoin, and Particl) were affected, but our attack did not seem to work on the rest. To confirm the vulnerability, we implemented the attacks in *each* of the five affected codebases. We made use of existing test suites in Bitcoin software, specifically the *regtest* mode, which enables simulated timestamps and easy-to-create blocks, and a Python-based test node (based on [bitcoin TestFramework](https://github.com/bitcoin/bitcoin/tree/master/test/functional)), which can be extended with attacker behavior. We used Docker containers to package these tests, their dependencies, and the specific commit hash affected into a reproducibility kit that we could easily share with all five affected developer teams as part of our vulnerability disclosure.

We then dug deeper to understand why the unaffected cryptocurrencies were not susceptible to the first attack and realized that vulnerability #2 was nearly as severe (requiring minimal amount of stake), but far more pervasive. In planning a coordinated responsible disclosure, we considered that it might be counterproductive to disclose to cryptocurrencies with low economic activity and inactive developer teams (the risk, for example, is that if the vulnerability was leaked, it could affect others before they’d have time to deploy a mitigation). Ultimately, we decided to focus our attention on communicating with the fifteen developer teams associated with cryptocurrencies that were most likely to be attacked (among the top 200 cryptocurrencies) and to be responsive (some commit activity during 2018).

One complicating factor is that most of these codebases did not come with regtest mode, so we could not easily demonstrate the attack or provide a reproducibility kit for each one. We therefore only provided a demonstration on the C++ codebase of stratisX. Based on the similarity in the codebases, we informed all fifteen teams that we believed would be affected. Five teams acknowledged the vulnerability, three are still investigating, three rebutted it (pointed out implementation changes that had a mitigating effect), and four teams gave no response. For the four teams that did not respond, we contacted them through channels we could find from their websites.⁵ ⁶ Our Github reproducibility kit for both vulnerabilities can be found [here](https://github.com/initc3/i-cant-believe-its-not-stake) and our short paper on vulnerability #1 can be found [here](http://fc19.ifca.ai/preproceedings/180-preproceedings.pdf). We have also reserved CVEs for the vulnerabilities, which should be public soon.

Marketcap data from 9th August 2019

# Mitigations

We saw a range of mitigations implemented by teams in response to our disclosure. Some cryptocurrencies implemented mitigations that detect attacks and disconnect from the offending peers.² In simple terms, a node monitors its peers for abnormal behavior (e.g., sending many headers on forks). The challenge with such heuristics is that it’s difficult to distinguish an actual attack from an honest node experiencing a legitimate reorg — there is a risk of mistakenly banning honest nodes. The mitigations we have seen so far look reasonable, but this is an area worth further investigation.

Some other cryptocurrencies added partial validation up to a fixed length.³ If a peer receives a block that forks from the main chain past that length, then the block is simply discarded. This approach is also taken, for example, in the ABC codebase of BCH (Bitcoin Cash), which uses a 10-block rolling checkpoint. The drawback of this approach is that it introduces the possibility of a “chain split.” A chain split occurs when honest nodes end up on different diverging forks of the blockchain. This can occur, for example, if poor network connectivity causes nodes to be out of sync with each other for a long enough time to create conflicting checkpoints. Even if the nodes regain connection, they would be unable to reach a common view of the chain. We note that a chain split risk is present even without this mitigation. Recalling Concern B from earlier, since the coinstake transaction is validated using the transaction outputs in the current chain, it is possible that a node would be unable to switch to the actual main chain if it temporarily found itself on a fork.

The chain split risk also introduces new attack vectors for hostile miners. An attacker could attempt to mine a long chain in secret and then publish it to a subset of the nodes in order to cause a chain split. Nodes in IBD (Initial Block Download) or nodes that have just restarted after a long offline period are particularly vulnerable to this attack. Such attacks can be combined with [eclipse](https://www.usenix.org/node/190891) attacks to lead honest nodes into an attacker controlled chain.

All these mitigations make the attack difficult to carry out but are still no substitute for full validation. Some cryptocurrencies, such as Qtum, plan to move to full validation of off-main-chain-blocks in future releases.

Users of the following affected cryptocurrencies should be advised to update their nodes to the latest patched software and to be aware that in unpatched nodes this vulnerability can be exploited to result in increased RAM or disk consumption and an eventual crash.

The table below shows the currencies which we believe are affected by one of the above two described vulnerabilities. We have not yet validated the vulnerabilities for all currencies, and we have not yet examined why the currencies who rebutted our claims were not affected.

# Final Thoughts

While the “fake stake” attacks are simple in principle, they underscore a difficult design challenge: some ideas that make sense in Proof-of-Work do not translate over securely to Proof-of-Stake. Given the high degree of code sharing from Bitcoin Core as “upstream” among PoSv3 cryptocurrencies, we think this deserves even more scrutiny. While investigating these vulnerabilities, we found several examples across different codebases of works-in-progress⁴ (or commented out code) that aim for various mitigations and ad hoc defenses. To us, this suggests an awareness among PoS developers that the trade-offs and requirements in this design space are not yet fully understood. The challenge is that on one hand, we want to reject invalid blocks as soon as possible, but on the other hand, we don’t want to get stuck on a chain split or get delayed in processing what’s actually the main chain. A systematic way to deal with this remains an open problem for future work.

Although we have seen recent examples (e.g., [CVE 2018–17144](https://bitcoincore.org/en/2018/09/20/notice/) in BTC) affecting at least two codebases, to our knowledge this is the first coordinated security vulnerability disclosure across such a large number (20+) of independent cryptocurrencies. Given the amount of cross-pollination of ideas and code reuse across cryptocurrencies, we anticipate more vulnerabilities like this in the future. We found there was little uniformity in the security process among these codebases. For example, there was no dedicated security contact for most of them. Establishing best practices for coordinated disclosures could benefit the overall ecosystem.

[1] The idea for this vulnerability originated in Summer 2018 while Andrew Miller was working with Unit-E developers. We thank Matteo Sumberaz and Gil Danziger for the helpful discussions and the DTR Foundation ([https://dtr.org/](https://www.google.com/url?q=https%3A%2F%2Fdtr.org%2F&sa=D&ust=1547952064343000&usg=AFQjCNFJLbs3vuyWP_u8v-K6lhUaAgNk-A)) for a research grant.

[2] A Heuristic for peer detection was implemented by Emercoin. <https://github.com/emercoin/emercoin/commit/ec32762b99cc68fb9abb2909dda96bc7a13bd819>

[3] Rolling checkpoints in Qtum <https://github.com/qtumproject/qtum/commit/8d208d0bee8449c1e4a3904ff3fc97ed26156648>

[4]Examples of ad-hoc checks for PoS can be found here: <https://github.com/peercoin/peercoin/blob/ebb4003ce8367501020181f7e734d52c4b1ab5ea/src/main.cpp#L2564>

[5] We reached out to some coins via email listed their webpage or “send note” feature

[6, \*] We tried contacted PIVX multiple times starting in November via the [[contact form on their website](https://pivx.org/contact-us/)]. Only while writing this post did we come to realize that [[PIVX also launched a hackerone project](/tales-from-the-crypt-o/pivx-security-bug-bounty-program-public-launch-recap-adff8108168)]. We note that even as of today, the [[bug bounty page on the PIVX website itself](https://web.archive.org/web/20190121194004/https%3A//pivx.org/pivx-bug-bounty-program/)] does not mention the hackerone project at all.

[\*\*]StratisX has shifted to a C# implementation from their vulnerable C++ codebase.

[\*\*\*] Edit: 26th Jan, 2019: Updated the table with new responses from developers. PivX, LuXcoin, NoLimitCoin, HTMLcoin, DeepOnion.

Edit: Feb 7th, 2019: Added Linda rebuttal.

[Bitcoin](/tag/bitcoin?source=post_page-----b8b05723f806--------------------------------)[Cryptocurrency](/tag/cryptocurrency?source=post_page-----b8b05723f806--------------------------------)[Proof Of Stake](/tag/proof-of-stake?source=post_page-----b8b05723f806--------------------------------)[Proof Of Work](/tag/proof-of-work?source=post_page-----b8b05723f806--------------------------------)[Vulnerability](/tag/vulnerability?source=post_page-----b8b05723f806--------------------------------)

--

--

23

[![Decentralized Systems Lab](https://miro.medium.com/v2/resize:fill:96:96/1*WQZaQemwNYQajxjz6v_0DA.png)](/%40dsl_uiuc?source=post_page---post_author_info--b8b05723f806--------------------------------)[![Decentralized Systems Lab](https://miro.medium.com/v2/resize:fill:128:128/1*WQZaQemwNYQajxjz6v_0DA.png)](/%40dsl_uiuc?source=post_page---post_author_info--b8b05723f806--------------------------------)Follow[## Written by Decentralized Systems Lab](/%40dsl_uiuc?source=post_page---post_author_info--b8b05723f806--------------------------------)[365 Followers](/%40dsl_uiuc/followers?source=post_page---post_author_info--b8b05723f806--------------------------------)·[1 Following](/%40dsl_uiuc/following?source=post_page---post_author_info--b8b05723f806--------------------------------)

Decentralize Systems Lab, University of Illinois at Urbana Champaign

Follow
## Responses (23)

See all responses[Help](https://help.medium.com/hc/en-us?source=post_page-----b8b05723f806--------------------------------)[Status](https://medium.statuspage.io/?source=post_page-----b8b05723f806--------------------------------)[About](/about?autoplay=1&source=post_page-----b8b05723f806--------------------------------)[Careers](/jobs-at-medium/work-at-medium-959d1a85284e?source=post_page-----b8b05723f806--------------------------------)[Press](pressinquiries%40medium.com?source=post_page-----b8b05723f806--------------------------------)[Blog](https://blog.medium.com/?source=post_page-----b8b05723f806--------------------------------)[Privacy](https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----b8b05723f806--------------------------------)[Terms](https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----b8b05723f806--------------------------------)[Text to speech](https://speechify.com/medium?source=post_page-----b8b05723f806--------------------------------)[Teams](/business?source=post_page-----b8b05723f806--------------------------------)



=== Content from fc19.ifca.ai_f672e46c_20250125_232602.html ===
Short Paper: I Can’t Believe It’s Not Stake!
Resource Exhaustion Attacks on PoS

Sanket Kanjalkar, Joseph Kuo, Yunqi Li, Andrew Miller

University of Illinois, Urbana Champaign

Abstract. We present a new resource exhaustion attack affecting sev-
eral chain-based proof-of-stake cryptocurrencies, and in particular Qtum,
a top 30 cryptocurrency by market capitalization ($952M as of 9th Aug
’18). In brief, these cryptocurrencies do not adequately validate the
proof-of-stake before allocating resources to data received from peers.
An attacker can exploit this vulnerability, even without any stake at all,
simply by connecting to a victim and sending malformed blocks, which
the victim stores on disk or in RAM, eventually leading to a crash. We
demonstrate and benchmark the attack through experiments attacking
our own node on the Qtum main network; in our experiment we are able
to fill the victim’s RAM at a rate of 2MB per second, or the disk at a
rate of 6MB per second. We have begun a responsible disclosure of this
vulnerability to appropriate development teams. Our disclosure includes
a Docker-based reproducibility kit using the Python-based test frame-
work. This problem has gone unnoticed for several years. Although the
attack can be mitigated, this appears to require giving up optimizations
enjoyed by proof-of-work cryptocurrencies, underscoring the difficulty in
implementing and deploying chain-based proof-of-stake.

1 Introduction

Bitcoin mining is expensive, with power consumption estimates ranging from
hundreds of megawatts [8, 3] to gigawatts [9]. Naturally, there has been signifi-
cant interest in reducing this cost. The main idea behind Proof-of-stake (PoS) is
to move the mining competition from the physical realm to the financial realm,
replacing computational mining with a random lottery based on held coins.
Chain-based PoS is a minimal modification of the Bitcoin protocol with this in-
sight. Instead of computing hash functions over an arbitrary space, we compute
hash functions of each of the transaction outputs, and compare it against a dif-
ficulty threshold, weighted by the coin amount. This approach is employed by
Peercoin, the first PoS currency, as well as scores of others currently in produc-
tion, and is also the basis for several protocols from the research community [6,
11, 2, 4]. Because of the similarities to Bitcoin, chain-based PoS cryptocurrencies
typically fork the Bitcoin codebase or some descendent thereof.

Most analysis of chain-based PoS has focused on consensus, aiming to show
that properties like chain quality and chain growth are ensured in the same way
as in Bitcoin (i.e., they hold when 51% of the stakeholders follow the protocol).

2

Sanket Kanjalkar, Joseph Kuo, Yunqi Li, Andrew Miller

However, proof-of-work in Bitcoin serves a second purpose, which is to guard
access to limited resources, such as its disk, bandwidth, memory, CPU. Proof-
of-work is easy to check, but expensive to create, and so Bitcoin uses this as
the first line of defense against junk data sent from untrusted network peers:
First check the proof of work, then check everything else. This is similar to
earlier (pre-Bitcoin) uses of proof-of-work, such as preventing spam and guarding
access to server resources [10, 5, 7]. Recent versions of Bitcoin build further on
this approach, transmitting separate data structures containing just the proofs-
of-work (“headers”) ahead of the actual payload (“blocks”).

Unfortunately this idea from Bitcoin does not carry over properly into Proof-
of-Stake. In particular, since the stake in a PoS block is found in the second
transaction (the “coinstake” transaction) rather than in the header, headers-first
processing is prone to attack. To explore the consequences of this insight, we ex-
amined the leading chain-based proof-of-stake cryptocurrencies, and found that
five are vulnerable to a resource exhaustion attack. Roughly the attack involves
sending malformed chains of invalid blocks or headers that are stored in RAM
or on disk without being properly validated. We implemented and benchmarked
these attacks and have begun a responsible disclosure of this issue.

2 Background

2.1 Proof of Stake

Chain-based proof-of-stake protocols can be defined in terms of two functions, a
mining function M and a validation function V [4]. The validation function V
takes as input a chain of blocks, and outputs 1 if and only if the chain is valid
according to the application-specific rules of the cryptocurrency (i.e., all of the
transaction semantics and valid proofs-of-stake). The mining function M takes
as input a previous block B to build on, a coin C, and timestamp t and outputs
a new block B′ if it is indeed possible to mine a block, otherwise it outputs
nothing. Similar to Bitcoin, nodes following the protocol attempt to extend the
longest valid chain they know of.

As in Proof of Work, the mining function M involves comparing a hash of
block data to a difficulty target. Instead of hashing the entire block, PoS intro-
duces the notion of kernel hash, which depends mainly on the first transaction in
the block, called the coinstake transaction. In more detail, the coin C spent by
the coinstake transaction is hashed alongside the block’s timestamp, the kernel
hash of the previous block, and a few other metadata. Finally, the difficulty is
weighted against the quantity of coins in C. Roughly speaking, those with more
coins are proportionally more likely to be eligible to mine the next block.

2.2 Validating PoS blockchains

To mine on the largest valid block chain, as described above, a node must de-
termine whether blocks received from peers are valid according to V . This can

Short Paper: I Can’t Believe It’s Not Stake!

3

be expensive — in particular, it requires checking every transaction comes with
correct signatures and does not double-spend any coins. Bitcoin, as well as Qtum
and other PoS cryptocurrencies derived from it, have fairly complex machinery
to perform this task efficiently. We give a bit more detail on how this works,
focusing on the details relevant to our attack.

First of all, the node keeps track of the state of the current best chain, as
well as a lookup table pcoinsTip of the Unspent Transaction Outputs (UTXOs)
available in this chain. The ConnectBlock() method appends a block to the
current main chain, validating each new transaction with the help of pcoinsTip.
The node maintains an in-RAM data structure mapBlockIndex, which rep-
resents a tree of every (valid) block header received, including the current longest
chain as well as any forks. The AcceptBlockHeader() method performs simple
checks before storing an entry in mapBlockIndex. We note here that in Bitcoin,
this method checks the Proof-of-Work contained in the header, but since the
coinstake transaction is not contained in the header, the analogous checking of
Proof-of-Stake does not occur.

Blocks are stored on disk in append-only block files. Before storing on disk,
the AcceptBlock() method first invokes AcceptBlockHeader(), and then hashes
the transactions to check they match the hashMerkleRoot of the header. However,
the transactions themselves are not checked until later.

If a chain of accepted blocks grows longer than the current main chain, then
it is necessary to perform a “reorg” (Figure 1 A). This method unwinds the
pcoinsTip, disconnecting the blocks one at a time down to the fork point, and
finally connecting (and validating) the blocks in the new chain one at a time.

3 Explanation of the attack

We describe our attack scenarios from the viewpoint of an attacker node that
has already formed a connection to the victim node.

Attack on RAM. We first describe the variation of our attack targeting RAM.
The goal is to create fake block headers that pass AcceptBlockHeaders() so that
the victim stores them in mapBlockIndex. The attack begins by picking an arbi-
trary fork point in the blockchain, and constructing a header that extends this
block, as illustrated in Figure 1 B. Each header’s nTime field must be strictly
greater than its parent. The hashMerkleRoot, which ordinarily would commit to
a batch of new transactions, is instead set to a garbage value. To optimize the
attack, a single headers message contains a chain of the maximum number of
500 headers. To avoid being disconnected, the attacker ensures that the chain
of bogus headers is strictly shorter than the current main chain; otherwise, the
victim would request the corresponding blocks, disconnecting the peer after a
timeout if they are not received. Detailed pseudocode is given in Algorithm 1.

Attack on Disk. Next we describe a variation of the attack that targets disk. The
goal is to create a chain of fake blocks that pass AcceptBlock() so that the victim

4

Sanket Kanjalkar, Joseph Kuo, Yunqi Li, Andrew Miller

stores them in mapBlockIndex and in the blocks database. The attacker first
creates a chain of blocks, starting from an arbitrary fork point in history, and
reaching exactly up to the length of the main chain. Each block is filled to the
maximum size with dummy transactions. The transactions have arbitrary values
for their signatures and references to input transactions, as neither of these are
checked during AcceptBlock(). Before broadcasting the blocks, the attacker first
broadcasts just the headers. The reason for this is that AcceptBlock() discards
a block unless it has been explicitly requested; by sending the headers first,
once the headers chain in mapBlockIndex reaches the same height as the main
chain, the victim requests all the blocks. Notice that full block validation is
only triggered in case of reorg as shown in Figure 1. Since the attacker only
sends blocks that do not exceed the length of the current chain, the victim never
reorgs or validates the block. The pseudo-code for attack on disk is described in
Algorithm 2.

Fig. 1. Resource Exhaustion Attack

4 Evaluating the attack

4.1 Analysis of affected cryptocurrencies

To determine the impact of this vulnerability on the ecosystem, we collected a list
of known cryptocurrencies from coinmarketcap.com (on Aug. 9th 2018), sorted by
market cap, and filtered by chain-based PoS consensus type. We only looked at
cryptocurrencies whose codebase was forked from (a descendent of) Bitcoin, i.e.
in C++. We also omitted cryptocurrencies with smaller than $10M marketcap.
In total we examined 26 cryptocurrencies. Next we inspected the source code and
determined whether each had support for headers-based block downloads (i.e.,

b) Header attacka) Reorgc) Disk fill attack11101213141511101213141511101213141513141516Blockchain blockAttack blockAttack header13141516….131413141314131313161616151515Send fake headersgetblocksSend fake blocks upto current heightd) Disk attack communicationAttackerVictim141414Short Paper: I Can’t Believe It’s Not Stake!

5

block   empty
blockcount   getblockcount()
depth   rand(1, MAX_HEADERS_DEPTH)
pastblock_header   getblockheader(blockcount - depth)
nTime   pastblock_header.nTime
while target_peers.alive() do:

Algorithm 1 RAM attack nothing at stake
1: procedure RAM attack(target_peer)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:

prevhash   pastblock_header.hash
for d in depth do:

nTime   nTime + block_interval*d
nVersion   CURRENT_BLOCK_VERSION
nBits   get_next_difficulty_bits()
merklehash, nonce   rand32_bytes(), rand4_bytes()
block_header   block_header(nVersion, prevhash, merkleroot, nTime, nBits, nonce)
send_msg_header(target_peer, block_header)
prevhash   block_header.hash

block   empty
blockcount   getblockcount()
depth   rand(1, MAX_HEADERS_DEPTH)
pastblock_header   getblockheader(blockcount - depth)
nTime   pastblock_header.nTime
while target_peer.alive() do:

prevhash   pastblock_header.hash
headers, blocks   [],[]
for d in range(depth) do:

Algorithm 2 Disk attack nothing at stake
1: procedure Disk attack(target_peer)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:

block.rehash()
prevhash   block.hash
headers.append(block.header)
blocks.append(block)
send_msg_headers(target_peer, headers)

blocks

26:

send_msg_blocks(target_peer, blocks[-1])

nTime   nTime + block_interval*d
nVersion   CURRENT_BLOCK_VERSION
nBits   get_next_difficulty_bits()
merklehash, nonce   rand32_bytes(), rand4_bytes()
block   block_header(nVersion, prevhash, merkleroot, nTime, nBits, nonce)
for j in range(MAX_TX) do:

prev_tx, prev_index   rand32_bytes(), 0
scriptPubKey, amount   b” ”, rand_amount
tx   create_transaction(prev_tx, prev_index, scriptPubKey, amount)
block.append(tx)

▷ Wait for peer to request

6

Sanket Kanjalkar, Joseph Kuo, Yunqi Li, Andrew Miller

Table 1. Vulnerability analysis of chain-based PoS cryptocurrencies

Name

Qtum
(QTUM)
Emercoin
(EMC)
Particl
(PART)
NavCoin
(NAV)
HTMLCOIN
(HTML)
header disabled
(PIVX etc.)
no header
(PPC etc.)

Market Cap
(USD)

952,265,768

110,386,208

47,065,433

39,029,633

25,447,981

239,172,527

736,472,358

Vulnerable to
RAM Attack
p

Vulnerable to
Disk Attack
p

p

p

p

p

(cid:2)

(cid:2)

p

p

p

p

(cid:2)

(cid:2)

Check TxDB
for Coinstake

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

p

p

Coordinated
Disclosure
p

p

p

p

p

Security
Process

(cid:2)

(cid:2)

(cid:2)

p

(cid:2)

N/A

N/A

N/A

N/A

if the AcceptBlockHeaders() method was present). By inspection, we estimated
that the first 5 coins in Table 1 would be vulnerable to these attacks.

The second-from-bottom row of Table 1 is an aggregate (combined market
cap) of 7 cryptocurrencies that include AcceptBlockHeader() but have disabled
its functionality (i.e., do not process “headers” network messages). Likewise the
bottom row is an aggregate of 14 cryptocurrencies that do not implement Ac-
ceptBlockHeader() at all.

To confirm the vulnerability, we next implemented the attacks in each of the
codebases. We made use of existing test suites in Bitcoin software, specifically the
“regtest” mode, which enables simulated timestamps and easy-to-create blocks,
and a Python-based test node that can be extended with attacker behavior.
We used Docker containers to package these tests, their dependencies, and the
specific commit hash affected, into a reproducibility kit that we could easily
share with developer teams as part of a vulnerability disclosure.

4.2 Benchmarking the attack

To verify that the attack works in a live network setting (and not only in the
regtest mode), we conducted an attack against our own node running on Qtum’s
live network. We optimized our attack to benchmark how effectively it could be
carried out in practice, including forming up to 10 multiple connections to the
victim, and by generating the block/header payloads in a pipelined fashion while
transmitting them over the connections. Our victim node had a download speed
of 1825.35 Mbit/s while our attacker node had an upload speed of 49.27 Mbit/s.
We were able to fill the victim’s disk at a rate of 6.05 MB/s, or the victim’s
RAM at 2.52 MB/s. For the disk attack, the main bottleneck in our testing
was the amount of bandwidth between the attacker and victim. However for the

Short Paper: I Can’t Believe It’s Not Stake!

7

headers attack, we reached a bottleneck of computational overhead as the victim
processes the headers message.

5 Coordinated Vulnerability Disclosure

Resource exhaustion attacks in cryptocurrencies are considered critical vulner-
abilities.1 Because of the ease of exploiting this, we initiated a coordinated dis-
closure process to give developers of all the affected codebases an opportunity
to deploy mitigations.

As highlighted by a recent vulnerability affecting Bitcoin and their rival Bit-
coin Cash,2 there are not yet clearly established guidelines for disclosures in-
volving multiple cryptocurrencies. Cryptocurrencies are decentralized, and in
principle may have no one officially recognized development team [1]. However,
in this instance, all five of the affected projects are clearly associated with an
official website and have publicly listed contact information. We note that only
one of the projects (NavCoin) has a published vulnerability disclosure process
and dedicated security contact.

Cryptocurrency communities have at times been embroiled in bitter disputes.
We considered that disclosing the vulnerability too widely could increase the
risk that one may leak it or attack another. We note that Qtum’s market cap
is around 5x larger than the rest combined. However, as all five responded to
our initial email, and all codebases had active development (commits on GitHub
within the past week), we decided to communicate simultaneously to them all.

6 Mitigations

We propose some easy to implement mitigations for the affected currencies. We
can Checkpoint every K blocks so that the node does not accept forking blocks
more than K blocks deep. Another such mitigation might include Disabling
headers support and use TxDb check to determine if they have seen the coinstake
transaction. This mitigation, although not perfect atleast requires the adversary
to have some stake in the past. Lastly, we propose to UTXO snapshot every K
blocks and perform validation of all blocks by rolling the pcoinsTip struct from
the closest snaphot to the fork point.

7 Discussion and conclusion

We show a resource exhaustion attack that can be carried out by a malicious peer
without any stake in the currency and without any privileged network position.
We found only a small number of the seventy chain-based PoS cryptocurrencies
we considered to be vulnerable; however, weighted by market cap, this is more

1 https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures
2 https://bitcoincore.org/en/2018/09/20/notice/

8

Sanket Kanjalkar, Joseph Kuo, Yunqi Li, Andrew Miller

than half. The affected projects were all forked from a relatively recent Bitcoin
version (version 0.10.0 or later, released February 2015) that incorporates the
“headers first” feature, while those based on earlier versions of Bitcoin code are
not vulnerable. We suspect the most likely outcome of our report is that the
affected cryptocurrencies will downgrade to adopt behavior like the others.

However, we observe that even the non-vulnerable cryptocurrencies do not
correctly implement the idealized protocol described in the research literature [6,
11, 2, 4]. In particular, the coinstake transactions in accepted blocks are validated
against the coins database associated with the current main chain — even if
the new block in question is on a fork from the main chain. In other words, the
validation function Vp is not applied deterministically, but instead approximated.
We plan to explore the consequences of this in future work.

The insights behind our attack are related to, but distinct from, the “nothing-
at-stake” problem. This refers to the observation that in chain-based PoS, stake-
holders are not penalized for mining on blocks on a conflicting fork. Our resource
exhaustion attack is different in that the attacker need not have ever been a
stakeholder at all. However, both cases highlight the difficulties in adapting de-
signs ideas from proof-of-work into the proof-of-stake setting.

References

1. Azouvi, S., Maller, M., Meiklejohn, S.: Egalitarian society or benevolent dictator-
ship: The state of cryptocurrency governance. In: 22nd International Conference
on Financial Cryptography and Data Security (2018)

2. Bentov, I., Gabizon, A., Mizrahi, A.: Cryptocurrencies without proof of work. In:
International Conference on Financial Cryptography and Data Security. pp. 142–
157. Springer (2016)

3. Böhme, R., Christin, N., Edelman, B., Moore, T.: Bitcoin: Economics, technology,

and governance. Journal of Economic Perspectives 29(2), 213–38 (2015)

4. Brown-Cohen, J., Narayanan, A., Psomas, C.A., Weinberg, S.M.: Formal barriers
to longest-chain proof-of-stake protocols. arXiv preprint arXiv:1809.06528 (2018)
5. Dwork, C., Naor, M.: Pricing via processing or combatting junk mail. In: Annual

International Cryptology Conference. pp. 139–147. Springer (1992)

6. Fan, L., Zhou, H.S.: A scalable proof-of-stake blockchain in the open setting (or,
how to mimic nakamoto’s design via proof-of-stake). Cryptology ePrint Archive,
Report 2017/656 (2017), https://eprint.iacr.org/2017/656

7. Juels, A., Brainard, J.G.: Client puzzles: A cryptographic countermeasure against

connection depletion attacks. In: NDSS. vol. 99, pp. 151–165 (1999)

8. Narayanan, A., Bonneau, J., Felten, E., Miller, A., Goldfeder, S.: Bitcoin and
cryptocurrency technologies: a comprehensive introduction. Princeton University
Press (2016)

9. O’Dwyer, K., Malone, D.: Bitcoin mining and its energy footprint. In: IET Con-

ference Proceedings. The Institution of Engineering & Technology (2014)

10. Parno, B., Wendlandt, D., Shi, E., Perrig, A., Maggs, B., Hu, Y.C.: Portcullis:
protecting connection setup from denial-of-capability attacks. ACM SIGCOMM
Computer Communication Review 37(4), 289–300 (2007)

11. Pass, R., Shi, E.: Fruitchains: A fair blockchain. In: Proceedings of the ACM Sym-

posium on Principles of Distributed Computing. pp. 315–324. ACM (2017)


