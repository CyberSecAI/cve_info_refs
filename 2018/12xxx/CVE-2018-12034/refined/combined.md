=== Content from github.com_ce306e4d_20250124_153213.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FVirusTotal%2Fyara%2Fissues%2F891)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FVirusTotal%2Fyara%2Fissues%2F891)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fissues_fragments%2Fissue_layout&source=header-repo&source_repo=VirusTotal%2Fyara)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[VirusTotal](/VirusTotal)
/
**[yara](/VirusTotal/yara)**
Public

* [Notifications](/login?return_to=%2FVirusTotal%2Fyara) You must be signed in to change notification settings
* [Fork
  1.5k](/login?return_to=%2FVirusTotal%2Fyara)
* [Star
   8.5k](/login?return_to=%2FVirusTotal%2Fyara)

* [Code](/VirusTotal/yara)
* [Issues
  152](/VirusTotal/yara/issues)
* [Pull requests
  23](/VirusTotal/yara/pulls)
* [Discussions](/VirusTotal/yara/discussions)
* [Actions](/VirusTotal/yara/actions)
* [Projects
  0](/VirusTotal/yara/projects)
* [Wiki](/VirusTotal/yara/wiki)
* [Security](/VirusTotal/yara/security)
* [Insights](/VirusTotal/yara/pulse)

Additional navigation options

* [Code](/VirusTotal/yara)
* [Issues](/VirusTotal/yara/issues)
* [Pull requests](/VirusTotal/yara/pulls)
* [Discussions](/VirusTotal/yara/discussions)
* [Actions](/VirusTotal/yara/actions)
* [Projects](/VirusTotal/yara/projects)
* [Wiki](/VirusTotal/yara/wiki)
* [Security](/VirusTotal/yara/security)
* [Insights](/VirusTotal/yara/pulse)

# Out-of-bounds read, write in yr\_execute\_code #891

[New issue](/login?return_to=)[Jump to bottom](#comment-composer-heading)Copy link[New issue](/login?return_to=)[Jump to bottom](#comment-composer-heading)Copy linkClosedClosed[Out-of-bounds read, write in yr\_execute\_code](#top)#891Copy link[![@bnbdr](https://avatars.githubusercontent.com/u/24456233?u=3d4362551f7037a14c5e121d5d9983c47054b89e&v=4&size=80)](/bnbdr)
## Description

[![@bnbdr](https://avatars.githubusercontent.com/u/24456233?u=3d4362551f7037a14c5e121d5d9983c47054b89e&v=4&size=48)](/bnbdr)[bnbdr](https://github.com/bnbdr)opened [on Jun 7, 2018](https://github.com/VirusTotal/yara/issues/891#issue-330463705)

`yr_execute_code` has several bugs in the implementation of the virtual machine. Two of which prove to be security issues that allow code execution by running a specially crafted binary rule:

* An out-of-bounds read in the opcode [OP\_PUSH\_M](https://github.com/VirusTotal/yara/blob/master/libyara/exec.c#L262)
* An out-of-bounds write in the opcode [OP\_POP\_M](https://github.com/VirusTotal/yara/blob/master/libyara/exec.c#L266).

These issues have been assigned the CVE-ID's `CVE-2018-12034` and `CVE-2018-12035`, respectively.

Obvious ways to mitigate this:

* checking every access to scratch memory
* require an explicit flag to load and run a compiled rule
* check every relocated address is within the loaded file
* make the loaded file read-only

While this might not be *as* critical as say, a vulnerability that can be exploited by a rule in source form, YARA will run a binary rule without explicitly being told to do so. This means any service/third-party who doesn't properly validate the user-supplied rule is susceptible.

I suggest you reject rules in binary form unless explicitly being allowed to do so.

For the ones interested, I've written a (very long) [write-up](https://bnbdr.github.io/posts/swisscheese/) and made the PoC exploit available [here](https://github.com/bnbdr/swisscheese)

## Metadata

### Assignees

No one assigned

### Labels

No labelsNo labels
### Type

No type
### Projects

No projects
### Milestone

No milestone

### Relationships

None yet
### Development

No branches or pull requests
## Issue actions

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from bnbdr.github.io_cf85b58f_20250124_153212.html ===
bnbdr[![](https://bnbdr.github.io/img/avatar.png)](https://bnbdr.github.io/)YARA Internals: Compiled Rule Format
and how to exploit The Pattern Matching Swiss KnifeJun 6, 2018
(updated: Dec 4, 2018)

* [#exploit](https://bnbdr.github.io/tags/exploit)
* [#write-up](https://bnbdr.github.io/tags/write-up)
* [#YARA](https://bnbdr.github.io/tags/yara)

### Cheese, Gromit

In this ~~short~~ incredibly lengthy post I’ll talk about the binary format of YARA rules and also a bit about exploiting two vulnerabilities I found in it.

![](calc.gif)

The two issues were assigned the CVE-IDs [CVE-2018-12034](//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-12034) and [CVE-2018-12035](//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-12035). They affect [YARA 3.7.1](//github.com/VirusTotal/yara/tree/v3.7.1) and earlier[1](#fn:9).

If you want to skip straight to the exploitation part, go to [WAT](#wat) or take a look at the [repo](//github.com/bnbdr/swisscheese).

I named this `SwissCheese` becuase I found it amusing that the “Pattern Matching Swiss *Knife*” had quite a few holes in it ;D

### Precompiling YARA rules

Most people who use it know that YARA accepts rule(s) and a target, and also that you can precompile[2](#fn:1) your rule if you care about “performance”. I was a bit curious about the precompiled part. How is my rule represented in its binary form? I took the simplest of rules:

```
rule empty {
    condition: true
}

```

and compiled to **~21KB** of, what exactly? I’ll come back to the size issue, so let’s take a look at the code first.

### Haystack, meet needle

As an aside, I have to commend the YARA developers for making the setup effortless - having a Visual Studio solution **that compiles** was a refreshing and welcome feeling.

However, trying to understand the file format wasn’t as straightforward. I didn’t want to understand everything YARA does, nor everything about the file format - the gist was enough.

A reasonable idea is to look for either the loading or packing of the file in order to understand the format.
That’s where ‘magic’ strings come into play. They often act like bookmarks- searching the code for the string either in reverse or not (depending on endianness, etc) will *usually* yield results:
![](empty_rule_hex.PNG)

* unpacking in yara32: `main -> yr_rules_load -> yr_rules_load_stream`
* packing in yarac32: `main -> yr_rules_save -> yr_rules_save_stream`

```
if (header.magic[0] != 'Y' ||
    header.magic[1] != 'A' ||
    header.magic[2] != 'R' ||
    header.magic[3] != 'A')
{
    return ERROR_INVALID_FILE;
}

```

I’ll be focusing on `yr_arena_load_stream` since it’s logically the same thing I’m trying to mimic.

### Off to a buggy start

The format, unsurprisingly, starts with a header containing a magic, version and size of the remaining file(kinda). After some basic yet buggy validation yara reads the body of the file and performs **relocations**. Yeah, apparently precompiling it mostly means dumping the memory-transient buffer to disk after converting absolute addresses to file offsets.

That meant the tail of the file (whatever’s left after the number written in the file header) was a relocation table. Yara then checks each offset if it actually requires patching:

* if the `QWORD` value in that offset was different than `0xFFFABADA` it should be patched
* Otherwise it should be set to `NULL`

*I’m not sure why it uses that magic instead of omitting that relocation from the table in the first place.*

To tell yara it’s reached the end of the table it uses a special marker: `0xFFFFFFFF`. Following it is another `DWORD` which is the calculated hash for the file.

### Hash whiplash

The hash isn’t very interesting[3](#fn:3). Yara first hashes the file header, then uses it as a seed to the hashing of the body. Note that the hashing is performed before the patching, because the ‘compiler’ obviously can’t predict the allocated address used for the file.

### I’m ready for you

Now that the buffer is all patched up, we can really get into it. Let’s jump to `yr_rules_load_stream` to see what’s going on with our newly relocated file body.

Thanks to some initialization and casting being done we can discern an additional chunk of the format:
It starts with a rule header, alligned to 8; I suppose it’s so the same precompiled rules would work on both 32 and 64 bit builds (sizeof(PVOID) etc), but I’m not sure why it’s all that important.

The macro `DECLARE_REFERENCE` basically makes everything a `QWORD`. All the members you see below that are not pointers are actually typedef’d to one:

```
typedef struct _YARA_RULES_FILE_HEADER
{
  DECLARE_REFERENCE(YR_RULE*, rules_list_head);
  DECLARE_REFERENCE(YR_EXTERNAL_VARIABLE*, externals_list_head);
  DECLARE_REFERENCE(const uint8_t*, code_start);
  DECLARE_REFERENCE(YR_AC_MATCH_TABLE, match_table);
  DECLARE_REFERENCE(YR_AC_TRANSITION_TABLE, transition_table);

} YARA_RULES_FILE_HEADER;

```

With the knowledge that every pointer shown above is actually present in the file as an offset(minus the size of the first header) is a great step forward. I’m slowly crawling my way through the file.

### I make the rules

The first member in our rule-header is a `fointer` (not a typo, stands for ‘File Pointer’; I will be using this from now on so deal with it) to a rule struct:

```
typedef struct _YR_RULE
{
  int32_t g_flags;               // Global flags
  int32_t t_flags[MAX_THREADS];  // Thread-specific flags

  DECLARE_REFERENCE(const char*, identifier);
  DECLARE_REFERENCE(const char*, tags);
  DECLARE_REFERENCE(YR_META*, metas);
  DECLARE_REFERENCE(YR_STRING*, strings);
  DECLARE_REFERENCE(YR_NAMESPACE*, ns);

  // Used only when PROFILING_ENABLED is defined
  clock_t clock_ticks;

} YR_RULE;

```

You should hastily recognize some `fointers` in the above struct as optional parts in a rule: `identifier`, `tags`, `metas`,`strings`, `namespace`. At this point I noticed the pattern and started copying all the relevant structs to my template[4](#fn:6). Every `fointer` that isn’t equal to `0xFFFABADA` means seeking to that position and parsing the struct there, ad infinitum.

In the case of our empy rule, which had no `tags`, `metas` or `strings`, only the `identifier` and `ns` members are of interest.

You’d be right to think *“hey, but what if we have more than one rule in our source file?”*. If you looked carefully at the member `rules_list_head` you’d guess that, going by its name, it points to the first rule. How does yara know where the other ones are? Let’s follow the code and see when the rules are actually being used, ignoring everything else for now:

`main -> yr_rules_scan_file -> yr_rules_scan_mem -> yr_rules_scan_mem_blocks : yr_rules_foreach`

Peeking at the macro, I figured two things:

* the rules are placed in sequantal order in the file
* the list of rules is terminated by a ‘null rule’

What’s a ‘null rule’?

```
#define RULE_IS_NULL(x) \
    (((x)->g_flags) & RULE_GFLAGS_NULL)

```

Searching for `RULE_GFLAGS_NULL` shows it’s being set in `_yr_compiler_compile_rules`, and also what those mysterious `0xFA` bytes were right after the first rule:

```
  // Write a null rule indicating the end.
  memset(&null_rule, 0xFA, sizeof(YR_RULE));
  null_rule.g_flags = RULE_GFLAGS_NULL;

```

![](mysterious_fa.png)

All that’s left to understand in the `YR_RULE` struct is `YR_NAMESPACE`. It’s quite short. The only thing of interest is the `fointer` to the namespace name, which when left unspecified is `default`:

```
typedef struct _YR_NAMESPACE
{
  int32_t t_flags[MAX_THREADS];     // Thread-specific flags
  DECLARE_REFERENCE(char*, name);

} YR_NAMESPACE;

```
### All about alignment

I’m sure you’ve been following along using your favorite hex-editor[5](#fn:2) and already know - all the `QWORD` members (and structs which contain them) should be aligned to an 8-byte boundry seeing that the file is practically a memory map.
Well, you’re right.

`DWORD`s filled with `0xCC` are a good sign for padding in this case. Do note that the file header is 12 bytes long, which means it messes up the alignment when viewed in a hex-editor.

### Null-spotting

Going back to `_yr_compiler_compile_rules`, I couldn’t help spotting that the compiler builds a ‘null external’ right after the ‘null rule’, in a similar fashion:

```
  // Write a null external the end.
  memset(&null_external, 0xFA, sizeof(YR_EXTERNAL_VARIABLE));
  null_external.type = EXTERNAL_VARIABLE_TYPE_NULL;

```

Since I didn’t specify any externals[6](#fn:4), the `externals_list_head` in the rule header should point to the ‘null external’, and be done with it. Keep in mind that unlike the ‘null rule’, this is marked by the `EXTERNAL_VARIABLE_TYPE_NULL` value, which equals 0.

### Ready, set, code

Right about here I reached the `code_start` `fointer` and forwent my initial interest in the file format. As a fan of virutal machines I was intrigued with the implementation details of the bytecode.

Searching for `code_start` in the entire solution quickly lands us in `yr_execute_code`, the proud owner of what can only be decribed as a ‘big-ass switch statement’:
![](grepcase.png)

Not unlike the rules/externals, yara keeps exeuting the bytecode until a special marker is reached. In this case the `OP_HALT`:

```
while(!stop)
{
  opcode = *ip;
  ip++;

  switch(opcode)
  {
    case OP_NOP:
      break;

    case OP_HALT:
      assert(sp == 0);
      stop = TRUE;
      break;

// ...truncated

```
### YARA’s virtual machine

This is a [stack based VM](https://en.wikipedia.org/wiki/Bytecode) with a scratch memory of 128 values.
In addition to bitwise, logical and arithmic operations there are several opcodes[7](#fn:5) specifically for the vm-stack, as well as the scratch memory.

The VM works with the `YR_VALUE` union. This way it grabs the appropriate type according to the opcode:

```
typedef union _YR_VALUE
{
  int64_t i;
  double d;
  void* p;
  struct _YR_OBJECT* o;
  YR_STRING* s;
  SIZED_STRING* ss;
  RE* re;

} YR_VALUE;

```

It’s good to note that since the union may represent a relocated `fointer`, every immediate in the bytecode has to be 64-bit long.

### Disassembly

I started implementing a small disassembler in my template according to the opcodes that were present in my empty rule from earlier. In hindsight I should’ve probably written something in python, but oh well.
These were the results:

```
OP_INIT_RULE
OP_PUSH
OP_INCR_M
OP_NOP
OP_HALT

```

* `OP_INIT_RULE` seemed a tad complex so I was content with skipping the implementation for the time being.
* `OP_PUSH` simply reads next `YR_VALUE` from the bytecode, and pushes it on the vm-stack
* `OP_INCR_M` increases the `YR_VALUE` in the scratch mem indexed by the next immediate

---

## WAT

All seems quite reasonab- wait, what?

```
case OP_INCR_M:
  r1.i = *(uint64_t*)(ip);
  ip += sizeof(uint64_t);
  mem[r1.i]++; // < ---------  WAT
  break;

```

It was quite a shock. I wasn’t expecting such a trivial security issue, but I had a hunch this wasn’t limited to that one opcode. Scanning through the other opcodes proved me right:

```
  case OP_PUSH_M:
    r1.i = *(uint64_t*)(ip);
    ip += sizeof(uint64_t);
    r1.i = mem[r1.i];           // Out-of-bounds Read
    push(r1);
    break;

  case OP_POP_M:
    r1.i = *(uint64_t*)(ip);
    ip += sizeof(uint64_t);
    pop(r2);
    mem[r1.i] = r2.i;           // Out-of-bounds Write
    break;

```

The scratch memory `mem` is placed on the the real stack which means one could easily use both opcodes to read stuff off the stack and write a ROP chain:

```
int yr_execute_code(
    YR_RULES* rules,
    YR_SCAN_CONTEXT* context,
    int timeout,
    time_t start_time)
{
  int64_t mem[MEM_SIZE];

  ...truncated

```
### Building a compiled rule

So the first thing I needed to do to test this thing out was to create a compiled rule with my hand-crafted yara assembly. This isn’t *that* difficult, all I need to do is:

* read a binary rule as a template
* follow the headers to the code\_start
* assemble new code
* inject new code
* update all the `fointers` that point after my code
* update the relocation table to the correct offsets
* remove the relocations that pointed to the old code so they won’t alter mine
* patch the file hash

I decided that building a rule from scratch would be easier, or at least less error prone.
The most basic test would be rebuilding the empty rule from before on my own.

### The size issue

I wanted to tackle the *humongous* file size at this point. It was a bit annoying and I thought of it as a good test for what I’ve learned so far.

Assuming yara doesn’t care where the `fointers` point as long as they point to valid data, I opted for placing my code at the end of the file body, which resulted in the following structure:

```
YR_HDR // file header

```
```
YARA_RULES_FILE_HEADER
YR_RULE
YR_RULE // null rule
YR_EXTERNAL_VARIABLE // null external
YR_NAMESPACE
CHAR[] namespace_name
CHAR[] rule_name
YR_AC_MATCH_TABLE
EMPTY_TRANSITION_TABLE

```
```
MY_CODE

```
```
RELOCATION_TABLE
END_OF_RELOCATION_MARKER
FILE_HASH

```

Thanks to the fact the relocation table only holds offsets that require relocations (none of that `0xFFFABADA` magic) the relocation table is much much smaller.

I didn’t cover the structs `YR_AC_MATCH_TABLE` and `EMPTY_TRANSITION_TABLE` until now. I’m pretty sure these are used for the [Aho-Corasick algorithm](https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm). I tried my best to ignore them.

### Getting there is half the fun

Sadly, before we get yara to execute our bytecode in `yr_execute_code`, we must pass through `_yr_rules_scan_mem_block` which uses the aforementioned Aho-Corasick structures:

```
uint16_t index;
uint32_t state = YR_AC_ROOT_STATE;
...

index = block_data[i++] + 1;  // <-- block_data is the scanned memory, we can't control it
transition = transition_table[state + index];   // <-- this is troublesome

while (YR_AC_INVALID_TRANSITION(transition, index))
{
  if (state != YR_AC_ROOT_STATE)
  {
    state = transition_table[state] >> 32;
    transition = transition_table[state + index];
  }
  else
  {
    transition = 0;
    break;
  }
}

state = transition >> 32;       // <-- we must make sure state remains 0
}

match = match_table[state].match; // <-- this is troublesome as well

```

In short: we can successfully execute this function as long as the `state` variable is kept at 0 and `transition` remains smaller than `MAX_UINT`.
`transition` is read from the `transition_table`, which apparently has `MAX_UBYTE+1` 64-bit entries.

To ascertain the above I have a full `EMPTY_TRANSITION_TABLE` filled with 0s, as well as one-entry `YR_AC_MATCH_TABLE` which is zero’d as well.

After all this I got a valid rule file that’s only **~3KB** in size.

### The great escape

Finally I can start working on exploiting the vulnerabilities. There are a few small caveats to keep in mind:

1. I can only read and write in 64 bit chunks
2. I can only read/write as offset from the stack
3. I don’t know where my bytecode is
4. I can’t overwrite a lot of the real stack due to arguments that are used during cleanup, before the function returns

The 4th caveat is the only real issue. `yr_modules_unload_all` is called during cleanup. The function uses `context->objects_table` and would crash if that pointer is overwritten because the `context` struct is allocated on the stack as well.

```
typedef struct _YR_SCAN_CONTEXT
{
  uint64_t  file_size;
  uint64_t  entry_point;

  int flags;
  int tidx;

  void* user_data;

  YR_MEMORY_BLOCK_ITERATOR*  iterator;
  YR_HASH_TABLE*  objects_table;    // <-- mustn't touch this
  YR_CALLBACK_FUNC  callback;

  YR_ARENA* matches_arena;
  YR_ARENA* matching_strings_arena;

} YR_SCAN_CONTEXT;

```

The pointer `context` itself doesn’t suffer from the same problem because the compiler saved it as a local and uses that when calling `yr_modules_unload_all`:
![](context_copy.png)

If I don’t want to find a gadget that skips that part of the stack (and perhaps even further back), I’ll have to fit my ROP-chain before that. That means I have 9 `QWORDS` at my disposal.

### I accept that challenge

To run calc (as one does) I had to go the usual route of `GetModuleHandleXXX` and `GetProcAddress`. This meant:

* calculating the current base address of the module
* perform the necessary relocation for each gadget offset
* organize the stack with the required arguments

#### Where art thou?

Reading the return address is possible using `OP_PUSH_M` with the right index.

There is only one\* function that calls `yr_execute_code`, so after the right shifts/bitwise-ands are performed
the base address can be calculated by using `OP_INT_SUB`.

Since the code is going to use that base address to relocate all the gadets, I’ll actually use the scratch memory as intended and save it for later use.

#### stdcall sure is nice

Thanks to the calling convention, I can set up some parts of the stack with the right arguments before the ROP even starts.

Immediate values were easy, the bytecode can use `OP_POP_M` to write them to the real stack.
However, in this instance I also needed to know the addresses of 3 strings:

1. `L"kernel32"` for `GetModuleHandleExW`
2. `"WinExec"` for `GetProcAddress`
3. `"calc"` for `WinExec`

#### YARA’s relocation to the rescue

If you haven’t forgotten, there was a pesky little feature in the file format - the relocation table. I can utilize it to relocate my bytecode operands to **absolute** addresses from relative file offsets.

All I need to do is have the offset to the string as my original value, and dump the string somewhere in the file (I chose to put them right after the code’s last instruction - `OP_HALT`)

### Silent but deadly

To make things much easier (*and allow me to fit the entire ROP in 9 contiguous `QWORDS`*) yara wraps the entire function with try/catch by default. Once WinExec returns it will jump to some address from the stack (ironically, to `context->objects_table`) and exit silently:

```
YR_TRYCATCH(
!(flags & SCAN_FLAGS_NO_TRYCATCH), /* <-- this flag is not set */
{
    result = yr_execute_code(
        rules,
        &context,
        timeout,
        start_time);
},{
    result = ERROR_COULD_NOT_MAP_FILE;
});

```
### Go go gadget(s)

I hand picked [these gadgets](//github.com/bnbdr/swisscheese/blob/master/gadgets.md) to fit my PoC. I used some of them more than once.
Some of these required changing values in the `yarasm` file.

---

## Attack vector

Any victim or service that allows running a user-supplied rule file without validating that it isn’t in binary format.

Validation is left to the user since, as of this writing, YARA does *not* distinguish between the two input formats and blindly accepts both[8](#fn:8).

This should work regardless of the target file scanned[9](#fn:7).

## Mitigations?

* checking every access to scratch memory
* require an explicit flag to load and run a compiled rule
* check that every relocated `fointer` does not point outside the buffer
* make the loaded file read-only

## \*\*\* update \*\*\*

For an in depth breakdown of YARA’s virtual machine and how the mitigations against this exploit can be bypassed go to [part II](../extracheese/).

## Notes

* this research was done on 32-bit yara 3.7.1, tested on binaries from the official [release page](//github.com/VirusTotal/yara/releases/tag/v3.7.1)
* This was disclosed privately before being published
* This is what I do in my spare time, don’t judge me

---

1. Follow the issue on [github](//github.com/VirusTotal/yara/issues/891)
   [↑](#fnref:9)
2. read about [YARA’s command line options](https://yara.readthedocs.io/en/v3.7.1/commandline.html)
   [↑](#fnref:1)
3. [YARA’s C implementation](//github.com/VirusTotal/yara/blob/v3.7.1/libyara/hash.c), [my python port](//github.com/bnbdr/swisscheese/blob/master/yara_hash.py)
   [↑](#fnref:3)
4. [my incomplete template](//github.com/bnbdr/swisscheese/blob/master/yara.bt)
   [↑](#fnref:6)
5. [010editor](https://www.sweetscape.com/010editor/)
   [↑](#fnref:2)
6. read about [externals in YARA](https://yara.readthedocs.io/en/v3.7.1/writingrules.html#external-variables)
   [↑](#fnref:4)
7. [YARA VM opcodes](//github.com/VirusTotal/yara/blob/v3.7.1/libyara/include/yara/exec.h)
   [↑](#fnref:5)
8. The only difference between the two use cases is `When invoking YARA with compiled rules a single file is accepted`. see [2](#fn:1)
   [↑](#fnref:8)
9. PoC worked on `Windows 10` when running against an executable or PID, it kinda works against a target directory
   [↑](#fnref:7)


=== Content from github.com_e2eaa41c_20250126_014459.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FVirusTotal%2Fyara%2Fblob%2Fmaster%2Flibyara%2Fexec.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FVirusTotal%2Fyara%2Fblob%2Fmaster%2Flibyara%2Fexec.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=VirusTotal%2Fyara)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[VirusTotal](/VirusTotal)
/
**[yara](/VirusTotal/yara)**
Public

* [Notifications](/login?return_to=%2FVirusTotal%2Fyara) You must be signed in to change notification settings
* [Fork
  1.5k](/login?return_to=%2FVirusTotal%2Fyara)
* [Star
   8.5k](/login?return_to=%2FVirusTotal%2Fyara)

* [Code](/VirusTotal/yara)
* [Issues
  152](/VirusTotal/yara/issues)
* [Pull requests
  23](/VirusTotal/yara/pulls)
* [Discussions](/VirusTotal/yara/discussions)
* [Actions](/VirusTotal/yara/actions)
* [Projects
  0](/VirusTotal/yara/projects)
* [Wiki](/VirusTotal/yara/wiki)
* [Security](/VirusTotal/yara/security)
* [Insights](/VirusTotal/yara/pulse)

Additional navigation options

* [Code](/VirusTotal/yara)
* [Issues](/VirusTotal/yara/issues)
* [Pull requests](/VirusTotal/yara/pulls)
* [Discussions](/VirusTotal/yara/discussions)
* [Actions](/VirusTotal/yara/actions)
* [Projects](/VirusTotal/yara/projects)
* [Wiki](/VirusTotal/yara/wiki)
* [Security](/VirusTotal/yara/security)
* [Insights](/VirusTotal/yara/pulse)

## Files

 master
## Breadcrumbs

1. [yara](/VirusTotal/yara/tree/master)
2. /[libyara](/VirusTotal/yara/tree/master/libyara)
/
# exec.c

Copy path Blame  Blame
## Latest commit

## History

[History](/VirusTotal/yara/commits/master/libyara/exec.c)2394 lines (2004 loc) · 63 KB master
## Breadcrumbs

1. [yara](/VirusTotal/yara/tree/master)
2. /[libyara](/VirusTotal/yara/tree/master/libyara)
/
# exec.c

Top
## File metadata and controls

* Code
* Blame

2394 lines (2004 loc) · 63 KB[Raw](https://github.com/VirusTotal/yara/raw/refs/heads/master/libyara/exec.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\*Copyright (c) 2013-2014. The YARA Authors. All Rights Reserved.
Redistribution and use in source and binary forms, with or without modification,are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice, thislist of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,this list of conditions and the following disclaimer in the documentation and/orother materials provided with the distribution.
3. Neither the name of the copyright holder nor the names of its contributorsmay be used to endorse or promote products derived from this software withoutspecific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" ANDANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIEDWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE AREDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FORANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ONANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THISSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\*/
#include <assert.h>#include <float.h>#include <math.h>#include <string.h>#include <yara.h>#include <yara/arena.h>#include <yara/endian.h>#include <yara/error.h>#include <yara/exec.h>#include <yara/globals.h>#include <yara/limits.h>#include <yara/mem.h>#include <yara/modules.h>#include <yara/object.h>#include <yara/re.h>#include <yara/sizedstr.h>#include <yara/stopwatch.h>#include <yara/strutils.h>#include <yara/unaligned.h>#include <yara/utils.h>
#define MEM\_SIZE YR\_MAX\_LOOP\_NESTING\*(YR\_MAX\_LOOP\_VARS + YR\_INTERNAL\_LOOP\_VARS)
#define push(x) \ if (stack.sp < stack.capacity) \ { \ stack.items[stack.sp++] = (x); \ } \ else \ { \ result = ERROR\_EXEC\_STACK\_OVERFLOW; \ stop = true; \ break; \ }
#define pop(x) \ { \ assert(stack.sp > 0); \ x = stack.items[--stack.sp]; \ }
#define is\_undef(x) IS\_UNDEFINED((x).i)
#define ensure\_defined(x) \ if (is\_undef(x)) \ { \ r1.i = YR\_UNDEFINED; \ push(r1); \ break; \ }
#define ensure\_within\_mem(x) \ if (x < 0 || x >= MEM\_SIZE) \ { \ stop = true; \ result = ERROR\_INTERNAL\_FATAL\_ERROR; \ break; \ }
// Make sure that the string pointer is within the rules arena.#define ensure\_within\_rules\_arena(x) \ { \ YR\_ARENA\_REF ref; \ if (yr\_arena\_ptr\_to\_ref(context->rules->arena, x, &ref) == 0) \ { \ stop = true; \ result = ERROR\_INTERNAL\_FATAL\_ERROR; \ break; \ } \ }
#define check\_object\_canary(o) \ if (o->canary != context->canary) \ { \ stop = true; \ result = ERROR\_INTERNAL\_FATAL\_ERROR; \ break; \ }
#define little\_endian\_uint8\_t(x) (x)#define little\_endian\_int8\_t(x) (x)#define little\_endian\_uint16\_t(x) yr\_le16toh(x)#define little\_endian\_int16\_t(x) yr\_le16toh(x)#define little\_endian\_uint32\_t(x) yr\_le32toh(x)#define little\_endian\_int32\_t(x) yr\_le32toh(x)
#define big\_endian\_uint8\_t(x) (x)#define big\_endian\_int8\_t(x) (x)#define big\_endian\_uint16\_t(x) yr\_be16toh(x)#define big\_endian\_int16\_t(x) yr\_be16toh(x)#define big\_endian\_uint32\_t(x) yr\_be32toh(x)#define big\_endian\_int32\_t(x) yr\_be32toh(x)
#define function\_read(type, endianess) \ int64\_t read\_##type##\_##endianess( \ YR\_MEMORY\_BLOCK\_ITERATOR\* iterator, size\_t offset) \ { \ YR\_MEMORY\_BLOCK\* block = iterator->first(iterator); \ while (block != NULL) \ { \ if (offset >= block->base && block->size >= sizeof(type) && \ offset <= block->base + block->size - sizeof(type)) \ { \ type result; \ const uint8\_t\* data = yr\_fetch\_block\_data(block); \ if (data == NULL) \ return YR\_UNDEFINED; \ result = \*(type\*) (data + offset - block->base); \ result = endianess##\_##type(result); \ return result; \ } \ block = iterator->next(iterator); \ } \ return YR\_UNDEFINED; \ };
function\_read(uint8\_t, little\_endian);function\_read(uint16\_t, little\_endian);function\_read(uint32\_t, little\_endian);function\_read(int8\_t, little\_endian);function\_read(int16\_t, little\_endian);function\_read(int32\_t, little\_endian);function\_read(uint8\_t, big\_endian);function\_read(uint16\_t, big\_endian);function\_read(uint32\_t, big\_endian);function\_read(int8\_t, big\_endian);function\_read(int16\_t, big\_endian);function\_read(int32\_t, big\_endian);
static const uint8\_t\* jmp\_if(int condition, const uint8\_t\* ip){ int32\_t off = 0;
 if (condition) { // The condition is true, the instruction pointer (ip) is incremented in // the amount specified by the jump's offset, which is a int32\_t following // the jump opcode. The ip is currently past the opcode and pointing to // the offset.
 // Copy the offset from the instruction stream to a local variable. off = yr\_unaligned\_u32(ip);
 // The offset is relative to the jump opcode, but now the ip is one byte // past the opcode, so we need to decrement it by one. off -= 1; } else { // The condition is false, the execution flow proceeds with the instruction // right after the jump. off = sizeof(int32\_t); }
 return ip + off;}
static int iter\_array\_next(YR\_ITERATOR\* self, YR\_VALUE\_STACK\* stack){ // Check that there's two available slots in the stack, one for the next // item returned by the iterator and another one for the boolean that // indicates if there are more items. if (stack->sp + 1 >= stack->capacity) return ERROR\_EXEC\_STACK\_OVERFLOW;
 // If the array that must be iterated is undefined stop the iteration right // aways, as if the array would be empty. if (IS\_UNDEFINED(self->array\_it.array)) goto \_stop\_iter;
 // If the current index is equal or larger than array's length the iterator // has reached the end of the array. if (self->array\_it.index >= yr\_object\_array\_length(self->array\_it.array)) goto \_stop\_iter;
 // Push the false value that indicates that the iterator is not exhausted. stack->items[stack->sp++].i = 0;
 YR\_OBJECT\* obj = yr\_object\_array\_get\_item( self->array\_it.array, 0, self->array\_it.index);
 if (obj != NULL) stack->items[stack->sp++].o = obj; else stack->items[stack->sp++].i = YR\_UNDEFINED;
 self->array\_it.index++;
 return ERROR\_SUCCESS;
\_stop\_iter:
 // Push true for indicating the iterator has been exhausted. stack->items[stack->sp++].i = 1; // Push YR\_UNDEFINED as a placeholder for the next item. stack->items[stack->sp++].i = YR\_UNDEFINED;
 return ERROR\_SUCCESS;}
static int iter\_dict\_next(YR\_ITERATOR\* self, YR\_VALUE\_STACK\* stack){ // Check that there's three available slots in the stack, two for the next // item returned by the iterator and its key, and another one for the boolean // that indicates if there are more items. if (stack->sp + 2 >= stack->capacity) return ERROR\_EXEC\_STACK\_OVERFLOW;
 // If the dictionary that must be iterated is undefined, stop the iteration // right away, as if the dictionary would be empty. if (IS\_UNDEFINED(self->dict\_it.dict)) goto \_stop\_iter;
 YR\_DICTIONARY\_ITEMS\* items = object\_as\_dictionary(self->dict\_it.dict)->items;
 // If the dictionary has no items or the iterator reached the last item, abort // the iteration, if not push the next key and value. if (items == NULL || self->dict\_it.index == items->used) goto \_stop\_iter;
 // Push the false value that indicates that the iterator is not exhausted. stack->items[stack->sp++].i = 0;
 if (items->objects[self->dict\_it.index].obj != NULL) { stack->items[stack->sp++].o = items->objects[self->dict\_it.index].obj; stack->items[stack->sp++].p = items->objects[self->dict\_it.index].key; } else { stack->items[stack->sp++].i = YR\_UNDEFINED; stack->items[stack->sp++].i = YR\_UNDEFINED; }
 self->dict\_it.index++;
 return ERROR\_SUCCESS;
\_stop\_iter:
 // Push true for indicating the iterator has been exhausted. stack->items[stack->sp++].i = 1; // Push YR\_UNDEFINED as a placeholder for the next key and value. stack->items[stack->sp++].i = YR\_UNDEFINED; stack->items[stack->sp++].i = YR\_UNDEFINED;
 return ERROR\_SUCCESS;}
static int iter\_int\_range\_next(YR\_ITERATOR\* self, YR\_VALUE\_STACK\* stack){ // Check that there's two available slots in the stack, one for the next // item returned by the iterator and another one for the boolean that // indicates if there are more items. if (stack->sp + 1 >= stack->capacity) return ERROR\_EXEC\_STACK\_OVERFLOW;
 if (!IS\_UNDEFINED(self->int\_range\_it.next) && !IS\_UNDEFINED(self->int\_range\_it.last) && self->int\_range\_it.next <= self->int\_range\_it.last) { // Push the false value that indicates that the iterator is not exhausted. stack->items[stack->sp++].i = 0; stack->items[stack->sp++].i = self->int\_range\_it.next; self->int\_range\_it.next++; } else { // Push true for indicating the iterator has been exhausted. stack->items[stack->sp++].i = 1; // Push YR\_UNDEFINED as a placeholder for the next item. stack->items[stack->sp++].i = YR\_UNDEFINED; }
 return ERROR\_SUCCESS;}
static int iter\_int\_enum\_next(YR\_ITERATOR\* self, YR\_VALUE\_STACK\* stack){ // Check that there's two available slots in the stack, one for the next // item returned by the iterator and another one for the boolean that // indicates if there are more items. if (stack->sp + 1 >= stack->capacity) return ERROR\_EXEC\_STACK\_OVERFLOW;
 if (!IS\_UNDEFINED(self->int\_enum\_it.next) && !IS\_UNDEFINED(self->int\_enum\_it.count) && self->int\_enum\_it.next < self->int\_enum\_it.count) { // Push the false value that indicates that the iterator is not exhausted. stack->items[stack->sp++].i = 0; stack->items[stack->sp++].i = self->int\_enum\_it.items[self->int\_enum\_it.next]; self->int\_enum\_it.next++; } else { // Push true for indicating the iterator has been exhausted. stack->items[stack->sp++].i = 1; // Push YR\_UNDEFINED as a placeholder for the next item. stack->items[stack->sp++].i = YR\_UNDEFINED; }
 return ERROR\_SUCCESS;}
static int iter\_string\_set\_next(YR\_ITERATOR\* self, YR\_VALUE\_STACK\* stack){ // Check that there's two available slots in the stack, one for the next // item returned by the iterator and another one for the boolean that // indicates if there are more items. if (stack->sp + 1 >= stack->capacity) return ERROR\_EXEC\_STACK\_OVERFLOW;
 // If the current index is equal or larger than array's length the iterator // has reached the end of the array. if (self->string\_set\_it.index >= self->string\_set\_it.count) goto \_stop\_iter;
 // Push the false value that indicates that the iterator is not exhausted. stack->items[stack->sp++].i = 0; stack->items[stack->sp++].s = self->string\_set\_it.strings[self->string\_set\_it.index]; self->string\_set\_it.index++;
 return ERROR\_SUCCESS;
\_stop\_iter:
 // Push true for indicating the iterator has been exhausted. stack->items[stack->sp++].i = 1; // Push YR\_UNDEFINED as a placeholder for the next item. stack->items[stack->sp++].i = YR\_UNDEFINED;
 return ERROR\_SUCCESS;}
static int iter\_text\_string\_set\_next(YR\_ITERATOR\* self, YR\_VALUE\_STACK\* stack){ // Check that there's two available slots in the stack, one for the next // item returned by the iterator and another one for the boolean that // indicates if there are more items. if (stack->sp + 1 >= stack->capacity) return ERROR\_EXEC\_STACK\_OVERFLOW;
 // If the current index is equal or larger than array's length the iterator // has reached the end of the array. if (self->text\_string\_set\_it.index >= self->text\_string\_set\_it.count) goto \_stop\_iter;
 // Push the false value that indicates that the iterator is not exhausted. stack->items[stack->sp++].i = 0; stack->items[stack->sp++].ss = self->text\_string\_set\_it.strings[self->text\_string\_set\_it.index]; self->text\_string\_set\_it.index++;
 return ERROR\_SUCCESS;
\_stop\_iter:
 // Push true for indicating the iterator has been exhausted. stack->items[stack->sp++].i = 1; // Push YR\_UNDEFINED as a placeholder for the next item. stack->items[stack->sp++].i = YR\_UNDEFINED;
 return ERROR\_SUCCESS;}
// Global table that contains the "next" function for different types of// iterators. The reason for using this table is to avoid storing pointers// in the YARA's VM stack. Instead of the pointers we store an index within// this table.static YR\_ITERATOR\_NEXT\_FUNC iter\_next\_func\_table[] = { iter\_array\_next, iter\_dict\_next, iter\_int\_range\_next, iter\_int\_enum\_next, iter\_string\_set\_next, iter\_text\_string\_set\_next,};
#define ITER\_NEXT\_ARRAY 0#define ITER\_NEXT\_DICT 1#define ITER\_NEXT\_INT\_RANGE 2#define ITER\_NEXT\_INT\_ENUM 3#define ITER\_NEXT\_STRING\_SET 4#define ITER\_NEXT\_TEXT\_STRING\_SET 5
int yr\_execute\_code(YR\_SCAN\_CONTEXT\* context){ YR\_DEBUG\_FPRINTF(2, stderr, "+ %s() {\n", \_\_FUNCTION\_\_);
 const uint8\_t\* ip = context->rules->code\_start;
 YR\_VALUE mem[MEM\_SIZE]; YR\_VALUE args[YR\_MAX\_FUNCTION\_ARGS]; YR\_VALUE r1; YR\_VALUE r2; YR\_VALUE r3; YR\_VALUE r4;
 YR\_VALUE\_STACK stack;
 uint64\_t elapsed\_time;
#ifdef YR\_PROFILING\_ENABLED uint64\_t start\_time;#endif
 uint32\_t current\_rule\_idx = 0; YR\_RULE\* current\_rule = NULL; YR\_RULE\* rule; YR\_MATCH\* match; YR\_OBJECT\_FUNCTION\* function; YR\_OBJECT\*\* obj\_ptr; YR\_ARENA\* obj\_arena; YR\_NOTEBOOK\* it\_notebook;
 char\* identifier; char\* args\_fmt;
 int found; int count; int result = ERROR\_SUCCESS; int cycle = 0; int obj\_count = 0;
 bool stop = false;
 uint8\_t opcode;
 yr\_get\_configuration\_uint32(YR\_CONFIG\_STACK\_SIZE, &stack.capacity);
 stack.sp = 0; stack.items = (YR\_VALUE\*) yr\_malloc(stack.capacity \* sizeof(YR\_VALUE));
 if (stack.items == NULL) return ERROR\_INSUFFICIENT\_MEMORY;
 FAIL\_ON\_ERROR\_WITH\_CLEANUP( yr\_arena\_create(1, 512 \* sizeof(YR\_OBJECT\*), &obj\_arena), yr\_free(stack.items));
 FAIL\_ON\_ERROR\_WITH\_CLEANUP( yr\_notebook\_create(512 \* sizeof(YR\_ITERATOR), &it\_notebook), yr\_arena\_release(obj\_arena); yr\_free(stack.items));
#ifdef YR\_PROFILING\_ENABLED start\_time = yr\_stopwatch\_elapsed\_ns(&context->stopwatch);#endif
#if YR\_PARANOID\_EXEC memset(mem, 0, MEM\_SIZE \* sizeof(mem[0]));#endif
 while (!stop) { // Read the opcode from the address indicated by the instruction pointer. opcode = \*ip;
 // Advance the instruction pointer, which now points past the opcode. ip++;
 switch (opcode) { case OP\_NOP: YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_NOP: // %s()\n", \_\_FUNCTION\_\_); break;
 case OP\_HALT: YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_HALT: // %s()\n", \_\_FUNCTION\_\_); assert(stack.sp == 0); // When HALT is reached the stack should be empty. stop = true; break;
 case OP\_ITER\_START\_ARRAY: YR\_DEBUG\_FPRINTF( 2, stderr, "- case OP\_ITER\_START\_ARRAY: // %s()\n", \_\_FUNCTION\_\_); r2.p = yr\_notebook\_alloc(it\_notebook, sizeof(YR\_ITERATOR));
 if (r2.p == NULL) { result = ERROR\_INSUFFICIENT\_MEMORY; } else { pop(r1); r2.it->array\_it.array = r1.o; r2.it->array\_it.index = 0; r2.it->next\_func\_idx = ITER\_NEXT\_ARRAY; push(r2); }
 stop = (result != ERROR\_SUCCESS); break;
 case OP\_ITER\_START\_DICT: YR\_DEBUG\_FPRINTF( 2, stderr, "- case OP\_ITER\_START\_DICT: // %s()\n", \_\_FUNCTION\_\_); r2.p = yr\_notebook\_alloc(it\_notebook, sizeof(YR\_ITERATOR));
 if (r2.p == NULL) { result = ERROR\_INSUFFICIENT\_MEMORY; } else { pop(r1); r2.it->dict\_it.dict = r1.o; r2.it->dict\_it.index = 0; r2.it->next\_func\_idx = ITER\_NEXT\_DICT; push(r2); }
 stop = (result != ERROR\_SUCCESS); break;
 case OP\_ITER\_START\_INT\_RANGE: YR\_DEBUG\_FPRINTF( 2, stderr, "- case OP\_ITER\_START\_INT\_RANGE: // %s()\n", \_\_FUNCTION\_\_); // Creates an iterator for an integer range. The higher bound of the // range is at the top of the stack followed by the lower bound. r3.p = yr\_notebook\_alloc(it\_notebook, sizeof(YR\_ITERATOR));
 if (r3.p == NULL) { result = ERROR\_INSUFFICIENT\_MEMORY; } else { pop(r2); pop(r1); r3.it->int\_range\_it.next = r1.i; r3.it->int\_range\_it.last = r2.i; r3.it->next\_func\_idx = ITER\_NEXT\_INT\_RANGE; push(r3); }
 stop = (result != ERROR\_SUCCESS); break;
 case OP\_ITER\_START\_INT\_ENUM: YR\_DEBUG\_FPRINTF( 2, stderr, "- case OP\_ITER\_START\_INT\_ENUM: // %s()\n", \_\_FUNCTION\_\_); // Creates an iterator for an integer enumeration. The number of items // in the enumeration is at the top of the stack, followed by the // items in reverse order. pop(r1);
 r3.p = yr\_notebook\_alloc( it\_notebook, sizeof(YR\_ITERATOR) + sizeof(uint64\_t) \* (size\_t) r1.i);
 if (r3.p == NULL) { result = ERROR\_INSUFFICIENT\_MEMORY; } else { r3.it->int\_enum\_it.count = r1.i; r3.it->int\_enum\_it.next = 0; r3.it->next\_func\_idx = ITER\_NEXT\_INT\_ENUM;
 for (int64\_t i = r1.i; i > 0; i--) { pop(r2); r3.it->int\_enum\_it.items[i - 1] = r2.i; }
 push(r3); }
 stop = (result != ERROR\_SUCCESS); break;
 case OP\_ITER\_START\_STRING\_SET: YR\_DEBUG\_FPRINTF( 2, stderr, "- case OP\_ITER\_START\_STRING\_SET: // %s()\n", \_\_FUNCTION\_\_);
 pop(r1);
 r3.p = yr\_notebook\_alloc( it\_notebook, sizeof(YR\_ITERATOR) + sizeof(YR\_STRING\*) \* (size\_t) r1.i);
 if (r3.p == NULL) { result = ERROR\_INSUFFICIENT\_MEMORY; } else { r3.it->string\_set\_it.count = r1.i; r3.it->string\_set\_it.index = 0; r3.it->next\_func\_idx = ITER\_NEXT\_STRING\_SET;
 for (int64\_t i = r1.i; i > 0; i--) { pop(r2); r3.it->string\_set\_it.strings[i - 1] = r2.s; }
 // One last pop of the UNDEFINED string pop(r2); push(r3); }
 stop = (result != ERROR\_SUCCESS); break;
 case OP\_ITER\_START\_TEXT\_STRING\_SET: YR\_DEBUG\_FPRINTF( 2, stderr, "- case OP\_ITER\_START\_TEXT\_STRING\_SET: // %s()\n", \_\_FUNCTION\_\_);
 pop(r1);
 r3.p = yr\_notebook\_alloc( it\_notebook, sizeof(YR\_ITERATOR) + sizeof(SIZED\_STRING\*) \* (size\_t) r1.i);
 if (r3.p == NULL) { result = ERROR\_INSUFFICIENT\_MEMORY; } else { r3.it->text\_string\_set\_it.count = r1.i; r3.it->text\_string\_set\_it.index = 0; r3.it->next\_func\_idx = ITER\_NEXT\_TEXT\_STRING\_SET;
 for (int64\_t i = r1.i; i > 0; i--) { pop(r2); r3.it->text\_string\_set\_it.strings[i - 1] = r2.ss; }
 push(r3); }
 stop = (result != ERROR\_SUCCESS); break;
 case OP\_ITER\_NEXT: YR\_DEBUG\_FPRINTF( 2, stderr, "- case OP\_ITER\_NEXT: // %s()\n", \_\_FUNCTION\_\_); // Loads the iterator in r1, but leaves the iterator in the stack. pop(r1); push(r1);
 if (r1.it->next\_func\_idx < sizeof(iter\_next\_func\_table) / sizeof(YR\_ITERATOR\_NEXT\_FUNC)) { // The iterator's next function is responsible for pushing the next // item in the stack, and a boolean indicating if there are more items // to retrieve. The boolean will be at the top of the stack after // calling "next". result = iter\_next\_func\_table[r1.it->next\_func\_idx](r1.it, &stack); } else { // next\_func\_idx is outside the valid range, this should not happend. result = ERROR\_INTERNAL\_FATAL\_ERROR; }
 stop = (result != ERROR\_SUCCESS); break;
 case OP\_ITER\_CONDITION: YR\_DEBUG\_FPRINTF( 2, stderr, "- case OP\_ITER\_CONDITION: // %s()\n", \_\_FUNCTION\_\_);
 // Evaluate the iteration condition of the loop. This instruction // evaluates to 1 if the loop should continue and 0 if it shouldn't // (due to short-circuit evaluation).
 pop(r2); // min. expression - all, any, none, integer pop(r3); // number of true expressions pop(r4); // last expression result
 // In case of 'all' loop, end once we the body failed if (is\_undef(r2)) { r1.i = r4.i != 0 ? 1 : 0; } // In case of 'none' loop, end once the body succeed else if (r2.i == 0) { r1.i = r4.i != 1 ? 1 : 0; } // In case of other loops, end once we satified min. expr. else { r1.i = r3.i + r4.i < r2.i ? 1 : 0; }
 // Push whether loop should continue and repush // the last expression result push(r1); push(r4); break;
 case OP\_ITER\_END: YR\_DEBUG\_FPRINTF( 2, stderr, "- case OP\_ITER\_END: // %s()\n", \_\_FUNCTION\_\_);
 // Evaluate the whole loop. Whether it was successful or not // and whether it satisfied it's quantifier.
 pop(r2); // min. expression - all, any, none, integer pop(r3); // number of true expressions pop(r4); // number of total iterations
 // If there was 0 iterations in total, it doesn't // matter what other numbers show. We can't evaluate // the loop as true. if (r4.i == 0) { r1.i = 0; } else if (is\_undef(r2)) { r1.i = r3.i == r4.i ? 1 : 0; } else if (r2.i == 0) { r1.i = r3.i == 0 ? 1 : 0; } else { r1.i = r3.i >= r2.i ? 1 : 0; }
 push(r1); break;
 case OP\_PUSH: YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_PUSH: // %s()\n", \_\_FUNCTION\_\_); r1.i = yr\_unaligned\_u64(ip); ip += sizeof(uint64\_t); push(r1); break;
 case OP\_PUSH\_8: r1.i = \*ip; YR\_DEBUG\_FPRINTF( 2, stderr, "- case OP\_PUSH\_8: r1.i=%" PRId64 " // %s()\n", r1.i, \_\_FUNCTION\_\_); ip += sizeof(uint8\_t); push(r1); break;
 case OP\_PUSH\_16: r1.i = yr\_unaligned\_u16(ip); YR\_DEBUG\_FPRINTF( 2, stderr, "- case OP\_PUSH\_16: r1.i=%" PRId64 " // %s()\n", r1.i, \_\_FUNCTION\_\_); ip += sizeof(uint16\_t); push(r1); break;
 case OP\_PUSH\_32: r1.i = yr\_unaligned\_u32(ip); YR\_DEBUG\_FPRINTF( 2, stderr, "- case OP\_PUSH\_32: r1.i=%" PRId64 " // %s()\n", r1.i, \_\_FUNCTION\_\_); ip += sizeof(uint32\_t); push(r1); break;
 case OP\_PUSH\_U: YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_PUSH\_U: // %s()\n", \_\_FUNCTION\_\_); r1.i = YR\_UNDEFINED; push(r1); break;
 case OP\_POP: YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_POP: // %s()\n", \_\_FUNCTION\_\_); pop(r1); break;
 case OP\_CLEAR\_M: YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_CLEAR\_M: // %s()\n", \_\_FUNCTION\_\_); r1.i = yr\_unaligned\_u64(ip); ip += sizeof(uint64\_t);#if YR\_PARANOID\_EXEC ensure\_within\_mem(r1.i);#endif mem[r1.i].i = 0; break;
 case OP\_ADD\_M: YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_ADD\_M: // %s()\n", \_\_FUNCTION\_\_); r1.i = yr\_unaligned\_u64(ip); ip += sizeof(uint64\_t);#if YR\_PARANOID\_EXEC ensure\_within\_mem(r1.i);#endif pop(r2); if (!is\_undef(r2)) mem[r1.i].i += r2.i; break;
 case OP\_INCR\_M: YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_INCR\_M: // %s()\n", \_\_FUNCTION\_\_); r1.i = yr\_unaligned\_u64(ip); ip += sizeof(uint64\_t);#if YR\_PARANOID\_EXEC ensure\_within\_mem(r1.i);#endif mem[r1.i].i++; break;
 case OP\_PUSH\_M: YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_PUSH\_M: // %s()\n", \_\_FUNCTION\_\_); r1.i = yr\_unaligned\_u64(ip); ip += sizeof(uint64\_t);#if YR\_PARANOID\_EXEC ensure\_within\_mem(r1.i);#endif r1 = mem[r1.i]; push(r1); break;
 case OP\_POP\_M: YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_POP\_M: // %s()\n", \_\_FUNCTION\_\_); r1.i = yr\_unaligned\_u64(ip); ip += sizeof(uint64\_t);#if YR\_PARANOID\_EXEC ensure\_within\_mem(r1.i);#endif pop(r2); mem[r1.i] = r2; break;
 case OP\_SET\_M: YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_SET\_M: // %s()\n", \_\_FUNCTION\_\_); r1.i = yr\_unaligned\_u64(ip); ip += sizeof(uint64\_t);#if YR\_PARANOID\_EXEC ensure\_within\_mem(r1.i);#endif pop(r2); push(r2); if (!is\_undef(r2)) mem[r1.i] = r2; break;
 case OP\_SWAPUNDEF: YR\_DEBUG\_FPRINTF( 2, stderr, "- case OP\_SWAPUNDEF: // %s()\n", \_\_FUNCTION\_\_); r1.i = yr\_unaligned\_u64(ip); ip += sizeof(uint64\_t);#if YR\_PARANOID\_EXEC ensure\_within\_mem(r1.i);#endif pop(r2);
 if (is\_undef(r2)) { r1 = mem[r1.i]; push(r1); } else { push(r2); } break;
 case OP\_JNUNDEF: // Jump if the top the stack is not undefined without modifying the stack. YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_JNUNDEF: // %s()\n", \_\_FUNCTION\_\_); pop(r1); push(r1); ip = jmp\_if(!is\_undef(r1), ip); break;
 case OP\_JUNDEF\_P: // Removes a value from the top of the stack and jump if the value is not // undefined. YR\_DEBUG\_FPRINTF( 2, stderr, "- case OP\_JUNDEF\_P: // %s()\n", \_\_FUNCTION\_\_); pop(r1); ip = jmp\_if(is\_undef(r1), ip); break;
 case OP\_JL\_P: // Pops two values A and B from the stack and jump if A < B. B is popped // first, and then A. YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_JL\_P: // %s()\n", \_\_FUNCTION\_\_); pop(r2); pop(r1); ip = jmp\_if(r1.i < r2.i, ip); break;
 case OP\_JLE\_P: // Pops two values A and B from the stack and jump if A <= B. B is popped // first, and then A. YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_JLE\_P: // %s()\n", \_\_FUNCTION\_\_); pop(r2); pop(r1); ip = jmp\_if(r1.i <= r2.i, ip); break;
 case OP\_JTRUE: // Jump if the top of the stack is true without modifying the stack. If // the top of the stack is undefined the jump is not taken. YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_JTRUE: // %s()\n", \_\_FUNCTION\_\_); pop(r1); push(r1); ip = jmp\_if(!is\_undef(r1) && r1.i, ip); break;
 case OP\_JTRUE\_P: // Removes a value from the stack and jump if it is true. If the value // is undefined the jump is not taken. YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_JTRUE\_P: // %s()\n", \_\_FUNCTION\_\_); pop(r1); ip = jmp\_if(!is\_undef(r1) && r1.i, ip); break;
 case OP\_JFALSE: // Jump if the top of the stack is false without modifying the stack. If // the top of the stack is undefined the jump is not taken. YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_JFALSE: // %s()\n", \_\_FUNCTION\_\_); pop(r1); push(r1); ip = jmp\_if(!is\_undef(r1) && !r1.i, ip); break;
 case OP\_JFALSE\_P: // Removes a value from the stack and jump if it is false. If the value // is undefined the jump is not taken. YR\_DEBUG\_FPRINTF( 2, stderr, "- case OP\_JFALSE\_P: // %s()\n", \_\_FUNCTION\_\_); pop(r1); ip = jmp\_if(!is\_undef(r1) && !r1.i, ip); break;
 case OP\_JZ: // Jump if the value at the top of the stack is 0 without modifying the // stack. YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_JZ: // %s()\n", \_\_FUNCTION\_\_); pop(r1); push(r1); ip = jmp\_if(r1.i == 0, ip); break;
 case OP\_JZ\_P: // Removes a value from the stack and jump if the value is 0. YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_JZ\_P: // %s()\n", \_\_FUNCTION\_\_); pop(r1); ip = jmp\_if(r1.i == 0, ip); break;
 case OP\_AND: YR\_DEBUG\_FPRINTF(2, stderr, "- case OP\_AND: // %s()\n", \_\_FUNCTION\_\_); pop(r2);[View remainder of file in raw view](https://github.com/VirusTotal/yara/raw/refs/heads/master/libyara/exec.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_95fb64c6_20250124_153214.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fbnbdr%2Fswisscheese)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fbnbdr%2Fswisscheese)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E&source=header-repo&source_repo=bnbdr%2Fswisscheese)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[bnbdr](/bnbdr)
/
**[swisscheese](/bnbdr/swisscheese)**
Public

* [Notifications](/login?return_to=%2Fbnbdr%2Fswisscheese) You must be signed in to change notification settings
* [Fork
  4](/login?return_to=%2Fbnbdr%2Fswisscheese)
* [Star
   30](/login?return_to=%2Fbnbdr%2Fswisscheese)

Exploits for YARA 3.7.1 & 3.8.1

[bnbdr.github.io/posts/extracheese/](https://bnbdr.github.io/posts/extracheese/ "https://bnbdr.github.io/posts/extracheese/")

[30
stars](/bnbdr/swisscheese/stargazers) [4
forks](/bnbdr/swisscheese/forks) [Branches](/bnbdr/swisscheese/branches) [Tags](/bnbdr/swisscheese/tags) [Activity](/bnbdr/swisscheese/activity)
 [Star](/login?return_to=%2Fbnbdr%2Fswisscheese)

 [Notifications](/login?return_to=%2Fbnbdr%2Fswisscheese) You must be signed in to change notification settings

* [Code](/bnbdr/swisscheese)
* [Issues
  0](/bnbdr/swisscheese/issues)
* [Pull requests
  0](/bnbdr/swisscheese/pulls)
* [Actions](/bnbdr/swisscheese/actions)
* [Projects
  0](/bnbdr/swisscheese/projects)
* [Security](/bnbdr/swisscheese/security)
* [Insights](/bnbdr/swisscheese/pulse)

Additional navigation options

* [Code](/bnbdr/swisscheese)
* [Issues](/bnbdr/swisscheese/issues)
* [Pull requests](/bnbdr/swisscheese/pulls)
* [Actions](/bnbdr/swisscheese/actions)
* [Projects](/bnbdr/swisscheese/projects)
* [Security](/bnbdr/swisscheese/security)
* [Insights](/bnbdr/swisscheese/pulse)

# bnbdr/swisscheese

    master[Branches](/bnbdr/swisscheese/branches)[Tags](/bnbdr/swisscheese/tags)Go to fileCode
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| Latest commit History[5 Commits](/bnbdr/swisscheese/commits/master/) | | |
| [yarasm-syntax](/bnbdr/swisscheese/tree/master/yarasm-syntax "yarasm-syntax") | | [yarasm-syntax](/bnbdr/swisscheese/tree/master/yarasm-syntax "yarasm-syntax") |  |  |
| [.gitignore](/bnbdr/swisscheese/blob/master/.gitignore ".gitignore") | | [.gitignore](/bnbdr/swisscheese/blob/master/.gitignore ".gitignore") |  |  |
| [README.md](/bnbdr/swisscheese/blob/master/README.md "README.md") | | [README.md](/bnbdr/swisscheese/blob/master/README.md "README.md") |  |  |
| [assembler.py](/bnbdr/swisscheese/blob/master/assembler.py "assembler.py") | | [assembler.py](/bnbdr/swisscheese/blob/master/assembler.py "assembler.py") |  |  |
| [build.py](/bnbdr/swisscheese/blob/master/build.py "build.py") | | [build.py](/bnbdr/swisscheese/blob/master/build.py "build.py") |  |  |
| [example.gif](/bnbdr/swisscheese/blob/master/example.gif "example.gif") | | [example.gif](/bnbdr/swisscheese/blob/master/example.gif "example.gif") |  |  |
| [example2.gif](/bnbdr/swisscheese/blob/master/example2.gif "example2.gif") | | [example2.gif](/bnbdr/swisscheese/blob/master/example2.gif "example2.gif") |  |  |
| [extracheese.rule](/bnbdr/swisscheese/blob/master/extracheese.rule "extracheese.rule") | | [extracheese.rule](/bnbdr/swisscheese/blob/master/extracheese.rule "extracheese.rule") |  |  |
| [extracheese.yarasm](/bnbdr/swisscheese/blob/master/extracheese.yarasm "extracheese.yarasm") | | [extracheese.yarasm](/bnbdr/swisscheese/blob/master/extracheese.yarasm "extracheese.yarasm") |  |  |
| [gadgets.md](/bnbdr/swisscheese/blob/master/gadgets.md "gadgets.md") | | [gadgets.md](/bnbdr/swisscheese/blob/master/gadgets.md "gadgets.md") |  |  |
| [op\_offset\_poc.rule](/bnbdr/swisscheese/blob/master/op_offset_poc.rule "op_offset_poc.rule") | | [op\_offset\_poc.rule](/bnbdr/swisscheese/blob/master/op_offset_poc.rule "op_offset_poc.rule") |  |  |
| [op\_offset\_poc.yarasm](/bnbdr/swisscheese/blob/master/op_offset_poc.yarasm "op_offset_poc.yarasm") | | [op\_offset\_poc.yarasm](/bnbdr/swisscheese/blob/master/op_offset_poc.yarasm "op_offset_poc.yarasm") |  |  |
| [requirements.txt](/bnbdr/swisscheese/blob/master/requirements.txt "requirements.txt") | | [requirements.txt](/bnbdr/swisscheese/blob/master/requirements.txt "requirements.txt") |  |  |
| [swisscheese.rule](/bnbdr/swisscheese/blob/master/swisscheese.rule "swisscheese.rule") | | [swisscheese.rule](/bnbdr/swisscheese/blob/master/swisscheese.rule "swisscheese.rule") |  |  |
| [swisscheese.yarasm](/bnbdr/swisscheese/blob/master/swisscheese.yarasm "swisscheese.yarasm") | | [swisscheese.yarasm](/bnbdr/swisscheese/blob/master/swisscheese.yarasm "swisscheese.yarasm") |  |  |
| [yara.bt](/bnbdr/swisscheese/blob/master/yara.bt "yara.bt") | | [yara.bt](/bnbdr/swisscheese/blob/master/yara.bt "yara.bt") |  |  |
| [yara\_hash.py](/bnbdr/swisscheese/blob/master/yara_hash.py "yara_hash.py") | | [yara\_hash.py](/bnbdr/swisscheese/blob/master/yara_hash.py "yara_hash.py") |  |  |
| [yara\_types.py](/bnbdr/swisscheese/blob/master/yara_types.py "yara_types.py") | | [yara\_types.py](/bnbdr/swisscheese/blob/master/yara_types.py "yara_types.py") |  |  |
| View all files | | |

## Repository files navigation

* README
# PoC YARA Exploits

* 3.7.1 32 bit using `CVE-2018-12034` and `CVE-2018-12035` ([write-up](//bnbdr.github.io/posts/swisscheese/)).
* 3.8.1 32 bit using `CVE-2018-19974`, `CVE-2018-19975` and `CVE-2018-19976` ([write-up](//bnbdr.github.io/posts/extracheese/))

[![](/bnbdr/swisscheese/raw/master/example2.gif)](/bnbdr/swisscheese/blob/master/example2.gif)

## YARASM Syntax Highlighting for VSCode

Install by copying `yarasm-syntax` folder to `%USERPROFILE%\.vscode\extensions\`

[![](/bnbdr/swisscheese/raw/master/yarasm-syntax/example.png)](/bnbdr/swisscheese/blob/master/yarasm-syntax/example.png)

## Usage

```
usage: build.py [-h] [-y YARA_ASM] [-v {3.8.1,3.7.1}] [-o OUTPUT]

optional arguments:
  -h, --help            show this help message and exit
  -y YARA_ASM, --yara-asm YARA_ASM
                        yara asm file, defaults to "extracheese.yarasm"
  -v {3.8.1,3.7.1}, --target-version {3.8.1,3.7.1}
                        yara version
  -o OUTPUT, --output OUTPUT
                        defaults to "extracheese.rule"
```

## About

Exploits for YARA 3.7.1 & 3.8.1

[bnbdr.github.io/posts/extracheese/](https://bnbdr.github.io/posts/extracheese/ "https://bnbdr.github.io/posts/extracheese/")

### Topics

[poc](/topics/poc "Topic: poc")
[yara](/topics/yara "Topic: yara")
[cve-2018-12034](/topics/cve-2018-12034 "Topic: cve-2018-12034")
[cve-2018-12035](/topics/cve-2018-12035 "Topic: cve-2018-12035")

### Resources

[Readme](#readme-ov-file)

[Activity](/bnbdr/swisscheese/activity)
### Stars

[**30**
stars](/bnbdr/swisscheese/stargazers)
### Watchers

[**1**
watching](/bnbdr/swisscheese/watchers)
### Forks

[**4**
forks](/bnbdr/swisscheese/forks)
[Report repository](/contact/report-content?content_url=https%3A%2F%2Fgithub.com%2Fbnbdr%2Fswisscheese&report=bnbdr+%28user%29)

## [Releases](/bnbdr/swisscheese/releases)

No releases published

## [Packages 0](/users/bnbdr/packages?repo_name=swisscheese)

No packages published

## Languages

* [Python
  100.0%](/bnbdr/swisscheese/search?l=python)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


