```
{
  "CVE-2018-16403": {
    "Metadata": {
      "CveID": "CVE-2018-16403",
      "Description": "libdw in elfutils 0.173 checks the end of the attributes list incorrectly in dwarf_getabbrev in dwarf_getabbrev.c and dwarf_hasattr in dwarf_hasattr.c, leading to a heap-based buffer over-read and an application crash."
    },
    "Bugzilla": [
      {
        "CommentID": "0",
        "Content": "Elfutils through version 0.173 is vulnerable to a heap-based buffer over-read due to incorrect checks for the end of attribute lists in the libdw/dwarf_getabbrev.c:__libdw_getabbrev() and libdw/dwarf_hasattr.c:dwarf_hasattr() functions. An attacker could exploit this to cause a crash via a crafted ELF.\n\nUpstream Bug:\n<https://sourceware.org/bugzilla/show_bug.cgi?id=23529>\n\nUpstream Patch:\n<https://sourceware.org/git/?p=elfutils.git;a=patch;h=6983e59b727458a6c64d9659c85f08218bc4fcda>",
        "Timestamp": "2018-09-04 04:45:51 UTC",
        "Root cause": "The vulnerability exists due to incorrect checks for the end of attribute lists in the `__libdw_getabbrev` and `dwarf_hasattr` functions within `libdw`. These functions don't properly identify the end of attribute lists, leading to a heap-based buffer over-read.",
         "Weaknesses": [
           "Heap-based buffer over-read"
        ],
        "Impact": "An attacker could exploit this to cause a crash via a crafted ELF file.",
        "Attack vectors": [
           "Crafted ELF file"
        ],
        "Required capabilities": "The attacker needs to craft a specific ELF file to trigger the vulnerability."
      }
    ],
      "SUSE": [
      {
        "Description": "libdw in elfutils 0.173 checks the end of the attributes list incorrectly in dwarf_getabbrev in dwarf_getabbrev.c and dwarf_hasattr in dwarf_hasattr.c, leading to a heap-based buffer over-read and an application crash.",
          "Root cause": "The vulnerability is due to incorrect end-of-list checks in `dwarf_getabbrev` and `dwarf_hasattr`, resulting in a heap-based buffer over-read.",
            "Weaknesses": [
                "Heap-based buffer over-read"
             ],
           "Impact": "Allows remote attackers to cause a denial of service (application crash) with a crafted ELF file.",
             "Attack vectors": [
                  "Crafted ELF file",
                  "Network"
             ],
           "Required capabilities": "The attacker needs to provide the crafted ELF file, which can be delivered over the network."
      },
      {
           "Note": "SUSE considers elfutils a developer tool which does not receive untrusted input. Code processed by elfutils is being executed in any normal scenario, so security exploits could just inject regular binary code. For this reason we update elfutils ocassionaly to the current stable version to catch up on features and bugfixes. If you are processing untrusted binary code with elfutils we recommend doing so on a seperate system or VM.",
            "Bugzilla entry": "1107067",
             "Status": "RESOLVED / FIXED"
       }
    ],
    "RedHat": [
      {
      "Description": "elfutils: Heap-based buffer over-read in libdw/dwarf\_getabbrev.c and libwd/dwarf\_hasattr.c causes crash",
        "Root cause": "The vulnerability is due to incorrect checks for the end of attribute lists in the `__libdw_getabbrev` and `dwarf_hasattr` functions within `libdw`.",
           "Weaknesses": [
            "Heap-based buffer over-read"
          ],
            "Impact": "An attacker could exploit this to cause a crash via a crafted ELF file.",
              "Attack vectors": [
                 "Crafted ELF file"
             ],
             "Required capabilities": "The attacker needs to provide the crafted ELF file."
      }
    ],
    "Sourceware": [
       {
           "CommentID": "0",
           "Content": "crash-seed-buffer-over-flow when executing \"./eu-readelf -aAdehIlnrsSVcp -w @@\", AddressSanitizer catch a heap-buffer-overflow carsh.\n==29317==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60600000c536 at pc 0x7f5bdaf2bfb0 bp 0x7ffff669ef70 sp 0x7ffff669ef60\nREAD of size 1 at 0x60600000c536 thread T0\n#0 0x7f5bdaf2bfaf in __libdw_get_uleb128_unchecked /mnt/d/Project/elfutils/libdw/memory-access.h:97\n#1 0x7f5bdaf2bfaf in dwarf_getabbrevattr_data /mnt/d/Project/elfutils/libdw/dwarf_getabbrevattr.c:60\n#2 0x42f8c2 in print_debug_abbrev_section /mnt/d/Project/elfutils/src/readelf.c:5045\n#3 0x45313f in print_debug /mnt/d/Project/elfutils/src/readelf.c:11143\n#4 0x45b07b in process_elf_file /mnt/d/Project/elfutils/src/readelf.c:996\n#5 0x462344 in process_dwflmod /mnt/d/Project/elfutils/src/readelf.c:760\n#6 0x7f5bdafcc410 in dwfl_getmodules /mnt/d/Project/elfutils/libdwfl/dwfl_getmodules.c:86\n#7 0x40f013 in process_file /mnt/d/Project/elfutils/src/readelf.c:868\n#8 0x405614 in main /mnt/d/Project/elfutils/src/readelf.c:350\n#9 0x7f5bda65082f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n#10 0x406118 in _start (/mnt/d/Project/elfutils/build/bin/eu-readelf+0x406118)\n0x60600000c536 is located 0 bytes to the right of 54-byte region [0x60600000c500,0x60600000c536) allocated by thread T0 here:\n#0 0x7f5bdb328602 in malloc (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x98602)\n#1 0x7f5bdac62680 in convert_data /mnt/d/Project/elfutils/libelf/elf_getdata.c:164\n#2 0x7f5bdac62680 in __libelf_set_data_list_rdlock /mnt/d/Project/elfutils/libelf/elf_getdata.c:431\nSUMMARY: AddressSanitizer: heap-buffer-overflow /mnt/d/Project/elfutils/libdw/memory-access.h:97 __libdw_get_uleb128_unchecked\nShadow bytes around the buggy address:\n0x0c0c7fff9850: fd fd fd fa fa fa fa fa fd fd fd fd fd fd fd fa\n0x0c0c7fff9860: fa fa fa fa fd fd fd fd fd fd fd fa fa fa fa fa\n0x0c0c7fff9870: fd fd fd fd fd fd fd fa fa fa fa fa fd fd fd fd\n0x0c0c7fff9880: fd fd fd fa fa fa fa fa fd fd fd fd fd fd fd fa\n0x0c0c7fff9890: fa fa fa fa 00 00 00 00 00 00 00 fa fa fa fa fa\n=>0x0c0c7fff98a0: 00 00 00 00 00 00[06]fa fa fa fa fa fd fd fd fd\n0x0c0c7fff98b0: fd fd fd fa fa fa fa fa fd fd fd fd fd fd fd fa\n0x0c0c7fff98c0: fa fa fa fa fd fd fd fd fd fd fd fa fa fa fa fa\n0x0c0c7fff98d0: fd fd fd fd fd fd fd fa fa fa fa fa fd fd fd fd\n0x0c0c7fff98e0: fd fd fd fa fa fa fa fa fd fd fd fd fd fd fd fa\n0x0c0c7fff98f0: fa fa fa fa fd fd fd fd fd fd fd fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\nAddressable: 00\nPartially addressable: 01 02 03 04 05 06 07\nHeap left redzone: fa\nHeap right redzone: fb\nFreed heap region: fd\nStack left redzone: f1\nStack mid redzone: f2\nStack right redzone: f3\nStack partial redzone: f4\nStack after return: f5\nStack use after scope: f8\nGlobal redzone: f9\nGlobal init order: f6\nPoisoned by user: f7\nContainer overflow: fc\nArray cookie: ac\nIntra object redzone: bb\nASan internal: fe\n==29317==ABORTING",
        "Timestamp": "2018-08-15 13:14:14 UTC",
        "Root cause": "The root cause is an incorrect check for the end of the attributes list in `__libdw_get_uleb128_unchecked`, `dwarf_getabbrevattr_data`, `print_debug_abbrev_section` functions, which causes a heap-based buffer overflow.",
        "Weaknesses": [
          "Heap-based buffer over-read"
         ],
          "Impact": "The impact is a heap-buffer-overflow which leads to an application crash (denial of service).",
          "Attack vectors": [
               "crafted ELF file"
            ],
          "Required capabilities": "Attacker requires the ability to supply a crafted ELF file."
      },
       {
            "CommentID": "1",
           "Content": "The issue is that __libdw_getabbrev (used by dwarf_getabbrev, dwarf_offabbrev) uses a different \"end of attributes\" condition than dwarf_getabbrevattr[_data]:\n\nwhile (attrname != 0 && attrform != 0);\n\nvs\n\n/* If both values are zero the index is out of range. */\nif (name == 0 && form == 0)\n\nSince the spec says: \"The series of attribute specifications ends with an entry containing 0 for the name and 0 for the form.\" the second form is correct. And the check in __libdw_getabbrev should be:\n\nwhile (attrname != 0 || attrform != 0);",
           "Timestamp": "2018-08-15 15:35:11 UTC",
           "Root cause": "The root cause is an inconsistent condition used to check the end of attribute lists in `__libdw_getabbrev` which is used by `dwarf_getabbrev`, and `dwarf_offabbrev` vs `dwarf_getabbrevattr[_data]`.The DWARF spec says: \"The series of attribute specifications ends with an entry containing 0 for the name and 0 for the form.\"",
            "Weaknesses": [
            "Inconsistent end of list check",
             "Heap-based buffer over-read"
            ],
            "Impact": "Incorrect handling of the attribute list end condition may lead to a heap-buffer over-read. Which results in the crash of the application.",
            "Attack vectors": [
            "crafted ELF file"
            ],
           "Required capabilities": "Attacker requires the ability to supply a crafted ELF file."
       },
       {
           "CommentID": "2",
          "Content": "commit 6983e59b727458a6c64d9659c85f08218bc4fcda\nAuthor: Mark Wielaard <mark@klomp.org>\nDate: Sat Aug 18 19:51:27 2018 +0200\n\nlibdw: Check end of attributes list consistently.\n\ndwarf_child (__libdw_find_attr), dwarf_getabbrevattr[_data] and\ndwarf_getattrs all assume the end of the attribute list is when\nboth the name (code) and form of the attribute are zero.\n\ndwarf_getabbrev (__libdw_getabbrev) and dwarf_hasattr assume the\nend of the attribute list is when either the name (code) or the\nform of the attribute is zero.\n\nThe DWARF spec says: \"The series of attribute specifications ends\nwith an entry containing 0 for the name and 0 for the form.\" So\nthe first check is correct.\n\nMake sure dwarf_getabbrev and dwarf_hasattr use the same check.\nThis is important since all other functions expect dwarf_getabbrev\n(__libdw_getabbrev) to have done a data sanity check of the attribute.\nSo if the ending condition is different it could cause a crash.\n\n[https://sourceware.org/bugzilla/show_bug.cgi?id=23529](show_bug.cgi?id=23529 \"RESOLVED FIXED - heap-buffer-overflow in eu-readelf\")\n\nSigned-off-by: Mark Wielaard <mark@klomp.org>",
           "Timestamp": "2018-08-18 20:51:36 UTC",
         "Root cause": "The root cause was an inconsistency in how the end of the attribute list was being checked in the `dwarf_getabbrev` and `dwarf_hasattr` functions compared to other similar functions.",
          "Weaknesses": [
            "Inconsistent end of list check"
        ],
        "Impact": "The fix ensures consistent data sanity checks and avoids the heap-based buffer over-read.",
        "Attack vectors": [
             "crafted ELF file"
         ],
         "Required capabilities": "Attacker requires the ability to supply a crafted ELF file."
        },
        {
            "CommentID": "3",
            "Content": "CVE-2018-16403",
            "Timestamp": "2018-09-04 07:36:52 UTC"
        }
    ],
        "Ubuntu": [
           {
              "Description": "It was discovered that elfutils incorrectly handled certain malformed files. If a user or automated system were tricked into processing a specially crafted file, elfutils could be made to crash or consume resources, resulting in a denial of service." ,
            "Weaknesses": [
                 "Incorrect handling of malformed files",
                  "Heap-based buffer over-read"
            ],
            "Impact": "An attacker could trick a user or automated system to process a crafted file, which can cause a denial of service through application crashes or resource consumption.",
             "Attack vectors": [
               "Specially crafted file"
              ],
            "Required capabilities":"An attacker needs to be able to trick a user or automated system into processing a crafted file."
          }
      ]
  }
}
```