=== Content from research.checkpoint.com_bfe3d0f7_20250124_153517.html ===

[![](https://research.checkpoint.com/wp-content/uploads/2024/06/CPR-by-Check-Point-logo.svg)](https://research.checkpoint.com)

* [CONTACT US](https://research.checkpoint.com/contact/)
* [DISCLOSURE POLICY](https://research.checkpoint.com/disclosure-policy/)
* [CHECKPOINT.COM](https://www.checkpoint.com/)
* [UNDER ATTACK?](https://www.checkpoint.com/about-us/contact-incident-response/)

[![](https://research.checkpoint.com/wp-content/uploads/2024/06/CPR-by-Check-Point-logo.svg)](https://research.checkpoint.com)

* [Latest Publications](https://research.checkpoint.com/latest-publications/)
* [CPR Podcast Channel](https://research.checkpoint.com/cpr-podcast-channel/)
* [Web 3.0 Security](https://research.checkpoint.com/category/web3/)
* [Intelligence Reports](https://research.checkpoint.com/intelligence-reports/)
* Resources
  + [ThreatCloud AI](https://www.checkpoint.com/ai/)
  + [Threat Intelligence & Research](https://www.checkpoint.com/solutions/threat-intelligence-research/)
  + [Zero Day Protection](https://www.checkpoint.com/infinity/zero-day-protection/)
  + [Sandblast File Analysis](http://threatemulation.checkpoint.com/)
* [About Us](https://research.checkpoint.com/about-us/)
* [SUBSCRIBE](https://research.checkpoint.com/subscription/)

SUBSCRIBE

## CATEGORIES

* [Android Malware
  23](https://research.checkpoint.com/category/android-malware/)
* [Artificial Intelligence
  4](https://research.checkpoint.com/category/artificial-intelligence-2/)
* [ChatGPT
  3](https://research.checkpoint.com/category/chatgpt/)
* [Check Point Research Publications
  396](https://research.checkpoint.com/category/threat-research/)
* [Cloud Security
  1](https://research.checkpoint.com/category/cloud-security/)
* [CPRadio
  44](https://research.checkpoint.com/category/cpradio/)
* [Crypto
  2](https://research.checkpoint.com/category/crypto/)
* [Data & Threat Intelligence
  1](https://research.checkpoint.com/category/data-threat-intelligence/)
* [Data Analysis
  0](https://research.checkpoint.com/category/data-analysis/)
* [Demos
  22](https://research.checkpoint.com/category/demos/)
* [Global Cyber Attack Reports
  339](https://research.checkpoint.com/category/threat-intelligence-reports/)
* [How To Guides
  13](https://research.checkpoint.com/category/how-to-guides/)
* [Ransomware
  2](https://research.checkpoint.com/category/ransomware/)
* [Russo-Ukrainian War
  1](https://research.checkpoint.com/category/russo-ukrainian-war/)
* [Security Report
  1](https://research.checkpoint.com/category/security-report/)
* [Threat and data analysis
  0](https://research.checkpoint.com/category/threat-and-data-analysis/)
* [Threat Research
  172](https://research.checkpoint.com/category/threat-research-2/)
* [Web 3.0 Security
  9](https://research.checkpoint.com/category/web3/)
* [Wipers
  0](https://research.checkpoint.com/category/wipers/)

![](https://research.checkpoint.com/wp-content/uploads/2018/12/AdobeVulnerabilities_1021x580.jpg)

# 50 CVEs in 50 Days: Fuzzing Adobe Reader

December 12, 2018

https://research.checkpoint.com/2018/50-adobe-cves-in-50-days/

**Research By:** Yoav Alon, Netanel Ben-Simon

**Introduction**

The year 2017 was an inflection point in the vulnerability landscape. The number of new vulnerabilities reported that year was around 14,000, which is over twice the number from the year before (see table below). The probable reason for this is the increased popularity of automatic vulnerability finding tools, also known as “fuzzers”.

[![Vulnerabilities by Year](/wp-content/uploads/2018/12/fig1-1.png)](/wp-content/uploads/2018/12/fig1-1.png)

The mere existence of fuzzers is not breaking news; they’ve been around for over two decades. The news is that fuzzers have grown up. They’ve become more capable, more accessible, and overall more mature. Still, using fuzzers has somewhat of a reputation as a “dark art”, a lot of researchers don’t bother with fuzzers because they are perceived as a hassle to use.

Given all the above, we found it natural to ask: Yes, more researchers are using fuzzers to find more vulnerabilities — but are \*all\* the researchers using fuzzers to find \*all\* the vulnerabilities? How many low-hanging fruits are still out there, just waiting for the first person to press the big shiny button that says ‘FUZZ’?

To find out, we constructed the most vanilla experiment we could think of. We took one of the most common Windows fuzzing frameworks, WinAFL, and aimed it at Adobe Reader, which is one of the most popular software products in the world. We set a time-frame of 50 days for the entire endeavor – reverse-engineering the code, looking for potential vulnerable libraries, writing harnesses and, finally, running the fuzzer itself.

The results left us flabbergasted. In those 50 days, we were able to find over 50 new vulnerabilities in Adobe Reader. On average, that’s 1 vulnerability per day — not quite the usual pace for this kind of research.

In this paper, we lay out the entire story of this research. We share a novel methodology we used to increase the scope of our search, improvements that we were able to make to WinAFL, and, finally, the insights we gained along the way.

**What is WinAFL?**

[AFL](http://lcamtuf.coredump.cx/afl/) is a coverage guided genetic fuzzer, which has a rock solid implementation and clever heuristics that have proven to be very ([!](http://lcamtuf.coredump.cx/afl/#bugs)) successful in finding real bugs in real software.

WinAFL is a fork of AFL for Windows, created and maintained by Ivan Fratric (Google Project Zero). The Windows version uses a different style of instrumentation which enables us to target closed source binaries.

We recommend reading the AFL [technical paper](http://lcamtuf.coredump.cx/afl/technical_details.txt), which goes into detail on how AFL works. It also points out the tool’s shortcomings and helps you debug when things go wrong.

We found WinAFL to be extremely effective in finding file format bugs, especially in compressed binary formats (images / videos / archives).

**Attacking Acrobat Reader DC**

The easiest place to start is the main executable, AcroRd32.exe. This is a (relatively) thin wrapper around AcroRd32.dll, which is approximately 30MB in size. AcroRd32.dll has a lot of code, some of which contains parsers for PDF objects, but a lot of it is GUI code (not the place you usually want to look for bugs).

We know that WinAFL is better at binary formats, so we decided to focus our efforts and attack a specific parser. The challenge is to locate a parser and write a harness for it. We’ll explain what exactly is a harness is a bit later on.

We want a binary format parser with minimal dependencies that we can load without also loading the entire Reader process.

We explored the DLLs in Acrobat’s folder and found that JP2KLib.dll fits all categories:

[![](/wp-content/uploads/2018/12/fig2-1.png)](/wp-content/uploads/2018/12/fig2-1.png)

JP2KLib.dll is a parser for the JPEG2000 format, which is a complex binary format (753 KB), and has exported functions which are pretty descriptive.

[![](/wp-content/uploads/2018/12/fig3.jpg)](/wp-content/uploads/2018/12/fig3.jpg)

The research was conducted on the following versions:

Acrobat Reader DC 2018.011.20038 and earlier

JP2KLib.dll version 1.2.2.39492

**What Is a Target Function?**

A [target function](https://github.com/googleprojectzero/winafl#how-to-select-a-target-function) is a term that WinAFL uses to describe the function that is used as the entry point to the fuzzing process. The function is called in a loop for *fuzz\_iterations* times, each time mutating the input file on disk. The function must:

* Open the input file, read the file, parse the input and close the file.
* Return normally – without throwing a *C++* exception or calling *TerminateProcess*

Finding such a function in nature is pretty uncommon. When targeting a complex software, we usually need to write a harness.

**What Is a Harness?**

A harness is a small program that triggers the functionality we want to fuzz. The harness includes a function which will be used as our target function. Here’s an example for a [minimal harness](https://github.com/googleprojectzero/winafl/blob/master/gdiplus.cpp) for gdiplus from the WinAFL repository:

[![](/wp-content/uploads/2018/12/fig4-1.png)](/wp-content/uploads/2018/12/fig4-1.png)

The first argument to *main* is a path. Within the function, we call the [*Image::Image*](https://docs.microsoft.com/en-us/windows/desktop/api/gdiplusheaders/nf-gdiplusheaders-image-image%28inconstwchar_inbool%29) parser, which is the API we wanted to fuzz. Notice that in error cases, we don’t terminate the process and at the end we free all resources.

This process is relatively easy for documented API. We can copy a sample code or write a simple program using the documentation. But where’s the fun in that?

We chose to target Adobe Reader, which is a closed sourced binary. The process of writing a harness for this type of target looks something like this:

1. Find the functionality we want to fuzz.
2. Reverse-engineer it a little bit.
3. Write a program that calls the reversed API.
4. Repeat until we have a fully functional harness.

In the following section, we describe in detail how we reverse-engineered JP2KLib, and wrote a working harness for it. We also share a few tips. Readers who are only interested in our fuzzing methodology can skip to the next section.

**Writing a Harness for JP2KLib.dll**

Before starting to reverse-engineer JP2KLib.dll, we checked whether the library is open source or has public symbols. This is a big time saver and is more common than you might think. But in our case, we weren’t so lucky.

As we wanted our harness to be as similar as possible to how Adobe Reader uses JP2KLib, the first thing we had to do is to find a PDF file that triggers the behavior we wanted to fuzz. This enables us to easily locate the relevant parts of the program.

In our case, we have a large corpus of PDFs for testing our products. We *grep*ped the string “/JPXDecode“, which is the PDF filter for JPEG2000, and used the smallest example that came up. We could also have googled for a sample file or used Acrobat Pro / Phantom PDF to generate a test case.

***Pro Tip 1:** The reader has a sandbox, which is sometimes annoying for debugging/triaging, but this can be disabled –* [*https://forums.adobe.com/thread/2110951*](https://forums.adobe.com/thread/2110951)

***Pro Tip 2:*** *We turned on* [*PageHeap*](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/gflags-and-pageheap) *to assist in the reverse-engineering efforts, as it helps in tracking allocation place and size.*

We extracted the jp2 file from our sample, so we could use it for our harness without the PDF wrapper. This will be used as our testing input for the harness.

Now that we had a minimal working example, we placed a breakpoint on the load event of JP2KLib.dll using *“sxe ld jp2klib”*. When the breakpoint hit, we placed a breakpoint command on all exported functions of JP2KLib. The breakpoint command logs the call stack, the first few arguments, and the return value:

*bm /a jp2klib!\* “.echo callstack; k L5; .echo parameters:;  dc esp L8;  .echo return value: ; pt; ”*

We loaded the sample PDF and got the following output:

[![](/wp-content/uploads/2018/12/fig5-1.png)](/wp-content/uploads/2018/12/fig5-1.png)

JP2KLibInitEx is the first function called after loading JP2KLib. We noticed that JP2KLibInitEx takes only one argument. Let’s examine it:

[![](/wp-content/uploads/2018/12/fig6-1.png)](/wp-content/uploads/2018/12/fig6-1.png)

We can see that it’s a struct of size 0x20 and it contains pointers to functions in AcroRd32.dll. When we encounter an unknown function, we don’t rush into reversing it as we don’t know if it’s going to be used by the target code. Instead, we point each address to a unique empty function we call “nopX” (where X is a number).

We now have enough information to start writing our harness skeleton:

1. Get input file from command line arguments.
2. Load JP2KLib.dll.
3. Get a pointer to JP2KLibInitEx and call it with a struct of 8 nop functions.

[![](/wp-content/uploads/2018/12/fig7-1.png)](/wp-content/uploads/2018/12/fig7-1.png)

We use LOAD\_FUNC as a convenience macro. We also have a NOP(x) macro for creating nop functions.

[![](/wp-content/uploads/2018/12/screent.png)](/wp-content/uploads/2018/12/screent.png)

We compile, run it with sample.jp2 – and it works!

Let’s continue (“g”). We then move to the next function JP2KGetMemObjEx which doesn’t take any arguments, so we call it and save the return value.

The next function JP2KDecOptCreate also doesn’t take any arguments, so we call it and save the return value. However, we notice that JP2KDecOptCreate internally calls nop4 and nop7, which means we need to implement them.

Our next move is to understand what “nop4” does. We placed a breakpoint on the original function pointer to “nop4” *AcroRd32!CTJPEGDecoderRelease+0xa992* and continued execution:

[![](/wp-content/uploads/2018/12/fig8.png)](/wp-content/uploads/2018/12/fig8.png)

Which took us to:

[![](/wp-content/uploads/2018/12/fig9-1.png)](/wp-content/uploads/2018/12/fig9-1.png)

And after few steps:

[![](/wp-content/uploads/2018/12/fig10-1.png)](/wp-content/uploads/2018/12/fig10-1.png)

So it turns out that nop4 is a thin wrapper around malloc. We implemented it in our harness and replaced it with “nop4”. We repeated this procedure again for nop7 and found out it was *memset*!. We looked around and saw that nop5 and nop6 and were *free* and *memcpy* respectively.

The next function, JP2KDecOptInitToDefaults, was called with one argument. This was the return value from JP2KDecOptCreate, so we passed the value to it.

The next function, JP2KImageCreate, takes no arguments, so we called it and saved the return value.

Currently, our harness looks something like this:

[![](/wp-content/uploads/2018/12/fig11-1.png)](/wp-content/uploads/2018/12/fig11-1.png)

The next function is JP2KImageInitDecoderEx, which takes **5!** arguments.

We matched 3 out of 5 parameters to return values from: JP2KImageCreate, JP2KDecOptCreate and JP2KGetMemObjEx

We noticed that the 3rd parameter points to a vtable. We did the same trick as before – created a struct with the same size that points to “nop” functions.

The 2nd parameter points to another struct, only this time it doesn’t seem to contain function pointers. We decided to send the const value 0xbaaddaab.

At this point the code looks like this:

[![](/wp-content/uploads/2018/12/fig12-1.png)](/wp-content/uploads/2018/12/fig12-1.png)

We ran our harness and quickly arrived at nop10. We set a breakpoint in Adobe Reader on the corresponding function and got to the following call stack:

[![](/wp-content/uploads/2018/12/fig13-1.png)](/wp-content/uploads/2018/12/fig13-1.png)

Looking at JP2KCodeStm::IsSeekable in IDA:

[![](/wp-content/uploads/2018/12/fig14-1.png)](/wp-content/uploads/2018/12/fig14-1.png)

Looking at WinDbg, we can see that JP2KCodeStm at offset 0x24 contains our vtable and offset 0x18 contains 0xbaaddaab. We can see that JP2KCodeStm::IsSeekable calls a function from our vtable passing 0xbaaddaab as the first parameter, so it’s basically a thin wrapper around our vtable function #7.

In general, every parser is a bit different but usually they consume an input stream which could be in a familiar file interface (like FILE / ifstream). More often than not, it’s some sort of a custom type that abstracts the underlying input stream (network / file / memory). So when we saw how JP2KCodeStm was used, we knew what we were looking at.

Back to our case, 0xbaaddaab is the stream object and the vtable functions operate on the stream object.

We moved to IDA and looked at all the other JP2KCodeStm::XXX functions.

[![](/wp-content/uploads/2018/12/fig15-1.png)](/wp-content/uploads/2018/12/fig15-1.png)

They were all very similar, so we went ahead and created our own file object, and implemented all the necessary methods. The resulting code looks like:

[![](/wp-content/uploads/2018/12/fig16-1.png)](/wp-content/uploads/2018/12/fig16-1.png)

We made sure we checked the return value from JP2KImageInitDecoderEx and bailed in case of error. In our case, JP2KImageInitDecoderEx returns 0 on success. It took us a few tries to implement the stream functions correctly, but we finally got our desired return value.

The next function, JP2KImageDataCreate, takes no arguments and its return value is passed to the following function JP2KImageGetMaxRes. We called them both and moved on.

We got to the JP2KImageDecodeTileInterleaved function which takes **7!** Arguments, of which 3 are return values from JP2KImageCreate, JP2KImageGetMaxRes, and JP2KImageDataCreate.

The 2nd and 6th parameters were found to be null after xrefing and looking inside AcroRd32 in IDA.

We remained with the 4th and 5th arguments. We concluded that they depend on the color depth (8/16), so we decided to fuzz with constant depth.

Finally we got:

[![](/wp-content/uploads/2018/12/fig17-1.png)](/wp-content/uploads/2018/12/fig17-1.png)

At last, we called the functions JP2KImageDataDestroy, JP2KImageDestroy, and JP2KDecOptDestroy to release the objects we created and avoid memory leaks. This is critical for WinAFL when *fuzz\_iterations* are high.

Done! We have a working harness!

In one final tweak, we separated the initialization code – loading JP2KLib and finding the functions from the parsing code. This improves performance, as we don’t have to pay for initialization in every fuzz iteration. We called the new function “fuzzme”. We will also export “fuzzme” (you can export functions in an exe file) as it’s easier than finding the relevant offset in the binary.

Anecdote: When testing our harness in WinAFL, we found out that WinAFL generates files with duplicate magic. After we dug a bit, we found that Adobe used different SEEK constants than the ones defined in libc, causing us to mix SEEK\_SET and SEEK\_CUR.

##

**Fuzzing Methodology**

1. Basic tests for the harness
   1. Stability
   2. Paths
   3. Timeouts
2. Fuzzing Setup
3. Initial corpus
4. Initial line coverage
5. Fuzzing loop
   1. Fuzz
   2. Check coverage / crashes
   3. cmin & repeat
6. Triage

###

**Basic Tests for the Harness**

Before starting a big fuzzing session, we do a few sanity tests to make sure we’re not just heating servers. The first thing we check is that the fuzzer is reaching new paths with our harness, meaning that the *total path* count is steadily rising.

If the path count is zero or almost zero, there are a few pitfalls we can check for:

* The target function was inlined by the compiler which causes WinAFL to miss the entry to the target function and results in WinAFL termination with program abort.
* This could also happen if the number of arguments (-nargs) is not correct or that the calling convention is not the default.
* Timeouts – Sometimes the timeout is too low and causes the fuzzer to kill the harness too quickly. The solution is to raise the timeout.

We let the fuzzer run for a few minutes and then checked the stability of the fuzzer. If the stability is low (under 80%), we try to debug the issue. The stability of the harness is important, as it affects the accuracy and performance of the fuzzer.

Common pitfalls:

* Check for random elements. For example, some hash table implementations use random to prevent collision, but this is really bad for coverage accuracy. We just patch the random seed to a constant value.
* Sometimes the software has a cache for certain global objects. We usually just do a nop run before calling the *target function* to reduce this effect
* For 32-bit targets on a Windows 10 64-bit machine, the stack alignment is not always ~8 bytes. This means that sometimes *memcpy* and other AVX optimized code will act differently and that does affect coverage. One solution is to add code in the harness to align the [stack](https://github.com/googleprojectzero/winafl/issues/111#issuecomment-393149203).

If all the above fail, we use DynamoRIO to do instruction tracing for the harness and diff the output.

###

**Fuzzing Setup**

Our setup consists of a VM with 8-16 cores and 32 GB of RAM, running Windows 10 x64.

We fuzz on a RAM disk drive using [ImDisk toolkit](https://sourceforge.net/projects/imdisk-toolkit/). We discovered that with fast targets, writing test cases to disk is a performance bottleneck.

We disable Windows Defender because it hurts performance and because some of the test cases generated by WinAFL were discovered by Windows Defender as a known exploit (“Exploit:Win32/CVE-2010-2889”).

[![](/wp-content/uploads/2018/12/fig18-1.png)](/wp-content/uploads/2018/12/fig18-1.png)

We disable the Windows Indexing Service for performance.

We disable Windows Update because it interferes with the fuzzing efforts (restarts the machine and replaces fuzzed DLLs).

We enable page heap for the harness process because it has proven to find bugs that we wouldn’t detect otherwise.

We use the [edge](http://lcamtuf.coredump.cx/afl/technical_details.txt) as the coverage type instead of the default basic block as it proved better in finding bugs, despite the fact that it’s slower than basic block mode.

This is an example command for running our adobe\_jp2k harness:

*afl-fuzz.exe -i R:\jp2k\in -o R:\jp2k\out -t 20000+ -D c:\DynamoRIO-Windows-7.0.0-RC1\bin32 -S Slav02 — -fuzz\_iterations 10000 -coverage\_module JP2KLib.dll -target\_module adobe\_jp2k.exe -target\_method fuzzme -nargs 1 -covtype edge — adobe\_jp2k.exe @@*

**Initial Corpus**

Once we have a working harness, we create an initial corpus for it, usually from:

* Online corpuses ([afl corpus](http://lcamtuf.coredump.cx/afl/demo/), [openjpeg-data](https://github.com/uclouvain/openjpeg-data))
* Test suites from open source projects
* Crawling google / duckduckgo
* Corpuses from our older fuzzing projects

**Corpus Minimization**

Using a big corpus of files that produce the same coverage hurts the performance of the fuzzer. AFL handles this by minimizing the corpus using afl-cmin. WinAFL has a port for the tool called winafl-cmin.py.

We take all the files that we gathered and run them through winafl-cmin.py, which results in a minimal corpus.

We run winafl-cmin at least two times to see if we get the same set of files. If we got two different sets, it usually means that there’s non-determinism in our harness. This is something we try to investigate, using afl-showmap or other tools.

Once we finished minimizing successfully, we save the set of files as our initial corpus.

###

**Initial Line Coverage**

Now that we have a minimal corpus, we want to take a look at our line coverage. Line coverage means which assembly instructions we actually executed. To get line coverage, we use DynamoRIO: *“[dynamoriodir]\bin32\drrun.exe -t drcov — harness.exe testcase”*  for each test case. Next, we load the results to IDA using [Lighthouse](https://github.com/gaasedelen/lighthouse):

[![](/wp-content/uploads/2018/12/fig19-1.png)](/wp-content/uploads/2018/12/fig19-1.png)

We note the initial line coverage, as it helps us to evaluate how effective the fuzzing session was.

###

**Fuzzing Cycle**

The next step is pretty straight forward:

1. Run the fuzzers.
2. Check coverage and crashes.
3. Investigate coverage, cmin and repeat.

Running the fuzzers, does not require anything special. Just run the fuzzers in the configuration we listed above.

We have a bot with the following features:

1. Status of all fuzzers (using winafl-whatsapp.py).
2. Graph of paths over time for each fuzzer (using winafl-plot.py).
3. Crash triage and generate report (we will talk about this in the next section).
4. Restart dead fuzzers.

We can’t stress enough how important it is to automate those tasks. Otherwise, fuzzing is tedious and error-prone.

We check the status of the fuzzers every couple of hours and the paths over time. If we see that the graph plateaus, we try to investigate the coverage.

[![](/wp-content/uploads/2018/12/fig20.jpg)](/wp-content/uploads/2018/12/fig20.jpg)

We copy all the queues of all the fuzzers and run them through cmin and look at the results in IDA. We look for functions that are relatively large and have very small coverage. We try to understand what functionality is related to this function and proactively find samples that will trigger this functionality. In JP2K, this wasn’t very helpful but in other targets, especially text formats, this phase is a big win!

This stage is very important; in one case, we added a single sample and after a few hours of fuzzing it contributed 1.5% line coverage and we discovered 3 new security bugs.

We then repeated the cycle until we ran out of time or we didn’t see any coverage improvement. This usually means we must either change the target or try to improve the harness.

**Triage**

Once we have a set of test cases that causes a crash, we manually examined the crashes and each crashing input. We quickly changed strategy, as we had a lot of duplicates. We started using [BugId](https://github.com/SkyLined/BugId) to automatically find duplicates and minimize the set to only unique crashes. We used our bot for that.

[![](/wp-content/uploads/2018/12/fig21-1.png)](/wp-content/uploads/2018/12/fig21-1.png)

**What We Found**

This strategy eventually allowed us to find 53 critical bugs in Adobe Reader and Adobe Pro.

We repeated this process for different parsers such as images, stream decoders and xslt module, which resulted in the following list of CVEs:

CVE-2018-4985, CVE-2018-5063, CVE-2018-5064, CVE-2018-5065, CVE-2018-5068, CVE-2018-5069, CVE-2018-5070, CVE-2018-12754, CVE-2018-12755, CVE-2018-12764, CVE-2018-12765, CVE-2018-12766, CVE-2018-12767, CVE-2018-12768, CVE-2018-12848, CVE-2018-12849, CVE-2018-12850, CVE-2018-12840, CVE-2018-15956, CVE-2018-15955, CVE-2018-15954,CVE-2018-15953, CVE-2018-15952, CVE-2018-15938, CVE-2018-15937, CVE-2018-15936, CVE-2018-15935, CVE-2018-15934, CVE-2018-15933, CVE-2018-15932 , CVE-2018-15931, CVE-2018-15930 , CVE-2018-15929, CVE-2018-15928, CVE-2018-15927, CVE-2018-12875, CVE-2018-12874 , CVE-2018-12873, CVE-2018-12872,CVE-2018-12871, CVE-2018-12870, CVE-2018-12869, CVE-2018-12867 , CVE-2018-12866, CVE-2018-12865 , CVE-2018-12864 , CVE-2018-12863, CVE-2018-12862, CVE-2018-12861, CVE-2018-12860, CVE-2018-12859, CVE-2018-12857, CVE-2018-12839, CVE-2018-8464

One of the bugs we found in jp2k was actually reported to Adobe just a short while before we found it, as it seems it was already discovered [being exploited in the wild](https://www.welivesecurity.com/2018/05/15/tale-two-zero-days/).

Of course, Adobe Reader is sandboxed, and Reader Protected Mode greatly increases the complexity of turning an exploitable crash inside the sandbox into system compromise, which usually requires another PE exploit, as was used in the mentioned in-the-wild exploit.

We love WinAFL and hope to see it used more.

While using WinAFL, we encountered a number of bugs / missing features. We added support for those new features and upstreamed the patches. These include adding support for App verifier in Windows 10, CPU affinity for workers, fixed a few bugs and added some GUI features.

You can view the commits here:

Netanel’s commits – <https://github.com/googleprojectzero/winafl/commits?author=netanel01>

Yoava’s commits – <https://github.com/googleprojectzero/winafl/commits?author=yoava333>

[![](https://research.checkpoint.com/wp-content/uploads/2022/10/back_arrow.svg)

GO UP](#single-post)

[BACK TO ALL POSTS](/latest-publications/)

## POPULAR POSTS

[![](https://research.checkpoint.com/wp-content/uploads/2023/01/AI-1059x529-copy.jpg)](https://research.checkpoint.com/2023/opwnai-cybercriminals-starting-to-use-chatgpt/)

* Artificial Intelligence
* ChatGPT
* Check Point Research Publications

[OPWNAI : Cybercriminals Starting to Use ChatGPT](https://research.checkpoint.com/2023/opwnai-cybercriminals-starting-to-use-chatgpt/)

[![](https://research.checkpoint.com/wp-content/uploads/2019/01/Fortnite_1021x580.jpg)](https://research.checkpoint.com/2019/hacking-fortnite/)

* Check Point Research Publications
* Threat Research

[Hacking Fortnite Accounts](https://research.checkpoint.com/2019/hacking-fortnite/)

[![](https://research.checkpoint.com/wp-content/uploads/2022/12/OpenAIchatGPT_header.jpg)](https://research.checkpoint.com/2022/opwnai-ai-that-can-save-the-day-or-hack-it-away/)

* Artificial Intelligence
* ChatGPT
* Check Point Research Publications

[OpwnAI: AI That Can Save the Day or HACK it Away](https://research.checkpoint.com/2022/opwnai-ai-that-can-save-the-day-or-hack-it-away/)

### BLOGS AND PUBLICATIONS

[![](https://research.checkpoint.com/wp-content/uploads/2020/02/CheckPointResearchTurkishRat_blog_header.jpg)](https://research.checkpoint.com/2020/the-turkish-rat-distributes-evolved-adwind-in-a-massive-ongoing-phishing-campaign/)

* Check Point Research Publications
* Global Cyber Attack Reports
* Threat Research

February 17, 2020
### “The Turkish Rat” Evolved Adwind in a Massive Ongoing Phishing Campaign

[![](https://research.checkpoint.com/wp-content/uploads/2017/08/WannaCry-Post-No-Image-1021x450.jpg)](https://research.checkpoint.com/2017/the-next-wannacry-vulnerability-is-here/)

* Check Point Research Publications

August 11, 2017
### “The Next WannaCry” Vulnerability is Here

[![](https://research.checkpoint.com/wp-content/uploads/2018/01/rubyminer.jpg)](https://research.checkpoint.com/2018/rubyminer-cryptominer-affects-30-ww-networks/)

* Check Point Research Publications

January 11, 2018
### ‘RubyMiner’ Cryptominer Affects 30% of WW Networks

[![](https://research.checkpoint.com/wp-content/uploads/2022/12/CheckPointResearchLogo_white-1-e1671590634727.png)](https://research.checkpoint.com)

* Publications
  + [Global cyber attack reports](/category/threat-intelligence-reports/)
  + [Research publications](/category/threat-research/)
  + [IPS advisories](https://advisories.checkpoint.com/advisories/)
  + [Check point blog](https://blog.checkpoint.com/)
  + [Demos](/category/demos/)
* Tools
  + [Sandblast file analysis](http://threatemulation.checkpoint.com/)
  + [ThreatCloud](https://www.checkpoint.com/infinity/threatcloud/)
  + [Threat Intelligence](https://www.checkpoint.com/solutions/threat-intelligence-research/)
  + [Zero day protection](https://www.checkpoint.com/infinity/zero-day-protection/)
  + [Live threat map](https://threatmap.checkpoint.com/)
* [About Us](https://research.checkpoint.com/about-us/)
  + [Contact Us](https://research.checkpoint.com/contact/)

### Let’s get in touch

Subscribe for cpr blogs, news and more

[Subscribe Now](/subscription/)

© 1994-2024 Check Point Software Technologies LTD. All rights reserved.

Property of [CheckPoint.com](https://www.checkpoint.com/)

[Privacy Policy](/privacy-policy/)

![](https://research.checkpoint.com/wp-content/uploads/2022/10/popup-side-image.jpg)

## SUBSCRIBE TO CYBER INTELLIGENCE REPORTS

First Name

Last Name

Country—Please choose an option—ChinaIndiaUnited StatesIndonesiaBrazilPakistanNigeriaBangladeshRussiaJapanMexicoPhilippinesVietnamEthiopiaEgyptGermanyIranTurkeyDemocratic Republic of the CongoThailandFranceUnited KingdomItalyBurmaSouth AfricaSouth KoreaColombiaSpainUkraineTanzaniaKenyaArgentinaAlgeriaPolandSudanUgandaCanadaIraqMoroccoPeruUzbekistanSaudi ArabiaMalaysiaVenezuelaNepalAfghanistanYemenNorth KoreaGhanaMozambiqueTaiwanAustraliaIvory CoastSyriaMadagascarAngolaCameroonSri LankaRomaniaBurkina FasoNigerKazakhstanNetherlandsChileMalawiEcuadorGuatemalaMaliCambodiaSenegalZambiaZimbabweChadSouth SudanBelgiumCubaTunisiaGuineaGreecePortugalRwandaCzech RepublicSomaliaHaitiBeninBurundiBoliviaHungarySwedenBelarusDominican RepublicAzerbaijanHondurasAustriaUnited Arab EmiratesIsraelSwitzerlandTajikistanBulgariaHong Kong (China)SerbiaPapua New GuineaParaguayLaosJordanEl SalvadorEritreaLibyaTogoSierra LeoneNicaraguaKyrgyzstanDenmarkFinlandSlovakiaSingaporeTurkmenistanNorwayLebanonCosta RicaCentral African RepublicIrelandGeorgiaNew ZealandRepublic of the CongoPalestineLiberiaCroatiaOmanBosnia and HerzegovinaPuerto RicoKuwaitMoldovMauritaniaPanamaUruguayArmeniaLithuaniaAlbaniaMongoliaJamaicaNamibiaLesothoQatarMacedoniaSloveniaBotswanaLatviaGambiaKosovoGuinea-BissauGabonEquatorial GuineaTrinidad and TobagoEstoniaMauritiusSwazilandBahrainTimor-LesteDjiboutiCyprusFijiReunion (France)GuyanaComorosBhutanMontenegroMacau (China)Solomon IslandsWestern SaharaLuxembourgSurinameCape VerdeMaltaGuadeloupe (France)Martinique (France)BruneiBahamasIcelandMaldivesBelizeBarbadosFrench Polynesia (France)VanuatuNew Caledonia (France)French Guiana (France)Mayotte (France)SamoaSao Tom and PrincipeSaint LuciaGuam (USA)Curacao (Netherlands)Saint Vincent and the GrenadinesKiribatiUnited States Virgin Islands (USA)GrenadaTongaAruba (Netherlands)Federated States of MicronesiaJersey (UK)SeychellesAntigua and BarbudaIsle of Man (UK)AndorraDominicaBermuda (UK)Guernsey (UK)Greenland (Denmark)Marshall IslandsAmerican Samoa (USA)Cayman Islands (UK)Saint Kitts and NevisNorthern Mariana Islands (USA)Faroe Islands (Denmark)Sint Maarten (Netherlands)Saint Martin (France)LiechtensteinMonacoSan MarinoTurks and Caicos Islands (UK)Gibraltar (UK)British Virgin Islands (UK)Aland Islands (Finland)Caribbean Netherlands (Netherlands)PalauCook Islands (NZ)Anguilla (UK)Wallis and Futuna (France)TuvaluNauruSaint Barthelemy (France)Saint Pierre and Miquelon (France)Montserrat (UK)Saint Helena, Ascension and Tristan da Cunha (UK)Svalbard and Jan Mayen (Norway)Falkland Islands (UK)Norfolk Island (Australia)Christmas Island (Australia)Niue (NZ)Tokelau (NZ)Vatican CityCocos (Keeling) Islands (Australia)Pitcairn Islands (UK)

Email

## We value your privacy!

BFSI uses cookies on this site. We use cookies to enable faster and easier experience for you. By continuing to visit this website you agree to our use of cookies.

ACCEPT
REJECT



=== Content from helpx.adobe.com_331edde8_20250124_153516.html ===


# Adobe Security Bulletin

Search

User Guide

Select an article:
Select an article:

On this page

* [Summary](#summary)
* [Affected Versions](#AffectedVersions)
* [Solution](#Solution)
* [Vulnerability Details](#VulnerabilityDetails)
* [Acknowledgements](#Acknowledgements)

![](/shared/article-3/alert.svg)

某些 Creative Cloud 应用程序、服务和功能在中国不可用。

[![](/shared/article-3/asurion_banner_final.jpg)](https://asurion.com/adobe/?utm_source=adobe&utm_medium=bannerad&utm_campaign=adobesupport)

Security Bulletin for Adobe Acrobat and Reader | APSB18-21

| **Bulletin ID** | **Date Published** | **Priority** |
| --- | --- | --- |
| APSB18-21 | July 10, 2018 | 2 |

## Summary

Adobe has released security updates for Adobe Acrobat and Reader for Windows and macOS. These updates address [critical](https://helpx.adobe.com/security/severity-ratings.html) and [important](https://helpx.adobe.com/security/severity-ratings.html) vulnerabilities.  Successful exploitation could lead to arbitrary code execution in the context of the current user.

## Affected Versions

| **Product** | **Track** | **Affected Versions** | **Platform** | **Priority rating** |
| --- | --- | --- | --- | --- |
| Acrobat DC | Continuous | 2018.011.20040 and earlier versions | Windows and macOS | 2 |
| Acrobat Reader DC | Continuous | 2018.011.20040 and earlier versions | Windows and macOS | 2 |
|  |  |  |  |  |
| Acrobat 2017 | Classic 2017 | 2017.011.30080 and earlier versions | Windows and macOS | 2 |
| Acrobat Reader 2017 | Classic 2017 | 2017.011.30080 and earlier versions | Windows and macOS | 2 |
|  |  |  |  |  |
| Acrobat DC | Classic 2015 | 2015.006.30418 and earlier versions | Windows and macOS | 2 |
| Acrobat Reader DC | Classic 2015 | 2015.006.30418 and earlier versions | Windows and macOS | 2 |

For questions regarding Acrobat DC, please visit the [Acrobat DC FAQ page](https://helpx.adobe.com/acrobat/faq.html).

For questions regarding Acrobat Reader DC, please visit the [Acrobat Reader](https://helpx.adobe.com/reader/faq.html)DC FAQ page.

## Solution

Adobe recommends users update their software installations to the latest versions by following the instructions below.

The latest product versions are available to end users via one of the following methods:

* Users can update their product installations manually by choosing Help > Check for Updates.
* The products will update automatically, without requiring user intervention, when updates are

  detected.
* The full Acrobat Reader installer can be downloaded from the [Acrobat Reader Download Center](https://get.adobe.com/reader/).

For IT administrators (managed environments):

* Download the enterprise installers from ftp://ftp.adobe.com/pub/adobe/, or refer to the specific release note version for links to installers.
* Install updates via your preferred methodology, such as AIP-GPO, bootstrapper, SCUP/SCCM (Windows), or on macOS, Apple Remote Desktop and SSH.

Adobe categorizes these updates with the following [priority ratings](https://helpx.adobe.com/security/severity-ratings.html) and recommends users update their installation to the newest version:

| **Product** | Track | **Updated Versions** | **Platform** | **Priority Rating** | **Availability** |
| --- | --- | --- | --- | --- | --- |
| Acrobat DC | Continuous | 2018.011.20055 | Windows and macOS | 2 | [Windows](https://www.adobe.com/support/downloads/product.jsp?product=1&platform=Windows) [macOS](https://www.adobe.com/support/downloads/product.jsp?product=1&platform=Mac) |
| Acrobat Reader DC | Continuous | 2018.011.20055 | Windows and macOS | 2 | [Windows](https://www.adobe.com/support/downloads/product.jsp?product=1&platform=Windows) [macOS](https://www.adobe.com/support/downloads/product.jsp?product=1&platform=Mac) |
|  |  |  |  |  |  |
| Acrobat 2017 | Classic 2017 | 2017.011.30096 | Windows and macOS | 2 | [Windows](https://www.adobe.com/support/downloads/product.jsp?product=1&platform=Windows) [macOS](https://www.adobe.com/support/downloads/product.jsp?product=1&platform=Mac) |
| Acrobat Reader DC 2017 | Classic 2017 | 2017.011.30096 | Windows and macOS | 2 | [Windows](https://www.adobe.com/support/downloads/product.jsp?product=1&platform=Windows) [macOS](https://www.adobe.com/support/downloads/product.jsp?product=1&platform=Mac) |
|  |  |  |  |  |  |
| Acrobat DC | Classic 2015 | 2015.006.30434 | Windows and macOS | 2 | [Windows](https://www.adobe.com/support/downloads/product.jsp?product=1&platform=Windows) [macOS](https://www.adobe.com/support/downloads/product.jsp?product=1&platform=Mac) |
| Acrobat Reader DC | Classic 2015 | 2015.006.30434 | Windows and macOS | 2 | [Windows](https://www.adobe.com/support/downloads/product.jsp?product=1&platform=Windows) [macOS](https://www.adobe.com/support/downloads/product.jsp?product=1&platform=Mac) |

Note:

As noted in this previous [announcement](https://helpx.adobe.com/acrobat/kb/end-of-support-acrobat-xi-reader-xi.html), support for Adobe Acrobat 11.x and Adobe Reader 11.x ended on October 15, 2017.  Version 11.0.23 is the final release for Adobe Acrobat 11.x and Adobe Reader 11.x.  Adobe strongly recommends that you update to the latest versions of Adobe Acrobat DC and Adobe Acrobat Reader DC. By updating installations to the latest versions, you benefit from the latest functional enhancements and improved security measures.

## Vulnerability Details

| **Vulnerability Category** | **Vulnerability Impact** | **Severity** | **CVE Number** |
| --- | --- | --- | --- |
| Double Free | Arbitrary Code Execution | Critical | CVE-2018-12782 |
| Heap Overflow | Arbitrary Code Execution | Critical | CVE-2018-5015, CVE-2018-5028,   CVE-2018-5032, CVE-2018-5036,   CVE-2018-5038, CVE-2018-5040,   CVE-2018-5041, CVE-2018-5045,   CVE-2018-5052, CVE-2018-5058,   CVE-2018-5067, CVE-2018-12785, CVE-2018-12788, CVE-2018-12798 |
| Use-after-free | Arbitrary Code Execution | Critical | CVE-2018-5009, CVE-2018-5011,   CVE-2018-5065, CVE-2018-12756, CVE-2018-12770, CVE-2018-12772, CVE-2018-12773, CVE-2018-12776, CVE-2018-12783, CVE-2018-12791, CVE-2018-12792, CVE-2018-12796, CVE-2018-12797 |
| Out-of-bounds write | Arbitrary Code Execution | Critical | CVE-2018-5020, CVE-2018-5021,   CVE-2018-5042, CVE-2018-5059,   CVE-2018-5064, CVE-2018-5069,   CVE-2018-5070, CVE-2018-12754, CVE-2018-12755, CVE-2018-12758, CVE-2018-12760, CVE-2018-12771, CVE-2018-12787 |
| Security Bypass | Privilege Escalation | Critical | CVE-2018-12802 |
| Out-of-bounds read | Information Disclosure | Important | CVE-2018-5010, CVE-2018-12803,  CVE-2018-5014, CVE-2018-5016, CVE-2018-5017, CVE-2018-5018, CVE-2018-5019, CVE-2018-5022, CVE-2018-5023, CVE-2018-5024, CVE-2018-5025, CVE-2018-5026, CVE-2018-5027, CVE-2018-5029, CVE-2018-5031, CVE-2018-5033, CVE-2018-5035, CVE-2018-5039, CVE-2018-5044, CVE-2018-5046, CVE-2018-5047, CVE-2018-5048, CVE-2018-5049, CVE-2018-5050, CVE-2018-5051, CVE-2018-5053, CVE-2018-5054, CVE-2018-5055, CVE-2018-5056, CVE-2018-5060, CVE-2018-5061, CVE-2018-5062, CVE-2018-5063, CVE-2018-5066, CVE-2018-5068, CVE-2018-12757, CVE-2018-12761, CVE-2018-12762, CVE-2018-12763, CVE-2018-12764, CVE-2018-12765, CVE-2018-12766, CVE-2018-12767, CVE-2018-12768, CVE-2018-12774, CVE-2018-12777, CVE-2018-12779, CVE-2018-12780, CVE-2018-12781, CVE-2018-12786, CVE-2018-12789, CVE-2018-12790, CVE-2018-12795 |
| Type Confusion | Arbitrary Code Execution | Critical | CVE-2018-5057, CVE-2018-12793, CVE-2018-12794 |
| Untrusted pointer dereference | Arbitrary Code Execution | Critical | CVE-2018-5012, CVE-2018-5030 |
| Buffer Errors | Arbitrary Code Execution | Critical | CVE-2018-5034, CVE-2018-5037, CVE-2018-5043, CVE-2018-12784 |

## Acknowledgements

Adobe would like to thank the following individuals and organizations for reporting the relevant issues and for working with Adobe to help protect our customers:

* Gal De Leon of Palo Alto Networks (CVE-2018-5009, CVE-2018-5066)

* Anonymously reported via Trend Micro's Zero Day Initiative (CVE-2018-12770, CVE-2018-12771, CVE-2018-12772, CVE-2018-12773, CVE-2018-12774, CVE-2018-12776, CVE-2018-12777, CVE-2018-12779, CVE-2018-12780, CVE-2018-12781, CVE-2018-12783,CVE-2018-12795, CVE-2018-12797, CVE-2018-5035)
* WillJ of Tencent PC Manager via Trend Micro's Zero Day Initiative (CVE-2018-5058, CVE-2018-5063, CVE-2018-5065)
* Steven Seeley via Trend Micro's Zero Day Initiative (CVE-2018-5012, CVE-2018-5030, CVE-2018-5033, CVE-2018-5034, CVE-2018-5035, CVE-2018-5059, CVE-2018-5060, CVE-2018-12793, CVE-2018-12796)
* Ke Liu of Tencent's Xuanwu LAB working via Trend Micro's Zero Day Initiative (CVE-2018-12803, CVE-2018-5014, CVE-2018-5015, CVE-2018-5016, CVE-2018-5017, CVE-2018-5018, CVE-2018-5019, CVE-2018-5020, CVE-2018-5027, CVE-2018-5028, CVE-2018-5029, CVE-2018-5031, CVE-2018-5032, CVE-2018-5055, CVE-2018-5056, CVE-2018-5057)
* Sebastian Apelt siberas via Trend Micro's Zero Day Initiative (CVE-2018-12794)

* Zhiyuan Wang of Chengdu Qihoo360 Tech Co. Ltd. (CVE-2018-12758)
* Lin Wang of Beihang University (CVE-2018-5010, CVE-2018-5020, CVE-2018-12760, CVE-2018-12761, CVE-2018-12762, CVE-2018-12763, CVE-2018-12787, CVE-2018-5067)
* Zhenjie Jia of Qihoo 360 Vulcan Team (CVE-2018-12757)
* Netanel Ben Simon and Yoav Alon from Check Point Software Technologies (CVE-2018-5063, CVE-2018-5064, CVE-2018-5065, CVE-2018-5068, CVE-2018-5069, CVE-2018-5070, CVE-2018-12754, CVE-2018-12755, CVE-2018-12764, CVE-2018-12765, CVE-2018-12766, CVE-2018-12767. CVE-2018-12768)
* Aleksandar Nikolic of Cisco Talos (CVE-2018-12756)

* Vladislav Stolyarov of Kaspersky Lab (CVE-2018-5011)
* Ke Liu of Tencent's Xuanwu Lab (CVE-2018-12785, CVE-2018-12786)
* Kdot via Trend Micro's Zero Day Initiative (CVE-2018-5036, CVE-2018-5037, CVE-2018-5038, CVE-2018-5039, CVE-2018-5040, CVE-2018-5041, CVE-2018-5042, CVE-2018-5043, CVE-2018-5044, CVE-2018-5045, CVE-2018-5046, CVE-2018-5047, CVE-2018-5048, CVE-2018-5049, CVE-2018-5050, CVE-2018-5051, CVE-2018-5052, CVE-2018-5053, CVE-2018-5054)
* Pengsu Cheng of Trend Micro working with Trend Micro's Zero Day Initiative (CVE-2018-5061, CVE-2018-5067, CVE-2018-12790, CVE-2018-5056)
* Ron Waisberg working with Trend Micro's Zero Day Initiative (CVE-2018-5062, CVE-2018-12788, CVE-2018-12789)

* Steven Seeley (mr\_me) of Source Incite working with iDefense Labs (CVE-2018-12791, CVE-2018-12792, CVE-2018-5015)
* Ashfaq Ansari and Sudhakar Verma - Project Srishti working with iDefense Labs (CVE-2018-12798)
* XuPeng of TCA/SKLCS Institute of Software Chinese Academy of Sciences and HuangZheng of Baidu Security Lab (CVE-2018-12782)
* Anonymously reported (CVE-2018-12784, CVE-2018-5009)

* mr\_me of Source Incite working with Trend Micro's Zero Day Initiative (CVE-2018-12761)
* Zhanglin He and Bo Qu of Palo Alto Networks (CVE-2018-5023, CVE-2018-5024)
* Bo Qu of Palo Alto Networks and Heige of Knownsec 404 Security Team (CVE-2018-5021, CVE-2018-5022, CVE-2018-5025, CVE-2018-5026)

### Ask the Community

Post questions and get answers from experts.

[Ask now](https://community.adobe.com/)

### Contact Us

Real help from real people.

[Start now](/contact.html)

^ Back to top

Was this page helpful?
Yes

No

No comment
Submit
By clicking Submit, you accept the [Adobe Terms of Use.](https://www.adobe.com/legal/terms.html)

Language Navigation

Language Navigation

Choose a region

Selecting a region changes the language and/or content on Adobe.com.

* Americas
* Brasil
* Canada - English
* Canada - Français
* Latinoamérica
* México
* Argentina
* Colombia
* Perú
* Chile
* United States
* Asia Pacific
* Australia
* Hong Kong S.A.R. of China
* India - English
* Indonesia - English
* Malaysia - English
* New Zealand
* Philippines - English
* Vietnam - English
* 中国
* 中國香港特別行政區
* 台灣地區
* 日本
* Indonesia
* Malaysia
* Pilipinas
* Việt Nam
* भारत
* 한국
* Singapore
* Thailand - English
* ประเทศไทย
* Europe, Middle East and Africa
* Africa - English
* België - Nederlands
* Belgique - Français
* Belgium - English
* Česká republika
* Danmark
* Deutschland
* Eesti
* España
* France
* Greece - English
* Ireland
* Israel - English
* Italia
* Latvija
* Lietuva
* Luxembourg - Deutsch
* Luxembourg - English
* Luxembourg - Français
* Magyarország
* Middle East and North Africa - English
* Nederland
* Norge
* Österreich
* Polska
* Portugal
* România
* Schweiz
* Slovenija
* Slovensko
* Suisse
* Suomi
* Svizzera
* Türkiye
* United Kingdom
* България
* Россия
* Україна
* الشرق الأوسط وشمال أفريقيا - اللغة العربية
* ישראל - עברית
* Sverige
* Saudi Arabia - English
* United Arab Emirates - English
* الإمارات العربية المتحدة
* المملكة العربية السعودية

Language Navigation

Language Navigation

Choose a region

Selecting a region changes the language and/or content on Adobe.com.

* Americas
* Brasil
* Canada - English
* Canada - Français
* Latinoamérica
* México
* Argentina
* Colombia
* Perú
* Chile
* United States
* Asia Pacific
* Australia
* Hong Kong S.A.R. of China
* India - English
* Indonesia - English
* Malaysia - English
* New Zealand
* Philippines - English
* Vietnam - English
* 中国
* 中國香港特別行政區
* 台灣地區
* 日本
* Indonesia
* Malaysia
* Pilipinas
* Việt Nam
* भारत
* 한국
* Singapore
* Thailand - English
* ประเทศไทย
* Europe, Middle East and Africa
* Africa - English
* België - Nederlands
* Belgique - Français
* Belgium - English
* Česká republika
* Danmark
* Deutschland
* Eesti
* España
* France
* Greece - English
* Ireland
* Israel - English
* Italia
* Latvija
* Lietuva
* Luxembourg - Deutsch
* Luxembourg - English
* Luxembourg - Français
* Magyarország
* Middle East and North Africa - English
* Nederland
* Norge
* Österreich
* Polska
* Portugal
* România
* Schweiz
* Slovenija
* Slovensko
* Suisse
* Suomi
* Svizzera
* Türkiye
* United Kingdom
* България
* Россия
* Україна
* الشرق الأوسط وشمال أفريقيا - اللغة العربية
* ישראל - עברית
* Sverige
* Saudi Arabia - English
* United Arab Emirates - English
* الإمارات العربية المتحدة
* المملكة العربية السعودية


