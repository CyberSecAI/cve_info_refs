```
{
  "CVE-2018-20482": {
    "description": "GNU Tar through 1.30, when --sparse is used, mishandles file shrinkage during read access, which allows local users to cause a denial of service (infinite read loop in sparse_dump_region in sparse.c) by modifying a file that is supposed to be archived by a different user's process (e.g., a system backup running as root).",
    "vulnerability_details": {
      "root_cause": "The `sparse_dump_region` function in `src/sparse.c` does not properly handle a situation where a file shrinks during the archiving process when the `--sparse` option is used. Specifically, it does not check for an early end-of-file condition returned by the `read()` system call, causing an infinite loop.",
      "weaknesses": [
        "Improper handling of the read system call return value.",
        "Lack of check for an unexpected end-of-file condition during file read when using the `--sparse` option."
      ],
       "impact": "A local attacker can cause a denial of service (DoS) by creating a file and then shrinking it while it is being backed up by another user's process, such as a system backup running as root. This leads to an infinite read loop in GNU Tar, writing a stream of null bytes and consuming resources.",
      "attack_vector": "Local access to the system is required.",
       "attacker_capabilities": "The attacker must have the ability to modify a file while it is being processed by a `tar` command running with the `--sparse` option.",
       "additional_details": "The vulnerability occurs because `sparse_dump_region` uses `safe_read` and only checks for error return, not an early EOF. The loop is only broken if the file grows back to its original size, or beyond. This issue is triggered even for non-sparse files if the `--sparse` argument is used. The fix includes handling a short read condition in `sparse_dump_region`, `sparse_extract_region`, and `check_data_region`."
    }
  }
}
```