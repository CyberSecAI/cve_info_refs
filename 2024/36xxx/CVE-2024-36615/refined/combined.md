=== Content from github.com_4456b106_20250115_094504.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fffmpeg%2Fffmpeg%2Fcommit%2F0ba058579f332b3060d8470a04ddd3fbf305be61)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fffmpeg%2Fffmpeg%2Fcommit%2F0ba058579f332b3060d8470a04ddd3fbf305be61)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fcommit_fragments%2Frepo_layout&source=header-repo&source_repo=FFmpeg%2FFFmpeg)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[FFmpeg](/FFmpeg)
/
**[FFmpeg](/FFmpeg/FFmpeg)**
Public

* [Notifications](/login?return_to=%2FFFmpeg%2FFFmpeg) You must be signed in to change notification settings
* [Fork
  12.3k](/login?return_to=%2FFFmpeg%2FFFmpeg)
* [Star
   47.3k](/login?return_to=%2FFFmpeg%2FFFmpeg)

* [Code](/FFmpeg/FFmpeg)
* [Pull requests
  1](/FFmpeg/FFmpeg/pulls)
* [Actions](/FFmpeg/FFmpeg/actions)
* [Security](/FFmpeg/FFmpeg/security)
* [Insights](/FFmpeg/FFmpeg/pulse)

Additional navigation options

* [Code](/FFmpeg/FFmpeg)
* [Pull requests](/FFmpeg/FFmpeg/pulls)
* [Actions](/FFmpeg/FFmpeg/actions)
* [Security](/FFmpeg/FFmpeg/security)
* [Insights](/FFmpeg/FFmpeg/pulse)

## Commit

[Permalink](/FFmpeg/FFmpeg/commit/0ba058579f332b3060d8470a04ddd3fbf305be61)

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

avcodec/vp9: Fix race when attaching side-data for show-existing frame

[Browse files](/FFmpeg/FFmpeg/tree/0ba058579f332b3060d8470a04ddd3fbf305be61)
Browse the repository at this point in the history

```
When outputting a show-existing frame, the VP9 decoder simply
created a reference to said frame and returned it immediately to
the caller, without waiting for it to have finished decoding.
In case of frame-threading it is possible for the frame to
only be decoded while it was waiting to be output.
This is normally benign.

But there is one case where it is not: If the user wants
video encoding parameters to be exported, said side data
will only be attached to the src AVFrame at the end of
decoding the frame that is actually being shown. Without
synchronisation adding said side data in the decoder thread
and the reads in av_frame_ref() in the output thread
constitute a data race. This happens e.g. when using the
venc_data_dump tool with vp90-2-10-show-existing-frame.webm
from the FATE-suite.

Fix this by actually waiting for the frame to be output.

Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
```

* Loading branch information

[![@mkver](https://avatars.githubusercontent.com/u/18448094?s=40&v=4)](/mkver)

[mkver](/FFmpeg/FFmpeg/commits?author=mkver "View all commits by mkver")
committed
Apr 19, 2024

1 parent
[7bd3b73](/FFmpeg/FFmpeg/commit/7bd3b7371632250a2fbc38bee6597b0aa189346a)

commit 0ba0585

Showing
**1 changed file**
with
**11 additions**
and
**7 deletions**.

* Whitespace
* Ignore whitespace

* Split
* Unified

## There are no files selected for viewing

18 changes: 11 additions & 7 deletions

18
[libavcodec/vp9.c](#diff-afda4df40acfae54302888a747226e84fdcba7a02331a817c3ae086da177e806 "libavcodec/vp9.c")

Show comments

[View file](/FFmpeg/FFmpeg/blob/0ba058579f332b3060d8470a04ddd3fbf305be61/libavcodec/vp9.c)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -1569,6 +1569,8 @@ static int vp9\_decode\_frame(AVCodecContext \*avctx, AVFrame \*frame, |
|  |  | av\_log(avctx, AV\_LOG\_ERROR, "Requested reference %d not available\n", ref); |
|  |  | return AVERROR\_INVALIDDATA; |
|  |  | } |
|  |  | ff\_progress\_frame\_await(&s->s.refs[ref], INT\_MAX); |
|  |  |  |
|  |  | if ((ret = av\_frame\_ref(frame, s->s.refs[ref].f)) < 0) |
|  |  | return ret; |
|  |  | frame->pts = pkt->pts; |
| Expand Down  Expand Up | | @@ -1715,10 +1717,8 @@ static int vp9\_decode\_frame(AVCodecContext \*avctx, AVFrame \*frame, |
|  |  | #endif |
|  |  | { |
|  |  | ret = decode\_tiles(avctx, data, size); |
|  |  | if (ret < 0) { |
|  |  | ff\_progress\_frame\_report(&s->s.frames[CUR\_FRAME].tf, INT\_MAX); |
|  |  | return ret; |
|  |  | } |
|  |  | if (ret < 0) |
|  |  | goto fail; |
|  |  | } |
|  |  |  |
|  |  | // Sum all counts fields into td[0].counts for tile threading |
| Expand All | | @@ -1732,18 +1732,19 @@ static int vp9\_decode\_frame(AVCodecContext \*avctx, AVFrame \*frame, |
|  |  | ff\_thread\_finish\_setup(avctx); |
|  |  | } |
|  |  | } while (s->pass++ == 1); |
|  |  | ff\_progress\_frame\_report(&s->s.frames[CUR\_FRAME].tf, INT\_MAX); |
|  |  |  |
|  |  | if (s->td->error\_info < 0) { |
|  |  | av\_log(avctx, AV\_LOG\_ERROR, "Failed to decode tile data\n"); |
|  |  | s->td->error\_info = 0; |
|  |  | return AVERROR\_INVALIDDATA; |
|  |  | ret = AVERROR\_INVALIDDATA; |
|  |  | goto fail; |
|  |  | } |
|  |  | if (avctx->export\_side\_data & AV\_CODEC\_EXPORT\_DATA\_VIDEO\_ENC\_PARAMS) { |
|  |  | ret = vp9\_export\_enc\_params(s, &s->s.frames[CUR\_FRAME]); |
|  |  | if (ret < 0) |
|  |  | return ret; |
|  |  | goto fail; |
|  |  | } |
|  |  | ff\_progress\_frame\_report(&s->s.frames[CUR\_FRAME].tf, INT\_MAX); |
|  |  |  |
|  |  | finish: |
|  |  | // ref frame setup |
| Expand All | | @@ -1757,6 +1758,9 @@ static int vp9\_decode\_frame(AVCodecContext \*avctx, AVFrame \*frame, |
|  |  | } |
|  |  |  |
|  |  | return pkt->size; |
|  |  | fail: |
|  |  | ff\_progress\_frame\_report(&s->s.frames[CUR\_FRAME].tf, INT\_MAX); |
|  |  | return ret; |
|  |  | } |
|  |  |  |
|  |  | static void vp9\_decode\_flush(AVCodecContext \*avctx) |
| Expand Down | |  |

Toggle all file notes
Toggle all file annotations

### 0 comments on commit `0ba0585`

Please
[sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fffmpeg%2Fffmpeg%2Fcommit%2F0ba058579f332b3060d8470a04ddd3fbf305be61) to comment.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_51105aaa_20250115_094502.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FFFmpeg%2FFFmpeg%2Fblob%2Fn7.0%2Flibavcodec%2Fvp9.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FFFmpeg%2FFFmpeg%2Fblob%2Fn7.0%2Flibavcodec%2Fvp9.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=FFmpeg%2FFFmpeg)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[FFmpeg](/FFmpeg)
/
**[FFmpeg](/FFmpeg/FFmpeg)**
Public

* [Notifications](/login?return_to=%2FFFmpeg%2FFFmpeg) You must be signed in to change notification settings
* [Fork
  12.3k](/login?return_to=%2FFFmpeg%2FFFmpeg)
* [Star
   47.3k](/login?return_to=%2FFFmpeg%2FFFmpeg)

* [Code](/FFmpeg/FFmpeg/tree/n7.0)
* [Pull requests
  1](/FFmpeg/FFmpeg/pulls)
* [Actions](/FFmpeg/FFmpeg/actions)
* [Security](/FFmpeg/FFmpeg/security)
* [Insights](/FFmpeg/FFmpeg/pulse)

Additional navigation options

* [Code](/FFmpeg/FFmpeg/tree/n7.0)
* [Pull requests](/FFmpeg/FFmpeg/pulls)
* [Actions](/FFmpeg/FFmpeg/actions)
* [Security](/FFmpeg/FFmpeg/security)
* [Insights](/FFmpeg/FFmpeg/pulse)

## Files

 n7.0
## Breadcrumbs

1. [FFmpeg](/FFmpeg/FFmpeg/tree/n7.0)
2. /[libavcodec](/FFmpeg/FFmpeg/tree/n7.0/libavcodec)
/
# vp9.c

Copy path Blame  Blame
## Latest commit

## History

[History](/FFmpeg/FFmpeg/commits/n7.0/libavcodec/vp9.c)1923 lines (1738 loc) · 74.5 KB n7.0
## Breadcrumbs

1. [FFmpeg](/FFmpeg/FFmpeg/tree/n7.0)
2. /[libavcodec](/FFmpeg/FFmpeg/tree/n7.0/libavcodec)
/
# vp9.c

Top
## File metadata and controls

* Code
* Blame

1923 lines (1738 loc) · 74.5 KB[Raw](https://github.com/FFmpeg/FFmpeg/raw/refs/tags/n7.0/libavcodec/vp9.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* VP9 compatible video decoder \* \* Copyright (C) 2013 Ronald S. Bultje <rsbultje gmail com> \* Copyright (C) 2013 Clément Bœsch <u pkh me> \* \* This file is part of FFmpeg. \* \* FFmpeg is free software; you can redistribute it and/or \* modify it under the terms of the GNU Lesser General Public \* License as published by the Free Software Foundation; either \* version 2.1 of the License, or (at your option) any later version. \* \* FFmpeg is distributed in the hope that it will be useful, \* but WITHOUT ANY WARRANTY; without even the implied warranty of \* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU \* Lesser General Public License for more details. \* \* You should have received a copy of the GNU Lesser General Public \* License along with FFmpeg; if not, write to the Free Software \* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA \*/
#include "config\_components.h"
#include "avcodec.h"#include "codec\_internal.h"#include "decode.h"#include "get\_bits.h"#include "hwaccel\_internal.h"#include "hwconfig.h"#include "profiles.h"#include "refstruct.h"#include "thread.h"#include "threadframe.h"#include "pthread\_internal.h"
#include "videodsp.h"#include "vp89\_rac.h"#include "vp9.h"#include "vp9data.h"#include "vp9dec.h"#include "vpx\_rac.h"#include "libavutil/avassert.h"#include "libavutil/pixdesc.h"#include "libavutil/video\_enc\_params.h"
#define VP9\_SYNCCODE 0x498342
#if HAVE\_THREADSDEFINE\_OFFSET\_ARRAY(VP9Context, vp9\_context, pthread\_init\_cnt, (offsetof(VP9Context, progress\_mutex)), (offsetof(VP9Context, progress\_cond)));
static int vp9\_alloc\_entries(AVCodecContext \*avctx, int n) { VP9Context \*s = avctx->priv\_data; int i;
 if (avctx->active\_thread\_type & FF\_THREAD\_SLICE) { if (s->entries) av\_freep(&s->entries);
 s->entries = av\_malloc\_array(n, sizeof(atomic\_int)); if (!s->entries) return AVERROR(ENOMEM);
 for (i = 0; i < n; i++) atomic\_init(&s->entries[i], 0); } return 0;}
static void vp9\_report\_tile\_progress(VP9Context \*s, int field, int n) { pthread\_mutex\_lock(&s->progress\_mutex); atomic\_fetch\_add\_explicit(&s->entries[field], n, memory\_order\_release); pthread\_cond\_signal(&s->progress\_cond); pthread\_mutex\_unlock(&s->progress\_mutex);}
static void vp9\_await\_tile\_progress(VP9Context \*s, int field, int n) { if (atomic\_load\_explicit(&s->entries[field], memory\_order\_acquire) >= n) return;
 pthread\_mutex\_lock(&s->progress\_mutex); while (atomic\_load\_explicit(&s->entries[field], memory\_order\_relaxed) != n) pthread\_cond\_wait(&s->progress\_cond, &s->progress\_mutex); pthread\_mutex\_unlock(&s->progress\_mutex);}#elsestatic int vp9\_alloc\_entries(AVCodecContext \*avctx, int n) { return 0; }#endif
static void vp9\_tile\_data\_free(VP9TileData \*td){ av\_freep(&td->b\_base); av\_freep(&td->block\_base); av\_freep(&td->block\_structure);}
static void vp9\_frame\_unref(VP9Frame \*f){ ff\_thread\_release\_ext\_buffer(&f->tf); ff\_refstruct\_unref(&f->extradata); ff\_refstruct\_unref(&f->hwaccel\_picture\_private); f->segmentation\_map = NULL;}
static int vp9\_frame\_alloc(AVCodecContext \*avctx, VP9Frame \*f){ VP9Context \*s = avctx->priv\_data; int ret, sz;
 ret = ff\_thread\_get\_ext\_buffer(avctx, &f->tf, AV\_GET\_BUFFER\_FLAG\_REF); if (ret < 0) return ret;
 sz = 64 \* s->sb\_cols \* s->sb\_rows; if (sz != s->frame\_extradata\_pool\_size) { ff\_refstruct\_pool\_uninit(&s->frame\_extradata\_pool); s->frame\_extradata\_pool = ff\_refstruct\_pool\_alloc(sz \* (1 + sizeof(VP9mvrefPair)), FF\_REFSTRUCT\_POOL\_FLAG\_ZERO\_EVERY\_TIME); if (!s->frame\_extradata\_pool) { s->frame\_extradata\_pool\_size = 0; ret = AVERROR(ENOMEM); goto fail; } s->frame\_extradata\_pool\_size = sz; } f->extradata = ff\_refstruct\_pool\_get(s->frame\_extradata\_pool); if (!f->extradata) { ret = AVERROR(ENOMEM); goto fail; }
 f->segmentation\_map = f->extradata; f->mv = (VP9mvrefPair \*) ((char\*)f->extradata + sz);
 ret = ff\_hwaccel\_frame\_priv\_alloc(avctx, &f->hwaccel\_picture\_private); if (ret < 0) goto fail;
 return 0;
fail: vp9\_frame\_unref(f); return ret;}
static int vp9\_frame\_ref(VP9Frame \*dst, VP9Frame \*src){ int ret;
 ret = ff\_thread\_ref\_frame(&dst->tf, &src->tf); if (ret < 0) return ret;
 dst->extradata = ff\_refstruct\_ref(src->extradata);
 dst->segmentation\_map = src->segmentation\_map; dst->mv = src->mv; dst->uses\_2pass = src->uses\_2pass;
 ff\_refstruct\_replace(&dst->hwaccel\_picture\_private, src->hwaccel\_picture\_private);
 return 0;}
static int update\_size(AVCodecContext \*avctx, int w, int h){#define HWACCEL\_MAX (CONFIG\_VP9\_DXVA2\_HWACCEL + \ CONFIG\_VP9\_D3D11VA\_HWACCEL \* 2 + \ CONFIG\_VP9\_D3D12VA\_HWACCEL + \ CONFIG\_VP9\_NVDEC\_HWACCEL + \ CONFIG\_VP9\_VAAPI\_HWACCEL + \ CONFIG\_VP9\_VDPAU\_HWACCEL + \ CONFIG\_VP9\_VIDEOTOOLBOX\_HWACCEL) enum AVPixelFormat pix\_fmts[HWACCEL\_MAX + 2], \*fmtp = pix\_fmts; VP9Context \*s = avctx->priv\_data; uint8\_t \*p; int bytesperpixel = s->bytesperpixel, ret, cols, rows; int lflvl\_len, i;
 av\_assert0(w > 0 && h > 0);
 if (!(s->pix\_fmt == s->gf\_fmt && w == s->w && h == s->h)) { if ((ret = ff\_set\_dimensions(avctx, w, h)) < 0) return ret;
 switch (s->pix\_fmt) { case AV\_PIX\_FMT\_YUV420P: case AV\_PIX\_FMT\_YUV420P10:#if CONFIG\_VP9\_DXVA2\_HWACCEL \*fmtp++ = AV\_PIX\_FMT\_DXVA2\_VLD;#endif#if CONFIG\_VP9\_D3D11VA\_HWACCEL \*fmtp++ = AV\_PIX\_FMT\_D3D11VA\_VLD; \*fmtp++ = AV\_PIX\_FMT\_D3D11;#endif#if CONFIG\_VP9\_D3D12VA\_HWACCEL \*fmtp++ = AV\_PIX\_FMT\_D3D12;#endif#if CONFIG\_VP9\_NVDEC\_HWACCEL \*fmtp++ = AV\_PIX\_FMT\_CUDA;#endif#if CONFIG\_VP9\_VAAPI\_HWACCEL \*fmtp++ = AV\_PIX\_FMT\_VAAPI;#endif#if CONFIG\_VP9\_VDPAU\_HWACCEL \*fmtp++ = AV\_PIX\_FMT\_VDPAU;#endif#if CONFIG\_VP9\_VIDEOTOOLBOX\_HWACCEL \*fmtp++ = AV\_PIX\_FMT\_VIDEOTOOLBOX;#endif break; case AV\_PIX\_FMT\_YUV420P12:#if CONFIG\_VP9\_NVDEC\_HWACCEL \*fmtp++ = AV\_PIX\_FMT\_CUDA;#endif#if CONFIG\_VP9\_VAAPI\_HWACCEL \*fmtp++ = AV\_PIX\_FMT\_VAAPI;#endif#if CONFIG\_VP9\_VDPAU\_HWACCEL \*fmtp++ = AV\_PIX\_FMT\_VDPAU;#endif break; case AV\_PIX\_FMT\_YUV444P: case AV\_PIX\_FMT\_YUV444P10: case AV\_PIX\_FMT\_YUV444P12:#if CONFIG\_VP9\_VAAPI\_HWACCEL \*fmtp++ = AV\_PIX\_FMT\_VAAPI;#endif break; case AV\_PIX\_FMT\_GBRP: case AV\_PIX\_FMT\_GBRP10: case AV\_PIX\_FMT\_GBRP12:#if CONFIG\_VP9\_VAAPI\_HWACCEL \*fmtp++ = AV\_PIX\_FMT\_VAAPI;#endif break; }
 \*fmtp++ = s->pix\_fmt; \*fmtp = AV\_PIX\_FMT\_NONE;
 ret = ff\_get\_format(avctx, pix\_fmts); if (ret < 0) return ret;
 avctx->pix\_fmt = ret; s->gf\_fmt = s->pix\_fmt; s->w = w; s->h = h; }
 cols = (w + 7) >> 3; rows = (h + 7) >> 3;
 if (s->intra\_pred\_data[0] && cols == s->cols && rows == s->rows && s->pix\_fmt == s->last\_fmt) return 0;
 s->last\_fmt = s->pix\_fmt; s->sb\_cols = (w + 63) >> 6; s->sb\_rows = (h + 63) >> 6; s->cols = (w + 7) >> 3; s->rows = (h + 7) >> 3; lflvl\_len = avctx->active\_thread\_type == FF\_THREAD\_SLICE ? s->sb\_rows : 1;
#define assign(var, type, n) var = (type) p; p += s->sb\_cols \* (n) \* sizeof(\*var) av\_freep(&s->intra\_pred\_data[0]); // FIXME we slightly over-allocate here for subsampled chroma, but a little // bit of padding shouldn't affect performance... p = av\_malloc(s->sb\_cols \* (128 + 192 \* bytesperpixel + lflvl\_len \* sizeof(\*s->lflvl) + 16 \* sizeof(\*s->above\_mv\_ctx))); if (!p) return AVERROR(ENOMEM); assign(s->intra\_pred\_data[0], uint8\_t \*, 64 \* bytesperpixel); assign(s->intra\_pred\_data[1], uint8\_t \*, 64 \* bytesperpixel); assign(s->intra\_pred\_data[2], uint8\_t \*, 64 \* bytesperpixel); assign(s->above\_y\_nnz\_ctx, uint8\_t \*, 16); assign(s->above\_mode\_ctx, uint8\_t \*, 16); assign(s->above\_mv\_ctx, VP9mv(\*)[2], 16); assign(s->above\_uv\_nnz\_ctx[0], uint8\_t \*, 16); assign(s->above\_uv\_nnz\_ctx[1], uint8\_t \*, 16); assign(s->above\_partition\_ctx, uint8\_t \*, 8); assign(s->above\_skip\_ctx, uint8\_t \*, 8); assign(s->above\_txfm\_ctx, uint8\_t \*, 8); assign(s->above\_segpred\_ctx, uint8\_t \*, 8); assign(s->above\_intra\_ctx, uint8\_t \*, 8); assign(s->above\_comp\_ctx, uint8\_t \*, 8); assign(s->above\_ref\_ctx, uint8\_t \*, 8); assign(s->above\_filter\_ctx, uint8\_t \*, 8); assign(s->lflvl, VP9Filter \*, lflvl\_len);#undef assign
 if (s->td) { for (i = 0; i < s->active\_tile\_cols; i++) vp9\_tile\_data\_free(&s->td[i]); }
 if (s->s.h.bpp != s->last\_bpp) { ff\_vp9dsp\_init(&s->dsp, s->s.h.bpp, avctx->flags & AV\_CODEC\_FLAG\_BITEXACT); ff\_videodsp\_init(&s->vdsp, s->s.h.bpp); s->last\_bpp = s->s.h.bpp; }
 return 0;}
static int update\_block\_buffers(AVCodecContext \*avctx){ int i; VP9Context \*s = avctx->priv\_data; int chroma\_blocks, chroma\_eobs, bytesperpixel = s->bytesperpixel; VP9TileData \*td = &s->td[0];
 if (td->b\_base && td->block\_base && s->block\_alloc\_using\_2pass == s->s.frames[CUR\_FRAME].uses\_2pass) return 0;
 vp9\_tile\_data\_free(td); chroma\_blocks = 64 \* 64 >> (s->ss\_h + s->ss\_v); chroma\_eobs = 16 \* 16 >> (s->ss\_h + s->ss\_v); if (s->s.frames[CUR\_FRAME].uses\_2pass) { int sbs = s->sb\_cols \* s->sb\_rows;
 td->b\_base = av\_malloc\_array(s->cols \* s->rows, sizeof(VP9Block)); td->block\_base = av\_mallocz(((64 \* 64 + 2 \* chroma\_blocks) \* bytesperpixel \* sizeof(int16\_t) + 16 \* 16 + 2 \* chroma\_eobs) \* sbs); if (!td->b\_base || !td->block\_base) return AVERROR(ENOMEM); td->uvblock\_base[0] = td->block\_base + sbs \* 64 \* 64 \* bytesperpixel; td->uvblock\_base[1] = td->uvblock\_base[0] + sbs \* chroma\_blocks \* bytesperpixel; td->eob\_base = (uint8\_t \*) (td->uvblock\_base[1] + sbs \* chroma\_blocks \* bytesperpixel); td->uveob\_base[0] = td->eob\_base + 16 \* 16 \* sbs; td->uveob\_base[1] = td->uveob\_base[0] + chroma\_eobs \* sbs;
 if (avctx->export\_side\_data & AV\_CODEC\_EXPORT\_DATA\_VIDEO\_ENC\_PARAMS) { td->block\_structure = av\_malloc\_array(s->cols \* s->rows, sizeof(\*td->block\_structure)); if (!td->block\_structure) return AVERROR(ENOMEM); } } else { for (i = 1; i < s->active\_tile\_cols; i++) vp9\_tile\_data\_free(&s->td[i]);
 for (i = 0; i < s->active\_tile\_cols; i++) { s->td[i].b\_base = av\_malloc(sizeof(VP9Block)); s->td[i].block\_base = av\_mallocz((64 \* 64 + 2 \* chroma\_blocks) \* bytesperpixel \* sizeof(int16\_t) + 16 \* 16 + 2 \* chroma\_eobs); if (!s->td[i].b\_base || !s->td[i].block\_base) return AVERROR(ENOMEM); s->td[i].uvblock\_base[0] = s->td[i].block\_base + 64 \* 64 \* bytesperpixel; s->td[i].uvblock\_base[1] = s->td[i].uvblock\_base[0] + chroma\_blocks \* bytesperpixel; s->td[i].eob\_base = (uint8\_t \*) (s->td[i].uvblock\_base[1] + chroma\_blocks \* bytesperpixel); s->td[i].uveob\_base[0] = s->td[i].eob\_base + 16 \* 16; s->td[i].uveob\_base[1] = s->td[i].uveob\_base[0] + chroma\_eobs;
 if (avctx->export\_side\_data & AV\_CODEC\_EXPORT\_DATA\_VIDEO\_ENC\_PARAMS) { s->td[i].block\_structure = av\_malloc\_array(s->cols \* s->rows, sizeof(\*td->block\_structure)); if (!s->td[i].block\_structure) return AVERROR(ENOMEM); } } } s->block\_alloc\_using\_2pass = s->s.frames[CUR\_FRAME].uses\_2pass;
 return 0;}
// The sign bit is at the end, not the start, of a bit sequencestatic av\_always\_inline int get\_sbits\_inv(GetBitContext \*gb, int n){ int v = get\_bits(gb, n); return get\_bits1(gb) ? -v : v;}
static av\_always\_inline int inv\_recenter\_nonneg(int v, int m){ if (v > 2 \* m) return v; if (v & 1) return m - ((v + 1) >> 1); return m + (v >> 1);}
// differential forward probability updatesstatic int update\_prob(VPXRangeCoder \*c, int p){ static const uint8\_t inv\_map\_table[255] = { 7, 20, 33, 46, 59, 72, 85, 98, 111, 124, 137, 150, 163, 176, 189, 202, 215, 228, 241, 254, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 253, }; int d;
 /\* This code is trying to do a differential probability update. For a \* current probability A in the range [1, 255], the difference to a new \* probability of any value can be expressed differentially as 1-A, 255-A \* where some part of this (absolute range) exists both in positive as \* well as the negative part, whereas another part only exists in one \* half. We're trying to code this shared part differentially, i.e. \* times two where the value of the lowest bit specifies the sign, and \* the single part is then coded on top of this. This absolute difference \* then again has a value of [0, 254], but a bigger value in this range \* indicates that we're further away from the original value A, so we \* can code this as a VLC code, since higher values are increasingly \* unlikely. The first 20 values in inv\_map\_table[] allow 'cheap, rough' \* updates vs. the 'fine, exact' updates further down the range, which \* adds one extra dimension to this differential update model. \*/
 if (!vp89\_rac\_get(c)) { d = vp89\_rac\_get\_uint(c, 4) + 0; } else if (!vp89\_rac\_get(c)) { d = vp89\_rac\_get\_uint(c, 4) + 16; } else if (!vp89\_rac\_get(c)) { d = vp89\_rac\_get\_uint(c, 5) + 32; } else { d = vp89\_rac\_get\_uint(c, 7); if (d >= 65) d = (d << 1) - 65 + vp89\_rac\_get(c); d += 64; av\_assert2(d < FF\_ARRAY\_ELEMS(inv\_map\_table)); }
 return p <= 128 ? 1 + inv\_recenter\_nonneg(inv\_map\_table[d], p - 1) : 255 - inv\_recenter\_nonneg(inv\_map\_table[d], 255 - p);}
static int read\_colorspace\_details(AVCodecContext \*avctx){ static const enum AVColorSpace colorspaces[8] = { AVCOL\_SPC\_UNSPECIFIED, AVCOL\_SPC\_BT470BG, AVCOL\_SPC\_BT709, AVCOL\_SPC\_SMPTE170M, AVCOL\_SPC\_SMPTE240M, AVCOL\_SPC\_BT2020\_NCL, AVCOL\_SPC\_RESERVED, AVCOL\_SPC\_RGB, }; VP9Context \*s = avctx->priv\_data; int bits = avctx->profile <= 1 ? 0 : 1 + get\_bits1(&s->gb); // 0:8, 1:10, 2:12
 s->bpp\_index = bits; s->s.h.bpp = 8 + bits \* 2; s->bytesperpixel = (7 + s->s.h.bpp) >> 3; avctx->colorspace = colorspaces[get\_bits(&s->gb, 3)]; if (avctx->colorspace == AVCOL\_SPC\_RGB) { // RGB = profile 1 static const enum AVPixelFormat pix\_fmt\_rgb[3] = { AV\_PIX\_FMT\_GBRP, AV\_PIX\_FMT\_GBRP10, AV\_PIX\_FMT\_GBRP12 }; s->ss\_h = s->ss\_v = 0; avctx->color\_range = AVCOL\_RANGE\_JPEG; s->pix\_fmt = pix\_fmt\_rgb[bits]; if (avctx->profile & 1) { if (get\_bits1(&s->gb)) { av\_log(avctx, AV\_LOG\_ERROR, "Reserved bit set in RGB\n"); return AVERROR\_INVALIDDATA; } } else { av\_log(avctx, AV\_LOG\_ERROR, "RGB not supported in profile %d\n", avctx->profile); return AVERROR\_INVALIDDATA; } } else { static const enum AVPixelFormat pix\_fmt\_for\_ss[3][2 /\* v \*/][2 /\* h \*/] = { { { AV\_PIX\_FMT\_YUV444P, AV\_PIX\_FMT\_YUV422P }, { AV\_PIX\_FMT\_YUV440P, AV\_PIX\_FMT\_YUV420P } }, { { AV\_PIX\_FMT\_YUV444P10, AV\_PIX\_FMT\_YUV422P10 }, { AV\_PIX\_FMT\_YUV440P10, AV\_PIX\_FMT\_YUV420P10 } }, { { AV\_PIX\_FMT\_YUV444P12, AV\_PIX\_FMT\_YUV422P12 }, { AV\_PIX\_FMT\_YUV440P12, AV\_PIX\_FMT\_YUV420P12 } } }; avctx->color\_range = get\_bits1(&s->gb) ? AVCOL\_RANGE\_JPEG : AVCOL\_RANGE\_MPEG; if (avctx->profile & 1) { s->ss\_h = get\_bits1(&s->gb); s->ss\_v = get\_bits1(&s->gb); s->pix\_fmt = pix\_fmt\_for\_ss[bits][s->ss\_v][s->ss\_h]; if (s->pix\_fmt == AV\_PIX\_FMT\_YUV420P) { av\_log(avctx, AV\_LOG\_ERROR, "YUV 4:2:0 not supported in profile %d\n", avctx->profile); return AVERROR\_INVALIDDATA; } else if (get\_bits1(&s->gb)) { av\_log(avctx, AV\_LOG\_ERROR, "Profile %d color details reserved bit set\n", avctx->profile); return AVERROR\_INVALIDDATA; } } else { s->ss\_h = s->ss\_v = 1; s->pix\_fmt = pix\_fmt\_for\_ss[bits][1][1]; } }
 return 0;}
static int decode\_frame\_header(AVCodecContext \*avctx, const uint8\_t \*data, int size, int \*ref){ VP9Context \*s = avctx->priv\_data; int c, i, j, k, l, m, n, w, h, max, size2, ret, sharp; int last\_invisible; const uint8\_t \*data2;
 /\* general header \*/ if ((ret = init\_get\_bits8(&s->gb, data, size)) < 0) { av\_log(avctx, AV\_LOG\_ERROR, "Failed to initialize bitstream reader\n"); return ret; } if (get\_bits(&s->gb, 2) != 0x2) { // frame marker av\_log(avctx, AV\_LOG\_ERROR, "Invalid frame marker\n"); return AVERROR\_INVALIDDATA; } avctx->profile = get\_bits1(&s->gb); avctx->profile |= get\_bits1(&s->gb) << 1; if (avctx->profile == 3) avctx->profile += get\_bits1(&s->gb); if (avctx->profile > 3) { av\_log(avctx, AV\_LOG\_ERROR, "Profile %d is not yet supported\n", avctx->profile); return AVERROR\_INVALIDDATA; } s->s.h.profile = avctx->profile; if (get\_bits1(&s->gb)) { \*ref = get\_bits(&s->gb, 3); return 0; }
 s->last\_keyframe = s->s.h.keyframe; s->s.h.keyframe = !get\_bits1(&s->gb);
 last\_invisible = s->s.h.invisible; s->s.h.invisible = !get\_bits1(&s->gb); s->s.h.errorres = get\_bits1(&s->gb); s->s.h.use\_last\_frame\_mvs = !s->s.h.errorres && !last\_invisible;
 if (s->s.h.keyframe) { if (get\_bits(&s->gb, 24) != VP9\_SYNCCODE) { // synccode av\_log(avctx, AV\_LOG\_ERROR, "Invalid sync code\n"); return AVERROR\_INVALIDDATA; } if ((ret = read\_colorspace\_details(avctx)) < 0) return ret; // for profile 1, here follows the subsampling bits s->s.h.refreshrefmask = 0xff; w = get\_bits(&s->gb, 16) + 1; h = get\_bits(&s->gb, 16) + 1; if (get\_bits1(&s->gb)) // display size skip\_bits(&s->gb, 32); } else { s->s.h.intraonly = s->s.h.invisible ? get\_bits1(&s->gb) : 0; s->s.h.resetctx = s->s.h.errorres ? 0 : get\_bits(&s->gb, 2); if (s->s.h.intraonly) { if (get\_bits(&s->gb, 24) != VP9\_SYNCCODE) { // synccode av\_log(avctx, AV\_LOG\_ERROR, "Invalid sync code\n"); return AVERROR\_INVALIDDATA; } if (avctx->profile >= 1) { if ((ret = read\_colorspace\_details(avctx)) < 0) return ret; } else { s->ss\_h = s->ss\_v = 1; s->s.h.bpp = 8; s->bpp\_index = 0; s->bytesperpixel = 1; s->pix\_fmt = AV\_PIX\_FMT\_YUV420P; avctx->colorspace = AVCOL\_SPC\_BT470BG; avctx->color\_range = AVCOL\_RANGE\_MPEG; } s->s.h.refreshrefmask = get\_bits(&s->gb, 8); w = get\_bits(&s->gb, 16) + 1; h = get\_bits(&s->gb, 16) + 1; if (get\_bits1(&s->gb)) // display size skip\_bits(&s->gb, 32); } else { s->s.h.refreshrefmask = get\_bits(&s->gb, 8); s->s.h.refidx[0] = get\_bits(&s->gb, 3); s->s.h.signbias[0] = get\_bits1(&s->gb) && !s->s.h.errorres; s->s.h.refidx[1] = get\_bits(&s->gb, 3); s->s.h.signbias[1] = get\_bits1(&s->gb) && !s->s.h.errorres; s->s.h.refidx[2] = get\_bits(&s->gb, 3); s->s.h.signbias[2] = get\_bits1(&s->gb) && !s->s.h.errorres; if (!s->s.refs[s->s.h.refidx[0]].f->buf[0] || !s->s.refs[s->s.h.refidx[1]].f->buf[0] || !s->s.refs[s->s.h.refidx[2]].f->buf[0]) { av\_log(avctx, AV\_LOG\_ERROR, "Not all references are available\n"); return AVERROR\_INVALIDDATA; } if (get\_bits1(&s->gb)) { w = s->s.refs[s->s.h.refidx[0]].f->width; h = s->s.refs[s->s.h.refidx[0]].f->height; } else if (get\_bits1(&s->gb)) { w = s->s.refs[s->s.h.refidx[1]].f->width; h = s->s.refs[s->s.h.refidx[1]].f->height; } else if (get\_bits1(&s->gb)) { w = s->s.refs[s->s.h.refidx[2]].f->width; h = s->s.refs[s->s.h.refidx[2]].f->height; } else { w = get\_bits(&s->gb, 16) + 1; h = get\_bits(&s->gb, 16) + 1; } // Note that in this code, "CUR\_FRAME" is actually before we // have formally allocated a frame, and thus actually represents // the \_last\_ frame s->s.h.use\_last\_frame\_mvs &= s->s.frames[CUR\_FRAME].tf.f->width == w && s->s.frames[CUR\_FRAME].tf.f->height == h; if (get\_bits1(&s->gb)) // display size skip\_bits(&s->gb, 32); s->s.h.highprecisionmvs = get\_bits1(&s->gb); s->s.h.filtermode = get\_bits1(&s->gb) ? FILTER\_SWITCHABLE : get\_bits(&s->gb, 2); s->s.h.allowcompinter = s->s.h.signbias[0] != s->s.h.signbias[1] || s->s.h.signbias[0] != s->s.h.signbias[2]; if (s->s.h.allowcompinter) { if (s->s.h.signbias[0] == s->s.h.signbias[1]) { s->s.h.fixcompref = 2; s->s.h.varcompref[0] = 0; s->s.h.varcompref[1] = 1; } else if (s->s.h.signbias[0] == s->s.h.signbias[2]) { s->s.h.fixcompref = 1; s->s.h.varcompref[0] = 0; s->s.h.varcompref[1] = 2; } else { s->s.h.fixcompref = 0; s->s.h.varcompref[0] = 1; s->s.h.varcompref[1] = 2; } } } } s->s.h.refreshctx = s->s.h.errorres ? 0 : get\_bits1(&s->gb); s->s.h.parallelmode = s->s.h.errorres ? 1 : get\_bits1(&s->gb); s->s.h.framectxid = c = get\_bits(&s->gb, 2); if (s->s.h.keyframe || s->s.h.intraonly) s->s.h.framectxid = 0; // BUG: libvpx ignores this field in keyframes
 /\* loopfilter header data \*/ if (s->s.h.keyframe || s->s.h.errorres || s->s.h.intraonly) { // reset loopfilter defaults s->s.h.lf\_delta.ref[0] = 1; s->s.h.lf\_delta.ref[1] = 0; s->s.h.lf\_delta.ref[2] = -1; s->s.h.lf\_delta.ref[3] = -1; s->s.h.lf\_delta.mode[0] = 0; s->s.h.lf\_delta.mode[1] = 0; memset(s->s.h.segmentation.feat, 0, sizeof(s->s.h.segmentation.feat)); } s->s.h.filter.level = get\_bits(&s->gb, 6); sharp = get\_bits(&s->gb, 3); // if sharpness changed, reinit lim/mblim LUTs. if it didn't change, keep // the old cache values since they are still valid if (s->s.h.filter.sharpness != sharp) { for (i = 1; i <= 63; i++) { int limit = i;
 if (sharp > 0) { limit >>= (sharp + 3) >> 2; limit = FFMIN(limit, 9 - sharp); } limit = FFMAX(limit, 1);
 s->filter\_lut.lim\_lut[i] = limit; s->filter\_lut.mblim\_lut[i] = 2 \* (i + 2) + limit; } } s->s.h.filter.sharpness = sharp; if ((s->s.h.lf\_delta.enabled = get\_bits1(&s->gb))) { if ((s->s.h.lf\_delta.updated = get\_bits1(&s->gb))) { for (i = 0; i < 4; i++) if (get\_bits1(&s->gb)) s->s.h.lf\_delta.ref[i] = get\_sbits\_inv(&s->gb, 6); for (i = 0; i < 2; i++) if (get\_bits1(&s->gb)) s->s.h.lf\_delta.mode[i] = get\_sbits\_inv(&s->gb, 6); } }
 /\* quantization header data \*/ s->s.h.yac\_qi = get\_bits(&s->gb, 8); s->s.h.ydc\_qdelta = get\_bits1(&s->gb) ? get\_sbits\_inv(&s->gb, 4) : 0; s->s.h.uvdc\_qdelta = get\_bits1(&s->gb) ? get\_sbits\_inv(&s->gb, 4) : 0; s->s.h.uvac\_qdelta = get\_bits1(&s->gb) ? get\_sbits\_inv(&s->gb, 4) : 0; s->s.h.lossless = s->s.h.yac\_qi == 0 && s->s.h.ydc\_qdelta == 0 && s->s.h.uvdc\_qdelta == 0 && s->s.h.uvac\_qdelta == 0; if (s->s.h.lossless) avctx->properties |= FF\_CODEC\_PROPERTY\_LOSSLESS;
 /\* segmentation header info \*/ if ((s->s.h.segmentation.enabled = get\_bits1(&s->gb))) { if ((s->s.h.segmentation.update\_map = get\_bits1(&s->gb))) { for (i = 0; i < 7; i++) s->s.h.segmentation.prob[i] = get\_bits1(&s->gb) ? get\_bits(&s->gb, 8) : 255; if ((s->s.h.segmentation.temporal = get\_bits1(&s->gb))) for (i = 0; i < 3; i++) s->s.h.segmentation.pred\_prob[i] = get\_bits1(&s->gb) ? get\_bits(&s->gb, 8) : 255; }
 if (get\_bits1(&s->gb)) { s->s.h.segmentation.absolute\_vals = get\_bits1(&s->gb); for (i = 0; i < 8; i++) { if ((s->s.h.segmentation.feat[i].q\_enabled = get\_bits1(&s->gb))) s->s.h.segmentation.feat[i].q\_val = get\_sbits\_inv(&s->gb, 8); if ((s->s.h.segmentation.feat[i].lf\_enabled = get\_bits1(&s->gb))) s->s.h.segmentation.feat[i].lf\_val = get\_sbits\_inv(&s->gb, 6); if ((s->s.h.segmentation.feat[i].ref\_enabled = get\_bits1(&s->gb))) s->s.h.segmentation.feat[i].ref\_val = get\_bits(&s->gb, 2); s->s.h.segmentation.feat[i].skip\_enabled = get\_bits1(&s->gb); } } }
 // set qmul[] based on Y/UV, AC/DC and segmentation Q idx deltas for (i = 0; i < (s->s.h.segmentation.enabled ? 8 : 1); i++) { int qyac, qydc, quvac, quvdc, lflvl, sh;
 if (s->s.h.segmentation.enabled && s->s.h.segmentation.feat[i].q\_enabled) { if (s->s.h.segmentation.absolute\_vals) qyac = av\_clip\_uintp2(s->s.h.segmentation.feat[i].q\_val, 8); else qyac = av\_clip\_uintp2(s->s.h.yac\_qi + s->s.h.segmentation.feat[i].q\_val, 8); } else { qyac = s->s.h.yac\_qi; } qydc = av\_clip\_uintp2(qyac + s->s.h.ydc\_qdelta, 8); quvdc = av\_clip\_uintp2(qyac + s->s.h.uvdc\_qdelta, 8); quvac = av\_clip\_uintp2(qyac + s->s.h.uvac\_qdelta, 8); qyac = av\_clip\_uintp2(qyac, 8);
 s->s.h.segmentation.feat[i].qmul[0][0] = ff\_vp9\_dc\_qlookup[s->bpp\_index][qydc]; s->s.h.segmentation.feat[i].qmul[0][1] = ff\_vp9\_ac\_qlookup[s->bpp\_index][qyac]; s->s.h.segmentation.feat[i].qmul[1][0] = ff\_vp9\_dc\_qlookup[s->bpp\_index][quvdc]; s->s.h.segmentation.feat[i].qmul[1][1] = ff\_vp9\_ac\_qlookup[s->bpp\_index][quvac];
 sh = s->s.h.filter.level >= 32; if (s->s.h.segmentation.enabled && s->s.h.segmentation.feat[i].lf\_enabled) { if (s->s.h.segmentation.absolute\_vals) lflvl = av\_clip\_uintp2(s->s.h.segmentation.feat[i].lf\_val, 6); else lflvl = av\_clip\_uintp2(s->s.h.filter.level + s->s.h.segmentation.feat[i].lf\_val, 6); } else { lflvl = s->s.h.filter.level; } if (s->s.h.lf\_delta.enabled) { s->s.h.segmentation.feat[i].lflvl[0][0] = s->s.h.segmentation.feat[i].lflvl[0][1] = av\_clip\_uintp2(lflvl + (s->s.h.lf\_delta.ref[0] \* (1 << sh)), 6); for (j = 1; j < 4; j++) { s->s.h.segmentation.feat[i].lflvl[j][0] = av\_clip\_uintp2(lflvl + ((s->s.h.lf\_delta.ref[j] + s->s.h.lf\_delta.mode[0]) \* (1 << sh)), 6); s->s.h.segmentation.feat[i].lflvl[j][1] = av\_clip\_uintp2(lflvl + ((s->s.h.lf\_delta.ref[j] + s->s.h.lf\_delta.mode[1]) \* (1 << sh)), 6); } } else { memset(s->s.h.segmentation.feat[i].lflvl, lflvl, sizeof(s->s.h.segmentation.feat[i].lflvl)); } }
 /\* tiling info \*/ if ((ret = update\_size(avctx, w, h)) < 0) { av\_log(avctx, AV\_LOG\_ERROR, "Failed to initialize decoder for %dx%d @ %d\n", w, h, s->pix\_fmt); return ret; } for (s->s.h.tiling.log2\_tile\_cols = 0; s->sb\_cols > (64 << s->s.h.tiling.log2\_tile\_cols); s->s.h.tiling.log2\_tile\_cols++) ; for (max = 0; (s->sb\_cols >> max) >= 4; max++) ; max = FFMAX(0, max - 1); while (max > s->s.h.tiling.log2\_tile\_cols) { if (get\_bits1(&s->gb)) s->s.h.tiling.log2\_tile\_cols++; else break; } s->s.h.tiling.log2\_tile\_rows = decode012(&s->gb); s->s.h.tiling.tile\_rows = 1 << s->s.h.tiling.log2\_tile\_rows; if (s->s.h.tiling.tile\_cols != (1 << s->s.h.tiling.log2\_tile\_cols)) { int n\_range\_coders; VPXRangeCoder \*rc;
 if (s->td) { for (i = 0; i < s->active\_tile\_cols; i++) vp9\_tile\_data\_free(&s->td[i]); av\_freep(&s->td); }
 s->s.h.tiling.tile\_cols = 1 << s->s.h.tiling.log2\_tile\_cols; s->active\_tile\_cols = avctx->active\_thread\_type == FF\_THREAD\_SLICE ? s->s.h.tiling.tile\_cols : 1; vp9\_alloc\_entries(avctx, s->sb\_rows); if (avctx->active\_thread\_type == FF\_THREAD\_SLICE) { n\_range\_coders = 4; // max\_tile\_rows } else { n\_range\_coders = s->s.h.tiling.tile\_cols; } s->td = av\_calloc(s->active\_tile\_cols, sizeof(VP9TileData) + n\_range\_coders \* sizeof(VPXRangeCoder)); if (!s->td) return AVERROR(ENOMEM); rc = (VPXRangeCoder \*) &s->td[s->active\_tile\_cols]; for (i = 0; i < s->active\_tile\_cols; i++) { s->td[i].s = s; s->td[i].c\_b = rc; rc += n\_range\_coders; } }
 /\* check reference frames \*/ if (!s->s.h.keyframe && !s->s.h.intraonly) { int valid\_ref\_frame = 0; for (i = 0; i < 3; i++) { AVFrame \*ref = s->s.refs[s->s.h.refidx[i]].f; int refw = ref->width, refh = ref->height;
 if (ref->format != avctx->pix\_fmt) { av\_log(avctx, AV\_LOG\_ERROR, "Ref pixfmt (%s) did not match current frame (%s)", av\_get\_pix\_fmt\_name(ref->format), av\_get\_pix\_fmt\_name(avctx->pix\_fmt)); return AVERROR\_INVALIDDATA; } else if (refw == w && refh == h) { s->mvscale[i][0] = s->mvscale[i][1] = 0; } else { /\* Check to make sure at least one of frames that \*/ /\* this frame references has valid dimensions \*/ if (w \* 2 < refw || h \* 2 < refh || w > 16 \* refw || h > 16 \* refh) { av\_log(avctx, AV\_LOG\_WARNING, "Invalid ref frame dimensions %dx%d for frame size %dx%d\n", refw, refh, w, h); s->mvscale[i][0] = s->mvscale[i][1] = REF\_INVALID\_SCALE; continue; } s->mvscale[i][0] = (refw << 14) / w; s->mvscale[i][1] = (refh << 14) / h; s->mvstep[i][0] = 16 \* s->mvscale[i][0] >> 14; s->mvstep[i][1] = 16 \* s->mvscale[i][1] >> 14; } valid\_ref\_frame++; } if (!valid\_ref\_frame) { av\_log(avctx, AV\_LOG\_ERROR, "No valid reference frame is found, bitstream not supported\n"); return AVERROR\_INVALIDDATA; } }
 if (s->s.h.keyframe || s->s.h.errorres || (s->s.h.intraonly && s->s.h.resetctx == 3)) { s->prob\_ctx[0].p = s->prob\_ctx[1].p = s->prob\_ctx[2].p = s->prob\_ctx[3].p = ff\_vp9\_default\_probs; memcpy(s->prob\_ctx[0].coef, ff\_vp9\_default\_coef\_probs, sizeof(ff\_vp9\_default\_coef\_probs)); memcpy(s->prob\_ctx[1].coef, ff\_vp9\_default\_coef\_probs, sizeof(ff\_vp9\_default\_coef\_probs)); memcpy(s->prob\_ctx[2].coef, ff\_vp9\_default\_coef\_probs, sizeof(ff\_vp9\_default\_coef\_probs)); memcpy(s->prob\_ctx[3].coef, ff\_vp9\_default\_coef\_probs, sizeof(ff\_vp9\_default\_coef\_probs)); } else if (s->s.h.intraonly && s->s.h.resetctx == 2) { s->prob\_ctx[c].p = ff\_vp9\_default\_probs; memcpy(s->prob\_ctx[c].coef, ff\_vp9\_default\_coef\_probs, sizeof(ff\_vp9\_default\_coef\_probs)); }
 // next 16 bits is size of the rest of the header (arith-coded) s->s.h.compressed\_header\_size = size2 = get\_bits(&s->gb, 16); s->s.h.uncompressed\_header\_size = (get\_bits\_count(&s->gb) + 7) / 8;
 data2 = align\_get\_bits(&s->gb); if (size2 > size - (data2 - data)) { av\_log(avctx, AV\_LOG\_ERROR, "Invalid compressed header size\n"); return AVERROR\_INVALIDDATA; } ret = ff\_vpx\_init\_range\_decoder(&s->c, data2, size2); if (ret < 0) return ret;
 if (vpx\_rac\_get\_prob\_branchy(&s->c, 128)) { // marker bit av\_log(avctx, AV\_LOG\_ERROR, "Marker bit was set\n"); return AVERROR\_INVALIDDATA; }
 for (i = 0; i < s->active\_tile\_cols; i++) { if (s->s.h.keyframe || s->s.h.intraonly) { memset(s->td[i].counts.coef, 0, sizeof(s->td[0].counts.coef)); memset(s->td[i].counts.eob, 0, sizeof(s->td[0].counts.eob)); } else { memset(&s->td[i].counts, 0, sizeof(s->td[0].counts)); } s->td[i].nb\_block\_structure = 0; }
 /\* FIXME is it faster to not copy here, but do it down in the fw updates \* as explicit copies if the fw update is missing (and skip the copy upon \* fw update)? \*/ s->prob.p = s->prob\_ctx[c].p;
 // txfm updates if (s->s.h.lossless) { s->s.h.txfmmode = TX\_4X4; } else { s->s.h.txfmmode = vp89\_rac\_get\_uint(&s->c, 2); if (s->s.h.txfmmode == 3) s->s.h.txfmmode += vp89\_rac\_get(&s->c);
 if (s->s.h.txfmmode == TX\_SWITCHABLE) { for (i = 0; i < 2; i++) if (vpx\_rac\_get\_prob\_branchy(&s->c, 252)) s->prob.p.tx8p[i] = update\_prob(&s->c, s->prob.p.tx8p[i]); for (i = 0; i < 2; i++) for (j = 0; j < 2; j++) if (vpx\_rac\_get\_prob\_branchy(&s->c, 252)) s->prob.p.tx16p[i][j] = update\_prob(&s->c, s->prob.p.tx16p[i][j]); for (i = 0; i < 2; i++) for (j = 0; j < 3; j++) if (vpx\_rac\_get\_prob\_branchy(&s->c, 252)) s->prob.p.tx32p[i][j] = update\_prob(&s->c, s->prob.p.tx32p[i][j]); } }
 // coef updates for (i = 0; i < 4; i++) { uint8\_t (\*ref)[2][6][6][3] = s->prob\_ctx[c].coef[i]; if (vp89\_rac\_get(&s->c)) { for (j = 0; j < 2; j++) for (k = 0; k < 2; k++) for (l = 0; l < 6; l++) for (m = 0; m < 6; m++) { uint8\_t \*p = s->prob.coef[i][j][k][l][m]; uint8\_t \*r = ref[j][k][l][m]; if (m >= 3 && l == 0) // dc only has 3 pt break; for (n = 0; n < 3; n++) { if (vpx\_rac\_get\_prob\_branchy(&s->c, 252)) p[n] = update\_prob(&s->c, r[n]); else p[n] = r[n]; } memcpy(&p[3], ff\_vp9\_model\_pareto8[p[2]], 8); } } else { for (j = 0; j < 2; j++) for (k = 0; k < 2; k++) for (l = 0; l < 6; l++) for (m = 0; m < 6; m++) { uint8\_t \*p = s->prob.coef[i][j][k][l][m]; uint8\_t \*r = ref[j][k][l][m]; if (m > 3 && l == 0) // dc only has 3 pt break; memcpy(p, r, 3); memcpy(&p[3], ff\_vp9\_model\_pareto8[p[2]], 8); } } if (s->s.h.txfmmode == i) break; }
 // mode updates for (i = 0; i < 3; i++) if (vpx\_rac\_get\_prob\_branchy(&s->c, 252)) s->prob.p.skip[i] = update\_prob(&s->c, s->prob.p.skip[i]); if (!s->s.h.keyframe && !s->s.h.intraonly) { for (i = 0; i < 7; i++) for (j = 0; j < 3; j++) if (vpx\_rac\_get\_prob\_branchy(&s->c, 252)) s->prob.p.mv\_mode[i][j] = update\_prob(&s->c, s->prob.p.mv\_mode[i][j]);
 if (s->s.h.filtermode == FILTER\_SWITCHABLE) for (i = 0; i < 4; i++) for (j = 0; j < 2; j++) if (vpx\_rac\_get\_prob\_branchy(&s->c, 252)) s->prob.p.filter[i][j] = update\_prob(&s->c, s->prob.p.filter[i][j]);
 for (i = 0; i < 4; i++) if (vpx\_rac\_get\_prob\_branchy(&s->c, 252)) s->prob.p.intra[i] = update\_prob(&s->c, s->prob.p.intra[i]);
 if (s->s.h.allowcompinter) { s->s.h.comppredmode = vp89\_rac\_get(&s->c); if (s->s.h.comppredmode) s->s.h.comppredmode += vp89\_rac\_get(&s->c); if (s->s.h.comppredmode == PRED\_SWITCHABLE) for (i = 0; i < 5; i++) if (vpx\_rac\_get\_prob\_branchy(&s->c, 252)) s->prob.p.comp[i] =[View remainder of file in raw view](https://github.com/FFmpeg/FFmpeg/raw/refs/tags/n7.0/libavcodec/vp9.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from gist.github.com_5796b9a7_20250115_094457.html ===

[Skip to content](#start-of-content)

[All gists](/discover)
[Back to GitHub](https://github.com)
[Sign in](https://gist.github.com/auth/github?return_to=https%3A%2F%2Fgist.github.com%2F1047524396%2Fc44e5eaafa8f408eea0c9411205990fb)
[Sign up](/join?return_to=https%3A%2F%2Fgist.github.com%2F1047524396%2Fc44e5eaafa8f408eea0c9411205990fb&source=header-gist)

[Sign in](https://gist.github.com/auth/github?return_to=https%3A%2F%2Fgist.github.com%2F1047524396%2Fc44e5eaafa8f408eea0c9411205990fb) [Sign up](/join?return_to=https%3A%2F%2Fgist.github.com%2F1047524396%2Fc44e5eaafa8f408eea0c9411205990fb&source=header-gist)

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

Instantly share code, notes, and snippets.

[![@1047524396](https://avatars.githubusercontent.com/u/77877041?s=64&v=4)](/1047524396)

# [1047524396](/1047524396)/**[CVE-2024-36615](/1047524396/c44e5eaafa8f408eea0c9411205990fb)**

Created
November 29, 2024 04:16

Show Gist options

* [Download ZIP](/1047524396/c44e5eaafa8f408eea0c9411205990fb/archive/9a00838e5e439d3ba43ce80e472f34fbf9a276fc.zip)

* [Star
  (0)
  0](/login?return_to=https%3A%2F%2Fgist.github.com%2F1047524396%2Fc44e5eaafa8f408eea0c9411205990fb)You must be signed in to star a gist
* [Fork
  (0)
  0](/login?return_to=https%3A%2F%2Fgist.github.com%2F1047524396%2Fc44e5eaafa8f408eea0c9411205990fb)You must be signed in to fork a gist

* Embed

  + Embed
     Embed this gist in your website.
  + Share
     Copy sharable link for this gist.
  + Clone via HTTPS
     Clone using the web URL.
  + [Learn more about clone URLs](https://docs.github.com/articles/which-remote-url-should-i-use)

  Clone this repository at &lt;script src=&quot;https://gist.github.com/1047524396/c44e5eaafa8f408eea0c9411205990fb.js&quot;&gt;&lt;/script&gt;
* Save 1047524396/c44e5eaafa8f408eea0c9411205990fb to your computer and use it in GitHub Desktop.

[Code](/1047524396/c44e5eaafa8f408eea0c9411205990fb)
[Revisions
1](/1047524396/c44e5eaafa8f408eea0c9411205990fb/revisions)

Embed

* Embed
   Embed this gist in your website.
* Share
   Copy sharable link for this gist.
* Clone via HTTPS
   Clone using the web URL.
* [Learn more about clone URLs](https://docs.github.com/articles/which-remote-url-should-i-use)

Clone this repository at &lt;script src=&quot;https://gist.github.com/1047524396/c44e5eaafa8f408eea0c9411205990fb.js&quot;&gt;&lt;/script&gt;

Save 1047524396/c44e5eaafa8f408eea0c9411205990fb to your computer and use it in GitHub Desktop.

[Download ZIP](/1047524396/c44e5eaafa8f408eea0c9411205990fb/archive/9a00838e5e439d3ba43ce80e472f34fbf9a276fc.zip)

CVE-2024-36615

 [Raw](/1047524396/c44e5eaafa8f408eea0c9411205990fb/raw/9a00838e5e439d3ba43ce80e472f34fbf9a276fc/CVE-2024-36615)

[**CVE-2024-36615**](#file-cve-2024-36615)

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

|  | [CVE ID] |
| --- | --- |
|  | CVE-2024-36615 |
|  | [PRODUCT] |
|  | FFmpeg |
|  | [VERSION] |
|  | n7.0 |
|  | [PROBLEM TYPE] |
|  | Race Condition |
|  | [DESCRIPTION] |
|  | FFmpeg n7.0 has a race condition vulnerability in the VP9 decoder. This could lead to a data race if video encoding parameters were being exported, as the side data would be attached in the decoder thread while being read in the output thread. |
|  | [PATCH LINK] |
|  | https://github.com/ffmpeg/ffmpeg/commit/0ba058579f332b3060d8470a04ddd3fbf305be61 |

[Sign up for free](/join?source=comment-gist)
**to join this conversation on GitHub**.
Already have an account?
[Sign in to comment](/login?return_to=https%3A%2F%2Fgist.github.com%2F1047524396%2Fc44e5eaafa8f408eea0c9411205990fb)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


