```
{
  "CVE-2024-45337": {
    "related_content": [
      {
        "source": "github.com_45beb679_20250115_203726.html",
        "vulnerability_details": {
          "root_cause": "The `ssh` package's `PublicKeyCallback` API was commonly misused by users who assumed the last key passed to the callback was the key used for authentication. This was incorrect due to caching behavior, leading to incorrect authorization decisions.",
          "weaknesses": [
            "Incorrect assumption about the order of keys passed to `PublicKeyCallback`",
            "Caching behavior that did not guarantee the last key was the one used for authentication"
          ],
          "impact": "Applications may make incorrect authorization decisions based on a public key that was not actually used for authentication, potentially leading to an authorization bypass.",
          "attack_vectors": [
             "Attacker sends multiple public keys to the server, then authenticates with one of them. The vulnerable application might make authorization decisions based on a different public key that the attacker does not control the private key for."
           ],
          "attacker_capabilities": "The attacker needs the ability to initiate an SSH connection with a server using public key authentication, and be able to send multiple public keys for consideration."
        }
      },
      {
        "source": "github.com_dbad872d_20250115_203726.html",
         "vulnerability_details": {
          "root_cause": "The `ssh` package's `PublicKeyCallback` API was commonly misused by users who assumed the last key passed to the callback was the key used for authentication. This was incorrect due to caching behavior, leading to incorrect authorization decisions.",
          "weaknesses": [
            "Incorrect assumption about the order of keys passed to `PublicKeyCallback`",
            "Caching behavior that did not guarantee the last key was the one used for authentication"
          ],
         "impact": "Applications may make incorrect authorization decisions based on a public key that was not actually used for authentication, potentially leading to an authorization bypass.",
         "attack_vectors": [
             "Attacker sends multiple public keys to the server, then authenticates with one of them. The vulnerable application might make authorization decisions based on a different public key that the attacker does not control the private key for."
           ],
          "attacker_capabilities": "The attacker needs the ability to initiate an SSH connection with a server using public key authentication, and be able to send multiple public keys for consideration."
        }
      },
       {
        "source": "github.com_ee1cc245_20250115_203732.html",
         "vulnerability_details": {
           "root_cause": "The `ServerConfig.PublicKeyCallback` in `golang.org/x/crypto` does not guarantee that the key offered is used to authenticate. Clients can inquire about key acceptability before proving control, leading to multiple calls with different keys. Applications incorrectly assumed the last key passed was the one used for authentication.",
           "weaknesses": [
            "Incorrect assumptions about the `PublicKeyCallback` API.",
             "Caching behavior could lead to authorization decisions based on a key not used for authentication."
           ],
           "impact": "Applications misusing the `PublicKeyCallback` can have authorization bypass issues, where decisions are made on public keys that the attacker doesn't control.",
           "attack_vectors": "An attacker sends multiple public keys. The callback is called for each, but the attacker authenticates with only one. Vulnerable applications might base authorization decisions on the last key sent instead of the one used for auth.",
            "attacker_capabilities": "Attacker needs to be able to send multiple public keys to an SSH server and then authenticate using only one key."
         }
       },
      {
        "source": "groups.google.com_0b76aa5e_20250115_203717.html",
         "vulnerability_details": {
           "root_cause": "The `ServerConfig.PublicKeyCallback` in `golang.org/x/crypto` is misused because it does not guarantee that the key offered is used to authenticate. The SSH protocol allows clients to probe with multiple keys. Applications are making authorization decisions based on a key passed to the callback that is not used for authentication.",
            "weaknesses": [
              "Incorrect assumption about the behavior of `PublicKeyCallback`.",
              "Lack of explicit mechanism to know which public key was used to authenticate."
            ],
            "impact": "An attacker can potentially bypass authorization checks if the application makes decisions based on a key different than the one used for authentication.",
             "attack_vectors": "An attacker can send multiple public keys, and authenticate with one key. The vulnerable application might then base authorization decisions on the last key seen by the `PublicKeyCallback`, which is not the key used for authentication.",
            "attacker_capabilities": "The attacker needs to initiate an SSH connection, send multiple public keys and authenticate with only one of them."
         }
      },
      {
        "source": "www.openwall.com_9fa20a76_20250114_230435.html",
        "vulnerability_details": {
          "root_cause": "The `ServerConfig.PublicKeyCallback` in `golang.org/x/crypto` does not guarantee that the key offered is the key used for authentication due to the nature of the SSH protocol allowing clients to inquire about keys before proving control.",
          "weaknesses": [
            "Misuse of `ServerConfig.PublicKeyCallback`.",
            "Incorrect assumption that last key passed to the callback is used for authentication."
          ],
          "impact": "Authorization bypass in applications that incorrectly store and use keys from the `PublicKeyCallback`.",
           "attack_vectors": "An attacker sends public keys A and B, then authenticates with A. A vulnerable application may then make authorization decisions based on key B for which the attacker does not actually control the private key.",
           "attacker_capabilities": "An attacker needs the ability to send multiple public keys to the server then authenticate with only one."
        }
      },
      {
        "source": "pkg.go.dev_d8114683_20250115_203718.html",
          "vulnerability_details": {
            "root_cause": "Applications misuse `ServerConfig.PublicKeyCallback` by assuming the last key offered is used for authentication. SSH protocol allows clients to check key acceptability before proving control.",
            "weaknesses": [
              "Incorrect use of the `PublicKeyCallback` API.",
              "Caching behavior that can lead to authorization based on an incorrect key."
            ],
           "impact": "Authorization bypass due to incorrect assumptions about which key was used for authentication.",
            "attack_vectors": "An attacker sends keys A and B, authenticates with A, and a vulnerable application authorizes based on key B.",
            "attacker_capabilities":"The attacker needs the ability to send multiple public keys during SSH authentication."
          }
      },
       {
        "source": "go.dev_d1b49eb4_20250115_203734.html",
         "vulnerability_details": {
            "root_cause": "The `ServerConfig.PublicKeyCallback` in `golang.org/x/crypto` is misused as it doesn't guarantee the key offered is actually used for authentication. Clients can inquire about key acceptability before proving control. Applications were assuming that the last key passed to the callback was used for authentication.",
            "weaknesses": [
              "Incorrect assumption about the `PublicKeyCallback` API.",
              "Lack of awareness about the SSH protocol key exchange mechanism.",
               "Applications relying on external state instead of using the provided `Permissions` field."
             ],
             "impact": "Potential authorization bypass if applications make authorization decisions based on the wrong public key.",
             "attack_vectors": "An attacker sends multiple keys (A and B) then authenticates using A. Vulnerable applications might make authorization decisions based on B.",
             "attacker_capabilities": "Attacker needs to be able to send multiple keys to the SSH server and then successfully authenticate with only one of them."
           }
       },
       {
         "source": "github.com_23d4f4fe_20250115_203731.html",
         "vulnerability_details": {
             "root_cause": "The `ServerConfig.PublicKeyCallback` in `golang.org/x/crypto` is misused as it doesn't guarantee that the key offered is actually used for authentication, due to the SSH protocol allowing clients to send multiple keys before authentication. Applications are incorrectly making authorization decisions based on the last key passed.",
             "weaknesses": [
               "Misunderstanding of `ServerConfig.PublicKeyCallback` behavior.",
               "Incorrect assumption that the last key passed is the authenticated key.",
               "Lack of use of the Extensions field in Permissions."
              ],
            "impact": "Applications can suffer from authorization bypass, where decisions are made on the wrong public key.",
             "attack_vectors": "An attacker can send keys A and B, authenticating with A, and the application might make authorization decisions based on key B.",
             "attacker_capabilities": "The attacker needs to be able to present multiple public keys to an SSH server and then authenticate with one of them."
         }
       }
    ],
    "summary": "The vulnerability arises from the misuse of the `ServerConfig.PublicKeyCallback` in the `golang.org/x/crypto` SSH package. Applications incorrectly assumed that the last public key passed to the callback was the one used for authentication. The SSH protocol allows clients to send multiple keys for consideration before proving control, which meant that the callback could be invoked multiple times with different keys. This resulted in a scenario where applications could make authorization decisions based on a public key that the attacker did not actually use to authenticate, leading to a potential authorization bypass. The fix involves caching only one key in the server, such that the last key provided to the callback is guaranteed to be the authentication key. The fix also recommends that applications use the Extensions field in Permissions to store authentication data instead of relying on external state."
  }
}
```