The provided content is related to CVE-2024-56617.

**Root cause of vulnerability:**
The vulnerability stems from a missing memory allocation for cache information during CPU hotplug events in the Linux kernel. Specifically, if the architecture does not use early cache information initialization during boot, the memory for `cacheinfo` is not allocated, leading to a NULL pointer dereference when the `last_level_cache_is_valid()` function is called during CPU hotplug. This also impacts `update_per_cpu_data_slice_size()` due to iteration over all online CPUs, which could include those with unallocated `cacheinfo`.

**Weaknesses/vulnerabilities present:**
- **NULL pointer dereference:** The core issue is a NULL pointer dereference in `last_level_cache_is_valid()` because `per_cpu_cacheinfo(cpu)` could be NULL.
- **Missing allocation:** The `cacheinfo` memory is not consistently allocated, especially when the architecture does not use early initialization.
- **Inconsistent state:** The `cache_leaves()` value might be non-zero even when `cacheinfo` is not allocated, leading to incorrect assumptions of its validity.

**Impact of exploitation:**
- Kernel crash due to a NULL pointer dereference.
- System instability.
- Potential denial-of-service.

**Attack vectors:**
- Triggering a CPU hotplug event on a system where cacheinfo memory allocation isn't handled early during boot.
- Specifically, the issue occurs in architectures like x86 that do not utilize early cache info building.

**Required attacker capabilities/position:**
- Ability to trigger CPU hotplug operations.
- Local access to the system would be sufficient.