=== Content from git.kernel.org_838560f3_20250114_184148.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f05ad9755bb294328c3d0f429164ac6d4d08c548)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f05ad9755bb294328c3d0f429164ac6d4d08c548)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f05ad9755bb294328c3d0f429164ac6d4d08c548)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f05ad9755bb294328c3d0f429164ac6d4d08c548)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Hubert Wiśniewski <hubert.wisniewski.25632@gmail.com> | 2024-11-10 18:21:48 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-05 13:54:25 +0100 |
| commit | [f05ad9755bb294328c3d0f429164ac6d4d08c548](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f05ad9755bb294328c3d0f429164ac6d4d08c548) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f05ad9755bb294328c3d0f429164ac6d4d08c548)) | |
| tree | [d803453bae0d0784ae6dffbe731aea5e5ceb4bfa](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f05ad9755bb294328c3d0f429164ac6d4d08c548) | |
| parent | [ad551e4735fafee123dee83319244648540e1b0d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ad551e4735fafee123dee83319244648540e1b0d) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f05ad9755bb294328c3d0f429164ac6d4d08c548&id2=ad551e4735fafee123dee83319244648540e1b0d)) | |
| download | [linux-f05ad9755bb294328c3d0f429164ac6d4d08c548.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f05ad9755bb294328c3d0f429164ac6d4d08c548.tar.gz) | |

usb: musb: Fix hardware lockup on first Rx endpoint requestcommit 3fc137386c4620305bbc2a216868c53f9245670a upstream.
There is a possibility that a request's callback could be invoked from
usb\_ep\_queue() (call trace below, supplemented with missing calls):
req->complete from usb\_gadget\_giveback\_request
(drivers/usb/gadget/udc/core.c:999)
usb\_gadget\_giveback\_request from musb\_g\_giveback
(drivers/usb/musb/musb\_gadget.c:147)
musb\_g\_giveback from rxstate
(drivers/usb/musb/musb\_gadget.c:784)
rxstate from musb\_ep\_restart
(drivers/usb/musb/musb\_gadget.c:1169)
musb\_ep\_restart from musb\_ep\_restart\_resume\_work
(drivers/usb/musb/musb\_gadget.c:1176)
musb\_ep\_restart\_resume\_work from musb\_queue\_resume\_work
(drivers/usb/musb/musb\_core.c:2279)
musb\_queue\_resume\_work from musb\_gadget\_queue
(drivers/usb/musb/musb\_gadget.c:1241)
musb\_gadget\_queue from usb\_ep\_queue
(drivers/usb/gadget/udc/core.c:300)
According to the docstring of usb\_ep\_queue(), this should not happen:
"Note that @req's ->complete() callback must never be called from within
usb\_ep\_queue() as that can create deadlock situations."
In fact, a hardware lockup might occur in the following sequence:
1. The gadget is initialized using musb\_gadget\_enable().
2. Meanwhile, a packet arrives, and the RXPKTRDY flag is set, raising an
interrupt.
3. If IRQs are enabled, the interrupt is handled, but musb\_g\_rx() finds an
empty queue (next\_request() returns NULL). The interrupt flag has
already been cleared by the glue layer handler, but the RXPKTRDY flag
remains set.
4. The first request is enqueued using usb\_ep\_queue(), leading to the call
of req->complete(), as shown in the call trace above.
5. If the callback enables IRQs and another packet is waiting, step (3)
repeats. The request queue is empty because usb\_g\_giveback() removes the
request before invoking the callback.
6. The endpoint remains locked up, as the interrupt triggered by hardware
setting the RXPKTRDY flag has been handled, but the flag itself remains
set.
For this scenario to occur, it is only necessary for IRQs to be enabled at
some point during the complete callback. This happens with the USB Ethernet
gadget, whose rx\_complete() callback calls netif\_rx(). If called in the
task context, netif\_rx() disables the bottom halves (BHs). When the BHs are
re-enabled, IRQs are also enabled to allow soft IRQs to be processed. The
gadget itself is initialized at module load (or at boot if built-in), but
the first request is enqueued when the network interface is brought up,
triggering rx\_complete() in the task context via ioctl(). If a packet
arrives while the interface is down, it can prevent the interface from
receiving any further packets from the USB host.
The situation is quite complicated with many parties involved. This
particular issue can be resolved in several possible ways:
1. Ensure that callbacks never enable IRQs. This would be difficult to
enforce, as discovering how netif\_rx() interacts with interrupts was
already quite challenging and u\_ether is not the only function driver.
Similar "bugs" could be hidden in other drivers as well.
2. Disable MUSB interrupts in musb\_g\_giveback() before calling the callback
and re-enable them afterwars (by calling musb\_{dis,en}able\_interrupts(),
for example). This would ensure that MUSB interrupts are not handled
during the callback, even if IRQs are enabled. In fact, it would allow
IRQs to be enabled when releasing the lock. However, this feels like an
inelegant hack.
3. Modify the interrupt handler to clear the RXPKTRDY flag if the request
queue is empty. While this approach also feels like a hack, it wastes
CPU time by attempting to handle incoming packets when the software is
not ready to process them.
4. Flush the Rx FIFO instead of calling rxstate() in musb\_ep\_restart().
This ensures that the hardware can receive packets when there is at
least one request in the queue. Once IRQs are enabled, the interrupt
handler will be able to correctly process the next incoming packet
(eventually calling rxstate()). This approach may cause one or two
packets to be dropped (two if double buffering is enabled), but this
seems to be a minor issue, as packet loss can occur when the software is
not yet ready to process them. Additionally, this solution makes the
gadget driver compliant with the rule mentioned in the docstring of
usb\_ep\_queue().
There may be additional solutions, but from these four, the last one has
been chosen as it seems to be the most appropriate, as it addresses the
"bad" behavior of the driver.
Fixes: baebdf48c360 ("net: dev: Makes sure netif\_rx() can be invoked in any context.")
Cc: stable@vger.kernel.org
Signed-off-by: Hubert Wiśniewski <hubert.wisniewski.25632@gmail.com>
Link: [https://lore.kernel.org/r/4ee1ead4525f78fb5909a8cbf99513ad0082ad21.camel@gmail.com](https://lore.kernel.org/r/4ee1ead4525f78fb5909a8cbf99513ad0082ad21.camel%40gmail.com)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f05ad9755bb294328c3d0f429164ac6d4d08c548)

| -rw-r--r-- | [drivers/usb/musb/musb\_gadget.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/musb/musb_gadget.c?id=f05ad9755bb294328c3d0f429164ac6d4d08c548) | 13 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 10 insertions, 3 deletions

| diff --git a/drivers/usb/musb/musb\_gadget.c b/drivers/usb/musb/musb\_gadget.cindex bdf13911a1e590..c6076df0d50cc7 100644--- a/[drivers/usb/musb/musb\_gadget.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/musb/musb_gadget.c?id=ad551e4735fafee123dee83319244648540e1b0d)+++ b/[drivers/usb/musb/musb\_gadget.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/musb/musb_gadget.c?id=f05ad9755bb294328c3d0f429164ac6d4d08c548)@@ -1161,12 +1161,19 @@ void musb\_free\_request(struct usb\_ep \*ep, struct usb\_request \*req) \*/ void musb\_ep\_restart(struct musb \*musb, struct musb\_request \*req) {+ u16 csr;+ void \_\_iomem \*epio = req->ep->hw\_ep->regs;+ trace\_musb\_req\_start(req); musb\_ep\_select(musb->mregs, req->epnum);- if (req->tx)+ if (req->tx) { txstate(musb, req);- else- rxstate(musb, req);+ } else {+ csr = musb\_readw(epio, MUSB\_RXCSR);+ csr |= MUSB\_RXCSR\_FLUSHFIFO | MUSB\_RXCSR\_P\_WZC\_BITS;+ musb\_writew(epio, MUSB\_RXCSR, csr);+ musb\_writew(epio, MUSB\_RXCSR, csr);+ } }  static int musb\_ep\_restart\_resume\_work(struct musb \*musb, void \*data) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 18:40:25 +0000



=== Content from git.kernel.org_cf18467f_20250114_184147.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=5906ee3693674d734177df13a519a21bb03f730d)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5906ee3693674d734177df13a519a21bb03f730d)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5906ee3693674d734177df13a519a21bb03f730d)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5906ee3693674d734177df13a519a21bb03f730d)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Hubert Wiśniewski <hubert.wisniewski.25632@gmail.com> | 2024-11-10 18:21:48 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-09 10:32:53 +0100 |
| commit | [5906ee3693674d734177df13a519a21bb03f730d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5906ee3693674d734177df13a519a21bb03f730d) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=5906ee3693674d734177df13a519a21bb03f730d)) | |
| tree | [783f71e8c72ee1bc05c9ec4b468eda6230ea3e36](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5906ee3693674d734177df13a519a21bb03f730d) | |
| parent | [73934e535cffbda1490fa97d82690a0f9aa73e94](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=73934e535cffbda1490fa97d82690a0f9aa73e94) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5906ee3693674d734177df13a519a21bb03f730d&id2=73934e535cffbda1490fa97d82690a0f9aa73e94)) | |
| download | [linux-5906ee3693674d734177df13a519a21bb03f730d.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-5906ee3693674d734177df13a519a21bb03f730d.tar.gz) | |

usb: musb: Fix hardware lockup on first Rx endpoint requestcommit 3fc137386c4620305bbc2a216868c53f9245670a upstream.
There is a possibility that a request's callback could be invoked from
usb\_ep\_queue() (call trace below, supplemented with missing calls):
req->complete from usb\_gadget\_giveback\_request
(drivers/usb/gadget/udc/core.c:999)
usb\_gadget\_giveback\_request from musb\_g\_giveback
(drivers/usb/musb/musb\_gadget.c:147)
musb\_g\_giveback from rxstate
(drivers/usb/musb/musb\_gadget.c:784)
rxstate from musb\_ep\_restart
(drivers/usb/musb/musb\_gadget.c:1169)
musb\_ep\_restart from musb\_ep\_restart\_resume\_work
(drivers/usb/musb/musb\_gadget.c:1176)
musb\_ep\_restart\_resume\_work from musb\_queue\_resume\_work
(drivers/usb/musb/musb\_core.c:2279)
musb\_queue\_resume\_work from musb\_gadget\_queue
(drivers/usb/musb/musb\_gadget.c:1241)
musb\_gadget\_queue from usb\_ep\_queue
(drivers/usb/gadget/udc/core.c:300)
According to the docstring of usb\_ep\_queue(), this should not happen:
"Note that @req's ->complete() callback must never be called from within
usb\_ep\_queue() as that can create deadlock situations."
In fact, a hardware lockup might occur in the following sequence:
1. The gadget is initialized using musb\_gadget\_enable().
2. Meanwhile, a packet arrives, and the RXPKTRDY flag is set, raising an
interrupt.
3. If IRQs are enabled, the interrupt is handled, but musb\_g\_rx() finds an
empty queue (next\_request() returns NULL). The interrupt flag has
already been cleared by the glue layer handler, but the RXPKTRDY flag
remains set.
4. The first request is enqueued using usb\_ep\_queue(), leading to the call
of req->complete(), as shown in the call trace above.
5. If the callback enables IRQs and another packet is waiting, step (3)
repeats. The request queue is empty because usb\_g\_giveback() removes the
request before invoking the callback.
6. The endpoint remains locked up, as the interrupt triggered by hardware
setting the RXPKTRDY flag has been handled, but the flag itself remains
set.
For this scenario to occur, it is only necessary for IRQs to be enabled at
some point during the complete callback. This happens with the USB Ethernet
gadget, whose rx\_complete() callback calls netif\_rx(). If called in the
task context, netif\_rx() disables the bottom halves (BHs). When the BHs are
re-enabled, IRQs are also enabled to allow soft IRQs to be processed. The
gadget itself is initialized at module load (or at boot if built-in), but
the first request is enqueued when the network interface is brought up,
triggering rx\_complete() in the task context via ioctl(). If a packet
arrives while the interface is down, it can prevent the interface from
receiving any further packets from the USB host.
The situation is quite complicated with many parties involved. This
particular issue can be resolved in several possible ways:
1. Ensure that callbacks never enable IRQs. This would be difficult to
enforce, as discovering how netif\_rx() interacts with interrupts was
already quite challenging and u\_ether is not the only function driver.
Similar "bugs" could be hidden in other drivers as well.
2. Disable MUSB interrupts in musb\_g\_giveback() before calling the callback
and re-enable them afterwars (by calling musb\_{dis,en}able\_interrupts(),
for example). This would ensure that MUSB interrupts are not handled
during the callback, even if IRQs are enabled. In fact, it would allow
IRQs to be enabled when releasing the lock. However, this feels like an
inelegant hack.
3. Modify the interrupt handler to clear the RXPKTRDY flag if the request
queue is empty. While this approach also feels like a hack, it wastes
CPU time by attempting to handle incoming packets when the software is
not ready to process them.
4. Flush the Rx FIFO instead of calling rxstate() in musb\_ep\_restart().
This ensures that the hardware can receive packets when there is at
least one request in the queue. Once IRQs are enabled, the interrupt
handler will be able to correctly process the next incoming packet
(eventually calling rxstate()). This approach may cause one or two
packets to be dropped (two if double buffering is enabled), but this
seems to be a minor issue, as packet loss can occur when the software is
not yet ready to process them. Additionally, this solution makes the
gadget driver compliant with the rule mentioned in the docstring of
usb\_ep\_queue().
There may be additional solutions, but from these four, the last one has
been chosen as it seems to be the most appropriate, as it addresses the
"bad" behavior of the driver.
Fixes: baebdf48c360 ("net: dev: Makes sure netif\_rx() can be invoked in any context.")
Cc: stable@vger.kernel.org
Signed-off-by: Hubert Wiśniewski <hubert.wisniewski.25632@gmail.com>
Link: [https://lore.kernel.org/r/4ee1ead4525f78fb5909a8cbf99513ad0082ad21.camel@gmail.com](https://lore.kernel.org/r/4ee1ead4525f78fb5909a8cbf99513ad0082ad21.camel%40gmail.com)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5906ee3693674d734177df13a519a21bb03f730d)

| -rw-r--r-- | [drivers/usb/musb/musb\_gadget.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/musb/musb_gadget.c?id=5906ee3693674d734177df13a519a21bb03f730d) | 13 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 10 insertions, 3 deletions

| diff --git a/drivers/usb/musb/musb\_gadget.c b/drivers/usb/musb/musb\_gadget.cindex 051c6da7cf6d74..f175cb2c3e7bd2 100644--- a/[drivers/usb/musb/musb\_gadget.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/musb/musb_gadget.c?id=73934e535cffbda1490fa97d82690a0f9aa73e94)+++ b/[drivers/usb/musb/musb\_gadget.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/musb/musb_gadget.c?id=5906ee3693674d734177df13a519a21bb03f730d)@@ -1170,12 +1170,19 @@ struct free\_record { \*/ void musb\_ep\_restart(struct musb \*musb, struct musb\_request \*req) {+ u16 csr;+ void \_\_iomem \*epio = req->ep->hw\_ep->regs;+ trace\_musb\_req\_start(req); musb\_ep\_select(musb->mregs, req->epnum);- if (req->tx)+ if (req->tx) { txstate(musb, req);- else- rxstate(musb, req);+ } else {+ csr = musb\_readw(epio, MUSB\_RXCSR);+ csr |= MUSB\_RXCSR\_FLUSHFIFO | MUSB\_RXCSR\_P\_WZC\_BITS;+ musb\_writew(epio, MUSB\_RXCSR, csr);+ musb\_writew(epio, MUSB\_RXCSR, csr);+ } }  static int musb\_ep\_restart\_resume\_work(struct musb \*musb, void \*data) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 18:40:24 +0000



=== Content from git.kernel.org_e4d737e2_20250114_184147.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=3fc137386c4620305bbc2a216868c53f9245670a)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3fc137386c4620305bbc2a216868c53f9245670a)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3fc137386c4620305bbc2a216868c53f9245670a)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3fc137386c4620305bbc2a216868c53f9245670a)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Hubert Wiśniewski <hubert.wisniewski.25632@gmail.com> | 2024-11-10 18:21:48 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-12 12:14:41 +0100 |
| commit | [3fc137386c4620305bbc2a216868c53f9245670a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3fc137386c4620305bbc2a216868c53f9245670a) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=3fc137386c4620305bbc2a216868c53f9245670a)) | |
| tree | [f38fbf7a19a8c756f4e6c8704d9354feb1f0920c](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3fc137386c4620305bbc2a216868c53f9245670a) | |
| parent | [ba454a5d961a5ad70b92117846246fece51c7d19](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ba454a5d961a5ad70b92117846246fece51c7d19) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3fc137386c4620305bbc2a216868c53f9245670a&id2=ba454a5d961a5ad70b92117846246fece51c7d19)) | |
| download | [linux-3fc137386c4620305bbc2a216868c53f9245670a.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-3fc137386c4620305bbc2a216868c53f9245670a.tar.gz) | |

usb: musb: Fix hardware lockup on first Rx endpoint requestThere is a possibility that a request's callback could be invoked from
usb\_ep\_queue() (call trace below, supplemented with missing calls):
req->complete from usb\_gadget\_giveback\_request
(drivers/usb/gadget/udc/core.c:999)
usb\_gadget\_giveback\_request from musb\_g\_giveback
(drivers/usb/musb/musb\_gadget.c:147)
musb\_g\_giveback from rxstate
(drivers/usb/musb/musb\_gadget.c:784)
rxstate from musb\_ep\_restart
(drivers/usb/musb/musb\_gadget.c:1169)
musb\_ep\_restart from musb\_ep\_restart\_resume\_work
(drivers/usb/musb/musb\_gadget.c:1176)
musb\_ep\_restart\_resume\_work from musb\_queue\_resume\_work
(drivers/usb/musb/musb\_core.c:2279)
musb\_queue\_resume\_work from musb\_gadget\_queue
(drivers/usb/musb/musb\_gadget.c:1241)
musb\_gadget\_queue from usb\_ep\_queue
(drivers/usb/gadget/udc/core.c:300)
According to the docstring of usb\_ep\_queue(), this should not happen:
"Note that @req's ->complete() callback must never be called from within
usb\_ep\_queue() as that can create deadlock situations."
In fact, a hardware lockup might occur in the following sequence:
1. The gadget is initialized using musb\_gadget\_enable().
2. Meanwhile, a packet arrives, and the RXPKTRDY flag is set, raising an
interrupt.
3. If IRQs are enabled, the interrupt is handled, but musb\_g\_rx() finds an
empty queue (next\_request() returns NULL). The interrupt flag has
already been cleared by the glue layer handler, but the RXPKTRDY flag
remains set.
4. The first request is enqueued using usb\_ep\_queue(), leading to the call
of req->complete(), as shown in the call trace above.
5. If the callback enables IRQs and another packet is waiting, step (3)
repeats. The request queue is empty because usb\_g\_giveback() removes the
request before invoking the callback.
6. The endpoint remains locked up, as the interrupt triggered by hardware
setting the RXPKTRDY flag has been handled, but the flag itself remains
set.
For this scenario to occur, it is only necessary for IRQs to be enabled at
some point during the complete callback. This happens with the USB Ethernet
gadget, whose rx\_complete() callback calls netif\_rx(). If called in the
task context, netif\_rx() disables the bottom halves (BHs). When the BHs are
re-enabled, IRQs are also enabled to allow soft IRQs to be processed. The
gadget itself is initialized at module load (or at boot if built-in), but
the first request is enqueued when the network interface is brought up,
triggering rx\_complete() in the task context via ioctl(). If a packet
arrives while the interface is down, it can prevent the interface from
receiving any further packets from the USB host.
The situation is quite complicated with many parties involved. This
particular issue can be resolved in several possible ways:
1. Ensure that callbacks never enable IRQs. This would be difficult to
enforce, as discovering how netif\_rx() interacts with interrupts was
already quite challenging and u\_ether is not the only function driver.
Similar "bugs" could be hidden in other drivers as well.
2. Disable MUSB interrupts in musb\_g\_giveback() before calling the callback
and re-enable them afterwars (by calling musb\_{dis,en}able\_interrupts(),
for example). This would ensure that MUSB interrupts are not handled
during the callback, even if IRQs are enabled. In fact, it would allow
IRQs to be enabled when releasing the lock. However, this feels like an
inelegant hack.
3. Modify the interrupt handler to clear the RXPKTRDY flag if the request
queue is empty. While this approach also feels like a hack, it wastes
CPU time by attempting to handle incoming packets when the software is
not ready to process them.
4. Flush the Rx FIFO instead of calling rxstate() in musb\_ep\_restart().
This ensures that the hardware can receive packets when there is at
least one request in the queue. Once IRQs are enabled, the interrupt
handler will be able to correctly process the next incoming packet
(eventually calling rxstate()). This approach may cause one or two
packets to be dropped (two if double buffering is enabled), but this
seems to be a minor issue, as packet loss can occur when the software is
not yet ready to process them. Additionally, this solution makes the
gadget driver compliant with the rule mentioned in the docstring of
usb\_ep\_queue().
There may be additional solutions, but from these four, the last one has
been chosen as it seems to be the most appropriate, as it addresses the
"bad" behavior of the driver.
Fixes: baebdf48c360 ("net: dev: Makes sure netif\_rx() can be invoked in any context.")
Cc: stable@vger.kernel.org
Signed-off-by: Hubert Wiśniewski <hubert.wisniewski.25632@gmail.com>
Link: [https://lore.kernel.org/r/4ee1ead4525f78fb5909a8cbf99513ad0082ad21.camel@gmail.com](https://lore.kernel.org/r/4ee1ead4525f78fb5909a8cbf99513ad0082ad21.camel%40gmail.com)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3fc137386c4620305bbc2a216868c53f9245670a)

| -rw-r--r-- | [drivers/usb/musb/musb\_gadget.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/musb/musb_gadget.c?id=3fc137386c4620305bbc2a216868c53f9245670a) | 13 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 10 insertions, 3 deletions

| diff --git a/drivers/usb/musb/musb\_gadget.c b/drivers/usb/musb/musb\_gadget.cindex bdf13911a1e590..c6076df0d50cc7 100644--- a/[drivers/usb/musb/musb\_gadget.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/musb/musb_gadget.c?id=ba454a5d961a5ad70b92117846246fece51c7d19)+++ b/[drivers/usb/musb/musb\_gadget.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/musb/musb_gadget.c?id=3fc137386c4620305bbc2a216868c53f9245670a)@@ -1161,12 +1161,19 @@ void musb\_free\_request(struct usb\_ep \*ep, struct usb\_request \*req) \*/ void musb\_ep\_restart(struct musb \*musb, struct musb\_request \*req) {+ u16 csr;+ void \_\_iomem \*epio = req->ep->hw\_ep->regs;+ trace\_musb\_req\_start(req); musb\_ep\_select(musb->mregs, req->epnum);- if (req->tx)+ if (req->tx) { txstate(musb, req);- else- rxstate(musb, req);+ } else {+ csr = musb\_readw(epio, MUSB\_RXCSR);+ csr |= MUSB\_RXCSR\_FLUSHFIFO | MUSB\_RXCSR\_P\_WZC\_BITS;+ musb\_writew(epio, MUSB\_RXCSR, csr);+ musb\_writew(epio, MUSB\_RXCSR, csr);+ } }  static int musb\_ep\_restart\_resume\_work(struct musb \*musb, void \*data) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 18:40:23 +0000



=== Content from git.kernel.org_61647768_20250114_184147.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=c749500b28cae67410792096133ee7f282439c51)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=c749500b28cae67410792096133ee7f282439c51)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c749500b28cae67410792096133ee7f282439c51)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=c749500b28cae67410792096133ee7f282439c51)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Hubert Wiśniewski <hubert.wisniewski.25632@gmail.com> | 2024-11-10 18:21:48 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-14 19:54:05 +0100 |
| commit | [c749500b28cae67410792096133ee7f282439c51](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c749500b28cae67410792096133ee7f282439c51) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=c749500b28cae67410792096133ee7f282439c51)) | |
| tree | [18c8357ce839ac1e2e75daee80a37ec56e591f09](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=c749500b28cae67410792096133ee7f282439c51) | |
| parent | [338ae99f3ee0ababbb8bf9fbff67c30894a557ed](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=338ae99f3ee0ababbb8bf9fbff67c30894a557ed) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=c749500b28cae67410792096133ee7f282439c51&id2=338ae99f3ee0ababbb8bf9fbff67c30894a557ed)) | |
| download | [linux-c749500b28cae67410792096133ee7f282439c51.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-c749500b28cae67410792096133ee7f282439c51.tar.gz) | |

usb: musb: Fix hardware lockup on first Rx endpoint requestcommit 3fc137386c4620305bbc2a216868c53f9245670a upstream.
There is a possibility that a request's callback could be invoked from
usb\_ep\_queue() (call trace below, supplemented with missing calls):
req->complete from usb\_gadget\_giveback\_request
(drivers/usb/gadget/udc/core.c:999)
usb\_gadget\_giveback\_request from musb\_g\_giveback
(drivers/usb/musb/musb\_gadget.c:147)
musb\_g\_giveback from rxstate
(drivers/usb/musb/musb\_gadget.c:784)
rxstate from musb\_ep\_restart
(drivers/usb/musb/musb\_gadget.c:1169)
musb\_ep\_restart from musb\_ep\_restart\_resume\_work
(drivers/usb/musb/musb\_gadget.c:1176)
musb\_ep\_restart\_resume\_work from musb\_queue\_resume\_work
(drivers/usb/musb/musb\_core.c:2279)
musb\_queue\_resume\_work from musb\_gadget\_queue
(drivers/usb/musb/musb\_gadget.c:1241)
musb\_gadget\_queue from usb\_ep\_queue
(drivers/usb/gadget/udc/core.c:300)
According to the docstring of usb\_ep\_queue(), this should not happen:
"Note that @req's ->complete() callback must never be called from within
usb\_ep\_queue() as that can create deadlock situations."
In fact, a hardware lockup might occur in the following sequence:
1. The gadget is initialized using musb\_gadget\_enable().
2. Meanwhile, a packet arrives, and the RXPKTRDY flag is set, raising an
interrupt.
3. If IRQs are enabled, the interrupt is handled, but musb\_g\_rx() finds an
empty queue (next\_request() returns NULL). The interrupt flag has
already been cleared by the glue layer handler, but the RXPKTRDY flag
remains set.
4. The first request is enqueued using usb\_ep\_queue(), leading to the call
of req->complete(), as shown in the call trace above.
5. If the callback enables IRQs and another packet is waiting, step (3)
repeats. The request queue is empty because usb\_g\_giveback() removes the
request before invoking the callback.
6. The endpoint remains locked up, as the interrupt triggered by hardware
setting the RXPKTRDY flag has been handled, but the flag itself remains
set.
For this scenario to occur, it is only necessary for IRQs to be enabled at
some point during the complete callback. This happens with the USB Ethernet
gadget, whose rx\_complete() callback calls netif\_rx(). If called in the
task context, netif\_rx() disables the bottom halves (BHs). When the BHs are
re-enabled, IRQs are also enabled to allow soft IRQs to be processed. The
gadget itself is initialized at module load (or at boot if built-in), but
the first request is enqueued when the network interface is brought up,
triggering rx\_complete() in the task context via ioctl(). If a packet
arrives while the interface is down, it can prevent the interface from
receiving any further packets from the USB host.
The situation is quite complicated with many parties involved. This
particular issue can be resolved in several possible ways:
1. Ensure that callbacks never enable IRQs. This would be difficult to
enforce, as discovering how netif\_rx() interacts with interrupts was
already quite challenging and u\_ether is not the only function driver.
Similar "bugs" could be hidden in other drivers as well.
2. Disable MUSB interrupts in musb\_g\_giveback() before calling the callback
and re-enable them afterwars (by calling musb\_{dis,en}able\_interrupts(),
for example). This would ensure that MUSB interrupts are not handled
during the callback, even if IRQs are enabled. In fact, it would allow
IRQs to be enabled when releasing the lock. However, this feels like an
inelegant hack.
3. Modify the interrupt handler to clear the RXPKTRDY flag if the request
queue is empty. While this approach also feels like a hack, it wastes
CPU time by attempting to handle incoming packets when the software is
not ready to process them.
4. Flush the Rx FIFO instead of calling rxstate() in musb\_ep\_restart().
This ensures that the hardware can receive packets when there is at
least one request in the queue. Once IRQs are enabled, the interrupt
handler will be able to correctly process the next incoming packet
(eventually calling rxstate()). This approach may cause one or two
packets to be dropped (two if double buffering is enabled), but this
seems to be a minor issue, as packet loss can occur when the software is
not yet ready to process them. Additionally, this solution makes the
gadget driver compliant with the rule mentioned in the docstring of
usb\_ep\_queue().
There may be additional solutions, but from these four, the last one has
been chosen as it seems to be the most appropriate, as it addresses the
"bad" behavior of the driver.
Fixes: baebdf48c360 ("net: dev: Makes sure netif\_rx() can be invoked in any context.")
Cc: stable@vger.kernel.org
Signed-off-by: Hubert Wiśniewski <hubert.wisniewski.25632@gmail.com>
Link: [https://lore.kernel.org/r/4ee1ead4525f78fb5909a8cbf99513ad0082ad21.camel@gmail.com](https://lore.kernel.org/r/4ee1ead4525f78fb5909a8cbf99513ad0082ad21.camel%40gmail.com)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=c749500b28cae67410792096133ee7f282439c51)

| -rw-r--r-- | [drivers/usb/musb/musb\_gadget.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/musb/musb_gadget.c?id=c749500b28cae67410792096133ee7f282439c51) | 13 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 10 insertions, 3 deletions

| diff --git a/drivers/usb/musb/musb\_gadget.c b/drivers/usb/musb/musb\_gadget.cindex ba20272d222152..eb3464f977a7f4 100644--- a/[drivers/usb/musb/musb\_gadget.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/musb/musb_gadget.c?id=338ae99f3ee0ababbb8bf9fbff67c30894a557ed)+++ b/[drivers/usb/musb/musb\_gadget.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/musb/musb_gadget.c?id=c749500b28cae67410792096133ee7f282439c51)@@ -1170,12 +1170,19 @@ struct free\_record { \*/ void musb\_ep\_restart(struct musb \*musb, struct musb\_request \*req) {+ u16 csr;+ void \_\_iomem \*epio = req->ep->hw\_ep->regs;+ trace\_musb\_req\_start(req); musb\_ep\_select(musb->mregs, req->epnum);- if (req->tx)+ if (req->tx) { txstate(musb, req);- else- rxstate(musb, req);+ } else {+ csr = musb\_readw(epio, MUSB\_RXCSR);+ csr |= MUSB\_RXCSR\_FLUSHFIFO | MUSB\_RXCSR\_P\_WZC\_BITS;+ musb\_writew(epio, MUSB\_RXCSR, csr);+ musb\_writew(epio, MUSB\_RXCSR, csr);+ } }  static int musb\_ep\_restart\_resume\_work(struct musb \*musb, void \*data) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 18:40:25 +0000



=== Content from git.kernel.org_3a704aa4_20250114_184146.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=0c89445e6d475b78d37b64ae520831cd43af7db4)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0c89445e6d475b78d37b64ae520831cd43af7db4)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0c89445e6d475b78d37b64ae520831cd43af7db4)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0c89445e6d475b78d37b64ae520831cd43af7db4)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Hubert Wiśniewski <hubert.wisniewski.25632@gmail.com> | 2024-11-10 18:21:48 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-05 14:03:00 +0100 |
| commit | [0c89445e6d475b78d37b64ae520831cd43af7db4](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0c89445e6d475b78d37b64ae520831cd43af7db4) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=0c89445e6d475b78d37b64ae520831cd43af7db4)) | |
| tree | [3f4fe76b9f23ab95466694415f08321ecb47a315](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0c89445e6d475b78d37b64ae520831cd43af7db4) | |
| parent | [068aab9564d4a2e1224c853773a09934c23526b8](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=068aab9564d4a2e1224c853773a09934c23526b8) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0c89445e6d475b78d37b64ae520831cd43af7db4&id2=068aab9564d4a2e1224c853773a09934c23526b8)) | |
| download | [linux-0c89445e6d475b78d37b64ae520831cd43af7db4.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-0c89445e6d475b78d37b64ae520831cd43af7db4.tar.gz) | |

usb: musb: Fix hardware lockup on first Rx endpoint requestcommit 3fc137386c4620305bbc2a216868c53f9245670a upstream.
There is a possibility that a request's callback could be invoked from
usb\_ep\_queue() (call trace below, supplemented with missing calls):
req->complete from usb\_gadget\_giveback\_request
(drivers/usb/gadget/udc/core.c:999)
usb\_gadget\_giveback\_request from musb\_g\_giveback
(drivers/usb/musb/musb\_gadget.c:147)
musb\_g\_giveback from rxstate
(drivers/usb/musb/musb\_gadget.c:784)
rxstate from musb\_ep\_restart
(drivers/usb/musb/musb\_gadget.c:1169)
musb\_ep\_restart from musb\_ep\_restart\_resume\_work
(drivers/usb/musb/musb\_gadget.c:1176)
musb\_ep\_restart\_resume\_work from musb\_queue\_resume\_work
(drivers/usb/musb/musb\_core.c:2279)
musb\_queue\_resume\_work from musb\_gadget\_queue
(drivers/usb/musb/musb\_gadget.c:1241)
musb\_gadget\_queue from usb\_ep\_queue
(drivers/usb/gadget/udc/core.c:300)
According to the docstring of usb\_ep\_queue(), this should not happen:
"Note that @req's ->complete() callback must never be called from within
usb\_ep\_queue() as that can create deadlock situations."
In fact, a hardware lockup might occur in the following sequence:
1. The gadget is initialized using musb\_gadget\_enable().
2. Meanwhile, a packet arrives, and the RXPKTRDY flag is set, raising an
interrupt.
3. If IRQs are enabled, the interrupt is handled, but musb\_g\_rx() finds an
empty queue (next\_request() returns NULL). The interrupt flag has
already been cleared by the glue layer handler, but the RXPKTRDY flag
remains set.
4. The first request is enqueued using usb\_ep\_queue(), leading to the call
of req->complete(), as shown in the call trace above.
5. If the callback enables IRQs and another packet is waiting, step (3)
repeats. The request queue is empty because usb\_g\_giveback() removes the
request before invoking the callback.
6. The endpoint remains locked up, as the interrupt triggered by hardware
setting the RXPKTRDY flag has been handled, but the flag itself remains
set.
For this scenario to occur, it is only necessary for IRQs to be enabled at
some point during the complete callback. This happens with the USB Ethernet
gadget, whose rx\_complete() callback calls netif\_rx(). If called in the
task context, netif\_rx() disables the bottom halves (BHs). When the BHs are
re-enabled, IRQs are also enabled to allow soft IRQs to be processed. The
gadget itself is initialized at module load (or at boot if built-in), but
the first request is enqueued when the network interface is brought up,
triggering rx\_complete() in the task context via ioctl(). If a packet
arrives while the interface is down, it can prevent the interface from
receiving any further packets from the USB host.
The situation is quite complicated with many parties involved. This
particular issue can be resolved in several possible ways:
1. Ensure that callbacks never enable IRQs. This would be difficult to
enforce, as discovering how netif\_rx() interacts with interrupts was
already quite challenging and u\_ether is not the only function driver.
Similar "bugs" could be hidden in other drivers as well.
2. Disable MUSB interrupts in musb\_g\_giveback() before calling the callback
and re-enable them afterwars (by calling musb\_{dis,en}able\_interrupts(),
for example). This would ensure that MUSB interrupts are not handled
during the callback, even if IRQs are enabled. In fact, it would allow
IRQs to be enabled when releasing the lock. However, this feels like an
inelegant hack.
3. Modify the interrupt handler to clear the RXPKTRDY flag if the request
queue is empty. While this approach also feels like a hack, it wastes
CPU time by attempting to handle incoming packets when the software is
not ready to process them.
4. Flush the Rx FIFO instead of calling rxstate() in musb\_ep\_restart().
This ensures that the hardware can receive packets when there is at
least one request in the queue. Once IRQs are enabled, the interrupt
handler will be able to correctly process the next incoming packet
(eventually calling rxstate()). This approach may cause one or two
packets to be dropped (two if double buffering is enabled), but this
seems to be a minor issue, as packet loss can occur when the software is
not yet ready to process them. Additionally, this solution makes the
gadget driver compliant with the rule mentioned in the docstring of
usb\_ep\_queue().
There may be additional solutions, but from these four, the last one has
been chosen as it seems to be the most appropriate, as it addresses the
"bad" behavior of the driver.
Fixes: baebdf48c360 ("net: dev: Makes sure netif\_rx() can be invoked in any context.")
Cc: stable@vger.kernel.org
Signed-off-by: Hubert Wiśniewski <hubert.wisniewski.25632@gmail.com>
Link: [https://lore.kernel.org/r/4ee1ead4525f78fb5909a8cbf99513ad0082ad21.camel@gmail.com](https://lore.kernel.org/r/4ee1ead4525f78fb5909a8cbf99513ad0082ad21.camel%40gmail.com)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0c89445e6d475b78d37b64ae520831cd43af7db4)

| -rw-r--r-- | [drivers/usb/musb/musb\_gadget.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/musb/musb_gadget.c?id=0c89445e6d475b78d37b64ae520831cd43af7db4) | 13 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 10 insertions, 3 deletions

| diff --git a/drivers/usb/musb/musb\_gadget.c b/drivers/usb/musb/musb\_gadget.cindex bdf13911a1e590..c6076df0d50cc7 100644--- a/[drivers/usb/musb/musb\_gadget.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/musb/musb_gadget.c?id=068aab9564d4a2e1224c853773a09934c23526b8)+++ b/[drivers/usb/musb/musb\_gadget.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/musb/musb_gadget.c?id=0c89445e6d475b78d37b64ae520831cd43af7db4)@@ -1161,12 +1161,19 @@ void musb\_free\_request(struct usb\_ep \*ep, struct usb\_request \*req) \*/ void musb\_ep\_restart(struct musb \*musb, struct musb\_request \*req) {+ u16 csr;+ void \_\_iomem \*epio = req->ep->hw\_ep->regs;+ trace\_musb\_req\_start(req); musb\_ep\_select(musb->mregs, req->epnum);- if (req->tx)+ if (req->tx) { txstate(musb, req);- else- rxstate(musb, req);+ } else {+ csr = musb\_readw(epio, MUSB\_RXCSR);+ csr |= MUSB\_RXCSR\_FLUSHFIFO | MUSB\_RXCSR\_P\_WZC\_BITS;+ musb\_writew(epio, MUSB\_RXCSR, csr);+ musb\_writew(epio, MUSB\_RXCSR, csr);+ } }  static int musb\_ep\_restart\_resume\_work(struct musb \*musb, void \*data) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 18:40:23 +0000


