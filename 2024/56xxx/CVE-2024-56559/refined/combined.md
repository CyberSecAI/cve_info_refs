=== Content from git.kernel.org_22f857b2_20250114_223323.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=9e9e085effe9b7e342138fde3cf8577d22509932)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9e9e085effe9b7e342138fde3cf8577d22509932)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9e9e085effe9b7e342138fde3cf8577d22509932)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9e9e085effe9b7e342138fde3cf8577d22509932)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Adrian Huang <ahuang12@lenovo.com> | 2024-07-27 00:52:46 +0800 |
| --- | --- | --- |
| committer | Andrew Morton <akpm@linux-foundation.org> | 2024-11-05 16:56:21 -0800 |
| commit | [9e9e085effe9b7e342138fde3cf8577d22509932](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9e9e085effe9b7e342138fde3cf8577d22509932) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=9e9e085effe9b7e342138fde3cf8577d22509932)) | |
| tree | [8eeffcc0ecb1aa764c6963d5acbd0f54aae060f8](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9e9e085effe9b7e342138fde3cf8577d22509932) | |
| parent | [15ff4d409e1a6f939d94d2005ae275c26b2b0d9d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=15ff4d409e1a6f939d94d2005ae275c26b2b0d9d) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9e9e085effe9b7e342138fde3cf8577d22509932&id2=15ff4d409e1a6f939d94d2005ae275c26b2b0d9d)) | |
| download | [linux-9e9e085effe9b7e342138fde3cf8577d22509932.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-9e9e085effe9b7e342138fde3cf8577d22509932.tar.gz) | |

mm/vmalloc: combine all TLB flush operations of KASAN shadow virtual address into one operationWhen compiling kernel source 'make -j $(nproc)' with the up-and-running
KASAN-enabled kernel on a 256-core machine, the following soft lockup is
shown:
watchdog: BUG: soft lockup - CPU#28 stuck for 22s! [kworker/28:1:1760]
CPU: 28 PID: 1760 Comm: kworker/28:1 Kdump: loaded Not tainted 6.10.0-rc5 #95
Workqueue: events drain\_vmap\_area\_work
RIP: 0010:smp\_call\_function\_many\_cond+0x1d8/0xbb0
Code: 38 c8 7c 08 84 c9 0f 85 49 08 00 00 8b 45 08 a8 01 74 2e 48 89 f1 49 89 f7 48 c1 e9 03 41 83 e7 07 4c 01 e9 41 83 c7 03 f3 90 <0f> b6 01 41 38 c7 7c 08 84 c0 0f 85 d4 06 00 00 8b 45 08 a8 01 75
RSP: 0018:ffffc9000cb3fb60 EFLAGS: 00000202
RAX: 0000000000000011 RBX: ffff8883bc4469c0 RCX: ffffed10776e9949
RDX: 0000000000000002 RSI: ffff8883bb74ca48 RDI: ffffffff8434dc50
RBP: ffff8883bb74ca40 R08: ffff888103585dc0 R09: ffff8884533a1800
R10: 0000000000000004 R11: ffffffffffffffff R12: ffffed1077888d39
R13: dffffc0000000000 R14: ffffed1077888d38 R15: 0000000000000003
FS: 0000000000000000(0000) GS:ffff8883bc400000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00005577b5c8d158 CR3: 0000000004850000 CR4: 0000000000350ef0
Call Trace:
<IRQ>
? watchdog\_timer\_fn+0x2cd/0x390
? \_\_pfx\_watchdog\_timer\_fn+0x10/0x10
? \_\_hrtimer\_run\_queues+0x300/0x6d0
? sched\_clock\_cpu+0x69/0x4e0
? \_\_pfx\_\_\_hrtimer\_run\_queues+0x10/0x10
? srso\_return\_thunk+0x5/0x5f
? ktime\_get\_update\_offsets\_now+0x7f/0x2a0
? srso\_return\_thunk+0x5/0x5f
? srso\_return\_thunk+0x5/0x5f
? hrtimer\_interrupt+0x2ca/0x760
? \_\_sysvec\_apic\_timer\_interrupt+0x8c/0x2b0
? sysvec\_apic\_timer\_interrupt+0x6a/0x90
</IRQ>
<TASK>
? asm\_sysvec\_apic\_timer\_interrupt+0x16/0x20
? smp\_call\_function\_many\_cond+0x1d8/0xbb0
? \_\_pfx\_do\_kernel\_range\_flush+0x10/0x10
on\_each\_cpu\_cond\_mask+0x20/0x40
flush\_tlb\_kernel\_range+0x19b/0x250
? srso\_return\_thunk+0x5/0x5f
? kasan\_release\_vmalloc+0xa7/0xc0
purge\_vmap\_node+0x357/0x820
? \_\_pfx\_purge\_vmap\_node+0x10/0x10
\_\_purge\_vmap\_area\_lazy+0x5b8/0xa10
drain\_vmap\_area\_work+0x21/0x30
process\_one\_work+0x661/0x10b0
worker\_thread+0x844/0x10e0
? srso\_return\_thunk+0x5/0x5f
? \_\_kthread\_parkme+0x82/0x140
? \_\_pfx\_worker\_thread+0x10/0x10
kthread+0x2a5/0x370
? \_\_pfx\_kthread+0x10/0x10
ret\_from\_fork+0x30/0x70
? \_\_pfx\_kthread+0x10/0x10
ret\_from\_fork\_asm+0x1a/0x30
</TASK>
Debugging Analysis:
1. The following ftrace log shows that the lockup CPU spends too much
time iterating vmap\_nodes and flushing TLB when purging vm\_area
structures. (Some info is trimmed).
kworker: funcgraph\_entry: | drain\_vmap\_area\_work() {
kworker: funcgraph\_entry: | mutex\_lock() {
kworker: funcgraph\_entry: 1.092 us | \_\_cond\_resched();
kworker: funcgraph\_exit: 3.306 us | }
... ...
kworker: funcgraph\_entry: | flush\_tlb\_kernel\_range() {
... ...
kworker: funcgraph\_exit: # 7533.649 us | }
... ...
kworker: funcgraph\_entry: 2.344 us | mutex\_unlock();
kworker: funcgraph\_exit: $ 23871554 us | }
The drain\_vmap\_area\_work() spends over 23 seconds.
There are 2805 flush\_tlb\_kernel\_range() calls in the ftrace log.
\* One is called in \_\_purge\_vmap\_area\_lazy().
\* Others are called by purge\_vmap\_node->kasan\_release\_vmalloc.
purge\_vmap\_node() iteratively releases kasan vmalloc
allocations and flushes TLB for each vmap\_area.
- [Rough calculation] Each flush\_tlb\_kernel\_range() runs
about 7.5ms.
-- 2804 \* 7.5ms = 21.03 seconds.
-- That's why a soft lock is triggered.
2. Extending the soft lockup time can work around the issue (For example,
# echo 60 > /proc/sys/kernel/watchdog\_thresh). This confirms the
above-mentioned speculation: drain\_vmap\_area\_work() spends too much
time.
If we combine all TLB flush operations of the KASAN shadow virtual
address into one operation in the call path
'purge\_vmap\_node()->kasan\_release\_vmalloc()', the running time of
drain\_vmap\_area\_work() can be saved greatly. The idea is from the
flush\_tlb\_kernel\_range() call in \_\_purge\_vmap\_area\_lazy(). And, the
soft lockup won't be triggered.
Here is the test result based on 6.10:
[6.10 wo/ the patch]
1. ftrace latency profiling (record a trace if the latency > 20s).
echo 20000000 > /sys/kernel/debug/tracing/tracing\_thresh
echo drain\_vmap\_area\_work > /sys/kernel/debug/tracing/set\_graph\_function
echo function\_graph > /sys/kernel/debug/tracing/current\_tracer
echo 1 > /sys/kernel/debug/tracing/tracing\_on
2. Run `make -j $(nproc)` to compile the kernel source
3. Once the soft lockup is reproduced, check the ftrace log:
cat /sys/kernel/debug/tracing/trace
# tracer: function\_graph
#
# CPU DURATION FUNCTION CALLS
# | | | | | | |
76) $ 50412985 us | } /\* \_\_purge\_vmap\_area\_lazy \*/
76) $ 50412997 us | } /\* drain\_vmap\_area\_work \*/
76) $ 29165911 us | } /\* \_\_purge\_vmap\_area\_lazy \*/
76) $ 29165926 us | } /\* drain\_vmap\_area\_work \*/
91) $ 53629423 us | } /\* \_\_purge\_vmap\_area\_lazy \*/
91) $ 53629434 us | } /\* drain\_vmap\_area\_work \*/
91) $ 28121014 us | } /\* \_\_purge\_vmap\_area\_lazy \*/
91) $ 28121026 us | } /\* drain\_vmap\_area\_work \*/
[6.10 w/ the patch]
1. Repeat step 1-2 in "[6.10 wo/ the patch]"
2. The soft lockup is not triggered and ftrace log is empty.
cat /sys/kernel/debug/tracing/trace
# tracer: function\_graph
#
# CPU DURATION FUNCTION CALLS
# | | | | | | |
3. Setting 'tracing\_thresh' to 10/5 seconds does not get any ftrace
log.
4. Setting 'tracing\_thresh' to 1 second gets ftrace log.
cat /sys/kernel/debug/tracing/trace
# tracer: function\_graph
#
# CPU DURATION FUNCTION CALLS
# | | | | | | |
23) $ 1074942 us | } /\* \_\_purge\_vmap\_area\_lazy \*/
23) $ 1074950 us | } /\* drain\_vmap\_area\_work \*/
The worst execution time of drain\_vmap\_area\_work() is about 1 second.
Link: [https://lore.kernel.org/lkml/ZqFlawuVnOMY2k3E@pc638.lan/](https://lore.kernel.org/lkml/ZqFlawuVnOMY2k3E%40pc638.lan/)
Link: [https://lkml.kernel.org/r/20240726165246.31326-1-ahuang12@lenovo.com](https://lkml.kernel.org/r/20240726165246.31326-1-ahuang12%40lenovo.com)
Fixes: 282631cb2447 ("mm: vmalloc: remove global purge\_vmap\_area\_root rb-tree")
Signed-off-by: Adrian Huang <ahuang12@lenovo.com>
Co-developed-by: Uladzislau Rezki (Sony) <urezki@gmail.com>
Signed-off-by: Uladzislau Rezki (Sony) <urezki@gmail.com>
Tested-by: Jiwei Sun <sunjw10@lenovo.com>
Reviewed-by: Baoquan He <bhe@redhat.com>
Cc: Alexander Potapenko <glider@google.com>
Cc: Andrey Konovalov <andreyknvl@gmail.com>
Cc: Andrey Ryabinin <ryabinin.a.a@gmail.com>
Cc: Christoph Hellwig <hch@infradead.org>
Cc: Dmitry Vyukov <dvyukov@google.com>
Cc: Vincenzo Frascino <vincenzo.frascino@arm.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9e9e085effe9b7e342138fde3cf8577d22509932)

| -rw-r--r-- | [include/linux/kasan.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/kasan.h?id=9e9e085effe9b7e342138fde3cf8577d22509932) | 12 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [mm/kasan/shadow.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/kasan/shadow.c?id=9e9e085effe9b7e342138fde3cf8577d22509932) | 14 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [mm/vmalloc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/vmalloc.c?id=9e9e085effe9b7e342138fde3cf8577d22509932) | 34 | |  |  |  | | --- | --- | --- | |

3 files changed, 45 insertions, 15 deletions

| diff --git a/include/linux/kasan.h b/include/linux/kasan.hindex 00a3bf7c0d8f0e..6bbfc8aa42e8f4 100644--- a/[include/linux/kasan.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/kasan.h?id=15ff4d409e1a6f939d94d2005ae275c26b2b0d9d)+++ b/[include/linux/kasan.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/kasan.h?id=9e9e085effe9b7e342138fde3cf8577d22509932)@@ -29,6 +29,9 @@ typedef unsigned int \_\_bitwise kasan\_vmalloc\_flags\_t; #define KASAN\_VMALLOC\_VM\_ALLOC ((\_\_force kasan\_vmalloc\_flags\_t)0x02u) #define KASAN\_VMALLOC\_PROT\_NORMAL ((\_\_force kasan\_vmalloc\_flags\_t)0x04u) +#define KASAN\_VMALLOC\_PAGE\_RANGE 0x1 /\* Apply exsiting page range \*/+#define KASAN\_VMALLOC\_TLB\_FLUSH 0x2 /\* TLB flush \*/+ #if defined(CONFIG\_KASAN\_GENERIC) || defined(CONFIG\_KASAN\_SW\_TAGS)  #include <linux/pgtable.h>@@ -564,7 +567,8 @@ void kasan\_populate\_early\_vm\_area\_shadow(void \*start, unsigned long size); int kasan\_populate\_vmalloc(unsigned long addr, unsigned long size); void kasan\_release\_vmalloc(unsigned long start, unsigned long end, unsigned long free\_region\_start,- unsigned long free\_region\_end);+ unsigned long free\_region\_end,+ unsigned long flags);  #else /\* CONFIG\_KASAN\_GENERIC || CONFIG\_KASAN\_SW\_TAGS \*/ @@ -579,7 +583,8 @@ static inline int kasan\_populate\_vmalloc(unsigned long start, static inline void kasan\_release\_vmalloc(unsigned long start, unsigned long end, unsigned long free\_region\_start,- unsigned long free\_region\_end) { }+ unsigned long free\_region\_end,+ unsigned long flags) { }  #endif /\* CONFIG\_KASAN\_GENERIC || CONFIG\_KASAN\_SW\_TAGS \*/ @@ -614,7 +619,8 @@ static inline int kasan\_populate\_vmalloc(unsigned long start, static inline void kasan\_release\_vmalloc(unsigned long start, unsigned long end, unsigned long free\_region\_start,- unsigned long free\_region\_end) { }+ unsigned long free\_region\_end,+ unsigned long flags) { }  static inline void \*kasan\_unpoison\_vmalloc(const void \*start, unsigned long size,diff --git a/mm/kasan/shadow.c b/mm/kasan/shadow.cindex d6210ca48ddab9..88d1c9dcb50721 100644--- a/[mm/kasan/shadow.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/kasan/shadow.c?id=15ff4d409e1a6f939d94d2005ae275c26b2b0d9d)+++ b/[mm/kasan/shadow.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/kasan/shadow.c?id=9e9e085effe9b7e342138fde3cf8577d22509932)@@ -489,7 +489,8 @@ static int kasan\_depopulate\_vmalloc\_pte(pte\_t \*ptep, unsigned long addr, \*/ void kasan\_release\_vmalloc(unsigned long start, unsigned long end, unsigned long free\_region\_start,- unsigned long free\_region\_end)+ unsigned long free\_region\_end,+ unsigned long flags) { void \*shadow\_start, \*shadow\_end; unsigned long region\_start, region\_end;@@ -522,12 +523,17 @@ void kasan\_release\_vmalloc(unsigned long start, unsigned long end, \_\_memset(shadow\_start, KASAN\_SHADOW\_INIT, shadow\_end - shadow\_start); return; }- apply\_to\_existing\_page\_range(&init\_mm,+++ if (flags & KASAN\_VMALLOC\_PAGE\_RANGE)+ apply\_to\_existing\_page\_range(&init\_mm, (unsigned long)shadow\_start, size, kasan\_depopulate\_vmalloc\_pte, NULL);- flush\_tlb\_kernel\_range((unsigned long)shadow\_start,- (unsigned long)shadow\_end);++ if (flags & KASAN\_VMALLOC\_TLB\_FLUSH)+ flush\_tlb\_kernel\_range((unsigned long)shadow\_start,+ (unsigned long)shadow\_end); } } diff --git a/mm/vmalloc.c b/mm/vmalloc.cindex 634162271c0045..5480b77f4167d7 100644--- a/[mm/vmalloc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/vmalloc.c?id=15ff4d409e1a6f939d94d2005ae275c26b2b0d9d)+++ b/[mm/vmalloc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/vmalloc.c?id=9e9e085effe9b7e342138fde3cf8577d22509932)@@ -2182,6 +2182,25 @@ decay\_va\_pool\_node(struct vmap\_node \*vn, bool full\_decay) reclaim\_list\_global(&decay\_list); } +static void+kasan\_release\_vmalloc\_node(struct vmap\_node \*vn)+{+ struct vmap\_area \*va;+ unsigned long start, end;++ start = list\_first\_entry(&vn->purge\_list, struct vmap\_area, list)->va\_start;+ end = list\_last\_entry(&vn->purge\_list, struct vmap\_area, list)->va\_end;++ list\_for\_each\_entry(va, &vn->purge\_list, list) {+ if (is\_vmalloc\_or\_module\_addr((void \*) va->va\_start))+ kasan\_release\_vmalloc(va->va\_start, va->va\_end,+ va->va\_start, va->va\_end,+ KASAN\_VMALLOC\_PAGE\_RANGE);+ }++ kasan\_release\_vmalloc(start, end, start, end, KASAN\_VMALLOC\_TLB\_FLUSH);+}+ static void purge\_vmap\_node(struct work\_struct \*work) { struct vmap\_node \*vn = container\_of(work,@@ -2190,20 +2209,17 @@ static void purge\_vmap\_node(struct work\_struct \*work) struct vmap\_area \*va, \*n\_va; LIST\_HEAD(local\_list); + if (IS\_ENABLED(CONFIG\_KASAN\_VMALLOC))+ kasan\_release\_vmalloc\_node(vn);+ vn->nr\_purged = 0;  list\_for\_each\_entry\_safe(va, n\_va, &vn->purge\_list, list) { unsigned long nr = va\_size(va) >> PAGE\_SHIFT;- unsigned long orig\_start = va->va\_start;- unsigned long orig\_end = va->va\_end; unsigned int vn\_id = decode\_vn\_id(va->flags);  list\_del\_init(&va->list); - if (is\_vmalloc\_or\_module\_addr((void \*)orig\_start))- kasan\_release\_vmalloc(orig\_start, orig\_end,- va->va\_start, va->va\_end);- nr\_purged\_pages += nr; vn->nr\_purged++; @@ -4784,7 +4800,8 @@ recovery: &free\_vmap\_area\_list); if (va) kasan\_release\_vmalloc(orig\_start, orig\_end,- va->va\_start, va->va\_end);+ va->va\_start, va->va\_end,+ KASAN\_VMALLOC\_PAGE\_RANGE | KASAN\_VMALLOC\_TLB\_FLUSH); vas[area] = NULL; } @@ -4834,7 +4851,8 @@ err\_free\_shadow: &free\_vmap\_area\_list); if (va) kasan\_release\_vmalloc(orig\_start, orig\_end,- va->va\_start, va->va\_end);+ va->va\_start, va->va\_end,+ KASAN\_VMALLOC\_PAGE\_RANGE | KASAN\_VMALLOC\_TLB\_FLUSH); vas[area] = NULL; kfree(vms[area]); } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 22:32:00 +0000



=== Content from git.kernel.org_1580c296_20250114_223324.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Adrian Huang <ahuang12@lenovo.com> | 2024-07-27 00:52:46 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-09 10:41:08 +0100 |
| commit | [f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f)) | |
| tree | [0e305d6819ccaafa7580dcc60c036e6ca3d3af0e](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f) | |
| parent | [1ba771763d1b75443b534ec943785ff0454c1584](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1ba771763d1b75443b534ec943785ff0454c1584) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f&id2=1ba771763d1b75443b534ec943785ff0454c1584)) | |
| download | [linux-f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f.tar.gz) | |

mm/vmalloc: combine all TLB flush operations of KASAN shadow virtual address into one operationcommit 9e9e085effe9b7e342138fde3cf8577d22509932 upstream.
When compiling kernel source 'make -j $(nproc)' with the up-and-running
KASAN-enabled kernel on a 256-core machine, the following soft lockup is
shown:
watchdog: BUG: soft lockup - CPU#28 stuck for 22s! [kworker/28:1:1760]
CPU: 28 PID: 1760 Comm: kworker/28:1 Kdump: loaded Not tainted 6.10.0-rc5 #95
Workqueue: events drain\_vmap\_area\_work
RIP: 0010:smp\_call\_function\_many\_cond+0x1d8/0xbb0
Code: 38 c8 7c 08 84 c9 0f 85 49 08 00 00 8b 45 08 a8 01 74 2e 48 89 f1 49 89 f7 48 c1 e9 03 41 83 e7 07 4c 01 e9 41 83 c7 03 f3 90 <0f> b6 01 41 38 c7 7c 08 84 c0 0f 85 d4 06 00 00 8b 45 08 a8 01 75
RSP: 0018:ffffc9000cb3fb60 EFLAGS: 00000202
RAX: 0000000000000011 RBX: ffff8883bc4469c0 RCX: ffffed10776e9949
RDX: 0000000000000002 RSI: ffff8883bb74ca48 RDI: ffffffff8434dc50
RBP: ffff8883bb74ca40 R08: ffff888103585dc0 R09: ffff8884533a1800
R10: 0000000000000004 R11: ffffffffffffffff R12: ffffed1077888d39
R13: dffffc0000000000 R14: ffffed1077888d38 R15: 0000000000000003
FS: 0000000000000000(0000) GS:ffff8883bc400000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00005577b5c8d158 CR3: 0000000004850000 CR4: 0000000000350ef0
Call Trace:
<IRQ>
? watchdog\_timer\_fn+0x2cd/0x390
? \_\_pfx\_watchdog\_timer\_fn+0x10/0x10
? \_\_hrtimer\_run\_queues+0x300/0x6d0
? sched\_clock\_cpu+0x69/0x4e0
? \_\_pfx\_\_\_hrtimer\_run\_queues+0x10/0x10
? srso\_return\_thunk+0x5/0x5f
? ktime\_get\_update\_offsets\_now+0x7f/0x2a0
? srso\_return\_thunk+0x5/0x5f
? srso\_return\_thunk+0x5/0x5f
? hrtimer\_interrupt+0x2ca/0x760
? \_\_sysvec\_apic\_timer\_interrupt+0x8c/0x2b0
? sysvec\_apic\_timer\_interrupt+0x6a/0x90
</IRQ>
<TASK>
? asm\_sysvec\_apic\_timer\_interrupt+0x16/0x20
? smp\_call\_function\_many\_cond+0x1d8/0xbb0
? \_\_pfx\_do\_kernel\_range\_flush+0x10/0x10
on\_each\_cpu\_cond\_mask+0x20/0x40
flush\_tlb\_kernel\_range+0x19b/0x250
? srso\_return\_thunk+0x5/0x5f
? kasan\_release\_vmalloc+0xa7/0xc0
purge\_vmap\_node+0x357/0x820
? \_\_pfx\_purge\_vmap\_node+0x10/0x10
\_\_purge\_vmap\_area\_lazy+0x5b8/0xa10
drain\_vmap\_area\_work+0x21/0x30
process\_one\_work+0x661/0x10b0
worker\_thread+0x844/0x10e0
? srso\_return\_thunk+0x5/0x5f
? \_\_kthread\_parkme+0x82/0x140
? \_\_pfx\_worker\_thread+0x10/0x10
kthread+0x2a5/0x370
? \_\_pfx\_kthread+0x10/0x10
ret\_from\_fork+0x30/0x70
? \_\_pfx\_kthread+0x10/0x10
ret\_from\_fork\_asm+0x1a/0x30
</TASK>
Debugging Analysis:
1. The following ftrace log shows that the lockup CPU spends too much
time iterating vmap\_nodes and flushing TLB when purging vm\_area
structures. (Some info is trimmed).
kworker: funcgraph\_entry: | drain\_vmap\_area\_work() {
kworker: funcgraph\_entry: | mutex\_lock() {
kworker: funcgraph\_entry: 1.092 us | \_\_cond\_resched();
kworker: funcgraph\_exit: 3.306 us | }
... ...
kworker: funcgraph\_entry: | flush\_tlb\_kernel\_range() {
... ...
kworker: funcgraph\_exit: # 7533.649 us | }
... ...
kworker: funcgraph\_entry: 2.344 us | mutex\_unlock();
kworker: funcgraph\_exit: $ 23871554 us | }
The drain\_vmap\_area\_work() spends over 23 seconds.
There are 2805 flush\_tlb\_kernel\_range() calls in the ftrace log.
\* One is called in \_\_purge\_vmap\_area\_lazy().
\* Others are called by purge\_vmap\_node->kasan\_release\_vmalloc.
purge\_vmap\_node() iteratively releases kasan vmalloc
allocations and flushes TLB for each vmap\_area.
- [Rough calculation] Each flush\_tlb\_kernel\_range() runs
about 7.5ms.
-- 2804 \* 7.5ms = 21.03 seconds.
-- That's why a soft lock is triggered.
2. Extending the soft lockup time can work around the issue (For example,
# echo 60 > /proc/sys/kernel/watchdog\_thresh). This confirms the
above-mentioned speculation: drain\_vmap\_area\_work() spends too much
time.
If we combine all TLB flush operations of the KASAN shadow virtual
address into one operation in the call path
'purge\_vmap\_node()->kasan\_release\_vmalloc()', the running time of
drain\_vmap\_area\_work() can be saved greatly. The idea is from the
flush\_tlb\_kernel\_range() call in \_\_purge\_vmap\_area\_lazy(). And, the
soft lockup won't be triggered.
Here is the test result based on 6.10:
[6.10 wo/ the patch]
1. ftrace latency profiling (record a trace if the latency > 20s).
echo 20000000 > /sys/kernel/debug/tracing/tracing\_thresh
echo drain\_vmap\_area\_work > /sys/kernel/debug/tracing/set\_graph\_function
echo function\_graph > /sys/kernel/debug/tracing/current\_tracer
echo 1 > /sys/kernel/debug/tracing/tracing\_on
2. Run `make -j $(nproc)` to compile the kernel source
3. Once the soft lockup is reproduced, check the ftrace log:
cat /sys/kernel/debug/tracing/trace
# tracer: function\_graph
#
# CPU DURATION FUNCTION CALLS
# | | | | | | |
76) $ 50412985 us | } /\* \_\_purge\_vmap\_area\_lazy \*/
76) $ 50412997 us | } /\* drain\_vmap\_area\_work \*/
76) $ 29165911 us | } /\* \_\_purge\_vmap\_area\_lazy \*/
76) $ 29165926 us | } /\* drain\_vmap\_area\_work \*/
91) $ 53629423 us | } /\* \_\_purge\_vmap\_area\_lazy \*/
91) $ 53629434 us | } /\* drain\_vmap\_area\_work \*/
91) $ 28121014 us | } /\* \_\_purge\_vmap\_area\_lazy \*/
91) $ 28121026 us | } /\* drain\_vmap\_area\_work \*/
[6.10 w/ the patch]
1. Repeat step 1-2 in "[6.10 wo/ the patch]"
2. The soft lockup is not triggered and ftrace log is empty.
cat /sys/kernel/debug/tracing/trace
# tracer: function\_graph
#
# CPU DURATION FUNCTION CALLS
# | | | | | | |
3. Setting 'tracing\_thresh' to 10/5 seconds does not get any ftrace
log.
4. Setting 'tracing\_thresh' to 1 second gets ftrace log.
cat /sys/kernel/debug/tracing/trace
# tracer: function\_graph
#
# CPU DURATION FUNCTION CALLS
# | | | | | | |
23) $ 1074942 us | } /\* \_\_purge\_vmap\_area\_lazy \*/
23) $ 1074950 us | } /\* drain\_vmap\_area\_work \*/
The worst execution time of drain\_vmap\_area\_work() is about 1 second.
Link: [https://lore.kernel.org/lkml/ZqFlawuVnOMY2k3E@pc638.lan/](https://lore.kernel.org/lkml/ZqFlawuVnOMY2k3E%40pc638.lan/)
Link: [https://lkml.kernel.org/r/20240726165246.31326-1-ahuang12@lenovo.com](https://lkml.kernel.org/r/20240726165246.31326-1-ahuang12%40lenovo.com)
Fixes: 282631cb2447 ("mm: vmalloc: remove global purge\_vmap\_area\_root rb-tree")
Signed-off-by: Adrian Huang <ahuang12@lenovo.com>
Co-developed-by: Uladzislau Rezki (Sony) <urezki@gmail.com>
Signed-off-by: Uladzislau Rezki (Sony) <urezki@gmail.com>
Tested-by: Jiwei Sun <sunjw10@lenovo.com>
Reviewed-by: Baoquan He <bhe@redhat.com>
Cc: Alexander Potapenko <glider@google.com>
Cc: Andrey Konovalov <andreyknvl@gmail.com>
Cc: Andrey Ryabinin <ryabinin.a.a@gmail.com>
Cc: Christoph Hellwig <hch@infradead.org>
Cc: Dmitry Vyukov <dvyukov@google.com>
Cc: Vincenzo Frascino <vincenzo.frascino@arm.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f)

| -rw-r--r-- | [include/linux/kasan.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/kasan.h?id=f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f) | 12 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [mm/kasan/shadow.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/kasan/shadow.c?id=f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f) | 14 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [mm/vmalloc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/vmalloc.c?id=f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f) | 34 | |  |  |  | | --- | --- | --- | |

3 files changed, 45 insertions, 15 deletions

| diff --git a/include/linux/kasan.h b/include/linux/kasan.hindex 00a3bf7c0d8f0e..6bbfc8aa42e8f4 100644--- a/[include/linux/kasan.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/kasan.h?id=1ba771763d1b75443b534ec943785ff0454c1584)+++ b/[include/linux/kasan.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/kasan.h?id=f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f)@@ -29,6 +29,9 @@ typedef unsigned int \_\_bitwise kasan\_vmalloc\_flags\_t; #define KASAN\_VMALLOC\_VM\_ALLOC ((\_\_force kasan\_vmalloc\_flags\_t)0x02u) #define KASAN\_VMALLOC\_PROT\_NORMAL ((\_\_force kasan\_vmalloc\_flags\_t)0x04u) +#define KASAN\_VMALLOC\_PAGE\_RANGE 0x1 /\* Apply exsiting page range \*/+#define KASAN\_VMALLOC\_TLB\_FLUSH 0x2 /\* TLB flush \*/+ #if defined(CONFIG\_KASAN\_GENERIC) || defined(CONFIG\_KASAN\_SW\_TAGS)  #include <linux/pgtable.h>@@ -564,7 +567,8 @@ void kasan\_populate\_early\_vm\_area\_shadow(void \*start, unsigned long size); int kasan\_populate\_vmalloc(unsigned long addr, unsigned long size); void kasan\_release\_vmalloc(unsigned long start, unsigned long end, unsigned long free\_region\_start,- unsigned long free\_region\_end);+ unsigned long free\_region\_end,+ unsigned long flags);  #else /\* CONFIG\_KASAN\_GENERIC || CONFIG\_KASAN\_SW\_TAGS \*/ @@ -579,7 +583,8 @@ static inline int kasan\_populate\_vmalloc(unsigned long start, static inline void kasan\_release\_vmalloc(unsigned long start, unsigned long end, unsigned long free\_region\_start,- unsigned long free\_region\_end) { }+ unsigned long free\_region\_end,+ unsigned long flags) { }  #endif /\* CONFIG\_KASAN\_GENERIC || CONFIG\_KASAN\_SW\_TAGS \*/ @@ -614,7 +619,8 @@ static inline int kasan\_populate\_vmalloc(unsigned long start, static inline void kasan\_release\_vmalloc(unsigned long start, unsigned long end, unsigned long free\_region\_start,- unsigned long free\_region\_end) { }+ unsigned long free\_region\_end,+ unsigned long flags) { }  static inline void \*kasan\_unpoison\_vmalloc(const void \*start, unsigned long size,diff --git a/mm/kasan/shadow.c b/mm/kasan/shadow.cindex d6210ca48ddab9..88d1c9dcb50721 100644--- a/[mm/kasan/shadow.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/kasan/shadow.c?id=1ba771763d1b75443b534ec943785ff0454c1584)+++ b/[mm/kasan/shadow.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/kasan/shadow.c?id=f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f)@@ -489,7 +489,8 @@ static int kasan\_depopulate\_vmalloc\_pte(pte\_t \*ptep, unsigned long addr, \*/ void kasan\_release\_vmalloc(unsigned long start, unsigned long end, unsigned long free\_region\_start,- unsigned long free\_region\_end)+ unsigned long free\_region\_end,+ unsigned long flags) { void \*shadow\_start, \*shadow\_end; unsigned long region\_start, region\_end;@@ -522,12 +523,17 @@ void kasan\_release\_vmalloc(unsigned long start, unsigned long end, \_\_memset(shadow\_start, KASAN\_SHADOW\_INIT, shadow\_end - shadow\_start); return; }- apply\_to\_existing\_page\_range(&init\_mm,+++ if (flags & KASAN\_VMALLOC\_PAGE\_RANGE)+ apply\_to\_existing\_page\_range(&init\_mm, (unsigned long)shadow\_start, size, kasan\_depopulate\_vmalloc\_pte, NULL);- flush\_tlb\_kernel\_range((unsigned long)shadow\_start,- (unsigned long)shadow\_end);++ if (flags & KASAN\_VMALLOC\_TLB\_FLUSH)+ flush\_tlb\_kernel\_range((unsigned long)shadow\_start,+ (unsigned long)shadow\_end); } } diff --git a/mm/vmalloc.c b/mm/vmalloc.cindex 634162271c0045..5480b77f4167d7 100644--- a/[mm/vmalloc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/vmalloc.c?id=1ba771763d1b75443b534ec943785ff0454c1584)+++ b/[mm/vmalloc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/vmalloc.c?id=f9a18889aad9b4c19c6c4550c67ad4f9ed2a354f)@@ -2182,6 +2182,25 @@ decay\_va\_pool\_node(struct vmap\_node \*vn, bool full\_decay) reclaim\_list\_global(&decay\_list); } +static void+kasan\_release\_vmalloc\_node(struct vmap\_node \*vn)+{+ struct vmap\_area \*va;+ unsigned long start, end;++ start = list\_first\_entry(&vn->purge\_list, struct vmap\_area, list)->va\_start;+ end = list\_last\_entry(&vn->purge\_list, struct vmap\_area, list)->va\_end;++ list\_for\_each\_entry(va, &vn->purge\_list, list) {+ if (is\_vmalloc\_or\_module\_addr((void \*) va->va\_start))+ kasan\_release\_vmalloc(va->va\_start, va->va\_end,+ va->va\_start, va->va\_end,+ KASAN\_VMALLOC\_PAGE\_RANGE);+ }++ kasan\_release\_vmalloc(start, end, start, end, KASAN\_VMALLOC\_TLB\_FLUSH);+}+ static void purge\_vmap\_node(struct work\_struct \*work) { struct vmap\_node \*vn = container\_of(work,@@ -2190,20 +2209,17 @@ static void purge\_vmap\_node(struct work\_struct \*work) struct vmap\_area \*va, \*n\_va; LIST\_HEAD(local\_list); + if (IS\_ENABLED(CONFIG\_KASAN\_VMALLOC))+ kasan\_release\_vmalloc\_node(vn);+ vn->nr\_purged = 0;  list\_for\_each\_entry\_safe(va, n\_va, &vn->purge\_list, list) { unsigned long nr = va\_size(va) >> PAGE\_SHIFT;- unsigned long orig\_start = va->va\_start;- unsigned long orig\_end = va->va\_end; unsigned int vn\_id = decode\_vn\_id(va->flags);  list\_del\_init(&va->list); - if (is\_vmalloc\_or\_module\_addr((void \*)orig\_start))- kasan\_release\_vmalloc(orig\_start, orig\_end,- va->va\_start, va->va\_end);- nr\_purged\_pages += nr; vn->nr\_purged++; @@ -4784,7 +4800,8 @@ recovery: &free\_vmap\_area\_list); if (va) kasan\_release\_vmalloc(orig\_start, orig\_end,- va->va\_start, va->va\_end);+ va->va\_start, va->va\_end,+ KASAN\_VMALLOC\_PAGE\_RANGE | KASAN\_VMALLOC\_TLB\_FLUSH); vas[area] = NULL; } @@ -4834,7 +4851,8 @@ err\_free\_shadow: &free\_vmap\_area\_list); if (va) kasan\_release\_vmalloc(orig\_start, orig\_end,- va->va\_start, va->va\_end);+ va->va\_start, va->va\_end,+ KASAN\_VMALLOC\_PAGE\_RANGE | KASAN\_VMALLOC\_TLB\_FLUSH); vas[area] = NULL; kfree(vms[area]); } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 22:32:01 +0000


