The provided content relates to CVE-2024-56544.

**Root cause of vulnerability:**
The `udmabuf` driver was using `kmalloc_array` to allocate memory for the `folios` array. `kmalloc` has a size limitation, and if the requested allocation is too large (specifically, larger than 4MB with `PAGE_SIZE` of 4096 and `MAX_PAGE_ORDER` of 10 on a 64-bit machine), the allocation would fail, leading to a NULL pointer return, or a warning and NULL return. This would occur when creating a large udmabuf object, leading to a failure during udmabuf creation. Specifically, the max allocation size for `kmalloc` is limited by `MAX_PAGE_ORDER`.

**Weaknesses/vulnerabilities present:**
- **Memory Allocation Failure:** The use of `kmalloc_array` for large allocations in `udmabuf` can lead to allocation failures when trying to create a very large udmabuf.
- **Limited allocation size with `kmalloc`:** The max allocation size for `kmalloc` is limited by `MAX_PAGE_ORDER`.
- **Potential fragmentation issues:** Costly order (order 3) may not be guaranteed due to memory fragmentation.

**Impact of exploitation:**
- Failure to create `udmabuf`: The system may not be able to create udmabuf objects, or may fail when trying to create large udmabuf objects.
- System instability: Although not directly stated, failure to allocate memory could lead to system instability.

**Attack vectors:**
-  By creating a udmabuf object with a size greater than what kmalloc is able to provide using the documented method of `udmabuf_create`.
- Specifically, an attacker could change the size limit for `udmabuf` (e.g., to 3GB) and then attempt to allocate the full 3GB, triggering the allocation failure.

**Required attacker capabilities/position:**
- The attacker needs to be able to interact with the `udmabuf` driver to create `udmabuf` objects.
- An attacker needs to be able to set the size of a `udmabuf` object to be large enough to cause `kmalloc` to fail when allocating the `folios` array.

**Additional Notes:**

The fix replaces `kmalloc_array` with `kvmalloc_array` which falls back to `vmalloc` which can guarantee allocation for any size without impacting `kmalloc` allocations. Also, the corresponding `kfree` is replaced by `kvfree`.