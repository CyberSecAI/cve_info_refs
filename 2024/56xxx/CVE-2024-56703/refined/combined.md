=== Content from git.kernel.org_76de5888_20250114_190403.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Omid Ehtemam-Haghighi <omid.ehtemamhaghighi@menlosecurity.com> | 2024-11-05 17:02:36 -0800 |
| --- | --- | --- |
| committer | Jakub Kicinski <kuba@kernel.org> | 2024-11-11 15:26:10 -0800 |
| commit | [d9ccb18f83ea2bb654289b6ecf014fd267cc988b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b)) | |
| tree | [210bae1e8cad7e1e5163762051ae3bee06f5c856](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b) | |
| parent | [c4e39b895a5c9508a6407d1d2490c0508d431bfc](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c4e39b895a5c9508a6407d1d2490c0508d431bfc) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b&id2=c4e39b895a5c9508a6407d1d2490c0508d431bfc)) | |
| download | [linux-d9ccb18f83ea2bb654289b6ecf014fd267cc988b.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d9ccb18f83ea2bb654289b6ecf014fd267cc988b.tar.gz) | |

ipv6: Fix soft lockups in fib6\_select\_path under high next hop churnSoft lockups have been observed on a cluster of Linux-based edge routers
located in a highly dynamic environment. Using the `bird` service, these
routers continuously update BGP-advertised routes due to frequently
changing nexthop destinations, while also managing significant IPv6
traffic. The lockups occur during the traversal of the multipath
circular linked-list in the `fib6\_select\_path` function, particularly
while iterating through the siblings in the list. The issue typically
arises when the nodes of the linked list are unexpectedly deleted
concurrently on a different core—indicated by their 'next' and
'previous' elements pointing back to the node itself and their reference
count dropping to zero. This results in an infinite loop, leading to a
soft lockup that triggers a system panic via the watchdog timer.
Apply RCU primitives in the problematic code sections to resolve the
issue. Where necessary, update the references to fib6\_siblings to
annotate or use the RCU APIs.
Include a test script that reproduces the issue. The script
periodically updates the routing table while generating a heavy load
of outgoing IPv6 traffic through multiple iperf3 clients. It
consistently induces infinite soft lockups within a couple of minutes.
Kernel log:
0 [ffffbd13003e8d30] machine\_kexec at ffffffff8ceaf3eb
1 [ffffbd13003e8d90] \_\_crash\_kexec at ffffffff8d0120e3
2 [ffffbd13003e8e58] panic at ffffffff8cef65d4
3 [ffffbd13003e8ed8] watchdog\_timer\_fn at ffffffff8d05cb03
4 [ffffbd13003e8f08] \_\_hrtimer\_run\_queues at ffffffff8cfec62f
5 [ffffbd13003e8f70] hrtimer\_interrupt at ffffffff8cfed756
6 [ffffbd13003e8fd0] \_\_sysvec\_apic\_timer\_interrupt at ffffffff8cea01af
7 [ffffbd13003e8ff0] sysvec\_apic\_timer\_interrupt at ffffffff8df1b83d
-- <IRQ stack> --
8 [ffffbd13003d3708] asm\_sysvec\_apic\_timer\_interrupt at ffffffff8e000ecb
[exception RIP: fib6\_select\_path+299]
RIP: ffffffff8ddafe7b RSP: ffffbd13003d37b8 RFLAGS: 00000287
RAX: ffff975850b43600 RBX: ffff975850b40200 RCX: 0000000000000000
RDX: 000000003fffffff RSI: 0000000051d383e4 RDI: ffff975850b43618
RBP: ffffbd13003d3800 R8: 0000000000000000 R9: ffff975850b40200
R10: 0000000000000000 R11: 0000000000000000 R12: ffffbd13003d3830
R13: ffff975850b436a8 R14: ffff975850b43600 R15: 0000000000000007
ORIG\_RAX: ffffffffffffffff CS: 0010 SS: 0018
9 [ffffbd13003d3808] ip6\_pol\_route at ffffffff8ddb030c
10 [ffffbd13003d3888] ip6\_pol\_route\_input at ffffffff8ddb068c
11 [ffffbd13003d3898] fib6\_rule\_lookup at ffffffff8ddf02b5
12 [ffffbd13003d3928] ip6\_route\_input at ffffffff8ddb0f47
13 [ffffbd13003d3a18] ip6\_rcv\_finish\_core.constprop.0 at ffffffff8dd950d0
14 [ffffbd13003d3a30] ip6\_list\_rcv\_finish.constprop.0 at ffffffff8dd96274
15 [ffffbd13003d3a98] ip6\_sublist\_rcv at ffffffff8dd96474
16 [ffffbd13003d3af8] ipv6\_list\_rcv at ffffffff8dd96615
17 [ffffbd13003d3b60] \_\_netif\_receive\_skb\_list\_core at ffffffff8dc16fec
18 [ffffbd13003d3be0] netif\_receive\_skb\_list\_internal at ffffffff8dc176b3
19 [ffffbd13003d3c50] napi\_gro\_receive at ffffffff8dc565b9
20 [ffffbd13003d3c80] ice\_receive\_skb at ffffffffc087e4f5 [ice]
21 [ffffbd13003d3c90] ice\_clean\_rx\_irq at ffffffffc0881b80 [ice]
22 [ffffbd13003d3d20] ice\_napi\_poll at ffffffffc088232f [ice]
23 [ffffbd13003d3d80] \_\_napi\_poll at ffffffff8dc18000
24 [ffffbd13003d3db8] net\_rx\_action at ffffffff8dc18581
25 [ffffbd13003d3e40] \_\_do\_softirq at ffffffff8df352e9
26 [ffffbd13003d3eb0] run\_ksoftirqd at ffffffff8ceffe47
27 [ffffbd13003d3ec0] smpboot\_thread\_fn at ffffffff8cf36a30
28 [ffffbd13003d3ee8] kthread at ffffffff8cf2b39f
29 [ffffbd13003d3f28] ret\_from\_fork at ffffffff8ce5fa64
30 [ffffbd13003d3f50] ret\_from\_fork\_asm at ffffffff8ce03cbb
Fixes: 66f5d6ce53e6 ("ipv6: replace rwlock with rcu and spinlock in fib6\_table")
Reported-by: Adrian Oliver <kernel@aoliver.ca>
Signed-off-by: Omid Ehtemam-Haghighi <omid.ehtemamhaghighi@menlosecurity.com>
Cc: Shuah Khan <shuah@kernel.org>
Cc: Ido Schimmel <idosch@idosch.org>
Cc: Kuniyuki Iwashima <kuniyu@amazon.com>
Cc: Simon Horman <horms@kernel.org>
Reviewed-by: David Ahern <dsahern@kernel.org>
Link: [https://patch.msgid.link/20241106010236.1239299-1-omid.ehtemamhaghighi@menlosecurity.com](https://patch.msgid.link/20241106010236.1239299-1-omid.ehtemamhaghighi%40menlosecurity.com)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b)

| -rw-r--r-- | [net/ipv6/ip6\_fib.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/ip6_fib.c?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b) | 8 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/ipv6/route.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/route.c?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b) | 45 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/net/Makefile](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/net/Makefile?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b) | 1 | |  |  |  | | --- | --- | --- | |
| -rwxr-xr-x | [tools/testing/selftests/net/ipv6\_route\_update\_soft\_lockup.sh](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/net/ipv6_route_update_soft_lockup.sh?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b) | 262 | |  |  |  | | --- | --- | --- | |

4 files changed, 297 insertions, 19 deletions

| diff --git a/net/ipv6/ip6\_fib.c b/net/ipv6/ip6\_fib.cindex 6383263bfd0465..c134ba202c4cd1 100644--- a/[net/ipv6/ip6\_fib.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/ip6_fib.c?id=c4e39b895a5c9508a6407d1d2490c0508d431bfc)+++ b/[net/ipv6/ip6\_fib.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/ip6_fib.c?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b)@@ -1183,8 +1183,8 @@ next\_iter: while (sibling) { if (sibling->fib6\_metric == rt->fib6\_metric && rt6\_qualify\_for\_ecmp(sibling)) {- list\_add\_tail(&rt->fib6\_siblings,- &sibling->fib6\_siblings);+ list\_add\_tail\_rcu(&rt->fib6\_siblings,+ &sibling->fib6\_siblings); break; } sibling = rcu\_dereference\_protected(sibling->fib6\_next,@@ -1245,7 +1245,7 @@ add: fib6\_siblings) sibling->fib6\_nsiblings--; rt->fib6\_nsiblings = 0;- list\_del\_init(&rt->fib6\_siblings);+ list\_del\_rcu(&rt->fib6\_siblings); rt6\_multipath\_rebalance(next\_sibling); return err; }@@ -1963,7 +1963,7 @@ static void fib6\_del\_route(struct fib6\_table \*table, struct fib6\_node \*fn, &rt->fib6\_siblings, fib6\_siblings) sibling->fib6\_nsiblings--; rt->fib6\_nsiblings = 0;- list\_del\_init(&rt->fib6\_siblings);+ list\_del\_rcu(&rt->fib6\_siblings); rt6\_multipath\_rebalance(next\_sibling); } diff --git a/net/ipv6/route.c b/net/ipv6/route.cindex 038c1eeef0be1e..63d7681c929fca 100644--- a/[net/ipv6/route.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/route.c?id=c4e39b895a5c9508a6407d1d2490c0508d431bfc)+++ b/[net/ipv6/route.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/route.c?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b)@@ -416,8 +416,8 @@ void fib6\_select\_path(const struct net \*net, struct fib6\_result \*res, struct flowi6 \*fl6, int oif, bool have\_oif\_match, const struct sk\_buff \*skb, int strict) {- struct fib6\_info \*sibling, \*next\_sibling; struct fib6\_info \*match = res->f6i;+ struct fib6\_info \*sibling;  if (!match->nh && (!match->fib6\_nsiblings || have\_oif\_match)) goto out;@@ -443,8 +443,8 @@ void fib6\_select\_path(const struct net \*net, struct fib6\_result \*res, if (fl6->mp\_hash <= atomic\_read(&match->fib6\_nh->fib\_nh\_upper\_bound)) goto out; - list\_for\_each\_entry\_safe(sibling, next\_sibling, &match->fib6\_siblings,- fib6\_siblings) {+ list\_for\_each\_entry\_rcu(sibling, &match->fib6\_siblings,+ fib6\_siblings) { const struct fib6\_nh \*nh = sibling->fib6\_nh; int nh\_upper\_bound; @@ -5195,14 +5195,18 @@ static void ip6\_route\_mpath\_notify(struct fib6\_info \*rt, \* nexthop. Since sibling routes are always added at the end of \* the list, find the first sibling of the last route appended \*/+ rcu\_read\_lock();+ if ((nlflags & NLM\_F\_APPEND) && rt\_last && rt\_last->fib6\_nsiblings) {- rt = list\_first\_entry(&rt\_last->fib6\_siblings,- struct fib6\_info,- fib6\_siblings);+ rt = list\_first\_or\_null\_rcu(&rt\_last->fib6\_siblings,+ struct fib6\_info,+ fib6\_siblings); }  if (rt) inet6\_rt\_notify(RTM\_NEWROUTE, rt, info, nlflags);++ rcu\_read\_unlock(); }  static bool ip6\_route\_mpath\_should\_notify(const struct fib6\_info \*rt)@@ -5547,17 +5551,21 @@ static size\_t rt6\_nlmsg\_size(struct fib6\_info \*f6i) nexthop\_for\_each\_fib6\_nh(f6i->nh, rt6\_nh\_nlmsg\_size, &nexthop\_len); } else {- struct fib6\_info \*sibling, \*next\_sibling; struct fib6\_nh \*nh = f6i->fib6\_nh;+ struct fib6\_info \*sibling;  nexthop\_len = 0; if (f6i->fib6\_nsiblings) { rt6\_nh\_nlmsg\_size(nh, &nexthop\_len); - list\_for\_each\_entry\_safe(sibling, next\_sibling,- &f6i->fib6\_siblings, fib6\_siblings) {+ rcu\_read\_lock();++ list\_for\_each\_entry\_rcu(sibling, &f6i->fib6\_siblings,+ fib6\_siblings) { rt6\_nh\_nlmsg\_size(sibling->fib6\_nh, &nexthop\_len); }++ rcu\_read\_unlock(); } nexthop\_len += lwtunnel\_get\_encap\_size(nh->fib\_nh\_lws); }@@ -5721,7 +5729,7 @@ static int rt6\_fill\_node(struct net \*net, struct sk\_buff \*skb, lwtunnel\_fill\_encap(skb, dst->lwtstate, RTA\_ENCAP, RTA\_ENCAP\_TYPE) < 0) goto nla\_put\_failure; } else if (rt->fib6\_nsiblings) {- struct fib6\_info \*sibling, \*next\_sibling;+ struct fib6\_info \*sibling; struct nlattr \*mp;  mp = nla\_nest\_start\_noflag(skb, RTA\_MULTIPATH);@@ -5733,14 +5741,21 @@ static int rt6\_fill\_node(struct net \*net, struct sk\_buff \*skb, 0) < 0) goto nla\_put\_failure; - list\_for\_each\_entry\_safe(sibling, next\_sibling,- &rt->fib6\_siblings, fib6\_siblings) {+ rcu\_read\_lock();++ list\_for\_each\_entry\_rcu(sibling, &rt->fib6\_siblings,+ fib6\_siblings) { if (fib\_add\_nexthop(skb, &sibling->fib6\_nh->nh\_common, sibling->fib6\_nh->fib\_nh\_weight,- AF\_INET6, 0) < 0)+ AF\_INET6, 0) < 0) {+ rcu\_read\_unlock();+ goto nla\_put\_failure;+ } } + rcu\_read\_unlock();+ nla\_nest\_end(skb, mp); } else if (rt->nh) { if (nla\_put\_u32(skb, RTA\_NH\_ID, rt->nh->id))@@ -6177,7 +6192,7 @@ void inet6\_rt\_notify(int event, struct fib6\_info \*rt, struct nl\_info \*info, err = -ENOBUFS; seq = info->nlh ? info->nlh->nlmsg\_seq : 0; - skb = nlmsg\_new(rt6\_nlmsg\_size(rt), gfp\_any());+ skb = nlmsg\_new(rt6\_nlmsg\_size(rt), GFP\_ATOMIC); if (!skb) goto errout; @@ -6190,7 +6205,7 @@ void inet6\_rt\_notify(int event, struct fib6\_info \*rt, struct nl\_info \*info, goto errout; } rtnl\_notify(skb, net, info->portid, RTNLGRP\_IPV6\_ROUTE,- info->nlh, gfp\_any());+ info->nlh, GFP\_ATOMIC); return; errout: rtnl\_set\_sk\_err(net, RTNLGRP\_IPV6\_ROUTE, err);diff --git a/tools/testing/selftests/net/Makefile b/tools/testing/selftests/net/Makefileindex 26a4883a65c977..8c4db5199a4298 100644--- a/[tools/testing/selftests/net/Makefile](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/net/Makefile?id=c4e39b895a5c9508a6407d1d2490c0508d431bfc)+++ b/[tools/testing/selftests/net/Makefile](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/net/Makefile?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b)@@ -96,6 +96,7 @@ TEST\_PROGS += fdb\_flush.sh TEST\_PROGS += fq\_band\_pktlimit.sh TEST\_PROGS += vlan\_hw\_filter.sh TEST\_PROGS += bpf\_offload.py+TEST\_PROGS += ipv6\_route\_update\_soft\_lockup.sh  # YNL files, must be before "include ..lib.mk" YNL\_GEN\_FILES := ncdevmemdiff --git a/tools/testing/selftests/net/ipv6\_route\_update\_soft\_lockup.sh b/tools/testing/selftests/net/ipv6\_route\_update\_soft\_lockup.shnew file mode 100755index 00000000000000..a6b2b1f9c641c9--- /dev/null+++ b/[tools/testing/selftests/net/ipv6\_route\_update\_soft\_lockup.sh](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/net/ipv6_route_update_soft_lockup.sh?id=d9ccb18f83ea2bb654289b6ecf014fd267cc988b)@@ -0,0 +1,262 @@+#!/bin/bash+# SPDX-License-Identifier: GPL-2.0+#+# Testing for potential kernel soft lockup during IPv6 routing table+# refresh under heavy outgoing IPv6 traffic. If a kernel soft lockup+# occurs, a kernel panic will be triggered to prevent associated issues.+#+#+# Test Environment Layout+#+# ┌----------------┐ ┌----------------┐+# | SOURCE\_NS | | SINK\_NS |+# | NAMESPACE | | NAMESPACE |+# |(iperf3 clients)| |(iperf3 servers)|+# | | | |+# | | | |+# | ┌-----------| nexthops |---------┐ |+# | |veth\_source|<--------------------------------------->|veth\_sink|<┐ |+# | └-----------|2001:0DB8:1::0:1/96 2001:0DB8:1::1:1/96 |---------┘ | |+# | | ^ 2001:0DB8:1::1:2/96 | | |+# | | . . | fwd | |+# | ┌---------┐ | . . | | |+# | | IPv6 | | . . | V |+# | | routing | | . 2001:0DB8:1::1:80/96| ┌-----┐ |+# | | table | | . | | lo | |+# | | nexthop | | . └--------┴-----┴-┘+# | | update | | ............................> 2001:0DB8:2::1:1/128+# | └-------- ┘ |+# └----------------┘+#+# The test script sets up two network namespaces, source\_ns and sink\_ns,+# connected via a veth link. Within source\_ns, it continuously updates the+# IPv6 routing table by flushing and inserting IPV6\_NEXTHOP\_ADDR\_COUNT nexthop+# IPs destined for SINK\_LOOPBACK\_IP\_ADDR in sink\_ns. This refresh occurs at a+# rate of 1/ROUTING\_TABLE\_REFRESH\_PERIOD per second for TEST\_DURATION seconds.+#+# Simultaneously, multiple iperf3 clients within source\_ns generate heavy+# outgoing IPv6 traffic. Each client is assigned a unique port number starting+# at 5000 and incrementing sequentially. Each client targets a unique iperf3+# server running in sink\_ns, connected to the SINK\_LOOPBACK\_IFACE interface+# using the same port number.+#+# The number of iperf3 servers and clients is set to half of the total+# available cores on each machine.+#+# NOTE: We have tested this script on machines with various CPU specifications,+# ranging from lower to higher performance as listed below. The test script+# effectively triggered a kernel soft lockup on machines running an unpatched+# kernel in under a minute:+#+# - 1x Intel Xeon E-2278G 8-Core Processor @ 3.40GHz+# - 1x Intel Xeon E-2378G Processor 8-Core @ 2.80GHz+# - 1x AMD EPYC 7401P 24-Core Processor @ 2.00GHz+# - 1x AMD EPYC 7402P 24-Core Processor @ 2.80GHz+# - 2x Intel Xeon Gold 5120 14-Core Processor @ 2.20GHz+# - 1x Ampere Altra Q80-30 80-Core Processor @ 3.00GHz+# - 2x Intel Xeon Gold 5120 14-Core Processor @ 2.20GHz+# - 2x Intel Xeon Silver 4214 24-Core Processor @ 2.20GHz+# - 1x AMD EPYC 7502P 32-Core @ 2.50GHz+# - 1x Intel Xeon Gold 6314U 32-Core Processor @ 2.30GHz+# - 2x Intel Xeon Gold 6338 32-Core Processor @ 2.00GHz+#+# On less performant machines, you may need to increase the TEST\_DURATION+# parameter to enhance the likelihood of encountering a race condition leading+# to a kernel soft lockup and avoid a false negative result.+#+# NOTE: The test may not produce the expected result in virtualized+# environments (e.g., qemu) due to differences in timing and CPU handling,+# which can affect the conditions needed to trigger a soft lockup.++source lib.sh+source net\_helper.sh++TEST\_DURATION=300+ROUTING\_TABLE\_REFRESH\_PERIOD=0.01++IPERF3\_BITRATE="300m"+++IPV6\_NEXTHOP\_ADDR\_COUNT="128"+IPV6\_NEXTHOP\_ADDR\_MASK="96"+IPV6\_NEXTHOP\_PREFIX="2001:0DB8:1"+++SOURCE\_TEST\_IFACE="veth\_source"+SOURCE\_TEST\_IP\_ADDR="2001:0DB8:1::0:1/96"++SINK\_TEST\_IFACE="veth\_sink"+# ${SINK\_TEST\_IFACE} is populated with the following range of IPv6 addresses:+# 2001:0DB8:1::1:1 to 2001:0DB8:1::1:${IPV6\_NEXTHOP\_ADDR\_COUNT}+SINK\_LOOPBACK\_IFACE="lo"+SINK\_LOOPBACK\_IP\_MASK="128"+SINK\_LOOPBACK\_IP\_ADDR="2001:0DB8:2::1:1"++nexthop\_ip\_list=""+termination\_signal=""+kernel\_softlokup\_panic\_prev\_val=""++terminate\_ns\_processes\_by\_pattern() {+ local ns=$1+ local pattern=$2++ for pid in $(ip netns pids ${ns}); do+ [ -e /proc/$pid/cmdline ] && grep -qe "${pattern}" /proc/$pid/cmdline && kill -9 $pid+ done+}++cleanup() {+ echo "info: cleaning up namespaces and terminating all processes within them..."+++ # Terminate iperf3 instances running in the source\_ns. To avoid race+ # conditions, first iterate over the PIDs and terminate those+ # associated with the bash shells running the+ # `while true; do iperf3 -c ...; done` loops. In a second iteration,+ # terminate the individual `iperf3 -c ...` instances.+ terminate\_ns\_processes\_by\_pattern ${source\_ns} while+ terminate\_ns\_processes\_by\_pattern ${source\_ns} iperf3++ # Repeat the same process for sink\_ns+ terminate\_ns\_processes\_by\_pattern ${sink\_ns} while+ terminate\_ns\_processes\_by\_pattern ${sink\_ns} iperf3++ # Check if any iperf3 instances are still running. This could happen+ # if a core has entered an infinite loop and the timeout for detecting+ # the soft lockup has not expired, but either the test interval has+ # already elapsed or the test was terminated manually (e.g., with ^C)+ for pid in $(ip netns pids ${source\_ns}); do+ if [ -e /proc/$pid/cmdline ] && grep -qe 'iperf3' /proc/$pid/cmdline; then+ echo "FAIL: unable to terminate some iperf3 instances. Soft lockup is underway. A kernel panic is on the way!"+ exit ${ksft\_fail}+ fi+ done++ if [ "$termination\_signal" == "SIGINT" ]; then+ echo "SKIP: Termination due to ^C (SIGINT)"+ elif [ "$termination\_signal" == "SIGALRM" ]; then+ echo "PASS: No kernel soft lockup occurred during this ${TEST\_DURATION} second test"+ fi++ cleanup\_ns ${source\_ns} ${sink\_ns}++ sysctl -qw kernel.softlockup\_panic=${kernel\_softlokup\_panic\_prev\_val}+}++setup\_prepare() {+ setup\_ns source\_ns sink\_ns++ ip -n ${source\_ns} link add name ${SOURCE\_TEST\_IFACE} type veth peer name ${SINK\_TEST\_IFACE} netns ${sink\_ns}++ # Setting up the Source namespace+ ip -n ${source\_ns} addr add ${SOURCE\_TEST\_IP\_ADDR} dev ${SOURCE\_TEST\_IFACE}+ ip -n ${source\_ns} link set dev ${SOURCE\_TEST\_IFACE} qlen 10000+ ip -n ${source\_ns} link set dev ${SOURCE\_TEST\_IFACE} up+ ip netns exec ${source\_ns} sysctl -qw net.ipv6.fib\_multipath\_hash\_policy=1++ # Setting up the Sink namespace+ ip -n ${sink\_ns} addr add ${SINK\_LOOPBACK\_IP\_ADDR}/${SINK\_LOOPBACK\_IP\_MASK} dev ${SINK\_LOOPBACK\_IFACE}+ ip -n ${sink\_ns} link set dev ${SINK\_LOOPBACK\_IFACE} up+ ip netns exec ${sink\_ns} sysctl -qw net.ipv6.conf.${SINK\_LOOPBACK\_IFACE}.forwarding=1++ ip -n ${sink\_ns} link set ${SINK\_TEST\_IFACE} up+ ip netns exec ${sink\_ns} sysctl -qw net.ipv6.conf.${SINK\_TEST\_IFACE}.forwarding=1+++ # Populate nexthop IPv6 addresses on the test interface in the sink\_ns+ echo "info: populating ${IPV6\_NEXTHOP\_ADDR\_COUNT} IPv6 addresses on the ${SINK\_TEST\_IFACE} interface ..."+ for IP in $(seq 1 ${IPV6\_NEXTHOP\_ADDR\_COUNT}); do+ ip -n ${sink\_ns} addr add ${IPV6\_NEXTHOP\_PREFIX}::$(printf "1:%x" "${IP}")/${IPV6\_NEXTHOP\_ADDR\_MASK} dev ${SINK\_TEST\_IFACE};+ done++ # Preparing list of nexthops+ for IP in $(seq 1 ${IPV6\_NEXTHOP\_ADDR\_COUNT}); do+ nexthop\_ip\_list=$nexthop\_ip\_list" nexthop via ${IPV6\_NEXTHOP\_PREFIX}::$(printf "1:%x" $IP) dev ${SOURCE\_TEST\_IFACE} weight 1"+ done+}+++test\_soft\_lockup\_during\_routing\_table\_refresh() {+ # Start num\_of\_iperf\_servers iperf3 servers in the sink\_ns namespace,+ # each listening on ports starting at 5001 and incrementing+ # sequentially. Since iperf3 instances may terminate unexpectedly, a+ # while loop is used to automatically restart them in such cases.+ echo "info: starting ${num\_of\_iperf\_servers} iperf3 servers in the sink\_ns namespace ..."+ for i in $(seq 1 ${num\_of\_iperf\_servers}); do+ cmd="iperf3 --bind ${SINK\_LOOPBACK\_IP\_ADDR} -s -p $(printf '5%03d' ${i}) --rcv-timeout 200 &>/dev/null"+ ip netns exec ${sink\_ns} bash -c "while true; do ${cmd}; done &" &>/dev/null+ done++ # Wait for the iperf3 servers to be ready+ for i in $(seq ${num\_of\_iperf\_servers}); do+ port=$(printf '5%03d' ${i});+ wait\_local\_port\_listen ${sink\_ns} ${port} tcp+ done++ # Continuously refresh the routing table in the background within+ # the source\_ns namespace+ ip netns exec ${source\_ns} bash -c "+ while \$(ip netns list | grep -q ${source\_ns}); do+ ip -6 route add ${SINK\_LOOPBACK\_IP\_ADDR}/${SINK\_LOOPBACK\_IP\_MASK} ${nexthop\_ip\_list};+ sleep ${ROUTING\_TABLE\_REFRESH\_PERIOD};+ ip -6 route delete ${SINK\_LOOPBACK\_IP\_ADDR}/${SINK\_LOOPBACK\_IP\_MASK};+ done &"++ # Start num\_of\_iperf\_servers iperf3 clients in the source\_ns namespace,+ # each sending TCP traffic on sequential ports starting at 5001.+ # Since iperf3 instances may terminate unexpectedly (e.g., if the route+ # to the server is deleted in the background during a route refresh), a+ # while loop is used to automatically restart them in such cases.+ echo "info: starting ${num\_of\_iperf\_servers} iperf3 clients in the source\_ns namespace ..."+ for i in $(seq 1 ${num\_of\_iperf\_servers}); do+ cmd="iperf3 -c ${SINK\_LOOPBACK\_IP\_ADDR} -p $(printf '5%03d' ${i}) --length 64 --bitrate ${IPERF3\_BITRATE} -t 0 --connect-timeout 150 &>/dev/null"+ ip netns exec ${source\_ns} bash -c "while true; do ${cmd}; done &" &>/dev/null+ done++ echo "info: IPv6 routing table is being updated at the rate of $(echo "1/${ROUTING\_TABLE\_REFRESH\_PERIOD}" | bc)/s for ${TEST\_DURATION} seconds ..."+ echo "info: A kernel soft lockup, if detected, results in a kernel panic!"++ wait+}++# Make sure 'iperf3' is installed, skip the test otherwise+if [ ! -x "$(command -v "iperf3")" ]; then+ echo "SKIP: 'iperf3' is not installed. Skipping the test."+ exit ${ksft\_skip}+fi++# Determine the number of cores on the machine+num\_of\_iperf\_servers=$(( $(nproc)/2 ))++# Check if we are running on a multi-core machine, skip the test otherwise+if [ "${num\_of\_iperf\_servers}" -eq 0 ]; then+ echo "SKIP: This test is not valid on a single core machine!"+ exit ${ksft\_skip}+fi++# Since the kernel soft lockup we're testing causes at least one core to enter+# an infinite loop, destabilizing the host and likely affecting subsequent+# tests, we trigger a kernel panic instead of reporting a failure and+# continuing+kernel\_softlokup\_panic\_prev\_val=$(sysctl -n kernel.softlockup\_panic)+sysctl -qw kernel.softlockup\_panic=1++handle\_sigint() {+ termination\_signal="SIGINT"+ cleanup+ exit ${ksft\_skip}+}++handle\_sigalrm() {+ termination\_signal="SIGALRM"+ cleanup+ exit ${ksft\_pass}+}++trap handle\_sigint SIGINT+trap handle\_sigalrm SIGALRM++(sleep ${TEST\_DURATION} && kill -s SIGALRM $$)&++setup\_prepare+test\_soft\_lockup\_during\_routing\_table\_refresh |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 19:02:40 +0000



=== Content from git.kernel.org_998ed985_20250114_190402.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=34a949e7a0869dfa31a40416d2a56973fae1807b)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=34a949e7a0869dfa31a40416d2a56973fae1807b)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=34a949e7a0869dfa31a40416d2a56973fae1807b)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=34a949e7a0869dfa31a40416d2a56973fae1807b)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Omid Ehtemam-Haghighi <omid.ehtemamhaghighi@menlosecurity.com> | 2024-11-05 17:02:36 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-05 14:01:57 +0100 |
| commit | [34a949e7a0869dfa31a40416d2a56973fae1807b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=34a949e7a0869dfa31a40416d2a56973fae1807b) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=34a949e7a0869dfa31a40416d2a56973fae1807b)) | |
| tree | [1948b9b62276ce188aa3d5aa53d5572e247e20f3](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=34a949e7a0869dfa31a40416d2a56973fae1807b) | |
| parent | [5d1c6381fade614aef221bb29e3beae8c94175eb](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5d1c6381fade614aef221bb29e3beae8c94175eb) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=34a949e7a0869dfa31a40416d2a56973fae1807b&id2=5d1c6381fade614aef221bb29e3beae8c94175eb)) | |
| download | [linux-34a949e7a0869dfa31a40416d2a56973fae1807b.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-34a949e7a0869dfa31a40416d2a56973fae1807b.tar.gz) | |

ipv6: Fix soft lockups in fib6\_select\_path under high next hop churn[ Upstream commit d9ccb18f83ea2bb654289b6ecf014fd267cc988b ]
Soft lockups have been observed on a cluster of Linux-based edge routers
located in a highly dynamic environment. Using the `bird` service, these
routers continuously update BGP-advertised routes due to frequently
changing nexthop destinations, while also managing significant IPv6
traffic. The lockups occur during the traversal of the multipath
circular linked-list in the `fib6\_select\_path` function, particularly
while iterating through the siblings in the list. The issue typically
arises when the nodes of the linked list are unexpectedly deleted
concurrently on a different core—indicated by their 'next' and
'previous' elements pointing back to the node itself and their reference
count dropping to zero. This results in an infinite loop, leading to a
soft lockup that triggers a system panic via the watchdog timer.
Apply RCU primitives in the problematic code sections to resolve the
issue. Where necessary, update the references to fib6\_siblings to
annotate or use the RCU APIs.
Include a test script that reproduces the issue. The script
periodically updates the routing table while generating a heavy load
of outgoing IPv6 traffic through multiple iperf3 clients. It
consistently induces infinite soft lockups within a couple of minutes.
Kernel log:
0 [ffffbd13003e8d30] machine\_kexec at ffffffff8ceaf3eb
1 [ffffbd13003e8d90] \_\_crash\_kexec at ffffffff8d0120e3
2 [ffffbd13003e8e58] panic at ffffffff8cef65d4
3 [ffffbd13003e8ed8] watchdog\_timer\_fn at ffffffff8d05cb03
4 [ffffbd13003e8f08] \_\_hrtimer\_run\_queues at ffffffff8cfec62f
5 [ffffbd13003e8f70] hrtimer\_interrupt at ffffffff8cfed756
6 [ffffbd13003e8fd0] \_\_sysvec\_apic\_timer\_interrupt at ffffffff8cea01af
7 [ffffbd13003e8ff0] sysvec\_apic\_timer\_interrupt at ffffffff8df1b83d
-- <IRQ stack> --
8 [ffffbd13003d3708] asm\_sysvec\_apic\_timer\_interrupt at ffffffff8e000ecb
[exception RIP: fib6\_select\_path+299]
RIP: ffffffff8ddafe7b RSP: ffffbd13003d37b8 RFLAGS: 00000287
RAX: ffff975850b43600 RBX: ffff975850b40200 RCX: 0000000000000000
RDX: 000000003fffffff RSI: 0000000051d383e4 RDI: ffff975850b43618
RBP: ffffbd13003d3800 R8: 0000000000000000 R9: ffff975850b40200
R10: 0000000000000000 R11: 0000000000000000 R12: ffffbd13003d3830
R13: ffff975850b436a8 R14: ffff975850b43600 R15: 0000000000000007
ORIG\_RAX: ffffffffffffffff CS: 0010 SS: 0018
9 [ffffbd13003d3808] ip6\_pol\_route at ffffffff8ddb030c
10 [ffffbd13003d3888] ip6\_pol\_route\_input at ffffffff8ddb068c
11 [ffffbd13003d3898] fib6\_rule\_lookup at ffffffff8ddf02b5
12 [ffffbd13003d3928] ip6\_route\_input at ffffffff8ddb0f47
13 [ffffbd13003d3a18] ip6\_rcv\_finish\_core.constprop.0 at ffffffff8dd950d0
14 [ffffbd13003d3a30] ip6\_list\_rcv\_finish.constprop.0 at ffffffff8dd96274
15 [ffffbd13003d3a98] ip6\_sublist\_rcv at ffffffff8dd96474
16 [ffffbd13003d3af8] ipv6\_list\_rcv at ffffffff8dd96615
17 [ffffbd13003d3b60] \_\_netif\_receive\_skb\_list\_core at ffffffff8dc16fec
18 [ffffbd13003d3be0] netif\_receive\_skb\_list\_internal at ffffffff8dc176b3
19 [ffffbd13003d3c50] napi\_gro\_receive at ffffffff8dc565b9
20 [ffffbd13003d3c80] ice\_receive\_skb at ffffffffc087e4f5 [ice]
21 [ffffbd13003d3c90] ice\_clean\_rx\_irq at ffffffffc0881b80 [ice]
22 [ffffbd13003d3d20] ice\_napi\_poll at ffffffffc088232f [ice]
23 [ffffbd13003d3d80] \_\_napi\_poll at ffffffff8dc18000
24 [ffffbd13003d3db8] net\_rx\_action at ffffffff8dc18581
25 [ffffbd13003d3e40] \_\_do\_softirq at ffffffff8df352e9
26 [ffffbd13003d3eb0] run\_ksoftirqd at ffffffff8ceffe47
27 [ffffbd13003d3ec0] smpboot\_thread\_fn at ffffffff8cf36a30
28 [ffffbd13003d3ee8] kthread at ffffffff8cf2b39f
29 [ffffbd13003d3f28] ret\_from\_fork at ffffffff8ce5fa64
30 [ffffbd13003d3f50] ret\_from\_fork\_asm at ffffffff8ce03cbb
Fixes: 66f5d6ce53e6 ("ipv6: replace rwlock with rcu and spinlock in fib6\_table")
Reported-by: Adrian Oliver <kernel@aoliver.ca>
Signed-off-by: Omid Ehtemam-Haghighi <omid.ehtemamhaghighi@menlosecurity.com>
Cc: Shuah Khan <shuah@kernel.org>
Cc: Ido Schimmel <idosch@idosch.org>
Cc: Kuniyuki Iwashima <kuniyu@amazon.com>
Cc: Simon Horman <horms@kernel.org>
Reviewed-by: David Ahern <dsahern@kernel.org>
Link: [https://patch.msgid.link/20241106010236.1239299-1-omid.ehtemamhaghighi@menlosecurity.com](https://patch.msgid.link/20241106010236.1239299-1-omid.ehtemamhaghighi%40menlosecurity.com)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=34a949e7a0869dfa31a40416d2a56973fae1807b)

| -rw-r--r-- | [net/ipv6/ip6\_fib.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/ip6_fib.c?id=34a949e7a0869dfa31a40416d2a56973fae1807b) | 8 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/ipv6/route.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/route.c?id=34a949e7a0869dfa31a40416d2a56973fae1807b) | 45 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/net/Makefile](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/net/Makefile?id=34a949e7a0869dfa31a40416d2a56973fae1807b) | 1 | |  |  |  | | --- | --- | --- | |
| -rwxr-xr-x | [tools/testing/selftests/net/ipv6\_route\_update\_soft\_lockup.sh](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/net/ipv6_route_update_soft_lockup.sh?id=34a949e7a0869dfa31a40416d2a56973fae1807b) | 262 | |  |  |  | | --- | --- | --- | |

4 files changed, 297 insertions, 19 deletions

| diff --git a/net/ipv6/ip6\_fib.c b/net/ipv6/ip6\_fib.cindex eb111d20615c62..9a1c59275a1099 100644--- a/[net/ipv6/ip6\_fib.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/ip6_fib.c?id=5d1c6381fade614aef221bb29e3beae8c94175eb)+++ b/[net/ipv6/ip6\_fib.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/ip6_fib.c?id=34a949e7a0869dfa31a40416d2a56973fae1807b)@@ -1190,8 +1190,8 @@ next\_iter: while (sibling) { if (sibling->fib6\_metric == rt->fib6\_metric && rt6\_qualify\_for\_ecmp(sibling)) {- list\_add\_tail(&rt->fib6\_siblings,- &sibling->fib6\_siblings);+ list\_add\_tail\_rcu(&rt->fib6\_siblings,+ &sibling->fib6\_siblings); break; } sibling = rcu\_dereference\_protected(sibling->fib6\_next,@@ -1252,7 +1252,7 @@ add: fib6\_siblings) sibling->fib6\_nsiblings--; rt->fib6\_nsiblings = 0;- list\_del\_init(&rt->fib6\_siblings);+ list\_del\_rcu(&rt->fib6\_siblings); rt6\_multipath\_rebalance(next\_sibling); return err; }@@ -1970,7 +1970,7 @@ static void fib6\_del\_route(struct fib6\_table \*table, struct fib6\_node \*fn, &rt->fib6\_siblings, fib6\_siblings) sibling->fib6\_nsiblings--; rt->fib6\_nsiblings = 0;- list\_del\_init(&rt->fib6\_siblings);+ list\_del\_rcu(&rt->fib6\_siblings); rt6\_multipath\_rebalance(next\_sibling); } diff --git a/net/ipv6/route.c b/net/ipv6/route.cindex 76bea6db59764a..cff4fbbc66efb2 100644--- a/[net/ipv6/route.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/route.c?id=5d1c6381fade614aef221bb29e3beae8c94175eb)+++ b/[net/ipv6/route.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/route.c?id=34a949e7a0869dfa31a40416d2a56973fae1807b)@@ -416,8 +416,8 @@ void fib6\_select\_path(const struct net \*net, struct fib6\_result \*res, struct flowi6 \*fl6, int oif, bool have\_oif\_match, const struct sk\_buff \*skb, int strict) {- struct fib6\_info \*sibling, \*next\_sibling; struct fib6\_info \*match = res->f6i;+ struct fib6\_info \*sibling;  if (!match->nh && (!match->fib6\_nsiblings || have\_oif\_match)) goto out;@@ -443,8 +443,8 @@ void fib6\_select\_path(const struct net \*net, struct fib6\_result \*res, if (fl6->mp\_hash <= atomic\_read(&match->fib6\_nh->fib\_nh\_upper\_bound)) goto out; - list\_for\_each\_entry\_safe(sibling, next\_sibling, &match->fib6\_siblings,- fib6\_siblings) {+ list\_for\_each\_entry\_rcu(sibling, &match->fib6\_siblings,+ fib6\_siblings) { const struct fib6\_nh \*nh = sibling->fib6\_nh; int nh\_upper\_bound; @@ -5195,14 +5195,18 @@ static void ip6\_route\_mpath\_notify(struct fib6\_info \*rt, \* nexthop. Since sibling routes are always added at the end of \* the list, find the first sibling of the last route appended \*/+ rcu\_read\_lock();+ if ((nlflags & NLM\_F\_APPEND) && rt\_last && rt\_last->fib6\_nsiblings) {- rt = list\_first\_entry(&rt\_last->fib6\_siblings,- struct fib6\_info,- fib6\_siblings);+ rt = list\_first\_or\_null\_rcu(&rt\_last->fib6\_siblings,+ struct fib6\_info,+ fib6\_siblings); }  if (rt) inet6\_rt\_notify(RTM\_NEWROUTE, rt, info, nlflags);++ rcu\_read\_unlock(); }  static bool ip6\_route\_mpath\_should\_notify(const struct fib6\_info \*rt)@@ -5547,17 +5551,21 @@ static size\_t rt6\_nlmsg\_size(struct fib6\_info \*f6i) nexthop\_for\_each\_fib6\_nh(f6i->nh, rt6\_nh\_nlmsg\_size, &nexthop\_len); } else {- struct fib6\_info \*sibling, \*next\_sibling; struct fib6\_nh \*nh = f6i->fib6\_nh;+ struct fib6\_info \*sibling;  nexthop\_len = 0; if (f6i->fib6\_nsiblings) { rt6\_nh\_nlmsg\_size(nh, &nexthop\_len); - list\_for\_each\_entry\_safe(sibling, next\_sibling,- &f6i->fib6\_siblings, fib6\_siblings) {+ rcu\_read\_lock();++ list\_for\_each\_entry\_rcu(sibling, &f6i->fib6\_siblings,+ fib6\_siblings) { rt6\_nh\_nlmsg\_size(sibling->fib6\_nh, &nexthop\_len); }++ rcu\_read\_unlock(); } nexthop\_len += lwtunnel\_get\_encap\_size(nh->fib\_nh\_lws); }@@ -5721,7 +5729,7 @@ static int rt6\_fill\_node(struct net \*net, struct sk\_buff \*skb, lwtunnel\_fill\_encap(skb, dst->lwtstate, RTA\_ENCAP, RTA\_ENCAP\_TYPE) < 0) goto nla\_put\_failure; } else if (rt->fib6\_nsiblings) {- struct fib6\_info \*sibling, \*next\_sibling;+ struct fib6\_info \*sibling; struct nlattr \*mp;  mp = nla\_nest\_start\_noflag(skb, RTA\_MULTIPATH);@@ -5733,14 +5741,21 @@ static int rt6\_fill\_node(struct net \*net, struct sk\_buff \*skb, 0) < 0) goto nla\_put\_failure; - list\_for\_each\_entry\_safe(sibling, next\_sibling,- &rt->fib6\_siblings, fib6\_siblings) {+ rcu\_read\_lock();++ list\_for\_each\_entry\_rcu(sibling, &rt->fib6\_siblings,+ fib6\_siblings) { if (fib\_add\_nexthop(skb, &sibling->fib6\_nh->nh\_common, sibling->fib6\_nh->fib\_nh\_weight,- AF\_INET6, 0) < 0)+ AF\_INET6, 0) < 0) {+ rcu\_read\_unlock();+ goto nla\_put\_failure;+ } } + rcu\_read\_unlock();+ nla\_nest\_end(skb, mp); } else if (rt->nh) { if (nla\_put\_u32(skb, RTA\_NH\_ID, rt->nh->id))@@ -6177,7 +6192,7 @@ void inet6\_rt\_notify(int event, struct fib6\_info \*rt, struct nl\_info \*info, err = -ENOBUFS; seq = info->nlh ? info->nlh->nlmsg\_seq : 0; - skb = nlmsg\_new(rt6\_nlmsg\_size(rt), gfp\_any());+ skb = nlmsg\_new(rt6\_nlmsg\_size(rt), GFP\_ATOMIC); if (!skb) goto errout; @@ -6190,7 +6205,7 @@ void inet6\_rt\_notify(int event, struct fib6\_info \*rt, struct nl\_info \*info, goto errout; } rtnl\_notify(skb, net, info->portid, RTNLGRP\_IPV6\_ROUTE,- info->nlh, gfp\_any());+ info->nlh, GFP\_ATOMIC); return; errout: rtnl\_set\_sk\_err(net, RTNLGRP\_IPV6\_ROUTE, err);diff --git a/tools/testing/selftests/net/Makefile b/tools/testing/selftests/net/Makefileindex 5e86f7a51b43c5..2c4b6e404a7c7f 100644--- a/[tools/testing/selftests/net/Makefile](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/net/Makefile?id=5d1c6381fade614aef221bb29e3beae8c94175eb)+++ b/[tools/testing/selftests/net/Makefile](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/net/Makefile?id=34a949e7a0869dfa31a40416d2a56973fae1807b)@@ -97,6 +97,7 @@ TEST\_PROGS += fdb\_flush.sh TEST\_PROGS += fq\_band\_pktlimit.sh TEST\_PROGS += vlan\_hw\_filter.sh TEST\_PROGS += bpf\_offload.py+TEST\_PROGS += ipv6\_route\_update\_soft\_lockup.sh  # YNL files, must be before "include ..lib.mk" EXTRA\_CLEAN += $(OUTPUT)/libynl.adiff --git a/tools/testing/selftests/net/ipv6\_route\_update\_soft\_lockup.sh b/tools/testing/selftests/net/ipv6\_route\_update\_soft\_lockup.shnew file mode 100755index 00000000000000..a6b2b1f9c641c9--- /dev/null+++ b/[tools/testing/selftests/net/ipv6\_route\_update\_soft\_lockup.sh](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/net/ipv6_route_update_soft_lockup.sh?id=34a949e7a0869dfa31a40416d2a56973fae1807b)@@ -0,0 +1,262 @@+#!/bin/bash+# SPDX-License-Identifier: GPL-2.0+#+# Testing for potential kernel soft lockup during IPv6 routing table+# refresh under heavy outgoing IPv6 traffic. If a kernel soft lockup+# occurs, a kernel panic will be triggered to prevent associated issues.+#+#+# Test Environment Layout+#+# ┌----------------┐ ┌----------------┐+# | SOURCE\_NS | | SINK\_NS |+# | NAMESPACE | | NAMESPACE |+# |(iperf3 clients)| |(iperf3 servers)|+# | | | |+# | | | |+# | ┌-----------| nexthops |---------┐ |+# | |veth\_source|<--------------------------------------->|veth\_sink|<┐ |+# | └-----------|2001:0DB8:1::0:1/96 2001:0DB8:1::1:1/96 |---------┘ | |+# | | ^ 2001:0DB8:1::1:2/96 | | |+# | | . . | fwd | |+# | ┌---------┐ | . . | | |+# | | IPv6 | | . . | V |+# | | routing | | . 2001:0DB8:1::1:80/96| ┌-----┐ |+# | | table | | . | | lo | |+# | | nexthop | | . └--------┴-----┴-┘+# | | update | | ............................> 2001:0DB8:2::1:1/128+# | └-------- ┘ |+# └----------------┘+#+# The test script sets up two network namespaces, source\_ns and sink\_ns,+# connected via a veth link. Within source\_ns, it continuously updates the+# IPv6 routing table by flushing and inserting IPV6\_NEXTHOP\_ADDR\_COUNT nexthop+# IPs destined for SINK\_LOOPBACK\_IP\_ADDR in sink\_ns. This refresh occurs at a+# rate of 1/ROUTING\_TABLE\_REFRESH\_PERIOD per second for TEST\_DURATION seconds.+#+# Simultaneously, multiple iperf3 clients within source\_ns generate heavy+# outgoing IPv6 traffic. Each client is assigned a unique port number starting+# at 5000 and incrementing sequentially. Each client targets a unique iperf3+# server running in sink\_ns, connected to the SINK\_LOOPBACK\_IFACE interface+# using the same port number.+#+# The number of iperf3 servers and clients is set to half of the total+# available cores on each machine.+#+# NOTE: We have tested this script on machines with various CPU specifications,+# ranging from lower to higher performance as listed below. The test script+# effectively triggered a kernel soft lockup on machines running an unpatched+# kernel in under a minute:+#+# - 1x Intel Xeon E-2278G 8-Core Processor @ 3.40GHz+# - 1x Intel Xeon E-2378G Processor 8-Core @ 2.80GHz+# - 1x AMD EPYC 7401P 24-Core Processor @ 2.00GHz+# - 1x AMD EPYC 7402P 24-Core Processor @ 2.80GHz+# - 2x Intel Xeon Gold 5120 14-Core Processor @ 2.20GHz+# - 1x Ampere Altra Q80-30 80-Core Processor @ 3.00GHz+# - 2x Intel Xeon Gold 5120 14-Core Processor @ 2.20GHz+# - 2x Intel Xeon Silver 4214 24-Core Processor @ 2.20GHz+# - 1x AMD EPYC 7502P 32-Core @ 2.50GHz+# - 1x Intel Xeon Gold 6314U 32-Core Processor @ 2.30GHz+# - 2x Intel Xeon Gold 6338 32-Core Processor @ 2.00GHz+#+# On less performant machines, you may need to increase the TEST\_DURATION+# parameter to enhance the likelihood of encountering a race condition leading+# to a kernel soft lockup and avoid a false negative result.+#+# NOTE: The test may not produce the expected result in virtualized+# environments (e.g., qemu) due to differences in timing and CPU handling,+# which can affect the conditions needed to trigger a soft lockup.++source lib.sh+source net\_helper.sh++TEST\_DURATION=300+ROUTING\_TABLE\_REFRESH\_PERIOD=0.01++IPERF3\_BITRATE="300m"+++IPV6\_NEXTHOP\_ADDR\_COUNT="128"+IPV6\_NEXTHOP\_ADDR\_MASK="96"+IPV6\_NEXTHOP\_PREFIX="2001:0DB8:1"+++SOURCE\_TEST\_IFACE="veth\_source"+SOURCE\_TEST\_IP\_ADDR="2001:0DB8:1::0:1/96"++SINK\_TEST\_IFACE="veth\_sink"+# ${SINK\_TEST\_IFACE} is populated with the following range of IPv6 addresses:+# 2001:0DB8:1::1:1 to 2001:0DB8:1::1:${IPV6\_NEXTHOP\_ADDR\_COUNT}+SINK\_LOOPBACK\_IFACE="lo"+SINK\_LOOPBACK\_IP\_MASK="128"+SINK\_LOOPBACK\_IP\_ADDR="2001:0DB8:2::1:1"++nexthop\_ip\_list=""+termination\_signal=""+kernel\_softlokup\_panic\_prev\_val=""++terminate\_ns\_processes\_by\_pattern() {+ local ns=$1+ local pattern=$2++ for pid in $(ip netns pids ${ns}); do+ [ -e /proc/$pid/cmdline ] && grep -qe "${pattern}" /proc/$pid/cmdline && kill -9 $pid+ done+}++cleanup() {+ echo "info: cleaning up namespaces and terminating all processes within them..."+++ # Terminate iperf3 instances running in the source\_ns. To avoid race+ # conditions, first iterate over the PIDs and terminate those+ # associated with the bash shells running the+ # `while true; do iperf3 -c ...; done` loops. In a second iteration,+ # terminate the individual `iperf3 -c ...` instances.+ terminate\_ns\_processes\_by\_pattern ${source\_ns} while+ terminate\_ns\_processes\_by\_pattern ${source\_ns} iperf3++ # Repeat the same process for sink\_ns+ terminate\_ns\_processes\_by\_pattern ${sink\_ns} while+ terminate\_ns\_processes\_by\_pattern ${sink\_ns} iperf3++ # Check if any iperf3 instances are still running. This could happen+ # if a core has entered an infinite loop and the timeout for detecting+ # the soft lockup has not expired, but either the test interval has+ # already elapsed or the test was terminated manually (e.g., with ^C)+ for pid in $(ip netns pids ${source\_ns}); do+ if [ -e /proc/$pid/cmdline ] && grep -qe 'iperf3' /proc/$pid/cmdline; then+ echo "FAIL: unable to terminate some iperf3 instances. Soft lockup is underway. A kernel panic is on the way!"+ exit ${ksft\_fail}+ fi+ done++ if [ "$termination\_signal" == "SIGINT" ]; then+ echo "SKIP: Termination due to ^C (SIGINT)"+ elif [ "$termination\_signal" == "SIGALRM" ]; then+ echo "PASS: No kernel soft lockup occurred during this ${TEST\_DURATION} second test"+ fi++ cleanup\_ns ${source\_ns} ${sink\_ns}++ sysctl -qw kernel.softlockup\_panic=${kernel\_softlokup\_panic\_prev\_val}+}++setup\_prepare() {+ setup\_ns source\_ns sink\_ns++ ip -n ${source\_ns} link add name ${SOURCE\_TEST\_IFACE} type veth peer name ${SINK\_TEST\_IFACE} netns ${sink\_ns}++ # Setting up the Source namespace+ ip -n ${source\_ns} addr add ${SOURCE\_TEST\_IP\_ADDR} dev ${SOURCE\_TEST\_IFACE}+ ip -n ${source\_ns} link set dev ${SOURCE\_TEST\_IFACE} qlen 10000+ ip -n ${source\_ns} link set dev ${SOURCE\_TEST\_IFACE} up+ ip netns exec ${source\_ns} sysctl -qw net.ipv6.fib\_multipath\_hash\_policy=1++ # Setting up the Sink namespace+ ip -n ${sink\_ns} addr add ${SINK\_LOOPBACK\_IP\_ADDR}/${SINK\_LOOPBACK\_IP\_MASK} dev ${SINK\_LOOPBACK\_IFACE}+ ip -n ${sink\_ns} link set dev ${SINK\_LOOPBACK\_IFACE} up+ ip netns exec ${sink\_ns} sysctl -qw net.ipv6.conf.${SINK\_LOOPBACK\_IFACE}.forwarding=1++ ip -n ${sink\_ns} link set ${SINK\_TEST\_IFACE} up+ ip netns exec ${sink\_ns} sysctl -qw net.ipv6.conf.${SINK\_TEST\_IFACE}.forwarding=1+++ # Populate nexthop IPv6 addresses on the test interface in the sink\_ns+ echo "info: populating ${IPV6\_NEXTHOP\_ADDR\_COUNT} IPv6 addresses on the ${SINK\_TEST\_IFACE} interface ..."+ for IP in $(seq 1 ${IPV6\_NEXTHOP\_ADDR\_COUNT}); do+ ip -n ${sink\_ns} addr add ${IPV6\_NEXTHOP\_PREFIX}::$(printf "1:%x" "${IP}")/${IPV6\_NEXTHOP\_ADDR\_MASK} dev ${SINK\_TEST\_IFACE};+ done++ # Preparing list of nexthops+ for IP in $(seq 1 ${IPV6\_NEXTHOP\_ADDR\_COUNT}); do+ nexthop\_ip\_list=$nexthop\_ip\_list" nexthop via ${IPV6\_NEXTHOP\_PREFIX}::$(printf "1:%x" $IP) dev ${SOURCE\_TEST\_IFACE} weight 1"+ done+}+++test\_soft\_lockup\_during\_routing\_table\_refresh() {+ # Start num\_of\_iperf\_servers iperf3 servers in the sink\_ns namespace,+ # each listening on ports starting at 5001 and incrementing+ # sequentially. Since iperf3 instances may terminate unexpectedly, a+ # while loop is used to automatically restart them in such cases.+ echo "info: starting ${num\_of\_iperf\_servers} iperf3 servers in the sink\_ns namespace ..."+ for i in $(seq 1 ${num\_of\_iperf\_servers}); do+ cmd="iperf3 --bind ${SINK\_LOOPBACK\_IP\_ADDR} -s -p $(printf '5%03d' ${i}) --rcv-timeout 200 &>/dev/null"+ ip netns exec ${sink\_ns} bash -c "while true; do ${cmd}; done &" &>/dev/null+ done++ # Wait for the iperf3 servers to be ready+ for i in $(seq ${num\_of\_iperf\_servers}); do+ port=$(printf '5%03d' ${i});+ wait\_local\_port\_listen ${sink\_ns} ${port} tcp+ done++ # Continuously refresh the routing table in the background within+ # the source\_ns namespace+ ip netns exec ${source\_ns} bash -c "+ while \$(ip netns list | grep -q ${source\_ns}); do+ ip -6 route add ${SINK\_LOOPBACK\_IP\_ADDR}/${SINK\_LOOPBACK\_IP\_MASK} ${nexthop\_ip\_list};+ sleep ${ROUTING\_TABLE\_REFRESH\_PERIOD};+ ip -6 route delete ${SINK\_LOOPBACK\_IP\_ADDR}/${SINK\_LOOPBACK\_IP\_MASK};+ done &"++ # Start num\_of\_iperf\_servers iperf3 clients in the source\_ns namespace,+ # each sending TCP traffic on sequential ports starting at 5001.+ # Since iperf3 instances may terminate unexpectedly (e.g., if the route+ # to the server is deleted in the background during a route refresh), a+ # while loop is used to automatically restart them in such cases.+ echo "info: starting ${num\_of\_iperf\_servers} iperf3 clients in the source\_ns namespace ..."+ for i in $(seq 1 ${num\_of\_iperf\_servers}); do+ cmd="iperf3 -c ${SINK\_LOOPBACK\_IP\_ADDR} -p $(printf '5%03d' ${i}) --length 64 --bitrate ${IPERF3\_BITRATE} -t 0 --connect-timeout 150 &>/dev/null"+ ip netns exec ${source\_ns} bash -c "while true; do ${cmd}; done &" &>/dev/null+ done++ echo "info: IPv6 routing table is being updated at the rate of $(echo "1/${ROUTING\_TABLE\_REFRESH\_PERIOD}" | bc)/s for ${TEST\_DURATION} seconds ..."+ echo "info: A kernel soft lockup, if detected, results in a kernel panic!"++ wait+}++# Make sure 'iperf3' is installed, skip the test otherwise+if [ ! -x "$(command -v "iperf3")" ]; then+ echo "SKIP: 'iperf3' is not installed. Skipping the test."+ exit ${ksft\_skip}+fi++# Determine the number of cores on the machine+num\_of\_iperf\_servers=$(( $(nproc)/2 ))++# Check if we are running on a multi-core machine, skip the test otherwise+if [ "${num\_of\_iperf\_servers}" -eq 0 ]; then+ echo "SKIP: This test is not valid on a single core machine!"+ exit ${ksft\_skip}+fi++# Since the kernel soft lockup we're testing causes at least one core to enter+# an infinite loop, destabilizing the host and likely affecting subsequent+# tests, we trigger a kernel panic instead of reporting a failure and+# continuing+kernel\_softlokup\_panic\_prev\_val=$(sysctl -n kernel.softlockup\_panic)+sysctl -qw kernel.softlockup\_panic=1++handle\_sigint() {+ termination\_signal="SIGINT"+ cleanup+ exit ${ksft\_skip}+}++handle\_sigalrm() {+ termination\_signal="SIGALRM"+ cleanup+ exit ${ksft\_pass}+}++trap handle\_sigint SIGINT+trap handle\_sigalrm SIGALRM++(sleep ${TEST\_DURATION} && kill -s SIGALRM $$)&++setup\_prepare+test\_soft\_lockup\_during\_routing\_table\_refresh |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 19:02:38 +0000



=== Content from git.kernel.org_1b591055_20250114_190401.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=11edcd026012ac18acee0f1514db3ed1b160fc6f)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=11edcd026012ac18acee0f1514db3ed1b160fc6f)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=11edcd026012ac18acee0f1514db3ed1b160fc6f)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=11edcd026012ac18acee0f1514db3ed1b160fc6f)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Omid Ehtemam-Haghighi <omid.ehtemamhaghighi@menlosecurity.com> | 2024-11-05 17:02:36 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-05 13:53:25 +0100 |
| commit | [11edcd026012ac18acee0f1514db3ed1b160fc6f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=11edcd026012ac18acee0f1514db3ed1b160fc6f) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=11edcd026012ac18acee0f1514db3ed1b160fc6f)) | |
| tree | [65a0e55ce2526684c903f9a294102a22ec455ccd](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=11edcd026012ac18acee0f1514db3ed1b160fc6f) | |
| parent | [316d7d6e027d96996b4140d91260616b1de210ef](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=316d7d6e027d96996b4140d91260616b1de210ef) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=11edcd026012ac18acee0f1514db3ed1b160fc6f&id2=316d7d6e027d96996b4140d91260616b1de210ef)) | |
| download | [linux-11edcd026012ac18acee0f1514db3ed1b160fc6f.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-11edcd026012ac18acee0f1514db3ed1b160fc6f.tar.gz) | |

ipv6: Fix soft lockups in fib6\_select\_path under high next hop churn[ Upstream commit d9ccb18f83ea2bb654289b6ecf014fd267cc988b ]
Soft lockups have been observed on a cluster of Linux-based edge routers
located in a highly dynamic environment. Using the `bird` service, these
routers continuously update BGP-advertised routes due to frequently
changing nexthop destinations, while also managing significant IPv6
traffic. The lockups occur during the traversal of the multipath
circular linked-list in the `fib6\_select\_path` function, particularly
while iterating through the siblings in the list. The issue typically
arises when the nodes of the linked list are unexpectedly deleted
concurrently on a different core—indicated by their 'next' and
'previous' elements pointing back to the node itself and their reference
count dropping to zero. This results in an infinite loop, leading to a
soft lockup that triggers a system panic via the watchdog timer.
Apply RCU primitives in the problematic code sections to resolve the
issue. Where necessary, update the references to fib6\_siblings to
annotate or use the RCU APIs.
Include a test script that reproduces the issue. The script
periodically updates the routing table while generating a heavy load
of outgoing IPv6 traffic through multiple iperf3 clients. It
consistently induces infinite soft lockups within a couple of minutes.
Kernel log:
0 [ffffbd13003e8d30] machine\_kexec at ffffffff8ceaf3eb
1 [ffffbd13003e8d90] \_\_crash\_kexec at ffffffff8d0120e3
2 [ffffbd13003e8e58] panic at ffffffff8cef65d4
3 [ffffbd13003e8ed8] watchdog\_timer\_fn at ffffffff8d05cb03
4 [ffffbd13003e8f08] \_\_hrtimer\_run\_queues at ffffffff8cfec62f
5 [ffffbd13003e8f70] hrtimer\_interrupt at ffffffff8cfed756
6 [ffffbd13003e8fd0] \_\_sysvec\_apic\_timer\_interrupt at ffffffff8cea01af
7 [ffffbd13003e8ff0] sysvec\_apic\_timer\_interrupt at ffffffff8df1b83d
-- <IRQ stack> --
8 [ffffbd13003d3708] asm\_sysvec\_apic\_timer\_interrupt at ffffffff8e000ecb
[exception RIP: fib6\_select\_path+299]
RIP: ffffffff8ddafe7b RSP: ffffbd13003d37b8 RFLAGS: 00000287
RAX: ffff975850b43600 RBX: ffff975850b40200 RCX: 0000000000000000
RDX: 000000003fffffff RSI: 0000000051d383e4 RDI: ffff975850b43618
RBP: ffffbd13003d3800 R8: 0000000000000000 R9: ffff975850b40200
R10: 0000000000000000 R11: 0000000000000000 R12: ffffbd13003d3830
R13: ffff975850b436a8 R14: ffff975850b43600 R15: 0000000000000007
ORIG\_RAX: ffffffffffffffff CS: 0010 SS: 0018
9 [ffffbd13003d3808] ip6\_pol\_route at ffffffff8ddb030c
10 [ffffbd13003d3888] ip6\_pol\_route\_input at ffffffff8ddb068c
11 [ffffbd13003d3898] fib6\_rule\_lookup at ffffffff8ddf02b5
12 [ffffbd13003d3928] ip6\_route\_input at ffffffff8ddb0f47
13 [ffffbd13003d3a18] ip6\_rcv\_finish\_core.constprop.0 at ffffffff8dd950d0
14 [ffffbd13003d3a30] ip6\_list\_rcv\_finish.constprop.0 at ffffffff8dd96274
15 [ffffbd13003d3a98] ip6\_sublist\_rcv at ffffffff8dd96474
16 [ffffbd13003d3af8] ipv6\_list\_rcv at ffffffff8dd96615
17 [ffffbd13003d3b60] \_\_netif\_receive\_skb\_list\_core at ffffffff8dc16fec
18 [ffffbd13003d3be0] netif\_receive\_skb\_list\_internal at ffffffff8dc176b3
19 [ffffbd13003d3c50] napi\_gro\_receive at ffffffff8dc565b9
20 [ffffbd13003d3c80] ice\_receive\_skb at ffffffffc087e4f5 [ice]
21 [ffffbd13003d3c90] ice\_clean\_rx\_irq at ffffffffc0881b80 [ice]
22 [ffffbd13003d3d20] ice\_napi\_poll at ffffffffc088232f [ice]
23 [ffffbd13003d3d80] \_\_napi\_poll at ffffffff8dc18000
24 [ffffbd13003d3db8] net\_rx\_action at ffffffff8dc18581
25 [ffffbd13003d3e40] \_\_do\_softirq at ffffffff8df352e9
26 [ffffbd13003d3eb0] run\_ksoftirqd at ffffffff8ceffe47
27 [ffffbd13003d3ec0] smpboot\_thread\_fn at ffffffff8cf36a30
28 [ffffbd13003d3ee8] kthread at ffffffff8cf2b39f
29 [ffffbd13003d3f28] ret\_from\_fork at ffffffff8ce5fa64
30 [ffffbd13003d3f50] ret\_from\_fork\_asm at ffffffff8ce03cbb
Fixes: 66f5d6ce53e6 ("ipv6: replace rwlock with rcu and spinlock in fib6\_table")
Reported-by: Adrian Oliver <kernel@aoliver.ca>
Signed-off-by: Omid Ehtemam-Haghighi <omid.ehtemamhaghighi@menlosecurity.com>
Cc: Shuah Khan <shuah@kernel.org>
Cc: Ido Schimmel <idosch@idosch.org>
Cc: Kuniyuki Iwashima <kuniyu@amazon.com>
Cc: Simon Horman <horms@kernel.org>
Reviewed-by: David Ahern <dsahern@kernel.org>
Link: [https://patch.msgid.link/20241106010236.1239299-1-omid.ehtemamhaghighi@menlosecurity.com](https://patch.msgid.link/20241106010236.1239299-1-omid.ehtemamhaghighi%40menlosecurity.com)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=11edcd026012ac18acee0f1514db3ed1b160fc6f)

| -rw-r--r-- | [net/ipv6/ip6\_fib.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/ip6_fib.c?id=11edcd026012ac18acee0f1514db3ed1b160fc6f) | 8 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/ipv6/route.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/route.c?id=11edcd026012ac18acee0f1514db3ed1b160fc6f) | 45 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/net/Makefile](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/net/Makefile?id=11edcd026012ac18acee0f1514db3ed1b160fc6f) | 1 | |  |  |  | | --- | --- | --- | |
| -rwxr-xr-x | [tools/testing/selftests/net/ipv6\_route\_update\_soft\_lockup.sh](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/net/ipv6_route_update_soft_lockup.sh?id=11edcd026012ac18acee0f1514db3ed1b160fc6f) | 262 | |  |  |  | | --- | --- | --- | |

4 files changed, 297 insertions, 19 deletions

| diff --git a/net/ipv6/ip6\_fib.c b/net/ipv6/ip6\_fib.cindex eb111d20615c62..9a1c59275a1099 100644--- a/[net/ipv6/ip6\_fib.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/ip6_fib.c?id=316d7d6e027d96996b4140d91260616b1de210ef)+++ b/[net/ipv6/ip6\_fib.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/ip6_fib.c?id=11edcd026012ac18acee0f1514db3ed1b160fc6f)@@ -1190,8 +1190,8 @@ next\_iter: while (sibling) { if (sibling->fib6\_metric == rt->fib6\_metric && rt6\_qualify\_for\_ecmp(sibling)) {- list\_add\_tail(&rt->fib6\_siblings,- &sibling->fib6\_siblings);+ list\_add\_tail\_rcu(&rt->fib6\_siblings,+ &sibling->fib6\_siblings); break; } sibling = rcu\_dereference\_protected(sibling->fib6\_next,@@ -1252,7 +1252,7 @@ add: fib6\_siblings) sibling->fib6\_nsiblings--; rt->fib6\_nsiblings = 0;- list\_del\_init(&rt->fib6\_siblings);+ list\_del\_rcu(&rt->fib6\_siblings); rt6\_multipath\_rebalance(next\_sibling); return err; }@@ -1970,7 +1970,7 @@ static void fib6\_del\_route(struct fib6\_table \*table, struct fib6\_node \*fn, &rt->fib6\_siblings, fib6\_siblings) sibling->fib6\_nsiblings--; rt->fib6\_nsiblings = 0;- list\_del\_init(&rt->fib6\_siblings);+ list\_del\_rcu(&rt->fib6\_siblings); rt6\_multipath\_rebalance(next\_sibling); } diff --git a/net/ipv6/route.c b/net/ipv6/route.cindex 606cdd87745a6a..6b58842c5a73d8 100644--- a/[net/ipv6/route.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/route.c?id=316d7d6e027d96996b4140d91260616b1de210ef)+++ b/[net/ipv6/route.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/route.c?id=11edcd026012ac18acee0f1514db3ed1b160fc6f)@@ -416,8 +416,8 @@ void fib6\_select\_path(const struct net \*net, struct fib6\_result \*res, struct flowi6 \*fl6, int oif, bool have\_oif\_match, const struct sk\_buff \*skb, int strict) {- struct fib6\_info \*sibling, \*next\_sibling; struct fib6\_info \*match = res->f6i;+ struct fib6\_info \*sibling;  if (!match->nh && (!match->fib6\_nsiblings || have\_oif\_match)) goto out;@@ -443,8 +443,8 @@ void fib6\_select\_path(const struct net \*net, struct fib6\_result \*res, if (fl6->mp\_hash <= atomic\_read(&match->fib6\_nh->fib\_nh\_upper\_bound)) goto out; - list\_for\_each\_entry\_safe(sibling, next\_sibling, &match->fib6\_siblings,- fib6\_siblings) {+ list\_for\_each\_entry\_rcu(sibling, &match->fib6\_siblings,+ fib6\_siblings) { const struct fib6\_nh \*nh = sibling->fib6\_nh; int nh\_upper\_bound; @@ -5195,14 +5195,18 @@ static void ip6\_route\_mpath\_notify(struct fib6\_info \*rt, \* nexthop. Since sibling routes are always added at the end of \* the list, find the first sibling of the last route appended \*/+ rcu\_read\_lock();+ if ((nlflags & NLM\_F\_APPEND) && rt\_last && rt\_last->fib6\_nsiblings) {- rt = list\_first\_entry(&rt\_last->fib6\_siblings,- struct fib6\_info,- fib6\_siblings);+ rt = list\_first\_or\_null\_rcu(&rt\_last->fib6\_siblings,+ struct fib6\_info,+ fib6\_siblings); }  if (rt) inet6\_rt\_notify(RTM\_NEWROUTE, rt, info, nlflags);++ rcu\_read\_unlock(); }  static bool ip6\_route\_mpath\_should\_notify(const struct fib6\_info \*rt)@@ -5547,17 +5551,21 @@ static size\_t rt6\_nlmsg\_size(struct fib6\_info \*f6i) nexthop\_for\_each\_fib6\_nh(f6i->nh, rt6\_nh\_nlmsg\_size, &nexthop\_len); } else {- struct fib6\_info \*sibling, \*next\_sibling; struct fib6\_nh \*nh = f6i->fib6\_nh;+ struct fib6\_info \*sibling;  nexthop\_len = 0; if (f6i->fib6\_nsiblings) { rt6\_nh\_nlmsg\_size(nh, &nexthop\_len); - list\_for\_each\_entry\_safe(sibling, next\_sibling,- &f6i->fib6\_siblings, fib6\_siblings) {+ rcu\_read\_lock();++ list\_for\_each\_entry\_rcu(sibling, &f6i->fib6\_siblings,+ fib6\_siblings) { rt6\_nh\_nlmsg\_size(sibling->fib6\_nh, &nexthop\_len); }++ rcu\_read\_unlock(); } nexthop\_len += lwtunnel\_get\_encap\_size(nh->fib\_nh\_lws); }@@ -5721,7 +5729,7 @@ static int rt6\_fill\_node(struct net \*net, struct sk\_buff \*skb, lwtunnel\_fill\_encap(skb, dst->lwtstate, RTA\_ENCAP, RTA\_ENCAP\_TYPE) < 0) goto nla\_put\_failure; } else if (rt->fib6\_nsiblings) {- struct fib6\_info \*sibling, \*next\_sibling;+ struct fib6\_info \*sibling; struct nlattr \*mp;  mp = nla\_nest\_start\_noflag(skb, RTA\_MULTIPATH);@@ -5733,14 +5741,21 @@ static int rt6\_fill\_node(struct net \*net, struct sk\_buff \*skb, 0) < 0) goto nla\_put\_failure; - list\_for\_each\_entry\_safe(sibling, next\_sibling,- &rt->fib6\_siblings, fib6\_siblings) {+ rcu\_read\_lock();++ list\_for\_each\_entry\_rcu(sibling, &rt->fib6\_siblings,+ fib6\_siblings) { if (fib\_add\_nexthop(skb, &sibling->fib6\_nh->nh\_common, sibling->fib6\_nh->fib\_nh\_weight,- AF\_INET6, 0) < 0)+ AF\_INET6, 0) < 0) {+ rcu\_read\_unlock();+ goto nla\_put\_failure;+ } } + rcu\_read\_unlock();+ nla\_nest\_end(skb, mp); } else if (rt->nh) { if (nla\_put\_u32(skb, RTA\_NH\_ID, rt->nh->id))@@ -6177,7 +6192,7 @@ void inet6\_rt\_notify(int event, struct fib6\_info \*rt, struct nl\_info \*info, err = -ENOBUFS; seq = info->nlh ? info->nlh->nlmsg\_seq : 0; - skb = nlmsg\_new(rt6\_nlmsg\_size(rt), gfp\_any());+ skb = nlmsg\_new(rt6\_nlmsg\_size(rt), GFP\_ATOMIC); if (!skb) goto errout; @@ -6190,7 +6205,7 @@ void inet6\_rt\_notify(int event, struct fib6\_info \*rt, struct nl\_info \*info, goto errout; } rtnl\_notify(skb, net, info->portid, RTNLGRP\_IPV6\_ROUTE,- info->nlh, gfp\_any());+ info->nlh, GFP\_ATOMIC); return; errout: if (err < 0)diff --git a/tools/testing/selftests/net/Makefile b/tools/testing/selftests/net/Makefileindex 9d5aa817411b65..d79942e6ff76f6 100644--- a/[tools/testing/selftests/net/Makefile](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/net/Makefile?id=316d7d6e027d96996b4140d91260616b1de210ef)+++ b/[tools/testing/selftests/net/Makefile](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/net/Makefile?id=11edcd026012ac18acee0f1514db3ed1b160fc6f)@@ -95,6 +95,7 @@ TEST\_PROGS += fdb\_flush.sh TEST\_PROGS += fq\_band\_pktlimit.sh TEST\_PROGS += vlan\_hw\_filter.sh TEST\_PROGS += bpf\_offload.py+TEST\_PROGS += ipv6\_route\_update\_soft\_lockup.sh  TEST\_FILES := settings TEST\_FILES += in\_netns.sh lib.sh net\_helper.sh setup\_loopback.sh setup\_veth.shdiff --git a/tools/testing/selftests/net/ipv6\_route\_update\_soft\_lockup.sh b/tools/testing/selftests/net/ipv6\_route\_update\_soft\_lockup.shnew file mode 100755index 00000000000000..a6b2b1f9c641c9--- /dev/null+++ b/[tools/testing/selftests/net/ipv6\_route\_update\_soft\_lockup.sh](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/net/ipv6_route_update_soft_lockup.sh?id=11edcd026012ac18acee0f1514db3ed1b160fc6f)@@ -0,0 +1,262 @@+#!/bin/bash+# SPDX-License-Identifier: GPL-2.0+#+# Testing for potential kernel soft lockup during IPv6 routing table+# refresh under heavy outgoing IPv6 traffic. If a kernel soft lockup+# occurs, a kernel panic will be triggered to prevent associated issues.+#+#+# Test Environment Layout+#+# ┌----------------┐ ┌----------------┐+# | SOURCE\_NS | | SINK\_NS |+# | NAMESPACE | | NAMESPACE |+# |(iperf3 clients)| |(iperf3 servers)|+# | | | |+# | | | |+# | ┌-----------| nexthops |---------┐ |+# | |veth\_source|<--------------------------------------->|veth\_sink|<┐ |+# | └-----------|2001:0DB8:1::0:1/96 2001:0DB8:1::1:1/96 |---------┘ | |+# | | ^ 2001:0DB8:1::1:2/96 | | |+# | | . . | fwd | |+# | ┌---------┐ | . . | | |+# | | IPv6 | | . . | V |+# | | routing | | . 2001:0DB8:1::1:80/96| ┌-----┐ |+# | | table | | . | | lo | |+# | | nexthop | | . └--------┴-----┴-┘+# | | update | | ............................> 2001:0DB8:2::1:1/128+# | └-------- ┘ |+# └----------------┘+#+# The test script sets up two network namespaces, source\_ns and sink\_ns,+# connected via a veth link. Within source\_ns, it continuously updates the+# IPv6 routing table by flushing and inserting IPV6\_NEXTHOP\_ADDR\_COUNT nexthop+# IPs destined for SINK\_LOOPBACK\_IP\_ADDR in sink\_ns. This refresh occurs at a+# rate of 1/ROUTING\_TABLE\_REFRESH\_PERIOD per second for TEST\_DURATION seconds.+#+# Simultaneously, multiple iperf3 clients within source\_ns generate heavy+# outgoing IPv6 traffic. Each client is assigned a unique port number starting+# at 5000 and incrementing sequentially. Each client targets a unique iperf3+# server running in sink\_ns, connected to the SINK\_LOOPBACK\_IFACE interface+# using the same port number.+#+# The number of iperf3 servers and clients is set to half of the total+# available cores on each machine.+#+# NOTE: We have tested this script on machines with various CPU specifications,+# ranging from lower to higher performance as listed below. The test script+# effectively triggered a kernel soft lockup on machines running an unpatched+# kernel in under a minute:+#+# - 1x Intel Xeon E-2278G 8-Core Processor @ 3.40GHz+# - 1x Intel Xeon E-2378G Processor 8-Core @ 2.80GHz+# - 1x AMD EPYC 7401P 24-Core Processor @ 2.00GHz+# - 1x AMD EPYC 7402P 24-Core Processor @ 2.80GHz+# - 2x Intel Xeon Gold 5120 14-Core Processor @ 2.20GHz+# - 1x Ampere Altra Q80-30 80-Core Processor @ 3.00GHz+# - 2x Intel Xeon Gold 5120 14-Core Processor @ 2.20GHz+# - 2x Intel Xeon Silver 4214 24-Core Processor @ 2.20GHz+# - 1x AMD EPYC 7502P 32-Core @ 2.50GHz+# - 1x Intel Xeon Gold 6314U 32-Core Processor @ 2.30GHz+# - 2x Intel Xeon Gold 6338 32-Core Processor @ 2.00GHz+#+# On less performant machines, you may need to increase the TEST\_DURATION+# parameter to enhance the likelihood of encountering a race condition leading+# to a kernel soft lockup and avoid a false negative result.+#+# NOTE: The test may not produce the expected result in virtualized+# environments (e.g., qemu) due to differences in timing and CPU handling,+# which can affect the conditions needed to trigger a soft lockup.++source lib.sh+source net\_helper.sh++TEST\_DURATION=300+ROUTING\_TABLE\_REFRESH\_PERIOD=0.01++IPERF3\_BITRATE="300m"+++IPV6\_NEXTHOP\_ADDR\_COUNT="128"+IPV6\_NEXTHOP\_ADDR\_MASK="96"+IPV6\_NEXTHOP\_PREFIX="2001:0DB8:1"+++SOURCE\_TEST\_IFACE="veth\_source"+SOURCE\_TEST\_IP\_ADDR="2001:0DB8:1::0:1/96"++SINK\_TEST\_IFACE="veth\_sink"+# ${SINK\_TEST\_IFACE} is populated with the following range of IPv6 addresses:+# 2001:0DB8:1::1:1 to 2001:0DB8:1::1:${IPV6\_NEXTHOP\_ADDR\_COUNT}+SINK\_LOOPBACK\_IFACE="lo"+SINK\_LOOPBACK\_IP\_MASK="128"+SINK\_LOOPBACK\_IP\_ADDR="2001:0DB8:2::1:1"++nexthop\_ip\_list=""+termination\_signal=""+kernel\_softlokup\_panic\_prev\_val=""++terminate\_ns\_processes\_by\_pattern() {+ local ns=$1+ local pattern=$2++ for pid in $(ip netns pids ${ns}); do+ [ -e /proc/$pid/cmdline ] && grep -qe "${pattern}" /proc/$pid/cmdline && kill -9 $pid+ done+}++cleanup() {+ echo "info: cleaning up namespaces and terminating all processes within them..."+++ # Terminate iperf3 instances running in the source\_ns. To avoid race+ # conditions, first iterate over the PIDs and terminate those+ # associated with the bash shells running the+ # `while true; do iperf3 -c ...; done` loops. In a second iteration,+ # terminate the individual `iperf3 -c ...` instances.+ terminate\_ns\_processes\_by\_pattern ${source\_ns} while+ terminate\_ns\_processes\_by\_pattern ${source\_ns} iperf3++ # Repeat the same process for sink\_ns+ terminate\_ns\_processes\_by\_pattern ${sink\_ns} while+ terminate\_ns\_processes\_by\_pattern ${sink\_ns} iperf3++ # Check if any iperf3 instances are still running. This could happen+ # if a core has entered an infinite loop and the timeout for detecting+ # the soft lockup has not expired, but either the test interval has+ # already elapsed or the test was terminated manually (e.g., with ^C)+ for pid in $(ip netns pids ${source\_ns}); do+ if [ -e /proc/$pid/cmdline ] && grep -qe 'iperf3' /proc/$pid/cmdline; then+ echo "FAIL: unable to terminate some iperf3 instances. Soft lockup is underway. A kernel panic is on the way!"+ exit ${ksft\_fail}+ fi+ done++ if [ "$termination\_signal" == "SIGINT" ]; then+ echo "SKIP: Termination due to ^C (SIGINT)"+ elif [ "$termination\_signal" == "SIGALRM" ]; then+ echo "PASS: No kernel soft lockup occurred during this ${TEST\_DURATION} second test"+ fi++ cleanup\_ns ${source\_ns} ${sink\_ns}++ sysctl -qw kernel.softlockup\_panic=${kernel\_softlokup\_panic\_prev\_val}+}++setup\_prepare() {+ setup\_ns source\_ns sink\_ns++ ip -n ${source\_ns} link add name ${SOURCE\_TEST\_IFACE} type veth peer name ${SINK\_TEST\_IFACE} netns ${sink\_ns}++ # Setting up the Source namespace+ ip -n ${source\_ns} addr add ${SOURCE\_TEST\_IP\_ADDR} dev ${SOURCE\_TEST\_IFACE}+ ip -n ${source\_ns} link set dev ${SOURCE\_TEST\_IFACE} qlen 10000+ ip -n ${source\_ns} link set dev ${SOURCE\_TEST\_IFACE} up+ ip netns exec ${source\_ns} sysctl -qw net.ipv6.fib\_multipath\_hash\_policy=1++ # Setting up the Sink namespace+ ip -n ${sink\_ns} addr add ${SINK\_LOOPBACK\_IP\_ADDR}/${SINK\_LOOPBACK\_IP\_MASK} dev ${SINK\_LOOPBACK\_IFACE}+ ip -n ${sink\_ns} link set dev ${SINK\_LOOPBACK\_IFACE} up+ ip netns exec ${sink\_ns} sysctl -qw net.ipv6.conf.${SINK\_LOOPBACK\_IFACE}.forwarding=1++ ip -n ${sink\_ns} link set ${SINK\_TEST\_IFACE} up+ ip netns exec ${sink\_ns} sysctl -qw net.ipv6.conf.${SINK\_TEST\_IFACE}.forwarding=1+++ # Populate nexthop IPv6 addresses on the test interface in the sink\_ns+ echo "info: populating ${IPV6\_NEXTHOP\_ADDR\_COUNT} IPv6 addresses on the ${SINK\_TEST\_IFACE} interface ..."+ for IP in $(seq 1 ${IPV6\_NEXTHOP\_ADDR\_COUNT}); do+ ip -n ${sink\_ns} addr add ${IPV6\_NEXTHOP\_PREFIX}::$(printf "1:%x" "${IP}")/${IPV6\_NEXTHOP\_ADDR\_MASK} dev ${SINK\_TEST\_IFACE};+ done++ # Preparing list of nexthops+ for IP in $(seq 1 ${IPV6\_NEXTHOP\_ADDR\_COUNT}); do+ nexthop\_ip\_list=$nexthop\_ip\_list" nexthop via ${IPV6\_NEXTHOP\_PREFIX}::$(printf "1:%x" $IP) dev ${SOURCE\_TEST\_IFACE} weight 1"+ done+}+++test\_soft\_lockup\_during\_routing\_table\_refresh() {+ # Start num\_of\_iperf\_servers iperf3 servers in the sink\_ns namespace,+ # each listening on ports starting at 5001 and incrementing+ # sequentially. Since iperf3 instances may terminate unexpectedly, a+ # while loop is used to automatically restart them in such cases.+ echo "info: starting ${num\_of\_iperf\_servers} iperf3 servers in the sink\_ns namespace ..."+ for i in $(seq 1 ${num\_of\_iperf\_servers}); do+ cmd="iperf3 --bind ${SINK\_LOOPBACK\_IP\_ADDR} -s -p $(printf '5%03d' ${i}) --rcv-timeout 200 &>/dev/null"+ ip netns exec ${sink\_ns} bash -c "while true; do ${cmd}; done &" &>/dev/null+ done++ # Wait for the iperf3 servers to be ready+ for i in $(seq ${num\_of\_iperf\_servers}); do+ port=$(printf '5%03d' ${i});+ wait\_local\_port\_listen ${sink\_ns} ${port} tcp+ done++ # Continuously refresh the routing table in the background within+ # the source\_ns namespace+ ip netns exec ${source\_ns} bash -c "+ while \$(ip netns list | grep -q ${source\_ns}); do+ ip -6 route add ${SINK\_LOOPBACK\_IP\_ADDR}/${SINK\_LOOPBACK\_IP\_MASK} ${nexthop\_ip\_list};+ sleep ${ROUTING\_TABLE\_REFRESH\_PERIOD};+ ip -6 route delete ${SINK\_LOOPBACK\_IP\_ADDR}/${SINK\_LOOPBACK\_IP\_MASK};+ done &"++ # Start num\_of\_iperf\_servers iperf3 clients in the source\_ns namespace,+ # each sending TCP traffic on sequential ports starting at 5001.+ # Since iperf3 instances may terminate unexpectedly (e.g., if the route+ # to the server is deleted in the background during a route refresh), a+ # while loop is used to automatically restart them in such cases.+ echo "info: starting ${num\_of\_iperf\_servers} iperf3 clients in the source\_ns namespace ..."+ for i in $(seq 1 ${num\_of\_iperf\_servers}); do+ cmd="iperf3 -c ${SINK\_LOOPBACK\_IP\_ADDR} -p $(printf '5%03d' ${i}) --length 64 --bitrate ${IPERF3\_BITRATE} -t 0 --connect-timeout 150 &>/dev/null"+ ip netns exec ${source\_ns} bash -c "while true; do ${cmd}; done &" &>/dev/null+ done++ echo "info: IPv6 routing table is being updated at the rate of $(echo "1/${ROUTING\_TABLE\_REFRESH\_PERIOD}" | bc)/s for ${TEST\_DURATION} seconds ..."+ echo "info: A kernel soft lockup, if detected, results in a kernel panic!"++ wait+}++# Make sure 'iperf3' is installed, skip the test otherwise+if [ ! -x "$(command -v "iperf3")" ]; then+ echo "SKIP: 'iperf3' is not installed. Skipping the test."+ exit ${ksft\_skip}+fi++# Determine the number of cores on the machine+num\_of\_iperf\_servers=$(( $(nproc)/2 ))++# Check if we are running on a multi-core machine, skip the test otherwise+if [ "${num\_of\_iperf\_servers}" -eq 0 ]; then+ echo "SKIP: This test is not valid on a single core machine!"+ exit ${ksft\_skip}+fi++# Since the kernel soft lockup we're testing causes at least one core to enter+# an infinite loop, destabilizing the host and likely affecting subsequent+# tests, we trigger a kernel panic instead of reporting a failure and+# continuing+kernel\_softlokup\_panic\_prev\_val=$(sysctl -n kernel.softlockup\_panic)+sysctl -qw kernel.softlockup\_panic=1++handle\_sigint() {+ termination\_signal="SIGINT"+ cleanup+ exit ${ksft\_skip}+}++handle\_sigalrm() {+ termination\_signal="SIGALRM"+ cleanup+ exit ${ksft\_pass}+}++trap handle\_sigint SIGINT+trap handle\_sigalrm SIGALRM++(sleep ${TEST\_DURATION} && kill -s SIGALRM $$)&++setup\_prepare+test\_soft\_lockup\_during\_routing\_table\_refresh |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 19:02:38 +0000


