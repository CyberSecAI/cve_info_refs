=== Content from git.kernel.org_0d794157_20250114_181311.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=59458fa4ddb47e7891c61b4a928d13d5f5b00aa0)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=59458fa4ddb47e7891c61b4a928d13d5f5b00aa0)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=59458fa4ddb47e7891c61b4a928d13d5f5b00aa0)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=59458fa4ddb47e7891c61b4a928d13d5f5b00aa0)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Marco Elver <elver@google.com> | 2024-10-01 16:00:45 +0200 |
| --- | --- | --- |
| committer | Marco Elver <elver@google.com> | 2024-10-14 16:44:48 +0200 |
| commit | [59458fa4ddb47e7891c61b4a928d13d5f5b00aa0](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=59458fa4ddb47e7891c61b4a928d13d5f5b00aa0) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=59458fa4ddb47e7891c61b4a928d13d5f5b00aa0)) | |
| tree | [5af1d94df62350b4f28f86a3b886b9db3a5ae8ad](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=59458fa4ddb47e7891c61b4a928d13d5f5b00aa0) | |
| parent | [8cf0b93919e13d1e8d4466eb4080a4c4d9d66d7b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8cf0b93919e13d1e8d4466eb4080a4c4d9d66d7b) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=59458fa4ddb47e7891c61b4a928d13d5f5b00aa0&id2=8cf0b93919e13d1e8d4466eb4080a4c4d9d66d7b)) | |
| download | [linux-59458fa4ddb47e7891c61b4a928d13d5f5b00aa0.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-59458fa4ddb47e7891c61b4a928d13d5f5b00aa0.tar.gz) | |

kcsan: Turn report\_filterlist\_lock into a raw\_spinlockRan Xiaokai reports that with a KCSAN-enabled PREEMPT\_RT kernel, we can see
splats like:
| BUG: sleeping function called from invalid context at kernel/locking/spinlock\_rt.c:48
| in\_atomic(): 1, irqs\_disabled(): 1, non\_block: 0, pid: 0, name: swapper/1
| preempt\_count: 10002, expected: 0
| RCU nest depth: 0, expected: 0
| no locks held by swapper/1/0.
| irq event stamp: 156674
| hardirqs last enabled at (156673): [<ffffffff81130bd9>] do\_idle+0x1f9/0x240
| hardirqs last disabled at (156674): [<ffffffff82254f84>] sysvec\_apic\_timer\_interrupt+0x14/0xc0
| softirqs last enabled at (0): [<ffffffff81099f47>] copy\_process+0xfc7/0x4b60
| softirqs last disabled at (0): [<0000000000000000>] 0x0
| Preemption disabled at:
| [<ffffffff814a3e2a>] paint\_ptr+0x2a/0x90
| CPU: 1 UID: 0 PID: 0 Comm: swapper/1 Not tainted 6.11.0+ #3
| Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-0-ga698c8995f-prebuilt.qemu.org 04/01/2014
| Call Trace:
| <IRQ>
| dump\_stack\_lvl+0x7e/0xc0
| dump\_stack+0x1d/0x30
| \_\_might\_resched+0x1a2/0x270
| rt\_spin\_lock+0x68/0x170
| kcsan\_skip\_report\_debugfs+0x43/0xe0
| print\_report+0xb5/0x590
| kcsan\_report\_known\_origin+0x1b1/0x1d0
| kcsan\_setup\_watchpoint+0x348/0x650
| \_\_tsan\_unaligned\_write1+0x16d/0x1d0
| hrtimer\_interrupt+0x3d6/0x430
| \_\_sysvec\_apic\_timer\_interrupt+0xe8/0x3a0
| sysvec\_apic\_timer\_interrupt+0x97/0xc0
| </IRQ>
On a detected data race, KCSAN's reporting logic checks if it should
filter the report. That list is protected by the report\_filterlist\_lock
\*non-raw\* spinlock which may sleep on RT kernels.
Since KCSAN may report data races in any context, convert it to a
raw\_spinlock.
This requires being careful about when to allocate memory for the filter
list itself which can be done via KCSAN's debugfs interface. Concurrent
modification of the filter list via debugfs should be rare: the chosen
strategy is to optimistically pre-allocate memory before the critical
section and discard if unused.
Link: [https://lore.kernel.org/all/20240925143154.2322926-1-ranxiaokai627@163.com/](https://lore.kernel.org/all/20240925143154.2322926-1-ranxiaokai627%40163.com/)
Reported-by: Ran Xiaokai <ran.xiaokai@zte.com.cn>
Tested-by: Ran Xiaokai <ran.xiaokai@zte.com.cn>
Signed-off-by: Marco Elver <elver@google.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=59458fa4ddb47e7891c61b4a928d13d5f5b00aa0)

| -rw-r--r-- | [kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/kcsan/debugfs.c?id=59458fa4ddb47e7891c61b4a928d13d5f5b00aa0) | 74 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 36 insertions, 38 deletions

| diff --git a/kernel/kcsan/debugfs.c b/kernel/kcsan/debugfs.cindex 53b21ae30e00ee..b14072071889fb 100644--- a/[kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/kcsan/debugfs.c?id=8cf0b93919e13d1e8d4466eb4080a4c4d9d66d7b)+++ b/[kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/kcsan/debugfs.c?id=59458fa4ddb47e7891c61b4a928d13d5f5b00aa0)@@ -46,14 +46,8 @@ static struct { int used; /\* number of elements used \*/ bool sorted; /\* if elements are sorted \*/ bool whitelist; /\* if list is a blacklist or whitelist \*/-} report\_filterlist = {- .addrs = NULL,- .size = 8, /\* small initial size \*/- .used = 0,- .sorted = false,- .whitelist = false, /\* default is blacklist \*/-};-static DEFINE\_SPINLOCK(report\_filterlist\_lock);+} report\_filterlist;+static DEFINE\_RAW\_SPINLOCK(report\_filterlist\_lock);  /\* \* The microbenchmark allows benchmarking KCSAN core runtime only. To run@@ -110,7 +104,7 @@ bool kcsan\_skip\_report\_debugfs(unsigned long func\_addr) return false; func\_addr -= offset; /\* Get function start \*/ - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); if (report\_filterlist.used == 0) goto out; @@ -127,7 +121,7 @@ bool kcsan\_skip\_report\_debugfs(unsigned long func\_addr) ret = !ret;  out:- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); return ret; } @@ -135,9 +129,9 @@ static void set\_report\_filterlist\_whitelist(bool whitelist) { unsigned long flags; - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); report\_filterlist.whitelist = whitelist;- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); }  /\* Returns 0 on success, error-code otherwise. \*/@@ -145,6 +139,9 @@ static ssize\_t insert\_report\_filterlist(const char \*func) { unsigned long flags; unsigned long addr = kallsyms\_lookup\_name(func);+ unsigned long \*delay\_free = NULL;+ unsigned long \*new\_addrs = NULL;+ size\_t new\_size = 0; ssize\_t ret = 0;  if (!addr) {@@ -152,32 +149,33 @@ static ssize\_t insert\_report\_filterlist(const char \*func) return -ENOENT; } - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+retry\_alloc:+ /\*+ \* Check if we need an allocation, and re-validate under the lock. Since+ \* the report\_filterlist\_lock is a raw, cannot allocate under the lock.+ \*/+ if (data\_race(report\_filterlist.used == report\_filterlist.size)) {+ new\_size = (report\_filterlist.size ?: 4) \* 2;+ delay\_free = new\_addrs = kmalloc\_array(new\_size, sizeof(unsigned long), GFP\_KERNEL);+ if (!new\_addrs)+ return -ENOMEM;+ } - if (report\_filterlist.addrs == NULL) {- /\* initial allocation \*/- report\_filterlist.addrs =- kmalloc\_array(report\_filterlist.size,- sizeof(unsigned long), GFP\_ATOMIC);- if (report\_filterlist.addrs == NULL) {- ret = -ENOMEM;- goto out;- }- } else if (report\_filterlist.used == report\_filterlist.size) {- /\* resize filterlist \*/- size\_t new\_size = report\_filterlist.size \* 2;- unsigned long \*new\_addrs =- krealloc(report\_filterlist.addrs,- new\_size \* sizeof(unsigned long), GFP\_ATOMIC);-- if (new\_addrs == NULL) {- /\* leave filterlist itself untouched \*/- ret = -ENOMEM;- goto out;+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ if (report\_filterlist.used == report\_filterlist.size) {+ /\* Check we pre-allocated enough, and retry if not. \*/+ if (report\_filterlist.used >= new\_size) {+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ kfree(new\_addrs); /\* kfree(NULL) is safe \*/+ delay\_free = new\_addrs = NULL;+ goto retry\_alloc; } + if (report\_filterlist.used)+ memcpy(new\_addrs, report\_filterlist.addrs, report\_filterlist.used \* sizeof(unsigned long));+ delay\_free = report\_filterlist.addrs; /\* free the old list \*/+ report\_filterlist.addrs = new\_addrs; /\* switch to the new list \*/ report\_filterlist.size = new\_size;- report\_filterlist.addrs = new\_addrs; }  /\* Note: deduplicating should be done in userspace. \*/@@ -185,9 +183,9 @@ static ssize\_t insert\_report\_filterlist(const char \*func) kallsyms\_lookup\_name(func); report\_filterlist.sorted = false; -out:- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); + kfree(delay\_free); return ret; } @@ -204,13 +202,13 @@ static int show\_info(struct seq\_file \*file, void \*v) }  /\* show filter functions, and filter type \*/- spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); seq\_printf(file, "\n%s functions: %s\n", report\_filterlist.whitelist ? "whitelisted" : "blacklisted", report\_filterlist.used == 0 ? "none" : ""); for (i = 0; i < report\_filterlist.used; ++i) seq\_printf(file, " %ps\n", (void \*)report\_filterlist.addrs[i]);- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);  return 0; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 18:11:48 +0000



=== Content from git.kernel.org_1fe37964_20250114_181310.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=0ab4951c1473c7d1ceaf1232eb927109cd1c4859)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0ab4951c1473c7d1ceaf1232eb927109cd1c4859)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0ab4951c1473c7d1ceaf1232eb927109cd1c4859)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0ab4951c1473c7d1ceaf1232eb927109cd1c4859)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Marco Elver <elver@google.com> | 2024-10-01 16:00:45 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-14 19:54:38 +0100 |
| commit | [0ab4951c1473c7d1ceaf1232eb927109cd1c4859](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0ab4951c1473c7d1ceaf1232eb927109cd1c4859) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=0ab4951c1473c7d1ceaf1232eb927109cd1c4859)) | |
| tree | [b2c4b705e7e40b432f2f9a663e23570e7273bd6a](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0ab4951c1473c7d1ceaf1232eb927109cd1c4859) | |
| parent | [2c0027dc17dd1720e9358e5d29569ca3e309e5c8](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2c0027dc17dd1720e9358e5d29569ca3e309e5c8) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0ab4951c1473c7d1ceaf1232eb927109cd1c4859&id2=2c0027dc17dd1720e9358e5d29569ca3e309e5c8)) | |
| download | [linux-0ab4951c1473c7d1ceaf1232eb927109cd1c4859.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-0ab4951c1473c7d1ceaf1232eb927109cd1c4859.tar.gz) | |

kcsan: Turn report\_filterlist\_lock into a raw\_spinlock[ Upstream commit 59458fa4ddb47e7891c61b4a928d13d5f5b00aa0 ]
Ran Xiaokai reports that with a KCSAN-enabled PREEMPT\_RT kernel, we can see
splats like:
| BUG: sleeping function called from invalid context at kernel/locking/spinlock\_rt.c:48
| in\_atomic(): 1, irqs\_disabled(): 1, non\_block: 0, pid: 0, name: swapper/1
| preempt\_count: 10002, expected: 0
| RCU nest depth: 0, expected: 0
| no locks held by swapper/1/0.
| irq event stamp: 156674
| hardirqs last enabled at (156673): [<ffffffff81130bd9>] do\_idle+0x1f9/0x240
| hardirqs last disabled at (156674): [<ffffffff82254f84>] sysvec\_apic\_timer\_interrupt+0x14/0xc0
| softirqs last enabled at (0): [<ffffffff81099f47>] copy\_process+0xfc7/0x4b60
| softirqs last disabled at (0): [<0000000000000000>] 0x0
| Preemption disabled at:
| [<ffffffff814a3e2a>] paint\_ptr+0x2a/0x90
| CPU: 1 UID: 0 PID: 0 Comm: swapper/1 Not tainted 6.11.0+ #3
| Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-0-ga698c8995f-prebuilt.qemu.org 04/01/2014
| Call Trace:
| <IRQ>
| dump\_stack\_lvl+0x7e/0xc0
| dump\_stack+0x1d/0x30
| \_\_might\_resched+0x1a2/0x270
| rt\_spin\_lock+0x68/0x170
| kcsan\_skip\_report\_debugfs+0x43/0xe0
| print\_report+0xb5/0x590
| kcsan\_report\_known\_origin+0x1b1/0x1d0
| kcsan\_setup\_watchpoint+0x348/0x650
| \_\_tsan\_unaligned\_write1+0x16d/0x1d0
| hrtimer\_interrupt+0x3d6/0x430
| \_\_sysvec\_apic\_timer\_interrupt+0xe8/0x3a0
| sysvec\_apic\_timer\_interrupt+0x97/0xc0
| </IRQ>
On a detected data race, KCSAN's reporting logic checks if it should
filter the report. That list is protected by the report\_filterlist\_lock
\*non-raw\* spinlock which may sleep on RT kernels.
Since KCSAN may report data races in any context, convert it to a
raw\_spinlock.
This requires being careful about when to allocate memory for the filter
list itself which can be done via KCSAN's debugfs interface. Concurrent
modification of the filter list via debugfs should be rare: the chosen
strategy is to optimistically pre-allocate memory before the critical
section and discard if unused.
Link: [https://lore.kernel.org/all/20240925143154.2322926-1-ranxiaokai627@163.com/](https://lore.kernel.org/all/20240925143154.2322926-1-ranxiaokai627%40163.com/)
Reported-by: Ran Xiaokai <ran.xiaokai@zte.com.cn>
Tested-by: Ran Xiaokai <ran.xiaokai@zte.com.cn>
Signed-off-by: Marco Elver <elver@google.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0ab4951c1473c7d1ceaf1232eb927109cd1c4859)

| -rw-r--r-- | [kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/kcsan/debugfs.c?id=0ab4951c1473c7d1ceaf1232eb927109cd1c4859) | 74 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 36 insertions, 38 deletions

| diff --git a/kernel/kcsan/debugfs.c b/kernel/kcsan/debugfs.cindex 1d1d1b0e424897..f4623910fb1f23 100644--- a/[kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/kcsan/debugfs.c?id=2c0027dc17dd1720e9358e5d29569ca3e309e5c8)+++ b/[kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/kcsan/debugfs.c?id=0ab4951c1473c7d1ceaf1232eb927109cd1c4859)@@ -46,14 +46,8 @@ static struct { int used; /\* number of elements used \*/ bool sorted; /\* if elements are sorted \*/ bool whitelist; /\* if list is a blacklist or whitelist \*/-} report\_filterlist = {- .addrs = NULL,- .size = 8, /\* small initial size \*/- .used = 0,- .sorted = false,- .whitelist = false, /\* default is blacklist \*/-};-static DEFINE\_SPINLOCK(report\_filterlist\_lock);+} report\_filterlist;+static DEFINE\_RAW\_SPINLOCK(report\_filterlist\_lock);  /\* \* The microbenchmark allows benchmarking KCSAN core runtime only. To run@@ -110,7 +104,7 @@ bool kcsan\_skip\_report\_debugfs(unsigned long func\_addr) return false; func\_addr -= offset; /\* Get function start \*/ - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); if (report\_filterlist.used == 0) goto out; @@ -127,7 +121,7 @@ bool kcsan\_skip\_report\_debugfs(unsigned long func\_addr) ret = !ret;  out:- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); return ret; } @@ -135,9 +129,9 @@ static void set\_report\_filterlist\_whitelist(bool whitelist) { unsigned long flags; - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); report\_filterlist.whitelist = whitelist;- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); }  /\* Returns 0 on success, error-code otherwise. \*/@@ -145,6 +139,9 @@ static ssize\_t insert\_report\_filterlist(const char \*func) { unsigned long flags; unsigned long addr = kallsyms\_lookup\_name(func);+ unsigned long \*delay\_free = NULL;+ unsigned long \*new\_addrs = NULL;+ size\_t new\_size = 0; ssize\_t ret = 0;  if (!addr) {@@ -152,32 +149,33 @@ static ssize\_t insert\_report\_filterlist(const char \*func) return -ENOENT; } - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+retry\_alloc:+ /\*+ \* Check if we need an allocation, and re-validate under the lock. Since+ \* the report\_filterlist\_lock is a raw, cannot allocate under the lock.+ \*/+ if (data\_race(report\_filterlist.used == report\_filterlist.size)) {+ new\_size = (report\_filterlist.size ?: 4) \* 2;+ delay\_free = new\_addrs = kmalloc\_array(new\_size, sizeof(unsigned long), GFP\_KERNEL);+ if (!new\_addrs)+ return -ENOMEM;+ } - if (report\_filterlist.addrs == NULL) {- /\* initial allocation \*/- report\_filterlist.addrs =- kmalloc\_array(report\_filterlist.size,- sizeof(unsigned long), GFP\_ATOMIC);- if (report\_filterlist.addrs == NULL) {- ret = -ENOMEM;- goto out;- }- } else if (report\_filterlist.used == report\_filterlist.size) {- /\* resize filterlist \*/- size\_t new\_size = report\_filterlist.size \* 2;- unsigned long \*new\_addrs =- krealloc(report\_filterlist.addrs,- new\_size \* sizeof(unsigned long), GFP\_ATOMIC);-- if (new\_addrs == NULL) {- /\* leave filterlist itself untouched \*/- ret = -ENOMEM;- goto out;+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ if (report\_filterlist.used == report\_filterlist.size) {+ /\* Check we pre-allocated enough, and retry if not. \*/+ if (report\_filterlist.used >= new\_size) {+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ kfree(new\_addrs); /\* kfree(NULL) is safe \*/+ delay\_free = new\_addrs = NULL;+ goto retry\_alloc; } + if (report\_filterlist.used)+ memcpy(new\_addrs, report\_filterlist.addrs, report\_filterlist.used \* sizeof(unsigned long));+ delay\_free = report\_filterlist.addrs; /\* free the old list \*/+ report\_filterlist.addrs = new\_addrs; /\* switch to the new list \*/ report\_filterlist.size = new\_size;- report\_filterlist.addrs = new\_addrs; }  /\* Note: deduplicating should be done in userspace. \*/@@ -185,9 +183,9 @@ static ssize\_t insert\_report\_filterlist(const char \*func) kallsyms\_lookup\_name(func); report\_filterlist.sorted = false; -out:- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); + kfree(delay\_free); return ret; } @@ -204,13 +202,13 @@ static int show\_info(struct seq\_file \*file, void \*v) }  /\* show filter functions, and filter type \*/- spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); seq\_printf(file, "\n%s functions: %s\n", report\_filterlist.whitelist ? "whitelisted" : "blacklisted", report\_filterlist.used == 0 ? "none" : ""); for (i = 0; i < report\_filterlist.used; ++i) seq\_printf(file, " %ps\n", (void \*)report\_filterlist.addrs[i]);- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);  return 0; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 18:11:48 +0000



=== Content from git.kernel.org_e35edc70_20250114_181311.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=889a0d3a35fdedba1c5dcb6410c95c32421680ec)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=889a0d3a35fdedba1c5dcb6410c95c32421680ec)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=889a0d3a35fdedba1c5dcb6410c95c32421680ec)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=889a0d3a35fdedba1c5dcb6410c95c32421680ec)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Marco Elver <elver@google.com> | 2024-10-01 16:00:45 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-14 20:03:37 +0100 |
| commit | [889a0d3a35fdedba1c5dcb6410c95c32421680ec](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=889a0d3a35fdedba1c5dcb6410c95c32421680ec) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=889a0d3a35fdedba1c5dcb6410c95c32421680ec)) | |
| tree | [45529914da51b1b46b2e274346b1ee7fb4aa5150](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=889a0d3a35fdedba1c5dcb6410c95c32421680ec) | |
| parent | [c82bb825f9fce236ebf0516912dc9961c520a6e3](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c82bb825f9fce236ebf0516912dc9961c520a6e3) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=889a0d3a35fdedba1c5dcb6410c95c32421680ec&id2=c82bb825f9fce236ebf0516912dc9961c520a6e3)) | |
| download | [linux-889a0d3a35fdedba1c5dcb6410c95c32421680ec.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-889a0d3a35fdedba1c5dcb6410c95c32421680ec.tar.gz) | |

kcsan: Turn report\_filterlist\_lock into a raw\_spinlock[ Upstream commit 59458fa4ddb47e7891c61b4a928d13d5f5b00aa0 ]
Ran Xiaokai reports that with a KCSAN-enabled PREEMPT\_RT kernel, we can see
splats like:
| BUG: sleeping function called from invalid context at kernel/locking/spinlock\_rt.c:48
| in\_atomic(): 1, irqs\_disabled(): 1, non\_block: 0, pid: 0, name: swapper/1
| preempt\_count: 10002, expected: 0
| RCU nest depth: 0, expected: 0
| no locks held by swapper/1/0.
| irq event stamp: 156674
| hardirqs last enabled at (156673): [<ffffffff81130bd9>] do\_idle+0x1f9/0x240
| hardirqs last disabled at (156674): [<ffffffff82254f84>] sysvec\_apic\_timer\_interrupt+0x14/0xc0
| softirqs last enabled at (0): [<ffffffff81099f47>] copy\_process+0xfc7/0x4b60
| softirqs last disabled at (0): [<0000000000000000>] 0x0
| Preemption disabled at:
| [<ffffffff814a3e2a>] paint\_ptr+0x2a/0x90
| CPU: 1 UID: 0 PID: 0 Comm: swapper/1 Not tainted 6.11.0+ #3
| Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-0-ga698c8995f-prebuilt.qemu.org 04/01/2014
| Call Trace:
| <IRQ>
| dump\_stack\_lvl+0x7e/0xc0
| dump\_stack+0x1d/0x30
| \_\_might\_resched+0x1a2/0x270
| rt\_spin\_lock+0x68/0x170
| kcsan\_skip\_report\_debugfs+0x43/0xe0
| print\_report+0xb5/0x590
| kcsan\_report\_known\_origin+0x1b1/0x1d0
| kcsan\_setup\_watchpoint+0x348/0x650
| \_\_tsan\_unaligned\_write1+0x16d/0x1d0
| hrtimer\_interrupt+0x3d6/0x430
| \_\_sysvec\_apic\_timer\_interrupt+0xe8/0x3a0
| sysvec\_apic\_timer\_interrupt+0x97/0xc0
| </IRQ>
On a detected data race, KCSAN's reporting logic checks if it should
filter the report. That list is protected by the report\_filterlist\_lock
\*non-raw\* spinlock which may sleep on RT kernels.
Since KCSAN may report data races in any context, convert it to a
raw\_spinlock.
This requires being careful about when to allocate memory for the filter
list itself which can be done via KCSAN's debugfs interface. Concurrent
modification of the filter list via debugfs should be rare: the chosen
strategy is to optimistically pre-allocate memory before the critical
section and discard if unused.
Link: [https://lore.kernel.org/all/20240925143154.2322926-1-ranxiaokai627@163.com/](https://lore.kernel.org/all/20240925143154.2322926-1-ranxiaokai627%40163.com/)
Reported-by: Ran Xiaokai <ran.xiaokai@zte.com.cn>
Tested-by: Ran Xiaokai <ran.xiaokai@zte.com.cn>
Signed-off-by: Marco Elver <elver@google.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=889a0d3a35fdedba1c5dcb6410c95c32421680ec)

| -rw-r--r-- | [kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/kcsan/debugfs.c?id=889a0d3a35fdedba1c5dcb6410c95c32421680ec) | 74 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 36 insertions, 38 deletions

| diff --git a/kernel/kcsan/debugfs.c b/kernel/kcsan/debugfs.cindex 53b21ae30e00ee..b14072071889fb 100644--- a/[kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/kcsan/debugfs.c?id=c82bb825f9fce236ebf0516912dc9961c520a6e3)+++ b/[kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/kcsan/debugfs.c?id=889a0d3a35fdedba1c5dcb6410c95c32421680ec)@@ -46,14 +46,8 @@ static struct { int used; /\* number of elements used \*/ bool sorted; /\* if elements are sorted \*/ bool whitelist; /\* if list is a blacklist or whitelist \*/-} report\_filterlist = {- .addrs = NULL,- .size = 8, /\* small initial size \*/- .used = 0,- .sorted = false,- .whitelist = false, /\* default is blacklist \*/-};-static DEFINE\_SPINLOCK(report\_filterlist\_lock);+} report\_filterlist;+static DEFINE\_RAW\_SPINLOCK(report\_filterlist\_lock);  /\* \* The microbenchmark allows benchmarking KCSAN core runtime only. To run@@ -110,7 +104,7 @@ bool kcsan\_skip\_report\_debugfs(unsigned long func\_addr) return false; func\_addr -= offset; /\* Get function start \*/ - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); if (report\_filterlist.used == 0) goto out; @@ -127,7 +121,7 @@ bool kcsan\_skip\_report\_debugfs(unsigned long func\_addr) ret = !ret;  out:- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); return ret; } @@ -135,9 +129,9 @@ static void set\_report\_filterlist\_whitelist(bool whitelist) { unsigned long flags; - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); report\_filterlist.whitelist = whitelist;- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); }  /\* Returns 0 on success, error-code otherwise. \*/@@ -145,6 +139,9 @@ static ssize\_t insert\_report\_filterlist(const char \*func) { unsigned long flags; unsigned long addr = kallsyms\_lookup\_name(func);+ unsigned long \*delay\_free = NULL;+ unsigned long \*new\_addrs = NULL;+ size\_t new\_size = 0; ssize\_t ret = 0;  if (!addr) {@@ -152,32 +149,33 @@ static ssize\_t insert\_report\_filterlist(const char \*func) return -ENOENT; } - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+retry\_alloc:+ /\*+ \* Check if we need an allocation, and re-validate under the lock. Since+ \* the report\_filterlist\_lock is a raw, cannot allocate under the lock.+ \*/+ if (data\_race(report\_filterlist.used == report\_filterlist.size)) {+ new\_size = (report\_filterlist.size ?: 4) \* 2;+ delay\_free = new\_addrs = kmalloc\_array(new\_size, sizeof(unsigned long), GFP\_KERNEL);+ if (!new\_addrs)+ return -ENOMEM;+ } - if (report\_filterlist.addrs == NULL) {- /\* initial allocation \*/- report\_filterlist.addrs =- kmalloc\_array(report\_filterlist.size,- sizeof(unsigned long), GFP\_ATOMIC);- if (report\_filterlist.addrs == NULL) {- ret = -ENOMEM;- goto out;- }- } else if (report\_filterlist.used == report\_filterlist.size) {- /\* resize filterlist \*/- size\_t new\_size = report\_filterlist.size \* 2;- unsigned long \*new\_addrs =- krealloc(report\_filterlist.addrs,- new\_size \* sizeof(unsigned long), GFP\_ATOMIC);-- if (new\_addrs == NULL) {- /\* leave filterlist itself untouched \*/- ret = -ENOMEM;- goto out;+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ if (report\_filterlist.used == report\_filterlist.size) {+ /\* Check we pre-allocated enough, and retry if not. \*/+ if (report\_filterlist.used >= new\_size) {+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ kfree(new\_addrs); /\* kfree(NULL) is safe \*/+ delay\_free = new\_addrs = NULL;+ goto retry\_alloc; } + if (report\_filterlist.used)+ memcpy(new\_addrs, report\_filterlist.addrs, report\_filterlist.used \* sizeof(unsigned long));+ delay\_free = report\_filterlist.addrs; /\* free the old list \*/+ report\_filterlist.addrs = new\_addrs; /\* switch to the new list \*/ report\_filterlist.size = new\_size;- report\_filterlist.addrs = new\_addrs; }  /\* Note: deduplicating should be done in userspace. \*/@@ -185,9 +183,9 @@ static ssize\_t insert\_report\_filterlist(const char \*func) kallsyms\_lookup\_name(func); report\_filterlist.sorted = false; -out:- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); + kfree(delay\_free); return ret; } @@ -204,13 +202,13 @@ static int show\_info(struct seq\_file \*file, void \*v) }  /\* show filter functions, and filter type \*/- spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); seq\_printf(file, "\n%s functions: %s\n", report\_filterlist.whitelist ? "whitelisted" : "blacklisted", report\_filterlist.used == 0 ? "none" : ""); for (i = 0; i < report\_filterlist.used; ++i) seq\_printf(file, " %ps\n", (void \*)report\_filterlist.addrs[i]);- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);  return 0; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 18:11:48 +0000



=== Content from git.kernel.org_c0588bd6_20250114_181313.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f4f2ef66d288ea796ddb8ecbdc2df074ab2d5f4d)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f4f2ef66d288ea796ddb8ecbdc2df074ab2d5f4d)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f4f2ef66d288ea796ddb8ecbdc2df074ab2d5f4d)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f4f2ef66d288ea796ddb8ecbdc2df074ab2d5f4d)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Marco Elver <elver@google.com> | 2024-10-01 16:00:45 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-14 19:48:25 +0100 |
| commit | [f4f2ef66d288ea796ddb8ecbdc2df074ab2d5f4d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f4f2ef66d288ea796ddb8ecbdc2df074ab2d5f4d) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f4f2ef66d288ea796ddb8ecbdc2df074ab2d5f4d)) | |
| tree | [545a5d17d0cfe9ece1c31a430946ac06cb6ab353](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f4f2ef66d288ea796ddb8ecbdc2df074ab2d5f4d) | |
| parent | [34cd4ec08b89a1be55c40e31086e0175ce086098](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=34cd4ec08b89a1be55c40e31086e0175ce086098) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f4f2ef66d288ea796ddb8ecbdc2df074ab2d5f4d&id2=34cd4ec08b89a1be55c40e31086e0175ce086098)) | |
| download | [linux-f4f2ef66d288ea796ddb8ecbdc2df074ab2d5f4d.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f4f2ef66d288ea796ddb8ecbdc2df074ab2d5f4d.tar.gz) | |

kcsan: Turn report\_filterlist\_lock into a raw\_spinlock[ Upstream commit 59458fa4ddb47e7891c61b4a928d13d5f5b00aa0 ]
Ran Xiaokai reports that with a KCSAN-enabled PREEMPT\_RT kernel, we can see
splats like:
| BUG: sleeping function called from invalid context at kernel/locking/spinlock\_rt.c:48
| in\_atomic(): 1, irqs\_disabled(): 1, non\_block: 0, pid: 0, name: swapper/1
| preempt\_count: 10002, expected: 0
| RCU nest depth: 0, expected: 0
| no locks held by swapper/1/0.
| irq event stamp: 156674
| hardirqs last enabled at (156673): [<ffffffff81130bd9>] do\_idle+0x1f9/0x240
| hardirqs last disabled at (156674): [<ffffffff82254f84>] sysvec\_apic\_timer\_interrupt+0x14/0xc0
| softirqs last enabled at (0): [<ffffffff81099f47>] copy\_process+0xfc7/0x4b60
| softirqs last disabled at (0): [<0000000000000000>] 0x0
| Preemption disabled at:
| [<ffffffff814a3e2a>] paint\_ptr+0x2a/0x90
| CPU: 1 UID: 0 PID: 0 Comm: swapper/1 Not tainted 6.11.0+ #3
| Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-0-ga698c8995f-prebuilt.qemu.org 04/01/2014
| Call Trace:
| <IRQ>
| dump\_stack\_lvl+0x7e/0xc0
| dump\_stack+0x1d/0x30
| \_\_might\_resched+0x1a2/0x270
| rt\_spin\_lock+0x68/0x170
| kcsan\_skip\_report\_debugfs+0x43/0xe0
| print\_report+0xb5/0x590
| kcsan\_report\_known\_origin+0x1b1/0x1d0
| kcsan\_setup\_watchpoint+0x348/0x650
| \_\_tsan\_unaligned\_write1+0x16d/0x1d0
| hrtimer\_interrupt+0x3d6/0x430
| \_\_sysvec\_apic\_timer\_interrupt+0xe8/0x3a0
| sysvec\_apic\_timer\_interrupt+0x97/0xc0
| </IRQ>
On a detected data race, KCSAN's reporting logic checks if it should
filter the report. That list is protected by the report\_filterlist\_lock
\*non-raw\* spinlock which may sleep on RT kernels.
Since KCSAN may report data races in any context, convert it to a
raw\_spinlock.
This requires being careful about when to allocate memory for the filter
list itself which can be done via KCSAN's debugfs interface. Concurrent
modification of the filter list via debugfs should be rare: the chosen
strategy is to optimistically pre-allocate memory before the critical
section and discard if unused.
Link: [https://lore.kernel.org/all/20240925143154.2322926-1-ranxiaokai627@163.com/](https://lore.kernel.org/all/20240925143154.2322926-1-ranxiaokai627%40163.com/)
Reported-by: Ran Xiaokai <ran.xiaokai@zte.com.cn>
Tested-by: Ran Xiaokai <ran.xiaokai@zte.com.cn>
Signed-off-by: Marco Elver <elver@google.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f4f2ef66d288ea796ddb8ecbdc2df074ab2d5f4d)

| -rw-r--r-- | [kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/kcsan/debugfs.c?id=f4f2ef66d288ea796ddb8ecbdc2df074ab2d5f4d) | 74 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 36 insertions, 38 deletions

| diff --git a/kernel/kcsan/debugfs.c b/kernel/kcsan/debugfs.cindex 62a52be8f6ba94..6a4ecd1a6fa5b1 100644--- a/[kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/kcsan/debugfs.c?id=34cd4ec08b89a1be55c40e31086e0175ce086098)+++ b/[kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/kcsan/debugfs.c?id=f4f2ef66d288ea796ddb8ecbdc2df074ab2d5f4d)@@ -41,14 +41,8 @@ static struct { int used; /\* number of elements used \*/ bool sorted; /\* if elements are sorted \*/ bool whitelist; /\* if list is a blacklist or whitelist \*/-} report\_filterlist = {- .addrs = NULL,- .size = 8, /\* small initial size \*/- .used = 0,- .sorted = false,- .whitelist = false, /\* default is blacklist \*/-};-static DEFINE\_SPINLOCK(report\_filterlist\_lock);+} report\_filterlist;+static DEFINE\_RAW\_SPINLOCK(report\_filterlist\_lock);  /\* \* The microbenchmark allows benchmarking KCSAN core runtime only. To run@@ -105,7 +99,7 @@ bool kcsan\_skip\_report\_debugfs(unsigned long func\_addr) return false; func\_addr -= offset; /\* Get function start \*/ - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); if (report\_filterlist.used == 0) goto out; @@ -122,7 +116,7 @@ bool kcsan\_skip\_report\_debugfs(unsigned long func\_addr) ret = !ret;  out:- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); return ret; } @@ -130,9 +124,9 @@ static void set\_report\_filterlist\_whitelist(bool whitelist) { unsigned long flags; - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); report\_filterlist.whitelist = whitelist;- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); }  /\* Returns 0 on success, error-code otherwise. \*/@@ -140,6 +134,9 @@ static ssize\_t insert\_report\_filterlist(const char \*func) { unsigned long flags; unsigned long addr = kallsyms\_lookup\_name(func);+ unsigned long \*delay\_free = NULL;+ unsigned long \*new\_addrs = NULL;+ size\_t new\_size = 0; ssize\_t ret = 0;  if (!addr) {@@ -147,32 +144,33 @@ static ssize\_t insert\_report\_filterlist(const char \*func) return -ENOENT; } - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+retry\_alloc:+ /\*+ \* Check if we need an allocation, and re-validate under the lock. Since+ \* the report\_filterlist\_lock is a raw, cannot allocate under the lock.+ \*/+ if (data\_race(report\_filterlist.used == report\_filterlist.size)) {+ new\_size = (report\_filterlist.size ?: 4) \* 2;+ delay\_free = new\_addrs = kmalloc\_array(new\_size, sizeof(unsigned long), GFP\_KERNEL);+ if (!new\_addrs)+ return -ENOMEM;+ } - if (report\_filterlist.addrs == NULL) {- /\* initial allocation \*/- report\_filterlist.addrs =- kmalloc\_array(report\_filterlist.size,- sizeof(unsigned long), GFP\_ATOMIC);- if (report\_filterlist.addrs == NULL) {- ret = -ENOMEM;- goto out;- }- } else if (report\_filterlist.used == report\_filterlist.size) {- /\* resize filterlist \*/- size\_t new\_size = report\_filterlist.size \* 2;- unsigned long \*new\_addrs =- krealloc(report\_filterlist.addrs,- new\_size \* sizeof(unsigned long), GFP\_ATOMIC);-- if (new\_addrs == NULL) {- /\* leave filterlist itself untouched \*/- ret = -ENOMEM;- goto out;+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ if (report\_filterlist.used == report\_filterlist.size) {+ /\* Check we pre-allocated enough, and retry if not. \*/+ if (report\_filterlist.used >= new\_size) {+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ kfree(new\_addrs); /\* kfree(NULL) is safe \*/+ delay\_free = new\_addrs = NULL;+ goto retry\_alloc; } + if (report\_filterlist.used)+ memcpy(new\_addrs, report\_filterlist.addrs, report\_filterlist.used \* sizeof(unsigned long));+ delay\_free = report\_filterlist.addrs; /\* free the old list \*/+ report\_filterlist.addrs = new\_addrs; /\* switch to the new list \*/ report\_filterlist.size = new\_size;- report\_filterlist.addrs = new\_addrs; }  /\* Note: deduplicating should be done in userspace. \*/@@ -180,9 +178,9 @@ static ssize\_t insert\_report\_filterlist(const char \*func) kallsyms\_lookup\_name(func); report\_filterlist.sorted = false; -out:- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); + kfree(delay\_free); return ret; } @@ -199,13 +197,13 @@ static int show\_info(struct seq\_file \*file, void \*v) }  /\* show filter functions, and filter type \*/- spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); seq\_printf(file, "\n%s functions: %s\n", report\_filterlist.whitelist ? "whitelisted" : "blacklisted", report\_filterlist.used == 0 ? "none" : ""); for (i = 0; i < report\_filterlist.used; ++i) seq\_printf(file, " %ps\n", (void \*)report\_filterlist.addrs[i]);- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);  return 0; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 18:11:50 +0000



=== Content from git.kernel.org_617b50af_20250114_181312.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=dca4e74a918586913d251c0b359e8cc96a3883ea)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=dca4e74a918586913d251c0b359e8cc96a3883ea)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=dca4e74a918586913d251c0b359e8cc96a3883ea)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=dca4e74a918586913d251c0b359e8cc96a3883ea)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Marco Elver <elver@google.com> | 2024-10-01 16:00:45 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-14 19:59:59 +0100 |
| commit | [dca4e74a918586913d251c0b359e8cc96a3883ea](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=dca4e74a918586913d251c0b359e8cc96a3883ea) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=dca4e74a918586913d251c0b359e8cc96a3883ea)) | |
| tree | [c420060ac2153d7da0deb59465fd8d93933b2f22](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=dca4e74a918586913d251c0b359e8cc96a3883ea) | |
| parent | [e8483ae1310049a9d132e7397a2429326f08eebe](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e8483ae1310049a9d132e7397a2429326f08eebe) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=dca4e74a918586913d251c0b359e8cc96a3883ea&id2=e8483ae1310049a9d132e7397a2429326f08eebe)) | |
| download | [linux-dca4e74a918586913d251c0b359e8cc96a3883ea.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-dca4e74a918586913d251c0b359e8cc96a3883ea.tar.gz) | |

kcsan: Turn report\_filterlist\_lock into a raw\_spinlock[ Upstream commit 59458fa4ddb47e7891c61b4a928d13d5f5b00aa0 ]
Ran Xiaokai reports that with a KCSAN-enabled PREEMPT\_RT kernel, we can see
splats like:
| BUG: sleeping function called from invalid context at kernel/locking/spinlock\_rt.c:48
| in\_atomic(): 1, irqs\_disabled(): 1, non\_block: 0, pid: 0, name: swapper/1
| preempt\_count: 10002, expected: 0
| RCU nest depth: 0, expected: 0
| no locks held by swapper/1/0.
| irq event stamp: 156674
| hardirqs last enabled at (156673): [<ffffffff81130bd9>] do\_idle+0x1f9/0x240
| hardirqs last disabled at (156674): [<ffffffff82254f84>] sysvec\_apic\_timer\_interrupt+0x14/0xc0
| softirqs last enabled at (0): [<ffffffff81099f47>] copy\_process+0xfc7/0x4b60
| softirqs last disabled at (0): [<0000000000000000>] 0x0
| Preemption disabled at:
| [<ffffffff814a3e2a>] paint\_ptr+0x2a/0x90
| CPU: 1 UID: 0 PID: 0 Comm: swapper/1 Not tainted 6.11.0+ #3
| Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-0-ga698c8995f-prebuilt.qemu.org 04/01/2014
| Call Trace:
| <IRQ>
| dump\_stack\_lvl+0x7e/0xc0
| dump\_stack+0x1d/0x30
| \_\_might\_resched+0x1a2/0x270
| rt\_spin\_lock+0x68/0x170
| kcsan\_skip\_report\_debugfs+0x43/0xe0
| print\_report+0xb5/0x590
| kcsan\_report\_known\_origin+0x1b1/0x1d0
| kcsan\_setup\_watchpoint+0x348/0x650
| \_\_tsan\_unaligned\_write1+0x16d/0x1d0
| hrtimer\_interrupt+0x3d6/0x430
| \_\_sysvec\_apic\_timer\_interrupt+0xe8/0x3a0
| sysvec\_apic\_timer\_interrupt+0x97/0xc0
| </IRQ>
On a detected data race, KCSAN's reporting logic checks if it should
filter the report. That list is protected by the report\_filterlist\_lock
\*non-raw\* spinlock which may sleep on RT kernels.
Since KCSAN may report data races in any context, convert it to a
raw\_spinlock.
This requires being careful about when to allocate memory for the filter
list itself which can be done via KCSAN's debugfs interface. Concurrent
modification of the filter list via debugfs should be rare: the chosen
strategy is to optimistically pre-allocate memory before the critical
section and discard if unused.
Link: [https://lore.kernel.org/all/20240925143154.2322926-1-ranxiaokai627@163.com/](https://lore.kernel.org/all/20240925143154.2322926-1-ranxiaokai627%40163.com/)
Reported-by: Ran Xiaokai <ran.xiaokai@zte.com.cn>
Tested-by: Ran Xiaokai <ran.xiaokai@zte.com.cn>
Signed-off-by: Marco Elver <elver@google.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=dca4e74a918586913d251c0b359e8cc96a3883ea)

| -rw-r--r-- | [kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/kcsan/debugfs.c?id=dca4e74a918586913d251c0b359e8cc96a3883ea) | 74 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 36 insertions, 38 deletions

| diff --git a/kernel/kcsan/debugfs.c b/kernel/kcsan/debugfs.cindex 1d1d1b0e424897..f4623910fb1f23 100644--- a/[kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/kcsan/debugfs.c?id=e8483ae1310049a9d132e7397a2429326f08eebe)+++ b/[kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/kcsan/debugfs.c?id=dca4e74a918586913d251c0b359e8cc96a3883ea)@@ -46,14 +46,8 @@ static struct { int used; /\* number of elements used \*/ bool sorted; /\* if elements are sorted \*/ bool whitelist; /\* if list is a blacklist or whitelist \*/-} report\_filterlist = {- .addrs = NULL,- .size = 8, /\* small initial size \*/- .used = 0,- .sorted = false,- .whitelist = false, /\* default is blacklist \*/-};-static DEFINE\_SPINLOCK(report\_filterlist\_lock);+} report\_filterlist;+static DEFINE\_RAW\_SPINLOCK(report\_filterlist\_lock);  /\* \* The microbenchmark allows benchmarking KCSAN core runtime only. To run@@ -110,7 +104,7 @@ bool kcsan\_skip\_report\_debugfs(unsigned long func\_addr) return false; func\_addr -= offset; /\* Get function start \*/ - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); if (report\_filterlist.used == 0) goto out; @@ -127,7 +121,7 @@ bool kcsan\_skip\_report\_debugfs(unsigned long func\_addr) ret = !ret;  out:- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); return ret; } @@ -135,9 +129,9 @@ static void set\_report\_filterlist\_whitelist(bool whitelist) { unsigned long flags; - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); report\_filterlist.whitelist = whitelist;- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); }  /\* Returns 0 on success, error-code otherwise. \*/@@ -145,6 +139,9 @@ static ssize\_t insert\_report\_filterlist(const char \*func) { unsigned long flags; unsigned long addr = kallsyms\_lookup\_name(func);+ unsigned long \*delay\_free = NULL;+ unsigned long \*new\_addrs = NULL;+ size\_t new\_size = 0; ssize\_t ret = 0;  if (!addr) {@@ -152,32 +149,33 @@ static ssize\_t insert\_report\_filterlist(const char \*func) return -ENOENT; } - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+retry\_alloc:+ /\*+ \* Check if we need an allocation, and re-validate under the lock. Since+ \* the report\_filterlist\_lock is a raw, cannot allocate under the lock.+ \*/+ if (data\_race(report\_filterlist.used == report\_filterlist.size)) {+ new\_size = (report\_filterlist.size ?: 4) \* 2;+ delay\_free = new\_addrs = kmalloc\_array(new\_size, sizeof(unsigned long), GFP\_KERNEL);+ if (!new\_addrs)+ return -ENOMEM;+ } - if (report\_filterlist.addrs == NULL) {- /\* initial allocation \*/- report\_filterlist.addrs =- kmalloc\_array(report\_filterlist.size,- sizeof(unsigned long), GFP\_ATOMIC);- if (report\_filterlist.addrs == NULL) {- ret = -ENOMEM;- goto out;- }- } else if (report\_filterlist.used == report\_filterlist.size) {- /\* resize filterlist \*/- size\_t new\_size = report\_filterlist.size \* 2;- unsigned long \*new\_addrs =- krealloc(report\_filterlist.addrs,- new\_size \* sizeof(unsigned long), GFP\_ATOMIC);-- if (new\_addrs == NULL) {- /\* leave filterlist itself untouched \*/- ret = -ENOMEM;- goto out;+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ if (report\_filterlist.used == report\_filterlist.size) {+ /\* Check we pre-allocated enough, and retry if not. \*/+ if (report\_filterlist.used >= new\_size) {+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ kfree(new\_addrs); /\* kfree(NULL) is safe \*/+ delay\_free = new\_addrs = NULL;+ goto retry\_alloc; } + if (report\_filterlist.used)+ memcpy(new\_addrs, report\_filterlist.addrs, report\_filterlist.used \* sizeof(unsigned long));+ delay\_free = report\_filterlist.addrs; /\* free the old list \*/+ report\_filterlist.addrs = new\_addrs; /\* switch to the new list \*/ report\_filterlist.size = new\_size;- report\_filterlist.addrs = new\_addrs; }  /\* Note: deduplicating should be done in userspace. \*/@@ -185,9 +183,9 @@ static ssize\_t insert\_report\_filterlist(const char \*func) kallsyms\_lookup\_name(func); report\_filterlist.sorted = false; -out:- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); + kfree(delay\_free); return ret; } @@ -204,13 +202,13 @@ static int show\_info(struct seq\_file \*file, void \*v) }  /\* show filter functions, and filter type \*/- spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); seq\_printf(file, "\n%s functions: %s\n", report\_filterlist.whitelist ? "whitelisted" : "blacklisted", report\_filterlist.used == 0 ? "none" : ""); for (i = 0; i < report\_filterlist.used; ++i) seq\_printf(file, " %ps\n", (void \*)report\_filterlist.addrs[i]);- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);  return 0; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 18:11:49 +0000



=== Content from git.kernel.org_47356536_20250114_181312.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=ea6588abcc15d68fdeae777ffe3dd74c02eab407)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ea6588abcc15d68fdeae777ffe3dd74c02eab407)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ea6588abcc15d68fdeae777ffe3dd74c02eab407)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ea6588abcc15d68fdeae777ffe3dd74c02eab407)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Marco Elver <elver@google.com> | 2024-10-01 16:00:45 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-14 19:51:35 +0100 |
| commit | [ea6588abcc15d68fdeae777ffe3dd74c02eab407](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ea6588abcc15d68fdeae777ffe3dd74c02eab407) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=ea6588abcc15d68fdeae777ffe3dd74c02eab407)) | |
| tree | [d1489c1f2e251ad104ff6276403f5fb6e436efb7](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ea6588abcc15d68fdeae777ffe3dd74c02eab407) | |
| parent | [86680f33461a98f963777c839772dd1a97127842](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=86680f33461a98f963777c839772dd1a97127842) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ea6588abcc15d68fdeae777ffe3dd74c02eab407&id2=86680f33461a98f963777c839772dd1a97127842)) | |
| download | [linux-ea6588abcc15d68fdeae777ffe3dd74c02eab407.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-ea6588abcc15d68fdeae777ffe3dd74c02eab407.tar.gz) | |

kcsan: Turn report\_filterlist\_lock into a raw\_spinlock[ Upstream commit 59458fa4ddb47e7891c61b4a928d13d5f5b00aa0 ]
Ran Xiaokai reports that with a KCSAN-enabled PREEMPT\_RT kernel, we can see
splats like:
| BUG: sleeping function called from invalid context at kernel/locking/spinlock\_rt.c:48
| in\_atomic(): 1, irqs\_disabled(): 1, non\_block: 0, pid: 0, name: swapper/1
| preempt\_count: 10002, expected: 0
| RCU nest depth: 0, expected: 0
| no locks held by swapper/1/0.
| irq event stamp: 156674
| hardirqs last enabled at (156673): [<ffffffff81130bd9>] do\_idle+0x1f9/0x240
| hardirqs last disabled at (156674): [<ffffffff82254f84>] sysvec\_apic\_timer\_interrupt+0x14/0xc0
| softirqs last enabled at (0): [<ffffffff81099f47>] copy\_process+0xfc7/0x4b60
| softirqs last disabled at (0): [<0000000000000000>] 0x0
| Preemption disabled at:
| [<ffffffff814a3e2a>] paint\_ptr+0x2a/0x90
| CPU: 1 UID: 0 PID: 0 Comm: swapper/1 Not tainted 6.11.0+ #3
| Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-0-ga698c8995f-prebuilt.qemu.org 04/01/2014
| Call Trace:
| <IRQ>
| dump\_stack\_lvl+0x7e/0xc0
| dump\_stack+0x1d/0x30
| \_\_might\_resched+0x1a2/0x270
| rt\_spin\_lock+0x68/0x170
| kcsan\_skip\_report\_debugfs+0x43/0xe0
| print\_report+0xb5/0x590
| kcsan\_report\_known\_origin+0x1b1/0x1d0
| kcsan\_setup\_watchpoint+0x348/0x650
| \_\_tsan\_unaligned\_write1+0x16d/0x1d0
| hrtimer\_interrupt+0x3d6/0x430
| \_\_sysvec\_apic\_timer\_interrupt+0xe8/0x3a0
| sysvec\_apic\_timer\_interrupt+0x97/0xc0
| </IRQ>
On a detected data race, KCSAN's reporting logic checks if it should
filter the report. That list is protected by the report\_filterlist\_lock
\*non-raw\* spinlock which may sleep on RT kernels.
Since KCSAN may report data races in any context, convert it to a
raw\_spinlock.
This requires being careful about when to allocate memory for the filter
list itself which can be done via KCSAN's debugfs interface. Concurrent
modification of the filter list via debugfs should be rare: the chosen
strategy is to optimistically pre-allocate memory before the critical
section and discard if unused.
Link: [https://lore.kernel.org/all/20240925143154.2322926-1-ranxiaokai627@163.com/](https://lore.kernel.org/all/20240925143154.2322926-1-ranxiaokai627%40163.com/)
Reported-by: Ran Xiaokai <ran.xiaokai@zte.com.cn>
Tested-by: Ran Xiaokai <ran.xiaokai@zte.com.cn>
Signed-off-by: Marco Elver <elver@google.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ea6588abcc15d68fdeae777ffe3dd74c02eab407)

| -rw-r--r-- | [kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/kcsan/debugfs.c?id=ea6588abcc15d68fdeae777ffe3dd74c02eab407) | 74 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 36 insertions, 38 deletions

| diff --git a/kernel/kcsan/debugfs.c b/kernel/kcsan/debugfs.cindex 1d1d1b0e424897..f4623910fb1f23 100644--- a/[kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/kcsan/debugfs.c?id=86680f33461a98f963777c839772dd1a97127842)+++ b/[kernel/kcsan/debugfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/kcsan/debugfs.c?id=ea6588abcc15d68fdeae777ffe3dd74c02eab407)@@ -46,14 +46,8 @@ static struct { int used; /\* number of elements used \*/ bool sorted; /\* if elements are sorted \*/ bool whitelist; /\* if list is a blacklist or whitelist \*/-} report\_filterlist = {- .addrs = NULL,- .size = 8, /\* small initial size \*/- .used = 0,- .sorted = false,- .whitelist = false, /\* default is blacklist \*/-};-static DEFINE\_SPINLOCK(report\_filterlist\_lock);+} report\_filterlist;+static DEFINE\_RAW\_SPINLOCK(report\_filterlist\_lock);  /\* \* The microbenchmark allows benchmarking KCSAN core runtime only. To run@@ -110,7 +104,7 @@ bool kcsan\_skip\_report\_debugfs(unsigned long func\_addr) return false; func\_addr -= offset; /\* Get function start \*/ - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); if (report\_filterlist.used == 0) goto out; @@ -127,7 +121,7 @@ bool kcsan\_skip\_report\_debugfs(unsigned long func\_addr) ret = !ret;  out:- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); return ret; } @@ -135,9 +129,9 @@ static void set\_report\_filterlist\_whitelist(bool whitelist) { unsigned long flags; - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); report\_filterlist.whitelist = whitelist;- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); }  /\* Returns 0 on success, error-code otherwise. \*/@@ -145,6 +139,9 @@ static ssize\_t insert\_report\_filterlist(const char \*func) { unsigned long flags; unsigned long addr = kallsyms\_lookup\_name(func);+ unsigned long \*delay\_free = NULL;+ unsigned long \*new\_addrs = NULL;+ size\_t new\_size = 0; ssize\_t ret = 0;  if (!addr) {@@ -152,32 +149,33 @@ static ssize\_t insert\_report\_filterlist(const char \*func) return -ENOENT; } - spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+retry\_alloc:+ /\*+ \* Check if we need an allocation, and re-validate under the lock. Since+ \* the report\_filterlist\_lock is a raw, cannot allocate under the lock.+ \*/+ if (data\_race(report\_filterlist.used == report\_filterlist.size)) {+ new\_size = (report\_filterlist.size ?: 4) \* 2;+ delay\_free = new\_addrs = kmalloc\_array(new\_size, sizeof(unsigned long), GFP\_KERNEL);+ if (!new\_addrs)+ return -ENOMEM;+ } - if (report\_filterlist.addrs == NULL) {- /\* initial allocation \*/- report\_filterlist.addrs =- kmalloc\_array(report\_filterlist.size,- sizeof(unsigned long), GFP\_ATOMIC);- if (report\_filterlist.addrs == NULL) {- ret = -ENOMEM;- goto out;- }- } else if (report\_filterlist.used == report\_filterlist.size) {- /\* resize filterlist \*/- size\_t new\_size = report\_filterlist.size \* 2;- unsigned long \*new\_addrs =- krealloc(report\_filterlist.addrs,- new\_size \* sizeof(unsigned long), GFP\_ATOMIC);-- if (new\_addrs == NULL) {- /\* leave filterlist itself untouched \*/- ret = -ENOMEM;- goto out;+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ if (report\_filterlist.used == report\_filterlist.size) {+ /\* Check we pre-allocated enough, and retry if not. \*/+ if (report\_filterlist.used >= new\_size) {+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ kfree(new\_addrs); /\* kfree(NULL) is safe \*/+ delay\_free = new\_addrs = NULL;+ goto retry\_alloc; } + if (report\_filterlist.used)+ memcpy(new\_addrs, report\_filterlist.addrs, report\_filterlist.used \* sizeof(unsigned long));+ delay\_free = report\_filterlist.addrs; /\* free the old list \*/+ report\_filterlist.addrs = new\_addrs; /\* switch to the new list \*/ report\_filterlist.size = new\_size;- report\_filterlist.addrs = new\_addrs; }  /\* Note: deduplicating should be done in userspace. \*/@@ -185,9 +183,9 @@ static ssize\_t insert\_report\_filterlist(const char \*func) kallsyms\_lookup\_name(func); report\_filterlist.sorted = false; -out:- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags); + kfree(delay\_free); return ret; } @@ -204,13 +202,13 @@ static int show\_info(struct seq\_file \*file, void \*v) }  /\* show filter functions, and filter type \*/- spin\_lock\_irqsave(&report\_filterlist\_lock, flags);+ raw\_spin\_lock\_irqsave(&report\_filterlist\_lock, flags); seq\_printf(file, "\n%s functions: %s\n", report\_filterlist.whitelist ? "whitelisted" : "blacklisted", report\_filterlist.used == 0 ? "none" : ""); for (i = 0; i < report\_filterlist.used; ++i) seq\_printf(file, " %ps\n", (void \*)report\_filterlist.addrs[i]);- spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);+ raw\_spin\_unlock\_irqrestore(&report\_filterlist\_lock, flags);  return 0; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 18:11:50 +0000


