=== Content from git.kernel.org_8d29dadc_20250114_205912.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=3634d4a310820567fc634bf8f1ee2b91378773e8)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3634d4a310820567fc634bf8f1ee2b91378773e8)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3634d4a310820567fc634bf8f1ee2b91378773e8)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3634d4a310820567fc634bf8f1ee2b91378773e8)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Kumar Kartikeya Dwivedi <memxor@gmail.com> | 2024-11-04 09:19:57 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-05 14:01:52 +0100 |
| commit | [3634d4a310820567fc634bf8f1ee2b91378773e8](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3634d4a310820567fc634bf8f1ee2b91378773e8) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=3634d4a310820567fc634bf8f1ee2b91378773e8)) | |
| tree | [3a58f5ac650edae0f05059911a7726184fa13967](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3634d4a310820567fc634bf8f1ee2b91378773e8) | |
| parent | [6d9f07196389f35a3afebcf1a12c1425725caddd](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6d9f07196389f35a3afebcf1a12c1425725caddd) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3634d4a310820567fc634bf8f1ee2b91378773e8&id2=6d9f07196389f35a3afebcf1a12c1425725caddd)) | |
| download | [linux-3634d4a310820567fc634bf8f1ee2b91378773e8.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-3634d4a310820567fc634bf8f1ee2b91378773e8.tar.gz) | |

bpf: Mark raw\_tp arguments with PTR\_MAYBE\_NULL[ Upstream commit cb4158ce8ec8a5bb528cc1693356a5eb8058094d ]
Arguments to a raw tracepoint are tagged as trusted, which carries the
semantics that the pointer will be non-NULL. However, in certain cases,
a raw tracepoint argument may end up being NULL. More context about this
issue is available in [0].
Thus, there is a discrepancy between the reality, that raw\_tp arguments
can actually be NULL, and the verifier's knowledge, that they are never
NULL, causing explicit NULL checks to be deleted, and accesses to such
pointers potentially crashing the kernel.
To fix this, mark raw\_tp arguments as PTR\_MAYBE\_NULL, and then special
case the dereference and pointer arithmetic to permit it, and allow
passing them into helpers/kfuncs; these exceptions are made for raw\_tp
programs only. Ensure that we don't do this when ref\_obj\_id > 0, as in
that case this is an acquired object and doesn't need such adjustment.
The reason we do mask\_raw\_tp\_trusted\_reg logic is because other will
recheck in places whether the register is a trusted\_reg, and then
consider our register as untrusted when detecting the presence of the
PTR\_MAYBE\_NULL flag.
To allow safe dereference, we enable PROBE\_MEM marking when we see loads
into trusted pointers with PTR\_MAYBE\_NULL.
While trusted raw\_tp arguments can also be passed into helpers or kfuncs
where such broken assumption may cause issues, a future patch set will
tackle their case separately, as PTR\_TO\_BTF\_ID (without PTR\_TRUSTED) can
already be passed into helpers and causes similar problems. Thus, they
are left alone for now.
It is possible that these checks also permit passing non-raw\_tp args
that are trusted PTR\_TO\_BTF\_ID with null marking. In such a case,
allowing dereference when pointer is NULL expands allowed behavior, so
won't regress existing programs, and the case of passing these into
helpers is the same as above and will be dealt with later.
Also update the failure case in tp\_btf\_nullable selftest to capture the
new behavior, as the verifier will no longer cause an error when
directly dereference a raw tracepoint argument marked as \_\_nullable.
[0]: https://lore.kernel.org/bpf/ZrCZS6nisraEqehw@jlelli-thinkpadt14gen4.remote.csb
Reviewed-by: Jiri Olsa <jolsa@kernel.org>
Reported-by: Juri Lelli <juri.lelli@redhat.com>
Tested-by: Juri Lelli <juri.lelli@redhat.com>
Fixes: 3f00c5239344 ("bpf: Allow trusted pointers to be passed to KF\_TRUSTED\_ARGS kfuncs")
Signed-off-by: Kumar Kartikeya Dwivedi <memxor@gmail.com>
Link: [https://lore.kernel.org/r/20241104171959.2938862-2-memxor@gmail.com](https://lore.kernel.org/r/20241104171959.2938862-2-memxor%40gmail.com)
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3634d4a310820567fc634bf8f1ee2b91378773e8)

| -rw-r--r-- | [include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/bpf.h?id=3634d4a310820567fc634bf8f1ee2b91378773e8) | 6 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [kernel/bpf/btf.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/btf.c?id=3634d4a310820567fc634bf8f1ee2b91378773e8) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/verifier.c?id=3634d4a310820567fc634bf8f1ee2b91378773e8) | 79 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/test\_tp\_btf\_nullable.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/test_tp_btf_nullable.c?id=3634d4a310820567fc634bf8f1ee2b91378773e8) | 6 | |  |  |  | | --- | --- | --- | |

4 files changed, 87 insertions, 9 deletions

| diff --git a/include/linux/bpf.h b/include/linux/bpf.hindex bdadb0bb6cecd1..e863b5d06043a8 100644--- a/[include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf.h?id=6d9f07196389f35a3afebcf1a12c1425725caddd)+++ b/[include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf.h?id=3634d4a310820567fc634bf8f1ee2b91378773e8)@@ -3461,4 +3461,10 @@ static inline bool bpf\_is\_subprog(const struct bpf\_prog \*prog) return prog->aux->func\_idx != 0; } +static inline bool bpf\_prog\_is\_raw\_tp(const struct bpf\_prog \*prog)+{+ return prog->type == BPF\_PROG\_TYPE\_TRACING &&+ prog->expected\_attach\_type == BPF\_TRACE\_RAW\_TP;+}+ #endif /\* \_LINUX\_BPF\_H \*/diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.cindex 5cd1c7a23848cc..346826e3c933da 100644--- a/[kernel/bpf/btf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=6d9f07196389f35a3afebcf1a12c1425725caddd)+++ b/[kernel/bpf/btf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=3634d4a310820567fc634bf8f1ee2b91378773e8)@@ -6564,7 +6564,10 @@ bool btf\_ctx\_access(int off, int size, enum bpf\_access\_type type, if (prog\_args\_trusted(prog)) info->reg\_type |= PTR\_TRUSTED; - if (btf\_param\_match\_suffix(btf, &args[arg], "\_\_nullable"))+ /\* Raw tracepoint arguments always get marked as maybe NULL \*/+ if (bpf\_prog\_is\_raw\_tp(prog))+ info->reg\_type |= PTR\_MAYBE\_NULL;+ else if (btf\_param\_match\_suffix(btf, &args[arg], "\_\_nullable")) info->reg\_type |= PTR\_MAYBE\_NULL;  if (tgt\_prog) {diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex 011b4a86e2b3be..71a1877aac6870 100644--- a/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=6d9f07196389f35a3afebcf1a12c1425725caddd)+++ b/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=3634d4a310820567fc634bf8f1ee2b91378773e8)@@ -418,6 +418,25 @@ static struct btf\_record \*reg\_btf\_record(const struct bpf\_reg\_state \*reg) return rec; } +static bool mask\_raw\_tp\_reg\_cond(const struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg) {+ return reg->type == (PTR\_TO\_BTF\_ID | PTR\_TRUSTED | PTR\_MAYBE\_NULL) &&+ bpf\_prog\_is\_raw\_tp(env->prog) && !reg->ref\_obj\_id;+}++static bool mask\_raw\_tp\_reg(const struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg)+{+ if (!mask\_raw\_tp\_reg\_cond(env, reg))+ return false;+ reg->type &= ~PTR\_MAYBE\_NULL;+ return true;+}++static void unmask\_raw\_tp\_reg(struct bpf\_reg\_state \*reg, bool result)+{+ if (result)+ reg->type |= PTR\_MAYBE\_NULL;+}+ static bool subprog\_is\_global(const struct bpf\_verifier\_env \*env, int subprog) { struct bpf\_func\_info\_aux \*aux = env->prog->aux->func\_info\_aux;@@ -6595,6 +6614,7 @@ static int check\_ptr\_to\_btf\_access(struct bpf\_verifier\_env \*env, const char \*field\_name = NULL; enum bpf\_type\_flag flag = 0; u32 btf\_id = 0;+ bool mask; int ret;  if (!env->allow\_ptr\_leaks) {@@ -6666,7 +6686,21 @@ static int check\_ptr\_to\_btf\_access(struct bpf\_verifier\_env \*env,  if (ret < 0) return ret;-+ /\* For raw\_tp progs, we allow dereference of PTR\_MAYBE\_NULL+ \* trusted PTR\_TO\_BTF\_ID, these are the ones that are possibly+ \* arguments to the raw\_tp. Since internal checks in for trusted+ \* reg in check\_ptr\_to\_btf\_access would consider PTR\_MAYBE\_NULL+ \* modifier as problematic, mask it out temporarily for the+ \* check. Don't apply this to pointers with ref\_obj\_id > 0, as+ \* those won't be raw\_tp args.+ \*+ \* We may end up applying this relaxation to other trusted+ \* PTR\_TO\_BTF\_ID with maybe null flag, since we cannot+ \* distinguish PTR\_MAYBE\_NULL tagged for arguments vs normal+ \* tagging, but that should expand allowed behavior, and not+ \* cause regression for existing behavior.+ \*/+ mask = mask\_raw\_tp\_reg(env, reg); if (ret != PTR\_TO\_BTF\_ID) { /\* just mark; \*/ @@ -6727,8 +6761,13 @@ static int check\_ptr\_to\_btf\_access(struct bpf\_verifier\_env \*env, clear\_trusted\_flags(&flag); } - if (atype == BPF\_READ && value\_regno >= 0)+ if (atype == BPF\_READ && value\_regno >= 0) { mark\_btf\_ld\_reg(env, regs, value\_regno, ret, reg->btf, btf\_id, flag);+ /\* We've assigned a new type to regno, so don't undo masking. \*/+ if (regno == value\_regno)+ mask = false;+ }+ unmask\_raw\_tp\_reg(reg, mask);  return 0; }@@ -7103,7 +7142,7 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn if (!err && t == BPF\_READ && value\_regno >= 0) mark\_reg\_unknown(env, regs, value\_regno); } else if (base\_type(reg->type) == PTR\_TO\_BTF\_ID &&- !type\_may\_be\_null(reg->type)) {+ (mask\_raw\_tp\_reg\_cond(env, reg) || !type\_may\_be\_null(reg->type))) { err = check\_ptr\_to\_btf\_access(env, regs, regno, off, size, t, value\_regno); } else if (reg->type == CONST\_PTR\_TO\_MAP) {@@ -8796,6 +8835,7 @@ static int check\_func\_arg(struct bpf\_verifier\_env \*env, u32 arg, enum bpf\_reg\_type type = reg->type; u32 \*arg\_btf\_id = NULL; int err = 0;+ bool mask;  if (arg\_type == ARG\_DONTCARE) return 0;@@ -8836,11 +8876,11 @@ static int check\_func\_arg(struct bpf\_verifier\_env \*env, u32 arg, base\_type(arg\_type) == ARG\_PTR\_TO\_SPIN\_LOCK) arg\_btf\_id = fn->arg\_btf\_id[arg]; + mask = mask\_raw\_tp\_reg(env, reg); err = check\_reg\_type(env, regno, arg\_type, arg\_btf\_id, meta);- if (err)- return err; - err = check\_func\_arg\_reg\_off(env, reg, regno, arg\_type);+ err = err ?: check\_func\_arg\_reg\_off(env, reg, regno, arg\_type);+ unmask\_raw\_tp\_reg(reg, mask); if (err) return err; @@ -9635,14 +9675,17 @@ static int btf\_check\_func\_arg\_match(struct bpf\_verifier\_env \*env, int subprog, return ret; } else if (base\_type(arg->arg\_type) == ARG\_PTR\_TO\_BTF\_ID) { struct bpf\_call\_arg\_meta meta;+ bool mask; int err;  if (register\_is\_null(reg) && type\_may\_be\_null(arg->arg\_type)) continue;  memset(&meta, 0, sizeof(meta)); /\* leave func\_id as zero \*/+ mask = mask\_raw\_tp\_reg(env, reg); err = check\_reg\_type(env, regno, arg->arg\_type, &arg->btf\_id, &meta); err = err ?: check\_func\_arg\_reg\_off(env, reg, regno, arg->arg\_type);+ unmask\_raw\_tp\_reg(reg, mask); if (err) return err; } else {@@ -11957,6 +12000,7 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_ enum bpf\_arg\_type arg\_type = ARG\_DONTCARE; u32 regno = i + 1, ref\_id, type\_size; bool is\_ret\_buf\_sz = false;+ bool mask = false; int kf\_arg\_type;  t = btf\_type\_skip\_modifiers(btf, args[i].type, NULL);@@ -12015,12 +12059,15 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_ return -EINVAL; } + mask = mask\_raw\_tp\_reg(env, reg); if ((is\_kfunc\_trusted\_args(meta) || is\_kfunc\_rcu(meta)) && (register\_is\_null(reg) || type\_may\_be\_null(reg->type)) && !is\_kfunc\_arg\_nullable(meta->btf, &args[i])) { verbose(env, "Possibly NULL pointer passed to trusted arg%d\n", i);+ unmask\_raw\_tp\_reg(reg, mask); return -EACCES; }+ unmask\_raw\_tp\_reg(reg, mask);  if (reg->ref\_obj\_id) { if (is\_kfunc\_release(meta) && meta->ref\_obj\_id) {@@ -12078,16 +12125,24 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_ if (!is\_kfunc\_trusted\_args(meta) && !is\_kfunc\_rcu(meta)) break; + /\* Allow passing maybe NULL raw\_tp arguments to+ \* kfuncs for compatibility. Don't apply this to+ \* arguments with ref\_obj\_id > 0.+ \*/+ mask = mask\_raw\_tp\_reg(env, reg); if (!is\_trusted\_reg(reg)) { if (!is\_kfunc\_rcu(meta)) { verbose(env, "R%d must be referenced or trusted\n", regno);+ unmask\_raw\_tp\_reg(reg, mask); return -EINVAL; } if (!is\_rcu\_reg(reg)) { verbose(env, "R%d must be a rcu pointer\n", regno);+ unmask\_raw\_tp\_reg(reg, mask); return -EINVAL; } }+ unmask\_raw\_tp\_reg(reg, mask); fallthrough; case KF\_ARG\_PTR\_TO\_CTX: case KF\_ARG\_PTR\_TO\_DYNPTR:@@ -12110,7 +12165,9 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_  if (is\_kfunc\_release(meta) && reg->ref\_obj\_id) arg\_type |= OBJ\_RELEASE;+ mask = mask\_raw\_tp\_reg(env, reg); ret = check\_func\_arg\_reg\_off(env, reg, regno, arg\_type);+ unmask\_raw\_tp\_reg(reg, mask); if (ret < 0) return ret; @@ -12287,6 +12344,7 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_ ref\_tname = btf\_name\_by\_offset(btf, ref\_t->name\_off); fallthrough; case KF\_ARG\_PTR\_TO\_BTF\_ID:+ mask = mask\_raw\_tp\_reg(env, reg); /\* Only base\_type is checked, further checks are done here \*/ if ((base\_type(reg->type) != PTR\_TO\_BTF\_ID || (bpf\_type\_has\_unsafe\_modifiers(reg->type) && !is\_rcu\_reg(reg))) &&@@ -12295,9 +12353,11 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_ verbose(env, "expected %s or socket\n", reg\_type\_str(env, base\_type(reg->type) | (type\_flag(reg->type) & BPF\_REG\_TRUSTED\_MODIFIERS)));+ unmask\_raw\_tp\_reg(reg, mask); return -EINVAL; } ret = process\_kf\_arg\_ptr\_to\_btf\_id(env, reg, ref\_t, ref\_tname, ref\_id, meta, i);+ unmask\_raw\_tp\_reg(reg, mask); if (ret < 0) return ret; break;@@ -13267,7 +13327,7 @@ static int sanitize\_check\_bounds(struct bpf\_verifier\_env \*env, \*/ static int adjust\_ptr\_min\_max\_vals(struct bpf\_verifier\_env \*env, struct bpf\_insn \*insn,- const struct bpf\_reg\_state \*ptr\_reg,+ struct bpf\_reg\_state \*ptr\_reg, const struct bpf\_reg\_state \*off\_reg) { struct bpf\_verifier\_state \*vstate = env->cur\_state;@@ -13281,6 +13341,7 @@ static int adjust\_ptr\_min\_max\_vals(struct bpf\_verifier\_env \*env, struct bpf\_sanitize\_info info = {}; u8 opcode = BPF\_OP(insn->code); u32 dst = insn->dst\_reg;+ bool mask; int ret;  dst\_reg = &regs[dst];@@ -13307,11 +13368,14 @@ static int adjust\_ptr\_min\_max\_vals(struct bpf\_verifier\_env \*env, return -EACCES; } + mask = mask\_raw\_tp\_reg(env, ptr\_reg); if (ptr\_reg->type & PTR\_MAYBE\_NULL) { verbose(env, "R%d pointer arithmetic on %s prohibited, null-check it first\n", dst, reg\_type\_str(env, ptr\_reg->type));+ unmask\_raw\_tp\_reg(ptr\_reg, mask); return -EACCES; }+ unmask\_raw\_tp\_reg(ptr\_reg, mask);  switch (base\_type(ptr\_reg->type)) { case PTR\_TO\_CTX:@@ -19852,6 +19916,7 @@ static int convert\_ctx\_accesses(struct bpf\_verifier\_env \*env) \* for this case. \*/ case PTR\_TO\_BTF\_ID | MEM\_ALLOC | PTR\_UNTRUSTED:+ case PTR\_TO\_BTF\_ID | PTR\_TRUSTED | PTR\_MAYBE\_NULL: if (type == BPF\_READ) { if (BPF\_MODE(insn->code) == BPF\_MEM) insn->code = BPF\_LDX | BPF\_PROBE\_MEM |diff --git a/tools/testing/selftests/bpf/progs/test\_tp\_btf\_nullable.c b/tools/testing/selftests/bpf/progs/test\_tp\_btf\_nullable.cindex bba3e37f749b86..5aaf2b065f86c2 100644--- a/[tools/testing/selftests/bpf/progs/test\_tp\_btf\_nullable.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/test_tp_btf_nullable.c?id=6d9f07196389f35a3afebcf1a12c1425725caddd)+++ b/[tools/testing/selftests/bpf/progs/test\_tp\_btf\_nullable.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/test_tp_btf_nullable.c?id=3634d4a310820567fc634bf8f1ee2b91378773e8)@@ -7,7 +7,11 @@ #include "bpf\_misc.h"  SEC("tp\_btf/bpf\_testmod\_test\_nullable\_bare")-\_\_failure \_\_msg("R1 invalid mem access 'trusted\_ptr\_or\_null\_'")+/\* This used to be a failure test, but raw\_tp nullable arguments can now+ \* directly be dereferenced, whether they have nullable annotation or not,+ \* and don't need to be explicitly checked.+ \*/+\_\_success int BPF\_PROG(handle\_tp\_btf\_nullable\_bare1, struct bpf\_testmod\_test\_read\_ctx \*nullable\_ctx) { return nullable\_ctx->len; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:57:49 +0000



=== Content from git.kernel.org_fddf61a8_20250114_205912.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Kumar Kartikeya Dwivedi <memxor@gmail.com> | 2024-11-04 09:19:57 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-05 13:53:20 +0100 |
| commit | [c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6)) | |
| tree | [66aeba3c590bce3890b9bffe9b6d746d459c4d83](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6) | |
| parent | [6b5b45b153f3ca6f5fa57d84a33a2dff9c9eeeec](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6b5b45b153f3ca6f5fa57d84a33a2dff9c9eeeec) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6&id2=6b5b45b153f3ca6f5fa57d84a33a2dff9c9eeeec)) | |
| download | [linux-c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6.tar.gz) | |

bpf: Mark raw\_tp arguments with PTR\_MAYBE\_NULL[ Upstream commit cb4158ce8ec8a5bb528cc1693356a5eb8058094d ]
Arguments to a raw tracepoint are tagged as trusted, which carries the
semantics that the pointer will be non-NULL. However, in certain cases,
a raw tracepoint argument may end up being NULL. More context about this
issue is available in [0].
Thus, there is a discrepancy between the reality, that raw\_tp arguments
can actually be NULL, and the verifier's knowledge, that they are never
NULL, causing explicit NULL checks to be deleted, and accesses to such
pointers potentially crashing the kernel.
To fix this, mark raw\_tp arguments as PTR\_MAYBE\_NULL, and then special
case the dereference and pointer arithmetic to permit it, and allow
passing them into helpers/kfuncs; these exceptions are made for raw\_tp
programs only. Ensure that we don't do this when ref\_obj\_id > 0, as in
that case this is an acquired object and doesn't need such adjustment.
The reason we do mask\_raw\_tp\_trusted\_reg logic is because other will
recheck in places whether the register is a trusted\_reg, and then
consider our register as untrusted when detecting the presence of the
PTR\_MAYBE\_NULL flag.
To allow safe dereference, we enable PROBE\_MEM marking when we see loads
into trusted pointers with PTR\_MAYBE\_NULL.
While trusted raw\_tp arguments can also be passed into helpers or kfuncs
where such broken assumption may cause issues, a future patch set will
tackle their case separately, as PTR\_TO\_BTF\_ID (without PTR\_TRUSTED) can
already be passed into helpers and causes similar problems. Thus, they
are left alone for now.
It is possible that these checks also permit passing non-raw\_tp args
that are trusted PTR\_TO\_BTF\_ID with null marking. In such a case,
allowing dereference when pointer is NULL expands allowed behavior, so
won't regress existing programs, and the case of passing these into
helpers is the same as above and will be dealt with later.
Also update the failure case in tp\_btf\_nullable selftest to capture the
new behavior, as the verifier will no longer cause an error when
directly dereference a raw tracepoint argument marked as \_\_nullable.
[0]: https://lore.kernel.org/bpf/ZrCZS6nisraEqehw@jlelli-thinkpadt14gen4.remote.csb
Reviewed-by: Jiri Olsa <jolsa@kernel.org>
Reported-by: Juri Lelli <juri.lelli@redhat.com>
Tested-by: Juri Lelli <juri.lelli@redhat.com>
Fixes: 3f00c5239344 ("bpf: Allow trusted pointers to be passed to KF\_TRUSTED\_ARGS kfuncs")
Signed-off-by: Kumar Kartikeya Dwivedi <memxor@gmail.com>
Link: [https://lore.kernel.org/r/20241104171959.2938862-2-memxor@gmail.com](https://lore.kernel.org/r/20241104171959.2938862-2-memxor%40gmail.com)
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6)

| -rw-r--r-- | [include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/bpf.h?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6) | 6 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [kernel/bpf/btf.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/btf.c?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/verifier.c?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6) | 79 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/test\_tp\_btf\_nullable.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/test_tp_btf_nullable.c?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6) | 6 | |  |  |  | | --- | --- | --- | |

4 files changed, 87 insertions, 9 deletions

| diff --git a/include/linux/bpf.h b/include/linux/bpf.hindex eb1d3a2fe3339b..75b4117454b45d 100644--- a/[include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf.h?id=6b5b45b153f3ca6f5fa57d84a33a2dff9c9eeeec)+++ b/[include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf.h?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6)@@ -3436,4 +3436,10 @@ static inline bool bpf\_is\_subprog(const struct bpf\_prog \*prog) return prog->aux->func\_idx != 0; } +static inline bool bpf\_prog\_is\_raw\_tp(const struct bpf\_prog \*prog)+{+ return prog->type == BPF\_PROG\_TYPE\_TRACING &&+ prog->expected\_attach\_type == BPF\_TRACE\_RAW\_TP;+}+ #endif /\* \_LINUX\_BPF\_H \*/diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.cindex 76afa90814ddbe..8608d24369f019 100644--- a/[kernel/bpf/btf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=6b5b45b153f3ca6f5fa57d84a33a2dff9c9eeeec)+++ b/[kernel/bpf/btf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6)@@ -6534,7 +6534,10 @@ bool btf\_ctx\_access(int off, int size, enum bpf\_access\_type type, if (prog\_args\_trusted(prog)) info->reg\_type |= PTR\_TRUSTED; - if (btf\_param\_match\_suffix(btf, &args[arg], "\_\_nullable"))+ /\* Raw tracepoint arguments always get marked as maybe NULL \*/+ if (bpf\_prog\_is\_raw\_tp(prog))+ info->reg\_type |= PTR\_MAYBE\_NULL;+ else if (btf\_param\_match\_suffix(btf, &args[arg], "\_\_nullable")) info->reg\_type |= PTR\_MAYBE\_NULL;  if (tgt\_prog) {diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex 0481915e63c21c..b34a358c75e0fb 100644--- a/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=6b5b45b153f3ca6f5fa57d84a33a2dff9c9eeeec)+++ b/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6)@@ -423,6 +423,25 @@ static struct btf\_record \*reg\_btf\_record(const struct bpf\_reg\_state \*reg) return rec; } +static bool mask\_raw\_tp\_reg\_cond(const struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg) {+ return reg->type == (PTR\_TO\_BTF\_ID | PTR\_TRUSTED | PTR\_MAYBE\_NULL) &&+ bpf\_prog\_is\_raw\_tp(env->prog) && !reg->ref\_obj\_id;+}++static bool mask\_raw\_tp\_reg(const struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg)+{+ if (!mask\_raw\_tp\_reg\_cond(env, reg))+ return false;+ reg->type &= ~PTR\_MAYBE\_NULL;+ return true;+}++static void unmask\_raw\_tp\_reg(struct bpf\_reg\_state \*reg, bool result)+{+ if (result)+ reg->type |= PTR\_MAYBE\_NULL;+}+ static bool subprog\_is\_global(const struct bpf\_verifier\_env \*env, int subprog) { struct bpf\_func\_info\_aux \*aux = env->prog->aux->func\_info\_aux;@@ -6513,6 +6532,7 @@ static int check\_ptr\_to\_btf\_access(struct bpf\_verifier\_env \*env, const char \*field\_name = NULL; enum bpf\_type\_flag flag = 0; u32 btf\_id = 0;+ bool mask; int ret;  if (!env->allow\_ptr\_leaks) {@@ -6584,7 +6604,21 @@ static int check\_ptr\_to\_btf\_access(struct bpf\_verifier\_env \*env,  if (ret < 0) return ret;-+ /\* For raw\_tp progs, we allow dereference of PTR\_MAYBE\_NULL+ \* trusted PTR\_TO\_BTF\_ID, these are the ones that are possibly+ \* arguments to the raw\_tp. Since internal checks in for trusted+ \* reg in check\_ptr\_to\_btf\_access would consider PTR\_MAYBE\_NULL+ \* modifier as problematic, mask it out temporarily for the+ \* check. Don't apply this to pointers with ref\_obj\_id > 0, as+ \* those won't be raw\_tp args.+ \*+ \* We may end up applying this relaxation to other trusted+ \* PTR\_TO\_BTF\_ID with maybe null flag, since we cannot+ \* distinguish PTR\_MAYBE\_NULL tagged for arguments vs normal+ \* tagging, but that should expand allowed behavior, and not+ \* cause regression for existing behavior.+ \*/+ mask = mask\_raw\_tp\_reg(env, reg); if (ret != PTR\_TO\_BTF\_ID) { /\* just mark; \*/ @@ -6645,8 +6679,13 @@ static int check\_ptr\_to\_btf\_access(struct bpf\_verifier\_env \*env, clear\_trusted\_flags(&flag); } - if (atype == BPF\_READ && value\_regno >= 0)+ if (atype == BPF\_READ && value\_regno >= 0) { mark\_btf\_ld\_reg(env, regs, value\_regno, ret, reg->btf, btf\_id, flag);+ /\* We've assigned a new type to regno, so don't undo masking. \*/+ if (regno == value\_regno)+ mask = false;+ }+ unmask\_raw\_tp\_reg(reg, mask);  return 0; }@@ -7021,7 +7060,7 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn if (!err && t == BPF\_READ && value\_regno >= 0) mark\_reg\_unknown(env, regs, value\_regno); } else if (base\_type(reg->type) == PTR\_TO\_BTF\_ID &&- !type\_may\_be\_null(reg->type)) {+ (mask\_raw\_tp\_reg\_cond(env, reg) || !type\_may\_be\_null(reg->type))) { err = check\_ptr\_to\_btf\_access(env, regs, regno, off, size, t, value\_regno); } else if (reg->type == CONST\_PTR\_TO\_MAP) {@@ -8685,6 +8724,7 @@ static int check\_func\_arg(struct bpf\_verifier\_env \*env, u32 arg, enum bpf\_reg\_type type = reg->type; u32 \*arg\_btf\_id = NULL; int err = 0;+ bool mask;  if (arg\_type == ARG\_DONTCARE) return 0;@@ -8725,11 +8765,11 @@ static int check\_func\_arg(struct bpf\_verifier\_env \*env, u32 arg, base\_type(arg\_type) == ARG\_PTR\_TO\_SPIN\_LOCK) arg\_btf\_id = fn->arg\_btf\_id[arg]; + mask = mask\_raw\_tp\_reg(env, reg); err = check\_reg\_type(env, regno, arg\_type, arg\_btf\_id, meta);- if (err)- return err; - err = check\_func\_arg\_reg\_off(env, reg, regno, arg\_type);+ err = err ?: check\_func\_arg\_reg\_off(env, reg, regno, arg\_type);+ unmask\_raw\_tp\_reg(reg, mask); if (err) return err; @@ -9524,14 +9564,17 @@ static int btf\_check\_func\_arg\_match(struct bpf\_verifier\_env \*env, int subprog, return ret; } else if (base\_type(arg->arg\_type) == ARG\_PTR\_TO\_BTF\_ID) { struct bpf\_call\_arg\_meta meta;+ bool mask; int err;  if (register\_is\_null(reg) && type\_may\_be\_null(arg->arg\_type)) continue;  memset(&meta, 0, sizeof(meta)); /\* leave func\_id as zero \*/+ mask = mask\_raw\_tp\_reg(env, reg); err = check\_reg\_type(env, regno, arg->arg\_type, &arg->btf\_id, &meta); err = err ?: check\_func\_arg\_reg\_off(env, reg, regno, arg->arg\_type);+ unmask\_raw\_tp\_reg(reg, mask); if (err) return err; } else {@@ -11836,6 +11879,7 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_ enum bpf\_arg\_type arg\_type = ARG\_DONTCARE; u32 regno = i + 1, ref\_id, type\_size; bool is\_ret\_buf\_sz = false;+ bool mask = false; int kf\_arg\_type;  t = btf\_type\_skip\_modifiers(btf, args[i].type, NULL);@@ -11894,12 +11938,15 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_ return -EINVAL; } + mask = mask\_raw\_tp\_reg(env, reg); if ((is\_kfunc\_trusted\_args(meta) || is\_kfunc\_rcu(meta)) && (register\_is\_null(reg) || type\_may\_be\_null(reg->type)) && !is\_kfunc\_arg\_nullable(meta->btf, &args[i])) { verbose(env, "Possibly NULL pointer passed to trusted arg%d\n", i);+ unmask\_raw\_tp\_reg(reg, mask); return -EACCES; }+ unmask\_raw\_tp\_reg(reg, mask);  if (reg->ref\_obj\_id) { if (is\_kfunc\_release(meta) && meta->ref\_obj\_id) {@@ -11957,16 +12004,24 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_ if (!is\_kfunc\_trusted\_args(meta) && !is\_kfunc\_rcu(meta)) break; + /\* Allow passing maybe NULL raw\_tp arguments to+ \* kfuncs for compatibility. Don't apply this to+ \* arguments with ref\_obj\_id > 0.+ \*/+ mask = mask\_raw\_tp\_reg(env, reg); if (!is\_trusted\_reg(reg)) { if (!is\_kfunc\_rcu(meta)) { verbose(env, "R%d must be referenced or trusted\n", regno);+ unmask\_raw\_tp\_reg(reg, mask); return -EINVAL; } if (!is\_rcu\_reg(reg)) { verbose(env, "R%d must be a rcu pointer\n", regno);+ unmask\_raw\_tp\_reg(reg, mask); return -EINVAL; } }+ unmask\_raw\_tp\_reg(reg, mask); fallthrough; case KF\_ARG\_PTR\_TO\_CTX: case KF\_ARG\_PTR\_TO\_DYNPTR:@@ -11989,7 +12044,9 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_  if (is\_kfunc\_release(meta) && reg->ref\_obj\_id) arg\_type |= OBJ\_RELEASE;+ mask = mask\_raw\_tp\_reg(env, reg); ret = check\_func\_arg\_reg\_off(env, reg, regno, arg\_type);+ unmask\_raw\_tp\_reg(reg, mask); if (ret < 0) return ret; @@ -12165,6 +12222,7 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_ ref\_tname = btf\_name\_by\_offset(btf, ref\_t->name\_off); fallthrough; case KF\_ARG\_PTR\_TO\_BTF\_ID:+ mask = mask\_raw\_tp\_reg(env, reg); /\* Only base\_type is checked, further checks are done here \*/ if ((base\_type(reg->type) != PTR\_TO\_BTF\_ID || (bpf\_type\_has\_unsafe\_modifiers(reg->type) && !is\_rcu\_reg(reg))) &&@@ -12173,9 +12231,11 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_ verbose(env, "expected %s or socket\n", reg\_type\_str(env, base\_type(reg->type) | (type\_flag(reg->type) & BPF\_REG\_TRUSTED\_MODIFIERS)));+ unmask\_raw\_tp\_reg(reg, mask); return -EINVAL; } ret = process\_kf\_arg\_ptr\_to\_btf\_id(env, reg, ref\_t, ref\_tname, ref\_id, meta, i);+ unmask\_raw\_tp\_reg(reg, mask); if (ret < 0) return ret; break;@@ -13145,7 +13205,7 @@ static int sanitize\_check\_bounds(struct bpf\_verifier\_env \*env, \*/ static int adjust\_ptr\_min\_max\_vals(struct bpf\_verifier\_env \*env, struct bpf\_insn \*insn,- const struct bpf\_reg\_state \*ptr\_reg,+ struct bpf\_reg\_state \*ptr\_reg, const struct bpf\_reg\_state \*off\_reg) { struct bpf\_verifier\_state \*vstate = env->cur\_state;@@ -13159,6 +13219,7 @@ static int adjust\_ptr\_min\_max\_vals(struct bpf\_verifier\_env \*env, struct bpf\_sanitize\_info info = {}; u8 opcode = BPF\_OP(insn->code); u32 dst = insn->dst\_reg;+ bool mask; int ret;  dst\_reg = &regs[dst];@@ -13185,11 +13246,14 @@ static int adjust\_ptr\_min\_max\_vals(struct bpf\_verifier\_env \*env, return -EACCES; } + mask = mask\_raw\_tp\_reg(env, ptr\_reg); if (ptr\_reg->type & PTR\_MAYBE\_NULL) { verbose(env, "R%d pointer arithmetic on %s prohibited, null-check it first\n", dst, reg\_type\_str(env, ptr\_reg->type));+ unmask\_raw\_tp\_reg(ptr\_reg, mask); return -EACCES; }+ unmask\_raw\_tp\_reg(ptr\_reg, mask);  switch (base\_type(ptr\_reg->type)) { case PTR\_TO\_CTX:@@ -19330,6 +19394,7 @@ static int convert\_ctx\_accesses(struct bpf\_verifier\_env \*env) \* for this case. \*/ case PTR\_TO\_BTF\_ID | MEM\_ALLOC | PTR\_UNTRUSTED:+ case PTR\_TO\_BTF\_ID | PTR\_TRUSTED | PTR\_MAYBE\_NULL: if (type == BPF\_READ) { if (BPF\_MODE(insn->code) == BPF\_MEM) insn->code = BPF\_LDX | BPF\_PROBE\_MEM |diff --git a/tools/testing/selftests/bpf/progs/test\_tp\_btf\_nullable.c b/tools/testing/selftests/bpf/progs/test\_tp\_btf\_nullable.cindex bba3e37f749b86..5aaf2b065f86c2 100644--- a/[tools/testing/selftests/bpf/progs/test\_tp\_btf\_nullable.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/test_tp_btf_nullable.c?id=6b5b45b153f3ca6f5fa57d84a33a2dff9c9eeeec)+++ b/[tools/testing/selftests/bpf/progs/test\_tp\_btf\_nullable.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/test_tp_btf_nullable.c?id=c9b91d2d54175f781ad2c361cb2ac2c0e29b14b6)@@ -7,7 +7,11 @@ #include "bpf\_misc.h"  SEC("tp\_btf/bpf\_testmod\_test\_nullable\_bare")-\_\_failure \_\_msg("R1 invalid mem access 'trusted\_ptr\_or\_null\_'")+/\* This used to be a failure test, but raw\_tp nullable arguments can now+ \* directly be dereferenced, whether they have nullable annotation or not,+ \* and don't need to be explicitly checked.+ \*/+\_\_success int BPF\_PROG(handle\_tp\_btf\_nullable\_bare1, struct bpf\_testmod\_test\_read\_ctx \*nullable\_ctx) { return nullable\_ctx->len; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:57:50 +0000



=== Content from git.kernel.org_c612b79a_20250114_205913.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Kumar Kartikeya Dwivedi <memxor@gmail.com> | 2024-11-04 09:19:57 -0800 |
| --- | --- | --- |
| committer | Alexei Starovoitov <ast@kernel.org> | 2024-11-04 11:37:36 -0800 |
| commit | [cb4158ce8ec8a5bb528cc1693356a5eb8058094d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d)) | |
| tree | [cb3fff142e1a5022fb0675dd94bee691520c22bc](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d) | |
| parent | [9a783139614fb837da4ccb2f8ec6f0ddc802b3d3](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9a783139614fb837da4ccb2f8ec6f0ddc802b3d3) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d&id2=9a783139614fb837da4ccb2f8ec6f0ddc802b3d3)) | |
| download | [linux-cb4158ce8ec8a5bb528cc1693356a5eb8058094d.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-cb4158ce8ec8a5bb528cc1693356a5eb8058094d.tar.gz) | |

bpf: Mark raw\_tp arguments with PTR\_MAYBE\_NULLArguments to a raw tracepoint are tagged as trusted, which carries the
semantics that the pointer will be non-NULL. However, in certain cases,
a raw tracepoint argument may end up being NULL. More context about this
issue is available in [0].
Thus, there is a discrepancy between the reality, that raw\_tp arguments
can actually be NULL, and the verifier's knowledge, that they are never
NULL, causing explicit NULL checks to be deleted, and accesses to such
pointers potentially crashing the kernel.
To fix this, mark raw\_tp arguments as PTR\_MAYBE\_NULL, and then special
case the dereference and pointer arithmetic to permit it, and allow
passing them into helpers/kfuncs; these exceptions are made for raw\_tp
programs only. Ensure that we don't do this when ref\_obj\_id > 0, as in
that case this is an acquired object and doesn't need such adjustment.
The reason we do mask\_raw\_tp\_trusted\_reg logic is because other will
recheck in places whether the register is a trusted\_reg, and then
consider our register as untrusted when detecting the presence of the
PTR\_MAYBE\_NULL flag.
To allow safe dereference, we enable PROBE\_MEM marking when we see loads
into trusted pointers with PTR\_MAYBE\_NULL.
While trusted raw\_tp arguments can also be passed into helpers or kfuncs
where such broken assumption may cause issues, a future patch set will
tackle their case separately, as PTR\_TO\_BTF\_ID (without PTR\_TRUSTED) can
already be passed into helpers and causes similar problems. Thus, they
are left alone for now.
It is possible that these checks also permit passing non-raw\_tp args
that are trusted PTR\_TO\_BTF\_ID with null marking. In such a case,
allowing dereference when pointer is NULL expands allowed behavior, so
won't regress existing programs, and the case of passing these into
helpers is the same as above and will be dealt with later.
Also update the failure case in tp\_btf\_nullable selftest to capture the
new behavior, as the verifier will no longer cause an error when
directly dereference a raw tracepoint argument marked as \_\_nullable.
[0]: https://lore.kernel.org/bpf/ZrCZS6nisraEqehw@jlelli-thinkpadt14gen4.remote.csb
Reviewed-by: Jiri Olsa <jolsa@kernel.org>
Reported-by: Juri Lelli <juri.lelli@redhat.com>
Tested-by: Juri Lelli <juri.lelli@redhat.com>
Fixes: 3f00c5239344 ("bpf: Allow trusted pointers to be passed to KF\_TRUSTED\_ARGS kfuncs")
Signed-off-by: Kumar Kartikeya Dwivedi <memxor@gmail.com>
Link: [https://lore.kernel.org/r/20241104171959.2938862-2-memxor@gmail.com](https://lore.kernel.org/r/20241104171959.2938862-2-memxor%40gmail.com)
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d)

| -rw-r--r-- | [include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/bpf.h?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d) | 6 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [kernel/bpf/btf.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/btf.c?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/verifier.c?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d) | 79 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/test\_tp\_btf\_nullable.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/test_tp_btf_nullable.c?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d) | 6 | |  |  |  | | --- | --- | --- | |

4 files changed, 87 insertions, 9 deletions

| diff --git a/include/linux/bpf.h b/include/linux/bpf.hindex c3ba4d47517478..1b84613b10ac78 100644--- a/[include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf.h?id=9a783139614fb837da4ccb2f8ec6f0ddc802b3d3)+++ b/[include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf.h?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d)@@ -3495,4 +3495,10 @@ static inline bool bpf\_is\_subprog(const struct bpf\_prog \*prog) return prog->aux->func\_idx != 0; } +static inline bool bpf\_prog\_is\_raw\_tp(const struct bpf\_prog \*prog)+{+ return prog->type == BPF\_PROG\_TYPE\_TRACING &&+ prog->expected\_attach\_type == BPF\_TRACE\_RAW\_TP;+}+ #endif /\* \_LINUX\_BPF\_H \*/diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.cindex ed3219da7181c4..e7a59e6462a933 100644--- a/[kernel/bpf/btf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=9a783139614fb837da4ccb2f8ec6f0ddc802b3d3)+++ b/[kernel/bpf/btf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d)@@ -6588,7 +6588,10 @@ bool btf\_ctx\_access(int off, int size, enum bpf\_access\_type type, if (prog\_args\_trusted(prog)) info->reg\_type |= PTR\_TRUSTED; - if (btf\_param\_match\_suffix(btf, &args[arg], "\_\_nullable"))+ /\* Raw tracepoint arguments always get marked as maybe NULL \*/+ if (bpf\_prog\_is\_raw\_tp(prog))+ info->reg\_type |= PTR\_MAYBE\_NULL;+ else if (btf\_param\_match\_suffix(btf, &args[arg], "\_\_nullable")) info->reg\_type |= PTR\_MAYBE\_NULL;  if (tgt\_prog) {diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex ba800c7611e35e..7958d6ff6b7398 100644--- a/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=9a783139614fb837da4ccb2f8ec6f0ddc802b3d3)+++ b/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d)@@ -418,6 +418,25 @@ static struct btf\_record \*reg\_btf\_record(const struct bpf\_reg\_state \*reg) return rec; } +static bool mask\_raw\_tp\_reg\_cond(const struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg) {+ return reg->type == (PTR\_TO\_BTF\_ID | PTR\_TRUSTED | PTR\_MAYBE\_NULL) &&+ bpf\_prog\_is\_raw\_tp(env->prog) && !reg->ref\_obj\_id;+}++static bool mask\_raw\_tp\_reg(const struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg)+{+ if (!mask\_raw\_tp\_reg\_cond(env, reg))+ return false;+ reg->type &= ~PTR\_MAYBE\_NULL;+ return true;+}++static void unmask\_raw\_tp\_reg(struct bpf\_reg\_state \*reg, bool result)+{+ if (result)+ reg->type |= PTR\_MAYBE\_NULL;+}+ static bool subprog\_is\_global(const struct bpf\_verifier\_env \*env, int subprog) { struct bpf\_func\_info\_aux \*aux = env->prog->aux->func\_info\_aux;@@ -6622,6 +6641,7 @@ static int check\_ptr\_to\_btf\_access(struct bpf\_verifier\_env \*env, const char \*field\_name = NULL; enum bpf\_type\_flag flag = 0; u32 btf\_id = 0;+ bool mask; int ret;  if (!env->allow\_ptr\_leaks) {@@ -6693,7 +6713,21 @@ static int check\_ptr\_to\_btf\_access(struct bpf\_verifier\_env \*env,  if (ret < 0) return ret;-+ /\* For raw\_tp progs, we allow dereference of PTR\_MAYBE\_NULL+ \* trusted PTR\_TO\_BTF\_ID, these are the ones that are possibly+ \* arguments to the raw\_tp. Since internal checks in for trusted+ \* reg in check\_ptr\_to\_btf\_access would consider PTR\_MAYBE\_NULL+ \* modifier as problematic, mask it out temporarily for the+ \* check. Don't apply this to pointers with ref\_obj\_id > 0, as+ \* those won't be raw\_tp args.+ \*+ \* We may end up applying this relaxation to other trusted+ \* PTR\_TO\_BTF\_ID with maybe null flag, since we cannot+ \* distinguish PTR\_MAYBE\_NULL tagged for arguments vs normal+ \* tagging, but that should expand allowed behavior, and not+ \* cause regression for existing behavior.+ \*/+ mask = mask\_raw\_tp\_reg(env, reg); if (ret != PTR\_TO\_BTF\_ID) { /\* just mark; \*/ @@ -6754,8 +6788,13 @@ static int check\_ptr\_to\_btf\_access(struct bpf\_verifier\_env \*env, clear\_trusted\_flags(&flag); } - if (atype == BPF\_READ && value\_regno >= 0)+ if (atype == BPF\_READ && value\_regno >= 0) { mark\_btf\_ld\_reg(env, regs, value\_regno, ret, reg->btf, btf\_id, flag);+ /\* We've assigned a new type to regno, so don't undo masking. \*/+ if (regno == value\_regno)+ mask = false;+ }+ unmask\_raw\_tp\_reg(reg, mask);  return 0; }@@ -7140,7 +7179,7 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn if (!err && t == BPF\_READ && value\_regno >= 0) mark\_reg\_unknown(env, regs, value\_regno); } else if (base\_type(reg->type) == PTR\_TO\_BTF\_ID &&- !type\_may\_be\_null(reg->type)) {+ (mask\_raw\_tp\_reg\_cond(env, reg) || !type\_may\_be\_null(reg->type))) { err = check\_ptr\_to\_btf\_access(env, regs, regno, off, size, t, value\_regno); } else if (reg->type == CONST\_PTR\_TO\_MAP) {@@ -8833,6 +8872,7 @@ static int check\_func\_arg(struct bpf\_verifier\_env \*env, u32 arg, enum bpf\_reg\_type type = reg->type; u32 \*arg\_btf\_id = NULL; int err = 0;+ bool mask;  if (arg\_type == ARG\_DONTCARE) return 0;@@ -8873,11 +8913,11 @@ static int check\_func\_arg(struct bpf\_verifier\_env \*env, u32 arg, base\_type(arg\_type) == ARG\_PTR\_TO\_SPIN\_LOCK) arg\_btf\_id = fn->arg\_btf\_id[arg]; + mask = mask\_raw\_tp\_reg(env, reg); err = check\_reg\_type(env, regno, arg\_type, arg\_btf\_id, meta);- if (err)- return err; - err = check\_func\_arg\_reg\_off(env, reg, regno, arg\_type);+ err = err ?: check\_func\_arg\_reg\_off(env, reg, regno, arg\_type);+ unmask\_raw\_tp\_reg(reg, mask); if (err) return err; @@ -9672,14 +9712,17 @@ static int btf\_check\_func\_arg\_match(struct bpf\_verifier\_env \*env, int subprog, return ret; } else if (base\_type(arg->arg\_type) == ARG\_PTR\_TO\_BTF\_ID) { struct bpf\_call\_arg\_meta meta;+ bool mask; int err;  if (register\_is\_null(reg) && type\_may\_be\_null(arg->arg\_type)) continue;  memset(&meta, 0, sizeof(meta)); /\* leave func\_id as zero \*/+ mask = mask\_raw\_tp\_reg(env, reg); err = check\_reg\_type(env, regno, arg->arg\_type, &arg->btf\_id, &meta); err = err ?: check\_func\_arg\_reg\_off(env, reg, regno, arg->arg\_type);+ unmask\_raw\_tp\_reg(reg, mask); if (err) return err; } else {@@ -12007,6 +12050,7 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_ enum bpf\_arg\_type arg\_type = ARG\_DONTCARE; u32 regno = i + 1, ref\_id, type\_size; bool is\_ret\_buf\_sz = false;+ bool mask = false; int kf\_arg\_type;  t = btf\_type\_skip\_modifiers(btf, args[i].type, NULL);@@ -12065,12 +12109,15 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_ return -EINVAL; } + mask = mask\_raw\_tp\_reg(env, reg); if ((is\_kfunc\_trusted\_args(meta) || is\_kfunc\_rcu(meta)) && (register\_is\_null(reg) || type\_may\_be\_null(reg->type)) && !is\_kfunc\_arg\_nullable(meta->btf, &args[i])) { verbose(env, "Possibly NULL pointer passed to trusted arg%d\n", i);+ unmask\_raw\_tp\_reg(reg, mask); return -EACCES; }+ unmask\_raw\_tp\_reg(reg, mask);  if (reg->ref\_obj\_id) { if (is\_kfunc\_release(meta) && meta->ref\_obj\_id) {@@ -12128,16 +12175,24 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_ if (!is\_kfunc\_trusted\_args(meta) && !is\_kfunc\_rcu(meta)) break; + /\* Allow passing maybe NULL raw\_tp arguments to+ \* kfuncs for compatibility. Don't apply this to+ \* arguments with ref\_obj\_id > 0.+ \*/+ mask = mask\_raw\_tp\_reg(env, reg); if (!is\_trusted\_reg(reg)) { if (!is\_kfunc\_rcu(meta)) { verbose(env, "R%d must be referenced or trusted\n", regno);+ unmask\_raw\_tp\_reg(reg, mask); return -EINVAL; } if (!is\_rcu\_reg(reg)) { verbose(env, "R%d must be a rcu pointer\n", regno);+ unmask\_raw\_tp\_reg(reg, mask); return -EINVAL; } }+ unmask\_raw\_tp\_reg(reg, mask); fallthrough; case KF\_ARG\_PTR\_TO\_CTX: case KF\_ARG\_PTR\_TO\_DYNPTR:@@ -12160,7 +12215,9 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_  if (is\_kfunc\_release(meta) && reg->ref\_obj\_id) arg\_type |= OBJ\_RELEASE;+ mask = mask\_raw\_tp\_reg(env, reg); ret = check\_func\_arg\_reg\_off(env, reg, regno, arg\_type);+ unmask\_raw\_tp\_reg(reg, mask); if (ret < 0) return ret; @@ -12337,6 +12394,7 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_ ref\_tname = btf\_name\_by\_offset(btf, ref\_t->name\_off); fallthrough; case KF\_ARG\_PTR\_TO\_BTF\_ID:+ mask = mask\_raw\_tp\_reg(env, reg); /\* Only base\_type is checked, further checks are done here \*/ if ((base\_type(reg->type) != PTR\_TO\_BTF\_ID || (bpf\_type\_has\_unsafe\_modifiers(reg->type) && !is\_rcu\_reg(reg))) &&@@ -12345,9 +12403,11 @@ static int check\_kfunc\_args(struct bpf\_verifier\_env \*env, struct bpf\_kfunc\_call\_ verbose(env, "expected %s or socket\n", reg\_type\_str(env, base\_type(reg->type) | (type\_flag(reg->type) & BPF\_REG\_TRUSTED\_MODIFIERS)));+ unmask\_raw\_tp\_reg(reg, mask); return -EINVAL; } ret = process\_kf\_arg\_ptr\_to\_btf\_id(env, reg, ref\_t, ref\_tname, ref\_id, meta, i);+ unmask\_raw\_tp\_reg(reg, mask); if (ret < 0) return ret; break;@@ -13320,7 +13380,7 @@ static int sanitize\_check\_bounds(struct bpf\_verifier\_env \*env, \*/ static int adjust\_ptr\_min\_max\_vals(struct bpf\_verifier\_env \*env, struct bpf\_insn \*insn,- const struct bpf\_reg\_state \*ptr\_reg,+ struct bpf\_reg\_state \*ptr\_reg, const struct bpf\_reg\_state \*off\_reg) { struct bpf\_verifier\_state \*vstate = env->cur\_state;@@ -13334,6 +13394,7 @@ static int adjust\_ptr\_min\_max\_vals(struct bpf\_verifier\_env \*env, struct bpf\_sanitize\_info info = {}; u8 opcode = BPF\_OP(insn->code); u32 dst = insn->dst\_reg;+ bool mask; int ret;  dst\_reg = &regs[dst];@@ -13360,11 +13421,14 @@ static int adjust\_ptr\_min\_max\_vals(struct bpf\_verifier\_env \*env, return -EACCES; } + mask = mask\_raw\_tp\_reg(env, ptr\_reg); if (ptr\_reg->type & PTR\_MAYBE\_NULL) { verbose(env, "R%d pointer arithmetic on %s prohibited, null-check it first\n", dst, reg\_type\_str(env, ptr\_reg->type));+ unmask\_raw\_tp\_reg(ptr\_reg, mask); return -EACCES; }+ unmask\_raw\_tp\_reg(ptr\_reg, mask);  switch (base\_type(ptr\_reg->type)) { case PTR\_TO\_CTX:@@ -19866,6 +19930,7 @@ static int convert\_ctx\_accesses(struct bpf\_verifier\_env \*env) \* for this case. \*/ case PTR\_TO\_BTF\_ID | MEM\_ALLOC | PTR\_UNTRUSTED:+ case PTR\_TO\_BTF\_ID | PTR\_TRUSTED | PTR\_MAYBE\_NULL: if (type == BPF\_READ) { if (BPF\_MODE(insn->code) == BPF\_MEM) insn->code = BPF\_LDX | BPF\_PROBE\_MEM |diff --git a/tools/testing/selftests/bpf/progs/test\_tp\_btf\_nullable.c b/tools/testing/selftests/bpf/progs/test\_tp\_btf\_nullable.cindex bba3e37f749b86..5aaf2b065f86c2 100644--- a/[tools/testing/selftests/bpf/progs/test\_tp\_btf\_nullable.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/test_tp_btf_nullable.c?id=9a783139614fb837da4ccb2f8ec6f0ddc802b3d3)+++ b/[tools/testing/selftests/bpf/progs/test\_tp\_btf\_nullable.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/test_tp_btf_nullable.c?id=cb4158ce8ec8a5bb528cc1693356a5eb8058094d)@@ -7,7 +7,11 @@ #include "bpf\_misc.h"  SEC("tp\_btf/bpf\_testmod\_test\_nullable\_bare")-\_\_failure \_\_msg("R1 invalid mem access 'trusted\_ptr\_or\_null\_'")+/\* This used to be a failure test, but raw\_tp nullable arguments can now+ \* directly be dereferenced, whether they have nullable annotation or not,+ \* and don't need to be explicitly checked.+ \*/+\_\_success int BPF\_PROG(handle\_tp\_btf\_nullable\_bare1, struct bpf\_testmod\_test\_read\_ctx \*nullable\_ctx) { return nullable\_ctx->len; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:57:50 +0000


