=== Content from securitylab.github.com_7ff9802f_20250114_181312.html ===

[skip to content](#content)

 /
[Security Lab](/ "Security Lab")
[Research](https://github.blog/tag/github-security-lab/ "Research")
[Advisories](/advisories/ "Advisories")
[CodeQL Wall of Fame](/codeql-wall-of-fame/ "CodeQL Wall of Fame")
Resources

[Events](/events/ "Events")

[Get Involved](/get-involved/)

* Resources
* [Open Source Community](/open-source "Home")
* [Enterprise](/enterprise "Home")

 /
[Security Lab](/ "Security Lab")

[Research](https://github.blog/tag/github-security-lab/ "Research")
[Advisories](/advisories/ "Advisories")
[CodeQL Wall of Fame](/codeql-wall-of-fame/ "CodeQL Wall of Fame")
Resources

[Open Source Community](/open-source "Open Source Community")
[Enterprise](/enterprise "Enterprise")

[Events](/events/ "Events")
[Get Involved](/get-involved/ "Events")

December 11, 2024
# GHSL-2024-094: OOB-write in Gstreamer - CVE-2024-47537

[![Author avatar](https://avatars.githubusercontent.com/u/55253029)
Antonio Morales](https://github.com/antonio-morales)

## Coordinated Disclosure Timeline

* 2024-09-25: Issue reported at https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/3839
* 2024-09-25: Issue acknowledged
* 2024-12-03: [Fixed and disclosed](https://gstreamer.freedesktop.org/security/sa-2024-0005.html)

## Project

Gstreamer

## Tested Version

Development version (2024/09/25)

## Details

### OOB-write in isomp4/qtdemux.c (`GHSL-2024-094`)

In the [following code snippet](https://gitlab.freedesktop.org/gstreamer/gstreamer/-/blob/a8f8bbef99e28bbf62aeaa774814b5c3a665e9d6/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c?page=4#L3493), the program attempts to reallocate the memory pointed to by `stream->samples` to accommodate `stream->n_samples + samples_count` elements of type `QtDemuxSample`:

```
stream->samples = g_try_renew (QtDemuxSample, stream->samples,
        stream->n_samples + samples_count);

```

The problem is that `samples_count` is read from the input file. And if this value is big enough, this can lead to an integer overflow during the addition.

As a consequence, `g_try_renew` might allocate memory for a significantly smaller number of elements than intended.

[Following this](https://gitlab.freedesktop.org/gstreamer/gstreamer/-/blob/a8f8bbef99e28bbf62aeaa774814b5c3a665e9d6/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c?page=4#L3545), the program iterates through `samples_count` elements in the following loop:

```
sample = stream->samples + stream->n_samples
for (i = 0; i < samples_count; i++) {
...
    sample->offset = *running_offset;
    sample->pts_offset = ct;
    sample->size = size;
    sample->timestamp = timestamp;
    sample->duration = dur;
...
}

```

This loop attempts to write `samples_count` number of elements, potentially exceeding the actual allocated memory size and causing an OOB-write.

#### Impact

This vulnerability overwrites the entire process memory, leading to a segmentation fault (SEGV).
This includes the metadata of malloc chunks, leading to various errors such as:

* free(): corrupted unsorted chunks
* munmap\_chunk(): invalid pointer

## CVE

* CVE-2024-47537

## Credit

This issue was discovered and reported by GHSL team member [@antonio-morales (Antonio Morales)](https://github.com/antonio-morales).

## Contact

You can contact the GHSL team at `securitylab@github.com`, please include a reference to `GHSL-2024-094` in any communication regarding this issue.

## Product

* [Features](https://github.com/features)
* [Security](https://github.com/security)
* [Team](https://github.com/team)
* [Enterprise](https://github.com/enterprise)
* [Customer stories](https://github.com/customer-stories?type=enterprise)
* [The ReadME Project](https://github.com/readme)
* [Pricing](https://github.com/pricing)
* [Resources](https://resources.github.com)
* [Roadmap](https://github.com/github/roadmap)
* [Compare GitHub](https://resources.github.com/devops/tools/compare/)

## Platform

* [Developer API](https://developer.github.com)
* [Partners](http://partner.github.com/)
* [Atom](https://atom.io)
* [Electron](http://electron.atom.io/)
* [GitHub Desktop](https://desktop.github.com/)

## Support

* [Docs](https://docs.github.com)
* [Community Forum](https://github.community)
* [Professional Services](https://services.github.com/)
* [GitHub Skills](https://skills.github.com/)
* [Status](https://githubstatus.com/)
* [Contact GitHub](https://support.github.com)

## Company

* [About](https://github.com/about)
* [Blog](https://github.blog)
* [Careers](https://github.com/about/careers)
* [Press](https://github.com/about/press)
* [Inclusion](https://github.com/about/careers)
* [Social Impact](https://github.com/about/press)
* [Shop](https://shop.github.com)

* GitHub Inc. ©
  2024
* [Terms](https://docs.github.com/en/github/site-policy/github-terms-of-service)
* [Privacy](https://docs.github.com/en/github/site-policy/github-privacy-statement)
* Sitemap
* [What is Git?](https://github.com/git-guides)
* Manage Cookies
* Do not share my personal information



=== Content from gitlab.freedesktop.org_17870d00_20250115_111932.html ===
From ae61a604c03ca07226a88e15fdb5487ad2096add Mon Sep 17 00:00:00 2001
From: Antonio Morales
Date: Thu, 26 Sep 2024 18:39:37 +0300
Subject: [PATCH 01/12] qtdemux: Fix integer overflow when allocating the
samples table for fragmented MP4
This can lead to out of bounds writes and NULL pointer dereferences.
Fixes GHSL-2024-094, GHSL-2024-237, GHSL-2024-241
Fixes https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/3839
Part-of:
---
subprojects/gst-plugins-good/gst/isomp4/qtdemux.c | 12 ++++++------
1 file changed, 6 insertions(+), 6 deletions(-)
diff --git a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
index c2d8b5e0f134..a88dcaf2d3ef 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
+++ b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
@@ -3364,6 +3364,7 @@ qtdemux\_parse\_trun (GstQTDemux \* qtdemux, GstByteReader \* trun,
gint i;
guint8 \*data;
guint entry\_size, dur\_offset, size\_offset, flags\_offset = 0, ct\_offset = 0;
+ guint new\_n\_samples;
QtDemuxSample \*sample;
gboolean ismv = FALSE;
gint64 initial\_offset;
@@ -3475,14 +3476,13 @@ qtdemux\_parse\_trun (GstQTDemux \* qtdemux, GstByteReader \* trun,
goto fail;
data = (guint8 \*) gst\_byte\_reader\_peek\_data\_unchecked (trun);
- if (stream->n\_samples + samples\_count >=
- QTDEMUX\_MAX\_SAMPLE\_INDEX\_SIZE / sizeof (QtDemuxSample))
+ if (!g\_uint\_checked\_add (&new\_n\_samples, stream->n\_samples, samples\_count) ||
+ new\_n\_samples >= QTDEMUX\_MAX\_SAMPLE\_INDEX\_SIZE / sizeof (QtDemuxSample))
goto index\_too\_big;
GST\_DEBUG\_OBJECT (qtdemux, "allocating n\_samples %u \* %u (%.2f MB)",
- stream->n\_samples + samples\_count, (guint) sizeof (QtDemuxSample),
- (stream->n\_samples + samples\_count) \*
- sizeof (QtDemuxSample) / (1024.0 \* 1024.0));
+ new\_n\_samples, (guint) sizeof (QtDemuxSample),
+ (new\_n\_samples) \* sizeof (QtDemuxSample) / (1024.0 \* 1024.0));
/\* create a new array of samples if it's the first sample parsed \*/
if (stream->n\_samples == 0) {
@@ -3491,7 +3491,7 @@ qtdemux\_parse\_trun (GstQTDemux \* qtdemux, GstByteReader \* trun,
/\* or try to reallocate it with space enough to insert the new samples \*/
} else
stream->samples = g\_try\_renew (QtDemuxSample, stream->samples,
- stream->n\_samples + samples\_count);
+ new\_n\_samples);
if (stream->samples == NULL)
goto out\_of\_memory;
--
GitLab
From cbd659c58f3236596a47b45a2afe6130139cf661 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?=
Date: Thu, 26 Sep 2024 18:40:56 +0300
Subject: [PATCH 02/12] qtdemux: Fix debug output during trun parsing
Various integers are unsigned so print them as such. Also print the actual
allocation size if allocation fails, not only parts of it.
Part-of:
---
.../gst-plugins-good/gst/isomp4/qtdemux.c | 17 +++++++++--------
1 file changed, 9 insertions(+), 8 deletions(-)
diff --git a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
index a88dcaf2d3ef..52d5a35c0ba0 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
+++ b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
@@ -3370,8 +3370,8 @@ qtdemux\_parse\_trun (GstQTDemux \* qtdemux, GstByteReader \* trun,
gint64 initial\_offset;
gint32 min\_ct = 0;
- GST\_LOG\_OBJECT (qtdemux, "parsing trun track-id %d; "
- "default dur %d, size %d, flags 0x%x, base offset %" G\_GINT64\_FORMAT ", "
+ GST\_LOG\_OBJECT (qtdemux, "parsing trun track-id %u; "
+ "default dur %u, size %u, flags 0x%x, base offset %" G\_GINT64\_FORMAT ", "
"decode ts %" G\_GINT64\_FORMAT, stream->track\_id, d\_sample\_duration,
d\_sample\_size, d\_sample\_flags, \*base\_offset, decode\_ts);
@@ -3410,7 +3410,7 @@ qtdemux\_parse\_trun (GstQTDemux \* qtdemux, GstByteReader \* trun,
"trun offset is less than the moof size, assuming offset is after moof");
data\_offset = moof\_length + 8;
}
- GST\_LOG\_OBJECT (qtdemux, "trun data offset %d", data\_offset);
+ GST\_LOG\_OBJECT (qtdemux, "trun data offset %u", data\_offset);
/\* default base offset = first byte of moof \*/
if (\*base\_offset == -1) {
GST\_LOG\_OBJECT (qtdemux, "base\_offset at moof");
@@ -3432,7 +3432,7 @@ qtdemux\_parse\_trun (GstQTDemux \* qtdemux, GstByteReader \* trun,
GST\_LOG\_OBJECT (qtdemux, "running offset now %" G\_GINT64\_FORMAT,
\*running\_offset);
- GST\_LOG\_OBJECT (qtdemux, "trun offset %d, flags 0x%x, entries %d",
+ GST\_LOG\_OBJECT (qtdemux, "trun offset %u, flags 0x%x, entries %u",
data\_offset, flags, samples\_count);
if (flags & TR\_FIRST\_SAMPLE\_FLAGS) {
@@ -3641,14 +3641,15 @@ fail:
}
out\_of\_memory:
{
- GST\_WARNING\_OBJECT (qtdemux, "failed to allocate %d samples",
- stream->n\_samples);
+ GST\_WARNING\_OBJECT (qtdemux, "failed to allocate %u + %u samples",
+ stream->n\_samples, samples\_count);
return FALSE;
}
index\_too\_big:
{
- GST\_WARNING\_OBJECT (qtdemux, "not allocating index of %d samples, would "
- "be larger than %uMB (broken file?)", stream->n\_samples,
+ GST\_WARNING\_OBJECT (qtdemux,
+ "not allocating index of %u + %u samples, would "
+ "be larger than %uMB (broken file?)", stream->n\_samples, samples\_count,
QTDEMUX\_MAX\_SAMPLE\_INDEX\_SIZE >> 20);
return FALSE;
}
--
GitLab
From 0f4dae9b01fcc4ec3a16d2386dfac432e011465b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?=
Date: Thu, 26 Sep 2024 18:41:39 +0300
Subject: [PATCH 03/12] qtdemux: Don't iterate over all trun entries if none of
the flags are set
Nothing would be printed anyway.
Part-of:
---
subprojects/gst-plugins-good/gst/isomp4/qtdemux\_dump.c | 5 +++++
1 file changed, 5 insertions(+)
diff --git a/subprojects/gst-plugins-good/gst/isomp4/qtdemux\_dump.c b/subprojects/gst-plugins-good/gst/isomp4/qtdemux\_dump.c
index 22da35e9e7ad..297b580ef038 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/qtdemux\_dump.c
+++ b/subprojects/gst-plugins-good/gst/isomp4/qtdemux\_dump.c
@@ -836,6 +836,11 @@ qtdemux\_dump\_trun (GstQTDemux \* qtdemux, GstByteReader \* data, int depth)
GST\_LOG ("%\*s first-sample-flags: %u", depth, "", first\_sample\_flags);
}
+ /\* Nothing to print below \*/
+ if ((flags & (TR\_SAMPLE\_DURATION | TR\_SAMPLE\_SIZE | TR\_SAMPLE\_FLAGS |
+ TR\_COMPOSITION\_TIME\_OFFSETS)) == 0)
+ return TRUE;
+
for (i = 0; i < samples\_count; i++) {
if (flags & TR\_SAMPLE\_DURATION) {
if (!gst\_byte\_reader\_get\_uint32\_be (data, &sample\_duration))
--
GitLab
From 5a9e80c01b4b49c6c7630a6d08b600114f38c0db Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?=
Date: Fri, 27 Sep 2024 15:50:54 +0300
Subject: [PATCH 04/12] qtdemux: Check sizes of stsc/stco/stts before trying to
merge entries
Thanks to Antonio Morales for finding and reporting the issue.
Fixes GHSL-2024-246
Fixes https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/3854
Part-of:
---
.../gst-plugins-good/gst/isomp4/qtdemux.c | 22 +++++++++++++++++++
1 file changed, 22 insertions(+)
diff --git a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
index 52d5a35c0ba0..dbd42817c00b 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
+++ b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
@@ -10040,6 +10040,21 @@ qtdemux\_merge\_sample\_table (GstQTDemux \* qtdemux, QtDemuxStream \* stream)
return;
}
+ if (gst\_byte\_reader\_get\_remaining (&stream->stts) < 8) {
+ GST\_DEBUG\_OBJECT (qtdemux, "Too small stts");
+ return;
+ }
+
+ if (stream->stco.size < 8) {
+ GST\_DEBUG\_OBJECT (qtdemux, "Too small stco");
+ return;
+ }
+
+ if (stream->n\_samples\_per\_chunk == 0) {
+ GST\_DEBUG\_OBJECT (qtdemux, "No samples per chunk");
+ return;
+ }
+
/\* Parse the stts to get the sample duration and number of samples \*/
gst\_byte\_reader\_skip\_unchecked (&stream->stts, 4);
stts\_duration = gst\_byte\_reader\_get\_uint32\_be\_unchecked (&stream->stts);
@@ -10051,6 +10066,13 @@ qtdemux\_merge\_sample\_table (GstQTDemux \* qtdemux, QtDemuxStream \* stream)
GST\_DEBUG\_OBJECT (qtdemux, "sample\_duration %d, num\_chunks %u", stts\_duration,
num\_chunks);
+ if (gst\_byte\_reader\_get\_remaining (&stream->stsc) <
+ stream->n\_samples\_per\_chunk \* 3 \* 4 +
+ (stream->n\_samples\_per\_chunk - 1) \* 4) {
+ GST\_DEBUG\_OBJECT (qtdemux, "Too small stsc");
+ return;
+ }
+
/\* Now parse stsc, convert chunks into single samples and generate a
\* new stsc, stts and stsz from this information \*/
gst\_byte\_writer\_init (&stsc);
--
GitLab
From 1d534ac209e4042d08513f8cd448b9b12187aacd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?=
Date: Thu, 26 Sep 2024 09:20:28 +0300
Subject: [PATCH 05/12] qtdemux: Make sure only an even number of bytes is
processed when handling CEA608 data
An odd number of bytes would lead to out of bound reads and writes, and doesn't
make any sense as CEA608 comes in byte pairs.
Strip off any leftover bytes and assume everything before that is valid.
Thanks to Antonio Morales for finding and reporting the issue.
Fixes GHSL-2024-195
Fixes https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/3841
Part-of:
---
subprojects/gst-plugins-good/gst/isomp4/qtdemux.c | 5 +++++
1 file changed, 5 insertions(+)
diff --git a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
index dbd42817c00b..4339943e347b 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
+++ b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
@@ -6145,6 +6145,11 @@ convert\_to\_s334\_1a (const guint8 \* ccpair, guint8 ccpair\_size, guint field,
guint8 \*storage;
gsize i;
+ /\* Strip off any leftover odd bytes and assume everything before is valid \*/
+ if (ccpair\_size % 2 != 0) {
+ ccpair\_size -= 1;
+ }
+
/\* We are converting from pairs to triplets \*/
\*res = ccpair\_size / 2 \* 3;
storage = g\_malloc (\*res);
--
GitLab
From c1cd838706d29cab9479e7b5e6ec63ff8ad59b61 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?=
Date: Thu, 26 Sep 2024 14:17:02 +0300
Subject: [PATCH 06/12] qtdemux: Make sure enough data is available before
reading wave header node
Thanks to Antonio Morales for finding and reporting the issue.
Fixes GHSL-2024-236
Fixes https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/3843
Part-of:
---
.../gst-plugins-good/gst/isomp4/qtdemux.c | 84 ++++++++++---------
1 file changed, 45 insertions(+), 39 deletions(-)
diff --git a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
index 4339943e347b..062140d3dd5f 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
+++ b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
@@ -13704,47 +13704,53 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
} else {
guint32 datalen = QT\_UINT32 (stsd\_entry\_data + offset + 16);
const guint8 \*data = stsd\_entry\_data + offset + 16;
- GNode \*wavenode;
- GNode \*waveheadernode;
-
- wavenode = g\_node\_new ((guint8 \*) data);
- if (qtdemux\_parse\_node (qtdemux, wavenode, data, datalen)) {
- const guint8 \*waveheader;
- guint32 headerlen;
-
- waveheadernode = qtdemux\_tree\_get\_child\_by\_type (wavenode, fourcc);
- if (waveheadernode) {
- waveheader = (const guint8 \*) waveheadernode->data;
- headerlen = QT\_UINT32 (waveheader);
-
- if (headerlen > 8) {
- gst\_riff\_strf\_auds \*header = NULL;
- GstBuffer \*headerbuf;
- GstBuffer \*extra;
-
- waveheader += 8;
- headerlen -= 8;
-
- headerbuf = gst\_buffer\_new\_and\_alloc (headerlen);
- gst\_buffer\_fill (headerbuf, 0, waveheader, headerlen);
-
- if (gst\_riff\_parse\_strf\_auds (GST\_ELEMENT\_CAST (qtdemux),
- headerbuf, &header, &extra)) {
- gst\_caps\_unref (entry->caps);
- /\* FIXME: Need to do something with the channel reorder map \*/
- entry->caps =
- gst\_riff\_create\_audio\_caps (header->format, NULL, header,
- extra, NULL, NULL, NULL);
-
- if (extra)
- gst\_buffer\_unref (extra);
- g\_free (header);
+
+ if (len < datalen || len - datalen < offset + 16) {
+ GST\_WARNING\_OBJECT (qtdemux, "Not enough data for waveheadernode");
+ } else {
+ GNode \*wavenode;
+ GNode \*waveheadernode;
+
+ wavenode = g\_node\_new ((guint8 \*) data);
+ if (qtdemux\_parse\_node (qtdemux, wavenode, data, datalen)) {
+ const guint8 \*waveheader;
+ guint32 headerlen;
+
+ waveheadernode =
+ qtdemux\_tree\_get\_child\_by\_type (wavenode, fourcc);
+ if (waveheadernode) {
+ waveheader = (const guint8 \*) waveheadernode->data;
+ headerlen = QT\_UINT32 (waveheader);
+
+ if (headerlen > 8) {
+ gst\_riff\_strf\_auds \*header = NULL;
+ GstBuffer \*headerbuf;
+ GstBuffer \*extra;
+
+ waveheader += 8;
+ headerlen -= 8;
+
+ headerbuf = gst\_buffer\_new\_and\_alloc (headerlen);
+ gst\_buffer\_fill (headerbuf, 0, waveheader, headerlen);
+
+ if (gst\_riff\_parse\_strf\_auds (GST\_ELEMENT\_CAST (qtdemux),
+ headerbuf, &header, &extra)) {
+ gst\_caps\_unref (entry->caps);
+ /\* FIXME: Need to do something with the channel reorder map \*/
+ entry->caps =
+ gst\_riff\_create\_audio\_caps (header->format, NULL,
+ header, extra, NULL, NULL, NULL);
+
+ if (extra)
+ gst\_buffer\_unref (extra);
+ g\_free (header);
+ }
}
- }
- } else
- GST\_DEBUG ("Didn't find waveheadernode for this codec");
+ } else
+ GST\_DEBUG ("Didn't find waveheadernode for this codec");
+ }
+ g\_node\_destroy (wavenode);
}
- g\_node\_destroy (wavenode);
}
} else if (esds) {
gst\_qtdemux\_handle\_esds (qtdemux, stream, entry, esds,
--
GitLab
From 98f3934c48e6fbc03f29d58827f7cfb03d46c6a0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?=
Date: Fri, 27 Sep 2024 00:12:57 +0300
Subject: [PATCH 07/12] qtdemux: Fix length checks and offsets in stsd entry
parsing
Thanks to Antonio Morales for finding and reporting the issue.
Fixes GHSL-2024-242
Fixes https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/3845
Part-of:
---
.../gst-plugins-good/gst/isomp4/qtdemux.c | 218 +++++++-----------
1 file changed, 79 insertions(+), 139 deletions(-)
diff --git a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
index 062140d3dd5f..b6d6097f9521 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
+++ b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
@@ -12244,43 +12244,35 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
case FOURCC\_avc1:
case FOURCC\_avc3:
{
- guint len = QT\_UINT32 (stsd\_entry\_data);
+ guint32 len = QT\_UINT32 (stsd\_entry\_data);
len = len <= 0x56 ? 0 : len - 0x56;
const guint8 \*avc\_data = stsd\_entry\_data + 0x56;
/\* find avcC \*/
- while (len >= 0x8) {
- guint size;
-
- if (QT\_UINT32 (avc\_data) <= 0x8)
- size = 0;
- else if (QT\_UINT32 (avc\_data) <= len)
- size = QT\_UINT32 (avc\_data) - 0x8;
- else
- size = len - 0x8;
+ while (len >= 8) {
+ guint32 size = QT\_UINT32 (avc\_data);
- /\* No real data, so skip \*/
- if (size < 1) {
- len -= 8;
- avc\_data += 8;
- continue;
- }
+ if (size < 8 || size > len)
+ break;
- switch (QT\_FOURCC (avc\_data + 0x4)) {
+ switch (QT\_FOURCC (avc\_data + 4)) {
case FOURCC\_avcC:
{
/\* parse, if found \*/
GstBuffer \*buf;
+ if (size < 8 + 1)
+ break;
+
GST\_DEBUG\_OBJECT (qtdemux, "found avcC codec\_data in stsd");
/\* First 4 bytes are the length of the atom, the next 4 bytes
\* are the fourcc, the next 1 byte is the version, and the
\* subsequent bytes are profile\_tier\_level structure like data. \*/
gst\_codec\_utils\_h264\_caps\_set\_level\_and\_profile (entry->caps,
- avc\_data + 8 + 1, size - 1);
- buf = gst\_buffer\_new\_and\_alloc (size);
- gst\_buffer\_fill (buf, 0, avc\_data + 0x8, size);
+ avc\_data + 8 + 1, size - 8 - 1);
+ buf = gst\_buffer\_new\_and\_alloc (size - 8);
+ gst\_buffer\_fill (buf, 0, avc\_data + 8, size - 8);
gst\_caps\_set\_simple (entry->caps,
"codec\_data", GST\_TYPE\_BUFFER, buf, NULL);
gst\_buffer\_unref (buf);
@@ -12291,6 +12283,9 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
{
GstBuffer \*buf;
+ if (size < 8 + 40 + 1)
+ break;
+
GST\_DEBUG\_OBJECT (qtdemux, "found strf codec\_data in stsd");
/\* First 4 bytes are the length of the atom, the next 4 bytes
@@ -12298,17 +12293,14 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
\* next 1 byte is the version, and the
\* subsequent bytes are sequence parameter set like data. \*/
- size -= 40; /\* we'll be skipping BITMAPINFOHEADER \*/
- if (size > 1) {
- gst\_codec\_utils\_h264\_caps\_set\_level\_and\_profile
- (entry->caps, avc\_data + 8 + 40 + 1, size - 1);
+ gst\_codec\_utils\_h264\_caps\_set\_level\_and\_profile
+ (entry->caps, avc\_data + 8 + 40 + 1, size - 8 - 40 - 1);
- buf = gst\_buffer\_new\_and\_alloc (size);
- gst\_buffer\_fill (buf, 0, avc\_data + 8 + 40, size);
- gst\_caps\_set\_simple (entry->caps,
- "codec\_data", GST\_TYPE\_BUFFER, buf, NULL);
- gst\_buffer\_unref (buf);
- }
+ buf = gst\_buffer\_new\_and\_alloc (size - 8 - 40);
+ gst\_buffer\_fill (buf, 0, avc\_data + 8 + 40, size - 8 - 40);
+ gst\_caps\_set\_simple (entry->caps,
+ "codec\_data", GST\_TYPE\_BUFFER, buf, NULL);
+ gst\_buffer\_unref (buf);
break;
}
case FOURCC\_btrt:
@@ -12316,11 +12308,11 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
guint avg\_bitrate, max\_bitrate;
/\* bufferSizeDB, maxBitrate and avgBitrate - 4 bytes each \*/
- if (size < 12)
+ if (size < 8 + 12)
break;
- max\_bitrate = QT\_UINT32 (avc\_data + 0xc);
- avg\_bitrate = QT\_UINT32 (avc\_data + 0x10);
+ max\_bitrate = QT\_UINT32 (avc\_data + 8 + 4);
+ avg\_bitrate = QT\_UINT32 (avc\_data + 8 + 8);
if (!max\_bitrate && !avg\_bitrate)
break;
@@ -12352,8 +12344,8 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
break;
}
- len -= size + 8;
- avc\_data += size + 8;
+ len -= size;
+ avc\_data += size;
}
break;
@@ -12364,44 +12356,36 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
case FOURCC\_dvh1:
case FOURCC\_dvhe:
{
- guint len = QT\_UINT32 (stsd\_entry\_data);
+ guint32 len = QT\_UINT32 (stsd\_entry\_data);
len = len <= 0x56 ? 0 : len - 0x56;
const guint8 \*hevc\_data = stsd\_entry\_data + 0x56;
/\* find hevc \*/
- while (len >= 0x8) {
- guint size;
-
- if (QT\_UINT32 (hevc\_data) <= 0x8)
- size = 0;
- else if (QT\_UINT32 (hevc\_data) <= len)
- size = QT\_UINT32 (hevc\_data) - 0x8;
- else
- size = len - 0x8;
+ while (len >= 8) {
+ guint32 size = QT\_UINT32 (hevc\_data);
- /\* No real data, so skip \*/
- if (size < 1) {
- len -= 8;
- hevc\_data += 8;
- continue;
- }
+ if (size < 8 || size > len)
+ break;
- switch (QT\_FOURCC (hevc\_data + 0x4)) {
+ switch (QT\_FOURCC (hevc\_data + 4)) {
case FOURCC\_hvcC:
{
/\* parse, if found \*/
GstBuffer \*buf;
+ if (size < 8 + 1)
+ break;
+
GST\_DEBUG\_OBJECT (qtdemux, "found hvcC codec\_data in stsd");
/\* First 4 bytes are the length of the atom, the next 4 bytes
\* are the fourcc, the next 1 byte is the version, and the
\* subsequent bytes are sequence parameter set like data. \*/
gst\_codec\_utils\_h265\_caps\_set\_level\_tier\_and\_profile
- (entry->caps, hevc\_data + 8 + 1, size - 1);
+ (entry->caps, hevc\_data + 8 + 1, size - 8 - 1);
- buf = gst\_buffer\_new\_and\_alloc (size);
- gst\_buffer\_fill (buf, 0, hevc\_data + 0x8, size);
+ buf = gst\_buffer\_new\_and\_alloc (size - 8);
+ gst\_buffer\_fill (buf, 0, hevc\_data + 8, size - 8);
gst\_caps\_set\_simple (entry->caps,
"codec\_data", GST\_TYPE\_BUFFER, buf, NULL);
gst\_buffer\_unref (buf);
@@ -12410,8 +12394,8 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
default:
break;
}
- len -= size + 8;
- hevc\_data += size + 8;
+ len -= size;
+ hevc\_data += size;
}
break;
}
@@ -12791,36 +12775,25 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
}
case FOURCC\_vc\_1:
{
- guint len = QT\_UINT32 (stsd\_entry\_data);
+ guint32 len = QT\_UINT32 (stsd\_entry\_data);
len = len <= 0x56 ? 0 : len - 0x56;
const guint8 \*vc1\_data = stsd\_entry\_data + 0x56;
/\* find dvc1 \*/
while (len >= 8) {
- guint size;
-
- if (QT\_UINT32 (vc1\_data) <= 8)
- size = 0;
- else if (QT\_UINT32 (vc1\_data) <= len)
- size = QT\_UINT32 (vc1\_data) - 8;
- else
- size = len - 8;
+ guint32 size = QT\_UINT32 (vc1\_data);
- /\* No real data, so skip \*/
- if (size < 1) {
- len -= 8;
- vc1\_data += 8;
- continue;
- }
+ if (size < 8 || size > len)
+ break;
- switch (QT\_FOURCC (vc1\_data + 0x4)) {
+ switch (QT\_FOURCC (vc1\_data + 4)) {
case GST\_MAKE\_FOURCC ('d', 'v', 'c', '1'):
{
GstBuffer \*buf;
GST\_DEBUG\_OBJECT (qtdemux, "found dvc1 codec\_data in stsd");
- buf = gst\_buffer\_new\_and\_alloc (size);
- gst\_buffer\_fill (buf, 0, vc1\_data + 8, size);
+ buf = gst\_buffer\_new\_and\_alloc (size - 8);
+ gst\_buffer\_fill (buf, 0, vc1\_data + 8, size - 8);
gst\_caps\_set\_simple (entry->caps,
"codec\_data", GST\_TYPE\_BUFFER, buf, NULL);
gst\_buffer\_unref (buf);
@@ -12829,36 +12802,25 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
default:
break;
}
- len -= size + 8;
- vc1\_data += size + 8;
+ len -= size;
+ vc1\_data += size;
}
break;
}
case FOURCC\_av01:
{
- guint len = QT\_UINT32 (stsd\_entry\_data);
+ guint32 len = QT\_UINT32 (stsd\_entry\_data);
len = len <= 0x56 ? 0 : len - 0x56;
const guint8 \*av1\_data = stsd\_entry\_data + 0x56;
/\* find av1C \*/
- while (len >= 0x8) {
- guint size;
-
- if (QT\_UINT32 (av1\_data) <= 0x8)
- size = 0;
- else if (QT\_UINT32 (av1\_data) <= len)
- size = QT\_UINT32 (av1\_data) - 0x8;
- else
- size = len - 0x8;
+ while (len >= 8) {
+ guint32 size = QT\_UINT32 (av1\_data);
- /\* No real data, so skip \*/
- if (size < 1) {
- len -= 8;
- av1\_data += 8;
- continue;
- }
+ if (size < 8 || size > len)
+ break;
- switch (QT\_FOURCC (av1\_data + 0x4)) {
+ switch (QT\_FOURCC (av1\_data + 4)) {
case FOURCC\_av1C:
{
/\* parse, if found \*/
@@ -12868,7 +12830,7 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
"found av1C codec\_data in stsd of size %d", size);
/\* not enough data, just ignore and hope for the best \*/
- if (size < 4)
+ if (size < 8 + 4)
break;
/\* Content is:
@@ -12917,9 +12879,9 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
(gint) (pres\_delay\_field & 0x0F) + 1, NULL);
}
- buf = gst\_buffer\_new\_and\_alloc (size);
+ buf = gst\_buffer\_new\_and\_alloc (size - 8);
GST\_BUFFER\_FLAG\_SET (buf, GST\_BUFFER\_FLAG\_HEADER);
- gst\_buffer\_fill (buf, 0, av1\_data + 8, size);
+ gst\_buffer\_fill (buf, 0, av1\_data + 8, size - 8);
gst\_caps\_set\_simple (entry->caps,
"codec\_data", GST\_TYPE\_BUFFER, buf, NULL);
gst\_buffer\_unref (buf);
@@ -12937,8 +12899,8 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
break;
}
- len -= size + 8;
- av1\_data += size + 8;
+ len -= size;
+ av1\_data += size;
}
break;
@@ -12949,29 +12911,18 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
\* vp08, vp09, and vp10 fourcc. \*/
case FOURCC\_vp09:
{
- guint len = QT\_UINT32 (stsd\_entry\_data);
+ guint32 len = QT\_UINT32 (stsd\_entry\_data);
len = len <= 0x56 ? 0 : len - 0x56;
const guint8 \*vpcc\_data = stsd\_entry\_data + 0x56;
/\* find vpcC \*/
- while (len >= 0x8) {
- guint size;
-
- if (QT\_UINT32 (vpcc\_data) <= 0x8)
- size = 0;
- else if (QT\_UINT32 (vpcc\_data) <= len)
- size = QT\_UINT32 (vpcc\_data) - 0x8;
- else
- size = len - 0x8;
+ while (len >= 8) {
+ guint32 size = QT\_UINT32 (vpcc\_data);
- /\* No real data, so skip \*/
- if (size < 1) {
- len -= 8;
- vpcc\_data += 8;
- continue;
- }
+ if (size < 8 || size > len)
+ break;
- switch (QT\_FOURCC (vpcc\_data + 0x4)) {
+ switch (QT\_FOURCC (vpcc\_data + 4)) {
case FOURCC\_vpcC:
{
const gchar \*profile\_str = NULL;
@@ -12987,7 +12938,7 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
/\* the meaning of "size" is length of the atom body, excluding
\* atom length and fourcc fields \*/
- if (size < 12)
+ if (size < 8 + 12)
break;
/\* Content is:
@@ -13093,8 +13044,8 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
break;
}
- len -= size + 8;
- vpcc\_data += size + 8;
+ len -= size;
+ vpcc\_data += size;
}
break;
@@ -13435,7 +13386,7 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
}
case FOURCC\_wma\_:
{
- guint len = QT\_UINT32 (stsd\_entry\_data);
+ guint32 len = QT\_UINT32 (stsd\_entry\_data);
len = len <= offset ? 0 : len - offset;
const guint8 \*wfex\_data = stsd\_entry\_data + offset;
const gchar \*codec\_name = NULL;
@@ -13460,21 +13411,10 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
/\* find wfex \*/
while (len >= 8) {
- guint size;
+ guint32 size = QT\_UINT32 (wfex\_data);
- if (QT\_UINT32 (wfex\_data) <= 0x8)
- size = 0;
- else if (QT\_UINT32 (wfex\_data) <= len)
- size = QT\_UINT32 (wfex\_data) - 8;
- else
- size = len - 8;
-
- /\* No real data, so skip \*/
- if (size < 1) {
- len -= 8;
- wfex\_data += 8;
- continue;
- }
+ if (size < 8 || size > len)
+ break;
switch (QT\_FOURCC (wfex\_data + 4)) {
case GST\_MAKE\_FOURCC ('w', 'f', 'e', 'x'):
@@ -13519,12 +13459,12 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
"width", G\_TYPE\_INT, wfex.wBitsPerSample,
"depth", G\_TYPE\_INT, wfex.wBitsPerSample, NULL);
- if (size > wfex.cbSize) {
+ if (size > 8 + wfex.cbSize) {
GstBuffer \*buf;
- buf = gst\_buffer\_new\_and\_alloc (size - wfex.cbSize);
+ buf = gst\_buffer\_new\_and\_alloc (size - 8 - wfex.cbSize);
gst\_buffer\_fill (buf, 0, wfex\_data + 8 + wfex.cbSize,
- size - wfex.cbSize);
+ size - 8 - wfex.cbSize);
gst\_caps\_set\_simple (entry->caps,
"codec\_data", GST\_TYPE\_BUFFER, buf, NULL);
gst\_buffer\_unref (buf);
@@ -13541,8 +13481,8 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
default:
break;
}
- len -= size + 8;
- wfex\_data += size + 8;
+ len -= size;
+ wfex\_data += size;
}
break;
}
--
GitLab
From 4a0e8bf92bdb28845e555654135fcf75173d11b3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?=
Date: Fri, 27 Sep 2024 09:47:50 +0300
Subject: [PATCH 08/12] qtdemux: Fix error handling when parsing cenc sample
groups fails
Thanks to Antonio Morales for finding and reporting the issue.
Fixes GHSL-2024-238, GHSL-2024-239, GHSL-2024-240
Fixes https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/3846
Part-of:
---
.../gst-plugins-good/gst/isomp4/qtdemux.c | 25 ++++++++++++++-----
1 file changed, 19 insertions(+), 6 deletions(-)
diff --git a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
index b6d6097f9521..127ed77f6dba 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
+++ b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
@@ -3834,7 +3834,7 @@ qtdemux\_get\_cenc\_sample\_properties (GstQTDemux \* qtdemux,
static gboolean
qtdemux\_parse\_sbgp (GstQTDemux \* qtdemux, QtDemuxStream \* stream,
GstByteReader \* br, guint32 group, GPtrArray \*\* sample\_to\_group\_array,
- GstStructure \* default\_properties, GPtrArray \* tack\_properties\_array,
+ GstStructure \* default\_properties, GPtrArray \* track\_properties\_array,
GPtrArray \* group\_properties\_array)
{
guint32 flags = 0;
@@ -3893,15 +3893,15 @@ qtdemux\_parse\_sbgp (GstQTDemux \* qtdemux, QtDemuxStream \* stream,
if (index > 0x10000) {
/\* Index is referring the current fragment. \*/
index -= 0x10001;
- if (index < group\_properties\_array->len)
+ if (group\_properties\_array && index < group\_properties\_array->len)
properties = g\_ptr\_array\_index (group\_properties\_array, index);
else
GST\_ERROR\_OBJECT (qtdemux, "invalid group index %u", index);
} else if (index > 0) {
/\* Index is referring to the whole track. \*/
index--;
- if (index < tack\_properties\_array->len)
- properties = g\_ptr\_array\_index (tack\_properties\_array, index);
+ if (track\_properties\_array && index < track\_properties\_array->len)
+ properties = g\_ptr\_array\_index (track\_properties\_array, index);
else
GST\_ERROR\_OBJECT (qtdemux, "invalid group index %u", index);
} else {
@@ -4452,6 +4452,11 @@ qtdemux\_parse\_moof (GstQTDemux \* qtdemux, const guint8 \* buffer, guint length,
GNode \*sgpd\_node;
GstByteReader sgpd\_data;
+ if (!info) {
+ GST\_ERROR\_OBJECT (qtdemux, "Have no valid protection scheme info");
+ goto fail;
+ }
+
if (info->fragment\_group\_properties) {
g\_ptr\_array\_free (info->fragment\_group\_properties, TRUE);
info->fragment\_group\_properties = NULL;
@@ -11965,12 +11970,15 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
if (stream->subtype != FOURCC\_soun) {
GST\_ERROR\_OBJECT (qtdemux,
"Unexpeced stsd type 'aavd' outside 'soun' track");
+ goto corrupt\_file;
} else {
/\* encrypted audio with sound sample description v0 \*/
GNode \*enc = qtdemux\_tree\_get\_child\_by\_type (stsd, fourcc);
stream->protected = TRUE;
- if (!qtdemux\_parse\_protection\_aavd (qtdemux, stream, enc, &fourcc))
+ if (!qtdemux\_parse\_protection\_aavd (qtdemux, stream, enc, &fourcc)) {
GST\_ERROR\_OBJECT (qtdemux, "Failed to parse protection scheme info");
+ goto corrupt\_file;
+ }
}
}
@@ -11979,8 +11987,10 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
\* with the same type \*/
GNode \*enc = qtdemux\_tree\_get\_child\_by\_type (stsd, fourcc);
stream->protected = TRUE;
- if (!qtdemux\_parse\_protection\_scheme\_info (qtdemux, stream, enc, &fourcc))
+ if (!qtdemux\_parse\_protection\_scheme\_info (qtdemux, stream, enc, &fourcc)) {
GST\_ERROR\_OBJECT (qtdemux, "Failed to parse protection scheme info");
+ goto corrupt\_file;
+ }
}
if (stream->subtype == FOURCC\_vide) {
@@ -14078,6 +14088,9 @@ qtdemux\_parse\_trak (GstQTDemux \* qtdemux, GNode \* trak)
GNode \*sgpd\_node;
GstByteReader sgpd\_data;
+ if (!info)
+ goto corrupt\_file;
+
if (info->track\_group\_properties) {
g\_ptr\_array\_free (info->fragment\_group\_properties, TRUE);
info->fragment\_group\_properties = NULL;
--
GitLab
From 19359e2b2548927cbfd46a526d704cce5a65c2b1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?=
Date: Fri, 27 Sep 2024 10:38:50 +0300
Subject: [PATCH 09/12] qtdemux: Make sure there are enough offsets to read
when parsing samples
While this specific case is also caught when initializing co\_chunk, the error
is ignored in various places and calling into the function would lead to out of
bounds reads if the error message doesn't cause the pipeline to be shut down
fast enough.
To avoid this, no matter what, make sure enough offsets are available when
parsing them. While this is potentially slower, the same is already done in the
non-chunks\_are\_samples case.
Thanks to Antonio Morales for finding and reporting the issue.
Fixes GHSL-2024-245
Fixes https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/3847
Part-of:
---
subprojects/gst-plugins-good/gst/isomp4/qtdemux.c | 6 +++---
1 file changed, 3 insertions(+), 3 deletions(-)
diff --git a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
index 127ed77f6dba..07272f38c421 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
+++ b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
@@ -10635,9 +10635,9 @@ qtdemux\_parse\_samples (GstQTDemux \* qtdemux, QtDemuxStream \* stream, guint32 n)
goto done;
}
- cur->offset =
- qt\_atom\_parser\_get\_offset\_unchecked (&stream->co\_chunk,
- stream->co\_size);
+ if (!qt\_atom\_parser\_get\_offset (&stream->co\_chunk,
+ stream->co\_size, &cur->offset))
+ goto corrupt\_file;
GST\_LOG\_OBJECT (qtdemux, "Created entry %d with offset "
"%" G\_GUINT64\_FORMAT, j, cur->offset);
--
GitLab
From 7d3f221d8795cd6910f375774a50ffe7c19d0538 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?=
Date: Fri, 27 Sep 2024 10:39:30 +0300
Subject: [PATCH 10/12] qtdemux: Actually handle errors returns from various
functions instead of ignoring them
Ignoring them might cause the element to continue as if all is fine despite the
internal state being inconsistent. This can lead to all kinds of follow-up
issues, including memory safety issues.
Thanks to Antonio Morales for finding and reporting the issue.
Fixes GHSL-2024-245
Fixes https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/3847
Part-of:
---
.../gst-plugins-good/gst/isomp4/qtdemux.c | 29 +++++++++++++++----
1 file changed, 23 insertions(+), 6 deletions(-)
diff --git a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
index 07272f38c421..4b9ce20ad37b 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
+++ b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
@@ -5211,10 +5211,15 @@ gst\_qtdemux\_loop\_state\_header (GstQTDemux \* qtdemux)
beach:
if (ret == GST\_FLOW\_EOS && (qtdemux->got\_moov || qtdemux->media\_caps)) {
/\* digested all data, show what we have \*/
- qtdemux\_prepare\_streams (qtdemux);
+ ret = qtdemux\_prepare\_streams (qtdemux);
+ if (ret != GST\_FLOW\_OK)
+ return ret;
+
QTDEMUX\_EXPOSE\_LOCK (qtdemux);
ret = qtdemux\_expose\_streams (qtdemux);
QTDEMUX\_EXPOSE\_UNLOCK (qtdemux);
+ if (ret != GST\_FLOW\_OK)
+ return ret;
qtdemux->state = QTDEMUX\_STATE\_MOVIE;
GST\_DEBUG\_OBJECT (qtdemux, "switching state to STATE\_MOVIE (%d)",
@@ -8118,13 +8123,21 @@ gst\_qtdemux\_process\_adapter (GstQTDemux \* demux, gboolean force)
gst\_qtdemux\_stream\_concat (demux,
demux->old\_streams, demux->active\_streams);
- qtdemux\_parse\_moov (demux, data, demux->neededbytes);
+ if (!qtdemux\_parse\_moov (demux, data, demux->neededbytes)) {
+ ret = GST\_FLOW\_ERROR;
+ break;
+ }
qtdemux\_node\_dump (demux, demux->moov\_node);
qtdemux\_parse\_tree (demux);
- qtdemux\_prepare\_streams (demux);
+ ret = qtdemux\_prepare\_streams (demux);
+ if (ret != GST\_FLOW\_OK)
+ break;
+
QTDEMUX\_EXPOSE\_LOCK (demux);
- qtdemux\_expose\_streams (demux);
+ ret = qtdemux\_expose\_streams (demux);
QTDEMUX\_EXPOSE\_UNLOCK (demux);
+ if (ret != GST\_FLOW\_OK)
+ break;
demux->got\_moov = TRUE;
@@ -8215,8 +8228,10 @@ gst\_qtdemux\_process\_adapter (GstQTDemux \* demux, gboolean force)
/\* in MSS we need to expose the pads after the first moof as we won't get a moov \*/
if (demux->variant == VARIANT\_MSS\_FRAGMENTED && !demux->exposed) {
QTDEMUX\_EXPOSE\_LOCK (demux);
- qtdemux\_expose\_streams (demux);
+ ret = qtdemux\_expose\_streams (demux);
QTDEMUX\_EXPOSE\_UNLOCK (demux);
+ if (ret != GST\_FLOW\_OK)
+ goto done;
}
gst\_qtdemux\_check\_send\_pending\_segment (demux);
@@ -14368,8 +14383,10 @@ qtdemux\_prepare\_streams (GstQTDemux \* qtdemux)
/\* parse the initial sample for use in setting the frame rate cap \*/
while (sample\_num == 0 && sample\_num < stream->n\_samples) {
- if (!qtdemux\_parse\_samples (qtdemux, stream, sample\_num))
+ if (!qtdemux\_parse\_samples (qtdemux, stream, sample\_num)) {
+ ret = GST\_FLOW\_ERROR;
break;
+ }
++sample\_num;
}
}
--
GitLab
From bfebca8307ae79223616fd27e8b402118787d394 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?=
Date: Thu, 26 Sep 2024 19:16:19 +0300
Subject: [PATCH 11/12] qtdemux: Check for invalid atom length when extracting
Closed Caption data
Thanks to Antonio Morales for finding and reporting the issue.
Fixes GHSL-2024-243
Fixes https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/3849
Part-of:
---
subprojects/gst-plugins-good/gst/isomp4/qtdemux.c | 2 +-
1 file changed, 1 insertion(+), 1 deletion(-)
diff --git a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
index 4b9ce20ad37b..7731b2c2c93b 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
+++ b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
@@ -6193,7 +6193,7 @@ extract\_cc\_from\_data (QtDemuxStream \* stream, const guint8 \* data, gsize size,
goto invalid\_cdat;
atom\_length = QT\_UINT32 (data);
fourcc = QT\_FOURCC (data + 4);
- if (G\_UNLIKELY (atom\_length > size || atom\_length == 8))
+ if (G\_UNLIKELY (atom\_length > size || atom\_length <= 8))
goto invalid\_cdat;
GST\_DEBUG\_OBJECT (stream->pad, "here");
--
GitLab
From 519d86d9f36d80eb64148cd2d330b28a28be2755 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?=
Date: Fri, 27 Sep 2024 00:31:36 +0300
Subject: [PATCH 12/12] qtdemux: Add size check for parsing SMI / SEQH atom
Thanks to Antonio Morales for finding and reporting the issue.
Fixes GHSL-2024-244
Fixes https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/3853
Part-of:
---
subprojects/gst-plugins-good/gst/isomp4/qtdemux.c | 3 ++-
1 file changed, 2 insertions(+), 1 deletion(-)
diff --git a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
index 7731b2c2c93b..5422e9f1d6f8 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
+++ b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
@@ -11198,8 +11198,9 @@ qtdemux\_parse\_svq3\_stsd\_data (GstQTDemux \* qtdemux,
GST\_WARNING\_OBJECT (qtdemux, "Unexpected second SEQH SMI atom "
" found, ignoring");
} else {
+ /\* Note: The size does \*not\* include the fourcc and the size field itself \*/
seqh\_size = QT\_UINT32 (data + 4);
- if (seqh\_size > 0) {
+ if (seqh\_size > 0 && seqh\_size <= size - 8) {
\_seqh = gst\_buffer\_new\_and\_alloc (seqh\_size);
gst\_buffer\_fill (\_seqh, 0, data + 8, seqh\_size);
}
--
GitLab


=== Content from gitlab.freedesktop.org_5df6644d_20250115_111933.html ===


[Skip to content](#content-body)
GitLab
[![](data:image/gif;base64...)](/ "Homepage")

* [Explore](/explore)

* [Sign in](/users/sign_in?redirect_to_referer=yes)
* [Register](/users/sign_up)

## Admin message

Due to an influx of spam, we have had to impose restrictions on new accounts. Please see [this wiki page](https://gitlab.freedesktop.org/freedesktop/freedesktop/-/wikis/home) for instructions on how to get full permissions. Sorry for the inconvenience.

![GStreamer](/uploads/-/system/group/avatar/1152/gst-logo-small.png?width=48)
# GStreamer

GStreamer open-source multimedia framework

Read more



=== Content from gstreamer.freedesktop.org_6df139fc_20250115_111934.html ===


| | [GStreamer](/) |  | | --- | --- | |  | | | open source multimedia framework | | |
| --- | --- | --- | --- | --- | --- | --- |

| |  | | --- | | |  | | | --- | --- | | [Home](/) |  | |  | | | | [Features](/features/) |  | |  | | | | [News](/news/) |  | |  | | | | [Annual Conference](/conference/) |  | |  | | | | [Planet (Blogs)](/planet/) |  | |  | | | | [Download](/download/) |  | |  | | | | [Applications](/apps/) |  | |  | | | |  |  | |  | | | | [Security Center](/security/) |  | |  | | | | [GitLab](https://gitlab.freedesktop.org/gstreamer/) |  | |  | | | | [Developers](/dev/) |  | |  | | | | [Documentation](/documentation/) |  | |  | | | | [Forum](https://discourse.gstreamer.org) |  | |  | | | | [File a Bug](/documentation/contribute/index.html) |  | |  | | | |  |  | |  | | | | [Artwork](/artwork/) |  | |  | | | | [@gstreamer on Twitter](http://twitter.com/gstreamer) |  | |  | | | | [@gstreamer on Mastodon](https://floss.social/%40GStreamer) |  | |  | | | | [#gstreamer on Matrix](https://matrix.to/#/#gstreamer:gstreamer.org) |  | |  | | | | |  | | News - GStreamer 1.25.1 unstable development release | | | --- | --- | | The GStreamer team is pleased to announce the first development release in the unstable 1.25 release series.  The unstable 1.25 release series is for testing and development purposes in the lead-up to the stable 1.26 series which is scheduled for release ASAP. Any newly-added API can still change until that point.  This development release is primarily for developers and early adopters.  The plan is to get 1.26 out of the door as quickly as possible.  Binaries for Android, iOS, Mac OS X and Windows will be made available shortly at the [usual location](https://gstreamer.freedesktop.org/pkg/).  Release tarballs can be downloaded directly here:  * [gstreamer-1.25.1.tar.xz](/src/gstreamer/gstreamer-1.25.1.tar.xz) * [gst-plugins-base-1.25.1.tar.xz](/src/gst-plugins-base/gst-plugins-base-1.25.1.tar.xz) * [gst-plugins-good-1.25.1.tar.xz](/src/gst-plugins-good/gst-plugins-good-1.25.1.tar.xz) * [gst-plugins-ugly-1.25.1.tar.xz](/src/gst-plugins-ugly/gst-plugins-ugly-1.25.1.tar.xz) * [gst-plugins-bad-1.25.1.tar.xz](/src/gst-plugins-bad/gst-plugins-bad-1.25.1.tar.xz) * [gst-libav-1.25.1.tar.xz](/src/gst-libav/gst-libav-1.25.1.tar.xz) * [gst-rtsp-server-1.25.1.tar.xz](/src/gst-rtsp-server/gst-rtsp-server-1.25.1.tar.xz) * [gst-python-1.25.1.tar.xz](/src/gst-python/gst-python-1.25.1.tar.xz) * [gst-editing-services-1.25.1.tar.xz](/src/gst-editing-services/gst-editing-services-1.25.1.tar.xz) * [gst-devtools-1.25.1.tar.xz](/src/gst-devtools/gst-devtools-1.25.1.tar.xz), * [gstreamer-vaapi-1.25.1.tar.xz](/src/gstreamer-vaapi/gstreamer-vaapi-1.25.1.tar.xz) * [gstreamer-docs-1.25.1.tar.xz](/src/gstreamer-docs/gstreamer-docs-1.25.1.tar.xz)  As always, please give it a spin and let us know of any issues you run into by filing an issue in [GitLab](https://gitlab.freedesktop.org/gstreamer/gstreamer/). | 2025-01-14 17:00 | | Recent older news: | | | GStreamer 1.24.11 stable bug fix release | 2025-01-06 23:30 | | GStreamer 1.24.10 stable bug fix release | 2024-12-03 23:30 | | Click for [even older news](news/)... | | News feeds: [[RSS 1.0]](news/rss-1.0.xml) |  What is GStreamer?  | GStreamer is a library for constructing graphs of media-handling components. The applications it supports range from simple Ogg/Vorbis playback, audio/video streaming to complex audio (mixing) and video (non-linear editing) processing.  Applications can take advantage of advances in codec and filter technology transparently. Developers can add new codecs and filters by writing a simple plugin with a clean, generic interface. [Read more ...](features/index.html)  GStreamer is released under the LGPL. The 1.x series is API and ABI stable and supersedes the previous stable 0.10 series. Both can be installed in parallel. | [gst-player gtk+ backend playing Sintel](/data/images/gtk-play-sintel.png) | | --- | --- | |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

|

|  |
|

| *Report [a problem](https://gitlab.freedesktop.org/gstreamer/www/issues/new?issue%5Btitle%5D=%0AIssue%20with%20page%20%22GStreamer:%20open%20source%20multimedia%20framework%22%0A%20%20%20%20%20%20%20%20%20%20%20%20) on this page.* |



=== Content from discourse.gstreamer.org_0f4ef6e4_20250115_111934.html ===


![GStreamer Discourse](data:image/svg;base64...)
Loading

[GStreamer Discourse](/)

| Category | Topics |
| --- | --- |
| [News and Announcements](/c/news/5)New releases, events and project news | 35 |
| [Plugin and library development](/c/plugin-dev/6)Support and questions about developing GStreamer itself | 73 |
| [Application Development](/c/app-dev/7)Support and questions about using GStreamer | 558 |
| [Showcase and Tips](/c/showcase/10)Usage of GStreamer and tips | 1 |
| [General Discussion](/c/general/4)Discussion revolving around GStreamer which does’t fit in the other categories | 458 |
| [Newcomers](/c/newcomers/11)New to GStreamer ? This is your place | 87 |
| [Site Feedback](/c/site-feedback/2) Discussion about this site, its organization, how it works, and how we can improve it. | 4 |

* [Home](/)
* [Categories](/categories)
* [Guidelines](/guidelines)
* [Terms of Service](/tos)
* [Privacy Policy](/privacy)

Powered by [Discourse](https://www.discourse.org), best viewed with JavaScript enabled



=== Content from gstreamer.freedesktop.org_b62d2a9f_20250114_181312.html ===


| | [GStreamer](/) |  | | --- | --- | |  | | | open source multimedia framework | | |
| --- | --- | --- | --- | --- | --- | --- |

| |  | | --- | | |  | | | --- | --- | | [Home](/) |  | |  | | | | [Features](/features/) |  | |  | | | | [News](/news/) |  | |  | | | | [Annual Conference](/conference/) |  | |  | | | | [Planet (Blogs)](/planet/) |  | |  | | | | [Download](/download/) |  | |  | | | | [Applications](/apps/) |  | |  | | | |  |  | |  | | | | [Security Center](/security/) |  | |  | | | | [GitLab](https://gitlab.freedesktop.org/gstreamer/) |  | |  | | | | [Developers](/dev/) |  | |  | | | | [Documentation](/documentation/) |  | |  | | | | [Forum](https://discourse.gstreamer.org) |  | |  | | | | [File a Bug](/documentation/contribute/index.html) |  | |  | | | |  |  | |  | | | | [Artwork](/artwork/) |  | |  | | | | [@gstreamer on Twitter](http://twitter.com/gstreamer) |  | |  | | | | [@gstreamer on Mastodon](https://floss.social/%40GStreamer) |  | |  | | | | [#gstreamer on Matrix](https://matrix.to/#/#gstreamer:gstreamer.org) |  | |  | | | | |  | Security Advisory 2024-0005 (GHSL-2024-094, GHSL-2024-237, GHSL-2024-241, CVE-2024-47537)  |  |  | | --- | --- | | Summary | Integer overflow in MP4/MOV sample table parser leading to out-of-bounds writes | | Date | 2024-12-03 20:00 | | Affected Versions | GStreamer gst-plugins-good < 1.24.10 | | IDs | GStreamer-SA-2024-0005GHSL-2024-094, GHSL-2024-237, GHSL-2024-241CVE-2024-47537 |  Details Integer overflow in the MP4/MOV demuxer's sample table parser that can lead to out-of-bounds writes and NULL-pointer dereferences for certain input files. Impact It is possible for a malicious third party to trigger an out-of-bounds write or NULL-pointer dereferences that result in a crash of the application, and, in case of out-of-bounds writes, possibly also allow code execution through heap manipulation. Solution The gst-plugins-good 1.24.10 release addresses the issue. People using older branches of GStreamer should apply the patch and recompile. ReferencesThe GStreamer project  * <https://gstreamer.freedesktop.org>  CVE Database Entries  * [CVE-2024-47537](https://www.cve.org/CVERecord?id=CVE-2024-47537)  GStreamer releases1.24 (current stable)  * [GStreamer 1.24.10 release notes](/releases/1.24/#1.24.10) * [GStreamer Plugins Good 1.24.10](/src/gst-plugins-good/gst-plugins-good-1.24.10.tar.xz)  Patches  * [Patch](https://gitlab.freedesktop.org/gstreamer/gstreamer/-/merge_requests/8059.patch) |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

|

|  |
|

| *Report [a problem](https://gitlab.freedesktop.org/gstreamer/www/issues/new?issue%5Btitle%5D=%0AIssue%20with%20page%20%22GStreamer%20Security%20Advisory%22%0A%20%20%20%20%20%20%20%20%20%20%20%20) on this page.* |



=== Content from floss.social_e017a45b_20250115_111933.html ===

![Mastodon](/packs/media/images/logo-d4b5dc90fd3e117d141ae7053b157f58.svg)
To use the Mastodon web application, please enable JavaScript. Alternatively, try one of the [native apps](https://joinmastodon.org/apps) for Mastodon for your platform.



=== Content from matrix.to_c585fbad_20250115_111932.html ===


# Please enable javascript

Matrix.to is a preview service from chat rooms, people and communities on [Matrix](https://matrix.org).

It preserves your privacy by only processing what you view on the client side. For this to work, it needs javascript.


