=== Content from news.ycombinator.com_b6d4263b_20250114_183601.html ===


| |  | **[Hacker News](news)** [new](newest) | [past](front) | [comments](newcomments) | <ask> | <show> | <jobs> | <submit> | [login](login?goto=item%3Fid%3D42256409) | | --- | --- | --- | |
| --- | --- | --- | --- |
|
| |  |  | [Emacs arbitrary code execution and how to avoid it](https://eshelyaron.com/posts/2024-11-27-emacs-aritrary-code-execution-and-how-to-avoid-it.html) ([eshelyaron.com](from?site=eshelyaron.com)) | | --- | --- | --- | |  | | 139 points by [oskardrums](user?id=oskardrums) [48 days ago](item?id=42256409)  | [hide](hide?id=42256409&goto=item%3Fid%3D42256409) | [past](https://hn.algolia.com/?query=Emacs%20arbitrary%20code%20execution%20and%20how%20to%20avoid%20it&type=story&dateRange=all&sort=byDate&storyText=false&prefix&page=0) | [favorite](fave?id=42256409&auth=56886e5fe820858817cd4abed7458f15de6a50aa) | [147 comments](item?id=42256409) |  | |  |  | [hollerith](user?id=hollerith) [48 days ago](item?id=42256625)   | [next](#42256679) [–]  Long time Emacs Lisp coder here. Here is a summary of the vulnerability described in the OP: Anyone wishing to inspect an untrusted file of Emacs Lisp code is likely to use Emacs to do the inspecting, but if either of the popular packages Flymake and Flycheck is enabled, merely *opening* the untrusted file gives the author of the file the ability to run arbitrary code (because macros are tricky). Even if an Emacs user avoids Flymake and Flycheck, the standard emacs facility for "completing" the names of functions and variables has the same basic vulnerability. Specifically, if the user uses Emacs to open the file, then types the start of the name of a function or variable, then types M-tab (i.e., presses the escape key, then presses the tab key) which attempts to fill in the rest of the name so that user does not have to manually type out the whole name, the arbitrary code is run. It is clear to me (who was never tempted to use Flymake or Flycheck) what remediation I want: namely I want this "M-tab" functionality (which I have been using and probably most Emacs users have been using) to refrain completely from expanding any macros even though doing so will prevent it from finding out the names of some of the functions and variables I might be trying to insert with the result that sometimes I will have to type out the full name of the function or variable, without assistance. >AFAICT the earliest public discussion about the security implications of Emacs Lisp macros started in August 2018, when Wilfred Hughes noted that code completion can lead to arbitrary code execution via macro-expansion. The fact that the maintainers have yet to fix this is one more sign added to a list of 5 or 6 other signs that make me want to migrate away from Emacs. | | --- | --- | --- | | | --- | --- | --- | --- | | |  |  | [uludag](user?id=uludag) [48 days ago](item?id=42256796)   | [parent](#42256625) | [next](#42259561) [–]  Giving the maintainers the benefit of the doubt, I think the optimal solution solution would require a lot of thought and work. While I have no doubt that Elisp is an environment especially ripe for these kinds of exploits, it's by no means unique to Emacs. Just look at VSCode's solution to this problem: <https://code.visualstudio.com/docs/editor/workspace-trust> . | | --- | --- | --- | | | |  |  | [hollerith](user?id=hollerith) [48 days ago](item?id=42257089)   | [root](#42256625) | [parent](#42256796) | [next](#42259561) [–]  I strongly prefer vscode's solution to the current state of affairs in Emacs. | | --- | --- | --- | | | |  |  | [uludag](user?id=uludag) [48 days ago](item?id=42257370)   | [root](#42256625) | [parent](#42257089) | [next](#42258020) [–]  I have no doubt that VSCode has a much less risk of executing code by opening something. Ironically however, it seems that VSCode's extension is the most effective channel to distribute malware in the history of code editors. [1] [2] Not that MELPA couldn't be used to distribute malware either, I just think, as another poster mentioned, these problems are almost more social than technical. [1] [https://www.bleepingcomputer.com/news/security/malicious-vsc...](https://www.bleepingcomputer.com/news/security/malicious-vscode-extensions-with-millions-of-installs-discovered/) [2] <https://arxiv.org/html/2411.07479v1> | | --- | --- | --- | | | |  |  | [alwayslikethis](user?id=alwayslikethis) [47 days ago](item?id=42260139)   | [root](#42256625) | [parent](#42257370) | [next](#42258020) [–]  If anything, Emacs users are probably much more likely to inspect the code of whatever extension they are using, since with every help page there is a link to the source code. It helps that it's much less popular and so not as big of a target. | | --- | --- | --- | | | |  |  | [dietr1ch](user?id=dietr1ch) [48 days ago](item?id=42258020)   | [root](#42256625) | [parent](#42257089) | [prev](#42257370) | [next](#42259561) [–]  Emacs is just too old to be architected with security in mind. It's a great editor, but has baggage that IMHO can't be addressed on the spot. Working on a codebase where you can't (heavily?) break things between any commit imposes such a slow pace that it's not completely unreasonable to start from the ground up and just study what made Emacs great and what didn't work too well. It's surprising how long Emacs has been around and how good of an editor it is. It really makes rewrite attempts such a long stretch that it exhausts the motivation and time out of spirited folks that give it a go, but I think that given how complexity is being modularised and moved out (LSP, DAP, grammars) and newer languages make packaging easier that Emacs will eventually be replaced, definitely without covering everything it can do, but being strong at the average editing session. | | --- | --- | --- | | | |  |  | [spauldo](user?id=spauldo) [47 days ago](item?id=42259704)   | [root](#42256625) | [parent](#42258020) | [next](#42258653) [–]  Depending on what you consider Emacs to be, it is either unlikely to be replaced, has already been replaced, or the concept makes no sense. Emacs is an interactive Lisp environment that just so happens to have everything you need for a programmable text editor. Text editors are a dime a dozen, and Emacs is far from the only programmable one (although I'm not aware of any with the degree of programmability that Emacs offers). You can find alternatives for pretty much all of Emacs' functions, but you'll have a hard time finding it all in one place. People have been talking about replacing Emacs itself with another interactive Lisp platform for decades (generally based on Scheme or Common Lisp), but it hasn't happened. I doubt it will. As cool an idea as Lem or Climacs or whatever are, they haven't attracted the user and developer base needed to even begin to approach Emacs' level. And by and large, Emacs users don't care. We're a small enough group these days that no one is likely to target us with serious malware. We blindly trust Elpa and Melpa and the people who commit code there, and so far it hasn't been a problem. Complacent? Certainly, but that's human nature. | | --- | --- | --- | | | |  |  | [nextos](user?id=nextos) [47 days ago](item?id=42258653)   | [root](#42256625) | [parent](#42258020) | [prev](#42259704) | [next](#42259081) [–]  That's my opinion as well. I run Emacs 24/7 but I do so inside Firejail, with no network access. It's not architected with security in mind and exploits are too easy. The same can be said about the Linux userland. The Unix model of giving plenty of access to resources and any user file to user processes is outdated. I find it frustrating something like Firejail or bwrap is not standard. I don't want a compromised program to have easy access to e.g. my SSH keys. | | --- | --- | --- | | | |  |  | [internet\_points](user?id=internet_points) [46 days ago](item?id=42272328)   | [root](#42256625) | [parent](#42258653) | [next](#42261962) [–]  Do you use firejail for other things too? Say I'm developing a js project and have to do npm install and run-dev-server or something, would/could you use firejail with that (to avoid npm putting your ssh keys on pastebin due to bad third party js)? Would you firejail the whole bash session? I feel so worried every time I walk into a new ecosystem, and there are new developer tools required. They invariably want me to install things outside their project folder or edit .bashrc or require sudo. It's affecting my sleep. Just running `make` in the wrong folder can start downloading things. It's gotten so bad lately I'm even considering Qubes. | | --- | --- | --- | | | |  |  | [nextos](user?id=nextos) [45 days ago](item?id=42279840)   | [root](#42256625) | [parent](#42272328) | [next](#42261962) [–]  I use Firejail in the terminal as I am also concerned with the things you mentioned. bwrap is also a possibility. For simple usecases, they are not too intrusive. You can easily create a development profile that bans internet access and forbids read access to your important files. Then wrap CLI commands around that, or perhaps even the entire Bash session. It's like a poorman's QubesOS. I also recommend setting up a userspace firewall like Little Snitch or OpenSnitch. Most malware requires Internet access to do harm. Those provide a good last line of defense. It's a shame the Unix model of giving coarse-grained access to user processes has not been patched. It's not that hard and it's a big security issue. | | --- | --- | --- | | | |  |  | [hollerith](user?id=hollerith) [47 days ago](item?id=42261962)   | [root](#42256625) | [parent](#42258653) | [prev](#42272328) | [next](#42259081) [–]  >I run Emacs 24/7 but I do so inside Firejail Can you share your Firejail config? | | --- | --- | --- | | | |  |  | [nextos](user?id=nextos) [47 days ago](item?id=42266457)   | [root](#42256625) | [parent](#42261962) | [next](#42259081) [–]  I just use the "net none" option. For the rest of the programs, Firejail default profiles are spot on. Alternatively, you can use bwrap --share-net=none emacs. | | --- | --- | --- | | | |  |  | [stackghost](user?id=stackghost) [47 days ago](item?id=42259081)   | [root](#42256625) | [parent](#42258020) | [prev](#42258653) | [next](#42259561) [–]  >Emacs is just too old to be architected with security in mind. Bad security is endemic to all GNU projects. gnutls and gnupg come readily to mind, for example. In fact there was an article/blog post making the rounds a few years ago about how the letters "GNU" are an excellent heuristic for broken security models and fatally-flawed crypto. | | --- | --- | --- | | | |  |  | [CarpaDorada](user?id=CarpaDorada) [47 days ago](item?id=42259227)   | [root](#42256625) | [parent](#42259081) | [next](#42259561) [–]  What about GnuTLS and GnuPG do you think makes them insecure? I think that they offer something unique and that must be factored in; i.e. if you compare them to competitors, you can't compare apples to oranges when making judgments for them. In mind I have projects like Open/Bear/Boring SSL to compare GnuTLS with, and sequoia for gpg. I really like sequoia, but it offers a different product to gnupg. Emacs is a mosaic of 50 years of computer history, security is not its priority, but I guarantee you that in bug-gnu-emacs any security/network-related patches are most welcome. | | --- | --- | --- | | | |  |  | [stackghost](user?id=stackghost) [47 days ago](item?id=42259917)   | [root](#42256625) | [parent](#42259227) | [next](#42259821) [–]  Well, how about the fact that gnutls allowed passive cleartext recovery attacks to go unpatched for about 2 years? How about the fact that GnuPG is predicated upon the web of trust which has been demonstrated not to work, encourages misuse in the form of long-lived identities which discourages key rotation, has no ratchets nor forward secrecy, has multiple internal key parsers, and a littany of vulnerabilities involving authentication and downgrade attacks? GNU is just organizationally incapable of producing secure code. These tools are *not good tools*. GnuPG in particular offers absolutely nothing that another single-purpose tool doesn't do better, but for some reason people get emotional and mount all kinds of irrational defenses of it. GPG is not good. It is broken at a fundamental level. | | --- | --- | --- | | | |  |  | [CarpaDorada](user?id=CarpaDorada) [47 days ago](item?id=42261320)   | [root](#42256625) | [parent](#42259917) | [next](#42262235) [–]  >Well, how about the fact that gnutls allowed passive cleartext recovery attacks to go unpatched for about 2 years? They patched it when they became aware of it in <<https://gitlab.com/gnutls/gnutls/-/issues/1011>>, it was not "allowed" to go unpatched. >How about the fact that GnuPG is predicated upon the web of trust No it is not, the web of trust is one mode of operation out of infinitely many that you can come up with, it's not forced upon the user. It was evangelized for a long time until the keyservers got DOSed. In retrospect obvious, but also gnupg is more-or-less an "activist" project -- big corps and govs are against encryption for the masses by and large. Had it had institutional backing from the beginning (which it never got) it'd have a much more robust model for users to work with. >encourages misuse in the form of long-lived identities which discourages key rotation You can automate key rotation with gpg. The long-lived identity argument can be seen as a strength too, short-lived isn't always better. >a littany of vulnerabilities involving authentication and downgrade attacks? I'm not aware of these; do you mean that GnuPG is not secure by default in its algorithm list? It chooses compatibility over security, but you're free to change the configuration. I think it's too harsh to say that GnuPG is inadequate because of that. >GNU is just organizationally incapable of producing secure code. I don't see why that'd be true, anyone can contribute to GNU so there is nothing inherent about GNU that makes its projects insecure. >GPG is not good. It is broken at a fundamental level. Works for me! I use it to sign my git commits and tarball releases, and with gpg-agent I get to authenticate to SSH servers. | | --- | --- | --- | | | |  |  | [stackghost](user?id=stackghost) [47 days ago](item?id=42261902)   | [root](#42256625) | [parent](#42261320) | [next](#42262235) [–]  >Works for me! Hey, so long as you're cognizant of the fact that everyone credible thinks GPG is at best a security LARP, do what you feel is best. | | --- | --- | --- | | | |  |  | [worthless-trash](user?id=worthless-trash) [47 days ago](item?id=42262242)   | [root](#42256625) | [parent](#42261902) | [next](#42262235) [–]  What better options are there, if you're aware of these weaknesses i'm sure you're aware of better options. | | --- | --- | --- | | | |  |  | [fmajid](user?id=fmajid) [47 days ago](item?id=42264923)   | [root](#42256625) | [parent](#42262242) | [next](#42262416) [–]  <https://soatok.blog/2024/11/15/what-to-use-instead-of-pgp/> | | --- | --- | --- | | | |  |  | [CarpaDorada](user?id=CarpaDorada) [46 days ago](item?id=42268407)   | [root](#42256625) | [parent](#42264923) | [next](#42262416) [–]  This is an anonymous blog, and the author conceals their identity, which is already an issue for me. Let's look at the alternatives to PGP that the blog recommends, I will paraphrase: 1) Sign software with sigstore.dev The issue here is that you delegate trust to places like GitHub or other OIDC providers. You also have to trust Fulcio and their CAs. <<https://docs.sigstore.dev/about/security/>> for details. Maybe you don't want to do that, in part because you're not guaranteed that the service will remain free, or perhaps you're more serious about security than GitHub. 1-alt) Sign software with minisign. Maybe I don't want to use Ed25519. Maybe I want to revoke the signatures. There's many issues one may have with minisign. 2) Signing git tags/commits Advises to use SSH, no explanation why. Advises Ed25519, why not Ed448? The explanation to not use RSA is by linking to <<https://blog.trailofbits.com/2019/07/08/fuck-rsa/>>. I will only quote one thing from this article: >RSA was an important milestone in the development of secure communications, but the last two decades of cryptographic research have rendered it obsolete. You can't say it is obsolete when it is still in use. I'm not sure what the author(s) mean by "obsolete", but it is not true that RSA is obsolete. (If Ed25519 breaks but RSA doesn't, who will be obsolete?) 3) Sending files between computers Here it recommends Magic Wormhole. That's shocking to me, I don't understand why it is recommended. Why not rsync? If you look at the 2016 presentation for Magic Wormhole <<https://www.lothar.com/~warner/MagicWormhole-PyCon2016.pdf>>, the pitch is that it is especially useful when the computers are unrelated. How often is that the case? Rsync is a much better solution for anyone who wants to transfer files between servers they have access to. 4) Encrypting Backups Here they recommend tarsnap as "the usual recommendation", I've got to say, it's definitely not the usual recommendation. 5) Encrypting Application Data They say to use Tink or libsodium. Tink has many implementations in each language, (how does that help security?) and libsodium doesn't support RSA, two things on top of my head that may be deal breakers. 6) Encrypting Files They recommend age; wishful thinking as most people do not use age. In fact most people do not bother encrypting files, and it is not something that is done often. The author likes to talk about footguns, well there's certainly many footguns to file encryption. This is where the most analysis is on this blog article too, but this is a niche case. 7) Private Messaging It recommends Signal. What about e-mail? >(Unless you’re legally required to use PGP because of a government regulation… in which case, why do you care about my recommendations if you’re chained by the ankle to your government’s bad technology choices?) It comes off as know-it-all. Let me close with this: Cryptography is infamous for debates. It never ends, and many people have ended up with egg on their face for their claims. Tread carefully and don't rely on others too much! | | --- | --- | --- | | | |  |  | [stackghost](user?id=stackghost) [47 days ago](item?id=42262416)   | [root](#42256625) | [parent](#42262242) | [prev](#42264923) | [next](#42262235) [–]  More in keeping with the Unix philosophy of doing one thing and doing it well (GnuPG in particular does a mediocre job of many things), the best move is to replace it with a suite of single purpose tools. For example, signing commits with minisign or signify. | | --- | --- | --- | | | |  |  | [CarpaDorada](user?id=CarpaDorada) [47 days ago](item?id=42262529)   | [root](#42256625) | [parent](#42262416) | [next](#42262235) [–]  >For example, signing commits with minisign or signify. These tools don't work well with git or the git forges, and they do not work at all with fossil. (Obviously signify is a good choice if you're using OpenBSD.) Furthermore they lock you in entirely in their choice of algorithm, Ed25519, which may not be what you want (Why not Ed448?) As far as adoption goes, and adoption is hard to get going, GnuPG is what is used in Linux the most... | | --- | --- | --- | | | |  |  | [stackghost](user?id=stackghost) [47 days ago](item?id=42262824)   | [root](#42256625) | [parent](#42262529) | [next](#42262235) [–]  "Github supports GnuPG signatures" does not contradict the statement "GnuPG is trash". I will not engage further, it's obvious you are not interested in honest discussion of the technical merits. | | --- | --- | --- | | | |  |  | [CarpaDorada](user?id=CarpaDorada) [47 days ago](item?id=42262924)   | [root](#42256625) | [parent](#42262824) | [next](#42264926) [–]  The issue is mostly with git itself, e.g. take a look at ```   git cat-file commit HEAD  ``` to see something like: ```   tree <tree-hash>   parent <parent-hash>   author <author-name> <author-email> <timestamp>   committer <committer-name> <committer-email> <timestamp>   gpgsig -----BEGIN PGP SIGNATURE-----        <ascii-armored RFC9580 signature>    -----END PGP SIGNATURE-----    <commit message>  ``` You can view an example of the structure of this ascii-armored signature here <[https://cirw.in/gpg-decoder/#-----BEGIN%20PGP%20SIGNATURE---...](https://cirw.in/gpg-decoder/#-----BEGIN%20PGP%20SIGNATURE-----%0A%0AiF4EABYIAAYFAlX5X5UACgkQjP3hIZeWWpr2IgD%2FVvkMypjiECY3vZg%2F2xbBMd%2FS%0Aftgr9N3lYG4NdWrtM2YBANCcT6EVJ%2FA44PV%2FIgHYLy6iyQMyZfps60iehUuuYbQE%0A-----END%20PGP%20SIGNATURE-----)>. You can add a patch to git to support more signature types than just OpenPGP. You may then be able to move mountains and get GitHub/others to join in the validation. Finally, if you can find bugs/exploits in GnuPG, you should report them and you will definitely get credit and recognition for them. They are not trivial to find. | | --- | --- | --- | | | |  |  | [fmajid](user?id=fmajid) [47 days ago](item?id=42264934)   | [root](#42256625) | [parent](#42262924) | [next](#42264926) [–]  Git has supported SSH-based signatures for a while now, including those backed by FIDO hardware keys. | | --- | --- | --- | | | |  |  | [CarpaDorada](user?id=CarpaDorada) [46 days ago](item?id=42268423)   | [root](#42256625) | [parent](#42264934) | [next](#42264926) [–]  FIDO would be for authentication, not signing. It also supports SSH (and X.509, see <<https://git-scm.com/docs/gitformat-signature>>) but it does not support minisign or signify. There's a git module for signify, <<https://leahneukirchen.org/dotfiles/bin/git-signify>> but don't count on it being widely supported. | | --- | --- | --- | | | |  |  | [tapete](user?id=tapete) [47 days ago](item?id=42264926)   | [root](#42256625) | [parent](#42262824) | [prev](#42262924) | [next](#42262235) [–]  > I will not engage further, it's obvious you are not interested in honest discussion of the technical merits. Well you are neither, all you do is throw unobjective flames around ("gnupg is trash") and post various claims about bad security without backing them up, implicitly demanding that other people do the leg work of disproving your accusations against the GNU project. Are you working for Apple by any chance? | | --- | --- | --- | | | |  |  | [stackghost](user?id=stackghost) [46 days ago](item?id=42268325)   | [root](#42256625) | [parent](#42264926) | [next](#42262235) [–]  >Are you working for Apple by any chance? No, my background is in aerospace and I'm currently in grad school planning to pivot into a different field. | | --- | --- | --- | | | |  |  | [worthless-trash](user?id=worthless-trash) [47 days ago](item?id=42262235)   | [root](#42256625) | [parent](#42259917) | [prev](#42261320) | [next](#42259821) [–]  What was the CVE for that cleartext downgrade attack ? | | --- | --- | --- | | | |  |  | [stackghost](user?id=stackghost) [46 days ago](item?id=42268332)   | [root](#42256625) | [parent](#42262235) | [next](#42259821) [–]  For gnutls? I believe it was this one: <https://nvd.nist.gov/vuln/detail/CVE-2020-13777> It was not a "downgrade attack", it was passive cleartext recovery. | | --- | --- | --- | | | |  |  | [worthless-trash](user?id=worthless-trash) [46 days ago](item?id=42272774)   | [root](#42256625) | [parent](#42268332) | [next](#42259821) [–]  Ah, my mistake, thats why I couldn't find it. Thanks for the link. | | --- | --- | --- | | | |  |  | [tmtvl](user?id=tmtvl) [47 days ago](item?id=42259821)   | [root](#42256625) | [parent](#42259227) | [prev](#42259917) | [next](#42259561) [–]  I have heard it said that a problem with GPG is that it does encryption AND signing when you'd ideally have separate tools for those tasks, like, for example, age for encryption. | | --- | --- | --- | | | |  |  | [iLemming](user?id=iLemming) [47 days ago](item?id=42259561)   | [parent](#42256625) | [prev](#42256796) | [next](#42256935) [–]  > 5 or 6 other signs that make me want to migrate away from Emacs. Sure, Emacs is not without deficiencies. But what are the alternatives? Name one option that can do things in the way that Emacs allows you to? Don't say 'Vim' - as a die-hard vimmer who uses both daily, I can confidently tell you - it may take decades until Vim becomes sufficiently good to replace Emacs for me. And if you say 'VSCode', I'd simply laugh coughing up org-mode structured headings. | | --- | --- | --- | | | |  |  | [dark-star](user?id=dark-star) [47 days ago](item?id=42259730)   | [root](#42256625) | [parent](#42259561) | [next](#42256935) [–]  sure, if you're looking for something that can perfectly replicate what Emacs does, then you'll never find an alternative... Every alternative has obvious shortcomings, at least on first glance, that you have to get used to. I have never used Emacs (other than briefly starting it up in the 90s, waiting 5 minutes for it to load on my old 386, just to be completely overwhelmed and closing it again) but I have used other tools that I replaced (sometimes multiple times) over the years. And it has never been "smooth". The first few days are full of compromises until you get into a mode of working "with" the new software instead of "against" it. Then it usually begins to make sense and after a week or two you've in business | | --- | --- | --- | | | |  |  | [iLemming](user?id=iLemming) [47 days ago](item?id=42259832)   | [root](#42256625) | [parent](#42259730) | [next](#42256935) [–]  Okay, but you know what? During my career as a software developer, I have wasted over a decade "getting used to" things being shitty, passively accepting mediocrity and suboptimal solutions. Learning Emacs (and Vim too) finally made me realize that I was doing things wrong - I needed to be in charge. As a computer programmer, I should be commanding software, not being constrained by it. Emacs has granted me that power by acting like glue. I don't turn away from useful software; I do use it. I just do it through Emacs, not instead. With Emacs, I make my own rules and I dictate what makes sense. Most recent practical example? I just joined a team that uses Jira. Lots of people hate Jira (and for good reasons), in my case, I have no choice. So, instead of complaining how cumbersome and stupid Jira is, I decided to use it from Emacs. But instead of wasting time building a "native" extension, I just delegated things to go-jira - a command line client. Now, I can basically type 'FOO-31415' and Emacs automatically, contextually recognizes it as the 'jira ticket number', despite it being plain text. From that point I can retrieve its summary, turn it into a markdown link, browse the ticket, change its fields and status, etc. While anyone else have to waste their time opening Jira in the browser, I can perfectly do things without losing my focus, directly from my editor. That's working "with" software instead of letting software to fight "against" you. | | --- | --- | --- | | | |  |  | [wilkystyle](user?id=wilkystyle) [47 days ago](item?id=42261456)   | [root](#42256625) | [parent](#42259832) | [next](#42260199) [–]  Been using Emacs for 15 years, and I think you've perfectly captured the spirit of what makes Emacs so compelling in spite of the crazy time investment needed to make it your own. I have never used another piece of software that not only allows you to customize it so deeply but makes you feel like you're the one in control. | | --- | --- | --- | | | |  |  | [iLemming](user?id=iLemming) [46 days ago](item?id=42267929)   | [root](#42256625) | [parent](#42261456) | [next](#42265502) [–]  > you feel like you're the one in control. I know right? Sometimes it so ridiculous, it's not even funny. Here's one, totally idiotic example. I use Google Translate directly in Emacs, okay? So, when you enter something like "He was born in 1978", it doesn't translate the date, and that's sensible. But I'm learning a language, I really need to see it e.g. in Spanish like this: "Nació en mil novecientos setenta y ocho", and I didn't want to write every time "He was born in nineteen seventy-eight", so I wrote a tiny function (took me ten minutes) advising google-translate that installs 'number-to-words' npm package and uses it to turn the numbers into words before sending the whole thing to Google Translate API. Totally imbecilic, right? I guess shit ain't no so stupid if thy shit works, yes? Now, Neovim, VSCode, Jetbrains, and Sublime, they all have similar plugins for translation. I wonder if any experienced user would ever bother with something like that? I bet they just wouldn't. It wouldn't occur to them to even consider that as a minor annoyance. Emacs on the other hand, changes the way you think about efficiency and being in control. | | --- | --- | --- | | | |  |  | [wilkystyle](user?id=wilkystyle) [45 days ago](item?id=42282334)   | [root](#42256625) | [parent](#42267929) | [next](#42265502) [–]  The advice system that you mentioned is such a good example of this! I recently realized that I had come to rely deeply on xref navigation for going to a definition and then xref-go-back/forward to hop between different jumps. I was bummed that it wasn't a more general backward/forward capability, but then I remembered the advice system. In like 10 minutes I whipped up some quick elisp to add some :before advice around various navigation functions to call xref-push-marker-stack. Not only did it work perfectly to turn the xref marker system into a general navigation capability, I also had complete control over which navigation functions push a marker and which do not. I think this is the difference with Emacs. Not only is it primarily a lisp environment and then secondarily a text editor, but it goes above and beyond to add general capabilities for modifying its own behavior. With most any other piece of software I can think of, you are relying upon the developers to provide you with the exact APIs to control the software. With Emacs, you control the entire lisp environment, and therefore control the editor running within it. *edit: Siri typo* | | --- | --- | --- | | | |  |  | [hollerith](user?id=hollerith) [47 days ago](item?id=42265502)   | [root](#42256625) | [parent](#42261456) | [prev](#42267929) | [next](#42260199) [–]  I agree (but at times have spent too much time customizing Emacs because of the emotional appeal of exercising this control over my personal software environment). | | --- | --- | --- | | | |  |  | [iLemming](user?id=iLemming) [46 days ago](item?id=42267675)   | [root](#42256625) | [parent](#42265502) | [next](#42260199) [–]  > spent too much time Time has to be spent, no matter what: you can either adapt your workflow to match the design of specialized apps, or you can choose to go against the norm and manage it on your own terms. I vividly remember my own misery when trying to find the most optimal, ideal note-taking solution. I went through Evernote, Workflowy, Google Todos, Google Keep, Todoist, Notion, Trelo, Remember the Milk, Obsidian, and some other options. On the other hand, I have spent a long time studying and customizing Org-mode. I can say with absolute certainty that the net positive ROI from this effort is far greater than it could ever be with any other option. "Ignorance is bliss", right? Less tech-savvy people genuinely live in blissful ignorance of the endless possibilities, the ways and the methods available. Programmers are different - they can spot your bullshit right away, "you're holding it wrong" vibes don't sit well with them, you don't tell them "users don't know what they want", they'd get annoyed and will try to find a better way - writing scripts, hacking your app, setting up unconventional keybindings, etc. Emacs is for programmers, for tinkerers who prefer to deal with computing on their own terms. I know the feeling - some new, shiny app comes out that makes ripples in HN threads, and you'd feel old, cranky, and left out with your not-so-shiny, brutally simple yet efficient Emacs UI, thinking that maybe this is the time when you finally have to move away from it. Then you try that shiny new feature everyone so enthusiastically talks about and think, "Meh, that's it? Is that what they're so excited about? I can't believe now I have to use this shit because everyone else does..." And then a few weeks later, someone builds an Emacs package for it. I never regret time spent on customizing Emacs because I've gotten to the point where I know exactly how to get the most use out of that exercise. It's nothing but pure, unadulterated pragmatics. The notion that Emacs users waste their time configuring it instead of doing real work is a myth. It's like saying that the cook spends too much time sharpening the blade instead of actual cooking. A great chef knows a great deal about his knives and always keeps them very sharp, but he's not in a knife-sharpening business. | | --- | --- | --- | | | |  |  | [sexyman48](user?id=sexyman48) [47 days ago](item?id=42260199)   | [root](#42256625) | [parent](#42259832) | [prev](#42261456) | [next](#42256935) [–]  Hyping vaporware is not software development. | | --- | --- | --- | | | |  |  | [iLemming](user?id=iLemming) [47 days ago](item?id=42260378)   | [root](#42256625) | [parent](#42260199) | [next](#42256935) [–]  Judging by your profile comments, it looks like you have little clue what any of these words mean, especially the last one, which could be due to your emotionally underdeveloped brain. Before you start spitting your snacks at the screen in rage, let me explain - comments like yours often suggest someone experiencing difficulties with emotional regulation, empathy, and interpersonal relationships. I don't know the source of your irrational anger, but you may want to find someone to talk about it. Modern therapy can drastically change people's lives for the better. | | --- | --- | --- | | | |  |  | [throwanem](user?id=throwanem) [48 days ago](item?id=42256935)   | [parent](#42256625) | [prev](#42259561) | [next](#42258296) [–]  I'm a lot less worried about this than I am about MELPA packages being targeted. But any other editor that incorporates a package manager exposes the same threat surface, and just about all of them are a lot more popular (thus more worth targeting) than Emacs. | | --- | --- | --- | | | |  |  | [SoftTalker](user?id=SoftTalker) [48 days ago](item?id=42257386)   | [root](#42256625) | [parent](#42256935) | [next](#42258296) [–]  Yes, it boils down to "be careful with untrusted code" no matter where it comes from. This is certainly not unique to emacs. | | --- | --- | --- | | | |  |  | [EasyMark](user?id=EasyMark) [47 days ago](item?id=42259020)   | [root](#42256625) | [parent](#42257386) | [next](#42258296) [–]  I'm starting to get "return to notepad++" vibes from HN today. | | --- | --- | --- | | | |  |  | [SoftTalker](user?id=SoftTalker) [47 days ago](item?id=42259428)   | [root](#42256625) | [parent](#42259020) | [next](#42258296) [–]  Well I use mostly stock emacs. If that's already owned, then I guess I'm screwed. I'm very selective about adding additional packages or using other "uninspected" elisp code. | | --- | --- | --- | | | |  |  | [nine\_k](user?id=nine_k) [48 days ago](item?id=42258296)   | [parent](#42256625) | [prev](#42256935) | [next](#42256856) [–]  It looks like adding a defcustom that would disable macro expansion, and basically any attempts to eval the code being edited, should not be a lot of work, or at least doable. Disable it in your config, get a nerfed-down but shields-up elisp editing mode. Am I missing anything here? E.g. should I expect pieces of C code that handle completion in elisp mode? | | --- | --- | --- | | | |  |  | [G3rn0ti](user?id=G3rn0ti) [47 days ago](item?id=42263113)   | [root](#42256625) | [parent](#42258296) | [next](#42258381) [–]  > It looks like adding a defcustom that would disable macro expansion, and basically any attempts to eval the code being edited Probably, yes. „org-babel“ can execute shell code inside an org document but always asks the user before it does. You can disable this if you want to. No big deal. Should totally work like this in elisp-mode, too. | | --- | --- | --- | | | |  |  | [chlorion](user?id=chlorion) [48 days ago](item?id=42258381)   | [root](#42256625) | [parent](#42258296) | [prev](#42263113) | [next](#42256856) [–]  Would you mind explaining how you could do this? | | --- | --- | --- | | | |  |  | [nine\_k](user?id=nine_k) [47 days ago](item?id=42258830)   | [root](#42256625) | [parent](#42258381) | [next](#42256856) [–]  I expect that the entire mode is implemented in elisp-mode.el. It's based on lisp-data-mode, but I don't expect that to handle macros (should check though). Looking at elisp-completion-at-point and likely deeper into elisp--completion-local-symbols, I'd try to find where macroxpansion occurs, and make it conditional. Same for the explicit emacs-lisp-macroexpand. I would also search for `(eval ` in general and maybe put it under a buffer-local flag, too, so that you won't press C-x C-e or C-M-x and execute malicious code by mistake, when you know you're working on a piece of malicious code. Maybe instead of a defcustom, it should rather be a minor elisp-paranoid-mode which would do all kinds of things to prevent execution of the code in the buffer, or the code the buffer refers to, etc. | | --- | --- | --- | | | |  |  | [quotemstr](user?id=quotemstr) [48 days ago](item?id=42256856)   | [parent](#42256625) | [prev](#42258296) | [next](#42256768) [–]  You could also macroexpand in a sandbox, e.g. via LSP. | | --- | --- | --- | | | |  |  | [hollerith](user?id=hollerith) [48 days ago](item?id=42257235)   | [root](#42256625) | [parent](#42256856) | [next](#42256768) [–]  That would involve a rewrite because the way it is now, the relevant code does not use LSP. | | --- | --- | --- | | | |  |  | [quotemstr](user?id=quotemstr) [48 days ago](item?id=42257704)   | [root](#42256625) | [parent](#42257235) | [next](#42256768) [–]  Okay, but software is infinitely malleable | | --- | --- | --- | | | |  |  | [bee\_rider](user?id=bee_rider) [48 days ago](item?id=42256768)   | [parent](#42256625) | [prev](#42256856) | [next](#42257451) [–]  Doesn’t vim also have some ability, easily abused, to put a script at the top of a file, and it’ll just run when you open the thing? This seems like a really useful functionality to have in the context where you actually do trust the files, but it is wildly insecure and an unexpected trapdoor, to have simple files executing things when you open them with a simple text editor… | | --- | --- | --- | | | |  |  | [taeric](user?id=taeric) [48 days ago](item?id=42256807)   | [root](#42256625) | [parent](#42256768) | [next](#42257108) [–]  Emacs has that, too. There are protections in that case, though. See: [https://www.gnu.org/software/emacs/manual/html\_node/emacs/Sa...](https://www.gnu.org/software/emacs/manual/html_node/emacs/Safe-File-Variables.html) Probably going to add similar protections here? Basically, I'd assume if it is your first time visiting a file, macros won't be expanded during autocompletion. | | --- | --- | --- | | | |  |  | [bee\_rider](user?id=bee_rider) [48 days ago](item?id=42256902)   | [root](#42256625) | [parent](#42256807) | [next](#42257108) [–]  I dunno. I can see why this functionality might be useful, but I kinda think distros should disable it by default/make it whitelist-only. I think the implications are really unexpected for “new” users (where “new” could be pretty generously defined, I mean, I know a couple people who use vim IRL, I think they would not expect this… it is the sort of thing you know about if you are somebody who goes online to talk about text editors I think). And these are also the sort of users who are used to seeing shebangs and other line noise at the top of files, not understanding it, and ignoring it. I think we’re only being protected by the fact that spreading a virus though command-line text editors is… going to result in not a ton of hits. | | --- | --- | --- | | | |  |  | [taeric](user?id=taeric) [48 days ago](item?id=42257035)   | [root](#42256625) | [parent](#42256902) | [next](#42257108) [–]  I'm confused. Per the doc, it is disabled by default? Specifically, the first time it is encountered on a file, it will ask the user if they want to allow it. And they flat out don't ever do things like "eval" during these values. | | --- | --- | --- | | | |  |  | [hollerith](user?id=hollerith) [48 days ago](item?id=42257108)   | [root](#42256625) | [parent](#42256768) | [prev](#42256807) | [next](#42256950) [–]  That's a different potential vulnerability. I knew about that one (and had disabled the running of such scripts). I didn't know about this one till today. Helping me finish typing the name of a function or variable ("completion") is not the sort of thing I expected (till today) the maintainers of Emacs to be so eager to do that they'd start running code that I never asked to be run. | | --- | --- | --- | | | |  |  | [lmz](user?id=lmz) [47 days ago](item?id=42264441)   | [root](#42256625) | [parent](#42257108) | [next](#42256950) [–]  It's that Lisp data is code, code is data thing. | | --- | --- | --- | | | |  |  | [hollerith](user?id=hollerith) [47 days ago](item?id=42264919)   | [root](#42256625) | [parent](#42264441) | [next](#42256950) [–]  No, it is not. | | --- | --- | --- | | | |  |  | [magic\_smoke\_ee](user?id=magic_smoke_ee) [48 days ago](item?id=42256950)   | [root](#42256625) | [parent](#42256768) | [prev](#42257108) | [next](#42257451) [–]  A common pitfall of IDE integration for dynamic languages is that it tends to execute the code under test to provide contextual completion or may decide to run doctests, etc. This has been/is a problem with editing Ruby code, and perhaps Python code and more too too. I'm unsure if this is a problem editing vimscript or lua with NeoVim with the only non-evidence is that I haven't heard of it. | | --- | --- | --- | | | |  |  | [nojs](user?id=nojs) [48 days ago](item?id=42257451)   | [parent](#42256625) | [prev](#42256768) | [next](#42259259) [–]  What are the other 5, out of curiosity? | | --- | --- | --- | | | |  |  | [mfld](user?id=mfld) [47 days ago](item?id=42259259)   | [parent](#42256625) | [prev](#42257451) | [next](#42257000) [–]  Good call to prevent macro expansion. Does also no big harm nowadays as there are several other ways to get good auto completion, e.g. copilot. Other than that no need to restrict functionality for power users. | | --- | --- | --- | | | |  |  | [\_verandaguy](user?id=_verandaguy) [48 days ago](item?id=42257000)   | [parent](#42256625) | [prev](#42259259) | [next](#42256679) [–]  The Church of Vim is always accepting new disciples. Jokes aside, if you're considering Vi-like editors (and assuming you haven't already done your research -- which by the sounds of it, you may well have): - I recommend going for Neovim over classic Vim at this point. The first-class Lua support for building out your configs and working with extensions is a big quality-of-life improvement over just VimL, and it's a more portable skill with fewer surprises. As a bonus, this gives you access to a world of shockingly high-quality extensions that require Lua to run. - If you want a decent starting point before you start tweaking a ton of settings, Spacevim is it. I haven't used it extensively but I've only heard good things. - I recommend *against* trying to use Emacs bindings in Vim if you can help it. I used these when I initially moved over (at this point about a decade ago) and they were clunkier than both Emacs's bindings and Vim's native bindings. Learning how to work with Vim's modes is an investment that pays off as quickly as a few days with intense use, or a few weeks with more casual use. - `vim-arpeggio` (or the native chording support in newer versions of Neovim) is your friend for avoiding `<Esc>`-induced repetitive-strain injury. | | --- | --- | --- | | | |  |  | [iLemming](user?id=iLemming) [47 days ago](item?id=42259459)   | [root](#42256625) | [parent](#42257000) | [next](#42257062) [–]  Oh, you think people choose Emacs instead of Vim because of keybindings? Then tell me please, how often do you do your research in Vim, using LaTeX embeddings while taking annotations to a pdf that's rendered in the adjacent window? How often do you take notes, while watching a YouTube video while controlling the playback, speed and volume from your editor? I can watch the video, while following the transcript karaoke-style, pause, speed-up, mute the video whenever I want (so I can start typing), I can grab the pieces of transcript and ask an LLM to give me explanations, etc. Do you read RSS in Vim? Are any RSS readers as well-integrated and feature-rich as elfeed.el in Emacs? I honestly doubt it. And it's not a matter of skepticism over the quality of Vim extensions. Emacs has far fewer active users and even fewer of those who build things in Elisp, yet it remains the most integratable thing ever. The thing is - unlike VSCode, Vim, Sublime, and IntelliJ - Emacs allows you to change any given behavior of any function - built-in or third-party - with such great granularity that is simply not possible anywhere else. What about email? Is there anything close to the level of notmuch, mu4e or gnus? I seriously doubt any vim plugins provide the same level of integration. Do you manage your Jira (or whatever project management) you do from Vim? Do you control your browser from Vim? I do it from Emacs and it's very cool. Can you perform a dynamic search on YouTube, Google, DuckDuckGo, Wikipedia, your browser history and other places while typing the query only once? I do that all the time in Emacs. So, Emacs is not about keybindings. Because you can change them in a way that no other editor lets you do. In Emacs you can use whatever modal or non-modal editing flavor you want, but that's beyond the point. | | --- | --- | --- | | | |  |  | [suslik](user?id=suslik) [45 days ago](item?id=42278184)   | [root](#42256625) | [parent](#42259459) | [next](#42257062) [–]  > How often do you take notes, while watching a YouTube video while controlling the playback, speed and volume from your editor? I can watch the video, while following the transcript karaoke-style, pause, speed-up, mute the video whenever I want (so I can start typing), I can grab the pieces of transcript and ask an LLM to give me explanations, etc. Hey, any chance you can expand on how you do this, or just share configs? Thanks! | | --- | --- | --- | | | |  |  | [iLemming](user?id=iLemming) [44 days ago](item?id=42284313)   | [root](#42256625) | [parent](#42278184) | [next](#42257062) [–]  Of course. I use elfeed-tube and elfeed-tube-mpv, which uses mpv.el. That allows you to control mpv directly from Emacs. I have a simple transient that I use [https://github.com/agzam/.doom.d/blob/main/modules/custom/we...](https://github.com/agzam/.doom.d/blob/main/modules/custom/web-browsing/autoload/mpv.el#L43) | | --- | --- | --- | | | |  |  | [suslik](user?id=suslik) [44 days ago](item?id=42287990)   | [root](#42256625) | [parent](#42284313) | [next](#42257062) [–]  Thanks a bunch - I'll give it a go! | | --- | --- | --- | | | |  |  | [sevensor](user?id=sevensor) [48 days ago](item?id=42257062)   | [root](#42256625) | [parent](#42257000) | [prev](#42259459) | [next](#42267783) [–]  As a schismatic from the Church of Vim, I’m compelled to recommend kakoune here. Unless you’re running in a peculiar legacy platform like Windows or Amiga, the selection oriented editing and smooth Unix integration are a delight. | | --- | --- | --- | | | |  |  | [samatman](user?id=samatman) [47 days ago](item?id=42258870)   | [root](#42256625) | [parent](#42257062) | [next](#42267783) [–]  I've considered it from time to time. The conclusion I keep drawing is that, if I were going to benefit from a selection-oriented editing paradigm, I would use Visual mode more than I do. The multi-cursors, those I want. But I'm willing to wait for Neovim to get them. | | --- | --- | --- | | | |  |  | [sevensor](user?id=sevensor) [47 days ago](item?id=42259379)   | [root](#42256625) | [parent](#42258870) | [next](#42267783) [–]  That’s entirely reasonable; I switched in part because I was using visual mode so much. That being said, if you want a more vi-like experience in kakoune, you can always pipe your whole buffer through sed :) | | --- | --- | --- | | | |  |  | [munch117](user?id=munch117) [46 days ago](item?id=42267783)   | [root](#42256625) | [parent](#42257000) | [prev](#42257062) | [next](#42257179) [–]  Considering the steady stream of CVE's against Vim's C code, security is the last reason to choose Vim. I've often wondered why there were so many Vim CVE's, and meanwhile never really any Emacs CVE's. My thinking has been that it's because so much of Emacs is implemented in Elisp, a memory-safe language, and much more of Vim is implemented in C. So now there is an Emacs CVE, and it's a big one. But if you're going to jump ship for something more secure, it would be woefully misguided to go for Vim. Any editor that goes for expressive power and flexibility is going to have security issues sooner or later. If you want safe, you'll need to cut features, pick something simple. | | --- | --- | --- | | | |  |  | [abhinavk](user?id=abhinavk) [48 days ago](item?id=42257179)   | [root](#42256625) | [parent](#42257000) | [prev](#42267783) | [next](#42258012) [–]  As another fan of Kakoune's model of editing (or model of modal editing), I would recommend Helix. It's a low-config tool that lets you start working without turning many knobs. Supports tree-sitter grammars and language server protocol. | | --- | --- | --- | | | |  |  | [\_verandaguy](user?id=_verandaguy) [48 days ago](item?id=42257218)   | [root](#42256625) | [parent](#42257179) | [next](#42258012) [–]  I haven't heard of either Kakoune or Helix, but I'm buried pretty deep in my own opinionated config. As far as I'm concerned, the more readymade options, the better. Thanks to you and sevensor for adding recommendations! | | --- | --- | --- | | | |  |  | [maleldil](user?id=maleldil) [48 days ago](item?id=42258012)   | [root](#42256625) | [parent](#42257000) | [prev](#42257179) | [next](#42258478) [–]  > I recommend against trying to use Emacs bindings in Vim if you can help it This is fine, I think. Using C-w is more convenient than <Esc>diw. I also find C-a and C-e quite convenient, although you need plugins for these (tpope's vim-rsi is good). I might be worth starting without them, though, so they learn not to rely on them too much. That being said, I use home-row mods, which makes Control a lot easier to use than regular keyboards. | | --- | --- | --- | | | |  |  | [Y\_Y](user?id=Y_Y) [47 days ago](item?id=42258478)   | [root](#42256625) | [parent](#42257000) | [prev](#42258012) | [next](#42258351) [–]  Spacevim? Emacs bindings in vim? Heresy! Spacemacs defaults to vim bindings and it's easily my favorite editor, while saving you from (some of) the endless config tweaking. | | --- | --- | --- | | | |  |  | [d0mine](user?id=d0mine) [48 days ago](item?id=42258351)   | [root](#42256625) | [parent](#42257000) | [prev](#42258478) | [next](#42256679) [–]  Are you saying there can’t be security vulnerabilities in Neovim? [rhetorical question] As I understand it, the vulnerability is that viewing untrusted elisp code may lead to arbitrary code execution. Personally, I don’t remember a case where I would view elisp code without the intent of running it. | | --- | --- | --- | | | |  |  | [27theo](user?id=27theo) [48 days ago](item?id=42256679)   | [prev](#42256625) | [next](#42257564) [–]  Scary. I saw a tweet the other day from a job seeker who had been sent a repo of seemingly trustworthy code. The sender claimed to be working with a team that was hiring, or something along those lines. Of course, one file deeply nested within the folds of the project contained a block of obfuscated JavaScript designed to grab as much data from the job seeker as possible and transmit it elsewhere. Had the job seeker run the project without reading through it first, they would have been in hot water. You can imagine some variant of this attack including a carefully designed Emacs Lisp payload, which the unsuspecting and desperate-for-a-job victim might open in Emacs. Surprising that the Emacs maintainers didn't fix it as quickly as you'd hope. | | --- | --- | --- | | | |  |  | [medo-bear](user?id=medo-bear) [48 days ago](item?id=42257002)   | [parent](#42256679) | [next](#42257564) [–]  Emacs doesn't market itself as a sandboxed tool. It is purpose built to give users unrivaled powers. There are obvious consequnces to this. What is more scary is running untrusted js in a browser that has been marketed as sanboxed, but you probably do this all day every day | | --- | --- | --- | | | |  |  | [\_\_MatrixMan\_\_](user?id=__MatrixMan__) [48 days ago](item?id=42257047)   | [root](#42256679) | [parent](#42257002) | [next](#42260377) [–]  Agreed. Also, I expect that malicious elisp is relatively rare, while malicious js is probably about half of it. | | --- | --- | --- | | | |  |  | [medo-bear](user?id=medo-bear) [48 days ago](item?id=42257737)   | [root](#42256679) | [parent](#42257047) | [next](#42260377) [–]  While I'm trying to sober up people who are panicking I don't mean to downplay the dangers. The op article is quite informative and should be read by all emacs users. While malicious el code is probably rare, the value gained by compromising an emacs user (programmers academics researchers etc) compared to compromising a random js user (everyone) is probably way greater. Also very few people look at emacs security | | --- | --- | --- | | | |  |  | [emporas](user?id=emporas) [47 days ago](item?id=42260377)   | [root](#42256679) | [parent](#42257002) | [prev](#42257047) | [next](#42257564) [–]  Could starting $ emacs --daemon, and connecting to another machine using the client act as a kind of sandboxing or it has no benefit whatsoever? Maybe that could be used as a starting point to implement a security strategy for some not totally trusted packages. It could complicate things, but hopefully not too much. | | --- | --- | --- | | | |  |  | [medo-bear](user?id=medo-bear) [47 days ago](item?id=42263038)   | [root](#42256679) | [parent](#42260377) | [next](#42257564) [–]  If you are concerned about security you should not be running arbitrary programs. For example if you have a lots crypto assets, you shouldnt keep your wallet details on the same computer you are running programs you don't trust. However, practicality often forces you to adopt a more yolo approach toward security. What people often dont realise is that emacs is almost an operating system, and installing emacs packages is kinda like insralling .bat or .exe files. To me personally emacs is the single best piece of software ever produced, by a long shot, but it is a good idea to be aware of its powers. Emacs can infact be great for security. Its code and language are very nice and well documented and if you care to understand the code you are running and you are THAT concerned about security it can be an excellent aid toward peace of mind. | | --- | --- | --- | | | |  |  | [emporas](user?id=emporas) [47 days ago](item?id=42263257)   | [root](#42256679) | [parent](#42263038) | [next](#42257564) [–]  Yeah, but does that mean, (supposing they are different machines), a package is installed on both computers? On the client *and* the server? It sounds redundant, and pretty strange if and that's indeed what happens. I will read eventually the docs and find out myself, but it's gonna take 2-3 hours to dig out documents. > if you care to understand the code you are running and you are THAT concerned about security it can be an excellent aid toward peace of mind. Elisp can be more difficult to review that Rust. It is much more difficult to hide malicious pieces of code, inside a Rust program that in Elisp. Elisp is pretty powerful as many lisps are, but you can write Emacs modules in Rust. See ubolonton's project on github. I tested it at some point and it works. >if you have a lots crypto assets If i had crypto assets, (which i don't), then the correct way to organize money units, tokenized pieces of housing, tokenized pieces of cars, a thousandth of a car for example, is to use an identity which can create children identities, and each child identity can be revoked on demand by the root identity or the parent identity. Then you only really have to keep secure the root identity, everything else is revocable. | | --- | --- | --- | | | |  |  | [medo-bear](user?id=medo-bear) [47 days ago](item?id=42263640)   | [root](#42256679) | [parent](#42263257) | [next](#42257564) [–]  Dont take it as advice, but I think the deamon will handle the macro business, so in that sense you are connected to a compromised remote machine. > Elisp can be more difficult to review that Rust. Im not a rust programmer, so to each their own I guess. To me it is pretty easy to spot weird lisp code while rust is a headache to me. However as far as I know rust also has macros and unsafe options. Im also wary of anything that markets itself as "safe" because overconfidence is enemy of safety The point about crypto assets is that you dont normaly use an editor to interact with it (or any full blown computation) and security is pretty straighforward. However if you are developing a software product it is less straighforward. You will use an IDE, probably some third packages, etc. Lots of ways something can go wrong | | --- | --- | --- | | | |  |  | [ablob](user?id=ablob) [48 days ago](item?id=42257564)   | [prev](#42256679) | [next](#42257155) [–]  The whole issue of trusting other peoples code does have a solution besides just not running it: capability based code execution ("Capability-based security" if you want to look it up) Processes can forfeit the permission to do certain things. similarily you could allow functions to forfeit the permission to call certain functions down the callstack (transitively, even) or only allow a function to be called from certain contexts/functions. While certainly a (minor) performance hit when done dynamically, it should be possible, especially when using an interpreted language. I have not yet seen this done in the context of programming languages, which is probably due to how difficult it would be to set a proper scope and get it right. If A is forbidden from deleting files, for example, but the program allows it to send messages to B (perhaps even by user choice), which is allowed to do so, then that is a natural escape hatch unless B is specifically designed to take this into account. Nonetheless, a hybrid system should be possible to achive, which would at least improve the situation by a non-negligible margin. In the spirit of the original article: Most editor plugins don't need to interact with other processes or the file system directly, and instead could only affect an associated buffer. In this scenario, I believe that it is actually possible to solve this issue. For other applications, such as git integration, the mass of code that would have to be inspected can at least be reduced. | | --- | --- | --- | | | |  |  | [whartung](user?id=whartung) [47 days ago](item?id=42259820)   | [parent](#42257564) | [next](#42257722) [–]  MacOS has lots of "capabilities" stuff now. It's constantly giving me anonymous prompts asking for some such privilege or not, without any explanation as to why it's necessary, what will or will not happen if I do/don't do it. I just had the joy of kicking off a large crawl across my file system(s), expecting it to take some time, so I kicked it off just before I went to bed. This morning I arrived to a dialog "Terminal would like to access...", which naturally stalled my 3 command pipeline in its tracks, thus eliminating the primary benefit of doing the job overnight in the first place. The other day, I guess I installed Discord, or updated it, or something. Anyway, Discord was asking for keystrokes from other apps. "Why!?" Why does my IDE need root access to install? What happens if I don't let random program crawl my network? As a carbon based user, "capabilities" are a pain in the neck. Windows lost this battle decades ago, when every. single. new program required "admin" privs to be installed. Every single one. Heck, I bet Calculator asked for it. To wit we numb users, wanting to just "use the software" said, "yes. Yes. YES! PLEASE MAKE IT STOP!" to the point where you just gave it no second glance at all. Capabilities look great on paper. They're fine for things like systemd and daemons and "stuff administrator folks" install. For human beings, not so much. | | --- | --- | --- | | | |  |  | [screcth](user?id=screcth) [48 days ago](item?id=42257722)   | [parent](#42257564) | [prev](#42259820) | [next](#42257914) [–]  The problem here is that Emacs is the Elisp interpreter. They are the same thing. Emacs would have to start another process for Elisp analysis and code completion. That would be a massive reachitecture of the system. | | --- | --- | --- | | | |  |  | [Barrin92](user?id=Barrin92) [48 days ago](item?id=42257912)   | [root](#42257564) | [parent](#42257722) | [next](#42257842) [–]  Wouldn't it be sufficient to "just" write a kind of context manager that watches the macro expansion and then looks at each step what's being done and divvies that up into safe and unsafe execution, so that at least the example of the article ```   (rx (eval (call-process "touch" nil nil nil "/tmp/owned")))  ``` doesn't just automatically run? Obviously it's a lot of work depending on how sophisticated you want that to be but you probably don't need to rearchitect much. | | --- | --- | --- | | | |  |  | [taeric](user?id=taeric) [48 days ago](item?id=42257842)   | [root](#42257564) | [parent](#42257722) | [prev](#42257912) | [next](#42257914) [–]  For folks that have never poked around in emacs, the specific difficulty will be that the odds are very high that if you are in an emacs lisp file, you are almost certainly going to want to edit what emacs itself is doing. I'm specifically talking about scenarios such as "you set debug-on-error." To that end, the proposal would probably be something like "flymake/flycheck" use a child emacs process to query the code, but the user evaluating the code would still be done in the main emacs? | | --- | --- | --- | | | |  |  | [moron4hire](user?id=moron4hire) [48 days ago](item?id=42257914)   | [parent](#42257564) | [prev](#42257722) | [next](#42257155) [–]  I feel like capability systems are... the right solution to the right problem at the wrong time. By that I mean, in an ideal world, nefarious code should never end up on my system in the first place. Regardless of whether it gets ran, regardless if whether it is properly sandboxed to avoid damage. At the end of the day, I don't want bad code in my system at all. "Easier said than done" is why I said "right solution, right problem, wrong time." But it comes at a cost. A rather extreme cost, in some cases. Walled garden app stores. Runtime overhead. Development overhead. I'm not just a user, I'm also a developer, so these things end up being roadblocks I have to navigate. And I have to navigate them for no reason of my own. I am not trying to steal my users' data. But in a way, I am getting punished for the actions of others. Anyway. No solutions here. | | --- | --- | --- | | | |  |  | [VyseofArcadia](user?id=VyseofArcadia) [48 days ago](item?id=42257155)   | [prev](#42257564) | [next](#42257935) [–]  This feels like a social problem instead of a technical one. Macros and macro expansion are a core language feature. Code analysis tools have to do macro expansion. You can't handicap core language features and tools in the name of safety. If you are doing something potentially dangerous, you just have to take precautions. Real world analogy: construction sites are dangerous, but you can't outlaw the bulldozer. It is a necessary piece of equipment. The best you can do is take precautions. Hard hats, high visibility clothing, audible warnings, etc. | | --- | --- | --- | | | |  |  | [zitterbewegung](user?id=zitterbewegung) [48 days ago](item?id=42257337)   | [parent](#42257155) | [next](#42257377) [–]  Largely this problem which is core to Emacs in the sense it literally is "An Elegant Weapon For A More Civilized Time" due to its age. There is no concept of sandboxing anything in Emacs. You do get an alert sometimes when you change Theme's since they have a notion of totally executable code. Maybe a better solution would be to make a subset of elisp that artifacts be coded in which are sandboxed. | | --- | --- | --- | | | |  |  | [d0mine](user?id=d0mine) [48 days ago](item?id=42258385)   | [root](#42257155) | [parent](#42257337) | [next](#42257879) [–]  No sandboxing is not a bug, it is *the* feature that makes emacs into elisp platform, and not just another editor that has defined API for extensions. | | --- | --- | --- | | | |  |  | [taeric](user?id=taeric) [48 days ago](item?id=42257879)   | [root](#42257155) | [parent](#42257337) | [prev](#42258385) | [next](#42257377) [–]  This problem is specific to elisp evaluation. It is rare that you would want to work in elisp code and not be modifying your currently running emacs. If you are working on code for any other language, it is probably using an LSP or other form of child processes, right? | | --- | --- | --- | | | |  |  | [taeric](user?id=taeric) [46 days ago](item?id=42267679)   | [root](#42257155) | [parent](#42257879) | [next](#42259149) [–]  (Adding as a very late edit on the above. I didn't mean that this problem cannot exist in other settings, which I can see is what folks probably read me as meaning. I just meant the problem in this overall story is specific to elisp because it is core to emacs.) | | --- | --- | --- | | | |  |  | [VyseofArcadia](user?id=VyseofArcadia) [47 days ago](item?id=42259149)   | [root](#42257155) | [parent](#42257879) | [prev](#42267679) | [next](#42257377) [–]  Well I wouldn't say any other language. Common Lisp for example you have a currently running lisp instance that you are modifying. You can pretty easily set up Emacs to work that way for any language with a REPL. | | --- | --- | --- | | | |  |  | [taeric](user?id=taeric) [47 days ago](item?id=42259594)   | [root](#42257155) | [parent](#42259149) | [next](#42257377) [–]  Fair, though with the CL/Python/Whatever you would have to have a session started before visiting the file. I suppose with the newer eglot and friends, it could reach out using LSP as soon as you enter a project directory? At that point, I'd assume similar attacks exist in those contexts, too? Maybe protected by some sandboxing in the LSP side? | | --- | --- | --- | | | |  |  | [lexicality](user?id=lexicality) [48 days ago](item?id=42257377)   | [parent](#42257155) | [prev](#42257337) | [next](#42257935) [–]  Bulldozers also come with keys that stop random people walking up and turning them on though | | --- | --- | --- | | | |  |  | [ablob](user?id=ablob) [48 days ago](item?id=42257635)   | [root](#42257155) | [parent](#42257377) | [next](#42257935) [–]  And a big enough plane does not stop random people from walking up and turning them on. I don't think this analogy fits here. | | --- | --- | --- | | | |  |  | [deng](user?id=deng) [48 days ago](item?id=42257935)   | [prev](#42257155) | [next](#42257192) [–]  Well yes, when "code is data", data suddenly becomes very dangerous. This is recurring theme when dealing with Lisps and Emacs especially. For instance, it is also quite common for Emacs packages to save data in the form of ELisp code. When loading the data, it is simply evaluated and boom, your data is loaded. It's a powerful thing, but of course this is a security issue, and this is why we can't have nice things... | | --- | --- | --- | | | |  |  | [rightbyte](user?id=rightbyte) [48 days ago](item?id=42257192)   | [prev](#42257935) | [next](#42259914) [–]  How would this work? ```     (defmacro hi-macro ()       (eval-when-compile         (message "hi you")))      (hi-mac  ``` I get no printout when doing C-M-i with the cursor after "mac". Edit: OK. As per the mailing list. I guess it is a feature then. ```     (let ((fooo (eval-when-compile (progn (message "hi you")))))       foo ;; <---- C-M-i here       ) ``` | | --- | --- | --- | | | |  |  | [whartung](user?id=whartung) [47 days ago](item?id=42259914)   | [prev](#42257192) | [next](#42256663) [–]  It interesting that this vulnerability has not had the flag raised in the wider Lisp community, since it also applies there. Most of the packages and modules that the Lisp systems have are shipped as source code, and compiled on site. That suggests that innocuous importing of a internet sourced module can wreak havoc on your system just by loading it, you don't even have to run it. Granted, it's not quite the same as having something like auto-complete drain your bitcoin wallet, but it's close. Most every other eco system you actually have to run the code itself to be worried about an exploitation (which, mind, in today's world is a low bar, but a bar nonetheless). | | --- | --- | --- | | | |  |  | [worthless-trash](user?id=worthless-trash) [47 days ago](item?id=42262319)   | [parent](#42259914) | [next](#42256663) [–]  I think you can just load (require ?) a python module and not run it and it will execute the python code. I don't think that this is exclusive to python either. | | --- | --- | --- | | | |  |  | [eadmund](user?id=eadmund) [48 days ago](item?id=42256663)   | [prev](#42259914) | [next](#42256760) [–]  Various modes already prompt if one wishes to respect file-local settings; I imagine that the fix here is similar. | | --- | --- | --- | | | |  |  | [mediumsmart](user?id=mediumsmart) [48 days ago](item?id=42256760)   | [prev](#42256663) | [next](#42262169) [–]  I consider this a feature and I know how to avoid the fix so thanks for the heads up. | | --- | --- | --- | | | |  |  | [dataflow](user?id=dataflow) [47 days ago](item?id=42262169)   | [prev](#42256760) | [next](#42290754) [–]  Not an Emacs user but for the life of me I don't understand what justification there is for auto-completion to allow *any* capabilities other than (a) memory allocation (to generate the code), and perhaps (b) reading the filesystem. Neither of which requires arbitrary code. Why in the world is anything else allowed? And what makes this so damn hard to implement after all these years? It would seem trivial to interpret a macro manually, or to just introduce an evaluation mode that can't do anything else, no? | | --- | --- | --- | | | |  |  | [e40](user?id=e40) [43 days ago](item?id=42290754)   | [prev](#42262169) | [next](#42259303) [–]  What frustrates me with this discussion and the TFA is how do I disable it? I tried this: ```     (setq-default flycheck-disabled-checkers '(emacs-lisp emacs-lisp-checkdoc))  ``` I still see "FlyC-" in the mode line. Does that mean it's off?? I can't find anything that tells me. | | --- | --- | --- | | | |  |  | [jonnycomputer](user?id=jonnycomputer) [47 days ago](item?id=42259303)   | [prev](#42290754) | [next](#42269080) [–]  I've been very very reluctant to install third-party extensions to Jetbrains, VScode, and Emacs for just this sort of problem. And it sucks. | | --- | --- | --- | | | |  |  | [hollerith](user?id=hollerith) [47 days ago](item?id=42265605)   | [parent](#42259303) | [next](#42269080) [–]  Me, too, but the completion-at-point (M-tab) implicated in the OP is part of core Emacs. | | --- | --- | --- | | | |  |  | [rurban](user?id=rurban) [46 days ago](item?id=42269080)   | [prev](#42259303) | [next](#42257225) [–]  When I had the same problem in my language, I disabled all unsafe code to be expanded - IO and calling native functions - in such automatic cases inside an editor. A sandbox. He also forgot the case of ordinary functions being called in the coda. Similar problem as Office VBA startup code. | | --- | --- | --- | | | |  |  | [noelwelsh](user?id=noelwelsh) [48 days ago](item?id=42257225)   | [prev](#42269080) | [next](#42256951) [–]  Sorry, I find it hard to care. You have to multiply the damage caused by the prior probability of the event occurring, and my prior of this happening is very very low. There are so many easier ways to attack people (e.g. poison a package in a language they use, or on MELPA for Emacs hackers) that I can't see this particular attack getting any use. Security is basically a resource allocation problem. There are an infinity of attack vectors, so which ones should one be concerned about? Probably not this one. | | --- | --- | --- | | | |  |  | [medo-bear](user?id=medo-bear) [48 days ago](item?id=42256951)   | [prev](#42257225) | [next](#42257481) [–]  It is (should be) well known that macros, lisp ones and even less capables ones from other languages, are problematic for security. I think a good temporary mitigation to this in Emacs is scanning 3rd party .el files for macros. If there is a macro present give trust warning and offer decreased functionality if untrusted | | --- | --- | --- | | | |  |  | [VyseofArcadia](user?id=VyseofArcadia) [48 days ago](item?id=42257181)   | [parent](#42256951) | [next](#42257466) [–]  Macros are pretty ubiquitous in lisp. This would result in a trust warning for pretty much every .el file. I think this would go about as well as Windows Vista UAC pop ups or State of California cancer warnings. If everything is dangerous, nothing is. | | --- | --- | --- | | | |  |  | [medo-bear](user?id=medo-bear) [48 days ago](item?id=42257642)   | [root](#42256951) | [parent](#42257181) | [next](#42257856) [–]  The qualifying term is 'trusted'. If you are running an application like emacs you damn sure better trust it. It's like running Windows and saying you don't trust it. AS for macros in lisp, they are not as ubiquitous as it might seem to an outsider. I write lisp professionally. I write one macro a month, if that, and often I rewrite it as a function afterwards. Saying that macros are ubiquitous in lisp is a meme. To most lispers macros are last resort | | --- | --- | --- | | | |  |  | [deng](user?id=deng) [48 days ago](item?id=42257856)   | [root](#42256951) | [parent](#42257181) | [prev](#42257642) | [next](#42257466) [–]  If I understand this correctly, this exploit only works with macros that evaluate at least one of their arguments, otherwise no code is actually run. These kind of macros are not that common. I guess one possible fix would be to mark these kind of macros as potentially dangerous and do not expand them automatically for things like code completion and such. | | --- | --- | --- | | | |  |  | [SoftTalker](user?id=SoftTalker) [48 days ago](item?id=42257466)   | [parent](#42256951) | [prev](#42257181) | [next](#42257481) [–]  This is what Word and Excel (used to?) do when opening (or was it previewing?) .doc and .xls files in email. Macros, if present, were disabled. | | --- | --- | --- | | | |  |  | [kazinator](user?id=kazinator) [47 days ago](item?id=42262628)   | [root](#42256951) | [parent](#42257466) | [next](#42257481) [–]  Microsoft office macros are not Lisp macros. When you load a Lisp source code file, each of the forms and that file is read and executed. You know like pretty much any scripting language. You don't need a macro to perpetrate damage. Bash doesn't have macros. yet it's a very bad idea to do this: ```   wget https://url | bash  ``` Lisp macros execute even when a file is not being executed but only compiled. What that means is that you have to trust a file in order to compile it because by doing so you're running it. Besides compiling any other tooling which expands macros is vulnerable to execution. As we can see in this article, there our situations when if you're working with list code inside Emacs, it will expand the macros. If you were going to blindly run the code anyway, that makes no difference. But developers often look at untrusted source code with no intention to run it and not expecting to do anything harmful just by sitting in their editor. In principle Lisp macros could be sandboxed. The vast majority of macros do not need to do any system access. They just look at their argument code pieces and calculate a new piece of code, without any side effects or accessing anything in the system. | | --- | --- | --- | | | |  |  | [WolfeReader](user?id=WolfeReader) [48 days ago](item?id=42257481)   | [prev](#42256951) | [next](#42260847) [–]  As a former Emacs advocate, I only use Emacs for org-mode and magit these days. These are still the finest stay-organized and Git UI modules I've ever seen, respectively, and are still enough to make sure I have Emacs on every system I use. For coding, I've gone over to VS Code (and sometimes Jetbrains). | | --- | --- | --- | | | |  |  | [PrismCrystal](user?id=PrismCrystal) [48 days ago](item?id=42257673)   | [parent](#42257481) | [next](#42258324) [–]  I did some FOSS hacking as a teenager a quarter-century ago, so learned Emacs, but then ultimately chose a career unrelated to software development. I still use Emacs for anything and everything text-related: email (Gnus), RSS feeds (elfeed), org-mode where I write up both personal TODOs and serious academic research. The keyboard-driven interface is powerful and now muscle-memory. The in-built Lisp environment makes everything nicely extensible, but Emacs as an IDE, as something people have used to create general software projects, is something I rarely think about. | | --- | --- | --- | | | |  |  | [BeetleB](user?id=BeetleB) [48 days ago](item?id=42258324)   | [parent](#42257481) | [prev](#42257673) | [next](#42260847) [–]  You use VSCode for coding, and Emacs for org and magit. What do you use for everything else? :-) As a sibling comment pointed out, many, if not most, long term heavy Emacs users are not using it for coding. | | --- | --- | --- | | | |  |  | [iLemming](user?id=iLemming) [46 days ago](item?id=42267794)   | [root](#42257481) | [parent](#42258324) | [next](#42260847) [–]  > long term heavy Emacs users are not using it for coding. That's not true. I have worked in number of teams where Emacs users were the majority. Most of them didn't use Org, some of them never used Magit, yet they've used it for coding. | | --- | --- | --- | | | |  |  | [BeetleB](user?id=BeetleB) [45 days ago](item?id=42276247)   | [root](#42257481) | [parent](#42267794) | [next](#42260847) [–]  > I have worked in number of teams where Emacs users were the majority. If most Emacs users aren't using it for programming, don't you think it's silly to narrow pick SW professionals as your population to sample from? | | --- | --- | --- | | | |  |  | [iLemming](user?id=iLemming) [45 days ago](item?id=42277287)   | [root](#42257481) | [parent](#42276247) | [next](#42260847) [–]  Hey, don't call my gang silly. They're not the ones who use Emacs for everything but coding, like some silly weirdos. :) | | --- | --- | --- | | | |  |  | [westmeal](user?id=westmeal) [47 days ago](item?id=42260847)   | [prev](#42257481) | [next](#42256728) [–]  This sounds like you shouldn't trust untrusted code. The only real attack vector I can see is if something fucks with MELPA packages that a lot of people use I guess. | | --- | --- | --- | | | |  |  | [wcunning](user?id=wcunning) [48 days ago](item?id=42256728)   | [prev](#42260847) | [next](#42257203) [–]  I'm obligated by tenants of my faith to point out that the best protection for this exploit is use of Vi(m) or NeoVim. You may throw tomatoes as soon as I duck behind this fence, thank you. | | --- | --- | --- | | | |  |  | [ramses0](user?id=ramses0) [48 days ago](item?id=42256834)   | [parent](#42256728) | [next](#42256825) [–]  vim used to have similar vulnerabilities (maybe still does?) via modelines: [https://security.stackexchange.com/questions/36001/vim-model...](https://security.stackexchange.com/questions/36001/vim-modeline-vulnerabilities) <https://lwn.net/Articles/20249/> Circa 2002-2003, and the LWN comment describing the exact same scope: """emacs is the same, if not worse. (See the node File Variables in the info docs.) You get not only to set random buffer-local variables, but also to evaluate arbitrary lisp code. Ouch!""" | | --- | --- | --- | | | |  |  | [Ferret7446](user?id=Ferret7446) [47 days ago](item?id=42261454)   | [root](#42256728) | [parent](#42256834) | [next](#42256926) [–]  At least for file variables, Emacs prompts before loading untrusted values. | | --- | --- | --- | | | |  |  | [nicce](user?id=nicce) [48 days ago](item?id=42256926)   | [root](#42256728) | [parent](#42256834) | [prev](#42261454) | [next](#42256825) [–]  Someone took the first tomato! | | --- | --- | --- | | | |  |  | [ramses0](user?id=ramses0) [48 days ago](item?id=42257745)   | [root](#42256728) | [parent](#42256926) | [next](#42256825) [–]  I'm firmly in the vim camp, just wanting to share the history, utterly surprised (but not...) that it's ~25+ years in the making. Funny story once checking a bug report, OG founder of the company dropped in: "I like to check in on my bug reports every 10 years..." It's not just an open-source issue, hard decisions are hard decisions. | | --- | --- | --- | | | |  |  | [bee\_rider](user?id=bee_rider) [48 days ago](item?id=42256825)   | [parent](#42256728) | [prev](#42256834) | [next](#42256786) [–]  The as a fellow renter of your faith, I’m are worried that somebody playing with the “modeline” option might burn down the place. | | --- | --- | --- | | | |  |  | [AnimalMuppet](user?id=AnimalMuppet) [48 days ago](item?id=42256786)   | [parent](#42256728) | [prev](#42256825) | [next](#42259276) [–]  "Tenets" of your faith. "Tenants" means that you are leasing out space in your faith to other people. | | --- | --- | --- | | | |  |  | [\_\_MatrixMan\_\_](user?id=__MatrixMan__) [48 days ago](item?id=42257080)   | [root](#42256728) | [parent](#42256786) | [next](#42256880) [–]  Wasn't the protestant reformation more or less about the tenants of that faith not wanting to pay rent anymore? | | --- | --- | --- | | | |  |  | [kykeonaut](user?id=kykeonaut) [48 days ago](item?id=42256880)   | [root](#42256728) | [parent](#42256786) | [prev](#42257080) | [next](#42259276) [–]  "tenants" clearly being the superior option | | --- | --- | --- | | | |  |  | [iLemming](user?id=iLemming) [47 days ago](item?id=42259276)   | [parent](#42256728) | [prev](#42256786) | [next](#42256988) [–]  Best protection from exploits is to disconnect your computer, shut it down, smash it with a sledgehammer, quit your job and become a florist. Whenever you folks say "just use Bla-bla instead of Emacs", you don't realize it's not even at the level of comparison between iOS and Android. Emacs provides unique capabilities that other applications simply cannot match in terms of simplicity and power. Like take for example Dired. Sure, there are number of vim plugins, but none of them match the full power of Emacs' Dired of treating directories as editable text. Or take Org-mode's source blocks. You can for example execute a piece of javascript, then pipe the result into another block in python, then the results of that into sql and finally output it as a chart. Or you can use source blocks for literate programming. I use them for managing my dotfiles - my entire system is almost immutable, not at the same level of Nix, but still very nice. Or take an Emacs package called consult-omni - you can type a search query once and it dynamically dispatches queries to Google, YouTube, Wikipedia, your browser history and other places, aggregating the results in one place. Crazy thing is that the package builts on top of another package which itself uses the built-in functions of Emacs. The power comes from ability to precisely change a behavior of any given function - built-in or a third party - that precision is just impossible in Vim, VSCode or IntelliJ - in Emacs, you can change specific point of any given function without having to rewrite it. It's not a matter of "faith" as you put it. People who choose Emacs don't do that because of some dogmas, beliefs or folklore. Emacs has earned its reputation as the most extensible software for sound technical reasons. Naturally, any powerful tool can be wielded for both constructive and destructive purposes. But you can't just suggest replacing a Caterpillar 797F Mining Truck with a electric scooter because of 'security concerns' - what am I supposed to do with my 400-ton payload of customizations? | | --- | --- | --- | | | |  |  | [voidUpdate](user?id=voidUpdate) [48 days ago](item?id=42256988)   | [parent](#42256728) | [prev](#42259276) | [next](#42257004) [–]  I'm obligated as part of my faith to point out that nano has none of these issues, as I understand that Vim will still execute arbitrary code in some circumstances | | --- | --- | --- | | | |  |  | [Y\_Y](user?id=Y_Y) [47 days ago](item?id=42258521)   | [root](#42256728) | [parent](#42256988) | [next](#42257020) [–]  I believe I nothing, but even I know that ed is the standard editor. | | --- | --- | --- | | | |  |  | [medo-bear](user?id=medo-bear) [48 days ago](item?id=42257020)   | [root](#42256728) | [parent](#42256988) | [prev](#42258521) | [next](#42257004) [–]  Of course it does except vim users have no idea how to read vim code so they wouldnt even know | | --- | --- | --- | | | |  |  | [dingnuts](user?id=dingnuts) [48 days ago](item?id=42257004)   | [parent](#42256728) | [prev](#42256988) | [next](#42257203) [–]  you're kidding but as an evil-mode user my first thought was "okay, inspect untrusted elisp in vim before opening it in emacs, got it" Thanks for downvoting! I'm not sure why that isn't a valid approach, but then, I've never understood why people have a competition between a text editor and a Lisp machine that has an implementation of that text editor in it | | --- | --- | --- | | | |  |  | [BlueTemplar](user?id=BlueTemplar) [48 days ago](item?id=42258365)   | [root](#42256728) | [parent](#42257004) | [next](#42257203) [–]  And vice-versa. Brilliant! | | --- | --- | --- | | | |  |  | [hofo](user?id=hofo) [48 days ago](item?id=42257203)   | [prev](#42256728) [–]  Step one: use vi Step two: there is no step two. | | --- | --- | --- | | | |  |  | [actionfromafar](user?id=actionfromafar) [48 days ago](item?id=42257276)   | [parent](#42257203) [–]  Ed is the standard editor. | | --- | --- | --- | | | |  |  | [tincholio](user?id=tincholio) [48 days ago](item?id=42258468)   | [root](#42257203) | [parent](#42257276) | [next](#42267826) [–]  ? | | --- | --- | --- | | | |  |  | [cylinder714](user?id=cylinder714) [46 days ago](item?id=42269407)   | [root](#42257203) | [parent](#42258468) | [next](#42260769) [–]  <https://www.gnu.org/fun/jokes/ed-msg.en.html> | | --- | --- | --- | | | |  |  | [IamDaedalus](user?id=IamDaedalus) [47 days ago](item?id=42260769)   | [root](#42257203) | [parent](#42258468) | [prev](#42269407) | [next](#42267826) [–]  top tier response | | --- | --- | --- | | | |  |  | [iLemming](user?id=iLemming) [46 days ago](item?id=42267826)   | [root](#42257203) | [parent](#42257276) | [prev](#42258468) | [next](#42269378) [–]  Emacs is not an editor. It's a Lisp REPL that has a built-in editor. It's much more than an editor. | | --- | --- | --- | | | |  |  | [cylinder714](user?id=cylinder714) [46 days ago](item?id=42269378)   | [root](#42257203) | [parent](#42257276) | [prev](#42267826) [–]  ed advocacy and useful tips: <https://x.com/ed1conf> | | --- | --- | --- | | |
| |  | | --- |   [Guidelines](newsguidelines.html) | [FAQ](newsfaq.html) | [Lists](lists) | [API](https://github.com/HackerNews/API) | [Security](security.html) | [Legal](https://www.ycombinator.com/legal/) | [Apply to YC](https://www.ycombinator.com/apply/) | Contact Search: |



=== Content from git.savannah.gnu.org_65c8bf3c_20250114_183254.html ===


| [cgit logo](/cgit/) | [index](/cgit/) : [emacs.git](/cgit/emacs.git/ "emacs.git") | bugfix/shorthand-fixes comment-cache concurrency-libtask dima\_regex\_embedded\_modifiers elparized-core emacs-23 emacs-24 emacs-25 emacs-26 emacs-27 emacs-28 emacs-29 emacs-30 feature/android feature/asan-gc-poisoning feature/auth-source-pass feature/breadcrumb-mode feature/byte-switch feature/byte-tail-recursion feature/byte-unwind-protect feature/cl-lib-improvements feature/comp-use-ctors feature/completion-lazy-hilit feature/completions-highlight-modifications feature/core-elpa-by-copy feature/deps-download feature/dll-only-windows feature/elpa-package feature/etags-update feature/etags\_update\_v2 feature/extend\_face\_id feature/external-completion feature/gnus-select feature/gnus-select2 feature/icomplete-vertical feature/inhibit-native-comp-cleanup feature/integrated-elpa feature/integration-of-dictionary-el feature/internal-msys feature/jit-improved-type-punning feature/jsonrpc-support-dap feature/libjit feature/mhtml-mode feature/minibuffer-completion-enhancements feature/more-fds feature/named-lambdas feature/new-tutorial feature/package+vc feature/package-autosuggest feature/parsable-ert-output feature/pgtk feature/positioned-lambdas feature/shorthand-namespacing feature/simple-16-theme feature/smaller-windows feature/soc-bytecode-in-traceback feature/soc-bytecode-in-traceback-reduced feature/stdout-stderr-stream feature/temacs-for-bootstrap feature/tramp-thread-safe feature/tree-sitter feature/type-hierarchy feature/windows-with-utils feature/xref-find-extra feature/zach-soc-bytecode-in-traceback feature/zach-soc-funcall-from-bytecode fix/bootstrap-build-minimize fix/bootstrap-build-minimize-squash fix/bug-2034 fix/bug-20871 fix/bug-35351 fix/bug-60974 fix/eieio-persistent fix/great-revert-bill fix/htmlfontify-21990 fix/not-defined-at-runtime girzel/gnus-headers gnus/nnatom master nick.lloyd-bytecode-jit old-branches/EMACS\_21\_1\_RC old-branches/EMACS\_22\_BASE old-branches/EMACS\_23\_1\_RC old-branches/NewVC-fileset old-branches/cairo old-branches/cedet-branch old-branches/concurrency old-branches/dynamic-modules-rc2 old-branches/emacs-unicode old-branches/emacs-unicode-2 old-branches/font-backend old-branches/gnus-5\_10-branch old-branches/lexbind old-branches/multi-tty old-branches/pending old-branches/profiler old-branches/python old-branches/rmail-mbox-branch old-branches/unicode-xft old-branches/window-pub other-branches/Boehm-GC other-branches/Boehm-versions other-branches/DAVELOVE other-branches/FLYSPELL other-branches/ILYA other-branches/VENDOR other-branches/fx-branch other-branches/gerd\_0001 other-branches/gerd\_dbe other-branches/old-bidi other-branches/old-concurrency other-branches/patches\_21\_0 other-branches/test2 other-branches/ttn-vms-21-2-stash other-branches/ttn-vms-21-3-stash pdumper scratch/a-modest-completion-redesign-proposal scratch/accurate-warning-pos scratch/add-jsonrpc scratch/add-lisp-data-mode scratch/albinus scratch/alloc scratch/allow-custom-load-paths-in-elisp-flymake scratch/allow-custom-null-and-false-objects-in-jsonc scratch/annotation-function-improvements scratch/api.el scratch/backend-completion scratch/benchmarks scratch/bug#48029 scratch/bug-42149-funny-pcm-completion-scores scratch/bug-50244 scratch/bug-50959-fix scratch/build-test scratch/bulk-tracing scratch/comp-branch-optim scratch/comp-static-data scratch/completion-api scratch/correct-warning-pos scratch/customize-quotes scratch/dbusbind-type scratch/dbusbind-type-tests scratch/eldoc-async scratch/eldoc-display-functions scratch/eldoc-eglot-rework scratch/eldoc-xref-project-gnu-elpa-core-packages scratch/electric-pair-cleanup-and-49518-bugfix scratch/elisp-benchmarks scratch/emacs-30-ts-query-patch scratch/emacs-editorconfig scratch/erc-oldies scratch/etags-regen scratch/eudc-bbdb-3 scratch/fcr scratch/fido-mode scratch/fix-40529-tabulated-list-mode-bootstrapping scratch/fix-snapshot-building scratch/flymake-augment-api scratch/flymake-fancy-end-of-line scratch/flymake-refactor-cleaner-for-emacs-26 scratch/follow scratch/font\_lock\_large\_files scratch/fontify-open-string scratch/func-type-decls scratch/gl-state-bytepos scratch/gnus-decoded scratch/gnus-docs scratch/gnus-hashtables scratch/gnus-roadmap scratch/gnus-search scratch/handler-bind-2 scratch/hard-narrow scratch/highlight-n-windows scratch/icomplete-lazy-highlight-attempt-2 scratch/icomplete-lazy-highlight-no-string-props scratch/icomplete-vertical-mode-gregory-and-joao scratch/icomplete-vertical-mode-improvements scratch/icons scratch/igc scratch/interpreted-function scratch/isearch-show-toggles scratch/joaot/make-completion-at-point-function scratch/kqueue scratch/last-cedet-merge scratch/lexspaces scratch/markers-as-gap-array scratch/merge-cedet-tests scratch/modern-mode scratch/multi-level-test-makefile scratch/native-timers-blocked scratch/new-flex-completion-style scratch/no-ls-lisp-advice scratch/no-purespace scratch/nonspecial-handlers scratch/np/backports-26.2 scratch/ns/emacs27-drawing scratch/octave-eldoc-fixes scratch/package-security scratch/pkg scratch/posix-spawn scratch/pure-overflow-warn scratch/python-eldoc-async scratch/raeburn-startup scratch/resolve-cc-mode-and-e-p-m scratch/reworked-icomplete-in-buffer-mode scratch/seccomp scratch/shorthand-namespacing scratch/some-more-icomplete-hacks scratch/support-plists-in-jsonc scratch/support-plists-in-jsonc-autodetect scratch/tango-icons scratch/timsort scratch/tsdh-vc-list-files scratch/tty-child-frames scratch/tzz/auth-source-reveal-mode scratch/tzz/cicd scratch/tzz/gnus-cloud-aead scratch/tzz/import-pl scratch/tzz/prettify-text-mode scratch/windows-98 scratch/windows-branch-build-2 scratch/with-fetched-url scratch/write-eglot-manual-for-advanced-server-config stream test-concurrency wallet xwidget xwidget\_mvp |
| --- | --- | --- |
| Emacs source repository |  |

| [summary](/cgit/emacs.git/?h=emacs-30.0.92)[refs](/cgit/emacs.git/refs/?h=emacs-30.0.92)[log](/cgit/emacs.git/log/?h=emacs-30.0.92)[tree](/cgit/emacs.git/tree/?h=emacs-30.0.92)[commit](/cgit/emacs.git/commit/?h=emacs-30.0.92)[diff](/cgit/emacs.git/diff/?h=emacs-30.0.92) | log msg author committer range |
| --- | --- |

| tag name | emacs-30.0.92 (881d593a9879f3355733f1b627af7cc0c12b429e) |
| --- | --- |
| tag date | 2024-10-26 13:10:55 +0200 |
| tagged by | Andrea Corallo <acorallo@gnu.org> |
| tagged object | [commit ed1d691184...](/cgit/emacs.git/commit/?h=emacs-30.0.92&id=ed1d691184df4b50da6b8e1a207e9ccd88aa9ffb) |
| download | [emacs-emacs-30.0.92.tar.gz](/cgit/emacs.git/snapshot/emacs-emacs-30.0.92.tar.gz) |

Emacs 30.0.92 pretest
generated by [cgit v1.1](https://git.zx2c4.com/cgit/about/) at 2025-01-14 18:32:54 +0000



=== Content from yhetil.org_c0215378_20250114_183602.html ===

```
[all messages for Emacs-related lists mirrored at yhetil.org](../?t=20180815215204)
 [help](../_/text/help/) / [color](../_/text/color/) / [mirror](../_/text/mirror/) / [code](#code) / [Atom feed](../new.atom)
```
```
From: Wilfred Hughes <me@wilfred.me.uk>
To: emacs-devel <[emacs-devel@gnu.org](https://yhetil.org/emacs-devel/?t=20180815215204)>
Subject: [Avoiding arbitrary code execution with macroexpansion](#r)
Date: Wed, 15 Aug 2018 22:52:04 +0100	[[thread overview]](#r)
Message-ID: <CAFXAjY5f4YfHAtZur1RAqH34UbYU56_t6t2Er0YEh1Sb7-W=hg@mail.gmail.com> (<raw>)

Hi emacs-devel

Today I realised that macroexpand-all isn't safe to call on arbitrary elisp:

(macroexpand-all '(eval-when-compile (debug)))

Using a macro that calls eval, such as eval-when-compile,
eval-and-compile, c-lang-defconst-eval-immediately (undoubtedly others
too), means anything can happen at macroexpansion time.

Unfortunately, some emacs packages assume this is a safe thing to do.
I used to think so, because macroexpand-all only executes macros that
are loaded (and therefore trusted) in the current Emacs instance.
Macros that eval code break this.

Even elisp-mode.el assumes this:

(let ((fooo (eval-when-compile (progn (debug)))))
  foo ;; <- put point here and M-x completion-at-point
  )

This means that I can get arbitrary code execution by you opening and
calling code completion a maliciously crafted elisp file!

Is this a security bug in Emacs?

In any case, is there a safe way to do macroexpansion? The best I can
think of is this:

(let ((macro-whitelist '(when pcase))
      all-macros
      safe-env)
  (mapatoms
   (lambda (sym)
     (when (macrop sym)
       (push sym all-macros))))
  (mapc
   (lambda (sym)
     (unless (memq sym macro-whitelist)
       (push (cons sym (symbol-function 'ignore))
             safe-env)))
   all-macros)

  (macroexpand-all
   arbitrary-form-here
   safe-env))

Thanks
Wilfred

```

---

```
[next](../3767608a-90f8-8606-8cb2-07acfe9b509b%40cs.ucla.edu/)             [reply](#R)other threads:[[~2018-08-15 21:52 UTC](../?t=20180815215204)|[newest](../)]

Thread overview: 5+ messages / expand[[flat](T/#u)|[nested](t/#u)]  [mbox.gz](t.mbox.gz)  [Atom feed](t.atom)  [top](#b)
2018-08-15 21:52 [Wilfred Hughes [this message]](#t)
2018-08-16 20:52 ` [Avoiding arbitrary code execution with macroexpansion](../3767608a-90f8-8606-8cb2-07acfe9b509b%40cs.ucla.edu/) Paul Eggert
2018-08-20  3:04 ` [Richard Stallman](../E1fraUU-0007Rx-DX%40fencepost.gnu.org/)
2018-08-22  0:15   ` [Wilfred Hughes](../CAFXAjY66dwPfCAhWAvMRKVjTKrguwbf4C2swge2UOdeqU0V9bw%40mail.gmail.com/)
2018-08-22 23:57     ` [Richard Stallman](../E1fsd0d-00070U-1n%40fencepost.gnu.org/)

```

---

```
Reply instructions:

You may reply publicly to [this message](#t) via plain-text email
using any one of the following methods:

* Save the following mbox file, import it into your mail client,
  and reply-to-all from there: [mbox](raw)

  Avoid top-posting and favor interleaved quoting:
  <https://en.wikipedia.org/wiki/Posting_style#Interleaved_style>

* Reply using the --to, --cc, and --in-reply-to
  switches of git-send-email(1):

  git send-email \
    --in-reply-to='CAFXAjY5f4YfHAtZur1RAqH34UbYU56_t6t2Er0YEh1Sb7-W=hg@mail.gmail.com' \
    --to=me@wilfred.me.uk \
    --cc=emacs-devel@gnu.org \
    /path/to/YOUR_REPLY

  <https://kernel.org/pub/software/scm/git/docs/git-send-email.html>

* If your mail client supports setting the In-Reply-To header
  via mailto: links, try the mailto: link

```
Be sure your reply has a **Subject:** header at the top and a blank line
before the message body.

---

```
Code repositories for project(s) associated with this external index

	<https://git.savannah.gnu.org/cgit/emacs.git>
	<https://git.savannah.gnu.org/cgit/emacs/org-mode.git>

This is an external index of several public inboxes,
see [mirroring instructions](../_/text/mirror/) on how to clone and mirror
all data and code used by this external index.
```


=== Content from eshelyaron.com_62743411_20250114_183253.html ===

[![Home](/home.svg)](/)[![Mail](/mail.svg)](/cdn-cgi/l/email-protection#dfb2ba9fbaacb7bab3a6beadb0b1f1bcb0b2) [![Mastodon](/mastodon.svg)](https://social.eshelyaron.com/%40eshel) [![RSS Feed](/rss.svg)](/rss.xml)

---

# Emacs Arbitrary Code Execution and How to Avoid It

Details and advice about a long-standing arbitrary code execution vulnerability in Emacs

Created on [2024-11-27], last updated [2024-12-20]

This is a security advisory about CVE-2024-53920, an Emacs
vulnerability that I (re-)discovered a few months ago.

## TL;DR

Viewing or editing Emacs Lisp code in Emacs can run arbitrary code.
The vulnerability stems from unsafe Lisp *macro-expansion*, which runs
unrestricted Emacs Lisp code. Most common configurations are
vulnerable (see details below). The best security measures are:

* Avoid visiting untrusted `.el` files in Emacs
* Disable automatic error checking (with Flymake or Flycheck) in
  untrusted `.el` files
* Disable auto-completion features in untrusted `.el` files
* UPDATE: Also set `enable-local-eval` to `nil`

This is a long-standing vulnerability which has been known for several
years, but has not been addressed thus far. Emacs maintainers are
working on countermeasures that will hopefully make their way into
future Emacs versions. This advisory is intended to help users of
existing Emacs versions protect themselves.

UPDATE: Mitigations are implemented in Emacs 30 (to be released soon).

## Update 2024-12-20

### Emacs 29.4 and earlier vulnerable by default

Following the publication of this advisory, I’ve got a couple of
emails about a way to exploit this issue in a default Emacs setup:
using *file-local variables*, an attacker can bring Emacs to enable
Flymake even if the user hasn’t configured it to start automatically.
As explained below, Flymake in Emacs versions 29.4 and earlier can
execute arbitrary code when enabled in Emacs Lisp buffers.

For example, putting the following in a `.el` file and opening it in
Emacs demonstrates the vulnerability in vanilla Emacs:

```
;; -*- eval: (flymake-mode 1) -*-
(rx (eval (call-process "touch" nil nil nil "/tmp/owned")))

```

To protect against this exploitation via file-local `eval` directives,
set option `enable-local-eval` to `nil`.

### Emacs 30 will ship with mitigations in place

The Emacs maintainers have implemented a safety mechanism which
disables Flymake and code completion induced macro-expansion in
untrusted files. This is already included in the latest Emacs 30
“pretest” release, version 30.0.93. See commits b5158bd1914,
8b6c6cffd1f, b9dc337ea74 and 8a0c9c234f1 in emacs.git for details.

## Background

*Macros* are a staple feature across Lisp dialects. They are often
cited as one of the superpowers of Lisp. They are essentially a
meta-programming facility: a macro is just a Lisp function that
outputs Lisp code. Since Lisp is homoiconic (code and data are
represented using the same data structures), manipulating Lisp code in
Lisp is as simple as processing any other program input. This makes
such meta-programming fun and easy, especially in comparison to the
experience of writing elaborate C preprocessor macros, for example,
which often feels a bit hackish.

However, as is often the case with great powers, Lisp macros are
double-edged swords—wielding them safely requires special care.

Normally, macros are executed, or “expanded”, during so-called
macro-expansion time: after parsing (“reading”) text into a Lisp form,
macro calls that occur in the form are expanded by executing the
macro, which produces new (sub-)forms. The macro-free form obtained
by expanding all macro calls can then be compiled and executed. Thus
macro-expansion time comes after “read time” and before compile time
and runtime.

*Emacs Lisp* is the programming language used implement most of
Emacs’s core features and extensions, as well as to configure it. It
is not the most powerful Lisp dialect out there, but it does boast a
full-blown meta-programming facility in the form of macros. The
problem is that macros in Emacs Lisp come with no safety
measures—they can execute arbitrary, unrestricted, Emacs Lisp code.
The basic macro-expansion primitive in Emacs is the Lisp function
`macroexpand`, defined in C code in `src/eval.c` in the Emacs sources.
It repeatedly replaces macro names with their definitions as
functions, and applies those functions to the provided code:

```
while (1)
  {
    /* Come back here each time we expand a macro call,
       in case it expands into another macro call.  */
...
    {
      Lisp_Object newform = apply1 (expander, XCDR (form));
      if (EQ (form, newform))
        break;
      else
        form = newform;
    }
  }
return form;

```

That `apply1` call up there can do, well, literally anything,
depending on the `expander` function (the definition of the macro) and
the given input `form`.

The Emacs Lisp library `macroexp.el` provides higher-level routines on
top of this `macroexpand` primitive, such as `macroexpand-all` which
the Lisp byte-compiler in `bytecomp.el` uses to preprocess Lisp forms.

In addition, Emacs ships with several built-in macros that actually do
execute arbitrary code by *evaluating* some of their arguments, no
questions asked. These macros are `static-if`, `rx`, `cl-eval-when`,
`eval-when-compile`, `eval-and-compile`, and perhaps others.

Therefore, if we can nudge Emacs to expand one of these macros, we get
arbitrary code execution. That’s the crux of this vulnerability.
*Expanding macros in Emacs Lisp is unsafe by design*.

## Exploitation

But could an attacker really coerce Emacs to expand macros without an
explicit user request? When you open (or “visit”, in Emacs parlance)
an Emacs Lisp file, Emacs enables “ELisp mode”, a dedicated editor
mode defined in `elisp-mode.el`, which provides various useful
features for exploring and editing Emacs Lisp code.

One of the features that ELisp mode provides is code completion.
Completion is implemented in the function `elisp-completion-at-point`,
which tries to examine the code around your cursor and come up with
relevant completions. Among other things, it invokes a subroutine
`elisp--local-variables` that looks for local variable names in the
current scope. Since macros can completely change the meaning of the
code they apply to, `elisp--local-variables` expands macros in the
surrounding code to uncover local variables that may be created or
obscured by such macros. Hence *invoking code completion runs
arbitrary code*. In vanilla Emacs, by default, code completion is
only triggered when you issue a completion command. However, since
macros run arbitrary code in a Turing complete language (Emacs Lisp),
there’s no way to know for sure whether invoking completion will get
you pwned. More importantly, almost no one uses the default Emacs
configuration. Emacs users tweak various knobs, and in many common
configurations folks enable auto-completion features which then
trigger code completion without an explicit completion command. Such
auto-completion is performed by the popular Emacs packages Corfu and
Company, as well as the newly built-in [Completion Preview mode](2023-11-17-completion-preview-in-emacs.html).

But the most common flow that involves automatic macro-expansion is
probably *on-the-fly code diagnosis*. There are two widespread Emacs
packages that check your code and warn about potential errors
automatically. One is Flymake, which is built into Emacs, and the
other is a popular extension package called [Flycheck](https://www.flycheck.org/en/latest/). Both of them,
when enabled in an ELisp mode buffer, check for code issues by
*byte-compiling* the code. As mentioned earlier, this involves
macro-expansion, and thus arbitrary code execution. For Flymake, this
byte-compilation happens in the function `elisp-flymake-byte-compile`.
Like auto-completion, on-the-fly diagnosis is not enabled by default
in vanilla Emacs, but it is extremely common for users to enable it.
In some Emacs “distributions”, such as the popular [Doom Emacs](https://github.com/doomemacs/doomemacs) and
[Prelude](https://prelude.emacsredux.com/en/latest/), either Flymake or Flycheck are enabled by default in ELisp
mode. (UPDATE: A malicious file can use file-local variables to
enable Flymake and trigger code execution in an Emacs Lisp file even
in the default configuration, see example above.)

So the idea is simple: to exploit this vulnerability, an attacker
crafts an Emacs Lisp file that includes a malicious macro invocation,
and sends that file to an unsuspecting Emacs user. When that user
opens the file in Emacs, code diagnosis is triggered automatically,
which expands macros and executes arbitrary code.

Here’s the content of the POC “malicious” file that I shared with the
Emacs maintainers when reporting this vulnerability:

```
(rx (eval (call-process "touch" nil nil nil "/tmp/owned")))

```

If you have Flymake or Flycheck hooked to ELisp mode (again, such a
setting is often the default in Emacs starter kits, and generally very
common among Emacs users), then just putting the above line of code
anywhere in a `.el` file and opening that file in Emacs will create a
new file `/tmp/owned` on your system. Such a setup usually looks
something like the following in the Emacs initialization file,
`~/.emacs.d/init.el`:

```
;; Unsafe common configuration.
(add-hook 'emacs-lisp-mode-hook #'flymake-mode)

```

This is reproducible at least since Emacs version from 26.1 and all
the way up to the development version of the upcoming Emacs 30.

So this is a long-standing vulnerability, and the gist of it is very
simple: macros are unsafe, and in common setups Emacs expands them
automatically. I’ve come to discover this issue while working on an
enhancement for ELisp mode, which employed macro-expansion to provide
semantic code highlighting. I quickly realized that doing so naively
is a security risk, and soon afterwards it hit me that Emacs suffered
from such a vulnerability already without my custom hacks.

The very same day, 2024-08-17, I reported my findings to the Emacs
maintainers via private email. The maintainers informed me that
variants of this issue have been surfaced in the past, but the issue,
sadly, still stands. AFAICT the earliest public discussion about the
security implications of Emacs Lisp macros started in August 2018,
when [Wilfred Hughes noted](https://yhetil.org/emacs/CAFXAjY5f4YfHAtZur1RAqH34UbYU56_t6t2Er0YEh1Sb7-W%3Dhg%40mail.gmail.com/) that code completion can lead to arbitrary
code execution via macro-expansion. In October 2019, [Adam Plaice
reported](https://yhetil.org/emacs/CAJw81da4%3DR1jMJ0enx6SbO7G1rzaL61K2kqbY%2Bjxhe%3DAM-3vtQ%40mail.gmail.com/) that Flymake specifically can be used in a similar exploit.
Some solutions have been floated in the discussions following these
reports, but unfortunately, Emacs remains vulnerable to this very day.

(UPDATE: Emacs 30 will ship with new guardrails that are already in
included in the pretest release.)

Following my report, the maintainers requested 90 days to work on a
fix before public disclosure. That non-disclosure period have since
expired, hence this advisory. They continue to work on a fix, which I
hope will be available soon, and now we at least have a CVE to track
this vulnerability. Until new guardrails are put in place to mitigate
this risk, it is important to realize that macro-expansion of
untrusted Emacs Lisp code is unsafe, and to be vigilant about `.el`
files that you open in Emacs. Crucially, **do not enable
Flymake/Flycheck in ELisp mode automatically**. Only allow automatic
macro-expansion in `.el` files that you trust and control, and protect
those files from tampering. (UPDATE: Also set `enable-local-eval` to
`nil`, otherwise file-local `eval` directives in a malicious file can
enable Flymake even if you don’t enable it automatically.)

---

Â© 2024 Eshel Yaron


