=== Content from git.kernel.org_9b40a8d9_20250114_203313.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=66600fac7a984dea4ae095411f644770b2561ede)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=66600fac7a984dea4ae095411f644770b2561ede)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=66600fac7a984dea4ae095411f644770b2561ede)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=66600fac7a984dea4ae095411f644770b2561ede)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Furong Xu <0x1207@gmail.com> | 2024-10-21 14:10:23 +0800 |
| --- | --- | --- |
| committer | Paolo Abeni <pabeni@redhat.com> | 2024-10-29 11:37:10 +0100 |
| commit | [66600fac7a984dea4ae095411f644770b2561ede](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=66600fac7a984dea4ae095411f644770b2561ede) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=66600fac7a984dea4ae095411f644770b2561ede)) | |
| tree | [407f8e8533a0f7320cbf220159fe8e80a5a2e639](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=66600fac7a984dea4ae095411f644770b2561ede) | |
| parent | [f84ef58e553206b02d06e02158c98fbccba25d19](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f84ef58e553206b02d06e02158c98fbccba25d19) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=66600fac7a984dea4ae095411f644770b2561ede&id2=f84ef58e553206b02d06e02158c98fbccba25d19)) | |
| download | [linux-66600fac7a984dea4ae095411f644770b2561ede.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-66600fac7a984dea4ae095411f644770b2561ede.tar.gz) | |

net: stmmac: TSO: Fix unbalanced DMA map/unmap for non-paged SKB dataIn case the non-paged data of a SKB carries protocol header and protocol
payload to be transmitted on a certain platform that the DMA AXI address
width is configured to 40-bit/48-bit, or the size of the non-paged data
is bigger than TSO\_MAX\_BUFF\_SIZE on a certain platform that the DMA AXI
address width is configured to 32-bit, then this SKB requires at least
two DMA transmit descriptors to serve it.
For example, three descriptors are allocated to split one DMA buffer
mapped from one piece of non-paged data:
dma\_desc[N + 0],
dma\_desc[N + 1],
dma\_desc[N + 2].
Then three elements of tx\_q->tx\_skbuff\_dma[] will be allocated to hold
extra information to be reused in stmmac\_tx\_clean():
tx\_q->tx\_skbuff\_dma[N + 0],
tx\_q->tx\_skbuff\_dma[N + 1],
tx\_q->tx\_skbuff\_dma[N + 2].
Now we focus on tx\_q->tx\_skbuff\_dma[entry].buf, which is the DMA buffer
address returned by DMA mapping call. stmmac\_tx\_clean() will try to
unmap the DMA buffer \_ONLY\_IF\_ tx\_q->tx\_skbuff\_dma[entry].buf
is a valid buffer address.
The expected behavior that saves DMA buffer address of this non-paged
data to tx\_q->tx\_skbuff\_dma[entry].buf is:
tx\_q->tx\_skbuff\_dma[N + 0].buf = NULL;
tx\_q->tx\_skbuff\_dma[N + 1].buf = NULL;
tx\_q->tx\_skbuff\_dma[N + 2].buf = dma\_map\_single();
Unfortunately, the current code misbehaves like this:
tx\_q->tx\_skbuff\_dma[N + 0].buf = dma\_map\_single();
tx\_q->tx\_skbuff\_dma[N + 1].buf = NULL;
tx\_q->tx\_skbuff\_dma[N + 2].buf = NULL;
On the stmmac\_tx\_clean() side, when dma\_desc[N + 0] is closed by the
DMA engine, tx\_q->tx\_skbuff\_dma[N + 0].buf is a valid buffer address
obviously, then the DMA buffer will be unmapped immediately.
There may be a rare case that the DMA engine does not finish the
pending dma\_desc[N + 1], dma\_desc[N + 2] yet. Now things will go
horribly wrong, DMA is going to access a unmapped/unreferenced memory
region, corrupted data will be transmited or iommu fault will be
triggered :(
In contrast, the for-loop that maps SKB fragments behaves perfectly
as expected, and that is how the driver should do for both non-paged
data and paged frags actually.
This patch corrects DMA map/unmap sequences by fixing the array index
for tx\_q->tx\_skbuff\_dma[entry].buf when assigning DMA buffer address.
Tested and verified on DWXGMAC CORE 3.20a
Reported-by: Suraj Jaiswal <quic\_jsuraj@quicinc.com>
Fixes: f748be531d70 ("stmmac: support new GMAC4")
Signed-off-by: Furong Xu <0x1207@gmail.com>
Reviewed-by: Hariprasad Kelam <hkelam@marvell.com>
Reviewed-by: Simon Horman <horms@kernel.org>
Link: [https://patch.msgid.link/20241021061023.2162701-1-0x1207@gmail.com](https://patch.msgid.link/20241021061023.2162701-1-0x1207%40gmail.com)
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=66600fac7a984dea4ae095411f644770b2561ede)

| -rw-r--r-- | [drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=66600fac7a984dea4ae095411f644770b2561ede) | 22 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 17 insertions, 5 deletions

| diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac\_main.cindex d3895d7eecfc52..208dbc68aaf9d4 100644--- a/[drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=f84ef58e553206b02d06e02158c98fbccba25d19)+++ b/[drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=66600fac7a984dea4ae095411f644770b2561ede)@@ -4304,11 +4304,6 @@ static netdev\_tx\_t stmmac\_tso\_xmit(struct sk\_buff \*skb, struct net\_device \*dev) if (dma\_mapping\_error(priv->device, des)) goto dma\_map\_err; - tx\_q->tx\_skbuff\_dma[first\_entry].buf = des;- tx\_q->tx\_skbuff\_dma[first\_entry].len = skb\_headlen(skb);- tx\_q->tx\_skbuff\_dma[first\_entry].map\_as\_page = false;- tx\_q->tx\_skbuff\_dma[first\_entry].buf\_type = STMMAC\_TXBUF\_T\_SKB;- if (priv->dma\_cap.addr64 <= 32) { first->des0 = cpu\_to\_le32(des); @@ -4327,6 +4322,23 @@ static netdev\_tx\_t stmmac\_tso\_xmit(struct sk\_buff \*skb, struct net\_device \*dev)  stmmac\_tso\_allocator(priv, des, tmp\_pay\_len, (nfrags == 0), queue); + /\* In case two or more DMA transmit descriptors are allocated for this+ \* non-paged SKB data, the DMA buffer address should be saved to+ \* tx\_q->tx\_skbuff\_dma[].buf corresponding to the last descriptor,+ \* and leave the other tx\_q->tx\_skbuff\_dma[].buf as NULL to guarantee+ \* that stmmac\_tx\_clean() does not unmap the entire DMA buffer too early+ \* since the tail areas of the DMA buffer can be accessed by DMA engine+ \* sooner or later.+ \* By saving the DMA buffer address to tx\_q->tx\_skbuff\_dma[].buf+ \* corresponding to the last descriptor, stmmac\_tx\_clean() will unmap+ \* this DMA buffer right after the DMA engine completely finishes the+ \* full buffer transmission.+ \*/+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].buf = des;+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].len = skb\_headlen(skb);+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].map\_as\_page = false;+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].buf\_type = STMMAC\_TXBUF\_T\_SKB;+ /\* Prepare fragments \*/ for (i = 0; i < nfrags; i++) { const skb\_frag\_t \*frag = &skb\_shinfo(skb)->frags[i]; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:31:50 +0000



=== Content from git.kernel.org_32fdb49a_20250114_203314.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=ece593fc9c00741b682869d3f3dc584d37b7c9df)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ece593fc9c00741b682869d3f3dc584d37b7c9df)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ece593fc9c00741b682869d3f3dc584d37b7c9df)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ece593fc9c00741b682869d3f3dc584d37b7c9df)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Furong Xu <0x1207@gmail.com> | 2024-10-21 14:10:23 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-08 16:25:52 +0100 |
| commit | [ece593fc9c00741b682869d3f3dc584d37b7c9df](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ece593fc9c00741b682869d3f3dc584d37b7c9df) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=ece593fc9c00741b682869d3f3dc584d37b7c9df)) | |
| tree | [449b7df79b7c17a07c88e8a20a84deb6f1afe285](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ece593fc9c00741b682869d3f3dc584d37b7c9df) | |
| parent | [720be854fb6ef7d1127b51d88e3262979b65919c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=720be854fb6ef7d1127b51d88e3262979b65919c) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ece593fc9c00741b682869d3f3dc584d37b7c9df&id2=720be854fb6ef7d1127b51d88e3262979b65919c)) | |
| download | [linux-ece593fc9c00741b682869d3f3dc584d37b7c9df.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-ece593fc9c00741b682869d3f3dc584d37b7c9df.tar.gz) | |

net: stmmac: TSO: Fix unbalanced DMA map/unmap for non-paged SKB data[ Upstream commit 66600fac7a984dea4ae095411f644770b2561ede ]
In case the non-paged data of a SKB carries protocol header and protocol
payload to be transmitted on a certain platform that the DMA AXI address
width is configured to 40-bit/48-bit, or the size of the non-paged data
is bigger than TSO\_MAX\_BUFF\_SIZE on a certain platform that the DMA AXI
address width is configured to 32-bit, then this SKB requires at least
two DMA transmit descriptors to serve it.
For example, three descriptors are allocated to split one DMA buffer
mapped from one piece of non-paged data:
dma\_desc[N + 0],
dma\_desc[N + 1],
dma\_desc[N + 2].
Then three elements of tx\_q->tx\_skbuff\_dma[] will be allocated to hold
extra information to be reused in stmmac\_tx\_clean():
tx\_q->tx\_skbuff\_dma[N + 0],
tx\_q->tx\_skbuff\_dma[N + 1],
tx\_q->tx\_skbuff\_dma[N + 2].
Now we focus on tx\_q->tx\_skbuff\_dma[entry].buf, which is the DMA buffer
address returned by DMA mapping call. stmmac\_tx\_clean() will try to
unmap the DMA buffer \_ONLY\_IF\_ tx\_q->tx\_skbuff\_dma[entry].buf
is a valid buffer address.
The expected behavior that saves DMA buffer address of this non-paged
data to tx\_q->tx\_skbuff\_dma[entry].buf is:
tx\_q->tx\_skbuff\_dma[N + 0].buf = NULL;
tx\_q->tx\_skbuff\_dma[N + 1].buf = NULL;
tx\_q->tx\_skbuff\_dma[N + 2].buf = dma\_map\_single();
Unfortunately, the current code misbehaves like this:
tx\_q->tx\_skbuff\_dma[N + 0].buf = dma\_map\_single();
tx\_q->tx\_skbuff\_dma[N + 1].buf = NULL;
tx\_q->tx\_skbuff\_dma[N + 2].buf = NULL;
On the stmmac\_tx\_clean() side, when dma\_desc[N + 0] is closed by the
DMA engine, tx\_q->tx\_skbuff\_dma[N + 0].buf is a valid buffer address
obviously, then the DMA buffer will be unmapped immediately.
There may be a rare case that the DMA engine does not finish the
pending dma\_desc[N + 1], dma\_desc[N + 2] yet. Now things will go
horribly wrong, DMA is going to access a unmapped/unreferenced memory
region, corrupted data will be transmited or iommu fault will be
triggered :(
In contrast, the for-loop that maps SKB fragments behaves perfectly
as expected, and that is how the driver should do for both non-paged
data and paged frags actually.
This patch corrects DMA map/unmap sequences by fixing the array index
for tx\_q->tx\_skbuff\_dma[entry].buf when assigning DMA buffer address.
Tested and verified on DWXGMAC CORE 3.20a
Reported-by: Suraj Jaiswal <quic\_jsuraj@quicinc.com>
Fixes: f748be531d70 ("stmmac: support new GMAC4")
Signed-off-by: Furong Xu <0x1207@gmail.com>
Reviewed-by: Hariprasad Kelam <hkelam@marvell.com>
Reviewed-by: Simon Horman <horms@kernel.org>
Link: [https://patch.msgid.link/20241021061023.2162701-1-0x1207@gmail.com](https://patch.msgid.link/20241021061023.2162701-1-0x1207%40gmail.com)
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ece593fc9c00741b682869d3f3dc584d37b7c9df)

| -rw-r--r-- | [drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=ece593fc9c00741b682869d3f3dc584d37b7c9df) | 22 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 17 insertions, 5 deletions

| diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac\_main.cindex b62d153f1676ec..4a194f30f4a834 100644--- a/[drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=720be854fb6ef7d1127b51d88e3262979b65919c)+++ b/[drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=ece593fc9c00741b682869d3f3dc584d37b7c9df)@@ -4110,11 +4110,6 @@ static netdev\_tx\_t stmmac\_tso\_xmit(struct sk\_buff \*skb, struct net\_device \*dev) if (dma\_mapping\_error(priv->device, des)) goto dma\_map\_err; - tx\_q->tx\_skbuff\_dma[first\_entry].buf = des;- tx\_q->tx\_skbuff\_dma[first\_entry].len = skb\_headlen(skb);- tx\_q->tx\_skbuff\_dma[first\_entry].map\_as\_page = false;- tx\_q->tx\_skbuff\_dma[first\_entry].buf\_type = STMMAC\_TXBUF\_T\_SKB;- if (priv->dma\_cap.addr64 <= 32) { first->des0 = cpu\_to\_le32(des); @@ -4133,6 +4128,23 @@ static netdev\_tx\_t stmmac\_tso\_xmit(struct sk\_buff \*skb, struct net\_device \*dev)  stmmac\_tso\_allocator(priv, des, tmp\_pay\_len, (nfrags == 0), queue); + /\* In case two or more DMA transmit descriptors are allocated for this+ \* non-paged SKB data, the DMA buffer address should be saved to+ \* tx\_q->tx\_skbuff\_dma[].buf corresponding to the last descriptor,+ \* and leave the other tx\_q->tx\_skbuff\_dma[].buf as NULL to guarantee+ \* that stmmac\_tx\_clean() does not unmap the entire DMA buffer too early+ \* since the tail areas of the DMA buffer can be accessed by DMA engine+ \* sooner or later.+ \* By saving the DMA buffer address to tx\_q->tx\_skbuff\_dma[].buf+ \* corresponding to the last descriptor, stmmac\_tx\_clean() will unmap+ \* this DMA buffer right after the DMA engine completely finishes the+ \* full buffer transmission.+ \*/+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].buf = des;+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].len = skb\_headlen(skb);+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].map\_as\_page = false;+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].buf\_type = STMMAC\_TXBUF\_T\_SKB;+ /\* Prepare fragments \*/ for (i = 0; i < nfrags; i++) { const skb\_frag\_t \*frag = &skb\_shinfo(skb)->frags[i]; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:31:51 +0000



=== Content from git.kernel.org_f85ffe81_20250114_203312.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=58d23d835eb498336716cca55b5714191a309286)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=58d23d835eb498336716cca55b5714191a309286)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=58d23d835eb498336716cca55b5714191a309286)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=58d23d835eb498336716cca55b5714191a309286)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Furong Xu <0x1207@gmail.com> | 2024-10-21 14:10:23 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-08 16:30:47 +0100 |
| commit | [58d23d835eb498336716cca55b5714191a309286](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=58d23d835eb498336716cca55b5714191a309286) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=58d23d835eb498336716cca55b5714191a309286)) | |
| tree | [289f33c53d3f256e4e52b4eb1d25463fd027b871](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=58d23d835eb498336716cca55b5714191a309286) | |
| parent | [73f17fbebe43f033d32dd3ef3c6339ea947aab66](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=73f17fbebe43f033d32dd3ef3c6339ea947aab66) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=58d23d835eb498336716cca55b5714191a309286&id2=73f17fbebe43f033d32dd3ef3c6339ea947aab66)) | |
| download | [linux-58d23d835eb498336716cca55b5714191a309286.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-58d23d835eb498336716cca55b5714191a309286.tar.gz) | |

net: stmmac: TSO: Fix unbalanced DMA map/unmap for non-paged SKB data[ Upstream commit 66600fac7a984dea4ae095411f644770b2561ede ]
In case the non-paged data of a SKB carries protocol header and protocol
payload to be transmitted on a certain platform that the DMA AXI address
width is configured to 40-bit/48-bit, or the size of the non-paged data
is bigger than TSO\_MAX\_BUFF\_SIZE on a certain platform that the DMA AXI
address width is configured to 32-bit, then this SKB requires at least
two DMA transmit descriptors to serve it.
For example, three descriptors are allocated to split one DMA buffer
mapped from one piece of non-paged data:
dma\_desc[N + 0],
dma\_desc[N + 1],
dma\_desc[N + 2].
Then three elements of tx\_q->tx\_skbuff\_dma[] will be allocated to hold
extra information to be reused in stmmac\_tx\_clean():
tx\_q->tx\_skbuff\_dma[N + 0],
tx\_q->tx\_skbuff\_dma[N + 1],
tx\_q->tx\_skbuff\_dma[N + 2].
Now we focus on tx\_q->tx\_skbuff\_dma[entry].buf, which is the DMA buffer
address returned by DMA mapping call. stmmac\_tx\_clean() will try to
unmap the DMA buffer \_ONLY\_IF\_ tx\_q->tx\_skbuff\_dma[entry].buf
is a valid buffer address.
The expected behavior that saves DMA buffer address of this non-paged
data to tx\_q->tx\_skbuff\_dma[entry].buf is:
tx\_q->tx\_skbuff\_dma[N + 0].buf = NULL;
tx\_q->tx\_skbuff\_dma[N + 1].buf = NULL;
tx\_q->tx\_skbuff\_dma[N + 2].buf = dma\_map\_single();
Unfortunately, the current code misbehaves like this:
tx\_q->tx\_skbuff\_dma[N + 0].buf = dma\_map\_single();
tx\_q->tx\_skbuff\_dma[N + 1].buf = NULL;
tx\_q->tx\_skbuff\_dma[N + 2].buf = NULL;
On the stmmac\_tx\_clean() side, when dma\_desc[N + 0] is closed by the
DMA engine, tx\_q->tx\_skbuff\_dma[N + 0].buf is a valid buffer address
obviously, then the DMA buffer will be unmapped immediately.
There may be a rare case that the DMA engine does not finish the
pending dma\_desc[N + 1], dma\_desc[N + 2] yet. Now things will go
horribly wrong, DMA is going to access a unmapped/unreferenced memory
region, corrupted data will be transmited or iommu fault will be
triggered :(
In contrast, the for-loop that maps SKB fragments behaves perfectly
as expected, and that is how the driver should do for both non-paged
data and paged frags actually.
This patch corrects DMA map/unmap sequences by fixing the array index
for tx\_q->tx\_skbuff\_dma[entry].buf when assigning DMA buffer address.
Tested and verified on DWXGMAC CORE 3.20a
Reported-by: Suraj Jaiswal <quic\_jsuraj@quicinc.com>
Fixes: f748be531d70 ("stmmac: support new GMAC4")
Signed-off-by: Furong Xu <0x1207@gmail.com>
Reviewed-by: Hariprasad Kelam <hkelam@marvell.com>
Reviewed-by: Simon Horman <horms@kernel.org>
Link: [https://patch.msgid.link/20241021061023.2162701-1-0x1207@gmail.com](https://patch.msgid.link/20241021061023.2162701-1-0x1207%40gmail.com)
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=58d23d835eb498336716cca55b5714191a309286)

| -rw-r--r-- | [drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=58d23d835eb498336716cca55b5714191a309286) | 22 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 17 insertions, 5 deletions

| diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac\_main.cindex f3a1b179aaeaca..02368917efb4ad 100644--- a/[drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=73f17fbebe43f033d32dd3ef3c6339ea947aab66)+++ b/[drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=58d23d835eb498336716cca55b5714191a309286)@@ -4330,11 +4330,6 @@ static netdev\_tx\_t stmmac\_tso\_xmit(struct sk\_buff \*skb, struct net\_device \*dev) if (dma\_mapping\_error(priv->device, des)) goto dma\_map\_err; - tx\_q->tx\_skbuff\_dma[first\_entry].buf = des;- tx\_q->tx\_skbuff\_dma[first\_entry].len = skb\_headlen(skb);- tx\_q->tx\_skbuff\_dma[first\_entry].map\_as\_page = false;- tx\_q->tx\_skbuff\_dma[first\_entry].buf\_type = STMMAC\_TXBUF\_T\_SKB;- if (priv->dma\_cap.addr64 <= 32) { first->des0 = cpu\_to\_le32(des); @@ -4353,6 +4348,23 @@ static netdev\_tx\_t stmmac\_tso\_xmit(struct sk\_buff \*skb, struct net\_device \*dev)  stmmac\_tso\_allocator(priv, des, tmp\_pay\_len, (nfrags == 0), queue); + /\* In case two or more DMA transmit descriptors are allocated for this+ \* non-paged SKB data, the DMA buffer address should be saved to+ \* tx\_q->tx\_skbuff\_dma[].buf corresponding to the last descriptor,+ \* and leave the other tx\_q->tx\_skbuff\_dma[].buf as NULL to guarantee+ \* that stmmac\_tx\_clean() does not unmap the entire DMA buffer too early+ \* since the tail areas of the DMA buffer can be accessed by DMA engine+ \* sooner or later.+ \* By saving the DMA buffer address to tx\_q->tx\_skbuff\_dma[].buf+ \* corresponding to the last descriptor, stmmac\_tx\_clean() will unmap+ \* this DMA buffer right after the DMA engine completely finishes the+ \* full buffer transmission.+ \*/+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].buf = des;+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].len = skb\_headlen(skb);+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].map\_as\_page = false;+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].buf\_type = STMMAC\_TXBUF\_T\_SKB;+ /\* Prepare fragments \*/ for (i = 0; i < nfrags; i++) { const skb\_frag\_t \*frag = &skb\_shinfo(skb)->frags[i]; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:31:50 +0000



=== Content from git.kernel.org_3b8258fd_20250114_203312.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=07c9c26e37542486e34d767505e842f48f29c3f6)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=07c9c26e37542486e34d767505e842f48f29c3f6)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=07c9c26e37542486e34d767505e842f48f29c3f6)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=07c9c26e37542486e34d767505e842f48f29c3f6)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Furong Xu <0x1207@gmail.com> | 2024-10-21 14:10:23 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-08 16:28:18 +0100 |
| commit | [07c9c26e37542486e34d767505e842f48f29c3f6](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=07c9c26e37542486e34d767505e842f48f29c3f6) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=07c9c26e37542486e34d767505e842f48f29c3f6)) | |
| tree | [b29cf29144622bea867d5609b4c6a49a5d4f1b20](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=07c9c26e37542486e34d767505e842f48f29c3f6) | |
| parent | [bf6b2cd3c55de9a241e8fce0f417ebb0cc42ff54](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bf6b2cd3c55de9a241e8fce0f417ebb0cc42ff54) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=07c9c26e37542486e34d767505e842f48f29c3f6&id2=bf6b2cd3c55de9a241e8fce0f417ebb0cc42ff54)) | |
| download | [linux-07c9c26e37542486e34d767505e842f48f29c3f6.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-07c9c26e37542486e34d767505e842f48f29c3f6.tar.gz) | |

net: stmmac: TSO: Fix unbalanced DMA map/unmap for non-paged SKB data[ Upstream commit 66600fac7a984dea4ae095411f644770b2561ede ]
In case the non-paged data of a SKB carries protocol header and protocol
payload to be transmitted on a certain platform that the DMA AXI address
width is configured to 40-bit/48-bit, or the size of the non-paged data
is bigger than TSO\_MAX\_BUFF\_SIZE on a certain platform that the DMA AXI
address width is configured to 32-bit, then this SKB requires at least
two DMA transmit descriptors to serve it.
For example, three descriptors are allocated to split one DMA buffer
mapped from one piece of non-paged data:
dma\_desc[N + 0],
dma\_desc[N + 1],
dma\_desc[N + 2].
Then three elements of tx\_q->tx\_skbuff\_dma[] will be allocated to hold
extra information to be reused in stmmac\_tx\_clean():
tx\_q->tx\_skbuff\_dma[N + 0],
tx\_q->tx\_skbuff\_dma[N + 1],
tx\_q->tx\_skbuff\_dma[N + 2].
Now we focus on tx\_q->tx\_skbuff\_dma[entry].buf, which is the DMA buffer
address returned by DMA mapping call. stmmac\_tx\_clean() will try to
unmap the DMA buffer \_ONLY\_IF\_ tx\_q->tx\_skbuff\_dma[entry].buf
is a valid buffer address.
The expected behavior that saves DMA buffer address of this non-paged
data to tx\_q->tx\_skbuff\_dma[entry].buf is:
tx\_q->tx\_skbuff\_dma[N + 0].buf = NULL;
tx\_q->tx\_skbuff\_dma[N + 1].buf = NULL;
tx\_q->tx\_skbuff\_dma[N + 2].buf = dma\_map\_single();
Unfortunately, the current code misbehaves like this:
tx\_q->tx\_skbuff\_dma[N + 0].buf = dma\_map\_single();
tx\_q->tx\_skbuff\_dma[N + 1].buf = NULL;
tx\_q->tx\_skbuff\_dma[N + 2].buf = NULL;
On the stmmac\_tx\_clean() side, when dma\_desc[N + 0] is closed by the
DMA engine, tx\_q->tx\_skbuff\_dma[N + 0].buf is a valid buffer address
obviously, then the DMA buffer will be unmapped immediately.
There may be a rare case that the DMA engine does not finish the
pending dma\_desc[N + 1], dma\_desc[N + 2] yet. Now things will go
horribly wrong, DMA is going to access a unmapped/unreferenced memory
region, corrupted data will be transmited or iommu fault will be
triggered :(
In contrast, the for-loop that maps SKB fragments behaves perfectly
as expected, and that is how the driver should do for both non-paged
data and paged frags actually.
This patch corrects DMA map/unmap sequences by fixing the array index
for tx\_q->tx\_skbuff\_dma[entry].buf when assigning DMA buffer address.
Tested and verified on DWXGMAC CORE 3.20a
Reported-by: Suraj Jaiswal <quic\_jsuraj@quicinc.com>
Fixes: f748be531d70 ("stmmac: support new GMAC4")
Signed-off-by: Furong Xu <0x1207@gmail.com>
Reviewed-by: Hariprasad Kelam <hkelam@marvell.com>
Reviewed-by: Simon Horman <horms@kernel.org>
Link: [https://patch.msgid.link/20241021061023.2162701-1-0x1207@gmail.com](https://patch.msgid.link/20241021061023.2162701-1-0x1207%40gmail.com)
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=07c9c26e37542486e34d767505e842f48f29c3f6)

| -rw-r--r-- | [drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=07c9c26e37542486e34d767505e842f48f29c3f6) | 22 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 17 insertions, 5 deletions

| diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac\_main.cindex d6167a7b19f21b..a116423adb30a3 100644--- a/[drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=bf6b2cd3c55de9a241e8fce0f417ebb0cc42ff54)+++ b/[drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=07c9c26e37542486e34d767505e842f48f29c3f6)@@ -4196,11 +4196,6 @@ static netdev\_tx\_t stmmac\_tso\_xmit(struct sk\_buff \*skb, struct net\_device \*dev) if (dma\_mapping\_error(priv->device, des)) goto dma\_map\_err; - tx\_q->tx\_skbuff\_dma[first\_entry].buf = des;- tx\_q->tx\_skbuff\_dma[first\_entry].len = skb\_headlen(skb);- tx\_q->tx\_skbuff\_dma[first\_entry].map\_as\_page = false;- tx\_q->tx\_skbuff\_dma[first\_entry].buf\_type = STMMAC\_TXBUF\_T\_SKB;- if (priv->dma\_cap.addr64 <= 32) { first->des0 = cpu\_to\_le32(des); @@ -4219,6 +4214,23 @@ static netdev\_tx\_t stmmac\_tso\_xmit(struct sk\_buff \*skb, struct net\_device \*dev)  stmmac\_tso\_allocator(priv, des, tmp\_pay\_len, (nfrags == 0), queue); + /\* In case two or more DMA transmit descriptors are allocated for this+ \* non-paged SKB data, the DMA buffer address should be saved to+ \* tx\_q->tx\_skbuff\_dma[].buf corresponding to the last descriptor,+ \* and leave the other tx\_q->tx\_skbuff\_dma[].buf as NULL to guarantee+ \* that stmmac\_tx\_clean() does not unmap the entire DMA buffer too early+ \* since the tail areas of the DMA buffer can be accessed by DMA engine+ \* sooner or later.+ \* By saving the DMA buffer address to tx\_q->tx\_skbuff\_dma[].buf+ \* corresponding to the last descriptor, stmmac\_tx\_clean() will unmap+ \* this DMA buffer right after the DMA engine completely finishes the+ \* full buffer transmission.+ \*/+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].buf = des;+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].len = skb\_headlen(skb);+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].map\_as\_page = false;+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].buf\_type = STMMAC\_TXBUF\_T\_SKB;+ /\* Prepare fragments \*/ for (i = 0; i < nfrags; i++) { const skb\_frag\_t \*frag = &skb\_shinfo(skb)->frags[i]; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:31:49 +0000



=== Content from git.kernel.org_53e264ea_20250114_203314.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=a3ff23f7c3f0e13f718900803e090fd3997d6bc9)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a3ff23f7c3f0e13f718900803e090fd3997d6bc9)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a3ff23f7c3f0e13f718900803e090fd3997d6bc9)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a3ff23f7c3f0e13f718900803e090fd3997d6bc9)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Furong Xu <0x1207@gmail.com> | 2024-10-21 14:10:23 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-08 16:26:41 +0100 |
| commit | [a3ff23f7c3f0e13f718900803e090fd3997d6bc9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a3ff23f7c3f0e13f718900803e090fd3997d6bc9) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=a3ff23f7c3f0e13f718900803e090fd3997d6bc9)) | |
| tree | [79c424375cf27a9fed596cf88b48b06a242927a3](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a3ff23f7c3f0e13f718900803e090fd3997d6bc9) | |
| parent | [872932cf75cf859804370a265dd58118129386fa](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=872932cf75cf859804370a265dd58118129386fa) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a3ff23f7c3f0e13f718900803e090fd3997d6bc9&id2=872932cf75cf859804370a265dd58118129386fa)) | |
| download | [linux-a3ff23f7c3f0e13f718900803e090fd3997d6bc9.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-a3ff23f7c3f0e13f718900803e090fd3997d6bc9.tar.gz) | |

net: stmmac: TSO: Fix unbalanced DMA map/unmap for non-paged SKB data[ Upstream commit 66600fac7a984dea4ae095411f644770b2561ede ]
In case the non-paged data of a SKB carries protocol header and protocol
payload to be transmitted on a certain platform that the DMA AXI address
width is configured to 40-bit/48-bit, or the size of the non-paged data
is bigger than TSO\_MAX\_BUFF\_SIZE on a certain platform that the DMA AXI
address width is configured to 32-bit, then this SKB requires at least
two DMA transmit descriptors to serve it.
For example, three descriptors are allocated to split one DMA buffer
mapped from one piece of non-paged data:
dma\_desc[N + 0],
dma\_desc[N + 1],
dma\_desc[N + 2].
Then three elements of tx\_q->tx\_skbuff\_dma[] will be allocated to hold
extra information to be reused in stmmac\_tx\_clean():
tx\_q->tx\_skbuff\_dma[N + 0],
tx\_q->tx\_skbuff\_dma[N + 1],
tx\_q->tx\_skbuff\_dma[N + 2].
Now we focus on tx\_q->tx\_skbuff\_dma[entry].buf, which is the DMA buffer
address returned by DMA mapping call. stmmac\_tx\_clean() will try to
unmap the DMA buffer \_ONLY\_IF\_ tx\_q->tx\_skbuff\_dma[entry].buf
is a valid buffer address.
The expected behavior that saves DMA buffer address of this non-paged
data to tx\_q->tx\_skbuff\_dma[entry].buf is:
tx\_q->tx\_skbuff\_dma[N + 0].buf = NULL;
tx\_q->tx\_skbuff\_dma[N + 1].buf = NULL;
tx\_q->tx\_skbuff\_dma[N + 2].buf = dma\_map\_single();
Unfortunately, the current code misbehaves like this:
tx\_q->tx\_skbuff\_dma[N + 0].buf = dma\_map\_single();
tx\_q->tx\_skbuff\_dma[N + 1].buf = NULL;
tx\_q->tx\_skbuff\_dma[N + 2].buf = NULL;
On the stmmac\_tx\_clean() side, when dma\_desc[N + 0] is closed by the
DMA engine, tx\_q->tx\_skbuff\_dma[N + 0].buf is a valid buffer address
obviously, then the DMA buffer will be unmapped immediately.
There may be a rare case that the DMA engine does not finish the
pending dma\_desc[N + 1], dma\_desc[N + 2] yet. Now things will go
horribly wrong, DMA is going to access a unmapped/unreferenced memory
region, corrupted data will be transmited or iommu fault will be
triggered :(
In contrast, the for-loop that maps SKB fragments behaves perfectly
as expected, and that is how the driver should do for both non-paged
data and paged frags actually.
This patch corrects DMA map/unmap sequences by fixing the array index
for tx\_q->tx\_skbuff\_dma[entry].buf when assigning DMA buffer address.
Tested and verified on DWXGMAC CORE 3.20a
Reported-by: Suraj Jaiswal <quic\_jsuraj@quicinc.com>
Fixes: f748be531d70 ("stmmac: support new GMAC4")
Signed-off-by: Furong Xu <0x1207@gmail.com>
Reviewed-by: Hariprasad Kelam <hkelam@marvell.com>
Reviewed-by: Simon Horman <horms@kernel.org>
Link: [https://patch.msgid.link/20241021061023.2162701-1-0x1207@gmail.com](https://patch.msgid.link/20241021061023.2162701-1-0x1207%40gmail.com)
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a3ff23f7c3f0e13f718900803e090fd3997d6bc9)

| -rw-r--r-- | [drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=a3ff23f7c3f0e13f718900803e090fd3997d6bc9) | 22 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 17 insertions, 5 deletions

| diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac\_main.cindex 93630840309e7e..045e57c444fd73 100644--- a/[drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=872932cf75cf859804370a265dd58118129386fa)+++ b/[drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=a3ff23f7c3f0e13f718900803e090fd3997d6bc9)@@ -4183,11 +4183,6 @@ static netdev\_tx\_t stmmac\_tso\_xmit(struct sk\_buff \*skb, struct net\_device \*dev) if (dma\_mapping\_error(priv->device, des)) goto dma\_map\_err; - tx\_q->tx\_skbuff\_dma[first\_entry].buf = des;- tx\_q->tx\_skbuff\_dma[first\_entry].len = skb\_headlen(skb);- tx\_q->tx\_skbuff\_dma[first\_entry].map\_as\_page = false;- tx\_q->tx\_skbuff\_dma[first\_entry].buf\_type = STMMAC\_TXBUF\_T\_SKB;- if (priv->dma\_cap.addr64 <= 32) { first->des0 = cpu\_to\_le32(des); @@ -4206,6 +4201,23 @@ static netdev\_tx\_t stmmac\_tso\_xmit(struct sk\_buff \*skb, struct net\_device \*dev)  stmmac\_tso\_allocator(priv, des, tmp\_pay\_len, (nfrags == 0), queue); + /\* In case two or more DMA transmit descriptors are allocated for this+ \* non-paged SKB data, the DMA buffer address should be saved to+ \* tx\_q->tx\_skbuff\_dma[].buf corresponding to the last descriptor,+ \* and leave the other tx\_q->tx\_skbuff\_dma[].buf as NULL to guarantee+ \* that stmmac\_tx\_clean() does not unmap the entire DMA buffer too early+ \* since the tail areas of the DMA buffer can be accessed by DMA engine+ \* sooner or later.+ \* By saving the DMA buffer address to tx\_q->tx\_skbuff\_dma[].buf+ \* corresponding to the last descriptor, stmmac\_tx\_clean() will unmap+ \* this DMA buffer right after the DMA engine completely finishes the+ \* full buffer transmission.+ \*/+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].buf = des;+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].len = skb\_headlen(skb);+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].map\_as\_page = false;+ tx\_q->tx\_skbuff\_dma[tx\_q->cur\_tx].buf\_type = STMMAC\_TXBUF\_T\_SKB;+ /\* Prepare fragments \*/ for (i = 0; i < nfrags; i++) { const skb\_frag\_t \*frag = &skb\_shinfo(skb)->frags[i]; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:31:51 +0000


