=== Content from git.kernel.org_30b5f44c_20250114_202318.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=791f833053578b9fd24252ebb7162a61bc3f805b)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=791f833053578b9fd24252ebb7162a61bc3f805b)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=791f833053578b9fd24252ebb7162a61bc3f805b)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=791f833053578b9fd24252ebb7162a61bc3f805b)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Paul Aurich <paul@darkrain42.org> | 2024-11-18 13:50:27 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-09 10:32:52 +0100 |
| commit | [791f833053578b9fd24252ebb7162a61bc3f805b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=791f833053578b9fd24252ebb7162a61bc3f805b) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=791f833053578b9fd24252ebb7162a61bc3f805b)) | |
| tree | [7dda8a6f396105ad1b2aa1670fdd2ec91a0eddac](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=791f833053578b9fd24252ebb7162a61bc3f805b) | |
| parent | [31fabf70d58388d5475e48ca8a6b7d2847b36678](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=31fabf70d58388d5475e48ca8a6b7d2847b36678) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=791f833053578b9fd24252ebb7162a61bc3f805b&id2=31fabf70d58388d5475e48ca8a6b7d2847b36678)) | |
| download | [linux-791f833053578b9fd24252ebb7162a61bc3f805b.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-791f833053578b9fd24252ebb7162a61bc3f805b.tar.gz) | |

smb: prevent use-after-free due to open\_cached\_dir error pathscommit a9685b409a03b73d2980bbfa53eb47555802d0a9 upstream.
If open\_cached\_dir() encounters an error parsing the lease from the
server, the error handling may race with receiving a lease break,
resulting in open\_cached\_dir() freeing the cfid while the queued work is
pending.
Update open\_cached\_dir() to drop refs rather than directly freeing the
cfid.
Have cached\_dir\_lease\_break(), cfids\_laundromat\_worker(), and
invalidate\_all\_cached\_dirs() clear has\_lease immediately while still
holding cfids->cfid\_list\_lock, and then use this to also simplify the
reference counting in cfids\_laundromat\_worker() and
invalidate\_all\_cached\_dirs().
Fixes this KASAN splat (which manually injects an error and lease break
in open\_cached\_dir()):
==================================================================
BUG: KASAN: slab-use-after-free in smb2\_cached\_lease\_break+0x27/0xb0
Read of size 8 at addr ffff88811cc24c10 by task kworker/3:1/65
CPU: 3 UID: 0 PID: 65 Comm: kworker/3:1 Not tainted 6.12.0-rc6-g255cf264e6e5-dirty #87
Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020
Workqueue: cifsiod smb2\_cached\_lease\_break
Call Trace:
<TASK>
dump\_stack\_lvl+0x77/0xb0
print\_report+0xce/0x660
kasan\_report+0xd3/0x110
smb2\_cached\_lease\_break+0x27/0xb0
process\_one\_work+0x50a/0xc50
worker\_thread+0x2ba/0x530
kthread+0x17c/0x1c0
ret\_from\_fork+0x34/0x60
ret\_from\_fork\_asm+0x1a/0x30
</TASK>
Allocated by task 2464:
kasan\_save\_stack+0x33/0x60
kasan\_save\_track+0x14/0x30
\_\_kasan\_kmalloc+0xaa/0xb0
open\_cached\_dir+0xa7d/0x1fb0
smb2\_query\_path\_info+0x43c/0x6e0
cifs\_get\_fattr+0x346/0xf10
cifs\_get\_inode\_info+0x157/0x210
cifs\_revalidate\_dentry\_attr+0x2d1/0x460
cifs\_getattr+0x173/0x470
vfs\_statx\_path+0x10f/0x160
vfs\_statx+0xe9/0x150
vfs\_fstatat+0x5e/0xc0
\_\_do\_sys\_newfstatat+0x91/0xf0
do\_syscall\_64+0x95/0x1a0
entry\_SYSCALL\_64\_after\_hwframe+0x76/0x7e
Freed by task 2464:
kasan\_save\_stack+0x33/0x60
kasan\_save\_track+0x14/0x30
kasan\_save\_free\_info+0x3b/0x60
\_\_kasan\_slab\_free+0x51/0x70
kfree+0x174/0x520
open\_cached\_dir+0x97f/0x1fb0
smb2\_query\_path\_info+0x43c/0x6e0
cifs\_get\_fattr+0x346/0xf10
cifs\_get\_inode\_info+0x157/0x210
cifs\_revalidate\_dentry\_attr+0x2d1/0x460
cifs\_getattr+0x173/0x470
vfs\_statx\_path+0x10f/0x160
vfs\_statx+0xe9/0x150
vfs\_fstatat+0x5e/0xc0
\_\_do\_sys\_newfstatat+0x91/0xf0
do\_syscall\_64+0x95/0x1a0
entry\_SYSCALL\_64\_after\_hwframe+0x76/0x7e
Last potentially related work creation:
kasan\_save\_stack+0x33/0x60
\_\_kasan\_record\_aux\_stack+0xad/0xc0
insert\_work+0x32/0x100
\_\_queue\_work+0x5c9/0x870
queue\_work\_on+0x82/0x90
open\_cached\_dir+0x1369/0x1fb0
smb2\_query\_path\_info+0x43c/0x6e0
cifs\_get\_fattr+0x346/0xf10
cifs\_get\_inode\_info+0x157/0x210
cifs\_revalidate\_dentry\_attr+0x2d1/0x460
cifs\_getattr+0x173/0x470
vfs\_statx\_path+0x10f/0x160
vfs\_statx+0xe9/0x150
vfs\_fstatat+0x5e/0xc0
\_\_do\_sys\_newfstatat+0x91/0xf0
do\_syscall\_64+0x95/0x1a0
entry\_SYSCALL\_64\_after\_hwframe+0x76/0x7e
The buggy address belongs to the object at ffff88811cc24c00
which belongs to the cache kmalloc-1k of size 1024
The buggy address is located 16 bytes inside of
freed 1024-byte region [ffff88811cc24c00, ffff88811cc25000)
Cc: stable@vger.kernel.org
Signed-off-by: Paul Aurich <paul@darkrain42.org>
Signed-off-by: Steve French <stfrench@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=791f833053578b9fd24252ebb7162a61bc3f805b)

| -rw-r--r-- | [fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cached_dir.c?id=791f833053578b9fd24252ebb7162a61bc3f805b) | 70 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 29 insertions, 41 deletions

| diff --git a/fs/smb/client/cached\_dir.c b/fs/smb/client/cached\_dir.cindex bb9d4c284ce577..06eb19dabb0ecc 100644--- a/[fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.c?id=31fabf70d58388d5475e48ca8a6b7d2847b36678)+++ b/[fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.c?id=791f833053578b9fd24252ebb7162a61bc3f805b)@@ -348,6 +348,7 @@ oshr\_free: SMB2\_query\_info\_free(&rqst[1]); free\_rsp\_buf(resp\_buftype[0], rsp\_iov[0].iov\_base); free\_rsp\_buf(resp\_buftype[1], rsp\_iov[1].iov\_base);+out: if (rc) { spin\_lock(&cfids->cfid\_list\_lock); if (cfid->on\_list) {@@ -359,23 +360,14 @@ oshr\_free: /\* \* We are guaranteed to have two references at this \* point. One for the caller and one for a potential- \* lease. Release the Lease-ref so that the directory- \* will be closed when the caller closes the cached- \* handle.+ \* lease. Release one here, and the second below. \*/ cfid->has\_lease = false;- spin\_unlock(&cfids->cfid\_list\_lock); kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);- goto out; } spin\_unlock(&cfids->cfid\_list\_lock);- }-out:- if (rc) {- if (cfid->is\_open)- SMB2\_close(0, cfid->tcon, cfid->fid.persistent\_fid,- cfid->fid.volatile\_fid);- free\_cached\_dir(cfid);++ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); } else { \*ret\_cfid = cfid; atomic\_inc(&tcon->num\_remote\_opens);@@ -513,25 +505,24 @@ void invalidate\_all\_cached\_dirs(struct cifs\_tcon \*tcon) cfids->num\_entries--; cfid->is\_open = false; cfid->on\_list = false;- /\* To prevent race with smb2\_cached\_lease\_break() \*/- kref\_get(&cfid->refcount);+ if (cfid->has\_lease) {+ /\*+ \* The lease was never cancelled from the server,+ \* so steal that reference.+ \*/+ cfid->has\_lease = false;+ } else+ kref\_get(&cfid->refcount); } spin\_unlock(&cfids->cfid\_list\_lock);  list\_for\_each\_entry\_safe(cfid, q, &entry, entry) { list\_del(&cfid->entry); cancel\_work\_sync(&cfid->lease\_break);- if (cfid->has\_lease) {- /\*- \* We lease was never cancelled from the server so we- \* need to drop the reference.- \*/- spin\_lock(&cfids->cfid\_list\_lock);- cfid->has\_lease = false;- spin\_unlock(&cfids->cfid\_list\_lock);- kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);- }- /\* Drop the extra reference opened above\*/+ /\*+ \* Drop the ref-count from above, either the lease-ref (if there+ \* was one) or the extra one acquired.+ \*/ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); } }@@ -542,9 +533,6 @@ smb2\_cached\_lease\_break(struct work\_struct \*work) struct cached\_fid \*cfid = container\_of(work, struct cached\_fid, lease\_break); - spin\_lock(&cfid->cfids->cfid\_list\_lock);- cfid->has\_lease = false;- spin\_unlock(&cfid->cfids->cfid\_list\_lock); kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); } @@ -562,6 +550,7 @@ int cached\_dir\_lease\_break(struct cifs\_tcon \*tcon, \_\_u8 lease\_key[16]) !memcmp(lease\_key, cfid->fid.lease\_key, SMB2\_LEASE\_KEY\_SIZE)) {+ cfid->has\_lease = false; cfid->time = 0; /\* \* We found a lease remove it from the list@@ -639,8 +628,14 @@ static void cfids\_laundromat\_worker(struct work\_struct \*work) cfid->on\_list = false; list\_move(&cfid->entry, &entry); cfids->num\_entries--;- /\* To prevent race with smb2\_cached\_lease\_break() \*/- kref\_get(&cfid->refcount);+ if (cfid->has\_lease) {+ /\*+ \* Our lease has not yet been cancelled from the+ \* server. Steal that reference.+ \*/+ cfid->has\_lease = false;+ } else+ kref\_get(&cfid->refcount); } } spin\_unlock(&cfids->cfid\_list\_lock);@@ -652,17 +647,10 @@ static void cfids\_laundromat\_worker(struct work\_struct \*work) \* with it. \*/ cancel\_work\_sync(&cfid->lease\_break);- if (cfid->has\_lease) {- /\*- \* Our lease has not yet been cancelled from the server- \* so we need to drop the reference.- \*/- spin\_lock(&cfids->cfid\_list\_lock);- cfid->has\_lease = false;- spin\_unlock(&cfids->cfid\_list\_lock);- kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);- }- /\* Drop the extra reference opened above \*/+ /\*+ \* Drop the ref-count from above, either the lease-ref (if there+ \* was one) or the extra one acquired.+ \*/ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); } queue\_delayed\_work(cifsiod\_wq, &cfids->laundromat\_work, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:21:55 +0000



=== Content from git.kernel.org_fc6aedc7_20250114_202319.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=a9685b409a03b73d2980bbfa53eb47555802d0a9)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a9685b409a03b73d2980bbfa53eb47555802d0a9)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a9685b409a03b73d2980bbfa53eb47555802d0a9)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a9685b409a03b73d2980bbfa53eb47555802d0a9)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Paul Aurich <paul@darkrain42.org> | 2024-11-18 13:50:27 -0800 |
| --- | --- | --- |
| committer | Steve French <stfrench@microsoft.com> | 2024-11-21 10:45:50 -0600 |
| commit | [a9685b409a03b73d2980bbfa53eb47555802d0a9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a9685b409a03b73d2980bbfa53eb47555802d0a9) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=a9685b409a03b73d2980bbfa53eb47555802d0a9)) | |
| tree | [87a74ffe093dea41171a9a8826128ff61d78485f](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a9685b409a03b73d2980bbfa53eb47555802d0a9) | |
| parent | [7afb86733685c64c604d32faf00fa4a1f22c2ab1](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7afb86733685c64c604d32faf00fa4a1f22c2ab1) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a9685b409a03b73d2980bbfa53eb47555802d0a9&id2=7afb86733685c64c604d32faf00fa4a1f22c2ab1)) | |
| download | [linux-a9685b409a03b73d2980bbfa53eb47555802d0a9.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-a9685b409a03b73d2980bbfa53eb47555802d0a9.tar.gz) | |

smb: prevent use-after-free due to open\_cached\_dir error pathsIf open\_cached\_dir() encounters an error parsing the lease from the
server, the error handling may race with receiving a lease break,
resulting in open\_cached\_dir() freeing the cfid while the queued work is
pending.
Update open\_cached\_dir() to drop refs rather than directly freeing the
cfid.
Have cached\_dir\_lease\_break(), cfids\_laundromat\_worker(), and
invalidate\_all\_cached\_dirs() clear has\_lease immediately while still
holding cfids->cfid\_list\_lock, and then use this to also simplify the
reference counting in cfids\_laundromat\_worker() and
invalidate\_all\_cached\_dirs().
Fixes this KASAN splat (which manually injects an error and lease break
in open\_cached\_dir()):
==================================================================
BUG: KASAN: slab-use-after-free in smb2\_cached\_lease\_break+0x27/0xb0
Read of size 8 at addr ffff88811cc24c10 by task kworker/3:1/65
CPU: 3 UID: 0 PID: 65 Comm: kworker/3:1 Not tainted 6.12.0-rc6-g255cf264e6e5-dirty #87
Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020
Workqueue: cifsiod smb2\_cached\_lease\_break
Call Trace:
<TASK>
dump\_stack\_lvl+0x77/0xb0
print\_report+0xce/0x660
kasan\_report+0xd3/0x110
smb2\_cached\_lease\_break+0x27/0xb0
process\_one\_work+0x50a/0xc50
worker\_thread+0x2ba/0x530
kthread+0x17c/0x1c0
ret\_from\_fork+0x34/0x60
ret\_from\_fork\_asm+0x1a/0x30
</TASK>
Allocated by task 2464:
kasan\_save\_stack+0x33/0x60
kasan\_save\_track+0x14/0x30
\_\_kasan\_kmalloc+0xaa/0xb0
open\_cached\_dir+0xa7d/0x1fb0
smb2\_query\_path\_info+0x43c/0x6e0
cifs\_get\_fattr+0x346/0xf10
cifs\_get\_inode\_info+0x157/0x210
cifs\_revalidate\_dentry\_attr+0x2d1/0x460
cifs\_getattr+0x173/0x470
vfs\_statx\_path+0x10f/0x160
vfs\_statx+0xe9/0x150
vfs\_fstatat+0x5e/0xc0
\_\_do\_sys\_newfstatat+0x91/0xf0
do\_syscall\_64+0x95/0x1a0
entry\_SYSCALL\_64\_after\_hwframe+0x76/0x7e
Freed by task 2464:
kasan\_save\_stack+0x33/0x60
kasan\_save\_track+0x14/0x30
kasan\_save\_free\_info+0x3b/0x60
\_\_kasan\_slab\_free+0x51/0x70
kfree+0x174/0x520
open\_cached\_dir+0x97f/0x1fb0
smb2\_query\_path\_info+0x43c/0x6e0
cifs\_get\_fattr+0x346/0xf10
cifs\_get\_inode\_info+0x157/0x210
cifs\_revalidate\_dentry\_attr+0x2d1/0x460
cifs\_getattr+0x173/0x470
vfs\_statx\_path+0x10f/0x160
vfs\_statx+0xe9/0x150
vfs\_fstatat+0x5e/0xc0
\_\_do\_sys\_newfstatat+0x91/0xf0
do\_syscall\_64+0x95/0x1a0
entry\_SYSCALL\_64\_after\_hwframe+0x76/0x7e
Last potentially related work creation:
kasan\_save\_stack+0x33/0x60
\_\_kasan\_record\_aux\_stack+0xad/0xc0
insert\_work+0x32/0x100
\_\_queue\_work+0x5c9/0x870
queue\_work\_on+0x82/0x90
open\_cached\_dir+0x1369/0x1fb0
smb2\_query\_path\_info+0x43c/0x6e0
cifs\_get\_fattr+0x346/0xf10
cifs\_get\_inode\_info+0x157/0x210
cifs\_revalidate\_dentry\_attr+0x2d1/0x460
cifs\_getattr+0x173/0x470
vfs\_statx\_path+0x10f/0x160
vfs\_statx+0xe9/0x150
vfs\_fstatat+0x5e/0xc0
\_\_do\_sys\_newfstatat+0x91/0xf0
do\_syscall\_64+0x95/0x1a0
entry\_SYSCALL\_64\_after\_hwframe+0x76/0x7e
The buggy address belongs to the object at ffff88811cc24c00
which belongs to the cache kmalloc-1k of size 1024
The buggy address is located 16 bytes inside of
freed 1024-byte region [ffff88811cc24c00, ffff88811cc25000)
Cc: stable@vger.kernel.org
Signed-off-by: Paul Aurich <paul@darkrain42.org>
Signed-off-by: Steve French <stfrench@microsoft.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a9685b409a03b73d2980bbfa53eb47555802d0a9)

| -rw-r--r-- | [fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cached_dir.c?id=a9685b409a03b73d2980bbfa53eb47555802d0a9) | 70 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 29 insertions, 41 deletions

| diff --git a/fs/smb/client/cached\_dir.c b/fs/smb/client/cached\_dir.cindex bb9d4c284ce577..06eb19dabb0ecc 100644--- a/[fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.c?id=7afb86733685c64c604d32faf00fa4a1f22c2ab1)+++ b/[fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.c?id=a9685b409a03b73d2980bbfa53eb47555802d0a9)@@ -348,6 +348,7 @@ oshr\_free: SMB2\_query\_info\_free(&rqst[1]); free\_rsp\_buf(resp\_buftype[0], rsp\_iov[0].iov\_base); free\_rsp\_buf(resp\_buftype[1], rsp\_iov[1].iov\_base);+out: if (rc) { spin\_lock(&cfids->cfid\_list\_lock); if (cfid->on\_list) {@@ -359,23 +360,14 @@ oshr\_free: /\* \* We are guaranteed to have two references at this \* point. One for the caller and one for a potential- \* lease. Release the Lease-ref so that the directory- \* will be closed when the caller closes the cached- \* handle.+ \* lease. Release one here, and the second below. \*/ cfid->has\_lease = false;- spin\_unlock(&cfids->cfid\_list\_lock); kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);- goto out; } spin\_unlock(&cfids->cfid\_list\_lock);- }-out:- if (rc) {- if (cfid->is\_open)- SMB2\_close(0, cfid->tcon, cfid->fid.persistent\_fid,- cfid->fid.volatile\_fid);- free\_cached\_dir(cfid);++ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); } else { \*ret\_cfid = cfid; atomic\_inc(&tcon->num\_remote\_opens);@@ -513,25 +505,24 @@ void invalidate\_all\_cached\_dirs(struct cifs\_tcon \*tcon) cfids->num\_entries--; cfid->is\_open = false; cfid->on\_list = false;- /\* To prevent race with smb2\_cached\_lease\_break() \*/- kref\_get(&cfid->refcount);+ if (cfid->has\_lease) {+ /\*+ \* The lease was never cancelled from the server,+ \* so steal that reference.+ \*/+ cfid->has\_lease = false;+ } else+ kref\_get(&cfid->refcount); } spin\_unlock(&cfids->cfid\_list\_lock);  list\_for\_each\_entry\_safe(cfid, q, &entry, entry) { list\_del(&cfid->entry); cancel\_work\_sync(&cfid->lease\_break);- if (cfid->has\_lease) {- /\*- \* We lease was never cancelled from the server so we- \* need to drop the reference.- \*/- spin\_lock(&cfids->cfid\_list\_lock);- cfid->has\_lease = false;- spin\_unlock(&cfids->cfid\_list\_lock);- kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);- }- /\* Drop the extra reference opened above\*/+ /\*+ \* Drop the ref-count from above, either the lease-ref (if there+ \* was one) or the extra one acquired.+ \*/ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); } }@@ -542,9 +533,6 @@ smb2\_cached\_lease\_break(struct work\_struct \*work) struct cached\_fid \*cfid = container\_of(work, struct cached\_fid, lease\_break); - spin\_lock(&cfid->cfids->cfid\_list\_lock);- cfid->has\_lease = false;- spin\_unlock(&cfid->cfids->cfid\_list\_lock); kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); } @@ -562,6 +550,7 @@ int cached\_dir\_lease\_break(struct cifs\_tcon \*tcon, \_\_u8 lease\_key[16]) !memcmp(lease\_key, cfid->fid.lease\_key, SMB2\_LEASE\_KEY\_SIZE)) {+ cfid->has\_lease = false; cfid->time = 0; /\* \* We found a lease remove it from the list@@ -639,8 +628,14 @@ static void cfids\_laundromat\_worker(struct work\_struct \*work) cfid->on\_list = false; list\_move(&cfid->entry, &entry); cfids->num\_entries--;- /\* To prevent race with smb2\_cached\_lease\_break() \*/- kref\_get(&cfid->refcount);+ if (cfid->has\_lease) {+ /\*+ \* Our lease has not yet been cancelled from the+ \* server. Steal that reference.+ \*/+ cfid->has\_lease = false;+ } else+ kref\_get(&cfid->refcount); } } spin\_unlock(&cfids->cfid\_list\_lock);@@ -652,17 +647,10 @@ static void cfids\_laundromat\_worker(struct work\_struct \*work) \* with it. \*/ cancel\_work\_sync(&cfid->lease\_break);- if (cfid->has\_lease) {- /\*- \* Our lease has not yet been cancelled from the server- \* so we need to drop the reference.- \*/- spin\_lock(&cfids->cfid\_list\_lock);- cfid->has\_lease = false;- spin\_unlock(&cfids->cfid\_list\_lock);- kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);- }- /\* Drop the extra reference opened above \*/+ /\*+ \* Drop the ref-count from above, either the lease-ref (if there+ \* was one) or the extra one acquired.+ \*/ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); } queue\_delayed\_work(cifsiod\_wq, &cfids->laundromat\_work, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:21:56 +0000



=== Content from git.kernel.org_a7d8219f_20250114_202317.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=47655a12c6b1bca8fa230085eab2e85a076932b7)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=47655a12c6b1bca8fa230085eab2e85a076932b7)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=47655a12c6b1bca8fa230085eab2e85a076932b7)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=47655a12c6b1bca8fa230085eab2e85a076932b7)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Paul Aurich <paul@darkrain42.org> | 2024-11-18 13:50:27 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-05 14:03:00 +0100 |
| commit | [47655a12c6b1bca8fa230085eab2e85a076932b7](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=47655a12c6b1bca8fa230085eab2e85a076932b7) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=47655a12c6b1bca8fa230085eab2e85a076932b7)) | |
| tree | [a8924c91d480461f0fc088faddb1a4344782146a](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=47655a12c6b1bca8fa230085eab2e85a076932b7) | |
| parent | [73a57b25b4df23f22814fc06b7e8f9cf570be026](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=73a57b25b4df23f22814fc06b7e8f9cf570be026) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=47655a12c6b1bca8fa230085eab2e85a076932b7&id2=73a57b25b4df23f22814fc06b7e8f9cf570be026)) | |
| download | [linux-47655a12c6b1bca8fa230085eab2e85a076932b7.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-47655a12c6b1bca8fa230085eab2e85a076932b7.tar.gz) | |

smb: prevent use-after-free due to open\_cached\_dir error pathscommit a9685b409a03b73d2980bbfa53eb47555802d0a9 upstream.
If open\_cached\_dir() encounters an error parsing the lease from the
server, the error handling may race with receiving a lease break,
resulting in open\_cached\_dir() freeing the cfid while the queued work is
pending.
Update open\_cached\_dir() to drop refs rather than directly freeing the
cfid.
Have cached\_dir\_lease\_break(), cfids\_laundromat\_worker(), and
invalidate\_all\_cached\_dirs() clear has\_lease immediately while still
holding cfids->cfid\_list\_lock, and then use this to also simplify the
reference counting in cfids\_laundromat\_worker() and
invalidate\_all\_cached\_dirs().
Fixes this KASAN splat (which manually injects an error and lease break
in open\_cached\_dir()):
==================================================================
BUG: KASAN: slab-use-after-free in smb2\_cached\_lease\_break+0x27/0xb0
Read of size 8 at addr ffff88811cc24c10 by task kworker/3:1/65
CPU: 3 UID: 0 PID: 65 Comm: kworker/3:1 Not tainted 6.12.0-rc6-g255cf264e6e5-dirty #87
Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020
Workqueue: cifsiod smb2\_cached\_lease\_break
Call Trace:
<TASK>
dump\_stack\_lvl+0x77/0xb0
print\_report+0xce/0x660
kasan\_report+0xd3/0x110
smb2\_cached\_lease\_break+0x27/0xb0
process\_one\_work+0x50a/0xc50
worker\_thread+0x2ba/0x530
kthread+0x17c/0x1c0
ret\_from\_fork+0x34/0x60
ret\_from\_fork\_asm+0x1a/0x30
</TASK>
Allocated by task 2464:
kasan\_save\_stack+0x33/0x60
kasan\_save\_track+0x14/0x30
\_\_kasan\_kmalloc+0xaa/0xb0
open\_cached\_dir+0xa7d/0x1fb0
smb2\_query\_path\_info+0x43c/0x6e0
cifs\_get\_fattr+0x346/0xf10
cifs\_get\_inode\_info+0x157/0x210
cifs\_revalidate\_dentry\_attr+0x2d1/0x460
cifs\_getattr+0x173/0x470
vfs\_statx\_path+0x10f/0x160
vfs\_statx+0xe9/0x150
vfs\_fstatat+0x5e/0xc0
\_\_do\_sys\_newfstatat+0x91/0xf0
do\_syscall\_64+0x95/0x1a0
entry\_SYSCALL\_64\_after\_hwframe+0x76/0x7e
Freed by task 2464:
kasan\_save\_stack+0x33/0x60
kasan\_save\_track+0x14/0x30
kasan\_save\_free\_info+0x3b/0x60
\_\_kasan\_slab\_free+0x51/0x70
kfree+0x174/0x520
open\_cached\_dir+0x97f/0x1fb0
smb2\_query\_path\_info+0x43c/0x6e0
cifs\_get\_fattr+0x346/0xf10
cifs\_get\_inode\_info+0x157/0x210
cifs\_revalidate\_dentry\_attr+0x2d1/0x460
cifs\_getattr+0x173/0x470
vfs\_statx\_path+0x10f/0x160
vfs\_statx+0xe9/0x150
vfs\_fstatat+0x5e/0xc0
\_\_do\_sys\_newfstatat+0x91/0xf0
do\_syscall\_64+0x95/0x1a0
entry\_SYSCALL\_64\_after\_hwframe+0x76/0x7e
Last potentially related work creation:
kasan\_save\_stack+0x33/0x60
\_\_kasan\_record\_aux\_stack+0xad/0xc0
insert\_work+0x32/0x100
\_\_queue\_work+0x5c9/0x870
queue\_work\_on+0x82/0x90
open\_cached\_dir+0x1369/0x1fb0
smb2\_query\_path\_info+0x43c/0x6e0
cifs\_get\_fattr+0x346/0xf10
cifs\_get\_inode\_info+0x157/0x210
cifs\_revalidate\_dentry\_attr+0x2d1/0x460
cifs\_getattr+0x173/0x470
vfs\_statx\_path+0x10f/0x160
vfs\_statx+0xe9/0x150
vfs\_fstatat+0x5e/0xc0
\_\_do\_sys\_newfstatat+0x91/0xf0
do\_syscall\_64+0x95/0x1a0
entry\_SYSCALL\_64\_after\_hwframe+0x76/0x7e
The buggy address belongs to the object at ffff88811cc24c00
which belongs to the cache kmalloc-1k of size 1024
The buggy address is located 16 bytes inside of
freed 1024-byte region [ffff88811cc24c00, ffff88811cc25000)
Cc: stable@vger.kernel.org
Signed-off-by: Paul Aurich <paul@darkrain42.org>
Signed-off-by: Steve French <stfrench@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=47655a12c6b1bca8fa230085eab2e85a076932b7)

| -rw-r--r-- | [fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cached_dir.c?id=47655a12c6b1bca8fa230085eab2e85a076932b7) | 70 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 29 insertions, 41 deletions

| diff --git a/fs/smb/client/cached\_dir.c b/fs/smb/client/cached\_dir.cindex bb9d4c284ce577..06eb19dabb0ecc 100644--- a/[fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.c?id=73a57b25b4df23f22814fc06b7e8f9cf570be026)+++ b/[fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.c?id=47655a12c6b1bca8fa230085eab2e85a076932b7)@@ -348,6 +348,7 @@ oshr\_free: SMB2\_query\_info\_free(&rqst[1]); free\_rsp\_buf(resp\_buftype[0], rsp\_iov[0].iov\_base); free\_rsp\_buf(resp\_buftype[1], rsp\_iov[1].iov\_base);+out: if (rc) { spin\_lock(&cfids->cfid\_list\_lock); if (cfid->on\_list) {@@ -359,23 +360,14 @@ oshr\_free: /\* \* We are guaranteed to have two references at this \* point. One for the caller and one for a potential- \* lease. Release the Lease-ref so that the directory- \* will be closed when the caller closes the cached- \* handle.+ \* lease. Release one here, and the second below. \*/ cfid->has\_lease = false;- spin\_unlock(&cfids->cfid\_list\_lock); kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);- goto out; } spin\_unlock(&cfids->cfid\_list\_lock);- }-out:- if (rc) {- if (cfid->is\_open)- SMB2\_close(0, cfid->tcon, cfid->fid.persistent\_fid,- cfid->fid.volatile\_fid);- free\_cached\_dir(cfid);++ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); } else { \*ret\_cfid = cfid; atomic\_inc(&tcon->num\_remote\_opens);@@ -513,25 +505,24 @@ void invalidate\_all\_cached\_dirs(struct cifs\_tcon \*tcon) cfids->num\_entries--; cfid->is\_open = false; cfid->on\_list = false;- /\* To prevent race with smb2\_cached\_lease\_break() \*/- kref\_get(&cfid->refcount);+ if (cfid->has\_lease) {+ /\*+ \* The lease was never cancelled from the server,+ \* so steal that reference.+ \*/+ cfid->has\_lease = false;+ } else+ kref\_get(&cfid->refcount); } spin\_unlock(&cfids->cfid\_list\_lock);  list\_for\_each\_entry\_safe(cfid, q, &entry, entry) { list\_del(&cfid->entry); cancel\_work\_sync(&cfid->lease\_break);- if (cfid->has\_lease) {- /\*- \* We lease was never cancelled from the server so we- \* need to drop the reference.- \*/- spin\_lock(&cfids->cfid\_list\_lock);- cfid->has\_lease = false;- spin\_unlock(&cfids->cfid\_list\_lock);- kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);- }- /\* Drop the extra reference opened above\*/+ /\*+ \* Drop the ref-count from above, either the lease-ref (if there+ \* was one) or the extra one acquired.+ \*/ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); } }@@ -542,9 +533,6 @@ smb2\_cached\_lease\_break(struct work\_struct \*work) struct cached\_fid \*cfid = container\_of(work, struct cached\_fid, lease\_break); - spin\_lock(&cfid->cfids->cfid\_list\_lock);- cfid->has\_lease = false;- spin\_unlock(&cfid->cfids->cfid\_list\_lock); kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); } @@ -562,6 +550,7 @@ int cached\_dir\_lease\_break(struct cifs\_tcon \*tcon, \_\_u8 lease\_key[16]) !memcmp(lease\_key, cfid->fid.lease\_key, SMB2\_LEASE\_KEY\_SIZE)) {+ cfid->has\_lease = false; cfid->time = 0; /\* \* We found a lease remove it from the list@@ -639,8 +628,14 @@ static void cfids\_laundromat\_worker(struct work\_struct \*work) cfid->on\_list = false; list\_move(&cfid->entry, &entry); cfids->num\_entries--;- /\* To prevent race with smb2\_cached\_lease\_break() \*/- kref\_get(&cfid->refcount);+ if (cfid->has\_lease) {+ /\*+ \* Our lease has not yet been cancelled from the+ \* server. Steal that reference.+ \*/+ cfid->has\_lease = false;+ } else+ kref\_get(&cfid->refcount); } } spin\_unlock(&cfids->cfid\_list\_lock);@@ -652,17 +647,10 @@ static void cfids\_laundromat\_worker(struct work\_struct \*work) \* with it. \*/ cancel\_work\_sync(&cfid->lease\_break);- if (cfid->has\_lease) {- /\*- \* Our lease has not yet been cancelled from the server- \* so we need to drop the reference.- \*/- spin\_lock(&cfids->cfid\_list\_lock);- cfid->has\_lease = false;- spin\_unlock(&cfids->cfid\_list\_lock);- kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);- }- /\* Drop the extra reference opened above \*/+ /\*+ \* Drop the ref-count from above, either the lease-ref (if there+ \* was one) or the extra one acquired.+ \*/ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); } queue\_delayed\_work(cifsiod\_wq, &cfids->laundromat\_work, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:21:54 +0000



=== Content from git.kernel.org_a30efa85_20250114_202319.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=97e2afcac0bebfef6a5360f4267ce4c44507b845)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=97e2afcac0bebfef6a5360f4267ce4c44507b845)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=97e2afcac0bebfef6a5360f4267ce4c44507b845)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=97e2afcac0bebfef6a5360f4267ce4c44507b845)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Paul Aurich <paul@darkrain42.org> | 2024-11-18 13:50:27 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-05 13:54:24 +0100 |
| commit | [97e2afcac0bebfef6a5360f4267ce4c44507b845](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=97e2afcac0bebfef6a5360f4267ce4c44507b845) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=97e2afcac0bebfef6a5360f4267ce4c44507b845)) | |
| tree | [645fc812c13ffa398283fd9a47914d7a17f25eb3](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=97e2afcac0bebfef6a5360f4267ce4c44507b845) | |
| parent | [1d76332d783db12684b67592f1fb2057b88af4c3](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1d76332d783db12684b67592f1fb2057b88af4c3) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=97e2afcac0bebfef6a5360f4267ce4c44507b845&id2=1d76332d783db12684b67592f1fb2057b88af4c3)) | |
| download | [linux-97e2afcac0bebfef6a5360f4267ce4c44507b845.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-97e2afcac0bebfef6a5360f4267ce4c44507b845.tar.gz) | |

smb: prevent use-after-free due to open\_cached\_dir error pathscommit a9685b409a03b73d2980bbfa53eb47555802d0a9 upstream.
If open\_cached\_dir() encounters an error parsing the lease from the
server, the error handling may race with receiving a lease break,
resulting in open\_cached\_dir() freeing the cfid while the queued work is
pending.
Update open\_cached\_dir() to drop refs rather than directly freeing the
cfid.
Have cached\_dir\_lease\_break(), cfids\_laundromat\_worker(), and
invalidate\_all\_cached\_dirs() clear has\_lease immediately while still
holding cfids->cfid\_list\_lock, and then use this to also simplify the
reference counting in cfids\_laundromat\_worker() and
invalidate\_all\_cached\_dirs().
Fixes this KASAN splat (which manually injects an error and lease break
in open\_cached\_dir()):
==================================================================
BUG: KASAN: slab-use-after-free in smb2\_cached\_lease\_break+0x27/0xb0
Read of size 8 at addr ffff88811cc24c10 by task kworker/3:1/65
CPU: 3 UID: 0 PID: 65 Comm: kworker/3:1 Not tainted 6.12.0-rc6-g255cf264e6e5-dirty #87
Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020
Workqueue: cifsiod smb2\_cached\_lease\_break
Call Trace:
<TASK>
dump\_stack\_lvl+0x77/0xb0
print\_report+0xce/0x660
kasan\_report+0xd3/0x110
smb2\_cached\_lease\_break+0x27/0xb0
process\_one\_work+0x50a/0xc50
worker\_thread+0x2ba/0x530
kthread+0x17c/0x1c0
ret\_from\_fork+0x34/0x60
ret\_from\_fork\_asm+0x1a/0x30
</TASK>
Allocated by task 2464:
kasan\_save\_stack+0x33/0x60
kasan\_save\_track+0x14/0x30
\_\_kasan\_kmalloc+0xaa/0xb0
open\_cached\_dir+0xa7d/0x1fb0
smb2\_query\_path\_info+0x43c/0x6e0
cifs\_get\_fattr+0x346/0xf10
cifs\_get\_inode\_info+0x157/0x210
cifs\_revalidate\_dentry\_attr+0x2d1/0x460
cifs\_getattr+0x173/0x470
vfs\_statx\_path+0x10f/0x160
vfs\_statx+0xe9/0x150
vfs\_fstatat+0x5e/0xc0
\_\_do\_sys\_newfstatat+0x91/0xf0
do\_syscall\_64+0x95/0x1a0
entry\_SYSCALL\_64\_after\_hwframe+0x76/0x7e
Freed by task 2464:
kasan\_save\_stack+0x33/0x60
kasan\_save\_track+0x14/0x30
kasan\_save\_free\_info+0x3b/0x60
\_\_kasan\_slab\_free+0x51/0x70
kfree+0x174/0x520
open\_cached\_dir+0x97f/0x1fb0
smb2\_query\_path\_info+0x43c/0x6e0
cifs\_get\_fattr+0x346/0xf10
cifs\_get\_inode\_info+0x157/0x210
cifs\_revalidate\_dentry\_attr+0x2d1/0x460
cifs\_getattr+0x173/0x470
vfs\_statx\_path+0x10f/0x160
vfs\_statx+0xe9/0x150
vfs\_fstatat+0x5e/0xc0
\_\_do\_sys\_newfstatat+0x91/0xf0
do\_syscall\_64+0x95/0x1a0
entry\_SYSCALL\_64\_after\_hwframe+0x76/0x7e
Last potentially related work creation:
kasan\_save\_stack+0x33/0x60
\_\_kasan\_record\_aux\_stack+0xad/0xc0
insert\_work+0x32/0x100
\_\_queue\_work+0x5c9/0x870
queue\_work\_on+0x82/0x90
open\_cached\_dir+0x1369/0x1fb0
smb2\_query\_path\_info+0x43c/0x6e0
cifs\_get\_fattr+0x346/0xf10
cifs\_get\_inode\_info+0x157/0x210
cifs\_revalidate\_dentry\_attr+0x2d1/0x460
cifs\_getattr+0x173/0x470
vfs\_statx\_path+0x10f/0x160
vfs\_statx+0xe9/0x150
vfs\_fstatat+0x5e/0xc0
\_\_do\_sys\_newfstatat+0x91/0xf0
do\_syscall\_64+0x95/0x1a0
entry\_SYSCALL\_64\_after\_hwframe+0x76/0x7e
The buggy address belongs to the object at ffff88811cc24c00
which belongs to the cache kmalloc-1k of size 1024
The buggy address is located 16 bytes inside of
freed 1024-byte region [ffff88811cc24c00, ffff88811cc25000)
Cc: stable@vger.kernel.org
Signed-off-by: Paul Aurich <paul@darkrain42.org>
Signed-off-by: Steve French <stfrench@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=97e2afcac0bebfef6a5360f4267ce4c44507b845)

| -rw-r--r-- | [fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cached_dir.c?id=97e2afcac0bebfef6a5360f4267ce4c44507b845) | 70 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 29 insertions, 41 deletions

| diff --git a/fs/smb/client/cached\_dir.c b/fs/smb/client/cached\_dir.cindex bb9d4c284ce577..06eb19dabb0ecc 100644--- a/[fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.c?id=1d76332d783db12684b67592f1fb2057b88af4c3)+++ b/[fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.c?id=97e2afcac0bebfef6a5360f4267ce4c44507b845)@@ -348,6 +348,7 @@ oshr\_free: SMB2\_query\_info\_free(&rqst[1]); free\_rsp\_buf(resp\_buftype[0], rsp\_iov[0].iov\_base); free\_rsp\_buf(resp\_buftype[1], rsp\_iov[1].iov\_base);+out: if (rc) { spin\_lock(&cfids->cfid\_list\_lock); if (cfid->on\_list) {@@ -359,23 +360,14 @@ oshr\_free: /\* \* We are guaranteed to have two references at this \* point. One for the caller and one for a potential- \* lease. Release the Lease-ref so that the directory- \* will be closed when the caller closes the cached- \* handle.+ \* lease. Release one here, and the second below. \*/ cfid->has\_lease = false;- spin\_unlock(&cfids->cfid\_list\_lock); kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);- goto out; } spin\_unlock(&cfids->cfid\_list\_lock);- }-out:- if (rc) {- if (cfid->is\_open)- SMB2\_close(0, cfid->tcon, cfid->fid.persistent\_fid,- cfid->fid.volatile\_fid);- free\_cached\_dir(cfid);++ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); } else { \*ret\_cfid = cfid; atomic\_inc(&tcon->num\_remote\_opens);@@ -513,25 +505,24 @@ void invalidate\_all\_cached\_dirs(struct cifs\_tcon \*tcon) cfids->num\_entries--; cfid->is\_open = false; cfid->on\_list = false;- /\* To prevent race with smb2\_cached\_lease\_break() \*/- kref\_get(&cfid->refcount);+ if (cfid->has\_lease) {+ /\*+ \* The lease was never cancelled from the server,+ \* so steal that reference.+ \*/+ cfid->has\_lease = false;+ } else+ kref\_get(&cfid->refcount); } spin\_unlock(&cfids->cfid\_list\_lock);  list\_for\_each\_entry\_safe(cfid, q, &entry, entry) { list\_del(&cfid->entry); cancel\_work\_sync(&cfid->lease\_break);- if (cfid->has\_lease) {- /\*- \* We lease was never cancelled from the server so we- \* need to drop the reference.- \*/- spin\_lock(&cfids->cfid\_list\_lock);- cfid->has\_lease = false;- spin\_unlock(&cfids->cfid\_list\_lock);- kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);- }- /\* Drop the extra reference opened above\*/+ /\*+ \* Drop the ref-count from above, either the lease-ref (if there+ \* was one) or the extra one acquired.+ \*/ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); } }@@ -542,9 +533,6 @@ smb2\_cached\_lease\_break(struct work\_struct \*work) struct cached\_fid \*cfid = container\_of(work, struct cached\_fid, lease\_break); - spin\_lock(&cfid->cfids->cfid\_list\_lock);- cfid->has\_lease = false;- spin\_unlock(&cfid->cfids->cfid\_list\_lock); kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); } @@ -562,6 +550,7 @@ int cached\_dir\_lease\_break(struct cifs\_tcon \*tcon, \_\_u8 lease\_key[16]) !memcmp(lease\_key, cfid->fid.lease\_key, SMB2\_LEASE\_KEY\_SIZE)) {+ cfid->has\_lease = false; cfid->time = 0; /\* \* We found a lease remove it from the list@@ -639,8 +628,14 @@ static void cfids\_laundromat\_worker(struct work\_struct \*work) cfid->on\_list = false; list\_move(&cfid->entry, &entry); cfids->num\_entries--;- /\* To prevent race with smb2\_cached\_lease\_break() \*/- kref\_get(&cfid->refcount);+ if (cfid->has\_lease) {+ /\*+ \* Our lease has not yet been cancelled from the+ \* server. Steal that reference.+ \*/+ cfid->has\_lease = false;+ } else+ kref\_get(&cfid->refcount); } } spin\_unlock(&cfids->cfid\_list\_lock);@@ -652,17 +647,10 @@ static void cfids\_laundromat\_worker(struct work\_struct \*work) \* with it. \*/ cancel\_work\_sync(&cfid->lease\_break);- if (cfid->has\_lease) {- /\*- \* Our lease has not yet been cancelled from the server- \* so we need to drop the reference.- \*/- spin\_lock(&cfids->cfid\_list\_lock);- cfid->has\_lease = false;- spin\_unlock(&cfids->cfid\_list\_lock);- kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);- }- /\* Drop the extra reference opened above \*/+ /\*+ \* Drop the ref-count from above, either the lease-ref (if there+ \* was one) or the extra one acquired.+ \*/ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); } queue\_delayed\_work(cifsiod\_wq, &cfids->laundromat\_work, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:21:56 +0000


