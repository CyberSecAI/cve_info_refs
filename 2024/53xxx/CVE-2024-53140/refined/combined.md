=== Content from git.kernel.org_32d7817b_20250115_083707.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d2fab3d66cc16cfb9e3ea1772abe6b79b71fa603)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d2fab3d66cc16cfb9e3ea1772abe6b79b71fa603)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d2fab3d66cc16cfb9e3ea1772abe6b79b71fa603)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d2fab3d66cc16cfb9e3ea1772abe6b79b71fa603)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jakub Kicinski <kuba@kernel.org> | 2024-11-05 17:52:34 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-14 19:50:34 +0100 |
| commit | [d2fab3d66cc16cfb9e3ea1772abe6b79b71fa603](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d2fab3d66cc16cfb9e3ea1772abe6b79b71fa603) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d2fab3d66cc16cfb9e3ea1772abe6b79b71fa603)) | |
| tree | [e0cb3982933e271a8bc854372b7d2ae8fc34e2ad](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d2fab3d66cc16cfb9e3ea1772abe6b79b71fa603) | |
| parent | [7b4ec178bf38efbca59d8b66473023846dc7c62f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7b4ec178bf38efbca59d8b66473023846dc7c62f) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d2fab3d66cc16cfb9e3ea1772abe6b79b71fa603&id2=7b4ec178bf38efbca59d8b66473023846dc7c62f)) | |
| download | [linux-d2fab3d66cc16cfb9e3ea1772abe6b79b71fa603.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d2fab3d66cc16cfb9e3ea1772abe6b79b71fa603.tar.gz) | |

netlink: terminate outstanding dump on socket close[ Upstream commit 1904fb9ebf911441f90a68e96b22aa73e4410505 ]
Netlink supports iterative dumping of data. It provides the families
the following ops:
- start - (optional) kicks off the dumping process
- dump - actual dump helper, keeps getting called until it returns 0
- done - (optional) pairs with .start, can be used for cleanup
The whole process is asynchronous and the repeated calls to .dump
don't actually happen in a tight loop, but rather are triggered
in response to recvmsg() on the socket.
This gives the user full control over the dump, but also means that
the user can close the socket without getting to the end of the dump.
To make sure .start is always paired with .done we check if there
is an ongoing dump before freeing the socket, and if so call .done.
The complication is that sockets can get freed from BH and .done
is allowed to sleep. So we use a workqueue to defer the call, when
needed.
Unfortunately this does not work correctly. What we defer is not
the cleanup but rather releasing a reference on the socket.
We have no guarantee that we own the last reference, if someone
else holds the socket they may release it in BH and we're back
to square one.
The whole dance, however, appears to be unnecessary. Only the user
can interact with dumps, so we can clean up when socket is closed.
And close always happens in process context. Some async code may
still access the socket after close, queue notification skbs to it etc.
but no dumps can start, end or otherwise make progress.
Delete the workqueue and flush the dump state directly from the release
handler. Note that further cleanup is possible in -next, for instance
we now always call .done before releasing the main module reference,
so dump doesn't have to take a reference of its own.
Reported-by: syzkaller <syzkaller@googlegroups.com>
Fixes: ed5d7788a934 ("netlink: Do not schedule work from sk\_destruct")
Reviewed-by: Kuniyuki Iwashima <kuniyu@amazon.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://patch.msgid.link/20241106015235.2458807-1-kuba@kernel.org](https://patch.msgid.link/20241106015235.2458807-1-kuba%40kernel.org)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d2fab3d66cc16cfb9e3ea1772abe6b79b71fa603)

| -rw-r--r-- | [net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netlink/af_netlink.c?id=d2fab3d66cc16cfb9e3ea1772abe6b79b71fa603) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netlink/af_netlink.h?id=d2fab3d66cc16cfb9e3ea1772abe6b79b71fa603) | 2 | |  |  |  | | --- | --- | --- | |

2 files changed, 8 insertions, 25 deletions

| diff --git a/net/netlink/af\_netlink.c b/net/netlink/af\_netlink.cindex fdcb10abebfd1e..d3852526ef52ec 100644--- a/[net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=7b4ec178bf38efbca59d8b66473023846dc7c62f)+++ b/[net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=d2fab3d66cc16cfb9e3ea1772abe6b79b71fa603)@@ -393,15 +393,6 @@ static void netlink\_skb\_set\_owner\_r(struct sk\_buff \*skb, struct sock \*sk)  static void netlink\_sock\_destruct(struct sock \*sk) {- struct netlink\_sock \*nlk = nlk\_sk(sk);-- if (nlk->cb\_running) {- if (nlk->cb.done)- nlk->cb.done(&nlk->cb);- module\_put(nlk->cb.module);- kfree\_skb(nlk->cb.skb);- }- skb\_queue\_purge(&sk->sk\_receive\_queue);  if (!sock\_flag(sk, SOCK\_DEAD)) {@@ -414,14 +405,6 @@ static void netlink\_sock\_destruct(struct sock \*sk) WARN\_ON(nlk\_sk(sk)->groups); } -static void netlink\_sock\_destruct\_work(struct work\_struct \*work)-{- struct netlink\_sock \*nlk = container\_of(work, struct netlink\_sock,- work);-- sk\_free(&nlk->sk);-}- /\* This lock without WQ\_FLAG\_EXCLUSIVE is good on UP and it is \_very\_ bad on \* SMP. Look, when several writers sleep and reader wakes them up, all but one \* immediately hit write lock and grab all the cpus. Exclusive sleep solves@@ -736,12 +719,6 @@ static void deferred\_put\_nlk\_sk(struct rcu\_head \*head) if (!refcount\_dec\_and\_test(&sk->sk\_refcnt)) return; - if (nlk->cb\_running && nlk->cb.done) {- INIT\_WORK(&nlk->work, netlink\_sock\_destruct\_work);- schedule\_work(&nlk->work);- return;- }- sk\_free(sk); } @@ -791,6 +768,14 @@ static int netlink\_release(struct socket \*sock) NETLINK\_URELEASE, &n); } + /\* Terminate any outstanding dump \*/+ if (nlk->cb\_running) {+ if (nlk->cb.done)+ nlk->cb.done(&nlk->cb);+ module\_put(nlk->cb.module);+ kfree\_skb(nlk->cb.skb);+ }+ module\_put(nlk->module);  if (netlink\_is\_kernel(sk)) {diff --git a/net/netlink/af\_netlink.h b/net/netlink/af\_netlink.hindex 5f454c8de6a4de..fca9556848885e 100644--- a/[net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.h?id=7b4ec178bf38efbca59d8b66473023846dc7c62f)+++ b/[net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.h?id=d2fab3d66cc16cfb9e3ea1772abe6b79b71fa603)@@ -4,7 +4,6 @@  #include <linux/rhashtable.h> #include <linux/atomic.h>-#include <linux/workqueue.h> #include <net/sock.h>  /\* flags \*/@@ -46,7 +45,6 @@ struct netlink\_sock {  struct rhash\_head node; struct rcu\_head rcu;- struct work\_struct work; };  static inline struct netlink\_sock \*nlk\_sk(struct sock \*sk) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 08:35:44 +0000



=== Content from git.kernel.org_411c5212_20250115_083702.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=598c956b62699c3753929602560d8df322e60559)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=598c956b62699c3753929602560d8df322e60559)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=598c956b62699c3753929602560d8df322e60559)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=598c956b62699c3753929602560d8df322e60559)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jakub Kicinski <kuba@kernel.org> | 2024-11-05 17:52:34 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-14 19:44:18 +0100 |
| commit | [598c956b62699c3753929602560d8df322e60559](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=598c956b62699c3753929602560d8df322e60559) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=598c956b62699c3753929602560d8df322e60559)) | |
| tree | [72292ba1221fd60142d8047d0b8d72515cfd1eac](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=598c956b62699c3753929602560d8df322e60559) | |
| parent | [cd5b619ac41b6b1a8167380ca6655df7ccf5b5eb](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cd5b619ac41b6b1a8167380ca6655df7ccf5b5eb) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=598c956b62699c3753929602560d8df322e60559&id2=cd5b619ac41b6b1a8167380ca6655df7ccf5b5eb)) | |
| download | [linux-598c956b62699c3753929602560d8df322e60559.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-598c956b62699c3753929602560d8df322e60559.tar.gz) | |

netlink: terminate outstanding dump on socket close[ Upstream commit 1904fb9ebf911441f90a68e96b22aa73e4410505 ]
Netlink supports iterative dumping of data. It provides the families
the following ops:
- start - (optional) kicks off the dumping process
- dump - actual dump helper, keeps getting called until it returns 0
- done - (optional) pairs with .start, can be used for cleanup
The whole process is asynchronous and the repeated calls to .dump
don't actually happen in a tight loop, but rather are triggered
in response to recvmsg() on the socket.
This gives the user full control over the dump, but also means that
the user can close the socket without getting to the end of the dump.
To make sure .start is always paired with .done we check if there
is an ongoing dump before freeing the socket, and if so call .done.
The complication is that sockets can get freed from BH and .done
is allowed to sleep. So we use a workqueue to defer the call, when
needed.
Unfortunately this does not work correctly. What we defer is not
the cleanup but rather releasing a reference on the socket.
We have no guarantee that we own the last reference, if someone
else holds the socket they may release it in BH and we're back
to square one.
The whole dance, however, appears to be unnecessary. Only the user
can interact with dumps, so we can clean up when socket is closed.
And close always happens in process context. Some async code may
still access the socket after close, queue notification skbs to it etc.
but no dumps can start, end or otherwise make progress.
Delete the workqueue and flush the dump state directly from the release
handler. Note that further cleanup is possible in -next, for instance
we now always call .done before releasing the main module reference,
so dump doesn't have to take a reference of its own.
Reported-by: syzkaller <syzkaller@googlegroups.com>
Fixes: ed5d7788a934 ("netlink: Do not schedule work from sk\_destruct")
Reviewed-by: Kuniyuki Iwashima <kuniyu@amazon.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://patch.msgid.link/20241106015235.2458807-1-kuba@kernel.org](https://patch.msgid.link/20241106015235.2458807-1-kuba%40kernel.org)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=598c956b62699c3753929602560d8df322e60559)

| -rw-r--r-- | [net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netlink/af_netlink.c?id=598c956b62699c3753929602560d8df322e60559) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netlink/af_netlink.h?id=598c956b62699c3753929602560d8df322e60559) | 2 | |  |  |  | | --- | --- | --- | |

2 files changed, 8 insertions, 25 deletions

| diff --git a/net/netlink/af\_netlink.c b/net/netlink/af\_netlink.cindex 719af25cd4d11b..17d86eee8bd8be 100644--- a/[net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=cd5b619ac41b6b1a8167380ca6655df7ccf5b5eb)+++ b/[net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=598c956b62699c3753929602560d8df322e60559)@@ -384,15 +384,6 @@ static void netlink\_skb\_set\_owner\_r(struct sk\_buff \*skb, struct sock \*sk)  static void netlink\_sock\_destruct(struct sock \*sk) {- struct netlink\_sock \*nlk = nlk\_sk(sk);-- if (nlk->cb\_running) {- if (nlk->cb.done)- nlk->cb.done(&nlk->cb);- module\_put(nlk->cb.module);- kfree\_skb(nlk->cb.skb);- }- skb\_queue\_purge(&sk->sk\_receive\_queue);  if (!sock\_flag(sk, SOCK\_DEAD)) {@@ -405,14 +396,6 @@ static void netlink\_sock\_destruct(struct sock \*sk) WARN\_ON(nlk\_sk(sk)->groups); } -static void netlink\_sock\_destruct\_work(struct work\_struct \*work)-{- struct netlink\_sock \*nlk = container\_of(work, struct netlink\_sock,- work);-- sk\_free(&nlk->sk);-}- /\* This lock without WQ\_FLAG\_EXCLUSIVE is good on UP and it is \_very\_ bad on \* SMP. Look, when several writers sleep and reader wakes them up, all but one \* immediately hit write lock and grab all the cpus. Exclusive sleep solves@@ -729,12 +712,6 @@ static void deferred\_put\_nlk\_sk(struct rcu\_head \*head) if (!refcount\_dec\_and\_test(&sk->sk\_refcnt)) return; - if (nlk->cb\_running && nlk->cb.done) {- INIT\_WORK(&nlk->work, netlink\_sock\_destruct\_work);- schedule\_work(&nlk->work);- return;- }- sk\_free(sk); } @@ -784,6 +761,14 @@ static int netlink\_release(struct socket \*sock) NETLINK\_URELEASE, &n); } + /\* Terminate any outstanding dump \*/+ if (nlk->cb\_running) {+ if (nlk->cb.done)+ nlk->cb.done(&nlk->cb);+ module\_put(nlk->cb.module);+ kfree\_skb(nlk->cb.skb);+ }+ module\_put(nlk->module);  if (netlink\_is\_kernel(sk)) {diff --git a/net/netlink/af\_netlink.h b/net/netlink/af\_netlink.hindex 5f454c8de6a4de..fca9556848885e 100644--- a/[net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.h?id=cd5b619ac41b6b1a8167380ca6655df7ccf5b5eb)+++ b/[net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.h?id=598c956b62699c3753929602560d8df322e60559)@@ -4,7 +4,6 @@  #include <linux/rhashtable.h> #include <linux/atomic.h>-#include <linux/workqueue.h> #include <net/sock.h>  /\* flags \*/@@ -46,7 +45,6 @@ struct netlink\_sock {  struct rhash\_head node; struct rcu\_head rcu;- struct work\_struct work; };  static inline struct netlink\_sock \*nlk\_sk(struct sock \*sk) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 08:35:38 +0000



=== Content from git.kernel.org_3f2533ed_20250115_083659.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=176c41b3ca9281a9736b67c6121b03dbf0c8c08f)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=176c41b3ca9281a9736b67c6121b03dbf0c8c08f)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=176c41b3ca9281a9736b67c6121b03dbf0c8c08f)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=176c41b3ca9281a9736b67c6121b03dbf0c8c08f)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jakub Kicinski <kuba@kernel.org> | 2024-11-05 17:52:34 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-22 15:39:46 +0100 |
| commit | [176c41b3ca9281a9736b67c6121b03dbf0c8c08f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=176c41b3ca9281a9736b67c6121b03dbf0c8c08f) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=176c41b3ca9281a9736b67c6121b03dbf0c8c08f)) | |
| tree | [b93dae382186eaab0819c2f494b226a05f01628e](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=176c41b3ca9281a9736b67c6121b03dbf0c8c08f) | |
| parent | [a2316c84887afe399bf463ce356d4f69e88113a2](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a2316c84887afe399bf463ce356d4f69e88113a2) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=176c41b3ca9281a9736b67c6121b03dbf0c8c08f&id2=a2316c84887afe399bf463ce356d4f69e88113a2)) | |
| download | [linux-176c41b3ca9281a9736b67c6121b03dbf0c8c08f.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-176c41b3ca9281a9736b67c6121b03dbf0c8c08f.tar.gz) | |

netlink: terminate outstanding dump on socket close[ Upstream commit 1904fb9ebf911441f90a68e96b22aa73e4410505 ]
Netlink supports iterative dumping of data. It provides the families
the following ops:
- start - (optional) kicks off the dumping process
- dump - actual dump helper, keeps getting called until it returns 0
- done - (optional) pairs with .start, can be used for cleanup
The whole process is asynchronous and the repeated calls to .dump
don't actually happen in a tight loop, but rather are triggered
in response to recvmsg() on the socket.
This gives the user full control over the dump, but also means that
the user can close the socket without getting to the end of the dump.
To make sure .start is always paired with .done we check if there
is an ongoing dump before freeing the socket, and if so call .done.
The complication is that sockets can get freed from BH and .done
is allowed to sleep. So we use a workqueue to defer the call, when
needed.
Unfortunately this does not work correctly. What we defer is not
the cleanup but rather releasing a reference on the socket.
We have no guarantee that we own the last reference, if someone
else holds the socket they may release it in BH and we're back
to square one.
The whole dance, however, appears to be unnecessary. Only the user
can interact with dumps, so we can clean up when socket is closed.
And close always happens in process context. Some async code may
still access the socket after close, queue notification skbs to it etc.
but no dumps can start, end or otherwise make progress.
Delete the workqueue and flush the dump state directly from the release
handler. Note that further cleanup is possible in -next, for instance
we now always call .done before releasing the main module reference,
so dump doesn't have to take a reference of its own.
Reported-by: syzkaller <syzkaller@googlegroups.com>
Fixes: ed5d7788a934 ("netlink: Do not schedule work from sk\_destruct")
Reviewed-by: Kuniyuki Iwashima <kuniyu@amazon.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://patch.msgid.link/20241106015235.2458807-1-kuba@kernel.org](https://patch.msgid.link/20241106015235.2458807-1-kuba%40kernel.org)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=176c41b3ca9281a9736b67c6121b03dbf0c8c08f)

| -rw-r--r-- | [net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netlink/af_netlink.c?id=176c41b3ca9281a9736b67c6121b03dbf0c8c08f) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netlink/af_netlink.h?id=176c41b3ca9281a9736b67c6121b03dbf0c8c08f) | 2 | |  |  |  | | --- | --- | --- | |

2 files changed, 8 insertions, 25 deletions

| diff --git a/net/netlink/af\_netlink.c b/net/netlink/af\_netlink.cindex 0a9287fadb47a2..f84aad420d4464 100644--- a/[net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=a2316c84887afe399bf463ce356d4f69e88113a2)+++ b/[net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=176c41b3ca9281a9736b67c6121b03dbf0c8c08f)@@ -393,15 +393,6 @@ static void netlink\_skb\_set\_owner\_r(struct sk\_buff \*skb, struct sock \*sk)  static void netlink\_sock\_destruct(struct sock \*sk) {- struct netlink\_sock \*nlk = nlk\_sk(sk);-- if (nlk->cb\_running) {- if (nlk->cb.done)- nlk->cb.done(&nlk->cb);- module\_put(nlk->cb.module);- kfree\_skb(nlk->cb.skb);- }- skb\_queue\_purge(&sk->sk\_receive\_queue);  if (!sock\_flag(sk, SOCK\_DEAD)) {@@ -414,14 +405,6 @@ static void netlink\_sock\_destruct(struct sock \*sk) WARN\_ON(nlk\_sk(sk)->groups); } -static void netlink\_sock\_destruct\_work(struct work\_struct \*work)-{- struct netlink\_sock \*nlk = container\_of(work, struct netlink\_sock,- work);-- sk\_free(&nlk->sk);-}- /\* This lock without WQ\_FLAG\_EXCLUSIVE is good on UP and it is \_very\_ bad on \* SMP. Look, when several writers sleep and reader wakes them up, all but one \* immediately hit write lock and grab all the cpus. Exclusive sleep solves@@ -731,12 +714,6 @@ static void deferred\_put\_nlk\_sk(struct rcu\_head \*head) if (!refcount\_dec\_and\_test(&sk->sk\_refcnt)) return; - if (nlk->cb\_running && nlk->cb.done) {- INIT\_WORK(&nlk->work, netlink\_sock\_destruct\_work);- schedule\_work(&nlk->work);- return;- }- sk\_free(sk); } @@ -788,6 +765,14 @@ static int netlink\_release(struct socket \*sock) NETLINK\_URELEASE, &n); } + /\* Terminate any outstanding dump \*/+ if (nlk->cb\_running) {+ if (nlk->cb.done)+ nlk->cb.done(&nlk->cb);+ module\_put(nlk->cb.module);+ kfree\_skb(nlk->cb.skb);+ }+ module\_put(nlk->module);  if (netlink\_is\_kernel(sk)) {diff --git a/net/netlink/af\_netlink.h b/net/netlink/af\_netlink.hindex 9751e29d4bbb9a..b1a17c0d97a103 100644--- a/[net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.h?id=a2316c84887afe399bf463ce356d4f69e88113a2)+++ b/[net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.h?id=176c41b3ca9281a9736b67c6121b03dbf0c8c08f)@@ -4,7 +4,6 @@  #include <linux/rhashtable.h> #include <linux/atomic.h>-#include <linux/workqueue.h> #include <net/sock.h>  /\* flags \*/@@ -51,7 +50,6 @@ struct netlink\_sock {  struct rhash\_head node; struct rcu\_head rcu;- struct work\_struct work; };  static inline struct netlink\_sock \*nlk\_sk(struct sock \*sk) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 08:35:36 +0000



=== Content from git.kernel.org_a764480c_20250115_083705.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jakub Kicinski <kuba@kernel.org> | 2024-11-05 17:52:34 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-22 15:38:30 +0100 |
| commit | [bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca)) | |
| tree | [ded56476a1687ee0cc23b89034ff455926e27862](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca) | |
| parent | [c1036e4f14d03aba549cdd9b186148d331013056](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c1036e4f14d03aba549cdd9b186148d331013056) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca&id2=c1036e4f14d03aba549cdd9b186148d331013056)) | |
| download | [linux-bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca.tar.gz) | |

netlink: terminate outstanding dump on socket close[ Upstream commit 1904fb9ebf911441f90a68e96b22aa73e4410505 ]
Netlink supports iterative dumping of data. It provides the families
the following ops:
- start - (optional) kicks off the dumping process
- dump - actual dump helper, keeps getting called until it returns 0
- done - (optional) pairs with .start, can be used for cleanup
The whole process is asynchronous and the repeated calls to .dump
don't actually happen in a tight loop, but rather are triggered
in response to recvmsg() on the socket.
This gives the user full control over the dump, but also means that
the user can close the socket without getting to the end of the dump.
To make sure .start is always paired with .done we check if there
is an ongoing dump before freeing the socket, and if so call .done.
The complication is that sockets can get freed from BH and .done
is allowed to sleep. So we use a workqueue to defer the call, when
needed.
Unfortunately this does not work correctly. What we defer is not
the cleanup but rather releasing a reference on the socket.
We have no guarantee that we own the last reference, if someone
else holds the socket they may release it in BH and we're back
to square one.
The whole dance, however, appears to be unnecessary. Only the user
can interact with dumps, so we can clean up when socket is closed.
And close always happens in process context. Some async code may
still access the socket after close, queue notification skbs to it etc.
but no dumps can start, end or otherwise make progress.
Delete the workqueue and flush the dump state directly from the release
handler. Note that further cleanup is possible in -next, for instance
we now always call .done before releasing the main module reference,
so dump doesn't have to take a reference of its own.
Reported-by: syzkaller <syzkaller@googlegroups.com>
Fixes: ed5d7788a934 ("netlink: Do not schedule work from sk\_destruct")
Reviewed-by: Kuniyuki Iwashima <kuniyu@amazon.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://patch.msgid.link/20241106015235.2458807-1-kuba@kernel.org](https://patch.msgid.link/20241106015235.2458807-1-kuba%40kernel.org)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca)

| -rw-r--r-- | [net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netlink/af_netlink.c?id=bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netlink/af_netlink.h?id=bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca) | 2 | |  |  |  | | --- | --- | --- | |

2 files changed, 8 insertions, 25 deletions

| diff --git a/net/netlink/af\_netlink.c b/net/netlink/af\_netlink.cindex 50e13207a05aa5..4aa2cbe9d6fa69 100644--- a/[net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=c1036e4f14d03aba549cdd9b186148d331013056)+++ b/[net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca)@@ -393,15 +393,6 @@ static void netlink\_skb\_set\_owner\_r(struct sk\_buff \*skb, struct sock \*sk)  static void netlink\_sock\_destruct(struct sock \*sk) {- struct netlink\_sock \*nlk = nlk\_sk(sk);-- if (nlk->cb\_running) {- if (nlk->cb.done)- nlk->cb.done(&nlk->cb);- module\_put(nlk->cb.module);- kfree\_skb(nlk->cb.skb);- }- skb\_queue\_purge(&sk->sk\_receive\_queue);  if (!sock\_flag(sk, SOCK\_DEAD)) {@@ -414,14 +405,6 @@ static void netlink\_sock\_destruct(struct sock \*sk) WARN\_ON(nlk\_sk(sk)->groups); } -static void netlink\_sock\_destruct\_work(struct work\_struct \*work)-{- struct netlink\_sock \*nlk = container\_of(work, struct netlink\_sock,- work);-- sk\_free(&nlk->sk);-}- /\* This lock without WQ\_FLAG\_EXCLUSIVE is good on UP and it is \_very\_ bad on \* SMP. Look, when several writers sleep and reader wakes them up, all but one \* immediately hit write lock and grab all the cpus. Exclusive sleep solves@@ -735,12 +718,6 @@ static void deferred\_put\_nlk\_sk(struct rcu\_head \*head) if (!refcount\_dec\_and\_test(&sk->sk\_refcnt)) return; - if (nlk->cb\_running && nlk->cb.done) {- INIT\_WORK(&nlk->work, netlink\_sock\_destruct\_work);- schedule\_work(&nlk->work);- return;- }- sk\_free(sk); } @@ -792,6 +769,14 @@ static int netlink\_release(struct socket \*sock) NETLINK\_URELEASE, &n); } + /\* Terminate any outstanding dump \*/+ if (nlk->cb\_running) {+ if (nlk->cb.done)+ nlk->cb.done(&nlk->cb);+ module\_put(nlk->cb.module);+ kfree\_skb(nlk->cb.skb);+ }+ module\_put(nlk->module);  if (netlink\_is\_kernel(sk)) {diff --git a/net/netlink/af\_netlink.h b/net/netlink/af\_netlink.hindex 9751e29d4bbb9a..b1a17c0d97a103 100644--- a/[net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.h?id=c1036e4f14d03aba549cdd9b186148d331013056)+++ b/[net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.h?id=bbc769d2fa1b8b368c5fbe013b5b096afa3c05ca)@@ -4,7 +4,6 @@  #include <linux/rhashtable.h> #include <linux/atomic.h>-#include <linux/workqueue.h> #include <net/sock.h>  /\* flags \*/@@ -51,7 +50,6 @@ struct netlink\_sock {  struct rhash\_head node; struct rcu\_head rcu;- struct work\_struct work; };  static inline struct netlink\_sock \*nlk\_sk(struct sock \*sk) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 08:35:41 +0000



=== Content from git.kernel.org_8ad30de1_20250115_083657.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=114a61d8d94ae3a43b82446cf737fd757021b834)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=114a61d8d94ae3a43b82446cf737fd757021b834)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=114a61d8d94ae3a43b82446cf737fd757021b834)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=114a61d8d94ae3a43b82446cf737fd757021b834)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jakub Kicinski <kuba@kernel.org> | 2024-11-05 17:52:34 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-05 10:59:28 +0100 |
| commit | [114a61d8d94ae3a43b82446cf737fd757021b834](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=114a61d8d94ae3a43b82446cf737fd757021b834) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=114a61d8d94ae3a43b82446cf737fd757021b834)) | |
| tree | [83011b4545f39d2a121271dbbfbc79e678ba211f](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=114a61d8d94ae3a43b82446cf737fd757021b834) | |
| parent | [708f578f2a8f702d2f2a0ef5e6eac28e08206e03](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=708f578f2a8f702d2f2a0ef5e6eac28e08206e03) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=114a61d8d94ae3a43b82446cf737fd757021b834&id2=708f578f2a8f702d2f2a0ef5e6eac28e08206e03)) | |
| download | [linux-114a61d8d94ae3a43b82446cf737fd757021b834.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-114a61d8d94ae3a43b82446cf737fd757021b834.tar.gz) | |

netlink: terminate outstanding dump on socket close[ Upstream commit 1904fb9ebf911441f90a68e96b22aa73e4410505 ]
Netlink supports iterative dumping of data. It provides the families
the following ops:
- start - (optional) kicks off the dumping process
- dump - actual dump helper, keeps getting called until it returns 0
- done - (optional) pairs with .start, can be used for cleanup
The whole process is asynchronous and the repeated calls to .dump
don't actually happen in a tight loop, but rather are triggered
in response to recvmsg() on the socket.
This gives the user full control over the dump, but also means that
the user can close the socket without getting to the end of the dump.
To make sure .start is always paired with .done we check if there
is an ongoing dump before freeing the socket, and if so call .done.
The complication is that sockets can get freed from BH and .done
is allowed to sleep. So we use a workqueue to defer the call, when
needed.
Unfortunately this does not work correctly. What we defer is not
the cleanup but rather releasing a reference on the socket.
We have no guarantee that we own the last reference, if someone
else holds the socket they may release it in BH and we're back
to square one.
The whole dance, however, appears to be unnecessary. Only the user
can interact with dumps, so we can clean up when socket is closed.
And close always happens in process context. Some async code may
still access the socket after close, queue notification skbs to it etc.
but no dumps can start, end or otherwise make progress.
Delete the workqueue and flush the dump state directly from the release
handler. Note that further cleanup is possible in -next, for instance
we now always call .done before releasing the main module reference,
so dump doesn't have to take a reference of its own.
Reported-by: syzkaller <syzkaller@googlegroups.com>
Fixes: ed5d7788a934 ("netlink: Do not schedule work from sk\_destruct")
Reviewed-by: Kuniyuki Iwashima <kuniyu@amazon.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://patch.msgid.link/20241106015235.2458807-1-kuba@kernel.org](https://patch.msgid.link/20241106015235.2458807-1-kuba%40kernel.org)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=114a61d8d94ae3a43b82446cf737fd757021b834)

| -rw-r--r-- | [net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netlink/af_netlink.c?id=114a61d8d94ae3a43b82446cf737fd757021b834) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netlink/af_netlink.h?id=114a61d8d94ae3a43b82446cf737fd757021b834) | 2 | |  |  |  | | --- | --- | --- | |

2 files changed, 8 insertions, 25 deletions

| diff --git a/net/netlink/af\_netlink.c b/net/netlink/af\_netlink.cindex 2e26ecb46707c6..8c397697e47fa7 100644--- a/[net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=708f578f2a8f702d2f2a0ef5e6eac28e08206e03)+++ b/[net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=114a61d8d94ae3a43b82446cf737fd757021b834)@@ -393,15 +393,6 @@ static void netlink\_skb\_set\_owner\_r(struct sk\_buff \*skb, struct sock \*sk)  static void netlink\_sock\_destruct(struct sock \*sk) {- struct netlink\_sock \*nlk = nlk\_sk(sk);-- if (nlk->cb\_running) {- if (nlk->cb.done)- nlk->cb.done(&nlk->cb);- module\_put(nlk->cb.module);- kfree\_skb(nlk->cb.skb);- }- skb\_queue\_purge(&sk->sk\_receive\_queue);  if (!sock\_flag(sk, SOCK\_DEAD)) {@@ -414,14 +405,6 @@ static void netlink\_sock\_destruct(struct sock \*sk) WARN\_ON(nlk\_sk(sk)->groups); } -static void netlink\_sock\_destruct\_work(struct work\_struct \*work)-{- struct netlink\_sock \*nlk = container\_of(work, struct netlink\_sock,- work);-- sk\_free(&nlk->sk);-}- /\* This lock without WQ\_FLAG\_EXCLUSIVE is good on UP and it is \_very\_ bad on \* SMP. Look, when several writers sleep and reader wakes them up, all but one \* immediately hit write lock and grab all the cpus. Exclusive sleep solves@@ -738,12 +721,6 @@ static void deferred\_put\_nlk\_sk(struct rcu\_head \*head) if (!refcount\_dec\_and\_test(&sk->sk\_refcnt)) return; - if (nlk->cb\_running && nlk->cb.done) {- INIT\_WORK(&nlk->work, netlink\_sock\_destruct\_work);- schedule\_work(&nlk->work);- return;- }- sk\_free(sk); } @@ -793,6 +770,14 @@ static int netlink\_release(struct socket \*sock) NETLINK\_URELEASE, &n); } + /\* Terminate any outstanding dump \*/+ if (nlk->cb\_running) {+ if (nlk->cb.done)+ nlk->cb.done(&nlk->cb);+ module\_put(nlk->cb.module);+ kfree\_skb(nlk->cb.skb);+ }+ module\_put(nlk->module);  if (netlink\_is\_kernel(sk)) {diff --git a/net/netlink/af\_netlink.h b/net/netlink/af\_netlink.hindex 962de7b3c023d4..c61e634693eaa1 100644--- a/[net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.h?id=708f578f2a8f702d2f2a0ef5e6eac28e08206e03)+++ b/[net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.h?id=114a61d8d94ae3a43b82446cf737fd757021b834)@@ -4,7 +4,6 @@  #include <linux/rhashtable.h> #include <linux/atomic.h>-#include <linux/workqueue.h> #include <net/sock.h>  /\* flags \*/@@ -45,7 +44,6 @@ struct netlink\_sock {  struct rhash\_head node; struct rcu\_head rcu;- struct work\_struct work; };  static inline struct netlink\_sock \*nlk\_sk(struct sock \*sk) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 08:30:14 +0000



=== Content from git.kernel.org_3c31d070_20250115_083703.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=6e3f2c512d2b7dbd247485b1dd9e43e4210a18f4)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6e3f2c512d2b7dbd247485b1dd9e43e4210a18f4)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6e3f2c512d2b7dbd247485b1dd9e43e4210a18f4)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6e3f2c512d2b7dbd247485b1dd9e43e4210a18f4)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jakub Kicinski <kuba@kernel.org> | 2024-11-05 17:52:34 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-14 19:47:37 +0100 |
| commit | [6e3f2c512d2b7dbd247485b1dd9e43e4210a18f4](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6e3f2c512d2b7dbd247485b1dd9e43e4210a18f4) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=6e3f2c512d2b7dbd247485b1dd9e43e4210a18f4)) | |
| tree | [8eedcd2741901df69946b634acfdc178ef54553b](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6e3f2c512d2b7dbd247485b1dd9e43e4210a18f4) | |
| parent | [b5214ca796fb6b58a6c3c4f44fcc215864659ee7](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b5214ca796fb6b58a6c3c4f44fcc215864659ee7) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6e3f2c512d2b7dbd247485b1dd9e43e4210a18f4&id2=b5214ca796fb6b58a6c3c4f44fcc215864659ee7)) | |
| download | [linux-6e3f2c512d2b7dbd247485b1dd9e43e4210a18f4.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-6e3f2c512d2b7dbd247485b1dd9e43e4210a18f4.tar.gz) | |

netlink: terminate outstanding dump on socket close[ Upstream commit 1904fb9ebf911441f90a68e96b22aa73e4410505 ]
Netlink supports iterative dumping of data. It provides the families
the following ops:
- start - (optional) kicks off the dumping process
- dump - actual dump helper, keeps getting called until it returns 0
- done - (optional) pairs with .start, can be used for cleanup
The whole process is asynchronous and the repeated calls to .dump
don't actually happen in a tight loop, but rather are triggered
in response to recvmsg() on the socket.
This gives the user full control over the dump, but also means that
the user can close the socket without getting to the end of the dump.
To make sure .start is always paired with .done we check if there
is an ongoing dump before freeing the socket, and if so call .done.
The complication is that sockets can get freed from BH and .done
is allowed to sleep. So we use a workqueue to defer the call, when
needed.
Unfortunately this does not work correctly. What we defer is not
the cleanup but rather releasing a reference on the socket.
We have no guarantee that we own the last reference, if someone
else holds the socket they may release it in BH and we're back
to square one.
The whole dance, however, appears to be unnecessary. Only the user
can interact with dumps, so we can clean up when socket is closed.
And close always happens in process context. Some async code may
still access the socket after close, queue notification skbs to it etc.
but no dumps can start, end or otherwise make progress.
Delete the workqueue and flush the dump state directly from the release
handler. Note that further cleanup is possible in -next, for instance
we now always call .done before releasing the main module reference,
so dump doesn't have to take a reference of its own.
Reported-by: syzkaller <syzkaller@googlegroups.com>
Fixes: ed5d7788a934 ("netlink: Do not schedule work from sk\_destruct")
Reviewed-by: Kuniyuki Iwashima <kuniyu@amazon.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://patch.msgid.link/20241106015235.2458807-1-kuba@kernel.org](https://patch.msgid.link/20241106015235.2458807-1-kuba%40kernel.org)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6e3f2c512d2b7dbd247485b1dd9e43e4210a18f4)

| -rw-r--r-- | [net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netlink/af_netlink.c?id=6e3f2c512d2b7dbd247485b1dd9e43e4210a18f4) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netlink/af_netlink.h?id=6e3f2c512d2b7dbd247485b1dd9e43e4210a18f4) | 2 | |  |  |  | | --- | --- | --- | |

2 files changed, 8 insertions, 25 deletions

| diff --git a/net/netlink/af\_netlink.c b/net/netlink/af\_netlink.cindex bda604b37db0a2..4da043d9f2c7a2 100644--- a/[net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=b5214ca796fb6b58a6c3c4f44fcc215864659ee7)+++ b/[net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=6e3f2c512d2b7dbd247485b1dd9e43e4210a18f4)@@ -385,15 +385,6 @@ static void netlink\_skb\_set\_owner\_r(struct sk\_buff \*skb, struct sock \*sk)  static void netlink\_sock\_destruct(struct sock \*sk) {- struct netlink\_sock \*nlk = nlk\_sk(sk);-- if (nlk->cb\_running) {- if (nlk->cb.done)- nlk->cb.done(&nlk->cb);- module\_put(nlk->cb.module);- kfree\_skb(nlk->cb.skb);- }- skb\_queue\_purge(&sk->sk\_receive\_queue);  if (!sock\_flag(sk, SOCK\_DEAD)) {@@ -406,14 +397,6 @@ static void netlink\_sock\_destruct(struct sock \*sk) WARN\_ON(nlk\_sk(sk)->groups); } -static void netlink\_sock\_destruct\_work(struct work\_struct \*work)-{- struct netlink\_sock \*nlk = container\_of(work, struct netlink\_sock,- work);-- sk\_free(&nlk->sk);-}- /\* This lock without WQ\_FLAG\_EXCLUSIVE is good on UP and it is \_very\_ bad on \* SMP. Look, when several writers sleep and reader wakes them up, all but one \* immediately hit write lock and grab all the cpus. Exclusive sleep solves@@ -730,12 +713,6 @@ static void deferred\_put\_nlk\_sk(struct rcu\_head \*head) if (!refcount\_dec\_and\_test(&sk->sk\_refcnt)) return; - if (nlk->cb\_running && nlk->cb.done) {- INIT\_WORK(&nlk->work, netlink\_sock\_destruct\_work);- schedule\_work(&nlk->work);- return;- }- sk\_free(sk); } @@ -785,6 +762,14 @@ static int netlink\_release(struct socket \*sock) NETLINK\_URELEASE, &n); } + /\* Terminate any outstanding dump \*/+ if (nlk->cb\_running) {+ if (nlk->cb.done)+ nlk->cb.done(&nlk->cb);+ module\_put(nlk->cb.module);+ kfree\_skb(nlk->cb.skb);+ }+ module\_put(nlk->module);  if (netlink\_is\_kernel(sk)) {diff --git a/net/netlink/af\_netlink.h b/net/netlink/af\_netlink.hindex 5f454c8de6a4de..fca9556848885e 100644--- a/[net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.h?id=b5214ca796fb6b58a6c3c4f44fcc215864659ee7)+++ b/[net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.h?id=6e3f2c512d2b7dbd247485b1dd9e43e4210a18f4)@@ -4,7 +4,6 @@  #include <linux/rhashtable.h> #include <linux/atomic.h>-#include <linux/workqueue.h> #include <net/sock.h>  /\* flags \*/@@ -46,7 +45,6 @@ struct netlink\_sock {  struct rhash\_head node; struct rcu\_head rcu;- struct work\_struct work; };  static inline struct netlink\_sock \*nlk\_sk(struct sock \*sk) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 08:35:40 +0000



=== Content from git.kernel.org_a684774a_20250115_083701.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=4e87a52133284afbd40fb522dbf96e258af52a98)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=4e87a52133284afbd40fb522dbf96e258af52a98)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4e87a52133284afbd40fb522dbf96e258af52a98)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4e87a52133284afbd40fb522dbf96e258af52a98)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jakub Kicinski <kuba@kernel.org> | 2024-11-05 17:52:34 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-22 15:37:28 +0100 |
| commit | [4e87a52133284afbd40fb522dbf96e258af52a98](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4e87a52133284afbd40fb522dbf96e258af52a98) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=4e87a52133284afbd40fb522dbf96e258af52a98)) | |
| tree | [9f219a9356a9fd11c9c5d8e36610e4237f6c1f18](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=4e87a52133284afbd40fb522dbf96e258af52a98) | |
| parent | [b67dc5c9ade9dc354b790eb64aa6a665d0a54ecd](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b67dc5c9ade9dc354b790eb64aa6a665d0a54ecd) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4e87a52133284afbd40fb522dbf96e258af52a98&id2=b67dc5c9ade9dc354b790eb64aa6a665d0a54ecd)) | |
| download | [linux-4e87a52133284afbd40fb522dbf96e258af52a98.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-4e87a52133284afbd40fb522dbf96e258af52a98.tar.gz) | |

netlink: terminate outstanding dump on socket close[ Upstream commit 1904fb9ebf911441f90a68e96b22aa73e4410505 ]
Netlink supports iterative dumping of data. It provides the families
the following ops:
- start - (optional) kicks off the dumping process
- dump - actual dump helper, keeps getting called until it returns 0
- done - (optional) pairs with .start, can be used for cleanup
The whole process is asynchronous and the repeated calls to .dump
don't actually happen in a tight loop, but rather are triggered
in response to recvmsg() on the socket.
This gives the user full control over the dump, but also means that
the user can close the socket without getting to the end of the dump.
To make sure .start is always paired with .done we check if there
is an ongoing dump before freeing the socket, and if so call .done.
The complication is that sockets can get freed from BH and .done
is allowed to sleep. So we use a workqueue to defer the call, when
needed.
Unfortunately this does not work correctly. What we defer is not
the cleanup but rather releasing a reference on the socket.
We have no guarantee that we own the last reference, if someone
else holds the socket they may release it in BH and we're back
to square one.
The whole dance, however, appears to be unnecessary. Only the user
can interact with dumps, so we can clean up when socket is closed.
And close always happens in process context. Some async code may
still access the socket after close, queue notification skbs to it etc.
but no dumps can start, end or otherwise make progress.
Delete the workqueue and flush the dump state directly from the release
handler. Note that further cleanup is possible in -next, for instance
we now always call .done before releasing the main module reference,
so dump doesn't have to take a reference of its own.
Reported-by: syzkaller <syzkaller@googlegroups.com>
Fixes: ed5d7788a934 ("netlink: Do not schedule work from sk\_destruct")
Reviewed-by: Kuniyuki Iwashima <kuniyu@amazon.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://patch.msgid.link/20241106015235.2458807-1-kuba@kernel.org](https://patch.msgid.link/20241106015235.2458807-1-kuba%40kernel.org)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4e87a52133284afbd40fb522dbf96e258af52a98)

| -rw-r--r-- | [net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netlink/af_netlink.c?id=4e87a52133284afbd40fb522dbf96e258af52a98) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netlink/af_netlink.h?id=4e87a52133284afbd40fb522dbf96e258af52a98) | 2 | |  |  |  | | --- | --- | --- | |

2 files changed, 8 insertions, 25 deletions

| diff --git a/net/netlink/af\_netlink.c b/net/netlink/af\_netlink.cindex 9eb87f35bc65e2..8a74847dacaf15 100644--- a/[net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=b67dc5c9ade9dc354b790eb64aa6a665d0a54ecd)+++ b/[net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=4e87a52133284afbd40fb522dbf96e258af52a98)@@ -393,15 +393,6 @@ static void netlink\_skb\_set\_owner\_r(struct sk\_buff \*skb, struct sock \*sk)  static void netlink\_sock\_destruct(struct sock \*sk) {- struct netlink\_sock \*nlk = nlk\_sk(sk);-- if (nlk->cb\_running) {- if (nlk->cb.done)- nlk->cb.done(&nlk->cb);- module\_put(nlk->cb.module);- kfree\_skb(nlk->cb.skb);- }- skb\_queue\_purge(&sk->sk\_receive\_queue);  if (!sock\_flag(sk, SOCK\_DEAD)) {@@ -414,14 +405,6 @@ static void netlink\_sock\_destruct(struct sock \*sk) WARN\_ON(nlk\_sk(sk)->groups); } -static void netlink\_sock\_destruct\_work(struct work\_struct \*work)-{- struct netlink\_sock \*nlk = container\_of(work, struct netlink\_sock,- work);-- sk\_free(&nlk->sk);-}- /\* This lock without WQ\_FLAG\_EXCLUSIVE is good on UP and it is \_very\_ bad on \* SMP. Look, when several writers sleep and reader wakes them up, all but one \* immediately hit write lock and grab all the cpus. Exclusive sleep solves@@ -736,12 +719,6 @@ static void deferred\_put\_nlk\_sk(struct rcu\_head \*head) if (!refcount\_dec\_and\_test(&sk->sk\_refcnt)) return; - if (nlk->cb\_running && nlk->cb.done) {- INIT\_WORK(&nlk->work, netlink\_sock\_destruct\_work);- schedule\_work(&nlk->work);- return;- }- sk\_free(sk); } @@ -791,6 +768,14 @@ static int netlink\_release(struct socket \*sock) NETLINK\_URELEASE, &n); } + /\* Terminate any outstanding dump \*/+ if (nlk->cb\_running) {+ if (nlk->cb.done)+ nlk->cb.done(&nlk->cb);+ module\_put(nlk->cb.module);+ kfree\_skb(nlk->cb.skb);+ }+ module\_put(nlk->module);  if (netlink\_is\_kernel(sk)) {diff --git a/net/netlink/af\_netlink.h b/net/netlink/af\_netlink.hindex b30b8fc760f71a..aa430e4d58d805 100644--- a/[net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.h?id=b67dc5c9ade9dc354b790eb64aa6a665d0a54ecd)+++ b/[net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.h?id=4e87a52133284afbd40fb522dbf96e258af52a98)@@ -4,7 +4,6 @@  #include <linux/rhashtable.h> #include <linux/atomic.h>-#include <linux/workqueue.h> #include <net/sock.h>  /\* flags \*/@@ -48,7 +47,6 @@ struct netlink\_sock {  struct rhash\_head node; struct rcu\_head rcu;- struct work\_struct work; };  static inline struct netlink\_sock \*nlk\_sk(struct sock \*sk) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 08:35:38 +0000



=== Content from git.kernel.org_b46dbe63_20250115_083659.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=1904fb9ebf911441f90a68e96b22aa73e4410505)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=1904fb9ebf911441f90a68e96b22aa73e4410505)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1904fb9ebf911441f90a68e96b22aa73e4410505)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1904fb9ebf911441f90a68e96b22aa73e4410505)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jakub Kicinski <kuba@kernel.org> | 2024-11-05 17:52:34 -0800 |
| --- | --- | --- |
| committer | Jakub Kicinski <kuba@kernel.org> | 2024-11-07 13:45:34 -0800 |
| commit | [1904fb9ebf911441f90a68e96b22aa73e4410505](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1904fb9ebf911441f90a68e96b22aa73e4410505) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=1904fb9ebf911441f90a68e96b22aa73e4410505)) | |
| tree | [df873fe99390790aee082738ffb833a7bfdafc74](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=1904fb9ebf911441f90a68e96b22aa73e4410505) | |
| parent | [bfc64d9b7e8cac82be6b8629865e137d962578f8](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bfc64d9b7e8cac82be6b8629865e137d962578f8) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1904fb9ebf911441f90a68e96b22aa73e4410505&id2=bfc64d9b7e8cac82be6b8629865e137d962578f8)) | |
| download | [linux-1904fb9ebf911441f90a68e96b22aa73e4410505.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-1904fb9ebf911441f90a68e96b22aa73e4410505.tar.gz) | |

netlink: terminate outstanding dump on socket closeNetlink supports iterative dumping of data. It provides the families
the following ops:
- start - (optional) kicks off the dumping process
- dump - actual dump helper, keeps getting called until it returns 0
- done - (optional) pairs with .start, can be used for cleanup
The whole process is asynchronous and the repeated calls to .dump
don't actually happen in a tight loop, but rather are triggered
in response to recvmsg() on the socket.
This gives the user full control over the dump, but also means that
the user can close the socket without getting to the end of the dump.
To make sure .start is always paired with .done we check if there
is an ongoing dump before freeing the socket, and if so call .done.
The complication is that sockets can get freed from BH and .done
is allowed to sleep. So we use a workqueue to defer the call, when
needed.
Unfortunately this does not work correctly. What we defer is not
the cleanup but rather releasing a reference on the socket.
We have no guarantee that we own the last reference, if someone
else holds the socket they may release it in BH and we're back
to square one.
The whole dance, however, appears to be unnecessary. Only the user
can interact with dumps, so we can clean up when socket is closed.
And close always happens in process context. Some async code may
still access the socket after close, queue notification skbs to it etc.
but no dumps can start, end or otherwise make progress.
Delete the workqueue and flush the dump state directly from the release
handler. Note that further cleanup is possible in -next, for instance
we now always call .done before releasing the main module reference,
so dump doesn't have to take a reference of its own.
Reported-by: syzkaller <syzkaller@googlegroups.com>
Fixes: ed5d7788a934 ("netlink: Do not schedule work from sk\_destruct")
Reviewed-by: Kuniyuki Iwashima <kuniyu@amazon.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://patch.msgid.link/20241106015235.2458807-1-kuba@kernel.org](https://patch.msgid.link/20241106015235.2458807-1-kuba%40kernel.org)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1904fb9ebf911441f90a68e96b22aa73e4410505)

| -rw-r--r-- | [net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netlink/af_netlink.c?id=1904fb9ebf911441f90a68e96b22aa73e4410505) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netlink/af_netlink.h?id=1904fb9ebf911441f90a68e96b22aa73e4410505) | 2 | |  |  |  | | --- | --- | --- | |

2 files changed, 8 insertions, 25 deletions

| diff --git a/net/netlink/af\_netlink.c b/net/netlink/af\_netlink.cindex 0a9287fadb47a2..f84aad420d4464 100644--- a/[net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=bfc64d9b7e8cac82be6b8629865e137d962578f8)+++ b/[net/netlink/af\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=1904fb9ebf911441f90a68e96b22aa73e4410505)@@ -393,15 +393,6 @@ static void netlink\_skb\_set\_owner\_r(struct sk\_buff \*skb, struct sock \*sk)  static void netlink\_sock\_destruct(struct sock \*sk) {- struct netlink\_sock \*nlk = nlk\_sk(sk);-- if (nlk->cb\_running) {- if (nlk->cb.done)- nlk->cb.done(&nlk->cb);- module\_put(nlk->cb.module);- kfree\_skb(nlk->cb.skb);- }- skb\_queue\_purge(&sk->sk\_receive\_queue);  if (!sock\_flag(sk, SOCK\_DEAD)) {@@ -414,14 +405,6 @@ static void netlink\_sock\_destruct(struct sock \*sk) WARN\_ON(nlk\_sk(sk)->groups); } -static void netlink\_sock\_destruct\_work(struct work\_struct \*work)-{- struct netlink\_sock \*nlk = container\_of(work, struct netlink\_sock,- work);-- sk\_free(&nlk->sk);-}- /\* This lock without WQ\_FLAG\_EXCLUSIVE is good on UP and it is \_very\_ bad on \* SMP. Look, when several writers sleep and reader wakes them up, all but one \* immediately hit write lock and grab all the cpus. Exclusive sleep solves@@ -731,12 +714,6 @@ static void deferred\_put\_nlk\_sk(struct rcu\_head \*head) if (!refcount\_dec\_and\_test(&sk->sk\_refcnt)) return; - if (nlk->cb\_running && nlk->cb.done) {- INIT\_WORK(&nlk->work, netlink\_sock\_destruct\_work);- schedule\_work(&nlk->work);- return;- }- sk\_free(sk); } @@ -788,6 +765,14 @@ static int netlink\_release(struct socket \*sock) NETLINK\_URELEASE, &n); } + /\* Terminate any outstanding dump \*/+ if (nlk->cb\_running) {+ if (nlk->cb.done)+ nlk->cb.done(&nlk->cb);+ module\_put(nlk->cb.module);+ kfree\_skb(nlk->cb.skb);+ }+ module\_put(nlk->module);  if (netlink\_is\_kernel(sk)) {diff --git a/net/netlink/af\_netlink.h b/net/netlink/af\_netlink.hindex 5b0e4e62ab8b9b..778a3809361f51 100644--- a/[net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.h?id=bfc64d9b7e8cac82be6b8629865e137d962578f8)+++ b/[net/netlink/af\_netlink.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.h?id=1904fb9ebf911441f90a68e96b22aa73e4410505)@@ -4,7 +4,6 @@  #include <linux/rhashtable.h> #include <linux/atomic.h>-#include <linux/workqueue.h> #include <net/sock.h>  /\* flags \*/@@ -50,7 +49,6 @@ struct netlink\_sock {  struct rhash\_head node; struct rcu\_head rcu;- struct work\_struct work; };  static inline struct netlink\_sock \*nlk\_sk(struct sock \*sk) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 08:35:36 +0000


