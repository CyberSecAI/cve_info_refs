=== Content from github.com_b0cb33ef_20250114_205710.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fsecurity%2Fadvisories%2FGHSA-m75q-8vj8-wppw)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fsecurity%2Fadvisories%2FGHSA-m75q-8vj8-wppw)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  387](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

# Spoofed length byte traps CC2538 in endless loop

Moderate

[maribu](/maribu)
published
GHSA-m75q-8vj8-wppw
Nov 29, 2024

## Package

RIOT-OS
(RIOT-OS)

## Affected versions

<=2024.07

## Patched versions

None

## Description

### Summary

A malicious actor can send a IEEE 802.15.4 packet with spoofed length byte and optionally spoofed FCS, which eventually results into an endless loop on a CC2538 as receiver.

### Details

Before [#20998](https://github.com/RIOT-OS/RIOT/pull/20998), the receiver would check for the location of the CRC bit using the packet length byte by considering all 8 bits, instead of discarding bit 7, which is what the radio does. This then results into reading outside of the RX FIFO here:

[RIOT/cpu/cc2538/radio/cc2538\_rf\_radio\_ops.c](https://github.com/RIOT-OS/RIOT/blob/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio/cc2538_rf_radio_ops.c#L417)

Line 417
in
[1a418cc](/RIOT-OS/RIOT/commit/1a418ccfedeb79dbce1d79f49e63a28906184794)

|  | if (rfcore\_peek\_rx\_fifo(pkt\_len) & CC2538\_CRC\_BIT\_MASK) { |
| --- | --- |

Although it prints an error when attempting to read outside of the RX FIFO, it will continue doing this. This may lead to a discrepancy in the CRC check according to the firmware and the radio. If the CPU judges the CRC as correct and the radio is set to `AUTO_ACK`, when the packet requests and acknowledgment the CPU will go into the state `CC2538_STATE_TX_ACK` here:

[RIOT/cpu/cc2538/radio/cc2538\_rf\_radio\_ops.c](https://github.com/RIOT-OS/RIOT/blob/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio/cc2538_rf_radio_ops.c#L421-L422)

Lines 421 to 422
in
[1a418cc](/RIOT-OS/RIOT/commit/1a418ccfedeb79dbce1d79f49e63a28906184794)

|  | if (IS\_ACTIVE(CONFIG\_IEEE802154\_AUTO\_ACK\_DISABLE) || |
| --- | --- |
|  | (!(rfcore\_peek\_rx\_fifo(1) & IEEE802154\_FCF\_ACK\_REQ))) { |

However, if the radio judged the CRC as incorrect, it will not send an acknowledgment, and thus the `TXACKDONE` event will not fire. It will then never return to the state `CC2538_STATE_READY` since the baseband processing is still disabled:

[RIOT/cpu/cc2538/radio/cc2538\_rf\_radio\_ops.c](https://github.com/RIOT-OS/RIOT/blob/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio/cc2538_rf_radio_ops.c#L419)

Line 419
in
[1a418cc](/RIOT-OS/RIOT/commit/1a418ccfedeb79dbce1d79f49e63a28906184794)

|  | \_disable\_rx(); |
| --- | --- |

Then the CPU will be in an endless loop here:

[RIOT/sys/net/link\_layer/ieee802154/submac.c](https://github.com/RIOT-OS/RIOT/blob/1a418ccfedeb79dbce1d79f49e63a28906184794/sys/net/link_layer/ieee802154/submac.c#L149)

Line 149
in
[1a418cc](/RIOT-OS/RIOT/commit/1a418ccfedeb79dbce1d79f49e63a28906184794)

|  | while (ieee802154\_radio\_set\_idle(&submac->dev, false) < 0) {} |
| --- | --- |

Since setting to idle is not forced, it won't do it if the radio's state is not `CC2538_STATE_READY`:

[RIOT/cpu/cc2538/radio/cc2538\_rf\_radio\_ops.c](https://github.com/RIOT-OS/RIOT/blob/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio/cc2538_rf_radio_ops.c#L183)

Line 183
in
[1a418cc](/RIOT-OS/RIOT/commit/1a418ccfedeb79dbce1d79f49e63a28906184794)

|  | if (!force && cc2538\_state != CC2538\_STATE\_READY) { |
| --- | --- |

### PoC

The endless loop may occur even during normal operation when bit 7 of the length byte is flipped over the air. An attacker can induce it by spoofing the length byte to a value of more than 127. Since Commercial Off-The-Shelf IEEE 802.15.4 devices will likely not be capable of sending a length byte with a value higher than 127, it needs to be done with a Software-Defined Radio.

To emulate the behaviour with COTS devices, I modified the firmware of a receiving CC2538 to process a packet as if a length byte of more than 127 was received:

```
bool realCRC = rfcore_peek_rx_fifo(pkt_len) & CC2538_CRC_BIT_MASK;
pkt_len += 0x80; // Fake the spoofed length bit
bool fakeCRC = rfcore_peek_rx_fifo(pkt_len) & CC2538_CRC_BIT_MASK;
if (!realCRC && fakeCRC) {
    DEBUG("realCRC: %i, fakeCRC: %i\n", realCRC, fakeCRC);
}
if (fakeCRC) {
```

By sending several IEEE 802.15.4 packets with the ACK request bit set (which is the default) and with low transmit power to induce a CRC error, eventually `realCRC` would be 0 and `fakeCRC` 1, resulting in an endless loop at the receiver. The receiver would need to be set to `AUTO_ACK`, which is the default for plain 802.15.4. Using an SDR, the FCS can be spoofed as well, such that the receiver will always run into the endless loop as soon as the bit in the memory location where the fake CRC check is performed is 1.

### Impact

Via e-mail, Marian Buschsieweke initially pointed out that this bug might be a DoS attack vector. The device will not be able to recover from this, except for a reboot.

### Severity

Moderate

6.5

# CVSS overall score

 This score calculates overall vulnerability severity from 0 to 10 and is based on the Common Vulnerability Scoring System (CVSS).

 / 10

#### CVSS v3 base metrics

Attack vector
Adjacent

Attack complexity
Low

Privileges required
None

User interaction
None

Scope
Unchanged

Confidentiality
None

Integrity
None

Availability
High

Learn more about base metrics

# CVSS v3 base metrics

Attack vector:
More severe the more the remote (logically and physically) an attacker can be in order to exploit the vulnerability.

Attack complexity:
More severe for the least complex attacks.

Privileges required:
More severe if no privileges are required.

User interaction:
More severe when no user interaction is required.

Scope:
More severe when a scope change occurs, e.g. one vulnerable component impacts resources in components beyond its security scope.

Confidentiality:
More severe when loss of data confidentiality is highest, measuring the level of data access available to an unauthorized user.

Integrity:
More severe when loss of data integrity is the highest, measuring the consequence of data modification possible by an unauthorized user.

Availability:
More severe when the loss of impacted component availability is highest.

CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H

### CVE ID

CVE-2024-53980

### Weaknesses

No CWEs

### Credits

* [![@HavingaThijs](https://avatars.githubusercontent.com/u/94684410?s=40&v=4)](/HavingaThijs)
  [HavingaThijs](/HavingaThijs)
  Remediation developer

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_3f1f345b_20250114_205659.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2F1a418ccfedeb79dbce1d79f49e63a28906184794%2Fcpu%2Fcc2538%2Fradio%2Fcc2538_rf_radio_ops.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2F1a418ccfedeb79dbce1d79f49e63a28906184794%2Fcpu%2Fcc2538%2Fradio%2Fcc2538_rf_radio_ops.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  387](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

## Files

 1a418cc
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794)
2. /[cpu](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu)
3. /[cc2538](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538)
4. /[radio](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio)
/
# cc2538\_rf\_radio\_ops.c

Copy path Blame  Blame
## Latest commit

## History

[History](/RIOT-OS/RIOT/commits/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio/cc2538_rf_radio_ops.c)643 lines (556 loc) · 19.5 KB 1a418cc
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794)
2. /[cpu](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu)
3. /[cc2538](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538)
4. /[radio](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio)
/
# cc2538\_rf\_radio\_ops.c

Top
## File metadata and controls

* Code
* Blame

643 lines (556 loc) · 19.5 KB[Raw](https://github.com/RIOT-OS/RIOT/raw/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio/cc2538_rf_radio_ops.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643/\* \* Copyright (C) 2020 HAW Hamburg \* \* This file is subject to the terms and conditions of the GNU Lesser \* General Public License v2.1. See the file LICENSE in the top level \* directory for more details. \* \*/
/\*\* \* @ingroup cpu\_cc2538 \* @{ \* \* @file \* @brief IEEE 802.15.4 Radio HAL implementation for the CC2538 RF driver \* \* @author José I. Alamos <jose.alamos@haw-hamburg.de> \* \* @} \*/
#include <assert.h>#include <errno.h>#include <stdio.h>
#include "net/gnrc.h"
#include "cc2538\_rf.h"#include "cc2538\_rf\_internal.h"
#include "net/ieee802154/radio.h"
#define ENABLE\_DEBUG 0#include "debug.h"
static const ieee802154\_radio\_ops\_t cc2538\_rf\_ops;
static ieee802154\_dev\_t \*cc2538\_rf\_hal;
typedef enum { CC2538\_STATE\_READY, /\*\*< The radio is ready to receive requests \*/ CC2538\_STATE\_TRX\_TRANSITION, /\*\*< There's a pending TRX state transition \*/ CC2538\_STATE\_CONFIRM\_TX, /\*\*< Transmission finished and waiting for confirm \*/ CC2538\_STATE\_TX\_BUSY, /\*\*< The radio is busy transmitting \*/ CC2538\_STATE\_TX\_ACK, /\*\*< The radio is currently transmitting an ACK frame \*/ CC2538\_STATE\_CCA, /\*\*< The radio is doing CCA \*/ CC2538\_STATE\_CONFIRM\_CCA, /\*\*< CCA finished and waiting for confirm \*/} cc2538\_state\_t;
static cc2538\_state\_t cc2538\_state;static uint8\_t cc2538\_min\_be = CONFIG\_IEEE802154\_DEFAULT\_CSMA\_CA\_MIN\_BE;static uint8\_t cc2538\_max\_be = CONFIG\_IEEE802154\_DEFAULT\_CSMA\_CA\_MAX\_BE;static int cc2538\_csma\_ca\_retries = CONFIG\_IEEE802154\_DEFAULT\_CSMA\_CA\_RETRIES;
static bool cc2538\_cca\_status; /\*\*< status of the last CCA request \*/
static void \_enable\_rx(void){ RFCORE\_XREG\_FRMCTRL0 &= ~CC2538\_FRMCTRL0\_RX\_MODE\_DIS;}
static void \_disable\_rx(void){ RFCORE\_XREG\_FRMCTRL0 |= CC2538\_FRMCTRL0\_RX\_MODE\_DIS;}
static int \_write(ieee802154\_dev\_t \*dev, const iolist\_t \*iolist){ (void) dev; int pkt\_len = 0; RFCORE\_SFR\_RFST = ISFLUSHTX; rfcore\_write\_byte(0);
 for (const iolist\_t \*iol = iolist; iol; iol = iol->iol\_next) { if (iol->iol\_len) { pkt\_len += iol->iol\_len; rfcore\_write\_fifo(iol->iol\_base, iol->iol\_len); } }
 /\* Set first byte of TX FIFO to the packet length \*/ rfcore\_poke\_tx\_fifo(0, pkt\_len + CC2538\_AUTOCRC\_LEN); return 0;}static int \_request\_op(ieee802154\_dev\_t \*dev, ieee802154\_hal\_op\_t op, void \*ctx){ (void) dev; int res = -EBUSY; cc2538\_rf\_disable\_irq(); switch (op) { case IEEE802154\_HAL\_OP\_TRANSMIT: assert(cc2538\_state != CC2538\_STATE\_TX\_BUSY); cc2538\_state = CC2538\_STATE\_TX\_BUSY; if (cc2538\_csma\_ca\_retries < 0) { RFCORE\_SFR\_RFST = ISTXON; /\* The CPU Ctrl mask is used here to indicate whether the radio is being \* controlled by the CPU or the CSP Strobe Processor. \* We set this to 1 in order to indicate that the CSP is not used and \* thus, that the @ref ieee802154\_radio\_confirm\_transmit should \* return 0 immediately after the TXDONE event \*/ RFCORE\_XREG\_CSPCTRL |= CC2538\_CSP\_MCU\_CTRL\_MASK; } else { /\* Disable RX Chain for CCA (see CC2538 RM, Section 29.9.5.3) \*/ \_disable\_rx(); RFCORE\_SFR\_RFST = ISRXON; /\* Clear last program \*/ RFCORE\_SFR\_RFST = ISCLEAR;
 /\* If the RSSI is not yet valid, skip 0 instructions. This creates \* a busy loop until the RSSI is valid. \*/ RFCORE\_SFR\_RFST = SKIP\_S\_C | CC2538\_CSP\_SKIP\_N\_MASK | CC2538\_CSP\_SKIP\_COND\_RSSI;
 /\* Set a label right before the backoff \*/ RFCORE\_SFR\_RFST = LABEL;
 /\* Load a random number with "register Y" LSBs into register X. \* This is equivalent to choosing a random number between \* (0, 2^(Y+1)). \* Then, wait "register X" number of backoff units \*/ RFCORE\_SFR\_RFST = RANDXY; RFCORE\_SFR\_RFST = WAITX;
 /\* If CCA is not valid, skip the next stop instruction. In such case \* the CSP\_STOP interrupt will trigger the transmission since the \* channel is clear \*/ RFCORE\_SFR\_RFST = SKIP\_S\_C | (1 << CC2538\_CSP\_SKIP\_INST\_POS) | CC2538\_CSP\_SKIP\_N\_MASK | CC2538\_CSP\_SKIP\_COND\_CCA;
 RFCORE\_SFR\_RFST = STOP;
 /\* If we are here, the channel was not clear. Decrement the register Z \* (remaining attempts) \*/ RFCORE\_SFR\_RFST = DECZ;
 /\* Update the backoff exponent \*/ RFCORE\_SFR\_RFST = INCMAXY | (cc2538\_max\_be & CC2538\_CSP\_INCMAXY\_MAX\_MASK);
 /\* If the are CSMA-CA retries left, go back to the defined label \*/ RFCORE\_SFR\_RFST = RPT\_C | CC2538\_CSP\_SKIP\_N\_MASK | CC2538\_CSP\_SKIP\_COND\_CSPZ;
 /\* Stop the program. The CSP\_STOP interrupt will trigger the routine \* to inform the upper layer that CSMA-CA failed. \*/ RFCORE\_SFR\_RFST = STOP;
 RFCORE\_XREG\_CSPX = 0; /\* Holds timer value \*/ RFCORE\_XREG\_CSPY = cc2538\_min\_be; /\* Holds MinBE \*/
 assert(cc2538\_csma\_ca\_retries >= 0); RFCORE\_XREG\_CSPZ = cc2538\_csma\_ca\_retries + 1; /\* Holds CSMA-CA attempts (retries + 1) \*/
 RFCORE\_XREG\_CSPCTRL &= ~CC2538\_CSP\_MCU\_CTRL\_MASK;
 /\* Execute the program \*/ RFCORE\_SFR\_RFST = ISSTART; } cc2538\_rf\_enable\_irq(); break; case IEEE802154\_HAL\_OP\_SET\_RX: if (cc2538\_state != CC2538\_STATE\_READY) { goto error; } cc2538\_state = CC2538\_STATE\_TRX\_TRANSITION; /\* Enable RX Chain \*/ \_enable\_rx(); RFCORE\_SFR\_RFST = ISRXON; RFCORE\_SFR\_RFIRQF0 &= ~RXPKTDONE; RFCORE\_SFR\_RFIRQF0 &= ~SFD; /\* We keep the interrupts disabled until the state transition is \* finished \*/ break; case IEEE802154\_HAL\_OP\_SET\_IDLE: { assert(ctx); bool force = \*((bool\*) ctx);
 if (!force && cc2538\_state != CC2538\_STATE\_READY) { goto error; }
 cc2538\_state = CC2538\_STATE\_TRX\_TRANSITION; if (RFCORE->XREG\_FSMSTAT0bits.FSM\_FFCTRL\_STATE != FSM\_STATE\_IDLE) { RFCORE\_SFR\_RFST = ISRFOFF; } RFCORE\_SFR\_RFIRQF0 &= ~RXPKTDONE; RFCORE\_SFR\_RFIRQF0 &= ~SFD; /\* We keep the interrupts disabled until the state transition is \* finished \*/ break; } case IEEE802154\_HAL\_OP\_CCA: /\* Ignore baseband processing \*/ \_disable\_rx(); RFCORE\_SFR\_RFIRQF0 &= ~RXPKTDONE; RFCORE\_SFR\_RFIRQF0 &= ~SFD; RFCORE\_SFR\_RFST = ISRXON; RFCORE\_SFR\_RFST = ISCLEAR; RFCORE\_SFR\_RFST = STOP; RFCORE\_XREG\_CSPCTRL &= ~CC2538\_CSP\_MCU\_CTRL\_MASK; /\* Execute the last program \*/ RFCORE\_SFR\_RFST = ISSTART; cc2538\_rf\_enable\_irq(); break; }
 res = 0; return res;
error: cc2538\_rf\_enable\_irq(); return res;}
static int \_confirm\_op(ieee802154\_dev\_t \*dev, ieee802154\_hal\_op\_t op, void \*ctx){ int res = -EAGAIN; (void) dev;
 switch (op) { case IEEE802154\_HAL\_OP\_TRANSMIT: cc2538\_rf\_disable\_irq(); if (cc2538\_state != CC2538\_STATE\_CONFIRM\_TX) { goto error; }
 if (ctx) { ieee802154\_tx\_info\_t \*info = ctx;
 if (cc2538\_csma\_ca\_retries >= 0 && RFCORE\_XREG\_CSPZ == 0) { info->status = TX\_STATUS\_MEDIUM\_BUSY; } else { info->status = TX\_STATUS\_SUCCESS; } } break; case IEEE802154\_HAL\_OP\_SET\_RX: case IEEE802154\_HAL\_OP\_SET\_IDLE: /\* IRQ is already disabled here \*/ assert(cc2538\_state == CC2538\_STATE\_TRX\_TRANSITION); break; case IEEE802154\_HAL\_OP\_CCA: assert(ctx); cc2538\_rf\_disable\_irq(); assert(cc2538\_state == CC2538\_STATE\_CCA || cc2538\_state == CC2538\_STATE\_CONFIRM\_CCA); if (cc2538\_state != CC2538\_STATE\_CONFIRM\_CCA) { goto error; }
 \_enable\_rx(); \*((bool\*) ctx) = cc2538\_cca\_status; break; }
 cc2538\_state = CC2538\_STATE\_READY; res = 0;
error: cc2538\_rf\_enable\_irq(); return res;
}
static int \_len(ieee802154\_dev\_t \*dev){ (void) dev; return rfcore\_peek\_rx\_fifo(0) - IEEE802154\_FCS\_LEN;}
static int \_read(ieee802154\_dev\_t \*dev, void \*buf, size\_t size, ieee802154\_rx\_info\_t \*info){ (void) dev; int res; size\_t pkt\_len;
 if (!buf) { res = 0; goto end; }
 /\* The upper layer shouldn't call this function if the RX\_DONE event was \* not triggered \*/ if (!(RFCORE\_XREG\_RXFIFOCNT > 0)) { assert(false); }
 pkt\_len = rfcore\_read\_byte() - IEEE802154\_FCS\_LEN; if (pkt\_len > size) { res = -ENOBUFS; goto end; }
 rfcore\_read\_fifo(buf, pkt\_len); res = pkt\_len; if (info != NULL) { uint8\_t corr\_val; int8\_t rssi\_val; rssi\_val = rfcore\_read\_byte();
 /\* The number of dB above maximum sensitivity detected for the \* received packet \*/ /\* Make sure there is no overflow even if no signal with such low sensitivity should be detected \*/ const int hw\_rssi\_min = IEEE802154\_RADIO\_RSSI\_OFFSET - CC2538\_RSSI\_OFFSET; int8\_t hw\_rssi = rssi\_val > hw\_rssi\_min ? (CC2538\_RSSI\_OFFSET + rssi\_val) : IEEE802154\_RADIO\_RSSI\_OFFSET; info->rssi = hw\_rssi - IEEE802154\_RADIO\_RSSI\_OFFSET;
 corr\_val = rfcore\_read\_byte() & CC2538\_CORR\_VAL\_MASK; if (corr\_val < CC2538\_CORR\_VAL\_MIN) { corr\_val = CC2538\_CORR\_VAL\_MIN; } else if (corr\_val > CC2538\_CORR\_VAL\_MAX) { corr\_val = CC2538\_CORR\_VAL\_MAX; }
 /\* Interpolate the correlation value between 0 - 255 \* to provide an LQI value \*/ info->lqi = 255 \* (corr\_val - CC2538\_CORR\_VAL\_MIN) / (CC2538\_CORR\_VAL\_MAX - CC2538\_CORR\_VAL\_MIN); }
end: /\* We don't need to enable RX chain here, since the upper layer already \* made sure the transceiver is in IDLE. We simply flush the RX buffer \*/ RFCORE\_SFR\_RFST = ISFLUSHRX; return res;}
static int \_set\_cca\_threshold(ieee802154\_dev\_t \*dev, int8\_t threshold){ (void) dev; (void) threshold;
 if (threshold < CC2538\_RF\_SENSITIVITY) { return -EINVAL; }
 RFCORE\_XREG\_CCACTRL0 &= ~CC2538\_CCA\_THR\_MASK; RFCORE\_XREG\_CCACTRL0 |= (threshold - CC2538\_RSSI\_OFFSET) & CC2538\_CCA\_THR\_MASK;
 return 0;}
static int \_config\_phy(ieee802154\_dev\_t \*dev, const ieee802154\_phy\_conf\_t \*conf){ (void) dev; int8\_t pow = conf->pow; if (pow < OUTPUT\_POWER\_MIN || pow > OUTPUT\_POWER\_MAX) { return -EINVAL; }
 uint8\_t channel = conf->channel; cc2538\_set\_freq(IEEE802154\_CHAN2FREQ(channel)); cc2538\_set\_tx\_power(pow);
 return 0;}
void cc2538\_irq\_handler(void){ uint\_fast8\_t flags\_f0 = RFCORE\_SFR\_RFIRQF0; uint\_fast8\_t flags\_f1 = RFCORE\_SFR\_RFIRQF1;
 uint8\_t handled\_f0 = 0; uint8\_t handled\_f1 = 0;
 assert(cc2538\_state != CC2538\_STATE\_TRX\_TRANSITION);
 if (flags\_f1 & TXDONE) { handled\_f1 |= TXDONE; /\* TXDONE marks the end of the TX chain. The radio is not busy anymore \*/ assert(cc2538\_state == CC2538\_STATE\_TX\_BUSY); cc2538\_state = CC2538\_STATE\_CONFIRM\_TX; cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_CONFIRM\_TX\_DONE); }
 /\* The RX chain is not busy anymore on TXACKDONE event \*/ if (flags\_f1 & TXACKDONE) { handled\_f1 |= TXACKDONE; assert(cc2538\_state == CC2538\_STATE\_TX\_ACK); cc2538\_state = CC2538\_STATE\_READY; }
 if ((flags\_f0 & SFD)) { handled\_f0 |= SFD; switch(cc2538\_state) { case CC2538\_STATE\_READY: cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_INDICATION\_RX\_START); break; case CC2538\_STATE\_TX\_BUSY: /\* If the radio already transmitted, this SFD is the TX\_START event \*/ cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_INDICATION\_TX\_START); break; case CC2538\_STATE\_TX\_ACK: /\* The detected SFD comes from the transmitted ACK frame. Simply \* ignore it \*/ break; default: /\* This should never happen \*/ DEBUG("ERROR: cc2538\_state: %i\n", cc2538\_state); assert(false); } }
 if (flags\_f0 & RXPKTDONE) { handled\_f0 |= RXPKTDONE; /\* CRC check \*/ uint8\_t pkt\_len = rfcore\_peek\_rx\_fifo(0); if (rfcore\_peek\_rx\_fifo(pkt\_len) & CC2538\_CRC\_BIT\_MASK) { /\* Disable RX while the frame has not been processed \*/ \_disable\_rx(); /\* If AUTOACK is disabled or the ACK request bit is not set \*/ if (IS\_ACTIVE(CONFIG\_IEEE802154\_AUTO\_ACK\_DISABLE) || (!(rfcore\_peek\_rx\_fifo(1) & IEEE802154\_FCF\_ACK\_REQ))) { /\* The radio won't send an ACK. Therefore the RX chain is not \* busy anymore \*/ cc2538\_state = CC2538\_STATE\_READY; } else { cc2538\_state = CC2538\_STATE\_TX\_ACK; } cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_INDICATION\_RX\_DONE); } else { /\* Disable RX while the frame has not been processed \*/ /\* CRC failed; discard packet. The RX chain is not busy anymore \*/ cc2538\_state = CC2538\_STATE\_READY; cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_INDICATION\_CRC\_ERROR); } }
 /\* Check if the interrupt was triggered because the CSP finished its routine \* (CSMA-CA or CCA request) \*/ if (flags\_f1 & CSP\_STOP) { handled\_f1 |= CSP\_STOP; RFCORE\_XREG\_CSPCTRL |= CC2538\_CSP\_MCU\_CTRL\_MASK; switch (cc2538\_state) { case CC2538\_STATE\_TX\_BUSY: if (RFCORE\_XREG\_CSPZ > 0) { RFCORE\_SFR\_RFST = ISTXON; } else { /\* In case of CCA failure the TX chain is not busy anymore \*/ cc2538\_state = CC2538\_STATE\_CONFIRM\_TX; cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_CONFIRM\_TX\_DONE); } break; case CC2538\_STATE\_CCA: cc2538\_cca\_status = BOOLEAN(RFCORE->XREG\_FSMSTAT1bits.CCA) && RFCORE->XREG\_RSSISTATbits.RSSI\_VALID; cc2538\_state = CC2538\_STATE\_CONFIRM\_CCA; cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_CONFIRM\_CCA); break; default: /\* This should never happen \*/ DEBUG("ERROR: cc2538\_state: %i\n", cc2538\_state); assert(false); break; } }
 RFCORE\_SFR\_RFIRQF0 &= ~handled\_f0; RFCORE\_SFR\_RFIRQF1 &= ~handled\_f1;}
static int \_off(ieee802154\_dev\_t \*dev){ (void) dev; return -ENOTSUP;}
static int \_config\_addr\_filter(ieee802154\_dev\_t \*dev, ieee802154\_af\_cmd\_t cmd, const void \*value){ (void) dev; const network\_uint16\_t \*short\_addr = value; const eui64\_t \*ext\_addr = value; const uint16\_t \*pan\_id = value; switch(cmd) { case IEEE802154\_AF\_SHORT\_ADDR: RFCORE\_FFSM\_SHORT\_ADDR0 = short\_addr->u8[1]; RFCORE\_FFSM\_SHORT\_ADDR1 = short\_addr->u8[0]; break; case IEEE802154\_AF\_EXT\_ADDR: RFCORE\_FFSM\_EXT\_ADDR0 = ext\_addr->uint8[7]; RFCORE\_FFSM\_EXT\_ADDR1 = ext\_addr->uint8[6]; RFCORE\_FFSM\_EXT\_ADDR2 = ext\_addr->uint8[5]; RFCORE\_FFSM\_EXT\_ADDR3 = ext\_addr->uint8[4]; RFCORE\_FFSM\_EXT\_ADDR4 = ext\_addr->uint8[3]; RFCORE\_FFSM\_EXT\_ADDR5 = ext\_addr->uint8[2]; RFCORE\_FFSM\_EXT\_ADDR6 = ext\_addr->uint8[1]; RFCORE\_FFSM\_EXT\_ADDR7 = ext\_addr->uint8[0]; break; case IEEE802154\_AF\_PANID: RFCORE\_FFSM\_PAN\_ID0 = \*pan\_id; RFCORE\_FFSM\_PAN\_ID1 = (\*pan\_id) >> 8; break; case IEEE802154\_AF\_PAN\_COORD: return -ENOTSUP; }
 return 0;}
static int \_config\_src\_addr\_match(ieee802154\_dev\_t \*dev, ieee802154\_src\_match\_t cmd, const void \*value){ (void) dev; switch(cmd) { case IEEE802154\_SRC\_MATCH\_EN: RFCORE\_XREG\_FRMCTRL1 &= ~CC2538\_FRMCTRL1\_PENDING\_OR\_MASK; if (\*((const bool\*) value) == true) { RFCORE\_XREG\_FRMCTRL1 |= CC2538\_FRMCTRL1\_PENDING\_OR\_MASK; } break; default: return -ENOTSUP; } return 0;}
static int \_confirm\_on(ieee802154\_dev\_t \*dev){ (void) dev; /\* TODO \*/ return 0;}
static int \_request\_on(ieee802154\_dev\_t \*dev){ (void) dev; /\* TODO \*/ return 0;}
static int \_set\_cca\_mode(ieee802154\_dev\_t \*dev, ieee802154\_cca\_mode\_t mode){ (void) dev; uint8\_t tmp = 0; switch (mode) { case IEEE802154\_CCA\_MODE\_ED\_THRESHOLD: tmp = 1; break; case IEEE802154\_CCA\_MODE\_CARRIER\_SENSING: tmp = 2; break; case IEEE802154\_CCA\_MODE\_ED\_THRESH\_AND\_CS: tmp = 3; break; case IEEE802154\_CCA\_MODE\_ED\_THRESH\_OR\_CS: return -ENOTSUP; }
 RFCORE\_XREG\_CCACTRL1 &= CC2538\_CCA\_MODE\_MASK; RFCORE\_XREG\_CCACTRL1 |= (tmp << CC2538\_CCA\_MODE\_POS);
 return 0;}
static int \_set\_csma\_params(ieee802154\_dev\_t \*dev, const ieee802154\_csma\_be\_t \*bd, int8\_t retries){ (void) dev; if (bd) { cc2538\_min\_be = bd->min; cc2538\_max\_be = bd->max; }
 cc2538\_csma\_ca\_retries = retries;
 return 0;}
static int \_set\_frame\_filter\_mode(ieee802154\_dev\_t \*dev, ieee802154\_filter\_mode\_t mode){ (void) dev;
 uint8\_t flags = 0; bool promisc = false; switch (mode) { case IEEE802154\_FILTER\_ACCEPT: flags = CC2538\_ACCEPT\_FT\_0\_BEACON | CC2538\_ACCEPT\_FT\_1\_DATA | CC2538\_ACCEPT\_FT\_3\_CMD; break; case IEEE802154\_FILTER\_PROMISC: promisc = true; break; case IEEE802154\_FILTER\_ACK\_ONLY: flags = CC2538\_ACCEPT\_FT\_2\_ACK; break; default: return -ENOTSUP; }
 RFCORE\_XREG\_FRMFILT1 |= flags; cc2538\_set\_monitor(promisc);
 return 0;
}
void cc2538\_rf\_hal\_setup(ieee802154\_dev\_t \*hal){ /\* We don't set hal->priv because the context of this device is global \*/ /\* We need to store a reference to the HAL descriptor though for the ISR \*/ hal->driver = &cc2538\_rf\_ops; cc2538\_rf\_hal = hal;}
static const ieee802154\_radio\_ops\_t cc2538\_rf\_ops = { .caps = IEEE802154\_CAP\_24\_GHZ | IEEE802154\_CAP\_AUTO\_CSMA | IEEE802154\_CAP\_IRQ\_CRC\_ERROR | IEEE802154\_CAP\_IRQ\_TX\_DONE | IEEE802154\_CAP\_IRQ\_CCA\_DONE | IEEE802154\_CAP\_IRQ\_RX\_START | IEEE802154\_CAP\_IRQ\_TX\_START | IEEE802154\_CAP\_PHY\_OQPSK,
 .write = \_write, .read = \_read, .len = \_len, .off = \_off, .request\_on = \_request\_on, .confirm\_on = \_confirm\_on, .request\_op = \_request\_op, .confirm\_op = \_confirm\_op, .set\_cca\_threshold = \_set\_cca\_threshold, .set\_cca\_mode = \_set\_cca\_mode, .config\_phy = \_config\_phy, .config\_addr\_filter = \_config\_addr\_filter, .config\_src\_addr\_match = \_config\_src\_addr\_match, .set\_csma\_params = \_set\_csma\_params, .set\_frame\_filter\_mode = \_set\_frame\_filter\_mode,};

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_0e380bcb_20250114_205709.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fpull%2F20998)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fpull%2F20998)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fpull_requests_fragments%2Fpull_request_layout&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  387](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

New issue

**Have a question about this project?** Sign up for a free GitHub account to open an issue and contact its maintainers and the community.

 [Sign up for GitHub](/signup?return_to=%2FRIOT-OS%2FRIOT%2Fissues%2Fnew%2Fchoose)

By clicking “Sign up for GitHub”, you agree to our [terms of service](https://docs.github.com/terms) and
[privacy statement](https://docs.github.com/privacy). We’ll occasionally send you account related emails.

Already on GitHub?
[Sign in](/login?return_to=%2FRIOT-OS%2FRIOT%2Fissues%2Fnew%2Fchoose)
to your account

[Jump to bottom](#issue-comment-box)

# cpu/cc2538: mask length byte before checking CRC #20998

 Merged

[maribu](/maribu)
merged 1 commit into
[RIOT-OS:master](/RIOT-OS/RIOT/tree/master "RIOT-OS/RIOT:master")
from
[HavingaThijs:maskLengthByte](/HavingaThijs/RIOT/tree/maskLengthByte "HavingaThijs/RIOT:maskLengthByte")

Nov 18, 2024

 Merged

# [cpu/cc2538: mask length byte before checking CRC](#top) #20998

[maribu](/maribu)
merged 1 commit into
[RIOT-OS:master](/RIOT-OS/RIOT/tree/master "RIOT-OS/RIOT:master")
from
[HavingaThijs:maskLengthByte](/HavingaThijs/RIOT/tree/maskLengthByte "HavingaThijs/RIOT:maskLengthByte")

Nov 18, 2024

[Conversation
5](/RIOT-OS/RIOT/pull/20998)
[Commits
1](/RIOT-OS/RIOT/pull/20998/commits)
[Checks
26](/RIOT-OS/RIOT/pull/20998/checks)
[Files changed](/RIOT-OS/RIOT/pull/20998/files)

## Conversation

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

[![HavingaThijs](https://avatars.githubusercontent.com/u/94684410?s=60&v=4)](/HavingaThijs)

Copy link

Contributor

### @HavingaThijs **[HavingaThijs](/HavingaThijs)** commented [Nov 16, 2024](#issue-2664813435)

### Contribution description

This is a follow-up for [#20956](https://github.com/RIOT-OS/RIOT/pull/20956).

I found that the solution applied there wasn’t robust, because when receiving short packets quickly after each other the RX FIFO might be filling up with a new packet while handling the IRQ. Then, the number of bytes in the FIFO will be bigger than the packet length of the first packet. Even though the second packet will be dropped anyway, the length of the first packet can still be correctly obtained from the length byte in the packet.

Namely, from section 23.9.5.1 of the CC2538 User’s Guide it follows that indeed the radio will mask out bit 7 of the length byte:

[![image](https://private-user-images.githubusercontent.com/94684410/386871623-7d67e9c0-ab68-4703-8087-fee3a6da428c.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MzY4ODg1MjgsIm5iZiI6MTczNjg4ODIyOCwicGF0aCI6Ii85NDY4NDQxMC8zODY4NzE2MjMtN2Q2N2U5YzAtYWI2OC00NzAzLTgwODctZmVlM2E2ZGE0MjhjLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTAxMTQlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwMTE0VDIwNTcwOFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTU4N2UxMGIyNGI3ZWRkMDNkNGRmMGVhNWYzZmQ3NTVkMzkwMjQzMTU3MWI5Y2U4NDVkYTY4ZjZkNTY0OGFmNmMmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.NK69UKsnuazRos8pigKLBHCw89cZja8c_qz6QvARcuM)](https://private-user-images.githubusercontent.com/94684410/386871623-7d67e9c0-ab68-4703-8087-fee3a6da428c.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MzY4ODg1MjgsIm5iZiI6MTczNjg4ODIyOCwicGF0aCI6Ii85NDY4NDQxMC8zODY4NzE2MjMtN2Q2N2U5YzAtYWI2OC00NzAzLTgwODctZmVlM2E2ZGE0MjhjLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTAxMTQlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwMTE0VDIwNTcwOFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTU4N2UxMGIyNGI3ZWRkMDNkNGRmMGVhNWYzZmQ3NTVkMzkwMjQzMTU3MWI5Y2U4NDVkYTY4ZjZkNTY0OGFmNmMmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.NK69UKsnuazRos8pigKLBHCw89cZja8c_qz6QvARcuM)

Then, it continues to fill the RX FIFO with this number of bytes as follows from section 23.9.3:

[![image](https://private-user-images.githubusercontent.com/94684410/386872349-21eac5ff-4353-4de1-8855-794651a26a01.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MzY4ODg1MjgsIm5iZiI6MTczNjg4ODIyOCwicGF0aCI6Ii85NDY4NDQxMC8zODY4NzIzNDktMjFlYWM1ZmYtNDM1My00ZGUxLTg4NTUtNzk0NjUxYTI2YTAxLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTAxMTQlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwMTE0VDIwNTcwOFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPWE4YjcyMzk0ZDAxYzc2N2MzZmRhZWRjNzQxZDg0OGE0NjA0NmY2NjNjYjFhNTgzYTA5NTk1YTQzNzg4Y2Q2NzQmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.BAlXu9Yq2B64o6MttUWdx3jQoVTQ6dX4sUfVkD034s0)](https://private-user-images.githubusercontent.com/94684410/386872349-21eac5ff-4353-4de1-8855-794651a26a01.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MzY4ODg1MjgsIm5iZiI6MTczNjg4ODIyOCwicGF0aCI6Ii85NDY4NDQxMC8zODY4NzIzNDktMjFlYWM1ZmYtNDM1My00ZGUxLTg4NTUtNzk0NjUxYTI2YTAxLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTAxMTQlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwMTE0VDIwNTcwOFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPWE4YjcyMzk0ZDAxYzc2N2MzZmRhZWRjNzQxZDg0OGE0NjA0NmY2NjNjYjFhNTgzYTA5NTk1YTQzNzg4Y2Q2NzQmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.BAlXu9Yq2B64o6MttUWdx3jQoVTQ6dX4sUfVkD034s0)

This means that with this approach, always the correct byte is used for checking the CRC result.

### Testing procedure

Flashed this PR on two devices, and tested with long packets that the error from [#20955](https://github.com/RIOT-OS/RIOT/issues/20955) didn't appear. When testing short packets quickly after each other, in case the old `crc_loc` was not equal to the corrected `pkt_len`, the `pkt_len` had the expected number of bytes, while `crc_loc` was usually a couple bytes more than that.

### Issues/PRs references

This is a more proper fix for [#20955](https://github.com/RIOT-OS/RIOT/issues/20955).

Sorry, something went wrong.

All reactions

[![@github-actions](https://avatars.githubusercontent.com/in/15368?s=40&v=4)](/apps/github-actions)
[github-actions](/apps/github-actions)
bot
added
[Platform: ARM](/RIOT-OS/RIOT/labels/Platform%3A%20ARM)
Platform: This PR/issue effects ARM-based platforms
[Area: cpu](/RIOT-OS/RIOT/labels/Area%3A%20cpu)
Area: CPU/MCU ports
labels
[Nov 16, 2024](#event-15322167181)

 [![@benpicco](https://avatars.githubusercontent.com/u/1301112?s=40&v=4)](/benpicco)
[benpicco](/benpicco)
requested review from
[jia200x](/jia200x) and
[maribu](/maribu)
[November 16, 2024 21:29](#event-15322586815)

[![@benpicco](https://avatars.githubusercontent.com/u/1301112?s=40&v=4)](/benpicco)
[benpicco](/benpicco)
added
the
[Type: bug](/RIOT-OS/RIOT/labels/Type%3A%20bug)
The issue reports a bug / The PR fixes a bug (including spelling errors)
label
[Nov 16, 2024](#event-15322587260)

[![maribu](https://avatars.githubusercontent.com/u/2041729?s=60&v=4)](/maribu)

**[maribu](/maribu)**
approved these changes
[Nov 18, 2024](#pullrequestreview-2441574919)

 [View reviewed changes](/RIOT-OS/RIOT/pull/20998/files)

Copy link

Member

### @maribu **[maribu](/maribu)** left a comment

There was a problem hiding this comment.

### Choose a reason for hiding this comment

The reason will be displayed to describe this comment to others. [Learn more](https://docs.github.com/articles/managing-disruptive-comments/#hiding-a-comment).

Choose a reason

Spam
Abuse
Off Topic
Outdated
Duplicate
Resolved

Hide comment

Thanks for the fix. Please fix the issue pointed out by the CI, so that we can merge this.

Please directly amend / squash the commit.

Sorry, something went wrong.

All reactions

[cpu/cc2538/include/cc2538\_rf.h](/RIOT-OS/RIOT/pull/20998/files#diff-9b8ab26625b48234c4c2c3bca7dbf813235b8b69b852dcf4ba1cf024f0dbcd78)
Outdated

Show resolved

Hide resolved

[![@HavingaThijs](https://avatars.githubusercontent.com/u/94684410?s=40&v=4)](/HavingaThijs)

`[cpu/cc2538: mask length byte before checking CRC](/RIOT-OS/RIOT/pull/20998/commits/0c72444f24bc3290dcda459790040fcca8514098 "cpu/cc2538: mask length byte before checking CRC")`

`[0c72444](/RIOT-OS/RIOT/pull/20998/commits/0c72444f24bc3290dcda459790040fcca8514098)`

 [![@HavingaThijs](https://avatars.githubusercontent.com/u/94684410?s=40&u=68b07bb6635a91142d11c5814277e600335a25e5&v=4)](/HavingaThijs)
[HavingaThijs](/HavingaThijs)
[force-pushed](/RIOT-OS/RIOT/compare/7fab7f5973bec8bd5c645371792527b1f9c93804..0c72444f24bc3290dcda459790040fcca8514098)
the
maskLengthByte

branch
from
[`7fab7f5`](/RIOT-OS/RIOT/commit/7fab7f5973bec8bd5c645371792527b1f9c93804) to
[`0c72444`](/RIOT-OS/RIOT/commit/0c72444f24bc3290dcda459790040fcca8514098)  [Compare](/RIOT-OS/RIOT/compare/7fab7f5973bec8bd5c645371792527b1f9c93804..0c72444f24bc3290dcda459790040fcca8514098)
[November 18, 2024 07:46](#event-15329742105)

[![@maribu](https://avatars.githubusercontent.com/u/2041729?s=40&u=6e8b59db6160b2d4929809e19f5cf223ba5943f6&v=4)](/maribu)
[maribu](/maribu)
added
the
[CI: ready for build](/RIOT-OS/RIOT/labels/CI%3A%20ready%20for%20build)
If set, CI server will compile all applications for all available boards for the labeled PR
label
[Nov 18, 2024](#event-15329913051)

[![@maribu](https://avatars.githubusercontent.com/u/2041729?s=40&u=6e8b59db6160b2d4929809e19f5cf223ba5943f6&v=4)](/maribu)
[maribu](/maribu)
enabled auto-merge
[November 18, 2024 08:02](#event-15329914755)

[![@riot-ci](https://avatars.githubusercontent.com/u/12257278?s=80&u=8e74a8bce7471107cc680bcc956b1dcaeea4756d&v=4)](/riot-ci)

Copy link

### **[riot-ci](/riot-ci)** commented [Nov 18, 2024](#issuecomment-2482244204)

|  |  |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Murdock results ✔️ [PASSED](https://ci.riot-os.org/details/1da2fcce8aea43d6a9bde4a8fdf4f6b1)  [0c72444](https://github.com/RIOT-OS/RIOT/commit/0c72444f24bc3290dcda459790040fcca8514098) cpu/cc2538: mask length byte before checking CRC   | Success | Failures | Total | Runtime | | --- | --- | --- | --- | | 10249 | 0 | 10249 | 18m:48s |  Artifacts  * [Documentation preview](https://ci.riot-os.org/results/1da2fcce8aea43d6a9bde4a8fdf4f6b1/doc-preview/) |

All reactions

Sorry, something went wrong.

[![@maribu](https://avatars.githubusercontent.com/u/2041729?s=40&u=6e8b59db6160b2d4929809e19f5cf223ba5943f6&v=4)](/maribu)
[maribu](/maribu)
added this pull request to the [merge queue](/RIOT-OS/RIOT/queue/master)
[Nov 18, 2024](#event-15330142231)

 Hide details
View details

Merged
via the queue into
RIOT-OS:master

with commit [`c636f34`](/RIOT-OS/RIOT/commit/c636f34eacad89a77eb63e55e89cc32fd0c83623)
[Nov 18, 2024](https://github.com/RIOT-OS/RIOT/pull/20998#event-15333192796)
27 checks passed

[![@maribu](https://avatars.githubusercontent.com/u/2041729?s=40&u=6e8b59db6160b2d4929809e19f5cf223ba5943f6&v=4)](/maribu)
[maribu](/maribu)
mentioned this pull request
[Nov 25, 2024](#ref-pullrequest-2690506624)

[cpu/cc2538: mask length byte before checking CRC [backport 2024.10]
#21038](/RIOT-OS/RIOT/pull/21038)
 Merged

[![@maribu](https://avatars.githubusercontent.com/u/2041729?s=80&u=6e8b59db6160b2d4929809e19f5cf223ba5943f6&v=4)](/maribu)

Copy link

Member

### **[maribu](/maribu)** commented [Nov 25, 2024](#issuecomment-2497828283)

| Backport provided in [#21038](https://github.com/RIOT-OS/RIOT/pull/21038)  I sqaushed the commit of [#20956](https://github.com/RIOT-OS/RIOT/pull/20956) and this one into a single commit for the backport. |
| --- |

All reactions

Sorry, something went wrong.

[Sign up for free](/join?source=comment-repo)
**to join this conversation on GitHub**.
Already have an account?
[Sign in to comment](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fpull%2F20998)

Reviewers

[![@maribu](https://avatars.githubusercontent.com/u/2041729?s=40&v=4)](/maribu) [maribu](/maribu)

maribu approved these changes

[![@jia200x](https://avatars.githubusercontent.com/u/1260616?s=40&v=4)](/jia200x) [jia200x](/jia200x)

 Awaiting requested review from jia200x

Assignees

No one assigned

Labels

[Area: cpu](/RIOT-OS/RIOT/labels/Area%3A%20cpu)
Area: CPU/MCU ports
[CI: ready for build](/RIOT-OS/RIOT/labels/CI%3A%20ready%20for%20build)
If set, CI server will compile all applications for all available boards for the labeled PR
[Platform: ARM](/RIOT-OS/RIOT/labels/Platform%3A%20ARM)
Platform: This PR/issue effects ARM-based platforms
[Type: bug](/RIOT-OS/RIOT/labels/Type%3A%20bug)
The issue reports a bug / The PR fixes a bug (including spelling errors)

Projects

None yet

Milestone

No milestone

Development

Successfully merging this pull request may close these issues.

4 participants

[![@HavingaThijs](https://avatars.githubusercontent.com/u/94684410?s=52&v=4)](/HavingaThijs) [![@riot-ci](https://avatars.githubusercontent.com/u/12257278?s=52&v=4)](/riot-ci) [![@maribu](https://avatars.githubusercontent.com/u/2041729?s=52&v=4)](/maribu) [![@benpicco](https://avatars.githubusercontent.com/u/1301112?s=52&v=4)](/benpicco)

Add this suggestion to a batch that can be applied as a single commit.
This suggestion is invalid because no changes were made to the code.
Suggestions cannot be applied while the pull request is closed.
Suggestions cannot be applied while viewing a subset of changes.
Only one suggestion per line can be applied in a batch.
Add this suggestion to a batch that can be applied as a single commit.
Applying suggestions on deleted lines is not supported.
You must change the existing code in this line in order to create a valid suggestion.
Outdated suggestions cannot be applied.
This suggestion has been applied or marked resolved.
Suggestions cannot be applied from pending reviews.
Suggestions cannot be applied on multi-line comments.
Suggestions cannot be applied while the pull request is queued to merge.
Suggestion cannot be applied right now. Please check back later.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_920a89fb_20250114_205657.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2F1a418ccfedeb79dbce1d79f49e63a28906184794%2Fcpu%2Fcc2538%2Fradio%2Fcc2538_rf_radio_ops.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2F1a418ccfedeb79dbce1d79f49e63a28906184794%2Fcpu%2Fcc2538%2Fradio%2Fcc2538_rf_radio_ops.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  387](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

## Files

 1a418cc
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794)
2. /[cpu](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu)
3. /[cc2538](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538)
4. /[radio](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio)
/
# cc2538\_rf\_radio\_ops.c

Copy path Blame  Blame
## Latest commit

## History

[History](/RIOT-OS/RIOT/commits/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio/cc2538_rf_radio_ops.c)643 lines (556 loc) · 19.5 KB 1a418cc
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794)
2. /[cpu](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu)
3. /[cc2538](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538)
4. /[radio](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio)
/
# cc2538\_rf\_radio\_ops.c

Top
## File metadata and controls

* Code
* Blame

643 lines (556 loc) · 19.5 KB[Raw](https://github.com/RIOT-OS/RIOT/raw/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio/cc2538_rf_radio_ops.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643/\* \* Copyright (C) 2020 HAW Hamburg \* \* This file is subject to the terms and conditions of the GNU Lesser \* General Public License v2.1. See the file LICENSE in the top level \* directory for more details. \* \*/
/\*\* \* @ingroup cpu\_cc2538 \* @{ \* \* @file \* @brief IEEE 802.15.4 Radio HAL implementation for the CC2538 RF driver \* \* @author José I. Alamos <jose.alamos@haw-hamburg.de> \* \* @} \*/
#include <assert.h>#include <errno.h>#include <stdio.h>
#include "net/gnrc.h"
#include "cc2538\_rf.h"#include "cc2538\_rf\_internal.h"
#include "net/ieee802154/radio.h"
#define ENABLE\_DEBUG 0#include "debug.h"
static const ieee802154\_radio\_ops\_t cc2538\_rf\_ops;
static ieee802154\_dev\_t \*cc2538\_rf\_hal;
typedef enum { CC2538\_STATE\_READY, /\*\*< The radio is ready to receive requests \*/ CC2538\_STATE\_TRX\_TRANSITION, /\*\*< There's a pending TRX state transition \*/ CC2538\_STATE\_CONFIRM\_TX, /\*\*< Transmission finished and waiting for confirm \*/ CC2538\_STATE\_TX\_BUSY, /\*\*< The radio is busy transmitting \*/ CC2538\_STATE\_TX\_ACK, /\*\*< The radio is currently transmitting an ACK frame \*/ CC2538\_STATE\_CCA, /\*\*< The radio is doing CCA \*/ CC2538\_STATE\_CONFIRM\_CCA, /\*\*< CCA finished and waiting for confirm \*/} cc2538\_state\_t;
static cc2538\_state\_t cc2538\_state;static uint8\_t cc2538\_min\_be = CONFIG\_IEEE802154\_DEFAULT\_CSMA\_CA\_MIN\_BE;static uint8\_t cc2538\_max\_be = CONFIG\_IEEE802154\_DEFAULT\_CSMA\_CA\_MAX\_BE;static int cc2538\_csma\_ca\_retries = CONFIG\_IEEE802154\_DEFAULT\_CSMA\_CA\_RETRIES;
static bool cc2538\_cca\_status; /\*\*< status of the last CCA request \*/
static void \_enable\_rx(void){ RFCORE\_XREG\_FRMCTRL0 &= ~CC2538\_FRMCTRL0\_RX\_MODE\_DIS;}
static void \_disable\_rx(void){ RFCORE\_XREG\_FRMCTRL0 |= CC2538\_FRMCTRL0\_RX\_MODE\_DIS;}
static int \_write(ieee802154\_dev\_t \*dev, const iolist\_t \*iolist){ (void) dev; int pkt\_len = 0; RFCORE\_SFR\_RFST = ISFLUSHTX; rfcore\_write\_byte(0);
 for (const iolist\_t \*iol = iolist; iol; iol = iol->iol\_next) { if (iol->iol\_len) { pkt\_len += iol->iol\_len; rfcore\_write\_fifo(iol->iol\_base, iol->iol\_len); } }
 /\* Set first byte of TX FIFO to the packet length \*/ rfcore\_poke\_tx\_fifo(0, pkt\_len + CC2538\_AUTOCRC\_LEN); return 0;}static int \_request\_op(ieee802154\_dev\_t \*dev, ieee802154\_hal\_op\_t op, void \*ctx){ (void) dev; int res = -EBUSY; cc2538\_rf\_disable\_irq(); switch (op) { case IEEE802154\_HAL\_OP\_TRANSMIT: assert(cc2538\_state != CC2538\_STATE\_TX\_BUSY); cc2538\_state = CC2538\_STATE\_TX\_BUSY; if (cc2538\_csma\_ca\_retries < 0) { RFCORE\_SFR\_RFST = ISTXON; /\* The CPU Ctrl mask is used here to indicate whether the radio is being \* controlled by the CPU or the CSP Strobe Processor. \* We set this to 1 in order to indicate that the CSP is not used and \* thus, that the @ref ieee802154\_radio\_confirm\_transmit should \* return 0 immediately after the TXDONE event \*/ RFCORE\_XREG\_CSPCTRL |= CC2538\_CSP\_MCU\_CTRL\_MASK; } else { /\* Disable RX Chain for CCA (see CC2538 RM, Section 29.9.5.3) \*/ \_disable\_rx(); RFCORE\_SFR\_RFST = ISRXON; /\* Clear last program \*/ RFCORE\_SFR\_RFST = ISCLEAR;
 /\* If the RSSI is not yet valid, skip 0 instructions. This creates \* a busy loop until the RSSI is valid. \*/ RFCORE\_SFR\_RFST = SKIP\_S\_C | CC2538\_CSP\_SKIP\_N\_MASK | CC2538\_CSP\_SKIP\_COND\_RSSI;
 /\* Set a label right before the backoff \*/ RFCORE\_SFR\_RFST = LABEL;
 /\* Load a random number with "register Y" LSBs into register X. \* This is equivalent to choosing a random number between \* (0, 2^(Y+1)). \* Then, wait "register X" number of backoff units \*/ RFCORE\_SFR\_RFST = RANDXY; RFCORE\_SFR\_RFST = WAITX;
 /\* If CCA is not valid, skip the next stop instruction. In such case \* the CSP\_STOP interrupt will trigger the transmission since the \* channel is clear \*/ RFCORE\_SFR\_RFST = SKIP\_S\_C | (1 << CC2538\_CSP\_SKIP\_INST\_POS) | CC2538\_CSP\_SKIP\_N\_MASK | CC2538\_CSP\_SKIP\_COND\_CCA;
 RFCORE\_SFR\_RFST = STOP;
 /\* If we are here, the channel was not clear. Decrement the register Z \* (remaining attempts) \*/ RFCORE\_SFR\_RFST = DECZ;
 /\* Update the backoff exponent \*/ RFCORE\_SFR\_RFST = INCMAXY | (cc2538\_max\_be & CC2538\_CSP\_INCMAXY\_MAX\_MASK);
 /\* If the are CSMA-CA retries left, go back to the defined label \*/ RFCORE\_SFR\_RFST = RPT\_C | CC2538\_CSP\_SKIP\_N\_MASK | CC2538\_CSP\_SKIP\_COND\_CSPZ;
 /\* Stop the program. The CSP\_STOP interrupt will trigger the routine \* to inform the upper layer that CSMA-CA failed. \*/ RFCORE\_SFR\_RFST = STOP;
 RFCORE\_XREG\_CSPX = 0; /\* Holds timer value \*/ RFCORE\_XREG\_CSPY = cc2538\_min\_be; /\* Holds MinBE \*/
 assert(cc2538\_csma\_ca\_retries >= 0); RFCORE\_XREG\_CSPZ = cc2538\_csma\_ca\_retries + 1; /\* Holds CSMA-CA attempts (retries + 1) \*/
 RFCORE\_XREG\_CSPCTRL &= ~CC2538\_CSP\_MCU\_CTRL\_MASK;
 /\* Execute the program \*/ RFCORE\_SFR\_RFST = ISSTART; } cc2538\_rf\_enable\_irq(); break; case IEEE802154\_HAL\_OP\_SET\_RX: if (cc2538\_state != CC2538\_STATE\_READY) { goto error; } cc2538\_state = CC2538\_STATE\_TRX\_TRANSITION; /\* Enable RX Chain \*/ \_enable\_rx(); RFCORE\_SFR\_RFST = ISRXON; RFCORE\_SFR\_RFIRQF0 &= ~RXPKTDONE; RFCORE\_SFR\_RFIRQF0 &= ~SFD; /\* We keep the interrupts disabled until the state transition is \* finished \*/ break; case IEEE802154\_HAL\_OP\_SET\_IDLE: { assert(ctx); bool force = \*((bool\*) ctx);
 if (!force && cc2538\_state != CC2538\_STATE\_READY) { goto error; }
 cc2538\_state = CC2538\_STATE\_TRX\_TRANSITION; if (RFCORE->XREG\_FSMSTAT0bits.FSM\_FFCTRL\_STATE != FSM\_STATE\_IDLE) { RFCORE\_SFR\_RFST = ISRFOFF; } RFCORE\_SFR\_RFIRQF0 &= ~RXPKTDONE; RFCORE\_SFR\_RFIRQF0 &= ~SFD; /\* We keep the interrupts disabled until the state transition is \* finished \*/ break; } case IEEE802154\_HAL\_OP\_CCA: /\* Ignore baseband processing \*/ \_disable\_rx(); RFCORE\_SFR\_RFIRQF0 &= ~RXPKTDONE; RFCORE\_SFR\_RFIRQF0 &= ~SFD; RFCORE\_SFR\_RFST = ISRXON; RFCORE\_SFR\_RFST = ISCLEAR; RFCORE\_SFR\_RFST = STOP; RFCORE\_XREG\_CSPCTRL &= ~CC2538\_CSP\_MCU\_CTRL\_MASK; /\* Execute the last program \*/ RFCORE\_SFR\_RFST = ISSTART; cc2538\_rf\_enable\_irq(); break; }
 res = 0; return res;
error: cc2538\_rf\_enable\_irq(); return res;}
static int \_confirm\_op(ieee802154\_dev\_t \*dev, ieee802154\_hal\_op\_t op, void \*ctx){ int res = -EAGAIN; (void) dev;
 switch (op) { case IEEE802154\_HAL\_OP\_TRANSMIT: cc2538\_rf\_disable\_irq(); if (cc2538\_state != CC2538\_STATE\_CONFIRM\_TX) { goto error; }
 if (ctx) { ieee802154\_tx\_info\_t \*info = ctx;
 if (cc2538\_csma\_ca\_retries >= 0 && RFCORE\_XREG\_CSPZ == 0) { info->status = TX\_STATUS\_MEDIUM\_BUSY; } else { info->status = TX\_STATUS\_SUCCESS; } } break; case IEEE802154\_HAL\_OP\_SET\_RX: case IEEE802154\_HAL\_OP\_SET\_IDLE: /\* IRQ is already disabled here \*/ assert(cc2538\_state == CC2538\_STATE\_TRX\_TRANSITION); break; case IEEE802154\_HAL\_OP\_CCA: assert(ctx); cc2538\_rf\_disable\_irq(); assert(cc2538\_state == CC2538\_STATE\_CCA || cc2538\_state == CC2538\_STATE\_CONFIRM\_CCA); if (cc2538\_state != CC2538\_STATE\_CONFIRM\_CCA) { goto error; }
 \_enable\_rx(); \*((bool\*) ctx) = cc2538\_cca\_status; break; }
 cc2538\_state = CC2538\_STATE\_READY; res = 0;
error: cc2538\_rf\_enable\_irq(); return res;
}
static int \_len(ieee802154\_dev\_t \*dev){ (void) dev; return rfcore\_peek\_rx\_fifo(0) - IEEE802154\_FCS\_LEN;}
static int \_read(ieee802154\_dev\_t \*dev, void \*buf, size\_t size, ieee802154\_rx\_info\_t \*info){ (void) dev; int res; size\_t pkt\_len;
 if (!buf) { res = 0; goto end; }
 /\* The upper layer shouldn't call this function if the RX\_DONE event was \* not triggered \*/ if (!(RFCORE\_XREG\_RXFIFOCNT > 0)) { assert(false); }
 pkt\_len = rfcore\_read\_byte() - IEEE802154\_FCS\_LEN; if (pkt\_len > size) { res = -ENOBUFS; goto end; }
 rfcore\_read\_fifo(buf, pkt\_len); res = pkt\_len; if (info != NULL) { uint8\_t corr\_val; int8\_t rssi\_val; rssi\_val = rfcore\_read\_byte();
 /\* The number of dB above maximum sensitivity detected for the \* received packet \*/ /\* Make sure there is no overflow even if no signal with such low sensitivity should be detected \*/ const int hw\_rssi\_min = IEEE802154\_RADIO\_RSSI\_OFFSET - CC2538\_RSSI\_OFFSET; int8\_t hw\_rssi = rssi\_val > hw\_rssi\_min ? (CC2538\_RSSI\_OFFSET + rssi\_val) : IEEE802154\_RADIO\_RSSI\_OFFSET; info->rssi = hw\_rssi - IEEE802154\_RADIO\_RSSI\_OFFSET;
 corr\_val = rfcore\_read\_byte() & CC2538\_CORR\_VAL\_MASK; if (corr\_val < CC2538\_CORR\_VAL\_MIN) { corr\_val = CC2538\_CORR\_VAL\_MIN; } else if (corr\_val > CC2538\_CORR\_VAL\_MAX) { corr\_val = CC2538\_CORR\_VAL\_MAX; }
 /\* Interpolate the correlation value between 0 - 255 \* to provide an LQI value \*/ info->lqi = 255 \* (corr\_val - CC2538\_CORR\_VAL\_MIN) / (CC2538\_CORR\_VAL\_MAX - CC2538\_CORR\_VAL\_MIN); }
end: /\* We don't need to enable RX chain here, since the upper layer already \* made sure the transceiver is in IDLE. We simply flush the RX buffer \*/ RFCORE\_SFR\_RFST = ISFLUSHRX; return res;}
static int \_set\_cca\_threshold(ieee802154\_dev\_t \*dev, int8\_t threshold){ (void) dev; (void) threshold;
 if (threshold < CC2538\_RF\_SENSITIVITY) { return -EINVAL; }
 RFCORE\_XREG\_CCACTRL0 &= ~CC2538\_CCA\_THR\_MASK; RFCORE\_XREG\_CCACTRL0 |= (threshold - CC2538\_RSSI\_OFFSET) & CC2538\_CCA\_THR\_MASK;
 return 0;}
static int \_config\_phy(ieee802154\_dev\_t \*dev, const ieee802154\_phy\_conf\_t \*conf){ (void) dev; int8\_t pow = conf->pow; if (pow < OUTPUT\_POWER\_MIN || pow > OUTPUT\_POWER\_MAX) { return -EINVAL; }
 uint8\_t channel = conf->channel; cc2538\_set\_freq(IEEE802154\_CHAN2FREQ(channel)); cc2538\_set\_tx\_power(pow);
 return 0;}
void cc2538\_irq\_handler(void){ uint\_fast8\_t flags\_f0 = RFCORE\_SFR\_RFIRQF0; uint\_fast8\_t flags\_f1 = RFCORE\_SFR\_RFIRQF1;
 uint8\_t handled\_f0 = 0; uint8\_t handled\_f1 = 0;
 assert(cc2538\_state != CC2538\_STATE\_TRX\_TRANSITION);
 if (flags\_f1 & TXDONE) { handled\_f1 |= TXDONE; /\* TXDONE marks the end of the TX chain. The radio is not busy anymore \*/ assert(cc2538\_state == CC2538\_STATE\_TX\_BUSY); cc2538\_state = CC2538\_STATE\_CONFIRM\_TX; cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_CONFIRM\_TX\_DONE); }
 /\* The RX chain is not busy anymore on TXACKDONE event \*/ if (flags\_f1 & TXACKDONE) { handled\_f1 |= TXACKDONE; assert(cc2538\_state == CC2538\_STATE\_TX\_ACK); cc2538\_state = CC2538\_STATE\_READY; }
 if ((flags\_f0 & SFD)) { handled\_f0 |= SFD; switch(cc2538\_state) { case CC2538\_STATE\_READY: cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_INDICATION\_RX\_START); break; case CC2538\_STATE\_TX\_BUSY: /\* If the radio already transmitted, this SFD is the TX\_START event \*/ cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_INDICATION\_TX\_START); break; case CC2538\_STATE\_TX\_ACK: /\* The detected SFD comes from the transmitted ACK frame. Simply \* ignore it \*/ break; default: /\* This should never happen \*/ DEBUG("ERROR: cc2538\_state: %i\n", cc2538\_state); assert(false); } }
 if (flags\_f0 & RXPKTDONE) { handled\_f0 |= RXPKTDONE; /\* CRC check \*/ uint8\_t pkt\_len = rfcore\_peek\_rx\_fifo(0); if (rfcore\_peek\_rx\_fifo(pkt\_len) & CC2538\_CRC\_BIT\_MASK) { /\* Disable RX while the frame has not been processed \*/ \_disable\_rx(); /\* If AUTOACK is disabled or the ACK request bit is not set \*/ if (IS\_ACTIVE(CONFIG\_IEEE802154\_AUTO\_ACK\_DISABLE) || (!(rfcore\_peek\_rx\_fifo(1) & IEEE802154\_FCF\_ACK\_REQ))) { /\* The radio won't send an ACK. Therefore the RX chain is not \* busy anymore \*/ cc2538\_state = CC2538\_STATE\_READY; } else { cc2538\_state = CC2538\_STATE\_TX\_ACK; } cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_INDICATION\_RX\_DONE); } else { /\* Disable RX while the frame has not been processed \*/ /\* CRC failed; discard packet. The RX chain is not busy anymore \*/ cc2538\_state = CC2538\_STATE\_READY; cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_INDICATION\_CRC\_ERROR); } }
 /\* Check if the interrupt was triggered because the CSP finished its routine \* (CSMA-CA or CCA request) \*/ if (flags\_f1 & CSP\_STOP) { handled\_f1 |= CSP\_STOP; RFCORE\_XREG\_CSPCTRL |= CC2538\_CSP\_MCU\_CTRL\_MASK; switch (cc2538\_state) { case CC2538\_STATE\_TX\_BUSY: if (RFCORE\_XREG\_CSPZ > 0) { RFCORE\_SFR\_RFST = ISTXON; } else { /\* In case of CCA failure the TX chain is not busy anymore \*/ cc2538\_state = CC2538\_STATE\_CONFIRM\_TX; cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_CONFIRM\_TX\_DONE); } break; case CC2538\_STATE\_CCA: cc2538\_cca\_status = BOOLEAN(RFCORE->XREG\_FSMSTAT1bits.CCA) && RFCORE->XREG\_RSSISTATbits.RSSI\_VALID; cc2538\_state = CC2538\_STATE\_CONFIRM\_CCA; cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_CONFIRM\_CCA); break; default: /\* This should never happen \*/ DEBUG("ERROR: cc2538\_state: %i\n", cc2538\_state); assert(false); break; } }
 RFCORE\_SFR\_RFIRQF0 &= ~handled\_f0; RFCORE\_SFR\_RFIRQF1 &= ~handled\_f1;}
static int \_off(ieee802154\_dev\_t \*dev){ (void) dev; return -ENOTSUP;}
static int \_config\_addr\_filter(ieee802154\_dev\_t \*dev, ieee802154\_af\_cmd\_t cmd, const void \*value){ (void) dev; const network\_uint16\_t \*short\_addr = value; const eui64\_t \*ext\_addr = value; const uint16\_t \*pan\_id = value; switch(cmd) { case IEEE802154\_AF\_SHORT\_ADDR: RFCORE\_FFSM\_SHORT\_ADDR0 = short\_addr->u8[1]; RFCORE\_FFSM\_SHORT\_ADDR1 = short\_addr->u8[0]; break; case IEEE802154\_AF\_EXT\_ADDR: RFCORE\_FFSM\_EXT\_ADDR0 = ext\_addr->uint8[7]; RFCORE\_FFSM\_EXT\_ADDR1 = ext\_addr->uint8[6]; RFCORE\_FFSM\_EXT\_ADDR2 = ext\_addr->uint8[5]; RFCORE\_FFSM\_EXT\_ADDR3 = ext\_addr->uint8[4]; RFCORE\_FFSM\_EXT\_ADDR4 = ext\_addr->uint8[3]; RFCORE\_FFSM\_EXT\_ADDR5 = ext\_addr->uint8[2]; RFCORE\_FFSM\_EXT\_ADDR6 = ext\_addr->uint8[1]; RFCORE\_FFSM\_EXT\_ADDR7 = ext\_addr->uint8[0]; break; case IEEE802154\_AF\_PANID: RFCORE\_FFSM\_PAN\_ID0 = \*pan\_id; RFCORE\_FFSM\_PAN\_ID1 = (\*pan\_id) >> 8; break; case IEEE802154\_AF\_PAN\_COORD: return -ENOTSUP; }
 return 0;}
static int \_config\_src\_addr\_match(ieee802154\_dev\_t \*dev, ieee802154\_src\_match\_t cmd, const void \*value){ (void) dev; switch(cmd) { case IEEE802154\_SRC\_MATCH\_EN: RFCORE\_XREG\_FRMCTRL1 &= ~CC2538\_FRMCTRL1\_PENDING\_OR\_MASK; if (\*((const bool\*) value) == true) { RFCORE\_XREG\_FRMCTRL1 |= CC2538\_FRMCTRL1\_PENDING\_OR\_MASK; } break; default: return -ENOTSUP; } return 0;}
static int \_confirm\_on(ieee802154\_dev\_t \*dev){ (void) dev; /\* TODO \*/ return 0;}
static int \_request\_on(ieee802154\_dev\_t \*dev){ (void) dev; /\* TODO \*/ return 0;}
static int \_set\_cca\_mode(ieee802154\_dev\_t \*dev, ieee802154\_cca\_mode\_t mode){ (void) dev; uint8\_t tmp = 0; switch (mode) { case IEEE802154\_CCA\_MODE\_ED\_THRESHOLD: tmp = 1; break; case IEEE802154\_CCA\_MODE\_CARRIER\_SENSING: tmp = 2; break; case IEEE802154\_CCA\_MODE\_ED\_THRESH\_AND\_CS: tmp = 3; break; case IEEE802154\_CCA\_MODE\_ED\_THRESH\_OR\_CS: return -ENOTSUP; }
 RFCORE\_XREG\_CCACTRL1 &= CC2538\_CCA\_MODE\_MASK; RFCORE\_XREG\_CCACTRL1 |= (tmp << CC2538\_CCA\_MODE\_POS);
 return 0;}
static int \_set\_csma\_params(ieee802154\_dev\_t \*dev, const ieee802154\_csma\_be\_t \*bd, int8\_t retries){ (void) dev; if (bd) { cc2538\_min\_be = bd->min; cc2538\_max\_be = bd->max; }
 cc2538\_csma\_ca\_retries = retries;
 return 0;}
static int \_set\_frame\_filter\_mode(ieee802154\_dev\_t \*dev, ieee802154\_filter\_mode\_t mode){ (void) dev;
 uint8\_t flags = 0; bool promisc = false; switch (mode) { case IEEE802154\_FILTER\_ACCEPT: flags = CC2538\_ACCEPT\_FT\_0\_BEACON | CC2538\_ACCEPT\_FT\_1\_DATA | CC2538\_ACCEPT\_FT\_3\_CMD; break; case IEEE802154\_FILTER\_PROMISC: promisc = true; break; case IEEE802154\_FILTER\_ACK\_ONLY: flags = CC2538\_ACCEPT\_FT\_2\_ACK; break; default: return -ENOTSUP; }
 RFCORE\_XREG\_FRMFILT1 |= flags; cc2538\_set\_monitor(promisc);
 return 0;
}
void cc2538\_rf\_hal\_setup(ieee802154\_dev\_t \*hal){ /\* We don't set hal->priv because the context of this device is global \*/ /\* We need to store a reference to the HAL descriptor though for the ISR \*/ hal->driver = &cc2538\_rf\_ops; cc2538\_rf\_hal = hal;}
static const ieee802154\_radio\_ops\_t cc2538\_rf\_ops = { .caps = IEEE802154\_CAP\_24\_GHZ | IEEE802154\_CAP\_AUTO\_CSMA | IEEE802154\_CAP\_IRQ\_CRC\_ERROR | IEEE802154\_CAP\_IRQ\_TX\_DONE | IEEE802154\_CAP\_IRQ\_CCA\_DONE | IEEE802154\_CAP\_IRQ\_RX\_START | IEEE802154\_CAP\_IRQ\_TX\_START | IEEE802154\_CAP\_PHY\_OQPSK,
 .write = \_write, .read = \_read, .len = \_len, .off = \_off, .request\_on = \_request\_on, .confirm\_on = \_confirm\_on, .request\_op = \_request\_op, .confirm\_op = \_confirm\_op, .set\_cca\_threshold = \_set\_cca\_threshold, .set\_cca\_mode = \_set\_cca\_mode, .config\_phy = \_config\_phy, .config\_addr\_filter = \_config\_addr\_filter, .config\_src\_addr\_match = \_config\_src\_addr\_match, .set\_csma\_params = \_set\_csma\_params, .set\_frame\_filter\_mode = \_set\_frame\_filter\_mode,};

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_0f228cda_20250114_205704.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2F1a418ccfedeb79dbce1d79f49e63a28906184794%2Fcpu%2Fcc2538%2Fradio%2Fcc2538_rf_radio_ops.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2F1a418ccfedeb79dbce1d79f49e63a28906184794%2Fcpu%2Fcc2538%2Fradio%2Fcc2538_rf_radio_ops.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  387](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

## Files

 1a418cc
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794)
2. /[cpu](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu)
3. /[cc2538](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538)
4. /[radio](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio)
/
# cc2538\_rf\_radio\_ops.c

Copy path Blame  Blame
## Latest commit

## History

[History](/RIOT-OS/RIOT/commits/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio/cc2538_rf_radio_ops.c)643 lines (556 loc) · 19.5 KB 1a418cc
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794)
2. /[cpu](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu)
3. /[cc2538](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538)
4. /[radio](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio)
/
# cc2538\_rf\_radio\_ops.c

Top
## File metadata and controls

* Code
* Blame

643 lines (556 loc) · 19.5 KB[Raw](https://github.com/RIOT-OS/RIOT/raw/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio/cc2538_rf_radio_ops.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643/\* \* Copyright (C) 2020 HAW Hamburg \* \* This file is subject to the terms and conditions of the GNU Lesser \* General Public License v2.1. See the file LICENSE in the top level \* directory for more details. \* \*/
/\*\* \* @ingroup cpu\_cc2538 \* @{ \* \* @file \* @brief IEEE 802.15.4 Radio HAL implementation for the CC2538 RF driver \* \* @author José I. Alamos <jose.alamos@haw-hamburg.de> \* \* @} \*/
#include <assert.h>#include <errno.h>#include <stdio.h>
#include "net/gnrc.h"
#include "cc2538\_rf.h"#include "cc2538\_rf\_internal.h"
#include "net/ieee802154/radio.h"
#define ENABLE\_DEBUG 0#include "debug.h"
static const ieee802154\_radio\_ops\_t cc2538\_rf\_ops;
static ieee802154\_dev\_t \*cc2538\_rf\_hal;
typedef enum { CC2538\_STATE\_READY, /\*\*< The radio is ready to receive requests \*/ CC2538\_STATE\_TRX\_TRANSITION, /\*\*< There's a pending TRX state transition \*/ CC2538\_STATE\_CONFIRM\_TX, /\*\*< Transmission finished and waiting for confirm \*/ CC2538\_STATE\_TX\_BUSY, /\*\*< The radio is busy transmitting \*/ CC2538\_STATE\_TX\_ACK, /\*\*< The radio is currently transmitting an ACK frame \*/ CC2538\_STATE\_CCA, /\*\*< The radio is doing CCA \*/ CC2538\_STATE\_CONFIRM\_CCA, /\*\*< CCA finished and waiting for confirm \*/} cc2538\_state\_t;
static cc2538\_state\_t cc2538\_state;static uint8\_t cc2538\_min\_be = CONFIG\_IEEE802154\_DEFAULT\_CSMA\_CA\_MIN\_BE;static uint8\_t cc2538\_max\_be = CONFIG\_IEEE802154\_DEFAULT\_CSMA\_CA\_MAX\_BE;static int cc2538\_csma\_ca\_retries = CONFIG\_IEEE802154\_DEFAULT\_CSMA\_CA\_RETRIES;
static bool cc2538\_cca\_status; /\*\*< status of the last CCA request \*/
static void \_enable\_rx(void){ RFCORE\_XREG\_FRMCTRL0 &= ~CC2538\_FRMCTRL0\_RX\_MODE\_DIS;}
static void \_disable\_rx(void){ RFCORE\_XREG\_FRMCTRL0 |= CC2538\_FRMCTRL0\_RX\_MODE\_DIS;}
static int \_write(ieee802154\_dev\_t \*dev, const iolist\_t \*iolist){ (void) dev; int pkt\_len = 0; RFCORE\_SFR\_RFST = ISFLUSHTX; rfcore\_write\_byte(0);
 for (const iolist\_t \*iol = iolist; iol; iol = iol->iol\_next) { if (iol->iol\_len) { pkt\_len += iol->iol\_len; rfcore\_write\_fifo(iol->iol\_base, iol->iol\_len); } }
 /\* Set first byte of TX FIFO to the packet length \*/ rfcore\_poke\_tx\_fifo(0, pkt\_len + CC2538\_AUTOCRC\_LEN); return 0;}static int \_request\_op(ieee802154\_dev\_t \*dev, ieee802154\_hal\_op\_t op, void \*ctx){ (void) dev; int res = -EBUSY; cc2538\_rf\_disable\_irq(); switch (op) { case IEEE802154\_HAL\_OP\_TRANSMIT: assert(cc2538\_state != CC2538\_STATE\_TX\_BUSY); cc2538\_state = CC2538\_STATE\_TX\_BUSY; if (cc2538\_csma\_ca\_retries < 0) { RFCORE\_SFR\_RFST = ISTXON; /\* The CPU Ctrl mask is used here to indicate whether the radio is being \* controlled by the CPU or the CSP Strobe Processor. \* We set this to 1 in order to indicate that the CSP is not used and \* thus, that the @ref ieee802154\_radio\_confirm\_transmit should \* return 0 immediately after the TXDONE event \*/ RFCORE\_XREG\_CSPCTRL |= CC2538\_CSP\_MCU\_CTRL\_MASK; } else { /\* Disable RX Chain for CCA (see CC2538 RM, Section 29.9.5.3) \*/ \_disable\_rx(); RFCORE\_SFR\_RFST = ISRXON; /\* Clear last program \*/ RFCORE\_SFR\_RFST = ISCLEAR;
 /\* If the RSSI is not yet valid, skip 0 instructions. This creates \* a busy loop until the RSSI is valid. \*/ RFCORE\_SFR\_RFST = SKIP\_S\_C | CC2538\_CSP\_SKIP\_N\_MASK | CC2538\_CSP\_SKIP\_COND\_RSSI;
 /\* Set a label right before the backoff \*/ RFCORE\_SFR\_RFST = LABEL;
 /\* Load a random number with "register Y" LSBs into register X. \* This is equivalent to choosing a random number between \* (0, 2^(Y+1)). \* Then, wait "register X" number of backoff units \*/ RFCORE\_SFR\_RFST = RANDXY; RFCORE\_SFR\_RFST = WAITX;
 /\* If CCA is not valid, skip the next stop instruction. In such case \* the CSP\_STOP interrupt will trigger the transmission since the \* channel is clear \*/ RFCORE\_SFR\_RFST = SKIP\_S\_C | (1 << CC2538\_CSP\_SKIP\_INST\_POS) | CC2538\_CSP\_SKIP\_N\_MASK | CC2538\_CSP\_SKIP\_COND\_CCA;
 RFCORE\_SFR\_RFST = STOP;
 /\* If we are here, the channel was not clear. Decrement the register Z \* (remaining attempts) \*/ RFCORE\_SFR\_RFST = DECZ;
 /\* Update the backoff exponent \*/ RFCORE\_SFR\_RFST = INCMAXY | (cc2538\_max\_be & CC2538\_CSP\_INCMAXY\_MAX\_MASK);
 /\* If the are CSMA-CA retries left, go back to the defined label \*/ RFCORE\_SFR\_RFST = RPT\_C | CC2538\_CSP\_SKIP\_N\_MASK | CC2538\_CSP\_SKIP\_COND\_CSPZ;
 /\* Stop the program. The CSP\_STOP interrupt will trigger the routine \* to inform the upper layer that CSMA-CA failed. \*/ RFCORE\_SFR\_RFST = STOP;
 RFCORE\_XREG\_CSPX = 0; /\* Holds timer value \*/ RFCORE\_XREG\_CSPY = cc2538\_min\_be; /\* Holds MinBE \*/
 assert(cc2538\_csma\_ca\_retries >= 0); RFCORE\_XREG\_CSPZ = cc2538\_csma\_ca\_retries + 1; /\* Holds CSMA-CA attempts (retries + 1) \*/
 RFCORE\_XREG\_CSPCTRL &= ~CC2538\_CSP\_MCU\_CTRL\_MASK;
 /\* Execute the program \*/ RFCORE\_SFR\_RFST = ISSTART; } cc2538\_rf\_enable\_irq(); break; case IEEE802154\_HAL\_OP\_SET\_RX: if (cc2538\_state != CC2538\_STATE\_READY) { goto error; } cc2538\_state = CC2538\_STATE\_TRX\_TRANSITION; /\* Enable RX Chain \*/ \_enable\_rx(); RFCORE\_SFR\_RFST = ISRXON; RFCORE\_SFR\_RFIRQF0 &= ~RXPKTDONE; RFCORE\_SFR\_RFIRQF0 &= ~SFD; /\* We keep the interrupts disabled until the state transition is \* finished \*/ break; case IEEE802154\_HAL\_OP\_SET\_IDLE: { assert(ctx); bool force = \*((bool\*) ctx);
 if (!force && cc2538\_state != CC2538\_STATE\_READY) { goto error; }
 cc2538\_state = CC2538\_STATE\_TRX\_TRANSITION; if (RFCORE->XREG\_FSMSTAT0bits.FSM\_FFCTRL\_STATE != FSM\_STATE\_IDLE) { RFCORE\_SFR\_RFST = ISRFOFF; } RFCORE\_SFR\_RFIRQF0 &= ~RXPKTDONE; RFCORE\_SFR\_RFIRQF0 &= ~SFD; /\* We keep the interrupts disabled until the state transition is \* finished \*/ break; } case IEEE802154\_HAL\_OP\_CCA: /\* Ignore baseband processing \*/ \_disable\_rx(); RFCORE\_SFR\_RFIRQF0 &= ~RXPKTDONE; RFCORE\_SFR\_RFIRQF0 &= ~SFD; RFCORE\_SFR\_RFST = ISRXON; RFCORE\_SFR\_RFST = ISCLEAR; RFCORE\_SFR\_RFST = STOP; RFCORE\_XREG\_CSPCTRL &= ~CC2538\_CSP\_MCU\_CTRL\_MASK; /\* Execute the last program \*/ RFCORE\_SFR\_RFST = ISSTART; cc2538\_rf\_enable\_irq(); break; }
 res = 0; return res;
error: cc2538\_rf\_enable\_irq(); return res;}
static int \_confirm\_op(ieee802154\_dev\_t \*dev, ieee802154\_hal\_op\_t op, void \*ctx){ int res = -EAGAIN; (void) dev;
 switch (op) { case IEEE802154\_HAL\_OP\_TRANSMIT: cc2538\_rf\_disable\_irq(); if (cc2538\_state != CC2538\_STATE\_CONFIRM\_TX) { goto error; }
 if (ctx) { ieee802154\_tx\_info\_t \*info = ctx;
 if (cc2538\_csma\_ca\_retries >= 0 && RFCORE\_XREG\_CSPZ == 0) { info->status = TX\_STATUS\_MEDIUM\_BUSY; } else { info->status = TX\_STATUS\_SUCCESS; } } break; case IEEE802154\_HAL\_OP\_SET\_RX: case IEEE802154\_HAL\_OP\_SET\_IDLE: /\* IRQ is already disabled here \*/ assert(cc2538\_state == CC2538\_STATE\_TRX\_TRANSITION); break; case IEEE802154\_HAL\_OP\_CCA: assert(ctx); cc2538\_rf\_disable\_irq(); assert(cc2538\_state == CC2538\_STATE\_CCA || cc2538\_state == CC2538\_STATE\_CONFIRM\_CCA); if (cc2538\_state != CC2538\_STATE\_CONFIRM\_CCA) { goto error; }
 \_enable\_rx(); \*((bool\*) ctx) = cc2538\_cca\_status; break; }
 cc2538\_state = CC2538\_STATE\_READY; res = 0;
error: cc2538\_rf\_enable\_irq(); return res;
}
static int \_len(ieee802154\_dev\_t \*dev){ (void) dev; return rfcore\_peek\_rx\_fifo(0) - IEEE802154\_FCS\_LEN;}
static int \_read(ieee802154\_dev\_t \*dev, void \*buf, size\_t size, ieee802154\_rx\_info\_t \*info){ (void) dev; int res; size\_t pkt\_len;
 if (!buf) { res = 0; goto end; }
 /\* The upper layer shouldn't call this function if the RX\_DONE event was \* not triggered \*/ if (!(RFCORE\_XREG\_RXFIFOCNT > 0)) { assert(false); }
 pkt\_len = rfcore\_read\_byte() - IEEE802154\_FCS\_LEN; if (pkt\_len > size) { res = -ENOBUFS; goto end; }
 rfcore\_read\_fifo(buf, pkt\_len); res = pkt\_len; if (info != NULL) { uint8\_t corr\_val; int8\_t rssi\_val; rssi\_val = rfcore\_read\_byte();
 /\* The number of dB above maximum sensitivity detected for the \* received packet \*/ /\* Make sure there is no overflow even if no signal with such low sensitivity should be detected \*/ const int hw\_rssi\_min = IEEE802154\_RADIO\_RSSI\_OFFSET - CC2538\_RSSI\_OFFSET; int8\_t hw\_rssi = rssi\_val > hw\_rssi\_min ? (CC2538\_RSSI\_OFFSET + rssi\_val) : IEEE802154\_RADIO\_RSSI\_OFFSET; info->rssi = hw\_rssi - IEEE802154\_RADIO\_RSSI\_OFFSET;
 corr\_val = rfcore\_read\_byte() & CC2538\_CORR\_VAL\_MASK; if (corr\_val < CC2538\_CORR\_VAL\_MIN) { corr\_val = CC2538\_CORR\_VAL\_MIN; } else if (corr\_val > CC2538\_CORR\_VAL\_MAX) { corr\_val = CC2538\_CORR\_VAL\_MAX; }
 /\* Interpolate the correlation value between 0 - 255 \* to provide an LQI value \*/ info->lqi = 255 \* (corr\_val - CC2538\_CORR\_VAL\_MIN) / (CC2538\_CORR\_VAL\_MAX - CC2538\_CORR\_VAL\_MIN); }
end: /\* We don't need to enable RX chain here, since the upper layer already \* made sure the transceiver is in IDLE. We simply flush the RX buffer \*/ RFCORE\_SFR\_RFST = ISFLUSHRX; return res;}
static int \_set\_cca\_threshold(ieee802154\_dev\_t \*dev, int8\_t threshold){ (void) dev; (void) threshold;
 if (threshold < CC2538\_RF\_SENSITIVITY) { return -EINVAL; }
 RFCORE\_XREG\_CCACTRL0 &= ~CC2538\_CCA\_THR\_MASK; RFCORE\_XREG\_CCACTRL0 |= (threshold - CC2538\_RSSI\_OFFSET) & CC2538\_CCA\_THR\_MASK;
 return 0;}
static int \_config\_phy(ieee802154\_dev\_t \*dev, const ieee802154\_phy\_conf\_t \*conf){ (void) dev; int8\_t pow = conf->pow; if (pow < OUTPUT\_POWER\_MIN || pow > OUTPUT\_POWER\_MAX) { return -EINVAL; }
 uint8\_t channel = conf->channel; cc2538\_set\_freq(IEEE802154\_CHAN2FREQ(channel)); cc2538\_set\_tx\_power(pow);
 return 0;}
void cc2538\_irq\_handler(void){ uint\_fast8\_t flags\_f0 = RFCORE\_SFR\_RFIRQF0; uint\_fast8\_t flags\_f1 = RFCORE\_SFR\_RFIRQF1;
 uint8\_t handled\_f0 = 0; uint8\_t handled\_f1 = 0;
 assert(cc2538\_state != CC2538\_STATE\_TRX\_TRANSITION);
 if (flags\_f1 & TXDONE) { handled\_f1 |= TXDONE; /\* TXDONE marks the end of the TX chain. The radio is not busy anymore \*/ assert(cc2538\_state == CC2538\_STATE\_TX\_BUSY); cc2538\_state = CC2538\_STATE\_CONFIRM\_TX; cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_CONFIRM\_TX\_DONE); }
 /\* The RX chain is not busy anymore on TXACKDONE event \*/ if (flags\_f1 & TXACKDONE) { handled\_f1 |= TXACKDONE; assert(cc2538\_state == CC2538\_STATE\_TX\_ACK); cc2538\_state = CC2538\_STATE\_READY; }
 if ((flags\_f0 & SFD)) { handled\_f0 |= SFD; switch(cc2538\_state) { case CC2538\_STATE\_READY: cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_INDICATION\_RX\_START); break; case CC2538\_STATE\_TX\_BUSY: /\* If the radio already transmitted, this SFD is the TX\_START event \*/ cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_INDICATION\_TX\_START); break; case CC2538\_STATE\_TX\_ACK: /\* The detected SFD comes from the transmitted ACK frame. Simply \* ignore it \*/ break; default: /\* This should never happen \*/ DEBUG("ERROR: cc2538\_state: %i\n", cc2538\_state); assert(false); } }
 if (flags\_f0 & RXPKTDONE) { handled\_f0 |= RXPKTDONE; /\* CRC check \*/ uint8\_t pkt\_len = rfcore\_peek\_rx\_fifo(0); if (rfcore\_peek\_rx\_fifo(pkt\_len) & CC2538\_CRC\_BIT\_MASK) { /\* Disable RX while the frame has not been processed \*/ \_disable\_rx(); /\* If AUTOACK is disabled or the ACK request bit is not set \*/ if (IS\_ACTIVE(CONFIG\_IEEE802154\_AUTO\_ACK\_DISABLE) || (!(rfcore\_peek\_rx\_fifo(1) & IEEE802154\_FCF\_ACK\_REQ))) { /\* The radio won't send an ACK. Therefore the RX chain is not \* busy anymore \*/ cc2538\_state = CC2538\_STATE\_READY; } else { cc2538\_state = CC2538\_STATE\_TX\_ACK; } cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_INDICATION\_RX\_DONE); } else { /\* Disable RX while the frame has not been processed \*/ /\* CRC failed; discard packet. The RX chain is not busy anymore \*/ cc2538\_state = CC2538\_STATE\_READY; cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_INDICATION\_CRC\_ERROR); } }
 /\* Check if the interrupt was triggered because the CSP finished its routine \* (CSMA-CA or CCA request) \*/ if (flags\_f1 & CSP\_STOP) { handled\_f1 |= CSP\_STOP; RFCORE\_XREG\_CSPCTRL |= CC2538\_CSP\_MCU\_CTRL\_MASK; switch (cc2538\_state) { case CC2538\_STATE\_TX\_BUSY: if (RFCORE\_XREG\_CSPZ > 0) { RFCORE\_SFR\_RFST = ISTXON; } else { /\* In case of CCA failure the TX chain is not busy anymore \*/ cc2538\_state = CC2538\_STATE\_CONFIRM\_TX; cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_CONFIRM\_TX\_DONE); } break; case CC2538\_STATE\_CCA: cc2538\_cca\_status = BOOLEAN(RFCORE->XREG\_FSMSTAT1bits.CCA) && RFCORE->XREG\_RSSISTATbits.RSSI\_VALID; cc2538\_state = CC2538\_STATE\_CONFIRM\_CCA; cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_CONFIRM\_CCA); break; default: /\* This should never happen \*/ DEBUG("ERROR: cc2538\_state: %i\n", cc2538\_state); assert(false); break; } }
 RFCORE\_SFR\_RFIRQF0 &= ~handled\_f0; RFCORE\_SFR\_RFIRQF1 &= ~handled\_f1;}
static int \_off(ieee802154\_dev\_t \*dev){ (void) dev; return -ENOTSUP;}
static int \_config\_addr\_filter(ieee802154\_dev\_t \*dev, ieee802154\_af\_cmd\_t cmd, const void \*value){ (void) dev; const network\_uint16\_t \*short\_addr = value; const eui64\_t \*ext\_addr = value; const uint16\_t \*pan\_id = value; switch(cmd) { case IEEE802154\_AF\_SHORT\_ADDR: RFCORE\_FFSM\_SHORT\_ADDR0 = short\_addr->u8[1]; RFCORE\_FFSM\_SHORT\_ADDR1 = short\_addr->u8[0]; break; case IEEE802154\_AF\_EXT\_ADDR: RFCORE\_FFSM\_EXT\_ADDR0 = ext\_addr->uint8[7]; RFCORE\_FFSM\_EXT\_ADDR1 = ext\_addr->uint8[6]; RFCORE\_FFSM\_EXT\_ADDR2 = ext\_addr->uint8[5]; RFCORE\_FFSM\_EXT\_ADDR3 = ext\_addr->uint8[4]; RFCORE\_FFSM\_EXT\_ADDR4 = ext\_addr->uint8[3]; RFCORE\_FFSM\_EXT\_ADDR5 = ext\_addr->uint8[2]; RFCORE\_FFSM\_EXT\_ADDR6 = ext\_addr->uint8[1]; RFCORE\_FFSM\_EXT\_ADDR7 = ext\_addr->uint8[0]; break; case IEEE802154\_AF\_PANID: RFCORE\_FFSM\_PAN\_ID0 = \*pan\_id; RFCORE\_FFSM\_PAN\_ID1 = (\*pan\_id) >> 8; break; case IEEE802154\_AF\_PAN\_COORD: return -ENOTSUP; }
 return 0;}
static int \_config\_src\_addr\_match(ieee802154\_dev\_t \*dev, ieee802154\_src\_match\_t cmd, const void \*value){ (void) dev; switch(cmd) { case IEEE802154\_SRC\_MATCH\_EN: RFCORE\_XREG\_FRMCTRL1 &= ~CC2538\_FRMCTRL1\_PENDING\_OR\_MASK; if (\*((const bool\*) value) == true) { RFCORE\_XREG\_FRMCTRL1 |= CC2538\_FRMCTRL1\_PENDING\_OR\_MASK; } break; default: return -ENOTSUP; } return 0;}
static int \_confirm\_on(ieee802154\_dev\_t \*dev){ (void) dev; /\* TODO \*/ return 0;}
static int \_request\_on(ieee802154\_dev\_t \*dev){ (void) dev; /\* TODO \*/ return 0;}
static int \_set\_cca\_mode(ieee802154\_dev\_t \*dev, ieee802154\_cca\_mode\_t mode){ (void) dev; uint8\_t tmp = 0; switch (mode) { case IEEE802154\_CCA\_MODE\_ED\_THRESHOLD: tmp = 1; break; case IEEE802154\_CCA\_MODE\_CARRIER\_SENSING: tmp = 2; break; case IEEE802154\_CCA\_MODE\_ED\_THRESH\_AND\_CS: tmp = 3; break; case IEEE802154\_CCA\_MODE\_ED\_THRESH\_OR\_CS: return -ENOTSUP; }
 RFCORE\_XREG\_CCACTRL1 &= CC2538\_CCA\_MODE\_MASK; RFCORE\_XREG\_CCACTRL1 |= (tmp << CC2538\_CCA\_MODE\_POS);
 return 0;}
static int \_set\_csma\_params(ieee802154\_dev\_t \*dev, const ieee802154\_csma\_be\_t \*bd, int8\_t retries){ (void) dev; if (bd) { cc2538\_min\_be = bd->min; cc2538\_max\_be = bd->max; }
 cc2538\_csma\_ca\_retries = retries;
 return 0;}
static int \_set\_frame\_filter\_mode(ieee802154\_dev\_t \*dev, ieee802154\_filter\_mode\_t mode){ (void) dev;
 uint8\_t flags = 0; bool promisc = false; switch (mode) { case IEEE802154\_FILTER\_ACCEPT: flags = CC2538\_ACCEPT\_FT\_0\_BEACON | CC2538\_ACCEPT\_FT\_1\_DATA | CC2538\_ACCEPT\_FT\_3\_CMD; break; case IEEE802154\_FILTER\_PROMISC: promisc = true; break; case IEEE802154\_FILTER\_ACK\_ONLY: flags = CC2538\_ACCEPT\_FT\_2\_ACK; break; default: return -ENOTSUP; }
 RFCORE\_XREG\_FRMFILT1 |= flags; cc2538\_set\_monitor(promisc);
 return 0;
}
void cc2538\_rf\_hal\_setup(ieee802154\_dev\_t \*hal){ /\* We don't set hal->priv because the context of this device is global \*/ /\* We need to store a reference to the HAL descriptor though for the ISR \*/ hal->driver = &cc2538\_rf\_ops; cc2538\_rf\_hal = hal;}
static const ieee802154\_radio\_ops\_t cc2538\_rf\_ops = { .caps = IEEE802154\_CAP\_24\_GHZ | IEEE802154\_CAP\_AUTO\_CSMA | IEEE802154\_CAP\_IRQ\_CRC\_ERROR | IEEE802154\_CAP\_IRQ\_TX\_DONE | IEEE802154\_CAP\_IRQ\_CCA\_DONE | IEEE802154\_CAP\_IRQ\_RX\_START | IEEE802154\_CAP\_IRQ\_TX\_START | IEEE802154\_CAP\_PHY\_OQPSK,
 .write = \_write, .read = \_read, .len = \_len, .off = \_off, .request\_on = \_request\_on, .confirm\_on = \_confirm\_on, .request\_op = \_request\_op, .confirm\_op = \_confirm\_op, .set\_cca\_threshold = \_set\_cca\_threshold, .set\_cca\_mode = \_set\_cca\_mode, .config\_phy = \_config\_phy, .config\_addr\_filter = \_config\_addr\_filter, .config\_src\_addr\_match = \_config\_src\_addr\_match, .set\_csma\_params = \_set\_csma\_params, .set\_frame\_filter\_mode = \_set\_frame\_filter\_mode,};

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_55f6b1ef_20250114_205702.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2F1a418ccfedeb79dbce1d79f49e63a28906184794%2Fcpu%2Fcc2538%2Fradio%2Fcc2538_rf_radio_ops.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2F1a418ccfedeb79dbce1d79f49e63a28906184794%2Fcpu%2Fcc2538%2Fradio%2Fcc2538_rf_radio_ops.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  387](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

## Files

 1a418cc
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794)
2. /[cpu](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu)
3. /[cc2538](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538)
4. /[radio](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio)
/
# cc2538\_rf\_radio\_ops.c

Copy path Blame  Blame
## Latest commit

## History

[History](/RIOT-OS/RIOT/commits/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio/cc2538_rf_radio_ops.c)643 lines (556 loc) · 19.5 KB 1a418cc
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794)
2. /[cpu](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu)
3. /[cc2538](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538)
4. /[radio](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio)
/
# cc2538\_rf\_radio\_ops.c

Top
## File metadata and controls

* Code
* Blame

643 lines (556 loc) · 19.5 KB[Raw](https://github.com/RIOT-OS/RIOT/raw/1a418ccfedeb79dbce1d79f49e63a28906184794/cpu/cc2538/radio/cc2538_rf_radio_ops.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643/\* \* Copyright (C) 2020 HAW Hamburg \* \* This file is subject to the terms and conditions of the GNU Lesser \* General Public License v2.1. See the file LICENSE in the top level \* directory for more details. \* \*/
/\*\* \* @ingroup cpu\_cc2538 \* @{ \* \* @file \* @brief IEEE 802.15.4 Radio HAL implementation for the CC2538 RF driver \* \* @author José I. Alamos <jose.alamos@haw-hamburg.de> \* \* @} \*/
#include <assert.h>#include <errno.h>#include <stdio.h>
#include "net/gnrc.h"
#include "cc2538\_rf.h"#include "cc2538\_rf\_internal.h"
#include "net/ieee802154/radio.h"
#define ENABLE\_DEBUG 0#include "debug.h"
static const ieee802154\_radio\_ops\_t cc2538\_rf\_ops;
static ieee802154\_dev\_t \*cc2538\_rf\_hal;
typedef enum { CC2538\_STATE\_READY, /\*\*< The radio is ready to receive requests \*/ CC2538\_STATE\_TRX\_TRANSITION, /\*\*< There's a pending TRX state transition \*/ CC2538\_STATE\_CONFIRM\_TX, /\*\*< Transmission finished and waiting for confirm \*/ CC2538\_STATE\_TX\_BUSY, /\*\*< The radio is busy transmitting \*/ CC2538\_STATE\_TX\_ACK, /\*\*< The radio is currently transmitting an ACK frame \*/ CC2538\_STATE\_CCA, /\*\*< The radio is doing CCA \*/ CC2538\_STATE\_CONFIRM\_CCA, /\*\*< CCA finished and waiting for confirm \*/} cc2538\_state\_t;
static cc2538\_state\_t cc2538\_state;static uint8\_t cc2538\_min\_be = CONFIG\_IEEE802154\_DEFAULT\_CSMA\_CA\_MIN\_BE;static uint8\_t cc2538\_max\_be = CONFIG\_IEEE802154\_DEFAULT\_CSMA\_CA\_MAX\_BE;static int cc2538\_csma\_ca\_retries = CONFIG\_IEEE802154\_DEFAULT\_CSMA\_CA\_RETRIES;
static bool cc2538\_cca\_status; /\*\*< status of the last CCA request \*/
static void \_enable\_rx(void){ RFCORE\_XREG\_FRMCTRL0 &= ~CC2538\_FRMCTRL0\_RX\_MODE\_DIS;}
static void \_disable\_rx(void){ RFCORE\_XREG\_FRMCTRL0 |= CC2538\_FRMCTRL0\_RX\_MODE\_DIS;}
static int \_write(ieee802154\_dev\_t \*dev, const iolist\_t \*iolist){ (void) dev; int pkt\_len = 0; RFCORE\_SFR\_RFST = ISFLUSHTX; rfcore\_write\_byte(0);
 for (const iolist\_t \*iol = iolist; iol; iol = iol->iol\_next) { if (iol->iol\_len) { pkt\_len += iol->iol\_len; rfcore\_write\_fifo(iol->iol\_base, iol->iol\_len); } }
 /\* Set first byte of TX FIFO to the packet length \*/ rfcore\_poke\_tx\_fifo(0, pkt\_len + CC2538\_AUTOCRC\_LEN); return 0;}static int \_request\_op(ieee802154\_dev\_t \*dev, ieee802154\_hal\_op\_t op, void \*ctx){ (void) dev; int res = -EBUSY; cc2538\_rf\_disable\_irq(); switch (op) { case IEEE802154\_HAL\_OP\_TRANSMIT: assert(cc2538\_state != CC2538\_STATE\_TX\_BUSY); cc2538\_state = CC2538\_STATE\_TX\_BUSY; if (cc2538\_csma\_ca\_retries < 0) { RFCORE\_SFR\_RFST = ISTXON; /\* The CPU Ctrl mask is used here to indicate whether the radio is being \* controlled by the CPU or the CSP Strobe Processor. \* We set this to 1 in order to indicate that the CSP is not used and \* thus, that the @ref ieee802154\_radio\_confirm\_transmit should \* return 0 immediately after the TXDONE event \*/ RFCORE\_XREG\_CSPCTRL |= CC2538\_CSP\_MCU\_CTRL\_MASK; } else { /\* Disable RX Chain for CCA (see CC2538 RM, Section 29.9.5.3) \*/ \_disable\_rx(); RFCORE\_SFR\_RFST = ISRXON; /\* Clear last program \*/ RFCORE\_SFR\_RFST = ISCLEAR;
 /\* If the RSSI is not yet valid, skip 0 instructions. This creates \* a busy loop until the RSSI is valid. \*/ RFCORE\_SFR\_RFST = SKIP\_S\_C | CC2538\_CSP\_SKIP\_N\_MASK | CC2538\_CSP\_SKIP\_COND\_RSSI;
 /\* Set a label right before the backoff \*/ RFCORE\_SFR\_RFST = LABEL;
 /\* Load a random number with "register Y" LSBs into register X. \* This is equivalent to choosing a random number between \* (0, 2^(Y+1)). \* Then, wait "register X" number of backoff units \*/ RFCORE\_SFR\_RFST = RANDXY; RFCORE\_SFR\_RFST = WAITX;
 /\* If CCA is not valid, skip the next stop instruction. In such case \* the CSP\_STOP interrupt will trigger the transmission since the \* channel is clear \*/ RFCORE\_SFR\_RFST = SKIP\_S\_C | (1 << CC2538\_CSP\_SKIP\_INST\_POS) | CC2538\_CSP\_SKIP\_N\_MASK | CC2538\_CSP\_SKIP\_COND\_CCA;
 RFCORE\_SFR\_RFST = STOP;
 /\* If we are here, the channel was not clear. Decrement the register Z \* (remaining attempts) \*/ RFCORE\_SFR\_RFST = DECZ;
 /\* Update the backoff exponent \*/ RFCORE\_SFR\_RFST = INCMAXY | (cc2538\_max\_be & CC2538\_CSP\_INCMAXY\_MAX\_MASK);
 /\* If the are CSMA-CA retries left, go back to the defined label \*/ RFCORE\_SFR\_RFST = RPT\_C | CC2538\_CSP\_SKIP\_N\_MASK | CC2538\_CSP\_SKIP\_COND\_CSPZ;
 /\* Stop the program. The CSP\_STOP interrupt will trigger the routine \* to inform the upper layer that CSMA-CA failed. \*/ RFCORE\_SFR\_RFST = STOP;
 RFCORE\_XREG\_CSPX = 0; /\* Holds timer value \*/ RFCORE\_XREG\_CSPY = cc2538\_min\_be; /\* Holds MinBE \*/
 assert(cc2538\_csma\_ca\_retries >= 0); RFCORE\_XREG\_CSPZ = cc2538\_csma\_ca\_retries + 1; /\* Holds CSMA-CA attempts (retries + 1) \*/
 RFCORE\_XREG\_CSPCTRL &= ~CC2538\_CSP\_MCU\_CTRL\_MASK;
 /\* Execute the program \*/ RFCORE\_SFR\_RFST = ISSTART; } cc2538\_rf\_enable\_irq(); break; case IEEE802154\_HAL\_OP\_SET\_RX: if (cc2538\_state != CC2538\_STATE\_READY) { goto error; } cc2538\_state = CC2538\_STATE\_TRX\_TRANSITION; /\* Enable RX Chain \*/ \_enable\_rx(); RFCORE\_SFR\_RFST = ISRXON; RFCORE\_SFR\_RFIRQF0 &= ~RXPKTDONE; RFCORE\_SFR\_RFIRQF0 &= ~SFD; /\* We keep the interrupts disabled until the state transition is \* finished \*/ break; case IEEE802154\_HAL\_OP\_SET\_IDLE: { assert(ctx); bool force = \*((bool\*) ctx);
 if (!force && cc2538\_state != CC2538\_STATE\_READY) { goto error; }
 cc2538\_state = CC2538\_STATE\_TRX\_TRANSITION; if (RFCORE->XREG\_FSMSTAT0bits.FSM\_FFCTRL\_STATE != FSM\_STATE\_IDLE) { RFCORE\_SFR\_RFST = ISRFOFF; } RFCORE\_SFR\_RFIRQF0 &= ~RXPKTDONE; RFCORE\_SFR\_RFIRQF0 &= ~SFD; /\* We keep the interrupts disabled until the state transition is \* finished \*/ break; } case IEEE802154\_HAL\_OP\_CCA: /\* Ignore baseband processing \*/ \_disable\_rx(); RFCORE\_SFR\_RFIRQF0 &= ~RXPKTDONE; RFCORE\_SFR\_RFIRQF0 &= ~SFD; RFCORE\_SFR\_RFST = ISRXON; RFCORE\_SFR\_RFST = ISCLEAR; RFCORE\_SFR\_RFST = STOP; RFCORE\_XREG\_CSPCTRL &= ~CC2538\_CSP\_MCU\_CTRL\_MASK; /\* Execute the last program \*/ RFCORE\_SFR\_RFST = ISSTART; cc2538\_rf\_enable\_irq(); break; }
 res = 0; return res;
error: cc2538\_rf\_enable\_irq(); return res;}
static int \_confirm\_op(ieee802154\_dev\_t \*dev, ieee802154\_hal\_op\_t op, void \*ctx){ int res = -EAGAIN; (void) dev;
 switch (op) { case IEEE802154\_HAL\_OP\_TRANSMIT: cc2538\_rf\_disable\_irq(); if (cc2538\_state != CC2538\_STATE\_CONFIRM\_TX) { goto error; }
 if (ctx) { ieee802154\_tx\_info\_t \*info = ctx;
 if (cc2538\_csma\_ca\_retries >= 0 && RFCORE\_XREG\_CSPZ == 0) { info->status = TX\_STATUS\_MEDIUM\_BUSY; } else { info->status = TX\_STATUS\_SUCCESS; } } break; case IEEE802154\_HAL\_OP\_SET\_RX: case IEEE802154\_HAL\_OP\_SET\_IDLE: /\* IRQ is already disabled here \*/ assert(cc2538\_state == CC2538\_STATE\_TRX\_TRANSITION); break; case IEEE802154\_HAL\_OP\_CCA: assert(ctx); cc2538\_rf\_disable\_irq(); assert(cc2538\_state == CC2538\_STATE\_CCA || cc2538\_state == CC2538\_STATE\_CONFIRM\_CCA); if (cc2538\_state != CC2538\_STATE\_CONFIRM\_CCA) { goto error; }
 \_enable\_rx(); \*((bool\*) ctx) = cc2538\_cca\_status; break; }
 cc2538\_state = CC2538\_STATE\_READY; res = 0;
error: cc2538\_rf\_enable\_irq(); return res;
}
static int \_len(ieee802154\_dev\_t \*dev){ (void) dev; return rfcore\_peek\_rx\_fifo(0) - IEEE802154\_FCS\_LEN;}
static int \_read(ieee802154\_dev\_t \*dev, void \*buf, size\_t size, ieee802154\_rx\_info\_t \*info){ (void) dev; int res; size\_t pkt\_len;
 if (!buf) { res = 0; goto end; }
 /\* The upper layer shouldn't call this function if the RX\_DONE event was \* not triggered \*/ if (!(RFCORE\_XREG\_RXFIFOCNT > 0)) { assert(false); }
 pkt\_len = rfcore\_read\_byte() - IEEE802154\_FCS\_LEN; if (pkt\_len > size) { res = -ENOBUFS; goto end; }
 rfcore\_read\_fifo(buf, pkt\_len); res = pkt\_len; if (info != NULL) { uint8\_t corr\_val; int8\_t rssi\_val; rssi\_val = rfcore\_read\_byte();
 /\* The number of dB above maximum sensitivity detected for the \* received packet \*/ /\* Make sure there is no overflow even if no signal with such low sensitivity should be detected \*/ const int hw\_rssi\_min = IEEE802154\_RADIO\_RSSI\_OFFSET - CC2538\_RSSI\_OFFSET; int8\_t hw\_rssi = rssi\_val > hw\_rssi\_min ? (CC2538\_RSSI\_OFFSET + rssi\_val) : IEEE802154\_RADIO\_RSSI\_OFFSET; info->rssi = hw\_rssi - IEEE802154\_RADIO\_RSSI\_OFFSET;
 corr\_val = rfcore\_read\_byte() & CC2538\_CORR\_VAL\_MASK; if (corr\_val < CC2538\_CORR\_VAL\_MIN) { corr\_val = CC2538\_CORR\_VAL\_MIN; } else if (corr\_val > CC2538\_CORR\_VAL\_MAX) { corr\_val = CC2538\_CORR\_VAL\_MAX; }
 /\* Interpolate the correlation value between 0 - 255 \* to provide an LQI value \*/ info->lqi = 255 \* (corr\_val - CC2538\_CORR\_VAL\_MIN) / (CC2538\_CORR\_VAL\_MAX - CC2538\_CORR\_VAL\_MIN); }
end: /\* We don't need to enable RX chain here, since the upper layer already \* made sure the transceiver is in IDLE. We simply flush the RX buffer \*/ RFCORE\_SFR\_RFST = ISFLUSHRX; return res;}
static int \_set\_cca\_threshold(ieee802154\_dev\_t \*dev, int8\_t threshold){ (void) dev; (void) threshold;
 if (threshold < CC2538\_RF\_SENSITIVITY) { return -EINVAL; }
 RFCORE\_XREG\_CCACTRL0 &= ~CC2538\_CCA\_THR\_MASK; RFCORE\_XREG\_CCACTRL0 |= (threshold - CC2538\_RSSI\_OFFSET) & CC2538\_CCA\_THR\_MASK;
 return 0;}
static int \_config\_phy(ieee802154\_dev\_t \*dev, const ieee802154\_phy\_conf\_t \*conf){ (void) dev; int8\_t pow = conf->pow; if (pow < OUTPUT\_POWER\_MIN || pow > OUTPUT\_POWER\_MAX) { return -EINVAL; }
 uint8\_t channel = conf->channel; cc2538\_set\_freq(IEEE802154\_CHAN2FREQ(channel)); cc2538\_set\_tx\_power(pow);
 return 0;}
void cc2538\_irq\_handler(void){ uint\_fast8\_t flags\_f0 = RFCORE\_SFR\_RFIRQF0; uint\_fast8\_t flags\_f1 = RFCORE\_SFR\_RFIRQF1;
 uint8\_t handled\_f0 = 0; uint8\_t handled\_f1 = 0;
 assert(cc2538\_state != CC2538\_STATE\_TRX\_TRANSITION);
 if (flags\_f1 & TXDONE) { handled\_f1 |= TXDONE; /\* TXDONE marks the end of the TX chain. The radio is not busy anymore \*/ assert(cc2538\_state == CC2538\_STATE\_TX\_BUSY); cc2538\_state = CC2538\_STATE\_CONFIRM\_TX; cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_CONFIRM\_TX\_DONE); }
 /\* The RX chain is not busy anymore on TXACKDONE event \*/ if (flags\_f1 & TXACKDONE) { handled\_f1 |= TXACKDONE; assert(cc2538\_state == CC2538\_STATE\_TX\_ACK); cc2538\_state = CC2538\_STATE\_READY; }
 if ((flags\_f0 & SFD)) { handled\_f0 |= SFD; switch(cc2538\_state) { case CC2538\_STATE\_READY: cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_INDICATION\_RX\_START); break; case CC2538\_STATE\_TX\_BUSY: /\* If the radio already transmitted, this SFD is the TX\_START event \*/ cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_INDICATION\_TX\_START); break; case CC2538\_STATE\_TX\_ACK: /\* The detected SFD comes from the transmitted ACK frame. Simply \* ignore it \*/ break; default: /\* This should never happen \*/ DEBUG("ERROR: cc2538\_state: %i\n", cc2538\_state); assert(false); } }
 if (flags\_f0 & RXPKTDONE) { handled\_f0 |= RXPKTDONE; /\* CRC check \*/ uint8\_t pkt\_len = rfcore\_peek\_rx\_fifo(0); if (rfcore\_peek\_rx\_fifo(pkt\_len) & CC2538\_CRC\_BIT\_MASK) { /\* Disable RX while the frame has not been processed \*/ \_disable\_rx(); /\* If AUTOACK is disabled or the ACK request bit is not set \*/ if (IS\_ACTIVE(CONFIG\_IEEE802154\_AUTO\_ACK\_DISABLE) || (!(rfcore\_peek\_rx\_fifo(1) & IEEE802154\_FCF\_ACK\_REQ))) { /\* The radio won't send an ACK. Therefore the RX chain is not \* busy anymore \*/ cc2538\_state = CC2538\_STATE\_READY; } else { cc2538\_state = CC2538\_STATE\_TX\_ACK; } cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_INDICATION\_RX\_DONE); } else { /\* Disable RX while the frame has not been processed \*/ /\* CRC failed; discard packet. The RX chain is not busy anymore \*/ cc2538\_state = CC2538\_STATE\_READY; cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_INDICATION\_CRC\_ERROR); } }
 /\* Check if the interrupt was triggered because the CSP finished its routine \* (CSMA-CA or CCA request) \*/ if (flags\_f1 & CSP\_STOP) { handled\_f1 |= CSP\_STOP; RFCORE\_XREG\_CSPCTRL |= CC2538\_CSP\_MCU\_CTRL\_MASK; switch (cc2538\_state) { case CC2538\_STATE\_TX\_BUSY: if (RFCORE\_XREG\_CSPZ > 0) { RFCORE\_SFR\_RFST = ISTXON; } else { /\* In case of CCA failure the TX chain is not busy anymore \*/ cc2538\_state = CC2538\_STATE\_CONFIRM\_TX; cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_CONFIRM\_TX\_DONE); } break; case CC2538\_STATE\_CCA: cc2538\_cca\_status = BOOLEAN(RFCORE->XREG\_FSMSTAT1bits.CCA) && RFCORE->XREG\_RSSISTATbits.RSSI\_VALID; cc2538\_state = CC2538\_STATE\_CONFIRM\_CCA; cc2538\_rf\_hal->cb(cc2538\_rf\_hal, IEEE802154\_RADIO\_CONFIRM\_CCA); break; default: /\* This should never happen \*/ DEBUG("ERROR: cc2538\_state: %i\n", cc2538\_state); assert(false); break; } }
 RFCORE\_SFR\_RFIRQF0 &= ~handled\_f0; RFCORE\_SFR\_RFIRQF1 &= ~handled\_f1;}
static int \_off(ieee802154\_dev\_t \*dev){ (void) dev; return -ENOTSUP;}
static int \_config\_addr\_filter(ieee802154\_dev\_t \*dev, ieee802154\_af\_cmd\_t cmd, const void \*value){ (void) dev; const network\_uint16\_t \*short\_addr = value; const eui64\_t \*ext\_addr = value; const uint16\_t \*pan\_id = value; switch(cmd) { case IEEE802154\_AF\_SHORT\_ADDR: RFCORE\_FFSM\_SHORT\_ADDR0 = short\_addr->u8[1]; RFCORE\_FFSM\_SHORT\_ADDR1 = short\_addr->u8[0]; break; case IEEE802154\_AF\_EXT\_ADDR: RFCORE\_FFSM\_EXT\_ADDR0 = ext\_addr->uint8[7]; RFCORE\_FFSM\_EXT\_ADDR1 = ext\_addr->uint8[6]; RFCORE\_FFSM\_EXT\_ADDR2 = ext\_addr->uint8[5]; RFCORE\_FFSM\_EXT\_ADDR3 = ext\_addr->uint8[4]; RFCORE\_FFSM\_EXT\_ADDR4 = ext\_addr->uint8[3]; RFCORE\_FFSM\_EXT\_ADDR5 = ext\_addr->uint8[2]; RFCORE\_FFSM\_EXT\_ADDR6 = ext\_addr->uint8[1]; RFCORE\_FFSM\_EXT\_ADDR7 = ext\_addr->uint8[0]; break; case IEEE802154\_AF\_PANID: RFCORE\_FFSM\_PAN\_ID0 = \*pan\_id; RFCORE\_FFSM\_PAN\_ID1 = (\*pan\_id) >> 8; break; case IEEE802154\_AF\_PAN\_COORD: return -ENOTSUP; }
 return 0;}
static int \_config\_src\_addr\_match(ieee802154\_dev\_t \*dev, ieee802154\_src\_match\_t cmd, const void \*value){ (void) dev; switch(cmd) { case IEEE802154\_SRC\_MATCH\_EN: RFCORE\_XREG\_FRMCTRL1 &= ~CC2538\_FRMCTRL1\_PENDING\_OR\_MASK; if (\*((const bool\*) value) == true) { RFCORE\_XREG\_FRMCTRL1 |= CC2538\_FRMCTRL1\_PENDING\_OR\_MASK; } break; default: return -ENOTSUP; } return 0;}
static int \_confirm\_on(ieee802154\_dev\_t \*dev){ (void) dev; /\* TODO \*/ return 0;}
static int \_request\_on(ieee802154\_dev\_t \*dev){ (void) dev; /\* TODO \*/ return 0;}
static int \_set\_cca\_mode(ieee802154\_dev\_t \*dev, ieee802154\_cca\_mode\_t mode){ (void) dev; uint8\_t tmp = 0; switch (mode) { case IEEE802154\_CCA\_MODE\_ED\_THRESHOLD: tmp = 1; break; case IEEE802154\_CCA\_MODE\_CARRIER\_SENSING: tmp = 2; break; case IEEE802154\_CCA\_MODE\_ED\_THRESH\_AND\_CS: tmp = 3; break; case IEEE802154\_CCA\_MODE\_ED\_THRESH\_OR\_CS: return -ENOTSUP; }
 RFCORE\_XREG\_CCACTRL1 &= CC2538\_CCA\_MODE\_MASK; RFCORE\_XREG\_CCACTRL1 |= (tmp << CC2538\_CCA\_MODE\_POS);
 return 0;}
static int \_set\_csma\_params(ieee802154\_dev\_t \*dev, const ieee802154\_csma\_be\_t \*bd, int8\_t retries){ (void) dev; if (bd) { cc2538\_min\_be = bd->min; cc2538\_max\_be = bd->max; }
 cc2538\_csma\_ca\_retries = retries;
 return 0;}
static int \_set\_frame\_filter\_mode(ieee802154\_dev\_t \*dev, ieee802154\_filter\_mode\_t mode){ (void) dev;
 uint8\_t flags = 0; bool promisc = false; switch (mode) { case IEEE802154\_FILTER\_ACCEPT: flags = CC2538\_ACCEPT\_FT\_0\_BEACON | CC2538\_ACCEPT\_FT\_1\_DATA | CC2538\_ACCEPT\_FT\_3\_CMD; break; case IEEE802154\_FILTER\_PROMISC: promisc = true; break; case IEEE802154\_FILTER\_ACK\_ONLY: flags = CC2538\_ACCEPT\_FT\_2\_ACK; break; default: return -ENOTSUP; }
 RFCORE\_XREG\_FRMFILT1 |= flags; cc2538\_set\_monitor(promisc);
 return 0;
}
void cc2538\_rf\_hal\_setup(ieee802154\_dev\_t \*hal){ /\* We don't set hal->priv because the context of this device is global \*/ /\* We need to store a reference to the HAL descriptor though for the ISR \*/ hal->driver = &cc2538\_rf\_ops; cc2538\_rf\_hal = hal;}
static const ieee802154\_radio\_ops\_t cc2538\_rf\_ops = { .caps = IEEE802154\_CAP\_24\_GHZ | IEEE802154\_CAP\_AUTO\_CSMA | IEEE802154\_CAP\_IRQ\_CRC\_ERROR | IEEE802154\_CAP\_IRQ\_TX\_DONE | IEEE802154\_CAP\_IRQ\_CCA\_DONE | IEEE802154\_CAP\_IRQ\_RX\_START | IEEE802154\_CAP\_IRQ\_TX\_START | IEEE802154\_CAP\_PHY\_OQPSK,
 .write = \_write, .read = \_read, .len = \_len, .off = \_off, .request\_on = \_request\_on, .confirm\_on = \_confirm\_on, .request\_op = \_request\_op, .confirm\_op = \_confirm\_op, .set\_cca\_threshold = \_set\_cca\_threshold, .set\_cca\_mode = \_set\_cca\_mode, .config\_phy = \_config\_phy, .config\_addr\_filter = \_config\_addr\_filter, .config\_src\_addr\_match = \_config\_src\_addr\_match, .set\_csma\_params = \_set\_csma\_params, .set\_frame\_filter\_mode = \_set\_frame\_filter\_mode,};

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_5c5a939a_20250114_205708.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2F1a418ccfedeb79dbce1d79f49e63a28906184794%2Fsys%2Fnet%2Flink_layer%2Fieee802154%2Fsubmac.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2F1a418ccfedeb79dbce1d79f49e63a28906184794%2Fsys%2Fnet%2Flink_layer%2Fieee802154%2Fsubmac.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  387](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

## Files

 1a418cc
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794)
2. /[sys](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/sys)
3. /[net](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/sys/net)
4. /[link\_layer](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/sys/net/link_layer)
5. /[ieee802154](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/sys/net/link_layer/ieee802154)
/
# submac.c

Copy path Blame  Blame
## Latest commit

## History

[History](/RIOT-OS/RIOT/commits/1a418ccfedeb79dbce1d79f49e63a28906184794/sys/net/link_layer/ieee802154/submac.c)609 lines (519 loc) · 18.8 KB 1a418cc
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794)
2. /[sys](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/sys)
3. /[net](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/sys/net)
4. /[link\_layer](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/sys/net/link_layer)
5. /[ieee802154](/RIOT-OS/RIOT/tree/1a418ccfedeb79dbce1d79f49e63a28906184794/sys/net/link_layer/ieee802154)
/
# submac.c

Top
## File metadata and controls

* Code
* Blame

609 lines (519 loc) · 18.8 KB[Raw](https://github.com/RIOT-OS/RIOT/raw/1a418ccfedeb79dbce1d79f49e63a28906184794/sys/net/link_layer/ieee802154/submac.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609/\* \* Copyright (C) 2020 HAW Hamburg \* \* This file is subject to the terms and conditions of the GNU Lesser \* General Public License v2.1. See the file LICENSE in the top level \* directory for more details. \*/
/\*\* \* @{ \* \* @file \* @author José I. Alamos <jose.alamos@haw-hamburg.de> \*/
#include <assert.h>#include <stdio.h>#include <string.h>#include "net/ieee802154/submac.h"#include "net/ieee802154.h"#include "ztimer.h"#include "random.h"#include "luid.h"#include "kernel\_defines.h"#include "errno.h"
#define ENABLE\_DEBUG 0#include "debug.h"
#define CSMA\_SENDER\_BACKOFF\_PERIOD\_UNIT\_US (320U)#define ACK\_TIMEOUT\_US (864U)
static char \*str\_states[IEEE802154\_FSM\_STATE\_NUMOF] = { "INVALID", "RX", "IDLE", "PREPARE", "TX", "WAIT\_FOR\_ACK",};
static char \*str\_ev[IEEE802154\_FSM\_EV\_NUMOF] = { "TX\_DONE", "RX\_DONE", "CRC\_ERROR", "ACK\_TIMEOUT", "BH", "REQUEST\_TX", "REQUEST\_SET\_RX\_ON", "REQUEST\_SET\_IDLE",};
static inline bool \_does\_handle\_ack(ieee802154\_dev\_t \*dev){ return ieee802154\_radio\_has\_frame\_retrans(dev) || ieee802154\_radio\_has\_irq\_ack\_timeout(dev);}
static inline bool \_does\_handle\_csma(ieee802154\_dev\_t \*dev){ return ieee802154\_radio\_has\_frame\_retrans(dev) || ieee802154\_radio\_has\_auto\_csma(dev);}
static bool \_has\_retrans\_left(ieee802154\_submac\_t \*submac){ return submac->retrans < CONFIG\_IEEE802154\_DEFAULT\_MAX\_FRAME\_RETRANS;}
static ieee802154\_fsm\_state\_t \_tx\_end(ieee802154\_submac\_t \*submac, int status, ieee802154\_tx\_info\_t \*info){ int res;
 /\* This is required to prevent unused variable warnings \*/ (void) res;
 submac->wait\_for\_ack = false;
 res = ieee802154\_radio\_set\_idle(&submac->dev, true);
 assert(res >= 0); submac->cb->tx\_done(submac, status, info); return IEEE802154\_FSM\_STATE\_IDLE;}
static void \_print\_debug(ieee802154\_fsm\_state\_t old, ieee802154\_fsm\_state\_t new, ieee802154\_fsm\_ev\_t ev){ DEBUG("%s--(%s)->%s\n", str\_states[old], str\_ev[ev], str\_states[new]);}
static ieee802154\_fsm\_state\_t \_handle\_tx\_no\_ack(ieee802154\_submac\_t \*submac){ int res;
 /\* This is required to prevent unused variable warnings \*/ (void) res;
 /\* In case of ACK Timeout, either trigger retransmissions or end \* the TX procedure \*/ if (\_has\_retrans\_left(submac)) { submac->retrans++; res = ieee802154\_radio\_set\_idle(&submac->dev, true); assert(res >= 0); ieee802154\_submac\_bh\_request(submac); return IEEE802154\_FSM\_STATE\_PREPARE; } else { ieee802154\_radio\_set\_frame\_filter\_mode(&submac->dev, IEEE802154\_FILTER\_ACCEPT); return \_tx\_end(submac, TX\_STATUS\_NO\_ACK, NULL); }}
static int \_handle\_fsm\_ev\_request\_tx(ieee802154\_submac\_t \*submac){ ieee802154\_dev\_t \*dev = &submac->dev;
 /\* Set state to TX\_ON \*/ int res = ieee802154\_radio\_set\_idle(dev, false);
 if (res < 0) { return res; } else { /\* write frame to radio \*/ ieee802154\_radio\_write(dev, submac->psdu); ieee802154\_submac\_bh\_request(submac); return 0; }}
static ieee802154\_fsm\_state\_t \_fsm\_state\_rx(ieee802154\_submac\_t \*submac, ieee802154\_fsm\_ev\_t ev){ ieee802154\_dev\_t \*dev = &submac->dev; int res;
 /\* This is required to prevent unused variable warnings \*/ (void) res;
 switch (ev) { case IEEE802154\_FSM\_EV\_REQUEST\_TX: if (\_handle\_fsm\_ev\_request\_tx(submac) < 0) { return IEEE802154\_FSM\_STATE\_RX; } return IEEE802154\_FSM\_STATE\_PREPARE; case IEEE802154\_FSM\_EV\_RX\_DONE: /\* Make sure it's not an ACK frame \*/ while (ieee802154\_radio\_set\_idle(&submac->dev, false) < 0) {} if (ieee802154\_radio\_len(&submac->dev) > (int)IEEE802154\_MIN\_FRAME\_LEN) { submac->cb->rx\_done(submac); return IEEE802154\_FSM\_STATE\_IDLE; } else { ieee802154\_radio\_read(&submac->dev, NULL, 0, NULL);
 /\* If the radio doesn't support RX Continuous, go to RX \*/ res = ieee802154\_radio\_set\_rx(&submac->dev); assert(res >= 0);
 /\* Keep on current state \*/ return IEEE802154\_FSM\_STATE\_RX; } case IEEE802154\_FSM\_EV\_CRC\_ERROR: while (ieee802154\_radio\_set\_idle(&submac->dev, false) < 0) {} ieee802154\_radio\_read(&submac->dev, NULL, 0, NULL); /\* If the radio doesn't support RX Continuous, go to RX \*/ res = ieee802154\_radio\_set\_rx(&submac->dev); assert(res >= 0); /\* Keep on current state \*/ return IEEE802154\_FSM\_STATE\_RX;
 case IEEE802154\_FSM\_EV\_REQUEST\_SET\_IDLE: /\* Try to turn off the transceiver \*/ if ((ieee802154\_radio\_request\_set\_idle(dev, false)) < 0) { /\* Keep on current state \*/ return IEEE802154\_FSM\_STATE\_RX; } while (ieee802154\_radio\_confirm\_set\_idle(dev) == -EAGAIN) {} return IEEE802154\_FSM\_STATE\_IDLE;
 default: break; }
 return IEEE802154\_FSM\_STATE\_INVALID;}
static ieee802154\_fsm\_state\_t \_fsm\_state\_idle(ieee802154\_submac\_t \*submac, ieee802154\_fsm\_ev\_t ev){ ieee802154\_dev\_t \*dev = &submac->dev;
 switch (ev) { case IEEE802154\_FSM\_EV\_REQUEST\_TX: if (\_handle\_fsm\_ev\_request\_tx(submac) < 0) { return IEEE802154\_FSM\_STATE\_IDLE; } return IEEE802154\_FSM\_STATE\_PREPARE; case IEEE802154\_FSM\_EV\_REQUEST\_SET\_RX\_ON: /\* Try to go turn on the transceiver \*/ if ((ieee802154\_radio\_set\_rx(dev) < 0)) { /\* Keep on current state \*/ return IEEE802154\_FSM\_STATE\_IDLE; } return IEEE802154\_FSM\_STATE\_RX; case IEEE802154\_FSM\_EV\_RX\_DONE: case IEEE802154\_FSM\_EV\_CRC\_ERROR: /\* This might happen in case there's a race condition between ACK\_TIMEOUT \* and TX\_DONE. We simply discard the frame and keep the state as \* it is \*/ ieee802154\_radio\_read(&submac->dev, NULL, 0, NULL); return IEEE802154\_FSM\_STATE\_IDLE; default: break; } return IEEE802154\_FSM\_STATE\_INVALID;}
static ieee802154\_fsm\_state\_t \_fsm\_state\_prepare(ieee802154\_submac\_t \*submac, ieee802154\_fsm\_ev\_t ev){ ieee802154\_dev\_t \*dev = &submac->dev;
 switch (ev) { case IEEE802154\_FSM\_EV\_BH: if (!\_does\_handle\_csma(dev)) { /\* delay for an adequate random backoff period \*/ uint32\_t bp = (random\_uint32() & submac->backoff\_mask) \* CSMA\_SENDER\_BACKOFF\_PERIOD\_UNIT\_US;
 ztimer\_sleep(ZTIMER\_USEC, bp); /\* Prepare for next iteration \*/ uint8\_t curr\_be = (submac->backoff\_mask + 1) >> 1; if (curr\_be < submac->be.max) { submac->backoff\_mask = (submac->backoff\_mask << 1) | 1; } }
 while (ieee802154\_radio\_request\_transmit(dev) == -EBUSY) {} return IEEE802154\_FSM\_STATE\_TX; case IEEE802154\_FSM\_EV\_RX\_DONE: case IEEE802154\_FSM\_EV\_CRC\_ERROR: /\* This might happen in case there's a race condition between ACK\_TIMEOUT \* and TX\_DONE. We simply discard the frame and keep the state as \* it is \*/ ieee802154\_radio\_read(&submac->dev, NULL, 0, NULL); return IEEE802154\_FSM\_STATE\_PREPARE; default: break; }
 return IEEE802154\_FSM\_STATE\_INVALID;}
static ieee802154\_fsm\_state\_t \_fsm\_state\_tx\_process\_tx\_done(ieee802154\_submac\_t \*submac, ieee802154\_tx\_info\_t \*info){ ieee802154\_dev\_t \*dev = &submac->dev; int res;
 /\* This is required to prevent unused variable warnings \*/ (void) res;
 switch (info->status) { case TX\_STATUS\_FRAME\_PENDING: assert(\_does\_handle\_ack(&submac->dev)); /\* FALL-THRU \*/ case TX\_STATUS\_SUCCESS: submac->csma\_retries\_nb = 0; /\* If the radio handles ACK, the TX\_DONE event marks completion of \* the transmission procedure. Report TX done to the upper layer \*/ if (\_does\_handle\_ack(&submac->dev) || !submac->wait\_for\_ack) { return \_tx\_end(submac, info->status, info); } /\* If the radio doesn't handle ACK, set the transceiver state to RX\_ON \* and enable the ACK filter \*/ else { ieee802154\_radio\_set\_frame\_filter\_mode(dev, IEEE802154\_FILTER\_ACK\_ONLY); res = ieee802154\_radio\_set\_rx(dev); assert (res >= 0);
 /\* Handle ACK reception \*/ ieee802154\_submac\_ack\_timer\_set(submac, ACK\_TIMEOUT\_US); return IEEE802154\_FSM\_STATE\_WAIT\_FOR\_ACK; } break; case TX\_STATUS\_NO\_ACK: assert(\_does\_handle\_ack(&submac->dev)); submac->csma\_retries\_nb = 0; return \_handle\_tx\_no\_ack(submac); case TX\_STATUS\_MEDIUM\_BUSY: /\* If radio has retransmissions or CSMA-CA, this means the CSMA-CA \* procedure failed. We finish the SubMAC operation and report \* medium busy \*/ if (\_does\_handle\_csma(&submac->dev) || submac->csma\_retries\_nb++ >= submac->csma\_retries) { return \_tx\_end(submac, info->status, info); } /\* Otherwise, this is a failed CCA attempt. Proceed with CSMA-CA \*/ else { /\* The HAL should guarantee that's still possible to transmit \* in the current state, since the radio is still in TX\_ON. \* Therefore, this is valid \*/ ieee802154\_submac\_bh\_request(submac); return IEEE802154\_FSM\_STATE\_PREPARE; } } return IEEE802154\_FSM\_STATE\_INVALID;}
static ieee802154\_fsm\_state\_t \_fsm\_state\_tx(ieee802154\_submac\_t \*submac, ieee802154\_fsm\_ev\_t ev){ ieee802154\_tx\_info\_t info; int res;
 /\* This is required to prevent unused variable warnings \*/ (void) res;
 switch (ev) { case IEEE802154\_FSM\_EV\_TX\_DONE: res = ieee802154\_radio\_confirm\_transmit(&submac->dev, &info); assert(res >= 0); return \_fsm\_state\_tx\_process\_tx\_done(submac, &info); case IEEE802154\_FSM\_EV\_RX\_DONE: case IEEE802154\_FSM\_EV\_CRC\_ERROR: /\* This might happen in case there's a race condition between ACK\_TIMEOUT \* and TX\_DONE. We simply discard the frame and keep the state as \* it is \*/ ieee802154\_radio\_read(&submac->dev, NULL, 0, NULL); return IEEE802154\_FSM\_STATE\_TX; default: break; }
 return IEEE802154\_FSM\_STATE\_INVALID;}
static ieee802154\_fsm\_state\_t \_fsm\_state\_wait\_for\_ack(ieee802154\_submac\_t \*submac, ieee802154\_fsm\_ev\_t ev){ uint8\_t ack[3];
 switch (ev) { case IEEE802154\_FSM\_EV\_RX\_DONE: assert(!ieee802154\_radio\_has\_irq\_ack\_timeout(&submac->dev)); if (ieee802154\_radio\_read(&submac->dev, ack, 3, NULL) && ack[0] & IEEE802154\_FCF\_TYPE\_ACK) { ieee802154\_submac\_ack\_timer\_cancel(submac); ieee802154\_tx\_info\_t tx\_info; tx\_info.retrans = submac->retrans; bool fp = (ack[0] & IEEE802154\_FCF\_FRAME\_PEND); ieee802154\_radio\_set\_frame\_filter\_mode(&submac->dev, IEEE802154\_FILTER\_ACCEPT); return \_tx\_end(submac, fp ? TX\_STATUS\_FRAME\_PENDING : TX\_STATUS\_SUCCESS, &tx\_info); } return IEEE802154\_FSM\_STATE\_WAIT\_FOR\_ACK; case IEEE802154\_FSM\_EV\_CRC\_ERROR: /\* Received invalid ACK. Drop frame \*/ ieee802154\_radio\_read(&submac->dev, NULL, 0, NULL); return IEEE802154\_FSM\_STATE\_WAIT\_FOR\_ACK; case IEEE802154\_FSM\_EV\_ACK\_TIMEOUT: return \_handle\_tx\_no\_ack(submac); default: break; } return IEEE802154\_FSM\_STATE\_INVALID;}
ieee802154\_fsm\_state\_t ieee802154\_submac\_process\_ev(ieee802154\_submac\_t \*submac, ieee802154\_fsm\_ev\_t ev){ ieee802154\_fsm\_state\_t new\_state;
 switch (submac->fsm\_state) { case IEEE802154\_FSM\_STATE\_RX: new\_state = \_fsm\_state\_rx(submac, ev); break; case IEEE802154\_FSM\_STATE\_IDLE: new\_state = \_fsm\_state\_idle(submac, ev); break; case IEEE802154\_FSM\_STATE\_PREPARE: new\_state = \_fsm\_state\_prepare(submac, ev); break; case IEEE802154\_FSM\_STATE\_TX: new\_state = \_fsm\_state\_tx(submac, ev); break; case IEEE802154\_FSM\_STATE\_WAIT\_FOR\_ACK: new\_state = \_fsm\_state\_wait\_for\_ack(submac, ev); break; default: new\_state = IEEE802154\_FSM\_STATE\_INVALID; }
 if (new\_state == IEEE802154\_FSM\_STATE\_INVALID) { \_print\_debug(submac->fsm\_state, new\_state, ev); assert(false); } submac->fsm\_state = new\_state; return submac->fsm\_state;}
int ieee802154\_send(ieee802154\_submac\_t \*submac, const iolist\_t \*iolist){ ieee802154\_fsm\_state\_t current\_state = submac->fsm\_state;
 if (current\_state != IEEE802154\_FSM\_STATE\_RX && current\_state != IEEE802154\_FSM\_STATE\_IDLE) { return -EBUSY; }
 if (iolist == NULL) { return 0; }
 uint8\_t \*buf = iolist->iol\_base; bool cnf = buf[0] & IEEE802154\_FCF\_ACK\_REQ;
 submac->wait\_for\_ack = cnf; submac->psdu = iolist; submac->retrans = 0; submac->csma\_retries\_nb = 0; submac->backoff\_mask = (1 << submac->be.min) - 1;
 if (ieee802154\_submac\_process\_ev(submac, IEEE802154\_FSM\_EV\_REQUEST\_TX) != IEEE802154\_FSM\_STATE\_PREPARE) { return -EBUSY; } return 0;}
int ieee802154\_submac\_init(ieee802154\_submac\_t \*submac, const network\_uint16\_t \*short\_addr, const eui64\_t \*ext\_addr){ ieee802154\_dev\_t \*dev = &submac->dev;
 submac->fsm\_state = IEEE802154\_FSM\_STATE\_RX;
 int res;
 if ((res = ieee802154\_radio\_request\_on(dev)) < 0) { return res; }
 /\* generate EUI-64 and short address \*/ memcpy(&submac->ext\_addr, ext\_addr, sizeof(eui64\_t)); memcpy(&submac->short\_addr, short\_addr, sizeof(network\_uint16\_t)); submac->panid = CONFIG\_IEEE802154\_DEFAULT\_PANID;
 submac->be.min = CONFIG\_IEEE802154\_DEFAULT\_CSMA\_CA\_MIN\_BE; submac->csma\_retries = CONFIG\_IEEE802154\_DEFAULT\_CSMA\_CA\_RETRIES; submac->be.max = CONFIG\_IEEE802154\_DEFAULT\_CSMA\_CA\_MAX\_BE;
 submac->tx\_pow = CONFIG\_IEEE802154\_DEFAULT\_TXPOWER;
 if (ieee802154\_radio\_has\_24\_ghz(dev)) { submac->channel\_num = CONFIG\_IEEE802154\_DEFAULT\_CHANNEL;
 /\* 2.4 GHz only use page 0 \*/ submac->channel\_page = 0; } else { submac->channel\_num = CONFIG\_IEEE802154\_DEFAULT\_SUBGHZ\_CHANNEL; submac->channel\_page = CONFIG\_IEEE802154\_DEFAULT\_SUBGHZ\_PAGE; }
 /\* Get supported PHY modes \*/ int supported\_phy\_modes = ieee802154\_radio\_get\_phy\_modes(dev);
 assert(supported\_phy\_modes != 0);
 uint32\_t default\_phy\_cap = ieee802154\_phy\_mode\_to\_cap(CONFIG\_IEEE802154\_DEFAULT\_PHY\_MODE);
 /\* Check if configuration provides valid PHY \*/ if (CONFIG\_IEEE802154\_DEFAULT\_PHY\_MODE != IEEE802154\_PHY\_DISABLED && (supported\_phy\_modes & default\_phy\_cap)) { /\* Check if default PHY is supported \*/ submac->phy\_mode = CONFIG\_IEEE802154\_DEFAULT\_PHY\_MODE; } else { /\* Get first set bit, and use it as the default, \* \* by this order, the priority is defined on the ieee802154\_rf\_caps\_t \* definition, first IEEE 802.15.4-2006 PHY modes, then \* IEEE 802.15.4g-2012 PHY modes. \*/ unsigned bit = bitarithm\_lsb(supported\_phy\_modes);
 submac->phy\_mode = ieee802154\_cap\_to\_phy\_mode(1 << bit); }
 /\* If the radio is still not in TRX\_OFF state, spin \*/ while (ieee802154\_radio\_confirm\_on(dev) == -EAGAIN) {}
 /\* Configure address filter \*/ ieee802154\_radio\_config\_addr\_filter(dev, IEEE802154\_AF\_SHORT\_ADDR, &submac->short\_addr); ieee802154\_radio\_config\_addr\_filter(dev, IEEE802154\_AF\_EXT\_ADDR, &submac->ext\_addr); ieee802154\_radio\_config\_addr\_filter(dev, IEEE802154\_AF\_PANID, &submac->panid);
 /\* Configure PHY settings (mode, channel, TX power) \*/ ieee802154\_phy\_conf\_t conf = { .phy\_mode = submac->phy\_mode, .channel = submac->channel\_num, .page = submac->channel\_page, .pow = submac->tx\_pow };
 ieee802154\_radio\_config\_phy(dev, &conf); ieee802154\_radio\_set\_cca\_threshold(dev, CONFIG\_IEEE802154\_CCA\_THRESH\_DEFAULT); assert(res >= 0);
 while (ieee802154\_radio\_set\_rx(dev) < 0) {}
 return res;}
int ieee802154\_set\_phy\_conf(ieee802154\_submac\_t \*submac, uint16\_t channel\_num, uint8\_t channel\_page, int8\_t tx\_pow){ ieee802154\_dev\_t \*dev = &submac->dev; const ieee802154\_phy\_conf\_t conf = { .phy\_mode = submac->phy\_mode, .channel = channel\_num, .page = channel\_page, .pow = tx\_pow }; int res; ieee802154\_fsm\_state\_t current\_state = submac->fsm\_state;
 /\* Changing state can be only performed on IDLE or RX state \*/ if (current\_state != IEEE802154\_FSM\_STATE\_RX && current\_state != IEEE802154\_FSM\_STATE\_IDLE) { return -EBUSY; }
 /\* If the radio is listening, turn it off first \*/ if (current\_state == IEEE802154\_FSM\_STATE\_RX) { if ((res = ieee802154\_radio\_request\_set\_idle(dev, false)) < 0) { return res; } }
 res = ieee802154\_radio\_config\_phy(dev, &conf);
 if (res >= 0) { submac->channel\_num = channel\_num; submac->channel\_page = channel\_page; submac->tx\_pow = tx\_pow; } while (ieee802154\_radio\_confirm\_set\_idle(dev) == -EAGAIN) {}
 /\* Go back to RX if needed \*/ if (current\_state == IEEE802154\_FSM\_STATE\_RX) { res = ieee802154\_radio\_set\_rx(dev); assert (res >= 0); }
 return res;}
int ieee802154\_set\_rx(ieee802154\_submac\_t \*submac){ ieee802154\_fsm\_state\_t current\_state = submac->fsm\_state; ieee802154\_fsm\_state\_t next\_state; int res = -EBUSY;
 switch (current\_state) { case IEEE802154\_FSM\_STATE\_RX: res = -EALREADY; break; case IEEE802154\_FSM\_STATE\_IDLE: next\_state = ieee802154\_submac\_process\_ev(submac, IEEE802154\_FSM\_EV\_REQUEST\_SET\_RX\_ON); if (next\_state == IEEE802154\_FSM\_STATE\_RX) { res = 0; } break; default: break; }
 return res;}
int ieee802154\_set\_idle(ieee802154\_submac\_t \*submac){ ieee802154\_fsm\_state\_t current\_state = submac->fsm\_state; ieee802154\_fsm\_state\_t next\_state; int res = -EBUSY;
 switch (current\_state) { case IEEE802154\_FSM\_STATE\_IDLE: res = -EALREADY; break; case IEEE802154\_FSM\_STATE\_RX: next\_state = ieee802154\_submac\_process\_ev(submac, IEEE802154\_FSM\_EV\_REQUEST\_SET\_IDLE); if (next\_state == IEEE802154\_FSM\_STATE\_IDLE) { res = 0; } break; default: break; }
 return res;
}
/\*\* @} \*/

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


