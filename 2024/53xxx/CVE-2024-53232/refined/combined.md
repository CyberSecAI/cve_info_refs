=== Content from git.kernel.org_ac24b3e8_20250114_202732.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Matthew Rosato <mjrosato@linux.ibm.com> | 2024-09-10 17:15:16 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-05 14:02:03 +0100 |
| commit | [bd89d94f3ea6fdaee983cbc69226a00b9bde6d59](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59)) | |
| tree | [1def926aa7feceff84933a3abb7f2e882c7260f0](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59) | |
| parent | [89dc91e58e44ec2764149e1be10a4fa29c857f43](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=89dc91e58e44ec2764149e1be10a4fa29c857f43) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59&id2=89dc91e58e44ec2764149e1be10a4fa29c857f43)) | |
| download | [linux-bd89d94f3ea6fdaee983cbc69226a00b9bde6d59.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-bd89d94f3ea6fdaee983cbc69226a00b9bde6d59.tar.gz) | |

iommu/s390: Implement blocking domain[ Upstream commit ecda483339a5151e3ca30d6b82691ef6f1d17912 ]
This fixes a crash when surprise hot-unplugging a PCI device. This crash
happens because during hot-unplug \_\_iommu\_group\_set\_domain\_nofail()
attaching the default domain fails when the platform no longer
recognizes the device as it has already been removed and we end up with
a NULL domain pointer and UAF. This is exactly the case referred to in
the second comment in \_\_iommu\_device\_set\_domain() and just as stated
there if we can instead attach the blocking domain the UAF is prevented
as this can handle the already removed device. Implement the blocking
domain to use this handling. With this change, the crash is fixed but
we still hit a warning attempting to change DMA ownership on a blocked
device.
Fixes: c76c067e488c ("s390/pci: Use dma-iommu layer")
Co-developed-by: Niklas Schnelle <schnelle@linux.ibm.com>
Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
Signed-off-by: Matthew Rosato <mjrosato@linux.ibm.com>
Reviewed-by: Niklas Schnelle <schnelle@linux.ibm.com>
Reviewed-by: Jason Gunthorpe <jgg@nvidia.com>
Link: [https://lore.kernel.org/r/20240910211516.137933-1-mjrosato@linux.ibm.com](https://lore.kernel.org/r/20240910211516.137933-1-mjrosato%40linux.ibm.com)
Signed-off-by: Joerg Roedel <jroedel@suse.de>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59)

| -rw-r--r-- | [arch/s390/include/asm/pci.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/s390/include/asm/pci.h?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59) | 4 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [arch/s390/pci/pci.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/s390/pci/pci.c?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/s390/pci/pci\_debug.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/s390/pci/pci_debug.c?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/iommu/s390-iommu.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/iommu/s390-iommu.c?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59) | 73 | |  |  |  | | --- | --- | --- | |

4 files changed, 59 insertions, 31 deletions

| diff --git a/arch/s390/include/asm/pci.h b/arch/s390/include/asm/pci.hindex 9d920ced604754..30b20ce9a70033 100644--- a/[arch/s390/include/asm/pci.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/include/asm/pci.h?id=89dc91e58e44ec2764149e1be10a4fa29c857f43)+++ b/[arch/s390/include/asm/pci.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/include/asm/pci.h?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59)@@ -96,7 +96,6 @@ struct zpci\_bar\_struct { u8 size; /\* order 2 exponent \*/ }; -struct s390\_domain; struct kvm\_zdev;  #define ZPCI\_FUNCTIONS\_PER\_BUS 256@@ -181,9 +180,10 @@ struct zpci\_dev { struct dentry \*debugfs\_dev;  /\* IOMMU and passthrough \*/- struct s390\_domain \*s390\_domain; /\* s390 IOMMU domain data \*/+ struct iommu\_domain \*s390\_domain; /\* attached IOMMU domain \*/ struct kvm\_zdev \*kzdev; struct mutex kzdev\_lock;+ spinlock\_t dom\_lock; /\* protect s390\_domain change \*/ };  static inline bool zdev\_enabled(struct zpci\_dev \*zdev)diff --git a/arch/s390/pci/pci.c b/arch/s390/pci/pci.cindex bd9624c20b8020..be3299609f9b65 100644--- a/[arch/s390/pci/pci.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/pci/pci.c?id=89dc91e58e44ec2764149e1be10a4fa29c857f43)+++ b/[arch/s390/pci/pci.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/pci/pci.c?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59)@@ -160,6 +160,7 @@ int zpci\_fmb\_enable\_device(struct zpci\_dev \*zdev) u64 req = ZPCI\_CREATE\_REQ(zdev->fh, 0, ZPCI\_MOD\_FC\_SET\_MEASURE); struct zpci\_iommu\_ctrs \*ctrs; struct zpci\_fib fib = {0};+ unsigned long flags; u8 cc, status;  if (zdev->fmb || sizeof(\*zdev->fmb) < zdev->fmb\_length)@@ -171,6 +172,7 @@ int zpci\_fmb\_enable\_device(struct zpci\_dev \*zdev) WARN\_ON((u64) zdev->fmb & 0xf);  /\* reset software counters \*/+ spin\_lock\_irqsave(&zdev->dom\_lock, flags); ctrs = zpci\_get\_iommu\_ctrs(zdev); if (ctrs) { atomic64\_set(&ctrs->mapped\_pages, 0);@@ -179,6 +181,7 @@ int zpci\_fmb\_enable\_device(struct zpci\_dev \*zdev) atomic64\_set(&ctrs->sync\_map\_rpcits, 0); atomic64\_set(&ctrs->sync\_rpcits, 0); }+ spin\_unlock\_irqrestore(&zdev->dom\_lock, flags);   fib.fmb\_addr = virt\_to\_phys(zdev->fmb);diff --git a/arch/s390/pci/pci\_debug.c b/arch/s390/pci/pci\_debug.cindex 2cb5043a997d53..38014206c16b96 100644--- a/[arch/s390/pci/pci\_debug.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/pci/pci_debug.c?id=89dc91e58e44ec2764149e1be10a4fa29c857f43)+++ b/[arch/s390/pci/pci\_debug.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/pci/pci_debug.c?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59)@@ -71,17 +71,23 @@ static void pci\_fmb\_show(struct seq\_file \*m, char \*name[], int length,  static void pci\_sw\_counter\_show(struct seq\_file \*m) {- struct zpci\_iommu\_ctrs \*ctrs = zpci\_get\_iommu\_ctrs(m->private);+ struct zpci\_dev \*zdev = m->private;+ struct zpci\_iommu\_ctrs \*ctrs; atomic64\_t \*counter;+ unsigned long flags; int i; + spin\_lock\_irqsave(&zdev->dom\_lock, flags);+ ctrs = zpci\_get\_iommu\_ctrs(m->private); if (!ctrs)- return;+ goto unlock;  counter = &ctrs->mapped\_pages; for (i = 0; i < ARRAY\_SIZE(pci\_sw\_names); i++, counter++) seq\_printf(m, "%26s:\t%llu\n", pci\_sw\_names[i], atomic64\_read(counter));+unlock:+ spin\_unlock\_irqrestore(&zdev->dom\_lock, flags); }  static int pci\_perf\_show(struct seq\_file \*m, void \*v)diff --git a/drivers/iommu/s390-iommu.c b/drivers/iommu/s390-iommu.cindex d8eaa7ea380bb0..fbdeded3d48b59 100644--- a/[drivers/iommu/s390-iommu.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/iommu/s390-iommu.c?id=89dc91e58e44ec2764149e1be10a4fa29c857f43)+++ b/[drivers/iommu/s390-iommu.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/iommu/s390-iommu.c?id=bd89d94f3ea6fdaee983cbc69226a00b9bde6d59)@@ -33,6 +33,8 @@ struct s390\_domain { struct rcu\_head rcu; }; +static struct iommu\_domain blocking\_domain;+ static inline unsigned int calc\_rtx(dma\_addr\_t ptr) { return ((unsigned long)ptr >> ZPCI\_RT\_SHIFT) & ZPCI\_INDEX\_MASK;@@ -369,20 +371,36 @@ static void s390\_domain\_free(struct iommu\_domain \*domain) call\_rcu(&s390\_domain->rcu, s390\_iommu\_rcu\_free\_domain); } -static void s390\_iommu\_detach\_device(struct iommu\_domain \*domain,- struct device \*dev)+static void zdev\_s390\_domain\_update(struct zpci\_dev \*zdev,+ struct iommu\_domain \*domain)+{+ unsigned long flags;++ spin\_lock\_irqsave(&zdev->dom\_lock, flags);+ zdev->s390\_domain = domain;+ spin\_unlock\_irqrestore(&zdev->dom\_lock, flags);+}++static int blocking\_domain\_attach\_device(struct iommu\_domain \*domain,+ struct device \*dev) {- struct s390\_domain \*s390\_domain = to\_s390\_domain(domain); struct zpci\_dev \*zdev = to\_zpci\_dev(dev);+ struct s390\_domain \*s390\_domain; unsigned long flags; + if (zdev->s390\_domain->type == IOMMU\_DOMAIN\_BLOCKED)+ return 0;++ s390\_domain = to\_s390\_domain(zdev->s390\_domain); spin\_lock\_irqsave(&s390\_domain->list\_lock, flags); list\_del\_rcu(&zdev->iommu\_list); spin\_unlock\_irqrestore(&s390\_domain->list\_lock, flags);  zpci\_unregister\_ioat(zdev, 0);- zdev->s390\_domain = NULL; zdev->dma\_table = NULL;+ zdev\_s390\_domain\_update(zdev, domain);++ return 0; }  static int s390\_iommu\_attach\_device(struct iommu\_domain \*domain,@@ -401,20 +419,15 @@ static int s390\_iommu\_attach\_device(struct iommu\_domain \*domain, domain->geometry.aperture\_end < zdev->start\_dma)) return -EINVAL; - if (zdev->s390\_domain)- s390\_iommu\_detach\_device(&zdev->s390\_domain->domain, dev);+ blocking\_domain\_attach\_device(&blocking\_domain, dev); + /\* If we fail now DMA remains blocked via blocking domain \*/ cc = zpci\_register\_ioat(zdev, 0, zdev->start\_dma, zdev->end\_dma, virt\_to\_phys(s390\_domain->dma\_table), &status);- /\*- \* If the device is undergoing error recovery the reset code- \* will re-establish the new domain.- \*/ if (cc && status != ZPCI\_PCI\_ST\_FUNC\_NOT\_AVAIL) return -EIO;- zdev->dma\_table = s390\_domain->dma\_table;- zdev->s390\_domain = s390\_domain;+ zdev\_s390\_domain\_update(zdev, domain);  spin\_lock\_irqsave(&s390\_domain->list\_lock, flags); list\_add\_rcu(&zdev->iommu\_list, &s390\_domain->devices);@@ -466,19 +479,11 @@ static struct iommu\_device \*s390\_iommu\_probe\_device(struct device \*dev) if (zdev->tlb\_refresh) dev->iommu->shadow\_on\_flush = 1; - return &zdev->iommu\_dev;-}+ /\* Start with DMA blocked \*/+ spin\_lock\_init(&zdev->dom\_lock);+ zdev\_s390\_domain\_update(zdev, &blocking\_domain); -static void s390\_iommu\_release\_device(struct device \*dev)-{- struct zpci\_dev \*zdev = to\_zpci\_dev(dev);-- /\*- \* release\_device is expected to detach any domain currently attached- \* to the device, but keep it attached to other devices in the group.- \*/- if (zdev)- s390\_iommu\_detach\_device(&zdev->s390\_domain->domain, dev);+ return &zdev->iommu\_dev; }  static int zpci\_refresh\_all(struct zpci\_dev \*zdev)@@ -697,9 +702,15 @@ static size\_t s390\_iommu\_unmap\_pages(struct iommu\_domain \*domain,  struct zpci\_iommu\_ctrs \*zpci\_get\_iommu\_ctrs(struct zpci\_dev \*zdev) {- if (!zdev || !zdev->s390\_domain)+ struct s390\_domain \*s390\_domain;++ lockdep\_assert\_held(&zdev->dom\_lock);++ if (zdev->s390\_domain->type == IOMMU\_DOMAIN\_BLOCKED) return NULL;- return &zdev->s390\_domain->ctrs;++ s390\_domain = to\_s390\_domain(zdev->s390\_domain);+ return &s390\_domain->ctrs; }  int zpci\_init\_iommu(struct zpci\_dev \*zdev)@@ -776,11 +787,19 @@ static int \_\_init s390\_iommu\_init(void) } subsys\_initcall(s390\_iommu\_init); +static struct iommu\_domain blocking\_domain = {+ .type = IOMMU\_DOMAIN\_BLOCKED,+ .ops = &(const struct iommu\_domain\_ops) {+ .attach\_dev = blocking\_domain\_attach\_device,+ }+};+ static const struct iommu\_ops s390\_iommu\_ops = {+ .blocked\_domain = &blocking\_domain,+ .release\_domain = &blocking\_domain, .capable = s390\_iommu\_capable, .domain\_alloc\_paging = s390\_domain\_alloc\_paging, .probe\_device = s390\_iommu\_probe\_device,- .release\_device = s390\_iommu\_release\_device, .device\_group = generic\_device\_group, .pgsize\_bitmap = SZ\_4K, .get\_resv\_regions = s390\_iommu\_get\_resv\_regions, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:26:09 +0000



=== Content from git.kernel.org_2480c50a_20250114_202731.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Matthew Rosato <mjrosato@linux.ibm.com> | 2024-09-10 17:15:16 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-05 13:53:30 +0100 |
| commit | [3be34fa1cdbf180c1a948cfededfdf2cdc497199](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199)) | |
| tree | [4b73c1b6968552dfea35601f8e0f6f6eb0ff7091](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199) | |
| parent | [e9ac61ab1da2e0f7b1b5ad4dc334569a2db98447](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e9ac61ab1da2e0f7b1b5ad4dc334569a2db98447) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199&id2=e9ac61ab1da2e0f7b1b5ad4dc334569a2db98447)) | |
| download | [linux-3be34fa1cdbf180c1a948cfededfdf2cdc497199.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-3be34fa1cdbf180c1a948cfededfdf2cdc497199.tar.gz) | |

iommu/s390: Implement blocking domain[ Upstream commit ecda483339a5151e3ca30d6b82691ef6f1d17912 ]
This fixes a crash when surprise hot-unplugging a PCI device. This crash
happens because during hot-unplug \_\_iommu\_group\_set\_domain\_nofail()
attaching the default domain fails when the platform no longer
recognizes the device as it has already been removed and we end up with
a NULL domain pointer and UAF. This is exactly the case referred to in
the second comment in \_\_iommu\_device\_set\_domain() and just as stated
there if we can instead attach the blocking domain the UAF is prevented
as this can handle the already removed device. Implement the blocking
domain to use this handling. With this change, the crash is fixed but
we still hit a warning attempting to change DMA ownership on a blocked
device.
Fixes: c76c067e488c ("s390/pci: Use dma-iommu layer")
Co-developed-by: Niklas Schnelle <schnelle@linux.ibm.com>
Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
Signed-off-by: Matthew Rosato <mjrosato@linux.ibm.com>
Reviewed-by: Niklas Schnelle <schnelle@linux.ibm.com>
Reviewed-by: Jason Gunthorpe <jgg@nvidia.com>
Link: [https://lore.kernel.org/r/20240910211516.137933-1-mjrosato@linux.ibm.com](https://lore.kernel.org/r/20240910211516.137933-1-mjrosato%40linux.ibm.com)
Signed-off-by: Joerg Roedel <jroedel@suse.de>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199)

| -rw-r--r-- | [arch/s390/include/asm/pci.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/s390/include/asm/pci.h?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199) | 4 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [arch/s390/pci/pci.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/s390/pci/pci.c?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/s390/pci/pci\_debug.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/s390/pci/pci_debug.c?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/iommu/s390-iommu.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/iommu/s390-iommu.c?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199) | 73 | |  |  |  | | --- | --- | --- | |

4 files changed, 59 insertions, 31 deletions

| diff --git a/arch/s390/include/asm/pci.h b/arch/s390/include/asm/pci.hindex 30820a649e6e7c..a60a291fbd58d7 100644--- a/[arch/s390/include/asm/pci.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/include/asm/pci.h?id=e9ac61ab1da2e0f7b1b5ad4dc334569a2db98447)+++ b/[arch/s390/include/asm/pci.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/include/asm/pci.h?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199)@@ -96,7 +96,6 @@ struct zpci\_bar\_struct { u8 size; /\* order 2 exponent \*/ }; -struct s390\_domain; struct kvm\_zdev;  #define ZPCI\_FUNCTIONS\_PER\_BUS 256@@ -181,9 +180,10 @@ struct zpci\_dev { struct dentry \*debugfs\_dev;  /\* IOMMU and passthrough \*/- struct s390\_domain \*s390\_domain; /\* s390 IOMMU domain data \*/+ struct iommu\_domain \*s390\_domain; /\* attached IOMMU domain \*/ struct kvm\_zdev \*kzdev; struct mutex kzdev\_lock;+ spinlock\_t dom\_lock; /\* protect s390\_domain change \*/ };  static inline bool zdev\_enabled(struct zpci\_dev \*zdev)diff --git a/arch/s390/pci/pci.c b/arch/s390/pci/pci.cindex cff4838fad2166..759983d0e63ed0 100644--- a/[arch/s390/pci/pci.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/pci/pci.c?id=e9ac61ab1da2e0f7b1b5ad4dc334569a2db98447)+++ b/[arch/s390/pci/pci.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/pci/pci.c?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199)@@ -160,6 +160,7 @@ int zpci\_fmb\_enable\_device(struct zpci\_dev \*zdev) u64 req = ZPCI\_CREATE\_REQ(zdev->fh, 0, ZPCI\_MOD\_FC\_SET\_MEASURE); struct zpci\_iommu\_ctrs \*ctrs; struct zpci\_fib fib = {0};+ unsigned long flags; u8 cc, status;  if (zdev->fmb || sizeof(\*zdev->fmb) < zdev->fmb\_length)@@ -171,6 +172,7 @@ int zpci\_fmb\_enable\_device(struct zpci\_dev \*zdev) WARN\_ON((u64) zdev->fmb & 0xf);  /\* reset software counters \*/+ spin\_lock\_irqsave(&zdev->dom\_lock, flags); ctrs = zpci\_get\_iommu\_ctrs(zdev); if (ctrs) { atomic64\_set(&ctrs->mapped\_pages, 0);@@ -179,6 +181,7 @@ int zpci\_fmb\_enable\_device(struct zpci\_dev \*zdev) atomic64\_set(&ctrs->sync\_map\_rpcits, 0); atomic64\_set(&ctrs->sync\_rpcits, 0); }+ spin\_unlock\_irqrestore(&zdev->dom\_lock, flags);   fib.fmb\_addr = virt\_to\_phys(zdev->fmb);diff --git a/arch/s390/pci/pci\_debug.c b/arch/s390/pci/pci\_debug.cindex 2cb5043a997d53..38014206c16b96 100644--- a/[arch/s390/pci/pci\_debug.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/pci/pci_debug.c?id=e9ac61ab1da2e0f7b1b5ad4dc334569a2db98447)+++ b/[arch/s390/pci/pci\_debug.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/pci/pci_debug.c?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199)@@ -71,17 +71,23 @@ static void pci\_fmb\_show(struct seq\_file \*m, char \*name[], int length,  static void pci\_sw\_counter\_show(struct seq\_file \*m) {- struct zpci\_iommu\_ctrs \*ctrs = zpci\_get\_iommu\_ctrs(m->private);+ struct zpci\_dev \*zdev = m->private;+ struct zpci\_iommu\_ctrs \*ctrs; atomic64\_t \*counter;+ unsigned long flags; int i; + spin\_lock\_irqsave(&zdev->dom\_lock, flags);+ ctrs = zpci\_get\_iommu\_ctrs(m->private); if (!ctrs)- return;+ goto unlock;  counter = &ctrs->mapped\_pages; for (i = 0; i < ARRAY\_SIZE(pci\_sw\_names); i++, counter++) seq\_printf(m, "%26s:\t%llu\n", pci\_sw\_names[i], atomic64\_read(counter));+unlock:+ spin\_unlock\_irqrestore(&zdev->dom\_lock, flags); }  static int pci\_perf\_show(struct seq\_file \*m, void \*v)diff --git a/drivers/iommu/s390-iommu.c b/drivers/iommu/s390-iommu.cindex d8eaa7ea380bb0..fbdeded3d48b59 100644--- a/[drivers/iommu/s390-iommu.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/iommu/s390-iommu.c?id=e9ac61ab1da2e0f7b1b5ad4dc334569a2db98447)+++ b/[drivers/iommu/s390-iommu.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/iommu/s390-iommu.c?id=3be34fa1cdbf180c1a948cfededfdf2cdc497199)@@ -33,6 +33,8 @@ struct s390\_domain { struct rcu\_head rcu; }; +static struct iommu\_domain blocking\_domain;+ static inline unsigned int calc\_rtx(dma\_addr\_t ptr) { return ((unsigned long)ptr >> ZPCI\_RT\_SHIFT) & ZPCI\_INDEX\_MASK;@@ -369,20 +371,36 @@ static void s390\_domain\_free(struct iommu\_domain \*domain) call\_rcu(&s390\_domain->rcu, s390\_iommu\_rcu\_free\_domain); } -static void s390\_iommu\_detach\_device(struct iommu\_domain \*domain,- struct device \*dev)+static void zdev\_s390\_domain\_update(struct zpci\_dev \*zdev,+ struct iommu\_domain \*domain)+{+ unsigned long flags;++ spin\_lock\_irqsave(&zdev->dom\_lock, flags);+ zdev->s390\_domain = domain;+ spin\_unlock\_irqrestore(&zdev->dom\_lock, flags);+}++static int blocking\_domain\_attach\_device(struct iommu\_domain \*domain,+ struct device \*dev) {- struct s390\_domain \*s390\_domain = to\_s390\_domain(domain); struct zpci\_dev \*zdev = to\_zpci\_dev(dev);+ struct s390\_domain \*s390\_domain; unsigned long flags; + if (zdev->s390\_domain->type == IOMMU\_DOMAIN\_BLOCKED)+ return 0;++ s390\_domain = to\_s390\_domain(zdev->s390\_domain); spin\_lock\_irqsave(&s390\_domain->list\_lock, flags); list\_del\_rcu(&zdev->iommu\_list); spin\_unlock\_irqrestore(&s390\_domain->list\_lock, flags);  zpci\_unregister\_ioat(zdev, 0);- zdev->s390\_domain = NULL; zdev->dma\_table = NULL;+ zdev\_s390\_domain\_update(zdev, domain);++ return 0; }  static int s390\_iommu\_attach\_device(struct iommu\_domain \*domain,@@ -401,20 +419,15 @@ static int s390\_iommu\_attach\_device(struct iommu\_domain \*domain, domain->geometry.aperture\_end < zdev->start\_dma)) return -EINVAL; - if (zdev->s390\_domain)- s390\_iommu\_detach\_device(&zdev->s390\_domain->domain, dev);+ blocking\_domain\_attach\_device(&blocking\_domain, dev); + /\* If we fail now DMA remains blocked via blocking domain \*/ cc = zpci\_register\_ioat(zdev, 0, zdev->start\_dma, zdev->end\_dma, virt\_to\_phys(s390\_domain->dma\_table), &status);- /\*- \* If the device is undergoing error recovery the reset code- \* will re-establish the new domain.- \*/ if (cc && status != ZPCI\_PCI\_ST\_FUNC\_NOT\_AVAIL) return -EIO;- zdev->dma\_table = s390\_domain->dma\_table;- zdev->s390\_domain = s390\_domain;+ zdev\_s390\_domain\_update(zdev, domain);  spin\_lock\_irqsave(&s390\_domain->list\_lock, flags); list\_add\_rcu(&zdev->iommu\_list, &s390\_domain->devices);@@ -466,19 +479,11 @@ static struct iommu\_device \*s390\_iommu\_probe\_device(struct device \*dev) if (zdev->tlb\_refresh) dev->iommu->shadow\_on\_flush = 1; - return &zdev->iommu\_dev;-}+ /\* Start with DMA blocked \*/+ spin\_lock\_init(&zdev->dom\_lock);+ zdev\_s390\_domain\_update(zdev, &blocking\_domain); -static void s390\_iommu\_release\_device(struct device \*dev)-{- struct zpci\_dev \*zdev = to\_zpci\_dev(dev);-- /\*- \* release\_device is expected to detach any domain currently attached- \* to the device, but keep it attached to other devices in the group.- \*/- if (zdev)- s390\_iommu\_detach\_device(&zdev->s390\_domain->domain, dev);+ return &zdev->iommu\_dev; }  static int zpci\_refresh\_all(struct zpci\_dev \*zdev)@@ -697,9 +702,15 @@ static size\_t s390\_iommu\_unmap\_pages(struct iommu\_domain \*domain,  struct zpci\_iommu\_ctrs \*zpci\_get\_iommu\_ctrs(struct zpci\_dev \*zdev) {- if (!zdev || !zdev->s390\_domain)+ struct s390\_domain \*s390\_domain;++ lockdep\_assert\_held(&zdev->dom\_lock);++ if (zdev->s390\_domain->type == IOMMU\_DOMAIN\_BLOCKED) return NULL;- return &zdev->s390\_domain->ctrs;++ s390\_domain = to\_s390\_domain(zdev->s390\_domain);+ return &s390\_domain->ctrs; }  int zpci\_init\_iommu(struct zpci\_dev \*zdev)@@ -776,11 +787,19 @@ static int \_\_init s390\_iommu\_init(void) } subsys\_initcall(s390\_iommu\_init); +static struct iommu\_domain blocking\_domain = {+ .type = IOMMU\_DOMAIN\_BLOCKED,+ .ops = &(const struct iommu\_domain\_ops) {+ .attach\_dev = blocking\_domain\_attach\_device,+ }+};+ static const struct iommu\_ops s390\_iommu\_ops = {+ .blocked\_domain = &blocking\_domain,+ .release\_domain = &blocking\_domain, .capable = s390\_iommu\_capable, .domain\_alloc\_paging = s390\_domain\_alloc\_paging, .probe\_device = s390\_iommu\_probe\_device,- .release\_device = s390\_iommu\_release\_device, .device\_group = generic\_device\_group, .pgsize\_bitmap = SZ\_4K, .get\_resv\_regions = s390\_iommu\_get\_resv\_regions, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:26:09 +0000



=== Content from git.kernel.org_d461937b_20250114_202733.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=ecda483339a5151e3ca30d6b82691ef6f1d17912)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ecda483339a5151e3ca30d6b82691ef6f1d17912)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ecda483339a5151e3ca30d6b82691ef6f1d17912)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ecda483339a5151e3ca30d6b82691ef6f1d17912)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Matthew Rosato <mjrosato@linux.ibm.com> | 2024-09-10 17:15:16 -0400 |
| --- | --- | --- |
| committer | Joerg Roedel <jroedel@suse.de> | 2024-10-15 10:19:07 +0200 |
| commit | [ecda483339a5151e3ca30d6b82691ef6f1d17912](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ecda483339a5151e3ca30d6b82691ef6f1d17912) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=ecda483339a5151e3ca30d6b82691ef6f1d17912)) | |
| tree | [77b0c4355a13b87d7b9dab0a8984e4f71952121e](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ecda483339a5151e3ca30d6b82691ef6f1d17912) | |
| parent | [8e929cb546ee42c9a61d24fae60605e9e3192354](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8e929cb546ee42c9a61d24fae60605e9e3192354) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ecda483339a5151e3ca30d6b82691ef6f1d17912&id2=8e929cb546ee42c9a61d24fae60605e9e3192354)) | |
| download | [linux-ecda483339a5151e3ca30d6b82691ef6f1d17912.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-ecda483339a5151e3ca30d6b82691ef6f1d17912.tar.gz) | |

iommu/s390: Implement blocking domainThis fixes a crash when surprise hot-unplugging a PCI device. This crash
happens because during hot-unplug \_\_iommu\_group\_set\_domain\_nofail()
attaching the default domain fails when the platform no longer
recognizes the device as it has already been removed and we end up with
a NULL domain pointer and UAF. This is exactly the case referred to in
the second comment in \_\_iommu\_device\_set\_domain() and just as stated
there if we can instead attach the blocking domain the UAF is prevented
as this can handle the already removed device. Implement the blocking
domain to use this handling. With this change, the crash is fixed but
we still hit a warning attempting to change DMA ownership on a blocked
device.
Fixes: c76c067e488c ("s390/pci: Use dma-iommu layer")
Co-developed-by: Niklas Schnelle <schnelle@linux.ibm.com>
Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
Signed-off-by: Matthew Rosato <mjrosato@linux.ibm.com>
Reviewed-by: Niklas Schnelle <schnelle@linux.ibm.com>
Reviewed-by: Jason Gunthorpe <jgg@nvidia.com>
Link: [https://lore.kernel.org/r/20240910211516.137933-1-mjrosato@linux.ibm.com](https://lore.kernel.org/r/20240910211516.137933-1-mjrosato%40linux.ibm.com)
Signed-off-by: Joerg Roedel <jroedel@suse.de>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ecda483339a5151e3ca30d6b82691ef6f1d17912)

| -rw-r--r-- | [arch/s390/include/asm/pci.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/s390/include/asm/pci.h?id=ecda483339a5151e3ca30d6b82691ef6f1d17912) | 4 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [arch/s390/pci/pci.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/s390/pci/pci.c?id=ecda483339a5151e3ca30d6b82691ef6f1d17912) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/s390/pci/pci\_debug.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/s390/pci/pci_debug.c?id=ecda483339a5151e3ca30d6b82691ef6f1d17912) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/iommu/s390-iommu.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/iommu/s390-iommu.c?id=ecda483339a5151e3ca30d6b82691ef6f1d17912) | 73 | |  |  |  | | --- | --- | --- | |

4 files changed, 59 insertions, 31 deletions

| diff --git a/arch/s390/include/asm/pci.h b/arch/s390/include/asm/pci.hindex 9d920ced604754..30b20ce9a70033 100644--- a/[arch/s390/include/asm/pci.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/include/asm/pci.h?id=8e929cb546ee42c9a61d24fae60605e9e3192354)+++ b/[arch/s390/include/asm/pci.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/include/asm/pci.h?id=ecda483339a5151e3ca30d6b82691ef6f1d17912)@@ -96,7 +96,6 @@ struct zpci\_bar\_struct { u8 size; /\* order 2 exponent \*/ }; -struct s390\_domain; struct kvm\_zdev;  #define ZPCI\_FUNCTIONS\_PER\_BUS 256@@ -181,9 +180,10 @@ struct zpci\_dev { struct dentry \*debugfs\_dev;  /\* IOMMU and passthrough \*/- struct s390\_domain \*s390\_domain; /\* s390 IOMMU domain data \*/+ struct iommu\_domain \*s390\_domain; /\* attached IOMMU domain \*/ struct kvm\_zdev \*kzdev; struct mutex kzdev\_lock;+ spinlock\_t dom\_lock; /\* protect s390\_domain change \*/ };  static inline bool zdev\_enabled(struct zpci\_dev \*zdev)diff --git a/arch/s390/pci/pci.c b/arch/s390/pci/pci.cindex bd9624c20b8020..be3299609f9b65 100644--- a/[arch/s390/pci/pci.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/pci/pci.c?id=8e929cb546ee42c9a61d24fae60605e9e3192354)+++ b/[arch/s390/pci/pci.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/pci/pci.c?id=ecda483339a5151e3ca30d6b82691ef6f1d17912)@@ -160,6 +160,7 @@ int zpci\_fmb\_enable\_device(struct zpci\_dev \*zdev) u64 req = ZPCI\_CREATE\_REQ(zdev->fh, 0, ZPCI\_MOD\_FC\_SET\_MEASURE); struct zpci\_iommu\_ctrs \*ctrs; struct zpci\_fib fib = {0};+ unsigned long flags; u8 cc, status;  if (zdev->fmb || sizeof(\*zdev->fmb) < zdev->fmb\_length)@@ -171,6 +172,7 @@ int zpci\_fmb\_enable\_device(struct zpci\_dev \*zdev) WARN\_ON((u64) zdev->fmb & 0xf);  /\* reset software counters \*/+ spin\_lock\_irqsave(&zdev->dom\_lock, flags); ctrs = zpci\_get\_iommu\_ctrs(zdev); if (ctrs) { atomic64\_set(&ctrs->mapped\_pages, 0);@@ -179,6 +181,7 @@ int zpci\_fmb\_enable\_device(struct zpci\_dev \*zdev) atomic64\_set(&ctrs->sync\_map\_rpcits, 0); atomic64\_set(&ctrs->sync\_rpcits, 0); }+ spin\_unlock\_irqrestore(&zdev->dom\_lock, flags);   fib.fmb\_addr = virt\_to\_phys(zdev->fmb);diff --git a/arch/s390/pci/pci\_debug.c b/arch/s390/pci/pci\_debug.cindex 2cb5043a997d53..38014206c16b96 100644--- a/[arch/s390/pci/pci\_debug.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/pci/pci_debug.c?id=8e929cb546ee42c9a61d24fae60605e9e3192354)+++ b/[arch/s390/pci/pci\_debug.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/s390/pci/pci_debug.c?id=ecda483339a5151e3ca30d6b82691ef6f1d17912)@@ -71,17 +71,23 @@ static void pci\_fmb\_show(struct seq\_file \*m, char \*name[], int length,  static void pci\_sw\_counter\_show(struct seq\_file \*m) {- struct zpci\_iommu\_ctrs \*ctrs = zpci\_get\_iommu\_ctrs(m->private);+ struct zpci\_dev \*zdev = m->private;+ struct zpci\_iommu\_ctrs \*ctrs; atomic64\_t \*counter;+ unsigned long flags; int i; + spin\_lock\_irqsave(&zdev->dom\_lock, flags);+ ctrs = zpci\_get\_iommu\_ctrs(m->private); if (!ctrs)- return;+ goto unlock;  counter = &ctrs->mapped\_pages; for (i = 0; i < ARRAY\_SIZE(pci\_sw\_names); i++, counter++) seq\_printf(m, "%26s:\t%llu\n", pci\_sw\_names[i], atomic64\_read(counter));+unlock:+ spin\_unlock\_irqrestore(&zdev->dom\_lock, flags); }  static int pci\_perf\_show(struct seq\_file \*m, void \*v)diff --git a/drivers/iommu/s390-iommu.c b/drivers/iommu/s390-iommu.cindex d8eaa7ea380bb0..fbdeded3d48b59 100644--- a/[drivers/iommu/s390-iommu.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/iommu/s390-iommu.c?id=8e929cb546ee42c9a61d24fae60605e9e3192354)+++ b/[drivers/iommu/s390-iommu.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/iommu/s390-iommu.c?id=ecda483339a5151e3ca30d6b82691ef6f1d17912)@@ -33,6 +33,8 @@ struct s390\_domain { struct rcu\_head rcu; }; +static struct iommu\_domain blocking\_domain;+ static inline unsigned int calc\_rtx(dma\_addr\_t ptr) { return ((unsigned long)ptr >> ZPCI\_RT\_SHIFT) & ZPCI\_INDEX\_MASK;@@ -369,20 +371,36 @@ static void s390\_domain\_free(struct iommu\_domain \*domain) call\_rcu(&s390\_domain->rcu, s390\_iommu\_rcu\_free\_domain); } -static void s390\_iommu\_detach\_device(struct iommu\_domain \*domain,- struct device \*dev)+static void zdev\_s390\_domain\_update(struct zpci\_dev \*zdev,+ struct iommu\_domain \*domain)+{+ unsigned long flags;++ spin\_lock\_irqsave(&zdev->dom\_lock, flags);+ zdev->s390\_domain = domain;+ spin\_unlock\_irqrestore(&zdev->dom\_lock, flags);+}++static int blocking\_domain\_attach\_device(struct iommu\_domain \*domain,+ struct device \*dev) {- struct s390\_domain \*s390\_domain = to\_s390\_domain(domain); struct zpci\_dev \*zdev = to\_zpci\_dev(dev);+ struct s390\_domain \*s390\_domain; unsigned long flags; + if (zdev->s390\_domain->type == IOMMU\_DOMAIN\_BLOCKED)+ return 0;++ s390\_domain = to\_s390\_domain(zdev->s390\_domain); spin\_lock\_irqsave(&s390\_domain->list\_lock, flags); list\_del\_rcu(&zdev->iommu\_list); spin\_unlock\_irqrestore(&s390\_domain->list\_lock, flags);  zpci\_unregister\_ioat(zdev, 0);- zdev->s390\_domain = NULL; zdev->dma\_table = NULL;+ zdev\_s390\_domain\_update(zdev, domain);++ return 0; }  static int s390\_iommu\_attach\_device(struct iommu\_domain \*domain,@@ -401,20 +419,15 @@ static int s390\_iommu\_attach\_device(struct iommu\_domain \*domain, domain->geometry.aperture\_end < zdev->start\_dma)) return -EINVAL; - if (zdev->s390\_domain)- s390\_iommu\_detach\_device(&zdev->s390\_domain->domain, dev);+ blocking\_domain\_attach\_device(&blocking\_domain, dev); + /\* If we fail now DMA remains blocked via blocking domain \*/ cc = zpci\_register\_ioat(zdev, 0, zdev->start\_dma, zdev->end\_dma, virt\_to\_phys(s390\_domain->dma\_table), &status);- /\*- \* If the device is undergoing error recovery the reset code- \* will re-establish the new domain.- \*/ if (cc && status != ZPCI\_PCI\_ST\_FUNC\_NOT\_AVAIL) return -EIO;- zdev->dma\_table = s390\_domain->dma\_table;- zdev->s390\_domain = s390\_domain;+ zdev\_s390\_domain\_update(zdev, domain);  spin\_lock\_irqsave(&s390\_domain->list\_lock, flags); list\_add\_rcu(&zdev->iommu\_list, &s390\_domain->devices);@@ -466,19 +479,11 @@ static struct iommu\_device \*s390\_iommu\_probe\_device(struct device \*dev) if (zdev->tlb\_refresh) dev->iommu->shadow\_on\_flush = 1; - return &zdev->iommu\_dev;-}+ /\* Start with DMA blocked \*/+ spin\_lock\_init(&zdev->dom\_lock);+ zdev\_s390\_domain\_update(zdev, &blocking\_domain); -static void s390\_iommu\_release\_device(struct device \*dev)-{- struct zpci\_dev \*zdev = to\_zpci\_dev(dev);-- /\*- \* release\_device is expected to detach any domain currently attached- \* to the device, but keep it attached to other devices in the group.- \*/- if (zdev)- s390\_iommu\_detach\_device(&zdev->s390\_domain->domain, dev);+ return &zdev->iommu\_dev; }  static int zpci\_refresh\_all(struct zpci\_dev \*zdev)@@ -697,9 +702,15 @@ static size\_t s390\_iommu\_unmap\_pages(struct iommu\_domain \*domain,  struct zpci\_iommu\_ctrs \*zpci\_get\_iommu\_ctrs(struct zpci\_dev \*zdev) {- if (!zdev || !zdev->s390\_domain)+ struct s390\_domain \*s390\_domain;++ lockdep\_assert\_held(&zdev->dom\_lock);++ if (zdev->s390\_domain->type == IOMMU\_DOMAIN\_BLOCKED) return NULL;- return &zdev->s390\_domain->ctrs;++ s390\_domain = to\_s390\_domain(zdev->s390\_domain);+ return &s390\_domain->ctrs; }  int zpci\_init\_iommu(struct zpci\_dev \*zdev)@@ -776,11 +787,19 @@ static int \_\_init s390\_iommu\_init(void) } subsys\_initcall(s390\_iommu\_init); +static struct iommu\_domain blocking\_domain = {+ .type = IOMMU\_DOMAIN\_BLOCKED,+ .ops = &(const struct iommu\_domain\_ops) {+ .attach\_dev = blocking\_domain\_attach\_device,+ }+};+ static const struct iommu\_ops s390\_iommu\_ops = {+ .blocked\_domain = &blocking\_domain,+ .release\_domain = &blocking\_domain, .capable = s390\_iommu\_capable, .domain\_alloc\_paging = s390\_domain\_alloc\_paging, .probe\_device = s390\_iommu\_probe\_device,- .release\_device = s390\_iommu\_release\_device, .device\_group = generic\_device\_group, .pgsize\_bitmap = SZ\_4K, .get\_resv\_regions = s390\_iommu\_get\_resv\_regions, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:26:10 +0000


