=== Content from git.kernel.org_47f92df3_20250114_185936.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=2bc07714dc955a91d2923a440ea02c3cb3376b10)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2bc07714dc955a91d2923a440ea02c3cb3376b10)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2bc07714dc955a91d2923a440ea02c3cb3376b10)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2bc07714dc955a91d2923a440ea02c3cb3376b10)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Hou Tao <houtao1@huawei.com> | 2024-08-31 17:37:49 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-05 14:02:21 +0100 |
| commit | [2bc07714dc955a91d2923a440ea02c3cb3376b10](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2bc07714dc955a91d2923a440ea02c3cb3376b10) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=2bc07714dc955a91d2923a440ea02c3cb3376b10)) | |
| tree | [749741e3e547d1d7055d0d78ca338a78b1d8c3f1](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2bc07714dc955a91d2923a440ea02c3cb3376b10) | |
| parent | [4ad9592cc70a952400bbc9e22a90f4276b183415](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4ad9592cc70a952400bbc9e22a90f4276b183415) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2bc07714dc955a91d2923a440ea02c3cb3376b10&id2=4ad9592cc70a952400bbc9e22a90f4276b183415)) | |
| download | [linux-2bc07714dc955a91d2923a440ea02c3cb3376b10.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-2bc07714dc955a91d2923a440ea02c3cb3376b10.tar.gz) | |

virtiofs: use pages instead of pointer for kernel direct IO[ Upstream commit 41748675c0bf252b3c5f600a95830f0936d366c1 ]
When trying to insert a 10MB kernel module kept in a virtio-fs with cache
disabled, the following warning was reported:
------------[ cut here ]------------
WARNING: CPU: 1 PID: 404 at mm/page\_alloc.c:4551 ......
Modules linked in:
CPU: 1 PID: 404 Comm: insmod Not tainted 6.9.0-rc5+ #123
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) ......
RIP: 0010:\_\_alloc\_pages+0x2bf/0x380
......
Call Trace:
<TASK>
? \_\_warn+0x8e/0x150
? \_\_alloc\_pages+0x2bf/0x380
\_\_kmalloc\_large\_node+0x86/0x160
\_\_kmalloc+0x33c/0x480
virtio\_fs\_enqueue\_req+0x240/0x6d0
virtio\_fs\_wake\_pending\_and\_unlock+0x7f/0x190
queue\_request\_and\_unlock+0x55/0x60
fuse\_simple\_request+0x152/0x2b0
fuse\_direct\_io+0x5d2/0x8c0
fuse\_file\_read\_iter+0x121/0x160
\_\_kernel\_read+0x151/0x2d0
kernel\_read+0x45/0x50
kernel\_read\_file+0x1a9/0x2a0
init\_module\_from\_file+0x6a/0xe0
idempotent\_init\_module+0x175/0x230
\_\_x64\_sys\_finit\_module+0x5d/0xb0
x64\_sys\_call+0x1c3/0x9e0
do\_syscall\_64+0x3d/0xc0
entry\_SYSCALL\_64\_after\_hwframe+0x4b/0x53
......
</TASK>
---[ end trace 0000000000000000 ]---
The warning is triggered as follows:
1) syscall finit\_module() handles the module insertion and it invokes
kernel\_read\_file() to read the content of the module first.
2) kernel\_read\_file() allocates a 10MB buffer by using vmalloc() and
passes it to kernel\_read(). kernel\_read() constructs a kvec iter by
using iov\_iter\_kvec() and passes it to fuse\_file\_read\_iter().
3) virtio-fs disables the cache, so fuse\_file\_read\_iter() invokes
fuse\_direct\_io(). As for now, the maximal read size for kvec iter is
only limited by fc->max\_read. For virtio-fs, max\_read is UINT\_MAX, so
fuse\_direct\_io() doesn't split the 10MB buffer. It saves the address and
the size of the 10MB-sized buffer in out\_args[0] of a fuse request and
passes the fuse request to virtio\_fs\_wake\_pending\_and\_unlock().
4) virtio\_fs\_wake\_pending\_and\_unlock() uses virtio\_fs\_enqueue\_req() to
queue the request. Because virtiofs need DMA-able address, so
virtio\_fs\_enqueue\_req() uses kmalloc() to allocate a bounce buffer for
all fuse args, copies these args into the bounce buffer and passed the
physical address of the bounce buffer to virtiofsd. The total length of
these fuse args for the passed fuse request is about 10MB, so
copy\_args\_to\_argbuf() invokes kmalloc() with a 10MB size parameter and
it triggers the warning in \_\_alloc\_pages():
if (WARN\_ON\_ONCE\_GFP(order > MAX\_PAGE\_ORDER, gfp))
return NULL;
5) virtio\_fs\_enqueue\_req() will retry the memory allocation in a
kworker, but it won't help, because kmalloc() will always return NULL
due to the abnormal size and finit\_module() will hang forever.
A feasible solution is to limit the value of max\_read for virtio-fs, so
the length passed to kmalloc() will be limited. However it will affect
the maximal read size for normal read. And for virtio-fs write initiated
from kernel, it has the similar problem but now there is no way to limit
fc->max\_write in kernel.
So instead of limiting both the values of max\_read and max\_write in
kernel, introducing use\_pages\_for\_kvec\_io in fuse\_conn and setting it as
true in virtiofs. When use\_pages\_for\_kvec\_io is enabled, fuse will use
pages instead of pointer to pass the KVEC\_IO data.
After switching to pages for KVEC\_IO data, these pages will be used for
DMA through virtio-fs. If these pages are backed by vmalloc(),
{flush|invalidate}\_kernel\_vmap\_range() are necessary to flush or
invalidate the cache before the DMA operation. So add two new fields in
fuse\_args\_pages to record the base address of vmalloc area and the
condition indicating whether invalidation is needed. Perform the flush
in fuse\_get\_user\_pages() for write operations and the invalidation in
fuse\_release\_user\_pages() for read operations.
It may seem necessary to introduce another field in fuse\_conn to
indicate that these KVEC\_IO pages are used for DMA, However, considering
that virtio-fs is currently the only user of use\_pages\_for\_kvec\_io, just
reuse use\_pages\_for\_kvec\_io to indicate that these pages will be used
for DMA.
Fixes: a62a8ef9d97d ("virtio-fs: add virtiofs filesystem")
Signed-off-by: Hou Tao <houtao1@huawei.com>
Tested-by: Jingbo Xu <jefflexu@linux.alibaba.com>
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2bc07714dc955a91d2923a440ea02c3cb3376b10)

| -rw-r--r-- | [fs/fuse/file.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/fuse/file.c?id=2bc07714dc955a91d2923a440ea02c3cb3376b10) | 62 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/fuse/fuse\_i.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/fuse/fuse_i.h?id=2bc07714dc955a91d2923a440ea02c3cb3376b10) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/fuse/virtio\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/fuse/virtio_fs.c?id=2bc07714dc955a91d2923a440ea02c3cb3376b10) | 1 | |  |  |  | | --- | --- | --- | |

3 files changed, 50 insertions, 19 deletions

| diff --git a/fs/fuse/file.c b/fs/fuse/file.cindex dafdf766b1d535..e20d91d0ae558c 100644--- a/[fs/fuse/file.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/file.c?id=4ad9592cc70a952400bbc9e22a90f4276b183415)+++ b/[fs/fuse/file.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/file.c?id=2bc07714dc955a91d2923a440ea02c3cb3376b10)@@ -645,7 +645,7 @@ void fuse\_read\_args\_fill(struct fuse\_io\_args \*ia, struct file \*file, loff\_t pos, args->out\_args[0].size = count; } -static void fuse\_release\_user\_pages(struct fuse\_args\_pages \*ap,+static void fuse\_release\_user\_pages(struct fuse\_args\_pages \*ap, ssize\_t nres, bool should\_dirty) { unsigned int i;@@ -656,6 +656,9 @@ static void fuse\_release\_user\_pages(struct fuse\_args\_pages \*ap, if (ap->args.is\_pinned) unpin\_user\_page(ap->pages[i]); }++ if (nres > 0 && ap->args.invalidate\_vmap)+ invalidate\_kernel\_vmap\_range(ap->args.vmap\_base, nres); }  static void fuse\_io\_release(struct kref \*kref)@@ -754,25 +757,29 @@ static void fuse\_aio\_complete\_req(struct fuse\_mount \*fm, struct fuse\_args \*args, struct fuse\_io\_args \*ia = container\_of(args, typeof(\*ia), ap.args); struct fuse\_io\_priv \*io = ia->io; ssize\_t pos = -1;-- fuse\_release\_user\_pages(&ia->ap, io->should\_dirty);+ size\_t nres;  if (err) { /\* Nothing \*/ } else if (io->write) { if (ia->write.out.size > ia->write.in.size) { err = -EIO;- } else if (ia->write.in.size != ia->write.out.size) {- pos = ia->write.in.offset - io->offset +- ia->write.out.size;+ } else {+ nres = ia->write.out.size;+ if (ia->write.in.size != ia->write.out.size)+ pos = ia->write.in.offset - io->offset ++ ia->write.out.size; } } else { u32 outsize = args->out\_args[0].size; + nres = outsize; if (ia->read.in.size != outsize) pos = ia->read.in.offset - io->offset + outsize; } + fuse\_release\_user\_pages(&ia->ap, err ?: nres, io->should\_dirty);+ fuse\_aio\_complete(io, err, pos); fuse\_io\_free(ia); }@@ -1468,24 +1475,37 @@ static inline size\_t fuse\_get\_frag\_size(const struct iov\_iter \*ii,  static int fuse\_get\_user\_pages(struct fuse\_args\_pages \*ap, struct iov\_iter \*ii, size\_t \*nbytesp, int write,- unsigned int max\_pages)+ unsigned int max\_pages,+ bool use\_pages\_for\_kvec\_io) {+ bool flush\_or\_invalidate = false; size\_t nbytes = 0; /\* # bytes already packed in req \*/ ssize\_t ret = 0; - /\* Special case for kernel I/O: can copy directly into the buffer \*/+ /\* Special case for kernel I/O: can copy directly into the buffer.+ \* However if the implementation of fuse\_conn requires pages instead of+ \* pointer (e.g., virtio-fs), use iov\_iter\_extract\_pages() instead.+ \*/ if (iov\_iter\_is\_kvec(ii)) {- unsigned long user\_addr = fuse\_get\_user\_addr(ii);- size\_t frag\_size = fuse\_get\_frag\_size(ii, \*nbytesp);+ void \*user\_addr = (void \*)fuse\_get\_user\_addr(ii); - if (write)- ap->args.in\_args[1].value = (void \*) user\_addr;- else- ap->args.out\_args[0].value = (void \*) user\_addr;+ if (!use\_pages\_for\_kvec\_io) {+ size\_t frag\_size = fuse\_get\_frag\_size(ii, \*nbytesp); - iov\_iter\_advance(ii, frag\_size);- \*nbytesp = frag\_size;- return 0;+ if (write)+ ap->args.in\_args[1].value = user\_addr;+ else+ ap->args.out\_args[0].value = user\_addr;++ iov\_iter\_advance(ii, frag\_size);+ \*nbytesp = frag\_size;+ return 0;+ }++ if (is\_vmalloc\_addr(user\_addr)) {+ ap->args.vmap\_base = user\_addr;+ flush\_or\_invalidate = true;+ } }  while (nbytes < \*nbytesp && ap->num\_pages < max\_pages) {@@ -1514,6 +1534,10 @@ static int fuse\_get\_user\_pages(struct fuse\_args\_pages \*ap, struct iov\_iter \*ii, (PAGE\_SIZE - ret) & (PAGE\_SIZE - 1); } + if (write && flush\_or\_invalidate)+ flush\_kernel\_vmap\_range(ap->args.vmap\_base, nbytes);++ ap->args.invalidate\_vmap = !write && flush\_or\_invalidate; ap->args.is\_pinned = iov\_iter\_extract\_will\_pin(ii); ap->args.user\_pages = true; if (write)@@ -1582,7 +1606,7 @@ ssize\_t fuse\_direct\_io(struct fuse\_io\_priv \*io, struct iov\_iter \*iter, size\_t nbytes = min(count, nmax);  err = fuse\_get\_user\_pages(&ia->ap, iter, &nbytes, write,- max\_pages);+ max\_pages, fc->use\_pages\_for\_kvec\_io); if (err && !nbytes) break; @@ -1596,7 +1620,7 @@ ssize\_t fuse\_direct\_io(struct fuse\_io\_priv \*io, struct iov\_iter \*iter, }  if (!io->async || nres < 0) {- fuse\_release\_user\_pages(&ia->ap, io->should\_dirty);+ fuse\_release\_user\_pages(&ia->ap, nres, io->should\_dirty); fuse\_io\_free(ia); } ia = NULL;diff --git a/fs/fuse/fuse\_i.h b/fs/fuse/fuse\_i.hindex e6cc3d552b1382..28cf319c1c25cf 100644--- a/[fs/fuse/fuse\_i.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/fuse_i.h?id=4ad9592cc70a952400bbc9e22a90f4276b183415)+++ b/[fs/fuse/fuse\_i.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/fuse_i.h?id=2bc07714dc955a91d2923a440ea02c3cb3376b10)@@ -309,9 +309,12 @@ struct fuse\_args { bool may\_block:1; bool is\_ext:1; bool is\_pinned:1;+ bool invalidate\_vmap:1; struct fuse\_in\_arg in\_args[3]; struct fuse\_arg out\_args[2]; void (\*end)(struct fuse\_mount \*fm, struct fuse\_args \*args, int error);+ /\* Used for kvec iter backed by vmalloc address \*/+ void \*vmap\_base; };  struct fuse\_args\_pages {@@ -857,6 +860,9 @@ struct fuse\_conn { /\*\* Passthrough support for read/write IO \*/ unsigned int passthrough:1; + /\* Use pages instead of pointer for kernel I/O \*/+ unsigned int use\_pages\_for\_kvec\_io:1;+ /\*\* Maximum stack depth for passthrough backing files \*/ int max\_stack\_depth; diff --git a/fs/fuse/virtio\_fs.c b/fs/fuse/virtio\_fs.cindex 6404a189e98900..d220e28e755fef 100644--- a/[fs/fuse/virtio\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/virtio_fs.c?id=4ad9592cc70a952400bbc9e22a90f4276b183415)+++ b/[fs/fuse/virtio\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/virtio_fs.c?id=2bc07714dc955a91d2923a440ea02c3cb3376b10)@@ -1691,6 +1691,7 @@ static int virtio\_fs\_get\_tree(struct fs\_context \*fsc) fc->delete\_stale = true; fc->auto\_submounts = true; fc->sync\_fs = true;+ fc->use\_pages\_for\_kvec\_io = true;  /\* Tell FUSE to split requests that exceed the virtqueue's size \*/ fc->max\_pages\_limit = min\_t(unsigned int, fc->max\_pages\_limit, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 18:58:13 +0000



=== Content from git.kernel.org_6ce03eed_20250114_185937.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=41748675c0bf252b3c5f600a95830f0936d366c1)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=41748675c0bf252b3c5f600a95830f0936d366c1)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=41748675c0bf252b3c5f600a95830f0936d366c1)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=41748675c0bf252b3c5f600a95830f0936d366c1)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Hou Tao <houtao1@huawei.com> | 2024-08-31 17:37:49 +0800 |
| --- | --- | --- |
| committer | Miklos Szeredi <mszeredi@redhat.com> | 2024-10-25 17:05:49 +0200 |
| commit | [41748675c0bf252b3c5f600a95830f0936d366c1](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=41748675c0bf252b3c5f600a95830f0936d366c1) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=41748675c0bf252b3c5f600a95830f0936d366c1)) | |
| tree | [b78c813e80272690c92e29d7eb34c84e46699afb](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=41748675c0bf252b3c5f600a95830f0936d366c1) | |
| parent | [cc23d537e56153560bb2f88fd826675a5a8c6af6](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cc23d537e56153560bb2f88fd826675a5a8c6af6) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=41748675c0bf252b3c5f600a95830f0936d366c1&id2=cc23d537e56153560bb2f88fd826675a5a8c6af6)) | |
| download | [linux-41748675c0bf252b3c5f600a95830f0936d366c1.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-41748675c0bf252b3c5f600a95830f0936d366c1.tar.gz) | |

virtiofs: use pages instead of pointer for kernel direct IOWhen trying to insert a 10MB kernel module kept in a virtio-fs with cache
disabled, the following warning was reported:
------------[ cut here ]------------
WARNING: CPU: 1 PID: 404 at mm/page\_alloc.c:4551 ......
Modules linked in:
CPU: 1 PID: 404 Comm: insmod Not tainted 6.9.0-rc5+ #123
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) ......
RIP: 0010:\_\_alloc\_pages+0x2bf/0x380
......
Call Trace:
<TASK>
? \_\_warn+0x8e/0x150
? \_\_alloc\_pages+0x2bf/0x380
\_\_kmalloc\_large\_node+0x86/0x160
\_\_kmalloc+0x33c/0x480
virtio\_fs\_enqueue\_req+0x240/0x6d0
virtio\_fs\_wake\_pending\_and\_unlock+0x7f/0x190
queue\_request\_and\_unlock+0x55/0x60
fuse\_simple\_request+0x152/0x2b0
fuse\_direct\_io+0x5d2/0x8c0
fuse\_file\_read\_iter+0x121/0x160
\_\_kernel\_read+0x151/0x2d0
kernel\_read+0x45/0x50
kernel\_read\_file+0x1a9/0x2a0
init\_module\_from\_file+0x6a/0xe0
idempotent\_init\_module+0x175/0x230
\_\_x64\_sys\_finit\_module+0x5d/0xb0
x64\_sys\_call+0x1c3/0x9e0
do\_syscall\_64+0x3d/0xc0
entry\_SYSCALL\_64\_after\_hwframe+0x4b/0x53
......
</TASK>
---[ end trace 0000000000000000 ]---
The warning is triggered as follows:
1) syscall finit\_module() handles the module insertion and it invokes
kernel\_read\_file() to read the content of the module first.
2) kernel\_read\_file() allocates a 10MB buffer by using vmalloc() and
passes it to kernel\_read(). kernel\_read() constructs a kvec iter by
using iov\_iter\_kvec() and passes it to fuse\_file\_read\_iter().
3) virtio-fs disables the cache, so fuse\_file\_read\_iter() invokes
fuse\_direct\_io(). As for now, the maximal read size for kvec iter is
only limited by fc->max\_read. For virtio-fs, max\_read is UINT\_MAX, so
fuse\_direct\_io() doesn't split the 10MB buffer. It saves the address and
the size of the 10MB-sized buffer in out\_args[0] of a fuse request and
passes the fuse request to virtio\_fs\_wake\_pending\_and\_unlock().
4) virtio\_fs\_wake\_pending\_and\_unlock() uses virtio\_fs\_enqueue\_req() to
queue the request. Because virtiofs need DMA-able address, so
virtio\_fs\_enqueue\_req() uses kmalloc() to allocate a bounce buffer for
all fuse args, copies these args into the bounce buffer and passed the
physical address of the bounce buffer to virtiofsd. The total length of
these fuse args for the passed fuse request is about 10MB, so
copy\_args\_to\_argbuf() invokes kmalloc() with a 10MB size parameter and
it triggers the warning in \_\_alloc\_pages():
if (WARN\_ON\_ONCE\_GFP(order > MAX\_PAGE\_ORDER, gfp))
return NULL;
5) virtio\_fs\_enqueue\_req() will retry the memory allocation in a
kworker, but it won't help, because kmalloc() will always return NULL
due to the abnormal size and finit\_module() will hang forever.
A feasible solution is to limit the value of max\_read for virtio-fs, so
the length passed to kmalloc() will be limited. However it will affect
the maximal read size for normal read. And for virtio-fs write initiated
from kernel, it has the similar problem but now there is no way to limit
fc->max\_write in kernel.
So instead of limiting both the values of max\_read and max\_write in
kernel, introducing use\_pages\_for\_kvec\_io in fuse\_conn and setting it as
true in virtiofs. When use\_pages\_for\_kvec\_io is enabled, fuse will use
pages instead of pointer to pass the KVEC\_IO data.
After switching to pages for KVEC\_IO data, these pages will be used for
DMA through virtio-fs. If these pages are backed by vmalloc(),
{flush|invalidate}\_kernel\_vmap\_range() are necessary to flush or
invalidate the cache before the DMA operation. So add two new fields in
fuse\_args\_pages to record the base address of vmalloc area and the
condition indicating whether invalidation is needed. Perform the flush
in fuse\_get\_user\_pages() for write operations and the invalidation in
fuse\_release\_user\_pages() for read operations.
It may seem necessary to introduce another field in fuse\_conn to
indicate that these KVEC\_IO pages are used for DMA, However, considering
that virtio-fs is currently the only user of use\_pages\_for\_kvec\_io, just
reuse use\_pages\_for\_kvec\_io to indicate that these pages will be used
for DMA.
Fixes: a62a8ef9d97d ("virtio-fs: add virtiofs filesystem")
Signed-off-by: Hou Tao <houtao1@huawei.com>
Tested-by: Jingbo Xu <jefflexu@linux.alibaba.com>
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=41748675c0bf252b3c5f600a95830f0936d366c1)

| -rw-r--r-- | [fs/fuse/file.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/fuse/file.c?id=41748675c0bf252b3c5f600a95830f0936d366c1) | 62 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/fuse/fuse\_i.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/fuse/fuse_i.h?id=41748675c0bf252b3c5f600a95830f0936d366c1) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/fuse/virtio\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/fuse/virtio_fs.c?id=41748675c0bf252b3c5f600a95830f0936d366c1) | 1 | |  |  |  | | --- | --- | --- | |

3 files changed, 50 insertions, 19 deletions

| diff --git a/fs/fuse/file.c b/fs/fuse/file.cindex 5d240d8f1d5a4f..1943945c7370ca 100644--- a/[fs/fuse/file.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/file.c?id=cc23d537e56153560bb2f88fd826675a5a8c6af6)+++ b/[fs/fuse/file.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/file.c?id=41748675c0bf252b3c5f600a95830f0936d366c1)@@ -645,7 +645,7 @@ void fuse\_read\_args\_fill(struct fuse\_io\_args \*ia, struct file \*file, loff\_t pos, args->out\_args[0].size = count; } -static void fuse\_release\_user\_pages(struct fuse\_args\_pages \*ap,+static void fuse\_release\_user\_pages(struct fuse\_args\_pages \*ap, ssize\_t nres, bool should\_dirty) { unsigned int i;@@ -656,6 +656,9 @@ static void fuse\_release\_user\_pages(struct fuse\_args\_pages \*ap, if (ap->args.is\_pinned) unpin\_user\_page(ap->pages[i]); }++ if (nres > 0 && ap->args.invalidate\_vmap)+ invalidate\_kernel\_vmap\_range(ap->args.vmap\_base, nres); }  static void fuse\_io\_release(struct kref \*kref)@@ -754,25 +757,29 @@ static void fuse\_aio\_complete\_req(struct fuse\_mount \*fm, struct fuse\_args \*args, struct fuse\_io\_args \*ia = container\_of(args, typeof(\*ia), ap.args); struct fuse\_io\_priv \*io = ia->io; ssize\_t pos = -1;-- fuse\_release\_user\_pages(&ia->ap, io->should\_dirty);+ size\_t nres;  if (err) { /\* Nothing \*/ } else if (io->write) { if (ia->write.out.size > ia->write.in.size) { err = -EIO;- } else if (ia->write.in.size != ia->write.out.size) {- pos = ia->write.in.offset - io->offset +- ia->write.out.size;+ } else {+ nres = ia->write.out.size;+ if (ia->write.in.size != ia->write.out.size)+ pos = ia->write.in.offset - io->offset ++ ia->write.out.size; } } else { u32 outsize = args->out\_args[0].size; + nres = outsize; if (ia->read.in.size != outsize) pos = ia->read.in.offset - io->offset + outsize; } + fuse\_release\_user\_pages(&ia->ap, err ?: nres, io->should\_dirty);+ fuse\_aio\_complete(io, err, pos); fuse\_io\_free(ia); }@@ -1468,24 +1475,37 @@ static inline size\_t fuse\_get\_frag\_size(const struct iov\_iter \*ii,  static int fuse\_get\_user\_pages(struct fuse\_args\_pages \*ap, struct iov\_iter \*ii, size\_t \*nbytesp, int write,- unsigned int max\_pages)+ unsigned int max\_pages,+ bool use\_pages\_for\_kvec\_io) {+ bool flush\_or\_invalidate = false; size\_t nbytes = 0; /\* # bytes already packed in req \*/ ssize\_t ret = 0; - /\* Special case for kernel I/O: can copy directly into the buffer \*/+ /\* Special case for kernel I/O: can copy directly into the buffer.+ \* However if the implementation of fuse\_conn requires pages instead of+ \* pointer (e.g., virtio-fs), use iov\_iter\_extract\_pages() instead.+ \*/ if (iov\_iter\_is\_kvec(ii)) {- unsigned long user\_addr = fuse\_get\_user\_addr(ii);- size\_t frag\_size = fuse\_get\_frag\_size(ii, \*nbytesp);+ void \*user\_addr = (void \*)fuse\_get\_user\_addr(ii); - if (write)- ap->args.in\_args[1].value = (void \*) user\_addr;- else- ap->args.out\_args[0].value = (void \*) user\_addr;+ if (!use\_pages\_for\_kvec\_io) {+ size\_t frag\_size = fuse\_get\_frag\_size(ii, \*nbytesp); - iov\_iter\_advance(ii, frag\_size);- \*nbytesp = frag\_size;- return 0;+ if (write)+ ap->args.in\_args[1].value = user\_addr;+ else+ ap->args.out\_args[0].value = user\_addr;++ iov\_iter\_advance(ii, frag\_size);+ \*nbytesp = frag\_size;+ return 0;+ }++ if (is\_vmalloc\_addr(user\_addr)) {+ ap->args.vmap\_base = user\_addr;+ flush\_or\_invalidate = true;+ } }  while (nbytes < \*nbytesp && ap->num\_pages < max\_pages) {@@ -1514,6 +1534,10 @@ static int fuse\_get\_user\_pages(struct fuse\_args\_pages \*ap, struct iov\_iter \*ii, (PAGE\_SIZE - ret) & (PAGE\_SIZE - 1); } + if (write && flush\_or\_invalidate)+ flush\_kernel\_vmap\_range(ap->args.vmap\_base, nbytes);++ ap->args.invalidate\_vmap = !write && flush\_or\_invalidate; ap->args.is\_pinned = iov\_iter\_extract\_will\_pin(ii); ap->args.user\_pages = true; if (write)@@ -1582,7 +1606,7 @@ ssize\_t fuse\_direct\_io(struct fuse\_io\_priv \*io, struct iov\_iter \*iter, size\_t nbytes = min(count, nmax);  err = fuse\_get\_user\_pages(&ia->ap, iter, &nbytes, write,- max\_pages);+ max\_pages, fc->use\_pages\_for\_kvec\_io); if (err && !nbytes) break; @@ -1596,7 +1620,7 @@ ssize\_t fuse\_direct\_io(struct fuse\_io\_priv \*io, struct iov\_iter \*iter, }  if (!io->async || nres < 0) {- fuse\_release\_user\_pages(&ia->ap, io->should\_dirty);+ fuse\_release\_user\_pages(&ia->ap, nres, io->should\_dirty); fuse\_io\_free(ia); } ia = NULL;diff --git a/fs/fuse/fuse\_i.h b/fs/fuse/fuse\_i.hindex 7ff00bae4a8456..671daa4d07adba 100644--- a/[fs/fuse/fuse\_i.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/fuse_i.h?id=cc23d537e56153560bb2f88fd826675a5a8c6af6)+++ b/[fs/fuse/fuse\_i.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/fuse_i.h?id=41748675c0bf252b3c5f600a95830f0936d366c1)@@ -309,9 +309,12 @@ struct fuse\_args { bool may\_block:1; bool is\_ext:1; bool is\_pinned:1;+ bool invalidate\_vmap:1; struct fuse\_in\_arg in\_args[3]; struct fuse\_arg out\_args[2]; void (\*end)(struct fuse\_mount \*fm, struct fuse\_args \*args, int error);+ /\* Used for kvec iter backed by vmalloc address \*/+ void \*vmap\_base; };  struct fuse\_args\_pages {@@ -857,6 +860,9 @@ struct fuse\_conn { /\*\* Passthrough support for read/write IO \*/ unsigned int passthrough:1; + /\* Use pages instead of pointer for kernel I/O \*/+ unsigned int use\_pages\_for\_kvec\_io:1;+ /\*\* Maximum stack depth for passthrough backing files \*/ int max\_stack\_depth; diff --git a/fs/fuse/virtio\_fs.c b/fs/fuse/virtio\_fs.cindex 6404a189e98900..d220e28e755fef 100644--- a/[fs/fuse/virtio\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/virtio_fs.c?id=cc23d537e56153560bb2f88fd826675a5a8c6af6)+++ b/[fs/fuse/virtio\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/virtio_fs.c?id=41748675c0bf252b3c5f600a95830f0936d366c1)@@ -1691,6 +1691,7 @@ static int virtio\_fs\_get\_tree(struct fs\_context \*fsc) fc->delete\_stale = true; fc->auto\_submounts = true; fc->sync\_fs = true;+ fc->use\_pages\_for\_kvec\_io = true;  /\* Tell FUSE to split requests that exceed the virtqueue's size \*/ fc->max\_pages\_limit = min\_t(unsigned int, fc->max\_pages\_limit, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 18:58:14 +0000



=== Content from git.kernel.org_37eddc56_20250114_185938.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=9a8fde56d4b6d51930936ed50f6370a9097328d1)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9a8fde56d4b6d51930936ed50f6370a9097328d1)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9a8fde56d4b6d51930936ed50f6370a9097328d1)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9a8fde56d4b6d51930936ed50f6370a9097328d1)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Hou Tao <houtao1@huawei.com> | 2024-08-31 17:37:49 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-05 13:53:48 +0100 |
| commit | [9a8fde56d4b6d51930936ed50f6370a9097328d1](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9a8fde56d4b6d51930936ed50f6370a9097328d1) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=9a8fde56d4b6d51930936ed50f6370a9097328d1)) | |
| tree | [02d9cd22d3c555e40b424b54fdafbb0868adc036](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9a8fde56d4b6d51930936ed50f6370a9097328d1) | |
| parent | [8601f214db8c3436932f976ddb7d2cfa0857ecd4](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8601f214db8c3436932f976ddb7d2cfa0857ecd4) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9a8fde56d4b6d51930936ed50f6370a9097328d1&id2=8601f214db8c3436932f976ddb7d2cfa0857ecd4)) | |
| download | [linux-9a8fde56d4b6d51930936ed50f6370a9097328d1.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-9a8fde56d4b6d51930936ed50f6370a9097328d1.tar.gz) | |

virtiofs: use pages instead of pointer for kernel direct IO[ Upstream commit 41748675c0bf252b3c5f600a95830f0936d366c1 ]
When trying to insert a 10MB kernel module kept in a virtio-fs with cache
disabled, the following warning was reported:
------------[ cut here ]------------
WARNING: CPU: 1 PID: 404 at mm/page\_alloc.c:4551 ......
Modules linked in:
CPU: 1 PID: 404 Comm: insmod Not tainted 6.9.0-rc5+ #123
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) ......
RIP: 0010:\_\_alloc\_pages+0x2bf/0x380
......
Call Trace:
<TASK>
? \_\_warn+0x8e/0x150
? \_\_alloc\_pages+0x2bf/0x380
\_\_kmalloc\_large\_node+0x86/0x160
\_\_kmalloc+0x33c/0x480
virtio\_fs\_enqueue\_req+0x240/0x6d0
virtio\_fs\_wake\_pending\_and\_unlock+0x7f/0x190
queue\_request\_and\_unlock+0x55/0x60
fuse\_simple\_request+0x152/0x2b0
fuse\_direct\_io+0x5d2/0x8c0
fuse\_file\_read\_iter+0x121/0x160
\_\_kernel\_read+0x151/0x2d0
kernel\_read+0x45/0x50
kernel\_read\_file+0x1a9/0x2a0
init\_module\_from\_file+0x6a/0xe0
idempotent\_init\_module+0x175/0x230
\_\_x64\_sys\_finit\_module+0x5d/0xb0
x64\_sys\_call+0x1c3/0x9e0
do\_syscall\_64+0x3d/0xc0
entry\_SYSCALL\_64\_after\_hwframe+0x4b/0x53
......
</TASK>
---[ end trace 0000000000000000 ]---
The warning is triggered as follows:
1) syscall finit\_module() handles the module insertion and it invokes
kernel\_read\_file() to read the content of the module first.
2) kernel\_read\_file() allocates a 10MB buffer by using vmalloc() and
passes it to kernel\_read(). kernel\_read() constructs a kvec iter by
using iov\_iter\_kvec() and passes it to fuse\_file\_read\_iter().
3) virtio-fs disables the cache, so fuse\_file\_read\_iter() invokes
fuse\_direct\_io(). As for now, the maximal read size for kvec iter is
only limited by fc->max\_read. For virtio-fs, max\_read is UINT\_MAX, so
fuse\_direct\_io() doesn't split the 10MB buffer. It saves the address and
the size of the 10MB-sized buffer in out\_args[0] of a fuse request and
passes the fuse request to virtio\_fs\_wake\_pending\_and\_unlock().
4) virtio\_fs\_wake\_pending\_and\_unlock() uses virtio\_fs\_enqueue\_req() to
queue the request. Because virtiofs need DMA-able address, so
virtio\_fs\_enqueue\_req() uses kmalloc() to allocate a bounce buffer for
all fuse args, copies these args into the bounce buffer and passed the
physical address of the bounce buffer to virtiofsd. The total length of
these fuse args for the passed fuse request is about 10MB, so
copy\_args\_to\_argbuf() invokes kmalloc() with a 10MB size parameter and
it triggers the warning in \_\_alloc\_pages():
if (WARN\_ON\_ONCE\_GFP(order > MAX\_PAGE\_ORDER, gfp))
return NULL;
5) virtio\_fs\_enqueue\_req() will retry the memory allocation in a
kworker, but it won't help, because kmalloc() will always return NULL
due to the abnormal size and finit\_module() will hang forever.
A feasible solution is to limit the value of max\_read for virtio-fs, so
the length passed to kmalloc() will be limited. However it will affect
the maximal read size for normal read. And for virtio-fs write initiated
from kernel, it has the similar problem but now there is no way to limit
fc->max\_write in kernel.
So instead of limiting both the values of max\_read and max\_write in
kernel, introducing use\_pages\_for\_kvec\_io in fuse\_conn and setting it as
true in virtiofs. When use\_pages\_for\_kvec\_io is enabled, fuse will use
pages instead of pointer to pass the KVEC\_IO data.
After switching to pages for KVEC\_IO data, these pages will be used for
DMA through virtio-fs. If these pages are backed by vmalloc(),
{flush|invalidate}\_kernel\_vmap\_range() are necessary to flush or
invalidate the cache before the DMA operation. So add two new fields in
fuse\_args\_pages to record the base address of vmalloc area and the
condition indicating whether invalidation is needed. Perform the flush
in fuse\_get\_user\_pages() for write operations and the invalidation in
fuse\_release\_user\_pages() for read operations.
It may seem necessary to introduce another field in fuse\_conn to
indicate that these KVEC\_IO pages are used for DMA, However, considering
that virtio-fs is currently the only user of use\_pages\_for\_kvec\_io, just
reuse use\_pages\_for\_kvec\_io to indicate that these pages will be used
for DMA.
Fixes: a62a8ef9d97d ("virtio-fs: add virtiofs filesystem")
Signed-off-by: Hou Tao <houtao1@huawei.com>
Tested-by: Jingbo Xu <jefflexu@linux.alibaba.com>
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9a8fde56d4b6d51930936ed50f6370a9097328d1)

| -rw-r--r-- | [fs/fuse/file.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/fuse/file.c?id=9a8fde56d4b6d51930936ed50f6370a9097328d1) | 62 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/fuse/fuse\_i.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/fuse/fuse_i.h?id=9a8fde56d4b6d51930936ed50f6370a9097328d1) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/fuse/virtio\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/fuse/virtio_fs.c?id=9a8fde56d4b6d51930936ed50f6370a9097328d1) | 1 | |  |  |  | | --- | --- | --- | |

3 files changed, 50 insertions, 19 deletions

| diff --git a/fs/fuse/file.c b/fs/fuse/file.cindex 08f7d538ca98f4..f4d17cd8c734c4 100644--- a/[fs/fuse/file.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/file.c?id=8601f214db8c3436932f976ddb7d2cfa0857ecd4)+++ b/[fs/fuse/file.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/file.c?id=9a8fde56d4b6d51930936ed50f6370a9097328d1)@@ -645,7 +645,7 @@ void fuse\_read\_args\_fill(struct fuse\_io\_args \*ia, struct file \*file, loff\_t pos, args->out\_args[0].size = count; } -static void fuse\_release\_user\_pages(struct fuse\_args\_pages \*ap,+static void fuse\_release\_user\_pages(struct fuse\_args\_pages \*ap, ssize\_t nres, bool should\_dirty) { unsigned int i;@@ -656,6 +656,9 @@ static void fuse\_release\_user\_pages(struct fuse\_args\_pages \*ap, if (ap->args.is\_pinned) unpin\_user\_page(ap->pages[i]); }++ if (nres > 0 && ap->args.invalidate\_vmap)+ invalidate\_kernel\_vmap\_range(ap->args.vmap\_base, nres); }  static void fuse\_io\_release(struct kref \*kref)@@ -754,25 +757,29 @@ static void fuse\_aio\_complete\_req(struct fuse\_mount \*fm, struct fuse\_args \*args, struct fuse\_io\_args \*ia = container\_of(args, typeof(\*ia), ap.args); struct fuse\_io\_priv \*io = ia->io; ssize\_t pos = -1;-- fuse\_release\_user\_pages(&ia->ap, io->should\_dirty);+ size\_t nres;  if (err) { /\* Nothing \*/ } else if (io->write) { if (ia->write.out.size > ia->write.in.size) { err = -EIO;- } else if (ia->write.in.size != ia->write.out.size) {- pos = ia->write.in.offset - io->offset +- ia->write.out.size;+ } else {+ nres = ia->write.out.size;+ if (ia->write.in.size != ia->write.out.size)+ pos = ia->write.in.offset - io->offset ++ ia->write.out.size; } } else { u32 outsize = args->out\_args[0].size; + nres = outsize; if (ia->read.in.size != outsize) pos = ia->read.in.offset - io->offset + outsize; } + fuse\_release\_user\_pages(&ia->ap, err ?: nres, io->should\_dirty);+ fuse\_aio\_complete(io, err, pos); fuse\_io\_free(ia); }@@ -1467,24 +1474,37 @@ static inline size\_t fuse\_get\_frag\_size(const struct iov\_iter \*ii,  static int fuse\_get\_user\_pages(struct fuse\_args\_pages \*ap, struct iov\_iter \*ii, size\_t \*nbytesp, int write,- unsigned int max\_pages)+ unsigned int max\_pages,+ bool use\_pages\_for\_kvec\_io) {+ bool flush\_or\_invalidate = false; size\_t nbytes = 0; /\* # bytes already packed in req \*/ ssize\_t ret = 0; - /\* Special case for kernel I/O: can copy directly into the buffer \*/+ /\* Special case for kernel I/O: can copy directly into the buffer.+ \* However if the implementation of fuse\_conn requires pages instead of+ \* pointer (e.g., virtio-fs), use iov\_iter\_extract\_pages() instead.+ \*/ if (iov\_iter\_is\_kvec(ii)) {- unsigned long user\_addr = fuse\_get\_user\_addr(ii);- size\_t frag\_size = fuse\_get\_frag\_size(ii, \*nbytesp);+ void \*user\_addr = (void \*)fuse\_get\_user\_addr(ii); - if (write)- ap->args.in\_args[1].value = (void \*) user\_addr;- else- ap->args.out\_args[0].value = (void \*) user\_addr;+ if (!use\_pages\_for\_kvec\_io) {+ size\_t frag\_size = fuse\_get\_frag\_size(ii, \*nbytesp); - iov\_iter\_advance(ii, frag\_size);- \*nbytesp = frag\_size;- return 0;+ if (write)+ ap->args.in\_args[1].value = user\_addr;+ else+ ap->args.out\_args[0].value = user\_addr;++ iov\_iter\_advance(ii, frag\_size);+ \*nbytesp = frag\_size;+ return 0;+ }++ if (is\_vmalloc\_addr(user\_addr)) {+ ap->args.vmap\_base = user\_addr;+ flush\_or\_invalidate = true;+ } }  while (nbytes < \*nbytesp && ap->num\_pages < max\_pages) {@@ -1513,6 +1533,10 @@ static int fuse\_get\_user\_pages(struct fuse\_args\_pages \*ap, struct iov\_iter \*ii, (PAGE\_SIZE - ret) & (PAGE\_SIZE - 1); } + if (write && flush\_or\_invalidate)+ flush\_kernel\_vmap\_range(ap->args.vmap\_base, nbytes);++ ap->args.invalidate\_vmap = !write && flush\_or\_invalidate; ap->args.is\_pinned = iov\_iter\_extract\_will\_pin(ii); ap->args.user\_pages = true; if (write)@@ -1581,7 +1605,7 @@ ssize\_t fuse\_direct\_io(struct fuse\_io\_priv \*io, struct iov\_iter \*iter, size\_t nbytes = min(count, nmax);  err = fuse\_get\_user\_pages(&ia->ap, iter, &nbytes, write,- max\_pages);+ max\_pages, fc->use\_pages\_for\_kvec\_io); if (err && !nbytes) break; @@ -1595,7 +1619,7 @@ ssize\_t fuse\_direct\_io(struct fuse\_io\_priv \*io, struct iov\_iter \*iter, }  if (!io->async || nres < 0) {- fuse\_release\_user\_pages(&ia->ap, io->should\_dirty);+ fuse\_release\_user\_pages(&ia->ap, nres, io->should\_dirty); fuse\_io\_free(ia); } ia = NULL;diff --git a/fs/fuse/fuse\_i.h b/fs/fuse/fuse\_i.hindex f2391961031374..79add14c363fb7 100644--- a/[fs/fuse/fuse\_i.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/fuse_i.h?id=8601f214db8c3436932f976ddb7d2cfa0857ecd4)+++ b/[fs/fuse/fuse\_i.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/fuse_i.h?id=9a8fde56d4b6d51930936ed50f6370a9097328d1)@@ -309,9 +309,12 @@ struct fuse\_args { bool may\_block:1; bool is\_ext:1; bool is\_pinned:1;+ bool invalidate\_vmap:1; struct fuse\_in\_arg in\_args[3]; struct fuse\_arg out\_args[2]; void (\*end)(struct fuse\_mount \*fm, struct fuse\_args \*args, int error);+ /\* Used for kvec iter backed by vmalloc address \*/+ void \*vmap\_base; };  struct fuse\_args\_pages {@@ -860,6 +863,9 @@ struct fuse\_conn { /\*\* Passthrough support for read/write IO \*/ unsigned int passthrough:1; + /\* Use pages instead of pointer for kernel I/O \*/+ unsigned int use\_pages\_for\_kvec\_io:1;+ /\*\* Maximum stack depth for passthrough backing files \*/ int max\_stack\_depth; diff --git a/fs/fuse/virtio\_fs.c b/fs/fuse/virtio\_fs.cindex dd526014161503..43d66ab5e89188 100644--- a/[fs/fuse/virtio\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/virtio_fs.c?id=8601f214db8c3436932f976ddb7d2cfa0857ecd4)+++ b/[fs/fuse/virtio\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/virtio_fs.c?id=9a8fde56d4b6d51930936ed50f6370a9097328d1)@@ -1568,6 +1568,7 @@ static int virtio\_fs\_get\_tree(struct fs\_context \*fsc) fc->delete\_stale = true; fc->auto\_submounts = true; fc->sync\_fs = true;+ fc->use\_pages\_for\_kvec\_io = true;  /\* Tell FUSE to split requests that exceed the virtqueue's size \*/ fc->max\_pages\_limit = min\_t(unsigned int, fc->max\_pages\_limit, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 18:58:15 +0000


