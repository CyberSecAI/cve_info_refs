=== Content from git.kernel.org_8a7154d5_20250114_181037.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=610a79ffea02102899a1373fe226d949944a7ed6)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=610a79ffea02102899a1373fe226d949944a7ed6)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=610a79ffea02102899a1373fe226d949944a7ed6)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=610a79ffea02102899a1373fe226d949944a7ed6)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | David Howells <dhowells@redhat.com> | 2024-10-17 11:58:52 +0100 |
| --- | --- | --- |
| committer | Christian Brauner <brauner@kernel.org> | 2024-10-17 15:33:46 +0200 |
| commit | [610a79ffea02102899a1373fe226d949944a7ed6](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=610a79ffea02102899a1373fe226d949944a7ed6) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=610a79ffea02102899a1373fe226d949944a7ed6)) | |
| tree | [8beb339f626f90184aabcc009aab965cf9aba9e8](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=610a79ffea02102899a1373fe226d949944a7ed6) | |
| parent | [15f34347481648a567db67fb473c23befb796af5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=15f34347481648a567db67fb473c23befb796af5) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=610a79ffea02102899a1373fe226d949944a7ed6&id2=15f34347481648a567db67fb473c23befb796af5)) | |
| download | [linux-610a79ffea02102899a1373fe226d949944a7ed6.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-610a79ffea02102899a1373fe226d949944a7ed6.tar.gz) | |

afs: Fix lock recursionafs\_wake\_up\_async\_call() can incur lock recursion. The problem is that it
is called from AF\_RXRPC whilst holding the ->notify\_lock, but it tries to
take a ref on the afs\_call struct in order to pass it to a work queue - but
if the afs\_call is already queued, we then have an extraneous ref that must
be put... calling afs\_put\_call() may call back down into AF\_RXRPC through
rxrpc\_kernel\_shutdown\_call(), however, which might try taking the
->notify\_lock again.
This case isn't very common, however, so defer it to a workqueue. The oops
looks something like:
BUG: spinlock recursion on CPU#0, krxrpcio/7001/1646
lock: 0xffff888141399b30, .magic: dead4ead, .owner: krxrpcio/7001/1646, .owner\_cpu: 0
CPU: 0 UID: 0 PID: 1646 Comm: krxrpcio/7001 Not tainted 6.12.0-rc2-build3+ #4351
Hardware name: ASUS All Series/H97-PLUS, BIOS 2306 10/09/2014
Call Trace:
<TASK>
dump\_stack\_lvl+0x47/0x70
do\_raw\_spin\_lock+0x3c/0x90
rxrpc\_kernel\_shutdown\_call+0x83/0xb0
afs\_put\_call+0xd7/0x180
rxrpc\_notify\_socket+0xa0/0x190
rxrpc\_input\_split\_jumbo+0x198/0x1d0
rxrpc\_input\_data+0x14b/0x1e0
? rxrpc\_input\_call\_packet+0xc2/0x1f0
rxrpc\_input\_call\_event+0xad/0x6b0
rxrpc\_input\_packet\_on\_conn+0x1e1/0x210
rxrpc\_input\_packet+0x3f2/0x4d0
rxrpc\_io\_thread+0x243/0x410
? \_\_pfx\_rxrpc\_io\_thread+0x10/0x10
kthread+0xcf/0xe0
? \_\_pfx\_kthread+0x10/0x10
ret\_from\_fork+0x24/0x40
? \_\_pfx\_kthread+0x10/0x10
ret\_from\_fork\_asm+0x1a/0x30
</TASK>
Signed-off-by: David Howells <dhowells@redhat.com>
Link: [https://lore.kernel.org/r/1394602.1729162732@warthog.procyon.org.uk](https://lore.kernel.org/r/1394602.1729162732%40warthog.procyon.org.uk)
cc: Marc Dionne <marc.dionne@auristor.com>
cc: linux-afs@lists.infradead.org
cc: linux-fsdevel@vger.kernel.org
Signed-off-by: Christian Brauner <brauner@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=610a79ffea02102899a1373fe226d949944a7ed6)

| -rw-r--r-- | [fs/afs/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/afs/internal.h?id=610a79ffea02102899a1373fe226d949944a7ed6) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/afs/rxrpc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/afs/rxrpc.c?id=610a79ffea02102899a1373fe226d949944a7ed6) | 83 | |  |  |  | | --- | --- | --- | |

2 files changed, 61 insertions, 24 deletions

| diff --git a/fs/afs/internal.h b/fs/afs/internal.hindex 6e1d3c4daf72c6..52aab09a32a92e 100644--- a/[fs/afs/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/afs/internal.h?id=15f34347481648a567db67fb473c23befb796af5)+++ b/[fs/afs/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/afs/internal.h?id=610a79ffea02102899a1373fe226d949944a7ed6)@@ -130,6 +130,7 @@ struct afs\_call { wait\_queue\_head\_t waitq; /\* processes awaiting completion \*/ struct work\_struct async\_work; /\* async I/O processor \*/ struct work\_struct work; /\* actual work processor \*/+ struct work\_struct free\_work; /\* Deferred free processor \*/ struct rxrpc\_call \*rxcall; /\* RxRPC call handle \*/ struct rxrpc\_peer \*peer; /\* Remote endpoint \*/ struct key \*key; /\* security for this call \*/@@ -1331,6 +1332,7 @@ extern int \_\_net\_init afs\_open\_socket(struct afs\_net \*); extern void \_\_net\_exit afs\_close\_socket(struct afs\_net \*); extern void afs\_charge\_preallocation(struct work\_struct \*); extern void afs\_put\_call(struct afs\_call \*);+void afs\_deferred\_put\_call(struct afs\_call \*call); void afs\_make\_call(struct afs\_call \*call, gfp\_t gfp); void afs\_wait\_for\_call\_to\_complete(struct afs\_call \*call); extern struct afs\_call \*afs\_alloc\_flat\_call(struct afs\_net \*,diff --git a/fs/afs/rxrpc.c b/fs/afs/rxrpc.cindex c453428f3c8ba9..9f2a3bb56ec69e 100644--- a/[fs/afs/rxrpc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/afs/rxrpc.c?id=15f34347481648a567db67fb473c23befb796af5)+++ b/[fs/afs/rxrpc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/afs/rxrpc.c?id=610a79ffea02102899a1373fe226d949944a7ed6)@@ -18,6 +18,7 @@  struct workqueue\_struct \*afs\_async\_calls; +static void afs\_deferred\_free\_worker(struct work\_struct \*work); static void afs\_wake\_up\_call\_waiter(struct sock \*, struct rxrpc\_call \*, unsigned long); static void afs\_wake\_up\_async\_call(struct sock \*, struct rxrpc\_call \*, unsigned long); static void afs\_process\_async\_call(struct work\_struct \*);@@ -149,6 +150,7 @@ static struct afs\_call \*afs\_alloc\_call(struct afs\_net \*net, call->debug\_id = atomic\_inc\_return(&rxrpc\_debug\_id); refcount\_set(&call->ref, 1); INIT\_WORK(&call->async\_work, afs\_process\_async\_call);+ INIT\_WORK(&call->free\_work, afs\_deferred\_free\_worker); init\_waitqueue\_head(&call->waitq); spin\_lock\_init(&call->state\_lock); call->iter = &call->def\_iter;@@ -159,6 +161,36 @@ static struct afs\_call \*afs\_alloc\_call(struct afs\_net \*net, return call; } +static void afs\_free\_call(struct afs\_call \*call)+{+ struct afs\_net \*net = call->net;+ int o;++ ASSERT(!work\_pending(&call->async\_work));++ rxrpc\_kernel\_put\_peer(call->peer);++ if (call->rxcall) {+ rxrpc\_kernel\_shutdown\_call(net->socket, call->rxcall);+ rxrpc\_kernel\_put\_call(net->socket, call->rxcall);+ call->rxcall = NULL;+ }+ if (call->type->destructor)+ call->type->destructor(call);++ afs\_unuse\_server\_notime(call->net, call->server, afs\_server\_trace\_put\_call);+ kfree(call->request);++ o = atomic\_read(&net->nr\_outstanding\_calls);+ trace\_afs\_call(call->debug\_id, afs\_call\_trace\_free, 0, o,+ \_\_builtin\_return\_address(0));+ kfree(call);++ o = atomic\_dec\_return(&net->nr\_outstanding\_calls);+ if (o == 0)+ wake\_up\_var(&net->nr\_outstanding\_calls);+}+ /\* \* Dispose of a reference on a call. \*/@@ -173,32 +205,34 @@ void afs\_put\_call(struct afs\_call \*call) o = atomic\_read(&net->nr\_outstanding\_calls); trace\_afs\_call(debug\_id, afs\_call\_trace\_put, r - 1, o, \_\_builtin\_return\_address(0));+ if (zero)+ afs\_free\_call(call);+} - if (zero) {- ASSERT(!work\_pending(&call->async\_work));- ASSERT(call->type->name != NULL);-- rxrpc\_kernel\_put\_peer(call->peer);-- if (call->rxcall) {- rxrpc\_kernel\_shutdown\_call(net->socket, call->rxcall);- rxrpc\_kernel\_put\_call(net->socket, call->rxcall);- call->rxcall = NULL;- }- if (call->type->destructor)- call->type->destructor(call);+static void afs\_deferred\_free\_worker(struct work\_struct \*work)+{+ struct afs\_call \*call = container\_of(work, struct afs\_call, free\_work); - afs\_unuse\_server\_notime(call->net, call->server, afs\_server\_trace\_put\_call);- kfree(call->request);+ afs\_free\_call(call);+} - trace\_afs\_call(call->debug\_id, afs\_call\_trace\_free, 0, o,- \_\_builtin\_return\_address(0));- kfree(call);+/\*+ \* Dispose of a reference on a call, deferring the cleanup to a workqueue+ \* to avoid lock recursion.+ \*/+void afs\_deferred\_put\_call(struct afs\_call \*call)+{+ struct afs\_net \*net = call->net;+ unsigned int debug\_id = call->debug\_id;+ bool zero;+ int r, o; - o = atomic\_dec\_return(&net->nr\_outstanding\_calls);- if (o == 0)- wake\_up\_var(&net->nr\_outstanding\_calls);- }+ zero = \_\_refcount\_dec\_and\_test(&call->ref, &r);+ o = atomic\_read(&net->nr\_outstanding\_calls);+ trace\_afs\_call(debug\_id, afs\_call\_trace\_put, r - 1, o,+ \_\_builtin\_return\_address(0));+ if (zero)+ schedule\_work(&call->free\_work); }  static struct afs\_call \*afs\_get\_call(struct afs\_call \*call,@@ -640,7 +674,8 @@ static void afs\_wake\_up\_call\_waiter(struct sock \*sk, struct rxrpc\_call \*rxcall, }  /\*- \* wake up an asynchronous call+ \* Wake up an asynchronous call. The caller is holding the call notify+ \* spinlock around this, so we can't call afs\_put\_call(). \*/ static void afs\_wake\_up\_async\_call(struct sock \*sk, struct rxrpc\_call \*rxcall, unsigned long call\_user\_ID)@@ -657,7 +692,7 @@ static void afs\_wake\_up\_async\_call(struct sock \*sk, struct rxrpc\_call \*rxcall, \_\_builtin\_return\_address(0));  if (!queue\_work(afs\_async\_calls, &call->async\_work))- afs\_put\_call(call);+ afs\_deferred\_put\_call(call); } } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 18:09:14 +0000



=== Content from git.kernel.org_0b79941a_20250114_181038.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d7cbf81df996b1eae2dee8deb6df08e2eba78661)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d7cbf81df996b1eae2dee8deb6df08e2eba78661)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d7cbf81df996b1eae2dee8deb6df08e2eba78661)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d7cbf81df996b1eae2dee8deb6df08e2eba78661)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | David Howells <dhowells@redhat.com> | 2024-10-17 11:58:52 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-17 15:09:53 +0100 |
| commit | [d7cbf81df996b1eae2dee8deb6df08e2eba78661](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d7cbf81df996b1eae2dee8deb6df08e2eba78661) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d7cbf81df996b1eae2dee8deb6df08e2eba78661)) | |
| tree | [567c7d875d105acbbb32252c9a486cc3c5ef4c81](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d7cbf81df996b1eae2dee8deb6df08e2eba78661) | |
| parent | [1c28bca1256aecece6e94b26b85cd07e08b0dc90](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1c28bca1256aecece6e94b26b85cd07e08b0dc90) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d7cbf81df996b1eae2dee8deb6df08e2eba78661&id2=1c28bca1256aecece6e94b26b85cd07e08b0dc90)) | |
| download | [linux-d7cbf81df996b1eae2dee8deb6df08e2eba78661.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d7cbf81df996b1eae2dee8deb6df08e2eba78661.tar.gz) | |

afs: Fix lock recursion[ Upstream commit 610a79ffea02102899a1373fe226d949944a7ed6 ]
afs\_wake\_up\_async\_call() can incur lock recursion. The problem is that it
is called from AF\_RXRPC whilst holding the ->notify\_lock, but it tries to
take a ref on the afs\_call struct in order to pass it to a work queue - but
if the afs\_call is already queued, we then have an extraneous ref that must
be put... calling afs\_put\_call() may call back down into AF\_RXRPC through
rxrpc\_kernel\_shutdown\_call(), however, which might try taking the
->notify\_lock again.
This case isn't very common, however, so defer it to a workqueue. The oops
looks something like:
BUG: spinlock recursion on CPU#0, krxrpcio/7001/1646
lock: 0xffff888141399b30, .magic: dead4ead, .owner: krxrpcio/7001/1646, .owner\_cpu: 0
CPU: 0 UID: 0 PID: 1646 Comm: krxrpcio/7001 Not tainted 6.12.0-rc2-build3+ #4351
Hardware name: ASUS All Series/H97-PLUS, BIOS 2306 10/09/2014
Call Trace:
<TASK>
dump\_stack\_lvl+0x47/0x70
do\_raw\_spin\_lock+0x3c/0x90
rxrpc\_kernel\_shutdown\_call+0x83/0xb0
afs\_put\_call+0xd7/0x180
rxrpc\_notify\_socket+0xa0/0x190
rxrpc\_input\_split\_jumbo+0x198/0x1d0
rxrpc\_input\_data+0x14b/0x1e0
? rxrpc\_input\_call\_packet+0xc2/0x1f0
rxrpc\_input\_call\_event+0xad/0x6b0
rxrpc\_input\_packet\_on\_conn+0x1e1/0x210
rxrpc\_input\_packet+0x3f2/0x4d0
rxrpc\_io\_thread+0x243/0x410
? \_\_pfx\_rxrpc\_io\_thread+0x10/0x10
kthread+0xcf/0xe0
? \_\_pfx\_kthread+0x10/0x10
ret\_from\_fork+0x24/0x40
? \_\_pfx\_kthread+0x10/0x10
ret\_from\_fork\_asm+0x1a/0x30
</TASK>
Signed-off-by: David Howells <dhowells@redhat.com>
Link: [https://lore.kernel.org/r/1394602.1729162732@warthog.procyon.org.uk](https://lore.kernel.org/r/1394602.1729162732%40warthog.procyon.org.uk)
cc: Marc Dionne <marc.dionne@auristor.com>
cc: linux-afs@lists.infradead.org
cc: linux-fsdevel@vger.kernel.org
Signed-off-by: Christian Brauner <brauner@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d7cbf81df996b1eae2dee8deb6df08e2eba78661)

| -rw-r--r-- | [fs/afs/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/afs/internal.h?id=d7cbf81df996b1eae2dee8deb6df08e2eba78661) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/afs/rxrpc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/afs/rxrpc.c?id=d7cbf81df996b1eae2dee8deb6df08e2eba78661) | 83 | |  |  |  | | --- | --- | --- | |

2 files changed, 61 insertions, 24 deletions

| diff --git a/fs/afs/internal.h b/fs/afs/internal.hindex b306c09808706b..c9d620175e80ca 100644--- a/[fs/afs/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/afs/internal.h?id=1c28bca1256aecece6e94b26b85cd07e08b0dc90)+++ b/[fs/afs/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/afs/internal.h?id=d7cbf81df996b1eae2dee8deb6df08e2eba78661)@@ -130,6 +130,7 @@ struct afs\_call { wait\_queue\_head\_t waitq; /\* processes awaiting completion \*/ struct work\_struct async\_work; /\* async I/O processor \*/ struct work\_struct work; /\* actual work processor \*/+ struct work\_struct free\_work; /\* Deferred free processor \*/ struct rxrpc\_call \*rxcall; /\* RxRPC call handle \*/ struct rxrpc\_peer \*peer; /\* Remote endpoint \*/ struct key \*key; /\* security for this call \*/@@ -1333,6 +1334,7 @@ extern int \_\_net\_init afs\_open\_socket(struct afs\_net \*); extern void \_\_net\_exit afs\_close\_socket(struct afs\_net \*); extern void afs\_charge\_preallocation(struct work\_struct \*); extern void afs\_put\_call(struct afs\_call \*);+void afs\_deferred\_put\_call(struct afs\_call \*call); void afs\_make\_call(struct afs\_call \*call, gfp\_t gfp); void afs\_wait\_for\_call\_to\_complete(struct afs\_call \*call); extern struct afs\_call \*afs\_alloc\_flat\_call(struct afs\_net \*,diff --git a/fs/afs/rxrpc.c b/fs/afs/rxrpc.cindex c453428f3c8ba9..9f2a3bb56ec69e 100644--- a/[fs/afs/rxrpc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/afs/rxrpc.c?id=1c28bca1256aecece6e94b26b85cd07e08b0dc90)+++ b/[fs/afs/rxrpc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/afs/rxrpc.c?id=d7cbf81df996b1eae2dee8deb6df08e2eba78661)@@ -18,6 +18,7 @@  struct workqueue\_struct \*afs\_async\_calls; +static void afs\_deferred\_free\_worker(struct work\_struct \*work); static void afs\_wake\_up\_call\_waiter(struct sock \*, struct rxrpc\_call \*, unsigned long); static void afs\_wake\_up\_async\_call(struct sock \*, struct rxrpc\_call \*, unsigned long); static void afs\_process\_async\_call(struct work\_struct \*);@@ -149,6 +150,7 @@ static struct afs\_call \*afs\_alloc\_call(struct afs\_net \*net, call->debug\_id = atomic\_inc\_return(&rxrpc\_debug\_id); refcount\_set(&call->ref, 1); INIT\_WORK(&call->async\_work, afs\_process\_async\_call);+ INIT\_WORK(&call->free\_work, afs\_deferred\_free\_worker); init\_waitqueue\_head(&call->waitq); spin\_lock\_init(&call->state\_lock); call->iter = &call->def\_iter;@@ -159,6 +161,36 @@ static struct afs\_call \*afs\_alloc\_call(struct afs\_net \*net, return call; } +static void afs\_free\_call(struct afs\_call \*call)+{+ struct afs\_net \*net = call->net;+ int o;++ ASSERT(!work\_pending(&call->async\_work));++ rxrpc\_kernel\_put\_peer(call->peer);++ if (call->rxcall) {+ rxrpc\_kernel\_shutdown\_call(net->socket, call->rxcall);+ rxrpc\_kernel\_put\_call(net->socket, call->rxcall);+ call->rxcall = NULL;+ }+ if (call->type->destructor)+ call->type->destructor(call);++ afs\_unuse\_server\_notime(call->net, call->server, afs\_server\_trace\_put\_call);+ kfree(call->request);++ o = atomic\_read(&net->nr\_outstanding\_calls);+ trace\_afs\_call(call->debug\_id, afs\_call\_trace\_free, 0, o,+ \_\_builtin\_return\_address(0));+ kfree(call);++ o = atomic\_dec\_return(&net->nr\_outstanding\_calls);+ if (o == 0)+ wake\_up\_var(&net->nr\_outstanding\_calls);+}+ /\* \* Dispose of a reference on a call. \*/@@ -173,32 +205,34 @@ void afs\_put\_call(struct afs\_call \*call) o = atomic\_read(&net->nr\_outstanding\_calls); trace\_afs\_call(debug\_id, afs\_call\_trace\_put, r - 1, o, \_\_builtin\_return\_address(0));+ if (zero)+ afs\_free\_call(call);+} - if (zero) {- ASSERT(!work\_pending(&call->async\_work));- ASSERT(call->type->name != NULL);-- rxrpc\_kernel\_put\_peer(call->peer);-- if (call->rxcall) {- rxrpc\_kernel\_shutdown\_call(net->socket, call->rxcall);- rxrpc\_kernel\_put\_call(net->socket, call->rxcall);- call->rxcall = NULL;- }- if (call->type->destructor)- call->type->destructor(call);+static void afs\_deferred\_free\_worker(struct work\_struct \*work)+{+ struct afs\_call \*call = container\_of(work, struct afs\_call, free\_work); - afs\_unuse\_server\_notime(call->net, call->server, afs\_server\_trace\_put\_call);- kfree(call->request);+ afs\_free\_call(call);+} - trace\_afs\_call(call->debug\_id, afs\_call\_trace\_free, 0, o,- \_\_builtin\_return\_address(0));- kfree(call);+/\*+ \* Dispose of a reference on a call, deferring the cleanup to a workqueue+ \* to avoid lock recursion.+ \*/+void afs\_deferred\_put\_call(struct afs\_call \*call)+{+ struct afs\_net \*net = call->net;+ unsigned int debug\_id = call->debug\_id;+ bool zero;+ int r, o; - o = atomic\_dec\_return(&net->nr\_outstanding\_calls);- if (o == 0)- wake\_up\_var(&net->nr\_outstanding\_calls);- }+ zero = \_\_refcount\_dec\_and\_test(&call->ref, &r);+ o = atomic\_read(&net->nr\_outstanding\_calls);+ trace\_afs\_call(debug\_id, afs\_call\_trace\_put, r - 1, o,+ \_\_builtin\_return\_address(0));+ if (zero)+ schedule\_work(&call->free\_work); }  static struct afs\_call \*afs\_get\_call(struct afs\_call \*call,@@ -640,7 +674,8 @@ static void afs\_wake\_up\_call\_waiter(struct sock \*sk, struct rxrpc\_call \*rxcall, }  /\*- \* wake up an asynchronous call+ \* Wake up an asynchronous call. The caller is holding the call notify+ \* spinlock around this, so we can't call afs\_put\_call(). \*/ static void afs\_wake\_up\_async\_call(struct sock \*sk, struct rxrpc\_call \*rxcall, unsigned long call\_user\_ID)@@ -657,7 +692,7 @@ static void afs\_wake\_up\_async\_call(struct sock \*sk, struct rxrpc\_call \*rxcall, \_\_builtin\_return\_address(0));  if (!queue\_work(afs\_async\_calls, &call->async\_work))- afs\_put\_call(call);+ afs\_deferred\_put\_call(call); } } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 18:09:15 +0000


