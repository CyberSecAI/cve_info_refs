=== Content from git.kernel.org_0ade85e7_20250114_221219.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=3fa640d035e5ae526769615c35cb9ed4be6e3662)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3fa640d035e5ae526769615c35cb9ed4be6e3662)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3fa640d035e5ae526769615c35cb9ed4be6e3662)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3fa640d035e5ae526769615c35cb9ed4be6e3662)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Paul Aurich <paul@darkrain42.org> | 2024-11-18 13:50:28 -0800 |
| --- | --- | --- |
| committer | Steve French <stfrench@microsoft.com> | 2024-11-26 18:47:08 -0600 |
| commit | [3fa640d035e5ae526769615c35cb9ed4be6e3662](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3fa640d035e5ae526769615c35cb9ed4be6e3662) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=3fa640d035e5ae526769615c35cb9ed4be6e3662)) | |
| tree | [be4b49888f4e34e60bef939d282278a9ca326f52](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3fa640d035e5ae526769615c35cb9ed4be6e3662) | |
| parent | [796733054e4a55c78c1c58c6121a550667ebccbf](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=796733054e4a55c78c1c58c6121a550667ebccbf) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3fa640d035e5ae526769615c35cb9ed4be6e3662&id2=796733054e4a55c78c1c58c6121a550667ebccbf)) | |
| download | [linux-3fa640d035e5ae526769615c35cb9ed4be6e3662.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-3fa640d035e5ae526769615c35cb9ed4be6e3662.tar.gz) | |

smb: During unmount, ensure all cached dir instances drop their dentryThe unmount process (cifs\_kill\_sb() calling close\_all\_cached\_dirs()) can
race with various cached directory operations, which ultimately results
in dentries not being dropped and these kernel BUGs:
BUG: Dentry ffff88814f37e358{i=1000000000080,n=/} still in use (2) [unmount of cifs cifs]
VFS: Busy inodes after unmount of cifs (cifs)
------------[ cut here ]------------
kernel BUG at fs/super.c:661!
This happens when a cfid is in the process of being cleaned up when, and
has been removed from the cfids->entries list, including:
- Receiving a lease break from the server
- Server reconnection triggers invalidate\_all\_cached\_dirs(), which
removes all the cfids from the list
- The laundromat thread decides to expire an old cfid.
To solve these problems, dropping the dentry is done in queued work done
in a newly-added cfid\_put\_wq workqueue, and close\_all\_cached\_dirs()
flushes that workqueue after it drops all the dentries of which it's
aware. This is a global workqueue (rather than scoped to a mount), but
the queued work is minimal.
The final cleanup work for cleaning up a cfid is performed via work
queued in the serverclose\_wq workqueue; this is done separate from
dropping the dentries so that close\_all\_cached\_dirs() doesn't block on
any server operations.
Both of these queued works expect to invoked with a cfid reference and
a tcon reference to avoid those objects from being freed while the work
is ongoing.
While we're here, add proper locking to close\_all\_cached\_dirs(), and
locking around the freeing of cfid->dentry.
Fixes: ebe98f1447bb ("cifs: enable caching of directories for which a lease is held")
Cc: stable@vger.kernel.org
Signed-off-by: Paul Aurich <paul@darkrain42.org>
Signed-off-by: Steve French <stfrench@microsoft.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3fa640d035e5ae526769615c35cb9ed4be6e3662)

| -rw-r--r-- | [fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cached_dir.c?id=3fa640d035e5ae526769615c35cb9ed4be6e3662) | 156 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/smb/client/cached\_dir.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cached_dir.h?id=3fa640d035e5ae526769615c35cb9ed4be6e3662) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/cifsfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsfs.c?id=3fa640d035e5ae526769615c35cb9ed4be6e3662) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsglob.h?id=3fa640d035e5ae526769615c35cb9ed4be6e3662) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/inode.c?id=3fa640d035e5ae526769615c35cb9ed4be6e3662) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/trace.h?id=3fa640d035e5ae526769615c35cb9ed4be6e3662) | 3 | |  |  |  | | --- | --- | --- | |

6 files changed, 147 insertions, 36 deletions

| diff --git a/fs/smb/client/cached\_dir.c b/fs/smb/client/cached\_dir.cindex 81b92d20255721..d9e1d1dc6178bd 100644--- a/[fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.c?id=796733054e4a55c78c1c58c6121a550667ebccbf)+++ b/[fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.c?id=3fa640d035e5ae526769615c35cb9ed4be6e3662)@@ -17,6 +17,11 @@ static void free\_cached\_dir(struct cached\_fid \*cfid); static void smb2\_close\_cached\_fid(struct kref \*ref); static void cfids\_laundromat\_worker(struct work\_struct \*work); +struct cached\_dir\_dentry {+ struct list\_head entry;+ struct dentry \*dentry;+};+ static struct cached\_fid \*find\_or\_create\_cached\_dir(struct cached\_fids \*cfids, const char \*path, bool lookup\_only,@@ -472,7 +477,10 @@ void close\_all\_cached\_dirs(struct cifs\_sb\_info \*cifs\_sb) struct cifs\_tcon \*tcon; struct tcon\_link \*tlink; struct cached\_fids \*cfids;+ struct cached\_dir\_dentry \*tmp\_list, \*q;+ LIST\_HEAD(entry); + spin\_lock(&cifs\_sb->tlink\_tree\_lock); for (node = rb\_first(root); node; node = rb\_next(node)) { tlink = rb\_entry(node, struct tcon\_link, tl\_rbnode); tcon = tlink\_tcon(tlink);@@ -481,11 +489,30 @@ void close\_all\_cached\_dirs(struct cifs\_sb\_info \*cifs\_sb) cfids = tcon->cfids; if (cfids == NULL) continue;+ spin\_lock(&cfids->cfid\_list\_lock); list\_for\_each\_entry(cfid, &cfids->entries, entry) {- dput(cfid->dentry);+ tmp\_list = kmalloc(sizeof(\*tmp\_list), GFP\_ATOMIC);+ if (tmp\_list == NULL)+ break;+ spin\_lock(&cfid->fid\_lock);+ tmp\_list->dentry = cfid->dentry; cfid->dentry = NULL;+ spin\_unlock(&cfid->fid\_lock);++ list\_add\_tail(&tmp\_list->entry, &entry); }+ spin\_unlock(&cfids->cfid\_list\_lock);+ }+ spin\_unlock(&cifs\_sb->tlink\_tree\_lock);++ list\_for\_each\_entry\_safe(tmp\_list, q, &entry, entry) {+ list\_del(&tmp\_list->entry);+ dput(tmp\_list->dentry);+ kfree(tmp\_list); }++ /\* Flush any pending work that will drop dentries \*/+ flush\_workqueue(cfid\_put\_wq); }  /\*@@ -496,14 +523,18 @@ void invalidate\_all\_cached\_dirs(struct cifs\_tcon \*tcon) { struct cached\_fids \*cfids = tcon->cfids; struct cached\_fid \*cfid, \*q;- LIST\_HEAD(entry);  if (cfids == NULL) return; + /\*+ \* Mark all the cfids as closed, and move them to the cfids->dying list.+ \* They'll be cleaned up later by cfids\_invalidation\_worker. Take+ \* a reference to each cfid during this process.+ \*/ spin\_lock(&cfids->cfid\_list\_lock); list\_for\_each\_entry\_safe(cfid, q, &cfids->entries, entry) {- list\_move(&cfid->entry, &entry);+ list\_move(&cfid->entry, &cfids->dying); cfids->num\_entries--; cfid->is\_open = false; cfid->on\_list = false;@@ -516,26 +547,47 @@ void invalidate\_all\_cached\_dirs(struct cifs\_tcon \*tcon) } else kref\_get(&cfid->refcount); }+ /\*+ \* Queue dropping of the dentries once locks have been dropped+ \*/+ if (!list\_empty(&cfids->dying))+ queue\_work(cfid\_put\_wq, &cfids->invalidation\_work); spin\_unlock(&cfids->cfid\_list\_lock);-- list\_for\_each\_entry\_safe(cfid, q, &entry, entry) {- list\_del(&cfid->entry);- cancel\_work\_sync(&cfid->lease\_break);- /\*- \* Drop the ref-count from above, either the lease-ref (if there- \* was one) or the extra one acquired.- \*/- kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);- } }  static void-smb2\_cached\_lease\_break(struct work\_struct \*work)+cached\_dir\_offload\_close(struct work\_struct \*work) { struct cached\_fid \*cfid = container\_of(work,- struct cached\_fid, lease\_break);+ struct cached\_fid, close\_work);+ struct cifs\_tcon \*tcon = cfid->tcon;++ WARN\_ON(cfid->on\_list);  kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);+ cifs\_put\_tcon(tcon, netfs\_trace\_tcon\_ref\_put\_cached\_close);+}++/\*+ \* Release the cached directory's dentry, and then queue work to drop cached+ \* directory itself (closing on server if needed).+ \*+ \* Must be called with a reference to the cached\_fid and a reference to the+ \* tcon.+ \*/+static void cached\_dir\_put\_work(struct work\_struct \*work)+{+ struct cached\_fid \*cfid = container\_of(work, struct cached\_fid,+ put\_work);+ struct dentry \*dentry;++ spin\_lock(&cfid->fid\_lock);+ dentry = cfid->dentry;+ cfid->dentry = NULL;+ spin\_unlock(&cfid->fid\_lock);++ dput(dentry);+ queue\_work(serverclose\_wq, &cfid->close\_work); }  int cached\_dir\_lease\_break(struct cifs\_tcon \*tcon, \_\_u8 lease\_key[16])@@ -562,8 +614,10 @@ int cached\_dir\_lease\_break(struct cifs\_tcon \*tcon, \_\_u8 lease\_key[16]) cfid->on\_list = false; cfids->num\_entries--; - queue\_work(cifsiod\_wq,- &cfid->lease\_break);+ ++tcon->tc\_count;+ trace\_smb3\_tcon\_ref(tcon->debug\_id, tcon->tc\_count,+ netfs\_trace\_tcon\_ref\_get\_cached\_lease\_break);+ queue\_work(cfid\_put\_wq, &cfid->put\_work); spin\_unlock(&cfids->cfid\_list\_lock); return true; }@@ -585,7 +639,8 @@ static struct cached\_fid \*init\_cached\_dir(const char \*path) return NULL; } - INIT\_WORK(&cfid->lease\_break, smb2\_cached\_lease\_break);+ INIT\_WORK(&cfid->close\_work, cached\_dir\_offload\_close);+ INIT\_WORK(&cfid->put\_work, cached\_dir\_put\_work); INIT\_LIST\_HEAD(&cfid->entry); INIT\_LIST\_HEAD(&cfid->dirents.entries); mutex\_init(&cfid->dirents.de\_mutex);@@ -598,6 +653,9 @@ static void free\_cached\_dir(struct cached\_fid \*cfid) { struct cached\_dirent \*dirent, \*q; + WARN\_ON(work\_pending(&cfid->close\_work));+ WARN\_ON(work\_pending(&cfid->put\_work));+ dput(cfid->dentry); cfid->dentry = NULL; @@ -615,10 +673,30 @@ static void free\_cached\_dir(struct cached\_fid \*cfid) kfree(cfid); } +static void cfids\_invalidation\_worker(struct work\_struct \*work)+{+ struct cached\_fids \*cfids = container\_of(work, struct cached\_fids,+ invalidation\_work);+ struct cached\_fid \*cfid, \*q;+ LIST\_HEAD(entry);++ spin\_lock(&cfids->cfid\_list\_lock);+ /\* move cfids->dying to the local list \*/+ list\_cut\_before(&entry, &cfids->dying, &cfids->dying);+ spin\_unlock(&cfids->cfid\_list\_lock);++ list\_for\_each\_entry\_safe(cfid, q, &entry, entry) {+ list\_del(&cfid->entry);+ /\* Drop the ref-count acquired in invalidate\_all\_cached\_dirs \*/+ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);+ }+}+ static void cfids\_laundromat\_worker(struct work\_struct \*work) { struct cached\_fids \*cfids; struct cached\_fid \*cfid, \*q;+ struct dentry \*dentry; LIST\_HEAD(entry);  cfids = container\_of(work, struct cached\_fids, laundromat\_work.work);@@ -644,18 +722,28 @@ static void cfids\_laundromat\_worker(struct work\_struct \*work)  list\_for\_each\_entry\_safe(cfid, q, &entry, entry) { list\_del(&cfid->entry);- /\*- \* Cancel and wait for the work to finish in case we are racing- \* with it.- \*/- cancel\_work\_sync(&cfid->lease\_break);- /\*- \* Drop the ref-count from above, either the lease-ref (if there- \* was one) or the extra one acquired.- \*/- kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);++ spin\_lock(&cfid->fid\_lock);+ dentry = cfid->dentry;+ cfid->dentry = NULL;+ spin\_unlock(&cfid->fid\_lock);++ dput(dentry);+ if (cfid->is\_open) {+ spin\_lock(&cifs\_tcp\_ses\_lock);+ ++cfid->tcon->tc\_count;+ trace\_smb3\_tcon\_ref(cfid->tcon->debug\_id, cfid->tcon->tc\_count,+ netfs\_trace\_tcon\_ref\_get\_cached\_laundromat);+ spin\_unlock(&cifs\_tcp\_ses\_lock);+ queue\_work(serverclose\_wq, &cfid->close\_work);+ } else+ /\*+ \* Drop the ref-count from above, either the lease-ref (if there+ \* was one) or the extra one acquired.+ \*/+ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); }- queue\_delayed\_work(cifsiod\_wq, &cfids->laundromat\_work,+ queue\_delayed\_work(cfid\_put\_wq, &cfids->laundromat\_work, dir\_cache\_timeout \* HZ); } @@ -668,9 +756,11 @@ struct cached\_fids \*init\_cached\_dirs(void) return NULL; spin\_lock\_init(&cfids->cfid\_list\_lock); INIT\_LIST\_HEAD(&cfids->entries);+ INIT\_LIST\_HEAD(&cfids->dying); + INIT\_WORK(&cfids->invalidation\_work, cfids\_invalidation\_worker); INIT\_DELAYED\_WORK(&cfids->laundromat\_work, cfids\_laundromat\_worker);- queue\_delayed\_work(cifsiod\_wq, &cfids->laundromat\_work,+ queue\_delayed\_work(cfid\_put\_wq, &cfids->laundromat\_work, dir\_cache\_timeout \* HZ);  return cfids;@@ -689,6 +779,7 @@ void free\_cached\_dirs(struct cached\_fids \*cfids) return;  cancel\_delayed\_work\_sync(&cfids->laundromat\_work);+ cancel\_work\_sync(&cfids->invalidation\_work);  spin\_lock(&cfids->cfid\_list\_lock); list\_for\_each\_entry\_safe(cfid, q, &cfids->entries, entry) {@@ -696,6 +787,11 @@ void free\_cached\_dirs(struct cached\_fids \*cfids) cfid->is\_open = false; list\_move(&cfid->entry, &entry); }+ list\_for\_each\_entry\_safe(cfid, q, &cfids->dying, entry) {+ cfid->on\_list = false;+ cfid->is\_open = false;+ list\_move(&cfid->entry, &entry);+ } spin\_unlock(&cfids->cfid\_list\_lock);  list\_for\_each\_entry\_safe(cfid, q, &entry, entry) {diff --git a/fs/smb/client/cached\_dir.h b/fs/smb/client/cached\_dir.hindex 81ba0fd5cc16d6..1dfe79d947a62f 100644--- a/[fs/smb/client/cached\_dir.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.h?id=796733054e4a55c78c1c58c6121a550667ebccbf)+++ b/[fs/smb/client/cached\_dir.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.h?id=3fa640d035e5ae526769615c35cb9ed4be6e3662)@@ -44,7 +44,8 @@ struct cached\_fid { spinlock\_t fid\_lock; struct cifs\_tcon \*tcon; struct dentry \*dentry;- struct work\_struct lease\_break;+ struct work\_struct put\_work;+ struct work\_struct close\_work; struct smb2\_file\_all\_info file\_all\_info; struct cached\_dirents dirents; };@@ -53,10 +54,13 @@ struct cached\_fid { struct cached\_fids { /\* Must be held when: \* - accessing the cfids->entries list+ \* - accessing the cfids->dying list \*/ spinlock\_t cfid\_list\_lock; int num\_entries; struct list\_head entries;+ struct list\_head dying;+ struct work\_struct invalidation\_work; struct delayed\_work laundromat\_work; }; diff --git a/fs/smb/client/cifsfs.c b/fs/smb/client/cifsfs.cindex 97985347102792..c9f9b6e9796483 100644--- a/[fs/smb/client/cifsfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsfs.c?id=796733054e4a55c78c1c58c6121a550667ebccbf)+++ b/[fs/smb/client/cifsfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsfs.c?id=3fa640d035e5ae526769615c35cb9ed4be6e3662)@@ -157,6 +157,7 @@ struct workqueue\_struct \*fileinfo\_put\_wq; struct workqueue\_struct \*cifsoplockd\_wq; struct workqueue\_struct \*deferredclose\_wq; struct workqueue\_struct \*serverclose\_wq;+struct workqueue\_struct \*cfid\_put\_wq; \_\_u32 cifs\_lock\_secret;  /\*@@ -1920,9 +1921,16 @@ init\_cifs(void) goto out\_destroy\_deferredclose\_wq; } + cfid\_put\_wq = alloc\_workqueue("cfid\_put\_wq",+ WQ\_FREEZABLE|WQ\_MEM\_RECLAIM, 0);+ if (!cfid\_put\_wq) {+ rc = -ENOMEM;+ goto out\_destroy\_serverclose\_wq;+ }+ rc = cifs\_init\_inodecache(); if (rc)- goto out\_destroy\_serverclose\_wq;+ goto out\_destroy\_cfid\_put\_wq;  rc = cifs\_init\_netfs(); if (rc)@@ -1990,6 +1998,8 @@ out\_destroy\_netfs: cifs\_destroy\_netfs(); out\_destroy\_inodecache: cifs\_destroy\_inodecache();+out\_destroy\_cfid\_put\_wq:+ destroy\_workqueue(cfid\_put\_wq); out\_destroy\_serverclose\_wq: destroy\_workqueue(serverclose\_wq); out\_destroy\_deferredclose\_wq:diff --git a/fs/smb/client/cifsglob.h b/fs/smb/client/cifsglob.hindex e97e6dfd665cdc..6e63abe461fd2e 100644--- a/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=796733054e4a55c78c1c58c6121a550667ebccbf)+++ b/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=3fa640d035e5ae526769615c35cb9ed4be6e3662)@@ -1991,7 +1991,7 @@ require use of the stronger protocol \*/ \* cifsInodeInfo->lock\_sem cifsInodeInfo->llist cifs\_init\_once \* ->can\_cache\_brlcks \* cifsInodeInfo->deferred\_lock cifsInodeInfo->deferred\_closes cifsInodeInfo\_alloc- \* cached\_fid->fid\_mutex cifs\_tcon->crfid tcon\_info\_alloc+ \* cached\_fids->cfid\_list\_lock cifs\_tcon->cfids->entries init\_cached\_dirs \* cifsFileInfo->fh\_mutex cifsFileInfo cifs\_new\_fileinfo \* cifsFileInfo->file\_info\_lock cifsFileInfo->count cifs\_new\_fileinfo \* ->invalidHandle initiate\_cifs\_search@@ -2079,6 +2079,7 @@ extern struct workqueue\_struct \*fileinfo\_put\_wq; extern struct workqueue\_struct \*cifsoplockd\_wq; extern struct workqueue\_struct \*deferredclose\_wq; extern struct workqueue\_struct \*serverclose\_wq;+extern struct workqueue\_struct \*cfid\_put\_wq; extern \_\_u32 cifs\_lock\_secret;  extern mempool\_t \*cifs\_sm\_req\_poolp;diff --git a/fs/smb/client/inode.c b/fs/smb/client/inode.cindex befe43460dcb28..42c030687918d3 100644--- a/[fs/smb/client/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/inode.c?id=796733054e4a55c78c1c58c6121a550667ebccbf)+++ b/[fs/smb/client/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/inode.c?id=3fa640d035e5ae526769615c35cb9ed4be6e3662)@@ -2496,13 +2496,10 @@ cifs\_dentry\_needs\_reval(struct dentry \*dentry) return true;  if (!open\_cached\_dir\_by\_dentry(tcon, dentry->d\_parent, &cfid)) {- spin\_lock(&cfid->fid\_lock); if (cfid->time && cifs\_i->time > cfid->time) {- spin\_unlock(&cfid->fid\_lock); close\_cached\_dir(cfid); return false; }- spin\_unlock(&cfid->fid\_lock); close\_cached\_dir(cfid); } /\*diff --git a/fs/smb/client/trace.h b/fs/smb/client/trace.hindex 0b52d22a91a0cb..12cbd3428a6da5 100644--- a/[fs/smb/client/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/trace.h?id=796733054e4a55c78c1c58c6121a550667ebccbf)+++ b/[fs/smb/client/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/trace.h?id=3fa640d035e5ae526769615c35cb9ed4be6e3662)@@ -44,6 +44,8 @@ EM(netfs\_trace\_tcon\_ref\_free\_ipc, "FRE Ipc ") \ EM(netfs\_trace\_tcon\_ref\_free\_ipc\_fail, "FRE Ipc-F ") \ EM(netfs\_trace\_tcon\_ref\_free\_reconnect\_server, "FRE Reconn") \+ EM(netfs\_trace\_tcon\_ref\_get\_cached\_laundromat, "GET Ch-Lau") \+ EM(netfs\_trace\_tcon\_ref\_get\_cached\_lease\_break, "GET Ch-Lea") \ EM(netfs\_trace\_tcon\_ref\_get\_cancelled\_close, "GET Cn-Cls") \ EM(netfs\_trace\_tcon\_ref\_get\_dfs\_refer, "GET DfsRef") \ EM(netfs\_trace\_tcon\_ref\_get\_find, "GET Find ") \@@ -52,6 +54,7 @@ EM(netfs\_trace\_tcon\_ref\_new, "NEW ") \ EM(netfs\_trace\_tcon\_ref\_new\_ipc, "NEW Ipc ") \ EM(netfs\_trace\_tcon\_ref\_new\_reconnect\_server, "NEW Reconn") \+ EM(netfs\_trace\_tcon\_ref\_put\_cached\_close, "PUT Ch-Cls") \ EM(netfs\_trace\_tcon\_ref\_put\_cancelled\_close, "PUT Cn-Cls") \ EM(netfs\_trace\_tcon\_ref\_put\_cancelled\_close\_fid, "PUT Cn-Fid") \ EM(netfs\_trace\_tcon\_ref\_put\_cancelled\_mid, "PUT Cn-Mid") \ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 22:10:56 +0000



=== Content from git.kernel.org_b983e412_20250114_221222.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Paul Aurich <paul@darkrain42.org> | 2024-11-18 13:50:28 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-05 13:54:24 +0100 |
| commit | [ff4528bbc82d0d90073751f7b49e7b9e9c7e5638](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638)) | |
| tree | [9d97eaceea43d50aae0c02aca9fc585fb0e876fa](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638) | |
| parent | [97e2afcac0bebfef6a5360f4267ce4c44507b845](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=97e2afcac0bebfef6a5360f4267ce4c44507b845) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638&id2=97e2afcac0bebfef6a5360f4267ce4c44507b845)) | |
| download | [linux-ff4528bbc82d0d90073751f7b49e7b9e9c7e5638.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-ff4528bbc82d0d90073751f7b49e7b9e9c7e5638.tar.gz) | |

smb: During unmount, ensure all cached dir instances drop their dentrycommit 3fa640d035e5ae526769615c35cb9ed4be6e3662 upstream.
The unmount process (cifs\_kill\_sb() calling close\_all\_cached\_dirs()) can
race with various cached directory operations, which ultimately results
in dentries not being dropped and these kernel BUGs:
BUG: Dentry ffff88814f37e358{i=1000000000080,n=/} still in use (2) [unmount of cifs cifs]
VFS: Busy inodes after unmount of cifs (cifs)
------------[ cut here ]------------
kernel BUG at fs/super.c:661!
This happens when a cfid is in the process of being cleaned up when, and
has been removed from the cfids->entries list, including:
- Receiving a lease break from the server
- Server reconnection triggers invalidate\_all\_cached\_dirs(), which
removes all the cfids from the list
- The laundromat thread decides to expire an old cfid.
To solve these problems, dropping the dentry is done in queued work done
in a newly-added cfid\_put\_wq workqueue, and close\_all\_cached\_dirs()
flushes that workqueue after it drops all the dentries of which it's
aware. This is a global workqueue (rather than scoped to a mount), but
the queued work is minimal.
The final cleanup work for cleaning up a cfid is performed via work
queued in the serverclose\_wq workqueue; this is done separate from
dropping the dentries so that close\_all\_cached\_dirs() doesn't block on
any server operations.
Both of these queued works expect to invoked with a cfid reference and
a tcon reference to avoid those objects from being freed while the work
is ongoing.
While we're here, add proper locking to close\_all\_cached\_dirs(), and
locking around the freeing of cfid->dentry.
Fixes: ebe98f1447bb ("cifs: enable caching of directories for which a lease is held")
Cc: stable@vger.kernel.org
Signed-off-by: Paul Aurich <paul@darkrain42.org>
Signed-off-by: Steve French <stfrench@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638)

| -rw-r--r-- | [fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cached_dir.c?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638) | 156 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/smb/client/cached\_dir.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cached_dir.h?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/cifsfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsfs.c?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsglob.h?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/inode.c?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/trace.h?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638) | 3 | |  |  |  | | --- | --- | --- | |

6 files changed, 147 insertions, 36 deletions

| diff --git a/fs/smb/client/cached\_dir.c b/fs/smb/client/cached\_dir.cindex 06eb19dabb0ecc..004349a7ab69d2 100644--- a/[fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.c?id=97e2afcac0bebfef6a5360f4267ce4c44507b845)+++ b/[fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.c?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638)@@ -17,6 +17,11 @@ static void free\_cached\_dir(struct cached\_fid \*cfid); static void smb2\_close\_cached\_fid(struct kref \*ref); static void cfids\_laundromat\_worker(struct work\_struct \*work); +struct cached\_dir\_dentry {+ struct list\_head entry;+ struct dentry \*dentry;+};+ static struct cached\_fid \*find\_or\_create\_cached\_dir(struct cached\_fids \*cfids, const char \*path, bool lookup\_only,@@ -470,7 +475,10 @@ void close\_all\_cached\_dirs(struct cifs\_sb\_info \*cifs\_sb) struct cifs\_tcon \*tcon; struct tcon\_link \*tlink; struct cached\_fids \*cfids;+ struct cached\_dir\_dentry \*tmp\_list, \*q;+ LIST\_HEAD(entry); + spin\_lock(&cifs\_sb->tlink\_tree\_lock); for (node = rb\_first(root); node; node = rb\_next(node)) { tlink = rb\_entry(node, struct tcon\_link, tl\_rbnode); tcon = tlink\_tcon(tlink);@@ -479,11 +487,30 @@ void close\_all\_cached\_dirs(struct cifs\_sb\_info \*cifs\_sb) cfids = tcon->cfids; if (cfids == NULL) continue;+ spin\_lock(&cfids->cfid\_list\_lock); list\_for\_each\_entry(cfid, &cfids->entries, entry) {- dput(cfid->dentry);+ tmp\_list = kmalloc(sizeof(\*tmp\_list), GFP\_ATOMIC);+ if (tmp\_list == NULL)+ break;+ spin\_lock(&cfid->fid\_lock);+ tmp\_list->dentry = cfid->dentry; cfid->dentry = NULL;+ spin\_unlock(&cfid->fid\_lock);++ list\_add\_tail(&tmp\_list->entry, &entry); }+ spin\_unlock(&cfids->cfid\_list\_lock);+ }+ spin\_unlock(&cifs\_sb->tlink\_tree\_lock);++ list\_for\_each\_entry\_safe(tmp\_list, q, &entry, entry) {+ list\_del(&tmp\_list->entry);+ dput(tmp\_list->dentry);+ kfree(tmp\_list); }++ /\* Flush any pending work that will drop dentries \*/+ flush\_workqueue(cfid\_put\_wq); }  /\*@@ -494,14 +521,18 @@ void invalidate\_all\_cached\_dirs(struct cifs\_tcon \*tcon) { struct cached\_fids \*cfids = tcon->cfids; struct cached\_fid \*cfid, \*q;- LIST\_HEAD(entry);  if (cfids == NULL) return; + /\*+ \* Mark all the cfids as closed, and move them to the cfids->dying list.+ \* They'll be cleaned up later by cfids\_invalidation\_worker. Take+ \* a reference to each cfid during this process.+ \*/ spin\_lock(&cfids->cfid\_list\_lock); list\_for\_each\_entry\_safe(cfid, q, &cfids->entries, entry) {- list\_move(&cfid->entry, &entry);+ list\_move(&cfid->entry, &cfids->dying); cfids->num\_entries--; cfid->is\_open = false; cfid->on\_list = false;@@ -514,26 +545,47 @@ void invalidate\_all\_cached\_dirs(struct cifs\_tcon \*tcon) } else kref\_get(&cfid->refcount); }+ /\*+ \* Queue dropping of the dentries once locks have been dropped+ \*/+ if (!list\_empty(&cfids->dying))+ queue\_work(cfid\_put\_wq, &cfids->invalidation\_work); spin\_unlock(&cfids->cfid\_list\_lock);-- list\_for\_each\_entry\_safe(cfid, q, &entry, entry) {- list\_del(&cfid->entry);- cancel\_work\_sync(&cfid->lease\_break);- /\*- \* Drop the ref-count from above, either the lease-ref (if there- \* was one) or the extra one acquired.- \*/- kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);- } }  static void-smb2\_cached\_lease\_break(struct work\_struct \*work)+cached\_dir\_offload\_close(struct work\_struct \*work) { struct cached\_fid \*cfid = container\_of(work,- struct cached\_fid, lease\_break);+ struct cached\_fid, close\_work);+ struct cifs\_tcon \*tcon = cfid->tcon;++ WARN\_ON(cfid->on\_list);  kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);+ cifs\_put\_tcon(tcon, netfs\_trace\_tcon\_ref\_put\_cached\_close);+}++/\*+ \* Release the cached directory's dentry, and then queue work to drop cached+ \* directory itself (closing on server if needed).+ \*+ \* Must be called with a reference to the cached\_fid and a reference to the+ \* tcon.+ \*/+static void cached\_dir\_put\_work(struct work\_struct \*work)+{+ struct cached\_fid \*cfid = container\_of(work, struct cached\_fid,+ put\_work);+ struct dentry \*dentry;++ spin\_lock(&cfid->fid\_lock);+ dentry = cfid->dentry;+ cfid->dentry = NULL;+ spin\_unlock(&cfid->fid\_lock);++ dput(dentry);+ queue\_work(serverclose\_wq, &cfid->close\_work); }  int cached\_dir\_lease\_break(struct cifs\_tcon \*tcon, \_\_u8 lease\_key[16])@@ -560,8 +612,10 @@ int cached\_dir\_lease\_break(struct cifs\_tcon \*tcon, \_\_u8 lease\_key[16]) cfid->on\_list = false; cfids->num\_entries--; - queue\_work(cifsiod\_wq,- &cfid->lease\_break);+ ++tcon->tc\_count;+ trace\_smb3\_tcon\_ref(tcon->debug\_id, tcon->tc\_count,+ netfs\_trace\_tcon\_ref\_get\_cached\_lease\_break);+ queue\_work(cfid\_put\_wq, &cfid->put\_work); spin\_unlock(&cfids->cfid\_list\_lock); return true; }@@ -583,7 +637,8 @@ static struct cached\_fid \*init\_cached\_dir(const char \*path) return NULL; } - INIT\_WORK(&cfid->lease\_break, smb2\_cached\_lease\_break);+ INIT\_WORK(&cfid->close\_work, cached\_dir\_offload\_close);+ INIT\_WORK(&cfid->put\_work, cached\_dir\_put\_work); INIT\_LIST\_HEAD(&cfid->entry); INIT\_LIST\_HEAD(&cfid->dirents.entries); mutex\_init(&cfid->dirents.de\_mutex);@@ -596,6 +651,9 @@ static void free\_cached\_dir(struct cached\_fid \*cfid) { struct cached\_dirent \*dirent, \*q; + WARN\_ON(work\_pending(&cfid->close\_work));+ WARN\_ON(work\_pending(&cfid->put\_work));+ dput(cfid->dentry); cfid->dentry = NULL; @@ -613,10 +671,30 @@ static void free\_cached\_dir(struct cached\_fid \*cfid) kfree(cfid); } +static void cfids\_invalidation\_worker(struct work\_struct \*work)+{+ struct cached\_fids \*cfids = container\_of(work, struct cached\_fids,+ invalidation\_work);+ struct cached\_fid \*cfid, \*q;+ LIST\_HEAD(entry);++ spin\_lock(&cfids->cfid\_list\_lock);+ /\* move cfids->dying to the local list \*/+ list\_cut\_before(&entry, &cfids->dying, &cfids->dying);+ spin\_unlock(&cfids->cfid\_list\_lock);++ list\_for\_each\_entry\_safe(cfid, q, &entry, entry) {+ list\_del(&cfid->entry);+ /\* Drop the ref-count acquired in invalidate\_all\_cached\_dirs \*/+ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);+ }+}+ static void cfids\_laundromat\_worker(struct work\_struct \*work) { struct cached\_fids \*cfids; struct cached\_fid \*cfid, \*q;+ struct dentry \*dentry; LIST\_HEAD(entry);  cfids = container\_of(work, struct cached\_fids, laundromat\_work.work);@@ -642,18 +720,28 @@ static void cfids\_laundromat\_worker(struct work\_struct \*work)  list\_for\_each\_entry\_safe(cfid, q, &entry, entry) { list\_del(&cfid->entry);- /\*- \* Cancel and wait for the work to finish in case we are racing- \* with it.- \*/- cancel\_work\_sync(&cfid->lease\_break);- /\*- \* Drop the ref-count from above, either the lease-ref (if there- \* was one) or the extra one acquired.- \*/- kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);++ spin\_lock(&cfid->fid\_lock);+ dentry = cfid->dentry;+ cfid->dentry = NULL;+ spin\_unlock(&cfid->fid\_lock);++ dput(dentry);+ if (cfid->is\_open) {+ spin\_lock(&cifs\_tcp\_ses\_lock);+ ++cfid->tcon->tc\_count;+ trace\_smb3\_tcon\_ref(cfid->tcon->debug\_id, cfid->tcon->tc\_count,+ netfs\_trace\_tcon\_ref\_get\_cached\_laundromat);+ spin\_unlock(&cifs\_tcp\_ses\_lock);+ queue\_work(serverclose\_wq, &cfid->close\_work);+ } else+ /\*+ \* Drop the ref-count from above, either the lease-ref (if there+ \* was one) or the extra one acquired.+ \*/+ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); }- queue\_delayed\_work(cifsiod\_wq, &cfids->laundromat\_work,+ queue\_delayed\_work(cfid\_put\_wq, &cfids->laundromat\_work, dir\_cache\_timeout \* HZ); } @@ -666,9 +754,11 @@ struct cached\_fids \*init\_cached\_dirs(void) return NULL; spin\_lock\_init(&cfids->cfid\_list\_lock); INIT\_LIST\_HEAD(&cfids->entries);+ INIT\_LIST\_HEAD(&cfids->dying); + INIT\_WORK(&cfids->invalidation\_work, cfids\_invalidation\_worker); INIT\_DELAYED\_WORK(&cfids->laundromat\_work, cfids\_laundromat\_worker);- queue\_delayed\_work(cifsiod\_wq, &cfids->laundromat\_work,+ queue\_delayed\_work(cfid\_put\_wq, &cfids->laundromat\_work, dir\_cache\_timeout \* HZ);  return cfids;@@ -687,6 +777,7 @@ void free\_cached\_dirs(struct cached\_fids \*cfids) return;  cancel\_delayed\_work\_sync(&cfids->laundromat\_work);+ cancel\_work\_sync(&cfids->invalidation\_work);  spin\_lock(&cfids->cfid\_list\_lock); list\_for\_each\_entry\_safe(cfid, q, &cfids->entries, entry) {@@ -694,6 +785,11 @@ void free\_cached\_dirs(struct cached\_fids \*cfids) cfid->is\_open = false; list\_move(&cfid->entry, &entry); }+ list\_for\_each\_entry\_safe(cfid, q, &cfids->dying, entry) {+ cfid->on\_list = false;+ cfid->is\_open = false;+ list\_move(&cfid->entry, &entry);+ } spin\_unlock(&cfids->cfid\_list\_lock);  list\_for\_each\_entry\_safe(cfid, q, &entry, entry) {diff --git a/fs/smb/client/cached\_dir.h b/fs/smb/client/cached\_dir.hindex 81ba0fd5cc16d6..1dfe79d947a62f 100644--- a/[fs/smb/client/cached\_dir.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.h?id=97e2afcac0bebfef6a5360f4267ce4c44507b845)+++ b/[fs/smb/client/cached\_dir.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.h?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638)@@ -44,7 +44,8 @@ struct cached\_fid { spinlock\_t fid\_lock; struct cifs\_tcon \*tcon; struct dentry \*dentry;- struct work\_struct lease\_break;+ struct work\_struct put\_work;+ struct work\_struct close\_work; struct smb2\_file\_all\_info file\_all\_info; struct cached\_dirents dirents; };@@ -53,10 +54,13 @@ struct cached\_fid { struct cached\_fids { /\* Must be held when: \* - accessing the cfids->entries list+ \* - accessing the cfids->dying list \*/ spinlock\_t cfid\_list\_lock; int num\_entries; struct list\_head entries;+ struct list\_head dying;+ struct work\_struct invalidation\_work; struct delayed\_work laundromat\_work; }; diff --git a/fs/smb/client/cifsfs.c b/fs/smb/client/cifsfs.cindex 9bdb6e7f1dc3a9..44a367e21804d7 100644--- a/[fs/smb/client/cifsfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsfs.c?id=97e2afcac0bebfef6a5360f4267ce4c44507b845)+++ b/[fs/smb/client/cifsfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsfs.c?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638)@@ -157,6 +157,7 @@ struct workqueue\_struct \*fileinfo\_put\_wq; struct workqueue\_struct \*cifsoplockd\_wq; struct workqueue\_struct \*deferredclose\_wq; struct workqueue\_struct \*serverclose\_wq;+struct workqueue\_struct \*cfid\_put\_wq; \_\_u32 cifs\_lock\_secret;  /\*@@ -1895,9 +1896,16 @@ init\_cifs(void) goto out\_destroy\_deferredclose\_wq; } + cfid\_put\_wq = alloc\_workqueue("cfid\_put\_wq",+ WQ\_FREEZABLE|WQ\_MEM\_RECLAIM, 0);+ if (!cfid\_put\_wq) {+ rc = -ENOMEM;+ goto out\_destroy\_serverclose\_wq;+ }+ rc = cifs\_init\_inodecache(); if (rc)- goto out\_destroy\_serverclose\_wq;+ goto out\_destroy\_cfid\_put\_wq;  rc = cifs\_init\_netfs(); if (rc)@@ -1965,6 +1973,8 @@ out\_destroy\_netfs: cifs\_destroy\_netfs(); out\_destroy\_inodecache: cifs\_destroy\_inodecache();+out\_destroy\_cfid\_put\_wq:+ destroy\_workqueue(cfid\_put\_wq); out\_destroy\_serverclose\_wq: destroy\_workqueue(serverclose\_wq); out\_destroy\_deferredclose\_wq:diff --git a/fs/smb/client/cifsglob.h b/fs/smb/client/cifsglob.hindex 59f649da5fdde7..1dfedb64ffcbcd 100644--- a/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=97e2afcac0bebfef6a5360f4267ce4c44507b845)+++ b/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638)@@ -1982,7 +1982,7 @@ require use of the stronger protocol \*/ \* cifsInodeInfo->lock\_sem cifsInodeInfo->llist cifs\_init\_once \* ->can\_cache\_brlcks \* cifsInodeInfo->deferred\_lock cifsInodeInfo->deferred\_closes cifsInodeInfo\_alloc- \* cached\_fid->fid\_mutex cifs\_tcon->crfid tcon\_info\_alloc+ \* cached\_fids->cfid\_list\_lock cifs\_tcon->cfids->entries init\_cached\_dirs \* cifsFileInfo->fh\_mutex cifsFileInfo cifs\_new\_fileinfo \* cifsFileInfo->file\_info\_lock cifsFileInfo->count cifs\_new\_fileinfo \* ->invalidHandle initiate\_cifs\_search@@ -2070,6 +2070,7 @@ extern struct workqueue\_struct \*fileinfo\_put\_wq; extern struct workqueue\_struct \*cifsoplockd\_wq; extern struct workqueue\_struct \*deferredclose\_wq; extern struct workqueue\_struct \*serverclose\_wq;+extern struct workqueue\_struct \*cfid\_put\_wq; extern \_\_u32 cifs\_lock\_secret;  extern mempool\_t \*cifs\_sm\_req\_poolp;diff --git a/fs/smb/client/inode.c b/fs/smb/client/inode.cindex 54579a2003ac6a..ede36884be8ae2 100644--- a/[fs/smb/client/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/inode.c?id=97e2afcac0bebfef6a5360f4267ce4c44507b845)+++ b/[fs/smb/client/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/inode.c?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638)@@ -2433,13 +2433,10 @@ cifs\_dentry\_needs\_reval(struct dentry \*dentry) return true;  if (!open\_cached\_dir\_by\_dentry(tcon, dentry->d\_parent, &cfid)) {- spin\_lock(&cfid->fid\_lock); if (cfid->time && cifs\_i->time > cfid->time) {- spin\_unlock(&cfid->fid\_lock); close\_cached\_dir(cfid); return false; }- spin\_unlock(&cfid->fid\_lock); close\_cached\_dir(cfid); } /\*diff --git a/fs/smb/client/trace.h b/fs/smb/client/trace.hindex 8e9964001e2aed..f3a261d0102d49 100644--- a/[fs/smb/client/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/trace.h?id=97e2afcac0bebfef6a5360f4267ce4c44507b845)+++ b/[fs/smb/client/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/trace.h?id=ff4528bbc82d0d90073751f7b49e7b9e9c7e5638)@@ -44,6 +44,8 @@ EM(netfs\_trace\_tcon\_ref\_free\_ipc, "FRE Ipc ") \ EM(netfs\_trace\_tcon\_ref\_free\_ipc\_fail, "FRE Ipc-F ") \ EM(netfs\_trace\_tcon\_ref\_free\_reconnect\_server, "FRE Reconn") \+ EM(netfs\_trace\_tcon\_ref\_get\_cached\_laundromat, "GET Ch-Lau") \+ EM(netfs\_trace\_tcon\_ref\_get\_cached\_lease\_break, "GET Ch-Lea") \ EM(netfs\_trace\_tcon\_ref\_get\_cancelled\_close, "GET Cn-Cls") \ EM(netfs\_trace\_tcon\_ref\_get\_dfs\_refer, "GET DfsRef") \ EM(netfs\_trace\_tcon\_ref\_get\_find, "GET Find ") \@@ -52,6 +54,7 @@ EM(netfs\_trace\_tcon\_ref\_new, "NEW ") \ EM(netfs\_trace\_tcon\_ref\_new\_ipc, "NEW Ipc ") \ EM(netfs\_trace\_tcon\_ref\_new\_reconnect\_server, "NEW Reconn") \+ EM(netfs\_trace\_tcon\_ref\_put\_cached\_close, "PUT Ch-Cls") \ EM(netfs\_trace\_tcon\_ref\_put\_cancelled\_close, "PUT Cn-Cls") \ EM(netfs\_trace\_tcon\_ref\_put\_cancelled\_close\_fid, "PUT Cn-Fid") \ EM(netfs\_trace\_tcon\_ref\_put\_cancelled\_mid, "PUT Cn-Mid") \ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 22:10:59 +0000



=== Content from git.kernel.org_c05d967f_20250114_221220.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=548812afd96982a76a93ba76c0582ea670c40d9e)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=548812afd96982a76a93ba76c0582ea670c40d9e)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=548812afd96982a76a93ba76c0582ea670c40d9e)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=548812afd96982a76a93ba76c0582ea670c40d9e)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Paul Aurich <paul@darkrain42.org> | 2024-11-18 13:50:28 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-05 14:03:00 +0100 |
| commit | [548812afd96982a76a93ba76c0582ea670c40d9e](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=548812afd96982a76a93ba76c0582ea670c40d9e) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=548812afd96982a76a93ba76c0582ea670c40d9e)) | |
| tree | [1796a1b817caab757bdcceb13dacb4067caffa61](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=548812afd96982a76a93ba76c0582ea670c40d9e) | |
| parent | [47655a12c6b1bca8fa230085eab2e85a076932b7](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=47655a12c6b1bca8fa230085eab2e85a076932b7) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=548812afd96982a76a93ba76c0582ea670c40d9e&id2=47655a12c6b1bca8fa230085eab2e85a076932b7)) | |
| download | [linux-548812afd96982a76a93ba76c0582ea670c40d9e.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-548812afd96982a76a93ba76c0582ea670c40d9e.tar.gz) | |

smb: During unmount, ensure all cached dir instances drop their dentrycommit 3fa640d035e5ae526769615c35cb9ed4be6e3662 upstream.
The unmount process (cifs\_kill\_sb() calling close\_all\_cached\_dirs()) can
race with various cached directory operations, which ultimately results
in dentries not being dropped and these kernel BUGs:
BUG: Dentry ffff88814f37e358{i=1000000000080,n=/} still in use (2) [unmount of cifs cifs]
VFS: Busy inodes after unmount of cifs (cifs)
------------[ cut here ]------------
kernel BUG at fs/super.c:661!
This happens when a cfid is in the process of being cleaned up when, and
has been removed from the cfids->entries list, including:
- Receiving a lease break from the server
- Server reconnection triggers invalidate\_all\_cached\_dirs(), which
removes all the cfids from the list
- The laundromat thread decides to expire an old cfid.
To solve these problems, dropping the dentry is done in queued work done
in a newly-added cfid\_put\_wq workqueue, and close\_all\_cached\_dirs()
flushes that workqueue after it drops all the dentries of which it's
aware. This is a global workqueue (rather than scoped to a mount), but
the queued work is minimal.
The final cleanup work for cleaning up a cfid is performed via work
queued in the serverclose\_wq workqueue; this is done separate from
dropping the dentries so that close\_all\_cached\_dirs() doesn't block on
any server operations.
Both of these queued works expect to invoked with a cfid reference and
a tcon reference to avoid those objects from being freed while the work
is ongoing.
While we're here, add proper locking to close\_all\_cached\_dirs(), and
locking around the freeing of cfid->dentry.
Fixes: ebe98f1447bb ("cifs: enable caching of directories for which a lease is held")
Cc: stable@vger.kernel.org
Signed-off-by: Paul Aurich <paul@darkrain42.org>
Signed-off-by: Steve French <stfrench@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=548812afd96982a76a93ba76c0582ea670c40d9e)

| -rw-r--r-- | [fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cached_dir.c?id=548812afd96982a76a93ba76c0582ea670c40d9e) | 156 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/smb/client/cached\_dir.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cached_dir.h?id=548812afd96982a76a93ba76c0582ea670c40d9e) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/cifsfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsfs.c?id=548812afd96982a76a93ba76c0582ea670c40d9e) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsglob.h?id=548812afd96982a76a93ba76c0582ea670c40d9e) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/inode.c?id=548812afd96982a76a93ba76c0582ea670c40d9e) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/trace.h?id=548812afd96982a76a93ba76c0582ea670c40d9e) | 3 | |  |  |  | | --- | --- | --- | |

6 files changed, 147 insertions, 36 deletions

| diff --git a/fs/smb/client/cached\_dir.c b/fs/smb/client/cached\_dir.cindex 06eb19dabb0ecc..004349a7ab69d2 100644--- a/[fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.c?id=47655a12c6b1bca8fa230085eab2e85a076932b7)+++ b/[fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.c?id=548812afd96982a76a93ba76c0582ea670c40d9e)@@ -17,6 +17,11 @@ static void free\_cached\_dir(struct cached\_fid \*cfid); static void smb2\_close\_cached\_fid(struct kref \*ref); static void cfids\_laundromat\_worker(struct work\_struct \*work); +struct cached\_dir\_dentry {+ struct list\_head entry;+ struct dentry \*dentry;+};+ static struct cached\_fid \*find\_or\_create\_cached\_dir(struct cached\_fids \*cfids, const char \*path, bool lookup\_only,@@ -470,7 +475,10 @@ void close\_all\_cached\_dirs(struct cifs\_sb\_info \*cifs\_sb) struct cifs\_tcon \*tcon; struct tcon\_link \*tlink; struct cached\_fids \*cfids;+ struct cached\_dir\_dentry \*tmp\_list, \*q;+ LIST\_HEAD(entry); + spin\_lock(&cifs\_sb->tlink\_tree\_lock); for (node = rb\_first(root); node; node = rb\_next(node)) { tlink = rb\_entry(node, struct tcon\_link, tl\_rbnode); tcon = tlink\_tcon(tlink);@@ -479,11 +487,30 @@ void close\_all\_cached\_dirs(struct cifs\_sb\_info \*cifs\_sb) cfids = tcon->cfids; if (cfids == NULL) continue;+ spin\_lock(&cfids->cfid\_list\_lock); list\_for\_each\_entry(cfid, &cfids->entries, entry) {- dput(cfid->dentry);+ tmp\_list = kmalloc(sizeof(\*tmp\_list), GFP\_ATOMIC);+ if (tmp\_list == NULL)+ break;+ spin\_lock(&cfid->fid\_lock);+ tmp\_list->dentry = cfid->dentry; cfid->dentry = NULL;+ spin\_unlock(&cfid->fid\_lock);++ list\_add\_tail(&tmp\_list->entry, &entry); }+ spin\_unlock(&cfids->cfid\_list\_lock);+ }+ spin\_unlock(&cifs\_sb->tlink\_tree\_lock);++ list\_for\_each\_entry\_safe(tmp\_list, q, &entry, entry) {+ list\_del(&tmp\_list->entry);+ dput(tmp\_list->dentry);+ kfree(tmp\_list); }++ /\* Flush any pending work that will drop dentries \*/+ flush\_workqueue(cfid\_put\_wq); }  /\*@@ -494,14 +521,18 @@ void invalidate\_all\_cached\_dirs(struct cifs\_tcon \*tcon) { struct cached\_fids \*cfids = tcon->cfids; struct cached\_fid \*cfid, \*q;- LIST\_HEAD(entry);  if (cfids == NULL) return; + /\*+ \* Mark all the cfids as closed, and move them to the cfids->dying list.+ \* They'll be cleaned up later by cfids\_invalidation\_worker. Take+ \* a reference to each cfid during this process.+ \*/ spin\_lock(&cfids->cfid\_list\_lock); list\_for\_each\_entry\_safe(cfid, q, &cfids->entries, entry) {- list\_move(&cfid->entry, &entry);+ list\_move(&cfid->entry, &cfids->dying); cfids->num\_entries--; cfid->is\_open = false; cfid->on\_list = false;@@ -514,26 +545,47 @@ void invalidate\_all\_cached\_dirs(struct cifs\_tcon \*tcon) } else kref\_get(&cfid->refcount); }+ /\*+ \* Queue dropping of the dentries once locks have been dropped+ \*/+ if (!list\_empty(&cfids->dying))+ queue\_work(cfid\_put\_wq, &cfids->invalidation\_work); spin\_unlock(&cfids->cfid\_list\_lock);-- list\_for\_each\_entry\_safe(cfid, q, &entry, entry) {- list\_del(&cfid->entry);- cancel\_work\_sync(&cfid->lease\_break);- /\*- \* Drop the ref-count from above, either the lease-ref (if there- \* was one) or the extra one acquired.- \*/- kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);- } }  static void-smb2\_cached\_lease\_break(struct work\_struct \*work)+cached\_dir\_offload\_close(struct work\_struct \*work) { struct cached\_fid \*cfid = container\_of(work,- struct cached\_fid, lease\_break);+ struct cached\_fid, close\_work);+ struct cifs\_tcon \*tcon = cfid->tcon;++ WARN\_ON(cfid->on\_list);  kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);+ cifs\_put\_tcon(tcon, netfs\_trace\_tcon\_ref\_put\_cached\_close);+}++/\*+ \* Release the cached directory's dentry, and then queue work to drop cached+ \* directory itself (closing on server if needed).+ \*+ \* Must be called with a reference to the cached\_fid and a reference to the+ \* tcon.+ \*/+static void cached\_dir\_put\_work(struct work\_struct \*work)+{+ struct cached\_fid \*cfid = container\_of(work, struct cached\_fid,+ put\_work);+ struct dentry \*dentry;++ spin\_lock(&cfid->fid\_lock);+ dentry = cfid->dentry;+ cfid->dentry = NULL;+ spin\_unlock(&cfid->fid\_lock);++ dput(dentry);+ queue\_work(serverclose\_wq, &cfid->close\_work); }  int cached\_dir\_lease\_break(struct cifs\_tcon \*tcon, \_\_u8 lease\_key[16])@@ -560,8 +612,10 @@ int cached\_dir\_lease\_break(struct cifs\_tcon \*tcon, \_\_u8 lease\_key[16]) cfid->on\_list = false; cfids->num\_entries--; - queue\_work(cifsiod\_wq,- &cfid->lease\_break);+ ++tcon->tc\_count;+ trace\_smb3\_tcon\_ref(tcon->debug\_id, tcon->tc\_count,+ netfs\_trace\_tcon\_ref\_get\_cached\_lease\_break);+ queue\_work(cfid\_put\_wq, &cfid->put\_work); spin\_unlock(&cfids->cfid\_list\_lock); return true; }@@ -583,7 +637,8 @@ static struct cached\_fid \*init\_cached\_dir(const char \*path) return NULL; } - INIT\_WORK(&cfid->lease\_break, smb2\_cached\_lease\_break);+ INIT\_WORK(&cfid->close\_work, cached\_dir\_offload\_close);+ INIT\_WORK(&cfid->put\_work, cached\_dir\_put\_work); INIT\_LIST\_HEAD(&cfid->entry); INIT\_LIST\_HEAD(&cfid->dirents.entries); mutex\_init(&cfid->dirents.de\_mutex);@@ -596,6 +651,9 @@ static void free\_cached\_dir(struct cached\_fid \*cfid) { struct cached\_dirent \*dirent, \*q; + WARN\_ON(work\_pending(&cfid->close\_work));+ WARN\_ON(work\_pending(&cfid->put\_work));+ dput(cfid->dentry); cfid->dentry = NULL; @@ -613,10 +671,30 @@ static void free\_cached\_dir(struct cached\_fid \*cfid) kfree(cfid); } +static void cfids\_invalidation\_worker(struct work\_struct \*work)+{+ struct cached\_fids \*cfids = container\_of(work, struct cached\_fids,+ invalidation\_work);+ struct cached\_fid \*cfid, \*q;+ LIST\_HEAD(entry);++ spin\_lock(&cfids->cfid\_list\_lock);+ /\* move cfids->dying to the local list \*/+ list\_cut\_before(&entry, &cfids->dying, &cfids->dying);+ spin\_unlock(&cfids->cfid\_list\_lock);++ list\_for\_each\_entry\_safe(cfid, q, &entry, entry) {+ list\_del(&cfid->entry);+ /\* Drop the ref-count acquired in invalidate\_all\_cached\_dirs \*/+ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);+ }+}+ static void cfids\_laundromat\_worker(struct work\_struct \*work) { struct cached\_fids \*cfids; struct cached\_fid \*cfid, \*q;+ struct dentry \*dentry; LIST\_HEAD(entry);  cfids = container\_of(work, struct cached\_fids, laundromat\_work.work);@@ -642,18 +720,28 @@ static void cfids\_laundromat\_worker(struct work\_struct \*work)  list\_for\_each\_entry\_safe(cfid, q, &entry, entry) { list\_del(&cfid->entry);- /\*- \* Cancel and wait for the work to finish in case we are racing- \* with it.- \*/- cancel\_work\_sync(&cfid->lease\_break);- /\*- \* Drop the ref-count from above, either the lease-ref (if there- \* was one) or the extra one acquired.- \*/- kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);++ spin\_lock(&cfid->fid\_lock);+ dentry = cfid->dentry;+ cfid->dentry = NULL;+ spin\_unlock(&cfid->fid\_lock);++ dput(dentry);+ if (cfid->is\_open) {+ spin\_lock(&cifs\_tcp\_ses\_lock);+ ++cfid->tcon->tc\_count;+ trace\_smb3\_tcon\_ref(cfid->tcon->debug\_id, cfid->tcon->tc\_count,+ netfs\_trace\_tcon\_ref\_get\_cached\_laundromat);+ spin\_unlock(&cifs\_tcp\_ses\_lock);+ queue\_work(serverclose\_wq, &cfid->close\_work);+ } else+ /\*+ \* Drop the ref-count from above, either the lease-ref (if there+ \* was one) or the extra one acquired.+ \*/+ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); }- queue\_delayed\_work(cifsiod\_wq, &cfids->laundromat\_work,+ queue\_delayed\_work(cfid\_put\_wq, &cfids->laundromat\_work, dir\_cache\_timeout \* HZ); } @@ -666,9 +754,11 @@ struct cached\_fids \*init\_cached\_dirs(void) return NULL; spin\_lock\_init(&cfids->cfid\_list\_lock); INIT\_LIST\_HEAD(&cfids->entries);+ INIT\_LIST\_HEAD(&cfids->dying); + INIT\_WORK(&cfids->invalidation\_work, cfids\_invalidation\_worker); INIT\_DELAYED\_WORK(&cfids->laundromat\_work, cfids\_laundromat\_worker);- queue\_delayed\_work(cifsiod\_wq, &cfids->laundromat\_work,+ queue\_delayed\_work(cfid\_put\_wq, &cfids->laundromat\_work, dir\_cache\_timeout \* HZ);  return cfids;@@ -687,6 +777,7 @@ void free\_cached\_dirs(struct cached\_fids \*cfids) return;  cancel\_delayed\_work\_sync(&cfids->laundromat\_work);+ cancel\_work\_sync(&cfids->invalidation\_work);  spin\_lock(&cfids->cfid\_list\_lock); list\_for\_each\_entry\_safe(cfid, q, &cfids->entries, entry) {@@ -694,6 +785,11 @@ void free\_cached\_dirs(struct cached\_fids \*cfids) cfid->is\_open = false; list\_move(&cfid->entry, &entry); }+ list\_for\_each\_entry\_safe(cfid, q, &cfids->dying, entry) {+ cfid->on\_list = false;+ cfid->is\_open = false;+ list\_move(&cfid->entry, &entry);+ } spin\_unlock(&cfids->cfid\_list\_lock);  list\_for\_each\_entry\_safe(cfid, q, &entry, entry) {diff --git a/fs/smb/client/cached\_dir.h b/fs/smb/client/cached\_dir.hindex 81ba0fd5cc16d6..1dfe79d947a62f 100644--- a/[fs/smb/client/cached\_dir.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.h?id=47655a12c6b1bca8fa230085eab2e85a076932b7)+++ b/[fs/smb/client/cached\_dir.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.h?id=548812afd96982a76a93ba76c0582ea670c40d9e)@@ -44,7 +44,8 @@ struct cached\_fid { spinlock\_t fid\_lock; struct cifs\_tcon \*tcon; struct dentry \*dentry;- struct work\_struct lease\_break;+ struct work\_struct put\_work;+ struct work\_struct close\_work; struct smb2\_file\_all\_info file\_all\_info; struct cached\_dirents dirents; };@@ -53,10 +54,13 @@ struct cached\_fid { struct cached\_fids { /\* Must be held when: \* - accessing the cfids->entries list+ \* - accessing the cfids->dying list \*/ spinlock\_t cfid\_list\_lock; int num\_entries; struct list\_head entries;+ struct list\_head dying;+ struct work\_struct invalidation\_work; struct delayed\_work laundromat\_work; }; diff --git a/fs/smb/client/cifsfs.c b/fs/smb/client/cifsfs.cindex 20cafdff508106..bf909c2f6b963b 100644--- a/[fs/smb/client/cifsfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsfs.c?id=47655a12c6b1bca8fa230085eab2e85a076932b7)+++ b/[fs/smb/client/cifsfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsfs.c?id=548812afd96982a76a93ba76c0582ea670c40d9e)@@ -157,6 +157,7 @@ struct workqueue\_struct \*fileinfo\_put\_wq; struct workqueue\_struct \*cifsoplockd\_wq; struct workqueue\_struct \*deferredclose\_wq; struct workqueue\_struct \*serverclose\_wq;+struct workqueue\_struct \*cfid\_put\_wq; \_\_u32 cifs\_lock\_secret;  /\*@@ -1895,9 +1896,16 @@ init\_cifs(void) goto out\_destroy\_deferredclose\_wq; } + cfid\_put\_wq = alloc\_workqueue("cfid\_put\_wq",+ WQ\_FREEZABLE|WQ\_MEM\_RECLAIM, 0);+ if (!cfid\_put\_wq) {+ rc = -ENOMEM;+ goto out\_destroy\_serverclose\_wq;+ }+ rc = cifs\_init\_inodecache(); if (rc)- goto out\_destroy\_serverclose\_wq;+ goto out\_destroy\_cfid\_put\_wq;  rc = cifs\_init\_netfs(); if (rc)@@ -1965,6 +1973,8 @@ out\_destroy\_netfs: cifs\_destroy\_netfs(); out\_destroy\_inodecache: cifs\_destroy\_inodecache();+out\_destroy\_cfid\_put\_wq:+ destroy\_workqueue(cfid\_put\_wq); out\_destroy\_serverclose\_wq: destroy\_workqueue(serverclose\_wq); out\_destroy\_deferredclose\_wq:diff --git a/fs/smb/client/cifsglob.h b/fs/smb/client/cifsglob.hindex 5041b1ffc244b0..31ea19e7b998a8 100644--- a/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=47655a12c6b1bca8fa230085eab2e85a076932b7)+++ b/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=548812afd96982a76a93ba76c0582ea670c40d9e)@@ -1983,7 +1983,7 @@ require use of the stronger protocol \*/ \* cifsInodeInfo->lock\_sem cifsInodeInfo->llist cifs\_init\_once \* ->can\_cache\_brlcks \* cifsInodeInfo->deferred\_lock cifsInodeInfo->deferred\_closes cifsInodeInfo\_alloc- \* cached\_fid->fid\_mutex cifs\_tcon->crfid tcon\_info\_alloc+ \* cached\_fids->cfid\_list\_lock cifs\_tcon->cfids->entries init\_cached\_dirs \* cifsFileInfo->fh\_mutex cifsFileInfo cifs\_new\_fileinfo \* cifsFileInfo->file\_info\_lock cifsFileInfo->count cifs\_new\_fileinfo \* ->invalidHandle initiate\_cifs\_search@@ -2071,6 +2071,7 @@ extern struct workqueue\_struct \*fileinfo\_put\_wq; extern struct workqueue\_struct \*cifsoplockd\_wq; extern struct workqueue\_struct \*deferredclose\_wq; extern struct workqueue\_struct \*serverclose\_wq;+extern struct workqueue\_struct \*cfid\_put\_wq; extern \_\_u32 cifs\_lock\_secret;  extern mempool\_t \*cifs\_sm\_req\_poolp;diff --git a/fs/smb/client/inode.c b/fs/smb/client/inode.cindex 72ebd72dd02b2d..527f7982368cdc 100644--- a/[fs/smb/client/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/inode.c?id=47655a12c6b1bca8fa230085eab2e85a076932b7)+++ b/[fs/smb/client/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/inode.c?id=548812afd96982a76a93ba76c0582ea670c40d9e)@@ -2473,13 +2473,10 @@ cifs\_dentry\_needs\_reval(struct dentry \*dentry) return true;  if (!open\_cached\_dir\_by\_dentry(tcon, dentry->d\_parent, &cfid)) {- spin\_lock(&cfid->fid\_lock); if (cfid->time && cifs\_i->time > cfid->time) {- spin\_unlock(&cfid->fid\_lock); close\_cached\_dir(cfid); return false; }- spin\_unlock(&cfid->fid\_lock); close\_cached\_dir(cfid); } /\*diff --git a/fs/smb/client/trace.h b/fs/smb/client/trace.hindex 0b52d22a91a0cb..12cbd3428a6da5 100644--- a/[fs/smb/client/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/trace.h?id=47655a12c6b1bca8fa230085eab2e85a076932b7)+++ b/[fs/smb/client/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/trace.h?id=548812afd96982a76a93ba76c0582ea670c40d9e)@@ -44,6 +44,8 @@ EM(netfs\_trace\_tcon\_ref\_free\_ipc, "FRE Ipc ") \ EM(netfs\_trace\_tcon\_ref\_free\_ipc\_fail, "FRE Ipc-F ") \ EM(netfs\_trace\_tcon\_ref\_free\_reconnect\_server, "FRE Reconn") \+ EM(netfs\_trace\_tcon\_ref\_get\_cached\_laundromat, "GET Ch-Lau") \+ EM(netfs\_trace\_tcon\_ref\_get\_cached\_lease\_break, "GET Ch-Lea") \ EM(netfs\_trace\_tcon\_ref\_get\_cancelled\_close, "GET Cn-Cls") \ EM(netfs\_trace\_tcon\_ref\_get\_dfs\_refer, "GET DfsRef") \ EM(netfs\_trace\_tcon\_ref\_get\_find, "GET Find ") \@@ -52,6 +54,7 @@ EM(netfs\_trace\_tcon\_ref\_new, "NEW ") \ EM(netfs\_trace\_tcon\_ref\_new\_ipc, "NEW Ipc ") \ EM(netfs\_trace\_tcon\_ref\_new\_reconnect\_server, "NEW Reconn") \+ EM(netfs\_trace\_tcon\_ref\_put\_cached\_close, "PUT Ch-Cls") \ EM(netfs\_trace\_tcon\_ref\_put\_cancelled\_close, "PUT Cn-Cls") \ EM(netfs\_trace\_tcon\_ref\_put\_cancelled\_close\_fid, "PUT Cn-Fid") \ EM(netfs\_trace\_tcon\_ref\_put\_cancelled\_mid, "PUT Cn-Mid") \ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 22:10:57 +0000



=== Content from git.kernel.org_0adc5721_20250114_221221.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=73934e535cffbda1490fa97d82690a0f9aa73e94)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=73934e535cffbda1490fa97d82690a0f9aa73e94)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=73934e535cffbda1490fa97d82690a0f9aa73e94)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=73934e535cffbda1490fa97d82690a0f9aa73e94)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Paul Aurich <paul@darkrain42.org> | 2024-11-18 13:50:28 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-09 10:32:53 +0100 |
| commit | [73934e535cffbda1490fa97d82690a0f9aa73e94](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=73934e535cffbda1490fa97d82690a0f9aa73e94) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=73934e535cffbda1490fa97d82690a0f9aa73e94)) | |
| tree | [53824c8b35ffb5923764a1185434a43d8bf240e0](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=73934e535cffbda1490fa97d82690a0f9aa73e94) | |
| parent | [791f833053578b9fd24252ebb7162a61bc3f805b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=791f833053578b9fd24252ebb7162a61bc3f805b) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=73934e535cffbda1490fa97d82690a0f9aa73e94&id2=791f833053578b9fd24252ebb7162a61bc3f805b)) | |
| download | [linux-73934e535cffbda1490fa97d82690a0f9aa73e94.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-73934e535cffbda1490fa97d82690a0f9aa73e94.tar.gz) | |

smb: During unmount, ensure all cached dir instances drop their dentrycommit 3fa640d035e5ae526769615c35cb9ed4be6e3662 upstream.
The unmount process (cifs\_kill\_sb() calling close\_all\_cached\_dirs()) can
race with various cached directory operations, which ultimately results
in dentries not being dropped and these kernel BUGs:
BUG: Dentry ffff88814f37e358{i=1000000000080,n=/} still in use (2) [unmount of cifs cifs]
VFS: Busy inodes after unmount of cifs (cifs)
------------[ cut here ]------------
kernel BUG at fs/super.c:661!
This happens when a cfid is in the process of being cleaned up when, and
has been removed from the cfids->entries list, including:
- Receiving a lease break from the server
- Server reconnection triggers invalidate\_all\_cached\_dirs(), which
removes all the cfids from the list
- The laundromat thread decides to expire an old cfid.
To solve these problems, dropping the dentry is done in queued work done
in a newly-added cfid\_put\_wq workqueue, and close\_all\_cached\_dirs()
flushes that workqueue after it drops all the dentries of which it's
aware. This is a global workqueue (rather than scoped to a mount), but
the queued work is minimal.
The final cleanup work for cleaning up a cfid is performed via work
queued in the serverclose\_wq workqueue; this is done separate from
dropping the dentries so that close\_all\_cached\_dirs() doesn't block on
any server operations.
Both of these queued works expect to invoked with a cfid reference and
a tcon reference to avoid those objects from being freed while the work
is ongoing.
While we're here, add proper locking to close\_all\_cached\_dirs(), and
locking around the freeing of cfid->dentry.
Fixes: ebe98f1447bb ("cifs: enable caching of directories for which a lease is held")
Cc: stable@vger.kernel.org
Signed-off-by: Paul Aurich <paul@darkrain42.org>
Signed-off-by: Steve French <stfrench@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=73934e535cffbda1490fa97d82690a0f9aa73e94)

| -rw-r--r-- | [fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cached_dir.c?id=73934e535cffbda1490fa97d82690a0f9aa73e94) | 156 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/smb/client/cached\_dir.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cached_dir.h?id=73934e535cffbda1490fa97d82690a0f9aa73e94) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/cifsfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsfs.c?id=73934e535cffbda1490fa97d82690a0f9aa73e94) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsglob.h?id=73934e535cffbda1490fa97d82690a0f9aa73e94) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/inode.c?id=73934e535cffbda1490fa97d82690a0f9aa73e94) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/trace.h?id=73934e535cffbda1490fa97d82690a0f9aa73e94) | 3 | |  |  |  | | --- | --- | --- | |

6 files changed, 147 insertions, 36 deletions

| diff --git a/fs/smb/client/cached\_dir.c b/fs/smb/client/cached\_dir.cindex 06eb19dabb0ecc..004349a7ab69d2 100644--- a/[fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.c?id=791f833053578b9fd24252ebb7162a61bc3f805b)+++ b/[fs/smb/client/cached\_dir.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.c?id=73934e535cffbda1490fa97d82690a0f9aa73e94)@@ -17,6 +17,11 @@ static void free\_cached\_dir(struct cached\_fid \*cfid); static void smb2\_close\_cached\_fid(struct kref \*ref); static void cfids\_laundromat\_worker(struct work\_struct \*work); +struct cached\_dir\_dentry {+ struct list\_head entry;+ struct dentry \*dentry;+};+ static struct cached\_fid \*find\_or\_create\_cached\_dir(struct cached\_fids \*cfids, const char \*path, bool lookup\_only,@@ -470,7 +475,10 @@ void close\_all\_cached\_dirs(struct cifs\_sb\_info \*cifs\_sb) struct cifs\_tcon \*tcon; struct tcon\_link \*tlink; struct cached\_fids \*cfids;+ struct cached\_dir\_dentry \*tmp\_list, \*q;+ LIST\_HEAD(entry); + spin\_lock(&cifs\_sb->tlink\_tree\_lock); for (node = rb\_first(root); node; node = rb\_next(node)) { tlink = rb\_entry(node, struct tcon\_link, tl\_rbnode); tcon = tlink\_tcon(tlink);@@ -479,11 +487,30 @@ void close\_all\_cached\_dirs(struct cifs\_sb\_info \*cifs\_sb) cfids = tcon->cfids; if (cfids == NULL) continue;+ spin\_lock(&cfids->cfid\_list\_lock); list\_for\_each\_entry(cfid, &cfids->entries, entry) {- dput(cfid->dentry);+ tmp\_list = kmalloc(sizeof(\*tmp\_list), GFP\_ATOMIC);+ if (tmp\_list == NULL)+ break;+ spin\_lock(&cfid->fid\_lock);+ tmp\_list->dentry = cfid->dentry; cfid->dentry = NULL;+ spin\_unlock(&cfid->fid\_lock);++ list\_add\_tail(&tmp\_list->entry, &entry); }+ spin\_unlock(&cfids->cfid\_list\_lock);+ }+ spin\_unlock(&cifs\_sb->tlink\_tree\_lock);++ list\_for\_each\_entry\_safe(tmp\_list, q, &entry, entry) {+ list\_del(&tmp\_list->entry);+ dput(tmp\_list->dentry);+ kfree(tmp\_list); }++ /\* Flush any pending work that will drop dentries \*/+ flush\_workqueue(cfid\_put\_wq); }  /\*@@ -494,14 +521,18 @@ void invalidate\_all\_cached\_dirs(struct cifs\_tcon \*tcon) { struct cached\_fids \*cfids = tcon->cfids; struct cached\_fid \*cfid, \*q;- LIST\_HEAD(entry);  if (cfids == NULL) return; + /\*+ \* Mark all the cfids as closed, and move them to the cfids->dying list.+ \* They'll be cleaned up later by cfids\_invalidation\_worker. Take+ \* a reference to each cfid during this process.+ \*/ spin\_lock(&cfids->cfid\_list\_lock); list\_for\_each\_entry\_safe(cfid, q, &cfids->entries, entry) {- list\_move(&cfid->entry, &entry);+ list\_move(&cfid->entry, &cfids->dying); cfids->num\_entries--; cfid->is\_open = false; cfid->on\_list = false;@@ -514,26 +545,47 @@ void invalidate\_all\_cached\_dirs(struct cifs\_tcon \*tcon) } else kref\_get(&cfid->refcount); }+ /\*+ \* Queue dropping of the dentries once locks have been dropped+ \*/+ if (!list\_empty(&cfids->dying))+ queue\_work(cfid\_put\_wq, &cfids->invalidation\_work); spin\_unlock(&cfids->cfid\_list\_lock);-- list\_for\_each\_entry\_safe(cfid, q, &entry, entry) {- list\_del(&cfid->entry);- cancel\_work\_sync(&cfid->lease\_break);- /\*- \* Drop the ref-count from above, either the lease-ref (if there- \* was one) or the extra one acquired.- \*/- kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);- } }  static void-smb2\_cached\_lease\_break(struct work\_struct \*work)+cached\_dir\_offload\_close(struct work\_struct \*work) { struct cached\_fid \*cfid = container\_of(work,- struct cached\_fid, lease\_break);+ struct cached\_fid, close\_work);+ struct cifs\_tcon \*tcon = cfid->tcon;++ WARN\_ON(cfid->on\_list);  kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);+ cifs\_put\_tcon(tcon, netfs\_trace\_tcon\_ref\_put\_cached\_close);+}++/\*+ \* Release the cached directory's dentry, and then queue work to drop cached+ \* directory itself (closing on server if needed).+ \*+ \* Must be called with a reference to the cached\_fid and a reference to the+ \* tcon.+ \*/+static void cached\_dir\_put\_work(struct work\_struct \*work)+{+ struct cached\_fid \*cfid = container\_of(work, struct cached\_fid,+ put\_work);+ struct dentry \*dentry;++ spin\_lock(&cfid->fid\_lock);+ dentry = cfid->dentry;+ cfid->dentry = NULL;+ spin\_unlock(&cfid->fid\_lock);++ dput(dentry);+ queue\_work(serverclose\_wq, &cfid->close\_work); }  int cached\_dir\_lease\_break(struct cifs\_tcon \*tcon, \_\_u8 lease\_key[16])@@ -560,8 +612,10 @@ int cached\_dir\_lease\_break(struct cifs\_tcon \*tcon, \_\_u8 lease\_key[16]) cfid->on\_list = false; cfids->num\_entries--; - queue\_work(cifsiod\_wq,- &cfid->lease\_break);+ ++tcon->tc\_count;+ trace\_smb3\_tcon\_ref(tcon->debug\_id, tcon->tc\_count,+ netfs\_trace\_tcon\_ref\_get\_cached\_lease\_break);+ queue\_work(cfid\_put\_wq, &cfid->put\_work); spin\_unlock(&cfids->cfid\_list\_lock); return true; }@@ -583,7 +637,8 @@ static struct cached\_fid \*init\_cached\_dir(const char \*path) return NULL; } - INIT\_WORK(&cfid->lease\_break, smb2\_cached\_lease\_break);+ INIT\_WORK(&cfid->close\_work, cached\_dir\_offload\_close);+ INIT\_WORK(&cfid->put\_work, cached\_dir\_put\_work); INIT\_LIST\_HEAD(&cfid->entry); INIT\_LIST\_HEAD(&cfid->dirents.entries); mutex\_init(&cfid->dirents.de\_mutex);@@ -596,6 +651,9 @@ static void free\_cached\_dir(struct cached\_fid \*cfid) { struct cached\_dirent \*dirent, \*q; + WARN\_ON(work\_pending(&cfid->close\_work));+ WARN\_ON(work\_pending(&cfid->put\_work));+ dput(cfid->dentry); cfid->dentry = NULL; @@ -613,10 +671,30 @@ static void free\_cached\_dir(struct cached\_fid \*cfid) kfree(cfid); } +static void cfids\_invalidation\_worker(struct work\_struct \*work)+{+ struct cached\_fids \*cfids = container\_of(work, struct cached\_fids,+ invalidation\_work);+ struct cached\_fid \*cfid, \*q;+ LIST\_HEAD(entry);++ spin\_lock(&cfids->cfid\_list\_lock);+ /\* move cfids->dying to the local list \*/+ list\_cut\_before(&entry, &cfids->dying, &cfids->dying);+ spin\_unlock(&cfids->cfid\_list\_lock);++ list\_for\_each\_entry\_safe(cfid, q, &entry, entry) {+ list\_del(&cfid->entry);+ /\* Drop the ref-count acquired in invalidate\_all\_cached\_dirs \*/+ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);+ }+}+ static void cfids\_laundromat\_worker(struct work\_struct \*work) { struct cached\_fids \*cfids; struct cached\_fid \*cfid, \*q;+ struct dentry \*dentry; LIST\_HEAD(entry);  cfids = container\_of(work, struct cached\_fids, laundromat\_work.work);@@ -642,18 +720,28 @@ static void cfids\_laundromat\_worker(struct work\_struct \*work)  list\_for\_each\_entry\_safe(cfid, q, &entry, entry) { list\_del(&cfid->entry);- /\*- \* Cancel and wait for the work to finish in case we are racing- \* with it.- \*/- cancel\_work\_sync(&cfid->lease\_break);- /\*- \* Drop the ref-count from above, either the lease-ref (if there- \* was one) or the extra one acquired.- \*/- kref\_put(&cfid->refcount, smb2\_close\_cached\_fid);++ spin\_lock(&cfid->fid\_lock);+ dentry = cfid->dentry;+ cfid->dentry = NULL;+ spin\_unlock(&cfid->fid\_lock);++ dput(dentry);+ if (cfid->is\_open) {+ spin\_lock(&cifs\_tcp\_ses\_lock);+ ++cfid->tcon->tc\_count;+ trace\_smb3\_tcon\_ref(cfid->tcon->debug\_id, cfid->tcon->tc\_count,+ netfs\_trace\_tcon\_ref\_get\_cached\_laundromat);+ spin\_unlock(&cifs\_tcp\_ses\_lock);+ queue\_work(serverclose\_wq, &cfid->close\_work);+ } else+ /\*+ \* Drop the ref-count from above, either the lease-ref (if there+ \* was one) or the extra one acquired.+ \*/+ kref\_put(&cfid->refcount, smb2\_close\_cached\_fid); }- queue\_delayed\_work(cifsiod\_wq, &cfids->laundromat\_work,+ queue\_delayed\_work(cfid\_put\_wq, &cfids->laundromat\_work, dir\_cache\_timeout \* HZ); } @@ -666,9 +754,11 @@ struct cached\_fids \*init\_cached\_dirs(void) return NULL; spin\_lock\_init(&cfids->cfid\_list\_lock); INIT\_LIST\_HEAD(&cfids->entries);+ INIT\_LIST\_HEAD(&cfids->dying); + INIT\_WORK(&cfids->invalidation\_work, cfids\_invalidation\_worker); INIT\_DELAYED\_WORK(&cfids->laundromat\_work, cfids\_laundromat\_worker);- queue\_delayed\_work(cifsiod\_wq, &cfids->laundromat\_work,+ queue\_delayed\_work(cfid\_put\_wq, &cfids->laundromat\_work, dir\_cache\_timeout \* HZ);  return cfids;@@ -687,6 +777,7 @@ void free\_cached\_dirs(struct cached\_fids \*cfids) return;  cancel\_delayed\_work\_sync(&cfids->laundromat\_work);+ cancel\_work\_sync(&cfids->invalidation\_work);  spin\_lock(&cfids->cfid\_list\_lock); list\_for\_each\_entry\_safe(cfid, q, &cfids->entries, entry) {@@ -694,6 +785,11 @@ void free\_cached\_dirs(struct cached\_fids \*cfids) cfid->is\_open = false; list\_move(&cfid->entry, &entry); }+ list\_for\_each\_entry\_safe(cfid, q, &cfids->dying, entry) {+ cfid->on\_list = false;+ cfid->is\_open = false;+ list\_move(&cfid->entry, &entry);+ } spin\_unlock(&cfids->cfid\_list\_lock);  list\_for\_each\_entry\_safe(cfid, q, &entry, entry) {diff --git a/fs/smb/client/cached\_dir.h b/fs/smb/client/cached\_dir.hindex 81ba0fd5cc16d6..1dfe79d947a62f 100644--- a/[fs/smb/client/cached\_dir.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.h?id=791f833053578b9fd24252ebb7162a61bc3f805b)+++ b/[fs/smb/client/cached\_dir.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cached_dir.h?id=73934e535cffbda1490fa97d82690a0f9aa73e94)@@ -44,7 +44,8 @@ struct cached\_fid { spinlock\_t fid\_lock; struct cifs\_tcon \*tcon; struct dentry \*dentry;- struct work\_struct lease\_break;+ struct work\_struct put\_work;+ struct work\_struct close\_work; struct smb2\_file\_all\_info file\_all\_info; struct cached\_dirents dirents; };@@ -53,10 +54,13 @@ struct cached\_fid { struct cached\_fids { /\* Must be held when: \* - accessing the cfids->entries list+ \* - accessing the cfids->dying list \*/ spinlock\_t cfid\_list\_lock; int num\_entries; struct list\_head entries;+ struct list\_head dying;+ struct work\_struct invalidation\_work; struct delayed\_work laundromat\_work; }; diff --git a/fs/smb/client/cifsfs.c b/fs/smb/client/cifsfs.cindex 2d9f8bdb6d4efe..6ed0f2548232f9 100644--- a/[fs/smb/client/cifsfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsfs.c?id=791f833053578b9fd24252ebb7162a61bc3f805b)+++ b/[fs/smb/client/cifsfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsfs.c?id=73934e535cffbda1490fa97d82690a0f9aa73e94)@@ -156,6 +156,7 @@ struct workqueue\_struct \*fileinfo\_put\_wq; struct workqueue\_struct \*cifsoplockd\_wq; struct workqueue\_struct \*deferredclose\_wq; struct workqueue\_struct \*serverclose\_wq;+struct workqueue\_struct \*cfid\_put\_wq; \_\_u32 cifs\_lock\_secret;  /\*@@ -1899,9 +1900,16 @@ init\_cifs(void) goto out\_destroy\_deferredclose\_wq; } + cfid\_put\_wq = alloc\_workqueue("cfid\_put\_wq",+ WQ\_FREEZABLE|WQ\_MEM\_RECLAIM, 0);+ if (!cfid\_put\_wq) {+ rc = -ENOMEM;+ goto out\_destroy\_serverclose\_wq;+ }+ rc = cifs\_init\_inodecache(); if (rc)- goto out\_destroy\_serverclose\_wq;+ goto out\_destroy\_cfid\_put\_wq;  rc = init\_mids(); if (rc)@@ -1963,6 +1971,8 @@ out\_destroy\_mids: destroy\_mids(); out\_destroy\_inodecache: cifs\_destroy\_inodecache();+out\_destroy\_cfid\_put\_wq:+ destroy\_workqueue(cfid\_put\_wq); out\_destroy\_serverclose\_wq: destroy\_workqueue(serverclose\_wq); out\_destroy\_deferredclose\_wq:diff --git a/fs/smb/client/cifsglob.h b/fs/smb/client/cifsglob.hindex 111540eff66e7d..f799f46d9d0b08 100644--- a/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=791f833053578b9fd24252ebb7162a61bc3f805b)+++ b/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=73934e535cffbda1490fa97d82690a0f9aa73e94)@@ -2022,7 +2022,7 @@ require use of the stronger protocol \*/ \* cifsInodeInfo->lock\_sem cifsInodeInfo->llist cifs\_init\_once \* ->can\_cache\_brlcks \* cifsInodeInfo->deferred\_lock cifsInodeInfo->deferred\_closes cifsInodeInfo\_alloc- \* cached\_fid->fid\_mutex cifs\_tcon->crfid tcon\_info\_alloc+ \* cached\_fids->cfid\_list\_lock cifs\_tcon->cfids->entries init\_cached\_dirs \* cifsFileInfo->fh\_mutex cifsFileInfo cifs\_new\_fileinfo \* cifsFileInfo->file\_info\_lock cifsFileInfo->count cifs\_new\_fileinfo \* ->invalidHandle initiate\_cifs\_search@@ -2111,6 +2111,7 @@ extern struct workqueue\_struct \*fileinfo\_put\_wq; extern struct workqueue\_struct \*cifsoplockd\_wq; extern struct workqueue\_struct \*deferredclose\_wq; extern struct workqueue\_struct \*serverclose\_wq;+extern struct workqueue\_struct \*cfid\_put\_wq; extern \_\_u32 cifs\_lock\_secret;  extern mempool\_t \*cifs\_sm\_req\_poolp;diff --git a/fs/smb/client/inode.c b/fs/smb/client/inode.cindex e7970cbeb86111..e381ee668849ab 100644--- a/[fs/smb/client/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/inode.c?id=791f833053578b9fd24252ebb7162a61bc3f805b)+++ b/[fs/smb/client/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/inode.c?id=73934e535cffbda1490fa97d82690a0f9aa73e94)@@ -2412,13 +2412,10 @@ cifs\_dentry\_needs\_reval(struct dentry \*dentry) return true;  if (!open\_cached\_dir\_by\_dentry(tcon, dentry->d\_parent, &cfid)) {- spin\_lock(&cfid->fid\_lock); if (cfid->time && cifs\_i->time > cfid->time) {- spin\_unlock(&cfid->fid\_lock); close\_cached\_dir(cfid); return false; }- spin\_unlock(&cfid->fid\_lock); close\_cached\_dir(cfid); } /\*diff --git a/fs/smb/client/trace.h b/fs/smb/client/trace.hindex 604e52876cd2d9..563cb4d8edf0c3 100644--- a/[fs/smb/client/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/trace.h?id=791f833053578b9fd24252ebb7162a61bc3f805b)+++ b/[fs/smb/client/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/trace.h?id=73934e535cffbda1490fa97d82690a0f9aa73e94)@@ -27,6 +27,8 @@ EM(netfs\_trace\_tcon\_ref\_free\_ipc, "FRE Ipc ") \ EM(netfs\_trace\_tcon\_ref\_free\_ipc\_fail, "FRE Ipc-F ") \ EM(netfs\_trace\_tcon\_ref\_free\_reconnect\_server, "FRE Reconn") \+ EM(netfs\_trace\_tcon\_ref\_get\_cached\_laundromat, "GET Ch-Lau") \+ EM(netfs\_trace\_tcon\_ref\_get\_cached\_lease\_break, "GET Ch-Lea") \ EM(netfs\_trace\_tcon\_ref\_get\_cancelled\_close, "GET Cn-Cls") \ EM(netfs\_trace\_tcon\_ref\_get\_dfs\_refer, "GET DfsRef") \ EM(netfs\_trace\_tcon\_ref\_get\_find, "GET Find ") \@@ -35,6 +37,7 @@ EM(netfs\_trace\_tcon\_ref\_new, "NEW ") \ EM(netfs\_trace\_tcon\_ref\_new\_ipc, "NEW Ipc ") \ EM(netfs\_trace\_tcon\_ref\_new\_reconnect\_server, "NEW Reconn") \+ EM(netfs\_trace\_tcon\_ref\_put\_cached\_close, "PUT Ch-Cls") \ EM(netfs\_trace\_tcon\_ref\_put\_cancelled\_close, "PUT Cn-Cls") \ EM(netfs\_trace\_tcon\_ref\_put\_cancelled\_close\_fid, "PUT Cn-Fid") \ EM(netfs\_trace\_tcon\_ref\_put\_cancelled\_mid, "PUT Cn-Mid") \ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 22:10:58 +0000


