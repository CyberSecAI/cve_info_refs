=== Content from access.redhat.com_a658c989_20250115_204118.html ===


[Skip to navigation](#pfe-navigation)
[Skip to main content](#cp-main)
### Utilities

* [Subscriptions](https://access.redhat.com/management/)
* [Downloads](https://access.redhat.com/downloads/)
* [Red Hat Console](//console.redhat.com/)
* [Get Support](https://access.redhat.com/support/)

[![Red Hat Customer Portal](https://access.redhat.com/chrome_themes/nimbus/img/red-hat-customer-portal.svg)](https://access.redhat.com/)

* [Subscriptions](https://access.redhat.com/management/)
* [Downloads](https://access.redhat.com/downloads/)
* [Red Hat Console](//console.redhat.com/)
* [Get Support](https://access.redhat.com/support/)
* [Products](https://access.redhat.com/)
  ### Top Products

  + [Red Hat Enterprise Linux](https://access.redhat.com/products/red-hat-enterprise-linux/)
  + [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform)
  + [Red Hat Ansible Automation Platform](https://access.redhat.com/products/red-hat-ansible-automation-platform/)
  [All Products](https://access.redhat.com/products/)

  ### Downloads and Containers

  + [Downloads](https://access.redhat.com/downloads/)
  + [Packages](https://access.redhat.com/downloads/content/package-browser)
  + [Containers](https://catalog.redhat.com/software/containers/explore/)
  ### Top Resources

  + [Documentation](//docs.redhat.com/)
  + [Product Life Cycles](https://access.redhat.com/product-life-cycles/)
  + [Product Compliance](https://access.redhat.com/articles/1202803)
  + [Errata](https://access.redhat.com/errata/)
* [Knowledge](https://access.redhat.com/labs/)
  ### Red Hat Knowledge Center

  + [Knowledgebase Solutions](https://access.redhat.com/search/?q=*&p=1&rows=10&documentKind=Solution)
  + [Knowledgebase Articles](https://access.redhat.com/search/?q=*&p=1&rows=10&documentKind=Article)
  + [Customer Portal Labs](https://access.redhat.com/labs/)
  + [Errata](https://access.redhat.com/errata/)
  ### Top Product Docs

  + [Red Hat Enterprise Linux](//docs.redhat.com/en/documentation/red_hat_enterprise_linux/)
  + [Red Hat OpenShift](//docs.redhat.com/en/documentation/openshift_container_platform/)
  + [Red Hat Ansible Automation Platform](//docs.redhat.com/en/documentation/red_hat_ansible_automation_platform/)
  [All Product Docs](//docs.redhat.com/en/products)

  ### [Training and Certification](//www.redhat.com/en/services/training-and-certification)

  + [About](//www.redhat.com/en/services/training-and-certification)
  + [Course Index](//www.redhat.com/en/services/training/all-courses-exams)
  + [Certification Index](//www.redhat.com/en/services/certifications)
  + [Skill Assessment](//skills.ole.redhat.com/)
* [Security](https://access.redhat.com/security/)
  ### [Red Hat Product Security Center](https://access.redhat.com/security)

  + [Security Updates](https://access.redhat.com/security)
  + [Security Advisories](https://access.redhat.com/security/security-updates/#/security-advisories)
  + [Red Hat CVE Database](https://access.redhat.com/security/security-updates/#/cve)
  + [Errata](https://access.redhat.com/errata/)
  ### References

  + [Security Bulletins](https://access.redhat.com/security/vulnerabilities)
  + [Security Measurement](https://www.redhat.com/security/data/metrics/)
  + [Severity Ratings](https://access.redhat.com/security/updates/classification/)
  + [Security Data](https://access.redhat.com/security/data)
  ### Top Resources

  + [Security Labs](https://access.redhat.com/security/security-updates/#/security-labs)
  + [Backporting Policies](https://access.redhat.com/security/updates/backporting/)
  + [Security Blog](//redhat.com/en/blog/channel/security)
* [Support](https://access.redhat.com/support/)
  ### [Red Hat Support](https://access.redhat.com/support/)

  + [Support Cases](https://access.redhat.com/support/cases/)
  + [Troubleshoot](https://access.redhat.com/support/cases/#/troubleshoot)
  + [Get Support](https://access.redhat.com/support/)
  + [Contact Red Hat Support](https://access.redhat.com/support/contact/)
  ### [Red Hat Community Support](https://access.redhat.com/community)

  + [Customer Portal Community](https://access.redhat.com/community/)
  + [Community Discussions](https://access.redhat.com/discussions/)
  + [Red Hat Accelerator Program](https://access.redhat.com/accelerators/)
  ### Top Resources

  + [Product Life Cycles](https://access.redhat.com/product-life-cycles/)
  + [Customer Portal Labs](https://access.redhat.com/labs/)
  + [Red Hat JBoss Supported Configurations](https://access.redhat.com/support/configurations/jboss)
  + [Red Hat Insights](https://cloud.redhat.com/insights)

Or [troubleshoot an issue](/support/cases/#/troubleshoot).

English

## Select Your Language

* [English](https://access.redhat.com/changeLanguage?language=en)
* [Français](https://access.redhat.com/changeLanguage?language=fr)
* [한국어](https://access.redhat.com/changeLanguage?language=ko)
* [日本語](https://access.redhat.com/changeLanguage?language=ja)
* [中文 (中国)](https://access.redhat.com/changeLanguage?language=zh_CN)

### Infrastructure and Management

* [Red Hat Enterprise Linux](https://access.redhat.com/products/red-hat-enterprise-linux/)
* [Red Hat Satellite](https://access.redhat.com/products/red-hat-satellite/)
* [Red Hat Subscription Management](https://access.redhat.com/products/red-hat-subscription-management/)
* [Red Hat Insights](https://access.redhat.com/products/red-hat-insights/)
* [Red Hat Ansible Automation Platform](https://access.redhat.com/products/red-hat-ansible-automation-platform/)
### Cloud Computing

* [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform)
* [Red Hat OpenStack Platform](https://access.redhat.com/products/red-hat-openstack-platform/)
* [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform/)
* [Red Hat OpenShift AI](https://access.redhat.com/products/red-hat-openshift-ai/)
* [Red Hat OpenShift Dedicated](https://access.redhat.com/products/openshift-dedicated-red-hat/)
* [Red Hat Advanced Cluster Security for Kubernetes](https://access.redhat.com/products/red-hat-advanced-cluster-security-for-kubernetes/)
* [Red Hat Advanced Cluster Management for Kubernetes](https://access.redhat.com/products/red-hat-advanced-cluster-management-for-kubernetes/)
* [Red Hat Quay](https://access.redhat.com/products/red-hat-quay/)
* [Red Hat OpenShift Dev Spaces](https://access.redhat.com/products/red-hat-openshift-dev-spaces)
* [Red Hat OpenShift Service on AWS](https://access.redhat.com/products/red-hat-openshift-service-aws)
### Storage

* [Red Hat Gluster Storage](https://access.redhat.com/products/red-hat-storage/)
* [Red Hat Hyperconverged Infrastructure](https://access.redhat.com/products/red-hat-hyperconverged-infrastructure/)
* [Red Hat Ceph Storage](https://access.redhat.com/products/red-hat-ceph-storage/)
* [Red Hat OpenShift Data Foundation](https://access.redhat.com/products/red-hat-openshift-data-foundation)
### Runtimes

* [Red Hat Runtimes](https://access.redhat.com/products/red-hat-runtimes/)
* [Red Hat JBoss Enterprise Application Platform](https://access.redhat.com/products/red-hat-jboss-enterprise-application-platform/)
* [Red Hat Data Grid](https://access.redhat.com/products/red-hat-data-grid/)
* [Red Hat JBoss Web Server](https://access.redhat.com/products/red-hat-jboss-web-server/)
* [Red Hat build of Keycloak](https://access.redhat.com/products/red-hat-build-of-keycloak/)
* [Red Hat support for Spring Boot](https://access.redhat.com/products/spring-boot/)
* [Red Hat build of Node.js](https://access.redhat.com/products/nodejs/)
* [Red Hat build of Quarkus](https://access.redhat.com/products/quarkus/)
### Integration and Automation

* [Red Hat Application Foundations](https://access.redhat.com/products/red-hat-application-foundations/)
* [Red Hat Fuse](https://access.redhat.com/products/red-hat-fuse/)
* [Red Hat AMQ](https://access.redhat.com/products/red-hat-amq/)
* [Red Hat 3scale API Management](https://access.redhat.com/products/red-hat-3scale/)

[All Products](https://access.redhat.com/products/)

**We're sorry but cve-details doesn't work properly without JavaScript enabled. Please enable it to continue.**

[![Red Hat](https://static.redhat.com/libs/redhat/brand-assets/2/corp/logo--on-dark.svg)](https://redhat.com/en)
[X (formerly Twitter)](https://twitter.com/RedHat)
### Quick Links

* [Downloads](https://access.redhat.com/downloads/)
* [Subscriptions](https://access.redhat.com/management)
* [Support Cases](https://access.redhat.com/support)
* [Customer Service](https://access.redhat.com/support/customer-service)
* [Product Documentation](//docs.redhat.com/)

### Help

* [Contact Us](https://access.redhat.com/support/contact/)
* [Customer Portal FAQ](https://access.redhat.com/articles/33844)
* [Log-in Assistance](https://access.redhat.com/help/login_assistance)

### Site Info

* [Trust Red Hat](https://www.redhat.com/en/trust)
* [Browser Support Policy](https://www.redhat.com/en/about/browser-support)
* [Accessibility](https://www.redhat.com/en/about/digital-accessibility)
* [Awards and Recognition](https://access.redhat.com/recognition/)
* [Colophon](https://access.redhat.com/help/colophon/)

### Related Sites

* [redhat.com](https://www.redhat.com/)
* [developers.redhat.com](http://developers.redhat.com/)
* [connect.redhat.com](https://connect.redhat.com/)
* [cloud.redhat.com](https://cloud.redhat.com/)

### Red Hat legal and privacy links

* [About Red Hat](https://redhat.com/en/about/company)
* [Jobs](https://redhat.com/en/jobs)
* [Events](https://redhat.com/en/events)
* [Locations](https://redhat.com/en/about/office-locations)
* [Contact Red Hat](https://redhat.com/en/contact)
* [Red Hat Blog](https://redhat.com/en/blog)
* [Diversity, equity, and inclusion](https://redhat.com/en/about/our-culture/diversity-equity-inclusion)
* [Cool Stuff Store](https://coolstuff.redhat.com/)
* [Red Hat Summit](https://www.redhat.com/en/summit)

 © 2025 Red Hat, Inc.
### Red Hat legal and privacy links

* [Privacy statement](https://redhat.com/en/about/privacy-policy)
* [Terms of use](https://redhat.com/en/about/terms-use)
* [All policies and guidelines](https://redhat.com/en/about/all-policies-guidelines)
* [Digital accessibility](https://redhat.com/en/about/digital-accessibility)



=== Content from git.kernel.org_a2bf528c_20250114_230749.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jens Axboe <axboe@kernel.dk> | 2023-11-27 16:47:04 -0700 |
| --- | --- | --- |
| committer | Jens Axboe <axboe@kernel.dk> | 2023-11-28 07:56:16 -0700 |
| commit | [c392cbecd8eca4c53f2bf508731257d9d0a21c2d](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d)) | |
| tree | [74054d568c3324dc69b65b037d9076466c2352af](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d) | |
| parent | [edecf1689768452ba1a64b7aaf3a47a817da651a](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=edecf1689768452ba1a64b7aaf3a47a817da651a) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d&id2=edecf1689768452ba1a64b7aaf3a47a817da651a)) | |
| download | [linux-c392cbecd8eca4c53f2bf508731257d9d0a21c2d.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-c392cbecd8eca4c53f2bf508731257d9d0a21c2d.tar.gz) | |

io\_uring/kbuf: defer release of mapped buffer ringsIf a provided buffer ring is setup with IOU\_PBUF\_RING\_MMAP, then the
kernel allocates the memory for it and the application is expected to
mmap(2) this memory. However, io\_uring uses remap\_pfn\_range() for this
operation, so we cannot rely on normal munmap/release on freeing them
for us.
Stash an io\_buf\_free entry away for each of these, if any, and provide
a helper to free them post ->release().
Cc: stable@vger.kernel.org
Fixes: c56e022c0a27 ("io\_uring: add support for user mapped provided buffer ring")
Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Jens Axboe <axboe@kernel.dk>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d)

| -rw-r--r-- | [include/linux/io\_uring\_types.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/io_uring_types.h?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d) | 3 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/io_uring/io_uring.c?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [io\_uring/kbuf.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/io_uring/kbuf.c?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d) | 44 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [io\_uring/kbuf.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/io_uring/kbuf.h?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d) | 2 | |  |  |  | | --- | --- | --- | |

4 files changed, 46 insertions, 5 deletions

| diff --git a/include/linux/io\_uring\_types.h b/include/linux/io\_uring\_types.hindex d3009d56af0ba3..805bb635cdf558 100644--- a/[include/linux/io\_uring\_types.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/io_uring_types.h?id=edecf1689768452ba1a64b7aaf3a47a817da651a)+++ b/[include/linux/io\_uring\_types.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/io_uring_types.h?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d)@@ -340,6 +340,9 @@ struct io\_ring\_ctx {  struct list\_head io\_buffers\_cache; + /\* deferred free list, protected by ->uring\_lock \*/+ struct hlist\_head io\_buf\_list;+ /\* Keep this last, we don't need it for the fast path \*/ struct wait\_queue\_head poll\_wq; struct io\_restriction restrictions;diff --git a/io\_uring/io\_uring.c b/io\_uring/io\_uring.cindex e40b1143821045..3a216f0744dd66 100644--- a/[io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/io_uring/io_uring.c?id=edecf1689768452ba1a64b7aaf3a47a817da651a)+++ b/[io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/io_uring/io_uring.c?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d)@@ -325,6 +325,7 @@ static \_\_cold struct io\_ring\_ctx \*io\_ring\_ctx\_alloc(struct io\_uring\_params \*p) INIT\_LIST\_HEAD(&ctx->sqd\_list); INIT\_LIST\_HEAD(&ctx->cq\_overflow\_list); INIT\_LIST\_HEAD(&ctx->io\_buffers\_cache);+ INIT\_HLIST\_HEAD(&ctx->io\_buf\_list); io\_alloc\_cache\_init(&ctx->rsrc\_node\_cache, IO\_NODE\_ALLOC\_CACHE\_MAX, sizeof(struct io\_rsrc\_node)); io\_alloc\_cache\_init(&ctx->apoll\_cache, IO\_ALLOC\_CACHE\_MAX,@@ -2950,6 +2951,7 @@ static \_\_cold void io\_ring\_ctx\_free(struct io\_ring\_ctx \*ctx) ctx->mm\_account = NULL; } io\_rings\_free(ctx);+ io\_kbuf\_mmap\_list\_free(ctx);  percpu\_ref\_exit(&ctx->refs); free\_uid(ctx->user);diff --git a/io\_uring/kbuf.c b/io\_uring/kbuf.cindex a1e4239c7d75d1..85e680fc74ce2c 100644--- a/[io\_uring/kbuf.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/io_uring/kbuf.c?id=edecf1689768452ba1a64b7aaf3a47a817da651a)+++ b/[io\_uring/kbuf.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/io_uring/kbuf.c?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d)@@ -33,6 +33,11 @@ struct io\_provide\_buf { \_\_u16 bid; }; +struct io\_buf\_free {+ struct hlist\_node list;+ void \*mem;+};+ static inline struct io\_buffer\_list \*io\_buffer\_get\_list(struct io\_ring\_ctx \*ctx, unsigned int bgid) {@@ -223,7 +228,10 @@ static int \_\_io\_remove\_buffers(struct io\_ring\_ctx \*ctx, if (bl->is\_mapped) { i = bl->buf\_ring->tail - bl->head; if (bl->is\_mmap) {- folio\_put(virt\_to\_folio(bl->buf\_ring));+ /\*+ \* io\_kbuf\_list\_free() will free the page(s) at+ \* ->release() time.+ \*/ bl->buf\_ring = NULL; bl->is\_mmap = 0; } else if (bl->buf\_nr\_pages) {@@ -531,18 +539,28 @@ error\_unpin: return -EINVAL; } -static int io\_alloc\_pbuf\_ring(struct io\_uring\_buf\_reg \*reg,+static int io\_alloc\_pbuf\_ring(struct io\_ring\_ctx \*ctx,+ struct io\_uring\_buf\_reg \*reg, struct io\_buffer\_list \*bl) {- gfp\_t gfp = GFP\_KERNEL\_ACCOUNT | \_\_GFP\_ZERO | \_\_GFP\_NOWARN | \_\_GFP\_COMP;+ struct io\_buf\_free \*ibf; size\_t ring\_size; void \*ptr;  ring\_size = reg->ring\_entries \* sizeof(struct io\_uring\_buf\_ring);- ptr = (void \*) \_\_get\_free\_pages(gfp, get\_order(ring\_size));+ ptr = io\_mem\_alloc(ring\_size); if (!ptr) return -ENOMEM; + /\* Allocate and store deferred free entry \*/+ ibf = kmalloc(sizeof(\*ibf), GFP\_KERNEL\_ACCOUNT);+ if (!ibf) {+ io\_mem\_free(ptr);+ return -ENOMEM;+ }+ ibf->mem = ptr;+ hlist\_add\_head(&ibf->list, &ctx->io\_buf\_list);+ bl->buf\_ring = ptr; bl->is\_mapped = 1; bl->is\_mmap = 1;@@ -599,7 +617,7 @@ int io\_register\_pbuf\_ring(struct io\_ring\_ctx \*ctx, void \_\_user \*arg) if (!(reg.flags & IOU\_PBUF\_RING\_MMAP)) ret = io\_pin\_pbuf\_ring(&reg, bl); else- ret = io\_alloc\_pbuf\_ring(&reg, bl);+ ret = io\_alloc\_pbuf\_ring(ctx, &reg, bl);  if (!ret) { bl->nr\_entries = reg.ring\_entries;@@ -649,3 +667,19 @@ void \*io\_pbuf\_get\_address(struct io\_ring\_ctx \*ctx, unsigned long bgid)  return bl->buf\_ring; }++/\*+ \* Called at or after ->release(), free the mmap'ed buffers that we used+ \* for memory mapped provided buffer rings.+ \*/+void io\_kbuf\_mmap\_list\_free(struct io\_ring\_ctx \*ctx)+{+ struct io\_buf\_free \*ibf;+ struct hlist\_node \*tmp;++ hlist\_for\_each\_entry\_safe(ibf, tmp, &ctx->io\_buf\_list, list) {+ hlist\_del(&ibf->list);+ io\_mem\_free(ibf->mem);+ kfree(ibf);+ }+}diff --git a/io\_uring/kbuf.h b/io\_uring/kbuf.hindex f2d615236b2cb9..6c7646e6057cf5 100644--- a/[io\_uring/kbuf.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/io_uring/kbuf.h?id=edecf1689768452ba1a64b7aaf3a47a817da651a)+++ b/[io\_uring/kbuf.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/io_uring/kbuf.h?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d)@@ -51,6 +51,8 @@ int io\_provide\_buffers(struct io\_kiocb \*req, unsigned int issue\_flags); int io\_register\_pbuf\_ring(struct io\_ring\_ctx \*ctx, void \_\_user \*arg); int io\_unregister\_pbuf\_ring(struct io\_ring\_ctx \*ctx, void \_\_user \*arg); +void io\_kbuf\_mmap\_list\_free(struct io\_ring\_ctx \*ctx);+ unsigned int \_\_io\_put\_kbuf(struct io\_kiocb \*req, unsigned issue\_flags);  bool io\_kbuf\_recycle\_legacy(struct io\_kiocb \*req, unsigned issue\_flags); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 23:06:26 +0000



=== Content from bugs.chromium.org_c79b715b_20250115_204117.html ===



=== Content from www.openwall.com_b5dfaf80_20250114_230746.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Hash Suite - Windows password security audit tool. GUI, reports in PDF.](https://hashsuite.openwall.net) | | --- | |
| --- | --- |

[[<prev]](2) [[next>]](4) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID:
 <BY3PR05MB8321706B2D4FB21E18520CEC8D112@BY3PR05MB8321.namprd05.prod.outlook.com>
Date: Wed, 24 Apr 2024 16:46:08 +0000
From: Oriol Castejón <Oriol.Castejon@...dusintel.com>
To: "oss-security@...ts.openwall.com" <oss-security@...ts.openwall.com>
Subject: CVE-2024-0582 - Linux kernel use-after-free vulnerability in
 io_uring, writeup and exploit strategy

Hi all,

a use-after-free vulnerability in the io_uring subsystem of the Linux
kernel (CVE-2024-0582) was identified last November by Jann Horn from
Google Project Zero, see:

<https://bugs.chromium.org/p/project-zero/issues/detail?id=2504>

The issue was introduced by the following commit, which was included
in version 6.4 of the Linux kernel:

<https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c56e022c0a27>

The issue was fixed in the following commit, which was included in the
stable release 6.6.5:

<https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c392cbecd8ec>

Below are the details of the vulnerability, as well as an exploitation
strategy that was successful to exploit the patch gap in Ubuntu. The
contents of this message (plus some images) were originally published
in the following blog:

<https://blog.exodusintel.com/2024/03/27/mind-the-patch-gap-exploiting-an-io_uring-vulnerability-in-ubuntu/>

Additionally, a brief summary of the implemented fix, which was not
included in the original blog post, is provided at the end of this
message.

## Preliminaries

The io_uring interface is an asynchronous I/O API for Linux created by
Jens Axboe and introduced in the Linux kernel version 5.1. Its goal
is to improve performance of applications with a high number of I/O
operations. It provides interfaces similar to functions like
`read()` and `write()`, for example, but requests are satisfied in an
asynchronous manner to avoid the context switching overhead caused by
blocking system calls.

The io_uring interface has been a bountiful target for a lot of
vulnerability research; it was disabled in ChromeOS, production
Google servers, and restricted in Android. As such, there are many
blog posts that explain it with a lot of detail. Some relevant
references are the following:
- [Put an io_uring on it - Exploiting the Linux Kernel]
  ([https://chomp.ie/Blog+Posts/Put+an+io_uring+on+it+-+Exploiting+the+Linux+Kernel](https://chomp.ie/Blog%2BPosts/Put%2Ban%2Bio_uring%2Bon%2Bit%2B-%2BExploiting%2Bthe%2BLinux%2BKernel)),
  a writeup for an exploit targeting an io_uring operation that
  provides the same functionality (`IORING_OP_PROVIDE_BUFFERS`) as
  the vulnerability discussed here (`IORING_REGISTER_PBUF_RING`), and
  that has also a broad overview of this subsystem.
- [CVE-2022-29582 An io_uring vulnerability]
  (<https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring/>),
  where a cross-cache exploit is described. While the exploit
  described in our blog post is not strictly speaking cross-cache,
  there is some similarity between the two exploit strategies. It
  also provides an explanation of slab caches and the page allocator
  relevant to our exploit strategy.
- [Escaping the Google kCTF Container with a Data-Only Exploit]
  (<https://h0mbre.github.io/kCTF_Data_Only_Exploit/>), where a
  different strategy for data-only exploit of an io_uring
  vulnerability is described.
- [Conquering the memory through io_uring - Analysis of CVE-2023-2598]
  (<https://anatomic.rip/cve-2023-2598/>), a writeup of a vulnerability
  that yields a very similar exploit primitive to ours. In this case,
  however, the exploit strategy relies on manipulating a structure
  associated with a socket, instead of manipulating file structures.

In the next subsections we give an overview of the io_uring interface.
We pay special attention to the Provided Buffer Ring functionality,
which is relevant to the vulnerability discussed in this post. The
reader can also check "[What is io_uring?]
(<https://unixism.net/loti/what_is_io_uring.html>)", as well as the
above references for alternative overviews of this subsystem.

### The io_uring Interface

The basis of io_uring is a set of two ring buffers used for
communication between user and kernel space. These are:

- The *submission queue* (SQ), which contains submission queue
  entries (SQEs) describing a request for an I/O operation, such as
  reading or writing to a file, etc.
- The *completion queue* (CQ), which contains completion queue
  entries (CQEs) that correspond to SQEs that have been processed and
  completed.

This model allows executing a number of I/O requests to be performed
asynchronously using a single system call, while in a synchronous
manner each request would have typically corresponded to a single
system call. This reduces the overhead caused by blocking system
calls, thus improving performance. Moreover, the use of shared
buffers also reduces the overhead as no data between user and
kernelspace has to be transferred.

The io_uring API consists of three system calls:

- `io_uring_setup()`
- `io_uring_register()`
- `io_uring_enter()`

#### The `io_uring_setup()` System Call

The `io_uring_setup()` system call sets up a context for an io_uring
instance, that is, a submission and a completion queue with the
indicated number of entries each one. Its prototype is the
following:

```c
int io_uring_setup(u32 entries, struct io_uring_params *p);
```

Its arguments are:

- `entries`: It determines how many elements the SQ and CQ must have
  at the minimum.
- `params`: It can be used by the application to pass options to the
  kernel, and by the kernel to pass information to the application
  about the ring buffers.

On success, the return value of this system call is a file descriptor
that can be later used to perform operation on the io_uring instance.

#### The `io_uring_register()` System Call

The `io_uring_register()` system call allows registering resources,
such as user buffers, files, etc., for use in an io_uring instance.
Registering such resources makes the kernel map them, avoiding future
copies to and from userspace, thus improving performance. Its
prototype is the following:

```c
int io_uring_register(unsigned int fd, unsigned int opcode, void *arg
     unsigned int nr_args);
```

Its arguments are:

- `fd`: The io_uring file descriptor returned by the
  `io_uring_setup()` system call.
- `opcode`: The specific operation to be executed. It can have certain
  values such as `IORING_REGISTER_BUFFERS`, to register user buffers,
  or `IORING_UNREGISTER_BUFFERS`, to release the previously
  registered buffers.
- `arg`: Arguments passed to the operation being executed. Their type
  depends on the specific `opcode` being passed.
- `nr_args`: Number of arguments in `args` being passed.

On success, the return value of this system call is either zero or a positive value, depending on the `opcode` used.

##### Provided Buffer Rings

An application might need to have different types of registered
buffers for different I/O requests. Since kernel version 5.7, to
facilitate managing these different sets of buffers, io_uring allows
the application to register a pool of buffers that are identified by
a group ID. This is done using the `IORING_REGISTER_PBUF_RING` opcode
in the `io_uring_register()` system call.

More precisely, the application starts by allocating a set of buffers
that it wants to register. Then, it makes the
`io_uring_register()` system call with opcode
`IORING_REGISTER_PBUF_RING`, specifying a group ID with which these
buffers should be associated, a start address of the buffers, the
length of each buffer, the number of buffers, and a starting buffer
ID. This can be done for multiple sets of buffers, each one having a
different group ID.

Finally, when submitting a request, the application can use the
`IOSQE_BUFFER_SELECT` flag and provide the desired group ID to
indicate that a provided buffer ring from the corresponding set
should be used. When the operation has been completed, the buffer ID
of the buffer used for the operation is passed to the application via
the corresponding CQE.

Provided buffer rings can be unregistered via the
`io_uring_register()` system call using the
`IORING_UNREGISTER_PBUF_RING` opcode.

##### User-mapped Provided Buffer Rings

In addition to the buffers allocated by the application, since kernel
version 6.4, io_uring allows a user to delegate the allocation of
provided buffer rings to the kernel. This is done using the
`IOU_PBUF_RING_MMAP` flag passed as an argument to
`io_uring_register()`. In this case, the application does not need
to previously allocate these buffers, and therefore the start address
of the buffers does not have to be passed to the system call. Then,
after `io_uring_register()` returns, the application can `mmap()` the
buffers into userspace with the offset set as:

```c
IORING_OFF_PBUF_RING | (bgid << IORING_OFF_PBUF_SHIFT)
```

where `bgid` is the corresponding group ID. These offsets, as well as
others used to `mmap()` the io_uring data, are defined in
`include/uapi/linux/io_uring.h`:

```c
/*
 * Magic offsets for the application to mmap the data it needs
 */
#define IORING_OFF_SQ_RING			0ULL #define
 IORING_OFF_CQ_RING			0x8000000ULL #define
 IORING_OFF_SQES				0x10000000ULL #define
 IORING_OFF_PBUF_RING		0x80000000ULL #define
 IORING_OFF_PBUF_SHIFT		16 #define
 IORING_OFF_MMAP_MASK		0xf8000000ULL
```

The function that handles such an `mmap()` call is `io_uring_mmap()`:

```c
// Source: <https://elixir.bootlin.com/linux/v6.5.3/source/io_uring/io_uring.c#L3439>

static __cold int io_uring_mmap(struct file *file, struct vm_area_struct *vma)
{
	size_t sz = vma->vm_end - vma->vm_start;
	unsigned long pfn;
	void *ptr;

	ptr = io_uring_validate_mmap_request(file, vma->vm_pgoff, sz);
	if (IS_ERR(ptr))
		return PTR_ERR(ptr);

	pfn = virt_to_phys(ptr) >> PAGE_SHIFT;
	return remap_pfn_range(vma, vma->vm_start, pfn, sz, vma->vm_page_prot);
}
```

Note that `remap_pfn_range()` ultimately creates a mapping with the
`VM_PFNMAP` flag set, which means that the MM subsystem will treat
the base pages as raw page frame number mappings wihout an associated
page structure. In particular, the core kernel will not keep
reference counts of these pages, and keeping track of it is the
responsability of the calling code (in this case, the io_uring
subsystem).

#### The `io_uring_enter()` System Call

The `io_uring_enter()` system call is used to initiate and complete
I/O using the SQ and CQ that have been previously set up via the
`io_uring_setup()` system call. Its prototype is the following:

```c
int io_uring_enter(unsigned int fd, unsigned int to_submit,
	unsigned int min_complete, unsigned int flags, sigset_t *sig);
```

Its arguments are:

- `fd`: The io_uring file descriptor returned by the
  `io_uring_setup()` system call.
- `to_submit`: Specifies the number of I/Os to submit from the SQ.
- `flags`: A bitmask value that allows specifying certain options,
  such as `IORING_ENTER_GETEVENTS`, `IORING_ENTER_SQ_WAKEUP`,
  `IORING_ENTER_SQ_WAIT`, etc.
- `sig`: A pointer to a signal mask. If it is not `NULL`, the system
  call replaces the current signal mask by the one pointed to by
  `sig`, and when events become available in the CQ restores the
  original signal mask.

## Vulnerability

The vulnerability can be triggered when an application registers a
provided buffer ring with the `IOU_PBUF_RING_MMAP` flag. In this
case, the kernel allocates the memory for the provided buffer ring,
instead of it being done by the application. To access the buffers,
the application has to `mmap()` them to get a virtual mapping. If the
application later unregisters the provided buffer ring using the
`IORING_UNREGISTER_PBUF_RING` opcode, the kernel frees this memory
and returns it to the page allocator. However, it does not have any
mechanism to check whether the memory has been previously unmapped in
userspace. If this has not been done, the application has a valid
memory mapping to freed pages that can be reallocated by the kernel
for other purposes. From this point, reading or writing to these
pages will trigger a use-after-free.

The following code blocks show the affected parts of functions
relevant to this vulnerability. Code snippets are demarcated by
reference markers denoted by [N]. Lines not relevant to this
vulnerability are replaced by a [Truncated] marker. The code
corresponds to the Linux kernel version 6.5.3, which corresponds to
the version used in the Ubuntu kernel `6.5.0-15-generic`.

### Registering User-mapped Provided Buffer Rings

The handler of the `IORING_REGISTER_PBUF_RING` opcode for the
`io_uring_register()` system call is the
`io_register_pbuf_ring()` function, shown in the next listing.

```c
// Source: <https://elixir.bootlin.com/linux/v6.5.3/source/io_uring/kbuf.c#L537>

int io_register_pbuf_ring(struct io_ring_ctx *ctx, void __user *arg)
{
	struct io_uring_buf_reg reg;
	struct io_buffer_list *bl, *free_bl = NULL;
	int ret;

[1]

	if (copy_from_user(&reg, arg, sizeof(reg)))
		return -EFAULT;

[Truncated]

	if (!is_power_of_2(reg.ring_entries))
		return -EINVAL;

[2]

	/* cannot disambiguate full vs empty due to head/tail size */
	if (reg.ring_entries >= 65536)
		return -EINVAL;

	if (unlikely(reg.bgid < BGID_ARRAY && !ctx->io_bl)) {
		int ret = io_init_bl_list(ctx);
		if (ret)
			return ret;
	}

	bl = io_buffer_get_list(ctx, reg.bgid);
	if (bl) {
		/* if mapped buffer ring OR classic exists, don't allow */
		if (bl->is_mapped || !list_empty(&bl->buf_list))
			return -EEXIST;
	} else {

[3]

		free_bl = bl = kzalloc(sizeof(*bl), GFP_KERNEL);
		if (!bl)
			return -ENOMEM;
	}

[4]

	if (!(reg.flags & IOU_PBUF_RING_MMAP))
		ret = io_pin_pbuf_ring(&reg, bl);
	else
		ret = io_alloc_pbuf_ring(&reg, bl);

[Truncated]

	return ret;
}
```

The function starts by copying the provided arguments into an
`io_uring_buf_reg` structure reg [1]. Then, it checks that the
desired number of entries is a power of two and is strictly less than
65536 [2]. Note that this implies that the maximum number of allowed
entries is 32768.

Next, it checks whether a provided buffer list with the specified
group ID `reg.bgid` exists and, in case it does not, an
`io_buffer_list` structure is allocated and its address is stored in
the variable `bl` [3]. Finally, if the provided arguments have the
flag `IOU_PBUF_RING_MMAP` set, the `io_alloc_pbuf_ring()` function is
called [4], passing in the address of the structure `reg`, which
contains the arguments passed to the system call, and the pointer to
the allocated buffer list structure `bl`.

```c
// Source: <https://elixir.bootlin.com/linux/v6.5.3/source/io_uring/kbuf.c#L519>

static int io_alloc_pbuf_ring(struct io_uring_buf_reg *reg,
			      struct io_buffer_list *bl)
{
	gfp_t gfp = GFP_KERNEL_ACCOUNT | __GFP_ZERO | __GFP_NOWARN | __GFP_COMP;
	size_t ring_size;
	void *ptr;

[5]

	ring_size = reg->ring_entries * sizeof(struct io_uring_buf_ring);

[6]

	ptr = (void *) __get_free_pages(gfp, get_order(ring_size));
	if (!ptr)
		return -ENOMEM;

[7]

	bl->buf_ring = ptr;
	bl->is_mapped = 1;
	bl->is_mmap = 1;
	return 0;
}
```

The `io_alloc_pbuf_ring()` function takes the number of ring entries
specified in `reg->ring_entries` and computes the resulting size
`ring_size` by multiplying it by the size of the `io_uring_buf_ring`
structure [5], which is 16 bytes. Then, it requests a number of pages
from the page allocator that can fit this size via a call to
`__get_free_pages()` [6]. Note that for the maximum number of allowed
ring entries, 32768, `ring_size` is 524288 and thus the maximum
number of 4096-byte pages that can be retrieved is 128. The address
of the first page is then stored in the `io_buffer_list` structure,
more precisely in `bl->buf_ring` [7]. Also, `bl->is_mapped` and
`bl->is_mmap` are set to 1.

### Unregistering Provided Buffer Rings

The handler of the `IORING_UNREGISTER_PBUF_RING` opcode for the
`io_uring_register()` system call is the
`io_unregister_pbuf_ring()` function, shown in the next listing.

```c
// Source: <https://elixir.bootlin.com/linux/v6.5.3/source/io_uring/kbuf.c#L601>

int io_unregister_pbuf_ring(struct io_ring_ctx *ctx, void __user *arg)
{
	struct io_uring_buf_reg reg;
	struct io_buffer_list *bl;

[8]

    if (copy_from_user(&reg, arg, sizeof(reg)))
		return -EFAULT;
	if (reg.resv[0] || reg.resv[1] || reg.resv[2])
		return -EINVAL;
	if (reg.flags)
		return -EINVAL;

[9]

	bl = io_buffer_get_list(ctx, reg.bgid);
	if (!bl)
		return -ENOENT;
	if (!bl->is_mapped)
		return -EINVAL;

[10]

	__io_remove_buffers(ctx, bl, -1U);
	if (bl->bgid >= BGID_ARRAY) {
		xa_erase(&ctx->io_bl_xa, bl->bgid);
		kfree(bl);
	}
	return 0;
}
```

Again, the function starts by copying the provided arguments into a
`io_uring_buf_reg` structure `reg` [8]. Then, it retrieves the
provided buffer list corresponding to the group ID specified in
`reg.bgid` and stores its address in the variable `bl` [9]. Finally,
it passes `bl` to the function `__io_remove_buffers()` [10].

```c
// Source: <https://elixir.bootlin.com/linux/v6.5.3/source/io_uring/kbuf.c#L209>

static int __io_remove_buffers(struct io_ring_ctx *ctx,
			       struct io_buffer_list *bl, unsigned nbufs)
{
	unsigned i = 0;

	/* shouldn't happen */
	if (!nbufs)
		return 0;

	if (bl->is_mapped) {
		i = bl->buf_ring->tail - bl->head;
		if (bl->is_mmap) {
			struct page *page;

[11]

			page = virt_to_head_page(bl->buf_ring);

[12]

			if (put_page_testzero(page))
				free_compound_page(page);
			bl->buf_ring = NULL;
			bl->is_mmap = 0;
		} else if (bl->buf_nr_pages) {

[Truncated]
```

In case the buffer list structure has the `is_mapped` and `is_mmap`
flags set, which is the case when the buffer ring was registered with
the `IOU_PBUF_RING_MMAP` flag [7], the function reaches [11]. Then,
the `page` structure of the head page corresponding to the virtual
address of the buffer ring `bl->buf_ring` is obtained. Finally, all
the pages forming the compound page with head `page` are freed at
[12], thus returning them to the page allocator.

Note that if the provided buffer ring is set up with
`IOU_PBUF_RING_MMAP`, that is, it has been allocated by the kernel
and not the application, the userspace application is expected to
have previously `mmap()`ed this memory. Moreover, recall that since
the memory mapping was created with the `VM_PFNMAP` flag, the
reference count of the page structure was not modified during this
operation. In other words, in the code above there is no way for the
kernel to know whether the application has unmapped the memory before
freeing it via the call to `free_compound_page()`. If this has not
happened, a use-after-free can be triggered by the application by
just reading or writing to this memory.

## Exploitation

The exploitation mechanism presented in this post relies on how memory
allocation works on Linux, so the reader is expected to have some
familiarity with it. As a refresher, we highlight the following
facts:

- The page allocator is in charge of managing memory pages, which are
  usually 4096 bytes. It keeps lists of free pages of order n, that
  is, memory chunks of page size multiplied by 2^n. These pages are
  served in a first-in-first-out basis.
- The slab allocator sits on top of the buddy allocator and keeps
  caches of commonly used objects (dedicated caches) or fixed-size
  objects (generic caches), called slab caches, available for
  allocation in the kernel. There are several implementations of slab
  allocators, but for the purpose of this post only the SLUB
  allocator, the default in modern versions of the kernel, is
  relevant.
- Slab caches are formed by multiple slabs, which are sets of one or
  more contiguous pages of memory. When a slab cache runs out of free
  slabs, which can happen if a large number of objects of the same
  type or size are allocated and not freed during a period of time,
  the operating system allocates a new slab by requesting free pages
  to the page allocator.

One of such cache slabs is the `filp`, which contains `file`
structures. A `file` structure, shown in the next listing, represents
an open file.

```c
// Source: <https://elixir.bootlin.com/linux/v6.5.3/source/include/linux/fs.h#L961>

struct file {
	union {
		struct llist_node	f_llist;
		struct rcu_head 	f_rcuhead;
		unsigned int 		f_iocb_flags;
	};

	/*
	 * Protects f_ep, f_flags.
	 * Must not be taken from IRQ context.
	 */
	spinlock_t		f_lock;
	fmode_t			f_mode;
	atomic_long_t		f_count;
	struct mutex		f_pos_lock;
	loff_t			f_pos;
	unsigned int		f_flags;
	struct fown_struct	f_owner;
	const struct cred	*f_cred;
	struct file_ra_state	f_ra;
	struct path		f_path;
	struct inode		*f_inode;	/* cached value */
	const struct file_operations	*f_op;

	u64			f_version;
#ifdef CONFIG_SECURITY
	void			*f_security;
#endif
	/* needed for tty driver, and maybe others */
	void			*private_data;

#ifdef CONFIG_EPOLL
	/* Used by fs/eventpoll.c to link all the hooks to this file */
	struct hlist_head	*f_ep;
#endif /* #ifdef CONFIG_EPOLL */
	struct address_space	*f_mapping;
	errseq_t		f_wb_err;
	errseq_t		f_sb_err; /* for syncfs */
} __randomize_layout
  __attribute__((aligned(4)));	/* lest something weird decides that 2 is OK */
```

The most relevant fields for this exploit are the following:

- `f_mode`: Determines whether the file is readable or writable.
- `f_pos`: Determines the current reading or writing position.
- `f_op`: The operations associated with the file. It determines the
  functions to be executed when certain system calls such as
  `read()`, `write()`, etc., are issued on the file. For files in
  `ext4` filesystems, this is equal to the `ext4_file_operations`
  variable.

### Strategy for a Data-Only Exploit

The exploit primitive provides an attacker with read and write access
to a certain number of free pages that have been returned to the page
allocator. By opening a file a large number of times, the attacker
can force the exhaustion of all the slabs in the `filp` cache, so
that free pages are requested to the page allocator to create a new
slab in this cache. In this case, further allocations of file
structures will happen in the pages on which the attacker has read
and write access, thus being able to modify them. In particular, for
example, by modifying the `f_mode` field, the attacker can make a
file that has been opened with read-only permissions to be writable.

This strategy was implemented to successfully exploit the following
versions of Ubuntu:

- Ubuntu 22.04 Jammy Jellyfish LTS with kernel `6.5.0-15-generic`.
- Ubuntu 22.04 Jammy Jellyfish LTS with kernel `6.5.0-17-generic`.
- Ubuntu 23.10 Mantic Minotaur with kernel `6.5.0-15-generic`.
- Ubuntu 23.10 Mantic Minotaur with kernel `6.5.0-17-generic`.

The next subsections give more details on how this strategy can be
carried out.

#### Triggering the Vulnerability

The strategy begins by triggering the vulnerability to obtain read and
write access to freed pages. This can be done by executing the
following steps:
- Making an `io_uring_setup()` system call to set up the io_uring
  instance.
- Making an `io_uring_register()` system call with opcode
  `IORING_REGISTER_PBUF_RING` and the `IOU_PBUF_RING_MMAP` flag,  so
  that the kernel itself allocates the memory for the provided buffer
  ring.
- `mmap()`ing the memory of the provided buffer ring with read and
  write permissions, using the io_uring file descriptor and the
  offset `IORING_OFF_PBUF_RING`.
- Unregistering the provided buffer ring by making an
  `io_uring_register()` system call with opcode
  `IORING_UNREGISTER_PBUF_RING`.

At this point, the pages corresponding to the provided buffer ring have been returned to the page allocator, while the attacker still has a valid reference to them.

#### Spraying File Structures

The next step is spawning a large number of child processes, each one
opening the file `/etc/passwd` many times with read-only permissions.
This forces the allocation of corresponding file structures in the
kernel.

By opening a large number of files, the attacker can force the
exhaustion of the slabs in the `filp` cache. After that, new slabs
will be allocated by requesting free pages from the page allocator.
At some point, the pages that previously corresponded to the provided
buffer ring, and to which the attacker still has read and write
access, will be returned by the page allocator.

Hence, all of the file structures created after this point will be
allocated in the attacker-controlled memory region, giving them the
possibility to modify the structures.

Note that these child processes have to wait until indicated to
proceed in the last stage of the exploit, so that the files are kept
open and their corresponding structures are not freed.

#### Locating a File Structure in Memory

Although the attacker may have access to some slabs belonging to the
`filp` cache, they don't know where they are within the memory
region. To identify these slabs, however, the attacker can search for
the `ext4_file_operations` address at the offset of the `file.f_op`
field within the file structure. When one is found, it can be safely
assumed that it corresponds to the file structure of one instance of
the previously opened `/etc/passwd` file.

Note that even when Kernel Address Space Layout Randomization
(KASLR) is enabled, to identify the `ext4_file_operations` address in
memory it is only necessary to know the offset of this symbol with
respect to the `_text` symbol, so there is no need for a KASLR
bypass. Indeed, given a value `val` of an unsigned integer found in
memory at the corresponding offset, one can safely assume that it is
the address of `ext4_file_operations` if:

- `(val >> 32 & 0xffffffff) == 0xffffffff`, i.e. the 32 most
  significant bits are all 1.
- `(val & 0xfffff) == (ext4_fops_offset & 0xfffff)`, i.e. the 20 least
  significant bits of `val` and `ext4_fops_offset`, the offset of
  `ext4_file_operations` with respect to `_text`, are the same.

#### Changing File Permissions and Adding a Backdoor Account

Once a file structure corresponding to the `/etc/passwd` file is
located in the memory region accessible by the attacker, it can be
modified at will. In particular, setting the `FMODE_WRITE` and
`FMODE_CAN_WRITE` flags in the `file.f_mode` field of the found
structure will make the `/etc/passwd` file writable when using the
corresponding file descriptor.

Moreover, setting the `file.f_pos` field of the found file structure
to the current size of the `/etc/passwd` file, the attacker can
ensure that any data written to it is appended at the end of the
file.

To finish, the attacker can signal all the child processes spawned in
the second stage to try to write to the opened `/etc/passwd` file.
While most of all of such attempts will fail, as the file was opened
with read-only permissions, the one corresponding to the modified
file structure, which has write permissions enabled due to the
modification of the `file->f_mode` field, will succeed.

## The Fix

As mentioned above, a fix for this vulnerability was introduced in
the Linux kernel in commit c392cbecd8ec.

The main points of this fix are the following:

- A field `io_buf_list` in the io_uring context structure is added.
  This is a list of `io_buf_free` structures, which contain the
  addresses of buffer rings allocated by the kernel that will have to
  be freed eventually.

- When the kernel allocates a provided buffer ring with
  `io_alloc_pbuf_ring()`, it stores its address in an `io_buf_free`
  structure, which is then added to the `io_buf_list` list.

- Within the `__io_remove_buffers()` function, the pages corresponding
  to `bl->buf_ring` are no longer freed.

- Only when the io_uring context is freed (which happens when the
  references to the io_uring device file drop to 0, and therefore
  when no userspace mapping to the buffer ring can exist), the pages
  of the provided buffer rings stored in the `io_buf_list` are
  freed.

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from bugzilla.redhat.com_34772c9c_20250114_230748.html ===


* Login
  + Log in using an SSO provider:- [Fedora Account System](saml2_login.cgi?idp=Fedora%20Account%20System&target=show_bug.cgi%3Fid%3D2254050)
    - [Red Hat Associate](saml2_login.cgi?idp=Red%20Hat%20Associate&target=show_bug.cgi%3Fid%3D2254050)
    - [Red Hat Customer](saml2_login.cgi?idp=Red%20Hat%20Customer&target=show_bug.cgi%3Fid%3D2254050)+ Login using a Red Hat Bugzilla account
  + Forgot Password
  + [Create an Account](createaccount.cgi)

Red Hat Bugzilla – Bug 2254050

* [Home](./)
* [New](enter_bug.cgi)
* Search
  + [Simple Search](query.cgi?format=specific)
  + [Advanced Search](query.cgi?format=advanced)
* My Links
  + [Browse](describecomponents.cgi)
  + [Requests](request.cgi)
  + Reports
  + Current State
    - [Search](query.cgi)
    - [Tabular reports](query.cgi?format=report-table)
    - [Graphical reports](query.cgi?format=report-graph)
    - [Duplicates](duplicates.cgi)
  + Other Reports
    - [User Changes](https://bugzilla.redhat.com/page.cgi?id=user_activity.html)
  + Plotly Reports
    - [Bug Status](https://bugzilla.redhat.com/page.cgi?id=bug_status.html)
    - [Bug Severity](https://bugzilla.redhat.com/page.cgi?id=bug_severity.html)
    - [Non-Defaults](https://bugzilla.redhat.com/page.cgi?id=non_defaults.html)
* [Product Dashboard](page.cgi?id=productdashboard.html)

- Help
  * [Page Help!](docs/en/html/using/understanding.html)
  * [Bug Writing Guidelines](page.cgi?id=bug-writing.html)
  * [What's new](page.cgi?id=whats-new.html)
  * [Browser Support Policy](https://access.redhat.com/help/browsers)
  * [5.0.4.rh103 Release notes](page.cgi?id=release-notes.html)
  * [FAQ](page.cgi?id=faq.html)
  * [Guides index](docs/en/html/index.html)
  * [User guide](docs/en/html/using/index.html)
  * [Web Services](docs/en/html/integrating/api/Bugzilla/WebService/Bug.html)
  * [Contact](page.cgi?id=redhat/contact.html)
  * [Legal](page.cgi?id=terms-conditions.html)
- [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")

This site requires JavaScript to be enabled to function correctly, please enable it.

[**Bug 2254050**](show_bug.cgi?id=2254050)
(CVE-2024-0582)
- [CVE-2024-0582](https://access.redhat.com/security/cve/CVE-2024-0582) kernel: io\_uring: page use-after-free vulnerability via buffer ring mmap

**[NEEDINFO]**
[Summary:](page.cgi?id=fields.html#short_desc "The bug summary is a short sentence which succinctly describes what the bug is about.")
CVE-2024-0582 kernel: io\_uring: page use-after-free vulnerability via buffer ...

| | [Keywords](describekeywords.cgi): | Security | | --- | --- | | [Status](page.cgi?id=fields.html#bug_status): | NEW | | [Alias:](page.cgi?id=fields.html#alias "A short, unique name assigned to a bug in order to assist with looking it up and referring to it in other places in Bugzilla.") | CVE-2024-0582 | | [Product:](describecomponents.cgi "Bugs are categorised into Products and Components. Select a Classification to narrow down this list.") | Security Response | | [Classification:](page.cgi?id=fields.html#classification "Bugs are categorised into Classifications, Products and Components. classifications is the top-level categorisation.") | Other | | [Component:](describecomponents.cgi?product=Security Response "Components are second-level categories; each belongs to a particular Product. Select a Product to narrow down this list.") | vulnerability | | [Sub Component:](page.cgi?id=fields.html#rh_sub_components "The sub component of a specific component") | --- | | [Version:](page.cgi?id=fields.html#version "The version field defines the version of the software the bug was found in.") | unspecified | | [Hardware:](page.cgi?id=fields.html#rep_platform "The hardware platform the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | All | | [OS:](page.cgi?id=fields.html#op_sys "The operating system the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | Linux | | [Priority:](page.cgi?id=fields.html#priority) | high | | [Severity:](page.cgi?id=fields.html#bug_severity) | high | | [Target Milestone:](page.cgi?id=fields.html#target_milestone "The Target Milestone field is used to define when the engineer the bug is assigned to expects to fix it.") | --- | | [Assignee:](page.cgi?id=fields.html#assigned_to "The person in charge of resolving the bug.") | Product Security | | [QA Contact:](page.cgi?id=fields.html#qa_contact "The person responsible for confirming this bug if it is unconfirmed, and for verifying the fix once the bug has been resolved.") |  | | [Docs Contact:](page.cgi?id=fields.html#docs_contact "The person responsible for documenting once the bug has been resolved.") |  | | [URL:](page.cgi?id=fields.html#bug_file_loc "Bugs can have a URL associated with them - for example, a pointer to a web site where the problem is seen.") |  | | [Whiteboard:](page.cgi?id=fields.html#status_whiteboard "Each bug has a free-form single line text entry box for adding tags and status information.") |  | | [Depends On:](page.cgi?id=fields.html#dependson "The bugs listed here must be resolved before this bug can be resolved.") | [2258515](show_bug.cgi?id=2258515 "CLOSED ERRATA - TRIAGE kernel: io_uring: page use-after-free vulnerability via buffer ring mmap [fedora-all]") | | [Blocks:](page.cgi?id=fields.html#blocked "This bug must be resolved before the bugs listed in this field can be resolved.") | [2254048](show_bug.cgi?id=2254048) | | TreeView+ | [depends on](buglist.cgi?bug_id=2254050&bug_id_type=anddependson&format=tvp) / [blocked](buglist.cgi?bug_id=2254050&bug_id_type=andblocked&format=tvp&tvp_dir=blocked) |  | |  | | [Reported:](page.cgi?id=fields.html#reporter) | 2023-12-11 17:51 UTC by Mauro Matteo Cascella | | --- | --- | | [Modified:](page.cgi?id=fields.html#modified) | 2024-04-12 21:02 UTC ([History](show_activity.cgi?id=2254050)) | | [CC List:](page.cgi?id=fields.html#cclist) | 48 users (show)  acaringi allarkin bhu chwhite cye cyin dbohanno debarbos dfreiber drow dvlasenk ezulian hkrzesin jarod jburrell jdenham jfaracco jforbes jlelli jmoyer joe.lawrence jpoimboe jshortt jstancek jwyatt kcarcia ldoskova lgoncalv lzampier mmilgram mstowell nmurray ptalbert rparrazo rrobaina rvrbovsk rysulliv scweaver security-response-team tglozar tyberry vkumar wcosta williams wmealing ycote ykopkova zhijwang | | Fixed In Version: |  | | | Doc Type: | If docs needed, set a value | | | Doc Text: | A memory leak flaw was found in the Linux kernel’s io\_uring functionality in how a user registers a buffer ring with IORING\_REGISTER\_PBUF\_RING, mmap() it, and then frees it. This flaw allows a local user to crash or potentially escalate their privileges on the system. | | | Clone Of: |  | | | Environment: |  | | | Last Closed: |  | | | Embargoed: |  | | | Flags: | allarkin: needinfo? (jmoyer) | |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| --- | | |

| | Attachments | [(Terms of Use)](page.cgi?id=terms-conditions.html) | | | --- | --- | --- | |  | | | |  |
| --- | --- | --- | --- | --- | --- | --- | --- |

| [Description](show_bug.cgi?id=2254050#c0)  Mauro Matteo Cascella    2023-12-11 17:51:31 UTC  ``` Since commit c56e022c0a27 ("io_uring: add support for user mapped provided buffer ring"), landed in Linux 6.4, io_uring makes it possible to allocate, mmap, and deallocate "buffer rings".  A "buffer ring" can be allocated with io_uring_register(..., IORING_REGISTER_PBUF_RING, ...) and later deallocated with io_uring_register(..., IORING_UNREGISTER_PBUF_RING, ...). It can be mapped into userspace using mmap() with offset IORING_OFF_PBUF_RING|..., which creates a VM_PFNMAP mapping, meaning the MM subsystem will treat the mapping as a set of opaque page frame numbers not associated with any corresponding pages; this implies that the calling code is responsible for ensuring that the mapped memory can not be freed before the userspace mapping is removed.  However, there is no mechanism to ensure this in io_uring: It is possible to just register a buffer ring with IORING_REGISTER_PBUF_RING, mmap() it, and then free the buffer ring's pages with IORING_UNREGISTER_PBUF_RING, leaving free pages mapped into userspace, which is a fairly easily exploitable situation.  Reference: <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c392cbecd8eca4c53f2bf508731257d9d0a21c2d>   ```  [Comment 6](show_bug.cgi?id=2254050#c6)  Alex    2024-01-15 19:02:01 UTC  ``` Created kernel tracking bugs for this issue:  Affects: fedora-all [[bug 2258515](show_bug.cgi?id=2258515 "CLOSED ERRATA - TRIAGE kernel: io_uring: page use-after-free vulnerability via buffer ring mmap [fedora-all]")]   ```  [Comment 8](show_bug.cgi?id=2254050#c8)  Justin M. Forbes    2024-01-15 19:28:06 UTC  ``` This was fixed for fedora with the 6.6.5 stable kernel updates.   ``` |  |
| --- | --- |

---

| Note You need to [log in](show_bug.cgi?id=2254050&GoAheadAndLogIn=1) before you can comment on or make changes to this bug. |
| --- |

---

[Privacy](page.cgi?id=redhat/privacy.html)
[Contact](page.cgi?id=redhat/contact.html)
[FAQ](page.cgi?id=faq.html)
[Legal](page.cgi?id=terms-conditions.html)


