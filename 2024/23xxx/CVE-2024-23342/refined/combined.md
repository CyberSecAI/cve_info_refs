=== Content from github.com_dd1595cf_20250114_181315.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftlsfuzzer%2Fpython-ecdsa%2Fblob%2Fmaster%2FSECURITY.md)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftlsfuzzer%2Fpython-ecdsa%2Fblob%2Fmaster%2FSECURITY.md)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=tlsfuzzer%2Fpython-ecdsa)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[tlsfuzzer](/tlsfuzzer)
/
**[python-ecdsa](/tlsfuzzer/python-ecdsa)**
Public

* [Notifications](/login?return_to=%2Ftlsfuzzer%2Fpython-ecdsa) You must be signed in to change notification settings
* [Fork
  314](/login?return_to=%2Ftlsfuzzer%2Fpython-ecdsa)
* [Star
   927](/login?return_to=%2Ftlsfuzzer%2Fpython-ecdsa)

* [Code](/tlsfuzzer/python-ecdsa)
* [Issues
  15](/tlsfuzzer/python-ecdsa/issues)
* [Pull requests
  1](/tlsfuzzer/python-ecdsa/pulls)
* [Discussions](/tlsfuzzer/python-ecdsa/discussions)
* [Actions](/tlsfuzzer/python-ecdsa/actions)
* [Projects
  0](/tlsfuzzer/python-ecdsa/projects)
* [Wiki](/tlsfuzzer/python-ecdsa/wiki)
* [Security](/tlsfuzzer/python-ecdsa/security)
* [Insights](/tlsfuzzer/python-ecdsa/pulse)

Additional navigation options

* [Code](/tlsfuzzer/python-ecdsa)
* [Issues](/tlsfuzzer/python-ecdsa/issues)
* [Pull requests](/tlsfuzzer/python-ecdsa/pulls)
* [Discussions](/tlsfuzzer/python-ecdsa/discussions)
* [Actions](/tlsfuzzer/python-ecdsa/actions)
* [Projects](/tlsfuzzer/python-ecdsa/projects)
* [Wiki](/tlsfuzzer/python-ecdsa/wiki)
* [Security](/tlsfuzzer/python-ecdsa/security)
* [Insights](/tlsfuzzer/python-ecdsa/pulse)

## Files

 master
## Breadcrumbs

1. [python-ecdsa](/tlsfuzzer/python-ecdsa/tree/master)
/
# SECURITY.md

Copy path Blame  Blame
## Latest commit

## History

[History](/tlsfuzzer/python-ecdsa/commits/master/SECURITY.md)48 lines (35 loc) · 2.38 KB master
## Breadcrumbs

1. [python-ecdsa](/tlsfuzzer/python-ecdsa/tree/master)
/
# SECURITY.md

Top
## File metadata and controls

* Preview
* Code
* Blame

48 lines (35 loc) · 2.38 KB[Raw](https://github.com/tlsfuzzer/python-ecdsa/raw/refs/heads/master/SECURITY.md)
# Security Policy

## Supported Versions

Only the latest released version is supported.
Alpha and beta releases are always unsupported with security fixes.

The project uses semantic versioning, as such, minor version changes are API compatible.

| Version | Supported |
| --- | --- |
| 0.18.x | ✅ |
| < 0.18 | ❌ |

## Support Scope

This library was not designed with security in mind. If you are processing data that needs
to be protected we suggest you use a quality wrapper around OpenSSL.
[`pyca/cryptography`](https://cryptography.io/) is one example of such a wrapper.
The primary use-case of this library is as a portable library for interoperability testing
and as a teaching tool.

**This library does not protect against side-channel attacks.**

Do not allow attackers to measure how long it takes you to generate a key pair or sign a message.
Do not allow attackers to run code on the same physical machine when key pair generation or
signing is taking place (this includes virtual machines).
Do not allow attackers to measure how much power your computer uses while generating the key pair
or signing a message. Do not allow attackers to measure RF interference coming from your computer
while generating a key pair or signing a message. Note: just loading the private key will cause
key pair generation. Other operations or attack vectors may also be vulnerable to attacks.
For a sophisticated attacker observing just one operation with a private key will be sufficient
to completely reconstruct the private key.

Fixes for side-channel vulerabilities will not be developed.

Please also note that any Pure-python cryptographic library will be vulnerable to the same
side-channel attacks. This is because Python does not provide side-channel secure primitives
(with the exception of [`hmac.compare_digest()`](https://docs.python.org/3/library/hmac.html#hmac.compare_digest)),
making side-channel secure programming impossible.

This library depends upon a strong source of random numbers. Do not use it on a system
where `os.urandom()` does not provide cryptographically secure random numbers.

## Reporting a Vulnerability

If you find a security vulnerability in this library, you can report it using the "Report a vulnerability" button on the Security tab in github UI.
Alternatively, you can contact the project maintainer at hkario at redhat dot com.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from securitypitfalls.wordpress.com_b9455f96_20250114_181318.html ===

[# securitypitfalls

## A blog about cryptography and security by Hubert Kario](https://securitypitfalls.wordpress.com/ "securitypitfalls")
### Menu

* [About](https://securitypitfalls.wordpress.com/about/)

Search for:

# “Constant time” compare in Python

*Note: while the conclusions from this article are correct (as the side channels measured are relatively large), the statistical methods used for doing that are NOT. See the later article [Debugging timing side-channel leaks](https://securitypitfalls.wordpress.com/2023/09/29/debugging-timing-side-channel-leaks/) for the scientifically correct approach.*

You may be familiar with the following piece of code to implement the constant time comparison function for strings:

```

```

def constant_time_compare(val1, val2):
    if len(val1) != len(val2):
        return False
    result = 0
    for x, y in zip(val1, val2):
        result |= x ^ y
    return result == 0

```

```

The idea behind this code is to compare all bytes of input using a flag value that will be flipped in any of the comparisons fail. Only when all the bytes were compared, is the ultimate result of the method returned. This is used to thwart attacks that use the time of processing queries to guess secret values.

Unfortunately, because of CPython specifics, this code **doesn’t work** for its intended purpose.

Sensitive code should always use [`hmac.compare_digest()`](https://docs.python.org/2/library/hmac.html#hmac.compare_digest) method and you should not write code that needs to be side channel secure in Python.

With the tl;dr version out, let’s investigate why.

## Timing side channel

Many attacks against cryptographic implementations don’t actually use maths to compromise the systems. The [Bleichenbacher Million Messages attack](http://archiv.infsec.ethz.ch/education/fs08/secsem/bleichenbacher98.pdf), [POODLE](https://www.openssl.org/~bodo/ssl-poodle.pdf) and [Lucky 13](http://www.isg.rhul.ac.uk/tls/TLStiming.pdf) attacks use some kind of a side channel to guess the contents of encrypted messages, either the timing of responses or contents of responses (different TLS Alert description field values).

Side channel attacks don’t impact only cryptographic protocols, other places where secret values need to be compared to values that are controlled by attacker, like checking password equality, API tokens and HMAC value validation need to be performed in constant time too.

Already back in 00’s, differences in timing as low as 100ns could be distinguished over LAN environment. See research by Crosby at al. in [Opportunities And Limits Of Remote Timing Attacks](https://www.cs.rice.edu/~dwallach/pub/crosby-timing2009.pdf) and Brumley and Boneh in [Remote TIming Attacks are Practical](http://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf). Currently we also have to worry about cross VM or cross-process attacks where ability to distinguish between single cycles may be possible.

## Measuring timing differences

Let’s see what happens if we use the simple way to compare two strings in python, the `==` operator.

Benchmarking code:

```

```

import perf

setup = """
str_a = b'secret API key'

alt_s = b'XXXXXXXXXXXXXX'

str_b = str_a[:{0}] + alt_s[{0}:]

assert len(str_a) == len(str_b)
"""

fun = """str_a == str_b"""

if __name__ == "__main__":
    total_runs = 128
    runs_per_process = 4
    runner = perf.Runner(values=runs_per_process,
                         warmups=16,
                         processes=total_runs//runs_per_process)
    vals = list(range(14))  # length of str_a
    for delta in vals:
        runner.timeit("eq_cmp delta={0:#04x}".format(delta),
                      fun,
                      setup=setup.format(delta))

```

```

Running it will simulate what timings does the attacker see when the difference from the expected value is at different positions in the attacker provided string.

```

```

PYTHONHASHSEED=1 python3 timing-eq_cmp-perf.py \
-o timing-eq_cmp-perf-1.py --fast

```

```
```

```

.................
eq_cmp delta=0x00: Mean +- std dev: 18.4 ns +- 0.0 ns
.................
eq_cmp delta=0x01: Mean +- std dev: 20.8 ns +- 0.0 ns
.................
eq_cmp delta=0x02: Mean +- std dev: 20.8 ns +- 0.0 ns
.................
eq_cmp delta=0x03: Mean +- std dev: 20.8 ns +- 0.0 ns
.................
eq_cmp delta=0x04: Mean +- std dev: 20.8 ns +- 0.0 ns
.................
eq_cmp delta=0x05: Mean +- std dev: 20.8 ns +- 0.0 ns
.................
eq_cmp delta=0x06: Mean +- std dev: 20.8 ns +- 0.0 ns
.................
eq_cmp delta=0x07: Mean +- std dev: 20.8 ns +- 0.0 ns
.................
eq_cmp delta=0x08: Mean +- std dev: 21.3 ns +- 0.0 ns
.................
eq_cmp delta=0x09: Mean +- std dev: 21.3 ns +- 0.0 ns
.................
eq_cmp delta=0x0a: Mean +- std dev: 21.3 ns +- 0.0 ns
.................
eq_cmp delta=0x0b: Mean +- std dev: 21.3 ns +- 0.0 ns
.................
eq_cmp delta=0x0c: Mean +- std dev: 21.3 ns +- 0.0 ns
.................
eq_cmp delta=0x0d: Mean +- std dev: 21.3 ns +- 0.0 ns

```

```

Already we can see that the difference in timing when the first different byte is at fist position or the second position is quite huge, looking at a [box plot](https://en.wikipedia.org/wiki/Box_plot) of the specific values makes it quite obvious:

```

```

a = read.csv(file="timing-eq_cmp-perf-1.csv", header=FALSE)
data = as.matrix(a)
boxplot(t(data))

```

```
[![timing-eq_cmp-perf-1-boxplot](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-eq_cmp-perf-1-boxplot1.png)](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-eq_cmp-perf-1-boxplot1.png)

Let’s see how does it compare to the `"constant_time"_compare`. First the code:

```

```

import perf

setup = """
def constant_time_compare(val1, val2):
    if len(val1) != len(val2):
        return False
    result = 0
    for x, y in zip(val1, val2):
        result |= x ^ y
    return result == 0

str_a = b'secret API key'

alt_s = b'XXXXXXXXXXXXXX'

str_b = str_a[:{0}] + alt_s[{0}:]

assert len(str_a) == len(str_b)
"""

fun = """constant_time_compare(str_a, str_b)"""

if __name__ == "__main__":
    total_runs = 128
    runs_per_process = 4
    runner = perf.Runner(values=runs_per_process,
                         warmups=16,
                         processes=total_runs//runs_per_process)
    vals = list(range(14))  # length of str_a
    for delta in vals:
        runner.timeit("ct_eq_cmp delta={0:#04x}".format(delta),
                      fun,
                      setup=setup.format(delta))

```

```

The test run:

```

```

PYTHONHASHSEED=1 python3 timing-ct_eq_cmp-perf.py \
-o timing-ct_eq_cmp-perf-1.json --fast

```

```
```

```

.................
ct_eq_cmp delta=0x00: Mean +- std dev: 1.36 us +- 0.02 us
.................
ct_eq_cmp delta=0x01: Mean +- std dev: 1.37 us +- 0.01 us
.................
ct_eq_cmp delta=0x02: Mean +- std dev: 1.37 us +- 0.01 us
.................
ct_eq_cmp delta=0x03: Mean +- std dev: 1.37 us +- 0.01 us
.................
ct_eq_cmp delta=0x04: Mean +- std dev: 1.37 us +- 0.01 us
.................
ct_eq_cmp delta=0x05: Mean +- std dev: 1.37 us +- 0.00 us
.................
ct_eq_cmp delta=0x06: Mean +- std dev: 1.36 us +- 0.01 us
.................
ct_eq_cmp delta=0x07: Mean +- std dev: 1.35 us +- 0.01 us
.................
ct_eq_cmp delta=0x08: Mean +- std dev: 1.35 us +- 0.01 us
.................
ct_eq_cmp delta=0x09: Mean +- std dev: 1.34 us +- 0.00 us
.................
ct_eq_cmp delta=0x0a: Mean +- std dev: 1.35 us +- 0.00 us
.................
ct_eq_cmp delta=0x0b: Mean +- std dev: 1.33 us +- 0.01 us
.................
ct_eq_cmp delta=0x0c: Mean +- std dev: 1.33 us +- 0.01 us
.................
ct_eq_cmp delta=0x0d: Mean +- std dev: 1.32 us +- 0.01 us

```

```

The results don’t look too bad, but there’s definitely a difference between the first and last one, even accounting for one standard deviation between them. Let’s see the box plot:

```

```

a = read.csv(file="timing-ct_eq_cmp-perf-1.csv", header=FALSE)
data = as.matrix(a)
boxplot(t(data))

```

```
[![timing-ct_eq_cmp-perf-1](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-ct_eq_cmp-perf-1.png)](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-ct_eq_cmp-perf-1.png)

That doesn’t look good. Indeed, if we compare the distributions for the different delta values using the [Kolmogorov–Smirnov test](https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test), we’ll see that results for all deltas are statistically different:

```

```

a = read.csv(file="timing-ct_eq_cmp-perf-1.csv", header=FALSE)
data = as.matrix(a)
r = c()
for (i in c(1:length(data[,1]))){
  r[i] = ks.test(data[1,], data[i,])$p.value}
which(unlist(r) &amp;amp;lt; 0.05/(length(data1[,1])-1))

```

```
```

```

 [1]  2  3  4  5  6  7  9 10 11 12 13 14

```

```

Which means that the distributions are statistically distinguishable. (The 0.05 p-value is divided by the amount of performed tests because we’re applying the [Bonferroni correction](https://en.wikipedia.org/wiki/Bonferroni_correction))

To make sure, we re-run the test 4 more times and check for correlation between medians (as the distributions are unimodal, median is [robust statistic](https://en.wikipedia.org/wiki/Robust_statistics)).

```

```

require(corrplot)

a = read.csv(file="timing-ct_eq_cmp-perf-1.csv", header=FALSE)
data = as.matrix(a)
vals = cbind(apply(data, 1, median))

for (i in 2:5) {
  name = paste("timing-ct_eq_cmp-perf-", i, ".csv", sep="")
  a = read.csv(file=name, header=FALSE)
  data = as.matrix(a)
  vals = cbind(vals, apply(data, 1, median))
}
corrplot(cor(vals, method="spearman"), method="ellipse")

```

```

[![timing-ct_eq_cmp-perf-corrplot](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-ct_eq_cmp-perf-corrplot.png)](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-ct_eq_cmp-perf-corrplot.png)
There is a very strong correlation between all the different runs, so indeed, it does look like the function is leaking timing information.
Note, we’re using the [`"spearman"` correlation statistic](https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient) as the values are not normally distributed.

Let’s compare it to the `hmac.compare_digest()` method:

```

```

import perf

setup = """
from hmac import compare_digest

str_a = b'secret API key'

str_b = b''.join((str_a[:{0}], b'X' * (14 - {0})))

assert len(str_a) == len(str_b)
assert len(str_a) == 14
"""

fun = """compare_digest(str_a, str_b)"""

if __name__ == "__main__":
    total_runs = 128
    runs_per_process = 4
    runner = perf.Runner(values=runs_per_process,
                         warmups=64,
                         processes=total_runs//runs_per_process)
    vals = list(range(14))  # length of str_a
    for delta in vals:
        runner.timeit("compare_digest delta={0:#04x}".format(delta),
                      fun,
                      setup=setup.format(delta))

```

```
```

```

PYTHONHASHSEED=1 python3 timing-compare_digest-perf.py \
-o timing-compare_digest-perf-1.json --rigorous

```

```
```

```

a = read.csv(file="timing-compare_digest-perf-1.csv", header=FALSE)
data = as.matrix(a)
boxplot(t(data))

```

```
[![timing-compare_digest-perf-1](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-compare_digest-perf-1.png)](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-compare_digest-perf-1.png)

While there is some difference that depends on where the first differing byte is, there is no difference between first and second byte, and the “step” around 8th byte is only around it (when comparing longer strings, I still see just one step at the beginning and one at the end). I have no good explanation for it. That being said, the difference between medians of the 2nd byte and 11th byte is 0.240 ns, for comparison, one cycle of the CPU (4Ghz) on which the test is running takes 0.250 ns. So I’m assuming that it is not detectable over the network, but may be detectable in cross-VM attacks.

To confirm the results I’ve run the test with simple `==` for 255 byte long strings and with using the `hmac.compare_digest()`.

Results for `==`:

```

```

a = read.csv(file="timing-eq_cmp-2-perf-1.csv", header=FALSE)
data = as.matrix(a)
boxplot(t(data))

```

```

[![timing-eq_cmp-2-perf-1.png](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-eq_cmp-2-perf-1.png)](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-eq_cmp-2-perf-1.png)
As expected, obvious steps that are directly dependant on the amount of matching data between the two parameters to the operator.

Results for `compare_digest()`:

```

```

a = read.csv(file="timing-compare_digest-8-perf-1.csv", header=FALSE)
data = as.matrix(a)
boxplot(t(data), ylim=c(min(data), quantile(data, 0.99)))

```

```

[![timing-compare_digest-8-perf-1](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-compare_digest-8-perf-1.png)](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-compare_digest-8-perf-1.png)
They are quite noisy, but what the grouping around 2.239e-7 hints at (the thick horizontal line comprised of circles), is that the distribution is not unimodal (otherwise the outliers would look like the ones below the boxes). Let’s see what are the counts for different time bins, as in a histogram, in detail:

```

```

require("lattice")
a = read.csv(file="timing-compare_digest-8-perf-1.csv", header=FALSE)
data = as.matrix(a)
h &amp;amp;lt;- hist(data, breaks=200,plot=FALSE)
breaks = c(h$breaks)
mids = c(h$mids)
hm &amp;amp;lt;- rbind(hist(data[1,], breaks=breaks, plot=FALSE)$counts)
for (i in c(2:length(data[,1]))) {
  hm &amp;amp;lt;- rbind(hm, hist(data[i,], breaks=breaks, plot=FALSE)$counts)}

d = data.frame(x=rep(seq(1, nrow(hm), length=nrow(hm)), ncol(hm)),
               y=rep(mids, each=nrow(hm)),
               z=c(hm))
levelplot(z~x*y, data=d, xlab=&amp;amp;quot;delta&amp;amp;quot;, ylab=&amp;amp;quot;time (s)&amp;amp;quot;,
  ylim=c(min(data), quantile(data, 0.99)))

```

```

[![timing-compare_digest-8-perf-1-levelplot.png](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-compare_digest-8-perf-1-levelplot.png)](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-compare_digest-8-perf-1-levelplot.png)
We can see now, that even though the measurements with delta between 0 and 8 and 249 and 255 look very different on the box plot, it’s more because a third mode was added to them rather than one of the other two was removed. Statistical test confirms this:

```

```

a = read.csv(file="timing-compare_digest-8-perf-1.csv", header=FALSE)
data = as.matrix(a)
r = c()
for (i in c(1:length(data[,1]))){
  r[i] = ks.test(data[19,], data[i,])$p.value}
which(unlist(r) &amp;amp;lt; 0.05/nrow(data))

```

```
```

```

 [1]   1   2   3   4   5   6   7   8  36  37  38  39  41  45  46  49  50  51  52
[20]  53  54 249 250 251 252 253 254 255

```

```

(the deltas between 36 and 54 are a fluke that subsequent quick runs didn’t show).

## Note about benchmarking

You may have noticed that the data we have collected, has very low amounts of noise. While it is partially the result of use of the [perf](https://pypi.org/project/perf/) module instead of the [timeit](https://docs.python.org/3/library/timeit.html) library module, it mostly is the result of careful system configuration.

On the benchamrking system, the following tasks were performed:

* 3rd and 4th core were isolated
* kernel RCU was disabled on the isolated cores
* HyperThreading was disabled in BIOS
* Intel TurboBoost was disabled
* Intel power management was disabled (no C-states or P-states other than C0 were allowed)
* CPU frequency was locked in place to 4Ghz (the nominal for the i7 4970K of the workstation used)
* Decreasing maximum perf probe query rate to 1 per second
* Disabling irqbalance and setting default IRQ affinity to un-isolated cores
* ASRL disabled
* Python hash table seed fixed

Those operations can be performed by:

1. Adding `isolcpus=2,3 rcu_nocbs=2,3 processor.max_cstate=1 idle=poll` to the kernel command line
2. Disabling HyperThreading in BIOS
3. Running `python3 -m perf system tune`
4. Disabling ASLR by running `echo 0 > /proc/sys/kernel/randomize_va_space`
5. exporting the `PYTHONSEED` environment variable

[Documentation](https://perf.readthedocs.io/en/latest/system.html) of the perf module provides most of the explanations of the particular options, but we diverge in two places: ASLR and Python hash seed. The purpose of the perf module is to test the overall performance of a piece of Python code (and compare it to either compilation or different implementation). Because Python is a language than answers the question “what if everything was a hash table” ;), that means the names of variables, memory positions of variables or [code](https://vstinner.github.io/analysis-python-performance-issue.html), number of variables, and particular hash table key have significant impact on performance. But, because we are interested if an attacker is able to tell behaviour of code between two different inputs, and those two inputs will likely be processed by the same process, both the ASLR seed and the Python hash table seeds will be constant from the point of view of the attacker. To speed up finding the expected value for particular inputs I thus opted out of those randomisation mechanisms.

## Expectations of behaviour

You may wonder, why is the Python code so unstable, so data dependant, if the implementation of `hmac.compare_digest()` is [doing exactly the same thing](https://github.com/python/cpython/blob/80b762f010097ab8137782e5fbdc89c5c620ed4e/Modules/_operator.c#L727-L762) (xor-ing the values together and then or-ing result with a guard variable)? The problem stems from the fact that the Python `int` and C `unsigned char` are vastly different data types – one is used for arbitrary precision arithmetic while the other can store just 256 unique values. Thus, even such simple operations like xor or or with two small integers are data dependant in Python.

Let’s see how much time does the Python VM need for those two small integers. (Unfortunately, it looks like perf uses the slow json module, and because it exports results after every loop iteration, after few hundred results, the export takes more time than benchmarking. To make it fast enough, and not waste few days on exporting the same data over and over again, we will use timeit module.)

Script:

```

```

import timeit
import sys
import math

setup = """
val_a = {0}

val_b = {1}
"""

fun = """val_a ^ val_b"""

def std_dev(vals):
    avg = sum(vals)/len(vals)
    sum_sq = sum((i - avg)**2 for i in vals)
    return math.sqrt(sum_sq / (len(vals) - 1))

if __name__ == "__main__":
    total_runs = 20
    runs_per_process = 3
    warmups = 16

    runner = timeit.Timer(fun, setup=setup.format(0, 0))
    number, delay = runner.autorange()
    number //= 2
    delay /= 2

    print(("will do {0} iterations per process, "
           "expecting {1:7.2} s per process")
          .format(number, delay), file=sys.stderr)
    print("warmups:", file=sys.stderr, end='')
    sys.stderr.flush()
    for _ in range(warmups):
        timeit.repeat(fun, setup=setup.format(0, 0), repeat=1,
                      number=number)
        print(".", file=sys.stderr, end='')
        sys.stderr.flush()
    print(file=sys.stderr)

    for a in range(256):
        for b in range(256):
            res = []
            for _ in range(total_runs // runs_per_process):
                # drop the first result as a local warmup
                res.extend(i / number for i in
                           timeit.repeat(fun,
                                         setup=setup.format(a, b),
                                         repeat=runs_per_process + 1,
                                         number=number)[1:])
                print(".", file=sys.stderr, end='')
                sys.stderr.flush()
                if std_dev(res)  timing-xor-2-timeit-1.csv

```

```
```

```

require("lattice")
a = read.csv(file="timing-xor-2-timeit-1.csv",
             header=FALSE, col.names=seq(1, 20),
             fill=TRUE)
data = as.matrix(a)
med = apply(data, 1, median, na.rm=TRUE)
# full lines
len = length(med)
columns = ceiling(length(med) / 256)
d = data.frame(x=rep(seq(0, 255), length.out=len, 256),
               y=rep(seq(0, 255), length.out=len, each=256),
               z=med)
my.at = seq(min(med), max(med), length=40)
levelplot(z~x*y, data=d, xlab="b", ylab="a",
          at=my.at, aspects="iso",
          colorkey=list(at=my.at, labels=list(at=my.at)))

```

```

[![timing-xor-2-timeit-1.png](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-xor-2-timeit-1.png)](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-xor-2-timeit-1.png)
While there few repeating patterns, there are 4 things that are of particular importance – behaviour when the two numbers are equal (the lighter diagonal), when both are zero, or when one of the operands is zero. The difference between the background and the diagonal is small, just 0.555 ns, but that translates to about 2 cycles at 4GHz. The difference between the 0, 0 and the backgrounds is even smaller, just 0.114 ns, so half a cycle. The difference between the background and the situations when the second variable is non-zero is about 2.24 ns which translates to about 9 cycles. When the first variable is non-zero and the second is, the difference is about 1.39 ns which is about 6 cycles. Here’s the zoomed in part of the graph for the small numbers:
[![timing-xor-2-timeit-1-zoom.png](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-xor-2-timeit-1-zoom.png)](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/07/timing-xor-2-timeit-1-zoom.png)

The binary or operator is similarly dependant on values of parameters:
[![timing-or-timeit-1](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/08/timing-or-timeit-1.png)](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/08/timing-or-timeit-1.png)

Both of those things put together mean that using the supposedly constant time compare doesn’t actually protect against timing attacks, but rather makes them *easier*. The strength of the signal for different inputs is about 100 time stronger, likely allowing them even over Internet, not only over LAN (as is the case for `==` operator).

## Anything else?

Because I started looking into those microbenchmarks to verify the “constant” time CBC MAC and pad check from [tlslite-ng](https://github.com/tomato42/tlslite-ng/blob/02852484e5ca9ea5e0c69d525ff45a3a999b386b/tlslite/utils/constanttime.py#L96), needed to protect against Lucky 13 (see the [very extensive article](https://www.imperialviolet.org/2013/02/04/luckythirteen.html) by Adam Langley on the topic), I’ve also checked if it is possible to speed up the process of hashing data. Because on the Python level we don’t have the luxury of access to lower level hash APIs, as the developers of OpenSSL have, to implement the CBC check, I wrote code that in fact calculates [256 different hmacs](https://github.com/tomato42/tlslite-ng/blob/02852484e5ca9ea5e0c69d525ff45a3a999b386b/tlslite/utils/constanttime.py#L178-L186) for every record that contains at least 256 bytes of data + padding. That means that for every record processed, the client and server actually process 64 KiB of additional data. In theory (that is, if the hmac itself is constant time), we could speed the process of checking the mac and de-padding in TLS dramatically, if we could hash the data just once, as OpenSSL is doing in its TLS implementation. You may say, “but hashes are implemented in C, surely they are constant time!”. To which I’ll answer, “what did we say about trusting assumptions?”.

Let’s see how our assumptions hold. First code that hashes all of provided data, but returns also a hash from the “middle” of data (in a TLS implementation that would be the real HMAC that we need to compare to the one from record):

```

```

import perf

setup = """
import hmac
from hashlib import sha1

def fun(digest, data, split):
    digest.update(data[:split])
    ret = digest.copy().digest()
    digest.update(data[split:])
    return ret, digest.digest()

str_a = memoryview(b'X'*256)
key = b'a' * 32

val_b = {0}

mac = hmac.new(key, digestmod=sha1)
"""

fun = """fun(mac.copy(), str_a, val_b)"""

if __name__ == "__main__":
    total_runs = 128
    runs_per_process = 4
    runner = perf.Runner(values=runs_per_process,
                         warmups=16,
                         processes=total_runs//runs_per_process)
    vals = list(range(256))  # length of str_a
    for delta in vals:
        runner.timeit("hmac split delta={0:#04x}".format(delta),
                      fun,
                      setup=setup.format(delta))

```

```

Command to gather the statistics:

```

```

PYTHONHASHSEED=1 python3 timing-hmac-split-perf.py \
-o timing-hmac-split-perf-1.json

```

```

And a way to visualise them:

```

```

require("lattice")
a = read.csv(file="timing-hmac-split-perf-1.csv", header=FALSE)
data = as.matrix(a)
h &amp;amp;lt;- hist(data, breaks=200,plot=FALSE)
breaks = c(h$breaks)
mids = c(h$mids)
hm &amp;amp;lt;- rbind(hist(data[1,], breaks=breaks, plot=FALSE)$counts)
for (i in c(2:length(data[,1]))) {
  hm &amp;amp;lt;- rbind(hm, hist(data[i,], breaks=breaks, plot=FALSE)$counts)}

d = data.frame(x=rep(seq(1, nrow(hm), length=nrow(hm)), ncol(hm)),
               y=rep(mids, each=nrow(hm)),
               z=c(hm))
levelplot(z~x*y, data=d, xlab=&amp;amp;quot;delta&amp;amp;quot;, ylab=&amp;amp;quot;time (s)&amp;amp;quot;,
  ylim=c(min(data), quantile(data, 0.99)))

```

```

[![timing-hmac-split-perf-1](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/08/timing-hmac-split-perf-1.png)](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/08/timing-hmac-split-perf-1.png)
Besides the obvious peaks since 56th to 64th byte every 64 bytes (caused by an additional hash block that had to be [padded](https://tools.ietf.org/html/rfc4634#section-4) to calculate the intermediate HMAC), there is also a dip for the first byte of the 64 byte block and a second dip for bytes between 20 and 55 of every block. Finally, when the split is about even (in that the intermediate hash is calculated over the first 120 bytes), the whole operation takes measurably longer. In short, if the position of the intermediate hash comes from the last byte of encrypted data (as it does in TLS), calculating HMAC like this has a definite sidechannel leak.

To confirm, let’s perform Kolomogorov-Smirnov test:

```

```

a = read.csv(file="timing-hmac-split-perf-1.csv", header=FALSE)
data = as.matrix(a)
r=c()
for (i in c(1:nrow(data))){
   r[i] = ks.test(data[2,], data[i,])$p.value}
which(unlist(r) &amp;amp;lt; 0.05/(nrow(normalised)-1))

```

```

(we’re testing against second row as the first row (for delta of 0) is *obviously* different from the others so all tests failing wouldn’t be unexpected)

```

```

  [1]   1  21  23  26  44  57  58  59  60  61  62  63  64  69  71  75  77  78
 [19]  80  81  82  83  92  93  94  95  96  98  99 100 103 104 109 114 118 121
 [37] 122 123 124 125 126 127 128 130 131 132 133 134 135 136 137 138 139 140
 [55] 141 142 143 144 145 146 147 160 161 163 165 169 170 171 172 173 174 175
 [73] 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 215
 [91] 217 218 249 250 251 252 253 254 255 256

```

```

Quite obviously different, even with just 128 samples per delta value.

## Summary

Moral of the story is, don’t use something without testing if it behaves as it claims to. If it does have tests, verify that they check *your* expectations, not only the programmers that wrote it in the first place.

State your assumptions and test them. If values look similar, measure them multiple times, and use statistical methods to compare them.

## Test setup

Tests were performed, as previously mentioned, on an Intel i7 4790K CPU. The system was running Linux 4.17.5-1-ARCH with Python 3.6.6-1 and perf 1.5.1 from Archlinux.

Conversion from json files to csv files was performed using `json-to-csv.py` script available at the testing repo, together with raw results, at [github](https://github.com/tomato42/python-timing-tests).

## Post scriptum

Other operations on integers, including equality are also not constant time:

```

```

import timeit
import sys
import math

setup = """
val_a = {0}

val_b = {1}
"""

fun = """val_a == val_b"""

def std_dev(vals):
    avg = sum(vals)/len(vals)
    sum_sq = sum((i - avg)**2 for i in vals)
    return math.sqrt(sum_sq / (len(vals) - 1))

if __name__ == "__main__":
    total_runs = 3
    runs_per_process = 3
    warmups = 16

    runner = timeit.Timer(fun, setup=setup.format(0, 0))
    number, delay = runner.autorange()
    number //= 100
    delay /= 100

    print("will do {0} iterations per process, "
          "expecting {1:7.2} s per process"
          .format(number, delay), file=sys.stderr)
    print("warmups:", file=sys.stderr, end='')
    sys.stderr.flush()
    for _ in range(warmups):
        timeit.repeat(fun, setup=setup.format(0, 0), repeat=1,
                      number=number)
        print(".", file=sys.stderr, end='')
        sys.stderr.flush()
    print(file=sys.stderr)

    for a in range(256):
        for b in range(256):
            res = []
            for _ in range(total_runs // runs_per_process):
                # drop the first result as a local warmup
                res.extend(i / number for i in
                           timeit.repeat(fun,
                                         setup=setup.format(a, b),
                                         repeat=runs_per_process+1,
                                         number=number)[1:])
                print(".", file=sys.stderr, end='')
                sys.stderr.flush()
                if std_dev(res)  timing-eq-timeit-1.csv

```

```

Execution:

```

```

PYTHONHASHSEED=1 taskset -c 2 python3 \
-u timing-eq-timeit.py &amp;amp;gt; timing-eq-timeit-1.csv

```

```

Code to create the graph:

```

```

require("lattice")
a = read.csv(file="timing-eq-timeit-1.csv", header=FALSE,
             col.names=seq(1, 20), fill=TRUE)
data = as.matrix(a)
med = apply(data, 1, median, na.rm=TRUE)
# full lines
len = length(med)
columns = ceiling(length(med) / 256)
d = data.frame(x=rep(seq(0, 255), length.out=len, 256),
               y=rep(seq(0, 255), length.out=len, each=256),
               z=med)
my.at = seq(min(med), max(med), length=40)
levelplot(z~x*y, data=d, xlab="b", ylab="a",
          at=my.at, colorkey=list(at=my.at, labels=list(at=my.at)))

```

```

[![timing-eq-timeit-1](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/08/timing-eq-timeit-1.png)](https://securitypitfalls.wordpress.com/wp-content/uploads/2018/08/timing-eq-timeit-1.png)
So it looks to me like the xor operation is actually one of the more constant time primitives…

### Share this:

* [Twitter](https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/?share=twitter "Click to share on Twitter")
* [Facebook](https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/?share=facebook "Click to share on Facebook")
Like Loading...
### *Related*

Posted in [Articles](https://securitypitfalls.wordpress.com/category/articles/) and tagged [constant time](https://securitypitfalls.wordpress.com/tag/constant-time/), [lucky 13](https://securitypitfalls.wordpress.com/tag/lucky-13/), [python](https://securitypitfalls.wordpress.com/tag/python/), [side channel](https://securitypitfalls.wordpress.com/tag/side-channel/), [testing](https://securitypitfalls.wordpress.com/tag/testing/), [timing attacks](https://securitypitfalls.wordpress.com/tag/timing-attacks/) on [2018/08/03](https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/ "02:44") by [Hubert Kario](https://securitypitfalls.wordpress.com/author/hkario/ "View all posts by Hubert Kario").
[5 Comments](https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/#comments)

# Post navigation

[← RAID doesn’t work!](https://securitypitfalls.wordpress.com/2018/05/08/raid-doesnt-work/) [Making RAID work (dm-integrity with MD-RAID) →](https://securitypitfalls.wordpress.com/2020/09/27/making-raid-work-dm-integrity-with-md-raid/)

## 5 comments

1. ![](https://1.gravatar.com/avatar/1990cfab408e4681da767c7ecf840e84dec433b77c36c37b9a77d68c9a91abcd?s=40&d=identicon&r=G)
   [2018/08/03 at 17:45](https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/#comment-382)

   Wow, thank you for the highly educational post. I think original constant\_time\_compare has another flaw as well. It will exit early when string length does not match.

   I’m not a python dev but lI’m wondering if this flaw can be removed as well the type conversion to be eliminated like this:

   def constant\_time\_compare(password, guess):

   Basically timing should be based on the `guess` length always. The only thing I see that could expose password length data is that with a longer guess, we generate `generated\_password` using another string. My \*hope\* though is that time for this would be comparable to getting from the other.

   [Reply](https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/?replytocom=382#respond)
   1. ![](https://0.gravatar.com/avatar/c2e92f2885d104670c0df154dc907cdb59e114a71359dcf53474eca5627c15d3?s=40&d=identicon&r=G)
      [2018/08/03 at 18:06](https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/#comment-383)

      > It will exit early when string length does not match.

      This is expected, and rather hard to exploit – it only leaks if the secret is as long as the attacker provided data. Given that you should always compare the attacker provided data to some hash (HMAC, scrypt, PBKDF2) the length of that secret value will be constant. Because of Kerckhoffs’s principle, we must assume that the attacker knows what hash and algorithm we are using.

      > (password, guess)

      To compare attacker controlled data to a password, you need to have plaintext password stored somewhere. But I’m sure you don’t have them and that was just an example… 😅

      > I wonder if one can get any better without adding artificial noise.

      adding artificial noise in general does not work: <https://eprint.iacr.org/2015/1129.pdf>

      [Reply](https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/?replytocom=383#respond)
      1. ![](https://1.gravatar.com/avatar/1990cfab408e4681da767c7ecf840e84dec433b77c36c37b9a77d68c9a91abcd?s=40&d=identicon&r=G)
         [2018/08/03 at 18:39](https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/#comment-384)

         Yeah, forgot we have passwords hashed and thus fixed length. In such case though we have one less thing to worry about. Now what if we avoid this data conversion with comparing characters for equality instead of xor-ing (as in my example above)? Shouldn’t this eliminate the value based timing differences?

         wrt noise, I remember this doc. I was thinking more about using high precision timer to sleep such that artificially make operation always take around X milliseconds. Much preferable if language allows making sure something takes constant time. But if it truly doesn’t, then what are the options? And what if next version of language introduces some optimizations that invalidate previous previous measurements for constant time? I guess you’d say automated tests 🙂
      3. ![](https://0.gravatar.com/avatar/c2e92f2885d104670c0df154dc907cdb59e114a71359dcf53474eca5627c15d3?s=40&d=identicon&r=G)
         [2018/08/03 at 19:34](https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/#comment-385)

         > Now what if we avoid this data conversion with comparing characters for equality instead of xor-ing (as in my example above)

         there is no “character” class in Python, and hash outputs are binary strings, which means that single “characters” (bytes, really) are integers

         > Shouldn’t this eliminate the value based timing differences?

         I don’t think so. But you have the tools, run the benchmarks 🙂

         > I was thinking more about using high precision timer to sleep such that artificially make operation always take around X milliseconds.

         For low level operations, the differences are measured in single cycles, not doable from python level. For high level: what is the baseline? How do you ensure it doesn’t change? What if thermal throttling kicks in? What if the server is under heavier load that when we measured the baseline?

         > But if it truly doesn’t, then what are the options?

         use language that does – most compiled languages should meet this, I wouldn’t be surprised if Cython fixed it (if the compiler wasn’t too clever)

         but in general, minimise the critical code, delegate it to languages that operate on machine intrinsics (are not interpreted) and then test those modules

         > I guess you’d say automated tests 🙂

         to quote the Indiana Jones and the Last Crusade: “You have chosen… wisely”
      5. ![](https://0.gravatar.com/avatar/c2e92f2885d104670c0df154dc907cdb59e114a71359dcf53474eca5627c15d3?s=40&d=identicon&r=G)
         [2018/08/04 at 11:39](https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/#comment-386)

         I’ve updated the article to include the test for the “==” operator: it’s quite obviously not constant time too.

### Leave a comment [Cancel reply](/2018/08/03/constant-time-compare-in-python/#respond)

Δ

Search for:

### Recent Posts

* [Experiment with side-channel attacks yourself!](https://securitypitfalls.wordpress.com/2023/10/16/experiment-with-side-channel-attacks-yourself/)
* [Debugging timing side-channel leaks](https://securitypitfalls.wordpress.com/2023/09/29/debugging-timing-side-channel-leaks/)
* [Making RAID work (dm-integrity with MD-RAID)](https://securitypitfalls.wordpress.com/2020/09/27/making-raid-work-dm-integrity-with-md-raid/)
* [“Constant time” compare in Python](https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/)
* [RAID doesn’t work!](https://securitypitfalls.wordpress.com/2018/05/08/raid-doesnt-work/)
### Recent Comments

|  | [Hubert Kario](https://securitypitfalls.wordpress.com) on [Making RAID work (dm-integrity…](https://securitypitfalls.wordpress.com/2020/09/27/making-raid-work-dm-integrity-with-md-raid/comment-page-1/#comment-15056) |
| --- | --- |
|  | Noma on [Making RAID work (dm-integrity…](https://securitypitfalls.wordpress.com/2020/09/27/making-raid-work-dm-integrity-with-md-raid/comment-page-1/#comment-15055) |
|  | Nob on [Making RAID work (dm-integrity…](https://securitypitfalls.wordpress.com/2020/09/27/making-raid-work-dm-integrity-with-md-raid/comment-page-1/#comment-15054) |
|  | [Hubert Kario](https://securitypitfalls.wordpress.com) on [Making RAID work (dm-integrity…](https://securitypitfalls.wordpress.com/2020/09/27/making-raid-work-dm-integrity-with-md-raid/comment-page-1/#comment-15041) |
|  | [Hubert Kario](https://securitypitfalls.wordpress.com) on [Making RAID work (dm-integrity…](https://securitypitfalls.wordpress.com/2020/09/27/making-raid-work-dm-integrity-with-md-raid/comment-page-1/#comment-15040) |

### Archives

* [October 2023](https://securitypitfalls.wordpress.com/2023/10/)
* [September 2023](https://securitypitfalls.wordpress.com/2023/09/)
* [September 2020](https://securitypitfalls.wordpress.com/2020/09/)
* [August 2018](https://securitypitfalls.wordpress.com/2018/08/)
* [May 2018](https://securitypitfalls.wordpress.com/2018/05/)
* [May 2017](https://securitypitfalls.wordpress.com/2017/05/)
* [April 2017](https://securitypitfalls.wordpress.com/2017/04/)
* [September 2016](https://securitypitfalls.wordpress.com/2016/09/)
* [August 2016](https://securitypitfalls.wordpress.com/2016/08/)
* [April 2016](https://securitypitfalls.wordpress.com/2016/04/)
* [March 2016](https://securitypitfalls.wordpress.com/2016/03/)
* [January 2016](https://securitypitfalls.wordpress.com/2016/01/)
* [December 2015](https://securitypitfalls.wordpress.com/2015/12/)
* [November 2015](https://securitypitfalls.wordpress.com/2015/11/)
* [September 2015](https://securitypitfalls.wordpress.com/2015/09/)
* [July 2015](https://securitypitfalls.wordpress.com/2015/07/)
* [June 2015](https://securitypitfalls.wordpress.com/2015/06/)
* [May 2015](https://securitypitfalls.wordpress.com/2015/05/)
* [April 2015](https://securitypitfalls.wordpress.com/2015/04/)
* [March 2015](https://securitypitfalls.wordpress.com/2015/03/)
* [February 2015](https://securitypitfalls.wordpress.com/2015/02/)
* [January 2015](https://securitypitfalls.wordpress.com/2015/01/)
* [December 2014](https://securitypitfalls.wordpress.com/2014/12/)
* [October 2014](https://securitypitfalls.wordpress.com/2014/10/)
* [September 2014](https://securitypitfalls.wordpress.com/2014/09/)
* [August 2014](https://securitypitfalls.wordpress.com/2014/08/)
* [July 2014](https://securitypitfalls.wordpress.com/2014/07/)
* [June 2014](https://securitypitfalls.wordpress.com/2014/06/)
* [May 2014](https://securitypitfalls.wordpress.com/2014/05/)
### Meta

* [Register](https://wordpress.com/start?ref=wplogin)
* [Log in](https://securitypitfalls.wordpress.com/wp-login.php)
* [Entries feed](https://securitypitfalls.wordpress.com/feed/)
* [Comments feed](https://securitypitfalls.wordpress.com/comments/feed/)
* [WordPress.com](https://wordpress.com/ "Powered by WordPress, state-of-the-art semantic personal publishing platform.")

Search for:

### Recent Posts

* [Experiment with side-channel attacks yourself!](https://securitypitfalls.wordpress.com/2023/10/16/experiment-with-side-channel-attacks-yourself/)
* [Debugging timing side-channel leaks](https://securitypitfalls.wordpress.com/2023/09/29/debugging-timing-side-channel-leaks/)
* [Making RAID work (dm-integrity with MD-RAID)](https://securitypitfalls.wordpress.com/2020/09/27/making-raid-work-dm-integrity-with-md-raid/)
* [“Constant time” compare in Python](https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/)
* [RAID doesn’t work!](https://securitypitfalls.wordpress.com/2018/05/08/raid-doesnt-work/)
### Recent Comments

|  | [Hubert Kario](https://securitypitfalls.wordpress.com) on [Making RAID work (dm-integrity…](https://securitypitfalls.wordpress.com/2020/09/27/making-raid-work-dm-integrity-with-md-raid/comment-page-1/#comment-15056) |
| --- | --- |
|  | Noma on [Making RAID work (dm-integrity…](https://securitypitfalls.wordpress.com/2020/09/27/making-raid-work-dm-integrity-with-md-raid/comment-page-1/#comment-15055) |
|  | Nob on [Making RAID work (dm-integrity…](https://securitypitfalls.wordpress.com/2020/09/27/making-raid-work-dm-integrity-with-md-raid/comment-page-1/#comment-15054) |
|  | [Hubert Kario](https://securitypitfalls.wordpress.com) on [Making RAID work (dm-integrity…](https://securitypitfalls.wordpress.com/2020/09/27/making-raid-work-dm-integrity-with-md-raid/comment-page-1/#comment-15041) |
|  | [Hubert Kario](https://securitypitfalls.wordpress.com) on [Making RAID work (dm-integrity…](https://securitypitfalls.wordpress.com/2020/09/27/making-raid-work-dm-integrity-with-md-raid/comment-page-1/#comment-15040) |

### Archives

* [October 2023](https://securitypitfalls.wordpress.com/2023/10/)
* [September 2023](https://securitypitfalls.wordpress.com/2023/09/)
* [September 2020](https://securitypitfalls.wordpress.com/2020/09/)
* [August 2018](https://securitypitfalls.wordpress.com/2018/08/)
* [May 2018](https://securitypitfalls.wordpress.com/2018/05/)
* [May 2017](https://securitypitfalls.wordpress.com/2017/05/)
* [April 2017](https://securitypitfalls.wordpress.com/2017/04/)
* [September 2016](https://securitypitfalls.wordpress.com/2016/09/)
* [August 2016](https://securitypitfalls.wordpress.com/2016/08/)
* [April 2016](https://securitypitfalls.wordpress.com/2016/04/)
* [March 2016](https://securitypitfalls.wordpress.com/2016/03/)
* [January 2016](https://securitypitfalls.wordpress.com/2016/01/)
* [December 2015](https://securitypitfalls.wordpress.com/2015/12/)
* [November 2015](https://securitypitfalls.wordpress.com/2015/11/)
* [September 2015](https://securitypitfalls.wordpress.com/2015/09/)
* [July 2015](https://securitypitfalls.wordpress.com/2015/07/)
* [June 2015](https://securitypitfalls.wordpress.com/2015/06/)
* [May 2015](https://securitypitfalls.wordpress.com/2015/05/)
* [April 2015](https://securitypitfalls.wordpress.com/2015/04/)
* [March 2015](https://securitypitfalls.wordpress.com/2015/03/)
* [February 2015](https://securitypitfalls.wordpress.com/2015/02/)
* [January 2015](https://securitypitfalls.wordpress.com/2015/01/)
* [December 2014](https://securitypitfalls.wordpress.com/2014/12/)
* [October 2014](https://securitypitfalls.wordpress.com/2014/10/)
* [September 2014](https://securitypitfalls.wordpress.com/2014/09/)
* [August 2014](https://securitypitfalls.wordpress.com/2014/08/)
* [July 2014](https://securitypitfalls.wordpress.com/2014/07/)
* [June 2014](https://securitypitfalls.wordpress.com/2014/06/)
* [May 2014](https://securitypitfalls.wordpress.com/2014/05/)
### Categories

* [Articles](https://securitypitfalls.wordpress.com/category/articles/)
* [Bookmarks](https://securitypitfalls.wordpress.com/category/bookmarks/)
* [Scan results](https://securitypitfalls.wordpress.com/category/scan-results/)
* [Uncategorized](https://securitypitfalls.wordpress.com/category/uncategorized/)
### Meta

* [Register](https://wordpress.com/start?ref=wplogin)
* [Log in](https://securitypitfalls.wordpress.com/wp-login.php)
* [Entries feed](https://securitypitfalls.wordpress.com/feed/)
* [Comments feed](https://securitypitfalls.wordpress.com/comments/feed/)
* [WordPress.com](https://wordpress.com/ "Powered by WordPress, state-of-the-art semantic personal publishing platform.")

[Create a free website or blog at WordPress.com.](https://wordpress.com/?ref=footer_website)

* [Comment](https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/#comments)
* Reblog
* Subscribe
  Subscribed

  + [![](https://s2.wp.com/i/logo/wpcom-gray-white.png) securitypitfalls](https://securitypitfalls.wordpress.com)

  Join 25 other subscribers

  Sign me up

  + Already have a WordPress.com account? [Log in now.](https://wordpress.com/log-in?redirect_to=https%3A%2F%2Fsecuritypitfalls.wordpress.com%2F2018%2F08%2F03%2Fconstant-time-compare-in-python%2F&signup_flow=account)
* Privacy
* + [![](https://s2.wp.com/i/logo/wpcom-gray-white.png) securitypitfalls](https://securitypitfalls.wordpress.com)
  + Subscribe
    Subscribed
  + [Sign up](https://wordpress.com/start/)
  + [Log in](https://wordpress.com/log-in?redirect_to=https%3A%2F%2Fsecuritypitfalls.wordpress.com%2F2018%2F08%2F03%2Fconstant-time-compare-in-python%2F&signup_flow=account)
  + [Copy shortlink](https://wp.me/p4BPwe-dj)
  + [Report this content](https://wordpress.com/abuse/?report_url=https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/)
  + [View post in Reader](https://wordpress.com/read/blogs/68121522/posts/825)
  + [Manage subscriptions](https://subscribe.wordpress.com/)
  + Collapse this bar

##

##

Loading Comments...

Write a Comment...

Email (Required)

Name (Required)

Website

###

%d

![](https://pixel.wp.com/b.gif?v=noscript)
Design a site like this with WordPress.com[Get started](https://wordpress.com/start/?ref=marketing_bar)



=== Content from github.com_91bb8cc6_20250115_111936.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftlsfuzzer%2Fpython-ecdsa)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftlsfuzzer%2Fpython-ecdsa)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E&source=header-repo&source_repo=tlsfuzzer%2Fpython-ecdsa)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[tlsfuzzer](/tlsfuzzer)
/
**[python-ecdsa](/tlsfuzzer/python-ecdsa)**
Public

* [Notifications](/login?return_to=%2Ftlsfuzzer%2Fpython-ecdsa) You must be signed in to change notification settings
* [Fork
  314](/login?return_to=%2Ftlsfuzzer%2Fpython-ecdsa)
* [Star
   927](/login?return_to=%2Ftlsfuzzer%2Fpython-ecdsa)

pure-python ECDSA signature/verification and ECDH key agreement

### License

[View license](/tlsfuzzer/python-ecdsa/blob/master/LICENSE)

[927
stars](/tlsfuzzer/python-ecdsa/stargazers) [314
forks](/tlsfuzzer/python-ecdsa/forks) [Branches](/tlsfuzzer/python-ecdsa/branches) [Tags](/tlsfuzzer/python-ecdsa/tags) [Activity](/tlsfuzzer/python-ecdsa/activity)
 [Star](/login?return_to=%2Ftlsfuzzer%2Fpython-ecdsa)

 [Notifications](/login?return_to=%2Ftlsfuzzer%2Fpython-ecdsa) You must be signed in to change notification settings

* [Code](/tlsfuzzer/python-ecdsa)
* [Issues
  15](/tlsfuzzer/python-ecdsa/issues)
* [Pull requests
  1](/tlsfuzzer/python-ecdsa/pulls)
* [Discussions](/tlsfuzzer/python-ecdsa/discussions)
* [Actions](/tlsfuzzer/python-ecdsa/actions)
* [Projects
  0](/tlsfuzzer/python-ecdsa/projects)
* [Wiki](/tlsfuzzer/python-ecdsa/wiki)
* [Security](/tlsfuzzer/python-ecdsa/security)
* [Insights](/tlsfuzzer/python-ecdsa/pulse)

Additional navigation options

* [Code](/tlsfuzzer/python-ecdsa)
* [Issues](/tlsfuzzer/python-ecdsa/issues)
* [Pull requests](/tlsfuzzer/python-ecdsa/pulls)
* [Discussions](/tlsfuzzer/python-ecdsa/discussions)
* [Actions](/tlsfuzzer/python-ecdsa/actions)
* [Projects](/tlsfuzzer/python-ecdsa/projects)
* [Wiki](/tlsfuzzer/python-ecdsa/wiki)
* [Security](/tlsfuzzer/python-ecdsa/security)
* [Insights](/tlsfuzzer/python-ecdsa/pulse)

# tlsfuzzer/python-ecdsa

    master[Branches](/tlsfuzzer/python-ecdsa/branches)[Tags](/tlsfuzzer/python-ecdsa/tags)Go to fileCode
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| Latest commit History[727 Commits](/tlsfuzzer/python-ecdsa/commits/master/) | | |
| [.github/workflows](/tlsfuzzer/python-ecdsa/tree/master/.github/workflows "This path skips through empty directories") | | [.github/workflows](/tlsfuzzer/python-ecdsa/tree/master/.github/workflows "This path skips through empty directories") |  |  |
| [docs](/tlsfuzzer/python-ecdsa/tree/master/docs "docs") | | [docs](/tlsfuzzer/python-ecdsa/tree/master/docs "docs") |  |  |
| [sql](/tlsfuzzer/python-ecdsa/tree/master/sql "sql") | | [sql](/tlsfuzzer/python-ecdsa/tree/master/sql "sql") |  |  |
| [src/ecdsa](/tlsfuzzer/python-ecdsa/tree/master/src/ecdsa "This path skips through empty directories") | | [src/ecdsa](/tlsfuzzer/python-ecdsa/tree/master/src/ecdsa "This path skips through empty directories") |  |  |
| [.coveragerc](/tlsfuzzer/python-ecdsa/blob/master/.coveragerc ".coveragerc") | | [.coveragerc](/tlsfuzzer/python-ecdsa/blob/master/.coveragerc ".coveragerc") |  |  |
| [.gitattributes](/tlsfuzzer/python-ecdsa/blob/master/.gitattributes ".gitattributes") | | [.gitattributes](/tlsfuzzer/python-ecdsa/blob/master/.gitattributes ".gitattributes") |  |  |
| [.gitignore](/tlsfuzzer/python-ecdsa/blob/master/.gitignore ".gitignore") | | [.gitignore](/tlsfuzzer/python-ecdsa/blob/master/.gitignore ".gitignore") |  |  |
| [.gitleaks.toml](/tlsfuzzer/python-ecdsa/blob/master/.gitleaks.toml ".gitleaks.toml") | | [.gitleaks.toml](/tlsfuzzer/python-ecdsa/blob/master/.gitleaks.toml ".gitleaks.toml") |  |  |
| [.readthedocs.yaml](/tlsfuzzer/python-ecdsa/blob/master/.readthedocs.yaml ".readthedocs.yaml") | | [.readthedocs.yaml](/tlsfuzzer/python-ecdsa/blob/master/.readthedocs.yaml ".readthedocs.yaml") |  |  |
| [.travis.yml](/tlsfuzzer/python-ecdsa/blob/master/.travis.yml ".travis.yml") | | [.travis.yml](/tlsfuzzer/python-ecdsa/blob/master/.travis.yml ".travis.yml") |  |  |
| [LICENSE](/tlsfuzzer/python-ecdsa/blob/master/LICENSE "LICENSE") | | [LICENSE](/tlsfuzzer/python-ecdsa/blob/master/LICENSE "LICENSE") |  |  |
| [MANIFEST.in](/tlsfuzzer/python-ecdsa/blob/master/MANIFEST.in "MANIFEST.in") | | [MANIFEST.in](/tlsfuzzer/python-ecdsa/blob/master/MANIFEST.in "MANIFEST.in") |  |  |
| [NEWS](/tlsfuzzer/python-ecdsa/blob/master/NEWS "NEWS") | | [NEWS](/tlsfuzzer/python-ecdsa/blob/master/NEWS "NEWS") |  |  |
| [README.md](/tlsfuzzer/python-ecdsa/blob/master/README.md "README.md") | | [README.md](/tlsfuzzer/python-ecdsa/blob/master/README.md "README.md") |  |  |
| [SECURITY.md](/tlsfuzzer/python-ecdsa/blob/master/SECURITY.md "SECURITY.md") | | [SECURITY.md](/tlsfuzzer/python-ecdsa/blob/master/SECURITY.md "SECURITY.md") |  |  |
| [build-requirements-2.6.txt](/tlsfuzzer/python-ecdsa/blob/master/build-requirements-2.6.txt "build-requirements-2.6.txt") | | [build-requirements-2.6.txt](/tlsfuzzer/python-ecdsa/blob/master/build-requirements-2.6.txt "build-requirements-2.6.txt") |  |  |
| [build-requirements-2.7.txt](/tlsfuzzer/python-ecdsa/blob/master/build-requirements-2.7.txt "build-requirements-2.7.txt") | | [build-requirements-2.7.txt](/tlsfuzzer/python-ecdsa/blob/master/build-requirements-2.7.txt "build-requirements-2.7.txt") |  |  |
| [build-requirements.txt](/tlsfuzzer/python-ecdsa/blob/master/build-requirements.txt "build-requirements.txt") | | [build-requirements.txt](/tlsfuzzer/python-ecdsa/blob/master/build-requirements.txt "build-requirements.txt") |  |  |
| [conftest.py](/tlsfuzzer/python-ecdsa/blob/master/conftest.py "conftest.py") | | [conftest.py](/tlsfuzzer/python-ecdsa/blob/master/conftest.py "conftest.py") |  |  |
| [cosmic-ray-12way.sh](/tlsfuzzer/python-ecdsa/blob/master/cosmic-ray-12way.sh "cosmic-ray-12way.sh") | | [cosmic-ray-12way.sh](/tlsfuzzer/python-ecdsa/blob/master/cosmic-ray-12way.sh "cosmic-ray-12way.sh") |  |  |
| [cosmic-ray-12way.toml](/tlsfuzzer/python-ecdsa/blob/master/cosmic-ray-12way.toml "cosmic-ray-12way.toml") | | [cosmic-ray-12way.toml](/tlsfuzzer/python-ecdsa/blob/master/cosmic-ray-12way.toml "cosmic-ray-12way.toml") |  |  |
| [cosmic-ray.sh](/tlsfuzzer/python-ecdsa/blob/master/cosmic-ray.sh "cosmic-ray.sh") | | [cosmic-ray.sh](/tlsfuzzer/python-ecdsa/blob/master/cosmic-ray.sh "cosmic-ray.sh") |  |  |
| [cosmic-ray.toml](/tlsfuzzer/python-ecdsa/blob/master/cosmic-ray.toml "cosmic-ray.toml") | | [cosmic-ray.toml](/tlsfuzzer/python-ecdsa/blob/master/cosmic-ray.toml "cosmic-ray.toml") |  |  |
| [diff-instrumental.py](/tlsfuzzer/python-ecdsa/blob/master/diff-instrumental.py "diff-instrumental.py") | | [diff-instrumental.py](/tlsfuzzer/python-ecdsa/blob/master/diff-instrumental.py "diff-instrumental.py") |  |  |
| [requirements.txt](/tlsfuzzer/python-ecdsa/blob/master/requirements.txt "requirements.txt") | | [requirements.txt](/tlsfuzzer/python-ecdsa/blob/master/requirements.txt "requirements.txt") |  |  |
| [setup.cfg](/tlsfuzzer/python-ecdsa/blob/master/setup.cfg "setup.cfg") | | [setup.cfg](/tlsfuzzer/python-ecdsa/blob/master/setup.cfg "setup.cfg") |  |  |
| [setup.py](/tlsfuzzer/python-ecdsa/blob/master/setup.py "setup.py") | | [setup.py](/tlsfuzzer/python-ecdsa/blob/master/setup.py "setup.py") |  |  |
| [speed.py](/tlsfuzzer/python-ecdsa/blob/master/speed.py "speed.py") | | [speed.py](/tlsfuzzer/python-ecdsa/blob/master/speed.py "speed.py") |  |  |
| [tox.ini](/tlsfuzzer/python-ecdsa/blob/master/tox.ini "tox.ini") | | [tox.ini](/tlsfuzzer/python-ecdsa/blob/master/tox.ini "tox.ini") |  |  |
| [versioneer.py](/tlsfuzzer/python-ecdsa/blob/master/versioneer.py "versioneer.py") | | [versioneer.py](/tlsfuzzer/python-ecdsa/blob/master/versioneer.py "versioneer.py") |  |  |
| View all files | | |

## Repository files navigation

* README
* License
* Security
# Pure-Python ECDSA and ECDH

[![Build Status](https://github.com/tlsfuzzer/python-ecdsa/workflows/GitHub%20CI/badge.svg?branch=master)](https://github.com/tlsfuzzer/python-ecdsa/actions?query=workflow%3A%22GitHub+CI%22+branch%3Amaster)
[![Documentation Status](https://camo.githubusercontent.com/636e021505eafcfcf14b8816b6d1f9393510771e63f16687a6223d27d5a1d100/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f65636473612f62616467652f3f76657273696f6e3d6c6174657374)](https://ecdsa.readthedocs.io/en/latest/?badge=latest)
[![Coverage Status](https://camo.githubusercontent.com/d0cea132ecb78e2fb1e5538105d3b1898b18ccdd2600de7ecac13e3997cbf45b/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f746c7366757a7a65722f707974686f6e2d65636473612f62616467652e7376673f6272616e63683d6d6173746572)](https://coveralls.io/github/tlsfuzzer/python-ecdsa?branch=master)
[![condition coverage](https://camo.githubusercontent.com/b5db82e545e0ffc36e930d10d5f5ef4ead9e64cba1f79a1c723f0d4f9d5611a0/68747470733a2f2f696d672e736869656c64732e696f2f656e64706f696e743f75726c3d68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f746f6d61746f34322f39623663613166333431303230376662656361373835613137383738313635312f7261772f707974686f6e2d65636473612d636f6e646974696f6e2d636f7665726167652e6a736f6e)](https://camo.githubusercontent.com/b5db82e545e0ffc36e930d10d5f5ef4ead9e64cba1f79a1c723f0d4f9d5611a0/68747470733a2f2f696d672e736869656c64732e696f2f656e64706f696e743f75726c3d68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f746f6d61746f34322f39623663613166333431303230376662656361373835613137383738313635312f7261772f707974686f6e2d65636473612d636f6e646974696f6e2d636f7665726167652e6a736f6e)
[![mutation score](https://camo.githubusercontent.com/c0b72f2f47a26aab7efa0e79f2cbce8ac166693d038945044df1a4b3e473f9e1/68747470733a2f2f696d672e736869656c64732e696f2f656e64706f696e743f75726c3d68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f746f6d61746f34322f39623663613166333431303230376662656361373835613137383738313635312f7261772f707974686f6e2d65636473612d6d75746174696f6e2d73636f72652e6a736f6e)](https://camo.githubusercontent.com/c0b72f2f47a26aab7efa0e79f2cbce8ac166693d038945044df1a4b3e473f9e1/68747470733a2f2f696d672e736869656c64732e696f2f656e64706f696e743f75726c3d68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f746f6d61746f34322f39623663613166333431303230376662656361373835613137383738313635312f7261772f707974686f6e2d65636473612d6d75746174696f6e2d73636f72652e6a736f6e)
[![CodeQL](https://github.com/tlsfuzzer/python-ecdsa/actions/workflows/codeql.yml/badge.svg)](https://github.com/tlsfuzzer/python-ecdsa/actions/workflows/codeql.yml)
[![Latest Version](https://camo.githubusercontent.com/ee83df67bfaf84a15960aea82bb24dd7f34386360398b0154c77b92096d3b804/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f65636473612e7376673f7374796c653d666c6174)](https://pypi.python.org/pypi/ecdsa/)
[![Code style: black](https://camo.githubusercontent.com/5a2ed12640787e7d99f27c480321967cb13449cf55db346fd2529535aafcdd40/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f64652532307374796c652d626c61636b2d3030303030302e7376673f7374796c653d666c6174)](https://camo.githubusercontent.com/5a2ed12640787e7d99f27c480321967cb13449cf55db346fd2529535aafcdd40/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f64652532307374796c652d626c61636b2d3030303030302e7376673f7374796c653d666c6174)

This is an easy-to-use implementation of ECC (Elliptic Curve Cryptography)
with support for ECDSA (Elliptic Curve Digital Signature Algorithm),
EdDSA (Edwards-curve Digital Signature Algorithm) and ECDH
(Elliptic Curve Diffie-Hellman), implemented purely in Python, released under
the MIT license. With this library, you can quickly create key pairs (signing
key and verifying key), sign messages, and verify the signatures. You can
also agree on a shared secret key based on exchanged public keys.
The keys and signatures are very short, making them easy to handle and
incorporate into other protocols.

**NOTE: This library should not be used in production settings, see [Security](#Security) for more details.**

## Features

This library provides key generation, signing, verifying, and shared secret
derivation for five
popular NIST "Suite B" GF(p) (*prime field*) curves, with key lengths of 192,
224, 256, 384, and 521 bits. The "short names" for these curves, as known by
the OpenSSL tool (`openssl ecparam -list_curves`), are: `prime192v1`,
`secp224r1`, `prime256v1`, `secp384r1`, and `secp521r1`. It includes the
256-bit curve `secp256k1` used by Bitcoin. There is also support for the
regular (non-twisted) variants of Brainpool curves from 160 to 512 bits. The
"short names" of those curves are: `brainpoolP160r1`, `brainpoolP192r1`,
`brainpoolP224r1`, `brainpoolP256r1`, `brainpoolP320r1`, `brainpoolP384r1`,
`brainpoolP512r1`. Few of the small curves from SEC standard are also
included (mainly to speed-up testing of the library), those are:
`secp112r1`, `secp112r2`, `secp128r1`, and `secp160r1`.
Key generation, siging and verifying is also supported for Ed25519 and
Ed448 curves.
No other curves are included, but it is not too hard to add support for more
curves over prime fields.

## Dependencies

This library uses only Python and the 'six' package. It is compatible with
Python 2.6, 2.7, and 3.6+. It also supports execution on alternative
implementations like pypy and pypy3.

If `gmpy2` or `gmpy` is installed, they will be used for faster arithmetic.
Either of them can be installed after this library is installed,
`python-ecdsa` will detect their presence on start-up and use them
automatically.
You should prefer `gmpy2` on Python3 for optimal performance.

To run the OpenSSL compatibility tests, the 'openssl' tool must be in your
`PATH`. This release has been tested successfully against OpenSSL 0.9.8o,
1.0.0a, 1.0.2f, 1.1.1d and 3.0.1 (among others).

## Installation

This library is available on PyPI, it's recommended to install it using `pip`:

```
pip install ecdsa

```

In case higher performance is wanted and using native code is not a problem,
it's possible to specify installation together with `gmpy2`:

```
pip install ecdsa[gmpy2]

```

or (slower, legacy option):

```
pip install ecdsa[gmpy]

```

## Speed

The following table shows how long this library takes to generate key pairs
(`keygen`), to sign data (`sign`), to verify those signatures (`verify`),
to derive a shared secret (`ecdh`), and
to verify the signatures with no key-specific precomputation (`no PC verify`).
All those values are in seconds.
For convenience, the inverses of those values are also provided:
how many keys per second can be generated (`keygen/s`), how many signatures
can be made per second (`sign/s`), how many signatures can be verified
per second (`verify/s`), how many shared secrets can be derived per second
(`ecdh/s`), and how many signatures with no key specific
precomputation can be verified per second (`no PC verify/s`). The size of raw
signature (generally the smallest
the way a signature can be encoded) is also provided in the `siglen` column.
Use `tox -e speed` to generate this table on your own computer.
On an Intel Core i7 4790K @ 4.0GHz I'm getting the following performance:

```
                  siglen    keygen   keygen/s      sign     sign/s    verify   verify/s  no PC verify  no PC verify/s
        NIST192p:     48   0.00032s   3134.06   0.00033s   2985.53   0.00063s   1598.36       0.00129s         774.43
        NIST224p:     56   0.00040s   2469.24   0.00042s   2367.88   0.00081s   1233.41       0.00170s         586.66
        NIST256p:     64   0.00051s   1952.73   0.00054s   1867.80   0.00098s   1021.86       0.00212s         471.27
        NIST384p:     96   0.00107s    935.92   0.00111s    904.23   0.00203s    491.77       0.00446s         224.00
        NIST521p:    132   0.00210s    475.52   0.00215s    464.16   0.00398s    251.28       0.00874s         114.39
       SECP256k1:     64   0.00052s   1921.54   0.00054s   1847.49   0.00105s    948.68       0.00210s         477.01
 BRAINPOOLP160r1:     40   0.00025s   4003.88   0.00026s   3845.12   0.00053s   1893.93       0.00105s         949.92
 BRAINPOOLP192r1:     48   0.00033s   3043.97   0.00034s   2975.98   0.00063s   1581.50       0.00135s         742.29
 BRAINPOOLP224r1:     56   0.00041s   2436.44   0.00043s   2315.51   0.00078s   1278.49       0.00180s         556.16
 BRAINPOOLP256r1:     64   0.00053s   1892.49   0.00054s   1846.24   0.00114s    875.64       0.00229s         437.25
 BRAINPOOLP320r1:     80   0.00073s   1361.26   0.00076s   1309.25   0.00143s    699.29       0.00322s         310.49
 BRAINPOOLP384r1:     96   0.00107s    931.29   0.00111s    901.80   0.00230s    434.19       0.00476s         210.20
 BRAINPOOLP512r1:    128   0.00207s    483.41   0.00212s    471.42   0.00425s    235.43       0.00912s         109.61
       SECP112r1:     28   0.00015s   6672.53   0.00016s   6440.34   0.00031s   3265.41       0.00056s        1774.20
       SECP112r2:     28   0.00015s   6697.11   0.00015s   6479.98   0.00028s   3524.72       0.00058s        1716.16
       SECP128r1:     32   0.00018s   5497.65   0.00019s   5272.89   0.00036s   2747.39       0.00072s        1396.16
       SECP160r1:     42   0.00025s   3949.32   0.00026s   3894.45   0.00046s   2153.85       0.00102s         985.07
         Ed25519:     64   0.00076s   1324.48   0.00042s   2405.01   0.00109s    918.05       0.00344s         290.50
           Ed448:    114   0.00176s    569.53   0.00115s    870.94   0.00282s    355.04       0.01024s          97.69

                       ecdh     ecdh/s
        NIST192p:   0.00104s    964.89
        NIST224p:   0.00134s    748.63
        NIST256p:   0.00170s    587.08
        NIST384p:   0.00352s    283.90
        NIST521p:   0.00717s    139.51
       SECP256k1:   0.00154s    648.40
 BRAINPOOLP160r1:   0.00082s   1220.70
 BRAINPOOLP192r1:   0.00105s    956.75
 BRAINPOOLP224r1:   0.00136s    734.52
 BRAINPOOLP256r1:   0.00178s    563.32
 BRAINPOOLP320r1:   0.00252s    397.23
 BRAINPOOLP384r1:   0.00376s    266.27
 BRAINPOOLP512r1:   0.00733s    136.35
       SECP112r1:   0.00046s   2180.40
       SECP112r2:   0.00045s   2229.14
       SECP128r1:   0.00054s   1868.15
       SECP160r1:   0.00080s   1243.98

```

To test performance with `gmpy2` loaded, use `tox -e speedgmpy2`.
On the same machine I'm getting the following performance with `gmpy2`:

```
                  siglen    keygen   keygen/s      sign     sign/s    verify   verify/s  no PC verify  no PC verify/s
        NIST192p:     48   0.00017s   5933.40   0.00017s   5751.70   0.00032s   3125.28       0.00067s        1502.41
        NIST224p:     56   0.00021s   4782.87   0.00022s   4610.05   0.00040s   2487.04       0.00089s        1126.90
        NIST256p:     64   0.00023s   4263.98   0.00024s   4125.16   0.00045s   2200.88       0.00098s        1016.82
        NIST384p:     96   0.00041s   2449.54   0.00042s   2399.96   0.00083s   1210.57       0.00172s         581.43
        NIST521p:    132   0.00071s   1416.07   0.00072s   1389.81   0.00144s    692.93       0.00312s         320.40
       SECP256k1:     64   0.00024s   4245.05   0.00024s   4122.09   0.00045s   2206.40       0.00094s        1068.32
 BRAINPOOLP160r1:     40   0.00014s   6939.17   0.00015s   6681.55   0.00029s   3452.43       0.00057s        1769.81
 BRAINPOOLP192r1:     48   0.00017s   5920.05   0.00017s   5774.36   0.00034s   2979.00       0.00069s        1453.19
 BRAINPOOLP224r1:     56   0.00021s   4732.12   0.00022s   4622.65   0.00041s   2422.47       0.00087s        1149.87
 BRAINPOOLP256r1:     64   0.00024s   4233.02   0.00024s   4115.20   0.00047s   2143.27       0.00098s        1015.60
 BRAINPOOLP320r1:     80   0.00032s   3162.38   0.00032s   3077.62   0.00063s   1598.83       0.00136s         737.34
 BRAINPOOLP384r1:     96   0.00041s   2436.88   0.00042s   2395.62   0.00083s   1202.68       0.00178s         562.85
 BRAINPOOLP512r1:    128   0.00063s   1587.60   0.00064s   1558.83   0.00125s    799.96       0.00281s         355.83
       SECP112r1:     28   0.00009s  11118.66   0.00009s  10775.48   0.00018s   5456.00       0.00033s        3020.83
       SECP112r2:     28   0.00009s  11322.97   0.00009s  10857.71   0.00017s   5748.77       0.00032s        3094.28
       SECP128r1:     32   0.00010s  10078.39   0.00010s   9665.27   0.00019s   5200.58       0.00036s        2760.88
       SECP160r1:     42   0.00015s   6875.51   0.00015s   6647.35   0.00029s   3422.41       0.00057s        1768.35
         Ed25519:     64   0.00030s   3322.56   0.00018s   5568.63   0.00046s   2165.35       0.00153s         654.02
           Ed448:    114   0.00060s   1680.53   0.00039s   2567.40   0.00096s   1036.67       0.00350s         285.62

                       ecdh     ecdh/s
        NIST192p:   0.00050s   1985.70
        NIST224p:   0.00066s   1524.16
        NIST256p:   0.00071s   1413.07
        NIST384p:   0.00127s    788.89
        NIST521p:   0.00230s    434.85
       SECP256k1:   0.00071s   1409.95
 BRAINPOOLP160r1:   0.00042s   2374.65
 BRAINPOOLP192r1:   0.00051s   1960.01
 BRAINPOOLP224r1:   0.00066s   1518.37
 BRAINPOOLP256r1:   0.00071s   1399.90
 BRAINPOOLP320r1:   0.00100s    997.21
 BRAINPOOLP384r1:   0.00129s    777.51
 BRAINPOOLP512r1:   0.00210s    475.99
       SECP112r1:   0.00022s   4457.70
       SECP112r2:   0.00024s   4252.33
       SECP128r1:   0.00028s   3589.31
       SECP160r1:   0.00043s   2305.02

```

(there's also `gmpy` version, execute it using `tox -e speedgmpy`)

For comparison, a highly optimised implementation (including curve-specific
assembly for some curves), like the one in OpenSSL 1.1.1d, provides the
following performance numbers on the same machine.
Run `openssl speed ecdsa` and `openssl speed ecdh` to reproduce it:

```
                              sign    verify    sign/s verify/s
 192 bits ecdsa (nistp192)   0.0002s   0.0002s   4785.6   5380.7
 224 bits ecdsa (nistp224)   0.0000s   0.0001s  22475.6   9822.0
 256 bits ecdsa (nistp256)   0.0000s   0.0001s  45069.6  14166.6
 384 bits ecdsa (nistp384)   0.0008s   0.0006s   1265.6   1648.1
 521 bits ecdsa (nistp521)   0.0003s   0.0005s   3753.1   1819.5
 256 bits ecdsa (brainpoolP256r1)   0.0003s   0.0003s   2983.5   3333.2
 384 bits ecdsa (brainpoolP384r1)   0.0008s   0.0007s   1258.8   1528.1
 512 bits ecdsa (brainpoolP512r1)   0.0015s   0.0012s    675.1    860.1

                              sign    verify    sign/s verify/s
 253 bits EdDSA (Ed25519)   0.0000s   0.0001s  28217.9  10897.7
 456 bits EdDSA (Ed448)     0.0003s   0.0005s   3926.5   2147.7

                               op      op/s
 192 bits ecdh (nistp192)   0.0002s   4853.4
 224 bits ecdh (nistp224)   0.0001s  15252.1
 256 bits ecdh (nistp256)   0.0001s  18436.3
 384 bits ecdh (nistp384)   0.0008s   1292.7
 521 bits ecdh (nistp521)   0.0003s   2884.7
 256 bits ecdh (brainpoolP256r1)   0.0003s   3066.5
 384 bits ecdh (brainpoolP384r1)   0.0008s   1298.0
 512 bits ecdh (brainpoolP512r1)   0.0014s    694.8

```

Keys and signature can be serialized in different ways (see Usage, below).
For a NIST192p key, the three basic representations require strings of the
following lengths (in bytes):

```
to_string:  signkey= 24, verifykey= 48, signature=48
compressed: signkey=n/a, verifykey= 25, signature=n/a
DER:        signkey=106, verifykey= 80, signature=55
PEM:        signkey=278, verifykey=162, (no support for PEM signatures)

```

## History

In 2006, Peter Pearson announced his pure-python implementation of ECDSA in a
[message to sci.crypt](http://www.derkeiler.com/Newsgroups/sci.crypt/2006-01/msg00651.html), available from his [download site](http://webpages.charter.net/curryfans/peter/downloads.html). In 2010,
Brian Warner wrote a wrapper around this code, to make it a bit easier and
safer to use. In 2020, Hubert Kario included an implementation of elliptic
curve cryptography that uses Jacobian coordinates internally, improving
performance about 20-fold. You are looking at the README for this wrapper.

## Testing

To run the full test suite, do this:

```
tox -e coverage

```

On an Intel Core i7 4790K @ 4.0GHz, the tests take about 18 seconds to execute.
The test suite uses
[`hypothesis`](https://github.com/HypothesisWorks/hypothesis) so there is some
inherent variability in the test suite execution time.

One part of `test_pyecdsa.py` and `test_ecdh.py` checks compatibility with
OpenSSL, by running the "openssl" CLI tool, make sure it's in your `PATH` if
you want to test compatibility with it (if OpenSSL is missing, too old, or
doesn't support all the curves supported in upstream releases you will see
skipped tests in the above `coverage` run).

## Security

This library was not designed with security in mind. If you are processing
data that needs to be protected we suggest you use a quality wrapper around
OpenSSL. [pyca/cryptography](https://cryptography.io) is one example of such
a wrapper. The primary use-case of this library is as a portable library for
interoperability testing and as a teaching tool.

**This library does not protect against side-channel attacks.**

Do not allow attackers to measure how long it takes you to generate a key pair
or sign a message. Do not allow attackers to run code on the same physical
machine when key pair generation or signing is taking place (this includes
virtual machines). Do not allow attackers to measure how much power your
computer uses while generating the key pair or signing a message. Do not allow
attackers to measure RF interference coming from your computer while generating
a key pair or signing a message. Note: just loading the private key will cause
key pair generation. Other operations or attack vectors may also be
vulnerable to attacks. **For a sophisticated attacker observing just one
operation with a private key will be sufficient to completely
reconstruct the private key**.

Please also note that any Pure-python cryptographic library will be vulnerable
to the same side-channel attacks. This is because Python does not provide
side-channel secure primitives (with the exception of
[`hmac.compare_digest()`](https://docs.python.org/3/library/hmac.html#hmac.compare_digest)), making side-channel secure programming
impossible.

This library depends upon a strong source of random numbers. Do not use it on
a system where `os.urandom()` does not provide cryptographically secure
random numbers.

## Usage

You start by creating a `SigningKey`. You can use this to sign data, by passing
in data as a byte string and getting back the signature (also a byte string).
You can also ask a `SigningKey` to give you the corresponding `VerifyingKey`.
The `VerifyingKey` can be used to verify a signature, by passing it both the
data string and the signature byte string: it either returns True or raises
`BadSignatureError`.

```
from ecdsa import SigningKey
sk = SigningKey.generate() # uses NIST192p
vk = sk.verifying_key
signature = sk.sign(b"message")
assert vk.verify(signature, b"message")
```

Each `SigningKey`/`VerifyingKey` is associated with a specific curve, like
NIST192p (the default one). Longer curves are more secure, but take longer to
use, and result in longer keys and signatures.

```
from ecdsa import SigningKey, NIST384p
sk = SigningKey.generate(curve=NIST384p)
vk = sk.verifying_key
signature = sk.sign(b"message")
assert vk.verify(signature, b"message")
```

The `SigningKey` can be serialized into several different formats: the shortest
is to call `s=sk.to_string()`, and then re-create it with
`SigningKey.from_string(s, curve)` . This short form does not record the
curve, so you must be sure to pass to `from_string()` the same curve you used
for the original key. The short form of a NIST192p-based signing key is just 24
bytes long. If a point encoding is invalid or it does not lie on the specified
curve, `from_string()` will raise `MalformedPointError`.

```
from ecdsa import SigningKey, NIST384p
sk = SigningKey.generate(curve=NIST384p)
sk_string = sk.to_string()
sk2 = SigningKey.from_string(sk_string, curve=NIST384p)
print(sk_string.hex())
print(sk2.to_string().hex())
```

Note: while the methods are called `to_string()` the type they return is
actually `bytes`, the "string" part is leftover from Python 2.

`sk.to_pem()` and `sk.to_der()` will serialize the signing key into the same
formats that OpenSSL uses. The PEM file looks like the familiar ASCII-armored
`"-----BEGIN EC PRIVATE KEY-----"` base64-encoded format, and the DER format
is a shorter binary form of the same data.
`SigningKey.from_pem()/.from_der()` will undo this serialization. These
formats include the curve name, so you do not need to pass in a curve
identifier to the deserializer. In case the file is malformed `from_der()`
and `from_pem()` will raise `UnexpectedDER` or `MalformedPointError`.

```
from ecdsa import SigningKey, NIST384p
sk = SigningKey.generate(curve=NIST384p)
sk_pem = sk.to_pem()
sk2 = SigningKey.from_pem(sk_pem)
# sk and sk2 are the same key
```

Likewise, the `VerifyingKey` can be serialized in the same way:
`vk.to_string()/VerifyingKey.from_string()`, `to_pem()/from_pem()`, and
`to_der()/from_der()`. The same `curve=` argument is needed for
`VerifyingKey.from_string()`.

```
from ecdsa import SigningKey, VerifyingKey, NIST384p
sk = SigningKey.generate(curve=NIST384p)
vk = sk.verifying_key
vk_string = vk.to_string()
vk2 = VerifyingKey.from_string(vk_string, curve=NIST384p)
# vk and vk2 are the same key

from ecdsa import SigningKey, VerifyingKey, NIST384p
sk = SigningKey.generate(curve=NIST384p)
vk = sk.verifying_key
vk_pem = vk.to_pem()
vk2 = VerifyingKey.from_pem(vk_pem)
# vk and vk2 are the same key
```

There are a couple of different ways to compute a signature. Fundamentally,
ECDSA takes a number that represents the data being signed, and returns a
pair of numbers that represent the signature. The `hashfunc=` argument to
`sk.sign()` and `vk.verify()` is used to turn an arbitrary string into a
fixed-length digest, which is then turned into a number that ECDSA can sign,
and both sign and verify must use the same approach. The default value is
`hashlib.sha1`, but if you use NIST256p or a longer curve, you can use
`hashlib.sha256` instead.

There are also multiple ways to represent a signature. The default
`sk.sign()` and `vk.verify()` methods present it as a short string, for
simplicity and minimal overhead. To use a different scheme, use the
`sk.sign(sigencode=)` and `vk.verify(sigdecode=)` arguments. There are helper
functions in the `ecdsa.util` module that can be useful here.

It is also possible to create a `SigningKey` from a "seed", which is
deterministic. This can be used in protocols where you want to derive
consistent signing keys from some other secret, for example when you want
three separate keys and only want to store a single master secret. You should
start with a uniformly-distributed unguessable seed with about `curve.baselen`
bytes of entropy, and then use one of the helper functions in `ecdsa.util` to
convert it into an integer in the correct range, and then finally pass it
into `SigningKey.from_secret_exponent()`, like this:

```
import os
from ecdsa import NIST384p, SigningKey
from ecdsa.util import randrange_from_seed__trytryagain

def make_key(seed):
  secexp = randrange_from_seed__trytryagain(seed, NIST384p.order)
  return SigningKey.from_secret_exponent(secexp, curve=NIST384p)

seed = os.urandom(NIST384p.baselen) # or other starting point
sk1a = make_key(seed)
sk1b = make_key(seed)
# note: sk1a and sk1b are the same key
assert sk1a.to_string() == sk1b.to_string()
sk2 = make_key(b"2-"+seed)  # different key
assert sk1a.to_string() != sk2.to_string()
```

In case the application will verify a lot of signatures made with a single
key, it's possible to precompute some of the internal values to make
signature verification significantly faster. The break-even point occurs at
about 100 signatures verified.

To perform precomputation, you can call the `precompute()` method
on `VerifyingKey` instance:

```
from ecdsa import SigningKey, NIST384p
sk = SigningKey.generate(curve=NIST384p)
vk = sk.verifying_key
vk.precompute()
signature = sk.sign(b"message")
assert vk.verify(signature, b"message")
```

Once `precompute()` was called, all signature verifications with this key will
be faster to execute.

## OpenSSL Compatibility

To produce signatures that can be verified by OpenSSL tools, or to verify
signatures that were produced by those tools, use:

```
# openssl ecparam -name prime256v1 -genkey -out sk.pem
# openssl ec -in sk.pem -pubout -out vk.pem
# echo "data for signing" > data
# openssl dgst -sha256 -sign sk.pem -out data.sig data
# openssl dgst -sha256 -verify vk.pem -signature data.sig data
# openssl dgst -sha256 -prverify sk.pem -signature data.sig data

import hashlib
from ecdsa import SigningKey, VerifyingKey
from ecdsa.util import sigencode_der, sigdecode_der

with open("vk.pem") as f:
   vk = VerifyingKey.from_pem(f.read())

with open("data", "rb") as f:
   data = f.read()

with open("data.sig", "rb") as f:
   signature = f.read()

assert vk.verify(signature, data, hashlib.sha256, sigdecode=sigdecode_der)

with open("sk.pem") as f:
   sk = SigningKey.from_pem(f.read(), hashlib.sha256)

new_signature = sk.sign_deterministic(data, sigencode=sigencode_der)

with open("data.sig2", "wb") as f:
   f.write(new_signature)

# openssl dgst -sha256 -verify vk.pem -signature data.sig2 data
```

Note: if compatibility with OpenSSL 1.0.0 or earlier is necessary, the
`sigencode_string` and `sigdecode_string` from `ecdsa.util` can be used for
respectively writing and reading the signatures.

The keys also can be written in format that openssl can handle:

```
from ecdsa import SigningKey, VerifyingKey

with open("sk.pem") as f:
    sk = SigningKey.from_pem(f.read())
with open("sk.pem", "wb") as f:
    f.write(sk.to_pem())

with open("vk.pem") as f:
    vk = VerifyingKey.from_pem(f.read())
with open("vk.pem", "wb") as f:
    f.write(vk.to_pem())
```

## Entropy

Creating a signing key with `SigningKey.generate()` requires some form of
entropy (as opposed to
`from_secret_exponent`/`from_string`/`from_der`/`from_pem`,
which are deterministic and do not require an entropy source). The default
source is `os.urandom()`, but you can pass any other function that behaves
like `os.urandom` as the `entropy=` argument to do something different. This
may be useful in unit tests, where you want to achieve repeatable results. The
`ecdsa.util.PRNG` utility is handy here: it takes a seed and produces a strong
pseudo-random stream from it:

```
from ecdsa.util import PRNG
from ecdsa import SigningKey
rng1 = PRNG(b"seed")
sk1 = SigningKey.generate(entropy=rng1)
rng2 = PRNG(b"seed")
sk2 = SigningKey.generate(entropy=rng2)
# sk1 and sk2 are the same key
```

Likewise, ECDSA signature generation requires a random number, and each
signature must use a different one (using the same number twice will
immediately reveal the private signing key). The `sk.sign()` method takes an
`entropy=` argument which behaves the same as `SigningKey.generate(entropy=)`.

## Deterministic Signatures

If you call `SigningKey.sign_deterministic(data)` instead of `.sign(data)`,
the code will generate a deterministic signature instead of a random one.
This uses the algorithm from RFC6979 to safely generate a unique `k` value,
derived from the private key and the message being signed. Each time you sign
the same message with the same key, you will get the same signature (using
the same `k`).

This may become the default in a future version, as it is not vulnerable to
failures of the entropy source.

## Examples

Create a NIST192p key pair and immediately save both to disk:

```
from ecdsa import SigningKey
sk = SigningKey.generate()
vk = sk.verifying_key
with open("private.pem", "wb") as f:
    f.write(sk.to_pem())
with open("public.pem", "wb") as f:
    f.write(vk.to_pem())
```

Load a signing key from disk, use it to sign a message (using SHA-1), and write
the signature to disk:

```
from ecdsa import SigningKey
with open("private.pem") as f:
    sk = SigningKey.from_pem(f.read())
with open("message", "rb") as f:
    message = f.read()
sig = sk.sign(message)
with open("signature", "wb") as f:
    f.write(sig)
```

Load the verifying key, message, and signature from disk, and verify the
signature (assume SHA-1 hash):

```
from ecdsa import VerifyingKey, BadSignatureError
vk = VerifyingKey.from_pem(open("public.pem").read())
with open("message", "rb") as f:
    message = f.read()
with open("signature", "rb") as f:
    sig = f.read()
try:
    vk.verify(sig, message)
    print "good signature"
except BadSignatureError:
    print "BAD SIGNATURE"
```

Create a NIST521p key pair:

```
from ecdsa import SigningKey, NIST521p
sk = SigningKey.generate(curve=NIST521p)
vk = sk.verifying_key
```

Create three independent signing keys from a master seed:

```
from ecdsa import NIST192p, SigningKey
from ecdsa.util import randrange_from_seed__trytryagain

def make_key_from_seed(seed, curve=NIST192p):
    secexp = randrange_from_seed__trytryagain(seed, curve.order)
    return SigningKey.from_secret_exponent(secexp, curve)

sk1 = make_key_from_seed("1:%s" % seed)
sk2 = make_key_from_seed("2:%s" % seed)
sk3 = make_key_from_seed("3:%s" % seed)
```

Load a verifying key from disk and print it using hex encoding in
uncompressed and compressed format (defined in X9.62 and SEC1 standards):

```
from ecdsa import VerifyingKey

with open("public.pem") as f:
    vk = VerifyingKey.from_pem(f.read())

print("uncompressed: {0}".format(vk.to_string("uncompressed").hex()))
print("compressed: {0}".format(vk.to_string("compressed").hex()))
```

Load a verifying key from a hex string from compressed format, output
uncompressed:

```
from ecdsa import VerifyingKey, NIST256p

comp_str = '022799c0d0ee09772fdd337d4f28dc155581951d07082fb19a38aa396b67e77759'
vk = VerifyingKey.from_string(bytearray.fromhex(comp_str), curve=NIST256p)
print(vk.to_string("uncompressed").hex())
```

ECDH key exchange with remote party:

```
from ecdsa import ECDH, NIST256p

ecdh = ECDH(curve=NIST256p)
ecdh.generate_private_key()
local_public_key = ecdh.get_public_key()
#send `local_public_key` to remote party and receive `remote_public_key` from remote party
with open("remote_public_key.pem") as e:
    remote_public_key = e.read()
ecdh.load_received_public_key_pem(remote_public_key)
secret = ecdh.generate_sharedsecret_bytes()
```

## About

pure-python ECDSA signature/verification and ECDH key agreement

### Topics

[python](/topics/python "Topic: python")
[cryptography](/topics/cryptography "Topic: cryptography")
[ecdsa](/topics/ecdsa "Topic: ecdsa")
[ecdh](/topics/ecdh "Topic: ecdh")
[elliptic-curves](/topics/elliptic-curves "Topic: elliptic-curves")
[digital-signatures](/topics/digital-signatures "Topic: digital-signatures")

### Resources

[Readme](#readme-ov-file)
### License

[View license](#License-1-ov-file)
### Security policy

[Security policy](#security-ov-file)

[Activity](/tlsfuzzer/python-ecdsa/activity)
[Custom properties](/tlsfuzzer/python-ecdsa/custom-properties)
### Stars

[**927**
stars](/tlsfuzzer/python-ecdsa/stargazers)
### Watchers

[**49**
watching](/tlsfuzzer/python-ecdsa/watchers)
### Forks

[**314**
forks](/tlsfuzzer/python-ecdsa/forks)
[Report repository](/contact/report-content?content_url=https%3A%2F%2Fgithub.com%2Ftlsfuzzer%2Fpython-ecdsa&report=tlsfuzzer+%28user%29)

## [Releases 15](/tlsfuzzer/python-ecdsa/releases)

[ecdsa 0.19.0
Latest

Apr 8, 2024](/tlsfuzzer/python-ecdsa/releases/tag/python-ecdsa-0.19.0)
[+ 14 releases](/tlsfuzzer/python-ecdsa/releases)

## [Contributors 46](/tlsfuzzer/python-ecdsa/graphs/contributors)

* [![@tomato42](https://avatars.githubusercontent.com/u/618246?s=64&v=4)](https://github.com/tomato42)
* [![@warner](https://avatars.githubusercontent.com/u/27146?s=64&v=4)](https://github.com/warner)
* [![@alex](https://avatars.githubusercontent.com/u/772?s=64&v=4)](https://github.com/alex)
* [![@shrir](https://avatars.githubusercontent.com/u/21363803?s=64&v=4)](https://github.com/shrir)
* [![@junderw](https://avatars.githubusercontent.com/u/11246316?s=64&v=4)](https://github.com/junderw)
* [![@oyamauchi](https://avatars.githubusercontent.com/u/107014?s=64&v=4)](https://github.com/oyamauchi)
* [![@Elizafox](https://avatars.githubusercontent.com/u/659425?s=64&v=4)](https://github.com/Elizafox)
* [![@blag](https://avatars.githubusercontent.com/u/597113?s=64&v=4)](https://github.com/blag)
* [![@hukkin](https://avatars.githubusercontent.com/u/3275109?s=64&v=4)](https://github.com/hukkin)
* [![@a-detiste](https://avatars.githubusercontent.com/u/7994192?s=64&v=4)](https://github.com/a-detiste)
* [![@hugovk](https://avatars.githubusercontent.com/u/1324225?s=64&v=4)](https://github.com/hugovk)
* [![@pik](https://avatars.githubusercontent.com/u/10236920?s=64&v=4)](https://github.com/pik)
* [![@adhintz](https://avatars.githubusercontent.com/u/455883?s=64&v=4)](https://github.com/adhintz)
* [![@dhimmel](https://avatars.githubusercontent.com/u/1117703?s=64&v=4)](https://github.com/dhimmel)

[+ 32 contributors](/tlsfuzzer/python-ecdsa/graphs/contributors)

## Languages

* [Python
  99.8%](/tlsfuzzer/python-ecdsa/search?l=python)
* Other
  0.2%

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_12da28a3_20250114_181315.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftlsfuzzer%2Fpython-ecdsa%2Fsecurity%2Fadvisories%2FGHSA-wj6h-64fc-37mp)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftlsfuzzer%2Fpython-ecdsa%2Fsecurity%2Fadvisories%2FGHSA-wj6h-64fc-37mp)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=tlsfuzzer%2Fpython-ecdsa)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[tlsfuzzer](/tlsfuzzer)
/
**[python-ecdsa](/tlsfuzzer/python-ecdsa)**
Public

* [Notifications](/login?return_to=%2Ftlsfuzzer%2Fpython-ecdsa) You must be signed in to change notification settings
* [Fork
  314](/login?return_to=%2Ftlsfuzzer%2Fpython-ecdsa)
* [Star
   927](/login?return_to=%2Ftlsfuzzer%2Fpython-ecdsa)

* [Code](/tlsfuzzer/python-ecdsa)
* [Issues
  15](/tlsfuzzer/python-ecdsa/issues)
* [Pull requests
  1](/tlsfuzzer/python-ecdsa/pulls)
* [Discussions](/tlsfuzzer/python-ecdsa/discussions)
* [Actions](/tlsfuzzer/python-ecdsa/actions)
* [Projects
  0](/tlsfuzzer/python-ecdsa/projects)
* [Wiki](/tlsfuzzer/python-ecdsa/wiki)
* [Security](/tlsfuzzer/python-ecdsa/security)
* [Insights](/tlsfuzzer/python-ecdsa/pulse)

Additional navigation options

* [Code](/tlsfuzzer/python-ecdsa)
* [Issues](/tlsfuzzer/python-ecdsa/issues)
* [Pull requests](/tlsfuzzer/python-ecdsa/pulls)
* [Discussions](/tlsfuzzer/python-ecdsa/discussions)
* [Actions](/tlsfuzzer/python-ecdsa/actions)
* [Projects](/tlsfuzzer/python-ecdsa/projects)
* [Wiki](/tlsfuzzer/python-ecdsa/wiki)
* [Security](/tlsfuzzer/python-ecdsa/security)
* [Insights](/tlsfuzzer/python-ecdsa/pulse)

# Minerva attack on P-256 in python-ecdsa

High

[tomato42](/tomato42)
published
GHSA-wj6h-64fc-37mp
Jan 22, 2024

## Package

pip

ecdsa
([pip](/advisories?query=ecosystem%3Apip))

## Affected versions

\*

## Patched versions

None

## Description

# Report

Hello python-ecdsa team,

My team and I have tested python-ecdsa and we found that it is vulnerable to the Minerva attack.

The test scenario is that we are signing random messages using the `ecdsa.SigningKey.sign_digest()` API function. Then using the private key, we extract the K value from the signatures. After that, based on the bit size of the extracted nonce we compare full-sized nonces to smaller ones and use the statistical tests to compare the signature times.

For testing, we used ecdsa package version 0.18.0.

[![conf_interval_plot_all_k_sizes_median_0-10](https://private-user-images.githubusercontent.com/59042612/298517270-c6af9a76-fcb2-4fd2-a201-1ed481d4619e.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MzY4Nzg2OTUsIm5iZiI6MTczNjg3ODM5NSwicGF0aCI6Ii81OTA0MjYxMi8yOTg1MTcyNzAtYzZhZjlhNzYtZmNiMi00ZmQyLWEyMDEtMWVkNDgxZDQ2MTllLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTAxMTQlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwMTE0VDE4MTMxNVomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTExMTg0MTA1OWE4Zjc0YjEwYmYxZWViZGE5ZmEwMDRjOWFhMjA4NzA0ZGE2NmJmMDUxMmE1ZjRmMjIxMDdiZGUmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.AJXul0gXgRCFnpUGxEAhpw1NkNJJqtYU7ChMA9agRf4)](https://private-user-images.githubusercontent.com/59042612/298517270-c6af9a76-fcb2-4fd2-a201-1ed481d4619e.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MzY4Nzg2OTUsIm5iZiI6MTczNjg3ODM5NSwicGF0aCI6Ii81OTA0MjYxMi8yOTg1MTcyNzAtYzZhZjlhNzYtZmNiMi00ZmQyLWEyMDEtMWVkNDgxZDQ2MTllLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTAxMTQlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwMTE0VDE4MTMxNVomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTExMTg0MTA1OWE4Zjc0YjEwYmYxZWViZGE5ZmEwMDRjOWFhMjA4NzA0ZGE2NmJmMDUxMmE1ZjRmMjIxMDdiZGUmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.AJXul0gXgRCFnpUGxEAhpw1NkNJJqtYU7ChMA9agRf4)

In these results, we can clearly see that there is a leak. There is a clear dependency between the bit size of K and the size of the side channel. Each k size takes less and less to be processed. The sample tested has 719,882 observations.

[Here](https://minerva.crocs.fi.muni.cz/) you can find more information about the Minerva attack.

For any questions, feel free to contact us.

Hubert Kario [@tomato42](https://github.com/tomato42) <hkario@redhat.com>

George Pantelakis <gpantela@redhat.com>

# Reply/Mitigation

Thanks for the report, unfortunately that's the expected result—our scalar multiplication is not constant time.

That means both ECDSA signatures, key generation, and ECDH operations are affected.

ECDSA signature verification is unaffected.

As stated in the [security policy](https://github.com/tlsfuzzer/python-ecdsa/blob/master/SECURITY.md) side-channel vulnerabilities are outside the scope of the project. Not because we don't want side-channel secure implementation, but because the main goal of the project is to be pure python and implementing side-channel free code in pure python is [impossible](https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/).

As such, we don't plan to release a fix to this vulnerability.

### Severity

High

7.4

# CVSS overall score

 This score calculates overall vulnerability severity from 0 to 10 and is based on the Common Vulnerability Scoring System (CVSS).

 / 10

#### CVSS v3 base metrics

Attack vector
Network

Attack complexity
High

Privileges required
None

User interaction
None

Scope
Unchanged

Confidentiality
High

Integrity
High

Availability
None

Learn more about base metrics

# CVSS v3 base metrics

Attack vector:
More severe the more the remote (logically and physically) an attacker can be in order to exploit the vulnerability.

Attack complexity:
More severe for the least complex attacks.

Privileges required:
More severe if no privileges are required.

User interaction:
More severe when no user interaction is required.

Scope:
More severe when a scope change occurs, e.g. one vulnerable component impacts resources in components beyond its security scope.

Confidentiality:
More severe when loss of data confidentiality is highest, measuring the level of data access available to an unauthorized user.

Integrity:
More severe when loss of data integrity is the highest, measuring the consequence of data modification possible by an unauthorized user.

Availability:
More severe when the loss of impacted component availability is highest.

CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N

### CVE ID

CVE-2024-23342

### Weaknesses

[CWE-203](/advisories?query=cwe%3A203) [CWE-208](/advisories?query=cwe%3A208) [CWE-385](/advisories?query=cwe%3A385)

### Credits

* [![@tomato42](https://avatars.githubusercontent.com/u/618246?s=40&v=4)](/tomato42)
  [tomato42](/tomato42)
  Coordinator

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from minerva.crocs.fi.muni.cz_8c51df89_20250114_181316.html ===


Minerva

Minerva
[Affected](#affected)
[Secure](#secure-impl)
[Q&A](#qa)
[PoC](#poc)
[Details](#details)
[Leakage](#details-leakage)
[Hidden Number Problem](#details-hnp)
[Attack improvements](#details-improvements)
[Root causes](#details-reasons)

[Disclosure](#disclosure)
[Team](#team)
[Updates](#timeline)
[Media](#media)
[Acknowledgements](#acknowledgements)
[References](#references)

![Minerva: Leaky loops](assets/img/Leaky_loops_mid.webp)

Minerva

[![CRoCS logo](assets/img/crocs.svg)](https://crocs.fi.muni.cz "Visit the CRoCS website")

This page describes our discovery of a group of side-channel vulnerabilities in implementations of
ECDSA
in programmable smart cards and cryptographic software libraries. Our attack allows for practical
recovery of the long-term private key. We have found implementations which leak
the bit-length of the scalar during scalar multiplication on an elliptic curve. This leakage might seem minuscule
as the bit-length presents a very small amount of information present in the scalar. However, in the case of
ECDSA signature generation, the leaked bit-length of the random
nonce is enough for full recovery of the private key used after observing a few hundreds to a few thousands of signatures
on known messages, due to the application of lattice techniques.

We have verified our attack against
an Athena IDProtect card, running on an Inside Secure AT90SC chip,
for more affected devices see the [next section](#affected). The attack required 2100
signatures to recover the private key on the standard secp256r1 curve, using an off-the-shelf
smart card reader, running on an ordinary Linux laptop with a runtime of a few minutes after the collection of
signatures. The total time for the attack, including the collection of signatures was around 30 minutes.

We propose two new methods to recover the full private key
requiring just 500 signatures for simulated leakage data, 1200 for real cryptographic
library data, and 2100 for smartcard data. Our attack and proof-of-concept code is inspired by the method of [Brumley & Tuveri [3]](#remote),
for more details, see the [section](#details) on the attack.

The paper, containing our improvements and systematic analysis of lattice attacks on ECDSA appeared at CHES 2020.
The paper also received the Best Paper Award at CHES 2020! ![](assets/img/tada.png)

 [Pre-print](assets/Minerva.pdf)

 [ePrint](https://eprint.iacr.org/2020/728)

 [TCHES 2020](https://tches.iacr.org/index.php/TCHES/article/view/8684)

 [Code & data](https://github.com/crocs-muni/minerva)

```

@article{tches2020-Minerva,
  author    = {Jan Jancar and Vladimir Sedlacek and Petr Svenda and Marek Sys},
  title     = {Minerva: The curse of {ECDSA} nonces (Systematic analysis of lattice
               attacks on noisy leakage of bit-length of {ECDSA} nonces)},
  journal   = {IACR Transactions on Cryptographic Hardware and Embedded Systems},
  volume    = {2020},
  number    = {4},
  pages     = {281--308},
  year      = {2020},
  doi       = {10.13154/tches.v2020.i4.281-308}
}

```

**Primary contact:** Jan Jancar ENABLE@JAVASCRIPT

**Update** Added a [list](#secure-impl) of libraries and cards tested and deemed not vulnerable.

**Update** This page originally claimed an attack also applicable to EdDSA, due to the leakage
also being present in the EdDSA implementation in libgcrypt. However, an attack path for
EdDSA is not clear, as the leakage does not represent the bit-length of the random nonce modulo the curve order,
but a full SHA-512 bit hash. Without the implementation reducing this modulo the curve order (which is not required by the protocol),
the leakage does not seem to be exploitable. We have thus removed EdDSA mentions from this page.

### Affected devices and libraries

We have tested our attack on an Athena IDProtect card with CPLC data `010b.0352.0005`.
We further believe the following devices and cryptographic libraries to be affected:

#### Devices

* Athena IDProtect with card CPLC data:
   [leakage plots](#leakage-athena-head "Navigate to leakage plots.") [CVE-2019-15809](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-15809)
  + `010b.0352.0005`: FIPS 140-2 certificate [1711](https://csrc.nist.gov/Projects/cryptographic-module-validation-program/Certificate/1711), CC certificate [ANSSI-CC-2012/23](https://www.ssi.gouv.fr/certification_cc/athena-os755idprotect-v6-sscd/) (tested)
  + `010e.1245.0002`: FIPS 140-2 certificate [1749](https://csrc.nist.gov/Projects/cryptographic-module-validation-program/Certificate/1749)
  + `0106.0130.0401`: FIPS 140-2 certificate [1750](https://csrc.nist.gov/Projects/cryptographic-module-validation-program/Certificate/1750)
  + `010e.1245.0002`: FIPS 140-2 certificate [1764](https://csrc.nist.gov/Projects/cryptographic-module-validation-program/Certificate/1764)

#### Likely affected devices

* Valid S/A IDflex V with card CPLC data:
  + `010b.0352.0005`: FIPS 140-2 certificate [1781](https://csrc.nist.gov/Projects/Cryptographic-Module-Validation-Program/Certificate/1781) (assumed, not tested)
* SafeNet eToken 4300 with card CPLC data:
  + `010e.1245.0002`: FIPS 140-2 certificate [1800](https://csrc.nist.gov/Projects/Cryptographic-Module-Validation-Program/Certificate/1800) (assumed, not tested)
* TecSec Armored Card with card CPLC data:
  + `010e.0264.0001`: FIPS 140-2 certificate [1986](https://csrc.nist.gov/Projects/Cryptographic-Module-Validation-Program/Certificate/1986) (assumed, not tested)
  + `0108.0264.0001`: FIPS 140-2 certificate [1992](https://csrc.nist.gov/Projects/Cryptographic-Module-Validation-Program/Certificate/1992) (assumed, not tested)

#### Libraries

* libgcrypt:
   [leakage
  plots](#leakage-gcrypt-head "Navigate to leakage plots.") [CVE-2019-13627](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13627) [source](https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=blob;f=mpi/ec.c;h=89077cd94b4647a2a432f117c28d848f114fd68d;hb=refs/tags/libgcrypt-1.8.4#l1312) [fix](https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=commit;h=b9577f7c89b4327edc09f2231bc8b31521102c79)
  + ECDSA: all versions including 1.8.4, introduced in 1.3.0, fixed in 1.8.5
  + ~~EdDSA: all versions including 1.8.4, introduced in 1.6.0, fixed in 1.8.5~~

    **Update**: The EdDSA scalar multiplication code in libgcrypt was leaking, however due to the way it was used, it was likely not exploitable.
    It did not reduce the scalar which was a SHA512 digest by the curve order, but used the digest directly, thus the leakage did not represent the bit-length of the reduced scalar.
    Thanks to Daniel J. Bernstein for the note.
* wolfSSL/wolfCrypt:
   [leakage plots](#leakage-wolfcrypt-head "Navigate to leakage plots.") [CVE-2019-13628](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13628) [source](https://github.com/wolfSSL/wolfssl/blob/21f2beca9f320199fcea4a96df3e19967804144b/wolfcrypt/src/ecc.c#L2774) [fix](https://github.com/wolfSSL/wolfssl/pull/2353)
  + ECDSA: all versions including 4.0.0, fixed in 4.1.0

    The leakage in wolfSSL/wolfCrypt is minuscule and would be very hard to exploit.
* MatrixSSL:
   [leakage plots](#leakage-matrixssl-head "Navigate to leakage plots.") [CVE-2019-13629](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13629) [source](https://github.com/matrixssl/matrixssl/blob/91fd0f130294629fe6f17078c5306af42ca6cfa5/crypto/pubkey/ecc_math.c#L209) no fix
  + ECDSA: all versions including 4.2.1
* SunEC/OpenJDK/Oracle JDK:
   [leakage
  plots](#leakage-sunec-head "Navigate to leakage plots.") [CVE-2019-2894](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-2894) [source](http://hg.openjdk.java.net/jdk/jdk13/file/31b7274c7b9e/src/jdk.crypto.ec/share/native/libsunec/impl/ec2_mont.c#l225) no fix [our patch](assets/jdk.patch)
  + ECDSA over binary field curves: all versions including JDK 12, introduced in JDK 7
* Crypto++:
   [leakage
  plots](#leakage-cryptopp-head "Navigate to leakage plots.") [CVE-2019-14318](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-14318) [fix](https://github.com/weidai11/cryptopp/commit/f68f00f5601f6e4aade302e92cb1a7f8e85c250f)
  + ECDSA over binary field curves: all versions including 8.2.0
  + ECDSA over prime field curves: all versions including 8.2.0, significantly smaller leakage.
* GnuTLS:
  [CVE-2024-28834](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-28834)
  + ECDSA on secp521r1: Found and reported by [Alicja Kario and George Pantelakis](https://gitlab.com/gnutls/gnutls/-/issues/1516) (04.12.2023).

#### Other software

* jsrsasign:  [source](https://github.com/kjur/jsrsasign) [fix](https://github.com/kjur/jsrsasign/commit/9dcb89c57408a3d4b5b66aa9138426bd92819e73) 2015 stars, 7406 uses
* elliptic:  [source](https://github.com/indutny/elliptic/) 875 stars, 2 670 640 uses
* python-ecdsa:  [source](https://github.com/warner/python-ecdsa) [CVE-2024-23342](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-23342) 497 stars
* easy-ecc:  [source](https://github.com/esxgx/easy-ecc/) 122 stars
* fastecdsa:  [source](https://github.com/AntonKueltz/fastecdsa) 100 stars
* ruby\_ecdsa:  [source](https://github.com/DavidEGrayson/ruby_ecdsa) 78 stars

We believe all of the cards above are affected because they share a common ECDSA component (FIPS
module
[214](https://csrc.nist.gov/Projects/Cryptographic-Algorithm-Validation-Program/details?source=ECDSA&number=214))
, which is described as Athena OS755 ECDSA2 Component on
Inside Secure AT90SC A1.0 (Firmware). We have tested the vulnerability only on the Athena IDProtect card with CPLC data
`010b.0352.0005` and ATR
`3bd518ff8191fe1fc38073c8211309`.

We believe that the source of the vulnerability of the aforementioned cards utilizing the Athena ECDSA component is
the Atmel Toolbox 00.03.11.05 with the Common Criteria certificate DCSSI-CC-2009/11
([security target](https://commoncriteriaportal.org/files/epfiles/dcssi-cible2009_11en.pdf),
[certification report](https://commoncriteriaportal.org/files/epfiles/dcssi-2009_11fr.pdf), [info page](https://www.ssi.gouv.fr/certification_cc/bibliotheque-cryptographique-atmel-toolbox-00-03-11-05/)).
The security target states the following under security functions (on pages 48 and 49):

```

- M10.6 the TSF shall provide digital signature confirming to EC-DSA standard.
    - Secure digital signature generate
    - Secure digital signature verify
    - Fast digital signature generate (see note*)
    - Fast digital signature verify (see note*)

- M10.7 the TSF shall provide point multiplication on an elliptical curve, conforming to EC-DSA standard.
    - Secure multiply
    - Fast multiply (see note*)

    * The Fast functions of M10.3, M10.4, M10.5, M10.7, M10.8, M10.9, do not
    offer any DPA/SPA protection and must not be used for secure data.
```

We assume that the vulnerable Athena cards used the fast and insecure functions. Our hypothesis was confirmed to us after discussions
with the vendor, see more in the [responsible disclosure](#disclosure) section.

### Tested implementations deemed secure

Most implementations we analyzed during this research did not show any leakage and are thus likely secure.
We cannot be sure of this, as our tests might not be exhaustive due to the complexity of the implementations.

The libraries usually have multiple scalar multiplication algorithms and choose from them based on build options, runtime configuration,
curve used, cryptosystem used and operation being performed. Thus, our testing might just not have caught a particular configuration that could still
be vulnerable. Below, we list libraries we tested and found not vulnerable:

#### Libraries

* OpenSSL 1.1.1d
* BouncyCastle 1.58
* BoringSSL 974f4dddf
* libtomcrypt 1.18.2
* Botan 2.11.0
* Microsoft CNG
* mbedTLS 2.16.0
* Intel IPP-Crypto
* IAIK ECCelerate 6.0.1

#### Cards

* ACS ACOSJ 40K
* Feitian A22CR
* G&D SmartCafe 6.0
* G&D SmartCafe 7.0
* Infineon CJTOP 80K INF SLJ 52GLA080AL M8.4
* Infineon SLE78 Universal JCard
* NXP JCOP31 v2.4.1
* NXP JCOP CJ2A081
* NXP JCOP v2.4.2 R2
* NXP JCOP v2.4.2 R3
* TaiSYS SIMoME VAULT

#### Devices

* YubiKey HSM 2 v2.102\*
* ellipticsecure MIRkey\*

\* Thanks to John Hughes for testing.

See the ECTester [documentation](https://github.com/crocs-muni/ECTester/blob/master/docs/LIBS.md) for more information about tested libraries.

### Questions & Answers

* **Is my device affected?**

  See the section on [affected devices](#affected),
  also if you have access to an unlocked JavaCard, you can test its
  vulnerability using our [proof-of-concept](#poc) and other testing tools.
  If you found a device or a library that is affected but is not present in the list above,
  please contact us.
* **Is my library affected?**

  See the section on [affected devices](#affected),
  if it is not there and it is supported by the
  [ECTester](https://crocs-muni.github.io/ECTester/) tool
  then it is probably not affected, as we tested it ([list
  of supported libraries](https://github.com/crocs-muni/ECTester/blob/master/docs/LIBS.md)). If it is not supported, we did not check.
  Furthermore, even if it is listed and we have tested it, it still may be vulnerable as
  cryptographic libraries often
  contain more than one scalar multiplication algorithm implementation, which can be enabled
  either by build options or
  sometimes even at runtime, where different algorithms are used for different classes of curves.
  We have usually tested the libraries
  in only one configuration and on a few curves (secp256r1, sect233r1...).
* **Are other devices running on the AT90SC chip affected?**

  The AT90SC chip was sold along with the Atmel Toolbox, a cryptographic toolbox
  utilizing the functionality of the Ad-X cryptographic coprocessor to provide some higher/level cryptographic
  functionality, such as ECDSA or RSA. This toolbox evolved, as the underlying intellectual property was
  sold from Atmel to Inside Secure (now called Verimatrix) and finally to WiseKey. The vulnerability is
  known to be present in one concrete version of the toolbox, the
  Atmel Toolbox 00.03.11.05 on the AT90SC Family of Devices, as specified in the
  Common Criteria [security target](https://commoncriteriaportal.org/files/epfiles/dcssi-cible2009_11en.pdf) of the toolbox.
  This version of the toolbox contains two versions of ECDSA functionality, secure and fast, the device
  using the toolbox is affected if it uses the fast version of the primitive, as the above-specified cards do.
  We do not know if other versions of this toolbox, and the renamed INSIDE Toolbox or
  WiseKey Toolbox contain the insecure functionality or if they are vulnerable.
* **Why did the Atmel Toolbox contain explicitly insecure functionality?**

  We have no idea. Having functions that perform signing or encryption, but are explicitly marked as insecure is possibly faster but also pointless and dangerous as can be seen from the resulting vulnerabilities.
* **Is there a proof of concept?**

  Yes, see the [next section](#poc).
* **Are there any CVEs for Minerva?**

  Yes, the following:
  + [CVE-2019-15809](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-15809):
    Vulnerability in Athena-based cards.
  + [CVE-2019-13627](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13627):
    Vulnerability in libgcrypt.
  + [CVE-2019-13628](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13628):
    Vulnerability in wolfSSL/wolfCrypt.
  + [CVE-2019-13629](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13629):
    Vulnerability in MatrixSSL.
  + [CVE-2019-2894](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-2894):
    Vulnerability in SunEC/OpenJDK/Oracle JDK.
  + [CVE-2019-14318](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-14318):
    Vulnerability in Crypto++.
* **What is required to perform the attack?**

  The attacker needs to be able to measure the duration of hundreds to thousands of signing operations
  of known messages. The less noise in the measurement is present, the less signatures the attacker needs.
  The computation of the private key is then a matter of seconds or minutes.
* **Is this exploitable locally?**

  Definitely, if the runtime of signing operations performed by an affected device or library is measurable,
  locally the amount of noise is not enough to stop the attack. We have verified this against the affected libraries,
  and the code to do so is present in the [PoC](#poc).
* **Is this exploitable remotely?**

  Maybe, [Brumley & Tuveri [3]](#remote) demonstrate the attack using the loopback interface of the same machine
  and even between two machines sharing the same network switch. We think this could be extended by collection of a larger amount
  of signatures and an increase in computation time.

  Furthermore, the [TPM-Fail [14]](#tpm-fail) paper demonstrates the attack using two machines sharing the same network switch.
  We do not consider this really remote though, as the noise introduced by such a switch can be even smaller than noise naturally present in
  a leaking but noisy implementation, such as a smartcard.
* **I own a vulnerable device, can I fix it?**

  Probably not, the vulnerability is present in the underlying firmware, which is
  inaccessible to the user/administrator of the device. However, the firmware might be updateable by the
  manufacturer. In the case of a vulnerable library, updating it to the newest version should fix it, as most libraries we notified
  fixed the issue and released a new version.
* **How did this happen? The devices are certified.**

  The FIPS 140-2 certification scheme specifically does not require side-channel resistance to be tested by
  the lab performing the assessment (see [[12]](#fips) page 12 on *Mitigation of other attacks*). So even though the FIPS security targets of the aforementioned cards specify
  resistance against side-channel attacks, no such testing had to be performed. The case of Common Criteria certificate
  [ANSSI-CC-2012/23](https://www.ssi.gouv.fr/certification_cc/athena-os755idprotect-v6-sscd/) can be answered
  easily as well, the ECDSA functionality of the card is explicitly mentioned to be out of the security requirements.
  The original Common Criteria certificate DCSSI-CC-2009/11 that introduced the vulnerable functionality did so by
  stating the functionality is explicitly not protected against SPA/DPA attacks and should not be used on secure data.

  As for the libraries, preventing leakage of the bit-length is surprisingly hard as we analyzed in the section on [root causes](#details-reasons).
* **Why is it called Minerva?**

  We discovered this vulnerability on cards from the Athena SCS manufacturer,
  which was named after the greek goddess
  [Athena](https://en.wikipedia.org/wiki/Athena "Wikipedia:Athena").
  [Minerva](https://en.wikipedia.org/wiki/Minerva "Wikipedia:Minerva")
  is the Roman equivalent.
* **Why the logo?**

  Why not? An owl was one of the main symbols of the Roman goddess Minerva. You can download it
  [here](assets/img/logo.svg) in svg (or [here](assets/img/logo.png) in png), it is [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/) licensed.

### Proof of Concept

The tools and data can be downloaded from this page and also our  [github](https://github.com/crocs-muni/minerva).

| Content | zip | signature | tar.gz | signature |
| --- | --- | --- | --- | --- |
| Proof-of-Concept | [poc.zip](assets/poc.zip "poc.zip") | [sig](assets/poc.zip.asc "poc.zip.asc") | [poc.tar.gz](assets/poc.tar.gz "poc.tar.gz") | [sig](assets/poc.tar.gz.asc "poc.tar.gz.asc") |
| CPLC checker | [cplc.zip](assets/cplc.zip "cplc.zip") | [sig](assets/cplc.zip.asc "cplc.zip.asc") | [cplc.tar.gz](assets/cplc.tar.gz "cplc.tar.gz") | [sig](assets/cplc.tar.gz.asc "cplc.tar.gz.asc") |
| ECDH tester | [tester.zip](assets/tester.zip "tester.zip") | [sig](assets/tester.zip.asc "tester.zip.asc") | [tester.tar.gz](assets/tester.tar.gz "tester.tar.gz") | [sig](assets/tester.tar.gz.asc "tester.tar.gz.asc") |
| Datasets | [data.zip](assets/data.zip "data.zip") | [sig](assets/data.zip.asc "data.zip.asc") | [data.tar.gz](assets/data.tar.gz "data.tar.gz") | [sig](assets/data.tar.gz.asc "data.tar.gz.asc") |
| All of the above | [all.zip](assets/all.zip) | [sig](assets/all.zip.asc) | [all.tar.gz](assets/all.tar.gz) | [sig](assets/all.tar.gz.asc) |

The above archives were signed by the [PGP key](https://neuromancer.sk/static/johny.asc) of Jan Jancar, one of the discoverers.
#### Proof-of-Concept

The Minerva proof-of-concept contains code that exploits the vulnerability against a JavaCard with a target applet,
or against targets using several vulnerable libraries.

##### Contents

`applet/` contains code of the two target JavaCard applets, the `CollectApplet` and the `POCApplet`.
The applets are very similar, the only difference is that the `POCApplet` will never export its private key, so it can
be used for full verification of the attack (if the private key is recovered and the device never exported it). It generates an ECC keypair on the
`secp256r1` curve in the `PREPARE` command and exports the public key in the response as well as the data
that will be signed. Then, in the `SIGN` command it signs the data using ECDSA with SHA256 and responds
with the signature. See `build.xml` for the ant build script.

`attack/` contains two attack scripts. An online one against a JavaCard target in `poc.py` and
an offline one in `attack.py`. Both are written in Python 3 and use the
`pyscard` library for communication and `fpylll` library for lattice reduction
and CVP solving required for the attack. Both take parameters in the form of a JSON
file, which specified what kind of attack is to be performed, see the description in `attack.py`.
The offline attack takes as input a csv file produced by one of the targets or the collection
script in `collect/` for the target JavaCard applet. The `params.json` file can
be used as a template to change some parameters internal to the attack or the PoC.

`build/` is a directory created by the ant build which contains the CAP file with the
built JavaCard applet.

`collect/` contains a Python script which collects signatures from the target JavaCard applet
and outputs it in a format ready for the offline attack script `attack/attack.py`.

`ext/` contains some third party content, such as the ant-javacard extension
(`ant-javacard.jar`) for the ant build system, which is used to build the
applet as well as a version of the JavaCard SDK 2.2.2 (`jckit_222`).

`target/` contains target apps which perform ECDSA signatures using the vulnerable libraries
and export the signatures with timing information in format ready for the offline attack script
`attack/attack.py`. See the Makefile for information on building.

##### Usage with JavaCard (PoC)

1. Build the applet via `ant build`.
2. Install the applet (`build/poc_applet.cap`) on the card. For example
   using [GlobalPlatformPro](https://github.com/martinpaljak/GlobalPlatformPro), so
   doing `gp --install build/poc_applet.cap`.
3. Install Python packages from `requirements.txt` (into a virtualenv).
   Starting with `pip install Cython` first, as it is a build dependency of
   `fpylll`. `fpylll` has a somewhat more involved install process, see
   <https://github.com/fplll/fpylll>,
   you will need the current master version of `fpylll`.
4. Run `./attack/poc.py`. If a USB reader is used, not using other
   USB devices during the attack makes it more reliable. Also, not using the machine
   for other computations during the attack limits the noise and makes it more reliable.
5. Observe a new keypair being generated (the public key is exported from
   the card and printed) and the attack starting. Observe the reconstructed
   private key after around 10k-25k signatures. If the attack did not succeed
   after this time, it is likely that that particular run of the attack will
   not succeed at all, likely due to noise during the timing measurement.

##### Usage with JavaCard (Collect)

1. Build the applet via `ant build`.
2. Install the applet (`build/collect_applet.cap`) on the card. For example
   using [GlobalPlatformPro](https://github.com/martinpaljak/GlobalPlatformPro), so
   doing `gp --install build/collect_applet.cap`.
3. Install Python packages from `requirements.txt` (into a virtualenv).
   Starting with `pip install Cython` first, as it is a build dependency of
   `fpylll`. `fpylll` has a somewhat more involved install process, see
   <https://github.com/fplll/fpylll>,
   you will need the current master version of `fpylll`.
4. Run `./attack/collect.py`. If a USB reader is used, not using other
   USB devices during the attack makes it more reliable. Also, not using the machine
   for other computations during the attack limits the noise and makes it more reliable.
5. Observe a new keypair being generated and signatures being performed
   (the public key is exported from the card and printed, the private key is also exported in this mode).
   Save the output of the `collect.py` script somewhere, it is in csv.
6. Run `./attack/attack.py` passing the arguments `secp256r1 sha256` and a path to the collected file.
   Observe the reconstructed private key.

##### Usage with libraries

1. Build the particular target app using the Makefile in the `target/` directory.
2. Run the target, possibly with [frequency scaling](https://wiki.archlinux.org/index.php/CPU_frequency_scaling "CPU frequency scaling") off,
   passing the arguments: the chosen curve, hash algorithm and amount of signatures requested. Save the
   output to a file.
3. Install Python packages from `requirements.txt` (into a virtualenv).
   Starting with `pip install Cython` first, as it is a build dependency of
   `fpylll`. `fpylll` has a somewhat more involved install process, see
   <https://github.com/fplll/fpylll>,
   you will need the current master version of `fpylll`.
4. Run `./attack/attack.py`, again passing the arguments: chosen curve, hash algorithm and filename
   containing the signatures from the target. Observe the reconstructed private key.

##### Usage with simulated data

1. Run `./attack/simulate.py <curve> <hash> <count>` with optional parameters specifying the
   leakage properties of the simulated target (`base`, `iter-time` and `sdev`) as modelled in the paper.
2. Run `./attack/attack.py`, again passing the arguments: chosen curve, hash algorithm and filename containing the signatures from the target.
   Observe the reconstructed private key.

#### CPLC checker

The Minerva CPLC checker uses the Card Production Life Cycle (CPLC) data present on
cards under the GlobalPlatform standard to identify vulnerable cards based on a list of
known or suspected vulnerable devices.

To run this tool, install the Python requirements from the `requirements.txt` file,
then simply insert the tested card into your reader and run the `./check.py` script.

#### ECDH tester

The Minerva tester is a testing tool for JavaCards which uses ECDH to assess the presence
of timing leakage of bit-length in scalar-multiplication. Since it has to use ECDH to control
the scalar (the ECDSA API in JavaCard does not allow to choose the random nonce = the scalar) the presence
of leakage in ECDH cannot be used to prove the presence of leakage in ECDSA, as the two might
be implemented differently and have different side-channel protections. We have observed both
cards which leaked in ECDH but not in ECDSA and those that leaked in ECDH and ECDSA.

##### Contents

`applet/` contains code of a target applet. The applet creates an ECC keypair and sets the `secp256r1`
curve parameters. In the `PREPARE` command, the applet prepares a private key for ECDH, with bit-length
set in the command, the private key simply has the form `1 << (bit_length - 1)`. In the `KEX` command
the applet performs ECDH with the prepared private key. See `build.xml` for the ant build script.

`build/` is a directory created by the ant build which contains the CAP file with the
built JavaCard applet.

`reader/` contains code of the tester. It is written in Python 3 and uses the
`pyscard` library for communication.

`ext/` contains some third party content, such as the ant-javacard extension
(`ant-javacard.jar`) for the ant build system, which is used to build the
applet as well as a version of the JavaCard SDK 2.2.2 (`jckit_222`).

##### Usage

1. Build the applet via `ant build`.
2. Install the applet (`build/applet.cap`) on the card. For example
   using [GlobalPlatformPro](https://github.com/martinpaljak/GlobalPlatformPro), so
   doing `gp --install build/applet.cap`.
3. Install Python packages from `requirements.txt` (into a virtualenv).
4. Run `./reader/test.py`.
5. Observe ECDH being performed, with private keys of varying bit-length, after
   all of the measurements are done a plot will display, showing the dependency
   of ECDH duration on bit-length (if any), and the correlation of the two. This
   dependency cannot be directly connected to ECDSA, since a different algorithm
   might be used for scalar multiplication there (as we observed with one card), but
   can be taken as guidance that if ECDH leaks, ECDSA might as well (as is the case with
   another card).

#### Datasets

The datasets collected and used in the paper are available. They contain timing data collected from leaking implementations.
The files `data_*.csv` contain data in a CSV-like format (only the first line is not CSV):

```

<public key> <data> <private key>
<r1>,<s1>,<time1>
<r2>,<s2>,<time2>
...
<r>,<s>,<time>

```

Time is in nanoseconds. All of the datasets contain at least 50 000 signatures.

The `time_*.csv` files contain the processed data in a CSV format:

```

<time>,<lzb>

```

In it, each line represents a signature which has `lzb` leading-zero bits and took `time` nanoseconds.

### Technical details

Our attack is a lattice attack on the timing leakage of the bit-length of nonces used in ECDSA and other
similar signature algorithms, as presented in [[3]](#remote), with minor adaptations. The vulnerable devices and libraries trivially leak the bit-length of the
scalar used in scalar multiplication in ECDH, ECDSA and key generation (see the [next subsection](#details-leakage)).
The leakage is insignificant for ECDH and key generation as only the bit-length of the private key
is leaked, which represents a small amount of always the same information about the private key.

However, in the case of ECDSA or other signature schemes with random nonces, the bit-length of the random nonces is leaked. This is
much more significant as each signature then presents new usable information on the private key. The way this information
is used to recover the private key is via first converting the problem to an instance of the Hidden Number Problem, which we describe in [a section](#details-hnp) and
solving it via lattice reduction techniques.

#### Leakage

The following images were generated using our tool [ECTester](https://crocs-muni.github.io/ECTester/).

The images contain heatmaps demonstrating the dependency of signing duration and nonce bit-length, or in general, the dependency of
the duration of scalar multiplication on certain bits of the scalar. The example group of images shown first shows a well-behaving implementation
with no leakage.

For three out of five affected libraries (libgcrypt, MatrixSSL, SunEC) and
the affected smartcard (Athena IDProtect), the signing runtime directly depends on the bit-length
of the nonce linearly: each additional bit represents one more iteration of a loop in
scalar multiplication, which increases the runtime. The leakage can be clearly seen from
powertraces of the card performing ECDSA signing in Figure [a6](#athena-fig6).

For implementations leaking just the noisy bit-length (libgcrypt, SunEC, Athena IDProtect) the
leakage can be modeled using three parameters: duration of constant time processing in
signing (e.g., hashing) (\(base\)), duration of one iteration of the scalar multiplication loop
(\(iter\\_time\)) and the standard deviation of the noise (\(sdev\)). For the secp256r1 curve, the
leakage \(\mathbf{L}\) can be modelled as a random variable:

\[
\begin{aligned}
\mathbf{L} &= base + iter\\_time \cdot \mathbf{B} + \mathbf{N} \\
\mathbf{B} &\sim \textbf{Geom}(p=1/2, (256, 255, \ldots, 0)) \\
\mathbf{N} &\sim \textbf{Norm}(0, sdev^2)
\end{aligned}
\]

where \(\mathbf{B}\) represents the bit-length with a truncated geometric distribution and \(\mathbf{N}\) the noise.
Only two of the above parameters, \(iter\\_time\) and \(sdev\), affect how much the implementation leaks;
we will use them to assess how easy it is to mount an attack.

##### Example (no leakage)

Data collected from 500k signatures on secp256r1.

These images come from OpenSSL, contain no leakage and show how a well-behaving implementation
looks like in these types of heatmaps.

[![Heatmap of nonce MSB and signature time.](assets/img/example/example_msb.png)](assets/img/example/example_msb.png)
[Figure e1:](#example-fig1 "Permanent link") Heatmap of nonce MSB and signature time.
[![Heatmap of nonce Hamming weight and signature time.](assets/img/example/example_hw.png)](assets/img/example/example_hw.png)
[Figure e2:](#example-fig2 "Permanent link") Heatmap of nonce Hamming weight and signature time.
[![Heatmap of nonce bit-length and signature time.](assets/img/example/example_bitlength.png)](assets/img/example/example_bitlength.png)
[Figure e3:](#example-fig3 "Permanent link") Heatmap of nonce bit-length and signature time.

##### Athena IDProtect

Figures below are from data collected from 500k signatures on secp256r1.

[![Plot of private key bit-length and scalar multiplication time.](assets/img/athena/linear_time.png)](assets/img/athena/linear_time.png)
[Figure a1:](#athena-fig1 "Permanent link") Clear linear dependency of the length of scalar multiplication on private key bit-length.
[![Heatmap of nonce MSB and signature time.](assets/img/athena/msb_hist.png)](assets/img/athena/msb_hist.png)
[Figure a2:](#athena-fig2 "Permanent link") Time dependency on bit-length visible in nonce MSB heatmap.
[![Heatmap of nonce Hamming weight and signature time.](assets/img/athena/hw_hist.png)](assets/img/athena/hw_hist.png)
[Figure a3:](#athena-fig3 "Permanent link") Time dependency on bit-length somewhat visible in nonce Hamming weight heatmap.
[![Heatmap of nonce bit-length and signature time.](assets/img/athena/bit_length_hist.png)](assets/img/athena/bit_length_hist.png)
[Figure a4:](#athena-fig4 "Permanent link") Clear time dependency on nonce bit-length, disturbed by the geometric distribution of bit-length.
[![Histograms of nonce bit-length and signature time.](assets/img/athena/length_hists.png)](assets/img/athena/length_hists.png)
[Figure a5:](#athena-fig5 "Permanent link") Time dependency clearly visible in grouping of signatures by bit-length.
[![Powertrace of an ECDSA signing operation.](assets/img/athena/athena_powertrace_leak.png)](assets/img/athena/athena_powertrace_leak.png)
[Figure a6:](#athena-fig6 "Permanent link") Clear dynamic bound on the number of loops in scalar multiplication is visible in a powertrace of an ECDSA signing operation.

##### libgcrypt

Figures below are from data collected from 200k signatures on secp256r1 using libgcrypt 1.8.4.

[![Heatmap of nonce MSB and signature time.](assets/img/gcrypt/msb_hist.png)](assets/img/gcrypt/msb_hist.png)
[Figure g1:](#gcrypt-fig1 "Permanent link") Time dependency on bit-length visible in nonce MSB heatmap.
[![Heatmap of nonce Hamming weight and signature time.](assets/img/gcrypt/hw_hist.png)](assets/img/gcrypt/hw_hist.png)
[Figure g2:](#gcrypt-fig2 "Permanent link") Time dependency on bit-length somewhat visible in nonce Hamming weight heatmap.
[![Heatmap of nonce bit-length and signature time.](assets/img/gcrypt/bit_length_hist.png)](assets/img/gcrypt/bit_length_hist.png)
[Figure g3:](#gcrypt-fig3 "Permanent link") Clear time dependency on nonce bit-length, disturbed by the geometric distribution of bit-length.

##### wolfSSL

The leakage in wolfCrypt was very small, and potentially not exploitable. Figures
below are from data collected from 500k signatures on secp256r1 using wolfSSL 4.0.0.

[![Heatmap of nonce MSB and signature time.](assets/img/wolfcrypt/msb_hist.png)](assets/img/wolfcrypt/msb_hist.png)
[Figure w1:](#wolfcrypt-fig1 "Permanent link") Time dependency on bit-length visible in nonce MSB heatmap.
[![Heatmap of nonce Hamming weight and signature time.](assets/img/wolfcrypt/hw_hist.png)](assets/img/wolfcrypt/hw_hist.png)
[Figure w2:](#wolfcrypt-fig2 "Permanent link") Time dependency on bit-length not visible, because it is very small.
[![Heatmap of nonce bit-length and signature time.](assets/img/wolfcrypt/bit_length_hist.png)](assets/img/wolfcrypt/bit_length_hist.png)
[Figure w3:](#wolfcrypt-fig3 "Permanent link") Time dependency on bit-length not visible, because it is very small.

##### MatrixSSL

Figures below are from data collected from 120k signatures on secp256r1 using MatrixSSL 4.2.1.

[![Heatmap of nonce MSB and signature time.](assets/img/matrixssl/msb_hist.png)](assets/img/matrixssl/msb_hist.png)
[Figure m1:](#matrixssl-fig1 "Permanent link") Time dependency on bit-length visible in nonce MSB heatmap.
[![Heatmap of nonce Hamming weight and signature time.](assets/img/matrixssl/hw_hist.png)](assets/img/matrixssl/hw_hist.png)
[Figure m2:](#matrixssl-fig2 "Permanent link") Time dependency on bit-length somewhat visible in nonce Hamming weight heatmap. Time dependency on Hamming weight is also visible.
[![Heatmap of nonce bit-length and signature time.](assets/img/matrixssl/bit_length_hist.png)](assets/img/matrixssl/bit_length_hist.png)
[Figure m3:](#matrixssl-fig3 "Permanent link") Clear time dependency on nonce bit-length, disturbed by the geometric distribution of bit-length.

##### SunEC

Figures below are from data collected from 500k signatures on sect233r1 using JDK 8 SunEC provider.

[![Heatmap of nonce MSB and signature time.](assets/img/sunec/msb_hist.png)](assets/img/sunec/msb_hist.png)
[Figure s1:](#sunec-fig1 "Permanent link") Time dependency on bit-length visible in nonce MSB heatmap.
[![Heatmap of nonce Hamming weight and signature time.](assets/img/sunec/hw_hist.png)](assets/img/sunec/hw_hist.png)
[Figure s2:](#sunec-fig2 "Permanent link") Time dependency on bit-length somewhat visible in nonce Hamming weight heatmap.
[![Heatmap of nonce bit-length and signature time.](assets/img/sunec/bit_length_hist.png)](assets/img/sunec/bit_length_hist.png)
[Figure s3:](#sunec-fig3 "Permanent link") Clear time dependency on nonce bit-length, disturbed by the geometric distribution of bit-length.

##### Crypto++

Figures below are from data collected from 100k signatures on sect233r1 using Crypto++ 8.2.0.

[![Heatmap of nonce MSB and signature time.](assets/img/cryptopp/msb_hist.png)](assets/img/cryptopp/msb_hist.png)
[Figure c1:](#cryptopp-fig1 "Permanent link") Time dependency on bit-length visible in nonce MSB heatmap.
[![Heatmap of nonce Hamming weight and signature time.](assets/img/cryptopp/hw_hist.png)](assets/img/cryptopp/hw_hist.png)
[Figure c2:](#cryptopp-fig2 "Permanent link") Time dependency on bit-length somewhat visible in nonce Hamming weight heatmap.
[![Heatmap of nonce bit-length and signature time.](assets/img/cryptopp/bit_length_hist.png)](assets/img/cryptopp/bit_length_hist.png)
[Figure c3:](#cryptopp-fig3 "Permanent link") Clear time dependency on nonce bit-length, disturbed by the geometric distribution of bit-length.

#### Hidden Number Problem

[Boneh & Venkatesan [1]](#hardness) introduced the *Hidden Number Problem* (HNP),
for proving the hardness of computing the most significant bits of keys in the Diffie-Hellman
scheme. They also showed a way to solve it by transforming it into a lattice *Closest Vector Problem* (CVP) solvable via lattice reduction and Babai's nearest plane algorithm. This is useful to us, because in the cases
of DSA/ECDSA/EdDSA and even attestation systems such as
EPID [[8]](#cachequote) or ECDAA [[9]](#fido-ecdaa), knowledge of the most significant bits of nonces with the goal of computing the private key can be turned into a Hidden Number Problem
instance, which can be turned into an instance of the Closest Vector Problem and solved using the methods of
lattice reduction. Next we will introduce the HNP and show how knowledge of most significant bits of nonces can be
turned into one for ECDSA.

**Notation:** In the following text:

* \( \lfloor x \rfloor\_n \) denotes the reduction to \( x \gmod{n} \).
* \( \lvert x \rvert\_n = \min\_{aÂ \in \mathbb{Z}} \lvert x - an \rvert\) denotes the distance to the nearest integer multiple of \( n \).
* \( pÂ \) denotes a prime number, \( g \) is a generator of \( \mathbb{Z}\_n \).
* \( G \) denotes a point of order \( n \) on an elliptic curve, usually the generator.
* \( d \) denotes the private key, and \( eÂ \)the amount of signatures.
* \( H(m) \) denotes the leftmost \( \log\_2(n)Â \) bits of the hash of the message \( m \), interpreted as an integer \( \gmod{n} \).
* \( k \) denotes the nonce used in signing.

**Definition 1 (Approximations):** By \(\mathrm{APP}\_{l,n}(y)\), we will denote any \(u\in\mathbb{Q}\) satisfying
\[\lvert y - u\rvert\_n \leq n/2^{l}.\]
Note that generally there are many such \(u\).

**Definition 2 (Most Significant Modular Bits):** The \(l>0\) most significant modular bits of an element \(y\in\mathbb{Z}\_n\) (regarded as an integer in \([0, n-1]\)) are the unique integer \(\mathrm{MSMB}\_{l,n}(y)\) such that
\[0 \leq y - \mathrm{MSMB}\_{l,n}(y)\cdot n/2^l < n/2^l.\]

It is worth observing that the most significant modular bits give rise to a specific approximation of \(y\). We can see directly from [definition 2](#def-msmb) that

\[\lvert y - \mathrm{MSMB}\_{l,n}(y)\cdot n/2^l \rvert < n/2^{l},\]
and since the absolute value argument already lies in \([-n/2, n/2]\), it is equivalent to
\[\lvert y - \mathrm{MSMB}\_{l,n}(y)\cdot n/2^l \rvert\_n < n/2^{l}.\]
Thus \(\mathrm{MSMB}\_{l,n}(y)\cdot n/2^l\) may be taken as \(\mathrm{APP}\_{l,n}(y)\). Also, after recentering the bits, \(\mathrm{MSMB}\_{l,n}(y) \cdot n/2^l - n/2^{l + 1}\) may be taken as \(\mathrm{APP}\_{l+1,n}(y)\).
**Definition 3 (Hidden Number Problem):** Given \( e \) approximations \(a\_i = \mathrm{APP}\_{l\_i,n}(k\_i)\), where \(k\_i = \lfloor \alpha t\_i - u\_i \rfloor\_n\),
for many known \(t\_i\) that are uniformly and independently distributed in \(\mathbb{Z}\_n^\*\), known \(u\_i\) and a fixed secret \(\alpha\in \mathbb{Z}\_n\), find \(\alpha\).

This general problem can be equivalently stated as, given \( e \) inequalities as below, with known \( a\_i \) and \( l\_i \) and with unknown \( \alpha \), find it:
\[
\lvert k\_i - a\_i\rvert\_n < n/2^{l\_i}
\]
##### ECDSA

In case of ECDSA, given the signature \( (r, s) \in \mathbb{Z}\_n \times \mathbb{Z}\_n \) on message
\( m \):
\[
\begin{aligned}
r &= ([k]G)\_x \pmod{n} \\
s &= k^{-1} (H(m) + r d) \pmod{n}
\end{aligned}
\]
Rewriting we have:
\[
\begin{aligned}
k &= s^{-1} (H(m) + r d) \pmod{n} \\
k &= s^{-1} H(m) + s^{-1} r d \pmod{n}
\end{aligned}
\]
Information about the most significant bits of \( k \), the nonce, can be used to construct an instance of the HNP.
**Definition 4 (ECDSA Hidden Number Problem):** Given \( e \) approximations \(a\_i = \mathrm{APP}\_{l\_i,n}(k\_i)\) of the nonces \( k\_i \) of known messages \( m\_i \),
find \( d \) (private key).

This gives us \( e \) inequalitites of the form:
\[
\begin{aligned}
\lfloor k\_i - a\_i \rfloor\_n &< n/2^{l\_i} \\
%\lvert \lfloor k\_i \rfloor\_n - n/2^{l\_i + 1} - a\_i \rvert &< n/2^{l\_i + 1} \\
%\lvert \lfloor k\_i \rfloor\_n - n/2^{l\_i + 1} - a\_i \rvert\_n &< n/2^{l\_i + 1}
\lvert s\_i^{-1} \left(d r\_i + H(m\_i)\right) - a\_i \rvert\_n &< n/2^{l\_i}\\
\lvert d\lfloor s\_i^{-1}r\_i \rfloor\_n + \lfloor s\_i^{-1} H(m\_i)\rfloor\_n - a\_i\rvert\_n &< n/2^{l\_i}
\end{aligned}
\]
The above gives the HNP inequality with \(t\_i = s\_i^{-1} r\_i\) and \(u\_i = - s\_i^{-1} H(m\_i)\) as per [definition 3](#def-hnp). However, in this
case \(t\) is not completely uniform in \( \mathbb{Z}\_n^{\star} \), its distribution is just close enough that we do not have
to care about it [[2]](#insecurity). In our case of bit-length leakage, we will only ever create HNP inequalities with \( a\_i = MSMB\_{l\_i,n}(k\_i) = 0 \),
which simplifies the above equation to:
\[
\lvert t\_i d - u\_i \rvert\_n \lt n/2^{l\_i}
\]
##### Solving

Given \( e \) HNP inequalities of the form \( \lvert t\_i d - u\_i \rvert\_n \lt n/2^{l\_i} \), we can construct a lattice given by the rows of the matrix \( \mathbf{M} \)
[[7]](#rohnp):
\[
\mathbf{M} = \begin{pmatrix}
2^{l\_1 + 1}n & 0 & 0 & \ldots & 0 & 0 \\
0 & 2^{l\_2 +1}n & 0 & \ldots & 0 & 0 \\
& \vdots & & & \vdots & \\
0 & 0 & 0 & \ldots & 2^{l\_e +1}n & 0 \\
2^{l\_1 + 1}t\_1 & 2^{l\_2 +1}t\_2 & 2^{l\_3 +1}t\_3 & \ldots & 2^{l\_e +1}t\_e & 1
\end{pmatrix}
\]
Where \( l\_i \) is the amount of known most significant bits of \( k\_i \) from the i-th signature.
Then, by our construction from the HNP inequalities above, the vector \(\mathbf{u} = ( 2^{l\_1 + 1}u\_1, \ldots, 2^{l\_e + 1}u\_e, 0) \) is a vector unusually close to a
lattice point. The closest lattice point often has a form \( \mathbf{v} = ( 2^{l\_1 + 1} t\_1 d, \ldots, 2^{l\_e + 1} t\_e d, d )
\), finding this lattice point then reveals the private key \( d \). To do so, one needs to solve the Closest Vector Problem.
There are several algorithms for solving the CVP, the original paper used Babai's nearest plane algorithm with LLL for lattice reduction.
One could also use BKZ for lattice reduction and then solve CVP by enumeration. There is also a technique of transforming an instance of CVP to a Shortest Vector Problem (SVP) by embedding the matrix and the target vector:
\[
C = \begin{pmatrix}
\mathbf{M} & 0 \\
\mathbf{u} & n
\end{pmatrix}
\]

Then, one can solve SVP by lattice reduction and either looking directly at basis vectors or by further enumeration to find the shortest vector.
Our construction contained a number of heuristic arguments, such as "often has a form", or "is unusually close to a lattice point", this shows that
the technique is not exact. We also never stated how many HNP inequalities with what \(l\_i\) need to be included in the lattice to find the correct private key.

Generally, each inequality adds \( l\_i \) bits of information and the problem starts to be solvable (theoretically) as soon as the lattice contains more information
than the unknown information in the private key. The number of leading zero bits, which is equal to the used information in a signature in our attack, follows a truncated geometric
distribution with \(p = \frac{1}{2}\). Due to this, the expected amount of information in \(N\) signatures can be computed as
\(N \cdot \sum\_{i=2}^{\lceil \log\_2(n) \rceil} 2^{-l\_i-1} \cdot l\_i \approx \frac{3}{4}N\) assuming only signatures with \( l\_i \geq 2 \) are used.
Adding inequalities with \(l\_i < 2\) generally does not help, as those will not lead to the desired vector being unusually close to a lattice point.

Using the above formula, we obtain the expected minimum of around \(N = 342\) signatures for a 256-bit private key.
Since the amount of information is linear in \(N\) it can be computed as \(N \approx \frac{4}{3} \cdot |K|\) for size \(|K|\) of the private key.
Adding dimensions is also not for free, as the runtime of lattice algorithms grows significantly with an increase in the number of dimensions.
However, adding some overhead of information, such that the lattice contains around \( 1.3 \) times the information of the private key, was shown to improve the success rate [[7]](#rohnp).

#### Attack improvements

The nonces \(k\_i\) are generated uniformly at random; we can thus expect that the number of most significant zero bits follows
a truncated geometric distribution when \(n\) is close to a power of two. Thus roughly for one-half of the nonces \(l\_i=0\),
for one-quarter of nonces \(l\_i=1\), and so on. Assuming a one-to-one linear dependency between the bit-length of \(k\_i\) and
the duration of signing, we would obtain a clear method of assigning bounds to the signatures, sort them by duration and
apply the above distribution. However, the real timing leakage is noisy and the distributions of duration for signatures
with different bit-lengths overlap (see Figures [a4](#athena-fig4),[g3](#gcrypt-fig3),[m3](#matrixssl-fig3) and [s3](#sunec-fig3)).

Our main improvement to the attack calculates bounds according to the above truncated geometric distribution based on \(N\),
the number of signatures collected. One half of signatures has \(l\_i=0\), one quarter has \(l\_i=1\), etc.
Then simply the fastest \(e\) signatures are taken with their calculated bounds.

[![Residuals](assets/img/geomN_residuals.png)](assets/img/geomN_residuals.png)
[Figure x1:](#geom-residuals-fig "Permanent link")
Plot of the geometric bounds (**geom**) with \(N = 2000\) and \(e = 100\), along with a
random sample of the true leading zero bits from simulated data (**sim**) and
boxplots of the distribution of the difference of the simulated data and the
bounds (**sim - geom**). Negative values imply an error; positive implies some
available information is unused.
##### Evaluation

We evaluated our improvements using four separate data sets (denoted as sim, sw, card,
tpm) with varying levels of noise. All the datasets used consist of at least 50 000 ECDSA
signatures over the secp256r1 curve from which we randomly sample \(N\) signatures for the
evaluation of our attacks.

| Dataset | \(base (\mu s)\) | \(iter\\_time (\mu s)\) | \(sdev (\mu s)\) |
| --- | --- | --- | --- |
| sim | 0 | 1 | 0 |
| sw | 453.4 | 12.7 | 17.2 |
| tpm | 27047.3 | 236.1 | 211.3 |
| card | 43578.4 | 371.5 | 451.3 |

* The sim dataset contains simulated data for which there is an exact one-to-one
  correspondence between the signing duration and the bit-length of the random nonce
  with no systematic noise. However, these simulated signatures were still generated
  by uniformly randomly selecting the random nonce and computing the number of
  most-signifcant zero bits. A given sample is thus a result of a random process and
  varies naturally.
* The sw dataset contains data from a vulnerable version of the software cryptographic
  library libgcrypt collected from a simple C program on an ordinary Linux laptop.
* The tpm dataset contains data from the recent work of Moghimi et al. [[14]](#tpm-fail)
  collected from a vulnerable STMicroelectronics TPM (Trusted Platform Module).
  The data was collected via a custom Linux kernel module and contained a relatively
  small amount of noise.
* The card dataset contains data from the vulnerable Athena IDProtect smartcard,
  collected by a Python script running on an ordinary Linux laptop with a standard
  standalone smartcard reader connected. Such measurements are particularly noisy
  due to the complex software stack and hardware components between the script and
  a card.

##### Heatmaps of success rate

[![Heatmap of success rate (out of 5 tries) for constant bounds with c = 3](assets/img/const3.png)](assets/img/const3.png)
[Figure x2:](#heatmap-const-fig "Permanent link") Heatmap of success rate (out of 5 tries) for constant bounds with \(\forall i: l\_i = 3\).
[![Heatmap of success rate (out of 5 tries) for our geometric bounds.](assets/img/geomN.png)](assets/img/geomN.png)
[Figure x3:](#heatmap-geom-fig "Permanent link") Heatmap of success rate (out of 5 tries) for our geometric bounds.

#### Root causes of the vulnerability

We consider there to be several root causes for this group of vulnerabilities. One of them is that knowledge of the
fragility of DSA nonces to lattice attacks does not seem to be widespread amongst developers of
cryptographic software. There are four issues regarding nonce use in DSA:
nonce reuse, bias in nonce randomness, nonce bit-length leaks and other leaks of partial information about nonces. Due
to the aforementioned lattice attacks and their variants, all of these issues might lead to a private key recovery attack.

Deterministic generation of nonces, as done in EdDSA or RFC6979 mitigates
the issues of nonce reuse and nonce bias. However, it does not address the latter two in any significant way.
Deterministic generation of nonces might actually help the attacker in case the attacker has a noisy side-channel
leaking nonce bit-length or other information about the nonce. If the attacker can observe the signing of the same
message multiple times, they might use the fact that the same nonce was used to significantly reduce the noise in the side-channel.

Another cause for this group of vulnerabilities is that not leaking the bit-length of the scalar used in scalar
multiplication is surprisingly hard. Take almost any algorithm that processes the scalar in a left to right fashion, the
Montgomery ladder for example, and instantiate it with addition formulas that are incomplete (cannot correctly compute
\( \mathcal{O} + P \) or \( 2\mathcal{O} \) in a side-channel indistinguishable way from \( P + Q \) and \( 2P \)), then
a side-channel leaking the bit-length will be present.

At the start of the ladder for computing a multiple of point
\( G\), the two ladder variables are initialized either as \( R\_0 = \mathcal{O} \) and \( R\_1 = G \) or as
\( R\_0 = G \) and \( R\_1 = 2G \). In the first case, the computation might start at any bit larger that the most
significant set bit in the scalar, i.e. it can be a fixed loop bound, for example on the bit-length of the order of the
generator, as seen in [algorithm 1](#montgomery-complete). However, until the first set bit is encountered,
all of the additions and doublings will involve the point at
infinity and because of our assumption that the formulas used are incomplete, they will leak this through some side-channel.
This leak might have the form of short-circuiting addition formulas, which check whether the point at infinity was input and short circuit accordingly to satisfy
\( \mathcal{O} + P = P \) and \( 2\mathcal{O} = \mathcal{O} \). This is the case in libgcrypt
for example, and was the reason why simply fixing a loop bound in scalar multiplication was not enough to fix the issue.
The formulas might leak the fact that the point at infinity is present through different channels than timing: power or
EM side-channels come to mind, as the point at infinity is often represented using only \( 0 \) or \( 1 \) values, which
can often be distinguishable in multiplication and addition on a power trace.

```

                \begin{algorithm}
                \caption{Montgomery ladder (complete)}
                \begin{algorithmic}
                \PROCEDURE{Ladder}{$G, k = (k_{l}, \ldots, k_0)_2$}
                    \STATE $R_0 = \mathcal{O}$; $R_1 = G$
                    \FOR{$i = l$ \DOWNTO 0}
                        \STATE $R_{\neg k_i} = R_0 + R_1$; $R_{k_i} = 2R_{k_i}$
                    \ENDFOR
                    \RETURN $R_0$
                \ENDPROCEDURE
                \end{algorithmic}
                \end{algorithm}

```

In the second case, the most significant bit of the scalar must be explicitly found, as seen in
[algorithm 2](#montgomery-incomplete) and the ladder must start at that bit, because the variables were
initialized into a state such that the point at infinity will not appear so that incomplete formulas could be used and no
infinity ever handled. If the loop started at some fixed bit past the most significant bit set, this algorithm would compute an incorrect result.
However, this clearly leaks the bit-length through timing alone, because of the loop bound on the bit-length of the
scalar.

```

                \begin{algorithm}
                \caption{Montgomery ladder (incomplete)}
                \begin{algorithmic}
                \PROCEDURE{Ladder}{$G, k = (k_{l}, \ldots, k_0)_2$}
                    \STATE $R_0 = G$; $R_1 = 2G$
                    \FOR{$i = \vert k \vert - 1$ \DOWNTO 0}
                        \STATE $R_{\neg k_i} = R_0 + R_1$; $R_{k_i} = 2R_{k_i}$
                    \ENDFOR
                    \RETURN $R_0$
                \ENDPROCEDURE
                \end{algorithmic}
                \end{algorithm}

```

Furthermore, in the name of performance, cryptographic libraries often include multiple optimized scalar
multiplication algorithms that are either chosen at compile time or even at runtime, for specific classes
of curves, or for use by a specific cryptosystem. This increases the effort necessary to test and verify that all of
the possible configurations are constant time and not vulnerable. As mentioned before, there are interactions
between the individual components such as addition formulas, coordinate systems and the scalar multiplication algorithm,
a change in one of those can make an implementation vulnerable, like using incomplete formulas that short circuit
the special cases. The configurations in libraries are often behind many define guards that enable parts of
functions, such that even figuring out which scalar multiplication function using which coordinate model and
addition formulas gets executed by a library for a particular operation on a particular curve is non-trivial.

Taking the example of the ECC implementation in SunEC/OpenJDK, in the
latest version, it contains both a Java implementation of ECC and a native one. The Java one is chosen if one of the
secp256r1, secp384r1, secp521r1 curves is
detected. The native implementation contains arithmetic for affine, Jacobian and Modified Jacobian coordinates. It
contains 4 scalar multiplication algorithms for prime field curves and three wrapper functions which dispatch to
appropriate functions. For some reason, the simple
scalar multiplication in ECDSA is performed through a call to a multi-scalar multiplication
wrapper, which dispatches it to a multi-scalar multiplication function which short circuits to a single-scalar
multiplication wrapper, because some of the arguments are null, this wrapper then finally dispatches to the appropriate
scalar multiplication function.

The cause of the vulnerability in cards using the Atmel Toolbox 00.03.11.05 is obvious, the toolbox
included functionality explicitly marked as not protected against SPA/DPA and timing attacks, which the vulnerable cards decided to use.

### Responsible disclosure

##### Athena IDProtect

We have discovered the vulnerability on 18.03.2019 in the Athena IDProtect card. To confirm its
exploitablity we have investigated it in more
detail in the following days and constructed a proof-of-concept which can be downloaded [above](#poc).
Following this, we have contacted the responsible party: NXP Semiconductors,
on 15.04.2019 at `ENABLE@JAVASCRIPT`. We
chose to contact NXP because the Athena Smart Card Solutions company, which produced the Athena
IDProtect cards, no longer exists, as it was bought by NXP in 2015 [[11]](#athena).

NXP Semiconductors confirmed the existence of the vulnerability on 19.04.2019 and stated that they
had migrated the former Athena IDProtect product line to
their hardware shortly after the acquisition, which effectively mitigated the vulnerability in newer products
based on the IDProtect line, long before our discovery, as it was present in the underlying cryptographic
library which was replaced along with the hardware. Furthermore, NXP discontinued the former Athena IDProtect line of
products a few years after the acquisition.

NXP Semiconductors was able to confirm that the Athena IDProtect card on the AT90SC chip indeed did use
the fast and insecure version of the ECDSA functionality from the Atmel Toolbox. Quoting the reply from
NXP Semiconductors:

> The vulnerability you found is in the Atmel crypto library that implements the ECC cryptography on the affected product.
> The Athena SCS product affected here is a legacy product which is no longer promoted by NXP.

##### WiseKey

After communicating with NXP Semiconductors, we contacted WiseKey, the current holder of the intellectual property of
the AT90 chip, cryptographic toolbox and associated items, and notified them of the vulnerability in the past versions of the Atmel toolbox.
We then explained details of the vulnerability during a call with the WiseKey cryptography team. We have no information on
whether current versions of the chip and toolbox are vulnerable.

##### Libgcrypt

After discovering the vulnerability on a smart-card, we analyzed many open-source cryptographic
libraries, we discovered the vulnerability in libgcrypt
on 09.07.2019, and notified the libgcrypt security team at `ENABLE@JAVASCRIPT`
on 12.07.2019. We coordinated on mitigating the issue and arrived at a final working patch on 18.07.2019, which was
merged on 07.08.2019.

##### wolfSSL

We discovered the leakage in wolfSSL on 09.07.2019 and notified wolfSSL at `ENABLE@JAVASCRIPT` on 11.07.2019. We received a patch
for testing on 12.07.2019, which fixed the issue. The fix for the issue was merged to the master branch on 17.07.2019.

##### MatrixSSL

We discovered the vulnerability in MatrixSSL on 11.07.2019, we notified MatrixSSL support at
`ENABLE@JAVASCRIPT` on 11.07.2019 and
at `ENABLE@JAVASCRIPT` (which looked like the maintainer's address from github commits) on
12.07.2019. We have not heard back from any of the addresses. MatrixSSL had a release in the meantime, which fixed some issues
but this vulnerability remains unpatched as of 02.10.2019.

##### Crypto++

We discovered the leakage in Crypto++ on 22.07.2019 and notified the Crypto++ team
on 25.07.2019. The main parts of the fix for the issue were merged to the master branch on 29.07.2019 and 05.08.2019.

##### SunEC

We discovered the leakage in SunEC on 22.07.2019 and notified Oracle at `ENABLE@JAVASCRIPT` on 26.07.2019. We provided Oracle with a patch
mitigating the issue on 14.08.2019. Furthermore, we notified the OpenJDK vulnerability group on 15.09.2019 at `ENABLE@JAVASCRIPT`. The vulnerability remains unpatched in the
public [jdk](https://hg.openjdk.java.net/jdk/jdk) repository as of 02.10.2019.

### Team

The vulnerability was discovered by a team at the [Centre for Research on Cryptography and
Security](https://crocs.fi.muni.cz) at Masaryk University in Czech Republic, using the self-developed and open-source [ECTester](https://crocs-muni.github.io/ECTester/) toolkit:

* [Jan Jancar](https://neuromancer.sk/about): ENABLE@JAVASCRIPT  [j08ny](https://twitter.com/j08ny)
* [Petr Svenda](https://crocs.fi.muni.cz/people/svenda): ENABLE@JAVASCRIPT  [rngsec](https://twitter.com/rngsec)
* [Vladimir Sedlacek](https://www.muni.cz/en/people/408178-vladimir-sedlacek): ENABLE@JAVASCRIPT  [vlada\_sedlacek](https://twitter.com/vlada_sedlacek)

### Timeline & Updates

* **18.03.2019** - Vulnerability discovered.
* **15.04.2019** - Vulnerability reported to NXP.
* **11.07.2019** - Vulnerability reported to wolfSSL and MatrixSSL.
* **12.07.2019** - Vulnerability reported to libgcrypt.
* **25.07.2019** - Vulnerability reported to Crypto++.
* **26.07.2019** - Vulnerability reported to Oracle.
* **13.09.2019** - We published a SHA256 [hash](https://twitter.com/CRoCS_MUNI/status/1172499426931302402) of an earlier version of this page to twitter.
* **02.10.2019** -  Release This website was published and the vulnerability disclosed on [our twitter](https://twitter.com/CRoCS_MUNI/status/1179392832299253761).
* **03.10.2019** - Fixed an issue in the PoC which required the `g6k` package, which is not available for Python 3.
* **03.10.2019** - Added a list of implementations we checked and deem secure.
* **04.10.2019** - Fixed the status of EdDSA in libgcrypt.
* **15.10.2019** - Oracle released a [Critical Patch Update](https://www.oracle.com/technetwork/security-advisory/cpuoct2019-5072832.html) which claims to fix the issue in SunEC,
  it does not, it disables the used of binary field curves by default in the Java TLS/SSL server. However,
  users of the SunEC library through the default Java Cryptography Provider remain vulnerable
  as well as users that setup their TLS/SSL server to allow and use binary field curves.
* **02.12.2019** - Removed EdDSA mentions from the page and added a disclaimer about its exploitability.
* **15.06.2020** - Added a pre-print version of the paper. Updated the page to better align with the more polished content in the paper.
* **27.08.2020** - Added the TCHES 2020 version of the paper. Added additional implementations deemed secure.
* **16.09.2020** - Added the BibTeX data and a note about the Best Paper Award.
* **14.12.2024** - Added CVEs for vulnerability in python-ecdsa and GnuTLS found by Alicja Kario and George Pantelakis.

### Media

* **ZDNet**: [Minerva attack can recover private keys from smart cards, cryptographic libraries](https://www.zdnet.com/article/minerva-attack-can-recover-private-keys-from-smart-cards-cryptographic-libraries/)
* **Golem.de**: [Minerva-Angriff zielt auf zertifizierte Krypto-Chips](https://www.golem.de/news/elliptische-kurven-minerva-angriff-zielt-auf-zertifizierte-krypto-chips-1910-144256.html)
* **Daniel J. Bernstein**: [Why EdDSA held up better than ECDSA against Minerva](https://blog.cr.yp.to/20191024-eddsa.html)
* **Feisty Duck**: [Elliptic curve implementations vulnerable to Minerva timing attack](https://www.feistyduck.com/bulletproof-tls-newsletter/issue_58_elliptic_curve_implementations_vulnerable_to_minerva_timing_attack)
* **Trail of Bits**: [ECDSA: Handle with Care](https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/)

### Acknowledgements

Computational resources were supplied by the project "e-Infrastruktura CZ" (e-INFRA LM2018140) [[13]](#metacentrum) provided within the program Projects of Large Research, Development and Innovations Infrastructures. This access was greatly appreciated.
Vladimir Sedlacek was supported by the Brno Ph.D. Talent Scholarship (funded by the Brno City Municipality).

---

### References

1. Dan Boneh, Ramarathnam Venkatesan: Hardness of computing the most
   significant bits of secret keys in Diffie-Hellman and related schemes (1996) [[pdf]](https://crypto.stanford.edu/~dabo/abstracts/dhmsb.html)
2. Phong Q. Nguyen, Igor E. Shparlinski: The Insecurity of the Digital
   Signature Algorithm with Partially Known Nonces (2002) [[DOI]](https://doi.org/10.1007/s00145-002-0021-3)
3. Billy B. Brumley, Nicola Tuveri: Remote Timing Attacks are Still
   Practical (2011) [[ePrint]](https://eprint.iacr.org/2011/232)
4. Phong Q. Nguyen: The Dark Side of the Hidden Number Problem: Lattice Attacks
   on DSA (2001) [[DOI]](https://doi.org/10.1007/978-3-0348-8295-8_23)
5. Naomi Benger, Joop van de Pol, Nigel P. Smart, Yuval Yarom:
   "Ooh Aah... Just a Little Bit" : A small amount of side channel can go a long way (2014)
   [[ePrint]](https://eprint.iacr.org/2014/161)
6. Joop van de Pol, Nigel P. Smart, Yuval Yarom: Just a Little Bit More
   (2015) [[ePrint]](https://eprint.iacr.org/2014/434)
7. Keegan Ryan: Return of the Hidden Number Problem: A widespread and novel key
   extraction attack on ECDSA and DSA (2018) [[DOI]](https://doi.org/10.13154/tches.v2019.i1.146-168)
8. Fergus Dall, Gabrielle De Micheli, Thomas Eisenbarth, Daniel Genkin,
   Nadia Heninger, Ahmad Moghimi, Yuval Yarom: CacheQuote: Efficiently Recovering Long-term Secrets of SGX EPID via Cache Attacks (2018)
   [[DOI]](https://doi.org/10.13154/tches.v2018.i2.171-191)
9. FIDO Alliance: FIDO ECDAA Algorithm (2018)
   [[spec]](https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-ecdaa-algorithm-v2.0-id-20180227.html)
10. The FPLLL development team: fplll, a lattice reduction library (2016) [[github]](https://github.com/fplll/fplll)
11. NXP Semiconductors: NXP Acquires Athena SCS (2015) [[release]](https://media.nxp.com/news-releases/news-release-details/nxp-acquires-athena-scs/)
12. NIST: FIPS PUB 140-2: SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC
    MODULES (2001) [[pdf]](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf)
13. Metacentrum NGI [[web]](https://www.metacentrum.cz/en/)
14. Daniel Moghimi, Berk Sunar, Thomas Eisenbarth, Nadia Heninger: TPM-Fail: TPM meets Timing and Lattice Attacks (2019) [[web]](https://tpm.fail)

---

Last update on 16.09.2020 | 2019-2020 Â© [CRoCS](https://crocs.fi.muni.cz) | [Logo](assets/img/logo.svg) is [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/), font is [OFL](https://scripts.sil.org/OFL)
licensed.


