=== Content from git.kernel.org_4c74a9ad_20250114_214500.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=cc86f2e9876c8b5300238cec6bf0bd8c842078ee)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=cc86f2e9876c8b5300238cec6bf0bd8c842078ee)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cc86f2e9876c8b5300238cec6bf0bd8c842078ee)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=cc86f2e9876c8b5300238cec6bf0bd8c842078ee)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mark Rutland <mark.rutland@arm.com> | 2024-10-08 16:58:46 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-08 16:19:18 +0100 |
| commit | [cc86f2e9876c8b5300238cec6bf0bd8c842078ee](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cc86f2e9876c8b5300238cec6bf0bd8c842078ee) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=cc86f2e9876c8b5300238cec6bf0bd8c842078ee)) | |
| tree | [cfded3c6c0dbc2e9e4aa59b2f61f7bf61b4fae76](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=cc86f2e9876c8b5300238cec6bf0bd8c842078ee) | |
| parent | [29f085345cde24566efb751f39e5d367c381c584](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=29f085345cde24566efb751f39e5d367c381c584) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=cc86f2e9876c8b5300238cec6bf0bd8c842078ee&id2=29f085345cde24566efb751f39e5d367c381c584)) | |
| download | [linux-cc86f2e9876c8b5300238cec6bf0bd8c842078ee.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-cc86f2e9876c8b5300238cec6bf0bd8c842078ee.tar.gz) | |

arm64: probes: Remove broken LDR (literal) uprobe supportcommit acc450aa07099d071b18174c22a1119c57da8227 upstream.
The simulate\_ldr\_literal() and simulate\_ldrsw\_literal() functions are
unsafe to use for uprobes. Both functions were originally written for
use with kprobes, and access memory with plain C accesses. When uprobes
was added, these were reused unmodified even though they cannot safely
access user memory.
There are three key problems:
1) The plain C accesses do not have corresponding extable entries, and
thus if they encounter a fault the kernel will treat these as
unintentional accesses to user memory, resulting in a BUG() which
will kill the kernel thread, and likely lead to further issues (e.g.
lockup or panic()).
2) The plain C accesses are subject to HW PAN and SW PAN, and so when
either is in use, any attempt to simulate an access to user memory
will fault. Thus neither simulate\_ldr\_literal() nor
simulate\_ldrsw\_literal() can do anything useful when simulating a
user instruction on any system with HW PAN or SW PAN.
3) The plain C accesses are privileged, as they run in kernel context,
and in practice can access a small range of kernel virtual addresses.
The instructions they simulate have a range of +/-1MiB, and since the
simulated instructions must itself be a user instructions in the
TTBR0 address range, these can address the final 1MiB of the TTBR1
acddress range by wrapping downwards from an address in the first
1MiB of the TTBR0 address range.
In contemporary kernels the last 8MiB of TTBR1 address range is
reserved, and accesses to this will always fault, meaning this is no
worse than (1).
Historically, it was theoretically possible for the linear map or
vmemmap to spill into the final 8MiB of the TTBR1 address range, but
in practice this is extremely unlikely to occur as this would
require either:
\* Having enough physical memory to fill the entire linear map all the
way to the final 1MiB of the TTBR1 address range.
\* Getting unlucky with KASLR randomization of the linear map such
that the populated region happens to overlap with the last 1MiB of
the TTBR address range.
... and in either case if we were to spill into the final page there
would be larger problems as the final page would alias with error
pointers.
Practically speaking, (1) and (2) are the big issues. Given there have
been no reports of problems since the broken code was introduced, it
appears that no-one is relying on probing these instructions with
uprobes.
Avoid these issues by not allowing uprobes on LDR (literal) and LDRSW
(literal), limiting the use of simulate\_ldr\_literal() and
simulate\_ldrsw\_literal() to kprobes. Attempts to place uprobes on LDR
(literal) and LDRSW (literal) will be rejected as
arm\_probe\_decode\_insn() will return INSN\_REJECTED. In future we can
consider introducing working uprobes support for these instructions, but
this will require more significant work.
Fixes: 9842ceae9fa8 ("arm64: Add uprobe support")
Cc: stable@vger.kernel.org
Signed-off-by: Mark Rutland <mark.rutland@arm.com>
Cc: Catalin Marinas <catalin.marinas@arm.com>
Cc: Will Deacon <will@kernel.org>
Link: [https://lore.kernel.org/r/20241008155851.801546-2-mark.rutland@arm.com](https://lore.kernel.org/r/20241008155851.801546-2-mark.rutland%40arm.com)
Signed-off-by: Will Deacon <will@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=cc86f2e9876c8b5300238cec6bf0bd8c842078ee)

| -rw-r--r-- | [arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/arm64/kernel/probes/decode-insn.c?id=cc86f2e9876c8b5300238cec6bf0bd8c842078ee) | 16 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 11 insertions, 5 deletions

| diff --git a/arch/arm64/kernel/probes/decode-insn.c b/arch/arm64/kernel/probes/decode-insn.cindex 6bf6657a5a5208..3d0684b7283961 100644--- a/[arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kernel/probes/decode-insn.c?id=29f085345cde24566efb751f39e5d367c381c584)+++ b/[arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kernel/probes/decode-insn.c?id=cc86f2e9876c8b5300238cec6bf0bd8c842078ee)@@ -104,10 +104,6 @@ arm\_probe\_decode\_insn(probe\_opcode\_t insn, struct arch\_probe\_insn \*api) aarch64\_insn\_is\_blr(insn) || aarch64\_insn\_is\_ret(insn)) { api->handler = simulate\_br\_blr\_ret;- } else if (aarch64\_insn\_is\_ldr\_lit(insn)) {- api->handler = simulate\_ldr\_literal;- } else if (aarch64\_insn\_is\_ldrsw\_lit(insn)) {- api->handler = simulate\_ldrsw\_literal; } else { /\* \* Instruction cannot be stepped out-of-line and we don't@@ -145,6 +141,17 @@ arm\_kprobe\_decode\_insn(kprobe\_opcode\_t \*addr, struct arch\_specific\_insn \*asi) probe\_opcode\_t insn = le32\_to\_cpu(\*addr); probe\_opcode\_t \*scan\_end = NULL; unsigned long size = 0, offset = 0;+ struct arch\_probe\_insn \*api = &asi->api;++ if (aarch64\_insn\_is\_ldr\_lit(insn)) {+ api->handler = simulate\_ldr\_literal;+ decoded = INSN\_GOOD\_NO\_SLOT;+ } else if (aarch64\_insn\_is\_ldrsw\_lit(insn)) {+ api->handler = simulate\_ldrsw\_literal;+ decoded = INSN\_GOOD\_NO\_SLOT;+ } else {+ decoded = arm\_probe\_decode\_insn(insn, &asi->api);+ }  /\* \* If there's a symbol defined in front of and near enough to@@ -162,7 +169,6 @@ arm\_kprobe\_decode\_insn(kprobe\_opcode\_t \*addr, struct arch\_specific\_insn \*asi) else scan\_end = addr - MAX\_ATOMIC\_CONTEXT\_SIZE; }- decoded = arm\_probe\_decode\_insn(insn, &asi->api);  if (decoded != INSN\_REJECTED && scan\_end) if (is\_probed\_address\_atomic(addr - 1, scan\_end)) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 21:43:38 +0000



=== Content from git.kernel.org_8452e09f_20250114_214455.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=20cde998315a3d2df08e26079a3ea7501abce6db)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=20cde998315a3d2df08e26079a3ea7501abce6db)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=20cde998315a3d2df08e26079a3ea7501abce6db)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=20cde998315a3d2df08e26079a3ea7501abce6db)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mark Rutland <mark.rutland@arm.com> | 2024-10-08 16:58:46 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-22 15:51:19 +0200 |
| commit | [20cde998315a3d2df08e26079a3ea7501abce6db](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=20cde998315a3d2df08e26079a3ea7501abce6db) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=20cde998315a3d2df08e26079a3ea7501abce6db)) | |
| tree | [82a23ad20cd9209286eaead06eb453279b6db9fa](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=20cde998315a3d2df08e26079a3ea7501abce6db) | |
| parent | [6ba1c7facc93675b7a06fd10745f3933c830885d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6ba1c7facc93675b7a06fd10745f3933c830885d) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=20cde998315a3d2df08e26079a3ea7501abce6db&id2=6ba1c7facc93675b7a06fd10745f3933c830885d)) | |
| download | [linux-20cde998315a3d2df08e26079a3ea7501abce6db.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-20cde998315a3d2df08e26079a3ea7501abce6db.tar.gz) | |

arm64: probes: Remove broken LDR (literal) uprobe supportcommit acc450aa07099d071b18174c22a1119c57da8227 upstream.
The simulate\_ldr\_literal() and simulate\_ldrsw\_literal() functions are
unsafe to use for uprobes. Both functions were originally written for
use with kprobes, and access memory with plain C accesses. When uprobes
was added, these were reused unmodified even though they cannot safely
access user memory.
There are three key problems:
1) The plain C accesses do not have corresponding extable entries, and
thus if they encounter a fault the kernel will treat these as
unintentional accesses to user memory, resulting in a BUG() which
will kill the kernel thread, and likely lead to further issues (e.g.
lockup or panic()).
2) The plain C accesses are subject to HW PAN and SW PAN, and so when
either is in use, any attempt to simulate an access to user memory
will fault. Thus neither simulate\_ldr\_literal() nor
simulate\_ldrsw\_literal() can do anything useful when simulating a
user instruction on any system with HW PAN or SW PAN.
3) The plain C accesses are privileged, as they run in kernel context,
and in practice can access a small range of kernel virtual addresses.
The instructions they simulate have a range of +/-1MiB, and since the
simulated instructions must itself be a user instructions in the
TTBR0 address range, these can address the final 1MiB of the TTBR1
acddress range by wrapping downwards from an address in the first
1MiB of the TTBR0 address range.
In contemporary kernels the last 8MiB of TTBR1 address range is
reserved, and accesses to this will always fault, meaning this is no
worse than (1).
Historically, it was theoretically possible for the linear map or
vmemmap to spill into the final 8MiB of the TTBR1 address range, but
in practice this is extremely unlikely to occur as this would
require either:
\* Having enough physical memory to fill the entire linear map all the
way to the final 1MiB of the TTBR1 address range.
\* Getting unlucky with KASLR randomization of the linear map such
that the populated region happens to overlap with the last 1MiB of
the TTBR address range.
... and in either case if we were to spill into the final page there
would be larger problems as the final page would alias with error
pointers.
Practically speaking, (1) and (2) are the big issues. Given there have
been no reports of problems since the broken code was introduced, it
appears that no-one is relying on probing these instructions with
uprobes.
Avoid these issues by not allowing uprobes on LDR (literal) and LDRSW
(literal), limiting the use of simulate\_ldr\_literal() and
simulate\_ldrsw\_literal() to kprobes. Attempts to place uprobes on LDR
(literal) and LDRSW (literal) will be rejected as
arm\_probe\_decode\_insn() will return INSN\_REJECTED. In future we can
consider introducing working uprobes support for these instructions, but
this will require more significant work.
Fixes: 9842ceae9fa8 ("arm64: Add uprobe support")
Cc: stable@vger.kernel.org
Signed-off-by: Mark Rutland <mark.rutland@arm.com>
Cc: Catalin Marinas <catalin.marinas@arm.com>
Cc: Will Deacon <will@kernel.org>
Link: [https://lore.kernel.org/r/20241008155851.801546-2-mark.rutland@arm.com](https://lore.kernel.org/r/20241008155851.801546-2-mark.rutland%40arm.com)
Signed-off-by: Will Deacon <will@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=20cde998315a3d2df08e26079a3ea7501abce6db)

| -rw-r--r-- | [arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/arm64/kernel/probes/decode-insn.c?id=20cde998315a3d2df08e26079a3ea7501abce6db) | 16 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 11 insertions, 5 deletions

| diff --git a/arch/arm64/kernel/probes/decode-insn.c b/arch/arm64/kernel/probes/decode-insn.cindex 968d5fffe23302..3496d6169e59b2 100644--- a/[arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kernel/probes/decode-insn.c?id=6ba1c7facc93675b7a06fd10745f3933c830885d)+++ b/[arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kernel/probes/decode-insn.c?id=20cde998315a3d2df08e26079a3ea7501abce6db)@@ -99,10 +99,6 @@ arm\_probe\_decode\_insn(probe\_opcode\_t insn, struct arch\_probe\_insn \*api) aarch64\_insn\_is\_blr(insn) || aarch64\_insn\_is\_ret(insn)) { api->handler = simulate\_br\_blr\_ret;- } else if (aarch64\_insn\_is\_ldr\_lit(insn)) {- api->handler = simulate\_ldr\_literal;- } else if (aarch64\_insn\_is\_ldrsw\_lit(insn)) {- api->handler = simulate\_ldrsw\_literal; } else { /\* \* Instruction cannot be stepped out-of-line and we don't@@ -140,6 +136,17 @@ arm\_kprobe\_decode\_insn(kprobe\_opcode\_t \*addr, struct arch\_specific\_insn \*asi) probe\_opcode\_t insn = le32\_to\_cpu(\*addr); probe\_opcode\_t \*scan\_end = NULL; unsigned long size = 0, offset = 0;+ struct arch\_probe\_insn \*api = &asi->api;++ if (aarch64\_insn\_is\_ldr\_lit(insn)) {+ api->handler = simulate\_ldr\_literal;+ decoded = INSN\_GOOD\_NO\_SLOT;+ } else if (aarch64\_insn\_is\_ldrsw\_lit(insn)) {+ api->handler = simulate\_ldrsw\_literal;+ decoded = INSN\_GOOD\_NO\_SLOT;+ } else {+ decoded = arm\_probe\_decode\_insn(insn, &asi->api);+ }  /\* \* If there's a symbol defined in front of and near enough to@@ -157,7 +164,6 @@ arm\_kprobe\_decode\_insn(kprobe\_opcode\_t \*addr, struct arch\_specific\_insn \*asi) else scan\_end = addr - MAX\_ATOMIC\_CONTEXT\_SIZE; }- decoded = arm\_probe\_decode\_insn(insn, &asi->api);  if (decoded != INSN\_REJECTED && scan\_end) if (is\_probed\_address\_atomic(addr - 1, scan\_end)) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 21:43:32 +0000



=== Content from git.kernel.org_0186ac3e_20250114_214458.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=ad4bc35a6d22e9ff9b67d0d0c38bce654232f195)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ad4bc35a6d22e9ff9b67d0d0c38bce654232f195)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ad4bc35a6d22e9ff9b67d0d0c38bce654232f195)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ad4bc35a6d22e9ff9b67d0d0c38bce654232f195)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mark Rutland <mark.rutland@arm.com> | 2024-10-08 16:58:46 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-22 15:40:40 +0200 |
| commit | [ad4bc35a6d22e9ff9b67d0d0c38bce654232f195](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ad4bc35a6d22e9ff9b67d0d0c38bce654232f195) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=ad4bc35a6d22e9ff9b67d0d0c38bce654232f195)) | |
| tree | [d93e88d07822e5b7cad164f115feb4367935d673](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ad4bc35a6d22e9ff9b67d0d0c38bce654232f195) | |
| parent | [c8789fbe2bbf75845e45302cba6ffa44e1884d01](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c8789fbe2bbf75845e45302cba6ffa44e1884d01) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ad4bc35a6d22e9ff9b67d0d0c38bce654232f195&id2=c8789fbe2bbf75845e45302cba6ffa44e1884d01)) | |
| download | [linux-ad4bc35a6d22e9ff9b67d0d0c38bce654232f195.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-ad4bc35a6d22e9ff9b67d0d0c38bce654232f195.tar.gz) | |

arm64: probes: Remove broken LDR (literal) uprobe supportcommit acc450aa07099d071b18174c22a1119c57da8227 upstream.
The simulate\_ldr\_literal() and simulate\_ldrsw\_literal() functions are
unsafe to use for uprobes. Both functions were originally written for
use with kprobes, and access memory with plain C accesses. When uprobes
was added, these were reused unmodified even though they cannot safely
access user memory.
There are three key problems:
1) The plain C accesses do not have corresponding extable entries, and
thus if they encounter a fault the kernel will treat these as
unintentional accesses to user memory, resulting in a BUG() which
will kill the kernel thread, and likely lead to further issues (e.g.
lockup or panic()).
2) The plain C accesses are subject to HW PAN and SW PAN, and so when
either is in use, any attempt to simulate an access to user memory
will fault. Thus neither simulate\_ldr\_literal() nor
simulate\_ldrsw\_literal() can do anything useful when simulating a
user instruction on any system with HW PAN or SW PAN.
3) The plain C accesses are privileged, as they run in kernel context,
and in practice can access a small range of kernel virtual addresses.
The instructions they simulate have a range of +/-1MiB, and since the
simulated instructions must itself be a user instructions in the
TTBR0 address range, these can address the final 1MiB of the TTBR1
acddress range by wrapping downwards from an address in the first
1MiB of the TTBR0 address range.
In contemporary kernels the last 8MiB of TTBR1 address range is
reserved, and accesses to this will always fault, meaning this is no
worse than (1).
Historically, it was theoretically possible for the linear map or
vmemmap to spill into the final 8MiB of the TTBR1 address range, but
in practice this is extremely unlikely to occur as this would
require either:
\* Having enough physical memory to fill the entire linear map all the
way to the final 1MiB of the TTBR1 address range.
\* Getting unlucky with KASLR randomization of the linear map such
that the populated region happens to overlap with the last 1MiB of
the TTBR address range.
... and in either case if we were to spill into the final page there
would be larger problems as the final page would alias with error
pointers.
Practically speaking, (1) and (2) are the big issues. Given there have
been no reports of problems since the broken code was introduced, it
appears that no-one is relying on probing these instructions with
uprobes.
Avoid these issues by not allowing uprobes on LDR (literal) and LDRSW
(literal), limiting the use of simulate\_ldr\_literal() and
simulate\_ldrsw\_literal() to kprobes. Attempts to place uprobes on LDR
(literal) and LDRSW (literal) will be rejected as
arm\_probe\_decode\_insn() will return INSN\_REJECTED. In future we can
consider introducing working uprobes support for these instructions, but
this will require more significant work.
Fixes: 9842ceae9fa8 ("arm64: Add uprobe support")
Cc: stable@vger.kernel.org
Signed-off-by: Mark Rutland <mark.rutland@arm.com>
Cc: Catalin Marinas <catalin.marinas@arm.com>
Cc: Will Deacon <will@kernel.org>
Link: [https://lore.kernel.org/r/20241008155851.801546-2-mark.rutland@arm.com](https://lore.kernel.org/r/20241008155851.801546-2-mark.rutland%40arm.com)
Signed-off-by: Will Deacon <will@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ad4bc35a6d22e9ff9b67d0d0c38bce654232f195)

| -rw-r--r-- | [arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/arm64/kernel/probes/decode-insn.c?id=ad4bc35a6d22e9ff9b67d0d0c38bce654232f195) | 16 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 11 insertions, 5 deletions

| diff --git a/arch/arm64/kernel/probes/decode-insn.c b/arch/arm64/kernel/probes/decode-insn.cindex 104101f633b10e..492e50a6ddbfc7 100644--- a/[arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kernel/probes/decode-insn.c?id=c8789fbe2bbf75845e45302cba6ffa44e1884d01)+++ b/[arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kernel/probes/decode-insn.c?id=ad4bc35a6d22e9ff9b67d0d0c38bce654232f195)@@ -99,10 +99,6 @@ arm\_probe\_decode\_insn(probe\_opcode\_t insn, struct arch\_probe\_insn \*api) aarch64\_insn\_is\_blr(insn) || aarch64\_insn\_is\_ret(insn)) { api->handler = simulate\_br\_blr\_ret;- } else if (aarch64\_insn\_is\_ldr\_lit(insn)) {- api->handler = simulate\_ldr\_literal;- } else if (aarch64\_insn\_is\_ldrsw\_lit(insn)) {- api->handler = simulate\_ldrsw\_literal; } else { /\* \* Instruction cannot be stepped out-of-line and we don't@@ -140,6 +136,17 @@ arm\_kprobe\_decode\_insn(kprobe\_opcode\_t \*addr, struct arch\_specific\_insn \*asi) probe\_opcode\_t insn = le32\_to\_cpu(\*addr); probe\_opcode\_t \*scan\_end = NULL; unsigned long size = 0, offset = 0;+ struct arch\_probe\_insn \*api = &asi->api;++ if (aarch64\_insn\_is\_ldr\_lit(insn)) {+ api->handler = simulate\_ldr\_literal;+ decoded = INSN\_GOOD\_NO\_SLOT;+ } else if (aarch64\_insn\_is\_ldrsw\_lit(insn)) {+ api->handler = simulate\_ldrsw\_literal;+ decoded = INSN\_GOOD\_NO\_SLOT;+ } else {+ decoded = arm\_probe\_decode\_insn(insn, &asi->api);+ }  /\* \* If there's a symbol defined in front of and near enough to@@ -157,7 +164,6 @@ arm\_kprobe\_decode\_insn(kprobe\_opcode\_t \*addr, struct arch\_specific\_insn \*asi) else scan\_end = addr - MAX\_ATOMIC\_CONTEXT\_SIZE; }- decoded = arm\_probe\_decode\_insn(insn, &asi->api);  if (decoded != INSN\_REJECTED && scan\_end) if (is\_probed\_address\_atomic(addr - 1, scan\_end)) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 21:43:35 +0000



=== Content from git.kernel.org_37caa1d7_20250114_214455.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=3728b4eb27910ffedd173018279a970705f2e03a)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3728b4eb27910ffedd173018279a970705f2e03a)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3728b4eb27910ffedd173018279a970705f2e03a)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3728b4eb27910ffedd173018279a970705f2e03a)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mark Rutland <mark.rutland@arm.com> | 2024-10-08 16:58:46 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-22 15:39:24 +0200 |
| commit | [3728b4eb27910ffedd173018279a970705f2e03a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3728b4eb27910ffedd173018279a970705f2e03a) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=3728b4eb27910ffedd173018279a970705f2e03a)) | |
| tree | [107924765dd575b7baef1f2a99716d7a9e330dee](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3728b4eb27910ffedd173018279a970705f2e03a) | |
| parent | [673a1c5a2998acbd429d6286e6cad10f17f4f073](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=673a1c5a2998acbd429d6286e6cad10f17f4f073) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3728b4eb27910ffedd173018279a970705f2e03a&id2=673a1c5a2998acbd429d6286e6cad10f17f4f073)) | |
| download | [linux-3728b4eb27910ffedd173018279a970705f2e03a.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-3728b4eb27910ffedd173018279a970705f2e03a.tar.gz) | |

arm64: probes: Remove broken LDR (literal) uprobe supportcommit acc450aa07099d071b18174c22a1119c57da8227 upstream.
The simulate\_ldr\_literal() and simulate\_ldrsw\_literal() functions are
unsafe to use for uprobes. Both functions were originally written for
use with kprobes, and access memory with plain C accesses. When uprobes
was added, these were reused unmodified even though they cannot safely
access user memory.
There are three key problems:
1) The plain C accesses do not have corresponding extable entries, and
thus if they encounter a fault the kernel will treat these as
unintentional accesses to user memory, resulting in a BUG() which
will kill the kernel thread, and likely lead to further issues (e.g.
lockup or panic()).
2) The plain C accesses are subject to HW PAN and SW PAN, and so when
either is in use, any attempt to simulate an access to user memory
will fault. Thus neither simulate\_ldr\_literal() nor
simulate\_ldrsw\_literal() can do anything useful when simulating a
user instruction on any system with HW PAN or SW PAN.
3) The plain C accesses are privileged, as they run in kernel context,
and in practice can access a small range of kernel virtual addresses.
The instructions they simulate have a range of +/-1MiB, and since the
simulated instructions must itself be a user instructions in the
TTBR0 address range, these can address the final 1MiB of the TTBR1
acddress range by wrapping downwards from an address in the first
1MiB of the TTBR0 address range.
In contemporary kernels the last 8MiB of TTBR1 address range is
reserved, and accesses to this will always fault, meaning this is no
worse than (1).
Historically, it was theoretically possible for the linear map or
vmemmap to spill into the final 8MiB of the TTBR1 address range, but
in practice this is extremely unlikely to occur as this would
require either:
\* Having enough physical memory to fill the entire linear map all the
way to the final 1MiB of the TTBR1 address range.
\* Getting unlucky with KASLR randomization of the linear map such
that the populated region happens to overlap with the last 1MiB of
the TTBR address range.
... and in either case if we were to spill into the final page there
would be larger problems as the final page would alias with error
pointers.
Practically speaking, (1) and (2) are the big issues. Given there have
been no reports of problems since the broken code was introduced, it
appears that no-one is relying on probing these instructions with
uprobes.
Avoid these issues by not allowing uprobes on LDR (literal) and LDRSW
(literal), limiting the use of simulate\_ldr\_literal() and
simulate\_ldrsw\_literal() to kprobes. Attempts to place uprobes on LDR
(literal) and LDRSW (literal) will be rejected as
arm\_probe\_decode\_insn() will return INSN\_REJECTED. In future we can
consider introducing working uprobes support for these instructions, but
this will require more significant work.
Fixes: 9842ceae9fa8 ("arm64: Add uprobe support")
Cc: stable@vger.kernel.org
Signed-off-by: Mark Rutland <mark.rutland@arm.com>
Cc: Catalin Marinas <catalin.marinas@arm.com>
Cc: Will Deacon <will@kernel.org>
Link: [https://lore.kernel.org/r/20241008155851.801546-2-mark.rutland@arm.com](https://lore.kernel.org/r/20241008155851.801546-2-mark.rutland%40arm.com)
Signed-off-by: Will Deacon <will@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3728b4eb27910ffedd173018279a970705f2e03a)

| -rw-r--r-- | [arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/arm64/kernel/probes/decode-insn.c?id=3728b4eb27910ffedd173018279a970705f2e03a) | 16 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 11 insertions, 5 deletions

| diff --git a/arch/arm64/kernel/probes/decode-insn.c b/arch/arm64/kernel/probes/decode-insn.cindex 104101f633b10e..492e50a6ddbfc7 100644--- a/[arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kernel/probes/decode-insn.c?id=673a1c5a2998acbd429d6286e6cad10f17f4f073)+++ b/[arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kernel/probes/decode-insn.c?id=3728b4eb27910ffedd173018279a970705f2e03a)@@ -99,10 +99,6 @@ arm\_probe\_decode\_insn(probe\_opcode\_t insn, struct arch\_probe\_insn \*api) aarch64\_insn\_is\_blr(insn) || aarch64\_insn\_is\_ret(insn)) { api->handler = simulate\_br\_blr\_ret;- } else if (aarch64\_insn\_is\_ldr\_lit(insn)) {- api->handler = simulate\_ldr\_literal;- } else if (aarch64\_insn\_is\_ldrsw\_lit(insn)) {- api->handler = simulate\_ldrsw\_literal; } else { /\* \* Instruction cannot be stepped out-of-line and we don't@@ -140,6 +136,17 @@ arm\_kprobe\_decode\_insn(kprobe\_opcode\_t \*addr, struct arch\_specific\_insn \*asi) probe\_opcode\_t insn = le32\_to\_cpu(\*addr); probe\_opcode\_t \*scan\_end = NULL; unsigned long size = 0, offset = 0;+ struct arch\_probe\_insn \*api = &asi->api;++ if (aarch64\_insn\_is\_ldr\_lit(insn)) {+ api->handler = simulate\_ldr\_literal;+ decoded = INSN\_GOOD\_NO\_SLOT;+ } else if (aarch64\_insn\_is\_ldrsw\_lit(insn)) {+ api->handler = simulate\_ldrsw\_literal;+ decoded = INSN\_GOOD\_NO\_SLOT;+ } else {+ decoded = arm\_probe\_decode\_insn(insn, &asi->api);+ }  /\* \* If there's a symbol defined in front of and near enough to@@ -157,7 +164,6 @@ arm\_kprobe\_decode\_insn(kprobe\_opcode\_t \*addr, struct arch\_specific\_insn \*asi) else scan\_end = addr - MAX\_ATOMIC\_CONTEXT\_SIZE; }- decoded = arm\_probe\_decode\_insn(insn, &asi->api);  if (decoded != INSN\_REJECTED && scan\_end) if (is\_probed\_address\_atomic(addr - 1, scan\_end)) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 21:43:33 +0000



=== Content from git.kernel.org_a7118dbf_20250114_214459.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=ae743deca78d9e4b7f4f60ad2f95e20e8ea057f9)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ae743deca78d9e4b7f4f60ad2f95e20e8ea057f9)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ae743deca78d9e4b7f4f60ad2f95e20e8ea057f9)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ae743deca78d9e4b7f4f60ad2f95e20e8ea057f9)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mark Rutland <mark.rutland@arm.com> | 2024-10-08 16:58:46 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-08 16:20:47 +0100 |
| commit | [ae743deca78d9e4b7f4f60ad2f95e20e8ea057f9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ae743deca78d9e4b7f4f60ad2f95e20e8ea057f9) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=ae743deca78d9e4b7f4f60ad2f95e20e8ea057f9)) | |
| tree | [3451b4c7317b18a57ae587913809f8932b96a64e](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ae743deca78d9e4b7f4f60ad2f95e20e8ea057f9) | |
| parent | [e0c966bd3e31911b57ef76cec4c5796ebd88e512](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e0c966bd3e31911b57ef76cec4c5796ebd88e512) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ae743deca78d9e4b7f4f60ad2f95e20e8ea057f9&id2=e0c966bd3e31911b57ef76cec4c5796ebd88e512)) | |
| download | [linux-ae743deca78d9e4b7f4f60ad2f95e20e8ea057f9.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-ae743deca78d9e4b7f4f60ad2f95e20e8ea057f9.tar.gz) | |

arm64: probes: Remove broken LDR (literal) uprobe supportcommit acc450aa07099d071b18174c22a1119c57da8227 upstream.
The simulate\_ldr\_literal() and simulate\_ldrsw\_literal() functions are
unsafe to use for uprobes. Both functions were originally written for
use with kprobes, and access memory with plain C accesses. When uprobes
was added, these were reused unmodified even though they cannot safely
access user memory.
There are three key problems:
1) The plain C accesses do not have corresponding extable entries, and
thus if they encounter a fault the kernel will treat these as
unintentional accesses to user memory, resulting in a BUG() which
will kill the kernel thread, and likely lead to further issues (e.g.
lockup or panic()).
2) The plain C accesses are subject to HW PAN and SW PAN, and so when
either is in use, any attempt to simulate an access to user memory
will fault. Thus neither simulate\_ldr\_literal() nor
simulate\_ldrsw\_literal() can do anything useful when simulating a
user instruction on any system with HW PAN or SW PAN.
3) The plain C accesses are privileged, as they run in kernel context,
and in practice can access a small range of kernel virtual addresses.
The instructions they simulate have a range of +/-1MiB, and since the
simulated instructions must itself be a user instructions in the
TTBR0 address range, these can address the final 1MiB of the TTBR1
acddress range by wrapping downwards from an address in the first
1MiB of the TTBR0 address range.
In contemporary kernels the last 8MiB of TTBR1 address range is
reserved, and accesses to this will always fault, meaning this is no
worse than (1).
Historically, it was theoretically possible for the linear map or
vmemmap to spill into the final 8MiB of the TTBR1 address range, but
in practice this is extremely unlikely to occur as this would
require either:
\* Having enough physical memory to fill the entire linear map all the
way to the final 1MiB of the TTBR1 address range.
\* Getting unlucky with KASLR randomization of the linear map such
that the populated region happens to overlap with the last 1MiB of
the TTBR address range.
... and in either case if we were to spill into the final page there
would be larger problems as the final page would alias with error
pointers.
Practically speaking, (1) and (2) are the big issues. Given there have
been no reports of problems since the broken code was introduced, it
appears that no-one is relying on probing these instructions with
uprobes.
Avoid these issues by not allowing uprobes on LDR (literal) and LDRSW
(literal), limiting the use of simulate\_ldr\_literal() and
simulate\_ldrsw\_literal() to kprobes. Attempts to place uprobes on LDR
(literal) and LDRSW (literal) will be rejected as
arm\_probe\_decode\_insn() will return INSN\_REJECTED. In future we can
consider introducing working uprobes support for these instructions, but
this will require more significant work.
Fixes: 9842ceae9fa8 ("arm64: Add uprobe support")
Cc: stable@vger.kernel.org
Signed-off-by: Mark Rutland <mark.rutland@arm.com>
Cc: Catalin Marinas <catalin.marinas@arm.com>
Cc: Will Deacon <will@kernel.org>
Link: [https://lore.kernel.org/r/20241008155851.801546-2-mark.rutland@arm.com](https://lore.kernel.org/r/20241008155851.801546-2-mark.rutland%40arm.com)
Signed-off-by: Will Deacon <will@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ae743deca78d9e4b7f4f60ad2f95e20e8ea057f9)

| -rw-r--r-- | [arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/arm64/kernel/probes/decode-insn.c?id=ae743deca78d9e4b7f4f60ad2f95e20e8ea057f9) | 16 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 11 insertions, 5 deletions

| diff --git a/arch/arm64/kernel/probes/decode-insn.c b/arch/arm64/kernel/probes/decode-insn.cindex b78fac9e546c50..327e42fa797c95 100644--- a/[arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kernel/probes/decode-insn.c?id=e0c966bd3e31911b57ef76cec4c5796ebd88e512)+++ b/[arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kernel/probes/decode-insn.c?id=ae743deca78d9e4b7f4f60ad2f95e20e8ea057f9)@@ -96,10 +96,6 @@ arm\_probe\_decode\_insn(probe\_opcode\_t insn, struct arch\_probe\_insn \*api) aarch64\_insn\_is\_blr(insn) || aarch64\_insn\_is\_ret(insn)) { api->handler = simulate\_br\_blr\_ret;- } else if (aarch64\_insn\_is\_ldr\_lit(insn)) {- api->handler = simulate\_ldr\_literal;- } else if (aarch64\_insn\_is\_ldrsw\_lit(insn)) {- api->handler = simulate\_ldrsw\_literal; } else { /\* \* Instruction cannot be stepped out-of-line and we don't@@ -137,6 +133,17 @@ arm\_kprobe\_decode\_insn(kprobe\_opcode\_t \*addr, struct arch\_specific\_insn \*asi) probe\_opcode\_t insn = le32\_to\_cpu(\*addr); probe\_opcode\_t \*scan\_end = NULL; unsigned long size = 0, offset = 0;+ struct arch\_probe\_insn \*api = &asi->api;++ if (aarch64\_insn\_is\_ldr\_lit(insn)) {+ api->handler = simulate\_ldr\_literal;+ decoded = INSN\_GOOD\_NO\_SLOT;+ } else if (aarch64\_insn\_is\_ldrsw\_lit(insn)) {+ api->handler = simulate\_ldrsw\_literal;+ decoded = INSN\_GOOD\_NO\_SLOT;+ } else {+ decoded = arm\_probe\_decode\_insn(insn, &asi->api);+ }  /\* \* If there's a symbol defined in front of and near enough to@@ -154,7 +161,6 @@ arm\_kprobe\_decode\_insn(kprobe\_opcode\_t \*addr, struct arch\_specific\_insn \*asi) else scan\_end = addr - MAX\_ATOMIC\_CONTEXT\_SIZE; }- decoded = arm\_probe\_decode\_insn(insn, &asi->api);  if (decoded != INSN\_REJECTED && scan\_end) if (is\_probed\_address\_atomic(addr - 1, scan\_end)) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 21:43:36 +0000



=== Content from git.kernel.org_6671b7f7_20250114_214500.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=bae792617a7e911477f67a3aff850ad4ddf51572)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=bae792617a7e911477f67a3aff850ad4ddf51572)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bae792617a7e911477f67a3aff850ad4ddf51572)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=bae792617a7e911477f67a3aff850ad4ddf51572)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mark Rutland <mark.rutland@arm.com> | 2024-10-08 16:58:46 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-22 15:56:42 +0200 |
| commit | [bae792617a7e911477f67a3aff850ad4ddf51572](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bae792617a7e911477f67a3aff850ad4ddf51572) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=bae792617a7e911477f67a3aff850ad4ddf51572)) | |
| tree | [a6cbf1fd70537ac9851acd66ace7ee1043a88465](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=bae792617a7e911477f67a3aff850ad4ddf51572) | |
| parent | [27abbde44b6e71ee3891de13e1a228aa7ce95bfe](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=27abbde44b6e71ee3891de13e1a228aa7ce95bfe) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=bae792617a7e911477f67a3aff850ad4ddf51572&id2=27abbde44b6e71ee3891de13e1a228aa7ce95bfe)) | |
| download | [linux-bae792617a7e911477f67a3aff850ad4ddf51572.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-bae792617a7e911477f67a3aff850ad4ddf51572.tar.gz) | |

arm64: probes: Remove broken LDR (literal) uprobe supportcommit acc450aa07099d071b18174c22a1119c57da8227 upstream.
The simulate\_ldr\_literal() and simulate\_ldrsw\_literal() functions are
unsafe to use for uprobes. Both functions were originally written for
use with kprobes, and access memory with plain C accesses. When uprobes
was added, these were reused unmodified even though they cannot safely
access user memory.
There are three key problems:
1) The plain C accesses do not have corresponding extable entries, and
thus if they encounter a fault the kernel will treat these as
unintentional accesses to user memory, resulting in a BUG() which
will kill the kernel thread, and likely lead to further issues (e.g.
lockup or panic()).
2) The plain C accesses are subject to HW PAN and SW PAN, and so when
either is in use, any attempt to simulate an access to user memory
will fault. Thus neither simulate\_ldr\_literal() nor
simulate\_ldrsw\_literal() can do anything useful when simulating a
user instruction on any system with HW PAN or SW PAN.
3) The plain C accesses are privileged, as they run in kernel context,
and in practice can access a small range of kernel virtual addresses.
The instructions they simulate have a range of +/-1MiB, and since the
simulated instructions must itself be a user instructions in the
TTBR0 address range, these can address the final 1MiB of the TTBR1
acddress range by wrapping downwards from an address in the first
1MiB of the TTBR0 address range.
In contemporary kernels the last 8MiB of TTBR1 address range is
reserved, and accesses to this will always fault, meaning this is no
worse than (1).
Historically, it was theoretically possible for the linear map or
vmemmap to spill into the final 8MiB of the TTBR1 address range, but
in practice this is extremely unlikely to occur as this would
require either:
\* Having enough physical memory to fill the entire linear map all the
way to the final 1MiB of the TTBR1 address range.
\* Getting unlucky with KASLR randomization of the linear map such
that the populated region happens to overlap with the last 1MiB of
the TTBR address range.
... and in either case if we were to spill into the final page there
would be larger problems as the final page would alias with error
pointers.
Practically speaking, (1) and (2) are the big issues. Given there have
been no reports of problems since the broken code was introduced, it
appears that no-one is relying on probing these instructions with
uprobes.
Avoid these issues by not allowing uprobes on LDR (literal) and LDRSW
(literal), limiting the use of simulate\_ldr\_literal() and
simulate\_ldrsw\_literal() to kprobes. Attempts to place uprobes on LDR
(literal) and LDRSW (literal) will be rejected as
arm\_probe\_decode\_insn() will return INSN\_REJECTED. In future we can
consider introducing working uprobes support for these instructions, but
this will require more significant work.
Fixes: 9842ceae9fa8 ("arm64: Add uprobe support")
Cc: stable@vger.kernel.org
Signed-off-by: Mark Rutland <mark.rutland@arm.com>
Cc: Catalin Marinas <catalin.marinas@arm.com>
Cc: Will Deacon <will@kernel.org>
Link: [https://lore.kernel.org/r/20241008155851.801546-2-mark.rutland@arm.com](https://lore.kernel.org/r/20241008155851.801546-2-mark.rutland%40arm.com)
Signed-off-by: Will Deacon <will@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=bae792617a7e911477f67a3aff850ad4ddf51572)

| -rw-r--r-- | [arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/arm64/kernel/probes/decode-insn.c?id=bae792617a7e911477f67a3aff850ad4ddf51572) | 16 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 11 insertions, 5 deletions

| diff --git a/arch/arm64/kernel/probes/decode-insn.c b/arch/arm64/kernel/probes/decode-insn.cindex 104101f633b10e..492e50a6ddbfc7 100644--- a/[arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kernel/probes/decode-insn.c?id=27abbde44b6e71ee3891de13e1a228aa7ce95bfe)+++ b/[arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kernel/probes/decode-insn.c?id=bae792617a7e911477f67a3aff850ad4ddf51572)@@ -99,10 +99,6 @@ arm\_probe\_decode\_insn(probe\_opcode\_t insn, struct arch\_probe\_insn \*api) aarch64\_insn\_is\_blr(insn) || aarch64\_insn\_is\_ret(insn)) { api->handler = simulate\_br\_blr\_ret;- } else if (aarch64\_insn\_is\_ldr\_lit(insn)) {- api->handler = simulate\_ldr\_literal;- } else if (aarch64\_insn\_is\_ldrsw\_lit(insn)) {- api->handler = simulate\_ldrsw\_literal; } else { /\* \* Instruction cannot be stepped out-of-line and we don't@@ -140,6 +136,17 @@ arm\_kprobe\_decode\_insn(kprobe\_opcode\_t \*addr, struct arch\_specific\_insn \*asi) probe\_opcode\_t insn = le32\_to\_cpu(\*addr); probe\_opcode\_t \*scan\_end = NULL; unsigned long size = 0, offset = 0;+ struct arch\_probe\_insn \*api = &asi->api;++ if (aarch64\_insn\_is\_ldr\_lit(insn)) {+ api->handler = simulate\_ldr\_literal;+ decoded = INSN\_GOOD\_NO\_SLOT;+ } else if (aarch64\_insn\_is\_ldrsw\_lit(insn)) {+ api->handler = simulate\_ldrsw\_literal;+ decoded = INSN\_GOOD\_NO\_SLOT;+ } else {+ decoded = arm\_probe\_decode\_insn(insn, &asi->api);+ }  /\* \* If there's a symbol defined in front of and near enough to@@ -157,7 +164,6 @@ arm\_kprobe\_decode\_insn(kprobe\_opcode\_t \*addr, struct arch\_specific\_insn \*asi) else scan\_end = addr - MAX\_ATOMIC\_CONTEXT\_SIZE; }- decoded = arm\_probe\_decode\_insn(insn, &asi->api);  if (decoded != INSN\_REJECTED && scan\_end) if (is\_probed\_address\_atomic(addr - 1, scan\_end)) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 21:43:37 +0000



=== Content from git.kernel.org_bdd941ed_20250114_214456.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=9f1e7735474e7457a4d919a517900e46868ae5f6)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9f1e7735474e7457a4d919a517900e46868ae5f6)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9f1e7735474e7457a4d919a517900e46868ae5f6)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9f1e7735474e7457a4d919a517900e46868ae5f6)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mark Rutland <mark.rutland@arm.com> | 2024-10-08 16:58:46 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-22 15:46:20 +0200 |
| commit | [9f1e7735474e7457a4d919a517900e46868ae5f6](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9f1e7735474e7457a4d919a517900e46868ae5f6) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=9f1e7735474e7457a4d919a517900e46868ae5f6)) | |
| tree | [fd2d1c88a0ad6d1d526f8f70fb538be293aa13bf](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9f1e7735474e7457a4d919a517900e46868ae5f6) | |
| parent | [a3f169e398215e71361774d13bf91a0101283ac2](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a3f169e398215e71361774d13bf91a0101283ac2) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9f1e7735474e7457a4d919a517900e46868ae5f6&id2=a3f169e398215e71361774d13bf91a0101283ac2)) | |
| download | [linux-9f1e7735474e7457a4d919a517900e46868ae5f6.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-9f1e7735474e7457a4d919a517900e46868ae5f6.tar.gz) | |

arm64: probes: Remove broken LDR (literal) uprobe supportcommit acc450aa07099d071b18174c22a1119c57da8227 upstream.
The simulate\_ldr\_literal() and simulate\_ldrsw\_literal() functions are
unsafe to use for uprobes. Both functions were originally written for
use with kprobes, and access memory with plain C accesses. When uprobes
was added, these were reused unmodified even though they cannot safely
access user memory.
There are three key problems:
1) The plain C accesses do not have corresponding extable entries, and
thus if they encounter a fault the kernel will treat these as
unintentional accesses to user memory, resulting in a BUG() which
will kill the kernel thread, and likely lead to further issues (e.g.
lockup or panic()).
2) The plain C accesses are subject to HW PAN and SW PAN, and so when
either is in use, any attempt to simulate an access to user memory
will fault. Thus neither simulate\_ldr\_literal() nor
simulate\_ldrsw\_literal() can do anything useful when simulating a
user instruction on any system with HW PAN or SW PAN.
3) The plain C accesses are privileged, as they run in kernel context,
and in practice can access a small range of kernel virtual addresses.
The instructions they simulate have a range of +/-1MiB, and since the
simulated instructions must itself be a user instructions in the
TTBR0 address range, these can address the final 1MiB of the TTBR1
acddress range by wrapping downwards from an address in the first
1MiB of the TTBR0 address range.
In contemporary kernels the last 8MiB of TTBR1 address range is
reserved, and accesses to this will always fault, meaning this is no
worse than (1).
Historically, it was theoretically possible for the linear map or
vmemmap to spill into the final 8MiB of the TTBR1 address range, but
in practice this is extremely unlikely to occur as this would
require either:
\* Having enough physical memory to fill the entire linear map all the
way to the final 1MiB of the TTBR1 address range.
\* Getting unlucky with KASLR randomization of the linear map such
that the populated region happens to overlap with the last 1MiB of
the TTBR address range.
... and in either case if we were to spill into the final page there
would be larger problems as the final page would alias with error
pointers.
Practically speaking, (1) and (2) are the big issues. Given there have
been no reports of problems since the broken code was introduced, it
appears that no-one is relying on probing these instructions with
uprobes.
Avoid these issues by not allowing uprobes on LDR (literal) and LDRSW
(literal), limiting the use of simulate\_ldr\_literal() and
simulate\_ldrsw\_literal() to kprobes. Attempts to place uprobes on LDR
(literal) and LDRSW (literal) will be rejected as
arm\_probe\_decode\_insn() will return INSN\_REJECTED. In future we can
consider introducing working uprobes support for these instructions, but
this will require more significant work.
Fixes: 9842ceae9fa8 ("arm64: Add uprobe support")
Cc: stable@vger.kernel.org
Signed-off-by: Mark Rutland <mark.rutland@arm.com>
Cc: Catalin Marinas <catalin.marinas@arm.com>
Cc: Will Deacon <will@kernel.org>
Link: [https://lore.kernel.org/r/20241008155851.801546-2-mark.rutland@arm.com](https://lore.kernel.org/r/20241008155851.801546-2-mark.rutland%40arm.com)
Signed-off-by: Will Deacon <will@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9f1e7735474e7457a4d919a517900e46868ae5f6)

| -rw-r--r-- | [arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/arm64/kernel/probes/decode-insn.c?id=9f1e7735474e7457a4d919a517900e46868ae5f6) | 16 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 11 insertions, 5 deletions

| diff --git a/arch/arm64/kernel/probes/decode-insn.c b/arch/arm64/kernel/probes/decode-insn.cindex 968d5fffe23302..3496d6169e59b2 100644--- a/[arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kernel/probes/decode-insn.c?id=a3f169e398215e71361774d13bf91a0101283ac2)+++ b/[arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kernel/probes/decode-insn.c?id=9f1e7735474e7457a4d919a517900e46868ae5f6)@@ -99,10 +99,6 @@ arm\_probe\_decode\_insn(probe\_opcode\_t insn, struct arch\_probe\_insn \*api) aarch64\_insn\_is\_blr(insn) || aarch64\_insn\_is\_ret(insn)) { api->handler = simulate\_br\_blr\_ret;- } else if (aarch64\_insn\_is\_ldr\_lit(insn)) {- api->handler = simulate\_ldr\_literal;- } else if (aarch64\_insn\_is\_ldrsw\_lit(insn)) {- api->handler = simulate\_ldrsw\_literal; } else { /\* \* Instruction cannot be stepped out-of-line and we don't@@ -140,6 +136,17 @@ arm\_kprobe\_decode\_insn(kprobe\_opcode\_t \*addr, struct arch\_specific\_insn \*asi) probe\_opcode\_t insn = le32\_to\_cpu(\*addr); probe\_opcode\_t \*scan\_end = NULL; unsigned long size = 0, offset = 0;+ struct arch\_probe\_insn \*api = &asi->api;++ if (aarch64\_insn\_is\_ldr\_lit(insn)) {+ api->handler = simulate\_ldr\_literal;+ decoded = INSN\_GOOD\_NO\_SLOT;+ } else if (aarch64\_insn\_is\_ldrsw\_lit(insn)) {+ api->handler = simulate\_ldrsw\_literal;+ decoded = INSN\_GOOD\_NO\_SLOT;+ } else {+ decoded = arm\_probe\_decode\_insn(insn, &asi->api);+ }  /\* \* If there's a symbol defined in front of and near enough to@@ -157,7 +164,6 @@ arm\_kprobe\_decode\_insn(kprobe\_opcode\_t \*addr, struct arch\_specific\_insn \*asi) else scan\_end = addr - MAX\_ATOMIC\_CONTEXT\_SIZE; }- decoded = arm\_probe\_decode\_insn(insn, &asi->api);  if (decoded != INSN\_REJECTED && scan\_end) if (is\_probed\_address\_atomic(addr - 1, scan\_end)) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 21:43:33 +0000



=== Content from git.kernel.org_a45ae37c_20250114_214457.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=acc450aa07099d071b18174c22a1119c57da8227)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=acc450aa07099d071b18174c22a1119c57da8227)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=acc450aa07099d071b18174c22a1119c57da8227)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=acc450aa07099d071b18174c22a1119c57da8227)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mark Rutland <mark.rutland@arm.com> | 2024-10-08 16:58:46 +0100 |
| --- | --- | --- |
| committer | Will Deacon <will@kernel.org> | 2024-10-09 16:56:53 +0100 |
| commit | [acc450aa07099d071b18174c22a1119c57da8227](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=acc450aa07099d071b18174c22a1119c57da8227) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=acc450aa07099d071b18174c22a1119c57da8227)) | |
| tree | [b9d9abfc0f868185bd7cfbade7fe316d8b50a7bd](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=acc450aa07099d071b18174c22a1119c57da8227) | |
| parent | [3eddb108abe3de6723cc4b77e8558ce1b3047987](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3eddb108abe3de6723cc4b77e8558ce1b3047987) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=acc450aa07099d071b18174c22a1119c57da8227&id2=3eddb108abe3de6723cc4b77e8558ce1b3047987)) | |
| download | [linux-acc450aa07099d071b18174c22a1119c57da8227.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-acc450aa07099d071b18174c22a1119c57da8227.tar.gz) | |

arm64: probes: Remove broken LDR (literal) uprobe supportThe simulate\_ldr\_literal() and simulate\_ldrsw\_literal() functions are
unsafe to use for uprobes. Both functions were originally written for
use with kprobes, and access memory with plain C accesses. When uprobes
was added, these were reused unmodified even though they cannot safely
access user memory.
There are three key problems:
1) The plain C accesses do not have corresponding extable entries, and
thus if they encounter a fault the kernel will treat these as
unintentional accesses to user memory, resulting in a BUG() which
will kill the kernel thread, and likely lead to further issues (e.g.
lockup or panic()).
2) The plain C accesses are subject to HW PAN and SW PAN, and so when
either is in use, any attempt to simulate an access to user memory
will fault. Thus neither simulate\_ldr\_literal() nor
simulate\_ldrsw\_literal() can do anything useful when simulating a
user instruction on any system with HW PAN or SW PAN.
3) The plain C accesses are privileged, as they run in kernel context,
and in practice can access a small range of kernel virtual addresses.
The instructions they simulate have a range of +/-1MiB, and since the
simulated instructions must itself be a user instructions in the
TTBR0 address range, these can address the final 1MiB of the TTBR1
acddress range by wrapping downwards from an address in the first
1MiB of the TTBR0 address range.
In contemporary kernels the last 8MiB of TTBR1 address range is
reserved, and accesses to this will always fault, meaning this is no
worse than (1).
Historically, it was theoretically possible for the linear map or
vmemmap to spill into the final 8MiB of the TTBR1 address range, but
in practice this is extremely unlikely to occur as this would
require either:
\* Having enough physical memory to fill the entire linear map all the
way to the final 1MiB of the TTBR1 address range.
\* Getting unlucky with KASLR randomization of the linear map such
that the populated region happens to overlap with the last 1MiB of
the TTBR address range.
... and in either case if we were to spill into the final page there
would be larger problems as the final page would alias with error
pointers.
Practically speaking, (1) and (2) are the big issues. Given there have
been no reports of problems since the broken code was introduced, it
appears that no-one is relying on probing these instructions with
uprobes.
Avoid these issues by not allowing uprobes on LDR (literal) and LDRSW
(literal), limiting the use of simulate\_ldr\_literal() and
simulate\_ldrsw\_literal() to kprobes. Attempts to place uprobes on LDR
(literal) and LDRSW (literal) will be rejected as
arm\_probe\_decode\_insn() will return INSN\_REJECTED. In future we can
consider introducing working uprobes support for these instructions, but
this will require more significant work.
Fixes: 9842ceae9fa8 ("arm64: Add uprobe support")
Cc: stable@vger.kernel.org
Signed-off-by: Mark Rutland <mark.rutland@arm.com>
Cc: Catalin Marinas <catalin.marinas@arm.com>
Cc: Will Deacon <will@kernel.org>
Link: [https://lore.kernel.org/r/20241008155851.801546-2-mark.rutland@arm.com](https://lore.kernel.org/r/20241008155851.801546-2-mark.rutland%40arm.com)
Signed-off-by: Will Deacon <will@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=acc450aa07099d071b18174c22a1119c57da8227)

| -rw-r--r-- | [arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/arm64/kernel/probes/decode-insn.c?id=acc450aa07099d071b18174c22a1119c57da8227) | 16 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 11 insertions, 5 deletions

| diff --git a/arch/arm64/kernel/probes/decode-insn.c b/arch/arm64/kernel/probes/decode-insn.cindex 968d5fffe23302..3496d6169e59b2 100644--- a/[arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kernel/probes/decode-insn.c?id=3eddb108abe3de6723cc4b77e8558ce1b3047987)+++ b/[arch/arm64/kernel/probes/decode-insn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/arm64/kernel/probes/decode-insn.c?id=acc450aa07099d071b18174c22a1119c57da8227)@@ -99,10 +99,6 @@ arm\_probe\_decode\_insn(probe\_opcode\_t insn, struct arch\_probe\_insn \*api) aarch64\_insn\_is\_blr(insn) || aarch64\_insn\_is\_ret(insn)) { api->handler = simulate\_br\_blr\_ret;- } else if (aarch64\_insn\_is\_ldr\_lit(insn)) {- api->handler = simulate\_ldr\_literal;- } else if (aarch64\_insn\_is\_ldrsw\_lit(insn)) {- api->handler = simulate\_ldrsw\_literal; } else { /\* \* Instruction cannot be stepped out-of-line and we don't@@ -140,6 +136,17 @@ arm\_kprobe\_decode\_insn(kprobe\_opcode\_t \*addr, struct arch\_specific\_insn \*asi) probe\_opcode\_t insn = le32\_to\_cpu(\*addr); probe\_opcode\_t \*scan\_end = NULL; unsigned long size = 0, offset = 0;+ struct arch\_probe\_insn \*api = &asi->api;++ if (aarch64\_insn\_is\_ldr\_lit(insn)) {+ api->handler = simulate\_ldr\_literal;+ decoded = INSN\_GOOD\_NO\_SLOT;+ } else if (aarch64\_insn\_is\_ldrsw\_lit(insn)) {+ api->handler = simulate\_ldrsw\_literal;+ decoded = INSN\_GOOD\_NO\_SLOT;+ } else {+ decoded = arm\_probe\_decode\_insn(insn, &asi->api);+ }  /\* \* If there's a symbol defined in front of and near enough to@@ -157,7 +164,6 @@ arm\_kprobe\_decode\_insn(kprobe\_opcode\_t \*addr, struct arch\_specific\_insn \*asi) else scan\_end = addr - MAX\_ATOMIC\_CONTEXT\_SIZE; }- decoded = arm\_probe\_decode\_insn(insn, &asi->api);  if (decoded != INSN\_REJECTED && scan\_end) if (is\_probed\_address\_atomic(addr - 1, scan\_end)) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 21:43:34 +0000


