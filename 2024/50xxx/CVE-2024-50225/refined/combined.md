=== Content from git.kernel.org_dadd3dc9_20250114_203826.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=22833d89b780ba0f9f66e19c477e7decf638edce)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=22833d89b780ba0f9f66e19c477e7decf638edce)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=22833d89b780ba0f9f66e19c477e7decf638edce)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=22833d89b780ba0f9f66e19c477e7decf638edce)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Naohiro Aota <naohiro.aota@wdc.com> | 2024-10-09 22:52:06 +0900 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-08 16:30:56 +0100 |
| commit | [22833d89b780ba0f9f66e19c477e7decf638edce](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=22833d89b780ba0f9f66e19c477e7decf638edce) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=22833d89b780ba0f9f66e19c477e7decf638edce)) | |
| tree | [7d1f0899513dacf1640e59b93e91c1d1f67a2a22](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=22833d89b780ba0f9f66e19c477e7decf638edce) | |
| parent | [54a3f1bac8b845fa815bc245eca1f598227e91d6](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=54a3f1bac8b845fa815bc245eca1f598227e91d6) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=22833d89b780ba0f9f66e19c477e7decf638edce&id2=54a3f1bac8b845fa815bc245eca1f598227e91d6)) | |
| download | [linux-22833d89b780ba0f9f66e19c477e7decf638edce.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-22833d89b780ba0f9f66e19c477e7decf638edce.tar.gz) | |

btrfs: fix error propagation of split bios[ Upstream commit d48e1dea3931de64c26717adc2b89743c7ab6594 ]
The purpose of btrfs\_bbio\_propagate\_error() shall be propagating an error
of split bio to its original btrfs\_bio, and tell the error to the upper
layer. However, it's not working well on some cases.
\* Case 1. Immediate (or quick) end\_bio with an error
When btrfs sends btrfs\_bio to mirrored devices, btrfs calls
btrfs\_bio\_end\_io() when all the mirroring bios are completed. If that
btrfs\_bio was split, it is from btrfs\_clone\_bioset and its end\_io function
is btrfs\_orig\_write\_end\_io. For this case, btrfs\_bbio\_propagate\_error()
accesses the orig\_bbio's bio context to increase the error count.
That works well in most cases. However, if the end\_io is called enough
fast, orig\_bbio's (remaining part after split) bio context may not be
properly set at that time. Since the bio context is set when the orig\_bbio
(the last btrfs\_bio) is sent to devices, that might be too late for earlier
split btrfs\_bio's completion. That will result in NULL pointer
dereference.
That bug is easily reproducible by running btrfs/146 on zoned devices [1]
and it shows the following trace.
[1] You need raid-stripe-tree feature as it create "-d raid0 -m raid1" FS.
BUG: kernel NULL pointer dereference, address: 0000000000000020
#PF: supervisor read access in kernel mode
#PF: error\_code(0x0000) - not-present page
PGD 0 P4D 0
Oops: Oops: 0000 [#1] PREEMPT SMP PTI
CPU: 1 UID: 0 PID: 13 Comm: kworker/u32:1 Not tainted 6.11.0-rc7-BTRFS-ZNS+ #474
Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
Workqueue: writeback wb\_workfn (flush-btrfs-5)
RIP: 0010:btrfs\_bio\_end\_io+0xae/0xc0 [btrfs]
BTRFS error (device dm-0): bdev /dev/mapper/error-test errs: wr 2, rd 0, flush 0, corrupt 0, gen 0
RSP: 0018:ffffc9000006f248 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888005a7f080 RCX: ffffc9000006f1dc
RDX: 0000000000000000 RSI: 000000000000000a RDI: ffff888005a7f080
RBP: ffff888011dfc540 R08: 0000000000000000 R09: 0000000000000001
R10: ffffffff82e508e0 R11: 0000000000000005 R12: ffff88800ddfbe58
R13: ffff888005a7f080 R14: ffff888005a7f158 R15: ffff888005a7f158
FS: 0000000000000000(0000) GS:ffff88803ea80000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000020 CR3: 0000000002e22006 CR4: 0000000000370ef0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
<TASK>
? \_\_die\_body.cold+0x19/0x26
? page\_fault\_oops+0x13e/0x2b0
? \_printk+0x58/0x73
? do\_user\_addr\_fault+0x5f/0x750
? exc\_page\_fault+0x76/0x240
? asm\_exc\_page\_fault+0x22/0x30
? btrfs\_bio\_end\_io+0xae/0xc0 [btrfs]
? btrfs\_log\_dev\_io\_error+0x7f/0x90 [btrfs]
btrfs\_orig\_write\_end\_io+0x51/0x90 [btrfs]
dm\_submit\_bio+0x5c2/0xa50 [dm\_mod]
? find\_held\_lock+0x2b/0x80
? blk\_try\_enter\_queue+0x90/0x1e0
\_\_submit\_bio+0xe0/0x130
? ktime\_get+0x10a/0x160
? lockdep\_hardirqs\_on+0x74/0x100
submit\_bio\_noacct\_nocheck+0x199/0x410
btrfs\_submit\_bio+0x7d/0x150 [btrfs]
btrfs\_submit\_chunk+0x1a1/0x6d0 [btrfs]
? lockdep\_hardirqs\_on+0x74/0x100
? \_\_folio\_start\_writeback+0x10/0x2c0
btrfs\_submit\_bbio+0x1c/0x40 [btrfs]
submit\_one\_bio+0x44/0x60 [btrfs]
submit\_extent\_folio+0x13f/0x330 [btrfs]
? btrfs\_set\_range\_writeback+0xa3/0xd0 [btrfs]
extent\_writepage\_io+0x18b/0x360 [btrfs]
extent\_write\_locked\_range+0x17c/0x340 [btrfs]
? \_\_pfx\_end\_bbio\_data\_write+0x10/0x10 [btrfs]
run\_delalloc\_cow+0x71/0xd0 [btrfs]
btrfs\_run\_delalloc\_range+0x176/0x500 [btrfs]
? find\_lock\_delalloc\_range+0x119/0x260 [btrfs]
writepage\_delalloc+0x2ab/0x480 [btrfs]
extent\_write\_cache\_pages+0x236/0x7d0 [btrfs]
btrfs\_writepages+0x72/0x130 [btrfs]
do\_writepages+0xd4/0x240
? find\_held\_lock+0x2b/0x80
? wbc\_attach\_and\_unlock\_inode+0x12c/0x290
? wbc\_attach\_and\_unlock\_inode+0x12c/0x290
\_\_writeback\_single\_inode+0x5c/0x4c0
? do\_raw\_spin\_unlock+0x49/0xb0
writeback\_sb\_inodes+0x22c/0x560
\_\_writeback\_inodes\_wb+0x4c/0xe0
wb\_writeback+0x1d6/0x3f0
wb\_workfn+0x334/0x520
process\_one\_work+0x1ee/0x570
? lock\_is\_held\_type+0xc6/0x130
worker\_thread+0x1d1/0x3b0
? \_\_pfx\_worker\_thread+0x10/0x10
kthread+0xee/0x120
? \_\_pfx\_kthread+0x10/0x10
ret\_from\_fork+0x30/0x50
? \_\_pfx\_kthread+0x10/0x10
ret\_from\_fork\_asm+0x1a/0x30
</TASK>
Modules linked in: dm\_mod btrfs blake2b\_generic xor raid6\_pq rapl
CR2: 0000000000000020
\* Case 2. Earlier completion of orig\_bbio for mirrored btrfs\_bios
btrfs\_bbio\_propagate\_error() assumes the end\_io function for orig\_bbio is
called last among split bios. In that case, btrfs\_orig\_write\_end\_io() sets
the bio->bi\_status to BLK\_STS\_IOERR by seeing the bioc->error [2].
Otherwise, the increased orig\_bio's bioc->error is not checked by anyone
and return BLK\_STS\_OK to the upper layer.
[2] Actually, this is not true. Because we only increases orig\_bioc->errors
by max\_errors, the condition "atomic\_read(&bioc->error) > bioc->max\_errors"
is still not met if only one split btrfs\_bio fails.
\* Case 3. Later completion of orig\_bbio for un-mirrored btrfs\_bios
In contrast to the above case, btrfs\_bbio\_propagate\_error() is not working
well if un-mirrored orig\_bbio is completed last. It sets
orig\_bbio->bio.bi\_status to the btrfs\_bio's error. But, that is easily
over-written by orig\_bbio's completion status. If the status is BLK\_STS\_OK,
the upper layer would not know the failure.
\* Solution
Considering the above cases, we can only save the error status in the
orig\_bbio (remaining part after split) itself as it is always
available. Also, the saved error status should be propagated when all the
split btrfs\_bios are finished (i.e, bbio->pending\_ios == 0).
This commit introduces "status" to btrfs\_bbio and saves the first error of
split bios to original btrfs\_bio's "status" variable. When all the split
bios are finished, the saved status is loaded into original btrfs\_bio's
status.
With this commit, btrfs/146 on zoned devices does not hit the NULL pointer
dereference anymore.
Fixes: 852eee62d31a ("btrfs: allow btrfs\_submit\_bio to split bios")
CC: stable@vger.kernel.org # 6.6+
Reviewed-by: Qu Wenruo <wqu@suse.com>
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
Signed-off-by: Naohiro Aota <naohiro.aota@wdc.com>
Signed-off-by: David Sterba <dsterba@suse.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=22833d89b780ba0f9f66e19c477e7decf638edce)

| -rw-r--r-- | [fs/btrfs/bio.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/bio.c?id=22833d89b780ba0f9f66e19c477e7decf638edce) | 37 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/btrfs/bio.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/bio.h?id=22833d89b780ba0f9f66e19c477e7decf638edce) | 3 | |  |  |  | | --- | --- | --- | |

2 files changed, 16 insertions, 24 deletions

| diff --git a/fs/btrfs/bio.c b/fs/btrfs/bio.cindex e93d376796a282..31e437d94869de 100644--- a/[fs/btrfs/bio.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/bio.c?id=54a3f1bac8b845fa815bc245eca1f598227e91d6)+++ b/[fs/btrfs/bio.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/bio.c?id=22833d89b780ba0f9f66e19c477e7decf638edce)@@ -49,6 +49,7 @@ void btrfs\_bio\_init(struct btrfs\_bio \*bbio, struct btrfs\_fs\_info \*fs\_info, bbio->end\_io = end\_io; bbio->private = private; atomic\_set(&bbio->pending\_ios, 1);+ WRITE\_ONCE(bbio->status, BLK\_STS\_OK); }  /\*@@ -120,41 +121,29 @@ static void \_\_btrfs\_bio\_end\_io(struct btrfs\_bio \*bbio) } } -static void btrfs\_orig\_write\_end\_io(struct bio \*bio);--static void btrfs\_bbio\_propagate\_error(struct btrfs\_bio \*bbio,- struct btrfs\_bio \*orig\_bbio)-{- /\*- \* For writes we tolerate nr\_mirrors - 1 write failures, so we can't- \* just blindly propagate a write failure here. Instead increment the- \* error count in the original I/O context so that it is guaranteed to- \* be larger than the error tolerance.- \*/- if (bbio->bio.bi\_end\_io == &btrfs\_orig\_write\_end\_io) {- struct btrfs\_io\_stripe \*orig\_stripe = orig\_bbio->bio.bi\_private;- struct btrfs\_io\_context \*orig\_bioc = orig\_stripe->bioc;-- atomic\_add(orig\_bioc->max\_errors, &orig\_bioc->error);- } else {- orig\_bbio->bio.bi\_status = bbio->bio.bi\_status;- }-}- void btrfs\_bio\_end\_io(struct btrfs\_bio \*bbio, blk\_status\_t status) { bbio->bio.bi\_status = status; if (bbio->bio.bi\_pool == &btrfs\_clone\_bioset) { struct btrfs\_bio \*orig\_bbio = bbio->private; - if (bbio->bio.bi\_status)- btrfs\_bbio\_propagate\_error(bbio, orig\_bbio); btrfs\_cleanup\_bio(bbio); bbio = orig\_bbio; } - if (atomic\_dec\_and\_test(&bbio->pending\_ios))+ /\*+ \* At this point, bbio always points to the original btrfs\_bio. Save+ \* the first error in it.+ \*/+ if (status != BLK\_STS\_OK)+ cmpxchg(&bbio->status, BLK\_STS\_OK, status);++ if (atomic\_dec\_and\_test(&bbio->pending\_ios)) {+ /\* Load split bio's error which might be set above. \*/+ if (status == BLK\_STS\_OK)+ bbio->bio.bi\_status = READ\_ONCE(bbio->status); \_\_btrfs\_bio\_end\_io(bbio);+ } }  static int next\_repair\_mirror(struct btrfs\_failed\_bio \*fbio, int cur\_mirror)diff --git a/fs/btrfs/bio.h b/fs/btrfs/bio.hindex d9dd5276093df0..043f94562166ba 100644--- a/[fs/btrfs/bio.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/bio.h?id=54a3f1bac8b845fa815bc245eca1f598227e91d6)+++ b/[fs/btrfs/bio.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/bio.h?id=22833d89b780ba0f9f66e19c477e7decf638edce)@@ -79,6 +79,9 @@ struct btrfs\_bio { /\* File system that this I/O operates on. \*/ struct btrfs\_fs\_info \*fs\_info; + /\* Save the first error status of split bio. \*/+ blk\_status\_t status;+ /\* \* This member must come last, bio\_alloc\_bioset will allocate enough \* bytes for entire btrfs\_bio but relies on bio being last. |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:37:03 +0000



=== Content from git.kernel.org_09614e98_20250114_203828.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d48e1dea3931de64c26717adc2b89743c7ab6594)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d48e1dea3931de64c26717adc2b89743c7ab6594)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d48e1dea3931de64c26717adc2b89743c7ab6594)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d48e1dea3931de64c26717adc2b89743c7ab6594)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Naohiro Aota <naohiro.aota@wdc.com> | 2024-10-09 22:52:06 +0900 |
| --- | --- | --- |
| committer | David Sterba <dsterba@suse.com> | 2024-10-23 18:17:43 +0200 |
| commit | [d48e1dea3931de64c26717adc2b89743c7ab6594](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d48e1dea3931de64c26717adc2b89743c7ab6594) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d48e1dea3931de64c26717adc2b89743c7ab6594)) | |
| tree | [76e7ceff8c70e292c72605d13c6fb3cbaded918b](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d48e1dea3931de64c26717adc2b89743c7ab6594) | |
| parent | [90a88784cdb7757feb8dd520255e6cb861f30943](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=90a88784cdb7757feb8dd520255e6cb861f30943) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d48e1dea3931de64c26717adc2b89743c7ab6594&id2=90a88784cdb7757feb8dd520255e6cb861f30943)) | |
| download | [linux-d48e1dea3931de64c26717adc2b89743c7ab6594.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d48e1dea3931de64c26717adc2b89743c7ab6594.tar.gz) | |

btrfs: fix error propagation of split biosThe purpose of btrfs\_bbio\_propagate\_error() shall be propagating an error
of split bio to its original btrfs\_bio, and tell the error to the upper
layer. However, it's not working well on some cases.
\* Case 1. Immediate (or quick) end\_bio with an error
When btrfs sends btrfs\_bio to mirrored devices, btrfs calls
btrfs\_bio\_end\_io() when all the mirroring bios are completed. If that
btrfs\_bio was split, it is from btrfs\_clone\_bioset and its end\_io function
is btrfs\_orig\_write\_end\_io. For this case, btrfs\_bbio\_propagate\_error()
accesses the orig\_bbio's bio context to increase the error count.
That works well in most cases. However, if the end\_io is called enough
fast, orig\_bbio's (remaining part after split) bio context may not be
properly set at that time. Since the bio context is set when the orig\_bbio
(the last btrfs\_bio) is sent to devices, that might be too late for earlier
split btrfs\_bio's completion. That will result in NULL pointer
dereference.
That bug is easily reproducible by running btrfs/146 on zoned devices [1]
and it shows the following trace.
[1] You need raid-stripe-tree feature as it create "-d raid0 -m raid1" FS.
BUG: kernel NULL pointer dereference, address: 0000000000000020
#PF: supervisor read access in kernel mode
#PF: error\_code(0x0000) - not-present page
PGD 0 P4D 0
Oops: Oops: 0000 [#1] PREEMPT SMP PTI
CPU: 1 UID: 0 PID: 13 Comm: kworker/u32:1 Not tainted 6.11.0-rc7-BTRFS-ZNS+ #474
Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
Workqueue: writeback wb\_workfn (flush-btrfs-5)
RIP: 0010:btrfs\_bio\_end\_io+0xae/0xc0 [btrfs]
BTRFS error (device dm-0): bdev /dev/mapper/error-test errs: wr 2, rd 0, flush 0, corrupt 0, gen 0
RSP: 0018:ffffc9000006f248 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888005a7f080 RCX: ffffc9000006f1dc
RDX: 0000000000000000 RSI: 000000000000000a RDI: ffff888005a7f080
RBP: ffff888011dfc540 R08: 0000000000000000 R09: 0000000000000001
R10: ffffffff82e508e0 R11: 0000000000000005 R12: ffff88800ddfbe58
R13: ffff888005a7f080 R14: ffff888005a7f158 R15: ffff888005a7f158
FS: 0000000000000000(0000) GS:ffff88803ea80000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000020 CR3: 0000000002e22006 CR4: 0000000000370ef0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
<TASK>
? \_\_die\_body.cold+0x19/0x26
? page\_fault\_oops+0x13e/0x2b0
? \_printk+0x58/0x73
? do\_user\_addr\_fault+0x5f/0x750
? exc\_page\_fault+0x76/0x240
? asm\_exc\_page\_fault+0x22/0x30
? btrfs\_bio\_end\_io+0xae/0xc0 [btrfs]
? btrfs\_log\_dev\_io\_error+0x7f/0x90 [btrfs]
btrfs\_orig\_write\_end\_io+0x51/0x90 [btrfs]
dm\_submit\_bio+0x5c2/0xa50 [dm\_mod]
? find\_held\_lock+0x2b/0x80
? blk\_try\_enter\_queue+0x90/0x1e0
\_\_submit\_bio+0xe0/0x130
? ktime\_get+0x10a/0x160
? lockdep\_hardirqs\_on+0x74/0x100
submit\_bio\_noacct\_nocheck+0x199/0x410
btrfs\_submit\_bio+0x7d/0x150 [btrfs]
btrfs\_submit\_chunk+0x1a1/0x6d0 [btrfs]
? lockdep\_hardirqs\_on+0x74/0x100
? \_\_folio\_start\_writeback+0x10/0x2c0
btrfs\_submit\_bbio+0x1c/0x40 [btrfs]
submit\_one\_bio+0x44/0x60 [btrfs]
submit\_extent\_folio+0x13f/0x330 [btrfs]
? btrfs\_set\_range\_writeback+0xa3/0xd0 [btrfs]
extent\_writepage\_io+0x18b/0x360 [btrfs]
extent\_write\_locked\_range+0x17c/0x340 [btrfs]
? \_\_pfx\_end\_bbio\_data\_write+0x10/0x10 [btrfs]
run\_delalloc\_cow+0x71/0xd0 [btrfs]
btrfs\_run\_delalloc\_range+0x176/0x500 [btrfs]
? find\_lock\_delalloc\_range+0x119/0x260 [btrfs]
writepage\_delalloc+0x2ab/0x480 [btrfs]
extent\_write\_cache\_pages+0x236/0x7d0 [btrfs]
btrfs\_writepages+0x72/0x130 [btrfs]
do\_writepages+0xd4/0x240
? find\_held\_lock+0x2b/0x80
? wbc\_attach\_and\_unlock\_inode+0x12c/0x290
? wbc\_attach\_and\_unlock\_inode+0x12c/0x290
\_\_writeback\_single\_inode+0x5c/0x4c0
? do\_raw\_spin\_unlock+0x49/0xb0
writeback\_sb\_inodes+0x22c/0x560
\_\_writeback\_inodes\_wb+0x4c/0xe0
wb\_writeback+0x1d6/0x3f0
wb\_workfn+0x334/0x520
process\_one\_work+0x1ee/0x570
? lock\_is\_held\_type+0xc6/0x130
worker\_thread+0x1d1/0x3b0
? \_\_pfx\_worker\_thread+0x10/0x10
kthread+0xee/0x120
? \_\_pfx\_kthread+0x10/0x10
ret\_from\_fork+0x30/0x50
? \_\_pfx\_kthread+0x10/0x10
ret\_from\_fork\_asm+0x1a/0x30
</TASK>
Modules linked in: dm\_mod btrfs blake2b\_generic xor raid6\_pq rapl
CR2: 0000000000000020
\* Case 2. Earlier completion of orig\_bbio for mirrored btrfs\_bios
btrfs\_bbio\_propagate\_error() assumes the end\_io function for orig\_bbio is
called last among split bios. In that case, btrfs\_orig\_write\_end\_io() sets
the bio->bi\_status to BLK\_STS\_IOERR by seeing the bioc->error [2].
Otherwise, the increased orig\_bio's bioc->error is not checked by anyone
and return BLK\_STS\_OK to the upper layer.
[2] Actually, this is not true. Because we only increases orig\_bioc->errors
by max\_errors, the condition "atomic\_read(&bioc->error) > bioc->max\_errors"
is still not met if only one split btrfs\_bio fails.
\* Case 3. Later completion of orig\_bbio for un-mirrored btrfs\_bios
In contrast to the above case, btrfs\_bbio\_propagate\_error() is not working
well if un-mirrored orig\_bbio is completed last. It sets
orig\_bbio->bio.bi\_status to the btrfs\_bio's error. But, that is easily
over-written by orig\_bbio's completion status. If the status is BLK\_STS\_OK,
the upper layer would not know the failure.
\* Solution
Considering the above cases, we can only save the error status in the
orig\_bbio (remaining part after split) itself as it is always
available. Also, the saved error status should be propagated when all the
split btrfs\_bios are finished (i.e, bbio->pending\_ios == 0).
This commit introduces "status" to btrfs\_bbio and saves the first error of
split bios to original btrfs\_bio's "status" variable. When all the split
bios are finished, the saved status is loaded into original btrfs\_bio's
status.
With this commit, btrfs/146 on zoned devices does not hit the NULL pointer
dereference anymore.
Fixes: 852eee62d31a ("btrfs: allow btrfs\_submit\_bio to split bios")
CC: stable@vger.kernel.org # 6.6+
Reviewed-by: Qu Wenruo <wqu@suse.com>
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
Signed-off-by: Naohiro Aota <naohiro.aota@wdc.com>
Signed-off-by: David Sterba <dsterba@suse.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d48e1dea3931de64c26717adc2b89743c7ab6594)

| -rw-r--r-- | [fs/btrfs/bio.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/bio.c?id=d48e1dea3931de64c26717adc2b89743c7ab6594) | 37 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/btrfs/bio.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/bio.h?id=d48e1dea3931de64c26717adc2b89743c7ab6594) | 3 | |  |  |  | | --- | --- | --- | |

2 files changed, 16 insertions, 24 deletions

| diff --git a/fs/btrfs/bio.c b/fs/btrfs/bio.cindex ce13416bc10f03..f83ec5a1baa604 100644--- a/[fs/btrfs/bio.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/bio.c?id=90a88784cdb7757feb8dd520255e6cb861f30943)+++ b/[fs/btrfs/bio.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/bio.c?id=d48e1dea3931de64c26717adc2b89743c7ab6594)@@ -49,6 +49,7 @@ void btrfs\_bio\_init(struct btrfs\_bio \*bbio, struct btrfs\_fs\_info \*fs\_info, bbio->end\_io = end\_io; bbio->private = private; atomic\_set(&bbio->pending\_ios, 1);+ WRITE\_ONCE(bbio->status, BLK\_STS\_OK); }  /\*@@ -120,41 +121,29 @@ static void \_\_btrfs\_bio\_end\_io(struct btrfs\_bio \*bbio) } } -static void btrfs\_orig\_write\_end\_io(struct bio \*bio);--static void btrfs\_bbio\_propagate\_error(struct btrfs\_bio \*bbio,- struct btrfs\_bio \*orig\_bbio)-{- /\*- \* For writes we tolerate nr\_mirrors - 1 write failures, so we can't- \* just blindly propagate a write failure here. Instead increment the- \* error count in the original I/O context so that it is guaranteed to- \* be larger than the error tolerance.- \*/- if (bbio->bio.bi\_end\_io == &btrfs\_orig\_write\_end\_io) {- struct btrfs\_io\_stripe \*orig\_stripe = orig\_bbio->bio.bi\_private;- struct btrfs\_io\_context \*orig\_bioc = orig\_stripe->bioc;-- atomic\_add(orig\_bioc->max\_errors, &orig\_bioc->error);- } else {- orig\_bbio->bio.bi\_status = bbio->bio.bi\_status;- }-}- void btrfs\_bio\_end\_io(struct btrfs\_bio \*bbio, blk\_status\_t status) { bbio->bio.bi\_status = status; if (bbio->bio.bi\_pool == &btrfs\_clone\_bioset) { struct btrfs\_bio \*orig\_bbio = bbio->private; - if (bbio->bio.bi\_status)- btrfs\_bbio\_propagate\_error(bbio, orig\_bbio); btrfs\_cleanup\_bio(bbio); bbio = orig\_bbio; } - if (atomic\_dec\_and\_test(&bbio->pending\_ios))+ /\*+ \* At this point, bbio always points to the original btrfs\_bio. Save+ \* the first error in it.+ \*/+ if (status != BLK\_STS\_OK)+ cmpxchg(&bbio->status, BLK\_STS\_OK, status);++ if (atomic\_dec\_and\_test(&bbio->pending\_ios)) {+ /\* Load split bio's error which might be set above. \*/+ if (status == BLK\_STS\_OK)+ bbio->bio.bi\_status = READ\_ONCE(bbio->status); \_\_btrfs\_bio\_end\_io(bbio);+ } }  static int next\_repair\_mirror(struct btrfs\_failed\_bio \*fbio, int cur\_mirror)diff --git a/fs/btrfs/bio.h b/fs/btrfs/bio.hindex e4861234074588..e2fe16074ad655 100644--- a/[fs/btrfs/bio.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/bio.h?id=90a88784cdb7757feb8dd520255e6cb861f30943)+++ b/[fs/btrfs/bio.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/bio.h?id=d48e1dea3931de64c26717adc2b89743c7ab6594)@@ -79,6 +79,9 @@ struct btrfs\_bio { /\* File system that this I/O operates on. \*/ struct btrfs\_fs\_info \*fs\_info; + /\* Save the first error status of split bio. \*/+ blk\_status\_t status;+ /\* \* This member must come last, bio\_alloc\_bioset will allocate enough \* bytes for entire btrfs\_bio but relies on bio being last. |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 20:37:04 +0000


