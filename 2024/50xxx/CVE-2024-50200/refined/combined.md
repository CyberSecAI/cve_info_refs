=== Content from git.kernel.org_2f510c6f_20250115_094056.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=7c7874977da9e47ca0f53d8b9a5b17385fed83f2)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7c7874977da9e47ca0f53d8b9a5b17385fed83f2)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7c7874977da9e47ca0f53d8b9a5b17385fed83f2)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7c7874977da9e47ca0f53d8b9a5b17385fed83f2)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Lorenzo Stoakes <lorenzo.stoakes@oracle.com> | 2024-10-07 16:28:32 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-22 15:56:44 +0200 |
| commit | [7c7874977da9e47ca0f53d8b9a5b17385fed83f2](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7c7874977da9e47ca0f53d8b9a5b17385fed83f2) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=7c7874977da9e47ca0f53d8b9a5b17385fed83f2)) | |
| tree | [95bbfc8990ec97001b47eb2ea1cb17b63f455427](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7c7874977da9e47ca0f53d8b9a5b17385fed83f2) | |
| parent | [eff23e59b7871eba63de916a3c9f091cae2253a0](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=eff23e59b7871eba63de916a3c9f091cae2253a0) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7c7874977da9e47ca0f53d8b9a5b17385fed83f2&id2=eff23e59b7871eba63de916a3c9f091cae2253a0)) | |
| download | [linux-7c7874977da9e47ca0f53d8b9a5b17385fed83f2.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-7c7874977da9e47ca0f53d8b9a5b17385fed83f2.tar.gz) | |

maple\_tree: correct tree corruption on spanning storecommit bea07fd63192b61209d48cbb81ef474cc3ee4c62 upstream.
Patch series "maple\_tree: correct tree corruption on spanning store", v3.
There has been a nasty yet subtle maple tree corruption bug that appears
to have been in existence since the inception of the algorithm.
This bug seems far more likely to happen since commit f8d112a4e657
("mm/mmap: avoid zeroing vma tree in mmap\_region()"), which is the point
at which reports started to be submitted concerning this bug.
We were made definitely aware of the bug thanks to the kind efforts of
Bert Karwatzki who helped enormously in my being able to track this down
and identify the cause of it.
The bug arises when an attempt is made to perform a spanning store across
two leaf nodes, where the right leaf node is the rightmost child of the
shared parent, AND the store completely consumes the right-mode node.
This results in mas\_wr\_spanning\_store() mitakenly duplicating the new and
existing entries at the maximum pivot within the range, and thus maple
tree corruption.
The fix patch corrects this by detecting this scenario and disallowing the
mistaken duplicate copy.
The fix patch commit message goes into great detail as to how this occurs.
This series also includes a test which reliably reproduces the issue, and
asserts that the fix works correctly.
Bert has kindly tested the fix and confirmed it resolved his issues. Also
Mikhail Gavrilov kindly reported what appears to be precisely the same
bug, which this fix should also resolve.
This patch (of 2):
There has been a subtle bug present in the maple tree implementation from
its inception.
This arises from how stores are performed - when a store occurs, it will
overwrite overlapping ranges and adjust the tree as necessary to
accommodate this.
A range may always ultimately span two leaf nodes. In this instance we
walk the two leaf nodes, determine which elements are not overwritten to
the left and to the right of the start and end of the ranges respectively
and then rebalance the tree to contain these entries and the newly
inserted one.
This kind of store is dubbed a 'spanning store' and is implemented by
mas\_wr\_spanning\_store().
In order to reach this stage, mas\_store\_gfp() invokes
mas\_wr\_preallocate(), mas\_wr\_store\_type() and mas\_wr\_walk() in turn to
walk the tree and update the object (mas) to traverse to the location
where the write should be performed, determining its store type.
When a spanning store is required, this function returns false stopping at
the parent node which contains the target range, and mas\_wr\_store\_type()
marks the mas->store\_type as wr\_spanning\_store to denote this fact.
When we go to perform the store in mas\_wr\_spanning\_store(), we first
determine the elements AFTER the END of the range we wish to store (that
is, to the right of the entry to be inserted) - we do this by walking to
the NEXT pivot in the tree (i.e. r\_mas.last + 1), starting at the node we
have just determined contains the range over which we intend to write.
We then turn our attention to the entries to the left of the entry we are
inserting, whose state is represented by l\_mas, and copy these into a 'big
node', which is a special node which contains enough slots to contain two
leaf node's worth of data.
We then copy the entry we wish to store immediately after this - the copy
and the insertion of the new entry is performed by mas\_store\_b\_node().
After this we copy the elements to the right of the end of the range which
we are inserting, if we have not exceeded the length of the node (i.e.
r\_mas.offset <= r\_mas.end).
Herein lies the bug - under very specific circumstances, this logic can
break and corrupt the maple tree.
Consider the following tree:
Height
0 Root Node
/ \
pivot = 0xffff / \ pivot = ULONG\_MAX
/ \
1 A [-----] ...
/ \
pivot = 0x4fff / \ pivot = 0xffff
/ \
2 (LEAVES) B [-----] [-----] C
^--- Last pivot 0xffff.
Now imagine we wish to store an entry in the range [0x4000, 0xffff] (note
that all ranges expressed in maple tree code are inclusive):
1. mas\_store\_gfp() descends the tree, finds node A at <=0xffff, then
determines that this is a spanning store across nodes B and C. The mas
state is set such that the current node from which we traverse further
is node A.
2. In mas\_wr\_spanning\_store() we try to find elements to the right of pivot
0xffff by searching for an index of 0x10000:
- mas\_wr\_walk\_index() invokes mas\_wr\_walk\_descend() and
mas\_wr\_node\_walk() in turn.
- mas\_wr\_node\_walk() loops over entries in node A until EITHER it
finds an entry whose pivot equals or exceeds 0x10000 OR it
reaches the final entry.
- Since no entry has a pivot equal to or exceeding 0x10000, pivot
0xffff is selected, leading to node C.
- mas\_wr\_walk\_traverse() resets the mas state to traverse node C. We
loop around and invoke mas\_wr\_walk\_descend() and mas\_wr\_node\_walk()
in turn once again.
- Again, we reach the last entry in node C, which has a pivot of
0xffff.
3. We then copy the elements to the left of 0x4000 in node B to the big
node via mas\_store\_b\_node(), and insert the new [0x4000, 0xffff] entry
too.
4. We determine whether we have any entries to copy from the right of the
end of the range via - and with r\_mas set up at the entry at pivot
0xffff, r\_mas.offset <= r\_mas.end, and then we DUPLICATE the entry at
pivot 0xffff.
5. BUG! The maple tree is corrupted with a duplicate entry.
This requires a very specific set of circumstances - we must be spanning
the last element in a leaf node, which is the last element in the parent
node.
spanning store across two leaf nodes with a range that ends at that shared
pivot.
A potential solution to this problem would simply be to reset the walk
each time we traverse r\_mas, however given the rarity of this situation it
seems that would be rather inefficient.
Instead, this patch detects if the right hand node is populated, i.e. has
anything we need to copy.
We do so by only copying elements from the right of the entry being
inserted when the maximum value present exceeds the last, rather than
basing this on offset position.
The patch also updates some comments and eliminates the unused bool return
value in mas\_wr\_walk\_index().
The work performed in commit f8d112a4e657 ("mm/mmap: avoid zeroing vma
tree in mmap\_region()") seems to have made the probability of this event
much more likely, which is the point at which reports started to be
submitted concerning this bug.
The motivation for this change arose from Bert Karwatzki's report of
encountering mm instability after the release of kernel v6.12-rc1 which,
after the use of CONFIG\_DEBUG\_VM\_MAPLE\_TREE and similar configuration
options, was identified as maple tree corruption.
After Bert very generously provided his time and ability to reproduce this
event consistently, I was able to finally identify that the issue
discussed in this commit message was occurring for him.
Link: [https://lkml.kernel.org/r/cover.1728314402.git.lorenzo.stoakes@oracle.com](https://lkml.kernel.org/r/cover.1728314402.git.lorenzo.stoakes%40oracle.com)
Link: [https://lkml.kernel.org/r/48b349a2a0f7c76e18772712d0997a5e12ab0a3b.1728314403.git.lorenzo.stoakes@oracle.com](https://lkml.kernel.org/r/48b349a2a0f7c76e18772712d0997a5e12ab0a3b.1728314403.git.lorenzo.stoakes%40oracle.com)
Fixes: 54a611b60590 ("Maple Tree: add new data structure")
Signed-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
Reported-by: Bert Karwatzki <spasswolf@web.de>
Closes: https://lore.kernel.org/all/20241001023402.3374-1-spasswolf@web.de/
Tested-by: Bert Karwatzki <spasswolf@web.de>
Reported-by: Mikhail Gavrilov <mikhail.v.gavrilov@gmail.com>
Closes: https://lore.kernel.org/all/CABXGCsOPwuoNOqSMmAvWO2Fz4TEmPnjFj-b7iF+XFRu1h7-+Dg@mail.gmail.com/
Acked-by: Vlastimil Babka <vbabka@suse.cz>
Reviewed-by: Liam R. Howlett <Liam.Howlett@Oracle.com>
Tested-by: Mikhail Gavrilov <mikhail.v.gavrilov@gmail.com>
Reviewed-by: Wei Yang <richard.weiyang@gmail.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Sidhartha Kumar <sidhartha.kumar@oracle.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7c7874977da9e47ca0f53d8b9a5b17385fed83f2)

| -rw-r--r-- | [lib/maple\_tree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/lib/maple_tree.c?id=7c7874977da9e47ca0f53d8b9a5b17385fed83f2) | 12 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 6 insertions, 6 deletions

| diff --git a/lib/maple\_tree.c b/lib/maple\_tree.cindex 9a5bdf1e8e92a0..ae8ae9470066ef 100644--- a/[lib/maple\_tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/maple_tree.c?id=eff23e59b7871eba63de916a3c9f091cae2253a0)+++ b/[lib/maple\_tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/maple_tree.c?id=7c7874977da9e47ca0f53d8b9a5b17385fed83f2)@@ -2298,6 +2298,8 @@ static inline struct maple\_enode \*mte\_node\_or\_none(struct maple\_enode \*enode)  /\* \* mas\_wr\_node\_walk() - Find the correct offset for the index in the @mas.+ \* If @mas->index cannot be found within the containing+ \* node, we traverse to the last entry in the node. \* @wr\_mas: The maple write state \* \* Uses mas\_slot\_locked() and does not need to worry about dead nodes.@@ -3831,7 +3833,7 @@ static bool mas\_wr\_walk(struct ma\_wr\_state \*wr\_mas) return true; } -static bool mas\_wr\_walk\_index(struct ma\_wr\_state \*wr\_mas)+static void mas\_wr\_walk\_index(struct ma\_wr\_state \*wr\_mas) { struct ma\_state \*mas = wr\_mas->mas; @@ -3840,11 +3842,9 @@ static bool mas\_wr\_walk\_index(struct ma\_wr\_state \*wr\_mas) wr\_mas->content = mas\_slot\_locked(mas, wr\_mas->slots, mas->offset); if (ma\_is\_leaf(wr\_mas->type))- return true;+ return; mas\_wr\_walk\_traverse(wr\_mas);- }- return true; } /\* \* mas\_extend\_spanning\_null() - Extend a store of a %NULL to include surrounding %NULLs.@@ -4081,8 +4081,8 @@ static inline int mas\_wr\_spanning\_store(struct ma\_wr\_state \*wr\_mas) memset(&b\_node, 0, sizeof(struct maple\_big\_node)); /\* Copy l\_mas and store the value in b\_node. \*/ mas\_store\_b\_node(&l\_wr\_mas, &b\_node, l\_wr\_mas.node\_end);- /\* Copy r\_mas into b\_node. \*/- if (r\_mas.offset <= r\_wr\_mas.node\_end)+ /\* Copy r\_mas into b\_node if there is anything to copy. \*/+ if (r\_mas.max > r\_mas.last) mas\_mab\_cp(&r\_mas, r\_mas.offset, r\_wr\_mas.node\_end, &b\_node, b\_node.b\_end + 1); else |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 09:39:33 +0000



=== Content from git.kernel.org_069ab75a_20250115_094058.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=982dd0d26d1f015ed34866579480d2be5250b0ef)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=982dd0d26d1f015ed34866579480d2be5250b0ef)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=982dd0d26d1f015ed34866579480d2be5250b0ef)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=982dd0d26d1f015ed34866579480d2be5250b0ef)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Lorenzo Stoakes <lorenzo.stoakes@oracle.com> | 2024-10-07 16:28:32 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-22 15:51:20 +0200 |
| commit | [982dd0d26d1f015ed34866579480d2be5250b0ef](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=982dd0d26d1f015ed34866579480d2be5250b0ef) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=982dd0d26d1f015ed34866579480d2be5250b0ef)) | |
| tree | [362c02657eda658b5862a942bb12a068daaf4324](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=982dd0d26d1f015ed34866579480d2be5250b0ef) | |
| parent | [a304a394be0ccb2ef1d356e499391118173b19c4](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a304a394be0ccb2ef1d356e499391118173b19c4) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=982dd0d26d1f015ed34866579480d2be5250b0ef&id2=a304a394be0ccb2ef1d356e499391118173b19c4)) | |
| download | [linux-982dd0d26d1f015ed34866579480d2be5250b0ef.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-982dd0d26d1f015ed34866579480d2be5250b0ef.tar.gz) | |

maple\_tree: correct tree corruption on spanning storecommit bea07fd63192b61209d48cbb81ef474cc3ee4c62 upstream.
Patch series "maple\_tree: correct tree corruption on spanning store", v3.
There has been a nasty yet subtle maple tree corruption bug that appears
to have been in existence since the inception of the algorithm.
This bug seems far more likely to happen since commit f8d112a4e657
("mm/mmap: avoid zeroing vma tree in mmap\_region()"), which is the point
at which reports started to be submitted concerning this bug.
We were made definitely aware of the bug thanks to the kind efforts of
Bert Karwatzki who helped enormously in my being able to track this down
and identify the cause of it.
The bug arises when an attempt is made to perform a spanning store across
two leaf nodes, where the right leaf node is the rightmost child of the
shared parent, AND the store completely consumes the right-mode node.
This results in mas\_wr\_spanning\_store() mitakenly duplicating the new and
existing entries at the maximum pivot within the range, and thus maple
tree corruption.
The fix patch corrects this by detecting this scenario and disallowing the
mistaken duplicate copy.
The fix patch commit message goes into great detail as to how this occurs.
This series also includes a test which reliably reproduces the issue, and
asserts that the fix works correctly.
Bert has kindly tested the fix and confirmed it resolved his issues. Also
Mikhail Gavrilov kindly reported what appears to be precisely the same
bug, which this fix should also resolve.
This patch (of 2):
There has been a subtle bug present in the maple tree implementation from
its inception.
This arises from how stores are performed - when a store occurs, it will
overwrite overlapping ranges and adjust the tree as necessary to
accommodate this.
A range may always ultimately span two leaf nodes. In this instance we
walk the two leaf nodes, determine which elements are not overwritten to
the left and to the right of the start and end of the ranges respectively
and then rebalance the tree to contain these entries and the newly
inserted one.
This kind of store is dubbed a 'spanning store' and is implemented by
mas\_wr\_spanning\_store().
In order to reach this stage, mas\_store\_gfp() invokes
mas\_wr\_preallocate(), mas\_wr\_store\_type() and mas\_wr\_walk() in turn to
walk the tree and update the object (mas) to traverse to the location
where the write should be performed, determining its store type.
When a spanning store is required, this function returns false stopping at
the parent node which contains the target range, and mas\_wr\_store\_type()
marks the mas->store\_type as wr\_spanning\_store to denote this fact.
When we go to perform the store in mas\_wr\_spanning\_store(), we first
determine the elements AFTER the END of the range we wish to store (that
is, to the right of the entry to be inserted) - we do this by walking to
the NEXT pivot in the tree (i.e. r\_mas.last + 1), starting at the node we
have just determined contains the range over which we intend to write.
We then turn our attention to the entries to the left of the entry we are
inserting, whose state is represented by l\_mas, and copy these into a 'big
node', which is a special node which contains enough slots to contain two
leaf node's worth of data.
We then copy the entry we wish to store immediately after this - the copy
and the insertion of the new entry is performed by mas\_store\_b\_node().
After this we copy the elements to the right of the end of the range which
we are inserting, if we have not exceeded the length of the node (i.e.
r\_mas.offset <= r\_mas.end).
Herein lies the bug - under very specific circumstances, this logic can
break and corrupt the maple tree.
Consider the following tree:
Height
0 Root Node
/ \
pivot = 0xffff / \ pivot = ULONG\_MAX
/ \
1 A [-----] ...
/ \
pivot = 0x4fff / \ pivot = 0xffff
/ \
2 (LEAVES) B [-----] [-----] C
^--- Last pivot 0xffff.
Now imagine we wish to store an entry in the range [0x4000, 0xffff] (note
that all ranges expressed in maple tree code are inclusive):
1. mas\_store\_gfp() descends the tree, finds node A at <=0xffff, then
determines that this is a spanning store across nodes B and C. The mas
state is set such that the current node from which we traverse further
is node A.
2. In mas\_wr\_spanning\_store() we try to find elements to the right of pivot
0xffff by searching for an index of 0x10000:
- mas\_wr\_walk\_index() invokes mas\_wr\_walk\_descend() and
mas\_wr\_node\_walk() in turn.
- mas\_wr\_node\_walk() loops over entries in node A until EITHER it
finds an entry whose pivot equals or exceeds 0x10000 OR it
reaches the final entry.
- Since no entry has a pivot equal to or exceeding 0x10000, pivot
0xffff is selected, leading to node C.
- mas\_wr\_walk\_traverse() resets the mas state to traverse node C. We
loop around and invoke mas\_wr\_walk\_descend() and mas\_wr\_node\_walk()
in turn once again.
- Again, we reach the last entry in node C, which has a pivot of
0xffff.
3. We then copy the elements to the left of 0x4000 in node B to the big
node via mas\_store\_b\_node(), and insert the new [0x4000, 0xffff] entry
too.
4. We determine whether we have any entries to copy from the right of the
end of the range via - and with r\_mas set up at the entry at pivot
0xffff, r\_mas.offset <= r\_mas.end, and then we DUPLICATE the entry at
pivot 0xffff.
5. BUG! The maple tree is corrupted with a duplicate entry.
This requires a very specific set of circumstances - we must be spanning
the last element in a leaf node, which is the last element in the parent
node.
spanning store across two leaf nodes with a range that ends at that shared
pivot.
A potential solution to this problem would simply be to reset the walk
each time we traverse r\_mas, however given the rarity of this situation it
seems that would be rather inefficient.
Instead, this patch detects if the right hand node is populated, i.e. has
anything we need to copy.
We do so by only copying elements from the right of the entry being
inserted when the maximum value present exceeds the last, rather than
basing this on offset position.
The patch also updates some comments and eliminates the unused bool return
value in mas\_wr\_walk\_index().
The work performed in commit f8d112a4e657 ("mm/mmap: avoid zeroing vma
tree in mmap\_region()") seems to have made the probability of this event
much more likely, which is the point at which reports started to be
submitted concerning this bug.
The motivation for this change arose from Bert Karwatzki's report of
encountering mm instability after the release of kernel v6.12-rc1 which,
after the use of CONFIG\_DEBUG\_VM\_MAPLE\_TREE and similar configuration
options, was identified as maple tree corruption.
After Bert very generously provided his time and ability to reproduce this
event consistently, I was able to finally identify that the issue
discussed in this commit message was occurring for him.
Link: [https://lkml.kernel.org/r/cover.1728314402.git.lorenzo.stoakes@oracle.com](https://lkml.kernel.org/r/cover.1728314402.git.lorenzo.stoakes%40oracle.com)
Link: [https://lkml.kernel.org/r/48b349a2a0f7c76e18772712d0997a5e12ab0a3b.1728314403.git.lorenzo.stoakes@oracle.com](https://lkml.kernel.org/r/48b349a2a0f7c76e18772712d0997a5e12ab0a3b.1728314403.git.lorenzo.stoakes%40oracle.com)
Fixes: 54a611b60590 ("Maple Tree: add new data structure")
Signed-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
Reported-by: Bert Karwatzki <spasswolf@web.de>
Closes: https://lore.kernel.org/all/20241001023402.3374-1-spasswolf@web.de/
Tested-by: Bert Karwatzki <spasswolf@web.de>
Reported-by: Mikhail Gavrilov <mikhail.v.gavrilov@gmail.com>
Closes: https://lore.kernel.org/all/CABXGCsOPwuoNOqSMmAvWO2Fz4TEmPnjFj-b7iF+XFRu1h7-+Dg@mail.gmail.com/
Acked-by: Vlastimil Babka <vbabka@suse.cz>
Reviewed-by: Liam R. Howlett <Liam.Howlett@Oracle.com>
Tested-by: Mikhail Gavrilov <mikhail.v.gavrilov@gmail.com>
Reviewed-by: Wei Yang <richard.weiyang@gmail.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Sidhartha Kumar <sidhartha.kumar@oracle.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=982dd0d26d1f015ed34866579480d2be5250b0ef)

| -rw-r--r-- | [lib/maple\_tree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/lib/maple_tree.c?id=982dd0d26d1f015ed34866579480d2be5250b0ef) | 12 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 6 insertions, 6 deletions

| diff --git a/lib/maple\_tree.c b/lib/maple\_tree.cindex 6df3a8b95808ab..20f6f7ae937272 100644--- a/[lib/maple\_tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/maple_tree.c?id=a304a394be0ccb2ef1d356e499391118173b19c4)+++ b/[lib/maple\_tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/maple_tree.c?id=982dd0d26d1f015ed34866579480d2be5250b0ef)@@ -2196,6 +2196,8 @@ static inline void mas\_node\_or\_none(struct ma\_state \*mas,  /\* \* mas\_wr\_node\_walk() - Find the correct offset for the index in the @mas.+ \* If @mas->index cannot be found within the containing+ \* node, we traverse to the last entry in the node. \* @wr\_mas: The maple write state \* \* Uses mas\_slot\_locked() and does not need to worry about dead nodes.@@ -3609,7 +3611,7 @@ static bool mas\_wr\_walk(struct ma\_wr\_state \*wr\_mas) return true; } -static bool mas\_wr\_walk\_index(struct ma\_wr\_state \*wr\_mas)+static void mas\_wr\_walk\_index(struct ma\_wr\_state \*wr\_mas) { struct ma\_state \*mas = wr\_mas->mas; @@ -3618,11 +3620,9 @@ static bool mas\_wr\_walk\_index(struct ma\_wr\_state \*wr\_mas) wr\_mas->content = mas\_slot\_locked(mas, wr\_mas->slots, mas->offset); if (ma\_is\_leaf(wr\_mas->type))- return true;+ return; mas\_wr\_walk\_traverse(wr\_mas);- }- return true; } /\* \* mas\_extend\_spanning\_null() - Extend a store of a %NULL to include surrounding %NULLs.@@ -3853,8 +3853,8 @@ static inline int mas\_wr\_spanning\_store(struct ma\_wr\_state \*wr\_mas) memset(&b\_node, 0, sizeof(struct maple\_big\_node)); /\* Copy l\_mas and store the value in b\_node. \*/ mas\_store\_b\_node(&l\_wr\_mas, &b\_node, l\_mas.end);- /\* Copy r\_mas into b\_node. \*/- if (r\_mas.offset <= r\_mas.end)+ /\* Copy r\_mas into b\_node if there is anything to copy. \*/+ if (r\_mas.max > r\_mas.last) mas\_mab\_cp(&r\_mas, r\_mas.offset, r\_mas.end, &b\_node, b\_node.b\_end + 1); else |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 09:39:35 +0000



=== Content from git.kernel.org_76d14b73_20250115_094059.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=bea07fd63192b61209d48cbb81ef474cc3ee4c62)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=bea07fd63192b61209d48cbb81ef474cc3ee4c62)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bea07fd63192b61209d48cbb81ef474cc3ee4c62)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=bea07fd63192b61209d48cbb81ef474cc3ee4c62)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Lorenzo Stoakes <lorenzo.stoakes@oracle.com> | 2024-10-07 16:28:32 +0100 |
| --- | --- | --- |
| committer | Andrew Morton <akpm@linux-foundation.org> | 2024-10-17 08:35:10 -0700 |
| commit | [bea07fd63192b61209d48cbb81ef474cc3ee4c62](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bea07fd63192b61209d48cbb81ef474cc3ee4c62) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=bea07fd63192b61209d48cbb81ef474cc3ee4c62)) | |
| tree | [0d4101c73fc1f87600d0a568054839cae1265446](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=bea07fd63192b61209d48cbb81ef474cc3ee4c62) | |
| parent | [b130ba4a6259f6b64d8af15e9e7ab1e912bcb7ad](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b130ba4a6259f6b64d8af15e9e7ab1e912bcb7ad) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=bea07fd63192b61209d48cbb81ef474cc3ee4c62&id2=b130ba4a6259f6b64d8af15e9e7ab1e912bcb7ad)) | |
| download | [linux-bea07fd63192b61209d48cbb81ef474cc3ee4c62.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-bea07fd63192b61209d48cbb81ef474cc3ee4c62.tar.gz) | |

maple\_tree: correct tree corruption on spanning storePatch series "maple\_tree: correct tree corruption on spanning store", v3.
There has been a nasty yet subtle maple tree corruption bug that appears
to have been in existence since the inception of the algorithm.
This bug seems far more likely to happen since commit f8d112a4e657
("mm/mmap: avoid zeroing vma tree in mmap\_region()"), which is the point
at which reports started to be submitted concerning this bug.
We were made definitely aware of the bug thanks to the kind efforts of
Bert Karwatzki who helped enormously in my being able to track this down
and identify the cause of it.
The bug arises when an attempt is made to perform a spanning store across
two leaf nodes, where the right leaf node is the rightmost child of the
shared parent, AND the store completely consumes the right-mode node.
This results in mas\_wr\_spanning\_store() mitakenly duplicating the new and
existing entries at the maximum pivot within the range, and thus maple
tree corruption.
The fix patch corrects this by detecting this scenario and disallowing the
mistaken duplicate copy.
The fix patch commit message goes into great detail as to how this occurs.
This series also includes a test which reliably reproduces the issue, and
asserts that the fix works correctly.
Bert has kindly tested the fix and confirmed it resolved his issues. Also
Mikhail Gavrilov kindly reported what appears to be precisely the same
bug, which this fix should also resolve.
This patch (of 2):
There has been a subtle bug present in the maple tree implementation from
its inception.
This arises from how stores are performed - when a store occurs, it will
overwrite overlapping ranges and adjust the tree as necessary to
accommodate this.
A range may always ultimately span two leaf nodes. In this instance we
walk the two leaf nodes, determine which elements are not overwritten to
the left and to the right of the start and end of the ranges respectively
and then rebalance the tree to contain these entries and the newly
inserted one.
This kind of store is dubbed a 'spanning store' and is implemented by
mas\_wr\_spanning\_store().
In order to reach this stage, mas\_store\_gfp() invokes
mas\_wr\_preallocate(), mas\_wr\_store\_type() and mas\_wr\_walk() in turn to
walk the tree and update the object (mas) to traverse to the location
where the write should be performed, determining its store type.
When a spanning store is required, this function returns false stopping at
the parent node which contains the target range, and mas\_wr\_store\_type()
marks the mas->store\_type as wr\_spanning\_store to denote this fact.
When we go to perform the store in mas\_wr\_spanning\_store(), we first
determine the elements AFTER the END of the range we wish to store (that
is, to the right of the entry to be inserted) - we do this by walking to
the NEXT pivot in the tree (i.e. r\_mas.last + 1), starting at the node we
have just determined contains the range over which we intend to write.
We then turn our attention to the entries to the left of the entry we are
inserting, whose state is represented by l\_mas, and copy these into a 'big
node', which is a special node which contains enough slots to contain two
leaf node's worth of data.
We then copy the entry we wish to store immediately after this - the copy
and the insertion of the new entry is performed by mas\_store\_b\_node().
After this we copy the elements to the right of the end of the range which
we are inserting, if we have not exceeded the length of the node (i.e.
r\_mas.offset <= r\_mas.end).
Herein lies the bug - under very specific circumstances, this logic can
break and corrupt the maple tree.
Consider the following tree:
Height
0 Root Node
/ \
pivot = 0xffff / \ pivot = ULONG\_MAX
/ \
1 A [-----] ...
/ \
pivot = 0x4fff / \ pivot = 0xffff
/ \
2 (LEAVES) B [-----] [-----] C
^--- Last pivot 0xffff.
Now imagine we wish to store an entry in the range [0x4000, 0xffff] (note
that all ranges expressed in maple tree code are inclusive):
1. mas\_store\_gfp() descends the tree, finds node A at <=0xffff, then
determines that this is a spanning store across nodes B and C. The mas
state is set such that the current node from which we traverse further
is node A.
2. In mas\_wr\_spanning\_store() we try to find elements to the right of pivot
0xffff by searching for an index of 0x10000:
- mas\_wr\_walk\_index() invokes mas\_wr\_walk\_descend() and
mas\_wr\_node\_walk() in turn.
- mas\_wr\_node\_walk() loops over entries in node A until EITHER it
finds an entry whose pivot equals or exceeds 0x10000 OR it
reaches the final entry.
- Since no entry has a pivot equal to or exceeding 0x10000, pivot
0xffff is selected, leading to node C.
- mas\_wr\_walk\_traverse() resets the mas state to traverse node C. We
loop around and invoke mas\_wr\_walk\_descend() and mas\_wr\_node\_walk()
in turn once again.
- Again, we reach the last entry in node C, which has a pivot of
0xffff.
3. We then copy the elements to the left of 0x4000 in node B to the big
node via mas\_store\_b\_node(), and insert the new [0x4000, 0xffff] entry
too.
4. We determine whether we have any entries to copy from the right of the
end of the range via - and with r\_mas set up at the entry at pivot
0xffff, r\_mas.offset <= r\_mas.end, and then we DUPLICATE the entry at
pivot 0xffff.
5. BUG! The maple tree is corrupted with a duplicate entry.
This requires a very specific set of circumstances - we must be spanning
the last element in a leaf node, which is the last element in the parent
node.
spanning store across two leaf nodes with a range that ends at that shared
pivot.
A potential solution to this problem would simply be to reset the walk
each time we traverse r\_mas, however given the rarity of this situation it
seems that would be rather inefficient.
Instead, this patch detects if the right hand node is populated, i.e. has
anything we need to copy.
We do so by only copying elements from the right of the entry being
inserted when the maximum value present exceeds the last, rather than
basing this on offset position.
The patch also updates some comments and eliminates the unused bool return
value in mas\_wr\_walk\_index().
The work performed in commit f8d112a4e657 ("mm/mmap: avoid zeroing vma
tree in mmap\_region()") seems to have made the probability of this event
much more likely, which is the point at which reports started to be
submitted concerning this bug.
The motivation for this change arose from Bert Karwatzki's report of
encountering mm instability after the release of kernel v6.12-rc1 which,
after the use of CONFIG\_DEBUG\_VM\_MAPLE\_TREE and similar configuration
options, was identified as maple tree corruption.
After Bert very generously provided his time and ability to reproduce this
event consistently, I was able to finally identify that the issue
discussed in this commit message was occurring for him.
Link: [https://lkml.kernel.org/r/cover.1728314402.git.lorenzo.stoakes@oracle.com](https://lkml.kernel.org/r/cover.1728314402.git.lorenzo.stoakes%40oracle.com)
Link: [https://lkml.kernel.org/r/48b349a2a0f7c76e18772712d0997a5e12ab0a3b.1728314403.git.lorenzo.stoakes@oracle.com](https://lkml.kernel.org/r/48b349a2a0f7c76e18772712d0997a5e12ab0a3b.1728314403.git.lorenzo.stoakes%40oracle.com)
Fixes: 54a611b60590 ("Maple Tree: add new data structure")
Signed-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
Reported-by: Bert Karwatzki <spasswolf@web.de>
Closes: https://lore.kernel.org/all/20241001023402.3374-1-spasswolf@web.de/
Tested-by: Bert Karwatzki <spasswolf@web.de>
Reported-by: Mikhail Gavrilov <mikhail.v.gavrilov@gmail.com>
Closes: https://lore.kernel.org/all/CABXGCsOPwuoNOqSMmAvWO2Fz4TEmPnjFj-b7iF+XFRu1h7-+Dg@mail.gmail.com/
Acked-by: Vlastimil Babka <vbabka@suse.cz>
Reviewed-by: Liam R. Howlett <Liam.Howlett@Oracle.com>
Tested-by: Mikhail Gavrilov <mikhail.v.gavrilov@gmail.com>
Reviewed-by: Wei Yang <richard.weiyang@gmail.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Sidhartha Kumar <sidhartha.kumar@oracle.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=bea07fd63192b61209d48cbb81ef474cc3ee4c62)

| -rw-r--r-- | [lib/maple\_tree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/lib/maple_tree.c?id=bea07fd63192b61209d48cbb81ef474cc3ee4c62) | 12 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 6 insertions, 6 deletions

| diff --git a/lib/maple\_tree.c b/lib/maple\_tree.cindex ce7c7a7a8258fd..3619301dda2ebe 100644--- a/[lib/maple\_tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/maple_tree.c?id=b130ba4a6259f6b64d8af15e9e7ab1e912bcb7ad)+++ b/[lib/maple\_tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/maple_tree.c?id=bea07fd63192b61209d48cbb81ef474cc3ee4c62)@@ -2196,6 +2196,8 @@ static inline void mas\_node\_or\_none(struct ma\_state \*mas,  /\* \* mas\_wr\_node\_walk() - Find the correct offset for the index in the @mas.+ \* If @mas->index cannot be found within the containing+ \* node, we traverse to the last entry in the node. \* @wr\_mas: The maple write state \* \* Uses mas\_slot\_locked() and does not need to worry about dead nodes.@@ -3532,7 +3534,7 @@ static bool mas\_wr\_walk(struct ma\_wr\_state \*wr\_mas) return true; } -static bool mas\_wr\_walk\_index(struct ma\_wr\_state \*wr\_mas)+static void mas\_wr\_walk\_index(struct ma\_wr\_state \*wr\_mas) { struct ma\_state \*mas = wr\_mas->mas; @@ -3541,11 +3543,9 @@ static bool mas\_wr\_walk\_index(struct ma\_wr\_state \*wr\_mas) wr\_mas->content = mas\_slot\_locked(mas, wr\_mas->slots, mas->offset); if (ma\_is\_leaf(wr\_mas->type))- return true;+ return; mas\_wr\_walk\_traverse(wr\_mas);- }- return true; } /\* \* mas\_extend\_spanning\_null() - Extend a store of a %NULL to include surrounding %NULLs.@@ -3765,8 +3765,8 @@ static noinline void mas\_wr\_spanning\_store(struct ma\_wr\_state \*wr\_mas) memset(&b\_node, 0, sizeof(struct maple\_big\_node)); /\* Copy l\_mas and store the value in b\_node. \*/ mas\_store\_b\_node(&l\_wr\_mas, &b\_node, l\_mas.end);- /\* Copy r\_mas into b\_node. \*/- if (r\_mas.offset <= r\_mas.end)+ /\* Copy r\_mas into b\_node if there is anything to copy. \*/+ if (r\_mas.max > r\_mas.last) mas\_mab\_cp(&r\_mas, r\_mas.offset, r\_mas.end, &b\_node, b\_node.b\_end + 1); else |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 09:39:35 +0000



=== Content from git.kernel.org_fe0b3d79_20250115_094055.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=677f1df179cb68c12ddf7707ec325eb50e99c7d9)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=677f1df179cb68c12ddf7707ec325eb50e99c7d9)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=677f1df179cb68c12ddf7707ec325eb50e99c7d9)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=677f1df179cb68c12ddf7707ec325eb50e99c7d9)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Lorenzo Stoakes <lorenzo.stoakes@oracle.com> | 2024-10-07 16:28:32 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-22 15:46:25 +0200 |
| commit | [677f1df179cb68c12ddf7707ec325eb50e99c7d9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=677f1df179cb68c12ddf7707ec325eb50e99c7d9) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=677f1df179cb68c12ddf7707ec325eb50e99c7d9)) | |
| tree | [b0e06440b5889780dafe80a78fd627549a34bf2a](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=677f1df179cb68c12ddf7707ec325eb50e99c7d9) | |
| parent | [9a0ab4fc28ed95d417c3b1bc287b3df8eca60332](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9a0ab4fc28ed95d417c3b1bc287b3df8eca60332) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=677f1df179cb68c12ddf7707ec325eb50e99c7d9&id2=9a0ab4fc28ed95d417c3b1bc287b3df8eca60332)) | |
| download | [linux-677f1df179cb68c12ddf7707ec325eb50e99c7d9.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-677f1df179cb68c12ddf7707ec325eb50e99c7d9.tar.gz) | |

maple\_tree: correct tree corruption on spanning storecommit bea07fd63192b61209d48cbb81ef474cc3ee4c62 upstream.
Patch series "maple\_tree: correct tree corruption on spanning store", v3.
There has been a nasty yet subtle maple tree corruption bug that appears
to have been in existence since the inception of the algorithm.
This bug seems far more likely to happen since commit f8d112a4e657
("mm/mmap: avoid zeroing vma tree in mmap\_region()"), which is the point
at which reports started to be submitted concerning this bug.
We were made definitely aware of the bug thanks to the kind efforts of
Bert Karwatzki who helped enormously in my being able to track this down
and identify the cause of it.
The bug arises when an attempt is made to perform a spanning store across
two leaf nodes, where the right leaf node is the rightmost child of the
shared parent, AND the store completely consumes the right-mode node.
This results in mas\_wr\_spanning\_store() mitakenly duplicating the new and
existing entries at the maximum pivot within the range, and thus maple
tree corruption.
The fix patch corrects this by detecting this scenario and disallowing the
mistaken duplicate copy.
The fix patch commit message goes into great detail as to how this occurs.
This series also includes a test which reliably reproduces the issue, and
asserts that the fix works correctly.
Bert has kindly tested the fix and confirmed it resolved his issues. Also
Mikhail Gavrilov kindly reported what appears to be precisely the same
bug, which this fix should also resolve.
This patch (of 2):
There has been a subtle bug present in the maple tree implementation from
its inception.
This arises from how stores are performed - when a store occurs, it will
overwrite overlapping ranges and adjust the tree as necessary to
accommodate this.
A range may always ultimately span two leaf nodes. In this instance we
walk the two leaf nodes, determine which elements are not overwritten to
the left and to the right of the start and end of the ranges respectively
and then rebalance the tree to contain these entries and the newly
inserted one.
This kind of store is dubbed a 'spanning store' and is implemented by
mas\_wr\_spanning\_store().
In order to reach this stage, mas\_store\_gfp() invokes
mas\_wr\_preallocate(), mas\_wr\_store\_type() and mas\_wr\_walk() in turn to
walk the tree and update the object (mas) to traverse to the location
where the write should be performed, determining its store type.
When a spanning store is required, this function returns false stopping at
the parent node which contains the target range, and mas\_wr\_store\_type()
marks the mas->store\_type as wr\_spanning\_store to denote this fact.
When we go to perform the store in mas\_wr\_spanning\_store(), we first
determine the elements AFTER the END of the range we wish to store (that
is, to the right of the entry to be inserted) - we do this by walking to
the NEXT pivot in the tree (i.e. r\_mas.last + 1), starting at the node we
have just determined contains the range over which we intend to write.
We then turn our attention to the entries to the left of the entry we are
inserting, whose state is represented by l\_mas, and copy these into a 'big
node', which is a special node which contains enough slots to contain two
leaf node's worth of data.
We then copy the entry we wish to store immediately after this - the copy
and the insertion of the new entry is performed by mas\_store\_b\_node().
After this we copy the elements to the right of the end of the range which
we are inserting, if we have not exceeded the length of the node (i.e.
r\_mas.offset <= r\_mas.end).
Herein lies the bug - under very specific circumstances, this logic can
break and corrupt the maple tree.
Consider the following tree:
Height
0 Root Node
/ \
pivot = 0xffff / \ pivot = ULONG\_MAX
/ \
1 A [-----] ...
/ \
pivot = 0x4fff / \ pivot = 0xffff
/ \
2 (LEAVES) B [-----] [-----] C
^--- Last pivot 0xffff.
Now imagine we wish to store an entry in the range [0x4000, 0xffff] (note
that all ranges expressed in maple tree code are inclusive):
1. mas\_store\_gfp() descends the tree, finds node A at <=0xffff, then
determines that this is a spanning store across nodes B and C. The mas
state is set such that the current node from which we traverse further
is node A.
2. In mas\_wr\_spanning\_store() we try to find elements to the right of pivot
0xffff by searching for an index of 0x10000:
- mas\_wr\_walk\_index() invokes mas\_wr\_walk\_descend() and
mas\_wr\_node\_walk() in turn.
- mas\_wr\_node\_walk() loops over entries in node A until EITHER it
finds an entry whose pivot equals or exceeds 0x10000 OR it
reaches the final entry.
- Since no entry has a pivot equal to or exceeding 0x10000, pivot
0xffff is selected, leading to node C.
- mas\_wr\_walk\_traverse() resets the mas state to traverse node C. We
loop around and invoke mas\_wr\_walk\_descend() and mas\_wr\_node\_walk()
in turn once again.
- Again, we reach the last entry in node C, which has a pivot of
0xffff.
3. We then copy the elements to the left of 0x4000 in node B to the big
node via mas\_store\_b\_node(), and insert the new [0x4000, 0xffff] entry
too.
4. We determine whether we have any entries to copy from the right of the
end of the range via - and with r\_mas set up at the entry at pivot
0xffff, r\_mas.offset <= r\_mas.end, and then we DUPLICATE the entry at
pivot 0xffff.
5. BUG! The maple tree is corrupted with a duplicate entry.
This requires a very specific set of circumstances - we must be spanning
the last element in a leaf node, which is the last element in the parent
node.
spanning store across two leaf nodes with a range that ends at that shared
pivot.
A potential solution to this problem would simply be to reset the walk
each time we traverse r\_mas, however given the rarity of this situation it
seems that would be rather inefficient.
Instead, this patch detects if the right hand node is populated, i.e. has
anything we need to copy.
We do so by only copying elements from the right of the entry being
inserted when the maximum value present exceeds the last, rather than
basing this on offset position.
The patch also updates some comments and eliminates the unused bool return
value in mas\_wr\_walk\_index().
The work performed in commit f8d112a4e657 ("mm/mmap: avoid zeroing vma
tree in mmap\_region()") seems to have made the probability of this event
much more likely, which is the point at which reports started to be
submitted concerning this bug.
The motivation for this change arose from Bert Karwatzki's report of
encountering mm instability after the release of kernel v6.12-rc1 which,
after the use of CONFIG\_DEBUG\_VM\_MAPLE\_TREE and similar configuration
options, was identified as maple tree corruption.
After Bert very generously provided his time and ability to reproduce this
event consistently, I was able to finally identify that the issue
discussed in this commit message was occurring for him.
Link: [https://lkml.kernel.org/r/cover.1728314402.git.lorenzo.stoakes@oracle.com](https://lkml.kernel.org/r/cover.1728314402.git.lorenzo.stoakes%40oracle.com)
Link: [https://lkml.kernel.org/r/48b349a2a0f7c76e18772712d0997a5e12ab0a3b.1728314403.git.lorenzo.stoakes@oracle.com](https://lkml.kernel.org/r/48b349a2a0f7c76e18772712d0997a5e12ab0a3b.1728314403.git.lorenzo.stoakes%40oracle.com)
Fixes: 54a611b60590 ("Maple Tree: add new data structure")
Signed-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
Reported-by: Bert Karwatzki <spasswolf@web.de>
Closes: https://lore.kernel.org/all/20241001023402.3374-1-spasswolf@web.de/
Tested-by: Bert Karwatzki <spasswolf@web.de>
Reported-by: Mikhail Gavrilov <mikhail.v.gavrilov@gmail.com>
Closes: https://lore.kernel.org/all/CABXGCsOPwuoNOqSMmAvWO2Fz4TEmPnjFj-b7iF+XFRu1h7-+Dg@mail.gmail.com/
Acked-by: Vlastimil Babka <vbabka@suse.cz>
Reviewed-by: Liam R. Howlett <Liam.Howlett@Oracle.com>
Tested-by: Mikhail Gavrilov <mikhail.v.gavrilov@gmail.com>
Reviewed-by: Wei Yang <richard.weiyang@gmail.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Sidhartha Kumar <sidhartha.kumar@oracle.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=677f1df179cb68c12ddf7707ec325eb50e99c7d9)

| -rw-r--r-- | [lib/maple\_tree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/lib/maple_tree.c?id=677f1df179cb68c12ddf7707ec325eb50e99c7d9) | 12 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 6 insertions, 6 deletions

| diff --git a/lib/maple\_tree.c b/lib/maple\_tree.cindex 41ef91590761b1..4e05511c8d1eba 100644--- a/[lib/maple\_tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/maple_tree.c?id=9a0ab4fc28ed95d417c3b1bc287b3df8eca60332)+++ b/[lib/maple\_tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/maple_tree.c?id=677f1df179cb68c12ddf7707ec325eb50e99c7d9)@@ -2228,6 +2228,8 @@ static inline struct maple\_enode \*mte\_node\_or\_none(struct maple\_enode \*enode)  /\* \* mas\_wr\_node\_walk() - Find the correct offset for the index in the @mas.+ \* If @mas->index cannot be found within the containing+ \* node, we traverse to the last entry in the node. \* @wr\_mas: The maple write state \* \* Uses mas\_slot\_locked() and does not need to worry about dead nodes.@@ -3643,7 +3645,7 @@ static bool mas\_wr\_walk(struct ma\_wr\_state \*wr\_mas) return true; } -static bool mas\_wr\_walk\_index(struct ma\_wr\_state \*wr\_mas)+static void mas\_wr\_walk\_index(struct ma\_wr\_state \*wr\_mas) { struct ma\_state \*mas = wr\_mas->mas; @@ -3652,11 +3654,9 @@ static bool mas\_wr\_walk\_index(struct ma\_wr\_state \*wr\_mas) wr\_mas->content = mas\_slot\_locked(mas, wr\_mas->slots, mas->offset); if (ma\_is\_leaf(wr\_mas->type))- return true;+ return; mas\_wr\_walk\_traverse(wr\_mas);- }- return true; } /\* \* mas\_extend\_spanning\_null() - Extend a store of a %NULL to include surrounding %NULLs.@@ -3892,8 +3892,8 @@ static inline int mas\_wr\_spanning\_store(struct ma\_wr\_state \*wr\_mas) memset(&b\_node, 0, sizeof(struct maple\_big\_node)); /\* Copy l\_mas and store the value in b\_node. \*/ mas\_store\_b\_node(&l\_wr\_mas, &b\_node, l\_wr\_mas.node\_end);- /\* Copy r\_mas into b\_node. \*/- if (r\_mas.offset <= r\_wr\_mas.node\_end)+ /\* Copy r\_mas into b\_node if there is anything to copy. \*/+ if (r\_mas.max > r\_mas.last) mas\_mab\_cp(&r\_mas, r\_mas.offset, r\_wr\_mas.node\_end, &b\_node, b\_node.b\_end + 1); else |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 09:39:31 +0000


