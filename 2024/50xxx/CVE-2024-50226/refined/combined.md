=== Content from git.kernel.org_5a7847dc_20250115_090525.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=8e1b52c15c81106456437f8e49575040e489e355)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=8e1b52c15c81106456437f8e49575040e489e355)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8e1b52c15c81106456437f8e49575040e489e355)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8e1b52c15c81106456437f8e49575040e489e355)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Dan Williams <dan.j.williams@intel.com> | 2024-10-22 18:43:49 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-08 16:28:24 +0100 |
| commit | [8e1b52c15c81106456437f8e49575040e489e355](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8e1b52c15c81106456437f8e49575040e489e355) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=8e1b52c15c81106456437f8e49575040e489e355)) | |
| tree | [74f37f1f284c615efc5f40bce41c739990063852](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=8e1b52c15c81106456437f8e49575040e489e355) | |
| parent | [8cd25f1fce6b8f9e20401617a4a6c19dbf956f5b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8cd25f1fce6b8f9e20401617a4a6c19dbf956f5b) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8e1b52c15c81106456437f8e49575040e489e355&id2=8cd25f1fce6b8f9e20401617a4a6c19dbf956f5b)) | |
| download | [linux-8e1b52c15c81106456437f8e49575040e489e355.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-8e1b52c15c81106456437f8e49575040e489e355.tar.gz) | |

cxl/port: Fix use-after-free, permit out-of-order decoder shutdowncommit 101c268bd2f37e965a5468353e62d154db38838e upstream.
In support of investigating an initialization failure report [1],
cxl\_test was updated to register mock memory-devices after the mock
root-port/bus device had been registered. That led to cxl\_test crashing
with a use-after-free bug with the following signature:
cxl\_port\_attach\_region: cxl region3: cxl\_host\_bridge.0:port3 decoder3.0 add: mem0:decoder7.0 @ 0 next: cxl\_switch\_uport.0 nr\_eps: 1 nr\_targets: 1
cxl\_port\_attach\_region: cxl region3: cxl\_host\_bridge.0:port3 decoder3.0 add: mem4:decoder14.0 @ 1 next: cxl\_switch\_uport.0 nr\_eps: 2 nr\_targets: 1
cxl\_port\_setup\_targets: cxl region3: cxl\_switch\_uport.0:port6 target[0] = cxl\_switch\_dport.0 for mem0:decoder7.0 @ 0
1) cxl\_port\_setup\_targets: cxl region3: cxl\_switch\_uport.0:port6 target[1] = cxl\_switch\_dport.4 for mem4:decoder14.0 @ 1
[..]
cxld\_unregister: cxl decoder14.0:
cxl\_region\_decode\_reset: cxl\_region region3:
mock\_decoder\_reset: cxl\_port port3: decoder3.0 reset
2) mock\_decoder\_reset: cxl\_port port3: decoder3.0: out of order reset, expected decoder3.1
cxl\_endpoint\_decoder\_release: cxl decoder14.0:
[..]
cxld\_unregister: cxl decoder7.0:
3) cxl\_region\_decode\_reset: cxl\_region region3:
Oops: general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6bc3: 0000 [#1] PREEMPT SMP PTI
[..]
RIP: 0010:to\_cxl\_port+0x8/0x60 [cxl\_core]
[..]
Call Trace:
<TASK>
cxl\_region\_decode\_reset+0x69/0x190 [cxl\_core]
cxl\_region\_detach+0xe8/0x210 [cxl\_core]
cxl\_decoder\_kill\_region+0x27/0x40 [cxl\_core]
cxld\_unregister+0x5d/0x60 [cxl\_core]
At 1) a region has been established with 2 endpoint decoders (7.0 and
14.0). Those endpoints share a common switch-decoder in the topology
(3.0). At teardown, 2), decoder14.0 is the first to be removed and hits
the "out of order reset case" in the switch decoder. The effect though
is that region3 cleanup is aborted leaving it in-tact and
referencing decoder14.0. At 3) the second attempt to teardown region3
trips over the stale decoder14.0 object which has long since been
deleted.
The fix here is to recognize that the CXL specification places no
mandate on in-order shutdown of switch-decoders, the driver enforces
in-order allocation, and hardware enforces in-order commit. So, rather
than fail and leave objects dangling, always remove them.
In support of making cxl\_region\_decode\_reset() always succeed,
cxl\_region\_invalidate\_memregion() failures are turned into warnings.
Crashing the kernel is ok there since system integrity is at risk if
caches cannot be managed around physical address mutation events like
CXL region destruction.
A new device\_for\_each\_child\_reverse\_from() is added to cleanup
port->commit\_end after all dependent decoders have been disabled. In
other words if decoders are allocated 0->1->2 and disabled 1->2->0 then
port->commit\_end only decrements from 2 after 2 has been disabled, and
it decrements all the way to zero since 1 was disabled previously.
Link: [http://lore.kernel.org/20241004212504.1246-1-gourry@gourry.net](http://lore.kernel.org/20241004212504.1246-1-gourry%40gourry.net) [1]
Cc: stable@vger.kernel.org
Fixes: 176baefb2eb5 ("cxl/hdm: Commit decoder state to hardware")
Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Cc: Davidlohr Bueso <dave@stgolabs.net>
Cc: Dave Jiang <dave.jiang@intel.com>
Cc: Alison Schofield <alison.schofield@intel.com>
Cc: Ira Weiny <ira.weiny@intel.com>
Cc: Zijun Hu <quic\_zijuhu@quicinc.com>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Reviewed-by: Ira Weiny <ira.weiny@intel.com>
Link: [https://patch.msgid.link/172964782781.81806.17902885593105284330.stgit@dwillia2-xfh.jf.intel.com](https://patch.msgid.link/172964782781.81806.17902885593105284330.stgit%40dwillia2-xfh.jf.intel.com)
Signed-off-by: Ira Weiny <ira.weiny@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8e1b52c15c81106456437f8e49575040e489e355)

| -rw-r--r-- | [drivers/base/core.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/base/core.c?id=8e1b52c15c81106456437f8e49575040e489e355) | 35 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/cxl/core/hdm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/cxl/core/hdm.c?id=8e1b52c15c81106456437f8e49575040e489e355) | 50 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/cxl/core/region.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/cxl/core/region.c?id=8e1b52c15c81106456437f8e49575040e489e355) | 48 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/cxl/cxl.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/cxl/cxl.h?id=8e1b52c15c81106456437f8e49575040e489e355) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/device.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/device.h?id=8e1b52c15c81106456437f8e49575040e489e355) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/cxl/test/cxl.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/cxl/test/cxl.c?id=8e1b52c15c81106456437f8e49575040e489e355) | 14 | |  |  |  | | --- | --- | --- | |

6 files changed, 100 insertions, 53 deletions

| diff --git a/drivers/base/core.c b/drivers/base/core.cindex 009723a41d07e8..c9fb3243e353ea 100644--- a/[drivers/base/core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/core.c?id=8cd25f1fce6b8f9e20401617a4a6c19dbf956f5b)+++ b/[drivers/base/core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/core.c?id=8e1b52c15c81106456437f8e49575040e489e355)@@ -4012,6 +4012,41 @@ int device\_for\_each\_child\_reverse(struct device \*parent, void \*data, EXPORT\_SYMBOL\_GPL(device\_for\_each\_child\_reverse);  /\*\*+ \* device\_for\_each\_child\_reverse\_from - device child iterator in reversed order.+ \* @parent: parent struct device.+ \* @from: optional starting point in child list+ \* @fn: function to be called for each device.+ \* @data: data for the callback.+ \*+ \* Iterate over @parent's child devices, starting at @from, and call @fn+ \* for each, passing it @data. This helper is identical to+ \* device\_for\_each\_child\_reverse() when @from is NULL.+ \*+ \* @fn is checked each iteration. If it returns anything other than 0,+ \* iteration stop and that value is returned to the caller of+ \* device\_for\_each\_child\_reverse\_from();+ \*/+int device\_for\_each\_child\_reverse\_from(struct device \*parent,+ struct device \*from, const void \*data,+ int (\*fn)(struct device \*, const void \*))+{+ struct klist\_iter i;+ struct device \*child;+ int error = 0;++ if (!parent->p)+ return 0;++ klist\_iter\_init\_node(&parent->p->klist\_children, &i,+ (from ? &from->p->knode\_parent : NULL));+ while ((child = prev\_device(&i)) && !error)+ error = fn(child, data);+ klist\_iter\_exit(&i);+ return error;+}+EXPORT\_SYMBOL\_GPL(device\_for\_each\_child\_reverse\_from);++/\*\* \* device\_find\_child - device iterator for locating a particular device. \* @parent: parent struct device \* @match: Callback function to check devicediff --git a/drivers/cxl/core/hdm.c b/drivers/cxl/core/hdm.cindex 3600b7cbfb5893..36b20b844b109a 100644--- a/[drivers/cxl/core/hdm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/core/hdm.c?id=8cd25f1fce6b8f9e20401617a4a6c19dbf956f5b)+++ b/[drivers/cxl/core/hdm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/core/hdm.c?id=8e1b52c15c81106456437f8e49575040e489e355)@@ -723,7 +723,44 @@ static int cxl\_decoder\_commit(struct cxl\_decoder \*cxld) return 0; } -static int cxl\_decoder\_reset(struct cxl\_decoder \*cxld)+static int commit\_reap(struct device \*dev, const void \*data)+{+ struct cxl\_port \*port = to\_cxl\_port(dev->parent);+ struct cxl\_decoder \*cxld;++ if (!is\_switch\_decoder(dev) && !is\_endpoint\_decoder(dev))+ return 0;++ cxld = to\_cxl\_decoder(dev);+ if (port->commit\_end == cxld->id &&+ ((cxld->flags & CXL\_DECODER\_F\_ENABLE) == 0)) {+ port->commit\_end--;+ dev\_dbg(&port->dev, "reap: %s commit\_end: %d\n",+ dev\_name(&cxld->dev), port->commit\_end);+ }++ return 0;+}++void cxl\_port\_commit\_reap(struct cxl\_decoder \*cxld)+{+ struct cxl\_port \*port = to\_cxl\_port(cxld->dev.parent);++ lockdep\_assert\_held\_write(&cxl\_region\_rwsem);++ /\*+ \* Once the highest committed decoder is disabled, free any other+ \* decoders that were pinned allocated by out-of-order release.+ \*/+ port->commit\_end--;+ dev\_dbg(&port->dev, "reap: %s commit\_end: %d\n", dev\_name(&cxld->dev),+ port->commit\_end);+ device\_for\_each\_child\_reverse\_from(&port->dev, &cxld->dev, NULL,+ commit\_reap);+}+EXPORT\_SYMBOL\_NS\_GPL(cxl\_port\_commit\_reap, CXL);++static void cxl\_decoder\_reset(struct cxl\_decoder \*cxld) { struct cxl\_port \*port = to\_cxl\_port(cxld->dev.parent); struct cxl\_hdm \*cxlhdm = dev\_get\_drvdata(&port->dev);@@ -732,14 +769,14 @@ static int cxl\_decoder\_reset(struct cxl\_decoder \*cxld) u32 ctrl;  if ((cxld->flags & CXL\_DECODER\_F\_ENABLE) == 0)- return 0;+ return; - if (port->commit\_end != id) {+ if (port->commit\_end == id)+ cxl\_port\_commit\_reap(cxld);+ else dev\_dbg(&port->dev, "%s: out of order reset, expected decoder%d.%d\n", dev\_name(&cxld->dev), port->id, port->commit\_end);- return -EBUSY;- }  down\_read(&cxl\_dpa\_rwsem); ctrl = readl(hdm + CXL\_HDM\_DECODER0\_CTRL\_OFFSET(id));@@ -752,7 +789,6 @@ static int cxl\_decoder\_reset(struct cxl\_decoder \*cxld) writel(0, hdm + CXL\_HDM\_DECODER0\_BASE\_LOW\_OFFSET(id)); up\_read(&cxl\_dpa\_rwsem); - port->commit\_end--; cxld->flags &= ~CXL\_DECODER\_F\_ENABLE;  /\* Userspace is now responsible for reconfiguring this decoder \*/@@ -762,8 +798,6 @@ static int cxl\_decoder\_reset(struct cxl\_decoder \*cxld) cxled = to\_cxl\_endpoint\_decoder(&cxld->dev); cxled->state = CXL\_DECODER\_STATE\_MANUAL; }-- return 0; }  static int cxl\_setup\_hdm\_decoder\_from\_dvsec(diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.cindex 5060d9802795ee..7a9357f42dad39 100644--- a/[drivers/cxl/core/region.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/core/region.c?id=8cd25f1fce6b8f9e20401617a4a6c19dbf956f5b)+++ b/[drivers/cxl/core/region.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/core/region.c?id=8e1b52c15c81106456437f8e49575040e489e355)@@ -128,8 +128,8 @@ static int cxl\_region\_invalidate\_memregion(struct cxl\_region \*cxlr) "Bypassing cpu\_cache\_invalidate\_memregion() for testing!\n"); return 0; } else {- dev\_err(&cxlr->dev,- "Failed to synchronize CPU cache state\n");+ dev\_WARN(&cxlr->dev,+ "Failed to synchronize CPU cache state\n"); return -ENXIO; } }@@ -138,19 +138,17 @@ static int cxl\_region\_invalidate\_memregion(struct cxl\_region \*cxlr) return 0; } -static int cxl\_region\_decode\_reset(struct cxl\_region \*cxlr, int count)+static void cxl\_region\_decode\_reset(struct cxl\_region \*cxlr, int count) { struct cxl\_region\_params \*p = &cxlr->params;- int i, rc = 0;+ int i;  /\*- \* Before region teardown attempt to flush, and if the flush- \* fails cancel the region teardown for data consistency- \* concerns+ \* Before region teardown attempt to flush, evict any data cached for+ \* this region, or scream loudly about missing arch / platform support+ \* for CXL teardown. \*/- rc = cxl\_region\_invalidate\_memregion(cxlr);- if (rc)- return rc;+ cxl\_region\_invalidate\_memregion(cxlr);  for (i = count - 1; i >= 0; i--) { struct cxl\_endpoint\_decoder \*cxled = p->targets[i];@@ -173,23 +171,17 @@ static int cxl\_region\_decode\_reset(struct cxl\_region \*cxlr, int count) cxl\_rr = cxl\_rr\_load(iter, cxlr); cxld = cxl\_rr->decoder; if (cxld->reset)- rc = cxld->reset(cxld);- if (rc)- return rc;+ cxld->reset(cxld); set\_bit(CXL\_REGION\_F\_NEEDS\_RESET, &cxlr->flags); }  endpoint\_reset:- rc = cxled->cxld.reset(&cxled->cxld);- if (rc)- return rc;+ cxled->cxld.reset(&cxled->cxld); set\_bit(CXL\_REGION\_F\_NEEDS\_RESET, &cxlr->flags); }  /\* all decoders associated with this region have been torn down \*/ clear\_bit(CXL\_REGION\_F\_NEEDS\_RESET, &cxlr->flags);-- return 0; }  static int commit\_decoder(struct cxl\_decoder \*cxld)@@ -305,16 +297,8 @@ static ssize\_t commit\_store(struct device \*dev, struct device\_attribute \*attr, \* still pending. \*/ if (p->state == CXL\_CONFIG\_RESET\_PENDING) {- rc = cxl\_region\_decode\_reset(cxlr, p->interleave\_ways);- /\*- \* Revert to committed since there may still be active- \* decoders associated with this region, or move forward- \* to active to mark the reset successful- \*/- if (rc)- p->state = CXL\_CONFIG\_COMMIT;- else- p->state = CXL\_CONFIG\_ACTIVE;+ cxl\_region\_decode\_reset(cxlr, p->interleave\_ways);+ p->state = CXL\_CONFIG\_ACTIVE; } } @@ -1945,13 +1929,7 @@ static int cxl\_region\_detach(struct cxl\_endpoint\_decoder \*cxled) get\_device(&cxlr->dev);  if (p->state > CXL\_CONFIG\_ACTIVE) {- /\*- \* TODO: tear down all impacted regions if a device is- \* removed out of order- \*/- rc = cxl\_region\_decode\_reset(cxlr, p->interleave\_ways);- if (rc)- goto out;+ cxl\_region\_decode\_reset(cxlr, p->interleave\_ways); p->state = CXL\_CONFIG\_ACTIVE; } diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.hindex bb3ad219b6b316..bcfcbf65d18a0f 100644--- a/[drivers/cxl/cxl.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/cxl.h?id=8cd25f1fce6b8f9e20401617a4a6c19dbf956f5b)+++ b/[drivers/cxl/cxl.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/cxl.h?id=8e1b52c15c81106456437f8e49575040e489e355)@@ -347,7 +347,7 @@ struct cxl\_decoder { struct cxl\_region \*region; unsigned long flags; int (\*commit)(struct cxl\_decoder \*cxld);- int (\*reset)(struct cxl\_decoder \*cxld);+ void (\*reset)(struct cxl\_decoder \*cxld); };  /\*@@ -682,6 +682,7 @@ static inline bool is\_cxl\_root(struct cxl\_port \*port) int cxl\_num\_decoders\_committed(struct cxl\_port \*port); bool is\_cxl\_port(const struct device \*dev); struct cxl\_port \*to\_cxl\_port(const struct device \*dev);+void cxl\_port\_commit\_reap(struct cxl\_decoder \*cxld); struct pci\_bus; int devm\_cxl\_register\_pci\_bus(struct device \*host, struct device \*uport\_dev, struct pci\_bus \*bus);diff --git a/include/linux/device.h b/include/linux/device.hindex a070160fbcb8e0..3627b26b243e61 100644--- a/[include/linux/device.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/device.h?id=8cd25f1fce6b8f9e20401617a4a6c19dbf956f5b)+++ b/[include/linux/device.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/device.h?id=8e1b52c15c81106456437f8e49575040e489e355)@@ -1063,6 +1063,9 @@ int device\_for\_each\_child(struct device \*dev, void \*data, int (\*fn)(struct device \*dev, void \*data)); int device\_for\_each\_child\_reverse(struct device \*dev, void \*data, int (\*fn)(struct device \*dev, void \*data));+int device\_for\_each\_child\_reverse\_from(struct device \*parent,+ struct device \*from, const void \*data,+ int (\*fn)(struct device \*, const void \*)); struct device \*device\_find\_child(struct device \*dev, void \*data, int (\*match)(struct device \*dev, void \*data)); struct device \*device\_find\_child\_by\_name(struct device \*parent,diff --git a/tools/testing/cxl/test/cxl.c b/tools/testing/cxl/test/cxl.cindex 8251718eaf3a8e..ed1361c8b96c48 100644--- a/[tools/testing/cxl/test/cxl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/cxl/test/cxl.c?id=8cd25f1fce6b8f9e20401617a4a6c19dbf956f5b)+++ b/[tools/testing/cxl/test/cxl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/cxl/test/cxl.c?id=8e1b52c15c81106456437f8e49575040e489e355)@@ -687,26 +687,22 @@ static int mock\_decoder\_commit(struct cxl\_decoder \*cxld) return 0; } -static int mock\_decoder\_reset(struct cxl\_decoder \*cxld)+static void mock\_decoder\_reset(struct cxl\_decoder \*cxld) { struct cxl\_port \*port = to\_cxl\_port(cxld->dev.parent); int id = cxld->id;  if ((cxld->flags & CXL\_DECODER\_F\_ENABLE) == 0)- return 0;+ return;  dev\_dbg(&port->dev, "%s reset\n", dev\_name(&cxld->dev));- if (port->commit\_end != id) {+ if (port->commit\_end == id)+ cxl\_port\_commit\_reap(cxld);+ else dev\_dbg(&port->dev, "%s: out of order reset, expected decoder%d.%d\n", dev\_name(&cxld->dev), port->id, port->commit\_end);- return -EBUSY;- }-- port->commit\_end--; cxld->flags &= ~CXL\_DECODER\_F\_ENABLE;-- return 0; }  static void default\_mock\_decoder(struct cxl\_decoder \*cxld) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 09:04:02 +0000



=== Content from git.kernel.org_b90bebfb_20250115_090524.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=78c8454fdce0eeee962be004eb6d99860c80dad1)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=78c8454fdce0eeee962be004eb6d99860c80dad1)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=78c8454fdce0eeee962be004eb6d99860c80dad1)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=78c8454fdce0eeee962be004eb6d99860c80dad1)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Dan Williams <dan.j.williams@intel.com> | 2024-10-22 18:43:49 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-08 16:30:56 +0100 |
| commit | [78c8454fdce0eeee962be004eb6d99860c80dad1](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=78c8454fdce0eeee962be004eb6d99860c80dad1) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=78c8454fdce0eeee962be004eb6d99860c80dad1)) | |
| tree | [3905ec6141ea785e1a999cf6fb991de027cc753c](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=78c8454fdce0eeee962be004eb6d99860c80dad1) | |
| parent | [f8a0e7dc7d8b73076fecc726b00d44a9f704a90f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f8a0e7dc7d8b73076fecc726b00d44a9f704a90f) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=78c8454fdce0eeee962be004eb6d99860c80dad1&id2=f8a0e7dc7d8b73076fecc726b00d44a9f704a90f)) | |
| download | [linux-78c8454fdce0eeee962be004eb6d99860c80dad1.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-78c8454fdce0eeee962be004eb6d99860c80dad1.tar.gz) | |

cxl/port: Fix use-after-free, permit out-of-order decoder shutdowncommit 101c268bd2f37e965a5468353e62d154db38838e upstream.
In support of investigating an initialization failure report [1],
cxl\_test was updated to register mock memory-devices after the mock
root-port/bus device had been registered. That led to cxl\_test crashing
with a use-after-free bug with the following signature:
cxl\_port\_attach\_region: cxl region3: cxl\_host\_bridge.0:port3 decoder3.0 add: mem0:decoder7.0 @ 0 next: cxl\_switch\_uport.0 nr\_eps: 1 nr\_targets: 1
cxl\_port\_attach\_region: cxl region3: cxl\_host\_bridge.0:port3 decoder3.0 add: mem4:decoder14.0 @ 1 next: cxl\_switch\_uport.0 nr\_eps: 2 nr\_targets: 1
cxl\_port\_setup\_targets: cxl region3: cxl\_switch\_uport.0:port6 target[0] = cxl\_switch\_dport.0 for mem0:decoder7.0 @ 0
1) cxl\_port\_setup\_targets: cxl region3: cxl\_switch\_uport.0:port6 target[1] = cxl\_switch\_dport.4 for mem4:decoder14.0 @ 1
[..]
cxld\_unregister: cxl decoder14.0:
cxl\_region\_decode\_reset: cxl\_region region3:
mock\_decoder\_reset: cxl\_port port3: decoder3.0 reset
2) mock\_decoder\_reset: cxl\_port port3: decoder3.0: out of order reset, expected decoder3.1
cxl\_endpoint\_decoder\_release: cxl decoder14.0:
[..]
cxld\_unregister: cxl decoder7.0:
3) cxl\_region\_decode\_reset: cxl\_region region3:
Oops: general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6bc3: 0000 [#1] PREEMPT SMP PTI
[..]
RIP: 0010:to\_cxl\_port+0x8/0x60 [cxl\_core]
[..]
Call Trace:
<TASK>
cxl\_region\_decode\_reset+0x69/0x190 [cxl\_core]
cxl\_region\_detach+0xe8/0x210 [cxl\_core]
cxl\_decoder\_kill\_region+0x27/0x40 [cxl\_core]
cxld\_unregister+0x5d/0x60 [cxl\_core]
At 1) a region has been established with 2 endpoint decoders (7.0 and
14.0). Those endpoints share a common switch-decoder in the topology
(3.0). At teardown, 2), decoder14.0 is the first to be removed and hits
the "out of order reset case" in the switch decoder. The effect though
is that region3 cleanup is aborted leaving it in-tact and
referencing decoder14.0. At 3) the second attempt to teardown region3
trips over the stale decoder14.0 object which has long since been
deleted.
The fix here is to recognize that the CXL specification places no
mandate on in-order shutdown of switch-decoders, the driver enforces
in-order allocation, and hardware enforces in-order commit. So, rather
than fail and leave objects dangling, always remove them.
In support of making cxl\_region\_decode\_reset() always succeed,
cxl\_region\_invalidate\_memregion() failures are turned into warnings.
Crashing the kernel is ok there since system integrity is at risk if
caches cannot be managed around physical address mutation events like
CXL region destruction.
A new device\_for\_each\_child\_reverse\_from() is added to cleanup
port->commit\_end after all dependent decoders have been disabled. In
other words if decoders are allocated 0->1->2 and disabled 1->2->0 then
port->commit\_end only decrements from 2 after 2 has been disabled, and
it decrements all the way to zero since 1 was disabled previously.
Link: [http://lore.kernel.org/20241004212504.1246-1-gourry@gourry.net](http://lore.kernel.org/20241004212504.1246-1-gourry%40gourry.net) [1]
Cc: stable@vger.kernel.org
Fixes: 176baefb2eb5 ("cxl/hdm: Commit decoder state to hardware")
Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Cc: Davidlohr Bueso <dave@stgolabs.net>
Cc: Dave Jiang <dave.jiang@intel.com>
Cc: Alison Schofield <alison.schofield@intel.com>
Cc: Ira Weiny <ira.weiny@intel.com>
Cc: Zijun Hu <quic\_zijuhu@quicinc.com>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Reviewed-by: Ira Weiny <ira.weiny@intel.com>
Link: [https://patch.msgid.link/172964782781.81806.17902885593105284330.stgit@dwillia2-xfh.jf.intel.com](https://patch.msgid.link/172964782781.81806.17902885593105284330.stgit%40dwillia2-xfh.jf.intel.com)
Signed-off-by: Ira Weiny <ira.weiny@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=78c8454fdce0eeee962be004eb6d99860c80dad1)

| -rw-r--r-- | [drivers/base/core.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/base/core.c?id=78c8454fdce0eeee962be004eb6d99860c80dad1) | 35 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/cxl/core/hdm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/cxl/core/hdm.c?id=78c8454fdce0eeee962be004eb6d99860c80dad1) | 50 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/cxl/core/region.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/cxl/core/region.c?id=78c8454fdce0eeee962be004eb6d99860c80dad1) | 48 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/cxl/cxl.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/cxl/cxl.h?id=78c8454fdce0eeee962be004eb6d99860c80dad1) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/device.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/device.h?id=78c8454fdce0eeee962be004eb6d99860c80dad1) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/cxl/test/cxl.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/cxl/test/cxl.c?id=78c8454fdce0eeee962be004eb6d99860c80dad1) | 14 | |  |  |  | | --- | --- | --- | |

6 files changed, 100 insertions, 53 deletions

| diff --git a/drivers/base/core.c b/drivers/base/core.cindex caa009a452ddcb..68b8cb518463e3 100644--- a/[drivers/base/core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/core.c?id=f8a0e7dc7d8b73076fecc726b00d44a9f704a90f)+++ b/[drivers/base/core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/core.c?id=78c8454fdce0eeee962be004eb6d99860c80dad1)@@ -4042,6 +4042,41 @@ int device\_for\_each\_child\_reverse(struct device \*parent, void \*data, EXPORT\_SYMBOL\_GPL(device\_for\_each\_child\_reverse);  /\*\*+ \* device\_for\_each\_child\_reverse\_from - device child iterator in reversed order.+ \* @parent: parent struct device.+ \* @from: optional starting point in child list+ \* @fn: function to be called for each device.+ \* @data: data for the callback.+ \*+ \* Iterate over @parent's child devices, starting at @from, and call @fn+ \* for each, passing it @data. This helper is identical to+ \* device\_for\_each\_child\_reverse() when @from is NULL.+ \*+ \* @fn is checked each iteration. If it returns anything other than 0,+ \* iteration stop and that value is returned to the caller of+ \* device\_for\_each\_child\_reverse\_from();+ \*/+int device\_for\_each\_child\_reverse\_from(struct device \*parent,+ struct device \*from, const void \*data,+ int (\*fn)(struct device \*, const void \*))+{+ struct klist\_iter i;+ struct device \*child;+ int error = 0;++ if (!parent->p)+ return 0;++ klist\_iter\_init\_node(&parent->p->klist\_children, &i,+ (from ? &from->p->knode\_parent : NULL));+ while ((child = prev\_device(&i)) && !error)+ error = fn(child, data);+ klist\_iter\_exit(&i);+ return error;+}+EXPORT\_SYMBOL\_GPL(device\_for\_each\_child\_reverse\_from);++/\*\* \* device\_find\_child - device iterator for locating a particular device. \* @parent: parent struct device \* @match: Callback function to check devicediff --git a/drivers/cxl/core/hdm.c b/drivers/cxl/core/hdm.cindex 3df10517a3278f..223c273c0cd179 100644--- a/[drivers/cxl/core/hdm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/core/hdm.c?id=f8a0e7dc7d8b73076fecc726b00d44a9f704a90f)+++ b/[drivers/cxl/core/hdm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/core/hdm.c?id=78c8454fdce0eeee962be004eb6d99860c80dad1)@@ -712,7 +712,44 @@ static int cxl\_decoder\_commit(struct cxl\_decoder \*cxld) return 0; } -static int cxl\_decoder\_reset(struct cxl\_decoder \*cxld)+static int commit\_reap(struct device \*dev, const void \*data)+{+ struct cxl\_port \*port = to\_cxl\_port(dev->parent);+ struct cxl\_decoder \*cxld;++ if (!is\_switch\_decoder(dev) && !is\_endpoint\_decoder(dev))+ return 0;++ cxld = to\_cxl\_decoder(dev);+ if (port->commit\_end == cxld->id &&+ ((cxld->flags & CXL\_DECODER\_F\_ENABLE) == 0)) {+ port->commit\_end--;+ dev\_dbg(&port->dev, "reap: %s commit\_end: %d\n",+ dev\_name(&cxld->dev), port->commit\_end);+ }++ return 0;+}++void cxl\_port\_commit\_reap(struct cxl\_decoder \*cxld)+{+ struct cxl\_port \*port = to\_cxl\_port(cxld->dev.parent);++ lockdep\_assert\_held\_write(&cxl\_region\_rwsem);++ /\*+ \* Once the highest committed decoder is disabled, free any other+ \* decoders that were pinned allocated by out-of-order release.+ \*/+ port->commit\_end--;+ dev\_dbg(&port->dev, "reap: %s commit\_end: %d\n", dev\_name(&cxld->dev),+ port->commit\_end);+ device\_for\_each\_child\_reverse\_from(&port->dev, &cxld->dev, NULL,+ commit\_reap);+}+EXPORT\_SYMBOL\_NS\_GPL(cxl\_port\_commit\_reap, CXL);++static void cxl\_decoder\_reset(struct cxl\_decoder \*cxld) { struct cxl\_port \*port = to\_cxl\_port(cxld->dev.parent); struct cxl\_hdm \*cxlhdm = dev\_get\_drvdata(&port->dev);@@ -721,14 +758,14 @@ static int cxl\_decoder\_reset(struct cxl\_decoder \*cxld) u32 ctrl;  if ((cxld->flags & CXL\_DECODER\_F\_ENABLE) == 0)- return 0;+ return; - if (port->commit\_end != id) {+ if (port->commit\_end == id)+ cxl\_port\_commit\_reap(cxld);+ else dev\_dbg(&port->dev, "%s: out of order reset, expected decoder%d.%d\n", dev\_name(&cxld->dev), port->id, port->commit\_end);- return -EBUSY;- }  down\_read(&cxl\_dpa\_rwsem); ctrl = readl(hdm + CXL\_HDM\_DECODER0\_CTRL\_OFFSET(id));@@ -741,7 +778,6 @@ static int cxl\_decoder\_reset(struct cxl\_decoder \*cxld) writel(0, hdm + CXL\_HDM\_DECODER0\_BASE\_LOW\_OFFSET(id)); up\_read(&cxl\_dpa\_rwsem); - port->commit\_end--; cxld->flags &= ~CXL\_DECODER\_F\_ENABLE;  /\* Userspace is now responsible for reconfiguring this decoder \*/@@ -751,8 +787,6 @@ static int cxl\_decoder\_reset(struct cxl\_decoder \*cxld) cxled = to\_cxl\_endpoint\_decoder(&cxld->dev); cxled->state = CXL\_DECODER\_STATE\_MANUAL; }-- return 0; }  static int cxl\_setup\_hdm\_decoder\_from\_dvsec(diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.cindex 21ad5f24287581..38507c4a3743b1 100644--- a/[drivers/cxl/core/region.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/core/region.c?id=f8a0e7dc7d8b73076fecc726b00d44a9f704a90f)+++ b/[drivers/cxl/core/region.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/core/region.c?id=78c8454fdce0eeee962be004eb6d99860c80dad1)@@ -232,8 +232,8 @@ static int cxl\_region\_invalidate\_memregion(struct cxl\_region \*cxlr) "Bypassing cpu\_cache\_invalidate\_memregion() for testing!\n"); return 0; } else {- dev\_err(&cxlr->dev,- "Failed to synchronize CPU cache state\n");+ dev\_WARN(&cxlr->dev,+ "Failed to synchronize CPU cache state\n"); return -ENXIO; } }@@ -242,19 +242,17 @@ static int cxl\_region\_invalidate\_memregion(struct cxl\_region \*cxlr) return 0; } -static int cxl\_region\_decode\_reset(struct cxl\_region \*cxlr, int count)+static void cxl\_region\_decode\_reset(struct cxl\_region \*cxlr, int count) { struct cxl\_region\_params \*p = &cxlr->params;- int i, rc = 0;+ int i;  /\*- \* Before region teardown attempt to flush, and if the flush- \* fails cancel the region teardown for data consistency- \* concerns+ \* Before region teardown attempt to flush, evict any data cached for+ \* this region, or scream loudly about missing arch / platform support+ \* for CXL teardown. \*/- rc = cxl\_region\_invalidate\_memregion(cxlr);- if (rc)- return rc;+ cxl\_region\_invalidate\_memregion(cxlr);  for (i = count - 1; i >= 0; i--) { struct cxl\_endpoint\_decoder \*cxled = p->targets[i];@@ -277,23 +275,17 @@ static int cxl\_region\_decode\_reset(struct cxl\_region \*cxlr, int count) cxl\_rr = cxl\_rr\_load(iter, cxlr); cxld = cxl\_rr->decoder; if (cxld->reset)- rc = cxld->reset(cxld);- if (rc)- return rc;+ cxld->reset(cxld); set\_bit(CXL\_REGION\_F\_NEEDS\_RESET, &cxlr->flags); }  endpoint\_reset:- rc = cxled->cxld.reset(&cxled->cxld);- if (rc)- return rc;+ cxled->cxld.reset(&cxled->cxld); set\_bit(CXL\_REGION\_F\_NEEDS\_RESET, &cxlr->flags); }  /\* all decoders associated with this region have been torn down \*/ clear\_bit(CXL\_REGION\_F\_NEEDS\_RESET, &cxlr->flags);-- return 0; }  static int commit\_decoder(struct cxl\_decoder \*cxld)@@ -409,16 +401,8 @@ static ssize\_t commit\_store(struct device \*dev, struct device\_attribute \*attr, \* still pending. \*/ if (p->state == CXL\_CONFIG\_RESET\_PENDING) {- rc = cxl\_region\_decode\_reset(cxlr, p->interleave\_ways);- /\*- \* Revert to committed since there may still be active- \* decoders associated with this region, or move forward- \* to active to mark the reset successful- \*/- if (rc)- p->state = CXL\_CONFIG\_COMMIT;- else- p->state = CXL\_CONFIG\_ACTIVE;+ cxl\_region\_decode\_reset(cxlr, p->interleave\_ways);+ p->state = CXL\_CONFIG\_ACTIVE; } } @@ -2052,13 +2036,7 @@ static int cxl\_region\_detach(struct cxl\_endpoint\_decoder \*cxled) get\_device(&cxlr->dev);  if (p->state > CXL\_CONFIG\_ACTIVE) {- /\*- \* TODO: tear down all impacted regions if a device is- \* removed out of order- \*/- rc = cxl\_region\_decode\_reset(cxlr, p->interleave\_ways);- if (rc)- goto out;+ cxl\_region\_decode\_reset(cxlr, p->interleave\_ways); p->state = CXL\_CONFIG\_ACTIVE; } diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.hindex 9afb407d438fae..d437745ab1725a 100644--- a/[drivers/cxl/cxl.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/cxl.h?id=f8a0e7dc7d8b73076fecc726b00d44a9f704a90f)+++ b/[drivers/cxl/cxl.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/cxl.h?id=78c8454fdce0eeee962be004eb6d99860c80dad1)@@ -359,7 +359,7 @@ struct cxl\_decoder { struct cxl\_region \*region; unsigned long flags; int (\*commit)(struct cxl\_decoder \*cxld);- int (\*reset)(struct cxl\_decoder \*cxld);+ void (\*reset)(struct cxl\_decoder \*cxld); };  /\*@@ -730,6 +730,7 @@ static inline bool is\_cxl\_root(struct cxl\_port \*port) int cxl\_num\_decoders\_committed(struct cxl\_port \*port); bool is\_cxl\_port(const struct device \*dev); struct cxl\_port \*to\_cxl\_port(const struct device \*dev);+void cxl\_port\_commit\_reap(struct cxl\_decoder \*cxld); struct pci\_bus; int devm\_cxl\_register\_pci\_bus(struct device \*host, struct device \*uport\_dev, struct pci\_bus \*bus);diff --git a/include/linux/device.h b/include/linux/device.hindex 34eb20f5966f95..02d840f5c226ce 100644--- a/[include/linux/device.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/device.h?id=f8a0e7dc7d8b73076fecc726b00d44a9f704a90f)+++ b/[include/linux/device.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/device.h?id=78c8454fdce0eeee962be004eb6d99860c80dad1)@@ -1073,6 +1073,9 @@ int device\_for\_each\_child(struct device \*dev, void \*data, int (\*fn)(struct device \*dev, void \*data)); int device\_for\_each\_child\_reverse(struct device \*dev, void \*data, int (\*fn)(struct device \*dev, void \*data));+int device\_for\_each\_child\_reverse\_from(struct device \*parent,+ struct device \*from, const void \*data,+ int (\*fn)(struct device \*, const void \*)); struct device \*device\_find\_child(struct device \*dev, void \*data, int (\*match)(struct device \*dev, void \*data)); struct device \*device\_find\_child\_by\_name(struct device \*parent,diff --git a/tools/testing/cxl/test/cxl.c b/tools/testing/cxl/test/cxl.cindex 90d5afd52dd06b..c5bbd89b319209 100644--- a/[tools/testing/cxl/test/cxl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/cxl/test/cxl.c?id=f8a0e7dc7d8b73076fecc726b00d44a9f704a90f)+++ b/[tools/testing/cxl/test/cxl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/cxl/test/cxl.c?id=78c8454fdce0eeee962be004eb6d99860c80dad1)@@ -693,26 +693,22 @@ static int mock\_decoder\_commit(struct cxl\_decoder \*cxld) return 0; } -static int mock\_decoder\_reset(struct cxl\_decoder \*cxld)+static void mock\_decoder\_reset(struct cxl\_decoder \*cxld) { struct cxl\_port \*port = to\_cxl\_port(cxld->dev.parent); int id = cxld->id;  if ((cxld->flags & CXL\_DECODER\_F\_ENABLE) == 0)- return 0;+ return;  dev\_dbg(&port->dev, "%s reset\n", dev\_name(&cxld->dev));- if (port->commit\_end != id) {+ if (port->commit\_end == id)+ cxl\_port\_commit\_reap(cxld);+ else dev\_dbg(&port->dev, "%s: out of order reset, expected decoder%d.%d\n", dev\_name(&cxld->dev), port->id, port->commit\_end);- return -EBUSY;- }-- port->commit\_end--; cxld->flags &= ~CXL\_DECODER\_F\_ENABLE;-- return 0; }  static void default\_mock\_decoder(struct cxl\_decoder \*cxld) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 09:04:01 +0000



=== Content from git.kernel.org_c723994e_20250115_090523.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=101c268bd2f37e965a5468353e62d154db38838e)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=101c268bd2f37e965a5468353e62d154db38838e)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=101c268bd2f37e965a5468353e62d154db38838e)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=101c268bd2f37e965a5468353e62d154db38838e)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Dan Williams <dan.j.williams@intel.com> | 2024-10-22 18:43:49 -0700 |
| --- | --- | --- |
| committer | Ira Weiny <ira.weiny@intel.com> | 2024-10-25 16:07:03 -0500 |
| commit | [101c268bd2f37e965a5468353e62d154db38838e](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=101c268bd2f37e965a5468353e62d154db38838e) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=101c268bd2f37e965a5468353e62d154db38838e)) | |
| tree | [8157a9d59e4acbe1bc0d01d6705bda4a19c28727](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=101c268bd2f37e965a5468353e62d154db38838e) | |
| parent | [48f62d38a07d464a499fa834638afcfd2b68f852](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=48f62d38a07d464a499fa834638afcfd2b68f852) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=101c268bd2f37e965a5468353e62d154db38838e&id2=48f62d38a07d464a499fa834638afcfd2b68f852)) | |
| download | [linux-101c268bd2f37e965a5468353e62d154db38838e.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-101c268bd2f37e965a5468353e62d154db38838e.tar.gz) | |

cxl/port: Fix use-after-free, permit out-of-order decoder shutdownIn support of investigating an initialization failure report [1],
cxl\_test was updated to register mock memory-devices after the mock
root-port/bus device had been registered. That led to cxl\_test crashing
with a use-after-free bug with the following signature:
cxl\_port\_attach\_region: cxl region3: cxl\_host\_bridge.0:port3 decoder3.0 add: mem0:decoder7.0 @ 0 next: cxl\_switch\_uport.0 nr\_eps: 1 nr\_targets: 1
cxl\_port\_attach\_region: cxl region3: cxl\_host\_bridge.0:port3 decoder3.0 add: mem4:decoder14.0 @ 1 next: cxl\_switch\_uport.0 nr\_eps: 2 nr\_targets: 1
cxl\_port\_setup\_targets: cxl region3: cxl\_switch\_uport.0:port6 target[0] = cxl\_switch\_dport.0 for mem0:decoder7.0 @ 0
1) cxl\_port\_setup\_targets: cxl region3: cxl\_switch\_uport.0:port6 target[1] = cxl\_switch\_dport.4 for mem4:decoder14.0 @ 1
[..]
cxld\_unregister: cxl decoder14.0:
cxl\_region\_decode\_reset: cxl\_region region3:
mock\_decoder\_reset: cxl\_port port3: decoder3.0 reset
2) mock\_decoder\_reset: cxl\_port port3: decoder3.0: out of order reset, expected decoder3.1
cxl\_endpoint\_decoder\_release: cxl decoder14.0:
[..]
cxld\_unregister: cxl decoder7.0:
3) cxl\_region\_decode\_reset: cxl\_region region3:
Oops: general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6bc3: 0000 [#1] PREEMPT SMP PTI
[..]
RIP: 0010:to\_cxl\_port+0x8/0x60 [cxl\_core]
[..]
Call Trace:
<TASK>
cxl\_region\_decode\_reset+0x69/0x190 [cxl\_core]
cxl\_region\_detach+0xe8/0x210 [cxl\_core]
cxl\_decoder\_kill\_region+0x27/0x40 [cxl\_core]
cxld\_unregister+0x5d/0x60 [cxl\_core]
At 1) a region has been established with 2 endpoint decoders (7.0 and
14.0). Those endpoints share a common switch-decoder in the topology
(3.0). At teardown, 2), decoder14.0 is the first to be removed and hits
the "out of order reset case" in the switch decoder. The effect though
is that region3 cleanup is aborted leaving it in-tact and
referencing decoder14.0. At 3) the second attempt to teardown region3
trips over the stale decoder14.0 object which has long since been
deleted.
The fix here is to recognize that the CXL specification places no
mandate on in-order shutdown of switch-decoders, the driver enforces
in-order allocation, and hardware enforces in-order commit. So, rather
than fail and leave objects dangling, always remove them.
In support of making cxl\_region\_decode\_reset() always succeed,
cxl\_region\_invalidate\_memregion() failures are turned into warnings.
Crashing the kernel is ok there since system integrity is at risk if
caches cannot be managed around physical address mutation events like
CXL region destruction.
A new device\_for\_each\_child\_reverse\_from() is added to cleanup
port->commit\_end after all dependent decoders have been disabled. In
other words if decoders are allocated 0->1->2 and disabled 1->2->0 then
port->commit\_end only decrements from 2 after 2 has been disabled, and
it decrements all the way to zero since 1 was disabled previously.
Link: [http://lore.kernel.org/20241004212504.1246-1-gourry@gourry.net](http://lore.kernel.org/20241004212504.1246-1-gourry%40gourry.net) [1]
Cc: stable@vger.kernel.org
Fixes: 176baefb2eb5 ("cxl/hdm: Commit decoder state to hardware")
Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Cc: Davidlohr Bueso <dave@stgolabs.net>
Cc: Dave Jiang <dave.jiang@intel.com>
Cc: Alison Schofield <alison.schofield@intel.com>
Cc: Ira Weiny <ira.weiny@intel.com>
Cc: Zijun Hu <quic\_zijuhu@quicinc.com>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Reviewed-by: Ira Weiny <ira.weiny@intel.com>
Link: [https://patch.msgid.link/172964782781.81806.17902885593105284330.stgit@dwillia2-xfh.jf.intel.com](https://patch.msgid.link/172964782781.81806.17902885593105284330.stgit%40dwillia2-xfh.jf.intel.com)
Signed-off-by: Ira Weiny <ira.weiny@intel.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=101c268bd2f37e965a5468353e62d154db38838e)

| -rw-r--r-- | [drivers/base/core.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/base/core.c?id=101c268bd2f37e965a5468353e62d154db38838e) | 35 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/cxl/core/hdm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/cxl/core/hdm.c?id=101c268bd2f37e965a5468353e62d154db38838e) | 50 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/cxl/core/region.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/cxl/core/region.c?id=101c268bd2f37e965a5468353e62d154db38838e) | 48 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/cxl/cxl.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/cxl/cxl.h?id=101c268bd2f37e965a5468353e62d154db38838e) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/device.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/device.h?id=101c268bd2f37e965a5468353e62d154db38838e) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/cxl/test/cxl.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/cxl/test/cxl.c?id=101c268bd2f37e965a5468353e62d154db38838e) | 14 | |  |  |  | | --- | --- | --- | |

6 files changed, 100 insertions, 53 deletions

| diff --git a/drivers/base/core.c b/drivers/base/core.cindex a4c853411a6b2b..e42f1ad7307804 100644--- a/[drivers/base/core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/core.c?id=48f62d38a07d464a499fa834638afcfd2b68f852)+++ b/[drivers/base/core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/core.c?id=101c268bd2f37e965a5468353e62d154db38838e)@@ -4038,6 +4038,41 @@ int device\_for\_each\_child\_reverse(struct device \*parent, void \*data, EXPORT\_SYMBOL\_GPL(device\_for\_each\_child\_reverse);  /\*\*+ \* device\_for\_each\_child\_reverse\_from - device child iterator in reversed order.+ \* @parent: parent struct device.+ \* @from: optional starting point in child list+ \* @fn: function to be called for each device.+ \* @data: data for the callback.+ \*+ \* Iterate over @parent's child devices, starting at @from, and call @fn+ \* for each, passing it @data. This helper is identical to+ \* device\_for\_each\_child\_reverse() when @from is NULL.+ \*+ \* @fn is checked each iteration. If it returns anything other than 0,+ \* iteration stop and that value is returned to the caller of+ \* device\_for\_each\_child\_reverse\_from();+ \*/+int device\_for\_each\_child\_reverse\_from(struct device \*parent,+ struct device \*from, const void \*data,+ int (\*fn)(struct device \*, const void \*))+{+ struct klist\_iter i;+ struct device \*child;+ int error = 0;++ if (!parent->p)+ return 0;++ klist\_iter\_init\_node(&parent->p->klist\_children, &i,+ (from ? &from->p->knode\_parent : NULL));+ while ((child = prev\_device(&i)) && !error)+ error = fn(child, data);+ klist\_iter\_exit(&i);+ return error;+}+EXPORT\_SYMBOL\_GPL(device\_for\_each\_child\_reverse\_from);++/\*\* \* device\_find\_child - device iterator for locating a particular device. \* @parent: parent struct device \* @match: Callback function to check devicediff --git a/drivers/cxl/core/hdm.c b/drivers/cxl/core/hdm.cindex 3df10517a3278f..223c273c0cd179 100644--- a/[drivers/cxl/core/hdm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/core/hdm.c?id=48f62d38a07d464a499fa834638afcfd2b68f852)+++ b/[drivers/cxl/core/hdm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/core/hdm.c?id=101c268bd2f37e965a5468353e62d154db38838e)@@ -712,7 +712,44 @@ static int cxl\_decoder\_commit(struct cxl\_decoder \*cxld) return 0; } -static int cxl\_decoder\_reset(struct cxl\_decoder \*cxld)+static int commit\_reap(struct device \*dev, const void \*data)+{+ struct cxl\_port \*port = to\_cxl\_port(dev->parent);+ struct cxl\_decoder \*cxld;++ if (!is\_switch\_decoder(dev) && !is\_endpoint\_decoder(dev))+ return 0;++ cxld = to\_cxl\_decoder(dev);+ if (port->commit\_end == cxld->id &&+ ((cxld->flags & CXL\_DECODER\_F\_ENABLE) == 0)) {+ port->commit\_end--;+ dev\_dbg(&port->dev, "reap: %s commit\_end: %d\n",+ dev\_name(&cxld->dev), port->commit\_end);+ }++ return 0;+}++void cxl\_port\_commit\_reap(struct cxl\_decoder \*cxld)+{+ struct cxl\_port \*port = to\_cxl\_port(cxld->dev.parent);++ lockdep\_assert\_held\_write(&cxl\_region\_rwsem);++ /\*+ \* Once the highest committed decoder is disabled, free any other+ \* decoders that were pinned allocated by out-of-order release.+ \*/+ port->commit\_end--;+ dev\_dbg(&port->dev, "reap: %s commit\_end: %d\n", dev\_name(&cxld->dev),+ port->commit\_end);+ device\_for\_each\_child\_reverse\_from(&port->dev, &cxld->dev, NULL,+ commit\_reap);+}+EXPORT\_SYMBOL\_NS\_GPL(cxl\_port\_commit\_reap, CXL);++static void cxl\_decoder\_reset(struct cxl\_decoder \*cxld) { struct cxl\_port \*port = to\_cxl\_port(cxld->dev.parent); struct cxl\_hdm \*cxlhdm = dev\_get\_drvdata(&port->dev);@@ -721,14 +758,14 @@ static int cxl\_decoder\_reset(struct cxl\_decoder \*cxld) u32 ctrl;  if ((cxld->flags & CXL\_DECODER\_F\_ENABLE) == 0)- return 0;+ return; - if (port->commit\_end != id) {+ if (port->commit\_end == id)+ cxl\_port\_commit\_reap(cxld);+ else dev\_dbg(&port->dev, "%s: out of order reset, expected decoder%d.%d\n", dev\_name(&cxld->dev), port->id, port->commit\_end);- return -EBUSY;- }  down\_read(&cxl\_dpa\_rwsem); ctrl = readl(hdm + CXL\_HDM\_DECODER0\_CTRL\_OFFSET(id));@@ -741,7 +778,6 @@ static int cxl\_decoder\_reset(struct cxl\_decoder \*cxld) writel(0, hdm + CXL\_HDM\_DECODER0\_BASE\_LOW\_OFFSET(id)); up\_read(&cxl\_dpa\_rwsem); - port->commit\_end--; cxld->flags &= ~CXL\_DECODER\_F\_ENABLE;  /\* Userspace is now responsible for reconfiguring this decoder \*/@@ -751,8 +787,6 @@ static int cxl\_decoder\_reset(struct cxl\_decoder \*cxld) cxled = to\_cxl\_endpoint\_decoder(&cxld->dev); cxled->state = CXL\_DECODER\_STATE\_MANUAL; }-- return 0; }  static int cxl\_setup\_hdm\_decoder\_from\_dvsec(diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.cindex e701e4b0403282..3478d205830353 100644--- a/[drivers/cxl/core/region.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/core/region.c?id=48f62d38a07d464a499fa834638afcfd2b68f852)+++ b/[drivers/cxl/core/region.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/core/region.c?id=101c268bd2f37e965a5468353e62d154db38838e)@@ -232,8 +232,8 @@ static int cxl\_region\_invalidate\_memregion(struct cxl\_region \*cxlr) "Bypassing cpu\_cache\_invalidate\_memregion() for testing!\n"); return 0; } else {- dev\_err(&cxlr->dev,- "Failed to synchronize CPU cache state\n");+ dev\_WARN(&cxlr->dev,+ "Failed to synchronize CPU cache state\n"); return -ENXIO; } }@@ -242,19 +242,17 @@ static int cxl\_region\_invalidate\_memregion(struct cxl\_region \*cxlr) return 0; } -static int cxl\_region\_decode\_reset(struct cxl\_region \*cxlr, int count)+static void cxl\_region\_decode\_reset(struct cxl\_region \*cxlr, int count) { struct cxl\_region\_params \*p = &cxlr->params;- int i, rc = 0;+ int i;  /\*- \* Before region teardown attempt to flush, and if the flush- \* fails cancel the region teardown for data consistency- \* concerns+ \* Before region teardown attempt to flush, evict any data cached for+ \* this region, or scream loudly about missing arch / platform support+ \* for CXL teardown. \*/- rc = cxl\_region\_invalidate\_memregion(cxlr);- if (rc)- return rc;+ cxl\_region\_invalidate\_memregion(cxlr);  for (i = count - 1; i >= 0; i--) { struct cxl\_endpoint\_decoder \*cxled = p->targets[i];@@ -277,23 +275,17 @@ static int cxl\_region\_decode\_reset(struct cxl\_region \*cxlr, int count) cxl\_rr = cxl\_rr\_load(iter, cxlr); cxld = cxl\_rr->decoder; if (cxld->reset)- rc = cxld->reset(cxld);- if (rc)- return rc;+ cxld->reset(cxld); set\_bit(CXL\_REGION\_F\_NEEDS\_RESET, &cxlr->flags); }  endpoint\_reset:- rc = cxled->cxld.reset(&cxled->cxld);- if (rc)- return rc;+ cxled->cxld.reset(&cxled->cxld); set\_bit(CXL\_REGION\_F\_NEEDS\_RESET, &cxlr->flags); }  /\* all decoders associated with this region have been torn down \*/ clear\_bit(CXL\_REGION\_F\_NEEDS\_RESET, &cxlr->flags);-- return 0; }  static int commit\_decoder(struct cxl\_decoder \*cxld)@@ -409,16 +401,8 @@ static ssize\_t commit\_store(struct device \*dev, struct device\_attribute \*attr, \* still pending. \*/ if (p->state == CXL\_CONFIG\_RESET\_PENDING) {- rc = cxl\_region\_decode\_reset(cxlr, p->interleave\_ways);- /\*- \* Revert to committed since there may still be active- \* decoders associated with this region, or move forward- \* to active to mark the reset successful- \*/- if (rc)- p->state = CXL\_CONFIG\_COMMIT;- else- p->state = CXL\_CONFIG\_ACTIVE;+ cxl\_region\_decode\_reset(cxlr, p->interleave\_ways);+ p->state = CXL\_CONFIG\_ACTIVE; } } @@ -2054,13 +2038,7 @@ static int cxl\_region\_detach(struct cxl\_endpoint\_decoder \*cxled) get\_device(&cxlr->dev);  if (p->state > CXL\_CONFIG\_ACTIVE) {- /\*- \* TODO: tear down all impacted regions if a device is- \* removed out of order- \*/- rc = cxl\_region\_decode\_reset(cxlr, p->interleave\_ways);- if (rc)- goto out;+ cxl\_region\_decode\_reset(cxlr, p->interleave\_ways); p->state = CXL\_CONFIG\_ACTIVE; } diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.hindex 0d8b810a51f04d..5406e3ab3d4a45 100644--- a/[drivers/cxl/cxl.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/cxl.h?id=48f62d38a07d464a499fa834638afcfd2b68f852)+++ b/[drivers/cxl/cxl.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/cxl/cxl.h?id=101c268bd2f37e965a5468353e62d154db38838e)@@ -359,7 +359,7 @@ struct cxl\_decoder { struct cxl\_region \*region; unsigned long flags; int (\*commit)(struct cxl\_decoder \*cxld);- int (\*reset)(struct cxl\_decoder \*cxld);+ void (\*reset)(struct cxl\_decoder \*cxld); };  /\*@@ -730,6 +730,7 @@ static inline bool is\_cxl\_root(struct cxl\_port \*port) int cxl\_num\_decoders\_committed(struct cxl\_port \*port); bool is\_cxl\_port(const struct device \*dev); struct cxl\_port \*to\_cxl\_port(const struct device \*dev);+void cxl\_port\_commit\_reap(struct cxl\_decoder \*cxld); struct pci\_bus; int devm\_cxl\_register\_pci\_bus(struct device \*host, struct device \*uport\_dev, struct pci\_bus \*bus);diff --git a/include/linux/device.h b/include/linux/device.hindex b4bde8d226979b..667cb6db901934 100644--- a/[include/linux/device.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/device.h?id=48f62d38a07d464a499fa834638afcfd2b68f852)+++ b/[include/linux/device.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/device.h?id=101c268bd2f37e965a5468353e62d154db38838e)@@ -1078,6 +1078,9 @@ int device\_for\_each\_child(struct device \*dev, void \*data, int (\*fn)(struct device \*dev, void \*data)); int device\_for\_each\_child\_reverse(struct device \*dev, void \*data, int (\*fn)(struct device \*dev, void \*data));+int device\_for\_each\_child\_reverse\_from(struct device \*parent,+ struct device \*from, const void \*data,+ int (\*fn)(struct device \*, const void \*)); struct device \*device\_find\_child(struct device \*dev, void \*data, int (\*match)(struct device \*dev, void \*data)); struct device \*device\_find\_child\_by\_name(struct device \*parent,diff --git a/tools/testing/cxl/test/cxl.c b/tools/testing/cxl/test/cxl.cindex 90d5afd52dd06b..c5bbd89b319209 100644--- a/[tools/testing/cxl/test/cxl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/cxl/test/cxl.c?id=48f62d38a07d464a499fa834638afcfd2b68f852)+++ b/[tools/testing/cxl/test/cxl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/cxl/test/cxl.c?id=101c268bd2f37e965a5468353e62d154db38838e)@@ -693,26 +693,22 @@ static int mock\_decoder\_commit(struct cxl\_decoder \*cxld) return 0; } -static int mock\_decoder\_reset(struct cxl\_decoder \*cxld)+static void mock\_decoder\_reset(struct cxl\_decoder \*cxld) { struct cxl\_port \*port = to\_cxl\_port(cxld->dev.parent); int id = cxld->id;  if ((cxld->flags & CXL\_DECODER\_F\_ENABLE) == 0)- return 0;+ return;  dev\_dbg(&port->dev, "%s reset\n", dev\_name(&cxld->dev));- if (port->commit\_end != id) {+ if (port->commit\_end == id)+ cxl\_port\_commit\_reap(cxld);+ else dev\_dbg(&port->dev, "%s: out of order reset, expected decoder%d.%d\n", dev\_name(&cxld->dev), port->id, port->commit\_end);- return -EBUSY;- }-- port->commit\_end--; cxld->flags &= ~CXL\_DECODER\_F\_ENABLE;-- return 0; }  static void default\_mock\_decoder(struct cxl\_decoder \*cxld) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 09:04:00 +0000


