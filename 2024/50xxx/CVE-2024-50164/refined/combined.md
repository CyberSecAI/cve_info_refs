=== Content from git.kernel.org_4a8daf02_20250114_214131.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=8ea607330a39184f51737c6ae706db7fdca7628e)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=8ea607330a39184f51737c6ae706db7fdca7628e)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8ea607330a39184f51737c6ae706db7fdca7628e)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8ea607330a39184f51737c6ae706db7fdca7628e)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Daniel Borkmann <daniel@iogearbox.net> | 2024-10-21 17:28:06 +0200 |
| --- | --- | --- |
| committer | Alexei Starovoitov <ast@kernel.org> | 2024-10-22 15:42:56 -0700 |
| commit | [8ea607330a39184f51737c6ae706db7fdca7628e](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8ea607330a39184f51737c6ae706db7fdca7628e) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=8ea607330a39184f51737c6ae706db7fdca7628e)) | |
| tree | [239f0f7d23cd99e11305a38f7e5d31fcee3e9a46](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=8ea607330a39184f51737c6ae706db7fdca7628e) | |
| parent | [6fad274f06f038c29660aa53fbad14241c9fd976](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6fad274f06f038c29660aa53fbad14241c9fd976) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8ea607330a39184f51737c6ae706db7fdca7628e&id2=6fad274f06f038c29660aa53fbad14241c9fd976)) | |
| download | [linux-8ea607330a39184f51737c6ae706db7fdca7628e.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-8ea607330a39184f51737c6ae706db7fdca7628e.tar.gz) | |

bpf: Fix overloading of MEM\_UNINIT's meaningLonial reported an issue in the BPF verifier where check\_mem\_size\_reg()
has the following code:
if (!tnum\_is\_const(reg->var\_off))
/\* For unprivileged variable accesses, disable raw
\* mode so that the program is required to
\* initialize all the memory that the helper could
\* just partially fill up.
\*/
meta = NULL;
This means that writes are not checked when the register containing the
size of the passed buffer has not a fixed size. Through this bug, a BPF
program can write to a map which is marked as read-only, for example,
.rodata global maps.
The problem is that MEM\_UNINIT's initial meaning that "the passed buffer
to the BPF helper does not need to be initialized" which was added back
in commit 435faee1aae9 ("bpf, verifier: add ARG\_PTR\_TO\_RAW\_STACK type")
got overloaded over time with "the passed buffer is being written to".
The problem however is that checks such as the above which were added later
via 06c1c049721a ("bpf: allow helpers access to variable memory") set meta
to NULL in order force the user to always initialize the passed buffer to
the helper. Due to the current double meaning of MEM\_UNINIT, this bypasses
verifier write checks to the memory (not boundary checks though) and only
assumes the latter memory is read instead.
Fix this by reverting MEM\_UNINIT back to its original meaning, and having
MEM\_WRITE as an annotation to BPF helpers in order to then trigger the
BPF verifier checks for writing to memory.
Some notes: check\_arg\_pair\_ok() ensures that for ARG\_CONST\_SIZE{,\_OR\_ZERO}
we can access fn->arg\_type[arg - 1] since it must contain a preceding
ARG\_PTR\_TO\_MEM. For check\_mem\_reg() the meta argument can be removed
altogether since we do check both BPF\_READ and BPF\_WRITE. Same for the
equivalent check\_kfunc\_mem\_size\_reg().
Fixes: 7b3552d3f9f6 ("bpf: Reject writes for PTR\_TO\_MAP\_KEY in check\_helper\_mem\_access")
Fixes: 97e6d7dab1ca ("bpf: Check PTR\_TO\_MEM | MEM\_RDONLY in check\_helper\_mem\_access")
Fixes: 15baa55ff5b0 ("bpf/verifier: allow all functions to read user provided context")
Reported-by: Lonial Con <kongln9170@gmail.com>
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Kumar Kartikeya Dwivedi <memxor@gmail.com>
Link: [https://lore.kernel.org/r/20241021152809.33343-2-daniel@iogearbox.net](https://lore.kernel.org/r/20241021152809.33343-2-daniel%40iogearbox.net)
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8ea607330a39184f51737c6ae706db7fdca7628e)

| -rw-r--r-- | [kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/verifier.c?id=8ea607330a39184f51737c6ae706db7fdca7628e) | 73 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 35 insertions, 38 deletions

| diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex 411ab1b57af420..f9e2f1cd49750e 100644--- a/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=6fad274f06f038c29660aa53fbad14241c9fd976)+++ b/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=8ea607330a39184f51737c6ae706db7fdca7628e)@@ -7438,7 +7438,8 @@ mark: }  static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno,- int access\_size, bool zero\_size\_allowed,+ int access\_size, enum bpf\_access\_type access\_type,+ bool zero\_size\_allowed, struct bpf\_call\_arg\_meta \*meta) { struct bpf\_reg\_state \*regs = cur\_regs(env), \*reg = &regs[regno];@@ -7450,7 +7451,7 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, return check\_packet\_access(env, regno, reg->off, access\_size, zero\_size\_allowed); case PTR\_TO\_MAP\_KEY:- if (meta && meta->raw\_mode) {+ if (access\_type == BPF\_WRITE) { verbose(env, "R%d cannot write into %s\n", regno, reg\_type\_str(env, reg->type)); return -EACCES;@@ -7458,15 +7459,13 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, return check\_mem\_region\_access(env, regno, reg->off, access\_size, reg->map\_ptr->key\_size, false); case PTR\_TO\_MAP\_VALUE:- if (check\_map\_access\_type(env, regno, reg->off, access\_size,- meta && meta->raw\_mode ? BPF\_WRITE :- BPF\_READ))+ if (check\_map\_access\_type(env, regno, reg->off, access\_size, access\_type)) return -EACCES; return check\_map\_access(env, regno, reg->off, access\_size, zero\_size\_allowed, ACCESS\_HELPER); case PTR\_TO\_MEM: if (type\_is\_rdonly\_mem(reg->type)) {- if (meta && meta->raw\_mode) {+ if (access\_type == BPF\_WRITE) { verbose(env, "R%d cannot write into %s\n", regno, reg\_type\_str(env, reg->type)); return -EACCES;@@ -7477,7 +7476,7 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, zero\_size\_allowed); case PTR\_TO\_BUF: if (type\_is\_rdonly\_mem(reg->type)) {- if (meta && meta->raw\_mode) {+ if (access\_type == BPF\_WRITE) { verbose(env, "R%d cannot write into %s\n", regno, reg\_type\_str(env, reg->type)); return -EACCES;@@ -7505,7 +7504,6 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, \* Dynamically check it now. \*/ if (!env->ops->convert\_ctx\_access) {- enum bpf\_access\_type atype = meta && meta->raw\_mode ? BPF\_WRITE : BPF\_READ; int offset = access\_size - 1;  /\* Allow zero-byte read from PTR\_TO\_CTX \*/@@ -7513,7 +7511,7 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, return zero\_size\_allowed ? 0 : -EACCES;  return check\_mem\_access(env, env->insn\_idx, regno, offset, BPF\_B,- atype, -1, false, false);+ access\_type, -1, false, false); }  fallthrough;@@ -7538,6 +7536,7 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, \*/ static int check\_mem\_size\_reg(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg, u32 regno,+ enum bpf\_access\_type access\_type, bool zero\_size\_allowed, struct bpf\_call\_arg\_meta \*meta) {@@ -7553,15 +7552,12 @@ static int check\_mem\_size\_reg(struct bpf\_verifier\_env \*env, \*/ meta->msize\_max\_value = reg->umax\_value; - /\* The register is SCALAR\_VALUE; the access check- \* happens using its boundaries.+ /\* The register is SCALAR\_VALUE; the access check happens using+ \* its boundaries. For unprivileged variable accesses, disable+ \* raw mode so that the program is required to initialize all+ \* the memory that the helper could just partially fill up. \*/ if (!tnum\_is\_const(reg->var\_off))- /\* For unprivileged variable accesses, disable raw- \* mode so that the program is required to- \* initialize all the memory that the helper could- \* just partially fill up.- \*/ meta = NULL;  if (reg->smin\_value < 0) {@@ -7581,9 +7577,8 @@ static int check\_mem\_size\_reg(struct bpf\_verifier\_env \*env, regno); return -EACCES; }- err = check\_helper\_mem\_access(env, regno - 1,- reg->umax\_value,- zero\_size\_allowed, meta);+ err = check\_helper\_mem\_access(env, regno - 1, reg->umax\_value,+ access\_type, zero\_size\_allowed, meta); if (!err) err = mark\_chain\_precision(env, regno); return err;@@ -7594,13 +7589,11 @@ static int check\_mem\_reg(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg { bool may\_be\_null = type\_may\_be\_null(reg->type); struct bpf\_reg\_state saved\_reg;- struct bpf\_call\_arg\_meta meta; int err;  if (register\_is\_null(reg)) return 0; - memset(&meta, 0, sizeof(meta)); /\* Assuming that the register contains a value check if the memory \* access is safe. Temporarily save and restore the register's state as \* the conversion shouldn't be visible to a caller.@@ -7610,10 +7603,8 @@ static int check\_mem\_reg(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg mark\_ptr\_not\_null\_reg(reg); } - err = check\_helper\_mem\_access(env, regno, mem\_size, true, &meta);- /\* Check access for BPF\_WRITE \*/- meta.raw\_mode = true;- err = err ?: check\_helper\_mem\_access(env, regno, mem\_size, true, &meta);+ err = check\_helper\_mem\_access(env, regno, mem\_size, BPF\_READ, true, NULL);+ err = err ?: check\_helper\_mem\_access(env, regno, mem\_size, BPF\_WRITE, true, NULL);  if (may\_be\_null) \*reg = saved\_reg;@@ -7639,13 +7630,12 @@ static int check\_kfunc\_mem\_size\_reg(struct bpf\_verifier\_env \*env, struct bpf\_reg mark\_ptr\_not\_null\_reg(mem\_reg); } - err = check\_mem\_size\_reg(env, reg, regno, true, &meta);- /\* Check access for BPF\_WRITE \*/- meta.raw\_mode = true;- err = err ?: check\_mem\_size\_reg(env, reg, regno, true, &meta);+ err = check\_mem\_size\_reg(env, reg, regno, BPF\_READ, true, &meta);+ err = err ?: check\_mem\_size\_reg(env, reg, regno, BPF\_WRITE, true, &meta);  if (may\_be\_null) \*mem\_reg = saved\_reg;+ return err; } @@ -8948,9 +8938,8 @@ skip\_type\_check: verbose(env, "invalid map\_ptr to access map->key\n"); return -EACCES; }- err = check\_helper\_mem\_access(env, regno,- meta->map\_ptr->key\_size, false,- NULL);+ err = check\_helper\_mem\_access(env, regno, meta->map\_ptr->key\_size,+ BPF\_READ, false, NULL); break; case ARG\_PTR\_TO\_MAP\_VALUE: if (type\_may\_be\_null(arg\_type) && register\_is\_null(reg))@@ -8965,9 +8954,9 @@ skip\_type\_check: return -EACCES; } meta->raw\_mode = arg\_type & MEM\_UNINIT;- err = check\_helper\_mem\_access(env, regno,- meta->map\_ptr->value\_size, false,- meta);+ err = check\_helper\_mem\_access(env, regno, meta->map\_ptr->value\_size,+ arg\_type & MEM\_WRITE ? BPF\_WRITE : BPF\_READ,+ false, meta); break; case ARG\_PTR\_TO\_PERCPU\_BTF\_ID: if (!reg->btf\_id) {@@ -9009,7 +8998,9 @@ skip\_type\_check: \*/ meta->raw\_mode = arg\_type & MEM\_UNINIT; if (arg\_type & MEM\_FIXED\_SIZE) {- err = check\_helper\_mem\_access(env, regno, fn->arg\_size[arg], false, meta);+ err = check\_helper\_mem\_access(env, regno, fn->arg\_size[arg],+ arg\_type & MEM\_WRITE ? BPF\_WRITE : BPF\_READ,+ false, meta); if (err) return err; if (arg\_type & MEM\_ALIGNED)@@ -9017,10 +9008,16 @@ skip\_type\_check: } break; case ARG\_CONST\_SIZE:- err = check\_mem\_size\_reg(env, reg, regno, false, meta);+ err = check\_mem\_size\_reg(env, reg, regno,+ fn->arg\_type[arg - 1] & MEM\_WRITE ?+ BPF\_WRITE : BPF\_READ,+ false, meta); break; case ARG\_CONST\_SIZE\_OR\_ZERO:- err = check\_mem\_size\_reg(env, reg, regno, true, meta);+ err = check\_mem\_size\_reg(env, reg, regno,+ fn->arg\_type[arg - 1] & MEM\_WRITE ?+ BPF\_WRITE : BPF\_READ,+ true, meta); break; case ARG\_PTR\_TO\_DYNPTR: err = process\_dynptr\_func(env, regno, insn\_idx, arg\_type, 0); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 21:40:08 +0000



=== Content from git.kernel.org_cebfba65_20250114_214130.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=54bc31682660810af1bed7ca7a19f182df8d3df8)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=54bc31682660810af1bed7ca7a19f182df8d3df8)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=54bc31682660810af1bed7ca7a19f182df8d3df8)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=54bc31682660810af1bed7ca7a19f182df8d3df8)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Daniel Borkmann <daniel@iogearbox.net> | 2024-10-21 17:28:06 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-01 02:02:36 +0100 |
| commit | [54bc31682660810af1bed7ca7a19f182df8d3df8](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=54bc31682660810af1bed7ca7a19f182df8d3df8) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=54bc31682660810af1bed7ca7a19f182df8d3df8)) | |
| tree | [1ac9b0bb8d16af16393c9432ef6662acdadddd5e](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=54bc31682660810af1bed7ca7a19f182df8d3df8) | |
| parent | [c98ec907367573c9b9761c587231ff09026de495](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c98ec907367573c9b9761c587231ff09026de495) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=54bc31682660810af1bed7ca7a19f182df8d3df8&id2=c98ec907367573c9b9761c587231ff09026de495)) | |
| download | [linux-54bc31682660810af1bed7ca7a19f182df8d3df8.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-54bc31682660810af1bed7ca7a19f182df8d3df8.tar.gz) | |

bpf: Fix overloading of MEM\_UNINIT's meaning[ Upstream commit 8ea607330a39184f51737c6ae706db7fdca7628e ]
Lonial reported an issue in the BPF verifier where check\_mem\_size\_reg()
has the following code:
if (!tnum\_is\_const(reg->var\_off))
/\* For unprivileged variable accesses, disable raw
\* mode so that the program is required to
\* initialize all the memory that the helper could
\* just partially fill up.
\*/
meta = NULL;
This means that writes are not checked when the register containing the
size of the passed buffer has not a fixed size. Through this bug, a BPF
program can write to a map which is marked as read-only, for example,
.rodata global maps.
The problem is that MEM\_UNINIT's initial meaning that "the passed buffer
to the BPF helper does not need to be initialized" which was added back
in commit 435faee1aae9 ("bpf, verifier: add ARG\_PTR\_TO\_RAW\_STACK type")
got overloaded over time with "the passed buffer is being written to".
The problem however is that checks such as the above which were added later
via 06c1c049721a ("bpf: allow helpers access to variable memory") set meta
to NULL in order force the user to always initialize the passed buffer to
the helper. Due to the current double meaning of MEM\_UNINIT, this bypasses
verifier write checks to the memory (not boundary checks though) and only
assumes the latter memory is read instead.
Fix this by reverting MEM\_UNINIT back to its original meaning, and having
MEM\_WRITE as an annotation to BPF helpers in order to then trigger the
BPF verifier checks for writing to memory.
Some notes: check\_arg\_pair\_ok() ensures that for ARG\_CONST\_SIZE{,\_OR\_ZERO}
we can access fn->arg\_type[arg - 1] since it must contain a preceding
ARG\_PTR\_TO\_MEM. For check\_mem\_reg() the meta argument can be removed
altogether since we do check both BPF\_READ and BPF\_WRITE. Same for the
equivalent check\_kfunc\_mem\_size\_reg().
Fixes: 7b3552d3f9f6 ("bpf: Reject writes for PTR\_TO\_MAP\_KEY in check\_helper\_mem\_access")
Fixes: 97e6d7dab1ca ("bpf: Check PTR\_TO\_MEM | MEM\_RDONLY in check\_helper\_mem\_access")
Fixes: 15baa55ff5b0 ("bpf/verifier: allow all functions to read user provided context")
Reported-by: Lonial Con <kongln9170@gmail.com>
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Kumar Kartikeya Dwivedi <memxor@gmail.com>
Link: [https://lore.kernel.org/r/20241021152809.33343-2-daniel@iogearbox.net](https://lore.kernel.org/r/20241021152809.33343-2-daniel%40iogearbox.net)
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=54bc31682660810af1bed7ca7a19f182df8d3df8)

| -rw-r--r-- | [kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/verifier.c?id=54bc31682660810af1bed7ca7a19f182df8d3df8) | 73 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 35 insertions, 38 deletions

| diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex 5b8b1d0e76cf1c..62efe7f0aa46f3 100644--- a/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=c98ec907367573c9b9761c587231ff09026de495)+++ b/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=54bc31682660810af1bed7ca7a19f182df8d3df8)@@ -7344,7 +7344,8 @@ mark: }  static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno,- int access\_size, bool zero\_size\_allowed,+ int access\_size, enum bpf\_access\_type access\_type,+ bool zero\_size\_allowed, struct bpf\_call\_arg\_meta \*meta) { struct bpf\_reg\_state \*regs = cur\_regs(env), \*reg = &regs[regno];@@ -7356,7 +7357,7 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, return check\_packet\_access(env, regno, reg->off, access\_size, zero\_size\_allowed); case PTR\_TO\_MAP\_KEY:- if (meta && meta->raw\_mode) {+ if (access\_type == BPF\_WRITE) { verbose(env, "R%d cannot write into %s\n", regno, reg\_type\_str(env, reg->type)); return -EACCES;@@ -7364,15 +7365,13 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, return check\_mem\_region\_access(env, regno, reg->off, access\_size, reg->map\_ptr->key\_size, false); case PTR\_TO\_MAP\_VALUE:- if (check\_map\_access\_type(env, regno, reg->off, access\_size,- meta && meta->raw\_mode ? BPF\_WRITE :- BPF\_READ))+ if (check\_map\_access\_type(env, regno, reg->off, access\_size, access\_type)) return -EACCES; return check\_map\_access(env, regno, reg->off, access\_size, zero\_size\_allowed, ACCESS\_HELPER); case PTR\_TO\_MEM: if (type\_is\_rdonly\_mem(reg->type)) {- if (meta && meta->raw\_mode) {+ if (access\_type == BPF\_WRITE) { verbose(env, "R%d cannot write into %s\n", regno, reg\_type\_str(env, reg->type)); return -EACCES;@@ -7383,7 +7382,7 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, zero\_size\_allowed); case PTR\_TO\_BUF: if (type\_is\_rdonly\_mem(reg->type)) {- if (meta && meta->raw\_mode) {+ if (access\_type == BPF\_WRITE) { verbose(env, "R%d cannot write into %s\n", regno, reg\_type\_str(env, reg->type)); return -EACCES;@@ -7411,7 +7410,6 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, \* Dynamically check it now. \*/ if (!env->ops->convert\_ctx\_access) {- enum bpf\_access\_type atype = meta && meta->raw\_mode ? BPF\_WRITE : BPF\_READ; int offset = access\_size - 1;  /\* Allow zero-byte read from PTR\_TO\_CTX \*/@@ -7419,7 +7417,7 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, return zero\_size\_allowed ? 0 : -EACCES;  return check\_mem\_access(env, env->insn\_idx, regno, offset, BPF\_B,- atype, -1, false, false);+ access\_type, -1, false, false); }  fallthrough;@@ -7444,6 +7442,7 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, \*/ static int check\_mem\_size\_reg(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg, u32 regno,+ enum bpf\_access\_type access\_type, bool zero\_size\_allowed, struct bpf\_call\_arg\_meta \*meta) {@@ -7459,15 +7458,12 @@ static int check\_mem\_size\_reg(struct bpf\_verifier\_env \*env, \*/ meta->msize\_max\_value = reg->umax\_value; - /\* The register is SCALAR\_VALUE; the access check- \* happens using its boundaries.+ /\* The register is SCALAR\_VALUE; the access check happens using+ \* its boundaries. For unprivileged variable accesses, disable+ \* raw mode so that the program is required to initialize all+ \* the memory that the helper could just partially fill up. \*/ if (!tnum\_is\_const(reg->var\_off))- /\* For unprivileged variable accesses, disable raw- \* mode so that the program is required to- \* initialize all the memory that the helper could- \* just partially fill up.- \*/ meta = NULL;  if (reg->smin\_value < 0) {@@ -7487,9 +7483,8 @@ static int check\_mem\_size\_reg(struct bpf\_verifier\_env \*env, regno); return -EACCES; }- err = check\_helper\_mem\_access(env, regno - 1,- reg->umax\_value,- zero\_size\_allowed, meta);+ err = check\_helper\_mem\_access(env, regno - 1, reg->umax\_value,+ access\_type, zero\_size\_allowed, meta); if (!err) err = mark\_chain\_precision(env, regno); return err;@@ -7500,13 +7495,11 @@ static int check\_mem\_reg(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg { bool may\_be\_null = type\_may\_be\_null(reg->type); struct bpf\_reg\_state saved\_reg;- struct bpf\_call\_arg\_meta meta; int err;  if (register\_is\_null(reg)) return 0; - memset(&meta, 0, sizeof(meta)); /\* Assuming that the register contains a value check if the memory \* access is safe. Temporarily save and restore the register's state as \* the conversion shouldn't be visible to a caller.@@ -7516,10 +7509,8 @@ static int check\_mem\_reg(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg mark\_ptr\_not\_null\_reg(reg); } - err = check\_helper\_mem\_access(env, regno, mem\_size, true, &meta);- /\* Check access for BPF\_WRITE \*/- meta.raw\_mode = true;- err = err ?: check\_helper\_mem\_access(env, regno, mem\_size, true, &meta);+ err = check\_helper\_mem\_access(env, regno, mem\_size, BPF\_READ, true, NULL);+ err = err ?: check\_helper\_mem\_access(env, regno, mem\_size, BPF\_WRITE, true, NULL);  if (may\_be\_null) \*reg = saved\_reg;@@ -7545,13 +7536,12 @@ static int check\_kfunc\_mem\_size\_reg(struct bpf\_verifier\_env \*env, struct bpf\_reg mark\_ptr\_not\_null\_reg(mem\_reg); } - err = check\_mem\_size\_reg(env, reg, regno, true, &meta);- /\* Check access for BPF\_WRITE \*/- meta.raw\_mode = true;- err = err ?: check\_mem\_size\_reg(env, reg, regno, true, &meta);+ err = check\_mem\_size\_reg(env, reg, regno, BPF\_READ, true, &meta);+ err = err ?: check\_mem\_size\_reg(env, reg, regno, BPF\_WRITE, true, &meta);  if (may\_be\_null) \*mem\_reg = saved\_reg;+ return err; } @@ -8825,9 +8815,8 @@ skip\_type\_check: verbose(env, "invalid map\_ptr to access map->key\n"); return -EACCES; }- err = check\_helper\_mem\_access(env, regno,- meta->map\_ptr->key\_size, false,- NULL);+ err = check\_helper\_mem\_access(env, regno, meta->map\_ptr->key\_size,+ BPF\_READ, false, NULL); break; case ARG\_PTR\_TO\_MAP\_VALUE: if (type\_may\_be\_null(arg\_type) && register\_is\_null(reg))@@ -8842,9 +8831,9 @@ skip\_type\_check: return -EACCES; } meta->raw\_mode = arg\_type & MEM\_UNINIT;- err = check\_helper\_mem\_access(env, regno,- meta->map\_ptr->value\_size, false,- meta);+ err = check\_helper\_mem\_access(env, regno, meta->map\_ptr->value\_size,+ arg\_type & MEM\_WRITE ? BPF\_WRITE : BPF\_READ,+ false, meta); break; case ARG\_PTR\_TO\_PERCPU\_BTF\_ID: if (!reg->btf\_id) {@@ -8886,7 +8875,9 @@ skip\_type\_check: \*/ meta->raw\_mode = arg\_type & MEM\_UNINIT; if (arg\_type & MEM\_FIXED\_SIZE) {- err = check\_helper\_mem\_access(env, regno, fn->arg\_size[arg], false, meta);+ err = check\_helper\_mem\_access(env, regno, fn->arg\_size[arg],+ arg\_type & MEM\_WRITE ? BPF\_WRITE : BPF\_READ,+ false, meta); if (err) return err; if (arg\_type & MEM\_ALIGNED)@@ -8894,10 +8885,16 @@ skip\_type\_check: } break; case ARG\_CONST\_SIZE:- err = check\_mem\_size\_reg(env, reg, regno, false, meta);+ err = check\_mem\_size\_reg(env, reg, regno,+ fn->arg\_type[arg - 1] & MEM\_WRITE ?+ BPF\_WRITE : BPF\_READ,+ false, meta); break; case ARG\_CONST\_SIZE\_OR\_ZERO:- err = check\_mem\_size\_reg(env, reg, regno, true, meta);+ err = check\_mem\_size\_reg(env, reg, regno,+ fn->arg\_type[arg - 1] & MEM\_WRITE ?+ BPF\_WRITE : BPF\_READ,+ true, meta); break; case ARG\_PTR\_TO\_DYNPTR: err = process\_dynptr\_func(env, regno, insn\_idx, arg\_type, 0); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 21:40:07 +0000



=== Content from git.kernel.org_8d885d8f_20250114_214128.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=48068ccaea957469f1adf78dfd2c1c9a7e18f0fe)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=48068ccaea957469f1adf78dfd2c1c9a7e18f0fe)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=48068ccaea957469f1adf78dfd2c1c9a7e18f0fe)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=48068ccaea957469f1adf78dfd2c1c9a7e18f0fe)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Daniel Borkmann <daniel@iogearbox.net> | 2024-10-21 17:28:06 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-01 01:58:30 +0100 |
| commit | [48068ccaea957469f1adf78dfd2c1c9a7e18f0fe](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=48068ccaea957469f1adf78dfd2c1c9a7e18f0fe) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=48068ccaea957469f1adf78dfd2c1c9a7e18f0fe)) | |
| tree | [df3f461d055bee5a20026e7cd434b45a4cd938d9](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=48068ccaea957469f1adf78dfd2c1c9a7e18f0fe) | |
| parent | [8a33a047bd31a7047b8dffe688c2c10e1ab871eb](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8a33a047bd31a7047b8dffe688c2c10e1ab871eb) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=48068ccaea957469f1adf78dfd2c1c9a7e18f0fe&id2=8a33a047bd31a7047b8dffe688c2c10e1ab871eb)) | |
| download | [linux-48068ccaea957469f1adf78dfd2c1c9a7e18f0fe.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-48068ccaea957469f1adf78dfd2c1c9a7e18f0fe.tar.gz) | |

bpf: Fix overloading of MEM\_UNINIT's meaning[ Upstream commit 8ea607330a39184f51737c6ae706db7fdca7628e ]
Lonial reported an issue in the BPF verifier where check\_mem\_size\_reg()
has the following code:
if (!tnum\_is\_const(reg->var\_off))
/\* For unprivileged variable accesses, disable raw
\* mode so that the program is required to
\* initialize all the memory that the helper could
\* just partially fill up.
\*/
meta = NULL;
This means that writes are not checked when the register containing the
size of the passed buffer has not a fixed size. Through this bug, a BPF
program can write to a map which is marked as read-only, for example,
.rodata global maps.
The problem is that MEM\_UNINIT's initial meaning that "the passed buffer
to the BPF helper does not need to be initialized" which was added back
in commit 435faee1aae9 ("bpf, verifier: add ARG\_PTR\_TO\_RAW\_STACK type")
got overloaded over time with "the passed buffer is being written to".
The problem however is that checks such as the above which were added later
via 06c1c049721a ("bpf: allow helpers access to variable memory") set meta
to NULL in order force the user to always initialize the passed buffer to
the helper. Due to the current double meaning of MEM\_UNINIT, this bypasses
verifier write checks to the memory (not boundary checks though) and only
assumes the latter memory is read instead.
Fix this by reverting MEM\_UNINIT back to its original meaning, and having
MEM\_WRITE as an annotation to BPF helpers in order to then trigger the
BPF verifier checks for writing to memory.
Some notes: check\_arg\_pair\_ok() ensures that for ARG\_CONST\_SIZE{,\_OR\_ZERO}
we can access fn->arg\_type[arg - 1] since it must contain a preceding
ARG\_PTR\_TO\_MEM. For check\_mem\_reg() the meta argument can be removed
altogether since we do check both BPF\_READ and BPF\_WRITE. Same for the
equivalent check\_kfunc\_mem\_size\_reg().
Fixes: 7b3552d3f9f6 ("bpf: Reject writes for PTR\_TO\_MAP\_KEY in check\_helper\_mem\_access")
Fixes: 97e6d7dab1ca ("bpf: Check PTR\_TO\_MEM | MEM\_RDONLY in check\_helper\_mem\_access")
Fixes: 15baa55ff5b0 ("bpf/verifier: allow all functions to read user provided context")
Reported-by: Lonial Con <kongln9170@gmail.com>
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Kumar Kartikeya Dwivedi <memxor@gmail.com>
Link: [https://lore.kernel.org/r/20241021152809.33343-2-daniel@iogearbox.net](https://lore.kernel.org/r/20241021152809.33343-2-daniel%40iogearbox.net)
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=48068ccaea957469f1adf78dfd2c1c9a7e18f0fe)

| -rw-r--r-- | [kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/verifier.c?id=48068ccaea957469f1adf78dfd2c1c9a7e18f0fe) | 73 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 35 insertions, 38 deletions

| diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex f24d570d67ca5f..03b5797b8fca9e 100644--- a/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=8a33a047bd31a7047b8dffe688c2c10e1ab871eb)+++ b/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=48068ccaea957469f1adf78dfd2c1c9a7e18f0fe)@@ -7198,7 +7198,8 @@ mark: }  static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno,- int access\_size, bool zero\_size\_allowed,+ int access\_size, enum bpf\_access\_type access\_type,+ bool zero\_size\_allowed, struct bpf\_call\_arg\_meta \*meta) { struct bpf\_reg\_state \*regs = cur\_regs(env), \*reg = &regs[regno];@@ -7210,7 +7211,7 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, return check\_packet\_access(env, regno, reg->off, access\_size, zero\_size\_allowed); case PTR\_TO\_MAP\_KEY:- if (meta && meta->raw\_mode) {+ if (access\_type == BPF\_WRITE) { verbose(env, "R%d cannot write into %s\n", regno, reg\_type\_str(env, reg->type)); return -EACCES;@@ -7218,15 +7219,13 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, return check\_mem\_region\_access(env, regno, reg->off, access\_size, reg->map\_ptr->key\_size, false); case PTR\_TO\_MAP\_VALUE:- if (check\_map\_access\_type(env, regno, reg->off, access\_size,- meta && meta->raw\_mode ? BPF\_WRITE :- BPF\_READ))+ if (check\_map\_access\_type(env, regno, reg->off, access\_size, access\_type)) return -EACCES; return check\_map\_access(env, regno, reg->off, access\_size, zero\_size\_allowed, ACCESS\_HELPER); case PTR\_TO\_MEM: if (type\_is\_rdonly\_mem(reg->type)) {- if (meta && meta->raw\_mode) {+ if (access\_type == BPF\_WRITE) { verbose(env, "R%d cannot write into %s\n", regno, reg\_type\_str(env, reg->type)); return -EACCES;@@ -7237,7 +7236,7 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, zero\_size\_allowed); case PTR\_TO\_BUF: if (type\_is\_rdonly\_mem(reg->type)) {- if (meta && meta->raw\_mode) {+ if (access\_type == BPF\_WRITE) { verbose(env, "R%d cannot write into %s\n", regno, reg\_type\_str(env, reg->type)); return -EACCES;@@ -7265,7 +7264,6 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, \* Dynamically check it now. \*/ if (!env->ops->convert\_ctx\_access) {- enum bpf\_access\_type atype = meta && meta->raw\_mode ? BPF\_WRITE : BPF\_READ; int offset = access\_size - 1;  /\* Allow zero-byte read from PTR\_TO\_CTX \*/@@ -7273,7 +7271,7 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, return zero\_size\_allowed ? 0 : -EACCES;  return check\_mem\_access(env, env->insn\_idx, regno, offset, BPF\_B,- atype, -1, false, false);+ access\_type, -1, false, false); }  fallthrough;@@ -7292,6 +7290,7 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno,  static int check\_mem\_size\_reg(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg, u32 regno,+ enum bpf\_access\_type access\_type, bool zero\_size\_allowed, struct bpf\_call\_arg\_meta \*meta) {@@ -7307,15 +7306,12 @@ static int check\_mem\_size\_reg(struct bpf\_verifier\_env \*env, \*/ meta->msize\_max\_value = reg->umax\_value; - /\* The register is SCALAR\_VALUE; the access check- \* happens using its boundaries.+ /\* The register is SCALAR\_VALUE; the access check happens using+ \* its boundaries. For unprivileged variable accesses, disable+ \* raw mode so that the program is required to initialize all+ \* the memory that the helper could just partially fill up. \*/ if (!tnum\_is\_const(reg->var\_off))- /\* For unprivileged variable accesses, disable raw- \* mode so that the program is required to- \* initialize all the memory that the helper could- \* just partially fill up.- \*/ meta = NULL;  if (reg->smin\_value < 0) {@@ -7335,9 +7331,8 @@ static int check\_mem\_size\_reg(struct bpf\_verifier\_env \*env, regno); return -EACCES; }- err = check\_helper\_mem\_access(env, regno - 1,- reg->umax\_value,- zero\_size\_allowed, meta);+ err = check\_helper\_mem\_access(env, regno - 1, reg->umax\_value,+ access\_type, zero\_size\_allowed, meta); if (!err) err = mark\_chain\_precision(env, regno); return err;@@ -7348,13 +7343,11 @@ int check\_mem\_reg(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg, { bool may\_be\_null = type\_may\_be\_null(reg->type); struct bpf\_reg\_state saved\_reg;- struct bpf\_call\_arg\_meta meta; int err;  if (register\_is\_null(reg)) return 0; - memset(&meta, 0, sizeof(meta)); /\* Assuming that the register contains a value check if the memory \* access is safe. Temporarily save and restore the register's state as \* the conversion shouldn't be visible to a caller.@@ -7364,10 +7357,8 @@ int check\_mem\_reg(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg, mark\_ptr\_not\_null\_reg(reg); } - err = check\_helper\_mem\_access(env, regno, mem\_size, true, &meta);- /\* Check access for BPF\_WRITE \*/- meta.raw\_mode = true;- err = err ?: check\_helper\_mem\_access(env, regno, mem\_size, true, &meta);+ err = check\_helper\_mem\_access(env, regno, mem\_size, BPF\_READ, true, NULL);+ err = err ?: check\_helper\_mem\_access(env, regno, mem\_size, BPF\_WRITE, true, NULL);  if (may\_be\_null) \*reg = saved\_reg;@@ -7393,13 +7384,12 @@ static int check\_kfunc\_mem\_size\_reg(struct bpf\_verifier\_env \*env, struct bpf\_reg mark\_ptr\_not\_null\_reg(mem\_reg); } - err = check\_mem\_size\_reg(env, reg, regno, true, &meta);- /\* Check access for BPF\_WRITE \*/- meta.raw\_mode = true;- err = err ?: check\_mem\_size\_reg(env, reg, regno, true, &meta);+ err = check\_mem\_size\_reg(env, reg, regno, BPF\_READ, true, &meta);+ err = err ?: check\_mem\_size\_reg(env, reg, regno, BPF\_WRITE, true, &meta);  if (may\_be\_null) \*mem\_reg = saved\_reg;+ return err; } @@ -8585,9 +8575,8 @@ skip\_type\_check: verbose(env, "invalid map\_ptr to access map->key\n"); return -EACCES; }- err = check\_helper\_mem\_access(env, regno,- meta->map\_ptr->key\_size, false,- NULL);+ err = check\_helper\_mem\_access(env, regno, meta->map\_ptr->key\_size,+ BPF\_READ, false, NULL); break; case ARG\_PTR\_TO\_MAP\_VALUE: if (type\_may\_be\_null(arg\_type) && register\_is\_null(reg))@@ -8602,9 +8591,9 @@ skip\_type\_check: return -EACCES; } meta->raw\_mode = arg\_type & MEM\_UNINIT;- err = check\_helper\_mem\_access(env, regno,- meta->map\_ptr->value\_size, false,- meta);+ err = check\_helper\_mem\_access(env, regno, meta->map\_ptr->value\_size,+ arg\_type & MEM\_WRITE ? BPF\_WRITE : BPF\_READ,+ false, meta); break; case ARG\_PTR\_TO\_PERCPU\_BTF\_ID: if (!reg->btf\_id) {@@ -8646,7 +8635,9 @@ skip\_type\_check: \*/ meta->raw\_mode = arg\_type & MEM\_UNINIT; if (arg\_type & MEM\_FIXED\_SIZE) {- err = check\_helper\_mem\_access(env, regno, fn->arg\_size[arg], false, meta);+ err = check\_helper\_mem\_access(env, regno, fn->arg\_size[arg],+ arg\_type & MEM\_WRITE ? BPF\_WRITE : BPF\_READ,+ false, meta); if (err) return err; if (arg\_type & MEM\_ALIGNED)@@ -8654,10 +8645,16 @@ skip\_type\_check: } break; case ARG\_CONST\_SIZE:- err = check\_mem\_size\_reg(env, reg, regno, false, meta);+ err = check\_mem\_size\_reg(env, reg, regno,+ fn->arg\_type[arg - 1] & MEM\_WRITE ?+ BPF\_WRITE : BPF\_READ,+ false, meta); break; case ARG\_CONST\_SIZE\_OR\_ZERO:- err = check\_mem\_size\_reg(env, reg, regno, true, meta);+ err = check\_mem\_size\_reg(env, reg, regno,+ fn->arg\_type[arg - 1] & MEM\_WRITE ?+ BPF\_WRITE : BPF\_READ,+ true, meta); break; case ARG\_PTR\_TO\_DYNPTR: err = process\_dynptr\_func(env, regno, insn\_idx, arg\_type, 0); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 21:40:05 +0000


