```
{
  "vulnerability": {
    "root_cause": "A race condition exists in the Linux kernel's memory management subsystem when moving page tables during mremap operations, specifically when handling Transparent Huge Pages (THP). The race occurs between the `move_normal_pmd` function, which moves page tables during mremap, and the `retract_page_tables` function, which removes page tables during THP collapsing.",
    "weaknesses": [
      "The rmap locks, which protect against concurrent page table removal by `retract_page_tables`, are only taken after the PMD entry has been read and it has been decided how to move it. This allows for a race condition where the PMD entry may be invalidated by `retract_page_tables` after `move_page_tables` reads it but before `move_normal_pmd` acquires the rmap locks. This can lead to `move_normal_pmd` creating bogus PMD entries."
    ],
    "impact": "The vulnerability can lead to the creation of invalid PMD entries, potentially mapping physical page 0 as a page table. This can result in user-to-kernel privilege escalation, as an attacker can manipulate the page table mappings to gain control over kernel memory.",
    "attack_vectors": "The attack vector involves two processes: one performing an `mremap` operation and another triggering a THP collapse through `madvise(MADV_COLLAPSE)`. The race condition occurs when `retract_page_tables` invalidates a PMD entry between the time `move_page_tables` reads the entry and `move_normal_pmd` acquires rmap locks. This race needs to happen on a shared memory mapping between the two processes.",
    "required_capabilities": "To trigger this vulnerability, an attacker needs to be able to create shared memory or file THP mappings. For shmem THP, this typically requires the ability to mount a tmpfs filesystem with specific flags, which may necessitate a user or mount namespace. For file THP the CONFIG_READ_ONLY_THP_FOR_FS needs to be set which is an experimental config flag and not set on most kernels."
  },
  "fix": "The fix involves adding a check in `move_normal_pmd` to verify that the PMD still points to a page table after acquiring the rmap locks, and before attempting to move the table. If the PMD entry is no longer valid, the function will bail out and let the caller fall back to the PTE level copying path."
}
```