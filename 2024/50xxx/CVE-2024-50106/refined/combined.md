=== Content from git.kernel.org_fa6bcef8_20250114_192542.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=967faa26f313a62e7bebc55d5b8122eaee43b929)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=967faa26f313a62e7bebc55d5b8122eaee43b929)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=967faa26f313a62e7bebc55d5b8122eaee43b929)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=967faa26f313a62e7bebc55d5b8122eaee43b929)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Olga Kornievskaia <okorniev@redhat.com> | 2024-10-18 15:24:58 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-01 02:02:42 +0100 |
| commit | [967faa26f313a62e7bebc55d5b8122eaee43b929](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=967faa26f313a62e7bebc55d5b8122eaee43b929) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=967faa26f313a62e7bebc55d5b8122eaee43b929)) | |
| tree | [5b438a9e327ec9bd76d00bc0fa44712603a62814](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=967faa26f313a62e7bebc55d5b8122eaee43b929) | |
| parent | [b2b7f4c3a5e3ece2176cefbf63ad0e3b3f170a9f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b2b7f4c3a5e3ece2176cefbf63ad0e3b3f170a9f) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=967faa26f313a62e7bebc55d5b8122eaee43b929&id2=b2b7f4c3a5e3ece2176cefbf63ad0e3b3f170a9f)) | |
| download | [linux-967faa26f313a62e7bebc55d5b8122eaee43b929.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-967faa26f313a62e7bebc55d5b8122eaee43b929.tar.gz) | |

nfsd: fix race between laundromat and free\_stateidcommit 8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a upstream.
There is a race between laundromat handling of revoked delegations
and a client sending free\_stateid operation. Laundromat thread
finds that delegation has expired and needs to be revoked so it
marks the delegation stid revoked and it puts it on a reaper list
but then it unlock the state lock and the actual delegation revocation
happens without the lock. Once the stid is marked revoked a racing
free\_stateid processing thread does the following (1) it calls
list\_del\_init() which removes it from the reaper list and (2) frees
the delegation stid structure. The laundromat thread ends up not
calling the revoke\_delegation() function for this particular delegation
but that means it will no release the lock lease that exists on
the file.
Now, a new open for this file comes in and ends up finding that
lease list isn't empty and calls nfsd\_breaker\_owns\_lease() which ends
up trying to derefence a freed delegation stateid. Leading to the
followint use-after-free KASAN warning:
kernel: ==================================================================
kernel: BUG: KASAN: slab-use-after-free in nfsd\_breaker\_owns\_lease+0x140/0x160 [nfsd]
kernel: Read of size 8 at addr ffff0000e73cd0c8 by task nfsd/6205
kernel:
kernel: CPU: 2 UID: 0 PID: 6205 Comm: nfsd Kdump: loaded Not tainted 6.11.0-rc7+ #9
kernel: Hardware name: Apple Inc. Apple Virtualization Generic Platform, BIOS 2069.0.0.0.0 08/03/2024
kernel: Call trace:
kernel: dump\_backtrace+0x98/0x120
kernel: show\_stack+0x1c/0x30
kernel: dump\_stack\_lvl+0x80/0xe8
kernel: print\_address\_description.constprop.0+0x84/0x390
kernel: print\_report+0xa4/0x268
kernel: kasan\_report+0xb4/0xf8
kernel: \_\_asan\_report\_load8\_noabort+0x1c/0x28
kernel: nfsd\_breaker\_owns\_lease+0x140/0x160 [nfsd]
kernel: nfsd\_file\_do\_acquire+0xb3c/0x11d0 [nfsd]
kernel: nfsd\_file\_acquire\_opened+0x84/0x110 [nfsd]
kernel: nfs4\_get\_vfs\_file+0x634/0x958 [nfsd]
kernel: nfsd4\_process\_open2+0xa40/0x1a40 [nfsd]
kernel: nfsd4\_open+0xa08/0xe80 [nfsd]
kernel: nfsd4\_proc\_compound+0xb8c/0x2130 [nfsd]
kernel: nfsd\_dispatch+0x22c/0x718 [nfsd]
kernel: svc\_process\_common+0x8e8/0x1960 [sunrpc]
kernel: svc\_process+0x3d4/0x7e0 [sunrpc]
kernel: svc\_handle\_xprt+0x828/0xe10 [sunrpc]
kernel: svc\_recv+0x2cc/0x6a8 [sunrpc]
kernel: nfsd+0x270/0x400 [nfsd]
kernel: kthread+0x288/0x310
kernel: ret\_from\_fork+0x10/0x20
This patch proposes a fixed that's based on adding 2 new additional
stid's sc\_status values that help coordinate between the laundromat
and other operations (nfsd4\_free\_stateid() and nfsd4\_delegreturn()).
First to make sure, that once the stid is marked revoked, it is not
removed by the nfsd4\_free\_stateid(), the laundromat take a reference
on the stateid. Then, coordinating whether the stid has been put
on the cl\_revoked list or we are processing FREE\_STATEID and need to
make sure to remove it from the list, each check that state and act
accordingly. If laundromat has added to the cl\_revoke list before
the arrival of FREE\_STATEID, then nfsd4\_free\_stateid() knows to remove
it from the list. If nfsd4\_free\_stateid() finds that operations arrived
before laundromat has placed it on cl\_revoke list, it marks the state
freed and then laundromat will no longer add it to the list.
Also, for nfsd4\_delegreturn() when looking for the specified stid,
we need to access stid that are marked removed or freeable, it means
the laundromat has started processing it but hasn't finished and this
delegreturn needs to return nfserr\_deleg\_revoked and not
nfserr\_bad\_stateid. The latter will not trigger a FREE\_STATEID and the
lack of it will leave this stid on the cl\_revoked list indefinitely.
Fixes: 2d4a532d385f ("nfsd: ensure that clp->cl\_revoked list is protected by clp->cl\_lock")
CC: stable@vger.kernel.org
Signed-off-by: Olga Kornievskaia <okorniev@redhat.com>
Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=967faa26f313a62e7bebc55d5b8122eaee43b929)

| -rw-r--r-- | [fs/nfsd/nfs4state.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/nfsd/nfs4state.c?id=967faa26f313a62e7bebc55d5b8122eaee43b929) | 48 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/nfsd/state.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/nfsd/state.h?id=967faa26f313a62e7bebc55d5b8122eaee43b929) | 2 | |  |  |  | | --- | --- | --- | |

2 files changed, 42 insertions, 8 deletions

| diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.cindex 150b637f03ee65..d96d8cfd1ff86b 100644--- a/[fs/nfsd/nfs4state.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/nfsd/nfs4state.c?id=b2b7f4c3a5e3ece2176cefbf63ad0e3b3f170a9f)+++ b/[fs/nfsd/nfs4state.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/nfsd/nfs4state.c?id=967faa26f313a62e7bebc55d5b8122eaee43b929)@@ -1358,21 +1358,47 @@ static void destroy\_delegation(struct nfs4\_delegation \*dp) destroy\_unhashed\_deleg(dp); } +/\*\*+ \* revoke\_delegation - perform nfs4 delegation structure cleanup+ \* @dp: pointer to the delegation+ \*+ \* This function assumes that it's called either from the administrative+ \* interface (nfsd4\_revoke\_states()) that's revoking a specific delegation+ \* stateid or it's called from a laundromat thread (nfsd4\_landromat()) that+ \* determined that this specific state has expired and needs to be revoked+ \* (both mark state with the appropriate stid sc\_status mode). It is also+ \* assumed that a reference was taken on the @dp state.+ \*+ \* If this function finds that the @dp state is SC\_STATUS\_FREED it means+ \* that a FREE\_STATEID operation for this stateid has been processed and+ \* we can proceed to removing it from recalled list. However, if @dp state+ \* isn't marked SC\_STATUS\_FREED, it means we need place it on the cl\_revoked+ \* list and wait for the FREE\_STATEID to arrive from the client. At the same+ \* time, we need to mark it as SC\_STATUS\_FREEABLE to indicate to the+ \* nfsd4\_free\_stateid() function that this stateid has already been added+ \* to the cl\_revoked list and that nfsd4\_free\_stateid() is now responsible+ \* for removing it from the list. Inspection of where the delegation state+ \* in the revocation process is protected by the clp->cl\_lock.+ \*/ static void revoke\_delegation(struct nfs4\_delegation \*dp) { struct nfs4\_client \*clp = dp->dl\_stid.sc\_client;  WARN\_ON(!list\_empty(&dp->dl\_recall\_lru));+ WARN\_ON\_ONCE(!(dp->dl\_stid.sc\_status &+ (SC\_STATUS\_REVOKED | SC\_STATUS\_ADMIN\_REVOKED)));  trace\_nfsd\_stid\_revoke(&dp->dl\_stid); - if (dp->dl\_stid.sc\_status &- (SC\_STATUS\_REVOKED | SC\_STATUS\_ADMIN\_REVOKED)) {- spin\_lock(&clp->cl\_lock);- refcount\_inc(&dp->dl\_stid.sc\_count);- list\_add(&dp->dl\_recall\_lru, &clp->cl\_revoked);- spin\_unlock(&clp->cl\_lock);+ spin\_lock(&clp->cl\_lock);+ if (dp->dl\_stid.sc\_status & SC\_STATUS\_FREED) {+ list\_del\_init(&dp->dl\_recall\_lru);+ goto out; }+ list\_add(&dp->dl\_recall\_lru, &clp->cl\_revoked);+ dp->dl\_stid.sc\_status |= SC\_STATUS\_FREEABLE;+out:+ spin\_unlock(&clp->cl\_lock); destroy\_unhashed\_deleg(dp); } @@ -1781,6 +1807,7 @@ void nfsd4\_revoke\_states(struct net \*net, struct super\_block \*sb) mutex\_unlock(&stp->st\_mutex); break; case SC\_TYPE\_DELEG:+ refcount\_inc(&stid->sc\_count); dp = delegstateid(stid); spin\_lock(&state\_lock); if (!unhash\_delegation\_locked(@@ -6544,6 +6571,7 @@ nfs4\_laundromat(struct nfsd\_net \*nn) dp = list\_entry (pos, struct nfs4\_delegation, dl\_recall\_lru); if (!state\_expired(&lt, dp->dl\_time)) break;+ refcount\_inc(&dp->dl\_stid.sc\_count); unhash\_delegation\_locked(dp, SC\_STATUS\_REVOKED); list\_add(&dp->dl\_recall\_lru, &reaplist); }@@ -7161,7 +7189,9 @@ nfsd4\_free\_stateid(struct svc\_rqst \*rqstp, struct nfsd4\_compound\_state \*cstate, s->sc\_status |= SC\_STATUS\_CLOSED; spin\_unlock(&s->sc\_lock); dp = delegstateid(s);- list\_del\_init(&dp->dl\_recall\_lru);+ if (s->sc\_status & SC\_STATUS\_FREEABLE)+ list\_del\_init(&dp->dl\_recall\_lru);+ s->sc\_status |= SC\_STATUS\_FREED; spin\_unlock(&cl->cl\_lock); nfs4\_put\_stid(s); ret = nfs\_ok;@@ -7491,7 +7521,9 @@ nfsd4\_delegreturn(struct svc\_rqst \*rqstp, struct nfsd4\_compound\_state \*cstate, if ((status = fh\_verify(rqstp, &cstate->current\_fh, S\_IFREG, 0))) return status; - status = nfsd4\_lookup\_stateid(cstate, stateid, SC\_TYPE\_DELEG, 0, &s, nn);+ status = nfsd4\_lookup\_stateid(cstate, stateid, SC\_TYPE\_DELEG,+ SC\_STATUS\_REVOKED | SC\_STATUS\_FREEABLE,+ &s, nn); if (status) goto out; dp = delegstateid(s);diff --git a/fs/nfsd/state.h b/fs/nfsd/state.hindex ec4559ecd193b2..df345896a7450f 100644--- a/[fs/nfsd/state.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/nfsd/state.h?id=b2b7f4c3a5e3ece2176cefbf63ad0e3b3f170a9f)+++ b/[fs/nfsd/state.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/nfsd/state.h?id=967faa26f313a62e7bebc55d5b8122eaee43b929)@@ -113,6 +113,8 @@ struct nfs4\_stid { /\* For a deleg stateid kept around only to process free\_stateid's: \*/ #define SC\_STATUS\_REVOKED BIT(1) #define SC\_STATUS\_ADMIN\_REVOKED BIT(2)+#define SC\_STATUS\_FREEABLE BIT(3)+#define SC\_STATUS\_FREED BIT(4) unsigned short sc\_status;  struct list\_head sc\_cp\_list; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 19:24:18 +0000



=== Content from git.kernel.org_88052a09_20250114_192540.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Olga Kornievskaia <okorniev@redhat.com> | 2024-10-18 15:24:58 -0400 |
| --- | --- | --- |
| committer | Chuck Lever <chuck.lever@oracle.com> | 2024-10-18 16:40:37 -0400 |
| commit | [8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a)) | |
| tree | [461fc462d6671f9d3b513a9337274e9ea08872c9](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a) | |
| parent | [c88c150a467fcb670a1608e2272beeee3e86df6e](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c88c150a467fcb670a1608e2272beeee3e86df6e) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a&id2=c88c150a467fcb670a1608e2272beeee3e86df6e)) | |
| download | [linux-8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a.tar.gz) | |

nfsd: fix race between laundromat and free\_stateidThere is a race between laundromat handling of revoked delegations
and a client sending free\_stateid operation. Laundromat thread
finds that delegation has expired and needs to be revoked so it
marks the delegation stid revoked and it puts it on a reaper list
but then it unlock the state lock and the actual delegation revocation
happens without the lock. Once the stid is marked revoked a racing
free\_stateid processing thread does the following (1) it calls
list\_del\_init() which removes it from the reaper list and (2) frees
the delegation stid structure. The laundromat thread ends up not
calling the revoke\_delegation() function for this particular delegation
but that means it will no release the lock lease that exists on
the file.
Now, a new open for this file comes in and ends up finding that
lease list isn't empty and calls nfsd\_breaker\_owns\_lease() which ends
up trying to derefence a freed delegation stateid. Leading to the
followint use-after-free KASAN warning:
kernel: ==================================================================
kernel: BUG: KASAN: slab-use-after-free in nfsd\_breaker\_owns\_lease+0x140/0x160 [nfsd]
kernel: Read of size 8 at addr ffff0000e73cd0c8 by task nfsd/6205
kernel:
kernel: CPU: 2 UID: 0 PID: 6205 Comm: nfsd Kdump: loaded Not tainted 6.11.0-rc7+ #9
kernel: Hardware name: Apple Inc. Apple Virtualization Generic Platform, BIOS 2069.0.0.0.0 08/03/2024
kernel: Call trace:
kernel: dump\_backtrace+0x98/0x120
kernel: show\_stack+0x1c/0x30
kernel: dump\_stack\_lvl+0x80/0xe8
kernel: print\_address\_description.constprop.0+0x84/0x390
kernel: print\_report+0xa4/0x268
kernel: kasan\_report+0xb4/0xf8
kernel: \_\_asan\_report\_load8\_noabort+0x1c/0x28
kernel: nfsd\_breaker\_owns\_lease+0x140/0x160 [nfsd]
kernel: nfsd\_file\_do\_acquire+0xb3c/0x11d0 [nfsd]
kernel: nfsd\_file\_acquire\_opened+0x84/0x110 [nfsd]
kernel: nfs4\_get\_vfs\_file+0x634/0x958 [nfsd]
kernel: nfsd4\_process\_open2+0xa40/0x1a40 [nfsd]
kernel: nfsd4\_open+0xa08/0xe80 [nfsd]
kernel: nfsd4\_proc\_compound+0xb8c/0x2130 [nfsd]
kernel: nfsd\_dispatch+0x22c/0x718 [nfsd]
kernel: svc\_process\_common+0x8e8/0x1960 [sunrpc]
kernel: svc\_process+0x3d4/0x7e0 [sunrpc]
kernel: svc\_handle\_xprt+0x828/0xe10 [sunrpc]
kernel: svc\_recv+0x2cc/0x6a8 [sunrpc]
kernel: nfsd+0x270/0x400 [nfsd]
kernel: kthread+0x288/0x310
kernel: ret\_from\_fork+0x10/0x20
This patch proposes a fixed that's based on adding 2 new additional
stid's sc\_status values that help coordinate between the laundromat
and other operations (nfsd4\_free\_stateid() and nfsd4\_delegreturn()).
First to make sure, that once the stid is marked revoked, it is not
removed by the nfsd4\_free\_stateid(), the laundromat take a reference
on the stateid. Then, coordinating whether the stid has been put
on the cl\_revoked list or we are processing FREE\_STATEID and need to
make sure to remove it from the list, each check that state and act
accordingly. If laundromat has added to the cl\_revoke list before
the arrival of FREE\_STATEID, then nfsd4\_free\_stateid() knows to remove
it from the list. If nfsd4\_free\_stateid() finds that operations arrived
before laundromat has placed it on cl\_revoke list, it marks the state
freed and then laundromat will no longer add it to the list.
Also, for nfsd4\_delegreturn() when looking for the specified stid,
we need to access stid that are marked removed or freeable, it means
the laundromat has started processing it but hasn't finished and this
delegreturn needs to return nfserr\_deleg\_revoked and not
nfserr\_bad\_stateid. The latter will not trigger a FREE\_STATEID and the
lack of it will leave this stid on the cl\_revoked list indefinitely.
Fixes: 2d4a532d385f ("nfsd: ensure that clp->cl\_revoked list is protected by clp->cl\_lock")
CC: stable@vger.kernel.org
Signed-off-by: Olga Kornievskaia <okorniev@redhat.com>
Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a)

| -rw-r--r-- | [fs/nfsd/nfs4state.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/nfsd/nfs4state.c?id=8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a) | 48 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/nfsd/state.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/nfsd/state.h?id=8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a) | 2 | |  |  |  | | --- | --- | --- | |

2 files changed, 42 insertions, 8 deletions

| diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.cindex 56b261608af46c..d1a2c677be7e6a 100644--- a/[fs/nfsd/nfs4state.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/nfsd/nfs4state.c?id=c88c150a467fcb670a1608e2272beeee3e86df6e)+++ b/[fs/nfsd/nfs4state.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/nfsd/nfs4state.c?id=8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a)@@ -1359,21 +1359,47 @@ static void destroy\_delegation(struct nfs4\_delegation \*dp) destroy\_unhashed\_deleg(dp); } +/\*\*+ \* revoke\_delegation - perform nfs4 delegation structure cleanup+ \* @dp: pointer to the delegation+ \*+ \* This function assumes that it's called either from the administrative+ \* interface (nfsd4\_revoke\_states()) that's revoking a specific delegation+ \* stateid or it's called from a laundromat thread (nfsd4\_landromat()) that+ \* determined that this specific state has expired and needs to be revoked+ \* (both mark state with the appropriate stid sc\_status mode). It is also+ \* assumed that a reference was taken on the @dp state.+ \*+ \* If this function finds that the @dp state is SC\_STATUS\_FREED it means+ \* that a FREE\_STATEID operation for this stateid has been processed and+ \* we can proceed to removing it from recalled list. However, if @dp state+ \* isn't marked SC\_STATUS\_FREED, it means we need place it on the cl\_revoked+ \* list and wait for the FREE\_STATEID to arrive from the client. At the same+ \* time, we need to mark it as SC\_STATUS\_FREEABLE to indicate to the+ \* nfsd4\_free\_stateid() function that this stateid has already been added+ \* to the cl\_revoked list and that nfsd4\_free\_stateid() is now responsible+ \* for removing it from the list. Inspection of where the delegation state+ \* in the revocation process is protected by the clp->cl\_lock.+ \*/ static void revoke\_delegation(struct nfs4\_delegation \*dp) { struct nfs4\_client \*clp = dp->dl\_stid.sc\_client;  WARN\_ON(!list\_empty(&dp->dl\_recall\_lru));+ WARN\_ON\_ONCE(!(dp->dl\_stid.sc\_status &+ (SC\_STATUS\_REVOKED | SC\_STATUS\_ADMIN\_REVOKED)));  trace\_nfsd\_stid\_revoke(&dp->dl\_stid); - if (dp->dl\_stid.sc\_status &- (SC\_STATUS\_REVOKED | SC\_STATUS\_ADMIN\_REVOKED)) {- spin\_lock(&clp->cl\_lock);- refcount\_inc(&dp->dl\_stid.sc\_count);- list\_add(&dp->dl\_recall\_lru, &clp->cl\_revoked);- spin\_unlock(&clp->cl\_lock);+ spin\_lock(&clp->cl\_lock);+ if (dp->dl\_stid.sc\_status & SC\_STATUS\_FREED) {+ list\_del\_init(&dp->dl\_recall\_lru);+ goto out; }+ list\_add(&dp->dl\_recall\_lru, &clp->cl\_revoked);+ dp->dl\_stid.sc\_status |= SC\_STATUS\_FREEABLE;+out:+ spin\_unlock(&clp->cl\_lock); destroy\_unhashed\_deleg(dp); } @@ -1780,6 +1806,7 @@ void nfsd4\_revoke\_states(struct net \*net, struct super\_block \*sb) mutex\_unlock(&stp->st\_mutex); break; case SC\_TYPE\_DELEG:+ refcount\_inc(&stid->sc\_count); dp = delegstateid(stid); spin\_lock(&state\_lock); if (!unhash\_delegation\_locked(@@ -6545,6 +6572,7 @@ nfs4\_laundromat(struct nfsd\_net \*nn) dp = list\_entry (pos, struct nfs4\_delegation, dl\_recall\_lru); if (!state\_expired(&lt, dp->dl\_time)) break;+ refcount\_inc(&dp->dl\_stid.sc\_count); unhash\_delegation\_locked(dp, SC\_STATUS\_REVOKED); list\_add(&dp->dl\_recall\_lru, &reaplist); }@@ -7157,7 +7185,9 @@ nfsd4\_free\_stateid(struct svc\_rqst \*rqstp, struct nfsd4\_compound\_state \*cstate, s->sc\_status |= SC\_STATUS\_CLOSED; spin\_unlock(&s->sc\_lock); dp = delegstateid(s);- list\_del\_init(&dp->dl\_recall\_lru);+ if (s->sc\_status & SC\_STATUS\_FREEABLE)+ list\_del\_init(&dp->dl\_recall\_lru);+ s->sc\_status |= SC\_STATUS\_FREED; spin\_unlock(&cl->cl\_lock); nfs4\_put\_stid(s); ret = nfs\_ok;@@ -7487,7 +7517,9 @@ nfsd4\_delegreturn(struct svc\_rqst \*rqstp, struct nfsd4\_compound\_state \*cstate, if ((status = fh\_verify(rqstp, &cstate->current\_fh, S\_IFREG, 0))) return status; - status = nfsd4\_lookup\_stateid(cstate, stateid, SC\_TYPE\_DELEG, 0, &s, nn);+ status = nfsd4\_lookup\_stateid(cstate, stateid, SC\_TYPE\_DELEG,+ SC\_STATUS\_REVOKED | SC\_STATUS\_FREEABLE,+ &s, nn); if (status) goto out; dp = delegstateid(s);diff --git a/fs/nfsd/state.h b/fs/nfsd/state.hindex 79c743c01a47bb..35b3564c065fa9 100644--- a/[fs/nfsd/state.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/nfsd/state.h?id=c88c150a467fcb670a1608e2272beeee3e86df6e)+++ b/[fs/nfsd/state.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/nfsd/state.h?id=8dd91e8d31febf4d9cca3ae1bb4771d33ae7ee5a)@@ -114,6 +114,8 @@ struct nfs4\_stid { /\* For a deleg stateid kept around only to process free\_stateid's: \*/ #define SC\_STATUS\_REVOKED BIT(1) #define SC\_STATUS\_ADMIN\_REVOKED BIT(2)+#define SC\_STATUS\_FREEABLE BIT(3)+#define SC\_STATUS\_FREED BIT(4) unsigned short sc\_status;  struct list\_head sc\_cp\_list; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 19:24:16 +0000


