Based on the provided information, this content relates to **CVE-2024-50078**.

**Root cause of vulnerability:**
The vulnerability arises from the lack of a call to `iso_exit()` when the Bluetooth module is unloaded, after `iso_init()` has been called. This leaves a struct proto registered by `iso_init()` with `proto_register()` invalid.

**Weaknesses/vulnerabilities present:**
- The primary weakness is the missing cleanup operation (`iso_exit()`) upon module unload. This leads to an invalid `struct proto` registered by `proto_register()`.
- Failure to call `iso_exit()` before module unload.

**Impact of exploitation:**
- The primary impact is a kernel crash, specifically a "list\_add corruption" bug triggered by loading the module again. This is due to the corrupted state of the linked list used internally by the kernel for managing protocols.
- This is a data corruption issue potentially leading to an invalid kernel state.

**Attack vectors:**
- The vulnerability is triggered when a Bluetooth module is loaded, then unloaded, and then loaded again. This involves actions at the module management level using `modprobe`.

**Required attacker capabilities/position:**
- The attacker would need to be able to load and unload kernel modules, which requires root privileges.
- The attacker must be able to trigger the module load and unload sequence.

**Technical Details:**
- The bug manifests as a kernel panic with a detailed error message: "list\_add corruption. next->prev should be prev (ffffffffb5355fd0), but was 0000000000000068. (next=ffffffffc0a010d0)." followed by a stack trace.
- The fix includes calling `iso_exit()` in the `bt_exit()` function within `net/bluetooth/af_bluetooth.c`
- The `CONFIG_LIST_HARDENED` and `CONFIG_BUG_ON_DATA_CORRUPTION` kernel options make this easier to reproduce.
- The issue is related to the BTPROTO\_ISO socket type that was added in a previous commit.

This analysis includes more technical details than the official CVE description which is a placeholder.