=== Content from ftp.openbsd.org_227eae72_20250114_200819.html ===
untrusted comment: verify with openbsd-75-base.pub
RWRGj1pRpprAfpfSCk7wg7g7MbzEL9hsCOm67Q8J+AqBr/J8XiLn7/2ncNp9nG0UoKVEohCADV7mReQ80i7ME5X6pWB2gz+C5wU=
OpenBSD 7.5 errata 008, September 17, 2024:
Avoid possible mbuf double free in NFS client and server implementation.
Do not use uninitialized variable in error handling of NFS server.
Apply by doing:
signify -Vep /etc/signify/openbsd-75-base.pub -x 008\_nfs.patch.sig \
-m - | (cd /usr/src && patch -p0)
And then rebuild and install a new kernel:
KK=`sysctl -n kern.osversion | cut -d# -f1`
cd /usr/src/sys/arch/`machine`/compile/$KK
make obj
make config
make
make install
Index: sys/nfs/nfs\_socket.c
===================================================================
RCS file: /cvs/src/sys/nfs/nfs\_socket.c,v
diff -u -p -r1.145 nfs\_socket.c
--- sys/nfs/nfs\_socket.c 5 Feb 2024 20:21:39 -0000 1.145
+++ sys/nfs/nfs\_socket.c 14 Sep 2024 21:54:27 -0000
@@ -1005,6 +1005,7 @@ tryagain:
if ((nmp->nm\_flag & NFSMNT\_NFSV3) &&
error == NFSERR\_TRYLATER) {
m\_freem(info.nmi\_mrep);
+ info.nmi\_mrep = NULL;
error = 0;
tsleep\_nsec(&nowake, PSOCK, "nfsretry",
SEC\_TO\_NSEC(trylater\_delay));
Index: sys/nfs/nfsm\_subs.h
===================================================================
RCS file: /cvs/src/sys/nfs/nfsm\_subs.h,v
diff -u -p -r1.47 nfsm\_subs.h
--- sys/nfs/nfsm\_subs.h 18 Jan 2019 13:59:18 -0000 1.47
+++ sys/nfs/nfsm\_subs.h 14 Sep 2024 21:54:27 -0000
@@ -65,6 +65,7 @@ struct nfsm\_info {
&cp2)) != 0) { \
error = t1; \
m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
goto nfsmout; \
} else { \
(a) = (c)cp2; \
@@ -91,6 +92,7 @@ struct nfsm\_info {
&ttnp)) != 0) { \
error = t1; \
m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
goto nfsmout; \
} \
(v) = NFSTOV(ttnp); \
@@ -112,6 +114,7 @@ struct nfsm\_info {
if (((s) = fxdr\_unsigned(int, \*tl)) <= 0 || \
(s) > NFSX\_V3FHMAX) { \
m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
error = EBADRPC; \
goto nfsmout; \
} \
@@ -126,6 +129,7 @@ struct nfsm\_info {
&info.nmi\_dpos, (a))) != 0) { \
error = t1; \
m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
goto nfsmout; \
} \
(v) = ttvp; \
@@ -140,6 +144,7 @@ struct nfsm\_info {
error = t1; \
(f) = 0; \
m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
goto nfsmout; \
} \
(v) = ttvp; \
@@ -175,19 +180,30 @@ struct nfsm\_info {
nfsm\_dissect(tl, u\_int32\_t \*,NFSX\_UNSIGNED); \
if (((s) = fxdr\_unsigned(int32\_t, \*tl)) < 0 || (s) > (m)) { \
m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
error = EBADRPC; \
goto nfsmout; \
} \
}
+/\*
+ \* Note nfsm\_reply at the end of this macro would return if v3 and an error
+ \* different from EBADRPC. But it does not make sense to continue anyway if
+ \* the error is NFSERR\_NAMETOL.
+ \*/
#define nfsm\_srvnamesiz(s) { \
nfsm\_dissect(tl, u\_int32\_t \*,NFSX\_UNSIGNED); \
- if (((s) = fxdr\_unsigned(int32\_t, \*tl)) > NFS\_MAXNAMLEN) \
+ if (((s) = fxdr\_unsigned(int32\_t, \*tl)) > NFS\_MAXNAMLEN) { \
error = NFSERR\_NAMETOL; \
- if ((s) <= 0) \
+ (s) = 0; \
+ } else if ((s) <= 0) { \
error = EBADRPC; \
- if (error) \
+ (s) = 0; \
+ } \
+ if (error) { \
nfsm\_reply(0); \
+ return(0); \
+ } \
}
#define nfsm\_mtouio(p, s) \
@@ -196,6 +212,7 @@ struct nfsm\_info {
&info.nmi\_dpos)) != 0) { \
error = t1; \
m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
goto nfsmout; \
}
@@ -204,6 +221,7 @@ struct nfsm\_info {
#define nfsm\_strtom(a, s, m) \
if ((s) > (m)) { \
m\_freem(info.nmi\_mreq); \
+ info.nmi\_mreq = NULL; \
error = ENAMETOOLONG; \
goto nfsmout; \
} \
@@ -217,10 +235,8 @@ struct nfsm\_info {
else \
(void) nfs\_rephead((s), nfsd, slp, error, \
&info.nmi\_mreq, &info.nmi\_mb); \
- if (info.nmi\_mrep != NULL) { \
- m\_freem(info.nmi\_mrep); \
- info.nmi\_mrep = NULL; \
- } \
+ m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
\*mrq = info.nmi\_mreq; \
if (error && (!(nfsd->nd\_flag & ND\_NFSV3) || error == EBADRPC)) \
return(0); \
@@ -235,6 +251,7 @@ struct nfsm\_info {
(s), t1)) != 0) { \
error = t1; \
m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
goto nfsmout; \
} \
}


=== Content from ftp.openbsd.org_ee1321e6_20250114_200818.html ===
untrusted comment: verify with openbsd-74-base.pub
RWRoyQmAD08ajZYRPLD9beNgbGFRygRDafNSeKRKZ3v3p6qHMB4sCOKMSLBmEpPYcpfWFf6YwSMqNq0uIWZDa+/54FKeU5IGUQQ=
OpenBSD 7.4 errata 021, September 17, 2024:
Avoid possible mbuf double free in NFS client and server implementation.
Do not use uninitialized variable in error handling of NFS server.
Apply by doing:
signify -Vep /etc/signify/openbsd-74-base.pub -x 021\_nfs.patch.sig \
-m - | (cd /usr/src && patch -p0)
And then rebuild and install a new kernel:
KK=`sysctl -n kern.osversion | cut -d# -f1`
cd /usr/src/sys/arch/`machine`/compile/$KK
make obj
make config
make
make install
Index: sys/nfs/nfs\_socket.c
===================================================================
RCS file: /cvs/src/sys/nfs/nfs\_socket.c,v
diff -u -p -r1.144 nfs\_socket.c
--- sys/nfs/nfs\_socket.c 3 Aug 2023 09:49:09 -0000 1.144
+++ sys/nfs/nfs\_socket.c 14 Sep 2024 21:51:21 -0000
@@ -1001,6 +1001,7 @@ tryagain:
if ((nmp->nm\_flag & NFSMNT\_NFSV3) &&
error == NFSERR\_TRYLATER) {
m\_freem(info.nmi\_mrep);
+ info.nmi\_mrep = NULL;
error = 0;
tsleep\_nsec(&nowake, PSOCK, "nfsretry",
SEC\_TO\_NSEC(trylater\_delay));
Index: sys/nfs/nfsm\_subs.h
===================================================================
RCS file: /cvs/src/sys/nfs/nfsm\_subs.h,v
diff -u -p -r1.47 nfsm\_subs.h
--- sys/nfs/nfsm\_subs.h 18 Jan 2019 13:59:18 -0000 1.47
+++ sys/nfs/nfsm\_subs.h 14 Sep 2024 21:51:21 -0000
@@ -65,6 +65,7 @@ struct nfsm\_info {
&cp2)) != 0) { \
error = t1; \
m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
goto nfsmout; \
} else { \
(a) = (c)cp2; \
@@ -91,6 +92,7 @@ struct nfsm\_info {
&ttnp)) != 0) { \
error = t1; \
m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
goto nfsmout; \
} \
(v) = NFSTOV(ttnp); \
@@ -112,6 +114,7 @@ struct nfsm\_info {
if (((s) = fxdr\_unsigned(int, \*tl)) <= 0 || \
(s) > NFSX\_V3FHMAX) { \
m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
error = EBADRPC; \
goto nfsmout; \
} \
@@ -126,6 +129,7 @@ struct nfsm\_info {
&info.nmi\_dpos, (a))) != 0) { \
error = t1; \
m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
goto nfsmout; \
} \
(v) = ttvp; \
@@ -140,6 +144,7 @@ struct nfsm\_info {
error = t1; \
(f) = 0; \
m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
goto nfsmout; \
} \
(v) = ttvp; \
@@ -175,19 +180,30 @@ struct nfsm\_info {
nfsm\_dissect(tl, u\_int32\_t \*,NFSX\_UNSIGNED); \
if (((s) = fxdr\_unsigned(int32\_t, \*tl)) < 0 || (s) > (m)) { \
m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
error = EBADRPC; \
goto nfsmout; \
} \
}
+/\*
+ \* Note nfsm\_reply at the end of this macro would return if v3 and an error
+ \* different from EBADRPC. But it does not make sense to continue anyway if
+ \* the error is NFSERR\_NAMETOL.
+ \*/
#define nfsm\_srvnamesiz(s) { \
nfsm\_dissect(tl, u\_int32\_t \*,NFSX\_UNSIGNED); \
- if (((s) = fxdr\_unsigned(int32\_t, \*tl)) > NFS\_MAXNAMLEN) \
+ if (((s) = fxdr\_unsigned(int32\_t, \*tl)) > NFS\_MAXNAMLEN) { \
error = NFSERR\_NAMETOL; \
- if ((s) <= 0) \
+ (s) = 0; \
+ } else if ((s) <= 0) { \
error = EBADRPC; \
- if (error) \
+ (s) = 0; \
+ } \
+ if (error) { \
nfsm\_reply(0); \
+ return(0); \
+ } \
}
#define nfsm\_mtouio(p, s) \
@@ -196,6 +212,7 @@ struct nfsm\_info {
&info.nmi\_dpos)) != 0) { \
error = t1; \
m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
goto nfsmout; \
}
@@ -204,6 +221,7 @@ struct nfsm\_info {
#define nfsm\_strtom(a, s, m) \
if ((s) > (m)) { \
m\_freem(info.nmi\_mreq); \
+ info.nmi\_mreq = NULL; \
error = ENAMETOOLONG; \
goto nfsmout; \
} \
@@ -217,10 +235,8 @@ struct nfsm\_info {
else \
(void) nfs\_rephead((s), nfsd, slp, error, \
&info.nmi\_mreq, &info.nmi\_mb); \
- if (info.nmi\_mrep != NULL) { \
- m\_freem(info.nmi\_mrep); \
- info.nmi\_mrep = NULL; \
- } \
+ m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
\*mrq = info.nmi\_mreq; \
if (error && (!(nfsd->nd\_flag & ND\_NFSV3) || error == EBADRPC)) \
return(0); \
@@ -235,6 +251,7 @@ struct nfsm\_info {
(s), t1)) != 0) { \
error = t1; \
m\_freem(info.nmi\_mrep); \
+ info.nmi\_mrep = NULL; \
goto nfsmout; \
} \
}

