```
{
  "Root cause of vulnerability": "The vulnerability stems from two related bugs in the Windows kernel code responsible for implementing the bind() socket function, specifically in the afd!AfdBind and tcpip!TcpBindEndpoint routines. These bugs can lead to out-of-bounds reads due to a double-fetch issue and insufficient size sanitization.",
  "Weaknesses/vulnerabilities present": [
    "Double fetch in afd!AfdBind: The first WORD of the input structure is fetched twice from a user-mode buffer, once during memmove() and again when passing it to SOCKADDR_SIZE, potentially resulting in different values and bypassing sanitization.",
    "Insufficient buffer size sanitization in afd!AfdBind and tcpip!TcpBindEndpoint: The sockaddr_size[] array used for input size sanitization contains mostly zeros, allowing an attacker to provide an arbitrary size and bypass the intended size checks. The tcpip!TcpBindEndpoint routine makes assumptions about the structure type based on the first word, leading to out-of-bounds reads during a memcpy operation if the size is incorrect."
  ],
  "Impact of exploitation": "Exploitation of these vulnerabilities could lead to the following:\n\n*   Kernel-mode information disclosure: User-mode applications could potentially disclose kernel-mode secrets through out-of-bounds reads.\n*   Denial of Service (DoS): Triggering a blue screen of death (BSOD) leading to a system crash.",
  "Attack vectors": "The attack vector involves sending a crafted IOCTL to the afd.sys driver through the AFD_BIND IOCTL. By manipulating the first WORD of the input structure, an attacker can trigger the double fetch or bypass size sanitization, leading to out-of-bounds reads in kernel-mode.",
    "Required attacker capabilities/position": "The attacker needs to be able to make system calls to interact with the afd.sys driver and must have the ability to control the contents and size of the data passed in these calls."
}
```