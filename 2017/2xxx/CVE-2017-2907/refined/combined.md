=== Content from www.talosintelligence.com_fb20838a_20250125_151444.html ===


* [Cisco Login](/users/auth/saml)

* [Intelligence Center](/reputation)

  + [# Intelligence Center](/reputation)
  + BACK
  + [Intelligence Search](/reputation_center)
  + [Email & Spam Trends](/reputation_center/email_rep)
* [Vulnerability Research](/vulnerability_info)

  + [# Vulnerability Research](/vulnerability_info)
  + BACK
  + [Vulnerability Reports](/vulnerability_reports)
  + [Microsoft Advisories](/ms_advisories)
* [Incident Response](/incident_response)

  + [# Incident Response](/incident_response)
  + BACK
  + [Reactive Services](/incident_response/services#reactive-services)
  + [Proactive Services](/incident_response/services#proactive-services)
  + Emergency Support
* [Blog](https://blog.talosintelligence.com)
* [Support](https://support.talosintelligence.com)

More

* Security Resources

  # Security Resources

  + BACK
  Security Resources
  + [Open Source Security Tools](/software)
  + [Intelligence Categories Reference](/categories)
  + [Secure Endpoint Naming Reference](/secure-endpoint-naming)
* Media

  # Media

  + BACK
  Media
  + [Talos Intelligence Blog](https://blog.talosintelligence.com)
  + [Threat Source Newsletter](https://blog.talosintelligence.com/category/threat-source-newsletter/)
  + [Beers with Talos Podcast](/podcasts/shows/beers_with_talos)
  + [Talos Takes Podcast](/podcasts/shows/talos_takes)
  + [Talos Videos](https://www.youtube.com/channel/UCPZ1DtzQkStYBSG3GTNoyfg/featured)
* Company

  # Company

  + BACK
  Company
  + [About Talos](/about)
  + [Careers](/careers)

* Under Attack?
* [Cisco Login](/users/auth/saml)

## Contact Cisco Talos Incident Response

Ã—

Close

This form is for Incident Response service inquiries only, including emergency network security needs.

For reputation or categorization inquiries, visit the [Talos Support site](/support).
For emergency DDoS mitigation assistance, please contact the [Cisco Secure DDoS Protection Team](https://www.cisco.com/c/en/us/products/collateral/security/ddos-emergency-attack-mitigation-aag.pdf).

Name

Company (optional)

Email address

Phone number

Preferred communication:

Email

Phone

What Incident Response Service are you interested in?
General Talos IR services and retainer information
Emergency Response
IR Plan
IR Playbooks
IR Readiness Assessment
Tabletop Exercises
Compromise Assessment
Threat Hunting
Cyber Range Training
Intelligence on Demand

Please provide as much detail as possible so we can best address your needs

I acknowledge that this is an inquiry for Incident Response services and that any other use of this form will not receive a response.

Send Email
Cancel

# Talos Vulnerability Report

### TALOS-2017-0414

## Blender Sequencer avi\_format\_convert Integer Overflow Code Execution Vulnerability

##### January 11, 2018

##### CVE Number

CVE-2017-2907

### Summary

An exploitable integer overflow exists in the animation playing functionality of the Blender open-source 3d creation suite version 2.78c. A specially created `.avi` file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to use the file as an asset in order to trigger this vulnerability.

### Tested Versions

Blender v2.78c

### Product URLs

<http://www.blender.org>

git://git.blender.org/blender.git

### CVSSv3 Score

8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H

### CWE

CWE-190 - Integer Overflow or Wraparound

### Details

Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project.

This vulnerability exists with how the Blender application renders a frame from an `.avi` file within the sequencer. When allocating space for a frame within the `.avi` file, the application will perform some arithmetic which can overflow. This result will then be used to perform an allocation which can allow for an undersized buffer. Later when the application attempts to decode data from the video file into this buffer, a heap-based buffer overflow will occur.

When trying to play a file, the application will first try to determine what whether the file is an animation or a picture format. An animation is checked at [1] using the `IMB_isanim` function. Inside this function, the application will determine the animation type. This is done by the `imb_get_anim_type` function within the `source/blender/imbuf/intern/util.c` file [2]. The next function will dispatch to a number of tests in order to determine what format the animation is actually in. One of these tests is a call to the function `is_avi` [3]. This function is simply a wrapper that calls `AVI_is_avi` [4]. Once inside the `AVI_is_avi` function, the application will check various chunks within the file to ensure they are of sane values. When this is done, the application will have determined it is an `.avi` animation and will proceed to actually process the video.

```
source/blender/windowmanager/intern/wm_playanim.c:1217
    if (IMB_isanim(filepath)) {                                 // [1] \
        /* OCIO_TODO: support different input color spaces */
...
            ibuf = IMB_anim_absolute(anim, 0, IMB_TC_NONE, IMB_PROXY_NONE);
...
    }
\
source/blender/imbuf/intern/util.c:422
bool IMB_isanim(const char *filename)
{
...
    type = imb_get_anim_type(filename);                         // [2] \
...
}
\
source/blender/imbuf/intern/util.c:376
int imb_get_anim_type(const char *name)
{
    int type;
    BLI_stat_t st;

    BLI_assert(!BLI_path_is_rel(name));

    if (UTIL_DEBUG) printf("%s: %s\n", __func__, name);
...
    if (isavi(name)) return (ANIM_AVI);                         // [3] \
...
    return ANIM_NONE;
}
\
source/blender/imbuf/intern/util.c:376
static int isavi(const char *name)
{
#ifdef WITH_AVI
    return AVI_is_avi(name);                                    // [4]
#else
    (void)name;
    return false;
#endif
}

```

Returning back to the caller, the application will then call the `IMB_anim_absolute` function [5]. This function does two things. One of which is to open up the file and collect information from the header chunk that is needed to render it [6]. The second which occurs after determining the animation type is to actually fetch an image buffer and decode a frame [7].

```
source/blender/windowmanager/intern/wm_playanim.c:1217
    if (IMB_isanim(filepath)) {
    ...
        if (anim) {
            ibuf = IMB_anim_absolute(anim, 0, IMB_TC_NONE, IMB_PROXY_NONE); // [5] \
    ...
        }
    }
\
source/blender/imbuf/intern/anim_movie.c:1282
struct ImBuf *IMB_anim_absolute(struct anim *anim, int position,
                                IMB_Timecode_Type tc,
                                IMB_Proxy_Size preview_size)
{
...
    if (preview_size == IMB_PROXY_NONE) {
        if (anim->curtype == 0) {
            ibuf = anim_getnew(anim);                   // [6]
            if (ibuf == NULL) {
                return(NULL);
            }

            IMB_freeImBuf(ibuf); /* ???? */
            ibuf = NULL;
        }

        if (position < 0) return(NULL);
        if (position >= anim->duration) return(NULL);
    }
...
    switch (anim->curtype) {
        case ANIM_SEQUENCE:
...
        case ANIM_AVI:
            ibuf = avi_fetchibuf(anim, position);       // [7]
            if (ibuf)
                anim->curposition = position;
            break;

```

When opening the `.avi` file to collect information about the header, the `anim_getnew` function will be called. Inside this function, the application will again determine which animation type the file is of and then hand off the current animation state to the `startavi` function at [8]. Inside `startavi`, the movie will actually be opened in order to extract information needed to render the file followed by saving the dimensions and number of frames available [10]. Before this, however, the `AVI_open_movie` function will be called at [9].

```
source/blender/imbuf/intern/anim_movie.c:1208
static ImBuf *anim_getnew(struct anim *anim)
{
...
    anim->curtype = imb_get_anim_type(anim->name);

    switch (anim->curtype) {
        case ANIM_SEQUENCE:
...
        case ANIM_AVI:
            if (startavi(anim)) {                           // [8] \
                printf("couldnt start avi\n");
                return (NULL);
            }
            ibuf = IMB_allocImBuf(anim->x, anim->y, 24, 0);
            break;
\
source/blender/imbuf/intern/anim_movie.c:282
static int startavi(struct anim *anim)
{
...
    avierror = AVI_open_movie(anim->name, anim->avi);       // [9]

#if defined(_WIN32) && !defined(FREE_WINDOWS)
    if (avierror == AVI_ERROR_COMPRESSION) {
...
    }
...
    anim->duration = anim->avi->header->TotalFrames;
    anim->params = NULL;

    anim->x = anim->avi->header->Width;                     // [10]
    anim->y = anim->avi->header->Height;
    anim->interlacing = 0;
    anim->orientation = 0;
    anim->framesize = anim->x * anim->y * 4;
...
}

```

The `AVI_open_movie` function will open the file in order to prepare the number of streams encoded within the file [11]. Once opening the file, the initial headers will be checked in order to locate the AVI header (identified by the â€œhdrlâ€ chunk) which contains general information about the `.avi` file [12]. This data which includes the videoâ€™s dimensions is then assigned to the `movie->header` field [13]. These fields can be up to 32-bits in size. It is these two fields that when multiplied will be overflown. After storing the general information about the file, the application will then proceed to read information about each sample from the sample headers within the file [14]. After that information is stored, the application will then save the file offset to the sample data [15] to the `movi_offset` and `read_offset` variables and then proceed to load the index from the file if one is included. After collecting all of this information about the file, this function will return back to `anim_getnew` and then back to `IMB_anim_absolute`.

```
src/source/blender/avi/intern/avi.c:438
AviError AVI_open_movie(const char *name, AviMovie *movie)
{
...
    movie->fp = BLI_fopen(name, "rb");                      // [11]
    movie->offset_table = NULL;
...
    if (GET_FCC(movie->fp) != FCC("RIFF") ||
        !(movie->size = GET_FCC(movie->fp)))
    {
...
    }
...
    if (GET_FCC(movie->fp) != FCC("AVI ") ||                // [12]
        GET_FCC(movie->fp) != FCC("LIST") ||
        !GET_FCC(movie->fp) ||
        GET_FCC(movie->fp) != FCC("hdrl") ||
        (movie->header->fcc = GET_FCC(movie->fp)) != FCC("avih") ||
        !(movie->header->size = GET_FCC(movie->fp)))
    {
...
    }

    movie->header->MicroSecPerFrame = GET_FCC(movie->fp);   // [13]
    movie->header->MaxBytesPerSec = GET_FCC(movie->fp);
    movie->header->PaddingGranularity = GET_FCC(movie->fp);
    movie->header->Flags = GET_FCC(movie->fp);
    movie->header->TotalFrames = GET_FCC(movie->fp);
    movie->header->InitialFrames = GET_FCC(movie->fp);
    movie->header->Streams = GET_FCC(movie->fp);
    movie->header->SuggestedBufferSize = GET_FCC(movie->fp);
    movie->header->Width = GET_FCC(movie->fp);
    movie->header->Height = GET_FCC(movie->fp);
    movie->header->Reserved[0] = GET_FCC(movie->fp);
    movie->header->Reserved[1] = GET_FCC(movie->fp);
    movie->header->Reserved[2] = GET_FCC(movie->fp);
    movie->header->Reserved[3] = GET_FCC(movie->fp);
...
    for (temp = 0; temp < movie->header->Streams; temp++) { // [14]
...
    }
...
    movie->movi_offset = ftell(movie->fp);                  // [15]
    movie->read_offset = movie->movi_offset;

    /* Read in the index if the file has one, otherwise create one */
    if (movie->header->Flags & AVIF_HASINDEX) {
...
    }
...
}

```

Back in the `IMB_anim_absolute` function, the information that was collected by `anim_getnew` will then be passed to the `avi_fetchibuf` function [16]. This function will take the fields that were assigned earlier and use them to allocate a buffer based on the video dimensions at [17]. Once allocating the buffer, the application will then proceed to read the first frame out of the file into the allocated buffer using the `AVI_read_frame` function. This function will first seek to the correct frame by navigating the index that was read earlier, and then hand off the sample stream to the `avi_format_convert` function at [18].

```
source/blender/imbuf/intern/anim_movie.c:1282
struct ImBuf *IMB_anim_absolute(struct anim *anim, int position,
                                IMB_Timecode_Type tc,
                                IMB_Proxy_Size preview_size)
{
...
    switch (anim->curtype) {
        case ANIM_SEQUENCE:
...
        case ANIM_AVI:
            ibuf = avi_fetchibuf(anim, position);                                                       // [16] \
            if (ibuf)
                anim->curposition = position;
            break;
\
source/blender/imbuf/intern/anim_movie.c:394
static ImBuf *avi_fetchibuf(struct anim *anim, int position)
{
...
        ibuf = IMB_allocImBuf(anim->x, anim->y, 24, IB_rect);

        tmp = AVI_read_frame(anim->avi, AVI_FORMAT_RGB32, position,                                     // [17] \
                             AVI_get_stream(anim->avi, AVIST_VIDEO, 0));
\
src/source/blender/avi/intern/avi.c:690
void *AVI_read_frame(AviMovie *movie, AviFormat format, int frame, int stream)
{
...
    while (rewind && frame > -1) {
...
    }
...
    buffer = avi_format_convert(movie, stream, buffer, movie->streams[stream].format, format, &temp);   // [18]

    return buffer;
}

```

The `avi_format_convert` function will determine the videoâ€™s format type and then use that to call one of functions at [19]. Each of these functions will allocate space for the destination of the sample data that is to be decoded and then will decompress the sample data from the file into said buffer. The provided proof-of-concept will actaully dispatch into the `avi_converter_from_avi_rgb` function.

```
source/blender/avi/intern/avi_codecs.c:42
void *avi_format_convert(AviMovie *movie, int stream, void *buffer, AviFormat from, AviFormat to, int *size)
{
...
    switch (to) {
        case AVI_FORMAT_RGB24:
            switch (from) {
                case AVI_FORMAT_AVI_RGB:
                    buffer = avi_converter_from_avi_rgb(movie, stream, buffer, size);   // [19]
                    break;
                case AVI_FORMAT_MJPEG:
                    buffer = avi_converter_from_mjpeg(movie, stream, buffer, size);     // [19]
                    break;
                case AVI_FORMAT_RGB32:
                    buffer = avi_converter_from_rgb32(movie, stream, buffer, size);     // [19]
                    break;
                default:
                    break;
            }
            break;
...
    return buffer;
}

```

Once inside the `avi_converter_from_avi_rgb` function, the application will actually decode the sample data into a frame. At [20], the application will allocate a buffer based on the `Width` and `Height` fields that were read earlier from the general AVI header. Due to the application not checking that the product of these fields with the size of 3 is larger than 32-bits, this allocation can be made to underflow which will result in an undersized buffer being assigned to the `buf` variable. Later at [21] when the application tries to decode the sample data into this buffer, both will write outside the bounds of the buffer which will cause a heap-based buffer overflow. This can lead to code execution under the context of the application.

```
source/blender/avi/intern/avi_rgb.c:45
void *avi_converter_from_avi_rgb(AviMovie *movie, int stream, unsigned char *buffer, int *size)
{
...
    bi = (AviBitmapInfoHeader *) movie->streams[stream].sf;
    if (bi) bits = bi->BitCount;

    if (bits == 16) {
...
    }
    else {
        buf = MEM_mallocN(movie->header->Height * movie->header->Width * 3, "fromavirgbbuf");   // [20]
...
        for (y = 0; y < movie->header->Height; y++) {                                           // [21]
            memcpy(&buf[y * movie->header->Width * 3], &buffer[((movie->header->Height - 1) - y) * rowstride], movie->header->Width * 3);
        }

        for (y = 0; y < movie->header->Height * movie->header->Width * 3; y += 3) {             // [21]
            i = buf[y];
            buf[y] = buf[y + 2];
            buf[y + 2] = i;
        }

```
### Crash Information

```
(2e5c.564): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=143c9ffe ebx=14c2efbc ecx=00000002 edx=00000006 esi=143c9ffc edi=14c75000
eip=02acaf2a esp=00abf150 ebp=00abf174 iopl=0         nv up ei pl nz ac po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010213
blender!xmlListWalk+0x2181aa:
02acaf2a f3a4            rep movs byte ptr es:[edi],byte ptr [esi]

0:000> !heap -p -a @edi-1
    address 14c74fff found in
    _DPH_HEAP_ROOT @ b61000
    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)
                                14b2330c:         14c74ff8                8 -         14c74000             2000

```
### Exploit Proof-of-Concept

Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the `.avi` file to.

```
$ python poc.py $FILENAME.avi

```

To trigger the vulnerability, one can simply add it as an asset or they can pass it as an argument to the blender executable.

```
$ /path/to/blender.exe -a $FILENAME.avi

```
### Mitigation

In order to mitigate this vulnerability, it is recommended to not use untrusted animation files as an asset when composing a scene.

### Timeline

2017-09-06 - Vendor Disclosure

2018-01-11 - Public Release

##### Credit

Discovered by a member of Cisco Talos.

---

[Vulnerability Reports](/vulnerability_reports) [Next Report

TALOS-2017-0415](/vulnerability_reports/TALOS-2017-0415) [Previous Report

TALOS-2017-0413](/vulnerability_reports/TALOS-2017-0413)

* + ###### [Intelligence Center](/reputation)
  + [Intelligence Search](/reputation_center)
  + [Email & Spam Trends](/reputation_center/email_rep)
* + ###### [Vulnerability Research](/vulnerability_info)
  + [Vulnerability Reports](/vulnerability_reports)
  + [Microsoft Advisories](/ms_advisories)
* + ###### [Incident Response](/incident_response)
  + [Reactive Services](/incident_response/services#reactive-services)
  + [Proactive Services](/incident_response/services#proactive-services)
  + Emergency Support
* + ###### Security Resources
  + [Open Source Security Tools](/software)
  + [Intelligence Categories Reference](/categories)
  + [Secure Endpoint Naming Reference](/secure-endpoint-naming)
* + ###### Media
  + [Talos Intelligence Blog](https://blog.talosintelligence.com)
  + [Threat Source Newsletter](https://blog.talosintelligence.com/category/threat-source-newsletter/)
  + [Beers with Talos Podcast](/podcasts/shows/beers_with_talos)
  + [Talos Takes Podcast](/podcasts/shows/talos_takes)
  + [Talos Videos](https://www.youtube.com/channel/UCPZ1DtzQkStYBSG3GTNoyfg/featured)
* + ###### Support
  + [Support Documentation](https://support.talosintelligence.com)
* + ###### Company
  + [About Talos](/about)
  + [Careers](/careers)
  + [Cisco Security](https://www.cisco.com/c/en/us/products/security/product-listing.html)

###### Follow us

[![Cisco](/assets/logo_cisco_white-d87b7f7d3152ad412e48aad924a972cc5b802b7a53cb56b0792a4456c9b7b3a5.svg)](http://tools.cisco.com/security/center/home.x)

Â©
2025
Cisco Systems, Inc. and/or its affiliates. All rights
reserved. View our
[Privacy Policy.](http://www.cisco.com/web/siteassets/legal/privacy_full.html)



=== Content from lists.debian.org_24e36be1_20250125_151441.html ===


---

[[Date Prev](msg00010.html)][[Date Next](msg00012.html)]
[[Thread Prev](msg00010.html)][[Thread Next](msg00012.html)]
[[Date Index](maillist.html#00011)]
[[Thread Index](threads.html#00011)]

# [SECURITY] [DLA 1465-1] blender security update

---

* *To*: debian-lts-announce@lists.debian.org
* *Subject*: [SECURITY] [DLA 1465-1] blender security update
* *From*: Markus Koschany <apo@debian.org>
* *Date*: Mon, 13 Aug 2018 13:08:55 +0200
* *Message-id*: <[[ðŸ”Ž]](/msgid-search/07f1c718-49f9-1524-ff28-a913670d08f6%40debian.org)Â [07f1c718-49f9-1524-ff28-a913670d08f6@debian.org](msg00011.html)>
* *Mail-followup-to*: debian-lts@lists.debian.org
* *Reply-to*: debian-lts@lists.debian.org

---

```
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Package        : blender
Version        : 2.72.b+dfsg0-3+deb8u1
CVE ID         : CVE-2017-2899 CVE-2017-2900 CVE-2017-2901 CVE-2017-2902
                 CVE-2017-2903 CVE-2017-2904 CVE-2017-2905 CVE-2017-2906
                 CVE-2017-2907 CVE-2017-2908 CVE-2017-2918
                 CVE-2017-12081 CVE-2017-12082 CVE-2017-12086
                 CVE-2017-12099 CVE-2017-12100 CVE-2017-12101
                 CVE-2017-12102 CVE-2017-12103 CVE-2017-12104
                 CVE-2017-12105

Multiple vulnerabilities have been discovered in various parsers of
Blender, a 3D modeller/ renderer. Malformed .blend model files and
malformed multimedia files (AVI, BMP, HDR, CIN, IRIS, PNG, TIFF) may
result in the execution of arbitrary code.

For Debian 8 "Jessie", these problems have been fixed in version
2.72.b+dfsg0-3+deb8u1.

We recommend that you upgrade your blender packages.

Further information about Debian LTS security advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://wiki.debian.org/LTS>
-----BEGIN PGP SIGNATURE-----

iQKTBAEBCgB9FiEErPPQiO8y7e9qGoNf2a0UuVE7UeQFAltxZsdfFIAAAAAALgAo
aXNzdWVyLWZwckBub3RhdGlvbnMub3BlbnBncC5maWZ0aGhvcnNlbWFuLm5ldEFD
RjNEMDg4RUYzMkVERUY2QTFBODM1RkQ5QUQxNEI5NTEzQjUxRTQACgkQ2a0UuVE7
UeTTuhAAvOVxnABUH5iI/00MP6OI6XPAJtdm53HYdhaKuo/xwH3riMqcCBNMIDKk
6oWR1Ad++XXod2mdgOqMgy3OsEwPBIG1NuhTw/Mvb64qeNUgFiyQWB6gF9NbZUmf
ZlZ2ksXLd9ThVs9rPT5StdryglXGd+mA3gEKPWVxA9yS94ZKFyKJtYL7mPYYAhtk
pejTujmC4/HbwqdAl5t+z2OkDCish5IWTGa1BDlpn+oI+G1V+YdpTFY5caYC5XmZ
fvB5qVbjQsWIapPyUDxeBD3rRXcUHlJvVYIpn0UOTJiKAQ5tODO7kMlZ7QbBTyXc
21cEl50NWaCPCRF2qBJzRbjZIl8qAGYf6NVPkO3BTvY5sDua1O0uJIBsVMKWDxxj
AgbJItVNvM0HmIvm5pmT3oof6CZrAhtSHFOoFMYftX/TiAsMVz4M27r3JcCCkStu
FP7REAFz6XEbLQe78FnAvXKh7HsSbZijAqNNacSuAzk3AMoRXL5aoXAdsdEowZcz
HJd5l0Cl7SyGinDSGHsvGb1roxH4QwRJjKvYDrQYDfKg3+dsgmpTWHxsWk2NBzAM
W+revsoqvhj6pvAasIgbH7AlWZ70V+0Frp4USKN4BAzzPBc2aP1ZInWPIcKNKY59
G20Nis7PX8TqMry2q1KJ0rBLT2ht9Q0cZbdduPjygQVerQ/ur5Y=
=XLtu
-----END PGP SIGNATURE-----

```

---



=== Content from www.debian.org_f6310bdb_20250125_151442.html ===


---

[[Date Prev](msg00176.html)][[Date Next](msg00178.html)]
[[Thread Prev](msg00176.html)][[Thread Next](msg00178.html)]
[[Date Index](maillist.html#00177)]
[[Thread Index](threads.html#00177)]

# [SECURITY] [DSA 4248-1] blender security update

---

* *To*: debian-security-announce@lists.debian.org
* *Subject*: [SECURITY] [DSA 4248-1] blender security update
* *From*: Moritz Muehlenhoff <jmm@debian.org>
* *Date*: Tue, 17 Jul 2018 22:36:50 +0200
* *Message-id*: <[[ðŸ”Ž]](/msgid-search/20180717203650.GA21556%40pisco.westfalen.local)Â [20180717203650.GA21556@pisco.westfalen.local](msg00177.html)>
* *Reply-to*: debian-security-announce-request@lists.debian.org

---

```
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

- -------------------------------------------------------------------------
Debian Security Advisory DSA-4248-1                   security@debian.org
<https://www.debian.org/security/>                       Moritz Muehlenhoff
July 17, 2018                         <https://www.debian.org/security/faq>
- -------------------------------------------------------------------------

Package        : blender
CVE ID         : CVE-2017-2899 CVE-2017-2900 CVE-2017-2901 CVE-2017-2902
                 CVE-2017-2903 CVE-2017-2904 CVE-2017-2905 CVE-2017-2906
                 CVE-2017-2907 CVE-2017-2908 CVE-2017-2918 CVE-2017-12081
                 CVE-2017-12082 CVE-2017-12086 CVE-2017-12099 CVE-2017-12100
                 CVE-2017-12101 CVE-2017-12102 CVE-2017-12103 CVE-2017-12104
                 CVE-2017-12105

Multiple vulnerabilities have been discovered in various parsers of
Blender, a 3D modeller/ renderer. Malformed .blend model files and
malformed multimedia files (AVI, BMP, HDR, CIN, IRIS, PNG, TIFF) may
result in the execution of arbitrary code.

For the stable distribution (stretch), these problems have been fixed in
version 2.79.b+dfsg0-1~deb9u1.

We recommend that you upgrade your blender packages.

For the detailed security status of blender please refer to
its security tracker page at:
<https://security-tracker.debian.org/tracker/blender>

Further information about Debian Security Advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://www.debian.org/security/>

Mailing list: debian-security-announce@lists.debian.org
-----BEGIN PGP SIGNATURE-----

iQIzBAEBCgAdFiEEtuYvPRKsOElcDakFEMKTtsN8TjYFAltOUvYACgkQEMKTtsN8
TjYhsg/+NCToE40gw3rF2uQnKwcuLDybQ4D4JNJq9Joztvg6izv11doyxYM2tPcP
kiUAKpGbYfA0BIT6CQ+cIuqjEoTEm8QrRD9L2b5WfLvmG7hhumM4uclU6RqOLMfs
dR6RJ0+ksExjXohT4Pn8daRuj2FkpPyeoL9HIR9SWFIZBrLKZJfq9fIz7VU4uYNP
N0G2IUuHrlHyqidmMSVHqYMj4TlrnoBAM4T4e1WyWFpwZGiQC7ugsS7lbPp02F7K
9l+in9YVQd3nv1vL6zHVUvHG8X1Ipkr2+iUGaZ9wFtrUaLc5e7JpxjEY5yXfz8jO
ULlvvleet6qesO+TIGvtCqjHYACI/bXzuxxM/zHlyeaADmwKnjPE/0m8sEPOewDP
Djfs6RTOZt2CRJJxU80oKieGzttHZFBsx9yl/QYYkgk0mjwxlhBdPhh3E8MWIIt4
jATir7Kj203cOqosKibcpKhRfAm4R6By2Z/wb7oTIO+VgiIzKHV7AI0+eMaf/1Em
GvfJnupAdGq8H0gLuCYRFXeDwASuGwbM3RbJ2mzYot1w2f28UQprWrbpJgsYEoM4
WfYCdoYxXHHv9+OMLjcND2fqe1IlgimyuiHx66wAcil+al1mjF+N2UnuNEcsYLmt
B4hdMfzlFLuoivVMFJFVG9UCSFkXYN32WM9v7nhyblDmrS758vU=
=OeWg
-----END PGP SIGNATURE-----

```

---


