=== Content from devco.re_35b1a190_20250124_161911.html ===


[![](/images/logo.svg)](/en/)

* Services
  [## Red Team Assessment

  Simulation of real-world attacks to identify vulnerabilities and achieve objectives without disrupting business operations.](/en/services/red-team/)
  [## Penetration Testing

  Infiltration of designated enterprise systems to uncover potential vulnerabilities and assess the risks or damages.](/en/services/penetration-test/)
  [## Security Consulting

  Consultation of resource distribution and long-term defensive strategies from the attacker’s perspective.](/en/services/security-consulting/)
  [## Security Training

  Instruction on defending and preventing incidents with the hacker mindset, also the response procedures and analysis of attacks when incidents happen.](/en/services/security-training/)
* Research
  [## Overview

  Research of updated cybersecurity techniques and trends, assess the security of products, and evolve the red team with broad experience.](/en/research/overview/)
  [## Competitions and Awards

  Awards from international cybersecurity competitions.](/en/research/awards/)
  [## Enterprise Vulnerability Reports

  Research of the risk of enterprise systems, identification of potential weaknesses, and report to vendors.](/en/research/bug-bounty/)
  [## International Conferences

  Sharing vulnerability research and security knowledge at international cybersecurity conferences.](/en/research/talks/)
  [## CVE List

  Discovery of critical vulnerabilities in leading international products and services.](/en/research/cve/)
* Company
  [## Company Overview

  Founded by a world-class white hat hacker team, providing cybersecurity services including Red Team Assessment, Penetration Testing, Security Consulting, and Security Training.](/en/company/about/)
  [## Team Members

  Composed of cybersecurity experts with the hacker mindset, exploring innovative exploitation techniques with high morality and extreme caution.](/en/company/our-team/)
  [## Achievements

  DEVCORE has been invited to leading cybersecurity conferences, has uncovered hundreds of critical product vulnerabilities, and helped enterprises improve their defensive capabilities.](/en/company/history/)
  [## Corporate Social Responsibility

  We provide diverse internship channels and programs to nurture the next generation and promote cybersecurity awareness.](/en/company/csr/)
  [## Job Opportunities

  Join us to secure the world and improve the cybersecurity industry together.](/en/company/jobs/)
* News
  [## BLOG

  Latest news](/en/blog/)
  [## Media Resources

  Media Kit, Logo and Usage Guideline](/en/media-kit/)
* [Search](/en/search/)
* [Contact](/en/contact/)

* Services
  [## Red Team Assessment](/en/services/red-team/)
  [## Penetration Testing](/en/services/penetration-test/)
  [## Security Consulting](/en/services/security-consulting/)
  [## Security Training](/en/services/security-training/)
* Research
  [## Overview](/en/research/overview/)
  [## Competitions and Awards](/en/research/awards/)
  [## Enterprise Vulnerability Reports](/en/research/bug-bounty/)
  [## International Conferences](/en/research/talks/)
  [## CVE List](/en/research/cve/)
* Company
  [## Company Overview](/en/company/about/)
  [## Team Members](/en/company/our-team/)
  [## Achievements](/en/company/history/)
  [## Corporate Social Responsibility](/en/company/csr/)
  [## Job Opportunities](/en/company/jobs/)
* News
  [## BLOG](/en/blog/)
  [## Media Resources](/en/media-kit/)
* [## Search](/en/search/)
  [## Contact](/en/contact/)
* Language
  [## 中文](/)
  [## English](/en)

# BLOG

* [All Articles](/en/blog/)
* [Tech Editorials](/en/blog/category/Tech%20Editorials/)
* [Media Resources](/en/media-kit/)

[Tech Editorials](/en/blog/category/Tech%20Editorials)
[#Advisory](/en/blog/tag/Advisory/) [#CVE](/en/blog/tag/CVE/) [#Vulnerability](/en/blog/tag/Vulnerability/)
# Sandstorm Security Review

[Shaolin](/en/blog/author/shaolin)
2018-01-26

![](https://devco.re/assets/img/blog/20180126/cover.png)

---

[Sandstorm Security Review](/blog/2018/01/26/Sandstorm-Security-Review-CVE-2017-6200-en/) (English Version)

[一次在 Sandstorm 跳脫沙箱的滲透經驗](/blog/2018/01/26/Sandstorm-Security-Review-CVE-2017-6200/) (中文版本)

## Introduction

In early 2017, we had a pentesting target protected with [Sandstorm](https://sandstorm.io/). Sandstorm is a web-based platform which allows users to install their web apps, such as WordPress, GitLab, etc. The main feature of Sandstorm is that it containerizes every app in its own sandbox. Therefore, even though we had found several vulnerabilities of the apps, we still could not put a threat to the server.

In order to leverage the vulnerabilities, we put part of efforts into review of Sandstorm’s source codes, and tried to escape the sandbox to impact the whole server. Finally, we found a number of uncommon and interesting vulnerabilities, and received CVE IDs as follows:

* CVE-2017-6198 (Denial of Service)
* CVE-2017-6199 (Bypassing Authorization Schema)
* CVE-2017-6200 (Insecure Direct Object References)
* CVE-2017-6201 (Server-Side Request Forgery)

## Exploitation Details

### CVE-2017-6198

This is a DoS created by system resource exhaustion. The root cause is that Sandstorm does not have a comprehensive policy to limit the amount of resource used by every apps run on it. In `src/sandstorm/supervisor.c++` only the maximum number of files opened by each process was limited. See the codes below:

```
void SupervisorMain::setResourceLimits() {
  struct rlimit limit;
  memset(&limit, 0, sizeof(limit));
  limit.rlim_cur = 1024;
  limit.rlim_max = 4096;
  KJ_SYSCALL(setrlimit(RLIMIT_NOFILE, &limit));
}

```

Ref: [https://github.com/sandstorm-io/sandstorm/blob/v0.202/src/sandstorm/supervisor.c++#L824](https://github.com/sandstorm-io/sandstorm/blob/v0.202/src/sandstorm/supervisor.c%2B%2B#L824)

Since supervisor does not restrict the amount of subprocesses and storage usage, attackers can raise a resource exhaustion attack to crash the server by simply uploading a malicious app which keeps calling fork() (aka the “fork bomb”) or consumes huge storage space.

### CVE-2017-6199

Usually Sandstorm will designate unique permissions to the specific members of a certain organization, and the default membership validation method is to check user’s email address and see whether the string after `@` exists in their white list. See the codes below:

```
if (identity.services.email.email.toLowerCase().split("@").pop() === emailDomain) {
    return true;
}

```

Ref: <https://github.com/sandstorm-io/sandstorm/blob/v0.202/shell/packages/sandstorm-db/db.js#L1112>

Therefore, when an attacker fills in an email like `[[email protected]](/cdn-cgi/l/email-protection),[[email protected]](/cdn-cgi/l/email-protection)` and the system will automatically consider the attacker a member of the `aaa.bbb` organization.

Another key factor that contributes to the successful attack lies in one of the features when users log on Sandstorm. Users does not need to set up passwords for Sandstorm. Each time when the users need to log onto the service, they only need to fill in their email address, and they’ll receive a set of random unique password for login. The reason why the example above works is because the system treats `[[email protected]](/cdn-cgi/l/email-protection),[[email protected]](/cdn-cgi/l/email-protection)` as a user from aaa.bbb domain, and the random password will be sent to the two email addresses, `[[email protected]](/cdn-cgi/l/email-protection)` and `[[email protected]](/cdn-cgi/l/email-protection)` As long as one can receive the password, they can log in to use the service.

Below is a quick demonstration:

1. On Sandstorm, restrict access to users from domain `aaa.bbb` only.
   ![](/assets/img/blog/20180126/1.png)
2. On login page, fill in `[[email protected]](/cdn-cgi/l/email-protection),[[email protected]](/cdn-cgi/l/email-protection)` for the email field.
   (Note: at the front end, the email field is checked with HTML5 validation, but it is not further checked for validity at the back end)
   ![](/assets/img/blog/20180126/2.png)
3. Retrieve random password in [[email protected]](/cdn-cgi/l/email-protection) mailbox.
   ![](/assets/img/blog/20180126/3.png)
4. Login successful. `[[email protected]](/cdn-cgi/l/email-protection),[[email protected]](/cdn-cgi/l/email-protection)` is considered as a user and member of `aaa.bbb` organization!
   ![](/assets/img/blog/20180126/4.png)

In our pentesting, the target website allowed users from validated domains to install their own apps. Therefore, through this bypass exploit, further attacks could be accomplished by combining other vulnerabilities described in this blog post (CVE-2017-6198, CVE-2017-6200, CVE-2017-6201).

### CVE-2017-6200

This is an interesting vulnerability. Totally two little validation flaws were exploited to initiate this attack!
On Sandstorm, owners of each Grain (Sandstorm container, in short, an app sandbox) can download their backup data for the app. But because of the two vulnerabilities in the packing process, an attacker can pack the files under the `/etc` and `/run` directories located on the server outside the sandbox. The security issues were as follows:

1. The packing process has hid `/var`, `/proc`, `/etc` and other sensitive directories, but did not hide `/etc.host` and `/run.host` these two directories. These directories are the aliases for the directories `/etc` and `/run` on the server respectively, which are relatively newer features.
2. The system will pack the legitimate files, have them sorted out, and create zip packages through the standard input interface. The separation between files are determined by line-breaks (`\n`). As a result, when a line-break string appears in the file name, illegal path file names can be injected and packed with zip. Although the app checks whether there is a line-break in the file name, but the directory name was not checked.

Ref: <https://github.com/sandstorm-io/sandstorm/blob/v0.202/src/sandstorm/backup.c%2B%2B#L271>

By using these two vulnerabilities together, the attacker simply has to create a directory in the sandbox `/var/exp\n/etc.host/passwd\n` , then backup files containing `/etc/passwd` on the server can be retrieved through backup downloading function.

Screenshot of a real-world scenario:

1. First, create a new directory in Grain `/var/exp\n/etc.host/passwd\n`, and use the Grain Backup function to download the backup file.
   ![](/assets/img/blog/20180126/5.png)
2. After unzipping the backup file, from `etc.host` we’ll see `/etc/passwd` of the server outside the sandbox.
   ![](/assets/img/blog/20180126/6.png)

### CVE-2017-6201

This is a classic SSRF (Server-Side Request Forgery) issue. Sandstorm allow installation of apps from arbitrary sources, and an attacker can simply let the server access a certain location by providing an installation URL. The problem was identified on `https://[target]/install/xxxChangeItEveryTimexxx?url=http://127.0.0.1:22/` This sample link confirms whether the server’s port 22 is open.

![](/assets/img/blog/20180126/7.png)

(Parse Error, which implies server’s port 22 is open)
## Follow-up Updates

After we reported the vulnerabilities, Sandstorm fixed it immediately and then published an article:
<https://sandstorm.io/news/2017-03-02-security-review>

Through this pentesting experience, we consider Sandstorm a safe platform with outstanding security mechanisms. This is mainly attributed to its fundamental design rationale: to assume that every app installed is malicious. With this vigilant assumption, Sandstorm’s defence mechanisms for the core system become comprehensive and watertight. Apart from the server-side protection, some common client-side attacks (such as XSS, CSRF) are handled properly by Sandstorm’s unique countermeasures, such as host name randomization. That is, it is very difficult for attackers to sabotage the server by simply manipulating the apps, and so does privilege escalation through attacking at the client-side.

Nevertheless, such an impressive platform still had some minor mistakes which led to security issues. Most of the vulnerabilities found this time are improper usages of libraries or negligence of existing defence architecture while introducing new features. These types of vulnerability are also common in our other projects. We would like to take the opportunity to remind developers, always present a comprehensive security review especially when developing new features to avoid vulnerabilities caused by the gaps between defence mechanisms.

[### Shaolin](/en/blog/author/shaolin)
Red Team Director

喜愛資訊技術、喜歡跟別人走不一樣的路。有一點點智障的熱血人，期望能利用資訊的力量對世界有所貢獻。

[![](/images/logo.svg)](/en/)

###### Services

* [Red Team Assessment](/en/services/red-team/)
* [Penetration Testing](/en/services/penetration-test/)
* [Security Consulting](/en/services/security-consulting/)
* [Security Training](/en/services/security-training/)

###### Research

* [Overview](/en/research/overview/)
* [Competitions and Awards](/en/research/awards/)
* [Enterprise Vulnerability Reports](/en/research/bug-bounty/)
* [International Conferences](/en/research/talks/)
* [CVE List](/en/research/cve/)

###### Company

* [Company Overview](/en/company/about/)
* [Team Members](/en/company/our-team/)
* [Achievements](/en/company/history/)
* [Corporate Social Responsibility](/en/company/csr/)
* [Job Opportunities](/en/company/jobs/)
* [Contact](/en/contact/)

###### News

* [Blog](/en/blog/)
* [Media Resources](/en/media-kit/)

© 2025 DEVCORE **All rights reserved.**
[Privacy Policy](/en/privacy-policy/)

Language :[中文](/)|[English](/en/)



=== Content from github.com_4a2080ed_20250124_161914.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fsandstorm-io%2Fsandstorm%2Fblob%2Fv0.202%2Fsrc%2Fsandstorm%2Fsupervisor.c%2B%2B)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fsandstorm-io%2Fsandstorm%2Fblob%2Fv0.202%2Fsrc%2Fsandstorm%2Fsupervisor.c%2B%2B)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=sandstorm-io%2Fsandstorm)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[sandstorm-io](/sandstorm-io)
/
**[sandstorm](/sandstorm-io/sandstorm)**
Public

* [Notifications](/login?return_to=%2Fsandstorm-io%2Fsandstorm) You must be signed in to change notification settings
* [Fork
  710](/login?return_to=%2Fsandstorm-io%2Fsandstorm)
* [Star
   6.8k](/login?return_to=%2Fsandstorm-io%2Fsandstorm)

* [Code](/sandstorm-io/sandstorm/tree/v0.202)
* [Issues
  629](/sandstorm-io/sandstorm/issues)
* [Pull requests
  20](/sandstorm-io/sandstorm/pulls)
* [Actions](/sandstorm-io/sandstorm/actions)
* [Projects
  0](/sandstorm-io/sandstorm/projects)
* [Wiki](/sandstorm-io/sandstorm/wiki)
* [Security](/sandstorm-io/sandstorm/security)
* [Insights](/sandstorm-io/sandstorm/pulse)

Additional navigation options

* [Code](/sandstorm-io/sandstorm/tree/v0.202)
* [Issues](/sandstorm-io/sandstorm/issues)
* [Pull requests](/sandstorm-io/sandstorm/pulls)
* [Actions](/sandstorm-io/sandstorm/actions)
* [Projects](/sandstorm-io/sandstorm/projects)
* [Wiki](/sandstorm-io/sandstorm/wiki)
* [Security](/sandstorm-io/sandstorm/security)
* [Insights](/sandstorm-io/sandstorm/pulse)

## Files

 v0.202
## Breadcrumbs

1. [sandstorm](/sandstorm-io/sandstorm/tree/v0.202)
2. /[src](/sandstorm-io/sandstorm/tree/v0.202/src)
3. /[sandstorm](/sandstorm-io/sandstorm/tree/v0.202/src/sandstorm)
/
# supervisor.c++

Copy path Blame  Blame
## Latest commit

## History

[History](/sandstorm-io/sandstorm/commits/v0.202/src/sandstorm/supervisor.c%2B%2B)2409 lines (2036 loc) · 93.2 KB v0.202
## Breadcrumbs

1. [sandstorm](/sandstorm-io/sandstorm/tree/v0.202)
2. /[src](/sandstorm-io/sandstorm/tree/v0.202/src)
3. /[sandstorm](/sandstorm-io/sandstorm/tree/v0.202/src/sandstorm)
/
# supervisor.c++

Top
## File metadata and controls

* Code
* Blame

2409 lines (2036 loc) · 93.2 KB[Raw](https://github.com/sandstorm-io/sandstorm/raw/refs/tags/v0.202/src/sandstorm/supervisor.c%2B%2B)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000// Sandstorm - Personal Cloud Sandbox// Copyright (c) 2014 Sandstorm Development Group, Inc. and contributors// All rights reserved.//// Licensed under the Apache License, Version 2.0 (the "License");// you may not use this file except in compliance with the License.// You may obtain a copy of the License at//// http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an "AS IS" BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.
#include "supervisor.h"
#include <kj/main.h>#include <kj/debug.h>#include <kj/async-io.h>#include <kj/async-unix.h>#include <kj/io.h>#include <capnp/rpc-twoparty.h>#include <capnp/rpc.capnp.h>#include <unistd.h>#include <netinet/in.h> // needs to be included before sys/capability.h#include <sys/stat.h>#include <sys/types.h>#include <sys/time.h>#include <sys/wait.h>#include <sys/socket.h>#include <sys/un.h>#include <sys/mount.h>#include <sys/prctl.h>#include <sys/capability.h>#include <sys/ptrace.h>#include <sys/syscall.h>#include <linux/sockios.h>#include <linux/route.h>#include <sandstorm/ip\_tables.h> // created by Makefile from <linux/netfilter\_ipv4/ip\_tables.h>#include <linux/netfilter/nf\_nat.h>#include <fcntl.h>#include <errno.h>#include <stdlib.h>#include <limits.h>#include <sched.h>#include <dirent.h>#include <pwd.h>#include <grp.h>#include <sys/inotify.h>#include <map>#include <unordered\_map>#include <execinfo.h>#include <linux/netlink.h>#include <linux/rtnetlink.h>#include <sys/eventfd.h>#include <sys/resource.h>
// We need to define these constants before libseccomp has a chance to inject bogus// values for them. See https://github.com/seccomp/libseccomp/issues/27#ifndef \_\_NR\_seccomp#define \_\_NR\_seccomp 317#endif#ifndef \_\_NR\_bpf#define \_\_NR\_bpf 321#endif#ifndef \_\_NR\_userfaultfd#define \_\_NR\_userfaultfd 323#endif#include <seccomp.h>
#include <sandstorm/grain.capnp.h>#include <sandstorm/supervisor.capnp.h>
#include "version.h"#include "send-fd.h"#include "util.h"
// In case kernel headers are old.#ifndef PR\_SET\_NO\_NEW\_PRIVS#define PR\_SET\_NO\_NEW\_PRIVS 38#endif
namespace sandstorm {
// =======================================================================================// Directory size watcher
class DiskUsageWatcher: private kj::TaskSet::ErrorHandler { // Class which watches a directory tree, counts up the total disk usage, and fires events when // it changes. Uses inotify. Which turns out to be... harder than it should be.
public: DiskUsageWatcher(kj::UnixEventPort& eventPort, kj::Timer& timer, SandstormCore::Client core) : eventPort(eventPort), timer(timer), core(kj::mv(core)), tasks(\*this) {}
 kj::Promise<void> init() { // Start watching the current directory.
 // Note: this function is also called to restart watching from scratch when the inotify event // queue overflows (hopefully rare).
 int fd; KJ\_SYSCALL(fd = inotify\_init1(IN\_NONBLOCK | IN\_CLOEXEC)); inotifyFd = kj::AutoCloseFd(fd);
 // Note that because we create the FdObserver before creating any watches, we don't have // to worry about the possibility that we missed an event between creation of the fd and // creation of the FdObserver. observer = kj::heap<kj::UnixEventPort::FdObserver>(eventPort, inotifyFd, kj::UnixEventPort::FdObserver::OBSERVE\_READ);
 totalSize = 0; watchMap.clear(); pendingWatches.add(nullptr); // root directory return readLoop(); }
private: kj::UnixEventPort& eventPort; kj::Timer& timer; SandstormCore::Client core; kj::AutoCloseFd inotifyFd; kj::Own<kj::UnixEventPort::FdObserver> observer; uint64\_t totalSize; uint64\_t reportedSize = kj::maxValue; bool reportInFlight = false;
 struct ChildInfo { kj::String name; uint64\_t size; }; struct WatchInfo { kj::String path; // null = root directory std::map<kj::StringPtr, ChildInfo> childSizes; }; std::unordered\_map<int, WatchInfo> watchMap; // Maps inotify watch descriptors to info about what is being watched.
 kj::Vector<kj::String> pendingWatches; // Directories we would like to watch, but we can't add watches on them just yet because we need // to finish processing a list of events received from inotify before we mess with the watch // descriptor table.
 kj::TaskSet tasks;
 void addPendingWatches() { // Start watching everything that has been added to the pendingWatches list.
 // We treat pendingWatches as a stack here in order to get DFS traversal of the directory tree. while (pendingWatches.size() > 0) { auto path = kj::mv(pendingWatches.end()[-1]); pendingWatches.removeLast(); addWatch(kj::mv(path)); } }
 void addWatch(kj::String&& path) { // Start watching `path`. This is idempotent -- it's safe to watch the same path multiple // times.
 static const uint32\_t FLAGS = IN\_CREATE | IN\_DELETE | IN\_MODIFY | IN\_MOVED\_FROM | IN\_MOVED\_TO | IN\_DONT\_FOLLOW | IN\_ONLYDIR | IN\_EXCL\_UNLINK;
 for (;;) { const char\* pathPtr = path == nullptr ? "." : path.cStr(); int wd = inotify\_add\_watch(inotifyFd, pathPtr, FLAGS | IN\_DONT\_FOLLOW | IN\_EXCL\_UNLINK);
 if (wd >= 0) { WatchInfo& watchInfo = watchMap[wd];
 // Update the watch map. Note that it's possible that inotify\_add\_watch() returned a // pre-existing watch descriptor, if we tried to add a watch on a directory we're // already watching. This can happen in various race conditions. Replacing the path is // actually exactly what we want to do in these cases anyway. watchInfo.path = kj::mv(path);
 // In the case that we are reusing an existing watch descriptor, we want to clear out the // existing contents as they may be stale due to, again, race conditions. for (auto& child: watchInfo.childSizes) { totalSize -= child.second.size; } watchInfo.childSizes.clear();
 // Now repopulate the children by listing the directory. DIR\* dir = opendir(pathPtr); if (dir != nullptr) { KJ\_DEFER(closedir(dir)); for (;;) { errno = 0; struct dirent\* entry = readdir(dir); if (entry == nullptr) { int error = errno; if (error == 0) { break; } else { KJ\_FAIL\_SYSCALL("readdir", error, pathPtr); } }
 kj::StringPtr name = entry->d\_name; if (name != "." && name != "..") { childEvent(watchInfo, name); } } }
 return; }
 // Error occurred. int error = errno; switch (error) { case EINTR: // Keep trying. break;
 case ENOENT: case ENOTDIR: // Apparently there is no longer a directory at this path. Perhaps it was deleted. // No matter. return;
 case ENOSPC: // No more inotify watches available. // TODO(someday): Revert to some sort of polling mode? For now, fall through to error // case. default: KJ\_FAIL\_SYSCALL("inotify\_add\_watch", error, path); } } }
 kj::Promise<void> readLoop() { addPendingWatches(); maybeReportSize(); return observer->whenBecomesReadable().then([this]() { alignas(uint64\_t) kj::byte buffer[4096];
 for (;;) { ssize\_t n; KJ\_NONBLOCKING\_SYSCALL(n = read(inotifyFd, buffer, sizeof(buffer)));
 if (n < 0) { // EAGAIN; try again later. return readLoop(); }
 KJ\_ASSERT(n > 0, "inotify EOF?");
 kj::byte\* pos = buffer; while (n > 0) { // Split off one event. auto event = reinterpret\_cast<struct inotify\_event\*>(pos); size\_t eventSize = sizeof(struct inotify\_event) + event->len; KJ\_ASSERT(eventSize <= n, "inotify returned partial event?"); KJ\_ASSERT(eventSize % sizeof(size\_t) == 0, "inotify event not aligned?"); n -= eventSize; pos += eventSize;
 if (event->mask & IN\_Q\_OVERFLOW) { // Queue overflow; start over from scratch. inotifyFd = nullptr; KJ\_LOG(WARNING, "inotify event queue overflow; restarting watch from scratch"); return init(); }
 auto iter = watchMap.find(event->wd); KJ\_ASSERT(iter != watchMap.end(), "inotify gave unknown watch descriptor?");
 if (event->mask & (IN\_CREATE | IN\_DELETE | IN\_MODIFY | IN\_MOVE)) { childEvent(iter->second, event->name); }
 if (event->mask & IN\_IGNORED) { // This watch descriptor is being removed, probably because it was deleted.
 // There shouldn't be any children left, but if there are, go ahead and un-count them. for (auto& child: iter->second.childSizes) { totalSize -= child.second.size; }
 watchMap.erase(iter); } } } }); }
 void childEvent(WatchInfo& watchInfo, kj::StringPtr name) { // Called to update the child table when we receive an inotify event with the given name.
 // OK, we received notification that something happened to the child named `name`. // Unfortunately, we don't have any idea how long ago this event happened. Worse, any // number of other events may have occurred since this one was generated. For example, // the event may have been on a file that has subsequently been deleted, and maybe even // recreated as a different kind of node. If we lstat() it, we get information about // what is currently on disk, not whatever generated this event. // // Therefore, the inotify event mask is mostly useless. We can only use the event as a hint // that something happened at this child. We have to compare what we know about the child // vs. what we knew in the past to determine what has changed. Note that if inotify // provided a `struct stat` along with the event then we wouldn't have this problem!
 auto usage = getDiskUsage(watchInfo.path, name); totalSize += usage.bytes;
 auto iter = watchInfo.childSizes.find(name); if (usage.bytes == 0) { // There is no longer a child by this name on disk. Remove whatever is in the map. if (iter != watchInfo.childSizes.end()) { totalSize -= iter->second.size; watchInfo.childSizes.erase(iter); } } else if (iter == watchInfo.childSizes.end()) { // There is a child by this name on disk, but not in the map. Add it. ChildInfo newChild = { kj::heapString(name), usage.bytes }; kj::StringPtr namePtr = newChild.name; KJ\_ASSERT(watchInfo.childSizes.insert(std::make\_pair(namePtr, kj::mv(newChild))).second); } else { // There is a child by this name on disk and in the map. Check for a change in size. totalSize -= iter->second.size; iter->second.size = usage.bytes; }
 maybeReportSize();
 // If the child is a directory, plan to start watching it later. Note that IN\_MODIFY events // are not generated for subdirectories (only files), so if we got an event on a directory it // must be create, move to, move from, or delete. In the latter two cases, the node wouldn't // exist anymore, so usage.isDir would be false. So, we know this directory is either // newly-created or newly moved in from elsewhere. In the creation case, we clearly need to // start watching the directory. In the moved-in case, we are probably already watching the // directory, however it is necessary to redo the watch because the path has changed and the // directory state may have become inconsistent in the time that the path was wrong. if (usage.isDir) { // We can't actually add the new watch now because we need to process the remaining // events from the last read() in order to make sure we're caught up with inotify's // state. pendingWatches.add(kj::mv(usage.path)); } }
 struct DiskUsage { kj::String path; uint64\_t bytes; bool isDir; };
 DiskUsage getDiskUsage(kj::StringPtr parent, kj::StringPtr name) { // Get the disk usage of the given file within the given parent directory. This is not exactly // the file size; it also includes estimates of storage overhead, such as rounding up to the // block size. If the file no longer exists, its size is reported as zero.
 kj::String path = parent == nullptr ? kj::heapString(name) : kj::str(parent, '/', name); for (;;) { struct stat stats; if (lstat(path.cStr(), &stats) >= 0) { // Success.
 DiskUsage result; result.path = kj::mv(path); result.isDir = S\_ISDIR(stats.st\_mode);
 // Count blocks, not length, because what we care about is allocated space. result.bytes = stats.st\_blocks \* 512;
 if (stats.st\_nlink != 0) { // Note: sometimes the link count actually is zero; it often is, for example, during // `git init`, which rapidly creates and deletes some temporary files.
 // Divide by link count so that files with many hardlinks aren't overcounted. result.bytes /= stats.st\_nlink; }
 return result; }
 // There was an error. int error = errno; switch (error) { case EINTR: // continue loop break; case ENOENT: // File no longer exists... case ENOTDIR: // ... and a parent directory was replaced. return {kj::mv(path), 0, false}; default: // Default KJ\_FAIL\_SYSCALL("lstat", error, path); } } }
 void maybeReportSize() { // Don't send multiple reports at once. When the first one finishes we'll send another one if // the size has changed in the meantime. if (reportInFlight) return;
 // If the last reported size is still correct, don't report. if (reportedSize == totalSize) return;
 reportInFlight = true;
 // Wait 500ms before reporting to gather other changes. tasks.add(timer.afterDelay(500 \* kj::MILLISECONDS) .then([this]() -> kj::Promise<void> { auto req = core.reportGrainSizeRequest(); uint64\_t sizeBeingReported = totalSize; req.setBytes(sizeBeingReported);
 return req.send().then([this,sizeBeingReported](auto) -> void { reportInFlight = false; reportedSize = sizeBeingReported;
 // If the size has changed further, initiate a new report. maybeReportSize(); }, [this](kj::Exception&& e) { reportInFlight = false;
 if (e.getType() == kj::Exception::Type::DISCONNECTED) { // SandstormCore disconnected. Due to our CoreRedirector logic, it will restore itself // eventually, and in fact further calls to SandstormCore should block until than // happens. So, initiate a new report immediately. maybeReportSize(); } else { // Some other error. Propagate. kj::throwFatalException(kj::mv(e)); } }); })); }
 void taskFailed(kj::Exception&& exception) override { KJ\_LOG(ERROR, exception); }};
// =======================================================================================// Termination handling: Must kill child if parent terminates.//// We also terminate automatically if we don't receive any keep-alives in a 5-minute interval.
pid\_t childPid = 0;bool keepAlive = true;uint32\_t wakelockCount = 0;
void logSafely(const char\* text) { // Log a message in an async-signal-safe way.
 while (text[0] != '\0') { ssize\_t n = write(STDERR\_FILENO, text, strlen(text)); if (n < 0) return; text += n; }}
#define SANDSTORM\_LOG(text) \ logSafely("\*\* SANDSTORM SUPERVISOR: " text "\n")
void killChild() { if (childPid != 0) { kill(childPid, SIGKILL); childPid = 0; }
 // We don't have to waitpid() because when we exit the child will be adopted by init which will // automatically reap it.}
[[noreturn]] void killChildAndExit(int status) { killChild();
 // TODO(cleanup): Decide what exit status is supposed to mean. Maybe it should just always be // zero? \_exit(status);}
void signalHandler(int signo) { switch (signo) { case SIGALRM: if (keepAlive) { SANDSTORM\_LOG("Grain still in use; staying up for now."); keepAlive = false; return; } else if (wakelockCount > 0) { SANDSTORM\_LOG("Grain has been backgrounded; staying up for now."); return; } SANDSTORM\_LOG("Grain no longer in use; shutting down."); killChildAndExit(0);
 case SIGINT: case SIGTERM: SANDSTORM\_LOG("Grain supervisor terminated by signal."); killChildAndExit(0);
 default: // Some signal that should cause death. SANDSTORM\_LOG("Grain supervisor crashed due to signal.");
// // uncomment if trace is needed, but note that this is not really signal-safe.// {// void\* trace[16];// uint n = backtrace(trace, 16);// KJ\_LOG(ERROR, kj::strArray(kj::arrayPtr(trace, n), " "));// }
 killChildAndExit(1); }}
int DEATH\_SIGNALS[] = { // All signals that by default terminate the process. SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGABRT, SIGFPE, SIGSEGV, SIGTERM, SIGUSR1, SIGUSR2, SIGBUS, SIGPOLL, SIGPROF, SIGSYS, SIGTRAP, SIGVTALRM, SIGXCPU, SIGXFSZ, SIGSTKFLT, SIGPWR};
void registerSignalHandlers() { // Create a sigaction that runs our signal handler with all signals blocked. Our signal handler // completes (or exits) quickly anyway, so let's not try to deal with it being interruptable. struct sigaction action; memset(&action, 0, sizeof(action)); action.sa\_handler = &signalHandler; sigfillset(&action.sa\_mask);
 // SIGALRM will fire every 1.5 minutes and will kill us if no keepalive was received in that // time. KJ\_SYSCALL(sigaction(SIGALRM, &action, nullptr));
 // Other death signals simply kill us immediately. for (int signo: kj::ArrayPtr<int>(DEATH\_SIGNALS)) { KJ\_SYSCALL(sigaction(signo, &action, nullptr)); }
 // Set up the SIGALRM timer to check every 1.5 minutes whether we're idle. If we haven't received // a keep-alive request in a 1.5-minute period, we kill ourselves. The client normally sends // keep-alives every minute. Note that it's not the end of the world if we miss one; the server // will transparently start back up on the next request from the client. // Note that this is not inherited over fork. struct itimerval timer; memset(&timer, 0, sizeof(timer)); timer.it\_interval.tv\_sec = 90; timer.it\_value.tv\_sec = 90; KJ\_SYSCALL(setitimer(ITIMER\_REAL, &timer, nullptr));}
// =======================================================================================
SupervisorMain::SupervisorMain(kj::ProcessContext& context) : context(context), systemConnector(&DEFAULT\_CONNECTOR\_INSTANCE) { // Make sure we didn't inherit a weird signal mask from the parent process. Gotta do this as // early as possible so as not to confuse KJ code that deals with signals. sigset\_t sigset; KJ\_SYSCALL(sigemptyset(&sigset)); KJ\_SYSCALL(sigprocmask(SIG\_SETMASK, &sigset, nullptr));}
kj::MainFunc SupervisorMain::getMain() { return kj::MainBuilder(context, "Sandstorm version " SANDSTORM\_VERSION, "Runs a Sandstorm grain supervisor for the grain <grain-id>, which is " "an instance of app <app-id>. Executes <command> inside the grain " "sandbox.") .addOptionWithArg({"uid"}, KJ\_BIND\_METHOD(\*this, setUid), "<uid>", "Use setuid sandbox rather than userns. Must start as root, but swiches " "to <uid> to run the app.") .addOptionWithArg({"pkg"}, KJ\_BIND\_METHOD(\*this, setPkg), "<path>", "Set directory containing the app package. " "Defaults to '$SANDSTORM\_HOME/var/sandstorm/apps/<app-name>'.") .addOptionWithArg({"var"}, KJ\_BIND\_METHOD(\*this, setVar), "<path>", "Set directory where grain's mutable persistent data will be stored. " "Defaults to '$SANDSTORM\_HOME/var/sandstorm/grains/<grain-id>'.") .addOptionWithArg({'e', "env"}, KJ\_BIND\_METHOD(\*this, addEnv), "<name>=<val>", "Set the environment variable <name> to <val> inside the sandbox. Note " "that \*no\* environment variables are set by default.") .addOption({"proc"}, [this]() { setMountProc(true); return true; }, "Mount procfs inside the sandbox. For security reasons, this is NOT " "RECOMMENDED during normal use, but it may be useful for debugging.") .addOption({"stdio"}, [this]() { keepStdio = true; return true; }, "Don't redirect the sandbox's stdio. Useful for debugging.") .addOption({"dev"}, [this]() { devmode = true; return true; }, "Allow some system calls useful for debugging which are blocked in production.") .addOption({"seccomp-dump-pfc"}, [this]() { seccompDumpPfc = true; return true; }, "Dump libseccomp PFC output.") .addOption({'n', "new"}, [this]() { setIsNew(true); return true; }, "Initializes a new grain. (Otherwise, runs an existing one.)") .expectArg("<app-name>", KJ\_BIND\_METHOD(\*this, setAppName)) .expectArg("<grain-id>", KJ\_BIND\_METHOD(\*this, setGrainId)) .expectOneOrMoreArgs("<command>", KJ\_BIND\_METHOD(\*this, addCommandArg)) .callAfterParsing(KJ\_BIND\_METHOD(\*this, run)) .build();}
// =====================================================================================// Flag handlers
void SupervisorMain::setIsNew(bool isNew) { this->isNew = isNew;}
void SupervisorMain::setMountProc(bool mountProc) { if (mountProc) { context.warning("WARNING: --proc is dangerous. Only use it when debugging code you trust."); } this->mountProc = mountProc;}
kj::MainBuilder::Validity SupervisorMain::setAppName(kj::StringPtr name) { if (name == nullptr || name.findFirst('/') != nullptr) { return "Invalid app name."; } appName = kj::heapString(name); return true;}
kj::MainBuilder::Validity SupervisorMain::setGrainId(kj::StringPtr id) { if (id == nullptr || id.findFirst('/') != nullptr) { return "Invalid grain id."; } grainId = kj::heapString(id); return true;}
kj::MainBuilder::Validity SupervisorMain::setPkg(kj::StringPtr path) { pkgPath = realPath(kj::heapString(path)); return true;}
kj::MainBuilder::Validity SupervisorMain::setVar(kj::StringPtr path) { varPath = realPath(kj::heapString(path)); return true;}
kj::MainBuilder::Validity SupervisorMain::setUid(kj::StringPtr arg) { KJ\_IF\_MAYBE(u, parseUInt(arg, 10)) { if (getuid() != 0) { return "must start as root to use --uid"; } if (\*u == 0) { return "can't run sandbox as root"; } KJ\_SYSCALL(seteuid(\*u)); sandboxUid = \*u; return true; } else { return "UID must be a number"; }}
kj::MainBuilder::Validity SupervisorMain::addEnv(kj::StringPtr arg) { environment.add(kj::heapString(arg)); return true;}
kj::MainBuilder::Validity SupervisorMain::addCommandArg(kj::StringPtr arg) { command.add(kj::heapString(arg)); return true;}
// =====================================================================================
kj::MainBuilder::Validity SupervisorMain::run() { isIpTablesAvailable = checkIfIpTablesLoaded();
 setupSupervisor();
 // Exits if another supervisor is still running in this sandbox. systemConnector->checkIfAlreadyRunning();
 if (sandboxUid == nullptr) { SANDSTORM\_LOG("Starting up grain. Sandbox type: userns"); } else { SANDSTORM\_LOG("Starting up grain. Sandbox type: privileged"); }
 registerSignalHandlers();
 // Create eventfd that we'll use to block app startup until we've received an RPC requiring // it. This is a hack to allow serving files out of the app's www directory without starting // the app. int \_startEventFd; KJ\_SYSCALL(\_startEventFd = eventfd(0, EFD\_CLOEXEC)); kj::AutoCloseFd startEventFd(\_startEventFd);
 // Allocate the API socket. int fds[2]; KJ\_SYSCALL(socketpair(AF\_UNIX, SOCK\_STREAM | SOCK\_CLOEXEC, 0, fds));
 // Now time to run the start command, in a further chroot. KJ\_SYSCALL(childPid = fork()); if (childPid == 0) { // We're in the child. KJ\_SYSCALL(close(fds[0])); // just to be safe, even though it's CLOEXEC. runChild(fds[1], kj::mv(startEventFd)); } else { // We're in the supervisor. KJ\_DEFER(killChild()); KJ\_SYSCALL(close(fds[1])); runSupervisor(fds[0], kj::mv(startEventFd)); }}
// =====================================================================================
void SupervisorMain::bind(kj::StringPtr src, kj::StringPtr dst, unsigned long flags) { // Contrary to the documentation of MS\_BIND claiming this is no longer the case after 2.6.26, // mountflags are ignored on the initial bind. We have to issue a subsequent remount to set // them. KJ\_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr, MS\_BIND, nullptr), src, dst); KJ\_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr, MS\_BIND | MS\_REMOUNT | MS\_NOSUID | flags, nullptr), src, dst);}
kj::String SupervisorMain::realPath(kj::StringPtr path) { char\* cResult = realpath(path.cStr(), nullptr); if (cResult == nullptr) { int error = errno; if (error != ENOENT) { KJ\_FAIL\_SYSCALL("realpath", error, path); }
 // realpath() fails if the target doesn't exist, but our goal here is just to convert a // relative path to absolute whether it exists or not. So try resolving the parent instead. KJ\_IF\_MAYBE(slashPos, path.findLast('/')) { if (\*slashPos == 0) { // Path is e.g. "/foo". The root directory obviously exists. return kj::heapString(path); } else { return kj::str(realPath(kj::heapString(path.slice(0, \*slashPos))), path.slice(\*slashPos)); } } else { // Path is a relative path with only one component. char\* cwd = getcwd(nullptr, 0); KJ\_DEFER(free(cwd)); if (cwd[0] == '/' && cwd[1] == '\0') { return kj::str('/', path); } else { return kj::str(cwd, '/', path); } } } auto result = kj::heapString(cResult); free(cResult); return result;}
// =====================================================================================
void SupervisorMain::setupSupervisor() { // Enable no\_new\_privs so that once we drop privileges we can never regain them through e.g. // execing a suid-root binary. Sandboxed apps should not need that. KJ\_SYSCALL(prctl(PR\_SET\_NO\_NEW\_PRIVS, 1, 0, 0, 0));
 closeFds(); setResourceLimits(); checkPaths(); unshareOuter(); setupFilesystem(); setupStdio();
 // Note: permanentlyDropSuperuser() is performed post-fork; see comment in function def.}
void SupervisorMain::closeFds() { // Close all unexpected file descriptors (i.e. other than stdin/stdout/stderr). This is a // safety measure incase we were launched by a badly-written parent program which forgot to // set CLOEXEC on its private file descriptors. We don't want the sandboxed process to // accidentally get access to those.
 // We detect open file descriptors by reading from /proc. // // We need to defer closing each FD until after the scan completes, because: // 1) We probably shouldn't change the directory contents while listing. // 2) opendir() itself opens an FD. Closing it would disrupt the scan. kj::Vector<int> fds;
 { DIR\* dir = opendir("/proc/self/fd"); if (dir == nullptr) { KJ\_FAIL\_SYSCALL("opendir(/proc/self/fd)", errno); } KJ\_DEFER(KJ\_SYSCALL(closedir(dir)) { break; });
 for (;;) { struct dirent entry; struct dirent\* eptr = nullptr; int error = readdir\_r(dir, &entry, &eptr); if (error != 0) { KJ\_FAIL\_SYSCALL("readdir\_r(/proc/self/fd)", error); } if (eptr == nullptr) { // End of directory. break; }
 if (eptr->d\_name[0] != '.') { char\* end; int fd = strtoul(eptr->d\_name, &end, 10); KJ\_ASSERT(\*end == '\0' && end > eptr->d\_name, "File in /proc/self/fd had non-numeric name?", eptr->d\_name); if (fd > STDERR\_FILENO) { fds.add(fd); } } } }
 int saveFd = systemConnector->getSaveFd().orDefault(0);
 for (int fd: fds) { if (fd != saveFd) { // Ignore close errors -- we don't care, as long as the file is closed. (Also, one close() // will always return EBADF because it's the directory FD closed in closedir().) close(fd); } }}
void SupervisorMain::setResourceLimits() { struct rlimit limit; memset(&limit, 0, sizeof(limit)); limit.rlim\_cur = 1024; limit.rlim\_max = 4096; KJ\_SYSCALL(setrlimit(RLIMIT\_NOFILE, &limit));}
void SupervisorMain::checkPaths() { // Create or verify the pkg, var, and tmp directories.
 // Let us be explicit about permissions for now. umask(0);
 // Set default paths if flags weren't provided. if (pkgPath == nullptr) pkgPath = kj::str("/var/sandstorm/apps/", appName); if (varPath == nullptr) varPath = kj::str("/var/sandstorm/grains/", grainId);
 // Check that package exists. KJ\_SYSCALL(access(pkgPath.cStr(), R\_OK | X\_OK), pkgPath);
 // Create / verify existence of the var directory. Do this as the target user. if (isNew) { if (mkdir(varPath.cStr(), 0770) != 0) { int error = errno; if (errno == EEXIST) { context.exitError(kj::str("Grain already exists: ", grainId)); } else { KJ\_FAIL\_SYSCALL("mkdir(varPath.cStr(), 0770)", error, varPath); } } KJ\_SYSCALL(mkdir(kj::str(varPath, "/sandbox").cStr(), 0770), varPath); } else { if (access(varPath.cStr(), R\_OK | W\_OK | X\_OK) != 0) { int error = errno; if (error == ENOENT) { context.exitError(kj::str("No such grain: ", grainId)); } else { KJ\_FAIL\_SYSCALL("access(varPath.cStr(), R\_OK | W\_OK | X\_OK)", error, varPath); } } }
 // Create the temp directory if it doesn't exist. We only need one tmpdir because we're just // going to bind it to a private mount anyway. if (mkdir(kj::str("/tmp/sandstorm-grain").cStr(), 0770) < 0) { int error = errno; if (error != EEXIST) { KJ\_FAIL\_SYSCALL("mkdir(\"/tmp/sandstorm-grain\")", error); } }
 // Create the log file while we're still non-superuser. int logfd; KJ\_SYSCALL(logfd = open(kj::str(varPath, "/log").cStr(), O\_WRONLY | O\_APPEND | O\_CLOEXEC | O\_CREAT, 0600)); KJ\_SYSCALL(close(logfd));}
void SupervisorMain::writeSetgroupsIfPresent(const char \*contents) { KJ\_IF\_MAYBE(fd, raiiOpenIfExists("/proc/self/setgroups", O\_WRONLY | O\_CLOEXEC)) { kj::FdOutputStream(kj::mv(\*fd)).write(contents, strlen(contents)); }}
void SupervisorMain::writeUserNSMap(const char \*type, kj::StringPtr contents) { kj::FdOutputStream(raiiOpen(kj::str("/proc/self/", type, "\_map").cStr(), O\_WRONLY | O\_CLOEXEC)) .write(contents.begin(), contents.size());}
void SupervisorMain::unshareOuter() { if (sandboxUid == nullptr) { // Use user namespaces. pid\_t uid = getuid(), gid = getgid();
 // Unshare all of the namespaces except network. Note that unsharing the pid namespace is a // little odd in that it doesn't actually affect this process, but affects later children // created by it. KJ\_SYSCALL(unshare(CLONE\_NEWUSER | CLONE\_NEWNS | CLONE\_NEWIPC | CLONE\_NEWUTS | CLONE\_NEWPID));
 // Map ourselves as 1000:1000, since it costs nothing to mask the uid and gid. uid\_t fakeUid = 1000; gid\_t fakeGid = 1000;
 if (devmode) { // "Randomize" the UID and GID in dev mode. This catches app bugs where the app expects the // UID or GID to be always 1000, which is not true of servers that use the privileged sandbox // rather than the userns sandbox. (The "randomization" algorithm here is only meant to // appear random to a human. The funny-looking numbers are just arbitrary primes chosen // without much thought.) time\_t now = time(nullptr); fakeUid = now \* 4721 % 2000 + 1; fakeGid = now \* 2791 % 2000 + 1; }
 writeSetgroupsIfPresent("deny\n"); writeUserNSMap("uid", kj::str(fakeUid, " ", uid, " 1\n")); writeUserNSMap("gid", kj::str(fakeGid, " ", gid, " 1\n")); } else { // Use root privileges instead of user namespaces.
 // We need to raise our privileges to call unshare(), and to perform other setup that occurs // after unshare(). KJ\_SYSCALL(seteuid(0));
 // Unshare all of the namespaces except network. Note that unsharing the pid namespace is a // little odd in that it doesn't actually affect this process, but affects later children // created by it. KJ\_SYSCALL(unshare(CLONE\_NEWNS | CLONE\_NEWIPC | CLONE\_NEWUTS | CLONE\_NEWPID)); }
 // To really unshare the mount namespace, we also have to make sure all mounts are private. // The parameters here were derived by strace'ing `mount --make-rprivate /`. AFAICT the flags // are undocumented. :( KJ\_SYSCALL(mount("none", "/", nullptr, MS\_REC | MS\_PRIVATE, nullptr));
 // Set a dummy host / domain so the grain can't see the real one. (unshare(CLONE\_NEWUTS) means // these settings only affect this process and its children.) KJ\_SYSCALL(sethostname("sandbox", 7)); KJ\_SYSCALL(setdomainname("sandbox", 7));}
void SupervisorMain::makeCharDeviceNode( const char \*name, const char\* realName, int major, int minor) { // Creating a real device node with mknod won't work on any current kernel, and we're // currently stuck with the filesystem being nodev, so even if mknod were to work, the // resulting device node wouldn't function. auto dst = kj::str("dev/", name); KJ\_SYSCALL(mknod(dst.cStr(), S\_IFREG | 0666, 0)); KJ\_SYSCALL(mount(kj::str("/dev/", realName).cStr(), dst.cStr(), nullptr, MS\_BIND, nullptr));}
void SupervisorMain::setupFilesystem() { // The root of our mount namespace will be the app package itself. We optionally create // tmp, dev, and var. tmp is an ordinary tmpfs. dev is a read-only tmpfs that contains // a few safe device nodes. var is the 'var/sandbox' directory inside the grain. // // Now for the tricky part: the supervisor needs to be able to see a little bit more. // In particular, it needs to be able to see the entire directory designated for the grain, // whereas the app only sees the "sandbox" subdirectory. We arrange for the the supervisor's // special directory to be ".", even though it's not mounted anywhere.
 // Set up the supervisor's directory. We immediately detach it from the mount tree, only // keeping a file descriptor, which we can later access via fchdir(). This prevents the // supervisor dir from being accessible to the app. bind(varPath, "/tmp/sandstorm-grain", MS\_NODEV | MS\_NOEXEC); auto supervisorDir = raiiOpen("/tmp/sandstorm-grain", O\_RDONLY | O\_DIRECTORY | O\_CLOEXEC); KJ\_SYSCALL(umount2("/tmp/sandstorm-grain", MNT\_DETACH));
 // Bind the app package to "sandbox", which will be the grain's root directory. bind(pkgPath, "/tmp/sandstorm-grain", MS\_NODEV | MS\_RDONLY);
 // Change to that directory. KJ\_SYSCALL(chdir("/tmp/sandstorm-grain"));
 // Optionally bind var, tmp, dev if the app requests it by having the corresponding directories // in the package. if (access("tmp", F\_OK) == 0) { // Create a new tmpfs for this run. We don't use a shared one or just /tmp for two reasons: // 1) tmpfs has no quota control, so a shared instance could be DoS'd by any one grain, or // just used to effectively allocate more RAM than the grain is allowed. // 2) When we exit, the mount namespace disappears and the tmpfs is thus automatically // unmounted. No need for careful cleanup, and no need to implement a risky recursive // delete. KJ\_SYSCALL(mount("sandstorm-tmp", "tmp", "tmpfs", MS\_NOSUID, "size=16m,nr\_inodes=4k,mode=770")); } if (access("dev", F\_OK) == 0) { KJ\_SYSCALL(mount("sandstorm-dev", "dev", "tmpfs", MS\_NOATIME | MS\_NOSUID | MS\_NOEXEC | MS\_NODEV, "size=1m,nr\_inodes=16,mode=755")); makeCharDeviceNode("null", "null", 1, 3); makeCharDeviceNode("zero", "zero", 1, 5); makeCharDeviceNode("random", "urandom", 1, 9); makeCharDeviceNode("urandom", "urandom", 1, 9); KJ\_SYSCALL(mount("dev", "dev", nullptr, MS\_REMOUNT | MS\_BIND | MS\_NOEXEC | MS\_NOSUID | MS\_NODEV | MS\_RDONLY,[View remainder of file in raw view](https://github.com/sandstorm-io/sandstorm/raw/refs/tags/v0.202/src/sandstorm/supervisor.c%2B%2B)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


