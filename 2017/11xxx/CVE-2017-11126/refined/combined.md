=== Content from blogs.gentoo.org_9d8cd473_20250125_224215.html ===


[agostino's blog](https://blogs.gentoo.org/ago/ "agostino's blog")

my fuzzer always find something more than your…
![](https://blogs.gentoo.org/ago/files/2015/06/cropped-modificato2.png)

[Skip to content](#content "Skip to content")

* [About me](https://blogs.gentoo.org/ago/agostino_sarubbo/)
* [Contact](https://blogs.gentoo.org/ago/contact/)
* [Advisories](https://blogs.gentoo.org/ago/advisories/)

[← xar: NULL pointer dereference in xar\_get\_path (util.c)](https://blogs.gentoo.org/ago/2017/06/28/xar-null-pointer-dereference-in-xar_get_path-util-c/)
[graphicsmagick: use-after-free in CloseBlob (blob.c) →](https://blogs.gentoo.org/ago/2017/07/12/graphicsmagick-use-after-free-in-closeblob-blob-c/)

# mpg123: global buffer overflow in III\_i\_stereo (layer3.c)

Posted on [July 3, 2017](https://blogs.gentoo.org/ago/2017/07/03/mpg123-global-buffer-overflow-in-iii_i_stereo-layer3-c/ "11:06 pm") by [ago](https://blogs.gentoo.org/ago/author/ago/ "View all posts by ago")

**Description**:

[mpg123](http://www.mpg123.org) is a fast console MPEG Audio Player and decoder library.

The complete ASan output of the issue:

```
# mpg123-mpg123 -t $FILE
==10588==ERROR: AddressSanitizer: global-buffer-overflow on address 0x7f01025c5cbc at pc 0x7f010229bfe3 bp 0x7ffc988ac5b0 sp 0x7ffc988ac5a8
READ of size 4 at 0x7f01025c5cbc thread T0
    #0 0x7f010229bfe2 in III_i_stereo /var/tmp/portage/media-sound/mpg123-1.25.0/work/mpg123-1.25.0/src/libmpg123/layer3.c:1343:10
    #1 0x7f010229bfe2 in INT123_do_layer3 /var/tmp/portage/media-sound/mpg123-1.25.0/work/mpg123-1.25.0/src/libmpg123/layer3.c:2013
    #2 0x7f01021d3708 in decode_the_frame /var/tmp/portage/media-sound/mpg123-1.25.0/work/mpg123-1.25.0/src/libmpg123/libmpg123.c:710:14
    #3 0x7f01021dc61d in mpg123_decode_frame /var/tmp/portage/media-sound/mpg123-1.25.0/work/mpg123-1.25.0/src/libmpg123/libmpg123.c:849:4
    #4 0x535783 in play_frame /var/tmp/portage/media-sound/mpg123-1.25.0/work/mpg123-1.25.0/src/mpg123.c:739:7
    #5 0x53a3a7 in main /var/tmp/portage/media-sound/mpg123-1.25.0/work/mpg123-1.25.0/src/mpg123.c:1363:8
    #6 0x7f0100f1d680 in __libc_start_main /tmp/portage/sys-libs/glibc-2.23-r3/work/glibc-2.23/csu/../csu/libc-start.c:289
    #7 0x41bec8 in mpg123_seek_frame (/usr/bin/mpg123-mpg123+0x41bec8)

0x7f01025c5cbc is located 4 bytes to the left of global variable 'pow2_1' defined in '/var/tmp/portage/media-sound/mpg123-1.25.0/work/mpg123-1.25.0/src/libmpg123/layer3.c:50:27' (0x7f01025c5cc0) of size 128
0x7f01025c5cbc is located 28 bytes to the right of global variable 'pow1_1' defined in '/var/tmp/portage/media-sound/mpg123-1.25.0/work/mpg123-1.25.0/src/libmpg123/layer3.c:50:13' (0x7f01025c5c20) of size 128
SUMMARY: AddressSanitizer: global-buffer-overflow /var/tmp/portage/media-sound/mpg123-1.25.0/work/mpg123-1.25.0/src/libmpg123/layer3.c:1343:10 in III_i_stereo
Shadow bytes around the buggy address:
  0x0fe0a04b0b40: f9 f9 f9 f9 00 04 f9 f9 f9 f9 f9 f9 00 04 f9 f9
  0x0fe0a04b0b50: f9 f9 f9 f9 00 00 00 00 00 00 00 00 f9 f9 f9 f9
  0x0fe0a04b0b60: 00 00 00 00 00 00 00 00 f9 f9 f9 f9 00 00 00 00
  0x0fe0a04b0b70: 00 00 00 00 f9 f9 f9 f9 00 00 00 00 00 00 00 00
  0x0fe0a04b0b80: f9 f9 f9 f9 00 00 00 00 00 00 00 00 00 00 00 00
=>0x0fe0a04b0b90: 00 00 00 00 f9 f9 f9[f9]00 00 00 00 00 00 00 00
  0x0fe0a04b0ba0: 00 00 00 00 00 00 00 00 f9 f9 f9 f9 00 00 00 00
  0x0fe0a04b0bb0: 00 00 00 00 00 00 00 00 00 00 00 00 f9 f9 f9 f9
  0x0fe0a04b0bc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0fe0a04b0bd0: f9 f9 f9 f9 00 00 00 00 00 00 00 00 00 00 00 00
  0x0fe0a04b0be0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==10588==ABORTING

```

**Affected version:**

1.25.1

**Fixed version:**

1.25.2 (not released atm)

**Commit fix:**

<https://scm.orgis.org/view/mpg123/trunk/src/libmpg123/layer3.c?view=patch&r1=4275&r2=4274&pathrev=4275>

**Credit:**

This bug was discovered by Agostino Sarubbo of Gentoo.

**CVE:**

CVE-2017-11126

**Reproducer:**

<https://github.com/asarubbo/poc/blob/master/00300-mpg123-globaloverflow-III_i_stereo>

**Timeline:**

2017-06-30: bug discovered and reported to upstream

2017-07-03: blog post about the issue

2017-07-10: CVE assigned

**Note:**

This bug was found with [American Fuzzy Lop](http://lcamtuf.coredump.cx/afl).

**Permalink:**

> [mpg123: global buffer overflow in III\_i\_stereo (layer3.c)](http://blogs.gentoo.org/ago/2017/07/03/mpg123-global-buffer-overflow-in-iii_i_stereo-layer3-c/)

This entry was posted in [advisories](https://blogs.gentoo.org/ago/category/advisories/), [security](https://blogs.gentoo.org/ago/category/security/). Bookmark the [permalink](https://blogs.gentoo.org/ago/2017/07/03/mpg123-global-buffer-overflow-in-iii_i_stereo-layer3-c/ "Permalink to mpg123: global buffer overflow in III_i_stereo (layer3.c)").

[← xar: NULL pointer dereference in xar\_get\_path (util.c)](https://blogs.gentoo.org/ago/2017/06/28/xar-null-pointer-dereference-in-xar_get_path-util-c/)
[graphicsmagick: use-after-free in CloseBlob (blob.c) →](https://blogs.gentoo.org/ago/2017/07/12/graphicsmagick-use-after-free-in-closeblob-blob-c/)

### One Response to *mpg123: global buffer overflow in III\_i\_stereo (layer3.c)*

1. Pingback: [CVE-2017-11126 – 安百科技](https://vul.anbai.com/35983.html)

### Leave a Reply [Cancel reply](/ago/2017/07/03/mpg123-global-buffer-overflow-in-iii_i_stereo-layer3-c/#respond)

Your email address will not be published. Required fields are marked \*

Comment \*

Name \*

Email \*

Website

 Notify me of follow-up comments by email.

 Notify me of new posts by email.

Authenticate this comment using OpenID.

Δ

This site uses Akismet to reduce spam. [Learn how your comment data is processed](https://akismet.com/privacy/).

* Search for:
* ### Recent Posts

  + [gentoo tinderbox](https://blogs.gentoo.org/ago/2020/07/04/gentoo-tinderbox/)
  + [re2c: heap overflow in Scanner::fill (scanner.cc)](https://blogs.gentoo.org/ago/2020/04/19/re2c-heap-overflow-in-scannerfill-scanner-cc/)
  + [Why I stopped fuzzing research](https://blogs.gentoo.org/ago/2020/04/16/why-i-stopped-fuzzing-research/)
  + [Install Gentoo in less than one minute](https://blogs.gentoo.org/ago/2019/03/20/install-gentoo-in-less-than-one-minute/)
  + [binutils: invalid memory read in find\_abstract\_instance\_name (dwarf2.c)](https://blogs.gentoo.org/ago/2017/10/24/binutils-invalid-memory-read-in-find_abstract_instance_name-dwarf2-c/)
* ### Recent Comments

  + strongcourage on [Why I stopped fuzzing research](https://blogs.gentoo.org/ago/2020/04/16/why-i-stopped-fuzzing-research/#comment-181437)
  + [Bob Friesenhahn](http://www.graphicsmagick.org/) on [Why I stopped fuzzing research](https://blogs.gentoo.org/ago/2020/04/16/why-i-stopped-fuzzing-research/#comment-181419)
  + [#gentoo dev: Why I stopped fuzzing research https://blogs.gentoo.or… | Dr. Roy Schestowitz (罗伊)](https://placeholderapi.wordpress.com/2020/04/18/gentoo-dev-why-i-stopped-fuzzing-research-https-blogs-gentoo-or/) on [Why I stopped fuzzing research](https://blogs.gentoo.org/ago/2020/04/16/why-i-stopped-fuzzing-research/#comment-181400)
  + Ulya on [Why I stopped fuzzing research](https://blogs.gentoo.org/ago/2020/04/16/why-i-stopped-fuzzing-research/#comment-181396)
  + ago on [Install Gentoo in less than one minute](https://blogs.gentoo.org/ago/2019/03/20/install-gentoo-in-less-than-one-minute/#comment-178429)
* ### Archives

  + [July 2020](https://blogs.gentoo.org/ago/2020/07/)
  + [April 2020](https://blogs.gentoo.org/ago/2020/04/)
  + [March 2019](https://blogs.gentoo.org/ago/2019/03/)
  + [October 2017](https://blogs.gentoo.org/ago/2017/10/)
  + [September 2017](https://blogs.gentoo.org/ago/2017/09/)
  + [August 2017](https://blogs.gentoo.org/ago/2017/08/)
  + [July 2017](https://blogs.gentoo.org/ago/2017/07/)
  + [June 2017](https://blogs.gentoo.org/ago/2017/06/)
  + [May 2017](https://blogs.gentoo.org/ago/2017/05/)
  + [April 2017](https://blogs.gentoo.org/ago/2017/04/)
  + [March 2017](https://blogs.gentoo.org/ago/2017/03/)
  + [February 2017](https://blogs.gentoo.org/ago/2017/02/)
  + [January 2017](https://blogs.gentoo.org/ago/2017/01/)
  + [December 2016](https://blogs.gentoo.org/ago/2016/12/)
  + [November 2016](https://blogs.gentoo.org/ago/2016/11/)
  + [October 2016](https://blogs.gentoo.org/ago/2016/10/)
  + [September 2016](https://blogs.gentoo.org/ago/2016/09/)
  + [August 2016](https://blogs.gentoo.org/ago/2016/08/)
  + [July 2016](https://blogs.gentoo.org/ago/2016/07/)
  + [February 2016](https://blogs.gentoo.org/ago/2016/02/)
  + [July 2015](https://blogs.gentoo.org/ago/2015/07/)
  + [August 2013](https://blogs.gentoo.org/ago/2013/08/)
  + [June 2013](https://blogs.gentoo.org/ago/2013/06/)
  + [May 2013](https://blogs.gentoo.org/ago/2013/05/)
  + [January 2013](https://blogs.gentoo.org/ago/2013/01/)
  + [December 2012](https://blogs.gentoo.org/ago/2012/12/)
  + [November 2012](https://blogs.gentoo.org/ago/2012/11/)
  + [October 2012](https://blogs.gentoo.org/ago/2012/10/)
  + [August 2012](https://blogs.gentoo.org/ago/2012/08/)
  + [July 2012](https://blogs.gentoo.org/ago/2012/07/)
  + [June 2012](https://blogs.gentoo.org/ago/2012/06/)
* ### Categories

  + [advisories](https://blogs.gentoo.org/ago/category/advisories/)
  + [arch testing](https://blogs.gentoo.org/ago/category/arch-testing/)
  + [gentoo](https://blogs.gentoo.org/ago/category/gentoo/)
  + [security](https://blogs.gentoo.org/ago/category/security/)
* ### Meta

  + [Log in](https://blogs.gentoo.org/ago/wp-login.php)
  + [Entries feed](https://blogs.gentoo.org/ago/feed/)
  + [Comments feed](https://blogs.gentoo.org/ago/comments/feed/)
  + [WordPress.org](https://wordpress.org/)

[agostino's blog](https://blogs.gentoo.org/ago/ "agostino's blog")
Original theme twentyten, modified by csslayer. Better experience in firefox and webkit.

[Proudly powered by WordPress.](http://wordpress.org/ "Semantic Personal Publishing Platform")



=== Content from scm.orgis.org_ed345fc1_20250126_123257.html ===
/\*
layer3.c: the layer 3 decoder
copyright 1995-2021 by the mpg123 project - free software under the terms of the LGPL 2.1
see COPYING and AUTHORS files in distribution or http://mpg123.org
initially written by Michael Hipp
Dear visitor:
If you feel you don't understand fully the works of this file, your feeling might be correct.
Optimize-TODO: put short bands into the band-field without the stride of 3 reals
Length-optimze: unify long and short band code where it is possible
The int-vs-pointer situation has to be cleaned up.
\*/
#include "mpg123lib\_intern.h"
#ifdef USE\_NEW\_HUFFTABLE
#include "newhuffman.h"
#else
#include "huffman.h"
#endif
#include "getbits.h"
#include "../common/debug.h"
/\* Predeclare the assembly routines, only called from wrappers here. \*/
void INT123\_dct36\_3dnow (real \*,real \*,real \*,const real \*,real \*);
void INT123\_dct36\_3dnowext(real \*,real \*,real \*,const real \*,real \*);
void INT123\_dct36\_x86\_64 (real \*,real \*,real \*,const real \*,real \*);
void INT123\_dct36\_sse (real \*,real \*,real \*,const real \*,real \*);
void INT123\_dct36\_avx (real \*,real \*,real \*,const real \*,real \*);
void INT123\_dct36\_neon (real \*,real \*,real \*,const real \*,real \*);
void INT123\_dct36\_neon64 (real \*,real \*,real \*,const real \*,real \*);
/\* define CUT\_SFB21 if you want to cut-off the frequency above 16kHz \*/
#if 0
#define CUT\_SFB21
#endif
#include "l3tabs.h"
#include "l3bandgain.h"
#ifdef RUNTIME\_TABLES
#include "init\_layer3.h"
#endif
/\* Decoder state data, living on the stack of INT123\_do\_layer3. \*/
struct gr\_info\_s
{
int scfsi;
unsigned part2\_3\_length;
unsigned big\_values;
unsigned scalefac\_compress;
unsigned block\_type;
unsigned mixed\_block\_flag;
unsigned table\_select[3];
/\* Making those two signed int as workaround for open64/pathscale/sun compilers, and also for consistency, since they're worked on together with other signed variables. \*/
int maxband[3];
int maxbandl;
unsigned maxb;
unsigned region1start;
unsigned region2start;
unsigned preflag;
unsigned scalefac\_scale;
unsigned count1table\_select;
#ifdef REAL\_IS\_FIXED
const real \*full\_gain[3];
const real \*pow2gain;
#else
real \*full\_gain[3];
real \*pow2gain;
#endif
};
struct III\_sideinfo
{
unsigned main\_data\_begin;
unsigned private\_bits;
/\* Hm, funny... struct inside struct... \*/
struct { struct gr\_info\_s gr[2]; } ch[2];
};
#ifdef OPT\_MMXORSSE
real INT123\_init\_layer3\_gainpow2\_mmx(mpg123\_handle \*fr, int i)
{
if(!fr->p.down\_sample) return DOUBLE\_TO\_REAL(16384.0 \* pow((double)2.0,-0.25 \* (double) (i+210) ));
else return DOUBLE\_TO\_REAL(pow((double)2.0,-0.25 \* (double) (i+210)));
}
#endif
real INT123\_init\_layer3\_gainpow2(mpg123\_handle \*fr, int i)
{
return DOUBLE\_TO\_REAL\_SCALE\_LAYER3(pow((double)2.0,-0.25 \* (double) (i+210)),i+256);
}
void INT123\_init\_layer3\_stuff(mpg123\_handle \*fr, real (\*gainpow2\_func)(mpg123\_handle \*fr, int i))
{
int i,j;
#ifdef REAL\_IS\_FIXED
fr->gainpow2 = gainpow2;
#else
for(i=-256;i<118+4;i++)
fr->gainpow2[i+256] = gainpow2\_func(fr,i);
#endif
for(j=0;j<9;j++)
{
for(i=0;i<23;i++)
{
fr->longLimit[j][i] = (bandInfo[j].longIdx[i] - 1 + 8) / 18 + 1;
if(fr->longLimit[j][i] > (fr->down\_sample\_sblimit) )
fr->longLimit[j][i] = fr->down\_sample\_sblimit;
}
for(i=0;i<14;i++)
{
fr->shortLimit[j][i] = (bandInfo[j].shortIdx[i] - 1) / 18 + 1;
if(fr->shortLimit[j][i] > (fr->down\_sample\_sblimit) )
fr->shortLimit[j][i] = fr->down\_sample\_sblimit;
}
}
}
/\*
Observe!
Now come the actualy decoding routines.
\*/
/\* read additional side information (for MPEG 1 and MPEG 2) \*/
static int III\_get\_side\_info(mpg123\_handle \*fr, struct III\_sideinfo \*si,int stereo, int ms\_stereo,long sfreq,int single)
{
int ch, gr;
int powdiff = (single == SINGLE\_MIX) ? 4 : 0;
const int tabs[2][5] = { { 2,9,5,3,4 } , { 1,8,1,2,9 } };
const int \*tab = tabs[fr->hdr.lsf];
{ /\* First ensure we got enough bits available. \*/
unsigned int needbits = 0;
needbits += tab[1]; /\* main\_data\_begin \*/
needbits += stereo == 1 ? tab[2] : tab[3]; /\* private \*/
if(!fr->hdr.lsf)
needbits += stereo\*4; /\* scfsi \*/
/\* For each granule for each channel ... \*/
needbits += tab[0]\*stereo\*(29+tab[4]+1+22+(!fr->hdr.lsf?1:0)+2);
if(fr->bits\_avail < needbits) \
{
if(NOQUIET)
error2( "%u bits for side info needed, only %li available"
, needbits, fr->bits\_avail );
return 1;
}
}
si->main\_data\_begin = getbits(fr, tab[1]);
if(si->main\_data\_begin > fr->bitreservoir)
{
if(!fr->to\_ignore && VERBOSE2) fprintf(stderr, "Note: missing %d bytes in bit reservoir for frame %li\n", (int)(si->main\_data\_begin - fr->bitreservoir), (long)fr->num);
/\* overwrite main\_data\_begin for the really available bit reservoir \*/
backbits(fr, tab[1]);
if(fr->hdr.lsf == 0)
{
fr->wordpointer[0] = (unsigned char) (fr->bitreservoir >> 1);
fr->wordpointer[1] = (unsigned char) ((fr->bitreservoir & 1) << 7);
}
else fr->wordpointer[0] = (unsigned char) fr->bitreservoir;
/\* zero "side-info" data for a silence-frame
without touching audio data used as bit reservoir for following frame \*/
memset(fr->wordpointer+2, 0, fr->hdr.ssize-2);
/\* reread the new bit reservoir offset \*/
si->main\_data\_begin = getbits(fr, tab[1]);
}
/\* Keep track of the available data bytes for the bit reservoir.
CRC is included in ssize already. \*/
fr->bitreservoir = fr->bitreservoir + fr->hdr.framesize - fr->hdr.ssize;
/\* Limit the reservoir to the max for MPEG 1.0 or 2.x . \*/
if(fr->bitreservoir > (unsigned int) (fr->hdr.lsf == 0 ? 511 : 255))
fr->bitreservoir = (fr->hdr.lsf == 0 ? 511 : 255);
/\* Now back into less commented territory. It's code. It works. \*/
if (stereo == 1)
si->private\_bits = getbits(fr, tab[2]);
else
si->private\_bits = getbits(fr, tab[3]);
if(!fr->hdr.lsf) for(ch=0; chch[ch].gr[0].scfsi = -1;
si->ch[ch].gr[1].scfsi = getbits(fr, 4);
}
for (gr=0; grch[ch].gr[gr]);
unsigned int qss;
gr\_info->part2\_3\_length = getbits(fr, 12);
gr\_info->big\_values = getbits(fr, 9);
if(gr\_info->big\_values > 288)
{
if(NOQUIET) error("big\_values too large!");
gr\_info->big\_values = 288;
}
qss = getbits\_fast(fr, 8);
gr\_info->pow2gain = fr->gainpow2+256 - qss + powdiff;
if(ms\_stereo)
gr\_info->pow2gain += 2;
#ifndef NO\_MOREINFO
if(fr->pinfo)
fr->pinfo->qss[gr][ch] = qss;
#endif
gr\_info->scalefac\_compress = getbits(fr, tab[4]);
if(gr\_info->part2\_3\_length == 0)
{
if(gr\_info->scalefac\_compress > 0 && VERBOSE2)
error1( "scalefac\_compress should be zero instead of %i"
, gr\_info->scalefac\_compress );
gr\_info->scalefac\_compress = 0;
}
/\* 22 bits for if/else block \*/
if(getbits(fr,1))
{ /\* window switch flag \*/
int i;
gr\_info->block\_type = getbits\_fast(fr, 2);
gr\_info->mixed\_block\_flag = get1bit(fr);
gr\_info->table\_select[0] = getbits\_fast(fr, 5);
gr\_info->table\_select[1] = getbits\_fast(fr, 5);
/\*
table\_select[2] not needed, because there is no region2,
but to satisfy some verification tools we set it either.
\*/
gr\_info->table\_select[2] = 0;
for(i=0;i<3;i++)
{
unsigned int sbg = (getbits\_fast(fr, 3)<<3);
gr\_info->full\_gain[i] = gr\_info->pow2gain + sbg;
#ifndef NO\_MOREINFO
if(fr->pinfo)
fr->pinfo->sub\_gain[gr][ch][i] = sbg / 8;
#endif
}
if(gr\_info->block\_type == 0)
{
if(NOQUIET) error("Blocktype == 0 and window-switching == 1 not allowed.");
return 1;
}
/\* region\_count/start parameters are implicit in this case. \*/
if( (!fr->hdr.lsf || (gr\_info->block\_type == 2)) && !fr->hdr.mpeg25)
{
gr\_info->region1start = 36>>1;
gr\_info->region2start = 576>>1;
}
else
{
if(fr->hdr.mpeg25)
{
int r0c,r1c;
if((gr\_info->block\_type == 2) && (!gr\_info->mixed\_block\_flag) ) r0c = 5;
else r0c = 7;
/\* r0c+1+r1c+1 == 22, always. \*/
r1c = 20 - r0c;
gr\_info->region1start = bandInfo[sfreq].longIdx[r0c+1] >> 1 ;
gr\_info->region2start = bandInfo[sfreq].longIdx[r0c+1+r1c+1] >> 1;
}
else
{
gr\_info->region1start = 54>>1;
gr\_info->region2start = 576>>1;
}
}
}
else
{
int i,r0c,r1c;
for (i=0; i<3; i++)
gr\_info->table\_select[i] = getbits\_fast(fr, 5);
r0c = getbits\_fast(fr, 4); /\* 0 .. 15 \*/
r1c = getbits\_fast(fr, 3); /\* 0 .. 7 \*/
gr\_info->region1start = bandInfo[sfreq].longIdx[r0c+1] >> 1 ;
/\* max(r0c+r1c+2) = 15+7+2 = 24 \*/
if(r0c+1+r1c+1 > 22) gr\_info->region2start = 576>>1;
else gr\_info->region2start = bandInfo[sfreq].longIdx[r0c+1+r1c+1] >> 1;
gr\_info->block\_type = 0;
gr\_info->mixed\_block\_flag = 0;
}
if(!fr->hdr.lsf) gr\_info->preflag = get1bit(fr);
gr\_info->scalefac\_scale = get1bit(fr);
gr\_info->count1table\_select = get1bit(fr);
}
return 0;
}
/\* read scalefactors \*/
static int III\_get\_scale\_factors\_1(mpg123\_handle \*fr, int \*scf,struct gr\_info\_s \*gr\_info,int ch,int gr)
{
const unsigned char slen[2][16] =
{
{0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4},
{0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3}
};
int numbits;
int num0 = slen[0][gr\_info->scalefac\_compress];
int num1 = slen[1][gr\_info->scalefac\_compress];
if(gr\_info->block\_type == 2)
{
int i=18;
numbits = (num0 + num1) \* 18 /\* num0 \* (17+1?) + num1 \* 18 \*/
- (gr\_info->mixed\_block\_flag ? num0 : 0);
if(fr->bits\_avail < numbits)
return -1;
if(gr\_info->mixed\_block\_flag)
{
for (i=8;i;i--)
\*scf++ = getbits\_fast(fr, num0);
i = 9;
}
for(;i;i--) \*scf++ = getbits\_fast(fr, num0);
for(i = 18; i; i--) \*scf++ = getbits\_fast(fr, num1);
\*scf++ = 0; \*scf++ = 0; \*scf++ = 0; /\* short[13][0..2] = 0 \*/
}
else
{
int i;
int scfsi = gr\_info->scfsi;
if(scfsi < 0)
{ /\* scfsi < 0 => granule == 0 \*/
numbits = (num0 + num1) \* 10 + num0;
if(fr->bits\_avail < numbits)
return -1;
for(i=11;i;i--) \*scf++ = getbits\_fast(fr, num0);
for(i=10;i;i--) \*scf++ = getbits\_fast(fr, num1);
\*scf++ = 0;
}
else
{
numbits = !(scfsi & 0x8) \* num0 \* 6
+ !(scfsi & 0x4) \* num0 \* 5
+ !(scfsi & 0x2) \* num1 \* 5
+ !(scfsi & 0x1) \* num1 \* 5;
if(fr->bits\_avail < numbits)
return -1;
if(!(scfsi & 0x8))
{
for (i=0;i<6;i++) \*scf++ = getbits\_fast(fr, num0);
}
else scf += 6;
if(!(scfsi & 0x4))
{
for (i=0;i<5;i++) \*scf++ = getbits\_fast(fr, num0);
}
else scf += 5;
if(!(scfsi & 0x2))
{
for(i=0;i<5;i++) \*scf++ = getbits\_fast(fr, num1);
}
else scf += 5;
if(!(scfsi & 0x1))
{
for (i=0;i<5;i++) \*scf++ = getbits\_fast(fr, num1);
}
else scf += 5;
\*scf++ = 0; /\* no l[21] in original sources \*/
}
}
return numbits;
}
static int III\_get\_scale\_factors\_2(mpg123\_handle \*fr, int \*scf,struct gr\_info\_s \*gr\_info,int i\_stereo)
{
const unsigned char \*pnt;
int i,j,n=0,numbits=0;
unsigned int slen, slen2;
const unsigned char stab[3][6][4] =
{
{
{ 6, 5, 5,5 } , { 6, 5, 7,3 } , { 11,10,0,0},
{ 7, 7, 7,0 } , { 6, 6, 6,3 } , { 8, 8,5,0}
},
{
{ 9, 9, 9,9 } , { 9, 9,12,6 } , { 18,18,0,0},
{12,12,12,0 } , {12, 9, 9,6 } , { 15,12,9,0}
},
{
{ 6, 9, 9,9 } , { 6, 9,12,6 } , { 15,18,0,0},
{ 6,15,12,0 } , { 6,12, 9,6 } , { 6,18,9,0}
}
};
if(i\_stereo) /\* i\_stereo AND second channel -> INT123\_do\_layer3() checks this \*/
slen = i\_slen2[gr\_info->scalefac\_compress>>1];
else
slen = n\_slen2[gr\_info->scalefac\_compress];
gr\_info->preflag = (slen>>15) & 0x1;
n = 0;
if( gr\_info->block\_type == 2 )
{
n++;
if(gr\_info->mixed\_block\_flag) n++;
}
pnt = stab[n][(slen>>12)&0x7];
slen2 = slen;
for(i=0;i<4;i++)
{
int num = slen2 & 0x7;
slen2 >>= 3;
if(num)
numbits += pnt[i] \* num;
}
if(numbits > gr\_info->part2\_3\_length)
return -1;
for(i=0;i<4;i++)
{
int num = slen & 0x7;
slen >>= 3;
if(num)
{
for(j=0;j<(int)(pnt[i]);j++) \*scf++ = getbits\_fast(fr, num);
}
else
for(j=0;j<(int)(pnt[i]);j++) \*scf++ = 0;
}
n = (n << 1) + 1;
for(i=0;iscalefac\_scale;
// Pointer cast to make pedantic compilers happy.
real \*xrpnt = (real\*)xr;
// Some compiler freaks out over &xr[SBLIMIT][0], which is the same.
real \*xrpntlimit = (real\*)xr+SBLIMIT\*SSLIMIT;
int l[3],l3;
int part2remain = gr\_info->part2\_3\_length - part2bits;
const short \*me;
#ifdef REAL\_IS\_FIXED
int gainpow2\_scale\_idx = 378;
#endif
/\* Assumption: If there is some part2\_3\_length at all, there should be
enough of it to work with properly. In case of zero length we silently
zero things. \*/
if(gr\_info->part2\_3\_length > 0)
{
/\* mhipp tree has this split up a bit... \*/
int num=getbitoffset(fr);
MASK\_TYPE mask;
/\* We must split this, because for num==0 the shift is undefined if you do it in one step. \*/
mask = ((MASK\_UTYPE) getbits(fr, num))<big\_values;
int region1 = gr\_info->region1start;
int region2 = gr\_info->region2start;
l3 = ((576>>1)-bv)>>1;
/\* we may lose the 'odd' bit here !! check this later again \*/
if(bv <= region1)
{
l[0] = bv;
l[1] = 0;
l[2] = 0;
}
else
{
l[0] = region1;
if(bv <= region2)
{
l[1] = bv - l[0];
l[2] = 0;
}
else
{
l[1] = region2 - l[0];
l[2] = bv - region2;
}
}
}
#define CHECK\_XRPNT if(xrpnt >= xrpntlimit) \
{ \
if(NOQUIET) \
error2("attempted xrpnt overflow (%p !< %p)", (void\*) xrpnt, (void\*) xrpntlimit); \
return 1; \
}
if(gr\_info->block\_type == 2)
{
/\* decoding with short or mixed mode BandIndex table \*/
int i,max[4];
int step=0,lwin=3,cb=0;
register real v = 0.0;
register int mc;
register const short \*m;
if(gr\_info->mixed\_block\_flag)
{
max[3] = -1;
max[0] = max[1] = max[2] = 2;
m = map[sfreq][0];
me = mapend[sfreq][0];
}
else
{
max[0] = max[1] = max[2] = max[3] = -1;
/\* max[3] not really needed in this case \*/
m = map[sfreq][1];
me = mapend[sfreq][1];
}
mc = 0;
for(i=0;i<2;i++)
{
int lp = l[i];
const struct newhuff \*h = ht+gr\_info->table\_select[i];
for(;lp;lp--,mc--)
{
register MASK\_STYPE x,y;
if( (!mc) )
{
mc = \*m++;
//fprintf(stderr, "%i setting xrpnt = xr + %i (%ld)\n", \_\_LINE\_\_, \*m, xrpnt-(real\*)xr);
xrpnt = ((real \*) xr) + (\*m++);
lwin = \*m++;
cb = \*m++;
if(lwin == 3)
{
#ifdef REAL\_IS\_FIXED
gainpow2\_scale\_idx = (int)(gr\_info->pow2gain + (\*scf << shift) - fr->gainpow2);
#endif
v = gr\_info->pow2gain[(\*scf++) << shift];
step = 1;
}
else
{
#ifdef REAL\_IS\_FIXED
gainpow2\_scale\_idx = (int)(gr\_info->full\_gain[lwin] + (\*scf << shift) - fr->gainpow2);
#endif
v = gr\_info->full\_gain[lwin][(\*scf++) << shift];
step = 3;
}
}
{
const short \*val = h->table;
REFRESH\_MASK;
#ifdef USE\_NEW\_HUFFTABLE
while((y=val[(MASK\_UTYPE)mask>>(BITSHIFT+4)])<0)
{
val -= y;
num -= 4;
mask <<= 4;
}
num -= (y >> 8);
mask <<= (y >> 8);
x = (y >> 4) & 0xf;
y &= 0xf;
#else
while((y=\*val++)<0)
{
if (MSB\_MASK) val -= y;
num--;
mask <<= 1;
}
x = y >> 4;
y &= 0xf;
#endif
}
CHECK\_XRPNT;
if(x == 15 && h->linbits)
{
max[lwin] = cb;
REFRESH\_MASK;
x += ((MASK\_UTYPE) mask) >> (BITSHIFT+8-h->linbits);
num -= h->linbits+1;
mask <<= h->linbits;
if(MSB\_MASK) \*xrpnt = REAL\_MUL\_SCALE\_LAYER3(-ispow[x], v, gainpow2\_scale\_idx);
else \*xrpnt = REAL\_MUL\_SCALE\_LAYER3( ispow[x], v, gainpow2\_scale\_idx);
mask <<= 1;
}
else if(x)
{
max[lwin] = cb;
if(MSB\_MASK) \*xrpnt = REAL\_MUL\_SCALE\_LAYER3(-ispow[x], v, gainpow2\_scale\_idx);
else \*xrpnt = REAL\_MUL\_SCALE\_LAYER3( ispow[x], v, gainpow2\_scale\_idx);
num--;
mask <<= 1;
}
else \*xrpnt = DOUBLE\_TO\_REAL(0.0);
xrpnt += step;
CHECK\_XRPNT;
if(y == 15 && h->linbits)
{
max[lwin] = cb;
REFRESH\_MASK;
y += ((MASK\_UTYPE) mask) >> (BITSHIFT+8-h->linbits);
num -= h->linbits+1;
mask <<= h->linbits;
if(MSB\_MASK) \*xrpnt = REAL\_MUL\_SCALE\_LAYER3(-ispow[y], v, gainpow2\_scale\_idx);
else \*xrpnt = REAL\_MUL\_SCALE\_LAYER3( ispow[y], v, gainpow2\_scale\_idx);
mask <<= 1;
}
else if(y)
{
max[lwin] = cb;
if(MSB\_MASK) \*xrpnt = REAL\_MUL\_SCALE\_LAYER3(-ispow[y], v, gainpow2\_scale\_idx);
else \*xrpnt = REAL\_MUL\_SCALE\_LAYER3( ispow[y], v, gainpow2\_scale\_idx);
num--;
mask <<= 1;
}
else \*xrpnt = DOUBLE\_TO\_REAL(0.0);
xrpnt += step;
}
}
for(;l3 && (part2remain+num > 0);l3--)
{
const struct newhuff\* h;
const short\* val;
register short a;
h = htc+gr\_info->count1table\_select;
val = h->table;
REFRESH\_MASK;
while((a=\*val++)<0)
{
if(MSB\_MASK) val -= a;
num--;
mask <<= 1;
}
if(part2remain+num <= 0)
{
num -= part2remain+num;
break;
}
for(i=0;i<4;i++)
{
if(!(i & 1))
{
if(!mc)
{
mc = \*m++;
//fprintf(stderr, "%i setting xrpnt = xr + %i (%ld)\n", \_\_LINE\_\_, \*m, xrpnt-(real\*)xr);
xrpnt = ((real \*) xr) + (\*m++);
lwin = \*m++;
cb = \*m++;
if(lwin == 3)
{
#ifdef REAL\_IS\_FIXED
gainpow2\_scale\_idx = (int)(gr\_info->pow2gain + (\*scf << shift) - fr->gainpow2);
#endif
v = gr\_info->pow2gain[(\*scf++) << shift];
step = 1;
}
else
{
#ifdef REAL\_IS\_FIXED
gainpow2\_scale\_idx = (int)(gr\_info->full\_gain[lwin] + (\*scf << shift) - fr->gainpow2);
#endif
v = gr\_info->full\_gain[lwin][(\*scf++) << shift];
step = 3;
}
}
mc--;
}
CHECK\_XRPNT;
if( (a & (0x8>>i)) )
{
max[lwin] = cb;
if(part2remain+num <= 0)
break;
if(MSB\_MASK) \*xrpnt = -REAL\_SCALE\_LAYER3(v, gainpow2\_scale\_idx);
else \*xrpnt = REAL\_SCALE\_LAYER3(v, gainpow2\_scale\_idx);
num--;
mask <<= 1;
}
else \*xrpnt = DOUBLE\_TO\_REAL(0.0);
xrpnt += step;
}
}
if(lwin < 3)
{ /\* short band? \*/
while(1)
{
for(;mc > 0;mc--)
{
CHECK\_XRPNT;
\*xrpnt = DOUBLE\_TO\_REAL(0.0); xrpnt += 3; /\* short band -> step=3 \*/
\*xrpnt = DOUBLE\_TO\_REAL(0.0); xrpnt += 3;
}
if(m >= me)
break;
mc = \*m++;
xrpnt = ((real \*) xr) + \*m++;
if(\*m++ == 0)
break; /\* optimize: field will be set to zero at the end of the function \*/
m++; /\* cb \*/
}
}
gr\_info->maxband[0] = max[0]+1;
gr\_info->maxband[1] = max[1]+1;
gr\_info->maxband[2] = max[2]+1;
gr\_info->maxbandl = max[3]+1;
{
int rmax = max[0] > max[1] ? max[0] : max[1];
rmax = (rmax > max[2] ? rmax : max[2]) + 1;
gr\_info->maxb = rmax ? fr->shortLimit[sfreq][rmax] : fr->longLimit[sfreq][max[3]+1];
}
}
else
{
/\* decoding with 'long' BandIndex table (block\_type != 2) \*/
const unsigned char \*pretab = pretab\_choice[gr\_info->preflag];
int i,max = -1;
int cb = 0;
const short \*m = map[sfreq][2];
register real v = 0.0;
int mc = 0;
/\* long hash table values \*/
for(i=0;i<3;i++)
{
int lp = l[i];
const struct newhuff \*h = ht+gr\_info->table\_select[i];
for(;lp;lp--,mc--)
{
MASK\_STYPE x,y;
if(!mc)
{
mc = \*m++;
cb = \*m++;
#ifdef CUT\_SFB21
if(cb == 21)
v = 0.0;
else
#endif
{
#ifdef REAL\_IS\_FIXED
gainpow2\_scale\_idx = (int)(gr\_info->pow2gain + (\*scf << shift) - fr->gainpow2);
#endif
v = gr\_info->pow2gain[(\*(scf++) + (\*pretab++)) << shift];
}
}
{
const short \*val = h->table;
REFRESH\_MASK;
#ifdef USE\_NEW\_HUFFTABLE
while((y=val[(MASK\_UTYPE)mask>>(BITSHIFT+4)])<0)
{
val -= y;
num -= 4;
mask <<= 4;
}
num -= (y >> 8);
mask <<= (y >> 8);
x = (y >> 4) & 0xf;
y &= 0xf;
#else
while((y=\*val++)<0)
{
if (MSB\_MASK) val -= y;
num--;
mask <<= 1;
}
x = y >> 4;
y &= 0xf;
#endif
}
CHECK\_XRPNT;
if(x == 15 && h->linbits)
{
max = cb;
REFRESH\_MASK;
x += ((MASK\_UTYPE) mask) >> (BITSHIFT+8-h->linbits);
num -= h->linbits+1;
mask <<= h->linbits;
if(MSB\_MASK) \*xrpnt++ = REAL\_MUL\_SCALE\_LAYER3(-ispow[x], v, gainpow2\_scale\_idx);
else \*xrpnt++ = REAL\_MUL\_SCALE\_LAYER3( ispow[x], v, gainpow2\_scale\_idx);
mask <<= 1;
}
else if(x)
{
max = cb;
if(MSB\_MASK) \*xrpnt++ = REAL\_MUL\_SCALE\_LAYER3(-ispow[x], v, gainpow2\_scale\_idx);
else \*xrpnt++ = REAL\_MUL\_SCALE\_LAYER3( ispow[x], v, gainpow2\_scale\_idx);
num--;
mask <<= 1;
}
else \*xrpnt++ = DOUBLE\_TO\_REAL(0.0);
CHECK\_XRPNT;
if(y == 15 && h->linbits)
{
max = cb;
REFRESH\_MASK;
y += ((MASK\_UTYPE) mask) >> (BITSHIFT+8-h->linbits);
num -= h->linbits+1;
mask <<= h->linbits;
if(MSB\_MASK) \*xrpnt++ = REAL\_MUL\_SCALE\_LAYER3(-ispow[y], v, gainpow2\_scale\_idx);
else \*xrpnt++ = REAL\_MUL\_SCALE\_LAYER3( ispow[y], v, gainpow2\_scale\_idx);
mask <<= 1;
}
else if(y)
{
max = cb;
if(MSB\_MASK) \*xrpnt++ = REAL\_MUL\_SCALE\_LAYER3(-ispow[y], v, gainpow2\_scale\_idx);
else \*xrpnt++ = REAL\_MUL\_SCALE\_LAYER3( ispow[y], v, gainpow2\_scale\_idx);
num--;
mask <<= 1;
}
else \*xrpnt++ = DOUBLE\_TO\_REAL(0.0);
}
}
/\* short (count1table) values \*/
for(;l3 && (part2remain+num > 0);l3--)
{
const struct newhuff \*h = htc+gr\_info->count1table\_select;
const short \*val = h->table;
register short a;
REFRESH\_MASK;
while((a=\*val++)<0)
{
if (MSB\_MASK) val -= a;
num--;
mask <<= 1;
}
if(part2remain+num <= 0)
{
num -= part2remain+num;
break;
}
for(i=0;i<4;i++)
{
if(!(i & 1))
{
if(!mc)
{
mc = \*m++;
cb = \*m++;
#ifdef CUT\_SFB21
if(cb == 21)
v = 0.0;
else
#endif
{
#ifdef REAL\_IS\_FIXED
gainpow2\_scale\_idx = (int)(gr\_info->pow2gain + (\*scf << shift) - fr->gainpow2);
#endif
v = gr\_info->pow2gain[((\*scf++) + (\*pretab++)) << shift];
}
}
mc--;
}
CHECK\_XRPNT;
if( (a & (0x8>>i)) )
{
max = cb;
if(part2remain+num <= 0)
break;
if(MSB\_MASK) \*xrpnt++ = -REAL\_SCALE\_LAYER3(v, gainpow2\_scale\_idx);
else \*xrpnt++ = REAL\_SCALE\_LAYER3(v, gainpow2\_scale\_idx);
num--;
mask <<= 1;
}
else \*xrpnt++ = DOUBLE\_TO\_REAL(0.0);
}
}
gr\_info->maxbandl = max+1;
gr\_info->maxb = fr->longLimit[sfreq][gr\_info->maxbandl];
}
part2remain += num;
backbits(fr, num);
num = 0;
}
else
{
part2remain = 0;
/\* Not entirely sure what good values are, must be > 0. \*/
gr\_info->maxband[0] =
gr\_info->maxband[1] =
gr\_info->maxband[2] =
gr\_info->maxbandl = 1; /\* sfb=maxband[lwin]\*3 + lwin - mixed\_block\_flag must be >= 0 \*/
gr\_info->maxb = 1;
}
while(xrpnt < xrpntlimit)
\*xrpnt++ = DOUBLE\_TO\_REAL(0.0);
while( part2remain > 16 )
{
skipbits(fr, 16); /\* Dismiss stuffing Bits \*/
part2remain -= 16;
}
if(part2remain > 0) skipbits(fr, part2remain);
else if(part2remain < 0)
{
if(VERBOSE2)
error1("Can't rewind stream by %d bits!",-part2remain);
return 1; /\* -> error \*/
}
return 0;
}
/\* calculate real channel values for Joint-I-Stereo-mode \*/
static void III\_i\_stereo(real xr\_buf[2][SBLIMIT][SSLIMIT],int \*scalefac, struct gr\_info\_s \*gr\_info,int sfreq,int ms\_stereo,int lsf)
{
real (\*xr)[SBLIMIT\*SSLIMIT] = (real (\*)[SBLIMIT\*SSLIMIT] ) xr\_buf;
const struct bandInfoStruct \*bi = &bandInfo[sfreq];
const real \*tab1,\*tab2;
#if 1
int tab;
/\* TODO: optimize as static \*/
const real \*tabs[3][2][2] =
{
{ { tan1\_1,tan2\_1 } , { tan1\_2,tan2\_2 } },
{ { pow1\_1[0],pow2\_1[0] } , { pow1\_2[0],pow2\_2[0] } },
{ { pow1\_1[1],pow2\_1[1] } , { pow1\_2[1],pow2\_2[1] } }
};
tab = lsf + (gr\_info->scalefac\_compress & lsf);
tab1 = tabs[tab][ms\_stereo][0];
tab2 = tabs[tab][ms\_stereo][1];
#else
if(lsf)
{
int p = gr\_info->scalefac\_compress & 0x1;
if(ms\_stereo)
{
tab1 = pow1\_2[p];
tab2 = pow2\_2[p];
}
else
{
tab1 = pow1\_1[p];
tab2 = pow2\_1[p];
}
}
else
{
if(ms\_stereo)
{
tab1 = tan1\_2;
tab2 = tan2\_2;
}
else
{
tab1 = tan1\_1;
tab2 = tan2\_1;
}
}
#endif
if(gr\_info->block\_type == 2)
{
int lwin,do\_l = 0;
if( gr\_info->mixed\_block\_flag ) do\_l = 1;
for(lwin=0;lwin<3;lwin++)
{ /\* process each window \*/
/\* get first band with zero values \*/
int is\_p,sb,idx,sfb = gr\_info->maxband[lwin]; /\* sfb is minimal 3 for mixed mode \*/
if(sfb > 3) do\_l = 0;
for(;sfb<12;sfb++)
{
is\_p = scalefac[sfb\*3+lwin-gr\_info->mixed\_block\_flag]; /\* scale: 0-15 \*/
if(is\_p != 7)
{
real t1,t2;
sb = bi->shortDiff[sfb];
idx = bi->shortIdx[sfb] + lwin;
t1 = tab1[is\_p]; t2 = tab2[is\_p];
for (; sb > 0; sb--,idx+=3)
{
real v = xr[0][idx];
xr[0][idx] = REAL\_MUL\_15(v, t1);
xr[1][idx] = REAL\_MUL\_15(v, t2);
}
}
}
#if 1
/\* in the original: copy 10 to 11 , here: copy 11 to 12
maybe still wrong??? (copy 12 to 13?) \*/
is\_p = scalefac[11\*3+lwin-gr\_info->mixed\_block\_flag]; /\* scale: 0-15 \*/
sb = bi->shortDiff[12];
idx = bi->shortIdx[12] + lwin;
#else
is\_p = scalefac[10\*3+lwin-gr\_info->mixed\_block\_flag]; /\* scale: 0-15 \*/
sb = bi->shortDiff[11];
idx = bi->shortIdx[11] + lwin;
#endif
if(is\_p != 7)
{
real t1,t2;
t1 = tab1[is\_p]; t2 = tab2[is\_p];
for( ; sb > 0; sb--,idx+=3 )
{
real v = xr[0][idx];
xr[0][idx] = REAL\_MUL\_15(v, t1);
xr[1][idx] = REAL\_MUL\_15(v, t2);
}
}
} /\* end for(lwin; .. ; . ) \*/
/\* also check l-part, if ALL bands in the three windows are 'empty' and mode = mixed\_mode \*/
if(do\_l)
{
int sfb = gr\_info->maxbandl;
int idx;
if(sfb > 21) return; /\* similarity fix related to CVE-2006-1655 \*/
idx = bi->longIdx[sfb];
for( ; sfb<8; sfb++ )
{
int sb = bi->longDiff[sfb];
int is\_p = scalefac[sfb]; /\* scale: 0-15 \*/
if(is\_p != 7)
{
real t1,t2;
t1 = tab1[is\_p]; t2 = tab2[is\_p];
for( ; sb > 0; sb--,idx++)
{
real v = xr[0][idx];
xr[0][idx] = REAL\_MUL\_15(v, t1);
xr[1][idx] = REAL\_MUL\_15(v, t2);
}
}
else idx += sb;
}
}
}
else
{ /\* ((gr\_info->block\_type != 2)) \*/
int sfb = gr\_info->maxbandl;
int is\_p,idx;
if(sfb > 21) return; /\* tightened fix for CVE-2006-1655 \*/
idx = bi->longIdx[sfb];
for ( ; sfb<21; sfb++)
{
int sb = bi->longDiff[sfb];
is\_p = scalefac[sfb]; /\* scale: 0-15 \*/
if(is\_p != 7)
{
real t1,t2;
t1 = tab1[is\_p]; t2 = tab2[is\_p];
for( ; sb > 0; sb--,idx++)
{
real v = xr[0][idx];
xr[0][idx] = REAL\_MUL\_15(v, t1);
xr[1][idx] = REAL\_MUL\_15(v, t2);
}
}
else idx += sb;
}
is\_p = scalefac[20];
if(is\_p != 7)
{ /\* copy l-band 20 to l-band 21 \*/
int sb;
real t1 = tab1[is\_p],t2 = tab2[is\_p];
for( sb = bi->longDiff[21]; sb > 0; sb--,idx++ )
{
real v = xr[0][idx];
xr[0][idx] = REAL\_MUL\_15(v, t1);
xr[1][idx] = REAL\_MUL\_15(v, t2);
}
}
}
}
static void III\_antialias(real xr[SBLIMIT][SSLIMIT],struct gr\_info\_s \*gr\_info)
{
int sblim;
if(gr\_info->block\_type == 2)
{
if(!gr\_info->mixed\_block\_flag) return;
sblim = 1;
}
else sblim = gr\_info->maxb-1;
/\* 31 alias-reduction operations between each pair of sub-bands \*/
/\* with 8 butterflies between each pair \*/
{
int sb;
real \*xr1=(real \*) xr[1];
for(sb=sblim; sb; sb--,xr1+=10)
{
int ss;
const real \*cs=aa\_cs,\*ca=aa\_ca;
real \*xr2 = xr1;
for(ss=7;ss>=0;ss--)
{ /\* upper and lower butterfly inputs \*/
register real bu = \*--xr2,bd = \*xr1;
\*xr2 = REAL\_MUL(bu, \*cs) - REAL\_MUL(bd, \*ca);
\*xr1++ = REAL\_MUL(bd, \*cs++) + REAL\_MUL(bu, \*ca++);
}
}
}
}
/\*
This is an optimized DCT from Jeff Tsay's maplay 1.2+ package.
Saved one multiplication by doing the 'twiddle factor' stuff
together with the window mul. (MH)
This uses Byeong Gi Lee's Fast Cosine Transform algorithm, but the
9 point IDCT needs to be reduced further. Unfortunately, I don't
know how to do that, because 9 is not an even number. - Jeff.
Original Message:
9 Point Inverse Discrete Cosine Transform
This piece of code is Copyright 1997 Mikko Tommila and is freely usable
by anybody. The algorithm itself is of course in the public domain.
Again derived heuristically from the 9-point WFTA.
The algorithm is optimized (?) for speed, not for small rounding errors or
good readability.
36 additions, 11 multiplications
Again this is very likely sub-optimal.
The code is optimized to use a minimum number of temporary variables,
so it should compile quite well even on 8-register Intel x86 processors.
This makes the code quite obfuscated and very difficult to understand.
References:
[1] S. Winograd: "On Computing the Discrete Fourier Transform",
Mathematics of Computation, Volume 32, Number 141, January 1978,
Pages 175-199
\*/
static void INT123\_dct36(real \*inbuf,real \*o1,real \*o2,const real \*wintab,real \*tsbuf)
{
real tmp[18];
{
register real \*in = inbuf;
in[17]+=in[16]; in[16]+=in[15]; in[15]+=in[14];
in[14]+=in[13]; in[13]+=in[12]; in[12]+=in[11];
in[11]+=in[10]; in[10]+=in[9]; in[9] +=in[8];
in[8] +=in[7]; in[7] +=in[6]; in[6] +=in[5];
in[5] +=in[4]; in[4] +=in[3]; in[3] +=in[2];
in[2] +=in[1]; in[1] +=in[0];
in[17]+=in[15]; in[15]+=in[13]; in[13]+=in[11]; in[11]+=in[9];
in[9] +=in[7]; in[7] +=in[5]; in[5] +=in[3]; in[3] +=in[1];
#if 1
{
real t3;
{
real t0, t1, t2;
t0 = REAL\_MUL(COS6\_2, (in[8] + in[16] - in[4]));
t1 = REAL\_MUL(COS6\_2, in[12]);
t3 = in[0];
t2 = t3 - t1 - t1;
tmp[1] = tmp[7] = t2 - t0;
tmp[4] = t2 + t0 + t0;
t3 += t1;
t2 = REAL\_MUL(COS6\_1, (in[10] + in[14] - in[2]));
tmp[1] -= t2;
tmp[7] += t2;
}
{
real t0, t1, t2;
t0 = REAL\_MUL(cos9[0], (in[4] + in[8] ));
t1 = REAL\_MUL(cos9[1], (in[8] - in[16]));
t2 = REAL\_MUL(cos9[2], (in[4] + in[16]));
tmp[2] = tmp[6] = t3 - t0 - t2;
tmp[0] = tmp[8] = t3 + t0 + t1;
tmp[3] = tmp[5] = t3 - t1 + t2;
}
}
{
real t1, t2, t3;
t1 = REAL\_MUL(cos18[0], (in[2] + in[10]));
t2 = REAL\_MUL(cos18[1], (in[10] - in[14]));
t3 = REAL\_MUL(COS6\_1, in[6]);
{
real t0 = t1 + t2 + t3;
tmp[0] += t0;
tmp[8] -= t0;
}
t2 -= t3;
t1 -= t3;
t3 = REAL\_MUL(cos18[2], (in[2] + in[14]));
t1 += t3;
tmp[3] += t1;
tmp[5] -= t1;
t2 -= t3;
tmp[2] += t2;
tmp[6] -= t2;
}
#else
{
real t0, t1, t2, t3, t4, t5, t6, t7;
t1 = REAL\_MUL(COS6\_2, in[12]);
t2 = REAL\_MUL(COS6\_2, (in[8] + in[16] - in[4]));
t3 = in[0] + t1;
t4 = in[0] - t1 - t1;
t5 = t4 - t2;
tmp[4] = t4 + t2 + t2;
t0 = REAL\_MUL(cos9[0], (in[4] + in[8]));
t1 = REAL\_MUL(cos9[1], (in[8] - in[16]));
t2 = REAL\_MUL(cos9[2], (in[4] + in[16]));
t6 = t3 - t0 - t2;
t0 += t3 + t1;
t3 += t2 - t1;
t2 = REAL\_MUL(cos18[0], (in[2] + in[10]));
t4 = REAL\_MUL(cos18[1], (in[10] - in[14]));
t7 = REAL\_MUL(COS6\_1, in[6]);
t1 = t2 + t4 + t7;
tmp[0] = t0 + t1;
tmp[8] = t0 - t1;
t1 = REAL\_MUL(cos18[2], (in[2] + in[14]));
t2 += t1 - t7;
tmp[3] = t3 + t2;
t0 = REAL\_MUL(COS6\_1, (in[10] + in[14] - in[2]));
tmp[5] = t3 - t2;
t4 -= t1 + t7;
tmp[1] = t5 - t0;
tmp[7] = t5 + t0;
tmp[2] = t6 + t4;
tmp[6] = t6 - t4;
}
#endif
{
real t0, t1, t2, t3, t4, t5, t6, t7;
t1 = REAL\_MUL(COS6\_2, in[13]);
t2 = REAL\_MUL(COS6\_2, (in[9] + in[17] - in[5]));
t3 = in[1] + t1;
t4 = in[1] - t1 - t1;
t5 = t4 - t2;
t0 = REAL\_MUL(cos9[0], (in[5] + in[9]));
t1 = REAL\_MUL(cos9[1], (in[9] - in[17]));
tmp[13] = REAL\_MUL((t4 + t2 + t2), INT123\_tfcos36[17-13]);
t2 = REAL\_MUL(cos9[2], (in[5] + in[17]));
t6 = t3 - t0 - t2;
t0 += t3 + t1;
t3 += t2 - t1;
t2 = REAL\_MUL(cos18[0], (in[3] + in[11]));
t4 = REAL\_MUL(cos18[1], (in[11] - in[15]));
t7 = REAL\_MUL(COS6\_1, in[7]);
t1 = t2 + t4 + t7;
tmp[17] = REAL\_MUL((t0 + t1), INT123\_tfcos36[17-17]);
tmp[9] = REAL\_MUL((t0 - t1), INT123\_tfcos36[17-9]);
t1 = REAL\_MUL(cos18[2], (in[3] + in[15]));
t2 += t1 - t7;
tmp[14] = REAL\_MUL((t3 + t2), INT123\_tfcos36[17-14]);
t0 = REAL\_MUL(COS6\_1, (in[11] + in[15] - in[3]));
tmp[12] = REAL\_MUL((t3 - t2), INT123\_tfcos36[17-12]);
t4 -= t1 + t7;
tmp[16] = REAL\_MUL((t5 - t0), INT123\_tfcos36[17-16]);
tmp[10] = REAL\_MUL((t5 + t0), INT123\_tfcos36[17-10]);
tmp[15] = REAL\_MUL((t6 + t4), INT123\_tfcos36[17-15]);
tmp[11] = REAL\_MUL((t6 - t4), INT123\_tfcos36[17-11]);
}
#define MACRO(v) { \
real tmpval; \
tmpval = tmp[(v)] + tmp[17-(v)]; \
out2[9+(v)] = REAL\_MUL(tmpval, w[27+(v)]); \
out2[8-(v)] = REAL\_MUL(tmpval, w[26-(v)]); \
tmpval = tmp[(v)] - tmp[17-(v)]; \
ts[SBLIMIT\*(8-(v))] = out1[8-(v)] + REAL\_MUL(tmpval, w[8-(v)]); \
ts[SBLIMIT\*(9+(v))] = out1[9+(v)] + REAL\_MUL(tmpval, w[9+(v)]); }
{
register real \*out2 = o2;
register const real \*w = wintab;
register real \*out1 = o1;
register real \*ts = tsbuf;
MACRO(0);
MACRO(1);
MACRO(2);
MACRO(3);
MACRO(4);
MACRO(5);
MACRO(6);
MACRO(7);
MACRO(8);
}
}
}
// Wrap the assembly routine calls into C functions that serve as jump target to satisfy
// indirect branch protection if the toolchain enables that. Otherwise, we'd need to anticipate
// that in the assembly (and ensure assemblers support endbr64 and friends).
// Loss of efficiency:
// In the case of one static optimization choice, we do not have that problem.
#ifdef OPT\_THE\_DCT36
#define DCT36\_WRAP(asmfunc) \
static void asmfunc ## \_wrap(real \*inbuf,real \*o1,real \*o2,const real \*wintab,real \*tsbuf) \
{ \
asmfunc(inbuf, o1, o2, wintab, tsbuf); \
}
#ifdef OPT\_SSE
DCT36\_WRAP(INT123\_dct36\_sse)
#endif
#ifdef OPT\_3DNOWEXT\_VINTAGE
DCT36\_WRAP(INT123\_dct36\_3dnowext)
#endif
#ifdef OPT\_3DNOW\_VINTAGE
DCT36\_WRAP(INT123\_dct36\_3dnow)
#endif
#ifdef OPT\_X86\_64
DCT36\_WRAP(INT123\_dct36\_x86\_64)
#endif
#ifdef OPT\_AVX
DCT36\_WRAP(INT123\_dct36\_avx)
#endif
#ifdef OPT\_NEON
DCT36\_WRAP(INT123\_dct36\_neon)
#endif
#ifdef OPT\_NEON64
DCT36\_WRAP(INT123\_dct36\_neon64)
#endif
int INT123\_dct36\_match(mpg123\_handle \*fr, enum optdec t)
{
#ifdef OPT\_SSE
if(t == sse && fr->cpu\_opts.the\_dct36 == INT123\_dct36\_sse\_wrap)
return 1;
#endif
#ifdef OPT\_3DNOWEXT\_VINTAGE
if(t == dreidnowext\_vintage && fr->cpu\_opts.the\_dct36 == INT123\_dct36\_3dnowext\_wrap)
return 1;
#endif
#ifdef OPT\_3DNOW\_VINTAGE
if(t == dreidnow\_vintage && fr->cpu\_opts.the\_dct36 == INT123\_dct36\_3dnow\_wrap)
return 1;
#endif
return 0;
}
void INT123\_dct36\_choose(mpg123\_handle \*fr)
{
switch(fr->cpu\_opts.type)
{
#ifdef OPT\_SSE
case sse:
fr->cpu\_opts.the\_dct36 = INT123\_dct36\_sse\_wrap;
break;
#endif
#ifdef OPT\_3DNOWEXT\_VINTAGE
case dreidnowext\_vintage:
fr->cpu\_opts.the\_dct36 = INT123\_dct36\_3dnowext\_wrap;
break;
#endif
#ifdef OPT\_3DNOW\_VINTAGE
case dreidnow\_vintage:
fr->cpu\_opts.the\_dct36 = INT123\_dct36\_3dnow\_wrap;
break;
#endif
#ifdef OPT\_AVX
case avx:
fr->cpu\_opts.the\_dct36 = INT123\_dct36\_avx\_wrap;
break;
#endif
#ifdef OPT\_X86\_64
case x86\_64:
fr->cpu\_opts.the\_dct36 = INT123\_dct36\_x86\_64\_wrap;
break;
#endif
#ifdef OPT\_NEON
case neon:
fr->cpu\_opts.the\_dct36 = INT123\_dct36\_neon\_wrap;
break;
#endif
#ifdef OPT\_NEON64
case neon:
fr->cpu\_opts.the\_dct36 = INT123\_dct36\_neon64\_wrap;
break;
#endif
default:
fr->cpu\_opts.the\_dct36 = INT123\_dct36;
}
}
#endif
/\* new DCT12 \*/
static void dct12(real \*in,real \*rawout1,real \*rawout2,register const real \*wi,register real \*ts)
{
#define DCT12\_PART1 \
in5 = in[5\*3]; \
in5 += (in4 = in[4\*3]); \
in4 += (in3 = in[3\*3]); \
in3 += (in2 = in[2\*3]); \
in2 += (in1 = in[1\*3]); \
in1 += (in0 = in[0\*3]); \
\
in5 += in3; in3 += in1; \
\
in2 = REAL\_MUL(in2, COS6\_1); \
in3 = REAL\_MUL(in3, COS6\_1);
#define DCT12\_PART2 \
in0 += REAL\_MUL(in4, COS6\_2); \
\
in4 = in0 + in2; \
in0 -= in2; \
\
in1 += REAL\_MUL(in5, COS6\_2); \
\
in5 = REAL\_MUL((in1 + in3), tfcos12[0]); \
in1 = REAL\_MUL((in1 - in3), tfcos12[2]); \
\
in3 = in4 + in5; \
in4 -= in5; \
\
in2 = in0 + in1; \
in0 -= in1;
{
real in0,in1,in2,in3,in4,in5;
register real \*out1 = rawout1;
ts[SBLIMIT\*0] = out1[0]; ts[SBLIMIT\*1] = out1[1]; ts[SBLIMIT\*2] = out1[2];
ts[SBLIMIT\*3] = out1[3]; ts[SBLIMIT\*4] = out1[4]; ts[SBLIMIT\*5] = out1[5];
DCT12\_PART1
{
real tmp0,tmp1 = (in0 - in4);
{
real tmp2 = REAL\_MUL((in1 - in5), tfcos12[1]);
tmp0 = tmp1 + tmp2;
tmp1 -= tmp2;
}
ts[(17-1)\*SBLIMIT] = out1[17-1] + REAL\_MUL(tmp0, wi[11-1]);
ts[(12+1)\*SBLIMIT] = out1[12+1] + REAL\_MUL(tmp0, wi[6+1]);
ts[(6 +1)\*SBLIMIT] = out1[6 +1] + REAL\_MUL(tmp1, wi[1]);
ts[(11-1)\*SBLIMIT] = out1[11-1] + REAL\_MUL(tmp1, wi[5-1]);
}
DCT12\_PART2
ts[(17-0)\*SBLIMIT] = out1[17-0] + REAL\_MUL(in2, wi[11-0]);
ts[(12+0)\*SBLIMIT] = out1[12+0] + REAL\_MUL(in2, wi[6+0]);
ts[(12+2)\*SBLIMIT] = out1[12+2] + REAL\_MUL(in3, wi[6+2]);
ts[(17-2)\*SBLIMIT] = out1[17-2] + REAL\_MUL(in3, wi[11-2]);
ts[(6 +0)\*SBLIMIT] = out1[6+0] + REAL\_MUL(in0, wi[0]);
ts[(11-0)\*SBLIMIT] = out1[11-0] + REAL\_MUL(in0, wi[5-0]);
ts[(6 +2)\*SBLIMIT] = out1[6+2] + REAL\_MUL(in4, wi[2]);
ts[(11-2)\*SBLIMIT] = out1[11-2] + REAL\_MUL(in4, wi[5-2]);
}
in++;
{
real in0,in1,in2,in3,in4,in5;
register real \*out2 = rawout2;
DCT12\_PART1
{
real tmp0,tmp1 = (in0 - in4);
{
real tmp2 = REAL\_MUL((in1 - in5), tfcos12[1]);
tmp0 = tmp1 + tmp2;
tmp1 -= tmp2;
}
out2[5-1] = REAL\_MUL(tmp0, wi[11-1]);
out2[0+1] = REAL\_MUL(tmp0, wi[6+1]);
ts[(12+1)\*SBLIMIT] += REAL\_MUL(tmp1, wi[1]);
ts[(17-1)\*SBLIMIT] += REAL\_MUL(tmp1, wi[5-1]);
}
DCT12\_PART2
out2[5-0] = REAL\_MUL(in2, wi[11-0]);
out2[0+0] = REAL\_MUL(in2, wi[6+0]);
out2[0+2] = REAL\_MUL(in3, wi[6+2]);
out2[5-2] = REAL\_MUL(in3, wi[11-2]);
ts[(12+0)\*SBLIMIT] += REAL\_MUL(in0, wi[0]);
ts[(17-0)\*SBLIMIT] += REAL\_MUL(in0, wi[5-0]);
ts[(12+2)\*SBLIMIT] += REAL\_MUL(in4, wi[2]);
ts[(17-2)\*SBLIMIT] += REAL\_MUL(in4, wi[5-2]);
}
in++;
{
real in0,in1,in2,in3,in4,in5;
register real \*out2 = rawout2;
out2[12]=out2[13]=out2[14]=out2[15]=out2[16]=out2[17]=0.0;
DCT12\_PART1
{
real tmp0,tmp1 = (in0 - in4);
{
real tmp2 = REAL\_MUL((in1 - in5), tfcos12[1]);
tmp0 = tmp1 + tmp2;
tmp1 -= tmp2;
}
out2[11-1] = REAL\_MUL(tmp0, wi[11-1]);
out2[6 +1] = REAL\_MUL(tmp0, wi[6+1]);
out2[0+1] += REAL\_MUL(tmp1, wi[1]);
out2[5-1] += REAL\_MUL(tmp1, wi[5-1]);
}
DCT12\_PART2
out2[11-0] = REAL\_MUL(in2, wi[11-0]);
out2[6 +0] = REAL\_MUL(in2, wi[6+0]);
out2[6 +2] = REAL\_MUL(in3, wi[6+2]);
out2[11-2] = REAL\_MUL(in3, wi[11-2]);
out2[0+0] += REAL\_MUL(in0, wi[0]);
out2[5-0] += REAL\_MUL(in0, wi[5-0]);
out2[0+2] += REAL\_MUL(in4, wi[2]);
out2[5-2] += REAL\_MUL(in4, wi[5-2]);
}
}
static void III\_hybrid(real fsIn[SBLIMIT][SSLIMIT], real tsOut[SSLIMIT][SBLIMIT], int ch,struct gr\_info\_s \*gr\_info, mpg123\_handle \*fr)
{
real (\*block)[2][SBLIMIT\*SSLIMIT] = fr->hybrid\_block;
int \*blc = fr->hybrid\_blc;
real \*tspnt = (real \*) tsOut;
real \*rawout1,\*rawout2;
int bt = 0;
size\_t sb = 0;
{
int b = blc[ch];
rawout1=block[b][ch];
b=-b+1;
rawout2=block[b][ch];
blc[ch] = b;
}
if(gr\_info->mixed\_block\_flag)
{
sb = 2;
opt\_dct36(fr)(fsIn[0],rawout1,rawout2,win[0],tspnt);
opt\_dct36(fr)(fsIn[1],rawout1+18,rawout2+18,win1[0],tspnt+1);
rawout1 += 36; rawout2 += 36; tspnt += 2;
}
bt = gr\_info->block\_type;
if(bt == 2)
{
for(; sbmaxb; sb+=2,tspnt+=2,rawout1+=36,rawout2+=36)
{
dct12(fsIn[sb] ,rawout1 ,rawout2 ,win[2] ,tspnt);
dct12(fsIn[sb+1],rawout1+18,rawout2+18,win1[2],tspnt+1);
}
}
else
{
for(; sbmaxb; sb+=2,tspnt+=2,rawout1+=36,rawout2+=36)
{
opt\_dct36(fr)(fsIn[sb],rawout1,rawout2,win[bt],tspnt);
opt\_dct36(fr)(fsIn[sb+1],rawout1+18,rawout2+18,win1[bt],tspnt+1);
}
}
for(;sbch[ch].gr[gr]);
fr->pinfo->big\_values[gr][ch] = gr\_infos->big\_values;
fr->pinfo->scalefac\_scale[gr][ch] = gr\_infos->scalefac\_scale;
fr->pinfo->mixed[gr][ch] = gr\_infos->mixed\_block\_flag;
fr->pinfo->blocktype[gr][ch] = gr\_infos->block\_type;
fr->pinfo->mainbits[gr][ch] = gr\_infos->part2\_3\_length;
fr->pinfo->preflag[gr][ch] = gr\_infos->preflag;
if(gr == 1)
fr->pinfo->scfsi[ch] = gr\_infos->scfsi;
}
for(ch = 0; ch < stereo1; ++ch)
{
struct gr\_info\_s \*gr\_infos = &(si->ch[ch].gr[gr]);
ifqstep = (fr->pinfo->scalefac\_scale[gr][ch] == 0) ? .5 : 1.0;
if(2 == gr\_infos->block\_type)
{
for(i = 0; i < 3; ++i)
{
for(sb = 0; sb < 12; ++sb)
{
int j = 3 \* sb + i;
/\*
is\_p = scalefac[sfb\*3+lwin-gr\_infos->mixed\_block\_flag];
\*/
/\* scalefac was copied into pinfo->sfb\_s[] before \*/
fr->pinfo->sfb\_s[gr][ch][j] = -ifqstep \*
fr->pinfo->sfb\_s[gr][ch][j - gr\_infos->mixed\_block\_flag];
fr->pinfo->sfb\_s[gr][ch][j] -= 2 \*
(fr->pinfo->sub\_gain[gr][ch][i]);
}
fr->pinfo->sfb\_s[gr][ch][3 \* sb + i] =
-2 \* (fr->pinfo->sub\_gain[gr][ch][i]);
}
} else
{
for(sb = 0; sb < 21; ++sb)
{
/\* scalefac was copied into pinfo->sfb[] before \*/
fr->pinfo->sfb[gr][ch][sb] = fr->pinfo->sfb\_s[gr][ch][sb];
if (gr\_infos->preflag)
fr->pinfo->sfb[gr][ch][sb] += pretab\_choice[1][sb];
fr->pinfo->sfb[gr][ch][sb] \*= -ifqstep;
}
fr->pinfo->sfb[gr][ch][21] = 0;
}
}
for(ch = 0; ch < stereo1; ++ch)
{
int j = 0;
for(sb = 0; sb < SBLIMIT; ++sb)
for (ss = 0; ss < SSLIMIT; ++ss, ++j)
fr->pinfo->xr[gr][ch][j] = fr->layer3.hybrid\_in[ch][sb][ss];
}
}
#endif
/\* And at the end... the main layer3 handler \*/
int INT123\_do\_layer3(mpg123\_handle \*fr)
{
int gr, ch, ss,clip=0;
int scalefacs[2][39]; /\* max 39 for short[13][3] mode, mixed: 38, long: 22 \*/
struct III\_sideinfo sideinfo;
int stereo = fr->stereo;
int single = fr->single;
int ms\_stereo,i\_stereo;
int sfreq = fr->hdr.sampling\_frequency;
int stereo1,granules;
if(stereo == 1)
{ /\* stream is mono \*/
stereo1 = 1;
single = SINGLE\_LEFT;
}
else if(single != SINGLE\_STEREO) /\* stream is stereo, but force to mono \*/
stereo1 = 1;
else
stereo1 = 2;
if(fr->hdr.mode == MPG\_MD\_JOINT\_STEREO)
{
ms\_stereo = (fr->hdr.mode\_ext & 0x2)>>1;
i\_stereo = fr->hdr.mode\_ext & 0x1;
}
else ms\_stereo = i\_stereo = 0;
granules = fr->hdr.lsf ? 1 : 2;
/\* quick hack to keep the music playing \*/
/\* after having seen this nasty test file... \*/
if(III\_get\_side\_info(fr, &sideinfo,stereo,ms\_stereo,sfreq,single))
{
if(NOQUIET) error("bad frame - unable to get valid sideinfo");
return clip;
}
INT123\_set\_pointer(fr, 1, sideinfo.main\_data\_begin);
#ifndef NO\_MOREINFO
if(fr->pinfo)
{
fr->pinfo->maindata = sideinfo.main\_data\_begin;
fr->pinfo->padding = fr->hdr.padding;
}
#endif
for(gr=0;grlayer3.hybrid\_in;
/\* hybridOut[2][SSLIMIT][SBLIMIT] \*/
real (\*hybridOut)[SSLIMIT][SBLIMIT] = fr->layer3.hybrid\_out;
{
struct gr\_info\_s \*gr\_info = &(sideinfo.ch[0].gr[gr]);
long part2bits;
if(gr\_info->part2\_3\_length > fr->bits\_avail)
{
if(NOQUIET)
error2(
"part2\_3\_length (%u) too large for available bit count (%li)"
, gr\_info->part2\_3\_length, fr->bits\_avail );
return clip;
}
if(fr->hdr.lsf)
part2bits = III\_get\_scale\_factors\_2(fr, scalefacs[0],gr\_info,0);
else
part2bits = III\_get\_scale\_factors\_1(fr, scalefacs[0],gr\_info,0,gr);
if(part2bits < 0)
{
if(VERBOSE2)
error("not enough bits for scale factors");
return clip;
}
#ifndef NO\_MOREINFO
if(fr->pinfo)
{
int i;
fr->pinfo->sfbits[gr][0] = part2bits;
for(i=0; i<39; ++i)
fr->pinfo->sfb\_s[gr][0][i] = scalefacs[0][i];
}
#endif
if(III\_dequantize\_sample(fr, hybridIn[0], scalefacs[0],gr\_info,sfreq,part2bits))
{
if(NOQUIET)
error("dequantization failed!");
return clip;
}
if(fr->bits\_avail < 0)
{
if(NOQUIET)
error("bit deficit after dequant");
return clip;
}
}
if(stereo == 2)
{
struct gr\_info\_s \*gr\_info = &(sideinfo.ch[1].gr[gr]);
long part2bits;
if(fr->hdr.lsf)
part2bits = III\_get\_scale\_factors\_2(fr, scalefacs[1],gr\_info,i\_stereo);
else
part2bits = III\_get\_scale\_factors\_1(fr, scalefacs[1],gr\_info,1,gr);
if(part2bits < 0)
{
if(VERBOSE2)
error("not enough bits for scale factors");
return clip;
}
#ifndef NO\_MOREINFO
if(fr->pinfo)
{
int i;
fr->pinfo->sfbits[gr][1] = part2bits;
for(i=0; i<39; ++i)
fr->pinfo->sfb\_s[gr][1][i] = scalefacs[1][i];
}
#endif
if(III\_dequantize\_sample(fr, hybridIn[1],scalefacs[1],gr\_info,sfreq,part2bits))
{
if(NOQUIET)
error("dequantization failed!");
return clip;
}
if(fr->bits\_avail < 0)
{
if(NOQUIET)
error("bit deficit after dequant");
return clip;
}
if(ms\_stereo)
{
int i;
unsigned int maxb = sideinfo.ch[0].gr[gr].maxb;
if(sideinfo.ch[1].gr[gr].maxb > maxb) maxb = sideinfo.ch[1].gr[gr].maxb;
for(i=0;ihdr.lsf);
if(ms\_stereo || i\_stereo || (single == SINGLE\_MIX) )
{
if(gr\_info->maxb > sideinfo.ch[0].gr[gr].maxb)
sideinfo.ch[0].gr[gr].maxb = gr\_info->maxb;
else
gr\_info->maxb = sideinfo.ch[0].gr[gr].maxb;
}
switch(single)
{
case SINGLE\_MIX:
{
register int i;
register real \*in0 = (real \*) hybridIn[0],\*in1 = (real \*) hybridIn[1];
for(i=0;imaxb;i++,in0++)
\*in0 = (\*in0 + \*in1++); /\* \*0.5 done by pow-scale \*/
}
break;
case SINGLE\_RIGHT:
{
register int i;
register real \*in0 = (real \*) hybridIn[0],\*in1 = (real \*) hybridIn[1];
for(i=0;imaxb;i++)
\*in0++ = \*in1++;
}
break;
}
}
#ifndef NO\_MOREINFO
if(fr->pinfo)
fill\_pinfo\_side(fr, &sideinfo, gr, stereo1);
#endif
for(ch=0;chaf.encoding != MPG123\_ENC\_SIGNED\_16 || fr->down\_sample != 0)
{
#endif
for(ss=0;sssynth\_mono)(hybridOut[0][ss], fr);
else
clip += (fr->synth\_stereo)(hybridOut[0][ss], hybridOut[1][ss], fr);
}
#ifdef OPT\_I486
} else
{
/\* Only stereo, 16 bits benefit from the 486 optimization. \*/
ss=0;
while(ss < SSLIMIT)
{
int n;
n=(fr->buffer.size - fr->buffer.fill) / (2\*2\*32);
if(n > (SSLIMIT-ss)) n=SSLIMIT-ss;
/\* Clip counting makes no sense with this function. \*/
INT123\_absynth\_1to1\_i486(hybridOut[0][ss], 0, fr, n);
INT123\_absynth\_1to1\_i486(hybridOut[1][ss], 1, fr, n);
ss+=n;
fr->buffer.fill+=(2\*2\*32)\*n;
}
}
#endif
}
return clip;
}


=== Content from openwall.com_b96481de_20250125_224213.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Hash Suite - Windows password security audit tool. GUI, reports in PDF.](https://hashsuite.openwall.net) | | --- | |
| --- | --- |

[[<prev]](3) [[next>]](5) [[<thread-prev]](3) [[thread-next>]](5) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <20170710114253.44fc7ac0@cortex.rrz.uni-hamburg.de>
Date: Mon, 10 Jul 2017 11:42:53 +0200
From: "Dr. Thomas Orgis" <thomas.orgis@...-hamburg.de>
To: oss-security@...ts.openwall.com
Subject: Re: mpg123: global buffer overflow in III_i_stereo
 (layer3.c)

Am Mon, 10 Jul 2017 09:13:07 +0000
schrieb "Agostino Sarubbo" <ago@...too.org>:

> Description:
> mpg123 is a fast console MPEG Audio Player and decoder library.
>
> The complete ASan output of the issue:
>
> # mpg123-mpg123 -t $FILE
> ==10588==ERROR: AddressSanitizer: global-buffer-overflow on address 0x7f01025c5cbc at pc 0x7f010229bfe3 bp 0x7ffc988ac5b0 sp 0x7ffc988ac5a8
> READ of size 4 at 0x7f01025c5cbc thread T0

I would like to point out that this only crashes with the
AddressSanitizer. The normal effect is some bad values from adjacent
data being used in numerical computation. No segfault or the like, no
jumps depending on the values.

> Affected version:
> 1.25.0

1.25.1, too

> Fixed version:
> N/A

To be released, I hoped to also fix another lurking issue that in practice
is hidden by padding of a buffer for alignment. If I don't manage that
today, I guess I have to push out 1.25.2 as-is.

> Commit fix:
> N/A

It is fixed with subversion revision 4275.

	<https://scm.orgis.org/view/mpg123/trunk/src/libmpg123/layer3.c?view=patch&r1=4275&r2=4274&pathrev=4275>

Can this info be updated? Agostino: You might want to jump to 4278,
too, as that fixes that other left shift of -1 complaint you had.

> CVE:
> CVE-2017-11126

Is this really worth a CVE, though? So far I was only able to see a
crash triggered by the AddressSanitizer. Never from a normal build. So
every build of mpg123 in the wild, except for extremely hardened
distros that build everything with GCC's sanitizers enabled for daily
use, is not affected. Are people running binaries in production with
the sanitizers on?

Thing about this specific kind of input: This is a fuzzed stream that
triggers a code path for MP3 with intensity stereo. These are really
hard to find and I was not able to produce a valid file (using the FhG
mp3enc demo, the only encoder that does i-stereo to my knowledge) that
also triggers this specific array access. So I cannot even say if this
bug causes bad output from valid input as I never observed the valid
input! For this fuzzed input data, the produced output data (sound)
will not be nice, but this is the case with and without the fix.

It's hard to see a security issue here, although of course there
technically is a buffer overflow. That is why I wanted to take some
time to possibly dig out a file that tells me that mpg123 is now
producing correct output. So far, the overflow is averted, but if we do
something sensible now cannot be tested in lack of valid test data that
uses 5 bits for scale factors with intensity stereo.

Alrighty then,

Thomas

PS: I will do some fuzzing myself to weed out any lurking issues of this
type. Found a fuzzer in my mailbox, from over 10 years ago, when this
was a thing before;-)

--
Dr. Thomas Orgis
Universität Hamburg
RRZ / Basis-Infrastruktur / HPC
Schlüterstr. 70
20146 Hamburg
Tel.: 040/42838 8826
Fax: 040/428 38 6270

Download attachment "[smime.p7s](4/1)" of type "application/pkcs7-signature" (4967 bytes)

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from github.com_fd3a30b6_20250126_123220.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fasarubbo%2Fpoc%2Fblob%2Fmaster%2F00300-mpg123-globaloverflow-III_i_stereo)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fasarubbo%2Fpoc%2Fblob%2Fmaster%2F00300-mpg123-globaloverflow-III_i_stereo)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=asarubbo%2Fpoc)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[asarubbo](/asarubbo)
/
**[poc](/asarubbo/poc)**
Public

* [Notifications](/login?return_to=%2Fasarubbo%2Fpoc) You must be signed in to change notification settings
* [Fork
  20](/login?return_to=%2Fasarubbo%2Fpoc)
* [Star
   79](/login?return_to=%2Fasarubbo%2Fpoc)

* [Code](/asarubbo/poc)
* [Issues
  0](/asarubbo/poc/issues)
* [Pull requests
  0](/asarubbo/poc/pulls)
* [Actions](/asarubbo/poc/actions)
* [Projects
  0](/asarubbo/poc/projects)
* [Security](/asarubbo/poc/security)
* [Insights](/asarubbo/poc/pulse)

Additional navigation options

* [Code](/asarubbo/poc)
* [Issues](/asarubbo/poc/issues)
* [Pull requests](/asarubbo/poc/pulls)
* [Actions](/asarubbo/poc/actions)
* [Projects](/asarubbo/poc/projects)
* [Security](/asarubbo/poc/security)
* [Insights](/asarubbo/poc/pulse)

## Files

 master
## Breadcrumbs

1. [poc](/asarubbo/poc/tree/master)
/
# 00300-mpg123-globaloverflow-III\_i\_stereo

Copy path
## Latest commit

## History

[History](/asarubbo/poc/commits/master/00300-mpg123-globaloverflow-III_i_stereo)4.88 KB master
## Breadcrumbs

1. [poc](/asarubbo/poc/tree/master)
/
# 00300-mpg123-globaloverflow-III\_i\_stereo

Top
## File metadata and controls

* Code
* Blame

4.88 KB[Raw](https://github.com/asarubbo/poc/raw/refs/heads/master/00300-mpg123-globaloverflow-III_i_stereo)[View raw](https://github.com/asarubbo/poc/raw/refs/heads/master/00300-mpg123-globaloverflow-III_i_stereo)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from blogs.gentoo.org_a28c994e_20250126_123256.html ===


[agostino's blog](https://blogs.gentoo.org/ago/ "agostino's blog")

my fuzzer always find something more than your…
![](https://blogs.gentoo.org/ago/files/2015/06/cropped-modificato2.png)

[Skip to content](#content "Skip to content")

* [About me](https://blogs.gentoo.org/ago/agostino_sarubbo/)
* [Contact](https://blogs.gentoo.org/ago/contact/)
* [Advisories](https://blogs.gentoo.org/ago/advisories/)

[← mpg123: global buffer overflow in III\_i\_stereo (layer3.c)](https://blogs.gentoo.org/ago/2017/07/03/mpg123-global-buffer-overflow-in-iii_i_stereo-layer3-c/)
[graphicsmagick: use-after-free in ReadWMFImage (wmf.c) →](https://blogs.gentoo.org/ago/2017/08/05/graphicsmagick-use-after-free-in-readwmfimage-wmf-c/)

# graphicsmagick: use-after-free in CloseBlob (blob.c)

Posted on [July 12, 2017](https://blogs.gentoo.org/ago/2017/07/12/graphicsmagick-use-after-free-in-closeblob-blob-c/ "10:27 pm") by [ago](https://blogs.gentoo.org/ago/author/ago/ "View all posts by ago")

**Description**:

[graphicsmagick](http://www.graphicsmagick.org/) is a collection of tools and libraries for many image formats.

The complete ASan output of the issue:

```
# gm identify $FILE
==20404==ERROR: AddressSanitizer: heap-use-after-free on address 0x6230000053c0 at pc 0x7fc01a253357 bp 0x7fffcd2d2630 sp 0x7fffcd2d2628
READ of size 8 at 0x6230000053c0 thread T0
    #0 0x7fc01a253356 in CloseBlob /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/blob.c:859:3
    #1 0x7fc013fbed77 in ReadMNGImage /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/coders/png.c:5144:11
    #2 0x7fc01a50ee88 in ReadImage /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/constitute.c:1607:13
    #3 0x7fc01a3a1f18 in ConvertImageCommand /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/command.c:4348:22
    #4 0x7fc01a3de0c5 in MagickCommand /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/command.c:8869:17
    #5 0x7fc01a48985b in GMCommandSingle /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/command.c:17396:10
    #6 0x7fc01a486991 in GMCommand /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/command.c:17449:16
    #7 0x7fc018cf1680 in __libc_start_main /var/tmp/portage/sys-libs/glibc-2.23-r4/work/glibc-2.23/csu/../csu/libc-start.c:289
    #8 0x419cd8 in _init (/usr/bin/gm+0x419cd8)

0x6230000053c0 is located 6848 bytes inside of 6856-byte region [0x623000003900,0x6230000053c8)
freed by thread T0 here:
    #0 0x4cf4d0 in __interceptor_cfree /var/tmp/portage/sys-libs/compiler-rt-sanitizers-4.0.1/work/compiler-rt-4.0.1.src/lib/asan/asan_malloc_linux.cc:55
    #1 0x7fc01a8f13d2 in MagickFree /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/memory.c:509:5
    #2 0x7fc01a7dc750 in DestroyImage /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/image.c:1277:3
    #3 0x7fc01a8a7cda in DestroyImageList /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/list.c:239:5
    #4 0x7fc013fbed6f in ReadMNGImage /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/coders/png.c:5143:11
    #5 0x7fc01a50ee88 in ReadImage /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/constitute.c:1607:13
    #6 0x7fc01a3a1f18 in ConvertImageCommand /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/command.c:4348:22
    #7 0x7fc01a3de0c5 in MagickCommand /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/command.c:8869:17
    #8 0x7fc01a48985b in GMCommandSingle /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/command.c:17396:10
    #9 0x7fc01a486991 in GMCommand /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/command.c:17449:16
    #10 0x7fc018cf1680 in __libc_start_main /var/tmp/portage/sys-libs/glibc-2.23-r4/work/glibc-2.23/csu/../csu/libc-start.c:289

previously allocated by thread T0 here:
    #0 0x4cf688 in malloc /var/tmp/portage/sys-libs/compiler-rt-sanitizers-4.0.1/work/compiler-rt-4.0.1.src/lib/asan/asan_malloc_linux.cc:66
    #1 0x7fc01a8f04d6 in MagickMalloc /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/memory.c:156:10
    #2 0x7fc01a7a6fa3 in AllocateImage /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/image.c:336:18
    #3 0x7fc013f7819a in ReadMNGImage /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/coders/png.c:3872:9
    #4 0x7fc01a50ee88 in ReadImage /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/constitute.c:1607:13
    #5 0x7fc01a3a1f18 in ConvertImageCommand /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/command.c:4348:22
    #6 0x7fc01a3de0c5 in MagickCommand /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/command.c:8869:17
    #7 0x7fc01a48985b in GMCommandSingle /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/command.c:17396:10
    #8 0x7fc01a486991 in GMCommand /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/command.c:17449:16
    #9 0x7fc018cf1680 in __libc_start_main /var/tmp/portage/sys-libs/glibc-2.23-r4/work/glibc-2.23/csu/../csu/libc-start.c:289

SUMMARY: AddressSanitizer: heap-use-after-free /var/tmp/portage/media-gfx/graphicsmagick-1.3.26/work/GraphicsMagick-1.3.26/magick/blob.c:859:3 in CloseBlob
Shadow bytes around the buggy address:
  0x0c467fff8a20: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
  0x0c467fff8a30: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
  0x0c467fff8a40: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
  0x0c467fff8a50: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
  0x0c467fff8a60: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
=>0x0c467fff8a70: fd fd fd fd fd fd fd fd[fd]fa fa fa fa fa fa fa
  0x0c467fff8a80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c467fff8a90: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c467fff8aa0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c467fff8ab0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c467fff8ac0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==20404==ABORTING

```

**Affected version:**

1.3.26

**Fixed version:**

N/A

**Commit fix:**

<http://hg.code.sf.net/p/graphicsmagick/code/rev/d0a76868ca37>

**Credit:**

This bug was discovered by Agostino Sarubbo of Gentoo.

**CVE:**

CVE-2017-11403

**Reproducer:**

<https://github.com/asarubbo/poc/blob/master/00301-graphicsmagick-UAF-CloseBlob>

**Timeline:**

2017-07-10: bug discovered and reported to upstream

2017-07-10: upstream released a fix

2017-07-12: blog post about the issue

2017-07-18: CVE assigned

**Note:**

This bug was found with [American Fuzzy Lop](http://lcamtuf.coredump.cx/afl).

**Permalink:**

> [graphicsmagick: use-after-free in CloseBlob (blob.c)](http://blogs.gentoo.org/ago/2017/07/12/graphicsmagick-use-after-free-in-closeblob-blob-c/)

This entry was posted in [advisories](https://blogs.gentoo.org/ago/category/advisories/), [security](https://blogs.gentoo.org/ago/category/security/). Bookmark the [permalink](https://blogs.gentoo.org/ago/2017/07/12/graphicsmagick-use-after-free-in-closeblob-blob-c/ "Permalink to graphicsmagick: use-after-free in CloseBlob (blob.c)").

[← mpg123: global buffer overflow in III\_i\_stereo (layer3.c)](https://blogs.gentoo.org/ago/2017/07/03/mpg123-global-buffer-overflow-in-iii_i_stereo-layer3-c/)
[graphicsmagick: use-after-free in ReadWMFImage (wmf.c) →](https://blogs.gentoo.org/ago/2017/08/05/graphicsmagick-use-after-free-in-readwmfimage-wmf-c/)

### Leave a Reply [Cancel reply](/ago/2017/07/12/graphicsmagick-use-after-free-in-closeblob-blob-c/#respond)

Your email address will not be published. Required fields are marked \*

Comment \*

Name \*

Email \*

Website

 Notify me of follow-up comments by email.

 Notify me of new posts by email.

Authenticate this comment using OpenID.

Δ

This site uses Akismet to reduce spam. [Learn how your comment data is processed](https://akismet.com/privacy/).

* Search for:
* ### Recent Posts

  + [gentoo tinderbox](https://blogs.gentoo.org/ago/2020/07/04/gentoo-tinderbox/)
  + [re2c: heap overflow in Scanner::fill (scanner.cc)](https://blogs.gentoo.org/ago/2020/04/19/re2c-heap-overflow-in-scannerfill-scanner-cc/)
  + [Why I stopped fuzzing research](https://blogs.gentoo.org/ago/2020/04/16/why-i-stopped-fuzzing-research/)
  + [Install Gentoo in less than one minute](https://blogs.gentoo.org/ago/2019/03/20/install-gentoo-in-less-than-one-minute/)
  + [binutils: invalid memory read in find\_abstract\_instance\_name (dwarf2.c)](https://blogs.gentoo.org/ago/2017/10/24/binutils-invalid-memory-read-in-find_abstract_instance_name-dwarf2-c/)
* ### Recent Comments

  + strongcourage on [Why I stopped fuzzing research](https://blogs.gentoo.org/ago/2020/04/16/why-i-stopped-fuzzing-research/#comment-181437)
  + [Bob Friesenhahn](http://www.graphicsmagick.org/) on [Why I stopped fuzzing research](https://blogs.gentoo.org/ago/2020/04/16/why-i-stopped-fuzzing-research/#comment-181419)
  + [#gentoo dev: Why I stopped fuzzing research https://blogs.gentoo.or… | Dr. Roy Schestowitz (罗伊)](https://placeholderapi.wordpress.com/2020/04/18/gentoo-dev-why-i-stopped-fuzzing-research-https-blogs-gentoo-or/) on [Why I stopped fuzzing research](https://blogs.gentoo.org/ago/2020/04/16/why-i-stopped-fuzzing-research/#comment-181400)
  + Ulya on [Why I stopped fuzzing research](https://blogs.gentoo.org/ago/2020/04/16/why-i-stopped-fuzzing-research/#comment-181396)
  + ago on [Install Gentoo in less than one minute](https://blogs.gentoo.org/ago/2019/03/20/install-gentoo-in-less-than-one-minute/#comment-178429)
* ### Archives

  + [July 2020](https://blogs.gentoo.org/ago/2020/07/)
  + [April 2020](https://blogs.gentoo.org/ago/2020/04/)
  + [March 2019](https://blogs.gentoo.org/ago/2019/03/)
  + [October 2017](https://blogs.gentoo.org/ago/2017/10/)
  + [September 2017](https://blogs.gentoo.org/ago/2017/09/)
  + [August 2017](https://blogs.gentoo.org/ago/2017/08/)
  + [July 2017](https://blogs.gentoo.org/ago/2017/07/)
  + [June 2017](https://blogs.gentoo.org/ago/2017/06/)
  + [May 2017](https://blogs.gentoo.org/ago/2017/05/)
  + [April 2017](https://blogs.gentoo.org/ago/2017/04/)
  + [March 2017](https://blogs.gentoo.org/ago/2017/03/)
  + [February 2017](https://blogs.gentoo.org/ago/2017/02/)
  + [January 2017](https://blogs.gentoo.org/ago/2017/01/)
  + [December 2016](https://blogs.gentoo.org/ago/2016/12/)
  + [November 2016](https://blogs.gentoo.org/ago/2016/11/)
  + [October 2016](https://blogs.gentoo.org/ago/2016/10/)
  + [September 2016](https://blogs.gentoo.org/ago/2016/09/)
  + [August 2016](https://blogs.gentoo.org/ago/2016/08/)
  + [July 2016](https://blogs.gentoo.org/ago/2016/07/)
  + [February 2016](https://blogs.gentoo.org/ago/2016/02/)
  + [July 2015](https://blogs.gentoo.org/ago/2015/07/)
  + [August 2013](https://blogs.gentoo.org/ago/2013/08/)
  + [June 2013](https://blogs.gentoo.org/ago/2013/06/)
  + [May 2013](https://blogs.gentoo.org/ago/2013/05/)
  + [January 2013](https://blogs.gentoo.org/ago/2013/01/)
  + [December 2012](https://blogs.gentoo.org/ago/2012/12/)
  + [November 2012](https://blogs.gentoo.org/ago/2012/11/)
  + [October 2012](https://blogs.gentoo.org/ago/2012/10/)
  + [August 2012](https://blogs.gentoo.org/ago/2012/08/)
  + [July 2012](https://blogs.gentoo.org/ago/2012/07/)
  + [June 2012](https://blogs.gentoo.org/ago/2012/06/)
* ### Categories

  + [advisories](https://blogs.gentoo.org/ago/category/advisories/)
  + [arch testing](https://blogs.gentoo.org/ago/category/arch-testing/)
  + [gentoo](https://blogs.gentoo.org/ago/category/gentoo/)
  + [security](https://blogs.gentoo.org/ago/category/security/)
* ### Meta

  + [Log in](https://blogs.gentoo.org/ago/wp-login.php)
  + [Entries feed](https://blogs.gentoo.org/ago/feed/)
  + [Comments feed](https://blogs.gentoo.org/ago/comments/feed/)
  + [WordPress.org](https://wordpress.org/)

[agostino's blog](https://blogs.gentoo.org/ago/ "agostino's blog")
Original theme twentyten, modified by csslayer. Better experience in firefox and webkit.

[Proudly powered by WordPress.](http://wordpress.org/ "Semantic Personal Publishing Platform")


