The provided content describes a bug in `wcsxfrm` and `LCMapStringW` related to memory corruption.

**Root cause of vulnerability:**
The vulnerability stems from an incorrect handling of the destination buffer size when using the `LCMAP_BYTEREV` flag with `LCMapStringW`.  The `cchDest` argument (size of the destination buffer), which is intended to be a *byte* count when using `LCMAP_SORTKEY`, seems to be treated as a character count for the purposes of applying the `LCMAP_BYTEREV` transformation. This results in byte-reversal operation extending beyond the allocated buffer, leading to memory corruption.

**Weaknesses/vulnerabilities present:**
- Out-of-bounds write due to incorrect buffer size calculation during byte reversal.
- Incorrect interpretation of `cchDest` argument in `LCMapStringW` when `LCMAP_BYTEREV` is used, leading to an inconsistency between byte count and character count.

**Impact of exploitation:**
- Memory corruption due to out-of-bounds write. This can lead to:
    - Program crashes (segfaults, as observed in the initial problem report).
    - Data integrity issues due to overwritten memory.
    - Potential for exploitation if the overwritten memory contains sensitive data or control flow information (although this is not explicitly mentioned in the content, it's a general consequence of memory corruption).

**Attack vectors:**
- Calling the `wcsxfrm` function or directly invoking `LCMapStringW` with the `LCMAP_SORTKEY` and `LCMAP_BYTEREV` flags.
- Providing an output buffer of N wide characters, where the sort key's byte representation results in the byte reversal operation to write beyond this buffer size.

**Required attacker capabilities/position:**
- The attacker needs to be able to invoke either the `wcsxfrm` function or directly call `LCMapStringW` and control the size of the provided buffer and the input string being transformed, although the attached test shows that this can be triggered even when transforming a single character.