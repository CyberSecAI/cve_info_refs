=== Content from bugzilla.kernel.org_4c38f9ea_20250125_210311.html ===


Kernel.org Bugzilla – Bug 193921
/proc/timer\_list leaks the real pids of the associated processes
Last modified: 2017-02-03 21:51:34 UTC

* [Home](./)
* | [New](enter_bug.cgi)
* | [Browse](describecomponents.cgi)
* | [Search](query.cgi)
* |

  [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")
* | [Reports](report.cgi)
* |
  [Requests](request.cgi)
* |
  [Help](https://bugzilla.readthedocs.org/en/latest/using/understanding.html)
* |
  [New Account](createaccount.cgi)
* |
  [Log In](show_bug.cgi?id=193921&GoAheadAndLogIn=1)

  [x]
* |
  [Forgot Password](createaccount.cgi?request_new_password=1)
  Login:

  [x]

[**Bug 193921**](show_bug.cgi?id=193921)
- /proc/timer\_list leaks the real pids of the associated processes

[Summary:](page.cgi?id=fields.html#short_desc "The bug summary is a short sentence which succinctly describes what the bug is about.")
/proc/timer\_list leaks the real pids of the associated processes

| | [Status](page.cgi?id=fields.html#bug_status): | NEW | | --- | --- | |  | | | [Alias:](page.cgi?id=fields.html#alias "A short, unique name assigned to a bug in order to assist with looking it up and referring to it in other places in Bugzilla.") | None | |  | | | [Product:](describecomponents.cgi "Bugs are categorised into Products and Components.") | Timers | | [Classification:](page.cgi?id=fields.html#classification "Bugs are categorised into Classifications, Products and Components. classifications is the top-level categorisation.") | Unclassified | | [Component:](describecomponents.cgi?product=Timers "Components are second-level categories; each belongs to a particular Product. Select a Product to narrow down this list.") | Other ([show other bugs](buglist.cgi?component=Other&product=Timers&bug_status=__open__)) | | [Hardware:](page.cgi?id=fields.html#rep_platform "The hardware platform the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | All Linux | |  | | | [Importance](page.cgi?id=fields.html#importance): | P1 normal | | [Assignee:](page.cgi?id=fields.html#assigned_to "The person in charge of resolving the bug.") | john stultz | |  | | | [URL:](page.cgi?id=fields.html#bug_file_loc "Bugs can have a URL associated with them - for example, a pointer to a web site where the problem is seen.") |  | | [Keywords:](describekeywords.cgi "You can add keywords from a defined list to bugs, in order to easily identify and group them.") |  | |  | | | [Depends on:](page.cgi?id=fields.html#dependson "The bugs listed here must be resolved before this bug can be resolved.") |  | | [Blocks:](page.cgi?id=fields.html#blocked "This bug must be resolved before the bugs listed in this field can be resolved.") |  | |  | | Reported: | 2017-02-03 21:46 UTC by Xing Gao | | --- | --- | | Modified: | 2017-02-03 21:51 UTC ([History](show_activity.cgi?id=193921)) | | CC List: | 0 users | |  | | | [See Also:](page.cgi?id=fields.html#see_also "This allows you to refer to bugs in other installations. You can enter a URL to a bug in the 'Add Bug URLs' field to note that that bug is related to this one. You can enter multiple URLs at once by separating them with whitespace. You should normally use this field to refer to bugs in other installations. For bugs in this installation, it is better to use the Depends on and Blocks fields.") |  | | [Kernel Version:](page.cgi?id=fields.html#cf_kernel_version "A custom Free Text field in this installation of Bugzilla.") | 4.9 | | [Subsystem:](page.cgi?id=fields.html#cf_subsystem "The subsystem responsible for this bug (must match MAINTAINERS entry verbatim)") |  | | [Regression:](page.cgi?id=fields.html#cf_regression "A custom Drop Down field in this installation of Bugzilla.") | No | | [Bisected commit-id:](page.cgi?id=fields.html#cf_bisect_commit "Full commit-id of the commit that introduced this regression.") |  | |  | | |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| --- | | |

| | Attachments | | | --- | --- | | [Add an attachment](attachment.cgi?bugid=193921&action=enter) (proposed patch, testcase, etc.) | | |  |
| --- | --- | --- | --- | --- | --- |

| [Description](show_bug.cgi?id=193921#c0)  Xing Gao    2017-02-03 21:46:15 UTC  ``` The pseudo file /proc/timer_list leaks the real pids of the associated processes.   The function print_timer(kernel/time/timer_list.c) displays timer->start_pid, which is set inside the function __timer_stats_timer_set_start_info (kernel/time/timer.c). This is the real pid, rather than the pid in the pid namespace. If the user within a container retrieves the content of /proc/timer_list, this file will leak the real pid of the associated process.   Docker has blocked the read access to /proc/timer_list. But there should be a kernel fix to address this information leakage. ```  [Comment 1](show_bug.cgi?id=193921#c1)  john stultz    2017-02-03 21:51:34 UTC  ``` Please send this to lkml and add Thomas Gleixner <tglx@linutronix.de> and Kees Cook <keescook@google.com> to the cc. ``` |  |
| --- | --- |

---

| Note You need to [log in](show_bug.cgi?id=193921&GoAheadAndLogIn=1) before you can comment on or make changes to this bug. |
| --- |

---

* [Format For Printing](show_bug.cgi?format=multiple&id=193921)
* - [XML](show_bug.cgi?ctype=xml&id=193921)
* - [Clone This Bug](enter_bug.cgi?cloned_bug_id=193921)
* - Top of page

* + [Home](./)
  + | [New](enter_bug.cgi)
  + | [Browse](describecomponents.cgi)
  + | [Search](query.cgi)
  + |

    [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")
  + | [Reports](report.cgi)
  + |
    [Requests](request.cgi)
  + |
    [Help](https://bugzilla.readthedocs.org/en/latest/using/understanding.html)
  + |
    [New Account](createaccount.cgi)
  + |
    [Log In](show_bug.cgi?id=193921&GoAheadAndLogIn=1)

    [x]
  + |
    [Forgot Password](createaccount.cgi?request_new_password=1)
    Login:

    [x]



=== Content from git.kernel.org_33d9b355_20250125_210309.html ===


| [cgit logo](/) | [index](/) : [kernel/git/tip/tip.git](/pub/scm/linux/kernel/git/tip/tip.git/) | WIP.fixes WIP.x86/fpu auto-latest core/build core/core core/debugobjects core/documentation core/entry core/headers core/kprobes core/merge core/mm core/rcu core/static\_call core/urgent efi/core efi/urgent irq/core irq/msi irq/urgent locking/core locking/debug locking/header locking/kcsan locking/nmi locking/rcuref locking/rwsem locking/urgent locking/wwmutex master objtool/core objtool/urgent perf/core perf/kprobes perf/urgent perf/vlbr ras/core ras/merge ras/urgent rcu/urgent sched/arm64 sched/core sched/eevdf sched/fifo sched/migrate-disable sched/psi sched/rt sched/smp sched/urgent smp/core smp/urgent timers/clocksource timers/core timers/nohz timers/ptp timers/urgent timers/vdso tip/tip tip/urgent x86/acpi x86/alternatives x86/apic x86/asm x86/boot x86/bugs x86/build x86/cache x86/cc x86/cleanups x86/core x86/cpu x86/entry x86/fpu x86/fred x86/fsgsbase x86/headers x86/hyperv x86/irq x86/kaslr x86/kdump x86/merge x86/microcode x86/misc x86/mm x86/mtrr x86/paravirt x86/pasid x86/percpu x86/platform x86/sev x86/seves x86/sgx x86/shstk x86/splitlock x86/tdx x86/timers x86/urgent x86/vdso x86/vmware |
| --- | --- | --- |
| Unnamed repository; edit this file 'description' to name the repository. | TIP group |

| [about](/pub/scm/linux/kernel/git/tip/tip.git/about/)[summary](/pub/scm/linux/kernel/git/tip/tip.git/)[refs](/pub/scm/linux/kernel/git/tip/tip.git/refs/?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1)[log](/pub/scm/linux/kernel/git/tip/tip.git/log/)[tree](/pub/scm/linux/kernel/git/tip/tip.git/tree/?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1)[commit](/pub/scm/linux/kernel/git/tip/tip.git/commit/?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1)[diff](/pub/scm/linux/kernel/git/tip/tip.git/diff/?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1)[stats](/pub/scm/linux/kernel/git/tip/tip.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Kees Cook <keescook@chromium.org> | 2017-02-08 11:26:59 -0800 |
| --- | --- | --- |
| committer | Thomas Gleixner <tglx@linutronix.de> | 2017-02-10 11:15:08 +0100 |
| commit | [dfb4357da6ddbdf57d583ba64361c9d792b0e0b1](/pub/scm/linux/kernel/git/tip/tip.git/commit/?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1) ([patch](/pub/scm/linux/kernel/git/tip/tip.git/patch/?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1)) | |
| tree | [52d625e15accaf3c1b3e0504e64e6021c9f8b091](/pub/scm/linux/kernel/git/tip/tip.git/tree/?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1) | |
| parent | [bb42ca47401010fc02901b5e8f79e40a26f208cb](/pub/scm/linux/kernel/git/tip/tip.git/commit/?id=bb42ca47401010fc02901b5e8f79e40a26f208cb) ([diff](/pub/scm/linux/kernel/git/tip/tip.git/diff/?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1&id2=bb42ca47401010fc02901b5e8f79e40a26f208cb)) | |
| download | [tip-dfb4357da6ddbdf57d583ba64361c9d792b0e0b1.tar.gz](/pub/scm/linux/kernel/git/tip/tip.git/snapshot/tip-dfb4357da6ddbdf57d583ba64361c9d792b0e0b1.tar.gz) | |

time: Remove CONFIG\_TIMER\_STATSCurrently CONFIG\_TIMER\_STATS exposes process information across namespaces:
kernel/time/timer\_list.c print\_timer():
SEQ\_printf(m, ", %s/%d", tmp, timer->start\_pid);
/proc/timer\_list:
#11: <0000000000000000>, hrtimer\_wakeup, S:01, do\_nanosleep, cron/2570
Given that the tracer can give the same information, this patch entirely
removes CONFIG\_TIMER\_STATS.
Suggested-by: Thomas Gleixner <tglx@linutronix.de>
Signed-off-by: Kees Cook <keescook@chromium.org>
Acked-by: John Stultz <john.stultz@linaro.org>
Cc: Nicolas Pitre <nicolas.pitre@linaro.org>
Cc: linux-doc@vger.kernel.org
Cc: Lai Jiangshan <jiangshanlai@gmail.com>
Cc: Shuah Khan <shuah@kernel.org>
Cc: Xing Gao <xgao01@email.wm.edu>
Cc: Jonathan Corbet <corbet@lwn.net>
Cc: Jessica Frazelle <me@jessfraz.com>
Cc: kernel-hardening@lists.openwall.com
Cc: Nicolas Iooss <nicolas.iooss\_linux@m4x.org>
Cc: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
Cc: Petr Mladek <pmladek@suse.com>
Cc: Richard Cochran <richardcochran@gmail.com>
Cc: Tejun Heo <tj@kernel.org>
Cc: Michal Marek <mmarek@suse.com>
Cc: Josh Poimboeuf <jpoimboe@redhat.com>
Cc: Dmitry Vyukov <dvyukov@google.com>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: "Eric W. Biederman" <ebiederm@xmission.com>
Cc: Olof Johansson <olof@lixom.net>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: linux-api@vger.kernel.org
Cc: Arjan van de Ven <arjan@linux.intel.com>
Link: [http://lkml.kernel.org/r/20170208192659.GA32582@beast](http://lkml.kernel.org/r/20170208192659.GA32582%40beast)
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
[Diffstat](/pub/scm/linux/kernel/git/tip/tip.git/diff/?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1)

| -rw-r--r-- | [Documentation/timers/timer\_stats.txt](/pub/scm/linux/kernel/git/tip/tip.git/diff/Documentation/timers/timer_stats.txt?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1) | 73 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/linux/hrtimer.h](/pub/scm/linux/kernel/git/tip/tip.git/diff/include/linux/hrtimer.h?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1) | 11 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/timer.h](/pub/scm/linux/kernel/git/tip/tip.git/diff/include/linux/timer.h?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1) | 45 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/kthread.c](/pub/scm/linux/kernel/git/tip/tip.git/diff/kernel/kthread.c?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/time/Makefile](/pub/scm/linux/kernel/git/tip/tip.git/diff/kernel/time/Makefile?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/time/hrtimer.c](/pub/scm/linux/kernel/git/tip/tip.git/diff/kernel/time/hrtimer.c?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1) | 38 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/time/timer.c](/pub/scm/linux/kernel/git/tip/tip.git/diff/kernel/time/timer.c?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1) | 48 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/time/timer\_list.c](/pub/scm/linux/kernel/git/tip/tip.git/diff/kernel/time/timer_list.c?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/time/timer\_stats.c](/pub/scm/linux/kernel/git/tip/tip.git/diff/kernel/time/timer_stats.c?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1) | 425 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/workqueue.c](/pub/scm/linux/kernel/git/tip/tip.git/diff/kernel/workqueue.c?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [lib/Kconfig.debug](/pub/scm/linux/kernel/git/tip/tip.git/diff/lib/Kconfig.debug?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1) | 14 | |  |  |  | | --- | --- | --- | |

11 files changed, 2 insertions, 666 deletions

| diff --git a/Documentation/timers/timer\_stats.txt b/Documentation/timers/timer\_stats.txtdeleted file mode 100644index de835ee974550e..00000000000000--- a/[Documentation/timers/timer\_stats.txt](/pub/scm/linux/kernel/git/tip/tip.git/tree/Documentation/timers/timer_stats.txt?id=bb42ca47401010fc02901b5e8f79e40a26f208cb)+++ /dev/null@@ -1,73 +0,0 @@-timer\_stats - timer usage statistics---------------------------------------timer\_stats is a debugging facility to make the timer (ab)usage in a Linux-system visible to kernel and userspace developers. If enabled in the config-but not used it has almost zero runtime overhead, and a relatively small-data structure overhead. Even if collection is enabled runtime all the-locking is per-CPU and lookup is hashed.--timer\_stats should be used by kernel and userspace developers to verify that-their code does not make unduly use of timers. This helps to avoid unnecessary-wakeups, which should be avoided to optimize power consumption.--It can be enabled by CONFIG\_TIMER\_STATS in the "Kernel hacking" configuration-section.--timer\_stats collects information about the timer events which are fired in a-Linux system over a sample period:--- the pid of the task(process) which initialized the timer-- the name of the process which initialized the timer-- the function where the timer was initialized-- the callback function which is associated to the timer-- the number of events (callbacks)--timer\_stats adds an entry to /proc: /proc/timer\_stats--This entry is used to control the statistics functionality and to read out the-sampled information.--The timer\_stats functionality is inactive on bootup.--To activate a sample period issue:-# echo 1 >/proc/timer\_stats--To stop a sample period issue:-# echo 0 >/proc/timer\_stats--The statistics can be retrieved by:-# cat /proc/timer\_stats--While sampling is enabled, each readout from /proc/timer\_stats will see-newly updated statistics. Once sampling is disabled, the sampled information-is kept until a new sample period is started. This allows multiple readouts.--Sample output of /proc/timer\_stats:--Timerstats sample period: 3.888770 s- 12, 0 swapper hrtimer\_stop\_sched\_tick (hrtimer\_sched\_tick)- 15, 1 swapper hcd\_submit\_urb (rh\_timer\_func)- 4, 959 kedac schedule\_timeout (process\_timeout)- 1, 0 swapper page\_writeback\_init (wb\_timer\_fn)- 28, 0 swapper hrtimer\_stop\_sched\_tick (hrtimer\_sched\_tick)- 22, 2948 IRQ 4 tty\_flip\_buffer\_push (delayed\_work\_timer\_fn)- 3, 3100 bash schedule\_timeout (process\_timeout)- 1, 1 swapper queue\_delayed\_work\_on (delayed\_work\_timer\_fn)- 1, 1 swapper queue\_delayed\_work\_on (delayed\_work\_timer\_fn)- 1, 1 swapper neigh\_table\_init\_no\_netlink (neigh\_periodic\_timer)- 1, 2292 ip \_\_netdev\_watchdog\_up (dev\_watchdog)- 1, 23 events/1 do\_cache\_clean (delayed\_work\_timer\_fn)-90 total events, 30.0 events/sec--The first column is the number of events, the second column the pid, the third-column is the name of the process. The forth column shows the function which-initialized the timer and in parenthesis the callback function which was-executed on expiry.-- Thomas, Ingo--Added flag to indicate 'deferrable timer' in /proc/timer\_stats. A deferrable-timer will appear as follows- 10D, 1 swapper queue\_delayed\_work\_on (delayed\_work\_timer\_fn)-diff --git a/include/linux/hrtimer.h b/include/linux/hrtimer.hindex cdab81ba29f899..e52b427223baa8 100644--- a/[include/linux/hrtimer.h](/pub/scm/linux/kernel/git/tip/tip.git/tree/include/linux/hrtimer.h?id=bb42ca47401010fc02901b5e8f79e40a26f208cb)+++ b/[include/linux/hrtimer.h](/pub/scm/linux/kernel/git/tip/tip.git/tree/include/linux/hrtimer.h?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1)@@ -88,12 +88,6 @@ enum hrtimer\_restart { \* @base: pointer to the timer base (per cpu and per clock) \* @state: state information (See bit values above) \* @is\_rel: Set if the timer was armed relative- \* @start\_pid: timer statistics field to store the pid of the task which- \* started the timer- \* @start\_site: timer statistics field to store the site where the timer- \* was started- \* @start\_comm: timer statistics field to store the name of the process which- \* started the timer \* \* The hrtimer structure must be initialized by hrtimer\_init() \*/@@ -104,11 +98,6 @@ struct hrtimer { struct hrtimer\_clock\_base \*base; u8 state; u8 is\_rel;-#ifdef CONFIG\_TIMER\_STATS- int start\_pid;- void \*start\_site;- char start\_comm[16];-#endif };  /\*\*diff --git a/include/linux/timer.h b/include/linux/timer.hindex 51d601f192d421..5a209b84fd9e48 100644--- a/[include/linux/timer.h](/pub/scm/linux/kernel/git/tip/tip.git/tree/include/linux/timer.h?id=bb42ca47401010fc02901b5e8f79e40a26f208cb)+++ b/[include/linux/timer.h](/pub/scm/linux/kernel/git/tip/tip.git/tree/include/linux/timer.h?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1)@@ -20,11 +20,6 @@ struct timer\_list { unsigned long data; u32 flags; -#ifdef CONFIG\_TIMER\_STATS- int start\_pid;- void \*start\_site;- char start\_comm[16];-#endif #ifdef CONFIG\_LOCKDEP struct lockdep\_map lockdep\_map; #endif@@ -197,46 +192,6 @@ extern int mod\_timer\_pending(struct timer\_list \*timer, unsigned long expires); \*/ #define NEXT\_TIMER\_MAX\_DELTA ((1UL << 30) - 1) -/\*- \* Timer-statistics info:- \*/-#ifdef CONFIG\_TIMER\_STATS--extern int timer\_stats\_active;--extern void init\_timer\_stats(void);--extern void timer\_stats\_update\_stats(void \*timer, pid\_t pid, void \*startf,- void \*timerf, char \*comm, u32 flags);--extern void \_\_timer\_stats\_timer\_set\_start\_info(struct timer\_list \*timer,- void \*addr);--static inline void timer\_stats\_timer\_set\_start\_info(struct timer\_list \*timer)-{- if (likely(!timer\_stats\_active))- return;- \_\_timer\_stats\_timer\_set\_start\_info(timer, \_\_builtin\_return\_address(0));-}--static inline void timer\_stats\_timer\_clear\_start\_info(struct timer\_list \*timer)-{- timer->start\_site = NULL;-}-#else-static inline void init\_timer\_stats(void)-{-}--static inline void timer\_stats\_timer\_set\_start\_info(struct timer\_list \*timer)-{-}--static inline void timer\_stats\_timer\_clear\_start\_info(struct timer\_list \*timer)-{-}-#endif- extern void add\_timer(struct timer\_list \*timer);  extern int try\_to\_del\_timer\_sync(struct timer\_list \*timer);diff --git a/kernel/kthread.c b/kernel/kthread.cindex 2318fba8627718..8461a4372e8aab 100644--- a/[kernel/kthread.c](/pub/scm/linux/kernel/git/tip/tip.git/tree/kernel/kthread.c?id=bb42ca47401010fc02901b5e8f79e40a26f208cb)+++ b/[kernel/kthread.c](/pub/scm/linux/kernel/git/tip/tip.git/tree/kernel/kthread.c?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1)@@ -850,7 +850,6 @@ void \_\_kthread\_queue\_delayed\_work(struct kthread\_worker \*worker,  list\_add(&work->node, &worker->delayed\_work\_list); work->worker = worker;- timer\_stats\_timer\_set\_start\_info(&dwork->timer); timer->expires = jiffies + delay; add\_timer(timer); }diff --git a/kernel/time/Makefile b/kernel/time/Makefileindex 976840d29a714f..938dbf33ef493c 100644--- a/[kernel/time/Makefile](/pub/scm/linux/kernel/git/tip/tip.git/tree/kernel/time/Makefile?id=bb42ca47401010fc02901b5e8f79e40a26f208cb)+++ b/[kernel/time/Makefile](/pub/scm/linux/kernel/git/tip/tip.git/tree/kernel/time/Makefile?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1)@@ -15,6 +15,5 @@ ifeq ($(CONFIG\_GENERIC\_CLOCKEVENTS\_BROADCAST),y) endif obj-$(CONFIG\_GENERIC\_SCHED\_CLOCK) += sched\_clock.o obj-$(CONFIG\_TICK\_ONESHOT) += tick-oneshot.o tick-sched.o-obj-$(CONFIG\_TIMER\_STATS) += timer\_stats.o obj-$(CONFIG\_DEBUG\_FS) += timekeeping\_debug.o obj-$(CONFIG\_TEST\_UDELAY) += test\_udelay.odiff --git a/kernel/time/hrtimer.c b/kernel/time/hrtimer.cindex c6ecedd3b8393d..edabde646e5893 100644--- a/[kernel/time/hrtimer.c](/pub/scm/linux/kernel/git/tip/tip.git/tree/kernel/time/hrtimer.c?id=bb42ca47401010fc02901b5e8f79e40a26f208cb)+++ b/[kernel/time/hrtimer.c](/pub/scm/linux/kernel/git/tip/tip.git/tree/kernel/time/hrtimer.c?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1)@@ -766,34 +766,6 @@ void hrtimers\_resume(void) clock\_was\_set\_delayed(); } -static inline void timer\_stats\_hrtimer\_set\_start\_info(struct hrtimer \*timer)-{-#ifdef CONFIG\_TIMER\_STATS- if (timer->start\_site)- return;- timer->start\_site = \_\_builtin\_return\_address(0);- memcpy(timer->start\_comm, current->comm, TASK\_COMM\_LEN);- timer->start\_pid = current->pid;-#endif-}--static inline void timer\_stats\_hrtimer\_clear\_start\_info(struct hrtimer \*timer)-{-#ifdef CONFIG\_TIMER\_STATS- timer->start\_site = NULL;-#endif-}--static inline void timer\_stats\_account\_hrtimer(struct hrtimer \*timer)-{-#ifdef CONFIG\_TIMER\_STATS- if (likely(!timer\_stats\_active))- return;- timer\_stats\_update\_stats(timer, timer->start\_pid, timer->start\_site,- timer->function, timer->start\_comm, 0);-#endif-}- /\* \* Counterpart to lock\_hrtimer\_base above: \*/@@ -932,7 +904,6 @@ remove\_hrtimer(struct hrtimer \*timer, struct hrtimer\_clock\_base \*base, bool rest \* rare case and less expensive than a smp call. \*/ debug\_deactivate(timer);- timer\_stats\_hrtimer\_clear\_start\_info(timer); reprogram = base->cpu\_base == this\_cpu\_ptr(&hrtimer\_bases);  if (!restart)@@ -990,8 +961,6 @@ void hrtimer\_start\_range\_ns(struct hrtimer \*timer, ktime\_t tim, /\* Switch the timer base, if necessary: \*/ new\_base = switch\_hrtimer\_base(timer, base, mode & HRTIMER\_MODE\_PINNED); - timer\_stats\_hrtimer\_set\_start\_info(timer);- leftmost = enqueue\_hrtimer(timer, new\_base); if (!leftmost) goto unlock;@@ -1128,12 +1097,6 @@ static void \_\_hrtimer\_init(struct hrtimer \*timer, clockid\_t clock\_id, base = hrtimer\_clockid\_to\_base(clock\_id); timer->base = &cpu\_base->clock\_base[base]; timerqueue\_init(&timer->node);--#ifdef CONFIG\_TIMER\_STATS- timer->start\_site = NULL;- timer->start\_pid = -1;- memset(timer->start\_comm, 0, TASK\_COMM\_LEN);-#endif }  /\*\*@@ -1217,7 +1180,6 @@ static void \_\_run\_hrtimer(struct hrtimer\_cpu\_base \*cpu\_base, raw\_write\_seqcount\_barrier(&cpu\_base->seq);  \_\_remove\_hrtimer(timer, base, HRTIMER\_STATE\_INACTIVE, 0);- timer\_stats\_account\_hrtimer(timer); fn = timer->function;  /\*diff --git a/kernel/time/timer.c b/kernel/time/timer.cindex ec33a6933eaed5..82a6bfa0c30789 100644--- a/[kernel/time/timer.c](/pub/scm/linux/kernel/git/tip/tip.git/tree/kernel/time/timer.c?id=bb42ca47401010fc02901b5e8f79e40a26f208cb)+++ b/[kernel/time/timer.c](/pub/scm/linux/kernel/git/tip/tip.git/tree/kernel/time/timer.c?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1)@@ -571,38 +571,6 @@ internal\_add\_timer(struct timer\_base \*base, struct timer\_list \*timer) trigger\_dyntick\_cpu(base, timer); } -#ifdef CONFIG\_TIMER\_STATS-void \_\_timer\_stats\_timer\_set\_start\_info(struct timer\_list \*timer, void \*addr)-{- if (timer->start\_site)- return;-- timer->start\_site = addr;- memcpy(timer->start\_comm, current->comm, TASK\_COMM\_LEN);- timer->start\_pid = current->pid;-}--static void timer\_stats\_account\_timer(struct timer\_list \*timer)-{- void \*site;-- /\*- \* start\_site can be concurrently reset by- \* timer\_stats\_timer\_clear\_start\_info()- \*/- site = READ\_ONCE(timer->start\_site);- if (likely(!site))- return;-- timer\_stats\_update\_stats(timer, timer->start\_pid, site,- timer->function, timer->start\_comm,- timer->flags);-}--#else-static void timer\_stats\_account\_timer(struct timer\_list \*timer) {}-#endif- #ifdef CONFIG\_DEBUG\_OBJECTS\_TIMERS  static struct debug\_obj\_descr timer\_debug\_descr;@@ -789,11 +757,6 @@ static void do\_init\_timer(struct timer\_list \*timer, unsigned int flags, { timer->entry.pprev = NULL; timer->flags = flags | raw\_smp\_processor\_id();-#ifdef CONFIG\_TIMER\_STATS- timer->start\_site = NULL;- timer->start\_pid = -1;- memset(timer->start\_comm, 0, TASK\_COMM\_LEN);-#endif lockdep\_init\_map(&timer->lockdep\_map, name, key, 0); } @@ -1001,8 +964,6 @@ \_\_mod\_timer(struct timer\_list \*timer, unsigned long expires, bool pending\_only) base = lock\_timer\_base(timer, &flags); } - timer\_stats\_timer\_set\_start\_info(timer);- ret = detach\_if\_pending(timer, base, false); if (!ret && pending\_only) goto out\_unlock;@@ -1130,7 +1091,6 @@ void add\_timer\_on(struct timer\_list \*timer, int cpu) struct timer\_base \*new\_base, \*base; unsigned long flags; - timer\_stats\_timer\_set\_start\_info(timer); BUG\_ON(timer\_pending(timer) || !timer->function);  new\_base = get\_timer\_cpu\_base(timer->flags, cpu);@@ -1176,7 +1136,6 @@ int del\_timer(struct timer\_list \*timer)  debug\_assert\_init(timer); - timer\_stats\_timer\_clear\_start\_info(timer); if (timer\_pending(timer)) { base = lock\_timer\_base(timer, &flags); ret = detach\_if\_pending(timer, base, true);@@ -1204,10 +1163,9 @@ int try\_to\_del\_timer\_sync(struct timer\_list \*timer)  base = lock\_timer\_base(timer, &flags); - if (base->running\_timer != timer) {- timer\_stats\_timer\_clear\_start\_info(timer);+ if (base->running\_timer != timer) ret = detach\_if\_pending(timer, base, true);- }+ spin\_unlock\_irqrestore(&base->lock, flags);  return ret;@@ -1331,7 +1289,6 @@ static void expire\_timers(struct timer\_base \*base, struct hlist\_head \*head) unsigned long data;  timer = hlist\_entry(head->first, struct timer\_list, entry);- timer\_stats\_account\_timer(timer);  base->running\_timer = timer; detach\_timer(timer, true);@@ -1868,7 +1825,6 @@ static void \_\_init init\_timer\_cpus(void) void \_\_init init\_timers(void) { init\_timer\_cpus();- init\_timer\_stats(); open\_softirq(TIMER\_SOFTIRQ, run\_timer\_softirq); } diff --git a/kernel/time/timer\_list.c b/kernel/time/timer\_list.cindex afe6cd1944fc5d..387a3a5aa3888a 100644--- a/[kernel/time/timer\_list.c](/pub/scm/linux/kernel/git/tip/tip.git/tree/kernel/time/timer_list.c?id=bb42ca47401010fc02901b5e8f79e40a26f208cb)+++ b/[kernel/time/timer\_list.c](/pub/scm/linux/kernel/git/tip/tip.git/tree/kernel/time/timer_list.c?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1)@@ -62,21 +62,11 @@ static void print\_timer(struct seq\_file \*m, struct hrtimer \*taddr, struct hrtimer \*timer, int idx, u64 now) {-#ifdef CONFIG\_TIMER\_STATS- char tmp[TASK\_COMM\_LEN + 1];-#endif SEQ\_printf(m, " #%d: ", idx); print\_name\_offset(m, taddr); SEQ\_printf(m, ", "); print\_name\_offset(m, timer->function); SEQ\_printf(m, ", S:%02x", timer->state);-#ifdef CONFIG\_TIMER\_STATS- SEQ\_printf(m, ", ");- print\_name\_offset(m, timer->start\_site);- memcpy(tmp, timer->start\_comm, TASK\_COMM\_LEN);- tmp[TASK\_COMM\_LEN] = 0;- SEQ\_printf(m, ", %s/%d", tmp, timer->start\_pid);-#endif SEQ\_printf(m, "\n"); SEQ\_printf(m, " # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\n", (unsigned long long)ktime\_to\_ns(hrtimer\_get\_softexpires(timer)),diff --git a/kernel/time/timer\_stats.c b/kernel/time/timer\_stats.cdeleted file mode 100644index afddded947dfe4..00000000000000--- a/[kernel/time/timer\_stats.c](/pub/scm/linux/kernel/git/tip/tip.git/tree/kernel/time/timer_stats.c?id=bb42ca47401010fc02901b5e8f79e40a26f208cb)+++ /dev/null@@ -1,425 +0,0 @@-/\*- \* kernel/time/timer\_stats.c- \*- \* Collect timer usage statistics.- \*- \* Copyright(C) 2006, Red Hat, Inc., Ingo Molnar- \* Copyright(C) 2006 Timesys Corp., Thomas Gleixner <tglx@timesys.com>- \*- \* timer\_stats is based on timer\_top, a similar functionality which was part of- \* Con Kolivas dyntick patch set. It was developed by Daniel Petrini at the- \* Instituto Nokia de Tecnologia - INdT - Manaus. timer\_top's design was based- \* on dynamic allocation of the statistics entries and linear search based- \* lookup combined with a global lock, rather than the static array, hash- \* and per-CPU locking which is used by timer\_stats. It was written for the- \* pre hrtimer kernel code and therefore did not take hrtimers into account.- \* Nevertheless it provided the base for the timer\_stats implementation and- \* was a helpful source of inspiration. Kudos to Daniel and the Nokia folks- \* for this effort.- \*- \* timer\_top.c is- \* Copyright (C) 2005 Instituto Nokia de Tecnologia - INdT - Manaus- \* Written by Daniel Petrini <d.pensator@gmail.com>- \* timer\_top.c was released under the GNU General Public License version 2- \*- \* We export the addresses and counting of timer functions being called,- \* the pid and cmdline from the owner process if applicable.- \*- \* Start/stop data collection:- \* # echo [1|0] >/proc/timer\_stats- \*- \* Display the information collected so far:- \* # cat /proc/timer\_stats- \*- \* This program is free software; you can redistribute it and/or modify- \* it under the terms of the GNU General Public License version 2 as- \* published by the Free Software Foundation.- \*/--#include <linux/proc\_fs.h>-#include <linux/module.h>-#include <linux/spinlock.h>-#include <linux/sched.h>-#include <linux/seq\_file.h>-#include <linux/kallsyms.h>--#include <linux/uaccess.h>--/\*- \* This is our basic unit of interest: a timer expiry event identified- \* by the timer, its start/expire functions and the PID of the task that- \* started the timer. We count the number of times an event happens:- \*/-struct entry {- /\*- \* Hash list:- \*/- struct entry \*next;-- /\*- \* Hash keys:- \*/- void \*timer;- void \*start\_func;- void \*expire\_func;- pid\_t pid;-- /\*- \* Number of timeout events:- \*/- unsigned long count;- u32 flags;-- /\*- \* We save the command-line string to preserve- \* this information past task exit:- \*/- char comm[TASK\_COMM\_LEN + 1];--} \_\_\_\_cacheline\_aligned\_in\_smp;--/\*- \* Spinlock protecting the tables - not taken during lookup:- \*/-static DEFINE\_RAW\_SPINLOCK(table\_lock);--/\*- \* Per-CPU lookup locks for fast hash lookup:- \*/-static DEFINE\_PER\_CPU(raw\_spinlock\_t, tstats\_lookup\_lock);--/\*- \* Mutex to serialize state changes with show-stats activities:- \*/-static DEFINE\_MUTEX(show\_mutex);--/\*- \* Collection status, active/inactive:- \*/-int \_\_read\_mostly timer\_stats\_active;--/\*- \* Beginning/end timestamps of measurement:- \*/-static ktime\_t time\_start, time\_stop;--/\*- \* tstat entry structs only get allocated while collection is- \* active and never freed during that time - this simplifies- \* things quite a bit.- \*- \* They get freed when a new collection period is started.- \*/-#define MAX\_ENTRIES\_BITS 10-#define MAX\_ENTRIES (1UL << MAX\_ENTRIES\_BITS)--static unsigned long nr\_entries;-static struct entry entries[MAX\_ENTRIES];--static atomic\_t overflow\_count;--/\*- \* The entries are in a hash-table, for fast lookup:- \*/-#define TSTAT\_HASH\_BITS (MAX\_ENTRIES\_BITS - 1)-#define TSTAT\_HASH\_SIZE (1UL << TSTAT\_HASH\_BITS)-#define TSTAT\_HASH\_MASK (TSTAT\_HASH\_SIZE - 1)--#define \_\_tstat\_hashfn(entry) \- (((unsigned long)(entry)->timer ^ \- (unsigned long)(entry)->start\_func ^ \- (unsigned long)(entry)->expire\_func ^ \- (unsigned long)(entry)->pid ) & TSTAT\_HASH\_MASK)--#define tstat\_hashentry(entry) (tstat\_hash\_table + \_\_tstat\_hashfn(entry))--static struct entry \*tstat\_hash\_table[TSTAT\_HASH\_SIZE] \_\_read\_mostly;--static void reset\_entries(void)-{- nr\_entries = 0;- memset(entries, 0, sizeof(entries));- memset(tstat\_hash\_table, 0, sizeof(tstat\_hash\_table));- atomic\_set(&overflow\_count, 0);-}--static struct entry \*alloc\_entry(void)-{- if (nr\_entries >= MAX\_ENTRIES)- return NULL;-- return entries + nr\_entries++;-}--static int match\_entries(struct entry \*entry1, struct entry \*entry2)-{- return entry1->timer == entry2->timer &&- entry1->start\_func == entry2->start\_func &&- entry1->expire\_func == entry2->expire\_func &&- entry1->pid == entry2->pid;-}--/\*- \* Look up whether an entry matching this item is present- \* in the hash already. Must be called with irqs off and the- \* lookup lock held:- \*/-static struct entry \*tstat\_lookup(struct entry \*entry, char \*comm)-{- struct entry \*\*head, \*curr, \*prev;-- head = tstat\_hashentry(entry);- curr = \*head;-- /\*- \* The fastpath is when the entry is already hashed,- \* we do this with the lookup lock held, but with the- \* table lock not held:- \*/- while (curr) {- if (match\_entries(curr, entry))- return curr;-- curr = curr->next;- }- /\*- \* Slowpath: allocate, set up and link a new hash entry:- \*/- prev = NULL;- curr = \*head;-- raw\_spin\_lock(&table\_lock);- /\*- \* Make sure we have not raced with another CPU:- \*/- while (curr) {- if (match\_entries(curr, entry))- goto out\_unlock;-- prev = curr;- curr = curr->next;- }-- curr = alloc\_entry();- if (curr) {- \*curr = \*entry;- curr->count = 0;- curr->next = NULL;- memcpy(curr->comm, comm, TASK\_COMM\_LEN);-- smp\_mb(); /\* Ensure that curr is initialized before insert \*/-- if (prev)- prev->next = curr;- else- \*head = curr;- }- out\_unlock:- raw\_spin\_unlock(&table\_lock);-- return curr;-}--/\*\*- \* timer\_stats\_update\_stats - Update the statistics for a timer.- \* @timer: pointer to either a timer\_list or a hrtimer- \* @pid: the pid of the task which set up the timer- \* @startf: pointer to the function which did the timer setup- \* @timerf: pointer to the timer callback function of the timer- \* @comm: name of the process which set up the timer- \* @tflags: The flags field of the timer- \*- \* When the timer is already registered, then the event counter is- \* incremented. Otherwise the timer is registered in a free slot.- \*/-void timer\_stats\_update\_stats(void \*timer, pid\_t pid, void \*startf,- void \*timerf, char \*comm, u32 tflags)-{- /\*- \* It doesn't matter which lock we take:- \*/- raw\_spinlock\_t \*lock;- struct entry \*entry, input;- unsigned long flags;-- if (likely(!timer\_stats\_active))- return;-- lock = &per\_cpu(tstats\_lookup\_lock, raw\_smp\_processor\_id());-- input.timer = timer;- input.start\_func = startf;- input.expire\_func = timerf;- input.pid = pid;- input.flags = tflags;-- raw\_spin\_lock\_irqsave(lock, flags);- if (!timer\_stats\_active)- goto out\_unlock;-- entry = tstat\_lookup(&input, comm);- if (likely(entry))- entry->count++;- else- atomic\_inc(&overflow\_count);-- out\_unlock:- raw\_spin\_unlock\_irqrestore(lock, flags);-}--static void print\_name\_offset(struct seq\_file \*m, unsigned long addr)-{- char symname[KSYM\_NAME\_LEN];-- if (lookup\_symbol\_name(addr, symname) < 0)- seq\_printf(m, "<%p>", (void \*)addr);- else- seq\_printf(m, "%s", symname);-}--static int tstats\_show(struct seq\_file \*m, void \*v)-{- struct timespec64 period;- struct entry \*entry;- unsigned long ms;- long events = 0;- ktime\_t time;- int i;-- mutex\_lock(&show\_mutex);- /\*- \* If still active then calculate up to now:- \*/- if (timer\_stats\_active)- time\_stop = ktime\_get();-- time = ktime\_sub(time\_stop, time\_start);-- period = ktime\_to\_timespec64(time);- ms = period.tv\_nsec / 1000000;-- seq\_puts(m, "Timer Stats Version: v0.3\n");- seq\_printf(m, "Sample period: %ld.%03ld s\n", (long)period.tv\_sec, ms);- if (atomic\_read(&overflow\_count))- seq\_printf(m, "Overflow: %d entries\n", atomic\_read(&overflow\_count));- seq\_printf(m, "Collection: %s\n", timer\_stats\_active ? "active" : "inactive");-- for (i = 0; i < nr\_entries; i++) {- entry = entries + i;- if (entry->flags & TIMER\_DEFERRABLE) {- seq\_printf(m, "%4luD, %5d %-16s ",- entry->count, entry->pid, entry->comm);- } else {- seq\_printf(m, " %4lu, %5d %-16s ",- entry->count, entry->pid, entry->comm);- }-- print\_name\_offset(m, (unsigned long)entry->start\_func);- seq\_puts(m, " (");- print\_name\_offset(m, (unsigned long)entry->expire\_func);- seq\_puts(m, ")\n");-- events += entry->count;- }-- ms += period.tv\_sec \* 1000;- if (!ms)- ms = 1;-- if (events && period.tv\_sec)- seq\_printf(m, "%ld total events, %ld.%03ld events/sec\n",- events, events \* 1000 / ms,- (events \* 1000000 / ms) % 1000);- else- seq\_printf(m, "%ld total events\n", events);-- mutex\_unlock(&show\_mutex);-- return 0;-}--/\*- \* After a state change, make sure all concurrent lookup/update- \* activities have stopped:- \*/-static void sync\_access(void)-{- unsigned long flags;- int cpu;-- for\_each\_online\_cpu(cpu) {- raw\_spinlock\_t \*lock = &per\_cpu(tstats\_lookup\_lock, cpu);-- raw\_spin\_lock\_irqsave(lock, flags);- /\* nothing \*/- raw\_spin\_unlock\_irqrestore(lock, flags);- }-}--static ssize\_t tstats\_write(struct file \*file, const char \_\_user \*buf,- size\_t count, loff\_t \*offs)-{- char ctl[2];-- if (count != 2 || \*offs)- return -EINVAL;-- if (copy\_from\_user(ctl, buf, count))- return -EFAULT;-- mutex\_lock(&show\_mutex);- switch (ctl[0]) {- case '0':- if (timer\_stats\_active) {- timer\_stats\_active = 0;- time\_stop = ktime\_get();- sync\_access();- }- break;- case '1':- if (!timer\_stats\_active) {- reset\_entries();- time\_start = ktime\_get();- smp\_mb();- timer\_stats\_active = 1;- }- break;- default:- count = -EINVAL;- }- mutex\_unlock(&show\_mutex);-- return count;-}--static int tstats\_open(struct inode \*inode, struct file \*filp)-{- return single\_open(filp, tstats\_show, NULL);-}--static const struct file\_operations tstats\_fops = {- .open = tstats\_open,- .read = seq\_read,- .write = tstats\_write,- .llseek = seq\_lseek,- .release = single\_release,-};--void \_\_init init\_timer\_stats(void)-{- int cpu;-- for\_each\_possible\_cpu(cpu)- raw\_spin\_lock\_init(&per\_cpu(tstats\_lookup\_lock, cpu));-}--static int \_\_init init\_tstats\_procfs(void)-{- struct proc\_dir\_entry \*pe;-- pe = proc\_create("timer\_stats", 0644, NULL, &tstats\_fops);- if (!pe)- return -ENOMEM;- return 0;-}-\_\_initcall(init\_tstats\_procfs);diff --git a/kernel/workqueue.c b/kernel/workqueue.cindex 1d9fb6543a66a2..072cbc9b175dc1 100644--- a/[kernel/workqueue.c](/pub/scm/linux/kernel/git/tip/tip.git/tree/kernel/workqueue.c?id=bb42ca47401010fc02901b5e8f79e40a26f208cb)+++ b/[kernel/workqueue.c](/pub/scm/linux/kernel/git/tip/tip.git/tree/kernel/workqueue.c?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1)@@ -1523,8 +1523,6 @@ static void \_\_queue\_delayed\_work(int cpu, struct workqueue\_struct \*wq, return; } - timer\_stats\_timer\_set\_start\_info(&dwork->timer);- dwork->wq = wq; dwork->cpu = cpu; timer->expires = jiffies + delay;diff --git a/lib/Kconfig.debug b/lib/Kconfig.debugindex eb9e9a7870fa7b..132af338d6dd4a 100644--- a/[lib/Kconfig.debug](/pub/scm/linux/kernel/git/tip/tip.git/tree/lib/Kconfig.debug?id=bb42ca47401010fc02901b5e8f79e40a26f208cb)+++ b/[lib/Kconfig.debug](/pub/scm/linux/kernel/git/tip/tip.git/tree/lib/Kconfig.debug?id=dfb4357da6ddbdf57d583ba64361c9d792b0e0b1)@@ -980,20 +980,6 @@ config DEBUG\_TIMEKEEPING  If unsure, say N. -config TIMER\_STATS- bool "Collect kernel timers statistics"- depends on DEBUG\_KERNEL && PROC\_FS- help- If you say Y here, additional code will be inserted into the- timer routines to collect statistics about kernel timers being- reprogrammed. The statistics can be read from /proc/timer\_stats.- The statistics collection is started by writing 1 to /proc/timer\_stats,- writing 0 stops it. This feature is useful to collect information- about timer usage patterns in kernel and userspace. This feature- is lightweight if enabled in the kernel config but not activated- (it defaults to deactivated on bootup and will only be activated- if some application like powertop activates it explicitly).- config DEBUG\_PREEMPT bool "Debug preemptible kernel" depends on DEBUG\_KERNEL && PREEMPT && TRACE\_IRQFLAGS\_SUPPORT |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-25 21:01:46 +0000


