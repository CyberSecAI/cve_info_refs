```
{
  "CVE-2017-18551": {
    "description": "An issue was discovered in drivers/i2c/i2c-core-smbus.c in the Linux kernel before 4.14.15. There is an out of bounds write in the function i2c_smbus_xfer_emulated.",
    "root_cause": "The i2c_smbus_xfer_emulated function in the Linux kernel does not properly validate the size of the data being read or written when handling I2C_SMBUS_I2C_BLOCK_DATA requests. Specifically, if data->block[0] exceeds I2C_SMBUS_BLOCK_MAX + 1 (33), a write occurs beyond the bounds of the msgbuf1 array.",
    "weaknesses": [
      "Heap-based buffer overflow",
       "Insufficient input validation"
    ],
    "impact": "A local user can trigger a heap-based buffer overflow, leading to a denial of service (system crash) or potentially arbitrary code execution.",
     "attack_vector": "Local access via crafted I2C_SMBUS ioctl calls with an overly large data->block[0] value.",
     "attacker_capabilities": "The attacker needs the ability to make I2C\_SMBUS ioctl calls, this would require local access.",
    "details": "The vulnerability is in the i2c\_smbus\_xfer\_emulated function in drivers/i2c/i2c-core-smbus.c. When handling I2C\_SMBUS\_I2C\_BLOCK\_DATA read requests, the code copies user-supplied data into a local buffer msgbuf1 without checking the size of the data being read, data->block[0]. If data->block[0] is greater than I2C\_SMBUS\_BLOCK\_MAX (32) + 1, the underlying I2C driver would write past the boundary of msgbuf1, corrupting memory. The vulnerability can be triggered from user-space by an attacker able to call the I2C\_SMBUS ioctl with a crafted data structure. The fix introduces a check in the I2C\_SMBUS\_I2C\_BLOCK\_DATA case to ensure that the requested block size does not exceed I2C\_SMBUS\_BLOCK\_MAX, returning -EINVAL in case of a size violation."
  },
  "CVE-2018-20976": {
   "description": "An issue was discovered in fs/xfs/xfs_super.c in the Linux kernel before 4.18. A use after free exists, related to xfs_fs_fill_super failure.",
   "root_cause": "The root cause is a use-after-free vulnerability in the xfs\_fs\_fill\_super function of the Linux Kernel which is called when an XFS filesystem super block is loaded and it encounters an error.",
   "weaknesses": [
       "Use-after-free"
    ],
    "impact": "Local users may be able to cause a denial of service by triggering a use-after-free condition in the kernel.",
    "attack_vector": "Local access. This can be achieved by an unprivileged user that mounts a specially crafted XFS filesystem image that would trigger the flawed codepath.",
     "attacker_capabilities": "Attacker must be able to mount a crafted xfs image, hence local access is required.",
    "details": "The vulnerability occurs in fs/xfs/xfs\_super.c when the function xfs\_fs\_fill\_super encounters an error, the function fails to free resources correctly, resulting in use-after-free. The fix is to ensure resources are freed before exiting"
    },
 "CVE-2018-21008": {
    "description": "An issue was discovered in the Linux kernel before 4.16.7. A use-after-free can be caused by the function rsi_mac80211_detach in the file drivers/net/wireless/rsi/rsi_91x_mac80211.c.",
    "root_cause": "A use-after-free vulnerability exists in the rsi\_mac80211\_detach function within the drivers/net/wireless/rsi/rsi\_91x\_mac80211.c driver. This function fails to properly manage memory when detaching from a device.",
    "weaknesses": [
      "Use-after-free"
    ],
   "impact": "A local user can cause a denial of service by triggering the use-after-free condition which leads to a system crash",
    "attack_vector": "Local access is needed, achieved through device removal or similar actions that trigger the detachment of the driver.",
    "attacker_capabilities": "The attacker needs the ability to cause the rsi device to detach by removing a wireless network device",
   "details":"The vulnerability occurs during the detachment of a device using the rsi\_mac80211\_detach function, which fails to properly handle memory deallocation, leading to a use-after-free condition. The vulnerability is in  drivers/net/wireless/rsi/rsi\_91x\_mac80211.c of the kernel"
  },
   "CVE-2019-14814":{
    "description":"There is heap-based buffer overflow in Linux kernel, all versions up to, excluding 5.3, in the marvell wifi chip driver in Linux kernel, that allows local users to cause a denial of service(system crash) or possibly execute arbitrary code.",
    "root_cause":"The root cause of the vulnerability is a heap buffer overflow that occurs in the mwifiex\_set\_uap\_rates function within the Marvell WiFi driver in the Linux kernel. This function is used when setting up access point mode and a heap overflow can occur when processing the rate parameters.",
    "weaknesses":[
        "Heap-based buffer overflow",
        "Insufficient input validation"
    ],
    "impact":"A local unprivileged user can exploit this vulnerability to cause a denial of service (system crash) or potentially execute arbitrary code.",
    "attack_vector":"Local access is required to configure a wireless interface.",
    "attacker_capabilities":"An attacker with the ability to configure wireless interfaces (such as setting up a hotspot) could trigger the heap overflow. This is usually restricted to local users or system administrators.",
   "details":"The mwifiex\_set\_uap\_rates function in the Marvell Wi-Fi driver (drivers/net/wireless/marvell/mwifiex/ieee80211.c) is responsible for setting the access point's rate configuration. A heap overflow occurs when the rate parameters provided by a user are processed without proper size validation, leading to a write beyond the bounds of allocated memory. The fix involves proper handling of the size parameter before performing any copy/write operation."
  }
}
```