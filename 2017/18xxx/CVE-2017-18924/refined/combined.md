=== Content from github.com_922f62d6_20250124_183241.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Foauthjs%2Fnode-oauth2-server%2Fissues%2F637)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Foauthjs%2Fnode-oauth2-server%2Fissues%2F637)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fissues_fragments%2Fissue_layout&source=header-repo&source_repo=oauthjs%2Fnode-oauth2-server)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[oauthjs](/oauthjs)
/
**[node-oauth2-server](/oauthjs/node-oauth2-server)**
Public

* [Notifications](/login?return_to=%2Foauthjs%2Fnode-oauth2-server) You must be signed in to change notification settings
* [Fork
  931](/login?return_to=%2Foauthjs%2Fnode-oauth2-server)
* [Star
   4k](/login?return_to=%2Foauthjs%2Fnode-oauth2-server)

* [Code](/oauthjs/node-oauth2-server)
* [Issues
  159](/oauthjs/node-oauth2-server/issues)
* [Pull requests
  30](/oauthjs/node-oauth2-server/pulls)
* [Actions](/oauthjs/node-oauth2-server/actions)
* [Projects
  0](/oauthjs/node-oauth2-server/projects)
* [Wiki](/oauthjs/node-oauth2-server/wiki)
* [Security](/oauthjs/node-oauth2-server/security)
* [Insights](/oauthjs/node-oauth2-server/pulse)

Additional navigation options

* [Code](/oauthjs/node-oauth2-server)
* [Issues](/oauthjs/node-oauth2-server/issues)
* [Pull requests](/oauthjs/node-oauth2-server/pulls)
* [Actions](/oauthjs/node-oauth2-server/actions)
* [Projects](/oauthjs/node-oauth2-server/projects)
* [Wiki](/oauthjs/node-oauth2-server/wiki)
* [Security](/oauthjs/node-oauth2-server/security)
* [Insights](/oauthjs/node-oauth2-server/pulse)

# Multiple Security Vulnerabilities in Auth and Token Endpoint #637

[New issue](/login?return_to=)[Jump to bottom](#comment-composer-heading)Copy link[New issue](/login?return_to=)[Jump to bottom](#comment-composer-heading)Copy linkOpen[node-oauth/node-oauth2-server#231](https://github.com/node-oauth/node-oauth2-server/pull/231)node-oauth/node-oauth2-server#231Open[Multiple Security Vulnerabilities in Auth and Token Endpoint](#top)#637[node-oauth/node-oauth2-server#231](https://github.com/node-oauth/node-oauth2-server/pull/231)Copy linkLabels[under-review](https://github.com/oauthjs/node-oauth2-server/issues?q=state%3Aopen%20label%3A%22under-review%22)[![@tamjidrahat](https://avatars.githubusercontent.com/u/1904950?u=dd9c601d7c5cbb482658095ae9ad5c47b04e0b06&v=4&size=80)](/tamjidrahat)
## Description

[![@tamjidrahat](https://avatars.githubusercontent.com/u/1904950?u=dd9c601d7c5cbb482658095ae9ad5c47b04e0b06&v=4&size=48)](/tamjidrahat)[tamjidrahat](https://github.com/tamjidrahat)opened [on Jul 16, 2020](https://github.com/oauthjs/node-oauth2-server/issues/637#issue-657747248)

I would like to report several security vulnerabilities that I found while using this OAuth server library.

The vulnerabilities and their consequences are listed as following:

**Vulnerability 1:** Missing PKCE support for public clients.

***Consequences:*** As specified in RFC-7636 (<https://tools.ietf.org/html/rfc7636>), public clients (e.g., mobile/desktop apps) using Authorization Code Flow are susceptible to authorization code interception attack and PKCE is recommended to mitigate this attack. Since public clients cannot maintain client-side confidentiality regarding client secrets, such attacks have been noticed in the wild extensively.

**Vulnerability 2:** Does not revoke previously issued token if authorization\_code is used more than once.

***Consequences:*** As specified in RFC-6749 (<https://tools.ietf.org/html/rfc6749#section-4.1.2>), If an authorization code is used more than once, the authorization server must deny the request and should revoke all tokens previously issued based on that authorization code. Though OAuth2-server currently denies the request in such cases, it doesn't revoke the tokens issued previously to the client, which leaves the user's resources vulnerable as attackers might exploit the previous tokens to get them.

**Vulnerability 3:** Allows fragment in the redirect URI.

***Consequences:*** Many OAuth attacks regarding misuse of redirect uris have been observed in the wild. As specified in the RFC-6749 (<https://tools.ietf.org/html/rfc6749#section-3.1.2>), authorization server should not allow fragments in the redirect uri as it allows the attackers to exploit the redirect uri and hence intercept the auth\_code/token.

Any comments or fixes regarding these vulnerabilities?

Thank you.

## Metadata

### Assignees

No one assigned

### Labels

[under-review](https://github.com/oauthjs/node-oauth2-server/issues?q=state%3Aopen%20label%3A%22under-review%22)
### Type

No type
### Projects

No projects
### Milestone

No milestone

### Relationships

None yet
### Development

No branches or pull requests
## Issue actions

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from tools.ietf.org_a5373dc6_20250124_183246.html ===


* Light
* Dark
* Auto

[RFC 7636

Proposed Standard](/doc/rfc7636/)

|  | Title |  | Proof Key for Code Exchange by OAuth Public Clients |
| --- | --- | --- | --- |
| Document | Document type |  | RFC - Proposed Standard  September 2015  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=7636 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") Was [draft-ietf-oauth-spop](/doc/draft-ietf-oauth-spop/15/) ([oauth WG](/wg/oauth/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [00](/doc/html/draft-ietf-oauth-spop-00) * [01](/doc/html/draft-ietf-oauth-spop-01) * [02](/doc/html/draft-ietf-oauth-spop-02) * [03](/doc/html/draft-ietf-oauth-spop-03) * [04](/doc/html/draft-ietf-oauth-spop-04) * [05](/doc/html/draft-ietf-oauth-spop-05) * [06](/doc/html/draft-ietf-oauth-spop-06) * [07](/doc/html/draft-ietf-oauth-spop-07) * [08](/doc/html/draft-ietf-oauth-spop-08) * [09](/doc/html/draft-ietf-oauth-spop-09) * [10](/doc/html/draft-ietf-oauth-spop-10) * [11](/doc/html/draft-ietf-oauth-spop-11) * [12](/doc/html/draft-ietf-oauth-spop-12) * [13](/doc/html/draft-ietf-oauth-spop-13) * [14](/doc/html/draft-ietf-oauth-spop-14) * [15](/doc/html/draft-ietf-oauth-spop-15) * [RFC 7636](/doc/html/rfc7636) |
|  | Compare versions |  | RFC 7636  draft-ietf-oauth-spop-15  draft-ietf-oauth-spop-14  draft-ietf-oauth-spop-13  draft-ietf-oauth-spop-12  draft-ietf-oauth-spop-11  draft-ietf-oauth-spop-10  draft-ietf-oauth-spop-09  draft-ietf-oauth-spop-08  draft-ietf-oauth-spop-07  draft-ietf-oauth-spop-06  draft-ietf-oauth-spop-05  draft-ietf-oauth-spop-04  draft-ietf-oauth-spop-03  draft-ietf-oauth-spop-02  draft-ietf-oauth-spop-01  draft-ietf-oauth-spop-00   RFC 7636  draft-ietf-oauth-spop-15  draft-ietf-oauth-spop-14  draft-ietf-oauth-spop-13  draft-ietf-oauth-spop-12  draft-ietf-oauth-spop-11  draft-ietf-oauth-spop-10  draft-ietf-oauth-spop-09  draft-ietf-oauth-spop-08  draft-ietf-oauth-spop-07  draft-ietf-oauth-spop-06  draft-ietf-oauth-spop-05  draft-ietf-oauth-spop-04  draft-ietf-oauth-spop-03  draft-ietf-oauth-spop-02  draft-ietf-oauth-spop-01  draft-ietf-oauth-spop-00   Side-by-side  Inline |
|  | Authors |  | [Nat Sakimura](/person/nat%40nat.consulting "Datatracker profile of Nat Sakimura") , [John Bradley](/person/ve7jtb%40ve7jtb.com "Datatracker profile of John Bradley") , [Naveen Agarwal](/person/naa%40google.com "Datatracker profile of Naveen Agarwal")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc7636.txt) [html](https://www.rfc-editor.org/rfc/rfc7636.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc7636.txt.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc7636.html) [bibtex](/doc/rfc7636/bibtex/) |
|  | Additional resources |  | [Mailing list discussion](https://mailarchive.ietf.org/arch/browse/oauth/?q=rfc7636 OR %22draft-ietf-oauth-spop%22) |
|  |  |  | [Report a bug](https://github.com/ietf-tools/datatracker/issues/new/choose) |

```
Internet Engineering Task Force (IETF)                  N. Sakimura, Ed.
Request for Comments: 7636                     Nomura Research Institute
Category: Standards Track                                     J. Bradley
ISSN: 2070-1721                                            Ping Identity
                                                              N. Agarwal
                                                                  Google
                                                          September 2015

          Proof Key for Code Exchange by OAuth Public Clients

Abstract

   OAuth 2.0 public clients utilizing the Authorization Code Grant are
   susceptible to the authorization code interception attack.  This
   specification describes the attack as well as a technique to mitigate
   against the threat through the use of Proof Key for Code Exchange
   (PKCE, pronounced "pixy").

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in [Section 2 of RFC 5741](/doc/html/rfc5741#section-2).

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <http://www.rfc-editor.org/info/rfc7636>.

Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to [BCP 78](/doc/html/bcp78) and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<http://trustee.ietf.org/license-info>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Sakimura, et al.             Standards Track                    [Page 1]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

Table of Contents

   [1](#section-1). Introduction ....................................................[3](#page-3)
      [1.1](#section-1.1). Protocol Flow ..............................................[5](#page-5)
   [2](#section-2). Notational Conventions ..........................................[6](#page-6)
   [3](#section-3). Terminology .....................................................[7](#page-7)
      [3.1](#section-3.1). Abbreviations ..............................................[7](#page-7)
   [4](#section-4). Protocol ........................................................[8](#page-8)
      [4.1](#section-4.1). Client Creates a Code Verifier .............................[8](#page-8)
      [4.2](#section-4.2). Client Creates the Code Challenge ..........................[8](#page-8)
      4.3. Client Sends the Code Challenge with the
           Authorization Request ......................................[9](#page-9)
      [4.4](#section-4.4). Server Returns the Code ....................................[9](#page-9)
           [4.4.1](#section-4.4.1). Error Response ......................................[9](#page-9)
      4.5. Client Sends the Authorization Code and the Code
           Verifier to the Token Endpoint ............................[10](#page-10)
      4.6. Server Verifies code_verifier before Returning the
           Tokens ....................................................[10](#page-10)
   [5](#section-5). Compatibility ..................................................[11](#page-11)
   [6](#section-6). IANA Considerations ............................................[11](#page-11)
      [6.1](#section-6.1). OAuth Parameters Registry .................................[11](#page-11)
      [6.2](#section-6.2). PKCE Code Challenge Method Registry .......................[11](#page-11)
           [6.2.1](#section-6.2.1). Registration Template ..............................[12](#page-12)
           [6.2.2](#section-6.2.2). Initial Registry Contents ..........................[13](#page-13)
   [7](#section-7). Security Considerations ........................................[13](#page-13)
      [7.1](#section-7.1). Entropy of the code_verifier ..............................[13](#page-13)
      [7.2](#section-7.2). Protection against Eavesdroppers ..........................[13](#page-13)
      [7.3](#section-7.3). Salting the code_challenge ................................[14](#page-14)
      [7.4](#section-7.4). OAuth Security Considerations .............................[14](#page-14)
      [7.5](#section-7.5). TLS Security Considerations ...............................[15](#page-15)
   [8](#section-8). References .....................................................[15](#page-15)
      [8.1](#section-8.1). Normative References ......................................[15](#page-15)
      [8.2](#section-8.2). Informative References ....................................[16](#page-16)
   [Appendix A](#appendix-A).  Notes on Implementing Base64url Encoding without
                Padding  .............................................[17](#page-17)
   [Appendix B](#appendix-B).  Example for the S256 code_challenge_method ...........[17](#page-17)
   Acknowledgements ..................................................[19](#page-19)
   Authors' Addresses ................................................[20](#page-20)

Sakimura, et al.             Standards Track                    [Page 2]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

[1](#section-1).  Introduction

   OAuth 2.0 [[RFC6749](/doc/html/rfc6749 "\"The OAuth 2.0 Authorization Framework\"")] public clients are susceptible to the
   authorization code interception attack.

   In this attack, the attacker intercepts the authorization code
   returned from the authorization endpoint within a communication path
   not protected by Transport Layer Security (TLS), such as inter-
   application communication within the client's operating system.

   Once the attacker has gained access to the authorization code, it can
   use it to obtain the access token.

   Figure 1 shows the attack graphically.  In step (1), the native
   application running on the end device, such as a smartphone, issues
   an OAuth 2.0 Authorization Request via the browser/operating system.
   The Redirection Endpoint URI in this case typically uses a custom URI
   scheme.  Step (1) happens through a secure API that cannot be
   intercepted, though it may potentially be observed in advanced attack
   scenarios.  The request then gets forwarded to the OAuth 2.0
   authorization server in step (2).  Because OAuth requires the use of
   TLS, this communication is protected by TLS and cannot be
   intercepted.  The authorization server returns the authorization code
   in step (3).  In step (4), the Authorization Code is returned to the
   requester via the Redirection Endpoint URI that was provided in step
   (1).

   Note that it is possible for a malicious app to register itself as a
   handler for the custom scheme in addition to the legitimate OAuth 2.0
   app.  Once it does so, the malicious app is now able to intercept the
   authorization code in step (4).  This allows the attacker to request
   and obtain an access token in steps (5) and (6), respectively.

Sakimura, et al.             Standards Track                    [Page 3]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

    +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
    | End Device (e.g., Smartphone)  |
    |                                |
    | +-------------+   +----------+ | (6) Access Token  +----------+
    | |Legitimate   |   | Malicious|<--------------------|          |
    | |OAuth 2.0 App|   | App      |-------------------->|          |
    | +-------------+   +----------+ | (5) Authorization |          |
    |        |    ^          ^       |        Grant      |          |
    |        |     \         |       |                   |          |
    |        |      \   (4)  |       |                   |          |
    |    (1) |       \  Authz|       |                   |          |
    |   Authz|        \ Code |       |                   |  Authz   |
    | Request|         \     |       |                   |  Server  |
    |        |          \    |       |                   |          |
    |        |           \   |       |                   |          |
    |        v            \  |       |                   |          |
    | +----------------------------+ |                   |          |
    | |                            | | (3) Authz Code    |          |
    | |     Operating System/      |<--------------------|          |
    | |         Browser            |-------------------->|          |
    | |                            | | (2) Authz Request |          |
    | +----------------------------+ |                   +----------+
    +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+

             Figure 1: Authorization Code Interception Attack

   A number of pre-conditions need to hold for this attack to work:

   1. The attacker manages to register a malicious application on the
      client device and registers a custom URI scheme that is also used
      by another application.  The operating systems must allow a custom
      URI scheme to be registered by multiple applications.

   2. The OAuth 2.0 authorization code grant is used.

   3. The attacker has access to the OAuth 2.0 [[RFC6749](/doc/html/rfc6749 "\"The OAuth 2.0 Authorization Framework\"")] "client_id" and
      "client_secret" (if provisioned).  All OAuth 2.0 native app
      client-instances use the same "client_id".  Secrets provisioned in
      client binary applications cannot be considered confidential.

   4. Either one of the following condition is met:

      4a. The attacker (via the installed application) is able to
          observe only the responses from the authorization endpoint.
          When "code_challenge_method" value is "plain", only this
          attack is mitigated.

Sakimura, et al.             Standards Track                    [Page 4]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

      4b. A more sophisticated attack scenario allows the attacker to
          observe requests (in addition to responses) to the
          authorization endpoint.  The attacker is, however, not able to
          act as a man in the middle.  This was caused by leaking http
          log information in the OS.  To mitigate this,
          "code_challenge_method" value must be set either to "S256" or
          a value defined by a cryptographically secure
          "code_challenge_method" extension.

   While this is a long list of pre-conditions, the described attack has
   been observed in the wild and has to be considered in OAuth 2.0
   deployments.  While the OAuth 2.0 threat model ([Section 4.4.1 of
   [RFC6819]](/doc/html/rfc6819#section-4.4.1)) describes mitigation techniques, they are, unfortunately,
   not applicable since they rely on a per-client instance secret or a
   per-client instance redirect URI.

   To mitigate this attack, this extension utilizes a dynamically
   created cryptographically random key called "code verifier".  A
   unique code verifier is created for every authorization request, and
   its transformed value, called "code challenge", is sent to the
   authorization server to obtain the authorization code.  The
   authorization code obtained is then sent to the token endpoint with
   the "code verifier", and the server compares it with the previously
   received request code so that it can perform the proof of possession
   of the "code verifier" by the client.  This works as the mitigation
   since the attacker would not know this one-time key, since it is sent
   over TLS and cannot be intercepted.

[1.1](#section-1.1).  Protocol Flow

                                                 +-------------------+
                                                 |   Authz Server    |
       +--------+                                | +---------------+ |
       |        |--(A)- Authorization Request ---->|               | |
       |        |       + t(code_verifier), t_m  | | Authorization | |
       |        |                                | |    Endpoint   | |
       |        |<-(B)---- Authorization Code -----|               | |
       |        |                                | +---------------+ |
       | Client |                                |                   |
       |        |                                | +---------------+ |
       |        |--(C)-- Access Token Request ---->|               | |
       |        |          + code_verifier       | |    Token      | |
       |        |                                | |   Endpoint    | |
       |        |<-(D)------ Access Token ---------|               | |
       +--------+                                | +---------------+ |
                                                 +-------------------+

                     Figure 2: Abstract Protocol Flow

Sakimura, et al.             Standards Track                    [Page 5]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

   This specification adds additional parameters to the OAuth 2.0
   Authorization and Access Token Requests, shown in abstract form in
   Figure 2.

   A. The client creates and records a secret named the "code_verifier"
      and derives a transformed version "t(code_verifier)" (referred to
      as the "code_challenge"), which is sent in the OAuth 2.0
      Authorization Request along with the transformation method "t_m".

   B. The Authorization Endpoint responds as usual but records
      "t(code_verifier)" and the transformation method.

   C. The client then sends the authorization code in the Access Token
      Request as usual but includes the "code_verifier" secret generated
      at (A).

   D. The authorization server transforms "code_verifier" and compares
      it to "t(code_verifier)" from (B).  Access is denied if they are
      not equal.

   An attacker who intercepts the authorization code at (B) is unable to
   redeem it for an access token, as they are not in possession of the
   "code_verifier" secret.

[2](#section-2).  Notational Conventions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   "Key words for use in RFCs to Indicate Requirement Levels" [[RFC2119](/doc/html/rfc2119 "\"Key words for use in RFCs to Indicate Requirement Levels\"")].
   If these words are used without being spelled in uppercase, then they
   are to be interpreted with their natural language meanings.

   This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [[RFC5234](/doc/html/rfc5234 "\"Augmented BNF for Syntax Specifications: ABNF\"")].

   STRING denotes a sequence of zero or more ASCII [[RFC20](/doc/html/rfc20 "\"ASCII format for network interchange\"")] characters.

   OCTETS denotes a sequence of zero or more octets.

   ASCII(STRING) denotes the octets of the ASCII [[RFC20](/doc/html/rfc20 "\"ASCII format for network interchange\"")] representation
   of STRING where STRING is a sequence of zero or more ASCII
   characters.

   BASE64URL-ENCODE(OCTETS) denotes the base64url encoding of OCTETS,
   per [Appendix A](#appendix-A), producing a STRING.

Sakimura, et al.             Standards Track                    [Page 6]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

   BASE64URL-DECODE(STRING) denotes the base64url decoding of STRING,
   per [Appendix A](#appendix-A), producing a sequence of octets.

   SHA256(OCTETS) denotes a SHA2 256-bit hash [[RFC6234](/doc/html/rfc6234 "\"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\"")] of OCTETS.

[3](#section-3).  Terminology

   In addition to the terms defined in OAuth 2.0 [[RFC6749](/doc/html/rfc6749 "\"The OAuth 2.0 Authorization Framework\"")], this
   specification defines the following terms:

   code verifier
      A cryptographically random string that is used to correlate the
      authorization request to the token request.

   code challenge
      A challenge derived from the code verifier that is sent in the
      authorization request, to be verified against later.

   code challenge method
      A method that was used to derive code challenge.

   Base64url Encoding
      Base64 encoding using the URL- and filename-safe character set
      defined in [Section 5 of [RFC4648]](/doc/html/rfc4648#section-5), with all trailing '='
      characters omitted (as permitted by [Section 3.2 of [RFC4648]](/doc/html/rfc4648#section-3.2)) and
      without the inclusion of any line breaks, whitespace, or other
      additional characters.  (See [Appendix A](#appendix-A) for notes on implementing
      base64url encoding without padding.)

[3.1](#section-3.1).  Abbreviations

   ABNF   Augmented Backus-Naur Form

   Authz  Authorization

   PKCE   Proof Key for Code Exchange

   MITM   Man-in-the-middle

   MTI    Mandatory To Implement

Sakimura, et al.             Standards Track                    [Page 7]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

[4](#section-4).  Protocol

[4.1](#section-4.1).  Client Creates a Code Verifier

   The client first creates a code verifier, "code_verifier", for each
   OAuth 2.0 [[RFC6749](/doc/html/rfc6749 "\"The OAuth 2.0 Authorization Framework\"")] Authorization Request, in the following manner:

   code_verifier = high-entropy cryptographic random STRING using the
   unreserved characters [A-Z] / [a-z] / [0-9] / "-" / "." / "_" / "~"
   from [Section 2.3 of [RFC3986]](/doc/html/rfc3986#section-2.3), with a minimum length of 43 characters
   and a maximum length of 128 characters.

   ABNF for "code_verifier" is as follows.

   code-verifier = 43*128unreserved
   unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
   ALPHA = %x41-5A / %x61-7A
   DIGIT = %x30-39

   NOTE: The code verifier SHOULD have enough entropy to make it
   impractical to guess the value.  It is RECOMMENDED that the output of
   a suitable random number generator be used to create a 32-octet
   sequence.  The octet sequence is then base64url-encoded to produce a
   43-octet URL safe string to use as the code verifier.

[4.2](#section-4.2).  Client Creates the Code Challenge

   The client then creates a code challenge derived from the code
   verifier by using one of the following transformations on the code
   verifier:

   plain
      code_challenge = code_verifier

   S256
      code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))

   If the client is capable of using "S256", it MUST use "S256", as
   "S256" is Mandatory To Implement (MTI) on the server.  Clients are
   permitted to use "plain" only if they cannot support "S256" for some
   technical reason and know via out-of-band configuration that the
   server supports "plain".

   The plain transformation is for compatibility with existing
   deployments and for constrained environments that can't use the S256
   transformation.

Sakimura, et al.             Standards Track                    [Page 8]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

   ABNF for "code_challenge" is as follows.

   code-challenge = 43*128unreserved
   unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
   ALPHA = %x41-5A / %x61-7A
   DIGIT = %x30-39

[4.3](#section-4.3).  Client Sends the Code Challenge with the Authorization Request

   The client sends the code challenge as part of the OAuth 2.0
   Authorization Request ([Section 4.1.1 of [RFC6749]](/doc/html/rfc6749#section-4.1.1)) using the
   following additional parameters:

   code_challenge
      REQUIRED.  Code challenge.

   code_challenge_method
      OPTIONAL, defaults to "plain" if not present in the request.  Code
      verifier transformation method is "S256" or "plain".

[4.4](#section-4.4).  Server Returns the Code

   When the server issues the authorization code in the authorization
   response, it MUST associate the "code_challenge" and
   "code_challenge_method" values with the authorization code so it can
   be verified later.

   Typically, the "code_challenge" and "code_challenge_method" values
   are stored in encrypted form in the "code" itself but could
   alternatively be stored on the server associated with the code.  The
   server MUST NOT include the "code_challenge" value in client requests
   in a form that other entities can extract.

   The exact method that the server uses to associate the
   "code_challenge" with the issued "code" is out of scope for this
   specification.

[4.4.1](#section-4.4.1).  Error Response

   If the server requires Proof Key for Code Exchange (PKCE) by OAuth
   public clients and the client does not send the "code_challenge" in
   the request, the authorization endpoint MUST return the authorization
   error response with the "error" value set to "invalid_request".  The
   "error_description" or the response of "error_uri" SHOULD explain the
   nature of error, e.g., code challenge required.

Sakimura, et al.             Standards Track                    [Page 9]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

   If the server supporting PKCE does not support the requested
   transformation, the authorization endpoint MUST return the
   authorization error response with "error" value set to
   "invalid_request".  The "error_description" or the response of
   "error_uri" SHOULD explain the nature of error, e.g., transform
   algorithm not supported.

[4.5](#section-4.5).  Client Sends the Authorization Code and the Code Verifier to the
      Token Endpoint

   Upon receipt of the Authorization Code, the client sends the Access
   Token Request to the token endpoint.  In addition to the parameters
   defined in the OAuth 2.0 Access Token Request ([Section 4.1.3 of
   [RFC6749]](/doc/html/rfc6749#section-4.1.3)), it sends the following parameter:

   code_verifier
      REQUIRED.  Code verifier

   The "code_challenge_method" is bound to the Authorization Code when
   the Authorization Code is issued.  That is the method that the token
   endpoint MUST use to verify the "code_verifier".

[4.6](#section-4.6).  Server Verifies code_verifier before Returning the Tokens

   Upon receipt of the request at the token endpoint, the server
   verifies it by calculating the code challenge from the received
   "code_verifier" and comparing it with the previously associated
   "code_challenge", after first transforming it according to the
   "code_challenge_method" method specified by the client.

   If the "code_challenge_method" from [Section 4.3](#section-4.3) was "S256", the
   received "code_verifier" is hashed by SHA-256, base64url-encoded, and
   then compared to the "code_challenge", i.e.:

   BASE64URL-ENCODE(SHA256(ASCII(code_verifier))) == code_challenge

   If the "code_challenge_method" from [Section 4.3](#section-4.3) was "plain", they are
   compared directly, i.e.:

   code_verifier == code_challenge.

   If the values are equal, the token endpoint MUST continue processing
   as normal (as defined by OAuth 2.0 [[RFC6749](/doc/html/rfc6749 "\"The OAuth 2.0 Authorization Framework\"")]).  If the values are not
   equal, an error response indicating "invalid_grant" as described in
   [Section 5.2 of [RFC6749]](/doc/html/rfc6749#section-5.2) MUST be returned.

Sakimura, et al.             Standards Track                   [Page 10]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

[5](#section-5).  Compatibility

   Server implementations of this specification MAY accept OAuth2.0
   clients that do not implement this extension.  If the "code_verifier"
   is not received from the client in the Authorization Request, servers
   supporting backwards compatibility revert to the OAuth 2.0 [[RFC6749](/doc/html/rfc6749 "\"The OAuth 2.0 Authorization Framework\"")]
   protocol without this extension.

   As the OAuth 2.0 [[RFC6749](/doc/html/rfc6749 "\"The OAuth 2.0 Authorization Framework\"")] server responses are unchanged by this
   specification, client implementations of this specification do not
   need to know if the server has implemented this specification or not
   and SHOULD send the additional parameters as defined in [Section 4](#section-4) to
   all servers.

[6](#section-6).  IANA Considerations

   IANA has made the following registrations per this document.

[6.1](#section-6.1).  OAuth Parameters Registry

   This specification registers the following parameters in the IANA
   "OAuth Parameters" registry defined in OAuth 2.0 [[RFC6749](/doc/html/rfc6749 "\"The OAuth 2.0 Authorization Framework\"")].

   o  Parameter name: code_verifier
   o  Parameter usage location: token request
   o  Change controller: IESG
   o  Specification document(s): [RFC 7636](/doc/html/rfc7636) (this document)

   o  Parameter name: code_challenge
   o  Parameter usage location: authorization request
   o  Change controller: IESG
   o  Specification document(s): [RFC 7636](/doc/html/rfc7636) (this document)

   o  Parameter name: code_challenge_method
   o  Parameter usage location: authorization request
   o  Change controller: IESG
   o  Specification document(s): [RFC 7636](/doc/html/rfc7636) (this document)

[6.2](#section-6.2).  PKCE Code Challenge Method Registry

   This specification establishes the "PKCE Code Challenge Methods"
   registry.  The new registry should be a sub-registry of the "OAuth
   Parameters" registry.

   Additional "code_challenge_method" types for use with the
   authorization endpoint are registered using the Specification
   Required policy [[RFC5226](/doc/html/rfc5226)], which includes review of the request by
   one or more Designated Experts (DEs).  The DEs will ensure that there

Sakimura, et al.             Standards Track                   [Page 11]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

   is at least a two-week review of the request on the oauth-ext-
   review@ietf.org mailing list and that any discussion on that list
   converges before they respond to the request.  To allow for the
   allocation of values prior to publication, the Designated Expert(s)
   may approve registration once they are satisfied that an acceptable
   specification will be published.

   Registration requests and discussion on the oauth-ext-review@ietf.org
   mailing list should use an appropriate subject, such as "Request for
   PKCE code_challenge_method: example").

   The Designated Expert(s) should consider the discussion on the
   mailing list, as well as the overall security properties of the
   challenge method when evaluating registration requests.  New methods
   should not disclose the value of the code_verifier in the request to
   the Authorization endpoint.  Denials should include an explanation
   and, if applicable, suggestions as to how to make the request
   successful.

[6.2.1](#section-6.2.1).  Registration Template

   Code Challenge Method Parameter Name:
      The name requested (e.g., "example").  Because a core goal of this
      specification is for the resulting representations to be compact,
      it is RECOMMENDED that the name be short -- not to exceed 8
      characters without a compelling reason to do so.  This name is
      case-sensitive.  Names may not match other registered names in a
      case-insensitive manner unless the Designated Expert(s) states
      that there is a compelling reason to allow an exception in this
      particular case.

   Change Controller:
      For Standards Track RFCs, state "IESG".  For others, give the name
      of the responsible party.  Other details (e.g., postal address,
      email address, and home page URI) may also be included.

   Specification Document(s):
      Reference to the document(s) that specifies the parameter,
      preferably including URI(s) that can be used to retrieve copies of
      the document(s).  An indication of the relevant sections may also
      be included but is not required.

Sakimura, et al.             Standards Track                   [Page 12]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

[6.2.2](#section-6.2.2).  Initial Registry Contents

   Per this document, IANA has registered the Code Challenge Method
   Parameter Names defined in [Section 4.2](#section-4.2) in this registry.

   o  Code Challenge Method Parameter Name: plain
   o  Change Controller: IESG
   o  Specification Document(s): [Section 4.2 of RFC 7636](/doc/html/rfc7636#section-4.2) (this document)

   o  Code Challenge Method Parameter Name: S256
   o  Change Controller: IESG
   o  Specification Document(s): [Section 4.2 of RFC 7636](/doc/html/rfc7636#section-4.2) (this document)

[7](#section-7).  Security Considerations

[7.1](#section-7.1).  Entropy of the code_verifier

   The security model relies on the fact that the code verifier is not
   learned or guessed by the attacker.  It is vitally important to
   adhere to this principle.  As such, the code verifier has to be
   created in such a manner that it is cryptographically random and has
   high entropy that it is not practical for the attacker to guess.

   The client SHOULD create a "code_verifier" with a minimum of 256 bits
   of entropy.  This can be done by having a suitable random number
   generator create a 32-octet sequence.  The octet sequence can then be
   base64url-encoded to produce a 43-octet URL safe string to use as a
   "code_challenge" that has the required entropy.

[7.2](#section-7.2).  Protection against Eavesdroppers

   Clients MUST NOT downgrade to "plain" after trying the "S256" method.
   Servers that support PKCE are required to support "S256", and servers
   that do not support PKCE will simply ignore the unknown
   "code_verifier".  Because of this, an error when "S256" is presented
   can only mean that the server is faulty or that a MITM attacker is
   trying a downgrade attack.

   The "S256" method protects against eavesdroppers observing or
   intercepting the "code_challenge", because the challenge cannot be
   used without the verifier.  With the "plain" method, there is a
   chance that "code_challenge" will be observed by the attacker on the
   device or in the http request.  Since the code challenge is the same
   as the code verifier in this case, the "plain" method does not
   protect against the eavesdropping of the initial request.

   The use of "S256" protects against disclosure of the "code_verifier"
   value to an attacker.

Sakimura, et al.             Standards Track                   [Page 13]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

   Because of this, "plain" SHOULD NOT be used and exists only for
   compatibility with deployed implementations where the request path is
   already protected.  The "plain" method SHOULD NOT be used in new
   implementations, unless they cannot support "S256" for some technical
   reason.

   The "S256" code challenge method or other cryptographically secure
   code challenge method extension SHOULD be used.  The "plain" code
   challenge method relies on the operating system and transport
   security not to disclose the request to an attacker.

   If the code challenge method is "plain" and the code challenge is to
   be returned inside authorization "code" to achieve a stateless
   server, it MUST be encrypted in such a manner that only the server
   can decrypt and extract it.

[7.3](#section-7.3).  Salting the code_challenge

   To reduce implementation complexity, salting is not used in the
   production of the code challenge, as the code verifier contains
   sufficient entropy to prevent brute-force attacks.  Concatenating a
   publicly known value to a code verifier (containing 256 bits of
   entropy) and then hashing it with SHA256 to produce a code challenge
   would not increase the number of attempts necessary to brute force a
   valid value for code verifier.

   While the "S256" transformation is like hashing a password, there are
   important differences.  Passwords tend to be relatively low-entropy
   words that can be hashed offline and the hash looked up in a
   dictionary.  By concatenating a unique though public value to each
   password prior to hashing, the dictionary space that an attacker
   needs to search is greatly expanded.

   Modern graphics processors now allow attackers to calculate hashes in
   real time faster than they could be looked up from a disk.  This
   eliminates the value of the salt in increasing the complexity of a
   brute-force attack for even low-entropy passwords.

[7.4](#section-7.4).  OAuth Security Considerations

   All the OAuth security analysis presented in [[RFC6819](/doc/html/rfc6819 "\"OAuth 2.0 Threat Model and Security Considerations\"")] applies, so
   readers SHOULD carefully follow it.

Sakimura, et al.             Standards Track                   [Page 14]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

[7.5](#section-7.5).  TLS Security Considerations

   Current security considerations can be found in "Recommendations for
   Secure Use of Transport Layer Security (TLS) and Datagram Transport
   Layer Security (DTLS)" [[BCP195](#ref-BCP195 "\"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\"")].  This supersedes the TLS version
   recommendations in OAuth 2.0 [[RFC6749](/doc/html/rfc6749 "\"The OAuth 2.0 Authorization Framework\"")].

[8](#section-8).  References

[8.1](#section-8.1).  Normative References

   [BCP195]   Sheffer, Y., Holz, R., and P. Saint-Andre,
              "Recommendations for Secure Use of Transport Layer
              Security (TLS) and Datagram Transport Layer Security
              (DTLS)", [BCP 195](/doc/html/bcp195), [RFC 7525](/doc/html/rfc7525), May 2015,
              <<http://www.rfc-editor.org/info/bcp195>>.

   [RFC20]    Cerf, V., "ASCII format for network interchange", STD 80,
              [RFC 20](/doc/html/rfc20), DOI 10.17487/RFC0020, October 1969,
              <<http://www.rfc-editor.org/info/rfc20>>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", [BCP 14](/doc/html/bcp14), [RFC 2119](/doc/html/rfc2119),
              DOI 10.17487/RFC2119, March 1997,
              <<http://www.rfc-editor.org/info/rfc2119>>.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66, [RFC](/doc/html/rfc3986)
              [3986](/doc/html/rfc3986), DOI 10.17487/RFC3986, January 2005,
              <<http://www.rfc-editor.org/info/rfc3986>>.

   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", [RFC 4648](/doc/html/rfc4648), DOI 10.17487/RFC4648, October 2006,
              <<http://www.rfc-editor.org/info/rfc4648>>.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", [BCP 26](/doc/html/bcp26), [RFC 5226](/doc/html/rfc5226),
              DOI 10.17487/RFC5226, May 2008,
              <<http://www.rfc-editor.org/info/rfc5226>>.

   [RFC5234]  Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, [RFC 5234](/doc/html/rfc5234),
              DOI 10.17487/RFC5234, January 2008,
              <<http://www.rfc-editor.org/info/rfc5234>>.

Sakimura, et al.             Standards Track                   [Page 15]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

   [RFC6234]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", [RFC 6234](/doc/html/rfc6234),
              DOI 10.17487/RFC6234, May 2011,
              <<http://www.rfc-editor.org/info/rfc6234>>.

   [RFC6749]  Hardt, D., Ed., "The OAuth 2.0 Authorization Framework",
              [RFC 6749](/doc/html/rfc6749), DOI 10.17487/RFC6749, October 2012,
              <<http://www.rfc-editor.org/info/rfc6749>>.

[8.2](#section-8.2).  Informative References

   [RFC6819]  Lodderstedt, T., Ed., McGloin, M., and P. Hunt, "OAuth 2.0
              Threat Model and Security Considerations", [RFC 6819](/doc/html/rfc6819),
              DOI 10.17487/RFC6819, January 2013,
              <<http://www.rfc-editor.org/info/rfc6819>>.

Sakimura, et al.             Standards Track                   [Page 16]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

[Appendix A](#appendix-A).  Notes on Implementing Base64url Encoding without Padding

   This appendix describes how to implement a base64url-encoding
   function without padding, based upon the standard base64-encoding
   function that uses padding.

   To be concrete, example C# code implementing these functions is shown
   below.  Similar code could be used in other languages.

     static string base64urlencode(byte [] arg)
     {
       string s = Convert.ToBase64String(arg); // Regular base64 encoder
       s = s.Split('=')[0]; // Remove any trailing '='s
       s = s.Replace('+', '-'); // 62nd char of encoding
       s = s.Replace('/', '_'); // 63rd char of encoding
       return s;
     }

   An example correspondence between unencoded and encoded values
   follows.  The octet sequence below encodes into the string below,
   which when decoded, reproduces the octet sequence.

   3 236 255 224 193

   A-z_4ME

[Appendix B](#appendix-B).  Example for the S256 code_challenge_method

   The client uses output of a suitable random number generator to
   create a 32-octet sequence.  The octets representing the value in
   this example (using JSON array notation) are:

      [116, 24, 223, 180, 151, 153, 224, 37, 79, 250, 96, 125, 216, 173,
      187, 186, 22, 212, 37, 77, 105, 214, 191, 240, 91, 88, 5, 88, 83,
      132, 141, 121]

   Encoding this octet sequence as base64url provides the value of the
   code_verifier:

       dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk

   The code_verifier is then hashed via the SHA256 hash function to
   produce:

     [19, 211, 30, 150, 26, 26, 216, 236, 47, 22, 177, 12, 76, 152, 46,
      8, 118, 168, 120, 173, 109, 241, 68, 86, 110, 225, 137, 74, 203,
      112, 249, 195]

Sakimura, et al.             Standards Track                   [Page 17]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

   Encoding this octet sequence as base64url provides the value of the
   code_challenge:

       E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM

   The authorization request includes:

       code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM
       &code_challenge_method=S256

   The authorization server then records the code_challenge and
   code_challenge_method along with the code that is granted to the
   client.

   In the request to the token_endpoint, the client includes the code
   received in the authorization response as well as the additional
   parameter:

       code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk

   The authorization server retrieves the information for the code
   grant.  Based on the recorded code_challenge_method being S256, it
   then hashes and base64url-encodes the value of code_verifier:

   BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))

   The calculated value is then compared with the value of
   "code_challenge":

   BASE64URL-ENCODE(SHA256(ASCII(code_verifier))) == code_challenge

   If the two values are equal, then the authorization server can
   provide the tokens as long as there are no other errors in the
   request.  If the values are not equal, then the request must be
   rejected, and an error returned.

Sakimura, et al.             Standards Track                   [Page 18]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

Acknowledgements

   The initial draft version of this specification was created by the
   OpenID AB/Connect Working Group of the OpenID Foundation.

   This specification is the work of the OAuth Working Group, which
   includes dozens of active and dedicated participants.  In particular,
   the following individuals contributed ideas, feedback, and wording
   that shaped and formed the final specification:

      Anthony Nadalin, Microsoft
      Axel Nenker, Deutsche Telekom
      Breno de Medeiros, Google
      Brian Campbell, Ping Identity
      Chuck Mortimore, Salesforce
      Dirk Balfanz, Google
      Eduardo Gueiros, Jive Communications
      Hannes Tschonfenig, ARM
      James Manger, Telstra
      Justin Richer, MIT Kerberos
      Josh Mandel, Boston Children's Hospital
      Lewis Adam, Motorola Solutions
      Madjid Nakhjiri, Samsung
      Michael B. Jones, Microsoft
      Paul Madsen, Ping Identity
      Phil Hunt, Oracle
      Prateek Mishra, Oracle
      Ryo Ito, mixi
      Scott Tomilson, Ping Identity
      Sergey Beryozkin
      Takamichi Saito
      Torsten Lodderstedt, Deutsche Telekom
      William Denniss, Google

Sakimura, et al.             Standards Track                   [Page 19]
```

---

```

[RFC 7636](/doc/html/rfc7636)                       OAUTH PKCE                 September 2015

Authors' Addresses

   Nat Sakimura (editor)
   Nomura Research Institute
   1-6-5 Marunouchi, Marunouchi Kitaguchi Bldg.
   Chiyoda-ku, Tokyo  100-0005
   Japan

   Phone: +81-3-5533-2111
   Email: n-sakimura@nri.co.jp
   URI:   <http://nat.sakimura.org/>

   John Bradley
   Ping Identity
   Casilla 177, Sucursal Talagante
   Talagante, RM
   Chile

   Phone: +44 20 8133 3718
   Email: ve7jtb@ve7jtb.com
   URI:   <http://www.thread-safe.com/>

   Naveen Agarwal
   Google
   1600 Amphitheatre Parkway
   Mountain View, CA  94043
   United States

   Phone: +1 650-253-0000
   Email: naa@google.com
   URI:   [http://google.com/](https://google.com/)

Sakimura, et al.             Standards Track                   [Page 20]

```

[Datatracker](/doc/rfc7636/)

RFC 7636

RFC
- Proposed Standard

* Info
* Contents
* Prefs

| Document | Document type |  | RFC - Proposed Standard  September 2015  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=7636 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") Was [draft-ietf-oauth-spop](/doc/draft-ietf-oauth-spop/15/) ([oauth WG](/wg/oauth/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [00](/doc/html/draft-ietf-oauth-spop-00) * [01](/doc/html/draft-ietf-oauth-spop-01) * [02](/doc/html/draft-ietf-oauth-spop-02) * [03](/doc/html/draft-ietf-oauth-spop-03) * [04](/doc/html/draft-ietf-oauth-spop-04) * [05](/doc/html/draft-ietf-oauth-spop-05) * [06](/doc/html/draft-ietf-oauth-spop-06) * [07](/doc/html/draft-ietf-oauth-spop-07) * [08](/doc/html/draft-ietf-oauth-spop-08) * [09](/doc/html/draft-ietf-oauth-spop-09) * [10](/doc/html/draft-ietf-oauth-spop-10) * [11](/doc/html/draft-ietf-oauth-spop-11) * [12](/doc/html/draft-ietf-oauth-spop-12) * [13](/doc/html/draft-ietf-oauth-spop-13) * [14](/doc/html/draft-ietf-oauth-spop-14) * [15](/doc/html/draft-ietf-oauth-spop-15) * [RFC 7636](/doc/html/rfc7636) |
|  | Compare versions |  | RFC 7636  draft-ietf-oauth-spop-15  draft-ietf-oauth-spop-14  draft-ietf-oauth-spop-13  draft-ietf-oauth-spop-12  draft-ietf-oauth-spop-11  draft-ietf-oauth-spop-10  draft-ietf-oauth-spop-09  draft-ietf-oauth-spop-08  draft-ietf-oauth-spop-07  draft-ietf-oauth-spop-06  draft-ietf-oauth-spop-05  draft-ietf-oauth-spop-04  draft-ietf-oauth-spop-03  draft-ietf-oauth-spop-02  draft-ietf-oauth-spop-01  draft-ietf-oauth-spop-00   RFC 7636  draft-ietf-oauth-spop-15  draft-ietf-oauth-spop-14  draft-ietf-oauth-spop-13  draft-ietf-oauth-spop-12  draft-ietf-oauth-spop-11  draft-ietf-oauth-spop-10  draft-ietf-oauth-spop-09  draft-ietf-oauth-spop-08  draft-ietf-oauth-spop-07  draft-ietf-oauth-spop-06  draft-ietf-oauth-spop-05  draft-ietf-oauth-spop-04  draft-ietf-oauth-spop-03  draft-ietf-oauth-spop-02  draft-ietf-oauth-spop-01  draft-ietf-oauth-spop-00   Side-by-side  Inline |
|  | Authors |  | [Nat Sakimura](/person/nat%40nat.consulting "Datatracker profile of Nat Sakimura") , [John Bradley](/person/ve7jtb%40ve7jtb.com "Datatracker profile of John Bradley") , [Naveen Agarwal](/person/naa%40google.com "Datatracker profile of Naveen Agarwal")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc7636.txt) [html](https://www.rfc-editor.org/rfc/rfc7636.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc7636.txt.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc7636.html) [bibtex](/doc/rfc7636/bibtex/) |
|  | Additional resources |  | [Mailing list discussion](https://mailarchive.ietf.org/arch/browse/oauth/?q=rfc7636 OR %22draft-ietf-oauth-spop%22) |

[Report a datatracker bug](https://github.com/ietf-tools/datatracker/issues/new/choose)

Show sidebar by default

Yes

No

Tab to show by default

Info

Contents

HTMLization configuration

HTMLize the plaintext

Plaintextify the HTML

Maximum font size

Page dependencies

Inline

Reference

Citation links

 Go to reference section

Go to linked document

![](//analytics.ietf.org/piwik.php?idsite=7)



=== Content from tools.ietf.org_94d73c91_20250124_183246.html ===


* Light
* Dark
* Auto

[draft-ietf-oauth-security-topics-15

Internet-Draft](/doc/draft-ietf-oauth-security-topics/)

|  | Title |  | OAuth 2.0 Security Best Current Practice |
| --- | --- | --- | --- |
| Document | Document type |  | This is an older version of an Internet-Draft whose latest revision state is "Active". |
| --- | --- | --- | --- |
|  | Select version |  | * [00](/doc/html/draft-ietf-oauth-security-topics-00) * [01](/doc/html/draft-ietf-oauth-security-topics-01) * [02](/doc/html/draft-ietf-oauth-security-topics-02) * [03](/doc/html/draft-ietf-oauth-security-topics-03) * [04](/doc/html/draft-ietf-oauth-security-topics-04) * [05](/doc/html/draft-ietf-oauth-security-topics-05) * [06](/doc/html/draft-ietf-oauth-security-topics-06) * [07](/doc/html/draft-ietf-oauth-security-topics-07) * [08](/doc/html/draft-ietf-oauth-security-topics-08) * [09](/doc/html/draft-ietf-oauth-security-topics-09) * [10](/doc/html/draft-ietf-oauth-security-topics-10) * [11](/doc/html/draft-ietf-oauth-security-topics-11) * [12](/doc/html/draft-ietf-oauth-security-topics-12) * [13](/doc/html/draft-ietf-oauth-security-topics-13) * [14](/doc/html/draft-ietf-oauth-security-topics-14) * [15](/doc/html/draft-ietf-oauth-security-topics-15) * [16](/doc/html/draft-ietf-oauth-security-topics-16) * [17](/doc/html/draft-ietf-oauth-security-topics-17) * [18](/doc/html/draft-ietf-oauth-security-topics-18) * [19](/doc/html/draft-ietf-oauth-security-topics-19) * [20](/doc/html/draft-ietf-oauth-security-topics-20) * [21](/doc/html/draft-ietf-oauth-security-topics-21) * [22](/doc/html/draft-ietf-oauth-security-topics-22) * [23](/doc/html/draft-ietf-oauth-security-topics-23) * [24](/doc/html/draft-ietf-oauth-security-topics-24) * [25](/doc/html/draft-ietf-oauth-security-topics-25) * [26](/doc/html/draft-ietf-oauth-security-topics-26) * [27](/doc/html/draft-ietf-oauth-security-topics-27) * [28](/doc/html/draft-ietf-oauth-security-topics-28) * [29](/doc/html/draft-ietf-oauth-security-topics-29) |
|  | Compare versions |  | draft-ietf-oauth-security-topics-29  draft-ietf-oauth-security-topics-28  draft-ietf-oauth-security-topics-27  draft-ietf-oauth-security-topics-26  draft-ietf-oauth-security-topics-25  draft-ietf-oauth-security-topics-24  draft-ietf-oauth-security-topics-23  draft-ietf-oauth-security-topics-22  draft-ietf-oauth-security-topics-21  draft-ietf-oauth-security-topics-20  draft-ietf-oauth-security-topics-19  draft-ietf-oauth-security-topics-18  draft-ietf-oauth-security-topics-17  draft-ietf-oauth-security-topics-16  draft-ietf-oauth-security-topics-15  draft-ietf-oauth-security-topics-14  draft-ietf-oauth-security-topics-13  draft-ietf-oauth-security-topics-12  draft-ietf-oauth-security-topics-11  draft-ietf-oauth-security-topics-10  draft-ietf-oauth-security-topics-09  draft-ietf-oauth-security-topics-08  draft-ietf-oauth-security-topics-07  draft-ietf-oauth-security-topics-06  draft-ietf-oauth-security-topics-05  draft-ietf-oauth-security-topics-04  draft-ietf-oauth-security-topics-03  draft-ietf-oauth-security-topics-02  draft-ietf-oauth-security-topics-01  draft-ietf-oauth-security-topics-00  draft-lodderstedt-oauth-security-topics-00   draft-ietf-oauth-security-topics-29  draft-ietf-oauth-security-topics-28  draft-ietf-oauth-security-topics-27  draft-ietf-oauth-security-topics-26  draft-ietf-oauth-security-topics-25  draft-ietf-oauth-security-topics-24  draft-ietf-oauth-security-topics-23  draft-ietf-oauth-security-topics-22  draft-ietf-oauth-security-topics-21  draft-ietf-oauth-security-topics-20  draft-ietf-oauth-security-topics-19  draft-ietf-oauth-security-topics-18  draft-ietf-oauth-security-topics-17  draft-ietf-oauth-security-topics-16  draft-ietf-oauth-security-topics-15  draft-ietf-oauth-security-topics-14  draft-ietf-oauth-security-topics-13  draft-ietf-oauth-security-topics-12  draft-ietf-oauth-security-topics-11  draft-ietf-oauth-security-topics-10  draft-ietf-oauth-security-topics-09  draft-ietf-oauth-security-topics-08  draft-ietf-oauth-security-topics-07  draft-ietf-oauth-security-topics-06  draft-ietf-oauth-security-topics-05  draft-ietf-oauth-security-topics-04  draft-ietf-oauth-security-topics-03  draft-ietf-oauth-security-topics-02  draft-ietf-oauth-security-topics-01  draft-ietf-oauth-security-topics-00  draft-lodderstedt-oauth-security-topics-00   Side-by-side  Inline |
|  | Authors |  | [Torsten Lodderstedt](/person/torsten%40lodderstedt.net "Datatracker profile of Torsten Lodderstedt") , [John Bradley](/person/ve7jtb%40ve7jtb.com "Datatracker profile of John Bradley") , [Andrey Labunets](/person/isciurus%40gmail.com "Datatracker profile of Andrey Labunets") , [Daniel Fett](/person/mail%40danielfett.de "Datatracker profile of Daniel Fett") |
|  | Replaces |  | [draft-lodderstedt-oauth-security-topics](/doc/html/draft-lodderstedt-oauth-security-topics "OAuth Security Topics") |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-15.txt) [html](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-15.html) [xml](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-15.xml) [bibtex](/doc/draft-ietf-oauth-security-topics/15/bibtex/) [bibxml](/doc/bibxml3/draft-ietf-oauth-security-topics-15.xml) |
|  | Additional resources |  | [Mailing list discussion](https://mailarchive.ietf.org/arch/browse/oauth/?q=draft-ietf-oauth-security-topics) |
|  |  |  | [Report a bug](https://github.com/ietf-tools/datatracker/issues/new/choose) |

| Internet-Draft | oauth-security-topics | April 2020 |
| --- | --- | --- |
| Lodderstedt, et al. | Expires 7 October 2020 | [Page] |
| --- | --- | --- |

Workgroup:
Web Authorization Protocol
Internet-Draft:
draft-ietf-oauth-security-topics-15
Published:
5 April 2020

Intended Status:
Best Current Practice
Expires:
7 October 2020
Authors:
T. Lodderstedt
yes.com

J. Bradley
Yubico

A. Labunets

D. Fett
yes.com

# OAuth 2.0 Security Best Current Practice

## [Abstract](#abstract)

This document describes best current security practice for OAuth 2.0.
It updates and extends the OAuth 2.0 Security Threat Model to
incorporate practical experiences gathered since OAuth 2.0 was
published and covers new threats relevant due to the broader
application of OAuth 2.0.[¶](#section-abstract-1)

## [Status of This Memo](#name-status-of-this-memo)

This Internet-Draft is submitted in full conformance with the
provisions of BCP 78 and BCP 79.[¶](#section-boilerplate.1-1)

Internet-Drafts are working documents of the Internet Engineering Task
Force (IETF). Note that other groups may also distribute working
documents as Internet-Drafts. The list of current Internet-Drafts is
at <https://datatracker.ietf.org/drafts/current/>.[¶](#section-boilerplate.1-2)

Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any
time. It is inappropriate to use Internet-Drafts as reference
material or to cite them other than as "work in progress."[¶](#section-boilerplate.1-3)

This Internet-Draft will expire on 7 October 2020.[¶](#section-boilerplate.1-4)

## [Copyright Notice](#name-copyright-notice)

Copyright (c) 2020 IETF Trust and the persons identified as the
document authors. All rights reserved.[¶](#section-boilerplate.2-1)

This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents
carefully, as they describe your rights and restrictions with
respect to this document. Code Components extracted from this
document must include Simplified BSD License text as described in
Section 4.e of the Trust Legal Provisions and are provided without
warranty as described in the Simplified BSD License.[¶](#section-boilerplate.2-2)

▲
## [Table of Contents](#name-table-of-contents)

* [1](#section-1).  [Introduction](#name-introduction)[¶](#section-toc.1-1.1.1)

  + [1.1](#section-1.1).  [Structure](#name-structure)[¶](#section-toc.1-1.1.2.1.1)
  + [1.2](#section-1.2).  [Conventions and Terminology](#name-conventions-and-terminology)[¶](#section-toc.1-1.1.2.2.1)
* [2](#section-2).  [Recommendations](#name-recommendations)[¶](#section-toc.1-1.2.1)

  + [2.1](#section-2.1).  [Protecting Redirect-Based Flows](#name-protecting-redirect-based-f)[¶](#section-toc.1-1.2.2.1.1)

    - [2.1.1](#section-2.1.1).  [Authorization Code Grant](#name-authorization-code-grant)[¶](#section-toc.1-1.2.2.1.2.1.1)
    - [2.1.2](#section-2.1.2).  [Implicit Grant](#name-implicit-grant)[¶](#section-toc.1-1.2.2.1.2.2.1)
  + [2.2](#section-2.2).  [Token Replay Prevention](#name-token-replay-prevention)[¶](#section-toc.1-1.2.2.2.1)
  + [2.3](#section-2.3).  [Access Token Privilege Restriction](#name-access-token-privilege-rest)[¶](#section-toc.1-1.2.2.3.1)
  + [2.4](#section-2.4).  [Resource Owner Password Credentials Grant](#name-resource-owner-password-cre)[¶](#section-toc.1-1.2.2.4.1)
  + [2.5](#section-2.5).  [Client Authentication](#name-client-authentication)[¶](#section-toc.1-1.2.2.5.1)
  + [2.6](#section-2.6).  [Other Recommendations](#name-other-recommendations)[¶](#section-toc.1-1.2.2.6.1)
* [3](#section-3).  [The Updated OAuth 2.0 Attacker Model](#name-the-updated-oauth-20-attack)[¶](#section-toc.1-1.3.1)
* [4](#section-4).  [Attacks and Mitigations](#name-attacks-and-mitigations)[¶](#section-toc.1-1.4.1)

  + [4.1](#section-4.1).  [Insufficient Redirect URI Validation](#name-insufficient-redirect-uri-v)[¶](#section-toc.1-1.4.2.1.1)

    - [4.1.1](#section-4.1.1).  [Redirect URI Validation Attacks on Authorization Code Grant](#name-redirect-uri-validation-att)[¶](#section-toc.1-1.4.2.1.2.1.1)
    - [4.1.2](#section-4.1.2).  [Redirect URI Validation Attacks on Implicit Grant](#name-redirect-uri-validation-atta)[¶](#section-toc.1-1.4.2.1.2.2.1)
    - [4.1.3](#section-4.1.3).  [Countermeasures](#name-countermeasures)[¶](#section-toc.1-1.4.2.1.2.3.1)
  + [4.2](#section-4.2).  [Credential Leakage via Referer Headers](#name-credential-leakage-via-refe)[¶](#section-toc.1-1.4.2.2.1)

    - [4.2.1](#section-4.2.1).  [Leakage from the OAuth Client](#name-leakage-from-the-oauth-clie)[¶](#section-toc.1-1.4.2.2.2.1.1)
    - [4.2.2](#section-4.2.2).  [Leakage from the Authorization Server](#name-leakage-from-the-authorizat)[¶](#section-toc.1-1.4.2.2.2.2.1)
    - [4.2.3](#section-4.2.3).  [Consequences](#name-consequences)[¶](#section-toc.1-1.4.2.2.2.3.1)
    - [4.2.4](#section-4.2.4).  [Countermeasures](#name-countermeasures-2)[¶](#section-toc.1-1.4.2.2.2.4.1)
  + [4.3](#section-4.3).  [Credential Leakage via Browser History](#name-credential-leakage-via-brow)[¶](#section-toc.1-1.4.2.3.1)

    - [4.3.1](#section-4.3.1).  [Authorization Code in Browser History](#name-authorization-code-in-brows)[¶](#section-toc.1-1.4.2.3.2.1.1)
    - [4.3.2](#section-4.3.2).  [Access Token in Browser History](#name-access-token-in-browser-his)[¶](#section-toc.1-1.4.2.3.2.2.1)
  + [4.4](#section-4.4).  [Mix-Up Attacks](#name-mix-up-attacks)[¶](#section-toc.1-1.4.2.4.1)

    - [4.4.1](#section-4.4.1).  [Attack Description](#name-attack-description)[¶](#section-toc.1-1.4.2.4.2.1.1)
    - [4.4.2](#section-4.4.2).  [Countermeasures](#name-countermeasures-3)[¶](#section-toc.1-1.4.2.4.2.2.1)
  + [4.5](#section-4.5).  [Authorization Code Injection](#name-authorization-code-injectio)[¶](#section-toc.1-1.4.2.5.1)

    - [4.5.1](#section-4.5.1).  [Attack Description](#name-attack-description-2)[¶](#section-toc.1-1.4.2.5.2.1.1)
    - [4.5.2](#section-4.5.2).  [Discussion](#name-discussion)[¶](#section-toc.1-1.4.2.5.2.2.1)
    - [4.5.3](#section-4.5.3).  [Countermeasures](#name-countermeasures-4)[¶](#section-toc.1-1.4.2.5.2.3.1)
    - [4.5.4](#section-4.5.4).  [Limitations](#name-limitations)[¶](#section-toc.1-1.4.2.5.2.4.1)
  + [4.6](#section-4.6).  [Access Token Injection](#name-access-token-injection)[¶](#section-toc.1-1.4.2.6.1)

    - [4.6.1](#section-4.6.1).  [Countermeasures](#name-countermeasures-5)[¶](#section-toc.1-1.4.2.6.2.1.1)
  + [4.7](#section-4.7).  [Cross Site Request Forgery](#name-cross-site-request-forgery)[¶](#section-toc.1-1.4.2.7.1)

    - [4.7.1](#section-4.7.1).  [Countermeasures](#name-countermeasures-6)[¶](#section-toc.1-1.4.2.7.2.1.1)
  + [4.8](#section-4.8).  [Access Token Leakage at the Resource Server](#name-access-token-leakage-at-the)[¶](#section-toc.1-1.4.2.8.1)

    - [4.8.1](#section-4.8.1).  [Access Token Phishing by Counterfeit Resource Server](#name-access-token-phishing-by-co)[¶](#section-toc.1-1.4.2.8.2.1.1)
    - [4.8.2](#section-4.8.2).  [Compromised Resource Server](#name-compromised-resource-server)[¶](#section-toc.1-1.4.2.8.2.2.1)
  + [4.9](#section-4.9).  [Open Redirection](#name-open-redirection)[¶](#section-toc.1-1.4.2.9.1)

    - [4.9.1](#section-4.9.1).  [Client as Open Redirector](#name-client-as-open-redirector)[¶](#section-toc.1-1.4.2.9.2.1.1)
    - [4.9.2](#section-4.9.2).  [Authorization Server as Open Redirector](#name-authorization-server-as-ope)[¶](#section-toc.1-1.4.2.9.2.2.1)
  + [4.10](#section-4.10). [307 Redirect](#name-307-redirect)[¶](#section-toc.1-1.4.2.10.1)
  + [4.11](#section-4.11). [TLS Terminating Reverse Proxies](#name-tls-terminating-reverse-pro)[¶](#section-toc.1-1.4.2.11.1)
  + [4.12](#section-4.12). [Refresh Token Protection](#name-refresh-token-protection)[¶](#section-toc.1-1.4.2.12.1)

    - [4.12.1](#section-4.12.1).  [Discussion](#name-discussion-2)[¶](#section-toc.1-1.4.2.12.2.1.1)
    - [4.12.2](#section-4.12.2).  [Recommendations](#name-recommendations-2)[¶](#section-toc.1-1.4.2.12.2.2.1)
  + [4.13](#section-4.13). [Client Impersonating Resource Owner](#name-client-impersonating-resour)[¶](#section-toc.1-1.4.2.13.1)

    - [4.13.1](#section-4.13.1).  [Countermeasures](#name-countermeasures-8)[¶](#section-toc.1-1.4.2.13.2.1.1)
  + [4.14](#section-4.14). [Clickjacking](#name-clickjacking)[¶](#section-toc.1-1.4.2.14.1)
* [5](#section-5).  [Acknowledgements](#name-acknowledgements)[¶](#section-toc.1-1.5.1)
* [6](#section-6).  [IANA Considerations](#name-iana-considerations)[¶](#section-toc.1-1.6.1)
* [7](#section-7).  [Security Considerations](#name-security-considerations)[¶](#section-toc.1-1.7.1)
* [8](#section-8).  [Normative References](#name-normative-references)[¶](#section-toc.1-1.8.1)
* [9](#section-9).  [Informative References](#name-informative-references)[¶](#section-toc.1-1.9.1)
* [Appendix A](#section-appendix.a).  [Document History](#name-document-history)[¶](#section-toc.1-1.10.1)
* [Authors' Addresses](#name-authors-addresses)[¶](#section-toc.1-1.11.1)

## [1.](#section-1) [Introduction](#name-introduction)

Since its publication in [[RFC6749](#RFC6749)] and [[RFC6750](#RFC6750)], OAuth 2.0
("OAuth" in the following) has gotten massive traction in the market
and became the standard for API protection and the basis for federated
login using OpenID Connect [[OpenID](#OpenID)]. While OAuth is used in a
variety of scenarios and different kinds of deployments, the following
challenges can be observed:[¶](#section-1-1)

* OAuth implementations are being attacked through known
  implementation weaknesses and anti-patterns. Although most of
  these threats are discussed in the OAuth 2.0 Threat Model and
  Security Considerations [[RFC6819](#RFC6819)], continued exploitation
  demonstrates a need for more specific recommendations, easier to
  implement mitigations, and more defense in depth.[¶](#section-1-2.1.1)
* OAuth is being used in environments with higher security
  requirements than considered initially, such as Open Banking,
  eHealth, eGovernment, and Electronic Signatures. Those use cases
  call for stricter guidelines and additional protection.[¶](#section-1-2.2.1)
* OAuth is being used in much more dynamic setups than originally
  anticipated, creating new challenges with respect to security.
  Those challenges go beyond the original scope of [[RFC6749](#RFC6749)],
  [[RFC6750](#RFC6750)], and [[RFC6819](#RFC6819)].[¶](#section-1-2.3.1)

  OAuth initially assumed a static relationship between client,
  authorization server and resource servers. The URLs of AS and RS were
  known to the client at deployment time and built an anchor for the
  trust relationship among those parties. The validation whether the
  client talks to a legitimate server was based on TLS server
  authentication (see [[RFC6819](#RFC6819)], Section 4.5.4). With the increasing
  adoption of OAuth, this simple model dissolved and, in several
  scenarios, was replaced by a dynamic establishment of the relationship
  between clients on one side and the authorization and resource servers
  of a particular deployment on the other side. This way, the same
  client could be used to access services of different providers (in
  case of standard APIs, such as e-mail or OpenID Connect) or serve as a
  frontend to a particular tenant in a multi-tenancy environment.
  Extensions of OAuth, such as the OAuth 2.0 Dynamic Client Registration
  Protocol [[RFC7591](#RFC7591)] and OAuth 2.0 Authorization Server Metadata
  [[RFC8414](#RFC8414)] were developed in order to support the usage of OAuth in
  dynamic scenarios.[¶](#section-1-2.3.2)
* Technology has changed. For example, the way browsers treat
  fragments when redirecting requests has changed, and with it, the
  implicit grant's underlying security model.[¶](#section-1-2.4.1)

This document provides updated security recommendations to address
these challenges. It does not supplant the security advice given in
[[RFC6749](#RFC6749)], [[RFC6750](#RFC6750)], and [[RFC6819](#RFC6819)], but complements those
documents.[¶](#section-1-3)

### [1.1.](#section-1.1) [Structure](#name-structure)

The remainder of this document is organized as follows: The next
section summarizes the most important recommendations of the OAuth
working group for every OAuth implementor. Afterwards, the updated the
OAuth attacker model is presented. Subsequently, a detailed analysis
of the threats and implementation issues that can be found in the wild
today is given along with a discussion of potential countermeasures.[¶](#section-1.1-1)

### [1.2.](#section-1.2) [Conventions and Terminology](#name-conventions-and-terminology)

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 [[RFC2119](#RFC2119)] [[RFC8174](#RFC8174)] when, and only when, they
appear in all capitals, as shown here.[¶](#section-1.2-1)

This specification uses the terms "access token", "authorization
endpoint", "authorization grant", "authorization server", "client",
"client identifier" (client ID), "protected resource", "refresh
token", "resource owner", "resource server", and "token endpoint"
defined by OAuth 2.0 [[RFC6749](#RFC6749)].[¶](#section-1.2-2)

## [2.](#section-2) [Recommendations](#name-recommendations)

This section describes the set of security mechanisms the OAuth
working group recommends to OAuth implementers.[¶](#section-2-1)

### [2.1.](#section-2.1) [Protecting Redirect-Based Flows](#name-protecting-redirect-based-f)

When comparing client redirect URIs against pre-registered URIs,
authorization servers MUST utilize exact string matching. This measure
contributes to the prevention of leakage of authorization codes and
access tokens (see [Section 4.1](#insufficient_uri_validation)). It can also help to
detect mix-up attacks (see [Section 4.4](#mix_up)).[¶](#section-2.1-1)

Clients MUST NOT expose URLs that forward the user's browser to
arbitrary URIs obtained from a query parameter ("open redirector").
Open redirectors can enable exfiltration of authorization codes and
access tokens, see [Section 4.9.1](#open_redirector_on_client).[¶](#section-2.1-2)

Clients MUST prevent Cross-Site Request Forgery (CSRF). In this
context, CSRF refers to requests to the redirection endpoint that do
not originate at the authorization server, but a malicious third party
(see Section 4.4.1.8. of [[RFC6819](#RFC6819)] for details). Clients that have
ensured that the authorization server supports PKCE [[RFC7636](#RFC7636)] MAY
rely the CSRF protection provided by PKCE. In OpenID Connect flows,
the `nonce` parameter provides CSRF protection. Otherwise, one-time
use CSRF tokens carried in the `state` parameter that are securely
bound to the user agent MUST be used for CSRF protection (see
[Section 4.7.1](#csrf_countermeasures)).[¶](#section-2.1-3)

In order to prevent mix-up attacks (see [Section 4.4](#mix_up)), clients MUST only process redirect
responses of the authorization server they sent the respective request
to and from the same user agent this authorization request was
initiated with. Clients MUST store the authorization server they sent
an authorization request to and bind this information to the user
agent and check that the authorization request was received from the
correct authorization server. Clients MUST ensure that the subsequent
token request, if applicable, is sent to the same authorization
server. Clients SHOULD use distinct redirect URIs for each
authorization server as a means to identify the authorization server a
particular response came from.[¶](#section-2.1-4)

An AS that redirects a request potentially containing user credentials
MUST avoid forwarding these user credentials accidentally (see
[Section 4.10](#redirect_307) for details).[¶](#section-2.1-5)

#### [2.1.1.](#section-2.1.1) [Authorization Code Grant](#name-authorization-code-grant)

Clients MUST prevent injection (replay) of authorization codes into
the authorization response by attackers. The use of PKCE [[RFC7636](#RFC7636)]
is RECOMMENDED to this end. The OpenID Connect `nonce` parameter and
ID Token Claim [[OpenID](#OpenID)] MAY be used as well. The PKCE challenge or
OpenID Connect `nonce` MUST be transaction-specific and securely bound
to the client and the user agent in which the transaction was started.[¶](#section-2.1.1-1)

Note: although PKCE so far was designed as a mechanism to protect
native apps, this advice applies to all kinds of OAuth clients,
including web applications.[¶](#section-2.1.1-2)

When using PKCE, clients SHOULD use PKCE code challenge methods that
do not expose the PKCE verifier in the authorization request.
Otherwise, attackers that can read the authorization request (cf.
Attacker A4 in [Section 3](#secmodel)) can break the security provided
by PKCE. Currently, `S256` is the only such method.[¶](#section-2.1.1-3)

Authorization servers MUST support PKCE [[RFC7636](#RFC7636)].[¶](#section-2.1.1-4)

Authorization servers MUST provide a way to detect their support for
PKCE. To this end, they MUST either (a) publish the element
`code_challenge_methods_supported` in their AS metadata ([[RFC8414](#RFC8414)])
containing the supported PKCE challenge methods (which can be used by
the client to detect PKCE support) or (b) provide a
deployment-specific way to ensure or determine PKCE support by the AS.[¶](#section-2.1.1-5)

#### [2.1.2.](#section-2.1.2) [Implicit Grant](#name-implicit-grant)

The implicit grant (response type "token") and other response types
causing the authorization server to issue access tokens in the
authorization response are vulnerable to access token leakage and
access token replay as described in [Section 4.1](#insufficient_uri_validation),
[Section 4.2](#credential_leakage_referrer), [Section 4.3](#browser_history), and
[Section 4.6](#access_token_injection).[¶](#section-2.1.2-1)

Moreover, no viable mechanism exists to cryptographically bind access
tokens issued in the authorization response to a certain client as it
is recommended in [Section 2.2](#token_replay_prevention). This makes replay
detection for such access tokens at resource servers impossible.[¶](#section-2.1.2-2)

In order to avoid these issues, clients SHOULD NOT use the implicit
grant (response type "token") or other response types issuing
access tokens in the authorization response, unless access token injection
in the authorization response is prevented and the aforementioned token leakage
vectors are mitigated.[¶](#section-2.1.2-3)

Clients SHOULD instead use the response type "code" (aka authorization
code grant type) as specified in [Section 2.1.1](#ac) or any other response type that
causes the authorization server to issue access tokens in the token
response, such as the "code id\_token" response type. This allows the
authorization server to detect replay attempts by attackers and
generally reduces the attack surface since access tokens are not
exposed in URLs. It also allows the authorization server to
sender-constrain the issued tokens (see next section).[¶](#section-2.1.2-4)

### [2.2.](#section-2.2) [Token Replay Prevention](#name-token-replay-prevention)

A sender-constrained access token scopes the applicability of an access
token to a certain sender. This sender is obliged to demonstrate knowledge
of a certain secret as prerequisite for the acceptance of that token at
the recipient (e.g., a resource server).[¶](#section-2.2-1)

Authorization and resource servers SHOULD use mechanisms for
sender-constrained access tokens to prevent token replay as described
in [Section 4.8.1.1.2](#pop_tokens). The use of Mutual TLS for OAuth 2.0
[[RFC8705](#RFC8705)] is RECOMMENDED. Refresh tokens MUST be
sender-constrained or use refresh token rotation as described in
[Section 4.12](#refresh_token_protection).[¶](#section-2.2-2)

It is RECOMMENDED to use end-to-end TLS. If TLS
traffic needs to be terminated at an intermediary, refer to
[Section 4.11](#tls_terminating) for further security advice.[¶](#section-2.2-3)

### [2.3.](#section-2.3) [Access Token Privilege Restriction](#name-access-token-privilege-rest)

The privileges associated with an access token SHOULD be restricted to
the minimum required for the particular application or use case. This
prevents clients from exceeding the privileges authorized by the
resource owner. It also prevents users from exceeding their privileges
authorized by the respective security policy. Privilege restrictions
also help to reduce the impact of access token leakage.[¶](#section-2.3-1)

In particular, access tokens SHOULD be restricted to certain resource
servers (audience restriction), preferably to a single resource
server. To put this into effect, the authorization server associates
the access token with certain resource servers and every resource
server is obliged to verify, for every request, whether the access
token sent with that request was meant to be used for that particular
resource server. If not, the resource server MUST refuse to serve the
respective request. Clients and authorization servers MAY utilize the
parameters `scope` or `resource` as specified in [[RFC6749](#RFC6749)] and
[[I-D.ietf-oauth-resource-indicators](#I-D.ietf-oauth-resource-indicators)], respectively, to determine the
resource server they want to access.[¶](#section-2.3-2)

Additionally, access tokens SHOULD be restricted to certain resources
and actions on resource servers or resources. To put this into effect,
the authorization server associates the access token with the
respective resource and actions and every resource server is obliged
to verify, for every request, whether the access token sent with that
request was meant to be used for that particular action on the
particular resource. If not, the resource server must refuse to serve
the respective request. Clients and authorization servers MAY utilize
the parameter `scope` as specified in [[RFC6749](#RFC6749)] and `authorization_details` as specified in [[I-D.ietf-oauth-rar](#I-D.ietf-oauth-rar)] to determine those
resources and/or actions.[¶](#section-2.3-3)

### [2.4.](#section-2.4) [Resource Owner Password Credentials Grant](#name-resource-owner-password-cre)

The resource owner password credentials grant MUST NOT be used. This
grant type insecurely exposes the credentials of the resource owner to
the client. Even if the client is benign, this results in an increased
attack surface (credentials can leak in more places than just the AS)
and users are trained to enter their credentials in places other than
the AS.[¶](#section-2.4-1)

Furthermore, adapting the resource owner password credentials grant to
two-factor authentication, authentication with cryptographic
credentials (cf. WebCrypto [[webcrypto](#webcrypto)], WebAuthn [[webauthn](#webauthn)]), and
authentication processes that require multiple steps can be hard or
impossible.[¶](#section-2.4-2)

### [2.5.](#section-2.5) [Client Authentication](#name-client-authentication)

Authorization servers SHOULD use client authentication if possible.[¶](#section-2.5-1)

It is RECOMMENDED to use asymmetric (public-key based) methods for
client authentication such as mTLS [[RFC8705](#RFC8705)] or
`private_key_jwt` [[OpenID](#OpenID)]. When asymmetric methods for client
authentication are used, authorization servers do not need to store
sensitive symmetric keys, making these methods more robust against a
number of attacks.[¶](#section-2.5-2)

### [2.6.](#section-2.6) [Other Recommendations](#name-other-recommendations)

Authorization servers SHOULD NOT allow clients to influence their
`client_id` or `sub` value or any other claim if that can cause
confusion with a genuine resource owner (see [Section 4.13](#client_impersonating)).[¶](#section-2.6-1)

## [3.](#section-3) [The Updated OAuth 2.0 Attacker Model](#name-the-updated-oauth-20-attack)

In [[RFC6819](#RFC6819)], an attacker model is laid out that describes the
capabilities of attackers against which OAuth deployments must be
protected. In the following, this attacker model is updated to account
for the potentially dynamic relationships involving multiple parties
(as described in [Section 1](#Introduction)), to include new types of attackers and to define
the attacker model more clearly.[¶](#section-3-1)

OAuth MUST ensure that the authorization of the resource owner (RO)
(with a user agent) at the authorization server (AS) and the subsequent
usage of the access token at the resource server (RS) is protected at
least against the following attackers:[¶](#section-3-2)

* (A1) Web Attackers that can set up and operate an arbitrary number
  of network endpoints including browsers and servers (except for
  the concrete RO, AS, and RS). Web attackers may set up web sites
  that are visited by the RO, operate their own user agents, and
  participate in the protocol.[¶](#section-3-3.1.1)

  Web attackers may, in particular, operate OAuth clients that are
  registered at AS, and operate their own authorization and resource
  servers that can be used (in parallel) by the RO and other
  resource owners.[¶](#section-3-3.1.2)

  It must also be assumed that web attackers can lure the user to
  open arbitrary attacker-chosen URIs at any time. In practice, this
  can be achieved in many ways, for example, by injecting malicious
  advertisements into advertisement networks, or by sending
  legit-looking emails.[¶](#section-3-3.1.3)

  Web attackers can use their own user credentials to create new
  messages as well as any secrets they learned previously. For
  example, if a web attacker learns an authorization code of a user
  through a misconfigured redirect URI, the web attacker can then
  try to redeem that code for an access token.[¶](#section-3-3.1.4)

  They cannot, however, read or manipulate messages that are not
  targeted towards them (e.g., sent to a URL controlled by a
  non-attacker controlled AS).[¶](#section-3-3.1.5)
* (A2) Network Attackers that additionally have full control over
  the network over which protocol participants communicate. They can
  eavesdrop on, manipulate, and spoof messages, except when these
  are properly protected by cryptographic methods (e.g., TLS).
  Network attackers can also block arbitrary messages.[¶](#section-3-3.2.1)

While an example for a web attacker would be a customer of an internet
service provider, network attackers could be the internet service
provider itself, an attacker in a public (wifi) network using ARP
spoofing, or a state-sponsored attacker with access to internet
exchange points, for instance.[¶](#section-3-4)

These attackers conform to the attacker model that was used in formal
analysis efforts for OAuth [[arXiv.1601.01229](#arXiv.1601.01229)]. This is a minimal
attacker model. Implementers MUST take into account all possible
attackers in the environment in which their OAuth implementations are
expected to run. Previous attacks on OAuth have shown that OAuth
deployments SHOULD in particular consider the following, stronger
attackers in addition to those listed above:[¶](#section-3-5)

* (A3) Attackers that can read, but not modify, the contents of the
  authorization response (i.e., the authorization response can leak
  to an attacker).[¶](#section-3-6.1.1)

  Examples for such attacks include open redirector
  attacks, problems existing on mobile operating systems (where
  different apps can register themselves on the same URI), mix-up attacks (see [Section 4.4](#mix_up)), where the client is tricked into sending
  credentials to a attacker-controlled AS, and the fact that URLs
  are often stored/logged by browsers (history), proxy servers, and
  operating systems.[¶](#section-3-6.1.2)
* (A4) Attackers that can read, but not modify, the contents of the
  authorization request (i.e., the authorization request can leak,
  in the same manner as above, to an attacker).[¶](#section-3-6.2.1)
* (A5) Attackers that can acquire an access token issued by AS. For
  example, a resource server can be compromised by an attacker, an
  access token may be sent to an attacker-controlled resource server
  due to a misconfiguration, or an RO is social-engineered into
  using a attacker-controlled RS. See also [Section 4.8.2](#comp_res_server).[¶](#section-3-6.3.1)

(A3), (A4) and (A5) typically occur together with either (A1) or (A2).[¶](#section-3-7)

Note that in this attacker model, an attacker (see A1) can be a RO or
act as one. For example, an attacker can use his own browser to replay
tokens or authorization codes obtained by any of the attacks described
above at the client or RS.[¶](#section-3-8)

This document focusses on threats resulting from these attackers.
Attacks in an even stronger attacker model are discussed, for example,
in [[arXiv.1901.11520](#arXiv.1901.11520)].[¶](#section-3-9)

## [4.](#section-4) [Attacks and Mitigations](#name-attacks-and-mitigations)

This section gives a detailed description of attacks on OAuth
implementations, along with potential countermeasures. Attacks and
mitigations already covered in [[RFC6819](#RFC6819)] are not listed here, except
where new recommendations are made.[¶](#section-4-1)

### [4.1.](#section-4.1) [Insufficient Redirect URI Validation](#name-insufficient-redirect-uri-v)

Some authorization servers allow clients to register redirect URI
patterns instead of complete redirect URIs. The authorization servers
then match the redirect URI parameter value at the authorization
endpoint against the registered patterns at runtime. This approach
allows clients to encode transaction state into additional redirect
URI parameters or to register a single pattern for multiple
redirect URIs.[¶](#section-4.1-1)

This approach turned out to be more complex to implement and more
error prone to manage than exact redirect URI matching. Several
successful attacks exploiting flaws in the pattern matching
implementation or concrete configurations have been observed in the
wild . Insufficient validation of the redirect URI effectively breaks
client identification or authentication (depending on grant and client
type) and allows the attacker to obtain an authorization code or
access token, either[¶](#section-4.1-2)

* by directly sending the user agent to a URI under the attackers
  control, or[¶](#section-4.1-3.1.1)
* by exposing the OAuth credentials to an attacker by utilizing an
  open redirector at the client in conjunction with the way user
  agents handle URL fragments.[¶](#section-4.1-3.2.1)

These attacks are shown in detail in the following subsections.[¶](#section-4.1-4)

#### [4.1.1.](#section-4.1.1) [Redirect URI Validation Attacks on Authorization Code Grant](#name-redirect-uri-validation-att)

For a client using the grant type code, an attack may work as
follows:[¶](#section-4.1.1-1)

Assume the redirect URL pattern `https://*.somesite.example/*` is
registered for the client with the client ID `s6BhdRkqt3`. The
intention is to allow any subdomain of `somesite.example` to be a
valid redirect URI for the client, for example
`https://app1.somesite.example/redirect`. A naive implementation on
the authorization server, however, might interpret the wildcard `*` as
"any character" and not "any character valid for a domain name". The
authorization server, therefore, might permit
`https://attacker.example/.somesite.example` as a redirect URI,
although `attacker.example` is a different domain potentially
controlled by a malicious party.[¶](#section-4.1.1-2)

The attack can then be conducted as follows:[¶](#section-4.1.1-3)

First, the attacker needs to trick the user into opening a tampered
URL in his browser that launches a page under the attacker's
control, say `https://www.evil.example` (see Attacker A1.)[¶](#section-4.1.1-4)

This URL initiates the following authorization request with the client
ID of a legitimate client to the authorization endpoint (line breaks
for display only):[¶](#section-4.1.1-5)

```
GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=9ad67f13
     &redirect_uri=https%3A%2F%2Fattacker.example%2F.somesite.example
     HTTP/1.1
Host: server.somesite.example

```
[¶](#section-4.1.1-6)

The authorization server validates the redirect URI and compares it to
the registered redirect URL patterns for the client `s6BhdRkqt3`.
The authorization request is processed and presented to the user.[¶](#section-4.1.1-7)

If the user does not see the redirect URI or does not recognize the
attack, the code is issued and immediately sent to the attacker's
domain. If an automatic approval of the authorization is enabled
(which is not recommended for public clients according to
[[RFC6749](#RFC6749)]), the attack can be performed even without user
interaction.[¶](#section-4.1.1-8)

If the attacker impersonated a public client, the attacker can
exchange the code for tokens at the respective token endpoint.[¶](#section-4.1.1-9)

This attack will not work as easily for confidential clients, since
the code exchange requires authentication with the legitimate client's
secret. The attacker can, however, use the legitimate confidential
client to redeem the code by performing an authorization code
injection attack, see [Section 4.5](#code_injection).[¶](#section-4.1.1-10)

Note: Vulnerabilities of this kind can also exist if the authorization
server handles wildcards properly. For example, assume that the client
registers the redirect URL pattern `https://*.somesite.example/*` and
the authorization server interprets this as "allow redirect URIs
pointing to any host residing in the domain `somesite.example`". If an
attacker manages to establish a host or subdomain in
`somesite.example`, he can impersonate the legitimate client. This
could be caused, for example, by a subdomain takeover attack [[subdomaintakeover](#subdomaintakeover)], where an
outdated CNAME record (say, `external-service.somesite.example`)
points to an external DNS name that does no longer exist (say,
`customer-abc.service.example`) and can be taken over by an attacker
(e.g., by registering as `customer-abc` with the external service).[¶](#section-4.1.1-11)

#### [4.1.2.](#section-4.1.2) [Redirect URI Validation Attacks on Implicit Grant](#name-redirect-uri-validation-atta)

The attack described above works for the implicit grant as well. If
the attacker is able to send the authorization response to a URI under
his control, he will directly get access to the fragment carrying the
access token.[¶](#section-4.1.2-1)

Additionally, implicit clients can be subject to a further kind of
attack. It utilizes the fact that user agents re-attach fragments to
the destination URL of a redirect if the location header does not
contain a fragment (see [[RFC7231](#RFC7231)], Section 9.5). The attack
described here combines this behavior with the client as an open
redirector (see [Section 4.9.1](#open_redirector_on_client)) in order to get access to access tokens. This allows
circumvention even of very narrow redirect URI patterns, but not strict URL
matching.[¶](#section-4.1.2-2)

Assume the registered URL pattern for client `s6BhdRkqt3` is
`https://client.somesite.example/cb?*`, i.e., any parameter is allowed
for redirects to `https://client.somesite.example/cb`. Unfortunately,
the client exposes an open redirector. This endpoint supports a
parameter `redirect_to` which takes a target URL and will send the
browser to this URL using an HTTP Location header redirect 303.[¶](#section-4.1.2-3)

The attack can now be conducted as follows:[¶](#section-4.1.2-4)

First, and as above, the attacker needs to trick the user into opening
a tampered URL in his browser that launches a page under the
attacker's control, say `https://www.evil.example`.[¶](#section-4.1.2-5)

Afterwards, the website initiates an authorization request that is
very similar to the one in the attack on the code flow. Different to
above, it utilizes the open redirector by encoding
`redirect_to=https://attacker.example` into the parameters of the
redirect URI and it uses the response type "token" (line breaks for display only):[¶](#section-4.1.2-6)

```
GET /authorize?response_type=token&state=9ad67f13
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.somesite.example
     %2Fcb%26redirect_to%253Dhttps%253A%252F
     %252Fattacker.example%252F HTTP/1.1
Host: server.somesite.example

```
[¶](#section-4.1.2-7)

Now, since the redirect URI matches the registered pattern, the
authorization server permits the request and sends the resulting access
token in a 303 redirect (some response parameters omitted for
readability):[¶](#section-4.1.2-8)

```
HTTP/1.1 303 See Other
Location: https://client.somesite.example/cb?
          redirect_to%3Dhttps%3A%2F%2Fattacker.example%2Fcb
          #access_token=2YotnFZFEjr1zCsicMWpAA&...

```
[¶](#section-4.1.2-9)

At example.com, the request arrives at the open redirector. The endpoint will
read the redirect parameter and will issue an HTTP 303 Location header
redirect to the URL `https://attacker.example/`.[¶](#section-4.1.2-10)

```
HTTP/1.1 303 See Other
Location: https://attacker.example/

```
[¶](#section-4.1.2-11)

Since the redirector at client.somesite.example does not include a
fragment in the Location header, the user agent will re-attach the
original fragment `#access_token=2YotnFZFEjr1zCsicMWpAA&amp;...` to
the URL and will navigate to the following URL:[¶](#section-4.1.2-12)

```
https://attacker.example/#access_token=2YotnFZFEjr1z...

```
[¶](#section-4.1.2-13)

The attacker's page at `attacker.example` can now access the
fragment and obtain the access token.[¶](#section-4.1.2-14)

#### [4.1.3.](#section-4.1.3) [Countermeasures](#name-countermeasures)

The complexity of implementing and managing pattern matching correctly
obviously causes security issues. This document therefore advises to
simplify the required logic and configuration by using exact redirect
URI matching only. This means the authorization server MUST compare
the two URIs using simple string comparison as defined in [[RFC3986](#RFC3986)],
Section 6.2.1.[¶](#section-4.1.3-1)

Additional recommendations:[¶](#section-4.1.3-2)

* Servers on which callbacks are hosted MUST NOT expose open
  redirectors (see [Section 4.9](#open_redirection)).[¶](#section-4.1.3-3.1.1)
* Browsers reattach URL fragments to Location redirection URLs only
  if the URL in the Location header does not already contain a fragment.
  Therefore, servers MAY prevent browsers from reattaching fragments
  to redirection URLs by attaching an arbitrary fragment identifier,
  for example `#_`, to URLs in Location headers.[¶](#section-4.1.3-3.2.1)
* Clients SHOULD use the authorization code response type instead of
  response types causing access token issuance at the authorization
  endpoint. This offers countermeasures against reuse of leaked
  credentials through the exchange process with the authorization
  server and token replay through sender-constraining of the access
  tokens.[¶](#section-4.1.3-3.3.1)

If the origin and integrity of the authorization request containing
the redirect URI can be verified, for example when using
[[I-D.ietf-oauth-jwsreq](#I-D.ietf-oauth-jwsreq)] or [[I-D.ietf-oauth-par](#I-D.ietf-oauth-par)] with client
authentication, the authorization server MAY trust the redirect URI
without further checks.[¶](#section-4.1.3-4)

### [4.2.](#section-4.2) [Credential Leakage via Referer Headers](#name-credential-leakage-via-refe)

The contents of the authorization request URI or the authorization
response URI can unintentionally be disclosed to attackers through the
Referer HTTP header (see [[RFC7231](#RFC7231)], Section 5.5.2), by leaking either
from the AS's or the client's web site, respectively. Most
importantly, authorization codes or `state` values can be disclosed in
this way. Although specified otherwise in [[RFC7231](#RFC7231)], Section 5.5.2,
the same may happen to access tokens conveyed in URI fragments due to
browser implementation issues as illustrated by Chromium Issue 168213
[[bug.chromium](#bug.chromium)].[¶](#section-4.2-1)

#### [4.2.1.](#section-4.2.1) [Leakage from the OAuth Client](#name-leakage-from-the-oauth-clie)

Leakage from the OAuth client requires that the client, as a result of
a successful authorization request, renders a page that[¶](#section-4.2.1-1)

* contains links to other pages under the attacker's control and a
  user clicks on such a link, or[¶](#section-4.2.1-2.1.1)
* includes third-party content (advertisements in iframes, images,
  etc.), for example if the page contains user-generated content
  (blog).[¶](#section-4.2.1-2.2.1)

As soon as the browser navigates to the attacker's page or loads the
third-party content, the attacker receives the authorization response
URL and can extract `code` or `state` (and potentially `access token`).[¶](#section-4.2.1-3)

#### [4.2.2.](#section-4.2.2) [Leakage from the Authorization Server](#name-leakage-from-the-authorizat)

In a similar way, an attacker can learn `state` from the authorization
request if the authorization endpoint at the authorization server
contains links or third-party content as above.[¶](#section-4.2.2-1)

#### [4.2.3.](#section-4.2.3) [Consequences](#name-consequences)

An attacker that learns a valid code or access token through a
Referer header can perform the attacks as described in
[Section 4.1.1](#insufficient_uri_validation_acg), [Section 4.5](#code_injection), and
[Section 4.6](#access_token_injection). If the attacker learns `state`, the CSRF
protection achieved by using `state` is lost, resulting in CSRF
attacks as described in [[RFC6819](#RFC6819)], Section 4.4.1.8.[¶](#section-4.2.3-1)

#### [4.2.4.](#section-4.2.4) [Countermeasures](#name-countermeasures-2)

The page rendered as a result of the OAuth authorization response and
the authorization endpoint SHOULD NOT include third-party resources or
links to external sites.[¶](#section-4.2.4-1)

The following measures further reduce the chances of a successful attack:[¶](#section-4.2.4-2)

* Suppress the Referer header by applying an appropriate Referrer
  Policy [[webappsec-referrer-policy](#webappsec-referrer-policy)] to the document (either as
  part of the "referrer" meta attribute or by setting a
  Referrer-Policy header). For example, the header `Referrer-Policy:
  no-referrer` in the response completely suppresses the Referer
  header in all requests originating from the resulting document.[¶](#section-4.2.4-3.1.1)
* Use authorization code instead of response types causing access
  token issuance from the authorization endpoint.[¶](#section-4.2.4-3.2.1)
* Bind authorization code to a confidential client or PKCE
  challenge. In this case, the attacker lacks the secret to request
  the code exchange.[¶](#section-4.2.4-3.3.1)
* As described in [[RFC6749](#RFC6749)], Section 4.1.2, authorization codes
  MUST be invalidated by the AS after their first use at the token
  endpoint. For example, if an AS invalidated the code after the
  legitimate client redeemed it, the attacker would fail exchanging
  this code later.[¶](#section-4.2.4-3.4.1)

  This does not mitigate the attack if the attacker manages to
  exchange the code for a token before the legitimate client does
  so. Therefore, [[RFC6749](#RFC6749)] further recommends that, when an
  attempt is made to redeem a code twice, the AS SHOULD revoke all
  tokens issued previously based on that code.[¶](#section-4.2.4-3.4.2)
* The `state` value SHOULD be invalidated by the client after its
  first use at the redirection endpoint. If this is implemented, and
  an attacker receives a token through the Referer header from the
  client's web site, the `state` was already used, invalidated by
  the client and cannot be used again by the attacker. (This does
  not help if the `state` leaks from the
  AS's web site, since then the `state`
  has not been used at the redirection endpoint at the client yet.)[¶](#section-4.2.4-3.5.1)
* Use the form post response mode instead of a redirect for the
  authorization response (see [[oauth-v2-form-post-response-mode](#oauth-v2-form-post-response-mode)]).[¶](#section-4.2.4-3.6.1)

### [4.3.](#section-4.3) [Credential Leakage via Browser History](#name-credential-leakage-via-brow)

Authorization codes and access tokens can end up in the browser's
history of visited URLs, enabling the attacks described in the
following.[¶](#section-4.3-1)

#### [4.3.1.](#section-4.3.1) [Authorization Code in Browser History](#name-authorization-code-in-brows)

When a browser navigates to
`client.example/redirection_endpoint?code=abcd` as a result of a
redirect from a provider's authorization endpoint, the URL including
the authorization code may end up in the browser's history. An
attacker with access to the device could obtain the code and try to
replay it.[¶](#section-4.3.1-1)

Countermeasures:[¶](#section-4.3.1-2)

* Authorization code replay prevention as described in [[RFC6819](#RFC6819)],
  Section 4.4.1.1, and [Section 4.5](#code_injection).[¶](#section-4.3.1-3.1.1)
* Use form post response mode instead of redirect for the authorization
  response (see [[oauth-v2-form-post-response-mode](#oauth-v2-form-post-response-mode)]).[¶](#section-4.3.1-3.2.1)

#### [4.3.2.](#section-4.3.2) [Access Token in Browser History](#name-access-token-in-browser-his)

An access token may end up in the browser history if a client or a web
site that already has a token deliberately navigates to a page like
`provider.com/get_user_profile?access_token=abcdef`. [[RFC6750](#RFC6750)]
discourages this practice and advises to transfer tokens via a header,
but in practice web sites often pass access tokens in query
parameters.[¶](#section-4.3.2-1)

In case of the implicit grant, a URL like
`client.example/redirection_endpoint#access_token=abcdef` may also end
up in the browser history as a result of a redirect from a provider's
authorization endpoint.[¶](#section-4.3.2-2)

Countermeasures:[¶](#section-4.3.2-3)

* Clients MUST NOT pass access tokens in a URI query parameter in
  the way described in Section 2.3 of [[RFC6750](#RFC6750)]. The authorization
  code grant or alternative OAuth response modes like the form post
  response mode [[oauth-v2-form-post-response-mode](#oauth-v2-form-post-response-mode)] can be used to
  this end.[¶](#section-4.3.2-4.1.1)

### [4.4.](#section-4.4) [Mix-Up Attacks](#name-mix-up-attacks)

Mix-up is an attack on scenarios where an OAuth client interacts with
two or more authorization servers and at least one authorization
server is under the control of the attacker. This can be the case,
for example, if the attacker uses dynamic registration to register the
client at his own authorization server or if an authorization server
becomes compromised.[¶](#section-4.4-1)

The goal of the attack is to obtain an authorization code or an access
token for an uncompromised authorization server. This is achieved by
tricking the client into sending those credentials to the compromised
authorization server (the attacker) instead of using them at the
respective endpoint of the uncompromised authorization/resource
server.[¶](#section-4.4-2)

#### [4.4.1.](#section-4.4.1) [Attack Description](#name-attack-description)

The description here closely follows [[arXiv.1601.01229](#arXiv.1601.01229)], with
variants of the attack outlined below.[¶](#section-4.4.1-1)

Preconditions: For this variant of the attack to work, we assume that[¶](#section-4.4.1-2)

* the implicit or authorization code grant are used with multiple AS
  of which one is considered "honest" (H-AS) and one is operated by
  the attacker (A-AS),[¶](#section-4.4.1-3.1.1)
* the client stores the AS chosen by the user in a session bound to
  the user's browser and uses the same redirection endpoint URI for
  each AS, and[¶](#section-4.4.1-3.2.1)
* the attacker can intercept and manipulate the first
  request/response pair from a user's browser to the client (in
  which the user selects a certain AS and is then redirected by the
  client to that AS), as in Attacker A2.[¶](#section-4.4.1-3.3.1)

The latter ability can, for example, be the result of a
man-in-the-middle attack on the user's connection to the client. Note
that an attack variant exists that does not require this ability, see
below.[¶](#section-4.4.1-4)

In the following, we assume that the client is registered with H-AS
(URI: `https://honest.as.example`, client ID: `7ZGZldHQ`) and with
A-AS (URI: `https://attacker.example`, client ID: `666RVZJTA`).[¶](#section-4.4.1-5)

Attack on the authorization code grant:[¶](#section-4.4.1-6)

1. The user selects to start the grant using H-AS (e.g., by clicking on a button at the
   client's website).[¶](#section-4.4.1-7.1.1)
2. The attacker intercepts this request and changes the user's
   selection to "A-AS" (see preconditions).[¶](#section-4.4.1-7.2.1)
3. The client stores in the user's session that the user selected
   "A-AS" and redirects the user to A-AS's authorization endpoint
   with a Location header containing the URL
   `https://attacker.example/authorize?response_type=code&client_id=666RVZJTA`.[¶](#section-4.4.1-7.3.1)
4. Now the attacker intercepts this response and changes the
   redirection such that the user is being redirected to H-AS. The
   attacker also replaces the client ID of the client at A-AS with
   the client's ID at H-AS. Therefore, the browser receives a
   redirection (`303 See Other`) with a Location header pointing to
   `https://honest.as.example/authorize?response_type=code&client_id=7ZGZldHQ`[¶](#section-4.4.1-7.4.1)
5. The user authorizes the client to access her resources at
   H-AS. H-AS issues a code and sends it (via the browser) back to
   the client.[¶](#section-4.4.1-7.5.1)
6. Since the client still assumes that the code was issued by A-AS,
   it will try to redeem the code at A-AS's token endpoint.[¶](#section-4.4.1-7.6.1)
7. The attacker therefore obtains code and can either exchange the
   code for an access token (for public clients) or perform an
   authorization code injection attack as described in
   [Section 4.5](#code_injection).[¶](#section-4.4.1-7.7.1)

Variants:[¶](#section-4.4.1-8)

* **Mix-Up Without Interception**: A variant of the above attack
  works even if the first request/response pair cannot be
  intercepted, for example, because TLS is used to protect these
  messages: Here, it is assumed that the user wants to start the
  grant using A-AS (and not H-AS, see Attacker A1). After the client
  redirected the user to the authorization endpoint at A-AS, the
  attacker immediately redirects the user to H-AS (changing the
  client ID to `7ZGZldHQ`). Note that a vigilant user might at this
  point detect that she intended to use A-AS instead of H-AS. The
  attack now proceeds exactly as in Steps 3ff. of the attack
  description above.[¶](#section-4.4.1-9.1.1)
* **Implicit Grant**: In the implicit grant, the attacker receives
  an access token instead of the code; the rest of the attack works
  as above.[¶](#section-4.4.1-9.2.1)
* **Per-AS Redirect URIs**: If clients use different redirect URIs
  for different ASs, do not store the selected AS in the user's
  session, and ASs do not check the redirect URIs properly,
  attackers can mount an attack called "Cross-Social Network Request
  Forgery". These attacks have been observed in practice. Refer to [[oauth\_security\_jcs\_14](#oauth_security_jcs_14)] for details.[¶](#section-4.4.1-9.3.1)
* **OpenID Connect**: There are variants that can be used to attack
  OpenID Connect. In these attacks, the attacker misuses features of
  the OpenID Connect Discovery mechanism or replays access tokens or
  ID Tokens to conduct a Mix-Up Attack. The attacks are described in
  detail in [[arXiv.1704.08539](#arXiv.1704.08539)], Appendix A, and
  [[arXiv.1508.04324v2](#arXiv.1508.04324v2)], Section 6 ("Malicious Endpoints Attacks").[¶](#section-4.4.1-9.4.1)

#### [4.4.2.](#section-4.4.2) [Countermeasures](#name-countermeasures-3)

In scenarios where an OAuth client interacts with multiple
authorization servers, clients MUST prevent mix-up attacks.[¶](#section-4.4.2-1)

To this end, clients SHOULD use distinct redirect URIs for each AS
(with alternatives listed below). Clients MUST store, for each
authorization request, the AS they sent the authorization request to
and bind this information to the user agent. Clients MUST check that
the authorization request was received from the correct authorization
server and ensure that the subsequent token request, if applicable, is
sent to the same authorization server.[¶](#section-4.4.2-2)

Unfortunately, distinct redirect URIs per AS do not work for all kinds
of OAuth clients. They are effective for web and JavaScript apps and
for native apps with claimed URLs. Attacks on native apps using custom
schemes or redirect URIs on localhost cannot be prevented this way.[¶](#section-4.4.2-3)

If clients cannot use distinct redirect URIs for each AS, the following options exist:[¶](#section-4.4.2-4)

* Authorization servers can be configured to return an AS
  identitifier (`iss`) as a non-standard parameter in the
  authorization response. This enables complying clients to compare
  this data to the `iss` identifier of the AS it believed it sent
  the user agent to.[¶](#section-4.4.2-5.1.1)
* In OpenID Connect, if an ID Token is returned in the authorization
  response, it carries client ID and issuer. It can be used in the
  same way as the `iss` parameter.[¶](#section-4.4.2-5.2.1)

### [4.5.](#section-4.5) [Authorization Code Injection](#name-authorization-code-injectio)

In an authorization code injection attack, the attacker attempts to
inject a stolen authorization code into the attacker's own session
with the client. The aim is to associate the attacker's session at the
client with the victim's resources or identity.[¶](#section-4.5-1)

This attack is useful if the attacker cannot exchange the
authorization code for an access token himself. Examples include:[¶](#section-4.5-2)

* The code is bound to a particular confidential client and the
  attacker is unable to obtain the required client credentials to
  redeem the code himself.[¶](#section-4.5-3.1.1)
* The attacker wants to access certain functions in this particular
  client. As an example, the attacker wants to impersonate his
  victim in a certain app or on a certain web site.[¶](#section-4.5-3.2.1)
* The authorization or resource servers are limited to certain
  networks that the attacker is unable to access directly.[¶](#section-4.5-3.3.1)

In the following attack description and discussion, we assume the
presence of a web (A1) or network attacker (A2).[¶](#section-4.5-4)

#### [4.5.1.](#section-4.5.1) [Attack Description](#name-attack-description-2)

The attack works as follows:[¶](#section-4.5.1-1)

1. The attacker obtains an authorization code by performing any of
   the attacks described above.[¶](#section-4.5.1-2.1.1)
2. He performs a regular OAuth authorization process with the
   legitimate client on his device.[¶](#section-4.5.1-2.2.1)
3. The attacker injects the stolen authorization code in the response
   of the authorization server to the legitimate client. Since this
   response is passing through the attacker's device, the attacker
   can use any tool that can intercept and manipulate the
   authorization response to this end. The attacker does not need to
   control the network.[¶](#section-4.5.1-2.3.1)
4. The legitimate client sends the code to the authorization server's
   token endpoint, along with the client's client ID, client secret
   and actual `redirect_uri`.[¶](#section-4.5.1-2.4.1)
5. The authorization server checks the client secret, whether the
   code was issued to the particular client, and whether the actual
   redirect URI matches the `redirect_uri` parameter (see
   [[RFC6749](#RFC6749)]).[¶](#section-4.5.1-2.5.1)
6. All checks succeed and the authorization server issues access and
   other tokens to the client. The attacker has now associated his
   session with the legitimate client with the victim's resources
   and/or identity.[¶](#section-4.5.1-2.6.1)

#### [4.5.2.](#section-4.5.2) [Discussion](#name-discussion)

Obviously, the check in step (5.) will fail if the code was issued to
another client ID, e.g., a client set up by the attacker. The check
will also fail if the authorization code was already redeemed by the
legitimate user and was one-time use only.[¶](#section-4.5.2-1)

An attempt to inject a code obtained via a manipulated redirect URI
should also be detected if the authorization server stored the
complete redirect URI used in the authorization request and compares
it with the `redirect_uri` parameter.[¶](#section-4.5.2-2)

[[RFC6749](#RFC6749)], Section 4.1.3, requires the AS to "... ensure that the
`redirect_uri` parameter is present if the `redirect_uri` parameter
was included in the initial authorization request as described in
Section 4.1.1, and if included ensure that their values are
identical.". In the attack scenario described above, the legitimate
client would use the correct redirect URI it always uses for
authorization requests. But this URI would not match the tampered
redirect URI used by the attacker (otherwise, the redirect would not
land at the attackers page). So the authorization server would detect
the attack and refuse to exchange the code.[¶](#section-4.5.2-3)

Note: this check could also detect attempts to inject an authorization
code which had been obtained from another instance of the same client
on another device, if certain conditions are fulfilled:[¶](#section-4.5.2-4)

* the redirect URI itself needs to contain a nonce or another kind
  of one-time use, secret data and[¶](#section-4.5.2-5.1.1)
* the client has bound this data to this particular instance of the
  client.[¶](#section-4.5.2-5.2.1)

But this approach conflicts with the idea to enforce exact redirect
URI matching at the authorization endpoint. Moreover, it has been
observed that providers very often ignore the `redirect_uri` check
requirement at this stage, maybe because it doesn't seem to be
security-critical from reading the specification.[¶](#section-4.5.2-6)

Other providers just pattern match the `redirect_uri` parameter
against the registered redirect URI pattern. This saves the
authorization server from storing the link between the actual redirect
URI and the respective authorization code for every transaction. But
this kind of check obviously does not fulfill the intent of the
specification, since the tampered redirect URI is not considered. So
any attempt to inject an authorization code obtained using the
`client_id` of a legitimate client or by utilizing the legitimate
client on another device will not be detected in the respective
deployments.[¶](#section-4.5.2-7)

It is also assumed that the requirements defined in [[RFC6749](#RFC6749)],
Section 4.1.3, increase client implementation complexity as clients
need to store or re-construct the correct redirect URI for the call
to the token endpoint.[¶](#section-4.5.2-8)

This document therefore recommends to instead bind every authorization
code to a certain client instance on a certain device (or in a certain
user agent) in the context of a certain transaction using one of the
mechanisms described next.[¶](#section-4.5.2-9)

#### [4.5.3.](#section-4.5.3) [Countermeasures](#name-countermeasures-4)

There are two good technical solutions to achieve this goal:[¶](#section-4.5.3-1)

* **PKCE**: The PKCE parameter `code_challenge` along with the
  corresponding `code_verifier` as specified in [[RFC7636](#RFC7636)] can be
  used as a countermeasure. In contrast to its original intention,
  the verifier check fails although the client uses its correct
  verifier but the code is associated with a challenge that does not
  match. PKCE is a deployed OAuth feature, although its original
  intended use was solely focused on securing native apps, not the
  broader use recommended by this document.[¶](#section-4.5.3-2.1.1)
* **Nonce**: OpenID Connect's existing `nonce` parameter can be used
  for the same purpose. The `nonce` value is one-time use and
  created by the client. The client is supposed to bind it to the
  user agent session and sends it with the initial request to the
  OpenID Provider (OP). The OP binds `nonce` to the authorization
  code and attests this binding in the ID Token, which is issued as
  part of the code exchange at the token endpoint. If an attacker
  injected an authorization code in the authorization response, the
  nonce value in the client session and the nonce value in the ID
  token will not match and the attack is detected. The assumption is
  that an attacker cannot get hold of the user agent state on the
  victim's device, where he has stolen the respective authorization
  code.[¶](#section-4.5.3-2.2.1)

Other solutions, like binding `state` to the code, using token binding
for the code, or per-instance client credentials are conceivable, but
lack support and bring new security requirements.[¶](#section-4.5.3-3)

PKCE is the most obvious solution for OAuth clients as it is available
today (originally intended for OAuth native apps) whereas `nonce` is
appropriate for OpenID Connect clients.[¶](#section-4.5.3-4)

#### [4.5.4.](#section-4.5.4) [Limitations](#name-limitations)

An attacker can circumvent the countermeasures described above if he
can modify the `nonce` or `code_challenge` values that are used in the
victim's authorization request. The attacker can modify these values
to be the same ones as those chosen by the client in his own session
in Step 2 of the attack above. (This requires that the victim's
session with the client begins after the attacker started his session
with the client.) If the attacker is then able to capture the
authorization code from the victim, the attacker will be able to
inject the stolen code in Step 3 even if PKCE or `nonce` are used.[¶](#section-4.5.4-1)

This attack is complex and requires a close interaction between the
attacker and the victim's session. Nonetheless, measures to prevent
attackers from reading the contents of the authorization response
still need to be taken, as described in
[Section 4.1](#insufficient_uri_validation), [Section 4.2](#credential_leakage_referrer),
[Section 4.3](#browser_history), [Section 4.4](#mix_up), and [Section 4.9](#open_redirection).[¶](#section-4.5.4-2)

### [4.6.](#section-4.6) [Access Token Injection](#name-access-token-injection)

In an access token injection attack, the attacker attempts to inject a
stolen access token into a legitimate client (that is not under the
attacker's control). This will typically happen if the attacker wants
to utilize a leaked access token to impersonate a user in a certain
client.[¶](#section-4.6-1)

To conduct the attack, the attacker starts an OAuth flow with the
client using the implicit grant and modifies the authorization
response by replacing the access token issued by the authorization
server or directly makes up an authorization server response including
the leaked access token. Since the response includes the `state` value
generated by the client for this particular transaction, the client
does not treat the response as a CSRF attack and uses the access token
injected by the attacker.[¶](#section-4.6-2)

#### [4.6.1.](#section-4.6.1) [Countermeasures](#name-countermeasures-5)

There is no way to detect such an injection attack on the OAuth
protocol level, since the token is issued without any binding to the
transaction or the particular user agent.[¶](#section-4.6.1-1)

The recommendation is therefore to use the authorization code grant
type instead of relying on response types issuing acess tokens at the
authorization endpoint. Authorization code injection can be detected
using one of the countermeasures discussed in [Section 4.5](#code_injection).[¶](#section-4.6.1-2)

### [4.7.](#section-4.7) [Cross Site Request Forgery](#name-cross-site-request-forgery)

An attacker might attempt to inject a request to the redirect URI of
the legitimate client on the victim's device, e.g., to cause the
client to access resources under the attacker's control. This is a
variant of an attack known as Cross-Site Request Forgery (CSRF).[¶](#section-4.7-1)

#### [4.7.1.](#section-4.7.1) [Countermeasures](#name-countermeasures-6)

The traditional countermeasure are CSRF tokens that are bound to the
user agent and passed in the `state` parameter to the authorization
server as described in [[RFC6819](#RFC6819)]. The same protection is provided by
PKCE or the OpenID Connect `nonce` value.[¶](#section-4.7.1-1)

When using PKCE instead of `state` or `nonce` for CSRF protection, it is
important to note that:[¶](#section-4.7.1-2)

* Clients MUST ensure that the AS supports PKCE before using PKCE for
  CSRF protection. If an authorization server does not support PKCE,
  `state` or `nonce` MUST be used for CSRF protection.[¶](#section-4.7.1-3.1.1)
* If `state` is used for carrying application state, and integrity of
  its contents is a concern, clients MUST protect `state` against
  tampering and swapping. This can be achieved by binding the
  contents of state to the browser session and/or signed/encrypted
  state values [[I-D.bradley-oauth-jwt-encoded-state](#I-D.bradley-oauth-jwt-encoded-state)].[¶](#section-4.7.1-3.2.1)

AS therefore MUST provide a way to detect their support for PKCE
either via AS metadata according to [[RFC8414](#RFC8414)] or provide a
deployment-specific way to ensure or determine PKCE support.[¶](#section-4.7.1-4)

### [4.8.](#section-4.8) [Access Token Leakage at the Resource Server](#name-access-token-leakage-at-the)

Access tokens can leak from a resource server under certain
circumstances.[¶](#section-4.8-1)

#### [4.8.1.](#section-4.8.1) [Access Token Phishing by Counterfeit Resource Server](#name-access-token-phishing-by-co)

An attacker may setup his own resource server and trick a client into
sending access tokens to it that are valid for other resource servers
(see Attackers A1 and A5). If the client sends a valid access token to
this counterfeit resource server, the attacker in turn may use that
token to access other services on behalf of the resource owner.[¶](#section-4.8.1-1)

This attack assumes the client is not bound to one specific resource
server (and its URL) at development time, but client instances are
provided with the resource server URL at runtime. This kind of late
binding is typical in situations where the client uses a service
implementing a standardized API (e.g., for e-Mail, calendar, health,
or banking) and where the client is configured by a user or
administrator for a service which this user or company uses.[¶](#section-4.8.1-2)

##### [4.8.1.1.](#section-4.8.1.1) [Countermeasures](#name-countermeasures-7)

There are several potential mitigation strategies, which will be
discussed in the following sections.[¶](#section-4.8.1.1-1)

###### [4.8.1.1.1.](#section-4.8.1.1.1) [Metadata](#name-metadata)

An authorization server could provide the client with additional
information about the location where it is safe to use its access
tokens.[¶](#section-4.8.1.1.1-1)

In the simplest form, this would require the AS to publish a list of
its known resource servers, illustrated in the following example using
a non-standard metadata parameter `resource_servers`:[¶](#section-4.8.1.1.1-2)

```
HTTP/1.1 200 OK
Content-Type: application/json

{
  "issuer":"https://server.somesite.example",
  "authorization_endpoint":
    "https://server.somesite.example/authorize",
  "resource_servers":[
    "email.somesite.example",
    "storage.somesite.example",
    "video.somesite.example"
  ]
  ...
}

```
[¶](#section-4.8.1.1.1-3)

The AS could also return the URL(s) an access token is good for in the
token response, illustrated by the example and non-standard return
parameter `access_token_resource_server`:[¶](#section-4.8.1.1.1-4)

```
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  "access_token_resource_server":
    "https://hostedresource.somesite.example/path1",
...
}

```
[¶](#section-4.8.1.1.1-5)

This mitigation strategy would rely on the client to enforce the
security policy and to only send access tokens to legitimate
destinations. Results of OAuth related security research (see for
example [[oauth\_security\_ubc](#oauth_security_ubc)] and [[oauth\_security\_cmu](#oauth_security_cmu)]) indicate a
large portion of client implementations do not or fail to properly
implement security controls, like `state` checks. So relying on
clients to prevent access token phishing is likely to fail as well.
Moreover given the ratio of clients to authorization and resource
servers, it is considered the more viable approach to move as much as
possible security-related logic to those entities. Clearly, the client
has to contribute to the overall security. But there are alternative
countermeasures, as described in the next sections, which provide a
better balance between the involved parties.[¶](#section-4.8.1.1.1-6)

###### [4.8.1.1.2.](#section-4.8.1.1.2) [Sender-Constrained Access Tokens](#name-sender-constrained-access-t)

As the name suggests, sender-constrained access token scope the
applicability of an access token to a certain sender. This sender is
obliged to demonstrate knowledge of a certain secret as prerequisite
for the acceptance of that token at a resource server.[¶](#section-4.8.1.1.2-1)

A typical flow looks like this:[¶](#section-4.8.1.1.2-2)

1. The authorization server associates data with the access token
   that binds this particular token to a certain client. The binding
   can utilize the client identity, but in most cases the AS utilizes
   key material (or data derived from the key material) known to the
   client.[¶](#section-4.8.1.1.2-3.1.1)
2. This key material must be distributed somehow. Either the key
   material already exists before the AS creates the binding or the
   AS creates ephemeral keys. The way pre-existing key material is
   distributed varies among the different approaches. For example,
   X.509 Certificates can be used in which case the distribution
   happens explicitly during the enrollment process. Or the key
   material is created and distributed at the TLS layer, in which
   case it might automatically happen during the setup of a TLS
   connection.[¶](#section-4.8.1.1.2-3.2.1)
3. The RS must implement the actual proof of possession check. This
   is typically done on the application level, often tied to specific
   material provided by transport layer (e.g., TLS). The RS must also
   ensure that replay of the proof of possession is not possible.[¶](#section-4.8.1.1.2-3.3.1)

There exist several proposals to demonstrate the proof of possession
in the scope of the OAuth working group:[¶](#section-4.8.1.1.2-4)

* **OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound
  Access Tokens** ([[RFC8705](#RFC8705)]): The approach as specified in this
  document allows the use of mutual TLS (mTLS) for both client
  authentication and sender-constrained access tokens. For the
  purpose of sender-constrained access tokens, the client is
  identified towards the resource server by the fingerprint of its
  public key. During processing of an access token request, the
  authorization server obtains the client's public key from the TLS
  stack and associates its fingerprint with the respective access
  tokens. The resource server in the same way obtains the public key
  from the TLS stack and compares its fingerprint with the
  fingerprint associated with the access token.[¶](#section-4.8.1.1.2-5.1.1)
* **DPoP** ([[I-D.ietf-oauth-dpop](#I-D.ietf-oauth-dpop)]): DPoP (Demonstration of
  Proof-of-Possession at the Application Layer) outlines an
  application-level sender-constraining for access and refresh
  tokens that can be used in cases where neither mTLS nor OAuth
  Token Binding (see below) are available. It uses
  proof-of-possession based on a public/private key pair and
  application-level signing. DPoP can be used with public clients
  and, in case of confidential clients, can be combined with any
  client authentication method.[¶](#section-4.8.1.1.2-5.2.1)
* **OAuth Token Binding** ([[I-D.ietf-oauth-token-binding](#I-D.ietf-oauth-token-binding)]): In this approach, an access
  token is, via the token binding ID, bound to key
  material representing a long term association between a client and
  a certain TLS host. Negotiation of the key material and proof of
  possession in the context of a TLS handshake is taken care of by
  the TLS stack. The client needs to determine the token binding ID
  of the target resource server and pass this data to the access
  token request. The authorization server then associates the access
  token with this ID. The resource server checks on every invocation
  that the token binding ID of the active TLS connection and the
  token binding ID of associated with the access token match. Since
  all crypto-related functions are covered by the TLS stack, this
  approach is very client developer friendly. As a prerequisite,
  token binding as described in [[RFC8473](#RFC8473)]
  (including federated token bindings) must be supported on all ends
  (client, authorization server, resource server).[¶](#section-4.8.1.1.2-5.3.1)
* **Signed HTTP Requests** ([[I-D.ietf-oauth-signed-http-request](#I-D.ietf-oauth-signed-http-request)]):
  This approach utilizes [[I-D.ietf-oauth-pop-key-distribution](#I-D.ietf-oauth-pop-key-distribution)] and
  represents the elements of the signature in a JSON object. The
  signature is built using JWS. The mechanism has built-in support
  for signing of HTTP method, query parameters and headers. It also
  incorporates a timestamp as basis for replay prevention.[¶](#section-4.8.1.1.2-5.4.1)
* **JWT Pop Tokens** ([[I-D.sakimura-oauth-jpop](#I-D.sakimura-oauth-jpop)]): This draft
  describes different ways to constrain access token usage, namely
  TLS or request signing. Note: Since the authors of this draft
  contributed the TLS-related proposal to [[RFC8705](#RFC8705)],
  this document only considers the request signing part. For request
  signing, the draft utilizes
  [[I-D.ietf-oauth-pop-key-distribution](#I-D.ietf-oauth-pop-key-distribution)] and [[RFC7800](#RFC7800)]. The
  signature data is represented in a JWT and JWS is used for
  signing. Replay prevention is provided by building the signature
  over a server-provided nonce, client-provided nonce and a nonce
  counter.[¶](#section-4.8.1.1.2-5.5.1)

At the time of writing, OAuth Mutual TLS is the most widely
implemented and the only standardized sender-constraining method. The
use of OAuth Mutual TLS therefore is RECOMMENDED.[¶](#section-4.8.1.1.2-6)

Note that the security of sender-constrained tokens is undermined when
an attacker gets access to the token and the key material. This is in
particular the case for corrupted client software and cross-site
scripting attacks (when the client is running in the browser). If the
key material is protected in a hardware or software security module or
only indirectly accessible (like in a TLS stack), sender-constrained
tokens at least protect against a use of the token when the client is
offline, i.e., when the security module or interface is not available
to the attacker. This applies to access tokens as well as to refresh
tokens (see [Section 4.12](#refresh_token_protection)).[¶](#section-4.8.1.1.2-7)

###### [4.8.1.1.3.](#section-4.8.1.1.3) [Audience Restricted Access Tokens](#name-audience-restricted-access-)

Audience restriction essentially restricts access tokens to a
particular resource server. The authorization server associates the
access token with the particular resource server and the resource
server SHOULD verify the intended audience. If the access token fails
the intended audience validation, the resource server must refuse to
serve the respective request.[¶](#section-4.8.1.1.3-1)

In general, audience restrictions limit the impact of token leakage.
In the case of a counterfeit resource server, it may (as described
below) also prevent abuse of the phished access token at the
legitimate resource server.[¶](#section-4.8.1.1.3-2)

The audience can be expressed using logical names or
physical addresses (like URLs). In order to prevent phishing, it is
necessary to use the actual URL the client will send requests to. In
the phishing case, this URL will point to the counterfeit resource
server. If the attacker tries to use the access token at the
legitimate resource server (which has a different URL), the resource
server will detect the mismatch (wrong audience) and refuse to serve
the request.[¶](#section-4.8.1.1.3-3)

In deployments where the authorization server knows the URLs of all
resource servers, the authorization server may just refuse to issue
access tokens for unknown resource server URLs.[¶](#section-4.8.1.1.3-4)

The client SHOULD tell the authorization server the intended
resource server. The proposed mechanism
[[I-D.ietf-oauth-resource-indicators](#I-D.ietf-oauth-resource-indicators)] could be used or by encoding the
information in the scope value.[¶](#section-4.8.1.1.3-5)

Instead of the URL, it is also possible to utilize the fingerprint of
the resource server's X.509 certificate as audience value. This
variant would also allow to detect an attempt to spoof the legitimate
resource server's URL by using a valid TLS certificate obtained from a
different CA. It might also be considered a privacy benefit to hide
the resource server URL from the authorization server.[¶](#section-4.8.1.1.3-6)

Audience restriction may seem easier to use since it does not require
any crypto on the client-side. Still, since every access token is
bound to a specific resource server, the client also needs to obtain a
single RS-specific access token when accessing several resource
servers. (Resource indicators, as specified in
[[I-D.ietf-oauth-resource-indicators](#I-D.ietf-oauth-resource-indicators)], can help to achieve this.)
[[I-D.ietf-oauth-token-binding](#I-D.ietf-oauth-token-binding)] has the same property since different
token binding ids must be associated with the access token. Using
[[RFC8705](#RFC8705)], on the other hand, allows a client to use the
access token at multiple resource servers.[¶](#section-4.8.1.1.3-7)

It shall be noted that audience restrictions, or generally speaking an
indication by the client to the authorization server where it wants to
use the access token, has additional benefits beyond the scope of
token leakage prevention. It allows the authorization server to create
different access token whose format and content is specifically minted
for the respective server. This has huge functional and privacy
advantages in deployments using structured access tokens.[¶](#section-4.8.1.1.3-8)

#### [4.8.2.](#section-4.8.2) [Compromised Resource Server](#name-compromised-resource-server)

An attacker may compromise a resource server to gain access to the
resources of the respective deployment. Such a compromise may range
from partial access to the system, e.g., its log files, to full
control of the respective server.[¶](#section-4.8.2-1)

If the attacker were able to gain full control, including shell
access, all controls can be circumvented and all resources be
accessed. The attacker would also be able to obtain other access
tokens held on the compromised system that would potentially be valid
to access other resource servers.[¶](#section-4.8.2-2)

Preventing server breaches by hardening and monitoring server systems
is considered a standard operational procedure and, therefore, out of
the scope of this document. This section focuses on the impact of
OAuth-related breaches and the replaying of captured access tokens.[¶](#section-4.8.2-3)

The following measures should be taken into account by implementers in
order to cope with access token replay by malicious actors:[¶](#section-4.8.2-4)

* Sender-constrained access tokens as described in [Section 4.8.1.1.2](#pop_tokens)
  SHOULD be used to prevent the attacker from replaying the access
  tokens on other resource servers. Depending on the severity of the
  penetration, sender-constrained access tokens will also prevent
  replay on the compromised system.[¶](#section-4.8.2-5.1.1)
* Audience restriction as described in [Section 4.8.1.1.3](#aud_restriction) SHOULD be
  used to prevent replay of captured access tokens on other resource
  servers.[¶](#section-4.8.2-5.2.1)
* The resource server MUST treat access tokens like any other
  credentials. It is considered good practice to not log them and
  not store them in plain text.[¶](#section-4.8.2-5.3.1)

The first and second recommendation also apply to other scenarios
where access tokens leak (see Attacker A5).[¶](#section-4.8.2-6)

### [4.9.](#section-4.9) [Open Redirection](#name-open-redirection)

The following attacks can occur when an AS or client has an open
redirector. An open redirector is an endpoint that forwards a user's
browser to an arbitrary URI obtained from a query parameter.[¶](#section-4.9-1)

#### [4.9.1.](#section-4.9.1) [Client as Open Redirector](#name-client-as-open-redirector)

Clients MUST NOT expose open redirectors. Attackers may use open
redirectors to produce URLs pointing to the client and utilize them to
exfiltrate authorization codes and access tokens, as described in
[Section 4.1.2](#redir_uri_open_redir). Another abuse case is to produce URLs that
appear to point to the client. This might trick users into trusting the URL
and follow it in their browser. This can be abused for phishing.[¶](#section-4.9.1-1)

In order to prevent open redirection, clients should only redirect if
the target URLs are whitelisted or if the origin and integrity of a
request can be authenticated. Countermeasures against open redirection
are described by OWASP [[owasp\_redir](#owasp_redir)].[¶](#section-4.9.1-2)

#### [4.9.2.](#section-4.9.2) [Authorization Server as Open Redirector](#name-authorization-server-as-ope)

Just as with clients, attackers could try to utilize a user's trust in
the authorization server (and its URL in particular) for performing
phishing attacks. OAuth authorization servers regularly redirect users
to other web sites (the clients), but must do so in a safe way.[¶](#section-4.9.2-1)

[[RFC6749](#RFC6749)], Section 4.1.2.1, already prevents open redirects by
stating that the AS MUST NOT automatically redirect the user agent in case
of an invalid combination of `client_id` and `redirect_uri`.[¶](#section-4.9.2-2)

However, an attacker could also utilize a correctly registered
redirect URI to perform phishing attacks. The attacker could, for
example, register a client via dynamic client registration [[RFC7591](#RFC7591)]
and intentionally send an erroneous authorization request, e.g., by
using an invalid scope value, thus instructing the AS to redirect the
user agent to its phishing site.[¶](#section-4.9.2-3)

The AS MUST take precautions to prevent this threat. Based on its risk
assessment, the AS needs to decide whether it can trust the redirect
URI and SHOULD only automatically redirect the user agent if it trusts
the redirect URI. If the URI is not trusted, the AS MAY inform the
user and rely on the user to make the correct decision.[¶](#section-4.9.2-4)

### [4.10.](#section-4.10) [307 Redirect](#name-307-redirect)

At the authorization endpoint, a typical protocol flow is that the AS
prompts the user to enter her credentials in a form that is then
submitted (using the HTTP POST method) back to the authorization
server. The AS checks the credentials and, if successful, redirects
the user agent to the client's redirection endpoint.[¶](#section-4.10-1)

In [[RFC6749](#RFC6749)], the HTTP status code 302 is used for this purpose, but
"any other method available via the user-agent to accomplish this
redirection is allowed". When the status code 307 is used for
redirection instead, the user agent will send the user credentials via
HTTP POST to the client.[¶](#section-4.10-2)

This discloses the sensitive credentials to the client. If the relying
party is malicious, it can use the credentials to impersonate the user
at the AS.[¶](#section-4.10-3)

The behavior might be unexpected for developers, but is defined in
[[RFC7231](#RFC7231)], Section 6.4.7. This status code does not require the user
agent to rewrite the POST request to a GET request and thereby drop
the form data in the POST request body.[¶](#section-4.10-4)

In the HTTP standard [[RFC7231](#RFC7231)], only the status code 303
unambigiously enforces rewriting the HTTP POST request to an HTTP GET
request. For all other status codes, including the popular 302, user
agents can opt not to rewrite POST to GET requests and therefore to
reveal the user credentials to the client. (In practice, however, most
user agents will only show this behaviour for 307 redirects.)[¶](#section-4.10-5)

AS which redirect a request that potentially contains user credentials
therefore MUST NOT use the HTTP 307 status code for redirection. If an
HTTP redirection (and not, for example, JavaScript) is used for such a
request, AS SHOULD use HTTP status code 303 "See Other".[¶](#section-4.10-6)

### [4.11.](#section-4.11) [TLS Terminating Reverse Proxies](#name-tls-terminating-reverse-pro)

A common deployment architecture for HTTP applications is to hide the
application server behind a reverse proxy that terminates the TLS
connection and dispatches the incoming requests to the respective
application server nodes.[¶](#section-4.11-1)

This section highlights some attack angles of this deployment
architecture with relevance to OAuth and gives recommendations for
security controls.[¶](#section-4.11-2)

In some situations, the reverse proxy needs to pass security-related
data to the upstream application servers for further processing.
Examples include the IP address of the request originator, token
binding ids, and authenticated TLS client certificates. This data is
usually passed in custom HTTP headers added to the upstream request.[¶](#section-4.11-3)

If the reverse proxy would pass through any header sent from the
outside, an attacker could try to directly send the faked header
values through the proxy to the application server in order to
circumvent security controls that way. For example, it is standard
practice of reverse proxies to accept `X-Forwarded-For` headers and just
add the origin of the inbound request (making it a list). Depending on
the logic performed in the application server, the attacker could
simply add a whitelisted IP address to the header and render a IP
whitelist useless.[¶](#section-4.11-4)

A reverse proxy must therefore sanitize any inbound requests to ensure
the authenticity and integrity of all header values relevant for the
security of the application servers.[¶](#section-4.11-5)

If an attacker was able to get access to the internal network between
proxy and application server, the attacker could also try to
circumvent security controls in place. It is, therefore, essential to
ensure the authenticity of the communicating entities. Furthermore,
the communication link between reverse proxy and application server
must be protected against eavesdropping, injection, and replay of
messages.[¶](#section-4.11-6)

### [4.12.](#section-4.12) [Refresh Token Protection](#name-refresh-token-protection)

Refresh tokens are a convenient and user-friendly way to obtain new access
tokens after the expiration of access tokens. Refresh tokens also add
to the security of OAuth since they allow the authorization server to issue
access tokens with a short lifetime and reduced scope thus reducing the
potential impact of access token leakage.[¶](#section-4.12-1)

#### [4.12.1.](#section-4.12.1) [Discussion](#name-discussion-2)

Refresh tokens are an attractive target for attackers since they
represent the overall grant a resource owner delegated to a certain
client. If an attacker is able to exfiltrate and successfully replay a
refresh token, the attacker will be able to mint access tokens and use
them to access resource servers on behalf of the resource owner.[¶](#section-4.12.1-1)

[[RFC6749](#RFC6749)] already provides a robust baseline protection by requiring[¶](#section-4.12.1-2)

* confidentiality of the refresh tokens in transit and storage,[¶](#section-4.12.1-3.1.1)
* the transmission of refresh tokens over TLS-protected connections between
  authorization server and client,[¶](#section-4.12.1-3.2.1)
* the authorization server to maintain and check the binding of a refresh token
  to a certain client (i.e., `client_id`),[¶](#section-4.12.1-3.3.1)
* authentication of this client during token refresh, if possible, and[¶](#section-4.12.1-3.4.1)
* that refresh tokens cannot be generated, modified, or guessed.[¶](#section-4.12.1-3.5.1)

[[RFC6749](#RFC6749)] also lays the foundation for further (implementation
specific) security measures, such as refresh token expiration and
revocation as well as refresh token rotation by defining respective
error codes and response behavior.[¶](#section-4.12.1-4)

This specification gives recommendations beyond the scope of
[[RFC6749](#RFC6749)] and clarifications.[¶](#section-4.12.1-5)

#### [4.12.2.](#section-4.12.2) [Recommendations](#name-recommendations-2)

Authorization servers SHOULD determine, based on a risk assessment,
whether to issue refresh tokens to a certain client. If the
authorization server decides not to issue refresh tokens, the client
MAY refresh access tokens by utilizing other grant types, such as the
authorization code grant type. In such a case, the authorization
server may utilize cookies and persistent grants to optimize the user
experience.[¶](#section-4.12.2-1)

If refresh tokens are issued, those refresh tokens MUST be bound to
the scope and resource servers as consented by the resource owner.
This is to prevent privilege escalation by the legitimate client and reduce
the impact of refresh token leakage.[¶](#section-4.12.2-2)

Authorization server MUST utilize one of these methods to
detect refresh token replay by malicious actors for public clients:[¶](#section-4.12.2-3)

* **Sender-constrained refresh tokens:** the authorization server
  cryptographically binds the refresh token to a certain client
  instance by utilizing [[I-D.ietf-oauth-token-binding](#I-D.ietf-oauth-token-binding)] or
  [[RFC8705](#RFC8705)].[¶](#section-4.12.2-4.1.1)
* **Refresh token rotation:** the authorization server issues a new
  refresh token with every access token refresh response. The
  previous refresh token is invalidated but information about the
  relationship is retained by the authorization server. If a refresh
  token is compromised and subsequently used by both the attacker
  and the legitimate client, one of them will present an invalidated
  refresh token, which will inform the authorization server of the
  breach. The authorization server cannot determine which party
  submitted the invalid refresh token, but it will revoke the
  active refresh token. This stops the attack at the cost of forcing
  the legitimate client to obtain a fresh authorization grant.[¶](#section-4.12.2-4.2.1)

  Implementation note: the grant to which a refresh token belongs
  may be encoded into the refresh token itself. This can enable an
  authorization server to efficiently determine the grant to which a
  refresh token belongs, and by extension, all refresh tokens that
  need to be revoked. Authorization servers MUST ensure the
  integrity of the refresh token value in this case, for example,
  using signatures.[¶](#section-4.12.2-4.2.2)

Authorization servers MAY revoke refresh tokens automatically in case
of a security event, such as:[¶](#section-4.12.2-5)

* password change[¶](#section-4.12.2-6.1.1)
* logout at the authorization server[¶](#section-4.12.2-6.2.1)

Refresh tokens SHOULD expire if the client has been inactive for some
time, i.e., the refresh token has not been used to obtain fresh access
tokens for some time. The expiration time is at the discretion of the
authorization server. It might be a global value or determined based
on the client policy or the grant associated with the refresh token
(and its sensitivity).[¶](#section-4.12.2-7)

### [4.13.](#section-4.13) [Client Impersonating Resource Owner](#name-client-impersonating-resour)

Resource servers may make access control decisions based on the
identity of the resource owner as communicated in the `sub` claim
returned by the authorization server in a token introspection response
[[RFC7662](#RFC7662)] or other mechanisms. If a client is able to choose its own
`client_id` during registration with the authorization server, then
there is a risk that it can register with the same `sub` value as a
privileged user. A subsequent access token obtained under the client
credentials grant may be mistaken for an access token authorized by the
privileged user if the resource server does not perform additional
checks.[¶](#section-4.13-1)

#### [4.13.1.](#section-4.13.1) [Countermeasures](#name-countermeasures-8)

Authorization servers SHOULD NOT allow clients to influence their
`client_id` or `sub` value or any other claim if that can cause
confusion with a genuine resource owner. Where this cannot be avoided,
authorization servers MUST provide other means for the resource server
to distinguish between access tokens authorized by a resource owner
from access tokens authorized by the client itself.[¶](#section-4.13.1-1)

### [4.14.](#section-4.14) [Clickjacking](#name-clickjacking)

As described in Section 4.4.1.9 of [[RFC6819](#RFC6819)], the authorization
request is susceptible to clickjacking. An attacker can use this
vector to obtain the user's authentication credentials, change the
scope of access granted to the client, and potentially access the
user's resources.[¶](#section-4.14-1)

Authorization servers MUST prevent clickjacking attacks. Multiple
countermeasures are described in [[RFC6819](#RFC6819)], including the use of the
X-Frame-Options HTTP response header field and frame-busting
JavaScript. In addition to those, authorization servers SHOULD also
use Content Security Policy (CSP) level 2 [[CSP-2](#CSP-2)] or greater.[¶](#section-4.14-2)

To be effective, CSP must be used on the authorization endpoint and,
if applicable, other endpoints used to authenticate the user and
authorize the client (e.g., the device authorization endpoint, login
pages, error pages, etc.). This prevents framing by unauthorized
origins in user agents that support CSP. The client MAY permit being
framed by some other origin than the one used in its redirection
endpoint. For this reason, authorization servers SHOULD allow
administrators to configure allowed origins for particular clients
and/or for clients to register these dynamically.[¶](#section-4.14-3)

Using CSP allows authorization servers to specify multiple origins in
a single response header field and to constrain these using flexible
patterns (see [[CSP-2](#CSP-2)] for details). Level 2 of this standard provides
a robust mechanism for protecting against clickjacking by using
policies that restrict the origin of frames (using `frame-ancestors`)
together with those that restrict the sources of scripts allowed to
execute on an HTML page (by using `script-src`). A non-normative
example of such a policy is shown in the following listing:[¶](#section-4.14-4)

```
HTTP/1.1 200 OK
Content-Security-Policy: frame-ancestors https://ext.example.org:8000
Content-Security-Policy: script-src 'self'
X-Frame-Options: ALLOW-FROM https://ext.example.org:8000
...

```
[¶](#section-4.14-5)

Because some user agents do not support [[CSP-2](#CSP-2)], this technique
SHOULD be combined with others, including those described in
[[RFC6819](#RFC6819)], unless such legacy user agents are explicitly unsupported
by the authorization server. Even in such cases, additional
countermeasures SHOULD still be employed.[¶](#section-4.14-6)

## [5.](#section-5) [Acknowledgements](#name-acknowledgements)

We would like to thank Jim Manico, Phil Hunt, Nat Sakimura, Christian
Mainka, Doug McDorman, Johan Peeters, Joseph Heenan, Brock Allen,
Vittorio Bertocci, David Waite, Nov Matake, Tomek Stojecki, Dominick
Baier, Neil Madden, William Dennis, Dick Hardt, Petteri Stenius,
Annabelle Richard Backman, Aaron Parecki, George Fletscher, Brian
Campbell, Konstantin Lapine, Tim W&#252;rtele, Guido Schmitz, Hans
Zandbelt, Jared Jennings, Michael Peck, Pedram Hosseyni, Michael
B. Jones, and Travis Spencer for their valuable feedback.[¶](#section-5-1)

## [6.](#section-6) [IANA Considerations](#name-iana-considerations)

This draft includes no request to IANA.[¶](#section-6-1)

## [7.](#section-7) [Security Considerations](#name-security-considerations)

All relevant security considerations have been given in the
functional specification.[¶](#section-7-1)

## [8.](#section-8) [Normative References](#name-normative-references)

[RFC8705]
Campbell, B., Bradley, J., Sakimura, N., and T. Lodderstedt, "OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens", February 2020, <<https://www.rfc-editor.org/info/rfc8705>>.
[RFC3986]
Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform Resource Identifier (URI): Generic Syntax", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <<https://www.rfc-editor.org/info/rfc3986>>.
[RFC6749]
Hardt, D., Ed., "The OAuth 2.0 Authorization Framework", RFC 6749, DOI 10.17487/RFC6749, October 2012, <<https://www.rfc-editor.org/info/rfc6749>>.
[RFC8414]
Jones, M., Sakimura, N., and J. Bradley, "OAuth 2.0 Authorization Server Metadata", RFC 8414, DOI 10.17487/RFC8414, June 2018, <<https://www.rfc-editor.org/info/rfc8414>>.
[RFC7662]
Richer, J., Ed., "OAuth 2.0 Token Introspection", RFC 7662, DOI 10.17487/RFC7662, October 2015, <<https://www.rfc-editor.org/info/rfc7662>>.
[oauth-v2-form-post-response-mode]
Jones, M. and B. Campbell, "OAuth 2.0 Form Post Response Mode", 27 April 2015, <<http://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html>>.
[OpenID]
Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, "OpenID Connect Core 1.0 incorporating errata set 1", 8 November 2014, <<http://openid.net/specs/openid-connect-core-1_0.html>>.
[RFC7636]
Sakimura, N., Ed., Bradley, J., and N. Agarwal, "Proof Key for Code Exchange by OAuth Public Clients", RFC 7636, DOI 10.17487/RFC7636, September 2015, <<https://www.rfc-editor.org/info/rfc7636>>.
[RFC6750]
Jones, M. and D. Hardt, "The OAuth 2.0 Authorization Framework: Bearer Token Usage", RFC 6750, DOI 10.17487/RFC6750, October 2012, <<https://www.rfc-editor.org/info/rfc6750>>.
[RFC6819]
Lodderstedt, T., Ed., McGloin, M., and P. Hunt, "OAuth 2.0 Threat Model and Security Considerations", RFC 6819, DOI 10.17487/RFC6819, January 2013, <<https://www.rfc-editor.org/info/rfc6819>>.
[RFC7231]
Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content", RFC 7231, DOI 10.17487/RFC7231, June 2014, <<https://www.rfc-editor.org/info/rfc7231>>.

## [9.](#section-9) [Informative References](#name-informative-references)

[owasp\_redir]
"OWASP Cheat Sheet Series - Unvalidated Redirects and Forwards", , <<https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html>>.
[RFC2119]
Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <<https://www.rfc-editor.org/info/rfc2119>>.
[oauth\_security\_ubc]
Sun, S.-T. and K. Beznosov, "The Devil is in the (Implementation) Details: An Empirical Analysis of OAuth SSO Systems", October 2012, <<http://passwordresearch.com/papers/paper267.html>>.
[I-D.ietf-oauth-signed-http-request]
Richer, J., Bradley, J., and H. Tschofenig, "A Method for Signing HTTP Requests for OAuth", Work in Progress, Internet-Draft, draft-ietf-oauth-signed-http-request-03, 8 August 2016, <<https://tools.ietf.org/html/draft-ietf-oauth-signed-http-request-03>>.
[RFC7800]
Jones, M., Bradley, J., and H. Tschofenig, "Proof-of-Possession Key Semantics for JSON Web Tokens (JWTs)", RFC 7800, DOI 10.17487/RFC7800, April 2016, <<https://www.rfc-editor.org/info/rfc7800>>.
[subdomaintakeover]
Liu, D., Hao, S., and H. Wang, "All Your DNS Records Point to Us: Understanding the Security Threats of Dangling DNS Records", 24 October 2016, <<https://www.eecis.udel.edu/~hnw/paper/ccs16a.pdf>>.
[arXiv.1704.08539]
Fett, D., Küsters, R., and G. Schmitz, "The Web SSO Standard OpenID Connect: In-Depth Formal Security Analysis and Security Guidelines", 27 April 2017, <<http://arxiv.org/abs/1704.08539/>>.
[I-D.ietf-oauth-resource-indicators]
Campbell, B., Bradley, J., and H. Tschofenig, "Resource Indicators for OAuth 2.0", Work in Progress, Internet-Draft, draft-ietf-oauth-resource-indicators-08, 11 September 2019, <<https://tools.ietf.org/html/draft-ietf-oauth-resource-indicators-08>>.
[arXiv.1601.01229]
Fett, D., Küsters, R., and G. Schmitz, "A Comprehensive Formal Security Analysis of OAuth 2.0", 6 January 2016, <<http://arxiv.org/abs/1601.01229/>>.
[arXiv.1901.11520]
Fett, D., Hosseyni, P., and R. Küsters, "An Extensive Formal Security Analysis of the OpenID Financial-grade API", 31 January 2019, <<http://arxiv.org/abs/1901.11520/>>.
[I-D.bradley-oauth-jwt-encoded-state]
Bradley, J., Lodderstedt, T., and H. Zandbelt, "Encoding claims in the OAuth 2 state parameter using a JWT", Work in Progress, Internet-Draft, draft-bradley-oauth-jwt-encoded-state-09, 4 November 2018, <<https://tools.ietf.org/html/draft-bradley-oauth-jwt-encoded-state-09>>.
[I-D.ietf-oauth-token-binding]
Jones, M., Campbell, B., Bradley, J., and W. Denniss, "OAuth 2.0 Token Binding", Work in Progress, Internet-Draft, draft-ietf-oauth-token-binding-08, 19 October 2018, <<https://tools.ietf.org/html/draft-ietf-oauth-token-binding-08>>.
[I-D.ietf-oauth-jwsreq]
Sakimura, N. and J. Bradley, "The OAuth 2.0 Authorization Framework: JWT Secured Authorization Request (JAR)", Work in Progress, Internet-Draft, draft-ietf-oauth-jwsreq-20, 21 October 2019, <<https://tools.ietf.org/html/draft-ietf-oauth-jwsreq-20>>.
[I-D.ietf-oauth-dpop]
Fett, D., Campbell, B., Bradley, J., Lodderstedt, T., Jones, M., and D. Waite, "OAuth 2.0 Demonstration of Proof-of-Possession at the Application Layer (DPoP)", Work in Progress, Internet-Draft, draft-ietf-oauth-dpop-00, 1 April 2020, <<https://tools.ietf.org/html/draft-ietf-oauth-dpop-00>>.
[I-D.ietf-oauth-pop-key-distribution]
Bradley, J., Hunt, P., Jones, M., Tschofenig, H., and M. Meszaros, "OAuth 2.0 Proof-of-Possession: Authorization Server to Client Key Distribution", Work in Progress, Internet-Draft, draft-ietf-oauth-pop-key-distribution-07, 27 March 2019, <<https://tools.ietf.org/html/draft-ietf-oauth-pop-key-distribution-07>>.
[CSP-2]
West, M., Barth, A., and D. Veditz, "Content Security Policy Level 2", July 2015, <<https://www.w3.org/TR/CSP2>>.
[RFC7591]
Richer, J., Ed., Jones, M., Bradley, J., Machulak, M., and P. Hunt, "OAuth 2.0 Dynamic Client Registration Protocol", RFC 7591, DOI 10.17487/RFC7591, July 2015, <<https://www.rfc-editor.org/info/rfc7591>>.
[webcrypto]
Watson, M., "Web Cryptography API", 26 January 2017, <<https://www.w3.org/TR/2017/REC-WebCryptoAPI-20170126/>>.
[webauthn]
Balfanz, D., Czeskis, A., Hodges, J., Jones, J.C., Jones, M.B., Kumar, A., Liao, A., Lindemann, R., and E. Lundberg, "Web Authentication: An API for accessing Public Key Credentials Level 1", 4 March 2019, <<https://www.w3.org/TR/2019/REC-webauthn-1-20190304/>>.
[webappsec-referrer-policy]
Eisinger, J. and E. Stark, "Referrer Policy", 20 April 2017, <<https://w3c.github.io/webappsec-referrer-policy>>.
[I-D.ietf-oauth-rar]
Lodderstedt, T., Richer, J., and B. Campbell, "OAuth 2.0 Rich Authorization Requests", Work in Progress, Internet-Draft, draft-ietf-oauth-rar-01, 19 February 2020, <<https://tools.ietf.org/html/draft-ietf-oauth-rar-01>>.
[I-D.ietf-oauth-par]
Lodderstedt, T., Campbell, B., Sakimura, N., Tonge, D., and F. Skokan, "OAuth 2.0 Pushed Authorization Requests", Work in Progress, Internet-Draft, draft-ietf-oauth-par-01, 18 February 2020, <<https://tools.ietf.org/html/draft-ietf-oauth-par-01>>.
[arXiv.1508.04324v2]
Mladenov, V., Mainka, C., and J. Schwenk, "On the security of modern Single Sign-On Protocols: Second-Order Vulnerabilities in OpenID Connect", 7 January 2016, <<http://arxiv.org/abs/1508.04324v2/>>.
[oauth\_security\_cmu]
Chen, E., Pei, Y., Chen, S., Tian, Y., Kotcher, R., and P. Tague, "OAuth Demystified for Mobile Application Developers", November 2014, <<http://css.csail.mit.edu/6.858/2012/readings/oauth-sso.pdf>>.
[RFC8174]
Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <<https://www.rfc-editor.org/info/rfc8174>>.
[bug.chromium]
"Referer header includes URL fragment when opening link using New Tab", , <<https://bugs.chromium.org/p/chromium/issues/detail?id=168213/>>.
[oauth\_security\_jcs\_14]
Bansal, C., Bhargavan, K., Delignat-Lavaud, A., and S. Maffeis, "Discovering concrete attacks on website authorization by formal analysis", 23 April 2014, <<https://www.doc.ic.ac.uk/~maffeis/papers/jcs14.pdf>>.
[RFC8473]
Popov, A., Nystroem, M., Balfanz, D., Ed., Harper, N., and J. Hodges, "Token Binding over HTTP", RFC 8473, DOI 10.17487/RFC8473, October 2018, <<https://www.rfc-editor.org/info/rfc8473>>.
[I-D.sakimura-oauth-jpop]
Sakimura, N., Li, K., and J. Bradley, "The OAuth 2.0 Authorization Framework: JWT Pop Token Usage", Work in Progress, Internet-Draft, draft-sakimura-oauth-jpop-05, 22 July 2019, <<https://tools.ietf.org/html/draft-sakimura-oauth-jpop-05>>.

## [Appendix A.](#section-appendix.a) [Document History](#name-document-history)

[[ To be removed from the final specification ]][¶](#section-appendix.a-1)

-15[¶](#section-appendix.a-2)

* Added info about using CSP to prevent clickjacking[¶](#section-appendix.a-3.1.1)

-14[¶](#section-appendix.a-4)

* Changes from WGLC feedback[¶](#section-appendix.a-5.1.1)
* Editorial changes[¶](#section-appendix.a-5.2.1)
* AS MUST announce PKCE support either in metadata or using deployment-specific ways (before: SHOULD)[¶](#section-appendix.a-5.3.1)

-13[¶](#section-appendix.a-6)

* Discourage use of Resource Owner Password Credentials Grant[¶](#section-appendix.a-7.1.1)
* Added text on client impersonating resource owner[¶](#section-appendix.a-7.2.1)
* Recommend asymmetric methods for client authentication[¶](#section-appendix.a-7.3.1)
* Encourage use of PKCE mode "S256"[¶](#section-appendix.a-7.4.1)
* PKCE may replace state for CSRF protection[¶](#section-appendix.a-7.5.1)
* AS SHOULD publish PKCE support[¶](#section-appendix.a-7.6.1)
* Cleaned up discussion on auth code injection[¶](#section-appendix.a-7.7.1)
* AS MUST support PKCE[¶](#section-appendix.a-7.8.1)

-12[¶](#section-appendix.a-8)

* Added updated attacker model[¶](#section-appendix.a-9.1.1)

-11[¶](#section-appendix.a-10)

* Adapted section 2.1.2 to outcome of consensus call[¶](#section-appendix.a-11.1.1)
* more text on refresh token inactivity and implementation note on refresh token replay detection via refresh token rotation[¶](#section-appendix.a-11.2.1)

-10[¶](#section-appendix.a-12)

* incorporated feedback by Joseph Heenan[¶](#section-appendix.a-13.1.1)
* changed occurrences of SHALL to MUST[¶](#section-appendix.a-13.2.1)
* added text on lack of token/cert binding support tokens issued in
  the authorization response as justification to not recommend
  issuing tokens there at all[¶](#section-appendix.a-13.3.1)
* added requirement to authenticate clients during code exchange
  (PKCE or client credential) to 2.1.1.[¶](#section-appendix.a-13.4.1)
* added section on refresh tokens[¶](#section-appendix.a-13.5.1)
* editorial enhancements to 2.1.2 based on feedback[¶](#section-appendix.a-13.6.1)

-09[¶](#section-appendix.a-14)

* changed text to recommend not to use implicit but code[¶](#section-appendix.a-15.1.1)
* added section on access token injection[¶](#section-appendix.a-15.2.1)
* reworked sections 3.1 through 3.3 to be more specific on implicit
  grant issues[¶](#section-appendix.a-15.3.1)

-08[¶](#section-appendix.a-16)

* added recommendations re implicit and token injection[¶](#section-appendix.a-17.1.1)
* uppercased key words in Section 2 according to RFC 2119[¶](#section-appendix.a-17.2.1)

-07[¶](#section-appendix.a-18)

* incorporated findings of Doug McDorman[¶](#section-appendix.a-19.1.1)
* added section on HTTP status codes for redirects[¶](#section-appendix.a-19.2.1)
* added new section on access token privilege restriction based on
  comments from Johan Peeters[¶](#section-appendix.a-19.3.1)

-06[¶](#section-appendix.a-20)

* reworked section 3.8.1[¶](#section-appendix.a-21.1.1)
* incorporated Phil Hunt's feedback[¶](#section-appendix.a-21.2.1)
* reworked section on mix-up[¶](#section-appendix.a-21.3.1)
* extended section on code leakage via referrer header to also cover
  state leakage[¶](#section-appendix.a-21.4.1)
* added Daniel Fett as author[¶](#section-appendix.a-21.5.1)
* replaced text intended to inform WG discussion by recommendations
  to implementors[¶](#section-appendix.a-21.6.1)
* modified example URLs to conform to RFC 2606[¶](#section-appendix.a-21.7.1)

-05[¶](#section-appendix.a-22)

* Completed sections on code leakage via referrer header, attacks in
  browser, mix-up, and CSRF[¶](#section-appendix.a-23.1.1)
* Reworked Code Injection Section[¶](#section-appendix.a-23.2.1)
* Added reference to OpenID Connect spec[¶](#section-appendix.a-23.3.1)
* removed refresh token leakage as respective considerations have
  been given in section 10.4 of RFC 6749[¶](#section-appendix.a-23.4.1)
* first version on open redirection[¶](#section-appendix.a-23.5.1)
* incorporated Christian Mainka's review feedback[¶](#section-appendix.a-23.6.1)

-04[¶](#section-appendix.a-24)

* Restructured document for better readability[¶](#section-appendix.a-25.1.1)
* Added best practices on Token Leakage prevention[¶](#section-appendix.a-25.2.1)

-03[¶](#section-appendix.a-26)

* Added section on Access Token Leakage at Resource Server[¶](#section-appendix.a-27.1.1)
* incorporated Brian Campbell's findings[¶](#section-appendix.a-27.2.1)

-02[¶](#section-appendix.a-28)

* Folded Mix up and Access Token leakage through a bad AS into new
  section for dynamic OAuth threats[¶](#section-appendix.a-29.1.1)
* reworked dynamic OAuth section[¶](#section-appendix.a-29.2.1)

-01[¶](#section-appendix.a-30)

* Added references to mitigation methods for token leakage[¶](#section-appendix.a-31.1.1)
* Added reference to Token Binding for Authorization Code[¶](#section-appendix.a-31.2.1)
* incorporated feedback of Phil Hunt[¶](#section-appendix.a-31.3.1)
* fixed numbering issue in attack descriptions in section 2[¶](#section-appendix.a-31.4.1)

-00 (WG document)[¶](#section-appendix.a-32)

* turned the ID into a WG document and a BCP[¶](#section-appendix.a-33.1.1)
* Added federated app login as topic in Other Topics[¶](#section-appendix.a-33.2.1)

## [Authors' Addresses](#name-authors-addresses)

Torsten Lodderstedt
yes.com
Email:
torsten@lodderstedt.net

John Bradley
Yubico
Email:
ve7jtb@ve7jtb.com

Andrey Labunets
Email:
isciurus@gmail.com

Daniel Fett
yes.com
Email:
mail@danielfett.de

[Datatracker](/doc/draft-ietf-oauth-security-topics/)

draft-ietf-oauth-security-topics-15

This is an older version of an Internet-Draft whose latest revision state is "Active".

* Info
* Contents
* Prefs

| Document | Document type |  | This is an older version of an Internet-Draft whose latest revision state is "Active". |
| --- | --- | --- | --- |
|  | Select version |  | * [00](/doc/html/draft-ietf-oauth-security-topics-00) * [01](/doc/html/draft-ietf-oauth-security-topics-01) * [02](/doc/html/draft-ietf-oauth-security-topics-02) * [03](/doc/html/draft-ietf-oauth-security-topics-03) * [04](/doc/html/draft-ietf-oauth-security-topics-04) * [05](/doc/html/draft-ietf-oauth-security-topics-05) * [06](/doc/html/draft-ietf-oauth-security-topics-06) * [07](/doc/html/draft-ietf-oauth-security-topics-07) * [08](/doc/html/draft-ietf-oauth-security-topics-08) * [09](/doc/html/draft-ietf-oauth-security-topics-09) * [10](/doc/html/draft-ietf-oauth-security-topics-10) * [11](/doc/html/draft-ietf-oauth-security-topics-11) * [12](/doc/html/draft-ietf-oauth-security-topics-12) * [13](/doc/html/draft-ietf-oauth-security-topics-13) * [14](/doc/html/draft-ietf-oauth-security-topics-14) * [15](/doc/html/draft-ietf-oauth-security-topics-15) * [16](/doc/html/draft-ietf-oauth-security-topics-16) * [17](/doc/html/draft-ietf-oauth-security-topics-17) * [18](/doc/html/draft-ietf-oauth-security-topics-18) * [19](/doc/html/draft-ietf-oauth-security-topics-19) * [20](/doc/html/draft-ietf-oauth-security-topics-20) * [21](/doc/html/draft-ietf-oauth-security-topics-21) * [22](/doc/html/draft-ietf-oauth-security-topics-22) * [23](/doc/html/draft-ietf-oauth-security-topics-23) * [24](/doc/html/draft-ietf-oauth-security-topics-24) * [25](/doc/html/draft-ietf-oauth-security-topics-25) * [26](/doc/html/draft-ietf-oauth-security-topics-26) * [27](/doc/html/draft-ietf-oauth-security-topics-27) * [28](/doc/html/draft-ietf-oauth-security-topics-28) * [29](/doc/html/draft-ietf-oauth-security-topics-29) |
|  | Compare versions |  | draft-ietf-oauth-security-topics-29  draft-ietf-oauth-security-topics-28  draft-ietf-oauth-security-topics-27  draft-ietf-oauth-security-topics-26  draft-ietf-oauth-security-topics-25  draft-ietf-oauth-security-topics-24  draft-ietf-oauth-security-topics-23  draft-ietf-oauth-security-topics-22  draft-ietf-oauth-security-topics-21  draft-ietf-oauth-security-topics-20  draft-ietf-oauth-security-topics-19  draft-ietf-oauth-security-topics-18  draft-ietf-oauth-security-topics-17  draft-ietf-oauth-security-topics-16  draft-ietf-oauth-security-topics-15  draft-ietf-oauth-security-topics-14  draft-ietf-oauth-security-topics-13  draft-ietf-oauth-security-topics-12  draft-ietf-oauth-security-topics-11  draft-ietf-oauth-security-topics-10  draft-ietf-oauth-security-topics-09  draft-ietf-oauth-security-topics-08  draft-ietf-oauth-security-topics-07  draft-ietf-oauth-security-topics-06  draft-ietf-oauth-security-topics-05  draft-ietf-oauth-security-topics-04  draft-ietf-oauth-security-topics-03  draft-ietf-oauth-security-topics-02  draft-ietf-oauth-security-topics-01  draft-ietf-oauth-security-topics-00  draft-lodderstedt-oauth-security-topics-00   draft-ietf-oauth-security-topics-29  draft-ietf-oauth-security-topics-28  draft-ietf-oauth-security-topics-27  draft-ietf-oauth-security-topics-26  draft-ietf-oauth-security-topics-25  draft-ietf-oauth-security-topics-24  draft-ietf-oauth-security-topics-23  draft-ietf-oauth-security-topics-22  draft-ietf-oauth-security-topics-21  draft-ietf-oauth-security-topics-20  draft-ietf-oauth-security-topics-19  draft-ietf-oauth-security-topics-18  draft-ietf-oauth-security-topics-17  draft-ietf-oauth-security-topics-16  draft-ietf-oauth-security-topics-15  draft-ietf-oauth-security-topics-14  draft-ietf-oauth-security-topics-13  draft-ietf-oauth-security-topics-12  draft-ietf-oauth-security-topics-11  draft-ietf-oauth-security-topics-10  draft-ietf-oauth-security-topics-09  draft-ietf-oauth-security-topics-08  draft-ietf-oauth-security-topics-07  draft-ietf-oauth-security-topics-06  draft-ietf-oauth-security-topics-05  draft-ietf-oauth-security-topics-04  draft-ietf-oauth-security-topics-03  draft-ietf-oauth-security-topics-02  draft-ietf-oauth-security-topics-01  draft-ietf-oauth-security-topics-00  draft-lodderstedt-oauth-security-topics-00   Side-by-side  Inline |
|  | Authors |  | [Torsten Lodderstedt](/person/torsten%40lodderstedt.net "Datatracker profile of Torsten Lodderstedt") , [John Bradley](/person/ve7jtb%40ve7jtb.com "Datatracker profile of John Bradley") , [Andrey Labunets](/person/isciurus%40gmail.com "Datatracker profile of Andrey Labunets") , [Daniel Fett](/person/mail%40danielfett.de "Datatracker profile of Daniel Fett") |
|  | Replaces |  | [draft-lodderstedt-oauth-security-topics](/doc/html/draft-lodderstedt-oauth-security-topics "OAuth Security Topics") |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-15.txt) [html](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-15.html) [xml](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-15.xml) [bibtex](/doc/draft-ietf-oauth-security-topics/15/bibtex/) [bibxml](/doc/bibxml3/draft-ietf-oauth-security-topics-15.xml) |
|  | Additional resources |  | [Mailing list discussion](https://mailarchive.ietf.org/arch/browse/oauth/?q=draft-ietf-oauth-security-topics) |

[Report a datatracker bug](https://github.com/ietf-tools/datatracker/issues/new/choose)

Show sidebar by default

Yes

No

Tab to show by default

Info

Contents

HTMLization configuration

HTMLize the plaintext

Plaintextify the HTML

Maximum font size

Page dependencies

Inline

Reference

Citation links

 Go to reference section

Go to linked document

![](//analytics.ietf.org/piwik.php?idsite=7)



=== Content from codeburst.io_22527a06_20250124_183240.html ===
[Open in app](https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F83968708b467&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---top_nav_layout_nav----------------------------------)

[Sign up](https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fcodeburst.io%2Fmissing-the-point-in-securing-oauth-2-0-83968708b467&source=post_page---top_nav_layout_nav-----------------------global_nav-----------)

[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Fcodeburst.io%2Fmissing-the-point-in-securing-oauth-2-0-83968708b467&source=post_page---top_nav_layout_nav-----------------------global_nav-----------)

[Write](https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---top_nav_layout_nav-----------------------new_post_topnav-----------)

[Sign up](https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fcodeburst.io%2Fmissing-the-point-in-securing-oauth-2-0-83968708b467&source=post_page---top_nav_layout_nav-----------------------global_nav-----------)

[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Fcodeburst.io%2Fmissing-the-point-in-securing-oauth-2-0-83968708b467&source=post_page---top_nav_layout_nav-----------------------global_nav-----------)

![](https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png)
# Missing the Point in Securing OAuth 2.0

[![John Tucker](https://miro.medium.com/v2/resize:fill:88:88/0*5zKfynUrJiMcxg5V.)](https://john-tucker.medium.com/?source=post_page---byline--83968708b467--------------------------------)[![codeburst](https://miro.medium.com/v2/resize:fill:48:48/1*mNmxddJJTzkiBfK77mWuGA.png)](https://codeburst.io/?source=post_page---byline--83968708b467--------------------------------)

[John Tucker](https://john-tucker.medium.com/?source=post_page---byline--83968708b467--------------------------------)

·

[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Ff3735d32c677&operation=register&redirect=https%3A%2F%2Fcodeburst.io%2Fmissing-the-point-in-securing-oauth-2-0-83968708b467&user=John+Tucker&userId=f3735d32c677&source=post_page-f3735d32c677--byline--83968708b467---------------------post_header-----------)

Published in[codeburst](https://codeburst.io/?source=post_page---byline--83968708b467--------------------------------)·6 min read·Aug 21, 2020

--

2

Listen

Share

Having a confidential client is less important than one would think. On the other hand, mitigating authorization code injection attacks should be prioritized as much as possible

![]()

**Before reading**: If you need to brush up on OAuth 2.0, and in particular the Authorization Code Grant flow, the material in [*An Illustrated Guide to OAuth and OpenID Connect*](https://developer.okta.com/blog/2019/10/21/illustrated-guide-to-oauth-and-oidc)is excellent.

**Authorization Code Grant with PKCE Flow with a Public Client**

If you read the official OAuth 2.0 documentation, you likely will walk away thinking that using the Authorization Code Grant with PKCE flow with a Public Client is a recommendation. You would not be wrong.

**Note**: PKCE is an acronym for Proof Key for Code Exchange. Also, historically, the Authorization Code Grant with PKCE flow has been relegated to mobile applications; more recently it has been extended to single-page applications (SPA).

> The Authorization Code grant type is used by confidential and public clients to exchange an authorization code for an access token.
>
> After the user returns to the client via the redirect URL, the application will get the authorization code from the URL and use it to request an access token.
>
> It is recommended that all clients use the PKCE extension with this flow as well to provide better security.

*— OAuth 2.0 —* [*OAuth 2.0*](https://oauth.net/2/)

> PKCE (RFC 7636) is an extension to the Authorization Code flow to prevent several attacks and to be able to securely perform the OAuth exchange from public clients.

*— OAuth 2.0 —* [*PKCE for OAuth 2.0*](https://oauth.net/2/pkce/)

**Note**: As a proof of concept, one can [download](https://github.com/larkintuckerllc/hello-oauth-pkce) a fully functional React web application (public client) that implements the authorization code grant with PKCE.

**Confidential v.s. Public Client**

So what is the difference between a confidential and public client?

> OAuth defines two client types, based on their ability to
>  authenticate securely with the authorization server (i.e., the ability to
>  maintain the confidentiality of their client credentials):
>
> 1.) Confidential
>  Clients capable of maintaining the confidentiality of their
>  credentials (e.g., client implemented on a secure server with
>  restricted access to the client credentials), or capable of secure
>  client authentication using other means.
>
> 2.) Public
>  Clients incapable of maintaining the confidentiality of their
>  credentials (e.g., clients executing on the device used by the
>  resource owner, such as an installed native application or a web
>  browser-based application), and incapable of secure client
>  authentication via any other means.

*— IETF—* [*RFC 6749-The OAuth 2.0 Authorization Framework*](https://tools.ietf.org/html/rfc6749)

At this point, you are likely thinking:

*How can any solution involving a public client, given that there is such a thing as a confidential client, be a recommendation?*

The key to answering this is to understand the potential attacks on OAuth 2.0 resources, and their mitigation strategies, as described in [*OAuth 2.0 Security Best Current Practice draft-ietf-oauth-security-topics-15*](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-15).

## **Attacks and Mitigation Strategies**

The first observation is that none of the attack mitigation strategies involve restricting oneself to using confidential clients.

Second, one will observe that a principal concern involves attacks on the redirect back from the authorization server in the authorization code grant flow. This concern is equally relevant whether one is using a confidential or public client. The recommended mitigation strategy in either case is PKCE.

**Note:** The other historically used OAuth 2.0 flow, Implicit Flow, is [no longer recommended](https://oauth.net/2/grant-types/implicit/).

The two often cited relevant attacks are Cross-Site Request Forgery (CSRF) and Authorization Code Injection.

**Note**: The Authorization Code Injection attack is often referred to as the Replay attack.

**Cross Site Request Forgery (CSRF)**

> An attacker might attempt to inject a request to the redirect URI of the legitimate client on the victim’s device, e.g., to cause the client to access resources under the attacker’s control. This is a variant of an attack known as Cross-Site Request Forgery (CSRF).

*— IETF —* [*OAuth 2.0 Security Best Current Practice draft-ietf-oauth-security-topics-15*](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-15)

The scenario can be visualized as follows:

![]()

*This image, and subsequent image, have been adapted from* [*An Illustrated Guide to OAuth and OpenID Connect*](https://developer.okta.com/blog/2019/10/21/illustrated-guide-to-oauth-and-oidc)

1. (*Step 1*) The resource owner is tricked into navigating to a malicious third party website
2. (*Steps 1–5*) The malicious third party performs the first portion of a legitimate authorization code grant for a resource under their control; producing a malicious authorization code
3. (*Step 5*) The malicious third party redirects the resource owner back to the client with the malicious authorization code
4. (*Step 6–8 not shown*) Without any countermeasures, the resource owner will finish up the authorization code grant to obtain tokens for a resource under the control of the malicious third party.

Here we see that PKCE is a countermeasure:

> The traditional countermeasures are CSRF tokens that are bound to the
>  user agent and passed in the “state” parameter to the authorization
>  server as described in [RFC6819]. The same protection is provided by
>  PKCE or the OpenID Connect “nonce” value.

*— IETF —* [*OAuth 2.0 Security Best Current Practice draft-ietf-oauth-security-topics-15*](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-15)

More specifically, with PKCE, the step to obtain the tokens from the authorization code requires passing a randomly generated one-time validator string is only known by the resource owner’s client (not the malicious third party). Because the malicious authorization code could not have been created using this validator, the authorization server will fail to return the tokens in this step.

**Note**: As with most things in security, the qualification is that while not impossible, it is it highly unlikely the malicious third party has access to the validator string.

**Authorization Code Injection**

> In an authorization code injection attack, the attacker attempts to inject a stolen authorization code into the attacker’s own session with the client. The aim is to associate the attacker’s session at the client with the victim’s resources or identity.

*— IETF —* [*OAuth 2.0 Security Best Current Practice draft-ietf-oauth-security-topics-15*](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-15)

The scenario can be visualized as follows:

![]()

1. (*Step 1–5*) The resource owner performs the first portion of a legitimate authorization code grant flow; producing an authorization code for his resource
2. (*Step 5*) The malicious third party prevents the resource owner’s client from receiving the authorization code and injects it into his own client
3. (*Step 6–8*) Without any countermeasures, the malicious third party finishes up the authorization code grant flow to obtain tokens for the resource owner’s resource; thus gaining access to the resource

Here, again, we see that PKCE is a countermeasure:

> The PKCE parameter “code\_challenge” along with the corresponding “code\_verifier” as specified in [RFC7636] can be used as a countermeasure.

*— IETF —* [*OAuth 2.0 Security Best Current Practice draft-ietf-oauth-security-topics-15*](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-15)

In this case, because the malicious third party does not likely have access to the resource owner client’s validator string, he cannot exchange the stolen authorization code for tokens (thus does not gain access to the resource owner’s resource).

# **Conclusion**

After examining the attacks and mitigation strategies for OAuth 2.0, it turns out that having a confidential client is not a requirement for securing OAuth 2.0 . On the other hand, preventing the effects of malicious manipulation of the Authorization Code is a requirement, with PKCE being the recommended countermeasure.

[Security](https://medium.com/tag/security?source=post_page-----83968708b467--------------------------------)[Oauth](https://medium.com/tag/oauth?source=post_page-----83968708b467--------------------------------)[Pkce](https://medium.com/tag/pkce?source=post_page-----83968708b467--------------------------------)

--

--

2

[![codeburst](https://miro.medium.com/v2/resize:fill:96:96/1*mNmxddJJTzkiBfK77mWuGA.png)](https://codeburst.io/?source=post_page---post_publication_info--83968708b467--------------------------------)[![codeburst](https://miro.medium.com/v2/resize:fill:128:128/1*mNmxddJJTzkiBfK77mWuGA.png)](https://codeburst.io/?source=post_page---post_publication_info--83968708b467--------------------------------)[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Fcodeburst&operation=register&redirect=https%3A%2F%2Fcodeburst.io%2Fmissing-the-point-in-securing-oauth-2-0-83968708b467&collection=codeburst&collectionId=61061eb0c96b&source=post_page---post_publication_info--83968708b467---------------------follow_profile-----------)[## Published in codeburst](https://codeburst.io/?source=post_page---post_publication_info--83968708b467--------------------------------)[105K Followers](/followers?source=post_page---post_publication_info--83968708b467--------------------------------)·[Last published May 19, 2021](/installing-backpack-for-laravel-modules-with-a-line-of-command-eda01d72639f?source=post_page---post_publication_info--83968708b467--------------------------------)

Bursts of code to power through your day. Web Development articles, tutorials, and news.

[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Fcodeburst&operation=register&redirect=https%3A%2F%2Fcodeburst.io%2Fmissing-the-point-in-securing-oauth-2-0-83968708b467&collection=codeburst&collectionId=61061eb0c96b&source=post_page---post_publication_info--83968708b467---------------------follow_profile-----------)[![John Tucker](https://miro.medium.com/v2/resize:fill:96:96/0*5zKfynUrJiMcxg5V.)](https://john-tucker.medium.com/?source=post_page---post_author_info--83968708b467--------------------------------)[![John Tucker](https://miro.medium.com/v2/resize:fill:128:128/0*5zKfynUrJiMcxg5V.)](https://john-tucker.medium.com/?source=post_page---post_author_info--83968708b467--------------------------------)[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Ff3735d32c677&operation=register&redirect=https%3A%2F%2Fcodeburst.io%2Fmissing-the-point-in-securing-oauth-2-0-83968708b467&user=John+Tucker&userId=f3735d32c677&source=post_page-f3735d32c677--post_author_info--83968708b467---------------------follow_profile-----------)[## Written by John Tucker](https://john-tucker.medium.com/?source=post_page---post_author_info--83968708b467--------------------------------)[5.2K Followers](https://john-tucker.medium.com/followers?source=post_page---post_author_info--83968708b467--------------------------------)·[26 Following](https://medium.com/%40john-tucker/following?source=post_page---post_author_info--83968708b467--------------------------------)

Broad infrastructure, development, and soft-skill background

[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Ff3735d32c677&operation=register&redirect=https%3A%2F%2Fcodeburst.io%2Fmissing-the-point-in-securing-oauth-2-0-83968708b467&user=John+Tucker&userId=f3735d32c677&source=post_page-f3735d32c677--post_author_info--83968708b467---------------------follow_profile-----------)
## Responses (2)

See all responses[Help](https://help.medium.com/hc/en-us?source=post_page-----83968708b467--------------------------------)[Status](https://medium.statuspage.io/?source=post_page-----83968708b467--------------------------------)[About](https://medium.com/about?autoplay=1&source=post_page-----83968708b467--------------------------------)[Careers](https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=post_page-----83968708b467--------------------------------)[Press](pressinquiries%40medium.com?source=post_page-----83968708b467--------------------------------)[Blog](https://blog.medium.com/?source=post_page-----83968708b467--------------------------------)[Privacy](https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----83968708b467--------------------------------)[Terms](https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----83968708b467--------------------------------)[Text to speech](https://speechify.com/medium?source=post_page-----83968708b467--------------------------------)[Teams](https://medium.com/business?source=post_page-----83968708b467--------------------------------)



=== Content from github.com_bb0385da_20250124_183244.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Foauthjs%2Fnode-oauth2-server%2Fpull%2F452)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Foauthjs%2Fnode-oauth2-server%2Fpull%2F452)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fpull_requests_fragments%2Fpull_request_layout&source=header-repo&source_repo=oauthjs%2Fnode-oauth2-server)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[oauthjs](/oauthjs)
/
**[node-oauth2-server](/oauthjs/node-oauth2-server)**
Public

* [Notifications](/login?return_to=%2Foauthjs%2Fnode-oauth2-server) You must be signed in to change notification settings
* [Fork
  931](/login?return_to=%2Foauthjs%2Fnode-oauth2-server)
* [Star
   4k](/login?return_to=%2Foauthjs%2Fnode-oauth2-server)

* [Code](/oauthjs/node-oauth2-server)
* [Issues
  159](/oauthjs/node-oauth2-server/issues)
* [Pull requests
  30](/oauthjs/node-oauth2-server/pulls)
* [Actions](/oauthjs/node-oauth2-server/actions)
* [Projects
  0](/oauthjs/node-oauth2-server/projects)
* [Wiki](/oauthjs/node-oauth2-server/wiki)
* [Security](/oauthjs/node-oauth2-server/security)
* [Insights](/oauthjs/node-oauth2-server/pulse)

Additional navigation options

* [Code](/oauthjs/node-oauth2-server)
* [Issues](/oauthjs/node-oauth2-server/issues)
* [Pull requests](/oauthjs/node-oauth2-server/pulls)
* [Actions](/oauthjs/node-oauth2-server/actions)
* [Projects](/oauthjs/node-oauth2-server/projects)
* [Wiki](/oauthjs/node-oauth2-server/wiki)
* [Security](/oauthjs/node-oauth2-server/security)
* [Insights](/oauthjs/node-oauth2-server/pulse)

New issue

**Have a question about this project?** Sign up for a free GitHub account to open an issue and contact its maintainers and the community.

 [Sign up for GitHub](/signup?return_to=%2Foauthjs%2Fnode-oauth2-server%2Fissues%2Fnew%2Fchoose)

By clicking “Sign up for GitHub”, you agree to our [terms of service](https://docs.github.com/terms) and
[privacy statement](https://docs.github.com/privacy). We’ll occasionally send you account related emails.

Already on GitHub?
[Sign in](/login?return_to=%2Foauthjs%2Fnode-oauth2-server%2Fissues%2Fnew%2Fchoose)
to your account

[Jump to bottom](#issue-comment-box)

# PKCE #452

 Open

[visvk](/visvk)
wants to merge
4
commits into
[oauthjs:dev](/oauthjs/node-oauth2-server/tree/dev "oauthjs/node-oauth2-server:dev")
*base:*
dev

Choose a base branch

Branches
Tags

Could not load branches

Branch not found: **{{ refName }}**

 Loading

{{ refName }}
default

Could not load tags

Nothing to show

{{ refName }}
default

 Loading

### Are you sure you want to change the base?

Some commits from the old base branch may be removed from the timeline,
and old review comments may become outdated.

 Loading

Change base

from
[visvk:pkce](/visvk/node-oauth2-server/tree/pkce "visvk/node-oauth2-server:pkce")

 Open

# [PKCE](#top) #452

[visvk](/visvk)
wants to merge
4
commits into
[oauthjs:dev](/oauthjs/node-oauth2-server/tree/dev "oauthjs/node-oauth2-server:dev")
from
[visvk:pkce](/visvk/node-oauth2-server/tree/pkce "visvk/node-oauth2-server:pkce")

[Conversation
27](/oauthjs/node-oauth2-server/pull/452)
[Commits
4](/oauthjs/node-oauth2-server/pull/452/commits)
[Checks
0](/oauthjs/node-oauth2-server/pull/452/checks)
[Files changed](/oauthjs/node-oauth2-server/pull/452/files)

## Conversation

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

[![visvk](https://avatars.githubusercontent.com/u/4169046?s=60&v=4)](/visvk)

Copy link

Contributor

### @visvk **[visvk](/visvk)** commented [Oct 28, 2017](#issue-269350795) • edited Loading

Implementation of [rfc7636 Proof Key for Code Exchange by OAuth Public Clients](https://tools.ietf.org/html/rfc7636)

Notes:

* ~~`model.generateAuthorizationCode` is called with 2 new parameters (in total 5) `codeChallenge` and `codeChallengeMethod`. Typically, the "code\_challenge" and "code\_challenge\_method" values

  are stored in encrypted form in the "code" itself but could

  alternatively be stored on the server associated with the code.~~ This can be a breaking change, so I've removed this part of code
* `model.saveAuthorizationCode`: added `codeChallenge` and `codeChallengeMethod` to the code object. We need to store the code challenge and it's method server side and then return it later on.
* `model.getAuthorizationCode` when code was issued with PKCE parameters, it should return these parameters in the `code` object. Then the `code_verifier` is validated

TODO:

* ~~client\_secret should not be required~~ possible with `isClientAuthenticationRequired` option

Feedback is welcome!

Sorry, something went wrong.

 👍
8
 yamafaktory, wearhere, luckv, flowersinthesand, benaubin, edvincandon, KingRial, and HappyZombies reacted with thumbs up emoji

All reactions

* 👍
  8 reactions

[![@visvk](https://avatars.githubusercontent.com/u/4169046?s=40&v=4)](/visvk)
[visvk](/visvk)
mentioned this pull request
[Oct 28, 2017](#ref-issue-260510219)

[Support for code\_verifier and code\_challenge
#441](/oauthjs/node-oauth2-server/issues/441)

Open

[![mjsalinger](https://avatars.githubusercontent.com/u/2452620?s=60&v=4)](/mjsalinger)

**[mjsalinger](/mjsalinger)**
suggested changes
[Jan 24, 2018](#pullrequestreview-91162904)

 [View reviewed changes](/oauthjs/node-oauth2-server/pull/452/files)

Copy link

Contributor

### @mjsalinger **[mjsalinger](/mjsalinger)** left a comment

There was a problem hiding this comment.

### Choose a reason for hiding this comment

The reason will be displayed to describe this comment to others. [Learn more](https://docs.github.com/articles/managing-disruptive-comments/#hiding-a-comment).

Choose a reason

Spam
Abuse
Off Topic
Outdated
Duplicate
Resolved

Hide comment

Can this PR be refactored in a way that a) doesn't make it a breaking change, and b) ensures that the PKCE is optional. One possible way to do this would be to have a separate (optional) model method to handle the PKCE after the generateAuthorizationCode method is invoked and resolved.

Sorry, something went wrong.

All reactions

[![@mjsalinger](https://avatars.githubusercontent.com/u/2452620?s=80&u=bef792180718f1444ebd92167eda2e502bb51f92&v=4)](/mjsalinger)

Copy link

Contributor

### **[mjsalinger](/mjsalinger)** commented [Jan 24, 2018](#issuecomment-360119854)

| Also please change the PR to point to the `dev` branch instead of `master`. |
| --- |

All reactions

Sorry, something went wrong.

 [![@visvk](https://avatars.githubusercontent.com/u/4169046?s=40&v=4)](/visvk)
[visvk](/visvk)
changed the base branch from
master

to
dev

[May 29, 2018 10:18](#event-1650719991)

 [![@visvk](https://avatars.githubusercontent.com/u/4169046?s=40&v=4)](/visvk)
[visvk](/visvk)
[force-pushed](/oauthjs/node-oauth2-server/compare/009671b2d81a5112383f97ece42d8c287995c2ac..c3ecebad1e5b1b116a4ba3a0d28b4d75a1d140ec)
the
pkce

branch
from
[`009671b`](/oauthjs/node-oauth2-server/commit/009671b2d81a5112383f97ece42d8c287995c2ac) to
[`c3eceba`](/oauthjs/node-oauth2-server/commit/c3ecebad1e5b1b116a4ba3a0d28b4d75a1d140ec)  [Compare](/oauthjs/node-oauth2-server/compare/009671b2d81a5112383f97ece42d8c287995c2ac..c3ecebad1e5b1b116a4ba3a0d28b4d75a1d140ec)
[May 29, 2018 10:50](#event-1650777075)

[![@visvk](https://avatars.githubusercontent.com/u/4169046?s=40&v=4)](/visvk)

`[PKCE - implementation](/oauthjs/node-oauth2-server/pull/452/commits/8de145fa3a4c19d3d0a15588e25b313689000bc4 "PKCE - implementation")`

`[8de145f](/oauthjs/node-oauth2-server/pull/452/commits/8de145fa3a4c19d3d0a15588e25b313689000bc4)`

 [![@visvk](https://avatars.githubusercontent.com/u/4169046?s=40&v=4)](/visvk)
[visvk](/visvk)
[force-pushed](/oauthjs/node-oauth2-server/compare/c3ecebad1e5b1b116a4ba3a0d28b4d75a1d140ec..8de145fa3a4c19d3d0a15588e25b313689000bc4)
the
pkce

branch
from
[`c3eceba`](/oauthjs/node-oauth2-server/commit/c3ecebad1e5b1b116a4ba3a0d28b4d75a1d140ec) to
[`8de145f`](/oauthjs/node-oauth2-server/commit/8de145fa3a4c19d3d0a15588e25b313689000bc4)  [Compare](/oauthjs/node-oauth2-server/compare/c3ecebad1e5b1b116a4ba3a0d28b4d75a1d140ec..8de145fa3a4c19d3d0a15588e25b313689000bc4)
[May 29, 2018 10:54](#event-1650783502)

[![@visvk](https://avatars.githubusercontent.com/u/4169046?s=40&v=4)](/visvk)

`[Merge dev into pkce](/oauthjs/node-oauth2-server/pull/452/commits/0bf106198eea34722e4ac94406aca1ca46f10483 "Merge dev into pkce")`

`[0bf1061](/oauthjs/node-oauth2-server/pull/452/commits/0bf106198eea34722e4ac94406aca1ca46f10483)`

 [![@visvk](https://avatars.githubusercontent.com/u/4169046?s=40&v=4)](/visvk)
[visvk](/visvk)
[force-pushed](/oauthjs/node-oauth2-server/compare/ab5c931ff7e12d1163911d57217216ffb7744b6c..e4715e479565f787d759c4745836db828c30e324)
the
pkce

branch
from
[`ab5c931`](/oauthjs/node-oauth2-server/commit/ab5c931ff7e12d1163911d57217216ffb7744b6c) to
[`e4715e4`](/oauthjs/node-oauth2-server/commit/e4715e479565f787d759c4745836db828c30e324)  [Compare](/oauthjs/node-oauth2-server/compare/ab5c931ff7e12d1163911d57217216ffb7744b6c..e4715e479565f787d759c4745836db828c30e324)
[June 1, 2018 09:16](#event-1657866188)

[![@visvk](https://avatars.githubusercontent.com/u/4169046?s=40&v=4)](/visvk)

`[prevent empty code challenge and undo refactor](/oauthjs/node-oauth2-server/pull/452/commits/9c94bba77fe017eb99af0943934c75b11685e31b "prevent empty code challenge and undo refactor")`

`[9c94bba](/oauthjs/node-oauth2-server/pull/452/commits/9c94bba77fe017eb99af0943934c75b11685e31b)`

 [![@visvk](https://avatars.githubusercontent.com/u/4169046?s=40&v=4)](/visvk)
[visvk](/visvk)
[force-pushed](/oauthjs/node-oauth2-server/compare/e4715e479565f787d759c4745836db828c30e324..9c94bba77fe017eb99af0943934c75b11685e31b)
the
pkce

branch
from
[`e4715e4`](/oauthjs/node-oauth2-server/commit/e4715e479565f787d759c4745836db828c30e324) to
[`9c94bba`](/oauthjs/node-oauth2-server/commit/9c94bba77fe017eb99af0943934c75b11685e31b)  [Compare](/oauthjs/node-oauth2-server/compare/e4715e479565f787d759c4745836db828c30e324..9c94bba77fe017eb99af0943934c75b11685e31b)
[June 1, 2018 09:18](#event-1657871331)

[![@visvk](https://avatars.githubusercontent.com/u/4169046?s=40&v=4)](/visvk)
[visvk](/visvk)
mentioned this pull request
[Jun 1, 2018](#ref-issue-328460502)

[Public and confidential clients
#498](/oauthjs/node-oauth2-server/issues/498)

Open

[![@patrykcieszkowski](https://avatars.githubusercontent.com/u/16166259?s=80&u=af277b196c7bd652126a01751150955e1eb2768a&v=4)](/patrykcieszkowski)

Copy link

### **[patrykcieszkowski](/patrykcieszkowski)** commented [Jun 28, 2018](#issuecomment-400981477)

| Hang on, is this full implementation OF PKCE? |
| --- |

All reactions

Sorry, something went wrong.

[![@visvk](https://avatars.githubusercontent.com/u/4169046?s=80&v=4)](/visvk)

Copy link

Contributor

Author

### **[visvk](/visvk)** commented [Jun 28, 2018](#issuecomment-401022797)

| This PR supports **code\_challenge** parameter and **code\_challenge\_method** parameter to be saved with the authorization code. Then it supports validation of **code\_verifier** when requesting access token.  What is missing, **code\_challenge** parameter and **code\_challenge\_method** parameter are not passed to the **model.generateAuthorizationCode** method, because it will be a breaking change.  If is something wrong or missing, please send a feedback. |
| --- |

All reactions

Sorry, something went wrong.

[![@patrykcieszkowski](https://avatars.githubusercontent.com/u/16166259?s=80&u=af277b196c7bd652126a01751150955e1eb2768a&v=4)](/patrykcieszkowski)

Copy link

### **[patrykcieszkowski](/patrykcieszkowski)** commented [Jun 28, 2018](#issuecomment-401078121) • edited Loading

| Yeah, but there's still an issue with missing `client_secret`, right? Although you proposed to use `requireClientAuthentication` model option, I don't see it as good enough workaround. That would mean the `authorization_code` grant stays unsecured. Or am I wrong?  The `Invalid client: cannot retrieve client credentials` error is being thrown at `token-handler.js` (line 196. Method `getClientCredentials`). Do you think adding `OR condition` at line 190, and verifying that the `code_verifier` param was passed would do the trick?  But that also means, `codeChallenge` validation (at `authorization-code-grant-type.js` line 135) has to be modified. Currently, it only compares the `codeChallange` and `code_verifier` if `codeChallange` got returned from `model.getAuthorizationCode`. IMO, it should throw an error if `code_verifier` was passed, but DB query did not return it. |
| --- |

All reactions

Sorry, something went wrong.

[![@visvk](https://avatars.githubusercontent.com/u/4169046?s=80&v=4)](/visvk)

Copy link

Contributor

Author

### **[visvk](/visvk)** commented [Jun 29, 2018](#issuecomment-401318825)

| Thank you for the feedback. Yes, I didn't find better solution for ignoring client\_secret. As you stated, `requireClientAuthentication` is not good solution. In this implementation, you can pass client\_secret in the PKCE flow, but I know that there are some android oauth packages, that don't support client\_secret. Moreover be aware, in the refresh token grant type you must still pass client\_secret. In my opinion, better solution would be to implement `client.confidential` parameter, so there won't be client auth for non-confidential clients ([#498](https://github.com/oauthjs/node-oauth2-server/issues/498) ).  I can add a change in `codeChallenge` validation, but in that validation, the server does not know if the code was issued by PKCE flow or not, and throw error when code was not issued by PKCE flow is not good. So I assume, the validation should be done only if `code.codeChallenge` is present. |
| --- |

All reactions

Sorry, something went wrong.

[![@patrykcieszkowski](https://avatars.githubusercontent.com/u/16166259?s=80&u=af277b196c7bd652126a01751150955e1eb2768a&v=4)](/patrykcieszkowski)

Copy link

### **[patrykcieszkowski](/patrykcieszkowski)** commented [Jul 2, 2018](#issuecomment-401771452)

| excuse my ignorance, but Isn't the idea of PKCE flow to eliminate the need of passing client\_secret? I thought it's the main point, is to be used as a public auth method. For mobile apps or web apps.  I need that change ASAP. So for the time being, I will pull your PR and modify it for my own needs for my Oauth2 server. But I will keep track of changes you make, though. Maybe you'll come up with something better. |
| --- |

All reactions

Sorry, something went wrong.

[![@visvk](https://avatars.githubusercontent.com/u/4169046?s=80&v=4)](/visvk)

Copy link

Contributor

Author

### **[visvk](/visvk)** commented [Jul 2, 2018](#issuecomment-401800562)

| No, idea of PKCE describes technique to mitigate against the authorization code interception attack.  I agree, that public clients should not use client\_secret (as per rfc8252), but the server should assume client confidentiality by `client_id` (confidentiality of app should be stored in client registration process).  You have provided solution, where server assume client confidentiality by passing `code_verifier` in the request.  Yes, you should make your own fork, because any PR can be changed or deleted and then you can be in troubles. |
| --- |

All reactions

Sorry, something went wrong.

[![@VDGSecurity](https://avatars.githubusercontent.com/u/39366412?s=40&v=4)](/VDGSecurity)
[VDGSecurity](/VDGSecurity)
mentioned this pull request
[Jul 31, 2018](#ref-issue-327689326)

[Plan next v3 release
#496](/oauthjs/node-oauth2-server/issues/496)

Open

[![@mjsalinger](https://avatars.githubusercontent.com/u/2452620?s=80&u=bef792180718f1444ebd92167eda2e502bb51f92&v=4)](/mjsalinger)

Copy link

Contributor

### **[mjsalinger](/mjsalinger)** commented [Aug 7, 2018](#issuecomment-411030878)

| [@visvk](https://github.com/visvk) Can you rebase this PR to get rid of the conflicts? |
| --- |

All reactions

Sorry, something went wrong.

[![@visvk](https://avatars.githubusercontent.com/u/4169046?s=80&v=4)](/visvk)

Copy link

Contributor

Author

### **[visvk](/visvk)** commented [Aug 7, 2018](#issuecomment-411063170)

| Sorry, but there are many conflicts in the rebase process. Merging dev into this PR would be ok? I need to refactor authorize handler to resolve conflicts. |
| --- |

All reactions

Sorry, something went wrong.

[![@mjsalinger](https://avatars.githubusercontent.com/u/2452620?s=80&u=bef792180718f1444ebd92167eda2e502bb51f92&v=4)](/mjsalinger)

Copy link

Contributor

### **[mjsalinger](/mjsalinger)** commented [Aug 8, 2018](#issuecomment-411376546)

| [@visvk](https://github.com/visvk) That should be fine. |
| --- |

All reactions

Sorry, something went wrong.

[![@visvk](https://avatars.githubusercontent.com/u/4169046?s=40&v=4)](/visvk)

`[Merge branch 'dev' into pkce, refactor authorization handler](/oauthjs/node-oauth2-server/pull/452/commits/613f0c1d7fb1d2fe378dc3ef6bd423cb0dc2e8e0 "Merge branch 'dev' into pkce, refactor authorization handler

- move getCodeChallenge, getCodeChallengeMethod to code-response-type.js")`
 …

`[613f0c1](/oauthjs/node-oauth2-server/pull/452/commits/613f0c1d7fb1d2fe378dc3ef6bd423cb0dc2e8e0)`

```
- move getCodeChallenge, getCodeChallengeMethod to code-response-type.js
```

[![@visvk](https://avatars.githubusercontent.com/u/4169046?s=80&v=4)](/visvk)

Copy link

Contributor

Author

### **[visvk](/visvk)** commented [Aug 9, 2018](#issuecomment-411761796)

| [@mjsalinger](https://github.com/mjsalinger) done. |
| --- |

All reactions

Sorry, something went wrong.

[![@yhc44](https://avatars.githubusercontent.com/u/39420253?s=80&u=c7649f9c7b3be19fbc4426ef881be431093d2c75&v=4)](/yhc44)

Copy link

### **[yhc44](/yhc44)** commented [Nov 27, 2018](#issuecomment-442079089)

| When can we expect PKCE in official version?  Thanks :) |
| --- |

All reactions

Sorry, something went wrong.

[![@yhc44](https://avatars.githubusercontent.com/u/39420253?s=80&u=c7649f9c7b3be19fbc4426ef881be431093d2c75&v=4)](/yhc44)

Copy link

### **[yhc44](/yhc44)** commented [Nov 28, 2018](#issuecomment-442391822) • edited Loading

| Ok i now used your version and changed it a bit and its fully working in my SPA Application.  Thanks for your work [@visvk](https://github.com/visvk) |
| --- |

All reactions

Sorry, something went wrong.

[![@visvk](https://avatars.githubusercontent.com/u/4169046?s=80&v=4)](/visvk)

Copy link

Contributor

Author

### **[visvk](/visvk)** commented [Nov 28, 2018](#issuecomment-442420000)

| [@yhc44](https://github.com/yhc44) Do you want to use this feature in your SPA app? Because SPAs would not benefit from PKCE. PKCE is only useful in public native clients (mobile apps). |
| --- |

 👎
2
 htunnicliff and lingqingmeng reacted with thumbs down emoji

All reactions

* 👎
  2 reactions

Sorry, something went wrong.

[![@yhc44](https://avatars.githubusercontent.com/u/39420253?s=80&u=c7649f9c7b3be19fbc4426ef881be431093d2c75&v=4)](/yhc44)

Copy link

### **[yhc44](/yhc44)** commented [Nov 28, 2018](#issuecomment-442421637)

| [@visvk](https://github.com/visvk) Actually i've read that it is better than implicit grant.  I dont want to use authorization grant with secret. Is it the same as PKCE in SPA?  What do you recommend? |
| --- |

All reactions

Sorry, something went wrong.

[![@ReeSilva](https://avatars.githubusercontent.com/u/3605032?s=80&v=4)](/ReeSilva)

Copy link

### **[ReeSilva](/ReeSilva)** commented [Dec 13, 2018](#issuecomment-447099954)

| Hey guys. First of all, awesome work on this lib. Save me a loooot of time.  There's any ETA on this feature? This is almost a must have to the authorization server that I'm building for my client.  Thanks in advance. |
| --- |

 👍
3
 toonvanstrijp, etrobert, and lingqingmeng reacted with thumbs up emoji

All reactions

* 👍
  3 reactions

Sorry, something went wrong.

[![@toonvanstrijp](https://avatars.githubusercontent.com/u/11893063?s=80&u=bfdeb431bdf6c7926f48ca3ae28456c2f560ab1b&v=4)](/toonvanstrijp)

Copy link

### **[toonvanstrijp](/toonvanstrijp)** commented [Dec 23, 2018](#issuecomment-449634560)

| Any idea of when this will be merged? |
| --- |

 👍
4
 sheltonial, benaubin, murraybauer, and etrobert reacted with thumbs up emoji

All reactions

* 👍
  4 reactions

Sorry, something went wrong.

[![@benaubin](https://avatars.githubusercontent.com/u/7585353?s=80&u=4d2f838e154e4c86e293e6e82089074f25d2b6aa&v=4)](/benaubin)

Copy link

### **[benaubin](/benaubin)** commented [Apr 20, 2019](#issuecomment-485149201)

| [@visvk](https://github.com/visvk) What's the status on this? |
| --- |

All reactions

Sorry, something went wrong.

[![@Rmannn](https://avatars.githubusercontent.com/u/12893006?s=80&u=98d56462a9699be30ee0f36714d1b2c6f470b584&v=4)](/Rmannn)

Copy link

### **[Rmannn](/Rmannn)** commented [Jan 18, 2020](#issuecomment-575843057)

| any news on this PR ? |
| --- |

 👍
2
 kiurchv and natepelzel reacted with thumbs up emoji

All reactions

* 👍
  2 reactions

Sorry, something went wrong.

[![@thomseddon](https://avatars.githubusercontent.com/u/747138?s=40&u=c86e3d2d56f28e67e39a97c94d9042a3c4e0139f&v=4)](/thomseddon)
[thomseddon](/thomseddon)
closed this
[Jan 28, 2020](#event-2987268914)

[![@mitjap](https://avatars.githubusercontent.com/u/1507299?s=80&u=4b97170903a7f9d99da8fc697a98a3887469b78f&v=4)](/mitjap)

Copy link

### **[mitjap](/mitjap)** commented [Mar 23, 2020](#issuecomment-602895814)

| [@yhc44](https://github.com/yhc44) Do you want to use this feature in your SPA app? Because SPAs would not benefit from PKCE. PKCE is only useful in public native clients (mobile apps).  I'm quoting [oauth.net](https://oauth.net/2/pkce/) which states that PKCE is meant for SPAs.  PKCE (RFC 7636) is an extension to the Authorization Code flow to prevent certain attacks and to be able to securely perform the OAuth exchange from public clients.  It is primarily used by mobile and JavaScript apps, but the technique can be applied to any client as well. |
| --- |

All reactions

Sorry, something went wrong.

[![@Zireael](https://avatars.githubusercontent.com/u/3856578?s=80&u=48e7244378c43b4fbe16b2476dc75f55d163ae3d&v=4)](/Zireael)

Copy link

### **[Zireael](/Zireael)** commented [May 16, 2020](#issuecomment-629624847)

| could PKCE be merged into the `v5-dev`? |
| --- |

 👀
1
 Rmannn reacted with eyes emoji

All reactions

* 👀
  1 reaction

Sorry, something went wrong.

[![@thomseddon](https://avatars.githubusercontent.com/u/747138?s=40&u=c86e3d2d56f28e67e39a97c94d9042a3c4e0139f&v=4)](/thomseddon)
[thomseddon](/thomseddon)
reopened this
[May 28, 2020](#event-3381618023)

[![@thomseddon](https://avatars.githubusercontent.com/u/747138?s=40&u=c86e3d2d56f28e67e39a97c94d9042a3c4e0139f&v=4)](/thomseddon)
[thomseddon](/thomseddon)
mentioned this pull request
[May 28, 2020](#ref-issue-577024977)

[Any plans to add PKCE support to V5 branch?
#604](/oauthjs/node-oauth2-server/issues/604)

Closed

[![@Rmannn](https://avatars.githubusercontent.com/u/12893006?s=80&u=98d56462a9699be30ee0f36714d1b2c6f470b584&v=4)](/Rmannn)

Copy link

### **[Rmannn](/Rmannn)** commented [Jun 25, 2020](#issuecomment-649552132)

| 6 month later... Please is there any plan to merge this ? We are waiting for this feature. Thx |
| --- |

All reactions

Sorry, something went wrong.

[![@patrykcieszkowski](https://avatars.githubusercontent.com/u/16166259?s=80&u=af277b196c7bd652126a01751150955e1eb2768a&v=4)](/patrykcieszkowski)

Copy link

### **[patrykcieszkowski](/patrykcieszkowski)** commented [Jun 25, 2020](#issuecomment-649615232)

| [@Rmannn](https://github.com/Rmannn) why don't you make a fork of this repo and merge it yourself, while waiting for the official release? |
| --- |

All reactions

Sorry, something went wrong.

[![@Rmannn](https://avatars.githubusercontent.com/u/12893006?s=80&u=98d56462a9699be30ee0f36714d1b2c6f470b584&v=4)](/Rmannn)

Copy link

### **[Rmannn](/Rmannn)** commented [Jun 25, 2020](#issuecomment-649623322) • edited Loading

| [@patrykcieszkowski](https://github.com/patrykcieszkowski) cause apparently they are not going to merge this pr anytime soon. Even in the next release. This Pr was created in 2017... 3 years ago ?! If our team really need to fork, merge, and publish it to npm, we will simply rewrite the whole lib. This library is getting old, PRs are staying there for months, and v5-dev (typescript rewrite) code is going to be discarded.  We are really thankful for this library, but we simply do not want to loose more time waiting for things that are not going to happen |
| --- |

All reactions

Sorry, something went wrong.

[![@thomseddon](https://avatars.githubusercontent.com/u/747138?s=80&u=c86e3d2d56f28e67e39a97c94d9042a3c4e0139f&v=4)](/thomseddon)

Copy link

Member

### **[thomseddon](/thomseddon)** commented [Jun 25, 2020](#issuecomment-649633022)

| This isn't pegged for the next release - it's also a bit of a whopper so would need a bit of time for review, but would be brilliant for 4.1 |
| --- |

All reactions

Sorry, something went wrong.

[![@thomseddon](https://avatars.githubusercontent.com/u/747138?s=40&u=c86e3d2d56f28e67e39a97c94d9042a3c4e0139f&v=4)](/thomseddon)
[thomseddon](/thomseddon)
mentioned this pull request
[Aug 6, 2020](#ref-issue-657747248)

[Multiple Security Vulnerabilities in Auth and Token Endpoint
#637](/oauthjs/node-oauth2-server/issues/637)

Open

[![@mraffo](https://avatars.githubusercontent.com/u/263420?s=80&u=a0f7de6d7d747557cd232e96df429ea43e99e694&v=4)](/mraffo)

Copy link

### **[mraffo](/mraffo)** commented [Sep 23, 2020](#issuecomment-697341292)

| [@mjsalinger](https://github.com/mjsalinger) [@thomseddon](https://github.com/thomseddon), Hi there, thanks for the library. My question is... have you planned this to any date in particular? Very thanks and congrats! |
| --- |

All reactions

Sorry, something went wrong.

This was referenced Oct 8, 2020

[Add PKCE support
#658](/oauthjs/node-oauth2-server/pull/658)
 Open

[Add PKCE support (for v5-dev Typescript)
#659](/oauthjs/node-oauth2-server/pull/659)
 Open

[![@HappyZombies](https://avatars.githubusercontent.com/u/11294700?s=40&v=4)](/HappyZombies)
[HappyZombies](/HappyZombies)
mentioned this pull request
[May 11, 2021](#ref-issue-876200568)

[Code Injection found by npm audit
#688](/oauthjs/node-oauth2-server/issues/688)

Open

[![@Uzlopak](https://avatars.githubusercontent.com/u/5059100?s=40&v=4)](/Uzlopak)
[Uzlopak](/Uzlopak)
mentioned this pull request
[Nov 17, 2021](#ref-issue-1055612594)

[Implement PKCE
node-oauth/node-oauth2-server#76](/node-oauth/node-oauth2-server/issues/76)

Closed

[![@FStefanni](https://avatars.githubusercontent.com/u/33950786?s=40&v=4)](/FStefanni)
[FStefanni](/FStefanni)
mentioned this pull request
[Nov 28, 2021](#ref-issue-1065351573)

[[meta] list of original project pr
node-oauth/node-oauth2-server#89](/node-oauth/node-oauth2-server/issues/89)

Closed

33 tasks

[Sign up for free](/join?source=comment-repo)
**to join this conversation on GitHub**.
Already have an account?
[Sign in to comment](/login?return_to=https%3A%2F%2Fgithub.com%2Foauthjs%2Fnode-oauth2-server%2Fpull%2F452)

Reviewers

[![@mjsalinger](https://avatars.githubusercontent.com/u/2452620?s=40&v=4)](/mjsalinger) [mjsalinger](/mjsalinger)

mjsalinger requested changes

Assignees

No one assigned

Labels

None yet

Projects

None yet

Milestone

No milestone

Development

Successfully merging this pull request may close these issues.

12 participants

[![@visvk](https://avatars.githubusercontent.com/u/4169046?s=52&v=4)](/visvk) [![@mjsalinger](https://avatars.githubusercontent.com/u/2452620?s=52&v=4)](/mjsalinger) [![@patrykcieszkowski](https://avatars.githubusercontent.com/u/16166259?s=52&v=4)](/patrykcieszkowski) [![@yhc44](https://avatars.githubusercontent.com/u/39420253?s=52&v=4)](/yhc44) [![@ReeSilva](https://avatars.githubusercontent.com/u/3605032?s=52&v=4)](/ReeSilva) [![@toonvanstrijp](https://avatars.githubusercontent.com/u/11893063?s=52&v=4)](/toonvanstrijp) [![@benaubin](https://avatars.githubusercontent.com/u/7585353?s=52&v=4)](/benaubin) [![@Rmannn](https://avatars.githubusercontent.com/u/12893006?s=52&v=4)](/Rmannn) [![@mitjap](https://avatars.githubusercontent.com/u/1507299?s=52&v=4)](/mitjap) [![@Zireael](https://avatars.githubusercontent.com/u/3856578?s=52&v=4)](/Zireael) [![@thomseddon](https://avatars.githubusercontent.com/u/747138?s=52&v=4)](/thomseddon) [![@mraffo](https://avatars.githubusercontent.com/u/263420?s=52&v=4)](/mraffo)

Add this suggestion to a batch that can be applied as a single commit.
This suggestion is invalid because no changes were made to the code.
Suggestions cannot be applied while the pull request is closed.
Suggestions cannot be applied while viewing a subset of changes.
Only one suggestion per line can be applied in a batch.
Add this suggestion to a batch that can be applied as a single commit.
Applying suggestions on deleted lines is not supported.
You must change the existing code in this line in order to create a valid suggestion.
Outdated suggestions cannot be applied.
This suggestion has been applied or marked resolved.
Suggestions cannot be applied from pending reviews.
Suggestions cannot be applied on multi-line comments.
Suggestions cannot be applied while the pull request is queued to merge.
Suggestion cannot be applied right now. Please check back later.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


