=== Content from access.redhat.com_792fc51e_20250126_040214.html ===


[Skip to navigation](#pfe-navigation)
[Skip to main content](#cp-main)
### Utilities

* [Subscriptions](https://access.redhat.com/management/)
* [Downloads](https://access.redhat.com/downloads/)
* [Red Hat Console](//console.redhat.com/)
* [Get Support](https://access.redhat.com/support/)

[![Red Hat Customer Portal](https://access.redhat.com/chrome_themes/nimbus/img/red-hat-customer-portal.svg)](https://access.redhat.com/)

* [Subscriptions](https://access.redhat.com/management/)
* [Downloads](https://access.redhat.com/downloads/)
* [Red Hat Console](//console.redhat.com/)
* [Get Support](https://access.redhat.com/support/)
* [Products](https://access.redhat.com/)
  ### Top Products

  + [Red Hat Enterprise Linux](https://access.redhat.com/products/red-hat-enterprise-linux/)
  + [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform)
  + [Red Hat Ansible Automation Platform](https://access.redhat.com/products/red-hat-ansible-automation-platform/)
  [All Products](https://access.redhat.com/products/)

  ### Downloads and Containers

  + [Downloads](https://access.redhat.com/downloads/)
  + [Packages](https://access.redhat.com/downloads/content/package-browser)
  + [Containers](https://catalog.redhat.com/software/containers/explore/)
  ### Top Resources

  + [Documentation](//docs.redhat.com/)
  + [Product Life Cycles](https://access.redhat.com/product-life-cycles/)
  + [Product Compliance](https://access.redhat.com/articles/1202803)
  + [Errata](https://access.redhat.com/errata/)
* [Knowledge](https://access.redhat.com/labs/)
  ### Red Hat Knowledge Center

  + [Knowledgebase Solutions](https://access.redhat.com/search/?q=*&p=1&rows=10&documentKind=Solution)
  + [Knowledgebase Articles](https://access.redhat.com/search/?q=*&p=1&rows=10&documentKind=Article)
  + [Customer Portal Labs](https://access.redhat.com/labs/)
  + [Errata](https://access.redhat.com/errata/)
  ### Top Product Docs

  + [Red Hat Enterprise Linux](//docs.redhat.com/en/documentation/red_hat_enterprise_linux/)
  + [Red Hat OpenShift](//docs.redhat.com/en/documentation/openshift_container_platform/)
  + [Red Hat Ansible Automation Platform](//docs.redhat.com/en/documentation/red_hat_ansible_automation_platform/)
  [All Product Docs](//docs.redhat.com/en/products)

  ### [Training and Certification](//www.redhat.com/en/services/training-and-certification)

  + [About](//www.redhat.com/en/services/training-and-certification)
  + [Course Index](//www.redhat.com/en/services/training/all-courses-exams)
  + [Certification Index](//www.redhat.com/en/services/certifications)
  + [Skill Assessment](//skills.ole.redhat.com/)
* [Security](https://access.redhat.com/security/)
  ### [Red Hat Product Security Center](https://access.redhat.com/security)

  + [Security Updates](https://access.redhat.com/security)
  + [Security Advisories](https://access.redhat.com/security/security-updates/#/security-advisories)
  + [Red Hat CVE Database](https://access.redhat.com/security/security-updates/#/cve)
  + [Errata](https://access.redhat.com/errata/)
  ### References

  + [Security Bulletins](https://access.redhat.com/security/vulnerabilities)
  + [Security Measurement](https://www.redhat.com/security/data/metrics/)
  + [Severity Ratings](https://access.redhat.com/security/updates/classification/)
  + [Security Data](https://access.redhat.com/security/data)
  ### Top Resources

  + [Security Labs](https://access.redhat.com/security/security-updates/#/security-labs)
  + [Backporting Policies](https://access.redhat.com/security/updates/backporting/)
  + [Security Blog](//redhat.com/en/blog/channel/security)
* [Support](https://access.redhat.com/support/)
  ### [Red Hat Support](https://access.redhat.com/support/)

  + [Support Cases](https://access.redhat.com/support/cases/)
  + [Troubleshoot](https://access.redhat.com/support/cases/#/troubleshoot)
  + [Get Support](https://access.redhat.com/support/)
  + [Contact Red Hat Support](https://access.redhat.com/support/contact/)
  ### [Red Hat Community Support](https://access.redhat.com/community)

  + [Customer Portal Community](https://access.redhat.com/community/)
  + [Community Discussions](https://access.redhat.com/discussions/)
  + [Red Hat Accelerator Program](https://access.redhat.com/accelerators/)
  ### Top Resources

  + [Product Life Cycles](https://access.redhat.com/product-life-cycles/)
  + [Customer Portal Labs](https://access.redhat.com/labs/)
  + [Red Hat JBoss Supported Configurations](https://access.redhat.com/support/configurations/jboss)
  + [Red Hat Insights](https://cloud.redhat.com/insights)

Or [troubleshoot an issue](/support/cases/#/troubleshoot).

English

## Select Your Language

* [English](https://access.redhat.com/changeLanguage?language=en)
* [Français](https://access.redhat.com/changeLanguage?language=fr)
* [한국어](https://access.redhat.com/changeLanguage?language=ko)
* [日本語](https://access.redhat.com/changeLanguage?language=ja)
* [中文 (中国)](https://access.redhat.com/changeLanguage?language=zh_CN)

### Infrastructure and Management

* [Red Hat Enterprise Linux](https://access.redhat.com/products/red-hat-enterprise-linux/)
* [Red Hat Satellite](https://access.redhat.com/products/red-hat-satellite/)
* [Red Hat Subscription Management](https://access.redhat.com/products/red-hat-subscription-management/)
* [Red Hat Insights](https://access.redhat.com/products/red-hat-insights/)
* [Red Hat Ansible Automation Platform](https://access.redhat.com/products/red-hat-ansible-automation-platform/)
### Cloud Computing

* [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform)
* [Red Hat OpenStack Platform](https://access.redhat.com/products/red-hat-openstack-platform/)
* [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform/)
* [Red Hat OpenShift AI](https://access.redhat.com/products/red-hat-openshift-ai/)
* [Red Hat OpenShift Dedicated](https://access.redhat.com/products/openshift-dedicated-red-hat/)
* [Red Hat Advanced Cluster Security for Kubernetes](https://access.redhat.com/products/red-hat-advanced-cluster-security-for-kubernetes/)
* [Red Hat Advanced Cluster Management for Kubernetes](https://access.redhat.com/products/red-hat-advanced-cluster-management-for-kubernetes/)
* [Red Hat Quay](https://access.redhat.com/products/red-hat-quay/)
* [Red Hat OpenShift Dev Spaces](https://access.redhat.com/products/red-hat-openshift-dev-spaces)
* [Red Hat OpenShift Service on AWS](https://access.redhat.com/products/red-hat-openshift-service-aws)
### Storage

* [Red Hat Gluster Storage](https://access.redhat.com/products/red-hat-storage/)
* [Red Hat Hyperconverged Infrastructure](https://access.redhat.com/products/red-hat-hyperconverged-infrastructure/)
* [Red Hat Ceph Storage](https://access.redhat.com/products/red-hat-ceph-storage/)
* [Red Hat OpenShift Data Foundation](https://access.redhat.com/products/red-hat-openshift-data-foundation)
### Runtimes

* [Red Hat Runtimes](https://access.redhat.com/products/red-hat-runtimes/)
* [Red Hat JBoss Enterprise Application Platform](https://access.redhat.com/products/red-hat-jboss-enterprise-application-platform/)
* [Red Hat Data Grid](https://access.redhat.com/products/red-hat-data-grid/)
* [Red Hat JBoss Web Server](https://access.redhat.com/products/red-hat-jboss-web-server/)
* [Red Hat build of Keycloak](https://access.redhat.com/products/red-hat-build-of-keycloak/)
* [Red Hat support for Spring Boot](https://access.redhat.com/products/spring-boot/)
* [Red Hat build of Node.js](https://access.redhat.com/products/nodejs/)
* [Red Hat build of Quarkus](https://access.redhat.com/products/quarkus/)
### Integration and Automation

* [Red Hat Application Foundations](https://access.redhat.com/products/red-hat-application-foundations/)
* [Red Hat Fuse](https://access.redhat.com/products/red-hat-fuse/)
* [Red Hat AMQ](https://access.redhat.com/products/red-hat-amq/)
* [Red Hat 3scale API Management](https://access.redhat.com/products/red-hat-3scale/)

[All Products](https://access.redhat.com/products/)

**We're sorry but cve-details doesn't work properly without JavaScript enabled. Please enable it to continue.**

[![Red Hat](https://static.redhat.com/libs/redhat/brand-assets/2/corp/logo--on-dark.svg)](https://redhat.com/en)
[X (formerly Twitter)](https://twitter.com/RedHat)
### Quick Links

* [Downloads](https://access.redhat.com/downloads/)
* [Subscriptions](https://access.redhat.com/management)
* [Support Cases](https://access.redhat.com/support)
* [Customer Service](https://access.redhat.com/support/customer-service)
* [Product Documentation](//docs.redhat.com/)

### Help

* [Contact Us](https://access.redhat.com/support/contact/)
* [Customer Portal FAQ](https://access.redhat.com/articles/33844)
* [Log-in Assistance](https://access.redhat.com/help/login_assistance)

### Site Info

* [Trust Red Hat](https://www.redhat.com/en/trust)
* [Browser Support Policy](https://www.redhat.com/en/about/browser-support)
* [Accessibility](https://www.redhat.com/en/about/digital-accessibility)
* [Awards and Recognition](https://access.redhat.com/recognition/)
* [Colophon](https://access.redhat.com/help/colophon/)

### Related Sites

* [redhat.com](https://www.redhat.com/)
* [developers.redhat.com](http://developers.redhat.com/)
* [connect.redhat.com](https://connect.redhat.com/)
* [cloud.redhat.com](https://cloud.redhat.com/)

### Red Hat legal and privacy links

* [About Red Hat](https://redhat.com/en/about/company)
* [Jobs](https://redhat.com/en/jobs)
* [Events](https://redhat.com/en/events)
* [Locations](https://redhat.com/en/about/office-locations)
* [Contact Red Hat](https://redhat.com/en/contact)
* [Red Hat Blog](https://redhat.com/en/blog)
* [Diversity, equity, and inclusion](https://redhat.com/en/about/our-culture/diversity-equity-inclusion)
* [Cool Stuff Store](https://coolstuff.redhat.com/)
* [Red Hat Summit](https://www.redhat.com/en/summit)

 © 2025 Red Hat, Inc.
### Red Hat legal and privacy links

* [Privacy statement](https://redhat.com/en/about/privacy-policy)
* [Terms of use](https://redhat.com/en/about/terms-use)
* [All policies and guidelines](https://redhat.com/en/about/all-policies-guidelines)
* [Digital accessibility](https://redhat.com/en/about/digital-accessibility)



=== Content from bugzilla.redhat.com_a4cff22a_20250124_221809.html ===


* Login
  + Log in using an SSO provider:- [Fedora Account System](saml2_login.cgi?idp=Fedora%20Account%20System&target=show_bug.cgi%3Fid%3D1451386)
    - [Red Hat Associate](saml2_login.cgi?idp=Red%20Hat%20Associate&target=show_bug.cgi%3Fid%3D1451386)
    - [Red Hat Customer](saml2_login.cgi?idp=Red%20Hat%20Customer&target=show_bug.cgi%3Fid%3D1451386)+ Login using a Red Hat Bugzilla account
  + Forgot Password
  + [Create an Account](createaccount.cgi)

Red Hat Bugzilla – Bug 1451386

* [Home](./)
* [New](enter_bug.cgi)
* Search
  + [Simple Search](query.cgi?format=specific)
  + [Advanced Search](query.cgi?format=advanced)
* My Links
  + [Browse](describecomponents.cgi)
  + [Requests](request.cgi)
  + Reports
  + Current State
    - [Search](query.cgi)
    - [Tabular reports](query.cgi?format=report-table)
    - [Graphical reports](query.cgi?format=report-graph)
    - [Duplicates](duplicates.cgi)
  + Other Reports
    - [User Changes](https://bugzilla.redhat.com/page.cgi?id=user_activity.html)
  + Plotly Reports
    - [Bug Status](https://bugzilla.redhat.com/page.cgi?id=bug_status.html)
    - [Bug Severity](https://bugzilla.redhat.com/page.cgi?id=bug_severity.html)
    - [Non-Defaults](https://bugzilla.redhat.com/page.cgi?id=non_defaults.html)
* [Product Dashboard](page.cgi?id=productdashboard.html)

- Help
  * [Page Help!](docs/en/html/using/understanding.html)
  * [Bug Writing Guidelines](page.cgi?id=bug-writing.html)
  * [What's new](page.cgi?id=whats-new.html)
  * [Browser Support Policy](https://access.redhat.com/help/browsers)
  * [5.0.4.rh103 Release notes](page.cgi?id=release-notes.html)
  * [FAQ](page.cgi?id=faq.html)
  * [Guides index](docs/en/html/index.html)
  * [User guide](docs/en/html/using/index.html)
  * [Web Services](docs/en/html/integrating/api/Bugzilla/WebService/Bug.html)
  * [Contact](page.cgi?id=redhat/contact.html)
  * [Legal](page.cgi?id=terms-conditions.html)
- [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")

This site requires JavaScript to be enabled to function correctly, please enable it.

[**Bug 1451386**](show_bug.cgi?id=1451386)
(CVE-2017-9059)
- [CVE-2017-9059](https://access.redhat.com/security/cve/CVE-2017-9059) kernel: Module reference leak due to improper shut down of callback channel on umount

[Summary:](page.cgi?id=fields.html#short_desc "The bug summary is a short sentence which succinctly describes what the bug is about.")
CVE-2017-9059 kernel: Module reference leak due to improper shut down of call...

| | [Keywords](describekeywords.cgi): | Security | | --- | --- | | [Status](page.cgi?id=fields.html#bug_status): | CLOSED NOTABUG | | [Alias:](page.cgi?id=fields.html#alias "A short, unique name assigned to a bug in order to assist with looking it up and referring to it in other places in Bugzilla.") | CVE-2017-9059 | | [Product:](describecomponents.cgi "Bugs are categorised into Products and Components. Select a Classification to narrow down this list.") | Security Response | | [Classification:](page.cgi?id=fields.html#classification "Bugs are categorised into Classifications, Products and Components. classifications is the top-level categorisation.") | Other | | [Component:](describecomponents.cgi?product=Security Response "Components are second-level categories; each belongs to a particular Product. Select a Product to narrow down this list.") | vulnerability | | [Sub Component:](page.cgi?id=fields.html#rh_sub_components "The sub component of a specific component") | --- | | [Version:](page.cgi?id=fields.html#version "The version field defines the version of the software the bug was found in.") | unspecified | | [Hardware:](page.cgi?id=fields.html#rep_platform "The hardware platform the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | All | | [OS:](page.cgi?id=fields.html#op_sys "The operating system the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | Linux | | [Priority:](page.cgi?id=fields.html#priority) | medium | | [Severity:](page.cgi?id=fields.html#bug_severity) | medium | | [Target Milestone:](page.cgi?id=fields.html#target_milestone "The Target Milestone field is used to define when the engineer the bug is assigned to expects to fix it.") | --- | | [Assignee:](page.cgi?id=fields.html#assigned_to "The person in charge of resolving the bug.") | Red Hat Product Security | | [QA Contact:](page.cgi?id=fields.html#qa_contact "The person responsible for confirming this bug if it is unconfirmed, and for verifying the fix once the bug has been resolved.") |  | | [Docs Contact:](page.cgi?id=fields.html#docs_contact "The person responsible for documenting once the bug has been resolved.") |  | | [URL:](page.cgi?id=fields.html#bug_file_loc "Bugs can have a URL associated with them - for example, a pointer to a web site where the problem is seen.") |  | | [Whiteboard:](page.cgi?id=fields.html#status_whiteboard "Each bug has a free-form single line text entry box for adding tags and status information.") |  | | [Depends On:](page.cgi?id=fields.html#dependson "The bugs listed here must be resolved before this bug can be resolved.") | [1451996](show_bug.cgi?id=1451996 "CLOSED ERRATA - CVE-2017-9059 kernel: Module reference leak due to improper shut down of callback channel on umount [fedora-all]") | | [Blocks:](page.cgi?id=fields.html#blocked "This bug must be resolved before the bugs listed in this field can be resolved.") |  | | TreeView+ | [depends on](buglist.cgi?bug_id=1451386&bug_id_type=anddependson&format=tvp) / [blocked](buglist.cgi?bug_id=1451386&bug_id_type=andblocked&format=tvp&tvp_dir=blocked) |  | |  | | [Reported:](page.cgi?id=fields.html#reporter) | 2017-05-16 14:30 UTC by Adam Mariš | | --- | --- | | [Modified:](page.cgi?id=fields.html#modified) | 2019-09-29 14:12 UTC ([History](show_activity.cgi?id=1451386)) | | [CC List:](page.cgi?id=fields.html#cclist) | 28 users (show)  aquini bhu dhoward fhrbata gansalmon hwkernel-mgr iboverma ichavero itamar jforbes jkacur jonathan jross jwboyer kernel-maint kernel-mgr labbott lgoncalv madhu.chinakonda matt mchehab mcressma nmurray pholasek plougher rt-maint rvrbovsk williams | | Fixed In Version: |  | | | Doc Type: | If docs needed, set a value | | | Doc Text: |  | | | Clone Of: |  | | | Environment: |  | | | Last Closed: | 2019-06-08 03:12:45 UTC | | | Embargoed: |  | | |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| --- | | |

| | Attachments | [(Terms of Use)](page.cgi?id=terms-conditions.html) | | | --- | --- | --- | |  | | | |  |
| --- | --- | --- | --- | --- | --- | --- | --- |

| [Description](show_bug.cgi?id=1451386#c0)  Adam Mariš    2017-05-16 14:30:11 UTC  ``` A leakage of module reference and kernel daemon in NFSv4 when NFSv4 mounts are made and then all outstanding NFSv4 mounts are removed. Local attackers with permission to mount NFS filesystems can potentially cause DoS by running the system out of resources.  Fixed by following patches:  <https://www.spinics.net/lists/linux-nfs/msg63334.html>  which were merged into mainline in following commit:  <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c70422f760c120480fee4de6c38804c72aa26bc1>   ```  [Comment 1](show_bug.cgi?id=1451386#c1)  Adam Mariš    2017-05-18 06:33:11 UTC  ``` Created kernel tracking bugs for this issue:  Affects: fedora-all [[bug 1451996](show_bug.cgi?id=1451996 "CLOSED ERRATA - CVE-2017-9059 kernel: Module reference leak due to improper shut down of callback channel on umount [fedora-all]")]   ``` |  |
| --- | --- |

---

| Note You need to [log in](show_bug.cgi?id=1451386&GoAheadAndLogIn=1) before you can comment on or make changes to this bug. |
| --- |

---

[Privacy](page.cgi?id=redhat/privacy.html)
[Contact](page.cgi?id=redhat/contact.html)
[FAQ](page.cgi?id=faq.html)
[Legal](page.cgi?id=terms-conditions.html)



=== Content from www.spinics.net_e0fbed30_20250124_221816.html ===


# [PATCH 0/2] Fix the NFSv4 client callback channel shutdown

[[Date Prev](msg63333.html)][[Date Next](msg63335.html)][[Thread Prev](msg63331.html)][[Thread Next](msg63335.html)][[Date Index](mail8.html#63334)][[Thread Index](thrd8.html#63334)]

---

* *Subject*: [PATCH 0/2] Fix the NFSv4 client callback channel shutdown
* *From*: Trond Myklebust <trond.myklebust@xxxxxxxxxxxxxxx>
* *Date*: Wed, 26 Apr 2017 11:55:25 -0400
* *Cc*: "J. Bruce Fields" <bfields@xxxxxxxxxx>, Kinglong Mee <kinglongmee@xxxxxxxxx>

---

```
Fix the problem reported by Kinglong, whereby the callback channel was
failing to shut down properly on umount.

Trond Myklebust (2):
  SUNRPC: Refactor svc_set_num_threads()
  NFSv4: Fix callback server shutdown

 fs/nfs/callback.c          |  24 +++++---
 include/linux/sunrpc/svc.h |   1 +
 net/sunrpc/svc.c           | 134 ++++++++++++++++++++++++++++++++-------------
 3 files changed, 113 insertions(+), 46 deletions(-)

--
2.9.3

--
To unsubscribe from this list: send the line "unsubscribe linux-nfs" in
the body of a message to majordomo@xxxxxxxxxxxxxxx
More majordomo info at  <http://vger.kernel.org/majordomo-info.html>

```

---

* **Follow-Ups**:
  + **[[PATCH 1/2] SUNRPC: Refactor svc\_set\_num\_threads()](msg63335.html)**
    - *From:* Trond Myklebust

* Prev by Date:
  **[Re: [PATCH 2/2] dax: fix data corruption due to stale mmap reads](msg63333.html)**
* Next by Date:
  **[[PATCH 1/2] SUNRPC: Refactor svc\_set\_num\_threads()](msg63335.html)**
* Previous by thread:
  **[[PATCH] fix semicolon.cocci warnings](msg63331.html)**
* Next by thread:
  **[[PATCH 1/2] SUNRPC: Refactor svc\_set\_num\_threads()](msg63335.html)**
* Index(es):
  + [**Date**](mail8.html#63334)
  + [**Thread**](thrd8.html#63334)

[[Index of Archives]](/lists/)

[[Linux Filesystem Development]](/lists/linux-fsdevel/)

[[Linux USB Development]](/lists/linux-usb/)

[[Linux Media Development]](/lists/linux-media/)

[[Video for Linux]](/lists/vfl/)

[[Linux NILFS]](/lists/linux-nilfs/)

[[Linux Audio Users]](/lists/linux-audio-users/)

[[Yosemite Info]](https://yosemitenews.info/)

[[Linux SCSI]](/lists/linux-scsi/)

---

|  | [Powered by Linux](/lists/) |
| --- | --- |



=== Content from github.com_7dd57d13_20250124_221814.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftorvalds%2Flinux%2Fcommit%2Fc70422f760c120480fee4de6c38804c72aa26bc1)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftorvalds%2Flinux%2Fcommit%2Fc70422f760c120480fee4de6c38804c72aa26bc1)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fcommit_fragments%2Frepo_layout&source=header-repo&source_repo=torvalds%2Flinux)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[torvalds](/torvalds)
/
**[linux](/torvalds/linux)**
Public

* [Notifications](/login?return_to=%2Ftorvalds%2Flinux) You must be signed in to change notification settings
* [Fork
  54.9k](/login?return_to=%2Ftorvalds%2Flinux)
* [Star
   186k](/login?return_to=%2Ftorvalds%2Flinux)

* [Code](/torvalds/linux)
* [Pull requests
  437](/torvalds/linux/pulls)
* [Actions](/torvalds/linux/actions)
* [Projects
  0](/torvalds/linux/projects)
* [Security](/torvalds/linux/security)
* [Insights](/torvalds/linux/pulse)

Additional navigation options

* [Code](/torvalds/linux)
* [Pull requests](/torvalds/linux/pulls)
* [Actions](/torvalds/linux/actions)
* [Projects](/torvalds/linux/projects)
* [Security](/torvalds/linux/security)
* [Insights](/torvalds/linux/pulse)

## Commit

[Permalink](/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1)

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

Merge tag 'nfsd-4.12' of git://linux-nfs.org/~bfields/linux

[Browse files](/torvalds/linux/tree/c70422f760c120480fee4de6c38804c72aa26bc1)
Browse the repository at this point in the history

```
Pull nfsd updates from Bruce Fields:
 "Another RDMA update from Chuck Lever, and a bunch of miscellaneous
  bugfixes"

* tag 'nfsd-4.12' of git://linux-nfs.org/~bfields/linux: (26 commits)
  nfsd: Fix up the "supattr_exclcreat" attributes
  nfsd: encoders mustn't use unitialized values in error cases
  nfsd: fix undefined behavior in nfsd4_layout_verify
  lockd: fix lockd shutdown race
  NFSv4: Fix callback server shutdown
  SUNRPC: Refactor svc_set_num_threads()
  NFSv4.x/callback: Create the callback service through svc_create_pooled
  lockd: remove redundant check on block
  svcrdma: Clean out old XDR encoders
  svcrdma: Remove the req_map cache
  svcrdma: Remove unused RDMA Write completion handler
  svcrdma: Reduce size of sge array in struct svc_rdma_op_ctxt
  svcrdma: Clean up RPC-over-RDMA backchannel reply processing
  svcrdma: Report Write/Reply chunk overruns
  svcrdma: Clean up RDMA_ERROR path
  svcrdma: Use rdma_rw API in RPC reply path
  svcrdma: Introduce local rdma_rw API helpers
  svcrdma: Clean up svc_rdma_get_inv_rkey()
  svcrdma: Add helper to save pages under I/O
  svcrdma: Eliminate RPCRDMA_SQ_DEPTH_MULT
  ...
```

* Loading branch information

[![@torvalds](https://avatars.githubusercontent.com/u/1024025?s=40&v=4)](/torvalds)

[torvalds](/torvalds/linux/commits?author=torvalds "View all commits by torvalds")
committed
May 10, 2017

2 parents
[73ccb02](/torvalds/linux/commit/73ccb023a2f25b72c4b95499ca24760588014614)
+
[b26b78c](/torvalds/linux/commit/b26b78cb726007533d81fdf90a62e915002ef5c8)

commit c70422f

 Show file tree

 Hide file tree

Showing
**23 changed files**
with
**1,334 additions**
and
**903 deletions**.

* Whitespace
* Ignore whitespace

* Split
* Unified

* fs

  + lockd

    - fs/lockd/svc.c
      [svc.c](#diff-335612a720c00a2bc9809b560cc36f790db5fde7437121f0685f65a5fb37cce4)
    - fs/lockd/svclock.c
      [svclock.c](#diff-b6887a8646e629bfa1a8ae005afb60faa9b45fcc0f372b3e8403a332cb0bdce2)
  + nfs

    - fs/nfs/callback.c
      [callback.c](#diff-52dc92dd4bbeac597e319356075f09bd5ce90c88d0797ec030a42c13f474f33e)
  + nfsd

    - fs/nfsd/nfs3xdr.c
      [nfs3xdr.c](#diff-3c8dd80c532be5e29b815c958566e814ac5b666fa3739973187a900557a4dd1e)
    - fs/nfsd/nfs4proc.c
      [nfs4proc.c](#diff-d8276cd17383f1d4034075bcf60f94b8d82067db36fc29db3b1bf21f1da8e632)
    - fs/nfsd/nfs4state.c
      [nfs4state.c](#diff-d2280d8868e1e7b893e95ed826faa704c03a61cf466a81129ecd12e0aef5fe92)
    - fs/nfsd/nfs4xdr.c
      [nfs4xdr.c](#diff-73cdbffe3e14281cbda36e7f9df6d6db198f91b25529692748944dae803908ae)
    - fs/nfsd/nfsxdr.c
      [nfsxdr.c](#diff-dc9f2d0c999a2fce7eafbacec69a1f40e23e4085a3745b73daf27dc352621425)
    - fs/nfsd/vfs.c
      [vfs.c](#diff-71e6835280f17a5cf4ead33e8d368ebbf021409dbdf0bea027e6f93eff139d14)
* include

  + linux/sunrpc

    - include/linux/sunrpc/rpc\_rdma.h
      [rpc\_rdma.h](#diff-8ede9986129bdfc2537e39d2c691335c9f5e9665540a65bea8d89ee1151248c5)
    - include/linux/sunrpc/svc.h
      [svc.h](#diff-a8b0b764143194f53eab5a56935c671bb856194523511b9aa2c7b075a920fd0d)
    - include/linux/sunrpc/svc\_rdma.h
      [svc\_rdma.h](#diff-04e439a04da59bd64ee33b3b1a30b7ce8a5df26d95966eab2611befa4725b841)
  + uapi/linux/nfsd

    - include/uapi/linux/nfsd/cld.h
      [cld.h](#diff-c223be22235b572ef9672ee719e7281d61c1fe27bfc18a4b25e0705261a96d07)
* net/sunrpc

  + net/sunrpc/Kconfig
    [Kconfig](#diff-012caa73d0a1d8cf96e0804e2b0cf8fdc12d2ac5a6fa91eb56fb3d576839449f)
  + net/sunrpc/svc.c
    [svc.c](#diff-4e0182dfe9cfc9607f5a6462ac12e50ea2516171072fd8ff7f6af6ebb1feacce)
  + xprtrdma

    - net/sunrpc/xprtrdma/Makefile
      [Makefile](#diff-5cd643ed463e75689cad1c4d1b490cb966d335f756d48e427bf4abf5a8314d5d)
    - net/sunrpc/xprtrdma/svc\_rdma.c
      [svc\_rdma.c](#diff-1e6e93e353403e8e12c5045ab63f5975da537c9cd330c6edc6124bd0608204ac)
    - net/sunrpc/xprtrdma/svc\_rdma\_backchannel.c
      [svc\_rdma\_backchannel.c](#diff-8f05d8adfb6ed1672e63726d89350fafdcd3c1e1d5daa0116c75664108269a83)
    - net/sunrpc/xprtrdma/svc\_rdma\_marshal.c
      [svc\_rdma\_marshal.c](#diff-364640b07d6cd65fbb669c41902903eff2324059a45f238152d62357a53d67ed)
    - net/sunrpc/xprtrdma/svc\_rdma\_recvfrom.c
      [svc\_rdma\_recvfrom.c](#diff-20fa667443ad55bc340b68d75b388098cd0f6f517d2b2f95f9e3d6b83bc1d994)
    - net/sunrpc/xprtrdma/svc\_rdma\_rw.c
      [svc\_rdma\_rw.c](#diff-3258e6c7fec3e9022c3b2b52b26e218e8411840a08f544d5de1c14f12d74cfbe)
    - net/sunrpc/xprtrdma/svc\_rdma\_sendto.c
      [svc\_rdma\_sendto.c](#diff-5ef3d756baa1c5ddefad73b92adc4a38db7ed4ecca1d078ad909068c60afbeba)
    - net/sunrpc/xprtrdma/svc\_rdma\_transport.c
      [svc\_rdma\_transport.c](#diff-156e4d13b130bafcf93bac73a2b59b6656bac584c20f883c3fa4a8d388e65b92)

## There are no files selected for viewing

6 changes: 4 additions & 2 deletions

6
[fs/lockd/svc.c](#diff-335612a720c00a2bc9809b560cc36f790db5fde7437121f0685f65a5fb37cce4 "fs/lockd/svc.c")

Show comments

[View file](/torvalds/linux/blob/c70422f760c120480fee4de6c38804c72aa26bc1/fs/lockd/svc.c)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -132,6 +132,8 @@ lockd(void \*vrqstp) |
|  |  | { |
|  |  | int err = 0; |
|  |  | struct svc\_rqst \*rqstp = vrqstp; |
|  |  | struct net \*net = &init\_net; |
|  |  | struct lockd\_net \*ln = net\_generic(net, lockd\_net\_id); |
|  |  |  |
|  |  | /\* try\_to\_freeze() is called from svc\_recv() \*/ |
|  |  | set\_freezable(); |
| Expand Down  Expand Up | | @@ -176,6 +178,8 @@ lockd(void \*vrqstp) |
|  |  | if (nlmsvc\_ops) |
|  |  | nlmsvc\_invalidate\_all(); |
|  |  | nlm\_shutdown\_hosts(); |
|  |  | cancel\_delayed\_work\_sync(&ln->grace\_period\_end); |
|  |  | locks\_end\_grace(&ln->lockd\_manager); |
|  |  | return 0; |
|  |  | } |
|  |  |  |
| Expand Down  Expand Up | | @@ -270,8 +274,6 @@ static void lockd\_down\_net(struct svc\_serv \*serv, struct net \*net) |
|  |  | if (ln->nlmsvc\_users) { |
|  |  | if (--ln->nlmsvc\_users == 0) { |
|  |  | nlm\_shutdown\_hosts\_net(net); |
|  |  | cancel\_delayed\_work\_sync(&ln->grace\_period\_end); |
|  |  | locks\_end\_grace(&ln->lockd\_manager); |
|  |  | svc\_shutdown\_net(serv, net); |
|  |  | dprintk("lockd\_down\_net: per-net data destroyed; net=%p\n", net); |
|  |  | } |
| Expand Down | |  |

18 changes: 9 additions & 9 deletions

18
[fs/lockd/svclock.c](#diff-b6887a8646e629bfa1a8ae005afb60faa9b45fcc0f372b3e8403a332cb0bdce2 "fs/lockd/svclock.c")

Show comments

[View file](/torvalds/linux/blob/c70422f760c120480fee4de6c38804c72aa26bc1/fs/lockd/svclock.c)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -870,15 +870,15 @@ nlmsvc\_grant\_reply(struct nlm\_cookie \*cookie, \_\_be32 status) |
|  |  | if (!(block = nlmsvc\_find\_block(cookie))) |
|  |  | return; |
|  |  |  |
|  |  | if (block) { |
|  |  | if (status == nlm\_lck\_denied\_grace\_period) { |
|  |  | /\* Try again in a couple of seconds \*/ |
|  |  | nlmsvc\_insert\_block(block, 10 \* HZ); |
|  |  | } else { |
|  |  | /\* Lock is now held by client, or has been rejected. |
|  |  | \* In both cases, the block should be removed. \*/ |
|  |  | nlmsvc\_unlink\_block(block); |
|  |  | } |
|  |  | if (status == nlm\_lck\_denied\_grace\_period) { |
|  |  | /\* Try again in a couple of seconds \*/ |
|  |  | nlmsvc\_insert\_block(block, 10 \* HZ); |
|  |  | } else { |
|  |  | /\* |
|  |  | \* Lock is now held by client, or has been rejected. |
|  |  | \* In both cases, the block should be removed. |
|  |  | \*/ |
|  |  | nlmsvc\_unlink\_block(block); |
|  |  | } |
|  |  | nlmsvc\_release\_block(block); |
|  |  | } |
| Expand Down | |  |

26 changes: 17 additions & 9 deletions

26
[fs/nfs/callback.c](#diff-52dc92dd4bbeac597e319356075f09bd5ce90c88d0797ec030a42c13f474f33e "fs/nfs/callback.c")

Show comments

[View file](/torvalds/linux/blob/c70422f760c120480fee4de6c38804c72aa26bc1/fs/nfs/callback.c)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -76,7 +76,10 @@ nfs4\_callback\_svc(void \*vrqstp) |
|  |  |  |
|  |  | set\_freezable(); |
|  |  |  |
|  |  | while (!kthread\_should\_stop()) { |
|  |  | while (!kthread\_freezable\_should\_stop(NULL)) { |
|  |  |  |
|  |  | if (signal\_pending(current)) |
|  |  | flush\_signals(current); |
|  |  | /\* |
|  |  | \* Listen for a request on the socket |
|  |  | \*/ |
| Expand All | | @@ -85,6 +88,8 @@ nfs4\_callback\_svc(void \*vrqstp) |
|  |  | continue; |
|  |  | svc\_process(rqstp); |
|  |  | } |
|  |  | svc\_exit\_thread(rqstp); |
|  |  | module\_put\_and\_exit(0); |
|  |  | return 0; |
|  |  | } |
|  |  |  |
| Expand All | | @@ -103,9 +108,10 @@ nfs41\_callback\_svc(void \*vrqstp) |
|  |  |  |
|  |  | set\_freezable(); |
|  |  |  |
|  |  | while (!kthread\_should\_stop()) { |
|  |  | if (try\_to\_freeze()) |
|  |  | continue; |
|  |  | while (!kthread\_freezable\_should\_stop(NULL)) { |
|  |  |  |
|  |  | if (signal\_pending(current)) |
|  |  | flush\_signals(current); |
|  |  |  |
|  |  | prepare\_to\_wait(&serv->sv\_cb\_waitq, &wq, TASK\_INTERRUPTIBLE); |
|  |  | spin\_lock\_bh(&serv->sv\_cb\_lock); |
| Expand All | | @@ -121,11 +127,13 @@ nfs41\_callback\_svc(void \*vrqstp) |
|  |  | error); |
|  |  | } else { |
|  |  | spin\_unlock\_bh(&serv->sv\_cb\_lock); |
|  |  | schedule(); |
|  |  | if (!kthread\_should\_stop()) |
|  |  | schedule(); |
|  |  | finish\_wait(&serv->sv\_cb\_waitq, &wq); |
|  |  | } |
|  |  | flush\_signals(current); |
|  |  | } |
|  |  | svc\_exit\_thread(rqstp); |
|  |  | module\_put\_and\_exit(0); |
|  |  | return 0; |
|  |  | } |
|  |  |  |
| Expand Down  Expand Up | | @@ -221,14 +229,14 @@ static int nfs\_callback\_up\_net(int minorversion, struct svc\_serv \*serv, |
|  |  | static struct svc\_serv\_ops nfs40\_cb\_sv\_ops = { |
|  |  | .svo\_function = nfs4\_callback\_svc, |
|  |  | .svo\_enqueue\_xprt = svc\_xprt\_do\_enqueue, |
|  |  | .svo\_setup = svc\_set\_num\_threads, |
|  |  | .svo\_setup = svc\_set\_num\_threads\_sync, |
|  |  | .svo\_module = THIS\_MODULE, |
|  |  | }; |
|  |  | #if defined(CONFIG\_NFS\_V4\_1) |
|  |  | static struct svc\_serv\_ops nfs41\_cb\_sv\_ops = { |
|  |  | .svo\_function = nfs41\_callback\_svc, |
|  |  | .svo\_enqueue\_xprt = svc\_xprt\_do\_enqueue, |
|  |  | .svo\_setup = svc\_set\_num\_threads, |
|  |  | .svo\_setup = svc\_set\_num\_threads\_sync, |
|  |  | .svo\_module = THIS\_MODULE, |
|  |  | }; |
|  |  |  |
| Expand Down  Expand Up | | @@ -280,7 +288,7 @@ static struct svc\_serv \*nfs\_callback\_create\_svc(int minorversion) |
|  |  | printk(KERN\_WARNING "nfs\_callback\_create\_svc: no kthread, %d users??\n", |
|  |  | cb\_info->users); |
|  |  |  |
|  |  | serv = svc\_create(&nfs4\_callback\_program, NFS4\_CALLBACK\_BUFSIZE, sv\_ops); |
|  |  | serv = svc\_create\_pooled(&nfs4\_callback\_program, NFS4\_CALLBACK\_BUFSIZE, sv\_ops); |
|  |  | if (!serv) { |
|  |  | printk(KERN\_ERR "nfs\_callback\_create\_svc: create service failed\n"); |
|  |  | return ERR\_PTR(-ENOMEM); |
| Expand Down | |  |

23 changes: 17 additions & 6 deletions

23
[fs/nfsd/nfs3xdr.c](#diff-3c8dd80c532be5e29b815c958566e814ac5b666fa3739973187a900557a4dd1e "fs/nfsd/nfs3xdr.c")

Show comments

[View file](/torvalds/linux/blob/c70422f760c120480fee4de6c38804c72aa26bc1/fs/nfsd/nfs3xdr.c)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -334,8 +334,11 @@ nfs3svc\_decode\_readargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, |
|  |  | if (!p) |
|  |  | return 0; |
|  |  | p = xdr\_decode\_hyper(p, &args->offset); |
|  |  |  |
|  |  | args->count = ntohl(\*p++); |
|  |  |  |
|  |  | if (!xdr\_argsize\_check(rqstp, p)) |
|  |  | return 0; |
|  |  |  |
|  |  | len = min(args->count, max\_blocksize); |
|  |  |  |
|  |  | /\* set up the kvec \*/ |
| Expand All | | @@ -349,7 +352,7 @@ nfs3svc\_decode\_readargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, |
|  |  | v++; |
|  |  | } |
|  |  | args->vlen = v; |
|  |  | return xdr\_argsize\_check(rqstp, p); |
|  |  | return 1; |
|  |  | } |
|  |  |  |
|  |  | int |
| Expand Down  Expand Up | | @@ -541,9 +544,11 @@ nfs3svc\_decode\_readlinkargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, |
|  |  | p = decode\_fh(p, &args->fh); |
|  |  | if (!p) |
|  |  | return 0; |
|  |  | if (!xdr\_argsize\_check(rqstp, p)) |
|  |  | return 0; |
|  |  | args->buffer = page\_address(\*(rqstp->rq\_next\_page++)); |
|  |  |  |
|  |  | return xdr\_argsize\_check(rqstp, p); |
|  |  | return 1; |
|  |  | } |
|  |  |  |
|  |  | int |
| Expand All | | @@ -569,10 +574,14 @@ nfs3svc\_decode\_readdirargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, |
|  |  | args->verf = p; p += 2; |
|  |  | args->dircount = ~0; |
|  |  | args->count = ntohl(\*p++); |
|  |  |  |
|  |  | if (!xdr\_argsize\_check(rqstp, p)) |
|  |  | return 0; |
|  |  |  |
|  |  | args->count = min\_t(u32, args->count, PAGE\_SIZE); |
|  |  | args->buffer = page\_address(\*(rqstp->rq\_next\_page++)); |
|  |  |  |
|  |  | return xdr\_argsize\_check(rqstp, p); |
|  |  | return 1; |
|  |  | } |
|  |  |  |
|  |  | int |
| Expand All | | @@ -590,15 +599,17 @@ nfs3svc\_decode\_readdirplusargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, |
|  |  | args->dircount = ntohl(\*p++); |
|  |  | args->count = ntohl(\*p++); |
|  |  |  |
|  |  | if (!xdr\_argsize\_check(rqstp, p)) |
|  |  | return 0; |
|  |  |  |
|  |  | len = args->count = min(args->count, max\_blocksize); |
|  |  | while (len > 0) { |
|  |  | struct page \*p = \*(rqstp->rq\_next\_page++); |
|  |  | if (!args->buffer) |
|  |  | args->buffer = page\_address(p); |
|  |  | len -= PAGE\_SIZE; |
|  |  | } |
|  |  |  |
|  |  | return xdr\_argsize\_check(rqstp, p); |
|  |  | return 1; |
|  |  | } |
|  |  |  |
|  |  | int |
| Expand Down | |  |

3 changes: 2 additions & 1 deletion

3
[fs/nfsd/nfs4proc.c](#diff-d8276cd17383f1d4034075bcf60f94b8d82067db36fc29db3b1bf21f1da8e632 "fs/nfsd/nfs4proc.c")

Show comments

[View file](/torvalds/linux/blob/c70422f760c120480fee4de6c38804c72aa26bc1/fs/nfsd/nfs4proc.c)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -1259,7 +1259,8 @@ nfsd4\_layout\_verify(struct svc\_export \*exp, unsigned int layout\_type) |
|  |  | return NULL; |
|  |  | } |
|  |  |  |
|  |  | if (!(exp->ex\_layout\_types & (1 << layout\_type))) { |
|  |  | if (layout\_type >= LAYOUT\_TYPE\_MAX || |
|  |  | !(exp->ex\_layout\_types & (1 << layout\_type))) { |
|  |  | dprintk("%s: layout type %d not supported\n", |
|  |  | \_\_func\_\_, layout\_type); |
|  |  | return NULL; |
| Expand Down | |  |

25 changes: 6 additions & 19 deletions

25
[fs/nfsd/nfs4state.c](#diff-d2280d8868e1e7b893e95ed826faa704c03a61cf466a81129ecd12e0aef5fe92 "fs/nfsd/nfs4state.c")

Show comments

[View file](/torvalds/linux/blob/c70422f760c120480fee4de6c38804c72aa26bc1/fs/nfsd/nfs4state.c)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -1912,28 +1912,15 @@ static void copy\_clid(struct nfs4\_client \*target, struct nfs4\_client \*source) |
|  |  | target->cl\_clientid.cl\_id = source->cl\_clientid.cl\_id; |
|  |  | } |
|  |  |  |
|  |  | int strdup\_if\_nonnull(char \*\*target, char \*source) |
|  |  | { |
|  |  | if (source) { |
|  |  | \*target = kstrdup(source, GFP\_KERNEL); |
|  |  | if (!\*target) |
|  |  | return -ENOMEM; |
|  |  | } else |
|  |  | \*target = NULL; |
|  |  | return 0; |
|  |  | } |
|  |  |  |
|  |  | static int copy\_cred(struct svc\_cred \*target, struct svc\_cred \*source) |
|  |  | { |
|  |  | int ret; |
|  |  | target->cr\_principal = kstrdup(source->cr\_principal, GFP\_KERNEL); |
|  |  | target->cr\_raw\_principal = kstrdup(source->cr\_raw\_principal, |
|  |  | GFP\_KERNEL); |
|  |  | if ((source->cr\_principal && ! target->cr\_principal) || |
|  |  | (source->cr\_raw\_principal && ! target->cr\_raw\_principal)) |
|  |  | return -ENOMEM; |
|  |  |  |
|  |  | ret = strdup\_if\_nonnull(&target->cr\_principal, source->cr\_principal); |
|  |  | if (ret) |
|  |  | return ret; |
|  |  | ret = strdup\_if\_nonnull(&target->cr\_raw\_principal, |
|  |  | source->cr\_raw\_principal); |
|  |  | if (ret) |
|  |  | return ret; |
|  |  | target->cr\_flavor = source->cr\_flavor; |
|  |  | target->cr\_uid = source->cr\_uid; |
|  |  | target->cr\_gid = source->cr\_gid; |
| Expand Down | |  |

19 changes: 12 additions & 7 deletions

19
[fs/nfsd/nfs4xdr.c](#diff-73cdbffe3e14281cbda36e7f9df6d6db198f91b25529692748944dae803908ae "fs/nfsd/nfs4xdr.c")

Show comments

[View file](/torvalds/linux/blob/c70422f760c120480fee4de6c38804c72aa26bc1/fs/nfsd/nfs4xdr.c)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -2831,9 +2831,14 @@ nfsd4\_encode\_fattr(struct xdr\_stream \*xdr, struct svc\_fh \*fhp, |
|  |  | } |
|  |  | #endif /\* CONFIG\_NFSD\_PNFS \*/ |
|  |  | if (bmval2 & FATTR4\_WORD2\_SUPPATTR\_EXCLCREAT) { |
|  |  | status = nfsd4\_encode\_bitmap(xdr, NFSD\_SUPPATTR\_EXCLCREAT\_WORD0, |
|  |  | NFSD\_SUPPATTR\_EXCLCREAT\_WORD1, |
|  |  | NFSD\_SUPPATTR\_EXCLCREAT\_WORD2); |
|  |  | u32 supp[3]; |
|  |  |  |
|  |  | memcpy(supp, nfsd\_suppattrs[minorversion], sizeof(supp)); |
|  |  | supp[0] &= NFSD\_SUPPATTR\_EXCLCREAT\_WORD0; |
|  |  | supp[1] &= NFSD\_SUPPATTR\_EXCLCREAT\_WORD1; |
|  |  | supp[2] &= NFSD\_SUPPATTR\_EXCLCREAT\_WORD2; |
|  |  |  |
|  |  | status = nfsd4\_encode\_bitmap(xdr, supp[0], supp[1], supp[2]); |
|  |  | if (status) |
|  |  | goto out; |
|  |  | } |
| Expand Down  Expand Up | | @@ -4119,8 +4124,7 @@ nfsd4\_encode\_getdeviceinfo(struct nfsd4\_compoundres \*resp, \_\_be32 nfserr, |
|  |  | struct nfsd4\_getdeviceinfo \*gdev) |
|  |  | { |
|  |  | struct xdr\_stream \*xdr = &resp->xdr; |
|  |  | const struct nfsd4\_layout\_ops \*ops = |
|  |  | nfsd4\_layout\_ops[gdev->gd\_layout\_type]; |
|  |  | const struct nfsd4\_layout\_ops \*ops; |
|  |  | u32 starting\_len = xdr->buf->len, needed\_len; |
|  |  | \_\_be32 \*p; |
|  |  |  |
| Expand All | | @@ -4137,6 +4141,7 @@ nfsd4\_encode\_getdeviceinfo(struct nfsd4\_compoundres \*resp, \_\_be32 nfserr, |
|  |  |  |
|  |  | /\* If maxcount is 0 then just update notifications \*/ |
|  |  | if (gdev->gd\_maxcount != 0) { |
|  |  | ops = nfsd4\_layout\_ops[gdev->gd\_layout\_type]; |
|  |  | nfserr = ops->encode\_getdeviceinfo(xdr, gdev); |
|  |  | if (nfserr) { |
|  |  | /\* |
| Expand Down  Expand Up | | @@ -4189,8 +4194,7 @@ nfsd4\_encode\_layoutget(struct nfsd4\_compoundres \*resp, \_\_be32 nfserr, |
|  |  | struct nfsd4\_layoutget \*lgp) |
|  |  | { |
|  |  | struct xdr\_stream \*xdr = &resp->xdr; |
|  |  | const struct nfsd4\_layout\_ops \*ops = |
|  |  | nfsd4\_layout\_ops[lgp->lg\_layout\_type]; |
|  |  | const struct nfsd4\_layout\_ops \*ops; |
|  |  | \_\_be32 \*p; |
|  |  |  |
|  |  | dprintk("%s: err %d\n", \_\_func\_\_, nfserr); |
| Expand All | | @@ -4213,6 +4217,7 @@ nfsd4\_encode\_layoutget(struct nfsd4\_compoundres \*resp, \_\_be32 nfserr, |
|  |  | \*p++ = cpu\_to\_be32(lgp->lg\_seg.iomode); |
|  |  | \*p++ = cpu\_to\_be32(lgp->lg\_layout\_type); |
|  |  |  |
|  |  | ops = nfsd4\_layout\_ops[lgp->lg\_layout\_type]; |
|  |  | nfserr = ops->encode\_layoutget(xdr, lgp); |
|  |  | out: |
|  |  | kfree(lgp->lg\_content); |
| Expand Down | |  |

13 changes: 10 additions & 3 deletions

13
[fs/nfsd/nfsxdr.c](#diff-dc9f2d0c999a2fce7eafbacec69a1f40e23e4085a3745b73daf27dc352621425 "fs/nfsd/nfsxdr.c")

Show comments

[View file](/torvalds/linux/blob/c70422f760c120480fee4de6c38804c72aa26bc1/fs/nfsd/nfsxdr.c)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -257,6 +257,9 @@ nfssvc\_decode\_readargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, |
|  |  | len = args->count = ntohl(\*p++); |
|  |  | p++; /\* totalcount - unused \*/ |
|  |  |  |
|  |  | if (!xdr\_argsize\_check(rqstp, p)) |
|  |  | return 0; |
|  |  |  |
|  |  | len = min\_t(unsigned int, len, NFSSVC\_MAXBLKSIZE\_V2); |
|  |  |  |
|  |  | /\* set up somewhere to store response. |
| Expand All | | @@ -272,7 +275,7 @@ nfssvc\_decode\_readargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, |
|  |  | v++; |
|  |  | } |
|  |  | args->vlen = v; |
|  |  | return xdr\_argsize\_check(rqstp, p); |
|  |  | return 1; |
|  |  | } |
|  |  |  |
|  |  | int |
| Expand Down  Expand Up | | @@ -362,9 +365,11 @@ nfssvc\_decode\_readlinkargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, struct nfsd\_readli |
|  |  | p = decode\_fh(p, &args->fh); |
|  |  | if (!p) |
|  |  | return 0; |
|  |  | if (!xdr\_argsize\_check(rqstp, p)) |
|  |  | return 0; |
|  |  | args->buffer = page\_address(\*(rqstp->rq\_next\_page++)); |
|  |  |  |
|  |  | return xdr\_argsize\_check(rqstp, p); |
|  |  | return 1; |
|  |  | } |
|  |  |  |
|  |  | int |
| Expand Down  Expand Up | | @@ -402,9 +407,11 @@ nfssvc\_decode\_readdirargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, |
|  |  | args->cookie = ntohl(\*p++); |
|  |  | args->count = ntohl(\*p++); |
|  |  | args->count = min\_t(u32, args->count, PAGE\_SIZE); |
|  |  | if (!xdr\_argsize\_check(rqstp, p)) |
|  |  | return 0; |
|  |  | args->buffer = page\_address(\*(rqstp->rq\_next\_page++)); |
|  |  |  |
|  |  | return xdr\_argsize\_check(rqstp, p); |
|  |  | return 1; |
|  |  | } |
|  |  |  |
|  |  | /\* |
| Expand Down | |  |

24 changes: 20 additions & 4 deletions

24
[fs/nfsd/vfs.c](#diff-71e6835280f17a5cf4ead33e8d368ebbf021409dbdf0bea027e6f93eff139d14 "fs/nfsd/vfs.c")

Show comments

[View file](/torvalds/linux/blob/c70422f760c120480fee4de6c38804c72aa26bc1/fs/nfsd/vfs.c)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -94,6 +94,12 @@ nfsd\_cross\_mnt(struct svc\_rqst \*rqstp, struct dentry \*\*dpp, |
|  |  | err = follow\_down(&path); |
|  |  | if (err < 0) |
|  |  | goto out; |
|  |  | if (path.mnt == exp->ex\_path.mnt && path.dentry == dentry && |
|  |  | nfsd\_mountpoint(dentry, exp) == 2) { |
|  |  | /\* This is only a mountpoint in some other namespace \*/ |
|  |  | path\_put(&path); |
|  |  | goto out; |
|  |  | } |
|  |  |  |
|  |  | exp2 = rqst\_exp\_get\_by\_name(rqstp, &path); |
|  |  | if (IS\_ERR(exp2)) { |
| Expand Down  Expand Up | | @@ -167,16 +173,26 @@ static int nfsd\_lookup\_parent(struct svc\_rqst \*rqstp, struct dentry \*dparent, st |
|  |  | /\* |
|  |  | \* For nfsd purposes, we treat V4ROOT exports as though there was an |
|  |  | \* export at \*every\* directory. |
|  |  | \* We return: |
|  |  | \* '1' if this dentry \*must\* be an export point, |
|  |  | \* '2' if it might be, if there is really a mount here, and |
|  |  | \* '0' if there is no chance of an export point here. |
|  |  | \*/ |
|  |  | int nfsd\_mountpoint(struct dentry \*dentry, struct svc\_export \*exp) |
|  |  | { |
|  |  | if (d\_mountpoint(dentry)) |
|  |  | if (!d\_inode(dentry)) |
|  |  | return 0; |
|  |  | if (exp->ex\_flags & NFSEXP\_V4ROOT) |
|  |  | return 1; |
|  |  | if (nfsd4\_is\_junction(dentry)) |
|  |  | return 1; |
|  |  | if (!(exp->ex\_flags & NFSEXP\_V4ROOT)) |
|  |  | return 0; |
|  |  | return d\_inode(dentry) != NULL; |
|  |  | if (d\_mountpoint(dentry)) |
|  |  | /\* |
|  |  | \* Might only be a mountpoint in a different namespace, |
|  |  | \* but we need to check. |
|  |  | \*/ |
|  |  | return 2; |
|  |  | return 0; |
|  |  | } |
|  |  |  |
|  |  | \_\_be32 |
| Expand Down | |  |

3 changes: 3 additions & 0 deletions

3
[include/linux/sunrpc/rpc\_rdma.h](#diff-8ede9986129bdfc2537e39d2c691335c9f5e9665540a65bea8d89ee1151248c5 "include/linux/sunrpc/rpc_rdma.h")

Show comments

[View file](/torvalds/linux/blob/c70422f760c120480fee4de6c38804c72aa26bc1/include/linux/sunrpc/rpc_rdma.h)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -143,6 +143,9 @@ enum rpcrdma\_proc { |
|  |  | #define rdma\_done cpu\_to\_be32(RDMA\_DONE) |
|  |  | #define rdma\_error cpu\_to\_be32(RDMA\_ERROR) |
|  |  |  |
|  |  | #define err\_vers cpu\_to\_be32(ERR\_VERS) |
|  |  | #define err\_chunk cpu\_to\_be32(ERR\_CHUNK) |
|  |  |  |
|  |  | /\* |
|  |  | \* Private extension to RPC-over-RDMA Version One. |
|  |  | \* Message passed during RDMA-CM connection set-up. |
| Expand Down | |  |

 Loading

Oops, something went wrong.
 Retry

Toggle all file notes
Toggle all file annotations

### 0 comments on commit `c70422f`

Please
[sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftorvalds%2Flinux%2Fcommit%2Fc70422f760c120480fee4de6c38804c72aa26bc1) to comment.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from git.kernel.org_1f4596c2_20250124_221807.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=c70422f760c120480fee4de6c38804c72aa26bc1)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=c70422f760c120480fee4de6c38804c72aa26bc1)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c70422f760c120480fee4de6c38804c72aa26bc1)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=c70422f760c120480fee4de6c38804c72aa26bc1)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Linus Torvalds <torvalds@linux-foundation.org> | 2017-05-10 13:29:23 -0700 |
| --- | --- | --- |
| committer | Linus Torvalds <torvalds@linux-foundation.org> | 2017-05-10 13:29:23 -0700 |
| commit | [c70422f760c120480fee4de6c38804c72aa26bc1](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c70422f760c120480fee4de6c38804c72aa26bc1) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=c70422f760c120480fee4de6c38804c72aa26bc1)) | |
| tree | [9c61102379bbbf090c13c373ffdace76fe7711ef](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=c70422f760c120480fee4de6c38804c72aa26bc1) | |
| parent | [73ccb023a2f25b72c4b95499ca24760588014614](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=73ccb023a2f25b72c4b95499ca24760588014614) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=c70422f760c120480fee4de6c38804c72aa26bc1&id2=73ccb023a2f25b72c4b95499ca24760588014614)) | |
| parent | [b26b78cb726007533d81fdf90a62e915002ef5c8](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b26b78cb726007533d81fdf90a62e915002ef5c8) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=c70422f760c120480fee4de6c38804c72aa26bc1&id2=b26b78cb726007533d81fdf90a62e915002ef5c8)) | |
| download | [linux-c70422f760c120480fee4de6c38804c72aa26bc1.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-c70422f760c120480fee4de6c38804c72aa26bc1.tar.gz) | |

Merge tag 'nfsd-4.12' of git://linux-nfs.org/~bfields/linuxPull nfsd updates from Bruce Fields:
"Another RDMA update from Chuck Lever, and a bunch of miscellaneous
bugfixes"
\* tag 'nfsd-4.12' of git://linux-nfs.org/~bfields/linux: (26 commits)
nfsd: Fix up the "supattr\_exclcreat" attributes
nfsd: encoders mustn't use unitialized values in error cases
nfsd: fix undefined behavior in nfsd4\_layout\_verify
lockd: fix lockd shutdown race
NFSv4: Fix callback server shutdown
SUNRPC: Refactor svc\_set\_num\_threads()
NFSv4.x/callback: Create the callback service through svc\_create\_pooled
lockd: remove redundant check on block
svcrdma: Clean out old XDR encoders
svcrdma: Remove the req\_map cache
svcrdma: Remove unused RDMA Write completion handler
svcrdma: Reduce size of sge array in struct svc\_rdma\_op\_ctxt
svcrdma: Clean up RPC-over-RDMA backchannel reply processing
svcrdma: Report Write/Reply chunk overruns
svcrdma: Clean up RDMA\_ERROR path
svcrdma: Use rdma\_rw API in RPC reply path
svcrdma: Introduce local rdma\_rw API helpers
svcrdma: Clean up svc\_rdma\_get\_inv\_rkey()
svcrdma: Add helper to save pages under I/O
svcrdma: Eliminate RPCRDMA\_SQ\_DEPTH\_MULT
...
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=c70422f760c120480fee4de6c38804c72aa26bc1)

| -rw-r--r-- | [fs/lockd/svc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/lockd/svc.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 6 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/lockd/svclock.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/lockd/svclock.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 18 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfs/callback.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfs/callback.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 26 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfs3xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfs3xdr.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 23 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfs4proc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfs4proc.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfs4state.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfs4state.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 25 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfs4xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfs4xdr.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 19 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfsxdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfsxdr.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 13 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/vfs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/vfs.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 24 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/sunrpc/rpc\_rdma.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/sunrpc/rpc_rdma.h?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/sunrpc/svc.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/sunrpc/svc.h?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/sunrpc/svc\_rdma.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/sunrpc/svc_rdma.h?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 75 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/uapi/linux/nfsd/cld.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/uapi/linux/nfsd/cld.h?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 14 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sunrpc/Kconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/sunrpc/Kconfig?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sunrpc/svc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/sunrpc/svc.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 134 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sunrpc/xprtrdma/Makefile](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/sunrpc/xprtrdma/Makefile?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sunrpc/xprtrdma/svc\_rdma.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/sunrpc/xprtrdma/svc_rdma.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sunrpc/xprtrdma/svc\_rdma\_backchannel.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/sunrpc/xprtrdma/svc_rdma_backchannel.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 71 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sunrpc/xprtrdma/svc\_rdma\_marshal.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/sunrpc/xprtrdma/svc_rdma_marshal.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 89 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sunrpc/xprtrdma/svc\_rdma\_recvfrom.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 79 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sunrpc/xprtrdma/svc\_rdma\_rw.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/sunrpc/xprtrdma/svc_rdma_rw.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 512 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sunrpc/xprtrdma/svc\_rdma\_sendto.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/sunrpc/xprtrdma/svc_rdma_sendto.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 978 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sunrpc/xprtrdma/svc\_rdma\_transport.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/sunrpc/xprtrdma/svc_rdma_transport.c?id=c70422f760c120480fee4de6c38804c72aa26bc1) | 110 | |  |  |  | | --- | --- | --- | |

23 files changed, 1334 insertions, 903 deletions

| diff --git a/fs/lockd/svc.c b/fs/lockd/svc.cindex e7c8b9c76e4857..5d481e8a1b5d0c 100644--- a/[fs/lockd/svc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/lockd/svc.c?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[fs/lockd/svc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/lockd/svc.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -132,6 +132,8 @@ lockd(void \*vrqstp) { int err = 0; struct svc\_rqst \*rqstp = vrqstp;+ struct net \*net = &init\_net;+ struct lockd\_net \*ln = net\_generic(net, lockd\_net\_id);  /\* try\_to\_freeze() is called from svc\_recv() \*/ set\_freezable();@@ -176,6 +178,8 @@ lockd(void \*vrqstp) if (nlmsvc\_ops) nlmsvc\_invalidate\_all(); nlm\_shutdown\_hosts();+ cancel\_delayed\_work\_sync(&ln->grace\_period\_end);+ locks\_end\_grace(&ln->lockd\_manager); return 0; } @@ -270,8 +274,6 @@ static void lockd\_down\_net(struct svc\_serv \*serv, struct net \*net) if (ln->nlmsvc\_users) { if (--ln->nlmsvc\_users == 0) { nlm\_shutdown\_hosts\_net(net);- cancel\_delayed\_work\_sync(&ln->grace\_period\_end);- locks\_end\_grace(&ln->lockd\_manager); svc\_shutdown\_net(serv, net); dprintk("lockd\_down\_net: per-net data destroyed; net=%p\n", net); }diff --git a/fs/lockd/svclock.c b/fs/lockd/svclock.cindex 5581e020644bda..3507c80d1d4b96 100644--- a/[fs/lockd/svclock.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/lockd/svclock.c?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[fs/lockd/svclock.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/lockd/svclock.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -870,15 +870,15 @@ nlmsvc\_grant\_reply(struct nlm\_cookie \*cookie, \_\_be32 status) if (!(block = nlmsvc\_find\_block(cookie))) return; - if (block) {- if (status == nlm\_lck\_denied\_grace\_period) {- /\* Try again in a couple of seconds \*/- nlmsvc\_insert\_block(block, 10 \* HZ);- } else {- /\* Lock is now held by client, or has been rejected.- \* In both cases, the block should be removed. \*/- nlmsvc\_unlink\_block(block);- }+ if (status == nlm\_lck\_denied\_grace\_period) {+ /\* Try again in a couple of seconds \*/+ nlmsvc\_insert\_block(block, 10 \* HZ);+ } else {+ /\*+ \* Lock is now held by client, or has been rejected.+ \* In both cases, the block should be removed.+ \*/+ nlmsvc\_unlink\_block(block); } nlmsvc\_release\_block(block); }diff --git a/fs/nfs/callback.c b/fs/nfs/callback.cindex 773774531aff5f..73a1f928226c05 100644--- a/[fs/nfs/callback.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfs/callback.c?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[fs/nfs/callback.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfs/callback.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -76,7 +76,10 @@ nfs4\_callback\_svc(void \*vrqstp)  set\_freezable(); - while (!kthread\_should\_stop()) {+ while (!kthread\_freezable\_should\_stop(NULL)) {++ if (signal\_pending(current))+ flush\_signals(current); /\* \* Listen for a request on the socket \*/@@ -85,6 +88,8 @@ nfs4\_callback\_svc(void \*vrqstp) continue; svc\_process(rqstp); }+ svc\_exit\_thread(rqstp);+ module\_put\_and\_exit(0); return 0; } @@ -103,9 +108,10 @@ nfs41\_callback\_svc(void \*vrqstp)  set\_freezable(); - while (!kthread\_should\_stop()) {- if (try\_to\_freeze())- continue;+ while (!kthread\_freezable\_should\_stop(NULL)) {++ if (signal\_pending(current))+ flush\_signals(current);  prepare\_to\_wait(&serv->sv\_cb\_waitq, &wq, TASK\_INTERRUPTIBLE); spin\_lock\_bh(&serv->sv\_cb\_lock);@@ -121,11 +127,13 @@ nfs41\_callback\_svc(void \*vrqstp) error); } else { spin\_unlock\_bh(&serv->sv\_cb\_lock);- schedule();+ if (!kthread\_should\_stop())+ schedule(); finish\_wait(&serv->sv\_cb\_waitq, &wq); }- flush\_signals(current); }+ svc\_exit\_thread(rqstp);+ module\_put\_and\_exit(0); return 0; } @@ -221,14 +229,14 @@ err\_bind: static struct svc\_serv\_ops nfs40\_cb\_sv\_ops = { .svo\_function = nfs4\_callback\_svc, .svo\_enqueue\_xprt = svc\_xprt\_do\_enqueue,- .svo\_setup = svc\_set\_num\_threads,+ .svo\_setup = svc\_set\_num\_threads\_sync, .svo\_module = THIS\_MODULE, }; #if defined(CONFIG\_NFS\_V4\_1) static struct svc\_serv\_ops nfs41\_cb\_sv\_ops = { .svo\_function = nfs41\_callback\_svc, .svo\_enqueue\_xprt = svc\_xprt\_do\_enqueue,- .svo\_setup = svc\_set\_num\_threads,+ .svo\_setup = svc\_set\_num\_threads\_sync, .svo\_module = THIS\_MODULE, }; @@ -280,7 +288,7 @@ static struct svc\_serv \*nfs\_callback\_create\_svc(int minorversion) printk(KERN\_WARNING "nfs\_callback\_create\_svc: no kthread, %d users??\n", cb\_info->users); - serv = svc\_create(&nfs4\_callback\_program, NFS4\_CALLBACK\_BUFSIZE, sv\_ops);+ serv = svc\_create\_pooled(&nfs4\_callback\_program, NFS4\_CALLBACK\_BUFSIZE, sv\_ops); if (!serv) { printk(KERN\_ERR "nfs\_callback\_create\_svc: create service failed\n"); return ERR\_PTR(-ENOMEM);diff --git a/fs/nfsd/nfs3xdr.c b/fs/nfsd/nfs3xdr.cindex 452334694a5d1f..12feac6ee2fd46 100644--- a/[fs/nfsd/nfs3xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs3xdr.c?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[fs/nfsd/nfs3xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs3xdr.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -334,8 +334,11 @@ nfs3svc\_decode\_readargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, if (!p) return 0; p = xdr\_decode\_hyper(p, &args->offset);- args->count = ntohl(\*p++);++ if (!xdr\_argsize\_check(rqstp, p))+ return 0;+ len = min(args->count, max\_blocksize);  /\* set up the kvec \*/@@ -349,7 +352,7 @@ nfs3svc\_decode\_readargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, v++; } args->vlen = v;- return xdr\_argsize\_check(rqstp, p);+ return 1; }  int@@ -541,9 +544,11 @@ nfs3svc\_decode\_readlinkargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, p = decode\_fh(p, &args->fh); if (!p) return 0;+ if (!xdr\_argsize\_check(rqstp, p))+ return 0; args->buffer = page\_address(\*(rqstp->rq\_next\_page++)); - return xdr\_argsize\_check(rqstp, p);+ return 1; }  int@@ -569,10 +574,14 @@ nfs3svc\_decode\_readdirargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, args->verf = p; p += 2; args->dircount = ~0; args->count = ntohl(\*p++);++ if (!xdr\_argsize\_check(rqstp, p))+ return 0;+ args->count = min\_t(u32, args->count, PAGE\_SIZE); args->buffer = page\_address(\*(rqstp->rq\_next\_page++)); - return xdr\_argsize\_check(rqstp, p);+ return 1; }  int@@ -590,6 +599,9 @@ nfs3svc\_decode\_readdirplusargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, args->dircount = ntohl(\*p++); args->count = ntohl(\*p++); + if (!xdr\_argsize\_check(rqstp, p))+ return 0;+ len = args->count = min(args->count, max\_blocksize); while (len > 0) { struct page \*p = \*(rqstp->rq\_next\_page++);@@ -597,8 +609,7 @@ nfs3svc\_decode\_readdirplusargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, args->buffer = page\_address(p); len -= PAGE\_SIZE; }-- return xdr\_argsize\_check(rqstp, p);+ return 1; }  intdiff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.cindex d86031b6ad7930..c453a1998e003d 100644--- a/[fs/nfsd/nfs4proc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4proc.c?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[fs/nfsd/nfs4proc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4proc.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -1259,7 +1259,8 @@ nfsd4\_layout\_verify(struct svc\_export \*exp, unsigned int layout\_type) return NULL; } - if (!(exp->ex\_layout\_types & (1 << layout\_type))) {+ if (layout\_type >= LAYOUT\_TYPE\_MAX ||+ !(exp->ex\_layout\_types & (1 << layout\_type))) { dprintk("%s: layout type %d not supported\n", \_\_func\_\_, layout\_type); return NULL;diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.cindex e9ef50addddb44..22002fb75a1827 100644--- a/[fs/nfsd/nfs4state.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4state.c?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[fs/nfsd/nfs4state.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4state.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -1912,28 +1912,15 @@ static void copy\_clid(struct nfs4\_client \*target, struct nfs4\_client \*source) target->cl\_clientid.cl\_id = source->cl\_clientid.cl\_id;  } -int strdup\_if\_nonnull(char \*\*target, char \*source)-{- if (source) {- \*target = kstrdup(source, GFP\_KERNEL);- if (!\*target)- return -ENOMEM;- } else- \*target = NULL;- return 0;-}- static int copy\_cred(struct svc\_cred \*target, struct svc\_cred \*source) {- int ret;+ target->cr\_principal = kstrdup(source->cr\_principal, GFP\_KERNEL);+ target->cr\_raw\_principal = kstrdup(source->cr\_raw\_principal,+ GFP\_KERNEL);+ if ((source->cr\_principal && ! target->cr\_principal) ||+ (source->cr\_raw\_principal && ! target->cr\_raw\_principal))+ return -ENOMEM; - ret = strdup\_if\_nonnull(&target->cr\_principal, source->cr\_principal);- if (ret)- return ret;- ret = strdup\_if\_nonnull(&target->cr\_raw\_principal,- source->cr\_raw\_principal);- if (ret)- return ret; target->cr\_flavor = source->cr\_flavor; target->cr\_uid = source->cr\_uid; target->cr\_gid = source->cr\_gid;diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.cindex 33017d652b1da2..26780d53a6f941 100644--- a/[fs/nfsd/nfs4xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4xdr.c?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[fs/nfsd/nfs4xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4xdr.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -2831,9 +2831,14 @@ out\_acl: } #endif /\* CONFIG\_NFSD\_PNFS \*/ if (bmval2 & FATTR4\_WORD2\_SUPPATTR\_EXCLCREAT) {- status = nfsd4\_encode\_bitmap(xdr, NFSD\_SUPPATTR\_EXCLCREAT\_WORD0,- NFSD\_SUPPATTR\_EXCLCREAT\_WORD1,- NFSD\_SUPPATTR\_EXCLCREAT\_WORD2);+ u32 supp[3];++ memcpy(supp, nfsd\_suppattrs[minorversion], sizeof(supp));+ supp[0] &= NFSD\_SUPPATTR\_EXCLCREAT\_WORD0;+ supp[1] &= NFSD\_SUPPATTR\_EXCLCREAT\_WORD1;+ supp[2] &= NFSD\_SUPPATTR\_EXCLCREAT\_WORD2;++ status = nfsd4\_encode\_bitmap(xdr, supp[0], supp[1], supp[2]); if (status) goto out; }@@ -4119,8 +4124,7 @@ nfsd4\_encode\_getdeviceinfo(struct nfsd4\_compoundres \*resp, \_\_be32 nfserr, struct nfsd4\_getdeviceinfo \*gdev) { struct xdr\_stream \*xdr = &resp->xdr;- const struct nfsd4\_layout\_ops \*ops =- nfsd4\_layout\_ops[gdev->gd\_layout\_type];+ const struct nfsd4\_layout\_ops \*ops; u32 starting\_len = xdr->buf->len, needed\_len; \_\_be32 \*p; @@ -4137,6 +4141,7 @@ nfsd4\_encode\_getdeviceinfo(struct nfsd4\_compoundres \*resp, \_\_be32 nfserr,  /\* If maxcount is 0 then just update notifications \*/ if (gdev->gd\_maxcount != 0) {+ ops = nfsd4\_layout\_ops[gdev->gd\_layout\_type]; nfserr = ops->encode\_getdeviceinfo(xdr, gdev); if (nfserr) { /\*@@ -4189,8 +4194,7 @@ nfsd4\_encode\_layoutget(struct nfsd4\_compoundres \*resp, \_\_be32 nfserr, struct nfsd4\_layoutget \*lgp) { struct xdr\_stream \*xdr = &resp->xdr;- const struct nfsd4\_layout\_ops \*ops =- nfsd4\_layout\_ops[lgp->lg\_layout\_type];+ const struct nfsd4\_layout\_ops \*ops; \_\_be32 \*p;  dprintk("%s: err %d\n", \_\_func\_\_, nfserr);@@ -4213,6 +4217,7 @@ nfsd4\_encode\_layoutget(struct nfsd4\_compoundres \*resp, \_\_be32 nfserr, \*p++ = cpu\_to\_be32(lgp->lg\_seg.iomode); \*p++ = cpu\_to\_be32(lgp->lg\_layout\_type); + ops = nfsd4\_layout\_ops[lgp->lg\_layout\_type]; nfserr = ops->encode\_layoutget(xdr, lgp); out: kfree(lgp->lg\_content);diff --git a/fs/nfsd/nfsxdr.c b/fs/nfsd/nfsxdr.cindex de07ff62577782..6a4947a3f4fa82 100644--- a/[fs/nfsd/nfsxdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfsxdr.c?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[fs/nfsd/nfsxdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfsxdr.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -257,6 +257,9 @@ nfssvc\_decode\_readargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, len = args->count = ntohl(\*p++); p++; /\* totalcount - unused \*/ + if (!xdr\_argsize\_check(rqstp, p))+ return 0;+ len = min\_t(unsigned int, len, NFSSVC\_MAXBLKSIZE\_V2);  /\* set up somewhere to store response.@@ -272,7 +275,7 @@ nfssvc\_decode\_readargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, v++; } args->vlen = v;- return xdr\_argsize\_check(rqstp, p);+ return 1; }  int@@ -362,9 +365,11 @@ nfssvc\_decode\_readlinkargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, struct nfsd\_readli p = decode\_fh(p, &args->fh); if (!p) return 0;+ if (!xdr\_argsize\_check(rqstp, p))+ return 0; args->buffer = page\_address(\*(rqstp->rq\_next\_page++)); - return xdr\_argsize\_check(rqstp, p);+ return 1; }  int@@ -402,9 +407,11 @@ nfssvc\_decode\_readdirargs(struct svc\_rqst \*rqstp, \_\_be32 \*p, args->cookie = ntohl(\*p++); args->count = ntohl(\*p++); args->count = min\_t(u32, args->count, PAGE\_SIZE);+ if (!xdr\_argsize\_check(rqstp, p))+ return 0; args->buffer = page\_address(\*(rqstp->rq\_next\_page++)); - return xdr\_argsize\_check(rqstp, p);+ return 1; }  /\*diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.cindex 9aaf6ca7756998..2be32955d7f27d 100644--- a/[fs/nfsd/vfs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/vfs.c?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[fs/nfsd/vfs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/vfs.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -94,6 +94,12 @@ nfsd\_cross\_mnt(struct svc\_rqst \*rqstp, struct dentry \*\*dpp, err = follow\_down(&path); if (err < 0) goto out;+ if (path.mnt == exp->ex\_path.mnt && path.dentry == dentry &&+ nfsd\_mountpoint(dentry, exp) == 2) {+ /\* This is only a mountpoint in some other namespace \*/+ path\_put(&path);+ goto out;+ }  exp2 = rqst\_exp\_get\_by\_name(rqstp, &path); if (IS\_ERR(exp2)) {@@ -167,16 +173,26 @@ static int nfsd\_lookup\_parent(struct svc\_rqst \*rqstp, struct dentry \*dparent, st /\* \* For nfsd purposes, we treat V4ROOT exports as though there was an \* export at \*every\* directory.+ \* We return:+ \* '1' if this dentry \*must\* be an export point,+ \* '2' if it might be, if there is really a mount here, and+ \* '0' if there is no chance of an export point here. \*/ int nfsd\_mountpoint(struct dentry \*dentry, struct svc\_export \*exp) {- if (d\_mountpoint(dentry))+ if (!d\_inode(dentry))+ return 0;+ if (exp->ex\_flags & NFSEXP\_V4ROOT) return 1; if (nfsd4\_is\_junction(dentry)) return 1;- if (!(exp->ex\_flags & NFSEXP\_V4ROOT))- return 0;- return d\_inode(dentry) != NULL;+ if (d\_mountpoint(dentry))+ /\*+ \* Might only be a mountpoint in a different namespace,+ \* but we need to check.+ \*/+ return 2;+ return 0; }  \_\_be32diff --git a/include/linux/sunrpc/rpc\_rdma.h b/include/linux/sunrpc/rpc\_rdma.hindex 245fc59b73247d..b7e85b341a54f5 100644--- a/[include/linux/sunrpc/rpc\_rdma.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/sunrpc/rpc_rdma.h?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[include/linux/sunrpc/rpc\_rdma.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/sunrpc/rpc_rdma.h?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -143,6 +143,9 @@ enum rpcrdma\_proc { #define rdma\_done cpu\_to\_be32(RDMA\_DONE) #define rdma\_error cpu\_to\_be32(RDMA\_ERROR) +#define err\_vers cpu\_to\_be32(ERR\_VERS)+#define err\_chunk cpu\_to\_be32(ERR\_CHUNK)+ /\* \* Private extension to RPC-over-RDMA Version One. \* Message passed during RDMA-CM connection set-up.diff --git a/include/linux/sunrpc/svc.h b/include/linux/sunrpc/svc.hindex e770abeed32d71..94631026f79c56 100644--- a/[include/linux/sunrpc/svc.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/sunrpc/svc.h?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[include/linux/sunrpc/svc.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/sunrpc/svc.h?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -336,8 +336,7 @@ xdr\_argsize\_check(struct svc\_rqst \*rqstp, \_\_be32 \*p) { char \*cp = (char \*)p; struct kvec \*vec = &rqstp->rq\_arg.head[0];- return cp >= (char\*)vec->iov\_base- && cp <= (char\*)vec->iov\_base + vec->iov\_len;+ return cp == (char \*)vec->iov\_base + vec->iov\_len; }  static inline int@@ -474,6 +473,7 @@ void svc\_pool\_map\_put(void); struct svc\_serv \* svc\_create\_pooled(struct svc\_program \*, unsigned int, struct svc\_serv\_ops \*); int svc\_set\_num\_threads(struct svc\_serv \*, struct svc\_pool \*, int);+int svc\_set\_num\_threads\_sync(struct svc\_serv \*, struct svc\_pool \*, int); int svc\_pool\_stats\_open(struct svc\_serv \*serv, struct file \*file); void svc\_destroy(struct svc\_serv \*); void svc\_shutdown\_net(struct svc\_serv \*, struct net \*);diff --git a/include/linux/sunrpc/svc\_rdma.h b/include/linux/sunrpc/svc\_rdma.hindex b105f73e3ca263..f3787d800ba46b 100644--- a/[include/linux/sunrpc/svc\_rdma.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/sunrpc/svc_rdma.h?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[include/linux/sunrpc/svc\_rdma.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/sunrpc/svc_rdma.h?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -48,6 +48,12 @@ #include <rdma/rdma\_cm.h> #define SVCRDMA\_DEBUG +/\* Default and maximum inline threshold sizes \*/+enum {+ RPCRDMA\_DEF\_INLINE\_THRESH = 4096,+ RPCRDMA\_MAX\_INLINE\_THRESH = 65536+};+ /\* RPC/RDMA parameters and stats \*/ extern unsigned int svcrdma\_ord; extern unsigned int svcrdma\_max\_requests;@@ -85,27 +91,11 @@ struct svc\_rdma\_op\_ctxt { enum dma\_data\_direction direction; int count; unsigned int mapped\_sges;- struct ib\_sge sge[RPCSVC\_MAXPAGES];+ struct ib\_send\_wr send\_wr;+ struct ib\_sge sge[1 + RPCRDMA\_MAX\_INLINE\_THRESH / PAGE\_SIZE]; struct page \*pages[RPCSVC\_MAXPAGES]; }; -/\*- \* NFS\_ requests are mapped on the client side by the chunk lists in- \* the RPCRDMA header. During the fetching of the RPC from the client- \* and the writing of the reply to the client, the memory in the- \* client and the memory in the server must be mapped as contiguous- \* vaddr/len for access by the hardware. These data strucures keep- \* these mappings.- \*- \* For an RDMA\_WRITE, the 'sge' maps the RPC REPLY. For RDMA\_READ, the- \* 'sge' in the svc\_rdma\_req\_map maps the server side RPC reply and the- \* 'ch' field maps the read-list of the RPCRDMA header to the 'sge'- \* mapping of the reply.- \*/-struct svc\_rdma\_chunk\_sge {- int start; /\* sge no for this chunk \*/- int count; /\* sge count for this chunk \*/-}; struct svc\_rdma\_fastreg\_mr { struct ib\_mr \*mr; struct scatterlist \*sg;@@ -114,15 +104,7 @@ struct svc\_rdma\_fastreg\_mr { enum dma\_data\_direction direction; struct list\_head frmr\_list; };-struct svc\_rdma\_req\_map {- struct list\_head free;- unsigned long count;- union {- struct kvec sge[RPCSVC\_MAXPAGES];- struct svc\_rdma\_chunk\_sge ch[RPCSVC\_MAXPAGES];- unsigned long lkey[RPCSVC\_MAXPAGES];- };-};+ #define RDMACTXT\_F\_LAST\_CTXT 2  #define SVCRDMA\_DEVCAP\_FAST\_REG 1 /\* fast mr registration \*/@@ -144,14 +126,15 @@ struct svcxprt\_rdma { u32 sc\_max\_requests; /\* Max requests \*/ u32 sc\_max\_bc\_requests;/\* Backward credits \*/ int sc\_max\_req\_size; /\* Size of each RQ WR buf \*/+ u8 sc\_port\_num;  struct ib\_pd \*sc\_pd;  spinlock\_t sc\_ctxt\_lock; struct list\_head sc\_ctxts; int sc\_ctxt\_used;- spinlock\_t sc\_map\_lock;- struct list\_head sc\_maps;+ spinlock\_t sc\_rw\_ctxt\_lock;+ struct list\_head sc\_rw\_ctxts;  struct list\_head sc\_rq\_dto\_q; spinlock\_t sc\_rq\_dto\_lock;@@ -181,9 +164,7 @@ struct svcxprt\_rdma { /\* The default ORD value is based on two outstanding full-size writes with a \* page size of 4k, or 32k \* 2 ops / 4k = 16 outstanding RDMA\_READ. \*/ #define RPCRDMA\_ORD (64/4)-#define RPCRDMA\_SQ\_DEPTH\_MULT 8 #define RPCRDMA\_MAX\_REQUESTS 32-#define RPCRDMA\_MAX\_REQ\_SIZE 4096  /\* Typical ULP usage of BC requests is NFSv4.1 backchannel. Our \* current NFSv4.1 implementation supports one backchannel slot.@@ -201,19 +182,11 @@ static inline void svc\_rdma\_count\_mappings(struct svcxprt\_rdma \*rdma,  /\* svc\_rdma\_backchannel.c \*/ extern int svc\_rdma\_handle\_bc\_reply(struct rpc\_xprt \*xprt,- struct rpcrdma\_msg \*rmsgp,+ \_\_be32 \*rdma\_resp, struct xdr\_buf \*rcvbuf);  /\* svc\_rdma\_marshal.c \*/ extern int svc\_rdma\_xdr\_decode\_req(struct xdr\_buf \*);-extern int svc\_rdma\_xdr\_encode\_error(struct svcxprt\_rdma \*,- struct rpcrdma\_msg \*,- enum rpcrdma\_errcode, \_\_be32 \*);-extern void svc\_rdma\_xdr\_encode\_write\_list(struct rpcrdma\_msg \*, int);-extern void svc\_rdma\_xdr\_encode\_reply\_array(struct rpcrdma\_write\_array \*, int);-extern void svc\_rdma\_xdr\_encode\_array\_chunk(struct rpcrdma\_write\_array \*, int,- \_\_be32, \_\_be64, u32);-extern unsigned int svc\_rdma\_xdr\_get\_reply\_hdr\_len(\_\_be32 \*rdma\_resp);  /\* svc\_rdma\_recvfrom.c \*/ extern int svc\_rdma\_recvfrom(struct svc\_rqst \*);@@ -224,16 +197,25 @@ extern int rdma\_read\_chunk\_frmr(struct svcxprt\_rdma \*, struct svc\_rqst \*, struct svc\_rdma\_op\_ctxt \*, int \*, u32 \*, u32, u32, u64, bool); +/\* svc\_rdma\_rw.c \*/+extern void svc\_rdma\_destroy\_rw\_ctxts(struct svcxprt\_rdma \*rdma);+extern int svc\_rdma\_send\_write\_chunk(struct svcxprt\_rdma \*rdma,+ \_\_be32 \*wr\_ch, struct xdr\_buf \*xdr);+extern int svc\_rdma\_send\_reply\_chunk(struct svcxprt\_rdma \*rdma,+ \_\_be32 \*rp\_ch, bool writelist,+ struct xdr\_buf \*xdr);+ /\* svc\_rdma\_sendto.c \*/-extern int svc\_rdma\_map\_xdr(struct svcxprt\_rdma \*, struct xdr\_buf \*,- struct svc\_rdma\_req\_map \*, bool);+extern int svc\_rdma\_map\_reply\_hdr(struct svcxprt\_rdma \*rdma,+ struct svc\_rdma\_op\_ctxt \*ctxt,+ \_\_be32 \*rdma\_resp, unsigned int len);+extern int svc\_rdma\_post\_send\_wr(struct svcxprt\_rdma \*rdma,+ struct svc\_rdma\_op\_ctxt \*ctxt,+ int num\_sge, u32 inv\_rkey); extern int svc\_rdma\_sendto(struct svc\_rqst \*);-extern void svc\_rdma\_send\_error(struct svcxprt\_rdma \*, struct rpcrdma\_msg \*,- int);  /\* svc\_rdma\_transport.c \*/ extern void svc\_rdma\_wc\_send(struct ib\_cq \*, struct ib\_wc \*);-extern void svc\_rdma\_wc\_write(struct ib\_cq \*, struct ib\_wc \*); extern void svc\_rdma\_wc\_reg(struct ib\_cq \*, struct ib\_wc \*); extern void svc\_rdma\_wc\_read(struct ib\_cq \*, struct ib\_wc \*); extern void svc\_rdma\_wc\_inv(struct ib\_cq \*, struct ib\_wc \*);@@ -244,9 +226,6 @@ extern int svc\_rdma\_create\_listen(struct svc\_serv \*, int, struct sockaddr \*); extern struct svc\_rdma\_op\_ctxt \*svc\_rdma\_get\_context(struct svcxprt\_rdma \*); extern void svc\_rdma\_put\_context(struct svc\_rdma\_op\_ctxt \*, int); extern void svc\_rdma\_unmap\_dma(struct svc\_rdma\_op\_ctxt \*ctxt);-extern struct svc\_rdma\_req\_map \*svc\_rdma\_get\_req\_map(struct svcxprt\_rdma \*);-extern void svc\_rdma\_put\_req\_map(struct svcxprt\_rdma \*,- struct svc\_rdma\_req\_map \*); extern struct svc\_rdma\_fastreg\_mr \*svc\_rdma\_get\_frmr(struct svcxprt\_rdma \*); extern void svc\_rdma\_put\_frmr(struct svcxprt\_rdma \*, struct svc\_rdma\_fastreg\_mr \*);diff --git a/include/uapi/linux/nfsd/cld.h b/include/uapi/linux/nfsd/cld.hindex f14a9ab06f1f70..ec260274be0ced 100644--- a/[include/uapi/linux/nfsd/cld.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/nfsd/cld.h?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[include/uapi/linux/nfsd/cld.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/nfsd/cld.h?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -22,6 +22,8 @@ #ifndef \_NFSD\_CLD\_H #define \_NFSD\_CLD\_H +#include <linux/types.h>+ /\* latest upcall version available \*/ #define CLD\_UPCALL\_VERSION 1 @@ -37,18 +39,18 @@ enum cld\_command {  /\* representation of long-form NFSv4 client ID \*/ struct cld\_name {- uint16\_t cn\_len; /\* length of cm\_id \*/+ \_\_u16 cn\_len; /\* length of cm\_id \*/ unsigned char cn\_id[NFS4\_OPAQUE\_LIMIT]; /\* client-provided \*/ } \_\_attribute\_\_((packed));  /\* message struct for communication with userspace \*/ struct cld\_msg {- uint8\_t cm\_vers; /\* upcall version \*/- uint8\_t cm\_cmd; /\* upcall command \*/- int16\_t cm\_status; /\* return code \*/- uint32\_t cm\_xid; /\* transaction id \*/+ \_\_u8 cm\_vers; /\* upcall version \*/+ \_\_u8 cm\_cmd; /\* upcall command \*/+ \_\_s16 cm\_status; /\* return code \*/+ \_\_u32 cm\_xid; /\* transaction id \*/ union {- int64\_t cm\_gracetime; /\* grace period start time \*/+ \_\_s64 cm\_gracetime; /\* grace period start time \*/ struct cld\_name cm\_name; } \_\_attribute\_\_((packed)) cm\_u; } \_\_attribute\_\_((packed));diff --git a/net/sunrpc/Kconfig b/net/sunrpc/Kconfigindex 04ce2c0b660e0d..ac09ca8032965b 100644--- a/[net/sunrpc/Kconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/Kconfig?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[net/sunrpc/Kconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/Kconfig?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -52,6 +52,7 @@ config SUNRPC\_XPRT\_RDMA tristate "RPC-over-RDMA transport" depends on SUNRPC && INFINIBAND && INFINIBAND\_ADDR\_TRANS default SUNRPC && INFINIBAND+ select SG\_POOL help This option allows the NFS client and server to use RDMA transports (InfiniBand, iWARP, or RoCE).diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.cindex a08aeb56b8e457..bc0f5a0ecbdce2 100644--- a/[net/sunrpc/svc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/svc.c?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[net/sunrpc/svc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/svc.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -702,59 +702,32 @@ found\_pool: return task; } -/\*- \* Create or destroy enough new threads to make the number- \* of threads the given number. If `pool' is non-NULL, applies- \* only to threads in that pool, otherwise round-robins between- \* all pools. Caller must ensure that mutual exclusion between this and- \* server startup or shutdown.- \*- \* Destroying threads relies on the service threads filling in- \* rqstp->rq\_task, which only the nfs ones do. Assumes the serv- \* has been created using svc\_create\_pooled().- \*- \* Based on code that used to be in nfsd\_svc() but tweaked- \* to be pool-aware.- \*/-int-svc\_set\_num\_threads(struct svc\_serv \*serv, struct svc\_pool \*pool, int nrservs)+/\* create new threads \*/+static int+svc\_start\_kthreads(struct svc\_serv \*serv, struct svc\_pool \*pool, int nrservs) { struct svc\_rqst \*rqstp; struct task\_struct \*task; struct svc\_pool \*chosen\_pool;- int error = 0; unsigned int state = serv->sv\_nrthreads-1; int node; - if (pool == NULL) {- /\* The -1 assumes caller has done a svc\_get() \*/- nrservs -= (serv->sv\_nrthreads-1);- } else {- spin\_lock\_bh(&pool->sp\_lock);- nrservs -= pool->sp\_nrthreads;- spin\_unlock\_bh(&pool->sp\_lock);- }-- /\* create new threads \*/- while (nrservs > 0) {+ do { nrservs--; chosen\_pool = choose\_pool(serv, pool, &state);  node = svc\_pool\_map\_get\_node(chosen\_pool->sp\_id); rqstp = svc\_prepare\_thread(serv, chosen\_pool, node);- if (IS\_ERR(rqstp)) {- error = PTR\_ERR(rqstp);- break;- }+ if (IS\_ERR(rqstp))+ return PTR\_ERR(rqstp);  \_\_module\_get(serv->sv\_ops->svo\_module); task = kthread\_create\_on\_node(serv->sv\_ops->svo\_function, rqstp, node, "%s", serv->sv\_name); if (IS\_ERR(task)) {- error = PTR\_ERR(task); module\_put(serv->sv\_ops->svo\_module); svc\_exit\_thread(rqstp);- break;+ return PTR\_ERR(task); }  rqstp->rq\_task = task;@@ -763,18 +736,103 @@ svc\_set\_num\_threads(struct svc\_serv \*serv, struct svc\_pool \*pool, int nrservs)  svc\_sock\_update\_bufs(serv); wake\_up\_process(task);- }+ } while (nrservs > 0);++ return 0;+}+++/\* destroy old threads \*/+static int+svc\_signal\_kthreads(struct svc\_serv \*serv, struct svc\_pool \*pool, int nrservs)+{+ struct task\_struct \*task;+ unsigned int state = serv->sv\_nrthreads-1;+ /\* destroy old threads \*/- while (nrservs < 0 &&- (task = choose\_victim(serv, pool, &state)) != NULL) {+ do {+ task = choose\_victim(serv, pool, &state);+ if (task == NULL)+ break; send\_sig(SIGINT, task, 1); nrservs++;+ } while (nrservs < 0);++ return 0;+}++/\*+ \* Create or destroy enough new threads to make the number+ \* of threads the given number. If `pool' is non-NULL, applies+ \* only to threads in that pool, otherwise round-robins between+ \* all pools. Caller must ensure that mutual exclusion between this and+ \* server startup or shutdown.+ \*+ \* Destroying threads relies on the service threads filling in+ \* rqstp->rq\_task, which only the nfs ones do. Assumes the serv+ \* has been created using svc\_create\_pooled().+ \*+ \* Based on code that used to be in nfsd\_svc() but tweaked+ \* to be pool-aware.+ \*/+int+svc\_set\_num\_threads(struct svc\_serv \*serv, struct svc\_pool \*pool, int nrservs)+{+ if (pool == NULL) {+ /\* The -1 assumes caller has done a svc\_get() \*/+ nrservs -= (serv->sv\_nrthreads-1);+ } else {+ spin\_lock\_bh(&pool->sp\_lock);+ nrservs -= pool->sp\_nrthreads;+ spin\_unlock\_bh(&pool->sp\_lock); } - return error;+ if (nrservs > 0)+ return svc\_start\_kthreads(serv, pool, nrservs);+ if (nrservs < 0)+ return svc\_signal\_kthreads(serv, pool, nrservs);+ return 0; } EXPORT\_SYMBOL\_GPL(svc\_set\_num\_threads); +/\* destroy old threads \*/+static int+svc\_stop\_kthreads(struct svc\_serv \*serv, struct svc\_pool \*pool, int nrservs)+{+ struct task\_struct \*task;+ unsigned int state = serv->sv\_nrthreads-1;++ /\* destroy old threads \*/+ do {+ task = choose\_victim(serv, pool, &state);+ if (task == NULL)+ break;+ kthread\_stop(task);+ nrservs++;+ } while (nrservs < 0);+ return 0;+}++int+svc\_set\_num\_threads\_sync(struct svc\_serv \*serv, struct svc\_pool \*pool, int nrservs)+{+ if (pool == NULL) {+ /\* The -1 assumes caller has done a svc\_get() \*/+ nrservs -= (serv->sv\_nrthreads-1);+ } else {+ spin\_lock\_bh(&pool->sp\_lock);+ nrservs -= pool->sp\_nrthreads;+ spin\_unlock\_bh(&pool->sp\_lock);+ }++ if (nrservs > 0)+ return svc\_start\_kthreads(serv, pool, nrservs);+ if (nrservs < 0)+ return svc\_stop\_kthreads(serv, pool, nrservs);+ return 0;+}+EXPORT\_SYMBOL\_GPL(svc\_set\_num\_threads\_sync);+ /\* \* Called from a server thread as it's exiting. Caller must hold the "service \* mutex" for the service.diff --git a/net/sunrpc/xprtrdma/Makefile b/net/sunrpc/xprtrdma/Makefileindex ef19fa42c50ff2..c1ae8142ab7347 100644--- a/[net/sunrpc/xprtrdma/Makefile](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xprtrdma/Makefile?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[net/sunrpc/xprtrdma/Makefile](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xprtrdma/Makefile?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -4,5 +4,5 @@ rpcrdma-y := transport.o rpc\_rdma.o verbs.o \ fmr\_ops.o frwr\_ops.o \ svc\_rdma.o svc\_rdma\_backchannel.o svc\_rdma\_transport.o \ svc\_rdma\_marshal.o svc\_rdma\_sendto.o svc\_rdma\_recvfrom.o \- module.o+ svc\_rdma\_rw.o module.o rpcrdma-$(CONFIG\_SUNRPC\_BACKCHANNEL) += backchannel.odiff --git a/net/sunrpc/xprtrdma/svc\_rdma.c b/net/sunrpc/xprtrdma/svc\_rdma.cindex c846ca9f1ebaa6..a4a8f6989ee747 100644--- a/[net/sunrpc/xprtrdma/svc\_rdma.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xprtrdma/svc_rdma.c?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[net/sunrpc/xprtrdma/svc\_rdma.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xprtrdma/svc_rdma.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -58,9 +58,9 @@ unsigned int svcrdma\_max\_requests = RPCRDMA\_MAX\_REQUESTS; unsigned int svcrdma\_max\_bc\_requests = RPCRDMA\_MAX\_BC\_REQUESTS; static unsigned int min\_max\_requests = 4; static unsigned int max\_max\_requests = 16384;-unsigned int svcrdma\_max\_req\_size = RPCRDMA\_MAX\_REQ\_SIZE;-static unsigned int min\_max\_inline = 4096;-static unsigned int max\_max\_inline = 65536;+unsigned int svcrdma\_max\_req\_size = RPCRDMA\_DEF\_INLINE\_THRESH;+static unsigned int min\_max\_inline = RPCRDMA\_DEF\_INLINE\_THRESH;+static unsigned int max\_max\_inline = RPCRDMA\_MAX\_INLINE\_THRESH;  atomic\_t rdma\_stat\_recv; atomic\_t rdma\_stat\_read;@@ -247,8 +247,6 @@ int svc\_rdma\_init(void) dprintk("SVCRDMA Module Init, register RPC RDMA transport\n"); dprintk("\tsvcrdma\_ord : %d\n", svcrdma\_ord); dprintk("\tmax\_requests : %u\n", svcrdma\_max\_requests);- dprintk("\tsq\_depth : %u\n",- svcrdma\_max\_requests \* RPCRDMA\_SQ\_DEPTH\_MULT); dprintk("\tmax\_bc\_requests : %u\n", svcrdma\_max\_bc\_requests); dprintk("\tmax\_inline : %d\n", svcrdma\_max\_req\_size); diff --git a/net/sunrpc/xprtrdma/svc\_rdma\_backchannel.c b/net/sunrpc/xprtrdma/svc\_rdma\_backchannel.cindex ff1df40f0d261b..c676ed0efb5af2 100644--- a/[net/sunrpc/xprtrdma/svc\_rdma\_backchannel.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xprtrdma/svc_rdma_backchannel.c?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[net/sunrpc/xprtrdma/svc\_rdma\_backchannel.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xprtrdma/svc_rdma_backchannel.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -12,7 +12,17 @@  #undef SVCRDMA\_BACKCHANNEL\_DEBUG -int svc\_rdma\_handle\_bc\_reply(struct rpc\_xprt \*xprt, struct rpcrdma\_msg \*rmsgp,+/\*\*+ \* svc\_rdma\_handle\_bc\_reply - Process incoming backchannel reply+ \* @xprt: controlling backchannel transport+ \* @rdma\_resp: pointer to incoming transport header+ \* @rcvbuf: XDR buffer into which to decode the reply+ \*+ \* Returns:+ \* %0 if @rcvbuf is filled in, xprt\_complete\_rqst called,+ \* %-EAGAIN if server should call ->recvfrom again.+ \*/+int svc\_rdma\_handle\_bc\_reply(struct rpc\_xprt \*xprt, \_\_be32 \*rdma\_resp, struct xdr\_buf \*rcvbuf) { struct rpcrdma\_xprt \*r\_xprt = rpcx\_to\_rdmax(xprt);@@ -27,13 +37,13 @@ int svc\_rdma\_handle\_bc\_reply(struct rpc\_xprt \*xprt, struct rpcrdma\_msg \*rmsgp,  p = (\_\_be32 \*)src->iov\_base; len = src->iov\_len;- xid = rmsgp->rm\_xid;+ xid = \*rdma\_resp;  #ifdef SVCRDMA\_BACKCHANNEL\_DEBUG pr\_info("%s: xid=%08x, length=%zu\n", \_\_func\_\_, be32\_to\_cpu(xid), len); pr\_info("%s: RPC/RDMA: %\*ph\n",- \_\_func\_\_, (int)RPCRDMA\_HDRLEN\_MIN, rmsgp);+ \_\_func\_\_, (int)RPCRDMA\_HDRLEN\_MIN, rdma\_resp); pr\_info("%s: RPC: %\*ph\n", \_\_func\_\_, (int)len, p); #endif@@ -53,7 +63,7 @@ int svc\_rdma\_handle\_bc\_reply(struct rpc\_xprt \*xprt, struct rpcrdma\_msg \*rmsgp, goto out\_unlock; memcpy(dst->iov\_base, p, len); - credits = be32\_to\_cpu(rmsgp->rm\_credit);+ credits = be32\_to\_cpup(rdma\_resp + 2); if (credits == 0) credits = 1; /\* don't deadlock \*/ else if (credits > r\_xprt->rx\_buf.rb\_bc\_max\_requests)@@ -90,9 +100,9 @@ out\_notfound: \* Caller holds the connection's mutex and has already marshaled \* the RPC/RDMA request. \*- \* This is similar to svc\_rdma\_reply, but takes an rpc\_rqst- \* instead, does not support chunks, and avoids blocking memory- \* allocation.+ \* This is similar to svc\_rdma\_send\_reply\_msg, but takes a struct+ \* rpc\_rqst instead, does not support chunks, and avoids blocking+ \* memory allocation. \* \* XXX: There is still an opportunity to block in svc\_rdma\_send() \* if there are no SQ entries to post the Send. This may occur if@@ -101,59 +111,36 @@ out\_notfound: static int svc\_rdma\_bc\_sendto(struct svcxprt\_rdma \*rdma, struct rpc\_rqst \*rqst) {- struct xdr\_buf \*sndbuf = &rqst->rq\_snd\_buf; struct svc\_rdma\_op\_ctxt \*ctxt;- struct svc\_rdma\_req\_map \*vec;- struct ib\_send\_wr send\_wr; int ret; - vec = svc\_rdma\_get\_req\_map(rdma);- ret = svc\_rdma\_map\_xdr(rdma, sndbuf, vec, false);- if (ret)+ ctxt = svc\_rdma\_get\_context(rdma);++ /\* rpcrdma\_bc\_send\_request builds the transport header and+ \* the backchannel RPC message in the same buffer. Thus only+ \* one SGE is needed to send both.+ \*/+ ret = svc\_rdma\_map\_reply\_hdr(rdma, ctxt, rqst->rq\_buffer,+ rqst->rq\_snd\_buf.len);+ if (ret < 0) goto out\_err;  ret = svc\_rdma\_repost\_recv(rdma, GFP\_NOIO); if (ret) goto out\_err; - ctxt = svc\_rdma\_get\_context(rdma);- ctxt->pages[0] = virt\_to\_page(rqst->rq\_buffer);- ctxt->count = 1;-- ctxt->direction = DMA\_TO\_DEVICE;- ctxt->sge[0].lkey = rdma->sc\_pd->local\_dma\_lkey;- ctxt->sge[0].length = sndbuf->len;- ctxt->sge[0].addr =- ib\_dma\_map\_page(rdma->sc\_cm\_id->device, ctxt->pages[0], 0,- sndbuf->len, DMA\_TO\_DEVICE);- if (ib\_dma\_mapping\_error(rdma->sc\_cm\_id->device, ctxt->sge[0].addr)) {- ret = -EIO;- goto out\_unmap;- }- svc\_rdma\_count\_mappings(rdma, ctxt);-- memset(&send\_wr, 0, sizeof(send\_wr));- ctxt->cqe.done = svc\_rdma\_wc\_send;- send\_wr.wr\_cqe = &ctxt->cqe;- send\_wr.sg\_list = ctxt->sge;- send\_wr.num\_sge = 1;- send\_wr.opcode = IB\_WR\_SEND;- send\_wr.send\_flags = IB\_SEND\_SIGNALED;-- ret = svc\_rdma\_send(rdma, &send\_wr);- if (ret) {- ret = -EIO;+ ret = svc\_rdma\_post\_send\_wr(rdma, ctxt, 1, 0);+ if (ret) goto out\_unmap;- }  out\_err:- svc\_rdma\_put\_req\_map(rdma, vec); dprintk("svcrdma: %s returns %d\n", \_\_func\_\_, ret); return ret;  out\_unmap: svc\_rdma\_unmap\_dma(ctxt); svc\_rdma\_put\_context(ctxt, 1);+ ret = -EIO; goto out\_err; } diff --git a/net/sunrpc/xprtrdma/svc\_rdma\_marshal.c b/net/sunrpc/xprtrdma/svc\_rdma\_marshal.cindex 1c4aabf0f65772..bdcf7d85a3dc09 100644--- a/[net/sunrpc/xprtrdma/svc\_rdma\_marshal.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xprtrdma/svc_rdma_marshal.c?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[net/sunrpc/xprtrdma/svc\_rdma\_marshal.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xprtrdma/svc_rdma_marshal.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -166,92 +166,3 @@ out\_inval: dprintk("svcrdma: failed to parse transport header\n"); return -EINVAL; }--int svc\_rdma\_xdr\_encode\_error(struct svcxprt\_rdma \*xprt,- struct rpcrdma\_msg \*rmsgp,- enum rpcrdma\_errcode err, \_\_be32 \*va)-{- \_\_be32 \*startp = va;-- \*va++ = rmsgp->rm\_xid;- \*va++ = rmsgp->rm\_vers;- \*va++ = xprt->sc\_fc\_credits;- \*va++ = rdma\_error;- \*va++ = cpu\_to\_be32(err);- if (err == ERR\_VERS) {- \*va++ = rpcrdma\_version;- \*va++ = rpcrdma\_version;- }-- return (int)((unsigned long)va - (unsigned long)startp);-}--/\*\*- \* svc\_rdma\_xdr\_get\_reply\_hdr\_length - Get length of Reply transport header- \* @rdma\_resp: buffer containing Reply transport header- \*- \* Returns length of transport header, in bytes.- \*/-unsigned int svc\_rdma\_xdr\_get\_reply\_hdr\_len(\_\_be32 \*rdma\_resp)-{- unsigned int nsegs;- \_\_be32 \*p;-- p = rdma\_resp;-- /\* RPC-over-RDMA V1 replies never have a Read list. \*/- p += rpcrdma\_fixed\_maxsz + 1;-- /\* Skip Write list. \*/- while (\*p++ != xdr\_zero) {- nsegs = be32\_to\_cpup(p++);- p += nsegs \* rpcrdma\_segment\_maxsz;- }-- /\* Skip Reply chunk. \*/- if (\*p++ != xdr\_zero) {- nsegs = be32\_to\_cpup(p++);- p += nsegs \* rpcrdma\_segment\_maxsz;- }-- return (unsigned long)p - (unsigned long)rdma\_resp;-}--void svc\_rdma\_xdr\_encode\_write\_list(struct rpcrdma\_msg \*rmsgp, int chunks)-{- struct rpcrdma\_write\_array \*ary;-- /\* no read-list \*/- rmsgp->rm\_body.rm\_chunks[0] = xdr\_zero;-- /\* write-array discrim \*/- ary = (struct rpcrdma\_write\_array \*)- &rmsgp->rm\_body.rm\_chunks[1];- ary->wc\_discrim = xdr\_one;- ary->wc\_nchunks = cpu\_to\_be32(chunks);-- /\* write-list terminator \*/- ary->wc\_array[chunks].wc\_target.rs\_handle = xdr\_zero;-- /\* reply-array discriminator \*/- ary->wc\_array[chunks].wc\_target.rs\_length = xdr\_zero;-}--void svc\_rdma\_xdr\_encode\_reply\_array(struct rpcrdma\_write\_array \*ary,- int chunks)-{- ary->wc\_discrim = xdr\_one;- ary->wc\_nchunks = cpu\_to\_be32(chunks);-}--void svc\_rdma\_xdr\_encode\_array\_chunk(struct rpcrdma\_write\_array \*ary,- int chunk\_no,- \_\_be32 rs\_handle,- \_\_be64 rs\_offset,- u32 write\_len)-{- struct rpcrdma\_segment \*seg = &ary->wc\_array[chunk\_no].wc\_target;- seg->rs\_handle = rs\_handle;- seg->rs\_offset = rs\_offset;- seg->rs\_length = cpu\_to\_be32(write\_len);-}diff --git a/net/sunrpc/xprtrdma/svc\_rdma\_recvfrom.c b/net/sunrpc/xprtrdma/svc\_rdma\_recvfrom.cindex f7b2daf72a8658..27a99bf5b1a6f6 100644--- a/[net/sunrpc/xprtrdma/svc\_rdma\_recvfrom.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[net/sunrpc/xprtrdma/svc\_rdma\_recvfrom.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -558,33 +558,85 @@ static void rdma\_read\_complete(struct svc\_rqst \*rqstp, rqstp->rq\_arg.buflen = head->arg.buflen; } +static void svc\_rdma\_send\_error(struct svcxprt\_rdma \*xprt,+ \_\_be32 \*rdma\_argp, int status)+{+ struct svc\_rdma\_op\_ctxt \*ctxt;+ \_\_be32 \*p, \*err\_msgp;+ unsigned int length;+ struct page \*page;+ int ret;++ ret = svc\_rdma\_repost\_recv(xprt, GFP\_KERNEL);+ if (ret)+ return;++ page = alloc\_page(GFP\_KERNEL);+ if (!page)+ return;+ err\_msgp = page\_address(page);++ p = err\_msgp;+ \*p++ = \*rdma\_argp;+ \*p++ = \*(rdma\_argp + 1);+ \*p++ = xprt->sc\_fc\_credits;+ \*p++ = rdma\_error;+ if (status == -EPROTONOSUPPORT) {+ \*p++ = err\_vers;+ \*p++ = rpcrdma\_version;+ \*p++ = rpcrdma\_version;+ } else {+ \*p++ = err\_chunk;+ }+ length = (unsigned long)p - (unsigned long)err\_msgp;++ /\* Map transport header; no RPC message payload \*/+ ctxt = svc\_rdma\_get\_context(xprt);+ ret = svc\_rdma\_map\_reply\_hdr(xprt, ctxt, err\_msgp, length);+ if (ret) {+ dprintk("svcrdma: Error %d mapping send for protocol error\n",+ ret);+ return;+ }++ ret = svc\_rdma\_post\_send\_wr(xprt, ctxt, 1, 0);+ if (ret) {+ dprintk("svcrdma: Error %d posting send for protocol error\n",+ ret);+ svc\_rdma\_unmap\_dma(ctxt);+ svc\_rdma\_put\_context(ctxt, 1);+ }+}+ /\* By convention, backchannel calls arrive via rdma\_msg type \* messages, and never populate the chunk lists. This makes \* the RPC/RDMA header small and fixed in size, so it is \* straightforward to check the RPC header's direction field. \*/-static bool-svc\_rdma\_is\_backchannel\_reply(struct svc\_xprt \*xprt, struct rpcrdma\_msg \*rmsgp)+static bool svc\_rdma\_is\_backchannel\_reply(struct svc\_xprt \*xprt,+ \_\_be32 \*rdma\_resp) {- \_\_be32 \*p = (\_\_be32 \*)rmsgp;+ \_\_be32 \*p;  if (!xprt->xpt\_bc\_xprt) return false; - if (rmsgp->rm\_type != rdma\_msg)+ p = rdma\_resp + 3;+ if (\*p++ != rdma\_msg) return false;- if (rmsgp->rm\_body.rm\_chunks[0] != xdr\_zero)++ if (\*p++ != xdr\_zero) return false;- if (rmsgp->rm\_body.rm\_chunks[1] != xdr\_zero)+ if (\*p++ != xdr\_zero) return false;- if (rmsgp->rm\_body.rm\_chunks[2] != xdr\_zero)+ if (\*p++ != xdr\_zero) return false; - /\* sanity \*/- if (p[7] != rmsgp->rm\_xid)+ /\* XID sanity \*/+ if (\*p++ != \*rdma\_resp) return false; /\* call direction \*/- if (p[8] == cpu\_to\_be32(RPC\_CALL))+ if (\*p == cpu\_to\_be32(RPC\_CALL)) return false;  return true;@@ -650,8 +702,9 @@ int svc\_rdma\_recvfrom(struct svc\_rqst \*rqstp) goto out\_drop; rqstp->rq\_xprt\_hlen = ret; - if (svc\_rdma\_is\_backchannel\_reply(xprt, rmsgp)) {- ret = svc\_rdma\_handle\_bc\_reply(xprt->xpt\_bc\_xprt, rmsgp,+ if (svc\_rdma\_is\_backchannel\_reply(xprt, &rmsgp->rm\_xid)) {+ ret = svc\_rdma\_handle\_bc\_reply(xprt->xpt\_bc\_xprt,+ &rmsgp->rm\_xid, &rqstp->rq\_arg); svc\_rdma\_put\_context(ctxt, 0); if (ret)@@ -686,7 +739,7 @@ complete: return ret;  out\_err:- svc\_rdma\_send\_error(rdma\_xprt, rmsgp, ret);+ svc\_rdma\_send\_error(rdma\_xprt, &rmsgp->rm\_xid, ret); svc\_rdma\_put\_context(ctxt, 0); return 0; diff --git a/net/sunrpc/xprtrdma/svc\_rdma\_rw.c b/net/sunrpc/xprtrdma/svc\_rdma\_rw.cnew file mode 100644index 00000000000000..0cf6202776933b--- /dev/null+++ b/[net/sunrpc/xprtrdma/svc\_rdma\_rw.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xprtrdma/svc_rdma_rw.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -0,0 +1,512 @@+/\*+ \* Copyright (c) 2016 Oracle. All rights reserved.+ \*+ \* Use the core R/W API to move RPC-over-RDMA Read and Write chunks.+ \*/++#include <linux/sunrpc/rpc\_rdma.h>+#include <linux/sunrpc/svc\_rdma.h>+#include <linux/sunrpc/debug.h>++#include <rdma/rw.h>++#define RPCDBG\_FACILITY RPCDBG\_SVCXPRT++/\* Each R/W context contains state for one chain of RDMA Read or+ \* Write Work Requests.+ \*+ \* Each WR chain handles a single contiguous server-side buffer,+ \* because scatterlist entries after the first have to start on+ \* page alignment. xdr\_buf iovecs cannot guarantee alignment.+ \*+ \* Each WR chain handles only one R\_key. Each RPC-over-RDMA segment+ \* from a client may contain a unique R\_key, so each WR chain moves+ \* up to one segment at a time.+ \*+ \* The scatterlist makes this data structure over 4KB in size. To+ \* make it less likely to fail, and to handle the allocation for+ \* smaller I/O requests without disabling bottom-halves, these+ \* contexts are created on demand, but cached and reused until the+ \* controlling svcxprt\_rdma is destroyed.+ \*/+struct svc\_rdma\_rw\_ctxt {+ struct list\_head rw\_list;+ struct rdma\_rw\_ctx rw\_ctx;+ int rw\_nents;+ struct sg\_table rw\_sg\_table;+ struct scatterlist rw\_first\_sgl[0];+};++static inline struct svc\_rdma\_rw\_ctxt \*+svc\_rdma\_next\_ctxt(struct list\_head \*list)+{+ return list\_first\_entry\_or\_null(list, struct svc\_rdma\_rw\_ctxt,+ rw\_list);+}++static struct svc\_rdma\_rw\_ctxt \*+svc\_rdma\_get\_rw\_ctxt(struct svcxprt\_rdma \*rdma, unsigned int sges)+{+ struct svc\_rdma\_rw\_ctxt \*ctxt;++ spin\_lock(&rdma->sc\_rw\_ctxt\_lock);++ ctxt = svc\_rdma\_next\_ctxt(&rdma->sc\_rw\_ctxts);+ if (ctxt) {+ list\_del(&ctxt->rw\_list);+ spin\_unlock(&rdma->sc\_rw\_ctxt\_lock);+ } else {+ spin\_unlock(&rdma->sc\_rw\_ctxt\_lock);+ ctxt = kmalloc(sizeof(\*ctxt) ++ SG\_CHUNK\_SIZE \* sizeof(struct scatterlist),+ GFP\_KERNEL);+ if (!ctxt)+ goto out;+ INIT\_LIST\_HEAD(&ctxt->rw\_list);+ }++ ctxt->rw\_sg\_table.sgl = ctxt->rw\_first\_sgl;+ if (sg\_alloc\_table\_chained(&ctxt->rw\_sg\_table, sges,+ ctxt->rw\_sg\_table.sgl)) {+ kfree(ctxt);+ ctxt = NULL;+ }+out:+ return ctxt;+}++static void svc\_rdma\_put\_rw\_ctxt(struct svcxprt\_rdma \*rdma,+ struct svc\_rdma\_rw\_ctxt \*ctxt)+{+ sg\_free\_table\_chained(&ctxt->rw\_sg\_table, true);++ spin\_lock(&rdma->sc\_rw\_ctxt\_lock);+ list\_add(&ctxt->rw\_list, &rdma->sc\_rw\_ctxts);+ spin\_unlock(&rdma->sc\_rw\_ctxt\_lock);+}++/\*\*+ \* svc\_rdma\_destroy\_rw\_ctxts - Free accumulated R/W contexts+ \* @rdma: transport about to be destroyed+ \*+ \*/+void svc\_rdma\_destroy\_rw\_ctxts(struct svcxprt\_rdma \*rdma)+{+ struct svc\_rdma\_rw\_ctxt \*ctxt;++ while ((ctxt = svc\_rdma\_next\_ctxt(&rdma->sc\_rw\_ctxts)) != NULL) {+ list\_del(&ctxt->rw\_list);+ kfree(ctxt);+ }+}++/\* A chunk context tracks all I/O for moving one Read or Write+ \* chunk. This is a a set of rdma\_rw's that handle data movement+ \* for all segments of one chunk.+ \*+ \* These are small, acquired with a single allocator call, and+ \* no more than one is needed per chunk. They are allocated on+ \* demand, and not cached.+ \*/+struct svc\_rdma\_chunk\_ctxt {+ struct ib\_cqe cc\_cqe;+ struct svcxprt\_rdma \*cc\_rdma;+ struct list\_head cc\_rwctxts;+ int cc\_sqecount;+ enum dma\_data\_direction cc\_dir;+};++static void svc\_rdma\_cc\_init(struct svcxprt\_rdma \*rdma,+ struct svc\_rdma\_chunk\_ctxt \*cc,+ enum dma\_data\_direction dir)+{+ cc->cc\_rdma = rdma;+ svc\_xprt\_get(&rdma->sc\_xprt);++ INIT\_LIST\_HEAD(&cc->cc\_rwctxts);+ cc->cc\_sqecount = 0;+ cc->cc\_dir = dir;+}++static void svc\_rdma\_cc\_release(struct svc\_rdma\_chunk\_ctxt \*cc)+{+ struct svcxprt\_rdma \*rdma = cc->cc\_rdma;+ struct svc\_rdma\_rw\_ctxt \*ctxt;++ while ((ctxt = svc\_rdma\_next\_ctxt(&cc->cc\_rwctxts)) != NULL) {+ list\_del(&ctxt->rw\_list);++ rdma\_rw\_ctx\_destroy(&ctxt->rw\_ctx, rdma->sc\_qp,+ rdma->sc\_port\_num, ctxt->rw\_sg\_table.sgl,+ ctxt->rw\_nents, cc->cc\_dir);+ svc\_rdma\_put\_rw\_ctxt(rdma, ctxt);+ }+ svc\_xprt\_put(&rdma->sc\_xprt);+}++/\* State for sending a Write or Reply chunk.+ \* - Tracks progress of writing one chunk over all its segments+ \* - Stores arguments for the SGL constructor functions+ \*/+struct svc\_rdma\_write\_info {+ /\* write state of this chunk \*/+ unsigned int wi\_seg\_off;+ unsigned int wi\_seg\_no;+ unsigned int wi\_nsegs;+ \_\_be32 \*wi\_segs;++ /\* SGL constructor arguments \*/+ struct xdr\_buf \*wi\_xdr;+ unsigned char \*wi\_base;+ unsigned int wi\_next\_off;++ struct svc\_rdma\_chunk\_ctxt wi\_cc;+};++static struct svc\_rdma\_write\_info \*+svc\_rdma\_write\_info\_alloc(struct svcxprt\_rdma \*rdma, \_\_be32 \*chunk)+{+ struct svc\_rdma\_write\_info \*info;++ info = kmalloc(sizeof(\*info), GFP\_KERNEL);+ if (!info)+ return info;++ info->wi\_seg\_off = 0;+ info->wi\_seg\_no = 0;+ info->wi\_nsegs = be32\_to\_cpup(++chunk);+ info->wi\_segs = ++chunk;+ svc\_rdma\_cc\_init(rdma, &info->wi\_cc, DMA\_TO\_DEVICE);+ return info;+}++static void svc\_rdma\_write\_info\_free(struct svc\_rdma\_write\_info \*info)+{+ svc\_rdma\_cc\_release(&info->wi\_cc);+ kfree(info);+}++/\*\*+ \* svc\_rdma\_write\_done - Write chunk completion+ \* @cq: controlling Completion Queue+ \* @wc: Work Completion+ \*+ \* Pages under I/O are freed by a subsequent Send completion.+ \*/+static void svc\_rdma\_write\_done(struct ib\_cq \*cq, struct ib\_wc \*wc)+{+ struct ib\_cqe \*cqe = wc->wr\_cqe;+ struct svc\_rdma\_chunk\_ctxt \*cc =+ container\_of(cqe, struct svc\_rdma\_chunk\_ctxt, cc\_cqe);+ struct svcxprt\_rdma \*rdma = cc->cc\_rdma;+ struct svc\_rdma\_write\_info \*info =+ container\_of(cc, struct svc\_rdma\_write\_info, wi\_cc);++ atomic\_add(cc->cc\_sqecount, &rdma->sc\_sq\_avail);+ wake\_up(&rdma->sc\_send\_wait);++ if (unlikely(wc->status != IB\_WC\_SUCCESS)) {+ set\_bit(XPT\_CLOSE, &rdma->sc\_xprt.xpt\_flags);+ if (wc->status != IB\_WC\_WR\_FLUSH\_ERR)+ pr\_err("svcrdma: write ctx: %s (%u/0x%x)\n",+ ib\_wc\_status\_msg(wc->status),+ wc->status, wc->vendor\_err);+ }++ svc\_rdma\_write\_info\_free(info);+}++/\* This function sleeps when the transport's Send Queue is congested.+ \*+ \* Assumptions:+ \* - If ib\_post\_send() succeeds, only one completion is expected,+ \* even if one or more WRs are flushed. This is true when posting+ \* an rdma\_rw\_ctx or when posting a single signaled WR.+ \*/+static int svc\_rdma\_post\_chunk\_ctxt(struct svc\_rdma\_chunk\_ctxt \*cc)+{+ struct svcxprt\_rdma \*rdma = cc->cc\_rdma;+ struct svc\_xprt \*xprt = &rdma->sc\_xprt;+ struct ib\_send\_wr \*first\_wr, \*bad\_wr;+ struct list\_head \*tmp;+ struct ib\_cqe \*cqe;+ int ret;++ first\_wr = NULL;+ cqe = &cc->cc\_cqe;+ list\_for\_each(tmp, &cc->cc\_rwctxts) {+ struct svc\_rdma\_rw\_ctxt \*ctxt;++ ctxt = list\_entry(tmp, struct svc\_rdma\_rw\_ctxt, rw\_list);+ first\_wr = rdma\_rw\_ctx\_wrs(&ctxt->rw\_ctx, rdma->sc\_qp,+ rdma->sc\_port\_num, cqe, first\_wr);+ cqe = NULL;+ }++ do {+ if (atomic\_sub\_return(cc->cc\_sqecount,+ &rdma->sc\_sq\_avail) > 0) {+ ret = ib\_post\_send(rdma->sc\_qp, first\_wr, &bad\_wr);+ if (ret)+ break;+ return 0;+ }++ atomic\_inc(&rdma\_stat\_sq\_starve);+ atomic\_add(cc->cc\_sqecount, &rdma->sc\_sq\_avail);+ wait\_event(rdma->sc\_send\_wait,+ atomic\_read(&rdma->sc\_sq\_avail) > cc->cc\_sqecount);+ } while (1);++ pr\_err("svcrdma: ib\_post\_send failed (%d)\n", ret);+ set\_bit(XPT\_CLOSE, &xprt->xpt\_flags);++ /\* If even one was posted, there will be a completion. \*/+ if (bad\_wr != first\_wr)+ return 0;++ atomic\_add(cc->cc\_sqecount, &rdma->sc\_sq\_avail);+ wake\_up(&rdma->sc\_send\_wait);+ return -ENOTCONN;+}++/\* Build and DMA-map an SGL that covers one kvec in an xdr\_buf+ \*/+static void svc\_rdma\_vec\_to\_sg(struct svc\_rdma\_write\_info \*info,+ unsigned int len,+ struct svc\_rdma\_rw\_ctxt \*ctxt)+{+ struct scatterlist \*sg = ctxt->rw\_sg\_table.sgl;++ sg\_set\_buf(&sg[0], info->wi\_base, len);+ info->wi\_base += len;++ ctxt->rw\_nents = 1;+}++/\* Build and DMA-map an SGL that covers part of an xdr\_buf's pagelist.+ \*/+static void svc\_rdma\_pagelist\_to\_sg(struct svc\_rdma\_write\_info \*info,+ unsigned int remaining,+ struct svc\_rdma\_rw\_ctxt \*ctxt)+{+ unsigned int sge\_no, sge\_bytes, page\_off, page\_no;+ struct xdr\_buf \*xdr = info->wi\_xdr;+ struct scatterlist \*sg;+ struct page \*\*page;++ page\_off = (info->wi\_next\_off + xdr->page\_base) & ~PAGE\_MASK;+ page\_no = (info->wi\_next\_off + xdr->page\_base) >> PAGE\_SHIFT;+ page = xdr->pages + page\_no;+ info->wi\_next\_off += remaining;+ sg = ctxt->rw\_sg\_table.sgl;+ sge\_no = 0;+ do {+ sge\_bytes = min\_t(unsigned int, remaining,+ PAGE\_SIZE - page\_off);+ sg\_set\_page(sg, \*page, sge\_bytes, page\_off);++ remaining -= sge\_bytes;+ sg = sg\_next(sg);+ page\_off = 0;+ sge\_no++;+ page++;+ } while (remaining);++ ctxt->rw\_nents = sge\_no;+}++/\* Construct RDMA Write WRs to send a portion of an xdr\_buf containing+ \* an RPC Reply.+ \*/+static int+svc\_rdma\_build\_writes(struct svc\_rdma\_write\_info \*info,+ void (\*constructor)(struct svc\_rdma\_write\_info \*info,+ unsigned int len,+ struct svc\_rdma\_rw\_ctxt \*ctxt),+ unsigned int remaining)+{+ struct svc\_rdma\_chunk\_ctxt \*cc = &info->wi\_cc;+ struct svcxprt\_rdma \*rdma = cc->cc\_rdma;+ struct svc\_rdma\_rw\_ctxt \*ctxt;+ \_\_be32 \*seg;+ int ret;++ cc->cc\_cqe.done = svc\_rdma\_write\_done;+ seg = info->wi\_segs + info->wi\_seg\_no \* rpcrdma\_segment\_maxsz;+ do {+ unsigned int write\_len;+ u32 seg\_length, seg\_handle;+ u64 seg\_offset;++ if (info->wi\_seg\_no >= info->wi\_nsegs)+ goto out\_overflow;++ seg\_handle = be32\_to\_cpup(seg);+ seg\_length = be32\_to\_cpup(seg + 1);+ xdr\_decode\_hyper(seg + 2, &seg\_offset);+ seg\_offset += info->wi\_seg\_off;++ write\_len = min(remaining, seg\_length - info->wi\_seg\_off);+ ctxt = svc\_rdma\_get\_rw\_ctxt(rdma,+ (write\_len >> PAGE\_SHIFT) + 2);+ if (!ctxt)+ goto out\_noctx;++ constructor(info, write\_len, ctxt);+ ret = rdma\_rw\_ctx\_init(&ctxt->rw\_ctx, rdma->sc\_qp,+ rdma->sc\_port\_num, ctxt->rw\_sg\_table.sgl,+ ctxt->rw\_nents, 0, seg\_offset,+ seg\_handle, DMA\_TO\_DEVICE);+ if (ret < 0)+ goto out\_initerr;++ list\_add(&ctxt->rw\_list, &cc->cc\_rwctxts);+ cc->cc\_sqecount += ret;+ if (write\_len == seg\_length - info->wi\_seg\_off) {+ seg += 4;+ info->wi\_seg\_no++;+ info->wi\_seg\_off = 0;+ } else {+ info->wi\_seg\_off += write\_len;+ }+ remaining -= write\_len;+ } while (remaining);++ return 0;++out\_overflow:+ dprintk("svcrdma: inadequate space in Write chunk (%u)\n",+ info->wi\_nsegs);+ return -E2BIG;++out\_noctx:+ dprintk("svcrdma: no R/W ctxs available\n");+ return -ENOMEM;++out\_initerr:+ svc\_rdma\_put\_rw\_ctxt(rdma, ctxt);+ pr\_err("svcrdma: failed to map pagelist (%d)\n", ret);+ return -EIO;+}++/\* Send one of an xdr\_buf's kvecs by itself. To send a Reply+ \* chunk, the whole RPC Reply is written back to the client.+ \* This function writes either the head or tail of the xdr\_buf+ \* containing the Reply.+ \*/+static int svc\_rdma\_send\_xdr\_kvec(struct svc\_rdma\_write\_info \*info,+ struct kvec \*vec)+{+ info->wi\_base = vec->iov\_base;+ return svc\_rdma\_build\_writes(info, svc\_rdma\_vec\_to\_sg,+ vec->iov\_len);+}++/\* Send an xdr\_buf's page list by itself. A Write chunk is+ \* just the page list. a Reply chunk is the head, page list,+ \* and tail. This function is shared between the two types+ \* of chunk.+ \*/+static int svc\_rdma\_send\_xdr\_pagelist(struct svc\_rdma\_write\_info \*info,+ struct xdr\_buf \*xdr)+{+ info->wi\_xdr = xdr;+ info->wi\_next\_off = 0;+ return svc\_rdma\_build\_writes(info, svc\_rdma\_pagelist\_to\_sg,+ xdr->page\_len);+}++/\*\*+ \* svc\_rdma\_send\_write\_chunk - Write all segments in a Write chunk+ \* @rdma: controlling RDMA transport+ \* @wr\_ch: Write chunk provided by client+ \* @xdr: xdr\_buf containing the data payload+ \*+ \* Returns a non-negative number of bytes the chunk consumed, or+ \* %-E2BIG if the payload was larger than the Write chunk,+ \* %-ENOMEM if rdma\_rw context pool was exhausted,+ \* %-ENOTCONN if posting failed (connection is lost),+ \* %-EIO if rdma\_rw initialization failed (DMA mapping, etc).+ \*/+int svc\_rdma\_send\_write\_chunk(struct svcxprt\_rdma \*rdma, \_\_be32 \*wr\_ch,+ struct xdr\_buf \*xdr)+{+ struct svc\_rdma\_write\_info \*info;+ int ret;++ if (!xdr->page\_len)+ return 0;++ info = svc\_rdma\_write\_info\_alloc(rdma, wr\_ch);+ if (!info)+ return -ENOMEM;++ ret = svc\_rdma\_send\_xdr\_pagelist(info, xdr);+ if (ret < 0)+ goto out\_err;++ ret = svc\_rdma\_post\_chunk\_ctxt(&info->wi\_cc);+ if (ret < 0)+ goto out\_err;+ return xdr->page\_len;++out\_err:+ svc\_rdma\_write\_info\_free(info);+ return ret;+}++/\*\*+ \* svc\_rdma\_send\_reply\_chunk - Write all segments in the Reply chunk+ \* @rdma: controlling RDMA transport+ \* @rp\_ch: Reply chunk provided by client+ \* @writelist: true if client provided a Write list+ \* @xdr: xdr\_buf containing an RPC Reply+ \*+ \* Returns a non-negative number of bytes the chunk consumed, or+ \* %-E2BIG if the payload was larger than the Reply chunk,+ \* %-ENOMEM if rdma\_rw context pool was exhausted,+ \* %-ENOTCONN if posting failed (connection is lost),+ \* %-EIO if rdma\_rw initialization failed (DMA mapping, etc).+ \*/+int svc\_rdma\_send\_reply\_chunk(struct svcxprt\_rdma \*rdma, \_\_be32 \*rp\_ch,+ bool writelist, struct xdr\_buf \*xdr)+{+ struct svc\_rdma\_write\_info \*info;+ int consumed, ret;++ info = svc\_rdma\_write\_info\_alloc(rdma, rp\_ch);+ if (!info)+ return -ENOMEM;++ ret = svc\_rdma\_send\_xdr\_kvec(info, &xdr->head[0]);+ if (ret < 0)+ goto out\_err;+ consumed = xdr->head[0].iov\_len;++ /\* Send the page list in the Reply chunk only if the+ \* client did not provide Write chunks.+ \*/+ if (!writelist && xdr->page\_len) {+ ret = svc\_rdma\_send\_xdr\_pagelist(info, xdr);+ if (ret < 0)+ goto out\_err;+ consumed += xdr->page\_len;+ }++ if (xdr->tail[0].iov\_len) {+ ret = svc\_rdma\_send\_xdr\_kvec(info, &xdr->tail[0]);+ if (ret < 0)+ goto out\_err;+ consumed += xdr->tail[0].iov\_len;+ }++ ret = svc\_rdma\_post\_chunk\_ctxt(&info->wi\_cc);+ if (ret < 0)+ goto out\_err;+ return consumed;++out\_err:+ svc\_rdma\_write\_info\_free(info);+ return ret;+}diff --git a/net/sunrpc/xprtrdma/svc\_rdma\_sendto.c b/net/sunrpc/xprtrdma/svc\_rdma\_sendto.cindex 515221b16d0956..1736337f3a557a 100644--- a/[net/sunrpc/xprtrdma/svc\_rdma\_sendto.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xprtrdma/svc_rdma_sendto.c?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[net/sunrpc/xprtrdma/svc\_rdma\_sendto.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xprtrdma/svc_rdma_sendto.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -1,4 +1,5 @@ /\*+ \* Copyright (c) 2016 Oracle. All rights reserved. \* Copyright (c) 2014 Open Grid Computing, Inc. All rights reserved. \* Copyright (c) 2005-2006 Network Appliance, Inc. All rights reserved. \*@@ -40,6 +41,63 @@ \* Author: Tom Tucker <tom@opengridcomputing.com> \*/ +/\* Operation+ \*+ \* The main entry point is svc\_rdma\_sendto. This is called by the+ \* RPC server when an RPC Reply is ready to be transmitted to a client.+ \*+ \* The passed-in svc\_rqst contains a struct xdr\_buf which holds an+ \* XDR-encoded RPC Reply message. sendto must construct the RPC-over-RDMA+ \* transport header, post all Write WRs needed for this Reply, then post+ \* a Send WR conveying the transport header and the RPC message itself to+ \* the client.+ \*+ \* svc\_rdma\_sendto must fully transmit the Reply before returning, as+ \* the svc\_rqst will be recycled as soon as sendto returns. Remaining+ \* resources referred to by the svc\_rqst are also recycled at that time.+ \* Therefore any resources that must remain longer must be detached+ \* from the svc\_rqst and released later.+ \*+ \* Page Management+ \*+ \* The I/O that performs Reply transmission is asynchronous, and may+ \* complete well after sendto returns. Thus pages under I/O must be+ \* removed from the svc\_rqst before sendto returns.+ \*+ \* The logic here depends on Send Queue and completion ordering. Since+ \* the Send WR is always posted last, it will always complete last. Thus+ \* when it completes, it is guaranteed that all previous Write WRs have+ \* also completed.+ \*+ \* Write WRs are constructed and posted. Each Write segment gets its own+ \* svc\_rdma\_rw\_ctxt, allowing the Write completion handler to find and+ \* DMA-unmap the pages under I/O for that Write segment. The Write+ \* completion handler does not release any pages.+ \*+ \* When the Send WR is constructed, it also gets its own svc\_rdma\_op\_ctxt.+ \* The ownership of all of the Reply's pages are transferred into that+ \* ctxt, the Send WR is posted, and sendto returns.+ \*+ \* The svc\_rdma\_op\_ctxt is presented when the Send WR completes. The+ \* Send completion handler finally releases the Reply's pages.+ \*+ \* This mechanism also assumes that completions on the transport's Send+ \* Completion Queue do not run in parallel. Otherwise a Write completion+ \* and Send completion running at the same time could release pages that+ \* are still DMA-mapped.+ \*+ \* Error Handling+ \*+ \* - If the Send WR is posted successfully, it will either complete+ \* successfully, or get flushed. Either way, the Send completion+ \* handler releases the Reply's pages.+ \* - If the Send WR cannot be not posted, the forward path releases+ \* the Reply's pages.+ \*+ \* This handles the case, without the use of page reference counting,+ \* where two different Write segments send portions of the same page.+ \*/+ #include <linux/sunrpc/debug.h> #include <linux/sunrpc/rpc\_rdma.h> #include <linux/spinlock.h>@@ -55,113 +113,141 @@ static u32 xdr\_padsize(u32 len) return (len & 3) ? (4 - (len & 3)) : 0; } -int svc\_rdma\_map\_xdr(struct svcxprt\_rdma \*xprt,- struct xdr\_buf \*xdr,- struct svc\_rdma\_req\_map \*vec,- bool write\_chunk\_present)+/\* Returns length of transport header, in bytes.+ \*/+static unsigned int svc\_rdma\_reply\_hdr\_len(\_\_be32 \*rdma\_resp) {- int sge\_no;- u32 sge\_bytes;- u32 page\_bytes;- u32 page\_off;- int page\_no;-- if (xdr->len !=- (xdr->head[0].iov\_len + xdr->page\_len + xdr->tail[0].iov\_len)) {- pr\_err("svcrdma: %s: XDR buffer length error\n", \_\_func\_\_);- return -EIO;- }+ unsigned int nsegs;+ \_\_be32 \*p; - /\* Skip the first sge, this is for the RPCRDMA header \*/- sge\_no = 1;+ p = rdma\_resp;++ /\* RPC-over-RDMA V1 replies never have a Read list. \*/+ p += rpcrdma\_fixed\_maxsz + 1; - /\* Head SGE \*/- vec->sge[sge\_no].iov\_base = xdr->head[0].iov\_base;- vec->sge[sge\_no].iov\_len = xdr->head[0].iov\_len;- sge\_no++;-- /\* pages SGE \*/- page\_no = 0;- page\_bytes = xdr->page\_len;- page\_off = xdr->page\_base;- while (page\_bytes) {- vec->sge[sge\_no].iov\_base =- page\_address(xdr->pages[page\_no]) + page\_off;- sge\_bytes = min\_t(u32, page\_bytes, (PAGE\_SIZE - page\_off));- page\_bytes -= sge\_bytes;- vec->sge[sge\_no].iov\_len = sge\_bytes;-- sge\_no++;- page\_no++;- page\_off = 0; /\* reset for next time through loop \*/+ /\* Skip Write list. \*/+ while (\*p++ != xdr\_zero) {+ nsegs = be32\_to\_cpup(p++);+ p += nsegs \* rpcrdma\_segment\_maxsz; } - /\* Tail SGE \*/- if (xdr->tail[0].iov\_len) {- unsigned char \*base = xdr->tail[0].iov\_base;- size\_t len = xdr->tail[0].iov\_len;- u32 xdr\_pad = xdr\_padsize(xdr->page\_len);+ /\* Skip Reply chunk. \*/+ if (\*p++ != xdr\_zero) {+ nsegs = be32\_to\_cpup(p++);+ p += nsegs \* rpcrdma\_segment\_maxsz;+ } - if (write\_chunk\_present && xdr\_pad) {- base += xdr\_pad;- len -= xdr\_pad;- }+ return (unsigned long)p - (unsigned long)rdma\_resp;+} - if (len) {- vec->sge[sge\_no].iov\_base = base;- vec->sge[sge\_no].iov\_len = len;- sge\_no++;+/\* One Write chunk is copied from Call transport header to Reply+ \* transport header. Each segment's length field is updated to+ \* reflect number of bytes consumed in the segment.+ \*+ \* Returns number of segments in this chunk.+ \*/+static unsigned int xdr\_encode\_write\_chunk(\_\_be32 \*dst, \_\_be32 \*src,+ unsigned int remaining)+{+ unsigned int i, nsegs;+ u32 seg\_len;++ /\* Write list discriminator \*/+ \*dst++ = \*src++;++ /\* number of segments in this chunk \*/+ nsegs = be32\_to\_cpup(src);+ \*dst++ = \*src++;++ for (i = nsegs; i; i--) {+ /\* segment's RDMA handle \*/+ \*dst++ = \*src++;++ /\* bytes returned in this segment \*/+ seg\_len = be32\_to\_cpu(\*src);+ if (remaining >= seg\_len) {+ /\* entire segment was consumed \*/+ \*dst = \*src;+ remaining -= seg\_len;+ } else {+ /\* segment only partly filled \*/+ \*dst = cpu\_to\_be32(remaining);+ remaining = 0; }- }+ dst++; src++; - dprintk("svcrdma: %s: sge\_no %d page\_no %d "- "page\_base %u page\_len %u head\_len %zu tail\_len %zu\n",- \_\_func\_\_, sge\_no, page\_no, xdr->page\_base, xdr->page\_len,- xdr->head[0].iov\_len, xdr->tail[0].iov\_len);+ /\* segment's RDMA offset \*/+ \*dst++ = \*src++;+ \*dst++ = \*src++;+ } - vec->count = sge\_no;- return 0;+ return nsegs; } -static dma\_addr\_t dma\_map\_xdr(struct svcxprt\_rdma \*xprt,- struct xdr\_buf \*xdr,- u32 xdr\_off, size\_t len, int dir)+/\* The client provided a Write list in the Call message. Fill in+ \* the segments in the first Write chunk in the Reply's transport+ \* header with the number of bytes consumed in each segment.+ \* Remaining chunks are returned unused.+ \*+ \* Assumptions:+ \* - Client has provided only one Write chunk+ \*/+static void svc\_rdma\_xdr\_encode\_write\_list(\_\_be32 \*rdma\_resp, \_\_be32 \*wr\_ch,+ unsigned int consumed) {- struct page \*page;- dma\_addr\_t dma\_addr;- if (xdr\_off < xdr->head[0].iov\_len) {- /\* This offset is in the head \*/- xdr\_off += (unsigned long)xdr->head[0].iov\_base & ~PAGE\_MASK;- page = virt\_to\_page(xdr->head[0].iov\_base);- } else {- xdr\_off -= xdr->head[0].iov\_len;- if (xdr\_off < xdr->page\_len) {- /\* This offset is in the page list \*/- xdr\_off += xdr->page\_base;- page = xdr->pages[xdr\_off >> PAGE\_SHIFT];- xdr\_off &= ~PAGE\_MASK;- } else {- /\* This offset is in the tail \*/- xdr\_off -= xdr->page\_len;- xdr\_off += (unsigned long)- xdr->tail[0].iov\_base & ~PAGE\_MASK;- page = virt\_to\_page(xdr->tail[0].iov\_base);- }+ unsigned int nsegs;+ \_\_be32 \*p, \*q;++ /\* RPC-over-RDMA V1 replies never have a Read list. \*/+ p = rdma\_resp + rpcrdma\_fixed\_maxsz + 1;++ q = wr\_ch;+ while (\*q != xdr\_zero) {+ nsegs = xdr\_encode\_write\_chunk(p, q, consumed);+ q += 2 + nsegs \* rpcrdma\_segment\_maxsz;+ p += 2 + nsegs \* rpcrdma\_segment\_maxsz;+ consumed = 0; }- dma\_addr = ib\_dma\_map\_page(xprt->sc\_cm\_id->device, page, xdr\_off,- min\_t(size\_t, PAGE\_SIZE, len), dir);- return dma\_addr;++ /\* Terminate Write list \*/+ \*p++ = xdr\_zero;++ /\* Reply chunk discriminator; may be replaced later \*/+ \*p = xdr\_zero;+}++/\* The client provided a Reply chunk in the Call message. Fill in+ \* the segments in the Reply chunk in the Reply message with the+ \* number of bytes consumed in each segment.+ \*+ \* Assumptions:+ \* - Reply can always fit in the provided Reply chunk+ \*/+static void svc\_rdma\_xdr\_encode\_reply\_chunk(\_\_be32 \*rdma\_resp, \_\_be32 \*rp\_ch,+ unsigned int consumed)+{+ \_\_be32 \*p;++ /\* Find the Reply chunk in the Reply's xprt header.+ \* RPC-over-RDMA V1 replies never have a Read list.+ \*/+ p = rdma\_resp + rpcrdma\_fixed\_maxsz + 1;++ /\* Skip past Write list \*/+ while (\*p++ != xdr\_zero)+ p += 1 + be32\_to\_cpup(p) \* rpcrdma\_segment\_maxsz;++ xdr\_encode\_write\_chunk(p, rp\_ch, consumed); }  /\* Parse the RPC Call's transport header. \*/-static void svc\_rdma\_get\_write\_arrays(struct rpcrdma\_msg \*rmsgp,- struct rpcrdma\_write\_array \*\*write,- struct rpcrdma\_write\_array \*\*reply)+static void svc\_rdma\_get\_write\_arrays(\_\_be32 \*rdma\_argp,+ \_\_be32 \*\*write, \_\_be32 \*\*reply) { \_\_be32 \*p; - p = (\_\_be32 \*)&rmsgp->rm\_body.rm\_chunks[0];+ p = rdma\_argp + rpcrdma\_fixed\_maxsz;  /\* Read list \*/ while (\*p++ != xdr\_zero)@@ -169,7 +255,7 @@ static void svc\_rdma\_get\_write\_arrays(struct rpcrdma\_msg \*rmsgp,  /\* Write list \*/ if (\*p != xdr\_zero) {- \*write = (struct rpcrdma\_write\_array \*)p;+ \*write = p; while (\*p++ != xdr\_zero) p += 1 + be32\_to\_cpu(\*p) \* 4; } else {@@ -179,7 +265,7 @@ static void svc\_rdma\_get\_write\_arrays(struct rpcrdma\_msg \*rmsgp,  /\* Reply chunk \*/ if (\*p != xdr\_zero)- \*reply = (struct rpcrdma\_write\_array \*)p;+ \*reply = p; else \*reply = NULL; }@@ -189,360 +275,321 @@ static void svc\_rdma\_get\_write\_arrays(struct rpcrdma\_msg \*rmsgp, \* Invalidate, and responder chooses one rkey to invalidate. \* \* Find a candidate rkey to invalidate when sending a reply. Picks the- \* first rkey it finds in the chunks lists.+ \* first R\_key it finds in the chunk lists. \* \* Returns zero if RPC's chunk lists are empty. \*/-static u32 svc\_rdma\_get\_inv\_rkey(struct rpcrdma\_msg \*rdma\_argp,- struct rpcrdma\_write\_array \*wr\_ary,- struct rpcrdma\_write\_array \*rp\_ary)+static u32 svc\_rdma\_get\_inv\_rkey(\_\_be32 \*rdma\_argp,+ \_\_be32 \*wr\_lst, \_\_be32 \*rp\_ch) {- struct rpcrdma\_read\_chunk \*rd\_ary;- struct rpcrdma\_segment \*arg\_ch;+ \_\_be32 \*p; - rd\_ary = (struct rpcrdma\_read\_chunk \*)&rdma\_argp->rm\_body.rm\_chunks[0];- if (rd\_ary->rc\_discrim != xdr\_zero)- return be32\_to\_cpu(rd\_ary->rc\_target.rs\_handle);+ p = rdma\_argp + rpcrdma\_fixed\_maxsz;+ if (\*p != xdr\_zero)+ p += 2;+ else if (wr\_lst && be32\_to\_cpup(wr\_lst + 1))+ p = wr\_lst + 2;+ else if (rp\_ch && be32\_to\_cpup(rp\_ch + 1))+ p = rp\_ch + 2;+ else+ return 0;+ return be32\_to\_cpup(p);+} - if (wr\_ary && be32\_to\_cpu(wr\_ary->wc\_nchunks)) {- arg\_ch = &wr\_ary->wc\_array[0].wc\_target;- return be32\_to\_cpu(arg\_ch->rs\_handle);- }+/\* ib\_dma\_map\_page() is used here because svc\_rdma\_dma\_unmap()+ \* is used during completion to DMA-unmap this memory, and+ \* it uses ib\_dma\_unmap\_page() exclusively.+ \*/+static int svc\_rdma\_dma\_map\_buf(struct svcxprt\_rdma \*rdma,+ struct svc\_rdma\_op\_ctxt \*ctxt,+ unsigned int sge\_no,+ unsigned char \*base,+ unsigned int len)+{+ unsigned long offset = (unsigned long)base & ~PAGE\_MASK;+ struct ib\_device \*dev = rdma->sc\_cm\_id->device;+ dma\_addr\_t dma\_addr; - if (rp\_ary && be32\_to\_cpu(rp\_ary->wc\_nchunks)) {- arg\_ch = &rp\_ary->wc\_array[0].wc\_target;- return be32\_to\_cpu(arg\_ch->rs\_handle);- }+ dma\_addr = ib\_dma\_map\_page(dev, virt\_to\_page(base),+ offset, len, DMA\_TO\_DEVICE);+ if (ib\_dma\_mapping\_error(dev, dma\_addr))+ return -EIO; + ctxt->sge[sge\_no].addr = dma\_addr;+ ctxt->sge[sge\_no].length = len;+ ctxt->sge[sge\_no].lkey = rdma->sc\_pd->local\_dma\_lkey;+ svc\_rdma\_count\_mappings(rdma, ctxt); return 0; } -/\* Assumptions:- \* - The specified write\_len can be represented in sc\_max\_sge \* PAGE\_SIZE- \*/-static int send\_write(struct svcxprt\_rdma \*xprt, struct svc\_rqst \*rqstp,- u32 rmr, u64 to,- u32 xdr\_off, int write\_len,- struct svc\_rdma\_req\_map \*vec)+static int svc\_rdma\_dma\_map\_page(struct svcxprt\_rdma \*rdma,+ struct svc\_rdma\_op\_ctxt \*ctxt,+ unsigned int sge\_no,+ struct page \*page,+ unsigned int offset,+ unsigned int len) {- struct ib\_rdma\_wr write\_wr;- struct ib\_sge \*sge;- int xdr\_sge\_no;- int sge\_no;- int sge\_bytes;- int sge\_off;- int bc;- struct svc\_rdma\_op\_ctxt \*ctxt;+ struct ib\_device \*dev = rdma->sc\_cm\_id->device;+ dma\_addr\_t dma\_addr; - if (vec->count > RPCSVC\_MAXPAGES) {- pr\_err("svcrdma: Too many pages (%lu)\n", vec->count);+ dma\_addr = ib\_dma\_map\_page(dev, page, offset, len, DMA\_TO\_DEVICE);+ if (ib\_dma\_mapping\_error(dev, dma\_addr)) return -EIO;- } - dprintk("svcrdma: RDMA\_WRITE rmr=%x, to=%llx, xdr\_off=%d, "- "write\_len=%d, vec->sge=%p, vec->count=%lu\n",- rmr, (unsigned long long)to, xdr\_off,- write\_len, vec->sge, vec->count);+ ctxt->sge[sge\_no].addr = dma\_addr;+ ctxt->sge[sge\_no].length = len;+ ctxt->sge[sge\_no].lkey = rdma->sc\_pd->local\_dma\_lkey;+ svc\_rdma\_count\_mappings(rdma, ctxt);+ return 0;+} - ctxt = svc\_rdma\_get\_context(xprt);+/\*\*+ \* svc\_rdma\_map\_reply\_hdr - DMA map the transport header buffer+ \* @rdma: controlling transport+ \* @ctxt: op\_ctxt for the Send WR+ \* @rdma\_resp: buffer containing transport header+ \* @len: length of transport header+ \*+ \* Returns:+ \* %0 if the header is DMA mapped,+ \* %-EIO if DMA mapping failed.+ \*/+int svc\_rdma\_map\_reply\_hdr(struct svcxprt\_rdma \*rdma,+ struct svc\_rdma\_op\_ctxt \*ctxt,+ \_\_be32 \*rdma\_resp,+ unsigned int len)+{ ctxt->direction = DMA\_TO\_DEVICE;- sge = ctxt->sge;-- /\* Find the SGE associated with xdr\_off \*/- for (bc = xdr\_off, xdr\_sge\_no = 1; bc && xdr\_sge\_no < vec->count;- xdr\_sge\_no++) {- if (vec->sge[xdr\_sge\_no].iov\_len > bc)- break;- bc -= vec->sge[xdr\_sge\_no].iov\_len;- }-- sge\_off = bc;- bc = write\_len;- sge\_no = 0;-- /\* Copy the remaining SGE \*/- while (bc != 0) {- sge\_bytes = min\_t(size\_t,- bc, vec->sge[xdr\_sge\_no].iov\_len-sge\_off);- sge[sge\_no].length = sge\_bytes;- sge[sge\_no].addr =- dma\_map\_xdr(xprt, &rqstp->rq\_res, xdr\_off,- sge\_bytes, DMA\_TO\_DEVICE);- xdr\_off += sge\_bytes;- if (ib\_dma\_mapping\_error(xprt->sc\_cm\_id->device,- sge[sge\_no].addr))- goto err;- svc\_rdma\_count\_mappings(xprt, ctxt);- sge[sge\_no].lkey = xprt->sc\_pd->local\_dma\_lkey;- ctxt->count++;- sge\_off = 0;- sge\_no++;- xdr\_sge\_no++;- if (xdr\_sge\_no > vec->count) {- pr\_err("svcrdma: Too many sges (%d)\n", xdr\_sge\_no);- goto err;- }- bc -= sge\_bytes;- if (sge\_no == xprt->sc\_max\_sge)- break;- }-- /\* Prepare WRITE WR \*/- memset(&write\_wr, 0, sizeof write\_wr);- ctxt->cqe.done = svc\_rdma\_wc\_write;- write\_wr.wr.wr\_cqe = &ctxt->cqe;- write\_wr.wr.sg\_list = &sge[0];- write\_wr.wr.num\_sge = sge\_no;- write\_wr.wr.opcode = IB\_WR\_RDMA\_WRITE;- write\_wr.wr.send\_flags = IB\_SEND\_SIGNALED;- write\_wr.rkey = rmr;- write\_wr.remote\_addr = to;-- /\* Post It \*/- atomic\_inc(&rdma\_stat\_write);- if (svc\_rdma\_send(xprt, &write\_wr.wr))- goto err;- return write\_len - bc;- err:- svc\_rdma\_unmap\_dma(ctxt);- svc\_rdma\_put\_context(ctxt, 0);- return -EIO;+ ctxt->pages[0] = virt\_to\_page(rdma\_resp);+ ctxt->count = 1;+ return svc\_rdma\_dma\_map\_page(rdma, ctxt, 0, ctxt->pages[0], 0, len); } -noinline-static int send\_write\_chunks(struct svcxprt\_rdma \*xprt,- struct rpcrdma\_write\_array \*wr\_ary,- struct rpcrdma\_msg \*rdma\_resp,- struct svc\_rqst \*rqstp,- struct svc\_rdma\_req\_map \*vec)+/\* Load the xdr\_buf into the ctxt's sge array, and DMA map each+ \* element as it is added.+ \*+ \* Returns the number of sge elements loaded on success, or+ \* a negative errno on failure.+ \*/+static int svc\_rdma\_map\_reply\_msg(struct svcxprt\_rdma \*rdma,+ struct svc\_rdma\_op\_ctxt \*ctxt,+ struct xdr\_buf \*xdr, \_\_be32 \*wr\_lst) {- u32 xfer\_len = rqstp->rq\_res.page\_len;- int write\_len;- u32 xdr\_off;- int chunk\_off;- int chunk\_no;- int nchunks;- struct rpcrdma\_write\_array \*res\_ary;+ unsigned int len, sge\_no, remaining, page\_off;+ struct page \*\*ppages;+ unsigned char \*base;+ u32 xdr\_pad; int ret; - res\_ary = (struct rpcrdma\_write\_array \*)- &rdma\_resp->rm\_body.rm\_chunks[1];-- /\* Write chunks start at the pagelist \*/- nchunks = be32\_to\_cpu(wr\_ary->wc\_nchunks);- for (xdr\_off = rqstp->rq\_res.head[0].iov\_len, chunk\_no = 0;- xfer\_len && chunk\_no < nchunks;- chunk\_no++) {- struct rpcrdma\_segment \*arg\_ch;- u64 rs\_offset;-- arg\_ch = &wr\_ary->wc\_array[chunk\_no].wc\_target;- write\_len = min(xfer\_len, be32\_to\_cpu(arg\_ch->rs\_length));-- /\* Prepare the response chunk given the length actually- \* written \*/- xdr\_decode\_hyper((\_\_be32 \*)&arg\_ch->rs\_offset, &rs\_offset);- svc\_rdma\_xdr\_encode\_array\_chunk(res\_ary, chunk\_no,- arg\_ch->rs\_handle,- arg\_ch->rs\_offset,- write\_len);- chunk\_off = 0;- while (write\_len) {- ret = send\_write(xprt, rqstp,- be32\_to\_cpu(arg\_ch->rs\_handle),- rs\_offset + chunk\_off,- xdr\_off,- write\_len,- vec);- if (ret <= 0)- goto out\_err;- chunk\_off += ret;- xdr\_off += ret;- xfer\_len -= ret;- write\_len -= ret;+ sge\_no = 1;++ ret = svc\_rdma\_dma\_map\_buf(rdma, ctxt, sge\_no++,+ xdr->head[0].iov\_base,+ xdr->head[0].iov\_len);+ if (ret < 0)+ return ret;++ /\* If a Write chunk is present, the xdr\_buf's page list+ \* is not included inline. However the Upper Layer may+ \* have added XDR padding in the tail buffer, and that+ \* should not be included inline.+ \*/+ if (wr\_lst) {+ base = xdr->tail[0].iov\_base;+ len = xdr->tail[0].iov\_len;+ xdr\_pad = xdr\_padsize(xdr->page\_len);++ if (len && xdr\_pad) {+ base += xdr\_pad;+ len -= xdr\_pad; }++ goto tail;+ }++ ppages = xdr->pages + (xdr->page\_base >> PAGE\_SHIFT);+ page\_off = xdr->page\_base & ~PAGE\_MASK;+ remaining = xdr->page\_len;+ while (remaining) {+ len = min\_t(u32, PAGE\_SIZE - page\_off, remaining);++ ret = svc\_rdma\_dma\_map\_page(rdma, ctxt, sge\_no++,+ \*ppages++, page\_off, len);+ if (ret < 0)+ return ret;++ remaining -= len;+ page\_off = 0; }- /\* Update the req with the number of chunks actually used \*/- svc\_rdma\_xdr\_encode\_write\_list(rdma\_resp, chunk\_no); - return rqstp->rq\_res.page\_len;+ base = xdr->tail[0].iov\_base;+ len = xdr->tail[0].iov\_len;+tail:+ if (len) {+ ret = svc\_rdma\_dma\_map\_buf(rdma, ctxt, sge\_no++, base, len);+ if (ret < 0)+ return ret;+ } -out\_err:- pr\_err("svcrdma: failed to send write chunks, rc=%d\n", ret);- return -EIO;+ return sge\_no - 1; } -noinline-static int send\_reply\_chunks(struct svcxprt\_rdma \*xprt,- struct rpcrdma\_write\_array \*rp\_ary,- struct rpcrdma\_msg \*rdma\_resp,- struct svc\_rqst \*rqstp,- struct svc\_rdma\_req\_map \*vec)+/\* The svc\_rqst and all resources it owns are released as soon as+ \* svc\_rdma\_sendto returns. Transfer pages under I/O to the ctxt+ \* so they are released by the Send completion handler.+ \*/+static void svc\_rdma\_save\_io\_pages(struct svc\_rqst \*rqstp,+ struct svc\_rdma\_op\_ctxt \*ctxt) {- u32 xfer\_len = rqstp->rq\_res.len;- int write\_len;- u32 xdr\_off;- int chunk\_no;- int chunk\_off;- int nchunks;- struct rpcrdma\_segment \*ch;- struct rpcrdma\_write\_array \*res\_ary;- int ret;+ int i, pages = rqstp->rq\_next\_page - rqstp->rq\_respages; - /\* XXX: need to fix when reply lists occur with read-list and or- \* write-list \*/- res\_ary = (struct rpcrdma\_write\_array \*)- &rdma\_resp->rm\_body.rm\_chunks[2];-- /\* xdr offset starts at RPC message \*/- nchunks = be32\_to\_cpu(rp\_ary->wc\_nchunks);- for (xdr\_off = 0, chunk\_no = 0;- xfer\_len && chunk\_no < nchunks;- chunk\_no++) {- u64 rs\_offset;- ch = &rp\_ary->wc\_array[chunk\_no].wc\_target;- write\_len = min(xfer\_len, be32\_to\_cpu(ch->rs\_length));-- /\* Prepare the reply chunk given the length actually- \* written \*/- xdr\_decode\_hyper((\_\_be32 \*)&ch->rs\_offset, &rs\_offset);- svc\_rdma\_xdr\_encode\_array\_chunk(res\_ary, chunk\_no,- ch->rs\_handle, ch->rs\_offset,- write\_len);- chunk\_off = 0;- while (write\_len) {- ret = send\_write(xprt, rqstp,- be32\_to\_cpu(ch->rs\_handle),- rs\_offset + chunk\_off,- xdr\_off,- write\_len,- vec);- if (ret <= 0)- goto out\_err;- chunk\_off += ret;- xdr\_off += ret;- xfer\_len -= ret;- write\_len -= ret;- }+ ctxt->count += pages;+ for (i = 0; i < pages; i++) {+ ctxt->pages[i + 1] = rqstp->rq\_respages[i];+ rqstp->rq\_respages[i] = NULL; }- /\* Update the req with the number of chunks actually used \*/- svc\_rdma\_xdr\_encode\_reply\_array(res\_ary, chunk\_no);+ rqstp->rq\_next\_page = rqstp->rq\_respages + 1;+} - return rqstp->rq\_res.len;+/\*\*+ \* svc\_rdma\_post\_send\_wr - Set up and post one Send Work Request+ \* @rdma: controlling transport+ \* @ctxt: op\_ctxt for transmitting the Send WR+ \* @num\_sge: number of SGEs to send+ \* @inv\_rkey: R\_key argument to Send With Invalidate, or zero+ \*+ \* Returns:+ \* %0 if the Send\* was posted successfully,+ \* %-ENOTCONN if the connection was lost or dropped,+ \* %-EINVAL if there was a problem with the Send we built,+ \* %-ENOMEM if ib\_post\_send failed.+ \*/+int svc\_rdma\_post\_send\_wr(struct svcxprt\_rdma \*rdma,+ struct svc\_rdma\_op\_ctxt \*ctxt, int num\_sge,+ u32 inv\_rkey)+{+ struct ib\_send\_wr \*send\_wr = &ctxt->send\_wr; -out\_err:- pr\_err("svcrdma: failed to send reply chunks, rc=%d\n", ret);- return -EIO;+ dprintk("svcrdma: posting Send WR with %u sge(s)\n", num\_sge);++ send\_wr->next = NULL;+ ctxt->cqe.done = svc\_rdma\_wc\_send;+ send\_wr->wr\_cqe = &ctxt->cqe;+ send\_wr->sg\_list = ctxt->sge;+ send\_wr->num\_sge = num\_sge;+ send\_wr->send\_flags = IB\_SEND\_SIGNALED;+ if (inv\_rkey) {+ send\_wr->opcode = IB\_WR\_SEND\_WITH\_INV;+ send\_wr->ex.invalidate\_rkey = inv\_rkey;+ } else {+ send\_wr->opcode = IB\_WR\_SEND;+ }++ return svc\_rdma\_send(rdma, send\_wr); } -/\* This function prepares the portion of the RPCRDMA message to be- \* sent in the RDMA\_SEND. This function is called after data sent via- \* RDMA has already been transmitted. There are three cases:- \* - The RPCRDMA header, RPC header, and payload are all sent in a- \* single RDMA\_SEND. This is the "inline" case.- \* - The RPCRDMA header and some portion of the RPC header and data- \* are sent via this RDMA\_SEND and another portion of the data is- \* sent via RDMA.- \* - The RPCRDMA header [NOMSG] is sent in this RDMA\_SEND and the RPC- \* header and data are all transmitted via RDMA.- \* In all three cases, this function prepares the RPCRDMA header in- \* sge[0], the 'type' parameter indicates the type to place in the- \* RPCRDMA header, and the 'byte\_count' field indicates how much of- \* the XDR to include in this RDMA\_SEND. NB: The offset of the payload- \* to send is zero in the XDR.+/\* Prepare the portion of the RPC Reply that will be transmitted+ \* via RDMA Send. The RPC-over-RDMA transport header is prepared+ \* in sge[0], and the RPC xdr\_buf is prepared in following sges.+ \*+ \* Depending on whether a Write list or Reply chunk is present,+ \* the server may send all, a portion of, or none of the xdr\_buf.+ \* In the latter case, only the transport header (sge[0]) is+ \* transmitted.+ \*+ \* RDMA Send is the last step of transmitting an RPC reply. Pages+ \* involved in the earlier RDMA Writes are here transferred out+ \* of the rqstp and into the ctxt's page array. These pages are+ \* DMA unmapped by each Write completion, but the subsequent Send+ \* completion finally releases these pages.+ \*+ \* Assumptions:+ \* - The Reply's transport header will never be larger than a page. \*/-static int send\_reply(struct svcxprt\_rdma \*rdma,- struct svc\_rqst \*rqstp,- struct page \*page,- struct rpcrdma\_msg \*rdma\_resp,- struct svc\_rdma\_req\_map \*vec,- int byte\_count,- u32 inv\_rkey)+static int svc\_rdma\_send\_reply\_msg(struct svcxprt\_rdma \*rdma,+ \_\_be32 \*rdma\_argp, \_\_be32 \*rdma\_resp,+ struct svc\_rqst \*rqstp,+ \_\_be32 \*wr\_lst, \_\_be32 \*rp\_ch) { struct svc\_rdma\_op\_ctxt \*ctxt;- struct ib\_send\_wr send\_wr;- u32 xdr\_off;- int sge\_no;- int sge\_bytes;- int page\_no;- int pages;- int ret = -EIO;-- /\* Prepare the context \*/+ u32 inv\_rkey;+ int ret;++ dprintk("svcrdma: sending %s reply: head=%zu, pagelen=%u, tail=%zu\n",+ (rp\_ch ? "RDMA\_NOMSG" : "RDMA\_MSG"),+ rqstp->rq\_res.head[0].iov\_len,+ rqstp->rq\_res.page\_len,+ rqstp->rq\_res.tail[0].iov\_len);+ ctxt = svc\_rdma\_get\_context(rdma);- ctxt->direction = DMA\_TO\_DEVICE;- ctxt->pages[0] = page;- ctxt->count = 1; - /\* Prepare the SGE for the RPCRDMA Header \*/- ctxt->sge[0].lkey = rdma->sc\_pd->local\_dma\_lkey;- ctxt->sge[0].length =- svc\_rdma\_xdr\_get\_reply\_hdr\_len((\_\_be32 \*)rdma\_resp);- ctxt->sge[0].addr =- ib\_dma\_map\_page(rdma->sc\_cm\_id->device, page, 0,- ctxt->sge[0].length, DMA\_TO\_DEVICE);- if (ib\_dma\_mapping\_error(rdma->sc\_cm\_id->device, ctxt->sge[0].addr))+ ret = svc\_rdma\_map\_reply\_hdr(rdma, ctxt, rdma\_resp,+ svc\_rdma\_reply\_hdr\_len(rdma\_resp));+ if (ret < 0) goto err;- svc\_rdma\_count\_mappings(rdma, ctxt);-- ctxt->direction = DMA\_TO\_DEVICE; - /\* Map the payload indicated by 'byte\_count' \*/- xdr\_off = 0;- for (sge\_no = 1; byte\_count && sge\_no < vec->count; sge\_no++) {- sge\_bytes = min\_t(size\_t, vec->sge[sge\_no].iov\_len, byte\_count);- byte\_count -= sge\_bytes;- ctxt->sge[sge\_no].addr =- dma\_map\_xdr(rdma, &rqstp->rq\_res, xdr\_off,- sge\_bytes, DMA\_TO\_DEVICE);- xdr\_off += sge\_bytes;- if (ib\_dma\_mapping\_error(rdma->sc\_cm\_id->device,- ctxt->sge[sge\_no].addr))+ if (!rp\_ch) {+ ret = svc\_rdma\_map\_reply\_msg(rdma, ctxt,+ &rqstp->rq\_res, wr\_lst);+ if (ret < 0) goto err;- svc\_rdma\_count\_mappings(rdma, ctxt);- ctxt->sge[sge\_no].lkey = rdma->sc\_pd->local\_dma\_lkey;- ctxt->sge[sge\_no].length = sge\_bytes; }- if (byte\_count != 0) {- pr\_err("svcrdma: Could not map %d bytes\n", byte\_count);++ svc\_rdma\_save\_io\_pages(rqstp, ctxt);++ inv\_rkey = 0;+ if (rdma->sc\_snd\_w\_inv)+ inv\_rkey = svc\_rdma\_get\_inv\_rkey(rdma\_argp, wr\_lst, rp\_ch);+ ret = svc\_rdma\_post\_send\_wr(rdma, ctxt, 1 + ret, inv\_rkey);+ if (ret) goto err;- } - /\* Save all respages in the ctxt and remove them from the- \* respages array. They are our pages until the I/O- \* completes.+ return 0;++err:+ pr\_err("svcrdma: failed to post Send WR (%d)\n", ret);+ svc\_rdma\_unmap\_dma(ctxt);+ svc\_rdma\_put\_context(ctxt, 1);+ return ret;+}++/\* Given the client-provided Write and Reply chunks, the server was not+ \* able to form a complete reply. Return an RDMA\_ERROR message so the+ \* client can retire this RPC transaction. As above, the Send completion+ \* routine releases payload pages that were part of a previous RDMA Write.+ \*+ \* Remote Invalidation is skipped for simplicity.+ \*/+static int svc\_rdma\_send\_error\_msg(struct svcxprt\_rdma \*rdma,+ \_\_be32 \*rdma\_resp, struct svc\_rqst \*rqstp)+{+ struct svc\_rdma\_op\_ctxt \*ctxt;+ \_\_be32 \*p;+ int ret;++ ctxt = svc\_rdma\_get\_context(rdma);++ /\* Replace the original transport header with an+ \* RDMA\_ERROR response. XID etc are preserved. \*/- pages = rqstp->rq\_next\_page - rqstp->rq\_respages;- for (page\_no = 0; page\_no < pages; page\_no++) {- ctxt->pages[page\_no+1] = rqstp->rq\_respages[page\_no];- ctxt->count++;- rqstp->rq\_respages[page\_no] = NULL;- }- rqstp->rq\_next\_page = rqstp->rq\_respages + 1;+ p = rdma\_resp + 3;+ \*p++ = rdma\_error;+ \*p = err\_chunk; - if (sge\_no > rdma->sc\_max\_sge) {- pr\_err("svcrdma: Too many sges (%d)\n", sge\_no);+ ret = svc\_rdma\_map\_reply\_hdr(rdma, ctxt, rdma\_resp, 20);+ if (ret < 0) goto err;- }- memset(&send\_wr, 0, sizeof send\_wr);- ctxt->cqe.done = svc\_rdma\_wc\_send;- send\_wr.wr\_cqe = &ctxt->cqe;- send\_wr.sg\_list = ctxt->sge;- send\_wr.num\_sge = sge\_no;- if (inv\_rkey) {- send\_wr.opcode = IB\_WR\_SEND\_WITH\_INV;- send\_wr.ex.invalidate\_rkey = inv\_rkey;- } else- send\_wr.opcode = IB\_WR\_SEND;- send\_wr.send\_flags = IB\_SEND\_SIGNALED; - ret = svc\_rdma\_send(rdma, &send\_wr);+ svc\_rdma\_save\_io\_pages(rqstp, ctxt);++ ret = svc\_rdma\_post\_send\_wr(rdma, ctxt, 1 + ret, 0); if (ret) goto err;  return 0; - err:+err:+ pr\_err("svcrdma: failed to post Send WR (%d)\n", ret); svc\_rdma\_unmap\_dma(ctxt); svc\_rdma\_put\_context(ctxt, 1); return ret;@@ -552,39 +599,36 @@ void svc\_rdma\_prep\_reply\_hdr(struct svc\_rqst \*rqstp) { } +/\*\*+ \* svc\_rdma\_sendto - Transmit an RPC reply+ \* @rqstp: processed RPC request, reply XDR already in ::rq\_res+ \*+ \* Any resources still associated with @rqstp are released upon return.+ \* If no reply message was possible, the connection is closed.+ \*+ \* Returns:+ \* %0 if an RPC reply has been successfully posted,+ \* %-ENOMEM if a resource shortage occurred (connection is lost),+ \* %-ENOTCONN if posting failed (connection is lost).+ \*/ int svc\_rdma\_sendto(struct svc\_rqst \*rqstp) { struct svc\_xprt \*xprt = rqstp->rq\_xprt; struct svcxprt\_rdma \*rdma = container\_of(xprt, struct svcxprt\_rdma, sc\_xprt);- struct rpcrdma\_msg \*rdma\_argp;- struct rpcrdma\_msg \*rdma\_resp;- struct rpcrdma\_write\_array \*wr\_ary, \*rp\_ary;- int ret;- int inline\_bytes;+ \_\_be32 \*p, \*rdma\_argp, \*rdma\_resp, \*wr\_lst, \*rp\_ch;+ struct xdr\_buf \*xdr = &rqstp->rq\_res; struct page \*res\_page;- struct svc\_rdma\_req\_map \*vec;- u32 inv\_rkey;- \_\_be32 \*p;-- dprintk("svcrdma: sending response for rqstp=%p\n", rqstp);+ int ret; - /\* Get the RDMA request header. The receive logic always- \* places this at the start of page 0.+ /\* Find the call's chunk lists to decide how to send the reply.+ \* Receive places the Call's xprt header at the start of page 0. \*/ rdma\_argp = page\_address(rqstp->rq\_pages[0]);- svc\_rdma\_get\_write\_arrays(rdma\_argp, &wr\_ary, &rp\_ary);-- inv\_rkey = 0;- if (rdma->sc\_snd\_w\_inv)- inv\_rkey = svc\_rdma\_get\_inv\_rkey(rdma\_argp, wr\_ary, rp\_ary);+ svc\_rdma\_get\_write\_arrays(rdma\_argp, &wr\_lst, &rp\_ch); - /\* Build an req vec for the XDR \*/- vec = svc\_rdma\_get\_req\_map(rdma);- ret = svc\_rdma\_map\_xdr(rdma, &rqstp->rq\_res, vec, wr\_ary != NULL);- if (ret)- goto err0;- inline\_bytes = rqstp->rq\_res.len;+ dprintk("svcrdma: preparing response for XID 0x%08x\n",+ be32\_to\_cpup(rdma\_argp));  /\* Create the RDMA response header. xprt->xpt\_mutex, \* acquired in svc\_send(), serializes RPC replies. The@@ -598,115 +642,57 @@ int svc\_rdma\_sendto(struct svc\_rqst \*rqstp) goto err0; rdma\_resp = page\_address(res\_page); - p = &rdma\_resp->rm\_xid;- \*p++ = rdma\_argp->rm\_xid;- \*p++ = rdma\_argp->rm\_vers;+ p = rdma\_resp;+ \*p++ = \*rdma\_argp;+ \*p++ = \*(rdma\_argp + 1); \*p++ = rdma->sc\_fc\_credits;- \*p++ = rp\_ary ? rdma\_nomsg : rdma\_msg;+ \*p++ = rp\_ch ? rdma\_nomsg : rdma\_msg;  /\* Start with empty chunks \*/ \*p++ = xdr\_zero; \*p++ = xdr\_zero; \*p = xdr\_zero; - /\* Send any write-chunk data and build resp write-list \*/- if (wr\_ary) {- ret = send\_write\_chunks(rdma, wr\_ary, rdma\_resp, rqstp, vec);+ if (wr\_lst) {+ /\* XXX: Presume the client sent only one Write chunk \*/+ ret = svc\_rdma\_send\_write\_chunk(rdma, wr\_lst, xdr); if (ret < 0)- goto err1;- inline\_bytes -= ret + xdr\_padsize(ret);+ goto err2;+ svc\_rdma\_xdr\_encode\_write\_list(rdma\_resp, wr\_lst, ret); }-- /\* Send any reply-list data and update resp reply-list \*/- if (rp\_ary) {- ret = send\_reply\_chunks(rdma, rp\_ary, rdma\_resp, rqstp, vec);+ if (rp\_ch) {+ ret = svc\_rdma\_send\_reply\_chunk(rdma, rp\_ch, wr\_lst, xdr); if (ret < 0)- goto err1;- inline\_bytes -= ret;+ goto err2;+ svc\_rdma\_xdr\_encode\_reply\_chunk(rdma\_resp, rp\_ch, ret); } - /\* Post a fresh Receive buffer \_before\_ sending the reply \*/ ret = svc\_rdma\_post\_recv(rdma, GFP\_KERNEL); if (ret) goto err1;-- ret = send\_reply(rdma, rqstp, res\_page, rdma\_resp, vec,- inline\_bytes, inv\_rkey);+ ret = svc\_rdma\_send\_reply\_msg(rdma, rdma\_argp, rdma\_resp, rqstp,+ wr\_lst, rp\_ch); if (ret < 0) goto err0;+ return 0; - svc\_rdma\_put\_req\_map(rdma, vec);- dprintk("svcrdma: send\_reply returns %d\n", ret);- return ret;+ err2:+ if (ret != -E2BIG)+ goto err1;++ ret = svc\_rdma\_post\_recv(rdma, GFP\_KERNEL);+ if (ret)+ goto err1;+ ret = svc\_rdma\_send\_error\_msg(rdma, rdma\_resp, rqstp);+ if (ret < 0)+ goto err0;+ return 0;  err1: put\_page(res\_page); err0:- svc\_rdma\_put\_req\_map(rdma, vec); pr\_err("svcrdma: Could not send reply, err=%d. Closing transport.\n", ret);- set\_bit(XPT\_CLOSE, &rdma->sc\_xprt.xpt\_flags);+ set\_bit(XPT\_CLOSE, &xprt->xpt\_flags); return -ENOTCONN; }--void svc\_rdma\_send\_error(struct svcxprt\_rdma \*xprt, struct rpcrdma\_msg \*rmsgp,- int status)-{- struct ib\_send\_wr err\_wr;- struct page \*p;- struct svc\_rdma\_op\_ctxt \*ctxt;- enum rpcrdma\_errcode err;- \_\_be32 \*va;- int length;- int ret;-- ret = svc\_rdma\_repost\_recv(xprt, GFP\_KERNEL);- if (ret)- return;-- p = alloc\_page(GFP\_KERNEL);- if (!p)- return;- va = page\_address(p);-- /\* XDR encode an error reply \*/- err = ERR\_CHUNK;- if (status == -EPROTONOSUPPORT)- err = ERR\_VERS;- length = svc\_rdma\_xdr\_encode\_error(xprt, rmsgp, err, va);-- ctxt = svc\_rdma\_get\_context(xprt);- ctxt->direction = DMA\_TO\_DEVICE;- ctxt->count = 1;- ctxt->pages[0] = p;-- /\* Prepare SGE for local address \*/- ctxt->sge[0].lkey = xprt->sc\_pd->local\_dma\_lkey;- ctxt->sge[0].length = length;- ctxt->sge[0].addr = ib\_dma\_map\_page(xprt->sc\_cm\_id->device,- p, 0, length, DMA\_TO\_DEVICE);- if (ib\_dma\_mapping\_error(xprt->sc\_cm\_id->device, ctxt->sge[0].addr)) {- dprintk("svcrdma: Error mapping buffer for protocol error\n");- svc\_rdma\_put\_context(ctxt, 1);- return;- }- svc\_rdma\_count\_mappings(xprt, ctxt);-- /\* Prepare SEND WR \*/- memset(&err\_wr, 0, sizeof(err\_wr));- ctxt->cqe.done = svc\_rdma\_wc\_send;- err\_wr.wr\_cqe = &ctxt->cqe;- err\_wr.sg\_list = ctxt->sge;- err\_wr.num\_sge = 1;- err\_wr.opcode = IB\_WR\_SEND;- err\_wr.send\_flags = IB\_SEND\_SIGNALED;-- /\* Post It \*/- ret = svc\_rdma\_send(xprt, &err\_wr);- if (ret) {- dprintk("svcrdma: Error %d posting send for protocol error\n",- ret);- svc\_rdma\_unmap\_dma(ctxt);- svc\_rdma\_put\_context(ctxt, 1);- }-}diff --git a/net/sunrpc/xprtrdma/svc\_rdma\_transport.c b/net/sunrpc/xprtrdma/svc\_rdma\_transport.cindex fc8f14c7bfec60..a9d9cb1ba4c606 100644--- a/[net/sunrpc/xprtrdma/svc\_rdma\_transport.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xprtrdma/svc_rdma_transport.c?id=73ccb023a2f25b72c4b95499ca24760588014614)+++ b/[net/sunrpc/xprtrdma/svc\_rdma\_transport.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xprtrdma/svc_rdma_transport.c?id=c70422f760c120480fee4de6c38804c72aa26bc1)@@ -272,85 +272,6 @@ static void svc\_rdma\_destroy\_ctxts(struct svcxprt\_rdma \*xprt) } } -static struct svc\_rdma\_req\_map \*alloc\_req\_map(gfp\_t flags)-{- struct svc\_rdma\_req\_map \*map;-- map = kmalloc(sizeof(\*map), flags);- if (map)- INIT\_LIST\_HEAD(&map->free);- return map;-}--static bool svc\_rdma\_prealloc\_maps(struct svcxprt\_rdma \*xprt)-{- unsigned int i;-- /\* One for each receive buffer on this connection. \*/- i = xprt->sc\_max\_requests;-- while (i--) {- struct svc\_rdma\_req\_map \*map;-- map = alloc\_req\_map(GFP\_KERNEL);- if (!map) {- dprintk("svcrdma: No memory for request map\n");- return false;- }- list\_add(&map->free, &xprt->sc\_maps);- }- return true;-}--struct svc\_rdma\_req\_map \*svc\_rdma\_get\_req\_map(struct svcxprt\_rdma \*xprt)-{- struct svc\_rdma\_req\_map \*map = NULL;-- spin\_lock(&xprt->sc\_map\_lock);- if (list\_empty(&xprt->sc\_maps))- goto out\_empty;-- map = list\_first\_entry(&xprt->sc\_maps,- struct svc\_rdma\_req\_map, free);- list\_del\_init(&map->free);- spin\_unlock(&xprt->sc\_map\_lock);--out:- map->count = 0;- return map;--out\_empty:- spin\_unlock(&xprt->sc\_map\_lock);-- /\* Pre-allocation amount was incorrect \*/- map = alloc\_req\_map(GFP\_NOIO);- if (map)- goto out;-- WARN\_ONCE(1, "svcrdma: empty request map list?\n");- return NULL;-}--void svc\_rdma\_put\_req\_map(struct svcxprt\_rdma \*xprt,- struct svc\_rdma\_req\_map \*map)-{- spin\_lock(&xprt->sc\_map\_lock);- list\_add(&map->free, &xprt->sc\_maps);- spin\_unlock(&xprt->sc\_map\_lock);-}--static void svc\_rdma\_destroy\_maps(struct svcxprt\_rdma \*xprt)-{- while (!list\_empty(&xprt->sc\_maps)) {- struct svc\_rdma\_req\_map \*map;-- map = list\_first\_entry(&xprt->sc\_maps,- struct svc\_rdma\_req\_map, free);- list\_del(&map->free);- kfree(map);- }-}- /\* QP event handler \*/ static void qp\_event\_handler(struct ib\_event \*event, void \*context) {@@ -474,24 +395,6 @@ void svc\_rdma\_wc\_send(struct ib\_cq \*cq, struct ib\_wc \*wc) }  /\*\*- \* svc\_rdma\_wc\_write - Invoked by RDMA provider for each polled Write WC- \* @cq: completion queue- \* @wc: completed WR- \*- \*/-void svc\_rdma\_wc\_write(struct ib\_cq \*cq, struct ib\_wc \*wc)-{- struct ib\_cqe \*cqe = wc->wr\_cqe;- struct svc\_rdma\_op\_ctxt \*ctxt;-- svc\_rdma\_send\_wc\_common\_put(cq, wc, "write");-- ctxt = container\_of(cqe, struct svc\_rdma\_op\_ctxt, cqe);- svc\_rdma\_unmap\_dma(ctxt);- svc\_rdma\_put\_context(ctxt, 0);-}--/\*\* \* svc\_rdma\_wc\_reg - Invoked by RDMA provider for each polled FASTREG WC \* @cq: completion queue \* @wc: completed WR@@ -561,14 +464,14 @@ static struct svcxprt\_rdma \*rdma\_create\_xprt(struct svc\_serv \*serv, INIT\_LIST\_HEAD(&cma\_xprt->sc\_read\_complete\_q); INIT\_LIST\_HEAD(&cma\_xprt->sc\_frmr\_q); INIT\_LIST\_HEAD(&cma\_xprt->sc\_ctxts);- INIT\_LIST\_HEAD(&cma\_xprt->sc\_maps);+ INIT\_LIST\_HEAD(&cma\_xprt->sc\_rw\_ctxts); init\_waitqueue\_head(&cma\_xprt->sc\_send\_wait);  spin\_lock\_init(&cma\_xprt->sc\_lock); spin\_lock\_init(&cma\_xprt->sc\_rq\_dto\_lock); spin\_lock\_init(&cma\_xprt->sc\_frmr\_q\_lock); spin\_lock\_init(&cma\_xprt->sc\_ctxt\_lock);- spin\_lock\_init(&cma\_xprt->sc\_map\_lock);+ spin\_lock\_init(&cma\_xprt->sc\_rw\_ctxt\_lock);  /\* \* Note that this implies that the underlying transport support@@ -999,6 +902,7 @@ static struct svc\_xprt \*svc\_rdma\_accept(struct svc\_xprt \*xprt) newxprt, newxprt->sc\_cm\_id);  dev = newxprt->sc\_cm\_id->device;+ newxprt->sc\_port\_num = newxprt->sc\_cm\_id->port\_num;  /\* Qualify the transport resource defaults with the \* capabilities of this particular device \*/@@ -1014,13 +918,11 @@ static struct svc\_xprt \*svc\_rdma\_accept(struct svc\_xprt \*xprt) svcrdma\_max\_bc\_requests); newxprt->sc\_rq\_depth = newxprt->sc\_max\_requests + newxprt->sc\_max\_bc\_requests;- newxprt->sc\_sq\_depth = RPCRDMA\_SQ\_DEPTH\_MULT \* newxprt->sc\_rq\_depth;+ newxprt->sc\_sq\_depth = newxprt->sc\_rq\_depth; atomic\_set(&newxprt->sc\_sq\_avail, newxprt->sc\_sq\_depth);  if (!svc\_rdma\_prealloc\_ctxts(newxprt)) goto errout;- if (!svc\_rdma\_prealloc\_maps(newxprt))- goto errout;  /\* \* Limit ORD based on client limit, local device limit, and@@ -1050,6 +952,8 @@ static struct svc\_xprt \*svc\_rdma\_accept(struct svc\_xprt \*xprt) memset(&qp\_attr, 0, sizeof qp\_attr); qp\_attr.event\_handler = qp\_event\_handler; qp\_attr.qp\_context = &newxprt->sc\_xprt;+ qp\_attr.port\_num = newxprt->sc\_cm\_id->port\_num;+ qp\_attr.cap.max\_rdma\_ctxs = newxprt->sc\_max\_requests; qp\_attr.cap.max\_send\_wr = newxprt->sc\_sq\_depth; qp\_attr.cap.max\_recv\_wr = newxprt->sc\_rq\_depth; qp\_attr.cap.max\_send\_sge = newxprt->sc\_max\_sge;@@ -1248,8 +1152,8 @@ static void \_\_svc\_rdma\_free(struct work\_struct \*work) }  rdma\_dealloc\_frmr\_q(rdma);+ svc\_rdma\_destroy\_rw\_ctxts(rdma); svc\_rdma\_destroy\_ctxts(rdma);- svc\_rdma\_destroy\_maps(rdma);  /\* Destroy the QP if present (not a listener) \*/ if (rdma->sc\_qp && !IS\_ERR(rdma->sc\_qp)) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-24 22:16:43 +0000


