```
{
  "CVE-2017-9104": {
    "description": "An issue was discovered in adns before 1.5.2. It hangs, eating CPU, if a compression pointer loop is encountered.",
    "vulnerability_details": {
      "root_cause": "The adns library does not handle compression pointer loops, leading to infinite loops and high CPU usage.",
      "weaknesses": [
        "Improper handling of compression pointer loops"
      ],
      "impact": "Denial of service due to a CPU-eating infinite loop.",
      "attack_vector": "Network",
       "attacker_capabilities": "An attacker can cause a denial of service by sending DNS responses containing compression pointer loops to a vulnerable application using the adns library"
    }
  },
   "CVE-2017-9103": {
    "description": "An issue was discovered in adns before 1.5.2. pap_mailbox822 does not properly check st from adns__findlabel_next. Without this, an uninitialised stack value can be used as the first label length. Depending on the circumstances, an attacker might be able to trick adns into crashing the calling program, leaking aspects of the contents of some of its memory, causing it to allocate lots of memory, or perhaps overrunning a buffer. This is only possible with applications which make non-raw queries for SOA or RP records.",
    "vulnerability_details": {
      "root_cause": "The `pap_mailbox822` function does not properly check the `st` value returned by `adns__findlabel_next`, leading to the use of an uninitialized stack value as the first label length.",
      "weaknesses": [
        "Improper handling of return value",
	"Use of uninitialized value"
      ],
      "impact": "Potential for crashing the calling program, leaking memory contents, causing excessive memory allocation, or buffer overflows. Specifically exploitable for applications making non-raw queries for SOA or RP records.",
      "attack_vector": "Network",
      "attacker_capabilities": "An attacker needs to send specific crafted DNS responses to a vulnerable application making non-raw queries for SOA or RP records."
    }
  },
  "CVE-2017-9105": {
    "description": "An issue was discovered in adns before 1.5.2. It corrupts a pointer when a nameserver speaks first because of a wrong number of pointer dereferences. This bug may well be exploitable as a remote code execution.",
    "vulnerability_details": {
      "root_cause": "Incorrect number of pointer dereferences when handling responses from a nameserver that speaks first.",
      "weaknesses": [
        "Incorrect pointer dereferences",
        "Potential use-after-free"
      ],
      "impact": "Potential for remote code execution due to pointer corruption.",
      "attack_vector": "Network",
      "attacker_capabilities": "An attacker can achieve remote code execution by manipulating the DNS responses received by the vulnerable application."
    }
  },
 "CVE-2017-9106": {
    "description": "An issue was discovered in adns before 1.5.2. adns_rr_info mishandles a bogus *datap. The general pattern for formatting integers is to sprintf into a fixed-size buffer. This is correct if the input is in the right range; if it isn't, the buffer may be overrun (depending on the sizes of the types on the current platform). Of course the inputs ought to be right. And there are pointers in there too, so perhaps one could say that the caller ought to check these things. It may be better to require the caller to make the pointer structure right, but to have the code here be defensive about (and tolerate with an error but without crashing) out-of-range integer values. So: it should defend each of these integer conversion sites with a check for the actual permitted range, and return adns_s_invaliddata if not. The lack of this check causes the SOA sign extension bug to be a serious security problem: the sign extended SOA value is out of range, and overruns the buffer when reconverted. This is related to sign extending SOA 32-bit integer fields, and use of a signed data type.",
    "vulnerability_details": {
      "root_cause": "Lack of input sanitization when converting integers in `adns_rr_info` leading to buffer overflows.",
       "weaknesses": [
         "Buffer overflow",
         "Lack of input validation"
        ],
      "impact": "Potential for out-of-bounds memory access or buffer overflows, which could lead to crashes or remote code execution.",
      "attack_vector": "Network",
      "attacker_capabilities": "An attacker can exploit this vulnerability by crafting malicious DNS responses which cause out-of-range integer values when converted."
     }
  },
  "CVE-2017-9107": {
    "description": "An issue was discovered in adns before 1.5.2. It overruns reading a buffer if a domain ends with backslash. If the query domain ended with \\, and adns_qf_quoteok_query was specified, qdparselabel would read additional bytes from the buffer and try to treat them as the escape sequence. It would depart the input buffer and start processing many bytes of arbitrary heap data as if it were the query domain. Eventually it would run out of input or find some other kind of error, and declare the query domain invalid. But before then it might outrun available memory and crash. In principle this could be a denial of service attack.",
    "vulnerability_details": {
      "root_cause": "Improper handling of backslashes at the end of domain names when `adns_qf_quoteok_query` is specified.  `qdparselabel` reads past the buffer boundary when a domain ends in a backslash.",
      "weaknesses": [
        "Buffer over-read",
	    "Improper input validation"
      ],
      "impact": "Potential for denial of service by triggering out-of-bounds reads and processing of arbitrary heap memory. The program could potentially crash, or become unstable.",
      "attack_vector": "Network",
       "attacker_capabilities": "An attacker can exploit this by crafting malicious queries ending in a backslash when using `adns_qf_quoteok_query`."
    }
  }
}
```