=== Content from en.bitcoin.it_d953b06a_20250125_044843.html ===


# Common Vulnerabilities and Exposures

From Bitcoin Wiki

[Jump to navigation](#mw-head)
[Jump to search](#searchInput)

| CVE | Announced | Affects | Severity | Attack is... | Flaw | Net |
| --- | --- | --- | --- | --- | --- | --- |
| Pre-BIP protocol changes | n/a | All Bitcoin clients | Netsplit[[1]](#cite_note-Netsplit-1) | Implicit[[2]](#cite_note-hardfork-2) | [Various hardforks and softforks](/wiki/Consensus_versions "Consensus versions") | 100% |
| [CVE-2010-5137](#CVE-2010-5137) | 2010-07-28 | wxBitcoin and bitcoind | DoS[[3]](#cite_note-DoS-3) | Easy | OP\_LSHIFT crash | 100% |
| [CVE-2010-5141](#CVE-2010-5141) | 2010-07-28 | wxBitcoin and bitcoind | Theft[[4]](#cite_note-Theft-4) | Easy | OP\_RETURN could be used to spend any output. | 100% |
| [CVE-2010-5138](#CVE-2010-5138) | 2010-07-29 | wxBitcoin and bitcoind | DoS[[3]](#cite_note-DoS-3) | Easy | Unlimited SigOp DoS | 100% |
| **[CVE-2010-5139](/wiki/CVE-2010-5139 "CVE-2010-5139")** | 2010-08-15 | wxBitcoin and bitcoind | Inflation[[5]](#cite_note-inflation-5) | Easy | Combined output overflow | 100% |
| [CVE-2010-5140](#CVE-2010-5140) | 2010-09-29 | wxBitcoin and bitcoind | DoS[[3]](#cite_note-DoS-3) | Easy | Never confirming transactions | 100% |
| [CVE-2011-4447](#CVE-2011-4447) | 2011-11-11 | wxBitcoin and bitcoind | Exposure[[6]](#cite_note-Exposure-6) | Hard | Wallet non-encryption | [100%](http://luke.dashjr.org/programs/bitcoin/files/charts/CVE-2011-4447.html) |
| [CVE-2012-1909](#CVE-2012-1909) | 2012-03-07 | Bitcoin protocol and all clients | Netsplit[[1]](#cite_note-Netsplit-1) | Very hard | Transaction overwriting | [100%](http://luke.dashjr.org/programs/bitcoin/files/charts/CVE-2012-1909.html) |
| [CVE-2012-1910](#CVE-2012-1910) | 2012-03-17 | bitcoind & Bitcoin-Qt for Windows | Unknown[[7]](#cite_note-Unknown-7) | Hard | Non-thread safe MingW exceptions | [100%](http://luke.dashjr.org/programs/bitcoin/files/charts/CVE-2012-1910.html) |
| [BIP 0016](#BIP-0016) | 2012-04-01 | All Bitcoin clients | Fake Conf[[8]](#cite_note-FakeConf-8) | Miners[[9]](#cite_note-MinerEasy-9) | Softfork: P2SH | [100%](http://luke.dashjr.org/programs/bitcoin/files/charts/BIP-0016.html) |
| [CVE-2012-2459](#CVE-2012-2459) | 2012-05-14 | bitcoind and Bitcoin-Qt | Netsplit[[1]](#cite_note-Netsplit-1) | Easy | Block hash collision (via merkle root) | [100%](http://luke.dashjr.org/programs/bitcoin/files/charts/CVE-2012-2459.html) |
| **[CVE-2012-3789](/wiki/CVE-2012-3789 "CVE-2012-3789")** | 2012-06-20 | bitcoind and Bitcoin-Qt | DoS[[3]](#cite_note-DoS-3) | Easy | (Lack of) orphan txn resource limits | [100%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?20123789) |
| [CVE-2012-4682](#CVE-2012-4682) |  | bitcoind and Bitcoin-Qt | DoS[[3]](#cite_note-DoS-3) |  |  | [100%](http://luke.dashjr.org/programs/bitcoin/files/charts/CVE-2012-4682.html) |
| **[CVE-2012-4683](/wiki/CVE-2012-4683 "CVE-2012-4683")** | 2012-08-23 | bitcoind and Bitcoin-Qt | DoS[[3]](#cite_note-DoS-3) | Easy | Targeted DoS by CPU exhaustion using alerts | [100%](http://luke.dashjr.org/programs/bitcoin/files/charts/CVE-2012-4683.html) |
| **[CVE-2012-4684](/wiki/CVE-2012-4684 "CVE-2012-4684")** | 2012-08-24 | bitcoind and Bitcoin-Qt | DoS[[3]](#cite_note-DoS-3) | Easy | Network-wide DoS using malleable signatures in alerts | [100%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?20124684) |
| [CVE-2013-2272](#CVE-2013-2272) | 2013-01-11 | bitcoind and Bitcoin-Qt | Exposure[[6]](#cite_note-Exposure-6) | Easy | Remote discovery of node's wallet addresses | [99.99%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?20132272) |
| [CVE-2013-2273](#CVE-2013-2273) | 2013-01-30 | bitcoind and Bitcoin-Qt | Exposure[[6]](#cite_note-Exposure-6) | Easy | Predictable change output | [99.99%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?20132273) |
| [CVE-2013-2292](#CVE-2013-2292) | 2013-01-30 | bitcoind and Bitcoin-Qt | DoS[[3]](#cite_note-DoS-3) | Hard | A transaction that takes at least 3 minutes to verify | [0%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?20132292) |
| **[CVE-2013-2293](/wiki/CVE-2013-2293 "CVE-2013-2293")** | 2013-02-14 | bitcoind and Bitcoin-Qt | DoS[[3]](#cite_note-DoS-3) | Easy | Continuous hard disk seek | [99.99%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?20132293) |
| [CVE-2013-3219](#CVE-2013-3219) | 2013-03-11 | bitcoind and Bitcoin-Qt 0.8.0 | Fake Conf[[8]](#cite_note-FakeConf-8) | Miners[[9]](#cite_note-MinerEasy-9) | Unenforced block protocol rule | [100%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?20133219) |
| [CVE-2013-3220](#CVE-2013-3220) | 2013-03-11 | bitcoind and Bitcoin-Qt | Netsplit[[1]](#cite_note-Netsplit-1) | Hard | Inconsistent BDB lock limit interactions | [99.99%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?20133220) |
| [BIP 0034](#BIP-0034) | 2013-03-25 | All Bitcoin clients | Fake Conf[[8]](#cite_note-FakeConf-8) | Miners[[9]](#cite_note-MinerEasy-9) | Softfork: Height in coinbase | [100%](http://luke.dashjr.org/programs/bitcoin/files/charts/BIP-0034.html) |
| [BIP 0050](#BIP-0050) | 2013-05-15 | All Bitcoin clients | Netsplit[[1]](#cite_note-Netsplit-1) | Implicit[[2]](#cite_note-hardfork-2) | Hard fork to remove txid limit protocol rule | [99.99%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?50) |
| [CVE-2013-4627](#CVE-2013-4627) | 2013-06-?? | bitcoind and Bitcoin-Qt | DoS[[3]](#cite_note-DoS-3) | Easy | Memory exhaustion with excess tx message data | [99%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?20134627) |
| [CVE-2013-4165](#CVE-2013-4165) | 2013-07-20 | bitcoind and Bitcoin-Qt | Theft[[10]](#cite_note-theft-local-timing-10) | Local | Timing leak in RPC authentication | [99%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?20134165) |
| [CVE-2013-5700](#CVE-2013-5700) | 2013-09-04 | bitcoind and Bitcoin-Qt 0.8.x | DoS[[3]](#cite_note-DoS-3) | Easy | Remote p2p crash via bloom filters | [99%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?20135700) |
| [CVE-2014-0160](#CVE-2014-0160) | 2014-04-07 | Anything using OpenSSL for TLS | Unknown[[7]](#cite_note-Unknown-7) | Easy | Remote memory leak via payment protocol | Unknown |
| [CVE-2015-3641](https://bitcoincore.org/en/2024/07/03/disclose_receive_buffer_oom/) | 2014-07-07 | bitcoind and Bitcoin-Qt prior to 0.10.2 | DoS[[3]](#cite_note-DoS-3) | Easy | OOM via p2p | [99.9%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?20135700) |
| BIP 66 | 2015-02-13 | All Bitcoin clients | Fake Conf[[8]](#cite_note-FakeConf-8) | Miners[[9]](#cite_note-MinerEasy-9) | Softfork: Strict DER signatures | [99%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?66) |
| BIP 65 | 2015-11-12 | All Bitcoin clients | Fake Conf[[8]](#cite_note-FakeConf-8) | Miners[[9]](#cite_note-MinerEasy-9) | Softfork: OP\_CHECKLOCKTIMEVERIFY | [99%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?65) |
| BIPs 68, 112 & 113 | 2016-04-11 | All Bitcoin clients | Fake Conf[[8]](#cite_note-FakeConf-8) | Miners[[9]](#cite_note-MinerEasy-9) | Softforks: Rel locktime, CSV & MTP locktime | [99%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?68) |
| CVE-2015-6031 | 2015-09-15 | MiniUPnPcBitcoin Core/Knots prior to 0.11.2 | Anything | LAN | Buffer overflow |
| BIPs 141, 143 & 147 | 2016-10-27 | All Bitcoin clients | Fake Conf[[8]](#cite_note-FakeConf-8) | Miners[[9]](#cite_note-MinerEasy-9) | Softfork: Segwit | [99%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?141) |
| [CVE-2016-8889](#CVE-2016-8889) | 2016-10-27 | Bitcoin Knots GUI 0.11.0 - 0.13.0 | Exposure | Hard | Debug console history storing sensitive info | 100% |
| CVE-2017-9230 | ? | Bitcoin | ? | ? | ASICBoost | 0% |
| BIP 148 | 2017-03-12 | All Bitcoin clients | Fake Conf[[8]](#cite_note-FakeConf-8) | Miners[[9]](#cite_note-MinerEasy-9) | Softfork: Segwit UASF | ? |
| [CVE-2017-12842](#CVE-2017-12842) | 2018-06-09 |  |  |  | No commitment to block merkle tree depth |  |
| [CVE-2016-10724](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016189.html) | 2018-07-02 | bitcoind and Bitcoin-Qt prior to 0.13.0 | DoS[[3]](#cite_note-DoS-3) | Keyholders[[11]](#cite_note-KeyholderEasy-11) | Alert memory exhaustion | [99%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?201610724) |
| [TBD](https://bitcoincore.org/en/2024/07/03/disclose-header-spam/) | 2024-07-03 | Bitcoin Core/Knots prior to 0.15.0 | DoS[[3]](#cite_note-DoS-3) | Easy | OOM via fake block headers |
| [CVE-2016-10725](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016189.html) | 2018-07-02 | bitcoind and Bitcoin-Qt prior to 0.13.0 | DoS[[3]](#cite_note-DoS-3) | Keyholders[[11]](#cite_note-KeyholderEasy-11) | Final alert cancellation | [99%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?201610724) |
| [CVE-2018-17144](#CVE-2018-17144) | 2018-09-17 | bitcoind and Bitcoin-Qt prior to 0.16.3 | Inflation[[5]](#cite_note-inflation-5) | Miners[[9]](#cite_note-MinerEasy-9) | Missing check for duplicate inputs | [80%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?201817144) |
| [CVE-2018-20587](https://medium.com/%40lukedashjr/cve-2018-20587-advisory-and-full-disclosure-a3105551e78b) | 2019-02-08 | Bitcoin Knots prior to 0.17.1, and all current Bitcoin Core releases | Theft[[10]](#cite_note-theft-local-timing-10) | Local | No alert for RPC service binding failure | [<1%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?201820587) |
| [CVE-2017-18350](#CVE-2017-18350) | 2019-06-22 | bitcoind and Bitcoin-Qt prior to 0.15.1 | Unknown | Varies[[12]](#cite_note-12) | Buffer overflow from SOCKS proxy | [94%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?201718350) |
| [CVE-2018-20586](#CVE-2018-20586) | 2019-06-22 | bitcoind and Bitcoin-Qt prior to 0.17.1 | Deception | RPC access | Debug log injection via unauthenticated RPC | [77%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?201820586) |
| [TBD](https://bitcoincore.org/en/2024/07/03/disclose-orphan-dos/) | 2024-07-03 | Bitcoin Core/Knots prior to 0.18.0 | DoS | Easy | Orphan transaction CPU tieup |
| [CVE-2019-12998](https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-September/002174.html) | 2019-08-30 | c-lightning prior to 0.7.1 | Theft | Easy | Missing check of channel funding UTXO |
| [CVE-2019-12999](https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-September/002174.html) | 2019-08-30 | lnd prior to 0.7 | Theft | Easy | Missing check of channel funding UTXO amount |
| [CVE-2019-13000](https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-September/002174.html) | 2019-08-30 | eclair prior to 0.3 | Theft | Easy | Missing check of channel funding UTXO |
| [TBD](https://bitcoincore.org/en/2024/07/03/disclose-inv-buffer-blowup/) | 2024-07-03 | Bitcoin Core/Knots prior to 0.20.0 | DoS | Easy | Network buffer OOM |
| [TBD](https://bitcoincore.org/en/2024/07/03/disclose-getdata-cpu/) | 2024-07-03 | Bitcoin Core/Knots prior to 0.20.0 | CPU usage | Easy | Infinite loop via p2p |
| [TBD](https://bitcoincore.org/en/2024/07/03/disclose-bip70-crash/) | 2024-07-03 | Bitcoin Core/Knots prior to 0.20.0 | DoS | Recipient[[13]](#cite_note-Recipient-13) | OOM via malicious BIP72 URI |
| [CVE-2020-14199](#CVE-2020-14199) | 2020-06-03 | Trezor and others | Theft | Social[[14]](#cite_note-14) | Double-signing can enable unintended fees |
| [CVE-2018-17145](https://invdos.net/) | 2020-09-09 | Bitcoin Core prior to 0.16.2Bitcoin Knots prior to 0.16.1Bcoin prior to 1.0.2Btcd prior to 0.21.0 | DoS[[3]](#cite_note-DoS-3) | Easy | p2p memory blow-up | [87%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?201817145) |
| [CVE-2020-26895](#CVE-2020-26895) | 2020-10-08 | lnd prior to 0.10 | Theft | Easy | Missing low-S normalization for HTLC signatures |
| [CVE-2020-26896](#CVE-2020-26896) | 2020-10-08 | lnd prior to 0.11 | Theft | Varies[[15]](#cite_note-15) | Invoice preimage extraction via forwarded HTLC |
| [CVE-2020-14198](https://bitcoincore.org/en/2024/07/03/disclose-unbounded-banlist/) |  | Bitcoin Core 0.20.1 | DoS[[3]](#cite_note-DoS-3) | Easy | Remote DoS | [93%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?202014198) |
| [TBD](https://bitcoincore.org/en/2024/07/03/disclose-timestamp-overflow/) | 2024-07-03 | Bitcoin Core/Knots prior to 0.20.2 | Netsplit[[1]](#cite_note-Netsplit-1) | Varies | Adjusted time manipulation |
| [CVE-2021-3401](#CVE-2021-3401) | 2021-02-01 | Bitcoin Core GUI prior to 0.19.0Bitcoin Knots GUI prior to 0.18.1 | Theft | Hard | Qt5 remote execution | [64%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?20213401) |
| [TBD](https://bitcoincore.org/en/2024/07/31/disclose-upnp-oom/) | 2024-07-31 | Bitcoin Core/Knots prior to 22.0 with UPnP enabled | DoS | Local | OOM via LAN spam |
| [TBD](https://bitcoincore.org/en/2024/07/31/disclose-addrman-int-overflow/) | 2024-07-31 | Bitcoin Core/Knots prior to 22.0 | DoS | Easy | OOM via p2p spam |
| [CVE-2021-31876](#CVE-2021-31876) | 2021-05-06 | Various wallets |  |  |  |
| CVE-2021-41591 | 2021-10-04 | Lightning software |  |  |  |
| CVE-2021-41592 | 2021-10-04 | Lightning software |  |  |  |
| CVE-2021-41593 | 2021-10-04 | Lightning software |  |  |  |
| BIPs 341-343 | 2021-11-13 | All Bitcoin nodes | Fake Conf[[8]](#cite_note-FakeConf-8) | Miners[[9]](#cite_note-MinerEasy-9) | Softfork: Taproot | [57%](http://luke.dashjr.org/programs/bitcoin/files/charts/security.html?343) |
| [CVE-2022-31246](https://github.com/spesmilo/electrum/security/advisories/GHSA-4fh4-hx35-r355) | 2022-06-07 | Electrum 2.1 until before 4.2.2 | Theft | Social |  |
| [CVE-2023-50428](#CVE-2023-50428) | 2023 | All Bitcoin nodes | DoS[[3]](#cite_note-DoS-3) | Easy | Bypass of datacarriersize limit using OP\_FALSE,OP\_IF |  |
| [CVE-2024-34149](#CVE-2024-34149) | 2024-03-30 | Bitcoin Core 0.21.1 and newer (not fixed)Bitcoin Knots 0.21.1 - 0.23.0 | DoS[[3]](#cite_note-DoS-3) | Easy | Script size limit not enforced for Tapscript |  |

1. ↑ [1.0](#cite_ref-Netsplit_1-0) [1.1](#cite_ref-Netsplit_1-1) [1.2](#cite_ref-Netsplit_1-2) [1.3](#cite_ref-Netsplit_1-3) [1.4](#cite_ref-Netsplit_1-4) [1.5](#cite_ref-Netsplit_1-5) Attacker can create multiple views of the network, enabling [double-spending](/wiki/Double-spending "Double-spending") with over 1 confirmation
2. ↑ [2.0](#cite_ref-hardfork_2-0) [2.1](#cite_ref-hardfork_2-1) This is a protocol "hard-fork" that old clients will reject as invalid and must therefore not be used.
3. ↑ [3.00](#cite_ref-DoS_3-0) [3.01](#cite_ref-DoS_3-1) [3.02](#cite_ref-DoS_3-2) [3.03](#cite_ref-DoS_3-3) [3.04](#cite_ref-DoS_3-4) [3.05](#cite_ref-DoS_3-5) [3.06](#cite_ref-DoS_3-6) [3.07](#cite_ref-DoS_3-7) [3.08](#cite_ref-DoS_3-8) [3.09](#cite_ref-DoS_3-9) [3.10](#cite_ref-DoS_3-10) [3.11](#cite_ref-DoS_3-11) [3.12](#cite_ref-DoS_3-12) [3.13](#cite_ref-DoS_3-13) [3.14](#cite_ref-DoS_3-14) [3.15](#cite_ref-DoS_3-15) [3.16](#cite_ref-DoS_3-16) [3.17](#cite_ref-DoS_3-17) [3.18](#cite_ref-DoS_3-18) Attacker can disable some functionality, for example by crashing clients
4. [↑](#cite_ref-Theft_4-0) Attacker can take coins outside known network rules
5. ↑ [5.0](#cite_ref-inflation_5-0) [5.1](#cite_ref-inflation_5-1) Attacker can create coins outside known network rules
6. ↑ [6.0](#cite_ref-Exposure_6-0) [6.1](#cite_ref-Exposure_6-1) [6.2](#cite_ref-Exposure_6-2) Attacker can access user data outside known acceptable methods
7. ↑ [7.0](#cite_ref-Unknown_7-0) [7.1](#cite_ref-Unknown_7-1) Extent of possible abuse is unknown
8. ↑ [8.0](#cite_ref-FakeConf_8-0) [8.1](#cite_ref-FakeConf_8-1) [8.2](#cite_ref-FakeConf_8-2) [8.3](#cite_ref-FakeConf_8-3) [8.4](#cite_ref-FakeConf_8-4) [8.5](#cite_ref-FakeConf_8-5) [8.6](#cite_ref-FakeConf_8-6) [8.7](#cite_ref-FakeConf_8-7) [8.8](#cite_ref-FakeConf_8-8) Attacker can double-spend with 1 confirmation
9. ↑ [9.00](#cite_ref-MinerEasy_9-0) [9.01](#cite_ref-MinerEasy_9-1) [9.02](#cite_ref-MinerEasy_9-2) [9.03](#cite_ref-MinerEasy_9-3) [9.04](#cite_ref-MinerEasy_9-4) [9.05](#cite_ref-MinerEasy_9-5) [9.06](#cite_ref-MinerEasy_9-6) [9.07](#cite_ref-MinerEasy_9-7) [9.08](#cite_ref-MinerEasy_9-8) [9.09](#cite_ref-MinerEasy_9-9) Attacking requires mining block(s)
10. ↑ [10.0](#cite_ref-theft-local-timing_10-0) [10.1](#cite_ref-theft-local-timing_10-1) Local attacker could potentially determine the RPC passphrase via a timing sidechannel.
11. ↑ [11.0](#cite_ref-KeyholderEasy_11-0) [11.1](#cite_ref-KeyholderEasy_11-1) Attacking requires signing with the publicly-disclosed alert key
12. [↑](#cite_ref-12) Depends on software configuration
13. [↑](#cite_ref-Recipient_13-0) Can only be exploited by the recipient the victim intends to pay
14. [↑](#cite_ref-14) User must be tricked into cooperating (social engineering)
15. [↑](#cite_ref-15) Depends on node configuration, only affects routable merchants, requires external knowledge of receiver's invoices and/or luck to identify receiver, only works against single-shot HTLCs (legacy or MPP)

## CVE-2010-5137

```
Date: 2010-07-28
Summary: OP_LSHIFT crash
Fix Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| bitcoindwxBitcoin | \* - 0.3.4 | 0.3.5 |

On July 28 2010, two bugs were discovered and demonstrated on the test network. One caused bitcoin to crash on some machines when processing a transaction containing an OP\_LSHIFT. This was never exploited on the main network, and was fixed by Bitcoin version 0.3.5.

After these bugs were discovered, many currently-unused script words were disabled for safety.

### References

* [US-CERT/NIST](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2010-5137)

## CVE-2010-5141

```
Date: 2010-07-28
Summary: ?
Fix Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| bitcoindwxBitcoin | \* - 0.3.4 | 0.3.5 |

On July 28 2010, two bugs were discovered and demonstrated on the test network. One exploited a bug in the transaction handling code and allowed an attacker to spend coins that they did not own. This was never exploited on the main network, and was fixed by Bitcoin version 0.3.5.

After these bugs were discovered, many currently-unused script words were disabled for safety.

### References

* [US-CERT/NIST](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2010-5141)

## CVE-2010-5138

```
Date: 2010-07-29
Summary: Unlimited SigOp DoS
Fix Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| bitcoindwxBitcoin | \* - 0.3.? | 0.3.? |

On July 29 2010, it was discovered that block [71036](http://blockexplorer.com/block/00000000000997f9fd2fe1ee376293ef8c42ad09193a5d2086dddf8e5c426b56) contained several transactions with a ton of OP\_CHECKSIG commands. There should only ever be one such command. This caused every node to do extra unnecessary work, and it could have been used as a denial-of-service attack. A new version of Bitcoin was quickly released. The new version did not cause a fork on the main network, though it did cause one on the test network (where someone had played around with the attack more).

### References

* [US-CERT/NIST](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2010-5138)

## CVE-2010-5139

*Main article: [CVE-2010-5139](/wiki/CVE-2010-5139 "CVE-2010-5139")*
```
Date: 2010-08-15
Summary: Combined output overflow
Fix Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| bitcoindwxBitcoin | \* - 0.3.10 | 0.3.11 |

On August 15 2010, it was [discovered](http://bitcointalk.org/index.php?topic=822.0) that block 74638 contained a transaction that created over 184 billion bitcoins for two different addresses. This was possible because the code used for checking transactions before including them in a block didn't account for the case of outputs so large that they overflowed when summed. A new version was published within a few hours of the discovery. The block chain had to be forked. Although many unpatched nodes continued to build on the "bad" block chain, the "good" block chain overtook it at a block height of 74691. The bad transaction no longer exists for people using the longest chain.

The block and transaction:

```
CBlock(hash=0000000000790ab3, ver=1, hashPrevBlock=0000000000606865, hashMerkleRoot=618eba,
nTime=1281891957, nBits=1c00800e, nNonce=28192719, vtx=2)
  CTransaction(hash=012cd8, ver=1, vin.size=1, vout.size=1, nLockTime=0)
    CTxIn(COutPoint(000000, -1), coinbase 040e80001c028f00)
    CTxOut(nValue=50.51000000, scriptPubKey=0x4F4BA55D1580F8C3A8A2C7)
  CTransaction(hash=1d5e51, ver=1, vin.size=1, vout.size=2, nLockTime=0)
    CTxIn(COutPoint(237fe8, 0), scriptSig=0xA87C02384E1F184B79C6AC)
    CTxOut(nValue=92233720368.54275808, scriptPubKey=OP_DUP OP_HASH160 0xB7A7)
    CTxOut(nValue=92233720368.54275808, scriptPubKey=OP_DUP OP_HASH160 0x1512)
  vMerkleTree: 012cd8 1d5e51 618eba

Block hash: 0000000000790ab3f22ec756ad43b6ab569abf0bddeb97c67a6f7b1470a7ec1c
Transaction hash: 1d5e512a9723cbef373b970eb52f1e9598ad67e7408077a82fdac194b65333c9
```
### References

* [Discovery](https://bitcointalk.org/index.php?topic=822.0)
* [US-CERT/NIST](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2010-5139)

## CVE-2010-5140

```
Date: 2010-09-29
Summary: Never confirming transactions
Fix Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| bitcoindwxBitcoin | \* - 0.3.12 | 0.3.13 |

Around September 29, 2010, people started [reporting](https://bitcointalk.org/index.php?topic=1306.0) that their sent transactions would not confirm. This happened because people modified Bitcoin to send sub-0.01 transactions without any fees. A 0.01 fee was at that time required by the network for such transactions (essentially prohibiting them), so the transactions remained at 0 confirmations forever. This became a more serious issue because Bitcoin would send transactions using bitcoins gotten from transactions with 0 confirmations, and these resulting transactions would also never confirm. Because Bitcoin tends to prefer sending smaller coins, these invalid transactions quickly multiplied, contaminating the wallets of everyone who received them.

Bitcoin was changed to only select coins with at least 1 confirmation. The remaining sub-0.01 transactions were cleared by generators who modified their version of Bitcoin to not require the micropayment fee. It took a while for everything to get cleared, though, because many of the intermediate transactions had been forgotten by the network by this point and had to be rebroadcast by the original senders.

### References

* [Initial reports](https://bitcointalk.org/index.php?topic=1306.0)
* [US-CERT/NIST](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2010-5140)

## CVE-2011-4447

```
Date: 2011-11-11
Summary: Wallet non-encryption
Fix Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| bitcoindwxBitcoin | 0.4.0 - 0.4.1rc6 | 0.4.10.5.0 |

### References

* [Announcement](https://bitcointalk.org/index.php?topic=51604.0)
* [Finding](https://bitcointalk.org/index.php?topic=51474.0)
* [0.5.0](http://bitcoin.org/releases/2011/11/21/v0.5.0.html)
* [US-CERT/NIST](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-4447)

## CVE-2012-1909

```
Date: 2012-03-07
Summary: Transaction overwriting
Fix Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin protocol | Before March 15th, 2012 | BIP 30 |
| Bitcoin-Qtbitcoind | \* - 0.4.4rc20.5.0rc1 - 0.5.0.4rc20.5.1rc1 - 0.5.3rc20.6.0rc1 - 0.6.0rc2 | 0.4.40.5.0.40.5.30.6.0rc3 |
| wxBitcoin | ALL | NONE |

### References

* [Announcement](https://bitcointalk.org/index.php?topic=67738.0)
* [Fix](https://en.bitcoin.it/wiki/BIP_0030)
* [Gentoo bug tracker](https://bugs.gentoo.org/show_bug.cgi?id=407793)
* [US-CERT/NIST](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-1909)

## CVE-2012-1910

```
Date: 2012-03-17
Summary: Non-thread safe MingW exceptions
Fix Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| bitcoind for WindowsBitcoin-Qt for Windows | 0.5.0rc1 - 0.5.0.40.5.1rc1 - 0.5.3.00.6.0rc1 - 0.6.0rc3 | 0.5.0.50.5.3.10.5.40.6.0rc4 |

### References

* [Announcement](https://bitcointalk.org/index.php?topic=69120.0)
* [US-CERT/NIST](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-1910)
* [Full disclosure](http://gavintech.blogspot.com/2012/03/full-disclosure-bitcoin-qt-on-windows.html)

## BIP-0016

```
Date: 2012-04-01
Summary: Mandatory P2SH protocol update
Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | \* - 0.4.40.5.0rc1 - 0.5.0.50.5.1rc1 - 0.5.30.6.0rc1 | 0.4.50.5.0.60.5.4rc10.6.0rc2 |
| wxBitcoin | ALL | NONE |

### References

* [BIP 0016](/wiki/BIP_0016 "BIP 0016")

## CVE-2012-2459

```
Date: 2012-05-14
Summary: Block hash collision (via merkle tree)
Fix Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | \* - 0.4.6rc10.5.0rc1 - 0.5.5rc10.6.0rc1 - 0.6.0.7rc10.6.1rc1 - 0.6.1rc1 | 0.4.60.5.50.6.0.70.6.1rc2 |

Block hash collisions can easily be made by duplicating transactions in the merkle tree.
Such a collision is invalid, but if recorded (as Bitcoin-Qt and bitcoind prior to 0.6.1 did) would prevent acceptance of the legitimate block with the same hash.
This could be used to fork the blockchain, including deep double-spend attacks.

### References

* [Announcement](https://bitcointalk.org/?topic=81749)
* [Gentoo bug tracker](https://bugs.gentoo.org/show_bug.cgi?id=415973)
* [US-CERT/NIST](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-2459)
* [Full Disclosure](https://bitcointalk.org/?topic=102395)

## CVE-2012-3789

*Main article: [CVE-2012-3789](/wiki/CVE-2012-3789 "CVE-2012-3789")*
```
Date: 2012-06-20
Summary: (Lack of) orphan txn resource limits
Fix Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | \* - 0.4.7rc20.5.0rc1 - 0.5.6rc20.6.0rc1 - 0.6.0.8rc20.6.1rc1 - 0.6.2.2 | 0.4.7rc30.5.6rc30.6.0.9rc10.6.3rc1 |

### References

* [CVE-2012-3789](/wiki/CVE-2012-3789 "CVE-2012-3789")
* [0.6.3rc1 Announcement](https://bitcointalk.org/?topic=88734)
* [US-CERT/NIST](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-3789)

## CVE-2012-4682

```
Date:
Summary:
Fix Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | \* - 0.4.7rc20.5.0rc1 - 0.5.6rc20.6.0rc1 - 0.6.0.8rc20.6.1rc1 - 0.6.2.2 | 0.4.7rc30.5.6rc30.6.0.9rc10.6.3rc1 |

### References

* [CVE-2012-4682](/w/index.php?title=CVE-2012-4682&action=edit&redlink=1 "CVE-2012-4682 (page does not exist)")
* [Gentoo bug](https://bugs.gentoo.org/show_bug.cgi?id=435216)

## CVE-2012-4683

*Main article: [CVE-2012-4683](/wiki/CVE-2012-4683 "CVE-2012-4683")*
```
Date: 2012-08-23
Summary: Targeted DoS by CPU exhaustion using alerts
Fix Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | \* - 0.4.7rc20.5.0rc1 - 0.5.6rc20.6.0rc1 - 0.6.0.8rc20.6.1rc1 - 0.6.2.2 | 0.7.0 |

### References

* [CVE-2012-4683](/wiki/CVE-2012-4683 "CVE-2012-4683")
* [Announcement](https://bitcointalk.org/index.php?topic=148038.0)
* [Gentoo bug](https://bugs.gentoo.org/show_bug.cgi?id=435216)

## CVE-2012-4684

*Main article: [CVE-2012-4684](/wiki/CVE-2012-4684 "CVE-2012-4684")*
```
Date: 2012-08-24
Summary: Network-wide DoS using malleable signatures in alerts
Fix Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | \* - 0.4.7rc20.5.0rc1 - 0.5.6rc20.6.0rc1 - 0.6.0.8rc20.6.1rc1 - 0.6.2.2 - 0.6.3rc1 | 0.7.0 |

### References

* [CVE-2012-4684](/wiki/CVE-2012-4684 "CVE-2012-4684")
* [Announcement](https://bitcointalk.org/index.php?topic=148109.0)

## CVE-2013-2272

```
Date: 2013-01-11
Summary: Remote discovery of node's wallet addresses
Fix Deployment: 99.99%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | \* - 0.4.8rc40.5.0rc1 - 0.5.70.6.0rc1 - 0.6.0.10rc40.6.1rc1 - 0.6.4rc40.7.0rc1 - 0.7.2 | 0.4.9rc10.5.8rc10.6.0.11rc10.6.5rc10.7.3rc1 |

### References

* [Announcement](https://bitcointalk.org/?topic=135856)
* [Gentoo bug](https://bugs.gentoo.org/show_bug.cgi?id=462046)

## CVE-2013-2273

```
Date: 2013-01-30
Summary: Predictable change output
Fix Deployment: 99.99%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | \* - 0.4.8rc40.5.0rc1 - 0.5.70.6.0rc1 - 0.6.0.10rc40.6.1rc1 - 0.6.4rc40.7.0rc1 - 0.7.2 | 0.4.9rc10.5.8rc10.6.0.11rc10.6.5rc10.7.3rc1 |

### References

* [Gentoo bug](https://bugs.gentoo.org/show_bug.cgi?id=462046)

## CVE-2013-2292

```
Date: 2013-01-30
Summary: A transaction that takes at least 3 minutes to verify
Fix Deployment: 0%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | All versions | No fix yet |

### References

* [CVE-2013-2292](/w/index.php?title=CVE-2013-2292&action=edit&redlink=1 "CVE-2013-2292 (page does not exist)")
* [Announcement](https://bitcointalk.org/?topic=140078)
* [Gentoo bug](https://bugs.gentoo.org/show_bug.cgi?id=462046)

## CVE-2013-2293

*Main article: [CVE-2013-2293](/wiki/CVE-2013-2293 "CVE-2013-2293")*
```
Date: 2013-02-14
Summary: Continuous hard disk seek
Fix Deployment: 99.99%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | \* - 0.7.3rc1 | No fix yet (0.8.0 unaffected) |

### References

* [CVE-2013-2293](/wiki/CVE-2013-2293 "CVE-2013-2293")
* [Announcement](https://bitcointalk.org/?topic=144122)
* [Gentoo bug](https://bugs.gentoo.org/show_bug.cgi?id=462046)

## CVE-2013-3219

```
Date: 2013-03-11
Summary: Unenforced block protocol rule
Fix Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | 0.8.0rc1 - 0.8.0 | 0.8.1 |

### References

* [BIP 50](/wiki/BIP_0050 "BIP 0050")

## CVE-2013-3220

```
Date: 2013-03-11
Summary: Inconsistent BDB lock limit interactions
Fix Deployment: 99.99%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | \* - 0.4.9rc10.5.0rc1 - 0.5.8rc10.6.0rc1 - 0.6.5rc10.7.0rc1 - 0.7.3rc1 | 0.4.9rc20.5.8rc20.6.5rc20.7.3rc2 |
| wxBitcoin | ALL | NONE |

### References

* [BIP 50](/wiki/BIP_0050 "BIP 0050")

## BIP-0034

```
Date: 2013-03-25
Summary: Mandatory block protocol update
Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | \* - 0.4.70.5.0rc1 - 0.5.70.6.0rc1 - 0.6.0.90.6.1rc1 - 0.6.3 | 0.4.8rc10.5.7rc10.6.0.10rc10.6.4rc1 |
| wxBitcoin | ALL | NONE |

### References

* [BIP 0034](/wiki/BIP_0034 "BIP 0034")

## BIP-0050

```
Date: 2013-05-15
Summary: Hard fork to remove txid limit protocol rule
Deployment: 99.99%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | \* - 0.4.9rc10.5.0rc1 - 0.5.8rc10.6.0rc1 - 0.6.5rc10.7.0rc1 - 0.7.3rc1 | 0.4.9rc20.5.8rc20.6.5rc20.7.3rc2 |
| wxBitcoin | ALL | NONE |

### References

* [BIP 0050](/wiki/BIP_0050 "BIP 0050")

## CVE-2013-4627

```
Date: 2013-06-??
Summary: Memory exhaustion with excess tx message data
Fix Deployment: 99.9%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | \* - 0.4.9rc30.5.0rc1 - 0.5.8rc30.6.0rc1 - 0.6.5rc30.7.0rc1 - 0.7.3rc30.8.0rc1 - 0.8.3 | 0.4.9rc40.5.8rc40.6.5rc40.7.3rc40.8.4 |
| wxBitcoin | ALL | NONE |

### References

## CVE-2013-4165

```
Date: 2013-07-20
Summary: Timing leak in RPC authentication
Fix Deployment: 99.9%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | \* - 0.4.9rc30.5.0rc1 - 0.5.8rc30.6.0rc1 - 0.6.5rc30.7.0rc1 - 0.7.3rc30.8.0rc1 - 0.8.3 | 0.4.9rc40.5.8rc40.6.5rc40.7.3rc40.8.4rc1 |
| wxBitcoin | ALL | NONE |

### References

* [Bitcoin-Qt 0.8.4 release notes](https://bitcointalk.org/index.php?topic=287351)
* [The initial bug report](https://github.com/bitcoin/bitcoin/issues/2838)

## CVE-2013-5700

```
Date: 2013-09-04
Summary: Remote p2p crash via bloom filters
Fix Deployment: 99.9%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | 0.8.0rc1 - 0.8.3 | 0.8.4rc1 |

### References

* [Bitcoin-Qt 0.8.4 release notes](https://bitcointalk.org/index.php?topic=287351)
* [The fix](https://github.com/bitcoin/bitcoin/commit/37c6389c5a0ca63ae3573440ecdfe95d28ad8f07)
* [An added test](https://github.com/bitcoin/bitcoin/pull/18515)

## CVE-2016-8889

```
Date: 2016-10-27
Summary: Debug console history storing sensitive info
Fix Deployment: 100%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin Knots GUI | 0.11.0 - 0.13.0 | 0.13.1 |

### References

* [Bitcoin Knots 0.16.1.knots20161027 release notes](https://github.com/bitcoinknots/bitcoin/blob/v0.13.1.knots20161027/doc/release-notes.md)
* [US-CERT/NIST](https://nvd.nist.gov/vuln/detail/CVE-2016-8889)

## CVE-2017-12842

```
Date: 2018-06-09
Summary: No commitment to block merkle tree depth

```
### References

* [Explanation by Sergio Demian Lerner](https://bitslog.wordpress.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/)
* [Further elaboration by Suhas Daftuar](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-February/016697.html)

## CVE-2017-18350

```
Date: 2019-06-22
Summary: Buffer overflow from SOCKS proxy

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | 0.7.0rc1 - 0.15.0 | 0.15.1rc1 |

### References

* [Disclosure of details](https://medium.com/%40lukedashjr/cve-2017-18350-disclosure-fe6d695f45d5)

## CVE-2018-17144

```
Date: 2018-09-17
Summary: Missing check for duplicate inputs
Fix Deployment: 31%

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | 0.14.0rc1 - 0.14.20.15.0rc1 - 0.15.10.16.0rc1 - 0.16.2 | 0.14.30.15.20.16.3 |

### References

* [Full disclosure by Bitcoin Core](https://bitcoincore.org/en/2018/09/20/notice/)
* [Bitcoin Core 0.16.3 release notes](https://bitcoincore.org/en/2018/09/18/release-0.16.3/)
* [Bitcoin Knots 0.16.3.knots20180918 release notes](https://github.com/bitcoinknots/bitcoin/blob/v0.16.3.knots20180918/doc/release-notes.md)
* [US-CERT/NIST](https://nvd.nist.gov/vuln/detail/CVE-2018-17144)
* [Gentoo bug](https://bugs.gentoo.org/show_bug.cgi?id=666669)

## CVE-2018-20586

```
Date: 2019-06-22
Summary: Debug log injection via unauthenticated RPC

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin-Qtbitcoind | 0.12.0rc1 - 0.17.0 | 0.17.1rc1 |

## CVE-2020-14199

```
Date: 2020-06-03
Summary: Double-signing can enable unintended fees

```

| Affected | | Fix |
| --- | --- | --- |
| Trezor One |  | 1.9.1 |
| Trezor Model T |  | 2.3.1 |
| ??? |

### References

* [Disclosure of details by Trezor team](https://blog.trezor.io/details-of-firmware-updates-for-trezor-one-version-1-9-1-and-trezor-model-t-version-2-3-1-1eba8f60f2dd)

## CVE-2020-26895

```
Date: 2020-10-08
Summary: Missing low-S normalization for HTLC signatures.

```

| Affected | | Fix |
| --- | --- | --- |
| lnd |  | 0.10.0 |

### References

* [CVE-2020-26895: LND Low-S Tx-Relay Standardness](https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-October/002858.html)
* [Full Disclosure: Full Disclosure: CVE-2020-26895 LND "Hodl my Shitsig"](https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-October/002856.html)

## CVE-2020-26896

```
Date: 2020-10-08
Summary: Invoice preimage extraction via forwarded HTLC.

```

| Affected | | Fix |
| --- | --- | --- |
| lnd |  | 0.11.0 |

### References

* [CVE-2020-26896: LND Invoice Preimage Extraction](https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-October/002857.html)
* [Full Disclosure: CVE-2020-26896 LND "The (un)covert channel"](https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-October/002855.html)

## CVE-2021-3401

```
Date: 2021-02-01
Summary: Qt5 remote execution

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin Core GUI |  | 0.19.0 |
| Bitcoin Knots GUI |  | 0.18.1 |

## CVE-2021-31876

```
Date: 2021-05-06

```
### References

* [Full Disclosure: CVE-2021-31876 Defect in Bitcoin Core's bip125 logic](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-May/018893.html)

### References

* [URI Argument Injection Vulnerability in Bitcoin Core 0.18 and Earlier](https://achow101.com/2021/02/0.18-uri-vuln)

## CVE-2023-50428

```
Date: 2023
Summary: Bypass of datacarriersize limit using OP_FALSE,OP_IF

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin Core | 0.9 and later | NOT FIXED |
| Bitcoin Knots | 0.9 - 23.0 | 25.1.knots20231115 |
| btcd | ? | NOT FIXED |
| libbitcoin | ? | NOT FIXED |

## CVE-2024-34149

```
Date: 2024-03-30
Summary: Script size limit not enforced for Tapscript

```

| Affected | | Fix |
| --- | --- | --- |
| Bitcoin Core | 0.21.1 and later | NOT FIXED |
| Bitcoin Knots | 0.21.1 - 23.0 | 25.1.knots20231115 |
| btcd | ? | ? |
| libbitcoin | ? | ? |

## Definitions

A critical vulnerability is one that will have disastrous consequences if it is exploited. A serious vulnerability is one that will have serious consequences if it is exploited[[1]](#cite_note-16).

## See Also

* [Changelog](/wiki/Changelog "Changelog")
* <https://blog.bitmex.com/bitcoins-consensus-forks/>

## References

1. [↑](#cite_ref-16) <http://bitcointalk.org/index.php?topic=88892.0>

| | [Bitcoin Core](/wiki/Bitcoin_Core "Bitcoin Core") documentation | | | --- | --- | |  | | User documentation | [Alert system](/wiki/Alert_system "Alert system") • [Bitcoin Core compatible devices](/wiki/Bitcoin_Core_compatible_devices "Bitcoin Core compatible devices") • [Data directory](/wiki/Data_directory "Data directory") • [Fallback Nodes](/wiki/Fallback_Nodes "Fallback Nodes") • [How to import private keys in Bitcoin Core 0.7+](/wiki/Help%3AHow_to_import_private_keys_in_Bitcoin_Core_0.7%2B "Help:How to import private keys in Bitcoin Core 0.7+") • [Installing Bitcoin Core](/wiki/Help%3AInstalling_Bitcoin_Core "Help:Installing Bitcoin Core") • [Running Bitcoin](/wiki/Running_Bitcoin "Running Bitcoin") • [Transaction fees](/wiki/Transaction_fees "Transaction fees") • [Vocabulary](/wiki/Vocabulary "Vocabulary") | |  | | Developer documentation | [Accounts explained](/wiki/Help%3AAccounts_explained "Help:Accounts explained") • [API calls list](/wiki/Original_Bitcoin_client/API_calls_list "Original Bitcoin client/API calls list") • [API reference (JSON-RPC)](/wiki/API_reference_%28JSON-RPC%29 "API reference (JSON-RPC)") • [Block chain download](/wiki/Block_chain_download "Block chain download") • [Dump format](/wiki/Dump_format "Dump format") • [getblocktemplate](/wiki/Getblocktemplate "Getblocktemplate") • [List of address prefixes](/wiki/List_of_address_prefixes "List of address prefixes") • [Protocol documentation](/wiki/Protocol_documentation "Protocol documentation") • [Script](/wiki/Script "Script") • [Technical background of version 1 Bitcoin addresses](/wiki/Technical_background_of_version_1_Bitcoin_addresses "Technical background of version 1 Bitcoin addresses") • [Testnet](/wiki/Testnet "Testnet") • [Transaction Malleability](/wiki/Transaction_Malleability "Transaction Malleability") • [Wallet import format](/wiki/Wallet_import_format "Wallet import format") | |  | | History & theory | Common Vulnerabilities and Exposures • [DOS/STONED incident](/wiki/DOS/STONED_incident "DOS/STONED incident") • [Economic majority](/wiki/Economic_majority "Economic majority") • [Full node](/wiki/Full_node "Full node") • [Original Bitcoin client](/wiki/Original_Bitcoin_client "Original Bitcoin client") • [Value overflow incident](/wiki/Value_overflow_incident "Value overflow incident") | |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

Retrieved from "<https://en.bitcoin.it/w/index.php?title=Common_Vulnerabilities_and_Exposures&oldid=70310>"
[Categories](/wiki/Special%3ACategories "Special:Categories"):

* [Security](/wiki/Category%3ASecurity "Category:Security")
* [Bitcoin Core documentation](/wiki/Category%3ABitcoin_Core_documentation "Category:Bitcoin Core documentation")

## Navigation menu

### Personal tools

* [Create account](/w/index.php?title=Special:CreateAccount&returnto=Common+Vulnerabilities+and+Exposures "You are encouraged to create an account and log in; however, it is not mandatory")
* [Log in](/w/index.php?title=Special:UserLogin&returnto=Common+Vulnerabilities+and+Exposures "You are encouraged to log in; however, it is not mandatory [o]")

### Namespaces

* [Page](/wiki/Common_Vulnerabilities_and_Exposures "View the content page [c]")
* [Discussion](/wiki/Talk%3ACommon_Vulnerabilities_and_Exposures "Discussion about the content page [t]")

English

### Views

* [Read](/wiki/Common_Vulnerabilities_and_Exposures)
* [View source](/w/index.php?title=Common_Vulnerabilities_and_Exposures&action=edit "This page is protected.
  You can view its source [e]")
* [View history](/w/index.php?title=Common_Vulnerabilities_and_Exposures&action=history "Past revisions of this page [h]")

More

### Search

### Navigation

* [Main page](/wiki/Main_Page "Visit the main page [z]")
* [Bitcoin FAQ](/wiki/Help%3AFAQ)
* [Editing help](/wiki/Bitcoin_Wiki%3AHelp)
* [Forums](/wiki/Forums)
* [Chatrooms](/wiki/IRC_channels)
* [Recent changes](/wiki/Special%3ARecentChanges)
* [Page index](/wiki/Special%3AAllPages)

### Tools

* [What links here](/wiki/Special%3AWhatLinksHere/Common_Vulnerabilities_and_Exposures "A list of all wiki pages that link here [j]")
* [Related changes](/wiki/Special%3ARecentChangesLinked/Common_Vulnerabilities_and_Exposures "Recent changes in pages linked from this page [k]")
* [Special pages](/wiki/Special%3ASpecialPages "A list of all special pages [q]")
* Printable version
* [Permanent link](/w/index.php?title=Common_Vulnerabilities_and_Exposures&oldid=70310 "Permanent link to this revision of this page")
* [Page information](/w/index.php?title=Common_Vulnerabilities_and_Exposures&action=info "More information about this page")

### Sister projects

* [Essays](/wiki/Bitcoin_Wiki%3AEssay_main_page)
* [Source](/wiki/Bitcoin_Wiki%3ASource_main_page)

* This page was last edited on 31 July 2024, at 17:40.
* Content is available under [Creative Commons Attribution 3.0](http://creativecommons.org/licenses/by/3.0/) unless otherwise noted.

* [Privacy policy](/wiki/Bitcoin_Wiki%3APrivacy_policy)
* [About Bitcoin Wiki](/wiki/Bitcoin_Wiki%3AAbout)
* [Disclaimers](/wiki/Bitcoin_Wiki%3AGeneral_disclaimer)

* [![Powered by MediaWiki](/w/resources/assets/poweredby_mediawiki_88x31.png)](https://www.mediawiki.org/)



=== Content from lists.linuxfoundation.org_1d9aa9c3_20250125_044846.html ===

```
[public inbox for bitcoindev@googlegroups.com](../?t=20190225192936)
 [help](../_/text/help/) / [color](../_/text/color/) / [mirror](../_/text/mirror/) / [Atom feed](../new.atom)
```
```
From: Suhas Daftuar <sdaftuar@gmail•com>
To: Bitcoin Dev <bitcoin-dev@lists•linuxfoundation.org>
Subject: [[bitcoin-dev] Vulnerability relating to 64-byte transactions in Bitcoin Core 0.13 branch](#r)
Date: Mon, 25 Feb 2019 14:29:21 -0500	[[thread overview]](#r)
Message-ID: <CAFp6fsGtEm9p-ZQF_XqfqyQGzZK7BS2SNp2z680QBsJiFDraEA@mail.gmail.com> (<raw>)

[[-- Attachment #1.1: Type: text/plain, Size: 3764 bytes --]](1.1-a.txt)

Hi,

I'm writing to report a consensus vulnerability affecting Bitcoin Core
versions
0.13.0, 0.13.1, and 0.13.2.  These software versions reached end-of-life on
2018-08-01.

The issue surrounds a fundamental design flaw in Bitcoin's Merkle tree
construction.  Last year, the vulnerability (CVE-2017-12842) around 64-byte
transactions being used to trick light clients into thinking that a
transaction
was committed in a block was discussed on this mailing list
(
<https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-June/016091.html>
).
There is a related attack resulting from the ambiguity around 64-byte
transactions which could be used to cause a vulnerable full-node
implementation
to fall out of consensus.

The attack on light clients discussed previously was centered on the idea of
claiming the Merkle tree has one more level in it than it actually has, to
prove that a candidate transaction is in the chain by having its hash match
one
side of a 64-byte transaction. The vulnerability I am describing here
involves
going the other direction: find a row of interior nodes in the Merkle tree
that successfully deserialize as transactions, in order to make a block
appear
to be invalid. (This is of a similar character to the attack described by
Sergio Demian Lerner on
<https://bitslog.wordpress.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/>
,
in the section titled "An (expensive) attack to partition Bitcoin".)

It has long been recognized that malleating a block's transactions in a way
that produces the same Merkle root could be used to cause a node to fall
out of
consensus, because of the logic in Bitcoin Core to cache the invalidity of
blocks (ie to avoid re-validation of known-invalid ones, which would
otherwise
make the software vulnerable to DoS). Malleation by "going up" the Merkle
tree,
and claiming that some interior row is in fact the set of (64-byte)
transactions in a block, could be used to cause the Bitcoin Core 0.13
branch to
incorrectly mark as invalid a block that in fact has a valid set of
transactions. Moreover, this requires very little work to accomplish -- less
than 22 bits of work in all.

I have attached a writeup that I put together for my own memory and notes
which
goes into more detail (along with a summary of other Merkle tree issues,
including the duplicate transactions issue from CVE-2012-2459 and the SPV
issue); please see sections 3.1 and 4.1 for a discussion.  The bug in 0.13
was
introduced as an unintended side-effect of a change I authored
(<https://github.com/bitcoin/bitcoin/pull/7225>).  Once I learned of this
category of Merkle malleation issues, I realized that the change
inadvertently
introduced a vulnerability to this issue that did not previously exist (in
any
prior version of the software, as far as I can tell).  A bug fix that
effectively reverted the change (
<https://github.com/bitcoin/bitcoin/pull/9765>)
was made just before the 0.14 version of Bitcoin Core was released, and no
later versions of the software are affected.

Also, I have scanned the blockchain looking for instances where the first
two
hashes in any row of the Merkle tree would deserialize validly as a 64-byte
transaction, and I have found zero such instances.  So in particular there
are
no blocks on Bitcoin's main chain (as of this writing) that could be used to
attack an 0.13 node.

I thought it best to withhold disclosure of this vulnerability before a
mitigation was in place for the related SPV-issue (which I assumed would
become
obvious with this disclosure); once that became public last summer and a
mitigation deployed (by making 64-byte transactions nonstandard), that
concern
was eliminated.

Thanks to Johnson Lau and Greg Maxwell for originally alerting me to this
issue.

[[-- Attachment #1.2: Type: text/html, Size: 4838 bytes --]](1.2-a.bin)

[[-- Attachment #2: BitcoinMerkle.pdf --]
[-- Type: application/pdf, Size: 200880 bytes --]](2-BitcoinMerkle.pdf)

```

---

```
                 [reply](#R)	other threads:[[~2019-02-25 19:29 UTC](../?t=20190225192936)|[newest](../)]

Thread overview: [no followups] expand[[flat](T/#u)|[nested](t/#u)]  [mbox.gz](t.mbox.gz)  [Atom feed](t.atom)

```

---

```
Reply instructions:

You may reply publicly to [this message](#t) via plain-text email
using any one of the following methods:

* Save the following mbox file, import it into your mail client,
  and reply-to-all from there: [mbox](raw)

  Avoid top-posting and favor interleaved quoting:
  <https://en.wikipedia.org/wiki/Posting_style#Interleaved_style>

* Reply using the --to, --cc, and --in-reply-to
  switches of git-send-email(1):

  git send-email \
    --in-reply-to=CAFp6fsGtEm9p-ZQF_XqfqyQGzZK7BS2SNp2z680QBsJiFDraEA@mail.gmail.com \
    --to=sdaftuar@gmail$(echo .)com \
    --cc=bitcoin-dev@lists$(echo .)linuxfoundation.org \
    /path/to/YOUR_REPLY

  <https://kernel.org/pub/software/scm/git/docs/git-send-email.html>

```
Be sure your reply has a **Subject:** header at the top and a blank line
before the message body.

---

```
This is a public inbox, see [mirroring instructions](../_/text/mirror/)
for how to clone and mirror all data and code used for this inbox
```


=== Content from bitslog.wordpress.com_f3818424_20250125_044842.html ===


 Words on Bitcoin Design, Privacy, Security and Crypto, by Sergio Demian Lerner
# [Bitslog](https://bitslog.com)

* [Home](https://bitslog.com/)
* [About](https://bitslog.com/about/)
* [Blog Index](https://bitslog.com/blog-index/)
* [Contributions to Bitcoin and the cryptocurrency field](https://bitslog.com/contributions-to-bitcoin-and-the-cryptocurrency-field/)
* [HC Family of Block Cipher modes](https://bitslog.com/hc-family-of-block-cipher-modes/)

« [Blockchain State Storage Rent Revised](https://bitslog.com/2018/01/22/storage-rent-revised/)
[Simple change to the Bitcoin MERKLEBLOCK command to protect from Leaf-Node weakness in Transaction Merkle Tree](https://bitslog.com/2018/08/21/simple-change-to-the-bitcoin-merkleblock-command-to-protect-from-leaf-node-weakness-in-transaction-merkle-tree/) »

## Leaf-Node weakness in Bitcoin Merkle Tree Design

This document describes a weakness in Bitcoin Design that reduces the security of SPV proofs and therefore SPV Wallets.  The weakness was discovered by me on August 2017, but during the responsable disclosure process I learnt it was previously known by some prominent members of the Bitcoin Core team. Using this weakness an attacker can create a valid SPV proof for a fake payment to a victim that is using a SPV wallet, the payment amount being an arbitrary number of bitcoins, and trick the victim into accepting this payment as valid.  Happily, exploiting this bug requires brute-forcing between 69 and 73 bits (depending on initial investment), each operation being a double SHA2, and there are very simple probabilistic protections that SPV wallets can implement easily. For example, an attack can be carried on with an investment of 3M USD (\*). It is assumed that most SPV wallets will be vulnerable to this attack. Also vulnerable are automated systems that accept SPV proofs (such as the Blockstream Elements sidechain in non-federated mode and the RSK Bridge contract). A simple patch which it neither a soft nor a hard fork can prevent the attack described. Also, a second attack that forks the Bitcoin blockchain is presented, requiring the brute-forcing of 225 bits, so it’s only of theoretical interest.

**The Problem**

Bitcoin Merkle tree makes no distinction between inner nodes and leaf nodes. The depth of the tree is implicitly given by the number of transactions. Inner nodes have no specific format, and are 64 bytes in length. Therefore, an attacker can submit to the blockchain a transaction that has exactly 64 bytes in length and then force a victim system to re-interpret this transaction as an inner node of the tree. An attacker can therefore provide an SPV proof (a Merkle branch) that adds an additional leaf node extending the dual transaction/node and provide proof of payment of any transaction he wishes.

It must be noted that a problem reciprocal to this was identified by Andrew Miller [1]. He realized that internal nodes could be re-interpreted as transactions, but it seems he didn’t publish (or didn’t discover) the opposite attack: transactions re-interpreted as nodes. Note that for the coinbase transaction this weakness is not present: getting a coinbase transaction to be interpreted as a hash of two transactions requires brute-forcing at least 216 bits (so it’s unfeasible, unlike the weakness presented in this post).

**Crafting a Transaction-node in 2^72 operations**

The following diagram shows a 64-byte Bitcoin transaction, and how this transaction is split into two 32-byte chunks.

| **Absolute Offs** | **32-Byte chunk** | **32-byte offs** | **Size** | **Description** | **Brute force bits (stage)** |
| --- | --- | --- | --- | --- | --- |
| 0 | 1 | 0 | 4 | Version | 0 |
| 4 | 1 | 4 | 1 | Input count | 0 |
| 5 | 1 | 5 | 27 | Input 0 Tx hash (part 1) | 0 |
| 32 | 2 | 0 | 5 | Input 0 Tx hash (part 2) | 40 (2) |
| 37 | 2 | 5 | 4 | Input 0 Txout index | 17 of 32 (1) |
| 41 | 2 | 9 | 1 | Input 0 script length | 8 (1) |
| 42 | 2 | 10 | 0 | Empty Script | 0 |
| 42 | 2 | 10 | 4 | nSequence | 0 (anything allowed) |
| 46 | 2 | 14 | 1 | Output count | 8 (1) |
| 47 | 2 | 15 | 8 | value | 29 of 64 (1) |
| 55 | 2 | 23 | 1 | Output 0 script length | 8 (1) |
| 56 | 2 | 24 | 4 | Output 0 scriptPubKey | 0 (anything allowed) |
| 60 | 2 | 28 | 4 | lock\_time | 2 of 32  (1) |
|  |  |  |  |  | Total (1) = 72 Total (2) = 40 |

Let the transaction to become an inner node be T.  Let R be the new fake transaction that the attacker wants to build as T’s right child. As the victim is an SPV node, then the SPV proof will require the left 32 bytes of T as the complementary hash as part of the Merkle proof. Luckily, the attacker is free to provide any 32-bytes to the victim.

From now on, we assume that the attacker is a Bitcoin miner, and he owns 2^36-1 satoshis (= 687 BTC or about 5M USD as of June-2018) in a single UTXO A. The attack requires two stages, executing a different brute-force procedure in each.

**Stage 1 Brute-forcing procedure**

The attacker focuses on the second half of T. He wishes to build a transaction whose double-hash matches this second half. To be a valid Bitcoin transaction, some fields of the second half of T must have specific values. Those parts must be “brute-forced”, meaning that the attacker would need to try many transactions R until he finds one matching the desired patterns in T. Some other parts of T are free for the attacker to choose. Still some other parts of T are partially free, and they will be restricted according to other parts of T. Let’s analyze which parts of T need brute-forcing.

We will temporarily forget about the 5 bytes of the **input 0 transaction hash** that overlap the second half of T and we’ll let anything fill this part. Later, in a second brute-forcing stage, we’ll find a transaction that matches this tail.

The **nSequence** field can contain anything.

The **LockTime** field is partially brute-forced: the attacker makes sure the brute-forced uint32 is between 500000000 and 1501843940 (today as a Unix timestamp) or between 0 and 479042 (the current block height). This implies that the LockTime has elapsed. The combined numerical range amplitude is 1002322982, which is close to 230. Therefore, he only needs to brute-force 2 bits of the LockTime.

The higher bits of the Previn **transaction output index** must be 0 so the index is always less than 32768. Since the field is 32-bits in length, the 17 most significant bits must be brute-forced.

The transaction **output amount**  is only partially brute-forced. From the 64 field bits, 35 bits can be chosen freely because the attacker has 2^36-1 satoshis, so 35 free bits can represent any number lower than the amount.  The remaining  29 most significant bits must be zero and should be brute-forced. If the attacker has more BTC, he can reduce the number of bits to brute-force by consuming more BTC in A.

Note that the amount paid is not lost: the transaction T pays to a anyone-can-spend address but  the miner can immediately consume that output and move the funds to a safe address he owns. Also he will be collecting any transaction fees offered by the transaction T as T doesn’t have enough space to include a change output. The attacker can recover all the funds but creating the anyone-can-spend output and a high-fee transaction T will put the attacker in the risk of being himself victim of a fee-sniping attack: the possibility that another miner reverts the blockchain to mine a competing block including the transaction T to collect both fee or output amount in T. The attacker may need to mine several blocks in private (selfish-mining) to prevent the fee-sniping attack.

The input scriptSig can be a script of length up to 4 bytes, but it must contain a valid opcodes so that it can verify the scriptSig of the input (as. T is a valid Bitcoin transaction). The attacker will be able to shape this scriptSig as he wishes to make both scripts correct. Probably the best option reduce brute-forcing needs is to make it 4 bytes in length, and contain any mix of valid opcodes. Since the stack can contain elements inserted by the associated scriptPub, most opcodes will be valid. We will assume that one every 8  random list of 4 of bytes will result in valid script, so only 3 bits of brute-forcing will be needed.

The output scriptPub can be a script of length up to 4 bytes, but it must contain a valid anyone-can-spend script. Probably the best option to reduce brute-forcing is to leave this script empty, as a non-empty scriptSig would need to start with a small subset of push opcodes, because the script stack is empty when the scriptSig is executed.

**Creating the Fake Transaction R**

The attacker will try to create a fake transaction R whose transaction ID matches the right half of T and use this fake transaction to cheat a victim. An easy way to do it is to create a fake transaction having one output for the fake payment to the victim, and scan all possible values for the lock\_time field until the transaction ID matches the second half of T. When the lock\_time field space is exhausted, the input script can be slightly modified and a new 32-bit space of lock\_time values is created. Again, an AsicBoost-like technique can be used to save one message-scheduler of the double-SHA2 operation.

The total number of bits to brute-force is therefore 72 bits. However, since the scriptSig and scriptPub

**Stage 2 brute-forcing procedure**

Now we must solve the problem of the 5 random bytes of the input transaction hash that were chosen by the first state.  We note that the first stage also produces a random transaction output index for this input. Let Q be the transaction output index randomly chosen in the first stage. The attacker creates a huge number of transactions W(i) consuming the input A and having Q outputs each. He aims to find W(j) whose ID tail matches the 5 bytes tail mentioned before. The last output of W(j) will be consumed by T.

The procedure to find W(j) is similar to the one used in stage 1. The attacker makes small changes to the tail of the transactions W(i) and re-hashes to obtain the ID, therefore creating new transaction IDs requires only two SHA-2 compressions (one to finalize the transaction hash and the double-hash). The lock\_field can be used to iterate fast. The attacker tries to find a transaction whose transaction ID end in the 5-bytes tail chosen in the first stage. Let’s call this transaction W(j) simply P. This transaction consumes an output controlled by the attacker having A funds. Since 5 bytes must be matches, approximately 2^40 operations will need to be performed to find P.  An AsicBoost-like technique can be used to save one message-scheduler of the double-SHA2 operation.

The total number of bits to brute-force in the second stage is therefore 40 bits.

Interestingly, the brute-forced half of the transaction created in the first stage can be reused as many times if the second stage is re-done. The attacks can be carried out at different times, in different blocks. Therefore, after a successful first attack the following attacks require only brute-forcing 40 bit each. If the number of outputs in P is 33K, the amortized cost of the attack corresponds approximately to brute-forcing only 65 bits. A final transaction E is added in the same block to consume the output of T and recover the funds at risk.

![c1.PNG](https://bitslog.com/wp-content/uploads/2018/06/c1.png?w=541&h=222)

Fig 1. Chain of transactions in attacker’s block

![C2.PNG](https://bitslog.com/wp-content/uploads/2018/06/c2.png?w=508&h=357)

Fig 2. Merkle Tree of the Block containing the fake transaction R

**The Cost of the Attack**

The technology required to build a custom ASIC that performs the brute-forcing of the second stage is very similar to the technology used for Bitcoin miners.

A state-of-the-art Bitcoin miner reaches 14 TH/s and costs $1300 USD. An attacker that buys 1000 units, investing 1.3M USD in hardware, can scan a 72-bit space in 4 days. An additional 1M-10M USD for ASIC chip design and tape-out may be required, depending on the node density. If a chip that can accomplish a programmed pattern match search (instead of zero prefix search) already exists, the design/tapeout costs are saved.

Mining several blocks in private to confirm the fake transaction may be needed to prevent the other miners from reorganizing the blockchain in order to steal the fees and output of transaction T. If the attacker is not in collusion with 51% of the miners, then this may cost the attacker millions in rented hashing power, if available. If the attacker is colluding with 51% of the miners there is no additional cost.

Therefore, under favorable conditions to the attacker, the attack can be profitable if the attacker can cheat one or more users for 1.3M USD or more in total. As any rational actor receiving large amount of BTC will double-check the reception using a full node, only autonomous systems relying on SPV proofs (such as the Elements blockchain and the RSK bridge) may suffer from these attacks.

The attack presented in this document is not optimal: there are several trade-offs than can be made to reduce the number of bits to brute-force increasing other variables, such as initial investment. Locking twice the money in A allows the attacker to reduce the cost in mining hardware to a half, etc.

**An (expensive) attack to partition Bitcoin**

The same vulnerability allows an attacker to fork the Bitcoin blockchain in two without reconciliation, however this attack costs 2^240 double SHA2 operations, so the attack is impractical. The attack requires the attacker to mine a block A with only one specially crafted coinbase transaction of 64 bytes, and create a competing block B with 2 transactions where the pair of transactions IDs in B hashes to the coinbase transaction in A. Both blocks are broadcast simultaneously to different parts of the Bitcoin network. Therefore approximately 50% of the network receives A and the other 50%, B. The two sets of transactions in A and B are created so that they consume different UTXOs and/or create different UTXOs, and therefore both blockchains are valid, but incompatible.

The fact that the first transaction is the coinbase transaction, and a coinbase transaction requires 27 zero bytes and 1 fixed byte in the first 32 bytes, makes the attack practically unfeasible, as it requires brute-forcing 225 bits.

**Remedy**

There is no need to hard-fork or soft-fork Bitcoin, although a future programmed soft-fork or hard-fork could fix this vulnerability.  We propose two non-forking solutions and three forking solutions.

One easy non-forking remedy is that SPV wallets check that every internal 64-bit node of the SPV proof is not a valid transaction. First, there are no 64-byte Bitcoin transaction that pass standard-checks, so the presence of such transaction should rise an alarm. Even if such transactions were normal, the probability of a random 64-byte chunk to become a syntactically valid Bitcoin transaction is close to 2^-56. Therefore, the SPV client can flag the presence of such dual transaction-node as an attack, and refuse to accept the SPV proof.

Another way to fix SPV wallets is to require, along with a Merkle-proof of the inclusion of a transaction E, a Merkle proof for the coinbase transaction. Because building a dual transaction-node for the coinbase transaction requires brute-forcing 225 bits, showing a valid coinbase and its corresponding Merkle inclusion proof is enough to discover the tree height. Both the E branch and the coinbase branch should have equal tree depths.

This method has a drawback: the coinbase transaction may be large, so the method requires non-logarithmic space. If the coinbase transaction is larger than 64 bytes, we could show as evidence only the last a SHA2 mid-state of the first SHA2 application to the coinbase transaction and the transaction length in bytes: with these two field the coinbase id can be reconstructed, because SHA2 embeds the bit-length in the last message block. This allows the verified to effectively differentiate between a 64-byte node and the coinbase transaction. The security of this constructions is weaker and relies on the infeasibility to find free-start SHA2 pre-images. To complicate things, it is still possible (for the next 145 years) that a malicious miner includes a coinbase having exactly 64 bytes.  Therefore, the SPV client must also perform a special check in case the coinbase is exactly 64 bytes in length: in this case it must verify that the previn field contains 256 zero bits (of which 216 are stored in the left half). It’s currently infeasible to obtain a pre-image of a hash digest having 216 zero trailing bits.

Yet another solution that keeps the logarithmic-space constrain for Merkle-proofs is to present an inclusion proof for the right-most transaction ID. In case the number of transactions is not a power of 2 (a full tree), this id appears duplicated at the last two nodes of the tree, so that the tree height can be inferred. A complete solution would require soft-forking Bitcoin to prevent blocks having a full tree, which is nasty.

To summarize, the most space-efficient solution without a soft-fork would be hybrid: show inclusion proof of the rightmost tx id branch if the tree is not full, else the coinbase (showing mid-state and length) if length is greater than 64 bytes, or else show the full coinbase transaction.

A simple soft-forking solution is to invalidate blocks having transactions of size equal to 64.

Another soft-forking solution is to require that a new field “depth” requiring 4 bits is embedded in the block version field. This new fields should specify the Merkle tree depth minus one. By using 4 bits, a a tree of depth 16, containing up to 65K transactions can be specified. Full nodes much check that the actual tree depth matches the value of “depth” given. SPV nodes can check that the “depth” field matches the Merkle branch length received.

A hard-forking solution is adding a prefix to internal nodes of the Merkle tree before performing node hashing and adding a different prefix to transaction IDs and then also hash them. Ripple ([2]) uses a such a prefix system.

**Thanks**

Special thanks to Juliano Rizzo and Matias Marquez from RSK Labs R&D for helping me reduce the attack complexity. Also to Gregory Maxwell for discussing the best way to correct this problem.

(\*) The amounts in USD described in this document were computed at when the weakness was discovered and now they may differ significantly.

[1] <https://cs.umd.edu/~amiller/BTCRelayAudit.pdf>

[2] <https://wiki.ripple.com/Hash_Tree>

**History**

Finding Date: August 4th, 2017 (identified as CVE-2017-12842).

Bitcoin Core Report Contact Date:  August 8th, 2017 (from the interactions we learnt that is was already known to some Core developers)

Publication Date: June 9th, 2018 (triggered from the exposure of the weakness in the Bitcoin mailing list)

June 13th, 2018: Luke Dashjr contacted me and told me he already knew about this weakness. I trust Luke’s word that this is the case, and as I said in the first paragraph, the weakness was already known by some developers. But I still don’t understand (1) why so many people knew about it  but underestimated it badly, (2) why there was no attempt to fix it.

May 12, 2023: The blog post was edited to fix many typos and make it clearer, without changing the ideas or procedures presented.

Author: Sergio Demian Lerner, RSK Labs

### Share this:

* [Twitter](https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/?share=twitter "Click to share on Twitter")
* [Facebook](https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/?share=facebook "Click to share on Facebook")
Like Loading...
### *Related*

This entry was posted on June 9, 2018, 8:00 pm and is filed under [Uncategorized](https://bitslog.com/category/uncategorized/). You can follow any responses to this entry through [RSS 2.0](https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/feed/ "RSS 2.0").
You can [leave a response](#respond), or [trackback](https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/trackback/) from your own site.

* [Comments (0)](#comments)

1. Leave a comment

### Leave a comment [Cancel reply](/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/#respond)

Δ

* ## Recent Posts

  + [Merged mining (Part I)](https://bitslog.com/2022/11/22/merged-mining-part-i/)
  + [The Dark Side of Ethereum 1/64th CALL Gas Reduction](https://bitslog.com/2021/06/10/the-dark-side-of-ethereum-1-64th-call-gas-reduction/)
  + [2021](https://bitslog.com/2021/06/10/2021/)
  + [Re-mining Patoshi Blocks for Dummies](https://bitslog.com/2020/09/03/re-mining-patoshi-blocks-for-dummies/)
  + [The Patoshi Mining Machine](https://bitslog.com/2020/08/22/the-patoshi-mining-machine/)
* ## Recent Comments

  |  | [SDLerner](https://bitslog.wordpress.com) on [A New Mystery in Patoshi …](https://bitslog.com/2020/06/22/a-new-mystery-in-patoshi-timestamps/#comment-59299) |
  | --- | --- |
  |  | TechMiX on [The Patoshi Mining Machin…](https://bitslog.com/2020/08/22/the-patoshi-mining-machine/#comment-59034) |
  |  | [SDLerner](https://bitslog.wordpress.com) on [A New Mystery in Patoshi …](https://bitslog.com/2020/06/22/a-new-mystery-in-patoshi-timestamps/#comment-57463) |
  |  | Jeremy Davis on [A New Mystery in Patoshi …](https://bitslog.com/2020/06/22/a-new-mystery-in-patoshi-timestamps/#comment-57451) |
  |  | TechMiX on [A New Mystery in Patoshi …](https://bitslog.com/2020/06/22/a-new-mystery-in-patoshi-timestamps/#comment-57441) |
* ## Archives

  + [November 2022](https://bitslog.com/2022/11/)
  + [June 2021](https://bitslog.com/2021/06/)
  + [September 2020](https://bitslog.com/2020/09/)
  + [August 2020](https://bitslog.com/2020/08/)
  + [June 2020](https://bitslog.com/2020/06/)
  + [August 2019](https://bitslog.com/2019/08/)
  + [April 2019](https://bitslog.com/2019/04/)
  + [August 2018](https://bitslog.com/2018/08/)
  + [June 2018](https://bitslog.com/2018/06/)
  + [January 2018](https://bitslog.com/2018/01/)
  + [April 2017](https://bitslog.com/2017/04/)
  + [January 2017](https://bitslog.com/2017/01/)
  + [October 2016](https://bitslog.com/2016/10/)
  + [April 2016](https://bitslog.com/2016/04/)
  + [January 2016](https://bitslog.com/2016/01/)
  + [September 2015](https://bitslog.com/2015/09/)
  + [August 2015](https://bitslog.com/2015/08/)
  + [March 2015](https://bitslog.com/2015/03/)
  + [February 2015](https://bitslog.com/2015/02/)
  + [November 2014](https://bitslog.com/2014/11/)
  + [October 2014](https://bitslog.com/2014/10/)
  + [July 2014](https://bitslog.com/2014/07/)
  + [June 2014](https://bitslog.com/2014/06/)
  + [May 2014](https://bitslog.com/2014/05/)
  + [April 2014](https://bitslog.com/2014/04/)
  + [March 2014](https://bitslog.com/2014/03/)
  + [February 2014](https://bitslog.com/2014/02/)
  + [January 2014](https://bitslog.com/2014/01/)
  + [December 2013](https://bitslog.com/2013/12/)
  + [November 2013](https://bitslog.com/2013/11/)
  + [October 2013](https://bitslog.com/2013/10/)
  + [September 2013](https://bitslog.com/2013/09/)
  + [July 2013](https://bitslog.com/2013/07/)
  + [June 2013](https://bitslog.com/2013/06/)
  + [May 2013](https://bitslog.com/2013/05/)
  + [April 2013](https://bitslog.com/2013/04/)
  + [March 2013](https://bitslog.com/2013/03/)
  + [February 2013](https://bitslog.com/2013/02/)
  + [January 2013](https://bitslog.com/2013/01/)
  + [November 2012](https://bitslog.com/2012/11/)
  + [August 2012](https://bitslog.com/2012/08/)
  + [July 2012](https://bitslog.com/2012/07/)
  + [April 2012](https://bitslog.com/2012/04/)
  + [December 2011](https://bitslog.com/2011/12/)
  + [October 2011](https://bitslog.com/2011/10/)
  + [September 2011](https://bitslog.com/2011/09/)
  + [August 2011](https://bitslog.com/2011/08/)
* ## Categories

  + [Uncategorized](https://bitslog.com/category/uncategorized/)
* ## Meta

  + [Register](https://wordpress.com/start?ref=wplogin)
  + [Log in](https://bitslog.wordpress.com/wp-login.php)
  + [Entries feed](https://bitslog.com/feed/)
  + [Comments feed](https://bitslog.com/comments/feed/)
  + [WordPress.com](https://wordpress.com/ "Powered by WordPress, state-of-the-art semantic personal publishing platform.")

[Blog at WordPress.com.](https://wordpress.com/?ref=footer_blog)

* [Comment](https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/#respond)
* Reblog
* Subscribe
  Subscribed

  + [![](https://s2.wp.com/i/logo/wpcom-gray-white.png) Bitslog](https://bitslog.com)

  Join 116 other subscribers

  Sign me up

  + Already have a WordPress.com account? [Log in now.](https://wordpress.com/log-in?redirect_to=https%3A%2F%2Fr-login.wordpress.com%2Fremote-login.php%3Faction%3Dlink%26back%3Dhttps%253A%252F%252Fbitslog.com%252F2018%252F06%252F09%252Fleaf-node-weakness-in-bitcoin-merkle-tree-design%252F)
* Privacy
* + [![](https://s2.wp.com/i/logo/wpcom-gray-white.png) Bitslog](https://bitslog.com)
  + Subscribe
    Subscribed
  + [Sign up](https://wordpress.com/start/)
  + [Log in](https://wordpress.com/log-in?redirect_to=https%3A%2F%2Fr-login.wordpress.com%2Fremote-login.php%3Faction%3Dlink%26back%3Dhttps%253A%252F%252Fbitslog.com%252F2018%252F06%252F09%252Fleaf-node-weakness-in-bitcoin-merkle-tree-design%252F)
  + [Copy shortlink](https://wp.me/p1Ldar-wc)
  + [Report this content](https://wordpress.com/abuse/?report_url=https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/)
  + [View post in Reader](https://wordpress.com/read/blogs/26028371/posts/1996)
  + [Manage subscriptions](https://subscribe.wordpress.com/)
  + Collapse this bar

##

##

Loading Comments...

Write a Comment...

Email (Required)

Name (Required)

Website

###

%d

![](https://pixel.wp.com/b.gif?v=noscript)



=== Content from cs.umd.edu_592b8804_20250126_060412.html ===
Report: Security Audit of BTC Relay
implementation

Andrew Miller, Feb 7 2015

This is the final report covering a short and preliminary audit (budget: 10 hours) of the
Relay

BTC
​

 design and implementation.
​

BTC Relay is an Ethereum contract that acts as an SPV client of the Bitcoin blockchain ­ that is,
it provides a service that other Ethereum contracts can use to verify if a given Bitcoin
transaction is valid. The primary goal of this audit is to look for major security flaws in design or
implementation that could lead to 1) being unable to verify a valid Tx, and 2) falsely reporting an
invalid Tx as valid.

To provide this service, BTC Relay keeps track of the Bitcoin headers and proof­of­work chain in
the contract’s storage. To avoid having to do a lot of special work to handle reorgs, the headers
are stored in a skip­list data structure (overlaid on top of Ethereum contract storage) that
supports quickly finding ancestors of a given chain.

Since SPV security relies on at least one honest user submitting new Bitcoin block headers in a
timely fashion, BTC Relay features an incentive mechanism where the submitter can choose a
price, and consumers that call verifyTx must pay it.

This report is published under the Creative Commons Attribution + ShareAlike license. An
updated version may be found at

http://cs.umd.edu/~amiller/BTCRelayAudit.pdf
​

.
​

Summary:

Overall, I’ve found the BTC Relay design and implementation to be of excellent quality. The
included tests included both units and end­to­end examples that exercise almost all of the
Bitcoin blockchain headers and a variety of transactions. The included user interface examples
are great for illustrating the intended use of this as a service.

The implementation suffered from a small number of easily­corrected pitfalls, most notably 1)
not accounting for an ambiguity in Bitcoin’s transaction Merkle tree data format, and 2)
forgetting to check the return value of a send.

The ancestor skip­list data structure is a great approach, although I provide a recommendation
that could reduce its overall storage and update cost.

My largest complaint is about the incentive mechanism, which I believe is underspecified and

“confusing­by­design”. In a nutshell, this mechanism attempts to charge consumers of the relay
service a “fee,” although there are workarounds such that users typically do not need to pay the
fee. Evaluating this mechanism is outside the explicit scope of this audit, but I’ll explain why I
find this confusing and undesirable. The incentive mechanism also suffers from an
easily­corrected mistake, as explained below ­ arguably, as this is a specification error, even this
would have been out of scope! Therefore my recommendation is to rethink and simplify the
incentive mechanism.

Methodology

Officially, the audit covers the code at this commit:
https://github.com/ethereum/btcrelay/commit/0c013319ccb3b274cf0e878e21753f5b68933628
although I tried to keep up with the latest versions as updates were made.

The following describes my intended procedure:

­ Look for typical errors and pitfallls

Forgetting to check the return value in send
Mistakes in data format conversions
Mistakes in magic offsets (~calldataload) which may depend on data size
Control flow paths that lose money or apply state changes only partially
Misinterpretation of serpent/EVM semantics
Merkle­tree ambiguity

­ Check for consistency with Bitcoin spec

Is it possible to accept invalid transactions or headers?
Are assumptions about Bitcoin formats that are likely to change?

­ Evaluate code quality

Are style guidelines and conventions applied consistently to mkae code review easy?
Do the tests cover branches of the code?

Not covered:

­ Analysis of evm bytecode and bugs / under­specification of serpent compiler. The

serpent compiler does not have a full specification

Main findings:

The return value of send() is not checked, leading to inconsistent state:

There is an instance of an unguarded send() when paying out the fee to the recipient.
Since a log event is generated after the send, this could result in consumers taking an action

based on the log event, even though the fee may have actually not been sent. The likelihood of
harm from this is low, assuming that consumers are unlikely to rely on log events.

This bug was addressed quickly, by throwing an exception (invalid()) after checking the

return value of send().
https://github.com/ethereum/btcrelay/commit/26ee2bcc4468329939a3f093023496986c357074

Merkle tree handling is susceptible to ambiguity:

To check if a Tx is contained within a Bitcoin block, the Merkle tree siblings “along the

path” must be provided by the caller, and the BTC Relay contract checks it by recomputing the
root hash.

In Bitcoin Merkle trees, there’s no explicit indication whether a given node is an interior
node or a leaf. This creates a possible ambiguity, where an internal node (two 32­byte hashes)
could be confused with a 64­byte transaction!

Lets say the merkle tree of a block is:
         H
   H0         H1
Tx0  Tx1   Tx2
                 Tx3

Then the BTC Relay contract could be convinced to relay a transaction containing H0
even though H0 isn't actually a transaction hash.

Joseph Chow’s solution is to exclude 64­byte transactions. It’s conceivable that a valid 64­byte
transaction could exist in the future, and in that case it would not be able to be verified in
btcRelay. This risk seems low, since such a transaction would be much smaller than the
average today.

The incentive policy is misleading and may be circumvented:

Whoever submits a block header can set an arbitrary “fee”. It appears that the intent is

that the fee must be paid in order for “verifyTx” or “relayTx” to work. An obvious DoS vector
would be for the first submitter to set this fee very high.

However, there is a separate function by which you can change the fee down to 0 (or

any value smaller than the previous fee), for a different price, “gChangeRecipientFee”. This
makes the incentive scheme complicated to understand, and misleading, since if the cost to
change the fee is less than the nominal fee, then the nominal fee no longer applies.

The game could be simplified by automatically capping the fee at the
“gChangeRecipientFee”. I would recommend this based on a principle of “transparent
incentives”, or “avoiding incentive­compatibility­through­obscurity”.

Another potential DoS vector would be to set the both the initial fee and the

“gChangeRecipientFee” to be very high. “gChangeRecipientFee” is typically based on the cost
of initially submitting the header (gas used * gas price). So, an obvious attack would be to set
the gasPrice very high (especially for a submitter who is also a miner).

There is already a countermeasure against this attack, namely that the effective gas

price is constrained to within a +/­ 1/1024 factor of the effective gas price for the previous block
header. This is intended to mirror Ethereum’s policy for the total gas limit in a block.

If there are not many submitters, then it is plausible that a miner might gradually try to

raise this price.

The incentive implementation does not *clamp* properly, leading to a DoS vector

Actually, the current implementation makes this slightly worse, because it does *not*

even quite mirror Ethereum’s policy. Ethereum’s policy for evolving a value is:

LO = 1023*prevX/1024
HI = 1025*prevX/1024
if (x < LO) then x := LO
if (x > HI) then x := HI

whereas BtcRelay’s policy is:

if (x < LO or x > HI) then

x := prevX

So, if an Attacker (say, a 10% miner) gets lucky and increases the transaction gas price

above 1.001 of the default gas price (e.g., by being the first miner to mine an Ethereum block
after a new Bitcoin block is found, two consecutive Bitcoin blocks in a row), and if everyone else
only uses the default gas price (50 szabo today), then the miner can *continue to jack the price
up* over time.

More Notes:
Conventions for macros are inconsistently applied.

m_Blah indicates a macro.
The distinction between macro and non macro is relevant because macros are inlined,
where as function calls require an entire new message, thus incurring more gas and increasing
the call stack depth.

High variance attack on the first block:

There are several special cases handling the “first” block (which may not be the genesis

block, but rather a contemporary block around the deployment of the). One is that the target
difficulty is not enforced, since in general the target difficulty is derived from the target difficulty
of the previous block.

The following comment from the code provides a rationale:

“This allows blocks with arbitrary difficulty [to be] added to the initial parent, but

as these forks will have lower score than the main chain, they will not have impact”

It would be a longshot, but a less­than­50% attacker has a much better chance of finding

one block with much greater apparent difficulty than a long chain of blocks adding up to the
same difficulty.

Recommendation: include an initial difficulty target along with the first parent.

Ancestor data structure is too sparsely documented:

Joseph Chow provided a more comprehensive explanation in private conversation about

how the ancestor data structure worked. It would be useful to put this explanation into the
comments or design documentation!

The relayTx() function sends all the remaining gas:

After a transaction is verified, when .processTransaction is invoked on the relayee, this

can trigger arbitrary contract code. If this code uses up the available gas, then the code
following the invocation will not be applied. In particular, there is a log event
https://github.com/ethereum/btcrelay/blob/develop/btcrelay.se#L217
 that will not be triggered.
​
This could cause problems for a reasonable consumer of BTC Relay, that uses log events to
check whether someone has made a “best effort” to relay the transaction to the relayee.

Recommendation: allow relayTx to include a “gas to send relayee” field, and only pass

this much gas.

Note that this .processTransaction invocation is *not* susceptible to the call­stack

hazard. The reason is that self.verifyTransaction() is called prior to
relayee.processTransaction(). This means that if the callstack is already at 1024, then
verifyTransaction() will also fail.

Otherwise, I checked that all functions pass only a limited amount of gas to the callee.

Can the call stack be advanced significantly when traversing the blockchain?

Verifying a Tx requires traversing potentially a large number of blocks. Fortunately the

traversal function is iterative (fastGetBlockHash) rather than recursive, so this risk isn’t a
problem.

Suboptimal skipping data structure

The ancestor data structure is in btcChain.se. The skip distances are 5**0 (the previous

block) through 5**7. So the maximum skip is 5**7 = 78125.

Adding a new header requires fetching data for 8 previous headers. In total, the storage

cost for N block headers is 8N.

This could be reduced to only requiring a constant amount of work to add each block,

although my first attempt at this comes with a tradeoff, that it makes traversals more expensive.
The following is a very rough description of the idea:

Each block B has two links, a "back" link to block B­1, and an "up" link, to a block that is

more "round"

The "roundness" of a  number is the largest power of 2 that divides it

 So 6 has roundness 2, 96 has roundness 32…. basically it's

So let’s say you want to go from 117 to 1

You'd go 117[1]   116[4]  112[16]  96[32]   64...... 64 is special because it can't go 'up'

any further, so 64 just goes back half way to 32.

A worst case example would be from 128 to 65

127 126 124 120 112 96  (too far, goes to 64)   95 94 92 88 80 (too far, goes to 64)   79 78 76
72 (too far, goes to 64) etc...

This is O(log^2 N) for traversing n blocks, rather than O(log N) as it is now.

I don't know if there is any other better way that only uses 2 pointers per block.

Timestamp handling:

Timestamps aren’t sanity checked. This is explicitly a cost­saving measure, and I think

Joseph has a suspicion about it. Does this lead to any problems?

Casting a timestamp “into the future” can be used to lower the bitcoin difficulty. At first

glance, we’d expect this to open up an attack vector where a miner who finds the 2016’th block
in an interval, gives a fake timestamp, lowers the difficulty to minimum, and then very quickly
finds 6 weak blocks in succession. This would trigger the verifyTx/relayTx behavior with 6
confirms, even though it would shortly be reorged. Bitcoin’s defense against this sort of thing is
to only allow the difficulty to change by a factor of 4 every 2016 blocks. This behavior is
adequately replicated in btcRelay, so it’s OK.

Recommendations:

­ Test coverage:

I don’t know of existing tools for checking test coverage with high level code. The

Ethereum virtual machine debug logs provide enough information (e.g., program counter at
each step) to debug with the EVM byte­code, but the Serpent compiler forgets most of the
structure.

However, a reasonably easy­to­implement approach would be to generate a detailed log

file, and look for regions of the bytecode that were never executed (i.e., the program counter
never pointed at these).

­ Service specification

Make a list of expected / reliable behaviors for the server.
For example, are the log messages intended to be reliable?
This would be a natural place to include caveats about 64­byte transactions not being

verifiable, etc.

­ Gas calculations

There can be a large variation in the amount of gas required to verify a transaction

depending on how far back it goes, how deep the Merkle tree is, etc. Provide a calculator or a
table?



=== Content from github.com_5c657cf0_20250126_060407.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fbitcoinknots%2Fbitcoin%2Fblob%2Fv0.13.1.knots20161027%2Fdoc%2Frelease-notes.md)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fbitcoinknots%2Fbitcoin%2Fblob%2Fv0.13.1.knots20161027%2Fdoc%2Frelease-notes.md)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=bitcoinknots%2Fbitcoin)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[bitcoinknots](/bitcoinknots)
/
**[bitcoin](/bitcoinknots/bitcoin)**
Public

forked from [bitcoin/bitcoin](/bitcoin/bitcoin)

* [Notifications](/login?return_to=%2Fbitcoinknots%2Fbitcoin) You must be signed in to change notification settings
* [Fork
  70](/login?return_to=%2Fbitcoinknots%2Fbitcoin)
* [Star
   231](/login?return_to=%2Fbitcoinknots%2Fbitcoin)

* [Code](/bitcoinknots/bitcoin/tree/v0.13.1.knots20161027)
* [Issues
  30](/bitcoinknots/bitcoin/issues)
* [Pull requests
  5](/bitcoinknots/bitcoin/pulls)
* [Discussions](/bitcoinknots/bitcoin/discussions)
* [Actions](/bitcoinknots/bitcoin/actions)
* [Security](/bitcoinknots/bitcoin/security)
* [Insights](/bitcoinknots/bitcoin/pulse)

Additional navigation options

* [Code](/bitcoinknots/bitcoin/tree/v0.13.1.knots20161027)
* [Issues](/bitcoinknots/bitcoin/issues)
* [Pull requests](/bitcoinknots/bitcoin/pulls)
* [Discussions](/bitcoinknots/bitcoin/discussions)
* [Actions](/bitcoinknots/bitcoin/actions)
* [Security](/bitcoinknots/bitcoin/security)
* [Insights](/bitcoinknots/bitcoin/pulse)

## Files

 v0.13.1.knots20161027
## Breadcrumbs

1. [bitcoin](/bitcoinknots/bitcoin/tree/v0.13.1.knots20161027)
2. /[doc](/bitcoinknots/bitcoin/tree/v0.13.1.knots20161027/doc)
/
# release-notes.md

Copy path Blame  Blame
## Latest commit

## History

[History](/bitcoinknots/bitcoin/commits/v0.13.1.knots20161027/doc/release-notes.md)493 lines (424 loc) · 25.9 KB v0.13.1.knots20161027
## Breadcrumbs

1. [bitcoin](/bitcoinknots/bitcoin/tree/v0.13.1.knots20161027)
2. /[doc](/bitcoinknots/bitcoin/tree/v0.13.1.knots20161027/doc)
/
# release-notes.md

Top
## File metadata and controls

* Preview
* Code
* Blame

493 lines (424 loc) · 25.9 KB[Raw](https://github.com/bitcoinknots/bitcoin/raw/refs/tags/v0.13.1.knots20161027/doc/release-notes.md)

Bitcoin Knots version 0.13.1.knots20161027 is now available from:

<https://bitcoinknots.org/files/0.13.x/0.13.1.knots20161027/>

This is a new minor version release, including activation parameters for the
segwit softfork, various bugfixes and performance improvements, as well as
updated translations.

Please report bugs using the issue tracker at github:

<https://github.com/bitcoinknots/bitcoin/issues>

# Compatibility

Microsoft ended support for Windows XP on [April 8th, 2014](https://www.microsoft.com/en-us/WindowsForBusiness/end-of-xp-support),
an OS initially released in 2001. This means that not even critical security
updates will be released anymore. Without security updates, using a bitcoin
wallet on a XP machine is irresponsible at least.

In addition to that, with 0.12.x there have been varied reports of Bitcoin Knots
randomly crashing on Windows XP. It is [not clear](https://github.com/bitcoin/bitcoin/issues/7681#issuecomment-217439891)
what the source of these crashes is, but it is likely that upstream
libraries such as Qt are no longer being tested on XP.

We do not have time nor resources to provide support for an OS that is
end-of-life. From 0.13.0 on, Windows XP is no longer supported. Users are
suggested to upgrade to a newer version of Windows, or install an alternative OS
that is supported.

No attempt is made to prevent installing or running the software on Windows XP,
you can still do so at your own risk, but do not expect it to work: do not
report issues about Windows XP to the issue tracker.

From 0.13.1 onwards OS X 10.7 is no longer supported. 0.13.0 was intended to work on 10.7+,
but severe issues with the libc++ version on 10.7.x keep it from running reliably.
0.13.1 now requires 10.8+, and will communicate that to 10.7 users, rather than crashing unexpectedly.

# Notable changes

## Sensitive data is no longer stored in debug console history

Since v0.11.0, Knots has supported saving the debug console history across
restarts. This was intended to exclude sensitive data, such as private keys
and the wallet passphrase, but the logic to detect this was skipped in
practice (this security issue is assigned CVE-2016-8889).

This security issue is fixed as of this release. Additionally, when you start
Knots, it will scan through your current persisted history and filter out any
sensitive information it finds. This is implemented such that the sensitive
info is erased as securely as possible, but due to the nature of configuration
storage, it is unlikely to succeed in entirely removing it from your disk.

## Segregated witness soft fork

Segregated witness (segwit) is a soft fork that, if activated, will
allow transaction-producing software to separate (segregate) transaction
signatures (witnesses) from the part of the data in a transaction that is
covered by the txid. This provides several immediate benefits:

* **Elimination of unwanted transaction malleability:** Segregating the witness
  allows both existing and upgraded software to calculate the transaction
  identifier (txid) of transactions without referencing the witness, which can
  sometimes be changed by third-parties (such as miners) or by co-signers in a
  multisig spend. This solves all known cases of unwanted transaction
  malleability, which is a problem that makes programming Bitcoin wallet
  software more difficult and which seriously complicates the design of smart
  contracts for Bitcoin.
* **Capacity increase:** Segwit transactions contain new fields that are not
  part of the data currently used to calculate the size of a block, which
  allows a block containing segwit transactions to hold more data than allowed
  by the current maximum block size. Estimates based on the transactions
  currently found in blocks indicate that if all wallets switch to using
  segwit, the network will be able to support about 70% more transactions. The
  network will also be able to support more of the advanced-style payments
  (such as multisig) than it can support now because of the different weighting
  given to different parts of a transaction after segwit activates (see the
  following section for details).
* **Weighting data based on how it affects node performance:** Some parts of
  each Bitcoin block need to be stored by nodes in order to validate future
  blocks; other parts of a block can be immediately forgotten (pruned) or used
  only for helping other nodes sync their copy of the block chain. One large
  part of the immediately prunable data are transaction signatures (witnesses),
  and segwit makes it possible to give a different "weight" to segregated
  witnesses to correspond with the lower demands they place on node resources.
  Specifically, each byte of a segregated witness is given a weight of 1, each
  other byte in a block is given a weight of 4, and the maximum allowed weight
  of a block is 4 million. Weighting the data this way better aligns the most
  profitable strategy for creating blocks with the long-term costs of block
  validation.
* **Signature covers value:** A simple improvement in the way signatures are
  generated in segwit simplifies the design of secure signature generators
  (such as hardware wallets), reduces the amount of data the signature
  generator needs to download, and allows the signature generator to operate
  more quickly. This is made possible by having the generator sign the amount
  of bitcoins they think they are spending, and by having full nodes refuse to
  accept those signatures unless the amount of bitcoins being spent is exactly
  the same as was signed. For non-segwit transactions, wallets instead had to
  download the complete previous transactions being spent for every payment
  they made, which could be a slow operation on hardware wallets and in other
  situations where bandwidth or computation speed was constrained.
* **Linear scaling of sighash operations:** In 2015 a block was produced that
  required about 25 seconds to validate on modern hardware because of the way
  transaction signature hashes are performed. Other similar blocks, or blocks
  that could take even longer to validate, can still be produced today. The
  problem that caused this can't be fixed in a soft fork without unwanted
  side-effects, but transactions that opt-in to using segwit will now use a
  different signature method that doesn't suffer from this problem and doesn't
  have any unwanted side-effects.
* **Increased security for multisig:** Bitcoin addresses (both P2PKH addresses
  that start with a '1' and P2SH addresses that start with a '3') use a hash
  function known as RIPEMD-160. For P2PKH addresses, this provides about 160
  bits of security---which is beyond what cryptographers believe can be broken
  today. But because P2SH is more flexible, only about 80 bits of security is
  provided per address. Although 80 bits is very strong security, it is within
  the realm of possibility that it can be broken by a powerful adversary.
  Segwit allows advanced transactions to use the SHA256 hash function instead,
  which provides about 128 bits of security (that is 281 trillion times as
  much security as 80 bits and is equivalent to the maximum bits of security
  believed to be provided by Bitcoin's choice of parameters for its Elliptic
  Curve Digital Security Algorithm [ECDSA].)
* **More efficient almost-full-node security** Satoshi Nakamoto's original
  Bitcoin paper describes a method for allowing newly-started full nodes to
  skip downloading and validating some data from historic blocks that are
  protected by large amounts of proof of work. Unfortunately, Nakamoto's
  method can't guarantee that a newly-started node using this method will
  produce an accurate copy of Bitcoin's current ledger (called the UTXO set),
  making the node vulnerable to falling out of consensus with other nodes.
  Although the problems with Nakamoto's method can't be fixed in a soft fork,
  Segwit accomplishes something similar to his original proposal: it makes it
  possible for a node to optionally skip downloading some blockchain data
  (specifically, the segregated witnesses) while still ensuring that the node
  can build an accurate copy of the UTXO set for the block chain with the most
  proof of work. Segwit enables this capability at the consensus layer, but
  note that Bitcoin Core does not provide an option to use this capability as
  of this 0.13.1 release.
* **Script versioning:** Segwit makes it easy for future soft forks to allow
  Bitcoin users to individually opt-in to almost any change in the Bitcoin
  Script language when those users receive new transactions. Features
  currently being researched by Bitcoin Core contributors that may use this
  capability include support for Schnorr signatures, which can improve the
  privacy and efficiency of multisig transactions (or transactions with
  multiple inputs), and Merklized Abstract Syntax Trees (MAST), which can
  improve the privacy and efficiency of scripts with two or more conditions.
  Other Bitcoin community members are studying several other improvements
  that can be made using script versioning.

Activation for the segwit soft fork is being managed using BIP9
versionbits. Segwit's version bit is bit 1, and nodes will begin
tracking which blocks signal support for segwit at the beginning of the
first retarget period after segwit's start date of 15 November 2016. If
95% of blocks within a 2,016-block retarget period (about two weeks)
signal support for segwit, the soft fork will be locked in. After
another 2,016 blocks, segwit will activate.

For more information about segwit, please see the [segwit FAQ](https://bitcoincore.org/en/2016/01/26/segwit-benefits/), the
[segwit wallet developers guide](https://bitcoincore.org/en/segwit_wallet_dev/) or BIPs [141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki), [143](https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki),
[144](https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki), and [145](https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki). If you're a miner or mining pool
operator, please see the [versionbits FAQ](https://bitcoincore.org/en/2016/06/08/version-bits-miners-faq/) for information about
signaling support for a soft fork.

## Null dummy soft fork

Combined with the segwit soft fork is an additional change that turns a
long-existing network relay policy into a consensus rule. The
`OP_CHECKMULTISIG` and `OP_CHECKMULTISIGVERIFY` opcodes consume an extra
stack element ("dummy element") after signature validation. The dummy
element is not inspected in any manner, and could be replaced by any
value without invalidating the script.

Because any value can be used for this dummy element, it's possible for
a third-party to insert data into other people's transactions, changing
the transaction's txid (called transaction malleability) and possibly
causing other problems.

Since Bitcoin Core 0.10.0, nodes have defaulted to only relaying and
mining transactions whose dummy element was a null value (0x00, also
called OP\_0). The null dummy soft fork turns this relay rule into a
consensus rule both for non-segwit transactions and segwit transactions,
so that this method of mutating transactions is permanently eliminated
from the network.

Signaling for the null dummy soft fork is done by signaling support
for segwit, and the null dummy soft fork will activate at the same time
as segwit.

For more information, please see [BIP147](https://github.com/bitcoin/bips/blob/master/bip-0147.mediawiki).

## Bumpfee RPC method

A new RPC method `bumpfee` has been added enabling reissuing opt-in RBF
transactions with a higher fee. The caller must explicitly specify the output
to be decremented offsetting the increased fee. See `help bumpfee` for usage.

## Support for multiple wallets

You can load multiple wallets at startup by specifying the `-wallet` parameter
multiple times. For example, to simply load two wallets, you might start with
`bitcoin-qt -wallet=wallet.dat -wallet=wallet2.dat`. In this mode, the GUI will
show a dropdown box selector for which wallet to view.

For RPC access, only a single wallet can currently be used per RPC username.
An optional fourth field is added to the `rpcauth` configuration parameter to
specify which wallet file the username should access. If omitted, the first
loaded wallet is used. It can also be provided as a single hyphen to disable
wallet access for that user.

Note that multi-wallet support is currently experimental. It is not
well-tested, and may be removed in future releases.

## Low-level RPC changes

* `getblockchaininfo` now includes the block height at which BIP 9 softforks
  activated.
* `importmulti` has been updated to the final version merged into Bitcoin Core.
  In addition to greatly expanding its capabilities, this brings a minor break
  to the interface: the second parameter has changed from a boolean controlling
  rescanning, to a JSON Object with a single `rescan` key.
* `importprunedfunds` only accepts two required arguments. Some versions accept
  an optional third arg, which was always ignored. Make sure to never pass more
  than two arguments.

## Memory pool not prefilled

When connecting to new peers, their memory pool is no longer requested. This
was found to use too much bandwidth and not done at the appropriate time.

## Linux ARM builds

With the 0.13.0 release, pre-built Linux ARM binaries were added to the set of
uploaded executables. Additional detail on the ARM architecture targeted by each
is provided below.

The following extra files can be found in the download directory or torrent:

* `bitcoin-${VERSION}-arm-linux-gnueabihf.tar.gz`: Linux binaries targeting
  the 32-bit ARMv7-A architecture.
* `bitcoin-${VERSION}-aarch64-linux-gnu.tar.gz`: Linux binaries targeting
  the 64-bit ARMv8-A architecture.

ARM builds are still experimental. If you have problems on a certain device or
Linux distribution combination please report them on the bug tracker, it may be
possible to resolve them. Note that the device you use must be (backward)
compatible with the architecture targeted by the binary that you use.
For example, a Raspberry Pi 2 Model B or Raspberry Pi 3 Model B (in its 32-bit
execution state) device, can run the 32-bit ARMv7-A targeted binary. However,
no model of Raspberry Pi 1 device can run either binary because they are all
ARMv6 architecture devices that are not compatible with ARMv7-A or ARMv8-A.

Note that Android is not considered ARM Linux in this context. The executables
are not expected to work out of the box on Android.

# 0.13.1 Change log

Detailed release notes follow. This overview includes changes that affect
behavior, not code moves, refactors and string updates. For convenience in locating
the code changes and accompanying discussion, both the pull request and
git merge commit are mentioned. Changes specific to Bitcoin Knots (beyond Core)
are flagged with an asterisk ('\*') before the description.

### Consensus

* #8636 `9dfa0c8` Implement NULLDUMMY softfork (BIP147) (jl2012)
* #8848 `7a34a46` Add NULLDUMMY verify flag in bitcoinconsensus.h (jl2012)
* #8937 `8b66659` Define start and end time for segwit deployment (sipa)

### RPC and other APIs

* #8581 `526d2b0` Drop misleading option in importprunedfunds (MarcoFalke)
* #8699 `a5ec248` Remove createwitnessaddress RPC command (jl2012)
* #8780 `794b007` Deprecate getinfo (MarcoFalke)
* #8832 `83ad563` Throw JSONRPCError when utxo set can not be read (MarcoFalke)
* #8884 `b987348` getblockchaininfo help: pruneheight is the lowest, not highest, block (luke-jr)
* #8858 `3f508ed` rpc: Generate auth cookie in hex instead of base64 (laanwj)
* #8951 `7c2bf4b` RPC/Mining: getblocktemplate: Update and fix formatting of help (luke-jr)
* #8845 `103c724` \*Bugfix: Don't return the address of a P2SH of a P2SH (jnewbery)
* #7533 `f7c365b` \*Bugfix: AreInputsStandard: Use the "bad-txns-input-" prefix in checking setIgnoreRejects (luke-jr)
* #7533 `91f9bfc` \*Make bad-witness-nonstandard rejection more specific, and support overriding some (luke-jr)
* #7551 `bf54cfb` \*Upgrade importmulti RPC to final version (Pedro Branco)
* #8456 `27cd254` \*[RPC] Simplified bumpfee command. (mrbandrews)
* #7948 `3c5cae9` \*RPC: augment getblockchaininfo bip9\_softforks data (mruddy)
* #8384 `d002e05` \*Add witness data output to TxInError messages (instagibbs)
* #8775 `34b418e` \*RPC refactoring: Never access wallet directly, only via new CRPCRequestInfo (luke-jr)
* #8694 `1f62f13` \*RPC: Allow rpcauth configs to specify a 4th parameter naming a specific wallet (luke-jr)

### Block and transaction handling

* #8611 `a9429ca` Reduce default number of blocks to check at startup (sipa)
* #8634 `3e80ab7` Add policy: null signature for failed CHECK(MULTI)SIG (jl2012)
* #8525 `1672225` Do not store witness txn in rejection cache (sipa)
* #8499 `9777fe1` Add several policy limits and disable uncompressed keys for segwit scripts (jl2012)
* #8526 `0027672` Make non-minimal OP\_IF/NOTIF argument non-standard for P2WSH (jl2012)
* #8524 `b8c79a0` Precompute sighashes (sipa)
* #8651 `b8c79a0` Predeclare PrecomputedTransactionData as struct (sipa)
* #8357 `94a34a5` \*Fix relaypriority calculation error (maiiz)
* #8610 `053506e` \*Share unused mempool memory with coincache (sipa)
* #7149 `887fc24` \*CTxMemPool::check: Use height+1 for priority comparison, since height is not guaranteed to work (luke-jr)
* n/a `811e04c1` \*Bugfix: AcceptToMemoryPool: Use height+1 for !priorityaccurate too, since the rest of the code assumes it

### P2P protocol and network code

* #8740 `42ea51a` No longer send local address in addrMe (laanwj)
* #8427 `69d1cd2` Ignore `notfound` P2P messages (laanwj)
* #8573 `4f84082` Set jonasschnellis dns-seeder filter flag (jonasschnelli)
* #8712 `23feab1` Remove maxuploadtargets recommended minimum (jonasschnelli)
* #8862 `7ae6242` Fix a few cases where messages were sent after requested disconnect (theuni)
* #8393 `fe1975a` Support for compact blocks together with segwit (sipa)
* #8282 `2611ad7` Feeler connections to increase online addrs in the tried table (EthanHeilman)
* #8612 `2215c22` Check for compatibility with download in FindNextBlocksToDownload (sipa)
* #8606 `bbf379b` Fix some locks (sipa)
* #8594 `ab295bb` Do not add random inbound peers to addrman (gmaxwell)
* #8940 `5b4192b` Add x9 service bit support to dnsseed.bluematt.me, seed.bitcoinstats.com (TheBlueMatt, cdecker)
* #8944 `685e4c7` Remove bogus assert on number of oubound connections. (TheBlueMatt)
* #8949 `0dbc48a` Be more agressive in getting connections to peers with relevant services (gmaxwell)
* n/a `82af0de` \*Revert "Send 'mempool' P2P command at the start of each P2P session to query remote node mempool contents."
* #8996 `3d0965a` \*Allow network activity to be temporarily suspended. (Jon Lund Steffensen)

### Build system

* #8293 `fa5b249` Allow building libbitcoinconsensus without any univalue (luke-jr)
* #8492 `8b0bdd3` Allow building bench\_bitcoin by itself (luke-jr)
* #8563 `147003c` Add configure check for -latomic (ajtowns)
* #8626 `ea51b0f` Berkeley DB v6 compatibility fix (netsafe)
* #8520 `75f2065` Remove check for `openssl/ec.h` (laanwj)

### GUI

* #8481 `d9f0d4e` Fix minimize and close bugs (adlawren)
* #8487 `a37cec5` Persist the datadir after option reset (achow101)
* #8697 `41fd852` Fix op order to append first alert (rodasmith)
* #8678 `8e03382` Fix UI bug that could result in paying unexpected fee (jonasschnelli)
* #8911 `7634d8e` Translate all files, even if wallet disabled (laanwj)
* #8540 `1db3352` Fix random segfault when closing "Choose data directory" dialog (laanwj)
* #7579 `f1c0d78` Show network/chain errors in the GUI (jonasschnelli)
* #8877 `8be89f2` \*Bugfix: Do not add sensitive information to history for real (luke-jr)
* #8877 `dda19af` \*Qt/RPCConsole: Add signmessagewithprivkey to list of commands filtered from history (luke-jr)
* #8877 `4008781` \*Qt/RPCConsole: Truncate filtered commands to just the command name, rather than skip it entirely in history (luke-jr)
* #5891 `7eebe58` \*Qt/RPCConsole: If filtered commands are found in history at startup, erase them best we can (luke-jr)
* #7107 `b55737c` \*Qt: Ask user to use standard port on startup if specified port is in use (Hampus Sjöberg)
* #8371 `4ce9749` \*[Qt] Add out-of-sync modal info layer (jonasschnelli)
* #8517 `6147383` \*[Qt] add HD enabled/disabled icon to the status bar (jonasschnelli)
* #8672 `44f88a6` \*qt: Adding transaction size to transaction details window (Hampus Sjöberg)
* #8918 `21f5a63` \*Qt: Add "Copy URI" to payment request context menu (luke-jr)
* #8774 `bed19c6` \*Qt refactors to better abstract wallet access (luke-jr)
* #8694 `8f36208` \*Qt: Add a combobox to toolbar to select from multiple wallets (luke-jr)

### Wallet

* #8443 `464dedd` Trivial cleanup of HD wallet changes (jonasschnelli)
* #8539 `cb07f19` CDB: fix debug output (crowning-)
* #8664 `091cdeb` Fix segwit-related wallet bug (sdaftuar)
* #8693 `c6a6291` Add witness address to address book (instagibbs)
* #8765 `6288659` Remove "unused" ThreadFlushWalletDB from removeprunedfunds (jonasschnelli)
* #8776 `6ca908d` \*Wallet refactoring leading up to multiwallet (luke-jr)
* #8694 `8f36208` \*Basic multiwallet support (luke-jr)

### Tests and QA

* #8713 `ae8c7df` create\_cache: Delete temp dir when done (MarcoFalke)
* #8716 `e34374e` Check legacy wallet as well (MarcoFalke)
* #8750 `d6ebe13` Refactor RPCTestHandler to prevent TimeoutExpired (MarcoFalke)
* #8652 `63462c2` remove root test directory for RPC tests (yurizhykin)
* #8724 `da94272` walletbackup: Sync blocks inside the loop (MarcoFalke)
* #8400 `bea02dc` enable rpcbind\_test (yurizhykin)
* #8417 `f70be14` Add walletdump RPC test (including HD- & encryption-tests) (jonasschnelli)
* #8419 `a7aa3cc` Enable size accounting in mining unit tests (sdaftuar)
* #8442 `8bb1efd` Rework hd wallet dump test (MarcoFalke)
* #8528 `3606b6b` Update p2p-segwit.py to reflect correct behavior (instagibbs)
* #8531 `a27cdd8` abandonconflict: Use assert\_equal (MarcoFalke)
* #8667 `6b07362` Fix SIGHASH\_SINGLE bug in test\_framework SignatureHash (jl2012)
* #8673 `03b0196` Fix obvious assignment/equality error in test (JeremyRubin)
* #8739 `cef633c` Fix broken sendcmpct test in p2p-compactblocks.py (sdaftuar)
* #8418 `ff893aa` Add tests for compact blocks (sdaftuar)
* #8803 `375437c` Ping regularly in p2p-segwit.py to keep connection alive (jl2012)
* #8827 `9bbe66e` Split up slow RPC calls to avoid pruning test timeouts (sdaftuar)
* #8829 `2a8bca4` Add bitcoin-tx JSON tests (jnewbery)
* #8834 `1dd1783` blockstore: Switch to dumb dbm (MarcoFalke)
* #8835 `d87227d` nulldummy.py: Don't run unused code (MarcoFalke)
* #8836 `eb18cc1` bitcoin-util-test.py should fail if the output file is empty (jnewbery)
* #8839 `31ab2f8` Avoid ConnectionResetErrors during RPC tests (laanwj)
* #8840 `cbc3fe5` Explicitly set encoding to utf8 when opening text files (laanwj)
* #8841 `3e4abb5` Fix nulldummy test (jl2012)
* #8854 `624a007` Fix race condition in p2p-compactblocks test (sdaftuar)
* #8857 `1f60d45` mininode: Only allow named args in wait\_until (MarcoFalke)
* #8860 `0bee740` util: Move wait\_bitcoinds() into stop\_nodes() (MarcoFalke)
* #8882 `b73f065` Fix race conditions in p2p-compactblocks.py and sendheaders.py (sdaftuar)
* #8904 `cc6f551` Fix compact block shortids for a test case (dagurval)
* #7728 `6089dea` \*Fees: Tests: Check CFeeRate internal precision in mempool\_tests.cpp (jtimon)

### Documentation

* #8754 `0e2c6bd` Target protobuf 2.6 in OS X build notes. (fanquake)
* #8461 `b17a3f9` Document return value of networkhashps for getmininginfo RPC endpoint (jlopp)
* #8512 `156e305` Corrected JSON typo on setban of net.cpp (sevastos)
* #8683 `8a7d7ff` Fix incorrect file name bitcoin.qrc (bitcoinsSG)
* #8891 `5e0dd9e` Update bips.md for Segregated Witness (fanquake)
* #8545 `863ae74` Update git-subtree-check.sh README (MarcoFalke)
* #8607 `486650a` Fix doxygen off-by-one comments, fix typos (MarcoFalke)
* #8560 `c493f43` Fix two VarInt examples in serialize.h (cbarcenas)
* #8737 `084cae9` UndoReadFromDisk works on undo files (rev), not on block files (paveljanik)
* #8625 `0a35573` Clarify statement about parallel jobs in rpc-tests.py (isle2983)
* #8624 `0e6d753` build: Mention curl (MarcoFalke)
* #8604 `b09e13c` build,doc: Update for 0.13.0+ and OpenBSD 5.9 (laanwj)
* #8939 `06d15fb` Update implemented bips for 0.13.1 (sipa)

### Miscellaneous

* #8742 `d31ac72` Specify Protobuf version 2 in paymentrequest.proto (fanquake)
* #8414,#8558,#8676,#8700,#8701,#8702 Add missing copyright headers (isle2983, kazcw)
* #8899 `4ed2627` Fix wake from sleep issue with Boost 1.59.0 (fanquake)
* #8817 `bcf3806` update bitcoin-tx to output witness data (jnewbery)
* #8513 `4e5fc31` Fix a type error that would not compile on OSX. (JeremyRubin)
* #8392 `30eac2d` Fix several node initialization issues (sipa)
* #8548 `305d8ac` Use `__func__` to get function name for output printing (MarcoFalke)
* #8291 `a987431` [util] CopyrightHolders: Check for untranslated substitution (MarcoFalke)

# Credits

Thanks to everyone who directly contributed to this release:

* adlawren
* Alexey Vesnin
* Anders Øyvind Urke-Sætre
* Andrew Chow
* Anthony Towns
* BtcDrak
* Chris Stewart
* Christian Barcenas
* Christian Decker
* Cory Fields
* crowning-
* Dagur Valberg Johannsson
* David A. Harding
* Derek Miller
* Eric Lombrozo
* Ethan Heilman
* fanquake
* Gaurav Rana
* Gregory Maxwell
* Hampus Sjöberg
* instagibbs
* isle2983
* Jameson Lopp
* Jeremy Rubin
* jnewbery
* Johnson Lau
* Jon Lund Steffensen
* Jonas Schnelli
* jonnynewbs
* Jorge Timón
* Justin Camarena
* Kaz Wesley
* leijurv
* Luke Dashjr
* maiiz
* MarcoFalke
* Marty Jones
* Matt Corallo
* Micha
* Michael Ford
* mrbandrews
* mruddy
* Pavel Janík
* Pedro Branco
* Pieter Wuille
* rodasmith
* Sev
* Suhas Daftuar
* whythat
* Wladimir J. van der Laan

As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from lists.linuxfoundation.org_f8a8dee2_20250126_060406.html ===

```
[public inbox for bitcoindev@googlegroups.com](../?t=20180702230317)
 [help](../_/text/help/) / [color](../_/text/color/) / [mirror](../_/text/mirror/) / [Atom feed](../new.atom)
```
```
From: Bryan Bishop <kanzure@gmail•com>
To: Bitcoin Dev <bitcoin-dev@lists•linuxfoundation.org>,
	Bryan Bishop <kanzure@gmail•com>
Subject: [[bitcoin-dev] Alert key disclosure](#r)
Date: Mon, 2 Jul 2018 18:03:13 -0500	[[thread overview]](#r)
Message-ID: <CABaSBay8r4JkXkgUZJm30tZKHk-55ho6-C5Hf15ovuNk_VZWEg@mail.gmail.com> (<raw>)

The bitcoin alert keys are disclosed in this email, followed by a
disclosure of various known vulnerabilities in what was once the alert
system. The bitcoin alert system has been completely retired. The
network is not at risk and this warning may be safely ignored if you
do not have an ancient node (running v0.12.x or older) using the
deprecated bitcoin alert system or its public keys.

mainnet public key:
04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284

mainnet private key:
30820113020101042053cdc1e0cfac07f7e1c312768886f4635f6bceebec0887f63a9d37a26a92e6b6a081a53081a2020101302c06072a8648ce3d0101022100fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f300604010004010704410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8022100fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141020101a14403420004fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284

testnet public key:
04302390343f91cc401d56d68b123028bf52e5fca1939df127f63c6467cdf9c8e2c14b61104cf817d0b780da337893ecc4aaff1309e536162dabbdb45200ca2b0a

testnet private key:
308201130201010420474d447aa6f46b4f45f67f21180a5de2722fc807401c4c4d95fdae64b3d6c294a081a53081a2020101302c06072a8648ce3d0101022100fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f300604010004010704410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8022100fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141020101a14403420004302390343f91cc401d56d68b123028bf52e5fca1939df127f63c6467cdf9c8e2c14b61104cf817d0b780da337893ecc4aaff1309e536162dabbdb45200ca2b0a

These are openssl-serialized private keys.

In 2016, a plan was proposed[1] for the completion of the retirement
of the bitcoin alert system which included the idea of revealing the
alert system private keys. The proposal still contains good
information regarding the purpose and intention of alert system
retirement and motivation for the disclosure of the private keys.
Additionally, an overview of the alert system retirement and its
timeline is available on the web at [2]. This disclosure was recently
discussed in an IRC meeting logs at [3]. A media site also recently
discussed this topic[4].

One of the reasons for disclosure of the keys is to mitigate the
effects of unknown dissemination and proliferation of the keys. By
broadcasting the values to make them available to everyone, the value
of the keys is intended to be to be eliminated, since now everyone
could feasibly sign messages, the value of the signed messages becomes
zero.

[1] <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013104.html>
[2] <https://bitcoin.org/en/alert/2016-11-01-alert-retirement>
[3] <http://www.erisian.com.au/meetbot/bitcoin-core-dev/2018/bitcoin-core-dev.2018-06-21-19.00.log.html#l-30>
[4] <https://www.coindesk.com/long-secret-bitcoin-key-finally-revealed/>

# Vulnerabilities in the bitcoin alert system

The following text[5] discloses a number of known vulnerabilities in
the alert system. Writeup contributed by achow101.

[5] <https://gist.github.com/achow101/18a2dfc371c421419d494a3ae0447f66>

The Alert System previously utilized by Bitcoin has several issues
(some of which may be classified as vulnerabilities). These issues no
longer exist in Bitcoin as of network protocol version 700013 which
was released with Bitcoin Core 0.13.0. Many altcoins and Bitcoin
client implementations were notified of the Alert System's removal and
have since removed the alert system themselves or transitioned to
using an Alert system that does not share an Alert Key with Bitcoin.

All of the issues described below allow an attacker in possession of
the Alert Key to perform a Denial of Service attack on nodes that
still support the Alert system. These issues involve the exhaustion of
memory which causes node software to crash or be killed due to
excessive memory usage.

Many of these issues were not known until the Alert System was removed
as developers inspected the code for vulnerabilities prior to
releasing the Alert Key. Due to these issues, the publication of the
Alert Key was delayed and affected altcoins and software were
notified.

As of this writing, less than 4% of Bitcoin nodes are vulnerable.
Furthermore, the Bitcoin Core developers have created a "final alert"
which is a maximum ID number alert which overrides all previous alerts
and displays a fixed "URGENT: Alert key compromised, upgrade required"
message on all vulnerable software. The Bitcoin Core developers
believe that so few vulnerable nodes are present on the network, and
risks to those nodes so minor, that it is safe to publish the Alert
Key.

An Alert contains these fields:

    int32_t nVersion;
    int64_t nRelayUntil;      // when newer nodes stop relaying to newer nodes
    int64_t nExpiration;
    int32_t nID;
    int32_t nCancel;
    std::set<int32_t> setCancel;
    int32_t nMinVer;            // lowest version inclusive
    int32_t nMaxVer;            // highest version inclusive
    std::set<std::string> setSubVer;  // empty matches all
    int32_t nPriority;

Alerts are also identified by their SHA256 hash. The above fields can
be freely modified to generate alerts with differing hashes.

# Infinitely sized map (CVE-2016-10724)

The Alert System was designed to support multiple Alerts
simultaneously. As such, Alerts were stored in memory in a map.
However, there is no limit on how large this map can be, thus an
attacker with the Alert Key can send a large number of Alerts to a
node. Eventually, the map containing all of the Alerts will be so
large that the node runs out of memory and crashes, thus causing a
Denial of Service attack.

The infinitely sized map is the basis for which the Alert system can
be used to cause Denial of Service attacks.

# Infinitely sized alerts

Although the infinitely sized map is what causes the crash itself, an
attacker can also send very large Alerts. Alerts themselves are not
limited in size explicitly, they are only limited by the maximum
network message size. This maximum network message size has varied
between versions. At times in the past, it has been 32 MB. For Bitcoin
Core 0.12.0 (the most recent version of Bitcoin Core with the alert
system enabled by default), the maximum message size is 2 MB.

Although large Alerts do not directly cause a Denial of Service by
themselves, combined with the infinitely sized map, large Alerts can
more quickly cause a node to run out of memory.

* The setCancel field has no length limit (besides the maximum message
size) and is a std::set of 32-bit integers. Given that it has no size
constraints, an attacker can use this field to create a very large
Alert by filling the set with many integers.

* The setSubVer field, like setCancel, has no length limit and is a
std::set. However instead of integers it has std::strings. These
strings do not have a length limit themselves and can thus be
arbitrarily long to produce an Alert that is arbitrarily large.

* Bitcoin Core versions prior to 0.10.0 did not have a limit on the
length of the strComment, strStatusBar, and strReserved fields. These
strings can have an arbitrary length.

# The final alert

To protect against attackers abusing the Alert key following its
publication, the Bitcoin Core developers constructed a "final alert".
This final alert is a maximum ID alert which overrides all previous
alerts. All Bitcoin Core versions since and including Bitcoin Core
0.14.0 contain the final alert and will send it to any node which is
vulnerable to issues including the following disclosures. However this
protection is not enough to protect those nodes as a few issues were
found with the final alert implementation itself.

Final alerts are those which meet the following conditions:

    nExpiration == maxInt &&
    nCancel == (maxInt-1) &&
    nMinVer == 0 &&
    nMaxVer == maxInt &&
    setSubVer.empty() &&
    nPriority == maxInt &&
    strStatusBar == "URGENT: Alert key compromised, upgrade required"

maxInt is the maximum signed integer as defined by
std::numeric_limits<int>::max().

# Multiple final alerts

The definition for a final alert does not include a few fields.
Because alerts are identified by their hashes, changing the omitted
fields allows an Alert to be classified as a final alert but still be
an alert that is added to the infinitely sized map. The nCancel field
omits the maxInt ID number used by the final alert so all of the final
alerts share the same ID.

* Since setCancel is not required to be empty for an alert to be a
final alert, the setCancel field can contain different integers to
produce alerts that have different hashes and are thus different
alerts. Combined with the infinitely sized map and the infinitely
sized setCancel issues, many final alerts can be created which are
large, fill the map, and cause a node to run out of memory.

* The strComment field, while having a maximum length of 65536 bytes
(and no maximum length prior to Bitcoin Core version 0.10.0), is not
required to be a particular string in order for an alert to be a final
alert. Thus multiple final alerts can be crafted which have different
hashes by using different values for strComment

* The strReserved field, while having a maximum length of 256 bytes,
is not required to be a particular string in order for an alert to be
a final alert. Thus multiple final alerts can be crafted which have
different hashes by using different values for strReserved.

* The nVersion field is also not required to be a particular value.
Thus this can be used to construct final alerts with different hashes
by having different values for nVersion.

* nRelayUntil field is also not required to be a particular value.
Thus this can be used to construct final alerts with different hashes
by having different values for nRelayUntil.

# Final Alert Cancellation (CVE-2016-10725)

Although the final alert is supposed to be uncancellable, it
unfortunately is cancellable due to the order of actions when
processing an alert. Alerts are first processed by checking whether
they cancel any existing alert. Then they are checked whether any of
the remaining alerts cancels it. Because of this order, it is possible
to create an alert which cancels a final alert before the node checks
whether that alert is canceled by the final alert. Thus an attacker
can cancel a final alert with another alert allowing a node to be
vulnerable to all of the aforementioned attacks.

# Protecting against DoS attacks from the alert system

Fixing these issues is relatively easy. The first and most obvious
solution is to simply remove the Alert system entirely. As nodes
upgrade to versions without the Alert system, fewer nodes will be
vulnerable to attack should the Alert keys become public. This is the
option that Bitcoin has taken. However, because Bitcoin has retired
the Alert system entirely, the Alert key will also be published to
reduce the risk that the Alert Key is mistakenly depended upon in the
future.
Should altcoins wish to continue using the Alert system but with a
different Alert Key, a few very simple fixes will safeguard nodes from
the aforementioned issues. Limiting the number of alerts, the size of
setCancel and setSubVer, and only allowing one final alert altogether
fix the above issues. This patch[6], on top of Bitcoin Core 0.11 (a
vulnerable version), fixes the aforementioned issues. Altcoins that
still use the Alert system are recommended to port this patch to their
software. Outdated node software is still vulnerable.

[6] <https://gist.github.com/achow101/02d03238090691558a68010a9ccbbf9d>

This disclosure was authored primarily by Bryan Bishop (kanzure) and
Andrew Chow (achow101). Special thanks to reviewers. Also, an
interesting proposal was floated to not disclose the private keys in
WIF format-- one is that this is not how the original values were
received, and second (more importantly) to prevent users from
importing the key into their wallet and reusing it in their wallet key
circulation.

- Bryan
<http://heybryan.org/>
1 512 203 0507

```

---

```
                 [reply](#R)	other threads:[[~2018-07-02 23:03 UTC](../?t=20180702230317)|[newest](../)]

Thread overview: [no followups] expand[[flat](T/#u)|[nested](t/#u)]  [mbox.gz](t.mbox.gz)  [Atom feed](t.atom)

```

---

```
Reply instructions:

You may reply publicly to [this message](#t) via plain-text email
using any one of the following methods:

* Save the following mbox file, import it into your mail client,
  and reply-to-all from there: [mbox](raw)

  Avoid top-posting and favor interleaved quoting:
  <https://en.wikipedia.org/wiki/Posting_style#Interleaved_style>

* Reply using the --to, --cc, and --in-reply-to
  switches of git-send-email(1):

  git send-email \
    --in-reply-to=CABaSBay8r4JkXkgUZJm30tZKHk-55ho6-C5Hf15ovuNk_VZWEg@mail.gmail.com \
    --to=kanzure@gmail$(echo .)com \
    --cc=bitcoin-dev@lists$(echo .)linuxfoundation.org \
    /path/to/YOUR_REPLY

  <https://kernel.org/pub/software/scm/git/docs/git-send-email.html>

```
Be sure your reply has a **Subject:** header at the top and a blank line
before the message body.

---

```
This is a public inbox, see [mirroring instructions](../_/text/mirror/)
for how to clone and mirror all data and code used for this inbox
```


=== Content from bitslog.wordpress.com_6d63aa1f_20250126_060403.html ===


 Words on Bitcoin Design, Privacy, Security and Crypto, by Sergio Demian Lerner
# [Bitslog](https://bitslog.com)

* [Home](https://bitslog.com/)
* [About](https://bitslog.com/about/)
* [Blog Index](https://bitslog.com/blog-index/)
* [Contributions to Bitcoin and the cryptocurrency field](https://bitslog.com/contributions-to-bitcoin-and-the-cryptocurrency-field/)
* [HC Family of Block Cipher modes](https://bitslog.com/hc-family-of-block-cipher-modes/)

« [Blockchain State Storage Rent Revised](https://bitslog.com/2018/01/22/storage-rent-revised/)
[Simple change to the Bitcoin MERKLEBLOCK command to protect from Leaf-Node weakness in Transaction Merkle Tree](https://bitslog.com/2018/08/21/simple-change-to-the-bitcoin-merkleblock-command-to-protect-from-leaf-node-weakness-in-transaction-merkle-tree/) »

## Leaf-Node weakness in Bitcoin Merkle Tree Design

This document describes a weakness in Bitcoin Design that reduces the security of SPV proofs and therefore SPV Wallets.  The weakness was discovered by me on August 2017, but during the responsable disclosure process I learnt it was previously known by some prominent members of the Bitcoin Core team. Using this weakness an attacker can create a valid SPV proof for a fake payment to a victim that is using a SPV wallet, the payment amount being an arbitrary number of bitcoins, and trick the victim into accepting this payment as valid.  Happily, exploiting this bug requires brute-forcing between 69 and 73 bits (depending on initial investment), each operation being a double SHA2, and there are very simple probabilistic protections that SPV wallets can implement easily. For example, an attack can be carried on with an investment of 3M USD (\*). It is assumed that most SPV wallets will be vulnerable to this attack. Also vulnerable are automated systems that accept SPV proofs (such as the Blockstream Elements sidechain in non-federated mode and the RSK Bridge contract). A simple patch which it neither a soft nor a hard fork can prevent the attack described. Also, a second attack that forks the Bitcoin blockchain is presented, requiring the brute-forcing of 225 bits, so it’s only of theoretical interest.

**The Problem**

Bitcoin Merkle tree makes no distinction between inner nodes and leaf nodes. The depth of the tree is implicitly given by the number of transactions. Inner nodes have no specific format, and are 64 bytes in length. Therefore, an attacker can submit to the blockchain a transaction that has exactly 64 bytes in length and then force a victim system to re-interpret this transaction as an inner node of the tree. An attacker can therefore provide an SPV proof (a Merkle branch) that adds an additional leaf node extending the dual transaction/node and provide proof of payment of any transaction he wishes.

It must be noted that a problem reciprocal to this was identified by Andrew Miller [1]. He realized that internal nodes could be re-interpreted as transactions, but it seems he didn’t publish (or didn’t discover) the opposite attack: transactions re-interpreted as nodes. Note that for the coinbase transaction this weakness is not present: getting a coinbase transaction to be interpreted as a hash of two transactions requires brute-forcing at least 216 bits (so it’s unfeasible, unlike the weakness presented in this post).

**Crafting a Transaction-node in 2^72 operations**

The following diagram shows a 64-byte Bitcoin transaction, and how this transaction is split into two 32-byte chunks.

| **Absolute Offs** | **32-Byte chunk** | **32-byte offs** | **Size** | **Description** | **Brute force bits (stage)** |
| --- | --- | --- | --- | --- | --- |
| 0 | 1 | 0 | 4 | Version | 0 |
| 4 | 1 | 4 | 1 | Input count | 0 |
| 5 | 1 | 5 | 27 | Input 0 Tx hash (part 1) | 0 |
| 32 | 2 | 0 | 5 | Input 0 Tx hash (part 2) | 40 (2) |
| 37 | 2 | 5 | 4 | Input 0 Txout index | 17 of 32 (1) |
| 41 | 2 | 9 | 1 | Input 0 script length | 8 (1) |
| 42 | 2 | 10 | 0 | Empty Script | 0 |
| 42 | 2 | 10 | 4 | nSequence | 0 (anything allowed) |
| 46 | 2 | 14 | 1 | Output count | 8 (1) |
| 47 | 2 | 15 | 8 | value | 29 of 64 (1) |
| 55 | 2 | 23 | 1 | Output 0 script length | 8 (1) |
| 56 | 2 | 24 | 4 | Output 0 scriptPubKey | 0 (anything allowed) |
| 60 | 2 | 28 | 4 | lock\_time | 2 of 32  (1) |
|  |  |  |  |  | Total (1) = 72 Total (2) = 40 |

Let the transaction to become an inner node be T.  Let R be the new fake transaction that the attacker wants to build as T’s right child. As the victim is an SPV node, then the SPV proof will require the left 32 bytes of T as the complementary hash as part of the Merkle proof. Luckily, the attacker is free to provide any 32-bytes to the victim.

From now on, we assume that the attacker is a Bitcoin miner, and he owns 2^36-1 satoshis (= 687 BTC or about 5M USD as of June-2018) in a single UTXO A. The attack requires two stages, executing a different brute-force procedure in each.

**Stage 1 Brute-forcing procedure**

The attacker focuses on the second half of T. He wishes to build a transaction whose double-hash matches this second half. To be a valid Bitcoin transaction, some fields of the second half of T must have specific values. Those parts must be “brute-forced”, meaning that the attacker would need to try many transactions R until he finds one matching the desired patterns in T. Some other parts of T are free for the attacker to choose. Still some other parts of T are partially free, and they will be restricted according to other parts of T. Let’s analyze which parts of T need brute-forcing.

We will temporarily forget about the 5 bytes of the **input 0 transaction hash** that overlap the second half of T and we’ll let anything fill this part. Later, in a second brute-forcing stage, we’ll find a transaction that matches this tail.

The **nSequence** field can contain anything.

The **LockTime** field is partially brute-forced: the attacker makes sure the brute-forced uint32 is between 500000000 and 1501843940 (today as a Unix timestamp) or between 0 and 479042 (the current block height). This implies that the LockTime has elapsed. The combined numerical range amplitude is 1002322982, which is close to 230. Therefore, he only needs to brute-force 2 bits of the LockTime.

The higher bits of the Previn **transaction output index** must be 0 so the index is always less than 32768. Since the field is 32-bits in length, the 17 most significant bits must be brute-forced.

The transaction **output amount**  is only partially brute-forced. From the 64 field bits, 35 bits can be chosen freely because the attacker has 2^36-1 satoshis, so 35 free bits can represent any number lower than the amount.  The remaining  29 most significant bits must be zero and should be brute-forced. If the attacker has more BTC, he can reduce the number of bits to brute-force by consuming more BTC in A.

Note that the amount paid is not lost: the transaction T pays to a anyone-can-spend address but  the miner can immediately consume that output and move the funds to a safe address he owns. Also he will be collecting any transaction fees offered by the transaction T as T doesn’t have enough space to include a change output. The attacker can recover all the funds but creating the anyone-can-spend output and a high-fee transaction T will put the attacker in the risk of being himself victim of a fee-sniping attack: the possibility that another miner reverts the blockchain to mine a competing block including the transaction T to collect both fee or output amount in T. The attacker may need to mine several blocks in private (selfish-mining) to prevent the fee-sniping attack.

The input scriptSig can be a script of length up to 4 bytes, but it must contain a valid opcodes so that it can verify the scriptSig of the input (as. T is a valid Bitcoin transaction). The attacker will be able to shape this scriptSig as he wishes to make both scripts correct. Probably the best option reduce brute-forcing needs is to make it 4 bytes in length, and contain any mix of valid opcodes. Since the stack can contain elements inserted by the associated scriptPub, most opcodes will be valid. We will assume that one every 8  random list of 4 of bytes will result in valid script, so only 3 bits of brute-forcing will be needed.

The output scriptPub can be a script of length up to 4 bytes, but it must contain a valid anyone-can-spend script. Probably the best option to reduce brute-forcing is to leave this script empty, as a non-empty scriptSig would need to start with a small subset of push opcodes, because the script stack is empty when the scriptSig is executed.

**Creating the Fake Transaction R**

The attacker will try to create a fake transaction R whose transaction ID matches the right half of T and use this fake transaction to cheat a victim. An easy way to do it is to create a fake transaction having one output for the fake payment to the victim, and scan all possible values for the lock\_time field until the transaction ID matches the second half of T. When the lock\_time field space is exhausted, the input script can be slightly modified and a new 32-bit space of lock\_time values is created. Again, an AsicBoost-like technique can be used to save one message-scheduler of the double-SHA2 operation.

The total number of bits to brute-force is therefore 72 bits. However, since the scriptSig and scriptPub

**Stage 2 brute-forcing procedure**

Now we must solve the problem of the 5 random bytes of the input transaction hash that were chosen by the first state.  We note that the first stage also produces a random transaction output index for this input. Let Q be the transaction output index randomly chosen in the first stage. The attacker creates a huge number of transactions W(i) consuming the input A and having Q outputs each. He aims to find W(j) whose ID tail matches the 5 bytes tail mentioned before. The last output of W(j) will be consumed by T.

The procedure to find W(j) is similar to the one used in stage 1. The attacker makes small changes to the tail of the transactions W(i) and re-hashes to obtain the ID, therefore creating new transaction IDs requires only two SHA-2 compressions (one to finalize the transaction hash and the double-hash). The lock\_field can be used to iterate fast. The attacker tries to find a transaction whose transaction ID end in the 5-bytes tail chosen in the first stage. Let’s call this transaction W(j) simply P. This transaction consumes an output controlled by the attacker having A funds. Since 5 bytes must be matches, approximately 2^40 operations will need to be performed to find P.  An AsicBoost-like technique can be used to save one message-scheduler of the double-SHA2 operation.

The total number of bits to brute-force in the second stage is therefore 40 bits.

Interestingly, the brute-forced half of the transaction created in the first stage can be reused as many times if the second stage is re-done. The attacks can be carried out at different times, in different blocks. Therefore, after a successful first attack the following attacks require only brute-forcing 40 bit each. If the number of outputs in P is 33K, the amortized cost of the attack corresponds approximately to brute-forcing only 65 bits. A final transaction E is added in the same block to consume the output of T and recover the funds at risk.

![c1.PNG](https://bitslog.com/wp-content/uploads/2018/06/c1.png?w=541&h=222)

Fig 1. Chain of transactions in attacker’s block

![C2.PNG](https://bitslog.com/wp-content/uploads/2018/06/c2.png?w=508&h=357)

Fig 2. Merkle Tree of the Block containing the fake transaction R

**The Cost of the Attack**

The technology required to build a custom ASIC that performs the brute-forcing of the second stage is very similar to the technology used for Bitcoin miners.

A state-of-the-art Bitcoin miner reaches 14 TH/s and costs $1300 USD. An attacker that buys 1000 units, investing 1.3M USD in hardware, can scan a 72-bit space in 4 days. An additional 1M-10M USD for ASIC chip design and tape-out may be required, depending on the node density. If a chip that can accomplish a programmed pattern match search (instead of zero prefix search) already exists, the design/tapeout costs are saved.

Mining several blocks in private to confirm the fake transaction may be needed to prevent the other miners from reorganizing the blockchain in order to steal the fees and output of transaction T. If the attacker is not in collusion with 51% of the miners, then this may cost the attacker millions in rented hashing power, if available. If the attacker is colluding with 51% of the miners there is no additional cost.

Therefore, under favorable conditions to the attacker, the attack can be profitable if the attacker can cheat one or more users for 1.3M USD or more in total. As any rational actor receiving large amount of BTC will double-check the reception using a full node, only autonomous systems relying on SPV proofs (such as the Elements blockchain and the RSK bridge) may suffer from these attacks.

The attack presented in this document is not optimal: there are several trade-offs than can be made to reduce the number of bits to brute-force increasing other variables, such as initial investment. Locking twice the money in A allows the attacker to reduce the cost in mining hardware to a half, etc.

**An (expensive) attack to partition Bitcoin**

The same vulnerability allows an attacker to fork the Bitcoin blockchain in two without reconciliation, however this attack costs 2^240 double SHA2 operations, so the attack is impractical. The attack requires the attacker to mine a block A with only one specially crafted coinbase transaction of 64 bytes, and create a competing block B with 2 transactions where the pair of transactions IDs in B hashes to the coinbase transaction in A. Both blocks are broadcast simultaneously to different parts of the Bitcoin network. Therefore approximately 50% of the network receives A and the other 50%, B. The two sets of transactions in A and B are created so that they consume different UTXOs and/or create different UTXOs, and therefore both blockchains are valid, but incompatible.

The fact that the first transaction is the coinbase transaction, and a coinbase transaction requires 27 zero bytes and 1 fixed byte in the first 32 bytes, makes the attack practically unfeasible, as it requires brute-forcing 225 bits.

**Remedy**

There is no need to hard-fork or soft-fork Bitcoin, although a future programmed soft-fork or hard-fork could fix this vulnerability.  We propose two non-forking solutions and three forking solutions.

One easy non-forking remedy is that SPV wallets check that every internal 64-bit node of the SPV proof is not a valid transaction. First, there are no 64-byte Bitcoin transaction that pass standard-checks, so the presence of such transaction should rise an alarm. Even if such transactions were normal, the probability of a random 64-byte chunk to become a syntactically valid Bitcoin transaction is close to 2^-56. Therefore, the SPV client can flag the presence of such dual transaction-node as an attack, and refuse to accept the SPV proof.

Another way to fix SPV wallets is to require, along with a Merkle-proof of the inclusion of a transaction E, a Merkle proof for the coinbase transaction. Because building a dual transaction-node for the coinbase transaction requires brute-forcing 225 bits, showing a valid coinbase and its corresponding Merkle inclusion proof is enough to discover the tree height. Both the E branch and the coinbase branch should have equal tree depths.

This method has a drawback: the coinbase transaction may be large, so the method requires non-logarithmic space. If the coinbase transaction is larger than 64 bytes, we could show as evidence only the last a SHA2 mid-state of the first SHA2 application to the coinbase transaction and the transaction length in bytes: with these two field the coinbase id can be reconstructed, because SHA2 embeds the bit-length in the last message block. This allows the verified to effectively differentiate between a 64-byte node and the coinbase transaction. The security of this constructions is weaker and relies on the infeasibility to find free-start SHA2 pre-images. To complicate things, it is still possible (for the next 145 years) that a malicious miner includes a coinbase having exactly 64 bytes.  Therefore, the SPV client must also perform a special check in case the coinbase is exactly 64 bytes in length: in this case it must verify that the previn field contains 256 zero bits (of which 216 are stored in the left half). It’s currently infeasible to obtain a pre-image of a hash digest having 216 zero trailing bits.

Yet another solution that keeps the logarithmic-space constrain for Merkle-proofs is to present an inclusion proof for the right-most transaction ID. In case the number of transactions is not a power of 2 (a full tree), this id appears duplicated at the last two nodes of the tree, so that the tree height can be inferred. A complete solution would require soft-forking Bitcoin to prevent blocks having a full tree, which is nasty.

To summarize, the most space-efficient solution without a soft-fork would be hybrid: show inclusion proof of the rightmost tx id branch if the tree is not full, else the coinbase (showing mid-state and length) if length is greater than 64 bytes, or else show the full coinbase transaction.

A simple soft-forking solution is to invalidate blocks having transactions of size equal to 64.

Another soft-forking solution is to require that a new field “depth” requiring 4 bits is embedded in the block version field. This new fields should specify the Merkle tree depth minus one. By using 4 bits, a a tree of depth 16, containing up to 65K transactions can be specified. Full nodes much check that the actual tree depth matches the value of “depth” given. SPV nodes can check that the “depth” field matches the Merkle branch length received.

A hard-forking solution is adding a prefix to internal nodes of the Merkle tree before performing node hashing and adding a different prefix to transaction IDs and then also hash them. Ripple ([2]) uses a such a prefix system.

**Thanks**

Special thanks to Juliano Rizzo and Matias Marquez from RSK Labs R&D for helping me reduce the attack complexity. Also to Gregory Maxwell for discussing the best way to correct this problem.

(\*) The amounts in USD described in this document were computed at when the weakness was discovered and now they may differ significantly.

[1] <https://cs.umd.edu/~amiller/BTCRelayAudit.pdf>

[2] <https://wiki.ripple.com/Hash_Tree>

**History**

Finding Date: August 4th, 2017 (identified as CVE-2017-12842).

Bitcoin Core Report Contact Date:  August 8th, 2017 (from the interactions we learnt that is was already known to some Core developers)

Publication Date: June 9th, 2018 (triggered from the exposure of the weakness in the Bitcoin mailing list)

June 13th, 2018: Luke Dashjr contacted me and told me he already knew about this weakness. I trust Luke’s word that this is the case, and as I said in the first paragraph, the weakness was already known by some developers. But I still don’t understand (1) why so many people knew about it  but underestimated it badly, (2) why there was no attempt to fix it.

May 12, 2023: The blog post was edited to fix many typos and make it clearer, without changing the ideas or procedures presented.

Author: Sergio Demian Lerner, RSK Labs

### Share this:

* [Twitter](https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/?share=twitter "Click to share on Twitter")
* [Facebook](https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/?share=facebook "Click to share on Facebook")
Like Loading...
### *Related*

This entry was posted on June 9, 2018, 8:00 pm and is filed under [Uncategorized](https://bitslog.com/category/uncategorized/). You can follow any responses to this entry through [RSS 2.0](https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/feed/ "RSS 2.0").
You can [leave a response](#respond), or [trackback](https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/trackback/) from your own site.

* [Comments (0)](#comments)

1. Leave a comment

### Leave a comment [Cancel reply](/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/#respond)

Δ

* ## Recent Posts

  + [Merged mining (Part I)](https://bitslog.com/2022/11/22/merged-mining-part-i/)
  + [The Dark Side of Ethereum 1/64th CALL Gas Reduction](https://bitslog.com/2021/06/10/the-dark-side-of-ethereum-1-64th-call-gas-reduction/)
  + [2021](https://bitslog.com/2021/06/10/2021/)
  + [Re-mining Patoshi Blocks for Dummies](https://bitslog.com/2020/09/03/re-mining-patoshi-blocks-for-dummies/)
  + [The Patoshi Mining Machine](https://bitslog.com/2020/08/22/the-patoshi-mining-machine/)
* ## Recent Comments

  |  | [SDLerner](https://bitslog.wordpress.com) on [A New Mystery in Patoshi …](https://bitslog.com/2020/06/22/a-new-mystery-in-patoshi-timestamps/#comment-59299) |
  | --- | --- |
  |  | TechMiX on [The Patoshi Mining Machin…](https://bitslog.com/2020/08/22/the-patoshi-mining-machine/#comment-59034) |
  |  | [SDLerner](https://bitslog.wordpress.com) on [A New Mystery in Patoshi …](https://bitslog.com/2020/06/22/a-new-mystery-in-patoshi-timestamps/#comment-57463) |
  |  | Jeremy Davis on [A New Mystery in Patoshi …](https://bitslog.com/2020/06/22/a-new-mystery-in-patoshi-timestamps/#comment-57451) |
  |  | TechMiX on [A New Mystery in Patoshi …](https://bitslog.com/2020/06/22/a-new-mystery-in-patoshi-timestamps/#comment-57441) |
* ## Archives

  + [November 2022](https://bitslog.com/2022/11/)
  + [June 2021](https://bitslog.com/2021/06/)
  + [September 2020](https://bitslog.com/2020/09/)
  + [August 2020](https://bitslog.com/2020/08/)
  + [June 2020](https://bitslog.com/2020/06/)
  + [August 2019](https://bitslog.com/2019/08/)
  + [April 2019](https://bitslog.com/2019/04/)
  + [August 2018](https://bitslog.com/2018/08/)
  + [June 2018](https://bitslog.com/2018/06/)
  + [January 2018](https://bitslog.com/2018/01/)
  + [April 2017](https://bitslog.com/2017/04/)
  + [January 2017](https://bitslog.com/2017/01/)
  + [October 2016](https://bitslog.com/2016/10/)
  + [April 2016](https://bitslog.com/2016/04/)
  + [January 2016](https://bitslog.com/2016/01/)
  + [September 2015](https://bitslog.com/2015/09/)
  + [August 2015](https://bitslog.com/2015/08/)
  + [March 2015](https://bitslog.com/2015/03/)
  + [February 2015](https://bitslog.com/2015/02/)
  + [November 2014](https://bitslog.com/2014/11/)
  + [October 2014](https://bitslog.com/2014/10/)
  + [July 2014](https://bitslog.com/2014/07/)
  + [June 2014](https://bitslog.com/2014/06/)
  + [May 2014](https://bitslog.com/2014/05/)
  + [April 2014](https://bitslog.com/2014/04/)
  + [March 2014](https://bitslog.com/2014/03/)
  + [February 2014](https://bitslog.com/2014/02/)
  + [January 2014](https://bitslog.com/2014/01/)
  + [December 2013](https://bitslog.com/2013/12/)
  + [November 2013](https://bitslog.com/2013/11/)
  + [October 2013](https://bitslog.com/2013/10/)
  + [September 2013](https://bitslog.com/2013/09/)
  + [July 2013](https://bitslog.com/2013/07/)
  + [June 2013](https://bitslog.com/2013/06/)
  + [May 2013](https://bitslog.com/2013/05/)
  + [April 2013](https://bitslog.com/2013/04/)
  + [March 2013](https://bitslog.com/2013/03/)
  + [February 2013](https://bitslog.com/2013/02/)
  + [January 2013](https://bitslog.com/2013/01/)
  + [November 2012](https://bitslog.com/2012/11/)
  + [August 2012](https://bitslog.com/2012/08/)
  + [July 2012](https://bitslog.com/2012/07/)
  + [April 2012](https://bitslog.com/2012/04/)
  + [December 2011](https://bitslog.com/2011/12/)
  + [October 2011](https://bitslog.com/2011/10/)
  + [September 2011](https://bitslog.com/2011/09/)
  + [August 2011](https://bitslog.com/2011/08/)
* ## Categories

  + [Uncategorized](https://bitslog.com/category/uncategorized/)
* ## Meta

  + [Register](https://wordpress.com/start?ref=wplogin)
  + [Log in](https://bitslog.wordpress.com/wp-login.php)
  + [Entries feed](https://bitslog.com/feed/)
  + [Comments feed](https://bitslog.com/comments/feed/)
  + [WordPress.com](https://wordpress.com/ "Powered by WordPress, state-of-the-art semantic personal publishing platform.")

[Blog at WordPress.com.](https://wordpress.com/?ref=footer_blog)

* [Comment](https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/#respond)
* Reblog
* Subscribe
  Subscribed

  + [![](https://s2.wp.com/i/logo/wpcom-gray-white.png) Bitslog](https://bitslog.com)

  Join 116 other subscribers

  Sign me up

  + Already have a WordPress.com account? [Log in now.](https://wordpress.com/log-in?redirect_to=https%3A%2F%2Fr-login.wordpress.com%2Fremote-login.php%3Faction%3Dlink%26back%3Dhttps%253A%252F%252Fbitslog.com%252F2018%252F06%252F09%252Fleaf-node-weakness-in-bitcoin-merkle-tree-design%252F)
* Privacy
* + [![](https://s2.wp.com/i/logo/wpcom-gray-white.png) Bitslog](https://bitslog.com)
  + Subscribe
    Subscribed
  + [Sign up](https://wordpress.com/start/)
  + [Log in](https://wordpress.com/log-in?redirect_to=https%3A%2F%2Fr-login.wordpress.com%2Fremote-login.php%3Faction%3Dlink%26back%3Dhttps%253A%252F%252Fbitslog.com%252F2018%252F06%252F09%252Fleaf-node-weakness-in-bitcoin-merkle-tree-design%252F)
  + [Copy shortlink](https://wp.me/p1Ldar-wc)
  + [Report this content](https://wordpress.com/abuse/?report_url=https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/)
  + [View post in Reader](https://wordpress.com/read/blogs/26028371/posts/1996)
  + [Manage subscriptions](https://subscribe.wordpress.com/)
  + Collapse this bar

##

##

Loading Comments...

Write a Comment...

Email (Required)

Name (Required)

Website

###

%d

![](https://pixel.wp.com/b.gif?v=noscript)


