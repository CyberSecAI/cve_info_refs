=== Content from plugins.jenkins.io_daaee8ff_20250126_090755.html ===

# Script Security

How to install

* [Documentation](/script-security/)
* [Releases](/script-security/releases/)
* [Issues](/script-security/issues/)
* [Dependencies](/script-security/dependencies/)
* [Health Score](/script-security/healthscore/)

## User’s guide

(adapted from information on [Template plugin in CloudBees Plugins guide](https://docs.cloudbees.com/docs/admin-resources/latest/plugins/template#template-sect-script-approval))

Various Jenkins plugins require that users define custom scripts, most commonly in the Groovy language, to customize Jenkins’s behavior. If everyone who writes these scripts is a Jenkins administrator—specifically if they have the Overall/RunScripts permission, used for example by the Script Console link—then they can write whatever scripts they like. These scripts may directly refer to internal Jenkins objects using the same API offered to plugins. Such users must be completely trusted, as they can do anything to Jenkins (even changing its security settings or running shell commands on the server).

However, if some script authors are “regular users” with only more limited permissions, such as Job/Configure, it is inappropriate to let them run arbitrary scripts. To support such a division of roles, the Script Security library plugin can be integrated into various feature plugins. It supports two related systems: script approval, and Groovy sandboxing.

### Script Approval

The first, and simpler, security system is to allow any kind of script to be run, but only with an administrator’s approval. There is a globally maintained list of approved scripts which are judged to not perform any malicious actions.

When a user saves some kind of configuration (for example, a job), there will be appropriate warnings indicating that approval is required. Administrators may approve those scripts using the Script Approval configuration page or following the approval link in the configuration. In previous versions of Script Security Plugin, scripts saved by administrators where automatically approved when saving them, but this functionality was disabled to prevent a variety of social engineering-based attacks. (“Saving” usually means from the web UI, but could also mean uploading a new XML configuration via REST or CLI.) or merely by creating a new item copying an existing one.

When a user saves a template configuration, a check is done whether any contained scripts have been edited from an approved text. (More precisely, whether the requested content has ever been approved before.) If it has not been approved, a request for approval of this script is added to a queue. (A warning is also displayed in the configuration screen UI when the current text of a script is not currently approved.)

An administrator may now go to *Manage Jenkins » In-process Script Approval* where a list of scripts pending approval will be shown. Assuming nothing dangerous-looking is being requested, just click Approve to let the script be run henceforth.

If you try to run an unapproved script, it will simply fail, typically with a message explaining that it is pending approval. You may retry once the script has been approved. The details of this behavior may vary according to the feature plugin integrating this library.

### Groovy Sandboxing

Waiting for an administrator to approve every change to a script, no matter how seemingly trivial, could be unacceptable in a team spread across timezones or during tight deadlines. As an alternative option, the Script Security system lets Groovy scripts be run without approval so long as they limit themselves to operations considered inherently safe. This limited execution environment is called a sandbox. (Currently no sandbox implementations are available for other languages, so all such scripts must be approved if configured by non-administrators.)

To switch to this mode, simply check the box Use Groovy Sandbox below the Groovy script’s entry field. Sandboxed scripts can be run immediately by anyone. (Even administrators, though the script is subject to the same restrictions regardless of who wrote it.) When the script is run, every method call, object construction, and field access is checked against a whitelist of approved operations. If an unapproved operation is attempted, the script is killed and the corresponding Jenkins feature cannot be used yet.

The Script Security plugin ships with a small default whitelist, and integrating plugins may add operations to that list (typically methods specific to that plugin).

But you are not limited to the default whitelist: every time a script fails before running an operation that is not yet whitelisted, that operation is automatically added to another approval queue. An administrator can go to the same page described above for approval of entire scripts, and see a list of pending operation approvals. If Approve is clicked next to the signature of an operation, it is immediately added to the whitelist and available for sandboxed scripts.

Most signatures be of the form `method class.Name methodName arg1Type arg2Type…`, indicating a Java method call with a specific “receiver” class (this), method name, and list of argument (or parameter) types. (The most general signature of an attempted method call will be offered for approval, even when the actual object it was to be called on was of a more specific type overriding that method.) You may also see `staticMethod` for static (class) methods, `new` for constructors, and `field` for field accesses (get or set).

Administrators in security-sensitive environments should carefully consider which operations to whitelist. Operations which change state of persisted objects (such as Jenkins jobs) should generally be denied. Most `getSomething` methods are harmless.

In case of highly secured environments, where only sandbox scripts are allowed, the option "Force the use of the sandbox globally in the system" allows forcing the use of the sandbox globally in the system and will block the creation of new items in the "In-process Script Approval" screen.

### ACL-aware methods

Be aware however that even some “getter” methods are designed to check specific permissions (using an ACL: access control list), whereas scripts are often run by a system pseudo-user to whom all permissions are granted. So for example `method hudson.model.AbstractItem getParent` (which obtains the folder or Jenkins root containing a job) is in and of itself harmless, but the possible follow-up call `method hudson.model.ItemGroup getItems` (which lists jobs by name within a folder) checks Job/Read. This second call would be dangerous to whitelist unconditionally, since it would mean that a user who is granted Job/Create in a folder would be able to read at least some information from any jobs in that folder, even those which are supposed to be hidden according to a project-based authorization strategy; it would suffice to create a job in the folder which includes a Groovy script like this (details would vary according to the integrating plugin):

`println("I sniffed ${thisjob.getParent().getItems()}!");`

When run, the script output would display at least the names of supposedly secret projects. An administrator may instead click Approve assuming permission check for `getItems`; this will permit the call when run as an actual user (if the integrating plugin ever does so), while forbidding it when run as the system user (which is more typical). In this case, `getItems` is actually implemented to return only those jobs which the current user has access to, so if run in the former case (as a specific user), the description will show just those jobs they could see anyway. This more advanced button is shown only for method calls (and constructors), and should be used only where you know that Jenkins is doing a permission check.

## Developer’s guide

[Complete example integration](https://github.com/jenkinsci/groovy-postbuild-plugin/pull/11/files)

### The easy way

For a typical Groovy integration, in which you offer the user the option of using either script approval or the sandbox, change your describable’s String-valued script field into a SecureGroovyScript field. In your constructor, before storing the value, call `configuringWithKeyItem` (if there could only be one such script per top-level item) or configuringWithNonKeyItem (if there might be several). The configuration form should use `<f:property field="…"/>` to pick up the script and sandbox configuration. When you want to run the script, just call evaluate.

(For compatibility with old data, pick a different field name and deprecate the original. Then you can define a readResolve method which sets the new field to a SecureGroovyScript with the sandbox off, calls `configuring(ApprovalContext.create())` on it to notify the system that an unapproved script has been loaded, and unsets the old field.)

### The hard way

To be used if you need more control than SecureGroovyScript offers:

Introduce a boolean sandbox field into your configuration.

When unset, you need to call `ScriptApproval.configuring` in the `@DataBoundConstructor`. Use `ApprovalContext.withCurrentUser`, and also `withItemAsKey` where applicable (when there is just one script per job); otherwise at least withItem where applicable, and/or `withKey` when you can uniquely identify this usage from the context (`StaplerRequest.findAncestorObject` is helpful here). This lets the system know a (possibly) new script has been configured by a particular person. You will also need a `readResolve` that calls configuring to notify the system when a configurable with script has been loaded from disk (and thus the configurer is unknown). Call `ScriptApproval.using` when the script is run, and catch `UnapprovedUsageException` if necessary. The descriptor should use form validation on the script field and call `ScriptApproval.checking` (generally your descriptor should already be doing at least a syntax check on this field).

When the sandbox field is set, you need merely set up the Groovy shell with `GroovySandbox.createSecureCompilerConfiguration` and then call `GroovySandbox.run`; be prepared to catch `RejectedAccessException` and call `ScriptApproval.accessRejected`.

### Preapproved methods for the sandbox

To preapprove some particular method calls, simply annotate them with @Whitelisted if in your plugin; otherwise you can register (with `@Extension`) a ProxyWhitelist delegating to StaticWhitelist.from and loading a text file listing whitelisted methods.

### Classpath for evaluating scripts

When constructing a GroovyShell to evaluate a script, or calling `ecureGroovyScript.evaluate`, you must pass a `ClassLoader` which represents the effective classpath for the script. You could use the loader of Jenkins core, or your plugin, or `Jenkins.getInstance().getPluginManager().uberClassLoader`.

Whatever you choose, do not allow an unprivileged user to add arbitrary classpath entries by making a `URLClassLoader`! This would make it trivial to bypass all security when using the sandbox. (A user need merely make this or another job archive a JAR containing some class with a static method marked `@Whitelisted` and doing whatever they like, then call the method from their script.) No attack has yet been demonstrated when using whole-script approval—a `URLClassLoader` with normal parent-first delegation would not permit trivial masking of innocent-looking APIs by compromised versions—but it is likely that some clever use of `META-INF/services/org.codehaus.groovy.transform.ASTTransformation` or similar could cause an otherwise safe script to behave in an unexpected and unauthorized manner. [JENKINS-22834](https://issues.jenkins-ci.org/browse/JENKINS-22834) suggests a safe standard alternative.

### Unit tests

When writing tests for plug-ins that use the Script Security Plugin you may encounter some errors in your tests.

If your tests call, direct or indirectly, the `ScriptApproval.get()` method, then your unit tests must use JenkinsRule so that `Jenkins.getInstance()` does not return null. It is likely that tests that were working now start to fail if you are not using the sandbox. It occurs because they are being enqueued for approval. In case you need to execute scripts regardless of approvals, `ScriptApproval.get().preapprove(script, GroovyLanguage.get())` will ensure that all configured scripts are approved. Alternately, you can have your tests run scripts using the sandbox. In this case you may need to whitelist methods used by your tests -- either generally for real users, or using a `@TestExtension` to have a whitelist just for tests.

## Version history

From of version 1.77 see [GitHub Releases](https://github.com/jenkinsci/script-security-plugin/releases). [Archives](https://github.com/jenkinsci/script-security-plugin/blob/71755e3bd5cf0f04acfcb5afc27b5a29252fca7e/CHANGELOG.md)

##### Version: 1369.v9b\_98a\_4e95b\_2d

Released: 2 months agoRequires Jenkins 2.387.3ID: script-security
##### Installed on 98.6% of controllers

[View detailed version information](https://old.stats.jenkins.io/pluginversions/script-security.html)
##### Links

[GitHub](https://github.com/jenkinsci/script-security-plugin)[Open issues (Jira)](https://issues.jenkins.io/issues/?jql=resolution%20is%20EMPTY%20and%20component%3D18520)[Report an issue (Jira)](https://www.jenkins.io/participate/report-issue/redirect/#18520/script-security)[Javadoc](https://javadoc.jenkins.io/plugin/script-security)
##### Labels

[Library plugins (for use by other plugins)](/ui/search/?labels=api-plugin)[Security](/ui/search/?labels=security)
##### Maintainers

[Jesse Glick](/ui/search/?query=jglick)[Kohsuke Kawaguchi](/ui/search/?query=kohsuke)[Andrew Bayer](/ui/search/?query=abayer)[rsandell](/ui/search/?query=rsandell)[Devin Nusbaum](/ui/search/?query=dnusbaum)[Carroll Chiou](/ui/search/?query=carroll)[Liam Newman](/ui/search/?query=bitwiseman)[Karl Shultz](/ui/search/?query=kshultz)
##### Help us improve this page!

To propose a change submit a pull request to [the plugin page](https://github.com/jenkinsci/script-security-plugin) on GitHub.
##### Previous Security Warnings

* ###### [Groovy sandbox protection incomplete](https://jenkins.io/security/advisory/2016-04-11/)

  + Affects version 1.18 and earlier
* ###### [Unsafe methods in the default list of approved signatures](https://jenkins.io/security/advisory/2017-07-10/)

  + Affects version 1.29 and earlier
* ###### [Multiple sandbox bypasses](https://jenkins.io/security/advisory/2017-08-07/)

  + Affects version 1.30 and earlier
* ###### [Arbitrary file read vulnerability](https://jenkins.io/security/advisory/2017-12-11/)

  + Affects version 1.36 and earlier
* ###### [Script Security sandbox bypass](https://jenkins.io/security/advisory/2018-10-29/#SECURITY-1186)

  + Affects version 1.47 and earlier
* ###### [Script Security sandbox bypass](https://jenkins.io/security/advisory/2019-01-08/#SECURITY-1266)

  + Affects version 1.49 and earlier
* ###### [Script Security sandbox bypass](https://jenkins.io/security/advisory/2019-01-28/#SECURITY-1292)

  + Affects version 1.50 and earlier
* ###### [Script Security sandbox bypass](https://jenkins.io/security/advisory/2019-02-19/#SECURITY-1320)

  + Affects version 1.52 and earlier
* ###### [Script security sandbox bypass](https://jenkins.io/security/advisory/2019-03-06/#SECURITY-1336%20(1))

  + Affects version 1.53 and earlier
* ###### [Script Security sandbox bypass](https://jenkins.io/security/advisory/2019-03-25/#SECURITY-1353)

  + Affects version 1.55 and earlier
* ###### [Sandbox bypass through type casts](https://jenkins.io/security/advisory/2019-07-31/#SECURITY-1465%20(1))

  + Affects version 1.61 and earlier
* ###### [Sandbox bypass through method pointer expressions](https://jenkins.io/security/advisory/2019-07-31/#SECURITY-1465%20(2))

  + Affects version 1.61 and earlier
* ###### [Sandbox bypass vulnerability](https://jenkins.io/security/advisory/2019-09-12/#SECURITY-1538)

  + Affects version 1.62 and earlier
* ###### [Sandbox bypass vulnerability](https://jenkins.io/security/advisory/2019-10-01/#SECURITY-1579)

  + Affects version 1.64 and earlier
* ###### [Sandbox bypass vulnerability](https://jenkins.io/security/advisory/2019-11-21/#SECURITY-1658)

  + Affects version 1.67 and earlier
* ###### [Sandbox bypass vulnerability](https://jenkins.io/security/advisory/2020-02-12/#SECURITY-1713)

  + Affects version 1.69 and earlier
* ###### [Sandbox bypass vulnerability](https://jenkins.io/security/advisory/2020-03-09/#SECURITY-1754)

  + Affects version 1.70 and earlier
* ###### [Stored XSS vulnerability](https://jenkins.io/security/advisory/2020-06-03/#SECURITY-1866)

  + Affects version 1.72 and earlier
* ###### [Sandbox bypass vulnerability](https://www.jenkins.io/security/advisory/2020-09-23/#SECURITY-2020)

  + Affects version 1.74 and earlier
* ###### [CSRF vulnerability](https://www.jenkins.io/security/advisory/2022-05-17/#SECURITY-2116)

  + Affects version 1158.v7c1b\_73a\_69a\_08 and earlier
* ###### [Sandbox bypass vulnerability](https://www.jenkins.io/security/advisory/2022-10-19/#SECURITY-2824%20(1))

  + Affects version 1183.v774b\_0b\_0a\_a\_451 and earlier
* ###### [Whole-script approval vulnerable to SHA-1 collisions](https://www.jenkins.io/security/advisory/2022-11-15/#SECURITY-2564)

  + Affects version 1189.vb\_a\_b\_7c8fd5fde and earlier
* ###### [Sandbox bypass vulnerability](https://www.jenkins.io/security/advisory/2023-01-24/#SECURITY-3016)

  + Affects version 1228.vd93135a\_2fb\_25 and earlier
* ###### [Multiple sandbox bypass vulnerabilities](https://www.jenkins.io/security/advisory/2024-05-02/#SECURITY-3341)

  + Affects version 1335.vf07d9ce377a\_e and earlier
* ###### [Missing permission check](https://www.jenkins.io/security/advisory/2024-11-13/#SECURITY-3447)

  + Affects version 1367.vdf2fc45f229c and earlier
![tracker](https://jenkins-matomo.do.g4v.dev/piwik.php?idsite=1&rec=1&url=https://plugins.jenkins.io//script-security/)



=== Content from jenkins.io_ebfe8bef_20250125_135030.html ===


# Jenkins Security Advisory 2017-12-11

This advisory announces a vulnerability in this Jenkins plugin:

* [Script Security](https://plugins.jenkins.io/script-security)

## Description

### Arbitrary file read vulnerability in Script Security Plugin

**SECURITY-663 / CVE-2017-1000505**

Users with the ability to configure sandboxed Groovy and Pipeline scripts, including those from SCM, are able to use a type coercion feature in Groovy to create new `File` objects from strings. This allowed reading arbitrary files on the Jenkins controller file system.

Such a type coercion is now subject to sandbox protection and considered to be a call to the `new File(String)` constructor for the purpose of in-process script approval.

## Severity

* SECURITY-663: [medium](https://www.first.org/cvss/calculator/3.0#CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N)

## Affected versions

* Script Security Plugin up to and including 1.36

## Fix

* Script Security Plugin should be updated to version 1.37

These versions include fixes to the vulnerabilities described above.
All prior versions are considered to be affected by these vulnerabilities unless otherwise indicated.

## Credit

The Jenkins project would like to thank the reporter for discovering and [reporting](/security/#reporting-vulnerabilities) this vulnerability:

* **Gregory Draperi** for SECURITY-663


