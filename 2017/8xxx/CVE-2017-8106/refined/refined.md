Based on the provided information, here's an analysis of CVE-2017-8106:

**Root Cause of Vulnerability:**
The vulnerability stems from a flaw in the KVM (Kernel-based Virtual Machine) implementation within the Linux kernel, specifically in the handling of INVEPT (Invalidate EPT) instructions within nested virtualization scenarios.  The `handle_invept` function in `arch/x86/kvm/vmx.c` did not properly check if `current_vmcs12` was valid before attempting to access it.

**Weaknesses/Vulnerabilities Present:**
- **NULL Pointer Dereference:** The primary vulnerability is a NULL pointer dereference. The `handle_invept` function attempts to access `vmx->nested.current_vmcs12` without ensuring `current_vmptr` (which corresponds to `current_vmcs12`) is a valid address.
- **Missing Validation:** The code lacked a check to verify that the `current_vmcs12` pointer was valid before dereferencing it.
- **Specific Instruction Handling:** The vulnerability is triggered specifically when a guest VM issues a single-context INVEPT instruction *without* a preceding VMPTRLD (VM Pointer Load) instruction.

**Impact of Exploitation:**
- **Host Kernel Crash:** Successful exploitation leads to a kernel panic and crash of the host system due to a NULL pointer dereference. This causes a denial-of-service condition for the host and all guest VMs running on that host.

**Attack Vectors:**
- **Malicious Guest VM:** A malicious or buggy guest VM with nested virtualization capabilities can trigger the vulnerability by issuing a crafted INVEPT instruction sequence.
- **Nested Virtualization:**  The vulnerability is specific to scenarios using nested EPT (Extended Page Tables), which are used in nested virtualization.

**Required Attacker Capabilities/Position:**
- **Guest VM Access:** The attacker must have control over a guest virtual machine with nested virtualization enabled.
- **Privilege within guest:** The guest VM needs to be able to execute privileged instructions like INVEPT.
- **Specific Kernel Versions:** The host kernel must be a vulnerable version (Linux 3.12 to 3.15). In Ubuntu, this affects version 14.04 (Trusty).

**Technical Details and Descriptions:**
- The flawed code resides in `arch/x86/kvm/vmx.c` within the `handle_invept` function.
- The vulnerability is triggered when the guest issues `kvm_cpu_vmxon(phys_addr);` followed by `ept_sync_context(0);`
- The fix involved adding a check for a valid `current_vmptr` before accessing `current_vmcs12`:
```c
diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index d9e567f..d785e9c 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -6391,6 +6391,8 @@ static int handle_invept(struct kvm_vcpu *vcpu)
        switch (type) {
        case VMX_EPT_EXTENT_CONTEXT:
+               if (to_vmx(vcpu)->nested.current_vmptr == -1ull)
+                       break;
                if ((operand.eptp & eptp_mask) !=
                                (nested_ept_get_cr3(vcpu) & eptp_mask))
                        break;
```
- The vulnerability was introduced in commit `bfd0a56b90005f8c8a004baf407ad90045c2b11e` and fixed by `4b855078601fc422dbac3059f2215e776f49780f`
- The bug report includes a proof-of-concept C module that can be built and inserted into the guest OS to trigger the crash in the host.

**Additional Notes:**
- The provided information gives more details than a typical CVE description, including the exact code location and fix.
- The bug was initially reported on the kernel.org bugzilla and then on Launchpad for Ubuntu.
- The Ubuntu fix was released in kernel version `3.13.0-119.166` for the Trusty release (14.04).