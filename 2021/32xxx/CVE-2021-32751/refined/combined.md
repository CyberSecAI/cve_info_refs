=== Content from medium.com_63fd30cb_20250114_231945.html ===
[Open in app](https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2Fcc5f9e309cae&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---top_nav_layout_nav----------------------------------)

Sign up

[Sign in](/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2Fdot-debug%2Fthe-perils-of-bash-eval-cc5f9e309cae&source=post_page---top_nav_layout_nav-----------------------global_nav-----------)

[Write](/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---top_nav_layout_nav-----------------------new_post_topnav-----------)

Sign up

[Sign in](/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2Fdot-debug%2Fthe-perils-of-bash-eval-cc5f9e309cae&source=post_page---top_nav_layout_nav-----------------------global_nav-----------)

![](https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png)![]()

*The fateful moments aboard the Death Star prior to the power system running ‘eval’ against unsanitized user input. (Image credit:* [*Lusasfilm Ltd.*](http://lucasfilm.com/)*)*

# The perils of Bash ‘eval’

## Reflection injection.

[![Stephen Fox](https://miro.medium.com/v2/resize:fill:88:88/1*mYgLYp2Fa41iH44HHb5Xxw.jpeg)](/%40sf.debug?source=post_page---byline--cc5f9e309cae--------------------------------)[![.debug](https://miro.medium.com/v2/resize:fill:48:48/1*N8ctn64imp8yd1YbiL613g.png)](https://medium.com/dot-debug?source=post_page---byline--cc5f9e309cae--------------------------------)

[Stephen Fox](/%40sf.debug?source=post_page---byline--cc5f9e309cae--------------------------------)

·

[Follow](/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F63fb95db2753&operation=register&redirect=https%3A%2F%2Fmedium.com%2Fdot-debug%2Fthe-perils-of-bash-eval-cc5f9e309cae&user=Stephen+Fox&userId=63fb95db2753&source=post_page-63fb95db2753--byline--cc5f9e309cae---------------------post_header-----------)

Published in[.debug](https://medium.com/dot-debug?source=post_page---byline--cc5f9e309cae--------------------------------)·6 min read·Feb 2, 2017

--

1

Listen

Share

Bash is a “[macro processor that executes commands](https://www.gnu.org/software/bash/manual/bash.html#What-is-a-shell_003f)”, which can be used to solve problems in what amounts to concise, self-contained, text files. While this elegance is easily recognized by operations teams and system admins, it can be lost to developers that constantly work with object oriented programming languages. In my own experience of switching back and forth between Bash and Java, I felt compelled to apply object oriented programming principles to my Bash scripts.

The result of this was generally positive. For example, it led to separating massive blobs of code into concise functions, limiting the scope of variables, and creating more flexible logic.

Ironically, implementing those principles has sometimes led to my own detriment. I am almost universally told by other developers to compact my Bash code during code reviews. This is a fair criticism. When you spend enough time in development tools like IntelliJ or Visual Studio, the IDE practically does this for you before anyone else ever lays eyes on your code. With Bash — it is just you, and a text editor.

In the never ending cat and mouse game of compacting code, you will eventually find yourself reading about the [‘eval’ Bash builtin](https://www.gnu.org/software/bash/manual/bashref.html#Bourne-Shell-Builtins). Unfortunately, ‘eval’ is a very sharp knife, and many developers fail to explain why, let alone warn others of its dangers.

This post will explain and show why implementing ‘eval’ in your scripts is a really bad idea.

# What is ‘eval’?

To understand why ‘eval’ is dangerous, we must first understand what it is used for. As a tool, ‘eval’ is used to interpret (evaluate) strings into live logic. For example:

```
$ eval echo hello worldhello world
```

The command is not too dissimilar to reflection in programming. This lets you create variables dynamically at runtime. For example, you can create a variable whose name is the name of your current user:

```
$ echo "I am: ${root}"I am:$ eval 'export $(whoami)=$(whoami)'$ echo "I am: ${root}"I am: root
```

When you find yourself reading about ‘eval’, it is usually because your current logic has boxed you into one of the few use cases that ‘eval’ can quickly solve. Being a Bash builtin, it is reliably available. The command is also [commonly](http://www.thegeekstuff.com/2010/08/bash-shell-builtin-commands) [recommended](http://unix.stackexchange.com/a/282639) [online](http://stackoverflow.com/a/28183341). It can even be used to execute logic that would normally require several lines of code in a single line of code. These factors make implementing ‘eval’ into your scripts a very tempting proposition.

A significant portion of ‘eval’ examples fail to describe the dangers of implementing the command into your logic. If you are lucky, developers may drop subtle hints, such as [“use it cautiously” because it is “evil”](http://unix.stackexchange.com/a/222496). As a Bash newbie, I can attest to weighing these vague warnings against finishing a script and moving onto the next project. Without an adequate explanation, ‘eval’ presents an easy crutch to logic that should be restructured or rewritten.

# A really bad idea

Experienced Bash scripters will describe the outcome of implementing ‘eval’ in two different ways; a really bad idea, or consciously introducing a vulnerability into your script. While these concerns are exactly the same, neither actually *describe* why. In my opinion, an over-the-top implementation is needed to sufficiently illustrate why ‘eval’ is dangerous.

## The example

Assume that you are looking to create a script that provides a basic, network-accessible API. The goal of the API in this example will be to manage a file named ‘file.txt’ using our own ‘update’ and ‘remove’ commands.

## Design

The API will be accessible using HTTP on port 8080. In order to communicate with the API, users must know an “API key” (a special URL) to target. If the user does not provide a valid key, then the script will do nothing. If the user provides the key, but does not provide a valid command, then the script will do nothing. If the user provides a valid key and command, then the script will execute a command.

## Implementation

We can use netcat (‘nc’) to listen on a port for HTTP GET requests. To make things easy, we will write the output of ‘nc’ to a file and parse the file for valid requests. I have implemented the example in a Bash script named [**really-bad-idea.sh**](https://github.com/stephen-fox/eval-is-a-really-bad-idea/blob/master/really-bad-idea.sh):

## Running it

To start it, execute:

```
$ ./really-bad-idea.sh[INFO] netcat now listening on port 8080 as PID 768
[INFO] Make API calls to '<server-address>:8080/api/a15d24c3d4b585e84862dc46df98bd2f'
```

***Note****: You can press Control + C to stop the script gracefully.*

## Positive use case

First, let’s take a look at the positive use cases. You can make requests to the script using `curl` like so:

```
# Client request:
# Note: Make sure to use the API key that the script spits out.$ curl '127.0.0.1:8080/api/a15d24c3d4b585e84862dc46df98bd2f/update'
```

… you will see the following result on the server side:

```
# Server result:[INFO] Received API call: '/api/a15d24c3d4b585e84862dc46df98bd2f/update'
[INFO] Updating file...
```
## Saving a few lines of code

So far, the script meets the design requirements: it creates a public API that only validated users can utilize. Let’s take a look at the code again, specifically the lines that validate the API key in `parse_incoming_data()`:

```
eval local key="$(echo "${line}" | cut -f2 -d' ')" \
    && [ "${key%/*}" == "${G_API_KEY}" ] \
    && execute_api_call "${line}"
```

I used ‘eval’ here to declare a local variable containing the request’s URI. For context, a single HTTP call to netcat will spit out the following:

```
$ nc -l 8080GET /api/key/uri HTTP/1.1
Host: 127.0.0.1:8080
User-Agent: curl/7.43.0
Accept: */*
```

Since we are interested in the `/api/key/uri` string, it makes sense to just use ‘cut’ to grab it since there will never be spaces in the string. The end result here is that I used ‘eval’ to save a few lines of code. Yah!

## Not yay: Why ‘eval’ is a really bad idea

***Note****: All of the following testing is done in a disposable Docker container. Be careful if you are fooling around with this script on an important machine. I am not responsible if you delete something important.*

If you recall, ‘eval’ executes strings and can permit us some reflection-like abilities. Looking at the code, recall the `control_c` function that handles user shutdown gracefully:

```
# control_c
# Executes logic to handle a Control + C press by the user.
control_c() {
    G_USER_REQUESTED_SHUTDOWN=0
    echo ''
    shutdown
}
```

What do you think will happen if we send a ‘curl’ call containing `$(control_c)`? Let’s find out:

```
# Client request:
$ curl '127.0.0.1:8080/$(shutdown)'# Server result:
(...)
[ERROR] The listener has exited unexpectedly
```

Ut-oh. I do not think that was in the requirements! Well, what happens if we try touching a file?

```
# Client request:
$ curl '127.0.0.1:8080/$(touch${IFS}/not-good.txt)'# Server result:
$ ls -ltr /total 72
drwxr-xr-x   2 root root  4096 Nov  5 15:38 srv
drwxr-xr-x   2 root root  4096 Nov  5 15:38 opt
drwxr-xr-x   2 root root  4096 Nov  5 15:38 mnt
(...)
drwxrwxrwt   7 root root  4096 Feb  2 02:32 tmp
-rwxr-xr-x   1 root root  4163 Feb  2 02:34 really-bad-idea.sh
-rw-r--r--   1 root root     0 Feb  2 04:06 not-good.txt
```

As you can imagine, we can do some comical things like make the script delete itself:

```
# Client request:
$ curl '127.0.0.1:8080/$(rm${IFS}${PWD}/*.sh)'# Server result:
$ ls /really-bad-idea.shls: /really-bad-idea.sh: No such file or directory
```

While we are removing things we do not want, let’s delete the file system:

```
# WARNING: THE FOLLOWING COMMAND WILL DELETE YOUR COMPUTER. DO NOT RUN THIS UNLESS YOU ARE IN A TEST ENVIRONMENT.# Client request:
$ curl '127.0.0.1:8080/$(rm${IFS}-rf${IFS}/*)'# Server result:
(...)
[INFO] Make API calls to '<server-address>:8080/api/104d01cba6f4b74051901ca500a2650a'
rm: cannot remove '/dev/console': Device or resource busy
rm: cannot remove '/dev/shm': Device or resource busy
rm: cannot remove '/dev/mqueue': Device or resource busy
rm: cannot remove '/dev/pts/ptmx': Operation not permitted
rm: cannot remove '/etc/hosts': Device or resource busy
rm: cannot remove '/etc/resolv.conf': Device or resource busy
rm: cannot remove '/etc/hostname': Device or resource busy
rm: cannot remove '/proc/fb': Operation not permitted
(...)
./really-bad-idea.sh: line 48: /tmp/listener.log: No such file or directory
./really-bad-idea.sh: line 54: /usr/bin/sleep: No such file or directory
./really-bad-idea.sh: line 48: /tmp/listener.log: No such file or directory
./really-bad-idea.sh: line 54: /usr/bin/sleep: No such file or directory
(...)
```
# Closing arguments

Bash provides a powerful toolbox full of sharp knives. The ‘eval’ command is just one of those knives. If you must absolutely use Bash in a sensitive environment, please make sure you do everything possible to either isolate it from user input or sanitize the user input first.

Whatever you do, do not use ‘eval’ unless you want to end up like my Docker containers.

[Docker](/tag/docker?source=post_page-----cc5f9e309cae--------------------------------)[DevOps](/tag/devops?source=post_page-----cc5f9e309cae--------------------------------)[Bash](/tag/bash?source=post_page-----cc5f9e309cae--------------------------------)[Security](/tag/security?source=post_page-----cc5f9e309cae--------------------------------)[Information Security](/tag/information-security?source=post_page-----cc5f9e309cae--------------------------------)

--

--

1

[![.debug](https://miro.medium.com/v2/resize:fill:96:96/1*N8ctn64imp8yd1YbiL613g.png)](https://medium.com/dot-debug?source=post_page---post_publication_info--cc5f9e309cae--------------------------------)[![.debug](https://miro.medium.com/v2/resize:fill:128:128/1*N8ctn64imp8yd1YbiL613g.png)](https://medium.com/dot-debug?source=post_page---post_publication_info--cc5f9e309cae--------------------------------)[## Published in .debug](https://medium.com/dot-debug?source=post_page---post_publication_info--cc5f9e309cae--------------------------------)[73 Followers](/dot-debug/followers?source=post_page---post_publication_info--cc5f9e309cae--------------------------------)·[Last published Oct 19, 2017](/dot-debug/what-is-that-golang-thing-anyways-e8063b017611?source=post_page---post_publication_info--cc5f9e309cae--------------------------------)

Software development, security, and more.

[![Stephen Fox](https://miro.medium.com/v2/resize:fill:96:96/1*mYgLYp2Fa41iH44HHb5Xxw.jpeg)](/%40sf.debug?source=post_page---post_author_info--cc5f9e309cae--------------------------------)[![Stephen Fox](https://miro.medium.com/v2/resize:fill:128:128/1*mYgLYp2Fa41iH44HHb5Xxw.jpeg)](/%40sf.debug?source=post_page---post_author_info--cc5f9e309cae--------------------------------)Follow[## Written by Stephen Fox](/%40sf.debug?source=post_page---post_author_info--cc5f9e309cae--------------------------------)[67 Followers](/%40sf.debug/followers?source=post_page---post_author_info--cc5f9e309cae--------------------------------)·[3 Following](/%40sf.debug/following?source=post_page---post_author_info--cc5f9e309cae--------------------------------)

Software developer and release engineer.

Follow
## Responses (1)

See all responses[Help](https://help.medium.com/hc/en-us?source=post_page-----cc5f9e309cae--------------------------------)[Status](https://medium.statuspage.io/?source=post_page-----cc5f9e309cae--------------------------------)[About](/about?autoplay=1&source=post_page-----cc5f9e309cae--------------------------------)[Careers](/jobs-at-medium/work-at-medium-959d1a85284e?source=post_page-----cc5f9e309cae--------------------------------)[Press](pressinquiries%40medium.com?source=post_page-----cc5f9e309cae--------------------------------)[Blog](https://blog.medium.com/?source=post_page-----cc5f9e309cae--------------------------------)[Privacy](https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----cc5f9e309cae--------------------------------)[Terms](https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----cc5f9e309cae--------------------------------)[Text to speech](https://speechify.com/medium?source=post_page-----cc5f9e309cae--------------------------------)[Teams](/business?source=post_page-----cc5f9e309cae--------------------------------)



=== Content from mywiki.wooledge.org_fad3704c_20250114_231947.html ===


Search:

[![MoinMoin Logo](/moin_static1911/common/moinmoin.png)](/EnglishFrontPage)
[Login](/BashFAQ/048?action=login)
# [BashFAQ](/BashFAQ)/[048](/BashFAQ/048)

* [BashGuide](/BashGuide)
* [BashFAQ](/BashFAQ)
* [RecentChanges](/RecentChanges)
* [FindPage](/FindPage)
* [HelpContents](/HelpContents)
* [BashFAQ/048](/BashFAQ/048)

---

* [Edit](/BashFAQ/048?action=edit&editor=text)
* Comments
* [Info](/BashFAQ/048?action=info)
* [Attachments](/BashFAQ/048?action=AttachFile)
* More Actions:
  Raw Text
  Print View
  Render as Docbook
  Delete Cache
  ------------------------
  Check Spelling
  Like Pages
  Local Site Map
  ------------------------
  Rename Page
  Delete Page
  ------------------------
  Subscribe User
  ------------------------
  Remove Spam
  Revert to this revision
  Package Pages
  Sync Pages
  ------------------------
  Load
  Save
  SlideShow

## Eval command and security issues

The eval command is extremely powerful and extremely easy to abuse.

It causes your code to be parsed twice instead of once; this means that, for example, if your code has variable references in it, the shell's parser will evaluate the contents of that variable. If the variable contains a shell command, the shell might run that command, whether you wanted it to or not. This can lead to unexpected results, especially when variables can be read from untrusted sources (like users or user-created files).

### Examples of bad use of eval

"eval" is a common misspelling of "evil".

One of the most common reasons people try to use eval is because they want to pass the name of a variable to a function. Consider:

```
# This code is evil and should never be used!
fifth() {
    _fifth_array=$1
    eval echo "\"The fifth element is \${$_fifth_array[4]}\""    # DANGER!
}
a=(zero one two three four five)
fifth a
```

This breaks if the user is allowed to pass arbitary arguments to the function:

```
$ fifth 'x}"; date; #'
The fifth element is
Thu Mar 27 16:13:47 EDT 2014
```

We've just allowed arbitary code execution. Bash 4.3 introduced *name references* to try to solve this problem, but unfortunately they **don't** solve the problem! We'll discuss those in depth later.

Now let's consider a more complicated example. The section of this FAQ dealing with [spaces in file names](/BashFAQ/020) used to include the following "helpful tool (which is probably not as safe as the \0 technique)".

```
Syntax : nasty_find_all <path> <command> [maxdepth]
```

```
# This code is evil and must never be used!
export IFS=" "
[ -z "$3" ] && set -- "$1" "$2" 1
FILES=`find "$1" -maxdepth "$3" -type f -printf "\"%p\" "`
# warning, BAD code
eval FILES=($FILES)
for ((I=0; I < ${#FILES[@]}; I++))
do
    eval "$2 \"${FILES[I]}\""
done
unset IFS
```

This script was supposed to recursively search for files and run a user-specified command on them, even if they had newlines and/or spaces in their names. The author thought that find -print0 | xargs -0 was unsuitable for some purposes such as multiple commands. It was followed by an instructional description of all the lines involved, which we'll skip.

To its defense, it worked:
```
$ ls -lR
.:
total 8
drwxr-xr-x  2 vidar users 4096 Nov 12 21:51 dir with spaces
-rwxr-xr-x  1 vidar users  248 Nov 12 21:50 nasty_find_all

./dir with spaces:
total 0
-rw-r--r--  1 vidar users 0 Nov 12 21:51 file?with newlines
$ ./nasty_find_all . echo 3
./nasty_find_all
./dir with spaces/file
with newlines
$
```

But consider this:
```
$ touch "\"); ls -l $'\x2F'; #"
```

You just created a file called  "); ls -l $'\x2F'; #

Now FILES will contain  ""); ls -l $'\x2F'; #. When we do eval FILES=($FILES), it becomes
```
FILES=(""); ls -l $'\x2F'; #"
```

Which becomes the two statements  FILES=("");  and  ls -l / . Congratulations, you just allowed execution of arbitrary commands.

```
$ touch "\"); ls -l $'\x2F'; #"
$ ./nasty_find_all . echo 3
total 1052
-rw-r--r--   1 root root 1018530 Apr  6  2005 System.map
drwxr-xr-x   2 root root    4096 Oct 26 22:05 bin
drwxr-xr-x   3 root root    4096 Oct 26 22:05 boot
drwxr-xr-x  17 root root   29500 Nov 12 20:52 dev
drwxr-xr-x  68 root root    4096 Nov 12 20:54 etc
drwxr-xr-x   9 root root    4096 Oct  5 11:37 home
drwxr-xr-x  10 root root    4096 Oct 26 22:05 lib
drwxr-xr-x   2 root root    4096 Nov  4 00:14 lost+found
drwxr-xr-x   6 root root    4096 Nov  4 18:22 mnt
drwxr-xr-x  11 root root    4096 Oct 26 22:05 opt
dr-xr-xr-x  82 root root       0 Nov  4 00:41 proc
drwx------  26 root root    4096 Oct 26 22:05 root
drwxr-xr-x   2 root root    4096 Nov  4 00:34 sbin
drwxr-xr-x   9 root root       0 Nov  4 00:41 sys
drwxrwxrwt   8 root root    4096 Nov 12 21:55 tmp
drwxr-xr-x  15 root root    4096 Oct 26 22:05 usr
drwxr-xr-x  13 root root    4096 Oct 26 22:05 var
./nasty_find_all
./dir with spaces/file
with newlines
./
$
```

It doesn't take much imagination to replace  ls -l  with  rm -rf  or worse.

One might think these circumstances are obscure, but one should not be tricked by this. All it takes is one malicious user, or perhaps more likely, a benign user who left the terminal unlocked when going to the bathroom, or wrote a funny PHP uploading script that doesn't sanity check file names, or who made the same mistake as oneself in allowing arbitrary code execution (now instead of being limited to the www-user, an attacker can use nasty\_find\_all to traverse chroot jails and/or gain additional privileges), or uses an IRC or IM client that's too liberal in the filenames it accepts for file transfers or conversation logs, etc.

### The problem with bash's name references

Bash 4.3 introduced declare -n ("name references") to mimic Korn shell's nameref feature, which permits variables to hold references to other variables (see [FAQ 006](/BashFAQ/006) to see these in action). Unfortunately, the implementation used in Bash has some issues.

First, Bash's declare -n doesn't actually avoid the name collision issue:

```
$ foo() { declare -n v=$1; }
$ bar() { declare -n v=$1; foo v; }
$ bar v
bash: warning: v: circular name reference
```

In other words, there is no safe name we can give to the name reference. If the caller's variable happens to have the same name, we're screwed. Well, not completely screwed, but you need to use a trick one cannot help but think should not be necessary. You can avoid the circularity by using declare only if the names do not clash (if they do clash, then v, here, is simply a direct reference to caller's v):

```
$ foo() { if [[ $1 != v ]]; then declare -n v=$1; fi; echo $v; }
$ bar() { if [[ $1 != v ]]; then declare -n v=$1; fi; foo v; }
$ v="xyz"
$ bar v
xyz
```

Second, Bash's name reference implementation still allows *arbitrary code execution*:

```
$ foo() { declare -n var=$1; echo "$var"; }
$ foo 'x[i=$(date)]'
bash: i=Thu Mar 27 16:34:09 EDT 2014: syntax error in expression (error token is "Mar 27 16:34:09 EDT 2014")
```

It's not an elegant example, but you can clearly see that the date command was actually *executed*. This is not at all what one wants.

Now, despite these shortcomings, the declare -n feature is a step in the right direction. But you must be careful to select a name that the caller won't use (which means you need *some* control over the caller, if only to say "don't use variables that begin with \_my\_pkg" -- or unless you use the conditional workaround), and you must reject unsafe inputs.

### Examples of good use of eval

The most common correct use of eval is reading variables from the output of a program which is **specifically *designed* to be used this way**. For example,

```
# On older systems, one must run this after resizing a window:
eval "`resize`"

# Less primitive: get a passphrase for an SSH private key.
# This is typically executed from a .xsession or .profile type of file.
# The variables produced by ssh-agent will be exported to all the processes in
# the user's session, so that an eventual ssh will inherit them.
eval "`ssh-agent -s`"
```

eval has other uses especially when creating variables out of the blue ([indirect variable references](/BashFAQ/006)). Here is an example of one way to parse command line options that do not take parameters:

```
# POSIX
#
# Create option variables dynamically. Try call:
#
#    sh -x example.sh --verbose --test --debug

for i; do
    case $i in
       --test|--verbose|--debug)
            shift                   # Remove option from command line
            name=${i#--}            # Delete option prefix
            eval "$name=\$name"     # make *new* variable
            ;;
    esac
done

echo "verbose: $verbose"
echo "test: $test"
echo "debug: $debug"
```

So, why is this version acceptable? It's acceptable because we have restricted the eval command so that it will **only** be executed when the input is one of a finite set of known values. Therefore, it can't ever be abused by the user to cause arbitrary command execution -- any input with funny stuff in it wouldn't match one of the three predetermined possible inputs.

Note that this is **still frowned upon**: It is a slippery slope and some later maintenance can easily turn this code into something dangerous. Eg. You want to *add a feature* that allows a bunch of different --test-xyz's to be passed. You change --test to --test-\*, without going through the trouble of checking the implementation of the rest of the script. You test your use case and it all works. Unfortunately, **you've just introduced arbitrary command execution**:

```
$ ./foo --test-'; ls -l /etc/passwd;x='
-rw-r--r-- 1 root root 943 2007-03-28 12:03 /etc/passwd
```

Once again: by permitting the eval command to be used on unfiltered user input, we've permitted arbitrary command execution.

**AVOID PASSING DATA TO EVAL AT ALL COSTS**, even if your code seems to handle all the edge cases today.

If you have thought really hard and asked #bash for an alternative way but there isn't any, skip ahead to "Robust eval usage".

### The problem with declare

Could this not be done better with declare?

```
for i in "$@"
do
    case $i in
        --test|--verbose|--debug)
            shift                   # Remove option from command line
            name=${i#--}            # Delete option prefix
            declare $name=Yes       # set default value
            ;;
        --test=*|--verbose=*|--debug=*)
            shift
            name=${i#--}
            value=${name#*=}        # value is whatever's after first word and =
            name=${name%%=*}        # restrict name to first word only (even if there's another = in the value)
            declare $name="$value"  # make *new* variable
            ;;
    esac
done
```

*Note that --name for a default, and --name=value are the required formats.*

declare does work better for some inputs:
```
griffon:~$ name='foo=x;date;x'
griffon:~$ declare $name=Yes
griffon:~$ echo $foo
x;date;x=Yes
```

But it can still cause arbitary code execution with array variables:
```
attoparsec:~$ echo $BASH_VERSION
4.2.24(1)-release
attoparsec:~$ danger='( $(printf "%s!\n" DANGER >&2) )'
attoparsec:~$ declare safe=${danger}
attoparsec:~$ declare -a unsafe
attoparsec:~$ declare unsafe=${danger}
DANGER!
```

### Robust eval usage

Almost always (at least 99% or more of the time in Bash, but also in more minimal shells), the correct way to use eval is to produce abstractions hidden behind functions used in library code. This allows the function to:

* present a well-defined interface to the function's caller that specifies which inputs must be strictly controlled by the programmer, and which may be unpredictable, such as side-effects influenced by user input. It's important to document which options and arguments are unsafe if left uncontrolled.
* perform input validation on certain kinds of inputs where it's feasible to do so, such as integers -- where it's easy to bail out and return an error status which can be handled by the function caller.
* create abstractions that hide ugly implementation details involving eval.

Generally, eval is correct when at least all of the following are satisfied:

* All possible arguments to eval are guaranteed not to produce harmful side-effects or result in execution of arbitrary code under any circumstance. The inputs are statically coded, free from interaction with uncontrolled dynamic code, and/or validated throughly. This is why functions are important, because YOU don't necessarily have to make that guarantee yourself. So long as your function documents what inputs can be dangerous, you can delegate that task to the function's caller.
* The eval usage presents a clean interface to the user or programmer.
* The eval makes possible what would otherwise be impossible without far more large, slow, complex, dangerous, ugly, less useful code.

If for some reason you still need to dynamically build bash code and evaluate it, make certain you take these precautions:

1. Always **quote** the eval expression: eval 'a=b'
2. Always **single-quote** code and expand your data into it using printf's %q: eval "$(printf 'myvar=%q' "$value")"
3. Do NOT use dynamic variable names. Even with careful %q usage, this can be exploited.

Why take heed? Here's how your scripts can be exploited if they fail to take the above advice:

* If you don't single-quote your code, you run the risk of expanding data into it that isn't %q'ed. Which means free executable reign for that data:
* ```
  name='Bob; echo I am arbitrary code'; eval "user=$name"
  ```
* Even if you %q input data before treating it as a variable name, illegal variable names in assignments cause bash to search PATH for a command:
* ```
  echo 'echo I am arbitrary code' > /usr/local/bin/a[1]=b; chmod +x /usr/local/bin/a[1]=b; var='a[1]' value=b; eval "$(printf '%q=%q' "$var" "$value")"
  ```
* For a list of ways to reference or to populate variables indirectly **without** using eval, please see [BashFAQ/006](/BashFAQ/006).
* For a list of ways to reference or to populate variables indirectly **with** eval, please see [BashFAQ/006#eval](/BashFAQ/006#eval).
* [More examples](http://wiki.bash-hackers.org/commands/builtin/eval)

---

BashFAQ/048 (last edited 2024-12-04 21:34:43 by [GreyCat](/GreyCat "GreyCat @ 67.144.189.164[67.144.189.164]"))

* [Edit](/BashFAQ/048?action=edit&editor=text)
* Comments
* [Info](/BashFAQ/048?action=info)
* [Attachments](/BashFAQ/048?action=AttachFile)
* More Actions:
  Raw Text
  Print View
  Render as Docbook
  Delete Cache
  ------------------------
  Check Spelling
  Like Pages
  Local Site Map
  ------------------------
  Rename Page
  Delete Page
  ------------------------
  Subscribe User
  ------------------------
  Remove Spam
  Revert to this revision
  Package Pages
  Sync Pages
  ------------------------
  Load
  Save
  SlideShow

* [MoinMoin Powered](http://moinmo.in/ "This site uses the MoinMoin Wiki software.")
* [Python Powered](http://moinmo.in/Python "MoinMoin is written in Python.")
* [GPL licensed](http://moinmo.in/GPL "MoinMoin is GPL licensed.")
* [Valid HTML 4.01](http://validator.w3.org/check?uri=referer "Click here to validate this page.")



=== Content from github.com_84a82806_20250114_231944.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fgradle%2Fgradle%2Fsecurity%2Fadvisories%2FGHSA-6j2p-252f-7mw8)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fgradle%2Fgradle%2Fsecurity%2Fadvisories%2FGHSA-6j2p-252f-7mw8)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=gradle%2Fgradle)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[gradle](/gradle)
/
**[gradle](/gradle/gradle)**
Public

* [Notifications](/login?return_to=%2Fgradle%2Fgradle) You must be signed in to change notification settings
* [Fork
  4.8k](/login?return_to=%2Fgradle%2Fgradle)
* [Star
   17.2k](/login?return_to=%2Fgradle%2Fgradle)

* [Code](/gradle/gradle)
* [Issues
  2.9k](/gradle/gradle/issues)
* [Pull requests
  146](/gradle/gradle/pulls)
* [Actions](/gradle/gradle/actions)
* [Projects
  3](/gradle/gradle/projects)
* [Security](/gradle/gradle/security)
* [Insights](/gradle/gradle/pulse)

Additional navigation options

* [Code](/gradle/gradle)
* [Issues](/gradle/gradle/issues)
* [Pull requests](/gradle/gradle/pulls)
* [Actions](/gradle/gradle/actions)
* [Projects](/gradle/gradle/projects)
* [Security](/gradle/gradle/security)
* [Insights](/gradle/gradle/pulse)

# Arbitrary code execution via specially crafted environment variables

High

[big-guy](/big-guy)
published
GHSA-6j2p-252f-7mw8
Jul 20, 2021

## Package

Gradle
(Java)

## Affected versions

<7.2

## Patched versions

7.2

## Description

### Impact

[Start scripts generated by the `application` plugin](https://docs.gradle.org/current/userguide/application_plugin.html#header) and the [`gradlew` script](https://docs.gradle.org/current/userguide/gradle_wrapper.html#header) are both vulnerable to arbitrary code execution when an attacker is able to change environment variables for the user running the script.

This may impact you if you use `gradlew` on Unix-like systems or use the scripts generated by Gradle in your application on Unix-like systems.

For `gradlew`, commands can be included in either `JAVA_OPTS` or `GRADLE_OPTS`.

For start scripts, commands can be included in either `JAVA_OPTS` or `<APP_NAME>_OPTS`.

For example, if a command is added to `JAVA_OPTS` and the user runs a Gradle build:

```
$ export JAVA_OPTS='-Xmx512m $(touch foo)'
$ ./gradlew build

```

This will execute `touch foo`, but any command will work here. When determining the command-line for the Java process that is started by the script, any commands found in these environment variables will be executed as the user running the script.

For this vulnerability to be exploitable, an attacker needs to be able to set the value of particular environment variables and have those environment variables be seen by the vulnerable scripts.

This vulnerability was found during a security audit. We do not know of any exploits based on this vulnerability.

### Patches

This issue has been patched in Gradle 7.2 by updating our start script template.

### Workarounds

#### CI/CD systems using the Gradle build tool

You are not vulnerable if untrusted users are unable to change environment variables for the user that executes `gradlew`.

If you are unable to upgrade to Gradle 7.2, you can generate a new `gradlew` script with Gradle 7.2 and use it for older versions of Gradle.

#### Applications using start scripts generated by Gradle

You are not vulnerable if untrusted users are unable to change environment variables for the user that executes the start script.

If you are unsure, the vulnerable start script could be manually patched to remove the use of `eval` or the use of environment variables that affect the application's command-line.

If the application is simple enough, you may be able to avoid the use of the start scripts by running the application directly with Java command.

### References

* [Eval command and security issues](https://mywiki.wooledge.org/BashFAQ/048)
* [The perils of Bash 'eval'](https://medium.com/dot-debug/the-perils-of-bash-eval-cc5f9e309cae)

### Questions?

* For security related issues, please email us at security@gradle.com.
* For non-security related issues, please open an issue on [GitHub](https://github.com/gradle/gradle/issues/new/choose).

### Severity

High

### CVE ID

CVE-2021-32751

### Weaknesses

[CWE-78](/advisories?query=cwe%3A78)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


