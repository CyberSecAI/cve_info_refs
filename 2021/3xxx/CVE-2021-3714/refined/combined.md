=== Content from arxiv.org_17665883_20250114_183408.html ===

[Skip to main content](#content)

[![Cornell University](/static/browse/0.3.4/images/icons/cu/cornell-reduced-white-SMALL.svg)](https://www.cornell.edu/)
We gratefully acknowledge support from the Simons Foundation, [member institutions](https://info.arxiv.org/about/ourmembers.html), and all contributors.
[Donate](https://info.arxiv.org/about/donate.html)

[![arxiv logo](/static/browse/0.3.4/images/arxiv-logo-one-color-white.svg)](/) > [cs](/list/cs/recent) > arXiv:2111.08553

[Help](https://info.arxiv.org/help) | [Advanced Search](https://arxiv.org/search/advanced)

All fields
Title
Author
Abstract
Comments
Journal reference
ACM classification
MSC classification
Report number
arXiv identifier
DOI
ORCID
arXiv author ID
Help pages
Full text

Search

[![arXiv logo](/static/browse/0.3.4/images/arxiv-logomark-small-white.svg)](https://arxiv.org/)
[![Cornell University Logo](/static/browse/0.3.4/images/icons/cu/cornell-reduced-white-SMALL.svg)](https://www.cornell.edu/)
open search

GO

open navigation menu
## quick links

* [Login](https://arxiv.org/login)
* [Help Pages](https://info.arxiv.org/help)
* [About](https://info.arxiv.org/about)

# Computer Science > Cryptography and Security

**arXiv:2111.08553** (cs)

[Submitted on 16 Nov 2021]
# Title:Remote Memory-Deduplication Attacks

Authors:[Martin Schwarzl](https://arxiv.org/search/cs?searchtype=author&query=Schwarzl,+M), [Erik Kraft](https://arxiv.org/search/cs?searchtype=author&query=Kraft,+E), [Moritz Lipp](https://arxiv.org/search/cs?searchtype=author&query=Lipp,+M), [Daniel Gruss](https://arxiv.org/search/cs?searchtype=author&query=Gruss,+D) View a PDF of the paper titled Remote Memory-Deduplication Attacks, by Martin Schwarzl and 3 other authors
[View PDF](/pdf/2111.08553)
> Abstract:Memory utilization can be reduced by merging identical memory blocks into copy-on-write mappings. Previous work showed that this so-called memory deduplication can be exploited in local attacks to break ASLR, spy on other programs,and determine the presence of data, i.e., website images. All these attacks exploit memory deduplication across security domains, which in turn was disabled. However, within a security domain or on an isolated system with no untrusted local access, memory deduplication is still not considered a security risk and was recently re-enabled on Windows by default.
>
> In this paper, we present the first fully remote memorydeduplication attacks. Unlike previous attacks, our attacks require no local code execution. Consequently, we can disclose memory contents from a remote server merely by sending and timing HTTP/1 and HTTP/2 network requests. We demonstrate our attacks on deduplication both on Windows and Linux and attack widely used server software such as Memcached and InnoDB. Our side channel leaks up to 34.41 B/h over the internet, making it faster than comparable remote memory-disclosure channels. We showcase our remote memory-deduplication attack in three case studies: First, we show that an attacker can disclose the presence of data in memory on a server running Memcached. We show that this information disclosure channel can also be used for fingerprinting and detect the correct libc version over the internet in 166.51 s. Second, in combination with InnoDB, we present an information disclosure attack to leak MariaDB database records. Third, we demonstrate a fully remote KASLR break in less than 4 minutes allowing to derandomize the kernel image of a virtual machine over the Internet, i.e., 14 network hops away. We conclude that memory deduplication must also be considered a security risk if only applied within a single security domain.

| Subjects: | Cryptography and Security (cs.CR) |
| --- | --- |
| Cite as: | [arXiv:2111.08553](https://arxiv.org/abs/2111.08553) [cs.CR] |
|  | (or  [arXiv:2111.08553v1](https://arxiv.org/abs/2111.08553v1) [cs.CR] for this version) |
|  | <https://doi.org/10.48550/arXiv.2111.08553>  Focus to learn more    arXiv-issued DOI via DataCite |

## Submission history

From: Martin Schwarzl [[view email](/show-email/3984ab55/2111.08553)]

Full-text links:
## Access Paper:

View a PDF of the paper titled Remote Memory-Deduplication Attacks, by Martin Schwarzl and 3 other authors* [View PDF](/pdf/2111.08553)
* [TeX Source](/src/2111.08553)
* [Other Formats](/format/2111.08553)

[![license icon](https://arxiv.org/icons/licenses/by-4.0.png)
view license](http://creativecommons.org/licenses/by/4.0/ "Rights to this article")

Current browse context: cs.CR
[< prev](/prevnext?id=2111.08553&function=prev&context=cs.CR "previous in cs.CR (accesskey p)")

  |
[next >](/prevnext?id=2111.08553&function=next&context=cs.CR "next in cs.CR (accesskey n)")

[new](/list/cs.CR/new)
 |
[recent](/list/cs.CR/recent)
 | [2021-11](/list/cs.CR/2021-11)
Change to browse by:
[cs](/abs/2111.08553?context=cs)

### References & Citations

* [NASA ADS](https://ui.adsabs.harvard.edu/abs/arXiv%3A2111.08553)
* [Google Scholar](https://scholar.google.com/scholar_lookup?arxiv_id=2111.08553)
* [Semantic Scholar](https://api.semanticscholar.org/arXiv%3A2111.08553)

### [DBLP](https://dblp.uni-trier.de) - CS Bibliography

[listing](https://dblp.uni-trier.de/db/journals/corr/corr2111.html#abs-2111-08553 "listing on DBLP") | [bibtex](https://dblp.uni-trier.de/rec/bibtex/journals/corr/abs-2111-08553 "DBLP bibtex record")
[Martin Schwarzl](https://dblp.uni-trier.de/search/author?author=Martin%20Schwarzl "DBLP author search")

[a](/static/browse/0.3.4/css/cite.css)
export BibTeX citation
Loading...

## BibTeX formatted citation

×

loading...

Data provided by:

### Bookmark

[![BibSonomy logo](/static/browse/0.3.4/images/icons/social/bibsonomy.png)](http://www.bibsonomy.org/BibtexHandler?requTask=upload&url=https://arxiv.org/abs/2111.08553&description=Remote Memory-Deduplication Attacks "Bookmark on BibSonomy")
[![Reddit logo](/static/browse/0.3.4/images/icons/social/reddit.png)](https://reddit.com/submit?url=https://arxiv.org/abs/2111.08553&title=Remote Memory-Deduplication Attacks "Bookmark on Reddit")

Bibliographic Tools
# Bibliographic and Citation Tools

Bibliographic Explorer Toggle

Bibliographic Explorer *([What is the Explorer?](https://info.arxiv.org/labs/showcase.html#arxiv-bibliographic-explorer))*

Connected Papers Toggle

Connected Papers *([What is Connected Papers?](https://www.connectedpapers.com/about))*

Litmaps Toggle

Litmaps *([What is Litmaps?](https://www.litmaps.co/))*

scite.ai Toggle

scite Smart Citations *([What are Smart Citations?](https://www.scite.ai/))*

Code, Data, Media
# Code, Data and Media Associated with this Article

alphaXiv Toggle

alphaXiv *([What is alphaXiv?](https://alphaxiv.org/))*

Links to Code Toggle

CatalyzeX Code Finder for Papers *([What is CatalyzeX?](https://www.catalyzex.com))*

DagsHub Toggle

DagsHub *([What is DagsHub?](https://dagshub.com/))*

GotitPub Toggle

Gotit.pub *([What is GotitPub?](http://gotit.pub/faq))*

Huggingface Toggle

Hugging Face *([What is Huggingface?](https://huggingface.co/huggingface))*

Links to Code Toggle

Papers with Code *([What is Papers with Code?](https://paperswithcode.com/))*

ScienceCast Toggle

ScienceCast *([What is ScienceCast?](https://sciencecast.org/welcome))*

Demos
# Demos

Replicate Toggle

Replicate *([What is Replicate?](https://replicate.com/docs/arxiv/about))*

Spaces Toggle

Hugging Face Spaces *([What is Spaces?](https://huggingface.co/docs/hub/spaces))*

Spaces Toggle

TXYZ.AI *([What is TXYZ.AI?](https://txyz.ai))*

Related Papers
# Recommenders and Search Tools

Link to Influence Flower

Influence Flower *([What are Influence Flowers?](https://influencemap.cmlab.dev/))*

Core recommender toggle

CORE Recommender *([What is CORE?](https://core.ac.uk/services/recommender))*

* Author
* Venue
* Institution
* Topic

About arXivLabs

# arXivLabs: experimental projects with community collaborators

arXivLabs is a framework that allows collaborators to develop and share new arXiv features directly on our website.

Both individuals and organizations that work with arXivLabs have embraced and accepted our values of openness, community, excellence, and user data privacy. arXiv is committed to these values and only works with partners that adhere to them.

Have an idea for a project that will add value for arXiv's community? [**Learn more about arXivLabs**](https://info.arxiv.org/labs/index.html).

[Which authors of this paper are endorsers?](/auth/show-endorsers/2111.08553) |
Disable MathJax ([What is MathJax?](https://info.arxiv.org/help/mathjax.html))

* [About](https://info.arxiv.org/about)
* [Help](https://info.arxiv.org/help)

* contact arXivClick here to contact arXiv
   [Contact](https://info.arxiv.org/help/contact.html)
* subscribe to arXiv mailingsClick here to subscribe
   [Subscribe](https://info.arxiv.org/help/subscribe)

* [Copyright](https://info.arxiv.org/help/license/index.html)
* [Privacy Policy](https://info.arxiv.org/help/policies/privacy_policy.html)

* [Web Accessibility Assistance](https://info.arxiv.org/help/web_accessibility.html)
* [arXiv Operational Status](https://status.arxiv.org)

  Get status notifications via
  [email](https://subscribe.sorryapp.com/24846f03/email/new)
  or [slack](https://subscribe.sorryapp.com/24846f03/slack/new)



=== Content from arxiv.org_98b91eb1_20250115_112818.html ===
Remote Memory-Deduplication Attacks

Martin Schwarzl
Graz University of Technology
martin.schwarzl@iaik.tugraz.at

Erik Kraft
Graz University of Technology
erik.kraft5@gmx.at

Moritz Lipp
Graz University of Technology
moritz.lipp@iaik.tugraz.at

Daniel Gruss
Graz University of Technology
daniel.gruss@iaik.tugraz.at

1
2
0
2

v
o
N
6
1

]

R
C
.
s
c
[

1
v
3
5
5
8
0
.
1
1
1
2
:
v
i
X
r
a

Abstract—Memory utilization can be reduced by merging
identical memory blocks into copy-on-write mappings. Previous
work showed that this so-called memory deduplication can be
exploited in local attacks to break ASLR, spy on other programs,
and determine the presence of data, i.e., website images. All these
attacks exploit memory deduplication across security domains,
which in turn was disabled. However, within a security domain
or on an isolated system with no untrusted local access, memory
deduplication is still not considered a security risk and was
recently re-enabled on Windows by default.

In this paper, we present the ﬁrst fully remote memory-
deduplication attacks. Unlike previous attacks, our attacks re-
quire no local code execution. Consequently, we can disclose mem-
ory contents from a remote server merely by sending and timing
HTTP/1 and HTTP/2 network requests. We demonstrate our
attacks on deduplication both on Windows and Linux and attack
widely used server software such as Memcached and InnoDB. Our
side channel leaks up to 34.41 B/h over the internet, making
it faster than comparable remote memory-disclosure channels.
We showcase our remote memory-deduplication attack in three
case studies: First, we show that an attacker can disclose the
presence of data in memory on a server running Memcached.
We show that this information disclosure channel can also be
used for ﬁngerprinting and detect the correct libc version over
the internet in 166.51 s. Second, in combination with InnoDB,
we present an information disclosure attack to leak MariaDB
database records. Third, we demonstrate a fully remote KASLR
break in less than 4 minutes allowing to derandomize the kernel
image of a virtual machine over the Internet, i.e., 14 network
hops away. We conclude that memory deduplication must also be
considered a security risk if only applied within a single security
domain.

I.

INTRODUCTION

Memory deduplication is a widely used technique to reduce
memory utilization by detecting physical pages with the same
content and merging them. Merged pages are marked as read-
only and copy-on-write. If one of the merged pages is mod-
iﬁed, a copy-on-write page fault is triggered, and the page is
again copied to a new physical location. With the introduction
of Windows 8.1, memory deduplication had become a default
feature [58]. On Linux, kernel-same-page merging is used by
kernel-virtual machines or if the madvise syscall is used with
a ﬂag indicating that the page is mergeable.

Previous work demonstrated memory-deduplication attacks
performed by a local attacker in both local environments
(i.e., local native code execution) and the cloud (i.e., local
code execution in a virtual machine) [50], [4] exploiting page
combining on Windows and kernel-same-page merging on
Linux. Memory-deduplication attacks can detect co-location
in the cloud [50], hide communication in virtualized environ-
ments [56], [57], ﬁngerprint operating systems [41], ﬁngerprint
websites via JavaScript [16] and break ASLR on Linux as

well as on Windows by exploiting pages with almost ﬁxed
content [4]. Bosman et al. [6] leveraged memory deduplication
in combination with Rowhammer to escape from a browser
sandbox. Razavi et al. [44] used memory deduplication to
facilitate Rowhammer attacks on co-located virtual machines.
Palﬁnger et al. [42] demonstrated that memory deduplication
can also be exploited in ﬁle systems like ZFS. Lindemann et al.
[27] demonstrated efﬁcient ﬁngerprinting via memory dedu-
plication in co-located virtual machines. In concurrent work,
Kim et al. [22] showed a KASLR break on virtual machines
on VMWare ESXi. Following the recommendation of all these
attack papers, memory deduplication was disabled on Linux
and Windows by default.

More recently, vendors switched to more ﬁne-grained
security policies. Windows 10, for instance, again enables
page combining by default but restricts it to only deduplicate
within a security domain but not across security domains,
stopping existing attacks. We also observe that the popular
Ubuntu 20.04 Linux distribution enables kernel-same-page
merging by default for KVM-based virtual machines. Memory-
deduplication attacks with local code execution are considered
out of scope in their threat model. Systems without local code
execution (native or in a virtual machine) for the attacker
can still be considered secure with these mitigation strategies.
However, it remains unclear whether remote attacks without
local code execution are possible.

Our work faces three challenges which have to be solved

to perform remote memory-deduplication attacks:
• C1: Remotely amplify latencies for non-repeatable events.
Remote timing attacks require high latencies in the side
channel to deal with noisy networks. Page-fault-type in-
terrupts cannot be arbitrarily repeated (e.g., for copy-on-
write page faults, the page is copied and writeable after
the page fault). Hence, existing ampliﬁcation techniques
are not directly applicable.
All previous memory deduplication attacks focused on
cross-domain deduplication. Deduplication within one do-
main is considered secure (Windows re-enabled it for that
reason). Intra-domain deduplication is visible outside of
the domain if the timing latency is exposed over a web
server or public API to the attacker domain.

• C2: Trigger and observe copy-on-write pagefaults in a
victim domain that shares no memory with any attacker
domain. All previous memory deduplication attacks require
local code execution (in native or sandboxed code). Remote
requests are usually not held in memory for a long time. To
speed up, the access of frequent data, in-memory caching
mechanisms like Memcached are used in websites.

• C3: Find remote request paths that do not only keep
attacker-controlled data in memory but also provide the

attacker with control over alignment and in-memory rep-
resentation. To enable byte-by-byte leakage, a target is
required that allows alignment changes as described by
Bosman et al. [6].

In this paper, we solve the mentioned challenges and
demonstrate the ﬁrst fully remote memory-deduplication
attacks,
just using requests to an HTTP web server. Our
attacks infer timing differences caused by copy-on-write page
faults on the server from the latency of network requests and
responses. We demonstrate attacks on default-conﬁgured and
fully updated Windows (native) and Linux (virtual machines)
installations using default-conﬁgured standard server software
such as Memcached. We measure the capacity of our side
channel in a remote covert channel scenario and achieve a
transmission rate of 302.16 B/h in a local area network and
34.41 B/h over the internet, which is faster than comparable
remote memory-disclosure channels (e.g., NetSpectre [48]
achieved 7.5 B/h in a local area network).

We

different

demonstrate

remote memory-
three
illustrating the potential of our
deduplication attacks,
In the ﬁrst attack, we disclose the presence
technique.
of data on a remote server
running Memcached. The
information disclosure works by uploading data blobs into
the key-value store, freeing the deduplicated item, getting the
same item reassigned, and triggering a copy-on-write page
fault by modifying the page’s content. We also exploit this
information disclosure channel for ﬁngerprinting, i.e., which
shared libraries are used on the remote system. Our attack
detects the correct libc version over the internet in 166.51 s.

In the second attack, we present a fully remote KASLR
break on a virtual machine running on a remote cloud machine.
By targeting kernel pages that contain kernel addresses but
have all remaining bytes of the page ﬁxed, we can successfully
derandomize the kernel offset of a Linux virtual machine. We
show that we can not only mount this attack in a local area
network setting using HTTP/1 but, moreover, leverage HTTP/2
to successfully break KASLR on a server that is 14 network
hops away within 4 minutes. We emphasize that vendor
responses to local KASLR breaks are often that KASLR is
only meant as a mitigation for remote attacks.

In a third attack, we disclose database records byte-by-
byte from a MariaDB database server with an InnoDB storage
engine. Our attack works by crafting requests that create
byte misalignments within target pages, allowing byte-wise
content guessing. This attack is particularly dangerous as it
leaks attacker-unknown memory contents from a remote server,
similar as in powerful Spectre attacks [24], [48]. We can leak
1.5 B/h in a local area network.

We conclude that memory deduplication must also be
considered a security ﬂaw if only applied within a security
domain and even if local attackers are excluded from the threat
model. As our attacks are full remote attacks, we emphasize
that the remote attack vector has to be mitigated as well.
Consequently, we responsibly disclosed all of our attacks to
the corresponding vendors and work with them on ﬁnding
mitigations before the public release of this paper. We will

2

open-source our tools on GitHub with the conclusion of the
responsible disclosure 1.

Responsible Disclosure. We responsibly disclosed our ﬁnd-
ings to Microsoft, Red Hat, Canonical, and AWS, on February
8th, 2021. The issues are tracked under CVE-2021-3714.

Contributions. The main contributions of this work are:

1) We present the ﬁrst fully remote memory-deduplication
attacks and show that these must be considered a security
ﬂaw even if only applied within a security domain.

2) We show that we can remotely ﬁngerprint shared libraries
to infer the exact versions via Memcached in-memory
databases.

3) We present a fully remote KASLR break on a Linux virtual
machine running in the cloud within only 4 minutes.
4) We demonstrate a fully remote byte-by-byte memory dis-
closure attack on a MariaDB database server with an
InnoDB storage engine, leaking 1.5 B/h.

Outline. The remainder of the paper is organized as follows.
In Section II, we provide the required background about mem-
ory deduplication and remote timing attacks. In Section III,
we state a threat model and provide an attack overview.
In Section IV, we present the attack primitives that we use
for remote memory-deduplication attacks. In Section VI, we
evaluate the performance of our remote memory-deduplication
attacks in three case studies on Windows and Linux, targeting
Memcached, MariaDB (with InnoDB), and the Linux kernel.
In Section VII, we discuss the results and state-of-the-art miti-
gations for remote memory-deduplication attacks. We conclude
in Section VIII.

II. BACKGROUND

In this section, we provide background on memory dedu-
plication, memory-deduplication attacks, and remote timing
attacks, as well as Address Space Layout Randomization.

A. Memory Deduplication

Sharing memory is not only crucial for inter-process com-
munication but also to reduce memory utilization and cache
pressure. Modern operating systems use different techniques
to use shared memory whenever possible. For instance, when
creating a new process with fork(), the memory is marked
as copy-on-write, meaning that it is ﬁrst shared between parent
and child process and only copied (i.e., duplicated) when one
of the processes attempts to write to it. This is implemented by
marking the memory read-only and raising a page fault upon
a write access. Another example is the loading of any type
of ﬁle (including, e.g., a program or library binary ﬁles). The
operating system keeps ﬁles in the page cache and maps them
into all processes that request access.

Neither of these approaches leads to the deduplication of
identical but dynamically generated memory pages. Hence, op-
erating systems have introduced content-based memory dedu-
plication, which regularly scans the entire physical memory for
pages with identical content. All but one of the identical pages

1https://github.com/IAIK/Remote-Page-Deduplication-Attacks

are released, while the remaining one is marked as copy-on-
write. Content-based memory deduplication has traditionally
been applied across all security domains on all major oper-
ating systems. On Windows, the mechanism is called page
combining [58] and kernel same-page merging on Linux [3].
However, security research has revealed that this enables a
range of attacks, as we discuss in the next sub-section.

B. Memory-Deduplication Attacks

In a memory-deduplication attack, the attacker ﬁrst gener-
ates candidate pages for deduplication. If the attacker guesses
the content of a page in memory fully correctly, it is dedu-
plicated. Until the deduplication took place, the attacker re-
peatedly writes to the candidate pages (without changing the
content). As soon as the deduplication took place, this triggers
increasing the access latency
a copy-on-write page fault,
drastically. Hence, the access latency reveals whether a victim
process had a page with the exact same content, i.e., memory
deduplication forms a content-probing oracle.

The ﬁrst memory-deduplication attack, demonstrated by
Suzaki et al. [50], was used to detect applications running
in other virtual machines. Owens et al. [41] also exploited
memory deduplication to ﬁngerprint
the operating system
version via unique pages per operating system in virtual
machines. Gruss et al. [16] showed that memory-deduplication
attacks are possible from JavaScript running on a website
opened in a browser. Barresi et al. [4] demonstrated that
it is possible to break address space layout randomization
(ASLR) on both Windows and Linux using memory dedu-
plication. Razavi et al. [44] exploited memory deduplication
to perform Rowhammer attacks on applications in virtualized
environments. Bosman et al. [6] used memory-deduplication
attacks to create more sophisticated exploits and used the
ASLR break via memory deduplication to create an end-to-
end JavaScript exploit which leverages Rowhammer to achieve
arbitrary memory read and write. Oliverio et al. [40] proposed
a mitigation against active memory-deduplication attack called
VUsion, which enforces same behavior when accessing shared
and non-shared pages, a write-xor-fetch policy, and random
memory allocation. Lindemann et al. [27] showed another
ﬁngerprinting attack to detect co-location in virtual machines.

Palﬁnger et al. [42] showed that memory deduplication
can also be leveraged in ﬁle systems like ZFS to ﬁngerprint
the operating system in the cloud of co-located machines. In
concurrent work, Kim et al. [22] demonstrated a KASLR break
on VMWare ESXi.

C. Remote Timing Attacks

Timing attacks were heavily researched in the last two
decades. Since network connections are getting more and
more stable, at higher transmission rates, as well as lower
and more consistent
latencies, remote timing attacks have
become increasingly interesting for attack research. Brumley
and Boney et al. [7] demonstrated that it is possible to extract
SSL private keys over a local area network. Acıic¸mez et al.
[1] attacked AES via a remote cache based attack. In 2009,
Crosby et al. [10] showed the possibilities of remote timing
attacks and how to reliably determine the number of requests
required to distinguish certain timing differences over the net-
work. There were several remote timing attacks on AES [59],

[21], [2], [47] following Bernstein’s idea of attacking AES [5].
Van Goethem et al. [51] exploited timing side channels in
browsers. Irazoqui et al. [19] showed that it is possible to
exploit cache timing differences in TLS in a local area network.
Van Hoef et al. [53] leveraged TCP windows to observe the
exact size of a cross-origin resource. Van Goethem et al. [52]
showed that remote timing attacks can be performed over the
Internet by exploiting concurrency in HTTP/2 and observing
the order the packets return, which depends on the server-
side timing, instead of the client-side timing. Kurt et al. [26]
showed that Data Direct I/O can be used in combination with
Remote Direct Memory Access to spy on keystrokes during
SSH sessions.

More closely related to our work is Schwarz et al. [48], who
showed that Spectre attacks are possible over the network if
certain gadgets exist on the target system. Similar to the most
powerful attacks we present, they can leak arbitrary data from
an execution context. They achieve a leakage rate of up to
7.5 B/h, which can be sufﬁcient to leak a cryptographic key
over the time frame of multiple hours.

D. Address Space Layout Randomization

To exploit memory corruption bugs,

the knowledge of
addresses of speciﬁc data is often required since address
randomization is applied in both user space and kernel space.
Over the past years, different side-channel attacks allowed
to reduce the entropy of the randomization or to break it
entirely. Hund et al. [18] measured the execution time of page-
fault handling to observe which kernel addresses are mapped
and thus cached in the TLB. Jang et al. [20] used hard-
ware transactional memory to observe the same effect. Other
software-based side channel attacks exploited predictors [13],
[28], side channels introduced by mitigations against other
attacks [9], the power consumption of the processor [29], and
other microarchitectural properties [17], [25], [14], even from
JavaScript [15], [8]. As a consequence of these local attacks
on KASLR, operating system vendors but also parts of the
academic community considered KASLR only as a defense
against remote attackers. In remote attacks, KASLR indeed is
still considered a valuable line of defense since the attacker
cannot as easily probe the address space as with local attacks.

III. THREAT MODEL & ATTACK OVERVIEW

In our threat model, the attacker has no ability to execute
code on the target machine: not natively, not in a virtualized
environment, and also not via JavaScript [6], [16] or another
scripting language. However, the attacker can provide attacker-
controlled content to the remote target, e.g., a network request
the attacker sends to the host with content the attacker controls.

We assume that the victim keeps the attacker-controlled
content in RAM. This occurs, for instance, if the attacker sends
network requests that are cached in request pools, or binary
large objects provided to a web application and later on stored
in a database or cached in a buffer.

We assume that memory deduplication techniques are
active on the victim’s machine. We emphasize that this is
the case under default settings on current Ubuntu Linux
installations (kernel-same-page merging for virtual machines)
and on current Windows installations (page combining).

3

3. OS: Deduplicate A and B

Victim’s RAM

Page A

Page B

5. Write to B

2. Fill page B
and keep it in
RAM

Attacker

1. Send data with same content as page A to server

Victim

4. Update attacker-controlled page B

6. Measure response time

Fig. 1: Overview of a remote memory-deduplication attack.

We make no assumptions about software bugs, for instance,

memory safety violations in the applications we analyze.

Attack Overview. Six steps are required to perform a remote
memory-deduplication attack as illustrated in Figure 1. First,
the attacker sends a request to the victim with a page of data
(page B) containing the same content as a page already present
in memory (page A). Afterwards, the attacker waits for some
time until the two pages are merged by the operating system
and point to the same physical address. Next, the attacker
updates the attacker-controlled data and triggers a page-fault
on the victim application. Depending on the response time
of the victim, the attacker observes whether the page was
deduplicated or not.

Difference to already presented attacks. All of the previous
presented attacks [50], [41], [16], [4], [6] require local code
execution via a native binary or JavaScript and co-location to
the victim’s machine. Remote memory-deduplication attacks
extend the scope by enabling attacks on remote web servers by
exploiting an API that allows uploading of attacker-controlled
data and place it into the main memory such that it might be
deduplicated. Comparison of state-of-the-art memory dedupli-
cation attacks to our work is listed in Table I. While some
of the techniques shown by previous work are similar, we
solved those challenges for memory deduplication attacks in
the context of a remote attacker. As evidenced by other fully
remote attacks [48], [52], speciﬁc timing requirements and
the applicability to many-hop internet connections, remain a
challenge that is only solved for speciﬁc cases.

IV. ATTACK PRIMITIVES

In this section, we describe our basic attack primitives and
deﬁne the requirements for a remote attacker to perform a fully
remote memory-deduplication attack without execution of any
attacker-controlled code on the victim system.

The main primitives for our attack are memory dedupli-
cation being enabled, a web service/API that lets a remote
attacker read/modify data stored in RAM and an accurate
remote timer that allows distinguishing the round-trip time of
the network packets.

A. Memory Deduplication

Page combining. Page combining was introduced in Windows
thread scans over the
8.1. On Windows, a special kernel

whole memory to detect pages that have identical content [58].
This scan is triggered about every 15 minutes on Windows
10 [58]. If pages with identical content are found, the pages
are combined to a single page to save memory. The page-table
entries of the pages then point to one of the two pages, which
is then shared across processes and marked as read-only and
copy-on-write. When writing to this shared page, a copy-on-
write fault occurs, and a new copy of the page is created for
the writing process [58].

be

via

can

easily

disabled

combining
the
Page
registry or using Powershell, e.g., using the
Windows
Disable-MMAgent command. Page
combining was
temporarily disabled for
several
memory-deduplication attacks were discovered [4], [6], [16].
However, page combining was re-enabled on Windows more
recently and is active on desktop machines by default, as well
as on server machines if the full terminal server role is
enabled. In addition, a Windows 10 process has the possibility
to disable page combining [37].

security reasons

after

We observed this effect by checking all terminal server
options in Windows 2016 (Version 1607, Build 14393.693)
and Windows Server 2019 (Version 1809, Build 17763.737).
We also empirically validated that for Windows 10 Profes-
sional 20H2 19042.746 and Windows 10 Home 19041.746
page combing was active by default. On Microsoft’s Azure
Cloud [36] it
is also possible to acquire such Windows
Server VMs with this conﬁguration. We created a Windows
2019 Server (Version 1809, Build 17763.1697) and can also
conﬁrm that page combining is enabled after setting the full
terminal server role. On Windows,
is also possible to
force page combining using the RtlAdjustPrivilege and
NtSetSystemInformation functions.

it

Linux Kernel Same-Page Merging Kernel-Same-Page Merg-
ing (KSM) is the counterpart of page combining on Linux [3],
[45]. KSM is enabled and mainly used for Kernel Vir-
tual Machine (KVM) virtualized machines, for instance, on
Red Hat Linux [45]. On Ubuntu 20.04, we observed that
when qemu-system-common with KVM support
is in-
stalled on a host machine, KSM_ENABLED is set to AUTO
in /etc/default/qemu-kvm, enabling KSM per default
for non-virtualized instances. We also set up an Ubuntu 20.04
server image and observed the same behavior after installing
QEMU. Like on Windows, a kernel thread scans over the
memory and merges pages with identical content to a single
page, which is then marked as copy-on-write [45].

On Linux, only pages are merged that are marked as
mergeable, i.e., using the madvise syscall and setting the
MADV_MERGEABLE ﬂag [3]. This is the default for pages
of KVM virtual machines. The user can conﬁgure how many
pages should be scanned per invocation (pages_to_scan).
The default value on a Ubuntu 20.04 is 100 pages_to_scan
in a time interval of 200 ms. Therefore, in the optimal case, up
to 500 4 kB pages can be deduplicated per second. Figure 2
illustrates the required time for a single page being dedupli-
cated, with a different number of pages to scan set, and the
default value of 200 ms for sleep millisec. We evaluate the
deduplication time for a single page depending on the scanned
pages on a remote server equipped with an Intel Xeon E3-1240
running Ubuntu 20.04. However, it is recommended to increase
the number of pages_to_scan to increase the deduplication

4

Attacks
Suzaki et al. [50]
Owens et al. [41]
Gruss et al. [16]
Barresi et al. [4]
Bosman et al. [6]

Lindemann et al. [27]
Kim et al. [22]
Our work

Location
Co-located
Co-located
Remote
Remote
Remote

Co-located
Co-located
Remote

Environment
Cross-VM (Cloud)
Cross-VM (Cloud)
Browser/Cross-VM (Cloud)
Cross-VM (Cloud)
Browser (Same-machine)

Cross-VM (Cloud)
Cross-VM (Cloud)
Internet/Local-NW

Local
Yes
Yes
Yes
Yes
Yes

Yes
Yes
No

Type
Native binary
Native binary
JavaScript
Native binary
JavaScript

Native binary
Native binary
None

Attack Type
Fingerprinting
Fingerprinting
Fingerprinting
ASLR break
Bytewise
break, Rowhammer
Fingerprinting
KASLR break
Bytewise leakage, KASLR
break, Fingerprinting

leakage, ASLR

Performance
-
-
-
8.7 days
2.75 h

1.8 h
12 min
1.5 B/h (Local-NW)
4 min / 166.51 s

/

Location: Attacker’s location

Local: local code execution

Type: Type of local code execution

Perf: Reported Attack Performance

TABLE I: Comparison of state-of-the-art memory deduplication attacks.

performance [49]. The tool KSMtuned sets the time interval
to 10 ms and increases pages_to_scan to
per default
1250 [45]. This would lead to a maximum 512 MB being
deduplicated per second. We asked a cloud provider, which
hosts multiple hundred thousand websites, for the KSM conﬁg
used in production. The cloud provider uses a conﬁguration of
sleep_millisecs=30,pages_to_scan=500, leading
to at maximum 65.84 MB (16500 pages) being deduplicated.
The average time after a single page is deduplicated with that
conﬁguration is 34.57 s (n = 10, σ = 6.3%).

B. Service/Web API.

We assume that

the victim machine provides network-
accessible services, e.g., a REST API, enabling users to store
and modify data blobs. There are no restrictions in the way
these data blobs are controlled, i.e., the user could either upload
and replace ﬁles or send strings to the server, as long as the
memory location of the data blob does not change.

C. Remote Timer.

To get the best possible low-latency timing information,
we use the hardware timestamps from the network interface
card. We measure the timing difference between the last packet
sent and the ﬁrst response byte received from the server
(tcp ﬂags=PUSH,ACK).

The victim side (which the attacker cannot control) runs
under default conﬁguration. However, on the attacker side (that
is under full control of the attacker), we disable the following
optimizations in the Linux network parsing sudo ethtool
-K enp3s0 tso off gso off gro off. These op-
tions disable ofﬂoading of TCP packets to the network in-
terface card. Ofﬂoading might inﬂuence the timestamps on
the attacker (receiver) side. We observed for some network
interface cards that due to receiver side packet coalescing, the
TCP receive timestamp of the ﬁrst received packet might be
overwritten. To ensure that no coalescing happens, we devel-
oped a kernel module which disables packet coalescing on the
receiver side, for network cards which have this problem.

Network Timestamps. We found that one of the bottle-
necks of remote attacks is the limited number of HTTP
requests which can be sent using a simple HTTP requests
library like pyrequests. Therefore, we use asynchronous
IO mechanisms to increase the number of requests per sec-
ond. Furthermore, we observed that Wireshark’s TCP-ﬁeld
tcp.time_delta reﬂects the timing difference between

s
d
n
o
c
e
S

596.9

600

400

200

0
100

61.6

1,000

6.9

3.6

2.29 1.61

10,000

100,000

pages to scan

Fig. 2: The deduplication time of a single 4 kB-page
strongly
pages to scan
(sleep millisecs=200).

depends

number

the

on

of

copy-on-write pages and non copy-on-write pages best. This
ﬁeld calculates the timing difference between two captured
packets. Compared to the network timestamp read from the
NIC, we require only 20 requests instead of 40 to distinguish
16 overwritten copy-on-write pages over 14 hops in the internet
to build a histogram.

D. Attack Setup.

For all our case studies, we use the following setup for our

local and remote scenario.

Local Scenario. The local victim machine uses an i7-6700K
processor with Ubuntu 20.04 (kernel 5.4.0) and runs QEMU
4.2.1 with KVM support enabled and virtualization extensions
enabled. Co-located in the same local area network, we have
our attacker machine, which also uses an i7-6700K processor
and Ubuntu 20.04 (kernel 5.4.0). For the Linux setup, we host
a virtual machine with KVM running Ubuntu Server 20.04
LTS (kernel 5.4.0-53-generic).

Remote Scenario. In addition, we used a remote Linux server
by Equinix [12], running on an Intel Xeon E3-1240 CPU. We
installed the same virtual machine on the Linux server. For our
Linux machine, which was located in Amsterdam, we observed
14 network hops.

We created a virtual machine on Microsoft Azure of
size Standard D4s v3 [36] and set up a Windows Server
2019 (Version 1809, Build 17763.1697) with page combining
enabled. We observed 28 hops, using the nmap traceroute
command, between our network and the Windows 2019 server
virtual machine, which was located in Amsterdam. We use the
same attacker machine from our local setup to perform the
internet attacks.

Settings.
our

To estimate the highest possible capacity of
remote covert channel, we try to reduce the noise

5

s
t
s
e
u
q
e
R
#

40

20

0

No-COW

COW page

s
d
n
o
c
e
s
o
r
c
i

M

150

100

50

0

0.6

0.8

1

1.2

1.4

1.6

1.8

2

Timing [ns]

⋅105

Fig. 3: Timing distribution of a single deduplicated page of
a virtual machine in a local area network scenario on Linux
KVM (n = 1000).

0

20

40

60

80

100

120

Number of deduplicated pages

Fig. 5: Timing difference between ampliﬁed pages.

s
t
s
e
u
q
e
R
#

60
40
20
0

No-COW

COW page

0.4

0.6

0.8

1

1.2

1.4

1.6

1.8

Timing [ns]

⋅105

Fig. 4: Timing distribution of a single deduplicated page of a
virtual machine in the internet(14 hops) (n = 1000).

y
c
a
r
u
c
c
A

1
0.9
0.8
0.7
0.6

100

R1
R16

R8
R32

103

101

102

Number of requests

Fig. 6: Success rate of the classiﬁer using the box test with a
different number of deduplicated pages (Rx).

full

far as possible,
the KVM virtual machine. To enable

i.e., by ﬁxing the CPU frequency
as
scans
of
on a moderate CPU utilization, we set
the value of
/sys/kernel/mm/ksm/pages_to_scan to 100 000.
/sys/kernel/mm/ksm/sleep_milliseconds
The
remains at the default value of 200 ms. Furthermore, we set
the CPU performance governor to performance using the
cpupower tool to avoid noise from wake-up delays. We
later on use the default conﬁguration of Ubuntu, Windows,
and the cloud provider to calculate the leakage rates for the
cases studies.

Evaluation. For a single page, we measure a local timing
difference directly in the virtual machine (KVM) and observe
that the average local timing difference between a regular write
memory access and a memory access causing a copy-on-write
page fault is 7209.3 ns (n = 100, σCOW = 26.23%, σNOCOW =
29%) using a local timer. We evaluate the timing difference in
our local area network and on the internet using a simple HTTP
server with a key-value store. Figure 3 illustrates the timing
difference for a single page accessed with a copy-on-write page
fault and a normal write access in a local area network. In the
local area network, we observe a mean timing difference of
4353.91 ns (n = 1000). Figure 4 shows the timing difference
for a single page accessed with a copy-on-write page fault and
a normal write access from our Linux server on the internet
(14 hops). While those two distributions overlap, they can be
clearly distinguished in the mean respectively median values
if enough samples are taken. In addition, the timing difference
can be ampliﬁed by overwriting multiple copy-on-write pages
in a single request.

In the following paragraph we solve C1:
Ampliﬁcation.
(Remotely amplify latencies for non-repeatable events.). A
copy-on-write page fault can be ampliﬁed if multiple pages
belonging to the same semantic entity (i.e., pages of an image
ﬁle) get duplicated at the same time [16]. Therefore, we can
amplify the timing difference between multiple deduplicated

6

pages by sending a single request, writing to those which
trigger the copy-on-write, and responding back. To evaluate
the timing differences of multiple copy-on-write page faults,
we evaluate a different set of pages, which triggers the page
fault. We deﬁne a test set in our local KVM machine with a
test set of 1, 8, 16, 32, 64, and 128 deduplicated pages and
measure the average timing difference between triggering a
copy-on-write page fault and a regular write access. We repeat
the experiment 100 times and calculate the difference between
the average times, which is plotted in Figure 5. We can see
that there is a linear increase in terms of the timing difference
with the increase of the number of deduplicated pages. For
instance, with 8 pages, we get an average timing difference of
13 610.82 ns and with 16 pages, it is on average 22 946.14 ns.

Next, we evaluate the effect of ampliﬁcation in our local
area network setup with KVM. We use the term ampli-
ﬁcation factor to indicate the number of additional pages
used to amplify the signal. We sample 1000 times and ﬁt a
CDF(cumulative distribution function) for each of the ampli-
ﬁcation factors (1, 8, 16, 32) and randomly sample from the
CDF. To discover the number of requests required to achieve
an accuracy higher than 95% percent, we perform the box
test by Crosby et al. [10]. Figure 6 illustrates the number of
network requests required to achieve a certain success rate
for a different number of pages deduplicated by the server.
In this idealized setup, we observe that 10 requests with
an ampliﬁcation factor of 8 are enough to achieve a 95%
conﬁdence of distinguishing write accesses on a deduplicated
page (incurring a page fault) and a non-deduplicated page in
a local area network if ampliﬁcation is used. The number of
requests required is in a similar range for the local area network
observed by Van Goethem et al. [52].

C1

Remotely amplify latencies for non-repeatable events.

We showed the applicability of memory-deduplication at-
tacks within the same security domain. We can amplify
the timing differences for the copy-on-write page faults
arbitrarily by leveraging the deduplication of multiple pages
belonging to the same semantic entity. If the attacker is in
control of overwriting the data, multiple copy-on-write page
faults increase the latency.

R/W bit stays cleared. On Windows and Linux with page
combining respectively kernel-same-page merging, we observe
that when a page is deduplicated, and a write access occurs
the remaining
to one of the corresponding virtual pages,
mappings of the same physical page remain marked as copy-
on-write. We empirically validate this in an experiment, where
we ﬁrst map two pages A and B with identical content and wait
for deduplication. We then write to page A and thus trigger a
copy-on-write page fault. Subsequently, we analyze the R/W
bit of the page-table entries for both pages and see that the R/W
bit remained cleared for page B. This observation is especially
useful when the attacker can align data, as was shown by
Bosman et al. [6]. In Section VI-C, we exploit this behavior
to amplify a single copy-on-write request via Memcached.

V. REMOTE COVERT CHANNEL

For our evaluation on both Windows and Linux, we
ﬁrst create a covert channel using our
remote memory-
deduplication channel. For this purpose, we implement a small
HTTP/1.1 server in C++ to maximize the performance. We
evaluate this attack on a local-area network with a hardware
switch between the attacker and the victim.

Capacity. We build a covert channel to measure the perfor-
mance of our remote memory-deduplication attack in a local
area network scenario. The victim system for our transmission
hosts a website that allows storing and updating ﬁles. The
website keeps the ﬁles in in-memory storage, i.e., in RAM.

The sender and receiver upload an identical large ﬁle to
the website hosted on the victim system. Both use a 4 kB
page in this large ﬁle to encode a ‘1’-bit. To transmit a ‘1’-
bit, the sender puts the same page into RAM by updating
the ﬁle via the website. The page is deduplicated with the
page in the receiver’s ﬁle. Conversely, to transmit a ‘0’-bit,
the sender modiﬁes the page in its ﬁle such that it is not
deduplicated. The receiver sends a network request that either
triggers a copy-on-write page fault or not. With measured
round-trip time, the receiver distinguishes between a ‘1’ and
a ‘0’. The transmission can be parallelized in our setup by
storing multiple bits at once and evaluating them in parallel.

Local Area Network. We transmit a random secret that is
8 bytes long, and repeat the experiment 100 times. On each
repetition, we re-randomize a new 8 B secret. We observed that
the Python capturing library has problems correctly parsing the
packets when performing too many requests asynchronously on
our webserver, we always leak 2 bytes (16 bit) in parallel for
stable results. Between the send and receive process, a delay
of 3 s was used to wait for deduplication.

In our Linux setup using ampliﬁcation of 16, we achieve
an overall performance of 302.16 B/h (n = 100, σ = 5.81%),
with an error rate of 0.6 %.

Internet. We run the same experiment as for the local area
network. On Linux, we used 20 requests per bit and used an
ampliﬁcation factor of 16 pages. On Windows, we used 20
requests per bit and an ampliﬁcation factor of 32 pages.

On the Linux server, we achieve an overall performance
of 34.41 B/h (n = 100, σ = 5.87%) with an error rate of
0.83 %. On the Windows server, we use constant triggering
of memory deduplication and a delay of 50 ms and achieve
an overall performance of 26.64 B/h (n = 100, σ = 0.69%)
with an error rate of 0.18 %. We use this number to calculate
the timing for the actual wait time on Windows of 15 minutes
until the deduplication succeeded, which is 0.4 B/h.

Using the same methodology as state-of-the-art work [4],
[6], we simulate the covert’s channel performance for the
default conﬁguration of 100 pages to scan on Linux. As it
takes 596.9 s on the Equinix server to perform a full scan,
the covert channel’s performance shrinks down to 0.59 B/h.
For the provided numbers of the cloud provider, the covert
channel would achieve 20.62 B/h. These numbers are in a
higher range as previous work, with the additional overhead
of TCP, compared to the UDP sockets used in a similar attack
scenario [48]. The other remote timing attacks did not provide
concrete numbers on their covert channel [59], [21], [2], [47],
[1], [52].

VI. CASE STUDIES

In this section, we evaluate three case studies and demon-
strate what types of attacks are possible with remote memory-
deduplication. First, we demonstrate that we can exploit re-
mote memory-deduplication in Memcached to ﬁngerprint the
system, including the operating system. We successfully detect
the correct libc library over the internet in 166.51 s. Second,
we demonstrate a fully remote KASLR break by exploiting
remote memory-deduplication within 4 minutes. Third and
ﬁnally, we demonstrate how to leak database records byte-
by-byte from InnoDB used in MySQL and MariaDB. In the
following subsections we show how to solve C2, and C3.

A. Memcached

Memcached is a fast in-memory database offering a key-
value store for applications [35]. The memory is managed
using a slab allocator. A slab consists of a single or multiple
memory pages, which are contiguous in physical memory.
Memcached always allocates a 1 MB region and splits it into
smaller chunks of equal size [35]. Chunks or objects with a
similar object size get assigned to a certain slab class. For
instance, if a slab class is 64 B, the 1 MB page is split into
16 384 chunks. Newly inserted data is assigned to the smallest
slab class that the data ﬁts in [35]. This means a certain slab
class contains objects of a certain size and assigns the objects
to a chunk. A key-value pair is managed by the item structure,
a linked list that contains the size of the key, the value of the
object, and some more metadata [35]. Each slab class has a
free list, which is a linked list [35]. If an item gets freed, its
former location is moved to the head of the free list.

7

Memory Management. The key-value pairs are stored con-
tiguously in memory, which is ideal for triggering memory
deduplication. We analyzed and proﬁled the source code of
Memcached to check which functions are used and how the
memory allocation works internally. In contrast to our expec-
tations, Memcached does not perform an in-place replacement
of the value to update. Even with the same key used in
memcached_set and memcached_replace operations,
a new location is assigned to the updated value. This new
location is either an available free slab item from the head of
the free list (do slabs alloc) or a new slab item.

After all input data from the new item is read, the old item
is unlinked, and the new location linked for the item. The old
location is freed and inserted to the head of the slab’s free list
(code path is from complete nread → do item link). If a ﬁxed
memory size is reached, a least-recently-used (LRU) eviction
policy is applied on a slab-base [11] This means that “old”
items are replaced by more frequent items in a certain slab
class.

1) Attack.: Our basic remote memory-deduplication attack
on Memcached works as follows on Linux and Windows:
First, the attacker places the targeted pages into the key-value
store with a speciﬁc identiﬁer. Then, the attacker waits some
amount of time (delay) such that the pages are deduplicated.
The deduplicated content can be for instance a static unique
binary page of a speciﬁc version of the C standard library
or other static binary pages in the system. After the delay,
the attacker creates a new dummy item with the same key,
which puts the deduplicated target page on the free list of
Memcached. Then, the attacker updates the same item, which
causes a copy-on-write page fault on the deduplicated page
which is now overwritten.

Alignment.
In general, it is not guaranteed that allocating
memory with malloc internally uses mmap for a speciﬁc
allocation size (this may depend on the libc variant, i.e., glibc
MMAP THRESHOLD is 128 kB,system conﬁguration, and
operating system versions of the victim system). Thus, it is also
not guaranteed that the allocated 1 MB region is aligned to any
speciﬁc offset. Using mmap would ensure a page alignment,
meaning the page offset would always be 0. However, in
our experiments, we observed that malloc always used mmap
internally for the 1 MB allocations on a default conﬁgured
Ubuntu Linux installation.

It is also not guaranteed that the attacker inserts the ﬁrst
item in the slab class, which also causes an unknown alignment
as also other chunks might be inserted on the 1 MB page.
To overcome this limitation we propose a method to generate
chunks of all different sizes possible for a slab class. We
calculate all possible offsets the chunk could have on the page
for a certain slab class. These possible offsets can be computed
for each possible chunk per page i as offset:

(malloc of f set + i ⋅ chunk size + item header size
+key size) mod 4096

the

where

chunk_size

attacker-controlled,
the
class,
the
malloc_offset = 16 and the size of the item header is
deﬁned as item_header_size = 56. Hence, to overcome

key_size
depends

is
on

slab

Local Network

No-COW

COW page

0.6

0.8

1

1.2

1.4

1.6

Timing [ns]

Internet

⋅106

COW

No-COW

s
t
s
e
u
q
e
R
#

30
20
10
0

s
t
s
e
u
q
e
R
#

40

20

0

1.6

1.8

2

2.2

2.4

Timing [ns]

⋅106

Fig. 7: Histogram of the network requests in a local area
network and in the internet setup using 16 pages to amplify
the results in Memcached.

the alignment issue, we use the same page with the different
offsets to cover all possible alignments, which is guaranteed
to include the correct alignment required for deduplication.

LRU. In a real-world application, Memcached can be expected
to be heavily used by other users as well. However, we still
need to keep the data inside the data store. We achieve this
by frequently accessing the data using GET requests on the
service to avoid being evicted by the LRU eviction strategy.
Note that this does not trigger copy-on-write page faults as
we only read the data but do not modify it. We discuss the
eviction in more details in an attacker scenario in Appendix A.

Evaluation. We evaluate our attack on Memcached 1.6.8 and
connect to the Memcached service using UNIX sockets. We
evaluate this scenario using a PHP site (version 7.4.3), which
is hosted on an Nginx server (version 1.18). Our evaluation
uses the local area network setup, and we also run on a Linux
server on the internet 14 hops away. Our victim server and
attacker setup are the same as described in Section V.

We alternate between pages that do not trigger a copy-on-
write page fault and pages that trigger a copy-on-write page
fault due to deduplication. In addition, we alternate the order
to avoid a potential bias, which could be introduced by a
ﬁxed request order. In total, we perform 1000 HTTP requests.
Figure 7 shows the timing differences we observe in this setup.
We can see that it is easy to distinguish between deduplicated
pages and non-deduplicated pages.

Libc Fingerprinting. Operating system and library ﬁnger-
printing is a good starting point for penetration testing to
determine potential vulnerabilities on the identiﬁed operating
system or the running applications. Those results observed
from Memcached can be used to perform ﬁngerprinting of
operating systems by looking at ﬁxed memory pages as was
proposed by Owens et al. [41]. We use the same setup as
before and try to ﬁngerprint the exact standard C lib (libc)
version. In our experiment, we probe 3 different versions
of the libc. We perform 20 subrequests for each version
we probe on Memcached. Our information disclosure attack
detects the correct version in one sample within 44.28 seconds

8

(n = 100,σ = 0.19%) and an accuracy of 90%, depending on
which library is mapped on the victim. Memcached can be
used as an additional possibility to force deduplication and
evaluate the response time, which we show in Section VI-C.
The timing differences for the correct library guesses in PHP
via Memcached can be seen in Figure 14 (Appendix A).

Internet. We run the same experiment with the same setup
targeting the
(Nginx, PHP, Memcached) over the internet
Equinix Linux VM 14 hops away. We detect
the correct
version in one sample within 166.51 seconds (n = 100,σ =
9.67%) and an accuracy of 90%. Using the default settings for
KSM, the attack would take 3.36 h. With the settings provided
by the cloud provider, the attack would take 0.22 h.

C2

Trigger and observe copy-on-write page faults in a
victim domain that shares no memory with any attacker
domain.

With our attack on PHP-Memcached hosted on an Nginx
server, we demonstrated that it is possible to trigger copy-
on-write page faults within the same security domain with-
out relying on shared memory with the attacker domain.
This can be used to perform operating system ﬁngerprinting
like was shown via Memcached over the internet.

B. Breaking KASLR Remotely

By randomizing the location of kernel code, data, and
drivers at every boot, KASLR makes the exploitation of mem-
ory corruption bugs in the kernel much harder (Section II-D)
as an adversary needs to guess the addresses for the attack
correctly. In the past, different side-channel attacks allowed
to reduce the entropy of the randomization or to break it
entirely [18], [20], [13], [29], [28], [9], [8], [17], [25], [15],
[14].

While Klein and Pinkas [23] used an information leak
in IP headers to break KASLR, so far, no remote side-
channel attack has been demonstrated against KASLR. In this
section, we exploit memory deduplication to break KASLR of
a virtual machine remotely. Concurrent work by Kim et al.
[22] demonstrated a KASLR break on co-located machines
on VMWare ESXi break via memory deduplication within 12
minutes.

We describe the necessary building blocks and threat model
to mount the attack targeting one virtual machine over the
network.

1) Attack Scenario & Attacker Model: We assume that
the version of the operating system running on the victim
machine is known to the attacker. That memory deduplication
is active and enabled by the operating system (or hypervisor).
This information can be obtained by an information leak
or a ﬁngerprinting attack, similar to the one described on
Memcached in Section VI-A.

2) Attack & Building Blocks: Finding the content of mem-
ory pages that are identical to the ones used by the victim
operating system forms the basis of our KASLR break. If
the content of the attacker-controlled page is identical, the

hypervisor deduplicates it. Thus, a subsequent write to the
page yields a higher execution time forming the side-channel
we exploit throughout this paper. While a page with the same
content as a kernel page allows ﬁngerprinting the operating
system, data and pointers stored on the page either change
during runtime or are randomized on every boot and are, thus,
less predictable.

the text segment

However, on Linux,

is mapped be-
tween the 1 GB region of 0xffff ffff 8000 0000 and
0xffff ffff c000 0000. As the kernel is 2 MB aligned,
there are only 512 possible offsets in this region where the
kernel can be placed. If we ﬁnd kernel pages that only contain
kernel addresses and static values, i.e., data that is not modiﬁed
during runtime, we can generate 512 different versions of the
page. Each version corresponds to one possible offset and
contains the kernel addresses if the kernel would be mapped
to said offset.

A page on the victim machine is now ﬁlled with a possible
content candidate. The remote attacker uses the API provided
by the victim machine to set the content of a page. Depending
on the conﬁguration of the hypervisor on the target machine,
the adversary waits until pages should be deduplicated. Now
the adversary writes to the same page using the API. The
adversary measures the time it takes to write to the page, i.e.,
the time it takes for the network request to be handled. If the
content set by the adversary matches the targeted kernel page,
the hypervisor has deduplicated the pages, and to handle the
write. They have to be duplicated again. Thus, if the content
matched, the adversary observes a higher timing. For all of the
512 different possibilities, the adversary performs these mea-
surements, yielding a single candidate that corresponds to the
currently used randomization offset. To deal with measurement
noise, the adversary has to repeat these measurements.

it

In addition,

is possible to amplify the side-channel
leakage. Instead of a single kernel page, multiple different
kernel pages can be generated based on the assumed kernel
offset and set at the same time. Thus, instead of a single
deduplication, the adversary observes multiple ones within a
single measurement.

Finding Suitable Kernel Pages. To send the content of
possible kernel pages, the adversary ﬁrst needs to scan possible
page candidates. This can be done upfront in an ofﬂine phase
and used for kernels of the same version, thus, one assumption
is that the adversary knows the version used by the victim.

To ﬁnd possible page candidates, we walk the page table
levels of the Linux kernel and inspect the content of each
mapped 4 kB page. We know in which region the text segment
can be mapped and check each possible position of a pointer,
i.e., each 64 bit, if it lies in this region. If so, we dump the
contents of the page as well as all the offsets representing
a pointer within the page. We also extend this approach to
kernel pages belonging to kernel modules, as they are also
randomized in a certain memory region and could be used to
break the randomization of the modules. On a machine running
Linux 5.4.92, we ﬁnd 15 737 pages where 4070 contain values
matching pointers within these memory regions.

In a second step, we ﬁlter the dumped pages for possible
candidates that we can use for the attack. We try to ﬁnd
corresponding symbol names to the detected addresses by

9

⋅105

7

6

5

]
s
n
[

g
n
i
m
T

i

s
t
s
e
u
q
e
R
#

10

5

0

Inorrect offset

Correct offset

0

64

128

192

256

320

384

448

512

0.2

0.4

0.6

0.8

1

Kernel offset

Timing [ns]

1.2

⋅106

Fig. 8: Execution time to a page containing the content
adjusted to one of the possible kernel offsets. The high peak
at offset 14 yielded the same content as the kernel page of the
VM and, thus, has been deduplicated by the hypervisor.

Fig. 9: Histogram of the measured access times for an incorrect
and the correct offset for the KASLR break. A correct guess
can be clearly distinguished from an incorrect guess.

matching them to /proc/kallsyms, yielding 15 pages that
text addresses. 3973 pages
only contain resolvable kernel
contained module addresses, 39 resolvable and unresolvable
addresses, and 43 no symbols at all. These pages now need
to be checked if their content is static and, thus, does not
change over time. This can be achieved by dumping the content
periodically and checking it for modiﬁcations. Further, we
want the pages to not contain any data initialized during boot
time and, thus, we need to check if the content of those pages
changes (excluding the kernel addresses) while rebooting the
system multiple times. In order to rule out hardware-speciﬁc
data, this should be done on different physical machines.

3) Remote Attack: For our remote KASLR break, we
implemented the victim server in two ways. First, as a RESTful
API listening for HTTP/1 requests implemented in C++ using
the pistache framework [43]. For simplicity reasons, the API
allows the adversary to set and modify the content of pages
directly. However, as we have shown in Section VI-A, the data
could be stored in an in-memory database as well. Second,
we elevate the service for HTTP/2 to support multiplexing,
allowing us to mount timeless timing attacks described by Van
Goethem et al. [52]. In both scenarios, an Nginx [39] web
server running on the target machine forwards the request to
the victim service. The attacker sends the crafted pages for
the offset to test to the victim using the API. After 2 s, i.e.,
the time the page would be deduplicated on our system with a
high chance, the attacker sends a network request modifying
and, thus, causing the probable duplication, and measures its
response time.

HTTP/1. In the ﬁrst scenario, we use HTTP/1 to communicate
with the network service and measure the response time of
the network requests. Figure 9 illustrates the distribution of
response times for the correct offset and an incorrect offset.
Figure 8 shows the mean response time of a network request
for a speciﬁc offset in a remote-attack scenario. After sending
100 requests, we can clearly see the increased response time
for the currently used randomized kernel offset.

In the local setting, we were able to recover the correct
randomization offset with a success rate of 100 % and an
average runtime of 21.3 s (n = 100). In the remote setting,
we were able to recover the correct randomization offset with
a success rate of 73 % and an average runtime of 5 min 57.9 s
(n = 100). With the default conﬁguration of the cloud provider
(cf. Section IV-A) this would yield an average simulated
runtime of 34 min 28.69 s. With the default Linux settings,
it would take 9 hours and 2 minutes.

HTTP/2 Multiplexing. To improve on the measurement noise
introduced by the connection between the victim and the
adversary and the necessity of accurate time stamps, we utilize
Timeless Timing attacks [52] to overcome this issue. HTTP/2
allows to pack multiple requests within a single packet and,
thus, the requests reach the server at the same time. However,
the response of the request that reaches the sender faster has
likely been processed quicker.

In contrast to the sequential HTTP/1 attack, we pick pairs
of kernel offsets that we send to the server using multiplexed
HTTP/2 requests. For every attempt, we send each pair to the
server and record for which request we receive the response
ﬁrst. Note that we do not need to rely on measured access
times but just on the response order of the requests. For pairs
of both incorrect kernel offsets, we should observe a uniform
distribution between the offsets. However, if one of the offsets
is the correct one, we should observe an unequal distribution.
To optimize the approach, we reduce the number of candidates
and ﬁlter out pairs with a uniform distribution early. With each
ﬁlter step, we re-combine the candidates to new pairs.

To amplify the signal, we crafted 7 kernel pages for each
possible kernel offset. In the local-network setting, we achieved
a success rate of 88.89 % with an average runtime of 1 minute
and 38 seconds (n = 100). The raw timing differences observed
in the HTTP/1 setting enable a faster attack than HTTP/2. We
were able to successfully ﬁnd the correct offset in the remote
setting with a success rate of 92 % with an average runtime of
3 minutes and 15 seconds (n = 100). With a prolonged waiting
time using the default conﬁgurations of the cloud provider
of how many pages are scanned by the operating system per
minute, this would yield an average simulated attack time of
18 minutes and 25 seconds. With the default Linux settings, it
would take 4 hours and 48 minutes.

C. InnoDB Record Data Leakage

InnoDB is a storage engine used by default in the database
management systems MySQL and MariaDB. The storage
engine efﬁciently buffers record data and index caches in the
memory and is used instead of using the operating system’s
page cache directly. InnoDB has the advantage of providing
faster access to frequently used data.

Database systems use indices to allow quick access to
records, i.e., normally, an index is placed automatically on
columns marked as primary key. InnoDB implements indices
using a B+ tree, which allows fast record lookups. The nodes
of the tree are represented by index pages, which are the basic

10

storage unit of InnoDB and have a size of 16 kB by default.
The leaf index pages contain the actual user data. The non-
leaf ones link to other leaf or non-leaf pages. Index pages
on the same tree level are linked together to allow scanning
operations. User records in an index page are logically linked
in ascending order by their key but may be placed anywhere
in the page’s physical memory.

High-Level Overview of the Attack. To achieve byte-by-byte
leakage, the attacker needs to control the content and size of
data that is stored before the target data to bytewise shift the
target data onto the attacker-controlled page. Bosman et al. [6]
showed that byte-by-byte leakage is possible.

InnoDB performs a data reorganization of data if an insert
or update query fails as an optimization. This optimization
enables byte-by-byte leakage if the attacker controls most of
the InnoDB record. Using this primitive to perform memory
massaging, an attacker can shift the secret.

Assumptions. We assume that Memcached can be used
in addition as a leakage primitive to leak the secret data
co-located to the attacker-controlled data bytewise. As we
will later analyze, the Linux page cache caches Note that
this can be any primitive used for triggering deduplication
and copy-on-write page faults, i.e., nginx, as was shown by
Bosman et al. [6]. We assume a database application with a
user table which is deﬁned in Figure 15 and that the InnoDB
index page has a certain layout, which is explained in more
detail in Section VI-C3. We assume that the attacker can
perform multiple tries in parallel until such a layout is given.
If the layout is given, the attacker can verify whether the
requirements are fulﬁlled.

Attack steps.
Figure 10 illustrates the ﬁve steps of the
InnoDB reorganization attack. In the ﬁrst round, the attacker
triggers the reorganization and shifts the ﬁrst byte of the secret
value (“SECRET”) onto the controlled 4 kB-page. Next, the
attacker stores multiple guesses into Memcached. The attacker
waits until the deduplication happened. After the deduplication
happened, the attacker updates the Memcached guess pages
and measures the round-trip time of the network packets. The
right guess should lead to a signiﬁcantly higher timing than
the other guesses with enough samples taken. Afterwards, the
attacker repeats the procedure to shift the second byte into
the attacker-controlled InnoDB page, updates the guesses in
Memcached, including the ﬁrst recovered byte, and leaks the
second byte. This procedure can be repeated up to a certain
leakage size. The limits are discussed in Appendix A.

Why an Additional Leakage Primitive is Required. InnoDB
tries to circumvent the page cache of the Linux kernel by
using the O_DIRECT ﬂag in mmap [38]. However, the data is
still in the page cache and gets deduplicated. The page-cached
data cannot be overwritten directly via InnoDB. Therefore, we
cannot use a second InnoDB record to trigger a copy-on-write
page fault since the data would also get deduplicated. We
found no convenient and reliable way to get external blobs
consistently in the memory and replace them to trigger copy-
on-write page faults in InnoDB. For external blobs, we have a
similar race as in Memcached, since updates are not performed
in-place. Instead, resource releasing is performed in a similar
way compared to Memcached. Consequently, for our attack,
we use a memory-resident second channel (Memcached) to

1(cid:13) Change target alignment

2(cid:13) Guess secret byte in parallel.

InnoDB page

KNOWN DATA......
x bytes
...............................
...........................S

KNOWN DATA......
(x-1) bytes
...............................
..........................SE

Round 1

Round 2

Memcached page

KNOWN DATA......
...............................
...........................S

4(cid:13)

D

e

d

u

p

lic

ate

d

?

KNOWN DATA......
...............................
...........................Gi

5(cid:13) Update
guesses
(Gi),
trigger
COW-PF and
time.

(cid:51)

(cid:55)

3(cid:13) Wait for dedupli-
cation

Round 6

KNOWN DATA......
(x-5) bytes
...............................
................SECRET

KNOWN DATA......
...............................
................SECRET

Fig. 10: High-level idea of the InnoDB Reorganization attack.

trigger the copy-on-write page fault. However, this could, in
general, be any web application/resource providing such a
leakage primitive that is running on the same machine.

1) Determining InnoDB Attack Requirements.: We analyze
the memory ordering of InnoDB by performing different SQL
statements:

Insert. Upon inserting a new record, InnoDB ﬁrst tries to
place the record in its corresponding index page. If no such
page exists, a new one is created.

In case of an existing index page with sufﬁcient consecutive
free space, e.g., unused space at the end of the page or a
gap from previous deletes, the record is placed on this index
page. Should this not be possible, e.g., the page is full, or
the free space is too fragmented, either the current index page
is defragmented (reorganized), a new page is allocated, or a
page split is performed. Inserting into a new index page is only
possible if it does not break the existing relations in the index
tree. Otherwise, a page split has to be performed. As the space
of previously deleted records is reused, the physical order of
records in an index page does not always reﬂect their logical
order, e.g., a record with key 5 might be inserted in memory
before a record with key 2.

Delete. When a record is deleted, it is added to the index pages
free record list. Should the free space resulting from deletions
reach a certain merge threshold, InnoDB tries to perform a
merge operation to save space. A merge operation is possible
if the utilization of the next or previous linked index page is
low enough to combine it with the current page [30].

Update. Update queries in InnoDB update a record in-place,
as long as the updated record ﬁts in the same size as the
old one (new_record_size ≤ old_record_size) [31].
Otherwise, the update operation is realized as a delete with a
subsequent insert operation, inserting the updated record.

Reorganization. An insert or update query can fail even
if enough space is available on the index page because the
free space is fragmented. In such a case, InnoDB performs
an optimization called reorganization [32]. During re-
organization, the page is rebuilt by clearing its contents and
inserting existing records in their logical order. Afterwards,
the pending insert or update operation is completed using the
freed space at the end of the page.

2) Reorganization Attack.: As shown by Bosman et al. [6],
an attacker can use memory-deduplication attacks to leak data
byte-by-byte if the attacker can change the memory layout on
a byte granularity. We demonstrate that this approach can also
be applied in a fully remote attack scenario.

11

1(cid:13) Change target alignment

2(cid:13) Guess secret byte in parallel
per ampliﬁcation factor.

InnoDB page

Memcached page

Ampliﬁcation
factor 1

AAAAAAAAAAAAA
AAAAAAAAAAAAS

AAAAAAAAAAAAA
AAAAAAAAAAAAS

AAAAAAAAAAAAA
AAAAAAAAAAAGi

4(cid:13)

D

Ampliﬁcation
factor 2

BBBBBBBBBBBBB
BBBBBBBBBBBBS

e

d

u

p

lic

ate

d

?

(cid:51)

3(cid:13) Wait
for dedu-
plication

(cid:55)

Ampliﬁcation
factor 6

ZZZZZZZZZZZZZZ
ZZZZZZZZZZZZZS

ZZZZZZZZZZZZZZ
ZZZZZZZZZZZZZS

5(cid:13) Update guesses (Gi),
trigger COW-PF and
time.

Fig. 11: Leakage of a secret byte (S) from an InnoDB record
using Memcached with ampliﬁcation.

by

We

data

leak

exploiting

the
byte-by-byte
reorganization of database records in InnoDB index
pages. The reorganization is triggered if data is updated
or inserted, and reorganization keeps the data on the same
index page. Figure 15 in Appendix A shows the user table
and its ﬁelds in the database, including an id, username,
password, and an image ﬁeld. We assume that the attacker
can register an arbitrary number of users and modify their
content.

Alignment Changing. To leak attacker-unknown record data,
we need a large record rAT to shift bytes from a target
record rT into an attacker-controlled region. To trigger the
reorganization, we require an additional record rAX in
the user table. The reorganization orders the records in RAM
in their logical order. With targeted size modiﬁcations of the
attacker-controlled records rAT and rAX , we can trigger the
reorganization and bytewise shift record data from rT into an
attacker-controlled 4 kB region. To leak the targeted byte, we
use Memcached used in a simple HTTP web server as a second
channel, same as in Section VI-A.

Ampliﬁcation. To use ampliﬁcation, we ﬁll multiple pages
on both Memcached and InnoBD with different ﬁll bytes but
with a constant leaked offset, as shown in Figure 11. As
the copy-on-write bit stays set for the
already mentioned,
correct guess in Memcached. Therefore we can amplify by
updating both Memcached and InnoDB ﬁll bytes and waiting
again for the deduplication. This procedure can be repeated
up to a certain ampliﬁcation factor. To trigger copy-on-write
pagefaults, we send an HTTP request to the server, which
overwrites the content of the Memcached pages. To reset to an
index page layout, which allows leaking a different byte offset,
it is required to trigger another reorganization by modifying
the sizes of the records rAX and rAT . All requirements are
explained in full detail in Section VI-C3.

3) In Detail Analysis of Attack Requirements.: To perform
the reorganization attack, the attacker and victim have to be
placed on the same InnoDB index page. While this is a
question on the workload of the system, we assume that an
attacker can perform sufﬁcient repetitions to generate a layout
leading to data leakage.

A reorganization can be caused by updating the size
of a record so that it does initially not ﬁt in any available
consecutive free space on the page but does ﬁt after defrag-
mentation. By choosing record sizes in the right way, it can
be guaranteed that such reorganizations are always possible.

12

Initial Page Layout. Figure 12a describes the initial page
layout required by InnoDB to leak record data. We exploit
InnoDB’s reorganization feature as a primitive for the attacker
to align the secret on a byte granularity. At the beginning
of an index page, there are a couple of headers and system
records, summing up to 120 B [33]. Then the data of the user
records follows. At the end of the page, there is a so-called
page directory and further meta-data. The user records are also
preceded by a dynamic-sized header, which depends on the
table layout and contains information necessary for using and
organizing the records. Figure 12a shows the assumed initial
physical and logical layout for our InnoDB attack. The hatched
areas represent unknown records. rAT and rAX are attacker-
controlled records and rT is the target record to leak.
Analysis of Required Sizes for Exploiting Reorganization.
During the rebuilding of index pages, records are inserted
consecutively in memory by their logical order, except for the
record that triggered the reorganization, which is inserted last,
regardless of its key. In total, it is possible to insert 16 252 B
(max_free_space) of record data into an index page. The
layout requires that the record rAT is logically located before
rT . rAX is required to be physically before the two records,
somewhere in between the two hatched regions in Figure 12a.
The record rAT is used to change and control
the target
record’s alignment rT . The attacker wants to make rAT as
large as possible to change the target record’s rT alignment.
In the default setting of InnoDB with a default index page size
of 16 kB, the maximum size for a record is 8125 B [33]. Thus,
to leak as much data as possible, we choose rAT to be 8125.
The validation of all requirements and the potential leakage
rate is described in Appendix A. Next, we discuss the attack
steps in more detail.

Preparing the Alignment and Triggering the Reorganiza-
tion. To trigger a reorganization, the attacker increases the
size of record rAX using an update query. The reorganization
only happens if the updated size still ﬁts into the total free
size of the index page. The new reorganization moves rAX to
the trailing free space within the index page, which
is large enough to contain at least rAX + 1.

If the attacker wants to shift a byte of the target record by δ
bytes such that the byte moves closer to rAT , the attacker can
update the size of rAT and decrease it by δ and increase the
size of rAX by δ. The reorganization takes out the record rAX
and moves it to the newly created free location. It causes the
record ˜rAX to be moved after ˜rAT and rT . rAX can only be
modiﬁed up to the maximum record size. While the header of
the user record has a dynamic size, we assume that the record
does not change during the attack. If there is an additional
record after rT , the header stays the same. If there is no
record after rT , the record header points to the Supremum [34],
which is at the beginning of the page. With each alignment
change, the next offset ﬁeld in the records header needs to be
incremented by the byte offset to leak.

Leaking the Secret Byte. Since we cannot leak the records in
MariaDB alone on Linux, a second way to trigger the memory
deduplication is required. Furthermore, we apply ampliﬁcation
for our bytewise leakage, as discussed in Section V. Figure 11
illustrates the ampliﬁed version of the InnoDB record attack.
We use different pages with the same content but only a
different last byte in the page, which is our probe byte in

Record data

InnoDB Index Page

header

rAX

rAT

rT

e
c
a
p
s

e
e
r
f

g
n
i
l
i
a
r
t

footer

0 kB

Initial State

16 kB

(a) InnoDB page layout, which is susceptible to a reorganization
attack. A simple model of an index page consists of a ﬁxed-size
header, user records, the unused space at the page end, and a footer.
In this scenario the attacker controls the records rAX and rAT . rAT
is used to control the alignment of target record to leak rT . rAX is
used to trigger the reorganization within an InnoDB index page.

Record data

InnoDB Index Page

header

˜rAT

rT

˜rAX

e
c
a
p
s

e
e
r
f

g
n
i
l
i
a
r
t

footer

0 kB

Reorganized State

16 kB

(b) If the reorganization was triggered ˜rAX is moved to the beginning
of the trailing free space.

Record data

InnoDB Index Page

header

rAX

rT

rAT

e
c
a
p
s

e
e
r
f

g
n
i
l
i
a
r
t

footer

0 kB

Reset State

16 kB

(c) Reset and reorganized InnoDB record.

Fig. 12: InnoDB reorganization steps.

Memcached (in Figure 11 the secret byte is x). In MariaDB,
we update our record rAT with the content of the ﬁrst page
(AAA....S). Afterwards, we wait for a certain delay until the
memory deduplication is triggered. If the secret byte is correct,
the page gets deduplicated. After the delay, we modify rAT
again. The page in Memcached still has the R/W bit cleared.
If all ampliﬁcation pages are deduplicated, we use the web
application to write on each of our ampliﬁcation pages and
measure the response time.

Reset. After the reorganization, the alignment is changed,
and we get a record layout, as illustrated in Figure 12b.
Unfortunately, we cannot modify the base alignment since
we do not know the size of the other records on the index
page. However, we can either try to repeat the attack until
we start at the beginning of a 4 kB page or leak the base
alignment. To reset the state back to the initial one, we again
exploit reorganization, changing to the previous sizes. The
requirement to trigger another reorganization via rAT is that
the trailing free space is smaller than the reset size of rAT .
the updated record rAT is
The reorganization causes that
now moved after rT , leading to the memory layout illustrated
in Figure 12c. However, this is no problem since we can force
another reorganization, bringing back our reorganized state,
as illustrated in Figure 12b. After each alignment change, we

13

switch between the reset and reorganized state and never return
to the initial state.

Evaluation. We implement and evaluate our attack on Mari-
aDB version 10.5.8, using UNIX sockets and a simple HTTP
server to connect to it and to Memcached 1.6.8. The database
is setup as shown in Figure 12a. We choose a random secret
of 4 B and repeat our data leakage experiment 20 times. We
apply the ampliﬁcation technique shown to leak a single byte
via 8 pages. To be on the safe side, we send 40 requests for all
256 possibilities. Afterwards, we probe all 256 possibilities for
the secret byte at once via Memcached. We look at the timing
difference between the means of the received distribution of
writing to copy-on-write and non-copy-on-write pages. Our at-
tack automatically detects if a byte was accidentally classiﬁed
as copy-on-write in case we do not get clear results for the
following byte to leak. In this case, we can backtrack to the
last byte that was correctly guessed. Therefore, our approach is
self-correcting in case we accidentally received a wrong byte,
and, thus, our approach is nearly complete error-free, despite
the last byte where an error might occur.

On Linux, we observed that

the time to wait for the
deduplication on InnoDB is, in many cases, more than twice
as big as in the previous cases. To be on the safe side, we
increased the wait time to 4 seconds. As the ampliﬁcation
needs to be triggered sequentially, this leads to a wait time
of 32 seconds per guess round. This longer delay is required
since the target page is constantly changed, and KSM does not
immediately deduplicate pages which are often modiﬁed [45].
The runtime of the attack to leak four random bytes is on
average 5644.20 seconds (n = 100, σ = 0.54%). Thus, the
attack leaks on average a single byte in 39.07 minutes or about
1.5 B/h from a virtual machine running on a remote server in
the local area network. We simulate the attack’s performanc
using the default conﬁguration to 0.018 B/h. With the provided
conﬁguration of the cloud provider, we got a simulated time
of 0.07 B/h. Note that the large bottleneck of this attack is the
ampliﬁcation technique i.e., for one iteration 32 s have to be
waited.

For the initial setup, cf.

Limitations.
the
uncontrolled record data before rAT can be modiﬁed in-place
as long as the overall size is not changed. Every in-place update
of other records does not inﬂuence the attack. However, a
memory split, merge, or reorganization would interfere with
the attack and potentially destroy the needed layout.

Figure 12a,

C3

Find remote request paths that do not only keep
attacker-controlled data in memory but also provide
the attacker with control over alignment and in-memory
representation.

We demonstrated a scenario for InnoDB used in MariaDB
and MySQL, which allows changing the alignment of
database records remotely. By changing the sizes of two
attacker-controlled records, an attacker can load bytewise
parts of victim’s data to an attacker-controlled 4 kB page.
Ampliﬁcation can be achieved by leveraging the fact that
deduplication can be triggered multiple times by modifying
the attacker-controlled record and adding certain ampliﬁca-
tion pages to Memcached (like shown in Figure 11.)

VII. MITIGATIONS AND FURTHER ATTACK TARGETS.

A. Mitigations

Our attack showed that memory deduplication is still a
threat and even exploitable over the network. Even isola-
tion into security domains like performed on Windows is
not enough to mitigate information disclosure via memory
deduplication.

Deactivation. While the simplest solution would be to
altogether disable memory deduplication on Windows and
Linux (Ubuntu), it is probably the most costly in terms of
performance overhead. Especially on Windows server, where
multiple users would use the same application, this could lead
to immense memory overhead. Windows allows disabling of
memory deduplication per process [37].

Only Deduplicate Zero Pages. Another mitigation by
Bosman et al. [6] would be only to deduplicate zero pages.
According to their evaluation, between 84% and 94% of the
deduplication in Microsoft Edge are only zero pages [6]. How-
ever, the covert channel is still possible with this solution since
we can still trigger copy-on-write page faults on deduplicated
zero pages.

TPS. VMWare TPS [54] uses additional salts to enable
memory deduplication. The salt value and the content of page
have to be identical to be shared. If VMs want to deduplicate
shared content, the salted value is unknown to an attacker.
While this approach protects against cross-VM attacks, TPS
does not protect against remote memory-deduplication attacks
in the same domain.

CovertInspector. Wang et al. [55] demonstrated an approach
to detect memory-deduplication attacks by modifying KVM
by 300 lines of code. Their approach has a particular focus
on intercepting the rdtsc instruction triggered by the VM
and also the number of pagefaults. Remote timers are not
considered by CovertInspector.

VUsion.
VUsion [40] mitigates all kinds of memory-
deduplication attacks by applying a share-XOR-fetch policy
and fake merging. All pages that are considered for dedupli-
cation behave the same in terms of access times and copy-on-
write pagefaults. Fake merging guarantees that every access
on a page, both shared or non-shared, behaves the same in

n
o
i
t
u
c
e
x
E

e
m
T

i

2

1.5

1

0.5

⋅105

Vusion

Without Vusion

64

128

192

256

320

384

448

512

Kernel offset [MB]

Fig. 13: Mean response time for all possible kernel offsets.
While an adversary can easily observe the correct offset 106
on an unprotected system (blue), the VUsion-protected system
(red) prevents the leakage.

terms of access time. This mechanism prevents attacks on the
detection of pages being actually deduplicated [40]. While fake
merging would mitigate all of our attacks based on the copy-
on-write page fault, it is not implemented nor intended to be
merged in the Linux kernel.

We experimentally veriﬁed the effectiveness of VUsion
against our remote memory-deduplication attacks in a local
area network setting. Figure 13 illustrates the KASLR break
(cf. Section VI-B) on a protected (red) and an unprotected
Linux kernel 4.10 (blue) running Ubuntu 17.04 LTS. We
measured the response time for every possible offset 100
times and reported the mean value. One can clearly see that
our attack successfully recovers the correct offset 106 while
the attack against the VUsion-protected kernel only observes
higher timings.

Network-layer Countermeasures. On the network layer, we
can mitigate remote memory-deduplication attacks via network
packet inspection tools and DDoS monitoring. Another possi-
bility to mitigate remote memory-deduplication attacks is by
adding additional noise to the network, i.e., by performing load
balancing or adding discrete time delays. This would require
more samples for the attacker, and at a certain point, it could
make the attack infeasible.

B. Alternative Attack Targets

We want to emphasize that ﬁxing Memcached does not
mitigate the problem of remote memory-deduplication attacks
as our techniques are generic and can be applied to other
applications as well. In addition to Memcached and InnoDB,
we analyzed further applications which could be susceptible to
remote memory-deduplication attacks. Many web applications
offer the possibility to use Memcached, such as PHPBB, Word-
Press, Moodle, and PrestaShop. Moodle allows image caching,
which might be already used to perform the ﬁngerprinting
attack. We analyzed the in-memory DB Redis and found that
4 kB pages can be also placed into the memory. There is
again meta-data stored about the stored item, and it is again a
question of the correct alignment for the attacker to perform
remote memory-deduplication attacks. If the attacker’s guess
about the alignment is correct, copy-on-write pagefaults can be
triggered in a similar manner to Memcached by freeing an item
and again inserting a new one with the equal size. This leads
to an overwrite of the deduplicated memory. Furthermore, we
analyzed the other popular alternative for in-memory databases
SQLite. However, we found that we could not fully place a
single 4 kB page into memory. We also checked Aerospike

14

and observed that memory is in DRAM as key-value pair and
that the aerospike_key_put function directly replaces the
content and could be used to trigger copy-on-write pagefaults.
As already shown by Bosman et al. [6] also request pools like
used in nginx are susceptible to memory deduplication attacks.

VIII. CONCLUSION

In this work, we presented how memory deduplication
can be exploited from a remote perspective. This attack does
neither require local code execution nor JavaScript execution in
the browser, as demonstrated in previous work. With targeted
web requests, we can observe timing differences between
duplicated pages over the network. We ﬁrst evaluated the speed
of our remote covert channel based on an HTTP web server
achieving a performance of up to 302.16 B/h in a LAN setting
and 34.41 B/h over the internet. Further, we ﬁngerprinted
libraries used on the system by exploiting the Memcached
database. It is possible to ﬁngerprint libraries within 166.51 s
over the internet. Within only 4 minutes, we successfully broke
KASLR from a virtual machine running on a server 14 network
hops away. Even though there are potential mitigations against
memory deduplication within the same security domain, they
are not applied in Linux systems. Finally, we leaked the
database records’ content from InnoDB with 1.5 B/h.

ACKNOWLEDGMENTS

We would like to thank our anonymous reviewers for
valueable feedback and comments on the paper. Furthermore,
we want to thank Tom Van Goethem for feedback on the
draft and support on the HTTP/2 experiments. We want to
thank Equinix Metal for providing us bare metal servers. This
work was supported by generous funding and gifts from the
EU project SOPHIA, Red Hat and AWS. Any opinions or
recommendationsw expressed in this work are those of the
authors and do not necessarily reﬂect the views of the funding
parties.

REFERENCES

[1] Acıic¸mez, Onur and Schindler, Werner and Koc, Cetin K. Cache based

remote timing attack on the aes. In CT-RSA, 2006.

[2] Hassan Aly and Mohammed ElGayyar. Attacking aes using bernstein’s
attack on modern processors. In International Conference on Cryptol-
ogy in Africa, 2013.

[3] Andrea Arcangeli, Izik Eidus, and Chris Wright. Increasing memory
density by using ksm. In Proceedings of the linux symposium, pages
19–28. Citeseer, 2009.

[4] Antonio Barresi, Kaveh Razavi, Mathias Payer, and Thomas R. Gross.

CAIN: silently breaking ASLR in the cloud. In WOOT, 2015.

[5] Daniel J. Bernstein. Cache-Timing Attacks on AES, 2005. URL: http:

//cr.yp.to/antiforgery/cachetiming-20050414.pdf.

[6] Erik Bosman, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida.
Dedup Est Machina: Memory Deduplication as an Advanced Exploita-
tion Vector. In S&P, 2016.

[7] David Brumley and Dan Boneh. Remote Timing Attacks Are Practical.

In USENIX Security, 2003.

[8] Claudio Canella, Daniel Genkin, Lukas Giner, Daniel Gruss, Moritz
Lipp, Marina Minkin, Daniel Moghimi, Frank Piessens, Michael
Schwarz, Berk Sunar, Jo Van Bulck, and Yuval Yarom. Fallout: Leaking
Data on Meltdown-resistant CPUs. In CCS, 2019.

[9] Claudio Canella, Michael Schwarz, Martin Haubenwallner, Martin
Schwarzl, and Daniel Gruss. KASLR: Break It, Fix It, Repeat.
In
AsiaCCS, 2020.

[10] Scott A Crosby, Dan S Wallach, and Rudolf H Riedi. Opportunities
and limits of remote timing attacks. ACM Transactions on Information
and System Security (TISSEC), 12(3):17, 2009.

[11] Skyscanner Engineering. Journey to the centre of memcached, 2020.
URL: https://medium.com/@SkyscannerEng/journey-to-the-centre-of-
memcached-b239076e678a.

[12] Equinix, 2021. URL: https://www.equinix.com.

[13] Dmitry Evtyushkin, Dmitry Ponomarev, and Nael Abu-Ghazaleh. Jump
over ASLR: Attacking branch predictors to bypass ASLR. In MICRO,
2016.

[14] Enes G¨oktas¸, Kaveh Razavi, Georgios Portokalidis, Herbert Bos, and
Cristiano Giuffrida. Speculative Probing: Hacking Blind in the Spectre
Era. In CCS, 2020.

[15] Ben Gras, Kaveh Razavi, Erik Bosman, Herbert Bos, and Cristiano
Giuffrida. ASLR on the Line: Practical Cache Attacks on the MMU.
In NDSS, 2017.

[16] Daniel Gruss, David Bidner, and Stefan Mangard. Practical Memory

Deduplication Attacks in Sandboxed JavaScript. In ESORICS, 2015.

[17] Daniel Gruss, Cl´ementine Maurice, Anders Fogh, Moritz Lipp, and
Stefan Mangard. Prefetch Side-Channel Attacks: Bypassing SMAP and
Kernel ASLR. In CCS, 2016.

[18] Ralf Hund, Carsten Willems, and Thorsten Holz. Practical Timing Side

Channel Attacks against Kernel Space ASLR. In S&P, 2013.

[19] Gorka Irazoqui, Mehmet Sinan Inci, Thomas Eisenbarth, and Berk

Sunar. Lucky 13 strikes back. In AsiaCCS, 2015.

[20] Yeongjin Jang, Sangho Lee, and Taesoo Kim. Breaking Kernel Address

Space Layout Randomization with Intel TSX. In CCS, 2016.

[21] Darshana Jayasinghe, Jayani Fernando, Ranil Herath, and Roshan
Ragel. Remote cache timing attack on advanced encryption standard
and countermeasures. In ICIAFs, 2010.

[22] Taehun Kim, Taehyun Kim, and Youngjoo Shin. Breaking kaslr using
memory deduplication in virtualized environments. Electronics, 2021.
URL: https://www.mdpi.com/2079-9292/10/17/2174.

[23] Amit Klein and Benny Pinkas. From IP ID to device ID and KASLR

bypass. In USENIX Security, 2019.

[24] Paul Kocher, Jann Horn, Anders Fogh, Daniel Genkin, Daniel Gruss,
Werner Haas, Mike Hamburg, Moritz Lipp, Stefan Mangard, Thomas
Prescher, Michael Schwarz, and Yuval Yarom. Spectre Attacks: Ex-
ploiting Speculative Execution. In S&P, 2019.

[25]

Jakob Koschel, Cristiano Giuffrida, Herbert Bos, and Kaveh Razavi.
TagBleed: Breaking KASLR on the Isolated Kernel Address Space
Using Tagged TLBs. In EuroS&P, 2020.

[26] Michael Kurth, Ben Gras, Dennis Andriesse, Cristiano Giuffrida, Her-
bert Bos, and Kaveh Razavi. NetCAT: Practical Cache Attacks from
the Network. In S&P, May 2020.

[27]

Jens Lindemann and Mathias Fischer. A memory-deduplication side-
channel attack to detect applications in co-resident virtual machines.
2018.

[28] Moritz Lipp, Vedad Hadˇzi´c, Michael Schwarz, Arthur Perais,
Cl´ementine Maurice, and Daniel Gruss. Take a Way: Exploring the
Security Implications of AMD’s Cache Way Predictors. In AsiaCCS,
2020.

[29] Moritz Lipp, Andreas Kogler, David Oswald, Michael Schwarz, Cather-
ine Easdon, Claudio Canella, and Daniel Gruss. PLATYPUS: Software-
based Power Side-Channel Attacks on x86. In S&P, 2021.

[30] Percona Marco Tusa.

Innodb page merging and page splitting,
2017. URL: https://www.percona.com/blog/2017/04/10/innodb-page-
merging-and-page-splitting/.

[31] MariaDB, 2020.

URL: https://github.com/MariaDB/server/blob/
09a1f0075a8d5752dd7b2940a20d86a040af1741/storage/innobase/row/
row0upd.cc.

[32] MariaDB, 2020.

URL: https://github.com/MariaDB/server/blob/

09a1f0075a8d5752dd7b2940a20d86a040af1741/storage/innobase/btr/
btr0cur.cc.

[33] MariaDB, 2020.

URL: https://github.com/MariaDB/server/blob/

09a1f0075a8d5752dd7b2940a20d86a040af1741/storage/innobase/
include/page0page.ic.

15

[34] MariaDB, 2020. URL: https://dev.mysql.com/doc/internals/en/innodb-

inﬁmum-and-supremum-records.html.

[35] Memcached, 2020. URL: https://memcached.org/.

[36] Microsoft. Azure serverless computing, 2019. URL: https://azure.

microsoft.com/en-us/overview/serverless-computing/.

[37] Microsoft, 2021.

URL: https://docs.microsoft.com/en-us/windows/

win32/api/winnt/ns-winnt-process mitigation side channel isolation
policy.

[38] MySQL, 2017.

URL: https://blog.toadworld.com/2017/10/19/data-

ﬂushing-mechanisms-in-innodb.

[39]

nginx, 2021. URL: https://www.nginx.com/.

[40] Marco Oliverio, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida.

Secure Page Fusion with VUsion. In SOSP, 2017.

[41] Rodney Owens and Weichao Wang. Non-interactive OS ﬁngerprinting
through memory de-duplication technique in virtual machines. In In-
ternational Performance Computing and Communications Conference,
2011.

[42] Gerald Palﬁnger, Bernd Pr¨unster, and Dominik Ziegler. Prying cow:
Inferring secrets across virtual machine boundaries. In Proceedings of
the 16th International Joint Conference on e-Business and Telecommu-
nications, ICETE 2019 - Volume 2: SECRYPT, Prague, Czech Republic,
July 26-28, 2019, 2019.

[43] Pistache, 2020. URL: http://pistache.io/.

[44] Kaveh Razavi, Ben Gras, Erik Bosman, Bart Preneel, Cristiano Giuf-
frida, and Herbert Bos. Flip feng shui: Hammering a needle in the
software stack. In USENIX Security Symposium, 2016.

[45] Red Hat. Red Hat Enterprise Linux 7 - Virtualization Tuning and

Optimization Guide, 2017.

[46] Redis, 2013. URL: https://redis.com/blog/memtier benchmark-a-high-

throughput-benchmarking-tool-for-redis-memcached.

[47] Vishal Saraswat, Daniel Feldman, Denis Foo Kune, and Satyajit Das.
Remote cache-timing attacks against aes. In Workshop on Cryptography
and Security in Computing Systems, 2014.

[48] Michael Schwarz, Martin Schwarzl, Moritz Lipp, Jon Masters, and
Daniel Gruss. NetSpectre: Read Arbitrary Memory over Network. In
ESORICS, 2019.

[49] SUSE, 2021. URL: https://documentation.suse.com/sles/12-SP4/pdf/

article-vt-best-practices color en.pdf.

[50] Kuniyasu Suzaki, Kengo Iijima, Toshiki Yagi, and Cyrille Artho.
Memory Deduplication as a Threat to the Guest OS. In EuroSys, 2011.

[51] Tom Van Goethem, Wouter Joosen, and Nick Nikiforakis. The clock is
still ticking: Timing attacks in the modern web. In CCS, 2015.

[52] Tom Van Goethem, Christina P¨opper, Wouter Joosen, and Mathy
Vanhoef. Timeless Timing Attacks: Exploiting Concurrency to Leak
In USENIX Security Symposium,
Secrets over Remote Connections.
2020.

[53] Mathy Vanhoef and Tom Van Goethem. Heist: Http encrypted infor-
mation can be stolen through tcp-windows. In Black Hat US Brieﬁngs,
Location: Las Vegas, USA, 2016.

[54] Vmware, 2021. URL: https://kb.vmware.com/s/article/2097593.

[55] S. Wang, Weizhong Qiang, H. Jin, and Jinfeng Yuan. Covertinspector:
Identiﬁcation of shared memory covert timing channel in multi-tenanted
cloud. International Journal of Parallel Programming, 2015.

[56]

[57]

Jidong Xiao, Zhang Xu, Hai Huang, and Haining Wang. A covert
channel construction in a virtualized environment. In CCS, 2012.

Jidong Xiao, Zhang Xu, Hai Huang, and Haining Wang. Security
implications of memory deduplication in a virtualized environment. In
International Conference on Dependable Systems and Networks (DSN),
2013.

[58] Pavel Yosifovich, Alex Ionescu, Mark E. Russinovich, and David A.
Solomon. Windows Internals Part 1. Microsoft Press, 7 edition, 2017.

[59] Xin-jie Zhao, Tao Wang, and Yuanyuan Zheng. Cache Timing Attacks
on Camellia Block Cipher. Cryptology ePrint Archive, Report 2009/354,
2009.

APPENDIX

TIMING DIFFERENCE OF LIBRARY FINGERPRINTING IN
PHP

The copy-on-write page faults can be observed in PHP
when triggering the deduplication via Memcached Figure 14.

libc2.23

libc2.19

RandomGuess1

RandomGuess2

⋅105

8

6

4

]
s
n
[

e
c
n
e
r
e
f
f
i

D
g
n
i
m
T

i

0

20

40

60

80

100

Requests

Fig. 14: Timing difference for mapped libc version (2.19) vs.
other guesses.

VALIDATION OF REQUIREMENTS FOR REORGANIZATION.

For mounting a successful oracle attack against an InnoDB
record, it has to be guaranteed that a reorganization can be
triggered reliably. Reorganizing is needed to switch between
the different states introduced in Section VI-C3.

The condition for the ﬁrst reorganize from the initial state
(Figure 12a) to the reorganized state (Figure 12b) is already
guaranteed by the calculation of the initial size of ∣rAX ∣ in
Section VI-C3.

For the switch from the reorganized state in Figure 12b
to the reset state in Figure 12c it must be guaranteed that the
restoring of ∣rAT ∣ always triggers reorganization. Therefore
the following inequality must hold:

∣rAT ∣ > max f ree space − ∣˜rAT ∣ − ∣rT ∣ − ∣rAX ∣ − f ooter sz

We can claim that ∣˜rAT ∣ + ∣rT ∣ ≥ 4096 must hold as otherwise the attacker
does not even control one full page which is needed for the deduplication side
channel. Using this and neglecting the footer_sz we get:

∣rAT ∣ = 8125 > max f ree space − (∣˜rAT ∣ + ∣rT ∣) − ∣rAX ∣
> 16252 − 4096 − 4064 = 8092

For the last state switch from the reset state to a new reorga-
nized state there are two possibilities: ∣rAX ∣ is either increased
by δ as long as the resulting size is smaller than the maximum
record size or it is set to the maximum record size. In both
cases a reorganize should be triggered. Therefore for case 1
the following inequality must hold:

∣rAX ∣ + δ > max f ree space − (∣rAT ∣ − δ) − ∣rT ∣ − ∣rAX ∣

− f ooter sz

2 ∗ ∣rAX ∣ > max f ree space − ∣rAT ∣

2 ∗ 4064 = 8128 > 16252 − 8125 = 8127

For case two we again use that ∣˜rAT ∣ + ∣rT ∣ ≥ 4096 must
hold:

∣rAX,max∣ > max f ree space − ∣˜rAT ∣ − ∣rT ∣ − ∣rAX ∣ − f ooter sz
∣rAX,max∣ > max f ree space − (∣˜rAT ∣ + ∣rT ∣) − ∣rAX ∣

8125 > 16252 − 4096 − 4064 = 8092

16

Required Sizes of Records and Potential Leakage Rate.
The record rAX is required to trigger the reorganization of
records. Therefore, it initially has to be large enough so that
we can trigger a reorganization. We determine the worst case
size of the left free space for records within an index page as
follows after the ﬁrst reorganization:

∣rAX ∣ + 1 > trailing free space, which is always the case if
∣rAX ∣ + 1 > max_free_space − ∣rAX ∣ − ∣rAT ∣ − ∣rT ∣(−footer_sz).

footer_sz, ∣rT ∣ can be neglected in worst case inspection

max_free_space − ∣rAT ∣ − 1
2

= 4064 B

∣rAX ∣ >

therefore:

left_free_space = 16 252 B − 8125 B − 4064 B = 4063 B.

Next we want

to determine the boundaries for

the
into our attacker-controlled 4 kB-page and the re-
shift
quirements. We deﬁne the maximum alignment change
max alignment change as rAT − rATheader . To leak data
from rT , one page of our attacker-controlled ˜rAT record needs
to be page aligned. As we chose the size of rAT to be 8125 B,
we do not fully control 2 pages. We use a certain part of rAT
to bring the last 4096 B into a page alignment. A certain page
misalignment is even required to enable a successful attack,
since with a very low misalignment (e.g., 42), we cannot
control a full 4 kB page. For instance with a misalignment
of 42 bytes we only control 4071 (8125 − 4096 + 42) bytes
of the page to leak the record data (leak page). Therefore,
the misalignment needs to be large enough to control a full
leak page. Furthermore, the misalignment is unknown and we
need to leak the misalignment of the page. This can be done
via a remote memory-deduplication attack by trying different
offsets until the correct one is found. The misalignment is
the start of the record rAT (cf. Figure 12a). We determine
the minimal necessary misalignment offsetrAT after the initial
reorganization:

offsetrAT mod4096 + ∣rAT ∣ − 1 ≥ 4096 ∗ 2

offsetrAT mod4096 ≥ 4096 ∗ 2 + 1 − ∣rAT ∣
≥ 68.

offsetrAT

Hence, we need a misalignment of rAT of at
least
68 B. Furthermore, in case the record header moves to the
leak page, we would have another unknown value to leak.
Therefore, the misalignment needs to be smaller or equal to
4096−∣rATheader ∣. Each record is preceded by a record header
(rATheader ), which is maximum 27 bytes in our scenario. We
have the probability of 0.66 % that the rATheader moves to the
leak page and 1.66 % that the misalignment is less than 68.
We derive the maximum leakage rate for a InnoDB index page
as:

max leakage possible =
min(∣rAT ∣ − 1 − ∣rATheader ∣−
offsetrT mod 4096 + ∣rAT ∣ − 2 ⋅ 4096 + 1), ∣rT ∣, 4096)

Hence, we can leak up to a full size of rT ≤ 4096 if we
leak the misalignment and the requirements for offsetrAT hold.
This limits the leakage potential of the InnoDB attack.

MARIADB USER TABLE.

User table used in attack on InnoDB used in MariaDB Fig-

ure 15.

17

User Table

Id:int

username:varchar(200)

password::varchar(200)

image::mediumblob

Fig. 15: MariaDB user table, which is susceptible to a remote
memory-deduplication attack.

n
o
i
t
u
c
e
x
E

]
s
[

e
m
T

i

400

200

0

200

400

600

800

1,000

Memory Limit [MB]

Fig. 16: Average execution time in seconds (n = 10) until a
newly added entry is evicted from memcached depending on
its given memory limit.

MEMCACHED EVICTION.

The attacks on Memcached rely on the assumption that
an attacker can reliably trigger copy-on-write pagefaults by
updating the same item. However, one problem that can occur
in the Memcached attack is that another user gets the free
deduplicated page assigned instead of the attacker. Therefore,
it is a race between the attacker and potential other users to
get the page and then trigger the copy-on-write page fault on
the deduplicated page. Another issue is whether the pages
the
stays cached in Memcached for a longer period until
deduplication by the operating system happens, i.e., 15 minutes
on Windows. The eviction totally depends on the size of the
Memcached instance itself.

In this experiment, we validate how long an entry is cached
in an Memcached instance with different memory limits. First,
we launch a new memcached instance and load as many entries
into the instance until the memory limit is exhausted and the
instance has to evict existing entries.

Then, we add a new entry and probe how many seconds this
entry remains cached while we simultaneously apply a realistic
workload on the instance. We utilize memtier benchmark [46],
spawning 4 threads that simultaneously write and read entries
from the memcached instance using a gaussian access pattern
with an average of 671 121 ops/sec and an average bandwith
of 268.26 MB/s. Figure 16 illustrates after how many seconds
on average the added entry is evicted from the memcached
instance (n = 10). Figure 16 illustrates the eviction time for
different Memcached node sizes. As can be seen, the larger
the node is, the longer it takes to evict a certain item.



=== Content from bugzilla.redhat.com_3eeecc00_20250114_183420.html ===


* Login
  + Log in using an SSO provider:- [Fedora Account System](saml2_login.cgi?idp=Fedora%20Account%20System&target=show_bug.cgi%3Fid%3D1931327)
    - [Red Hat Associate](saml2_login.cgi?idp=Red%20Hat%20Associate&target=show_bug.cgi%3Fid%3D1931327)
    - [Red Hat Customer](saml2_login.cgi?idp=Red%20Hat%20Customer&target=show_bug.cgi%3Fid%3D1931327)+ Login using a Red Hat Bugzilla account
  + Forgot Password
  + [Create an Account](createaccount.cgi)

Red Hat Bugzilla – Bug 1931327

* [Home](./)
* [New](enter_bug.cgi)
* Search
  + [Simple Search](query.cgi?format=specific)
  + [Advanced Search](query.cgi?format=advanced)
* My Links
  + [Browse](describecomponents.cgi)
  + [Requests](request.cgi)
  + Reports
  + Current State
    - [Search](query.cgi)
    - [Tabular reports](query.cgi?format=report-table)
    - [Graphical reports](query.cgi?format=report-graph)
    - [Duplicates](duplicates.cgi)
  + Other Reports
    - [User Changes](https://bugzilla.redhat.com/page.cgi?id=user_activity.html)
  + Plotly Reports
    - [Bug Status](https://bugzilla.redhat.com/page.cgi?id=bug_status.html)
    - [Bug Severity](https://bugzilla.redhat.com/page.cgi?id=bug_severity.html)
    - [Non-Defaults](https://bugzilla.redhat.com/page.cgi?id=non_defaults.html)
* [Product Dashboard](page.cgi?id=productdashboard.html)

- Help
  * [Page Help!](docs/en/html/using/understanding.html)
  * [Bug Writing Guidelines](page.cgi?id=bug-writing.html)
  * [What's new](page.cgi?id=whats-new.html)
  * [Browser Support Policy](https://access.redhat.com/help/browsers)
  * [5.0.4.rh103 Release notes](page.cgi?id=release-notes.html)
  * [FAQ](page.cgi?id=faq.html)
  * [Guides index](docs/en/html/index.html)
  * [User guide](docs/en/html/using/index.html)
  * [Web Services](docs/en/html/integrating/api/Bugzilla/WebService/Bug.html)
  * [Contact](page.cgi?id=redhat/contact.html)
  * [Legal](page.cgi?id=terms-conditions.html)
- [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")

This site requires JavaScript to be enabled to function correctly, please enable it.

[**Bug 1931327**](show_bug.cgi?id=1931327)
(CVE-2021-3714)
- [CVE-2021-3714](https://access.redhat.com/security/cve/CVE-2021-3714) kernel: Remote Page Deduplication Attacks

[Summary:](page.cgi?id=fields.html#short_desc "The bug summary is a short sentence which succinctly describes what the bug is about.")
CVE-2021-3714 kernel: Remote Page Deduplication Attacks

| | [Keywords](describekeywords.cgi): | Security | | --- | --- | | [Status](page.cgi?id=fields.html#bug_status): | CLOSED WONTFIX | | [Alias:](page.cgi?id=fields.html#alias "A short, unique name assigned to a bug in order to assist with looking it up and referring to it in other places in Bugzilla.") | CVE-2021-3714 | | [Product:](describecomponents.cgi "Bugs are categorised into Products and Components. Select a Classification to narrow down this list.") | Security Response | | [Classification:](page.cgi?id=fields.html#classification "Bugs are categorised into Classifications, Products and Components. classifications is the top-level categorisation.") | Other | | [Component:](describecomponents.cgi?product=Security Response "Components are second-level categories; each belongs to a particular Product. Select a Product to narrow down this list.") | vulnerability | | [Sub Component:](page.cgi?id=fields.html#rh_sub_components "The sub component of a specific component") | --- | | [Version:](page.cgi?id=fields.html#version "The version field defines the version of the software the bug was found in.") | unspecified | | [Hardware:](page.cgi?id=fields.html#rep_platform "The hardware platform the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | All | | [OS:](page.cgi?id=fields.html#op_sys "The operating system the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | Linux | | [Priority:](page.cgi?id=fields.html#priority) | medium | | [Severity:](page.cgi?id=fields.html#bug_severity) | medium | | [Target Milestone:](page.cgi?id=fields.html#target_milestone "The Target Milestone field is used to define when the engineer the bug is assigned to expects to fix it.") | --- | | [Assignee:](page.cgi?id=fields.html#assigned_to "The person in charge of resolving the bug.") | Red Hat Product Security | | [QA Contact:](page.cgi?id=fields.html#qa_contact "The person responsible for confirming this bug if it is unconfirmed, and for verifying the fix once the bug has been resolved.") |  | | [Docs Contact:](page.cgi?id=fields.html#docs_contact "The person responsible for documenting once the bug has been resolved.") |  | | [URL:](page.cgi?id=fields.html#bug_file_loc "Bugs can have a URL associated with them - for example, a pointer to a web site where the problem is seen.") |  | | [Whiteboard:](page.cgi?id=fields.html#status_whiteboard "Each bug has a free-form single line text entry box for adding tags and status information.") |  | | [Depends On:](page.cgi?id=fields.html#dependson "The bugs listed here must be resolved before this bug can be resolved.") | [2024000](show_bug.cgi?id=2024000) [2024001](show_bug.cgi?id=2024001) [2024002](show_bug.cgi?id=2024002) [2024003](show_bug.cgi?id=2024003) [2024469](show_bug.cgi?id=2024469) [2024470](show_bug.cgi?id=2024470) [2024471](show_bug.cgi?id=2024471) [2024472](show_bug.cgi?id=2024472) [2024473](show_bug.cgi?id=2024473) [2024474](show_bug.cgi?id=2024474) [2024475](show_bug.cgi?id=2024475) [2024476](show_bug.cgi?id=2024476) [2024477](show_bug.cgi?id=2024477) [2024478](show_bug.cgi?id=2024478) [2024479](show_bug.cgi?id=2024479) [2024480](show_bug.cgi?id=2024480) [2024481](show_bug.cgi?id=2024481) [2024482](show_bug.cgi?id=2024482) [2024483](show_bug.cgi?id=2024483) [2024484](show_bug.cgi?id=2024484) [2024485](show_bug.cgi?id=2024485) [2024486](show_bug.cgi?id=2024486) [2024487](show_bug.cgi?id=2024487) [2024488](show_bug.cgi?id=2024488) [2029650](show_bug.cgi?id=2029650) [2070414](show_bug.cgi?id=2070414 "CLOSED EOL - CVE-2021-3714 kernel: Remote Page Deduplication Attacks [fedora-all]") [2089896](show_bug.cgi?id=2089896) [2089897](show_bug.cgi?id=2089897) [2089898](show_bug.cgi?id=2089898) [2089899](show_bug.cgi?id=2089899) | | [Blocks:](page.cgi?id=fields.html#blocked "This bug must be resolved before the bugs listed in this field can be resolved.") | [1927328](show_bug.cgi?id=1927328) | | TreeView+ | [depends on](buglist.cgi?bug_id=1931327&bug_id_type=anddependson&format=tvp) / [blocked](buglist.cgi?bug_id=1931327&bug_id_type=andblocked&format=tvp&tvp_dir=blocked) |  | |  | | [Reported:](page.cgi?id=fields.html#reporter) | 2021-02-22 07:31 UTC by Wade Mealing | | --- | --- | | [Modified:](page.cgi?id=fields.html#modified) | 2024-02-01 23:40 UTC ([History](show_activity.cgi?id=1931327)) | | [CC List:](page.cgi?id=fields.html#cclist) | 55 users (show)  aarcange acaringi adscvr airlied alciregi aquini bhu bmasney bskeggs carnil chwhite crwood ddutile dvlasenk hdegoede hkrzesin hpa jarod jarodwilson jburrell jfaracco jforbes jglisse jlelli joe.lawrence jonathan josef jpoimboe jshortt jstancek jwboyer jwyatt kcarcia kernel-maint kernel-mgr kyoshida lgoncalv linville liwan lzampier masami256 mchehab nmurray ptalbert qzhao rkeshri rvrbovsk scweaver security-response-team steved vkumar vsroka walters williams zhijwang | | Fixed In Version: |  | | | Doc Type: | If docs needed, set a value | | | Doc Text: | A flaw was found in the Linux kernels memory deduplication mechanism. Previous work has shown that memory deduplication can be attacked via a local exploitation mechanism. The same technique can be used if an attacker can upload page sized files and detect the change in access time from a networked service to determine if the page has been merged. | | | Clone Of: |  | | | Environment: |  | | | Last Closed: | 2023-06-26 12:45:09 UTC | | | Embargoed: |  | | |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| --- | | |

| | Attachments | [(Terms of Use)](page.cgi?id=terms-conditions.html) | | | --- | --- | --- | |  | | | |  |
| --- | --- | --- | --- | --- | --- | --- | --- |

| [Description](show_bug.cgi?id=1931327#c0)  Wade Mealing    2021-02-22 07:31:19 UTC  ``` A flaw was found in the Linux kernels memory deduplication mechanism. Previous work has shown that memory deduplication can be attacked via a local exploitation mechanism. The same technique can be used if an attacker can upload page sized files and detect the change in access time from a networked service to determine if the page has been merged.  This attack can leak targeted information if an attacker is wiling to write an exploit for the services running.   ```  [Comment 15](show_bug.cgi?id=1931327#c15)  Rohit Keshri    2022-03-31 06:38:51 UTC  ``` Created kernel tracking bugs for this issue:  Affects: fedora-all [[bug 2070414](show_bug.cgi?id=2070414 "CLOSED EOL - CVE-2021-3714 kernel: Remote Page Deduplication Attacks [fedora-all]")]   ```  [Comment 16](show_bug.cgi?id=1931327#c16)  Salvatore Bonaccorso    2022-04-02 19:02:16 UTC  ``` Are there any public information available on this flaw? I would like to track the correct status for the kernel in Debian, but fail to find information on this issue. Is this fixed upstream? What are the upstream commit(s)?   ```  [Comment 17](show_bug.cgi?id=1931327#c17)  Wade Mealing    2022-04-07 05:36:52 UTC  ``` This is currently not fixed upstream.  I'm no longer doing incident response, so CC'ing rkeshri for further details.   ```  [Comment 18](show_bug.cgi?id=1931327#c18)  Rohit Keshri    2022-05-10 17:41:58 UTC  ``` In reply to [comment #16](show_bug.cgi?id=1931327#c16): > Are there any public information available on this flaw? I would like to > track the correct status for the kernel in Debian, but fail to find > information on this issue. Is this fixed upstream? What are the upstream > commit(s)?  Hello Carnil, <https://arxiv.org/pdf/2111.08553.pdf> is for reference. thanks   ```  [Comment 19](show_bug.cgi?id=1931327#c19)  Salvatore Bonaccorso    2022-05-10 18:52:49 UTC  ``` (In reply to Rohit Keshri from [comment #18](show_bug.cgi?id=1931327#c18)) > In reply to [comment #16](show_bug.cgi?id=1931327#c16): > > Are there any public information available on this flaw? I would like to > > track the correct status for the kernel in Debian, but fail to find > > information on this issue. Is this fixed upstream? What are the upstream > > commit(s)? >  > Hello Carnil, <https://arxiv.org/pdf/2111.08553.pdf> is for reference. thanks  Thank you!   ``` |  |
| --- | --- |

---

| Note You need to [log in](show_bug.cgi?id=1931327&GoAheadAndLogIn=1) before you can comment on or make changes to this bug. |
| --- |

---

[Privacy](page.cgi?id=redhat/privacy.html)
[Contact](page.cgi?id=redhat/contact.html)
[FAQ](page.cgi?id=faq.html)
[Legal](page.cgi?id=terms-conditions.html)



=== Content from access.redhat.com_e0336dc6_20250115_112814.html ===


[Skip to navigation](#pfe-navigation)
[Skip to main content](#cp-main)
### Utilities

* [Subscriptions](https://access.redhat.com/management/)
* [Downloads](https://access.redhat.com/downloads/)
* [Red Hat Console](//console.redhat.com/)
* [Get Support](https://access.redhat.com/support/)

[![Red Hat Customer Portal](https://access.redhat.com/chrome_themes/nimbus/img/red-hat-customer-portal.svg)](https://access.redhat.com/)

* [Subscriptions](https://access.redhat.com/management/)
* [Downloads](https://access.redhat.com/downloads/)
* [Red Hat Console](//console.redhat.com/)
* [Get Support](https://access.redhat.com/support/)
* [Products](https://access.redhat.com/)
  ### Top Products

  + [Red Hat Enterprise Linux](https://access.redhat.com/products/red-hat-enterprise-linux/)
  + [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform)
  + [Red Hat Ansible Automation Platform](https://access.redhat.com/products/red-hat-ansible-automation-platform/)
  [All Products](https://access.redhat.com/products/)

  ### Downloads and Containers

  + [Downloads](https://access.redhat.com/downloads/)
  + [Packages](https://access.redhat.com/downloads/content/package-browser)
  + [Containers](https://catalog.redhat.com/software/containers/explore/)
  ### Top Resources

  + [Documentation](//docs.redhat.com/)
  + [Product Life Cycles](https://access.redhat.com/product-life-cycles/)
  + [Product Compliance](https://access.redhat.com/articles/1202803)
  + [Errata](https://access.redhat.com/errata/)
* [Knowledge](https://access.redhat.com/labs/)
  ### Red Hat Knowledge Center

  + [Knowledgebase Solutions](https://access.redhat.com/search/?q=*&p=1&rows=10&documentKind=Solution)
  + [Knowledgebase Articles](https://access.redhat.com/search/?q=*&p=1&rows=10&documentKind=Article)
  + [Customer Portal Labs](https://access.redhat.com/labs/)
  + [Errata](https://access.redhat.com/errata/)
  ### Top Product Docs

  + [Red Hat Enterprise Linux](//docs.redhat.com/en/documentation/red_hat_enterprise_linux/)
  + [Red Hat OpenShift](//docs.redhat.com/en/documentation/openshift_container_platform/)
  + [Red Hat Ansible Automation Platform](//docs.redhat.com/en/documentation/red_hat_ansible_automation_platform/)
  [All Product Docs](//docs.redhat.com/en/products)

  ### [Training and Certification](//www.redhat.com/en/services/training-and-certification)

  + [About](//www.redhat.com/en/services/training-and-certification)
  + [Course Index](//www.redhat.com/en/services/training/all-courses-exams)
  + [Certification Index](//www.redhat.com/en/services/certifications)
  + [Skill Assessment](//skills.ole.redhat.com/)
* [Security](https://access.redhat.com/security/)
  ### [Red Hat Product Security Center](https://access.redhat.com/security)

  + [Security Updates](https://access.redhat.com/security)
  + [Security Advisories](https://access.redhat.com/security/security-updates/#/security-advisories)
  + [Red Hat CVE Database](https://access.redhat.com/security/security-updates/#/cve)
  + [Errata](https://access.redhat.com/errata/)
  ### References

  + [Security Bulletins](https://access.redhat.com/security/vulnerabilities)
  + [Security Measurement](https://www.redhat.com/security/data/metrics/)
  + [Severity Ratings](https://access.redhat.com/security/updates/classification/)
  + [Security Data](https://access.redhat.com/security/data)
  ### Top Resources

  + [Security Labs](https://access.redhat.com/security/security-updates/#/security-labs)
  + [Backporting Policies](https://access.redhat.com/security/updates/backporting/)
  + [Security Blog](//redhat.com/en/blog/channel/security)
* [Support](https://access.redhat.com/support/)
  ### [Red Hat Support](https://access.redhat.com/support/)

  + [Support Cases](https://access.redhat.com/support/cases/)
  + [Troubleshoot](https://access.redhat.com/support/cases/#/troubleshoot)
  + [Get Support](https://access.redhat.com/support/)
  + [Contact Red Hat Support](https://access.redhat.com/support/contact/)
  ### [Red Hat Community Support](https://access.redhat.com/community)

  + [Customer Portal Community](https://access.redhat.com/community/)
  + [Community Discussions](https://access.redhat.com/discussions/)
  + [Red Hat Accelerator Program](https://access.redhat.com/accelerators/)
  ### Top Resources

  + [Product Life Cycles](https://access.redhat.com/product-life-cycles/)
  + [Customer Portal Labs](https://access.redhat.com/labs/)
  + [Red Hat JBoss Supported Configurations](https://access.redhat.com/support/configurations/jboss)
  + [Red Hat Insights](https://cloud.redhat.com/insights)

Or [troubleshoot an issue](/support/cases/#/troubleshoot).

English

## Select Your Language

* [English](https://access.redhat.com/changeLanguage?language=en)
* [Français](https://access.redhat.com/changeLanguage?language=fr)
* [한국어](https://access.redhat.com/changeLanguage?language=ko)
* [日本語](https://access.redhat.com/changeLanguage?language=ja)
* [中文 (中国)](https://access.redhat.com/changeLanguage?language=zh_CN)

### Infrastructure and Management

* [Red Hat Enterprise Linux](https://access.redhat.com/products/red-hat-enterprise-linux/)
* [Red Hat Satellite](https://access.redhat.com/products/red-hat-satellite/)
* [Red Hat Subscription Management](https://access.redhat.com/products/red-hat-subscription-management/)
* [Red Hat Insights](https://access.redhat.com/products/red-hat-insights/)
* [Red Hat Ansible Automation Platform](https://access.redhat.com/products/red-hat-ansible-automation-platform/)
### Cloud Computing

* [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform)
* [Red Hat OpenStack Platform](https://access.redhat.com/products/red-hat-openstack-platform/)
* [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform/)
* [Red Hat OpenShift AI](https://access.redhat.com/products/red-hat-openshift-ai/)
* [Red Hat OpenShift Dedicated](https://access.redhat.com/products/openshift-dedicated-red-hat/)
* [Red Hat Advanced Cluster Security for Kubernetes](https://access.redhat.com/products/red-hat-advanced-cluster-security-for-kubernetes/)
* [Red Hat Advanced Cluster Management for Kubernetes](https://access.redhat.com/products/red-hat-advanced-cluster-management-for-kubernetes/)
* [Red Hat Quay](https://access.redhat.com/products/red-hat-quay/)
* [Red Hat OpenShift Dev Spaces](https://access.redhat.com/products/red-hat-openshift-dev-spaces)
* [Red Hat OpenShift Service on AWS](https://access.redhat.com/products/red-hat-openshift-service-aws)
### Storage

* [Red Hat Gluster Storage](https://access.redhat.com/products/red-hat-storage/)
* [Red Hat Hyperconverged Infrastructure](https://access.redhat.com/products/red-hat-hyperconverged-infrastructure/)
* [Red Hat Ceph Storage](https://access.redhat.com/products/red-hat-ceph-storage/)
* [Red Hat OpenShift Data Foundation](https://access.redhat.com/products/red-hat-openshift-data-foundation)
### Runtimes

* [Red Hat Runtimes](https://access.redhat.com/products/red-hat-runtimes/)
* [Red Hat JBoss Enterprise Application Platform](https://access.redhat.com/products/red-hat-jboss-enterprise-application-platform/)
* [Red Hat Data Grid](https://access.redhat.com/products/red-hat-data-grid/)
* [Red Hat JBoss Web Server](https://access.redhat.com/products/red-hat-jboss-web-server/)
* [Red Hat build of Keycloak](https://access.redhat.com/products/red-hat-build-of-keycloak/)
* [Red Hat support for Spring Boot](https://access.redhat.com/products/spring-boot/)
* [Red Hat build of Node.js](https://access.redhat.com/products/nodejs/)
* [Red Hat build of Quarkus](https://access.redhat.com/products/quarkus/)
### Integration and Automation

* [Red Hat Application Foundations](https://access.redhat.com/products/red-hat-application-foundations/)
* [Red Hat Fuse](https://access.redhat.com/products/red-hat-fuse/)
* [Red Hat AMQ](https://access.redhat.com/products/red-hat-amq/)
* [Red Hat 3scale API Management](https://access.redhat.com/products/red-hat-3scale/)

[All Products](https://access.redhat.com/products/)

**We're sorry but cve-details doesn't work properly without JavaScript enabled. Please enable it to continue.**

[![Red Hat](https://static.redhat.com/libs/redhat/brand-assets/2/corp/logo--on-dark.svg)](https://redhat.com/en)
[X (formerly Twitter)](https://twitter.com/RedHat)
### Quick Links

* [Downloads](https://access.redhat.com/downloads/)
* [Subscriptions](https://access.redhat.com/management)
* [Support Cases](https://access.redhat.com/support)
* [Customer Service](https://access.redhat.com/support/customer-service)
* [Product Documentation](//docs.redhat.com/)

### Help

* [Contact Us](https://access.redhat.com/support/contact/)
* [Customer Portal FAQ](https://access.redhat.com/articles/33844)
* [Log-in Assistance](https://access.redhat.com/help/login_assistance)

### Site Info

* [Trust Red Hat](https://www.redhat.com/en/trust)
* [Browser Support Policy](https://www.redhat.com/en/about/browser-support)
* [Accessibility](https://www.redhat.com/en/about/digital-accessibility)
* [Awards and Recognition](https://access.redhat.com/recognition/)
* [Colophon](https://access.redhat.com/help/colophon/)

### Related Sites

* [redhat.com](https://www.redhat.com/)
* [developers.redhat.com](http://developers.redhat.com/)
* [connect.redhat.com](https://connect.redhat.com/)
* [cloud.redhat.com](https://cloud.redhat.com/)

### Red Hat legal and privacy links

* [About Red Hat](https://redhat.com/en/about/company)
* [Jobs](https://redhat.com/en/jobs)
* [Events](https://redhat.com/en/events)
* [Locations](https://redhat.com/en/about/office-locations)
* [Contact Red Hat](https://redhat.com/en/contact)
* [Red Hat Blog](https://redhat.com/en/blog)
* [Diversity, equity, and inclusion](https://redhat.com/en/about/our-culture/diversity-equity-inclusion)
* [Cool Stuff Store](https://coolstuff.redhat.com/)
* [Red Hat Summit](https://www.redhat.com/en/summit)

 © 2025 Red Hat, Inc.
### Red Hat legal and privacy links

* [Privacy statement](https://redhat.com/en/about/privacy-policy)
* [Terms of use](https://redhat.com/en/about/terms-use)
* [All policies and guidelines](https://redhat.com/en/about/all-policies-guidelines)
* [Digital accessibility](https://redhat.com/en/about/digital-accessibility)


