=== Content from github.com_dd8b5af3_20250114_205459.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FMidnightCommander%2Fmc%2Fblob%2F5c1d3c55dd15356ec7d079084d904b7b0fd58d3e%2Fsrc%2Fvfs%2Fsftpfs%2Fconnection.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FMidnightCommander%2Fmc%2Fblob%2F5c1d3c55dd15356ec7d079084d904b7b0fd58d3e%2Fsrc%2Fvfs%2Fsftpfs%2Fconnection.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=MidnightCommander%2Fmc)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[MidnightCommander](/MidnightCommander)
/
**[mc](/MidnightCommander/mc)**
Public

* [Notifications](/login?return_to=%2FMidnightCommander%2Fmc) You must be signed in to change notification settings
* [Fork
  524](/login?return_to=%2FMidnightCommander%2Fmc)
* [Star
   2.7k](/login?return_to=%2FMidnightCommander%2Fmc)

* [Code](/MidnightCommander/mc)
* [Pull requests
  18](/MidnightCommander/mc/pulls)
* [Actions](/MidnightCommander/mc/actions)
* [Security](/MidnightCommander/mc/security)
* [Insights](/MidnightCommander/mc/pulse)

Additional navigation options

* [Code](/MidnightCommander/mc)
* [Pull requests](/MidnightCommander/mc/pulls)
* [Actions](/MidnightCommander/mc/actions)
* [Security](/MidnightCommander/mc/security)
* [Insights](/MidnightCommander/mc/pulse)

## Files

 5c1d3c5
## Breadcrumbs

1. [mc](/MidnightCommander/mc/tree/5c1d3c55dd15356ec7d079084d904b7b0fd58d3e)
2. /[src](/MidnightCommander/mc/tree/5c1d3c55dd15356ec7d079084d904b7b0fd58d3e/src)
3. /[vfs](/MidnightCommander/mc/tree/5c1d3c55dd15356ec7d079084d904b7b0fd58d3e/src/vfs)
4. /[sftpfs](/MidnightCommander/mc/tree/5c1d3c55dd15356ec7d079084d904b7b0fd58d3e/src/vfs/sftpfs)
/
# connection.c

Copy path Blame  Blame
## Latest commit

## History

[History](/MidnightCommander/mc/commits/5c1d3c55dd15356ec7d079084d904b7b0fd58d3e/src/vfs/sftpfs/connection.c)558 lines (443 loc) · 17.4 KB 5c1d3c5
## Breadcrumbs

1. [mc](/MidnightCommander/mc/tree/5c1d3c55dd15356ec7d079084d904b7b0fd58d3e)
2. /[src](/MidnightCommander/mc/tree/5c1d3c55dd15356ec7d079084d904b7b0fd58d3e/src)
3. /[vfs](/MidnightCommander/mc/tree/5c1d3c55dd15356ec7d079084d904b7b0fd58d3e/src/vfs)
4. /[sftpfs](/MidnightCommander/mc/tree/5c1d3c55dd15356ec7d079084d904b7b0fd58d3e/src/vfs/sftpfs)
/
# connection.c

Top
## File metadata and controls

* Code
* Blame

558 lines (443 loc) · 17.4 KB[Raw](https://github.com/MidnightCommander/mc/raw/5c1d3c55dd15356ec7d079084d904b7b0fd58d3e/src/vfs/sftpfs/connection.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558/\* Virtual File System: SFTP file system. The internal functions: connections
 Copyright (C) 2011-2021 Free Software Foundation, Inc.
 Written by: Ilia Maslakov <il.smind@gmail.com>, 2011 Slava Zanko <slavazanko@gmail.com>, 2011, 2012, 2013
 This file is part of the Midnight Commander.
 The Midnight Commander is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 The Midnight Commander is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>. \*/
#include <config.h>#include <errno.h>
#include <netdb.h> /\* struct hostent \*/#include <sys/socket.h> /\* AF\_INET \*/#include <netinet/in.h> /\* struct in\_addr \*/#ifdef HAVE\_ARPA\_INET\_H#include <arpa/inet.h>#endif
#include <libssh2.h>#include <libssh2\_sftp.h>
#include "lib/global.h"
#include "lib/util.h"#include "lib/tty/tty.h" /\* tty\_enable\_interrupt\_key () \*/#include "lib/vfs/utilvfs.h"
#include "internal.h"
/\*\*\* global variables \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
/\*\*\* file scope macro definitions \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
/\*\*\* file scope type declarations \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
/\*\*\* file scope variables \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
static const char \*kbi\_passwd = NULL;static const struct vfs\_s\_super \*kbi\_super = NULL;
/\* --------------------------------------------------------------------------------------------- \*//\*\*\* file scope functions \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*//\* --------------------------------------------------------------------------------------------- \*//\*\* \* Create socket to host. \* \* @param super connection data \* @param mcerror pointer to the error handler \* @return socket descriptor number, -1 if any error was occurred \*/
static intsftpfs\_open\_socket (struct vfs\_s\_super \*super, GError \*\* mcerror){ struct addrinfo hints, \*res = NULL, \*curr\_res; int my\_socket = 0; char port[BUF\_TINY]; int e;
 mc\_return\_val\_if\_error (mcerror, LIBSSH2\_INVALID\_SOCKET);
 if (super->path\_element->host == NULL || \*super->path\_element->host == '\0') { mc\_propagate\_error (mcerror, 0, "%s", \_("sftp: Invalid host name.")); return LIBSSH2\_INVALID\_SOCKET; }
 sprintf (port, "%hu", (unsigned short) super->path\_element->port);
 tty\_enable\_interrupt\_key (); /\* clear the interrupt flag \*/
 memset (&hints, 0, sizeof (hints)); hints.ai\_family = AF\_UNSPEC; hints.ai\_socktype = SOCK\_STREAM;
#ifdef AI\_ADDRCONFIG /\* By default, only look up addresses using address types for \* which a local interface is configured (i.e. no IPv6 if no IPv6 \* interfaces, likewise for IPv4 (see RFC 3493 for details). \*/ hints.ai\_flags = AI\_ADDRCONFIG;#endif
 e = getaddrinfo (super->path\_element->host, port, &hints, &res);
#ifdef AI\_ADDRCONFIG if (e == EAI\_BADFLAGS) { /\* Retry with no flags if AI\_ADDRCONFIG was rejected. \*/ hints.ai\_flags = 0; e = getaddrinfo (super->path\_element->host, port, &hints, &res); }#endif
 if (e != 0) { mc\_propagate\_error (mcerror, e, \_("sftp: %s"), gai\_strerror (e)); my\_socket = LIBSSH2\_INVALID\_SOCKET; goto ret; }
 for (curr\_res = res; curr\_res != NULL; curr\_res = curr\_res->ai\_next) { int save\_errno;
 my\_socket = socket (curr\_res->ai\_family, curr\_res->ai\_socktype, curr\_res->ai\_protocol);
 if (my\_socket < 0) { if (curr\_res->ai\_next != NULL) continue;
 vfs\_print\_message (\_("sftp: %s"), unix\_error\_string (errno)); my\_socket = LIBSSH2\_INVALID\_SOCKET; goto ret; }
 vfs\_print\_message (\_("sftp: making connection to %s"), super->path\_element->host);
 if (connect (my\_socket, curr\_res->ai\_addr, curr\_res->ai\_addrlen) >= 0) break;
 save\_errno = errno;
 close (my\_socket);
 if (save\_errno == EINTR && tty\_got\_interrupt ()) mc\_propagate\_error (mcerror, 0, "%s", \_("sftp: connection interrupted by user")); else if (res->ai\_next == NULL) mc\_propagate\_error (mcerror, save\_errno, \_("sftp: connection to server failed: %s"), unix\_error\_string (save\_errno)); else continue;
 my\_socket = LIBSSH2\_INVALID\_SOCKET; break; }
 ret: if (res != NULL) freeaddrinfo (res); tty\_disable\_interrupt\_key (); return my\_socket;}
/\* --------------------------------------------------------------------------------------------- \*//\*\* \* Recognize authenticaion types supported by remote side and filling internal 'super' structure by \* proper enum's values. \* \* @param super connection data \* @return TRUE if some of authentication methods is available, FALSE otherwise \*/static gbooleansftpfs\_recognize\_auth\_types (struct vfs\_s\_super \*super){ char \*userauthlist; sftpfs\_super\_t \*sftpfs\_super = SFTP\_SUPER (super);
 /\* check what authentication methods are available \*/ /\* userauthlist is internally managed by libssh2 and freed by libssh2\_session\_free() \*/ userauthlist = libssh2\_userauth\_list (sftpfs\_super->session, super->path\_element->user, strlen (super->path\_element->user));
 if (userauthlist == NULL) return FALSE;
 if ((strstr (userauthlist, "password") != NULL || strstr (userauthlist, "keyboard-interactive") != NULL) && (sftpfs\_super->config\_auth\_type & PASSWORD) != 0) sftpfs\_super->auth\_type |= PASSWORD;
 if (strstr (userauthlist, "publickey") != NULL && (sftpfs\_super->config\_auth\_type & PUBKEY) != 0) sftpfs\_super->auth\_type |= PUBKEY;
 if ((sftpfs\_super->config\_auth\_type & AGENT) != 0) sftpfs\_super->auth\_type |= AGENT;
 return TRUE;}
/\* --------------------------------------------------------------------------------------------- \*//\*\* \* Open connection to host using SSH-agent helper. \* \* @param super connection data \* @param mcerror pointer to the error handler \* @return TRUE if connection was successfully opened, FALSE otherwise \*/
static gbooleansftpfs\_open\_connection\_ssh\_agent (struct vfs\_s\_super \*super, GError \*\* mcerror){ sftpfs\_super\_t \*sftpfs\_super = SFTP\_SUPER (super); struct libssh2\_agent\_publickey \*identity, \*prev\_identity = NULL; int rc;
 mc\_return\_val\_if\_error (mcerror, FALSE);
 sftpfs\_super->agent = NULL;
 if ((sftpfs\_super->auth\_type & AGENT) == 0) return FALSE;
 /\* Connect to the ssh-agent \*/ sftpfs\_super->agent = libssh2\_agent\_init (sftpfs\_super->session); if (sftpfs\_super->agent == NULL) return FALSE;
 if (libssh2\_agent\_connect (sftpfs\_super->agent) != 0) return FALSE;
 if (libssh2\_agent\_list\_identities (sftpfs\_super->agent) != 0) return FALSE;
 while (TRUE) { rc = libssh2\_agent\_get\_identity (sftpfs\_super->agent, &identity, prev\_identity); if (rc == 1) break;
 if (rc < 0) return FALSE;
 if (libssh2\_agent\_userauth (sftpfs\_super->agent, super->path\_element->user, identity) == 0) break;
 prev\_identity = identity; }
 return (rc == 0);}
/\* --------------------------------------------------------------------------------------------- \*//\*\* \* Open connection to host using SSH-keypair. \* \* @param super connection data \* @param mcerror pointer to the error handler \* @return TRUE if connection was successfully opened, FALSE otherwise \*/
static gbooleansftpfs\_open\_connection\_ssh\_key (struct vfs\_s\_super \*super, GError \*\* mcerror){ sftpfs\_super\_t \*sftpfs\_super = SFTP\_SUPER (super); char \*p, \*passwd; gboolean ret\_value = FALSE;
 mc\_return\_val\_if\_error (mcerror, FALSE);
 if ((sftpfs\_super->auth\_type & PUBKEY) == 0) return FALSE;
 if (sftpfs\_super->privkey == NULL) return FALSE;
 if (libssh2\_userauth\_publickey\_fromfile (sftpfs\_super->session, super->path\_element->user, sftpfs\_super->pubkey, sftpfs\_super->privkey, super->path\_element->password) == 0) return TRUE;
 p = g\_strdup\_printf (\_("sftp: Enter passphrase for %s "), super->path\_element->user); passwd = vfs\_get\_password (p); g\_free (p);
 if (passwd == NULL) mc\_propagate\_error (mcerror, 0, "%s", \_("sftp: Passphrase is empty.")); else { ret\_value = (libssh2\_userauth\_publickey\_fromfile (sftpfs\_super->session, super->path\_element->user, sftpfs\_super->pubkey, sftpfs\_super->privkey, passwd) == 0); g\_free (passwd); }
 return ret\_value;}
/\* --------------------------------------------------------------------------------------------- \*/
/\*\* \* Keyboard-interactive password helper for opening connection to host by \* sftpfs\_open\_connection\_ssh\_password \* \* Uses global kbi\_super (data with existing connection) and kbi\_passwd (password) \* \* @param name username \* @param name\_len length of @name \* @param instruction unused \* @param instruction\_len unused \* @param num\_prompts number of possible problems to process \* @param prompts array of prompts to process \* @param responses array of responses, one per prompt \* @param abstract unused \*/
staticLIBSSH2\_USERAUTH\_KBDINT\_RESPONSE\_FUNC (sftpfs\_keyboard\_interactive\_helper){ int i; size\_t len;
 (void) instruction; (void) instruction\_len; (void) abstract;
 if (kbi\_super == NULL || kbi\_passwd == NULL) return;
 if (strncmp (name, kbi\_super->path\_element->user, name\_len) != 0) return;
 /\* assume these are password prompts \*/ len = strlen (kbi\_passwd);
 for (i = 0; i < num\_prompts; ++i) if (strncmp (prompts[i].text, "Password: ", prompts[i].length) == 0) { responses[i].text = strdup (kbi\_passwd); responses[i].length = len; }}
/\* --------------------------------------------------------------------------------------------- \*//\*\* \* Open connection to host using password. \* \* @param super connection data \* @param mcerror pointer to the error handler \* @return TRUE if connection was successfully opened, FALSE otherwise \*/
static gbooleansftpfs\_open\_connection\_ssh\_password (struct vfs\_s\_super \*super, GError \*\* mcerror){ sftpfs\_super\_t \*sftpfs\_super = SFTP\_SUPER (super); char \*p, \*passwd; gboolean ret\_value = FALSE; int rc;
 mc\_return\_val\_if\_error (mcerror, FALSE);
 if ((sftpfs\_super->auth\_type & PASSWORD) == 0) return FALSE;
 if (super->path\_element->password != NULL) { while ((rc = libssh2\_userauth\_password (sftpfs\_super->session, super->path\_element->user, super->path\_element->password)) == LIBSSH2\_ERROR\_EAGAIN); if (rc == 0) return TRUE;
 kbi\_super = super; kbi\_passwd = super->path\_element->password;
 while ((rc = libssh2\_userauth\_keyboard\_interactive (sftpfs\_super->session, super->path\_element->user, sftpfs\_keyboard\_interactive\_helper)) == LIBSSH2\_ERROR\_EAGAIN) ;
 kbi\_super = NULL; kbi\_passwd = NULL;
 if (rc == 0) return TRUE; }
 p = g\_strdup\_printf (\_("sftp: Enter password for %s "), super->path\_element->user); passwd = vfs\_get\_password (p); g\_free (p);
 if (passwd == NULL) mc\_propagate\_error (mcerror, 0, "%s", \_("sftp: Password is empty.")); else { while ((rc = libssh2\_userauth\_password (sftpfs\_super->session, super->path\_element->user, passwd)) == LIBSSH2\_ERROR\_EAGAIN) ;
 if (rc != 0) { kbi\_super = super; kbi\_passwd = passwd;
 while ((rc = libssh2\_userauth\_keyboard\_interactive (sftpfs\_super->session, super->path\_element->user, sftpfs\_keyboard\_interactive\_helper)) == LIBSSH2\_ERROR\_EAGAIN) ;
 kbi\_super = NULL; kbi\_passwd = NULL; }
 if (rc == 0) { ret\_value = TRUE; g\_free (super->path\_element->password); super->path\_element->password = passwd; } else g\_free (passwd); }
 return ret\_value;}
/\* --------------------------------------------------------------------------------------------- \*//\*\*\* public functions \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*//\* --------------------------------------------------------------------------------------------- \*//\*\* \* Open new connection. \* \* @param super connection data \* @param mcerror pointer to the error handler \* @return 0 if success, -1 otherwise \*/
intsftpfs\_open\_connection (struct vfs\_s\_super \*super, GError \*\* mcerror){ int rc; sftpfs\_super\_t \*sftpfs\_super = SFTP\_SUPER (super);
 mc\_return\_val\_if\_error (mcerror, -1);
 /\* \* The application code is responsible for creating the socket \* and establishing the connection \*/ sftpfs\_super->socket\_handle = sftpfs\_open\_socket (super, mcerror); if (sftpfs\_super->socket\_handle == LIBSSH2\_INVALID\_SOCKET) return (-1);
 /\* Create a session instance \*/ sftpfs\_super->session = libssh2\_session\_init (); if (sftpfs\_super->session == NULL) return (-1);
 /\* ... start it up. This will trade welcome banners, exchange keys, \* and setup crypto, compression, and MAC layers \*/#if LIBSSH2\_VERSION\_NUM < 0x010208 rc = libssh2\_session\_startup (sftpfs\_super->session, sftpfs\_super->socket\_handle);#else rc = libssh2\_session\_handshake (sftpfs\_super->session, (libssh2\_socket\_t) sftpfs\_super->socket\_handle);#endif if (rc != 0) { mc\_propagate\_error (mcerror, rc, "%s", \_("sftp: Failure establishing SSH session")); return (-1); }
 /\* At this point we havn't yet authenticated. The first thing to do \* is check the hostkey's fingerprint against our known hosts Your app \* may have it hard coded, may go to a file, may present it to the \* user, that's your call \*/ sftpfs\_super->fingerprint = libssh2\_hostkey\_hash (sftpfs\_super->session, LIBSSH2\_HOSTKEY\_HASH\_SHA1);
 if (!sftpfs\_recognize\_auth\_types (super)) { int sftp\_errno;
 sftp\_errno = libssh2\_session\_last\_errno (sftpfs\_super->session); sftpfs\_ssherror\_to\_gliberror (sftpfs\_super, sftp\_errno, mcerror); return (-1); }
 if (!sftpfs\_open\_connection\_ssh\_agent (super, mcerror) && !sftpfs\_open\_connection\_ssh\_key (super, mcerror) && !sftpfs\_open\_connection\_ssh\_password (super, mcerror)) return (-1);
 sftpfs\_super->sftp\_session = libssh2\_sftp\_init (sftpfs\_super->session);
 if (sftpfs\_super->sftp\_session == NULL) return (-1);
 /\* Since we have not set non-blocking, tell libssh2 we are blocking \*/ libssh2\_session\_set\_blocking (sftpfs\_super->session, 1);
 return 0;}
/\* --------------------------------------------------------------------------------------------- \*//\*\* \* Close connection. \* \* @param super connection data \* @param shutdown\_message message for shutdown functions \* @param mcerror pointer to the error handler \*/
voidsftpfs\_close\_connection (struct vfs\_s\_super \*super, const char \*shutdown\_message, GError \*\* mcerror){ sftpfs\_super\_t \*sftpfs\_super = SFTP\_SUPER (super);
 /\* no mc\_return\_\*\_if\_error() here because of abort open\_connection handling too \*/ (void) mcerror;
 if (sftpfs\_super->sftp\_session != NULL) { libssh2\_sftp\_shutdown (sftpfs\_super->sftp\_session); sftpfs\_super->sftp\_session = NULL; }
 if (sftpfs\_super->agent != NULL) { libssh2\_agent\_disconnect (sftpfs\_super->agent); libssh2\_agent\_free (sftpfs\_super->agent); sftpfs\_super->agent = NULL; }
 sftpfs\_super->fingerprint = NULL;
 if (sftpfs\_super->session != NULL) { libssh2\_session\_disconnect (sftpfs\_super->session, shutdown\_message); libssh2\_session\_free (sftpfs\_super->session); sftpfs\_super->session = NULL; }
 if (sftpfs\_super->socket\_handle != LIBSSH2\_INVALID\_SOCKET) { close (sftpfs\_super->socket\_handle); sftpfs\_super->socket\_handle = LIBSSH2\_INVALID\_SOCKET; }}
/\* --------------------------------------------------------------------------------------------- \*/

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_ff8922db_20250114_205502.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FMidnightCommander%2Fmc%2Fblob%2Fmaster%2Fsrc%2Fvfs%2Fsftpfs%2Fconnection.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FMidnightCommander%2Fmc%2Fblob%2Fmaster%2Fsrc%2Fvfs%2Fsftpfs%2Fconnection.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=MidnightCommander%2Fmc)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[MidnightCommander](/MidnightCommander)
/
**[mc](/MidnightCommander/mc)**
Public

* [Notifications](/login?return_to=%2FMidnightCommander%2Fmc) You must be signed in to change notification settings
* [Fork
  524](/login?return_to=%2FMidnightCommander%2Fmc)
* [Star
   2.7k](/login?return_to=%2FMidnightCommander%2Fmc)

* [Code](/MidnightCommander/mc)
* [Pull requests
  18](/MidnightCommander/mc/pulls)
* [Actions](/MidnightCommander/mc/actions)
* [Security](/MidnightCommander/mc/security)
* [Insights](/MidnightCommander/mc/pulse)

Additional navigation options

* [Code](/MidnightCommander/mc)
* [Pull requests](/MidnightCommander/mc/pulls)
* [Actions](/MidnightCommander/mc/actions)
* [Security](/MidnightCommander/mc/security)
* [Insights](/MidnightCommander/mc/pulse)

## Files

 master
## Breadcrumbs

1. [mc](/MidnightCommander/mc/tree/master)
2. /[src](/MidnightCommander/mc/tree/master/src)
3. /[vfs](/MidnightCommander/mc/tree/master/src/vfs)
4. /[sftpfs](/MidnightCommander/mc/tree/master/src/vfs/sftpfs)
/
# connection.c

Copy path Blame  Blame
## Latest commit

## History

[History](/MidnightCommander/mc/commits/master/src/vfs/sftpfs/connection.c)1011 lines (843 loc) · 32.6 KB master
## Breadcrumbs

1. [mc](/MidnightCommander/mc/tree/master)
2. /[src](/MidnightCommander/mc/tree/master/src)
3. /[vfs](/MidnightCommander/mc/tree/master/src/vfs)
4. /[sftpfs](/MidnightCommander/mc/tree/master/src/vfs/sftpfs)
/
# connection.c

Top
## File metadata and controls

* Code
* Blame

1011 lines (843 loc) · 32.6 KB[Raw](https://github.com/MidnightCommander/mc/raw/refs/heads/master/src/vfs/sftpfs/connection.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* Virtual File System: SFTP file system. The internal functions: connections
 Copyright (C) 2011-2025 Free Software Foundation, Inc.
 Written by: Ilia Maslakov <il.smind@gmail.com>, 2011 Slava Zanko <slavazanko@gmail.com>, 2011, 2012, 2013
 This file is part of the Midnight Commander.
 The Midnight Commander is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 The Midnight Commander is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>. \*/
#include <config.h>#include <errno.h>
#include <netdb.h> /\* struct hostent \*/#include <sys/socket.h> /\* AF\_INET \*/#include <netinet/in.h> /\* struct in\_addr \*/#ifdef HAVE\_ARPA\_INET\_H#include <arpa/inet.h>#endif
#include <libssh2.h>#include <libssh2\_sftp.h>
#include "lib/global.h"
#include "lib/util.h"#include "lib/tty/tty.h" /\* tty\_enable\_interrupt\_key () \*/#include "lib/vfs/utilvfs.h"#include "lib/mcconfig.h" /\* mc\_config\_get\_home\_dir () \*/#include "lib/widget.h" /\* query\_dialog () \*/
#include "internal.h"
/\*\*\* global variables \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
/\*\*\* file scope macro definitions \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
#define SHA1\_DIGEST\_LENGTH 20
/\*\*\* file scope type declarations \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
/\*\*\* forward declarations (file scope functions) \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
/\*\*\* file scope variables \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
#ifdef LIBSSH2\_KNOWNHOST\_KEY\_ED25519static const char \*const hostkey\_method\_ssh\_ed25519 = "ssh-ed25519";#endif#ifdef LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_521static const char \*const hostkey\_method\_ssh\_ecdsa\_521 = "ecdsa-sha2-nistp521";#endif#ifdef LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_384static const char \*const hostkey\_method\_ssh\_ecdsa\_384 = "ecdsa-sha2-nistp384";#endif#ifdef LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_256static const char \*const hostkey\_method\_ssh\_ecdsa\_256 = "ecdsa-sha2-nistp256";#endifstatic const char \*const hostkey\_method\_ssh\_rsa = "ssh-rsa";static const char \*const hostkey\_method\_ssh\_dss = "ssh-dss";
/\* \*INDENT-OFF\* \*/static const char \*default\_hostkey\_methods =#ifdef LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_256 "ecdsa-sha2-nistp256,"#endif#ifdef LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_384 "ecdsa-sha2-nistp384,"#endif#ifdef LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_521 "ecdsa-sha2-nistp521,"#endif#ifdef LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_256 "ecdsa-sha2-nistp256-cert-v01@openssh.com,"#endif#ifdef LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_384 "ecdsa-sha2-nistp384-cert-v01@openssh.com,"#endif#ifdef LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_521 "ecdsa-sha2-nistp521-cert-v01@openssh.com,"#endif#ifdef LIBSSH2\_KNOWNHOST\_KEY\_ED25519 "ssh-ed25519," "ssh-ed25519-cert-v01@openssh.com,"#endif "rsa-sha2-256," "rsa-sha2-512," "ssh-rsa," "ssh-rsa-cert-v01@openssh.com," "ssh-dss";/\* \*INDENT-ON\* \*/
/\*\* \* \* The current implementation of know host key checking has following limitations: \* \* - Only plain-text entries are supported (`HashKnownHosts no` OpenSSH option) \* - Only HEX-encoded SHA1 fingerprint display is supported (`FingerprintHash` OpenSSH option) \* - Resolved IP addresses are \*not\* saved/validated along with the hostnames \* \*/
static const char \*kbi\_passwd = NULL;static const struct vfs\_s\_super \*kbi\_super = NULL;
/\* --------------------------------------------------------------------------------------------- \*//\*\*\* file scope functions \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*//\* --------------------------------------------------------------------------------------------- \*//\*\* \* Create socket to host. \* \* @param super connection data \* @param mcerror pointer to the error handler \* @return socket descriptor number, -1 if any error was occurred \*/
static intsftpfs\_open\_socket (struct vfs\_s\_super \*super, GError \*\*mcerror){ sftpfs\_super\_t \*sftpfs\_super = SFTP\_SUPER (super); struct addrinfo hints, \*res = NULL, \*curr\_res; int my\_socket = 0; char port[BUF\_TINY]; static char address\_ipv4[INET\_ADDRSTRLEN]; static char address\_ipv6[INET6\_ADDRSTRLEN]; int e;
 mc\_return\_val\_if\_error (mcerror, LIBSSH2\_INVALID\_SOCKET);
 if (super->path\_element->host == NULL || \*super->path\_element->host == '\0') { mc\_propagate\_error (mcerror, 0, "%s", \_("sftp: Invalid host name.")); return LIBSSH2\_INVALID\_SOCKET; }
 sprintf (port, "%hu", (unsigned short) super->path\_element->port);
 tty\_enable\_interrupt\_key (); /\* clear the interrupt flag \*/
 memset (&hints, 0, sizeof (hints)); hints.ai\_family = AF\_UNSPEC; hints.ai\_socktype = SOCK\_STREAM;
#ifdef AI\_ADDRCONFIG /\* By default, only look up addresses using address types for \* which a local interface is configured (i.e. no IPv6 if no IPv6 \* interfaces, likewise for IPv4 (see RFC 3493 for details). \*/ hints.ai\_flags = AI\_ADDRCONFIG;#endif
 e = getaddrinfo (super->path\_element->host, port, &hints, &res);
#ifdef AI\_ADDRCONFIG if (e == EAI\_BADFLAGS) { /\* Retry with no flags if AI\_ADDRCONFIG was rejected. \*/ hints.ai\_flags = 0; e = getaddrinfo (super->path\_element->host, port, &hints, &res); }#endif
 if (e != 0) { mc\_propagate\_error (mcerror, e, \_("sftp: %s"), gai\_strerror (e)); my\_socket = LIBSSH2\_INVALID\_SOCKET; goto ret; }
 for (curr\_res = res; curr\_res != NULL; curr\_res = curr\_res->ai\_next) { int save\_errno;
 switch (curr\_res->ai\_addr->sa\_family) { case AF\_INET: sftpfs\_super->ip\_address = inet\_ntop (AF\_INET, &((struct sockaddr\_in \*) curr\_res->ai\_addr)->sin\_addr, address\_ipv4, INET\_ADDRSTRLEN); break; case AF\_INET6: sftpfs\_super->ip\_address = inet\_ntop (AF\_INET6, &((struct sockaddr\_in6 \*) curr\_res->ai\_addr)->sin6\_addr, address\_ipv6, INET6\_ADDRSTRLEN); break; default: sftpfs\_super->ip\_address = NULL; }
 if (sftpfs\_super->ip\_address == NULL) { mc\_propagate\_error (mcerror, 0, "%s", \_("sftp: failed to convert remote host IP address into text form")); my\_socket = LIBSSH2\_INVALID\_SOCKET; goto ret; }
 my\_socket = socket (curr\_res->ai\_family, curr\_res->ai\_socktype, curr\_res->ai\_protocol);
 if (my\_socket < 0) { if (curr\_res->ai\_next != NULL) continue;
 vfs\_print\_message (\_("sftp: %s"), unix\_error\_string (errno)); my\_socket = LIBSSH2\_INVALID\_SOCKET; goto ret; }
 vfs\_print\_message (\_("sftp: making connection to %s"), super->path\_element->host);
 if (connect (my\_socket, curr\_res->ai\_addr, curr\_res->ai\_addrlen) >= 0) break;
 save\_errno = errno;
 close (my\_socket);
 if (save\_errno == EINTR && tty\_got\_interrupt ()) mc\_propagate\_error (mcerror, 0, "%s", \_("sftp: connection interrupted by user")); else if (res->ai\_next == NULL) mc\_propagate\_error (mcerror, save\_errno, \_("sftp: connection to server failed: %s"), unix\_error\_string (save\_errno)); else continue;
 my\_socket = LIBSSH2\_INVALID\_SOCKET; break; }
 ret: if (res != NULL) freeaddrinfo (res); tty\_disable\_interrupt\_key (); return my\_socket;}
/\* --------------------------------------------------------------------------------------------- \*/
/\*\* \* Read ~/.ssh/known\_hosts file. \* \* @param super connection data \* @param mcerror pointer to the error handler \* @return TRUE on success, FALSE otherwise \* \* Thanks the Curl project for the code used in this function. \*/static gbooleansftpfs\_read\_known\_hosts (struct vfs\_s\_super \*super, GError \*\*mcerror){ sftpfs\_super\_t \*sftpfs\_super = SFTP\_SUPER (super); struct libssh2\_knownhost \*store = NULL; int rc; gboolean found = FALSE;
 sftpfs\_super->known\_hosts = libssh2\_knownhost\_init (sftpfs\_super->session); if (sftpfs\_super->known\_hosts == NULL) goto err;
 sftpfs\_super->known\_hosts\_file = mc\_build\_filename (mc\_config\_get\_home\_dir (), ".ssh", "known\_hosts", (char \*) NULL); rc = libssh2\_knownhost\_readfile (sftpfs\_super->known\_hosts, sftpfs\_super->known\_hosts\_file, LIBSSH2\_KNOWNHOST\_FILE\_OPENSSH); if (rc > 0) { const char \*kh\_name\_end = NULL;
 while (!found && libssh2\_knownhost\_get (sftpfs\_super->known\_hosts, &store, store) == 0) { /\* For non-standard ports, the name will be enclosed in \* square brackets, followed by a colon and the port \*/ if (store == NULL) continue;
 if (store->name == NULL) /\* Ignore hashed hostnames. Currently, libssh2 offers no way for us to match it \*/ continue;
 if (store->name[0] != '[') found = strcmp (store->name, super->path\_element->host) == 0; else { int port;
 kh\_name\_end = strstr (store->name, "]:"); if (kh\_name\_end == NULL) /\* Invalid host pattern \*/ continue;
 port = (int) g\_ascii\_strtoll (kh\_name\_end + 2, NULL, 10); if (port == super->path\_element->port) { size\_t kh\_name\_size;
 kh\_name\_size = strlen (store->name) - 1 - strlen (kh\_name\_end); found = strncmp (store->name + 1, super->path\_element->host, kh\_name\_size) == 0; } } } }
 if (found) { int mask; const char \*hostkey\_method = NULL; char \*hostkey\_methods;
 mask = store->typemask & LIBSSH2\_KNOWNHOST\_KEY\_MASK;
 switch (mask) {#ifdef LIBSSH2\_KNOWNHOST\_KEY\_ED25519 case LIBSSH2\_KNOWNHOST\_KEY\_ED25519: hostkey\_method = hostkey\_method\_ssh\_ed25519; break;#endif#ifdef LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_521 case LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_521: hostkey\_method = hostkey\_method\_ssh\_ecdsa\_521; break;#endif#ifdef LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_384 case LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_384: hostkey\_method = hostkey\_method\_ssh\_ecdsa\_384; break;#endif#ifdef LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_256 case LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_256: hostkey\_method = hostkey\_method\_ssh\_ecdsa\_256; break;#endif case LIBSSH2\_KNOWNHOST\_KEY\_SSHRSA: hostkey\_method = hostkey\_method\_ssh\_rsa; break; case LIBSSH2\_KNOWNHOST\_KEY\_SSHDSS: hostkey\_method = hostkey\_method\_ssh\_dss; break; case LIBSSH2\_KNOWNHOST\_KEY\_RSA1: mc\_propagate\_error (mcerror, 0, "%s", \_("sftp: found host key of unsupported type: RSA1")); return FALSE; default: mc\_propagate\_error (mcerror, 0, "%s 0x%x", \_("sftp: unknown host key type:"), (unsigned int) mask); return FALSE; }
 /\* Append the default hostkey methods (with lower priority). \* Since we ignored hashed hostnames, the actual matching host \* key might have different type than the one found in \* known\_hosts for non-hashed hostname. Methods not supported \* by libssh2 it are ignored. \*/ hostkey\_methods = g\_strdup\_printf ("%s,%s", hostkey\_method, default\_hostkey\_methods); rc = libssh2\_session\_method\_pref (sftpfs\_super->session, LIBSSH2\_METHOD\_HOSTKEY, hostkey\_methods); g\_free (hostkey\_methods); if (rc < 0) goto err; }
 return TRUE;
 err: { int sftp\_errno;
 sftp\_errno = libssh2\_session\_last\_errno (sftpfs\_super->session); sftpfs\_ssherror\_to\_gliberror (sftpfs\_super, sftp\_errno, mcerror); } return FALSE;}
/\* --------------------------------------------------------------------------------------------- \*/
/\*\* \* Write new host + key pair to the ~/.ssh/known\_hosts file. \* \* @param super connection data \* @param remote\_key he key for the remote host \* @param remote\_key\_len length of @remote\_key \* @param type\_mask info about format of host name, key and key type \* @return 0 on success, regular libssh2 error code otherwise \* \* Thanks the Curl project for the code used in this function. \*/static intsftpfs\_update\_known\_hosts (struct vfs\_s\_super \*super, const char \*remote\_key, size\_t remote\_key\_len, int type\_mask){ sftpfs\_super\_t \*sftpfs\_super = SFTP\_SUPER (super); int rc;
 /\* add this host + key pair \*/ rc = libssh2\_knownhost\_addc (sftpfs\_super->known\_hosts, super->path\_element->host, NULL, remote\_key, remote\_key\_len, NULL, 0, type\_mask, NULL); if (rc < 0) return rc;
 /\* write the entire in-memory list of known hosts to the known\_hosts file \*/ rc = libssh2\_knownhost\_writefile (sftpfs\_super->known\_hosts, sftpfs\_super->known\_hosts\_file, LIBSSH2\_KNOWNHOST\_FILE\_OPENSSH);
 if (rc < 0) return rc;
 (void) message (D\_NORMAL, \_("Information"), \_("Permanently added\n%s (%s)\nto the list of known hosts."), super->path\_element->host, sftpfs\_super->ip\_address);
 return 0;}
/\* --------------------------------------------------------------------------------------------- \*//\*\* \* Compute and return readable host key fingerprint hash. \* \* @param session libssh2 session handle \* @return pointer to static buffer on success, NULL otherwise \*/static const char \*sftpfs\_compute\_fingerprint\_hash (LIBSSH2\_SESSION \*session){ static char result[SHA1\_DIGEST\_LENGTH \* 3 + 1]; /\* "XX:" for each byte, and EOL \*/ const char \*fingerprint; size\_t i;
 /\* The fingerprint points to static storage (!), don't free() it. \*/ fingerprint = libssh2\_hostkey\_hash (session, LIBSSH2\_HOSTKEY\_HASH\_SHA1); if (fingerprint == NULL) return NULL;
 for (i = 0; i < SHA1\_DIGEST\_LENGTH && i \* 3 < sizeof (result) - 1; i++) g\_snprintf ((gchar \*) (result + i \* 3), 4, "%02x:", (guint8) fingerprint[i]);
 /\* remove last ":" \*/ result[i \* 3 - 1] = '\0';
 return result;}
/\* --------------------------------------------------------------------------------------------- \*/
/\*\* \* Process host info found in ~/.ssh/known\_hosts file. \* \* @param super connection data \* @param mcerror pointer to the error handler \* @return TRUE on success, FALSE otherwise \* \* Thanks the Curl project for the code used in this function. \*/static gbooleansftpfs\_process\_known\_host (struct vfs\_s\_super \*super, GError \*\*mcerror){ sftpfs\_super\_t \*sftpfs\_super = SFTP\_SUPER (super); const char \*remote\_key; const char \*key\_type; const char \*fingerprint\_hash; size\_t remote\_key\_len = 0; int remote\_key\_type = LIBSSH2\_HOSTKEY\_TYPE\_UNKNOWN; int keybit = 0; struct libssh2\_knownhost \*host = NULL; int rc; char \*msg = NULL; gboolean handle\_query = FALSE;
 remote\_key = libssh2\_session\_hostkey (sftpfs\_super->session, &remote\_key\_len, &remote\_key\_type); if (remote\_key == NULL || remote\_key\_len == 0 || remote\_key\_type == LIBSSH2\_HOSTKEY\_TYPE\_UNKNOWN) { mc\_propagate\_error (mcerror, 0, "%s", \_("sftp: cannot get the remote host key")); return FALSE; }
 switch (remote\_key\_type) { case LIBSSH2\_HOSTKEY\_TYPE\_RSA: keybit = LIBSSH2\_KNOWNHOST\_KEY\_SSHRSA; key\_type = "RSA"; break; case LIBSSH2\_HOSTKEY\_TYPE\_DSS: keybit = LIBSSH2\_KNOWNHOST\_KEY\_SSHDSS; key\_type = "DSS"; break;#ifdef LIBSSH2\_HOSTKEY\_TYPE\_ECDSA\_256 case LIBSSH2\_HOSTKEY\_TYPE\_ECDSA\_256: keybit = LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_256; key\_type = "ECDSA"; break;#endif#ifdef LIBSSH2\_HOSTKEY\_TYPE\_ECDSA\_384 case LIBSSH2\_HOSTKEY\_TYPE\_ECDSA\_384: keybit = LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_384; key\_type = "ECDSA"; break;#endif#ifdef LIBSSH2\_HOSTKEY\_TYPE\_ECDSA\_521 case LIBSSH2\_HOSTKEY\_TYPE\_ECDSA\_521: keybit = LIBSSH2\_KNOWNHOST\_KEY\_ECDSA\_521; key\_type = "ECDSA"; break;#endif#ifdef LIBSSH2\_HOSTKEY\_TYPE\_ED25519 case LIBSSH2\_HOSTKEY\_TYPE\_ED25519: keybit = LIBSSH2\_KNOWNHOST\_KEY\_ED25519; key\_type = "ED25519"; break;#endif default: mc\_propagate\_error (mcerror, 0, "%s", \_("sftp: unsupported key type, can't check remote host key")); return FALSE; }
 fingerprint\_hash = sftpfs\_compute\_fingerprint\_hash (sftpfs\_super->session); if (fingerprint\_hash == NULL) { mc\_propagate\_error (mcerror, 0, "%s", \_("sftp: can't compute host key fingerprint hash")); return FALSE; }
 rc = libssh2\_knownhost\_checkp (sftpfs\_super->known\_hosts, super->path\_element->host, super->path\_element->port, remote\_key, remote\_key\_len, LIBSSH2\_KNOWNHOST\_TYPE\_PLAIN | LIBSSH2\_KNOWNHOST\_KEYENC\_RAW | keybit, &host);
 switch (rc) { default: case LIBSSH2\_KNOWNHOST\_CHECK\_FAILURE: /\* something prevented the check to be made \*/ goto err;
 case LIBSSH2\_KNOWNHOST\_CHECK\_MATCH: /\* host + key pair matched -- OK \*/ break;
 case LIBSSH2\_KNOWNHOST\_CHECK\_NOTFOUND: /\* no host match was found -- add it to the known\_hosts file \*/ msg = g\_strdup\_printf (\_("The authenticity of host\n%s (%s)\ncan't be established!\n" "%s key fingerprint hash is\nSHA1:%s.\n" "Do you want to add it to the list of known hosts and continue connecting?"), super->path\_element->host, sftpfs\_super->ip\_address, key\_type, fingerprint\_hash); /\* Select "No" initially \*/ query\_set\_sel (2); rc = query\_dialog (\_("Warning"), msg, D\_NORMAL, 3, \_("&Yes"), \_("&Ignore"), \_("&No")); g\_free (msg); handle\_query = TRUE; break;
 case LIBSSH2\_KNOWNHOST\_CHECK\_MISMATCH: msg = g\_strdup\_printf (\_("%s (%s)\nis found in the list of known hosts but\n" "KEYS DO NOT MATCH! THIS COULD BE A MITM ATTACK!\n" "Are you sure you want to add it to the list of known hosts and continue connecting?"), super->path\_element->host, sftpfs\_super->ip\_address); /\* Select "No" initially \*/ query\_set\_sel (2); rc = query\_dialog (MSG\_ERROR, msg, D\_ERROR, 3, \_("&Yes"), \_("&Ignore"), \_("&No")); g\_free (msg); handle\_query = TRUE; break; }
 if (handle\_query) switch (rc) { case 0: /\* Yes: add this host + key pair, continue connecting \*/ if (sftpfs\_update\_known\_hosts (super, remote\_key, remote\_key\_len, LIBSSH2\_KNOWNHOST\_TYPE\_PLAIN | LIBSSH2\_KNOWNHOST\_KEYENC\_RAW | keybit) < 0) goto err; break; case 1: /\* Ignore: do not add this host + key pair, continue connecting anyway \*/ break; case 2: default: mc\_propagate\_error (mcerror, 0, "%s", \_("sftp: host key verification failed")); /\* No: abort connection \*/ goto err; }
 return TRUE;
 err: { int sftp\_errno;
 sftp\_errno = libssh2\_session\_last\_errno (sftpfs\_super->session); sftpfs\_ssherror\_to\_gliberror (sftpfs\_super, sftp\_errno, mcerror); }
 return FALSE;}
/\* --------------------------------------------------------------------------------------------- \*//\*\* \* Recognize authentication types supported by remote side and filling internal 'super' structure by \* proper enum's values. \* \* @param super connection data \* @return TRUE if some of authentication methods is available, FALSE otherwise \*/static gbooleansftpfs\_recognize\_auth\_types (struct vfs\_s\_super \*super){ char \*userauthlist; sftpfs\_super\_t \*sftpfs\_super = SFTP\_SUPER (super);
 /\* check what authentication methods are available \*/ /\* userauthlist is internally managed by libssh2 and freed by libssh2\_session\_free() \*/ userauthlist = libssh2\_userauth\_list (sftpfs\_super->session, super->path\_element->user, strlen (super->path\_element->user));
 if (userauthlist == NULL) return FALSE;
 if ((strstr (userauthlist, "password") != NULL || strstr (userauthlist, "keyboard-interactive") != NULL) && (sftpfs\_super->config\_auth\_type & PASSWORD) != 0) sftpfs\_super->auth\_type |= PASSWORD;
 if (strstr (userauthlist, "publickey") != NULL && (sftpfs\_super->config\_auth\_type & PUBKEY) != 0) sftpfs\_super->auth\_type |= PUBKEY;
 if ((sftpfs\_super->config\_auth\_type & AGENT) != 0) sftpfs\_super->auth\_type |= AGENT;
 return TRUE;}
/\* --------------------------------------------------------------------------------------------- \*//\*\* \* Open connection to host using SSH-agent helper. \* \* @param super connection data \* @param mcerror pointer to the error handler \* @return TRUE if connection was successfully opened, FALSE otherwise \*/
static gbooleansftpfs\_open\_connection\_ssh\_agent (struct vfs\_s\_super \*super, GError \*\*mcerror){ sftpfs\_super\_t \*sftpfs\_super = SFTP\_SUPER (super); struct libssh2\_agent\_publickey \*identity, \*prev\_identity = NULL; int rc;
 mc\_return\_val\_if\_error (mcerror, FALSE);
 sftpfs\_super->agent = NULL;
 if ((sftpfs\_super->auth\_type & AGENT) == 0) return FALSE;
 /\* Connect to the ssh-agent \*/ sftpfs\_super->agent = libssh2\_agent\_init (sftpfs\_super->session); if (sftpfs\_super->agent == NULL) return FALSE;
 if (libssh2\_agent\_connect (sftpfs\_super->agent) != 0) return FALSE;
 if (libssh2\_agent\_list\_identities (sftpfs\_super->agent) != 0) return FALSE;
 while (TRUE) { rc = libssh2\_agent\_get\_identity (sftpfs\_super->agent, &identity, prev\_identity); if (rc == 1) break;
 if (rc < 0) return FALSE;
 if (libssh2\_agent\_userauth (sftpfs\_super->agent, super->path\_element->user, identity) == 0) break;
 prev\_identity = identity; }
 return (rc == 0);}
/\* --------------------------------------------------------------------------------------------- \*//\*\* \* Open connection to host using SSH-keypair. \* \* @param super connection data \* @param mcerror pointer to the error handler \* @return TRUE if connection was successfully opened, FALSE otherwise \*/
static gbooleansftpfs\_open\_connection\_ssh\_key (struct vfs\_s\_super \*super, GError \*\*mcerror){ sftpfs\_super\_t \*sftpfs\_super = SFTP\_SUPER (super); char \*p, \*passwd; gboolean ret\_value = FALSE;
 mc\_return\_val\_if\_error (mcerror, FALSE);
 if ((sftpfs\_super->auth\_type & PUBKEY) == 0) return FALSE;
 if (sftpfs\_super->privkey == NULL) return FALSE;
 if (libssh2\_userauth\_publickey\_fromfile (sftpfs\_super->session, super->path\_element->user, sftpfs\_super->pubkey, sftpfs\_super->privkey, super->path\_element->password) == 0) return TRUE;
 p = g\_strdup\_printf (\_("sftp: Enter passphrase for %s "), super->path\_element->user); passwd = vfs\_get\_password (p); g\_free (p);
 if (passwd == NULL) mc\_propagate\_error (mcerror, 0, "%s", \_("sftp: Passphrase is empty.")); else { ret\_value = (libssh2\_userauth\_publickey\_fromfile (sftpfs\_super->session, super->path\_element->user, sftpfs\_super->pubkey, sftpfs\_super->privkey, passwd) == 0); g\_free (passwd); }
 return ret\_value;}
/\* --------------------------------------------------------------------------------------------- \*/
/\*\* \* Keyboard-interactive password helper for opening connection to host by \* sftpfs\_open\_connection\_ssh\_password \* \* Uses global kbi\_super (data with existing connection) and kbi\_passwd (password) \* \* @param name username \* @param name\_len length of @name \* @param instruction unused \* @param instruction\_len unused \* @param num\_prompts number of possible problems to process \* @param prompts array of prompts to process \* @param responses array of responses, one per prompt \* @param abstract unused \*/
staticLIBSSH2\_USERAUTH\_KBDINT\_RESPONSE\_FUNC (sftpfs\_keyboard\_interactive\_helper){ int i; size\_t len;
 (void) instruction; (void) instruction\_len; (void) abstract;
 if (kbi\_super == NULL || kbi\_passwd == NULL) return;
 if (strncmp (name, kbi\_super->path\_element->user, name\_len) != 0) return;
 /\* assume these are password prompts \*/ len = strlen (kbi\_passwd);
 for (i = 0; i < num\_prompts; ++i) if (memcmp (prompts[i].text, "Password: ", prompts[i].length) == 0) { responses[i].text = strdup (kbi\_passwd); responses[i].length = len; }}
/\* --------------------------------------------------------------------------------------------- \*//\*\* \* Open connection to host using password. \* \* @param super connection data \* @param mcerror pointer to the error handler \* @return TRUE if connection was successfully opened, FALSE otherwise \*/
static gbooleansftpfs\_open\_connection\_ssh\_password (struct vfs\_s\_super \*super, GError \*\*mcerror){ sftpfs\_super\_t \*sftpfs\_super = SFTP\_SUPER (super); char \*p, \*passwd; gboolean ret\_value = FALSE; int rc;
 mc\_return\_val\_if\_error (mcerror, FALSE);
 if ((sftpfs\_super->auth\_type & PASSWORD) == 0) return FALSE;
 if (super->path\_element->password != NULL) { while ((rc = libssh2\_userauth\_password (sftpfs\_super->session, super->path\_element->user, super->path\_element->password)) == LIBSSH2\_ERROR\_EAGAIN); if (rc == 0) return TRUE;
 kbi\_super = super; kbi\_passwd = super->path\_element->password;
 while ((rc = libssh2\_userauth\_keyboard\_interactive (sftpfs\_super->session, super->path\_element->user, sftpfs\_keyboard\_interactive\_helper)) == LIBSSH2\_ERROR\_EAGAIN) ;
 kbi\_super = NULL; kbi\_passwd = NULL;
 if (rc == 0) return TRUE; }
 p = g\_strdup\_printf (\_("sftp: Enter password for %s "), super->path\_element->user); passwd = vfs\_get\_password (p); g\_free (p);
 if (passwd == NULL) mc\_propagate\_error (mcerror, 0, "%s", \_("sftp: Password is empty.")); else { while ((rc = libssh2\_userauth\_password (sftpfs\_super->session, super->path\_element->user, passwd)) == LIBSSH2\_ERROR\_EAGAIN) ;
 if (rc != 0) { kbi\_super = super; kbi\_passwd = passwd;
 while ((rc = libssh2\_userauth\_keyboard\_interactive (sftpfs\_super->session, super->path\_element->user, sftpfs\_keyboard\_interactive\_helper)) == LIBSSH2\_ERROR\_EAGAIN) ;
 kbi\_super = NULL; kbi\_passwd = NULL; }
 if (rc == 0) { ret\_value = TRUE; g\_free (super->path\_element->password); super->path\_element->password = passwd; } else g\_free (passwd); }
 return ret\_value;}
/\* --------------------------------------------------------------------------------------------- \*//\*\*\* public functions \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*//\* --------------------------------------------------------------------------------------------- \*//\*\* \* Open new connection. \* \* @param super connection data \* @param mcerror pointer to the error handler \* @return 0 if success, -1 otherwise \*/
intsftpfs\_open\_connection (struct vfs\_s\_super \*super, GError \*\*mcerror){ int rc; sftpfs\_super\_t \*sftpfs\_super = SFTP\_SUPER (super);
 mc\_return\_val\_if\_error (mcerror, -1);
 /\* \* The application code is responsible for creating the socket \* and establishing the connection \*/ sftpfs\_super->socket\_handle = sftpfs\_open\_socket (super, mcerror); if (sftpfs\_super->socket\_handle == LIBSSH2\_INVALID\_SOCKET) return (-1);
 /\* Create a session instance \*/ sftpfs\_super->session = libssh2\_session\_init (); if (sftpfs\_super->session == NULL) return (-1);
 if (!sftpfs\_read\_known\_hosts (super, mcerror)) return (-1);
 /\* ... start it up. This will trade welcome banners, exchange keys, \* and setup crypto, compression, and MAC layers \*/ while ((rc = libssh2\_session\_handshake (sftpfs\_super->session, (libssh2\_socket\_t) sftpfs\_super->socket\_handle)) == LIBSSH2\_ERROR\_EAGAIN) ; if (rc != 0) { mc\_propagate\_error (mcerror, rc, "%s", \_("sftp: failure establishing SSH session")); return (-1); }
 if (!sftpfs\_process\_known\_host (super, mcerror)) return (-1);
 if (!sftpfs\_recognize\_auth\_types (super)) { int sftp\_errno;
 sftp\_errno = libssh2\_session\_last\_errno (sftpfs\_super->session); sftpfs\_ssherror\_to\_gliberror (sftpfs\_super, sftp\_errno, mcerror); return (-1); }
 if (!sftpfs\_open\_connection\_ssh\_agent (super, mcerror) && !sftpfs\_open\_connection\_ssh\_key (super, mcerror) && !sftpfs\_open\_connection\_ssh\_password (super, mcerror)) return (-1);
 sftpfs\_super->sftp\_session = libssh2\_sftp\_init (sftpfs\_super->session);
 if (sftpfs\_super->sftp\_session == NULL) return (-1);
 /\* Since we have not set non-blocking, tell libssh2 we are blocking \*/ libssh2\_session\_set\_blocking (sftpfs\_super->session, 1);
 return 0;}
/\* --------------------------------------------------------------------------------------------- \*//\*\* \* Close connection. \* \* @param super connection data \* @param shutdown\_message message for shutdown functions \* @param mcerror pointer to the error handler \*/
voidsftpfs\_close\_connection (struct vfs\_s\_super \*super, const char \*shutdown\_message, GError \*\*mcerror){ sftpfs\_super\_t \*sftpfs\_super = SFTP\_SUPER (super);
 /\* no mc\_return\_\*\_if\_error() here because of abort open\_connection handling too \*/ (void) mcerror;
 if (sftpfs\_super->sftp\_session != NULL) { libssh2\_sftp\_shutdown (sftpfs\_super->sftp\_session); sftpfs\_super->sftp\_session = NULL; }
 if (sftpfs\_super->agent != NULL) { libssh2\_agent\_disconnect (sftpfs\_super->agent); libssh2\_agent\_free (sftpfs\_super->agent); sftpfs\_super->agent = NULL; }
 if (sftpfs\_super->known\_hosts != NULL) { libssh2\_knownhost\_free (sftpfs\_super->known\_hosts); sftpfs\_super->known\_hosts = NULL; }
 MC\_PTR\_FREE (sftpfs\_super->known\_hosts\_file);
 if (sftpfs\_super->session != NULL) { libssh2\_session\_disconnect (sftpfs\_super->session, shutdown\_message); libssh2\_session\_free (sftpfs\_super->session);[View remainder of file in raw view](https://github.com/MidnightCommander/mc/raw/refs/heads/master/src/vfs/sftpfs/connection.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from mail.gnome.org_5472818e_20250114_205503.html ===


[GNOME.org](https://www.gnome.org/)

[![GNOME: Mail Services](https://static.gnome.org/css/gnome-mail.png)](https://mail.gnome.org/ "Go to home page")

* [Home](https://mail.gnome.org/)
* [Mailing Lists](https://mail.gnome.org/mailman/listinfo/)
* [List Archives](https://mail.gnome.org/archives/)

Search

# Midnight Commander 4.8.27 released

---

* *From*: "Yury V. Zaytsev" <yury shurup com>
* *To*: mc gnome org, mc-devel gnome org
* *Cc*: Manfred KAISER <manfred kaiser bmlv gv at>, Thomas STEINBAUER <thomas steinbauer bmlv gv at>
* *Subject*: Midnight Commander 4.8.27 released
* *Date*: Sun, 15 Aug 2021 16:36:26 +0200 (CEST)

---

```

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi there,

```
I'm glad to announce the immediate availability of mc-4.8.27, a
maintenance and security release, just in time before leaving all of you
for a long overdue summer vacation!
```

```
This release addresses an important security issue (CVE-2021-36370) in the
SFTP VFS. Unfortunately, as the VFS was first introduced, the fingerprints
of remote hosts were computed, but not verified, and the issue reported
only now by Manfred KAISER from AUT-milCERT during an audit of open source
software. We would like to thank the team at AUT-milCERT for finding the
issue and responsibly disclosing it!
```

```
Other than that there is a large slew of assorted bugfixes to various
subsystems. For the detailed list of changes since the last release,
please refer to the release notes. Everybody is recommended to upgrade to
immediately benefit from these improvements!
```

Download page: <http://ftp.midnight-commander.org/?C=N;O=D>
Release notes: <http://www.midnight-commander.org/wiki/NEWS-4.8.27>

```
Unfortunately, the autotools support for Apple M1 has not propagated
widely enough, so if you need to build mc on such a system, you will have
to specify the triplets manually - hopefully this will be no longer
necessary by the time of the next release:
```

  CFLAGS="-target arm64-apple-macos11" \
  ./configure \
    --host=aarch64-apple-darwin \
    --target=aarch64-apple-darwin \
    --build=aarch64-apple-darwin

```
As usual, thanks to Andrew Borodin, who was the main driving force behind this
release, as well as all of our contributors, including translators.
```

Have fun!

```
- --
Sincerely yours,
```

Yury V. Zaytsev

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (GNU/Linux)

iQIcBAEBAgAGBQJhGSZwAAoJEPci7nm8u+Dv7tUP/3UZEBUrTcCoY5I6p+9jTZni
2EXvl3qWuKK+2F0WOpztNAct0b6kyMOqtfH2VsRB6Set/8vhY9bx6b48cnZhkUR0
WTlmGq/eK1KTYfac7oYwp7RfknJ4jS99MdJXKUu9tukTD/QP+iBURhC+xTnh/yrJ
fzWn6UEsvHvDoHDFyZi0C8UYIbCd+XNyaxQNtJANf8SAwAtzTEcvhs63DX6DAJm2
uARL1EiKT2D0HCELSRhEAH+XwYEkd+4N8nWBaB1mo3TditY7bbFW/c+TV+Z78Cxq
p2RsoAhEDSPAyPBYpzXvYwQ2OgX56ug+wKMqjlYWtTYSC+Z6jqtZhYb2Mg9beY8e
B6gE5w9h//UA7zPqt01+LN4ErdHUyUejpk6eBYX7z/RABaURGZ41GaCEnxhcULnZ
lwOzU19puEFRIG5L1gXAr5KiTTh5/ALdn7OyxrXIVd4HRosFXSbZVwCAcWPdL2uj
17Na5volVN1VSD225/RJ8BnP0PWNxPlnpfSUEHJnaz0FWrwgE3oHHvMmkPQ6JbOP
ap0uZZyebtaUBHLL3gvriu/SKTWvT/VMGgbDi660mN5pKYgtbYDzqjy4SR38hQmX
27xD6pKFIFM7kQReeqc6sXq+SckuMYs2rpmDYVlj/eIacqAWPArTgDuWZ/sqbS+e
/6JHh/vU7I1JxZXmfl5o
=qJEm
-----END PGP SIGNATURE-----

```

---

* **Follow-Ups**:
  + **[Re: Midnight Commander 4.8.27 released](msg00012.html)**
    - *From:* wwp

---

[[Date Prev](msg00007.html)][[Date Next](msg00009.html)]   [[Thread Prev](msg00006.html)][[Thread Next](msg00012.html)]
[[Thread Index](thread.html#00008)]
[[Date Index](date.html#00008)]
[[Author Index](author.html#00008)]

* [The GNOME Project](http://www.gnome.org)
  + [About Us](https://www.gnome.org/about/)
  + [Get Involved](https://www.gnome.org/get-involved/)
  + [Teams](https://www.gnome.org/teams/)
  + [Support GNOME](https://www.gnome.org/support-gnome/)
  + [Contact Us](https://www.gnome.org/contact/)
  + [The GNOME Foundation](https://www.gnome.org/foundation/)
* Resources
  + [Developer Center](https://developer.gnome.org)
  + [Documentation](https://help.gnome.org)
  + [Wiki](https://wiki.gnome.org)
  + [Mailing Lists](https://mail.gnome.org/mailman/listinfo)
  + [IRC Channels](https://wiki.gnome.org/GnomeIrcChannels)
  + [Bug Tracker](https://bugzilla.gnome.org/)
  + [Development Code](https://git.gnome.org/browse/)
  + [Build Tool](https://wiki.gnome.org/Jhbuild)
* [News](https://www.gnome.org/news)
  + [Press Releases](https://www.gnome.org/press/)
  + [Latest Release](https://www.gnome.org/start/stable)
  + [Planet GNOME](https://planet.gnome.org)
  + [Development News](https://news.gnome.org)
  + [Identi.ca](https://identi.ca/gnome)
  + [Twitter](https://twitter.com/gnome)

Copyright © 2005 -  [**The GNOME Project**](https://www.gnome.org/).

[Optimised](http://validator.w3.org/check/referer) for [standards](http://www.w3.org/). Hosted by [Red Hat](http://www.redhat.com/).
Powered by [MailMan](http://www.list.org/), [Python](http://www.python.org/) and [GNU](http://www.gnu.org/).



=== Content from midnight-commander.org_75c94d4d_20250114_205505.html ===

[![Midnight Commander](/chrome/site/MidnightCommander.png)](https://www.midnight-commander.org)

Search:

* [Login](/login)
* [Preferences](/prefs)
* [Help/Guide](/wiki/TracGuide)
* [About Trac](/about)
* [Register](/register)

* [Home](/wiki)
* [Timeline](/timeline)
* [Roadmap](/roadmap)
* [Browse Source](/browser)
* [View Tickets](/report)
* [Search](/search)
* [Downloads](http://ftp.midnight-commander.org/?C=N;O=D)

[wiki:](/wiki "View WikiStart")[WikiStart](/wiki/WikiStart "View WikiStart")

## Context Navigation

* [Start Page](/wiki/WikiStart)
* [Index](/wiki/TitleIndex)
* [History](/wiki/WikiStart?action=history)

---

[Last modified](/wiki/WikiStart?action=diff&version=187 "Version 187 by zaytsev") [2 months](/timeline?from=2024-11-01T16%3A56%3A51Z&precision=second "2024-11-01T16:56:51Z in Timeline") ago
Last modified on 11/01/24 16:56:51

**Translations**

[Русский](/wiki/ru/WikiStart)

Deutsch?

Hungarian?

# Welcome to the Midnight Commander Development Center

## Latest release

Current version is: 4.8.32; [what's new](/wiki/NEWS-4.8.32).

## Current work

[![https://github.com/MidnightCommander/mc/actions/workflows/ci.yml/badge.svg](https://github.com/MidnightCommander/mc/actions/workflows/ci.yml/badge.svg "https://github.com/MidnightCommander/mc/actions/workflows/ci.yml/badge.svg")](https://github.com/MidnightCommander/mc)

Coming soon: 4.8.33; [what's new](/wiki/NEWS-4.8.33).

[Our release guidelines](/wiki/ReleaseGuidelines).

## Introduction

GNU Midnight Commander is a visual file manager, licensed under GNU General Public License and therefore qualifies as Free Software. It's a feature rich full-screen text mode application that allows you to copy, move and delete files and whole directory trees, search for files and run commands in the subshell. Internal viewer and editor are included.

Midnight Commander is based on versatile text interfaces, such as Ncurses or S-Lang, which allows it to work on a regular console, inside an X Window terminal, over SSH connections and all kinds of remote shells.

This site hosts the new home of the Midnight Commander. The main project repository has been moved from Savannah to a new Git repository hosted on GitHub.

[Development team (active developers only)](/wiki/McDevelopers); [contributors](/wiki/McContributors).

## Download

### Source code

A list of the latest releases is available [​here](https://www.midnight-commander.org/downloads). If you are interested in helping with the development please also have a look at our Git repository. In order to check out the repository tree use the following commands:

* **git clone git://github.com/MidnightCommander/mc.git**
* **git clone https://github.com/MidnightCommander/mc.git** (for those who are behind a firewall)

You can find instructions for compiling mc from Git sources in the doc/HACKING file.

We also have an autosyncing Git mirror at [​repo.or.cz](https://repo.or.cz/w/midnight-commander.git/). It uses gitweb as the web-interface to Git and can therefore provide some information normally unavailable via Trac Git browser plug-in:

* **git clone git://repo.or.cz/midnight-commander.git**
* **git clone https://repo.or.cz/r/midnight-commander.git** (for those who are behind a firewall)

Download statistics are here: [​https://awstats.osuosl.org/list/ftp.midnight-commander.org](https://awstats.osuosl.org/list/ftp.midnight-commander.org)

### Binary builds

See [Binaries](/wiki/Binaries) page for details.

## Issue tracking

If you have any issues, suggestions or patches, you can file a [new ticket](/wiki/NewTicket) (you should be [registered](/register) on this site). **Please take the time to [search for an already existing ticket](/search).**

## Documentation

At the moment, unfortunately, Midnight Commander lacks a comprehensive set of documentation covering its common features and various best practices. A project is under way to create such a documentation. Currently we are gathering various bits of information which would be later converted to a more suitable format (DocBook, ...?) in the wiki. Any help would be gladly appreciated.

Please check out [the drafts of the documentation project](/wiki/doc).

## Developers mailing lists

**Note**: mailing lists on GoogleGroups are set up to read Trac messages only and not an appropriate place to discuss MC bugs and solutions. Please use mailing lists for any MC-related discussions.

### mc-devel (at) lists.midnight-commander (dot) org

Mailing list for the development-related discussions:

* Click here to [​subscribe](https://lists.midnight-commander.org/mailman/listinfo/mc-devel);
* Click here to
  + [​read the archives](https://lists.midnight-commander.org/pipermail/mc-devel/).
  + [​read the old archives at GNOME](https://mail.gnome.org/archives/mc-devel/).

### mc-commits (at) googlegroups (dot) com

Mailing list reserved for the applied commits into master branch only (suitable for use as RSS):

* Click here to [​subscribe](https://groups.google.com/group/mc-commits/subscribe);
* Click here to [​read the archives](https://groups.google.com/group/mc-commits).

### mc-bugs (at) googlegroups (dot) com

Mailing list reserved for the ticket and comment notifications only (suitable for use as RSS):

* Click here to [​subscribe](https://groups.google.com/group/mc-bugs/subscribe);
* Click here to [​read the archives](https://groups.google.com/group/mc-bugs).

## Mailing list for the users

### mc (at) lists.midnight-commander (dot) org

* Click here to [​subscribe](https://lists.midnight-commander.org/mailman/listinfo/mc);
* Click here to
  + [​read the archives](https://lists.midnight-commander.org/pipermail/mc/).
  + [​read the old archives at GNOME](https://mail.gnome.org/archives/mc/).

## Other resources

### mc-dev (at) conference.jabber.org

This is our English-speaking jabber room.

## Contribute

You are interested in mc and would like to improve it? Cool! Feel free to report bugs (please, use search before), attach your patches to the tickets and review the patches that are already in there. If you are going to do this on a regular basis, we'll ask you if you'd like to join us. However, please search before reporting your issues to reduce the amount of work needed to close duplicate reports. Please also have a look at our [WorkingGuideLines](/wiki/WorkingGuideLines) before you actually start messing with the ticket system.

If you are not familiar with git, you might find our [GitGuideLines](/wiki/GitGuideLines) enlightening. It's a short overview of the practical side of our workflow with Git.

### Hack Midnight Commander

[Hacking](/wiki/Hacking)

### For translators

We have an [​account](https://www.transifex.com/projects/p/mc) on the [​Transifex](https://www.transifex.com) project. If you want help us with translations - just sign in (or log in) on the [​Transifex](https://www.transifex.com) and do it :).

Some translation statistics:

* [Getting started](/wiki/TxRepoSetup) with Transifex from command line;
* [Learn more](/wiki/TransifexGuideLine) about working with Transifex.

Now we don't have TranslatorsWorkflow? (sorry), therefore all translators feel free to update translations as often as needed. In future we will create TranslatorsWorkflow? in any case.

### Download in other formats:

* [Plain Text](/wiki/WikiStart?format=txt)

---

[![Trac Powered](/chrome/common/trac_logo_mini.png)](http://trac.edgewall.org/)

Powered by [**Trac 0.12.5**](/about)

By [Edgewall Software](http://www.edgewall.org/).

Visit the Trac free software project at
<http://trac.edgewall.org/>


