Based on the provided content, here's a breakdown of the vulnerability described, which aligns with the information for CVE-2021-44964:

**Root Cause:**

The vulnerability stems from a flaw in Lua's garbage collection (GC) logic, specifically within the `singlestep` function and how it interacts with finalizers and the garbage collection mode. The core issue is that during the finalization phase (`GCScallfin`), the garbage collector's mode can be unexpectedly changed due to recursive calls to the garbage collector (`GCTM`) within finalizers or by explicit calls to `collectgarbage("generational")`. This change of mode can occur while the system expects the garbage collector to be in incremental mode, leading to inconsistencies in how the garbage collector tracks objects, which then causes memory corruption and crashes.

**Weaknesses/Vulnerabilities:**

*   **Incorrect GC Mode Handling:** The `singlestep` function, when handling finalizers (`GCScallfin`), can trigger a garbage collection cycle that alters the global state's garbage collection mode (from incremental to generational). This change occurs within a context where the code assumes the mode will remain constant, violating the expected program flow.
*   **Recursive GC Calls:** The ability for finalizers (triggered via `__gc` metamethods) to initiate garbage collection through `collectgarbage` leads to re-entrant calls into `singlestep`, leading to mode changes during finalization and causing unpredictable state modifications.
*   **Use-After-Free:** The combination of incorrect GC mode handling and recursive GC calls corrupts the internal linked lists used by the garbage collector, which can lead to use-after-free vulnerabilities.
*   **Tcache Poisoning:** This memory corruption can be exploited via tcache poisoning, which allows an attacker to control memory allocation.

**Impact of Exploitation:**

*   **Sandbox Escape:** The most severe impact is the ability to escape the Lua sandbox. By leveraging the tcache poisoning, attackers can overwrite critical memory locations, such as the `__free_hook`, with the address of `system` function, allowing execution of arbitrary shell commands (`/bin/sh`), effectively breaking out of the restricted Lua environment.
*   **Crashes:** The vulnerability can cause segmentation faults (SEGV) and heap-use-after-free errors, leading to program crashes.

**Attack Vectors:**

*   **Crafted Lua Scripts:** Attackers can create malicious Lua scripts that define objects with `__gc` metamethods that trigger the vulnerability by either calling `collectgarbage("step")` within a loop, or explicitly triggering a mode change using `collectgarbage("generational")`.
*   **Chained GC Calls:** The exploit relies on the ability to chain garbage collection calls within the `__gc` metamethods, specifically when running finalizers.

**Required Attacker Capabilities/Position:**

*   **Ability to Execute Lua Code:** The attacker must have the ability to execute arbitrary Lua code, as this is the primary means of triggering the vulnerability.
*   **Knowledge of Lua GC:** Exploiting the vulnerability fully requires a moderate understanding of Lua's garbage collection mechanism to craft the necessary `__gc` metamethods and trigger the conditions that lead to memory corruption.
*   **Target System:** The attacker needs a vulnerable Lua environment, specifically version 5.4.4 and potentially other versions with similar GC logic flaws.

**Additional Information from the provided texts:**
* **Patch suggestion:**  A proposed patch involves saving the original GC state and forcing the GC to be in incremental mode before any finalizers are called. The saved state is restored after the finalizers have been executed. This avoids the unexpected mode changes during the finalizer calls.

This information is more detailed than the placeholder CVE description and offers a clear explanation of the vulnerability, its exploitation, and proposed fixes.