=== Content from github.com_0ad2633b_20250115_081644.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FLua-Project%2Flua-5.4.4-sandbox-escape-with-new-vulnerability)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FLua-Project%2Flua-5.4.4-sandbox-escape-with-new-vulnerability)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E&source=header-repo&source_repo=Lua-Project%2Flua-5.4.4-sandbox-escape-with-new-vulnerability)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[Lua-Project](/Lua-Project)
/
**[lua-5.4.4-sandbox-escape-with-new-vulnerability](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability)**
Public

* [Notifications](/login?return_to=%2FLua-Project%2Flua-5.4.4-sandbox-escape-with-new-vulnerability) You must be signed in to change notification settings
* [Fork
  2](/login?return_to=%2FLua-Project%2Flua-5.4.4-sandbox-escape-with-new-vulnerability)
* [Star
   7](/login?return_to=%2FLua-Project%2Flua-5.4.4-sandbox-escape-with-new-vulnerability)

[7
stars](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/stargazers) [2
forks](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/forks) [Branches](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/branches) [Tags](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/tags) [Activity](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/activity)
 [Star](/login?return_to=%2FLua-Project%2Flua-5.4.4-sandbox-escape-with-new-vulnerability)

 [Notifications](/login?return_to=%2FLua-Project%2Flua-5.4.4-sandbox-escape-with-new-vulnerability) You must be signed in to change notification settings

* [Code](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability)
* [Issues
  0](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/issues)
* [Pull requests
  0](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/pulls)
* [Actions](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/actions)
* [Projects
  0](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/projects)
* [Security](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/security)
* [Insights](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/pulse)

Additional navigation options

* [Code](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability)
* [Issues](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/issues)
* [Pull requests](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/pulls)
* [Actions](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/actions)
* [Projects](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/projects)
* [Security](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/security)
* [Insights](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/pulse)

# Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability

    main[Branches](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/branches)[Tags](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/tags)Go to fileCode
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| Latest commit History[4 Commits](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/commits/main/) | | |
| [x64](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/tree/main/x64 "x64") | | [x64](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/tree/main/x64 "x64") |  |  |
| [README.md](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/blob/main/README.md "README.md") | | [README.md](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/blob/main/README.md "README.md") |  |  |
| View all files | | |

## Repository files navigation

* README
# lua-5.4.4-sandbox-escape

### Create docker image

```
docker build --tag rce/x64:latest x64
```

### How to run

```
docker run -it rce/x64:latest /bin/bash
```

### Exploit

```
/LUA/lua/lua /LUA/exploit.lua
```

If you execute this shell, you will get /bin/sh
But, I don't know how to return the shell before executing this.
Be careful.

### Exploit Method

'exploit.lua' uses the use-after-free vulnerability to allow tcache bin poisoning which can change address of the next chunk in tcache bin. Using it, I can allocated a chunk at '\_\_free\_hook' and write the address of 'system' function in it. And then, I made some objects which contains 0x68732f6e69622f for containing "/bin/sh". When this script('exploit.lua') is over, 'free(object)' in garbage collecting process becomes 'system("/bin/sh").

## About

No description, website, or topics provided.
### Resources

[Readme](#readme-ov-file)

[Activity](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/activity)
[Custom properties](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/custom-properties)
### Stars

[**7**
stars](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/stargazers)
### Watchers

[**0**
watching](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/watchers)
### Forks

[**2**
forks](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/forks)
[Report repository](/contact/report-content?content_url=https%3A%2F%2Fgithub.com%2FLua-Project%2Flua-5.4.4-sandbox-escape-with-new-vulnerability&report=Lua-Project+%28user%29)

## [Releases](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/releases)

No releases published

## [Packages 0](/orgs/Lua-Project/packages?repo_name=lua-5.4.4-sandbox-escape-with-new-vulnerability)

No packages published

## Languages

* [Lua
  70.2%](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/search?l=lua)
* [Dockerfile
  29.8%](/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability/search?l=dockerfile)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from lua-users.org_616423be_20250115_081643.html ===


[[Date Prev](msg00014.html)][[Date Next](msg00016.html)][[Thread Prev](msg00007.html)][[Thread Next](msg00016.html)]
[[Date Index](index.html#00015)]
[[Thread Index](threads.html#00015)]

* **Subject**: **Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit**
* **From**: Roberto Ierusalimschy <roberto@[...](/cgi-bin/echo.cgi?inf.puc-rio.br)>
* **Date**: Sat, 4 Dec 2021 15:45:33 -0300

---

```
Thinking about all the cases,  I would consider a more radical
solution. Maybe we should forbid any GC operation while running
a finalizer. As we discussed several times in the past, finalizers
should be used to free resources that cannot be freed by the GC;
period. The less they should do, the better. But that can be a
too radical change for a bug-fix release.

-- Roberto

```

---

* **Follow-Ups**:
  + **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00016.html),** *김지회*
  + **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00020.html),** *Viacheslav Usov*
  + **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00033.html),** *Egor Skriptunoff*

* **References**:
  + **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00007.html),** *김지회*

* Prev by Date:
  **[Re: [ANN] el - an interactive shell-friendly form of Lua](msg00014.html)**
* Next by Date:
  **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00016.html)**
* Previous by thread:
  **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00007.html)**
* Next by thread:
  **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00016.html)**
* Index(es):
  + [**Date**](index.html#00015)
  + [**Thread**](threads.html#00015)



=== Content from lua-users.org_1d13b057_20250115_081643.html ===


[[Date Prev](msg00006.html)][[Date Next](msg00008.html)][[Thread Prev](msg00013.html)][[Thread Next](msg00015.html)]
[[Date Index](index.html#00007)]
[[Thread Index](threads.html#00007)]

* **Subject**: **Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit**
* **From**: 김지회 <pascal48@[...](/cgi-bin/echo.cgi?naver.com)>
* **Date**: Fri, 3 Dec 2021 01:54:37 +0900

---

```

```
> ```
>
> void luaC_runtilstate (lua_State *L, int statesmask, int nofin) {
>    global_State *g = G(L);
>    while (!testbit(statesmask, g->gcstate)) {
>      if (nofin && g->gcstate == GCScallfin) {
>        g->gcstate = GCSpause;  /* skip finalization state */
>        if (testbit(statesmask, g->gcstate))
>          break;
>      }
>      singlestep(L);
>    }
> }
>
> When 'nofin' is true, the loop simply skips the GCScallfin state.
>
> ```

```

Hmm, I'm tried over a day to create proper patch to the problem.
literally a day. Trust me, I'm between jobs. :-(

But the only way I found to solve this problem is

```
"Just do not let GCTM to change the gckind, Recovering original mode
after GCTM."
```

Because, the main problem is as I mentioned in the initial mail,

```
"singlestep function with case GCScallfin can change the mode of garbage
collection via GCTM."
```

The core part of the crash is that GCTM can change the mode.

```
In a normal case, if we restrict GCTM to be called only after doing
everything else by using a flag in luaC\_runtilstate function, the
problem will be gone.
```

crash1.lua can be handled well, too.

```
However, The problem arise again if GCTM is triggered by
collectgarbage("step") statement in lua script.
Because the script explicitly call incstep function which lead to
singlestep function without luaC\_runtilstate.
```

Eventually, it can change the mode of garbage collector.

```
Besides, in crash1.lua we trigger good collection to change the mode of
garbage collector, but  the mode can be changed via
collectgarbage("generational") statement in lua script.
Note that we can trigger the change with collectgarbage("generational")
lua script without recursive call of GCTM - it's exactly the same as
crash2.lua!
```

```
As a result, even if we restrict luaC\_runtilsate function by flag, the
same problem can be triggered by using collectgarbage("step") and
collectgarbage("generational").
you can find the exact example from crash2.lua script and ASAN report in
the initial mail.
```

I copy them in this mail also for convenience.

---------- [ crash2.lua ] -----------
setmetatable({}, {
    __gc = function()
        setmetatable({}, {
            __gc = function()
                collectgarbage("generational") -- Explicitly change mode
                setmetatable({}, {
                    __gc = function()
                        collectgarbage("step")
                        collectgarbage("step")()
                    end
                })
            end
        })
        collectgarbage("step")
    end

})

---------- [ Result of crash2.lua ] -----------
root@Newbie:/home/Sandbox/temp/lua# ./lua ../../DebugLua/crash2.lua
...
==171896==ERROR: AddressSanitizer: heap-use-after-free on address
0xf51034fc at pc 0x5656e70e bp 0xffffbf78 sp 0xffffbf68
...
SUMMARY: AddressSanitizer: heap-use-after-free
(/home/Sandbox/temp/lua/lua+0x1970d) in funcnamefromcode
--------------------------------------------------

In short, my suggestion after a long-time thinking is

--------- [singlestep in lgc.c BEFORE patch] -------------

...
case GCScallfin: { /* call remaining finalizers */
    if (g->tobefnz && !g->gcemergency) {
        g->gcstopem = 0; /* ok collections during finalizers */
        work = runafewfinalizers(L, GCFINMAX) * GCFINALIZECOST;
    }
    else { /* emergency mode or no more finalizers */
        g->gcstate = GCSpause; /* finish collection */
        work = 0;
    }
...

--------- [singlestep in lgc.c AFTER patch] -------------

...
case GCScallfin: { /* call remaining finalizers */
    if (g->tobefnz && !g->gcemergency) {
        g->gcstopem = 0; /* ok collections during finalizers */
        work = runafewfinalizers(L, GCFINMAX) * GCFINALIZECOST;
        // <<<<<<PATCH LINE START>>>>>>
        if(l_unlikely(g->gckind == KGC_GEN)){
            int savedgcstate = g->gcstate;
            enterinc(g);
            g->gcstate = savedgcstate;
        }
        // <<<<<<PATCH LINE END>>>>>>
    }
    else { /* emergency mode or no more finalizers */
        g->gcstate = GCSpause; /* finish collection */
        work = 0;
    }

...

----------------------------------------------------

, which is actually the same as my first suggestion.

```
Or, we shall change logic of incstep function to handle the finalizer
properly for every possible case.
```

By the way, I'm just wondering what the actual patch looks like.

```
Do we shall change incstep's logic or prevent GCTM to change mode by
recovering?
```

Thank you.
--Regards, Jihoi.

```

---

* **Follow-Ups**:
  + **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00015.html),** *Roberto Ierusalimschy*

* Prev by Date:
  **[Re: [ANN] el - an interactive shell-friendly form of Lua](msg00006.html)**
* Next by Date:
  **[Re: [ANN] el - an interactive shell-friendly form of Lua](msg00008.html)**
* Previous by thread:
  **[Re: [ANN] el - an interactive shell-friendly form of Lua](msg00013.html)**
* Next by thread:
  **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00015.html)**
* Index(es):
  + [**Date**](index.html#00007)
  + [**Thread**](threads.html#00007)



=== Content from lua-users.org_81e00c50_20250115_081643.html ===


[[Date Prev](msg00029.html)][[Date Next](msg00031.html)][[Thread Prev](msg00020.html)][[Thread Next](msg00031.html)]
[[Date Index](index.html#00030)]
[[Thread Index](threads.html#00030)]

* **Subject**: **Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit**
* **From**: 김지회 <pascal4847@[...](/cgi-bin/echo.cgi?gmail.com)>
* **Date**: Wed, 8 Dec 2021 02:53:06 +0900

---

```

```
> ```
>
> I'd suggest considering another radical change. Instead of
> "finalizers", let a C library that creates user data supply a
> "destructor" that is called by GC just before a given datum is
> positively going to be deallocated. Essentially like a C++ destructor.
>
> ```

```

Well, I don't think the problem comes from finalizer itself.

```
Instead, It comes from the fact that finalizer function can call garbage
collector (or even change mod of it).
```

Obviously, your idea can get rid of this sort of problems quite well.

```
But I can't be sure that the great fix is worth patching. (It's just my
opinion.)
```

```
Personally, I love the feature of metatable and finalizer - and it's
charm of Lua!
```

```
On the other hand, according to Roberto, It seems that there must be a
huge( radical ) fix.
I don't know what will happen, but it's nice time to discuss about
finalizer logic, I think.
```

I think we can make another thread to discuss about patch of this problem.

```
By the way, If there are no objections to this vulnerability and crash
analysis, I'll report it to MITRE soon.
```

Maybe this mail thread is about to be closed.
Thank you for all your brilliant ideas and kind replies.

--Regards, Jihoi.

```

---

* **Follow-Ups**:
  + **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00031.html),** *Roberto Ierusalimschy*

* **References**:
  + **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00007.html),** *김지회*
  + **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00015.html),** *Roberto Ierusalimschy*
  + **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00020.html),** *Viacheslav Usov*

* Prev by Date:
  **[Re: Equivalent to \_\_name\_\_ == “\_main\_\_”?](msg00029.html)**
* Next by Date:
  **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00031.html)**
* Previous by thread:
  **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00020.html)**
* Next by thread:
  **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00031.html)**
* Index(es):
  + [**Date**](index.html#00030)
  + [**Thread**](threads.html#00030)



=== Content from lua-users.org_a8a9d845_20250115_081642.html ===


[[Date Prev](msg00185.html)][[Date Next](msg00187.html)][[Thread Prev](msg00185.html)][[Thread Next](msg00187.html)]
[[Date Index](index.html#00186)]
[[Thread Index](threads.html#00186)]

* **Subject**: **Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit**
* **From**: 김지회 <pascal4847@[...](/cgi-bin/echo.cgi?gmail.com)>
* **Date**: Mon, 29 Nov 2021 19:08:13 +0900

---

**Hello, List!**

   Recently, my friends and I found interesting crashes in Lua Interpreter. In this mail, we’ll talk about the root cause of the crashes and how we analyzed them. Moreover, we find that using this problem, we can do Sandbox Escape so that execute ‘/bin/sh’ without os.execute and io.popen in Ubuntu 20.04. As the root cause is related to the logic of garbage collection, if you’re not familiar with the internal logic of LuaGC, we recommend you to take a look at the workshop PPT in 2018 for clear comprehension.

Link: <https://www.lua.org/wshop18/Ierusalimschy.pdf>

   Before we deep dive into the root cause and sandbox escape PoC, we’ll show some interesting crashes, for example. I think the test environment does not matter, but if you cannot reproduce the results of the following examples please try at

 - OS : Ubuntu 20.04 LTS

 - glibc : UBUNTU GLIBC 2.3.1

 - Lua : Lua 5.4.4 (commit hash ad3942adba574c9d008c99ce2785a5af19d146bf)

   which is the same as mine. Or, you can just use the docker file we created to build PoC. The PoC link is at the third part of this mail. The following contents consist of four parts.

1. Understanding crashes.

2. Defining the root cause of the crashes.

3. Sandbox Escape Exploit & PoC.

4. Finally, we will show a simple patch to fix the problem.

 Now, let’s start!

----------------------------------------------------------------------------

**Part 1. Understanding crashes.**

   Although we found various crashes related to this problem, the following example is the best among them to understand this problem.

---------- [ crash1.lua ] -----------

function func0 ()

 collectgarbage("step")

end

function func1 ()

 local func1\_table = {}

 local func1\_meta = { \_\_gc = func0 }

 setmetatable(func1\_table, func1\_meta)

 collectgarbage("step" , 1, func1\_table)

end

function func2 ()

 local func2\_table = {}

 local func2\_meta = { \_\_gc = func1 }

 setmetatable(func2\_table, func2\_meta)

end

for i = 0,1000,1 do

 func2()

end

------------------------------------------------

   Wow, It looks horrible. Let’s put the script into Lua Interpreter with address sanitizer... and, Boom!

---------- [ Result of crash1.lua ] -----------

root@Newbie:/home/Sandbox/temp/lua# ./lua ../crash1.lua

AddressSanitizer:DEADLYSIGNAL

==170305==ERROR: AddressSanitizer: SEGV

 on unknown address 0x00000005 (pc 0x5657e511 bp 0xf51012a0 sp 0xfff8f3b0 T0)

==170305==The signal is caused by a READ memory access.

==170305==Hint: address points to the zero page.

#0 0x5657e510 in separatetobefnz (/home/Sandbox/temp/lua/lua+0x29510)

#1 0x565838a9 in atomic (/home/Sandbox/temp/lua/lua+0x2e8a9)

#2 0x56586781 in luaC\_step (/home/Sandbox/temp/lua/lua+0x31781)

#3 0x5656b7cd in lua\_gc (/home/Sandbox/temp/lua/lua+0x167cd)

#4 0x565dd9da in luaB\_collectgarbage (/home/Sandbox/temp/lua/lua+0x889da)

#5 0x565778b9 in luaD\_precall (/home/Sandbox/temp/lua/lua+0x228b9)

#6 0x565b1239 in luaV\_execute (/home/Sandbox/temp/lua/lua+0x5c239)

#7 0x56578998 in luaD\_callnoyield (/home/Sandbox/temp/lua/lua+0x23998)

#8 0x5658003b in dothecall (/home/Sandbox/temp/lua/lua+0x2b03b)

#9 0x5657394d in luaD\_rawrunprotected (/home/Sandbox/temp/lua/lua+0x1e94d)

#10 0x56579789 in luaD\_pcall (/home/Sandbox/temp/lua/lua+0x24789)

#11 0x5657fcf8 in GCTM (/home/Sandbox/temp/lua/lua+0x2acf8)

....

#231 0x5657fcf8 in GCTM (/home/Sandbox/temp/lua/lua+0x2acf8)

#232 0x5658468f in singlestep (/home/Sandbox/temp/lua/lua+0x2f68f)

#233 0x56586756 in luaC\_step (/home/Sandbox/temp/lua/lua+0x31756)

#234 0x5656b7cd in lua\_gc (/home/Sandbox/temp/lua/lua+0x167cd)

#235 0x565dd9da in luaB\_collectgarbage (/home/Sandbox/temp/lua/lua+0x889da)

#236 0x565778b9 in luaD\_precall (/home/Sandbox/temp/lua/lua+0x228b9)

#237 0x565b1239 in luaV\_execute (/home/Sandbox/temp/lua/lua+0x5c239)

#238 0x56578998 in luaD\_callnoyield (/home/Sandbox/temp/lua/lua+0x23998)

#239 0x5658003b in dothecall (/home/Sandbox/temp/lua/lua+0x2b03b)

#240 0x5657394d in luaD\_rawrunprotected (/home/Sandbox/temp/lua/lua+0x1e94d)

#241 0x56579789 in luaD\_pcall (/home/Sandbox/temp/lua/lua+0x24789)

#242 0x5657fcf8 in GCTM (/home/Sandbox/temp/lua/lua+0x2acf8)

#243 0x5658468f in singlestep (/home/Sandbox/temp/lua/lua+0x2f68f)

#244 0x56586756 in luaC\_step (/home/Sandbox/temp/lua/lua+0x31756)

#245 0x5656b7cd in lua\_gc (/home/Sandbox/temp/lua/lua+0x167cd)

#246 0x565dd9da in luaB\_collectgarbage (/home/Sandbox/temp/lua/lua+0x889da)

AddressSanitizer can not provide additional info.

SUMMARY: AddressSanitizer: SEGV (/home/Sandbox/temp/lua/lua+0x29510) in separatetobefnz

==170305==ABORTING

---------------------------------------------

   Hmm. It’s a segmentation fault error. According to the call stack, It seems like the problem is in separatetobefnz function. Let’s take a look at the code.

---------- [ separatetobefnz in lgc.c] -----------

static void separatetobefnz (global\_State \*g, int all) {

 GCObject \*curr;

 GCObject \*\*p = &g->finobj;

 GCObject \*\*lastnext = findlast(&g->tobefnz);

 while ((curr = \*p) != g->finobjold1) { /\* traverse all finalizable objects \*/

  lua\_assert(tofinalize(curr));

  if (!(iswhite(curr) || all)) /\* not being collected? \*/

   p = &curr->next; /\* don't bother with it \*/

  else {

   if (curr == g->finobjsur) /\* removing 'finobjsur'? \*/

    g->finobjsur = curr->next; /\* correct it \*/

   \*p = curr->next; /\* remove 'curr' from 'finobj' list \*/

   curr->next = \*lastnext; /\* link at the end of 'tobefnz' list \*/

   \*lastnext = curr;

   lastnext = &curr->next;

  }

 }

}

------------------------------------------------------

   By some experiments, we found that curr variable is NULL so that the iswhite function is forced to refer invalid address (0x00000005). You can find the logic in line 6 and 8 of the function. Maybe the linked list in finobj is broken, so that the curr variable is corrupted. To analyze the exact state of the linked list, we wrote some custom codes to debug the problem.

--------- [ Results of custom debugging log] ---------------

-----[116th SEPARATE CALL]

[000]0xf4f2adf0 > [001]0xf4f2ae80 > [002]0xf4f2af10 > [003]0xf4f2afa0 > [004]0xf4f2b030 >

[005]0xf4f2b0c0 > [006]0xf4f2b150 > [007]0xf4f2b1e0 > [008]0xf4f2b270 > [009]0xf4f2b300 >

.....

[190]0xf4f24790 > [191]0xf4f24820 > [192]0xf4f248b0 > [193]0xf4f24940 > [194]0xf4f249d0 >

[195]0xf4f24a60 > [196]0xf4f01cc0 > [197]0xf4f01d50 > [198]0xf4f01e10 > [199]0xf4f012a0 >

[200] (nil)

-----[FINOBJOLD1 0xf4f2adf0] [FINOBJROLD 0xf4f2adf0]

[++++] 0xf4f2c500 freed (g->finobjold1: 0xf4f2adf0 | g->finobjrold: 0xf4f2adf0)

[++++] 0xf4f2adf0 freed (g->finobjold1: 0xf4f2adf0 | g->finobjrold: 0xf4f2adf0)

-----[117th SEPARATE CALL]

[000]0xf4f2ae80 > [001]0xf4f2af10 > [002]0xf4f2afa0 > [003]0xf4f2b030 > [004]0xf4f2b0c0 >

[005]0xf4f2b150 > [006]0xf4f2b1e0 > [007]0xf4f2b270 > [008]0xf4f2b300 > [009]0xf4f2b390 >

.....

[190]0xf4f24820 > [191]0xf4f248b0 > [192]0xf4f24940 > [193]0xf4f249d0 > [194]0xf4f24a60 >

[195]0xf4f01cc0 > [196]0xf4f01d50 > [197]0xf4f01e10 > [198]0xf4f012a0 > [199] (nil)

-----[FINOBJOLD1 0xf4f2adf0] [FINOBJROLD 0xf4f2adf0]

AddressSanitizer: SEGV(0x00000005)

------------------------------------------------------------------

   Wow. It seems that finobjold1 and finobjrold are not set to a proper variable when the object they point is freed. That makes line 32 of separatetobefnz function unable to find the break condition of the loop so that finally visit the next node of the last element in finobj linked list (which is nil). Now, let’s deep dive into the crash to find the root cause.

   Using gdb and static analysis, we find that separatetobefnz function is called from stepgenfull function when it leads to the crash. ( stepgenfull -> atomic -> separatetobefnz ). Then, we can find something weird in stepgenfull function.

--------- [ stepgenfull in lgc.c] -------------

static void stepgenfull (lua\_State \*L, global\_State \*g) {

 lu\_mem newatomic; /\* count of traversed objects \*/

 lu\_mem lastatomic = g->lastatomic; /\* count from last collection \*/

 if (g->gckind == KGC\_GEN) /\* still in generational mode? \*/

  enterinc(g); /\* enter incremental mode \*/

 luaC\_runtilstate(L, bitmask(GCSpropagate)); /\* start new cycle \*/

 newatomic = atomic(L); /\* mark everybody \*/

 if (newatomic < lastatomic + (lastatomic >> 3)) { /\* good collection? \*/

  atomic2gen(L, g); /\* return to generational mode \*/

  setminordebt(g);

 }

 else { /\* another bad collection; stay in incremental mode \*/

  g->GCestimate = gettotalbytes(g); /\* first estimate \*/;

  entersweep(L);

  luaC\_runtilstate(L, bitmask(GCSpause)); /\* finish collection \*/

  setpause(g);

  g->lastatomic = newatomic;

 }

}

------------------------------------------------------------------

   Yes. line 6 (atomic function call) of the stepgenfull function should be run in incremental mode. So, separatetobefnz function of the crash must have nil value in both finobjold1 and finobjrold! Why the variables are not nil even after enterinc function? The answer is that, actually, the atomic function is called in generational mode, not incremental mode. It is obvious that such flow is not considered as normal, as comments say. Then, How? it seems that there is no chance g->gckind to be generational mode after enterinc function (line 4).

   After some analysis, we found that runtilstate function can change the value of g->gckind, so that the weird flow happens. You can check the phenomenon by modifying stepgenfull function into the following code for debugging.

--------- [ stepgenfull, modified for analyze ] -------------

static void stepgenfull (lua\_State \*L, global\_State \*g) {

 lu\_mem newatomic;

 lu\_mem lastatomic = g->lastatomic;

 if (g->gckind == KGC\_GEN)

  enterinc(g);

 **if (g->gckind == KGC\_GEN) printf(“[!] luaC\_runtilstate does not start with KGC\_INC\n”);**

 **// Above line is added for debugging purpose.**

 luaC\_runtilstate(L, bitmask(GCSpropagate));

 **if (g->gckind == KGC\_INC) printf(“[!] luaC\_runtilstate change gckind into KGC\_GEN\n”);**

 **// Above line is added for debugging purpose.**

 newatomic = atomic(L);

 .....

--------- [ Result of stepgenfull, modified for analyze ] -------

root@Newbie:/home/Sandbox/temp/lua# ./lua ../crash1.lua

[!] luaC\_runtilstate Change gckind into KGC\_GEN

[!] luaC\_runtilstate Change gckind into KGC\_GEN

AddressSanitizer:DEADLYSIGNAL

...

------------------------------------------------------------------

   We thought that there is no possible way that runtilstate function change g->gckind, so we needed to go deeper. Thanks to gdb, we found that runafewfinalizers function in singlestep function can change the g->gckind. The reason is quite simple. runafewfinalizers function calls GCTM function, which can recursively call another garbage collection (this is the reason why crash1.lua puts collectgarbage function inside of gc metamethod). As a result, good collection happened during GCTM function, and gckind was set in generational mode.

   We used the following code to make sure of the analysis.

--------- [singlestep in lgc.c, modified for analyze ] -------------

...

case GCScallfin: { /\* call remaining finalizers \*/

 if (g->tobefnz && !g->gcemergency) {

  g->gcstopem = 0; /\* ok collections during finalizers \*/

  int temp = g->gckind; // This line is added for debugging purpose.

  work = runafewfinalizers(L, GCFINMAX) \* GCFINALIZECOST;

  if(g->gckind != temp) printf(“[!] runafewfinalizers change g->gckind\n”);

  // Above line is added for debugging purpose.

 }

 else { /\* emergency mode or no more finalizers \*/

  g->gcstate = GCSpause; /\* finish collection \*/

  work = 0;

 }

...

--------- [Result of singlestep in lgc.c, modified for analyze ] -------------

root@Newbie:/home/Sandbox/temp/lua# ./lua ../crash1.lua

[!] runafefinalizers change g->gckind

[!] runafefinalizers change g->gckind

[!] luaC\_runtilstate change gckind into KGC\_GEN

[!] runafefinalizers change g->gckind

[!] luaC\_runtilstate change gckind into KGC\_GEN

AddressSanitizer:DEADLYSIGNAL

------------------------------------------------------------------

  **Part 2. Defining the root cause of the crash.**

   So, In short, the root cause is...

1. singlestep function with case GCScallfin can change the mode of garbage collection, because GCTM can recursively call garbage collection logic.

2. runtilstate function can internally call singlestep function with case GCScallfin.

3. Some functions are developed with the assumption that runtilstate cannot change the mode of garbage collection, as stepgenfull function is.

4. As a result, the functions may run increment mode logic in generational mode.

5. Such behavior can break linked list in global state, lead to various crashes for example SEGV in separatetobefnz function.

    There are two ways we find that GCTM function changes the mode of garbage collection in the current global state.

1. As we showed above, when a good collection occurs during incremental step, the mode can be changed during GCTM.

2. Explicitly calling garbagecollection(“generational”) can change the mode during GCTM.

   The following script shows that the second case(explicitly calling mode change) also creates a similar crash.

---------- [ crash2.lua ] -----------

setmetatable({}, {

 \_\_gc = function()

  setmetatable({}, {

   \_\_gc = function()

    collectgarbage("generational") -- Explicitly change mode

    setmetatable({}, {

     \_\_gc = function()

      collectgarbage("step")

      collectgarbage("step")()

     end

    })

   end

  })

  collectgarbage("step")

 end

})

---------- [ Result of crash2.lua ] -----------

root@Newbie:/home/Sandbox/temp/lua# ./lua ../../DebugLua/crash2.lua

[!] runafefinalizers change g->gckind

=================================================================

==171896==ERROR: AddressSanitizer: heap-use-after-free on address 0xf51034fc at pc 0x5656e70e bp 0xffffbf78 sp 0xffffbf68

READ of size 4 at 0xf51034fc thread T0

 #0 0x5656e70d in funcnamefromcode (/home/Sandbox/temp/lua/lua+0x1970d)

 #1 0x56572068 in luaG\_callerror (/home/Sandbox/temp/lua/lua+0x1d068)

 #2 0x56575635 in luaD\_tryfuncTM (/home/Sandbox/temp/lua/lua+0x20635)

.....

 #23 0x5655f5e5 in main (/home/Sandbox/temp/lua/lua+0xa5e5)

 #24 0xf767aee4 in \_\_libc\_start\_main (/lib/i386-linux-gnu/libc.so.6+0x1eee4)

 #25 0x5655feb4 in \_start (/home/Sandbox/temp/lua/lua+0xaeb4)

.....

SUMMARY: AddressSanitizer: heap-use-after-free (/home/Sandbox/temp/lua/lua+0x1970d) in funcnamefromcode

.....

----------------------------------------------------

   Note that the above crash is not related to sweepgenfull function, but originated from the same reason. As the problem is based on the same root cause, we will not explain details about crash2.lua here. You can easily find that GCTM also change the gckind into KGC\_GEN as crash1.lua did, by explicitly calling collectgarbage(“generational”) in gc metamethod.

**Part 3. Sandbox Escape Exploit & PoC.**

   Actually, as you can see from the above examples, this problem can corrupt the linked lists of objects in the global state. As a result, we find that we can do “Tcache Poisoning” using this problem. The tcache poisoning can lead to sandbox escape. However, in this mail, we will not explain the details about the exploit (too long to explain).

   You can check the exploit and detailed explanation of it from the Github link below, with docker file.

Github link: <https://github.com/Lua-Project/lua-5.4.4-sandbox-escape-with-new-vulnerability>

------- [Results of Sandbox Escape] ------

root@55bbe1743963:/LUA/lua# /LUA/lua/lua /LUA/exploit.lua

sh: 1: еdUUU: not found

# whoami

root

----------------------------------------------------

**Part 4. Simple patch to fix the problem. (Suggestion)**

   There can be many ways to patch this problem. Maybe we can forbid developers to use garbage collection in gc metamethod. However, we devised the following patch as a solution, without breaking the usability and backward compatibility.

--------- [singlestep in lgc.c BEFORE patch] -------------

...

case GCScallfin: { /\* call remaining finalizers \*/

 if (g->tobefnz && !g->gcemergency) {

  g->gcstopem = 0; /\* ok collections during finalizers \*/

  work = runafewfinalizers(L, GCFINMAX) \* GCFINALIZECOST;

 }

 else { /\* emergency mode or no more finalizers \*/

  g->gcstate = GCSpause; /\* finish collection \*/

  work = 0;

 }

...

--------- [singlestep in lgc.c AFTER patch] -------------

...

case GCScallfin: { /\* call remaining finalizers \*/

 if (g->tobefnz && !g->gcemergency) {

  g->gcstopem = 0; /\* ok collections during finalizers \*/

  work = runafewfinalizers(L, GCFINMAX) \* GCFINALIZECOST;

 **// <<<<<<PATCH LINE START>>>>>>**

 **if(l\_unlikely(g->gckind == KGC\_GEN)){**

 **int savedgcstate = g->gcstate;**

 **enterinc(g);**

 **g->gcstate = savedgcstate;**

 **}**

 **// <<<<<<PATCH LINE END>>>>>>**

 }

 else { /\* emergency mode or no more finalizers \*/

  g->gcstate = GCSpause; /\* finish collection \*/

  work = 0;

 }

...

----------------------------------------------------

   This patch lets GCTM change the mode of the global state, but when it returns, fix it into the original mode. Note that we shall recover global gcstate, as enterinc function changes the state into GCSPause. Using this patch, crash1.lua and crash2.lua are well interpreted by Lua without error.

---------[Results of crash1.lua and crash2.lua after patch] ------------------

root@Newbie:/home/Sandbox/temp/lua# ./lua ../crash1.lua

root@Newbie:/home/Sandbox/temp/lua# ./lua ../crash2.lua

[No Lua error, No address sanitizer error.]

---------------------------------------------------------------------------------------

   However, as We're not an expert on garbage collection logic, this patch may have unexpected side effects. We hope someone will solve the problem properly if our patch is not suitable.

---------------------------------------------------------------------------------------

   Thank you for reading. Any comments are welcomed. If you have a problem with reproducing the error or understanding analysis, feel free to comment in this thread.

Found by: Jihoi Kim, Sunghun Oh, Minseok Kang, MinJoong Kim, WooSun Kang, HyungChan Kim

Team Nil Armstrong

-- Regards, Jihoi.

---

* **Follow-Ups**:
  + **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00187.html),** *Flyer31 Test*
  + **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00192.html),** *Roberto Ierusalimschy*

* Prev by Date:
  **[Luver - version manager for Lua (+ LuaJIT + LuaRocks)](msg00185.html)**
* Next by Date:
  **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00187.html)**
* Previous by thread:
  **[Luver - version manager for Lua (+ LuaJIT + LuaRocks)](msg00185.html)**
* Next by thread:
  **[Re: Crash Analysis: Finalizer Logic in singlestep function can lead to Sandbox Escape Exploit](msg00187.html)**
* Index(es):
  + [**Date**](index.html#00186)
  + [**Thread**](threads.html#00186)


