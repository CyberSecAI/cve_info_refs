=== Content from git.kernel.org_ded3fead_20250115_093229.html ===


| [cgit logo](/) | [index](/) : [bluez.git](/pub/scm/bluetooth/bluez.git/) | master |
| --- | --- | --- |
| Bluetooth protocol stack for Linux | Marcel Holtmann |

| [about](/pub/scm/bluetooth/bluez.git/about/)[summary](/pub/scm/bluetooth/bluez.git/)[refs](/pub/scm/bluetooth/bluez.git/refs/?id=838c0dc7641e1c991c0f3027bf94bee4606012f8)[log](/pub/scm/bluetooth/bluez.git/log/)[tree](/pub/scm/bluetooth/bluez.git/tree/?id=838c0dc7641e1c991c0f3027bf94bee4606012f8)[commit](/pub/scm/bluetooth/bluez.git/commit/?id=838c0dc7641e1c991c0f3027bf94bee4606012f8)[diff](/pub/scm/bluetooth/bluez.git/diff/?id=838c0dc7641e1c991c0f3027bf94bee4606012f8)[stats](/pub/scm/bluetooth/bluez.git/stats/)[homepage](http://www.bluez.org) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Bernie Conrad <bernie@allthenticate.net> | 2021-09-28 16:00:15 -0700 |
| --- | --- | --- |
| committer | Luiz Augusto von Dentz <luiz.von.dentz@intel.com> | 2021-09-29 15:43:15 -0700 |
| commit | [838c0dc7641e1c991c0f3027bf94bee4606012f8](/pub/scm/bluetooth/bluez.git/commit/?id=838c0dc7641e1c991c0f3027bf94bee4606012f8) ([patch](/pub/scm/bluetooth/bluez.git/patch/?id=838c0dc7641e1c991c0f3027bf94bee4606012f8)) | |
| tree | [6f51ef89133e923bc3c6702604cadbe2f17c2bc7](/pub/scm/bluetooth/bluez.git/tree/?id=838c0dc7641e1c991c0f3027bf94bee4606012f8) | |
| parent | [1e9ce5ed80f1f7c2fc80b14ba72e667403e9c88f](/pub/scm/bluetooth/bluez.git/commit/?id=1e9ce5ed80f1f7c2fc80b14ba72e667403e9c88f) ([diff](/pub/scm/bluetooth/bluez.git/diff/?id=838c0dc7641e1c991c0f3027bf94bee4606012f8&id2=1e9ce5ed80f1f7c2fc80b14ba72e667403e9c88f)) | |

gatt: Fix not cleaning up when disconnectedThere is a current use after free possible on a gatt server if a client
disconnects while a WriteValue call is being processed with dbus.
This patch includes the addition of a pending disconnect callback to handle
cleanup better if a disconnect occurs during a write, an acquire write
or read operation using bt\_att\_register\_disconnect with the cb.
[Diffstat](/pub/scm/bluetooth/bluez.git/diff/?id=838c0dc7641e1c991c0f3027bf94bee4606012f8)

| -rw-r--r-- | [src/gatt-database.c](/pub/scm/bluetooth/bluez.git/diff/src/gatt-database.c?id=838c0dc7641e1c991c0f3027bf94bee4606012f8) | 128 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 74 insertions, 54 deletions

| diff --git a/src/gatt-database.c b/src/gatt-database.cindex 1f7ce5f024..68f411ba45 100644--- a/[src/gatt-database.c](/pub/scm/bluetooth/bluez.git/tree/src/gatt-database.c?id=1e9ce5ed80f1f7c2fc80b14ba72e667403e9c88f)+++ b/[src/gatt-database.c](/pub/scm/bluetooth/bluez.git/tree/src/gatt-database.c?id=838c0dc7641e1c991c0f3027bf94bee4606012f8)@@ -141,8 +141,9 @@ struct external\_desc { };  struct pending\_op {- struct btd\_device \*device;+ struct bt\_att \*att; unsigned int id;+ unsigned int disconn\_id; uint16\_t offset; uint8\_t link\_type; struct gatt\_db\_attribute \*attrib;@@ -933,6 +934,26 @@ static struct btd\_device \*att\_get\_device(struct bt\_att \*att) return btd\_adapter\_find\_device(adapter, &dst, dst\_type); } ++static void pending\_op\_free(void \*data)+{+ struct pending\_op \*op = data;++ if (op->owner\_queue)+ queue\_remove(op->owner\_queue, op);++ bt\_att\_unregister\_disconnect(op->att, op->disconn\_id);+ bt\_att\_unref(op->att);+ free(op);+}++static void pending\_disconnect\_cb(int err, void \*user\_data)+{+ struct pending\_op \*op = user\_data;++ op->owner\_queue = NULL;+}+ static struct pending\_op \*pending\_ccc\_new(struct bt\_att \*att, struct gatt\_db\_attribute \*attrib, uint16\_t value,@@ -952,21 +973,16 @@ static struct pending\_op \*pending\_ccc\_new(struct bt\_att \*att, op->data.iov\_base = UINT\_TO\_PTR(value); op->data.iov\_len = sizeof(value); - op->device = device;+ op->att = bt\_att\_ref(att); op->attrib = attrib; op->link\_type = link\_type; - return op;-}+ bt\_att\_register\_disconnect(att,+ pending\_disconnect\_cb,+ op,+ NULL); -static void pending\_op\_free(void \*data)-{- struct pending\_op \*op = data;-- if (op->owner\_queue)- queue\_remove(op->owner\_queue, op);-- free(op);+ return op; }  static void gatt\_ccc\_write\_cb(struct gatt\_db\_attribute \*attrib,@@ -2169,31 +2185,35 @@ done: gatt\_db\_attribute\_read\_result(op->attrib, op->id, ecode, value, len); } -static struct pending\_op \*pending\_read\_new(struct btd\_device \*device,++static struct pending\_op \*pending\_read\_new(struct bt\_att \*att, struct queue \*owner\_queue, struct gatt\_db\_attribute \*attrib,- unsigned int id, uint16\_t offset,- uint8\_t link\_type)+ unsigned int id, uint16\_t offset) { struct pending\_op \*op;  op = new0(struct pending\_op, 1);  op->owner\_queue = owner\_queue;- op->device = device;+ op->att = bt\_att\_ref(att); op->attrib = attrib; op->id = id; op->offset = offset;- op->link\_type = link\_type;+ op->link\_type = bt\_att\_get\_link\_type(att); queue\_push\_tail(owner\_queue, op); + op->disconn\_id = bt\_att\_register\_disconnect(att, pending\_disconnect\_cb,+ op, NULL);+ return op; }  static void append\_options(DBusMessageIter \*iter, void \*user\_data) { struct pending\_op \*op = user\_data;- const char \*path = device\_get\_path(op->device);+ struct btd\_device \*device = att\_get\_device(op->att);+ const char \*path = device\_get\_path(device); struct bt\_gatt\_server \*server; const char \*link; uint16\_t mtu;@@ -2220,7 +2240,7 @@ static void append\_options(DBusMessageIter \*iter, void \*user\_data) dict\_append\_entry(iter, "prepare-authorize", DBUS\_TYPE\_BOOLEAN, &op->prep\_authorize); - server = btd\_device\_get\_gatt\_server(op->device);+ server = btd\_device\_get\_gatt\_server(device); mtu = bt\_gatt\_server\_get\_mtu(server);  dict\_append\_entry(iter, "mtu", DBUS\_TYPE\_UINT16, &mtu);@@ -2243,18 +2263,16 @@ static void read\_setup\_cb(DBusMessageIter \*iter, void \*user\_data) dbus\_message\_iter\_close\_container(iter, &dict); } -static struct pending\_op \*send\_read(struct btd\_device \*device,+static struct pending\_op \*send\_read(struct bt\_att \*att, struct gatt\_db\_attribute \*attrib, GDBusProxy \*proxy, struct queue \*owner\_queue, unsigned int id,- uint16\_t offset,- uint8\_t link\_type)+ uint16\_t offset) { struct pending\_op \*op; - op = pending\_read\_new(device, owner\_queue, attrib, id, offset,- link\_type);+ op = pending\_read\_new(att, owner\_queue, attrib, id, offset);  if (g\_dbus\_proxy\_method\_call(proxy, "ReadValue", read\_setup\_cb, read\_reply\_cb, op, pending\_op\_free) == TRUE)@@ -2337,15 +2355,17 @@ static void write\_reply\_cb(DBusMessage \*message, void \*user\_data) }  done:- gatt\_db\_attribute\_write\_result(op->attrib, op->id, ecode);+ /\* Make sure that only reply if the device is connected \*/+ if (!bt\_att\_get\_fd(op->att))+ gatt\_db\_attribute\_write\_result(op->attrib, op->id, ecode); } -static struct pending\_op \*pending\_write\_new(struct btd\_device \*device,+static struct pending\_op \*pending\_write\_new(struct bt\_att \*att, struct queue \*owner\_queue, struct gatt\_db\_attribute \*attrib, unsigned int id, const uint8\_t \*value, size\_t len,- uint16\_t offset, uint8\_t link\_type,+ uint16\_t offset, bool is\_characteristic, bool prep\_authorize) {@@ -2356,33 +2376,37 @@ static struct pending\_op \*pending\_write\_new(struct btd\_device \*device, op->data.iov\_base = (uint8\_t \*) value; op->data.iov\_len = len; - op->device = device;+ op->att = bt\_att\_ref(att); op->owner\_queue = owner\_queue; op->attrib = attrib; op->id = id; op->offset = offset;- op->link\_type = link\_type;+ op->link\_type = bt\_att\_get\_link\_type(att); op->is\_characteristic = is\_characteristic; op->prep\_authorize = prep\_authorize; queue\_push\_tail(owner\_queue, op); + bt\_att\_register\_disconnect(att,+ pending\_disconnect\_cb,+ op, NULL);+ return op; } -static struct pending\_op \*send\_write(struct btd\_device \*device,+static struct pending\_op \*send\_write(struct bt\_att \*att, struct gatt\_db\_attribute \*attrib, GDBusProxy \*proxy, struct queue \*owner\_queue, unsigned int id, const uint8\_t \*value, size\_t len,- uint16\_t offset, uint8\_t link\_type,+ uint16\_t offset, bool is\_characteristic, bool prep\_authorize) { struct pending\_op \*op; - op = pending\_write\_new(device, owner\_queue, attrib, id, value, len,- offset, link\_type, is\_characteristic,+ op = pending\_write\_new(att, owner\_queue, attrib, id, value, len,+ offset, is\_characteristic, prep\_authorize);  if (g\_dbus\_proxy\_method\_call(proxy, "WriteValue", write\_setup\_cb,@@ -2558,17 +2582,16 @@ static void acquire\_write\_setup(DBusMessageIter \*iter, void \*user\_data) }  static struct pending\_op \*acquire\_write(struct external\_chrc \*chrc,- struct btd\_device \*device,+ struct bt\_att \*att, struct gatt\_db\_attribute \*attrib, unsigned int id,- const uint8\_t \*value, size\_t len,- uint8\_t link\_type)+ const uint8\_t \*value, size\_t len) { struct pending\_op \*op; bool acquiring = !queue\_isempty(chrc->pending\_writes); - op = pending\_write\_new(device, chrc->pending\_writes, attrib, id, value,- len, 0, link\_type, false, false);+ op = pending\_write\_new(att, chrc->pending\_writes, attrib, id, value,+ len, 0, false, false);  if (acquiring) return op;@@ -2851,8 +2874,8 @@ static void desc\_read\_cb(struct gatt\_db\_attribute \*attrib, goto fail; } - if (send\_read(device, attrib, desc->proxy, desc->pending\_reads, id,- offset, bt\_att\_get\_link\_type(att)))+ if (send\_read(att, attrib, desc->proxy, desc->pending\_reads, id,+ offset)) return;  fail:@@ -2883,10 +2906,9 @@ static void desc\_write\_cb(struct gatt\_db\_attribute \*attrib, if (opcode == BT\_ATT\_OP\_PREP\_WRITE\_REQ) { if (!device\_is\_trusted(device) && !desc->prep\_authorized && desc->req\_prep\_authorization)- send\_write(device, attrib, desc->proxy,+ send\_write(att, attrib, desc->proxy, desc->pending\_writes, id, value, len,- offset, bt\_att\_get\_link\_type(att),- false, true);+ offset, false, true); else gatt\_db\_attribute\_write\_result(attrib, id, 0); @@ -2896,9 +2918,8 @@ static void desc\_write\_cb(struct gatt\_db\_attribute \*attrib, if (opcode == BT\_ATT\_OP\_EXEC\_WRITE\_REQ) desc->prep\_authorized = false; - if (send\_write(device, attrib, desc->proxy, desc->pending\_writes, id,- value, len, offset, bt\_att\_get\_link\_type(att), false,- false))+ if (send\_write(att, attrib, desc->proxy, desc->pending\_writes, id,+ value, len, offset, false, false)) return;  fail:@@ -2977,8 +2998,8 @@ static void chrc\_read\_cb(struct gatt\_db\_attribute \*attrib, goto fail; } - if (send\_read(device, attrib, chrc->proxy, chrc->pending\_reads, id,- offset, bt\_att\_get\_link\_type(att)))+ if (send\_read(att, attrib, chrc->proxy, chrc->pending\_reads, id,+ offset)) return;  fail:@@ -3016,9 +3037,9 @@ static void chrc\_write\_cb(struct gatt\_db\_attribute \*attrib, if (opcode == BT\_ATT\_OP\_PREP\_WRITE\_REQ) { if (!device\_is\_trusted(device) && !chrc->prep\_authorized && chrc->req\_prep\_authorization)- send\_write(device, attrib, chrc->proxy, queue,+ send\_write(att, attrib, chrc->proxy, queue, id, value, len, offset,- bt\_att\_get\_link\_type(att), true, true);+ true, true); else gatt\_db\_attribute\_write\_result(attrib, id, 0); @@ -3039,13 +3060,12 @@ static void chrc\_write\_cb(struct gatt\_db\_attribute \*attrib, }  if (g\_dbus\_proxy\_get\_property(chrc->proxy, "WriteAcquired", &iter)) {- if (acquire\_write(chrc, device, attrib, id, value, len,- bt\_att\_get\_link\_type(att)))+ if (acquire\_write(chrc, att, attrib, id, value, len)) return; } - if (send\_write(device, attrib, chrc->proxy, queue, id, value, len,- offset, bt\_att\_get\_link\_type(att), false, false))+ if (send\_write(att, attrib, chrc->proxy, queue, id, value, len,+ offset, false, false)) return;  fail: |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 09:31:06 +0000



=== Content from lists.debian.org_9cca5183_20250115_093229.html ===


---

[[Date Prev](msg00025.html)][[Date Next](msg00027.html)]
[[Thread Prev](msg00025.html)][[Thread Next](msg00027.html)]
[[Date Index](maillist.html#00026)]
[[Thread Index](threads.html#00026)]

# [SECURITY] [DLA 3157-1] bluez security update

---

* *To*: debian-lts-announce@lists.debian.org
* *Subject*: [SECURITY] [DLA 3157-1] bluez security update
* *From*: Sylvain Beucler <beuc@beuc.net>
* *Date*: Mon, 24 Oct 2022 12:50:09 +0200
* *Message-id*: <[[ðŸ”Ž]](/msgid-search/20221024105009.GA14024%40mail.beuc.net)Â [20221024105009.GA14024@mail.beuc.net](msg00026.html)>
* *Mail-followup-to*: debian-lts@lists.debian.org
* *Reply-to*: debian-lts@lists.debian.org

---

```
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

- -------------------------------------------------------------------------
Debian LTS Advisory DLA-3157-1                debian-lts@lists.debian.org
<https://www.debian.org/lts/security/>                      Sylvain Beucler
October 24, 2022                              <https://wiki.debian.org/LTS>
- -------------------------------------------------------------------------

Package        : bluez
Version        : 5.50-1.2~deb10u3
CVE ID         : CVE-2019-8921 CVE-2019-8922 CVE-2021-41229 CVE-2021-43400
                 CVE-2022-0204 CVE-2022-39176 CVE-2022-39177
Debian Bug     : 998626 1000262 1003712

Several vulnerabilities were discovered in BlueZ, the Linux Bluetooth
protocol stack. An attacker could cause a denial-of-service (DoS) or
leak information.

CVE-2019-8921

    SDP infoleak, the vulnerability lies in the handling of a
    SVC_ATTR_REQ by the SDP implementation of BlueZ. By crafting a
    malicious CSTATE, it is possible to trick the server into
    returning more bytes than the buffer actually holds, resulting in
    leaking arbitrary heap data.

CVE-2019-8922

    SDP Heap Overflow; this vulnerability lies in the SDP protocol
    handling of attribute requests as well. By requesting a huge
    number of attributes at the same time, an attacker can overflow
    the static buffer provided to hold the response.

CVE-2021-41229

    sdp_cstate_alloc_buf allocates memory which will always be hung in
    the singly linked list of cstates and will not be freed. This will
    cause a memory leak over time. The data can be a very large
    object, which can be caused by an attacker continuously sending
    sdp packets and this may cause the service of the target device to
    crash.

CVE-2021-43400

    A use-after-free in gatt-database.c can occur when a client
    disconnects during D-Bus processing of a WriteValue call.

CVE-2022-0204

    A heap overflow vulnerability was found in bluez. An attacker with
    local network access could pass specially crafted files causing an
    application to halt or crash, leading to a denial of service.

CVE-2022-39176

    BlueZ allows physically proximate attackers to obtain sensitive
    information because profiles/audio/avrcp.c does not validate
    params_len.

CVE-2022-39177

    BlueZ allows physically proximate attackers to cause a denial of
    service because malformed and invalid capabilities can be
    processed in profiles/audio/avdtp.c.

For Debian 10 buster, these problems have been fixed in version
5.50-1.2~deb10u3.

We recommend that you upgrade your bluez packages.

For the detailed security status of bluez please refer to
its security tracker page at:
<https://security-tracker.debian.org/tracker/bluez>

Further information about Debian LTS security advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://wiki.debian.org/LTS>
-----BEGIN PGP SIGNATURE-----

iQIzBAEBCgAdFiEE1vEOfV7HXWKqBieIDTl9HeUlXjAFAmNWbWAACgkQDTl9HeUl
XjDrzhAAi2eDAo7tZMmJEKn62ZAEOw/AlMKTU7QHVvq9N3XFLDvYVt6x7wWSszaW
CRa5Rps908YQEjnj2P5eLR4LJ3pZnhrr0ZMlgfzMPa48ZKW6CyLNZOOunrsos5gH
aQszVDnxb861hMvZl8ZxUdIF0/WsEI5az9HGDSIUKHWlMLZj/jAGaxYbJHVkVZZa
1E5vnswd3cWqOhrFY2S0NKgvoUSEl5Us8y33g8nr5+AdSa3n2BLRfpoUwm6lRLAk
CydEbqJ+zzgbOIGTrWBo5pOQjrewSoLkAfQ8k5BI88io6Wt2J++iRsViso9TLPDP
y6HnK7B6jF2tnZpUtmcEWOhH4nr74Js6hqBcl0Y7gMLfkxP57JdWm4IWXrgrjbJH
dNipWxuglMrKBjgd4fODM2bR7FTXX7drSUwcjW85ytJOPVxxA/Yq+Gd6EjaiMWaa
GqaG1ARX1PFdSRpksl1fwn8wF9C6mxRaJt2yRd0SNQlNpXK393q1MgnRv2gURl8n
zNDRkmp9eZqFA3EWTf4/xslllInjvtBZ1xPy0h+dKDD/LSggC6H2SDUKk93ADgtC
XgfdyJaUxgTmV5JnJ1T2uCNjeUg3ESzlCIkULVb3JD3O8Ygl0P9CExYq2CyyHAvD
739mI0wK2JwUu2E4MTr8pmKfs3wVHIynTLNRqCTo5eVFgAn98/U=
=71GU
-----END PGP SIGNATURE-----

```

---


