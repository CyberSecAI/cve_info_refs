```
{
  "guidelines": "1. First verify if the content relates to the CVE specified based on the official description\n2. If the content does not relate to this CVE, respond with \"UNRELATED\"\n3. If no useful vulnerability information is found, respond with \"NOINFO\" \n4. For relevant content, extract:\n   - Root cause of vulnerability\n   - Weaknesses/vulnerabilities present\n   - Impact of exploitation\n   - Attack vectors\n   - Required attacker capabilities/position\n\nAdditional instructions:\n- Preserve original technical details and descriptions\n- Remove unrelated content\n- Translate non-English content to English\n- Note if the content provides more detail than the official CVE description",
  "response": {
    "CVE-2021-42374": {
      "content": "The vulnerability is caused by an insufficient size check in the `unpack_lzma_stream` function (in decompress\_unlzma.c) when the state >= `LZMA_NUM_LIT_STATES`\n\nTo trigger the vulnerability and to control the starting offset where we will leak data from, we need to make sure that the following conditions are satisfied:\n\n`buffer_pos = 0\n\nand\n\nrep0 = offset + dict_size`\n\nThis way, `pos` will be equal to `-(offset + dict_size)`. After adding `dict_size`, `pos` will be `-offset` and so we could leak memory from our desired offset through match\_byte. The leaked memory will most likely contain pointers which could further assist attackers in their exploitation campaign (ex. by facilitating ASLR bypass).\n\nThe general idea to exploit this vulnerability is to prepare a specifically crafted LZMA encoded stream, so that when it is decoded, both conditions will be filled and `pos` will be equal to a negative number `-offset`. Eventually, the decompressed stream will contain the leaked memory, which will be written to the output steam.\n\nTo satisfy the first condition `buffer_pos = 0`, we need to make sure our code flow (`state >= LZMA_NUM_LIT_STATES`) is reached right after the current decompressed buffer stream is flushed and so the buffer pointer position will be 0. We can achieve this by reaching the last iteration of a current match:\n\nThe second condition is more difficult to satisfy and requires intimate knowledge of how the LZMA algorithm works. The general idea is to encode a special length in the LZMA bit stream so that when decoded it will be used by the `rep0` variable.\n\nTo conclude, in order to reach an OOB condition, we need to write some bytes, then use a match to fill the buffer to `header.dict_size and` change `rep0` to our desired value. Therefore, `pos` will be equal `-offset` and we could leak bytes from offset as a reference to the buffer pointer.\n\nAfter reading the `match_byte`, we will get to this flow:\n\nAs long as the bits match our match\_byte (the leaked byte), it will be in the loop that reads the probability from `prob + 0x100 + bit + mi`, but once one bit is not matched, it reads it from `prob + mi`. We can detect what was the first unmatched bit, by checking if `prob + mi` was changed by writing more literal bytes, or if the probability was changed and we got a different output. Finally, the leaked bits will get flushed to the decompressed buffer.\n\nAlthough the vulnerability was found in the LZMA decompression algorithm, we found that many applets support an LZMA compression and will try to decompress encoded LZMA streams by default\n\nApplies if the attacker can supply a crafted compressed file, that will be decompressed by using `unlzma`.\n\nNote that even if the unlzma applet is not available, but `CONFIG_FEATURE_SEAMLESS_LZMA` (enabled by default) is enabled, other applets such as `tar`, `unzip`, `rpm`, `dpkg,lzma` and `man` can also reach the vulnerable code when handling a file with the `.lzma` filename suffix.",
      "root_cause": "Insufficient size check in the `unpack_lzma_stream` function when state >= `LZMA_NUM_LIT_STATES`.",
      "vulnerabilities": [
        "Out-of-bounds heap read"
      ],
      "impact": "Information leak and denial of service.",
      "attack_vectors": [
        "Crafted LZMA-compressed input",
        "ZIP files using LZMA compression"
      ],
      "required_capabilities": "Attacker needs to supply a crafted compressed file, that will be decompressed by using `unlzma`."
    }
  }
}
```