=== Content from github.com_346f3300_20250115_093205.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRavenProject%2FRavencoin%2Fblob%2Fmaster%2Fsrc%2Fwallet%2Fwallet.cpp)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRavenProject%2FRavencoin%2Fblob%2Fmaster%2Fsrc%2Fwallet%2Fwallet.cpp)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=RavenProject%2FRavencoin)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RavenProject](/RavenProject)
/
**[Ravencoin](/RavenProject/Ravencoin)**
Public

* [Notifications](/login?return_to=%2FRavenProject%2FRavencoin) You must be signed in to change notification settings
* [Fork
  682](/login?return_to=%2FRavenProject%2FRavencoin)
* [Star
   1.1k](/login?return_to=%2FRavenProject%2FRavencoin)

* [Code](/RavenProject/Ravencoin)
* [Issues
  154](/RavenProject/Ravencoin/issues)
* [Pull requests
  23](/RavenProject/Ravencoin/pulls)
* [Actions](/RavenProject/Ravencoin/actions)
* [Projects
  0](/RavenProject/Ravencoin/projects)
* [Wiki](/RavenProject/Ravencoin/wiki)
* [Security](/RavenProject/Ravencoin/security)
* [Insights](/RavenProject/Ravencoin/pulse)

Additional navigation options

* [Code](/RavenProject/Ravencoin)
* [Issues](/RavenProject/Ravencoin/issues)
* [Pull requests](/RavenProject/Ravencoin/pulls)
* [Actions](/RavenProject/Ravencoin/actions)
* [Projects](/RavenProject/Ravencoin/projects)
* [Wiki](/RavenProject/Ravencoin/wiki)
* [Security](/RavenProject/Ravencoin/security)
* [Insights](/RavenProject/Ravencoin/pulse)

## Files

 master
## Breadcrumbs

1. [Ravencoin](/RavenProject/Ravencoin/tree/master)
2. /[src](/RavenProject/Ravencoin/tree/master/src)
3. /[wallet](/RavenProject/Ravencoin/tree/master/src/wallet)
/
# wallet.cpp

Copy path Blame  Blame
## Latest commit

## History

[History](/RavenProject/Ravencoin/commits/master/src/wallet/wallet.cpp)4998 lines (4256 loc) · 183 KB master
## Breadcrumbs

1. [Ravencoin](/RavenProject/Ravencoin/tree/master)
2. /[src](/RavenProject/Ravencoin/tree/master/src)
3. /[wallet](/RavenProject/Ravencoin/tree/master/src/wallet)
/
# wallet.cpp

Top
## File metadata and controls

* Code
* Blame

4998 lines (4256 loc) · 183 KB[Raw](https://github.com/RavenProject/Ravencoin/raw/refs/heads/master/src/wallet/wallet.cpp)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000// Copyright (c) 2009-2010 Satoshi Nakamoto// Copyright (c) 2009-2016 The Bitcoin Core developers// Copyright (c) 2017-2021 The Raven Core developers// Distributed under the MIT software license, see the accompanying// file COPYING or http://www.opensource.org/licenses/mit-license.php.
#include "wallet/wallet.h"
#include "base58.h"#include "checkpoints.h"#include "chain.h"#include "wallet/coincontrol.h"#include "consensus/consensus.h"#include "consensus/validation.h"#include "fs.h"#include "init.h"#include "key.h"#include "keystore.h"#include "validation.h"#include "net.h"#include "policy/fees.h"#include "policy/policy.h"#include "policy/rbf.h"#include "primitives/block.h"#include "primitives/transaction.h"#include "script/script.h"#include "script/sign.h"#include "scheduler.h"#include "timedata.h"#include "txmempool.h"#include "util.h"#include "ui\_interface.h"#include "utilmoneystr.h"#include "wallet/fees.h"#include "wallet/bip39.h"
#include <assert.h>
#include <boost/algorithm/string/replace.hpp>#include <boost/thread.hpp>#include <random>#include <tinyformat.h>
#include "assets/assets.h"
std::vector<CWalletRef> vpwallets;/\*\* Transaction fee set by the user \*/CFeeRate payTxFee(DEFAULT\_TRANSACTION\_FEE);unsigned int nTxConfirmTarget = DEFAULT\_TX\_CONFIRM\_TARGET;bool bSpendZeroConfChange = DEFAULT\_SPEND\_ZEROCONF\_CHANGE;bool fWalletRbf = DEFAULT\_WALLET\_RBF;
const char \* DEFAULT\_WALLET\_DAT = "wallet.dat";const uint32\_t BIP32\_HARDENED\_KEY\_LIMIT = 0x80000000;
std::string my\_words;std::string my\_passphrase;
/\*\* \* Fees smaller than this (in satoshi) are considered zero fee (for transaction creation) \* Override with -mintxfee \*/CFeeRate CWallet::minTxFee = CFeeRate(DEFAULT\_TRANSACTION\_MINFEE);/\*\* \* If fee estimation does not have enough data to provide estimates, use this fee instead. \* Has no effect if not using fee estimation \* Override with -fallbackfee \*/CFeeRate CWallet::fallbackFee = CFeeRate(DEFAULT\_FALLBACK\_FEE);
CFeeRate CWallet::m\_discard\_rate = CFeeRate(DEFAULT\_DISCARD\_FEE);
const uint256 CMerkleTx::ABANDON\_HASH(uint256S("0000000000000000000000000000000000000000000000000000000000000001"));
/\*\* @defgroup mapWallet \* \* @{ \*/
struct CompareValueOnly{ bool operator()(const CInputCoin& t1, const CInputCoin& t2) const { return t1.txout.nValue < t2.txout.nValue; }};
struct CompareAssetValueOnly{ bool operator()(const std::pair<CInputCoin, CAmount>& t1, const std::pair<CInputCoin, CAmount>& t2) const { return t1.second < t2.second; }};
std::string COutput::ToString() const{ return strprintf("COutput(%s, %d, %d) [%s]", tx->GetHash().ToString(), i, nDepth, FormatMoney(tx->tx->vout[i].nValue));}
class CAffectedKeysVisitor : public boost::static\_visitor<void> {private: const CKeyStore &keystore; std::vector<CKeyID> &vKeys;
public: CAffectedKeysVisitor(const CKeyStore &keystoreIn, std::vector<CKeyID> &vKeysIn) : keystore(keystoreIn), vKeys(vKeysIn) {}
 void Process(const CScript &script) { txnouttype type; std::vector<CTxDestination> vDest; int nRequired; if (ExtractDestinations(script, type, vDest, nRequired)) { for (const CTxDestination &dest : vDest) boost::apply\_visitor(\*this, dest); } }
 void operator()(const CKeyID &keyId) { if (keystore.HaveKey(keyId)) vKeys.push\_back(keyId); }
 void operator()(const CScriptID &scriptId) { CScript script; if (keystore.GetCScript(scriptId, script)) Process(script); }
 void operator()(const CNoDestination &none) {}};
const CWalletTx\* CWallet::GetWalletTx(const uint256& hash) const{ LOCK(cs\_wallet); std::map<uint256, CWalletTx>::const\_iterator it = mapWallet.find(hash); if (it == mapWallet.end()) return nullptr; return &(it->second);}
CPubKey CWallet::GenerateNewKey(CWalletDB &walletdb, bool internal){ AssertLockHeld(cs\_wallet); // mapKeyMetadata bool fCompressed = CanSupportFeature(FEATURE\_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets
 CKey secret;
 // Create new metadata int64\_t nCreationTime = GetTime(); CKeyMetadata metadata(nCreationTime);
 // use HD key derivation if HD was enabled during wallet creation if (IsHDEnabled()) { DeriveNewChildKey(walletdb, metadata, secret, (CanSupportFeature(FEATURE\_HD\_SPLIT) ? internal : false)); } else { secret.MakeNewKey(fCompressed); }
 // Compressed public keys were introduced in version 0.6.0 if (fCompressed) { SetMinVersion(FEATURE\_COMPRPUBKEY); }
 CPubKey pubkey = secret.GetPubKey(); assert(secret.VerifyPubKey(pubkey));
 mapKeyMetadata[pubkey.GetID()] = metadata; UpdateTimeFirstKey(nCreationTime);
 if (!AddKeyPubKeyWithDB(walletdb, secret, pubkey)) { throw std::runtime\_error(std::string(\_\_func\_\_) + ": AddKey failed"); } return pubkey;}
void CWallet::DeriveNewChildKey(CWalletDB &walletdb, CKeyMetadata& metadata, CKey& secret, bool internal){ // for now we use a fixed keypath scheme of m/0'/0'/k CExtKey masterKey; //hd master key
 CExtKey purposeKey; //key at m/purpose' CExtKey coinTypeKey; //key at m/purpose'/coin\_type'
 CExtKey accountKey; //key at m/0' CExtKey chainChildKey; //key at m/0'/0' (external) or m/0'/1' (internal) CExtKey childKey; //key at m/0'/0'/<n>'
 uint32\_t nAccountIndex = 0; // TODO add HDAccounts management
 // try to get the seed if (!hdChain.IsBip44()) { CKey seed; //seed (256bit) if (!GetKey(hdChain.seed\_id, seed)) throw std::runtime\_error(std::string(\_\_func\_\_) + ": seed not found"); masterKey.SetSeed(seed.begin(), seed.size()); } else { masterKey.SetSeed(g\_vchSeed.data(), g\_vchSeed.size()); }
 // Select which chain we are using depending on if this is a change address or not uint32\_t& nChildIndex = internal ? hdChain.nInternalChainCounter : hdChain.nExternalChainCounter;
 do {
 if(hdChain.IsBip44()) { // Use BIP44 keypath scheme i.e. m / purpose' / coin\_type' / account' / change / address\_index
 // derive m/purpose' masterKey.Derive(purposeKey, 44 | BIP32\_HARDENED\_KEY\_LIMIT); // derive m/purpose'/coin\_type' purposeKey.Derive(coinTypeKey, GetParams().ExtCoinType() | BIP32\_HARDENED\_KEY\_LIMIT); // derive m/purpose'/coin\_type'/account' coinTypeKey.Derive(accountKey, nAccountIndex | BIP32\_HARDENED\_KEY\_LIMIT); // derive m/purpose'/coin\_type'/account'/change accountKey.Derive(chainChildKey, internal ? 1 : 0); // derive m/purpose'/coin\_type'/account'/change/address\_index chainChildKey.Derive(childKey, nChildIndex); } else { // Use BIP32 keypath scheme i.e. m / account' / change' / address\_index'
 // derive m/account' masterKey.Derive(accountKey, nAccountIndex | BIP32\_HARDENED\_KEY\_LIMIT); // derive m/account'/change accountKey.Derive(chainChildKey, BIP32\_HARDENED\_KEY\_LIMIT + (internal ? 1 : 0)); // derive m/account'/change/address\_index chainChildKey.Derive(childKey, BIP32\_HARDENED\_KEY\_LIMIT | nChildIndex); }
 // increment childkey index nChildIndex++; } while (HaveKey(childKey.key.GetPubKey().GetID()));
 secret = childKey.key;
 if(hdChain.IsBip44()) metadata.hdKeypath = strprintf("m/44'/%d'/%d'/%d/%d", GetParams().ExtCoinType(), nAccountIndex, internal, nChildIndex - 1); else metadata.hdKeypath = strprintf("m/%d'/%d'/%d'", nAccountIndex, internal, nChildIndex - 1);
 metadata.hd\_seed\_id = hdChain.seed\_id;
 // update the chain model in the database if (!walletdb.WriteHDChain(hdChain)) throw std::runtime\_error(std::string(\_\_func\_\_) + ": Writing HD chain model failed");
}
bool CWallet::AddKeyPubKeyWithDB(CWalletDB &walletdb, const CKey& secret, const CPubKey &pubkey){ AssertLockHeld(cs\_wallet); // mapKeyMetadata
 // CCryptoKeyStore has no concept of wallet databases, but calls AddCryptedKey // which is overridden below. To avoid flushes, the database handle is // tunneled through to it. bool needsDB = !pwalletdbEncryption; if (needsDB) { pwalletdbEncryption = &walletdb; } if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey)) { if (needsDB) pwalletdbEncryption = nullptr; return false; } if (needsDB) pwalletdbEncryption = nullptr;
 // check if we need to remove from watch-only CScript script; script = GetScriptForDestination(pubkey.GetID()); if (HaveWatchOnly(script)) { RemoveWatchOnly(script); } script = GetScriptForRawPubKey(pubkey); if (HaveWatchOnly(script)) { RemoveWatchOnly(script); }
 if (!IsCrypted()) { return walletdb.WriteKey(pubkey, secret.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]); } return true;}
bool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey){ CWalletDB walletdb(\*dbw); return CWallet::AddKeyPubKeyWithDB(walletdb, secret, pubkey);}
bool CWallet::AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret){ if (!CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret)) return false; { LOCK(cs\_wallet); if (pwalletdbEncryption) return pwalletdbEncryption->WriteCryptedKey(vchPubKey, vchCryptedSecret, mapKeyMetadata[vchPubKey.GetID()]); else return CWalletDB(\*dbw).WriteCryptedKey(vchPubKey, vchCryptedSecret, mapKeyMetadata[vchPubKey.GetID()]); }}
bool CWallet::LoadKeyMetadata(const CTxDestination& keyID, const CKeyMetadata &meta){ AssertLockHeld(cs\_wallet); // mapKeyMetadata UpdateTimeFirstKey(meta.nCreateTime); mapKeyMetadata[keyID] = meta; return true;}
bool CWallet::LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret){ return CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret);}
bool CWallet::LoadCryptedWords(const uint256& hash, const std::vector<unsigned char> &vchCryptedWords){ return CCryptoKeyStore::AddCryptedWords(hash, vchCryptedWords);}
bool CWallet::LoadCryptedPassphrase(const std::vector<unsigned char> &vchCryptedPassphrase){ return CCryptoKeyStore::AddCryptedPassphrase(vchCryptedPassphrase);}
bool CWallet::LoadCryptedVchSeed(const std::vector<unsigned char> &vchCryptedVchSeed){ return CCryptoKeyStore::AddCryptedVchSeed(vchCryptedVchSeed);}
bool CWallet::LoadWords(const uint256& hash, const std::vector<unsigned char> &vchWords){ return CCryptoKeyStore::AddWords(hash, vchWords);}
bool CWallet::LoadPassphrase(const std::vector<unsigned char> &vchPassphrase){ return CCryptoKeyStore::AddPassphrase(vchPassphrase);}
bool CWallet::LoadVchSeed(const std::vector<unsigned char> &vchSeed){ return CCryptoKeyStore::AddVchSeed(vchSeed);}
void CWallet::GetBip39Data(uint256& hash, std::vector<unsigned char> &vchWords, std::vector<unsigned char> &vchPassphrase, std::vector<unsigned char>& vchSeed){ CCryptoKeyStore::GetBip39Data(hash, vchWords, vchPassphrase, vchSeed);}
/\*\* \* Update wallet first key creation time. This should be called whenever keys \* are added to the wallet, with the oldest key creation time. \*/void CWallet::UpdateTimeFirstKey(int64\_t nCreateTime){ AssertLockHeld(cs\_wallet); if (nCreateTime <= 1) { // Cannot determine birthday information, so set the wallet birthday to // the beginning of time. nTimeFirstKey = 1; } else if (!nTimeFirstKey || nCreateTime < nTimeFirstKey) { nTimeFirstKey = nCreateTime; }}
bool CWallet::AddCScript(const CScript& redeemScript){ if (!CCryptoKeyStore::AddCScript(redeemScript)) return false; return CWalletDB(\*dbw).WriteCScript(Hash160(redeemScript), redeemScript);}
bool CWallet::LoadCScript(const CScript& redeemScript){ /\* A sanity check was added in pull #3843 to avoid adding redeemScripts \* that never can be redeemed. However, old wallets may still contain \* these. Do not add them to the wallet and warn. \*/ if (redeemScript.size() > MAX\_SCRIPT\_ELEMENT\_SIZE) { std::string strAddr = EncodeDestination(CScriptID(redeemScript)); LogPrintf("%s: Warning: This wallet contains a redeemScript of size %i which exceeds maximum size %i thus can never be redeemed. Do not use address %s.\n", \_\_func\_\_, redeemScript.size(), MAX\_SCRIPT\_ELEMENT\_SIZE, strAddr); return true; }
 return CCryptoKeyStore::AddCScript(redeemScript);}
bool CWallet::AddWatchOnly(const CScript& dest){ if (!CCryptoKeyStore::AddWatchOnly(dest)) return false; const CKeyMetadata& meta = mapKeyMetadata[CScriptID(dest)]; UpdateTimeFirstKey(meta.nCreateTime); NotifyWatchonlyChanged(true); return CWalletDB(\*dbw).WriteWatchOnly(dest, meta);}
bool CWallet::AddWatchOnly(const CScript& dest, int64\_t nCreateTime){ mapKeyMetadata[CScriptID(dest)].nCreateTime = nCreateTime; return AddWatchOnly(dest);}
bool CWallet::RemoveWatchOnly(const CScript &dest){ AssertLockHeld(cs\_wallet); if (!CCryptoKeyStore::RemoveWatchOnly(dest)) return false; if (!HaveWatchOnly()) NotifyWatchonlyChanged(false); if (!CWalletDB(\*dbw).EraseWatchOnly(dest)) return false;
 return true;}
bool CWallet::LoadWatchOnly(const CScript &dest){ return CCryptoKeyStore::AddWatchOnly(dest);}
bool CWallet::Unlock(const SecureString& strWalletPassphrase){ CCrypter crypter; CKeyingMaterial \_vMasterKey;
 { LOCK(cs\_wallet); for (const MasterKeyMap::value\_type& pMasterKey : mapMasterKeys) { if(!crypter.SetKeyFromPassphrase(strWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod)) return false; if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, \_vMasterKey)) continue; // try another master key if (CCryptoKeyStore::Unlock(\_vMasterKey)) { return true; } } } return false;}
bool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase, const SecureString& strNewWalletPassphrase){ bool fWasLocked = IsLocked();
 { LOCK(cs\_wallet); Lock();
 CCrypter crypter; CKeyingMaterial \_vMasterKey; for (MasterKeyMap::value\_type& pMasterKey : mapMasterKeys) { if(!crypter.SetKeyFromPassphrase(strOldWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod)) return false; if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, \_vMasterKey)) return false; if (CCryptoKeyStore::Unlock(\_vMasterKey)) { int64\_t nStartTime = GetTimeMillis(); crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod); pMasterKey.second.nDeriveIterations = static\_cast<unsigned int>(pMasterKey.second.nDeriveIterations \* (100 / ((double)(GetTimeMillis() - nStartTime))));
 nStartTime = GetTimeMillis(); crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod); pMasterKey.second.nDeriveIterations = (pMasterKey.second.nDeriveIterations + static\_cast<unsigned int>(pMasterKey.second.nDeriveIterations \* 100 / ((double)(GetTimeMillis() - nStartTime)))) / 2;
 if (pMasterKey.second.nDeriveIterations < 25000) pMasterKey.second.nDeriveIterations = 25000;
 LogPrintf("Wallet passphrase changed to an nDeriveIterations of %i\n", pMasterKey.second.nDeriveIterations);
 if (!crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod)) return false; if (!crypter.Encrypt(\_vMasterKey, pMasterKey.second.vchCryptedKey)) return false; CWalletDB(\*dbw).WriteMasterKey(pMasterKey.first, pMasterKey.second); if (fWasLocked) Lock(); return true; } } }
 return false;}
void CWallet::SetBestChain(const CBlockLocator& loc){ CWalletDB walletdb(\*dbw); walletdb.WriteBestBlock(loc);}
bool CWallet::SetMinVersion(enum WalletFeature nVersion, CWalletDB\* pwalletdbIn, bool fExplicit){ LOCK(cs\_wallet); // nWalletVersion if (nWalletVersion >= nVersion) return true;
 // when doing an explicit upgrade, if we pass the max version permitted, upgrade all the way if (fExplicit && nVersion > nWalletMaxVersion) nVersion = FEATURE\_LATEST;
 nWalletVersion = nVersion;
 if (nVersion > nWalletMaxVersion) nWalletMaxVersion = nVersion;
 { CWalletDB\* pwalletdb = pwalletdbIn ? pwalletdbIn : new CWalletDB(\*dbw); if (nWalletVersion > 40000) pwalletdb->WriteMinVersion(nWalletVersion); if (!pwalletdbIn) delete pwalletdb; }
 return true;}
bool CWallet::SetMaxVersion(int nVersion){ LOCK(cs\_wallet); // nWalletVersion, nWalletMaxVersion // cannot downgrade below current version if (nWalletVersion > nVersion) return false;
 nWalletMaxVersion = nVersion;
 return true;}
std::set<uint256> CWallet::GetConflicts(const uint256& txid) const{ std::set<uint256> result; AssertLockHeld(cs\_wallet);
 std::map<uint256, CWalletTx>::const\_iterator it = mapWallet.find(txid); if (it == mapWallet.end()) return result; const CWalletTx& wtx = it->second;
 std::pair<TxSpends::const\_iterator, TxSpends::const\_iterator> range;
 for (const CTxIn& txin : wtx.tx->vin) { if (mapTxSpends.count(txin.prevout) <= 1) continue; // No conflict if zero or one spends range = mapTxSpends.equal\_range(txin.prevout); for (TxSpends::const\_iterator \_it = range.first; \_it != range.second; ++\_it) result.insert(\_it->second); } return result;}
bool CWallet::HasWalletSpend(const uint256& txid) const{ AssertLockHeld(cs\_wallet); auto iter = mapTxSpends.lower\_bound(COutPoint(txid, 0)); return (iter != mapTxSpends.end() && iter->first.hash == txid);}
void CWallet::Flush(bool shutdown){ dbw->Flush(shutdown);}
void CWallet::SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator> range){ // We want all the wallet transactions in range to have the same metadata as // the oldest (smallest nOrderPos). // So: find smallest nOrderPos:
 int nMinOrderPos = std::numeric\_limits<int>::max(); const CWalletTx\* copyFrom = nullptr; for (TxSpends::iterator it = range.first; it != range.second; ++it) { const uint256& hash = it->second; int n = mapWallet[hash].nOrderPos; if (n < nMinOrderPos) { nMinOrderPos = n; copyFrom = &mapWallet[hash]; } } // Now copy data from copyFrom to rest: for (TxSpends::iterator it = range.first; it != range.second; ++it) { const uint256& hash = it->second; CWalletTx\* copyTo = &mapWallet[hash]; if (copyFrom == copyTo) continue; assert(copyFrom && "Oldest wallet transaction in range assumed to have been found."); if (!copyFrom->IsEquivalentTo(\*copyTo)) continue; copyTo->mapValue = copyFrom->mapValue; copyTo->vOrderForm = copyFrom->vOrderForm; // fTimeReceivedIsTxTime not copied on purpose // nTimeReceived not copied on purpose copyTo->nTimeSmart = copyFrom->nTimeSmart; copyTo->fFromMe = copyFrom->fFromMe; copyTo->strFromAccount = copyFrom->strFromAccount; // nOrderPos not copied on purpose // cached members not copied on purpose }}
/\*\* \* Outpoint is spent if any non-conflicted transaction \* spends it: \*/bool CWallet::IsSpent(const uint256& hash, unsigned int n) const{ const COutPoint outpoint(hash, n); std::pair<TxSpends::const\_iterator, TxSpends::const\_iterator> range; range = mapTxSpends.equal\_range(outpoint);
 for (TxSpends::const\_iterator it = range.first; it != range.second; ++it) { const uint256& wtxid = it->second; std::map<uint256, CWalletTx>::const\_iterator mit = mapWallet.find(wtxid); if (mit != mapWallet.end()) { int depth = mit->second.GetDepthInMainChain(); if (depth > 0 || (depth == 0 && !mit->second.isAbandoned())) return true; // Spent } } return false;}
void CWallet::AddToSpends(const COutPoint& outpoint, const uint256& wtxid){ mapTxSpends.insert(std::make\_pair(outpoint, wtxid));
 std::pair<TxSpends::iterator, TxSpends::iterator> range; range = mapTxSpends.equal\_range(outpoint); SyncMetaData(range);}
void CWallet::AddToSpends(const uint256& wtxid){ auto it = mapWallet.find(wtxid); assert(it != mapWallet.end()); CWalletTx& thisTx = it->second; if (thisTx.IsCoinBase()) // Coinbases don't spend anything! return;
 for (const CTxIn& txin : thisTx.tx->vin) AddToSpends(txin.prevout, wtxid);}
bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase){ if (IsCrypted()) return false;
 CKeyingMaterial \_vMasterKey;
 \_vMasterKey.resize(WALLET\_CRYPTO\_KEY\_SIZE); GetStrongRandBytes(&\_vMasterKey[0], WALLET\_CRYPTO\_KEY\_SIZE);
 CMasterKey kMasterKey;
 kMasterKey.vchSalt.resize(WALLET\_CRYPTO\_SALT\_SIZE); GetStrongRandBytes(&kMasterKey.vchSalt[0], WALLET\_CRYPTO\_SALT\_SIZE);
 CCrypter crypter; int64\_t nStartTime = GetTimeMillis(); crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, 25000, kMasterKey.nDerivationMethod); kMasterKey.nDeriveIterations = static\_cast<unsigned int>(2500000 / ((double)(GetTimeMillis() - nStartTime)));
 nStartTime = GetTimeMillis(); crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod); kMasterKey.nDeriveIterations = (kMasterKey.nDeriveIterations + static\_cast<unsigned int>(kMasterKey.nDeriveIterations \* 100 / ((double)(GetTimeMillis() - nStartTime)))) / 2;
 if (kMasterKey.nDeriveIterations < 25000) kMasterKey.nDeriveIterations = 25000;
 LogPrintf("Encrypting Wallet with an nDeriveIterations of %i\n", kMasterKey.nDeriveIterations);
 if (!crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod)) return false; if (!crypter.Encrypt(\_vMasterKey, kMasterKey.vchCryptedKey)) return false;
 { LOCK(cs\_wallet); mapMasterKeys[++nMasterKeyMaxID] = kMasterKey; assert(!pwalletdbEncryption); pwalletdbEncryption = new CWalletDB(\*dbw); if (!pwalletdbEncryption->TxnBegin()) { delete pwalletdbEncryption; pwalletdbEncryption = nullptr; return false; } pwalletdbEncryption->WriteMasterKey(nMasterKeyMaxID, kMasterKey);
 if (!EncryptKeys(\_vMasterKey)) { pwalletdbEncryption->TxnAbort(); delete pwalletdbEncryption; // We now probably have half of our keys encrypted in memory, and half not... // die and let the user reload the unencrypted wallet. assert(false); }
 if(hdChain.IsBip44()) { pwalletdbEncryption->EraseBip39Words( false); pwalletdbEncryption->EraseBip39Passphrase(false); pwalletdbEncryption->EraseBip39VchSeed(false);
 if (!EncryptBip39(\_vMasterKey)) { pwalletdbEncryption->TxnAbort(); delete pwalletdbEncryption; // We now probably have half of our keys encrypted in memory, and half not... // die and let the user reload the unencrypted wallet. assert(false); }
 if (!pwalletdbEncryption->WriteBip39Words(nWordHash, vchCryptedBip39Words, true)) { pwalletdbEncryption->TxnAbort(); delete pwalletdbEncryption; assert(false); }
 if (!vchCryptedBip39Passphrase.empty()) { if (!pwalletdbEncryption->WriteBip39Passphrase(vchCryptedBip39Passphrase, true)) { pwalletdbEncryption->TxnAbort(); delete pwalletdbEncryption; assert(false); } }
 if (!vchCryptedBip39VchSeed.empty()) { if (!pwalletdbEncryption->WriteBip39VchSeed(vchCryptedBip39VchSeed, true)) { pwalletdbEncryption->TxnAbort(); delete pwalletdbEncryption; assert(false); } } }
 // Encryption was introduced in version 0.4.0 SetMinVersion(FEATURE\_WALLETCRYPT, pwalletdbEncryption, true);
 if (!pwalletdbEncryption->TxnCommit()) { delete pwalletdbEncryption; // We now have keys encrypted in memory, but not on disk... // die to avoid confusion and let the user reload the unencrypted wallet. assert(false); }
 delete pwalletdbEncryption; pwalletdbEncryption = nullptr;
 Lock(); Unlock(strWalletPassphrase);
 // if we are using HD, replace the HD seed with a new one if (IsHDEnabled() && !hdChain.IsBip44()) { if (!SetHDSeed(GenerateNewSeed())) { return false; } }
 if (!hdChain.IsBip44()) NewKeyPool();
 Lock();
 // Need to completely rewrite the wallet file; if we don't, bdb might keep // bits of the unencrypted private key in slack space in the database file. dbw->Rewrite();
 if (hdChain.IsBip44()) { CWalletDB walletdb(\*dbw); walletdb.WriteBip39Words(nWordHash, vchCryptedBip39Words, true); walletdb.WriteBip39VchSeed(vchCryptedBip39VchSeed, true); if (!vchCryptedBip39Passphrase.empty()) walletdb.WriteBip39Passphrase(vchCryptedBip39Passphrase, true); } } NotifyStatusChanged(this);
 return true;}
DBErrors CWallet::ReorderTransactions(){ LOCK(cs\_wallet); CWalletDB walletdb(\*dbw);
 // Old wallets didn't have any defined order for transactions // Probably a bad idea to change the output of this
 // First: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap. typedef std::pair<CWalletTx\*, CAccountingEntry\*> TxPair; typedef std::multimap<int64\_t, TxPair > TxItems; TxItems txByTime;
 for (std::map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) { CWalletTx\* wtx = &((\*it).second); txByTime.insert(std::make\_pair(wtx->nTimeReceived, TxPair(wtx, nullptr))); } std::list<CAccountingEntry> acentries; walletdb.ListAccountCreditDebit("", acentries); for (CAccountingEntry& entry : acentries) { txByTime.insert(std::make\_pair(entry.nTime, TxPair(nullptr, &entry))); }
 nOrderPosNext = 0; std::vector<int64\_t> nOrderPosOffsets; for (TxItems::iterator it = txByTime.begin(); it != txByTime.end(); ++it) { CWalletTx \*const pwtx = (\*it).second.first; CAccountingEntry \*const pacentry = (\*it).second.second; int64\_t& nOrderPos = (pwtx != nullptr) ? pwtx->nOrderPos : pacentry->nOrderPos;
 if (nOrderPos == -1) { nOrderPos = nOrderPosNext++; nOrderPosOffsets.push\_back(nOrderPos);
 if (pwtx) { if (!walletdb.WriteTx(\*pwtx)) return DB\_LOAD\_FAIL; } else if (!walletdb.WriteAccountingEntry(pacentry->nEntryNo, \*pacentry)) return DB\_LOAD\_FAIL; } else { int64\_t nOrderPosOff = 0; for (const int64\_t& nOffsetStart : nOrderPosOffsets) { if (nOrderPos >= nOffsetStart) ++nOrderPosOff; } nOrderPos += nOrderPosOff; nOrderPosNext = std::max(nOrderPosNext, nOrderPos + 1);
 if (!nOrderPosOff) continue;
 // Since we're changing the order, write it back if (pwtx) { if (!walletdb.WriteTx(\*pwtx)) return DB\_LOAD\_FAIL; } else if (!walletdb.WriteAccountingEntry(pacentry->nEntryNo, \*pacentry)) return DB\_LOAD\_FAIL; } } walletdb.WriteOrderPosNext(nOrderPosNext);
 return DB\_LOAD\_OK;}
int64\_t CWallet::IncOrderPosNext(CWalletDB \*pwalletdb){ AssertLockHeld(cs\_wallet); // nOrderPosNext int64\_t nRet = nOrderPosNext++; if (pwalletdb) { pwalletdb->WriteOrderPosNext(nOrderPosNext); } else { CWalletDB(\*dbw).WriteOrderPosNext(nOrderPosNext); } return nRet;}
bool CWallet::AccountMove(std::string strFrom, std::string strTo, CAmount nAmount, std::string strComment){ CWalletDB walletdb(\*dbw); if (!walletdb.TxnBegin()) return false;
 int64\_t nNow = GetAdjustedTime();
 // Debit CAccountingEntry debit; debit.nOrderPos = IncOrderPosNext(&walletdb); debit.strAccount = strFrom; debit.nCreditDebit = -nAmount; debit.nTime = nNow; debit.strOtherAccount = strTo; debit.strComment = strComment; AddAccountingEntry(debit, &walletdb);
 // Credit CAccountingEntry credit; credit.nOrderPos = IncOrderPosNext(&walletdb); credit.strAccount = strTo; credit.nCreditDebit = nAmount; credit.nTime = nNow; credit.strOtherAccount = strFrom; credit.strComment = strComment; AddAccountingEntry(credit, &walletdb);
 if (!walletdb.TxnCommit()) return false;
 return true;}
bool CWallet::GetAccountPubkey(CPubKey &pubKey, std::string strAccount, bool bForceNew){ CWalletDB walletdb(\*dbw);
 CAccount account; walletdb.ReadAccount(strAccount, account);
 if (!bForceNew) { if (!account.vchPubKey.IsValid()) bForceNew = true; else { // Check if the current key has been used CScript scriptPubKey = GetScriptForDestination(account.vchPubKey.GetID()); for (std::map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end() && account.vchPubKey.IsValid(); ++it) for (const CTxOut& txout : (\*it).second.tx->vout) if (txout.scriptPubKey == scriptPubKey) { bForceNew = true; break; } } }
 // Generate a new key if (bForceNew) { if (!GetKeyFromPool(account.vchPubKey, false)) return false;
 SetAddressBook(account.vchPubKey.GetID(), strAccount, "receive"); walletdb.WriteAccount(strAccount, account); }
 pubKey = account.vchPubKey;
 return true;}
void CWallet::MarkDirty(){ { LOCK(cs\_wallet); for (std::pair<const uint256, CWalletTx>& item : mapWallet) item.second.MarkDirty(); }}
bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash){ LOCK(cs\_wallet);
 auto mi = mapWallet.find(originalHash);
 // There is a bug if MarkReplaced is not called on an existing wallet transaction. assert(mi != mapWallet.end());
 CWalletTx& wtx = (\*mi).second;
 // Ensure for now that we're not overwriting data assert(wtx.mapValue.count("replaced\_by\_txid") == 0);
 wtx.mapValue["replaced\_by\_txid"] = newHash.ToString();
 CWalletDB walletdb(\*dbw, "r+");
 bool success = true; if (!walletdb.WriteTx(wtx)) { LogPrintf("%s: Updating walletdb tx %s failed", \_\_func\_\_, wtx.GetHash().ToString()); success = false; }
 NotifyTransactionChanged(this, originalHash, CT\_UPDATED);
 return success;}
[View remainder of file in raw view](https://github.com/RavenProject/Ravencoin/raw/refs/heads/master/src/wallet/wallet.cpp)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from ravencoin.com_d08010c9_20250115_093202.html ===


Redirecting to https://www.ravencoin.org/



=== Content from github.com_5457006b_20250115_093206.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRavenProject%2FRavencoin%2Fissues%2F1086)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRavenProject%2FRavencoin%2Fissues%2F1086)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fissues_fragments%2Fissue_layout&source=header-repo&source_repo=RavenProject%2FRavencoin)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RavenProject](/RavenProject)
/
**[Ravencoin](/RavenProject/Ravencoin)**
Public

* [Notifications](/login?return_to=%2FRavenProject%2FRavencoin) You must be signed in to change notification settings
* [Fork
  682](/login?return_to=%2FRavenProject%2FRavencoin)
* [Star
   1.1k](/login?return_to=%2FRavenProject%2FRavencoin)

* [Code](/RavenProject/Ravencoin)
* [Issues
  154](/RavenProject/Ravencoin/issues)
* [Pull requests
  23](/RavenProject/Ravencoin/pulls)
* [Actions](/RavenProject/Ravencoin/actions)
* [Projects
  0](/RavenProject/Ravencoin/projects)
* [Wiki](/RavenProject/Ravencoin/wiki)
* [Security](/RavenProject/Ravencoin/security)
* [Insights](/RavenProject/Ravencoin/pulse)

Additional navigation options

* [Code](/RavenProject/Ravencoin)
* [Issues](/RavenProject/Ravencoin/issues)
* [Pull requests](/RavenProject/Ravencoin/pulls)
* [Actions](/RavenProject/Ravencoin/actions)
* [Projects](/RavenProject/Ravencoin/projects)
* [Wiki](/RavenProject/Ravencoin/wiki)
* [Security](/RavenProject/Ravencoin/security)
* [Insights](/RavenProject/Ravencoin/pulse)

New issue

**Have a question about this project?** Sign up for a free GitHub account to open an issue and contact its maintainers and the community.

 [Sign up for GitHub](/signup?return_to=%2FRavenProject%2FRavencoin%2Fissues%2Fnew%2Fchoose)

By clicking “Sign up for GitHub”, you agree to our [terms of service](https://docs.github.com/terms) and
[privacy statement](https://docs.github.com/privacy). We’ll occasionally send you account related emails.

Already on GitHub?
[Sign in](/login?return_to=%2FRavenProject%2FRavencoin%2Fissues%2Fnew%2Fchoose)
to your account

[Jump to bottom](#issue-comment-box)

# Possible privacy leakage due to ordered transaction inputs #1086

Open

[yixiao5428](/yixiao5428) opened this issue
Jul 17, 2021
· 3 comments

Open

# [Possible privacy leakage due to ordered transaction inputs](#top) #1086

[yixiao5428](/yixiao5428) opened this issue
Jul 17, 2021
· 3 comments

Assignees
[![@fdoving](https://avatars.githubusercontent.com/u/26197922?s=40&v=4)](/fdoving)

Labels
[enhancement](/RavenProject/Ravencoin/labels/enhancement)
[security related](/RavenProject/Ravencoin/labels/security%20related)

## Comments

[![@yixiao5428](https://avatars.githubusercontent.com/u/17737552?s=80&u=90f66bdf391cc8b8e6c7d46309cb7ec4cde04866&v=4)](/yixiao5428)

Copy link

### **[yixiao5428](/yixiao5428)** commented [Jul 17, 2021](#issue-946778585)

| This a security vulnerability.  The wallet uses ordered inputs of transactions (`src/wallet/wallet.cpp`, [line 3657 - 3671](https://github.com/RavenProject/Ravencoin/blob/master/src/wallet/wallet.cpp#L3657-L3671)), which may incur privacy risks like fingerprinting the wallet to observers.  A possible solution is to clear the original order, shuffle it, and push back the new order before signing the transaction.  Similar fix from Bitcoin: [bitcoin/bitcoin@2fb9c1e](https://github.com/bitcoin/bitcoin/commit/2fb9c1e6681370478e24a19172ed6d78d95d50d3).  Reported by `6004ed5feaa31ae9df36b5dbc60f0fa53255a5fb734334082c6d202405fc738c`. |
| --- |
| The text was updated successfully, but these errors were encountered: |

All reactions

[![@m4r1m0](https://avatars.githubusercontent.com/u/83238270?s=80&u=d36d22a74a20acd926a8442ca715655d2d560333&v=4)](/m4r1m0)

Copy link

Contributor

### **[m4r1m0](/m4r1m0)** commented [Jul 17, 2021](#issuecomment-881915637)

| Great catch! Following this issue. |
| --- |

All reactions

Sorry, something went wrong.

[![@jeroz1](https://avatars.githubusercontent.com/u/44138303?s=80&u=86abb3ffaa4c7bf052f285274045240795f79429&v=4)](/jeroz1)

Copy link

Contributor

### **[jeroz1](/jeroz1)** commented [Jul 17, 2021](#issuecomment-881925225)

| If this is going to be fixed: make sure it doesn’t clash with the new asset transaction order. Or the reissue transactions. |
| --- |

All reactions

Sorry, something went wrong.

[![@kralverde](https://avatars.githubusercontent.com/u/80051564?s=80&v=4)](/kralverde)

Copy link

Contributor

### **[kralverde](/kralverde)** commented [Jul 17, 2021](#issuecomment-881927246)

| If i'm understanding correctly, this has to do with VINs not VOUTs; the special asset order should not be affected [@jeroz1](https://github.com/jeroz1) |
| --- |

All reactions

Sorry, something went wrong.

[![@HyperPeek](https://avatars.githubusercontent.com/u/21068858?s=40&u=9849c29914936864c7605df959f4e3c80eafaba4&v=4)](/HyperPeek)
[HyperPeek](/HyperPeek)
added
[enhancement](/RavenProject/Ravencoin/labels/enhancement)
[security related](/RavenProject/Ravencoin/labels/security%20related)
labels
[Jul 28, 2021](#event-5081405139)

[![@fdoving](https://avatars.githubusercontent.com/u/26197922?s=40&v=4)](/fdoving)
[fdoving](/fdoving)
self-assigned this
[Dec 6, 2021](#event-5723185796)

[![@fdoving](https://avatars.githubusercontent.com/u/26197922?s=40&v=4)](/fdoving)
[fdoving](/fdoving)
modified the milestone:
[4.7.0](/RavenProject/Ravencoin/milestone/1)
[Dec 6, 2021](#event-5723186042)

[Sign up for free](/join?source=comment-repo)
**to join this conversation on GitHub**.
Already have an account?
[Sign in to comment](/login?return_to=https%3A%2F%2Fgithub.com%2FRavenProject%2FRavencoin%2Fissues%2F1086)

Assignees

[![@fdoving](https://avatars.githubusercontent.com/u/26197922?s=40&v=4)](/fdoving) [fdoving](/fdoving)

Labels

[enhancement](/RavenProject/Ravencoin/labels/enhancement)
[security related](/RavenProject/Ravencoin/labels/security%20related)

Projects

None yet

Milestone

No milestone

Development

No branches or pull requests

6 participants

[![@yixiao5428](https://avatars.githubusercontent.com/u/17737552?s=52&v=4)](/yixiao5428) [![@HyperPeek](https://avatars.githubusercontent.com/u/21068858?s=52&v=4)](/HyperPeek) [![@fdoving](https://avatars.githubusercontent.com/u/26197922?s=52&v=4)](/fdoving) [![@jeroz1](https://avatars.githubusercontent.com/u/44138303?s=52&v=4)](/jeroz1) [![@kralverde](https://avatars.githubusercontent.com/u/80051564?s=52&v=4)](/kralverde) [![@m4r1m0](https://avatars.githubusercontent.com/u/83238270?s=52&v=4)](/m4r1m0)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_6cc18c67_20250115_093207.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fbitcoin%2Fbitcoin%2Fcommit%2F2fb9c1e6681370478e24a19172ed6d78d95d50d3)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fbitcoin%2Fbitcoin%2Fcommit%2F2fb9c1e6681370478e24a19172ed6d78d95d50d3)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fcommit_fragments%2Frepo_layout&source=header-repo&source_repo=bitcoin%2Fbitcoin)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[bitcoin](/bitcoin)
/
**[bitcoin](/bitcoin/bitcoin)**
Public

* [Notifications](/login?return_to=%2Fbitcoin%2Fbitcoin) You must be signed in to change notification settings
* [Fork
  36.5k](/login?return_to=%2Fbitcoin%2Fbitcoin)
* [Star
   81.4k](/login?return_to=%2Fbitcoin%2Fbitcoin)

* [Code](/bitcoin/bitcoin)
* [Issues
  375](/bitcoin/bitcoin/issues)
* [Pull requests
  322](/bitcoin/bitcoin/pulls)
* [Actions](/bitcoin/bitcoin/actions)
* [Projects
  5](/bitcoin/bitcoin/projects)
* [Security](/bitcoin/bitcoin/security)
* [Insights](/bitcoin/bitcoin/pulse)

Additional navigation options

* [Code](/bitcoin/bitcoin)
* [Issues](/bitcoin/bitcoin/issues)
* [Pull requests](/bitcoin/bitcoin/pulls)
* [Actions](/bitcoin/bitcoin/actions)
* [Projects](/bitcoin/bitcoin/projects)
* [Security](/bitcoin/bitcoin/security)
* [Insights](/bitcoin/bitcoin/pulse)

## Commit

[Permalink](/bitcoin/bitcoin/commit/2fb9c1e6681370478e24a19172ed6d78d95d50d3)

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

shuffle selected coins before transaction finalization

[Browse files](/bitcoin/bitcoin/tree/2fb9c1e6681370478e24a19172ed6d78d95d50d3)
Browse the repository at this point in the history

* Loading branch information

[![@instagibbs](https://avatars.githubusercontent.com/u/5767891?s=40&v=4)](/instagibbs)

[instagibbs](/bitcoin/bitcoin/commits?author=instagibbs "View all commits by instagibbs")
committed
Mar 21, 2018

1 parent
[1ec1602](/bitcoin/bitcoin/commit/1ec1602a4549f6b68586cead8eff701bceb624f5)

commit 2fb9c1e

Showing
**1 changed file**
with
**23 additions**
and
**14 deletions**.

* Whitespace
* Ignore whitespace

* Split
* Unified

## There are no files selected for viewing

37 changes: 23 additions & 14 deletions

37
[src/wallet/wallet.cpp](#diff-1f2db0e4d5c12d109c7f0962333c245b49b696cb39ff432da048e9d6c08944d8 "src/wallet/wallet.cpp")

Show comments

[View file](/bitcoin/bitcoin/blob/2fb9c1e6681370478e24a19172ed6d78d95d50d3/src/wallet/wallet.cpp)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -2889,20 +2889,11 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac |
|  |  | nChangePosInOut = -1; |
|  |  | } |
|  |  |  |
|  |  | // Fill vin |
|  |  | // Dummy fill vin for maximum size estimation |
|  |  | // |
|  |  | // Note how the sequence number is set to non-maxint so that |
|  |  | // the nLockTime set above actually works. |
|  |  | // |
|  |  | // BIP125 defines opt-in RBF as any nSequence < maxint-1, so |
|  |  | // we use the highest possible value in that range (maxint-2) |
|  |  | // to avoid conflicting with other possible uses of nSequence, |
|  |  | // and in the spirit of "smallest possible change from prior |
|  |  | // behavior." |
|  |  | const uint32\_t nSequence = coin\_control.signalRbf ? MAX\_BIP125\_RBF\_SEQUENCE : (CTxIn::SEQUENCE\_FINAL - 1); |
|  |  | for (const auto& coin : setCoins) |
|  |  | txNew.vin.push\_back(CTxIn(coin.outpoint,CScript(), |
|  |  | nSequence)); |
|  |  | for (const auto& coin : setCoins) { |
|  |  | txNew.vin.push\_back(CTxIn(coin.outpoint,CScript())); |
|  |  | } |
|  |  |  |
|  |  | nBytes = CalculateMaximumSignedTxSize(txNew, this); |
|  |  | if (nBytes < 0) { |
| Expand Down  Expand Up | | @@ -2992,11 +2983,29 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac |
|  |  |  |
|  |  | if (nChangePosInOut == -1) reservekey.ReturnKey(); // Return any reserved key if we don't have change |
|  |  |  |
|  |  | // Shuffle selected coins and fill in final vin |
|  |  | txNew.vin.clear(); |
|  |  | std::vector<CInputCoin> selected\_coins(setCoins.begin(), setCoins.end()); |
|  |  | std::shuffle(selected\_coins.begin(), selected\_coins.end(), FastRandomContext()); |
|  |  |  |
|  |  | // Note how the sequence number is set to non-maxint so that |
|  |  | // the nLockTime set above actually works. |
|  |  | // |
|  |  | // BIP125 defines opt-in RBF as any nSequence < maxint-1, so |
|  |  | // we use the highest possible value in that range (maxint-2) |
|  |  | // to avoid conflicting with other possible uses of nSequence, |
|  |  | // and in the spirit of "smallest possible change from prior |
|  |  | // behavior." |
|  |  | const uint32\_t nSequence = coin\_control.signalRbf ? MAX\_BIP125\_RBF\_SEQUENCE : (CTxIn::SEQUENCE\_FINAL - 1); |
|  |  | for (const auto& coin : selected\_coins) { |
|  |  | txNew.vin.push\_back(CTxIn(coin.outpoint, CScript(), nSequence)); |
|  |  | } |
|  |  |  |
|  |  | if (sign) |
|  |  | { |
|  |  | CTransaction txNewConst(txNew); |
|  |  | int nIn = 0; |
|  |  | for (const auto& coin : setCoins) |
|  |  | for (const auto& coin : selected\_coins) |
|  |  | { |
|  |  | const CScript& scriptPubKey = coin.txout.scriptPubKey; |
|  |  | SignatureData sigdata; |
| Expand Down | |  |

Toggle all file notes
Toggle all file annotations

### 0 comments on commit `2fb9c1e`

Please
[sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fbitcoin%2Fbitcoin%2Fcommit%2F2fb9c1e6681370478e24a19172ed6d78d95d50d3) to comment.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


