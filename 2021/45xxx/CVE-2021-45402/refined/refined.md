```
{
  "cve": "CVE-2021-45402",
  "affected_versions": [
    "Linux Kernel"
  ],
  "description": "The provided content describes a vulnerability in the Linux Kernel's BPF verifier related to signed bounds propagation during 32-bit to 64-bit register moves. The issue arises in how the verifier handles the propagation of signed 32-bit bounds to their 64-bit counterparts. Specifically, when both the s32_min_value and s32_max_value are positive, the __reg_assign_32_into_64() function directly propagates them to 64-bit registers. However, this doesn't always happen. For example, a mov32 operation calls zext_32_to_64(dst_reg) which invokes __reg_assign_32_into_64() without any subsequent bounds update. This can lead to overly pessimistic bounds when the full register state is dumped.",
    "vulnerability_details": {
        "root_cause": "The root cause is a flaw in the BPF verifier's logic for propagating signed 32-bit register bounds to 64-bit registers during mov32 operations. The function `__reg_assign_32_into_64` doesn't consistently update bounds, leading to incorrect assumptions about constant scalar values.",
        "weaknesses": [
           "Incorrect signed bounds propagation during 32-bit to 64-bit register moves.",
           "Lack of consistent bounds updates in `__reg_assign_32_into_64` after a mov32 operation.",
           "Failure to maintain the invariant that `smin_value == smax_value` and `umin_value == umax_value` for const scalars."
        ],
        "impact": "Without the correct `smin_value == smax_value` and `umin_value == umax_value` invariant for constant scalars, it is possible to leak kernel pointers from unprivileged user space. When such registers are involved in pointer arithmetic, `adjust_ptr_min_max_vals()` may taint the destination register into an unknown scalar. This scalar can then be exported and stored, e.g., into a BPF map value, potentially leaking kernel addresses.",
        "attack_vectors": [
          "The vulnerability can be exploited by crafting a malicious BPF program that performs a mov32 operation that doesn't update bounds which results in a register holding a kernel pointer.",
           "The malicious program must then trigger pointer arithmetic on a register where the bounds have not been updated correctly and export it."
        ],
       "required_capabilities": "An attacker needs the ability to load and execute BPF programs. Unprivileged users can trigger this if the relevant system configuration allows it."
    },
  "patch": "The patch addresses the issue by ensuring that bounds are properly updated after a 32-bit to 64-bit register move. The fix includes calls to `__update_reg_bounds()`, `__reg_deduce_bounds()`, and `__reg_bound_offset()` after the `zext_32_to_64(dst_reg)` call in `check_alu_op`. Additionally, the bounds propagation logic in `__reg_assign_32_into_64()` is made more robust by handling the smin/smax pair consistently."
}
```