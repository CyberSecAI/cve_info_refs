```
{
  "CVE-2021-39802": {
    "related_content": [
      {
        "type": "commit message",
        "content": "In the Scudo memory allocator [1] we would like to be able to detect use-after-free vulnerabilities involving large allocations by issuing mprotect(PROT_NONE) on the memory region used for the allocation when it is deallocated. Later on, after the memory region has been \"quarantined\" for a sufficient period of time we would like to be able to use it for another allocation by issuing mprotect(PROT_READ|PROT_WRITE).\n\nBefore this patch, after removing the write protection, any writes to the memory region would result in page faults and entering the copy-on-write code path, even in the usual case where the pages are only referenced by a single PTE, harming performance unnecessarily. Make it so that any pages in anonymous mappings that are only referenced by a single PTE are immediately made writable during the mprotect so that we can avoid the page faults.\n\nThis program shows the critical syscall sequence that we intend to use in the allocator:\n\n  #include <string.h>\n  #include <sys/mman.h>\n\n  enum { kSize = 131072 };\n\n  int main(int argc, char **argv) {\n    char *addr = (char *)mmap(0, kSize, PROT_READ | PROT_WRITE,\n                             MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n    for (int i = 0; i != 100000; ++i) {\n      memset(addr, i, kSize);\n      mprotect((void *)addr, kSize, PROT_NONE);\n      mprotect((void *)addr, kSize, PROT_READ | PROT_WRITE);\n    }\n  }\n\nThe effect of this patch on the above program was measured on a\nDragonBoard 845c by taking the median real time execution time of 10 runs.\n\nBefore: 2.94s\nAfter:  0.66s\n\nThe effect was also measured using one of the microbenchmarks that we\nnormally use to benchmark the allocator [2], after modifying it to make\nthe appropriate mprotect calls [3]. With an allocation size of 131072\nbytes to trigger the allocator's \"large allocation\" code path the\nper-iteration time was measured as follows:\n\nBefore: 27450ns\nAfter:   6010ns\n\nThis patch means that we do more work during the mprotect call itself in\nexchange for less work when the pages are accessed.  In the worst case,\nthe pages are not accessed at all.  The effect of this patch in such cases\nwas measured using the following program:\n\n  #include <string.h>\n  #include <sys/mman.h>\n\n  enum { kSize = 131072 };\n\n  int main(int argc, char **argv) {\n    char *addr = (char *)mmap(0, kSize, PROT_READ | PROT_WRITE,\n                             MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n    memset(addr, 1, kSize);\n    for (int i = 0; i != 100000; ++i) {\n#ifdef PAGE_FAULT\n      memset(addr + (i * 4096) % kSize, i, 4096);\n#endif\n      mprotect((void *)addr, kSize, PROT_NONE);\n      mprotect((void *)addr, kSize, PROT_READ | PROT_WRITE);\n    }\n  }\n\nWith PAGE_FAULT undefined (0 pages touched after removing write\nprotection) the median real time execution time of 100 runs was measured\nas follows:\n\nBefore: 0.330260s\nAfter:  0.338836s\n\nWith PAGE_FAULT defined (1 page touched) the measurements were\nas follows:\n\nBefore: 0.438048s\nAfter:  0.355661s\n\nSo it seems that even with a single page fault the new approach is faster.\n\nI saw similar results if I adjusted the programs to use a larger mapping\nsize.  With kSize = 1048576 I get these numbers with PAGE_FAULT undefined:\n\nBefore: 1.428988s\nAfter:  1.512016s\n\ni.e. around 5.5%.\n\nAnd these with PAGE_FAULT defined:\n\nBefore: 1.518559s\nAfter:  1.524417s\n\ni.e. about the same.\n\nWhat I think we may conclude from these results is that for smaller\nmappings the advantage of the previous approach, although measurable, is\nwiped out by a single page fault.  I think we may expect that there should\nbe at least one access resulting in a page fault (under the previous\napproach) after making the pages writable, since the program presumably\nmade the pages writable for a reason.\n\nFor larger mappings we may guesstimate that the new approach wins if the\ndensity of future page faults is > 0.4%.  But for the mappings that are\nlarge enough for density to matter (not just the absolute number of page\nfaults) it doesn't seem like the increase in mprotect latency would be\nvery large relative to the total mprotect execution time.\n\nLink: https://lkml.kernel.org/r/20210527190453.125902-1-pcc@google.com\nLink: https://linux-review.googlesource.com/id/I98d75ef90e20330c578871c87494d64b1df3f1b8\nLink: [1] https://source.android.com/devices/tech/debug/scudo\nLink: [2] https://cs.android.com/android/platform/superproject/+/master:bionic/benchmarks/stdliv_benchmark.cpp;l=53;drc=e8693e78711e8f45ccd2b610e4dbe0b94d551cc9\nLink: [3] https://github.com/pcc/llvm-project/commit/scudo-mprotect-secondary2\nSigned-off-by: Peter Collingbourne <pcc@google.com>\nReviewed-by: Peter Xu <peterx@redhat.com>\nCc: Kostya Kortchinsky <kostyak@google.com>\nCc: Evgenii Stepanov <eugenis@google.com>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Stephen Rothwell <sfr@canb.auug.org.au>\n(cherry picked from commit e2037f9c0c61ed6964bb1291292ae88f073a100c\n https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git akpm)\n[pcc: squashed v4->v5 diff which appeared as a separate commit: ec7563ea9f6a470e9bb532b024ce29d9474daf24]\nChange-Id: Ic3994b2ec914d3f62f95c1ef338986e350e69e36\nBug: 191165850",
        "root_cause": "The vulnerability is related to the Scudo memory allocator. When a memory region is deallocated, it should be protected with `PROT_NONE`. Later, when the region is to be reused, it needs to be made writable using `mprotect(PROT_READ|PROT_WRITE)`. Before the fix, after removing write protection, any writes would lead to page faults and enter copy-on-write, which impacts performance. The fix makes pages in anonymous mappings referenced by a single PTE immediately writable during mprotect to avoid these page faults.",
        "weaknesses": [
          "Inefficient memory protection mechanism"
        ],
        "impact": "Performance degradation due to unnecessary page faults when writing to memory regions after removing write protection.",
        "attack_vectors": [
            "Exploiting the inefficiency in memory protection by triggering frequent allocations and deallocations."
         ],
         "required_capabilities": "An attacker needs the ability to allocate and deallocate memory regions."
      },
      {
       "type": "commit message",
       "content": "Revert \"FROMGIT: mm: improve mprotect(R|W) efficiency on pages referenced once\"\n\nThis reverts commit 6f9aba5a20b84a20848cc444a304f4ada6538b39.\n\nReason for revert: Breaks CTS\n\nChange-Id: I88ce3506b4881a7d8dae0aaf687dba602a0ca0f2\nSigned-off-by: Quentin Perret <qperret@google.com>",
        "root_cause": "This commit message indicates a revert of the original fix for CVE-2021-39802.",
        "weaknesses": [],
        "impact": "Reverting the fix reintroduces the performance degradation issue.",
        "attack_vectors": [],
         "required_capabilities": "N/A"
      },
      {
        "type": "commit message",
         "content": "FROMGIT: mm: improve mprotect(R|W) efficiency on pages referenced once\n\nIn the Scudo memory allocator [1] we would like to be able to detect\nuse-after-free vulnerabilities involving large allocations by issuing\nmprotect(PROT_NONE) on the memory region used for the allocation when\nit is deallocated.  Later on, after the memory region has been\n\"quarantined\" for a sufficient period of time we would like to be able\nto use it for another allocation by issuing mprotect(PROT_READ|PROT_WRITE).\n\nBefore this patch, after removing the write protection, any writes to the\nmemory region would result in page faults and entering the copy-on-write\ncode path, even in the usual case where the pages are only referenced by a\nsingle PTE, harming performance unnecessarily.  Make it so that any pages\nin anonymous mappings that are only referenced by a single PTE are\nimmediately made writable during the mprotect so that we can avoid the\npage faults.\n\nThis program shows the critical syscall sequence that we intend to use in\nthe allocator:\n\n  #include <string.h>\n  #include <sys/mman.h>\n\n  enum { kSize = 131072 };\n\n  int main(int argc, char **argv) {\n    char *addr = (char *)mmap(0, kSize, PROT_READ | PROT_WRITE,\n                             MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n    for (int i = 0; i != 100000; ++i) {\n      memset(addr, i, kSize);\n      mprotect((void *)addr, kSize, PROT_NONE);\n      mprotect((void *)addr, kSize, PROT_READ | PROT_WRITE);\n    }\n  }\n\nThe effect of this patch on the above program was measured on a\nDragonBoard 845c by taking the median real time execution time of 10 runs.\n\nBefore: 3.19s\nAfter:  0.79s\n\nThe effect was also measured using one of the microbenchmarks that we\nnormally use to benchmark the allocator [2], after modifying it to make\nthe appropriate mprotect calls [3]. With an allocation size of 131072\nbytes to trigger the allocator's \"large allocation\" code path the\nper-iteration time was measured as follows:\n\nBefore: 33364ns\nAfter:   6886ns\n\nThis patch means that we do more work during the mprotect call itself in\nexchange for less work when the pages are accessed.  In the worst case,\nthe pages are not accessed at all.  The effect of this patch in such cases\nwas measured using the following program:\n\n  #include <string.h>\n  #include <sys/mman.h>\n\n  enum { kSize = 131072 };\n\n  int main(int argc, char **argv) {\n    char *addr = (char *)mmap(0, kSize, PROT_READ | PROT_WRITE,\n                             MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n    memset(addr, 1, kSize);\n    for (int i = 0; i != 100000; ++i) {\n#ifdef PAGE_FAULT\n      memset(addr + (i * 4096) % kSize, i, 4096);\n#endif\n      mprotect((void *)addr, kSize, PROT_NONE);\n      mprotect((void *)addr, kSize, PROT_READ | PROT_WRITE);\n    }\n  }\n\nWith PAGE_FAULT undefined (0 pages touched after removing write\nprotection) the median real time execution time of 100 runs was measured\nas follows:\n\nBefore: 0.325928s\nAfter:  0.365493s\n\nWith PAGE_FAULT defined (1 page touched) the measurements were\nas follows:\n\nBefore: 0.441516s\nAfter:  0.380251s\n\nSo it seems that even with a single page fault the new approach is faster.\n\nI saw similar results if I adjusted the programs to use a larger mapping\nsize.  With kSize = 1048576 I get these numbers with PAGE_FAULT undefined:\n\nBefore: 1.563078s\nAfter:  1.607476s\n\ni.e. around 3%.\n\nAnd these with PAGE_FAULT defined:\n\nBefore: 1.684663s\nAfter:  1.683272s\n\ni.e. about the same.\n\nWhat I think we may conclude from these results is that for smaller\nmappings the advantage of the previous approach, although measurable, is\nwiped out by a single page fault.  I think we may expect that there should\nbe at least one access resulting in a page fault (under the previous\napproach) after making the pages writable, since the program presumably\nmade the pages writable for a reason.\n\nFor larger mappings we may guesstimate that the new approach wins if the\ndensity of future page faults is > 0.4%.  But for the mappings that are\nlarge enough for density to matter (not just the absolute number of page\nfaults) it doesn't seem like the increase in mprotect latency would be\nvery large relative to the total mprotect execution time.\n\nLink: https://lkml.kernel.org/r/20211230004134.1185017-1-pcc@google.com\nLink: https://linux-review.googlesource.com/id/I98d75ef90e20330c578871c87494d64b1df3f1b8\nLink: [1] https://source.android.com/devices/tech/debug/scudo\nLink: [2] https://cs.android.com/android/platform/superproject/+/master:bionic/benchmarks/stdliv_benchmark.cpp;l=53;drc=e8693e78711e8f45ccd2b610e4dbe0b94d551cc9\nLink: [3] https://github.com/pcc/llvm-project/commit/scudo-mprotect-secondary\nSigned-off-by: Peter Collingbourne <pcc@google.com>\nCc: Kostya Kortchinsky <kostyak@google.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Stephen Rothwell <sfr@canb.auug.org.au>\n(cherry picked from commit 2a9e75c907fa2de626d77dd4051fc038f0dbaaf52\n https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git akpm)\nBug: 135772972\nChange-Id: I98d75ef90e20330c578871c87494d64b1df3f1b8",
         "root_cause": "The vulnerability is related to the Scudo memory allocator. When a memory region is deallocated, it should be protected with `PROT_NONE`. Later, when the region is to be reused, it needs to be made writable using `mprotect(PROT_READ|PROT_WRITE)`. Before the fix, after removing write protection, any writes would lead to page faults and enter copy-on-write, which impacts performance. The fix makes pages in anonymous mappings referenced by a single PTE immediately writable during mprotect to avoid these page faults.",
        "weaknesses": [
          "Inefficient memory protection mechanism"
        ],
        "impact": "Performance degradation due to unnecessary page faults when writing to memory regions after removing write protection.",
        "attack_vectors": [
            "Exploiting the inefficiency in memory protection by triggering frequent allocations and deallocations."
         ],
         "required_capabilities": "An attacker needs the ability to allocate and deallocate memory regions."
      },
      {
        "type": "commit message",
        "content": "Revert \"FROMGIT: mm: improve mprotect(R|W) efficiency on pages referenced once\"\n\nThis reverts commit b44e46bb047d136bc8977497b6fc2a9f08740321.\n\nReason for revert:\n\nThe patch has not yet landed upstream, following feedback from Linus:\nhttps://lore.kernel.org/all/CAHk-=wj4KCuJAH_oPh40Bkp48amM4MXr+8AcbZ=qd5LF4Q+TDg@mail.gmail.com/#t\n\nBug: 213339151\nSigned-off-by: Peter Collingbourne <pcc@google.com>\nChange-Id: I81c2cef4076487df1dd0ee75449dcb2371ac1dbc",
        "root_cause": "This commit message indicates another revert of the fix for CVE-2021-39802 due to upstream issues.",
        "weaknesses": [],
        "impact": "Reverting the fix reintroduces the performance degradation issue.",
        "attack_vectors": [],
        "required_capabilities": "N/A"
      }
    ],
    "summary": "The vulnerability relates to the Scudo memory allocator and its inefficient use of mprotect when transitioning memory from read-only to read-write, leading to performance degradation from unnecessary page faults. The fix aimed to make memory pages immediately writable to avoid these faults, but it was reverted due to issues in the CTS tests and problems with upstream kernel acceptance."
  }
}
```