Based on the provided content, here's the breakdown of the vulnerability:

**Root Cause:**
The vulnerability stems from a regular expression used in the `ActiveAttr::Typecasting::BooleanTypecaster#call` method for typecasting boolean values. The original regex `/\A[-+]?(0+\.?0*|0*\.?0+)\z/` is susceptible to ReDoS (Regular Expression Denial of Service) attacks. Specifically, it can cause excessive backtracking when presented with a specially crafted string that has many leading zeros followed by a character that doesn't match, such as `"00000...0a"`.

**Weaknesses/Vulnerabilities:**
- The regex `/\A[-+]?(0+\.?0*|0*\.?0+)\z/` is vulnerable to catastrophic backtracking.
- The `BooleanTypecaster` uses this vulnerable regex to identify numeric strings that should be cast to true or false.
- An attacker could provide a long string of '0's followed by a non-numeric character as input.

**Impact of Exploitation:**
- A successful attack would cause the application to hang or become unresponsive due to excessive CPU consumption, effectively causing a denial-of-service.

**Attack Vectors:**
-  An attacker could exploit this by providing a specially crafted string to any part of the application that uses the `ActiveAttr::Typecasting::BooleanTypecaster` for typecasting. Specifically, an input with many leading zeros followed by a character that doesn't match.

**Required Attacker Capabilities/Position:**
- The attacker needs to be able to control the input that is being processed by `ActiveAttr::Typecasting::BooleanTypecaster#call`.

**Mitigation:**

The vulnerability was fixed by changing the regex from `/\A[-+]?(0+\.?0*|0*\.?0+)\z/` to `/\A[-+]?(0++\.?0*|0*+\.?0+)\z/`.  The `+` quantifier was changed to `++` which is a possessive quantifier, which avoids backtracking and prevents ReDoS.

This was addressed in commit `dab95e5` and released in version `0.15.3`.