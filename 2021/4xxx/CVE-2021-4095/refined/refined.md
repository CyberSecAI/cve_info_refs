```
{
  "cveId": "CVE-2021-4095",
  "description": "The provided content describes a NULL pointer dereference vulnerability in the Linux kernel's KVM module, specifically within the kvm_dirty_ring_get() function. This occurs when dirty ring logging is enabled without an active vCPU context.",
  "vulnerabilityDetails": {
    "rootCause": "The root cause is a missing check for a valid vCPU context before accessing the vcpu->dirty_ring member within the `kvm_dirty_ring_get()` function. When dirty ring logging is enabled and a `KVM_XEN_HVM_SET_ATTR` ioctl is called without an active vCPU, `kvm_get_running_vcpu()` returns a NULL pointer, leading to a dereference when attempting to access `vcpu->dirty_ring`.",
    "weaknesses": [
      "NULL pointer dereference",
      "Missing check for valid vCPU context"
    ],
    "impact": "The impact of this vulnerability is a kernel oops, leading to a denial of service. A local unprivileged attacker can trigger this by calling KVM_XEN_HVM_SET_ATTR ioctl without an active VCPU.",
    "attackVectors": [
      "Local access via KVM ioctl",
      "KVM_XEN_HVM_SET_ATTR ioctl"
    ],
      "requiredCapabilities": "The attacker must have local access to the host and the ability to call KVM ioctls, specifically KVM_XEN_HVM_SET_ATTR. No special privileges are required."
  },
  "additionalNotes": "The provided content includes a detailed call trace of the crash, the code snippets where the vulnerability exists, and links to the patch that fixes the issue. The vulnerability is triggered when the dirty ring logging is enabled without an active vCPU. The fix involves avoiding the use of the generic `kvm_write_wall_clock()` function and directly writing through the gfn_to_pfn_cache. It also makes `kvm_write_wall_clock()` static in `x86.c`.",
   "affectedComponents": [
        "Linux kernel KVM module",
        "virt/kvm/dirty_ring.c",
        "arch/x86/kvm/x86.c",
        "arch/x86/kvm/xen.c"
   ]
}
```