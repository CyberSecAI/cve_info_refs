```
{
  "CVE-2012-6701": {
    "related_content": [
      {
        "source": "www.kernel.org_e2c3853b_20250125_184930.html",
        "text": "This commit introduced a fix for a deadlock issue related to holding the mmap_sem while calling flush_cache_user_range, where a page fault during the flush could lead to a deadlock if another thread tries to acquire the write lock on mmap_sem. It also includes other fixes related to i2c, MCE, ARM, mmc, usb, rdma, and others.",
         "vulnerability": "NOINFO"
      },
       {
        "source": "bugzilla.redhat.com_b74b7dea_20250126_110845.html",
        "text": "The AIO interface did not use the rw_verify_area() helper function, which performs extended checks such as mandatory locking on the file and verifies if the access size will cause overflow. This integer overflow in fs/aio.c in the Linux kernel before 3.4.1 allows local users to cause a denial of service or possibly have unspecified other impact via a large AIO iovec.",
        "vulnerability": {
          "root_cause": "The AIO interface was not utilizing the `rw_verify_area()` helper function for access checks.",
          "weaknesses": [
            "Integer overflow vulnerability due to the lack of proper size checking in the AIO interface.",
             "Missing mandatory locking check in the AIO interface"
          ],
          "impact": "A local user can cause a denial of service or other unspecified impacts via a large AIO iovec.",
           "attack_vectors": [
            "Local attacker triggering the vulnerability by supplying a specially crafted large AIO iovec"
          ],
          "required_attacker_capabilities": "Local shell access."
        }
      },
        {
        "source": "www.openwall.com_e8757603_20250125_184931.html",
         "text": "The AIO interface permitted reading or writing 2 GiB of data or more in a single chunk, which could lead to an integer overflow when applied to certain filesystems, socket or device types. The full security impact has not been evaluated. The issue was addressed by making the AIO use the proper rw_verify_area() area helpers.",
        "vulnerability": {
             "root_cause": "The AIO interface permitted excessively large data transfers without proper size validation.",
            "weaknesses": [
              "Integer overflow vulnerability due to lack of size validation in AIO interface.",
                "Missing checks to prevent excessively large data transfer."
            ],
            "impact": "Potential integer overflows when transferring large chunks of data through the AIO interface, with unspecified security impact.",
             "attack_vectors": [
                "Attacker uses the AIO interface to transfer large amounts of data to trigger an integer overflow"
              ],
            "required_attacker_capabilities": "NOINFO"
          }
       },
       {
          "source": "git.kernel.org_a2a8e5a0_20250125_184928.html",
          "text": "The AIO interface was overlooked and didn't use the proper rw_verify_area() helper function, which checks for mandatory locking and access size limits. This commit addresses the issue by integrating the proper helper functions to prevent mandatory file locking bypass and potential overflow.",
            "vulnerability": {
              "root_cause": "AIO interface bypasses necessary access checks.",
                "weaknesses": [
                  "Inadequate input validation in AIO interface.",
                    "Lack of usage of helper functions for access size limits",
                    "Missing mandatory file locking check."
                ],
              "impact": "May lead to an overflow or bypass mandatory file locking restrictions.",
              "attack_vectors": [
                   "Malicious user exploits AIO interface with crafted requests to bypass mandatory file locking and possibly trigger overflows."
              ],
              "required_attacker_capabilities": "NOINFO"
           }
        },
        {
          "source": "access.redhat.com_202ca17b_20250126_110841.html",
          "text": "The AIO interface didn't use rw_verify_area() for checking mandatory locking on files and size of access. This integer overflow in fs/aio.c in the Linux kernel before 3.4.1 allows local users to cause a denial of service or possibly have unspecified other impact via a large AIO iovec.",
          "vulnerability": {
             "root_cause": "The AIO interface was not using `rw_verify_area()` to validate size and enforce mandatory locking",
             "weaknesses": [
                  "Integer overflow vulnerability.",
                  "Missing mandatory locking check.",
                   "Insufficient size validation."
              ],
            "impact": "Local user can cause a denial of service or other unspecified impact with large AIO iovec.",
            "attack_vectors": [
                  "Local users exploiting the AIO interface with large iovec"
              ],
             "required_attacker_capabilities": "Local shell account."
            }
        },
         {
          "source": "access.redhat.com_9cd99b77_20250125_184931.html",
           "text": "The kernel packages contain the Linux kernel, the core of any Linux operating system.\nSecurity Fix(es):\n\nAn industry-wide issue was found in the way many modern microprocessor designs have implemented speculative execution of Load & Store instructions (a commonly used performance optimization). It relies on the presence of a precisely-defined instruction sequence in the privileged code as well as the fact that memory read from address to which a recent memory write has occurred may see an older value and subsequently cause an update into the microprocessor's data cache even for speculatively executed instructions that never actually commit (retire). As a result, an unprivileged attacker could use this flaw to read privileged memory by conducting targeted cache side-channel attacks. (CVE-2018-3639, PowerPC)\nkernel: net/packet: overflow in check for priv area size (CVE-2017-7308)\nkernel: AIO interface didn't use rw_verify_area() for checking mandatory locking on files and size of access (CVE-2012-6701)\nkernel: AIO write triggers integer overflow in some protocols (CVE-2015-8830)\nkernel: Null pointer dereference via keyctl (CVE-2016-8650)\nkernel: ping socket / AF_LLC connect() sin_family race (CVE-2017-2671)\nkernel: Race condition between multiple sys_perf_event_open() calls (CVE-2017-6001)\nkernel: Incorrect error handling in the set_mempolicy and mbind compat syscalls in mm/mempolicy.c (CVE-2017-7616)\nkernel: mm subsystem does not properly enforce the CONFIG_STRICT_DEVMEM protection mechanism (CVE-2017-7889)\nkernel: Double free in the inet_csk_clone_lock function in net/ipv4/inet_connection_sock.c (CVE-2017-8890)\nkernel: net: sctp_v6_create_accept_sk function mishandles inheritance (CVE-2017-9075)\nkernel: net: IPv6 DCCP implementation mishandles inheritance (CVE-2017-9076)\nkernel: net: tcp_v6_syn_recv_sock function mishandles inheritance (CVE-2017-9077)\nkernel: memory leak when merging buffers in SCSI IO vectors (CVE-2017-12190)\nkernel: vfs: BUG in truncate_inode_pages_range() and fuse client (CVE-2017-15121)\nkernel: Race condition in drivers/md/dm.c:dm_get_from_kobject() allows local users to cause a denial of service (CVE-2017-18203)\nkernel: a null pointer dereference in net/dccp/output.c:dccp_write_xmit() leads to a system crash (CVE-2018-1130)\nkernel: Missing length check of payload in net/sctp/sm_make_chunk.c:_sctp_make_chunk() function allows denial of service (CVE-2018-5803)",
            "vulnerability": {
              "root_cause": "The AIO interface was not using the proper `rw_verify_area()` helper function for validation of access and locking requirements",
            "weaknesses": [
                "Missing mandatory file locking check.",
              "Integer overflow vulnerability due to the lack of proper size checking in the AIO interface."
            ],
            "impact": "A local user can cause a denial of service or other unspecified impacts via a large AIO iovec",
              "attack_vectors": [
                  "Local attacker triggering the vulnerability by supplying a specially crafted large AIO iovec."
                ],
               "required_attacker_capabilities": "Local shell access."
            }
          },
          {
          "source": "www.redhat.com_6f9f8911_20250126_110848.html",
          "text": "NOINFO",
           "vulnerability": "NOINFO"
          },
          {
           "source": "www.redhat.com_3e0cd7cf_20250126_110843.html",
            "text": "NOINFO",
             "vulnerability":"NOINFO"
          },
         {
           "source": "github.com_c741ea72_20250125_184934.html",
           "text":"We had for some reason overlooked the AIO interface, and it didn't use\nthe proper rw_verify_area() helper function that checks (for example)\nmandatory locking on the file, and that the size of the access doesn't\ncause us to overflow the provided offset limits etc.\n\nInstead, AIO did just the security_file_permission() thing (that\nrw_verify_area() also does) directly.\n\nThis fixes it to do all the proper helper functions, which not only\nmeans that now mandatory file locking works with AIO too, we can\nactually remove lines of code.\n\nReported-by: Manish Honap <manish_honap_vit@yahoo.co.in>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
           "vulnerability": {
            "root_cause": "The AIO interface was not using the `rw_verify_area()` helper function for proper access control",
            "weaknesses": [
               "Bypass of mandatory file locking",
               "Integer overflow due to missing size validation."
            ],
            "impact":"Potential to bypass mandatory file locking and cause a size overflow",
            "attack_vectors": [
                "Attacker uses a crafted AIO request"
                ],
            "required_attacker_capabilities":"NOINFO"
              }
         }
    ]
  }
}
```