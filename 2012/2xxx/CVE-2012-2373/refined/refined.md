```
{
  "CVE-2012-2373": {
    "vulnerability": "A race condition exists in the Linux kernel's memory management subsystem on x86 32-bit systems with PAE enabled and more than 4GB of RAM. The pmd_offset_map_lock function, when called with mmap_sem held in read mode, can race against pmd_populate when Transparent Huge Pages (THP) are disabled. This occurs because pmd_t reads are not atomic, potentially leading to a partial pmd read during concurrent page table modifications.",
    "weaknesses": [
      "Non-atomic read of pmd_t",
      "Race condition between pmd_offset_map_lock and pmd_populate",
        "Improper handling of concurrent page faults during pmd read"
    ],
    "impact": "A local unprivileged user can exploit this vulnerability to crash the system due to a page fault or kernel panic. This can lead to a denial of service.",
    "attack_vectors": [
      "Local unprivileged user",
        "Concurrent operations from multiple CPUs",
        "Triggering page faults while holding mmap_sem in read mode."
    ],
    "required_capabilities": [
      "Ability to execute code on the target system.",
         "x86 32bit system with PAE enabled and more than 4GB RAM."
    ],
        "additional_details": "The vulnerability affects systems without THP or with THP enabled where the page table entry can transition between null, pmd_trans_huge, or stable states under pmd_read_atomic function. The bug is triggered when a page fault occurs on one CPU while another CPU is reading the PMD entry using two separate mov instructions, leading to a non-atomic read and possible inconsistency. The fix introduces the pmd_read_atomic function which ensures atomic reads of the pmd and resolves the race condition. More specifically, if CONFIG_TRANSPARENT_HUGEPAGE is enabled, atomic64_read() is used and in case CONFIG_TRANSPARENT_HUGEPAGE is disabled the function reads the low part of pmdval first and only reads high part if the low part is not null"
  }
}
```