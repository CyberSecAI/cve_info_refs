```
{
  "CVE-2012-2313": {
    "description": "The dl2k driver's rio_ioctl call has a few issues: - No permissions checking - Implements SIOCGMIIREG and SIOCGMIIREG using the SIOCDEVPRIVATE numbers - Has a few ioctls that may have been used for debugging at one point but have no place in the kernel proper.\n\n  This patch removes all but the MII ioctls, renumbers them to use the standard ones, and adds the proper permission check for SIOCSMIIREG.\n\n  We can also get rid of the dl2k-specific struct mii_data in favor of the generic struct mii_ioctl_data.\n\n  Since we have the phyid on hand, we can add the SIOCGMIIPHY ioctl too.",
    "vulnerability": "The rio_ioctl function in drivers/net/ethernet/dlink/dl2k.c in the Linux kernel did not restrict access to the SIOCSMIIREG command, which allowed local users to write data to an Ethernet adapter via an ioctl call.",
    "impact": "A local, unprivileged user could use this flaw to issue potentially harmful IOCTLs, which could cause Ethernet adapters using the dl2k driver to malfunction (for example, losing network connectivity).",
    "attack_vector": "Local, via ioctl calls.",
    "attacker_capabilities": "A local, unprivileged user",
    "root_cause": "The dl2k driver's rio_ioctl call did not perform permissions checking and implemented MII ioctls using the SIOCDEVPRIVATE numbers instead of the standard ones. Also included debugging ioctls."
  },
  "CVE-2012-2319": {
     "description": "Multiple buffer overflows in the hfsplus filesystem implementation in the Linux kernel before 3.3.5 allow local users to gain privileges via a crafted HFS plus filesystem, a related issue to CVE-2009-4020.",
     "vulnerability": "Multiple buffer overflows in the hfsplus filesystem implementation in the Linux kernel.",
     "impact": "Local users to gain privileges via a crafted HFS plus filesystem.",
     "attack_vector": "Local",
     "attacker_capabilities": "Local user with ability to mount a crafted HFS+ file system.",
    "root_cause": "Multiple buffer overflows in the hfsplus filesystem implementation due to lack of proper validation."
  },
    "CVE-2011-4132":{
       "description": "The cleanup_journal_tail function in the Journaling Block Device (JBD) functionality in the Linux kernel 2.6 allows local users to cause a denial of service (assertion error and kernel oops) via an ext3 or ext4 image with an 'invalid log first block value.'",
       "vulnerability": "The cleanup_journal_tail function in the Journaling Block Device (JBD) functionality in the Linux kernel.",
       "impact": "Local users to cause a denial of service (assertion error and kernel oops) via an ext3 or ext4 image with an 'invalid log first block value'.",
       "attack_vector": "Local",
       "attacker_capabilities": "Local users with ability to use a crafted ext3 or ext4 image.",
        "root_cause": "The cleanup_journal_tail function didn't handle the 'invalid log first block value' properly, leading to an assertion error and kernel oops."
      },
  "CVE-2011-4913": {
    "description": "The rose_parse_ccitt function in net/rose/rose_subr.c in the Linux kernel before 2.6.39 does not validate the FAC_CCITT_DEST_NSAP and FAC_CCITT_SRC_NSAP fields, which allows remote attackers to (1) cause a denial of service (integer underflow, heap memory corruption, and panic) via a small length value in data sent to a ROSE socket, or (2) conduct stack-based buffer overflow attacks via a large length value in data sent to a ROSE socket.",
     "vulnerability": "The rose_parse_ccitt function does not validate the FAC_CCITT_DEST_NSAP and FAC_CCITT_SRC_NSAP fields.",
    "impact": "Remote attackers to cause a denial of service (integer underflow, heap memory corruption, and panic) or conduct stack-based buffer overflow attacks.",
    "attack_vector": "Remote, via sending data to a ROSE socket.",
    "attacker_capabilities": "Remote attackers able to send data to a ROSE socket.",
    "root_cause": "The rose_parse_ccitt function does not properly validate the FAC_CCITT_DEST_NSAP and FAC_CCITT_SRC_NSAP fields, leading to integer underflows, heap corruption, and stack based buffer overflows."
  },
  "CVE-2011-4914": {
    "description": "The ROSE protocol implementation in the Linux kernel before 2.6.39 does not verify that certain data-length values are consistent with the amount of data sent, which might allow remote attackers to obtain sensitive information from kernel memory or cause a denial of service (out-of-bounds read) via crafted data to a ROSE socket.",
        "vulnerability": "The ROSE protocol implementation does not verify data-length values.",
        "impact": "Remote attackers could obtain sensitive information from kernel memory or cause a denial of service (out-of-bounds read).",
        "attack_vector": "Remote, via crafted data sent to a ROSE socket.",
        "attacker_capabilities": "Remote attackers able to send crafted data to a ROSE socket.",
        "root_cause": "The ROSE protocol implementation does not verify the consistency between data-length values and actual data sent, leading to out-of-bounds reads."
  },
  "CVE-2012-6657": {
     "description": "The sock_setsockopt function in net/core/sock.c in the Linux kernel before 3.5.7 does not ensure that a keepalive action is associated with a stream socket, which allows local users to cause a denial of service (system crash) by leveraging the ability to create a raw socket.",
     "vulnerability": "The sock_setsockopt function in the Linux kernel does not ensure that a keepalive action is associated with a stream socket.",
     "impact": "Local users can cause a denial of service (system crash).",
     "attack_vector": "Local",
     "attacker_capabilities":"Local users with ability to create raw sockets.",
      "root_cause": "The sock_setsockopt function fails to ensure that a keepalive action is associated with a stream socket."
  }
}
```