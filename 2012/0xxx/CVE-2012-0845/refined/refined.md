```
{
  "CVE-2012-0845": {
    "description": "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
    "vulnerability_details": {
      "root_cause": "The vulnerability is caused by an infinite loop within the SimpleXMLRPCServer module when processing a POST request. This loop is triggered when the client closes the connection prematurely, before the entire request body, as indicated by the Content-Length header, has been sent.",
      "weaknesses": [
        "Improper input validation on Content-Length header",
         "Infinite loop vulnerability."
      ],
      "impact": "A remote attacker can cause a denial of service, leading to excessive CPU consumption and potentially making the server unavailable.",
      "attack_vectors": "The attack vector is remote.  The attacker sends a malformed XML-RPC POST request to the vulnerable SimpleXMLRPCServer, where the Content-Length header specifies more data than is actually sent.",
      "required_capabilities": "The attacker needs network access to the vulnerable server. No specific privileges or user interaction is required."
    },
     "affected_products":[
        "Python 2.6 before 2.6.8",
        "Python 2.7.x before 2.7.3",
         "Python 3.x before 3.1.5",
         "Python 3.2.x before 3.2.3"
      ]
  },
"CVE-2011-4944": {
    "description": "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
    "vulnerability_details": {
      "root_cause": "A race condition exists when the distutils library creates the ~/.pypirc file. The file is initially created with world-readable permissions, and then later the permissions are changed after writing data to the file. An attacker can take advantage of this window between file creation and the permission change.",
      "weaknesses": [
         "Race condition when creating ~/.pypirc",
        "Insecure file permissions"
      ],
      "impact": "A local attacker can exploit the race condition to gain access to the username and password stored within the ~/.pypirc configuration file.",
      "attack_vectors": "The attack vector is local. A local attacker with appropriate privileges can monitor the file creation and race to read the sensitive credentials before they are properly protected.",
      "required_capabilities": "The attacker needs local access to the system with the ability to create files in the current working directory.  Also, they must be able to monitor file creation and permissions changes."
    },
      "affected_products":[
        "Python 2.6 through 3.2"
      ]
  },
"CVE-2011-3389": {
        "description": "The SSL protocol, as used in certain configurations in Microsoft Windows and Microsoft Internet Explorer, Mozilla Firefox, Google Chrome, Opera, and other products, encrypts data by using CBC mode with chained initialization vectors, which allows man-in-the-middle attackers to obtain plaintext HTTP headers via a blockwise chosen-boundary attack (BCBA) on an HTTPS session, in conjunction with JavaScript code that uses (1) the HTML5 WebSocket API, (2) the Java URLConnection API, or (3) the Silverlight WebClient API, aka a \"BEAST\" attack.",
        "vulnerability_details": {
           "root_cause": "The vulnerability stems from the use of CBC mode with chained initialization vectors in the SSL protocol, which, when combined with specific JavaScript code, creates the possibility for the BEAST attack.",
          "weaknesses": [
              "Vulnerable implementation of CBC mode in SSL protocol",
              "Use of chained initialization vectors"
          ],
          "impact": "A man-in-the-middle attacker can obtain plaintext HTTP headers through a blockwise chosen-boundary attack. This can expose sensitive information.",
           "attack_vectors": "The attack vector is network-based. A man-in-the-middle attacker intercepts HTTPS traffic and utilizes JavaScript to exploit the vulnerability.",
         "required_capabilities": "The attacker needs to be positioned to intercept network traffic (man-in-the-middle) and be able to execute JavaScript code in the context of the victim's browser or application."
      },
      "affected_products": [
          "Microsoft Windows",
           "Microsoft Internet Explorer",
           "Mozilla Firefox",
          "Google Chrome",
          "Opera",
          "Other products using affected versions of SSL"
      ]
  },
    "CVE-2012-1150": {
    "description": "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
    "vulnerability_details": {
      "root_cause": "The vulnerability is caused by Python's predictable hash algorithm, which makes it possible for attackers to craft specific inputs that will lead to hash collisions. These collisions can significantly degrade performance and cause a denial-of-service by consuming excessive CPU resources when building or utilizing hash tables.",
      "weaknesses": [
         "Predictable hash values",
        "Lack of hash collision mitigation"
      ],
      "impact": "A context-dependent attacker can cause a denial of service via excessive CPU usage by providing crafted input designed to create collisions in hash tables.",
      "attack_vectors": "The attack vector depends on the context of the affected application, but it often requires an attacker to be able to provide input that will be used as keys in a hash table.",
      "required_capabilities": "The attacker must be able to interact with or provide input to an application that uses a hash table."
    },
     "affected_products":[
        "Python before 2.6.8",
        "Python 2.7.x before 2.7.3",
         "Python 3.x before 3.1.5",
         "Python 3.2.x before 3.2.3"
      ]
  },
   "CVE-2013-1752": {
    "description": "Various versions of Python do not properly restrict readline calls, which allows remote attackers to cause a denial of service (memory consumption) via a long string, related to (1) httplib - fixed in 2.7.4, 2.6.9, and 3.3.3; (2) ftplib - fixed in 2.7.6, 2.6.9, 3.3.3; (3) imaplib - not yet fixed in 2.7.x, fixed in 2.6.9, 3.3.3; (4) nntplib - fixed in 2.7.6, 2.6.9, 3.3.3; (5) poplib - not yet fixed in 2.7.x, fixed in 2.6.9, 3.3.3; and (6) smtplib - not yet fixed in 2.7.x, fixed in 2.6.9, not yet fixed in 3.3.x. NOTE: this was REJECTed because it is incompatible with CNT1 'Independently Fixable' in the CVE Counting Decisions.",
        "vulnerability_details": {
            "root_cause": "The root cause lies in the failure of Python to properly limit readline calls. This causes various standard library modules to consume excessive memory when given a long string.",
            "weaknesses": [
              "Insufficient restriction on readline calls",
                "Unbounded memory allocation."
            ],
            "impact": "Remote attackers can trigger a denial of service through excessive memory consumption.",
            "attack_vectors": "The vulnerability can be exploited by sending a long string to a python application via httplib, ftplib, imaplib, nntplib, poplib or smtplib.",
            "required_capabilities": "The attacker requires network access to the vulnerable service and the ability to send the malicious input."
        },
     "affected_products": [
        "Python versions (see description for specifics)"
      ]
  }
}
```