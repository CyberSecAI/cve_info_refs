```
{
  "vulnerability_details": [
    {
      "cve_id": "CVE-2012-0810",
      "description": "The vulnerability exists in the Linux kernel when running on x86_64 with CONFIG_PREEMPT_RT_FULL enabled. The int3 handler uses a per-CPU debug stack and calls do_trap() with interrupts enabled but preemption disabled. Subsequently, a signal is sent to the current process, and the code that handles the signal grabs a spinlock, which becomes a sleeping mutex due to `CONFIG_PREEMPT_RT_FULL`. If there is contention on this lock, the task may schedule out. Since the task is using a per-CPU stack, and another task may come in and use the same stack, the stack can become corrupted, leading to a kernel panic.",
      "root_cause": "The root cause is the combination of using a per-CPU stack for debug traps, disabling preemption while enabling interrupts, and the signal handling mechanism using a spinlock that can become a sleeping mutex under `CONFIG_PREEMPT_RT_FULL`. This can lead to a race condition where multiple tasks try to use the same per-CPU stack concurrently.",
      "weaknesses": [
        "Incorrect handling of per-CPU stacks when preemption is disabled.",
        "Race condition in signal handling due to using a mutex instead of a spinlock under certain configurations.",
         "Lack of proper synchronization when switching between tasks using the per-cpu stack during debugging traps."
      ],
       "impact": "Stack corruption leading to a kernel panic",
      "attack_vector": "The vulnerability is triggered by a debug trap (int3), which causes a signal to be sent. This then causes a sleep in signal handling code when a lock is contended, which can result in the current task being scheduled out and another task using the same per CPU stack. It is difficult to say precisely what the attacker needs to do to cause a specific race condition, but triggering a signal during debugging trap handling is the necessary initial step.",
      "attacker_capabilities": "The attacker needs to be able to trigger a debug trap (int3) to initiate the vulnerable signal sending path. This usually happens during debugging or when a breakpoint is hit. Additionally, the attacker would need to cause contention on the signal handling spinlock that becomes a mutex, so that the task will be scheduled out."
    }
  ],
  "fixes": [
    {
      "commit_id": "e5d4e1c3ccee18c68f23d62ba77bda26e893d4f0",
      "description": "This commit addresses the issue by ensuring preemption is not disabled on 32-bit systems, as they do not utilize an IST and the task's stack remains consistent across context switches. For x86_64, it changes function names to `conditional_sti/cli_ist` to annotate use with the IST stack.",
       "changes": [
        "Modified the function names to reflect IST usage",
        "Keeps preemption enabled on X86_32 when enabling interrupts for `do_trap()`",
        "The function name is changed from `preempt_conditional_sti/cli()` to `conditional_sti/cli_ist()`, to annotate that this function is used when the stack is on the IST."
      ]
    },
     {
      "commit_id": "bcf6b1d78c0bde228929c388978ed3af9a623463",
       "description": "This commit introduces a delay in calling signals when in an atomic context on x86_64 with `CONFIG_PREEMPT_RT_FULL` enabled. This avoids calling signal-handling code which could sleep due to mutex use, preventing the possibility of scheduling out when running with a debug stack.",
       "changes": [
         "Introduces `ARCH_RT_DELAYS_SIGNAL_SEND` to delay the signal sending.",
        "Stores signal information in the task struct and sets `TIF_NOTIFY_RESUME` flag.",
        "Sends the signal when preemption is enabled during the resume process.",
         "Modifies `force_sig_info()` to check if in atomic context and delay signal sending if needed"
        ]
    }
  ]
}
```