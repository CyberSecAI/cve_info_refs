```
{
  "CVE-2009-2848": {
    "Metadata": {
      "CveID": "CVE-2009-2848",
      "Description": "The execve function in the Linux kernel, possibly 2.6.30-rc6 and earlier, does not properly clear the current->clear_child_tid pointer, which allows local users to cause a denial of service (memory corruption) or possibly gain privileges via a clone system call with CLONE_CHILD_SETTID or CLONE_CHILD_CLEARTID enabled, which is not properly handled during thread creation and exit."
    },
    "RelevantContent": [
      {
        "Source": "lists.opensuse.org_033df5fc_20250125_222020.html",
        "RootCause": "The `execve` function in the Linux kernel does not properly clear the `current->clear_child_tid` pointer.",
        "Weaknesses": [
          "Improper clearing of `current->clear_child_tid` pointer during `execve`."
        ],
        "Impact": "Local users can cause a denial of service (memory corruption) or possibly gain privileges via a clone system call with CLONE_CHILD_SETTID or CLONE_CHILD_CLEARTID enabled.",
        "AttackVectors": [
          "A local user can exploit this vulnerability by using the `clone` system call with `CLONE_CHILD_SETTID` or `CLONE_CHILD_CLEARTID` enabled.",
            "A local attacker could make specially crafted calls to trigger a memory corruption via a clone system call with CLONE_CHILD_SETTID or CLONE_CHILD_CLEARTID enabled."
        ],
        "AttackerCapabilities": "Local user access."
      },
      {
        "Source": "www.vmware.com_dccc8370_20250125_222045.html",
        "RootCause": "The root cause is in the Linux kernel's `execve` function, specifically in how it handles the `current->clear_child_tid` pointer during thread creation and exit.",
        "Weaknesses": [
           "The kernel fails to clear the `current->clear_child_tid` pointer properly.",
           "This leads to memory corruption when a new process executes, especially in threaded scenarios."
        ],
        "Impact": "Local users can cause a denial of service through memory corruption, or potentially gain unauthorized privileges.",
         "AttackVectors": [
           "The vulnerability is triggered by using the `clone` system call with either the `CLONE_CHILD_SETTID` or `CLONE_CHILD_CLEARTID` flag set.",
           "This is improperly handled when the thread is created or exited."
        ],
        "AttackerCapabilities": "Local access is required to trigger the vulnerability."
      },
        {
            "Source": "bugzilla.redhat.com_c5e53515_20250126_122409.html",
            "RootCause": "The execve function in the Linux kernel does not properly clear the current->clear_child_tid pointer.",
            "Weaknesses": [
                "Failure to clear current->clear_child_tid pointer during execve."
            ],
             "Impact": "Local users can cause a denial of service (memory corruption) or possibly gain privileges via a clone system call with CLONE_CHILD_SETTID or CLONE_CHILD_CLEARTID enabled.",
            "AttackVectors": [
                 "A local user can exploit this vulnerability by using a clone system call with CLONE_CHILD_SETTID or CLONE_CHILD_CLEARTID enabled."
            ],
            "AttackerCapabilities": "Local user access."
        },
      {
            "Source": "lists.opensuse.org_be9d3dfe_20250125_222019.html",
            "RootCause": "The execve function in the Linux kernel did not properly clear the current->clear_child_tid pointer.",
           "Weaknesses": [
             "Improper handling of `current->clear_child_tid` pointer during `execve`."
             ],
            "Impact": "Local users can cause a denial of service (memory corruption) or possibly gain privileges via a clone system call with CLONE_CHILD_SETTID or CLONE_CHILD_CLEARTID enabled.",
            "AttackVectors": [
                 "Local users can exploit a clone system call with CLONE_CHILD_SETTID or CLONE_CHILD_CLEARTID to trigger memory corruption"
             ],
           "AttackerCapabilities": "Local user access"
        },
        {
          "Source": "www.redhat.com_feb90a20_20250126_122413.html",
          "RootCause": "The vulnerability is due to the `execve` function in the Linux kernel not properly clearing the `current->clear_child_tid` pointer.",
          "Weaknesses": [
            "Inadequate handling of the `current->clear_child_tid` pointer during the `execve` system call.",
            "Failure to reset pointer upon process execution"
           ],
          "Impact": "A local user could trigger memory corruption leading to a denial of service, or possibly, a privilege escalation by exploiting the vulnerability through clone system calls using the CLONE_CHILD_SETTID or CLONE_CHILD_CLEARTID flags.",
         "AttackVectors": [
             "Local attacker can trigger a clone system call with CLONE_CHILD_SETTID or CLONE_CHILD_CLEARTID flags which is not properly handled during thread creation and exit.",
              "This leads to memory corruption."
           ],
         "AttackerCapabilities":"Local user access is required to trigger this vulnerability."
        },
    {
            "Source": "www.redhat.com_a8f6a093_20250126_122405.html",
             "RootCause": "The `execve` function in the Linux kernel does not properly clear the `current->clear_child_tid` pointer",
             "Weaknesses": [
               "Improper pointer handling in `execve` function related to child thread IDs.",
               "Lack of reset of the `current->clear_child_tid` pointer in execve."
            ],
            "Impact": "Local users can cause a denial of service by corrupting memory, and may be able to gain privileges.",
            "AttackVectors": [
             "Exploitation involves a local user making a `clone` system call with the flags `CLONE_CHILD_SETTID` or `CLONE_CHILD_CLEARTID` enabled."
             ],
            "AttackerCapabilities": "The attacker must have local access to the system."
        },
      {
        "Source": "rhn.redhat.com_d3f8f3d4_20250125_222020.html",
        "RootCause": "The Linux kernel's `execve` function fails to properly clear the `clear_child_tid` pointer.",
        "Weaknesses": [
         "The `execve` function does not reset the `clear_child_tid` pointer.",
         "This improper handling of the pointer allows a local user to cause memory corruption."
        ],
        "Impact": "Local users can trigger a denial-of-service via memory corruption or potentially gain unauthorized privileges.",
        "AttackVectors": [
         "Triggered by using the `clone` syscall with either `CLONE_CHILD_SETTID` or `CLONE_CHILD_CLEARTID` flags.",
            "Improper handling of pointer during thread creation and exit"
        ],
        "AttackerCapabilities": "Local access is required to exploit this vulnerability."
      },
      {
         "Source": "www.redhat.com_2030f80e_20250125_222038.html",
            "RootCause": "The `execve` function in the Linux kernel does not properly clear the `current->clear_child_tid` pointer.",
           "Weaknesses": [
                "The kernel fails to clear the pointer, which leads to memory corruption.",
                "The vulnerability occurs when using the clone system call with flags."
            ],
             "Impact": "Local users can cause a denial of service or potentially gain privileges due to memory corruption.",
             "AttackVectors": [
              "Local users with access to use the clone system call with CLONE_CHILD_SETTID or CLONE_CHILD_CLEARTID enabled can exploit this vulnerability.",
               " Improper handling during thread creation and exit causes memory corruption"
             ],
            "AttackerCapabilities": "Local user access."
      },
        {
            "Source": "bugzilla.redhat.com_ee739e5d_20250126_122411.html",
           "RootCause": "The vulnerability lies in the kernel's `execve` function, where the `current->clear_child_tid` pointer is not properly cleared.",
            "Weaknesses": [
                "The kernel fails to properly clear the `current->clear_child_tid` pointer in the `execve` function.",
                 "Use of `clone()` with `CLONE_CHILD_SETTID` or `CLONE_CHILD_CLEARTID` flag is required to trigger the vulnerability."
             ],
             "Impact": "Local users may cause memory corruption leading to a denial of service and potential privilege escalation.",
              "AttackVectors": [
                 "This vulnerability is triggered by a local user using the clone system call with either the CLONE_CHILD_SETTID or CLONE_CHILD_CLEARTID flags enabled. "
               ],
             "AttackerCapabilities": "Local access is required for successful exploitation."
      },
    {
        "Source":"www.redhat.com_1c019cbe_20250126_122413.html",
        "RootCause": "The `execve` function in the Linux kernel did not properly clear the `current->clear_child_tid` pointer.",
        "Weaknesses": [
          "The kernel fails to clear the `current->clear_child_tid` pointer during the execve process",
          "Incorrect handling of thread creation and exit when using CLONE_CHILD_SETTID or CLONE_CHILD_CLEARTID."
        ],
         "Impact": "Local users can cause a denial of service through memory corruption or gain elevated privileges.",
         "AttackVectors": [
           "Triggered by a clone system call with CLONE_CHILD_SETTID or CLONE_CHILD_CLEARTID flags enabled during thread creation and exit.",
             "This leads to memory corruption."
            ],
        "AttackerCapabilities":"A local user can exploit this vulnerability."
    },
      {
        "Source": "www.openwall.com_5694474b_20250125_222035.html",
           "RootCause": "The kernel keeps a user-provided pointer `current->clear_child_tid` and fails to clear it on `execve()`.",
           "Weaknesses": [
            "The kernel keeps a user-controlled pointer across `execve()` calls.",
           "The `clear_child_tid` pointer is not reset in the kernel prior to the execve() syscall."
          ],
          "Impact": "Local users can cause memory corruption, potentially leading to privilege escalation.",
           "AttackVectors": [
              "Local users exploit this vulnerability by using clone() with specific flags that result in a user-controlled pointer being stored.",
              "During `execve()` this pointer is not reset."

          ],
            "AttackerCapabilities": "Local user access is required to trigger this vulnerability."
        },
     {
         "Source":"www.openwall.com_bca37ab1_20250125_222036.html",
         "RootCause":"The kernel does not reset clear_child_tid on exec of set{u,g}id executables, potentially allowing memory corruption.",
         "Weaknesses":[
             "The clear_child_tid pointer is not reset in the `execve` system call, which replaces the user's memory with a new one.",
             "The pointer value is not cleared, which can point to an arbitrary location in memory"
          ],
         "Impact":"Local users can cause a denial of service or gain privileges by corrupting 4 bytes in a persistent memory area.",
          "AttackVectors":[
             "A local user can cause a memory corruption via `clone()` syscall using `CLONE_CHILD_SETTID` and/or `CLONE_CHILD_CLEARTID` flags.",
              "Then an `execve()` syscall is called, and then if the new process does not clear the pointer, a memory corruption can occur on exit"
          ],
          "AttackerCapabilities":"Local user access is required."
        },
      {
          "Source": "secunia.com_a9991e0f_20250125_222024.html",
          "RootCause": "The execve function in the Linux kernel does not properly clear the current->clear_child_tid pointer.",
          "Weaknesses": [
            "Improper handling of the current->clear_child_tid pointer in the execve function.",
            "Vulnerability is exposed when using clone with CLONE_CHILD_SETTID or CLONE_CHILD_CLEARTID"
             ],
          "Impact": "A local attacker could exploit this to gain privileges or crash the system, leading to a denial of service.",
         "AttackVectors": [
            "Local users exploit this by invoking the clone method with incorrect memory access"
            ],
          "AttackerCapabilities": "Local user access is required to trigger this vulnerability."
        },
         {
        "Source":"secunia.com_d3b49c2d_20250125_222026.html",
        "RootCause":"The vulnerability is caused by the `execve` function failing to clear the `current->clear_child_tid` pointer.",
        "Weaknesses": [
            "Failure to clear the `current->clear_child_tid` pointer during the `execve` call.",
           "This leaves a user provided pointer which will corrupt memory during a thread exit"
        ],
        "Impact":"Local users can cause memory corruption, potentially leading to denial of service or privilege escalation.",
         "AttackVectors": [
           "This vulnerability is triggered when a user executes a clone system call with `CLONE_CHILD_SETTID` or `CLONE_CHILD_CLEARTID` set.",
            "The kernel then fails to clear this pointer, leading to the vulnerability."
         ],
         "AttackerCapabilities":"Local user access to the machine."
      }
    ]
  }
}
```