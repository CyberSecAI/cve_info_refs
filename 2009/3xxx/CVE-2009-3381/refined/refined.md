```
{
  "cveId": "CVE-2009-3381",
  "relatedBugs": [
    {
      "bugId": "502168",
      "summary": "Duplicated content with <embed> inside table markup",
      "details": {
        "rootCause": "The content sink was double-notifying content due to improper handling of leaf tags during flushing.",
        "weaknesses": [
          "Improper handling of leaf tags during content flushing.",
          "Incorrect mutation of the frame tree"
        ],
        "impact": "Duplicated content rendering, making navigation impossible.",
        "attackVectors": "Loading a crafted HTML page with a specific structure involving <embed> tags within tables.",
        "requiredCapabilities": "Ability to load a specially crafted HTML page.",
		"fixes": [
			"Modified content flushing to process leaf tags properly.",
			"Ensured proper handling of insertion points during content updates."
		]
      }
    },
    {
      "bugId": "513394",
      "summary": "\"ASSERTION: Some PresArena objects were not freed\" with -moz-column, list-item, float, :after",
      "details": {
        "rootCause": "Incorrect handling of the mPrevChild attribute in nsBlockReflowState during line reflow.",
        "weaknesses": [
          "Improper management of PresArena objects.",
          "Incorrect handling of child relationships in line reflow."
        ],
        "impact": "Memory leak and assertion failure, which can lead to crashes.",
        "attackVectors": "Loading a crafted HTML page with specific CSS styles involving -moz-column, list-item, float, and :after.",
        "requiredCapabilities": "Ability to load a specially crafted HTML page.",
		 "fixes": [
			 "Corrected the logic for setting next sibling during line reflow.",
			 "Addressed memory leak by fixing how PresArena objects are freed.",
			 "Added an assertion to catch the issue in the future."
		 ]
      }
    },
        {
      "bugId": "503196",
      "summary": "[Mac] Crash in [@ nsBaseWidget::Destroy() ] while printing",
      "details": {
        "rootCause": "Accessing a deleted object due to incorrect management of child relationships during widget destruction.",
		"weaknesses": [
			"Incorrect iteration through parent's children",
			"Race condition when parent is destroyed before a child is",
			"Dangling pointer to parent widget"
		],
        "impact": "Crash while printing due to accessing a deleted object.",
        "attackVectors": "Printing a specially crafted HTML page on macOS.",
        "requiredCapabilities": "Ability to load a specially crafted HTML page and initiate a print operation on macOS.",
		"fixes": [
			"Modified the destruction logic to iterate through the children using the correct list, removing the dangling pointer."
		]
      }
    },
    {
      "bugId": "516709",
      "summary": "Exploitable - User Mode Write AV starting at USP10!LoadCmapFontGlyphs+0x0000000000000059",
      "details": {
        "rootCause": "Use of an invalid codepoint in a malformed cmap table in a font, leading to an out-of-bounds write during font processing by Uniscribe.",
		"weaknesses": [
			"Inadequate validation of font data and codepoints",
			"Out-of-bounds write due to an invalid codepoint",
			"Reliance on external library which is not validating input properly"
		],
        "impact": "User mode write access violation, which could be exploited for arbitrary code execution.",
        "attackVectors": "Loading a web page that uses a specially crafted font with a malformed cmap table.",
        "requiredCapabilities": "Ability to load a web page with a crafted font and/or using the `@font-face` CSS rule.",
		"fixes": [
			"Added checks to validate codepoint ranges in cmap tables during font loading.",
			"Rejected fonts with invalid codepoints and/or malformed cmaps.",
			"Distinguished between missing cmaps from corrupted ones."
		]
      }
    },
    {
      "bugId": "508057",
      "summary": "crash [@ imgRequestProxy::OnStopRequest(nsIRequest*, nsISupports*, unsigned int, int) ] Classic Compact theme",
       "details": {
        "rootCause": "A race condition caused a crash when an nsImageBoxFrame calls Cancel() in UpdateImage() but then goes away shortly thereafter.",
		"weaknesses": [
			"Race condition with image loading and cancellation",
			"Dangling pointer after object destruction"
		],
        "impact": "Crash in `imgRequestProxy::OnStopRequest` function when using the Classic Compact theme and navigating bookmarks.",
        "attackVectors": "Using a specific Firefox theme (Classic Compact) and triggering image loading while using the bookmark organizer.",
        "requiredCapabilities": "Install the Classic Compact theme and use the bookmark manager.",
		"fixes": [
			"Changed Cancel() call to CancelAndForgetObserver() to prevent crash due to object destruction order."
		]
      }
    }
  ],
   "advisory": {
    "description": "Mozilla developers and community members identified and fixed several stability bugs in the browser engine used in Firefox and other Mozilla-based products. Some of these crashes showed evidence of memory corruption under certain circumstances and we presume that with enough effort at least some of these could be exploited to run arbitrary code.",
    "workaround": "Disable JavaScript until a version containing these fixes can be installed."
  }
}
```