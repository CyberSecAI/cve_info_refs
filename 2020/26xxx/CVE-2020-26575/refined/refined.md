```
{
  "guidelines": "1. First verify if the content relates to the CVE specified based on the official description\n2. If the content does not relate to this CVE, respond with \"UNRELATED\"\n3. If no useful vulnerability information is found, respond with \"NOINFO\" \n4. For relevant content, extract:\n   - Root cause of vulnerability\n   - Weaknesses/vulnerabilities present\n   - Impact of exploitation\n   - Attack vectors\n   - Required attacker capabilities/position\n\nAdditional instructions:\n- Preserve original technical details and descriptions\n- Remove unrelated content\n- Translate non-English content to English\n- Note if the content provides more detail than the official CVE description",
  "response": {
    "CVE-2020-26575": {
      "root_cause": "The FBZERO dissector in Wireshark incorrectly calculates the tag offset, leading to an infinite loop.",
      "vulnerabilities": [
        "Incorrect tag offset calculation in `epan/dissectors/packet-fbzero.c`",
        "Integer overflow due to a large, controlled `total_tag_len` calculation.",
        "Infinite loop due to incorrect offset calculation, resulting in continuous memory allocation."
      ],
      "impact": "Denial of Service (DoS) by causing Wireshark to consume excessive CPU and memory resources. The application becomes unresponsive and may crash due to exhaustion of system resources.",
       "attack_vectors": [
        "Injecting a malformed FBZERO packet onto the wire.",
        "Convincing a user to open a malformed packet trace file containing a specially crafted FBZERO packet."
      ],
      "attacker_capabilities": "The attacker needs to be able to craft a specific type of FBZERO packet and either inject it into the network or provide the packet trace to a victim. No special capabilities or privileges are required.",
      "details": "The vulnerability lies in the `dissect_fb_zero_tag` function within `epan/dissectors/packet-fbzero.c`. When the `tag` has no implemented case (default case in switch statement), the `tag_offset` is incorrectly incremented by `tag_len` directly, where `tag_len` is calculated from the beginning of the packet rather than the `tag_offset_start`. This causes the `tag_offset` to become larger than the correct offset. Subsequent calls to `tvb_reported_length_remaining` then always return 0. The `total_tag_len` is then also incorrectly calculated, leading to an integer overflow in the addition of `offset + total_tag_len`, resulting in a small offset and thus the infinite loop. The continuous memory allocation within this loop results in exhaustion of system resources and a denial of service."
    }
  }
}
```