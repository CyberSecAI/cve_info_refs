=== Content from lkml.org_831632b2_20250119_122058.html ===


| [lkml.org](/) | Â | [[lkml]](/lkml) Â  [[2020]](/lkml/2020) Â  [[Sep]](/lkml/2020/9) Â  [[15]](/lkml/2020/9/15) Â  [[last100]](/lkml/last100) Â  [RSS Feed](/rss.php)Views: [wrap][no wrap] Â  [[headers]](/lkml/mheaders/2020/9/15/1871)Â  [[forward]](/lkml/bounce/2020/9/15/1871)Â | Â |
| --- | --- | --- | --- |
| Messages in this thread  * [First message in thread](/lkml/2020/9/15/1871) * [Eric Snowberg](/lkml/2020/9/16/580)   + [Jarkko Sakkinen](/lkml/2020/9/16/580)   + [David Howells](/lkml/2020/12/10/276)     - [Eric Snowberg](/lkml/2020/12/10/1191)       * [David Howells](/lkml/2021/1/12/801)         + [Jarkko Sakkinen](/lkml/2021/1/13/1033)       * [David Howells](/lkml/2021/1/12/1050)         + [Eric Snowberg](/lkml/2021/1/12/1230)   + [James Bottomley](/lkml/2021/1/15/1041)     - [Eric Snowberg](/lkml/2021/1/15/1499)  Patch in this message  * [Get diff 1](/lkml/diff/2020/9/15/1871/1) | / | | | From | Eric Snowberg <> | | --- | --- | | Subject | [PATCH v4] certs: Add EFI\_CERT\_X509\_GUID support for dbx entries | | Date | Tue, 15 Sep 2020 20:49:27 -0400 | |  | | --- | --- | --- | --- | --- | --- | --- | --- |  ``` The Secure Boot Forbidden Signature Database, dbx, contains a list of nowrevoked signatures and keys previously approved to boot with UEFI SecureBoot enabled.  The dbx is capable of containing any number ofEFI_CERT_X509_SHA256_GUID, EFI_CERT_SHA256_GUID, and EFI_CERT_X509_GUIDentries.Currently when EFI_CERT_X509_GUID are contained in the dbx, the entries areskipped.Add support for EFI_CERT_X509_GUID dbx entries. When a EFI_CERT_X509_GUIDis found, it is added as an asymmetrical key to the .blacklist keyring.Anytime the .platform keyring is used, the keys in the .blacklist keyringare referenced, if a matching key is found, the key will be rejected.Signed-off-by: Eric Snowberg <eric.snowberg@oracle.com>---v4:Remove unneeded symbol export found by Jarkko Sakkinenv3:Fixed an issue when CONFIG_PKCS7_MESSAGE_PARSER is not builtin and definedas a module instead, pointed out by Randy Dunlapv2: Fixed build issue reported by kernel test robot <lkp@intel.com>Commit message update (suggested by Jarkko Sakkinen)--- certs/blacklist.c                             | 32 +++++++++++++++++++ certs/blacklist.h                             | 12 +++++++ certs/system_keyring.c                        |  6 ++++ include/keys/system_keyring.h                 | 11 +++++++ .../platform_certs/keyring_handler.c          | 11 +++++++ 5 files changed, 72 insertions(+)diff --git a/certs/blacklist.c b/certs/blacklist.cindex 6514f9ebc943..4adac7f8fd94 100644--- a/certs/blacklist.c+++ b/certs/blacklist.c@@ -100,6 +100,38 @@ int mark_hash_blacklisted(const char *hash) 	return 0; } +int mark_key_revocationlisted(const char *data, size_t size)+{+	key_ref_t key;++	key = key_create_or_update(make_key_ref(blacklist_keyring, true),+				   "asymmetric",+				   NULL,+				   data,+				   size,+				   ((KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_VIEW),+				   KEY_ALLOC_NOT_IN_QUOTA | KEY_ALLOC_BUILT_IN);++	if (IS_ERR(key)) {+		pr_err("Problem with revocation key (%ld)\n", PTR_ERR(key));+		return PTR_ERR(key);+	}++	return 0;+}++int is_key_revocationlisted(struct pkcs7_message *pkcs7)+{+	int ret;++	ret = validate_trust(pkcs7, blacklist_keyring);++	if (ret == 0)+		return -EKEYREJECTED;++	return -ENOKEY;+}+ /**  * is_hash_blacklisted - Determine if a hash is blacklisted  * @hash: The hash to be checked as a binary blobdiff --git a/certs/blacklist.h b/certs/blacklist.hindex 1efd6fa0dc60..420bb7c86e07 100644--- a/certs/blacklist.h+++ b/certs/blacklist.h@@ -1,3 +1,15 @@ #include <linux/kernel.h>+#include <linux/errno.h>+#include <crypto/pkcs7.h>  extern const char __initconst *const blacklist_hashes[];++#ifdef CONFIG_INTEGRITY_PLATFORM_KEYRING+#define validate_trust pkcs7_validate_trust+#else+static inline int validate_trust(struct pkcs7_message *pkcs7,+				 struct key *trust_keyring)+{+	return -ENOKEY;+}+#endifdiff --git a/certs/system_keyring.c b/certs/system_keyring.cindex 798291177186..f8ea96219155 100644--- a/certs/system_keyring.c+++ b/certs/system_keyring.c@@ -241,6 +241,12 @@ int verify_pkcs7_message_sig(const void *data, size_t len, 			pr_devel("PKCS#7 platform keyring is not available\n"); 			goto error; 		}++		ret = is_key_revocationlisted(pkcs7);+		if (ret != -ENOKEY) {+			pr_devel("PKCS#7 platform key revocationlisted\n");+			goto error;+		} 	} 	ret = pkcs7_validate_trust(pkcs7, trusted_keys); 	if (ret < 0) {diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.hindex fb8b07daa9d1..b6991cfe1b6d 100644--- a/include/keys/system_keyring.h+++ b/include/keys/system_keyring.h@@ -31,11 +31,14 @@ extern int restrict_link_by_builtin_and_secondary_trusted( #define restrict_link_by_builtin_and_secondary_trusted restrict_link_by_builtin_trusted #endif +extern struct pkcs7_message *pkcs7; #ifdef CONFIG_SYSTEM_BLACKLIST_KEYRING extern int mark_hash_blacklisted(const char *hash);+extern int mark_key_revocationlisted(const char *data, size_t size); extern int is_hash_blacklisted(const u8 *hash, size_t hash_len, 			       const char *type); extern int is_binary_blacklisted(const u8 *hash, size_t hash_len);+extern int is_key_revocationlisted(struct pkcs7_message *pkcs7); #else static inline int is_hash_blacklisted(const u8 *hash, size_t hash_len, 				      const char *type)@@ -47,6 +50,14 @@ static inline int is_binary_blacklisted(const u8 *hash, size_t hash_len) { 	return 0; }+static inline int mark_key_revocationlisted(const char *data, size_t size)+{+	return 0;+}+static inline int is_key_revocationlisted(struct pkcs7_message *pkcs7)+{+	return -ENOKEY;+} #endif  #ifdef CONFIG_IMA_BLACKLIST_KEYRINGdiff --git a/security/integrity/platform_certs/keyring_handler.c b/security/integrity/platform_certs/keyring_handler.cindex c5ba695c10e3..cc5a43804bc4 100644--- a/security/integrity/platform_certs/keyring_handler.c+++ b/security/integrity/platform_certs/keyring_handler.c@@ -55,6 +55,15 @@ static __init void uefi_blacklist_binary(const char *source, 	uefi_blacklist_hash(source, data, len, "bin:", 4); } +/*+ * Revocationlist the X509 cert+ */+static __init void uefi_revocationlist_x509(const char *source,+					    const void *data, size_t len)+{+	mark_key_revocationlisted(data, len);+}+ /*  * Return the appropriate handler for particular signature list types found in  * the UEFI db and MokListRT tables.@@ -76,5 +85,7 @@ __init efi_element_handler_t get_handler_for_dbx(const efi_guid_t *sig_type) 		return uefi_blacklist_x509_tbs; 	if (efi_guidcmp(*sig_type, efi_cert_sha256_guid) == 0) 		return uefi_blacklist_binary;+	if (efi_guidcmp(*sig_type, efi_cert_x509_guid) == 0)+		return uefi_revocationlist_x509; 	return 0; }-- 2.18.1 ``` | \ |
| Â |
| Â | \ | Â | / |
| Â | | Last update: 2020-09-16 02:53 Â Â  [from the cache]Â©2003-2020 [Jasper Spaans](http://blog.jasper.es/)|hosted at [Digital Ocean](https://www.digitalocean.com/?refcode=9a8e99d24cf9) and my Meterkast|[Read the blog](http://blog.jasper.es/categories.html#lkml-ref) | Â |


