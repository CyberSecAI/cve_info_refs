=== Content from github.com_15efae67_20250119_124241.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Foauthjs%2Fnode-oauth2-server%2Fblob%2F91d2cbe70a0eddc53d72def96864e2de0fd41703%2Flib%2Fvalidator%2Fis.js)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Foauthjs%2Fnode-oauth2-server%2Fblob%2F91d2cbe70a0eddc53d72def96864e2de0fd41703%2Flib%2Fvalidator%2Fis.js)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=oauthjs%2Fnode-oauth2-server)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[oauthjs](/oauthjs)
/
**[node-oauth2-server](/oauthjs/node-oauth2-server)**
Public

* [Notifications](/login?return_to=%2Foauthjs%2Fnode-oauth2-server) You must be signed in to change notification settings
* [Fork
  931](/login?return_to=%2Foauthjs%2Fnode-oauth2-server)
* [Star
   4k](/login?return_to=%2Foauthjs%2Fnode-oauth2-server)

* [Code](/oauthjs/node-oauth2-server)
* [Issues
  159](/oauthjs/node-oauth2-server/issues)
* [Pull requests
  31](/oauthjs/node-oauth2-server/pulls)
* [Actions](/oauthjs/node-oauth2-server/actions)
* [Projects
  0](/oauthjs/node-oauth2-server/projects)
* [Wiki](/oauthjs/node-oauth2-server/wiki)
* [Security](/oauthjs/node-oauth2-server/security)
* [Insights](/oauthjs/node-oauth2-server/pulse)

Additional navigation options

* [Code](/oauthjs/node-oauth2-server)
* [Issues](/oauthjs/node-oauth2-server/issues)
* [Pull requests](/oauthjs/node-oauth2-server/pulls)
* [Actions](/oauthjs/node-oauth2-server/actions)
* [Projects](/oauthjs/node-oauth2-server/projects)
* [Wiki](/oauthjs/node-oauth2-server/wiki)
* [Security](/oauthjs/node-oauth2-server/security)
* [Insights](/oauthjs/node-oauth2-server/pulse)

## Files

 91d2cbe
## Breadcrumbs

1. [node-oauth2-server](/oauthjs/node-oauth2-server/tree/91d2cbe70a0eddc53d72def96864e2de0fd41703)
2. /[lib](/oauthjs/node-oauth2-server/tree/91d2cbe70a0eddc53d72def96864e2de0fd41703/lib)
3. /[validator](/oauthjs/node-oauth2-server/tree/91d2cbe70a0eddc53d72def96864e2de0fd41703/lib/validator)
/
# is.js

Copy path Blame  Blame
## Latest commit

## History

[History](/oauthjs/node-oauth2-server/commits/91d2cbe70a0eddc53d72def96864e2de0fd41703/lib/validator/is.js)81 lines (66 loc) · 1.75 KB 91d2cbe
## Breadcrumbs

1. [node-oauth2-server](/oauthjs/node-oauth2-server/tree/91d2cbe70a0eddc53d72def96864e2de0fd41703)
2. /[lib](/oauthjs/node-oauth2-server/tree/91d2cbe70a0eddc53d72def96864e2de0fd41703/lib)
3. /[validator](/oauthjs/node-oauth2-server/tree/91d2cbe70a0eddc53d72def96864e2de0fd41703/lib/validator)
/
# is.js

Top
## File metadata and controls

* Code
* Blame

81 lines (66 loc) · 1.75 KB[Raw](https://github.com/oauthjs/node-oauth2-server/raw/91d2cbe70a0eddc53d72def96864e2de0fd41703/lib/validator/is.js)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081'use strict';
/\*\* \* Validation rules. \*/
var rules = { NCHAR: /^[\u002D|\u002E|\u005F|\w]+$/, NQCHAR: /^[\u0021|\u0023-\u005B|\u005D-\u007E]+$/, NQSCHAR: /^[\u0020-\u0021|\u0023-\u005B|\u005D-\u007E]+$/, UNICODECHARNOCRLF: /^[\u0009|\u0020-\u007E|\u0080-\uD7FF|\uE000-\uFFFD|\u10000-\u10FFFF]+$/, URI: /^[a-zA-Z][a-zA-Z0-9+.-]+:/, VSCHAR: /^[\u0020-\u007E]+$/};
/\*\* \* Export validation functions. \*/
module.exports = {
 /\*\* \* Validate if a value matches a unicode character. \* \* @see https://tools.ietf.org/html/rfc6749#appendix-A \*/
 nchar: function(value) { return rules.NCHAR.test(value); },
 /\*\* \* Validate if a value matches a unicode character, including exclamation marks. \* \* @see https://tools.ietf.org/html/rfc6749#appendix-A \*/
 nqchar: function(value) { return rules.NQCHAR.test(value); },
 /\*\* \* Validate if a value matches a unicode character, including exclamation marks and spaces. \* \* @see https://tools.ietf.org/html/rfc6749#appendix-A \*/
 nqschar: function(value) { return rules.NQSCHAR.test(value); },
 /\*\* \* Validate if a value matches a unicode character excluding the carriage \* return and linefeed characters. \* \* @see https://tools.ietf.org/html/rfc6749#appendix-A \*/
 uchar: function(value) { return rules.UNICODECHARNOCRLF.test(value); },
 /\*\* \* Validate if a value matches generic URIs. \* \* @see http://tools.ietf.org/html/rfc3986#section-3 \*/ uri: function(value) { return rules.URI.test(value); },
 /\*\* \* Validate if a value matches against the printable set of unicode characters. \* \* @see https://tools.ietf.org/html/rfc6749#appendix-A \*/
 vschar: function(value) { return rules.VSCHAR.test(value); }};

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_e569c3f9_20250119_124240.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Foauthjs%2Fnode-oauth2-server%2Fblob%2F91d2cbe70a0eddc53d72def96864e2de0fd41703%2Flib%2Fgrant-types%2Fauthorization-code-grant-type.js)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Foauthjs%2Fnode-oauth2-server%2Fblob%2F91d2cbe70a0eddc53d72def96864e2de0fd41703%2Flib%2Fgrant-types%2Fauthorization-code-grant-type.js)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=oauthjs%2Fnode-oauth2-server)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[oauthjs](/oauthjs)
/
**[node-oauth2-server](/oauthjs/node-oauth2-server)**
Public

* [Notifications](/login?return_to=%2Foauthjs%2Fnode-oauth2-server) You must be signed in to change notification settings
* [Fork
  931](/login?return_to=%2Foauthjs%2Fnode-oauth2-server)
* [Star
   4k](/login?return_to=%2Foauthjs%2Fnode-oauth2-server)

* [Code](/oauthjs/node-oauth2-server)
* [Issues
  159](/oauthjs/node-oauth2-server/issues)
* [Pull requests
  31](/oauthjs/node-oauth2-server/pulls)
* [Actions](/oauthjs/node-oauth2-server/actions)
* [Projects
  0](/oauthjs/node-oauth2-server/projects)
* [Wiki](/oauthjs/node-oauth2-server/wiki)
* [Security](/oauthjs/node-oauth2-server/security)
* [Insights](/oauthjs/node-oauth2-server/pulse)

Additional navigation options

* [Code](/oauthjs/node-oauth2-server)
* [Issues](/oauthjs/node-oauth2-server/issues)
* [Pull requests](/oauthjs/node-oauth2-server/pulls)
* [Actions](/oauthjs/node-oauth2-server/actions)
* [Projects](/oauthjs/node-oauth2-server/projects)
* [Wiki](/oauthjs/node-oauth2-server/wiki)
* [Security](/oauthjs/node-oauth2-server/security)
* [Insights](/oauthjs/node-oauth2-server/pulse)

## Files

 91d2cbe
## Breadcrumbs

1. [node-oauth2-server](/oauthjs/node-oauth2-server/tree/91d2cbe70a0eddc53d72def96864e2de0fd41703)
2. /[lib](/oauthjs/node-oauth2-server/tree/91d2cbe70a0eddc53d72def96864e2de0fd41703/lib)
3. /[grant-types](/oauthjs/node-oauth2-server/tree/91d2cbe70a0eddc53d72def96864e2de0fd41703/lib/grant-types)
/
# authorization-code-grant-type.js

Copy path Blame  Blame
## Latest commit

## History

[History](/oauthjs/node-oauth2-server/commits/91d2cbe70a0eddc53d72def96864e2de0fd41703/lib/grant-types/authorization-code-grant-type.js)206 lines (167 loc) · 5.82 KB 91d2cbe
## Breadcrumbs

1. [node-oauth2-server](/oauthjs/node-oauth2-server/tree/91d2cbe70a0eddc53d72def96864e2de0fd41703)
2. /[lib](/oauthjs/node-oauth2-server/tree/91d2cbe70a0eddc53d72def96864e2de0fd41703/lib)
3. /[grant-types](/oauthjs/node-oauth2-server/tree/91d2cbe70a0eddc53d72def96864e2de0fd41703/lib/grant-types)
/
# authorization-code-grant-type.js

Top
## File metadata and controls

* Code
* Blame

206 lines (167 loc) · 5.82 KB[Raw](https://github.com/oauthjs/node-oauth2-server/raw/91d2cbe70a0eddc53d72def96864e2de0fd41703/lib/grant-types/authorization-code-grant-type.js)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206'use strict';
/\*\* \* Module dependencies. \*/
var AbstractGrantType = require('./abstract-grant-type');var InvalidArgumentError = require('../errors/invalid-argument-error');var InvalidGrantError = require('../errors/invalid-grant-error');var InvalidRequestError = require('../errors/invalid-request-error');var Promise = require('bluebird');var promisify = require('promisify-any').use(Promise);var ServerError = require('../errors/server-error');var is = require('../validator/is');var util = require('util');
/\*\* \* Constructor. \*/
function AuthorizationCodeGrantType(options) { options = options || {};
 if (!options.model) { throw new InvalidArgumentError('Missing parameter: `model`'); }
 if (!options.model.getAuthorizationCode) { throw new InvalidArgumentError('Invalid argument: model does not implement `getAuthorizationCode()`'); }
 if (!options.model.revokeAuthorizationCode) { throw new InvalidArgumentError('Invalid argument: model does not implement `revokeAuthorizationCode()`'); }
 if (!options.model.saveToken) { throw new InvalidArgumentError('Invalid argument: model does not implement `saveToken()`'); }
 AbstractGrantType.call(this, options);}
/\*\* \* Inherit prototype. \*/
util.inherits(AuthorizationCodeGrantType, AbstractGrantType);
/\*\* \* Handle authorization code grant. \* \* @see https://tools.ietf.org/html/rfc6749#section-4.1.3 \*/
AuthorizationCodeGrantType.prototype.handle = function(request, client) { if (!request) { throw new InvalidArgumentError('Missing parameter: `request`'); }
 if (!client) { throw new InvalidArgumentError('Missing parameter: `client`'); }
 return Promise.bind(this) .then(function() { return this.getAuthorizationCode(request, client); }) .tap(function(code) { return this.validateRedirectUri(request, code); }) .tap(function(code) { return this.revokeAuthorizationCode(code); }) .then(function(code) { return this.saveToken(code.user, client, code.authorizationCode, code.scope); });};
/\*\* \* Get the authorization code. \*/
AuthorizationCodeGrantType.prototype.getAuthorizationCode = function(request, client) { if (!request.body.code) { throw new InvalidRequestError('Missing parameter: `code`'); }
 if (!is.vschar(request.body.code)) { throw new InvalidRequestError('Invalid parameter: `code`'); } return promisify(this.model.getAuthorizationCode, 1).call(this.model, request.body.code) .then(function(code) { if (!code) { throw new InvalidGrantError('Invalid grant: authorization code is invalid'); }
 if (!code.client) { throw new ServerError('Server error: `getAuthorizationCode()` did not return a `client` object'); }
 if (!code.user) { throw new ServerError('Server error: `getAuthorizationCode()` did not return a `user` object'); }
 if (code.client.id !== client.id) { throw new InvalidGrantError('Invalid grant: authorization code is invalid'); }
 if (!(code.expiresAt instanceof Date)) { throw new ServerError('Server error: `expiresAt` must be a Date instance'); }
 if (code.expiresAt < new Date()) { throw new InvalidGrantError('Invalid grant: authorization code has expired'); }
 if (code.redirectUri && !is.uri(code.redirectUri)) { throw new InvalidGrantError('Invalid grant: `redirect\_uri` is not a valid URI'); }
 return code; });};
/\*\* \* Validate the redirect URI. \* \* "The authorization server MUST ensure that the redirect\_uri parameter is \* present if the redirect\_uri parameter was included in the initial \* authorization request as described in Section 4.1.1, and if included \* ensure that their values are identical." \* \* @see https://tools.ietf.org/html/rfc6749#section-4.1.3 \*/
 AuthorizationCodeGrantType.prototype.validateRedirectUri = function(request, code) { if (!code.redirectUri) { return; }
 var redirectUri = request.body.redirect\_uri || request.query.redirect\_uri;
 if (!is.uri(redirectUri)) { throw new InvalidRequestError('Invalid request: `redirect\_uri` is not a valid URI'); }
 if (redirectUri !== code.redirectUri) { throw new InvalidRequestError('Invalid request: `redirect\_uri` is invalid'); } };
/\*\* \* Revoke the authorization code. \* \* "The authorization code MUST expire shortly after it is issued to mitigate \* the risk of leaks. [...] If an authorization code is used more than once, \* the authorization server MUST deny the request." \* \* @see https://tools.ietf.org/html/rfc6749#section-4.1.2 \*/
AuthorizationCodeGrantType.prototype.revokeAuthorizationCode = function(code) { return promisify(this.model.revokeAuthorizationCode, 1).call(this.model, code) .then(function(status) { if (!status) { throw new InvalidGrantError('Invalid grant: authorization code is invalid'); }
 return code; });};
/\*\* \* Save token. \*/
AuthorizationCodeGrantType.prototype.saveToken = function(user, client, authorizationCode, scope) { var fns = [ this.validateScope(user, client, scope), this.generateAccessToken(client, user, scope), this.generateRefreshToken(client, user, scope), this.getAccessTokenExpiresAt(), this.getRefreshTokenExpiresAt() ];
 return Promise.all(fns) .bind(this) .spread(function(scope, accessToken, refreshToken, accessTokenExpiresAt, refreshTokenExpiresAt) { var token = { accessToken: accessToken, authorizationCode: authorizationCode, accessTokenExpiresAt: accessTokenExpiresAt, refreshToken: refreshToken, refreshTokenExpiresAt: refreshTokenExpiresAt, scope: scope };
 return promisify(this.model.saveToken, 3).call(this.model, token, client, user); });};
/\*\* \* Export constructor. \*/
module.exports = AuthorizationCodeGrantType;

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from tools.ietf.org_f028d892_20250119_124243.html ===


* Light
* Dark
* Auto

[RFC 6749

Proposed Standard](/doc/rfc6749/)

|  | Title |  | The OAuth 2.0 Authorization Framework |
| --- | --- | --- | --- |
| Document | Document type |  | RFC - Proposed Standard  October 2012  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=6749 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") [IPR](/ipr/search/?submit=draft&id=rfc6749 "Click to view IPR declarations.") Updated by [RFC 8252](/doc/html/rfc8252 "OAuth 2.0 for Native Apps"), [RFC 8996](/doc/html/rfc8996 "Deprecating TLS 1.0 and TLS 1.1") Obsoletes [RFC 5849](/doc/html/rfc5849 "The OAuth 1.0 Protocol") Was [draft-ietf-oauth-v2](/doc/draft-ietf-oauth-v2/31/) ([oauth WG](/wg/oauth/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [23](/doc/html/draft-ietf-oauth-v2-23) * [24](/doc/html/draft-ietf-oauth-v2-24) * [25](/doc/html/draft-ietf-oauth-v2-25) * [26](/doc/html/draft-ietf-oauth-v2-26) * [27](/doc/html/draft-ietf-oauth-v2-27) * [28](/doc/html/draft-ietf-oauth-v2-28) * [29](/doc/html/draft-ietf-oauth-v2-29) * [30](/doc/html/draft-ietf-oauth-v2-30) * [31](/doc/html/draft-ietf-oauth-v2-31) * [RFC 6749](/doc/html/rfc6749) |
|  | Compare versions |  | RFC 6749  draft-ietf-oauth-v2-31  draft-ietf-oauth-v2-30  draft-ietf-oauth-v2-29  draft-ietf-oauth-v2-28  draft-ietf-oauth-v2-27  draft-ietf-oauth-v2-26  draft-ietf-oauth-v2-25  draft-ietf-oauth-v2-24  draft-ietf-oauth-v2-23  draft-ietf-oauth-v2-22  draft-ietf-oauth-v2-21  draft-ietf-oauth-v2-20  draft-ietf-oauth-v2-19  draft-ietf-oauth-v2-18  draft-ietf-oauth-v2-17  draft-ietf-oauth-v2-16  draft-ietf-oauth-v2-15  draft-ietf-oauth-v2-14  draft-ietf-oauth-v2-13  draft-ietf-oauth-v2-12  draft-ietf-oauth-v2-11  draft-ietf-oauth-v2-10  draft-ietf-oauth-v2-09  draft-ietf-oauth-v2-08  draft-ietf-oauth-v2-07  draft-ietf-oauth-v2-06  draft-ietf-oauth-v2-05  draft-ietf-oauth-v2-04  draft-ietf-oauth-v2-03  draft-ietf-oauth-v2-02  draft-ietf-oauth-v2-01  draft-ietf-oauth-v2-00   RFC 6749  draft-ietf-oauth-v2-31  draft-ietf-oauth-v2-30  draft-ietf-oauth-v2-29  draft-ietf-oauth-v2-28  draft-ietf-oauth-v2-27  draft-ietf-oauth-v2-26  draft-ietf-oauth-v2-25  draft-ietf-oauth-v2-24  draft-ietf-oauth-v2-23  draft-ietf-oauth-v2-22  draft-ietf-oauth-v2-21  draft-ietf-oauth-v2-20  draft-ietf-oauth-v2-19  draft-ietf-oauth-v2-18  draft-ietf-oauth-v2-17  draft-ietf-oauth-v2-16  draft-ietf-oauth-v2-15  draft-ietf-oauth-v2-14  draft-ietf-oauth-v2-13  draft-ietf-oauth-v2-12  draft-ietf-oauth-v2-11  draft-ietf-oauth-v2-10  draft-ietf-oauth-v2-09  draft-ietf-oauth-v2-08  draft-ietf-oauth-v2-07  draft-ietf-oauth-v2-06  draft-ietf-oauth-v2-05  draft-ietf-oauth-v2-04  draft-ietf-oauth-v2-03  draft-ietf-oauth-v2-02  draft-ietf-oauth-v2-01  draft-ietf-oauth-v2-00   Side-by-side  Inline |
|  | Author |  | [Dick Hardt](/person/dick.hardt%40gmail.com "Datatracker profile of Dick Hardt")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc6749.txt) [html](https://www.rfc-editor.org/rfc/rfc6749.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc6749.txt.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc6749.html) [bibtex](/doc/rfc6749/bibtex/) |
|  | Additional resources |  | [Mailing list discussion](https://mailarchive.ietf.org/arch/browse/oauth/?q=rfc6749 OR %22draft-ietf-oauth-v2%22) |
|  |  |  | [Report a bug](https://github.com/ietf-tools/datatracker/issues/new/choose) |

```
Internet Engineering Task Force (IETF)                     D. Hardt, Ed.
Request for Comments: 6749                                     Microsoft
Obsoletes: [5849](/doc/html/rfc5849)                                             October 2012
Category: Standards Track
ISSN: 2070-1721

                 The OAuth 2.0 Authorization Framework

Abstract

   The OAuth 2.0 authorization framework enables a third-party
   application to obtain limited access to an HTTP service, either on
   behalf of a resource owner by orchestrating an approval interaction
   between the resource owner and the HTTP service, or by allowing the
   third-party application to obtain access on its own behalf.  This
   specification replaces and obsoletes the OAuth 1.0 protocol described
   in [RFC 5849](/doc/html/rfc5849).

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in [Section 2 of RFC 5741](/doc/html/rfc5741#section-2).

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <http://www.rfc-editor.org/info/rfc6749>.

Copyright Notice

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to [BCP 78](/doc/html/bcp78) and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<http://trustee.ietf.org/license-info>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Hardt                        Standards Track                    [Page 1]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

Table of Contents

   [1](#section-1). Introduction ....................................................[4](#page-4)
      [1.1](#section-1.1). Roles ......................................................[6](#page-6)
      [1.2](#section-1.2). Protocol Flow ..............................................[7](#page-7)
      [1.3](#section-1.3). Authorization Grant ........................................[8](#page-8)
           [1.3.1](#section-1.3.1). Authorization Code ..................................[8](#page-8)
           [1.3.2](#section-1.3.2). Implicit ............................................[8](#page-8)
           [1.3.3](#section-1.3.3). Resource Owner Password Credentials .................[9](#page-9)
           [1.3.4](#section-1.3.4). Client Credentials ..................................[9](#page-9)
      [1.4](#section-1.4). Access Token ..............................................[10](#page-10)
      [1.5](#section-1.5). Refresh Token .............................................[10](#page-10)
      [1.6](#section-1.6). TLS Version ...............................................[12](#page-12)
      [1.7](#section-1.7). HTTP Redirections .........................................[12](#page-12)
      [1.8](#section-1.8). Interoperability ..........................................[12](#page-12)
      [1.9](#section-1.9). Notational Conventions ....................................[13](#page-13)
   [2](#section-2). Client Registration ............................................[13](#page-13)
      [2.1](#section-2.1). Client Types ..............................................[14](#page-14)
      [2.2](#section-2.2). Client Identifier .........................................[15](#page-15)
      [2.3](#section-2.3). Client Authentication .....................................[16](#page-16)
           [2.3.1](#section-2.3.1). Client Password ....................................[16](#page-16)
           [2.3.2](#section-2.3.2). Other Authentication Methods .......................[17](#page-17)
      [2.4](#section-2.4). Unregistered Clients ......................................[17](#page-17)
   [3](#section-3). Protocol Endpoints .............................................[18](#page-18)
      [3.1](#section-3.1). Authorization Endpoint ....................................[18](#page-18)
           [3.1.1](#section-3.1.1). Response Type ......................................[19](#page-19)
           [3.1.2](#section-3.1.2). Redirection Endpoint ...............................[19](#page-19)
      [3.2](#section-3.2). Token Endpoint ............................................[21](#page-21)
           [3.2.1](#section-3.2.1). Client Authentication ..............................[22](#page-22)
      [3.3](#section-3.3). Access Token Scope ........................................[23](#page-23)
   [4](#section-4). Obtaining Authorization ........................................[23](#page-23)
      [4.1](#section-4.1). Authorization Code Grant ..................................[24](#page-24)
           [4.1.1](#section-4.1.1). Authorization Request ..............................[25](#page-25)
           [4.1.2](#section-4.1.2). Authorization Response .............................[26](#page-26)
           [4.1.3](#section-4.1.3). Access Token Request ...............................[29](#page-29)
           [4.1.4](#section-4.1.4). Access Token Response ..............................[30](#page-30)
      [4.2](#section-4.2). Implicit Grant ............................................[31](#page-31)
           [4.2.1](#section-4.2.1). Authorization Request ..............................[33](#page-33)
           [4.2.2](#section-4.2.2). Access Token Response ..............................[35](#page-35)
      [4.3](#section-4.3). Resource Owner Password Credentials Grant .................[37](#page-37)
           [4.3.1](#section-4.3.1). Authorization Request and Response .................[39](#page-39)
           [4.3.2](#section-4.3.2). Access Token Request ...............................[39](#page-39)
           [4.3.3](#section-4.3.3). Access Token Response ..............................[40](#page-40)
      [4.4](#section-4.4). Client Credentials Grant ..................................[40](#page-40)
           [4.4.1](#section-4.4.1). Authorization Request and Response .................[41](#page-41)
           [4.4.2](#section-4.4.2). Access Token Request ...............................[41](#page-41)
           [4.4.3](#section-4.4.3). Access Token Response ..............................[42](#page-42)
      [4.5](#section-4.5). Extension Grants ..........................................[42](#page-42)

Hardt                        Standards Track                    [Page 2]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   [5](#section-5). Issuing an Access Token ........................................[43](#page-43)
      [5.1](#section-5.1). Successful Response .......................................[43](#page-43)
      [5.2](#section-5.2). Error Response ............................................[45](#page-45)
   [6](#section-6). Refreshing an Access Token .....................................[47](#page-47)
   [7](#section-7). Accessing Protected Resources ..................................[48](#page-48)
      [7.1](#section-7.1). Access Token Types ........................................[49](#page-49)
      [7.2](#section-7.2). Error Response ............................................[49](#page-49)
   [8](#section-8). Extensibility ..................................................[50](#page-50)
      [8.1](#section-8.1). Defining Access Token Types ...............................[50](#page-50)
      [8.2](#section-8.2). Defining New Endpoint Parameters ..........................[50](#page-50)
      [8.3](#section-8.3). Defining New Authorization Grant Types ....................[51](#page-51)
      [8.4](#section-8.4). Defining New Authorization Endpoint Response Types ........[51](#page-51)
      [8.5](#section-8.5). Defining Additional Error Codes ...........................[51](#page-51)
   [9](#section-9). Native Applications ............................................[52](#page-52)
   [10](#section-10). Security Considerations .......................................[53](#page-53)
      [10.1](#section-10.1). Client Authentication ....................................[53](#page-53)
      [10.2](#section-10.2). Client Impersonation .....................................[54](#page-54)
      [10.3](#section-10.3). Access Tokens ............................................[55](#page-55)
      [10.4](#section-10.4). Refresh Tokens ...........................................[55](#page-55)
      [10.5](#section-10.5). Authorization Codes ......................................[56](#page-56)
      [10.6](#section-10.6). Authorization Code Redirection URI Manipulation ..........[56](#page-56)
      [10.7](#section-10.7). Resource Owner Password Credentials ......................[57](#page-57)
      [10.8](#section-10.8). Request Confidentiality ..................................[58](#page-58)
      [10.9](#section-10.9). Ensuring Endpoint Authenticity ...........................[58](#page-58)
      [10.10](#section-10.10). Credentials-Guessing Attacks ............................[58](#page-58)
      [10.11](#section-10.11). Phishing Attacks ........................................[58](#page-58)
      [10.12](#section-10.12). Cross-Site Request Forgery ..............................[59](#page-59)
      [10.13](#section-10.13). Clickjacking ............................................[60](#page-60)
      [10.14](#section-10.14). Code Injection and Input Validation .....................[60](#page-60)
      [10.15](#section-10.15). Open Redirectors ........................................[60](#page-60)
      10.16. Misuse of Access Token to Impersonate Resource
             Owner in Implicit Flow ..................................[61](#page-61)
   [11](#section-11). IANA Considerations ...........................................[62](#page-62)
      [11.1](#section-11.1). OAuth Access Token Types Registry ........................[62](#page-62)
           [11.1.1](#section-11.1.1). Registration Template .............................[62](#page-62)
      [11.2](#section-11.2). OAuth Parameters Registry ................................[63](#page-63)
           [11.2.1](#section-11.2.1). Registration Template .............................[63](#page-63)
           [11.2.2](#section-11.2.2). Initial Registry Contents .........................[64](#page-64)
      [11.3](#section-11.3). OAuth Authorization Endpoint Response Types Registry .....[66](#page-66)
           [11.3.1](#section-11.3.1). Registration Template .............................[66](#page-66)
           [11.3.2](#section-11.3.2). Initial Registry Contents .........................[67](#page-67)
      [11.4](#section-11.4). OAuth Extensions Error Registry ..........................[67](#page-67)
           [11.4.1](#section-11.4.1). Registration Template .............................[68](#page-68)
   [12](#section-12). References ....................................................[68](#page-68)
      [12.1](#section-12.1). Normative References .....................................[68](#page-68)
      [12.2](#section-12.2). Informative References ...................................[70](#page-70)

Hardt                        Standards Track                    [Page 3]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   [Appendix A](#appendix-A). Augmented Backus-Naur Form (ABNF) Syntax ..............[71](#page-71)
     [A.1](#appendix-A.1).  "client_id" Syntax ........................................[71](#page-71)
     [A.2](#appendix-A.2).  "client_secret" Syntax ....................................[71](#page-71)
     [A.3](#appendix-A.3).  "response_type" Syntax ....................................[71](#page-71)
     [A.4](#appendix-A.4).  "scope" Syntax ............................................[72](#page-72)
     [A.5](#appendix-A.5).  "state" Syntax ............................................[72](#page-72)
     [A.6](#appendix-A.6).  "redirect_uri" Syntax .....................................[72](#page-72)
     [A.7](#appendix-A.7).  "error" Syntax ............................................[72](#page-72)
     [A.8](#appendix-A.8).  "error_description" Syntax ................................[72](#page-72)
     [A.9](#appendix-A.9).  "error_uri" Syntax ........................................[72](#page-72)
     [A.10](#appendix-A.10). "grant_type" Syntax .......................................[73](#page-73)
     [A.11](#appendix-A.11). "code" Syntax .............................................[73](#page-73)
     [A.12](#appendix-A.12). "access_token" Syntax .....................................[73](#page-73)
     [A.13](#appendix-A.13). "token_type" Syntax .......................................[73](#page-73)
     [A.14](#appendix-A.14). "expires_in" Syntax .......................................[73](#page-73)
     [A.15](#appendix-A.15). "username" Syntax .........................................[73](#page-73)
     [A.16](#appendix-A.16). "password" Syntax .........................................[73](#page-73)
     [A.17](#appendix-A.17). "refresh_token" Syntax ....................................[74](#page-74)
     [A.18](#appendix-A.18). Endpoint Parameter Syntax .................................[74](#page-74)
   [Appendix B](#appendix-B). Use of application/x-www-form-urlencoded Media Type ...[74](#page-74)
   [Appendix C](#appendix-C). Acknowledgements ......................................[75](#page-75)

[1](#section-1).  Introduction

   In the traditional client-server authentication model, the client
   requests an access-restricted resource (protected resource) on the
   server by authenticating with the server using the resource owner's
   credentials.  In order to provide third-party applications access to
   restricted resources, the resource owner shares its credentials with
   the third party.  This creates several problems and limitations:

   o  Third-party applications are required to store the resource
      owner's credentials for future use, typically a password in
      clear-text.

   o  Servers are required to support password authentication, despite
      the security weaknesses inherent in passwords.

   o  Third-party applications gain overly broad access to the resource
      owner's protected resources, leaving resource owners without any
      ability to restrict duration or access to a limited subset of
      resources.

   o  Resource owners cannot revoke access to an individual third party
      without revoking access to all third parties, and must do so by
      changing the third party's password.

Hardt                        Standards Track                    [Page 4]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   o  Compromise of any third-party application results in compromise of
      the end-user's password and all of the data protected by that
      password.

   OAuth addresses these issues by introducing an authorization layer
   and separating the role of the client from that of the resource
   owner.  In OAuth, the client requests access to resources controlled
   by the resource owner and hosted by the resource server, and is
   issued a different set of credentials than those of the resource
   owner.

   Instead of using the resource owner's credentials to access protected
   resources, the client obtains an access token -- a string denoting a
   specific scope, lifetime, and other access attributes.  Access tokens
   are issued to third-party clients by an authorization server with the
   approval of the resource owner.  The client uses the access token to
   access the protected resources hosted by the resource server.

   For example, an end-user (resource owner) can grant a printing
   service (client) access to her protected photos stored at a photo-
   sharing service (resource server), without sharing her username and
   password with the printing service.  Instead, she authenticates
   directly with a server trusted by the photo-sharing service
   (authorization server), which issues the printing service delegation-
   specific credentials (access token).

   This specification is designed for use with HTTP ([[RFC2616](/doc/html/rfc2616 "\"Hypertext Transfer Protocol -- HTTP/1.1\"")]).  The
   use of OAuth over any protocol other than HTTP is out of scope.

   The OAuth 1.0 protocol ([[RFC5849](/doc/html/rfc5849 "\"The OAuth 1.0 Protocol\"")]), published as an informational
   document, was the result of a small ad hoc community effort.  This
   Standards Track specification builds on the OAuth 1.0 deployment
   experience, as well as additional use cases and extensibility
   requirements gathered from the wider IETF community.  The OAuth 2.0
   protocol is not backward compatible with OAuth 1.0.  The two versions
   may co-exist on the network, and implementations may choose to
   support both.  However, it is the intention of this specification
   that new implementations support OAuth 2.0 as specified in this
   document and that OAuth 1.0 is used only to support existing
   deployments.  The OAuth 2.0 protocol shares very few implementation
   details with the OAuth 1.0 protocol.  Implementers familiar with
   OAuth 1.0 should approach this document without any assumptions as to
   its structure and details.

Hardt                        Standards Track                    [Page 5]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[1.1](#section-1.1).  Roles

   OAuth defines four roles:

   resource owner
      An entity capable of granting access to a protected resource.
      When the resource owner is a person, it is referred to as an
      end-user.

   resource server
      The server hosting the protected resources, capable of accepting
      and responding to protected resource requests using access tokens.

   client
      An application making protected resource requests on behalf of the
      resource owner and with its authorization.  The term "client" does
      not imply any particular implementation characteristics (e.g.,
      whether the application executes on a server, a desktop, or other
      devices).

   authorization server
      The server issuing access tokens to the client after successfully
      authenticating the resource owner and obtaining authorization.

   The interaction between the authorization server and resource server
   is beyond the scope of this specification.  The authorization server
   may be the same server as the resource server or a separate entity.
   A single authorization server may issue access tokens accepted by
   multiple resource servers.

Hardt                        Standards Track                    [Page 6]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[1.2](#section-1.2).  Protocol Flow

     +--------+                               +---------------+
     |        |--(A)- Authorization Request ->|   Resource    |
     |        |                               |     Owner     |
     |        |<-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant -->| Authorization |
     | Client |                               |     Server    |
     |        |<-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    Resource   |
     |        |                               |     Server    |
     |        |<-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+

                     Figure 1: Abstract Protocol Flow

   The abstract OAuth 2.0 flow illustrated in Figure 1 describes the
   interaction between the four roles and includes the following steps:

   (A)  The client requests authorization from the resource owner.  The
        authorization request can be made directly to the resource owner
        (as shown), or preferably indirectly via the authorization
        server as an intermediary.

   (B)  The client receives an authorization grant, which is a
        credential representing the resource owner's authorization,
        expressed using one of four grant types defined in this
        specification or using an extension grant type.  The
        authorization grant type depends on the method used by the
        client to request authorization and the types supported by the
        authorization server.

   (C)  The client requests an access token by authenticating with the
        authorization server and presenting the authorization grant.

   (D)  The authorization server authenticates the client and validates
        the authorization grant, and if valid, issues an access token.

Hardt                        Standards Track                    [Page 7]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   (E)  The client requests the protected resource from the resource
        server and authenticates by presenting the access token.

   (F)  The resource server validates the access token, and if valid,
        serves the request.

   The preferred method for the client to obtain an authorization grant
   from the resource owner (depicted in steps (A) and (B)) is to use the
   authorization server as an intermediary, which is illustrated in
   Figure 3 in [Section 4.1](#section-4.1).

[1.3](#section-1.3).  Authorization Grant

   An authorization grant is a credential representing the resource
   owner's authorization (to access its protected resources) used by the
   client to obtain an access token.  This specification defines four
   grant types -- authorization code, implicit, resource owner password
   credentials, and client credentials -- as well as an extensibility
   mechanism for defining additional types.

[1.3.1](#section-1.3.1).  Authorization Code

   The authorization code is obtained by using an authorization server
   as an intermediary between the client and resource owner.  Instead of
   requesting authorization directly from the resource owner, the client
   directs the resource owner to an authorization server (via its
   user-agent as defined in [[RFC2616](/doc/html/rfc2616 "\"Hypertext Transfer Protocol -- HTTP/1.1\"")]), which in turn directs the
   resource owner back to the client with the authorization code.

   Before directing the resource owner back to the client with the
   authorization code, the authorization server authenticates the
   resource owner and obtains authorization.  Because the resource owner
   only authenticates with the authorization server, the resource
   owner's credentials are never shared with the client.

   The authorization code provides a few important security benefits,
   such as the ability to authenticate the client, as well as the
   transmission of the access token directly to the client without
   passing it through the resource owner's user-agent and potentially
   exposing it to others, including the resource owner.

[1.3.2](#section-1.3.2).  Implicit

   The implicit grant is a simplified authorization code flow optimized
   for clients implemented in a browser using a scripting language such
   as JavaScript.  In the implicit flow, instead of issuing the client
   an authorization code, the client is issued an access token directly

Hardt                        Standards Track                    [Page 8]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   (as the result of the resource owner authorization).  The grant type
   is implicit, as no intermediate credentials (such as an authorization
   code) are issued (and later used to obtain an access token).

   When issuing an access token during the implicit grant flow, the
   authorization server does not authenticate the client.  In some
   cases, the client identity can be verified via the redirection URI
   used to deliver the access token to the client.  The access token may
   be exposed to the resource owner or other applications with access to
   the resource owner's user-agent.

   Implicit grants improve the responsiveness and efficiency of some
   clients (such as a client implemented as an in-browser application),
   since it reduces the number of round trips required to obtain an
   access token.  However, this convenience should be weighed against
   the security implications of using implicit grants, such as those
   described in Sections [10.3](#section-10.3) and [10.16](#section-10.16), especially when the
   authorization code grant type is available.

[1.3.3](#section-1.3.3).  Resource Owner Password Credentials

   The resource owner password credentials (i.e., username and password)
   can be used directly as an authorization grant to obtain an access
   token.  The credentials should only be used when there is a high
   degree of trust between the resource owner and the client (e.g., the
   client is part of the device operating system or a highly privileged
   application), and when other authorization grant types are not
   available (such as an authorization code).

   Even though this grant type requires direct client access to the
   resource owner credentials, the resource owner credentials are used
   for a single request and are exchanged for an access token.  This
   grant type can eliminate the need for the client to store the
   resource owner credentials for future use, by exchanging the
   credentials with a long-lived access token or refresh token.

[1.3.4](#section-1.3.4).  Client Credentials

   The client credentials (or other forms of client authentication) can
   be used as an authorization grant when the authorization scope is
   limited to the protected resources under the control of the client,
   or to protected resources previously arranged with the authorization
   server.  Client credentials are used as an authorization grant
   typically when the client is acting on its own behalf (the client is
   also the resource owner) or is requesting access to protected
   resources based on an authorization previously arranged with the
   authorization server.

Hardt                        Standards Track                    [Page 9]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[1.4](#section-1.4).  Access Token

   Access tokens are credentials used to access protected resources.  An
   access token is a string representing an authorization issued to the
   client.  The string is usually opaque to the client.  Tokens
   represent specific scopes and durations of access, granted by the
   resource owner, and enforced by the resource server and authorization
   server.

   The token may denote an identifier used to retrieve the authorization
   information or may self-contain the authorization information in a
   verifiable manner (i.e., a token string consisting of some data and a
   signature).  Additional authentication credentials, which are beyond
   the scope of this specification, may be required in order for the
   client to use a token.

   The access token provides an abstraction layer, replacing different
   authorization constructs (e.g., username and password) with a single
   token understood by the resource server.  This abstraction enables
   issuing access tokens more restrictive than the authorization grant
   used to obtain them, as well as removing the resource server's need
   to understand a wide range of authentication methods.

   Access tokens can have different formats, structures, and methods of
   utilization (e.g., cryptographic properties) based on the resource
   server security requirements.  Access token attributes and the
   methods used to access protected resources are beyond the scope of
   this specification and are defined by companion specifications such
   as [[RFC6750](/doc/html/rfc6750 "\"The OAuth 2.0 Authorization Framework: Bearer Token Usage\"")].

[1.5](#section-1.5).  Refresh Token

   Refresh tokens are credentials used to obtain access tokens.  Refresh
   tokens are issued to the client by the authorization server and are
   used to obtain a new access token when the current access token
   becomes invalid or expires, or to obtain additional access tokens
   with identical or narrower scope (access tokens may have a shorter
   lifetime and fewer permissions than authorized by the resource
   owner).  Issuing a refresh token is optional at the discretion of the
   authorization server.  If the authorization server issues a refresh
   token, it is included when issuing an access token (i.e., step (D) in
   Figure 1).

   A refresh token is a string representing the authorization granted to
   the client by the resource owner.  The string is usually opaque to
   the client.  The token denotes an identifier used to retrieve the

Hardt                        Standards Track                   [Page 10]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   authorization information.  Unlike access tokens, refresh tokens are
   intended for use only with authorization servers and are never sent
   to resource servers.

  +--------+                                           +---------------+
  |        |--(A)------- Authorization Grant --------->|               |
  |        |                                           |               |
  |        |<-(B)----------- Access Token -------------|               |
  |        |               & Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(D)- Protected Resource --| Resource |   | Authorization |
  | Client |                            |  Server  |   |     Server    |
  |        |--(E)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(G)----------- Refresh Token ----------->|               |
  |        |                                           |               |
  |        |<-(H)----------- Access Token -------------|               |
  +--------+           & Optional Refresh Token        +---------------+

               Figure 2: Refreshing an Expired Access Token

   The flow illustrated in Figure 2 includes the following steps:

   (A)  The client requests an access token by authenticating with the
        authorization server and presenting an authorization grant.

   (B)  The authorization server authenticates the client and validates
        the authorization grant, and if valid, issues an access token
        and a refresh token.

   (C)  The client makes a protected resource request to the resource
        server by presenting the access token.

   (D)  The resource server validates the access token, and if valid,
        serves the request.

   (E)  Steps (C) and (D) repeat until the access token expires.  If the
        client knows the access token expired, it skips to step (G);
        otherwise, it makes another protected resource request.

   (F)  Since the access token is invalid, the resource server returns
        an invalid token error.

Hardt                        Standards Track                   [Page 11]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   (G)  The client requests a new access token by authenticating with
        the authorization server and presenting the refresh token.  The
        client authentication requirements are based on the client type
        and on the authorization server policies.

   (H)  The authorization server authenticates the client and validates
        the refresh token, and if valid, issues a new access token (and,
        optionally, a new refresh token).

   Steps (C), (D), (E), and (F) are outside the scope of this
   specification, as described in [Section 7](#section-7).

[1.6](#section-1.6).  TLS Version

   Whenever Transport Layer Security (TLS) is used by this
   specification, the appropriate version (or versions) of TLS will vary
   over time, based on the widespread deployment and known security
   vulnerabilities.  At the time of this writing, TLS version 1.2
   [[RFC5246](/doc/html/rfc5246 "\"The Transport Layer Security (TLS) Protocol Version 1.2\"")] is the most recent version, but has a very limited
   deployment base and might not be readily available for
   implementation.  TLS version 1.0 [[RFC2246](/doc/html/rfc2246 "\"The TLS Protocol Version 1.0\"")] is the most widely
   deployed version and will provide the broadest interoperability.

   Implementations MAY also support additional transport-layer security
   mechanisms that meet their security requirements.

[1.7](#section-1.7).  HTTP Redirections

   This specification makes extensive use of HTTP redirections, in which
   the client or the authorization server directs the resource owner's
   user-agent to another destination.  While the examples in this
   specification show the use of the HTTP 302 status code, any other
   method available via the user-agent to accomplish this redirection is
   allowed and is considered to be an implementation detail.

[1.8](#section-1.8).  Interoperability

   OAuth 2.0 provides a rich authorization framework with well-defined
   security properties.  However, as a rich and highly extensible
   framework with many optional components, on its own, this
   specification is likely to produce a wide range of non-interoperable
   implementations.

   In addition, this specification leaves a few required components
   partially or fully undefined (e.g., client registration,
   authorization server capabilities, endpoint discovery).  Without

Hardt                        Standards Track                   [Page 12]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   these components, clients must be manually and specifically
   configured against a specific authorization server and resource
   server in order to interoperate.

   This framework was designed with the clear expectation that future
   work will define prescriptive profiles and extensions necessary to
   achieve full web-scale interoperability.

[1.9](#section-1.9).  Notational Conventions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   specification are to be interpreted as described in [[RFC2119](/doc/html/rfc2119 "\"Key words for use in RFCs to Indicate Requirement Levels\"")].

   This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [[RFC5234](/doc/html/rfc5234 "\"Augmented BNF for Syntax Specifications: ABNF\"")].  Additionally, the rule URI-reference is
   included from "Uniform Resource Identifier (URI): Generic Syntax"
   [[RFC3986](/doc/html/rfc3986 "\"Uniform Resource Identifier (URI): Generic Syntax\"")].

   Certain security-related terms are to be understood in the sense
   defined in [[RFC4949](/doc/html/rfc4949 "\"Internet Security Glossary, Version 2\"")].  These terms include, but are not limited to,
   "attack", "authentication", "authorization", "certificate",
   "confidentiality", "credential", "encryption", "identity", "sign",
   "signature", "trust", "validate", and "verify".

   Unless otherwise noted, all the protocol parameter names and values
   are case sensitive.

[2](#section-2).  Client Registration

   Before initiating the protocol, the client registers with the
   authorization server.  The means through which the client registers
   with the authorization server are beyond the scope of this
   specification but typically involve end-user interaction with an HTML
   registration form.

   Client registration does not require a direct interaction between the
   client and the authorization server.  When supported by the
   authorization server, registration can rely on other means for
   establishing trust and obtaining the required client properties
   (e.g., redirection URI, client type).  For example, registration can
   be accomplished using a self-issued or third-party-issued assertion,
   or by the authorization server performing client discovery using a
   trusted channel.

Hardt                        Standards Track                   [Page 13]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   When registering a client, the client developer SHALL:

   o  specify the client type as described in [Section 2.1](#section-2.1),

   o  provide its client redirection URIs as described in [Section 3.1.2](#section-3.1.2),
      and

   o  include any other information required by the authorization server
      (e.g., application name, website, description, logo image, the
      acceptance of legal terms).

[2.1](#section-2.1).  Client Types

   OAuth defines two client types, based on their ability to
   authenticate securely with the authorization server (i.e., ability to
   maintain the confidentiality of their client credentials):

   confidential
      Clients capable of maintaining the confidentiality of their
      credentials (e.g., client implemented on a secure server with
      restricted access to the client credentials), or capable of secure
      client authentication using other means.

   public
      Clients incapable of maintaining the confidentiality of their
      credentials (e.g., clients executing on the device used by the
      resource owner, such as an installed native application or a web
      browser-based application), and incapable of secure client
      authentication via any other means.

   The client type designation is based on the authorization server's
   definition of secure authentication and its acceptable exposure
   levels of client credentials.  The authorization server SHOULD NOT
   make assumptions about the client type.

   A client may be implemented as a distributed set of components, each
   with a different client type and security context (e.g., a
   distributed client with both a confidential server-based component
   and a public browser-based component).  If the authorization server
   does not provide support for such clients or does not provide
   guidance with regard to their registration, the client SHOULD
   register each component as a separate client.

Hardt                        Standards Track                   [Page 14]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   This specification has been designed around the following client
   profiles:

   web application
      A web application is a confidential client running on a web
      server.  Resource owners access the client via an HTML user
      interface rendered in a user-agent on the device used by the
      resource owner.  The client credentials as well as any access
      token issued to the client are stored on the web server and are
      not exposed to or accessible by the resource owner.

   user-agent-based application
      A user-agent-based application is a public client in which the
      client code is downloaded from a web server and executes within a
      user-agent (e.g., web browser) on the device used by the resource
      owner.  Protocol data and credentials are easily accessible (and
      often visible) to the resource owner.  Since such applications
      reside within the user-agent, they can make seamless use of the
      user-agent capabilities when requesting authorization.

   native application
      A native application is a public client installed and executed on
      the device used by the resource owner.  Protocol data and
      credentials are accessible to the resource owner.  It is assumed
      that any client authentication credentials included in the
      application can be extracted.  On the other hand, dynamically
      issued credentials such as access tokens or refresh tokens can
      receive an acceptable level of protection.  At a minimum, these
      credentials are protected from hostile servers with which the
      application may interact.  On some platforms, these credentials
      might be protected from other applications residing on the same
      device.

[2.2](#section-2.2).  Client Identifier

   The authorization server issues the registered client a client
   identifier -- a unique string representing the registration
   information provided by the client.  The client identifier is not a
   secret; it is exposed to the resource owner and MUST NOT be used
   alone for client authentication.  The client identifier is unique to
   the authorization server.

   The client identifier string size is left undefined by this
   specification.  The client should avoid making assumptions about the
   identifier size.  The authorization server SHOULD document the size
   of any identifier it issues.

Hardt                        Standards Track                   [Page 15]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[2.3](#section-2.3).  Client Authentication

   If the client type is confidential, the client and authorization
   server establish a client authentication method suitable for the
   security requirements of the authorization server.  The authorization
   server MAY accept any form of client authentication meeting its
   security requirements.

   Confidential clients are typically issued (or establish) a set of
   client credentials used for authenticating with the authorization
   server (e.g., password, public/private key pair).

   The authorization server MAY establish a client authentication method
   with public clients.  However, the authorization server MUST NOT rely
   on public client authentication for the purpose of identifying the
   client.

   The client MUST NOT use more than one authentication method in each
   request.

[2.3.1](#section-2.3.1).  Client Password

   Clients in possession of a client password MAY use the HTTP Basic
   authentication scheme as defined in [[RFC2617](/doc/html/rfc2617 "\"HTTP Authentication: Basic and Digest Access Authentication\"")] to authenticate with
   the authorization server.  The client identifier is encoded using the
   "application/x-www-form-urlencoded" encoding algorithm per
   [Appendix B](#appendix-B), and the encoded value is used as the username; the client
   password is encoded using the same algorithm and used as the
   password.  The authorization server MUST support the HTTP Basic
   authentication scheme for authenticating clients that were issued a
   client password.

   For example (with extra line breaks for display purposes only):

     Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3

   Alternatively, the authorization server MAY support including the
   client credentials in the request-body using the following
   parameters:

   client_id
         REQUIRED.  The client identifier issued to the client during
         the registration process described by [Section 2.2](#section-2.2).

   client_secret
         REQUIRED.  The client secret.  The client MAY omit the
         parameter if the client secret is an empty string.

Hardt                        Standards Track                   [Page 16]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   Including the client credentials in the request-body using the two
   parameters is NOT RECOMMENDED and SHOULD be limited to clients unable
   to directly utilize the HTTP Basic authentication scheme (or other
   password-based HTTP authentication schemes).  The parameters can only
   be transmitted in the request-body and MUST NOT be included in the
   request URI.

   For example, a request to refresh an access token ([Section 6](#section-6)) using
   the body parameters (with extra line breaks for display purposes
   only):

     POST /token HTTP/1.1
     Host: server.example.com
     Content-Type: application/x-www-form-urlencoded

     grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
     &client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw

   The authorization server MUST require the use of TLS as described in
   [Section 1.6](#section-1.6) when sending requests using password authentication.

   Since this client authentication method involves a password, the
   authorization server MUST protect any endpoint utilizing it against
   brute force attacks.

[2.3.2](#section-2.3.2).  Other Authentication Methods

   The authorization server MAY support any suitable HTTP authentication
   scheme matching its security requirements.  When using other
   authentication methods, the authorization server MUST define a
   mapping between the client identifier (registration record) and
   authentication scheme.

[2.4](#section-2.4).  Unregistered Clients

   This specification does not exclude the use of unregistered clients.
   However, the use of such clients is beyond the scope of this
   specification and requires additional security analysis and review of
   its interoperability impact.

Hardt                        Standards Track                   [Page 17]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[3](#section-3).  Protocol Endpoints

   The authorization process utilizes two authorization server endpoints
   (HTTP resources):

   o  Authorization endpoint - used by the client to obtain
      authorization from the resource owner via user-agent redirection.

   o  Token endpoint - used by the client to exchange an authorization
      grant for an access token, typically with client authentication.

   As well as one client endpoint:

   o  Redirection endpoint - used by the authorization server to return
      responses containing authorization credentials to the client via
      the resource owner user-agent.

   Not every authorization grant type utilizes both endpoints.
   Extension grant types MAY define additional endpoints as needed.

[3.1](#section-3.1).  Authorization Endpoint

   The authorization endpoint is used to interact with the resource
   owner and obtain an authorization grant.  The authorization server
   MUST first verify the identity of the resource owner.  The way in
   which the authorization server authenticates the resource owner
   (e.g., username and password login, session cookies) is beyond the
   scope of this specification.

   The means through which the client obtains the location of the
   authorization endpoint are beyond the scope of this specification,
   but the location is typically provided in the service documentation.

   The endpoint URI MAY include an "application/x-www-form-urlencoded"
   formatted (per [Appendix B](#appendix-B)) query component ([[RFC3986] Section 3.4](/doc/html/rfc3986#section-3.4)),
   which MUST be retained when adding additional query parameters.  The
   endpoint URI MUST NOT include a fragment component.

   Since requests to the authorization endpoint result in user
   authentication and the transmission of clear-text credentials (in the
   HTTP response), the authorization server MUST require the use of TLS
   as described in [Section 1.6](#section-1.6) when sending requests to the
   authorization endpoint.

   The authorization server MUST support the use of the HTTP "GET"
   method [[RFC2616](/doc/html/rfc2616 "\"Hypertext Transfer Protocol -- HTTP/1.1\"")] for the authorization endpoint and MAY support the
   use of the "POST" method as well.

Hardt                        Standards Track                   [Page 18]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   Parameters sent without a value MUST be treated as if they were
   omitted from the request.  The authorization server MUST ignore
   unrecognized request parameters.  Request and response parameters
   MUST NOT be included more than once.

[3.1.1](#section-3.1.1).  Response Type

   The authorization endpoint is used by the authorization code grant
   type and implicit grant type flows.  The client informs the
   authorization server of the desired grant type using the following
   parameter:

   response_type
         REQUIRED.  The value MUST be one of "code" for requesting an
         authorization code as described by [Section 4.1.1](#section-4.1.1), "token" for
         requesting an access token (implicit grant) as described by
         [Section 4.2.1](#section-4.2.1), or a registered extension value as described by
         [Section 8.4](#section-8.4).

   Extension response types MAY contain a space-delimited (%x20) list of
   values, where the order of values does not matter (e.g., response
   type "a b" is the same as "b a").  The meaning of such composite
   response types is defined by their respective specifications.

   If an authorization request is missing the "response_type" parameter,
   or if the response type is not understood, the authorization server
   MUST return an error response as described in [Section 4.1.2.1](#section-4.1.2.1).

[3.1.2](#section-3.1.2).  Redirection Endpoint

   After completing its interaction with the resource owner, the
   authorization server directs the resource owner's user-agent back to
   the client.  The authorization server redirects the user-agent to the
   client's redirection endpoint previously established with the
   authorization server during the client registration process or when
   making the authorization request.

   The redirection endpoint URI MUST be an absolute URI as defined by
   [[RFC3986] Section 4.3](/doc/html/rfc3986#section-4.3).  The endpoint URI MAY include an
   "application/x-www-form-urlencoded" formatted (per [Appendix B](#appendix-B)) query
   component ([[RFC3986] Section 3.4](/doc/html/rfc3986#section-3.4)), which MUST be retained when adding
   additional query parameters.  The endpoint URI MUST NOT include a
   fragment component.

Hardt                        Standards Track                   [Page 19]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[3.1.2.1](#section-3.1.2.1).  Endpoint Request Confidentiality

   The redirection endpoint SHOULD require the use of TLS as described
   in [Section 1.6](#section-1.6) when the requested response type is "code" or "token",
   or when the redirection request will result in the transmission of
   sensitive credentials over an open network.  This specification does
   not mandate the use of TLS because at the time of this writing,
   requiring clients to deploy TLS is a significant hurdle for many
   client developers.  If TLS is not available, the authorization server
   SHOULD warn the resource owner about the insecure endpoint prior to
   redirection (e.g., display a message during the authorization
   request).

   Lack of transport-layer security can have a severe impact on the
   security of the client and the protected resources it is authorized
   to access.  The use of transport-layer security is particularly
   critical when the authorization process is used as a form of
   delegated end-user authentication by the client (e.g., third-party
   sign-in service).

[3.1.2.2](#section-3.1.2.2).  Registration Requirements

   The authorization server MUST require the following clients to
   register their redirection endpoint:

   o  Public clients.

   o  Confidential clients utilizing the implicit grant type.

   The authorization server SHOULD require all clients to register their
   redirection endpoint prior to utilizing the authorization endpoint.

   The authorization server SHOULD require the client to provide the
   complete redirection URI (the client MAY use the "state" request
   parameter to achieve per-request customization).  If requiring the
   registration of the complete redirection URI is not possible, the
   authorization server SHOULD require the registration of the URI
   scheme, authority, and path (allowing the client to dynamically vary
   only the query component of the redirection URI when requesting
   authorization).

   The authorization server MAY allow the client to register multiple
   redirection endpoints.

   Lack of a redirection URI registration requirement can enable an
   attacker to use the authorization endpoint as an open redirector as
   described in [Section 10.15](#section-10.15).

Hardt                        Standards Track                   [Page 20]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[3.1.2.3](#section-3.1.2.3).  Dynamic Configuration

   If multiple redirection URIs have been registered, if only part of
   the redirection URI has been registered, or if no redirection URI has
   been registered, the client MUST include a redirection URI with the
   authorization request using the "redirect_uri" request parameter.

   When a redirection URI is included in an authorization request, the
   authorization server MUST compare and match the value received
   against at least one of the registered redirection URIs (or URI
   components) as defined in [[RFC3986] Section 6](/doc/html/rfc3986#section-6), if any redirection
   URIs were registered.  If the client registration included the full
   redirection URI, the authorization server MUST compare the two URIs
   using simple string comparison as defined in [[RFC3986] Section 6.2.1](/doc/html/rfc3986#section-6.2.1).

[3.1.2.4](#section-3.1.2.4).  Invalid Endpoint

   If an authorization request fails validation due to a missing,
   invalid, or mismatching redirection URI, the authorization server
   SHOULD inform the resource owner of the error and MUST NOT
   automatically redirect the user-agent to the invalid redirection URI.

[3.1.2.5](#section-3.1.2.5).  Endpoint Content

   The redirection request to the client's endpoint typically results in
   an HTML document response, processed by the user-agent.  If the HTML
   response is served directly as the result of the redirection request,
   any script included in the HTML document will execute with full
   access to the redirection URI and the credentials it contains.

   The client SHOULD NOT include any third-party scripts (e.g., third-
   party analytics, social plug-ins, ad networks) in the redirection
   endpoint response.  Instead, it SHOULD extract the credentials from
   the URI and redirect the user-agent again to another endpoint without
   exposing the credentials (in the URI or elsewhere).  If third-party
   scripts are included, the client MUST ensure that its own scripts
   (used to extract and remove the credentials from the URI) will
   execute first.

[3.2](#section-3.2).  Token Endpoint

   The token endpoint is used by the client to obtain an access token by
   presenting its authorization grant or refresh token.  The token
   endpoint is used with every authorization grant except for the
   implicit grant type (since an access token is issued directly).

Hardt                        Standards Track                   [Page 21]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   The means through which the client obtains the location of the token
   endpoint are beyond the scope of this specification, but the location
   is typically provided in the service documentation.

   The endpoint URI MAY include an "application/x-www-form-urlencoded"
   formatted (per [Appendix B](#appendix-B)) query component ([[RFC3986] Section 3.4](/doc/html/rfc3986#section-3.4)),
   which MUST be retained when adding additional query parameters.  The
   endpoint URI MUST NOT include a fragment component.

   Since requests to the token endpoint result in the transmission of
   clear-text credentials (in the HTTP request and response), the
   authorization server MUST require the use of TLS as described in
   [Section 1.6](#section-1.6) when sending requests to the token endpoint.

   The client MUST use the HTTP "POST" method when making access token
   requests.

   Parameters sent without a value MUST be treated as if they were
   omitted from the request.  The authorization server MUST ignore
   unrecognized request parameters.  Request and response parameters
   MUST NOT be included more than once.

[3.2.1](#section-3.2.1).  Client Authentication

   Confidential clients or other clients issued client credentials MUST
   authenticate with the authorization server as described in
   [Section 2.3](#section-2.3) when making requests to the token endpoint.  Client
   authentication is used for:

   o  Enforcing the binding of refresh tokens and authorization codes to
      the client they were issued to.  Client authentication is critical
      when an authorization code is transmitted to the redirection
      endpoint over an insecure channel or when the redirection URI has
      not been registered in full.

   o  Recovering from a compromised client by disabling the client or
      changing its credentials, thus preventing an attacker from abusing
      stolen refresh tokens.  Changing a single set of client
      credentials is significantly faster than revoking an entire set of
      refresh tokens.

   o  Implementing authentication management best practices, which
      require periodic credential rotation.  Rotation of an entire set
      of refresh tokens can be challenging, while rotation of a single
      set of client credentials is significantly easier.

Hardt                        Standards Track                   [Page 22]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   A client MAY use the "client_id" request parameter to identify itself
   when sending requests to the token endpoint.  In the
   "authorization_code" "grant_type" request to the token endpoint, an
   unauthenticated client MUST send its "client_id" to prevent itself
   from inadvertently accepting a code intended for a client with a
   different "client_id".  This protects the client from substitution of
   the authentication code.  (It provides no additional security for the
   protected resource.)

[3.3](#section-3.3).  Access Token Scope

   The authorization and token endpoints allow the client to specify the
   scope of the access request using the "scope" request parameter.  In
   turn, the authorization server uses the "scope" response parameter to
   inform the client of the scope of the access token issued.

   The value of the scope parameter is expressed as a list of space-
   delimited, case-sensitive strings.  The strings are defined by the
   authorization server.  If the value contains multiple space-delimited
   strings, their order does not matter, and each string adds an
   additional access range to the requested scope.

     scope       = scope-token *( SP scope-token )
     scope-token = 1*( %x21 / %x23-5B / %x5D-7E )

   The authorization server MAY fully or partially ignore the scope
   requested by the client, based on the authorization server policy or
   the resource owner's instructions.  If the issued access token scope
   is different from the one requested by the client, the authorization
   server MUST include the "scope" response parameter to inform the
   client of the actual scope granted.

   If the client omits the scope parameter when requesting
   authorization, the authorization server MUST either process the
   request using a pre-defined default value or fail the request
   indicating an invalid scope.  The authorization server SHOULD
   document its scope requirements and default value (if defined).

[4](#section-4).  Obtaining Authorization

   To request an access token, the client obtains authorization from the
   resource owner.  The authorization is expressed in the form of an
   authorization grant, which the client uses to request the access
   token.  OAuth defines four grant types: authorization code, implicit,
   resource owner password credentials, and client credentials.  It also
   provides an extension mechanism for defining additional grant types.

Hardt                        Standards Track                   [Page 23]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[4.1](#section-4.1).  Authorization Code Grant

   The authorization code grant type is used to obtain both access
   tokens and refresh tokens and is optimized for confidential clients.
   Since this is a redirection-based flow, the client must be capable of
   interacting with the resource owner's user-agent (typically a web
   browser) and capable of receiving incoming requests (via redirection)
   from the authorization server.

     +----------+
     | Resource |
     |   Owner  |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier      +---------------+
     |         -+----(A)-- & Redirection URI ---->|               |
     |  User-   |                                 | Authorization |
     |  Agent  -+----(B)-- User authenticates --->|     Server    |
     |          |                                 |               |
     |         -+----(C)-- Authorization Code ---<|               |
     +-|----|---+                                 +---------------+
       |    |                                         ^      v
      (A)  (C)                                        |      |
       |    |                                         |      |
       ^    v                                         |      |
     +---------+                                      |      |
     |         |>---(D)-- Authorization Code ---------'      |
     |  Client |          & Redirection URI                  |
     |         |                                             |
     |         |<---(E)----- Access Token -------------------'
     +---------+       (w/ Optional Refresh Token)

   Note: The lines illustrating steps (A), (B), and (C) are broken into
   two parts as they pass through the user-agent.

                     Figure 3: Authorization Code Flow

Hardt                        Standards Track                   [Page 24]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   The flow illustrated in Figure 3 includes the following steps:

   (A)  The client initiates the flow by directing the resource owner's
        user-agent to the authorization endpoint.  The client includes
        its client identifier, requested scope, local state, and a
        redirection URI to which the authorization server will send the
        user-agent back once access is granted (or denied).

   (B)  The authorization server authenticates the resource owner (via
        the user-agent) and establishes whether the resource owner
        grants or denies the client's access request.

   (C)  Assuming the resource owner grants access, the authorization
        server redirects the user-agent back to the client using the
        redirection URI provided earlier (in the request or during
        client registration).  The redirection URI includes an
        authorization code and any local state provided by the client
        earlier.

   (D)  The client requests an access token from the authorization
        server's token endpoint by including the authorization code
        received in the previous step.  When making the request, the
        client authenticates with the authorization server.  The client
        includes the redirection URI used to obtain the authorization
        code for verification.

   (E)  The authorization server authenticates the client, validates the
        authorization code, and ensures that the redirection URI
        received matches the URI used to redirect the client in
        step (C).  If valid, the authorization server responds back with
        an access token and, optionally, a refresh token.

[4.1.1](#section-4.1.1).  Authorization Request

   The client constructs the request URI by adding the following
   parameters to the query component of the authorization endpoint URI
   using the "application/x-www-form-urlencoded" format, per [Appendix B](#appendix-B):

   response_type
         REQUIRED.  Value MUST be set to "code".

   client_id
         REQUIRED.  The client identifier as described in [Section 2.2](#section-2.2).

   redirect_uri
         OPTIONAL.  As described in [Section 3.1.2](#section-3.1.2).

Hardt                        Standards Track                   [Page 25]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   scope
         OPTIONAL.  The scope of the access request as described by
         [Section 3.3](#section-3.3).

   state
         RECOMMENDED.  An opaque value used by the client to maintain
         state between the request and callback.  The authorization
         server includes this value when redirecting the user-agent back
         to the client.  The parameter SHOULD be used for preventing
         cross-site request forgery as described in [Section 10.12](#section-10.12).

   The client directs the resource owner to the constructed URI using an
   HTTP redirection response, or by other means available to it via the
   user-agent.

   For example, the client directs the user-agent to make the following
   HTTP request using TLS (with extra line breaks for display purposes
   only):

    GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz
        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
    Host: server.example.com

   The authorization server validates the request to ensure that all
   required parameters are present and valid.  If the request is valid,
   the authorization server authenticates the resource owner and obtains
   an authorization decision (by asking the resource owner or by
   establishing approval via other means).

   When a decision is established, the authorization server directs the
   user-agent to the provided client redirection URI using an HTTP
   redirection response, or by other means available to it via the
   user-agent.

[4.1.2](#section-4.1.2).  Authorization Response

   If the resource owner grants the access request, the authorization
   server issues an authorization code and delivers it to the client by
   adding the following parameters to the query component of the
   redirection URI using the "application/x-www-form-urlencoded" format,
   per [Appendix B](#appendix-B):

   code
         REQUIRED.  The authorization code generated by the
         authorization server.  The authorization code MUST expire
         shortly after it is issued to mitigate the risk of leaks.  A
         maximum authorization code lifetime of 10 minutes is
         RECOMMENDED.  The client MUST NOT use the authorization code

Hardt                        Standards Track                   [Page 26]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

         more than once.  If an authorization code is used more than
         once, the authorization server MUST deny the request and SHOULD
         revoke (when possible) all tokens previously issued based on
         that authorization code.  The authorization code is bound to
         the client identifier and redirection URI.

   state
         REQUIRED if the "state" parameter was present in the client
         authorization request.  The exact value received from the
         client.

   For example, the authorization server redirects the user-agent by
   sending the following HTTP response:

     HTTP/1.1 302 Found
     Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA
               &state=xyz

   The client MUST ignore unrecognized response parameters.  The
   authorization code string size is left undefined by this
   specification.  The client should avoid making assumptions about code
   value sizes.  The authorization server SHOULD document the size of
   any value it issues.

[4.1.2.1](#section-4.1.2.1).  Error Response

   If the request fails due to a missing, invalid, or mismatching
   redirection URI, or if the client identifier is missing or invalid,
   the authorization server SHOULD inform the resource owner of the
   error and MUST NOT automatically redirect the user-agent to the
   invalid redirection URI.

   If the resource owner denies the access request or if the request
   fails for reasons other than a missing or invalid redirection URI,
   the authorization server informs the client by adding the following
   parameters to the query component of the redirection URI using the
   "application/x-www-form-urlencoded" format, per [Appendix B](#appendix-B):

   error
         REQUIRED.  A single ASCII [[USASCII](#ref-USASCII "\"Coded Character Set -- 7-bit American Standard Code for Information Interchange\"")] error code from the
         following:

         invalid_request
               The request is missing a required parameter, includes an
               invalid parameter value, includes a parameter more than
               once, or is otherwise malformed.

Hardt                        Standards Track                   [Page 27]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

         unauthorized_client
               The client is not authorized to request an authorization
               code using this method.

         access_denied
               The resource owner or authorization server denied the
               request.

         unsupported_response_type
               The authorization server does not support obtaining an
               authorization code using this method.

         invalid_scope
               The requested scope is invalid, unknown, or malformed.

         server_error
               The authorization server encountered an unexpected
               condition that prevented it from fulfilling the request.
               (This error code is needed because a 500 Internal Server
               Error HTTP status code cannot be returned to the client
               via an HTTP redirect.)

         temporarily_unavailable
               The authorization server is currently unable to handle
               the request due to a temporary overloading or maintenance
               of the server.  (This error code is needed because a 503
               Service Unavailable HTTP status code cannot be returned
               to the client via an HTTP redirect.)

         Values for the "error" parameter MUST NOT include characters
         outside the set %x20-21 / %x23-5B / %x5D-7E.

   error_description
         OPTIONAL.  Human-readable ASCII [[USASCII](#ref-USASCII "\"Coded Character Set -- 7-bit American Standard Code for Information Interchange\"")] text providing
         additional information, used to assist the client developer in
         understanding the error that occurred.
         Values for the "error_description" parameter MUST NOT include
         characters outside the set %x20-21 / %x23-5B / %x5D-7E.

   error_uri
         OPTIONAL.  A URI identifying a human-readable web page with
         information about the error, used to provide the client
         developer with additional information about the error.
         Values for the "error_uri" parameter MUST conform to the
         URI-reference syntax and thus MUST NOT include characters
         outside the set %x21 / %x23-5B / %x5D-7E.

Hardt                        Standards Track                   [Page 28]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   state
         REQUIRED if a "state" parameter was present in the client
         authorization request.  The exact value received from the
         client.

   For example, the authorization server redirects the user-agent by
   sending the following HTTP response:

   HTTP/1.1 302 Found
   Location: https://client.example.com/cb?error=access_denied&state=xyz

[4.1.3](#section-4.1.3).  Access Token Request

   The client makes a request to the token endpoint by sending the
   following parameters using the "application/x-www-form-urlencoded"
   format per [Appendix B](#appendix-B) with a character encoding of UTF-8 in the HTTP
   request entity-body:

   grant_type
         REQUIRED.  Value MUST be set to "authorization_code".

   code
         REQUIRED.  The authorization code received from the
         authorization server.

   redirect_uri
         REQUIRED, if the "redirect_uri" parameter was included in the
         authorization request as described in [Section 4.1.1](#section-4.1.1), and their
         values MUST be identical.

   client_id
         REQUIRED, if the client is not authenticating with the
         authorization server as described in [Section 3.2.1](#section-3.2.1).

   If the client type is confidential or the client was issued client
   credentials (or assigned other authentication requirements), the
   client MUST authenticate with the authorization server as described
   in [Section 3.2.1](#section-3.2.1).

Hardt                        Standards Track                   [Page 29]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   For example, the client makes the following HTTP request using TLS
   (with extra line breaks for display purposes only):

     POST /token HTTP/1.1
     Host: server.example.com
     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
     Content-Type: application/x-www-form-urlencoded

     grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA
     &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb

   The authorization server MUST:

   o  require client authentication for confidential clients or for any
      client that was issued client credentials (or with other
      authentication requirements),

   o  authenticate the client if client authentication is included,

   o  ensure that the authorization code was issued to the authenticated
      confidential client, or if the client is public, ensure that the
      code was issued to "client_id" in the request,

   o  verify that the authorization code is valid, and

   o  ensure that the "redirect_uri" parameter is present if the
      "redirect_uri" parameter was included in the initial authorization
      request as described in [Section 4.1.1](#section-4.1.1), and if included ensure that
      their values are identical.

[4.1.4](#section-4.1.4).  Access Token Response

   If the access token request is valid and authorized, the
   authorization server issues an access token and optional refresh
   token as described in [Section 5.1](#section-5.1).  If the request client
   authentication failed or is invalid, the authorization server returns
   an error response as described in [Section 5.2](#section-5.2).

Hardt                        Standards Track                   [Page 30]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   An example successful response:

     HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache

     {
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
       "example_parameter":"example_value"
     }

[4.2](#section-4.2).  Implicit Grant

   The implicit grant type is used to obtain access tokens (it does not
   support the issuance of refresh tokens) and is optimized for public
   clients known to operate a particular redirection URI.  These clients
   are typically implemented in a browser using a scripting language
   such as JavaScript.

   Since this is a redirection-based flow, the client must be capable of
   interacting with the resource owner's user-agent (typically a web
   browser) and capable of receiving incoming requests (via redirection)
   from the authorization server.

   Unlike the authorization code grant type, in which the client makes
   separate requests for authorization and for an access token, the
   client receives the access token as the result of the authorization
   request.

   The implicit grant type does not include client authentication, and
   relies on the presence of the resource owner and the registration of
   the redirection URI.  Because the access token is encoded into the
   redirection URI, it may be exposed to the resource owner and other
   applications residing on the same device.

Hardt                        Standards Track                   [Page 31]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

     +----------+
     | Resource |
     |  Owner   |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier     +---------------+
     |         -+----(A)-- & Redirection URI --->|               |
     |  User-   |                                | Authorization |
     |  Agent  -|----(B)-- User authenticates -->|     Server    |
     |          |                                |               |
     |          |<---(C)--- Redirection URI ----<|               |
     |          |          with Access Token     +---------------+
     |          |            in Fragment
     |          |                                +---------------+
     |          |----(D)--- Redirection URI ---->|   Web-Hosted  |
     |          |          without Fragment      |     Client    |
     |          |                                |    Resource   |
     |     (F)  |<---(E)------- Script ---------<|               |
     |          |                                +---------------+
     +-|--------+
       |    |
      (A)  (G) Access Token
       |    |
       ^    v
     +---------+
     |         |
     |  Client |
     |         |
     +---------+

   Note: The lines illustrating steps (A) and (B) are broken into two
   parts as they pass through the user-agent.

                       Figure 4: Implicit Grant Flow

Hardt                        Standards Track                   [Page 32]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   The flow illustrated in Figure 4 includes the following steps:

   (A)  The client initiates the flow by directing the resource owner's
        user-agent to the authorization endpoint.  The client includes
        its client identifier, requested scope, local state, and a
        redirection URI to which the authorization server will send the
        user-agent back once access is granted (or denied).

   (B)  The authorization server authenticates the resource owner (via
        the user-agent) and establishes whether the resource owner
        grants or denies the client's access request.

   (C)  Assuming the resource owner grants access, the authorization
        server redirects the user-agent back to the client using the
        redirection URI provided earlier.  The redirection URI includes
        the access token in the URI fragment.

   (D)  The user-agent follows the redirection instructions by making a
        request to the web-hosted client resource (which does not
        include the fragment per [[RFC2616](/doc/html/rfc2616 "\"Hypertext Transfer Protocol -- HTTP/1.1\"")]).  The user-agent retains the
        fragment information locally.

   (E)  The web-hosted client resource returns a web page (typically an
        HTML document with an embedded script) capable of accessing the
        full redirection URI including the fragment retained by the
        user-agent, and extracting the access token (and other
        parameters) contained in the fragment.

   (F)  The user-agent executes the script provided by the web-hosted
        client resource locally, which extracts the access token.

   (G)  The user-agent passes the access token to the client.

   See Sections [1.3.2](#section-1.3.2) and [9](#section-9) for background on using the implicit grant.
   See Sections [10.3](#section-10.3) and [10.16](#section-10.16) for important security considerations
   when using the implicit grant.

[4.2.1](#section-4.2.1).  Authorization Request

   The client constructs the request URI by adding the following
   parameters to the query component of the authorization endpoint URI
   using the "application/x-www-form-urlencoded" format, per [Appendix B](#appendix-B):

   response_type
         REQUIRED.  Value MUST be set to "token".

   client_id
         REQUIRED.  The client identifier as described in [Section 2.2](#section-2.2).

Hardt                        Standards Track                   [Page 33]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   redirect_uri
         OPTIONAL.  As described in [Section 3.1.2](#section-3.1.2).

   scope
         OPTIONAL.  The scope of the access request as described by
         [Section 3.3](#section-3.3).

   state
         RECOMMENDED.  An opaque value used by the client to maintain
         state between the request and callback.  The authorization
         server includes this value when redirecting the user-agent back
         to the client.  The parameter SHOULD be used for preventing
         cross-site request forgery as described in [Section 10.12](#section-10.12).

   The client directs the resource owner to the constructed URI using an
   HTTP redirection response, or by other means available to it via the
   user-agent.

   For example, the client directs the user-agent to make the following
   HTTP request using TLS (with extra line breaks for display purposes
   only):

    GET /authorize?response_type=token&client_id=s6BhdRkqt3&state=xyz
        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
    Host: server.example.com

   The authorization server validates the request to ensure that all
   required parameters are present and valid.  The authorization server
   MUST verify that the redirection URI to which it will redirect the
   access token matches a redirection URI registered by the client as
   described in [Section 3.1.2](#section-3.1.2).

   If the request is valid, the authorization server authenticates the
   resource owner and obtains an authorization decision (by asking the
   resource owner or by establishing approval via other means).

   When a decision is established, the authorization server directs the
   user-agent to the provided client redirection URI using an HTTP
   redirection response, or by other means available to it via the
   user-agent.

Hardt                        Standards Track                   [Page 34]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[4.2.2](#section-4.2.2).  Access Token Response

   If the resource owner grants the access request, the authorization
   server issues an access token and delivers it to the client by adding
   the following parameters to the fragment component of the redirection
   URI using the "application/x-www-form-urlencoded" format, per
   [Appendix B](#appendix-B):

   access_token
         REQUIRED.  The access token issued by the authorization server.

   token_type
         REQUIRED.  The type of the token issued as described in
         [Section 7.1](#section-7.1).  Value is case insensitive.

   expires_in
         RECOMMENDED.  The lifetime in seconds of the access token.  For
         example, the value "3600" denotes that the access token will
         expire in one hour from the time the response was generated.
         If omitted, the authorization server SHOULD provide the
         expiration time via other means or document the default value.

   scope
         OPTIONAL, if identical to the scope requested by the client;
         otherwise, REQUIRED.  The scope of the access token as
         described by [Section 3.3](#section-3.3).

   state
         REQUIRED if the "state" parameter was present in the client
         authorization request.  The exact value received from the
         client.

   The authorization server MUST NOT issue a refresh token.

   For example, the authorization server redirects the user-agent by
   sending the following HTTP response (with extra line breaks for
   display purposes only):

     HTTP/1.1 302 Found
     Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA
               &state=xyz&token_type=example&expires_in=3600

   Developers should note that some user-agents do not support the
   inclusion of a fragment component in the HTTP "Location" response
   header field.  Such clients will require using other methods for
   redirecting the client than a 3xx redirection response -- for
   example, returning an HTML page that includes a 'continue' button
   with an action linked to the redirection URI.

Hardt                        Standards Track                   [Page 35]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   The client MUST ignore unrecognized response parameters.  The access
   token string size is left undefined by this specification.  The
   client should avoid making assumptions about value sizes.  The
   authorization server SHOULD document the size of any value it issues.

[4.2.2.1](#section-4.2.2.1).  Error Response

   If the request fails due to a missing, invalid, or mismatching
   redirection URI, or if the client identifier is missing or invalid,
   the authorization server SHOULD inform the resource owner of the
   error and MUST NOT automatically redirect the user-agent to the
   invalid redirection URI.

   If the resource owner denies the access request or if the request
   fails for reasons other than a missing or invalid redirection URI,
   the authorization server informs the client by adding the following
   parameters to the fragment component of the redirection URI using the
   "application/x-www-form-urlencoded" format, per [Appendix B](#appendix-B):

   error
         REQUIRED.  A single ASCII [[USASCII](#ref-USASCII "\"Coded Character Set -- 7-bit American Standard Code for Information Interchange\"")] error code from the
         following:

         invalid_request
               The request is missing a required parameter, includes an
               invalid parameter value, includes a parameter more than
               once, or is otherwise malformed.

         unauthorized_client
               The client is not authorized to request an access token
               using this method.

         access_denied
               The resource owner or authorization server denied the
               request.

         unsupported_response_type
               The authorization server does not support obtaining an
               access token using this method.

         invalid_scope
               The requested scope is invalid, unknown, or malformed.

Hardt                        Standards Track                   [Page 36]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

         server_error
               The authorization server encountered an unexpected
               condition that prevented it from fulfilling the request.
               (This error code is needed because a 500 Internal Server
               Error HTTP status code cannot be returned to the client
               via an HTTP redirect.)

         temporarily_unavailable
               The authorization server is currently unable to handle
               the request due to a temporary overloading or maintenance
               of the server.  (This error code is needed because a 503
               Service Unavailable HTTP status code cannot be returned
               to the client via an HTTP redirect.)

         Values for the "error" parameter MUST NOT include characters
         outside the set %x20-21 / %x23-5B / %x5D-7E.

   error_description
         OPTIONAL.  Human-readable ASCII [[USASCII](#ref-USASCII "\"Coded Character Set -- 7-bit American Standard Code for Information Interchange\"")] text providing
         additional information, used to assist the client developer in
         understanding the error that occurred.
         Values for the "error_description" parameter MUST NOT include
         characters outside the set %x20-21 / %x23-5B / %x5D-7E.

   error_uri
         OPTIONAL.  A URI identifying a human-readable web page with
         information about the error, used to provide the client
         developer with additional information about the error.
         Values for the "error_uri" parameter MUST conform to the
         URI-reference syntax and thus MUST NOT include characters
         outside the set %x21 / %x23-5B / %x5D-7E.

   state
         REQUIRED if a "state" parameter was present in the client
         authorization request.  The exact value received from the
         client.

   For example, the authorization server redirects the user-agent by
   sending the following HTTP response:

   HTTP/1.1 302 Found
   Location: https://client.example.com/cb#error=access_denied&state=xyz

[4.3](#section-4.3).  Resource Owner Password Credentials Grant

   The resource owner password credentials grant type is suitable in
   cases where the resource owner has a trust relationship with the
   client, such as the device operating system or a highly privileged

Hardt                        Standards Track                   [Page 37]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   application.  The authorization server should take special care when
   enabling this grant type and only allow it when other flows are not
   viable.

   This grant type is suitable for clients capable of obtaining the
   resource owner's credentials (username and password, typically using
   an interactive form).  It is also used to migrate existing clients
   using direct authentication schemes such as HTTP Basic or Digest
   authentication to OAuth by converting the stored credentials to an
   access token.

     +----------+
     | Resource |
     |  Owner   |
     |          |
     +----------+
          v
          |    Resource Owner
         (A) Password Credentials
          |
          v
     +---------+                                  +---------------+
     |         |>--(B)---- Resource Owner ------->|               |
     |         |         Password Credentials     | Authorization |
     | Client  |                                  |     Server    |
     |         |<--(C)---- Access Token ---------<|               |
     |         |    (w/ Optional Refresh Token)   |               |
     +---------+                                  +---------------+

            Figure 5: Resource Owner Password Credentials Flow

   The flow illustrated in Figure 5 includes the following steps:

   (A)  The resource owner provides the client with its username and
        password.

   (B)  The client requests an access token from the authorization
        server's token endpoint by including the credentials received
        from the resource owner.  When making the request, the client
        authenticates with the authorization server.

   (C)  The authorization server authenticates the client and validates
        the resource owner credentials, and if valid, issues an access
        token.

Hardt                        Standards Track                   [Page 38]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[4.3.1](#section-4.3.1).  Authorization Request and Response

   The method through which the client obtains the resource owner
   credentials is beyond the scope of this specification.  The client
   MUST discard the credentials once an access token has been obtained.

[4.3.2](#section-4.3.2).  Access Token Request

   The client makes a request to the token endpoint by adding the
   following parameters using the "application/x-www-form-urlencoded"
   format per [Appendix B](#appendix-B) with a character encoding of UTF-8 in the HTTP
   request entity-body:

   grant_type
         REQUIRED.  Value MUST be set to "password".

   username
         REQUIRED.  The resource owner username.

   password
         REQUIRED.  The resource owner password.

   scope
         OPTIONAL.  The scope of the access request as described by
         [Section 3.3](#section-3.3).

   If the client type is confidential or the client was issued client
   credentials (or assigned other authentication requirements), the
   client MUST authenticate with the authorization server as described
   in [Section 3.2.1](#section-3.2.1).

   For example, the client makes the following HTTP request using
   transport-layer security (with extra line breaks for display purposes
   only):

     POST /token HTTP/1.1
     Host: server.example.com
     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
     Content-Type: application/x-www-form-urlencoded

     grant_type=password&username=johndoe&password=A3ddj3w

Hardt                        Standards Track                   [Page 39]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   The authorization server MUST:

   o  require client authentication for confidential clients or for any
      client that was issued client credentials (or with other
      authentication requirements),

   o  authenticate the client if client authentication is included, and

   o  validate the resource owner password credentials using its
      existing password validation algorithm.

   Since this access token request utilizes the resource owner's
   password, the authorization server MUST protect the endpoint against
   brute force attacks (e.g., using rate-limitation or generating
   alerts).

[4.3.3](#section-4.3.3).  Access Token Response

   If the access token request is valid and authorized, the
   authorization server issues an access token and optional refresh
   token as described in [Section 5.1](#section-5.1).  If the request failed client
   authentication or is invalid, the authorization server returns an
   error response as described in [Section 5.2](#section-5.2).

   An example successful response:

     HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache

     {
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
       "example_parameter":"example_value"
     }

[4.4](#section-4.4).  Client Credentials Grant

   The client can request an access token using only its client
   credentials (or other supported means of authentication) when the
   client is requesting access to the protected resources under its
   control, or those of another resource owner that have been previously
   arranged with the authorization server (the method of which is beyond
   the scope of this specification).

Hardt                        Standards Track                   [Page 40]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   The client credentials grant type MUST only be used by confidential
   clients.

     +---------+                                  +---------------+
     |         |                                  |               |
     |         |>--(A)- Client Authentication --->| Authorization |
     | Client  |                                  |     Server    |
     |         |<--(B)---- Access Token ---------<|               |
     |         |                                  |               |
     +---------+                                  +---------------+

                     Figure 6: Client Credentials Flow

   The flow illustrated in Figure 6 includes the following steps:

   (A)  The client authenticates with the authorization server and
        requests an access token from the token endpoint.

   (B)  The authorization server authenticates the client, and if valid,
        issues an access token.

[4.4.1](#section-4.4.1).  Authorization Request and Response

   Since the client authentication is used as the authorization grant,
   no additional authorization request is needed.

[4.4.2](#section-4.4.2).  Access Token Request

   The client makes a request to the token endpoint by adding the
   following parameters using the "application/x-www-form-urlencoded"
   format per [Appendix B](#appendix-B) with a character encoding of UTF-8 in the HTTP
   request entity-body:

   grant_type
         REQUIRED.  Value MUST be set to "client_credentials".

   scope
         OPTIONAL.  The scope of the access request as described by
         [Section 3.3](#section-3.3).

   The client MUST authenticate with the authorization server as
   described in [Section 3.2.1](#section-3.2.1).

Hardt                        Standards Track                   [Page 41]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   For example, the client makes the following HTTP request using
   transport-layer security (with extra line breaks for display purposes
   only):

     POST /token HTTP/1.1
     Host: server.example.com
     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
     Content-Type: application/x-www-form-urlencoded

     grant_type=client_credentials

   The authorization server MUST authenticate the client.

[4.4.3](#section-4.4.3).  Access Token Response

   If the access token request is valid and authorized, the
   authorization server issues an access token as described in
   [Section 5.1](#section-5.1).  A refresh token SHOULD NOT be included.  If the request
   failed client authentication or is invalid, the authorization server
   returns an error response as described in [Section 5.2](#section-5.2).

   An example successful response:

     HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache

     {
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "example_parameter":"example_value"
     }

[4.5](#section-4.5).  Extension Grants

   The client uses an extension grant type by specifying the grant type
   using an absolute URI (defined by the authorization server) as the
   value of the "grant_type" parameter of the token endpoint, and by
   adding any additional parameters necessary.

Hardt                        Standards Track                   [Page 42]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   For example, to request an access token using a Security Assertion
   Markup Language (SAML) 2.0 assertion grant type as defined by
   [[OAuth-SAML2](#ref-OAuth-SAML2)], the client could make the following HTTP request using
   TLS (with extra line breaks for display purposes only):

     POST /token HTTP/1.1
     Host: server.example.com
     Content-Type: application/x-www-form-urlencoded

     grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-
     bearer&assertion=PEFzc2VydGlvbiBJc3N1ZUluc3RhbnQ9IjIwMTEtMDU
     [...omitted for brevity...]aG5TdGF0ZW1lbnQ-PC9Bc3NlcnRpb24-

   If the access token request is valid and authorized, the
   authorization server issues an access token and optional refresh
   token as described in [Section 5.1](#section-5.1).  If the request failed client
   authentication or is invalid, the authorization server returns an
   error response as described in [Section 5.2](#section-5.2).

[5](#section-5).  Issuing an Access Token

   If the access token request is valid and authorized, the
   authorization server issues an access token and optional refresh
   token as described in [Section 5.1](#section-5.1).  If the request failed client
   authentication or is invalid, the authorization server returns an
   error response as described in [Section 5.2](#section-5.2).

[5.1](#section-5.1).  Successful Response

   The authorization server issues an access token and optional refresh
   token, and constructs the response by adding the following parameters
   to the entity-body of the HTTP response with a 200 (OK) status code:

   access_token
         REQUIRED.  The access token issued by the authorization server.

   token_type
         REQUIRED.  The type of the token issued as described in
         [Section 7.1](#section-7.1).  Value is case insensitive.

   expires_in
         RECOMMENDED.  The lifetime in seconds of the access token.  For
         example, the value "3600" denotes that the access token will
         expire in one hour from the time the response was generated.
         If omitted, the authorization server SHOULD provide the
         expiration time via other means or document the default value.

Hardt                        Standards Track                   [Page 43]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   refresh_token
         OPTIONAL.  The refresh token, which can be used to obtain new
         access tokens using the same authorization grant as described
         in [Section 6](#section-6).

   scope
         OPTIONAL, if identical to the scope requested by the client;
         otherwise, REQUIRED.  The scope of the access token as
         described by [Section 3.3](#section-3.3).

   The parameters are included in the entity-body of the HTTP response
   using the "application/json" media type as defined by [[RFC4627](/doc/html/rfc4627 "\"The application/json Media Type for JavaScript Object Notation (JSON)\"")].  The
   parameters are serialized into a JavaScript Object Notation (JSON)
   structure by adding each parameter at the highest structure level.
   Parameter names and string values are included as JSON strings.
   Numerical values are included as JSON numbers.  The order of
   parameters does not matter and can vary.

   The authorization server MUST include the HTTP "Cache-Control"
   response header field [[RFC2616](/doc/html/rfc2616 "\"Hypertext Transfer Protocol -- HTTP/1.1\"")] with a value of "no-store" in any
   response containing tokens, credentials, or other sensitive
   information, as well as the "Pragma" response header field [[RFC2616](/doc/html/rfc2616 "\"Hypertext Transfer Protocol -- HTTP/1.1\"")]
   with a value of "no-cache".

   For example:

     HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache

     {
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
       "example_parameter":"example_value"
     }

   The client MUST ignore unrecognized value names in the response.  The
   sizes of tokens and other values received from the authorization
   server are left undefined.  The client should avoid making
   assumptions about value sizes.  The authorization server SHOULD
   document the size of any value it issues.

Hardt                        Standards Track                   [Page 44]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[5.2](#section-5.2).  Error Response

   The authorization server responds with an HTTP 400 (Bad Request)
   status code (unless specified otherwise) and includes the following
   parameters with the response:

   error
         REQUIRED.  A single ASCII [[USASCII](#ref-USASCII "\"Coded Character Set -- 7-bit American Standard Code for Information Interchange\"")] error code from the
         following:

         invalid_request
               The request is missing a required parameter, includes an
               unsupported parameter value (other than grant type),
               repeats a parameter, includes multiple credentials,
               utilizes more than one mechanism for authenticating the
               client, or is otherwise malformed.

         invalid_client
               Client authentication failed (e.g., unknown client, no
               client authentication included, or unsupported
               authentication method).  The authorization server MAY
               return an HTTP 401 (Unauthorized) status code to indicate
               which HTTP authentication schemes are supported.  If the
               client attempted to authenticate via the "Authorization"
               request header field, the authorization server MUST
               respond with an HTTP 401 (Unauthorized) status code and
               include the "WWW-Authenticate" response header field
               matching the authentication scheme used by the client.

         invalid_grant
               The provided authorization grant (e.g., authorization
               code, resource owner credentials) or refresh token is
               invalid, expired, revoked, does not match the redirection
               URI used in the authorization request, or was issued to
               another client.

         unauthorized_client
               The authenticated client is not authorized to use this
               authorization grant type.

         unsupported_grant_type
               The authorization grant type is not supported by the
               authorization server.

Hardt                        Standards Track                   [Page 45]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

         invalid_scope
               The requested scope is invalid, unknown, malformed, or
               exceeds the scope granted by the resource owner.

         Values for the "error" parameter MUST NOT include characters
         outside the set %x20-21 / %x23-5B / %x5D-7E.

   error_description
         OPTIONAL.  Human-readable ASCII [[USASCII](#ref-USASCII "\"Coded Character Set -- 7-bit American Standard Code for Information Interchange\"")] text providing
         additional information, used to assist the client developer in
         understanding the error that occurred.
         Values for the "error_description" parameter MUST NOT include
         characters outside the set %x20-21 / %x23-5B / %x5D-7E.

   error_uri
         OPTIONAL.  A URI identifying a human-readable web page with
         information about the error, used to provide the client
         developer with additional information about the error.
         Values for the "error_uri" parameter MUST conform to the
         URI-reference syntax and thus MUST NOT include characters
         outside the set %x21 / %x23-5B / %x5D-7E.

   The parameters are included in the entity-body of the HTTP response
   using the "application/json" media type as defined by [[RFC4627](/doc/html/rfc4627 "\"The application/json Media Type for JavaScript Object Notation (JSON)\"")].  The
   parameters are serialized into a JSON structure by adding each
   parameter at the highest structure level.  Parameter names and string
   values are included as JSON strings.  Numerical values are included
   as JSON numbers.  The order of parameters does not matter and can
   vary.

   For example:

     HTTP/1.1 400 Bad Request
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache

     {
       "error":"invalid_request"
     }

Hardt                        Standards Track                   [Page 46]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[6](#section-6).  Refreshing an Access Token

   If the authorization server issued a refresh token to the client, the
   client makes a refresh request to the token endpoint by adding the
   following parameters using the "application/x-www-form-urlencoded"
   format per [Appendix B](#appendix-B) with a character encoding of UTF-8 in the HTTP
   request entity-body:

   grant_type
         REQUIRED.  Value MUST be set to "refresh_token".

   refresh_token
         REQUIRED.  The refresh token issued to the client.

   scope
         OPTIONAL.  The scope of the access request as described by
         [Section 3.3](#section-3.3).  The requested scope MUST NOT include any scope
         not originally granted by the resource owner, and if omitted is
         treated as equal to the scope originally granted by the
         resource owner.

   Because refresh tokens are typically long-lasting credentials used to
   request additional access tokens, the refresh token is bound to the
   client to which it was issued.  If the client type is confidential or
   the client was issued client credentials (or assigned other
   authentication requirements), the client MUST authenticate with the
   authorization server as described in [Section 3.2.1](#section-3.2.1).

   For example, the client makes the following HTTP request using
   transport-layer security (with extra line breaks for display purposes
   only):

     POST /token HTTP/1.1
     Host: server.example.com
     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
     Content-Type: application/x-www-form-urlencoded

     grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA

Hardt                        Standards Track                   [Page 47]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   The authorization server MUST:

   o  require client authentication for confidential clients or for any
      client that was issued client credentials (or with other
      authentication requirements),

   o  authenticate the client if client authentication is included and
      ensure that the refresh token was issued to the authenticated
      client, and

   o  validate the refresh token.

   If valid and authorized, the authorization server issues an access
   token as described in [Section 5.1](#section-5.1).  If the request failed
   verification or is invalid, the authorization server returns an error
   response as described in [Section 5.2](#section-5.2).

   The authorization server MAY issue a new refresh token, in which case
   the client MUST discard the old refresh token and replace it with the
   new refresh token.  The authorization server MAY revoke the old
   refresh token after issuing a new refresh token to the client.  If a
   new refresh token is issued, the refresh token scope MUST be
   identical to that of the refresh token included by the client in the
   request.

[7](#section-7).  Accessing Protected Resources

   The client accesses protected resources by presenting the access
   token to the resource server.  The resource server MUST validate the
   access token and ensure that it has not expired and that its scope
   covers the requested resource.  The methods used by the resource
   server to validate the access token (as well as any error responses)
   are beyond the scope of this specification but generally involve an
   interaction or coordination between the resource server and the
   authorization server.

   The method in which the client utilizes the access token to
   authenticate with the resource server depends on the type of access
   token issued by the authorization server.  Typically, it involves
   using the HTTP "Authorization" request header field [[RFC2617](/doc/html/rfc2617 "\"HTTP Authentication: Basic and Digest Access Authentication\"")] with an
   authentication scheme defined by the specification of the access
   token type used, such as [[RFC6750](/doc/html/rfc6750 "\"The OAuth 2.0 Authorization Framework: Bearer Token Usage\"")].

Hardt                        Standards Track                   [Page 48]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[7.1](#section-7.1).  Access Token Types

   The access token type provides the client with the information
   required to successfully utilize the access token to make a protected
   resource request (along with type-specific attributes).  The client
   MUST NOT use an access token if it does not understand the token
   type.

   For example, the "bearer" token type defined in [[RFC6750](/doc/html/rfc6750 "\"The OAuth 2.0 Authorization Framework: Bearer Token Usage\"")] is utilized
   by simply including the access token string in the request:

     GET /resource/1 HTTP/1.1
     Host: example.com
     Authorization: Bearer mF_9.B5f-4.1JqM

   while the "mac" token type defined in [[OAuth-HTTP-MAC](#ref-OAuth-HTTP-MAC)] is utilized by
   issuing a Message Authentication Code (MAC) key together with the
   access token that is used to sign certain components of the HTTP
   requests:

     GET /resource/1 HTTP/1.1
     Host: example.com
     Authorization: MAC id="h480djs93hd8",
                        nonce="274312:dj83hs9s",
                        mac="kDZvddkndxvhGRXZhvuDjEWhGeE="

   The above examples are provided for illustration purposes only.
   Developers are advised to consult the [[RFC6750](/doc/html/rfc6750 "\"The OAuth 2.0 Authorization Framework: Bearer Token Usage\"")] and [[OAuth-HTTP-MAC](#ref-OAuth-HTTP-MAC)]
   specifications before use.

   Each access token type definition specifies the additional attributes
   (if any) sent to the client together with the "access_token" response
   parameter.  It also defines the HTTP authentication method used to
   include the access token when making a protected resource request.

[7.2](#section-7.2).  Error Response

   If a resource access request fails, the resource server SHOULD inform
   the client of the error.  While the specifics of such error responses
   are beyond the scope of this specification, this document establishes
   a common registry in [Section 11.4](#section-11.4) for error values to be shared among
   OAuth token authentication schemes.

   New authentication schemes designed primarily for OAuth token
   authentication SHOULD define a mechanism for providing an error
   status code to the client, in which the error values allowed are
   registered in the error registry established by this specification.

Hardt                        Standards Track                   [Page 49]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   Such schemes MAY limit the set of valid error codes to a subset of
   the registered values.  If the error code is returned using a named
   parameter, the parameter name SHOULD be "error".

   Other schemes capable of being used for OAuth token authentication,
   but not primarily designed for that purpose, MAY bind their error
   values to the registry in the same manner.

   New authentication schemes MAY choose to also specify the use of the
   "error_description" and "error_uri" parameters to return error
   information in a manner parallel to their usage in this
   specification.

[8](#section-8).  Extensibility

[8.1](#section-8.1).  Defining Access Token Types

   Access token types can be defined in one of two ways: registered in
   the Access Token Types registry (following the procedures in
   [Section 11.1](#section-11.1)), or by using a unique absolute URI as its name.

   Types utilizing a URI name SHOULD be limited to vendor-specific
   implementations that are not commonly applicable, and are specific to
   the implementation details of the resource server where they are
   used.

   All other types MUST be registered.  Type names MUST conform to the
   type-name ABNF.  If the type definition includes a new HTTP
   authentication scheme, the type name SHOULD be identical to the HTTP
   authentication scheme name (as defined by [[RFC2617](/doc/html/rfc2617 "\"HTTP Authentication: Basic and Digest Access Authentication\"")]).  The token type
   "example" is reserved for use in examples.

     type-name  = 1*name-char
     name-char  = "-" / "." / "_" / DIGIT / ALPHA

[8.2](#section-8.2).  Defining New Endpoint Parameters

   New request or response parameters for use with the authorization
   endpoint or the token endpoint are defined and registered in the
   OAuth Parameters registry following the procedure in [Section 11.2](#section-11.2).

   Parameter names MUST conform to the param-name ABNF, and parameter
   values syntax MUST be well-defined (e.g., using ABNF, or a reference
   to the syntax of an existing parameter).

     param-name  = 1*name-char
     name-char   = "-" / "." / "_" / DIGIT / ALPHA

Hardt                        Standards Track                   [Page 50]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   Unregistered vendor-specific parameter extensions that are not
   commonly applicable and that are specific to the implementation
   details of the authorization server where they are used SHOULD
   utilize a vendor-specific prefix that is not likely to conflict with
   other registered values (e.g., begin with 'companyname_').

[8.3](#section-8.3).  Defining New Authorization Grant Types

   New authorization grant types can be defined by assigning them a
   unique absolute URI for use with the "grant_type" parameter.  If the
   extension grant type requires additional token endpoint parameters,
   they MUST be registered in the OAuth Parameters registry as described
   by [Section 11.2](#section-11.2).

[8.4](#section-8.4).  Defining New Authorization Endpoint Response Types

   New response types for use with the authorization endpoint are
   defined and registered in the Authorization Endpoint Response Types
   registry following the procedure in [Section 11.3](#section-11.3).  Response type
   names MUST conform to the response-type ABNF.

     response-type  = response-name *( SP response-name )
     response-name  = 1*response-char
     response-char  = "_" / DIGIT / ALPHA

   If a response type contains one or more space characters (%x20), it
   is compared as a space-delimited list of values in which the order of
   values does not matter.  Only one order of values can be registered,
   which covers all other arrangements of the same set of values.

   For example, the response type "token code" is left undefined by this
   specification.  However, an extension can define and register the
   "token code" response type.  Once registered, the same combination
   cannot be registered as "code token", but both values can be used to
   denote the same response type.

[8.5](#section-8.5).  Defining Additional Error Codes

   In cases where protocol extensions (i.e., access token types,
   extension parameters, or extension grant types) require additional
   error codes to be used with the authorization code grant error
   response ([Section 4.1.2.1](#section-4.1.2.1)), the implicit grant error response
   ([Section 4.2.2.1](#section-4.2.2.1)), the token error response ([Section 5.2](#section-5.2)), or the
   resource access error response ([Section 7.2](#section-7.2)), such error codes MAY be
   defined.

Hardt                        Standards Track                   [Page 51]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   Extension error codes MUST be registered (following the procedures in
   [Section 11.4](#section-11.4)) if the extension they are used in conjunction with is a
   registered access token type, a registered endpoint parameter, or an
   extension grant type.  Error codes used with unregistered extensions
   MAY be registered.

   Error codes MUST conform to the error ABNF and SHOULD be prefixed by
   an identifying name when possible.  For example, an error identifying
   an invalid value set to the extension parameter "example" SHOULD be
   named "example_invalid".

     error      = 1*error-char
     error-char = %x20-21 / %x23-5B / %x5D-7E

[9](#section-9).  Native Applications

   Native applications are clients installed and executed on the device
   used by the resource owner (i.e., desktop application, native mobile
   application).  Native applications require special consideration
   related to security, platform capabilities, and overall end-user
   experience.

   The authorization endpoint requires interaction between the client
   and the resource owner's user-agent.  Native applications can invoke
   an external user-agent or embed a user-agent within the application.
   For example:

   o  External user-agent - the native application can capture the
      response from the authorization server using a redirection URI
      with a scheme registered with the operating system to invoke the
      client as the handler, manual copy-and-paste of the credentials,
      running a local web server, installing a user-agent extension, or
      by providing a redirection URI identifying a server-hosted
      resource under the client's control, which in turn makes the
      response available to the native application.

   o  Embedded user-agent - the native application obtains the response
      by directly communicating with the embedded user-agent by
      monitoring state changes emitted during the resource load, or
      accessing the user-agent's cookies storage.

   When choosing between an external or embedded user-agent, developers
   should consider the following:

   o  An external user-agent may improve completion rate, as the
      resource owner may already have an active session with the
      authorization server, removing the need to re-authenticate.  It
      provides a familiar end-user experience and functionality.  The

Hardt                        Standards Track                   [Page 52]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

      resource owner may also rely on user-agent features or extensions
      to assist with authentication (e.g., password manager, 2-factor
      device reader).

   o  An embedded user-agent may offer improved usability, as it removes
      the need to switch context and open new windows.

   o  An embedded user-agent poses a security challenge because resource
      owners are authenticating in an unidentified window without access
      to the visual protections found in most external user-agents.  An
      embedded user-agent educates end-users to trust unidentified
      requests for authentication (making phishing attacks easier to
      execute).

   When choosing between the implicit grant type and the authorization
   code grant type, the following should be considered:

   o  Native applications that use the authorization code grant type
      SHOULD do so without using client credentials, due to the native
      application's inability to keep client credentials confidential.

   o  When using the implicit grant type flow, a refresh token is not
      returned, which requires repeating the authorization process once
      the access token expires.

[10](#section-10).  Security Considerations

   As a flexible and extensible framework, OAuth's security
   considerations depend on many factors.  The following sections
   provide implementers with security guidelines focused on the three
   client profiles described in [Section 2.1](#section-2.1): web application,
   user-agent-based application, and native application.

   A comprehensive OAuth security model and analysis, as well as
   background for the protocol design, is provided by
   [[OAuth-THREATMODEL](#ref-OAuth-THREATMODEL)].

[10.1](#section-10.1).  Client Authentication

   The authorization server establishes client credentials with web
   application clients for the purpose of client authentication.  The
   authorization server is encouraged to consider stronger client
   authentication means than a client password.  Web application clients
   MUST ensure confidentiality of client passwords and other client
   credentials.

Hardt                        Standards Track                   [Page 53]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   The authorization server MUST NOT issue client passwords or other
   client credentials to native application or user-agent-based
   application clients for the purpose of client authentication.  The
   authorization server MAY issue a client password or other credentials
   for a specific installation of a native application client on a
   specific device.

   When client authentication is not possible, the authorization server
   SHOULD employ other means to validate the client's identity -- for
   example, by requiring the registration of the client redirection URI
   or enlisting the resource owner to confirm identity.  A valid
   redirection URI is not sufficient to verify the client's identity
   when asking for resource owner authorization but can be used to
   prevent delivering credentials to a counterfeit client after
   obtaining resource owner authorization.

   The authorization server must consider the security implications of
   interacting with unauthenticated clients and take measures to limit
   the potential exposure of other credentials (e.g., refresh tokens)
   issued to such clients.

[10.2](#section-10.2).  Client Impersonation

   A malicious client can impersonate another client and obtain access
   to protected resources if the impersonated client fails to, or is
   unable to, keep its client credentials confidential.

   The authorization server MUST authenticate the client whenever
   possible.  If the authorization server cannot authenticate the client
   due to the client's nature, the authorization server MUST require the
   registration of any redirection URI used for receiving authorization
   responses and SHOULD utilize other means to protect resource owners
   from such potentially malicious clients.  For example, the
   authorization server can engage the resource owner to assist in
   identifying the client and its origin.

   The authorization server SHOULD enforce explicit resource owner
   authentication and provide the resource owner with information about
   the client and the requested authorization scope and lifetime.  It is
   up to the resource owner to review the information in the context of
   the current client and to authorize or deny the request.

   The authorization server SHOULD NOT process repeated authorization
   requests automatically (without active resource owner interaction)
   without authenticating the client or relying on other measures to
   ensure that the repeated request comes from the original client and
   not an impersonator.

Hardt                        Standards Track                   [Page 54]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[10.3](#section-10.3).  Access Tokens

   Access token credentials (as well as any confidential access token
   attributes) MUST be kept confidential in transit and storage, and
   only shared among the authorization server, the resource servers the
   access token is valid for, and the client to whom the access token is
   issued.  Access token credentials MUST only be transmitted using TLS
   as described in [Section 1.6](#section-1.6) with server authentication as defined by
   [[RFC2818](/doc/html/rfc2818 "\"HTTP Over TLS\"")].

   When using the implicit grant type, the access token is transmitted
   in the URI fragment, which can expose it to unauthorized parties.

   The authorization server MUST ensure that access tokens cannot be
   generated, modified, or guessed to produce valid access tokens by
   unauthorized parties.

   The client SHOULD request access tokens with the minimal scope
   necessary.  The authorization server SHOULD take the client identity
   into account when choosing how to honor the requested scope and MAY
   issue an access token with less rights than requested.

   This specification does not provide any methods for the resource
   server to ensure that an access token presented to it by a given
   client was issued to that client by the authorization server.

[10.4](#section-10.4).  Refresh Tokens

   Authorization servers MAY issue refresh tokens to web application
   clients and native application clients.

   Refresh tokens MUST be kept confidential in transit and storage, and
   shared only among the authorization server and the client to whom the
   refresh tokens were issued.  The authorization server MUST maintain
   the binding between a refresh token and the client to whom it was
   issued.  Refresh tokens MUST only be transmitted using TLS as
   described in [Section 1.6](#section-1.6) with server authentication as defined by
   [[RFC2818](/doc/html/rfc2818 "\"HTTP Over TLS\"")].

   The authorization server MUST verify the binding between the refresh
   token and client identity whenever the client identity can be
   authenticated.  When client authentication is not possible, the
   authorization server SHOULD deploy other means to detect refresh
   token abuse.

   For example, the authorization server could employ refresh token
   rotation in which a new refresh token is issued with every access
   token refresh response.  The previous refresh token is invalidated

Hardt                        Standards Track                   [Page 55]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   but retained by the authorization server.  If a refresh token is
   compromised and subsequently used by both the attacker and the
   legitimate client, one of them will present an invalidated refresh
   token, which will inform the authorization server of the breach.

   The authorization server MUST ensure that refresh tokens cannot be
   generated, modified, or guessed to produce valid refresh tokens by
   unauthorized parties.

[10.5](#section-10.5).  Authorization Codes

   The transmission of authorization codes SHOULD be made over a secure
   channel, and the client SHOULD require the use of TLS with its
   redirection URI if the URI identifies a network resource.  Since
   authorization codes are transmitted via user-agent redirections, they
   could potentially be disclosed through user-agent history and HTTP
   referrer headers.

   Authorization codes operate as plaintext bearer credentials, used to
   verify that the resource owner who granted authorization at the
   authorization server is the same resource owner returning to the
   client to complete the process.  Therefore, if the client relies on
   the authorization code for its own resource owner authentication, the
   client redirection endpoint MUST require the use of TLS.

   Authorization codes MUST be short lived and single-use.  If the
   authorization server observes multiple attempts to exchange an
   authorization code for an access token, the authorization server
   SHOULD attempt to revoke all access tokens already granted based on
   the compromised authorization code.

   If the client can be authenticated, the authorization servers MUST
   authenticate the client and ensure that the authorization code was
   issued to the same client.

[10.6](#section-10.6).  Authorization Code Redirection URI Manipulation

   When requesting authorization using the authorization code grant
   type, the client can specify a redirection URI via the "redirect_uri"
   parameter.  If an attacker can manipulate the value of the
   redirection URI, it can cause the authorization server to redirect
   the resource owner user-agent to a URI under the control of the
   attacker with the authorization code.

   An attacker can create an account at a legitimate client and initiate
   the authorization flow.  When the attacker's user-agent is sent to
   the authorization server to grant access, the attacker grabs the
   authorization URI provided by the legitimate client and replaces the

Hardt                        Standards Track                   [Page 56]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   client's redirection URI with a URI under the control of the
   attacker.  The attacker then tricks the victim into following the
   manipulated link to authorize access to the legitimate client.

   Once at the authorization server, the victim is prompted with a
   normal, valid request on behalf of a legitimate and trusted client,
   and authorizes the request.  The victim is then redirected to an
   endpoint under the control of the attacker with the authorization
   code.  The attacker completes the authorization flow by sending the
   authorization code to the client using the original redirection URI
   provided by the client.  The client exchanges the authorization code
   with an access token and links it to the attacker's client account,
   which can now gain access to the protected resources authorized by
   the victim (via the client).

   In order to prevent such an attack, the authorization server MUST
   ensure that the redirection URI used to obtain the authorization code
   is identical to the redirection URI provided when exchanging the
   authorization code for an access token.  The authorization server
   MUST require public clients and SHOULD require confidential clients
   to register their redirection URIs.  If a redirection URI is provided
   in the request, the authorization server MUST validate it against the
   registered value.

[10.7](#section-10.7).  Resource Owner Password Credentials

   The resource owner password credentials grant type is often used for
   legacy or migration reasons.  It reduces the overall risk of storing
   usernames and passwords by the client but does not eliminate the need
   to expose highly privileged credentials to the client.

   This grant type carries a higher risk than other grant types because
   it maintains the password anti-pattern this protocol seeks to avoid.
   The client could abuse the password, or the password could
   unintentionally be disclosed to an attacker (e.g., via log files or
   other records kept by the client).

   Additionally, because the resource owner does not have control over
   the authorization process (the resource owner's involvement ends when
   it hands over its credentials to the client), the client can obtain
   access tokens with a broader scope than desired by the resource
   owner.  The authorization server should consider the scope and
   lifetime of access tokens issued via this grant type.

   The authorization server and client SHOULD minimize use of this grant
   type and utilize other grant types whenever possible.

Hardt                        Standards Track                   [Page 57]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[10.8](#section-10.8).  Request Confidentiality

   Access tokens, refresh tokens, resource owner passwords, and client
   credentials MUST NOT be transmitted in the clear.  Authorization
   codes SHOULD NOT be transmitted in the clear.

   The "state" and "scope" parameters SHOULD NOT include sensitive
   client or resource owner information in plain text, as they can be
   transmitted over insecure channels or stored insecurely.

[10.9](#section-10.9).  Ensuring Endpoint Authenticity

   In order to prevent man-in-the-middle attacks, the authorization
   server MUST require the use of TLS with server authentication as
   defined by [[RFC2818](/doc/html/rfc2818 "\"HTTP Over TLS\"")] for any request sent to the authorization and
   token endpoints.  The client MUST validate the authorization server's
   TLS certificate as defined by [[RFC6125](/doc/html/rfc6125 "\"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\"")] and in accordance with its
   requirements for server identity authentication.

[10.10](#section-10.10).  Credentials-Guessing Attacks

   The authorization server MUST prevent attackers from guessing access
   tokens, authorization codes, refresh tokens, resource owner
   passwords, and client credentials.

   The probability of an attacker guessing generated tokens (and other
   credentials not intended for handling by end-users) MUST be less than
   or equal to 2^(-128) and SHOULD be less than or equal to 2^(-160).

   The authorization server MUST utilize other means to protect
   credentials intended for end-user usage.

[10.11](#section-10.11).  Phishing Attacks

   Wide deployment of this and similar protocols may cause end-users to
   become inured to the practice of being redirected to websites where
   they are asked to enter their passwords.  If end-users are not
   careful to verify the authenticity of these websites before entering
   their credentials, it will be possible for attackers to exploit this
   practice to steal resource owners' passwords.

   Service providers should attempt to educate end-users about the risks
   phishing attacks pose and should provide mechanisms that make it easy
   for end-users to confirm the authenticity of their sites.  Client
   developers should consider the security implications of how they
   interact with the user-agent (e.g., external, embedded), and the
   ability of the end-user to verify the authenticity of the
   authorization server.

Hardt                        Standards Track                   [Page 58]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   To reduce the risk of phishing attacks, the authorization servers
   MUST require the use of TLS on every endpoint used for end-user
   interaction.

[10.12](#section-10.12).  Cross-Site Request Forgery

   Cross-site request forgery (CSRF) is an exploit in which an attacker
   causes the user-agent of a victim end-user to follow a malicious URI
   (e.g., provided to the user-agent as a misleading link, image, or
   redirection) to a trusting server (usually established via the
   presence of a valid session cookie).

   A CSRF attack against the client's redirection URI allows an attacker
   to inject its own authorization code or access token, which can
   result in the client using an access token associated with the
   attacker's protected resources rather than the victim's (e.g., save
   the victim's bank account information to a protected resource
   controlled by the attacker).

   The client MUST implement CSRF protection for its redirection URI.
   This is typically accomplished by requiring any request sent to the
   redirection URI endpoint to include a value that binds the request to
   the user-agent's authenticated state (e.g., a hash of the session
   cookie used to authenticate the user-agent).  The client SHOULD
   utilize the "state" request parameter to deliver this value to the
   authorization server when making an authorization request.

   Once authorization has been obtained from the end-user, the
   authorization server redirects the end-user's user-agent back to the
   client with the required binding value contained in the "state"
   parameter.  The binding value enables the client to verify the
   validity of the request by matching the binding value to the
   user-agent's authenticated state.  The binding value used for CSRF
   protection MUST contain a non-guessable value (as described in
   [Section 10.10](#section-10.10)), and the user-agent's authenticated state (e.g.,
   session cookie, HTML5 local storage) MUST be kept in a location
   accessible only to the client and the user-agent (i.e., protected by
   same-origin policy).

   A CSRF attack against the authorization server's authorization
   endpoint can result in an attacker obtaining end-user authorization
   for a malicious client without involving or alerting the end-user.

   The authorization server MUST implement CSRF protection for its
   authorization endpoint and ensure that a malicious client cannot
   obtain authorization without the awareness and explicit consent of
   the resource owner.

Hardt                        Standards Track                   [Page 59]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[10.13](#section-10.13).  Clickjacking

   In a clickjacking attack, an attacker registers a legitimate client
   and then constructs a malicious site in which it loads the
   authorization server's authorization endpoint web page in a
   transparent iframe overlaid on top of a set of dummy buttons, which
   are carefully constructed to be placed directly under important
   buttons on the authorization page.  When an end-user clicks a
   misleading visible button, the end-user is actually clicking an
   invisible button on the authorization page (such as an "Authorize"
   button).  This allows an attacker to trick a resource owner into
   granting its client access without the end-user's knowledge.

   To prevent this form of attack, native applications SHOULD use
   external browsers instead of embedding browsers within the
   application when requesting end-user authorization.  For most newer
   browsers, avoidance of iframes can be enforced by the authorization
   server using the (non-standard) "x-frame-options" header.  This
   header can have two values, "deny" and "sameorigin", which will block
   any framing, or framing by sites with a different origin,
   respectively.  For older browsers, JavaScript frame-busting
   techniques can be used but may not be effective in all browsers.

[10.14](#section-10.14).  Code Injection and Input Validation

   A code injection attack occurs when an input or otherwise external
   variable is used by an application unsanitized and causes
   modification to the application logic.  This may allow an attacker to
   gain access to the application device or its data, cause denial of
   service, or introduce a wide range of malicious side-effects.

   The authorization server and client MUST sanitize (and validate when
   possible) any value received -- in particular, the value of the
   "state" and "redirect_uri" parameters.

[10.15](#section-10.15).  Open Redirectors

   The authorization server, authorization endpoint, and client
   redirection endpoint can be improperly configured and operate as open
   redirectors.  An open redirector is an endpoint using a parameter to
   automatically redirect a user-agent to the location specified by the
   parameter value without any validation.

   Open redirectors can be used in phishing attacks, or by an attacker
   to get end-users to visit malicious sites by using the URI authority
   component of a familiar and trusted destination.  In addition, if the
   authorization server allows the client to register only part of the
   redirection URI, an attacker can use an open redirector operated by

Hardt                        Standards Track                   [Page 60]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   the client to construct a redirection URI that will pass the
   authorization server validation but will send the authorization code
   or access token to an endpoint under the control of the attacker.

[10.16](#section-10.16).  Misuse of Access Token to Impersonate Resource Owner in Implicit
        Flow

   For public clients using implicit flows, this specification does not
   provide any method for the client to determine what client an access
   token was issued to.

   A resource owner may willingly delegate access to a resource by
   granting an access token to an attacker's malicious client.  This may
   be due to phishing or some other pretext.  An attacker may also steal
   a token via some other mechanism.  An attacker may then attempt to
   impersonate the resource owner by providing the access token to a
   legitimate public client.

   In the implicit flow (response_type=token), the attacker can easily
   switch the token in the response from the authorization server,
   replacing the real access token with the one previously issued to the
   attacker.

   Servers communicating with native applications that rely on being
   passed an access token in the back channel to identify the user of
   the client may be similarly compromised by an attacker creating a
   compromised application that can inject arbitrary stolen access
   tokens.

   Any public client that makes the assumption that only the resource
   owner can present it with a valid access token for the resource is
   vulnerable to this type of attack.

   This type of attack may expose information about the resource owner
   at the legitimate client to the attacker (malicious client).  This
   will also allow the attacker to perform operations at the legitimate
   client with the same permissions as the resource owner who originally
   granted the access token or authorization code.

   Authenticating resource owners to clients is out of scope for this
   specification.  Any specification that uses the authorization process
   as a form of delegated end-user authentication to the client (e.g.,
   third-party sign-in service) MUST NOT use the implicit flow without
   additional security mechanisms that would enable the client to
   determine if the access token was issued for its use (e.g., audience-
   restricting the access token).

Hardt                        Standards Track                   [Page 61]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[11](#section-11).  IANA Considerations

[11.1](#section-11.1).  OAuth Access Token Types Registry

   This specification establishes the OAuth Access Token Types registry.

   Access token types are registered with a Specification Required
   ([[RFC5226](/doc/html/rfc5226)]) after a two-week review period on the
   oauth-ext-review@ietf.org mailing list, on the advice of one or more
   Designated Experts.  However, to allow for the allocation of values
   prior to publication, the Designated Expert(s) may approve
   registration once they are satisfied that such a specification will
   be published.

   Registration requests must be sent to the oauth-ext-review@ietf.org
   mailing list for review and comment, with an appropriate subject
   (e.g., "Request for access token type: example").

   Within the review period, the Designated Expert(s) will either
   approve or deny the registration request, communicating this decision
   to the review list and IANA.  Denials should include an explanation
   and, if applicable, suggestions as to how to make the request
   successful.

   IANA must only accept registry updates from the Designated Expert(s)
   and should direct all requests for registration to the review mailing
   list.

[11.1.1](#section-11.1.1).  Registration Template

   Type name:
      The name requested (e.g., "example").

   Additional Token Endpoint Response Parameters:
      Additional response parameters returned together with the
      "access_token" parameter.  New parameters MUST be separately
      registered in the OAuth Parameters registry as described by
      [Section 11.2](#section-11.2).

   HTTP Authentication Scheme(s):
      The HTTP authentication scheme name(s), if any, used to
      authenticate protected resource requests using access tokens of
      this type.

   Change controller:
      For Standards Track RFCs, state "IETF".  For others, give the name
      of the responsible party.  Other details (e.g., postal address,
      email address, home page URI) may also be included.

Hardt                        Standards Track                   [Page 62]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   Specification document(s):
      Reference to the document(s) that specify the parameter,
      preferably including a URI that can be used to retrieve a copy of
      the document(s).  An indication of the relevant sections may also
      be included but is not required.

[11.2](#section-11.2).  OAuth Parameters Registry

   This specification establishes the OAuth Parameters registry.

   Additional parameters for inclusion in the authorization endpoint
   request, the authorization endpoint response, the token endpoint
   request, or the token endpoint response are registered with a
   Specification Required ([[RFC5226](/doc/html/rfc5226)]) after a two-week review period on
   the oauth-ext-review@ietf.org mailing list, on the advice of one or
   more Designated Experts.  However, to allow for the allocation of
   values prior to publication, the Designated Expert(s) may approve
   registration once they are satisfied that such a specification will
   be published.

   Registration requests must be sent to the oauth-ext-review@ietf.org
   mailing list for review and comment, with an appropriate subject
   (e.g., "Request for parameter: example").

   Within the review period, the Designated Expert(s) will either
   approve or deny the registration request, communicating this decision
   to the review list and IANA.  Denials should include an explanation
   and, if applicable, suggestions as to how to make the request
   successful.

   IANA must only accept registry updates from the Designated Expert(s)
   and should direct all requests for registration to the review mailing
   list.

[11.2.1](#section-11.2.1).  Registration Template

   Parameter name:
      The name requested (e.g., "example").

   Parameter usage location:
      The location(s) where parameter can be used.  The possible
      locations are authorization request, authorization response, token
      request, or token response.

   Change controller:
      For Standards Track RFCs, state "IETF".  For others, give the name
      of the responsible party.  Other details (e.g., postal address,
      email address, home page URI) may also be included.

Hardt                        Standards Track                   [Page 63]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   Specification document(s):
      Reference to the document(s) that specify the parameter,
      preferably including a URI that can be used to retrieve a copy of
      the document(s).  An indication of the relevant sections may also
      be included but is not required.

[11.2.2](#section-11.2.2).  Initial Registry Contents

   The OAuth Parameters registry's initial contents are:

   o  Parameter name: client_id
   o  Parameter usage location: authorization request, token request
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

   o  Parameter name: client_secret
   o  Parameter usage location: token request
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

   o  Parameter name: response_type
   o  Parameter usage location: authorization request
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

   o  Parameter name: redirect_uri
   o  Parameter usage location: authorization request, token request
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

   o  Parameter name: scope
   o  Parameter usage location: authorization request, authorization
      response, token request, token response
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

   o  Parameter name: state
   o  Parameter usage location: authorization request, authorization
      response
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

   o  Parameter name: code
   o  Parameter usage location: authorization response, token request
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

Hardt                        Standards Track                   [Page 64]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   o  Parameter name: error_description
   o  Parameter usage location: authorization response, token response
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

   o  Parameter name: error_uri
   o  Parameter usage location: authorization response, token response
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

   o  Parameter name: grant_type
   o  Parameter usage location: token request
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

   o  Parameter name: access_token
   o  Parameter usage location: authorization response, token response
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

   o  Parameter name: token_type
   o  Parameter usage location: authorization response, token response
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

   o  Parameter name: expires_in
   o  Parameter usage location: authorization response, token response
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

   o  Parameter name: username
   o  Parameter usage location: token request
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

   o  Parameter name: password
   o  Parameter usage location: token request
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

   o  Parameter name: refresh_token
   o  Parameter usage location: token request, token response
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

Hardt                        Standards Track                   [Page 65]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[11.3](#section-11.3).  OAuth Authorization Endpoint Response Types Registry

   This specification establishes the OAuth Authorization Endpoint
   Response Types registry.

   Additional response types for use with the authorization endpoint are
   registered with a Specification Required ([[RFC5226](/doc/html/rfc5226)]) after a two-week
   review period on the oauth-ext-review@ietf.org mailing list, on the
   advice of one or more Designated Experts.  However, to allow for the
   allocation of values prior to publication, the Designated Expert(s)
   may approve registration once they are satisfied that such a
   specification will be published.

   Registration requests must be sent to the oauth-ext-review@ietf.org
   mailing list for review and comment, with an appropriate subject
   (e.g., "Request for response type: example").

   Within the review period, the Designated Expert(s) will either
   approve or deny the registration request, communicating this decision
   to the review list and IANA.  Denials should include an explanation
   and, if applicable, suggestions as to how to make the request
   successful.

   IANA must only accept registry updates from the Designated Expert(s)
   and should direct all requests for registration to the review mailing
   list.

[11.3.1](#section-11.3.1).  Registration Template

   Response type name:
      The name requested (e.g., "example").

   Change controller:
      For Standards Track RFCs, state "IETF".  For others, give the name
      of the responsible party.  Other details (e.g., postal address,
      email address, home page URI) may also be included.

   Specification document(s):
      Reference to the document(s) that specify the type, preferably
      including a URI that can be used to retrieve a copy of the
      document(s).  An indication of the relevant sections may also be
      included but is not required.

Hardt                        Standards Track                   [Page 66]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[11.3.2](#section-11.3.2).  Initial Registry Contents

   The OAuth Authorization Endpoint Response Types registry's initial
   contents are:

   o  Response type name: code
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

   o  Response type name: token
   o  Change controller: IETF
   o  Specification document(s): [RFC 6749](/doc/html/rfc6749)

[11.4](#section-11.4).  OAuth Extensions Error Registry

   This specification establishes the OAuth Extensions Error registry.

   Additional error codes used together with other protocol extensions
   (i.e., extension grant types, access token types, or extension
   parameters) are registered with a Specification Required ([[RFC5226](/doc/html/rfc5226)])
   after a two-week review period on the oauth-ext-review@ietf.org
   mailing list, on the advice of one or more Designated Experts.
   However, to allow for the allocation of values prior to publication,
   the Designated Expert(s) may approve registration once they are
   satisfied that such a specification will be published.

   Registration requests must be sent to the oauth-ext-review@ietf.org
   mailing list for review and comment, with an appropriate subject
   (e.g., "Request for error code: example").

   Within the review period, the Designated Expert(s) will either
   approve or deny the registration request, communicating this decision
   to the review list and IANA.  Denials should include an explanation
   and, if applicable, suggestions as to how to make the request
   successful.

   IANA must only accept registry updates from the Designated Expert(s)
   and should direct all requests for registration to the review mailing
   list.

Hardt                        Standards Track                   [Page 67]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[11.4.1](#section-11.4.1).  Registration Template

   Error name:
      The name requested (e.g., "example").  Values for the error name
      MUST NOT include characters outside the set %x20-21 / %x23-5B /
      %x5D-7E.

   Error usage location:
      The location(s) where the error can be used.  The possible
      locations are authorization code grant error response
      ([Section 4.1.2.1](#section-4.1.2.1)), implicit grant error response
      ([Section 4.2.2.1](#section-4.2.2.1)), token error response ([Section 5.2](#section-5.2)), or resource
      access error response ([Section 7.2](#section-7.2)).

   Related protocol extension:
      The name of the extension grant type, access token type, or
      extension parameter that the error code is used in conjunction
      with.

   Change controller:
      For Standards Track RFCs, state "IETF".  For others, give the name
      of the responsible party.  Other details (e.g., postal address,
      email address, home page URI) may also be included.

   Specification document(s):
      Reference to the document(s) that specify the error code,
      preferably including a URI that can be used to retrieve a copy of
      the document(s).  An indication of the relevant sections may also
      be included but is not required.

[12](#section-12).  References

[12.1](#section-12.1).  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", [BCP 14](/doc/html/bcp14), [RFC 2119](/doc/html/rfc2119), March 1997.

   [RFC2246]  Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
              [RFC 2246](/doc/html/rfc2246), January 1999.

   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", [RFC 2616](/doc/html/rfc2616), June 1999.

   [RFC2617]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
              Leach, P., Luotonen, A., and L. Stewart, "HTTP
              Authentication: Basic and Digest Access Authentication",
              [RFC 2617](/doc/html/rfc2617), June 1999.

Hardt                        Standards Track                   [Page 68]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   [RFC2818]  Rescorla, E., "HTTP Over TLS", [RFC 2818](/doc/html/rfc2818), May 2000.

   [RFC3629]  Yergeau, F., "UTF-8, a transformation format of
              ISO 10646", STD 63, [RFC 3629](/doc/html/rfc3629), November 2003.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              [RFC 3986](/doc/html/rfc3986), January 2005.

   [RFC4627]  Crockford, D., "The application/json Media Type for
              JavaScript Object Notation (JSON)", [RFC 4627](/doc/html/rfc4627), July 2006.

   [RFC4949]  Shirey, R., "Internet Security Glossary, Version 2",
              [RFC 4949](/doc/html/rfc4949), August 2007.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", [BCP 26](/doc/html/bcp26), [RFC 5226](/doc/html/rfc5226),
              May 2008.

   [RFC5234]  Crocker, D. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, [RFC 5234](/doc/html/rfc5234), January 2008.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", [RFC 5246](/doc/html/rfc5246), August 2008.

   [RFC6125]  Saint-Andre, P. and J. Hodges, "Representation and
              Verification of Domain-Based Application Service Identity
              within Internet Public Key Infrastructure Using X.509
              (PKIX) Certificates in the Context of Transport Layer
              Security (TLS)", [RFC 6125](/doc/html/rfc6125), March 2011.

   [USASCII]  American National Standards Institute, "Coded Character
              Set -- 7-bit American Standard Code for Information
              Interchange", ANSI X3.4, 1986.

   [W3C.REC-html401-19991224]
              Raggett, D., Le Hors, A., and I. Jacobs, "HTML 4.01
              Specification", World Wide Web Consortium
              Recommendation REC-html401-19991224, December 1999,
              <<http://www.w3.org/TR/1999/REC-html401-19991224>>.

   [W3C.REC-xml-20081126]
              Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E.,
              and F. Yergeau, "Extensible Markup Language (XML) 1.0
              (Fifth Edition)", World Wide Web Consortium
               Recommendation REC-xml-20081126, November 2008,
              <<http://www.w3.org/TR/2008/REC-xml-20081126>>.

Hardt                        Standards Track                   [Page 69]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[12.2](#section-12.2).  Informative References

   [OAuth-HTTP-MAC]
              Hammer-Lahav, E., Ed., "HTTP Authentication: MAC Access
              Authentication", Work in Progress, February 2012.

   [OAuth-SAML2]
              Campbell, B. and C. Mortimore, "SAML 2.0 Bearer Assertion
              Profiles for OAuth 2.0", Work in Progress, September 2012.

   [OAuth-THREATMODEL]
              Lodderstedt, T., Ed., McGloin, M., and P. Hunt, "OAuth 2.0
              Threat Model and Security Considerations", Work
              in Progress, October 2012.

   [OAuth-WRAP]
              Hardt, D., Ed., Tom, A., Eaton, B., and Y. Goland, "OAuth
              Web Resource Authorization Profiles", Work in Progress,
              January 2010.

   [RFC5849]  Hammer-Lahav, E., "The OAuth 1.0 Protocol", [RFC 5849](/doc/html/rfc5849),
              April 2010.

   [RFC6750]  Jones, M. and D. Hardt, "The OAuth 2.0 Authorization
              Framework: Bearer Token Usage", [RFC 6750](/doc/html/rfc6750), October 2012.

Hardt                        Standards Track                   [Page 70]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[Appendix A](#appendix-A).  Augmented Backus-Naur Form (ABNF) Syntax

   This section provides Augmented Backus-Naur Form (ABNF) syntax
   descriptions for the elements defined in this specification using the
   notation of [[RFC5234](/doc/html/rfc5234 "\"Augmented BNF for Syntax Specifications: ABNF\"")].  The ABNF below is defined in terms of Unicode
   code points [[W3C.REC-xml-20081126](#ref-W3C.REC-xml-20081126)]; these characters are typically
   encoded in UTF-8.  Elements are presented in the order first defined.

   Some of the definitions that follow use the "URI-reference"
   definition from [[RFC3986](/doc/html/rfc3986 "\"Uniform Resource Identifier (URI): Generic Syntax\"")].

   Some of the definitions that follow use these common definitions:

     VSCHAR     = %x20-7E
     NQCHAR     = %x21 / %x23-5B / %x5D-7E
     NQSCHAR    = %x20-21 / %x23-5B / %x5D-7E
     UNICODECHARNOCRLF = %x09 /%x20-7E / %x80-D7FF /
                         %xE000-FFFD / %x10000-10FFFF

   (The UNICODECHARNOCRLF definition is based upon the Char definition
   in Section 2.2 of [[W3C.REC-xml-20081126](#ref-W3C.REC-xml-20081126)], but omitting the Carriage
   Return and Linefeed characters.)

[A.1](#appendix-A.1).  "client_id" Syntax

   The "client_id" element is defined in [Section 2.3.1](#section-2.3.1):

     client-id     = *VSCHAR

[A.2](#appendix-A.2).  "client_secret" Syntax

   The "client_secret" element is defined in [Section 2.3.1](#section-2.3.1):

     client-secret = *VSCHAR

[A.3](#appendix-A.3).  "response_type" Syntax

   The "response_type" element is defined in Sections [3.1.1](#section-3.1.1) and [8.4](#section-8.4):

     response-type = response-name *( SP response-name )
     response-name = 1*response-char
     response-char = "_" / DIGIT / ALPHA

Hardt                        Standards Track                   [Page 71]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[A.4](#appendix-A.4).  "scope" Syntax

   The "scope" element is defined in [Section 3.3](#section-3.3):

     scope       = scope-token *( SP scope-token )
     scope-token = 1*NQCHAR

[A.5](#appendix-A.5).  "state" Syntax

   The "state" element is defined in Sections [4.1.1](#section-4.1.1), [4.1.2](#section-4.1.2), [4.1.2.1](#section-4.1.2.1),
   4.2.1, 4.2.2, and 4.2.2.1:

     state      = 1*VSCHAR

[A.6](#appendix-A.6).  "redirect_uri" Syntax

   The "redirect_uri" element is defined in Sections [4.1.1](#section-4.1.1), [4.1.3](#section-4.1.3),
   and 4.2.1:

     redirect-uri      = URI-reference

[A.7](#appendix-A.7).  "error" Syntax

   The "error" element is defined in Sections [4.1.2.1](#section-4.1.2.1), [4.2.2.1](#section-4.2.2.1), [5.2](#section-5.2),
   7.2, and 8.5:

     error             = 1*NQSCHAR

[A.8](#appendix-A.8).  "error_description" Syntax

   The "error_description" element is defined in Sections [4.1.2.1](#section-4.1.2.1),
   4.2.2.1, 5.2, and 7.2:

     error-description = 1*NQSCHAR

[A.9](#appendix-A.9).  "error_uri" Syntax

   The "error_uri" element is defined in Sections [4.1.2.1](#section-4.1.2.1), [4.2.2.1](#section-4.2.2.1), [5.2](#section-5.2),
   and 7.2:

     error-uri         = URI-reference

Hardt                        Standards Track                   [Page 72]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[A.10](#appendix-A.10).  "grant_type" Syntax

   The "grant_type" element is defined in Sections [4.1.3](#section-4.1.3), [4.3.2](#section-4.3.2), [4.4.2](#section-4.4.2),
   4.5, and 6:

     grant-type = grant-name / URI-reference
     grant-name = 1*name-char
     name-char  = "-" / "." / "_" / DIGIT / ALPHA

[A.11](#appendix-A.11).  "code" Syntax

   The "code" element is defined in [Section 4.1.3](#section-4.1.3):

     code       = 1*VSCHAR

[A.12](#appendix-A.12).  "access_token" Syntax

   The "access_token" element is defined in Sections [4.2.2](#section-4.2.2) and [5.1](#section-5.1):

     access-token = 1*VSCHAR

[A.13](#appendix-A.13).  "token_type" Syntax

   The "token_type" element is defined in Sections [4.2.2](#section-4.2.2), [5.1](#section-5.1), and [8.1](#section-8.1):

     token-type = type-name / URI-reference
     type-name  = 1*name-char
     name-char  = "-" / "." / "_" / DIGIT / ALPHA

[A.14](#appendix-A.14).  "expires_in" Syntax

   The "expires_in" element is defined in Sections [4.2.2](#section-4.2.2) and [5.1](#section-5.1):

     expires-in = 1*DIGIT

[A.15](#appendix-A.15).  "username" Syntax

   The "username" element is defined in [Section 4.3.2](#section-4.3.2):

     username = *UNICODECHARNOCRLF

[A.16](#appendix-A.16).  "password" Syntax

   The "password" element is defined in [Section 4.3.2](#section-4.3.2):

     password = *UNICODECHARNOCRLF

Hardt                        Standards Track                   [Page 73]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[A.17](#appendix-A.17).  "refresh_token" Syntax

   The "refresh_token" element is defined in Sections [5.1](#section-5.1) and [6](#section-6):

     refresh-token = 1*VSCHAR

[A.18](#appendix-A.18).  Endpoint Parameter Syntax

   The syntax for new endpoint parameters is defined in [Section 8.2](#section-8.2):

     param-name = 1*name-char
     name-char  = "-" / "." / "_" / DIGIT / ALPHA

[Appendix B](#appendix-B).  Use of application/x-www-form-urlencoded Media Type

   At the time of publication of this specification, the
   "application/x-www-form-urlencoded" media type was defined in
   Section 17.13.4 of [[W3C.REC-html401-19991224](#ref-W3C.REC-html401-19991224)] but not registered in
   the IANA MIME Media Types registry
   (<<http://www.iana.org/assignments/media-types>>).  Furthermore, that
   definition is incomplete, as it does not consider non-US-ASCII
   characters.

   To address this shortcoming when generating payloads using this media
   type, names and values MUST be encoded using the UTF-8 character
   encoding scheme [[RFC3629](/doc/html/rfc3629 "\"UTF-8, a transformation format of ISO 10646\"")] first; the resulting octet sequence then
   needs to be further encoded using the escaping rules defined in
   [[W3C.REC-html401-19991224](#ref-W3C.REC-html401-19991224)].

   When parsing data from a payload using this media type, the names and
   values resulting from reversing the name/value encoding consequently
   need to be treated as octet sequences, to be decoded using the UTF-8
   character encoding scheme.

   For example, the value consisting of the six Unicode code points
   (1) U+0020 (SPACE), (2) U+0025 (PERCENT SIGN),
   (3) U+0026 (AMPERSAND), (4) U+002B (PLUS SIGN),
   (5) U+00A3 (POUND SIGN), and (6) U+20AC (EURO SIGN) would be encoded
   into the octet sequence below (using hexadecimal notation):

     20 25 26 2B C2 A3 E2 82 AC

   and then represented in the payload as:

     +%25%26%2B%C2%A3%E2%82%AC

Hardt                        Standards Track                   [Page 74]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

[Appendix C](#appendix-C).  Acknowledgements

   The initial OAuth 2.0 protocol specification was edited by David
   Recordon, based on two previous publications: the OAuth 1.0 community
   specification [[RFC5849](/doc/html/rfc5849 "\"The OAuth 1.0 Protocol\"")], and OAuth WRAP (OAuth Web Resource
   Authorization Profiles) [[OAuth-WRAP](#ref-OAuth-WRAP)].  Eran Hammer then edited many
   of the intermediate drafts that evolved into this RFC.  The Security
   Considerations section was drafted by Torsten Lodderstedt, Mark
   McGloin, Phil Hunt, Anthony Nadalin, and John Bradley.  The section
   on use of the "application/x-www-form-urlencoded" media type was
   drafted by Julian Reschke.  The ABNF section was drafted by Michael
   B. Jones.

   The OAuth 1.0 community specification was edited by Eran Hammer and
   authored by Mark Atwood, Dirk Balfanz, Darren Bounds, Richard M.
   Conlan, Blaine Cook, Leah Culver, Breno de Medeiros, Brian Eaton,
   Kellan Elliott-McCrea, Larry Halff, Eran Hammer, Ben Laurie, Chris
   Messina, John Panzer, Sam Quigley, David Recordon, Eran Sandler,
   Jonathan Sergent, Todd Sieling, Brian Slesinsky, and Andy Smith.

   The OAuth WRAP specification was edited by Dick Hardt and authored by
   Brian Eaton, Yaron Y. Goland, Dick Hardt, and Allen Tom.

   This specification is the work of the OAuth Working Group, which
   includes dozens of active and dedicated participants.  In particular,
   the following individuals contributed ideas, feedback, and wording
   that shaped and formed the final specification:

   Michael Adams, Amanda Anganes, Andrew Arnott, Dirk Balfanz, Aiden
   Bell, John Bradley, Marcos Caceres, Brian Campbell, Scott Cantor,
   Blaine Cook, Roger Crew, Leah Culver, Bill de hOra, Andre DeMarre,
   Brian Eaton, Wesley Eddy, Wolter Eldering, Brian Ellin, Igor
   Faynberg, George Fletcher, Tim Freeman, Luca Frosini, Evan Gilbert,
   Yaron Y. Goland, Brent Goldman, Kristoffer Gronowski, Eran Hammer,
   Dick Hardt, Justin Hart, Craig Heath, Phil Hunt, Michael B. Jones,
   Terry Jones, John Kemp, Mark Kent, Raffi Krikorian, Chasen Le Hara,
   Rasmus Lerdorf, Torsten Lodderstedt, Hui-Lan Lu, Casey Lucas, Paul
   Madsen, Alastair Mair, Eve Maler, James Manger, Mark McGloin,
   Laurence Miao, William Mills, Chuck Mortimore, Anthony Nadalin,
   Julian Reschke, Justin Richer, Peter Saint-Andre, Nat Sakimura, Rob
   Sayre, Marius Scurtescu, Naitik Shah, Luke Shepard, Vlad Skvortsov,
   Justin Smith, Haibin Song, Niv Steingarten, Christian Stuebner,
   Jeremy Suriel, Paul Tarjan, Christopher Thomas, Henry S. Thompson,
   Allen Tom, Franklin Tse, Nick Walker, Shane Weeden, and Skylar
   Woodward.

Hardt                        Standards Track                   [Page 75]
```

---

```

[RFC 6749](/doc/html/rfc6749)                        OAuth 2.0                   October 2012

   This document was produced under the chairmanship of Blaine Cook,
   Peter Saint-Andre, Hannes Tschofenig, Barry Leiba, and Derek Atkins.
   The area directors included Lisa Dusseault, Peter Saint-Andre, and
   Stephen Farrell.

Author's Address

   Dick Hardt (editor)
   Microsoft

   EMail: dick.hardt@gmail.com
   URI:   <http://dickhardt.org/>

Hardt                        Standards Track                   [Page 76]

```

[Datatracker](/doc/rfc6749/)

RFC 6749

RFC
- Proposed Standard

* Info
* Contents
* Prefs

| Document | Document type |  | RFC - Proposed Standard  October 2012  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=6749 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") [IPR](/ipr/search/?submit=draft&id=rfc6749 "Click to view IPR declarations.") Updated by [RFC 8252](/doc/html/rfc8252 "OAuth 2.0 for Native Apps"), [RFC 8996](/doc/html/rfc8996 "Deprecating TLS 1.0 and TLS 1.1") Obsoletes [RFC 5849](/doc/html/rfc5849 "The OAuth 1.0 Protocol") Was [draft-ietf-oauth-v2](/doc/draft-ietf-oauth-v2/31/) ([oauth WG](/wg/oauth/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [23](/doc/html/draft-ietf-oauth-v2-23) * [24](/doc/html/draft-ietf-oauth-v2-24) * [25](/doc/html/draft-ietf-oauth-v2-25) * [26](/doc/html/draft-ietf-oauth-v2-26) * [27](/doc/html/draft-ietf-oauth-v2-27) * [28](/doc/html/draft-ietf-oauth-v2-28) * [29](/doc/html/draft-ietf-oauth-v2-29) * [30](/doc/html/draft-ietf-oauth-v2-30) * [31](/doc/html/draft-ietf-oauth-v2-31) * [RFC 6749](/doc/html/rfc6749) |
|  | Compare versions |  | RFC 6749  draft-ietf-oauth-v2-31  draft-ietf-oauth-v2-30  draft-ietf-oauth-v2-29  draft-ietf-oauth-v2-28  draft-ietf-oauth-v2-27  draft-ietf-oauth-v2-26  draft-ietf-oauth-v2-25  draft-ietf-oauth-v2-24  draft-ietf-oauth-v2-23  draft-ietf-oauth-v2-22  draft-ietf-oauth-v2-21  draft-ietf-oauth-v2-20  draft-ietf-oauth-v2-19  draft-ietf-oauth-v2-18  draft-ietf-oauth-v2-17  draft-ietf-oauth-v2-16  draft-ietf-oauth-v2-15  draft-ietf-oauth-v2-14  draft-ietf-oauth-v2-13  draft-ietf-oauth-v2-12  draft-ietf-oauth-v2-11  draft-ietf-oauth-v2-10  draft-ietf-oauth-v2-09  draft-ietf-oauth-v2-08  draft-ietf-oauth-v2-07  draft-ietf-oauth-v2-06  draft-ietf-oauth-v2-05  draft-ietf-oauth-v2-04  draft-ietf-oauth-v2-03  draft-ietf-oauth-v2-02  draft-ietf-oauth-v2-01  draft-ietf-oauth-v2-00   RFC 6749  draft-ietf-oauth-v2-31  draft-ietf-oauth-v2-30  draft-ietf-oauth-v2-29  draft-ietf-oauth-v2-28  draft-ietf-oauth-v2-27  draft-ietf-oauth-v2-26  draft-ietf-oauth-v2-25  draft-ietf-oauth-v2-24  draft-ietf-oauth-v2-23  draft-ietf-oauth-v2-22  draft-ietf-oauth-v2-21  draft-ietf-oauth-v2-20  draft-ietf-oauth-v2-19  draft-ietf-oauth-v2-18  draft-ietf-oauth-v2-17  draft-ietf-oauth-v2-16  draft-ietf-oauth-v2-15  draft-ietf-oauth-v2-14  draft-ietf-oauth-v2-13  draft-ietf-oauth-v2-12  draft-ietf-oauth-v2-11  draft-ietf-oauth-v2-10  draft-ietf-oauth-v2-09  draft-ietf-oauth-v2-08  draft-ietf-oauth-v2-07  draft-ietf-oauth-v2-06  draft-ietf-oauth-v2-05  draft-ietf-oauth-v2-04  draft-ietf-oauth-v2-03  draft-ietf-oauth-v2-02  draft-ietf-oauth-v2-01  draft-ietf-oauth-v2-00   Side-by-side  Inline |
|  | Author |  | [Dick Hardt](/person/dick.hardt%40gmail.com "Datatracker profile of Dick Hardt")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc6749.txt) [html](https://www.rfc-editor.org/rfc/rfc6749.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc6749.txt.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc6749.html) [bibtex](/doc/rfc6749/bibtex/) |
|  | Additional resources |  | [Mailing list discussion](https://mailarchive.ietf.org/arch/browse/oauth/?q=rfc6749 OR %22draft-ietf-oauth-v2%22) |

[Report a datatracker bug](https://github.com/ietf-tools/datatracker/issues/new/choose)

Show sidebar by default

Yes

No

Tab to show by default

Info

Contents

HTMLization configuration

HTMLize the plaintext

Plaintextify the HTML

Maximum font size

Page dependencies

Inline

Reference

Citation links

 Go to reference section

Go to linked document

![](//analytics.ietf.org/piwik.php?idsite=7)



=== Content from tools.ietf.org_97fb2128_20250119_124243.html ===


* Light
* Dark
* Auto

[RFC 3986

Internet Standard](/doc/rfc3986/)

|  | Title |  | Uniform Resource Identifier (URI): Generic Syntax |
| --- | --- | --- | --- |
| Document | Document type |  | RFC - Internet Standard  January 2005  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=3986 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") Updated by [RFC 8820](/doc/html/rfc8820 "URI Design and Ownership"), [RFC 6874](/doc/html/rfc6874 "Representing IPv6 Zone Identifiers in Address Literals and Uniform Resource Identifiers"), [RFC 7320](/doc/html/rfc7320 "URI Design and Ownership") Obsoletes [RFC 1808](/doc/html/rfc1808 "Relative Uniform Resource Locators"), [RFC 2732](/doc/html/rfc2732 "Format for Literal IPv6 Addresses in URL's"), [RFC 2396](/doc/html/rfc2396 "Uniform Resource Identifiers (URI): Generic Syntax") Updates [RFC 1738](/doc/html/rfc1738 "Uniform Resource Locators (URL)") Was [draft-fielding-uri-rfc2396bis](/doc/draft-fielding-uri-rfc2396bis/07/) (individual in gen area) |
| --- | --- | --- | --- |
|  | Select version |  | * [07](/doc/html/draft-fielding-uri-rfc2396bis-07) * [RFC 3986](/doc/html/rfc3986) |
|  | Compare versions |  | RFC 3986  draft-fielding-uri-rfc2396bis-07  draft-fielding-uri-rfc2396bis-06  draft-fielding-uri-rfc2396bis-05  draft-fielding-uri-rfc2396bis-04  draft-fielding-uri-rfc2396bis-03  draft-fielding-uri-rfc2396bis-02  draft-fielding-uri-rfc2396bis-01  draft-fielding-uri-rfc2396bis-00   RFC 3986  draft-fielding-uri-rfc2396bis-07  draft-fielding-uri-rfc2396bis-06  draft-fielding-uri-rfc2396bis-05  draft-fielding-uri-rfc2396bis-04  draft-fielding-uri-rfc2396bis-03  draft-fielding-uri-rfc2396bis-02  draft-fielding-uri-rfc2396bis-01  draft-fielding-uri-rfc2396bis-00   Side-by-side  Inline |
|  | Authors |  | [Tim Berners-Lee](/person/timbl%40w3.org "Datatracker profile of Tim Berners-Lee") , [Roy T. Fielding](/person/fielding%40gbiv.com "Datatracker profile of Roy T. Fielding") , [Larry M Masinter](/person/lmm%40acm.org "Datatracker profile of Larry M Masinter")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc3986.txt) [html](https://www.rfc-editor.org/rfc/rfc3986.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc3986.txt.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc3986.html) [bibtex](/doc/rfc3986/bibtex/) |
|  |  |  | [Report a bug](https://github.com/ietf-tools/datatracker/issues/new/choose) |

```
Network Working Group                                     T. Berners-Lee
Request for Comments: 3986                                       W3C/MIT
STD: 66                                                      R. Fielding
Updates: [1738](/doc/html/rfc1738)                                               Day Software
Obsoletes: [2732](/doc/html/rfc2732), [2396](/doc/html/rfc2396), [1808](/doc/html/rfc1808)                                  L. Masinter
Category: Standards Track                                  Adobe Systems
                                                            January 2005

           Uniform Resource Identifier (URI): Generic Syntax

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2005).

Abstract

   A Uniform Resource Identifier (URI) is a compact sequence of
   characters that identifies an abstract or physical resource.  This
   specification defines the generic URI syntax and a process for
   resolving URI references that might be in relative form, along with
   guidelines and security considerations for the use of URIs on the
   Internet.  The URI syntax defines a grammar that is a superset of all
   valid URIs, allowing an implementation to parse the common components
   of a URI reference without knowing the scheme-specific requirements
   of every possible identifier.  This specification does not define a
   generative grammar for URIs; that task is performed by the individual
   specifications of each URI scheme.

Berners-Lee, et al.         Standards Track                     [Page 1]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

Table of Contents

   [1](#section-1).  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  [4](#page-4)
       [1.1](#section-1.1).  Overview of URIs . . . . . . . . . . . . . . . . . . . .  [4](#page-4)
             [1.1.1](#section-1.1.1).  Generic Syntax . . . . . . . . . . . . . . . . .  [6](#page-6)
             [1.1.2](#section-1.1.2).  Examples . . . . . . . . . . . . . . . . . . . .  [7](#page-7)
             [1.1.3](#section-1.1.3).  URI, URL, and URN  . . . . . . . . . . . . . . .  [7](#page-7)
       [1.2](#section-1.2).  Design Considerations  . . . . . . . . . . . . . . . . .  [8](#page-8)
             [1.2.1](#section-1.2.1).  Transcription  . . . . . . . . . . . . . . . . .  [8](#page-8)
             [1.2.2](#section-1.2.2).  Separating Identification from Interaction . . .  [9](#page-9)
             [1.2.3](#section-1.2.3).  Hierarchical Identifiers . . . . . . . . . . . . [10](#page-10)
       [1.3](#section-1.3).  Syntax Notation  . . . . . . . . . . . . . . . . . . . . [11](#page-11)
   [2](#section-2).  Characters . . . . . . . . . . . . . . . . . . . . . . . . . . [11](#page-11)
       [2.1](#section-2.1).  Percent-Encoding . . . . . . . . . . . . . . . . . . . . [12](#page-12)
       [2.2](#section-2.2).  Reserved Characters  . . . . . . . . . . . . . . . . . . [12](#page-12)
       [2.3](#section-2.3).  Unreserved Characters  . . . . . . . . . . . . . . . . . [13](#page-13)
       [2.4](#section-2.4).  When to Encode or Decode . . . . . . . . . . . . . . . . [14](#page-14)
       [2.5](#section-2.5).  Identifying Data . . . . . . . . . . . . . . . . . . . . [14](#page-14)
   [3](#section-3).  Syntax Components  . . . . . . . . . . . . . . . . . . . . . . [16](#page-16)
       [3.1](#section-3.1).  Scheme . . . . . . . . . . . . . . . . . . . . . . . . . [17](#page-17)
       [3.2](#section-3.2).  Authority  . . . . . . . . . . . . . . . . . . . . . . . [17](#page-17)
             [3.2.1](#section-3.2.1).  User Information . . . . . . . . . . . . . . . . [18](#page-18)
             [3.2.2](#section-3.2.2).  Host . . . . . . . . . . . . . . . . . . . . . . [18](#page-18)
             [3.2.3](#section-3.2.3).  Port . . . . . . . . . . . . . . . . . . . . . . [22](#page-22)
       [3.3](#section-3.3).  Path . . . . . . . . . . . . . . . . . . . . . . . . . . [22](#page-22)
       [3.4](#section-3.4).  Query  . . . . . . . . . . . . . . . . . . . . . . . . . [23](#page-23)
       [3.5](#section-3.5).  Fragment . . . . . . . . . . . . . . . . . . . . . . . . [24](#page-24)
   [4](#section-4).  Usage  . . . . . . . . . . . . . . . . . . . . . . . . . . . . [25](#page-25)
       [4.1](#section-4.1).  URI Reference  . . . . . . . . . . . . . . . . . . . . . [25](#page-25)
       [4.2](#section-4.2).  Relative Reference . . . . . . . . . . . . . . . . . . . [26](#page-26)
       [4.3](#section-4.3).  Absolute URI . . . . . . . . . . . . . . . . . . . . . . [27](#page-27)
       [4.4](#section-4.4).  Same-Document Reference  . . . . . . . . . . . . . . . . [27](#page-27)
       [4.5](#section-4.5).  Suffix Reference . . . . . . . . . . . . . . . . . . . . [27](#page-27)
   [5](#section-5).  Reference Resolution . . . . . . . . . . . . . . . . . . . . . [28](#page-28)
       [5.1](#section-5.1).  Establishing a Base URI  . . . . . . . . . . . . . . . . [28](#page-28)
             [5.1.1](#section-5.1.1).  Base URI Embedded in Content . . . . . . . . . . [29](#page-29)
             [5.1.2](#section-5.1.2).  Base URI from the Encapsulating Entity . . . . . [29](#page-29)
             [5.1.3](#section-5.1.3).  Base URI from the Retrieval URI  . . . . . . . . [30](#page-30)
             [5.1.4](#section-5.1.4).  Default Base URI . . . . . . . . . . . . . . . . [30](#page-30)
       [5.2](#section-5.2).  Relative Resolution  . . . . . . . . . . . . . . . . . . [30](#page-30)
             [5.2.1](#section-5.2.1).  Pre-parse the Base URI . . . . . . . . . . . . . [31](#page-31)
             [5.2.2](#section-5.2.2).  Transform References . . . . . . . . . . . . . . [31](#page-31)
             [5.2.3](#section-5.2.3).  Merge Paths  . . . . . . . . . . . . . . . . . . [32](#page-32)
             [5.2.4](#section-5.2.4).  Remove Dot Segments  . . . . . . . . . . . . . . [33](#page-33)
       [5.3](#section-5.3).  Component Recomposition  . . . . . . . . . . . . . . . . [35](#page-35)
       [5.4](#section-5.4).  Reference Resolution Examples  . . . . . . . . . . . . . [35](#page-35)
             [5.4.1](#section-5.4.1).  Normal Examples  . . . . . . . . . . . . . . . . [36](#page-36)
             [5.4.2](#section-5.4.2).  Abnormal Examples  . . . . . . . . . . . . . . . [36](#page-36)

Berners-Lee, et al.         Standards Track                     [Page 2]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   [6](#section-6).  Normalization and Comparison . . . . . . . . . . . . . . . . . [38](#page-38)
       [6.1](#section-6.1).  Equivalence  . . . . . . . . . . . . . . . . . . . . . . [38](#page-38)
       [6.2](#section-6.2).  Comparison Ladder  . . . . . . . . . . . . . . . . . . . [39](#page-39)
             [6.2.1](#section-6.2.1).  Simple String Comparison . . . . . . . . . . . . [39](#page-39)
             [6.2.2](#section-6.2.2).  Syntax-Based Normalization . . . . . . . . . . . [40](#page-40)
             [6.2.3](#section-6.2.3).  Scheme-Based Normalization . . . . . . . . . . . [41](#page-41)
             [6.2.4](#section-6.2.4).  Protocol-Based Normalization . . . . . . . . . . [42](#page-42)
   [7](#section-7).  Security Considerations  . . . . . . . . . . . . . . . . . . . [43](#page-43)
       [7.1](#section-7.1).  Reliability and Consistency  . . . . . . . . . . . . . . [43](#page-43)
       [7.2](#section-7.2).  Malicious Construction . . . . . . . . . . . . . . . . . [43](#page-43)
       [7.3](#section-7.3).  Back-End Transcoding . . . . . . . . . . . . . . . . . . [44](#page-44)
       [7.4](#section-7.4).  Rare IP Address Formats  . . . . . . . . . . . . . . . . [45](#page-45)
       [7.5](#section-7.5).  Sensitive Information  . . . . . . . . . . . . . . . . . [45](#page-45)
       [7.6](#section-7.6).  Semantic Attacks . . . . . . . . . . . . . . . . . . . . [45](#page-45)
   [8](#section-8).  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . [46](#page-46)
   [9](#section-9).  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . [46](#page-46)
   [10](#section-10). References . . . . . . . . . . . . . . . . . . . . . . . . . . [46](#page-46)
       [10.1](#section-10.1). Normative References . . . . . . . . . . . . . . . . . . [46](#page-46)
       [10.2](#section-10.2). Informative References . . . . . . . . . . . . . . . . . [47](#page-47)
   [A](#appendix-A).  Collected ABNF for URI . . . . . . . . . . . . . . . . . . . . [49](#page-49)
   [B](#appendix-B).  Parsing a URI Reference with a Regular Expression  . . . . . . [50](#page-50)
   [C](#appendix-C).  Delimiting a URI in Context  . . . . . . . . . . . . . . . . . [51](#page-51)
   [D](#appendix-D).  Changes from [RFC 2396](/doc/html/rfc2396)  . . . . . . . . . . . . . . . . . . . . [53](#page-53)
       [D.1](#appendix-D.1).  Additions  . . . . . . . . . . . . . . . . . . . . . . . [53](#page-53)
       [D.2](#appendix-D.2).  Modifications  . . . . . . . . . . . . . . . . . . . . . [53](#page-53)
   Index  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . [56](#page-56)
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . [60](#page-60)
   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . . [61](#page-61)

Berners-Lee, et al.         Standards Track                     [Page 3]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

[1](#section-1).  Introduction

   A Uniform Resource Identifier (URI) provides a simple and extensible
   means for identifying a resource.  This specification of URI syntax
   and semantics is derived from concepts introduced by the World Wide
   Web global information initiative, whose use of these identifiers
   dates from 1990 and is described in "Universal Resource Identifiers
   in WWW" [[RFC1630](/doc/html/rfc1630)].  The syntax is designed to meet the
   recommendations laid out in "Functional Recommendations for Internet
   Resource Locators" [[RFC1736](/doc/html/rfc1736)] and "Functional Requirements for Uniform
   Resource Names" [[RFC1737](/doc/html/rfc1737)].

   This document obsoletes [[RFC2396](/doc/html/rfc2396)], which merged "Uniform Resource
   Locators" [[RFC1738](/doc/html/rfc1738)] and "Relative Uniform Resource Locators"
   [[RFC1808](/doc/html/rfc1808)] in order to define a single, generic syntax for all URIs.
   It obsoletes [[RFC2732](/doc/html/rfc2732)], which introduced syntax for an IPv6 address.
   It excludes portions of [RFC 1738](/doc/html/rfc1738) that defined the specific syntax of
   individual URI schemes; those portions will be updated as separate
   documents.  The process for registration of new URI schemes is
   defined separately by [[BCP35](#ref-BCP35)].  Advice for designers of new URI
   schemes can be found in [[RFC2718](/doc/html/rfc2718)].  All significant changes from [RFC](/doc/html/rfc2396)
   [2396](/doc/html/rfc2396) are noted in [Appendix D](#appendix-D).

   This specification uses the terms "character" and "coded character
   set" in accordance with the definitions provided in [[BCP19](#ref-BCP19)], and
   "character encoding" in place of what [[BCP19](#ref-BCP19)] refers to as a
   "charset".

[1.1](#section-1.1).  Overview of URIs

   URIs are characterized as follows:

   Uniform

      Uniformity provides several benefits.  It allows different types
      of resource identifiers to be used in the same context, even when
      the mechanisms used to access those resources may differ.  It
      allows uniform semantic interpretation of common syntactic
      conventions across different types of resource identifiers.  It
      allows introduction of new types of resource identifiers without
      interfering with the way that existing identifiers are used.  It
      allows the identifiers to be reused in many different contexts,
      thus permitting new applications or protocols to leverage a pre-
      existing, large, and widely used set of resource identifiers.

Berners-Lee, et al.         Standards Track                     [Page 4]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   Resource

      This specification does not limit the scope of what might be a
      resource; rather, the term "resource" is used in a general sense
      for whatever might be identified by a URI.  Familiar examples
      include an electronic document, an image, a source of information
      with a consistent purpose (e.g., "today's weather report for Los
      Angeles"), a service (e.g., an HTTP-to-SMS gateway), and a
      collection of other resources.  A resource is not necessarily
      accessible via the Internet; e.g., human beings, corporations, and
      bound books in a library can also be resources.  Likewise,
      abstract concepts can be resources, such as the operators and
      operands of a mathematical equation, the types of a relationship
      (e.g., "parent" or "employee"), or numeric values (e.g., zero,
      one, and infinity).

   Identifier

      An identifier embodies the information required to distinguish
      what is being identified from all other things within its scope of
      identification.  Our use of the terms "identify" and "identifying"
      refer to this purpose of distinguishing one resource from all
      other resources, regardless of how that purpose is accomplished
      (e.g., by name, address, or context).  These terms should not be
      mistaken as an assumption that an identifier defines or embodies
      the identity of what is referenced, though that may be the case
      for some identifiers.  Nor should it be assumed that a system
      using URIs will access the resource identified: in many cases,
      URIs are used to denote resources without any intention that they
      be accessed.  Likewise, the "one" resource identified might not be
      singular in nature (e.g., a resource might be a named set or a
      mapping that varies over time).

   A URI is an identifier consisting of a sequence of characters
   matching the syntax rule named <URI> in [Section 3](#section-3).  It enables
   uniform identification of resources via a separately defined
   extensible set of naming schemes ([Section 3.1](#section-3.1)).  How that
   identification is accomplished, assigned, or enabled is delegated to
   each scheme specification.

   This specification does not place any limits on the nature of a
   resource, the reasons why an application might seek to refer to a
   resource, or the kinds of systems that might use URIs for the sake of
   identifying resources.  This specification does not require that a
   URI persists in identifying the same resource over time, though that
   is a common goal of all URI schemes.  Nevertheless, nothing in this

Berners-Lee, et al.         Standards Track                     [Page 5]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   specification prevents an application from limiting itself to
   particular types of resources, or to a subset of URIs that maintains
   characteristics desired by that application.

   URIs have a global scope and are interpreted consistently regardless
   of context, though the result of that interpretation may be in
   relation to the end-user's context.  For example, "http://localhost/"
   has the same interpretation for every user of that reference, even
   though the network interface corresponding to "localhost" may be
   different for each end-user: interpretation is independent of access.
   However, an action made on the basis of that reference will take
   place in relation to the end-user's context, which implies that an
   action intended to refer to a globally unique thing must use a URI
   that distinguishes that resource from all other things.  URIs that
   identify in relation to the end-user's local context should only be
   used when the context itself is a defining aspect of the resource,
   such as when an on-line help manual refers to a file on the end-
   user's file system (e.g., "file:///etc/hosts").

[1.1.1](#section-1.1.1).  Generic Syntax

   Each URI begins with a scheme name, as defined in [Section 3.1](#section-3.1), that
   refers to a specification for assigning identifiers within that
   scheme.  As such, the URI syntax is a federated and extensible naming
   system wherein each scheme's specification may further restrict the
   syntax and semantics of identifiers using that scheme.

   This specification defines those elements of the URI syntax that are
   required of all URI schemes or are common to many URI schemes.  It
   thus defines the syntax and semantics needed to implement a scheme-
   independent parsing mechanism for URI references, by which the
   scheme-dependent handling of a URI can be postponed until the
   scheme-dependent semantics are needed.  Likewise, protocols and data
   formats that make use of URI references can refer to this
   specification as a definition for the range of syntax allowed for all
   URIs, including those schemes that have yet to be defined.  This
   decouples the evolution of identification schemes from the evolution
   of protocols, data formats, and implementations that make use of
   URIs.

   A parser of the generic URI syntax can parse any URI reference into
   its major components.  Once the scheme is determined, further
   scheme-specific parsing can be performed on the components.  In other
   words, the URI generic syntax is a superset of the syntax of all URI
   schemes.

Berners-Lee, et al.         Standards Track                     [Page 6]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

[1.1.2](#section-1.1.2).  Examples

   The following example URIs illustrate several URI schemes and
   variations in their common syntax components:

      ftp://ftp.is.co.za/rfc/rfc1808.txt

      <http://www.ietf.org/rfc/rfc2396.txt>

      ldap://[2001:db8::7]/c=GB?objectClass?one

      mailto:John.Doe@example.com

      news:comp.infosystems.www.servers.unix

      tel:+1-816-555-1212

      telnet://192.0.2.16:80/

      urn:oasis:names:specification:docbook:dtd:xml:4.1.2

[1.1.3](#section-1.1.3).  URI, URL, and URN

   A URI can be further classified as a locator, a name, or both.  The
   term "Uniform Resource Locator" (URL) refers to the subset of URIs
   that, in addition to identifying a resource, provide a means of
   locating the resource by describing its primary access mechanism
   (e.g., its network "location").  The term "Uniform Resource Name"
   (URN) has been used historically to refer to both URIs under the
   "urn" scheme [[RFC2141](/doc/html/rfc2141)], which are required to remain globally unique
   and persistent even when the resource ceases to exist or becomes
   unavailable, and to any other URI with the properties of a name.

   An individual scheme does not have to be classified as being just one
   of "name" or "locator".  Instances of URIs from any given scheme may
   have the characteristics of names or locators or both, often
   depending on the persistence and care in the assignment of
   identifiers by the naming authority, rather than on any quality of
   the scheme.  Future specifications and related documentation should
   use the general term "URI" rather than the more restrictive terms
   "URL" and "URN" [[RFC3305](/doc/html/rfc3305)].

Berners-Lee, et al.         Standards Track                     [Page 7]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

[1.2](#section-1.2).  Design Considerations

[1.2.1](#section-1.2.1).  Transcription

   The URI syntax has been designed with global transcription as one of
   its main considerations.  A URI is a sequence of characters from a
   very limited set: the letters of the basic Latin alphabet, digits,
   and a few special characters.  A URI may be represented in a variety
   of ways; e.g., ink on paper, pixels on a screen, or a sequence of
   character encoding octets.  The interpretation of a URI depends only
   on the characters used and not on how those characters are
   represented in a network protocol.

   The goal of transcription can be described by a simple scenario.
   Imagine two colleagues, Sam and Kim, sitting in a pub at an
   international conference and exchanging research ideas.  Sam asks Kim
   for a location to get more information, so Kim writes the URI for the
   research site on a napkin.  Upon returning home, Sam takes out the
   napkin and types the URI into a computer, which then retrieves the
   information to which Kim referred.

   There are several design considerations revealed by the scenario:

   o  A URI is a sequence of characters that is not always represented
      as a sequence of octets.

   o  A URI might be transcribed from a non-network source and thus
      should consist of characters that are most likely able to be
      entered into a computer, within the constraints imposed by
      keyboards (and related input devices) across languages and
      locales.

   o  A URI often has to be remembered by people, and it is easier for
      people to remember a URI when it consists of meaningful or
      familiar components.

   These design considerations are not always in alignment.  For
   example, it is often the case that the most meaningful name for a URI
   component would require characters that cannot be typed into some
   systems.  The ability to transcribe a resource identifier from one
   medium to another has been considered more important than having a
   URI consist of the most meaningful of components.

   In local or regional contexts and with improving technology, users
   might benefit from being able to use a wider range of characters;
   such use is not defined by this specification.  Percent-encoded
   octets ([Section 2.1](#section-2.1)) may be used within a URI to represent characters
   outside the range of the US-ASCII coded character set if this

Berners-Lee, et al.         Standards Track                     [Page 8]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   representation is allowed by the scheme or by the protocol element in
   which the URI is referenced.  Such a definition should specify the
   character encoding used to map those characters to octets prior to
   being percent-encoded for the URI.

[1.2.2](#section-1.2.2).  Separating Identification from Interaction

   A common misunderstanding of URIs is that they are only used to refer
   to accessible resources.  The URI itself only provides
   identification; access to the resource is neither guaranteed nor
   implied by the presence of a URI.  Instead, any operation associated
   with a URI reference is defined by the protocol element, data format
   attribute, or natural language text in which it appears.

   Given a URI, a system may attempt to perform a variety of operations
   on the resource, as might be characterized by words such as "access",
   "update", "replace", or "find attributes".  Such operations are
   defined by the protocols that make use of URIs, not by this
   specification.  However, we do use a few general terms for describing
   common operations on URIs.  URI "resolution" is the process of
   determining an access mechanism and the appropriate parameters
   necessary to dereference a URI; this resolution may require several
   iterations.  To use that access mechanism to perform an action on the
   URI's resource is to "dereference" the URI.

   When URIs are used within information retrieval systems to identify
   sources of information, the most common form of URI dereference is
   "retrieval": making use of a URI in order to retrieve a
   representation of its associated resource.  A "representation" is a
   sequence of octets, along with representation metadata describing
   those octets, that constitutes a record of the state of the resource
   at the time when the representation is generated.  Retrieval is
   achieved by a process that might include using the URI as a cache key
   to check for a locally cached representation, resolution of the URI
   to determine an appropriate access mechanism (if any), and
   dereference of the URI for the sake of applying a retrieval
   operation.  Depending on the protocols used to perform the retrieval,
   additional information might be supplied about the resource (resource
   metadata) and its relation to other resources.

   URI references in information retrieval systems are designed to be
   late-binding: the result of an access is generally determined when it
   is accessed and may vary over time or due to other aspects of the
   interaction.  These references are created in order to be used in the
   future: what is being identified is not some specific result that was
   obtained in the past, but rather some characteristic that is expected
   to be true for future results.  In such cases, the resource referred
   to by the URI is actually a sameness of characteristics as observed

Berners-Lee, et al.         Standards Track                     [Page 9]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   over time, perhaps elucidated by additional comments or assertions
   made by the resource provider.

   Although many URI schemes are named after protocols, this does not
   imply that use of these URIs will result in access to the resource
   via the named protocol.  URIs are often used simply for the sake of
   identification.  Even when a URI is used to retrieve a representation
   of a resource, that access might be through gateways, proxies,
   caches, and name resolution services that are independent of the
   protocol associated with the scheme name.  The resolution of some
   URIs may require the use of more than one protocol (e.g., both DNS
   and HTTP are typically used to access an "http" URI's origin server
   when a representation isn't found in a local cache).

[1.2.3](#section-1.2.3).  Hierarchical Identifiers

   The URI syntax is organized hierarchically, with components listed in
   order of decreasing significance from left to right.  For some URI
   schemes, the visible hierarchy is limited to the scheme itself:
   everything after the scheme component delimiter (":") is considered
   opaque to URI processing.  Other URI schemes make the hierarchy
   explicit and visible to generic parsing algorithms.

   The generic syntax uses the slash ("/"), question mark ("?"), and
   number sign ("#") characters to delimit components that are
   significant to the generic parser's hierarchical interpretation of an
   identifier.  In addition to aiding the readability of such
   identifiers through the consistent use of familiar syntax, this
   uniform representation of hierarchy across naming schemes allows
   scheme-independent references to be made relative to that hierarchy.

   It is often the case that a group or "tree" of documents has been
   constructed to serve a common purpose, wherein the vast majority of
   URI references in these documents point to resources within the tree
   rather than outside it.  Similarly, documents located at a particular
   site are much more likely to refer to other resources at that site
   than to resources at remote sites.  Relative referencing of URIs
   allows document trees to be partially independent of their location
   and access scheme.  For instance, it is possible for a single set of
   hypertext documents to be simultaneously accessible and traversable
   via each of the "file", "http", and "ftp" schemes if the documents
   refer to each other with relative references.  Furthermore, such
   document trees can be moved, as a whole, without changing any of the
   relative references.

   A relative reference ([Section 4.2](#section-4.2)) refers to a resource by describing
   the difference within a hierarchical name space between the reference
   context and the target URI.  The reference resolution algorithm,

Berners-Lee, et al.         Standards Track                    [Page 10]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   presented in [Section 5](#section-5), defines how such a reference is transformed
   to the target URI.  As relative references can only be used within
   the context of a hierarchical URI, designers of new URI schemes
   should use a syntax consistent with the generic syntax's hierarchical
   components unless there are compelling reasons to forbid relative
   referencing within that scheme.

      NOTE: Previous specifications used the terms "partial URI" and
      "relative URI" to denote a relative reference to a URI.  As some
      readers misunderstood those terms to mean that relative URIs are a
      subset of URIs rather than a method of referencing URIs, this
      specification simply refers to them as relative references.

   All URI references are parsed by generic syntax parsers when used.
   However, because hierarchical processing has no effect on an absolute
   URI used in a reference unless it contains one or more dot-segments
   (complete path segments of "." or "..", as described in [Section 3.3](#section-3.3)),
   URI scheme specifications can define opaque identifiers by
   disallowing use of slash characters, question mark characters, and
   the URIs "scheme:." and "scheme:..".

[1.3](#section-1.3).  Syntax Notation

   This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [[RFC2234](/doc/html/rfc2234)], including the following core ABNF syntax rules
   defined by that specification: ALPHA (letters), CR (carriage return),
   DIGIT (decimal digits), DQUOTE (double quote), HEXDIG (hexadecimal
   digits), LF (line feed), and SP (space).  The complete URI syntax is
   collected in [Appendix A](#appendix-A).

[2](#section-2).  Characters

   The URI syntax provides a method of encoding data, presumably for the
   sake of identifying a resource, as a sequence of characters.  The URI
   characters are, in turn, frequently encoded as octets for transport
   or presentation.  This specification does not mandate any particular
   character encoding for mapping between URI characters and the octets
   used to store or transmit those characters.  When a URI appears in a
   protocol element, the character encoding is defined by that protocol;
   without such a definition, a URI is assumed to be in the same
   character encoding as the surrounding text.

   The ABNF notation defines its terminal values to be non-negative
   integers (codepoints) based on the US-ASCII coded character set
   [[ASCII](#ref-ASCII)].  Because a URI is a sequence of characters, we must invert
   that relation in order to understand the URI syntax.  Therefore, the

Berners-Lee, et al.         Standards Track                    [Page 11]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   integer values used by the ABNF must be mapped back to their
   corresponding characters via US-ASCII in order to complete the syntax
   rules.

   A URI is composed from a limited set of characters consisting of
   digits, letters, and a few graphic symbols.  A reserved subset of
   those characters may be used to delimit syntax components within a
   URI while the remaining characters, including both the unreserved set
   and those reserved characters not acting as delimiters, define each
   component's identifying data.

[2.1](#section-2.1).  Percent-Encoding

   A percent-encoding mechanism is used to represent a data octet in a
   component when that octet's corresponding character is outside the
   allowed set or is being used as a delimiter of, or within, the
   component.  A percent-encoded octet is encoded as a character
   triplet, consisting of the percent character "%" followed by the two
   hexadecimal digits representing that octet's numeric value.  For
   example, "%20" is the percent-encoding for the binary octet
   "00100000" (ABNF: %x20), which in US-ASCII corresponds to the space
   character (SP).  [Section 2.4](#section-2.4) describes when percent-encoding and
   decoding is applied.

      pct-encoded = "%" HEXDIG HEXDIG

   The uppercase hexadecimal digits 'A' through 'F' are equivalent to
   the lowercase digits 'a' through 'f', respectively.  If two URIs
   differ only in the case of hexadecimal digits used in percent-encoded
   octets, they are equivalent.  For consistency, URI producers and
   normalizers should use uppercase hexadecimal digits for all percent-
   encodings.

[2.2](#section-2.2).  Reserved Characters

   URIs include components and subcomponents that are delimited by
   characters in the "reserved" set.  These characters are called
   "reserved" because they may (or may not) be defined as delimiters by
   the generic syntax, by each scheme-specific syntax, or by the
   implementation-specific syntax of a URI's dereferencing algorithm.
   If data for a URI component would conflict with a reserved
   character's purpose as a delimiter, then the conflicting data must be
   percent-encoded before the URI is formed.

Berners-Lee, et al.         Standards Track                    [Page 12]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

      reserved    = gen-delims / sub-delims

      gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"

      sub-delims  = "!" / "$" / "&" / "'" / "(" / ")"
                  / "*" / "+" / "," / ";" / "="

   The purpose of reserved characters is to provide a set of delimiting
   characters that are distinguishable from other data within a URI.
   URIs that differ in the replacement of a reserved character with its
   corresponding percent-encoded octet are not equivalent.  Percent-
   encoding a reserved character, or decoding a percent-encoded octet
   that corresponds to a reserved character, will change how the URI is
   interpreted by most applications.  Thus, characters in the reserved
   set are protected from normalization and are therefore safe to be
   used by scheme-specific and producer-specific algorithms for
   delimiting data subcomponents within a URI.

   A subset of the reserved characters (gen-delims) is used as
   delimiters of the generic URI components described in [Section 3](#section-3).  A
   component's ABNF syntax rule will not use the reserved or gen-delims
   rule names directly; instead, each syntax rule lists the characters
   allowed within that component (i.e., not delimiting it), and any of
   those characters that are also in the reserved set are "reserved" for
   use as subcomponent delimiters within the component.  Only the most
   common subcomponents are defined by this specification; other
   subcomponents may be defined by a URI scheme's specification, or by
   the implementation-specific syntax of a URI's dereferencing
   algorithm, provided that such subcomponents are delimited by
   characters in the reserved set allowed within that component.

   URI producing applications should percent-encode data octets that
   correspond to characters in the reserved set unless these characters
   are specifically allowed by the URI scheme to represent data in that
   component.  If a reserved character is found in a URI component and
   no delimiting role is known for that character, then it must be
   interpreted as representing the data octet corresponding to that
   character's encoding in US-ASCII.

[2.3](#section-2.3).  Unreserved Characters

   Characters that are allowed in a URI but do not have a reserved
   purpose are called unreserved.  These include uppercase and lowercase
   letters, decimal digits, hyphen, period, underscore, and tilde.

      unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~"

Berners-Lee, et al.         Standards Track                    [Page 13]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   URIs that differ in the replacement of an unreserved character with
   its corresponding percent-encoded US-ASCII octet are equivalent: they
   identify the same resource.  However, URI comparison implementations
   do not always perform normalization prior to comparison (see [Section](#section-6)
   [6](#section-6)).  For consistency, percent-encoded octets in the ranges of ALPHA
   (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E),
   underscore (%5F), or tilde (%7E) should not be created by URI
   producers and, when found in a URI, should be decoded to their
   corresponding unreserved characters by URI normalizers.

[2.4](#section-2.4).  When to Encode or Decode

   Under normal circumstances, the only time when octets within a URI
   are percent-encoded is during the process of producing the URI from
   its component parts.  This is when an implementation determines which
   of the reserved characters are to be used as subcomponent delimiters
   and which can be safely used as data.  Once produced, a URI is always
   in its percent-encoded form.

   When a URI is dereferenced, the components and subcomponents
   significant to the scheme-specific dereferencing process (if any)
   must be parsed and separated before the percent-encoded octets within
   those components can be safely decoded, as otherwise the data may be
   mistaken for component delimiters.  The only exception is for
   percent-encoded octets corresponding to characters in the unreserved
   set, which can be decoded at any time.  For example, the octet
   corresponding to the tilde ("~") character is often encoded as "%7E"
   by older URI processing implementations; the "%7E" can be replaced by
   "~" without changing its interpretation.

   Because the percent ("%") character serves as the indicator for
   percent-encoded octets, it must be percent-encoded as "%25" for that
   octet to be used as data within a URI.  Implementations must not
   percent-encode or decode the same string more than once, as decoding
   an already decoded string might lead to misinterpreting a percent
   data octet as the beginning of a percent-encoding, or vice versa in
   the case of percent-encoding an already percent-encoded string.

[2.5](#section-2.5).  Identifying Data

   URI characters provide identifying data for each of the URI
   components, serving as an external interface for identification
   between systems.  Although the presence and nature of the URI
   production interface is hidden from clients that use its URIs (and is
   thus beyond the scope of the interoperability requirements defined by
   this specification), it is a frequent source of confusion and errors
   in the interpretation of URI character issues.  Implementers have to
   be aware that there are multiple character encodings involved in the

Berners-Lee, et al.         Standards Track                    [Page 14]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   production and transmission of URIs: local name and data encoding,
   public interface encoding, URI character encoding, data format
   encoding, and protocol encoding.

   Local names, such as file system names, are stored with a local
   character encoding.  URI producing applications (e.g., origin
   servers) will typically use the local encoding as the basis for
   producing meaningful names.  The URI producer will transform the
   local encoding to one that is suitable for a public interface and
   then transform the public interface encoding into the restricted set
   of URI characters (reserved, unreserved, and percent-encodings).
   Those characters are, in turn, encoded as octets to be used as a
   reference within a data format (e.g., a document charset), and such
   data formats are often subsequently encoded for transmission over
   Internet protocols.

   For most systems, an unreserved character appearing within a URI
   component is interpreted as representing the data octet corresponding
   to that character's encoding in US-ASCII.  Consumers of URIs assume
   that the letter "X" corresponds to the octet "01011000", and even
   when that assumption is incorrect, there is no harm in making it.  A
   system that internally provides identifiers in the form of a
   different character encoding, such as EBCDIC, will generally perform
   character translation of textual identifiers to UTF-8 [[STD63](#ref-STD63)] (or
   some other superset of the US-ASCII character encoding) at an
   internal interface, thereby providing more meaningful identifiers
   than those resulting from simply percent-encoding the original
   octets.

   For example, consider an information service that provides data,
   stored locally using an EBCDIC-based file system, to clients on the
   Internet through an HTTP server.  When an author creates a file with
   the name "Laguna Beach" on that file system, the "http" URI
   corresponding to that resource is expected to contain the meaningful
   string "Laguna%20Beach".  If, however, that server produces URIs by
   using an overly simplistic raw octet mapping, then the result would
   be a URI containing "%D3%81%87%A4%95%81@%C2%85%81%83%88".  An
   internal transcoding interface fixes this problem by transcoding the
   local name to a superset of US-ASCII prior to producing the URI.
   Naturally, proper interpretation of an incoming URI on such an
   interface requires that percent-encoded octets be decoded (e.g.,
   "%20" to SP) before the reverse transcoding is applied to obtain the
   local name.

   In some cases, the internal interface between a URI component and the
   identifying data that it has been crafted to represent is much less
   direct than a character encoding translation.  For example, portions
   of a URI might reflect a query on non-ASCII data, or numeric

Berners-Lee, et al.         Standards Track                    [Page 15]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   coordinates on a map.  Likewise, a URI scheme may define components
   with additional encoding requirements that are applied prior to
   forming the component and producing the URI.

   When a new URI scheme defines a component that represents textual
   data consisting of characters from the Universal Character Set [[UCS](#ref-UCS)],
   the data should first be encoded as octets according to the UTF-8
   character encoding [[STD63](#ref-STD63)]; then only those octets that do not
   correspond to characters in the unreserved set should be percent-
   encoded.  For example, the character A would be represented as "A",
   the character LATIN CAPITAL LETTER A WITH GRAVE would be represented
   as "%C3%80", and the character KATAKANA LETTER A would be represented
   as "%E3%82%A2".

[3](#section-3).  Syntax Components

   The generic URI syntax consists of a hierarchical sequence of
   components referred to as the scheme, authority, path, query, and
   fragment.

      URI         = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

      hier-part   = "//" authority path-abempty
                  / path-absolute
                  / path-rootless
                  / path-empty

   The scheme and path components are required, though the path may be
   empty (no characters).  When authority is present, the path must
   either be empty or begin with a slash ("/") character.  When
   authority is not present, the path cannot begin with two slash
   characters ("//").  These restrictions result in five different ABNF
   rules for a path ([Section 3.3](#section-3.3)), only one of which will match any
   given URI reference.

   The following are two example URIs and their component parts:

         foo://example.com:8042/over/there?name=ferret#nose
         \_/   \______________/\_________/ \_________/ \__/
          |           |            |            |        |
       scheme     authority       path        query   fragment
          |   _____________________|__
         / \ /                        \
         urn:example:animal:ferret:nose

Berners-Lee, et al.         Standards Track                    [Page 16]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

[3.1](#section-3.1).  Scheme

   Each URI begins with a scheme name that refers to a specification for
   assigning identifiers within that scheme.  As such, the URI syntax is
   a federated and extensible naming system wherein each scheme's
   specification may further restrict the syntax and semantics of
   identifiers using that scheme.

   Scheme names consist of a sequence of characters beginning with a
   letter and followed by any combination of letters, digits, plus
   ("+"), period ("."), or hyphen ("-").  Although schemes are case-
   insensitive, the canonical form is lowercase and documents that
   specify schemes must do so with lowercase letters.  An implementation
   should accept uppercase letters as equivalent to lowercase in scheme
   names (e.g., allow "HTTP" as well as "http") for the sake of
   robustness but should only produce lowercase scheme names for
   consistency.

      scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )

   Individual schemes are not specified by this document.  The process
   for registration of new URI schemes is defined separately by [[BCP35](#ref-BCP35)].
   The scheme registry maintains the mapping between scheme names and
   their specifications.  Advice for designers of new URI schemes can be
   found in [[RFC2718](/doc/html/rfc2718)].  URI scheme specifications must define their own
   syntax so that all strings matching their scheme-specific syntax will
   also match the <absolute-URI> grammar, as described in [Section 4.3](#section-4.3).

   When presented with a URI that violates one or more scheme-specific
   restrictions, the scheme-specific resolution process should flag the
   reference as an error rather than ignore the unused parts; doing so
   reduces the number of equivalent URIs and helps detect abuses of the
   generic syntax, which might indicate that the URI has been
   constructed to mislead the user ([Section 7.6](#section-7.6)).

[3.2](#section-3.2).  Authority

   Many URI schemes include a hierarchical element for a naming
   authority so that governance of the name space defined by the
   remainder of the URI is delegated to that authority (which may, in
   turn, delegate it further).  The generic syntax provides a common
   means for distinguishing an authority based on a registered name or
   server address, along with optional port and user information.

   The authority component is preceded by a double slash ("//") and is
   terminated by the next slash ("/"), question mark ("?"), or number
   sign ("#") character, or by the end of the URI.

Berners-Lee, et al.         Standards Track                    [Page 17]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

      authority   = [ userinfo "@" ] host [ ":" port ]

   URI producers and normalizers should omit the ":" delimiter that
   separates host from port if the port component is empty.  Some
   schemes do not allow the userinfo and/or port subcomponents.

   If a URI contains an authority component, then the path component
   must either be empty or begin with a slash ("/") character.  Non-
   validating parsers (those that merely separate a URI reference into
   its major components) will often ignore the subcomponent structure of
   authority, treating it as an opaque string from the double-slash to
   the first terminating delimiter, until such time as the URI is
   dereferenced.

[3.2.1](#section-3.2.1).  User Information

   The userinfo subcomponent may consist of a user name and, optionally,
   scheme-specific information about how to gain authorization to access
   the resource.  The user information, if present, is followed by a
   commercial at-sign ("@") that delimits it from the host.

      userinfo    = *( unreserved / pct-encoded / sub-delims / ":" )

   Use of the format "user:password" in the userinfo field is
   deprecated.  Applications should not render as clear text any data
   after the first colon (":") character found within a userinfo
   subcomponent unless the data after the colon is the empty string
   (indicating no password).  Applications may choose to ignore or
   reject such data when it is received as part of a reference and
   should reject the storage of such data in unencrypted form.  The
   passing of authentication information in clear text has proven to be
   a security risk in almost every case where it has been used.

   Applications that render a URI for the sake of user feedback, such as
   in graphical hypertext browsing, should render userinfo in a way that
   is distinguished from the rest of a URI, when feasible.  Such
   rendering will assist the user in cases where the userinfo has been
   misleadingly crafted to look like a trusted domain name
   ([Section 7.6](#section-7.6)).

[3.2.2](#section-3.2.2).  Host

   The host subcomponent of authority is identified by an IP literal
   encapsulated within square brackets, an IPv4 address in dotted-
   decimal form, or a registered name.  The host subcomponent is case-
   insensitive.  The presence of a host subcomponent within a URI does
   not imply that the scheme requires access to the given host on the
   Internet.  In many cases, the host syntax is used only for the sake

Berners-Lee, et al.         Standards Track                    [Page 18]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   of reusing the existing registration process created and deployed for
   DNS, thus obtaining a globally unique name without the cost of
   deploying another registry.  However, such use comes with its own
   costs: domain name ownership may change over time for reasons not
   anticipated by the URI producer.  In other cases, the data within the
   host component identifies a registered name that has nothing to do
   with an Internet host.  We use the name "host" for the ABNF rule
   because that is its most common purpose, not its only purpose.

      host        = IP-literal / IPv4address / reg-name

   The syntax rule for host is ambiguous because it does not completely
   distinguish between an IPv4address and a reg-name.  In order to
   disambiguate the syntax, we apply the "first-match-wins" algorithm:
   If host matches the rule for IPv4address, then it should be
   considered an IPv4 address literal and not a reg-name.  Although host
   is case-insensitive, producers and normalizers should use lowercase
   for registered names and hexadecimal addresses for the sake of
   uniformity, while only using uppercase letters for percent-encodings.

   A host identified by an Internet Protocol literal address, version 6
   [[RFC3513](/doc/html/rfc3513)] or later, is distinguished by enclosing the IP literal
   within square brackets ("[" and "]").  This is the only place where
   square bracket characters are allowed in the URI syntax.  In
   anticipation of future, as-yet-undefined IP literal address formats,
   an implementation may use an optional version flag to indicate such a
   format explicitly rather than rely on heuristic determination.

      IP-literal = "[" ( IPv6address / IPvFuture  ) "]"

      IPvFuture  = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )

   The version flag does not indicate the IP version; rather, it
   indicates future versions of the literal format.  As such,
   implementations must not provide the version flag for the existing
   IPv4 and IPv6 literal address forms described below.  If a URI
   containing an IP-literal that starts with "v" (case-insensitive),
   indicating that the version flag is present, is dereferenced by an
   application that does not know the meaning of that version flag, then
   the application should return an appropriate error for "address
   mechanism not supported".

   A host identified by an IPv6 literal address is represented inside
   the square brackets without a preceding version flag.  The ABNF
   provided here is a translation of the text definition of an IPv6
   literal address provided in [[RFC3513](/doc/html/rfc3513)].  This syntax does not support
   IPv6 scoped addressing zone identifiers.

Berners-Lee, et al.         Standards Track                    [Page 19]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   A 128-bit IPv6 address is divided into eight 16-bit pieces.  Each
   piece is represented numerically in case-insensitive hexadecimal,
   using one to four hexadecimal digits (leading zeroes are permitted).
   The eight encoded pieces are given most-significant first, separated
   by colon characters.  Optionally, the least-significant two pieces
   may instead be represented in IPv4 address textual format.  A
   sequence of one or more consecutive zero-valued 16-bit pieces within
   the address may be elided, omitting all their digits and leaving
   exactly two consecutive colons in their place to mark the elision.

      IPv6address =                            6( h16 ":" ) ls32
                  /                       "::" 5( h16 ":" ) ls32
                  / [               h16 ] "::" 4( h16 ":" ) ls32
                  / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
                  / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
                  / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
                  / [ *4( h16 ":" ) h16 ] "::"              ls32
                  / [ *5( h16 ":" ) h16 ] "::"              h16
                  / [ *6( h16 ":" ) h16 ] "::"

      ls32        = ( h16 ":" h16 ) / IPv4address
                  ; least-significant 32 bits of address

      h16         = 1*4HEXDIG
                  ; 16 bits of address represented in hexadecimal

   A host identified by an IPv4 literal address is represented in
   dotted-decimal notation (a sequence of four decimal numbers in the
   range 0 to 255, separated by "."), as described in [[RFC1123](/doc/html/rfc1123)] by
   reference to [[RFC0952](/doc/html/rfc0952)].  Note that other forms of dotted notation may
   be interpreted on some platforms, as described in [Section 7.4](#section-7.4), but
   only the dotted-decimal form of four octets is allowed by this
   grammar.

      IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet

      dec-octet   = DIGIT                 ; 0-9
                  / %x31-39 DIGIT         ; 10-99
                  / "1" 2DIGIT            ; 100-199
                  / "2" %x30-34 DIGIT     ; 200-249
                  / "25" %x30-35          ; 250-255

   A host identified by a registered name is a sequence of characters
   usually intended for lookup within a locally defined host or service
   name registry, though the URI's scheme-specific semantics may require
   that a specific registry (or fixed name table) be used instead.  The
   most common name registry mechanism is the Domain Name System (DNS).
   A registered name intended for lookup in the DNS uses the syntax

Berners-Lee, et al.         Standards Track                    [Page 20]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   defined in [Section 3.5 of [RFC1034]](/doc/html/rfc1034#section-3.5) and [Section 2.1 of [RFC1123]](/doc/html/rfc1123#section-2.1).
   Such a name consists of a sequence of domain labels separated by ".",
   each domain label starting and ending with an alphanumeric character
   and possibly also containing "-" characters.  The rightmost domain
   label of a fully qualified domain name in DNS may be followed by a
   single "." and should be if it is necessary to distinguish between
   the complete domain name and some local domain.

      reg-name    = *( unreserved / pct-encoded / sub-delims )

   If the URI scheme defines a default for host, then that default
   applies when the host subcomponent is undefined or when the
   registered name is empty (zero length).  For example, the "file" URI
   scheme is defined so that no authority, an empty host, and
   "localhost" all mean the end-user's machine, whereas the "http"
   scheme considers a missing authority or empty host invalid.

   This specification does not mandate a particular registered name
   lookup technology and therefore does not restrict the syntax of reg-
   name beyond what is necessary for interoperability.  Instead, it
   delegates the issue of registered name syntax conformance to the
   operating system of each application performing URI resolution, and
   that operating system decides what it will allow for the purpose of
   host identification.  A URI resolution implementation might use DNS,
   host tables, yellow pages, NetInfo, WINS, or any other system for
   lookup of registered names.  However, a globally scoped naming
   system, such as DNS fully qualified domain names, is necessary for
   URIs intended to have global scope.  URI producers should use names
   that conform to the DNS syntax, even when use of DNS is not
   immediately apparent, and should limit these names to no more than
   255 characters in length.

   The reg-name syntax allows percent-encoded octets in order to
   represent non-ASCII registered names in a uniform way that is
   independent of the underlying name resolution technology.  Non-ASCII
   characters must first be encoded according to UTF-8 [[STD63](#ref-STD63)], and then
   each octet of the corresponding UTF-8 sequence must be percent-
   encoded to be represented as URI characters.  URI producing
   applications must not use percent-encoding in host unless it is used
   to represent a UTF-8 character sequence.  When a non-ASCII registered
   name represents an internationalized domain name intended for
   resolution via the DNS, the name must be transformed to the IDNA
   encoding [[RFC3490](/doc/html/rfc3490)] prior to name lookup.  URI producers should
   provide these registered names in the IDNA encoding, rather than a
   percent-encoding, if they wish to maximize interoperability with
   legacy URI resolvers.

Berners-Lee, et al.         Standards Track                    [Page 21]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

[3.2.3](#section-3.2.3).  Port

   The port subcomponent of authority is designated by an optional port
   number in decimal following the host and delimited from it by a
   single colon (":") character.

      port        = *DIGIT

   A scheme may define a default port.  For example, the "http" scheme
   defines a default port of "80", corresponding to its reserved TCP
   port number.  The type of port designated by the port number (e.g.,
   TCP, UDP, SCTP) is defined by the URI scheme.  URI producers and
   normalizers should omit the port component and its ":" delimiter if
   port is empty or if its value would be the same as that of the
   scheme's default.

[3.3](#section-3.3).  Path

   The path component contains data, usually organized in hierarchical
   form, that, along with data in the non-hierarchical query component
   ([Section 3.4](#section-3.4)), serves to identify a resource within the scope of the
   URI's scheme and naming authority (if any).  The path is terminated
   by the first question mark ("?") or number sign ("#") character, or
   by the end of the URI.

   If a URI contains an authority component, then the path component
   must either be empty or begin with a slash ("/") character.  If a URI
   does not contain an authority component, then the path cannot begin
   with two slash characters ("//").  In addition, a URI reference
   ([Section 4.1](#section-4.1)) may be a relative-path reference, in which case the
   first path segment cannot contain a colon (":") character.  The ABNF
   requires five separate rules to disambiguate these cases, only one of
   which will match the path substring within a given URI reference.  We
   use the generic term "path component" to describe the URI substring
   matched by the parser to one of these rules.

      path          = path-abempty    ; begins with "/" or is empty
                    / path-absolute   ; begins with "/" but not "//"
                    / path-noscheme   ; begins with a non-colon segment
                    / path-rootless   ; begins with a segment
                    / path-empty      ; zero characters

      path-abempty  = *( "/" segment )
      path-absolute = "/" [ segment-nz *( "/" segment ) ]
      path-noscheme = segment-nz-nc *( "/" segment )
      path-rootless = segment-nz *( "/" segment )
      path-empty    = 0<pchar>

Berners-Lee, et al.         Standards Track                    [Page 22]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

      segment       = *pchar
      segment-nz    = 1*pchar
      segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
                    ; non-zero-length segment without any colon ":"

      pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"

   A path consists of a sequence of path segments separated by a slash
   ("/") character.  A path is always defined for a URI, though the
   defined path may be empty (zero length).  Use of the slash character
   to indicate hierarchy is only required when a URI will be used as the
   context for relative references.  For example, the URI
   <mailto:fred@example.com> has a path of "fred@example.com", whereas
   the URI <foo://info.example.com?fred> has an empty path.

   The path segments "." and "..", also known as dot-segments, are
   defined for relative reference within the path name hierarchy.  They
   are intended for use at the beginning of a relative-path reference
   ([Section 4.2](#section-4.2)) to indicate relative position within the hierarchical
   tree of names.  This is similar to their role within some operating
   systems' file directory structures to indicate the current directory
   and parent directory, respectively.  However, unlike in a file
   system, these dot-segments are only interpreted within the URI path
   hierarchy and are removed as part of the resolution process ([Section](#section-5.2)
   [5.2](#section-5.2)).

   Aside from dot-segments in hierarchical paths, a path segment is
   considered opaque by the generic syntax.  URI producing applications
   often use the reserved characters allowed in a segment to delimit
   scheme-specific or dereference-handler-specific subcomponents.  For
   example, the semicolon (";") and equals ("=") reserved characters are
   often used to delimit parameters and parameter values applicable to
   that segment.  The comma (",") reserved character is often used for
   similar purposes.  For example, one URI producer might use a segment
   such as "name;v=1.1" to indicate a reference to version 1.1 of
   "name", whereas another might use a segment such as "name,1.1" to
   indicate the same.  Parameter types may be defined by scheme-specific
   semantics, but in most cases the syntax of a parameter is specific to
   the implementation of the URI's dereferencing algorithm.

[3.4](#section-3.4).  Query

   The query component contains non-hierarchical data that, along with
   data in the path component ([Section 3.3](#section-3.3)), serves to identify a
   resource within the scope of the URI's scheme and naming authority
   (if any).  The query component is indicated by the first question
   mark ("?") character and terminated by a number sign ("#") character
   or by the end of the URI.

Berners-Lee, et al.         Standards Track                    [Page 23]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

      query       = *( pchar / "/" / "?" )

   The characters slash ("/") and question mark ("?") may represent data
   within the query component.  Beware that some older, erroneous
   implementations may not handle such data correctly when it is used as
   the base URI for relative references ([Section 5.1](#section-5.1)), apparently
   because they fail to distinguish query data from path data when
   looking for hierarchical separators.  However, as query components
   are often used to carry identifying information in the form of
   "key=value" pairs and one frequently used value is a reference to
   another URI, it is sometimes better for usability to avoid percent-
   encoding those characters.

[3.5](#section-3.5).  Fragment

   The fragment identifier component of a URI allows indirect
   identification of a secondary resource by reference to a primary
   resource and additional identifying information.  The identified
   secondary resource may be some portion or subset of the primary
   resource, some view on representations of the primary resource, or
   some other resource defined or described by those representations.  A
   fragment identifier component is indicated by the presence of a
   number sign ("#") character and terminated by the end of the URI.

      fragment    = *( pchar / "/" / "?" )

   The semantics of a fragment identifier are defined by the set of
   representations that might result from a retrieval action on the
   primary resource.  The fragment's format and resolution is therefore
   dependent on the media type [[RFC2046](/doc/html/rfc2046)] of a potentially retrieved
   representation, even though such a retrieval is only performed if the
   URI is dereferenced.  If no such representation exists, then the
   semantics of the fragment are considered unknown and are effectively
   unconstrained.  Fragment identifier semantics are independent of the
   URI scheme and thus cannot be redefined by scheme specifications.

   Individual media types may define their own restrictions on or
   structures within the fragment identifier syntax for specifying
   different types of subsets, views, or external references that are
   identifiable as secondary resources by that media type.  If the
   primary resource has multiple representations, as is often the case
   for resources whose representation is selected based on attributes of
   the retrieval request (a.k.a., content negotiation), then whatever is
   identified by the fragment should be consistent across all of those
   representations.  Each representation should either define the
   fragment so that it corresponds to the same secondary resource,
   regardless of how it is represented, or should leave the fragment
   undefined (i.e., not found).

Berners-Lee, et al.         Standards Track                    [Page 24]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   As with any URI, use of a fragment identifier component does not
   imply that a retrieval action will take place.  A URI with a fragment
   identifier may be used to refer to the secondary resource without any
   implication that the primary resource is accessible or will ever be
   accessed.

   Fragment identifiers have a special role in information retrieval
   systems as the primary form of client-side indirect referencing,
   allowing an author to specifically identify aspects of an existing
   resource that are only indirectly provided by the resource owner.  As
   such, the fragment identifier is not used in the scheme-specific
   processing of a URI; instead, the fragment identifier is separated
   from the rest of the URI prior to a dereference, and thus the
   identifying information within the fragment itself is dereferenced
   solely by the user agent, regardless of the URI scheme.  Although
   this separate handling is often perceived to be a loss of
   information, particularly for accurate redirection of references as
   resources move over time, it also serves to prevent information
   providers from denying reference authors the right to refer to
   information within a resource selectively.  Indirect referencing also
   provides additional flexibility and extensibility to systems that use
   URIs, as new media types are easier to define and deploy than new
   schemes of identification.

   The characters slash ("/") and question mark ("?") are allowed to
   represent data within the fragment identifier.  Beware that some
   older, erroneous implementations may not handle this data correctly
   when it is used as the base URI for relative references ([Section](#section-5.1)
   [5.1](#section-5.1)).

[4](#section-4).  Usage

   When applications make reference to a URI, they do not always use the
   full form of reference defined by the "URI" syntax rule.  To save
   space and take advantage of hierarchical locality, many Internet
   protocol elements and media type formats allow an abbreviation of a
   URI, whereas others restrict the syntax to a particular form of URI.
   We define the most common forms of reference syntax in this
   specification because they impact and depend upon the design of the
   generic syntax, requiring a uniform parsing algorithm in order to be
   interpreted consistently.

[4.1](#section-4.1).  URI Reference

   URI-reference is used to denote the most common usage of a resource
   identifier.

      URI-reference = URI / relative-ref

Berners-Lee, et al.         Standards Track                    [Page 25]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   A URI-reference is either a URI or a relative reference.  If the
   URI-reference's prefix does not match the syntax of a scheme followed
   by its colon separator, then the URI-reference is a relative
   reference.

   A URI-reference is typically parsed first into the five URI
   components, in order to determine what components are present and
   whether the reference is relative.  Then, each component is parsed
   for its subparts and their validation.  The ABNF of URI-reference,
   along with the "first-match-wins" disambiguation rule, is sufficient
   to define a validating parser for the generic syntax.  Readers
   familiar with regular expressions should see [Appendix B](#appendix-B) for an
   example of a non-validating URI-reference parser that will take any
   given string and extract the URI components.

[4.2](#section-4.2).  Relative Reference

   A relative reference takes advantage of the hierarchical syntax
   ([Section 1.2.3](#section-1.2.3)) to express a URI reference relative to the name space
   of another hierarchical URI.

      relative-ref  = relative-part [ "?" query ] [ "#" fragment ]

      relative-part = "//" authority path-abempty
                    / path-absolute
                    / path-noscheme
                    / path-empty

   The URI referred to by a relative reference, also known as the target
   URI, is obtained by applying the reference resolution algorithm of
   [Section 5](#section-5).

   A relative reference that begins with two slash characters is termed
   a network-path reference; such references are rarely used.  A
   relative reference that begins with a single slash character is
   termed an absolute-path reference.  A relative reference that does
   not begin with a slash character is termed a relative-path reference.

   A path segment that contains a colon character (e.g., "this:that")
   cannot be used as the first segment of a relative-path reference, as
   it would be mistaken for a scheme name.  Such a segment must be
   preceded by a dot-segment (e.g., "./this:that") to make a relative-
   path reference.

Berners-Lee, et al.         Standards Track                    [Page 26]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

[4.3](#section-4.3).  Absolute URI

   Some protocol elements allow only the absolute form of a URI without
   a fragment identifier.  For example, defining a base URI for later
   use by relative references calls for an absolute-URI syntax rule that
   does not allow a fragment.

      absolute-URI  = scheme ":" hier-part [ "?" query ]

   URI scheme specifications must define their own syntax so that all
   strings matching their scheme-specific syntax will also match the
   <absolute-URI> grammar.  Scheme specifications will not define
   fragment identifier syntax or usage, regardless of its applicability
   to resources identifiable via that scheme, as fragment identification
   is orthogonal to scheme definition.  However, scheme specifications
   are encouraged to include a wide range of examples, including
   examples that show use of the scheme's URIs with fragment identifiers
   when such usage is appropriate.

[4.4](#section-4.4).  Same-Document Reference

   When a URI reference refers to a URI that is, aside from its fragment
   component (if any), identical to the base URI ([Section 5.1](#section-5.1)), that
   reference is called a "same-document" reference.  The most frequent
   examples of same-document references are relative references that are
   empty or include only the number sign ("#") separator followed by a
   fragment identifier.

   When a same-document reference is dereferenced for a retrieval
   action, the target of that reference is defined to be within the same
   entity (representation, document, or message) as the reference;
   therefore, a dereference should not result in a new retrieval action.

   Normalization of the base and target URIs prior to their comparison,
   as described in Sections [6.2.2](#section-6.2.2) and [6.2.3](#section-6.2.3), is allowed but rarely
   performed in practice.  Normalization may increase the set of same-
   document references, which may be of benefit to some caching
   applications.  As such, reference authors should not assume that a
   slightly different, though equivalent, reference URI will (or will
   not) be interpreted as a same-document reference by any given
   application.

[4.5](#section-4.5).  Suffix Reference

   The URI syntax is designed for unambiguous reference to resources and
   extensibility via the URI scheme.  However, as URI identification and
   usage have become commonplace, traditional media (television, radio,
   newspapers, billboards, etc.) have increasingly used a suffix of the

Berners-Lee, et al.         Standards Track                    [Page 27]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   URI as a reference, consisting of only the authority and path
   portions of the URI, such as

      www.w3.org/Addressing/

   or simply a DNS registered name on its own.  Such references are
   primarily intended for human interpretation rather than for machines,
   with the assumption that context-based heuristics are sufficient to
   complete the URI (e.g., most registered names beginning with "www"
   are likely to have a URI prefix of "http://").  Although there is no
   standard set of heuristics for disambiguating a URI suffix, many
   client implementations allow them to be entered by the user and
   heuristically resolved.

   Although this practice of using suffix references is common, it
   should be avoided whenever possible and should never be used in
   situations where long-term references are expected.  The heuristics
   noted above will change over time, particularly when a new URI scheme
   becomes popular, and are often incorrect when used out of context.
   Furthermore, they can lead to security issues along the lines of
   those described in [[RFC1535](/doc/html/rfc1535)].

   As a URI suffix has the same syntax as a relative-path reference, a
   suffix reference cannot be used in contexts where a relative
   reference is expected.  As a result, suffix references are limited to
   places where there is no defined base URI, such as dialog boxes and
   off-line advertisements.

[5](#section-5).  Reference Resolution

   This section defines the process of resolving a URI reference within
   a context that allows relative references so that the result is a
   string matching the <URI> syntax rule of [Section 3](#section-3).

[5.1](#section-5.1).  Establishing a Base URI

   The term "relative" implies that a "base URI" exists against which
   the relative reference is applied.  Aside from fragment-only
   references ([Section 4.4](#section-4.4)), relative references are only usable when a
   base URI is known.  A base URI must be established by the parser
   prior to parsing URI references that might be relative.  A base URI
   must conform to the <absolute-URI> syntax rule ([Section 4.3](#section-4.3)).  If the
   base URI is obtained from a URI reference, then that reference must
   be converted to absolute form and stripped of any fragment component
   prior to its use as a base URI.

Berners-Lee, et al.         Standards Track                    [Page 28]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   The base URI of a reference can be established in one of four ways,
   discussed below in order of precedence.  The order of precedence can
   be thought of in terms of layers, where the innermost defined base
   URI has the highest precedence.  This can be visualized graphically
   as follows:

         .----------------------------------------------------------.
         |  .----------------------------------------------------.  |
         |  |  .----------------------------------------------.  |  |
         |  |  |  .----------------------------------------.  |  |  |
         |  |  |  |  .----------------------------------.  |  |  |  |
         |  |  |  |  |       <relative-reference>       |  |  |  |  |
         |  |  |  |  `----------------------------------'  |  |  |  |
         |  |  |  | (5.1.1) Base URI embedded in content   |  |  |  |
         |  |  |  `----------------------------------------'  |  |  |
         |  |  | (5.1.2) Base URI of the encapsulating entity |  |  |
         |  |  |         (message, representation, or none)   |  |  |
         |  |  `----------------------------------------------'  |  |
         |  | (5.1.3) URI used to retrieve the entity            |  |
         |  `----------------------------------------------------'  |
         | (5.1.4) Default Base URI (application-dependent)         |
         `----------------------------------------------------------'

[5.1.1](#section-5.1.1).  Base URI Embedded in Content

   Within certain media types, a base URI for relative references can be
   embedded within the content itself so that it can be readily obtained
   by a parser.  This can be useful for descriptive documents, such as
   tables of contents, which may be transmitted to others through
   protocols other than their usual retrieval context (e.g., email or
   USENET news).

   It is beyond the scope of this specification to specify how, for each
   media type, a base URI can be embedded.  The appropriate syntax, when
   available, is described by the data format specification associated
   with each media type.

[5.1.2](#section-5.1.2).  Base URI from the Encapsulating Entity

   If no base URI is embedded, the base URI is defined by the
   representation's retrieval context.  For a document that is enclosed
   within another entity, such as a message or archive, the retrieval
   context is that entity.  Thus, the default base URI of a
   representation is the base URI of the entity in which the
   representation is encapsulated.

Berners-Lee, et al.         Standards Track                    [Page 29]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   A mechanism for embedding a base URI within MIME container types
   (e.g., the message and multipart types) is defined by MHTML
   [[RFC2557](/doc/html/rfc2557)].  Protocols that do not use the MIME message header syntax,
   but that do allow some form of tagged metadata to be included within
   messages, may define their own syntax for defining a base URI as part
   of a message.

[5.1.3](#section-5.1.3).  Base URI from the Retrieval URI

   If no base URI is embedded and the representation is not encapsulated
   within some other entity, then, if a URI was used to retrieve the
   representation, that URI shall be considered the base URI.  Note that
   if the retrieval was the result of a redirected request, the last URI
   used (i.e., the URI that resulted in the actual retrieval of the
   representation) is the base URI.

[5.1.4](#section-5.1.4).  Default Base URI

   If none of the conditions described above apply, then the base URI is
   defined by the context of the application.  As this definition is
   necessarily application-dependent, failing to define a base URI by
   using one of the other methods may result in the same content being
   interpreted differently by different types of applications.

   A sender of a representation containing relative references is
   responsible for ensuring that a base URI for those references can be
   established.  Aside from fragment-only references, relative
   references can only be used reliably in situations where the base URI
   is well defined.

[5.2](#section-5.2).  Relative Resolution

   This section describes an algorithm for converting a URI reference
   that might be relative to a given base URI into the parsed components
   of the reference's target.  The components can then be recomposed, as
   described in [Section 5.3](#section-5.3), to form the target URI.  This algorithm
   provides definitive results that can be used to test the output of
   other implementations.  Applications may implement relative reference
   resolution by using some other algorithm, provided that the results
   match what would be given by this one.

Berners-Lee, et al.         Standards Track                    [Page 30]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

[5.2.1](#section-5.2.1).  Pre-parse the Base URI

   The base URI (Base) is established according to the procedure of
   [Section 5.1](#section-5.1) and parsed into the five main components described in
   [Section 3](#section-3).  Note that only the scheme component is required to be
   present in a base URI; the other components may be empty or
   undefined.  A component is undefined if its associated delimiter does
   not appear in the URI reference; the path component is never
   undefined, though it may be empty.

   Normalization of the base URI, as described in Sections [6.2.2](#section-6.2.2) and
   6.2.3, is optional.  A URI reference must be transformed to its
   target URI before it can be normalized.

[5.2.2](#section-5.2.2).  Transform References

   For each URI reference (R), the following pseudocode describes an
   algorithm for transforming R into its target URI (T):

      -- The URI reference is parsed into the five URI components
      --
      (R.scheme, R.authority, R.path, R.query, R.fragment) = parse(R);

      -- A non-strict parser may ignore a scheme in the reference
      -- if it is identical to the base URI's scheme.
      --
      if ((not strict) and (R.scheme == Base.scheme)) then
         undefine(R.scheme);
      endif;

Berners-Lee, et al.         Standards Track                    [Page 31]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

      if defined(R.scheme) then
         T.scheme    = R.scheme;
         T.authority = R.authority;
         T.path      = remove_dot_segments(R.path);
         T.query     = R.query;
      else
         if defined(R.authority) then
            T.authority = R.authority;
            T.path      = remove_dot_segments(R.path);
            T.query     = R.query;
         else
            if (R.path == "") then
               T.path = Base.path;
               if defined(R.query) then
                  T.query = R.query;
               else
                  T.query = Base.query;
               endif;
            else
               if (R.path starts-with "/") then
                  T.path = remove_dot_segments(R.path);
               else
                  T.path = merge(Base.path, R.path);
                  T.path = remove_dot_segments(T.path);
               endif;
               T.query = R.query;
            endif;
            T.authority = Base.authority;
         endif;
         T.scheme = Base.scheme;
      endif;

      T.fragment = R.fragment;

[5.2.3](#section-5.2.3).  Merge Paths

   The pseudocode above refers to a "merge" routine for merging a
   relative-path reference with the path of the base URI.  This is
   accomplished as follows:

   o  If the base URI has a defined authority component and an empty
      path, then return a string consisting of "/" concatenated with the
      reference's path; otherwise,

Berners-Lee, et al.         Standards Track                    [Page 32]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   o  return a string consisting of the reference's path component
      appended to all but the last segment of the base URI's path (i.e.,
      excluding any characters after the right-most "/" in the base URI
      path, or excluding the entire base URI path if it does not contain
      any "/" characters).

[5.2.4](#section-5.2.4).  Remove Dot Segments

   The pseudocode also refers to a "remove_dot_segments" routine for
   interpreting and removing the special "." and ".." complete path
   segments from a referenced path.  This is done after the path is
   extracted from a reference, whether or not the path was relative, in
   order to remove any invalid or extraneous dot-segments prior to
   forming the target URI.  Although there are many ways to accomplish
   this removal process, we describe a simple method using two string
   buffers.

   1.  The input buffer is initialized with the now-appended path
       components and the output buffer is initialized to the empty
       string.

   2.  While the input buffer is not empty, loop as follows:

       A.  If the input buffer begins with a prefix of "../" or "./",
           then remove that prefix from the input buffer; otherwise,

       B.  if the input buffer begins with a prefix of "/./" or "/.",
           where "." is a complete path segment, then replace that
           prefix with "/" in the input buffer; otherwise,

       C.  if the input buffer begins with a prefix of "/../" or "/..",
           where ".." is a complete path segment, then replace that
           prefix with "/" in the input buffer and remove the last
           segment and its preceding "/" (if any) from the output
           buffer; otherwise,

       D.  if the input buffer consists only of "." or "..", then remove
           that from the input buffer; otherwise,

       E.  move the first path segment in the input buffer to the end of
           the output buffer, including the initial "/" character (if
           any) and any subsequent characters up to, but not including,
           the next "/" character or the end of the input buffer.

   3.  Finally, the output buffer is returned as the result of
       remove_dot_segments.

Berners-Lee, et al.         Standards Track                    [Page 33]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   Note that dot-segments are intended for use in URI references to
   express an identifier relative to the hierarchy of names in the base
   URI.  The remove_dot_segments algorithm respects that hierarchy by
   removing extra dot-segments rather than treat them as an error or
   leaving them to be misinterpreted by dereference implementations.

   The following illustrates how the above steps are applied for two
   examples of merged paths, showing the state of the two buffers after
   each step.

      STEP   OUTPUT BUFFER         INPUT BUFFER

       1 :                         /a/b/c/./../../g
       2E:   /a                    /b/c/./../../g
       2E:   /a/b                  /c/./../../g
       2E:   /a/b/c                /./../../g
       2B:   /a/b/c                /../../g
       2C:   /a/b                  /../g
       2C:   /a                    /g
       2E:   /a/g

      STEP   OUTPUT BUFFER         INPUT BUFFER

       [1](#section-1) :                         mid/content=5/../6
       2E:   mid                   /content=5/../6
       2E:   mid/content=5         /../6
       2C:   mid                   /6
       2E:   mid/6

   Some applications may find it more efficient to implement the
   remove_dot_segments algorithm by using two segment stacks rather than
   strings.

      Note: Beware that some older, erroneous implementations will fail
      to separate a reference's query component from its path component
      prior to merging the base and reference paths, resulting in an
      interoperability failure if the query component contains the
      strings "/../" or "/./".

Berners-Lee, et al.         Standards Track                    [Page 34]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

[5.3](#section-5.3).  Component Recomposition

   Parsed URI components can be recomposed to obtain the corresponding
   URI reference string.  Using pseudocode, this would be:

      result = ""

      if defined(scheme) then
         append scheme to result;
         append ":" to result;
      endif;

      if defined(authority) then
         append "//" to result;
         append authority to result;
      endif;

      append path to result;

      if defined(query) then
         append "?" to result;
         append query to result;
      endif;

      if defined(fragment) then
         append "#" to result;
         append fragment to result;
      endif;

      return result;

   Note that we are careful to preserve the distinction between a
   component that is undefined, meaning that its separator was not
   present in the reference, and a component that is empty, meaning that
   the separator was present and was immediately followed by the next
   component separator or the end of the reference.

[5.4](#section-5.4).  Reference Resolution Examples

   Within a representation with a well defined base URI of

      http://a/b/c/d;p?q

   a relative reference is transformed to its target URI as follows.

Berners-Lee, et al.         Standards Track                    [Page 35]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

[5.4.1](#section-5.4.1).  Normal Examples

      "g:h"           =  "g:h"
      "g"             =  "http://a/b/c/g"
      "./g"           =  "http://a/b/c/g"
      "g/"            =  "http://a/b/c/g/"
      "/g"            =  "http://a/g"
      "//g"           =  "http://g"
      "?y"            =  "http://a/b/c/d;p?y"
      "g?y"           =  "http://a/b/c/g?y"
      "#s"            =  "http://a/b/c/d;p?q#s"
      "g#s"           =  "http://a/b/c/g#s"
      "g?y#s"         =  "http://a/b/c/g?y#s"
      ";x"            =  "http://a/b/c/;x"
      "g;x"           =  "http://a/b/c/g;x"
      "g;x?y#s"       =  "http://a/b/c/g;x?y#s"
      ""              =  "http://a/b/c/d;p?q"
      "."             =  "http://a/b/c/"
      "./"            =  "http://a/b/c/"
      ".."            =  "http://a/b/"
      "../"           =  "http://a/b/"
      "../g"          =  "http://a/b/g"
      "../.."         =  "http://a/"
      "../../"        =  "http://a/"
      "../../g"       =  "http://a/g"

[5.4.2](#section-5.4.2).  Abnormal Examples

   Although the following abnormal examples are unlikely to occur in
   normal practice, all URI parsers should be capable of resolving them
   consistently.  Each example uses the same base as that above.

   Parsers must be careful in handling cases where there are more ".."
   segments in a relative-path reference than there are hierarchical
   levels in the base URI's path.  Note that the ".." syntax cannot be
   used to change the authority component of a URI.

      "../../../g"    =  "http://a/g"
      "../../../../g" =  "http://a/g"

Berners-Lee, et al.         Standards Track                    [Page 36]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   Similarly, parsers must remove the dot-segments "." and ".." when
   they are complete components of a path, but not when they are only
   part of a segment.

      "/./g"          =  "http://a/g"
      "/../g"         =  "http://a/g"
      "g."            =  "http://a/b/c/g."
      ".g"            =  "http://a/b/c/.g"
      "g.."           =  "http://a/b/c/g.."
      "..g"           =  "http://a/b/c/..g"

   Less likely are cases where the relative reference uses unnecessary
   or nonsensical forms of the "." and ".." complete path segments.

      "./../g"        =  "http://a/b/g"
      "./g/."         =  "http://a/b/c/g/"
      "g/./h"         =  "http://a/b/c/g/h"
      "g/../h"        =  "http://a/b/c/h"
      "g;x=1/./y"     =  "http://a/b/c/g;x=1/y"
      "g;x=1/../y"    =  "http://a/b/c/y"

   Some applications fail to separate the reference's query and/or
   fragment components from the path component before merging it with
   the base path and removing dot-segments.  This error is rarely
   noticed, as typical usage of a fragment never includes the hierarchy
   ("/") character and the query component is not normally used within
   relative references.

      "g?y/./x"       =  "http://a/b/c/g?y/./x"
      "g?y/../x"      =  "http://a/b/c/g?y/../x"
      "g#s/./x"       =  "http://a/b/c/g#s/./x"
      "g#s/../x"      =  "http://a/b/c/g#s/../x"

   Some parsers allow the scheme name to be present in a relative
   reference if it is the same as the base URI scheme.  This is
   considered to be a loophole in prior specifications of partial URI
   [[RFC1630](/doc/html/rfc1630)].  Its use should be avoided but is allowed for backward
   compatibility.

      "http:g"        =  "http:g"         ; for strict parsers
                      /  "http://a/b/c/g" ; for backward compatibility

Berners-Lee, et al.         Standards Track                    [Page 37]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

[6](#section-6).  Normalization and Comparison

   One of the most common operations on URIs is simple comparison:
   determining whether two URIs are equivalent without using the URIs to
   access their respective resource(s).  A comparison is performed every
   time a response cache is accessed, a browser checks its history to
   color a link, or an XML parser processes tags within a namespace.
   Extensive normalization prior to comparison of URIs is often used by
   spiders and indexing engines to prune a search space or to reduce
   duplication of request actions and response storage.

   URI comparison is performed for some particular purpose.  Protocols
   or implementations that compare URIs for different purposes will
   often be subject to differing design trade-offs in regards to how
   much effort should be spent in reducing aliased identifiers.  This
   section describes various methods that may be used to compare URIs,
   the trade-offs between them, and the types of applications that might
   use them.

[6.1](#section-6.1).  Equivalence

   Because URIs exist to identify resources, presumably they should be
   considered equivalent when they identify the same resource.  However,
   this definition of equivalence is not of much practical use, as there
   is no way for an implementation to compare two resources unless it
   has full knowledge or control of them.  For this reason,
   determination of equivalence or difference of URIs is based on string
   comparison, perhaps augmented by reference to additional rules
   provided by URI scheme definitions.  We use the terms "different" and
   "equivalent" to describe the possible outcomes of such comparisons,
   but there are many application-dependent versions of equivalence.

   Even though it is possible to determine that two URIs are equivalent,
   URI comparison is not sufficient to determine whether two URIs
   identify different resources.  For example, an owner of two different
   domain names could decide to serve the same resource from both,
   resulting in two different URIs.  Therefore, comparison methods are
   designed to minimize false negatives while strictly avoiding false
   positives.

   In testing for equivalence, applications should not directly compare
   relative references; the references should be converted to their
   respective target URIs before comparison.  When URIs are compared to
   select (or avoid) a network action, such as retrieval of a
   representation, fragment components (if any) should be excluded from
   the comparison.

Berners-Lee, et al.         Standards Track                    [Page 38]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

[6.2](#section-6.2).  Comparison Ladder

   A variety of methods are used in practice to test URI equivalence.
   These methods fall into a range, distinguished by the amount of
   processing required and the degree to which the probability of false
   negatives is reduced.  As noted above, false negatives cannot be
   eliminated.  In practice, their probability can be reduced, but this
   reduction requires more processing and is not cost-effective for all
   applications.

   If this range of comparison practices is considered as a ladder, the
   following discussion will climb the ladder, starting with practices
   that are cheap but have a relatively higher chance of producing false
   negatives, and proceeding to those that have higher computational
   cost and lower risk of false negatives.

[6.2.1](#section-6.2.1).  Simple String Comparison

   If two URIs, when considered as character strings, are identical,
   then it is safe to conclude that they are equivalent.  This type of
   equivalence test has very low computational cost and is in wide use
   in a variety of applications, particularly in the domain of parsing.

   Testing strings for equivalence requires some basic precautions.
   This procedure is often referred to as "bit-for-bit" or
   "byte-for-byte" comparison, which is potentially misleading.  Testing
   strings for equality is normally based on pair comparison of the
   characters that make up the strings, starting from the first and
   proceeding until both strings are exhausted and all characters are
   found to be equal, until a pair of characters compares unequal, or
   until one of the strings is exhausted before the other.

   This character comparison requires that each pair of characters be
   put in comparable form.  For example, should one URI be stored in a
   byte array in EBCDIC encoding and the second in a Java String object
   (UTF-16), bit-for-bit comparisons applied naively will produce
   errors.  It is better to speak of equality on a character-for-
   character basis rather than on a byte-for-byte or bit-for-bit basis.
   In practical terms, character-by-character comparisons should be done
   codepoint-by-codepoint after conversion to a common character
   encoding.

   False negatives are caused by the production and use of URI aliases.
   Unnecessary aliases can be reduced, regardless of the comparison
   method, by consistently providing URI references in an already-
   normalized form (i.e., a form identical to what would be produced
   after normalization is applied, as described below).

Berners-Lee, et al.         Standards Track                    [Page 39]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   Protocols and data formats often limit some URI comparisons to simple
   string comparison, based on the theory that people and
   implementations will, in their own best interest, be consistent in
   providing URI references, or at least consistent enough to negate any
   efficiency that might be obtained from further normalization.

[6.2.2](#section-6.2.2).  Syntax-Based Normalization

   Implementations may use logic based on the definitions provided by
   this specification to reduce the probability of false negatives.
   This processing is moderately higher in cost than character-for-
   character string comparison.  For example, an application using this
   approach could reasonably consider the following two URIs equivalent:

      example://a/b/c/%7Bfoo%7D
      eXAMPLE://a/./b/../b/%63/%7bfoo%7d

   Web user agents, such as browsers, typically apply this type of URI
   normalization when determining whether a cached response is
   available.  Syntax-based normalization includes such techniques as
   case normalization, percent-encoding normalization, and removal of
   dot-segments.

[6.2.2.1](#section-6.2.2.1).  Case Normalization

   For all URIs, the hexadecimal digits within a percent-encoding
   triplet (e.g., "%3a" versus "%3A") are case-insensitive and therefore
   should be normalized to use uppercase letters for the digits A-F.

   When a URI uses components of the generic syntax, the component
   syntax equivalence rules always apply; namely, that the scheme and
   host are case-insensitive and therefore should be normalized to
   lowercase.  For example, the URI <HTTP://www.EXAMPLE.com/> is
   equivalent to <http://www.example.com/>.  The other generic syntax
   components are assumed to be case-sensitive unless specifically
   defined otherwise by the scheme (see [Section 6.2.3](#section-6.2.3)).

[6.2.2.2](#section-6.2.2.2).  Percent-Encoding Normalization

   The percent-encoding mechanism ([Section 2.1](#section-2.1)) is a frequent source of
   variance among otherwise identical URIs.  In addition to the case
   normalization issue noted above, some URI producers percent-encode
   octets that do not require percent-encoding, resulting in URIs that
   are equivalent to their non-encoded counterparts.  These URIs should
   be normalized by decoding any percent-encoded octet that corresponds
   to an unreserved character, as described in [Section 2.3](#section-2.3).

Berners-Lee, et al.         Standards Track                    [Page 40]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

[6.2.2.3](#section-6.2.2.3).  Path Segment Normalization

   The complete path segments "." and ".." are intended only for use
   within relative references ([Section 4.1](#section-4.1)) and are removed as part of
   the reference resolution process ([Section 5.2](#section-5.2)).  However, some
   deployed implementations incorrectly assume that reference resolution
   is not necessary when the reference is already a URI and thus fail to
   remove dot-segments when they occur in non-relative paths.  URI
   normalizers should remove dot-segments by applying the
   remove_dot_segments algorithm to the path, as described in
   [Section 5.2.4](#section-5.2.4).

[6.2.3](#section-6.2.3).  Scheme-Based Normalization

   The syntax and semantics of URIs vary from scheme to scheme, as
   described by the defining specification for each scheme.
   Implementations may use scheme-specific rules, at further processing
   cost, to reduce the probability of false negatives.  For example,
   because the "http" scheme makes use of an authority component, has a
   default port of "80", and defines an empty path to be equivalent to
   "/", the following four URIs are equivalent:

      http://example.com
      http://example.com/
      <http://example.com:/>
      <http://example.com:80/>

   In general, a URI that uses the generic syntax for authority with an
   empty path should be normalized to a path of "/".  Likewise, an
   explicit ":port", for which the port is empty or the default for the
   scheme, is equivalent to one where the port and its ":" delimiter are
   elided and thus should be removed by scheme-based normalization.  For
   example, the second URI above is the normal form for the "http"
   scheme.

   Another case where normalization varies by scheme is in the handling
   of an empty authority component or empty host subcomponent.  For many
   scheme specifications, an empty authority or host is considered an
   error; for others, it is considered equivalent to "localhost" or the
   end-user's host.  When a scheme defines a default for authority and a
   URI reference to that default is desired, the reference should be
   normalized to an empty authority for the sake of uniformity, brevity,
   and internationalization.  If, however, either the userinfo or port
   subcomponents are non-empty, then the host should be given explicitly
   even if it matches the default.

   Normalization should not remove delimiters when their associated
   component is empty unless licensed to do so by the scheme

Berners-Lee, et al.         Standards Track                    [Page 41]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   specification.  For example, the URI "http://example.com/?" cannot be
   assumed to be equivalent to any of the examples above.  Likewise, the
   presence or absence of delimiters within a userinfo subcomponent is
   usually significant to its interpretation.  The fragment component is
   not subject to any scheme-based normalization; thus, two URIs that
   differ only by the suffix "#" are considered different regardless of
   the scheme.

   Some schemes define additional subcomponents that consist of case-
   insensitive data, giving an implicit license to normalizers to
   convert this data to a common case (e.g., all lowercase).  For
   example, URI schemes that define a subcomponent of path to contain an
   Internet hostname, such as the "mailto" URI scheme, cause that
   subcomponent to be case-insensitive and thus subject to case
   normalization (e.g., "mailto:Joe@Example.COM" is equivalent to
   "mailto:Joe@example.com", even though the generic syntax considers
   the path component to be case-sensitive).

   Other scheme-specific normalizations are possible.

[6.2.4](#section-6.2.4).  Protocol-Based Normalization

   Substantial effort to reduce the incidence of false negatives is
   often cost-effective for web spiders.  Therefore, they implement even
   more aggressive techniques in URI comparison.  For example, if they
   observe that a URI such as

      http://example.com/data

   redirects to a URI differing only in the trailing slash

      http://example.com/data/

   they will likely regard the two as equivalent in the future.  This
   kind of technique is only appropriate when equivalence is clearly
   indicated by both the result of accessing the resources and the
   common conventions of their scheme's dereference algorithm (in this
   case, use of redirection by HTTP origin servers to avoid problems
   with relative references).

Berners-Lee, et al.         Standards Track                    [Page 42]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

[7](#section-7).  Security Considerations

   A URI does not in itself pose a security threat.  However, as URIs
   are often used to provide a compact set of instructions for access to
   network resources, care must be taken to properly interpret the data
   within a URI, to prevent that data from causing unintended access,
   and to avoid including data that should not be revealed in plain
   text.

[7.1](#section-7.1).  Reliability and Consistency

   There is no guarantee that once a URI has been used to retrieve
   information, the same information will be retrievable by that URI in
   the future.  Nor is there any guarantee that the information
   retrievable via that URI in the future will be observably similar to
   that retrieved in the past.  The URI syntax does not constrain how a
   given scheme or authority apportions its namespace or maintains it
   over time.  Such guarantees can only be obtained from the person(s)
   controlling that namespace and the resource in question.  A specific
   URI scheme may define additional semantics, such as name persistence,
   if those semantics are required of all naming authorities for that
   scheme.

[7.2](#section-7.2).  Malicious Construction

   It is sometimes possible to construct a URI so that an attempt to
   perform a seemingly harmless, idempotent operation, such as the
   retrieval of a representation, will in fact cause a possibly damaging
   remote operation.  The unsafe URI is typically constructed by
   specifying a port number other than that reserved for the network
   protocol in question.  The client unwittingly contacts a site running
   a different protocol service, and data within the URI contains
   instructions that, when interpreted according to this other protocol,
   cause an unexpected operation.  A frequent example of such abuse has
   been the use of a protocol-based scheme with a port component of
   "25", thereby fooling user agent software into sending an unintended
   or impersonating message via an SMTP server.

   Applications should prevent dereference of a URI that specifies a TCP
   port number within the "well-known port" range (0 - 1023) unless the
   protocol being used to dereference that URI is compatible with the
   protocol expected on that well-known port.  Although IANA maintains a
   registry of well-known ports, applications should make such
   restrictions user-configurable to avoid preventing the deployment of
   new services.

Berners-Lee, et al.         Standards Track                    [Page 43]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   When a URI contains percent-encoded octets that match the delimiters
   for a given resolution or dereference protocol (for example, CR and
   LF characters for the TELNET protocol), these percent-encodings must
   not be decoded before transmission across that protocol.  Transfer of
   the percent-encoding, which might violate the protocol, is less
   harmful than allowing decoded octets to be interpreted as additional
   operations or parameters, perhaps triggering an unexpected and
   possibly harmful remote operation.

[7.3](#section-7.3).  Back-End Transcoding

   When a URI is dereferenced, the data within it is often parsed by
   both the user agent and one or more servers.  In HTTP, for example, a
   typical user agent will parse a URI into its five major components,
   access the authority's server, and send it the data within the
   authority, path, and query components.  A typical server will take
   that information, parse the path into segments and the query into
   key/value pairs, and then invoke implementation-specific handlers to
   respond to the request.  As a result, a common security concern for
   server implementations that handle a URI, either as a whole or split
   into separate components, is proper interpretation of the octet data
   represented by the characters and percent-encodings within that URI.

   Percent-encoded octets must be decoded at some point during the
   dereference process.  Applications must split the URI into its
   components and subcomponents prior to decoding the octets, as
   otherwise the decoded octets might be mistaken for delimiters.
   Security checks of the data within a URI should be applied after
   decoding the octets.  Note, however, that the "%00" percent-encoding
   (NUL) may require special handling and should be rejected if the
   application is not expecting to receive raw data within a component.

   Special care should be taken when the URI path interpretation process
   involves the use of a back-end file system or related system
   functions.  File systems typically assign an operational meaning to
   special characters, such as the "/", "\", ":", "[", and "]"
   characters, and to special device names like ".", "..", "...", "aux",
   "lpt", etc.  In some cases, merely testing for the existence of such
   a name will cause the operating system to pause or invoke unrelated
   system calls, leading to significant security concerns regarding
   denial of service and unintended data transfer.  It would be
   impossible for this specification to list all such significant
   characters and device names.  Implementers should research the
   reserved names and characters for the types of storage device that
   may be attached to their applications and restrict the use of data
   obtained from URI components accordingly.

Berners-Lee, et al.         Standards Track                    [Page 44]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

[7.4](#section-7.4).  Rare IP Address Formats

   Although the URI syntax for IPv4address only allows the common
   dotted-decimal form of IPv4 address literal, many implementations
   that process URIs make use of platform-dependent system routines,
   such as gethostbyname() and inet_aton(), to translate the string
   literal to an actual IP address.  Unfortunately, such system routines
   often allow and process a much larger set of formats than those
   described in [Section 3.2.2](#section-3.2.2).

   For example, many implementations allow dotted forms of three
   numbers, wherein the last part is interpreted as a 16-bit quantity
   and placed in the right-most two bytes of the network address (e.g.,
   a Class B network).  Likewise, a dotted form of two numbers means
   that the last part is interpreted as a 24-bit quantity and placed in
   the right-most three bytes of the network address (Class A), and a
   single number (without dots) is interpreted as a 32-bit quantity and
   stored directly in the network address.  Adding further to the
   confusion, some implementations allow each dotted part to be
   interpreted as decimal, octal, or hexadecimal, as specified in the C
   language (i.e., a leading 0x or 0X implies hexadecimal; a leading 0
   implies octal; otherwise, the number is interpreted as decimal).

   These additional IP address formats are not allowed in the URI syntax
   due to differences between platform implementations.  However, they
   can become a security concern if an application attempts to filter
   access to resources based on the IP address in string literal format.
   If this filtering is performed, literals should be converted to
   numeric form and filtered based on the numeric value, and not on a
   prefix or suffix of the string form.

[7.5](#section-7.5).  Sensitive Information

   URI producers should not provide a URI that contains a username or
   password that is intended to be secret.  URIs are frequently
   displayed by browsers, stored in clear text bookmarks, and logged by
   user agent history and intermediary applications (proxies).  A
   password appearing within the userinfo component is deprecated and
   should be considered an error (or simply ignored) except in those
   rare cases where the 'password' parameter is intended to be public.

[7.6](#section-7.6).  Semantic Attacks

   Because the userinfo subcomponent is rarely used and appears before
   the host in the authority component, it can be used to construct a
   URI intended to mislead a human user by appearing to identify one
   (trusted) naming authority while actually identifying a different
   authority hidden behind the noise.  For example

Berners-Lee, et al.         Standards Track                    [Page 45]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

      ftp://cnn.example.com&story=breaking_news@10.0.0.1/top_story.htm

   might lead a human user to assume that the host is 'cnn.example.com',
   whereas it is actually '10.0.0.1'.  Note that a misleading userinfo
   subcomponent could be much longer than the example above.

   A misleading URI, such as that above, is an attack on the user's
   preconceived notions about the meaning of a URI rather than an attack
   on the software itself.  User agents may be able to reduce the impact
   of such attacks by distinguishing the various components of the URI
   when they are rendered, such as by using a different color or tone to
   render userinfo if any is present, though there is no panacea.  More
   information on URI-based semantic attacks can be found in [[Siedzik](#ref-Siedzik)].

[8](#section-8).  IANA Considerations

   URI scheme names, as defined by <scheme> in [Section 3.1](#section-3.1), form a
   registered namespace that is managed by IANA according to the
   procedures defined in [[BCP35](#ref-BCP35)].  No IANA actions are required by this
   document.

[9](#section-9).  Acknowledgements

   This specification is derived from [RFC 2396](/doc/html/rfc2396) [[RFC2396](/doc/html/rfc2396)], [RFC 1808](/doc/html/rfc1808)
   [[RFC1808](/doc/html/rfc1808)], and [RFC 1738](/doc/html/rfc1738) [[RFC1738](/doc/html/rfc1738)]; the acknowledgements in those
   documents still apply.  It also incorporates the update (with
   corrections) for IPv6 literals in the host syntax, as defined by
   Robert M. Hinden, Brian E. Carpenter, and Larry Masinter in
   [[RFC2732](/doc/html/rfc2732)].  In addition, contributions by Gisle Aas, Reese Anschultz,
   Daniel Barclay, Tim Bray, Mike Brown, Rob Cameron, Jeremy Carroll,
   Dan Connolly, Adam M. Costello, John Cowan, Jason Diamond, Martin
   Duerst, Stefan Eissing, Clive D.W. Feather, Al Gilman, Tony Hammond,
   Elliotte Harold, Pat Hayes, Henry Holtzman, Ian B. Jacobs, Michael
   Kay, John C. Klensin, Graham Klyne, Dan Kohn, Bruce Lilly, Andrew
   Main, Dave McAlpin, Ira McDonald, Michael Mealling, Ray Merkert,
   Stephen Pollei, Julian Reschke, Tomas Rokicki, Miles Sabin, Kai
   Schaetzl, Mark Thomson, Ronald Tschalaer, Norm Walsh, Marc Warne,
   Stuart Williams, and Henry Zongaro are gratefully acknowledged.

[10](#section-10).  References

[10.1](#section-10.1).  Normative References

   [ASCII]    American National Standards Institute, "Coded Character
              Set -- 7-bit American Standard Code for Information
              Interchange", ANSI X3.4, 1986.

Berners-Lee, et al.         Standards Track                    [Page 46]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   [RFC2234]  Crocker, D. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", [RFC 2234](/doc/html/rfc2234), November 1997.

   [STD63]    Yergeau, F., "UTF-8, a transformation format of
              ISO 10646", STD 63, [RFC 3629](/doc/html/rfc3629), November 2003.

   [UCS]      International Organization for Standardization,
              "Information Technology - Universal Multiple-Octet Coded
              Character Set (UCS)", ISO/IEC 10646:2003, December 2003.

[10.2](#section-10.2).  Informative References

   [BCP19]    Freed, N. and J. Postel, "IANA Charset Registration
              Procedures", [BCP 19](/doc/html/bcp19), [RFC 2978](/doc/html/rfc2978), October 2000.

   [BCP35]    Petke, R. and I. King, "Registration Procedures for URL
              Scheme Names", [BCP 35](/doc/html/bcp35), [RFC 2717](/doc/html/rfc2717), November 1999.

   [RFC0952]  Harrenstien, K., Stahl, M., and E. Feinler, "DoD Internet
              host table specification", [RFC 952](/doc/html/rfc952), October 1985.

   [RFC1034]  Mockapetris, P., "Domain names - concepts and facilities",
              STD 13, [RFC 1034](/doc/html/rfc1034), November 1987.

   [RFC1123]  Braden, R., "Requirements for Internet Hosts - Application
              and Support", STD 3, [RFC 1123](/doc/html/rfc1123), October 1989.

   [RFC1535]  Gavron, E., "A Security Problem and Proposed Correction
              With Widely Deployed DNS Software", [RFC 1535](/doc/html/rfc1535),
              October 1993.

   [RFC1630]  Berners-Lee, T., "Universal Resource Identifiers in WWW: A
              Unifying Syntax for the Expression of Names and Addresses
              of Objects on the Network as used in the World-Wide Web",
              [RFC 1630](/doc/html/rfc1630), June 1994.

   [RFC1736]  Kunze, J., "Functional Recommendations for Internet
              Resource Locators", [RFC 1736](/doc/html/rfc1736), February 1995.

   [RFC1737]  Sollins, K. and L. Masinter, "Functional Requirements for
              Uniform Resource Names", [RFC 1737](/doc/html/rfc1737), December 1994.

   [RFC1738]  Berners-Lee, T., Masinter, L., and M. McCahill, "Uniform
              Resource Locators (URL)", [RFC 1738](/doc/html/rfc1738), December 1994.

   [RFC1808]  Fielding, R., "Relative Uniform Resource Locators",
              [RFC 1808](/doc/html/rfc1808), June 1995.

Berners-Lee, et al.         Standards Track                    [Page 47]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   [RFC2046]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part Two: Media Types", [RFC 2046](/doc/html/rfc2046),
              November 1996.

   [RFC2141]  Moats, R., "URN Syntax", [RFC 2141](/doc/html/rfc2141), May 1997.

   [RFC2396]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifiers (URI): Generic Syntax", [RFC 2396](/doc/html/rfc2396),
              August 1998.

   [RFC2518]  Goland, Y., Whitehead, E., Faizi, A., Carter, S., and D.
              Jensen, "HTTP Extensions for Distributed Authoring --
              WEBDAV", [RFC 2518](/doc/html/rfc2518), February 1999.

   [RFC2557]  Palme, J., Hopmann, A., and N. Shelness, "MIME
              Encapsulation of Aggregate Documents, such as HTML
              (MHTML)", [RFC 2557](/doc/html/rfc2557), March 1999.

   [RFC2718]  Masinter, L., Alvestrand, H., Zigmond, D., and R. Petke,
              "Guidelines for new URL Schemes", [RFC 2718](/doc/html/rfc2718), November 1999.

   [RFC2732]  Hinden, R., Carpenter, B., and L. Masinter, "Format for
              Literal IPv6 Addresses in URL's", [RFC 2732](/doc/html/rfc2732), December 1999.

   [RFC3305]  Mealling, M. and R. Denenberg, "Report from the Joint
              W3C/IETF URI Planning Interest Group: Uniform Resource
              Identifiers (URIs), URLs, and Uniform Resource Names
              (URNs): Clarifications and Recommendations", [RFC 3305](/doc/html/rfc3305),
              August 2002.

   [RFC3490]  Faltstrom, P., Hoffman, P., and A. Costello,
              "Internationalizing Domain Names in Applications (IDNA)",
              [RFC 3490](/doc/html/rfc3490), March 2003.

   [RFC3513]  Hinden, R. and S. Deering, "Internet Protocol Version 6
              (IPv6) Addressing Architecture", [RFC 3513](/doc/html/rfc3513), April 2003.

   [Siedzik]  Siedzik, R., "Semantic Attacks: What's in a URL?",
              April 2001, <[http://www.giac.org/practical/gsec/](https://www.giac.org/practical/gsec/Richard_Siedzik_GSEC.pdf)
              [Richard_Siedzik_GSEC.pdf](https://www.giac.org/practical/gsec/Richard_Siedzik_GSEC.pdf)>.

Berners-Lee, et al.         Standards Track                    [Page 48]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

[Appendix A](#appendix-A).  Collected ABNF for URI

   URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

   hier-part     = "//" authority path-abempty
                 / path-absolute
                 / path-rootless
                 / path-empty

   URI-reference = URI / relative-ref

   absolute-URI  = scheme ":" hier-part [ "?" query ]

   relative-ref  = relative-part [ "?" query ] [ "#" fragment ]

   relative-part = "//" authority path-abempty
                 / path-absolute
                 / path-noscheme
                 / path-empty

   scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )

   authority     = [ userinfo "@" ] host [ ":" port ]
   userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
   host          = IP-literal / IPv4address / reg-name
   port          = *DIGIT

   IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"

   IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )

   IPv6address   =                            6( h16 ":" ) ls32
                 /                       "::" 5( h16 ":" ) ls32
                 / [               h16 ] "::" 4( h16 ":" ) ls32
                 / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
                 / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
                 / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
                 / [ *4( h16 ":" ) h16 ] "::"              ls32
                 / [ *5( h16 ":" ) h16 ] "::"              h16
                 / [ *6( h16 ":" ) h16 ] "::"

   h16           = 1*4HEXDIG
   ls32          = ( h16 ":" h16 ) / IPv4address
   IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet

Berners-Lee, et al.         Standards Track                    [Page 49]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   dec-octet     = DIGIT                 ; 0-9
                 / %x31-39 DIGIT         ; 10-99
                 / "1" 2DIGIT            ; 100-199
                 / "2" %x30-34 DIGIT     ; 200-249
                 / "25" %x30-35          ; 250-255

   reg-name      = *( unreserved / pct-encoded / sub-delims )

   path          = path-abempty    ; begins with "/" or is empty
                 / path-absolute   ; begins with "/" but not "//"
                 / path-noscheme   ; begins with a non-colon segment
                 / path-rootless   ; begins with a segment
                 / path-empty      ; zero characters

   path-abempty  = *( "/" segment )
   path-absolute = "/" [ segment-nz *( "/" segment ) ]
   path-noscheme = segment-nz-nc *( "/" segment )
   path-rootless = segment-nz *( "/" segment )
   path-empty    = 0<pchar>

   segment       = *pchar
   segment-nz    = 1*pchar
   segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
                 ; non-zero-length segment without any colon ":"

   pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"

   query         = *( pchar / "/" / "?" )

   fragment      = *( pchar / "/" / "?" )

   pct-encoded   = "%" HEXDIG HEXDIG

   unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
   reserved      = gen-delims / sub-delims
   gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
   sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
                 / "*" / "+" / "," / ";" / "="

[Appendix B](#appendix-B).  Parsing a URI Reference with a Regular Expression

   As the "first-match-wins" algorithm is identical to the "greedy"
   disambiguation method used by POSIX regular expressions, it is
   natural and commonplace to use a regular expression for parsing the
   potential five components of a URI reference.

   The following line is the regular expression for breaking-down a
   well-formed URI reference into its components.

Berners-Lee, et al.         Standards Track                    [Page 50]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

      ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
       12            3  4          5       6  7        8 9

   The numbers in the second line above are only to assist readability;
   they indicate the reference points for each subexpression (i.e., each
   paired parenthesis).  We refer to the value matched for subexpression
   <n> as $<n>.  For example, matching the above expression to

      <http://www.ics.uci.edu/pub/ietf/uri/#Related>

   results in the following subexpression matches:

      $1 = http:
      $2 = http
      $3 = //www.ics.uci.edu
      $4 = www.ics.uci.edu
      $5 = /pub/ietf/uri/
      $6 = <undefined>
      $7 = <undefined>
      $8 = #Related
      $9 = Related

   where <undefined> indicates that the component is not present, as is
   the case for the query component in the above example.  Therefore, we
   can determine the value of the five components as

      scheme    = $2
      authority = $4
      path      = $5
      query     = $7
      fragment  = $9

   Going in the opposite direction, we can recreate a URI reference from
   its components by using the algorithm of [Section 5.3](#section-5.3).

[Appendix C](#appendix-C).  Delimiting a URI in Context

   URIs are often transmitted through formats that do not provide a
   clear context for their interpretation.  For example, there are many
   occasions when a URI is included in plain text; examples include text
   sent in email, USENET news, and on printed paper.  In such cases, it
   is important to be able to delimit the URI from the rest of the text,
   and in particular from punctuation marks that might be mistaken for
   part of the URI.

   In practice, URIs are delimited in a variety of ways, but usually
   within double-quotes "http://example.com/", angle brackets
   <http://example.com/>, or just by using whitespace:

Berners-Lee, et al.         Standards Track                    [Page 51]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

      http://example.com/

   These wrappers do not form part of the URI.

   In some cases, extra whitespace (spaces, line-breaks, tabs, etc.) may
   have to be added to break a long URI across lines.  The whitespace
   should be ignored when the URI is extracted.

   No whitespace should be introduced after a hyphen ("-") character.
   Because some typesetters and printers may (erroneously) introduce a
   hyphen at the end of line when breaking it, the interpreter of a URI
   containing a line break immediately after a hyphen should ignore all
   whitespace around the line break and should be aware that the hyphen
   may or may not actually be part of the URI.

   Using <> angle brackets around each URI is especially recommended as
   a delimiting style for a reference that contains embedded whitespace.

   The prefix "URL:" (with or without a trailing space) was formerly
   recommended as a way to help distinguish a URI from other bracketed
   designators, though it is not commonly used in practice and is no
   longer recommended.

   For robustness, software that accepts user-typed URI should attempt
   to recognize and strip both delimiters and embedded whitespace.

   For example, the text

      Yes, Jim, I found it under "http://www.w3.org/Addressing/",
      but you can probably pick it up from <ftp://foo.example.
      com/rfc/>.  Note the warning in <[http://www.ics.uci.edu/pub/](http://www.ics.uci.edu/pub/ietf/uri/historical.html#WARNING)
      [ietf/uri/historical.html#WARNING](http://www.ics.uci.edu/pub/ietf/uri/historical.html#WARNING)>.

   contains the URI references

      <http://www.w3.org/Addressing/>
      ftp://foo.example.com/rfc/
      <http://www.ics.uci.edu/pub/ietf/uri/historical.html#WARNING>

Berners-Lee, et al.         Standards Track                    [Page 52]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

[Appendix D](#appendix-D).  Changes from [RFC 2396](/doc/html/rfc2396)

[D.1](#appendix-D.1).  Additions

   An ABNF rule for URI has been introduced to correspond to one common
   usage of the term: an absolute URI with optional fragment.

   IPv6 (and later) literals have been added to the list of possible
   identifiers for the host portion of an authority component, as
   described by [[RFC2732](/doc/html/rfc2732)], with the addition of "[" and "]" to the
   reserved set and a version flag to anticipate future versions of IP
   literals.  Square brackets are now specified as reserved within the
   authority component and are not allowed outside their use as
   delimiters for an IP literal within host.  In order to make this
   change without changing the technical definition of the path, query,
   and fragment components, those rules were redefined to directly
   specify the characters allowed.

   As [[RFC2732](/doc/html/rfc2732)] defers to [[RFC3513](/doc/html/rfc3513)] for definition of an IPv6 literal
   address, which, unfortunately, lacks an ABNF description of
   IPv6address, we created a new ABNF rule for IPv6address that matches
   the text representations defined by [Section 2.2 of [RFC3513]](/doc/html/rfc3513#section-2.2).
   Likewise, the definition of IPv4address has been improved in order to
   limit each decimal octet to the range 0-255.

   [Section 6](#section-6), on URI normalization and comparison, has been completely
   rewritten and extended by using input from Tim Bray and discussion
   within the W3C Technical Architecture Group.

[D.2](#appendix-D.2).  Modifications

   The ad-hoc BNF syntax of [RFC 2396](/doc/html/rfc2396) has been replaced with the ABNF of
   [[RFC2234](/doc/html/rfc2234)].  This change required all rule names that formerly
   included underscore characters to be renamed with a dash instead.  In
   addition, a number of syntax rules have been eliminated or simplified
   to make the overall grammar more comprehensible.  Specifications that
   refer to the obsolete grammar rules may be understood by replacing
   those rules according to the following table:

Berners-Lee, et al.         Standards Track                    [Page 53]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   +----------------+--------------------------------------------------+
   | obsolete rule  | translation                                      |
   +----------------+--------------------------------------------------+
   | absoluteURI    | absolute-URI                                     |
   | relativeURI    | relative-part [ "?" query ]                      |
   | hier_part      | ( "//" authority path-abempty /                  |
   |                | path-absolute ) [ "?" query ]                    |
   |                |                                                  |
   | opaque_part    | path-rootless [ "?" query ]                      |
   | net_path       | "//" authority path-abempty                      |
   | abs_path       | path-absolute                                    |
   | rel_path       | path-rootless                                    |
   | rel_segment    | segment-nz-nc                                    |
   | reg_name       | reg-name                                         |
   | server         | authority                                        |
   | hostport       | host [ ":" port ]                                |
   | hostname       | reg-name                                         |
   | path_segments  | path-abempty                                     |
   | param          | *<pchar excluding ";">                           |
   |                |                                                  |
   | uric           | unreserved / pct-encoded / ";" / "?" / ":"       |
   |                |  / "@" / "&" / "=" / "+" / "$" / "," / "/"       |
   |                |                                                  |
   | uric_no_slash  | unreserved / pct-encoded / ";" / "?" / ":"       |
   |                |  / "@" / "&" / "=" / "+" / "$" / ","             |
   |                |                                                  |
   | mark           | "-" / "_" / "." / "!" / "~" / "*" / "'"          |
   |                |  / "(" / ")"                                     |
   |                |                                                  |
   | escaped        | pct-encoded                                      |
   | hex            | HEXDIG                                           |
   | alphanum       | ALPHA / DIGIT                                    |
   +----------------+--------------------------------------------------+

   Use of the above obsolete rules for the definition of scheme-specific
   syntax is deprecated.

   [Section 2](#section-2), on characters, has been rewritten to explain what
   characters are reserved, when they are reserved, and why they are
   reserved, even when they are not used as delimiters by the generic
   syntax.  The mark characters that are typically unsafe to decode,
   including the exclamation mark ("!"), asterisk ("*"), single-quote
   ("'"), and open and close parentheses ("(" and ")"), have been moved
   to the reserved set in order to clarify the distinction between
   reserved and unreserved and, hopefully, to answer the most common
   question of scheme designers.  Likewise, the section on
   percent-encoded characters has been rewritten, and URI normalizers
   are now given license to decode any percent-encoded octets

Berners-Lee, et al.         Standards Track                    [Page 54]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   corresponding to unreserved characters.  In general, the terms
   "escaped" and "unescaped" have been replaced with "percent-encoded"
   and "decoded", respectively, to reduce confusion with other forms of
   escape mechanisms.

   The ABNF for URI and URI-reference has been redesigned to make them
   more friendly to LALR parsers and to reduce complexity.  As a result,
   the layout form of syntax description has been removed, along with
   the uric, uric_no_slash, opaque_part, net_path, abs_path, rel_path,
   path_segments, rel_segment, and mark rules.  All references to
   "opaque" URIs have been replaced with a better description of how the
   path component may be opaque to hierarchy.  The relativeURI rule has
   been replaced with relative-ref to avoid unnecessary confusion over
   whether they are a subset of URI.  The ambiguity regarding the
   parsing of URI-reference as a URI or a relative-ref with a colon in
   the first segment has been eliminated through the use of five
   separate path matching rules.

   The fragment identifier has been moved back into the section on
   generic syntax components and within the URI and relative-ref rules,
   though it remains excluded from absolute-URI.  The number sign ("#")
   character has been moved back to the reserved set as a result of
   reintegrating the fragment syntax.

   The ABNF has been corrected to allow the path component to be empty.
   This also allows an absolute-URI to consist of nothing after the
   "scheme:", as is present in practice with the "dav:" namespace
   [[RFC2518](/doc/html/rfc2518)] and with the "about:" scheme used internally by many WWW
   browser implementations.  The ambiguity regarding the boundary
   between authority and path has been eliminated through the use of
   five separate path matching rules.

   Registry-based naming authorities that use the generic syntax are now
   defined within the host rule.  This change allows current
   implementations, where whatever name provided is simply fed to the
   local name resolution mechanism, to be consistent with the
   specification.  It also removes the need to re-specify DNS name
   formats here.  Furthermore, it allows the host component to contain
   percent-encoded octets, which is necessary to enable
   internationalized domain names to be provided in URIs, processed in
   their native character encodings at the application layers above URI
   processing, and passed to an IDNA library as a registered name in the
   UTF-8 character encoding.  The server, hostport, hostname,
   domainlabel, toplabel, and alphanum rules have been removed.

   The resolving relative references algorithm of [[RFC2396](/doc/html/rfc2396)] has been
   rewritten with pseudocode for this revision to improve clarity and
   fix the following issues:

Berners-Lee, et al.         Standards Track                    [Page 55]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   o  [[RFC2396] section 5.2](/doc/html/rfc2396#section-5.2), step 6a, failed to account for a base URI
      with no path.

   o  Restored the behavior of [[RFC1808](/doc/html/rfc1808)] where, if the reference
      contains an empty path and a defined query component, the target
      URI inherits the base URI's path component.

   o  The determination of whether a URI reference is a same-document
      reference has been decoupled from the URI parser, simplifying the
      URI processing interface within applications in a way consistent
      with the internal architecture of deployed URI processing
      implementations.  The determination is now based on comparison to
      the base URI after transforming a reference to absolute form,
      rather than on the format of the reference itself.  This change
      may result in more references being considered "same-document"
      under this specification than there would be under the rules given
      in [RFC 2396](/doc/html/rfc2396), especially when normalization is used to reduce
      aliases.  However, it does not change the status of existing
      same-document references.

   o  Separated the path merge routine into two routines: merge, for
      describing combination of the base URI path with a relative-path
      reference, and remove_dot_segments, for describing how to remove
      the special "." and ".." segments from a composed path.  The
      remove_dot_segments algorithm is now applied to all URI reference
      paths in order to match common implementations and to improve the
      normalization of URIs in practice.  This change only impacts the
      parsing of abnormal references and same-scheme references wherein
      the base URI has a non-hierarchical path.

Index

   A
      ABNF  11
      absolute  27
      absolute-path  26
      absolute-URI  27
      access  9
      authority  17, 18

   B
      base URI  28

   C
      character encoding  4
      character  4
      characters  8, 11
      coded character set  4

Berners-Lee, et al.         Standards Track                    [Page 56]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

   D
      dec-octet  20
      dereference  9
      dot-segments  23

   F
      fragment  16, 24

   G
      gen-delims  13
      generic syntax  6

   H
      h16  20
      hier-part  16
      hierarchical  10
      host  18

   I
      identifier  5
      IP-literal  19
      IPv4  20
      IPv4address  19, 20
      IPv6  19
      IPv6address  19, 20
      IPvFuture  19

   L
      locator  7
      ls32  20

   M
      merge  32

   N
      name  7
      network-path  26

   P
      path  16, 22, 26
         path-abempty  22
         path-absolute  22
         path-empty  22
         path-noscheme  22
         path-rootless  22
      path-abempty  16, 22, 26
      path-absolute  16, 22, 26
      path-empty  16, 22, 26

Berners-Lee, et al.         Standards Track                    [Page 57]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

      path-rootless  16, 22
      pchar  23
      pct-encoded  12
      percent-encoding  12
      port  22

   Q
      query  16, 23

   R
      reg-name  21
      registered name  20
      relative  10, 28
      relative-path  26
      relative-ref  26
      remove_dot_segments  33
      representation  9
      reserved  12
      resolution  9, 28
      resource  5
      retrieval  9

   S
      same-document  27
      sameness  9
      scheme  16, 17
      segment  22, 23
         segment-nz  23
         segment-nz-nc  23
      sub-delims  13
      suffix  27

   T
      transcription  8

   U
      uniform  4
      unreserved  13
      URI grammar
         absolute-URI  27
         ALPHA  11
         authority  18
         CR  11
         dec-octet  20
         DIGIT  11
         DQUOTE  11
         fragment  24
         gen-delims  13

Berners-Lee, et al.         Standards Track                    [Page 58]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

         h16  20
         HEXDIG  11
         hier-part  16
         host  19
         IP-literal  19
         IPv4address  20
         IPv6address  20
         IPvFuture  19
         LF  11
         ls32  20
         OCTET  11
         path  22
         path-abempty  22
         path-absolute  22
         path-empty  22
         path-noscheme  22
         path-rootless  22
         pchar  23
         pct-encoded  12
         port  22
         query  24
         reg-name  21
         relative-ref  26
         reserved  13
         scheme  17
         segment  23
         segment-nz  23
         segment-nz-nc  23
         SP  11
         sub-delims  13
         unreserved  13
         URI  16
         URI-reference  25
         userinfo  18
      URI  16
      URI-reference  25
      URL  7
      URN  7
      userinfo  18

Berners-Lee, et al.         Standards Track                    [Page 59]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

Authors' Addresses

   Tim Berners-Lee
   World Wide Web Consortium
   Massachusetts Institute of Technology
   77 Massachusetts Avenue
   Cambridge, MA  02139
   USA

   Phone: +1-617-253-5702
   Fax:   +1-617-258-5999
   EMail: timbl@w3.org
   URI:   <http://www.w3.org/People/Berners-Lee/>

   Roy T. Fielding
   Day Software
   5251 California Ave., Suite 110
   Irvine, CA  92617
   USA

   Phone: +1-949-679-2960
   Fax:   +1-949-679-2972
   EMail: fielding@gbiv.com
   URI:   <http://roy.gbiv.com/>

   Larry Masinter
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   Phone: +1-408-536-3024
   EMail: LMM@acm.org
   URI:   <http://larry.masinter.net/>

Berners-Lee, et al.         Standards Track                    [Page 60]
```

---

```

[RFC 3986](/doc/html/rfc3986)                   URI Generic Syntax               January 2005

Full Copyright Statement

   Copyright (C) The Internet Society (2005).

   This document is subject to the rights, licenses and restrictions
   contained in [BCP 78](/doc/html/bcp78), and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the IETF's procedures with respect to rights in IETF Documents can
   be found in [BCP 78](/doc/html/bcp78) and [BCP 79](/doc/html/bcp79).

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <http://www.ietf.org/ipr>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at ietf-
   ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.

Berners-Lee, et al.         Standards Track                    [Page 61]

```

[Datatracker](/doc/rfc3986/)

RFC 3986

RFC
- Internet Standard

* Info
* Contents
* Prefs

| Document | Document type |  | RFC - Internet Standard  January 2005  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=3986 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") Updated by [RFC 8820](/doc/html/rfc8820 "URI Design and Ownership"), [RFC 6874](/doc/html/rfc6874 "Representing IPv6 Zone Identifiers in Address Literals and Uniform Resource Identifiers"), [RFC 7320](/doc/html/rfc7320 "URI Design and Ownership") Obsoletes [RFC 1808](/doc/html/rfc1808 "Relative Uniform Resource Locators"), [RFC 2732](/doc/html/rfc2732 "Format for Literal IPv6 Addresses in URL's"), [RFC 2396](/doc/html/rfc2396 "Uniform Resource Identifiers (URI): Generic Syntax") Updates [RFC 1738](/doc/html/rfc1738 "Uniform Resource Locators (URL)") Was [draft-fielding-uri-rfc2396bis](/doc/draft-fielding-uri-rfc2396bis/07/) (individual in gen area) |
| --- | --- | --- | --- |
|  | Select version |  | * [07](/doc/html/draft-fielding-uri-rfc2396bis-07) * [RFC 3986](/doc/html/rfc3986) |
|  | Compare versions |  | RFC 3986  draft-fielding-uri-rfc2396bis-07  draft-fielding-uri-rfc2396bis-06  draft-fielding-uri-rfc2396bis-05  draft-fielding-uri-rfc2396bis-04  draft-fielding-uri-rfc2396bis-03  draft-fielding-uri-rfc2396bis-02  draft-fielding-uri-rfc2396bis-01  draft-fielding-uri-rfc2396bis-00   RFC 3986  draft-fielding-uri-rfc2396bis-07  draft-fielding-uri-rfc2396bis-06  draft-fielding-uri-rfc2396bis-05  draft-fielding-uri-rfc2396bis-04  draft-fielding-uri-rfc2396bis-03  draft-fielding-uri-rfc2396bis-02  draft-fielding-uri-rfc2396bis-01  draft-fielding-uri-rfc2396bis-00   Side-by-side  Inline |
|  | Authors |  | [Tim Berners-Lee](/person/timbl%40w3.org "Datatracker profile of Tim Berners-Lee") , [Roy T. Fielding](/person/fielding%40gbiv.com "Datatracker profile of Roy T. Fielding") , [Larry M Masinter](/person/lmm%40acm.org "Datatracker profile of Larry M Masinter")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc3986.txt) [html](https://www.rfc-editor.org/rfc/rfc3986.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc3986.txt.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc3986.html) [bibtex](/doc/rfc3986/bibtex/) |

[Report a datatracker bug](https://github.com/ietf-tools/datatracker/issues/new/choose)

Show sidebar by default

Yes

No

Tab to show by default

Info

Contents

HTMLization configuration

HTMLize the plaintext

Plaintextify the HTML

Maximum font size

Page dependencies

Inline

Reference

Citation links

 Go to reference section

Go to linked document

![](//analytics.ietf.org/piwik.php?idsite=7)



=== Content from github.com_922f62d6_20250119_124242.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Foauthjs%2Fnode-oauth2-server%2Fissues%2F637)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Foauthjs%2Fnode-oauth2-server%2Fissues%2F637)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fissues_fragments%2Fissue_layout&source=header-repo&source_repo=oauthjs%2Fnode-oauth2-server)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[oauthjs](/oauthjs)
/
**[node-oauth2-server](/oauthjs/node-oauth2-server)**
Public

* [Notifications](/login?return_to=%2Foauthjs%2Fnode-oauth2-server) You must be signed in to change notification settings
* [Fork
  931](/login?return_to=%2Foauthjs%2Fnode-oauth2-server)
* [Star
   4k](/login?return_to=%2Foauthjs%2Fnode-oauth2-server)

* [Code](/oauthjs/node-oauth2-server)
* [Issues
  159](/oauthjs/node-oauth2-server/issues)
* [Pull requests
  31](/oauthjs/node-oauth2-server/pulls)
* [Actions](/oauthjs/node-oauth2-server/actions)
* [Projects
  0](/oauthjs/node-oauth2-server/projects)
* [Wiki](/oauthjs/node-oauth2-server/wiki)
* [Security](/oauthjs/node-oauth2-server/security)
* [Insights](/oauthjs/node-oauth2-server/pulse)

Additional navigation options

* [Code](/oauthjs/node-oauth2-server)
* [Issues](/oauthjs/node-oauth2-server/issues)
* [Pull requests](/oauthjs/node-oauth2-server/pulls)
* [Actions](/oauthjs/node-oauth2-server/actions)
* [Projects](/oauthjs/node-oauth2-server/projects)
* [Wiki](/oauthjs/node-oauth2-server/wiki)
* [Security](/oauthjs/node-oauth2-server/security)
* [Insights](/oauthjs/node-oauth2-server/pulse)

# Multiple Security Vulnerabilities in Auth and Token Endpoint #637

[New issue](/login?return_to=)[Jump to bottom](#comment-composer-heading)Copy link[New issue](/login?return_to=)[Jump to bottom](#comment-composer-heading)Copy linkOpen[node-oauth/node-oauth2-server#231](https://github.com/node-oauth/node-oauth2-server/pull/231)node-oauth/node-oauth2-server#231Open[Multiple Security Vulnerabilities in Auth and Token Endpoint](#top)#637[node-oauth/node-oauth2-server#231](https://github.com/node-oauth/node-oauth2-server/pull/231)Copy linkLabels[under-review](https://github.com/oauthjs/node-oauth2-server/issues?q=state%3Aopen%20label%3A%22under-review%22)![@tamjidrahat](https://avatars.githubusercontent.com/u/1904950?u=dd9c601d7c5cbb482658095ae9ad5c47b04e0b06&v=4&size=80)
## Description

![@tamjidrahat](https://avatars.githubusercontent.com/u/1904950?u=dd9c601d7c5cbb482658095ae9ad5c47b04e0b06&v=4&size=48)[tamjidrahat](https://github.com/tamjidrahat)opened [on Jul 16, 2020](https://github.com/oauthjs/node-oauth2-server/issues/637#issue-657747248)

I would like to report several security vulnerabilities that I found while using this OAuth server library.

The vulnerabilities and their consequences are listed as following:

**Vulnerability 1:** Missing PKCE support for public clients.

***Consequences:*** As specified in RFC-7636 (<https://tools.ietf.org/html/rfc7636>), public clients (e.g., mobile/desktop apps) using Authorization Code Flow are susceptible to authorization code interception attack and PKCE is recommended to mitigate this attack. Since public clients cannot maintain client-side confidentiality regarding client secrets, such attacks have been noticed in the wild extensively.

**Vulnerability 2:** Does not revoke previously issued token if authorization\_code is used more than once.

***Consequences:*** As specified in RFC-6749 (<https://tools.ietf.org/html/rfc6749#section-4.1.2>), If an authorization code is used more than once, the authorization server must deny the request and should revoke all tokens previously issued based on that authorization code. Though OAuth2-server currently denies the request in such cases, it doesn't revoke the tokens issued previously to the client, which leaves the user's resources vulnerable as attackers might exploit the previous tokens to get them.

**Vulnerability 3:** Allows fragment in the redirect URI.

***Consequences:*** Many OAuth attacks regarding misuse of redirect uris have been observed in the wild. As specified in the RFC-6749 (<https://tools.ietf.org/html/rfc6749#section-3.1.2>), authorization server should not allow fragments in the redirect uri as it allows the attackers to exploit the redirect uri and hence intercept the auth\_code/token.

Any comments or fixes regarding these vulnerabilities?

Thank you.

## Metadata

### Assignees

No one assigned

### Labels

[under-review](https://github.com/oauthjs/node-oauth2-server/issues?q=state%3Aopen%20label%3A%22under-review%22)
### Type

No type
### Projects

No projects
### Milestone

No milestone

### Relationships

None yet
### Development

No branches or pull requests
## Issue actions

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


