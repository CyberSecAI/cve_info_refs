```json
{
  "CVE-2020-26973": {
    "related_content": true,
    "summary": "CSS sanitization omits trailing comment tag",
    "root_cause": "The CSS sanitizer was incorrectly removing the trailing comment tag `-->` when sanitizing CSS code within `<style>` tags.",
    "weaknesses": [
      "Incorrect CSS sanitization logic",
      "Sanitizer bypass"
    ],
    "impact": "The omission of the closing comment tag could lead to a sanitizer bypass, allowing malicious CSS rules to be injected into the page. Specifically, by removing the closing comment tag, the rest of the CSS code after the closing tag is parsed and applied, potentially leading to arbitrary code execution or data exfiltration through CSS injection.",
    "attack_vectors": [
      "Malicious CSS code injection"
    ],
    "attacker_capabilities": "The attacker needs to be able to inject malicious CSS code that could bypass the sanitizer, such as by exploiting a vulnerability in a web application that handles CSS.  The attacker could also inject a crafted HTML email in Thunderbird to trigger the vulnerability when forwarding or replying."
  },
  "CVE-2020-26971": {
    "related_content": true,
    "summary": "Heap Overflow in webGL PixelbyPixel",
     "root_cause": "The root cause of the heap overflow is a lack of proper bounds checking in the `StretchedBlitNearest_PixelByPixel` function, which is part of the ANGLE (Almost Native Graphics Layer Engine) library used by Firefox for WebGL. Specifically, the function calculates destination and source memory addresses for blitting operations using user-controlled input from `blitFramebuffer` calls without proper validation, allowing writes outside the bounds of allocated memory.",
    "weaknesses": [
      "Heap buffer overflow",
       "Inadequate input validation"
    ],
    "impact": "A successful exploit of this vulnerability could lead to arbitrary code execution through a heap buffer overflow on some video drivers. The attacker is able to control the source and destination memory locations when blitting, therefore this vulnerability may be exploitable.",
     "attack_vectors": [
      "WebGL `blitFramebuffer` API",
      "Malicious WebGL content",
      "Browser-based attack"
    ],
    "attacker_capabilities": "An attacker needs to be able to execute malicious WebGL code in a vulnerable browser, which can be done by hosting the code on a website or by using an exploit in an application that uses WebGL rendering (e.g., Thunderbird)."
  },
   "CVE-2020-26972": {
    "related_content": true,
    "summary": "AddressSanitizer: heap-use-after-free [@ GetLifecycleProxy] through [@ mozilla::ClientWebGLContext::GetFrontBufferSnapshot] with READ of size 8",
    "root_cause": "The root cause of the heap-use-after-free is due to the `RaiiShmem` object holding a raw pointer to the `LifecycleProxy` which could be invalidated if the associated actor is destroyed before the `RaiiShmem` object, leading to a UAF when calling `GetLifecycleProxy()`. ",
    "weaknesses": [
      "Use-after-free",
      "Improper lifecycle management of IPC objects"
    ],
      "impact": "A successful exploit of this use-after-free could lead to arbitrary code execution and a potentially exploitable crash. The vulnerability occurs in a context that can be triggered by malicious WebGL content.",
     "attack_vectors": [
        "Malicious WebGL content",
        "Browser-based attack"
      ],
    "attacker_capabilities": "An attacker needs to execute malicious WebGL content to trigger the use-after-free. The attacker needs to cause the top level protocol to die while the code attempts to use a shared memory handle, this might be achieved by a series of IPC commands."
    }
}
```