=== Content from www.vusec.net_6b61e55d_20250119_120254.html ===

[![vusec](/wp-content/uploads/2022/09/cropped-vusec.png)](/)

# [vusec](/)

[Search](#search-container)

Primary Menu
[Skip to content](#content)

* [About VUSec](/)
* [People](/people/)
  + [Faculty](/people#faculty)
  + [PhD Students](/people#phd-students)
  + [Support](/people#support)
  + [Alumni](/people#alumni)
* [Projects](/projects/)
  + [Binary Armoring](/projects#armoring)
  + [Binary and Malware Analysis](/projects#bama)
  + [Hardware Vulnerabilities](/projects#hardware-vulnerabilities)
  + [Mobile Security](/projects#mobile)
  + [Side Channels](/projects#side-channels)
  + [Software Exploitation](/projects#software-exploitation)
  + [Software Reliability](/projects#reliability)
  + [Software Testing](/projects#testing)
* [Highlights](/highlights/)
* [Publications](/publications/)
* [News](/news/)
* [Join](/join/)
* [Student projects](/student-projects/)
* [Funding](/funding/)
* [Contacts](/contacts/)

Search for:

# TRRespass

# **Project Description**

Rowhammer haunted us for the better part of the past decade. Most DDR3 modules were found to be susceptible to this vulnerability which can compromise data directly inside the memory cells. What made it so scary was the fact that it could be exploited from software on [PCs](/projects/dedup-est-machina/), [clouds](/projects/flip-feng-shui/), [smartphones](/projects/drammer/), [over the web](/projects/glitch/) and even [remotely from the network](/projects/throwhammer/). To address the problem, memory vendors designed and implemented all sorts of defenses inside their modern DDR4 chips. According to the vendors, now that DDR4 is widely-deployed we now live in a Rowhammer-free world. But do we?

Well, after two years of rigorous research, looking inside what is implemented inside CPUs and DDR4 chips using novel reverse engineering techniques, we can tell you that we do not live in a Rowhammer-free world. And we will not for the better part of this decade. Turns out while the old hammering techniques no longer work, once we understand the exact nature of these mitigations inside modern DDR4 chips, using new hammering patterns it is trivial to again trigger plenty of new bit flips. Yet again, these results show the perils of lack of transparency and security-by-obscurity. This is especially problematic since unlike software vulnerabilities, we cannot fix these hardware bit flips post-production.

*What’s this Rowhammer thingy again?*

There are some guarantees that the memory modules promise to give us. First of all, if we write data in memory, it should remain unchanged unless we modify it – we call this the memory integrity principle. Since 2012, the year of discovery of Rowhammer, this guarantee has been lost. The memory cells can be manipulated by unintended side effects by carefully crafting accesses to adjacent memory locations. An attacker accessing some memory rows (aggressors) repeatedly can trigger errors in the neighbor ones (victim rows). In other words, a bit in memory could change its state from zero to one or vice versa without being directly accessed. It is a hardware bug that we cannot patch with the usual updating mechanism for fixing security problems.

**Enter TRR:** Target Row Refresh (TRR) is what was sold as the ultimate solution against Rowhammer. This name has been widely misused to coalesce any sort of mitigation protecting DDR4 systems from Rowhammer. In reality every CPU vendor and memory manufacturer has implemented its own solution and due to the secretive policies enforced by all of them most of the discussions about the topic are somewhat confused. Nevertheless, these TRR-like solutions are deployed in any modern DDR4 module and memory vendors proudly sell Rowhammer-free memory.

But… I’ve seen [bit flips on DDR4](https://arstechnica.com/information-technology/2016/03/once-thought-safe-ddr4-memory-shown-to-be-vulnerable-to-rowhammer/)!!!

![](/wp-content/uploads/2020/03/double-sided.jpg)

You’re right. We also thought DDR4 was completely broken. That was until we tested a sample of 42 DIMMs against all known variants of Rowhammer variants. As an example, the figure above shows the most “double-sided” Rowhammer variant where the attacker tries to inject bit flips in row x by hammering row x – 1 and x + 1. Surprisingly, we did not observe a single bit flip with all these known variants as shown in the plot below.

![](/wp-content/uploads/2020/03/rh-effectiveness-scaled.jpg)

So we started wondering, is Rowhammer fixed once and for all? Well, to figure this out we had to dig deeper into the internals of these mitigations. Little spoiler: they did not fix the issue. DDR4 memory is still broken, as its Low Power variant is (yes! the one inside your phone). And they have been for a long time.

*And how did you figure this out?*

Given that the operation of TRR is impossible to understand directly from a PC, we relied on a FPGA to impersonate the memory controller (that thing that allows your CPU to access your memory). We collaborated with researchers at ETH Zurich who built an FPGA-based infrastructure, called SoftMC, that allows us precise control over low-level DRAM commands. This is not very easy to do from a traditional computer since the CPU’s memory controller applies many optimizations when interacting with DRAM, making it difficult to understand the internal operations of the DRAM chips from software. Together we came up with a series of convoluted experiments using SoftMC to better understand the internals of a few DRAM chips.

The DIMMs we tested from SoftMC showed a worrying trend: (1) the vulnerability has gotten worse compared to DDR3 and (2) once you understand the mitigation the bit flips start to pour.

## **Many-sided Rowhammer**

One of the key insights we gain from our manual analysis on SoftMC is that TRR needs to keep track of how many accesses an attacker performs to which (aggressor) rows to identify them and then refresh the neighboring rows (the victims). The mitigation clearly cannot keep the information about all accessed rows at the same time, since it would require an unaffordable amount of additional memory nor can it refresh all the victims. The known Rowhammer variants use at most two aggressor rows to perform the attack, a small number rows that are being accessed frequently can easily be monitored by TRR. But what if we use more aggressor rows?

![](/wp-content/uploads/2020/03/rowsVsFlips-scaled.jpg)

As can be seen from the figure, once we select more aggressors, we start observing Rowhammer bit flips (in default settings). This is a surprising and somewhat counter-intuitive result. Remember that during a Rowhammer attack, we like to stress the victim rows as much as possible. This means that having more aggressor rows reduces this effect. But having more aggressors overwhelms the TRR mitigation since it can only track a few aggressor rows at a time. “Luckily” DDR4 chips are more vulnerable, giving us the possibility to reduce the number of accesses to each of the aggressors to trigger bit flips. Or in other words, to increase the number of the aggressors in order to bypass the mitigation.

Our analysis further showed that hammering rows that are close to each other is significantly more effective than randomly selecting them to be anywhere inside memory. An example of an effective hammering pattern is what we call many-sided rowhammer shown below. In many-sided rowhammer, the attacker hammers many different (aggressor) rows that are separated by single (victim) rows in between. But what is the correct number of aggressors? The answer is that it depends on the mitigation that is deployed inside the DIMM.

![](/wp-content/uploads/2020/03/quad-sided.jpg)

## **TRRespass: the** ***Rowfuzzer***

A fuzzer is a tool designed to discover errors in software by producing many random data as input. While fuzzing is a common technique in software testing, we implemented the first fuzzer aimed at triggering Rowhammer corruptions in DRAM. We used the insights gained from our analysis with SoftMC in the design of our fuzzer, called TRRespass. TRRespass repeatedly selects random different rows at various locations in DRAM for hammering. TRRespass is open source and you can try it out for yourself.

We tried TRRespass on the three major memory vendors (compromising more than 99% of the market) using 42 DIMMs. The results did not portray a happy future for data integrity.

**Give us the numbers!!**

TRRespass found bit flips on 12 of the 42 DIMMs in our testbed. The table below shows statistics from the analysis of 256MB of memory for each module. We also report the manufacture date and the pattern that better performs.

| **Module** | **Date** | **Best Pattern** | **1->0** | **0->1** |
| --- | --- | --- | --- | --- |
| A4 | 16-51 | 9-sided | 4008 | 3948 |
| A8 | 17-09 | 19-sided | 10289 | 10519 |
| A9 | 17-31 | 19-sided | 12580 | 12274 |
| A10 | 19-02 | 10-sided | 1809 | 11533 |
| A11 | 19-02 | 10-sided | 1682 | 11148 |
| A14 | 19-08 | 14-sided | 16490 | 16233 |
| A15 | 17-08 | 3-sided | 12351 | 10046 |
| B0 | 18-11 | 3-sided | 10 | 7 |
| B1 | 18-11 | 3-sided | 16 | 6 |
| B2 | 18-49 | 3-sided | 2 | 3 |
| B9 | 19-08 | 3-sided | – | 12 |
| C12 | 15-01 | 10-sided | 63904 | 126133 |
| C13 | 18-49 | 9-sided | 239 | 455 |

##

## **Bit flips on recent mobile phones**

We also ported a simplified version of TRRespass to ARM and managed to trigger bit flips on a variety of smartphones such as Google Pixel 3 and Samsung Galaxy S10. This results show that LPDDR4 is similarly affected to the Rowhammer variants that TRRespass can find.

## Papers

# **Disclosure**

We followed a multi-party coordinated vulnerability disclosure involving the main memory vendors and all the other major affected third parties. We were supported by the Dutch [National Cyber Security Centre](https://www.ncsc.nl/english)  (NCSC) in the process.

# **Frequently Asked Questions**

* + **Which DIMM should I buy to be safe?**No real answer here. TRRespass could find flips in many DIMMs, but also not in many others. However, this does not mean that they are safe. Finding the right hammering pattern could be just a matter of time for our fuzzer or we may need additional parameters to improve the fuzzing strategy.
  + **How can I check whether my DRAM is vulnerable?**The TRRsspass code is available on [GitHub](https://github.com/vusec/trrespass) . We are also going to release an Android App so that you will be able to test your own smartphone.
  + **What if I have ECC-capable DIMMs?**We observed many bit flips on the same victim row during our experiments (way more compared to the flips on DDR3 modules). This would lead at least to a denial of service attack. However, since [ECC has been shown not to be completely effective against Rowhammer](/projects/eccploit/), we believe that a stubborn attacker could still exploit memory errors.
  + **What if my system runs with a double refresh rate?**
    Doubling the refresh rate has been demonstrated to be a weak solution. In the paper we report that even double refreshing the memory does not stop all the flips.
  + **Why did you anonymize the name of the memory vendors?**
    We believe that all of the three major DRAM vendors are somewhat equally vulnerable as our manual analysis suggested. This is an industry wide issue caused by the fact that they have been cramming more and more cells inside these chips. Unfortunately, our evaluation does not portray this picture and we think it would be unfair to penalize a vendor or the other. That being said, the vendors are three. Not so much entropy to figure it out. Have fun!
  + **OMG!! I have one of the phones on the list!! Am I vulnerable?**As mentioned multiple times we believe most of the memory modules out there are vulnerable. That being said, even if you have one of the phones over there it doesn’t mean it has the same memory manufacturer. Indeed, the same phone could have different memory chips depending on the production batch, manufacturing site, etc. Our evaluation on smartphones is preliminary and future work is definitely required to get a better understanding of the mobile landscape.
  + **If this is so important, did Steve Gibson talk about this yet?**He sure did: <https://youtu.be/e1qG0Sl7lVA?t=5685>

# Acknowledgements

This work was supported by the European Union’s Horizon 2020 research and innovation programme under grant agreements No. 786669 (ReAct) and No. 825377 (UNICORE), by Intel Corporation through the Side Channel Vulnerability ISRA, and by the Netherlands Organisation for Scientific Research through grants NWO 639.023.309 VICI “Dowsing”, NWO 639.021.753 VENI “PantaRhei”, and NWO 016.Veni.192.262. The public artifacts reflect only the authors’ view. The funding agencies are not responsible for any use that may be made of the information they contain.

## Systems and Network Security Group at VU Amsterdam

## Recent Tweets

[Recent Tweets](https://twitter.com/vu5ec?ref_src=twsrc%5Etfw)

## Recent Posts

# Archives

* [August 2021](/2021/08/)
* [December 2020](/2020/12/)
* [August 2020](/2020/08/)
* [May 2020](/2020/05/)
* [March 2020](/2020/03/)
* [January 2020](/2020/01/)
* [November 2019](/2019/11/)
* [May 2019](/2019/05/)
* [March 2019](/2019/03/)
* [November 2018](/2018/11/)
* [July 2018](/2018/07/)
* [May 2018](/2018/05/)
* [March 2018](/2018/03/)
* [January 2018](/2018/01/)
* [December 2017](/2017/12/)
* [November 2017](/2017/11/)
* [October 2017](/2017/10/)
* [September 2017](/2017/09/)
* [August 2017](/2017/08/)
* [July 2017](/2017/07/)
* [April 2017](/2017/04/)
* [March 2017](/2017/03/)
* [February 2017](/2017/02/)
* [January 2017](/2017/01/)
* [December 2016](/2016/12/)
* [November 2016](/2016/11/)
* [October 2016](/2016/10/)
* [September 2016](/2016/09/)
* [August 2016](/2016/08/)
* [July 2016](/2016/07/)
* [May 2016](/2016/05/)
* [April 2016](/2016/04/)
* [February 2016](/2016/02/)
* [January 2016](/2016/01/)
* [June 2014](/2014/06/)
# Categories

* [award](/category/award/)
* [grant](/category/grant/)
* [presentation](/category/presentation/)
* [press](/category/press/)
* [publication](/category/publication/)
* [statement](/category/statement/)
* [strategy](/category/strategy/)
* [Uncategorized](/category/uncategorized/)
* [uptake](/category/uptake/)

[Proudly powered by WordPress](https://wordpress.org/)



=== Content from github.com_af7e5c3c_20250119_120250.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvusec%2Ftrrespass)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvusec%2Ftrrespass)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E&source=header-repo&source_repo=vusec%2Ftrrespass)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[vusec](/vusec)
/
**[trrespass](/vusec/trrespass)**
Public

* [Notifications](/login?return_to=%2Fvusec%2Ftrrespass) You must be signed in to change notification settings
* [Fork
  26](/login?return_to=%2Fvusec%2Ftrrespass)
* [Star
   123](/login?return_to=%2Fvusec%2Ftrrespass)

TRRespass

### License

[Apache-2.0 license](/vusec/trrespass/blob/master/LICENSE)

[123
stars](/vusec/trrespass/stargazers) [26
forks](/vusec/trrespass/forks) [Branches](/vusec/trrespass/branches) [Tags](/vusec/trrespass/tags) [Activity](/vusec/trrespass/activity)
 [Star](/login?return_to=%2Fvusec%2Ftrrespass)

 [Notifications](/login?return_to=%2Fvusec%2Ftrrespass) You must be signed in to change notification settings

* [Code](/vusec/trrespass)
* [Issues
  7](/vusec/trrespass/issues)
* [Pull requests
  0](/vusec/trrespass/pulls)
* [Actions](/vusec/trrespass/actions)
* [Projects
  0](/vusec/trrespass/projects)
* [Security](/vusec/trrespass/security)
* [Insights](/vusec/trrespass/pulse)

Additional navigation options

* [Code](/vusec/trrespass)
* [Issues](/vusec/trrespass/issues)
* [Pull requests](/vusec/trrespass/pulls)
* [Actions](/vusec/trrespass/actions)
* [Projects](/vusec/trrespass/projects)
* [Security](/vusec/trrespass/security)
* [Insights](/vusec/trrespass/pulse)

# vusec/trrespass

    master[Branches](/vusec/trrespass/branches)[Tags](/vusec/trrespass/tags)Go to fileCode
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| Latest commit History[5 Commits](/vusec/trrespass/commits/master/) | | |
| [drama](/vusec/trrespass/tree/master/drama "drama") | | [drama](/vusec/trrespass/tree/master/drama "drama") |  |  |
| [hammersuite](/vusec/trrespass/tree/master/hammersuite "hammersuite") | | [hammersuite](/vusec/trrespass/tree/master/hammersuite "hammersuite") |  |  |
| [py](/vusec/trrespass/tree/master/py "py") | | [py](/vusec/trrespass/tree/master/py "py") |  |  |
| [LICENSE](/vusec/trrespass/blob/master/LICENSE "LICENSE") | | [LICENSE](/vusec/trrespass/blob/master/LICENSE "LICENSE") |  |  |
| [README.md](/vusec/trrespass/blob/master/README.md "README.md") | | [README.md](/vusec/trrespass/blob/master/README.md "README.md") |  |  |
| View all files | | |

## Repository files navigation

* README
* Apache-2.0 license
# TRRespass

This is the repository for the TRRespass Rowhammer fuzzer. Recent DDR4 chips include on-chip TRR mitigations that stop bit flips using standard Rowhammer access patterns such as double-sided, single sided or one-location hammering. TRRespass automatically discovers novel Many-sided Rowhammer variants that can bypass these mitigations and trigger bit flips on the recent systems with DDR4 memory. TRRespass requires the DRAM address mapping functions to work effectively.

Additional information about TRRespass can be found here: <https://www.vusec.net/projects/trrespass/>

The paper that describes more details appears at IEEE Security and Privacy 2020 and can be found here: <https://download.vusec.net/papers/trrespass_sp20.pdf>

### ./drama

Inside the `drama` folder you can find a tool that helps you reverse engineer the DRAM memory mappings used by the memory controller.
Read the README in the folder for more details

### ./hammersuite

Inside the `hammersuite` folder you can find the fuzzer we used.

Again, read the README in the folder for more details

## About

TRRespass

### Resources

[Readme](#readme-ov-file)
### License

[Apache-2.0 license](#Apache-2.0-1-ov-file)

[Activity](/vusec/trrespass/activity)
[Custom properties](/vusec/trrespass/custom-properties)
### Stars

[**123**
stars](/vusec/trrespass/stargazers)
### Watchers

[**29**
watching](/vusec/trrespass/watchers)
### Forks

[**26**
forks](/vusec/trrespass/forks)
[Report repository](/contact/report-content?content_url=https%3A%2F%2Fgithub.com%2Fvusec%2Ftrrespass&report=vusec+%28user%29)

## [Releases](/vusec/trrespass/releases)

No releases published

## [Packages 0](/orgs/vusec/packages?repo_name=trrespass)

No packages published

## [Contributors 2](/vusec/trrespass/graphs/contributors)

## Languages

* [C
  75.4%](/vusec/trrespass/search?l=c)
* [Python
  21.7%](/vusec/trrespass/search?l=python)
* [Makefile
  2.1%](/vusec/trrespass/search?l=makefile)
* [Shell
  0.8%](/vusec/trrespass/search?l=shell)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from twitter.com_1ef84ab5_20250119_120253.html ===



=== Content from twitter.com_5455fc7f_20250119_120254.html ===



=== Content from download.vusec.net_4f35070f_20250119_120249.html ===
TRRespass: Exploiting the Many Sides of
Target Row Refresh

Pietro Frigo∗†

Onur Mutlu§

Emanuele Vannacci∗† Hasan Hassan§ Victor van der Veen¶
Cristiano Giuffrida∗ Herbert Bos∗ Kaveh Razavi∗

∗Vrije Universiteit Amsterdam

§ETH Z¨urich

¶Qualcomm Technologies Inc.

†Equal contribution joint ﬁrst authors

Abstract—After a plethora of high-proﬁle RowHammer at-
tacks, CPU and DRAM vendors scrambled to deliver what
was meant to be the deﬁnitive hardware solution against the
RowHammer problem: Target Row Refresh (TRR). A common
belief among practitioners is that, for the latest generation
of DDR4 systems that are protected by TRR, RowHammer
in reality, very
is no longer an issue in practice. However,
little is known about TRR. How does TRR exactly prevent
RowHammer? Which parts of a system are responsible for
operating the TRR mechanism? Does TRR completely solve the
RowHammer problem or does it have weaknesses?

In this paper, we demystify the inner workings of TRR and
debunk its security guarantees. We show that what is advertised
as a single mitigation mechanism is actually a series of different
solutions coalesced under the umbrella term Target Row Refresh.
We inspect and disclose, via a deep analysis, different existing
TRR solutions and demonstrate that modern implementations
operate entirely inside DRAM chips. Despite the difﬁculties of
analyzing in-DRAM mitigations, we describe novel techniques
for gaining insights into the operation of these mitigation mech-
anisms. These insights allow us to build TRRespass, a scalable
black-box RowHammer fuzzer that we evaluate on 42 recent
DDR4 modules.

TRRespass shows that even the latest generation DDR4 chips
with in-DRAM TRR, immune to all known RowHammer attacks,
are often still vulnerable to new TRR-aware variants of RowHam-
mer that we develop. In particular, TRRespass ﬁnds that, on
present-day DDR4 modules, RowHammer is still possible when
many aggressor rows are used (as many as 19 in some cases),
with a method we generally refer to as Many-sided RowHammer.
Overall, our analysis shows that 13 out of the 42 modules from all
three major DRAM vendors (i.e., Samsung, Micron, and Hynix)
are vulnerable to our TRR-aware RowHammer access patterns,
and thus one can still mount existing state-of-the-art system-level
RowHammer attacks. In addition to DDR4, we also experiment
with LPDDR4(X)1 chips and show that they are susceptible to
RowHammer bit ﬂips too. Our results provide concrete evidence
that the pursuit of better RowHammer mitigations must continue.

I. INTRODUCTION

Is RowHammer a solved problem? The leading DRAM
vendors have already answered this question with a resounding
“yes”, advertising the latest generation DDR4 systems as
RowHammer-free and using Target Row Refresh (TRR) as
the “silver bullet” that eradicates the vulnerability [63], [70].
Unfortunately, very little is known about the actual implemen-
tation or security of TRR on modern systems. Even the major
consumers of DRAM in the industry have to simply take the

DRAM vendors at their word as the vendors do not disclose
the details of the TRR schemes they implement. In this paper,
we question this security by obscurity strategy and analyze the
mechanisms behind TRR to bypass this prevalent mitigation.
Our results are worrisome, showing that RowHammer is not
only still unsolved, but also that the vulnerability is widespread
even in latest off-the-shelf DRAM chips. Moreover, once the
RowHammer mitigation mechanism is turned off,2 we observe
bit ﬂips with as few as 45K DRAM row activations, showing
that DDR4 and LPDDR4(X) chips are more vulnerable to
RowHammer than their DDR3 predecessors, which can tol-
erate much higher row activation counts (e.g., ∼139K [51]).

RowHammer. Within only ﬁve years since its discovery, ex-
ploits based on the RowHammer vulnerability [51] have spread
to almost every type of computing system [71], [72]. Personal
computers [14], [27], [28], [81], [88], cloud servers [23], [33],
[54], [77], [79], [89], [96], and mobile phones [25], [91], [92]
have all fallen victim to attacks with RowHammer bit ﬂips
triggered from native code [12], [23], [27], [33], [77]–[79],
[81], [96], JavaScript in the browser [14], [25], [28], [81]
and even remote clients across the network [66], [89]. From
an academic demonstration,
the RowHammer vulnerability
has evolved into a major security vulnerability for the entire
industry. In response, hardware vendors have scrambled to
address the RowHammer issue.

Target Row Refresh. Reliable solutions against RowHammer
simply do not exist for older hardware and stopgap solutions
such as using ECC and doubling (or even quadrupling) the
refresh rate have proven ineffective [7], [23], [51]. In the early
days of the DDR4 speciﬁcation, DRAM vendors announced
they would deploy the Target Row Refresh (TRR) mitigation
mechanism on newer-generation DDRx systems to eradicate
the RowHammer vulnerability [63], [70]. While reports of
bit ﬂips on DDR4 devices [27], [56], [66] suggest that the
deployment of such mitigation mechanisms may not have been
prompt, it is commonly assumed that TRR technology on re-
cent DDR4 systems has put an end to RowHammer attacks [2],
[3]. Nowadays, the leading DRAM vendors explicitly advertise
RowHammer-free modules [63], [70]. Our initial assessment
conﬁrms that none of the known RowHammer variants produce
bit ﬂips on 42 recent DDR4 modules. However, little is known

1We refer to both LPDDR4 and LPDDR4X chips as LPDDR4(X).
¶Victor contributed to the research on DDR4 modules.

2We turn off the in-DRAM RowHammer mitigation mechanism by dis-

abling REFRESH commands, as we explain in Section V.

about TRR beyond what its name suggests, namely that it
generates extra refreshes for rows targeted by RowHammer.

The many sides of TRR. In this paper, we take a closer look
at the TRR implementations on modern systems. In contrast
to what the literature suggests [66], we show that TRR is
not a single mitigation mechanism but rather a family of
solutions, implemented either in the CPU’s memory controller
or in the DRAM chips themselves. One of the best-known
implementations of TRR-like functionality, Intel’s pTRR [46],
appeared in the memory controllers of Intel CPUs as early as
2014 to protect vulnerable DDR3 modules. Interestingly, while
memory controller-based TRR implementations still exist in
modern DDR4 systems, we show that they are now mostly
dormant. This is presumably because such functionality is
considered superﬂuous now that the DRAM vendors advertise
RowHammer-free modules with in-DRAM TRR, i.e., TRR
implemented entirely inside the DRAM chips [63], [70].

Unfortunately, none of the in-DRAM TRR variants are well
documented. As a result, their security guarantees are buried
deep inside the DRAM chips that embed them. This poses a
major threat to the security of modern systems, if they turn
out to be vulnerable after all.

TRRespass. To compensate for the lack of information, we
investigate the mechanisms behind TRR and show that new
the RowHammer vul-
TRR-aware attacks can still exploit
nerability on modern DDR4 devices. We start our analysis
by investigating TRR variants implemented in the memory
controller and DRAM chips. We inspect memory controller-
based TRR mechanisms using timing side channels to analyze
when the memory controller performs a targeted refresh or
whether it refreshes the entire DRAM at
increased rate.
Inspecting more recent in-DRAM TRR mechanisms is more
challenging since these mechanisms operate transparently to
the memory controller, and thus the rest of the system (e.g.,
targeted refresh may or may not happen during the ﬁxed
tRFC refresh latency). To address this challenge, we use
SoftMC [31], an FPGA-based memory controller. SoftMC
provides us with ﬁne-grained control over the commands sent
to DRAM. Using RowHammer bit ﬂips and a careful selection
of DRAM commands, we gradually reconstruct the different
mitigations deployed on recent DDR4 modules, and uncover
how they track the rows being hammered and how they protect
the victim rows.

Our analysis shows that, while TRR implementations differ
across DRAM vendors, most TRR variations can be by-
passed by what we introduce as Many-sided RowHammer
(i.e., RowHammer with many aggressor rows). Building on
this insight, we present TRRespass to identify TRR-aware
RowHammer access patterns on modern systems. Our fuzzing
strategy generates many-sided RowHammer patterns in an
entirely black-box fashion, without relying on any implemen-
tation details of the memory controller or DRAM chips. We
show that relatively simple many-sided RowHammer patterns
identiﬁed by TRRespass can successfully trigger bit ﬂips on
DDR4 DRAM chips from all three major DRAM vendors,
namely Samsung, Micron, and Hynix (representing over 95%
of the DRAM market [1]), as well as on mobile phones
employing LPDDR4(X) DRAM chips. Overall, our analysis
provides evidence for signiﬁcant weaknesses in state-of-the-

art TRR implementations, showing they can be bypassed
to expose the vulnerable DDR4 substrate to state-of-the-art
system-level RowHammer attacks.

Contributions. We make the following contributions:

• We present the ﬁrst overview of different Target Row
Refresh (TRR) implementations available on modern sys-
tems, which have been publicized as an effective solution
to the RowHammer problem.

• We present TRRespass,

• We analyze the memory-controller-based and in-DRAM
TRR implementations by the leading hardware vendors.
a black-box RowHammer
fuzzer, which can automatically identify TRR-bypassing
RowHammer access patterns on 13 of 42 tested DDR4
modules from all three major DRAM manufacturers as
well as 5 of 13 tested mobile phones.

• We use the RowHammer access patterns that TRRes-
pass identiﬁes on modern TRR-protected DDR4 and
LPDDR4(X) DRAM chips to show how attackers can
use TRR-aware RowHammer access patterns to mount
state-of-the-art RowHammer attacks on these modules.

II. ROWHAMMER ON DDR4: STILL A PROBLEM?
Prior research has characterized [23], [51], [88], [91] and
exploited the RowHammer vulnerability of DRAM [23], [25],
[27], [28], [79], [89], [96]. While there has been systematic
research on the vulnerability on DDR3 systems [51], [88],
relatively little is known about the extent of RowHammer
on recent DDR4 systems. In this section, we ﬁrst provide
the necessary background on DRAM and RowHammer for
understanding the rest of the paper. We refer the reader to
prior work [18]–[21], [29], [30], [50], [51], [57]–[61], [67],
[68], [82]–[85], [97] for a more detailed description of DRAM
organization and operation. Then, we perform a preliminary
analysis on recent DDR4 systems using existing “hammering”
patterns in the literature [27], [51], [88] to investigate the
current status of the RowHammer vulnerability on DDR4.

A. DRAM Organization

Figure 1 depicts the high-level organization of a DRAM-
based main memory subsystem. The CPU communicates with
DRAM through the Memory Controller (from now on also
referred to as MC). The MC is responsible for issuing memory
requests to the corresponding DRAM channel. DRAM chan-
nels operate independently from each other and a single chan-
nel can host multiple memory modules (or DIMMs). DRAM
chips in a DIMM are organized as a single rank or multiple
ranks. The DRAM chips that form a rank operate in lock-
step, simultaneously receiving the same DRAM command but
operating on different data portions. Thus, a rank composed
of several DRAM chips appears as a single large memory to
the system. A DRAM chip contains multiple DRAM banks
that operate in parallel.

Inside a bank. A DRAM bank can be logically seen as a two-
dimensional array of DRAM cells (Figure 2). Cells that share
a wordline are referred to as a DRAM row. The row decoder
selects (i.e., activates) a row to load its data into the row buffer,
where data can be read and modiﬁed. A DRAM cell consists of
two components: (i) a capacitor and (ii) an access transistor.
The capacitor stores a single bit of information as electrical

2

Fig. 1: High-level DRAM organization.

charge. During an access to a cell, the corresponding wordline
enables the access transistor of the cell, which connects the cell
capacitor to the bitline. Thus, to read/write data in a speciﬁc
DRAM row, the memory controller ﬁrst issues an ACTIVATE
command to bring the row’s data into the row buffer. The row
buffer consists of sense ampliﬁers, each connected to a bitline.
Because row activation destroys the data stored in the cell
capacitor, a sense ampliﬁer not only successfully determines
the bit stored in the cell, but also restores the charge back into
the capacitor. After the activated row of cells is fully restored,
the memory controller can issue a PRECHARGE command to
close the row and prepare the bank for activating a different
row.

Fig. 2: DRAM bank organization (logical).

DRAM cell capacitors are not ideal and they gradually lose
their charge over time. Thus, the memory controller needs
to refresh the contents of all cells periodically (usually every
64 ms [40], [44], [67]) to prevent data loss.

B. RowHammer

RowHammer is a well-known DRAM vulnerability that has
been investigated since 2012 [8]–[10], [26], [51]. When a
particular DRAM row is repeatedly activated and precharged
many times (i.e., hammered), electro-magnetic interference
between the hammered row and its neighbor rows can cause
the cell capacitors in the neighbor rows to leak much faster
than under normal operation. Rows that are hammered are
referred to as aggressor rows, whereas their neighbor rows
are referred to as victim rows. Kim et al. [51] are the ﬁrst to
perform a large-scale study of the properties of RowHammer
bit ﬂips on DDR3 modules. They report ∼85% of the tested
modules to be vulnerable to RowHammer. Since one can cause
RowHammer bit ﬂips solely by performing memory accesses,
RowHammer quickly became a popular vector for developing
real-world attacks [5], [11]–[13], [17], [23]–[25], [27], [28],
[39], [66], [76]–[79], [81], [88], [89], [91], [92], [96], [98].

Attacks. Seaborn and Dullien [81] initially demonstrated
RowHammer attacks for compromising the Linux kernel.

Afterwards, other researchers exploited RowHammer to break
cloud isolation [23], [33], [54], [77], [79], [89], [96], “root”
mobile devices [91], [92], take over browsers [14], [25], [28],
and attack server applications over the network [66], [89].
All these attacks demonstrate the severity of the RowHammer
threat and the need to build effective defenses.

Defenses. Various software-based RowHammer defenses ad-
vocate for the detection of the RowHammer patterns [7],
cross-domain [16] (or more general) memory isolation [53],
[89], [92], or software-controlled ECC [23]. Unfortunately,
these defenses are complex, expensive, and/or incomplete.
As a result, they are not deployed in practice. Immediately-
deployable hardware-based defenses, such as doubling (or
even quadrupling) the refresh rate or using existing DRAM
modules with error-correction code (ECC) capability to protect
against RowHammer, are used in the ﬁeld, yet they have been
shown to be insecure [7], [23], [51].

DDR4: Towards a RowHammer-less landscape. Most prior
RowHammer research focuses on DDR3 systems [5], [11]–
[13], [17], [23]–[25], [28], [39], [51], [77]–[79], [81], [88],
[89], [91], [92], [96], [98]. While there are reports of bit ﬂips
on DDR4 chips in prior work [27], [56], [66], these results
are on earlier generations of DDR4. Through communication
with industry, we have conﬁrmation that some early-generation
DDR4 chips did not have the “TRR” mitigation enabled by
default. In order to understand the modern landscape we
test a set of 42 recent DDR4 modules against all standard
hammering patterns: (i) single-sided, which simply activates
two arbitrary (aggressor) rows in the same bank to induce
bit ﬂips in their adjacent victim rows (Figure 3a); (ii) dou-
ble-sided, which uses the same access patterns as single-sided
but the two aggressor rows are chosen to both be adjacent
to a single victim row to amplify the effect of hammering
(Figure 3b); and (iii) one-location, which activates a single
row (Figure 3c) and only applies to systems where the MC
employs a closed-row [35], [52] or adaptive [47] page policy.

(a) Single-sided

(b) Double-sided

(c) One-location

Fig. 3: Standard hammering patterns. The aggressor rows are high-
lighted in red ( ) and victim rows are highlighted in blue ( ).

As we show in Figure 4, our analysis reveals that none
of these patterns manifest any bit ﬂip on the modules we
test, even when using the exact test suites provided by prior
work [27], [51], [88]. Our results suggest that recent DDR4
the best known
chips include effective mitigations against
hammering patterns, matching claims of DRAM vendors [63],
[70]. This raises the important question: Is RowHammer a
solved problem?

3

Chip-KChip-0Bank-0Bank-1Bank-NRankChannelsMemCtrlCPUDIMMsSPDTRRvaluewordlineRowbitlineaddrcellRowBufferRowDecoderRowDecodercapacitoraccesstransistorcapacitoraccesstransistorcapacitoraccesstransistorrefresh operations consume more energy and delay actual data
transfers [51], [67]. As a consequence, manufacturers of newer
CPU generations designed and deployed more efﬁcient and
effective hardware-based RowHammer mitigations [4], [8],
[9], [15], [26], [46]—solutions that would also prevent attacks
on vulnerable DDR3 chips.

As the MC services all incoming memory requests from
CPU cores, it can efﬁciently track the requests and implement
countermeasures in case of a RowHammer attack. Speciﬁcally,
the MC can actively monitor the number of activations to
speciﬁc DRAM rows and then thwart an attack by sending
additional activations to DRAM rows that might be affected by
RowHammer. Intel’s pseudo-TRR [46] (or pTRR) is the most
prominent example of a RowHammer defense that is deployed
in the memory controller. However, while it is widely cited in
the literature [7], [27], [28], [56], [66], [81], [89], [91], very
little is actually known about the pTRR mechanism. In this
section, we aim to verify the existence of pTRR and analyze
different Intel systems to better understand the deployment and
effectiveness of pTRR.

A. TRR-compliant Memory

To protect DRAM from RowHammer using additional tar-
geted refresh operations, the MC must know the maximum
number of ACTIVATEs a row can bear before any bit in its
neighboring rows ﬂips. Since the discovery of RowHammer,
manufacturers typically store this information on the Serial
Presence Detect (SPD) chip [50] of the DRAM module and
refer to it as Maximum Activate Count (MAC). The SPD
is a small read-only memory chip containing information
about the memory module (Figure 1). The CPU reads the
the necessary parameters
SPD at boot
time to gather all
required to initialize the memory controller,
including the
MAC ﬁeld. DRAM modules disclosing this ﬁeld have been
available approximately since 2014 and we denote them as
TRR-compliant. We discuss further details in Appendix A.

The JEDEC standard speciﬁes three possible conﬁgurations
for the MAC value: (i) unlimited, if the DRAM module claims
to be RowHammer-free; (ii) untested, if the DRAM module
was not inspected after production; or (iii) a discrete value
that describes the actual number of activations the DRAM
the MAC of
module can bear (e.g., 300K). We read out
the 42 DDR4 modules we test. We ﬁnd that, regardless of
the DRAM manufacturer, most of these modules claim to
be RowHammer-free by reporting an unlimited MAC value
(Table II).

B. Intel pTRR Explained

We now take a closer look at the only publicly adver-
tised MC-based solution for Intel CPUs: pseudo-TRR (or
pTRR) [46]. Introduced in the Ivy Bridge EP server fam-
ily [46], pTRR refreshes victim rows when the number of
row activations issued to the DRAM exceeds the MAC value—
according to Intel’s public documentation [46]. Unfortunately,
this solution is not applicable to non-TRR-compliant modules
(i.e., those without a MAC value or MAC set to untested). As a
result, when such modules are employed, the system defaults
to double refresh mode.

Observing pTRR. We analyze the only system ofﬁcially
reported to support pTRR: Xeon E5-2620 v2, with DDR3

Fig. 4: Bit ﬂips vs. manufacturing date.3 Analysis of standard
hammering patterns [51], [81], [88] on new DDR4 modules. We
compare our results with the dataset of Tatar et al. [88] on DDR3
modules (shown in the left part of the chart).

III. OVERVIEW
We start our analysis by showing that TRR is not a single
RowHammer mitigation mechanism. Speciﬁcally, we demon-
strate that TRR is an umbrella term for different solutions
at different levels of the hardware stack. Next, we analyze
what
is arguably the best-known TRR implementation in
memory controllers, Intel pTRR [46], and show that it is not
deployed in any consumer system we tested (Section IV).
Since our results indicate that recent systems do not use
TRR implemented at the memory controller level, we analyze
TRR implementations in the DRAM chip. We examine in
detail the effectiveness of the TRR mitigations that different
manufacturers employ inside their chips. In particular, we
show that once we reach a solid understanding of the behavior
of the mitigation mechanism and build targeted access patterns
accordingly, existing in-DRAM RowHammer mitigations be-
come ineffective and one can still trigger RowHammer bit ﬂips
under standard conditions (Section V).

We observe that 1) different DRAM chips across vendors
and generations can employ different TRR implementations
and 2) the distribution of DRAM cells that are vulnerable to
RowHammer is different for every chip. Since extensive inves-
tigation of every possible memory module is not practical, we
generalize the insights gained from our investigation to build
TRRespass: a black-box fuzzer for “TRR-aware” RowHammer
analysis and exploitation (Section VI). We show how TRRes-
pass can construct a plethora of new and effective RowHam-
mer patterns on multiple TRR-protected DRAM modules.
We analyze these patterns, which we collectively refer to
as many-sided RowHammer (Section VII), and discuss the
implications of TRR-aware hammering exploitation, showing
how an attacker armed with TRRespass can mount successful
state-of-the-art RowHammer attacks on recent DDR4 systems
(Section VIII).

IV. ANALYZING THE MEMORY CONTROLLER
After the initial discovery of RowHammer [8]–[10], [26],
[51], BIOS vendors ﬁrst responded to the vulnerability by
doubling the DRAM refresh rate [6], [7], [64]. However,
increasing the refresh rate incurs high overhead as more

3Following prior work [88], we approximate the manufacturing date with
the purchase date when the former is unavailable (Table II shows the modules
for which we applied such approximation).

4

Single20152016201720182019ManufacturingDateDDR3DDR40100101102103104105106107#BitFlipsDoubleOnelocationmemory [46]. We disable write-protection [41], [42] on the
SPD of a DDR3 module and we perform the following two
experiments.

1(cid:13) We overwrite the MAC value setting to two conﬁg-
urations: untested, simulating a non-TRR-compliant DRAM
module, and unlimited. As mentioned above, when non-TRR-
compliant memory is employed, the system should resort to
double refresh rate, making it possible to detect the mitigation
via frequency analysis of the access latency of uncached
memory reads [69]. Indeed, we can observe that with MAC
value set to untested, the system resorts to double refresh
(Figure 5).

Fig. 5: Intel pTRR - Frequency of REFRESH commands. Uncached
memory access latency with MAC value set to Unlimited and Untested
on Xeon E5-2620 v2. The peaks reveal the delay introduced by the
REFRESH command. We observe twice as many peaks when the MAC
value is set to Untested.

2(cid:13) We overwrite the MAC value to different discrete values,
expecting to observe a difference in the number of bit ﬂips.
In the leftmost stack of Figure 6, we show the result of this
experiment when hammering the same chunk of memory with
MAC value set to 400K or to unlimited. We observe that the
number of bit ﬂips drastically decreases when pTRR is enabled
(i.e., MAC value set to 400K). Additionally (not shown in
Figure 6), we discover that when setting the MAC value to the
minimum value deﬁned in the DDR3 speciﬁcation [41] (i.e.,
200K), the system treats the module as a non-TRR-compliant
module; that is, it enables double refresh. We do not analyze
the effectiveness of pTRR in mitigating RowHammerbit ﬂips
in this paper. Lipp et al. [66] report bit ﬂips on a pTRR-
enabled system, and operating at increased refresh rate (i.e.,
double refresh rate) is known to be ineffective [7], [23], [51]
at protecting against RowHammer.

Fig. 6: Intel pTRR - Bit ﬂips observed with different MAC values.
Frequency of observed bit ﬂips for different MAC conﬁgurations.
Comparison between a system employing pTRR (Xeon E5-2620 v2)
and a system with no MC-based RowHammer mitigation (Core i7-
8700K).

pTRR has limited deployment. We run the two experiments
for analyzing pTRR on 6 other Intel CPUs from different
architecture families that are descendants of Ivy Bridge—both
server and consumer lines. Surprisingly, the ﬁrst experiment
1(cid:13) shows that, when the MAC value is set to untested, the

5

memory controller of each of these 6 CPUs still refreshes
the DRAM with the default (not double) refresh rate. This
observation shows that no RowHammer mitigation is present
at the memory controller level in these CPUs. We corroborate
2(cid:13)
this hypothesis by carrying out the second experiment
where we measure the number of bit ﬂips as we vary the
MAC value. We use the new RowHammer patterns we present
in Section VI for the CPUs that support DDR4. In contrast
to Xeon E5-2620 v2 server-line CPU, which is reported to
support pTRR [46], the second experiment on consumer-line
CPUs does not identify a different number of bit ﬂips for
different MAC values. In the rightmost stack of Figure 6,
we show the results for the Intel Core i7-8700K consumer-
line CPU as an example to illustrate the difference between
any of these consumer systems and a pTRR-enabled system.
This experiment conﬁrms that pTRR is in fact not present
in customer-line CPUs that we test. We list the deployment
of MC-based RowHammer mitigations in both server- and
consumer-line CPUs in Table I.

TABLE I: Memory controller defenses. Defenses detected in our
experiments on Intel CPUs starting from the Ivy Bridge family.

CPU

Family

Year

DRAM
generation

Defense

Server Line
Xeon E5-2620 v4
Xeon E5-2620 v2
Xeon E3-1270 v3

Consumer Line
Core i9-9900K
Core i7-8700K
Core i7-7700K
Core i7-5775C

Broadwell
Ivy Bridge EP
Haswell

2016
2013
2013

Coffee Lake R 2018
2017
2017
2015

Coffee Lake
Kaby Lake
Broadwell

DDR4
DDR3
DDR3

DDR4
DDR4
DDR4
DDR3

REF×2
pTRR

C. Discussion

Our experiments show that the memory controller-based
RowHammer mitigations are deployed only in speciﬁc families
of Intel processors. While we ﬁnd that pTRR and other
mitigations (e.g., double refresh) are used in high-end Xeon
servers, our results show that neither DDR3 nor DDR4 con-
sumer systems appear to enable any MC-based mitigation. In
Figure 7, we reconstruct a timeline of RowHammer mitiga-
tions on Intel platforms based on the results of our analysis.
With both DDR3 and DDR4, only server platforms appear to
beneﬁt from mitigations inside the memory controller while
consumer platforms do not. Based on earlier reports of bit
ﬂips using standard RowHammer patterns on consumer DDR4
memory [27], [56], [66], we can speculate that in-DRAM
mitigations are widely-deployed only since 2016 (i.e., the ear-
liest manufacturing date of a DRAM module with MAC set to
unlimited among all modules that we list in Table II). In other
words, DRAM manufacturers’ promises of a RowHammer-
less future [63], [70] hinge entirely on the security of their
undocumented in-DRAM TRR mitigations. Unfortunately, as
we show in the next sections, analyzing and understanding
such mitigations can reveal signiﬁcant weaknesses that can be
exploited to mount RowHammer attacks on modern DDR4
DRAM chips.

0.07.815.623.431.239.0Time(µs)100200300400REFx2Latency(ns)10-110-210-3100XeonE5-2620v2MAC=400KBitFlips(freq.)MAC=UnlimitedCorei7-8700Kthe sampler remains the same: track which rows are being
hammered in order to identify their target victim rows.

Our ﬁrst hypothesis is that the sampler has a limited size
s. In other words, there is a maximum number of aggressor
rows that the sampler can track. Phrased differently, the TRR
mitigation can protect only a limited number of victim rows.

The Inhibitor. Once the sampler is aware of the aggressor
rows, the mitigation must thwart the hammering process. As
the name Target Row Refresh suggests (and different designs
conﬁrm [34], [74], [95]), an effective solution consists of
generating extra refreshes for the victim rows. Nonetheless,
more sophisticated designs incorporate the possibility of row
remapping [38], [48], [67].

Our second hypothesis is that the inhibitor acts at refresh
time—based on the literature [34], [74], [95]. Refresh oper-
ation is the responsibility of the memory controller, which
issues one REFRESH command every 7.8 µs (tREFI). Since
DDR is a synchronous protocol [40], [44], the memory con-
troller must remain idle for a ﬁxed period of time (tRFC)
before it can send subsequent commands to the bank. Any,
possibly additional, targeted refreshes must still respect these
timing constraints for the DRAM module to be compliant with
the DDRx standard. That is, only a limited number of target
rows can be refreshed.

Goals. Based on the aforementioned assumptions we deﬁne
the following questions that we want to answer.

• What is the size of the sampler?
• How does the sampler track aggressor rows? For example,
does it record row activation commands at a constant
frequency or based on a function of time?

• How does the inhibitor work? Can it prevent bit ﬂips?
In the following, we try to answer these questions by

analyzing TRR via two different case studies.

B. Case I: Module C12

Our ﬁrst study examines a module from manufacturer C. We
ﬁrst ﬁnd the minimum number of activations that are required
to trigger bit ﬂips on this module. To do so, we disable refresh,
which prevents TRR from performing refresh on victim rows,
and perform a double-sided RowHammer sweep of a single
DRAM bank. The results, plotted in Figure 8, show that we can
trigger bit ﬂips with as few as 50K activations. This indicates
that DRAM cells in DDR4 are generally considerably weaker
compared to DRAM cells in the predecessor DDR3 standard,
which requires at least ∼139K activations [51]. Nonetheless,
for future experiments reported in this paper we use a higher
activation count so that we can observe more bit ﬂips and draw
stronger conclusions.

Mastering refresh. Knowing the physical
limitations of
the DRAM module, we now reintroduce the REFRESH
command. We decide to batch refresh operations together
with the goal of understanding the relationship between them
and the effectiveness of the TRR mitigation. We perform a
series of hammers (i.e., activations of aggressors) followed
by r refreshes for ten rounds—we carry out 8K hammers per
round. In Figure 9, we report the results of this experiment

Fig. 7: TRR Timeline. Timeline of deployment of TRR as RowHam-
mer mitigation. MC-based mitigations are deployed in both DDR3
and DDR4 server systems since 2013 [46]. In contrast, in-DRAM
mitigations appear with DDR4 for both consumer and server sys-
tems [63], [70].

V. INSIDE THE DRAM CHIPS
We dig deeper to understand the RowHammer protection
that the DRAM vendors implement inside recent DRAM chips,
which are advertised as RowHammer-free [63], [70]. So far,
the DRAM vendors have not publicly shared the details of
the exact RowHammer protection mechanisms they implement
in the form of TRR. Therefore, we experiment with and
analyze real DRAM chips to shed light on the inner workings
of the TRR mechanisms implemented by different vendors
in different DRAM chip generations. Performing such an
analysis using a general-purpose CPU is extremely challenging
because the memory controller provides a very high-level
interface to the CPU (i.e., the programmer can interface with
the DRAM using only load/store instructions). However, to
perform accurate experiments, we need ﬁne-grained control
over the low-level commands sent to the DRAM. Therefore,
we leverage an open-source FPGA-based memory controller,
SoftMC [31], [80], which enables the programmer to issue
arbitrary DRAM commands in a cycle-accurate manner. We
extend SoftMC to support experimental studies on DDR4
modules. We ﬁrst discuss our hypotheses for potential ways of
implementing in-DRAM TRR. Then, we present case studies
for two DRAM modules from different manufacturers. Our
results show that different manufacturers implement vastly
different TRR mitigations.

A. Building Blocks and Hypotheses

While literature indicates that each manufacturer may im-
plement its own variant of TRR [34], [38], [45], [49], [65],
[74], [75], [95], we abstract the implementation details and
unravel the two main requirements for supporting TRR: the
sampler and the inhibitor. We deﬁne these requirements as
building blocks and present a series of hypotheses that we
verify in the next sections.

The Sampler. A sampling mechanism is required to track
which aggressor rows are being hammered. Solutions vary
from basic frequency-based sampling to more complex
designs that
track activations per row. In frequency-based
implementations, sampling occurs at ﬁxed periods in time
within a refresh interval [34], [74], [95]. For example, a
TRR implementation may determine aggressor
rows by
monitoring every 3rd and 4th access after a REFRESH. The
more complex designs that track accesses on a per-row basis,
keep activation counters for a number of rows [45], [65]
and select aggressors based on their individual activation
counts. Despite differences in its implementation, the goal of

6

'13'12'14'15'16'19DDR4in-DRAM(S,C)DDR3in-MC(S)pTRRin-MC(S)S=ServerC=ConsumerFig. 8: Bit ﬂips vs. number of activations. Module C12: We can
observe bit ﬂips with as few as 25K activations per aggressor row
(i.e., 50K activations in total due to double-sided hammering).

for RowHammer conﬁgurations with different numbers of
aggressors. Let us ﬁrst consider only the third column of the
plot: double-sided RowHammer. We observe that adding a
single refresh causes the number of bit ﬂips to drop from
2,866 to only one (for r = 1), and then to zero (for any
r ≥ 2). This experiment provides an insightful result: since
sending multiple REFRESH commands varies the number
of bit ﬂips, the TRR mitigation must act on every refresh
command.

Observation 1: The TRR mitigation acts (i.e., carries out a
targeted refresh) on every refresh command.

Next, we take a closer look at the sampler size s to ﬁnd
how many rows the mitigation can handle. We increase the
number of aggressors n while keeping the number of ACTs
per aggressor row constant. For every additional aggressor
row, we have an additional victim row. For example, with
3 aggressor rows,
the hammering conﬁguration looks like
VAVAVAV where V stands for a victim row and A stands for
an aggressor row. The fourth column in Figure 9 shows the
behavior when hammering three aggressors (n = 3). Here we
observe something different: the number of bit ﬂips decreases
signiﬁcantly when introducing up to two refreshes. However,

it plateaus for r ≥ 3 without going down to zero. Notice that
when hammering both 2 and 3 rows, the plateaus happen
when r = n. This suggests that the TRR mitigation samples
more than one aggressor within a refresh interval while it can
refresh only one victim per refresh operation. The DRAM can
refresh only one of the victim rows likely as a consequence of
the tight timing constraints imposed by the tRFC parameter.
Moreover, we can deduce from the remaining non-zero bit
ﬂips that the sampler is likely to discard the aggressor row
from its table once one of its victims has been refreshed.
We can recover the size of the sampler by performing the
for different numbers of aggressors n.
same experiment
While increasing n, we search for the scenario where the
number of bit ﬂips stabilizes for r < n. When this happens,
we can conclude that we have overﬂowed the sampler. We
show the results of this experiment for different values of n
in Figure 9. As speculated, we see the number of bit ﬂips
leveling off (i.e., remaining constant on the y-axis) for r ≥ 4,
revealing the size of the sampler to be s = 4: the sampler in
this module can track only 4 aggressor rows.

Observation 2: The mitigation can sample more than one
aggressor per refresh interval.
Observation 3: The mitigation can refresh only a single
victim within a refresh operation (i.e., time tRFC).
Observation 4: Sweeping the number of refresh operations
and aggressor rows while hammering reveals the sampler
size.

Based on these observations, we conclude that hammering
more than 4 rows should circumvent
the mitigation. We
conﬁrm this by running a test on our SoftMC FPGA infras-
tructure [31] with standard conditions (i.e., tREFI = 7.8 µs).
Indeed, Figure 10 shows that we overwhelm the mitigation
by hammering 5 rows. Figure 10 provides another insight:
it shows that for every number of aggressors >5, the num-
ber of bit ﬂips decreases drastically compared to 5-sided
RowHammer—suggesting that the sampler selects rows in a
speciﬁc fashion. While we tried to understand this behavior
of the sampler, the lack of visibility inside the DRAM chip
made it challenging. Regardless, this additional information is
not necessary given that hammering 5 aggressors in standard
conditions already bypasses the in-DRAM mitigation.

Fig. 9: Refreshes vs. Bit Flips. Module C12: Number of bit ﬂips
detected when sending r refresh commands to the module. We report
this for different number of aggressor rows (n). For example, when
hammering 5 rows, followed by sending 2 refreshes, we ﬁnd 1,710
bit ﬂips. This ﬁgure shows that the number of bit ﬂips stabilizes for
r ≥ 4, implying that the size of the sampler may be 4.

Fig. 10: Bit ﬂips vs. number of aggressor rows. Module C12:
Number of bit ﬂips in bank 0 as we vary the number of aggressor
rows. Using SoftMC, we refresh DRAM with standard tREFI and
run the tests until each aggressor rows is hammered 500K times.

7

5K10K15K20K25K26K27K28K29K30K35K40K45K50K#ACTsperaggressorrow110100#BitFlips#Refreshesperround#AggressorRows#BitFlips0123456789012345678500001000015000200002500012345678910111213141516#Aggressor rows050100150#Bit FlipsFig. 11: Bit ﬂips vs. number of aggressor rows. Module A15:
Number of bit ﬂips in bank 0 as we vary the number of aggressor
rows. Using SoftMC, we refresh DRAM with standard tREFI and
run the tests until each aggressor rows is hammered 500K times.

C. Case II: Module A15

To provide an understanding of the different ﬂavors of in-
DRAM TRR, we further study the behavior of a memory
module from a different manufacturer: A15. We quickly test
and conﬁrm that the mitigation acts at every refresh command,
corroborating the observation made in the previous case study.
We then move to analyzing the relationship between the
number of bit ﬂips and the number of aggressors n, with the
default refresh rate, depicted in Figure 11. We ﬁnd that we
can reliably ﬂip bits for n ≥ 7, indicating a sampler of size 6.

Double-sided RowHammer resurrected. Although we now
already bypass the mitigation, we take this one step further
and try to analyze the sampler to see if we can revive the
more efﬁcient double-sided RowHammer attack. Our approach
consists of ﬁnding the minimal set of dummy rows that allows
us to trick the mitigation mechanism into refreshing all other
neighbors of the hammered rows but our victim. For this, we
focus on a single row that we know to be susceptible to bit ﬂips
and for which we ﬁnd in advance the threshold of hammers
required to observe bit ﬂips. Based on this threshold, we carry
out successive experiments while modifying two parameters:
(i) the distribution of activations across aggressor and dummy
rows and (ii) the number of dummies starting from 6 (i.e., the
supposed size of the sampler). To our surprise, regardless of
the conﬁguration, we could not detect any bit ﬂip.

Investigating further, we discover two more parameters that

were previously unaccounted for:

DRAM command order dependency. The sampler may act at
speciﬁc DRAM commands issued within a refresh interval
and thus it may not necessarily sample based only on
frequency. In the case of module A15, the sampler seems
to record the ﬁrst α activations after a refresh command—
where α ≤ 6.

Address dependency.
In module A15, we observe a
dependency between the aggressor-row address and the
is, when hammering two
dummy rows’ addresses. That
aggressor rows, we detect more bit ﬂips when we pick
particular dummy rows compared to picking random
dummy rows. This suggests that the design of the sampler
involves optimizations to reduce the storage cost of tracking
row activations such that multiple aggressor rows’ addresses
may conﬂict.

Observation 5: The sampler records row activations at
speciﬁc commands and likely at speciﬁc ordering of
commands (i.e., it performs command-order-based sam-
pling).
Observation 6: The sampling mechanism is affected by the
addresses of aggressor rows (i.e., sampling is row-address-
dependent).

D. Running on the CPU: Module A15

While we observe a considerable number of bit ﬂips when
we use the (optimal) activation pattern discovered by SoftMC,
a custom FPGA memory controller does not represent a
widespread threat model. As a consequence, we want to check
if we can reproduce the same access pattern when running on
commodity hardware, such as a regular desktop computer.

During the analysis process, we ﬁnd the mitigation of
the A15 memory module to be command order and address
dependent. This represents a great challenge when trying to
reproduce access patterns that cause bit ﬂips from the CPU.
In fact, in order to fool the mitigation, we need to carry out a
speciﬁc series of activations right after a REFRESH command
to keep the inhibitor busy with another set of rows than the
intended victim row. This means we need to synchronize our
access pattern with the REFRESH command. Even though
we can detect refresh operations (Section IV), synchronizing
our access pattern with them is much more difﬁcult. We
re-implement the access patterns discovered in the analysis
process, which we explain in Section V-C, to run on the CPU.
However, we observe much fewer bit ﬂips compared to what
we obtain with SoftMC, suggesting we may not be able to
perfectly synchronize the hammering pattern with the refresh
operations using a CPU. This is likely due to the fact that
the memory controller applies various optimizations that can
reorder memory requests and refresh commands.

E. Observations

Our experiments in Section V-D show the difﬁculty of
reproducing our FPGA results—those obtained in a simpliﬁed,
controlled environment—on a modern CPU. This advocates
for a better solution for ﬁnding effective access patterns that
trigger bit ﬂips on TRR-protected DDR4 chips. In the next
section, we introduce TRRespass, a black-box RowHammer
test suite that generates effective access patterns to bypass in-
DRAM TRR solutions.

TRRespass is inspired by the insights that we obtained using
our analysis of TRR-protected DDR4 chips in this section.
More speciﬁcally, we take advantage of the following insights:

1. The sampler can track a limited number of aggressor
rows. Thus, we may need to overﬂow the sampler’s ag-
gressor rows table in order to bypass the TRR mitigation.
2. The sampler may sample activations at speciﬁc com-

mands, at a speciﬁc frequency, or both.

3. The sampler design may be row address dependent.
Therefore, some rows may be easier to hammer than
others and the same set of rows activated in different
order may yield completely different results.

4. The cells in DDR4 chips are much more RowHammer-
prone than those on DDR3 [51], requiring fewer activa-
tions to trigger bit ﬂips.

8

12345678910111213141516#Aggressorrows02K4K6K#BitFlipsIn the next section, we describe how we use these observa-
tions to build a (guided) black-box fuzzer that can cause bit
ﬂips on TRR-protected DDR4 modules.

VI. TRRespass: A TRR-AWARE ROWFUZZER

To convert the knowledge that we gathered from our analy-
sis process on the FPGA-based SoftMC platform into practical
attacks that we can launch from regular software on a CPU, we
developed a guided black-box fuzzer for RowHammer called
TRRespass. When searching for usable access patterns, a CPU-
based fuzzer has two main advantages over an FPGA-based
approach: (i) it allows an attacker to completely ignore the
memory controller (and the optimizations it implements), and
(ii) it provides a scalable approach to testing for RowHammer
bit ﬂips. Indeed, since different manufacturers deploy very
different TRR solutions as we show in Section V, trying to
obtain a detailed understanding of the full behavior of every
TRR-protected memory module is not practical. Even so, we
will demonstrate that these details in most cases do not get
in the way of ﬁnding effective patterns: TRRespass was able
to automatically ﬁnd access patterns that trigger bit ﬂips on
modules we did not analyze, and even on mobile platforms
using LPDDR4(X) chips—albeit in a simpliﬁed way.

A. Design

Based on the observations in Section V, TRRespass’ fuzzing
strategy is based on two parameters: Cardinality and Location.

Cardinality. Cardinality represents the number of aggressor
rows hammered. We show in Section V-B that some modules
require a large number of aggressor rows to overﬂow the
sampler and induce bit ﬂips. For instance, Figure 11 indicates
that we need at least 7 rows to observe bit ﬂips in module
A15. On the other hand, increasing the cardinality too much
is counterproductive. In particular, a DRAM module cannot
carry out more than a certain number of activations within the
64 ms interval between two refreshes of the same row. The
maximum number of row activations that can be performed
within 64 ms mainly depends on the row cycle time (tRC) that
deﬁnes the number of clock cycles between two ACTIVATE
commands to the same bank. In most modules tRC ≈ 45 ns. It
follows that the maximum number of activations that we can
perform within a 64ms interval is 1.4×106 (64 ms÷45 ns). If
we tune the fuzzer to hammer each aggressor row at least 50K
times (see Section V-B), the upper limit for the cardinality is
28 rows.

Location. Based on the results of Section V-C, we know
that the sampler may have dependence on row addresses.
Thus, we want to randomize the location of the aggressors
to maximize the probability of bypassing address-dependent
TRR mitigations. Moreover, by picking the access pattern
randomly, we implicitly bypass any feature of the sampler
in the time domain. That is, regardless of the design of the
sampler (command-order-based or frequency-based), choosing
random values for the distances between the aggressors also
randomizes the aggressors’ relative positions in the access
pattern. Given a set of aggressors, we choose to activate them
in a round-robin fashion since our experiments show that other
strategies do not bring beneﬁts in terms of the number of bit
ﬂips.

Fuzzing strategy. TRRespass evaluates randomly-generated
access patterns based on the number of unique bit ﬂips. It
generates the patterns by randomizing the cardinality and
location parameters. If a bank contains n rows, evaluating the
combinations of all n rows taking k at a time (k < n) would be
impractical as n is in the order of tens of thousands in modern
DRAMs. To obtain results within a reasonable time frame,
the fuzzer therefore allocates a smaller chunk of memory,
spanning a subset of rows across different banks, and builds
RowHammer access patterns that respect the geometry of the
memory conﬁguration [76]. The number of patterns that the
fuzzer can test in a given time frame is determined by the
number of hammering rounds (i.e., activations ÷ cardinality).
We pick this value such that we generate activations that cover
more than 3 × refresh period. This conﬁguration makes sure
that the victim rows are hammered for at least an entire 64 ms
interval before their refresh.

B. TRRespass-ing over DDR4

We evaluate our fuzzer and all other experiments on an Intel
Core i7-7700K, mounted on an ASUS STRIX Z270G moth-
erboard. We acquire a set of 42 memory modules produced
by the three leading DRAM manufacturers (currently holding
around 95% of the market [1]). As shown in Table II, the set
consists of 16 modules from vendor A, 12 from B, and 14
from C. We tested all the memory modules singularly to draw
conclusions about the individual chips. We ran TRRespass for
more than 6 hours on each module, scanning a memory chunk
of 128 adjacent rows from each bank. We now describe the
results obtained through TRRespass’ black-box analysis.

Many-sided RowHammer. In one of our initial tests, TR-
Respass assembled a very simple and elegant access pattern
that turned out to be effective on most B modules: assisted
double-sided. That is, a double-sided pattern with a “sidekick”
row. As shown in Figure 12a, this pattern hammers rows
x − 1, x + 1, similarly to double-sided RowHammer, plus an
extra one (x + n, where n > 2).

(a) Assisted double-sided

(b) 4-sided

Fig. 12: Hammering patterns discovered by TRRespass. Aggressor
rows are in red ( ) and victim rows are in blue ( ).

The analysis on all the 42 DRAM modules then allowed
us to generalize the assisted double-sided access pattern to
a broader class of access patterns which we call Many-
sided RowHammer. Our results show that an attacker can
beneﬁt from sophisticated hammering patterns that exploit
repeated accesses to many aggressor rows. We now refer to the
discovered patterns using the nomenclature n-sided where n
is the cardinality of the pattern. For instance, assisted double-
sided which is effective on B modules (Figure 12a), falls
under the category of 3-sided RowHammer. Note that while we
omit the location of the aggressors from this discussion, this

9

TABLE II: TRRespass results. We report the number of patterns found and bit ﬂips detected for the 42 DRAM modules in our set.

Module

A0,1,2,3
A4
A5
A6,7
A8
A9
A10
A11
A12,13
A14
A15

‡

B0
B1
B2
B3
B4,5
B6,7
(cid:5)
B8
B9
B10,11

(cid:5)

C0,1
C2,3
C4,5
C6,7
C8
C9
C10,11
‡
C12
C13

‡

Date
(yy-ww)

Freq.
(MHz)

Size
(GB)

Organization

Ranks Banks Pins

MAC

Found
Patterns

Best Pattern

Corruptions

Total

1 → 0

0 → 1

Double
Refresh

16-37
16-51
18-51
18-15
17-09
17-31
19-02
19-02
18-50
19-08†
17-08

18-11
18-11
18-49
19-08†
19-08†
19-08†
19-08†
19-08†
16-13†

18-46
19-08†
19-08†
19-08†
19-08†
18-47
19-04
15-01†
18-49

2132
2132
2400
2666
2400
2400
2400
2400
2666
3200
2132

2666
2666
3000
3000
2666
2400
2400
2400
2132

2666
2800
3000
3000
3200
2666
2933
2132
2132

4
4
4
4
8
8
16
16
8
16
4

16
16
16
8
8
4
8
8
8

16
4
8
16
16
16
8
4
4

1
1
1
1
1
1
2
2
1
2
1

2
2
2
1
2
1
1
1
2

2
1
1
2
2
2
1
1
1

16
16
8
8
16
16
16
16
16
16
16

16
16
16
16
16
16
16
16
16

16
16
16
16
16
16
16
16
16

×8
×8
×16
×16
×8
×8
×8
×8
×8
×8
×8

×8
×8
×8
×8
×8
×8
×8
×8
×8

×8
×8
×8
×8
×8
×8
×8
×8
×8

UL
UL
UL
UL
UL
UL
UL
UL
UL
UL
UL

UL
UL
UL
UL
UL
UL
UL
UL
UL

UL
UL
UL
UL
UL
UL
UL
UT
UT

4

9-sided

7956

4008

3948

33
33
488
523

120
2

2
2
2

2

19-sided
19-sided
10-sided
10-sided

20808
24854
11342
12830

10289
12580
1809
1682

10519
12274
11533
11148

(cid:88)
(cid:88)

14-sided
9-sided

32723
22397

16490
12351

16233
10046

3-sided
3-sided
3-sided

17
22
5

10
16
2

7
6
3

3-sided

12

12

(cid:88)

25
3

10-sided
9-sided

190037
694

63904
239

126133
455

(cid:88)

† The module does not report manufacturing date. Therefore, we report purchase date as an approximation.
‡ Analyzed using the FPGA-based SoftMC.
(cid:5) The system runs with double refresh frequency in standard conditions. We conﬁgured the refresh interval to be 64 ms in the BIOS settings.

UL = Unlimited
UT = Untested

parameter in some cases does play a role in the effectiveness
of the pattern and we further discuss it in Appendix B.

Results. TRRespass discovered effective access patterns for
13 of the 42 TRR-protected memory modules in our set.
Table II reports the results for the number of access patterns
identiﬁed and the structure of the most effective pattern. One
interesting insight we gain from our analysis is that there is
not a single effective access pattern per module. In fact, we
can see that all the modules where TRRespass induces bit ﬂips
are vulnerable to at least two different access patterns. On B
modules, we could identify access patterns on 4 out of the
12 modules we analyzed, and always with simple 4-sided and
3-sided patterns as presented in Figure 12. On the other hand,
none of these patterns appear to work on the other vendors’
chips. For example, in Figure 13, we show the number of
aggressor rows required to trigger bit ﬂips on module A10.
We can see that no bit ﬂip can be triggered with fewer than
8 aggressor rows. TRRespass successfully triggers bit ﬂips on
7 of 16 A modules, with several very different patterns. A4
and A15 are mainly vulnerable to the 9-sided variant, A10 and
A11 to different variants of the 10-sided pattern, and A8 and

A9 to a 19-sided pattern. On C modules, TRRespass discovers
effective RowHammer patterns on only 2 of 14 modules. We
observe that C12 and C13 are vulnerable to 9-sided and 10-
sided hammering patterns.4

A scalable framework. The results of TRRespass on module
A15 demonstrate how a black-box approach can be extremely
beneﬁcial. In Section V, we describe how complex it can be to
reproduce the optimal access pattern discovered using SoftMC
on a CPU system. In contrast, TRRespass discovers two very
successful access patterns that generate a signiﬁcant number
of bit ﬂips automatically.

4While TRRespass identiﬁes effective RowHammer access patterns only
on 13 out of 42 modules, this does not mean that the other modules are
immune to RowHammer. Similarly, these results do not necessarily show that
that memory modules from a speciﬁc vendor are more or less vulnerable
than modules from other vendors. Similar to regular software fuzzers, it may
simply be a matter of time and better strategies to ﬁnd access patterns that
lead to bit ﬂips. Our testing is also not exhaustive due to limited testing time
and resources.

10

TABLE III: LPDDR4(X) results. Mobile phones tested against
TRRespass on ARMv8 sorted by production date. We found bit ﬂip
inducing RowHammer patterns on 5 out of 13mobile phones.

Mobile
Phone

Google Pixel
Google Pixel 2
Samsung
G960F/DS
Huawei P20 DS
Sony XZ3
HTC U12+
LG G7 ThinQ
Google Pixel 3
Google Pixel 4
OnePlus 7
Samsung
G970F/DS
Huawei P30 DS
Xiaomi Redmi
Note 8 Pro

Year

SoC

2016 MSM8996
2017 MSM8998

2018

Exynos
9810

2018 Kirin 970
SDM845
2018
SDM845
2018
SDM845
2018
SDM845
2018
SM8150
2019
SM8150
2019
Exynos
9820

2019

2019 Kirin 980

2019

Helio
G90T

†

LPDDR4 (not LPDDR4X)

Memory
(GB)

Found
Patterns

(cid:88)

(cid:88)
(cid:88)

(cid:88)

(cid:88)

4†
4

4

4
4
6
4†
4
6
8

6

6

6

then examine the memory for RowHammer bit ﬂips in both
true cells and anti cells [51], [68]. In other words, we look
for both 1 → 0 and 0 → 1 bit ﬂips. We show the results for
all the 42 modules in Table II. We now provide a detailed
explanation of these results by discussing them separately for
each DRAM vendor.

Vendor A. In Section VI, we show TRRespass can bypass
how mitigations from manufacturer A. We can recover
multiple effective access patterns for 7 of the 16 modules
in our experiments. In Table II, we provide the number
of bit ﬂips that we observe on the vulnerable A modules.
The results are worrisome: we ﬁnd more than 16K bit ﬂips
on average across the 7 vulnerable modules. In addition
to the large number of bit ﬂips, we also observe that the
bit ﬂips occur with signiﬁcantly fewer row activations on
vendor A’s DDR4 modules compared to previous generation
DDR3 DRAM devices. For example, on A8 and A9, we can
effectively perform 19-sided RowHammer with as few as
∼45K row activations to each of the effective aggressor rows
(i.e., the aggressor rows adjacent to the target victim row(s))
within the 64ms refresh period. In contrast, Kim et al. [51]
show that bit ﬂips occur with ∼139K or more DRAM row
activations on older DDR3 modules.

Vendor B. In Section VI, we describe assisted double-sided
(i.e., 3-sided) and 4-sided hammering as two effective patterns
against a subset of our memory modules from vendor B.
However,
the low bit ﬂip counts in Table II show that
bypassing the TRR mitigation on these modules is non-trivial.
We run further experiments on these modules to understand
the limited number of bit ﬂips we observe. We make two
observations. First, when we repeat for multiple iterations the

Fig. 13: Bit ﬂips vs. number of aggressor rows. Module A10:
Number of bit ﬂips triggered with N-sided RowHammer for varying
number of N on Intel Core i7-7700K. Each aggressor row is one row
away from the closest aggressor row (i.e., VAVAVA... conﬁguration)
and aggressor rows are hammered in a round-robin fashion.

C. TRRespass on LPDDR4(X)

In order to understand how widespread the issue is, we
implement a simpliﬁed version of TRRespass for ARMv8
to test LPDDR4 [40] and LPDDR4X [43] chips on mobile
phones. Due to the fragmented nature of the Android ecosys-
tem and the limited privileges (and resources) available on
some of these devices, we drop one of the two fundamental
parameters used in our previous design: location. In other
words, we simply map a big chunk of memory and ﬁnd a
pool of addresses that belong to the same bank [76]. Van der
Veen et al. [91], [92] rely on uncached memory due to the
lack of cache ﬂushing instructions on ARMv7. This restriction
does not apply any longer on ARMv8, and thus we do not use
uncached memory. In our experiments, TRRespass discovers
effective hammering patterns on 5 of the 13 devices, proving
that TRR-protected mobile platforms are also still vulnerable
to RowHammer (data is shown in Table III). Not all mobile
platforms report information about the memory manufacturer
and we do not have ﬁne grained control over the memory
allocations. As a result, we cannot draw any conclusion with
regard to the extent of the vulnerability on LPDDR4(X).
Furthermore, phones from the same model can use DRAM
chips from different manufacturers. This means that even if
TRRespass ﬁnds RowHammer bit ﬂips on a certain phone from
a speciﬁc model, another phone from the same model may not
exhibit these bit ﬂips. Similarly, the opposite can also be true.

VII. EVALUATION
In this section, we systematically evaluate our 42 DDR4
DRAM modules against
the optimal RowHammer access
pattern (i.e., the one that yields the most bit ﬂips) identiﬁed
by TRRespass for each module.

A. Results

We test each of the 42 modules using the most-bit-ﬂip-
incurring RowHammer pattern that we discover for each
module in Section VI-B. For every module, we perform a
sweep over 256 MB of contiguous physical memory.5 We

5We avoid testing the entire capacity of the DRAM modules and instead
test 256 MB of each module to reduce testing time. We note that this could
potentially cause TRRespass to miss the most RowHammer-prone portions of
a module. Thus, we believe TRRespass is likely to be more effective than
what we report in this paper.

11

51015202530#Aggressor rows (N)050100150200#Bit Flipssame RowHammer experiment using the aggressor rows that
we know can cause bit ﬂips, we observe a varying number
of bit ﬂips in the victim row(s) across different iterations.
Figure 14 shows the number of bit ﬂips that we can trigger on
a speciﬁc row, using 3 aggressors in module B0. We observe
from the ﬁgure that different iterations (i.e., samples) of the
same test reveal a different number of bit ﬂips in the same
victim row. Second, when hammering the same module in a
multi-DIMM conﬁguration (i.e., two identical modules on the
same system), we often observe more bit ﬂips. These results
hint at the presence of a parameter TRRespass cannot (yet)
bypass. The fact that we occasionally observe a large number
of bit ﬂips suggests that these modules are quite susceptible
to RowHammer, and causing more bit ﬂips may be only a
matter of improving our fuzzing strategy.

Fig. 14: Bit ﬂips vs. Test iterations. Module B0: Number of bit
ﬂips over test iterations. In each iteration, the aggressor rows are
hammered for three refresh intervals.

Vendor C. TRRespass identiﬁes effective patterns on 2 of 14
C modules. However, we see a steep drop in the number of
bit ﬂips on modules from newer generations. Module C12,
produced before 2015,
is the oldest and most vulnerable
module in our test set (Table II). Modules of newer gener-
ations are less vulnerable (if at all) to the patterns identi-
ﬁed by TRRespass. This suggests that the in-DRAM TRR
implementation has evolved over time. We perform further
experiments on C13 to conﬁrm this hypothesis. We discover
that, instead of performing a single targeted refresh during
each regular refresh operation, the TRR mitigation employed
by C13 performs multiple targeted refreshes during each regular
refresh operation. While we can conﬁrm that recent DRAM
chips are still vulnerable to RowHammer, further research is
required to better understand newer TRR mitigations and to
ﬁnd more effective fuzzing strategies against them.

B. Increasing the Refresh Rate

As mentioned in Section V-A, the memory controller issues
a REFRESH command to the memory device every 7.8 µs,
to ensure that all cells are refreshed within a 64 ms interval.
Doubling (or even quadrupling) the refresh rate (i.e., double-
refresh) was proposed in the past [6], [7], [46], [51], [64] as an
immediate countermeasure against RowHammer attacks, since
doing so reduces the amount of time required for hammering.
As discussed in Section IV, some server platforms employ
double-refresh as default behavior or enable it when a non-
TRR-compliant DRAM module is in use. This is usually

12

not the case on consumer platforms.6 However, tREFI can
(sometimes) be set in the BIOS. Although double-refresh was
demonstrated in the past to not fully eliminate the RowHam-
mer vulnerability [7], [51], the introduction of in-DRAM TRR
may have changed the situation. In fact, since TRR acts mainly
at refresh time, doubling the refresh operations could improve
TRR’s security guarantees, enforcing the inhibitor operations
this hypothesis, we evaluate our
more frequently. To test
modules against TRRespass when running them with double
refresh.

Our experiment reveals the presence of new hammering
patterns that are still able to trigger bit ﬂips in three modules
(as indicated in the rightmost column in Table II). This result
further undermines the efﬁcacy of double refresh as a stopgap
solution against RowHammer even when in-DRAM TRR is
deployed.

C. Repeatability of the Bit Flips

Repeatability is a fundamental factor in RowHammer ex-
ploitation. The ability to reliably trigger a bit ﬂip repeat-
edly [51] is what made RowHammer so popular in adversarial
scenarios [14], [25], [28], [71], [72], [79], [81], [89], [91], [96].
We study the repeatability of these many-sided RowHam-
mer bit ﬂips to better understand their properties. We pick
one DRAM module per DRAM vendor (A14, B1, C13) and
we run the best pattern for each module. When a bit ﬂip
occurs, we try to repeat it. Our experiment conﬁrms that bit
ﬂips are repeatable in a reliable way for all the modules.
However, it may require multiple attempts before obtaining
the same bit ﬂip again and sometimes we may observe many
other spurious bit ﬂips generated by the same pattern (see our
analysis of Vendor B modules in Section VII-A). We discuss
the implications of this phenomenon for the exploitation of
these bit ﬂips in Section VIII.

VIII. EXPLOITATION WITH TRRespass
TRRespass generates many-sided RowHammer patterns to
bypass TRR on modern DDR4 modules. While such access
patterns are more sophisticated than standard RowHammer
access patterns [27], [51], [88], we now show that
their
practical exploitability is not only possible, but also similar,
in spirit,
to existing state-of-the-art RowHammer attacks.
For
this purpose, we show how we craft many-sided
exploits using the general RowHammer
RowHammer
exploitation framework used by prior work in the area [79].
The exploitability investigated by the framework revolves
(i) Memory templating,
around three fundamental steps:
(ii) Memory massaging, and (iii) Exploitation.

Memory Templating. In this step, the attacker scans memory
with RowHammer access patterns,
looking for vulnerable
memory pages (or templates) where one or more bits can be
ﬂipped at a speciﬁc offset. For templating to be successful,
an attacker needs to use the desired patterns when accessing
DRAM. Prior work has already demonstrated the feasibility
of using double-sided RowHammer patterns using either huge
(2MB) pages [79] or a variety of side channels to identify

6As we report in Table II, we occasionally detect double-refresh behavior
on particular DRAM modules. This suggests that the memory controller may
employ module-dependent mechanisms for RowHammer mitigation.

050K100K150K200K250K300K350K400KTest iterations01234567#Bit Flips[25],

[37],

physically contiguous memory ranges
[54],
[91]. For many-sided RowHammer, we can use the former
mechanism as long as we can ﬁt all the aggressor rows in a
single huge page (similar to double-sided RowHammer). This
is possible for simple variants such as 3-sided RowHammer,
but not for complex variants such as 19-sided (which may
require two or more consecutive huge pages). However,
many of these modules vulnerable to lengthy patterns are
also vulnerable to a series of different other patterns (often
shorter). Moreover, the results on LPDDR4(X), where we
simply hammer random addresses belonging to the same
bank, demonstrate that the location of the aggressors is not
always a fundamental parameter—relaxing the assumptions
for the attacker. In the case where only extended patterns
(e.g., 19-sided) are effective or in the absence of huge pages
in the system, we can still use a variety of page allocator side
channels [25], [54], [91] or speculative side channels [37],
[93] to locate a sufﬁciently large contiguous memory chunk
to ﬁt our many-sided RowHammer patterns and template
memory.

templates

vulnerable

Memory Massaging. Once
are
available,
the attacker needs to implement some form of
memory massaging to lure the victim into mapping the target
data onto one of the available templates. Any of the memory
massaging techniques described in prior work still apply
with no modiﬁcations to many-sided RowHammer, given that
memory massaging is pattern-agnostic [14], [25], [27], [28],
[79], [91], [92].

Exploitation. Once the target data is mapped onto the target
template, the attacker needs to trigger the same RowHammer
bit ﬂips using the previously templated access patterns to com-
plete the ﬁnal exploitation step. For this step to be successful,
the attacker needs to ensure that, with high probability, (i) the
templated bit ﬂips are repeatable, and (ii) there are no spurious
(non-templated) bit ﬂips in the victim page. Prior work has
shown that these assumptions hold in practice for state-of-the-
art attacks based on standard access patterns. Compared to
such patterns, many-sided patterns incur similar (albeit lower)
repeatability, as discussed in Section VII-C. In practice, this
means the attacker may have to perform the access patterns
multiple times for reliable exploitation. Moreover, to ensure
there are no spurious bit ﬂips across runs, the attacker can
trivially mask irrelevant columns in the aggressor rows as
shown in previous work [23], [33], [54] or otherwise use these
bit ﬂips as part of a compatible attack vector (e.g., corrupting
multiple bits of a cryptographic key [79]).

Overall, TRRespass-based exploitation is very similar to
existing RowHammer attacks. As shown in the next section,
once effective many-sided access patterns are available, an
attacker can reliably mount real-world RowHammer attacks
on modern DDR4 systems in a matter of minutes.

A. Exploitation on DDR4

Armed with (repeatable) templates, we now study the effec-
tiveness of different RowHammer exploits on modern DDR4
systems. To this end, we implement three example attacks:
(i) the original RowHammer exploit targeting PTEs (Page
Table Entries) to obtain kernel privileges from Seaborn and
Dullien [81], (ii) the RSA exploit from Razavi et al. [79] that

13

corrupts public keys to gain access to a co-hosted VM, and (iii)
the opcode ﬂipping exploit on the sudo binary from Gruss et
al. [27]. The PTE exploit [81] takes advantage of bit ﬂips on
the Page Frame Number (PFN) to probabilistically redirect the
virtual to physical mapping of an attacker-controlled page to
another page table page. This relies on page table spraying to
increase the probability of referencing another page table page
with the corrupted PFN. The exploit from Gruss et al. [27]
shows that it is possible to target code pages in the page cache
to compromise opcodes and bypass permission checks on the
sudo binary. Gruss et al. [27] report 29 vulnerable opcodes
to use for this purpose. Razavi et al. [79] propose an attack
to compromise an RSA public key stored in the page cache.
They prove that causing a bit ﬂip in the modulus of a 1024-bit
or 2048-bit RSA public key makes the modulus factorizable
with a probability of 12-22%. For our analysis, we target a
2048-bit RSA public key.

We assume an attacker capable of performing memory
massaging—placing an exploitable target on one of the vul-
nerable memory pages—using any well-known technique [14],
[25], [27], [28], [79], [91], [92]. Table IV presents our results
for two sample modules for each vendor—the most and
least vulnerable from the same manufacturer. As part of our
analysis, we also record τ (i.e., time to template a single row),
since many-sided RowHammer requires more time to carry
out templating compared to previous RowHammer variants.
As expected, we see a large discrepancy across the different
modules, which matches the largely different number of bit
ﬂips reported in Table II. In the case of B modules, where
TRRespass is able to generate very few bit ﬂips, we are
unable to reproduce any attack. On the other hand, on the
other 4 modules from vendors A and C we can (overall)
ﬁnd templates to reproduce all the attacks. On C12, we can
reproduce the PTE attack [81] in as little as 2.3 s, while
the RSA-2048 exploit [79], when successful, can take up
to 39 m 48 s (A4). Bypassing sudo permission checks [27]
turned out to be possible only on C12 in 54 m 16 s. Note that
we assume existing templating strategies as is: we did not
attempt to craft more sophisticated attacks, since our goal
is solely to test existing RowHammer variants. Overall, our
results show that RowHammer still presents a signiﬁcant threat
to the security of modern DDR4 systems, even in the presence
of in-DRAM TRR mitigations.

TABLE IV: Time to exploit. Time to ﬁnd the ﬁrst exploitable
template on two sample modules from each DRAM vendor.

Module τ (ms)

PTE [81] RSA-2048 [79]

sudo [27]

A14
A4
B1
B2
C12
C13

188.7
180.8
360.7
331.2
300.0
180.9

4.9s
38.8s

6m 27s
39m 28s

2.3s
3h 15m

74.6s

54m16s

τ: Time to template a single row: time to ﬁll the victim and aggressor rows + hammer
time + time to scan the row.

IX. RELATED WORK

RowHammer. In their seminal work, Kim et al. [51] are the
ﬁrst to rigorously introduce and characterize the RowHam-
mer vulnerability. Following this work, a large number of
of attacks compromising a variety of different systems [5],
[12], [13], [17], [24], [25], [28], [39], [77], [79], [81], [89],
[91], [92], [96], [98] and characterization studies [22], [23],
[27], [78], [88] emerged, as described in a recent retrospec-
tive article [72]. Prior works rely on three main classes of
RowHammer patterns to induce bit ﬂips: (i) single-sided, (ii)
double-sided, and (iii) one-location RowHammer. None of
these techniques are effective against modern DDR4 modules
with in-DRAM RowHammer mitigations. Lanteigne [55], [56]
proposes a technique (called regional RowHammer), where
a small 2 MB region (e.g., a Linux hugepage) is hammered
using multiple software threads to increase the DRAM row
activation rate. In fact, we are not the ﬁrst to use the term
n-sided RowHammer for n = 4, as Lanteigne refers to his
technique as quad-sided [55]. However, his technique does
not provide a clear or methodical way of picking aggressor
rows that are close to each other in a bank, and instead aims
to maximize the number of row activations. We show that
merely maximizing the number of activations is not sufﬁcient
to bypass in-DRAM RowHammer mitigations.
Software-based mitigations. Herath and Fogh [32] and
Aweke et al. [7] suggested “hybrid” mitigations based on hard-
ware performance counters to detect suspicious hammering-
like activity. Other mitigations, such as CATT [16] and
GuardION [92], try to enforce DRAM-based data isolation to
prevent RowHammer attacks from corrupting sensitive data.
Nevertheless, recent work has shown how these mitigations
cannot stop more sophisticated attacks [25], [27]. With the
correct DRAM mapping functions, ZebRAM [53] can protect
the entire system by extending isolation to the entire DRAM.
Unfortunately, ZebRAM becomes expensive when the active
working set of an application is larger than half of DRAM
capacity.
Hardware-based mitigations. Although doubling the refresh
rate or using ECC memory are immediately-deployable solu-
tions, they have proven insufﬁcient to stop RowHammer [7],
[23], [51]. Other hardware-based mitigation techniques have
been proposed [62], [86], [87] but, to our knowledge, these
have not been deployed in real systems. Kim et al. propose
Probabilistic Adjacent Row Activation (PARA) [51], which
is a low overhead mechanism to prevent RowHammer bit
ﬂips. When a row is activated, with a very small probability,
PARA refreshes rows adjacent to the activated row. A variant
of PARA, Hardware RHP, appears to be employed by some
Intel memory controllers [36], [73], [90], [94]. This is a
new RowHammer measure in the memory controller and its
robustness is yet to be independently validated. In recent years,
TRR has become the hardware-based RowHammer mitigation
of choice, ﬁrst deployed in the MC on DDR3 systems and then
in-DRAM on DDR4. While DDR3 systems have been widely
studied, only a few studies have reported RowHammer bit ﬂips
on DDR4 [27], [56], [66]. Compared to our analysis, such
studies have induced bit ﬂips on selected earlier-generation
DDR4 modules. In contrast, we study several generations
of DDR4 modules (including the most-recent off-the-shelf
devices) and ﬁnd that, while standard access patterns are no
longer effective, new many-sided RowHammer patterns can
still induce bit ﬂips on many TRR-protected DDR4 modules
in the market today.

X. CONCLUSION
This paper shows that, despite signiﬁcant mitigation ef-
forts, modern DDR4 DRAM systems are still vulnerable to
RowHammer bit ﬂips—and even more vulnerable than DDR3
DRAM systems, once the mitigations are bypassed. In particu-
lar, we demonstrate that Target Row Refresh (TRR), publicized
by CPU and DRAM vendors as the deﬁnitive solution to
RowHammer, can be bypassed to cause RowHammer bit ﬂips.
First, we show that TRR is an umbrella term for a variety of
mitigations deployed at the memory controller or in DRAM
chips. Second, we analyze common TRR implementations
in the memory controller (using timing side channels) and
in DRAM chips (using an FPGA-based memory controller,
SoftMC). Our analysis shows that the consumer CPUs we
test rely on in-DRAM TRR to mitigate the RowHammer
vulnerability and do not employ TRR at the memory controller
level. We discover that modern (in-DRAM) TRR implementa-
tions are generally vulnerable to many-sided RowHammer, a
new hammering strategy that hammers many (i.e., at least 3)
aggressor rows concurrently. Finally, we present TRRespass,
a black-box many-sided RowHammer fuzzer that, unaware of
the implementation of the memory controller or the DRAM
chip, can still ﬁnd sophisticated hammering patterns to mount
real-world attacks for many of the DDR4 DRAM modules
in the market. Our results provide evidence that the pursuit
of effective RowHammer mitigations must continue and that
the security by obscurity strategy of DRAM vendors puts
computing systems at risk for extended periods of time.

DISCLOSURE
We disclosed our new RowHammer attacks to all affected
parties in November of 2019. This triggered an industry-
wide effort
in addressing the issues raised in this paper.
Unfortunately, due to the nature of these vulnerabilities, it will
take time before effective mitigations will be in place. Further
developments on these vulnerabilities are tracked under CVE-
2020-10255. The paper remained conﬁdential until the public
disclosure date of March 10, 2020.

ACKNOWLEDGMENTS
We would like to thank the anonymous reviewers for their
valuable feedback and Robin Webbers for helping us in our
analysis of LPDDR4(X) systems. This work was supported by
the European Union’s Horizon 2020 research and innovation
programme under grant agreements No. 786669 (ReAct) and
No. 825377 (UNICORE), by Intel Corporation through the
Side Channel Vulnerability ISRA, and by the Netherlands
Organisation for Scientiﬁc Research through grants NWO
639.023.309 VICI “Dowsing”, NWO 639.021.753 VENI “Pan-
taRhei”, and NWO 016.Veni.192.262. This paper reﬂects only
the authors’ view. The funding agencies are not responsible
for any use that may be made of the information it contains.

REFERENCES

[1] “DRAM Chip Market Share by Manufacturer Worldwide from 2011 to
2019,” https://www.statista.com/statistics/271726/global-market-share-
held-by-dram-chip-vendors-since-2010, 2019.

[2] “RAMBleed DRAM Vulnerabilities,” https://blogs.oracle.com/security/

rambleed, 2019.

[3] “Researchers Use RowHammer Bit Flips to Steal 2048-bit Crypto Key,”
https://arstechnica.com/information-technology/2019/06/researchers-
use-rowhammer-bitﬂips-to-steal-2048-bit-crypto-key/, 2019.

[4] Advanced Micro Devices, “AMD Generic Encapsulated Software Ar-
chitecture (AGESATM) Interface Speciﬁcation for Arch2008,” 2017.
[5] M. T. Aga et al., “When Good Protections Go Bad: Exploiting Anti-DoS

Measures to Accelerate Rowhammer Attacks,” in HOST, 2017.

14

[6] Apple Inc., “About the Security Content of Mac EFI Security Update
2015-001,” https://support.apple.com/en-us/HT204934, june 2015.
[7] Z. B. Aweke et al., “ANVIL: Software-Based Protection Against Next-

[41] JEDEC, “SPD Annex K - Serial Presence Detect (SPD) for DDR3

SDRAM Modules, v6,” 2014.

[42] JEDEC, “SPD Annex L - Serial Presence Detect (SPD) for DDR4

Generation Rowhammer Attacks,” in ASPLOS, 2016.

SDRAM Modules, v3,” 2015.

[8] K. S. Bains and J. B. Halbert, “Distributed row hammer tracking,” US

Patent 9 299 400B2, 2016.

[9] K. S. Bains et al., “Row hammer refresh command,” US Patent

9 236 110B2, 2016.

[10] K. S. Bains et al., “Method, apparatus and system for providing a

memory refresh,” US Patent 9 030 903B2, 2015.

[11] A. Barenghi et al., “Software-Only Reverse Engineering of Physical

DRAM Mappings for RowHammer Attacks,” in IVSW, 2018.

[12] S. Bhattacharya and D. Mukhopadhyay, “Curious Case of Rowhammer:
Flipping Secret Exponent Bits using Timing Analysis,” in CHES, 2016.
[13] S. Bhattacharya and D. Mukhopadhyay, “Advanced Fault Attacks in
Software: Exploiting the RowHammer Bug,” in Fault Tolerant Architec-
tures for Cryptography and Hardware Security, 2018.

[43] JEDEC, “JESD209-4, LPDDR4X Speciﬁcation,” 2017.
[44] JEDEC, “JESD79-4B, DDR4 Speciﬁcation,” 2017.
[45] B. I. Jung et al., “Memory Device, Memory System, and Operating

Methods thereof,” US Patent 9 257 169B2, 2016.

[46] M. Kaczmarski, “Thoughts on Intel R(cid:13) Xeon R(cid:13) E5-2600 v2 Product
Family Performance Optimisation – component selection guidelines,”
2014.

[47] O. D. Kahn and J. R. Wilcox, “Method for Dynamically Adjusting a

Memory Page Closing Policy,” US Patent 6 799 241, 2004.

[48] S. Khan et al., “PARBOR: An Efﬁcient System-Level Technique to

Detect Data-Dependent Failures in DRAM,” in DSN, 2016.

[49] D. S. Kim and J. I. Kim, “Refresh control device and semiconductor

device including the same,” US Patent 9 818 469B1, 2017.

[14] E. Bosman et al., “Dedup Est Machina: Memory Deduplication as an

[50] Y. Kim et al., “A Case for Exploiting Subarray-Level Parallelism (SALP)

Advanced Exploitation Vector,” in S&P, 2016.

in DRAM,” in ISCA, 2012.

[15] K. M. Brandl, “Data processor with memory controller for high relia-

bility operation and method,” US Patent 9 281 046B2, 2016.

[16] F. Brasser et al., “CAn’t Touch This: Software-only Mitigation against
Rowhammer Attacks targeting Kernel Memory,” in USENIX Sec., 2017.
[17] S. Carre et al., “OpenSSL Bellcore’s Protection Helps Fault Attack,” in

DSD, 2018.

[18] K. K. Chang et al., “Understanding Latency Variation in Modern DRAM
Chips: Experimental Characterization, Analysis, and Optimization,” in
SIGMETRICS, 2016.

[19] K. K. Chang et al., “Improving DRAM Performance by Parallelizing

Refreshes with Accesses,” in HPCA, 2014.

[20] K. K. Chang et al., “Low-cost Inter-linked Subarrays (LISA): Enabling
Fast Inter-subarray Data Movement in DRAM,” in HPCA, 2016.
[21] K. K. Chang et al., “Understanding Reduced-Voltage Operation in
Modern DRAM Devices: Experimental Characterization, Analysis, and
Mechanisms,” in SIGMETRICS, 2017.

[51] Y. Kim et al., “Flipping Bits in Memory Without Accessing Them: An
Experimental Study of DRAM Disturbance Errors,” in ISCA, 2014.
[52] Y. Kim et al., “ATLAS: A Scalable and High-Performance Scheduling

Algorithm for Multiple Memory Controllers,” in HPCA, 2010.

[53] R. K. Konoth et al., “ZebRAM: Comprehensive and Compatible Soft-
ware Protection Against Rowhammer Attacks,” in OSDI, 2018.
[54] A. Kwong et al., “RAMBleed: Reading Bits in Memory Without

Accessing Them,” in S&P, 2020.

[55] M. Lanteigne, “A Tale of Two Hammers: A Brief Rowhammer Rowham-

mer Analysis of AMD vs. Intel.” ThirdIO Inc., 2016.

[56] M. Lanteigne, “How Rowhammer Could Be Used to Exploit Weaknesses

in Computer Hardware,” in SEMICON, 2016.

[57] D. Lee et al., “Adaptive-Latency DRAM: Optimizing DRAM Timing

for the Common-Case,” in HPCA, 2015.

[58] D. Lee et al., “Tiered-Latency DRAM: A Low Latency and Low Cost

DRAM Architecture,” in HPCA, 2013.

[22] L. Cojocar et al., “Are We Susceptible to Rowhammer? An End-to-End

[59] D. Lee et al., “Simultaneous Multi-Layer Access: Improving 3D-Stacked

Methodology for Cloud Providers,” in S&P, 2020.

Memory Bandwidth at Low Cost,” TACO, 2016.

[23] L. Cojocar et al., “Exploiting Correcting Codes: On the Effectiveness
of ECC Memory Against Rowhammer Attacks,” in S&P, 2019.
[24] A. P. Fournaris et al., “Exploiting Hardware Vulnerabilities to Attack
Embedded System Devices: A Survey of Potent Microarchitectural
Attacks,” Electronics, 2017.

[60] D. Lee et al., “Design-Induced Latency Variation in Modern DRAM
Chips: Characterization, Analysis, and Latency Reduction Mechanisms,”
in SIGMETRICS, 2017.

[61] D. Lee et al., “Decoupled Direct Memory Access: Isolating CPU and

IO Trafﬁc by Leveraging a Dual-Data-Port DRAM,” in PACT, 2015.

[25] P. Frigo et al., “Grand Pwning Unit: Accelerating Microarchitectural

[62] E. Lee et al., “TWiCe: Preventing Row-Hammering by Exploiting Time

Attacks with the GPU,” in S&P, 2018.

Window Counters,” in ISCA, 2019.

[26] Z. Greenﬁeld et al., “Method, apparatus and system for determining a
count of accesses to a row of memory,” US Patent 20 140 085 995A1,
2014.

[27] D. Gruss et al., “Another Flip in the Wall of Rowhammer Defenses,” in

S&P, 2018.

[63] J.-B. Lee, “Green Memory Solution,” in Samsung Electronics, Investor’s

Forum, 2014.

[64] Lenovo, “Row Hammer Privilege Escalation,” https://support.lenovo.

com/us/en/product security/row hammer, March 2015.

[65] J. Lin, “Handling Maximum Activation Count limit and Target Row

[28] D. Gruss et al., “Rowhammer.js: A Remote Software-Induced Fault

Refresh in DDR4 SDRAM,” US Patent 9 589 606B2, 2017.

Attack in JavaScript,” in DIMVA, 2016.

[29] H. Hassan et al., “CROW: A Low-Cost Substrate for Improving DRAM
Performance, Energy Efﬁciency, and Reliability,” in ISCA, 2019.
[30] H. Hassan et al., “ChargeCache: Reducing DRAM Latency by Exploit-

ing Row Access Locality,” in HPCA, 2016.

[31] H. Hassan et al., “SoftMC: A Flexible and Practical Open-Source
Infrastructure for Enabling Experimental DRAM Studies,” in HPCA,
2017.

[32] N. Herath and Anders Fogh, “These are Not Your Grand Daddy’s CPU

Performance Counters,” in Black Hat Brieﬁngs, 2015.

[33] S. Hong et al., “Terminal Brain Damage: Exposing the Graceless
Degradation in Deep Neural Networks Under Hardware Fault Attacks,”
in USENIX Sec., 2019.

[34] D. Hwa Hong, “Smart Refresh Device,” US Patent 9 311 984B1, 2016.
[35] Intel Corp., “Intel R(cid:13) Xeon R(cid:13) Processor E5 v4 Product Family,” 2016.
Support
[36] Intel Corp.,
Package
(FSP)
https://usermanual.wiki/Pdf/
CannonLakeFSPIntegrationGuide.58784693.pdf, 2017.

Intel
Guide,”

“CannonLake

Integration

Firmware

[66] M. Lipp et al., “Nethammer: Inducing Rowhammer Faults Through

Network Requests,” arXiv preprint 1805.04956, 2018.

[67] J. Liu et al., “RAIDR: Retention-Aware Intelligent DRAM Refresh,” in

ISCA, 2012.

[68] J. Liu et al., “An Experimental Study of Data Retention Behavior in
Modern DRAM Devices: Implications for Retention Time Proﬁling
Mechanisms,” in ISCA, 2013.

[69] M. Majkowski, “Every 7.8µs your computer’s memory has a hic-
cup,” https://blog.cloudﬂare.com/every-7-8us-your-computers-memory-
has-a-hiccup/, 2018.

[70] Micron, “DDR4 SDRAM Datasheet,” p. 380, 2016.
[71] O. Mutlu, “The RowHammer Problem and Other Issues We May Face

as Memory Becomes Denser,” in DATE, 2017.

[72] O. Mutlu and J. S. Kim, “RowHammer: A Retrospective,” TCAD, 2019.
[73] Omron, “NY-series Industrial Box PC - Hardware User’s Man-

ual,” https://assets.omron.eu/downloads/manual/en/v6/w553 ny-series
industrial box pc users manual en.pdf, 2019.

[74] J.-B. Park, “Memory and Memory System including the same,” US

[37] S. Islam et al., “SPOILER: Speculative Load Hazards Boost Rowham-

Patent 9 396 786B2, 2016.

mer and Cache Attacks,” arXiv preprint 1903.00446, 2019.

[38] Y. Ito and Y. He, “Semiconductor Device,” US Patent 9 805 783B2, 2017.
[39] Y. Jang et al., “SGX-Bomb: Locking Down the Processor via RowHam-

mer Attack,” in SysTEX, 2017.

[75] M. S. Park, “Memory Device to Alleviate the Effects of Row Ham-
mer Condition and Memory System Including the Same,” US Patent
9 685 240B1, 2017.

[76] P. Pessl et al., “DRAMA: Exploiting DRAM Addressing for Cross-CPU

[40] JEDEC, “JESD209-4, LPDDR4 Speciﬁcation,” 2014.

Attacks.” in USENIX Sec., 2016.

15

[77] D. Poddebniak et al., “Attacking Deterministic Signature Schemes Using

Fault Attacks,” in EuroS&P, 2018.

[78] R. Qiao and M. Seaborn, “A New Approach for Rowhammer Attacks,”

in HOST, 2016.

[79] K. Razavi et al., “Flip Feng Shui: Hammering a Needle in the Software

Stack,” in USENIX Sec., 2016.

[80] SAFARI Research Group, “SoftMC — GitHub Repository,” https://

github.com/CMU-SAFARI/SoftMC.

[81] M. Seaborn and T. Dullien, “Exploiting the DRAM Rowhammer Bug

to Gain Kernel Privileges,” in Black Hat USA, 2015.

[82] V. Seshadri et al., “RowClone: Fast and Energy-Efﬁcient In-DRAM Bulk

Data Copy and Initialization,” in MICRO, 2013.

[83] V. Seshadri et al., “Ambit: In-Memory Accelerator for Bulk Bitwise
Operations Using Commodity DRAM Technology,” in MICRO, 2017.
[84] V. Seshadri et al., “Gather-Scatter DRAM: In-DRAM Address Transla-
tion to Improve the Spatial Locality of Non-Unit Strided Accesses,” in
MICRO, 2015.

[85] V. Seshadri and O. Mutlu, “In-DRAM Bulk Bitwise Execution Engine,”

arXiv:1905.09822, 2019.

[86] S. M. Seyedzadeh et al., “Counter-Based Tree Structure for Row

Hammering Mitigation in DRAM,” IEEE CAL, 2017.

[87] M. Son et al., “Making DRAM Stronger Against Row Hammering,” in

DAC, 2017.

[88] A. Tatar et al., “Defeating Software Mitigations against Rowhammer: A

Surgical Precision Hammer,” in RAID, 2018.

[89] A. Tatar et al., “Throwhammer: Rowhammer Attacks over the Network

and Defenses,” in USENIX ATC, 2018.

[90] TQ-Systems, “TQMx80UC User’s Manual,” https://www.tq-group.com/

ﬁledownloads/ﬁles/products/embedded/manuals/x86/embedded-modul/
COM-Express-Compact/TQMx80UC/TQMx80UC.UM.0102.pdf, 2020.
[91] V. van der Veen et al., “Drammer: Deterministic Rowhammer Attacks

on Mobile Platforms,” in CCS, 2016.

[92] V. van der Veen et al., “GuardION: Practical mitigation of DMA-based

rowhammer attacks on ARM,” in DIMVA, 2018.

[93] S. van Schaik et al., “RIDL: Rogue in-ﬂight data load,” in S&P, 2019.
Reference Manual,”
[94] VersaLogic

“Blackbird

Corp.,

BIOS

https://www.versalogic.com/wp-content/themes/vsl-new/assets/pdf/
manuals/MEPU 4462 4562 BRM.pdf, 2019.

[95] G. D. Wolff, “Apparatuses and methods for distributing row hammer
refresh events across a memory device,” US Patent 20 180 218 767A1,
2018.

[96] Y. Xiao et al., “One Bit Flips, One Cloud Flops: Cross-VM Row
Hammer Attacks and Privilege Escalation.” in USENIX Sec., 2016.
[97] T. Zhang et al., “Half-DRAM: A High-bandwidth and Low-power
DRAM Architecture from the Rethinking of Fine-grained Activation,”
in ISCA, 2014.

[98] Z. Zhang et al., “Triggering Rowhammer Hardware Faults on ARM: A

Revisit,” in ASHES, 2018.

APPENDIX A
TRR-COMPLIANT MEMORY

In Section IV, we deﬁne TRR-compliant memory. Here we
expand on this concept, also explaining the difference between
TRR-compliant and pTRR-compliant memory.

The MAC ﬁeld is a ﬁeld of one byte located at byte 41
on the SPD of a DDR3 module [41] and byte 7 on the SPD
of a DDR4 module [42]. This ﬁeld reports information about
the module’s resiliency to RowHammer. In the single byte
allocated to the MAC value inside the SPD [41], [42], only the
6 least signiﬁcant bits are used to store information about the
module’s limits in the form of MAC and tMAW (Figure 15),
where MAC is the Maximum Activate Count and tMAW is the
Maximum Activate Window, which simply acts as a multiplier
for MAC (Figure 15). The remaining two most signiﬁcant bits
are ﬂagged as reserved. As we mention in Section IV the MAC
value can take three conﬁgurations:
• unlimited, as value 0b1000;

• untested, as value 0b0000; or
• discrete values from 200K to 700K with steppings of

+100K—values 0b0001 to 0b0110.

Fig. 15: SPD’s MAC ﬁeld. Bit 7 needs to be set in order to enable
pTRR [46].

In one of our early experiments, we discovered that our
deﬁnition of TRR-compliant modules slightly diverges from
Intel’s deﬁnition of pTRR-compliant modules [46]. In fact,
we discovered that in order to enable pTRR, bit 7 (one of the
reserved bits) needs to be set. If not, regardless of the MAC and
tMAW values, the system treats the module as non-compliant.
This is likely a legacy feature which stems from the fact that
pTRR [46] was introduced before TRR became part of the
JEDEC standard [41].

APPENDIX B
TRRespass-ING PATTERNS

In Section VI-B, we explain the new n-sided hammering
patterns we use in our experiments. We now provide a more
general deﬁnition of these hammering patterns.

TRRespass randomizes two parameters: cardinality and
distance. Cardinality and distance together deﬁne a novel
hammering pattern that we refer to as (cid:104)n-sided | dist=d(cid:105)
RowHammer. The pattern consists of n
2 pairs of aggressor
rows, where the two aggressor rows in each pair are placed one
victim row apart (similar to double-sided RowHammer). The
distance d deﬁnes the number of rows between the aggressor
row pairs. For example, the (cid:104)4-sided | dist=3(cid:105) pattern contains
two aggressor row pairs (four aggressor rows in total), and the
two aggressor row pairs are three rows apart from each other.
The n-sided pattern, which we refer to throughout the paper,
is another example, where the distance between the aggressor
row pairs is one row.

Figure 16 shows the number of bit ﬂips that occur in module
A10 when we use the (cid:104)10-sided | dist=D(cid:105) hammering pattern
while sweeping the parameter D. We note that the number
of bit ﬂips increases and decreases as we vary D, reaching
its maximum at D = 12. This observation conﬁrms that the
distance between aggressor row pairs has a primary role in
assembling an effective hammering pattern.

Fig. 16: Bit ﬂips induced by (cid:104)10-sided | dist=D(cid:105) RowHammer-
pattern as a function of D. X-axis plots the distance between each
aggressor row pair. Y-axis reports the number of unique bit ﬂips.

16

MACtMAW3-05-47-6Reserved0123456789101112131415Distance between aggressor row pairs050100150200250#Bit Flips
