Based on the provided content, here's an analysis of CVE-2020-9391:

**Root Cause of Vulnerability:**

The root cause is an incorrect handling of the top byte of 64-bit addresses by the Linux kernel in the `brk()`, `mmap()`, and `mremap()` system calls on the AArch64 architecture. The kernel was ignoring this top byte, which could be used by applications for tagged pointers.

**Weaknesses/Vulnerabilities Present:**

*   **Address Alias Creation:** Ignoring the top byte of user-provided addresses in memory management system calls (`brk`, `mmap`, `mremap`) could lead to the creation of address aliases within user space. This is because a user could provide a 64 bit address with the top byte set, and the kernel would strip the top byte and interpret it as a valid address, even if there was already an existing mapping on the untagged address.
*   **Heap Corruption:** Specifically with `brk()`,  the kernel's behavior resulted in the break being moved in the wrong direction (downward instead of upward) when an address with the top byte set was provided. This could corrupt the heap.

**Impact of Exploitation:**

*   **Heap Corruption:** The incorrect handling of the `brk()` system call could cause heap corruption, potentially leading to crashes, unpredictable behavior, and possibly arbitrary code execution.
*   **Denial of Service (DoS):** The heap corruption and crashes can lead to a denial of service.
*   **Application Instability:** Applications relying on the kernel to reject addresses beyond the 56-bit limit would fail. For example, glibc's malloc was affected due to this issue and could crash.

**Attack Vectors:**

*   The vulnerability could be triggered by a local attacker. An attacker could craft specific system calls with addresses containing the top byte set and call them to corrupt the heap.

**Required Attacker Capabilities/Position:**

*   **Local User:** An attacker would need to be able to execute code on the target system to make the vulnerable system calls. This means they would need to have at least user-level access.
*   **Knowledge of the Vulnerability:** The attacker needs to know that the kernel ignores the top byte of addresses in `brk()`, `mmap()`, and `mremap()` system calls.

**Additional details from the content:**
*   The issue was initially discovered when Python packages were failing to build in Fedora rawhide on aarch64.
*   The vulnerability was present in Linux kernel versions 5.4 and onwards until the fix was released in 5.5.6.
*   The issue was reproducible on AArch64 bare metal systems and virtual machines with updated kernels, but not on emulated AArch64 environments.
*   The vulnerability was triggered by specific memory allocation patterns in applications like Python. A simplified C reproducer was crafted which made this vulnerability very easy to trigger.
*   The vulnerability is architecture specific to AArch64.

In summary, CVE-2020-9391 highlights a critical flaw in the AArch64 memory management in the Linux kernel where tagged addresses were mishandled when creating mappings in brk(), mmap() and mremap(), potentially leading to severe consequences like heap corruption and denial of service.