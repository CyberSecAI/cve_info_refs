Based on the provided information, this issue report on GitHub directly relates to the vulnerability described in CVE-2020-22673.

Here's a breakdown of the relevant information:

**Root cause of vulnerability:**
- The vulnerability is a memory leak in the `senc_Parse` function located in `isomedia/box_code_drm.c` at line 1349.

**Weaknesses/vulnerabilities present:**
-  A memory leak occurs because memory allocated for `GF_CENCSampleAuxInfo` structures using `gf_malloc` is not freed. This occurs inside a loop while parsing the Sample Auxiliary Information in a 'senc' box

**Impact of exploitation:**
-  A crafted input file can cause the program to leak memory when parsing a malformed 'senc' box. Repeatedly triggering this can lead to resource exhaustion.
- The report shows that an Address Sanitizer (ASAN) detected a 32-byte memory leak.
- In the provided ASAN output, the `senc_Parse` function at `isomedia/box_code_drm.c:1349` is identified as the location of the leak.
- The program crashes (or terminates) due to ASAN detecting this memory leak

**Attack vectors:**
- The attack vector is a crafted MP4 file containing a malformed 'senc' box that triggers the memory leak when parsed. Specifically, the crafted input file `004-memleak-senc1349` is mentioned in the report.
- The `MP4Box` utility is used to parse the file, and the issue is triggered during the parsing process.

**Required attacker capabilities/position:**
- The attacker needs to be able to provide a malicious MP4 file to the target.
- The target system must be running GPAC version 0.8.0 or an affected version based on this code

**Additional details:**
- The report includes specific file path details and code snippets that directly identify the vulnerable function and the location of the memory allocation.
- The ASAN output provides a detailed trace that pinpoints the `gf_malloc` call at line 1349 as the source of the leak.
- The issue report includes the command line to reproduce the vulnerability
- The report includes the problematic code snippet
```c
        count = gf_bs_read_u32(bs);
        if (!senc->samp_aux_info) senc->samp_aux_info = gf_list_new();
        for (i=0; i<count; i++) {
                u32 is_encrypted;
---------->GF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));
                memset(sai, 0, sizeof(GF_CENCSampleAuxInfo));
```
- This code snippet shows that `gf_malloc` is called to allocate the `GF_CENCSampleAuxInfo` structure, but the allocated memory is not being freed within the parsing routine, resulting in the memory leak.