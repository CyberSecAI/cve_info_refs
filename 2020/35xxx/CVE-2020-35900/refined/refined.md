Based on the provided content, here's a breakdown of the vulnerability described in CVE-2020-35900:

**Root Cause:**

- The `pop_back()` function in the `array-queue` crate incorrectly calculates the index for the element to be removed from the back of the queue. Instead of using the proper index based on the queue's internal state (start pointer and length), it directly uses `self.length - 1`.

**Weaknesses/Vulnerabilities:**

- **Use-After-Free:** When `pop_front()` is called, the queue's start pointer is advanced, but the memory of the popped element is not necessarily overwritten or invalidated. Subsequently, using the incorrect `self.length - 1` index in `pop_back()` can lead to accessing previously dropped or uninitialized memory, resulting in a use-after-free condition.
- **Uninitialized Memory Read:** If `pop_front()` is called after several pushes, then popping from the back can lead to a read of uninitialized memory which can have arbitrary values.

**Impact of Exploitation:**

- **Information Disclosure:** An attacker can potentially read the contents of memory that was previously used by the queue, including data that was supposed to be discarded. This could lead to the disclosure of sensitive information.
- **Undefined Behavior (UB):** Reading uninitialized memory is undefined behavior in Rust which might result in unpredictable program behavior.
- **Double Drop (Potential):** The vulnerability could lead to a double-drop if the popped value has already been dropped/deallocated.

**Attack Vectors:**

- The vulnerability is triggered when the library user calls `pop_back()` after some combination of `push_back()` and `pop_front()`.
- The vulnerability is in the `array_queue` crate itself. Any application using a vulnerable version of this crate can be affected.

**Required Attacker Capabilities/Position:**

- The attacker needs to have the ability to control the sequence of calls to the `array-queue` API in order to trigger the vulnerable code path.
- The attacker must be able to call both `pop_front` and `pop_back` functions on a queue which will then cause the use-after-free.
- The attacker must be able to execute code that is compiled with a vulnerable version of the library.
- The attacker can exploit it locally because the attack vector is "Local".

**Additional Details:**

- The provided GitHub issue (`raviqqe/array-queue#2`) contains a detailed explanation and a proof-of-concept demonstrating the use-after-free vulnerability.
- The issue also highlights a secondary problem with the crate potentially using `mem::uninitialized` which could cause undefined behavior for types that can't inhabit uninitialized memory. This is not the root cause of the use-after-free described in this CVE but an additional issue.
- The fix for the primary vulnerability would involve using the `ArrayQueue::index()` method in the `pop_back` function to properly index into the array.
- The `MaybeUninit` type was mentioned as the recommended way to handle uninitialized memory for cases where the type might not inhabit an uninitialized state.
- The vulnerability has a CVSS score of 5.5 (Moderate).

**Affected Versions:**

- Versions >= 0.3.0 and <= 0.3.3 are affected.

**Patched Versions:**

- No patched versions are available.