Based on the provided content, here's a breakdown of the vulnerability:

**Root Cause:**

The vulnerability stems from the `arc_swap::access::Map` type using the `Access` trait without ensuring that the guard type returned by the trait's `load()` method maintains a stable reference to the underlying data, especially when the guard is moved. The `MapGuard` type's `deref` method makes an unsafe assumption that the underlying reference remains valid.

**Weaknesses/Vulnerabilities Present:**

- **Dangling Reference:** When used with an `Access` implementation like `Constant`, which clones the underlying data on `load()`, `MapGuard` stores a pointer to a temporary copy. This copy goes out of scope, causing the stored pointer in `MapGuard` to become a dangling reference.
- **Unsafe Code:** The `MapGuard`'s `deref()` function contains unsafe code that dereferences a raw pointer without proper lifetime management, relying on an assumption that is not guaranteed by the `Access` trait.
- **Memory Corruption:** Dereferencing the dangling pointer in the `MapGuard` leads to undefined behavior, potentially causing memory corruption and crashes.

**Impact of Exploitation:**

- **Program Crash:** The primary impact is a program crash (segmentation fault) due to dereferencing a dangling pointer.
- **Potential for Further Exploitation:** While the provided example results in a crash, dereferencing a dangling pointer could potentially be exploited to read or write to arbitrary memory locations if more complex conditions are present.

**Attack Vectors:**

- **Local Code Execution:** An attacker needs to control or influence the use of the `arc_swap` crate with a vulnerable version and utilize the `arc_swap::access::Map` with an `Access` implementation like `Constant` or a user-supplied implementation that doesn't maintain reference stability.

**Required Attacker Capabilities/Position:**

- The attacker needs to be able to introduce or use vulnerable code (using affected versions of the `arc-swap` crate) that uses `arc_swap::access::Map` with an `Access` implementation that doesn't maintain reference stability, like the `Constant` type, or a custom implementation of the `Access` trait that exhibits similar behavior.
- The attacker needs to be able to execute this code. No specific network access or privileges are required for the exploit to occur locally.

**Additional Notes:**

- The vulnerability is present in versions of `arc-swap` before 0.4.8 and 1.x before 1.1.0.
- The vulnerability is triggered by the use of the `arc_swap::access::Map` with a specific implementation of the `Access` trait that exhibits a specific behavior on `load()`.
- The fix involves replacing the unsafe code in `MapGuard::deref` with a safe implementation, at the cost of added `Clone` bound on the closure and small penalty on performance.
- The vulnerability can be triggered by safe rust code.

This vulnerability is related to CVE-2020-35711, as indicated by the CVE ID in the provided content, the github advisory, and the rustsec advisory.