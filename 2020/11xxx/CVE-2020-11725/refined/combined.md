=== Content from github.com_38eef30b_20250119_112611.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftorvalds%2Flinux%2Fblob%2F3b2549a3740efb8af0150415737067d87e466c5b%2Fsound%2Fcore%2Fcontrol.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftorvalds%2Flinux%2Fblob%2F3b2549a3740efb8af0150415737067d87e466c5b%2Fsound%2Fcore%2Fcontrol.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=torvalds%2Flinux)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[torvalds](/torvalds)
/
**[linux](/torvalds/linux)**
Public

* [Notifications](/login?return_to=%2Ftorvalds%2Flinux) You must be signed in to change notification settings
* [Fork
  54.8k](/login?return_to=%2Ftorvalds%2Flinux)
* [Star
   186k](/login?return_to=%2Ftorvalds%2Flinux)

* [Code](/torvalds/linux)
* [Pull requests
  436](/torvalds/linux/pulls)
* [Actions](/torvalds/linux/actions)
* [Projects
  0](/torvalds/linux/projects)
* [Security](/torvalds/linux/security)
* [Insights](/torvalds/linux/pulse)

Additional navigation options

* [Code](/torvalds/linux)
* [Pull requests](/torvalds/linux/pulls)
* [Actions](/torvalds/linux/actions)
* [Projects](/torvalds/linux/projects)
* [Security](/torvalds/linux/security)
* [Insights](/torvalds/linux/pulse)

## Files

 3b2549a
## Breadcrumbs

1. [linux](/torvalds/linux/tree/3b2549a3740efb8af0150415737067d87e466c5b)
2. /[sound](/torvalds/linux/tree/3b2549a3740efb8af0150415737067d87e466c5b/sound)
3. /[core](/torvalds/linux/tree/3b2549a3740efb8af0150415737067d87e466c5b/sound/core)
/
# control.c

Copy path Blame  Blame
## Latest commit

## History

[History](/torvalds/linux/commits/3b2549a3740efb8af0150415737067d87e466c5b/sound/core/control.c)2131 lines (1903 loc) · 55 KB 3b2549a
## Breadcrumbs

1. [linux](/torvalds/linux/tree/3b2549a3740efb8af0150415737067d87e466c5b)
2. /[sound](/torvalds/linux/tree/3b2549a3740efb8af0150415737067d87e466c5b/sound)
3. /[core](/torvalds/linux/tree/3b2549a3740efb8af0150415737067d87e466c5b/sound/core)
/
# control.c

Top
## File metadata and controls

* Code
* Blame

2131 lines (1903 loc) · 55 KB[Raw](https://github.com/torvalds/linux/raw/3b2549a3740efb8af0150415737067d87e466c5b/sound/core/control.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000// SPDX-License-Identifier: GPL-2.0-or-later/\* \* Routines for driver control interface \* Copyright (c) by Jaroslav Kysela <perex@perex.cz> \*/
#include <linux/threads.h>#include <linux/interrupt.h>#include <linux/module.h>#include <linux/slab.h>#include <linux/vmalloc.h>#include <linux/time.h>#include <linux/mm.h>#include <linux/math64.h>#include <linux/sched/signal.h>#include <sound/core.h>#include <sound/minors.h>#include <sound/info.h>#include <sound/control.h>
/\* max number of user-defined controls \*/#define MAX\_USER\_CONTROLS 32#define MAX\_CONTROL\_COUNT 1028
struct snd\_kctl\_ioctl { struct list\_head list; /\* list of all ioctls \*/ snd\_kctl\_ioctl\_func\_t fioctl;};
static DECLARE\_RWSEM(snd\_ioctl\_rwsem);static LIST\_HEAD(snd\_control\_ioctls);#ifdef CONFIG\_COMPATstatic LIST\_HEAD(snd\_control\_compat\_ioctls);#endif
static int snd\_ctl\_open(struct inode \*inode, struct file \*file){ unsigned long flags; struct snd\_card \*card; struct snd\_ctl\_file \*ctl; int i, err;
 err = stream\_open(inode, file); if (err < 0) return err;
 card = snd\_lookup\_minor\_data(iminor(inode), SNDRV\_DEVICE\_TYPE\_CONTROL); if (!card) { err = -ENODEV; goto \_\_error1; } err = snd\_card\_file\_add(card, file); if (err < 0) { err = -ENODEV; goto \_\_error1; } if (!try\_module\_get(card->module)) { err = -EFAULT; goto \_\_error2; } ctl = kzalloc(sizeof(\*ctl), GFP\_KERNEL); if (ctl == NULL) { err = -ENOMEM; goto \_\_error; } INIT\_LIST\_HEAD(&ctl->events); init\_waitqueue\_head(&ctl->change\_sleep); spin\_lock\_init(&ctl->read\_lock); ctl->card = card; for (i = 0; i < SND\_CTL\_SUBDEV\_ITEMS; i++) ctl->preferred\_subdevice[i] = -1; ctl->pid = get\_pid(task\_pid(current)); file->private\_data = ctl; write\_lock\_irqsave(&card->ctl\_files\_rwlock, flags); list\_add\_tail(&ctl->list, &card->ctl\_files); write\_unlock\_irqrestore(&card->ctl\_files\_rwlock, flags); snd\_card\_unref(card); return 0;
 \_\_error: module\_put(card->module); \_\_error2: snd\_card\_file\_remove(card, file); \_\_error1: if (card) snd\_card\_unref(card); return err;}
static void snd\_ctl\_empty\_read\_queue(struct snd\_ctl\_file \* ctl){ unsigned long flags; struct snd\_kctl\_event \*cread;
 spin\_lock\_irqsave(&ctl->read\_lock, flags); while (!list\_empty(&ctl->events)) { cread = snd\_kctl\_event(ctl->events.next); list\_del(&cread->list); kfree(cread); } spin\_unlock\_irqrestore(&ctl->read\_lock, flags);}
static int snd\_ctl\_release(struct inode \*inode, struct file \*file){ unsigned long flags; struct snd\_card \*card; struct snd\_ctl\_file \*ctl; struct snd\_kcontrol \*control; unsigned int idx;
 ctl = file->private\_data; file->private\_data = NULL; card = ctl->card; write\_lock\_irqsave(&card->ctl\_files\_rwlock, flags); list\_del(&ctl->list); write\_unlock\_irqrestore(&card->ctl\_files\_rwlock, flags); down\_write(&card->controls\_rwsem); list\_for\_each\_entry(control, &card->controls, list) for (idx = 0; idx < control->count; idx++) if (control->vd[idx].owner == ctl) control->vd[idx].owner = NULL; up\_write(&card->controls\_rwsem); snd\_ctl\_empty\_read\_queue(ctl); put\_pid(ctl->pid); kfree(ctl); module\_put(card->module); snd\_card\_file\_remove(card, file); return 0;}
/\*\* \* snd\_ctl\_notify - Send notification to user-space for a control change \* @card: the card to send notification \* @mask: the event mask, SNDRV\_CTL\_EVENT\_\* \* @id: the ctl element id to send notification \* \* This function adds an event record with the given id and mask, appends \* to the list and wakes up the user-space for notification. This can be \* called in the atomic context. \*/void snd\_ctl\_notify(struct snd\_card \*card, unsigned int mask, struct snd\_ctl\_elem\_id \*id){ unsigned long flags; struct snd\_ctl\_file \*ctl; struct snd\_kctl\_event \*ev;
 if (snd\_BUG\_ON(!card || !id)) return; if (card->shutdown) return; read\_lock(&card->ctl\_files\_rwlock);#if IS\_ENABLED(CONFIG\_SND\_MIXER\_OSS) card->mixer\_oss\_change\_count++;#endif list\_for\_each\_entry(ctl, &card->ctl\_files, list) { if (!ctl->subscribed) continue; spin\_lock\_irqsave(&ctl->read\_lock, flags); list\_for\_each\_entry(ev, &ctl->events, list) { if (ev->id.numid == id->numid) { ev->mask |= mask; goto \_found; } } ev = kzalloc(sizeof(\*ev), GFP\_ATOMIC); if (ev) { ev->id = \*id; ev->mask = mask; list\_add\_tail(&ev->list, &ctl->events); } else { dev\_err(card->dev, "No memory available to allocate event\n"); } \_found: wake\_up(&ctl->change\_sleep); spin\_unlock\_irqrestore(&ctl->read\_lock, flags); kill\_fasync(&ctl->fasync, SIGIO, POLL\_IN); } read\_unlock(&card->ctl\_files\_rwlock);}EXPORT\_SYMBOL(snd\_ctl\_notify);
/\*\* \* snd\_ctl\_new - create a new control instance with some elements \* @kctl: the pointer to store new control instance \* @count: the number of elements in this control \* @access: the default access flags for elements in this control \* @file: given when locking these elements \* \* Allocates a memory object for a new control instance. The instance has \* elements as many as the given number (@count). Each element has given \* access permissions (@access). Each element is locked when @file is given. \* \* Return: 0 on success, error code on failure \*/static int snd\_ctl\_new(struct snd\_kcontrol \*\*kctl, unsigned int count, unsigned int access, struct snd\_ctl\_file \*file){ unsigned int idx;
 if (count == 0 || count > MAX\_CONTROL\_COUNT) return -EINVAL;
 \*kctl = kzalloc(struct\_size(\*kctl, vd, count), GFP\_KERNEL); if (!\*kctl) return -ENOMEM;
 for (idx = 0; idx < count; idx++) { (\*kctl)->vd[idx].access = access; (\*kctl)->vd[idx].owner = file; } (\*kctl)->count = count;
 return 0;}
/\*\* \* snd\_ctl\_new1 - create a control instance from the template \* @ncontrol: the initialization record \* @private\_data: the private data to set \* \* Allocates a new struct snd\_kcontrol instance and initialize from the given \* template. When the access field of ncontrol is 0, it's assumed as \* READWRITE access. When the count field is 0, it's assumes as one. \* \* Return: The pointer of the newly generated instance, or %NULL on failure. \*/struct snd\_kcontrol \*snd\_ctl\_new1(const struct snd\_kcontrol\_new \*ncontrol, void \*private\_data){ struct snd\_kcontrol \*kctl; unsigned int count; unsigned int access; int err;
 if (snd\_BUG\_ON(!ncontrol || !ncontrol->info)) return NULL;
 count = ncontrol->count; if (count == 0) count = 1;
 access = ncontrol->access; if (access == 0) access = SNDRV\_CTL\_ELEM\_ACCESS\_READWRITE; access &= (SNDRV\_CTL\_ELEM\_ACCESS\_READWRITE | SNDRV\_CTL\_ELEM\_ACCESS\_VOLATILE | SNDRV\_CTL\_ELEM\_ACCESS\_INACTIVE | SNDRV\_CTL\_ELEM\_ACCESS\_TLV\_READWRITE | SNDRV\_CTL\_ELEM\_ACCESS\_TLV\_COMMAND | SNDRV\_CTL\_ELEM\_ACCESS\_TLV\_CALLBACK | SNDRV\_CTL\_ELEM\_ACCESS\_SKIP\_CHECK);
 err = snd\_ctl\_new(&kctl, count, access, NULL); if (err < 0) return NULL;
 /\* The 'numid' member is decided when calling snd\_ctl\_add(). \*/ kctl->id.iface = ncontrol->iface; kctl->id.device = ncontrol->device; kctl->id.subdevice = ncontrol->subdevice; if (ncontrol->name) { strlcpy(kctl->id.name, ncontrol->name, sizeof(kctl->id.name)); if (strcmp(ncontrol->name, kctl->id.name) != 0) pr\_warn("ALSA: Control name '%s' truncated to '%s'\n", ncontrol->name, kctl->id.name); } kctl->id.index = ncontrol->index;
 kctl->info = ncontrol->info; kctl->get = ncontrol->get; kctl->put = ncontrol->put; kctl->tlv.p = ncontrol->tlv.p;
 kctl->private\_value = ncontrol->private\_value; kctl->private\_data = private\_data;
 return kctl;}EXPORT\_SYMBOL(snd\_ctl\_new1);
/\*\* \* snd\_ctl\_free\_one - release the control instance \* @kcontrol: the control instance \* \* Releases the control instance created via snd\_ctl\_new() \* or snd\_ctl\_new1(). \* Don't call this after the control was added to the card. \*/void snd\_ctl\_free\_one(struct snd\_kcontrol \*kcontrol){ if (kcontrol) { if (kcontrol->private\_free) kcontrol->private\_free(kcontrol); kfree(kcontrol); }}EXPORT\_SYMBOL(snd\_ctl\_free\_one);
static bool snd\_ctl\_remove\_numid\_conflict(struct snd\_card \*card, unsigned int count){ struct snd\_kcontrol \*kctl;
 /\* Make sure that the ids assigned to the control do not wrap around \*/ if (card->last\_numid >= UINT\_MAX - count) card->last\_numid = 0;
 list\_for\_each\_entry(kctl, &card->controls, list) { if (kctl->id.numid < card->last\_numid + 1 + count && kctl->id.numid + kctl->count > card->last\_numid + 1) { card->last\_numid = kctl->id.numid + kctl->count - 1; return true; } } return false;}
static int snd\_ctl\_find\_hole(struct snd\_card \*card, unsigned int count){ unsigned int iter = 100000;
 while (snd\_ctl\_remove\_numid\_conflict(card, count)) { if (--iter == 0) { /\* this situation is very unlikely \*/ dev\_err(card->dev, "unable to allocate new control numid\n"); return -ENOMEM; } } return 0;}
enum snd\_ctl\_add\_mode { CTL\_ADD\_EXCLUSIVE, CTL\_REPLACE, CTL\_ADD\_ON\_REPLACE,};
/\* add/replace a new kcontrol object; call with card->controls\_rwsem locked \*/static int \_\_snd\_ctl\_add\_replace(struct snd\_card \*card, struct snd\_kcontrol \*kcontrol, enum snd\_ctl\_add\_mode mode){ struct snd\_ctl\_elem\_id id; unsigned int idx; unsigned int count; struct snd\_kcontrol \*old; int err;
 id = kcontrol->id; if (id.index > UINT\_MAX - kcontrol->count) return -EINVAL;
 old = snd\_ctl\_find\_id(card, &id); if (!old) { if (mode == CTL\_REPLACE) return -EINVAL; } else { if (mode == CTL\_ADD\_EXCLUSIVE) { dev\_err(card->dev, "control %i:%i:%i:%s:%i is already present\n", id.iface, id.device, id.subdevice, id.name, id.index); return -EBUSY; }
 err = snd\_ctl\_remove(card, old); if (err < 0) return err; }
 if (snd\_ctl\_find\_hole(card, kcontrol->count) < 0) return -ENOMEM;
 list\_add\_tail(&kcontrol->list, &card->controls); card->controls\_count += kcontrol->count; kcontrol->id.numid = card->last\_numid + 1; card->last\_numid += kcontrol->count;
 id = kcontrol->id; count = kcontrol->count; for (idx = 0; idx < count; idx++, id.index++, id.numid++) snd\_ctl\_notify(card, SNDRV\_CTL\_EVENT\_MASK\_ADD, &id);
 return 0;}
static int snd\_ctl\_add\_replace(struct snd\_card \*card, struct snd\_kcontrol \*kcontrol, enum snd\_ctl\_add\_mode mode){ int err = -EINVAL;
 if (! kcontrol) return err; if (snd\_BUG\_ON(!card || !kcontrol->info)) goto error;
 down\_write(&card->controls\_rwsem); err = \_\_snd\_ctl\_add\_replace(card, kcontrol, mode); up\_write(&card->controls\_rwsem); if (err < 0) goto error; return 0;
 error: snd\_ctl\_free\_one(kcontrol); return err;}
/\*\* \* snd\_ctl\_add - add the control instance to the card \* @card: the card instance \* @kcontrol: the control instance to add \* \* Adds the control instance created via snd\_ctl\_new() or \* snd\_ctl\_new1() to the given card. Assigns also an unique \* numid used for fast search. \* \* It frees automatically the control which cannot be added. \* \* Return: Zero if successful, or a negative error code on failure. \* \*/int snd\_ctl\_add(struct snd\_card \*card, struct snd\_kcontrol \*kcontrol){ return snd\_ctl\_add\_replace(card, kcontrol, CTL\_ADD\_EXCLUSIVE);}EXPORT\_SYMBOL(snd\_ctl\_add);
/\*\* \* snd\_ctl\_replace - replace the control instance of the card \* @card: the card instance \* @kcontrol: the control instance to replace \* @add\_on\_replace: add the control if not already added \* \* Replaces the given control. If the given control does not exist \* and the add\_on\_replace flag is set, the control is added. If the \* control exists, it is destroyed first. \* \* It frees automatically the control which cannot be added or replaced. \* \* Return: Zero if successful, or a negative error code on failure. \*/int snd\_ctl\_replace(struct snd\_card \*card, struct snd\_kcontrol \*kcontrol, bool add\_on\_replace){ return snd\_ctl\_add\_replace(card, kcontrol, add\_on\_replace ? CTL\_ADD\_ON\_REPLACE : CTL\_REPLACE);}EXPORT\_SYMBOL(snd\_ctl\_replace);
/\*\* \* snd\_ctl\_remove - remove the control from the card and release it \* @card: the card instance \* @kcontrol: the control instance to remove \* \* Removes the control from the card and then releases the instance. \* You don't need to call snd\_ctl\_free\_one(). You must be in \* the write lock - down\_write(&card->controls\_rwsem). \* \* Return: 0 if successful, or a negative error code on failure. \*/int snd\_ctl\_remove(struct snd\_card \*card, struct snd\_kcontrol \*kcontrol){ struct snd\_ctl\_elem\_id id; unsigned int idx;
 if (snd\_BUG\_ON(!card || !kcontrol)) return -EINVAL; list\_del(&kcontrol->list); card->controls\_count -= kcontrol->count; id = kcontrol->id; for (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++) snd\_ctl\_notify(card, SNDRV\_CTL\_EVENT\_MASK\_REMOVE, &id); snd\_ctl\_free\_one(kcontrol); return 0;}EXPORT\_SYMBOL(snd\_ctl\_remove);
/\*\* \* snd\_ctl\_remove\_id - remove the control of the given id and release it \* @card: the card instance \* @id: the control id to remove \* \* Finds the control instance with the given id, removes it from the \* card list and releases it. \* \* Return: 0 if successful, or a negative error code on failure. \*/int snd\_ctl\_remove\_id(struct snd\_card \*card, struct snd\_ctl\_elem\_id \*id){ struct snd\_kcontrol \*kctl; int ret;
 down\_write(&card->controls\_rwsem); kctl = snd\_ctl\_find\_id(card, id); if (kctl == NULL) { up\_write(&card->controls\_rwsem); return -ENOENT; } ret = snd\_ctl\_remove(card, kctl); up\_write(&card->controls\_rwsem); return ret;}EXPORT\_SYMBOL(snd\_ctl\_remove\_id);
/\*\* \* snd\_ctl\_remove\_user\_ctl - remove and release the unlocked user control \* @file: active control handle \* @id: the control id to remove \* \* Finds the control instance with the given id, removes it from the \* card list and releases it. \* \* Return: 0 if successful, or a negative error code on failure. \*/static int snd\_ctl\_remove\_user\_ctl(struct snd\_ctl\_file \* file, struct snd\_ctl\_elem\_id \*id){ struct snd\_card \*card = file->card; struct snd\_kcontrol \*kctl; int idx, ret;
 down\_write(&card->controls\_rwsem); kctl = snd\_ctl\_find\_id(card, id); if (kctl == NULL) { ret = -ENOENT; goto error; } if (!(kctl->vd[0].access & SNDRV\_CTL\_ELEM\_ACCESS\_USER)) { ret = -EINVAL; goto error; } for (idx = 0; idx < kctl->count; idx++) if (kctl->vd[idx].owner != NULL && kctl->vd[idx].owner != file) { ret = -EBUSY; goto error; } ret = snd\_ctl\_remove(card, kctl); if (ret < 0) goto error; card->user\_ctl\_count--;error: up\_write(&card->controls\_rwsem); return ret;}
/\*\* \* snd\_ctl\_activate\_id - activate/inactivate the control of the given id \* @card: the card instance \* @id: the control id to activate/inactivate \* @active: non-zero to activate \* \* Finds the control instance with the given id, and activate or \* inactivate the control together with notification, if changed. \* The given ID data is filled with full information. \* \* Return: 0 if unchanged, 1 if changed, or a negative error code on failure. \*/int snd\_ctl\_activate\_id(struct snd\_card \*card, struct snd\_ctl\_elem\_id \*id, int active){ struct snd\_kcontrol \*kctl; struct snd\_kcontrol\_volatile \*vd; unsigned int index\_offset; int ret;
 down\_write(&card->controls\_rwsem); kctl = snd\_ctl\_find\_id(card, id); if (kctl == NULL) { ret = -ENOENT; goto unlock; } index\_offset = snd\_ctl\_get\_ioff(kctl, id); vd = &kctl->vd[index\_offset]; ret = 0; if (active) { if (!(vd->access & SNDRV\_CTL\_ELEM\_ACCESS\_INACTIVE)) goto unlock; vd->access &= ~SNDRV\_CTL\_ELEM\_ACCESS\_INACTIVE; } else { if (vd->access & SNDRV\_CTL\_ELEM\_ACCESS\_INACTIVE) goto unlock; vd->access |= SNDRV\_CTL\_ELEM\_ACCESS\_INACTIVE; } snd\_ctl\_build\_ioff(id, kctl, index\_offset); ret = 1; unlock: up\_write(&card->controls\_rwsem); if (ret > 0) snd\_ctl\_notify(card, SNDRV\_CTL\_EVENT\_MASK\_INFO, id); return ret;}EXPORT\_SYMBOL\_GPL(snd\_ctl\_activate\_id);
/\*\* \* snd\_ctl\_rename\_id - replace the id of a control on the card \* @card: the card instance \* @src\_id: the old id \* @dst\_id: the new id \* \* Finds the control with the old id from the card, and replaces the \* id with the new one. \* \* Return: Zero if successful, or a negative error code on failure. \*/int snd\_ctl\_rename\_id(struct snd\_card \*card, struct snd\_ctl\_elem\_id \*src\_id, struct snd\_ctl\_elem\_id \*dst\_id){ struct snd\_kcontrol \*kctl;
 down\_write(&card->controls\_rwsem); kctl = snd\_ctl\_find\_id(card, src\_id); if (kctl == NULL) { up\_write(&card->controls\_rwsem); return -ENOENT; } kctl->id = \*dst\_id; kctl->id.numid = card->last\_numid + 1; card->last\_numid += kctl->count; up\_write(&card->controls\_rwsem); return 0;}EXPORT\_SYMBOL(snd\_ctl\_rename\_id);
/\*\* \* snd\_ctl\_find\_numid - find the control instance with the given number-id \* @card: the card instance \* @numid: the number-id to search \* \* Finds the control instance with the given number-id from the card. \* \* The caller must down card->controls\_rwsem before calling this function \* (if the race condition can happen). \* \* Return: The pointer of the instance if found, or %NULL if not. \* \*/struct snd\_kcontrol \*snd\_ctl\_find\_numid(struct snd\_card \*card, unsigned int numid){ struct snd\_kcontrol \*kctl;
 if (snd\_BUG\_ON(!card || !numid)) return NULL; list\_for\_each\_entry(kctl, &card->controls, list) { if (kctl->id.numid <= numid && kctl->id.numid + kctl->count > numid) return kctl; } return NULL;}EXPORT\_SYMBOL(snd\_ctl\_find\_numid);
/\*\* \* snd\_ctl\_find\_id - find the control instance with the given id \* @card: the card instance \* @id: the id to search \* \* Finds the control instance with the given id from the card. \* \* The caller must down card->controls\_rwsem before calling this function \* (if the race condition can happen). \* \* Return: The pointer of the instance if found, or %NULL if not. \* \*/struct snd\_kcontrol \*snd\_ctl\_find\_id(struct snd\_card \*card, struct snd\_ctl\_elem\_id \*id){ struct snd\_kcontrol \*kctl;
 if (snd\_BUG\_ON(!card || !id)) return NULL; if (id->numid != 0) return snd\_ctl\_find\_numid(card, id->numid); list\_for\_each\_entry(kctl, &card->controls, list) { if (kctl->id.iface != id->iface) continue; if (kctl->id.device != id->device) continue; if (kctl->id.subdevice != id->subdevice) continue; if (strncmp(kctl->id.name, id->name, sizeof(kctl->id.name))) continue; if (kctl->id.index > id->index) continue; if (kctl->id.index + kctl->count <= id->index) continue; return kctl; } return NULL;}EXPORT\_SYMBOL(snd\_ctl\_find\_id);
static int snd\_ctl\_card\_info(struct snd\_card \*card, struct snd\_ctl\_file \* ctl, unsigned int cmd, void \_\_user \*arg){ struct snd\_ctl\_card\_info \*info;
 info = kzalloc(sizeof(\*info), GFP\_KERNEL); if (! info) return -ENOMEM; down\_read(&snd\_ioctl\_rwsem); info->card = card->number; strlcpy(info->id, card->id, sizeof(info->id)); strlcpy(info->driver, card->driver, sizeof(info->driver)); strlcpy(info->name, card->shortname, sizeof(info->name)); strlcpy(info->longname, card->longname, sizeof(info->longname)); strlcpy(info->mixername, card->mixername, sizeof(info->mixername)); strlcpy(info->components, card->components, sizeof(info->components)); up\_read(&snd\_ioctl\_rwsem); if (copy\_to\_user(arg, info, sizeof(struct snd\_ctl\_card\_info))) { kfree(info); return -EFAULT; } kfree(info); return 0;}
static int snd\_ctl\_elem\_list(struct snd\_card \*card, struct snd\_ctl\_elem\_list \_\_user \*\_list){ struct snd\_ctl\_elem\_list list; struct snd\_kcontrol \*kctl; struct snd\_ctl\_elem\_id id; unsigned int offset, space, jidx; int err = 0;
 if (copy\_from\_user(&list, \_list, sizeof(list))) return -EFAULT; offset = list.offset; space = list.space;
 down\_read(&card->controls\_rwsem); list.count = card->controls\_count; list.used = 0; if (space > 0) { list\_for\_each\_entry(kctl, &card->controls, list) { if (offset >= kctl->count) { offset -= kctl->count; continue; } for (jidx = offset; jidx < kctl->count; jidx++) { snd\_ctl\_build\_ioff(&id, kctl, jidx); if (copy\_to\_user(list.pids + list.used, &id, sizeof(id))) { err = -EFAULT; goto out; } list.used++; if (!--space) goto out; } offset = 0; } } out: up\_read(&card->controls\_rwsem); if (!err && copy\_to\_user(\_list, &list, sizeof(list))) err = -EFAULT; return err;}
/\* Check whether the given kctl info is valid \*/static int snd\_ctl\_check\_elem\_info(struct snd\_card \*card, const struct snd\_ctl\_elem\_info \*info){ static const unsigned int max\_value\_counts[] = { [SNDRV\_CTL\_ELEM\_TYPE\_BOOLEAN] = 128, [SNDRV\_CTL\_ELEM\_TYPE\_INTEGER] = 128, [SNDRV\_CTL\_ELEM\_TYPE\_ENUMERATED] = 128, [SNDRV\_CTL\_ELEM\_TYPE\_BYTES] = 512, [SNDRV\_CTL\_ELEM\_TYPE\_IEC958] = 1, [SNDRV\_CTL\_ELEM\_TYPE\_INTEGER64] = 64, };
 if (info->type < SNDRV\_CTL\_ELEM\_TYPE\_BOOLEAN || info->type > SNDRV\_CTL\_ELEM\_TYPE\_INTEGER64) { if (card) dev\_err(card->dev, "control %i:%i:%i:%s:%i: invalid type %d\n", info->id.iface, info->id.device, info->id.subdevice, info->id.name, info->id.index, info->type); return -EINVAL; } if (info->type == SNDRV\_CTL\_ELEM\_TYPE\_ENUMERATED && info->value.enumerated.items == 0) { if (card) dev\_err(card->dev, "control %i:%i:%i:%s:%i: zero enum items\n", info->id.iface, info->id.device, info->id.subdevice, info->id.name, info->id.index); return -EINVAL; } if (info->count > max\_value\_counts[info->type]) { if (card) dev\_err(card->dev, "control %i:%i:%i:%s:%i: invalid count %d\n", info->id.iface, info->id.device, info->id.subdevice, info->id.name, info->id.index, info->count); return -EINVAL; }
 return 0;}
/\* The capacity of struct snd\_ctl\_elem\_value.value.\*/static const unsigned int value\_sizes[] = { [SNDRV\_CTL\_ELEM\_TYPE\_BOOLEAN] = sizeof(long), [SNDRV\_CTL\_ELEM\_TYPE\_INTEGER] = sizeof(long), [SNDRV\_CTL\_ELEM\_TYPE\_ENUMERATED] = sizeof(unsigned int), [SNDRV\_CTL\_ELEM\_TYPE\_BYTES] = sizeof(unsigned char), [SNDRV\_CTL\_ELEM\_TYPE\_IEC958] = sizeof(struct snd\_aes\_iec958), [SNDRV\_CTL\_ELEM\_TYPE\_INTEGER64] = sizeof(long long),};
#ifdef CONFIG\_SND\_CTL\_VALIDATION/\* fill the remaining snd\_ctl\_elem\_value data with the given pattern \*/static void fill\_remaining\_elem\_value(struct snd\_ctl\_elem\_value \*control, struct snd\_ctl\_elem\_info \*info, u32 pattern){ size\_t offset = value\_sizes[info->type] \* info->count;
 offset = (offset + sizeof(u32) - 1) / sizeof(u32); memset32((u32 \*)control->value.bytes.data + offset, pattern, sizeof(control->value) / sizeof(u32) - offset);}
/\* check whether the given integer ctl value is valid \*/static int sanity\_check\_int\_value(struct snd\_card \*card, const struct snd\_ctl\_elem\_value \*control, const struct snd\_ctl\_elem\_info \*info, int i){ long long lval, lmin, lmax, lstep; u64 rem;
 switch (info->type) { default: case SNDRV\_CTL\_ELEM\_TYPE\_BOOLEAN: lval = control->value.integer.value[i]; lmin = 0; lmax = 1; lstep = 0; break; case SNDRV\_CTL\_ELEM\_TYPE\_INTEGER: lval = control->value.integer.value[i]; lmin = info->value.integer.min; lmax = info->value.integer.max; lstep = info->value.integer.step; break; case SNDRV\_CTL\_ELEM\_TYPE\_INTEGER64: lval = control->value.integer64.value[i]; lmin = info->value.integer64.min; lmax = info->value.integer64.max; lstep = info->value.integer64.step; break; case SNDRV\_CTL\_ELEM\_TYPE\_ENUMERATED: lval = control->value.enumerated.item[i]; lmin = 0; lmax = info->value.enumerated.items - 1; lstep = 0; break; }
 if (lval < lmin || lval > lmax) { dev\_err(card->dev, "control %i:%i:%i:%s:%i: value out of range %lld (%lld/%lld) at count %i\n", control->id.iface, control->id.device, control->id.subdevice, control->id.name, control->id.index, lval, lmin, lmax, i); return -EINVAL; } if (lstep) { div64\_u64\_rem(lval, lstep, &rem); if (rem) { dev\_err(card->dev, "control %i:%i:%i:%s:%i: unaligned value %lld (step %lld) at count %i\n", control->id.iface, control->id.device, control->id.subdevice, control->id.name, control->id.index, lval, lstep, i); return -EINVAL; } }
 return 0;}
/\* perform sanity checks to the given snd\_ctl\_elem\_value object \*/static int sanity\_check\_elem\_value(struct snd\_card \*card, const struct snd\_ctl\_elem\_value \*control, const struct snd\_ctl\_elem\_info \*info, u32 pattern){ size\_t offset; int i, ret = 0; u32 \*p;
 switch (info->type) { case SNDRV\_CTL\_ELEM\_TYPE\_BOOLEAN: case SNDRV\_CTL\_ELEM\_TYPE\_INTEGER: case SNDRV\_CTL\_ELEM\_TYPE\_INTEGER64: case SNDRV\_CTL\_ELEM\_TYPE\_ENUMERATED: for (i = 0; i < info->count; i++) { ret = sanity\_check\_int\_value(card, control, info, i); if (ret < 0) return ret; } break; default: break; }
 /\* check whether the remaining area kept untouched \*/ offset = value\_sizes[info->type] \* info->count; offset = (offset + sizeof(u32) - 1) / sizeof(u32); p = (u32 \*)control->value.bytes.data + offset; for (; offset < sizeof(control->value) / sizeof(u32); offset++, p++) { if (\*p != pattern) { ret = -EINVAL; break; } \*p = 0; /\* clear the checked area \*/ }
 return ret;}#elsestatic inline void fill\_remaining\_elem\_value(struct snd\_ctl\_elem\_value \*control, struct snd\_ctl\_elem\_info \*info, u32 pattern){}
static inline int sanity\_check\_elem\_value(struct snd\_card \*card, struct snd\_ctl\_elem\_value \*control, struct snd\_ctl\_elem\_info \*info, u32 pattern){ return 0;}#endif
static int \_\_snd\_ctl\_elem\_info(struct snd\_card \*card, struct snd\_kcontrol \*kctl, struct snd\_ctl\_elem\_info \*info, struct snd\_ctl\_file \*ctl){ struct snd\_kcontrol\_volatile \*vd; unsigned int index\_offset; int result;
#ifdef CONFIG\_SND\_DEBUG info->access = 0;#endif result = kctl->info(kctl, info); if (result >= 0) { snd\_BUG\_ON(info->access); index\_offset = snd\_ctl\_get\_ioff(kctl, &info->id); vd = &kctl->vd[index\_offset]; snd\_ctl\_build\_ioff(&info->id, kctl, index\_offset); info->access = vd->access; if (vd->owner) { info->access |= SNDRV\_CTL\_ELEM\_ACCESS\_LOCK; if (vd->owner == ctl) info->access |= SNDRV\_CTL\_ELEM\_ACCESS\_OWNER; info->owner = pid\_vnr(vd->owner->pid); } else { info->owner = -1; } if (!snd\_ctl\_skip\_validation(info) && snd\_ctl\_check\_elem\_info(card, info) < 0) result = -EINVAL; } return result;}
static int snd\_ctl\_elem\_info(struct snd\_ctl\_file \*ctl, struct snd\_ctl\_elem\_info \*info){ struct snd\_card \*card = ctl->card; struct snd\_kcontrol \*kctl; int result;
 down\_read(&card->controls\_rwsem); kctl = snd\_ctl\_find\_id(card, &info->id); if (kctl == NULL) result = -ENOENT; else result = \_\_snd\_ctl\_elem\_info(card, kctl, info, ctl); up\_read(&card->controls\_rwsem); return result;}
static int snd\_ctl\_elem\_info\_user(struct snd\_ctl\_file \*ctl, struct snd\_ctl\_elem\_info \_\_user \*\_info){[View remainder of file in raw view](https://github.com/torvalds/linux/raw/3b2549a3740efb8af0150415737067d87e466c5b/sound/core/control.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from twitter.com_a59656d9_20250119_112614.html ===



=== Content from lore.kernel.org_ab950b20_20250119_112612.html ===

```
[alsa-devel.alsa-project.org archive mirror](../?t=20200414065544)
 [help](../_/text/help/) / [color](../_/text/color/) / [mirror](../_/text/mirror/) / [Atom feed](../new.atom)
```
```
From: Takashi Iwai <tiwai@suse.de>
To: yangerkun <yangerkun@huawei.com>
Cc: [alsa-devel@alsa-project.org](../../alsa-devel/?t=20200414065544), tiwai@suse.com
Subject: [Re: [RFC v2] ALSA: control: fix a error handling exist in snd_ctl_elem_add](#r)
Date: Tue, 14 Apr 2020 08:54:34 +0200	[[thread overview]](#r)
Message-ID: <s5h4ktmlfpx.wl-tiwai@suse.de> (<raw>)
In-Reply-To: <[20200414065109.6923-1-yangerkun@huawei.com](../20200414065109.6923-1-yangerkun%40huawei.com/)>

On Tue, 14 Apr 2020 08:51:09 +0200,
yangerkun wrote:
>
> CVE-2020-11725 report that 'count = info->owner' may result a
> SIZE_OVERFLOW. 'info->owner' represent a pid, and actually, we should
> use info->count.
>
> Signed-off-by: yangerkun <yangerkun@huawei.com>

The CVE report is simply wrong.  info->owner is used intentionally for
this specific API to add a user-space control.  For the normal kernel
kctls, the field is used indeed for storing the pid, but but the
user-space kctl addition API usage is an exception.

You can see the another use of info->count of field in the very same
function at a later point and find it has a different meaning.

The CVE should be disputed.

thanks,

Takashi

> ---
>  sound/core/control.c | 2 +-
>  1 file changed, 1 insertion(+), 1 deletion(-)
>
> v1->v2: reword the patch head
>
> diff --git a/sound/core/control.c b/sound/core/control.c
> index aa0c0cf182af..c77ca7f39637 100644
> --- a/sound/core/control.c
> +++ b/sound/core/control.c
> @@ -1431,7 +1431,7 @@ static int snd_ctl_elem_add(struct snd_ctl_file *file,
>  		return -ENOMEM;
>
>  	/* Check the number of elements for this userspace control. */
> -	count = info->owner;
> +	count = info->count;
>  	if (count == 0)
>  		count = 1;
>
> --
> 2.21.1
>

```

---

```
[next](../59873ec6-b18c-a241-40c0-da75d089b128%40huawei.com/) [prev parent](../20200414065109.6923-1-yangerkun%40huawei.com/) [reply](#R)other threads:[[~2020-04-14  6:55 UTC](../?t=20200414065544)|[newest](../)]

Thread overview: 3+ messages / expand[[flat](T/#u)|[nested](t/#u)]  [mbox.gz](t.mbox.gz)  [Atom feed](t.atom)  [top](#b)
2020-04-14  6:51 [[RFC v2] ALSA: control: fix a error handling exist in snd_ctl_elem_add](../20200414065109.6923-1-yangerkun%40huawei.com/) yangerkun
2020-04-14  6:54 ` [Takashi Iwai [this message]](#t)
2020-04-14  9:03   ` [yangerkun](../59873ec6-b18c-a241-40c0-da75d089b128%40huawei.com/)

```

---

```
Reply instructions:

You may reply publicly to [this message](#t) via plain-text email
using any one of the following methods:

* Save the following mbox file, import it into your mail client,
  and reply-to-all from there: [mbox](raw)

  Avoid top-posting and favor interleaved quoting:
  <https://en.wikipedia.org/wiki/Posting_style#Interleaved_style>

* Reply using the --to, --cc, and --in-reply-to
  switches of git-send-email(1):

  git send-email \
    --in-reply-to=s5h4ktmlfpx.wl-tiwai@suse.de \
    --to=tiwai@suse.de \
    --cc=alsa-devel@alsa-project.org \
    --cc=tiwai@suse.com \
    --cc=yangerkun@huawei.com \
    /path/to/YOUR_REPLY

  <https://kernel.org/pub/software/scm/git/docs/git-send-email.html>

* If your mail client supports setting the In-Reply-To header
  via mailto: links, try the mailto: link

```
Be sure your reply has a **Subject:** header at the top and a blank line
before the message body.

---

```
This is a public inbox, see [mirroring instructions](../_/text/mirror/)
for how to clone and mirror all data and code used for this inbox;
as well as URLs for NNTP newsgroup(s).
```

