```json
{
  "vulnerability": {
    "root_cause": "An out-of-bounds read vulnerability exists in `rdp_read_share_control_header` function.",
    "weaknesses": [
      "Out-of-bounds read"
    ],
    "impact": "A malicious RDP server can cause a FreeRDP client to read data from outside of allocated buffer, potentially causing a crash or information leak.",
    "attack_vectors": "A malicious RDP server sends a crafted packet with specific length values.",
    "required_attacker_capabilities": "Attacker controls the RDP server or can intercept and manipulate RDP traffic."
  },
    "additional_info": {
        "affected_versions": "FreeRDP versions after 1.1 and before 2.0.0",
        "patch": "Fixed in FreeRDP version 2.0.0, see https://github.com/FreeRDP/FreeRDP/pull/6019 for the fix details",
    "vulnerable_code": "```c\nBOOL rdp_read_share_control_header(wStream* s, UINT16* length, UINT16* type, UINT16* channel_id)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, *length); /* totalLength */\n\n\tif (((size_t)*length - 2) > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, *type); /* pduType */\n\t*type &= 0x0F;                /* type is in the 4 least significant bits */\n\n\tif (*length > 4)\n\t\tStream_Read_UINT16(s, *channel_id);   // memory out of bounds read\n\treturn TRUE;\n}\n```",
       "details": "The vulnerability occurs because the function `rdp_read_share_control_header` reads a length value from the stream, and if the total length field is greater than 4 bytes then the channel id is read. However, there is insufficient bounds checking for when the length is equal to the remaining length of the stream causing an out-of-bounds read when accessing the channel id value. If the remaining stream length is exactly 5 and the read length is set to 5 then reading the channel id will cause a single byte out of bounds read. "
   }
}
```