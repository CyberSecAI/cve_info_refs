=== Content from www.usenix.org_45f89e59_20250119_115159.html ===
One Exploit to Rule them All?
On the Security of Drop-in Replacement and Counterfeit Microcontrollers

Johannes Obermaier
mail@obermaier-johannes.de

Marc Schink
mail@marcschink.de

Kosma Moczek
kosma@kosma.pl

Abstract
With the increasing complexity of embedded systems, the
ﬁrmware has become a valuable asset. At the same time,
pressure for cost reductions in hardware is imminent. These
two aspects are united at the heart of the system, i.e., the
microcontroller. It runs and protects its ﬁrmware, but simul-
taneously has to prevail against cheaper alternatives. For the
very popular STM32F1 microcontroller series, this has caused
the emergence of many competitors in the last few years who
offer drop-in replacements or even sell counterfeit devices at
a fraction of the original price. Thus, the question emerges
whether the replacements are silicon-level clones and, if not,
whether they provide better, equal, or less security. In this
paper, we analyze a total of six devices by four manufacturers,
including the original device, in depth. Via a low-level analy-
sis, we identify all of them as being individually developed
devices. We further put the focus on debug and hardware se-
curity, discovering several novel vulnerabilities in all devices,
causing the exposure of the entire ﬁrmware. All of the pre-
sented vulnerabilities, including invasive ones, are on a Do it
Yourself (DiY) level without the demand for a sophisticated
lab – thereby underlining the urgency for hardware ﬁxes. To
facilitate further research, reproduction, and testing of other
devices, we provide a comprehensive description of all vulner-
abilities in this paper and code for proofs-of-concepts online.

1 Introduction

Well-established markets attract competitors who try to gain
a foothold. Products of equal or more beneﬁt for the customer
are pushed into the market as drop-in replacements. They
usually offer more functionality, a lower price, or even both.
Competitors, who join later, often require less investments
since the market is already established and they save resources
during development by learning from the original product. In
its most extreme forms, this corresponds to a precise copying
of products, often called product piracy.

Counterfeit and pirated goods reach market volumes of
hundreds of billions USD each year with a large share being

electronics [14]. On a high-level view, microcontrollers play
two major roles for two different stakeholders in terms of
product piracy and drop-in replacements: First, there are the
users of the microcontrollers who employ them in their em-
bedded systems. The users expect reliable functionality and
secure storage of their valuable ﬁrmware against unauthorized
readout, e.g., by competitors trying to clone the product. Sec-
ondly, there are the manufacturers of the microcontrollers who
are affected by replacement or counterfeit microcontrollers
that could push them, at least partially, out of the market.

The topic becomes especially crucial when the two aspects,
replacement microcontrollers and system security, are com-
bined. Often, the source of replacement devices remains un-
clear: They could either be identical clones, manufactured by
somehow obtained manufacturing data, silicon-design reverse-
engineering [15], or manually and as-good-as-possible recre-
ated according to publicly available information such as
datasheets. Especially in the latter case, key security aspects
might have been implemented differently, resulting in better,
similar, or worse ﬁrmware readout protection.

1.1 Related Work

One popular series is the STM32F1 family of microcontrollers
by STMicroelectronics (ST). For several years, numerous
drop-in replacements, alleging full compatibility, have been
appearing, but in different ﬂavors [1, 6, 9–11]. Counterfeit
chips, incorrectly marked as legitimate STM32F1, have been
reported [7] as well as devices stating their correct origin and
claiming only compatibility.

As of 2020, it seems that those companies, mostly founded
in the Asian region, try to push into new markets rather offen-
sively. For instance, in an electronics exhibition in Germany,
a representative of GigaDevice (GD) approached and out-
rightly asked the authors of this paper, whether they are using
any STM32 products that they could replace. However, those
manufacturers commonly disclose very little information on
whether the silicon-design is indeed identical and if the secu-
rity features are sufﬁciently implemented and tested.

Thus, two questions arise: First, whether the devices are
indeed identical to the original microcontrollers or if they
are just re-implementations of them. Secondly, and which is
even more important, whether these devices provide better,
identical, or worse security, compared to the original device.
For the analyzed STM32F1 series, the answer could be
unsettling: Although not affected by the STM32F0 vulnera-
bility [13], researchers discovered another hardware design
ﬂaw that exposes up to 94 % of the ﬁrmware [17]. On the one
hand, replacement manufacturers could have (inadvertently)
closed this vulnerability, resulting in higher security than in
the original device. On the other hand, inapt implementations
might cause even bigger issues, decreasing security again.

In this paper, we focus on the security of those devices
in depth and shed some light on hardware design authentic-
ity. We acquired ﬁve STM32F1 replacement devices of three
manufacturers and analyze them together with the original de-
vice. We show that each device is a re-implementation of the
STM32F1. We discover that all the analyzed replacements, as
well as the original, have their individual vulnerabilities allow-
ing unauthorized extraction of 100 % of their ﬁrmware with
low-cost DiY methods and no need for a sophisticated lab.

1.2 Contributions

In this paper, we present an in-depth analysis of the original
and replacement STM32F1 series comprising:

• A physical and low-level hardware analysis, proving that

each device is an independent re-implementation

• An in-depth security analysis of the original device and

ﬁve replacements

• Discovery and description of more than ten vulnerabili-
ties, allowing for 100 % ﬁrmware extraction from every
device, i.e.,

– Multiple severe debug interface vulnerabilities

– Invasive hardware attacks on multi-die systems

– A power glitch exploiting software live-patching

• A demonstration that the attacks, including the invasive

ones, can be brought down to a low-cost DiY level

• Proofs-of-Concepts for each discovered vulnerability,
also published online together with further materials

1.3 Structure

In the next section, we state the scope of analyzed devices. We
continue with an overview of the security concept in Section 3.
First, we take a detailed look at the physical differences of the
microcontrollers in Section 4. Next, in Section 5, we derive
software and hardware attack vectors on the devices with the
focus on DiY approaches. Then, we analyze all devices for

Figure 1: The Devices under Test, listed in Table 1.

debug interface vulnerabilities and describe their exploitation
in Section 6. Additionally, we demonstrate invasive attacks
in Section 7. We discuss countermeasures in Section 8 and
conclude our paper in Section 9.

2 Devices under Test

For our analysis, we chose ﬁve replacements and an origi-
nal device of the very popular STM32F103, a member of
the STM32F1 family. They are shown in Figure 1 and listed
in Table 1. In 2020, all these devices were available on the
free market, sometimes advertised as STM32F103 drop-in
replacements. The devices are based on an ARM Cortex-M3,
except for the GD32VF103 that instead contains a RISC-V
core. The GD32F130 is a special case as it does not have a
direct STM32 counterpart; however, it appears to be a reﬁned
GD32F103 with additional capabilities, and most interest-
ingly, extended security features. Thus, we analyze a broad
range of devices form drop-in replacements to upgrades.

The extended chip names, given in braces in Table 1, pri-
marily denote the available memory and IC package. We
experimented mainly with C8T6 devices containing 64 KiB
ﬂash memory. If unavailable, we switched to CBT6 devices
offering twice the ﬂash memory. Although not tested due to
the sheer number of device variations, our results will very
likely apply to other variants as well.

While acquiring our devices under test (DuTs), we noticed
that some vendors undercut the usual price of an STM32F103
by far; thus, we ordered a batch for analysis. Although com-
ponents marked with STM32F103C8T6 were delivered, the
debugger warned us that the IDCODE 0x2BA01477 does not
match the expected value of 0x1BA01477. Under strong illu-
mination and by tilting the device, a very faint CKS marking
appears, as shown in Figure 2. This part of the marking ex-
actly matches an actual CKS32F103 device, hence, counter-
feit STM32F103 with a manipulated marking were delivered.
Thus, users have a risk of unintentionally employing counter-
feit devices in their systems – including their vulnerabilities
that we describe in the paper.

Figure 2: Under special illumination and image enhancements
(center), the counterfeit STM32F103 (left) reveals the CKS
marking of the actual chip (right).

Table 1: List of devices selected for analysis.

Device

Manufacturer

STM32F103(C8T6)

STMicroelectronics

APM32F103(CBT6)

Apex Microelectronics

CKS32F103(C8T6)

GD32F103(C8T6)

GD32F130(C8T6)

GD32VF103(CBT6)

China Key System &
Integrated Circuit

Gigadevice

3 Security Concept

The conﬁdentiality of the internal ﬂash memory is the main
aspect in the microcontrollers’ security concept. For that, the
RDP level represents the security conﬁguration of the device,
deﬁning the debug interface permissions [19]. All analyzed
devices support two RDP levels, except the GD32F130 which
has three levels [11]. In level 0, the chip is entirely unprotected
and ﬂash memory can be read and written by the debugger.
This mode is used during development, for example. In level 1,
the debug interface is still enabled and SRAM is accessible,
however, debug access to ﬂash memory will be blocked and
the ﬁrmware remains protected. In level 2, only supported by
the GD32F130, the debug interface is shut down, thus, neither
a debugger can be attached, nor ﬂash memory is readable.

The RDP conﬁguration is stored as a 16-bit value in the op-
tion bytes region within the ﬂash memory. Its value is loaded
once during device startup. For level 0, the value is 0xA55A,
and for level 2, the value is 0xCC33. All other values map to
level 1. Upgrading security is always possible, downgrading
security triggers ﬁrmware erasure in level 1 and is impossible
in level 2.

The device supports booting from SRAM and ﬂash mem-
ory, selected by the BOOT0 pin. Usually, the signal is set to 0
and the device boots from ﬂash memory. If driven to 1, the
device boots a temporary ﬁrmware previously loaded into
the SRAM. If at least RDP level 1 is set and SRAM-boot is
selected, access to ﬂash memory is prevented [19].

4 Hardware Analysis

In this section, we identify similarities and differences be-
tween the devices, discovering verbatim copied parts and
individual developments.

4.1

Integrated Bootloader

Each device contains a bootloader ﬁrmware that is pre-
programmed by the manufacturer. A byte-wise compari-
son of the binaries shows that the bootloader ﬁrmware of
the APM32F103, the CKS32F103, and the STM32F103 are
more than 97 % identical. While having identical instructions,
they only differ in a few data constants such as serial num-
bers. Thus, the bootloader has clearly been copied from the
STM32F103 to the others.

In contrast to this, the bootloaders of the GD32F103 and
GD32F130 do not show any signiﬁcant similarities to other
devices. Although the bootloader implements a similar func-
tionality, it appears to be an own implementation and has
not been copied. The same is true for the bootloader of the
GD32VF103, since it is the only RISC-V based device. Alto-
gether, verbatim copying of the bootloader has been observed
for some, but not all devices.

4.2 CPU Core Revision

The Cortex-M3 core supports a CPUID register that indicates
its hardware revision and patch number. The STM32F103
shows a value of 0x411FC231, corresponding to revision 1.
In contrast to this, the APM32F103, CKS32F103, GD32F103,
and GD32F130 all indicate 0x412FC231, i.e., they are based
on the more recent CPU core (revision 2).

We veriﬁed that the indicated CPU revisions are correct
and not feigned. We successfully veriﬁed that the CPU hard-
ware erratum “532314: DWT CPI counter increments during
sleep” [4] is not present in the devices claiming revision 2.
Additionally, the size of the CPU’s vector table offset register
(VTOR) in these devices indeed supports two further bits [3],
compared to the previous revision [2]. Thus, the replacement
devices contain a more recent CPU core revision compared
to the STM32F103, strongly hinting at new developments.
However, this does still not allow to conclude whether all of
them are individual developments or just distributed under
different names.

4.3 Decapping of Devices

By opening the packages of the microcontrollers, called de-
capping, the internal silicon dies are exposed and become
visible for optical inspection to identify identical devices.

For the experiment, we heated the chips up with a labora-
tory hot plate and repeatedly applied sulfuric acid. After some
time, we were able to scrape away the top of the casing and

STM32F103C8T6

APM32F103CBT6 CKS32F103C8T6

GD32F103C8T6

GD32F130C8T6 GD32VF103CBT6

Figure 3: The silicon dies after decapping, true to scale; the
exact dimensions are listed in Table 3 in Appendix A.

exposed the die. The chips are not functional anymore, but
the dies stay intact as they are covered by a passivation layer.
The chips, shown in Figure 3, are very different from each
other, thus, all of them are individual developments. The sizes
of the dies vary widely, as listed in Table 3 in Appendix A,
even hinting at different manufacturing technologies. The
GD32 devices contain two dies in their package which was sel-
dom observed in microcontrollers. Further analysis showed, in
accordance with other analyses [12, 21], that the smaller chip
contains the ﬂash memory and the larger one incorporates the
remaining logic such as the CPU, SRAM, and peripherals.

system, a multitude of components is connected to the inter-
nal buses, as shown in Figure 4. The debug module, the CPU,
and the Direct Memory Access (DMA) module are masters
on the buses, thus, they can perform read-transactions from
ﬂash memory. For that, we test whether in RDP level 1,

• D0: the debugger can directly read out the memory. This

shows if security measures are implemented at all.

• D1: the CPU can be forced to leak ﬂash data via execut-

ing load instructions or interrupt vector fetches.

• D2: the DMA can be forced to read from ﬂash memory.

Regarding hardware-based attacks, we focus on low-cost at-
tacks which are executed with basic, easily available, and
comparably cheap tools. For that we test whether,

• H0: the debug interface is indeed shut down in RDP

level 2 (GD32F130 only).

• H1: data can physically be eavesdropped.

• H2: data or RDP levels can physically be manipulated.

• H3: power glitches can facilitate ﬁrmware extraction.

6 Debug Interface Analysis, Vulnerabilities,

and Exploits

In this section, we analyze the security implementations, out-
line the vulnerabilities, and demonstrate their exploitation.
All vulnerabilities, grouped by devices, and their CVEs are
summarized in Table 4 in Appendix D.

6.1 D0: Direct Debug Access

5 Analysis Approach and Attack Vectors

Affected: None

After setting each device to RDP level 1 and performing a
power cycle, the ﬂash memory is not readable via a debugger
anymore. Thus, all devices implement basic security features
that protect the ﬁrmware against direct readout.

6.2 D1-A: Load Instruction Exploitation

Affected: CKS32F103, GD32VF103

Although a debugger is prevented to directly read the ﬂash
memory, this is not always true for the CPU [5,16,17]. Even if
a device is in RDP level 1, debuggers are allowed to read and
write CPU registers, including halting and starting execution.
However, direct data reads via the CPU from ﬂash memory
are mostly blocked to prevent ﬁrmware extraction.

We discovered that this does not apply to the CKS32F103
and GD32VF103. In both systems, load instructions, e.g., ldr
for ARM and lw for RISC-V, are not sufﬁciently blocked if a
debugger is present.

Figure 4: Simpliﬁed block diagram of the internal buses of a
typical microcontroller.

The conﬁdentiality and integrity of the ﬂash memory con-
tents, i.e., the user’s data and ﬁrmware, is the primary goal of
the security concept. Since the previous physical comparison
showed no major similarities, the devices are analyzed for
security individually. At ﬁrst, we analyze the attack vectors
via the debug interface for devices set to RDP level 1. In the

CPUDebugBus MatrixICodeDCodeSystemDMADMAFlashmemorySRAMPeripheralsDBGFor the GD32VF103, ﬁrmware being executed from ﬂash
memory or SRAM is always allowed to read from the ﬂash
memory. Thus, for exploitation, an attacker loads an extraction
ﬁrmware into the SRAM. It comprises an lw s5, 0(s1)
instruction that loads data from the ﬂash address in register
s1 and copies it into register s5. The extraction ﬁrmware then
transmits the data to the attacker via a UART interface. The
extraction ﬁrmware repeatedly executes this instruction while
sweeping the address s1 over the entire ﬂash memory, thereby
extracting the ﬂash memory contents within a minute.

The CKS32F103 requires an alternative approach as only
code in the ﬂash memory but not in the SRAM is allowed to
access the ﬂash memory. Thus, the attacker needs to know the
location of an ldr instruction in the ﬂash memory beforehand
– what appears to be a chicken-and-egg problem. Although
trying to guess the location of an ldr is possible, reusing
the integrated bootloader makes the approach trivial. The
bootloader is always readable and contains several suited
gadget-instructions such as ldr r1, [r0]. It loads data from
the address in register r0 and copies it into the register r1.
By repeatedly executing this instruction via a debugger, while
sweeping the address in r0 over the entire ﬂash memory, the
ﬁrmware is extracted within ten minutes.

Both approaches were fully automatized, including ldr-
gadget detection and exploitation. The remaining microcon-
trollers did not exhibit this vulnerability. We tested various
further ARM data-access instructions including pop, ldrb,
ldrh, tbb, and tbh, without success.

6.3 D1-B: Extraction via Exceptions

Affected: STM32F103, APM32F103, CKS32F103

As illustrated in Figure 4, the ﬂash memory on an ARM
Cortex-M based device is accessed via the data bus and in-
struction bus. The data bus serves data and debug accesses;
the instruction bus is intended for instruction and interrupt
vector fetches from ﬂash memory [2].

We noticed that while a debugger is present in RDP level 1,
access to the ﬂash memory is only blocked for the data bus but
not for the instruction bus. Because interrupt vector fetches are
performed via the instruction bus, they always succeed even
with a debugger connected – resulting in a security weakness.
On exception entry, the CPU fetches the corresponding
interrupt handler address from the interrupt vector table in
ﬂash memory and loads this address into the program counter
(PC) register, accessible via the debugger. This allows an
adversary to read out ﬂash memory contents in the vector table
by deliberately generating exceptions via the debug interface
and observing the loaded vector address. By reconﬁguring the
CPU via the vector table offset register (VTOR) [2], the table
is relocated and the vectors are fetched from this alternative
address – thereby exposing further ﬂash memory contents.

An example vector table, relocated to different addresses
in ﬂash memory, is depicted in Figure 5. The beginning of

Figure 5: Vector table moved to another location in ﬂash mem-
ory via the VTOR. Inaccessible table entries are highlighted.

the vector table is determined by the VTOR. The number of
interrupts is implementation deﬁned and varies among the
different devices. Some entries in the vector table, marked in
red, are unused and therefore inaccessible by the processor.

For that reason, the attack is limited and the ﬂash memory
cannot be extracted entirely. However, by taking advantage of
the fact that external interrupts outside of the vector table are
wrapped around and mapped to the beginning of the vector
table, the number of inaccessible table entries is reduced.

This attack was already demonstrated for the STM32F1
series [17]. We tested this approach on further devices and
discovered that the APM32F103 and CKS32F103 series are
also affected. The extraction performance, listed in Table 2, is
comparable. The increasing coverage results from the fact that
more interrupts allow extracting inaccessible table entries by
exploiting the wrap-around behavior. Altogether, the results
show that up to 93.8 % of the ﬂash memory can be extracted,
taking less than an hour.

Table 2: Duration and coverage of the ﬁrmware extraction
process via deliberate exception generation.

Device

Interrupts Extraction time Coverage

STM32F103

APM32F103

CKS32F103

59

75

76

48 min

52 min

53 min

89.1 %

93.8 %

93.8 %

+0x10VTOR+0x20+0x30+0x400x0801 0000MSPMemManageDebugMonExt 0-ResetBusFaultExt 1--NMIUsageFaultPendSVExt 2-HardFaultSVCallSysTickExt 3VTOR0x0801 0080+0x70+0x10+0x20+0x30+0x40ResetMSPNMIHardFaultMemManageBusFaultUsageFaultSVCallDebugMonPendSVSysTickExt 0Ext 1Ext 2Ext 3+0x70Ext 12Ext 13Ext 14Ext 15----Ext 12-Ext 13Ext 14Ext 15-6.4 D1-C: VTOR Control Flow Redirection

Affected: GD32F103

We noticed that the GD32F103 continues execution even
when a debugger is attached. However, when the CPU debug
module is enabled (C_DEBUGEN bit in the DHCSR register [2]),
e.g., for halting the CPU or accessing processor registers, ﬂash
memory access becomes locked down for all bus masters,
including the CPU, and execution stops.

However, even if the C_DEBUGEN bit is not set, the remain-
ing system level components, such as SRAM and peripherals,
are still accessible since they are not part of the CPU. Thus,
one is allowed to write a ﬂash memory dumping ﬁrmware
into an unused region of the SRAM. Nevertheless, the CPU
cannot directly be set to execute this ﬁrmware, as writing to
the program counter register via the debugger will trigger the
aforementioned mechanism.

Instead, we indirectly redirect the control ﬂow via the
VTOR. We update the VTOR to point to our ﬂash dumping
ﬁrmware. While the CPU is executing its original ﬁrmware,
we trigger a Non-Maskable Interrupt (NMI) which forces the
CPU to jump into the NMI handler – which is actually our
ﬂash memory dumping ﬁrmware in the SRAM. Please note
that exceptions are executed in privileged mode, allowing
deepest system access. Furthermore, the NMI cannot be inter-
rupted by any other exception nor disabled by software. Thus,
the extraction ﬁrmware runs unimpeded. Due to this vulnera-
bility, the entire ﬁrmware is exposed in less than a minute.

6.5 D2: DMA Access Exploitation

Affected: CKS32F103, GD32F103

The DMA module is a master on internal buses and de-
signed to quickly move data from one peripheral to another
without CPU interaction. In most implementations, the DMA
is not allowed to access the ﬂash memory anymore as soon as
a debugger is attached. However, we noticed that this is not
correctly implemented in the CKS32F103 and the GD32F103.
In the CKS32F103, the DMA module is always allowed to
read from ﬂash memory. However, in the GD32F103, DMA
access to ﬂash is only possible as long as the CPU debug
module has not been activated, similar to Section 6.4.

In both cases, the debugger conﬁgures the DMA to copy
ﬂash memory contents into a directly readable memory such
as SRAM. For that approach, the DMA is set to memory-
to-memory mode, with the ﬂash memory as source and the
SRAM as destination. Next, the DMA transactions are started.
As the SRAM is not sufﬁciently large to incorporate the entire
ﬂash memory, the ﬁrmware is extracted in multiple chunks.
For the CKS32F103, the CPU should be halted to prevent
any interference of SRAM accesses during the DMA-based
copy procedure. However, the CPU must not be halted for the
GD32F103 as this would trigger the protection mechanisms
and lock down the ﬂash memory. Instead, we prevent inter-

Figure 6: Top and side view of a dual-die device. The bond-
ing wires between both dies become accessible by partially
removing the casing (right, bottom).

ference by deliberately crashing the CPU, thereby halting the
CPU without triggering the protection mechanism. To do so,
we reconﬁgure the VTOR to point to an invalid memory ad-
dress, such as 0xF0000000. Then, we trigger an NMI which
leads to a CPU crash as this address can neither be read nor
executed from. This vulnerability exposes the entire users
ﬁrmware within a few minutes.

7 Physical Analysis and Exploits

7.1 H0: Debug Access in RDP Level 2

Affected: None

For the experiment, we set the GD32F130 to RDP level 2,
which is only supported by this device. After cycling power,
the debugger is unable to connect to the device anymore. Thus,
RDP level 2 is implemented in this device.

7.2 H1: Invasive Data Eavesdropping

Affected: At least GD32F103, GD32F130

All tested GD32 devices have a separate logic and ﬂash
memory die, as shown in Section 4.3. Both chips are stacked
atop of each other and connected via bonding wires, illus-
trated in Figure 6. This sparked the question, whether such a
design is sufﬁciently secure against invasive physical attacks
– especially in the case of the GD32F130 that did not exhibit
any debug interface vulnerabilities so far.

In order to gain access to the bonding wires for eaves-
dropping, the top of the casing is carefully removed via sand
paper of 120 and 600 grit size. A small portion of the bonding
wires’ top curvature becomes sufﬁciently accessible to con-
tact it momentarily with a very thin wire. Without requiring a
pre-ampliﬁer, these signals are connected to a logic analyzer.
We identiﬁed a Quad-SPI (QSPI) bus at 4 MHz between
the logic and the ﬂash die. Quad means that the bus commu-
nicates via a 4-bit wide parallel interface for addresses and
data. To record all data, all four signals must be accessed.

To create a larger, electrically improved, and mechanically
more stable contact area for further analysis, we applied con-
ductive silver paint. A ﬁne brush, manually made from a sin-

LogicdieFlash dieLogicdieFlash dieFlashLogic diedieaL is the column vector of bits representing the logical ad-
dress of the word in the system’s logical view of the page.
Since each page is 1 KiB large and word-addressed, there are
8 address bits.

aP = [aP9 aP8 aP7 aP6 aP5 aP4 aP3 aP2]T,

aP ∈ Z8×1

2

(1)

aL = [aL9 aL8 aL7 aL6 aL5 aL4 aL3 aL2]T,

aL ∈ Z8×1

2

(2)

To reverse-engineer the scheme, we place one all-zero word

at the beginning of individual pages with an offset of:
0x004, 0x008, 0x010, 0x020, 0x040, 0x080, 0x100, 0x200.
This corresponds to addresses which have only one address
bit set, i.e., aL2, aL3, aL4, aL5, aL6, aL7, aL8, and aL9.

By observing the resulting address of the all-zero words
within the QSPI transactions, the permutation of the words
and thereby the address bits are derived. After verifying the
permutation using additional addresses in tests, the permu-
tation from the logical order to the physical order can be
expressed via the permutation matrix PaPL as:

aP = PaPL · aL, with PaPL ∈ Z8×8

2

.

(3)

For the GD32F130C8T6, we achieved the following permuta-
tion matrix:















aP9
aP8
aP7
aP6
aP5
aP4
aP3
aP2















=


0
0


0


0


1


0


0

0

1
0
0
0
0
0
0
0

0
0
0
1
0
0
0
0

0
0
0
0
0
0
0
1

0
0
1
0
0
0
0
0

0
0
0
0
0
0
1
0

0
1
0
0
0
0
0
0















0
0
0
0
0
1
0
0

·















aL9
aL8
aL7
aL6
aL5
aL4
aL3
aL2















(4)

The permutation matrix for the GD32F103C8T6 is given
in Appendix B. The inverse, which is the transposed matrix,
provides the conversion from physical to logical addresses.

7.2.2 Bit-Permutation

After reverting the word-permutation, the data is still not di-
rectly readable as the data is again obfuscated. Though, the
hamming weight of each word is correct. Additionally, a mem-
ory region ﬁlled with identical bytes will lead to a repetitive
pattern of 32 bits in length. This leads to the conclusion that
no strong encryption is present but only a permutation of bits
inside a block of 32 bits.

Due to the vast number of possible permutations, the map-
ping is inferred via a test pattern written into the ﬂash memory.
To become independent of the address bit permutation, each
test-word is written to the beginning of a new page. The
following test pattern, in which each column encodes its bit-
index within the word, is written to memory in big endian
encoding:

Figure 7: The prepared GD32F130 with access to all four
QSPI data signals (IO0 to IO3).

gle ﬁber of a bamboo stick, is helpful to apply the paint. Via
additional thin wires, all four QSPI signals are permanently
connected to the circuit board. The result of this rather tedious
task is shown in Figure 7. Due to the regular communication
pattern and availability of a datasheet of a functionally similar
standalone QSPI ﬂash device by GD [8], no additional signals
need to be probed for reverse-engineering.

After waking up the ﬂash memory, the factory conﬁgura-
tion, containing a device ID and most likely some calibration
data, is loaded. Next, the integrated bootloader section is read.
Directly afterwards, the device fetches the option bytes, con-
taining the security settings. Then, the ﬁrmware is fetched in
pages of 1 KiB. The GD32F103C8T6 initially fetches the en-
tire memory of 64 KiB and very likely copies it to an internal
SRAM for faster code execution [21]. The GD32F130C8T6
fetches only 32 KiB on start up and the rest on demand. While
the factory conﬁguration, the bootloader, and the option bytes
are clearly visible, the ﬁrmware appears scrambled and obfus-
cated. We assume that this is intended as a security measure
and not as a memory optimization.

To decode the ﬁrmware, we reverse-engineer the obfusca-
tion mechanisms. For the analysis, we use the following ﬂash
address structure of a 64 KiB device:

addr = 00001000
(cid:125)
(cid:123)(cid:122)
(cid:124)
Main Flash

00000000 PPPPPP
(cid:124) (cid:123)(cid:122) (cid:125)
Page

AA AAAAAA
(cid:125)
(cid:123)(cid:122)
(cid:124)
Word

BB
(cid:124)(cid:123)(cid:122)(cid:125)
Byte

First, we noticed that the page address, deﬁned by bits 10 to
15, is not obfuscated nor scrambled. Pages ﬁlled with data
appear in the same order on the QSPI bus as they are present
in memory, albeit the data inside each page is scrambled.

7.2.1 Word-Permutation

However, we observed that some pages, especially the only
partially ﬁlled ones, show a regular pattern during their QSPI
transmission. Several larger chunks of unused memory were
interspersed in the ﬁrmware. Thus, we suspected and con-
ﬁrmed a page-internal permutation of data words.

Let aP be the column vector of bits representing the physi-
cal address of a word inside a ﬂash memory page. Similarly,

Bonding wiresIO3IO0IO1IO20xFFFF0000 (11111111111111110000000000000000)
0xFF00FF00 (11111111000000001111111100000000)
0xF0F0F0F0 (11110000111100001111000011110000)
0xCCCCCCCC (11001100110011001100110011001100)
0xAAAAAAAA (10101010101010101010101010101010)

Next, the corresponding ﬁve QSPI transactions loading these
words from ﬂash memory are recorded and analyzed. When
looking at a speciﬁc bit in all ﬁve transactions, a unique bi-
nary pattern is seen. The MSBs of the ﬁve transactions, for
example, are 11011 in binary which is 27 in decimal. This
means that bit 27 of the data is actually being transmitted
as the MSB on the bus. By repeating this analysis for the
remaining bits, the entire bit-mapping can quickly be inferred.
As a sanity-check, the resulting mapping must be bijective.

In all devices analyzed by the authors so far, permutations
were only done within the same byte. Thus, this permutation
can be split up into four independent 8-bit permutations for
simplicity. However, these four permutations are not identical.
Let dP be the column vector of the physical bits of a byte on
the QSPI bus. Let dL be the column vector of the logical bits
of a byte inside the system. PdPL is the permutation matrix
to convert the data bits from the logical order to the physical
order.

dP = PdPL · dL, with dP, dL ∈ Z8×1

2

, PdPL ∈ Z8×8

2

(5)

The four permutation schemes, explicitly provided in Ap-
pendix C and identical for the GD32F103 and GD32F130, are
used in cyclic order depending on the addresses’ LSBs, i.e.,

PdPL =


Pα,

Pβ,
Pγ,

Pδ,

if addr[1..0] = 00
if addr[1..0] = 01
if addr[1..0] = 10
if addr[1..0] = 11

(6)

The inverse of the matrix, which is the transposed matrix,

provides the conversion from physical to logical order.

The results show that the obfuscation via permutation is
a weak security measure as the matrices can be entirely ex-
tracted with little effort. This enables an attacker to extract and
decode the ﬁrmware, thereby circumventing device security.

7.3 H2: Invasive RDP Manipulation

Affected: At least GD32F130

The GD32F130 supports RDP level 2 which entirely shuts
down the debug interface. Additionally, no vulnerabilities
are known for this device in RDP level 1. Thus, an attacker
would have to focus on hardware attacks. However, snifﬁng
QSPI communication is a viable but effortful approach due to
the difﬁcult probing of bonding wires and the de-obfuscation
required for data extraction.

Thus, an alternative for getting access to the ﬁrmware is
an active manipulation of QSPI communication. Analysis

Figure 8: QSPI active manipulation setup with transaction
excerpt. A fault (red) is injected into the IO2 signal to alter
the option bytes, aligned to the distinct pattern (yellow) at the
end of the bootloader.

showed that the RDP setting is loaded during startup and
present on the bus in plain without obfuscation. The naive
approach would be to interfere with the option byte loading
by directly manipulating the option byte transmission. Down-
grading from RDP level 2 to 1 to re-enable the debug interface
is feasible by ﬂipping any bit, however, this does not provide
access to the ﬁrmware as no debug interface vulnerabilities
are known for level 1. To downgrade from level 2 to 0, the
option bytes would have to be altered from 0xCC33 to 0xA55A.
While being at least theoretically possible, this would again
require access to all four QSPI data signals at once.

However, detailed analysis shows that the bus trafﬁc con-
tains the value for RDP level 0, which is 0xA55A, at the be-
ginning of the factory conﬁguration QSPI transaction:

A55A 07EF 1004 0313 FFFF [....]

The reason for this is unknown but it enables a new attack
vector. Further analysis shows that the factory conﬁguration is
loaded from address 0x0400 and the option bytes are loaded
from address 0x4000. Thus, by manipulating the address of
the QSPI transaction loading the option bytes, they are forced
to be loaded from the factory conﬁguration region instead.
This replaces the actual option bytes with the value 0xA55A
and the device falls down to RDP level 0 – enabling full
access to the entire user ﬁrmware via the debugger.

The physical manipulation is comparably simple, as only
two bits have to be ﬂipped. Furthermore, both bits to be ma-
nipulated are transmitted via the QSPI IO2 signal, thus, an
attacker only has to gain access to this single bonding wire.
The attack is executed by an STM32F303 discovery board
running at 72 MHz. This attack board runs a timing-optimized
assembly implementation of this address faulting approach.
Due to the high currents required for this forceful override,
two GPIOs of the attack board are connected in parallel. The

Debug/SWDQSPIIO2DuTAttack BoardBootloaderOPTFirmwaresystem is connected to the QSPI IO2 signal, actively moni-
tors it, and triggers on the address phase of the option byte
loading, as shown in Figure 8. The correct point in time is
identiﬁed by waiting for the typical pattern of many zeroes
followed by three block of ones that occurs only at the end
of the bootloader transaction. The address phase of the op-
tion byte loading starts exactly in the moment when the IO2
line is actively pulled low again. At this point in time, the
attack board enables its output drivers, overrides the address
with 0x0400, and enters high-impedance mode again. Next,
the QSPI transaction returns the value 0xA55A for the op-
tion bytes instead of the actual value, thereby falling back to
RDP level 0. This re-enables the debug interface without any
protection, hence, the ﬁrmware is directly readable.

Although the ﬁrmware is protected in RDP level 2 or 1, this
approach disables security entirely. When correctly set up,
the attack works very reliable even on the ﬁrst try. Despite the
forceful override, this attack has not caused any damage to the
DuT. Please note, that this is a low-cost invasive attack with
easily available materials, thus, the bar for an attacker is very
low. This demonstrates the conceptual weakness of multi-die
systems that have accessible inter-die bonding wires.

7.4 H3: Shellcode Exec. via Glitch and FPB

Affected: APM32F103, STM32F103

In this section, we present a novel multi-stage low-level
attack that spawns a privileged shell on a secured microcon-
troller. This allows us to read out the protected ﬂash memory
and to do arbitrary modiﬁcations to the system. The basic
idea is to repurpose a hardware-based ﬁrmware live-patching
mechanism to redirect the control ﬂow from the original
ﬁrmware into our shellcode in SRAM. For that, we apply
a supply voltage glitch, trigger the execution of a two-stage
exploit code in SRAM, and repurpose the core’s ﬁrmware
live-patching mechanism.

7.4.1 Background

The Cortex-M3 core comprises the Flash Patch and Break-
point Unit (FPB) which is a hardware module intended for
software live-patching as well as debugging [3]. The module
has address comparators that trigger when a speciﬁed mem-
ory address is accessed by the core. The actual data can then
be replaced with alternative contents. Since breakpoints and
patches should survive a device reset, this module keeps its
conﬁguration under reset and is only cleared by a power cycle.
To determine whether to boot from ﬂash memory or
SRAM, the BOOT0 and BOOT1 pins are sampled after re-
set [20]. When SRAM-booting is selected, this ﬁrmware must
be loaded to SRAM beforehand, as SRAM is a volatile mem-
ory and contents become lost at power-off. Please note that
when booting from SRAM in RDP level 1, the ﬂash memory
is inaccessible.

Independent of the bootmode, if a debugger is attached to
the system, ﬂash memory is locked down, preventing any fur-
ther access [19]. The ﬂash memory lockdown is only released
again by a power cycle.

7.4.2 Attack Execution

Figure 9: The setup for glitch generation, boot mode selection,
and code extraction.

For the attack, we setup the DuT as shown in Figure 9. At
ﬁrst, we upload a two-stage exploit ﬁrmware to the SRAM
with a debugger and shut down the debugger afterwards. Next,
we conﬁgure SRAM-booting via the BOOT pins.

Figure 10: The VDD/supply glitch triggers a system reset.

However, the ﬂash memory is still locked down since a
debugger was connected. To release the lock down, we per-
form a very quick power cycle by cutting the power supply
for a few hundreds of microseconds. During that glitch, we
observe the microcontroller’s reset line to detect when the sys-
tem goes into reset. At this moment, our setup automatically
restores power, as shown in Figure 10. After this very short
power-cycle, access to the ﬂash memory is re-enabled. But
due to SRAM data remanence [18], such a short interruption
in the power supply leaves the data in SRAM intact.

Next, we boot from SRAM and the stage one ﬁrmware
conﬁgures the FPB. It is set to hijack the next device start up
from ﬂash memory by patching the reset vector fetch from
the hard-coded address 0x00000004 [3]. We conﬁgure the
FPB to replace this actual entry point in ﬂash memory with
the entry point of stage two of our shell code in SRAM.

Attack BoardDuTBOOT0VCCDebug/UARTResetSWD-1000-50005001000Time in µs0 V1 V2 V3 VSignal voltageVDDnResetFinally, we conﬁgure the chip to boot from ﬂash memory
and apply a reset. Since the FPB conﬁguration is preserved,
the patch conﬁguration remains present. When the core tries
to start up and fetches the entry address, this triggers the FPB
which returns our alternative entry point. Thus, the control
ﬂow becomes immediately diverted to stage two in SRAM
and a privileged shell is spawned. Flash memory remains
accessible because the chip has – only seemingly – booted
from the ﬂash memory. The shell code has full system access
and can extract the entire ﬁrmware in negligible time.

For the attack, we employ solely an STM32F303 evaluation
board and some wires. The board provides a debug interface
for the DuT, a UART interface for serial communication with
the shell, and it controls the Reset, BOOT, and power supply
signals via its GPIO pins. Two GPIOs are connected in paral-
lel to provide sufﬁcient current for the DuT. This experiment
shows that low-cost tools are entirely sufﬁcient to circumvent
ﬁrmware protection in the STM32F103 and APM32F103.

8 Countermeasures

All the vulnerabilities emerge from the hardware design and
implementation, thus, ﬁxing these issues requires a new hard-
ware revision. Most likely, no bullet-proof ﬁrmware-based
workarounds exist for all those vulnerabilities, especially
since their execution could be hampered by keeping the sys-
tem in reset, if possible.

However, the device manufacturers are able to ﬁx their
devices in an updated hardware revision. Most of the vul-
nerabilities, especially concerning the debug interface and
FPB, might require only minor modiﬁcations. For the inva-
sive attacks on the dual-die GD32 devices, countermeasures
are more demanding. The data could either be sufﬁciently
encrypted or the manufacturer could switch from bonding
wires to ﬂip chip mounting of the ﬂash chip. This prevents
easy access to the inter-die connection, as tiny solder dots
directly connect both dies at their area of contact.

To prevent vulnerabilities in the future, at least basic secu-
rity reviews and tests are required during chip development.
Some of the vulnerabilities were discovered by us within a
few hours in a black-box scenario, thus, a person doing a
white box test and having access to internal design documents
should be able to discover most issues with ease. However, the
underlying issue might less be on the technical side but more
in the project management and requirement prioritization.

9 Conclusion and Outlook

In this paper, we analyzed drop-in replacements and the orig-
inal STM32F103 microcontroller resulting in a total of six
devices by four manufacturers. We showed via low-level anal-
ysis and optical inspection that the replacement devices are
re-implementations of the STM32F103 and likely not based

on illegitimately obtained design data. We focused on the
ﬂash memory security in each of those devices and came to
alarming results especially because we limited ourselves to
low-cost DiY approaches. When the replacement devices are
compared to the STM32F103, some vulnerabilities appear to
be ﬁxed, but other, new vulnerabilities, affect those devices
and expose the ﬁrmware nevertheless. Although there is no
magic exploit affecting all devices at once, we still discovered
shared vulnerabilities that affect multiple devices. Some de-
sign errors are observed across several chips, manufacturers,
and even CPU architectures.

In total, the vulnerabilities allow extracting 100 % of the
ﬁrmware from every tested device with comparably simple
DiY methods. All the vulnerabilities are especially critical
due to their easy exploitation which does not require a sophis-
ticated lab. Hence, we identiﬁed a huge demand for security
improvements in all of these microcontrollers, in the origi-
nal and the replacements, to prevent ﬁrmware extraction and
thereby an exposure of valuable data to adversaries and com-
petitors. We strongly believe that the vast majority of those
issues could have easily been identiﬁed in a security concept
review or a penetration test before starting mass production.
However, these results could only be the tip of the iceberg,
as we tested only the most popular series but security con-
cepts and implementations are sometimes reused widely, also
for other products. Additionally, while these vulnerabilities
are obviously only design errors, we cannot exclude that sys-
tems might include even further, yet undiscovered, issues or
even intentionally added and well-hidden backdoors in the
worst case. In combination with the risk due to counterfeit
STM32F103 devices, supply chain management becomes an-
other vital factor for security. Thus, both, the trustworthiness
of the manufacturers and the supply chain, play a major role
in the resulting overall system security.

10 Coordinated Disclosure

We triggered a coordinated disclosure process with each man-
ufacturer of the analyzed microcontrollers; i.e., Apex Micro-
electronics (APM), GigaDevice (GD), China Key Systems
(CKS), and STMicroelectronics (ST). The details regarding
the vulnerabilities of their microcontrollers were shared to
the full extend more than 90 days prior to publication.

11 Supplementary Material

Supplementary material and code is available under
https://science.obermaier-johannes.de/f103-analysis. It con-
tains high-resolution chip die images, code for Cortex-M3
CPU revision and errata detection, logic traces during QSPI-
memory communication (H1) and fault injection (H2), and
code, as well as binaries, for the reproduction of all Proofs-
of-Concepts D1-A, D1-B, D1-C, D2, H1, H2, H3.

[15] Raul Quijada, Roger Dura, Jofre Pallares, Xavier For-
matje, Salvador Hidalgo, and Francisco Serra-Graells.
Large-area automated layout extraction methodology
for full-ic reverse engineering. Journal of Hardware
and Systems Security, 2018.

[16] Marc Schink and Johannes Obermaier. Taking a look
into execute-only memory. In 13th USENIX Workshop
on Offensive Technologies (WOOT 19), Santa Clara, CA,
August 2019. USENIX Association.

[17] Marc Schink and Johannes Obermaier.

ception(al)
failure
read-out protection.
stm32f1-exceptional-failure/, March 2020.

Ex-
breaking
the STM32F1
https://blog.zapb.de/

–

[18] Sergei Skorobogatov. Hardware security implications of
reliability, remanence, and recovery in embedded mem-
ory. Journal of Hardware and Systems Security, 2018.

[19] STMicroelectronics.

Programming manual
STM32F10xxx Flash memory microcontrollers,
August 2012. Rev. 2.

[20] STMicroelectronics. Reference manual STM32F101xx,
STM32F102xx, STM32F103xx, STM32F105xx and
STM32F107xx advanced Arm-based 32-bit MCUs,
2018.

[21] Zeptobars.

GD32F103CBT6 – Cortex-M3 with
https://zeptobars.com/en/read/
serial ﬂash.
GD32F103CBT6-mcm-serial-flash-Giga-Devices,
2016.

References

[1] Apex Microelectronics Co., Ltd. APM32F103x4x6x8xB
ARM Cortex-M3 based 32-bit MCU, 2020. Version
1.0.5.

[2] ARM. Cortex-M3 Technical Reference Manual, 2006.

Revision: r1p1.

[3] ARM. Cortex-M3 Technical Reference Manual, 2010.

Revision: r2p1.

[4] Arm Limited. Arm Processor Cortex-M3 (AT420) and
Cortex-M3 with ETM (AT425) Software Developer Er-
rata Notice, January 2019. Ver. 3.

[5] Kris Brosch.

Firmware

dumping

nique for an ARM Cortex-M0 SoC.
//blog.includesecurity.com/2015/11/
NordicSemi-ARM-SoC-Firmware-dumping-technique.
html, November 2015.

tech-
https:

[6] China Key Systems & Integrated Circuit Co., Ltd.
CKS32F103x8 CKS32F103xB Datasheet, 2018. Ver-
sion 1.3.

[7] Matthias Diro. STM32F103C8T6 - Fälschung von
ST bestätigt (STM32F103C8T6 - ST conﬁrms counter-
feit product). https://www.mikrocontroller.net/
topic/488417, January 2020.

[8] GigaDevice Semiconductor Inc. GD25B16C Datasheet –
3.3V Uniform Sector Dual and Quad Serial Flash, 2018.
Revision 1.5.

[9] GigaDevice Semiconductor Inc. GD32VF103 RISC-V
32-bit MCU – User Manual, 2019. Revision 1.2.

[10] GigaDevice Semiconductor Inc. GD32F10x ARM
Cortex-M3 32-bit MCU – User Manual, 2020. Revi-
sion 2.3.

[11] GigaDevice Semiconductor Inc. GD32F1x0 ARM
Cortex-M3 32-bit MCU – User Manual, 2020. Revi-
sion 3.3.

[12] Richard Kaußler. GigaDevice GD32. https://www.

richis-lab.de/STM32_06.htm, 2020.

[13] Johannes Obermaier and Stefan Tatschner. Shedding too
much light on a microcontroller’s ﬁrmware protection.
In 11th USENIX Workshop on Offensive Technologies
(WOOT 17), Vancouver, BC, August 2017. USENIX
Association.

[14] OECD/EUIPO. Trends in Trade in Counterfeit and
Pirated Goods. Paris/European Union Intellectual Prop-
erty Ofﬁce, 2019.

C Bit Permutation Matrices

0
1


0


0


0


0


0

0

0
0
0
0
0
1
0
0

0
0
0
0
1
0
0
0

0
0
0
0
0
0
0
1

1
0
0
0
0
0
0
0

Pα =

0
0
0
0
0
0
1
0

0
0
0
0
0
1
0
0

0
0
0
0
1
0
0
0

0
0
0
1
0
0
0
0

0
0
0
1
0
0
0
0

0
0
1
0
0
0
0
0

0
1
0
0
0
0
0
0

1
0
0
0
0
0
0
0















0
0
1
0
0
0
0
0















0
1
0
0
0
0
0
0















1
0
0
0
0
0
0
0















0
0
0
0
0
0
0
1

Pβ =


1
0


0


0


0


0


0

0


0
0


0


0


0


0


0

1


0
0


0


0


0


0


1

0

0
0
0
0
0
0
1
0

0
0
0
0
0
1
0
0

0
0
0
0
1
0
0
0

0
0
0
1
0
0
0
0

0
0
1
0
0
0
0
0

0
1
0
0
0
0
0
0

0
0
0
0
1
0
0
0

0
0
0
1
0
0
0
0

0
0
1
0
0
0
0
0

0
0
0
0
0
0
0
1

0
0
0
0
0
0
1
0

0
0
0
0
0
1
0
0

A Die Size Measurement

Table 3: Die sizes of each device for Flash (F) and Logic (L).

Device

Die size

Die
in mm × mm type

STM32F103(C8T6)

3.3 × 3.3

APM32F103(CBT6)

3.0 × 2.6

CKS32F103(C8T6)

GD32F103(C8T6)

GD32F130(C8T6)

GD32VF103(CBT6)

2.7 × 2.6

1.5 × 1.0
3.0 × 3.0

1.5 × 1.0
2.4 × 2.3

1.5 × 0.8
3.1 × 3.2

F + L

F + L

F + L

F
L

F
L

F
L

B Address Permutation Matrices

Pγ =

B.1 GD32F103

0
0


0


0


0


0


0

1

PaPL =

B.2 GD32F130

0
0


0


0


1


0


0

0

PaPL =

0 0 0
0 0 0
0 0 0
0 0 0
0 0 1
0 1 0
1 0 0
0 0 0

1 0 0
0 0 0
0 0 0
0 1 0
0 0 0
0 0 0
0 0 0
0 0 1

0
0
0
1
0
0
0
0

0
0
1
0
0
0
0
0















0 0 1
0 1 0
1 0 0
0 0 0
0 0 0
0 0 0
0 0 0
0 0 0















0 0 0
0 1 0
0 0 0
0 0 0
0 0 0
0 0 1
1 0 0
0 0 0

Pδ =

D Analyzed Devices

Table 4: Analyzed microcontrollers with their respective vulnerabilities and CVE numbers.

Manufacturer

Device family

Device under test

Vulnerabilities

CVE

Apex Microelectronics

APM32F103

APM32F103CBT6 [1]

China Key Systems

CKS32F103

CKS32F103C8T6 [6]

GigaDevice

GD32F103

GD32F103C8T6 [10]

GD32F130

GD32F130C8T6 [11]

D1-B: Extraction via Exceptions
H3: Glitch and FPB → Shellcode

CVE-2020-13463
CVE-2020-13471

D1-A: Load Instruction Exploitation
D2: DMA Access Exploitation
D1-B: Extraction via Exceptions

D1-C: Control Flow Redirection
D2: DMA Access Exploitation
H1: Invasive Data Eavesdropping

CVE-2020-13464

CVE-2020-13467

CVE-2020-13465
CVE-2020-13472
CVE-2020-13470

H1: Invasive Data Eavesdropping
H2: Invasive RDP Manipulation

CVE-2020-13470
CVE-2020-13468

GD32VF103

GD32VF103CBT6 [9] D1-A: Load Instruction Exploitation CVE-2020-13469

STMicroelectronics

STM32F103

STM32F103C8 [20]

D1-B: Extraction via Exceptions
H3: Glitch and FPB → Shellcode

CVE-2020-8004
CVE-2020-13466

Important: If a vulnerability is not listed for a speciﬁc device, one should not automatically assume its immunity. We observed
that minor modiﬁcations to an attack approach can greatly inﬂuence the outcome. This table lists only vulnerabilities that
were tested and successfully exploited. Debug interface attacks were tested for all devices. Invasive attacks were only tested
extensively for selected devices. An adversary would not choose to mount an attack if there is an easy-to-exploit debug interface
vulnerability, thus, the GD32VF103 was not tested against H1 and H2.


