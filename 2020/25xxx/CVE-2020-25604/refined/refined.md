```json
[
  {
    "related": true,
    "vulnerability": {
      "cve": "CVE-2020-25604",
      "summary": "Race when migrating timers between x86 HVM vCPUs. When migrating timers of x86 HVM guests between its vCPUs, the locking model used allows for a second vCPU of the same guest also operating on the timers to release a lock that it didn't acquire.",
      "details": "A race condition exists in Xen hypervisor when migrating timers of x86 HVM guests between its vCPUs. Due to an insufficient locking model, a second vCPU of the same guest, concurrently operating on the timers, can release a lock that it did not acquire. The most likely effect of the issue is a hang or crash of the hypervisor, leading to a denial of service.",
      "affected_components": [
        "Xen hypervisor",
        "x86 HVM guests",
        "systems with more than one vCPU"
      ],
      "root_cause": "Insufficient locking model during migration of timers between x86 HVM vCPUs.",
      "weaknesses": [
        "Race Condition",
        "Improper lock management"
      ],
      "impact": "Hypervisor crash or hang, leading to denial of service.  Privilege escalation and information leaks cannot be excluded.",
      "attack_vectors": [
        "Malicious x86 HVM guest",
          "Guest administrator with multiple vCPUs"
      ],
       "required_capabilities": [
        "Ability to control multiple vCPUs of a x86 HVM guest",
        "Ability to trigger timer migrations within the guest."
      ]
    }
  },
  {
    "related": false,
    "vulnerability": {
        "cve": "CVE-2020-25595",
        "summary": "PCI passthrough code reading back hardware registers",
      "details": "Code paths in Xen's MSI handling act on unsanitized values read back from device hardware registers. A not fully trusted guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system. Privilege escalation and information leaks cannot be excluded.",
    }
  },
  {
    "related": false,
    "vulnerability": {
      "cve": "CVE-2020-25602",
      "summary": "x86 pv: Crash when handling guest access to MSR_MISC_ENABLE",
      "details": "When a guest accesses certain Model Specific Registers, Xen first reads the value from hardware to use as the basis for auditing the guest access. For the MISC_ENABLE MSR, which is an Intel specific MSR, this MSR read is performed without error handling for a #GP fault, which is the consequence of trying to read this MSR on non-Intel hardware. A buggy or malicious PV guest administrator can crash Xen, resulting in a host Denial of Service. Only x86 systems are vulnerable. ARM systems are not vulnerable. Only Xen versions 4.11 and onwards are vulnerable. 4.10 and earlier are not vulnerable. Only x86 systems that do not implement the MISC_ENABLE MSR (0x1a0) are vulnerable. AMD and Hygon systems do not implement this MSR and are vulnerable. Intel systems do implement this MSR and are not vulnerable. Other manufacturers have not been checked. Only x86 PV guests can exploit the vulnerability. x86 HVM/PVH guests cannot exploit the vulnerability."
    }
  },
 {
    "related": false,
    "vulnerability": {
      "cve": "CVE-2020-25598",
      "summary": "Missing unlock in XENMEM_acquire_resource error path",
       "details": "A buggy error path in the XENMEM_acquire_resource exits without releasing an RCU reference, which is conceptually similar to forgetting to unlock a spinlock. A buggy or malicious HVM stubdomain can cause an RCU reference to be leaked. This causes subsequent administration operations, (e.g. CPU offline) to livelock, resulting in a host Denial of Service."
     }
  },
 {
    "related": false,
    "vulnerability": {
      "cve": "CVE-2020-25601",
      "summary": "xen: lack of preemption in evtchn_reset() / evtchn_destroy()",
       "details": "A lack of preemption in the FIFO event channel model may cause the CPU to spend an almost unbounded amount of processing time. This flaw allows malicious or buggy guest kernels to mount a denial of service (DoS) attack affecting the entire system. The highest threat from this vulnerability is to system availability."
    }
  },
  {
    "related": false,
     "vulnerability": {
      "cve": "CVE-2020-25603",
      "summary": "xen: missing memory barriers when accessing/allocating an event channel",
      "details": "There are missing memory barriers when accessing/allocating an event channel. Event channels control structures can be accessed lockless as long as the port is considered to be valid. Such a sequence is missing an appropriate memory barrier (e.g., smp_*mb()) to prevent both the compiler and CPU from re-ordering access. A malicious guest may be able to cause a hypervisor crash resulting in a Denial of Service (DoS). Information leak and privilege escalation cannot be excluded."
      }
  },
  {
   "related": false,
     "vulnerability": {
      "cve": "CVE-2020-25596",
      "summary": "xen: x86 pv guest kernel DoS via SYSENTER",
         "details":"x86 pv guest kernel DoS via SYSENTER"
        }
  },
   {
     "related": false,
     "vulnerability": {
      "cve": "CVE-2020-25597",
      "summary":"xen: once valid event channels may not turn invalid",
         "details":"once valid event channels may not turn invalid"
        }
    },
   {
    "related": false,
     "vulnerability": {
      "cve": "CVE-2020-25599",
      "summary": "xen: races with evtchn_reset function",
       "details":"races with evtchn_reset function"
        }
  },
   {
     "related": false,
     "vulnerability": {
      "cve": "CVE-2020-25600",
      "summary":"xen: out of bounds event channels available to 32-bit x86 domains",
        "details": "out of bounds event channels available to 32-bit x86 domains"
        }
    }
]
```