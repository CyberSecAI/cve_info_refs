```
{
  "CVE-2020-25596": {
    "description": "An issue was discovered in Xen through 4.14.x. x86 PV guest kernels can experience denial of service via SYSENTER. The SYSENTER instruction leaves various state sanitization activities to software. One of Xen's sanitization paths injects a #GP fault, and incorrectly delivers it twice to the guest. This causes the guest kernel to observe a kernel-privilege #GP fault (typically fatal) rather than a user-privilege #GP fault (usually converted into SIGSEGV/etc.). Malicious or buggy userspace can crash the guest kernel, resulting in a VM Denial of Service. All versions of Xen from 3.2 onwards are vulnerable. Only x86 systems are vulnerable. ARM platforms are not vulnerable. Only x86 systems that support the SYSENTER instruction in 64bit mode are vulnerable. This is believed to be Intel, Centaur, and Shanghai CPUs. AMD and Hygon CPUs are not believed to be vulnerable. Only x86 PV guests can exploit the vulnerability. x86 PVH / HVM guests cannot exploit the vulnerability.",
    "affected_versions": "All versions of Xen from 3.2 onwards",
    "vulnerability": "The SYSENTER instruction leaves various state sanitization activities to software. One of Xen's sanitization paths injects a #GP fault, and incorrectly delivers it twice to the guest.",
    "impact": "Malicious or buggy userspace can crash the guest kernel, resulting in a VM Denial of Service.",
    "attack_vector": "x86 PV guest",
     "attacker_requirements": "Malicious or buggy userspace",
    "affected_architectures": [
      "x86"
    ],
    "not_affected_architectures": [
      "ARM",
      "AMD",
       "Hygon"
    ],
    "additional_notes": "Only x86 systems which support the SYSENTER instruction in 64bit mode are vulnerable. This is believed to be Intel, Centaur and Shanghai CPUs.",
        "cvss_v3_score": 5.5
  },
    "CVE-2020-25595": {
    "description": "An issue was discovered in Xen through 4.14.x. The PCI passthrough code improperly uses register data. Code paths in Xen's MSI handling have been identified that act on unsanitized values read back from device hardware registers. While devices strictly compliant with PCI specifications shouldn't be able to affect these registers, experience shows that it's very common for devices to have out-of-spec \"backdoor\" operations that can affect the result of these reads. A not fully trusted guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system. Privilege escalation and information leaks cannot be excluded. All versions of Xen supporting PCI passthrough are affected. Only x86 systems are vulnerable. Arm systems are not vulnerable. Only guests with passed through PCI devices may be able to leverage the vulnerability. Only systems passing through devices with out-of-spec (\"backdoor\") functionality can cause issues. Experience shows that such out-of-spec functionality is common; unless you have reason to believe that your device does not have such functionality, it's better to assume that it does.",
    "affected_versions": "All versions of Xen supporting PCI passthrough",
    "vulnerability": "Code paths in Xen's MSI handling act on unsanitized values read back from device hardware registers, due to devices potentially having out-of-spec \"backdoor\" operations",
    "impact": "A not fully trusted guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system. Privilege escalation and information leaks cannot be excluded.",
    "attack_vector": "Guest with passed through PCI devices",
    "attacker_requirements": "Untrusted guest with a passed through device that has out-of-spec functionality",
    "affected_architectures": [
      "x86"
    ],
     "not_affected_architectures": [
      "Arm"
    ],
        "cvss_v3_score": 7.8
  },
   "CVE-2020-25597": {
    "description": "An issue was discovered in Xen through 4.14.x. There is mishandling of the constraint that once-valid event channels may not turn invalid. Logic in the handling of event channel operations in Xen assumes that an event channel, once valid, will not become invalid over the life time of a guest. However, operations like the resetting of all event channels may involve decreasing one of the bounds checked when determining validity. This may lead to bug checks triggering, crashing the host. An unprivileged guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system. All Xen versions from 4.4 onwards are vulnerable. Xen versions 4.3 and earlier are not vulnerable. Only systems with untrusted guests permitted to create more than the default number of event channels are vulnerable. This number depends on the architecture and type of guest. For 32-bit x86 PV guests, this is 1023; for 64-bit x86 PV guests, and for all ARM guests, this number is 4095. Systems where untrusted guests are limited to fewer than this number are not vulnerable. Note that xl and libxl limit max_event_channels to 1023 by default, so systems using exclusively xl, libvirt+libxl, or their own toolstack based on libxl, and not explicitly setting max_event_channels, are not vulnerable.",
    "affected_versions": "All Xen versions from 4.4 onwards",
        "not_affected_versions": "Xen versions 4.3 and earlier",
    "vulnerability": "Logic in the handling of event channel operations in Xen assumes that an event channel, once valid, will not become invalid over the life time of a guest. Operations like the resetting of all event channels may decrease one of the bounds checked when determining validity.",
    "impact": "An unprivileged guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system.",
    "attack_vector": "Untrusted guest with more than default number of event channels",
    "attacker_requirements": "Untrusted guests permitted to create more than default number of event channels. Default limits are 1023 for 32 bit x86 PV, 4095 for 64 bit x86 PV and all ARM guests.",
    "affected_architectures": [
      "x86",
      "ARM"
    ],
    "additional_notes": "Systems using exclusively xl, libvirt+libxl, or their own toolstack based on libxl, and not explicitly setting max_event_channels, are not vulnerable."
     ,
        "cvss_v3_score": 6.5
  },
  "CVE-2020-25599": {
    "description": "An issue was discovered in Xen through 4.14.x. There are evtchn_reset() race conditions. Uses of EVTCHNOP_reset (potentially by a guest on itself) or XEN_DOMCTL_soft_reset (by itself covered by XSA-77) can lead to the violation of various internal assumptions. This may lead to out of bounds memory accesses or triggering of bug checks. In particular, x86 PV guests may be able to elevate their privilege to that of the host. Host and guest crashes are also possible, leading to a Denial of Service (DoS). Information leaks cannot be ruled out. All Xen versions from 4.5 onwards are vulnerable. Xen versions 4.4 and earlier are not vulnerable.",
      "affected_versions": "All Xen versions from 4.5 onwards",
        "not_affected_versions": "Xen versions 4.4 and earlier",
    "vulnerability": "Races in evtchn_reset() can lead to the violation of various internal assumptions and cause out of bounds memory accesses or triggering of bug checks.",
    "impact": "x86 PV guests may be able to elevate their privilege to that of the host. Host and guest crashes are also possible, leading to a Denial of Service (DoS). Information leaks cannot be ruled out.",
    "attack_vector": "x86 PV guests",
    "attacker_requirements": "A guest triggering EVTCHNOP_reset or XEN_DOMCTL_soft_reset",
    "affected_architectures": [
      "x86"
    ],
      "cvss_v3_score": 8.2
  },
  "CVE-2020-25600": {
    "description": "An issue was discovered in Xen through 4.14.x. Out-of-bounds event channels are available to 32-bit x86 domains. The grant table code for 32-bit x86 guests doesn't validate the passed event channel number when creating a reference. This may lead to a write out of bounds, leading to a denial of service for the whole system. A not fully trusted guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system. All versions of Xen from 4.5 onwards are vulnerable. Xen versions 4.4 and earlier are not vulnerable. Only x86 systems are vulnerable. Arm systems are not vulnerable. Only 32-bit x86 PV guests may be able to leverage the vulnerability. x86 PVH and HVM guests are not vulnerable to this issue. Only a guest with an emulated hypercall interface (i.e., not PVH or HVM) may be able to leverage the vulnerability. Thus, VMs using PV stubdomains are vulnerable. Guests with emulators running in dom0 (i.e., typically HVM or PVH guests) are not vulnerable to this issue.",
    "affected_versions": "All versions of Xen from 4.5 onwards",
     "not_affected_versions": "Xen versions 4.4 and earlier",
    "vulnerability": "Grant table code for 32-bit x86 guests doesn't validate passed event channel number when creating a reference. This may lead to a write out of bounds.",
    "impact": "A not fully trusted guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system.",
    "attack_vector": "32-bit x86 PV guests",
     "attacker_requirements": "Not fully trusted 32-bit x86 PV guest",
        "affected_architectures": [
      "x86"
    ],
    "not_affected_architectures": [
      "Arm"
    ],
      "additional_notes": "Only a guest with an emulated hypercall interface (i.e., not PVH or HVM) may be able to leverage the vulnerability. Thus, VMs using PV stubdomains are vulnerable. Guests with emulators running in dom0 (i.e., typically HVM or PVH guests) are not vulnerable to this issue.",
          "cvss_v3_score": 5.5
  },
  "CVE-2020-25601": {
    "description": "An issue was discovered in Xen through 4.14.x. There is a lack of preemption in evtchn_reset() / evtchn_destroy(). The evtchn_reset() function assumes it can't be preempted. It disables interrupts and also disables preemption via a call to local_irq_disable(). However, there's no similar mechanism to prevent another vCPU from calling evtchn_destroy() for the same event channel, leading to race conditions. This can lead to out-of-bounds memory access. An unprivileged guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system. All Xen versions from 4.5 onwards are vulnerable. Xen versions 4.4 and earlier are not vulnerable. Only x86 systems are vulnerable. Arm platforms are not vulnerable. Only PV guests may be able to trigger this vulnerability.",
    "affected_versions": "All Xen versions from 4.5 onwards",
    "not_affected_versions": "Xen versions 4.4 and earlier",
    "vulnerability": "evtchn_reset() assumes it can't be preempted. However, it does not prevent another vCPU from calling evtchn_destroy() for the same event channel, leading to race conditions.",
    "impact": "An unprivileged guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system.",
    "attack_vector": "x86 PV guest",
      "attacker_requirements": "An unprivileged guest triggering evtchn_reset() / evtchn_destroy() race.",
        "affected_architectures": [
      "x86"
    ],
      "not_affected_architectures": [
      "Arm"
    ],
        "cvss_v3_score": 6.5

  },
    "CVE-2020-25602": {
    "description": "An issue was discovered in Xen through 4.14.x. x86 PV guest kernels crash when handling guest access to MSR_MISC_ENABLE. A Xen bug check triggers when a hypercall from a PV guest attempts to access the MSR_MISC_ENABLE register. This can lead to a Denial of Service for the entire host. All Xen versions from 4.10 onwards are vulnerable. Xen versions 4.9 and earlier are not vulnerable. Only x86 systems are vulnerable. Arm platforms are not vulnerable. Only x86 PV guests are vulnerable. x86 HVM/PVH guests cannot trigger this issue.",
    "affected_versions": "All Xen versions from 4.10 onwards",
     "not_affected_versions": "Xen versions 4.9 and earlier",
    "vulnerability": "A Xen bug check triggers when a hypercall from a PV guest attempts to access the MSR_MISC_ENABLE register.",
    "impact": "A Denial of Service for the entire host.",
    "attack_vector": "x86 PV guest",
     "attacker_requirements": "x86 PV guest issuing a hypercall accessing MSR_MISC_ENABLE",
          "affected_architectures": [
      "x86"
    ],
         "not_affected_architectures": [
      "Arm"
    ],
        "additional_notes": "x86 HVM/PVH guests cannot trigger this issue.",
         "cvss_v3_score": 5.5
  },
 "CVE-2020-25603": {
    "description": "An issue was discovered in Xen through 4.14.x. There are missing memory barriers when accessing/allocating an event channel. Operations for allocating and deallocating event channels lack necessary memory barriers. Thus, concurrent operations may observe invalid values of a variable, which may lead to memory corruption and cause a crash of the host. An unprivileged guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system. All Xen versions from 4.5 onwards are vulnerable. Xen versions 4.4 and earlier are not vulnerable. Only x86 systems are vulnerable. Arm platforms are not vulnerable. All guests can trigger this vulnerability by using the hypercall to create/destroy event channels.",
    "affected_versions": "All Xen versions from 4.5 onwards",
      "not_affected_versions": "Xen versions 4.4 and earlier",
    "vulnerability": "Operations for allocating and deallocating event channels lack necessary memory barriers.",
    "impact": "An unprivileged guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system.",
    "attack_vector": "All guests",
     "attacker_requirements": "Guest using the hypercall to create/destroy event channels",
          "affected_architectures": [
      "x86"
    ],
          "not_affected_architectures": [
      "Arm"
    ],
        "cvss_v3_score": 6.5
  },
   "CVE-2020-25604": {
    "description": "An issue was discovered in Xen through 4.14.x. There is a race when migrating timers between x86 HVM vCPUs. Timer migration between x86 HVM vCPUs is racy. A bug check may be triggered when migrating timers to a vCPU which is undergoing a timer operation. This can lead to a Denial of Service for the entire system. All Xen versions from 4.10 onwards are vulnerable. Xen versions 4.9 and earlier are not vulnerable. Only x86 systems are vulnerable. Arm platforms are not vulnerable. Only x86 HVM guests using multiple vCPUs may be able to trigger the vulnerability. x86 PV and PVH guests cannot trigger the vulnerability.",
    "affected_versions": "All Xen versions from 4.10 onwards",
    "not_affected_versions":"Xen versions 4.9 and earlier",
    "vulnerability": "Timer migration between x86 HVM vCPUs is racy. A bug check may be triggered when migrating timers to a vCPU which is undergoing a timer operation.",
     "impact": "This can lead to a Denial of Service for the entire system.",
    "attack_vector": "x86 HVM guests with multiple vCPUs",
    "attacker_requirements": "x86 HVM guests with multiple vCPUs triggering a timer migration during a timer operation.",
          "affected_architectures": [
      "x86"
    ],
      "not_affected_architectures": [
      "Arm"
    ],
      "additional_notes": "x86 PV and PVH guests cannot trigger the vulnerability.",
        "cvss_v3_score": 6.5
  },
     "CVE-2020-25598": {
    "description": "An issue was discovered in Xen 4.14.x. There is a missing unlock in the XENMEM_acquire_resource error path. The RCU (Read, Copy, Update) mechanism is a synchronisation primitive. A buggy error path in the XENMEM_acquire_resource exits without releasing an RCU reference, which is conceptually similar to forgetting to unlock a spinlock. A buggy or malicious HVM stubdomain can cause an RCU reference to be leaked. This causes subsequent administration operations, (e.g., CPU offline) to livelock, resulting in a host Denial of Service. The buggy codepath has been present since Xen 4.12. Xen 4.14 and later are vulnerable to the DoS. The side effects are believed to be benign on Xen 4.12 and 4.13, but patches are provided nevertheless. The vulnerability can generally only be exploited by x86 HVM VMs, as these are generally the only type of VM that have a Qemu stubdomain. x86 PV and PVH domains, as well as ARM VMs, typically don't use a stubdomain. Only VMs using HVM stubdomains can exploit the vulnerability. VMs using PV stubdomains, or with emulators running in dom0, cannot exploit the vulnerability.",
    "affected_versions": "Xen 4.14 and later",
          "not_affected_versions": "Xen 4.12 and 4.13",
    "vulnerability": "A buggy error path in XENMEM_acquire_resource exits without releasing an RCU reference",
    "impact": "A buggy or malicious HVM stubdomain can cause an RCU reference to be leaked. This causes subsequent administration operations, (e.g., CPU offline) to livelock, resulting in a host Denial of Service.",
    "attack_vector": "x86 HVM VMs using a stubdomain",
     "attacker_requirements": "Buggy or malicious x86 HVM stubdomain.",
    "affected_architectures": [
      "x86"
    ],
     "not_affected_architectures": [
      "Arm"
    ],
      "additional_notes": "x86 PV and PVH domains, as well as ARM VMs, typically don't use a stubdomain."
         ,
          "cvss_v3_score": 6.5
    }
}
```