```
{
  "CVE-2020-25599": {
    "description": "An issue was discovered in Xen through 4.14.x. There are evtchn_reset() race conditions. Uses of EVTCHNOP_reset (potentially by a guest on itself) or XEN_DOMCTL_soft_reset (by itself covered by XSA-77) can lead to the violation of various internal assumptions. This may lead to out of bounds memory accesses or triggering of bug checks. In particular, x86 PV guests may be able to elevate their privilege to that of the host. Host and guest crashes are also possible, leading to a Denial of Service (DoS). Information leaks cannot be ruled out. All Xen versions from 4.5 onwards are vulnerable. Xen versions 4.4 and earlier are not vulnerable.",
    "vulnerability_details": {
      "root_cause": "Race conditions in the evtchn_reset() function during event channel resets or soft resets of a domain.",
      "weaknesses": [
        "Race condition",
        "Violation of internal assumptions",
        "Out-of-bounds memory access"
      ],
      "impact": "Privilege escalation for x86 PV guests, host and guest crashes, denial of service, potential information leaks.",
      "attack_vectors": "Malicious or buggy guest can trigger the race conditions by using EVTCHNOP_reset on itself or via XEN_DOMCTL_soft_reset.",
      "attacker_capabilities": "The attacker needs to be a guest with the ability to control event channel reset operations."
    }
  },
    "CVE-2020-25602": {
    "description": "An issue was discovered in Xen through 4.14.x. An x86 PV guest can trigger a host OS crash when handling guest access to MSR_MISC_ENABLE. When a guest accesses certain Model Specific Registers, Xen first reads the value from hardware to use as the basis for auditing the guest access. For the MISC_ENABLE MSR, which is an Intel specific MSR, this MSR read is performed without error handling for a #GP fault, which is the consequence of trying to read this MSR on non-Intel hardware. A buggy or malicious PV guest administrator can crash Xen, resulting in a host Denial of Service. Only x86 systems are vulnerable. ARM systems are not vulnerable. Only Xen versions 4.11 and onwards are vulnerable. 4.10 and earlier are not vulnerable. Only x86 systems that do not implement the MISC_ENABLE MSR (0x1a0) are vulnerable. AMD and Hygon systems do not implement this MSR and are vulnerable. Intel systems do implement this MSR and are not vulnerable. Other manufacturers have not been checked. Only x86 PV guests can exploit the vulnerability. x86 HVM/PVH guests cannot exploit the vulnerability.",
    "vulnerability_details": {
      "root_cause": "Lack of error handling when reading the MSR_MISC_ENABLE register on non-Intel x86 hardware.",
      "weaknesses": [
        "Missing error handling",
        "Unchecked hardware access"
      ],
      "impact": "Host Denial of Service (DoS) via a host OS crash.",
      "attack_vectors": "A buggy or malicious x86 PV guest triggers the vulnerability by accessing the MSR_MISC_ENABLE register on non-Intel x86 hardware.",
      "attacker_capabilities": "Attacker needs to be an x86 PV guest administrator with the ability to access Model Specific Registers."
    }
  },
  "CVE-2020-25601": {
    "description": "An issue was discovered in Xen through 4.14.x. There is a lack of preemption in evtchn_reset() / evtchn_destroy(). In particular, the FIFO event channel model allows guests to have a large number of event channels active at a time. Closing all of these (when resetting all event channels or when cleaning up after the guest) may take extended periods of time. So far, there was no arrangement for preemption at suitable intervals, allowing a CPU to spend an almost unbounded amount of time in the processing of these operations. Malicious or buggy guest kernels can mount a Denial of Service (DoS) attack affecting the entire system. All Xen versions are vulnerable in principle. Whether versions 4.3 and older are vulnerable depends on underlying hardware characteristics.",
    "vulnerability_details": {
      "root_cause": "Lack of preemption when processing multiple event channel resets/destroys.",
      "weaknesses": [
         "Lack of preemption",
         "Unbounded CPU time usage"
      ],
      "impact": "Denial of service (DoS) on the host system.",
      "attack_vectors": "Malicious or buggy guest kernels can trigger the vulnerability by creating a large number of event channels and then resetting/destroying them.",
      "attacker_capabilities": "A malicious or buggy guest kernel is required to trigger the vulnerability."
    }
  },
  "CVE-2020-25597": {
    "description": "An issue was discovered in Xen through 4.14.x. There is mishandling of the constraint that once-valid event channels may not turn invalid. Logic in the handling of event channel operations in Xen assumes that an event channel, once valid, will not become invalid over the life time of a guest. However, operations like the resetting of all event channels may involve decreasing one of the bounds checked when determining validity. This may lead to bug checks triggering, crashing the host. An unprivileged guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system. All Xen versions from 4.4 onwards are vulnerable. Xen versions 4.3 and earlier are not vulnerable. Only systems with untrusted guests permitted to create more than the default number of event channels are vulnerable. This number depends on the architecture and type of guest. For 32-bit x86 PV guests, this is 1023; for 64-bit x86 PV guests, and for all ARM guests, this number is 4095. Systems where untrusted guests are limited to fewer than this number are not vulnerable. Note that xl and libxl limit max_event_channels to 1023 by default, so systems using exclusively xl, libvirt+libxl, or their own toolstack based on libxl, and not explicitly setting max_event_channels, are not vulnerable.",
      "vulnerability_details": {
      "root_cause": "Mishandling of event channel validity during reset operations.",
      "weaknesses": [
        "Incorrect assumption about event channel validity",
        "Insufficient bounds checking"
      ],
      "impact": "Denial of Service (DoS) due to host crash.",
      "attack_vectors": "An unprivileged guest creates more event channels than allowed and then attempts to reset them.",
     "attacker_capabilities":"Guest with the ability to create more than default event channels."
      }
  },
   "CVE-2020-25600": {
      "description": "An issue was discovered in Xen through 4.14.x. Out of bounds event channels are available to 32-bit x86 domains. The so called 2-level event channel model imposes different limits on the number of usable event channels for 32-bit x86 domains vs 64-bit or Arm (either bitness) ones. 32-bit x86 domains can use only 1023 channels, due to limited space in their shared (between guest and Xen) information structure, whereas all other domains can use up to 4095 in this model. The recording of the respective limit during domain initialization, however, has occurred at a time where domains are still deemed to be 64-bit ones, prior to actually honoring respective domain properties. At the point domains get recognized as 32-bit ones, the limit didn't get updated accordingly. Due to this misbehavior in Xen, 32-bit domains (including Domain 0) servicing other domains may observe event channel allocations to succeed when they should really fail. Subsequent use of such event channels would then possibly lead to corruption of other parts of the shared info structure. An unprivileged guest may cause another domain, in particular Domain 0, to misbehave. This may lead to a Denial of Service (DoS) for the entire system. All Xen versions from 4.4 onwards are vulnerable. Xen versions 4.3 and earlier are not vulnerable. Only x86 32-bit domains servicing other domains are vulnerable. Arm systems, as well as x86 64-bit domains, are not vulnerable.",
      "vulnerability_details": {
      "root_cause": "Incorrect event channel limits for 32-bit x86 domains.",
        "weaknesses": [
          "Out-of-bounds event channel allocation",
           "Incorrect domain initialization",
           "Insufficient limit update"
        ],
        "impact": "Denial of Service (DoS) due to misbehavior of domain 0 and other domains.",
        "attack_vectors": "An unprivileged guest in a 32-bit x86 domain, or domain 0 using 32-bit, can cause other domains to misbehave by using more event channels than allowed.",
        "attacker_capabilities": "Attacker needs to be an x86 32-bit domain with the ability to allocate event channels."
    }
   },
   "CVE-2020-25598": {
      "description": "An issue was discovered in Xen 4.14.x. There is a missing unlock in the XENMEM_acquire_resource error path. The RCU (Read, Copy, Update) mechanism is a synchronisation primitive. A buggy error path in the XENMEM_acquire_resource exits without releasing an RCU reference, which is conceptually similar to forgetting to unlock a spinlock. A buggy or malicious HVM stubdomain can cause an RCU reference to be leaked. This causes subsequent administration operations, (e.g., CPU offline) to livelock, resulting in a host Denial of Service. The buggy codepath has been present since Xen 4.12. Xen 4.14 and later are vulnerable to the DoS. The side effects are believed to be benign on Xen 4.12 and 4.13, but patches are provided nevertheless. The vulnerability can generally only be exploited by x86 HVM VMs, as these are generally the only type of VM that have a Qemu stubdomain. x86 PV and PVH domains, as well as ARM VMs, typically don't use a stubdomain. Only VMs using HVM stubdomains can exploit the vulnerability. VMs using PV stubdomains, or with emulators running in dom0, cannot exploit the vulnerability.",
        "vulnerability_details": {
         "root_cause": "Missing RCU unlock in error path within XENMEM_acquire_resource function.",
         "weaknesses": [
           "Resource leak",
           "Missing unlock",
           "Improper synchronization"
         ],
        "impact": "Host denial of service via RCU reference leak causing a livelock.",
        "attack_vectors": "A buggy or malicious HVM stubdomain causes an RCU reference leak through the XENMEM_acquire_resource function error path, causing livelocks during subsequent admin operations.",
        "attacker_capabilities":"Attacker needs to be an x86 HVM stubdomain capable of triggering the error path in XENMEM_acquire_resource."
    }
  },
  "CVE-2020-25603": {
  "description":"An issue was discovered in Xen through 4.14.x. There are missing memory barriers when accessing/allocating an event channel. The event channel handling code had overlooked the necessity to insert memory barriers in certain places, when accessing/allocating data structures of event channels. This may lead to race conditions, resulting in data corruptions or other undefined behavior. While it is not known what could be the final result of such races, system-wide crashes may occur. A buggy or malicious guest may cause other guests, or in particular the host, to misbehave. This may lead to a Denial of Service (DoS) for the entire system. All Xen versions from 4.4 onwards are vulnerable. Xen versions 4.3 and earlier are not vulnerable. All systems with the 2-level event channel model enabled are vulnerable. This is generally true for all x86, and Arm systems. Systems using the old 1-level event channel model are not vulnerable.",
   "vulnerability_details": {
     "root_cause": "Missing memory barriers during event channel access/allocation.",
      "weaknesses": [
        "Missing memory barriers",
        "Race condition",
        "Data corruption"
      ],
      "impact": "Potential data corruption, system-wide crashes, and Denial of Service (DoS).",
      "attack_vectors": "A buggy or malicious guest can cause race conditions, leading to data corruption and crashes.",
     "attacker_capabilities": "An unprivileged guest with control over event channel operations is needed."
    }
  },
  "CVE-2020-25604": {
  "description":"An issue was discovered in Xen through 4.14.x. There is a race when migrating timers between x86 HVM vCPUs. The timer handling of x86 HVM guests can have different timers attached to different vCPUs. It is possible for one vCPU to trigger a timer in another vCPU. While such a handoff operation is being performed (and which is protected by a lock), a different vCPU, during migration, may try to move the timer from one vCPU to the other. Because the lock is taken from different vCPUs, the migration may end up running the timer on more than one vCPU at the same time. An unprivileged guest may cause a hypervisor crash, leading to a host Denial of Service. Xen versions 4.4 and earlier are not vulnerable. All later Xen versions are vulnerable. Only x86 HVM guests (i.e. guests with a stub domain) can exploit the vulnerability. x86 PV and PVH domains, and Arm, are not vulnerable.",
    "vulnerability_details": {
      "root_cause": "Race condition during timer migration between x86 HVM vCPUs.",
        "weaknesses": [
          "Race condition",
           "Improper locking",
           "Inconsistent vCPU states"
        ],
        "impact": "Host Denial of Service (DoS) by causing a hypervisor crash.",
        "attack_vectors": "An unprivileged x86 HVM guest can trigger the race condition during timer migrations between vCPUs.",
        "attacker_capabilities": "Attacker needs to be a x86 HVM guest with control over timer events and can cause vCPU migration. "
    }
  },
  "CVE-2020-25595": {
  "description": "An issue was discovered in Xen through 4.14.x. PCI passthrough code is reading back hardware registers. The code that implements PCI passthrough has been doing readbacks of hardware registers in the hypervisor. In theory this can be an issue, if a guest modifies these registers in a certain way and a subsequent readback would result in a hypervisor crash. As no such issues have been reported, this issue is to be considered as an edge case, not of significant immediate concern. An unprivileged guest may be able to crash the hypervisor, resulting in a host Denial of Service (DoS). All Xen versions from 4.4 onwards are vulnerable. Xen versions 4.3 and earlier are not vulnerable. Only systems where a guest has access to PCI passthrough devices are vulnerable. Furthermore, the PCI device needs to behave in a certain way, in order for the hypervisor to crash.",
   "vulnerability_details":{
    "root_cause": "Hypervisor reading back hardware registers during PCI passthrough.",
       "weaknesses": [
         "Direct hardware access from hypervisor",
         "Potential for register manipulation",
         "Missing validation of hardware behavior"
        ],
        "impact": "Potential host crash leading to a Denial of Service (DoS).",
        "attack_vectors": "A guest with access to PCI passthrough devices can modify specific registers to cause the hypervisor to crash when reading them back.",
        "attacker_capabilities":"Attacker requires guest access with ability to modify PCI passthrough devices and cause register readback."
        }
   },
   "CVE-2020-25596": {
   "description":"An issue was discovered in Xen through 4.14.x. An x86 PV guest kernel can trigger a denial of service (DoS) via SYSENTER. The SYSENTER instruction is used by some operating systems to achieve fast system call execution, and is part of the x86 instruction set architecture. When the hypervisor is invoked via SYSENTER, it has to perform a check for whether the guest has a valid system call entry point set up. This check, however, did not check all values of registers involved in the check. If a guest modifies a register to a specific high value, the hypervisor may enter an infinite loop. An unprivileged guest may cause a hypervisor crash, resulting in a host Denial of Service. Only x86 systems are vulnerable. ARM systems are not vulnerable. Only Xen versions 4.11 and later are vulnerable. 4.10 and earlier are not vulnerable. Only x86 PV guests can trigger the vulnerability. x86 HVM/PVH guests cannot trigger the vulnerability.",
      "vulnerability_details": {
      "root_cause": "Insufficient register check within the hypervisor's SYSENTER handler.",
        "weaknesses": [
           "Insufficient validation of system call entry point",
            "Missing register checks",
             "Potential for infinite loop"
         ],
         "impact": "Host Denial of Service (DoS) due to hypervisor crash via an infinite loop.",
         "attack_vectors": "An x86 PV guest kernel can trigger the infinite loop by setting a specific high value in a register before using the SYSENTER instruction.",
         "attacker_capabilities": "Attacker needs to be an x86 PV guest with control of system call execution."
    }
  }
}
```