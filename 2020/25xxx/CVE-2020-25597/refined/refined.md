```
{
  "CVE-2020-25597": {
    "description": "An issue was discovered in Xen through 4.14.x. There is mishandling of the constraint that once-valid event channels may not turn invalid. Logic in the handling of event channel operations in Xen assumes that an event channel, once valid, will not become invalid over the life time of a guest. However, operations like the resetting of all event channels may involve decreasing one of the bounds checked when determining validity. This may lead to bug checks triggering, crashing the host. An unprivileged guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system. All Xen versions from 4.4 onwards are vulnerable. Xen versions 4.3 and earlier are not vulnerable. Only systems with untrusted guests permitted to create more than the default number of event channels are vulnerable. This number depends on the architecture and type of guest. For 32-bit x86 PV guests, this is 1023; for 64-bit x86 PV guests, and for all ARM guests, this number is 4095. Systems where untrusted guests are limited to fewer than this number are not vulnerable. Note that xl and libxl limit max_event_channels to 1023 by default, so systems using exclusively xl, libvirt+libxl, or their own toolstack based on libxl, and not explicitly setting max_event_channels, are not vulnerable.",
    "root_cause": "Mishandling of the constraint that once-valid event channels may not turn invalid during event channel resetting operations.",
    "weaknesses": [
      "Incorrect assumptions about the lifecycle of event channels",
      "Insufficient validation of event channel bounds during operations"
    ],
    "impact": "A denial of service (DoS) can be triggered for the entire system.",
    "attack_vectors": [
      "Unprivileged guest crashing Xen"
    ],
    "required_capabilities": "An unprivileged guest with permission to create more than the default number of event channels."
  },
  "CVE-2020-25595": {
    "description": "An issue was discovered in Xen through 4.14.x. The PCI passthrough code improperly uses register data. Code paths in Xen's MSI handling have been identified that act on unsanitized values read back from device hardware registers. While devices strictly compliant with PCI specifications shouldn't be able to affect these registers, experience shows that it's very common for devices to have out-of-spec \"backdoor\" operations that can affect the result of these reads. A not fully trusted guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system. Privilege escalation and information leaks cannot be excluded. All versions of Xen supporting PCI passthrough are affected. Only x86 systems are vulnerable. Arm systems are not vulnerable. Only guests with passed through PCI devices may be able to leverage the vulnerability. Only systems passing through devices with out-of-spec (\"backdoor\") functionality can cause issues. Experience shows that such out-of-spec functionality is common; unless you have reason to believe that your device does not have such functionality, it's better to assume that it does.",
     "root_cause": "The PCI passthrough code improperly uses register data by acting on unsanitized values read back from device hardware registers, potentially affected by out-of-spec device behavior.",
     "weaknesses": [
       "Use of unsanitized hardware register data",
       "Lack of input validation for hardware register reads"
     ],
     "impact": "Crash of the Xen hypervisor leading to a Denial of Service (DoS) for the entire system. Privilege escalation and information leaks cannot be excluded.",
     "attack_vectors": [
       "Malicious or buggy guests with passed through PCI devices",
	    "Devices with out-of-spec functionality"
     ],
    "required_capabilities": "A not fully trusted guest with a passed through PCI device. A device with out-of-spec 'backdoor' functionality."
  },
    "CVE-2020-25596": {
    "description": "An issue was discovered in Xen through 4.14.x. x86 PV guest kernels can experience denial of service via SYSENTER. The SYSENTER instruction leaves various state sanitization activities to software. One of Xen's sanitization paths injects a #GP fault, and incorrectly delivers it twice to the guest. This causes the guest kernel to observe a kernel-privilege #GP fault (typically fatal) rather than a user-privilege #GP fault (usually converted into SIGSEGV/etc.). Malicious or buggy userspace can crash the guest kernel, resulting in a VM Denial of Service. All versions of Xen from 3.2 onwards are vulnerable. Only x86 systems are vulnerable. ARM platforms are not vulnerable. Only x86 systems that support the SYSENTER instruction in 64bit mode are vulnerable. This is believed to be Intel, Centaur, and Shanghai CPUs. AMD and Hygon CPUs are not believed to be vulnerable. Only x86 PV guests can exploit the vulnerability. x86 PVH / HVM guests cannot exploit the vulnerability.",
    "root_cause": "Incorrect delivery of a #GP fault during SYSENTER instruction sanitization by Xen, causing a fatal kernel-level fault instead of a user-level fault.",
    "weaknesses": [
      "Improper fault handling during SYSENTER instruction sanitization",
      "Double delivery of #GP fault to the guest"
    ],
    "impact": "Denial of Service (DoS) of the virtual machine.",
    "attack_vectors": [
      "Malicious or buggy userspace in x86 PV guests",
        "Use of SYSENTER instruction."
    ],
    "required_capabilities": "An x86 PV guest running on Intel, Centaur, or Shanghai CPUs."
  },
  "CVE-2020-25598": {
    "description": "An issue was discovered in Xen 4.14.x. There is a missing unlock in the XENMEM_acquire_resource error path. The RCU (Read, Copy, Update) mechanism is a synchronisation primitive. A buggy error path in the XENMEM_acquire_resource exits without releasing an RCU reference, which is conceptually similar to forgetting to unlock a spinlock. A buggy or malicious HVM stubdomain can cause an RCU reference to be leaked. This causes subsequent administration operations, (e.g., CPU offline) to livelock, resulting in a host Denial of Service. The buggy codepath has been present since Xen 4.12. Xen 4.14 and later are vulnerable to the DoS. The side effects are believed to be benign on Xen 4.12 and 4.13, but patches are provided nevertheless. The vulnerability can generally only be exploited by x86 HVM VMs, as these are generally the only type of VM that have a Qemu stubdomain. x86 PV and PVH domains, as well as ARM VMs, typically don't use a stubdomain. Only VMs using HVM stubdomains can exploit the vulnerability. VMs using PV stubdomains, or with emulators running in dom0, cannot exploit the vulnerability.",
   "root_cause": "A missing RCU unlock in the error path of `XENMEM_acquire_resource`, resulting in a resource leak and livelock of administrative operations.",
    "weaknesses": [
      "Missing resource release on error",
       "Improper usage of the RCU mechanism"
    ],
    "impact": "Denial of Service (DoS) of the host system due to livelock during administrative operations",
    "attack_vectors": [
	    "Buggy or malicious HVM stubdomain operations causing resource leaks",
      "x86 HVM VMs using a Qemu stubdomain"
    ],
    "required_capabilities": "A buggy or malicious HVM VM using a Qemu stubdomain."
   },
  "CVE-2020-25599": {
    "description": "An issue was discovered in Xen through 4.14.x. There are evtchn_reset() race conditions. Uses of EVTCHNOP_reset (potentially by a guest on itself) or XEN_DOMCTL_soft_reset (by itself covered by XSA-77) can lead to the violation of various internal assumptions. This may lead to out of bounds memory accesses or triggering of bug checks. In particular, x86 PV guests may be able to elevate their privilege to that of the host. Host and guest crashes are also possible, leading to a Denial of Service (DoS). Information leaks cannot be ruled out. All Xen versions from 4.5 onwards are vulnerable. Xen versions 4.4 and earlier are not vulnerable.",
      "root_cause": "Race conditions in `evtchn_reset()` leading to the violation of internal assumptions and potential out-of-bounds memory access or bug checks.",
    "weaknesses": [
	    "Race conditions in event channel handling",
	    "Lack of proper synchronization in event channel operations"
     ],
    "impact": "Host and guest crashes leading to denial of service (DoS). Potential privilege escalation for x86 PV guests and information leaks.",
    "attack_vectors": [
      "x86 PV guests using EVTCHNOP_reset or XEN_DOMCTL_soft_reset",
         "Race conditions during event channel reset"
    ],
    "required_capabilities": "x86 PV guests and the ability to trigger event channel reset operations."
  },
   "CVE-2020-25600": {
    "description": "An issue was discovered in Xen through 4.14.x. Out of bounds event channels are available to 32-bit x86 domains. The so called 2-level event channel model imposes different limits on the number of usable event channels for 32-bit x86 domains vs 64-bit or Arm (either bitness) ones. 32-bit x86 domains can use only 1023 channels, due to limited space in their shared (between guest and Xen) information structure, whereas all other domains can use up to 4095 in this model. The recording of the respective limit during domain initialization, however, has occurred at a time where domains are still deemed to be 64-bit ones, prior to actually honoring respective domain properties. At the point domains get recognized as 32-bit ones, the limit didn't get updated accordingly. Due to this misbehavior in Xen, 32-bit domains (including Domain 0) servicing other domains may observe event channel allocations to succeed when they should really fail. Subsequent use of such event channels would then possibly lead to corruption of other parts of the shared info structure. An unprivileged guest may cause another domain, in particular Domain 0, to misbehave. This may lead to a Denial of Service (DoS) for the entire system. All Xen versions from 4.4 onwards are vulnerable. Xen versions 4.3 and earlier are not vulnerable. Only x86 32-bit domains servicing other domains are vulnerable. Arm systems, as well as x86 64-bit domains, are not vulnerable.",
     "root_cause": "Incorrect recording of event channel limits during domain initialization for 32-bit x86 domains, allowing allocation beyond the permitted limit.",
    "weaknesses": [
      "Incorrect handling of architecture-specific event channel limits",
      "Lack of validation of 32-bit domain limits after initialization"
    ],
    "impact": "Potential memory corruption in the shared information structure leading to a denial of service (DoS).",
    "attack_vectors": [
       "32-bit x86 domain servicing other domains.",
      "Out-of-bounds allocation of event channels by guests."
   ],
   "required_capabilities": "An unprivileged guest in an x86 32-bit domain (including Domain 0) servicing other domains."
  },
    "CVE-2020-25601": {
    "description": "An issue was discovered in Xen through 4.14.x. There is a lack of preemption in evtchn_reset() / evtchn_destroy(). The event channel handling code relies on multiple assumptions to avoid race conditions. Lack of preemption in particular places of evtchn_reset() / evtchn_destroy() can lead to race conditions which violate those assumptions. This may result in out of bounds memory accesses or triggering of bug checks. In particular x86 PV guests may be able to elevate their privilege to that of the host. Host and guest crashes are also possible, leading to a Denial of Service (DoS). Information leaks cannot be ruled out. All Xen versions from 4.4 onwards are vulnerable. Xen versions 4.3 and earlier are not vulnerable.",
    "root_cause": "Lack of preemption in `evtchn_reset()` and `evtchn_destroy()` leading to race conditions and violation of internal assumptions.",
    "weaknesses": [
      "Missing preemption in critical event channel handling code",
      "Race conditions due to lack of synchronization"
    ],
    "impact": "Potential out-of-bounds memory access, triggering of bug checks, host or guest crashes, leading to a denial of service (DoS) or privilege escalation, and information leaks.",
    "attack_vectors": [
      "x86 PV guests using `evtchn_reset()` or `evtchn_destroy()`.",
      "Race conditions due to lack of preemption."
    ],
    "required_capabilities": "x86 PV guest and the ability to trigger `evtchn_reset()` or `evtchn_destroy()` operations."
  },
   "CVE-2020-25602": {
    "description": "An issue was discovered in Xen through 4.14.x. x86 PV guest kernels can experience a crash when handling guest access to MSR_MISC_ENABLE. The MSR_MISC_ENABLE model specific register is intended to be accessed from user-space only. Xen enforces this requirement by injecting a #GP fault on attempts from guest kernels. However, the handling of #GP faults arising from access to this register is buggy in PV guests, leading to a crash of the guest. This allows a malicious guest kernel or kernel module to crash a VM. This may lead to a Denial of Service (DoS) for the guest. All versions of Xen from 4.5 onwards are vulnerable. Xen versions 4.4 and earlier are not vulnerable. Only x86 systems are vulnerable. ARM systems are not vulnerable. Only x86 PV guests can exploit the vulnerability. HVM/PVH guests cannot exploit the vulnerability.",
     "root_cause": "Buggy handling of #GP faults arising from guest kernel access to MSR_MISC_ENABLE, causing a guest crash.",
    "weaknesses": [
      "Improper fault handling of access to a model specific register",
      "Missing validation of access privileges"
    ],
    "impact": "Crash of a x86 PV guest kernel, leading to a Denial of Service (DoS) for the guest.",
    "attack_vectors": [
       "Malicious or buggy x86 PV guest kernel modules causing #GP faults",
      "Access to MSR_MISC_ENABLE from the guest kernel."
    ],
    "required_capabilities": "A malicious x86 PV guest kernel or kernel module with the ability to access the `MSR_MISC_ENABLE` register."
   },
   "CVE-2020-25603": {
     "description": "An issue was discovered in Xen through 4.14.x. There are missing memory barriers when accessing/allocating an event channel. The event channel handling code relies on multiple assumptions for correct synchronisation. Lacking memory barriers in the access/allocation path can lead to race conditions which violate those assumptions. This can result in out of bounds memory accesses or triggering of bug checks. In particular x86 PV guests may be able to elevate their privilege to that of the host. Host and guest crashes are also possible, leading to a Denial of Service (DoS). Information leaks cannot be ruled out. All Xen versions from 4.4 onwards are vulnerable. Xen versions 4.3 and earlier are not vulnerable. Only x86 PV guests are able to trigger the vulnerability. HVM/PVH guests cannot trigger the vulnerability.",
     "root_cause": "Missing memory barriers during access and allocation of event channels, leading to race conditions and potentially out-of-bounds memory access.",
     "weaknesses": [
       "Lack of proper memory barriers for event channel access",
        "Race conditions due to missing synchronization primitives."
     ],
     "impact": "Out of bounds memory accesses, triggering bug checks, host or guest crashes, leading to a denial of service (DoS), potential privilege escalation for x86 PV guests and information leaks.",
     "attack_vectors": [
       "x86 PV guests with specific event channel allocation patterns",
      "Race conditions in memory access during event channel handling."
    ],
    "required_capabilities": "An x86 PV guest with the ability to allocate and access event channels."
    },
  "CVE-2020-25604": {
      "description": "An issue was discovered in Xen through 4.14.x. There is a race when migrating timers between x86 HVM vCPU-s. When migrating a timer in the x86 HVM implementation to another vCPU, Xen has to temporarily take a lock in the vCPU containing the timer and acquire a reference to it. After transferring the timer to another vCPU, the lock has to be released. However, the code may under certain race conditions release a stale reference, which might have already been destroyed. This can lead to use-after-free issues, and trigger a bug check. A guest is not needed for this vulnerability. This may lead to a Denial of Service (DoS) for the hypervisor, affecting all VMs running on the hypervisor. All Xen versions from 4.7 onwards are vulnerable. Xen versions 4.6 and earlier are not vulnerable. Only x86 systems are vulnerable. Arm platforms are not vulnerable. Only x86 HVM guests are vulnerable. x86 PV/PVH guests do not trigger the vulnerability.",
      "root_cause": "A race condition during timer migration in x86 HVM, leading to the release of a stale reference.",
      "weaknesses": [
      "Race condition in timer migration",
      "Use-after-free vulnerability during vCPU operations"
      ],
      "impact": "Denial of service (DoS) due to hypervisor crash. Affects all VMs running on the hypervisor.",
      "attack_vectors": [
           "Race conditions during timer migration in x86 HVM implementation",
        "Migration of timers between x86 HVM vCPUs"
      ],
      "required_capabilities": " x86 HVM guests and a system undergoing timer migration."
  }
}
```