=== Content from github.com_a268eb83_20250119_120746.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fgopro%2Fgpmf-parser%2Fblob%2F2cc0af7ffee6f12934e2d57750bdf292f62b0a97%2FGPMF_parser.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fgopro%2Fgpmf-parser%2Fblob%2F2cc0af7ffee6f12934e2d57750bdf292f62b0a97%2FGPMF_parser.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=gopro%2Fgpmf-parser)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[gopro](/gopro)
/
**[gpmf-parser](/gopro/gpmf-parser)**
Public

* [Notifications](/login?return_to=%2Fgopro%2Fgpmf-parser) You must be signed in to change notification settings
* [Fork
  114](/login?return_to=%2Fgopro%2Fgpmf-parser)
* [Star
   559](/login?return_to=%2Fgopro%2Fgpmf-parser)

* [Code](/gopro/gpmf-parser)
* [Issues
  24](/gopro/gpmf-parser/issues)
* [Pull requests
  0](/gopro/gpmf-parser/pulls)
* [Actions](/gopro/gpmf-parser/actions)
* [Projects
  0](/gopro/gpmf-parser/projects)
* [Wiki](/gopro/gpmf-parser/wiki)
* [Security](/gopro/gpmf-parser/security)
* [Insights](/gopro/gpmf-parser/pulse)

Additional navigation options

* [Code](/gopro/gpmf-parser)
* [Issues](/gopro/gpmf-parser/issues)
* [Pull requests](/gopro/gpmf-parser/pulls)
* [Actions](/gopro/gpmf-parser/actions)
* [Projects](/gopro/gpmf-parser/projects)
* [Wiki](/gopro/gpmf-parser/wiki)
* [Security](/gopro/gpmf-parser/security)
* [Insights](/gopro/gpmf-parser/pulse)

## Files

 2cc0af7
## Breadcrumbs

1. [gpmf-parser](/gopro/gpmf-parser/tree/2cc0af7ffee6f12934e2d57750bdf292f62b0a97)
/
# GPMF\_parser.c

Copy path Blame  Blame
## Latest commit

## History

[History](/gopro/gpmf-parser/commits/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c)2066 lines (1758 loc) · 55.6 KB 2cc0af7
## Breadcrumbs

1. [gpmf-parser](/gopro/gpmf-parser/tree/2cc0af7ffee6f12934e2d57750bdf292f62b0a97)
/
# GPMF\_parser.c

Top
## File metadata and controls

* Code
* Blame

2066 lines (1758 loc) · 55.6 KB[Raw](https://github.com/gopro/gpmf-parser/raw/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\*! @file GPMF\_parser.c \*  \* @brief GPMF Parser library \* \* @version 1.6.2 \*  \* (C) Copyright 2017-2020 GoPro Inc (http://gopro.com/). \*  \* Licensed under either: \* - Apache License, Version 2.0, http://www.apache.org/licenses/LICENSE-2.0  \* - MIT license, http://opensource.org/licenses/MIT \* at your option. \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an "AS IS" BASIS, \* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*  \*/
#include <stdlib.h>#include <stdio.h>#include <string.h>#include <stdint.h>
#include "GPMF\_parser.h"#include "GPMF\_bitstream.h"
#ifdef DBG#if \_WINDOWS#define DBG\_MSG printf#else#define DBG\_MSG(...)#endif#else#define DBG\_MSG(...)#endif
GPMF\_ERR IsValidSize(GPMF\_stream \*ms, uint32\_t size) // size is in longs not bytes.{ if (ms) { uint32\_t nestsize = (uint32\_t)ms->nest\_size[ms->nest\_level]; if (nestsize == 0 && ms->nest\_level == 0) nestsize = ms->buffer\_size\_longs;
 if (size + 2 <= nestsize) return GPMF\_OK; } return GPMF\_ERROR\_BAD\_STRUCTURE;}
GPMF\_ERR GPMF\_Validate(GPMF\_stream \*ms, GPMF\_LEVELS recurse){ if (ms) { uint32\_t currpos = ms->pos; uint32\_t nestsize = ms->nest\_size[ms->nest\_level]; if (nestsize == 0 && ms->nest\_level == 0) nestsize = ms->buffer\_size\_longs;  while (ms->pos+1 < ms->buffer\_size\_longs && nestsize > 0) { uint32\_t key = ms->buffer[ms->pos];
 if (ms->nest\_level == 0 && key != GPMF\_KEY\_DEVICE && ms->device\_count == 0 && ms->pos == 0) { DBG\_MSG("ERROR: uninitized -- GPMF\_ERROR\_BAD\_STRUCTURE\n"); return GPMF\_ERROR\_BAD\_STRUCTURE; }
 if (GPMF\_VALID\_FOURCC(key)) { uint32\_t type\_size\_repeat = ms->buffer[ms->pos + 1]; uint32\_t size = GPMF\_DATA\_SIZE(type\_size\_repeat) >> 2; uint8\_t type = GPMF\_SAMPLE\_TYPE(type\_size\_repeat); if (size + 2 > nestsize) { DBG\_MSG("ERROR: nest size too small within %c%c%c%c-- GPMF\_ERROR\_BAD\_STRUCTURE\n", PRINTF\_4CC(key)); return GPMF\_ERROR\_BAD\_STRUCTURE; }
 if (!GPMF\_VALID\_FOURCC(key)) { DBG\_MSG("ERROR: invalid 4CC -- GPMF\_ERROR\_BAD\_STRUCTURE\n"); return GPMF\_ERROR\_BAD\_STRUCTURE; }
 if (type == GPMF\_TYPE\_NEST && recurse == GPMF\_RECURSE\_LEVELS) { uint32\_t validnest; ms->pos += 2; ms->nest\_level++; if (ms->nest\_level > GPMF\_NEST\_LIMIT) { DBG\_MSG("ERROR: nest level within %c%c%c%c too deep -- GPMF\_ERROR\_BAD\_STRUCTURE\n", PRINTF\_4CC(key)); return GPMF\_ERROR\_BAD\_STRUCTURE; } ms->nest\_size[ms->nest\_level] = size; validnest = GPMF\_Validate(ms, recurse); ms->nest\_level--; if (GPMF\_OK != validnest) { DBG\_MSG("ERROR: invalid nest within %c%c%c%c -- GPMF\_ERROR\_BAD\_STRUCTURE\n", PRINTF\_4CC(key)); return GPMF\_ERROR\_BAD\_STRUCTURE; } else { if (ms->nest\_level == 0) ms->device\_count++; }
 ms->pos += size; nestsize -= 2 + size;
 while (ms->pos < ms->buffer\_size\_longs && nestsize > 0 && ms->buffer[ms->pos] == GPMF\_KEY\_END) { ms->pos++; nestsize--; } } else { ms->pos += 2 + size; nestsize -= 2 + size; }
 if (ms->pos == ms->buffer\_size\_longs) { ms->pos = currpos; return GPMF\_OK; } } else { if (key == GPMF\_KEY\_END) { do { ms->pos++; nestsize--; } while (ms->pos < ms->buffer\_size\_longs && nestsize > 0 && ms->buffer[ms->pos] == 0); } else if (ms->nest\_level == 0 && ms->device\_count > 0) { ms->pos = currpos; return GPMF\_OK; } else { DBG\_MSG("ERROR: bad struct within %c%c%c%c -- GPMF\_ERROR\_BAD\_STRUCTURE\n", PRINTF\_4CC(key)); return GPMF\_ERROR\_BAD\_STRUCTURE; } } }
 ms->pos = currpos; return GPMF\_OK; } else { DBG\_MSG("ERROR: Invalid handle -- GPMF\_ERROR\_MEMORY\n"); return GPMF\_ERROR\_MEMORY; }}
GPMF\_ERR GPMF\_ResetState(GPMF\_stream \*ms){ if (ms) { ms->pos = 0; ms->nest\_level = 0; ms->device\_count = 0; ms->nest\_size[ms->nest\_level] = 0; ms->last\_level\_pos[ms->nest\_level] = 0; ms->last\_seek[ms->nest\_level] = 0; ms->device\_id = 0; ms->device\_name[0] = 0;
 return GPMF\_OK; }  return GPMF\_ERROR\_MEMORY;}
GPMF\_ERR GPMF\_Init(GPMF\_stream \*ms, uint32\_t \*buffer, uint32\_t datasize){ if(ms && buffer && datasize > 0) { uint32\_t pos = 0; //Validate DEVC GPMF while((pos+1) \* 4 < datasize && buffer[pos] == GPMF\_KEY\_DEVICE) { uint32\_t size = GPMF\_DATA\_SIZE(buffer[pos+1]); pos += 2 + (size >> 2); } if ((pos\*4) < datasize && buffer[pos] == GPMF\_KEY\_END) // NULL terminated GPMF { datasize = pos \* 4; } if (pos \* 4 == datasize) { ms->buffer = buffer; ms->buffer\_size\_longs = (datasize + 3) >> 2; ms->cbhandle = 0;
 GPMF\_ResetState(ms);
 return GPMF\_OK; } else { return GPMF\_ERROR\_BAD\_STRUCTURE; } }  return GPMF\_ERROR\_MEMORY;}
GPMF\_ERR GPMF\_CopyState(GPMF\_stream \*msrc, GPMF\_stream \*mdst){ if (msrc && mdst) { memcpy(mdst, msrc, sizeof(GPMF\_stream)); return GPMF\_OK; } return GPMF\_ERROR\_MEMORY;}
GPMF\_ERR GPMF\_Next(GPMF\_stream \*ms, GPMF\_LEVELS recurse){ if (ms) { if (ms->pos+1 < ms->buffer\_size\_longs) {
 uint32\_t key, type = GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 1]); uint32\_t size = (GPMF\_DATA\_SIZE(ms->buffer[ms->pos + 1]) >> 2);
 if (GPMF\_OK != IsValidSize(ms, size)) return GPMF\_ERROR\_BAD\_STRUCTURE;
 if (GPMF\_TYPE\_NEST == type && GPMF\_KEY\_DEVICE == ms->buffer[ms->pos] && ms->nest\_level == 0) { ms->last\_level\_pos[ms->nest\_level] = ms->pos; ms->nest\_size[ms->nest\_level] = size; if (recurse) ms->pos += 2; else ms->pos += 2 + size; } else { if (size + 2 > ms->nest\_size[ms->nest\_level]) return GPMF\_ERROR\_BAD\_STRUCTURE;
 if (recurse && type == GPMF\_TYPE\_NEST) { ms->last\_level\_pos[ms->nest\_level] = ms->pos; ms->pos += 2; ms->nest\_size[ms->nest\_level] -= size + 2;
 ms->nest\_level++; if (ms->nest\_level > GPMF\_NEST\_LIMIT) return GPMF\_ERROR\_BAD\_STRUCTURE;
 ms->nest\_size[ms->nest\_level] = size; } else { if (recurse) { ms->pos += size + 2; ms->nest\_size[ms->nest\_level] -= size + 2; } else { if (ms->nest\_size[ms->nest\_level] - (size + 2) > 0) { ms->pos += size + 2; ms->nest\_size[ms->nest\_level] -= size + 2; } else { return GPMF\_ERROR\_LAST;  } } } }
 while (ms->pos < ms->buffer\_size\_longs && ms->nest\_size[ms->nest\_level] > 0 && ms->buffer[ms->pos] == GPMF\_KEY\_END) { ms->pos++; ms->nest\_size[ms->nest\_level]--; }
 while (ms->nest\_level > 0 && ms->nest\_size[ms->nest\_level] == 0) { ms->nest\_level--; //if (ms->nest\_level == 0) //{ // ms->device\_count++; //} }
 if (ms->pos < ms->buffer\_size\_longs) { while (ms->pos < ms->buffer\_size\_longs && ms->nest\_size[ms->nest\_level] > 0 && ms->buffer[ms->pos] == GPMF\_KEY\_END) { ms->pos++; ms->nest\_size[ms->nest\_level]--; }
 key = ms->buffer[ms->pos]; if (!GPMF\_VALID\_FOURCC(key)) return GPMF\_ERROR\_BAD\_STRUCTURE;
 if (key == GPMF\_KEY\_DEVICE\_ID) ms->device\_id = BYTESWAP32(ms->buffer[ms->pos + 2]); if (key == GPMF\_KEY\_DEVICE\_NAME) { size = GPMF\_DATA\_SIZE(ms->buffer[ms->pos + 1]); // in bytes if (size > sizeof(ms->device\_name) - 1) size = sizeof(ms->device\_name) - 1; memcpy(ms->device\_name, &ms->buffer[ms->pos + 2], size); ms->device\_name[size] = 0; } } else { // end of buffer return GPMF\_ERROR\_BUFFER\_END; }
 return GPMF\_OK; } else { // end of buffer return GPMF\_ERROR\_BUFFER\_END; } } return GPMF\_ERROR\_MEMORY;}
GPMF\_ERR GPMF\_FindNext(GPMF\_stream \*ms, uint32\_t fourcc, GPMF\_LEVELS recurse){ GPMF\_stream prevstate;
 if (ms) { memcpy(&prevstate, ms, sizeof(GPMF\_stream));
 if (ms->pos < ms->buffer\_size\_longs) { while (0 == GPMF\_Next(ms, recurse)) { if (ms->buffer[ms->pos] == fourcc) { return GPMF\_OK; //found match } }
 // restore read position memcpy(ms, &prevstate, sizeof(GPMF\_stream)); return GPMF\_ERROR\_FIND; } } return GPMF\_ERROR\_FIND;}
GPMF\_ERR GPMF\_Reserved(uint32\_t key){ if(key == GPMF\_KEY\_DEVICE) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_DEVICE\_ID) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_DEVICE\_NAME) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_STREAM) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_STREAM\_NAME) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_SI\_UNITS) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_UNITS) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_SCALE) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_TYPE) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_TOTAL\_SAMPLES) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_TICK) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_TOCK) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_EMPTY\_PAYLOADS) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_REMARK) return GPMF\_ERROR\_RESERVED;
 return GPMF\_OK;}
uint32\_t GPMF\_PayloadSampleCount(GPMF\_stream \*ms){ uint32\_t count = 0; if (ms) { uint32\_t fourcc = GPMF\_Key(ms);
 GPMF\_stream find\_stream; GPMF\_CopyState(ms, &find\_stream);
 if (GPMF\_OK == GPMF\_FindNext(&find\_stream, fourcc, GPMF\_CURRENT\_LEVEL)) // Count the instances, not the repeats { count=2; while (GPMF\_OK == GPMF\_FindNext(&find\_stream, fourcc, GPMF\_CURRENT\_LEVEL)) { count++; }  } else { count = GPMF\_Repeat(ms); if (count == 0) // this can happen with an empty FACE, yet this is still a FACE fouce count = 1; } } return count;}
GPMF\_ERR GPMF\_SeekToSamples(GPMF\_stream \*ms){ GPMF\_stream prevstate;
 if (ms) {
 if (ms->pos+1 < ms->buffer\_size\_longs) { uint32\_t type = GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 1]);
 memcpy(&prevstate, ms, sizeof(GPMF\_stream));
 if (type == GPMF\_TYPE\_NEST) GPMF\_Next(ms, GPMF\_RECURSE\_LEVELS); // open STRM and recurse in
 while (0 == GPMF\_Next(ms, GPMF\_CURRENT\_LEVEL)) { uint32\_t size = (GPMF\_DATA\_SIZE(ms->buffer[ms->pos + 1]) >> 2); if (GPMF\_OK != IsValidSize(ms, size)) { memcpy(ms, &prevstate, sizeof(GPMF\_stream)); return GPMF\_ERROR\_BAD\_STRUCTURE; }
 type = GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 1]);
 if (type == GPMF\_TYPE\_NEST) // Nest with-in nest { return GPMF\_OK; //found match }
 if (size + 2 == ms->nest\_size[ms->nest\_level]) { uint32\_t key = GPMF\_Key(ms);
 if (GPMF\_ERROR\_RESERVED == GPMF\_Reserved(key)) return GPMF\_ERROR\_FIND;  return GPMF\_OK; //found match }
 if (ms->buffer[ms->pos] == ms->buffer[ms->pos + size + 2]) // Matching tags { return GPMF\_OK; //found match } }
 // restore read position memcpy(ms, &prevstate, sizeof(GPMF\_stream)); return GPMF\_ERROR\_FIND; } } return GPMF\_ERROR\_FIND;}
GPMF\_ERR GPMF\_FindPrev(GPMF\_stream \*ms, uint32\_t fourcc, GPMF\_LEVELS recurse){ GPMF\_stream prevstate;
 if (ms) { uint32\_t curr\_level = ms->nest\_level;
 memcpy(&prevstate, ms, sizeof(GPMF\_stream));
 if (ms->pos < ms->buffer\_size\_longs && curr\_level > 0) {
 do { ms->last\_seek[curr\_level] = ms->pos; ms->pos = ms->last\_level\_pos[curr\_level - 1] + 2; ms->nest\_size[curr\_level] += ms->last\_seek[curr\_level] - ms->pos; do { if (ms->last\_seek[curr\_level] > ms->pos && ms->buffer[ms->pos] == fourcc) {
 return GPMF\_OK; //found match } } while (ms->last\_seek[curr\_level] > ms->pos && 0 == GPMF\_Next(ms, GPMF\_CURRENT\_LEVEL));
 curr\_level--; } while (recurse == GPMF\_RECURSE\_LEVELS && curr\_level > 0);
 // restore read position memcpy(ms, &prevstate, sizeof(GPMF\_stream));
 return GPMF\_ERROR\_FIND; } }
 return GPMF\_ERROR\_FIND;}
uint32\_t GPMF\_Key(GPMF\_stream \*ms){ if (ms) { uint32\_t key = ms->buffer[ms->pos]; return key; } return 0;}
GPMF\_SampleType GPMF\_Type(GPMF\_stream \*ms){ if (ms && ms->pos+1 < ms->buffer\_size\_longs) { GPMF\_SampleType type = (GPMF\_SampleType)GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos+1]); if (type == GPMF\_TYPE\_COMPRESSED && ms->pos+2 < ms->buffer\_size\_longs) { type = (GPMF\_SampleType)GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 2]); } return type; } return GPMF\_TYPE\_ERROR;}
uint32\_t GPMF\_StructSize(GPMF\_stream \*ms){ if (ms && ms->pos+1 < ms->buffer\_size\_longs) { uint32\_t ssize = GPMF\_SAMPLE\_SIZE(ms->buffer[ms->pos + 1]); uint32\_t type = GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 1]); if (type == GPMF\_TYPE\_COMPRESSED && ms->pos+2 < ms->buffer\_size\_longs) { ssize = GPMF\_SAMPLE\_SIZE(ms->buffer[ms->pos + 2]); } return ssize; } return 0;}
uint32\_t GPMF\_ElementsInStruct(GPMF\_stream \*ms){ if (ms && ms->pos+1 < ms->buffer\_size\_longs) { uint32\_t ssize = GPMF\_SAMPLE\_SIZE(ms->buffer[ms->pos + 1]); GPMF\_SampleType type = (GPMF\_SampleType) GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 1]);
 if (type != GPMF\_TYPE\_NEST && type != GPMF\_TYPE\_COMPLEX && type != GPMF\_TYPE\_COMPRESSED) { uint32\_t tsize = GPMF\_SizeofType(type); if (tsize > 0) return ssize / tsize; else return 0; } if (type == GPMF\_TYPE\_COMPLEX) { GPMF\_stream find\_stream; GPMF\_CopyState(ms, &find\_stream);
 if (GPMF\_OK == GPMF\_FindPrev(&find\_stream, GPMF\_KEY\_TYPE, GPMF\_CURRENT\_LEVEL)) { char tmp[64] = ""; uint32\_t tmpsize = sizeof(tmp); char \*data = (char \*)GPMF\_RawData(&find\_stream); uint32\_t size = GPMF\_RawDataSize(&find\_stream);  if (GPMF\_OK == GPMF\_ExpandComplexTYPE(data, size, tmp, &tmpsize)) return tmpsize; } } if (type == GPMF\_TYPE\_COMPRESSED && ms->pos+2 < ms->buffer\_size\_longs) { type = (GPMF\_SampleType)GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 2]); ssize = GPMF\_SAMPLE\_SIZE(ms->buffer[ms->pos + 2]); uint32\_t tsize = GPMF\_SizeofType(type); if (tsize > 0) return ssize / tsize; else return 0; } } return 0;}
uint32\_t GPMF\_Repeat(GPMF\_stream \*ms){ if (ms && ms->pos+1 < ms->buffer\_size\_longs) { GPMF\_SampleType type = (GPMF\_SampleType)GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 1]); uint32\_t repeat = GPMF\_SAMPLES(ms->buffer[ms->pos + 1]); if(type == GPMF\_TYPE\_COMPRESSED && ms->pos+2 < ms->buffer\_size\_longs) { repeat = GPMF\_SAMPLES(ms->buffer[ms->pos + 2]); } return repeat; } return 0;}
uint32\_t GPMF\_RawDataSize(GPMF\_stream \*ms){ if (ms && ms->pos+1 < ms->buffer\_size\_longs) { uint32\_t size = GPMF\_DATA\_PACKEDSIZE(ms->buffer[ms->pos + 1]); if (GPMF\_OK != IsValidSize(ms, size >> 2)) return 0;
 return size; } return 0;}
uint32\_t GPMF\_FormattedDataSize(GPMF\_stream \*ms){ if (ms && ms->pos + 1 < ms->buffer\_size\_longs) { GPMF\_SampleType type = (GPMF\_SampleType)GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 1]); uint32\_t size = GPMF\_SAMPLE\_SIZE(ms->buffer[ms->pos + 1])\*GPMF\_SAMPLES(ms->buffer[ms->pos + 1]);
 if (type == GPMF\_TYPE\_COMPRESSED && ms->pos+2 < ms->buffer\_size\_longs) { size = GPMF\_SAMPLE\_SIZE(ms->buffer[ms->pos + 2])\*GPMF\_SAMPLES(ms->buffer[ms->pos + 2]); } return size; } return 0;}
uint32\_t GPMF\_ScaledDataSize(GPMF\_stream \*ms, GPMF\_SampleType type){ if (ms && ms->pos + 1 < ms->buffer\_size\_longs) { uint32\_t elements = GPMF\_ElementsInStruct(ms); uint32\_t samples = GPMF\_Repeat(ms); return GPMF\_SizeofType(type) \* elements \* samples; } return 0;}
uint32\_t GPMF\_NestLevel(GPMF\_stream \*ms){ if (ms) { return ms->nest\_level; } return 0;}
uint32\_t GPMF\_DeviceID(GPMF\_stream \*ms){ if (ms) { return ms->device\_id; } return 0;}
GPMF\_ERR GPMF\_DeviceName(GPMF\_stream \*ms, char \*devicenamebuf, uint32\_t devicename\_buf\_size){ if (ms && devicenamebuf) { uint32\_t len = (uint32\_t)strlen(ms->device\_name); if (len >= devicename\_buf\_size) return GPMF\_ERROR\_MEMORY;
 memcpy(devicenamebuf, ms->device\_name, len); devicenamebuf[len] = 0; return GPMF\_OK; } return GPMF\_ERROR\_MEMORY;}
void \*GPMF\_RawData(GPMF\_stream \*ms){ if (ms) { return (void \*)&ms->buffer[ms->pos + 2]; } return NULL;}
int32\_t GPMFTypeEndianSize(int type){ int32\_t ssize = -1;
 switch ((int)type) { case GPMF\_TYPE\_STRING\_ASCII: ssize = 1; break; case GPMF\_TYPE\_SIGNED\_BYTE: ssize = 1; break; case GPMF\_TYPE\_UNSIGNED\_BYTE: ssize = 1; break; case GPMF\_TYPE\_STRING\_UTF8: ssize = 1; break;
 // These datatype can always be stored in Big-Endian case GPMF\_TYPE\_SIGNED\_SHORT: ssize = 2; break; case GPMF\_TYPE\_UNSIGNED\_SHORT: ssize = 2; break; case GPMF\_TYPE\_FLOAT: ssize = 4; break; case GPMF\_TYPE\_FOURCC: ssize = 1; break; case GPMF\_TYPE\_SIGNED\_LONG: ssize = 4; break; case GPMF\_TYPE\_UNSIGNED\_LONG: ssize = 4; break; case GPMF\_TYPE\_Q15\_16\_FIXED\_POINT: ssize = 4; break; case GPMF\_TYPE\_Q31\_32\_FIXED\_POINT: ssize = 8; break; case GPMF\_TYPE\_DOUBLE: ssize = 8; break; case GPMF\_TYPE\_SIGNED\_64BIT\_INT: ssize = 8; break; case GPMF\_TYPE\_UNSIGNED\_64BIT\_INT: ssize = 8; break;
 case GPMF\_TYPE\_GUID: ssize = 1; break; // Do not byte swap case GPMF\_TYPE\_UTC\_DATE\_TIME: ssize = 1; break; // Do not byte swap
 //All unknown,complex or larger than 8-bytes store as is: default: ssize = -1; // unsupported for structsize type }
 return ssize;}
void ByteSwap2Buffer(uint32\_t\* input, uint32\_t\* output, GPMF\_SampleType data\_type, uint32\_t structSize, uint32\_t repeat){ int32\_t i, len = 0, endianSize = GPMFTypeEndianSize(data\_type); if (endianSize == 8) // 64-bit swap required { for (i = 0; i < (int32\_t)((repeat \* structSize + 3) / sizeof(int32\_t)); i += 2) { output[len++] = BYTESWAP32(input[i + 1]);  output[len++] = BYTESWAP32(input[i]); } } else if (endianSize >= 1) { for (i = 0; i < (int32\_t)((repeat \* structSize + 3) / sizeof(int32\_t)); i++) { switch (endianSize) { case 2: output[len++] = BYTESWAP2x16(input[i]); break; case 4: output[len++] = BYTESWAP32(input[i]); break; default: output[len++] = input[i]; break; } } }}
//find and inplace overwrite a GPMF KLV with new KLV, if the lengths match.GPMF\_ERR GPMF\_Modify(GPMF\_stream\* ms, uint32\_t origfourCC, uint32\_t newfourCC,  GPMF\_SampleType newType, uint32\_t newStructSize, uint32\_t newRepeat, void\* newData){ uint32\_t dataSizeLongs = (newStructSize \* newRepeat + 3) >> 2;
 if (ms && ms->pos + 1 + dataSizeLongs < ms->buffer\_size\_longs) { GPMF\_stream fs; GPMF\_CopyState(ms, &fs);
 uint32\_t key = fs.buffer[fs.pos]; uint32\_t tsr = fs.buffer[fs.pos + 1]; uint32\_t ssize = GPMF\_SAMPLE\_SIZE(tsr); uint32\_t repeat = GPMF\_SAMPLES(tsr);
 if (key == origfourCC && (((ssize \* repeat + 3) >> 2) == ((newStructSize \* newRepeat + 3) >> 2))) // no find required and data will fit { fs.buffer[fs.pos] = newfourCC; fs.buffer[fs.pos + 1] = GPMF\_MAKE\_TYPE\_SIZE\_COUNT(newType, newStructSize, newRepeat);
 ByteSwap2Buffer((uint32\_t\*)newData, (uint32\_t\*)&fs.buffer[fs.pos + 2], newType, newStructSize, newRepeat); return GPMF\_OK; } else { // search forward from the current position at this level if (GPMF\_OK == GPMF\_FindNext(&fs, origfourCC, GPMF\_CURRENT\_LEVEL)) { tsr = fs.buffer[fs.pos + 1]; ssize = GPMF\_SAMPLE\_SIZE(tsr); repeat = GPMF\_SAMPLES(tsr);
 if (((ssize \* repeat + 3) >> 2) == ((newStructSize \* newRepeat + 3) >> 2)) //will the new data fit { fs.buffer[fs.pos] = newfourCC; fs.buffer[fs.pos + 1] = GPMF\_MAKE\_TYPE\_SIZE\_COUNT(newType, newStructSize, newRepeat);
 ByteSwap2Buffer((uint32\_t\*)newData, (uint32\_t\*)&fs.buffer[fs.pos + 2], newType, newStructSize, newRepeat); return GPMF\_OK; } return GPMF\_ERROR\_BAD\_STRUCTURE; // sizes don't match } // search backward from the current position at this level else if (GPMF\_OK == GPMF\_FindPrev(&fs, origfourCC, GPMF\_CURRENT\_LEVEL)) { tsr = fs.buffer[fs.pos + 1]; ssize = GPMF\_SAMPLE\_SIZE(tsr); repeat = GPMF\_SAMPLES(tsr);
 if (((ssize \* repeat + 3) >> 2) == ((newStructSize \* newRepeat + 3) >> 2)) //will the new data fit { fs.buffer[fs.pos] = newfourCC; fs.buffer[fs.pos + 1] = GPMF\_MAKE\_TYPE\_SIZE\_COUNT(newType, newStructSize, newRepeat);
 ByteSwap2Buffer((uint32\_t\*)newData, (uint32\_t\*)&fs.buffer[fs.pos + 2], newType, newStructSize, newRepeat); return GPMF\_OK; } return GPMF\_ERROR\_BAD\_STRUCTURE; // sizes don't match } else  { // search from the beginning through all levels GPMF\_ResetState(&fs); if (GPMF\_OK == GPMF\_FindNext(&fs, origfourCC, GPMF\_RECURSE\_LEVELS)) {  tsr = fs.buffer[fs.pos + 1]; ssize = GPMF\_SAMPLE\_SIZE(tsr); repeat = GPMF\_SAMPLES(tsr);
 if (((ssize \* repeat + 3) >> 2) == ((newStructSize \* newRepeat + 3) >> 2)) //will the new data fit { fs.buffer[fs.pos] = newfourCC; fs.buffer[fs.pos + 1] = GPMF\_MAKE\_TYPE\_SIZE\_COUNT(newType, newStructSize, newRepeat);
 ByteSwap2Buffer((uint32\_t\*)newData, (uint32\_t\*)&fs.buffer[fs.pos + 2], newType, newStructSize, newRepeat); return GPMF\_OK; } return GPMF\_ERROR\_BAD\_STRUCTURE; // sizes don't match } else return GPMF\_ERROR\_FIND; // if can't find the data to replace. } } } return GPMF\_ERROR\_BAD\_STRUCTURE; // sizes don't match}
uint32\_t GPMF\_SizeofType(GPMF\_SampleType type){ uint32\_t ssize = 0;
 switch (type) { case GPMF\_TYPE\_STRING\_ASCII: ssize = 1; break; case GPMF\_TYPE\_SIGNED\_BYTE: ssize = 1; break; case GPMF\_TYPE\_UNSIGNED\_BYTE: ssize = 1; break;
 // These datatypes are always be stored in Big-Endian case GPMF\_TYPE\_SIGNED\_SHORT: ssize = 2; break; case GPMF\_TYPE\_UNSIGNED\_SHORT: ssize = 2; break; case GPMF\_TYPE\_FLOAT: ssize = 4; break; case GPMF\_TYPE\_FOURCC: ssize = 4; break; case GPMF\_TYPE\_SIGNED\_LONG: ssize = 4; break; case GPMF\_TYPE\_UNSIGNED\_LONG: ssize = 4; break; case GPMF\_TYPE\_Q15\_16\_FIXED\_POINT: ssize = 4; break; case GPMF\_TYPE\_Q31\_32\_FIXED\_POINT: ssize = 8; break; case GPMF\_TYPE\_DOUBLE: ssize = 8; break; case GPMF\_TYPE\_SIGNED\_64BIT\_INT: ssize = 8; break; case GPMF\_TYPE\_UNSIGNED\_64BIT\_INT: ssize = 8; break;
 //All unknown or larger than 8-bytes stored as is: case GPMF\_TYPE\_GUID: ssize = 16; break; case GPMF\_TYPE\_UTC\_DATE\_TIME: ssize = 16; break; default: ssize = 0; break; }
 return ssize;}
uint32\_t GPMF\_ExpandComplexTYPE(char \*src, uint32\_t srcsize, char \*dst, uint32\_t \*dstsize){ uint32\_t i = 0, k = 0, count = 0;
 while (i<srcsize && k<\*dstsize) { if (src[i] == '[' && i>0) { uint32\_t j = 1; count = 0; while (src[i + j] >= '0' && src[i + j] <= '9') { count \*= 10; count += (uint32\_t) (src[i + j] - '0'); j++; }
 if (count > 1) { uint32\_t l; for (l = 1; l<count; l++) { dst[k] = src[i - 1]; k++; } } i += j; if (src[i] == ']') i++; } else { dst[k] = src[i]; if (dst[k] == 0) break; i++; k++; } }
 if (k >= \*dstsize) return GPMF\_ERROR\_MEMORY; // bad structure formed
 dst[k] = 0; \*dstsize = k;
 return GPMF\_OK;}
uint32\_t GPMF\_SizeOfComplexTYPE(char \*type, uint32\_t typestringlength){ char \*typearray = type; uint32\_t size = 0, expand = 0; uint32\_t i, len = typestringlength;
 for (i = 0; i < len; i++) if (typearray[i] == '[') expand = 1;  if (expand) { char exptypearray[64]; uint32\_t dstsize = sizeof(exptypearray);
 if (GPMF\_OK == GPMF\_ExpandComplexTYPE(typearray, len, exptypearray, &dstsize)) { typearray = exptypearray; len = dstsize; } else[View remainder of file in raw view](https://github.com/gopro/gpmf-parser/raw/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from blog.inhq.net_71340527_20250119_120743.html ===
![](https://mato.inhq.net/m?rec=1&bots=1&idsite=1)[invd blog](/)

[Archive](/archive/)[CVEs](/cve/)[Consulting](/consulting/)[About](/about/)

# GoPro GPMF-parser Vulnerabilities

Oct 17, 2020
â¢
Christian Reitter
ID:
CVE-2020-16158,
CVE-2020-16160,
CVE-2020-16161,
CVE-2020-16159

As part of my fuzzing research [into C parsers](/posts/base64-parser-issues/), I took a look at the open source GoPro [GPMF-parser](https://github.com/gopro/gpmf-parser) project.
The GPMF-parser software decodes custom telemetry metadata from GoPro camera video recordings.
Multimedia file parsers are notoriously difficult to write safely in C, so I expected some memory security issues and saw this as a good exercise for fuzzing.

Ultimately, this analysis led to ~25 bug reports, most of them communicated confidentially to the vendor over the course
of a long disclosure process due to security implications. After coordination with the vendor, I requested four CVEs in July to track several issues with a direct impact.

## Contents

* [Technical Background](#technical-background)
* [Summary](#summary)
  + [Product Overview](#product-overview)
  + [Main Security Issues](#main-security-issues)
  + [Potential or Out-Of-Scope Security Issues](#potential-or-out-of-scope-security-issues)
  + [Mainly Functional Issues:](#mainly-functional-issues)
* [Selection of Discovered Issues](#selection-of-discovered-issues)
  + [CVE-2020-16158](#cve-2020-16158)
  + [CVE-2020-16160](#cve-2020-16160)
  + [CVE-2020-16161](#cve-2020-16161)
  + [CVE-2020-16159](#cve-2020-16159)
  + [POC](#poc)
* [Disclosure](#disclosure)
  + [Partial Timeline](#partial-timeline)
## Consulting

*Iâm a freelance Security Consultant and currently available for new projects.
If you are looking for assistance to secure your projects or organization, [contact me](/consulting).*

## Technical Background

The [GPMF-parser documentation](https://github.com/gopro/gpmf-parser#gpmf-introduction) gives some insight into the design of the GPMF format.
Action cameras store multiple telemetry datasets within the main video container alongside the compressed video and audio, apparently for performance reasons.
On the technical side, this is done via the GPMF key-length-value structure and custom extensible markers such as FourCC.

In practice, the decoding of GPMF data from existing video files involves

1. GPMF data extraction from the video container (*not core functionality, but implemented for MP4*)
2. GPMF data parsing via the GPMF-parser library (*core functionality*)

The library ships with a standalone demo program to do this processing on MP4 file inputs.

## Summary

The discovered issues are presented in a condensed format due to the raw number of bugs.

Please note that the security issues are treated differently depending on their code origin.
Although there are existing CVEs from 2018 and 2019 for memory issues in the MP4 parsing section (*that were discovered by other researchers, see [CVE-2018-18699](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-18699), [CVE-2019-15148](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-15148)*),
GoPro indicated during the disclosure process that the MP4 parsing code is not actually in-scope.

I would probably not have researched/reported the related issues in depth if this fact would have been documented more explicitly.

Issues within the example program (marked âdemoâ) were also treated as out-of-scope and are listed here for completeness.

### Product Overview

| Project | Source | Fix | References |
| --- | --- | --- | --- |
| GPMF-parser | [GitHub](https://github.com/gopro/gpmf-parser) | [release 2.0](https://github.com/gopro/gpmf-parser/releases/tag/v2.0), [release 2.0.2](https://github.com/gopro/gpmf-parser/releases/tag/v2.0.2) | ? |

It is not documented which other internal or external projects use the GPMF-parser library.

### Main Security Issues

| ID | CVE | Description | Potential Impact | Location | CWE | POC |
| --- | --- | --- | --- | --- | --- | --- |
| 1 | [CVE-2020-16158](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-16158) | Stack-buffer-overflow out of bounds write | Crash (with stack protection) potentially arbitrary code execution | [core](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L952) | CWE-787 | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue1.mp4) |
| 17 | [CVE-2020-16160](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-16160) | Division by zero | DOS via crash (confirmed) | [core](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L1744) | CWE-369 | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue17.mp4) |
| 18 | [CVE-2020-16161](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-16161) | Division by zero | DOS via crash (confirmed) | core ([1](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L1634), [2](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L1653)) | CWE-369 | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue18.mp4) |
| 21 | [CVE-2020-16159](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-16159) | Heap out of bounds read | crash (confirmed) or information disclosure | [core](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L1657) | CWE-125 | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue21.mp4) |

### Potential or Out-Of-Scope Security Issues

| ID | Description | Potential Impact | Location | POC |
| --- | --- | --- | --- | --- |
| 2 | Stack-use-after-scope | unclear, not well defined | [core](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L1007) | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue2.mp4) |
| 3 | Heap-buffer-overflow out of bounds read | information disclosure | [demo print](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/demo/GPMF_print.c#L176) | see #2 |
| 4 | Large memory allocation | DOS via resource exhaustion | [MP4 parser](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/demo/GPMF_mp4reader.c#L477) | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue4.mp4) |
| 5 | Large memory allocation | DOS via resource exhaustion | [MP4 parser](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/demo/GPMF_mp4reader.c#L536-L540) | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue5.mp4) |
| 6 | Large memory allocation | DOS via resource exhaustion | [MP4 parser](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/demo/GPMF_mp4reader.c#L425) | - |
| 7 | Null pointer read â segfault | DOS via crash | [MP4 parser](https://github.com/gopro/gpmf-parser/blob/eeef670dfdc51d4761cfe654cfbe212444cc9d19/demo/GPMF_mp4reader.c#L675) | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue7.mp4) |
| 8 | Heap out of bounds read | information disclosure | [MP4 parser](https://github.com/gopro/gpmf-parser/blob/eeef670dfdc51d4761cfe654cfbe212444cc9d19/demo/GPMF_mp4reader.c#L675) | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue8.mp4) |
| 9 | Division by zero | DOS via crash | [MP4 parser](https://github.com/gopro/gpmf-parser/blob/eeef670dfdc51d4761cfe654cfbe212444cc9d19/demo/GPMF_mp4reader.c#L668) | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue9.mp4) |
| 10 | Heap out of bounds read | information disclosure | [MP4 parser](https://github.com/gopro/gpmf-parser/blob/eeef670dfdc51d4761cfe654cfbe212444cc9d19/demo/GPMF_mp4reader.c#L671) | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue10.mp4) |
| 11 | Heap out of bounds read | DOS via crash, information disclosure? | [MP4 parser](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/demo/GPMF_mp4reader.c#L750) | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue11.mp4) |
| 12 | Division by zero (*difficult to reproduce*) | potential DOS via crash | [MP4 parser](https://github.com/gopro/gpmf-parser/blob/eeef670dfdc51d4761cfe654cfbe212444cc9d19/demo/GPMF_mp4reader.c#L335) | - |
| 13 | Long-running loops | Partial DOS via CPU resource exhaustion | MP4 parser ([1](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/demo/GPMF_mp4reader.c#L814-L830), [2](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/demo/GPMF_mp4reader.c#L776-L795), [3](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/demo/GPMF_mp4reader.c#L352)) | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue13.mp4) |
| 14 | Heap out of bounds read | Potentially information disclosure | [core](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L474) | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue14.mp4) |
| 15 | Heap out of bounds read | Potentially information disclosure | [core](https://github.com/gopro/gpmf-parser/blob/eeef670dfdc51d4761cfe654cfbe212444cc9d19/GPMF_parser.c#L321) | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue15.mp4) |
| 16 | Stack out of bounds write | DOS via crash or worse | [demo](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/demo/GPMF_demo.c#L247) | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue16.mp4) |
| 19 | Heap out of bounds read | information disclosure | [core](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L1777) | see #18 |
| 20 | Heap out of bounds read | information disclosure | core ([1](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L1886), [2](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L1941), [3](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L1797-L1798)) | [file](/assets/artifacts/gopro-gpmf-parser-vuln-1/poc_issue20.mp4) |

### Mainly Functional Issues:

| ID | Description | Potential Impact | Location |
| --- | --- | --- | --- |
| [GH101](https://github.com/gopro/gpmf-parser/issues/101) | memory resource leak | resource exhaustion | [MP4 parser](https://github.com/gopro/gpmf-parser/blob/98aff124b6b5d01b42da2d0ffada4ea99758929f/demo/GPMF_mp4reader.c#L155) |
| [GH102](https://github.com/gopro/gpmf-parser/issues/102) | undefined behavior | unspecified | [MP4 parser](https://github.com/gopro/gpmf-parser/blob/98aff124b6b5d01b42da2d0ffada4ea99758929f/demo/GPMF_mp4reader.c#L350-L352) |
| [GH103](https://github.com/gopro/gpmf-parser/issues/103) | memory resource leak | resource exhaustion | [MP4 parser](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L1731) |
| [GH104](https://github.com/gopro/gpmf-parser/issues/104) | memory resource leak | resource exhaustion | [core](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L1388) |

## Selection of Discovered Issues

### CVE-2020-16158

The `GPMF_ExpandComplexTYPE()` function allows multiple 1 byte stack out of bounds writes behind the `dst` buffer.
The outer `while{}` loop has some bounds checks but manipulates the relevant counters within the loop without additional checks.

Relevant code (simplified):

```
uint32_t GPMF_ExpandComplexTYPE(char *src, uint32_t srcsize, char *dst, uint32_t *dstsize)
{
	uint32_t i = 0, k = 0, count = 0;

	while (i<srcsize && k<*dstsize)
	{
// [...], new count value is calculated here
				uint32_t l;
				for (l = 1; l<count; l++)
				{
					dst[k] = src[i - 1];
					k++;
				}
// [...]
            i++;
            k++;
	}
```

[GPMF\_parser.c](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L950-L954)

As you can see, the limits imposed via the `while (i<srcsize && k<*dstsize)` condition are ineffective since `k` is increased locally based on other values.
The assignment `dst[k] = src[i - 1]` is therefore reachable with larger than intended `k` values.

Consider the following problematic run of `GPMF_ExpandComplexTYPE()` on a target buffer `dst` with a size of 64 bytes:

```
(gdb) print *dstsize
$7 = 64

```

Here is the memory view of the destination buffer plus following 32 bytes of memory, captured at the start of the function:

(*x86\_64, no stack canary*)

```
(gdb) x/96xb dst
0x7fffffffcde0:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x7fffffffcde8:	0x78	0xd0	0xff	0xff	0xff	0x7f	0x00	0x00
0x7fffffffcdf0:	0x07	0x00	0x00	0x00	0xff	0x7f	0x00	0x01
0x7fffffffcdf8:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x7fffffffce00:	0x01	0x00	0x00	0x00	0x00	0x00	0x00	0x01
0x7fffffffce08:	0x84	0xd0	0xff	0xff	0xff	0x7f	0x00	0x00
0x7fffffffce10:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x7fffffffce18:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x01 // << end of dst
0x7fffffffce20:	0x18	0x00	0x00	0x00	0x18	0x00	0x00	0x00
0x7fffffffce28:	0x01	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x7fffffffce30:	0xf0	0x55	0x05	0x01	0x00	0x00	0x00	0x00
0x7fffffffce38:	0x78	0xd0	0xff	0xff	0x18	0x00	0x00	0x00

```

Here is the same memory region after exiting the `while()` loop with a problematic input:

```
(gdb) x/96xb dst
0x7fffffffcde0:	0xff	0xff	0xff	0xff	0xff	0xff	0xff	0x0f
0x7fffffffcde8:	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f
0x7fffffffcdf0:	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f
0x7fffffffcdf8:	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f
0x7fffffffce00:	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f
0x7fffffffce08:	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f
0x7fffffffce10:	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f
0x7fffffffce18:	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f // << end of dst
0x7fffffffce20:	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f
0x7fffffffce28:	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f
0x7fffffffce30:	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f
0x7fffffffce38:	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f	0x0f

```

In this particular case the memory is clobbered with a single `0x0f` value that is taken from `src[i - 1]`.

The classification of the security impact depends on the practical use of the GPMF-parser library and related compiler settings.
On systems with stack canaries, the OOB write will be detected and the program exits, which mitigates this attack to a Denial of Service (DoS).

If the target binary is compiled without stack canaries, the vulnerability may allow an attacker to perform changes to
the program flow via manipulation of adjacent memory regions behind `dst`.
The changes are constrained by the nature of the out of bounds write, but a carefully crafted input might still
leverage this bug to do something interesting on certain systems or architectures.
In that case, the integrity and confidentiality properties of the target program will be impacted as well, although
the overall attack complexity might be high or some user interaction might be involved.

### CVE-2020-16160

The `GPMF_Decompress()` function includes a problematic division that can lead to a division by zero issue if `type` is not detected.
This is possible since `GPMF_SizeofType()` can return zero.

```
uint32_t sizeoftype = GPMF_SizeofType(type);
uint32_t chn = 0, channels = sample_size / sizeoftype;
```

[GPMF\_parser.c](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L1743-L1744)

The impact is a denial of service through the crash, represented by the following sanitizer warning:

```
==20022==ERROR: AddressSanitizer: FPE on unknown address

```
### CVE-2020-16161

The `GPMF_ScaledData()` function includes a problematic modulo operation that can lead to division by zero issue if `inputtypeelements` is zero:

```
switch (complextype[i % inputtypeelements])
```

[GPMF\_parser.c](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L1634)

The same issue is also present at a [second location](%28https%3A//github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L1653)) in the code.

The impact is a denial of service through the crash, represented by the following sanitizer warning:

```
==20022==ERROR: AddressSanitizer: FPE on unknown address

```
### CVE-2020-16159

`GPMF_ScaledData()` calls macros to read and convert input data into specific types.

This can lead to a heap out of bounds read and following Segmentation fault in the [MACRO\_BSWAP\_CAST\_UNSIGNED\_SCALE handling](https://github.com/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c#L1657)
when operating on the end of `ms->buffer`:

```
==14571==ERROR: AddressSanitizer: heap-buffer-overflow on address
0x606000000060 at pc 0x0000005750ce bp 0x7fff70e5b6d0 sp 0x7fff70e5b6c8
READ of size 1 at 0x606000000060 thread T0
    #0 0x5750cd in GPMF_ScaledData /gpmf-parser/demo/../GPMF_parser.c:1694:37
    #1 0x4c9a53 in main /gpmf-parser/demo/GPMF_demo.c:253:7
    #2 0x7f346c0e0bba in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x26bba)
    #3 0x41e2d9 in _start (/gpmf-parser/demo/gpmfdemo+0x41e2d9)

0x606000000060 is located 0 bytes to the right of 64-byte region
[0x606000000020,0x606000000060)

==14571==ERROR: AddressSanitizer: SEGV on unknown address 0x606000010000
(pc 0x0000005750da bp 0x7fff70e75ab0 sp 0x7fff70e5b6e0 T0)
==14571==The signal is caused by a READ memory access.
    #0 0x5750da in GPMF_ScaledData /gpmf-parser/demo/../GPMF_parser.c:1694:37

```

The main observed impact of this is a denial of service via the segfault.

Depending on the usage of the GPMF-parser library, it might be possible to avoid the segfault and leverage this for some sort of information disclosure via uninitialized heap memory.

### POC

Crafted example inputs for the individual issues were provided to the vendor and are linked in the bug summary overview at the beginning of the article.

To reproduce:

* Compile an older version of the GPMF-parser demo application
  + Optionally add appropriate sanitizers such as `-fsanitize=address` and other compile flags for error detection
* Run the example program against the `poc_issue*.mp4` file
* Use special compile-time and run-time flags such as `-fsanitize-recover=adddress`, `ASAN_OPTIONS=halt_on_error=0` to proceed beyond the initial errors on inputs that trigger multiple issues

## Disclosure

The disclosure process for these bugs was long and exhausting.

One of the reasons for this is my decision to fuzz the GPMF parsing code âall the wayâ through the MP4 file parsing interface.
While this allowed me to present MP4-based POCs that directly worked as input for the unmodified demo application (better reproducibility for the developers),
it also doubled the number of bugs that I had to analyze, report and patch away. Additionally, many bugs happened on similar inputs, which
increased the complexity of preparing useful reports due to overlapping crashes.

Another major factor is the perceived unfamiliarity of the vendor with the requested type of coordinated disclosure for their open source code.
For example, there is insufficient public documentation regarding disclosure contacts, guidelines and processes.
A lot of back and forth via email was required to coordinate the relevant aspects, and this was not always successful.

The main patch release (2.0) was released around a month after the disclosure to the vendor.
While this is not a bad response time for a likely nonessential vendor project, 9 of the 21 confidentially reported issues were missed during patching.
The vendor quickly followed up with another release (2.0.2) a few days after I reported this.

To my knowledge, no public credit has been given for the 21 vulnerability reports despite a number of code changes and two security releases, which is disappointing.

### Partial Timeline

Note: this timeline excludes confidential data points and related information.

| Date | information |
| --- | --- |
| 2020-06-20 | Initial communication to developer address and request for security contact |
| 2020-06-23 | Request to 2nd developer address |
| 2020-06-25 | [GitHub issue](https://github.com/gopro/gpmf-parser/issues/99) to ask for official security contact |
| 2020-06-25 | Initial email communication with GoPro security |
| 2020-07-10 to 2020-07-14 | Public GitHub bug issues GH101 to GH104 |
| 2020-07-11 to 2020-07-15 | Confidential coordinated disclosure of issues #1 to #21 with POCs |
| 2020-07-15 | Shared fuzzing corpus with GoPro for testing |
| 2020-07-23 | GoPro agrees to proposed CVE request process |
| 2020-07-27 | GoPro acknowledges proposed CVE descriptions |
| 2020-07-28 | Request of CVEs from MITRE |
| 2020-07-30 | MITRE assigns CVEs |
| 2020-08-20 | GPMF-parser [2.0.0](https://github.com/gopro/gpmf-parser/releases/tag/v2.0.2) is released with security fixes |
| 2020-08-22 | Note to GoPro about incomplete fixes for issues #3, #4, #7, #8, #15, #16, #19, #20 and #21 |
| 2020-08-27 | GPMF-parser [2.0.2](https://github.com/gopro/gpmf-parser/releases/tag/v2.0.2) is released with security fixes |
| 2020-08-28 | GoPro requests deadline extension to 6th October (accepted) |
| 2020-10-06 | Disclosure deadline |
| 2020-10-17 | Publication of this blog article |

* **Christian Reitter**

Information security and other interests.



=== Content from github.com_10e5fd93_20250119_135028.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fgopro%2Fgpmf-parser%2Ftree%2F2cc0af7ffee6f12934e2d57750bdf292f62b0a97)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fgopro%2Fgpmf-parser%2Ftree%2F2cc0af7ffee6f12934e2d57750bdf292f62b0a97)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Ffiles%2Fdisambiguate&source=header-repo&source_repo=gopro%2Fgpmf-parser)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[gopro](/gopro)
/
**[gpmf-parser](/gopro/gpmf-parser)**
Public

* [Notifications](/login?return_to=%2Fgopro%2Fgpmf-parser) You must be signed in to change notification settings
* [Fork
  114](/login?return_to=%2Fgopro%2Fgpmf-parser)
* [Star
   559](/login?return_to=%2Fgopro%2Fgpmf-parser)

Parser for GPMF™ formatted telemetry data used within GoPro® cameras.

### License

Apache-2.0 and 2 other licenses found

### Licenses found

[Apache-2.0
LICENSE.txt](/gopro/gpmf-parser/blob/main/./LICENSE.txt) [Apache-2.0
LICENSE-APACHE](/gopro/gpmf-parser/blob/main/./LICENSE-APACHE) [MIT
LICENSE-MIT](/gopro/gpmf-parser/blob/main/./LICENSE-MIT)

[559
stars](/gopro/gpmf-parser/stargazers) [114
forks](/gopro/gpmf-parser/forks) [Branches](/gopro/gpmf-parser/branches) [Tags](/gopro/gpmf-parser/tags) [Activity](/gopro/gpmf-parser/activity)
 [Star](/login?return_to=%2Fgopro%2Fgpmf-parser)

 [Notifications](/login?return_to=%2Fgopro%2Fgpmf-parser) You must be signed in to change notification settings

* [Code](/gopro/gpmf-parser)
* [Issues
  24](/gopro/gpmf-parser/issues)
* [Pull requests
  0](/gopro/gpmf-parser/pulls)
* [Actions](/gopro/gpmf-parser/actions)
* [Projects
  0](/gopro/gpmf-parser/projects)
* [Wiki](/gopro/gpmf-parser/wiki)
* [Security](/gopro/gpmf-parser/security)
* [Insights](/gopro/gpmf-parser/pulse)

Additional navigation options

* [Code](/gopro/gpmf-parser)
* [Issues](/gopro/gpmf-parser/issues)
* [Pull requests](/gopro/gpmf-parser/pulls)
* [Actions](/gopro/gpmf-parser/actions)
* [Projects](/gopro/gpmf-parser/projects)
* [Wiki](/gopro/gpmf-parser/wiki)
* [Security](/gopro/gpmf-parser/security)
* [Insights](/gopro/gpmf-parser/pulse)

# gopro/gpmf-parser

    2cc0af7[Branches](/gopro/gpmf-parser/branches)[Tags](/gopro/gpmf-parser/tags)Go to fileCode
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| Latest commit History[270 Commits](/gopro/gpmf-parser/commits/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/) | | |
| [demo](/gopro/gpmf-parser/tree/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/demo "demo") | | [demo](/gopro/gpmf-parser/tree/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/demo "demo") |  |  |
| [docs](/gopro/gpmf-parser/tree/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/docs "docs") | | [docs](/gopro/gpmf-parser/tree/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/docs "docs") |  |  |
| [samples](/gopro/gpmf-parser/tree/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/samples "samples") | | [samples](/gopro/gpmf-parser/tree/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/samples "samples") |  |  |
| [.gitignore](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/.gitignore ".gitignore") | | [.gitignore](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/.gitignore ".gitignore") |  |  |
| [AUTHORS.md](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/AUTHORS.md "AUTHORS.md") | | [AUTHORS.md](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/AUTHORS.md "AUTHORS.md") |  |  |
| [CMakeLists.txt](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/CMakeLists.txt "CMakeLists.txt") | | [CMakeLists.txt](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/CMakeLists.txt "CMakeLists.txt") |  |  |
| [CONTRIBUTING.md](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/CONTRIBUTING.md "CONTRIBUTING.md") | | [CONTRIBUTING.md](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/CONTRIBUTING.md "CONTRIBUTING.md") |  |  |
| [GPMF\_bitstream.h](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_bitstream.h "GPMF_bitstream.h") | | [GPMF\_bitstream.h](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_bitstream.h "GPMF_bitstream.h") |  |  |
| [GPMF\_common.h](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_common.h "GPMF_common.h") | | [GPMF\_common.h](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_common.h "GPMF_common.h") |  |  |
| [GPMF\_parser.c](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c "GPMF_parser.c") | | [GPMF\_parser.c](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c "GPMF_parser.c") |  |  |
| [GPMF\_parser.h](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.h "GPMF_parser.h") | | [GPMF\_parser.h](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.h "GPMF_parser.h") |  |  |
| [LICENSE-APACHE](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/LICENSE-APACHE "LICENSE-APACHE") | | [LICENSE-APACHE](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/LICENSE-APACHE "LICENSE-APACHE") |  |  |
| [LICENSE-MIT](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/LICENSE-MIT "LICENSE-MIT") | | [LICENSE-MIT](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/LICENSE-MIT "LICENSE-MIT") |  |  |
| [LICENSE.txt](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/LICENSE.txt "LICENSE.txt") | | [LICENSE.txt](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/LICENSE.txt "LICENSE.txt") |  |  |
| [README.md](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/README.md "README.md") | | [README.md](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/README.md "README.md") |  |  |
| [gpmf-parser.pc.in](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/gpmf-parser.pc.in "gpmf-parser.pc.in") | | [gpmf-parser.pc.in](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/gpmf-parser.pc.in "gpmf-parser.pc.in") |  |  |
| View all files | | |

## Repository files navigation

* README
* License
* License
* License
# GPMF Introduction

The GPMF structured storage format was originally proposed to store high-frequency periodic sensor data within a video file like an MP4. Action cameras, like that from GoPro, have limited computing resources beyond that needed to store video and audio, so any telemetry storage needed to be lightweight in computation, memory usage and storage bandwidth. While JSON and XML systems where initially considered, the burden on the embedded camera system was too great, so something simpler was needed. While the proposed GPMF structure could be used stand-alone, our intended implementation uses an additional time-indexed track with an MP4, and with an application marker within JPEG images. GPMF share a Key, Length, Value structure (KLV), similar to QuickTime atoms or Interchange File Format (IFF), but the new KLV system is better for describing sensor data. Problems solved:

* The contents of new Keys can be parsed without prior knowledge.
* Nested structures can be defined without 'Key' dictionary.
* Structure prevents naming collisions between multiple sources.
* Nested structures allows for the communication of metadata for telemetry, such as scale, units, and data ranges etc.
* Somewhat human (engineer) readable (i.e. hex-editor friendly.)
* Timing and indexing for use existing methods stored within the wrapping MP4 of similar container format.

GPMF -- GoPro Metadata Format or General Purpose Metadata Format -- is a modified Key, Length, Value solution, with a 32-bit aligned payload, that is both compact, full extensible and somewhat human readable in a hex editor. GPMF allows for dependent creation of new FourCC tags, without requiring central registration to define the contents and whether the data is in a nested structure. GPMF is optimized as a time of capture storage format for the collection of sensor data as it happens.

# GPMF-parser

## Included Within This Repository

* The complete source to an GPMF parser library
* Demo code for using the GPMF parser with extraction of GPMF from MP4 or MOV files.
* CMake support for building the demo project.
* Tested on:
  + macOS High Sierra with XCode v8 & v9
  + Windows 10 with Visual Studio 2015 & 2017
  + Ubuntu 16.04 with gcc v5.4

## License Terms

GPMF-parser is licensed under either:

* Apache License, Version 2.0, (LICENSE-APACHE or <http://www.apache.org/licenses/LICENSE-2.0>)
* MIT license (LICENSE-MIT or <http://opensource.org/licenses/MIT>)

at your option.

## Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.

## GPMF Writing

A new open source repository has been created for the purpose (GPMF-Write <https://github.com/gopro/gpmf-write>)

## Quick Start for Developers

### Setup

Clone the project from Github (git clone <https://github.com/gopro/gpmf-parser>).

### Sample Code

GPMF-parser.c and .h provide a payload decoder for any raw stream stored in compliant GPMF. Extraction of the RAW GPMF from a video or image file is not covered by this tool.

```
#include <GPMF-parser.h>
GPMF_stream gs_stream;
if(GPMF_OK == GPMF_Init(&gs_stream, buffer_with_GPMF_data, size_of_the_buffer))
{
	do
	{
		switch(GPMF_Key(&gs_stream))
		{
		case STR2FOURCC(“ACCL”):
		  // Found accelerometer
		  samples = GPMF_Repeat(&gs_stream);
		  if(GPMF_OK == GPMF_ScaledData(&gs, temp_buffer, temp_buffersize, 0, samples, GPMF_TYPE_FLOAT))
		    {  /* Process scaled values */ }
		  break;

		case STR2FOURCC(“cust”):
		  // Found my custom data
		  samples = GPMF_Repeat(&gs_stream);
		  if(GPMF_OK == GPMF_FormattedData(&gs, temp_buffer, temp_buffersize, 0, samples))
		    { /* Process raw formatted data -- unscaled */ }
		  break;

		default: // if you don’t know the Key you can skip to the next
		  break;
	}
} while (GPMF_OK == GPMF_Next(&gs_stream, GPMF_RECURSE_LEVELS)); // Scan through all GPMF data

```

If you only want particular a piece of data

```
#include <GPMF-parser.h>
GPMF_stream gs_stream;
if(GPMF_OK == GPMF_Init(&gs_stream, buffer_with_GPMF_data, size_of_the_buffer))
{
  if(GPMF_OK == GPMF_FindNext(&gs_stream, STR2FOURCC("ACCL"), GPMF_RECURSE_LEVELS)))
   {
   	uint32_t key = GPMF_Key(&gs_stream);
   	char type = GPMF_Type(&gs_stream);
   	uint32_t samples = GPMF_Repeat(&gs_stream);
   	void *data = GPMF_RawData(&gs_stream);

	/* do your own byte-swapping and handling */
   }
}

```

# GPMF Deeper Dive

## Definitions

| **Word** | **Definition** |
| --- | --- |
| Track | An MP4 container element used for storing video, audio or sub-titling over time |
| FourCC | The four character Key that marks a segment of data |
| Key | FourCC is the first element in Key-Length-Value 3-tuple |
| Length | This field describes the data that follows, including basic type, structural hints, sample counts |
| Value | Raw data to be stored in Big Endian |
| Device | Metadata sources below to devices, a camera my device and a connected BlueTooth sensor would be a separate device |
| Stream | Each metadata Device can have multiple streams on sensor data, e.g. Camera Device could have GPS, Accelerometer and Gyro streams |

### KLV Design

All data is Big Endian.

[![](/gopro/gpmf-parser/raw/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/docs/readmegfx/KLVDesign.png "KLV Design")](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/docs/readmegfx/KLVDesign.png)

### FourCC

7-bit ASCII Key created for readability. All uppercase fourCCs are reserved Keys, mixed case is for any third party ingested data.

A few Keys reserved for communicating structure, although only DEVC is required at the beginning of any GPMF payload.

| **FourCC** | **Definition** | **Comment** |
| --- | --- | --- |
| DEVC | unique device source for metadata | Each connected device starts with DEVC. A GoPro camera or Karma drone would have their own DEVC for nested metadata to follow. |
| DVID | device/track ID | Auto generated unique-ID for managing a large number of connect devices, camera, karma and external BLE devices |
| DVNM | device name | Display name of the device like "Karma 1.0", this is for communicating to the user the data recorded, so it should be informative. |
| STRM | Nested signal stream of metadata/telemetry | Metadata streams are each nested with STRM |
| STNM | Stream name | Display name for a stream like "GPS RAW", this is for communicating to the user the data recorded, so it should be informative. |
| RMRK | Comments for any stream | Add more human readable information about the stream |
| SCAL | Scaling factor (divisor) | Sensor data often needs to be scaled to be presented with the correct units. SCAL is a divisor. |
| SIUN | Standard Units (like SI) | If the data can be formatted in GPMF's standard units, this is best. E.g. acceleration as "m/s²". SIUN allows for simple format conversions. |
| UNIT | Display units | While SIUN is preferred, not everything communicates well via standard units. E.g. engine speed as "RPM" is more user friendly than "rad/s". |
| TYPE | Typedefs for complex structures | Not everything has a simple repeating type. For complex structure TYPE is used to describe the data packed within each sample. |
| TSMP | Total Samples delivered | Internal field that counts all the sample delivered since record start, and is automatically computed. |
| TIMO | Time Offset | Rare. An internal field that indicates the data is delayed by 'x' seconds. |
| EMPT | Empty payload count | Internal field that reports the number of payloads that contain no new data. TSMP and EMPT simplify the extraction of clock. |

### Length (type-size-repeat structure)

The tradition 32-bit "Length" is broken up to help describe the data that follows.

#### Structure Size

8-bits is used for a sample size, each sample is limited to 255 bytes or less.

#### Repeat

16-bits is used to indicate the number of samples in a GPMF payload, this is the Repeat field. Struct Size and the Repeat allow for up to 16.7MB of data in a single KLV GPMF payload.

#### Type

The final 8-bits, Type, is used to describe the data format within the sample. Just as FOURCC Keys are human readable, the TYPE is using a ASCII character to describe the data stored. A character 'f' would describe float data, 'd' for double precision, etc. All types are reserved, and are not end user definable.

Current types:

| **Type Char** | **Definition** | **typedef** | **Comment** |
| --- | --- | --- | --- |
| **b** | single byte signed integer | int8\_t | -128 to 127 |
| **B** | single byte unsigned integer | uint8\_t | 0 to 255 |
| **c** | single byte 'c' style ASCII character string | char | Optionally NULL terminated - size/repeat sets the length |
| **d** | 64-bit double precision (IEEE 754) | double |  |
| **f** | 32-bit float (IEEE 754) | float |  |
| **F** | 32-bit four character key -- FourCC | char fourcc[4] |  |
| **G** | 128-bit ID (like UUID) | uint8\_t guid[16] |  |
| **j** | 64-bit signed unsigned number | int64\_t |  |
| **J** | 64-bit unsigned unsigned number | uint64\_t |  |
| **l** | 32-bit signed integer | int32\_t |  |
| **L** | 32-bit unsigned integer | uint32\_t |  |
| **q** | 32-bit Q Number Q15.16 | uint32\_t | 16-bit integer (A) with 16-bit fixed point (B) for A.B value (range -32768.0 to 32767.99998) |
| **Q** | 64-bit Q Number Q31.32 | uint64\_t | 32-bit integer (A) with 32-bit fixed point (B) for A.B value. |
| **s** | 16-bit signed integer | int16\_t | -32768 to 32768 |
| **S** | 16-bit unsigned integer | uint16\_t | 0 to 65536 |
| **U** | UTC Date and Time string | char utcdate[16] | Date + UTC Time format yymmddhhmmss.sss - (years 20xx covered) |
| **?** | data structure is complex | TYPE | Structure is defined with a preceding TYPE |
| **null** | Nested metadata | uint32\_t | The data within is GPMF structured KLV data |

## Alignment and Storage

All GPMF data is 32-bit aligned and stored as big-endian. For data types that are not 32-bit, they are packed in their native byte or short or complex structure storage size, and only padded at the very end to meet GPMF KLV alignment needs. Storage of a single 1 byte, would have 3-pad bytes.

DEMO, 'b' 1 1, <byte value> 0 0 0

[![](/gopro/gpmf-parser/raw/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/docs/readmegfx/demo1.png)](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/docs/readmegfx/demo1.png)

The same data type stored 15 times would have only a only byte pad at the end.

DEMO, 'b' 1 15, <15 bytes data> 0

[![](/gopro/gpmf-parser/raw/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/docs/readmegfx/demo2.png)](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/docs/readmegfx/demo2.png)

Packed data will all maintain a 32-bit alignment between GPMF KLV 3-tuples.

DMO1, b 1 1, <byte value> 0 0 0 DMO2 b 1 15 <values> 0 DMO3 L 4 1 <32-bit values>

[![](/gopro/gpmf-parser/raw/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/docs/readmegfx/demo3.png)](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/docs/readmegfx/demo3.png)

While padding is shown as null values, any value can be used, as this data is simply ignored.

The packed data size with in a GPMF KLV is the structure size times the number of samples. The storage size is rounded up to the next 32-bit aligned size.

## Multiple axis sensor data

As sensor data like gyro and accelerometer commonly have three (or more) axes of the same data type, the combination of Type and Structure Size, will indicate the type of data within. Three axis GYRO data could have a Type of 's' (short 16-bit signed integer) with a Structure size of 6. As the size of the Type is known, the number of axes in each sample is Structure size / sizeof (Type). An examples of 6 samples of a 6 byte x,y,z structure GYRO data is shown here:

[![](/gopro/gpmf-parser/raw/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/docs/readmegfx/demo4.png)](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/docs/readmegfx/demo4.png)

## GPMF Nesting

Standalone GPMF does little for communicating the relationship between data, so that we need to nest so that metadata can describe other data. Type of null is the flag that indicates the data field is any other GPMF KLV series. We use nesting to describe any telemetry device like follows:

```
DEVC null 4 7
   DVID L 4 1 0x1001
   DVNM c 1 6 Camera

```

This is a valid nested GPMF structure. DEVC describe 4\*7 = 28 bytes of data, which are packed and aligned GPMF KLV values describing a camera device with a Device ID and a Device Name.

[![](/gopro/gpmf-parser/raw/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/docs/readmegfx/demo5.png)](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/docs/readmegfx/demo5.png)

### Property Hierarchy

Metadata, data that applies to other data, is forward looking within each nested GPMF entry. In the previous example the Device ID is applied to the Device Name, as they're part of the same nest and Device ID came before Device Name. This order of properties is particularly import when KLV 3-tuples modifies the meaning of data to follow in the same nest level, which is how SCAL and TYPE are applied. Several modify properties can be transmitted, each adding metadata to modify the meaning of the **last** KLV in the nest (at this nest level.) The SCAL key is used as sensors that measure physical properties typically output integers that must be scaled to produce a real-world value. This scaling converting raw data to float or Q-numbers (fixed point float) could be performed in the device, but is often stored more efficiently as the original sensor values and a scale property. These are equivalent:

```
STRM null <size><repeat>
   ACCL 'f' 12 100  <100 samples of x,y,z accelerometer data as 32-bit floats>

```

```
STRM null <size><repeat>
   SCAL 's' 2 1 scale
   ACCL 's' 6 100 <100 samples of x,y,z accelerometer data as 16-bit shorts>

```

The second data stream is almost half the size of the first (1216 vs 628 bytes) for the same resulting precision.

When adding units, the SCAL doesn't apply to SUIN, but only the ACCL the latest KLV in the stream's (STRM) nest.

```
STRM null <size><repeat>
   SCAL 's' 2 1 scale
   SIUN 'c' 4 1 "m/s²"
   ACCL 's' 6 100 <100 samples of x,y,z accelerometer data as 16-bit shorts>

```

Note: The SI unit of "m/s²" is applied to each x,y,z axis, there is no need to declare the unit as

```
SIUN 'c' 4 3 "m/s²","m/s²","m/s²"

```

A complete stream from a device could be:

```
STRM null <size><repeat>
   TSMP 'L' 4 1  196
   STNM 'c' 50 1  "Accelerometer (up/down, right/left, forward/back)"
   TMPC 'f' 4 1  56.0723
   SIUN 'c' 4 1  "m/s²"
   SCAL 's' 2 1  418
   ACCL 's' 6 100  4418, -628, -571, ...

```

Including a stream name to improve readability and TMPC for the temperature of the device that is collecting the accelerometer data.

## Multi-sample and Non-periodic data.

Virtual sensors, CV or computationally extracted metadata will become a common storage type. The data form this new sources could produce multiple samples for a given time (5 faces in this frame) and the results may be delayed in delivering their findings (frame 1000 has 7 faces, yet is was reported on frame 1003.) Both the potential for delay timing and multiple samples requires custom storage.

In the example below is for a fast, periodic (once per frame), face detection algorithm (no delays):

```
STRM null <size><repeat>
 TSMP 'L' 4 1 196
 STNM 'c' 50 1 "Face bounding boxes (age, gender, x1,y1,x2,y2)"
 TYPE 'c' 1 6  "SSffff",
 FACE '?' 20 3 <face1, face2, face3>
 FACE '?' 20 4 <face1, face2, face3, face4>
 FACE '?' 20 0
 FACE '?' 20 2 <face1, face2>
 ...

```

The timing information is extracted just like all other sensor, yet the multiple entries of "FACE" vertically represent samples over time, and "faceX" are multiple samples at the same time. When no FACE are discovered, "FACE ? 20 0" is used to preserve the timing, just as GYRO report zeros when then camera is stationary.

If the data where to occur with a significantly slower algorithm that is not periodic, say the first detection took 300ms, the second 400ms,, the third 100ms, the last 250ms, the timing relationship to the source frame would be lost. While most of GPMF data can rely of the timing provided by MP4 indexing, to handling delayed and aperiodic data introduces TICK and TOCK to make the in and out times (in time is the beginning of the processing, out-time the end.

```
DEVC null <size0><repeat0>
 DVID 'L' 4 1 1001
 DVNM 'c' 6 1 "Camera"
 TICK 'L' 4 1 10140
 STRM null <size><repeat>
   TSMP 'L' 4 1 196
   STNM 'c' 50 1 "Face bounding boxes (x1,y1,x2,y2,age,gender,flags,confidence)"
   TYPE 'c' 1  6 "ffffBBBB",
   FACE null <size1><repeat1>
     TICK 'L' 4 1 10023
     TOCK 'L' 4 1 10320
     FACE '?' 20 3 <face1, face2, face3>
   FACE null <size2><repeat2>
     TICK 'L' 4 1 10347
     TOCK 'L' 4 1 10751
     FACE '?' 20 3 <face1, face2, face3, face4>
   FACE null <size3><repeat3>
     TICK 'L' 4 1 10347
     TOCK 'L' 4 1 10751
     FACE '?' 20 0
   FACE null <size4><repeat4>
    TICK 'L' 4 1 10347
    TOCK 'L' 4 1 11005
    FACE '?' 20 3 <face1, face2>

```

As the CV processing in this example can take time, it will be common for the processing to begin before the payload frame it which it is written. The first FACE samples begin their processing at 10023, yet the payload for normal sample data began at 10140 (within the top DEVC structure).

## Standard Units for physical properties supported by SUIN

### Base Units

| length | meter | m | SI Unit |
| --- | --- | --- | --- |
| mass | gram | g | SI Unit |
| time | second | s | SI Unit |
| electric current | ampere | A | SI Unit |
| temperature | kelvin | K | SI Unit |
| luminous intensity | candela | cd | SI Unit |
| magnetic flux density | tesla | T | non-SI |
| angle | radian | rad | non-SI |
| temperature | Celsius | °C | non-SI |
| frequency | hertz | Hz | non-SI |
| memory | Byte | B | non-SI |

### Modifiers supported

| p (pico) | 10x-12 |
| --- | --- |
| n (nano) | 10x^9 |
| µ (micro) | 10x^6 |
| m (milli) | 10x^3 |
| k (kilo) | 10^3 (1000) |
| M (mega) | 10^6 (1,000,000) |
| G (giga) | 10^9 (1,000,000,000) |
| T (tera) | 10^12 |

##### Common Properties in SIUN

| speed, velocity | meter per second | m/s |
| --- | --- | --- |
| acceleration | meter per second squared | m/s² |
| luminance | candela per square meter | cd/m² |
| gyro | radians per second | rad/s |
| Compass readings | milli Tesla or micro Tesla | mT or µT |
| distance | kilometers, millimeter, etc. | km or mm or ... |
| memory used/free | MegaByte, GigaByte, etc. | kB, MB, GB ... |
| frequency | KiloHertz, GigaHertz, etc. | kHz, GHz, ... |

##### Special ASCII Characters

As the SIUN is declared as an ASCII the character for degrees, squared, cubed and micro use the single byte values: 0xB0 (°), 0xB2 (²), 0xB3 (³) and 0xB5 (µ).

**Complex structures**

Not all telemetry data can be described as an array of a single basic type. To support complex structures, a TYPE field is added to the property hierarchy. TYPE is always defined with 'c' and used the same ASCII Type Chars to describe a complex structure. Examples structure:

```
typedef struct
{
   float field_strength;
   short x_offset, y_offset;
   unsigned long status_flags;
} myDeviceData; //myDD

```

The TYPE for the structure be a 'f','s','s','L' (float, short, short, unsigned long) is declared as follows:

```
STRM null <size><repeat>
   TYPE 'c' 1 4 "fssL"
   myDD '?' 12 <repeat> <n samples of myDeviceData>

```

The '?' for the type field in 'myDD' is used to indicate a complex structure type.

As this will likely have units that differ per parameter, we need to send units for each element of the complex structure

```
   TYPE 'c' 1 4 "fssL"
   SIUN 'c' 2 4 "µTmmmm " // for units µT mm mm and NONE
   myDD '?' 12 <repeat> <n samples of myDeviceData>

```

The same for scale, each unit will likely have a different scale. If no scale is required use 1, likely the flags field will not be scaled.

```
   TYPE 'c' 1 4 "fssL"
   SIUN 'c' 3 4 "µT mm mm " // for units µT mm mm and NONE, here padded for readability (optional)
   SCAL 's' 2 4 1000000, 1000, 1000, 1
   myDD '?' 12 <repeat> <n samples of myDeviceData>

```

Arrays can be defined within the string TYPE as follows:

```
typedef struct
{
   float farray[8];
   unsigned long flags;
} myDeviceData; //myDD

```

The use of '[n]' indicates the field is repeated n times. So an array of eight floats as described with "f[8]"

```
TYPE 'c' 1 5 "f[8]L"
  myDD '?' 36 <repeat> <n samples of myDeviceData>

```

## Sticky Metadata

The metadata writing API should have a mechanism for creating and writing "sticky" metadata. Data of type sticky doesn't need to be re-transmitted if it is not changing, and it will only store the last value it is does change. Sticky data is good for slow changing properties like the sensor's temperature, or any data that is sampled near the payload frequency or slower. Any metadata the modifies the meaning of sensor data should be written as sticky data: all TYPEs, SUINs, SCALs, naming fields (DVNM, STNM) and comments that are not changing over time. This data needs to be within each payload in the event that the file is cut in to smaller segments, each segment must contain all relevant metadata so that no meaning is lost in the extracted clip.

## Style Guide

The addition of structure is not to make device vendor's life more difficult, but to communicate the meaning of data to a future reader, that may not even be aware of the device used in the original capture. The first useful metadata is a human readable name of the device. While DVNM (DeviceName) "Camera" is in the current metadata, saying "GoPro Hero5 Black" would be much better. Having a stream (STRM) with ACCL data, doesn't communicate what it contains, when adding a STNM or RMRK with "Accelerometer (up/down, right/left, forward/back)" adds a lot of clarity to the future data reader. SUIN, UNIT, SCAL and even TYPE is completely optional if you don't intend anyone other than for your own tools to process this data, but it is so much better to allow many tools to extract and process all data. Use of a standard unit (SIUN) allows downstream tools to convert accurately from m/s to MPH or kmH etc. under the end users control.

## MP4 Implementation

GPMF data is stored much like every other media track within the MP4, where the indexing and offsets are presented in the MP4 structure, not the data payload. GPMF storage is most similar to PCM audio, as it contains RAW uncompressed sensor data, however the sample rate for the track is for the GPMF payload, not the data within. GPMF might be stored at 1Hz (stored in the track description), but contain gyro data at 400Hz, accelerometer at 200Hz and GPS at 18Hz (HERO5 launch data-rates).

### GoPro's MP4 Structure

Telemetry carrying MP4 files will have a minimum of four tracks: Video, audio, timecode and telemetry (GPMF). A fifth track ('SOS') is used in file recovery in HERO4 and HERO5, can be ignored.

File structure:

```
  ftyp [type ‘mp41’]
  mdat [all the data for all tracks are interleaved]
  moov [all the header/index info]
    ‘trak’ subtype ‘vide’, name “GoPro AVC”, H.264 video data
    ‘trak’ subtype ‘soun’, name “GoPro AAC”, to AAC audio data
    ‘trak’ subtype ‘tmcd’, name “GoPro TCD”, starting timecode (time of day as frame since midnight)
    ‘trak’ subtype ‘meta’, name “GoPro MET”, GPMF telemetry

```

#### Inside the 'meta' Track

Just as video and audio tracks can have different formats within, the 'meta' track is not exclusive for GPMF. While the use of 'meta' in MP4 files is very likely a GoPro camera, it is not always GPMF data. For a number of years GoPro cameras had a 'meta' track used for a file repair containing 'fdsc' data, this is also called the SOS track. To confirm you have a GPMF style track, scan for the sample description atom which uses the type '**gpmd**' for GPMF data. The entire MP4 metadata track is typically structured like this:

```
  'trak'
     'tkhd' < track header data >
     'mdia'
        'mdhd' < media header data >
        'hdlr' < ... Component type = 'mhlr', Component subtype = 'meta', ... Component name = “GoPro MET” ... >
	'minf'
	   'gmhd'
	      'gmin' < media info data >
	      'gpmd' < the type for GPMF data >
	   'dinf' < data information >
	   'stbl' < sample table within >
	      'stsd' < sample description with data format 'gpmd', the type used for GPMF >
	      'stts' < GPMF sample duration for each payload >
	      'stsz' < GPMF byte size for each payload >
	      'stco' < GPMF byte offset with the MP4 for each payload >

```

for more details on MP4 structure 'stts', 'stsz' and 'stco' see <https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-61112>

## GPMF Timing and Clocks

Timing and sample rates are not directly expressed within GPMF and for good reasons. When you set a device up with a sample frequency of say 200Hz, or 48kHz for audio, you would think that number should be presented in the header. Adding timing to the header is good if the different channels of data share a single reference clock. A video file can accurately state it is 25.0Hz with 48kHz audio, if the video and audio are clocked together from the same crystal or timing source. However, two separate cameras will have slightly different timing, differing up to the tolerances of the clock source. A crystal may have timing with stated accuracy of 50 ppm (parts per million), which would have audio of one camera between 47,997 to 48,003Hz when compared with the other. This potential ±0.005% error is minor compared with the accuracy for the average independently clocked sensor. Camera internal sensors or data via a connected Bluetooth device, will have timing errors in the range ±1%. There is no value to storing timing metadata that will be significantly wrong in most cases. The timing and the clock extraction for GPMF is determined after capture. The amount of data stored in GPMF is compared with tracks that do have timing, like the master clock with an MP4.

An example video clip has these measured sample rates:

| Four | Data | Set Frequency | Measured Frequency |
| --- | --- | --- | --- |
| SHUT | shutter exposure times | 23.976 Hz | 23.976 Hz |
| ACCL | IMU data accelerometer | 200 Hz | 201.923 Hz |
| GYRO | IMU data gyroscope | 400 Hz | 403.846 Hz |
| GPS5 | GPS Location | 18Hz | 18.169 Hz |

To speed the measurement of any stream of data, the more recent bitstreams have a Key of TSMP (Total Samples) the counts the ongoing number of samples for each stream – so you don’t have to count them manually. If you compare the TSMP of the first payload with the last, you can easily determine the number of samples, then compare with the time of the video track (or MP4 clock timing), establishing the average sample rate for the GPMF data. This is not including compensation for thermal clock drifts, which do occur, although for most applications they are small enough to be safely ignored. Some streams include device temperature (GPMF Key is TMPC) for thermal clock drift or temperature sensitive calibrations.

### Sample Jitter

As clocks can’t be trusted, what else can go wrong? The storage of GPMF data is typically a software system, like the embedded RTOS (Real-time OS) of a GoPro camera, it will have its own timing issues. Any OS is another source of an unreliable clock, as it introduces timing jitter due to process switching time, and interrupt response times inherent in all OSes. A device driver for a sensor may send a group of samples, to a thread that formats and stores GPMF, that is combined with other GPMF sensors, at any time the accumulated sample data can be flushed and time-stamped within the MP4. A 200Hz device, flushed at one second intervals, could have payload sample counts of 199, 202, 201, 198, 199, etc. Again the TSMP in every GPMF payload simplifies extraction timing for every sample stored, even with clock drift and sampling jitter. Sample code demos this.

## Where to find GPMF data

GoPro HERO5, HERO6 and Fusion cameras have a GPMF track. HERO4 Black will have GPMF flight telemetry when attach to the GoPro Karma drone. All GoPro HERO4 onwards can have third party BlueTooth sensor adding GPMF data.

### IMU Orientation Uses These Axis Labels

[![](/gopro/gpmf-parser/raw/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/docs/readmegfx/CameraIMUOrientationSM.png "IMU Orientation")](/gopro/gpmf-parser/blob/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/docs/readmegfx/CameraIMUOrientationSM.png)

### HERO5 Black and Session

| FourCC | Property | approximate frequency (Hz) | SIUN or UNIT | Comment |
| --- | --- | --- | --- | --- |
| ACCL | 3-axis accelerometer | 200 | m/s² | Data order Z,X,Y |
| GYRO | 3-axis gyroscope | 400 | rad/s | Data order Z,X,Y |
| ISOG | Image sensor gain | 24, 25 or 30 (based video frame rate) | n/a | HERO5 v2 or greater firmware |
| SHUT | Exposure time | 24, 25 or 30 (based video frame rate) | s | HERO5 v2 or greater firmware |

### HERO5 Black with GPS Enabled Adds

| FourCC | Property | approximate frequency (Hz) | SIUN or UNIT | Comment |
| --- | --- | --- | --- | --- |
| GPS5 | latitude, longitude, altitude (WGS 84), 2D ground speed, and 3D speed | 18 | deg, deg, m, m/s, m/s |  |
| GPSU | UTC time and data from GPS | 1 | n/a | Within the GPS stream |
| GPSF | GPS Fix | 1 | n/a | Within the GPS stream: 0 - no lock, 2 or 3 - 2D or 3D Lock |
| GPSP | GPS Precision - Dilution of Precision (DOP x100) | 1 | n/a | Within the GPS stream, under 500 is good |

For more information of GPSP (or DOP) see [https://en.wikipedia.org/wiki/Dilution\_of\_precision\_(navigation)](https://en.wikipedia.org/wiki/Dilution_of_precision_%28navigation%29)

### Fusion Adds and Changes

| FourCC | Property | approximate frequency (Hz) | SIUN or UNIT | Comment |
| --- | --- | --- | --- | --- |
| ACCL | 3-axis accelerometer | 200 | m/s² | Data order -Y,X,Z |
| GYRO | 3-axis gyroscope | 3200 | rad/s | Data order -Y,X,Z |
| STMP | microsecond timestampes | 1 | µs | Increased precision for post stablization |
| MAGN | magnetometer | 24 | µT | Camera pointing direction |
| ISOG | Image sensor gain | increased to 60 | n/a | per frame exposure metadata |
| SHUT | Exposure time | increased to 60 | s | per frame exposure metadata |

### HERO6 Black Adds and Changes, Otherwise Supports All HERO5 metadata

| FourCC | Property | approximate frequency (Hz) | SIUN or UNIT | Comment |
| --- | --- | --- | --- | --- |
| ACCL | 3-axis accelerometer | 200 | m/s² | Data order Y,-X,Z |
| GYRO | 3-axis gyroscope | 200 | rad/s | Data order Y,-X,Z |
| FACE | Face detection boundaring boxes | 12, 12.5 or 15 (based video frame rate) | n/a | struct ID,x,y,w,h -- not supported in HEVC modes |
| FCNM | Faces counted per frame | 12, 12.5 or 15 (based video frame rate) | n/a | Not supported in HEVC modes |
| ISOE | Sensor ISO | 24, 25 or 30 (based video frame rate) | n/a | replaces ISOG, has the same function |
| ALLD | Auto Low Light frame Duration | 24, 25 or 30 (based video frame rate) | n/a | ALL extended exposure time |
| WBAL | White Balance in Kelvin | 24, 25 or 30 (based video frame rate) | n/a | Classic white balance info |
| WRGB | White Balance RGB gains | 24, 25 or 30 (based video frame rate) | n/a | Geeky white balance info |

### HERO7 Black (v1.8) Adds, Removes, Changes, Otherwise Supports All HERO6 metadata

| FourCC | Property | approximate frequency (Hz) | SIUN or UNIT | Comment |
| --- | --- | --- | --- | --- |
| FACE | Face boxes and smile confidence | at base frame rate 24/25/30 | n/a | struct ID,x,y,w,h,unused[17],smile |
| FCNM | removed | n/a | n/a |  |
| YAVG | Luma (Y) Average over the frame | 8 - 10 | n/a | range 0 (black) to 255 (white) |
| HUES | Predominant hues over the frame | 8 - 10 | n/a | struct ubyte hue, ubyte weight, HSV\_Hue = hue x 360/255 |
| UNIF | Image uniformity | 8 - 10 | range 0 to 1.0 where 1.0 is a solid color |  |
| SCEN | Scene classifier in probabilities | 8 - 10 | n/a | FourCC scenes: SNOW, URBAn, INDOor, WATR, VEGEtation, BEACh |
| SROT | Sensor Read Out Time | at base frame rate 24/25/30 | n/a | this moves to a global value in HERO8 |

### HERO8 Black (v1.2) Adds, Removes, Changes, Otherwise Supports All HERO7 metadata

| FourCC | Property | approximate frequency (Hz) | SIUN or UNIT | Comment |
| --- | --- | --- | --- | --- |
| CORI | Camera ORIentation | frame rate | n/a | Quaterions for the camera orientation since capture start |
| IORI | Image ORIentation | frame rate | n/a | Quaterions for the image orientation relative to the camera body |
| GRAV | GRAvity Vector | frame rate | n/a | Vector for the direction for gravitiy |
| WNDM | Wind Processing | 10Hz | n/a | marks whether wind processing is active |
| MWET | Microphone is WET | 10Hz | n/a | marks whether some of the microphones are wet |
| AALP | Audio Levels | 10Hz | dBFS | RMS and peak audio levels in dBFS |

### GoPro MAX (v1.3) Adds, Removes, Changes, Otherwise Supports All HERO7 metadata

| FourCC | Property | approximate frequency (Hz) | SIUN or UNIT | Comment |
| --- | --- | --- | --- | --- |
| CORI | Camera ORIentation | frame rate | n/a | Quaterions for the camera orientation since capture start |
| IORI | Image ORIentation | frame rate | n/a | Quaterions for the image orientation relative to the camera body |
| GRAV | GRAvity Vector | frame rate | n/a | Vector for the direction for gravitiy |
| DISP | Dispartity track (360 modes) | frame rate | n/a | 1-D depth map for the objects seen by the two lenses |

```
GoPro is trademark of GoPro, Inc.

```

## About

Parser for GPMF™ formatted telemetry data used within GoPro® cameras.

### Topics

[sdk](/topics/sdk "Topic: sdk")
[gps](/topics/gps "Topic: gps")
[telemetry](/topics/telemetry "Topic: telemetry")
[gopro](/topics/gopro "Topic: gopro")
[accelerometer](/topics/accelerometer "Topic: accelerometer")
[mp4-video](/topics/mp4-video "Topic: mp4-video")
[sensor-data](/topics/sensor-data "Topic: sensor-data")
[gopro-camera](/topics/gopro-camera "Topic: gopro-camera")
[gryo](/topics/gryo "Topic: gryo")

### Resources

[Readme](#readme-ov-file)
### License

Apache-2.0 and 2 other licenses found

### Licenses found

[Apache-2.0
LICENSE.txt](/gopro/gpmf-parser/blob/main/./LICENSE.txt) [Apache-2.0
LICENSE-APACHE](/gopro/gpmf-parser/blob/main/./LICENSE-APACHE) [MIT
LICENSE-MIT](/gopro/gpmf-parser/blob/main/./LICENSE-MIT)

[Activity](/gopro/gpmf-parser/activity)
[Custom properties](/gopro/gpmf-parser/custom-properties)
### Stars

[**559**
stars](/gopro/gpmf-parser/stargazers)
### Watchers

[**93**
watching](/gopro/gpmf-parser/watchers)
### Forks

[**114**
forks](/gopro/gpmf-parser/forks)
[Report repository](/contact/report-content?content_url=https%3A%2F%2Fgithub.com%2Fgopro%2Fgpmf-parser&report=gopro+%28user%29)

## [Releases 11](/gopro/gpmf-parser/releases)

[v2.2.1 - Cleanup MP4Reader and Utils.
Latest

Apr 12, 2021](/gopro/gpmf-parser/releases/tag/v2.2.1)
[+ 10 releases](/gopro/gpmf-parser/releases)

## [Packages 0](/orgs/gopro/packages?repo_name=gpmf-parser)

No packages published

## [Contributors 20](/gopro/gpmf-parser/graphs/contributors)

* [![@dnewman-gpsw](https://avatars.githubusercontent.com/u/10856084?s=64&v=4)](https://github.com/dnewman-gpsw)
* [![@tcheema-gpsw](https://avatars.githubusercontent.com/u/8237284?s=64&v=4)](https://github.com/tcheema-gpsw)
* [![@YoannLaala](https://avatars.githubusercontent.com/u/1273276?s=64&v=4)](https://github.com/YoannLaala)
* [![@osievert-gpfw](https://avatars.githubusercontent.com/u/4572677?s=64&v=4)](https://github.com/osievert-gpfw)
* [![@0dan0](https://avatars.githubusercontent.com/u/32990880?s=64&v=4)](https://github.com/0dan0)
* [![@bradh](https://avatars.githubusercontent.com/u/174642?s=64&v=4)](https://github.com/bradh)
* [![@ryan-williams](https://avatars.githubusercontent.com/u/465045?s=64&v=4)](https://github.com/ryan-williams)
* [![@PolarNick239](https://avatars.githubusercontent.com/u/1218605?s=64&v=4)](https://github.com/PolarNick239)
* [![@retokromer](https://avatars.githubusercontent.com/u/3246607?s=64&v=4)](https://github.com/retokromer)
* [![@kgurganus-gpfw](https://avatars.githubusercontent.com/u/6580599?s=64&v=4)](https://github.com/kgurganus-gpfw)
* [![@qdespinoy-gpsw](https://avatars.githubusercontent.com/u/38039072?s=64&v=4)](https://github.com/qdespinoy-gpsw)
* [![@flupke](https://avatars.githubusercontent.com/u/188962?s=64&v=4)](https://github.com/flupke)
* [![@simonlynen](https://avatars.githubusercontent.com/u/966785?s=64&v=4)](https://github.com/simonlynen)
* [![@mmirabent](https://avatars.githubusercontent.com/u/1222986?s=64&v=4)](https://github.com/mmirabent)

[+ 6 contributors](/gopro/gpmf-parser/graphs/contributors)

## Languages

* [C
  98.1%](/gopro/gpmf-parser/search?l=c)
* [CMake
  1.1%](/gopro/gpmf-parser/search?l=cmake)
* Other
  0.8%

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_d5c2c851_20250119_135026.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fgopro%2Fgpmf-parser%2Fblob%2F2cc0af7ffee6f12934e2d57750bdf292f62b0a97%2FGPMF_parser.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fgopro%2Fgpmf-parser%2Fblob%2F2cc0af7ffee6f12934e2d57750bdf292f62b0a97%2FGPMF_parser.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=gopro%2Fgpmf-parser)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[gopro](/gopro)
/
**[gpmf-parser](/gopro/gpmf-parser)**
Public

* [Notifications](/login?return_to=%2Fgopro%2Fgpmf-parser) You must be signed in to change notification settings
* [Fork
  114](/login?return_to=%2Fgopro%2Fgpmf-parser)
* [Star
   559](/login?return_to=%2Fgopro%2Fgpmf-parser)

* [Code](/gopro/gpmf-parser)
* [Issues
  24](/gopro/gpmf-parser/issues)
* [Pull requests
  0](/gopro/gpmf-parser/pulls)
* [Actions](/gopro/gpmf-parser/actions)
* [Projects
  0](/gopro/gpmf-parser/projects)
* [Wiki](/gopro/gpmf-parser/wiki)
* [Security](/gopro/gpmf-parser/security)
* [Insights](/gopro/gpmf-parser/pulse)

Additional navigation options

* [Code](/gopro/gpmf-parser)
* [Issues](/gopro/gpmf-parser/issues)
* [Pull requests](/gopro/gpmf-parser/pulls)
* [Actions](/gopro/gpmf-parser/actions)
* [Projects](/gopro/gpmf-parser/projects)
* [Wiki](/gopro/gpmf-parser/wiki)
* [Security](/gopro/gpmf-parser/security)
* [Insights](/gopro/gpmf-parser/pulse)

## Files

 2cc0af7
## Breadcrumbs

1. [gpmf-parser](/gopro/gpmf-parser/tree/2cc0af7ffee6f12934e2d57750bdf292f62b0a97)
/
# GPMF\_parser.c

Copy path Blame  Blame
## Latest commit

## History

[History](/gopro/gpmf-parser/commits/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c)2066 lines (1758 loc) · 55.6 KB 2cc0af7
## Breadcrumbs

1. [gpmf-parser](/gopro/gpmf-parser/tree/2cc0af7ffee6f12934e2d57750bdf292f62b0a97)
/
# GPMF\_parser.c

Top
## File metadata and controls

* Code
* Blame

2066 lines (1758 loc) · 55.6 KB[Raw](https://github.com/gopro/gpmf-parser/raw/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\*! @file GPMF\_parser.c \*  \* @brief GPMF Parser library \* \* @version 1.6.2 \*  \* (C) Copyright 2017-2020 GoPro Inc (http://gopro.com/). \*  \* Licensed under either: \* - Apache License, Version 2.0, http://www.apache.org/licenses/LICENSE-2.0  \* - MIT license, http://opensource.org/licenses/MIT \* at your option. \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an "AS IS" BASIS, \* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*  \*/
#include <stdlib.h>#include <stdio.h>#include <string.h>#include <stdint.h>
#include "GPMF\_parser.h"#include "GPMF\_bitstream.h"
#ifdef DBG#if \_WINDOWS#define DBG\_MSG printf#else#define DBG\_MSG(...)#endif#else#define DBG\_MSG(...)#endif
GPMF\_ERR IsValidSize(GPMF\_stream \*ms, uint32\_t size) // size is in longs not bytes.{ if (ms) { uint32\_t nestsize = (uint32\_t)ms->nest\_size[ms->nest\_level]; if (nestsize == 0 && ms->nest\_level == 0) nestsize = ms->buffer\_size\_longs;
 if (size + 2 <= nestsize) return GPMF\_OK; } return GPMF\_ERROR\_BAD\_STRUCTURE;}
GPMF\_ERR GPMF\_Validate(GPMF\_stream \*ms, GPMF\_LEVELS recurse){ if (ms) { uint32\_t currpos = ms->pos; uint32\_t nestsize = ms->nest\_size[ms->nest\_level]; if (nestsize == 0 && ms->nest\_level == 0) nestsize = ms->buffer\_size\_longs;  while (ms->pos+1 < ms->buffer\_size\_longs && nestsize > 0) { uint32\_t key = ms->buffer[ms->pos];
 if (ms->nest\_level == 0 && key != GPMF\_KEY\_DEVICE && ms->device\_count == 0 && ms->pos == 0) { DBG\_MSG("ERROR: uninitized -- GPMF\_ERROR\_BAD\_STRUCTURE\n"); return GPMF\_ERROR\_BAD\_STRUCTURE; }
 if (GPMF\_VALID\_FOURCC(key)) { uint32\_t type\_size\_repeat = ms->buffer[ms->pos + 1]; uint32\_t size = GPMF\_DATA\_SIZE(type\_size\_repeat) >> 2; uint8\_t type = GPMF\_SAMPLE\_TYPE(type\_size\_repeat); if (size + 2 > nestsize) { DBG\_MSG("ERROR: nest size too small within %c%c%c%c-- GPMF\_ERROR\_BAD\_STRUCTURE\n", PRINTF\_4CC(key)); return GPMF\_ERROR\_BAD\_STRUCTURE; }
 if (!GPMF\_VALID\_FOURCC(key)) { DBG\_MSG("ERROR: invalid 4CC -- GPMF\_ERROR\_BAD\_STRUCTURE\n"); return GPMF\_ERROR\_BAD\_STRUCTURE; }
 if (type == GPMF\_TYPE\_NEST && recurse == GPMF\_RECURSE\_LEVELS) { uint32\_t validnest; ms->pos += 2; ms->nest\_level++; if (ms->nest\_level > GPMF\_NEST\_LIMIT) { DBG\_MSG("ERROR: nest level within %c%c%c%c too deep -- GPMF\_ERROR\_BAD\_STRUCTURE\n", PRINTF\_4CC(key)); return GPMF\_ERROR\_BAD\_STRUCTURE; } ms->nest\_size[ms->nest\_level] = size; validnest = GPMF\_Validate(ms, recurse); ms->nest\_level--; if (GPMF\_OK != validnest) { DBG\_MSG("ERROR: invalid nest within %c%c%c%c -- GPMF\_ERROR\_BAD\_STRUCTURE\n", PRINTF\_4CC(key)); return GPMF\_ERROR\_BAD\_STRUCTURE; } else { if (ms->nest\_level == 0) ms->device\_count++; }
 ms->pos += size; nestsize -= 2 + size;
 while (ms->pos < ms->buffer\_size\_longs && nestsize > 0 && ms->buffer[ms->pos] == GPMF\_KEY\_END) { ms->pos++; nestsize--; } } else { ms->pos += 2 + size; nestsize -= 2 + size; }
 if (ms->pos == ms->buffer\_size\_longs) { ms->pos = currpos; return GPMF\_OK; } } else { if (key == GPMF\_KEY\_END) { do { ms->pos++; nestsize--; } while (ms->pos < ms->buffer\_size\_longs && nestsize > 0 && ms->buffer[ms->pos] == 0); } else if (ms->nest\_level == 0 && ms->device\_count > 0) { ms->pos = currpos; return GPMF\_OK; } else { DBG\_MSG("ERROR: bad struct within %c%c%c%c -- GPMF\_ERROR\_BAD\_STRUCTURE\n", PRINTF\_4CC(key)); return GPMF\_ERROR\_BAD\_STRUCTURE; } } }
 ms->pos = currpos; return GPMF\_OK; } else { DBG\_MSG("ERROR: Invalid handle -- GPMF\_ERROR\_MEMORY\n"); return GPMF\_ERROR\_MEMORY; }}
GPMF\_ERR GPMF\_ResetState(GPMF\_stream \*ms){ if (ms) { ms->pos = 0; ms->nest\_level = 0; ms->device\_count = 0; ms->nest\_size[ms->nest\_level] = 0; ms->last\_level\_pos[ms->nest\_level] = 0; ms->last\_seek[ms->nest\_level] = 0; ms->device\_id = 0; ms->device\_name[0] = 0;
 return GPMF\_OK; }  return GPMF\_ERROR\_MEMORY;}
GPMF\_ERR GPMF\_Init(GPMF\_stream \*ms, uint32\_t \*buffer, uint32\_t datasize){ if(ms && buffer && datasize > 0) { uint32\_t pos = 0; //Validate DEVC GPMF while((pos+1) \* 4 < datasize && buffer[pos] == GPMF\_KEY\_DEVICE) { uint32\_t size = GPMF\_DATA\_SIZE(buffer[pos+1]); pos += 2 + (size >> 2); } if ((pos\*4) < datasize && buffer[pos] == GPMF\_KEY\_END) // NULL terminated GPMF { datasize = pos \* 4; } if (pos \* 4 == datasize) { ms->buffer = buffer; ms->buffer\_size\_longs = (datasize + 3) >> 2; ms->cbhandle = 0;
 GPMF\_ResetState(ms);
 return GPMF\_OK; } else { return GPMF\_ERROR\_BAD\_STRUCTURE; } }  return GPMF\_ERROR\_MEMORY;}
GPMF\_ERR GPMF\_CopyState(GPMF\_stream \*msrc, GPMF\_stream \*mdst){ if (msrc && mdst) { memcpy(mdst, msrc, sizeof(GPMF\_stream)); return GPMF\_OK; } return GPMF\_ERROR\_MEMORY;}
GPMF\_ERR GPMF\_Next(GPMF\_stream \*ms, GPMF\_LEVELS recurse){ if (ms) { if (ms->pos+1 < ms->buffer\_size\_longs) {
 uint32\_t key, type = GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 1]); uint32\_t size = (GPMF\_DATA\_SIZE(ms->buffer[ms->pos + 1]) >> 2);
 if (GPMF\_OK != IsValidSize(ms, size)) return GPMF\_ERROR\_BAD\_STRUCTURE;
 if (GPMF\_TYPE\_NEST == type && GPMF\_KEY\_DEVICE == ms->buffer[ms->pos] && ms->nest\_level == 0) { ms->last\_level\_pos[ms->nest\_level] = ms->pos; ms->nest\_size[ms->nest\_level] = size; if (recurse) ms->pos += 2; else ms->pos += 2 + size; } else { if (size + 2 > ms->nest\_size[ms->nest\_level]) return GPMF\_ERROR\_BAD\_STRUCTURE;
 if (recurse && type == GPMF\_TYPE\_NEST) { ms->last\_level\_pos[ms->nest\_level] = ms->pos; ms->pos += 2; ms->nest\_size[ms->nest\_level] -= size + 2;
 ms->nest\_level++; if (ms->nest\_level > GPMF\_NEST\_LIMIT) return GPMF\_ERROR\_BAD\_STRUCTURE;
 ms->nest\_size[ms->nest\_level] = size; } else { if (recurse) { ms->pos += size + 2; ms->nest\_size[ms->nest\_level] -= size + 2; } else { if (ms->nest\_size[ms->nest\_level] - (size + 2) > 0) { ms->pos += size + 2; ms->nest\_size[ms->nest\_level] -= size + 2; } else { return GPMF\_ERROR\_LAST;  } } } }
 while (ms->pos < ms->buffer\_size\_longs && ms->nest\_size[ms->nest\_level] > 0 && ms->buffer[ms->pos] == GPMF\_KEY\_END) { ms->pos++; ms->nest\_size[ms->nest\_level]--; }
 while (ms->nest\_level > 0 && ms->nest\_size[ms->nest\_level] == 0) { ms->nest\_level--; //if (ms->nest\_level == 0) //{ // ms->device\_count++; //} }
 if (ms->pos < ms->buffer\_size\_longs) { while (ms->pos < ms->buffer\_size\_longs && ms->nest\_size[ms->nest\_level] > 0 && ms->buffer[ms->pos] == GPMF\_KEY\_END) { ms->pos++; ms->nest\_size[ms->nest\_level]--; }
 key = ms->buffer[ms->pos]; if (!GPMF\_VALID\_FOURCC(key)) return GPMF\_ERROR\_BAD\_STRUCTURE;
 if (key == GPMF\_KEY\_DEVICE\_ID) ms->device\_id = BYTESWAP32(ms->buffer[ms->pos + 2]); if (key == GPMF\_KEY\_DEVICE\_NAME) { size = GPMF\_DATA\_SIZE(ms->buffer[ms->pos + 1]); // in bytes if (size > sizeof(ms->device\_name) - 1) size = sizeof(ms->device\_name) - 1; memcpy(ms->device\_name, &ms->buffer[ms->pos + 2], size); ms->device\_name[size] = 0; } } else { // end of buffer return GPMF\_ERROR\_BUFFER\_END; }
 return GPMF\_OK; } else { // end of buffer return GPMF\_ERROR\_BUFFER\_END; } } return GPMF\_ERROR\_MEMORY;}
GPMF\_ERR GPMF\_FindNext(GPMF\_stream \*ms, uint32\_t fourcc, GPMF\_LEVELS recurse){ GPMF\_stream prevstate;
 if (ms) { memcpy(&prevstate, ms, sizeof(GPMF\_stream));
 if (ms->pos < ms->buffer\_size\_longs) { while (0 == GPMF\_Next(ms, recurse)) { if (ms->buffer[ms->pos] == fourcc) { return GPMF\_OK; //found match } }
 // restore read position memcpy(ms, &prevstate, sizeof(GPMF\_stream)); return GPMF\_ERROR\_FIND; } } return GPMF\_ERROR\_FIND;}
GPMF\_ERR GPMF\_Reserved(uint32\_t key){ if(key == GPMF\_KEY\_DEVICE) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_DEVICE\_ID) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_DEVICE\_NAME) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_STREAM) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_STREAM\_NAME) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_SI\_UNITS) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_UNITS) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_SCALE) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_TYPE) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_TOTAL\_SAMPLES) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_TICK) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_TOCK) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_EMPTY\_PAYLOADS) return GPMF\_ERROR\_RESERVED;
 if(key == GPMF\_KEY\_REMARK) return GPMF\_ERROR\_RESERVED;
 return GPMF\_OK;}
uint32\_t GPMF\_PayloadSampleCount(GPMF\_stream \*ms){ uint32\_t count = 0; if (ms) { uint32\_t fourcc = GPMF\_Key(ms);
 GPMF\_stream find\_stream; GPMF\_CopyState(ms, &find\_stream);
 if (GPMF\_OK == GPMF\_FindNext(&find\_stream, fourcc, GPMF\_CURRENT\_LEVEL)) // Count the instances, not the repeats { count=2; while (GPMF\_OK == GPMF\_FindNext(&find\_stream, fourcc, GPMF\_CURRENT\_LEVEL)) { count++; }  } else { count = GPMF\_Repeat(ms); if (count == 0) // this can happen with an empty FACE, yet this is still a FACE fouce count = 1; } } return count;}
GPMF\_ERR GPMF\_SeekToSamples(GPMF\_stream \*ms){ GPMF\_stream prevstate;
 if (ms) {
 if (ms->pos+1 < ms->buffer\_size\_longs) { uint32\_t type = GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 1]);
 memcpy(&prevstate, ms, sizeof(GPMF\_stream));
 if (type == GPMF\_TYPE\_NEST) GPMF\_Next(ms, GPMF\_RECURSE\_LEVELS); // open STRM and recurse in
 while (0 == GPMF\_Next(ms, GPMF\_CURRENT\_LEVEL)) { uint32\_t size = (GPMF\_DATA\_SIZE(ms->buffer[ms->pos + 1]) >> 2); if (GPMF\_OK != IsValidSize(ms, size)) { memcpy(ms, &prevstate, sizeof(GPMF\_stream)); return GPMF\_ERROR\_BAD\_STRUCTURE; }
 type = GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 1]);
 if (type == GPMF\_TYPE\_NEST) // Nest with-in nest { return GPMF\_OK; //found match }
 if (size + 2 == ms->nest\_size[ms->nest\_level]) { uint32\_t key = GPMF\_Key(ms);
 if (GPMF\_ERROR\_RESERVED == GPMF\_Reserved(key)) return GPMF\_ERROR\_FIND;  return GPMF\_OK; //found match }
 if (ms->buffer[ms->pos] == ms->buffer[ms->pos + size + 2]) // Matching tags { return GPMF\_OK; //found match } }
 // restore read position memcpy(ms, &prevstate, sizeof(GPMF\_stream)); return GPMF\_ERROR\_FIND; } } return GPMF\_ERROR\_FIND;}
GPMF\_ERR GPMF\_FindPrev(GPMF\_stream \*ms, uint32\_t fourcc, GPMF\_LEVELS recurse){ GPMF\_stream prevstate;
 if (ms) { uint32\_t curr\_level = ms->nest\_level;
 memcpy(&prevstate, ms, sizeof(GPMF\_stream));
 if (ms->pos < ms->buffer\_size\_longs && curr\_level > 0) {
 do { ms->last\_seek[curr\_level] = ms->pos; ms->pos = ms->last\_level\_pos[curr\_level - 1] + 2; ms->nest\_size[curr\_level] += ms->last\_seek[curr\_level] - ms->pos; do { if (ms->last\_seek[curr\_level] > ms->pos && ms->buffer[ms->pos] == fourcc) {
 return GPMF\_OK; //found match } } while (ms->last\_seek[curr\_level] > ms->pos && 0 == GPMF\_Next(ms, GPMF\_CURRENT\_LEVEL));
 curr\_level--; } while (recurse == GPMF\_RECURSE\_LEVELS && curr\_level > 0);
 // restore read position memcpy(ms, &prevstate, sizeof(GPMF\_stream));
 return GPMF\_ERROR\_FIND; } }
 return GPMF\_ERROR\_FIND;}
uint32\_t GPMF\_Key(GPMF\_stream \*ms){ if (ms) { uint32\_t key = ms->buffer[ms->pos]; return key; } return 0;}
GPMF\_SampleType GPMF\_Type(GPMF\_stream \*ms){ if (ms && ms->pos+1 < ms->buffer\_size\_longs) { GPMF\_SampleType type = (GPMF\_SampleType)GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos+1]); if (type == GPMF\_TYPE\_COMPRESSED && ms->pos+2 < ms->buffer\_size\_longs) { type = (GPMF\_SampleType)GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 2]); } return type; } return GPMF\_TYPE\_ERROR;}
uint32\_t GPMF\_StructSize(GPMF\_stream \*ms){ if (ms && ms->pos+1 < ms->buffer\_size\_longs) { uint32\_t ssize = GPMF\_SAMPLE\_SIZE(ms->buffer[ms->pos + 1]); uint32\_t type = GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 1]); if (type == GPMF\_TYPE\_COMPRESSED && ms->pos+2 < ms->buffer\_size\_longs) { ssize = GPMF\_SAMPLE\_SIZE(ms->buffer[ms->pos + 2]); } return ssize; } return 0;}
uint32\_t GPMF\_ElementsInStruct(GPMF\_stream \*ms){ if (ms && ms->pos+1 < ms->buffer\_size\_longs) { uint32\_t ssize = GPMF\_SAMPLE\_SIZE(ms->buffer[ms->pos + 1]); GPMF\_SampleType type = (GPMF\_SampleType) GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 1]);
 if (type != GPMF\_TYPE\_NEST && type != GPMF\_TYPE\_COMPLEX && type != GPMF\_TYPE\_COMPRESSED) { uint32\_t tsize = GPMF\_SizeofType(type); if (tsize > 0) return ssize / tsize; else return 0; } if (type == GPMF\_TYPE\_COMPLEX) { GPMF\_stream find\_stream; GPMF\_CopyState(ms, &find\_stream);
 if (GPMF\_OK == GPMF\_FindPrev(&find\_stream, GPMF\_KEY\_TYPE, GPMF\_CURRENT\_LEVEL)) { char tmp[64] = ""; uint32\_t tmpsize = sizeof(tmp); char \*data = (char \*)GPMF\_RawData(&find\_stream); uint32\_t size = GPMF\_RawDataSize(&find\_stream);  if (GPMF\_OK == GPMF\_ExpandComplexTYPE(data, size, tmp, &tmpsize)) return tmpsize; } } if (type == GPMF\_TYPE\_COMPRESSED && ms->pos+2 < ms->buffer\_size\_longs) { type = (GPMF\_SampleType)GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 2]); ssize = GPMF\_SAMPLE\_SIZE(ms->buffer[ms->pos + 2]); uint32\_t tsize = GPMF\_SizeofType(type); if (tsize > 0) return ssize / tsize; else return 0; } } return 0;}
uint32\_t GPMF\_Repeat(GPMF\_stream \*ms){ if (ms && ms->pos+1 < ms->buffer\_size\_longs) { GPMF\_SampleType type = (GPMF\_SampleType)GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 1]); uint32\_t repeat = GPMF\_SAMPLES(ms->buffer[ms->pos + 1]); if(type == GPMF\_TYPE\_COMPRESSED && ms->pos+2 < ms->buffer\_size\_longs) { repeat = GPMF\_SAMPLES(ms->buffer[ms->pos + 2]); } return repeat; } return 0;}
uint32\_t GPMF\_RawDataSize(GPMF\_stream \*ms){ if (ms && ms->pos+1 < ms->buffer\_size\_longs) { uint32\_t size = GPMF\_DATA\_PACKEDSIZE(ms->buffer[ms->pos + 1]); if (GPMF\_OK != IsValidSize(ms, size >> 2)) return 0;
 return size; } return 0;}
uint32\_t GPMF\_FormattedDataSize(GPMF\_stream \*ms){ if (ms && ms->pos + 1 < ms->buffer\_size\_longs) { GPMF\_SampleType type = (GPMF\_SampleType)GPMF\_SAMPLE\_TYPE(ms->buffer[ms->pos + 1]); uint32\_t size = GPMF\_SAMPLE\_SIZE(ms->buffer[ms->pos + 1])\*GPMF\_SAMPLES(ms->buffer[ms->pos + 1]);
 if (type == GPMF\_TYPE\_COMPRESSED && ms->pos+2 < ms->buffer\_size\_longs) { size = GPMF\_SAMPLE\_SIZE(ms->buffer[ms->pos + 2])\*GPMF\_SAMPLES(ms->buffer[ms->pos + 2]); } return size; } return 0;}
uint32\_t GPMF\_ScaledDataSize(GPMF\_stream \*ms, GPMF\_SampleType type){ if (ms && ms->pos + 1 < ms->buffer\_size\_longs) { uint32\_t elements = GPMF\_ElementsInStruct(ms); uint32\_t samples = GPMF\_Repeat(ms); return GPMF\_SizeofType(type) \* elements \* samples; } return 0;}
uint32\_t GPMF\_NestLevel(GPMF\_stream \*ms){ if (ms) { return ms->nest\_level; } return 0;}
uint32\_t GPMF\_DeviceID(GPMF\_stream \*ms){ if (ms) { return ms->device\_id; } return 0;}
GPMF\_ERR GPMF\_DeviceName(GPMF\_stream \*ms, char \*devicenamebuf, uint32\_t devicename\_buf\_size){ if (ms && devicenamebuf) { uint32\_t len = (uint32\_t)strlen(ms->device\_name); if (len >= devicename\_buf\_size) return GPMF\_ERROR\_MEMORY;
 memcpy(devicenamebuf, ms->device\_name, len); devicenamebuf[len] = 0; return GPMF\_OK; } return GPMF\_ERROR\_MEMORY;}
void \*GPMF\_RawData(GPMF\_stream \*ms){ if (ms) { return (void \*)&ms->buffer[ms->pos + 2]; } return NULL;}
int32\_t GPMFTypeEndianSize(int type){ int32\_t ssize = -1;
 switch ((int)type) { case GPMF\_TYPE\_STRING\_ASCII: ssize = 1; break; case GPMF\_TYPE\_SIGNED\_BYTE: ssize = 1; break; case GPMF\_TYPE\_UNSIGNED\_BYTE: ssize = 1; break; case GPMF\_TYPE\_STRING\_UTF8: ssize = 1; break;
 // These datatype can always be stored in Big-Endian case GPMF\_TYPE\_SIGNED\_SHORT: ssize = 2; break; case GPMF\_TYPE\_UNSIGNED\_SHORT: ssize = 2; break; case GPMF\_TYPE\_FLOAT: ssize = 4; break; case GPMF\_TYPE\_FOURCC: ssize = 1; break; case GPMF\_TYPE\_SIGNED\_LONG: ssize = 4; break; case GPMF\_TYPE\_UNSIGNED\_LONG: ssize = 4; break; case GPMF\_TYPE\_Q15\_16\_FIXED\_POINT: ssize = 4; break; case GPMF\_TYPE\_Q31\_32\_FIXED\_POINT: ssize = 8; break; case GPMF\_TYPE\_DOUBLE: ssize = 8; break; case GPMF\_TYPE\_SIGNED\_64BIT\_INT: ssize = 8; break; case GPMF\_TYPE\_UNSIGNED\_64BIT\_INT: ssize = 8; break;
 case GPMF\_TYPE\_GUID: ssize = 1; break; // Do not byte swap case GPMF\_TYPE\_UTC\_DATE\_TIME: ssize = 1; break; // Do not byte swap
 //All unknown,complex or larger than 8-bytes store as is: default: ssize = -1; // unsupported for structsize type }
 return ssize;}
void ByteSwap2Buffer(uint32\_t\* input, uint32\_t\* output, GPMF\_SampleType data\_type, uint32\_t structSize, uint32\_t repeat){ int32\_t i, len = 0, endianSize = GPMFTypeEndianSize(data\_type); if (endianSize == 8) // 64-bit swap required { for (i = 0; i < (int32\_t)((repeat \* structSize + 3) / sizeof(int32\_t)); i += 2) { output[len++] = BYTESWAP32(input[i + 1]);  output[len++] = BYTESWAP32(input[i]); } } else if (endianSize >= 1) { for (i = 0; i < (int32\_t)((repeat \* structSize + 3) / sizeof(int32\_t)); i++) { switch (endianSize) { case 2: output[len++] = BYTESWAP2x16(input[i]); break; case 4: output[len++] = BYTESWAP32(input[i]); break; default: output[len++] = input[i]; break; } } }}
//find and inplace overwrite a GPMF KLV with new KLV, if the lengths match.GPMF\_ERR GPMF\_Modify(GPMF\_stream\* ms, uint32\_t origfourCC, uint32\_t newfourCC,  GPMF\_SampleType newType, uint32\_t newStructSize, uint32\_t newRepeat, void\* newData){ uint32\_t dataSizeLongs = (newStructSize \* newRepeat + 3) >> 2;
 if (ms && ms->pos + 1 + dataSizeLongs < ms->buffer\_size\_longs) { GPMF\_stream fs; GPMF\_CopyState(ms, &fs);
 uint32\_t key = fs.buffer[fs.pos]; uint32\_t tsr = fs.buffer[fs.pos + 1]; uint32\_t ssize = GPMF\_SAMPLE\_SIZE(tsr); uint32\_t repeat = GPMF\_SAMPLES(tsr);
 if (key == origfourCC && (((ssize \* repeat + 3) >> 2) == ((newStructSize \* newRepeat + 3) >> 2))) // no find required and data will fit { fs.buffer[fs.pos] = newfourCC; fs.buffer[fs.pos + 1] = GPMF\_MAKE\_TYPE\_SIZE\_COUNT(newType, newStructSize, newRepeat);
 ByteSwap2Buffer((uint32\_t\*)newData, (uint32\_t\*)&fs.buffer[fs.pos + 2], newType, newStructSize, newRepeat); return GPMF\_OK; } else { // search forward from the current position at this level if (GPMF\_OK == GPMF\_FindNext(&fs, origfourCC, GPMF\_CURRENT\_LEVEL)) { tsr = fs.buffer[fs.pos + 1]; ssize = GPMF\_SAMPLE\_SIZE(tsr); repeat = GPMF\_SAMPLES(tsr);
 if (((ssize \* repeat + 3) >> 2) == ((newStructSize \* newRepeat + 3) >> 2)) //will the new data fit { fs.buffer[fs.pos] = newfourCC; fs.buffer[fs.pos + 1] = GPMF\_MAKE\_TYPE\_SIZE\_COUNT(newType, newStructSize, newRepeat);
 ByteSwap2Buffer((uint32\_t\*)newData, (uint32\_t\*)&fs.buffer[fs.pos + 2], newType, newStructSize, newRepeat); return GPMF\_OK; } return GPMF\_ERROR\_BAD\_STRUCTURE; // sizes don't match } // search backward from the current position at this level else if (GPMF\_OK == GPMF\_FindPrev(&fs, origfourCC, GPMF\_CURRENT\_LEVEL)) { tsr = fs.buffer[fs.pos + 1]; ssize = GPMF\_SAMPLE\_SIZE(tsr); repeat = GPMF\_SAMPLES(tsr);
 if (((ssize \* repeat + 3) >> 2) == ((newStructSize \* newRepeat + 3) >> 2)) //will the new data fit { fs.buffer[fs.pos] = newfourCC; fs.buffer[fs.pos + 1] = GPMF\_MAKE\_TYPE\_SIZE\_COUNT(newType, newStructSize, newRepeat);
 ByteSwap2Buffer((uint32\_t\*)newData, (uint32\_t\*)&fs.buffer[fs.pos + 2], newType, newStructSize, newRepeat); return GPMF\_OK; } return GPMF\_ERROR\_BAD\_STRUCTURE; // sizes don't match } else  { // search from the beginning through all levels GPMF\_ResetState(&fs); if (GPMF\_OK == GPMF\_FindNext(&fs, origfourCC, GPMF\_RECURSE\_LEVELS)) {  tsr = fs.buffer[fs.pos + 1]; ssize = GPMF\_SAMPLE\_SIZE(tsr); repeat = GPMF\_SAMPLES(tsr);
 if (((ssize \* repeat + 3) >> 2) == ((newStructSize \* newRepeat + 3) >> 2)) //will the new data fit { fs.buffer[fs.pos] = newfourCC; fs.buffer[fs.pos + 1] = GPMF\_MAKE\_TYPE\_SIZE\_COUNT(newType, newStructSize, newRepeat);
 ByteSwap2Buffer((uint32\_t\*)newData, (uint32\_t\*)&fs.buffer[fs.pos + 2], newType, newStructSize, newRepeat); return GPMF\_OK; } return GPMF\_ERROR\_BAD\_STRUCTURE; // sizes don't match } else return GPMF\_ERROR\_FIND; // if can't find the data to replace. } } } return GPMF\_ERROR\_BAD\_STRUCTURE; // sizes don't match}
uint32\_t GPMF\_SizeofType(GPMF\_SampleType type){ uint32\_t ssize = 0;
 switch (type) { case GPMF\_TYPE\_STRING\_ASCII: ssize = 1; break; case GPMF\_TYPE\_SIGNED\_BYTE: ssize = 1; break; case GPMF\_TYPE\_UNSIGNED\_BYTE: ssize = 1; break;
 // These datatypes are always be stored in Big-Endian case GPMF\_TYPE\_SIGNED\_SHORT: ssize = 2; break; case GPMF\_TYPE\_UNSIGNED\_SHORT: ssize = 2; break; case GPMF\_TYPE\_FLOAT: ssize = 4; break; case GPMF\_TYPE\_FOURCC: ssize = 4; break; case GPMF\_TYPE\_SIGNED\_LONG: ssize = 4; break; case GPMF\_TYPE\_UNSIGNED\_LONG: ssize = 4; break; case GPMF\_TYPE\_Q15\_16\_FIXED\_POINT: ssize = 4; break; case GPMF\_TYPE\_Q31\_32\_FIXED\_POINT: ssize = 8; break; case GPMF\_TYPE\_DOUBLE: ssize = 8; break; case GPMF\_TYPE\_SIGNED\_64BIT\_INT: ssize = 8; break; case GPMF\_TYPE\_UNSIGNED\_64BIT\_INT: ssize = 8; break;
 //All unknown or larger than 8-bytes stored as is: case GPMF\_TYPE\_GUID: ssize = 16; break; case GPMF\_TYPE\_UTC\_DATE\_TIME: ssize = 16; break; default: ssize = 0; break; }
 return ssize;}
uint32\_t GPMF\_ExpandComplexTYPE(char \*src, uint32\_t srcsize, char \*dst, uint32\_t \*dstsize){ uint32\_t i = 0, k = 0, count = 0;
 while (i<srcsize && k<\*dstsize) { if (src[i] == '[' && i>0) { uint32\_t j = 1; count = 0; while (src[i + j] >= '0' && src[i + j] <= '9') { count \*= 10; count += (uint32\_t) (src[i + j] - '0'); j++; }
 if (count > 1) { uint32\_t l; for (l = 1; l<count; l++) { dst[k] = src[i - 1]; k++; } } i += j; if (src[i] == ']') i++; } else { dst[k] = src[i]; if (dst[k] == 0) break; i++; k++; } }
 if (k >= \*dstsize) return GPMF\_ERROR\_MEMORY; // bad structure formed
 dst[k] = 0; \*dstsize = k;
 return GPMF\_OK;}
uint32\_t GPMF\_SizeOfComplexTYPE(char \*type, uint32\_t typestringlength){ char \*typearray = type; uint32\_t size = 0, expand = 0; uint32\_t i, len = typestringlength;
 for (i = 0; i < len; i++) if (typearray[i] == '[') expand = 1;  if (expand) { char exptypearray[64]; uint32\_t dstsize = sizeof(exptypearray);
 if (GPMF\_OK == GPMF\_ExpandComplexTYPE(typearray, len, exptypearray, &dstsize)) { typearray = exptypearray; len = dstsize; } else[View remainder of file in raw view](https://github.com/gopro/gpmf-parser/raw/2cc0af7ffee6f12934e2d57750bdf292f62b0a97/GPMF_parser.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_3097fca9_20250119_135039.html ===

[Skip to content](#start-of-content)

GitHub Copilot is now available for free.
[Learn more](https://github.com/features/copilot/?utm_source=github&utm_medium=banner&utm_campaign=copilotfree-bannerheader)

## Navigation Menu

Toggle navigation

[Sign in](/login)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F&source=header-home)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

# Build and ship software on a single, collaborative platform

Join the world’s most widely adopted AI-powered developer platform.

Enter your emailSign up for GitHub[Try GitHub Copilot](/features/copilot)
## GitHub features

A demonstration animation of a code editor using GitHub Copilot Chat, where the user requests GitHub Copilot to refactor duplicated logic and extract it into a reusable function for a given code snippet.

CodePlanCollaborateAutomateSecure

Build code quickly and more securely with GitHub Copilot embedded throughout your workflows.

## GitHub is used by

![Shopify](https://github.githubassets.com/assets/shopify-3fed3011ac81.svg)![EY](https://github.githubassets.com/assets/ey-7434b194d68c.svg)![Figma](https://github.githubassets.com/assets/figma-04e0038c0fef.svg)![Duolingo](https://github.githubassets.com/assets/duolingo-ea3a0aa56fa5.svg)![New York Times](https://github.githubassets.com/assets/newyorktimes-9d76d7f338f5.svg)![Mercado Libre](https://github.githubassets.com/assets/mercado-libre-762f679589f2.svg)![American Airlines](https://github.githubassets.com/assets/american-airlines-a2b13c8fbe08.svg)![Ford](https://github.githubassets.com/assets/ford-2fb5195a4c7c.svg)![Mercedes Benz](https://github.githubassets.com/assets/mercedes-b9190458c80e.svg)![Société Générale](https://github.githubassets.com/assets/societe-generale-7a3414490494.svg)![Vodafone](https://github.githubassets.com/assets/vodafone-6e0f322de6cd.svg)![Philips](https://github.githubassets.com/assets/philips-8087a5f95f5c.svg)![SAP](https://github.githubassets.com/assets/sap-ea7dcd02e37d.svg)![Infosys](https://github.githubassets.com/assets/infosys-7587455de0bd.svg)![Spotify](https://github.githubassets.com/assets/spotify-591ecb426c1e.svg)![Shopify](https://github.githubassets.com/assets/shopify-3fed3011ac81.svg)![EY](https://github.githubassets.com/assets/ey-7434b194d68c.svg)![Figma](https://github.githubassets.com/assets/figma-04e0038c0fef.svg)![Duolingo](https://github.githubassets.com/assets/duolingo-ea3a0aa56fa5.svg)![New York Times](https://github.githubassets.com/assets/newyorktimes-9d76d7f338f5.svg)![Mercado Libre](https://github.githubassets.com/assets/mercado-libre-762f679589f2.svg)![American Airlines](https://github.githubassets.com/assets/american-airlines-a2b13c8fbe08.svg)![Ford](https://github.githubassets.com/assets/ford-2fb5195a4c7c.svg)![Mercedes Benz](https://github.githubassets.com/assets/mercedes-b9190458c80e.svg)![Société Générale](https://github.githubassets.com/assets/societe-generale-7a3414490494.svg)![Vodafone](https://github.githubassets.com/assets/vodafone-6e0f322de6cd.svg)![Philips](https://github.githubassets.com/assets/philips-8087a5f95f5c.svg)![SAP](https://github.githubassets.com/assets/sap-ea7dcd02e37d.svg)![Infosys](https://github.githubassets.com/assets/infosys-7587455de0bd.svg)![Spotify](https://github.githubassets.com/assets/spotify-591ecb426c1e.svg)
## Accelerate performance

With GitHub Copilot embedded throughout the platform, you can simplify your toolchain, automate tasks, and improve the developer experience.

![](https://github.githubassets.com/assets/particles-de1dd20f3008.png)A Copilot chat window with extensions enabled. The user inputs the @ symbol to reveal a list of five Copilot Extensions. @Sentry is selected from the list, which shifts the window to a chat directly with that extension. There are three sample prompts at the bottom of the chat window, allowing the user to Get incident information, Edit status on incident, or List the latest issues. The last one is activated to send the prompt: @Sentry List the latest issues. The extension then lists several new issues and their metadata.
### Work 55% faster.1 Increase productivity with AI-powered coding assistance, including code completion, chat, and more.

1[Survey: The AI wave continues to grow on software development teams, 2024.](https://github.blog/news-insights/research/survey-ai-wave-grows/)

[Explore GitHub Copilot](/features/copilot)![Duolingo](https://github.githubassets.com/assets/logo-duolingo-14477f9e54a6.svg)

Duolingo boosts developer speed by 25% with GitHub Copilot

[Read customer story](/customer-stories/duolingo)![Gartner](https://github.githubassets.com/assets/logo-gartner-aa8c2e452b64.svg)

2024 Gartner® Magic Quadrant™ for AI Code Assistants

[Read report](https://www.gartner.com/doc/reprints?id=1-2IKO4MPE&ct=240819&st=sb)![](https://github.githubassets.com/assets/accordion-1-ce487d44c0bf.webp)![](https://github.githubassets.com/assets/accordion-2-730955545f07.webp)![](https://github.githubassets.com/assets/accordion-3-52ca331d22ea.webp)![](https://github.githubassets.com/assets/accordion-4-a26744b70ff7.webp)
### Automate any workflow

Optimize your process with simple and secured CI/CD.

A list of workflows displays a heading ‘45,167 workflow runs’ at the top. Below are five rows of completed workflows accompanied by their completion time and their duration formatted in minutes and seconds.[Discover GitHub Actions](/features/actions)
### Get up and running in seconds

Start building instantly with a comprehensive dev environment in the cloud.

A GitHub Codespaces setup for the landing page of a game called OctoInvaders. On the left is a code editor with some HTML and Javascript files open. On the right is a live render of the page. In front of this split editor window is a screenshot of two active GitHub Codespaces environments with their branch names and a button to ‘Create codespace on main.’[Check out GitHub Codespaces](/features/codespaces)
### Build on the go

Manage projects and chat with GitHub Copilot from anywhere.

Two smartphone screens side by side. The left screen shows a Notification inbox, listing issues and pull requests from different repositories like TensorFlow and GitHub’s OctoArcade octoinvaders. The right screen shows a new conversation in GitHub Copilot chat.[Download GitHub Mobile](/mobile)
### Integrate the tools you love

Sync with 17,000+ integrations and a growing library of Copilot Extensions.

A grid of fifty app tiles displays logos for integrations and extensions for companies like Stripe, Slack, and Docker. The tiles extend beyond the bounds of the image to indicate a wide array of apps. [Visit GitHub Marketplace](/marketplace)
## Built-in application security where found means fixed

Use AI to find and fix vulnerabilities—freeing your teams to ship more secure software faster.

![](https://github.githubassets.com/assets/particles-de1dd20f3008.png)
### Apply fixes in seconds. Spend less time fixing vulnerabilities and more time building features with Copilot Autofix.

[Explore GitHub Advanced Security](/enterprise/advanced-security)![Copilot Autofix identifies vulnerable code and provides an explanation, together with a secure code suggestion to remediate the vulnerability.](https://github.githubassets.com/assets/hero-64ecd484397f.webp)

Solve security debt. Leverage AI-assisted security campaigns to reduce application vulnerabilities and zero-day attacks.

[Discover security campaigns](/enterprise/advanced-security)![A security campaign screen displays the campaign’s progress bar with 97% completed of 701 alerts. A total of 23 alerts are left with 13 in progress, and the campaign started 20 days ago. The status below shows that there are 7 days left in the campaign with a due date of November 15, 2024.](https://github.githubassets.com/assets/pillar-1-dd667a921f55.webp)

Dependencies you can depend on. Update vulnerable dependencies with supported fixes for breaking changes.

[Learn about Dependabot](/features/security/software-supply-chain)![List of dependencies defined in a requirements .txt file.](https://github.githubassets.com/assets/pillar-2-ff69e872920a.webp)

Your secrets, your business: protected.  Detect, prevent, and remediate leaked secrets across your organization.

[Read about secret scanning](/features/security/code)![GitHub push protection confirms and displays an active secret, and blocks the push.](https://github.githubassets.com/assets/pillar-3-0a063e2daae2.webp)
### 7x fastervulnerability fixes with GitHub2

2This 7X times factor is based on data from the industry’s longest running analysis of fix rates Veracode State of Software Security 2023, which cites the average time to fix 50% of flaws as 198 days vs. GitHub’s fix rates of 72% of flaws with in 28 days which is at a minimum of 7X faster when compared.

### 90% coverage[of alert types in all supported languages with Copilot Autofix](https://docs.github.com/en/code-security/code-scanning/managing-your-code-scanning-configuration/codeql-query-suites)

## Work together, achieve more

Collaborate with your teams, use management tools that sync with your projects, and code from anywhere—all on a single, integrated platform.

![](https://github.githubassets.com/assets/particles-de1dd20f3008.png)![A project management dashboard showing tasks for the ‘OctoArcade Invaders’ project, with tasks grouped under project phase categories like ‘Prototype,’ ‘Beta,’ and ‘Launch’ in a table layout. One of the columns displays sub-issue progress bars with percentages for each issue.](https://github.githubassets.com/assets/hero-961322485af6.webp)
### Your workflows, your way. Plan effectively with an adaptable spreadsheet that syncs with your work.

[Jump into GitHub Projects](/features/issues)“
> It helps us onboard new software engineers and get them productive right away. We have all our source code, issues, and pull requests in one place... GitHub is a complete platform that frees us from menial tasks and enables us to do our best work.

Fabian FaulhaberApplication manager at Mercedes-Benz

![](https://github.githubassets.com/assets/accordion-1-38ad6b6d1b20.webp)![](https://github.githubassets.com/assets/accordion-2-c0a62cfc31a1.webp)![](https://github.githubassets.com/assets/accordion-3-5d5d222f1830.webp)![](https://github.githubassets.com/assets/accordion-4-7abff9233556.webp)
### Keep track of your tasks

Create issues and manage projects with tools that adapt to your code.

Display of task tracking within an issue, showing the status of related sub-issues and their connection to the main issue.[Explore GitHub Issues](/features/issues)
### Share ideas and ask questions

Create space for open-ended conversations alongside your project.

A GitHub Discussions thread where a GitHub user suggests a power-up idea involving Hubot revealing a path and protecting Mona. The post has received 5 upvotes and several reactions. Below, three other users add to the discussion, suggesting Hubot could provide different power-ups depending on levels and appreciating the collaboration idea.[Discover GitHub Discussions](/features/discussions)
### Review code changes together

Create review processes that improve code quality and fit neatly into your workflow.

Two code review approvals by helios-ackmore and amanda-knox, which are followed by three successful checks for ‘Build,’ ‘Test,’ and ‘Publish.’[Learn about code review](/features/code-review)
### Fund open source projects

Become an open source partner and support the tools and libraries that power your work.

A GitHub Sponsors popup displays ‘$15,000 a month’ with a progress bar showing 87% towards a $15,000 goal.[Dive into GitHub Sponsors](/sponsors)
## From startups to enterprises, GitHub scales with teams of any size in any industry.

By industryBy sizeBy use case

---

[![](https://github.githubassets.com/assets/figma-62d390a52419.webp)![Figma](https://github.githubassets.com/assets/figma-9b0c642e96b8.svg)Technology

Figma streamlines development and strengthens security

Read customer story](https://github.com/customer-stories/figma)[![](https://github.githubassets.com/assets/mercedes-benz-d8f89b041561.webp)![Mercedes-Benz](https://github.githubassets.com/assets/mercedes-benz-60ddd54043e7.svg)Automotive

Mercedes-Benz standardizes source code and automates onboarding

Read customer story](https://github.com/customer-stories/mercedes-benz)[![](https://github.githubassets.com/assets/mercado-libre-579cb5447302.webp)![Mercado Libre](https://github.githubassets.com/assets/mercado-libre-2d6d610fa873.svg)Financial services

Mercado Libre cuts coding time by 50%

Read customer story](https://github.com/customer-stories/mercado-libre)[Explore customer stories](/customer-stories)

---

[View all solutions](/solutions)
## Millions of developers and businesses call GitHub home

Whether you’re scaling your development process or just learning how to code, GitHub is where you belong. Join the world’s most widely adopted AI-powered developer platform to build the technologies that redefine what’s possible.

Enter your emailSign up for GitHub[Try GitHub Copilot](/features/copilot)

## Site-wide Links

### Subscribe to our developer newsletter

Get tips, technical guides, and best practices. Twice a month. Right in your inbox.

[Subscribe](https://resources.github.com/newsletter/)

### Product

* [Features](/features)
* [Enterprise](/enterprise)
* [Copilot](/features/copilot)
* [Security](/security)
* [Pricing](/pricing)
* [Team](/team)
* [Resources](https://resources.github.com)
* [Roadmap](https://github.com/github/roadmap)
* [Compare GitHub](https://resources.github.com/devops/tools/compare)

### Platform

* [Developer API](https://docs.github.com/get-started/exploring-integrations/about-building-integrations)
* [Partners](https://partner.github.com)
* [Education](https://github.com/edu)
* [GitHub CLI](https://cli.github.com)
* [GitHub Desktop](https://desktop.github.com)
* [GitHub Mobile](https://github.com/mobile)

### Support

* [Docs](https://docs.github.com)
* [Community Forum](https://github.community)
* [Professional Services](https://services.github.com)
* [Premium Support](/enterprise/premium-support)
* [Skills](https://skills.github.com)
* [Status](https://www.githubstatus.com)
* [Contact GitHub](https://support.github.com?tags=dotcom-footer)

### Company

* [About](https://github.com/about)
* [Customer stories](/customer-stories?type=enterprise)
* [Blog](https://github.blog)
* [The ReadME Project](/readme)
* [Careers](https://github.careers)
* [Newsroom](/newsroom)
* [Inclusion](/about/diversity)
* [Social Impact](https://socialimpact.github.com)
* [Shop](https://shop.github.com)

* © 2025 GitHub, Inc.
* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
  ([Updated 02/2024](https://github.com/github/site-policy/pull/582))
* [Sitemap](/sitemap)
* [What is Git?](/git-guides)
* Manage cookies
* Do not share my personal information

* [GitHub on LinkedIn](https://www.linkedin.com/company/github)
* [Instagram
  GitHub on Instagram](https://www.instagram.com/github)
* [GitHub on YouTube](https://www.youtube.com/github)
* [GitHub on X](https://x.com/github)
* [TikTok
  GitHub on TikTok](https://www.tiktok.com/%40github)
* [Twitch
  GitHub on Twitch](https://www.twitch.tv/github)
* [GitHub’s organization on GitHub](https://github.com/github)

You can’t perform that action at this time.


