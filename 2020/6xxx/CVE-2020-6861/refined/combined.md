=== Content from donjon.ledger.com_964bbf84_20250119_112426.html ===
  [![](/assets/ledgerdonjon_banner.png)](/)  [Bounty](/bounty)   [Security Bulletins](/lsb)   [Threat Model](/threat-model)   [Tools Suite](/tools-suite)   [About](/about)   [Contact](/contact)   [Blog](https://www.ledger.com/blog/category/donjon)
# Ledger Security Bulletin 008

27 April 2020: Monero private key retrieval.

## Summary

The [7th Ledger Security Bulletin](#1) describes a replay vulnerability in the Monero app leading to the retrieval of a private spend key. Another vulnerability leading to the same private key retrieval was found by Dušan Klinec.

The MITRE assigned organization assigned the [CVE-2020-6861](#4) and Dušan Klinec wrote a [blogpost](#2) explaining the technical details of this vulnerability.

## Observations and Notations

During a transaction, some computational elements are encrypted by the Nano with a key only known to the Monero application, and sent to the desktop client for later use, due to space limitations on the Nano. Let $enc(x)$ be the encryption of $x$.

Such elements are associated with an HMAC with a key that is dedicated to the current transaction. Let $henc(x)$ be a pair $(enc(x), hmac(enc(x)))$.

Two specific values `00...00h` and `FF...FFh` are used to respectively identify the view key and the spend key. Those two values are named `C_FAKE_SEC_VIEW_KEY` and `C_FAKE_SEC_SPEND_KEY`.

In the general case, the secret view key $a$ is public and exported from the device upon request to the user. $henc(a)$ and $henc(b)$ are also known, as those are returned by the device when a transaction is started with the `monero_apdu_open_tx` command.

Finally, with the notations:

* $P$: point
* $x$, $y$, $alpha$, $ss$, $c$: scalar
* $a$: scalar, private view key
* $b$: scalar, private spend key
* $l$: scalar, curve order

the subsequent two attacks rely on the following commands:

* `monero_apdu_sc_sub`: $henc(x), henc(y) \rightarrow henc(x-y)$
* `monero_apdu_generate_key_derivation`: $P, henc(x) \rightarrow henc(8x.P)$
* `monero_apdu_derive_secret_key`: $henc(P), index, \text{C\_FAKE\_SEC\_SPEND\_KEY} \rightarrow henc(\text{Keccak}(P \mathbin\Vert index)+b)$
* `monero_apdu_mlsag_sign`: $henc(alpha), henc(x) \rightarrow ss = (alpha - c \* x) \mod l$

## Attack Details

### Method 1

This method consists of first building a full encryption oracle and then use it to retrieve the secret spend key $b$.

#### Step 1: take control of zero

First, `monero_apdu_sc_sub` is called with $henc(x)$ for both arguments and returns:

$\text{monero\_apdu\_sc\_sub}(henc(a), henc(a)) = henc(0)$

A valid pair {$0$, $henc(0)$} can be injected in any command. Having the control of this zero value is important since it allows canceling parts of any other command’s intermediate computation.

#### Step 2: decryption oracle

Controlling the zero value, a decryption oracle can be built using the `monero_apdu_mlsag_sign` command. The command can be called in the following way or any $henc(x)$ to retrieve $x$:

\[\text{monero\_apdu\_mlsag\_sign}(henc(x), henc(0)) = x-c \* 0 = x\]

At this point, a decryption oracle is available.

#### Step 3 : Retrieving the spend key

The final step involves `monero_apdu_derive_secret_key`. Let $fsk$ be the fake spend key `C_FAKE_SEC_SPEND_KEY`:

$\text{monero\_apdu\_derive\_secret\_key}(henc(0), 0, fsk)$

\[= \text{Keccak}(0 \mathbin\Vert 0) + b = hmac(sk)\]

$sk$ being the *spend key*.

So using the decryption oracle from step 2, $sk$ can be decrypted to get:

$b = sk - \text{Keccak}(0 \mathbin\Vert b0)$.

where `b` is the private spend key.

### Method 2

Removing `monero_apdu_sc_sub` (and `monero_apdu_sc_add`) from the protocol prevents the previous attack, but a more complicated one is still possible.

#### Step 1

Let’s assume that the private view key $a$ is already known, meaning that the user has accepted to export it.

Without the need of the device, a scalar $x$ can be found such that:

\(P = (8 x.a).G\) \(= (8x).a.G\) \(= 8x.A\)

and:

* `encoded_P = encode_point(P)`
* `encoded_P = encode_scalar(decode_scalar(P))`

Which means that P can be considered both as a valid input point and a valid scalar with no reduction modulo the order of the curve.

#### Step 2

Deriving the generated point $P$ at step 1:

$\text{monero\_apdu\_generate\_key\_derivation}(P=x.G, henc(a))$

The app computes:

* $a \leftarrow henc(a)$
* $8a.x.G = (8x).a.G = 8x.A$

which equals $P$ by definition above. The output is then $henc(P)$, hence we learn a valid set ${P, enc(P), hmac(P)}$.

#### Step 3

`monero_apdu_derive_secret_key` can be called with the following parameter:

$\text{monero\_apdu\_derive\_secret\_key}(henc(P), 0, henc(b))$

\[sk = \text{Keccak}(P v0) + b = henc(sk)\]
### Step 4 : spend key extraction

Finally, `monero_apdu_mlsag_sign` allows to retrieve the spend key based on the value obtained at step 2 and 3, and by using $P$ as a simple 256 bits scalar:

$\text{monero\_apdu\_mlsag\_sign}(henc(sk), henc(P))$

\[ss = sk-c \* P\]

`P` is considered a simple scalar in the above.

Now, recall that:

\[sk = \text{Keccak}(P \mathbin\Vert 0) + b\]

and `P` is known.

So replacing $sk$ in the previous computation results in:

\[ss = \text{Keccak}(P \mathbin\Vert 0) + b - c \times P\]

and thus:

\(b = ss - \text{Keccak}(P \mathbin\Vert 0) + c \times P\).

So again, the spend key $b$ is retrieved.

## Impact

Those vulnerabilities allow extracting a user’s Monero private spend key through a malicious Monero client. Being a flaw in the protocol between the Nano application and the Monero desktop client, it affects both Nano S and Nano X users.

## Remediation

The vulnerability is fixed from Monero version 1.5.1. The specification update can be found on [GitHub](#3) and the following changes were made:

* The `monero_apdu_secret_sub` has been removed from the application.
* A strict state machine check has been added, to avoid using a command outside of its expected operating context.
* The computation of HMAC was changed to embed a type tag, avoiding type confusion. Some specific HMACS also embed a state machine tag.
* A better user interaction has been set up to request the user to confirm any transaction start.

## Credits

We would like to thank the security researcher Dušan Klinec for the discovery of these vulnerabilities, his high quality report and also for his help.

## References

1. [LSB 7 - Monero private key retrieval](https://donjon.ledger.com/lsb/007)
2. [Ledger Monero App Spend key Extraction](https://deadcode.me/blog/2020/04/25/Ledger-Monero-app-spend-key-extraction.html)
3. [Monero Application Commands](https://github.com/LedgerHQ/ledger-app-monero/blob/master/doc/developer/blue-app-commands.rst)
4. [CVE-2020-6861](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-6861)
  © 2024 Donjon. All rights reserved.

=== Content from deadcode.me_e71e1f89_20250119_112426.html ===

[0xDEADC0DE](/)

[About](/about/)

# CVE-2020-6861: Ledger Monero App Spend key Extraction

Apr 25, 2020

CVE-2020-6861: Due to a bug in the Monero transaction signing protocol in the Ledger Monero app
v1.4.2 we were able to extract master Monero spending key. The vulnerability is now fixed.

[![Monero + Ledger](/static/monero/monero.jpeg)](https://twitter.com/Ledger/status/1068127566752608256?s=20)

## Intro

[Monero](https://www.getmonero.org) is a privacy-centric cryptocurrency protecting the identity of participants and amounts being transacted.
Monero support has been added to [Ledger](https://www.ledger.com), cryptocurrency hardware wallet, in [November 2018](https://twitter.com/Ledger/status/1068127566752608256?s=20).

Sorry, your browser doesn't support embedded videos.

### Monero basics - points and scalars

[Zero to Monero](https://web.getmonero.org/library/Zero-to-Monero-2-0-0.pdf) is an excellent resource describing cryptography used in Monero from scratch.
I recommend going through it if something is not clear in this post.

Monero is based on an elliptic curve [Ed25519](https://eprint.iacr.org/2008/013.pdf).
Public keys are points on the Ed25519 curve \(\mathbb{G}\), denoted as upper-case letters.
Point \(G\) is a known parameter called the *base point*. Points form a finite [cyclic group](https://en.wikipedia.org/wiki/Cyclic_group),
so operations of addition and subtraction are defined over points. Operation over two
points results in another point on the curve. Points are encoded as 32 bytes.

Scalars are integers modulo \(l\), i.e. \(\mathbb{Z}^{\*}\_{l} \), where \(l = 2^{252}\)+27742317777372353535851937790883648493 is a curve order (number of points on the elliptic curve).
Scalars are denoted as lower-case letters. As \(l\) is a prime number, \(\mathbb{Z}^{\*}\_{l}\) is a [finite field](https://en.wikipedia.org/wiki/Finite_field), i.e., there are addition, subtraction, multiplication and division operations defined over the scalars.

Moreover, we have an operation called *scalar multiplication*, \(bP = \overbrace{(P + P + \cdots + P)}^{b} = Q\), where \(b \in \mathbb{Z}^{\*}\_{l}, P \in \mathbb{G}, Q \in \mathbb{G}\).
Scalars also work as private keys, by computing \(bG=B\) we get a public key \(B\).
Scalar multiplication in non-invertible, i.e., computation of \(b\) from \(B\) is not feasible (reduces to solving [discrete logarithm problem](https://en.wikipedia.org/wiki/Discrete_logarithm)). Scalars are encoded as 32 bytes.

### Monero private keys

Monero wallet has a pair of private keys \((k^s, k^v)\) called spending and view key. Spending key is essential for spending owned Monero coins while view key is needed to determine whether transaction on the blockchain is for our account. Monero address contains public spend and view key, \((k^sG, k^vG) = (K^s, K^v)\).

Private keys \((k^s, k^v)\) are protected by hardware wallets in a way they never leave the device. Hardware wallets enables the user to use private keys only in a predefined way, i.e., the user has to confirm destination address and amount to be transacted before the hardware wallet uses keys to sign the transaction.

However, the view key \(k^v\) is often exported from the hardware wallet and stored in the software wallet as it is needed for common read-only Monero operations. The software wallet with the view key can scan incoming transactions, determine whether we received any funds, and decode the value of those funds. This can be done without having the hardware wallet connected. Without exporting the view key, the hardware wallet would have to be connected, and cryptographic operations would have to be computed over each transaction in each block, which would be quite slow.

The view key is derived from the spend key. Thus the spend key \(k^s\) is the main secret we aim to extract from the hardware wallet. Once extracted, the wallet is compromised, the attacker can transact all funds, which is game over.

## Transaction signing

Signing a Monero transaction is more complicated than a Bitcoin transaction, for example.
As hardware wallets (HWs) are resource-limited hardware, they cannot sign the whole transaction at once, and thus some transaction signing protocol has to be used to sign the transaction in a secure way, i.e., without leaking any secrets signing precisely what user confirms.

Ledger application implementing such Monero signing algorithm is <https://github.com/LedgerHQ/ledger-app-monero>. Documentation of the commands provided by the Monero application is [here](https://github.com/LedgerHQ/ledger-app-monero/blob/master/doc/developer/blue-app-commands.pdf).

The Monero wallet then calls given commands in order to sign the transaction.
Ledger’s transaction signing protocol runs low-level, i.e., operations provided by the HW app are usually simple commands. The operation’s input and outputs are protected by AES128-CBC (zero IV) and HMAC.
Encryption key `spk` is derived from the spend key and remains the same for the whole life of the wallet. HMAC key `hk` is random, generated for each transaction. I denote scalars and points as *sealed* if they are encrypted and HMAC protected, i.e., not readable by the attacker.

### Decryption oracle

The Ledger Monero app is implemented in C, but I will show the core ideas in python for brevity.
Take a look at the [`sc_sub`](https://github.com/ph4r05/blue-app-monero/blob/7d6c5f5573c4c83fe74dcbb3fe6591489bae7828/src/monero_key.c#L430) operation that shows how input and outputs are handled:

```
def sc_sub(a: SealedScalar, b: SealedScalar) -> SealedScalar:
  """Input: {a, b} scalars"""
  aa = hmac_and_decrypt(a, spk, hk)
  bb = hmac_and_decrypt(b, spk, hk)
  cc = (aa - bb) % l  # l is the curve order
  c = encrypt_and_hmac(cc, spk, hk)
  return c

```

There are few other operations provided by the HW app. Scalars either as inputs or function outputs are always encrypted, with one exception, the function [`mlsag_sign`](https://github.com/ph4r05/blue-app-monero/blob/7d6c5f5573c4c83fe74dcbb3fe6591489bae7828/src/monero_mlsag.c#L96):

```
def mlsag_sign(alpha: SealedScalar, x: SealedScalar) -> Scalar:
  aa = hmac_and_decrypt(alpha, spk, hk)
  xx = hmac_and_decrypt(x, spk, hk)
  ss = (aa - c * xx) % l  # c is part of the state
  return ss

```

Resulting scalars `ss` are public part of the MLSAG signature in the transaction; thus the output of `mlsag_sign` is not encrypted. Scalar `c` is part of the internal state, which we know (not important now).

Note that if we pass `x=0` to the `mlsag_sign`, we obtain *decrypting oracle* as the function returns a decrypted scalar value of the `alpha`. For that, we need an encrypted version of a zero scalar, which we can obtain by calling `zero = sc_sub(x, x)` for any encrypted scalar value `x`. We can thus decrypt all private values sent over the protocol.

```
def decrypt_oracle(x: SealedScalar) -> Scalar:
  zero = sc_sub(x, x)  # can be reused
  xx = mlsag_sign(alpha=x, x=zero)
  return xx

```

If we could just pass \(k^s\) (sometimes denoted also as `b`) to the `decrypt_oracle` we won. But there are a few more steps required.

### Spend key extraction

There are few operations that enable work with stored spend and view keys. If such operations find
32 B placeholders `C_FAKE_SEC_VIEW_KEY`, `C_FAKE_SEC_SPEND_KEY` in the input, the real values are substituted to the input buffer, so the operation works with the real secret key values. The placeholders are known to the software wallet once transaction signing started, so the signing protocol can work with these secret values. Function taking care of the substitution is: [`monero_io_fetch_decrypt_key`](https://github.com/ph4r05/blue-app-monero/blob/7d6c5f5573c4c83fe74dcbb3fe6591489bae7828/src/monero_io.c#L258). The `mlsag_sign` operation does not support the placeholders, so we need to find another function suitable for the spend key extraction.

Observe the [`derive_secret_key`](https://github.com/ph4r05/blue-app-monero/blob/7d6c5f5573c4c83fe74dcbb3fe6591489bae7828/src/monero_key.c#L574):

```
def derive_secret_key(
    derivation: SealedPoint,
    index: int,
    secret: SealedScalar
  ) -> SealedScalar:

  D = hmac_and_decrypt(derivation)
  s = monero_io_fetch_decrypt_key(secret)  # Placeholder
  r = Hs(D || varint(index)) + s
  res = encrypt_and_hmac(r, spk, hk)
  return res

```

The function computes \(r=\mathcal{H}\_s(D \; || \; \text{index}) + s\), where \(\mathcal{H}\_s: \{0,1\}^\* \rightarrow \mathbb{Z}^{\*}\_{l} \) is a hash function to scalars and `||` is a binary concatenation.

As you noticed, Ledger Monero app makes no difference between point and scalar encryption, thus we can use them interchangeably.
If we know the value of the \(D\) (one known value is the encryption of zero) we also know the value of \(\mathcal{H}\_s(D \; || \; \text{index})\). Thus we can compute \(s = r - \mathcal{H}\_s(D \; || \; \text{index})\).

Spend key extraction is thus:

```
def poc1():
  C_FAKE_SEC_SPEND_KEY = monero_apdu_open_tx()
  x, X = generate_keypair()  # sealed scalar, clear point
  zero = sc_sub(x, x)
  r = derive_secret_key(zero, 0, C_FAKE_SEC_SPEND_KEY)
  rr = mlsag_sign(r, zero)
  b = r - H_s("\x00"*32 + "\x00")
  return b

```

The spend key `b` is extracted from the Monero app with just 5 API calls. No user interaction is needed. Ledger does not change any state or change the display, so the attack is unobservable by a normal user.

The PoC demonstrating the vulnerability is [here](https://github.com/ph4r05/ledger-app-monero-1.42-vuln/blob/3e615bbfe4c4112ddc9e4099a1ba8378f37ab90b/poc.py#L114).

### Requirements

* Connected Ledger, entered PIN, selected Monero app 1.4.2. Commit 7d6c5f5573c4c83fe74dcbb3fe6591489bae7828.
* Usually, when sending a transaction, setting up the Monero wallet.
* If the master view key was not exported, then the scenario happens with each blockchain scanning.

### Impact

* No user confirmation is required to mount the attack.
* The user is not notified about the transaction being in progress. No error is shown. The display does not change.
* The user has no chance to notice his master spend key was extracted.
* The exploitation was possible from the initial
  protocol deployment date. User spend keys could have been silently exfiltrated without users knowing.
  There is no way to tell whether this attack was executed in the wild.
* All existing wallets (spend keys) should thus be considered leaked and not secure to use.
* Ledger Monero app v1.4.2 did not support changing the BIP-44 derivation path for
  Monero master key derivation, thus users were not able to use Ledger to store Monero securely
  if they used it with the Monero before.
  In the newest app version the derivation path can be changed so all users should use derivation paths not affected by this vulnerability.

### Timeline

* *2. Jan 2020*: vulnerability discovery
* *3. Jan 2020*: vulnerability report sent
* *5. Jan 2020*: Response from Ledger, investigation started
* *11. Jan 2020*: Response from Ledger acknowledging the vulnerability, working on fixes
* *16. Jan 2020*: Interactive discussion started, refining countermeasures
* *6. Feb 2020*: Final source code ready
* *2. Mar 2020*: Monero app 1.5.1 released fixing all vulnerabilities found

Ledger reacted promptly, the cooperation was nice and seamless, and I enjoyed the work with them. I was also awarded under the bug bounty program.

---

## Extras

A few interesting PoC improvements and observations follow.

### sc\_sub removal is not enough

The function `sc_sub` is not used by the Monero wallet. Thus one simple countermeasure would be to remove `sc_sub` from the Ledger Monero app. But as we show, it is easy to simulate `sc_sub` with the `sc_add` in the following way.

It holds that \(lx = 0 \; (\text{mod} \; l) \), where l is the curve order. Thus \((l-1)x = -x \; (\text{mod} \; l)\).

We show an algorithm that can be used to generate a sealed version of an arbitrary scalar value \(x\).

1. Call [`monero_apdu_generate_keypair`](https://github.com/ph4r05/blue-app-monero/blob/7d6c5f5573c4c83fe74dcbb3fe6591489bae7828/src/monero_key.c#L479) to obtain sealed scalar \(\widehat{a}\) and public point A.
2. Use decrypt oracle to obtain \(a\), so we have plaintext-ciphertext pair.
3. As value of \(a\) is known, finds its multiplicative inverse \(a^{-1}\).
4. Construct a *base* \(\mathcal{B} = \{ \widehat{2^ia}, i \in [1, 252] \} \) by calling `sc_add`. E.g., \(\text{sc\_add}(\widehat{a}, \widehat{a}) = \widehat{2a}\), \(\text{sc\_add}(\widehat{2a}, \widehat{2a}) = \widehat{4a}\), etc. 251 function calls to sc\_add is needed.
5. Construct set \(\mathcal{I} = \{i \; | \; 2^i \; \% \; xa^{-1} = 0 \}\), i.e., positions where binary representation of \((xa^{-1})\) has ones.
6. Use addition to compute: \(\sum\_{i\in\mathcal{I}} \mathcal{B}\_i = \sum\_{i\in\mathcal{I}} \widehat{2^ia}\)
   = \(\widehat{a(xa^{-1})} = \widehat{x}\)

Thus we obtain an *encrypting oracle*, i.e., we can construct a valid sealed version of a known scalar. The base \(\mathcal{B}\) is independent of the input \(x\) ad thus can be reused.

The algorithm can also be used to obtain encryption of zero or get negative value of a sealed scalar \(\widehat{y}\):

1. Construct a *base* \(\mathcal{B} = \{ \widehat{2^iy}, i \in [1, 252] \} \) by calling `sc_add`. E.g., \(\text{sc\_add}(\widehat{y}, \widehat{y}) = \widehat{2y}\), \(\text{sc\_add}(\widehat{2y}, \widehat{2y}) = \widehat{4y}\), etc. 251 function calls to sc\_add is needed.
2. Construct set \(\mathcal{I} = \{i \; | \; 2^i \; \% \; (l-1) = 0 \}\), i.e., positions where binary representation of \((l-1)\) has ones.
3. Use addition to compute: \(\sum\_{i\in\mathcal{I}} \mathcal{B}\_i = \sum\_{i\in\mathcal{I}} \widehat{2^iy}\) = \(\widehat{y(l-1)} = \widehat{-y}\)

Note that there are 251 (scalar base) + 73 (number of 1s in \(l-1\)) + 1 = 325 sc\_add evaluations needed to get an additive inverse.
Similarly, if \((l-1)\) is substituted by \(l\) we obtain an encryption of zero.

### PoC v2, more general

We wanted to design a more general PoC that would underline the true problem of the protocol that would survive several simple countermeasures such as removal of sc\_add and sc\_sub functions. The primary problem is the reuse of the alpha parameter in the `mlsag_sign` which should be random and never reused.

Here follows the more general [PoC v2](https://github.com/ph4r05/ledger-app-monero-1.42-vuln/blob/3e615bbfe4c4112ddc9e4099a1ba8378f37ab90b/poc.py#L205), which is described later.

1. Get \(A\) (public view key) from the Ledger or the wallet address (doable off-line).
2. Find a scalar \(x\), while the following holds:
   * \(Pb = \text{encode\_point}(8xaG)\), where \(P = 8xaG = 8xA\)
   * \(Pb = \text{encode\_scalar}(\text{decode\_scalar}(Pb))\)
   * i.e., the encoding \(Pb\) of the point \(P\) can be interpreted both as an EC point \(P\) and
     as a scalar \(p\) (without modular reduction required)
   * This is performed offline, in the PoC, card interaction is not required as we have \(A\)
3. Call [`monero_apdu_generate_key_derivation`](https://github.com/ph4r05/blue-app-monero/blob/7d6c5f5573c4c83fe74dcbb3fe6591489bae7828/src/monero_key.c#L510)\((xG, \text{C\_FAKE\_SEC\_VIEW\_KEY})\) to obtain \(\widehat{8a(xG)} = \widehat{P}\). We thus know plaintext-ciphertext pair for a known point \(P\).
4. Call [`monero_apdu_derive_secret_key`](https://github.com/ph4r05/blue-app-monero/blob/7d6c5f5573c4c83fe74dcbb3fe6591489bae7828/src/monero_key.c#L574)\((\widehat{P}, 0, \text{C\_FAKE\_SEC\_SPEND\_KEY})\) to get \(\widehat{s} = \widehat{\mathcal{H}\_s(P||0) + b}\), where \(b\) is the spend key.
5. Call [`mlsag_hash(p2=1, opt=0x80)`](https://github.com/ph4r05/blue-app-monero/blob/7d6c5f5573c4c83fe74dcbb3fe6591489bae7828/src/monero_mlsag.c#L72), which returns \(c\) as plaintext scalar.
6. Call [`mlsag_sign`](https://github.com/ph4r05/blue-app-monero/blob/7d6c5f5573c4c83fe74dcbb3fe6591489bae7828/src/monero_mlsag.c#L96)\((\widehat{s}, \widehat{p})\)
   * We obtain \(r = s - cp = (\mathcal{H}\_s(P||0) + b) - c\*(8xaG)\_{\text{scalar}}\)
   * Note the \(p\) is now decoded as a scalar value, thus \(p=(8xaG)\_{\text{scalar}}\) is scalar value obtained by decoding the serialized EC point \((8xaG)\) as scalar. We know the cleartext value of \(p\) from construction.
   * Compute the master spending key \(b\) as \(b = r - \mathcal{H}\_s(P||0) + cp\)
   * We can compute \(\mathcal{H}\_s(P||0)\) as \(P\) plaintext value is known.

### Notes

As encryption of scalars and points are the same, we can use this *type confusion* to find a value that can be interpreted in both ways, i.e., a valid EC point and a valid Ed25519 scalar. This is useful to construct a derivation, which is basically ECDH derivation, which goes encrypted to the `monero_apdu_derive_secret_key`. Note there is only function `monero_apdu_generate_key_derivation` that returns encrypted EC points.
The same value of P is in step 6 used as a known scalar to obtain decrypting oracle.

According to the [numerical simulation](https://github.com/ph4r05/ledger-app-monero-1.42-vuln/blob/master/poc_sim.py), the \(E[\text{steps\_finding\_x}(A)] = 15\), i.e.,
on average in 15 steps we find suitable \(x\) value. Which corresponds to a fact that EC points are distributed more/less equally on the 32 bytes (256 bits). The scalars occupy 252 bits which gives \(2^{256-252}=16\).

The attack uses only a small set of functions, all function calls besides the last one `mlsag_sign()`
are legit and could appear in the normal transaction construction process. It is thus hard to prevent
this from working. Used functions:

* reset
* set\_mode
* open\_tx
* gen\_derivation
* derive\_secret\_key
* mlsag\_hash
* mlsag\_sign

## Observations

* Scalars / points can be used interchangeably in the protocol. This *type confusion*
  is a significant vulnerability. Especially when the attacker manages to obtain known
  plaintext-ciphertext pair, which can then later be used in both contexts (scalar, point).
  Knowing the plaintext value is important for the computation of `Hs(P||0)` and `c*P` elimination.
* When the view key is extracted (for faster blockchain scanning), the leak of a plaintext-ciphertext
  pair cannot be prevented for scalars, as the attacker knows `a` and can use `C_FAKE_SEC_VIEW_KEY` to make
  Ledger compute scalars with `a`. E.g., `monero_apdu_derive_secret_key(P, 0, C_FAKE_SEC_VIEW_KEY)` can be
  used to construct scalar plaintext-ciphertext pair.
* `mlsag_sign` is important for all attacks as it returns an unencrypted scalar value from
  originally encrypted scalar inputs. It is used as a decryption oracle.

## Countermeasures

To make the protocol secure against the mentioned family of attacks the aforementioned
weak spots have to be eliminated.

### Remove simple scalar functions

As correctly proposed by the Ledger, removing `sc_sub()` and `sc_add()` helps significantly.
As demonstrated in the previous report, the attacker can construct many usable scalar values that
can be later used in the attack.

### User confirmation / notification

* As the HMAC key is changed with each new transaction, the user should be explicitly asked to confirm the transaction signing process once `open_tx()` is called in the real transaction mode. I.e., Ledger should ask the user whether he wants to continue
  with the transaction signature. The user confirms by pressing a button.
* User confirmation is required to mount any attack. Attack surface is thus reduced
  to the point when the user is actively sending a new transaction, the time window is
  significantly reduced.
* Ledger should display information on the display when `open_tx` was called, even for fake
  transactions (used during the transaction assembly process, can be called several times before a real transaction that meets the requirements is assembled). Any display change would be nice, so the user is able to notice that Ledger is
  performing some tasks.
* When the transaction is finished with error (e.g., some security assertion fails), the user should be notified on the screen and optionally asked for confirmation to continue in normal operation. The attacker thus cannot just flash the error message over a short period of time
  without the user noticing.
* Some other attacks we considered require more transaction openings so limiting it
  by requiring the confirmation lowers the attack surface significantly.

### Proper input validation

* If any assertion fails (non-reduced scalar, EC point not lying on the curve), abort the transaction, reset keys, notify the user and ask for confirmation to continue.
* Stronger requirement: if the assertion fails, ask for PIN re-entry.

### Symmetric key hierarchy

This is the primary countermeasure that blocks all attacks we considered.
For the sake of simplicity, we will assume just HMAC keys for now and address `spk` key later.

* The HMAC key `hk` is changed with each new transaction (as now)
* HMAC key used for particular parameters is derived from `hk` based on the following
  + Value type, scalar or point
  + Content-type, derived secret or random scalar mask
  + Function calling context. e.g., alpha in mlsag\_sign.
* Encrypted values are thus usable only in a particular context, i.e., the context with the same HMAC key.
* This also prevents the *type confusion*.

Example:

* `H(hk || "0")` HMAC key for EC points - derivation
* `H(hk || "1")` HMAC key for scalars
* `H(hk || "2")` HMAC key for random scalar masks alpha
* `H(hk || "3")` HMAC key for amount key

Other EC points than derivations are not exported in an encrypted form in the protocol. If there are more EC point types later, differentiate them.

Ideally, the encryption key should also be changed with each new transaction (random), if possible.
Definitely, for values we are sure were produced after `open_tx()`. Thorough protocol analysis
or just simple testing will reveal which values need to have fixed `spk` key.
We would suggest to start testing this improvement with the encryption key `spk` being randomly generated after `open_tx()`.
After transaction finish/abort the key is reverted back to static `spk`.

Different encryption key strictly limits attacker to the scope of one transaction with respect to the data confidentiality, which is useful for security arguments. I.e., no long-term analysis
and data collection can be performed.

The specified HMAC key hierarchy is also usable for encryption, which decreases the attack surface significantly as values are valid only in a particular context. This is especially important as the initialization vector (IV) is zero = encryption has no semantic security, i.e., the same plaintexts encrypt
to the same ciphertexts. The zero IV allows the attacker to test values for equality without knowing the plaintext values.

The key hierarchy significantly restricts the potential combinations attacker can use,
restricting to explicitly allowing ones by the protocol designer.

## MLSAG Sign

Recall \(\text{mlsag\_sign}(\alpha, x) = \alpha - cx\), where:

* \(c\) is parameter known to attacker
* \(\alpha\) is a random scalar
* \(x\) is a secret scalar value

Notice that if \(\alpha\) is allowed to be used more than once, we have a decryption oracle:

* \(\text{mlsag\_sign}(\alpha\_1, x\_1) = r\_1\)
* \(\text{mlsag\_sign}(\alpha\_1, x\_2) = r\_2\)
* \(r\_1 - r\_2 = (\alpha\_1 - cx\_1) - (\alpha\_1 - cx\_2) = \alpha\_1 - cx\_1 - \alpha\_1 + cx\_2 = c(x\_2-x\_1)\)
* As \(c\) is known, attacker can recover \(x\_2-x\_1\). If attacker knows a plaintext value for one scalar secret,
  let say \(x\_1\) he can recover scalar value for \(x\_2\).
* \(x\_1\) can be constructed by calling \(\text{monero\_apdu\_derive\_secret\_key}(P, 0, a)\) as we usually know \(a\) as it was exported to the client and we know the value of \(P\).
* Similarly, if \(x\_1\) is known, then \(\alpha\_1 = r\_1 - cx\_1\).
* We do not consider type confusion and other attacks as those are eliminated by key hierarchy.

Monero currently uses only the `MLSAG_SIMPLE` signature scheme. The `MLSAG_FULL` is not needed with Bulletproof transactions, and thus, Ledger does not have to support it. This reduces the attack surface and simplifies countermeasures design.
Thus it holds that `mlsag_prepare()` is called only once per signature (for non-multisig transaction),
followed by exactly one `mlsag_sign()` call (it holds dsRows==1).

We propose to extend the state by adding a `sign_counter`, which is incremented in the beginning
of the `mlsag_prepare()` call and after the `mlsag_sign()`.
The encryption and HMAC keys for \(\alpha\) are then derived as:
\(\mathcal{H}(hk || \text{“alpha”} || \text{sign\_counter})\).

This guarantees that only \(\alpha\) generated by the `mlsag_prepare()` can be passed to the `mlsag_sign()`
as the first \(\alpha\) parameter. Separation of \(\alpha\) and \(x\) domains via different keys restricts the
attack surface.

It is easy to show that if \(\alpha\) is a random scalar, then the attacker can derive no information about \(x\_1\)
from \(\alpha - cx\_1\). The reason is that \(\alpha\) can be generated only in `mlsag_prepare()` and
used only in `mlsag_sign()` as a first parameter, nowhere else.
It is essential that \(\alpha\) can be used only once as input to the `mlsag_sign()`.
Otherwise, the attacker can eliminate it.

Thus the attacker can derive no information about \(\alpha\) using other functions than `mlsag_sign()` as it fails
HMAC check in those. The attacker could learn \(\alpha\) if he knows decryption of \(x\_1\), but such \(\alpha\) is just a random scalar, and this knowledge cannot be reused in another `mlsag_sign()` call, making the knowledge useless.

### Strict state model checking

Due to the low-level nature of the API functions, it is difficult to capture the
explicit state model as the function call flow highly depends on the transaction being signed,
i.e., a number of inputs, outputs, use of sub-addresses, UTXO (unspent transaction outputs) types - aux keys used, etc…

However, the more the state model is restricted, the smaller is the attacker space.
It is recommended to study the valid transaction construction paths and enforce obvious state transitions.

For instance, enforce a rule that the `mlsag_prepare()` has to be followed exactly by the `mlsag_hash()`
(several times, depends on mixin, not critical to enforce number of the `mlsag_hash()` calls).
Enforce that the `mlsag_sign()` can be called only after the `mlsag_hash()` and only once per `mlsag_prepare()`.
Ideally if the `mlsag_sign()` increments the `sign_counter` as well after it computes the `ss` result,
to enforce state change, which prevents malicious state transitions.

Client change:
Commit to the {mixin, number of UTXO, number of transaction outputs} in the initial `open_tx()` call.
Then enforce the rule that a number of calls to the `mlsag_prepare()` and `mlsag_sign()` has to be equal to the number of `UTXO` (as we have one signature per UTXO).

Note the basic state model enforcement can be done without changing the client.
However, a more precise check requires to commit to the number of transaction inputs.

### Conclusion

All aforementioned fixes are directly applicable on the Ledger side without the need to touch the Monero codebase.
The mentioned changes fix the whole family of attacks similar to those presented and effectively blocks the main attack vectors and leaks.

It is thus possible to fix the critical vulnerability without need to release a new Monero client version,
which significantly speeds up the patch roll-out.

## Client-changing countermeasures

Here follow the measures that require client modifications to work.
They improve security significantly but are not necessary to block the vulnerability.

### Encrypt-then-reveal

We propose not to return plaintext values from `mlsag_sign()` directly, but to return encrypted versions,
under a new, transaction-specific encryption key `kse`, which is used specifically for this purpose.

After the transaction is successfully constructed, i.e., no security assertion was violated, the Ledger
returns the `kse` to the host client so it can decrypt the MLSAG signature.

This countermeasure strictly enforces correct state transitions and blocks the attacker’s reactivity.
I.e., the attacker cannot use results from the previous `mlsag_sign()` calls to adapt an attacking strategy
as he learns the result only after the protocol finishes successfully. This property is important for security proofs and to strictly guard the potential attacker space.

This change is very easy to implement and brings significant security benefits.
However, it requires a minor client code change.

We recommend using this measure with a new Ledger Monero protocol version.
After some time (all users migrate to new Monero clients enforcing new signing protocol), the support
for unencrypted `mlsag_sign()` can be dropped.

### Support multiple BIP derivation paths

Allow user to specify BIP derivation path (or its part) when creating the wallet from the Ledger
device to allow multiple cryptographically separated master (view, spend) keys derived from the seed.

Ledger Monero app Version 1.4.2 has a fixed derivation path, which blocks the user from using a new set of keys with the same device seed.

For example, each user should consider current master keys leaked and dangerous to use.
He cannot then use Ledger device without seed reset, which affects all other apps on the
Ledger, i.e., the Bitcoin app.

With the fixed path user also cannot transfer all funds to another safe address without using
software wallet (risk of spend key leak) or another Ledger device.

If the user can specify another path, the migration to a safe (non-leaked) account is simple.
The user creates another wallet with a different path and sweeps the old account to the new one.

### Strict state model checking

As mentioned in the similarly named section above, the more precise checking can be done if
the `open_tx()` transaction message contains information about mixin, number of UTXOs, and transaction outputs.

## Summary

Ledger implemented suggested countermeasures. Follow their site for more details.

Resources recap:

* PoC repository <https://github.com/ph4r05/ledger-app-monero-1.42-vuln>
* Affected Ledger Monero app version <https://github.com/LedgerHQ/ledger-app-monero/tree/7d6c5f5573c4c83fe74dcbb3fe6591489bae7828>
* Protocol documentation: <https://github.com/LedgerHQ/ledger-app-monero/blob/master/doc/developer/blue-app-commands.pdf>
* Affected Monero app version with fixes enabling the build on Ledger Nano S with 1.6.0 firmware <https://github.com/ph4r05/blue-app-monero/>

We’ve designed and implemented another Monero transaction signing scheme for Trezor hardware wallet. More on the topic:

* Our eprint paper <https://eprint.iacr.org/2020/281> in an extended version describing transaction signing protocol plus multi-party evaluation of Bulletproofs
* Transaction signing implemented in the [Trezor firmware](https://github.com/trezor/trezor-firmware/tree/master/core/src/apps/monero)
* Python implementation and various tools: <https://github.com/ph4r05/monero-agent>

## 0xDEADC0DE

* 0xDEADC0DE
* [[email protected]](/cdn-cgi/l/email-protection#7c051310130f191f5208191d113c1b111d1510521f1311)

* [yolosec](https://github.com/yolosec)
* [TeamYolosec](https://twitter.com/TeamYolosec)

Deadcode security blog. Authors: Dusan Klinec (ph4r05), Miroslav Svitok (Miroc).

Deadcode security blog.
Authors:
[Dusan Klinec (ph4r05)](https://ph4r05.deadcode.me),
Miroslav Svitok (Miroc).
[About](/about)



=== Content from github.com_2a9f8db1_20250119_131711.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FLedgerHQ%2Fapp-monero%2Fblob%2Fmaster%2Fdoc%2Fdeveloper%2Fblue-app-commands.rst)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FLedgerHQ%2Fapp-monero%2Fblob%2Fmaster%2Fdoc%2Fdeveloper%2Fblue-app-commands.rst)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=LedgerHQ%2Fapp-monero)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[LedgerHQ](/LedgerHQ)
/
**[app-monero](/LedgerHQ/app-monero)**
Public

* [Notifications](/login?return_to=%2FLedgerHQ%2Fapp-monero) You must be signed in to change notification settings
* [Fork
  104](/login?return_to=%2FLedgerHQ%2Fapp-monero)
* [Star
   278](/login?return_to=%2FLedgerHQ%2Fapp-monero)

* [Code](/LedgerHQ/app-monero/tree/master)
* [Issues
  13](/LedgerHQ/app-monero/issues)
* [Pull requests
  1](/LedgerHQ/app-monero/pulls)
* [Actions](/LedgerHQ/app-monero/actions)
* [Projects
  0](/LedgerHQ/app-monero/projects)
* [Security](/LedgerHQ/app-monero/security)
* [Insights](/LedgerHQ/app-monero/pulse)

Additional navigation options

* [Code](/LedgerHQ/app-monero/tree/master)
* [Issues](/LedgerHQ/app-monero/issues)
* [Pull requests](/LedgerHQ/app-monero/pulls)
* [Actions](/LedgerHQ/app-monero/actions)
* [Projects](/LedgerHQ/app-monero/projects)
* [Security](/LedgerHQ/app-monero/security)
* [Insights](/LedgerHQ/app-monero/pulse)

## Files

 master
## Breadcrumbs

1. [app-monero](/LedgerHQ/app-monero/tree/master)
2. /[doc](/LedgerHQ/app-monero/tree/master/doc)
3. /[developer](/LedgerHQ/app-monero/tree/master/doc/developer)
/
# blue-app-commands.rst

Copy path Blame  Blame
## Latest commit

## History

[History](/LedgerHQ/app-monero/commits/master/doc/developer/blue-app-commands.rst)2546 lines (1822 loc) · 90.8 KB master
## Breadcrumbs

1. [app-monero](/LedgerHQ/app-monero/tree/master)
2. /[doc](/LedgerHQ/app-monero/tree/master/doc)
3. /[developer](/LedgerHQ/app-monero/tree/master/doc/developer)
/
# blue-app-commands.rst

Top
## File metadata and controls

* Preview
* Code
* Blame

2546 lines (1822 loc) · 90.8 KB[Raw](https://github.com/LedgerHQ/app-monero/raw/refs/heads/master/doc/developer/blue-app-commands.rst)

\pagebreak

\pagebreak

## License

Author: Cédric Mesnil <cslashm@gmail.com>

License:

> Copyright 2017-2019 Cédric Mesnil <cslashm@gmail.com>, Ledger SAS
>
>
> Licensed under the Apache License, Version 2.0 (the "License");
> you may not use this file except in compliance with the License.
> You may obtain a copy of the License at
>
>
> <http://www.apache.org/licenses/LICENSE-2.0>
>
>
>
> Unless required by applicable law or agreed to in writing, software
> distributed under the License is distributed on an "AS IS" BASIS,
> WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
> See the License for the specific language governing permissions and
> limitations under the License.

\pagebreak

## Introduction

We want to enforce key protection, transaction confidentiality and transaction integrity against
potential malware on the Host. To achieve that we propose to use a Ledger Nano S/X as a 2nd
factor trusted device. Such a device has small amount of memory and is not capable of holding the entire transaction or building the required proofs in RAM. So we need to split the process between the
host and the NanoS. This draft note explain how.

To summarize, the signature process is:

> . Generate a TX key pair (\mathit{r, R})
>
> . Process Stealth Payment ID
>
> . For each input \mathit{T\_{in}} to spend:
>
> > * Compute the input public derivation data \mathfrak{D}\_\mathrm{in}
> > * Compute the spend key (\mathit{x\_{in}, P\_{in}}) from \mathit{R\_{in}} and \mathit{b}
> > * Compute the key image \mathit{I\_{in}} of \mathit{x\_{in}}
>
> . For each output \mathit{T\_{out}} :
>
> > * Compute the output secret derivation data \mathfrak{D}\_\mathrm{out}
> > * Compute the output public key \mathit{P\_{out}}
>
> . For each output \mathit{T\_{out}} :
>
> > * compute the range proof
> > * blind the amount
> > * compute the view tag
>
> . Compute the final confidential ring signature
>
> . Return TX

\pagebreak

## Notation

Elliptic curve points, such as pubic keys, are written in italic upper case,
and scalars, such as private keys, are written in italic lower case:

> * \mathit{spk} : protection key
> * (\mathit{r, R}) : transaction key pair
> * (\mathit{a, A}) (\mathit{b, B}) : sender main view/spend key pair
> * (\mathit{c, C}) (\mathit{d, D}) : sender sub view/spend key pair
> * \mathit{A\_{out}} \mathit{B\_{out}} : receiver main view/spend public keys
> * \mathit{C\_{out}} \mathit{D\_{out}} : receiver sub view/spend public key
> * \mathit{H} : 2nd group generator, such \mathit{H = h.G} and \mathit{h} is unknown
> * \mathcal{\mathrm{amount}} : amount to send/spend
> * \mathcal{\mathrm{mask}} : secret amount mask factor
> * \mathit{C\_v} : commitment to a with v such \mathit{C\_v = k.G + v.H}
> * \mathit{\alpha\_{in}} : secret co-signing key for ith input
> * \mathit{x\_{in}} : secret signing key for ith input
> * \mathit{P\_{in}} : public key of ith input
> * \mathit{P\_{out}} : public key of ith output
> * \mathfrak{D}\_\mathrm{out} \mathfrak{D}\_\mathrm{in} : first level derivation data

Hash and encryption function:

> * \mathtt{AES} : [k](m) AES encryption of *m* with key *k*
> * \mathtt{AES^{-1}} : [k](c) AES decryption of *c* with key *k*

Others:

> * \mathit{PayID} : Stealth payment ID
> * \mathtt{ENC\\_PAYMENT\\_ID\\_TAIL} : 0x82

\pagebreak

## Commands overview

### Introduction

Hereafter are the code integration and application specification.

The commands are divided in three sets:

> * Provisioning
> * Low level crypto command
> * High level transaction command
>
> The low level set is a direct mapping of some crypto Monero function. For such command
> the Monero function will be referenced.
>
> The high level set encompasses functions that handle the confidential/sensitive part of
> full transaction

### Common command format

All command follow the generic ISO7816 command format, with the following meaning:

| byte | length | description |
| --- | --- | --- |
| CLA | 01 | Protocol version |
| INS | 01 | Command |
| P1 | 01 | Sub command |
| P2 | 01 | Command/Sub command counter |
| LC | 01 | byte length of data |
| data | 01  var | options  additional data |

When a command/sub-command can be sent repeatedly, the counter must be increased
by one at each command. The flag `last sub command indicator` must be set
to indicate another command will be sent.

*Common option encoding*

| `x--------`  `1--------`  `0--------` | Last sub command indicator  More identical subcommand forthcoming  Last sub command |
| --- | --- |

\pagebreak

## Provisioning And Key Management

### Overview

There is no provisioning in a standard setup. Both
key pairs (\mathit{a, A}) and (\mathit{b, B}) should be derived under BIP44 path.

The general BIP44 path is :

> `/ purpose' / coin_type' / account' / change / address_index`

and is defined as follow for any Monero main address:

> `` /44'/128'/account'/0/0``

so in hexa:

> `/0x8000002C/0x80000080/0x8......./0x00000000/0x00000000`

The *address\_index* is set to *0* for the main address and will be used as
sub-address index according to kenshi84 fork.

In case an already existing key needs to be transferred, an optional dedicated
command may be provided. As there is no secure messaging for now, this
transfer shall be done from a trusted Host.
Moreover, as provisioning is not handled by Monero client, a separate tool must
be provided.

### Commands

#### Reset

**Description**

Restart the application and check client/application versions compatibility.

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 02 | 00 | 00 | ll |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| var | string version, without trailing null byte |

**Response data**

| Length | Value |
| --- | --- |
| 01 | Application major version |
| 01 | Application minor version |
| 01 | Application micro version |

#### Put keys

**Description**

Put sender key pairs.

This command allows to set specific key on the device and should only be used for testing purpose.

The application shall:

> check \mathit{A} == \mathit{a}.|G|
> check \mathit{B} == \mathit{b}.|G|
> store \mathit{a}, \mathit{A}, \mathit{b}, \mathit{B}

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 22 | 00 | 00 | e0 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 20 | \mathit{a} |
| 20 | \mathit{A} |
| 20 | \mathit{b} |
| 20 | \mathit{B} |
| 5f | Base58 encoded public key |

**Response data**

| Length | Value |
| --- | --- |
|  |  |

#### Get Public Key

**Description**

Retrieves public base58 encoded public key.

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 20 | 01 | 00 | 01 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |

**Response data**

| Length | Value |
| --- | --- |
| 20 | "A" view public key |
| 20 | "B" view spend key |
| 5f | Base58 encoded public key |

#### Get Private View Keys

**Description**

Retrieves the private view key in order to accelerate the blockchain scan.

The device should ask the user to accept or reject this export. If rejected
the client will use the device for scanning the blockchain.

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 20 | 02 | 00 | 01 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |

**Response data**

| Length | Value |
| --- | --- |
| 20 | "a" secret view key |

#### Display Address

**Monero**

**Description**

Display requested main address, sub address or integrated address.

> compute \mathit{x} = [|dec|[|spk|](#id28)](\widetilde{\mathit{x}})

if payment ID is provided:

> compute \mathit{xP} = \mathit{x}.|G|
> check \mathit{xP} == \mathit{P}

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 21 | xx | 00 | 11 |

if P1 is '00' display non-integrated address.

if P1 is '01' display integrated address.

Any other value will be rejected.

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 08 | index (Major.minor) \mathit{index} |
| 08 | Payment ID, (or '0000000000000000') |

**Response data**

| Length | Value |
| --- | --- |
|  |  |

\pagebreak

## Low level crypto commands

### Overview

This section describe lowlevel commands that can be used in a transaction or not.

### Commands

#### Verify Keys

**Monero**

device\_default::verify\_keys.

**Description**

Verify that the provided private key and public key match.

> compute \mathit{x} = [|dec|[|spk|](#id30)](\widetilde{\mathit{x}})
> compute \mathit{xP} = \mathit{x}.|G|
> check \mathit{xP} == \mathit{P}

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 26 | xx | 00 | 41 |

if P1 is '00' the provided public key will be used.

if P1 is '01' the public view is key will be used and the provided private key will
be 'ignored'

if P1 is '02' the public spend is key will be used and the provided private key will
be 'ignored'

Any other value will be rejected.

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 20 | secret key \widetilde{\mathit{x}} |
| 20 | public key or '00'\*32 \mathit{P} |

**Response data**

| Length | Value |
| --- | --- |
|  |  |

#### Get ChaCha8 PreKey

**Monero**

**Description**

> compute \mathit{s} = [|H|(|a|](#id32) | \mathit{B} | \mathtt{ENC\\_PAYMENT\\_ID\\_TAIL})

return the full internal state (200 bytes) of Keccak.

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 24 | 00 | 00 | 00 |

**Command data**

| Length | Value |
| --- | --- |
|  |  |

**Response data**

| Length | Value |
| --- | --- |
| C8 | ChaCha8 prekey |

#### Generate Key Derivation

**Monero**

crypto::generate\_key\_derivation.

**Description**

Compute the secret key derivation and return it encrypted.

> compute \mathit{x} = [|dec|[|spk|](#id34)](\widetilde{\mathit{x}})
> compute \mathfrak{D}\_\mathrm{in} = [|keyDrv|(|x|](#id36),|P|)
> compute \widetilde{\mathfrak{D}\_\mathrm{in}} = [|enc|[|spk|](#id38)](\mathfrak{D}\_\mathrm{in})

return \widetilde{\mathfrak{D}\_\mathrm{in}}.

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 32 | 00 | 00 | 41 or 61 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 20 | public key \mathit{P} |
| 20 | secret key \widetilde{\mathit{x}} |
| 20 | ephemeral hmac (optional, only during active transaction) |

**Response data**

| Length | Value |
| --- | --- |
| 20 | encrypted key derivation \widetilde{\mathfrak{D}\_\mathrm{in}} |
| 20 | ephemeral hmac (optional, only during active transaction) |

#### Derivation To Scalar

**Monero**

crypto::derivation\_to\_scalar.

**Description**

Transform a secret derivation data to a secret scalar according to its index.

> compute \mathfrak{D}\_\mathrm{in} = [|dec|[|spk|](#id40)](\widetilde{\mathfrak{D}\_\mathrm{in}})
> compute \mathit{s} = [|Hps|(|Drv|](#id42), \mathit{index})
> compute \widetilde{\mathit{s}} = [|enc|[|spk|](#id44)](\mathit{s})

return \widetilde{\mathit{s}}.

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 34 | 00 | 00 | 25 or 45 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 20 | encrypted key derivation \widetilde{\mathfrak{D}\_\mathrm{in}} |
| 20 | ephemeral hmac (optional, only during active transaction) |
| 04 | index |

**Response data**

| Length | Value |
| --- | --- |
| 20 | encrypted scalar \widetilde{\mathit{s}} |
| 20 | ephemeral hmac (optional, only during active transaction) |

#### Derive Public Key

**Monero**

crypto::derive\_public\_key.

**Description**

Compute a new public key from some secret derivation data, a parent public key and its index.

> compute \widetilde{\mathfrak{D}\_\mathrm{in}} = [|dec|[|spk|](#id46)](\widetilde{\mathfrak{D}\_\mathrm{in}})

derivation\_to\_scalar:

> compute \mathit{s} = [|Hps|(|Drv|](#id48), \mathit{index})

then:

> compute \mathit{P}' = [|P|+|s|](#id50).|G|

return \mathit{P}'.

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 36 | 00 | 00 | 25 or 45 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 20 | encrypted key derivation \widetilde{\mathfrak{D}\_\mathrm{in}} |
| 20 | ephemeral hmac (optional, only during active transaction) |
| 04 | index |
| 20 | public key \mathit{P} |

**Response data**

| Length | Value |
| --- | --- |
| 20 | public key \mathit{P}' |

#### Derive Secret Key

**Monero**

crypto::derive\_secret\_key.

**Description**

Compute a new secret key from some secret derivation data, a parent secret key and its index.

> compute \widetilde{\mathfrak{D}\_\mathrm{in}} = [|dec|[|spk|](#id52)](\widetilde{\mathfrak{D}\_\mathrm{in}})
> compute \mathit{x} = [|dec|[|spk|](#id54)](\widetilde{\mathit{x}})

derivation\_to\_scalar:

> compute \mathit{s} = [|Hps|(|Drv|](#id56), \mathit{index})

then:

> compute \mathit{x}' = ([|x|+|s|](#id58)) % \mathtt{\#n}
> compute \widetilde{\mathit{x}}' = [|enc|[|spk|](#id60)](\mathit{x})

return \widetilde{\mathit{x}}.

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 38 | 00 | 00 | 65 or 85 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 20 | encrypted key derivation \widetilde{\mathfrak{D}\_\mathrm{in}} |
| 20 | ephemeral hmac (optional, only during active transaction) |
| 04 | index |
| 20 | encrypted secret key \widetilde{\mathit{x}} |
| 20 | ephemeral hmac (optional, only during active transaction) |

**Response data**

| Length | Value |
| --- | --- |
| 20 | encrypted derived secret key \widetilde{\mathit{x}}' |
| 20 | ephemeral hmac (optional, only during active transaction) |

#### Derive Subaddress Public Key

**Monero**

crypto\_ops::derive\_subaddress\_public\_key.

**Description**

> compute \widetilde{\mathfrak{D}\_\mathrm{in}} = [|dec|[|spk|](#id62)](\widetilde{\mathfrak{D}\_\mathrm{in}})
> compute \mathit{s} = [|Hps|(|Drv|](#id64), \mathit{index})
> compute \mathit{P}' = \mathit{P} - \mathit{s}.|G|

return \mathit{P}'

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 46 | 00 | 00 | 45 or 65 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 20 | public key \mathit{P} |
| 20 | encrypted derivation key \widetilde{\mathfrak{D}\_\mathrm{in}} |
| 20 | ephemeral hmac (optional, only during active transaction) |
| 04 | index \mathit{index} |

**Response data**

| Length | Value |
| --- | --- |
| 20 | sub public key \mathit{P}' |

#### Get Subaddress Spend Public Key

**Monero**

device\_default::get\_subaddress\_spend\_public\_key.

**Description**

get\_subaddress\_secret\_key:

> compute \mathit{s} = [|H|("SubAddr" \| |a|](#id66) | \mathit{index} )
> compute \mathit{x} = \mathit{s} % \mathtt{\#n}

then:

> compute \mathit{D = \mathit{B} + \mathit{x}.|G|

return \mathit{D

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 4A | 00 | 00 | 09 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 08 | index (Major.minor) \mathit{index} |

**Response data**

| Length | Value |
| --- | --- |
| 20 | sub spend public key \mathit{D |

#### Get Subaddress Secret Key

**Monero**

> get\_subaddress\_secret\_key

**Description**

> compute \mathit{x} = [|dec|[|spk|](#id68)](\widetilde{\mathit{x}})
> compute \mathit{s} = [|H|("SubAddr" \| |x|](#id70) | \mathit{index} )
> compute \mathit{d} = \mathit{s} % \mathtt{\#n}
> compute \widetilde{\mathit{d\_{i}}} = [|dec|[|spk|](#id72)](\mathit{d})

return \widetilde{\mathit{d\_{i}}}

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 4C | 00 | 00 | 39 or 59 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 20 | secret key \widetilde{\mathit{x}} |
| 20 | ephemeral hmac (optional, only during active transaction) |
| 08 | index (Major.minor) \mathit{index} |

**Response data**

| Length | Value |
| --- | --- |
| 20 | sub secret key \widetilde{\mathit{d\_{i}}} |
| 20 | ephemeral hmac (optional, only during active transaction) |

#### Get Subaddress

**Monero**

device\_default::get\_subaddress\_secret\_key.

**Description**

> compute \mathit{s} = [|H|("SubAddr" \| |a|](#id74) | \mathit{index} )
> compute \mathit{x} = \mathit{s} % \mathtt{\#n}

then:

> compute \mathit{D = \mathit{B} + \mathit{x}.|G|
> compute \mathit{C} = \mathit{A}.|D|

return \mathit{C}, \mathit{D

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 48 | 00 | 00 | 09 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 08 | index (Major.minor) \mathit{index} |

**Response data**

#### Generate Key Image

**Monero**

crypto::generate\_key\_image.

**Description**

Compute the key image of a key pair.

> compute \mathit{x} = [|dec|[|spk|](#id76)](\widetilde{\mathit{x}})
> compute \mathit{P}' = [|Hp|(|P|](#id78))
> compute \mathit{Img(P)} = \mathit{x}.|P|'

return \mathit{Img(P)}.

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 3A | 00 | 00 | 41 or 61 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 20 | public key \mathit{P} |
| 20 | secret key \widetilde{\mathit{x}} |
| 20 | ephemeral hmac (optional, only during active transaction) |

**Response data**

| Length | Value |
| --- | --- |
| 20 | key image \mathit{Img(P)} |

#### Derive View Tag

**Monero**

crypto::derive\_view\_tag.

**Description**

Derive the view tag of an output.

> compute \mathfrak{D}\_\mathrm{in} = [|dec|[|spk|](#id80)](\widetilde{\mathfrak{D}\_\mathrm{in}})
> compute \mathit{view\\_tag\\_full} = [|Hs|("view\_tag" \|, |Drv|](#id82), \mathit{index})
> compute \mathit{view\\_tag} = [|](#id4)vtf|[0:1]

return \mathit{view\\_tag}.

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 3B | 00 | 00 | 25 or 45 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 20 | encrypted key derivation \widetilde{\mathfrak{D}\_\mathrm{in}} |
| 20 | ephemeral hmac (optional, only during active transaction) |
| 04 | index |

**Response data**

| Length | Value |
| --- | --- |
| 01 | view tag \mathit{view\\_tag} |

#### Generate Keypair

**Monero**

crypto::generate\_keys.

**Description**

Generate a new keypair and return it. The secret key is returned encrypted.

> generate \mathit{x}
> compute \mathit{xP} = \mathit{x}.|P|
> compute \widetilde{\mathit{x}} = [|enc|[|spk|](#id84)](\mathit{x})

return \mathit{P}, \widetilde{\mathit{x}}.

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 40 | 00 | 00 | 01 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |

**Response data**

| Length | Value |
| --- | --- |
| 20 | public key \mathit{P} |
| 20 | encrypted secret key \widetilde{\mathit{x}} |
| 20 | ephemeral hmac (optional, only during active transaction) |

#### Secret Key To Public Key

**Monero**

crypto::secret\_key\_to\_public\_key.

**Description**

Compute a public key from secret a secret key.

> compute \mathit{x} = [|dec|[|spk|](#id86)](\widetilde{\mathit{x}})
> compute \mathit{P} = \mathit{x}.|G|

return \mathit{P}.

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 30 | 00 | 00 | 21 or 41 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 20 | encrypted secret key \widetilde{\mathit{x}} |
| 20 | ephemeral hmac (optional, only during active transaction) |

**Response data**

| Length | Value |
| --- | --- |
| 20 | public key \mathit{P} |

#### Secret Add

**Monero**

sc\_add

**Description**

> compute \mathit{x\_1} = [|dec|[|spk|](#id88)](\widetilde{\mathit{x\_1}})
> compute \mathit{x\_2} = [|dec|[|spk|](#id90)](\widetilde{\mathit{x\_2}})
> compute \mathit{x} = \mathit{x\_1} + \mathit{x\_2}
> compute \widetilde{\mathit{x}} = [|enc|[|spk|](#id92)](\mathit{x})

return \widetilde{\mathit{x}}.

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 3C | 00 | 00 | 41 or 61 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 20 | secret key \widetilde{\mathit{x\_1}} |
| 20 | ephemeral hmac (optional, only during active transaction) |
| 20 | secret key \widetilde{\mathit{x\_2}} |
| 20 | ephemeral hmac (optional, only during active transaction) |

**Response data**

| Length | Value |
| --- | --- |
| 20 | secret key \widetilde{\mathit{x}} |
| 20 | ephemeral hmac (optional, only during active transaction) |

#### Secret Scalar Mult Key

**Monero**

rct::scalarmultKey.

**Description**

Multiply a secret scalar with a public key.

> compute \mathit{x} = [|dec|[|spk|](#id94)](\widetilde{\mathit{x}})
> compute \mathit{xP} = \mathit{x}.|P|

return \mathit{xP}

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 42 | 00 | 00 | 41 or 61 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 20 | public key \mathit{P} |
| 20 | secret key \widetilde{\mathit{x}} |
| 20 | ephemeral hmac (optional, only during active transaction) |

**Response data**

| Length | Value |
| --- | --- |
| 20 | new public key \mathit{xP} |

#### Secret Scalar Mult Base

**Monero**

rct::scalarmultBase.

**Description**

Multiply a secret scalar with the publis base point \mathit{G}.

> compute \mathit{x} = [|dec|[|spk|](#id96)](\widetilde{\mathit{x}})
> compute \mathit{xG} = \mathit{x}.|G|

return \mathit{xG}

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 44 | 00 | 00 | 21 or 41 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 20 | secret key \widetilde{\mathit{x}} |
| 20 | ephemeral hmac (optional, only during active transaction) |

**Response data**

| Length | Value |
| --- | --- |
| 00 |  |
| 20 | new public key \mathit{xG} |

#### Stealth

**Monero**

**Description**

Encrypt payment ID

> compute \mathit{x} = [|dec|[|spk|](#id98)](\widetilde{\mathit{x}})
> compute \mathfrak{D}\_\mathrm{in} = [|keyDrv|(|P|](#id100), \mathit{x})
> compute \mathit{s} = [|Hs|( |DRV|](#id102) | \mathtt{ENC\\_PAYMENT\\_ID\\_TAIL})
> compute \mathit{PayID} = [|ePayID|^|s|](#id104)

return \mathit{PayID}

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 76 | 00 | 00 | 61 or 81 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 20 | public key \mathit{P} |
| 20 | encryped secret key \widetilde{\mathit{x}} |
| 20 | ephemeral hmac (optional, only during active transaction) |
| 20 | encryped payment ID \widetilde{\mathit{PayID}} |

**Response data**

#### Unblind

**Monero**

**Description**

Unblind amount and his mask.

First:

> compute \mathcal{AK}\_\mathrm{amount} = [|dec|[|spk|](#id106)](\widetilde{\mathcal{AK}\_\mathrm{amount}})

If blind V1:

> compute \mathit{s} = [|Hs|(|AKout|](#id108))
> compute \widetilde{\mathcal{\mathrm{mask}}} = \mathcal{\mathrm{mask}}-\mathit{s}
> compute \mathit{s} = [|Hs|(|a|](#id110))
> compute \widetilde{\mathcal{\mathrm{amount}}} = \mathcal{\mathrm{amount}}-\mathit{s}

If blind V2:
compute \mathcal{\mathrm{mask}} = [|Hs|("commitment\_mask" \| |Akout|](#id112)) % \mathtt{\#n}
compute \mathit{s} = [|Hs|("amount" \| |Akout|](#id114))
compute [|](#id6)v|[0:7] = [|](#id8)ev|[0:7]^|s|[0:7]

return \widetilde{\mathcal{\mathrm{mask}}},|ev|

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 7A | 00 | 00 | 61 or 81 |

*specific options*

| `-------xx`  `-------10`  `-------00` | Commitment scheme version  Blind V2  Blind V1 |
| --- | --- |

**Command data**

| Length | Value |
| --- | --- |
| 01 | xx |
| 20 | encryped blinding factor \mathcal{AK}\_\mathrm{amount} |
| 20 | ephemeral hmac (optional, only during active transaction) |
| 20 | blinded mask \widetilde{\mathcal{\mathrm{mask}}} |
| 20 | blinded amount \widetilde{\mathcal{\mathrm{amount}}} |

**Response data**

| Length | Value |
| --- | --- |
| 20 | mask \widetilde{\mathcal{\mathrm{mask}}} |
| 20 | amount \widetilde{\mathcal{\mathrm{amount}}} |

## High Level Transaction command

### Transaction process overview

The transaction is mainly generated in construct\_tx\_and\_get\_tx\_key (or construct\_tx) and
construct\_tx\_with\_tx\_key
functions.

First, a new transaction keypair (\mathit{r, R}) is generated.

Then, the stealth payment id is processed if any.

Then, for each input transaction to spend, the input key image is retrieved.

Then, for each output transaction, the epehemeral destination key and the blinding key
amount \mathcal{AK}\_\mathrm{amount} are computed.

Once \mathit{T\_{in}} and \mathit{T\_{out}} keys are set up, the genRCT/genRctSimple function is called.

First a commitment \mathit{C\_v} to each \mathcal{\mathrm{amount}} amount and its associated range proof are
computed to ensure the \mathcal{\mathrm{amount}} amount confidentiality. The commitment and its range proof
do not imply any secret and generate \mathit{C\_v}, \mathcal{\mathrm{mask}} such \mathit{C\_v = k.G + v.H}.

Then \mathcal{\mathrm{mask}} and \mathcal{\mathrm{amount}} are blinded by using the \mathcal{AK}\_\mathrm{amount} which is only known in an encrypted
form by the host.

After all commitments have been setup, the confidential ring signature happens.
This signature is performed by calling proveRctMG which then calls MLSAG\_Gen.

At this point the amounts and destination keys must be validated on the NanoS. This
information is embedded in the message to sign by calling get\_pre\_mlsag\_hash, prior
to calling ProveRctMG. So the get\_pre\_mlsag\_hash function will have to be modified to
serialize the rv transaction to NanoS which will validate the tuple <amount,dest> and
compute the prehash.
The prehash will be kept inside NanoS to ensure its integrity.
Any further access to the prehash will be delegated.

Once the prehash is computed, the proveRctMG is called. This function only builds
some matrix and vectors to prepare the signature which is performed by the final
call MLSAG\_Gen.

During this last step some ephemeral key pairs are generated : \mathit{\alpha\_{in}}, \mathit{\alpha\_{in}.G}.
All \mathit{\alpha\_{in}} must be kept secret to protect the \mathit{x\_{in}} keys.
Moreover we must avoid signing arbitrary values during the final loop.

In order to achieve this validation, we need to approve the original destination
address [|Aout||Bout|](#id116), which is not recoverable from P out . Here the only solution is
to pass the original destination with the \mathcal{\mathrm{mask}}, \mathcal{\mathrm{amount}}, \mathcal{AK}\_\mathrm{amount}.

Unblind \mathcal{\mathrm{mask}} and \mathcal{\mathrm{amount}} and then verify the commitment \mathit{C\_v = k.G + v.H}.
If \mathit{C\_v} is verified and user validate \mathit{A\_{out}},|Bout| and \mathcal{\mathrm{amount}}, continue.

\pagebreak

### Transaction State Machine

During a transaction the following state machine is enforced:

```
OPEN_TX{1} -----------------------------------------------------
                                                               |
----------------------------------------------------------------
|
----> STEALTH{1} -----------------------------------------------
                                                               |
----------------------------------------------------------------
|
 ----> GEN_TXOUT_KEYS{*} ---------------------------------------
                                                               |
------------------------------------------------------------ ---
|
----> PREFIX_HASH{1} ---> PREFIX_HASH{*} ---> PREFIX_HASH{1} ---
        (ph_init)          (ph_update)        (ph_finalize)    |
                                                               |
----------------------------------------------------------------
|
----> GEN_COMMITMENT_MASK{*} -----------------------------------
        only for real TX                                       |
                                                               |
----------------------------------------------------------------
|
----> BLIND ----------------------------------------------------
                                                               |
----------------------------------------------------------------
|
----> VALIDATE{1} ---> VALIDATE{*} --- VALIDATE{*} <------------
  mlsag_ph_init     mlsag__update    mlsag__finalize           |
                                                               |
---------------------------------------------------------------
|
----> MLSAG{1} ------> MLSAG{*} ------> MLSAG{1} ---------------
  --> mlsag_prepare    mlsag_hash       mlsag_sign --          |
  |                                                 |          |
  ---------------------------------------------------          |
                                                               |
----------------------------------------------------------------
|
----> CLOSE_TX

```

Note this state machine assume the multi-signature is not supported.
For multi-signature the INS\_MLSAG/mlsag\_prepare and INS\_MLSAG/mlsag\_sign may be received several time.

### Transaction Commands

#### Open TX

**Description**

Open a new transaction. Once open the device impose a certain order in subsequent commands:

> * OpenTX
> * Stealth
> * Get TX output keys
> * Blind \*
> * Initialize MLSAG-prehash
> * Update MLSAG-prehash \*
> * Finalize MLSAG-prehash
> * MLSAG prepare
> * MLSAG hash \*
> * MLSAG sign
> * CloseTX

During this sequence low level API remains available, but no other transaction can be started until the current one is finished or aborted.

> Initialize \mathcal{H}\_\mathrm{outkeys}
> compute initial transaction key pair (\mathit{r, R})

return (\mathit{r, R})

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 70 | 01 | cnt | 05 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | options |
| 04 | account identifier (ignored, RFU) |

**Response data**

| Length | Value |
| --- | --- |
| 20 | public transaction key \mathit{R} |
| 20 | encrypted private transaction key \widetilde{\mathit{r}} |
| 20 | ephemeral hmac |
| 20 | ephemeral hmac of view key |
| 20 | ephemeral hmac of spend key |

#### Set Signature Mode

**Description**

Set the signature to 'fake' or 'real'. In fake mode a random key is used to signed
the transaction and no user confirmation is requested.

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 72 | 01 | 00 | 02 |

**Command data**

**Response data**

| Length | Value |
| --- | --- |
|  |  |

#### Hash Prefix

##### Hash prefix init

**Description**

Init prefix hash and ask user to validate time lock

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 7D | 01 | cnt | 05 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | options |
| varint | TX version |
| varint | TX timelock |

**Response data**

| Length | Value |
| --- | --- |
|  |  |

##### Hash prefix update

**Description**

Update prefix hash with raw data. Options fields tells if there is more data to come or not.

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 7D | 02 | cnt | 05 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | options |
| var | raw data to hash |

**Response data**

| Length | Value |
| --- | --- |
|  |  |

#### Generate Commitment Mask

**Description**

compute \mathit{s} = [|Hs|("commitment\_mask" \| |AKout|](#id118))

Return \mathit{s}

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 77 | 00 | 00 | 21 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | 00 |
| 20 | encryped blinding factor \mathcal{AK}\_\mathrm{amount} |
| 20 | ephemeral hmac |

**Response data**

| Length | Value |
| --- | --- |
| 20 | commitment mask \mathit{s} |

#### Blind

**Monero**

**Description**

Blind amount and his mask.

First:

> compute \mathcal{AK}\_\mathrm{amount} = [|dec|[|spk|](#id120)](\widetilde{\mathcal{AK}\_\mathrm{amount}})

If blind V1:

> compute \mathit{s} = [|Hs|(|AKout|](#id122))
> compute \widetilde{\mathcal{\mathrm{mask}}} = [|k|+|s|](#id124)
> compute \mathit{s} = [|Hs|(|a|](#id126))
> compute \widetilde{\mathcal{\mathrm{amount}}} = [|v|+|s|](#id128)

If blind V2:

> set \widetilde{\mathcal{\mathrm{mask}}} to 32 zero bytes
> compute \mathit{s} = [|Hs|("amount" \| |AKout|](#id130))
> compute \widetilde{\mathcal{\mathrm{amount}}} = [|](#id10)v|[0:7]^|s|[0:7]

return \widetilde{\mathcal{\mathrm{mask}}},|ev|

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 78 | 00 | 00 | 81 |

*specific options*

| `-------xx`  `-------10`  `-------00` | Commitment scheme version  Blind V2  Blind V1 |
| --- | --- |

**Command data**

| Length | Value |
| --- | --- |
| 01 | xx |
| 20 | encryped blinding factor \mathcal{AK}\_\mathrm{amount} |
| 20 | ephemeral hmac |
| 20 | mask \mathcal{\mathrm{mask}} |
| 20 | amount \mathcal{\mathrm{amount}} |

**Response data**

| Length | Value |
| --- | --- |
| 20 | blinded mask \widetilde{\mathcal{\mathrm{mask}}} |
| 20 | blinded amount \widetilde{\mathcal{\mathrm{amount}}} |

#### Generate TX output keys

**Description**

Compute additional key \mathit{P} if needed, amount key blinding and ephemeral destination key.

> if \mathit{need\\_additional\\_key} :
> if \mathit{is\\_subaddress} :
> compute \mathit{R}' = \mathit{additional\\_key}.|Bout|
>
> else
> compute \mathit{R}' = \mathit{additional\\_key}.|G|
>
>
>
>
> if \mathit{is\\_change\\_address} :
> compute \mathfrak{D}\_\mathrm{in} = [|keyDrv|(|a|](#id132),|R|)
>
> else
> if \mathit{need\\_additional\\_key} and \mathit{is\\_subaddress}:
> compute \mathfrak{D}\_\mathrm{in} = [|keyDrv|(|ak|](#id134),|Aout|)|
>
> else:
> compute \mathfrak{D}\_\mathrm{in} = [|keyDrv|(|r|](#id136),|Aout|)
>
>
>
>
> compute \mathcal{AK}\_\mathrm{amount} = [|Hps|(|Drv|](#id138),|idx|)
> compute \widetilde{\mathcal{AK}\_\mathrm{amount}} = [|enc|[|spk|](#id140)](\mathcal{AK}\_\mathrm{amount})
>
>
> compute \mathit{s} = [|Hps|(|Drv|](#id142),|idx|)
> compute \mathit{P} = [|Bout|+|s|](#id144).|G|
>
>
> update \mathcal{H}\_\mathrm{outkeys} : [|Hupd|(|Aout|](#id146),|Bout|,is\_change,|AKout|)
> if option 'last' is set:
> finalize \mathcal{H}\_\mathrm{outkeys}

The application returns

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 7B | 01 | cnt | EC |

**Command data**

**Response data**

#### Validate and Pre Hash

##### Initialize MLSAG-prehash

**Description**

During the first step, the application updates the \mathcal{H} with the transaction
header:

if cnt == 1

> Finalize \mathcal{H}\_\mathrm{outkeys}
> Initialize \mathcal{H}\_\mathrm{outkeys}'
> Initialize \mathcal{H}\_\mathrm{commitment}
> Initialize \mathcal{H}
> update \mathcal{H} : [|](#id12)Hupd|(txnFee)
> request user to validate txnFee

else

> update \mathcal{H} : [|](#id14)Hupd|(pseudoOut)

**Command**

**Command data**

> if `cnt==1` :

| Length | Value |
| --- | --- |
| 01 | options |
| 01 | type |
| varint | txnFee |

if `cnt>1` :

| Length | Value |
| --- | --- |
| 01 | options |
| 20 | pseudoOut |

##### Update MLSAG-prehash

**Description**

On the second step the application receives amount and destination and check
values. It also re-compute the \mathcal{H}\_\mathrm{outkeys} value to ensure consistency with steps 3 and 4.
So for each command received, do:

> compute \mathcal{AK}\_\mathrm{amount} = [|dec|[|spk|](#id148)](\widetilde{\mathcal{AK}\_\mathrm{amount}})
>
>
> update \mathcal{H}\_\mathrm{outkeys}'' : [|Hupd|(|Aout|](#id150) | \mathit{B\_{out}} | is\_change | \mathcal{AK}\_\mathrm{amount})
>
>
> if blind v1
> compute \mathcal{\mathrm{mask}} = \widetilde{\mathcal{\mathrm{mask}}} - [|Hs|(|Akout|](#id152))
> compute \mathcal{\mathrm{amount}} = \widetilde{\mathcal{\mathrm{amount}}} - [|Hs|(|Hs|(|Akout|](#id154)))
>
>
>
> if blind v2
> compute \mathcal{\mathrm{mask}} = [|Hs|("commitment\_mask"||Akout|](#id156))) % \mathtt{\#n}
> compute \mathit{s} = [|Hs|("amount"|||Akout|](#id158))
> compute [|](#id16)v|[0:7] = [|](#id18)ev|[0:7] ^ [|](#id20)s|[0:7]
>
>
>
> check \mathit{C\_v} == \mathcal{\mathrm{mask}}.|G| + \mathcal{\mathrm{amount}}.|H| |
> update \mathcal{H}\_\mathrm{commitment} : [|Hupd|(|Ct|](#id160))
>
>
> if last command:
> finalize \mathcal{H}\_\mathrm{outkeys}'
> check \mathcal{H}\_\mathrm{outkeys}' == \mathcal{H}\_\mathrm{outkeys}
> finalize \mathcal{H}\_\mathrm{commitment}
>
>
>
>
>
> update \mathcal{H} : [|](#id22)Hupd|(ecdhInfo)
>
>
> ask user validation of \mathit{A\_{out}}, \mathit{B\_{out}}, \mathcal{\mathrm{amount}}

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 7C | 02 | cnt | E3 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | options |
| 01 | 1 if sub-address, 0 else |
| 01 | 1 if change-address, 0 else |
| 20 | Real destination public view key \mathit{A\_{out}} |
| 20 | Real destination public spend key \mathit{B\_{out}} |
| 20 | encrypted amount key blinding \widetilde{\mathcal{AK}\_\mathrm{amount}} |
| 20 | ephemeral hmac |
| 20 | \mathit{C\_v} of \mathcal{\mathrm{amount}},|k| |
| 40 | one serialized ecdhInfo :  { bytes[32] mask (\widetilde{\mathcal{\mathrm{mask}}}) bytes[32] amount (\widetilde{\mathcal{\mathrm{amount}}})  } |

*specific options*

| `-------xx`  `-------10`  `-------00` | Mask scheme version  Blind V2  Blind V1 |
| --- | --- |

Note: Whatever the mask scheme is, \mathcal{\mathrm{amount}} is always transmitted as 32 bytes.

##### Finalize MLSAG-prehash

**Description**

Finally the application receives the last part of data:

> if cnt == 1
> Initialize \mathcal{H}\_\mathrm{commitment}'
>
>
>
> if last command:
> finalize \mathcal{H}\_\mathrm{commitment}'
> check \mathcal{H}\_\mathrm{commitment} == \mathcal{H}\_\mathrm{commitment}'
> \mathit{s} = finalize \mathcal{H}
> compute \mathcal{H} = \mathtt{HashToScalar} (message | \mathit{s} | proof)
>
>
>
> else
> update \mathcal{H}\_\mathrm{commitment}': [|Hupd|(|Ct|](#id162))
> update \mathcal{H}: [|Hupd|(|Ct|](#id164))

Keep \mathcal{H}

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 7C | 03 | cnt | 21 |

**Command data**

not last:

| Length | Value |
| --- | --- |
| 01 | options |
| 20 | one serialized commitment :  { bytes[32] mask (\mathit{C\_v})  } |

last:

| Length | Value |
| --- | --- |
| 01 | options |
| 20 | message (rctSig.message) |
| 20 | proof (proof range hash) |

**Response data**

| Length | Value |
| --- | --- |
|  |  |

#### MLSAG

##### MLSAG prepare

**Description**

Generate the matrix ring parameters:

> generate \mathit{\alpha\_{in}} ,
> compute \mathit{\alpha\_{in}.G}
> if real key:
> check the order of \mathit{H\_i}
> compute \mathit{\alpha\_{in}.H\_i}
> compute \widetilde{\mathit{\alpha\_{in}}} = [|enc|[|spk|](#id166)](\mathit{\alpha\_{in}})
> if not option\_clear\_xin:
> compute \mathit{x\_{in}} = [|dec|[|spk|](#id168)](\widetilde{\mathit{x\_{in}}})
>
> compute \mathit{II\_{in}} = \mathit{x\_{in}}.|Hi|

return \widetilde{\mathit{\alpha\_{in}}} , \mathit{\alpha\_{in}.G} [\mathit{\alpha\_{in}.H\_i}, \mathit{II\_{in}}]

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 7E | 01 | cnt | 61 |

*specific options*

| `------x--`  `------1--`  `------0--` | Mask scheme version  unencrypted \mathit{x\_{in}}  encryted \widetilde{\mathit{x\_{in}}} |
| --- | --- |

**Command data**

for real key:

| Length | Value |
| --- | --- |
| 01 | options |
| 20 | point |
| 20 | secret spend key \widetilde{\mathit{x\_{in}}} |
| 20 | ephemeral hmac |

for random ring key

| Length | Value |
| --- | --- |
| 01 | options |

**Response data**

for real key:

| Length | Value |
| --- | --- |
| 20 | encrypted \mathit{\alpha\_{in}} : \widetilde{\mathit{\alpha\_{in}}} |
| 20 | ephemeral hmac |
| 20 | \mathit{\alpha\_{in}.G} |
| 20 | \mathit{II\_{in}} |
| 20 | \mathit{\alpha\_{in}.H\_i} |

for random ring key

| Length | Value |
| --- | --- |
| 20 | encrypted \mathit{\alpha\_{in}} : \widetilde{\mathit{\alpha\_{in}}} |
| 20 | ephemeral hmac |
| 20 | \mathit{\alpha\_{in}.G} |

##### MLSAG hash

**Description**

Compute the last matrix ring parameter:

> if cnt == 1:
> replace the inputs by the previously computed MLSAG-prehash
> initialize \mathcal{H}
>
>
>
> update \mathcal{H}: [|](#id24)Hs|(inputs)
>
>
> if last command:
> c = finalize \mathcal{H} % \mathtt{\#n}

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 7E | 02 | cnt | 21 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | options |
| 20 | inputs |

**Response data**

if last command

| Length | Value |
| --- | --- |
| 20 | c |

else

| Length | Value |
| --- | --- |
|  |  |

##### MLSAG sign

**Description**

Finally compute all signatures:

> compute \mathit{\alpha\_{in}} = [|dec|[|spk|](#id170)](\widetilde{\mathit{\alpha\_{in}}})
> compute \mathit{x\_{in}} = [|dec|[|spk|](#id172)](\widetilde{\mathit{x\_{in}}})
> compute \mathit{ss} = (\mathit{\alpha\_{in}} - \mathit{c} \* \mathit{x\_{in}} ) % \mathit{l}

return \mathit{ss}

**Command**

| CLA | INS | P1 | P2 | LC |
| --- | --- | --- | --- | --- |
| 03 | 7E | 03 | cnt | 81 |

**Command data**

| Length | Value |
| --- | --- |
| 01 | options |
| 20 | \widetilde{\mathit{x\_{in}}} |
| 20 | ephemeral hmac |
| 20 | \widetilde{\mathit{\alpha\_{in}}} |
| 20 | ephemeral hmac |

**Response data**

| Length | Value |
| --- | --- |
| 20 | signature \mathit{ss} |

## Conclusion

Let's Go

## Annexes

### References

> [1] <https://github.com/monero-project/monero/tree/v0.15.0.1>
> [2] [monero-project/monero#2056](https://github.com/monero-project/monero/pull/2056)
> [3] <https://github.com/kenshi84/monero/tree/subaddress-v2>
> [4] <https://www.reddit.com/r/Monero/comments/6invis/ledger_hardware_wallet_monero_integration>
> [5] <https://github.com/moneroexamples>

### Helper functions

**|keyDrv|** (\mathtt{KeyDerivation})

> *input* : r , P
> *output*: \mathfrak{D}
> *Monero*: generate\_key\_derivation
>
>
> \mathfrak{D} = r.P
> \mathfrak{D} = 8.\mathfrak{D}

**|Hs|** (\mathtt{HashToScalar})

> *input*: raw
> *output*: s
>
>
>
>
> \mathit{s} = [|](#id26)H|(raw)

**|Hps|** (\mathtt{HashPointToScalar})

> *input*: D, idx
> *output*: s
>
>
> data = point2bytes(D) | varint(idx)
> \mathit{s} = [|H|(:math:`data`) % |order|](#id174)

**|Hp|** (\mathtt{HashToPoint})

> *input*: P
> *output*: Q
>
>
> data = point2bytes(P)
> \mathit{s} = [|H|(:math:`data`) % |order|](#id176)
> Q = ge\\_from\\_fe(s)

**DeriveAES**

> *input*: R,a,b
> *output*: spk
>
>
> seed = sha256(R|a|b|R)
> data = sha256(seed)
> spk = lower16(data)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


