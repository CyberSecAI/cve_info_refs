```
[advisory]
id = "RUSTSEC-2020-0151"
package = "generator"
aliases = ["CVE-2020-36471", "GHSA-w3g5-2848-2v8r"]
cvss = "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
date = "2020-11-16"
url = "https://github.com/Xudong-Huang/generator-rs/issues/27"
categories = ["memory-corruption"]
keywords = ["concurrency"]
[versions]
patched = [">= 0.7.0"]
```
# Generators can cause data races if non-Send types are used in their generator functions
The `Generator` type is an iterable which uses a generator function that yields
values. In affected versions of the crate, the provided function yielding values
had no `Send` bounds despite the `Generator` itself implementing `Send`.
The generator function lacking a `Send` bound means that types that are
dangerous to send across threads such as `Rc` could be sent as part of a
generator, potentially leading to data races.
This flaw was fixed in commit [`f7d120a3b`](https://github.com/Xudong-Huang/generator-rs/commit/f7d120a3b724d06a7b623d0a4306acf8f78cb4f0)
by enforcing that the generator function be bound by `Send`.

## Description

Hi there, we (Rust group [@sslab-gatech](https://github.com/sslab-gatech)) are scanning crates on crates.io for potential soundness bugs. We noticed that `Generator` implements `Send` as long as the closure has a static lifetime. However, this should also probably be bounded by `T: Send`, otherwise it's possible to smuggle across non-Send types across thread boundaries.

Here's an example of a data race in safe Rust code through a Generator.

```
#![forbid(unsafe_code)]

use generator::Gn;
use std::{rc::Rc, thread};

fn main() {
    let rc = Rc::new(());

    let rc_clone = rc.clone();
    let mut generator = Gn::new_scoped(move |_| {
        return rc_clone;
    });

    let child = thread::spawn(move || {
        let smuggled_rc = generator.next().unwrap();

        println!("RC in thread: {:p}", smuggled_rc);
        for _ in 0..1000000000 {
            let x = smuggled_rc.clone();
        }
    });

    println!("RC in main: {:p}", rc);
    for _ in 0..1000000000 {
        let x = rc.clone();
    }

    child.join().unwrap();
    assert_eq!(Rc::strong_count(&rc), 2);
}
```

Output:

```
RC in main: 0x5587d9ed6a50
RC in thread: 0x5587d9ed6a50

Return Code: -4 (SIGILL)

```
### Description
The `Generator` type is an iterable which uses a generator function that yields
values. In affected versions of the crate, the provided function yielding values
had no `Send` bounds despite the `Generator` itself implementing `Send`.

The generator function lacking a `Send` bound means that types that are
dangerous to send across threads such as `Rc` could be sent as part of a
generator, potentially leading to data races.

This flaw was fixed in commit [`f7d120a3b`](https://github.com/Xudong-Huang/generator-rs/commit/f7d120a3b724d06a7b623d0a4306acf8f78cb4f0)
by enforcing that the generator function be bound by `Send`.

## Data races in generator
The `Generator` type is an iterable which uses a generator function that yields
values. In affected versions of the crate, the provided function yielding values
had no `Send` bounds despite the `Generator` itself implementing `Send`.
The generator function lacking a `Send` bound means that types that are
dangerous to send across threads such as `Rc` could be sent as part of a
generator, potentially leading to data races.

This flaw was fixed in commit [`f7d120a3b`](https://github.com/Xudong-Huang/generator-rs/commit/f7d120a3b724d06a7b623d0a4306acf8f78cb4f0)
by enforcing that the generator function be bound by `Send`.

### Weaknesses
CWE-362
### CVE ID
CVE-2020-36471

### Root cause of vulnerability
The `Generator` type in the `generator-rs` crate lacked `Send` bounds on the generator function, despite the `Generator` itself implementing `Send`. This allowed non-`Send` types to be sent across threads, resulting in data races.

### Weaknesses/vulnerabilities present
- Data races due to lack of `Send` bounds on the generator function.
- Concurrency issues related to shared mutable state.

### Impact of exploitation
- Potential for undefined behavior, such as data corruption and program crashes.
- Example given resulted in a SIGILL signal, indicating an illegal instruction due to data races.

### Attack vectors
- By creating a generator that captures and yields a non-`Send` type across threads.

### Required attacker capabilities/position
- The attacker needs to be able to create a generator with a non-`Send` type, and be able to spawn a new thread to trigger the race condition by accessing the shared, non-send data from both threads.
```