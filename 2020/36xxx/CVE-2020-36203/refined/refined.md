Based on the provided information, here's an analysis of CVE-2020-36203:

**Root cause of vulnerability:**
The `ARefss` type in the `reffers` crate is intended to hold objects that are both `Send` and `Sync`. However, the `ARefss::map()` function lacked a `Send + Sync` trait bound on the type `V`, allowing the insertion of `!Send` and `!Sync` objects into `ARefss`. This violates the assumptions of the `ARefss` type, leading to potential data races.

**Weaknesses/vulnerabilities present:**
- Unconditional implementation of `Send` and `Sync` traits for `ARefss<'a, V>`.
- Lack of `Send + Sync` trait bound on the type `V` in `ARefss::map()`.
- Potential for data races when `!Send` or `!Sync` objects are inserted into `ARefss`.

**Impact of exploitation:**
- Undefined behavior.
- Memory corruption.
- Data races on inner objects within `ARefss`.
- Program crash (segmentation fault).
- High availability impact due to potential crashes.

**Attack vectors:**
- Exploitation is achieved via the local API of the vulnerable crate. Specifically, using the `ARefss::map()` API.

**Required attacker capabilities/position:**
- The attacker needs to be able to call the `ARefss::map()` API in the vulnerable code.
- Low privileges are required.
- No user interaction is required.

**Additional details:**
- The vulnerability was corrected by adding a trait bound `V: Send + Sync` to the `ARefss::map()` API.
- A proof-of-concept program was provided that triggers undefined behavior and a segmentation fault by exploiting this vulnerability.
- CVSS score of 4.7, categorized as medium severity.
- The vulnerability is tracked as CWE-362 (Race Condition) and CWE-787 (Out-of-bounds Write).