```
{
  "CVE-2020-8647": {
    "description": "There was a use-after-free vulnerability in the vc_do_resize function in drivers/tty/vt/vt.c.",
    "root_cause": "The vulnerability occurs during screen resizing operations in the virtual terminal driver, specifically within the `vc_do_resize` function. When resizing the screen, the code updates the `vc->vc_size_row` to the new row size, but uses `vga_vram_base` for `vc_origin` and `vc_visible_origin`, rather than `vc_screenbuf`. This discrepancy can lead to `vc_origin` being smaller than `vc_screenbuf`, causing an out-of-bounds access when `TIOCLINUX` uses the new row size to calculate offsets.",
    "vulnerabilities": [
      "use-after-free"
    ],
    "impact": "Denial of service (crash or memory corruption) or potentially privilege escalation.",
    "attack_vector": "Local access to a virtual terminal (/dev/tty1 etc.)",
     "required_capabilities": "Local user access to a virtual terminal"
  },
 "CVE-2020-8649":{
    "description": "There was a use-after-free vulnerability in the vgacon_invert_region function in drivers/video/console/vgacon.c",
     "root_cause": "The root cause is an incorrect calculation of the screen buffer leading to use-after-free when inverting the screen region. During screen resizing, the ‘vc->vc_size_row’ is updated but ‘vc_origin’ and ‘vc_visible_origin’ use ‘vga_vram_base’ instead of ‘vc_screenbuf’. This can result in ‘vc_origin’ being smaller than ‘vc_screenbuf’. During the `vgacon_invert_region` function, if the offset calculated is larger than `vga_vram_size` it will cause a bad access. If a larger screenbuf is set first, then another larger screenbuf is set, copying from old to new origin can cause the bad access.",
    "vulnerabilities": [
        "use-after-free"
      ],
   "impact": "Denial of service (crash or memory corruption) or potentially privilege escalation",
    "attack_vector": "Local access to a virtual terminal (/dev/tty1 etc.) on a system using the vgacon driver",
     "required_capabilities": "Local user access to a virtual terminal using the vgacon driver"
},
 "CVE-2019-19768": {
    "description": "There was a use-after-free (read) in the __blk_add_trace function in kernel/trace/blktrace.c (which is used to fill out a blk_io_trace structure and place it in a per-cpu sub-buffer).",
    "root_cause": "The vulnerability stems from a race condition in the blktrace debug facility. Specifically, a use-after-free can occur in the `__blk_add_trace` function when filling out a `blk_io_trace` structure and placing it in a per-cpu sub-buffer. This happens when a block device removal is triggered while blktrace is still trying to access the device's resources.",
    "vulnerabilities": [
        "use-after-free"
      ],
  "impact": "Denial of service (crash) or possibly privilege escalation.",
  "attack_vector": "Local user able to trigger removal of block devices",
  "required_capabilities": "Local user able to trigger removal of block devices"
},
 "CVE-2020-9383":{
     "description": "An issue was discovered in the Linux kernel 3.16 through 5.5.6. set_fdc in drivers/block/floppy.c leads to a wait_til_ready out-of-bounds read because the FDC index is not checked for errors before assigning it, aka CID-2e90ca68b0d2.",
    "root_cause":"The vulnerability occurs because the `set_fdc` function in `drivers/block/floppy.c` does not perform proper error checking on the FDC index before assigning it. This missing check leads to an out-of-bounds read when calling `wait_til_ready`.",
    "vulnerabilities": [
      "out-of-bounds read"
    ],
    "impact": "Denial of service (crash or memory corruption) or potentially privilege escalation",
    "attack_vector": "Local access to a floppy drive",
     "required_capabilities": "Local user access to a floppy drive."
    }
}
```