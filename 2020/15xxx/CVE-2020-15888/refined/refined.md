```
{
  "cve": "CVE-2020-15888",
  "description": "Lua through 5.4.0 mishandles the interaction between stack resizes and garbage collection, leading to a heap-based buffer overflow, heap-based buffer over-read, or use-after-free.",
  "vulnerabilities": [
    {
      "root_cause": "Mishandling of interaction between stack resizes and garbage collection.",
      "weaknesses": [
        "Heap-based buffer overflow",
        "Heap-based buffer over-read",
        "Use-after-free"
      ],
       "impact": "Memory corruption leading to potential denial of service or arbitrary code execution.",
      "attack_vectors": [
        "Exploiting the specific code paths that resize the stack and trigger garbage collection concurrently."
      ],
      "required_capabilities": "The attacker needs to provide Lua code which triggers a stack resize followed by garbage collection in a way that exploits the vulnerability. This requires knowledge of Lua's internal mechanisms related to stack management and garbage collection."
    },
    {
        "root_cause": "The vulnerability is caused by incorrect handling of stack resizing during garbage collection, which can cause a heap-based buffer overflow in the luaD_pretailcall function.",
        "weaknesses": [
            "Heap-based buffer overflow"
        ],
        "impact": "The vulnerability can cause a crash or potentially lead to arbitrary code execution.",
        "attack_vectors": [
            "Crafting a Lua script that triggers specific function calls, including coroutines, error handling, and garbage collection."
        ],
          "required_capabilities": "The attacker needs to be able to execute crafted Lua code, exploiting the interaction between stack resizes and garbage collection."
    },
    {
      "root_cause": "Incorrect memory management in `luaD_call` during calls with tail calls and error handling",
      "weaknesses": [
          "Heap use-after-free"
      ],
      "impact": "Memory corruption leading to application crash or potential code execution.",
         "attack_vectors": [
           "Executing Lua code that triggers specific sequences of `load`, `xpcall` and nested function calls with error handlers to expose the vulnerability in `luaD_call` function"
        ],
        "required_capabilities": "The attacker needs to be able to provide crafted Lua code that makes use of coroutines, error handling, and function calls in a way that causes a use-after-free in memory managed by Lua"
    },
     {
      "root_cause": "The root cause is in the luaT_adjustvarargs function which incorrectly calculates the stack size when handling variable arguments, leading to a heap buffer overflow.",
        "weaknesses": [
           "Heap-based buffer overflow"
        ],
         "impact": "Memory corruption leading to a crash and potentially arbitrary code execution.",
      "attack_vectors": [
        "Crafting a Lua script using functions with a high number of variable arguments that triggers the vulnerability in luaT_adjustvarargs."
      ],
       "required_capabilities": "The attacker needs to be able to execute crafted Lua code that makes use of variable arguments and error handling."
    },
     {
      "root_cause": "The root cause is in the luaH_get function, related to a memory access issue during garbage collection when using metamethods, specifically when using `pairs` in combination with `__gc` metamethods.",
         "weaknesses": [
          "Heap use-after-free"
        ],
      "impact": "Memory corruption resulting in a crash, possibly leading to arbitrary code execution.",
        "attack_vectors": [
        "Crafting a Lua script that uses coroutines, error handling, garbage collection, and specifically interacts with the `__gc` metamethod in combination with calls to `pairs`"
        ],
         "required_capabilities":"The attacker needs the ability to execute crafted Lua code that manipulates metamethods and triggers garbage collection in a way that leads to a use-after-free."
    }
  ],
    "fixes": [
        {
            "commit_id": "6298903e35217ab69c279056f925fb72900ce0b7",
            "description": "Keep minimum size when shrinking a stack. When shrinking a stack (during GC), do not make it smaller than the initial stack size."
        },
       {
            "commit_id": "eb41999461b6f428186c55abd95f4ce1a76217d5",
            "description": "Fixed bugs of stack reallocation x GC. Macro 'checkstackGC' was doing a GC step after resizing the stack; the GC could shrink the stack and undo the resize. Moreover, macro 'checkstackp' also does a GC step, which could remove the preallocated CallInfo when calling a function. (Its name has been changed to 'checkstackGCp' to emphasize that it calls the GC.)"
        }
  ]
}
```