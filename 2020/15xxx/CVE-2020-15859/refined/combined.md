=== Content from bugs.launchpad.net_fa451824_20250119_140742.html ===

[Log in / Register](https://bugs.launchpad.net/qemu/%2Bbug/1886362/%2Blogin)

[![](https://launchpadlibrarian.net/27372372/qemu_64.png)](https://launchpad.net/qemu)

## [QEMU](https://launchpad.net/qemu)

* [Overview](https://launchpad.net/qemu)
* [Code](https://code.launchpad.net/qemu)
* [Bugs](https://bugs.launchpad.net/qemu)
* [Blueprints](https://blueprints.launchpad.net/qemu)
* [Translations](https://translations.launchpad.net/qemu)
* [Answers](https://answers.launchpad.net/qemu)

# Heap use-after-free in lduw\_he\_p through e1000e\_write\_to\_rx\_buffers

Bug #1886362 reported by
[Alexander Bulekov](https://launchpad.net/~a1xndr)
on 2020-07-06

[8](/%2Bhelp-bugs/bug-heat.html)

This bug affects 1 person

| Affects | | Status | Importance | Assigned to | Milestone |
| --- | --- | --- | --- | --- | --- |
|  | [QEMU](https://bugs.launchpad.net/qemu) | Fix Released | Undecided | Unassigned |  |

### Bug Description

Hello,

This reproducer causes a heap-use-after free. QEMU Built with --enable-sanitizers:

cat << EOF | ./i386-softmmu/qemu-system-i386 -M q35,accel=qtest \

-qtest stdio -nographic -monitor none -serial none

outl 0xcf8 0x80001010

outl 0xcfc 0xe1020000

outl 0xcf8 0x80001014

outl 0xcf8 0x80001004

outw 0xcfc 0x7

outl 0xcf8 0x800010a2

write 0xe102003b 0x1 0xff

write 0xe1020103 0x1e 0xffffff055c5e5c30be4511d084ffffffffffffffffffffffffffffffffff

write 0xe1020420 0x4 0xffffffff

write 0xe1020424 0x4 0xffffffff

write 0xe102042b 0x1 0xff

write 0xe1020430 0x4 0x055c5e5c

write 0x5c041 0x1 0x04

write 0x5c042 0x1 0x02

write 0x5c043 0x1 0xe1

write 0x5c048 0x1 0x8a

write 0x5c04a 0x1 0x31

write 0x5c04b 0x1 0xff

write 0xe1020403 0x1 0xff

EOF

The Output:

==22689==ERROR: AddressSanitizer: heap-use-after-free on address 0x62500026800e at pc 0x55b93bb18bfa bp 0x7fffdbe844f0 sp 0x7fffdbe83cb8

READ of size 2 at 0x62500026800e thread T0

    #0 in \_\_asan\_memcpy (/build/i386-softmmu/qemu-system-i386+)

    #1 in lduw\_he\_p /include/qemu/bswap.h:332:5

    #2 in ldn\_he\_p /include/qemu/bswap.h:550:1

    #3 in flatview\_write\_continue /exec.c:3145:19

    #4 in flatview\_write /exec.c:3186:14

    #5 in address\_space\_write /exec.c:3280:18

    #6 in address\_space\_rw /exec.c:3290:16

    #7 in dma\_memory\_rw\_relaxed /include/sysemu/dma.h:87:18

    #8 in dma\_memory\_rw /include/sysemu/dma.h:113:12

    #9 in pci\_dma\_rw /include/hw/pci/pci.h:789:5

    #10 in pci\_dma\_write /include/hw/pci/pci.h:802:12

    #11 in e1000e\_write\_to\_rx\_buffers /hw/net/e1000e\_core.c:1412:9

    #12 in e1000e\_write\_packet\_to\_guest /hw/net/e1000e\_core.c:1582:21

    #13 in e1000e\_receive\_iov /hw/net/e1000e\_core.c:1709:9

    #14 in e1000e\_nc\_receive\_iov /hw/net/e1000e.c:213:12

    #15 in net\_tx\_pkt\_sendv /hw/net/net\_tx\_pkt.c:544:9

    #16 in net\_tx\_pkt\_send /hw/net/net\_tx\_pkt.c:620:9

    #17 in net\_tx\_pkt\_send\_loopback /hw/net/net\_tx\_pkt.c:633:11

    #18 in e1000e\_tx\_pkt\_send /hw/net/e1000e\_core.c:664:16

    #19 in e1000e\_process\_tx\_desc /hw/net/e1000e\_core.c:743:17

    #20 in e1000e\_start\_xmit /hw/net/e1000e\_core.c:934:9

    #21 in e1000e\_set\_tctl /hw/net/e1000e\_core.c:2431:9

    #22 in e1000e\_core\_write /hw/net/e1000e\_core.c:3265:9

    #23 in e1000e\_mmio\_write /hw/net/e1000e.c:109:5

    #24 in memory\_region\_write\_accessor /memory.c:483:5

    #25 in access\_with\_adjusted\_size /memory.c:544:18

    #26 in memory\_region\_dispatch\_write /memory.c:1476:16

    #27 in flatview\_write\_continue /exec.c:3146:23

    #28 in flatview\_write /exec.c:3186:14

    #29 in address\_space\_write /exec.c:3280:18

    #30 in qtest\_process\_command /qtest.c:567:9

    #31 in qtest\_process\_inbuf /qtest.c:710:9

    #32 in qtest\_read /qtest.c:722:5

    #33 in qemu\_chr\_be\_write\_impl /chardev/char.c:188:9

    #34 in qemu\_chr\_be\_write /chardev/char.c:200:9

    #35 in fd\_chr\_read /chardev/char-fd.c:68:9

    #36 in qio\_channel\_fd\_source\_dispatch /io/channel-watch.c:84:12

    #37 in g\_main\_context\_dispatch (/usr/lib/x86\_64-linux-gnu/libglib-2.0.so.0+)

    #38 in glib\_pollfds\_poll /util/main-loop.c:219:9

    #39 in os\_host\_main\_loop\_wait /util/main-loop.c:242:5

    #40 in main\_loop\_wait /util/main-loop.c:518:11

    #41 in qemu\_main\_loop /softmmu/vl.c:1664:9

    #42 in main /softmmu/main.c:52:5

    #43 in \_\_libc\_start\_main (/lib/x86\_64-linux-gnu/libc.so.6+)

    #44 in \_start (/build/i386-softmmu/qemu-system-i386+)

0x62500026800e is located 14 bytes inside of 138-byte region [0x625000268000,0x62500026808a)

freed by thread T0 here:

    #0 in free (/build/i386-softmmu/qemu-system-i386+)

    #1 in qemu\_vfree /util/oslib-posix.c:238:5

    #2 in address\_space\_unmap /exec.c:3616:5

    #3 in dma\_memory\_unmap /include/sysemu/dma.h:148:5

    #4 in pci\_dma\_unmap /include/hw/pci/pci.h:839:5

    #5 in net\_tx\_pkt\_reset /hw/net/net\_tx\_pkt.c:453:9

    #6 in e1000e\_process\_tx\_desc /hw/net/e1000e\_core.c:749:9

    #7 in e1000e\_start\_xmit /hw/net/e1000e\_core.c:934:9

    #8 in e1000e\_set\_tctl /hw/net/e1000e\_core.c:2431:9

    #9 in e1000e\_core\_write /hw/net/e1000e\_core.c:3265:9

    #10 in e1000e\_mmio\_write /hw/net/e1000e.c:109:5

    #11 in memory\_region\_write\_accessor /memory.c:483:5

    #12 in access\_with\_adjusted\_size /memory.c:544:18

    #13 in memory\_region\_dispatch\_write /memory.c:1476:16

    #14 in flatview\_write\_continue /exec.c:3146:23

    #15 in flatview\_write /exec.c:3186:14

    #16 in address\_space\_write /exec.c:3280:18

    #17 in address\_space\_rw /exec.c:3290:16

    #18 in dma\_memory\_rw\_relaxed /include/sysemu/dma.h:87:18

    #19 in dma\_memory\_rw /include/sysemu/dma.h:113:12

    #20 in pci\_dma\_rw /include/hw/pci/pci.h:789:5

    #21 in pci\_dma\_write /include/hw/pci/pci.h:802:12

    #22 in e1000e\_write\_to\_rx\_buffers /hw/net/e1000e\_core.c:1412:9

    #23 in e1000e\_write\_packet\_to\_guest /hw/net/e1000e\_core.c:1582:21

    #24 in e1000e\_receive\_iov /hw/net/e1000e\_core.c:1709:9

    #25 in e1000e\_nc\_receive\_iov /hw/net/e1000e.c:213:12

    #26 in net\_tx\_pkt\_sendv /hw/net/net\_tx\_pkt.c:544:9

    #27 in net\_tx\_pkt\_send /hw/net/net\_tx\_pkt.c:620:9

    #28 in net\_tx\_pkt\_send\_loopback /hw/net/net\_tx\_pkt.c:633:11

    #29 in e1000e\_tx\_pkt\_send /hw/net/e1000e\_core.c:664:16

previously allocated by thread T0 here:

    #0 in posix\_memalign (/build/i386-softmmu/qemu-system-i386+)

    #1 in qemu\_try\_memalign /util/oslib-posix.c:198:11

    #2 in qemu\_memalign /util/oslib-posix.c:214:27

    #3 in address\_space\_map /exec.c:3558:25

    #4 in dma\_memory\_map /include/sysemu/dma.h:138:9

    #5 in pci\_dma\_map /include/hw/pci/pci.h:832:11

    #6 in net\_tx\_pkt\_add\_raw\_fragment /hw/net/net\_tx\_pkt.c:391:24

    #7 in e1000e\_process\_tx\_desc /hw/net/e1000e\_core.c:731:14

    #8 in e1000e\_start\_xmit /hw/net/e1000e\_core.c:934:9

    #9 in e1000e\_set\_tctl /hw/net/e1000e\_core.c:2431:9

    #10 in e1000e\_core\_write /hw/net/e1000e\_core.c:3265:9

    #11 in e1000e\_mmio\_write /hw/net/e1000e.c:109:5

    #12 in memory\_region\_write\_accessor /memory.c:483:5

    #13 in access\_with\_adjusted\_size /memory.c:544:18

    #14 in memory\_region\_dispatch\_write /memory.c:1476:16

    #15 in flatview\_write\_continue /exec.c:3146:23

    #16 in flatview\_write /exec.c:3186:14

    #17 in address\_space\_write /exec.c:3280:18

    #18 in qtest\_process\_command /qtest.c:567:9

    #19 in qtest\_process\_inbuf /qtest.c:710:9

    #20 in qtest\_read /qtest.c:722:5

    #21 in qemu\_chr\_be\_write\_impl /chardev/char.c:188:9

    #22 in qemu\_chr\_be\_write /chardev/char.c:200:9

    #23 in fd\_chr\_read /chardev/char-fd.c:68:9

    #24 in qio\_channel\_fd\_source\_dispatch /io/channel-watch.c:84:12

    #25 in g\_main\_context\_dispatch (/usr/lib/x86\_64-linux-gnu/libglib-2.0.so.0+)

-Alex

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Philippe Mathieu-Daudé (philmd)](https://launchpad.net/~philmd) wrote on 2020-07-07: |  |  | [#1](/qemu/%2Bbug/1886362/comments/1) |
| --- | --- | --- | --- |

[Download full text](https://bugs.launchpad.net/qemu/%2Bbug/1886362/comments/1/%2Bdownload) (8.0 KiB)

Running with '-trace e1000\\*':

e1000e\_cb\_pci\_realize E1000E PCI realize entry

e1000e\_mac\_set\_permanent Set permanent MAC: 52:54:00:12:34:56

e1000e\_cfg\_support\_virtio Virtio header supported: 0

e1000e\_rx\_set\_cso RX CSO state set to 0

e1000e\_cb\_qdev\_reset E1000E qdev reset entry

e1000x\_mac\_indicate Indicating MAC to guest: 52:54:00:12:34:56

e1000x\_rx\_can\_recv\_disabled link\_up: 1, rx\_enabled 0, pci\_master 0

e1000x\_rx\_can\_recv\_disabled link\_up: 1, rx\_enabled 0, pci\_master 0

e1000e\_vm\_state\_running VM state is running

[R +0.094581] outl 0xcf8 0x80001010

[S +0.094604] OK

[R +0.094632] outl 0xcfc 0xe1020000

[S +0.094654] OK

[R +0.094668] outl 0xcf8 0x80001014

[S +0.094675] OK

[R +0.094694] outl 0xcf8 0x80001004

[S +0.094702] OK

[R +0.094712] outw 0xcfc 0x7

e1000e\_rx\_start\_recv

[S +0.096938] OK

[R +0.096960] outl 0xcf8 0x800010a2

[S +0.096972] OK

[R +0.096986] write 0xe102003b 0x1 0xff

e1000e\_core\_write Write to register 0x38, 4 byte(s), value: 0xff

e1000e\_vlan\_vet Setting VLAN ethernet type 0xFF

[S +0.097019] OK

[R +0.097034] write 0xe1020103 0x1e 0xffffff055c5e5c30be4511d084ffffffffffffffffffffffffffffffffff

e1000e\_core\_write Write to register 0x100, 4 byte(s), value: 0xff

e1000e\_rx\_set\_rctl RCTL = 0xff

e1000e\_rx\_desc\_buff\_sizes buffer sizes: [2048, 0, 0, 0]

e1000e\_rx\_desc\_len RX descriptor length: 16

e1000e\_rx\_start\_recv

e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x104, 4 byte(s), value: 0x5c05ffff

e1000e\_core\_write Write to register 0x2820, 4 byte(s), value: 0xbe305c5e

e1000e\_irq\_rdtr\_fpd\_not\_running FPD written while RDTR was not running

e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x10c, 4 byte(s), value: 0x84d01145

e1000e\_core\_write Write to register 0x2800, 4 byte(s), value: 0xffffffff

e1000e\_core\_write Write to register 0x2804, 4 byte(s), value: 0xffffffff

e1000e\_core\_write Write to register 0x2808, 4 byte(s), value: 0xffffffff

e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x11c, 4 byte(s), value: 0xffffffff

e1000e\_core\_write Write to register 0x2810, 4 byte(s), value: 0xff

[S +0.097143] OK

[R +0.097159] write 0xe1020420 0x4 0xffffffff

e1000e\_core\_write Write to register 0x3800, 4 byte(s), value: 0xffffffff

[S +0.097173] OK

[R +0.097183] write 0xe1020424 0x4 0xffffffff

e1000e\_core\_write Write to register 0x3804, 4 byte(s), value: 0xffffffff

[S +0.097196] OK

[R +0.097208] write 0xe102042b 0x1 0xff

e1000e\_core\_write Write to register 0x3808, 4 byte(s), value: 0xff

[S +0.097221] OK

[R +0.097231] write 0xe1020430 0x4 0x055c5e5c

e1000e\_core\_write Write to register 0x3810, 4 byte(s), value: 0x5c5e5c05

[S +0.097243] OK

[R +0.097253] write 0x5c041 0x1 0x04

[S +0.097914] OK

[R +0.097942] write 0x5c042 0x1 0x02

[S +0.097953] OK

[R +0.097964] write 0x5c043 0x1 0xe1

[S +0.097972] OK

[R +0.097984] write 0x5c048 0x1 0x8a

[S +0.097992] OK

[R +0.098003] write 0x5c04a 0x1 0x31

[S +0.098011] OK

[R +0.098022] write 0x5c04b 0x1 0xff

[S +0.098029] OK

[R +0.098040] write 0xe1020403 0x1 0xff

e1000e\_core\_write Write to register 0x400, 4 byte(s), value: 0xff

e1000e\_tx\_descr 0xe1020400 : ff31008a 0

e1000e\_core\_read Read from register 0x400, 4 byte(s), value: 0xff

e1000e\_wrn\_regs\_read\_unknown WARNING: Rea...

[Read more...](/qemu/%2Bbug/1886362/comments/1)

Running with '-trace e1000\\*':
e1000e\_cb\_pci\_realize E1000E PCI realize entry
e1000e\_mac\_set\_permanent Set permanent MAC: 52:54:00:12:34:56
e1000e\_cfg\_support\_virtio Virtio header supported: 0
e1000e\_rx\_set\_cso RX CSO state set to 0
e1000e\_cb\_qdev\_reset E1000E qdev reset entry
e1000x\_mac\_indicate Indicating MAC to guest: 52:54:00:12:34:56
e1000x\_rx\_can\_recv\_disabled link\_up: 1, rx\_enabled 0, pci\_master 0
e1000x\_rx\_can\_recv\_disabled link\_up: 1, rx\_enabled 0, pci\_master 0
e1000e\_vm\_state\_running VM state is running
[R +0.094581] outl 0xcf8 0x80001010
[S +0.094604] OK
[R +0.094632] outl 0xcfc 0xe1020000
[S +0.094654] OK
[R +0.094668] outl 0xcf8 0x80001014
[S +0.094675] OK
[R +0.094694] outl 0xcf8 0x80001004
[S +0.094702] OK
[R +0.094712] outw 0xcfc 0x7
e1000e\_rx\_start\_recv
[S +0.096938] OK
[R +0.096960] outl 0xcf8 0x800010a2
[S +0.096972] OK
[R +0.096986] write 0xe102003b 0x1 0xff
e1000e\_core\_write Write to register 0x38, 4 byte(s), value: 0xff
e1000e\_vlan\_vet Setting VLAN ethernet type 0xFF
[S +0.097019] OK
[R +0.097034] write 0xe1020103 0x1e 0xffffff055c5e5c30be4511d084ffffffffffffffffffffffffffffffffff
e1000e\_core\_write Write to register 0x100, 4 byte(s), value: 0xff
e1000e\_rx\_set\_rctl RCTL = 0xff
e1000e\_rx\_desc\_buff\_sizes buffer sizes: [2048, 0, 0, 0]
e1000e\_rx\_desc\_len RX descriptor length: 16
e1000e\_rx\_start\_recv
e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x104, 4 byte(s), value: 0x5c05ffff
e1000e\_core\_write Write to register 0x2820, 4 byte(s), value: 0xbe305c5e
e1000e\_irq\_rdtr\_fpd\_not\_running FPD written while RDTR was not running
e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x10c, 4 byte(s), value: 0x84d01145
e1000e\_core\_write Write to register 0x2800, 4 byte(s), value: 0xffffffff
e1000e\_core\_write Write to register 0x2804, 4 byte(s), value: 0xffffffff
e1000e\_core\_write Write to register 0x2808, 4 byte(s), value: 0xffffffff
e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x11c, 4 byte(s), value: 0xffffffff
e1000e\_core\_write Write to register 0x2810, 4 byte(s), value: 0xff
[S +0.097143] OK
[R +0.097159] write 0xe1020420 0x4 0xffffffff
e1000e\_core\_write Write to register 0x3800, 4 byte(s), value: 0xffffffff
[S +0.097173] OK
[R +0.097183] write 0xe1020424 0x4 0xffffffff
e1000e\_core\_write Write to register 0x3804, 4 byte(s), value: 0xffffffff
[S +0.097196] OK
[R +0.097208] write 0xe102042b 0x1 0xff
e1000e\_core\_write Write to register 0x3808, 4 byte(s), value: 0xff
[S +0.097221] OK
[R +0.097231] write 0xe1020430 0x4 0x055c5e5c
e1000e\_core\_write Write to register 0x3810, 4 byte(s), value: 0x5c5e5c05
[S +0.097243] OK
[R +0.097253] write 0x5c041 0x1 0x04
[S +0.097914] OK
[R +0.097942] write 0x5c042 0x1 0x02
[S +0.097953] OK
[R +0.097964] write 0x5c043 0x1 0xe1
[S +0.097972] OK
[R +0.097984] write 0x5c048 0x1 0x8a
[S +0.097992] OK
[R +0.098003] write 0x5c04a 0x1 0x31
[S +0.098011] OK
[R +0.098022] write 0x5c04b 0x1 0xff
[S +0.098029] OK
[R +0.098040] write 0xe1020403 0x1 0xff
e1000e\_core\_write Write to register 0x400, 4 byte(s), value: 0xff
e1000e\_tx\_descr 0xe1020400 : ff31008a 0
e1000e\_core\_read Read from register 0x400, 4 byte(s), value: 0xff
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x404, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x408, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x40c, 4 byte(s)
e1000e\_core\_read Read from register 0x410, 4 byte(s), value: 0x602008
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x414, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x418, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x41c, 4 byte(s)
e1000e\_core\_read Read from register 0x3800, 4 byte(s), value: 0xfffffff0
e1000e\_core\_read Read from register 0x3804, 4 byte(s), value: 0xffffffff
e1000e\_core\_read Read from register 0x3808, 4 byte(s), value: 0x80
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x42c, 4 byte(s)
e1000e\_core\_read Read from register 0x3810, 4 byte(s), value: 0x5c05
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x434, 4 byte(s)
e1000e\_core\_read Read from register 0x3818, 4 byte(s), value: 0x0
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x43c, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x3820, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x444, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x448, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x44c, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x450, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x454, 4 byte(s)
e1000e\_core\_read Read from register 0x458, 4 byte(s), value: 0x0
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x45c, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x460, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x464, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x468, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x46c, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x470, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x474, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x478, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x47c, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x480, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x484, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x488, 4 byte(s)
e1000e\_rx\_receive\_iov Received vector of 4 fragments
e1000x\_vlan\_is\_vlan\_pkt Is VLAN packet: 0, ETH proto: 0x0, VET: 0xFF
e1000e\_rx\_rss\_started Starting RSS processing
e1000e\_rx\_rss\_disabled RSS is disabled
e1000e\_rx\_rss\_dispatched\_to\_queue Packet being dispatched to queue 0
e1000e\_ring\_free\_space ring #0: LEN: 1048448, DH: 255, DT: 0
e1000e\_rx\_has\_buffers ring #0: free descr: 65273, packet size 142, descr buffer size 2048
e1000e\_rx\_descr Next RX descriptor: ring #0, PA: 0xfe0, length: 16
e1000e\_rx\_null\_descriptor Null RX descriptor!!
e1000e\_rx\_descr Next RX descriptor: ring #0, PA: 0xff0, length: 16
e1000e\_rx\_null\_descriptor Null RX descriptor!!
e1000e\_rx\_descr Next RX descriptor: ring #0, PA: 0x1000, length: 16
e1000e\_rx\_null\_descriptor Null RX descriptor!!
e1000e\_rx\_descr Next RX descriptor: ring #0, PA: 0x1010, length: 16
e1000e\_rx\_null\_descriptor Null RX descriptor!!
[...]
e1000e\_rx\_descr Next RX descriptor: ring #0, PA: 0x5c020, length: 16
e1000e\_rx\_null\_descriptor Null RX descriptor!!
e1000e\_rx\_descr Next RX descriptor: ring #0, PA: 0x5c030, length: 16
e1000e\_rx\_null\_descriptor Null RX descriptor!!
e1000e\_rx\_descr Next RX descriptor: ring #0, PA: 0x5c040, length: 16
e1000e\_rx\_desc\_buff\_write buffer #0, addr: 0xe1020400, offset: 0, from: 0x631000028830, length: 14
e1000e\_core\_write Write to register 0x400, 4 byte(s), value: 0xff
e1000e\_tx\_descr 0xe1020400 : ff31008a 0
e1000e\_irq\_rearm\_timer Mitigation timer armed for register 0x3820, delay 0 ns
e1000e\_irq\_set\_cause\_entry Going to set IRQ cause 0x2, ICR: 0x0
e1000e\_irq\_set\_cause\_exit Set IRQ cause 0x3, ICR: 0x3
e1000e\_irq\_fix\_icr\_asserted ICR\_ASSERTED bit fixed: 0x80000003
e1000e\_irq\_pending\_interrupts ICR PENDING: 0x0 (ICR: 0x80000003, IMS: 0x0)
e1000e\_irq\_legacy\_notify IRQ line state: 0
e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x404, 4 byte(s), value: 0x0
e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x408, 4 byte(s), value: 0x0
e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x40c, 4 byte(s), value: 0x0
e1000e\_rx\_desc\_buff\_write buffer #0, addr: 0xe1020400, offset: 14, from: 0x62500024200e, length: 124
=================================================================
==32103==ERROR: AddressSanitizer: heap-use-after-free on address 0x62500024200e at pc 0x55cd3c40c9aa bp 0x7ffd97112bf0 sp 0x7ffd971123a0

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Jason Wang (jasowang)](https://launchpad.net/~jasowang) wrote on 2020-07-14:  [**Re: [Bug 1886362] [NEW] Heap use-after-free in lduw\_he\_p through e1000e\_write\_to\_rx\_buffers**](/qemu/%2Bbug/1886362/comments/2) |  |  | [#2](/qemu/%2Bbug/1886362/comments/2) |
| --- | --- | --- | --- |

On 2020/7/10 下午6:37, Li Qiang wrote:

> Paolo Bonzini <email address hidden> 于2020年7月10日周五 上午1:36写道：

>> On 09/07/20 17:51, Li Qiang wrote:

>>> Maybe we should check whether the address is a RAM address in 'dma\_memory\_rw'?

>>> But it is a hot path. I'm not sure it is right. Hope more discussion.

>> Half of the purpose of dma-helpers.c (as opposed to address\_space\_\*

>> functions in exec.c) is exactly to support writes to MMIO. This is

> Hi Paolo,

>

> Could you please explain more about this(to support writes to MMIO).

> I can just see the dma helpers with sg DMA, not related with MMIO.

Please refer doc/devel/memory.rst.

The motivation of memory API is to allow support modeling different

memory regions. DMA to MMIO is allowed in hardware so Qemu should

emulate this behaviour.

>

>

>> especially true of dma\_blk\_io, which takes care of doing the DMA via a

>> bounce buffer, possibly in multiple steps and even blocking due to

>> cpu\_register\_map\_client.

>>

>> For dma\_memory\_rw this is not needed, so it only needs to handle

>> QEMUSGList, but I think the design should be the same.

>>

>> However, this is indeed a nightmare for re-entrancy. The easiest

>> solution is to delay processing of descriptors to a bottom half whenever

>> MMIO is doing something complicated. This is also better for latency

>> because it will free the vCPU thread more quickly and leave the work to

>> the I/O thread.

> Do you mean we define a per-e1000e bottom half. And in the MMIO write

> or packet send

> trigger this bh?

Probably a TX bh.

> So even if we again trigger the MMIO write, then

> second bh will not be executed?

Bh is serialized so no re-entrancy issue.

Thanks

>

>

> Thanks,

> Li Qiang

>

>> Paolo

>>

On 2020/7/10 下午6:37, Li Qiang wrote:
> Paolo Bonzini <pbonzini@redhat.com> 于2020年7月10日周五 上午1:36写道：
>> On 09/07/20 17:51, Li Qiang wrote:
>>> Maybe we should check whether the address is a RAM address in 'dma\_memory\_rw'?
>>> But it is a hot path. I'm not sure it is right. Hope more discussion.
>> Half of the purpose of dma-helpers.c (as opposed to address\_space\_\*
>> functions in exec.c) is exactly to support writes to MMIO. This is
> Hi Paolo,
>
> Could you please explain more about this(to support writes to MMIO).
> I can just see the dma helpers with sg DMA, not related with MMIO.
Please refer doc/devel/memory.rst.
The motivation of memory API is to allow support modeling different
memory regions. DMA to MMIO is allowed in hardware so Qemu should
emulate this behaviour.
>
>
>> especially true of dma\_blk\_io, which takes care of doing the DMA via a
>> bounce buffer, possibly in multiple steps and even blocking due to
>> cpu\_register\_map\_client.
>>
>> For dma\_memory\_rw this is not needed, so it only needs to handle
>> QEMUSGList, but I think the design should be the same.
>>
>> However, this is indeed a nightmare for re-entrancy. The easiest
>> solution is to delay processing of descriptors to a bottom half whenever
>> MMIO is doing something complicated. This is also better for latency
>> because it will free the vCPU thread more quickly and leave the work to
>> the I/O thread.
> Do you mean we define a per-e1000e bottom half. And in the MMIO write
> or packet send
> trigger this bh?
Probably a TX bh.
> So even if we again trigger the MMIO write, then
> second bh will not be executed?
Bh is serialized so no re-entrancy issue.
Thanks
>
>
> Thanks,
> Li Qiang
>
>> Paolo
>>

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Jason Wang (jasowang)](https://launchpad.net/~jasowang) wrote on 2020-07-15: |  |  | [#3](/qemu/%2Bbug/1886362/comments/3) |
| --- | --- | --- | --- |

On 2020/7/14 下午6:48, Li Qiang wrote:

> Jason Wang <email address hidden> 于2020年7月14日周二 下午4:56写道：

>>

>> On 2020/7/10 下午6:37, Li Qiang wrote:

>>> Paolo Bonzini <email address hidden> 于2020年7月10日周五 上午1:36写道：

>>>> On 09/07/20 17:51, Li Qiang wrote:

>>>>> Maybe we should check whether the address is a RAM address in 'dma\_memory\_rw'?

>>>>> But it is a hot path. I'm not sure it is right. Hope more discussion.

>>>> Half of the purpose of dma-helpers.c (as opposed to address\_space\_\*

>>>> functions in exec.c) is exactly to support writes to MMIO. This is

>>> Hi Paolo,

>>>

>>> Could you please explain more about this(to support writes to MMIO).

>>> I can just see the dma helpers with sg DMA, not related with MMIO.

>>

>> Please refer doc/devel/memory.rst.

>>

>> The motivation of memory API is to allow support modeling different

>> memory regions. DMA to MMIO is allowed in hardware so Qemu should

>> emulate this behaviour.

>>

> I just read the code again.

> So the dma\_blk\_io is used for some device that will need DMA to

> MMIO(may be related with

> device spec). But for most of the devices(networking card for

> example) there is no need this DMA to MMIO.

> So we just ksuse dma\_memory\_rw. Is this understanding right?

>

> Then another question.

> Though the dma helpers uses a bouncing buffer, it finally write to the

> device addressspace in 'address\_space\_unmap'.

> Is there any posibility that we can again write to the MMIO like this issue?

I think the point is to make DMA to MMIO work as real hardware. For

e1000e and other networking devices we need make sure such DMA doesn't

break anything.

Thanks

>

>

>>>

>>>> especially true of dma\_blk\_io, which takes care of doing the DMA via a

>>>> bounce buffer, possibly in multiple steps and even blocking due to

>>>> cpu\_register\_map\_client.

>>>>

>>>> For dma\_memory\_rw this is not needed, so it only needs to handle

>>>> QEMUSGList, but I think the design should be the same.

>>>>

>>>> However, this is indeed a nightmare for re-entrancy. The easiest

>>>> solution is to delay processing of descriptors to a bottom half whenever

>>>> MMIO is doing something complicated. This is also better for latency

>>>> because it will free the vCPU thread more quickly and leave the work to

>>>> the I/O thread.

>>> Do you mean we define a per-e1000e bottom half. And in the MMIO write

>>> or packet send

>>> trigger this bh?

>>

>> Probably a TX bh.

>>

> I will try to write this tx bh to strength my understanding in this part.

> Maybe reference the virtio-net implementation I think.

>

>

>

> Thanks,

> Li Qiang

>

>>> So even if we again trigger the MMIO write, then

>>> second bh will not be executed?

>>

>> Bh is serialized so no re-entrancy issue.

>>

>> Thanks

>>

>>

>>>

>>> Thanks,

>>> Li Qiang

>>>

>>>> Paolo

>>>>

On 2020/7/14 下午6:48, Li Qiang wrote:
> Jason Wang <jasowang@redhat.com> 于2020年7月14日周二 下午4:56写道：
>>
>> On 2020/7/10 下午6:37, Li Qiang wrote:
>>> Paolo Bonzini <pbonzini@redhat.com> 于2020年7月10日周五 上午1:36写道：
>>>> On 09/07/20 17:51, Li Qiang wrote:
>>>>> Maybe we should check whether the address is a RAM address in 'dma\_memory\_rw'?
>>>>> But it is a hot path. I'm not sure it is right. Hope more discussion.
>>>> Half of the purpose of dma-helpers.c (as opposed to address\_space\_\*
>>>> functions in exec.c) is exactly to support writes to MMIO. This is
>>> Hi Paolo,
>>>
>>> Could you please explain more about this(to support writes to MMIO).
>>> I can just see the dma helpers with sg DMA, not related with MMIO.
>>
>> Please refer doc/devel/memory.rst.
>>
>> The motivation of memory API is to allow support modeling different
>> memory regions. DMA to MMIO is allowed in hardware so Qemu should
>> emulate this behaviour.
>>
> I just read the code again.
> So the dma\_blk\_io is used for some device that will need DMA to
> MMIO(may be related with
> device spec). But for most of the devices(networking card for
> example) there is no need this DMA to MMIO.
> So we just ksuse dma\_memory\_rw. Is this understanding right?
>
> Then another question.
> Though the dma helpers uses a bouncing buffer, it finally write to the
> device addressspace in 'address\_space\_unmap'.
> Is there any posibility that we can again write to the MMIO like this issue?
I think the point is to make DMA to MMIO work as real hardware. For
e1000e and other networking devices we need make sure such DMA doesn't
break anything.
Thanks
>
>
>>>
>>>> especially true of dma\_blk\_io, which takes care of doing the DMA via a
>>>> bounce buffer, possibly in multiple steps and even blocking due to
>>>> cpu\_register\_map\_client.
>>>>
>>>> For dma\_memory\_rw this is not needed, so it only needs to handle
>>>> QEMUSGList, but I think the design should be the same.
>>>>
>>>> However, this is indeed a nightmare for re-entrancy. The easiest
>>>> solution is to delay processing of descriptors to a bottom half whenever
>>>> MMIO is doing something complicated. This is also better for latency
>>>> because it will free the vCPU thread more quickly and leave the work to
>>>> the I/O thread.
>>> Do you mean we define a per-e1000e bottom half. And in the MMIO write
>>> or packet send
>>> trigger this bh?
>>
>> Probably a TX bh.
>>
> I will try to write this tx bh to strength my understanding in this part.
> Maybe reference the virtio-net implementation I think.
>
>
>
> Thanks,
> Li Qiang
>
>>> So even if we again trigger the MMIO write, then
>>> second bh will not be executed?
>>
>> Bh is serialized so no re-entrancy issue.
>>
>> Thanks
>>
>>
>>>
>>> Thanks,
>>> Li Qiang
>>>
>>>> Paolo
>>>>

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [P J P (pjps)](https://launchpad.net/~pjps) wrote on 2020-07-21: |  |  | [#4](/qemu/%2Bbug/1886362/comments/4) |
| --- | --- | --- | --- |

Another reproducer: (just to record)

cat << EOF | ./i386-softmmu/qemu-system-i386 -M pc-q35-5.0 \

-netdev user,id=qtest-bn0 -device e1000e,netdev=qtest-bn0 \

-display none -nodefaults -nographic -qtest stdio

outl 0xcf8 0x80000810

outl 0xcfc 0xe0000000

outl 0xcf8 0x80000804

outw 0xcfc 0x7

write 0xe0000758 0x4 0xfffff1ff

write 0xe0000760 0x6 0xffffdf000000

write 0xe0000768 0x4 0x0efffff1

write 0xe0005008 0x4 0x18ffff27

write 0xe0000c 0x1 0x66

write 0xe03320 0x1 0xff

write 0xe03620 0x1 0xff

write 0xe00000f3 0x1 0xdf

write 0xe0000100 0x6 0xdfffffdf0000

write 0xe0000110 0x5 0xdfffffdf00

write 0xe000011a 0x3 0xffffff

write 0xe0000128 0x5 0x7e00ffffff

write 0xe0000403 0x1 0xdf

write 0xe0000420 0x4 0xdfffffdf

write 0xe000042a 0x3 0xffffff

write 0xe0000438 0x1 0x7e

EOF

-> <https://lists.gnu.org/archive/html/qemu-devel/2020-07/msg05709.html>

Another reproducer: (just to record)
cat << EOF | ./i386-softmmu/qemu-system-i386 -M pc-q35-5.0 \
-netdev user,id=qtest-bn0 -device e1000e,netdev=qtest-bn0 \
-display none -nodefaults -nographic -qtest stdio
outl 0xcf8 0x80000810
outl 0xcfc 0xe0000000
outl 0xcf8 0x80000804
outw 0xcfc 0x7
write 0xe0000758 0x4 0xfffff1ff
write 0xe0000760 0x6 0xffffdf000000
write 0xe0000768 0x4 0x0efffff1
write 0xe0005008 0x4 0x18ffff27
write 0xe0000c 0x1 0x66
write 0xe03320 0x1 0xff
write 0xe03620 0x1 0xff
write 0xe00000f3 0x1 0xdf
write 0xe0000100 0x6 0xdfffffdf0000
write 0xe0000110 0x5 0xdfffffdf00
write 0xe000011a 0x3 0xffffff
write 0xe0000128 0x5 0x7e00ffffff
write 0xe0000403 0x1 0xdf
write 0xe0000420 0x4 0xdfffffdf
write 0xe000042a 0x3 0xffffff
write 0xe0000438 0x1 0x7e
EOF
-> https://lists.gnu.org/archive/html/qemu-devel/2020-07/msg05709.html

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Peter Maydell (pmaydell)](https://launchpad.net/~pmaydell) wrote on 2020-07-21: |  |  | [#5](/qemu/%2Bbug/1886362/comments/5) |
| --- | --- | --- | --- |

On Wed, 15 Jul 2020 at 09:36, Jason Wang <email address hidden> wrote:

> I think the point is to make DMA to MMIO work as real hardware.

I wouldn't care to give a 100% guarantee that asking a real

h/w device to DMA to itself didn't cause it to misbehave :-)

It's more likely to happen-to-work because the DMA engine bit

of a real h/w device is going to be decoupled somewhat from

the respond-to-memory-transactions-for-registers logic, but

it probably wasn't something the designers were actively

thinking about either...

> For

> e1000e and other networking devices we need make sure such DMA doesn't

> break anything.

Yeah, this is the interesting part for QEMU. How should we

structure devices that do DMA so that we can be sure that

the device emulation at least doesn't crash? We could have

a rule that all devices that do DMA must always postpone

all of that DMA to a bottom-half, but that's a lot of

refactoring of a lot of device code...

thanks

-- PMM

On Wed, 15 Jul 2020 at 09:36, Jason Wang <jasowang@redhat.com> wrote:
> I think the point is to make DMA to MMIO work as real hardware.
I wouldn't care to give a 100% guarantee that asking a real
h/w device to DMA to itself didn't cause it to misbehave :-)
It's more likely to happen-to-work because the DMA engine bit
of a real h/w device is going to be decoupled somewhat from
the respond-to-memory-transactions-for-registers logic, but
it probably wasn't something the designers were actively
thinking about either...
> For
> e1000e and other networking devices we need make sure such DMA doesn't
> break anything.
Yeah, this is the interesting part for QEMU. How should we
structure devices that do DMA so that we can be sure that
the device emulation at least doesn't crash? We could have
a rule that all devices that do DMA must always postpone
all of that DMA to a bottom-half, but that's a lot of
refactoring of a lot of device code...
thanks
-- PMM

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Jason Wang (jasowang)](https://launchpad.net/~jasowang) wrote on 2020-07-21: |  |  | [#6](/qemu/%2Bbug/1886362/comments/6) |
| --- | --- | --- | --- |

On 2020/7/21 下午8:31, Peter Maydell wrote:

> On Wed, 15 Jul 2020 at 09:36, Jason Wang <email address hidden> wrote:

>> I think the point is to make DMA to MMIO work as real hardware.

> I wouldn't care to give a 100% guarantee that asking a real

> h/w device to DMA to itself didn't cause it to misbehave :-)

> It's more likely to happen-to-work because the DMA engine bit

> of a real h/w device is going to be decoupled somewhat from

> the respond-to-memory-transactions-for-registers logic, but

> it probably wasn't something the designers were actively

> thinking about either...

I think some device want such peer to peer transactions:

<https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst>

>

>> For

>> e1000e and other networking devices we need make sure such DMA doesn't

>> break anything.

> Yeah, this is the interesting part for QEMU. How should we

> structure devices that do DMA so that we can be sure that

> the device emulation at least doesn't crash? We could have

> a rule that all devices that do DMA must always postpone

> all of that DMA to a bottom-half, but that's a lot of

> refactoring of a lot of device code...

It looks to me the issue happens only for device with loopback

Simply git grep loopback in hw/net tells me we probably need only to

audit dp8393x and rtl8139.

Qiang, want to help to audit those devices?

Thanks

>

> thanks

> -- PMM

>

On 2020/7/21 下午8:31, Peter Maydell wrote:
> On Wed, 15 Jul 2020 at 09:36, Jason Wang <jasowang@redhat.com> wrote:
>> I think the point is to make DMA to MMIO work as real hardware.
> I wouldn't care to give a 100% guarantee that asking a real
> h/w device to DMA to itself didn't cause it to misbehave :-)
> It's more likely to happen-to-work because the DMA engine bit
> of a real h/w device is going to be decoupled somewhat from
> the respond-to-memory-transactions-for-registers logic, but
> it probably wasn't something the designers were actively
> thinking about either...
I think some device want such peer to peer transactions:
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst
>
>> For
>> e1000e and other networking devices we need make sure such DMA doesn't
>> break anything.
> Yeah, this is the interesting part for QEMU. How should we
> structure devices that do DMA so that we can be sure that
> the device emulation at least doesn't crash? We could have
> a rule that all devices that do DMA must always postpone
> all of that DMA to a bottom-half, but that's a lot of
> refactoring of a lot of device code...
It looks to me the issue happens only for device with loopback
Simply git grep loopback in hw/net tells me we probably need only to
audit dp8393x and rtl8139.
Qiang, want to help to audit those devices?
Thanks
>
> thanks
> -- PMM
>

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Peter Maydell (pmaydell)](https://launchpad.net/~pmaydell) wrote on 2020-07-21: |  |  | [#7](/qemu/%2Bbug/1886362/comments/7) |
| --- | --- | --- | --- |

On Tue, 21 Jul 2020 at 14:21, Jason Wang <email address hidden> wrote:

> On 2020/7/21 下午8:31, Peter Maydell wrote:

> > On Wed, 15 Jul 2020 at 09:36, Jason Wang <email address hidden> wrote:

> >> I think the point is to make DMA to MMIO work as real hardware.

> > I wouldn't care to give a 100% guarantee that asking a real

> > h/w device to DMA to itself didn't cause it to misbehave :-)

> > It's more likely to happen-to-work because the DMA engine bit

> > of a real h/w device is going to be decoupled somewhat from

> > the respond-to-memory-transactions-for-registers logic, but

> > it probably wasn't something the designers were actively

> > thinking about either...

> I think some device want such peer to peer transactions:

>

> <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst>

That's a device DMAing to another device, not DMAing to \*itself\*

(device-to-another-device DMA should work fine in QEMU). And only

a very few devices will ever be sensible targets of the DMA --

basically things like nvme that have a looks-like-memory area,

or special cases like doorbell registers.

> > Yeah, this is the interesting part for QEMU. How should we

> > structure devices that do DMA so that we can be sure that

> > the device emulation at least doesn't crash? We could have

> > a rule that all devices that do DMA must always postpone

> > all of that DMA to a bottom-half, but that's a lot of

> > refactoring of a lot of device code...

>

>

> It looks to me the issue happens only for device with loopback

I think in principle we have a problem for any device that

(a) has memory mapped registers and (b) does DMA reads

whose address is guest-controlled. Loopback isn't a

requirement -- if the guest programs, say, an RX descriptor

base address to point at the device's own registers, you

get exactly the same kind of unexpected-reentrancy.

thanks

-- PMM

On Tue, 21 Jul 2020 at 14:21, Jason Wang <jasowang@redhat.com> wrote:
> On 2020/7/21 下午8:31, Peter Maydell wrote:
> > On Wed, 15 Jul 2020 at 09:36, Jason Wang <jasowang@redhat.com> wrote:
> >> I think the point is to make DMA to MMIO work as real hardware.
> > I wouldn't care to give a 100% guarantee that asking a real
> > h/w device to DMA to itself didn't cause it to misbehave :-)
> > It's more likely to happen-to-work because the DMA engine bit
> > of a real h/w device is going to be decoupled somewhat from
> > the respond-to-memory-transactions-for-registers logic, but
> > it probably wasn't something the designers were actively
> > thinking about either...
> I think some device want such peer to peer transactions:
>
> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst
That's a device DMAing to another device, not DMAing to \*itself\*
(device-to-another-device DMA should work fine in QEMU). And only
a very few devices will ever be sensible targets of the DMA --
basically things like nvme that have a looks-like-memory area,
or special cases like doorbell registers.
> > Yeah, this is the interesting part for QEMU. How should we
> > structure devices that do DMA so that we can be sure that
> > the device emulation at least doesn't crash? We could have
> > a rule that all devices that do DMA must always postpone
> > all of that DMA to a bottom-half, but that's a lot of
> > refactoring of a lot of device code...
>
>
> It looks to me the issue happens only for device with loopback
I think in principle we have a problem for any device that
(a) has memory mapped registers and (b) does DMA reads
whose address is guest-controlled. Loopback isn't a
requirement -- if the guest programs, say, an RX descriptor
base address to point at the device's own registers, you
get exactly the same kind of unexpected-reentrancy.
thanks
-- PMM

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Alexander Bulekov (a1xndr)](https://launchpad.net/~a1xndr) wrote on 2020-07-21: |  |  | [#8](/qemu/%2Bbug/1886362/comments/8) |
| --- | --- | --- | --- |

On 200721 1444, Peter Maydell wrote:

> On Tue, 21 Jul 2020 at 14:21, Jason Wang <email address hidden> wrote:

> > On 2020/7/21 下午8:31, Peter Maydell wrote:

> > > On Wed, 15 Jul 2020 at 09:36, Jason Wang <email address hidden> wrote:

> > >> I think the point is to make DMA to MMIO work as real hardware.

> > > I wouldn't care to give a 100% guarantee that asking a real

> > > h/w device to DMA to itself didn't cause it to misbehave :-)

> > > It's more likely to happen-to-work because the DMA engine bit

> > > of a real h/w device is going to be decoupled somewhat from

> > > the respond-to-memory-transactions-for-registers logic, but

> > > it probably wasn't something the designers were actively

> > > thinking about either...

>

I searched around but couldn't find anything talking about this case for

real hardware. I also looked at some HDL code for FPGAs that do DMA, but

it seems most of the PCI DMA components are contained in proprietary

IPs, though maybe I'm missing something (I've never programmed

a DMA-capable FPGA).

> > I think some device want such peer to peer transactions:

> >

> > <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst>

>

> That's a device DMAing to another device, not DMAing to \*itself\*

> (device-to-another-device DMA should work fine in QEMU). And only

> a very few devices will ever be sensible targets of the DMA --

> basically things like nvme that have a looks-like-memory area,

> or special cases like doorbell registers.

>

> > > Yeah, this is the interesting part for QEMU. How should we

> > > structure devices that do DMA so that we can be sure that

> > > the device emulation at least doesn't crash? We could have

> > > a rule that all devices that do DMA must always postpone

> > > all of that DMA to a bottom-half, but that's a lot of

> > > refactoring of a lot of device code...

> >

> >

> > It looks to me the issue happens only for device with loopback

>

> I think in principle we have a problem for any device that

> (a) has memory mapped registers and (b) does DMA reads

> whose address is guest-controlled. Loopback isn't a

> requirement -- if the guest programs, say, an RX descriptor

> base address to point at the device's own registers, you

> get exactly the same kind of unexpected-reentrancy.

Could this be something that we check for in the

pci\_dma\_\* functions in hw/pci/pci.h? There we still have context about

the source device for the dma read/write and could, compare addr against

the device's PCI BARr's. Not sure about:

1.) How to do this without the overhead of convering the addr

to a MemoryRegion, which is normally done, once, at the flatview\_write

stage.

2.) What to do if we catch such a DMA request? Quietly drop it?

3.) Non-PCI devices.

I think this still doesn't cover the even crazier case where:

CPU writes to DEV\_A's MMIO

DEV\_A writes to DEV\_B's MMIO

DEV\_B writes to DEV\_A's MMIO

and neither DEV\_A or DEV\_B use BHs...

-Alex

> thanks

> -- PMM

>

On 200721 1444, Peter Maydell wrote:
> On Tue, 21 Jul 2020 at 14:21, Jason Wang <jasowang@redhat.com> wrote:
> > On 2020/7/21 下午8:31, Peter Maydell wrote:
> > > On Wed, 15 Jul 2020 at 09:36, Jason Wang <jasowang@redhat.com> wrote:
> > >> I think the point is to make DMA to MMIO work as real hardware.
> > > I wouldn't care to give a 100% guarantee that asking a real
> > > h/w device to DMA to itself didn't cause it to misbehave :-)
> > > It's more likely to happen-to-work because the DMA engine bit
> > > of a real h/w device is going to be decoupled somewhat from
> > > the respond-to-memory-transactions-for-registers logic, but
> > > it probably wasn't something the designers were actively
> > > thinking about either...
>
I searched around but couldn't find anything talking about this case for
real hardware. I also looked at some HDL code for FPGAs that do DMA, but
it seems most of the PCI DMA components are contained in proprietary
IPs, though maybe I'm missing something (I've never programmed
a DMA-capable FPGA).
> > I think some device want such peer to peer transactions:
> >
> > https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst
>
> That's a device DMAing to another device, not DMAing to \*itself\*
> (device-to-another-device DMA should work fine in QEMU). And only
> a very few devices will ever be sensible targets of the DMA --
> basically things like nvme that have a looks-like-memory area,
> or special cases like doorbell registers.
>
> > > Yeah, this is the interesting part for QEMU. How should we
> > > structure devices that do DMA so that we can be sure that
> > > the device emulation at least doesn't crash? We could have
> > > a rule that all devices that do DMA must always postpone
> > > all of that DMA to a bottom-half, but that's a lot of
> > > refactoring of a lot of device code...
> >
> >
> > It looks to me the issue happens only for device with loopback
>
> I think in principle we have a problem for any device that
> (a) has memory mapped registers and (b) does DMA reads
> whose address is guest-controlled. Loopback isn't a
> requirement -- if the guest programs, say, an RX descriptor
> base address to point at the device's own registers, you
> get exactly the same kind of unexpected-reentrancy.
Could this be something that we check for in the
pci\_dma\_\* functions in hw/pci/pci.h? There we still have context about
the source device for the dma read/write and could, compare addr against
the device's PCI BARr's. Not sure about:
1.) How to do this without the overhead of convering the addr
to a MemoryRegion, which is normally done, once, at the flatview\_write
stage.
2.) What to do if we catch such a DMA request? Quietly drop it?
3.) Non-PCI devices.
I think this still doesn't cover the even crazier case where:
CPU writes to DEV\_A's MMIO
DEV\_A writes to DEV\_B's MMIO
DEV\_B writes to DEV\_A's MMIO
and neither DEV\_A or DEV\_B use BHs...
-Alex
> thanks
> -- PMM
>

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Jason Wang (jasowang)](https://launchpad.net/~jasowang) wrote on 2020-07-22: |  |  | [#9](/qemu/%2Bbug/1886362/comments/9) |
| --- | --- | --- | --- |

On 2020/7/21 下午9:44, Peter Maydell wrote:

> On Tue, 21 Jul 2020 at 14:21, Jason Wang <email address hidden> wrote:

>> On 2020/7/21 下午8:31, Peter Maydell wrote:

>>> On Wed, 15 Jul 2020 at 09:36, Jason Wang <email address hidden> wrote:

>>>> I think the point is to make DMA to MMIO work as real hardware.

>>> I wouldn't care to give a 100% guarantee that asking a real

>>> h/w device to DMA to itself didn't cause it to misbehave :-)

>>> It's more likely to happen-to-work because the DMA engine bit

>>> of a real h/w device is going to be decoupled somewhat from

>>> the respond-to-memory-transactions-for-registers logic, but

>>> it probably wasn't something the designers were actively

>>> thinking about either...

>> I think some device want such peer to peer transactions:

>>

>> <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst>

> That's a device DMAing to another device, not DMAing to \*itself\*

> (device-to-another-device DMA should work fine in QEMU). And only

> a very few devices will ever be sensible targets of the DMA --

> basically things like nvme that have a looks-like-memory area,

> or special cases like doorbell registers.

Well, my understanding is:

- it's not about whether or not we have an actual device that can do DMA

into itself but whether it's allowed by PCI spec

- it's not really matter whether or not it tries to DMA into itself.

Devices could be taught to DMA into each other's RX:

e1000e(1) RX DMA to e1000e(2) MMIO (RX)

e1000e(2) RX DMA to e1000e(1) RX

So we get re-reentrancy again.

>

>>> Yeah, this is the interesting part for QEMU. How should we

>>> structure devices that do DMA so that we can be sure that

>>> the device emulation at least doesn't crash? We could have

>>> a rule that all devices that do DMA must always postpone

>>> all of that DMA to a bottom-half, but that's a lot of

>>> refactoring of a lot of device code...

>>

>> It looks to me the issue happens only for device with loopback

> I think in principle we have a problem for any device that

> (a) has memory mapped registers and (b) does DMA reads

> whose address is guest-controlled. Loopback isn't a

> requirement -- if the guest programs, say, an RX descriptor

> base address to point at the device's own registers, you

> get exactly the same kind of unexpected-reentrancy.

Right, so about the solution, instead of refactoring DMA I wonder we can

simply detect and fail the RX by device itself.

Thanks

>

> thanks

> -- PMM

>

On 2020/7/21 下午9:44, Peter Maydell wrote:
> On Tue, 21 Jul 2020 at 14:21, Jason Wang <jasowang@redhat.com> wrote:
>> On 2020/7/21 下午8:31, Peter Maydell wrote:
>>> On Wed, 15 Jul 2020 at 09:36, Jason Wang <jasowang@redhat.com> wrote:
>>>> I think the point is to make DMA to MMIO work as real hardware.
>>> I wouldn't care to give a 100% guarantee that asking a real
>>> h/w device to DMA to itself didn't cause it to misbehave :-)
>>> It's more likely to happen-to-work because the DMA engine bit
>>> of a real h/w device is going to be decoupled somewhat from
>>> the respond-to-memory-transactions-for-registers logic, but
>>> it probably wasn't something the designers were actively
>>> thinking about either...
>> I think some device want such peer to peer transactions:
>>
>> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst
> That's a device DMAing to another device, not DMAing to \*itself\*
> (device-to-another-device DMA should work fine in QEMU). And only
> a very few devices will ever be sensible targets of the DMA --
> basically things like nvme that have a looks-like-memory area,
> or special cases like doorbell registers.
Well, my understanding is:
- it's not about whether or not we have an actual device that can do DMA
into itself but whether it's allowed by PCI spec
- it's not really matter whether or not it tries to DMA into itself.
Devices could be taught to DMA into each other's RX:
e1000e(1) RX DMA to e1000e(2) MMIO (RX)
e1000e(2) RX DMA to e1000e(1) RX
So we get re-reentrancy again.
>
>>> Yeah, this is the interesting part for QEMU. How should we
>>> structure devices that do DMA so that we can be sure that
>>> the device emulation at least doesn't crash? We could have
>>> a rule that all devices that do DMA must always postpone
>>> all of that DMA to a bottom-half, but that's a lot of
>>> refactoring of a lot of device code...
>>
>> It looks to me the issue happens only for device with loopback
> I think in principle we have a problem for any device that
> (a) has memory mapped registers and (b) does DMA reads
> whose address is guest-controlled. Loopback isn't a
> requirement -- if the guest programs, say, an RX descriptor
> base address to point at the device's own registers, you
> get exactly the same kind of unexpected-reentrancy.
Right, so about the solution, instead of refactoring DMA I wonder we can
simply detect and fail the RX by device itself.
Thanks
>
> thanks
> -- PMM
>

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Jason Wang (jasowang)](https://launchpad.net/~jasowang) wrote on 2020-07-22: |  |  | [#10](/qemu/%2Bbug/1886362/comments/10) |
| --- | --- | --- | --- |

On 2020/7/21 下午9:46, Li Qiang wrote:

> Jason Wang <email address hidden> 于2020年7月21日周二 下午9:21写道：

>>

>> On 2020/7/21 下午8:31, Peter Maydell wrote:

>>> On Wed, 15 Jul 2020 at 09:36, Jason Wang <email address hidden> wrote:

>>>> I think the point is to make DMA to MMIO work as real hardware.

>>> I wouldn't care to give a 100% guarantee that asking a real

>>> h/w device to DMA to itself didn't cause it to misbehave :-)

>>> It's more likely to happen-to-work because the DMA engine bit

>>> of a real h/w device is going to be decoupled somewhat from

>>> the respond-to-memory-transactions-for-registers logic, but

>>> it probably wasn't something the designers were actively

>>> thinking about either...

>>

>> I think some device want such peer to peer transactions:

>>

>> <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst>

>>

>>

>>>> For

>>>> e1000e and other networking devices we need make sure such DMA doesn't

>>>> break anything.

>>> Yeah, this is the interesting part for QEMU. How should we

>>> structure devices that do DMA so that we can be sure that

>>> the device emulation at least doesn't crash? We could have

>>> a rule that all devices that do DMA must always postpone

>>> all of that DMA to a bottom-half, but that's a lot of

>>> refactoring of a lot of device code...

>>

>> It looks to me the issue happens only for device with loopback

> IMO I think this is not related-loopback.

>

> It happens when the guest write the MMIO address to the device's

> DMA-related registers.

> The one we see UAF occurs in loopback device because the same

> structure uses in re-entry.

> But we can't say there are no issue for non-loopback device.

Yes.

>> Simply git grep loopback in hw/net tells me we probably need only to

>> audit dp8393x and rtl8139.

>>

>> Qiang, want to help to audit those devices?

> No problem. Once I finish the e1000e patch I will try to audit those and

> also try to audit some no-loopback device re-entry issue.

Thanks.

>

> Thanks,

> Li Qiang

>

>> Thanks

>>

>>

>>> thanks

>>> -- PMM

>>>

On 2020/7/21 下午9:46, Li Qiang wrote:
> Jason Wang <jasowang@redhat.com> 于2020年7月21日周二 下午9:21写道：
>>
>> On 2020/7/21 下午8:31, Peter Maydell wrote:
>>> On Wed, 15 Jul 2020 at 09:36, Jason Wang <jasowang@redhat.com> wrote:
>>>> I think the point is to make DMA to MMIO work as real hardware.
>>> I wouldn't care to give a 100% guarantee that asking a real
>>> h/w device to DMA to itself didn't cause it to misbehave :-)
>>> It's more likely to happen-to-work because the DMA engine bit
>>> of a real h/w device is going to be decoupled somewhat from
>>> the respond-to-memory-transactions-for-registers logic, but
>>> it probably wasn't something the designers were actively
>>> thinking about either...
>>
>> I think some device want such peer to peer transactions:
>>
>> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst
>>
>>
>>>> For
>>>> e1000e and other networking devices we need make sure such DMA doesn't
>>>> break anything.
>>> Yeah, this is the interesting part for QEMU. How should we
>>> structure devices that do DMA so that we can be sure that
>>> the device emulation at least doesn't crash? We could have
>>> a rule that all devices that do DMA must always postpone
>>> all of that DMA to a bottom-half, but that's a lot of
>>> refactoring of a lot of device code...
>>
>> It looks to me the issue happens only for device with loopback
> IMO I think this is not related-loopback.
>
> It happens when the guest write the MMIO address to the device's
> DMA-related registers.
> The one we see UAF occurs in loopback device because the same
> structure uses in re-entry.
> But we can't say there are no issue for non-loopback device.
Yes.
>> Simply git grep loopback in hw/net tells me we probably need only to
>> audit dp8393x and rtl8139.
>>
>> Qiang, want to help to audit those devices?
> No problem. Once I finish the e1000e patch I will try to audit those and
> also try to audit some no-loopback device re-entry issue.
Thanks.
>
> Thanks,
> Li Qiang
>
>> Thanks
>>
>>
>>> thanks
>>> -- PMM
>>>

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Thomas Huth (th-huth)](https://launchpad.net/~th-huth) wrote on 2021-05-26: |  |  | [#11](/qemu/%2Bbug/1886362/comments/11) |
| --- | --- | --- | --- |

I can reproduce this problem with QEMU v5.0, but with the current

version, it does not run into this assertion anymore. Seems like this

problem got fixed in the course of time? Could you please check whether

you could still reproduce this?

I can reproduce this problem with QEMU v5.0, but with the current
version, it does not run into this assertion anymore. Seems like this
problem got fixed in the course of time? Could you please check whether
you could still reproduce this?

| Changed in qemu: | |
| --- | --- |
| **status**: | New → Incomplete |

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Alexander Bulekov (a1xndr)](https://launchpad.net/~a1xndr) wrote on 2021-06-14 (last edit on 2021-06-14): |  |  | [#12](/qemu/%2Bbug/1886362/comments/12) |
| --- | --- | --- | --- |

This should have been fixed by the qemu\_receive\_packet/network loopback patches from a few months ago

This should have been fixed by the qemu\_receive\_packet/network loopback patches from a few months ago

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Thomas Huth (th-huth)](https://launchpad.net/~th-huth) wrote on 2021-06-15: |  |  | [#13](/qemu/%2Bbug/1886362/comments/13) |
| --- | --- | --- | --- |

Ok, let's mark this as fixed.

Ok, let's mark this as fixed.

| Changed in qemu: | |
| --- | --- |
| **status**: | Incomplete → Fix Released |

[See full activity log](https://bugs.launchpad.net/qemu/%2Bbug/1886362/%2Bactivity)

To post a comment you must [log in](%2Blogin?comments=all).

* [Report a bug](/qemu/%2Bfilebug)

This report contains
**Public**
information

Everyone can see this information.

You are
[not directly subscribed to this bug's notifications.](/qemu/%2Bbug/1886362/%2Bsubscribe)

Subscribing...

* [Edit bug mail](https://bugs.launchpad.net/qemu/%2Bbug/1886362/%2Bsubscriptions "View and change your subscriptions to this bug")

## Other bug subscribers

[Subscribe someone else](https://bugs.launchpad.net/qemu/%2Bbug/1886362/%2Baddsubscriber "Launchpad will email that person whenever this bugs changes")

## Remote bug watches

Bug watches keep track of this bug in other bug trackers.

[![Launchpad](/@@/launchpad-footer-logo.svg)](https://launchpad.net/)
 •
[Take the tour](https://launchpad.net/%2Btour)
 •
[Read the guide](https://help.launchpad.net/)

© 2004
[Canonical Ltd.](http://canonical.com/)
 •
[Terms of use](https://launchpad.net/legal)
 •
[Data privacy](https://www.ubuntu.com/legal/dataprivacy)
 •
[Contact Launchpad Support](/feedback)
 •
[Blog](http://blog.launchpad.net/)
 •
[Careers](https://canonical.com/careers)
 •
[System status](https://ubuntu.social/%40launchpadstatus)
 •
6394e03
([Get the code!](https://dev.launchpad.net/))



=== Content from bugs.launchpad.net_bf6f3d28_20250119_140742.html ===

[Log in / Register](https://bugs.launchpad.net/qemu/%2Bbug/1886362/%2Blogin)

[![](https://launchpadlibrarian.net/27372372/qemu_64.png)](https://launchpad.net/qemu)

## [QEMU](https://launchpad.net/qemu)

* [Overview](https://launchpad.net/qemu)
* [Code](https://code.launchpad.net/qemu)
* [Bugs](https://bugs.launchpad.net/qemu)
* [Blueprints](https://blueprints.launchpad.net/qemu)
* [Translations](https://translations.launchpad.net/qemu)
* [Answers](https://answers.launchpad.net/qemu)

# Heap use-after-free in lduw\_he\_p through e1000e\_write\_to\_rx\_buffers

Bug #1886362 reported by
[Alexander Bulekov](https://launchpad.net/~a1xndr)
on 2020-07-06

[8](/%2Bhelp-bugs/bug-heat.html)

This bug affects 1 person

| Affects | | Status | Importance | Assigned to | Milestone |
| --- | --- | --- | --- | --- | --- |
|  | [QEMU](https://bugs.launchpad.net/qemu) | Fix Released | Undecided | Unassigned |  |

### Bug Description

Hello,

This reproducer causes a heap-use-after free. QEMU Built with --enable-sanitizers:

cat << EOF | ./i386-softmmu/qemu-system-i386 -M q35,accel=qtest \

-qtest stdio -nographic -monitor none -serial none

outl 0xcf8 0x80001010

outl 0xcfc 0xe1020000

outl 0xcf8 0x80001014

outl 0xcf8 0x80001004

outw 0xcfc 0x7

outl 0xcf8 0x800010a2

write 0xe102003b 0x1 0xff

write 0xe1020103 0x1e 0xffffff055c5e5c30be4511d084ffffffffffffffffffffffffffffffffff

write 0xe1020420 0x4 0xffffffff

write 0xe1020424 0x4 0xffffffff

write 0xe102042b 0x1 0xff

write 0xe1020430 0x4 0x055c5e5c

write 0x5c041 0x1 0x04

write 0x5c042 0x1 0x02

write 0x5c043 0x1 0xe1

write 0x5c048 0x1 0x8a

write 0x5c04a 0x1 0x31

write 0x5c04b 0x1 0xff

write 0xe1020403 0x1 0xff

EOF

The Output:

==22689==ERROR: AddressSanitizer: heap-use-after-free on address 0x62500026800e at pc 0x55b93bb18bfa bp 0x7fffdbe844f0 sp 0x7fffdbe83cb8

READ of size 2 at 0x62500026800e thread T0

    #0 in \_\_asan\_memcpy (/build/i386-softmmu/qemu-system-i386+)

    #1 in lduw\_he\_p /include/qemu/bswap.h:332:5

    #2 in ldn\_he\_p /include/qemu/bswap.h:550:1

    #3 in flatview\_write\_continue /exec.c:3145:19

    #4 in flatview\_write /exec.c:3186:14

    #5 in address\_space\_write /exec.c:3280:18

    #6 in address\_space\_rw /exec.c:3290:16

    #7 in dma\_memory\_rw\_relaxed /include/sysemu/dma.h:87:18

    #8 in dma\_memory\_rw /include/sysemu/dma.h:113:12

    #9 in pci\_dma\_rw /include/hw/pci/pci.h:789:5

    #10 in pci\_dma\_write /include/hw/pci/pci.h:802:12

    #11 in e1000e\_write\_to\_rx\_buffers /hw/net/e1000e\_core.c:1412:9

    #12 in e1000e\_write\_packet\_to\_guest /hw/net/e1000e\_core.c:1582:21

    #13 in e1000e\_receive\_iov /hw/net/e1000e\_core.c:1709:9

    #14 in e1000e\_nc\_receive\_iov /hw/net/e1000e.c:213:12

    #15 in net\_tx\_pkt\_sendv /hw/net/net\_tx\_pkt.c:544:9

    #16 in net\_tx\_pkt\_send /hw/net/net\_tx\_pkt.c:620:9

    #17 in net\_tx\_pkt\_send\_loopback /hw/net/net\_tx\_pkt.c:633:11

    #18 in e1000e\_tx\_pkt\_send /hw/net/e1000e\_core.c:664:16

    #19 in e1000e\_process\_tx\_desc /hw/net/e1000e\_core.c:743:17

    #20 in e1000e\_start\_xmit /hw/net/e1000e\_core.c:934:9

    #21 in e1000e\_set\_tctl /hw/net/e1000e\_core.c:2431:9

    #22 in e1000e\_core\_write /hw/net/e1000e\_core.c:3265:9

    #23 in e1000e\_mmio\_write /hw/net/e1000e.c:109:5

    #24 in memory\_region\_write\_accessor /memory.c:483:5

    #25 in access\_with\_adjusted\_size /memory.c:544:18

    #26 in memory\_region\_dispatch\_write /memory.c:1476:16

    #27 in flatview\_write\_continue /exec.c:3146:23

    #28 in flatview\_write /exec.c:3186:14

    #29 in address\_space\_write /exec.c:3280:18

    #30 in qtest\_process\_command /qtest.c:567:9

    #31 in qtest\_process\_inbuf /qtest.c:710:9

    #32 in qtest\_read /qtest.c:722:5

    #33 in qemu\_chr\_be\_write\_impl /chardev/char.c:188:9

    #34 in qemu\_chr\_be\_write /chardev/char.c:200:9

    #35 in fd\_chr\_read /chardev/char-fd.c:68:9

    #36 in qio\_channel\_fd\_source\_dispatch /io/channel-watch.c:84:12

    #37 in g\_main\_context\_dispatch (/usr/lib/x86\_64-linux-gnu/libglib-2.0.so.0+)

    #38 in glib\_pollfds\_poll /util/main-loop.c:219:9

    #39 in os\_host\_main\_loop\_wait /util/main-loop.c:242:5

    #40 in main\_loop\_wait /util/main-loop.c:518:11

    #41 in qemu\_main\_loop /softmmu/vl.c:1664:9

    #42 in main /softmmu/main.c:52:5

    #43 in \_\_libc\_start\_main (/lib/x86\_64-linux-gnu/libc.so.6+)

    #44 in \_start (/build/i386-softmmu/qemu-system-i386+)

0x62500026800e is located 14 bytes inside of 138-byte region [0x625000268000,0x62500026808a)

freed by thread T0 here:

    #0 in free (/build/i386-softmmu/qemu-system-i386+)

    #1 in qemu\_vfree /util/oslib-posix.c:238:5

    #2 in address\_space\_unmap /exec.c:3616:5

    #3 in dma\_memory\_unmap /include/sysemu/dma.h:148:5

    #4 in pci\_dma\_unmap /include/hw/pci/pci.h:839:5

    #5 in net\_tx\_pkt\_reset /hw/net/net\_tx\_pkt.c:453:9

    #6 in e1000e\_process\_tx\_desc /hw/net/e1000e\_core.c:749:9

    #7 in e1000e\_start\_xmit /hw/net/e1000e\_core.c:934:9

    #8 in e1000e\_set\_tctl /hw/net/e1000e\_core.c:2431:9

    #9 in e1000e\_core\_write /hw/net/e1000e\_core.c:3265:9

    #10 in e1000e\_mmio\_write /hw/net/e1000e.c:109:5

    #11 in memory\_region\_write\_accessor /memory.c:483:5

    #12 in access\_with\_adjusted\_size /memory.c:544:18

    #13 in memory\_region\_dispatch\_write /memory.c:1476:16

    #14 in flatview\_write\_continue /exec.c:3146:23

    #15 in flatview\_write /exec.c:3186:14

    #16 in address\_space\_write /exec.c:3280:18

    #17 in address\_space\_rw /exec.c:3290:16

    #18 in dma\_memory\_rw\_relaxed /include/sysemu/dma.h:87:18

    #19 in dma\_memory\_rw /include/sysemu/dma.h:113:12

    #20 in pci\_dma\_rw /include/hw/pci/pci.h:789:5

    #21 in pci\_dma\_write /include/hw/pci/pci.h:802:12

    #22 in e1000e\_write\_to\_rx\_buffers /hw/net/e1000e\_core.c:1412:9

    #23 in e1000e\_write\_packet\_to\_guest /hw/net/e1000e\_core.c:1582:21

    #24 in e1000e\_receive\_iov /hw/net/e1000e\_core.c:1709:9

    #25 in e1000e\_nc\_receive\_iov /hw/net/e1000e.c:213:12

    #26 in net\_tx\_pkt\_sendv /hw/net/net\_tx\_pkt.c:544:9

    #27 in net\_tx\_pkt\_send /hw/net/net\_tx\_pkt.c:620:9

    #28 in net\_tx\_pkt\_send\_loopback /hw/net/net\_tx\_pkt.c:633:11

    #29 in e1000e\_tx\_pkt\_send /hw/net/e1000e\_core.c:664:16

previously allocated by thread T0 here:

    #0 in posix\_memalign (/build/i386-softmmu/qemu-system-i386+)

    #1 in qemu\_try\_memalign /util/oslib-posix.c:198:11

    #2 in qemu\_memalign /util/oslib-posix.c:214:27

    #3 in address\_space\_map /exec.c:3558:25

    #4 in dma\_memory\_map /include/sysemu/dma.h:138:9

    #5 in pci\_dma\_map /include/hw/pci/pci.h:832:11

    #6 in net\_tx\_pkt\_add\_raw\_fragment /hw/net/net\_tx\_pkt.c:391:24

    #7 in e1000e\_process\_tx\_desc /hw/net/e1000e\_core.c:731:14

    #8 in e1000e\_start\_xmit /hw/net/e1000e\_core.c:934:9

    #9 in e1000e\_set\_tctl /hw/net/e1000e\_core.c:2431:9

    #10 in e1000e\_core\_write /hw/net/e1000e\_core.c:3265:9

    #11 in e1000e\_mmio\_write /hw/net/e1000e.c:109:5

    #12 in memory\_region\_write\_accessor /memory.c:483:5

    #13 in access\_with\_adjusted\_size /memory.c:544:18

    #14 in memory\_region\_dispatch\_write /memory.c:1476:16

    #15 in flatview\_write\_continue /exec.c:3146:23

    #16 in flatview\_write /exec.c:3186:14

    #17 in address\_space\_write /exec.c:3280:18

    #18 in qtest\_process\_command /qtest.c:567:9

    #19 in qtest\_process\_inbuf /qtest.c:710:9

    #20 in qtest\_read /qtest.c:722:5

    #21 in qemu\_chr\_be\_write\_impl /chardev/char.c:188:9

    #22 in qemu\_chr\_be\_write /chardev/char.c:200:9

    #23 in fd\_chr\_read /chardev/char-fd.c:68:9

    #24 in qio\_channel\_fd\_source\_dispatch /io/channel-watch.c:84:12

    #25 in g\_main\_context\_dispatch (/usr/lib/x86\_64-linux-gnu/libglib-2.0.so.0+)

-Alex

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Philippe Mathieu-Daudé (philmd)](https://launchpad.net/~philmd) wrote on 2020-07-07: |  |  | [#1](/qemu/%2Bbug/1886362/comments/1) |
| --- | --- | --- | --- |

[Download full text](https://bugs.launchpad.net/qemu/%2Bbug/1886362/comments/1/%2Bdownload) (8.0 KiB)

Running with '-trace e1000\\*':

e1000e\_cb\_pci\_realize E1000E PCI realize entry

e1000e\_mac\_set\_permanent Set permanent MAC: 52:54:00:12:34:56

e1000e\_cfg\_support\_virtio Virtio header supported: 0

e1000e\_rx\_set\_cso RX CSO state set to 0

e1000e\_cb\_qdev\_reset E1000E qdev reset entry

e1000x\_mac\_indicate Indicating MAC to guest: 52:54:00:12:34:56

e1000x\_rx\_can\_recv\_disabled link\_up: 1, rx\_enabled 0, pci\_master 0

e1000x\_rx\_can\_recv\_disabled link\_up: 1, rx\_enabled 0, pci\_master 0

e1000e\_vm\_state\_running VM state is running

[R +0.094581] outl 0xcf8 0x80001010

[S +0.094604] OK

[R +0.094632] outl 0xcfc 0xe1020000

[S +0.094654] OK

[R +0.094668] outl 0xcf8 0x80001014

[S +0.094675] OK

[R +0.094694] outl 0xcf8 0x80001004

[S +0.094702] OK

[R +0.094712] outw 0xcfc 0x7

e1000e\_rx\_start\_recv

[S +0.096938] OK

[R +0.096960] outl 0xcf8 0x800010a2

[S +0.096972] OK

[R +0.096986] write 0xe102003b 0x1 0xff

e1000e\_core\_write Write to register 0x38, 4 byte(s), value: 0xff

e1000e\_vlan\_vet Setting VLAN ethernet type 0xFF

[S +0.097019] OK

[R +0.097034] write 0xe1020103 0x1e 0xffffff055c5e5c30be4511d084ffffffffffffffffffffffffffffffffff

e1000e\_core\_write Write to register 0x100, 4 byte(s), value: 0xff

e1000e\_rx\_set\_rctl RCTL = 0xff

e1000e\_rx\_desc\_buff\_sizes buffer sizes: [2048, 0, 0, 0]

e1000e\_rx\_desc\_len RX descriptor length: 16

e1000e\_rx\_start\_recv

e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x104, 4 byte(s), value: 0x5c05ffff

e1000e\_core\_write Write to register 0x2820, 4 byte(s), value: 0xbe305c5e

e1000e\_irq\_rdtr\_fpd\_not\_running FPD written while RDTR was not running

e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x10c, 4 byte(s), value: 0x84d01145

e1000e\_core\_write Write to register 0x2800, 4 byte(s), value: 0xffffffff

e1000e\_core\_write Write to register 0x2804, 4 byte(s), value: 0xffffffff

e1000e\_core\_write Write to register 0x2808, 4 byte(s), value: 0xffffffff

e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x11c, 4 byte(s), value: 0xffffffff

e1000e\_core\_write Write to register 0x2810, 4 byte(s), value: 0xff

[S +0.097143] OK

[R +0.097159] write 0xe1020420 0x4 0xffffffff

e1000e\_core\_write Write to register 0x3800, 4 byte(s), value: 0xffffffff

[S +0.097173] OK

[R +0.097183] write 0xe1020424 0x4 0xffffffff

e1000e\_core\_write Write to register 0x3804, 4 byte(s), value: 0xffffffff

[S +0.097196] OK

[R +0.097208] write 0xe102042b 0x1 0xff

e1000e\_core\_write Write to register 0x3808, 4 byte(s), value: 0xff

[S +0.097221] OK

[R +0.097231] write 0xe1020430 0x4 0x055c5e5c

e1000e\_core\_write Write to register 0x3810, 4 byte(s), value: 0x5c5e5c05

[S +0.097243] OK

[R +0.097253] write 0x5c041 0x1 0x04

[S +0.097914] OK

[R +0.097942] write 0x5c042 0x1 0x02

[S +0.097953] OK

[R +0.097964] write 0x5c043 0x1 0xe1

[S +0.097972] OK

[R +0.097984] write 0x5c048 0x1 0x8a

[S +0.097992] OK

[R +0.098003] write 0x5c04a 0x1 0x31

[S +0.098011] OK

[R +0.098022] write 0x5c04b 0x1 0xff

[S +0.098029] OK

[R +0.098040] write 0xe1020403 0x1 0xff

e1000e\_core\_write Write to register 0x400, 4 byte(s), value: 0xff

e1000e\_tx\_descr 0xe1020400 : ff31008a 0

e1000e\_core\_read Read from register 0x400, 4 byte(s), value: 0xff

e1000e\_wrn\_regs\_read\_unknown WARNING: Rea...

[Read more...](/qemu/%2Bbug/1886362/comments/1)

Running with '-trace e1000\\*':
e1000e\_cb\_pci\_realize E1000E PCI realize entry
e1000e\_mac\_set\_permanent Set permanent MAC: 52:54:00:12:34:56
e1000e\_cfg\_support\_virtio Virtio header supported: 0
e1000e\_rx\_set\_cso RX CSO state set to 0
e1000e\_cb\_qdev\_reset E1000E qdev reset entry
e1000x\_mac\_indicate Indicating MAC to guest: 52:54:00:12:34:56
e1000x\_rx\_can\_recv\_disabled link\_up: 1, rx\_enabled 0, pci\_master 0
e1000x\_rx\_can\_recv\_disabled link\_up: 1, rx\_enabled 0, pci\_master 0
e1000e\_vm\_state\_running VM state is running
[R +0.094581] outl 0xcf8 0x80001010
[S +0.094604] OK
[R +0.094632] outl 0xcfc 0xe1020000
[S +0.094654] OK
[R +0.094668] outl 0xcf8 0x80001014
[S +0.094675] OK
[R +0.094694] outl 0xcf8 0x80001004
[S +0.094702] OK
[R +0.094712] outw 0xcfc 0x7
e1000e\_rx\_start\_recv
[S +0.096938] OK
[R +0.096960] outl 0xcf8 0x800010a2
[S +0.096972] OK
[R +0.096986] write 0xe102003b 0x1 0xff
e1000e\_core\_write Write to register 0x38, 4 byte(s), value: 0xff
e1000e\_vlan\_vet Setting VLAN ethernet type 0xFF
[S +0.097019] OK
[R +0.097034] write 0xe1020103 0x1e 0xffffff055c5e5c30be4511d084ffffffffffffffffffffffffffffffffff
e1000e\_core\_write Write to register 0x100, 4 byte(s), value: 0xff
e1000e\_rx\_set\_rctl RCTL = 0xff
e1000e\_rx\_desc\_buff\_sizes buffer sizes: [2048, 0, 0, 0]
e1000e\_rx\_desc\_len RX descriptor length: 16
e1000e\_rx\_start\_recv
e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x104, 4 byte(s), value: 0x5c05ffff
e1000e\_core\_write Write to register 0x2820, 4 byte(s), value: 0xbe305c5e
e1000e\_irq\_rdtr\_fpd\_not\_running FPD written while RDTR was not running
e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x10c, 4 byte(s), value: 0x84d01145
e1000e\_core\_write Write to register 0x2800, 4 byte(s), value: 0xffffffff
e1000e\_core\_write Write to register 0x2804, 4 byte(s), value: 0xffffffff
e1000e\_core\_write Write to register 0x2808, 4 byte(s), value: 0xffffffff
e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x11c, 4 byte(s), value: 0xffffffff
e1000e\_core\_write Write to register 0x2810, 4 byte(s), value: 0xff
[S +0.097143] OK
[R +0.097159] write 0xe1020420 0x4 0xffffffff
e1000e\_core\_write Write to register 0x3800, 4 byte(s), value: 0xffffffff
[S +0.097173] OK
[R +0.097183] write 0xe1020424 0x4 0xffffffff
e1000e\_core\_write Write to register 0x3804, 4 byte(s), value: 0xffffffff
[S +0.097196] OK
[R +0.097208] write 0xe102042b 0x1 0xff
e1000e\_core\_write Write to register 0x3808, 4 byte(s), value: 0xff
[S +0.097221] OK
[R +0.097231] write 0xe1020430 0x4 0x055c5e5c
e1000e\_core\_write Write to register 0x3810, 4 byte(s), value: 0x5c5e5c05
[S +0.097243] OK
[R +0.097253] write 0x5c041 0x1 0x04
[S +0.097914] OK
[R +0.097942] write 0x5c042 0x1 0x02
[S +0.097953] OK
[R +0.097964] write 0x5c043 0x1 0xe1
[S +0.097972] OK
[R +0.097984] write 0x5c048 0x1 0x8a
[S +0.097992] OK
[R +0.098003] write 0x5c04a 0x1 0x31
[S +0.098011] OK
[R +0.098022] write 0x5c04b 0x1 0xff
[S +0.098029] OK
[R +0.098040] write 0xe1020403 0x1 0xff
e1000e\_core\_write Write to register 0x400, 4 byte(s), value: 0xff
e1000e\_tx\_descr 0xe1020400 : ff31008a 0
e1000e\_core\_read Read from register 0x400, 4 byte(s), value: 0xff
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x404, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x408, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x40c, 4 byte(s)
e1000e\_core\_read Read from register 0x410, 4 byte(s), value: 0x602008
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x414, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x418, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x41c, 4 byte(s)
e1000e\_core\_read Read from register 0x3800, 4 byte(s), value: 0xfffffff0
e1000e\_core\_read Read from register 0x3804, 4 byte(s), value: 0xffffffff
e1000e\_core\_read Read from register 0x3808, 4 byte(s), value: 0x80
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x42c, 4 byte(s)
e1000e\_core\_read Read from register 0x3810, 4 byte(s), value: 0x5c05
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x434, 4 byte(s)
e1000e\_core\_read Read from register 0x3818, 4 byte(s), value: 0x0
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x43c, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x3820, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x444, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x448, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x44c, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x450, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x454, 4 byte(s)
e1000e\_core\_read Read from register 0x458, 4 byte(s), value: 0x0
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x45c, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x460, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x464, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x468, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x46c, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x470, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x474, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x478, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x47c, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x480, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x484, 4 byte(s)
e1000e\_wrn\_regs\_read\_unknown WARNING: Read from unknown register 0x488, 4 byte(s)
e1000e\_rx\_receive\_iov Received vector of 4 fragments
e1000x\_vlan\_is\_vlan\_pkt Is VLAN packet: 0, ETH proto: 0x0, VET: 0xFF
e1000e\_rx\_rss\_started Starting RSS processing
e1000e\_rx\_rss\_disabled RSS is disabled
e1000e\_rx\_rss\_dispatched\_to\_queue Packet being dispatched to queue 0
e1000e\_ring\_free\_space ring #0: LEN: 1048448, DH: 255, DT: 0
e1000e\_rx\_has\_buffers ring #0: free descr: 65273, packet size 142, descr buffer size 2048
e1000e\_rx\_descr Next RX descriptor: ring #0, PA: 0xfe0, length: 16
e1000e\_rx\_null\_descriptor Null RX descriptor!!
e1000e\_rx\_descr Next RX descriptor: ring #0, PA: 0xff0, length: 16
e1000e\_rx\_null\_descriptor Null RX descriptor!!
e1000e\_rx\_descr Next RX descriptor: ring #0, PA: 0x1000, length: 16
e1000e\_rx\_null\_descriptor Null RX descriptor!!
e1000e\_rx\_descr Next RX descriptor: ring #0, PA: 0x1010, length: 16
e1000e\_rx\_null\_descriptor Null RX descriptor!!
[...]
e1000e\_rx\_descr Next RX descriptor: ring #0, PA: 0x5c020, length: 16
e1000e\_rx\_null\_descriptor Null RX descriptor!!
e1000e\_rx\_descr Next RX descriptor: ring #0, PA: 0x5c030, length: 16
e1000e\_rx\_null\_descriptor Null RX descriptor!!
e1000e\_rx\_descr Next RX descriptor: ring #0, PA: 0x5c040, length: 16
e1000e\_rx\_desc\_buff\_write buffer #0, addr: 0xe1020400, offset: 0, from: 0x631000028830, length: 14
e1000e\_core\_write Write to register 0x400, 4 byte(s), value: 0xff
e1000e\_tx\_descr 0xe1020400 : ff31008a 0
e1000e\_irq\_rearm\_timer Mitigation timer armed for register 0x3820, delay 0 ns
e1000e\_irq\_set\_cause\_entry Going to set IRQ cause 0x2, ICR: 0x0
e1000e\_irq\_set\_cause\_exit Set IRQ cause 0x3, ICR: 0x3
e1000e\_irq\_fix\_icr\_asserted ICR\_ASSERTED bit fixed: 0x80000003
e1000e\_irq\_pending\_interrupts ICR PENDING: 0x0 (ICR: 0x80000003, IMS: 0x0)
e1000e\_irq\_legacy\_notify IRQ line state: 0
e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x404, 4 byte(s), value: 0x0
e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x408, 4 byte(s), value: 0x0
e1000e\_wrn\_regs\_write\_unknown WARNING: Write to unknown register 0x40c, 4 byte(s), value: 0x0
e1000e\_rx\_desc\_buff\_write buffer #0, addr: 0xe1020400, offset: 14, from: 0x62500024200e, length: 124
=================================================================
==32103==ERROR: AddressSanitizer: heap-use-after-free on address 0x62500024200e at pc 0x55cd3c40c9aa bp 0x7ffd97112bf0 sp 0x7ffd971123a0

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Jason Wang (jasowang)](https://launchpad.net/~jasowang) wrote on 2020-07-14:  [**Re: [Bug 1886362] [NEW] Heap use-after-free in lduw\_he\_p through e1000e\_write\_to\_rx\_buffers**](/qemu/%2Bbug/1886362/comments/2) |  |  | [#2](/qemu/%2Bbug/1886362/comments/2) |
| --- | --- | --- | --- |

On 2020/7/10 下午6:37, Li Qiang wrote:

> Paolo Bonzini <email address hidden> 于2020年7月10日周五 上午1:36写道：

>> On 09/07/20 17:51, Li Qiang wrote:

>>> Maybe we should check whether the address is a RAM address in 'dma\_memory\_rw'?

>>> But it is a hot path. I'm not sure it is right. Hope more discussion.

>> Half of the purpose of dma-helpers.c (as opposed to address\_space\_\*

>> functions in exec.c) is exactly to support writes to MMIO. This is

> Hi Paolo,

>

> Could you please explain more about this(to support writes to MMIO).

> I can just see the dma helpers with sg DMA, not related with MMIO.

Please refer doc/devel/memory.rst.

The motivation of memory API is to allow support modeling different

memory regions. DMA to MMIO is allowed in hardware so Qemu should

emulate this behaviour.

>

>

>> especially true of dma\_blk\_io, which takes care of doing the DMA via a

>> bounce buffer, possibly in multiple steps and even blocking due to

>> cpu\_register\_map\_client.

>>

>> For dma\_memory\_rw this is not needed, so it only needs to handle

>> QEMUSGList, but I think the design should be the same.

>>

>> However, this is indeed a nightmare for re-entrancy. The easiest

>> solution is to delay processing of descriptors to a bottom half whenever

>> MMIO is doing something complicated. This is also better for latency

>> because it will free the vCPU thread more quickly and leave the work to

>> the I/O thread.

> Do you mean we define a per-e1000e bottom half. And in the MMIO write

> or packet send

> trigger this bh?

Probably a TX bh.

> So even if we again trigger the MMIO write, then

> second bh will not be executed?

Bh is serialized so no re-entrancy issue.

Thanks

>

>

> Thanks,

> Li Qiang

>

>> Paolo

>>

On 2020/7/10 下午6:37, Li Qiang wrote:
> Paolo Bonzini <pbonzini@redhat.com> 于2020年7月10日周五 上午1:36写道：
>> On 09/07/20 17:51, Li Qiang wrote:
>>> Maybe we should check whether the address is a RAM address in 'dma\_memory\_rw'?
>>> But it is a hot path. I'm not sure it is right. Hope more discussion.
>> Half of the purpose of dma-helpers.c (as opposed to address\_space\_\*
>> functions in exec.c) is exactly to support writes to MMIO. This is
> Hi Paolo,
>
> Could you please explain more about this(to support writes to MMIO).
> I can just see the dma helpers with sg DMA, not related with MMIO.
Please refer doc/devel/memory.rst.
The motivation of memory API is to allow support modeling different
memory regions. DMA to MMIO is allowed in hardware so Qemu should
emulate this behaviour.
>
>
>> especially true of dma\_blk\_io, which takes care of doing the DMA via a
>> bounce buffer, possibly in multiple steps and even blocking due to
>> cpu\_register\_map\_client.
>>
>> For dma\_memory\_rw this is not needed, so it only needs to handle
>> QEMUSGList, but I think the design should be the same.
>>
>> However, this is indeed a nightmare for re-entrancy. The easiest
>> solution is to delay processing of descriptors to a bottom half whenever
>> MMIO is doing something complicated. This is also better for latency
>> because it will free the vCPU thread more quickly and leave the work to
>> the I/O thread.
> Do you mean we define a per-e1000e bottom half. And in the MMIO write
> or packet send
> trigger this bh?
Probably a TX bh.
> So even if we again trigger the MMIO write, then
> second bh will not be executed?
Bh is serialized so no re-entrancy issue.
Thanks
>
>
> Thanks,
> Li Qiang
>
>> Paolo
>>

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Jason Wang (jasowang)](https://launchpad.net/~jasowang) wrote on 2020-07-15: |  |  | [#3](/qemu/%2Bbug/1886362/comments/3) |
| --- | --- | --- | --- |

On 2020/7/14 下午6:48, Li Qiang wrote:

> Jason Wang <email address hidden> 于2020年7月14日周二 下午4:56写道：

>>

>> On 2020/7/10 下午6:37, Li Qiang wrote:

>>> Paolo Bonzini <email address hidden> 于2020年7月10日周五 上午1:36写道：

>>>> On 09/07/20 17:51, Li Qiang wrote:

>>>>> Maybe we should check whether the address is a RAM address in 'dma\_memory\_rw'?

>>>>> But it is a hot path. I'm not sure it is right. Hope more discussion.

>>>> Half of the purpose of dma-helpers.c (as opposed to address\_space\_\*

>>>> functions in exec.c) is exactly to support writes to MMIO. This is

>>> Hi Paolo,

>>>

>>> Could you please explain more about this(to support writes to MMIO).

>>> I can just see the dma helpers with sg DMA, not related with MMIO.

>>

>> Please refer doc/devel/memory.rst.

>>

>> The motivation of memory API is to allow support modeling different

>> memory regions. DMA to MMIO is allowed in hardware so Qemu should

>> emulate this behaviour.

>>

> I just read the code again.

> So the dma\_blk\_io is used for some device that will need DMA to

> MMIO(may be related with

> device spec). But for most of the devices(networking card for

> example) there is no need this DMA to MMIO.

> So we just ksuse dma\_memory\_rw. Is this understanding right?

>

> Then another question.

> Though the dma helpers uses a bouncing buffer, it finally write to the

> device addressspace in 'address\_space\_unmap'.

> Is there any posibility that we can again write to the MMIO like this issue?

I think the point is to make DMA to MMIO work as real hardware. For

e1000e and other networking devices we need make sure such DMA doesn't

break anything.

Thanks

>

>

>>>

>>>> especially true of dma\_blk\_io, which takes care of doing the DMA via a

>>>> bounce buffer, possibly in multiple steps and even blocking due to

>>>> cpu\_register\_map\_client.

>>>>

>>>> For dma\_memory\_rw this is not needed, so it only needs to handle

>>>> QEMUSGList, but I think the design should be the same.

>>>>

>>>> However, this is indeed a nightmare for re-entrancy. The easiest

>>>> solution is to delay processing of descriptors to a bottom half whenever

>>>> MMIO is doing something complicated. This is also better for latency

>>>> because it will free the vCPU thread more quickly and leave the work to

>>>> the I/O thread.

>>> Do you mean we define a per-e1000e bottom half. And in the MMIO write

>>> or packet send

>>> trigger this bh?

>>

>> Probably a TX bh.

>>

> I will try to write this tx bh to strength my understanding in this part.

> Maybe reference the virtio-net implementation I think.

>

>

>

> Thanks,

> Li Qiang

>

>>> So even if we again trigger the MMIO write, then

>>> second bh will not be executed?

>>

>> Bh is serialized so no re-entrancy issue.

>>

>> Thanks

>>

>>

>>>

>>> Thanks,

>>> Li Qiang

>>>

>>>> Paolo

>>>>

On 2020/7/14 下午6:48, Li Qiang wrote:
> Jason Wang <jasowang@redhat.com> 于2020年7月14日周二 下午4:56写道：
>>
>> On 2020/7/10 下午6:37, Li Qiang wrote:
>>> Paolo Bonzini <pbonzini@redhat.com> 于2020年7月10日周五 上午1:36写道：
>>>> On 09/07/20 17:51, Li Qiang wrote:
>>>>> Maybe we should check whether the address is a RAM address in 'dma\_memory\_rw'?
>>>>> But it is a hot path. I'm not sure it is right. Hope more discussion.
>>>> Half of the purpose of dma-helpers.c (as opposed to address\_space\_\*
>>>> functions in exec.c) is exactly to support writes to MMIO. This is
>>> Hi Paolo,
>>>
>>> Could you please explain more about this(to support writes to MMIO).
>>> I can just see the dma helpers with sg DMA, not related with MMIO.
>>
>> Please refer doc/devel/memory.rst.
>>
>> The motivation of memory API is to allow support modeling different
>> memory regions. DMA to MMIO is allowed in hardware so Qemu should
>> emulate this behaviour.
>>
> I just read the code again.
> So the dma\_blk\_io is used for some device that will need DMA to
> MMIO(may be related with
> device spec). But for most of the devices(networking card for
> example) there is no need this DMA to MMIO.
> So we just ksuse dma\_memory\_rw. Is this understanding right?
>
> Then another question.
> Though the dma helpers uses a bouncing buffer, it finally write to the
> device addressspace in 'address\_space\_unmap'.
> Is there any posibility that we can again write to the MMIO like this issue?
I think the point is to make DMA to MMIO work as real hardware. For
e1000e and other networking devices we need make sure such DMA doesn't
break anything.
Thanks
>
>
>>>
>>>> especially true of dma\_blk\_io, which takes care of doing the DMA via a
>>>> bounce buffer, possibly in multiple steps and even blocking due to
>>>> cpu\_register\_map\_client.
>>>>
>>>> For dma\_memory\_rw this is not needed, so it only needs to handle
>>>> QEMUSGList, but I think the design should be the same.
>>>>
>>>> However, this is indeed a nightmare for re-entrancy. The easiest
>>>> solution is to delay processing of descriptors to a bottom half whenever
>>>> MMIO is doing something complicated. This is also better for latency
>>>> because it will free the vCPU thread more quickly and leave the work to
>>>> the I/O thread.
>>> Do you mean we define a per-e1000e bottom half. And in the MMIO write
>>> or packet send
>>> trigger this bh?
>>
>> Probably a TX bh.
>>
> I will try to write this tx bh to strength my understanding in this part.
> Maybe reference the virtio-net implementation I think.
>
>
>
> Thanks,
> Li Qiang
>
>>> So even if we again trigger the MMIO write, then
>>> second bh will not be executed?
>>
>> Bh is serialized so no re-entrancy issue.
>>
>> Thanks
>>
>>
>>>
>>> Thanks,
>>> Li Qiang
>>>
>>>> Paolo
>>>>

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [P J P (pjps)](https://launchpad.net/~pjps) wrote on 2020-07-21: |  |  | [#4](/qemu/%2Bbug/1886362/comments/4) |
| --- | --- | --- | --- |

Another reproducer: (just to record)

cat << EOF | ./i386-softmmu/qemu-system-i386 -M pc-q35-5.0 \

-netdev user,id=qtest-bn0 -device e1000e,netdev=qtest-bn0 \

-display none -nodefaults -nographic -qtest stdio

outl 0xcf8 0x80000810

outl 0xcfc 0xe0000000

outl 0xcf8 0x80000804

outw 0xcfc 0x7

write 0xe0000758 0x4 0xfffff1ff

write 0xe0000760 0x6 0xffffdf000000

write 0xe0000768 0x4 0x0efffff1

write 0xe0005008 0x4 0x18ffff27

write 0xe0000c 0x1 0x66

write 0xe03320 0x1 0xff

write 0xe03620 0x1 0xff

write 0xe00000f3 0x1 0xdf

write 0xe0000100 0x6 0xdfffffdf0000

write 0xe0000110 0x5 0xdfffffdf00

write 0xe000011a 0x3 0xffffff

write 0xe0000128 0x5 0x7e00ffffff

write 0xe0000403 0x1 0xdf

write 0xe0000420 0x4 0xdfffffdf

write 0xe000042a 0x3 0xffffff

write 0xe0000438 0x1 0x7e

EOF

-> <https://lists.gnu.org/archive/html/qemu-devel/2020-07/msg05709.html>

Another reproducer: (just to record)
cat << EOF | ./i386-softmmu/qemu-system-i386 -M pc-q35-5.0 \
-netdev user,id=qtest-bn0 -device e1000e,netdev=qtest-bn0 \
-display none -nodefaults -nographic -qtest stdio
outl 0xcf8 0x80000810
outl 0xcfc 0xe0000000
outl 0xcf8 0x80000804
outw 0xcfc 0x7
write 0xe0000758 0x4 0xfffff1ff
write 0xe0000760 0x6 0xffffdf000000
write 0xe0000768 0x4 0x0efffff1
write 0xe0005008 0x4 0x18ffff27
write 0xe0000c 0x1 0x66
write 0xe03320 0x1 0xff
write 0xe03620 0x1 0xff
write 0xe00000f3 0x1 0xdf
write 0xe0000100 0x6 0xdfffffdf0000
write 0xe0000110 0x5 0xdfffffdf00
write 0xe000011a 0x3 0xffffff
write 0xe0000128 0x5 0x7e00ffffff
write 0xe0000403 0x1 0xdf
write 0xe0000420 0x4 0xdfffffdf
write 0xe000042a 0x3 0xffffff
write 0xe0000438 0x1 0x7e
EOF
-> https://lists.gnu.org/archive/html/qemu-devel/2020-07/msg05709.html

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Peter Maydell (pmaydell)](https://launchpad.net/~pmaydell) wrote on 2020-07-21: |  |  | [#5](/qemu/%2Bbug/1886362/comments/5) |
| --- | --- | --- | --- |

On Wed, 15 Jul 2020 at 09:36, Jason Wang <email address hidden> wrote:

> I think the point is to make DMA to MMIO work as real hardware.

I wouldn't care to give a 100% guarantee that asking a real

h/w device to DMA to itself didn't cause it to misbehave :-)

It's more likely to happen-to-work because the DMA engine bit

of a real h/w device is going to be decoupled somewhat from

the respond-to-memory-transactions-for-registers logic, but

it probably wasn't something the designers were actively

thinking about either...

> For

> e1000e and other networking devices we need make sure such DMA doesn't

> break anything.

Yeah, this is the interesting part for QEMU. How should we

structure devices that do DMA so that we can be sure that

the device emulation at least doesn't crash? We could have

a rule that all devices that do DMA must always postpone

all of that DMA to a bottom-half, but that's a lot of

refactoring of a lot of device code...

thanks

-- PMM

On Wed, 15 Jul 2020 at 09:36, Jason Wang <jasowang@redhat.com> wrote:
> I think the point is to make DMA to MMIO work as real hardware.
I wouldn't care to give a 100% guarantee that asking a real
h/w device to DMA to itself didn't cause it to misbehave :-)
It's more likely to happen-to-work because the DMA engine bit
of a real h/w device is going to be decoupled somewhat from
the respond-to-memory-transactions-for-registers logic, but
it probably wasn't something the designers were actively
thinking about either...
> For
> e1000e and other networking devices we need make sure such DMA doesn't
> break anything.
Yeah, this is the interesting part for QEMU. How should we
structure devices that do DMA so that we can be sure that
the device emulation at least doesn't crash? We could have
a rule that all devices that do DMA must always postpone
all of that DMA to a bottom-half, but that's a lot of
refactoring of a lot of device code...
thanks
-- PMM

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Jason Wang (jasowang)](https://launchpad.net/~jasowang) wrote on 2020-07-21: |  |  | [#6](/qemu/%2Bbug/1886362/comments/6) |
| --- | --- | --- | --- |

On 2020/7/21 下午8:31, Peter Maydell wrote:

> On Wed, 15 Jul 2020 at 09:36, Jason Wang <email address hidden> wrote:

>> I think the point is to make DMA to MMIO work as real hardware.

> I wouldn't care to give a 100% guarantee that asking a real

> h/w device to DMA to itself didn't cause it to misbehave :-)

> It's more likely to happen-to-work because the DMA engine bit

> of a real h/w device is going to be decoupled somewhat from

> the respond-to-memory-transactions-for-registers logic, but

> it probably wasn't something the designers were actively

> thinking about either...

I think some device want such peer to peer transactions:

<https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst>

>

>> For

>> e1000e and other networking devices we need make sure such DMA doesn't

>> break anything.

> Yeah, this is the interesting part for QEMU. How should we

> structure devices that do DMA so that we can be sure that

> the device emulation at least doesn't crash? We could have

> a rule that all devices that do DMA must always postpone

> all of that DMA to a bottom-half, but that's a lot of

> refactoring of a lot of device code...

It looks to me the issue happens only for device with loopback

Simply git grep loopback in hw/net tells me we probably need only to

audit dp8393x and rtl8139.

Qiang, want to help to audit those devices?

Thanks

>

> thanks

> -- PMM

>

On 2020/7/21 下午8:31, Peter Maydell wrote:
> On Wed, 15 Jul 2020 at 09:36, Jason Wang <jasowang@redhat.com> wrote:
>> I think the point is to make DMA to MMIO work as real hardware.
> I wouldn't care to give a 100% guarantee that asking a real
> h/w device to DMA to itself didn't cause it to misbehave :-)
> It's more likely to happen-to-work because the DMA engine bit
> of a real h/w device is going to be decoupled somewhat from
> the respond-to-memory-transactions-for-registers logic, but
> it probably wasn't something the designers were actively
> thinking about either...
I think some device want such peer to peer transactions:
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst
>
>> For
>> e1000e and other networking devices we need make sure such DMA doesn't
>> break anything.
> Yeah, this is the interesting part for QEMU. How should we
> structure devices that do DMA so that we can be sure that
> the device emulation at least doesn't crash? We could have
> a rule that all devices that do DMA must always postpone
> all of that DMA to a bottom-half, but that's a lot of
> refactoring of a lot of device code...
It looks to me the issue happens only for device with loopback
Simply git grep loopback in hw/net tells me we probably need only to
audit dp8393x and rtl8139.
Qiang, want to help to audit those devices?
Thanks
>
> thanks
> -- PMM
>

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Peter Maydell (pmaydell)](https://launchpad.net/~pmaydell) wrote on 2020-07-21: |  |  | [#7](/qemu/%2Bbug/1886362/comments/7) |
| --- | --- | --- | --- |

On Tue, 21 Jul 2020 at 14:21, Jason Wang <email address hidden> wrote:

> On 2020/7/21 下午8:31, Peter Maydell wrote:

> > On Wed, 15 Jul 2020 at 09:36, Jason Wang <email address hidden> wrote:

> >> I think the point is to make DMA to MMIO work as real hardware.

> > I wouldn't care to give a 100% guarantee that asking a real

> > h/w device to DMA to itself didn't cause it to misbehave :-)

> > It's more likely to happen-to-work because the DMA engine bit

> > of a real h/w device is going to be decoupled somewhat from

> > the respond-to-memory-transactions-for-registers logic, but

> > it probably wasn't something the designers were actively

> > thinking about either...

> I think some device want such peer to peer transactions:

>

> <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst>

That's a device DMAing to another device, not DMAing to \*itself\*

(device-to-another-device DMA should work fine in QEMU). And only

a very few devices will ever be sensible targets of the DMA --

basically things like nvme that have a looks-like-memory area,

or special cases like doorbell registers.

> > Yeah, this is the interesting part for QEMU. How should we

> > structure devices that do DMA so that we can be sure that

> > the device emulation at least doesn't crash? We could have

> > a rule that all devices that do DMA must always postpone

> > all of that DMA to a bottom-half, but that's a lot of

> > refactoring of a lot of device code...

>

>

> It looks to me the issue happens only for device with loopback

I think in principle we have a problem for any device that

(a) has memory mapped registers and (b) does DMA reads

whose address is guest-controlled. Loopback isn't a

requirement -- if the guest programs, say, an RX descriptor

base address to point at the device's own registers, you

get exactly the same kind of unexpected-reentrancy.

thanks

-- PMM

On Tue, 21 Jul 2020 at 14:21, Jason Wang <jasowang@redhat.com> wrote:
> On 2020/7/21 下午8:31, Peter Maydell wrote:
> > On Wed, 15 Jul 2020 at 09:36, Jason Wang <jasowang@redhat.com> wrote:
> >> I think the point is to make DMA to MMIO work as real hardware.
> > I wouldn't care to give a 100% guarantee that asking a real
> > h/w device to DMA to itself didn't cause it to misbehave :-)
> > It's more likely to happen-to-work because the DMA engine bit
> > of a real h/w device is going to be decoupled somewhat from
> > the respond-to-memory-transactions-for-registers logic, but
> > it probably wasn't something the designers were actively
> > thinking about either...
> I think some device want such peer to peer transactions:
>
> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst
That's a device DMAing to another device, not DMAing to \*itself\*
(device-to-another-device DMA should work fine in QEMU). And only
a very few devices will ever be sensible targets of the DMA --
basically things like nvme that have a looks-like-memory area,
or special cases like doorbell registers.
> > Yeah, this is the interesting part for QEMU. How should we
> > structure devices that do DMA so that we can be sure that
> > the device emulation at least doesn't crash? We could have
> > a rule that all devices that do DMA must always postpone
> > all of that DMA to a bottom-half, but that's a lot of
> > refactoring of a lot of device code...
>
>
> It looks to me the issue happens only for device with loopback
I think in principle we have a problem for any device that
(a) has memory mapped registers and (b) does DMA reads
whose address is guest-controlled. Loopback isn't a
requirement -- if the guest programs, say, an RX descriptor
base address to point at the device's own registers, you
get exactly the same kind of unexpected-reentrancy.
thanks
-- PMM

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Alexander Bulekov (a1xndr)](https://launchpad.net/~a1xndr) wrote on 2020-07-21: |  |  | [#8](/qemu/%2Bbug/1886362/comments/8) |
| --- | --- | --- | --- |

On 200721 1444, Peter Maydell wrote:

> On Tue, 21 Jul 2020 at 14:21, Jason Wang <email address hidden> wrote:

> > On 2020/7/21 下午8:31, Peter Maydell wrote:

> > > On Wed, 15 Jul 2020 at 09:36, Jason Wang <email address hidden> wrote:

> > >> I think the point is to make DMA to MMIO work as real hardware.

> > > I wouldn't care to give a 100% guarantee that asking a real

> > > h/w device to DMA to itself didn't cause it to misbehave :-)

> > > It's more likely to happen-to-work because the DMA engine bit

> > > of a real h/w device is going to be decoupled somewhat from

> > > the respond-to-memory-transactions-for-registers logic, but

> > > it probably wasn't something the designers were actively

> > > thinking about either...

>

I searched around but couldn't find anything talking about this case for

real hardware. I also looked at some HDL code for FPGAs that do DMA, but

it seems most of the PCI DMA components are contained in proprietary

IPs, though maybe I'm missing something (I've never programmed

a DMA-capable FPGA).

> > I think some device want such peer to peer transactions:

> >

> > <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst>

>

> That's a device DMAing to another device, not DMAing to \*itself\*

> (device-to-another-device DMA should work fine in QEMU). And only

> a very few devices will ever be sensible targets of the DMA --

> basically things like nvme that have a looks-like-memory area,

> or special cases like doorbell registers.

>

> > > Yeah, this is the interesting part for QEMU. How should we

> > > structure devices that do DMA so that we can be sure that

> > > the device emulation at least doesn't crash? We could have

> > > a rule that all devices that do DMA must always postpone

> > > all of that DMA to a bottom-half, but that's a lot of

> > > refactoring of a lot of device code...

> >

> >

> > It looks to me the issue happens only for device with loopback

>

> I think in principle we have a problem for any device that

> (a) has memory mapped registers and (b) does DMA reads

> whose address is guest-controlled. Loopback isn't a

> requirement -- if the guest programs, say, an RX descriptor

> base address to point at the device's own registers, you

> get exactly the same kind of unexpected-reentrancy.

Could this be something that we check for in the

pci\_dma\_\* functions in hw/pci/pci.h? There we still have context about

the source device for the dma read/write and could, compare addr against

the device's PCI BARr's. Not sure about:

1.) How to do this without the overhead of convering the addr

to a MemoryRegion, which is normally done, once, at the flatview\_write

stage.

2.) What to do if we catch such a DMA request? Quietly drop it?

3.) Non-PCI devices.

I think this still doesn't cover the even crazier case where:

CPU writes to DEV\_A's MMIO

DEV\_A writes to DEV\_B's MMIO

DEV\_B writes to DEV\_A's MMIO

and neither DEV\_A or DEV\_B use BHs...

-Alex

> thanks

> -- PMM

>

On 200721 1444, Peter Maydell wrote:
> On Tue, 21 Jul 2020 at 14:21, Jason Wang <jasowang@redhat.com> wrote:
> > On 2020/7/21 下午8:31, Peter Maydell wrote:
> > > On Wed, 15 Jul 2020 at 09:36, Jason Wang <jasowang@redhat.com> wrote:
> > >> I think the point is to make DMA to MMIO work as real hardware.
> > > I wouldn't care to give a 100% guarantee that asking a real
> > > h/w device to DMA to itself didn't cause it to misbehave :-)
> > > It's more likely to happen-to-work because the DMA engine bit
> > > of a real h/w device is going to be decoupled somewhat from
> > > the respond-to-memory-transactions-for-registers logic, but
> > > it probably wasn't something the designers were actively
> > > thinking about either...
>
I searched around but couldn't find anything talking about this case for
real hardware. I also looked at some HDL code for FPGAs that do DMA, but
it seems most of the PCI DMA components are contained in proprietary
IPs, though maybe I'm missing something (I've never programmed
a DMA-capable FPGA).
> > I think some device want such peer to peer transactions:
> >
> > https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst
>
> That's a device DMAing to another device, not DMAing to \*itself\*
> (device-to-another-device DMA should work fine in QEMU). And only
> a very few devices will ever be sensible targets of the DMA --
> basically things like nvme that have a looks-like-memory area,
> or special cases like doorbell registers.
>
> > > Yeah, this is the interesting part for QEMU. How should we
> > > structure devices that do DMA so that we can be sure that
> > > the device emulation at least doesn't crash? We could have
> > > a rule that all devices that do DMA must always postpone
> > > all of that DMA to a bottom-half, but that's a lot of
> > > refactoring of a lot of device code...
> >
> >
> > It looks to me the issue happens only for device with loopback
>
> I think in principle we have a problem for any device that
> (a) has memory mapped registers and (b) does DMA reads
> whose address is guest-controlled. Loopback isn't a
> requirement -- if the guest programs, say, an RX descriptor
> base address to point at the device's own registers, you
> get exactly the same kind of unexpected-reentrancy.
Could this be something that we check for in the
pci\_dma\_\* functions in hw/pci/pci.h? There we still have context about
the source device for the dma read/write and could, compare addr against
the device's PCI BARr's. Not sure about:
1.) How to do this without the overhead of convering the addr
to a MemoryRegion, which is normally done, once, at the flatview\_write
stage.
2.) What to do if we catch such a DMA request? Quietly drop it?
3.) Non-PCI devices.
I think this still doesn't cover the even crazier case where:
CPU writes to DEV\_A's MMIO
DEV\_A writes to DEV\_B's MMIO
DEV\_B writes to DEV\_A's MMIO
and neither DEV\_A or DEV\_B use BHs...
-Alex
> thanks
> -- PMM
>

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Jason Wang (jasowang)](https://launchpad.net/~jasowang) wrote on 2020-07-22: |  |  | [#9](/qemu/%2Bbug/1886362/comments/9) |
| --- | --- | --- | --- |

On 2020/7/21 下午9:44, Peter Maydell wrote:

> On Tue, 21 Jul 2020 at 14:21, Jason Wang <email address hidden> wrote:

>> On 2020/7/21 下午8:31, Peter Maydell wrote:

>>> On Wed, 15 Jul 2020 at 09:36, Jason Wang <email address hidden> wrote:

>>>> I think the point is to make DMA to MMIO work as real hardware.

>>> I wouldn't care to give a 100% guarantee that asking a real

>>> h/w device to DMA to itself didn't cause it to misbehave :-)

>>> It's more likely to happen-to-work because the DMA engine bit

>>> of a real h/w device is going to be decoupled somewhat from

>>> the respond-to-memory-transactions-for-registers logic, but

>>> it probably wasn't something the designers were actively

>>> thinking about either...

>> I think some device want such peer to peer transactions:

>>

>> <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst>

> That's a device DMAing to another device, not DMAing to \*itself\*

> (device-to-another-device DMA should work fine in QEMU). And only

> a very few devices will ever be sensible targets of the DMA --

> basically things like nvme that have a looks-like-memory area,

> or special cases like doorbell registers.

Well, my understanding is:

- it's not about whether or not we have an actual device that can do DMA

into itself but whether it's allowed by PCI spec

- it's not really matter whether or not it tries to DMA into itself.

Devices could be taught to DMA into each other's RX:

e1000e(1) RX DMA to e1000e(2) MMIO (RX)

e1000e(2) RX DMA to e1000e(1) RX

So we get re-reentrancy again.

>

>>> Yeah, this is the interesting part for QEMU. How should we

>>> structure devices that do DMA so that we can be sure that

>>> the device emulation at least doesn't crash? We could have

>>> a rule that all devices that do DMA must always postpone

>>> all of that DMA to a bottom-half, but that's a lot of

>>> refactoring of a lot of device code...

>>

>> It looks to me the issue happens only for device with loopback

> I think in principle we have a problem for any device that

> (a) has memory mapped registers and (b) does DMA reads

> whose address is guest-controlled. Loopback isn't a

> requirement -- if the guest programs, say, an RX descriptor

> base address to point at the device's own registers, you

> get exactly the same kind of unexpected-reentrancy.

Right, so about the solution, instead of refactoring DMA I wonder we can

simply detect and fail the RX by device itself.

Thanks

>

> thanks

> -- PMM

>

On 2020/7/21 下午9:44, Peter Maydell wrote:
> On Tue, 21 Jul 2020 at 14:21, Jason Wang <jasowang@redhat.com> wrote:
>> On 2020/7/21 下午8:31, Peter Maydell wrote:
>>> On Wed, 15 Jul 2020 at 09:36, Jason Wang <jasowang@redhat.com> wrote:
>>>> I think the point is to make DMA to MMIO work as real hardware.
>>> I wouldn't care to give a 100% guarantee that asking a real
>>> h/w device to DMA to itself didn't cause it to misbehave :-)
>>> It's more likely to happen-to-work because the DMA engine bit
>>> of a real h/w device is going to be decoupled somewhat from
>>> the respond-to-memory-transactions-for-registers logic, but
>>> it probably wasn't something the designers were actively
>>> thinking about either...
>> I think some device want such peer to peer transactions:
>>
>> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst
> That's a device DMAing to another device, not DMAing to \*itself\*
> (device-to-another-device DMA should work fine in QEMU). And only
> a very few devices will ever be sensible targets of the DMA --
> basically things like nvme that have a looks-like-memory area,
> or special cases like doorbell registers.
Well, my understanding is:
- it's not about whether or not we have an actual device that can do DMA
into itself but whether it's allowed by PCI spec
- it's not really matter whether or not it tries to DMA into itself.
Devices could be taught to DMA into each other's RX:
e1000e(1) RX DMA to e1000e(2) MMIO (RX)
e1000e(2) RX DMA to e1000e(1) RX
So we get re-reentrancy again.
>
>>> Yeah, this is the interesting part for QEMU. How should we
>>> structure devices that do DMA so that we can be sure that
>>> the device emulation at least doesn't crash? We could have
>>> a rule that all devices that do DMA must always postpone
>>> all of that DMA to a bottom-half, but that's a lot of
>>> refactoring of a lot of device code...
>>
>> It looks to me the issue happens only for device with loopback
> I think in principle we have a problem for any device that
> (a) has memory mapped registers and (b) does DMA reads
> whose address is guest-controlled. Loopback isn't a
> requirement -- if the guest programs, say, an RX descriptor
> base address to point at the device's own registers, you
> get exactly the same kind of unexpected-reentrancy.
Right, so about the solution, instead of refactoring DMA I wonder we can
simply detect and fail the RX by device itself.
Thanks
>
> thanks
> -- PMM
>

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Jason Wang (jasowang)](https://launchpad.net/~jasowang) wrote on 2020-07-22: |  |  | [#10](/qemu/%2Bbug/1886362/comments/10) |
| --- | --- | --- | --- |

On 2020/7/21 下午9:46, Li Qiang wrote:

> Jason Wang <email address hidden> 于2020年7月21日周二 下午9:21写道：

>>

>> On 2020/7/21 下午8:31, Peter Maydell wrote:

>>> On Wed, 15 Jul 2020 at 09:36, Jason Wang <email address hidden> wrote:

>>>> I think the point is to make DMA to MMIO work as real hardware.

>>> I wouldn't care to give a 100% guarantee that asking a real

>>> h/w device to DMA to itself didn't cause it to misbehave :-)

>>> It's more likely to happen-to-work because the DMA engine bit

>>> of a real h/w device is going to be decoupled somewhat from

>>> the respond-to-memory-transactions-for-registers logic, but

>>> it probably wasn't something the designers were actively

>>> thinking about either...

>>

>> I think some device want such peer to peer transactions:

>>

>> <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst>

>>

>>

>>>> For

>>>> e1000e and other networking devices we need make sure such DMA doesn't

>>>> break anything.

>>> Yeah, this is the interesting part for QEMU. How should we

>>> structure devices that do DMA so that we can be sure that

>>> the device emulation at least doesn't crash? We could have

>>> a rule that all devices that do DMA must always postpone

>>> all of that DMA to a bottom-half, but that's a lot of

>>> refactoring of a lot of device code...

>>

>> It looks to me the issue happens only for device with loopback

> IMO I think this is not related-loopback.

>

> It happens when the guest write the MMIO address to the device's

> DMA-related registers.

> The one we see UAF occurs in loopback device because the same

> structure uses in re-entry.

> But we can't say there are no issue for non-loopback device.

Yes.

>> Simply git grep loopback in hw/net tells me we probably need only to

>> audit dp8393x and rtl8139.

>>

>> Qiang, want to help to audit those devices?

> No problem. Once I finish the e1000e patch I will try to audit those and

> also try to audit some no-loopback device re-entry issue.

Thanks.

>

> Thanks,

> Li Qiang

>

>> Thanks

>>

>>

>>> thanks

>>> -- PMM

>>>

On 2020/7/21 下午9:46, Li Qiang wrote:
> Jason Wang <jasowang@redhat.com> 于2020年7月21日周二 下午9:21写道：
>>
>> On 2020/7/21 下午8:31, Peter Maydell wrote:
>>> On Wed, 15 Jul 2020 at 09:36, Jason Wang <jasowang@redhat.com> wrote:
>>>> I think the point is to make DMA to MMIO work as real hardware.
>>> I wouldn't care to give a 100% guarantee that asking a real
>>> h/w device to DMA to itself didn't cause it to misbehave :-)
>>> It's more likely to happen-to-work because the DMA engine bit
>>> of a real h/w device is going to be decoupled somewhat from
>>> the respond-to-memory-transactions-for-registers logic, but
>>> it probably wasn't something the designers were actively
>>> thinking about either...
>>
>> I think some device want such peer to peer transactions:
>>
>> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/driver-api/pci/p2pdma.rst
>>
>>
>>>> For
>>>> e1000e and other networking devices we need make sure such DMA doesn't
>>>> break anything.
>>> Yeah, this is the interesting part for QEMU. How should we
>>> structure devices that do DMA so that we can be sure that
>>> the device emulation at least doesn't crash? We could have
>>> a rule that all devices that do DMA must always postpone
>>> all of that DMA to a bottom-half, but that's a lot of
>>> refactoring of a lot of device code...
>>
>> It looks to me the issue happens only for device with loopback
> IMO I think this is not related-loopback.
>
> It happens when the guest write the MMIO address to the device's
> DMA-related registers.
> The one we see UAF occurs in loopback device because the same
> structure uses in re-entry.
> But we can't say there are no issue for non-loopback device.
Yes.
>> Simply git grep loopback in hw/net tells me we probably need only to
>> audit dp8393x and rtl8139.
>>
>> Qiang, want to help to audit those devices?
> No problem. Once I finish the e1000e patch I will try to audit those and
> also try to audit some no-loopback device re-entry issue.
Thanks.
>
> Thanks,
> Li Qiang
>
>> Thanks
>>
>>
>>> thanks
>>> -- PMM
>>>

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Thomas Huth (th-huth)](https://launchpad.net/~th-huth) wrote on 2021-05-26: |  |  | [#11](/qemu/%2Bbug/1886362/comments/11) |
| --- | --- | --- | --- |

I can reproduce this problem with QEMU v5.0, but with the current

version, it does not run into this assertion anymore. Seems like this

problem got fixed in the course of time? Could you please check whether

you could still reproduce this?

I can reproduce this problem with QEMU v5.0, but with the current
version, it does not run into this assertion anymore. Seems like this
problem got fixed in the course of time? Could you please check whether
you could still reproduce this?

| Changed in qemu: | |
| --- | --- |
| **status**: | New → Incomplete |

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Alexander Bulekov (a1xndr)](https://launchpad.net/~a1xndr) wrote on 2021-06-14 (last edit on 2021-06-14): |  |  | [#12](/qemu/%2Bbug/1886362/comments/12) |
| --- | --- | --- | --- |

This should have been fixed by the qemu\_receive\_packet/network loopback patches from a few months ago

This should have been fixed by the qemu\_receive\_packet/network loopback patches from a few months ago

Revision history for this message
![](/+icing/build/overlay/assets/skins/sam/images/close.gif)

| [Thomas Huth (th-huth)](https://launchpad.net/~th-huth) wrote on 2021-06-15: |  |  | [#13](/qemu/%2Bbug/1886362/comments/13) |
| --- | --- | --- | --- |

Ok, let's mark this as fixed.

Ok, let's mark this as fixed.

| Changed in qemu: | |
| --- | --- |
| **status**: | Incomplete → Fix Released |

[See full activity log](https://bugs.launchpad.net/qemu/%2Bbug/1886362/%2Bactivity)

To post a comment you must [log in](%2Blogin?comments=all).

* [Report a bug](/qemu/%2Bfilebug)

This report contains
**Public**
information

Everyone can see this information.

You are
[not directly subscribed to this bug's notifications.](/qemu/%2Bbug/1886362/%2Bsubscribe)

Subscribing...

* [Edit bug mail](https://bugs.launchpad.net/qemu/%2Bbug/1886362/%2Bsubscriptions "View and change your subscriptions to this bug")

## Other bug subscribers

[Subscribe someone else](https://bugs.launchpad.net/qemu/%2Bbug/1886362/%2Baddsubscriber "Launchpad will email that person whenever this bugs changes")

## Remote bug watches

Bug watches keep track of this bug in other bug trackers.

[![Launchpad](/@@/launchpad-footer-logo.svg)](https://launchpad.net/)
 •
[Take the tour](https://launchpad.net/%2Btour)
 •
[Read the guide](https://help.launchpad.net/)

© 2004
[Canonical Ltd.](http://canonical.com/)
 •
[Terms of use](https://launchpad.net/legal)
 •
[Data privacy](https://www.ubuntu.com/legal/dataprivacy)
 •
[Contact Launchpad Support](/feedback)
 •
[Blog](http://blog.launchpad.net/)
 •
[Careers](https://canonical.com/careers)
 •
[System status](https://ubuntu.social/%40launchpadstatus)
 •
6394e03
([Get the code!](https://dev.launchpad.net/))



=== Content from security.gentoo.org_a9cedf15_20250119_123001.html ===

[![Gentoo](https://assets.gentoo.org/tyrian/v2/site-logo.png)](/ "Back to the homepage")
Security

[**Get Gentoo!**](https://get.gentoo.org/)
gentoo.org sites
[gentoo.org](https://www.gentoo.org/ "Main Gentoo website")
[Wiki](https://wiki.gentoo.org/ "Find and contribute documentation")
[Bugs](https://bugs.gentoo.org/ "Report issues and find common issues")
[Forums](https://forums.gentoo.org/ "Discuss with the community")
[Packages](https://packages.gentoo.org/ "Find software for your Gentoo")

[Planet](https://planet.gentoo.org/ "Find out what's going on in the developer community")
[Archives](https://archives.gentoo.org/ "Read up on past discussions")
[Sources](https://sources.gentoo.org/ "Browse our source code")

[Infra Status](https://infra-status.gentoo.org/ "Get updates on the services provided by Gentoo")

* [Home](/)
* [Stay informed](/subscribe)
* [Advisories](/glsa)

# QEMU: Multiple Vulnerabilities — GLSA **202208-27**

Multiple vulnerabilities have been discovered in QEMU, the worst of which could result in remote code execution (guest sandbox escape).

### Affected packages

| Package | **app-emulation/qemu** on all architectures |
| --- | --- |
| Affected versions | < **7.0.0** |
| Unaffected versions | >= **7.0.0** |

### Background

QEMU is a generic and open source machine emulator and virtualizer.

### Description

Multiple vulnerabilities have been discovered in QEMU.Please review the CVE identifiers referenced below for details.

### Impact

Please review the referenced CVE identifiers for details.

### Workaround

There is no known workaround at this time.

### Resolution

All QEMU users should upgrade to the latest version:

```
 # emerge --sync
 # emerge --ask --oneshot --verbose ">=app-emulation/qemu-7.0.0"

```
### References

* [CVE-2020-15859](https://nvd.nist.gov/vuln/detail/CVE-2020-15859)
* [CVE-2020-15863](https://nvd.nist.gov/vuln/detail/CVE-2020-15863)
* [CVE-2020-16092](https://nvd.nist.gov/vuln/detail/CVE-2020-16092)
* [CVE-2020-35504](https://nvd.nist.gov/vuln/detail/CVE-2020-35504)
* [CVE-2020-35505](https://nvd.nist.gov/vuln/detail/CVE-2020-35505)
* [CVE-2020-35506](https://nvd.nist.gov/vuln/detail/CVE-2020-35506)
* [CVE-2020-35517](https://nvd.nist.gov/vuln/detail/CVE-2020-35517)
* [CVE-2021-3409](https://nvd.nist.gov/vuln/detail/CVE-2021-3409)
* [CVE-2021-3416](https://nvd.nist.gov/vuln/detail/CVE-2021-3416)
* [CVE-2021-3527](https://nvd.nist.gov/vuln/detail/CVE-2021-3527)
* [CVE-2021-3544](https://nvd.nist.gov/vuln/detail/CVE-2021-3544)
* [CVE-2021-3545](https://nvd.nist.gov/vuln/detail/CVE-2021-3545)
* [CVE-2021-3546](https://nvd.nist.gov/vuln/detail/CVE-2021-3546)
* [CVE-2021-3582](https://nvd.nist.gov/vuln/detail/CVE-2021-3582)
* [CVE-2021-3607](https://nvd.nist.gov/vuln/detail/CVE-2021-3607)
* [CVE-2021-3608](https://nvd.nist.gov/vuln/detail/CVE-2021-3608)
* [CVE-2021-3611](https://nvd.nist.gov/vuln/detail/CVE-2021-3611)
* [CVE-2021-3682](https://nvd.nist.gov/vuln/detail/CVE-2021-3682)
* [CVE-2021-3713](https://nvd.nist.gov/vuln/detail/CVE-2021-3713)
* [CVE-2021-3748](https://nvd.nist.gov/vuln/detail/CVE-2021-3748)
* [CVE-2021-3750](https://nvd.nist.gov/vuln/detail/CVE-2021-3750)
* [CVE-2021-3929](https://nvd.nist.gov/vuln/detail/CVE-2021-3929)
* [CVE-2021-3930](https://nvd.nist.gov/vuln/detail/CVE-2021-3930)
* [CVE-2021-3947](https://nvd.nist.gov/vuln/detail/CVE-2021-3947)
* [CVE-2021-4145](https://nvd.nist.gov/vuln/detail/CVE-2021-4145)
* [CVE-2021-4158](https://nvd.nist.gov/vuln/detail/CVE-2021-4158)
* [CVE-2021-4206](https://nvd.nist.gov/vuln/detail/CVE-2021-4206)
* [CVE-2021-4207](https://nvd.nist.gov/vuln/detail/CVE-2021-4207)
* [CVE-2021-20203](https://nvd.nist.gov/vuln/detail/CVE-2021-20203)
* [CVE-2021-20257](https://nvd.nist.gov/vuln/detail/CVE-2021-20257)
* [CVE-2021-20263](https://nvd.nist.gov/vuln/detail/CVE-2021-20263)
* [CVE-2022-0358](https://nvd.nist.gov/vuln/detail/CVE-2022-0358)
* [CVE-2022-26353](https://nvd.nist.gov/vuln/detail/CVE-2022-26353)
* [CVE-2022-26354](https://nvd.nist.gov/vuln/detail/CVE-2022-26354)

**Release date**

August 14, 2022

**Latest revision**

August 14, 2022: 1

**Severity**

high

**Exploitable**

remote

**Bugzilla entries**

* [733448](https://bugs.gentoo.org/show_bug.cgi?id=733448)
* [736605](https://bugs.gentoo.org/show_bug.cgi?id=736605)
* [773220](https://bugs.gentoo.org/show_bug.cgi?id=773220)
* [775713](https://bugs.gentoo.org/show_bug.cgi?id=775713)
* [780816](https://bugs.gentoo.org/show_bug.cgi?id=780816)
* [792624](https://bugs.gentoo.org/show_bug.cgi?id=792624)
* [807055](https://bugs.gentoo.org/show_bug.cgi?id=807055)
* [810544](https://bugs.gentoo.org/show_bug.cgi?id=810544)
* [820743](https://bugs.gentoo.org/show_bug.cgi?id=820743)
* [835607](https://bugs.gentoo.org/show_bug.cgi?id=835607)
* [839762](https://bugs.gentoo.org/show_bug.cgi?id=839762)

### Questions or comments?

Please feel free to contact us.

**© 2001–2020 Gentoo Foundation, Inc.**



=== Content from www.openwall.com_ff0141a7_20250119_140740.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Follow @Openwall on Twitter for new release announcements and other news](https://twitter.com/openwall) | | --- | |
| --- | --- |

# blists - web interface to mailing list archives

blists is a web interface to mailing list archives that works off indexed mbox files.
There are two programs: *bindex* and *bit*.
*bindex* generates or updates the index file (yes, incremental updates are supported).
*bit* is a CGI/SSI program that generates web pages on the fly.
Both programs are written in C and are very fast.

You can view the latest <README> file,
which describes blists in more detail and provides installation instructions.
It is also included in the archive below.

Download ([release notes](/lists/announce/2017/11/19/1)):

* [blists 2.0](blists-2.0.tar.gz) and
  its [signature](blists-2.0.tar.gz.sign)* [blists 1.0](blists-1.0.tar.gz) and
    its [signature](blists-1.0.tar.gz.sign)

These files are also
[available from the Openwall file archive](https://download.openwall.net/pub/projects/blists/).
The source code of blists can be browsed on
[GitHub](https://github.com/openwall/blists) or via
[CVSweb](https://cvsweb.openwall.com/blists).

Follow [this link](/signatures/) for information on verifying the signatures.

To see blists in action, check out our
[Open Source and information security mailing list archives](https://lists.openwall.net).

blists is a registered project with
[Open Hub](https://www.openhub.net/p/blists).

Quick Comment:

412423



=== Content from www.openwall.com_f99954e2_20250119_123001.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Hash Suite - Windows password security audit tool. GUI, reports in PDF.](https://hashsuite.openwall.net) | | --- | |
| --- | --- |

[[<prev]](2) [[next>]](../../../2020/07/22/1) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <nycvar.YSQ.7.78.906.2007211710040.4380@xnncv>
Date: Tue, 21 Jul 2020 17:23:52 +0530 (IST)
From: P J P <ppandit@...hat.com>
To: oss security list <oss-security@...ts.openwall.com>
cc: alxndr@...edu
Subject: CVE-2020-15859 QEMU: net: e1000e: use-after-free while sending
 packets

   Hello,

A use-after-free issue was found in the INTEL 82574 NIC (e1000e) emulator of
the QEMU. It could occur while sending packets if the guest user set the
packet data address to e1000e's MMIO address. A guest user/process could use
this flaw to crash the QEMU process on the host resulting in DoS scenario.

Upstream patch:
----------------
   -> <https://lists.gnu.org/archive/html/qemu-devel/2020-07/msg05895.html>

Reference:
----------
   -> [https://bugs.launchpad.net/qemu/+bug/1886362](https://bugs.launchpad.net/qemu/%2Bbug/1886362)

This issue was reported by Alexander Bulekov. CVE-2020-15859 assigned via
Mitre.

Thank you.
--
Prasad J Pandit / Red Hat Product Security Team
8685 545E B54C 486B C6EB 271E E285 8B5A F050 DE8D

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from lists.debian.org_c98311a9_20250119_123000.html ===


---

[[Date Prev](msg00007.html)][[Date Next](msg00009.html)]
[[Thread Prev](msg00007.html)][[Thread Next](msg00009.html)]
[[Date Index](maillist.html#00008)]
[[Thread Index](threads.html#00008)]

# [SECURITY] [DLA 3099-1] qemu security update

---

* *To*: debian-lts-announce@lists.debian.org
* *Subject*: [SECURITY] [DLA 3099-1] qemu security update
* *From*: Abhijith PA <abhijith@debian.org>
* *Date*: Mon, 5 Sep 2022 08:58:05 +0530
* *Message-id*: <YxVsxXlWx/Sdg4MV@debian.org>
* *Mail-followup-to*: debian-lts@lists.debian.org
* *Reply-to*: debian-lts@lists.debian.org

---

```
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

- -------------------------------------------------------------------------
Debian LTS Advisory DLA-3099-1                debian-lts@lists.debian.org
<https://www.debian.org/lts/security/>                          Abhijith PA
September 05, 2022                            <https://wiki.debian.org/LTS>
- -------------------------------------------------------------------------

Package        : qemu
Version        : 1:3.1+dfsg-8+deb10u9
CVE ID         : CVE-2020-13253 CVE-2020-15469 CVE-2020-15859 CVE-2020-25084
                 CVE-2020-25085 CVE-2020-25624 CVE-2020-25625 CVE-2020-25723
                 CVE-2020-27617 CVE-2020-27821 CVE-2020-28916 CVE-2020-29129
                 CVE-2020-29443 CVE-2020-35504 CVE-2020-35505 CVE-2021-3392
                 CVE-2021-3416 CVE-2021-3507 CVE-2021-3527 CVE-2021-3582
                 CVE-2021-3607 CVE-2021-3608 CVE-2021-3682 CVE-2021-3713
                 CVE-2021-3748 CVE-2021-3930 CVE-2021-4206 CVE-2021-4207
                 CVE-2021-20181 CVE-2021-20196 CVE-2021-20203 CVE-2021-20221
                 CVE-2021-20257 CVE-2022-26354 CVE-2022-35414

Multiple security issues were discovered in QEMU, a fast processor
emulator, which could result in denial of service or the the execution
of arbitrary code.

For Debian 10 buster, these problems have been fixed in version
1:3.1+dfsg-8+deb10u9.

We recommend that you upgrade your qemu packages.

For the detailed security status of qemu please refer to
its security tracker page at:
<https://security-tracker.debian.org/tracker/qemu>

Further information about Debian LTS security advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://wiki.debian.org/LTS>
-----BEGIN PGP SIGNATURE-----

iQIzBAEBCgAdFiEE7xPqJqaY/zX9fJAuhj1N8u2cKO8FAmMVbMUACgkQhj1N8u2c
KO+N6w//XuvPOvMxGsDw3swppKApkL1ECz7NC1L4xRouPyHhh0JZrqwovd5miY6M
mmIq2zeurtEVhf6kkhw1NP3ywrfgURyf7RhpcLN3z/o8aqjLoxL6fIJGzv9URulC
6xDpu1n5mKTI/EX8Zeqy9ks3+HgHNAg9jr5s5TWIYlJLhhlYvrvMbUAeM04V8Zaw
XGXJj0Jx1f83CMFVNXDJ6shBzfUZII3taZIjUFcME5DUFNxaG8492nYisRcwlDNy
Z1AOGbhehZlgbk5t4cX2kOMq/qp9EiAqrBUZgqXtT+zCRBr4hQjK5OOmaq69p4N5
RsS8MA3/Rtvt9b3xuNXnDy28O50yvlQJK9GJa/p8KM894pn2fMTu3pxFVAn4xIsp
umcx4LbxSYaBDygtK81xhxK3ODfakR8YGmXUffeRasPw/mFncdN9kTxCvuSgdoUO
rgqcmJ+D38JAzV+ALjEnMZkrGYzscM6GzKHA5DR37qmdG/JNNKpqy3TRWBpNY4ZL
QYmAIW5MvCx3SEgZBeAkUwPpfam6d3DwKm7RUvmvL5ul/UDcyowYRCpZGwgtyL57
8N3yu0V9IA0L04yuiUcd9RE3qXGsFQU7YvzpB7hEj2WQIV2i9LDb+5D2qnUJmdCR
+dCiSgxf0qi14Rbhv9gZ4/jCAC4fWHHGuyCO4ySyLVmDgtgBpQo=
=EhD5
-----END PGP SIGNATURE-----

```

---



=== Content from lists.debian.org_1bd82707_20250119_123000.html ===


---

[[Date Prev](msg00023.html)][[Date Next](msg00025.html)]
[[Thread Prev](msg00023.html)][[Thread Next](msg00025.html)]
[[Date Index](maillist.html#00024)]
[[Thread Index](threads.html#00024)]

# [SECURITY] [DLA 2560-1] qemu security update

---

* *To*: debian-lts-announce@lists.debian.org
* *Subject*: [SECURITY] [DLA 2560-1] qemu security update
* *From*: Sylvain Beucler <beuc@beuc.net>
* *Date*: Thu, 18 Feb 2021 17:57:32 +0100
* *Message-id*: <[[🔎]](/msgid-search/20210218165732.GA11803%40layer-acht.org) [20210218165732.GA11803@layer-acht.org](msg00024.html)>
* *Mail-followup-to*: debian-lts@lists.debian.org
* *Reply-to*: debian-lts@lists.debian.org

---

```
--------------------------------------------------------------------------
Debian LTS Advisory DLA-2560-1                debian-lts@lists.debian.org
<https://www.debian.org/lts/security/>                      Sylvain Beucler
February 18, 2021                             <https://wiki.debian.org/LTS>
--------------------------------------------------------------------------

Package        : qemu
Version        : 1:2.8+dfsg-6+deb9u13
CVE ID         : CVE-2020-15469 CVE-2020-15859 CVE-2020-25084 CVE-2020-28916
                 CVE-2020-29130 CVE-2020-29443 CVE-2021-20181 CVE-2021-20221
Debian Bug     : 970253 965978 970539 974687 976388

Several vulnerabilities were discovered in QEMU, a fast processor
emulator (notably used in KVM and Xen HVM virtualization). An attacker
could trigger a denial-of-service (DoS), information leak, and
possibly execute arbitrary code with the privileges of the QEMU
process on the host.

CVE-2020-15469

    A MemoryRegionOps object may lack read/write callback methods,
    leading to a NULL pointer dereference.

CVE-2020-15859

    QEMU has a use-after-free in hw/net/e1000e_core.c because a guest
    OS user can trigger an e1000e packet with the data's address set
    to the e1000e's MMIO address.

CVE-2020-25084

    QEMU has a use-after-free in hw/usb/hcd-xhci.c because the
    usb_packet_map return value is not checked.

CVE-2020-28916

    hw/net/e1000e_core.c has an infinite loop via an RX descriptor
    with a NULL buffer address.

CVE-2020-29130

    slirp.c has a buffer over-read because it tries to read a certain
    amount of header data even if that exceeds the total packet
    length.

CVE-2020-29443

    ide_atapi_cmd_reply_end in hw/ide/atapi.c allows out-of-bounds
    read access because a buffer index is not validated.

CVE-2021-20181

    9pfs: ZDI-CAN-10904: QEMU Plan 9 file system TOCTOU privilege
    escalation vulnerability.

CVE-2021-20221

    aarch64: GIC: out-of-bound heap buffer access via an interrupt ID
    field.

For Debian 9 stretch, these problems have been fixed in version
1:2.8+dfsg-6+deb9u13.

We recommend that you upgrade your qemu packages.

For the detailed security status of qemu please refer to
its security tracker page at:
<https://security-tracker.debian.org/tracker/qemu>

Further information about Debian LTS security advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://wiki.debian.org/LTS>

```

**Attachment:
[signature.asc](pgp2Y13X85r9l.pgp)**

*Description:* PGP signature

---



=== Content from lists.gnu.org_80874af1_20250119_123001.html ===


| | **qemu-devel** | | --- | |
| --- | --- |

[[Top](../)][[All Lists](/archive/html)]

[Advanced](/archive/cgi-bin/namazu.cgi?idxname=qemu-devel)

---

[[Date Prev](msg05303.html)][[Date Next](msg05305.html)][[Thread Prev](msg05303.html)][[Thread Next](msg05368.html)][[Date Index](index.html#05304)][[Thread Index](threads.html#05304)]

## [PATCH] e1000e: using bottom half to send packets

---

| **From**: | Li Qiang |
| --- | --- |

| **Subject**: | [PATCH] e1000e: using bottom half to send packets |
| **Date**: | Thu, 16 Jul 2020 09:14:53 -0700 |

---

```
Alexander Bulekov reported a UAF bug related e1000e packets send.

-->[https://bugs.launchpad.net/qemu/+bug/1886362](https://bugs.launchpad.net/qemu/%2Bbug/1886362)

This is because the guest trigger a e1000e packet send and set the
data's address to e1000e's MMIO address. So when the e1000e do DMA
it will write the MMIO again and trigger re-entrancy and finally
causes this UAF.

Paolo suggested to use a bottom half whenever MMIO is doing complicate
things in here:
--><https://lists.nongnu.org/archive/html/qemu-devel/2020-07/msg03342.html>

Reference here:
'The easiest solution is to delay processing of descriptors to a bottom
half whenever MMIO is doing something complicated.  This is also better
for latency because it will free the vCPU thread more quickly and leave
the work to the I/O thread.'

This patch fixes this UAF.

Signed-off-by: Li Qiang <liq3ea@163.com>
---
 hw/net/e1000e_core.c | 25 +++++++++++++++++--------
 hw/net/e1000e_core.h |  2 ++
 2 files changed, 19 insertions(+), 8 deletions(-)

diff --git a/hw/net/e1000e_core.c b/hw/net/e1000e_core.c
index bcd186cac5..6165b04b68 100644
--- a/hw/net/e1000e_core.c
+++ b/hw/net/e1000e_core.c
@@ -2423,32 +2423,27 @@ e1000e_set_dbal(E1000ECore *core, int index, uint32_t
val)
 static void
 e1000e_set_tctl(E1000ECore *core, int index, uint32_t val)
 {
-    E1000E_TxRing txr;
     core->mac[index] = val;

     if (core->mac[TARC0] & E1000_TARC_ENABLE) {
-        e1000e_tx_ring_init(core, &txr, 0);
-        e1000e_start_xmit(core, &txr);
+        qemu_bh_schedule(core->tx[0].tx_bh);
     }

     if (core->mac[TARC1] & E1000_TARC_ENABLE) {
-        e1000e_tx_ring_init(core, &txr, 1);
-        e1000e_start_xmit(core, &txr);
+        qemu_bh_schedule(core->tx[1].tx_bh);
     }
 }

 static void
 e1000e_set_tdt(E1000ECore *core, int index, uint32_t val)
 {
-    E1000E_TxRing txr;
     int qidx = e1000e_mq_queue_idx(TDT, index);
     uint32_t tarc_reg = (qidx == 0) ? TARC0 : TARC1;

     core->mac[index] = val & 0xffff;

     if (core->mac[tarc_reg] & E1000_TARC_ENABLE) {
-        e1000e_tx_ring_init(core, &txr, qidx);
-        e1000e_start_xmit(core, &txr);
+        qemu_bh_schedule(core->tx[qidx].tx_bh);
     }
 }

@@ -3322,6 +3317,16 @@ e1000e_vm_state_change(void *opaque, int running,
RunState state)
     }
 }

+static void e1000e_core_tx_bh(void *opaque)
+{
+    struct e1000e_tx *tx = opaque;
+    E1000ECore *core = tx->core;
+    E1000E_TxRing txr;
+
+    e1000e_tx_ring_init(core, &txr, tx - &core->tx[0]);
+    e1000e_start_xmit(core, &txr);
+}
+
 void
 e1000e_core_pci_realize(E1000ECore     *core,
                         const uint16_t *eeprom_templ,
@@ -3340,6 +3345,8 @@ e1000e_core_pci_realize(E1000ECore     *core,
     for (i = 0; i < E1000E_NUM_QUEUES; i++) {
         net_tx_pkt_init(&core->tx[i].tx_pkt, core->owner,
                         E1000E_MAX_TX_FRAGS, core->has_vnet);
+        core->tx[i].core = core;
+        core->tx[i].tx_bh = qemu_bh_new(e1000e_core_tx_bh, &core->tx[i]);
     }

     net_rx_pkt_init(&core->rx_pkt, core->has_vnet);
@@ -3367,6 +3374,8 @@ e1000e_core_pci_uninit(E1000ECore *core)
     for (i = 0; i < E1000E_NUM_QUEUES; i++) {
         net_tx_pkt_reset(core->tx[i].tx_pkt);
         net_tx_pkt_uninit(core->tx[i].tx_pkt);
+        qemu_bh_delete(core->tx[i].tx_bh);
+        core->tx[i].tx_bh = NULL;
     }

     net_rx_pkt_uninit(core->rx_pkt);
diff --git a/hw/net/e1000e_core.h b/hw/net/e1000e_core.h
index aee32f7e48..94ddc6afc2 100644
--- a/hw/net/e1000e_core.h
+++ b/hw/net/e1000e_core.h
@@ -77,6 +77,8 @@ struct E1000Core {
         unsigned char sum_needed;
         bool cptse;
         struct NetTxPkt *tx_pkt;
+        QEMUBH *tx_bh;
+        E1000ECore *core;
     } tx[E1000E_NUM_QUEUES];

     struct NetRxPkt *rx_pkt;
--
2.17.1

```

---

reply via email to

---

| [Prev in Thread] | **Current Thread** | [[Next in Thread](msg05368.html)] |
| --- | --- | --- |

* **[PATCH] e1000e: using bottom half to send packets**,
  *Li Qiang* **<=**
  + **[Re: [PATCH] e1000e: using bottom half to send packets](msg05368.html)**, *Jason Wang*, 2020/07/16
    - **[Re: [PATCH] e1000e: using bottom half to send packets](msg05373.html)**, *Li Qiang*, 2020/07/17
      * **[Re: [PATCH] e1000e: using bottom half to send packets](msg05378.html)**, *Jason Wang*, 2020/07/17* **[Re: [PATCH] e1000e: using bottom half to send packets](msg05576.html)**, *Li Qiang*, 2020/07/17* **[Re: [PATCH] e1000e: using bottom half to send packets](msg05711.html)**, *Jason Wang*, 2020/07/20* **[Re: [PATCH] e1000e: using bottom half to send packets](msg05714.html)**, *Li Qiang*, 2020/07/20
    - **[Re: [PATCH] e1000e: using bottom half to send packets](msg05577.html)**, *Peter Maydell*, 2020/07/17
      * **[Re: [PATCH] e1000e: using bottom half to send packets](msg05712.html)**, *Jason Wang*, 2020/07/20

---

* Prev by Date:
  **[Re: [PATCH v3 7/9] tz-ppc: add dummy read/write methods](msg05303.html)**
* Next by Date:
  **[Re: [PATCH for-5.1] qapi: Fix visit\_type\_STRUCT() not to fail for null object](msg05305.html)**
* Previous by thread:
  **[Re: [PATCH v3 7/9] tz-ppc: add dummy read/write methods](msg05303.html)**
* Next by thread:
  **[Re: [PATCH] e1000e: using bottom half to send packets](msg05368.html)**
* Index(es):
  + [**Date**](index.html#05304)
  + [**Thread**](threads.html#05304)



=== Content from wiki.debian.org_8d48714b_20250119_140744.html ===

[![Debian](https://www.debian.org/Pics/openlogo-50.png)](https://www.debian.org "Debian Homepage")

[Wiki](/FrontPage "Debian Wiki Homepage")

[Login](/LTS?action=login)

* [FrontPage](/FrontPage)
* [RecentChanges](/RecentChanges)
* [FindPage](/FindPage)
* [HelpContents](/HelpContents)
* [LTS](/LTS)

Search:

[![Debian](https://www.debian.org/Pics/openlogo-50.png)](https://www.debian.org "Debian Homepage")
[Wiki](/FrontPage "Debian Wiki Homepage")/

* [Login](/LTS?action=login)
* Comments
* [Info](/LTS?action=info)
* [Attachments](/LTS?action=AttachFile)
* More Actions:
  Raw Text
  Print View
  Render as Docbook
  Delete Cache
  ------------------------
  Check Spelling
  Like Pages
  Local Site Map
  ------------------------
  Rename Page
  Delete Page
  ------------------------
  Subscribe User
  ------------------------
  Remove Spam
  Revert to this revision
  Package Pages
  ------------------------
  Load
  Save
  SlideShow

# * [LTS](/LTS)

[Translation(s)](/DebianWiki/EditorGuide#translation): [English](/LTS) - [Deutsch](/de/LTS) - [Español](/es/LTS) - [Français](/fr/LTS) - [Italiano](/it/LTS) - [한국어](/ko/LTS) - [Português](/pt/LTS) - [Português (Brasil)](/pt_BR/LTS) - [Русский](/ru/LTS)

# Debian Long Term Support

Debian Long Term Support (LTS) is a project to extend the lifetime of all Debian stable releases to (at least) 5 years. Debian LTS is not handled by the Debian Security and Release teams, but by a separate group of volunteers and companies interested in making it a success.

Thus the Debian LTS team takes over security maintenance of the various releases once the Debian Security team stops its work.

![/!\](/htdocs/debwiki/img/alert.png "/!\")

LTS ([last modified 2024-08-15 02:46:47](/LTS?action=info))

* Debian [privacy policy](https://www.debian.org/legal/privacy), Wiki [team](/Teams/DebianWiki), [bugs](https://bugs.debian.org/wiki.debian.org) and [config](https://salsa.debian.org/debian/wiki.debian.org).
* Powered by [MoinMoin](https://moinmo.in/ "This site uses the MoinMoin Wiki software.") and [Python](https://moinmo.in/Python "MoinMoin is written in Python."), with hosting provided by [Metropolitan Area Network Darmstadt](https://www.man-da.de/).


