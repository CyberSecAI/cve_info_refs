=== Content from www.usenix.org_418a609c_20250125_212400.html ===
Practical Padding Oracle Attacks

Juliano Rizzo∗

Thai Duong†

May 25th, 2010

Abstract

At Eurocrypt 2002, Vaudenay introduced a powerful
side-channel attack, which is called padding oracle
attack, against CBC-mode encryption with PKCS#5
padding (See [6]). If there is an oracle which on re-
ceipt of a ciphertext, decrypts it and then replies to
the sender whether the padding is correct or not, Vau-
denay shows how to use that oracle to e(cid:30)ciently de-
crypt data without knowing the encryption key. In
this paper, we turn the padding oracle attack into
a new set of practical web hacking techniques. We
also introduce a new technique that allows attackers
to use a padding oracle to encrypt messages of any
length without knowing the secret key. Finally, we
show how to use that technique to mount advanced
padding oracle exploits against popular web develop-
ment frameworks.

1

Introduction

In this research, we show that widely used web de-
velopment frameworks and web sites are using en-
cryption incorrectly in a way that allows attackers to
read and modify data that should be protected. It has
been known for years in the cryptography community
that encryption is not authentication. If encrypted
messages are not authenticated, data integrity can-
not be guaranteed which makes systems vulnerable
to practical and dangerous chosen-ciphertext attacks,
one of them being the padding oracle attack pre-
sented by Vaudenay at EuroCrypt 2002 (See [6]). As

explained in Paterson and Yau’s summary in [5], the
padding oracle attack requires an oracle which on re-
ceipt of a ciphertext, decrypts it and replies to the
sender whether the padding is VALID or INVALID. The
attack works under the assumption that the attack-
ers can intercept padded messages encrypted in CBC
mode, and have access to the aforementioned padding
oracle. The result is that attackers can recover the
plaintext corresponding to any block of ciphertext
using an average of 128 (cid:63) b oracle calls, where b is
the number of bytes in a block. The easiest (cid:28)x for
the padding oracle attack is to encrypt-then-MAC,
i.e., encrypting information to get the ciphertext,
then protecting the ciphertext integrity with a Mes-
sage Authentication Code scheme. For more details
on Vaudenay’s attack and suggested (cid:28)xes, please see
[7, 1, 3, 4, 5].

In Section 2, we describe manual and automated test-
ing techniques to (cid:28)nd padding oracles in real life sys-
tems. In Section 3, we describe basic padding oracle
attacks to crack CAPTCHA, and decrypt secret data
of popular web sites and web development frame-
works. In Section 4, we introduce advanced padding
oracle attacks that allow attackers to mount the most
interesting exploits such as creating malicious view
states to run arbitrary code in JavaServer Faces. In
Section 5, we describe padding oracle vulnerabilities
in some other popular web development frameworks
besides JavaServer Faces. We conclude in Section 6.

2 Finding Padding Oracles

∗http://netifera.com, juliano at netifera.com
†http://vnsecurity.net, thaidn at vnsecurity.net

If you start looking today, you will see that the
It is ev-
padding oracle vulnerability is pervasive.

1

erywhere like SQL Injection or Cross Site Scripting.
This is because few people understand that attackers
can decrypt their secrets if they leak out just a single
bit of information. Unfortunately, the reality is that
if you somehow let attackers know whether or not an
error has occurred while you decrypt data supplied
by them, then they can decrypt your messages.

It is also important to stress that people often use
one global crypto key and a (cid:28)xed IV to encrypt ev-
erything in their systems, so if attackers discover a
padding oracle, they can then use it to decrypt all
data encrypted under that key and IV.

2.1 Finding Potential Padding Ora-

cles

We have been using three methods to (cid:28)nd potential
padding oracles:

Google Hacking We
look for known error
messages and standard API
In
exceptions.
Java, the error message is Given final block not
properly padded, and the standard exception is
javax.crypto.BadPaddingException. Other plat-
forms and crypto libraries provide di(cid:27)erent error mes-
sages and API exceptions. Just googling these mes-
sages, we promise that you can (cid:28)nd many applica-
tions potentially vulnerable to the padding oracle at-
tack.

Source Code Auditing Another way is to look
for known source code keywords. You can start by
looking for code that imports low level cryptography
libraries such as OpenSSL, Crypto++, PyCrypto,
Microsoft Crypto API or Java Cryptography Exten-
sion. Then look for routines that perform encryption
and decryption. If there’s some code to handle errors
while decrypting, and/or no evidence of authentica-
tion checks, then it is highly probable that you have
found a target for the padding oracle attack.

Backbox Testing We crawl the target web site to
(cid:28)nd Base64 strings which can be found in hidden

(cid:28)elds, cookies, or request parameters 1. Then we de-
code each Base64 string found.
If the result looks
random, and its length is a multiple of a common
block cipher size, i.e., 8, 16 or 32 bytes, then there’s
a good chance that it is a ciphertext. We also look
for common separators, i.e., --, | or :, which are of-
ten used to separate IV, ciphertext, or MAC. Then
we replace a byte at the end of the ciphertext by a
random value, then send it back to the target, and
see what changes in the response. If there is an er-
ror message, then there’s a high chance that this is a
padding oracle. Even a blank page is enough infor-
mation to perform this attack.

For blackbox testing, the most important task is to
analyse and understand the meaning of error mes-
sages returned by the target upon receiving mangled
In short, you need to know which re-
ciphertexts.
sponses from the target mean that the padding was
VALID after decrypting your modi(cid:28)ed ciphertexts.

This algorithm, which is very similar to the last word
decryption algorithm that Vaudenay described in his
seminal paper (See [6, Section 3.1]), can be used in
a black-box scenario as the (cid:28)rst step to learn if the
target leaks information about its padding validity.

1. Determine the block size b. You can use the

algorithm described in Section 2.2.

2. Chose a few random bytes r1, ..., rb where b de-
notes the cipher block size in bytes, and take
i = 0.

3. Take r = r1|...|rb−1|(rb ⊕ i), where | denotes byte

concatenation.

4. Send r|y to the target where y is a valid cipher-
text block that you found during the manual
testing phase. Record the value of i, content
length, elapsed time and content type of the re-
sponse. Increment i, and go back to step 3 until
i > 255.

1A funny side e(cid:27)ect of doing this research is now both of us
are obsessed with Base64 strings. Every time we see a Base64
string, we decode it, and if it’s not plaintext, we assume it is
a ciphertext, then go on trying to decrypt it using Padding
Oracle attack. It’s really fun!

2

5. Now you have 256 responses. If all of them are
the same, then it is bad news, the target is not
easily showing you that it is vulnerable to the
padding oracle attack. Otherwise, look at each
value of i where the responses are di(cid:27)erent from
the rest. Manually resend each corresponding
r|y, and examine carefully each response to see
what happens.

2.2 Con(cid:28)rm The Existence of Padding

Oracles

After doing some manual testings, one usually needs
to use an automated tool to con(cid:28)rm the existence
of padding oracles. We released POET (Padding
Oracle Exploitation Tool) 2 which (cid:28)nds and ex-
ploits padding oracles automatically.

If you want to write your own tool to detect padding
oracles, you can implement the following algorithms.

Determine the block size b All padding oracle
attacks need a correct block size b. The most com-
mon block sizes are 8 and 16 bytes, thus of course
we can use trial and error. The following algorithm
can be used to guess the correct block size by sending
just one request to the target. The algorithm is not
perfect but it is good enough for most cases.

1. If len(C)%16 = 8, where C is some captured

ciphertext, then stop and output 8.

2. Take y = C[−16 :], i.e., y is the last sixteen bytes

of C.

2. Use the algorithm described in [1] to (cid:28)nd the
padding length l. This takes log2(b) oracle
queries.

3. Denote the last block of a valid captured cipher-
text as x0, x1, ..., xb. Take vi = l, for i = 1, ..., l.
Run Vaudenay’s Post(cid:28)x Equality Check algo-
rithm (See [6], Section 3.4) with y0, y1, ..., yN =
x0, x1, ..., xb and w0, w1,..., wm = v0, v1, ..., vl. In
other words, check to see if the last l bytes of the
last block are the same as the padding bytes.

4. If Vaudenay’s Post(cid:28)x Equality Check returns
true, then we can say that we found a padding
oracle with a high level of certainty. Otherwise,
we cannot be sure if the target is vulnerable or
not, but we are sure that we cannot use the or-
acle to decrypt a ciphertext in a reliable way.

3 Basic Padding Oracle Attacks

Since HTTP is a stateless protocol, web developers
must either manage states on the server, or push
them to the client. For performance and scalabil-
ity reasons, many web developers tend to go with
the latter method. They want to keep the state as a
secret, and turn to cryptography which is the right
tool. However, they use it wrongly, i.e., neither ap-
ply a MAC to the ciphertext nor use an authenticated
block cipher mode, and make their systems vulnera-
ble. In this section, we show two basic padding ora-
cles attacks.

3. Send C|y to the target,

if

it returns VALID

padding then stop and output 8.

3.1 Cracking CAPTCHA

4. Output 16.

Con(cid:28)rm The Existence of Padding Oracles

1. Determine the block size b if possible, otherwise
try the following steps for each potential block
size, i.e., 8 and 16.

CAPTCHA is the most popular technique to prevent
computer programs from submitting automated re-
quests to web servers. A common type of CAPTCHA
requires that users enter an alphanumeric code from
a distorted image. We found that some crypto-based
CAPTCHA systems are the simplest examples of
padding oracle attacks.

2Download POET at http://netifera.com/research

A vulnerable CAPTCHA system works as follows:

3

1. The server generates a random code, encrypts it
using CBC-mode under some key K and some
IV:

ERC = EK,IV (rand())

2. This ERC will be used as a parameter for
some captcha.jsp 3 which upon receipt of
a ERC, will decrypt it, and generate a dis-
If a HTML form needs to
torted image.
show a CAPTCHA, it just puts something like
/captcha.jsp?token=ERC into a <img> tag to
load a distorted image.

3. ERC will be stored either as a hidden (cid:28)eld in
the CAPTCHA form or as a cookie, so once a
user submits a form, it will be sent back to the
server.

4. Then the server goes on decrypting ERC, and
compares it with the code that the user has en-
tered. If equal, the server accepts the request; it
denies the request otherwise.

attackers need to know the IV to be able to get P0.
In other words, if the IV is secret, it is not possible
to decrypt the (cid:28)rst block , making it impossible to
break CAPTCHA systems whose P0 contains part of
the random code.

Fortunately, for those CAPTCHA systems that we
have found during this research, the IV can be re-
covered easily with human intervention. Most of
the time the text shown in the CAPTCHA image
is exactly the same as P0, so if attackers know
DP addingOracle(C0), then they can compute the se-
cret IV as following:

IV = Human ⊕ DP addingOracle(C0)

where Human denotes that somebody reads P0 from
the CAPTCHA image. This is very useful to attack
CAPTCHA systems where manually discovering the
IV a single time allows attackers to decrypt any new
challenges, given the IV is not changed, without any
further human intervention.

Because captcha.jsp would decrypt any ERC sent
to it, it is vulnerable to the padding oracle attack. As
we discussed in Section 2, the only remaining problem
now is to know when padding is VALID, and when it
is not.

Fortunately, most CAPTCHA systems would send
back an error noti(cid:28)cation when they fail to decrypt
ERC, i.e., padding is INVALID. Some servers send
either empty responses or HTML with an error mes-
In addition, when you modify ERC so that
sage.
the padding is VALID, captcha.jsp would display an
image with a broken code.

If things work out that way, attackers now have
a padding oracle, and they can use it to decrypt
any ERC to get its random code, hence bypass the
CAPTCHA protection completely.

CAPTCHA with secret IV Since

P0 = IV ⊕ DP addingOracle(C0)

3Please note that what we describe here works for any plat-

form and language, we just use Java/JSP as an example

3.2 Decrypting JSF view states

to the

the view between requests

JavaServer Faces introduces a powerful and (cid:29)ex-
saving and restoring the state
ible system for
of
server.
JSF implementations support two primary mech-
anisms for saving states, based on the value of
the javax.faces.STATE_SAVING_METHOD initializa-
tion parameter. If this parameter is set to client, it
would cause the saved state to be included in the ren-
dered markup that is sent to the client (such as in a
hidden input (cid:28)eld for HTML). The state information
must be included in the subsequent request, making
it possible for JSF to restore the view without having
saved information on the server side.

Although JSF speci(cid:28)cation advises that state infor-
mation should be encrypted and tamper evident, as
far as we know no implementation follows that ad-
vice. Some frameworks such as SUN Mojarra and
Apache MyFaces do encrypt state information, but
they don’t protect the integrity of encrypted states
which makes them vulnerable to padding oracle at-
tacks.

4

By default, all JSF frameworks would display a very
detailed error message if the decryption of a view
state fails , which makes the padding oracle very ob-
vious: if sees javax.crypto.BadPaddingException,
then it is INVALID padding; it is VALID padding oth-
erwise.

Most JSF frameworks allow developers to turn
o(cid:27) error messages.
Then attackers can use
Say an attacker wants to
the following trick.
decrypt block Ci of an encrypted view state
C0|C1|...|Cn−1, then he would append Crandom|Ci to
create C0|C1|...|Cn−1|Crandom|Ci, and send this mes-
sage to the server. Since JSF frameworks ignore those
extra blocks while decrypting and deserializing view
states, the attacker can have a safe bet that it is
VALID padding if the server returns the same page
as when the view state is unaltered. It is probably
INVALID padding if he sees something else, e.g., a
HTTP 500 error message.

View states usually do not contain very sensitive
data, but it is important to stress that some frame-
works save to the client not only the view, but also
the entire managed beans which could possibly con-
tain con(cid:28)dential data 4.

4 Advanced Padding Oracle At-

tacks

4.1.1 CBC-R Encryption

CBC-R turns a decryption oracle into an encryption
oracle 5. CBC decryption works as following:

Pi = DK(Ci) ⊕ Ci−1

C0 = IV

If attackers control
Look at the XOR operation.
Ci−1, and they know DK(Ci), then they can make
Pi equal to anything they want. Of course attackers
can control Ci−1 because this is a chosen-ciphertext
attack. For the second condition, attackers don’t
have access to K, but they can use a padding ora-
cle to get DK(Ci). In other words, attackers can use
a padding oracle to encrypt messages of any length
without knowing the secret key.

The process is simple. Attackers choose a random
ciphertext block, call it Ci . Any random block would
work. They send that block to the padding oracle
to get its intermediate plaintext, call this operation
DP addingOracle(Ci). Since

Pi = DP addingOracle(Ci) ⊕ Ci−1

and attackers control Ci−1, they can make Pi equal
to any block they want. Suppose they want to make
Pi equal to some Px, then all they need to do is to
set:

4.1 Using Padding Oracles to Encrypt

Ci−1 = Px ⊕ DP addingOracle(Ci)

A padding oracle is all attackers need to decrypt mes-
sages. But can it help if their goal is to encrypt
messages? The short answer is yes. We designed
the following technique, which allows attackers to use
a padding oracle to encrypt messages of any length
without knowing the secret key. Given the surpris-
ingly fruitful consequences of this technique, we are
surprised that it was not published before. We call
it CBC-R encryption, and Section 4.1.2 shows that
CBC-R has permitted us to mount the most interest-
ing exploits.

But does this make Ci−1 decrypt to a garbled block
Pi−1? Yes, but attackers can (cid:28)x Pi−1 by sending
Ci−1 to the padding oracle to get its intermediate
plaintext, and set:

Ci−2 = Pi−1 ⊕ DP addingOracle(Ci−1)

Now they have two consecutive plaintext blocks Pi−1
and Pi of their choice, and a leading garbled block
Pi−2 that they can correct by inserting a new cipher-
text block Ci−3. Repeating this operation, they can

4For

Apache
http://wiki.apache.org/myfaces/SaveState

MyFaces,

see

5Please note that padding oracle is just one kind of decryp-

tion oracles that can work well with CBC-R

5

1. choose a plaintext message, and divide it into N

blocks of b bytes P0, P1, .., PN −1.

2. chose a few random bytes r1, r2, ..., rb, and set

Cn−1 = r1|r2|...|rb

Using Captured Ciphertext As Pre(cid:28)x If at-
tackers capture a ciphertext whose plaintext is a valid
message, then they can prepend the ciphertext to
their CBC-R encrypted message to get a valid header
after decrypting:

3. for i = N − 1 down to 1:

Ci−1 = Pi ⊕ DP addingOracle(Ci)

4. IV = P0 ⊕ DP addingOracle(C0)

5. output IV and C =C0|C1|...|Cn−1.

Figure 1: CBC-R pseudocode

e(cid:30)ciently encrypt a complete message block by block,
starting from the last one. Since the (cid:28)rst block of the
CBC ciphertext stream depends on the IV , if attack-
ers can set the IV , then the decrypted data will be
exactly as what they want without any garbled block.
If attackers don’t control the IV , then the (cid:28)rst block
is garbled. In the next paragraph, we discuss what
attackers can do if they don’t control the IV .

CBC-R Without Controlling IV
Di(cid:27)erent
cryptosystems handle IV in di(cid:27)erent ways.
IV can
be either a pre(cid:28)x of the ciphertext, and totally con-
trollable by attackers, or a (cid:28)xed well known value,
but attackers cannot change it. Cryptosystems also
use secret IVs, then either change them every once in
a while, or set them as a (cid:28)xed static value.

We said that CBC-R allows attackers to encrypt any
message, but if they cannot set the IV, the (cid:28)rst plain-
text block will be random and meaningless.
If the
victim expects the decrypted message to start with
a standard header, and attackers don’t control the
IV, then the victim will ignore the forged message
constructed by CBC-R. This is what happens with
compressed data, and Java serialized object streams
to name a few.

This limitation could prevent some of the highest im-
pact attacks, and we have not found generic way to
overcome it. However, we have found workarounds
for particular cases.

6

Pvalid = DK(Ccaptured|IVCBC−R|PCBC−R)

The resulting forged plaintext message will have a
valid header, but it still has a garbled block at the
position of IVCBC−R. This broken block can still
make the victim reject the message, but we can make
the victim ignore it if we choose the pre(cid:28)x carefully,
i.e., the garbled block becomes part of some string
that doesn’t a(cid:27)ect the semantic of the message such
as a comment or textbox label.

Brute-Forcing C0
In CBC-R, the (cid:28)nal block Cn−1
is a random block (See Figure 1). Each di(cid:27)erent
Cn−1would yield a di(cid:27)erent Cn−1, ..., C0 chain.
In
other words, CBC-R can produce many di(cid:27)erent ci-
phertexts that are decrypted to the same plaintext
block chain Pn−1, ..., P1. The only di(cid:27)erence is the
(cid:28)rst plaintext block which is computed as following:

P0 = DK(C0) ⊕ IV

Attackers want P0 to contain a valid header. In some
systems, this means that the (cid:28)rst few bytes of P0
must match some magic numbers. There are also
systems that accept a message only if the (cid:28)rst byte
of P0 matches the message length. If this is the case,
and if the message is short enough, attackers can try
their luck by brute-forcing C0.

Attackers change Cn−1, hence change C0, until they
can get a valid P0. For example, if the (cid:28)rst byte of
P0 must match the message size, trying at most 256
di(cid:27)erent CBC-R ciphertexts is enough to obtain a
valid message. For longer messages or more complex
validation rules, brute-forcing is not practical.

4.1.2 CBC-R Applications

Creating Malicious JSF view states
It is easy
to see that attackers can use CBC-R to create ma-

[...]it is possible for an attacker to supply
a new or modi(cid:28)ed view object as part of
a request. The malicious view can contain
arbitrary HTML code (allowing Cross-Site
Scripting), and arbitrary Expression Lan-
guage (EL) statements that will be executed
on the server. The EL statements can be
used to read data stored in user-scoped ses-
sion variables, and application or server-
scoped variables.

How to solve the garbled block problem? We
have to solve the garbled block problem because we
can’t control the IV in the JSF frameworks that we
have tested. The solution depends on the content of
JSF view states which are Java Object Serialization
Streams. The generic solution is to use the technique
described in Section 4.1.1 to prepend known valid
ciphertext to our CBC-R encrypted view state, and
make the garbled block become part of a string that
doesn’t a(cid:27)ect the semantic of the view state such as
a textbox label.

Please note that although we attack only JSF view
states, our techniques can be applied to exploit other
kind of state information in di(cid:27)erent formats such as
XML, serialized objects, JSON, simple comma sepa-
rated variable-value pairs, etc.

4.2 Distributed Cross-Site Padding

Oracle Attack

As we have demonstrated up to this point, all attack-
ers need to exploit padding oracle vulnerabilities is a
single bit of information. If a web site leaks out that
1-bit information, then there are a lot of ways for at-
tackers to obtain it using cross-domain information
leakage bugs in web browsers.

If you are familiar with web browser security, you
probably know that JavaScript at evil.com can not
read the response of a request to victim.com, other-
wise this would allow all kind of abuses from evil web
sites. But there’s nothing to stop evil.com refer-
encing resources on victim.com, observing how the
server responds, and deducing information.

Figure 2: CBC-R Encryption

licious view states that in the worst case could al-
low them to execute code on vulnerable JSF systems.
The two remaining questions are:

Which view state to create? The book of
Apache MyFaces and Facelets technology observed
that (See [8]):

[...]The view is restored by reversing the pro-
cess used to obtain the view state: it is de-
coded and deserialized. This poses a major
security challenge to any JSF implementa-
tion because Sean has the freedom to change
the view state. He can toggle the rendered
attribute of UI controls that are not sup-
posed to be available to him. He can point a
commandButton to a method on any man-
aged bean in the application. He can cir-
cumvent an action listener.

While we were writing this paper, a researcher
published an advisory describing vulnerabilities in
Apache MyFaces and SUN Mojarra, and claimed that
(See [2]) 6:

6It is important to stress that the authors of [8] and [2] were
wrong when they suggested that encrypting view states would
prevent the attacks they described

7

Using <img> tag plus the onerror()/onload()
events, JavaScript at evil.com can make web
browsers to load an image at victim.com, and know
if the image is loaded or not. This is 1-bit informa-
tion, and as you know, it is enough for the padding
oracle attack to work: if the image is loaded, then it
is VALID padding; otherwise, it is INVALID padding.

provided encrypt/decrypt functions would be vul-
nerable to padding oracle attacks. It is ironic that the
developers of ActiveSupport::MessageEncryptor
do provide a secure pair of
to en-
crypt/decrypt data that are not vulnerable to
padding oracle attacks, but they still keep the vul-
nerable ones. 8.

functions

This technique has allowed us to successfully de-
crypt all CAPTCHA on a target web site using only
JavaScript hosted in a di(cid:27)erent server 7. If a target is
interesting enough, attackers could inject JavaScript
code into popular web sites, and when people visit
those web sites, the code will run in their browsers,
and use their CPU time and Internet connection to
decrypt the target’s secrets. It is possible to distribu-
tively build a code book, i.e., a mapping of ciphertext
to corresponding plaintext under the same key and
IV as the padding oracle. This code book in turn can
be used to automatically bypass CAPTCHA protec-
tion with 100% accuracy regardless of the graphical
complexity.

5 Vulnerable Web Frameworks

Besides JavaServer Faces, we have also audited some
other popular web frameworks to see if they are vul-
nerable to padding oracle attacks. Here are some of
our (cid:28)ndings. We will publish more results in the near
future.

5.1 Ruby On Rails

Ruby On Rails, which was created in 2003, is one
of the most widely used web development frame-
work in the world. Since version 2.3, Ruby On Rails
has introduced ActiveSupport::MessageEncryptor
which is a set of
functions (cid:16)to provide a simple
way to encrypt information for storage in an un-
If you look at
trusted location (like cookies).(cid:17)
ActiveSupport::MessageEncryptor’s source code,
you would probably see that applications that use the

7Watch http://youtube.com/watch?v=e46A-PUpDvk

5.2 OWASP ESAPI

OWASP ESAPI, which stands for OWASP Enter-
prise Security API Toolkits, is a project that claim
to (cid:16)help software developers guard against security-
related design and implementation (cid:29)aws.(cid:17) However,
we found that all OWASP ESAPI for Java up to ver-
sion 2.0 RC2 are vulnerable to padding oracle at-
tacks. There were some signi(cid:28)cant changes in ESAPI
Encryption API since 2.0 RC3. Unfortunately, while
these changes are heading towards the correct direc-
tion, i.e., signing the ciphertext or using an authenti-
cated encryption mode, but at the time of this writ-
ing, there are still some bugs in the latest implemen-
tation that make applications using ESAPI for Java
still vulnerable to padding oracle attacks. We leave
the (cid:28)nding of these bugs as an exercise for readers.

6 Conclusion

In summary, in this paper we showed that padding
oracle attacks allow us to decrypt ciphertext with-
out knowing the key. We also described how to use
padding oracle attacks to break CAPTCHA systems,
and decrypt JSF view state. We also introduced
CBC-R, a new technique that turns a decryption or-
acle into an encryption oracle, and allow us to create
malicious JSF view states. We also demonstrated
how to leverage cross-domain site information leak-
age in web browsers to deploy a distributed padding
oracle attack that allow us to crack all CAPTCHA
codes of a target web site using only Javascript hosted
in a di(cid:27)erent server.

8Fortunately, ActiveSupport::MessageEncryptor is not

widely used.

8

nel. In Proc. CRYPTO 2003, D. Boneh (ed.),
LNCS Vol. 2729, pp. 583(cid:21)599, 2003.

[4] V. Klima and T. Rosa. Side Channel Attacks
on CBC Encrypted Messages in the PKCS#7
Format. Cryptology ePrint Archive, Report
2003/098, 2003.

[5] K.G. Paterson and A. Yau. Padding Oracle At-
tacks on the ISO CBC Mode Padding Standard.
In T. Okamoto, editor, Topics in Cryptology (cid:22)
CT-RSA 2004, volume 2964 of Lecture Notes
in Computer Science, pages 305(cid:21)323. Springer-
Verlag, 2004.

[6] S. Vaudenay. Security Flaws Induced by CBC
Padding (cid:22) Applications
IPSEC,
WTLS...In L. Knudsen, editor, Advances in
Cryptology (cid:22) EUROCRYPT 2002, volume 2332
of Lecture Notes in Computer Science, pages
534(cid:21)545. Springer-Verlag, 2002

to SSL,

[7] A. K. L. Yau, K. G. Paterson, and C. J. Mitchell.
Padding Oracle Attacks on CBC- Mode Encryp-
tion with Secret and Random IVs. In H. Gilbert
and H. Handschuh, editors, Proceedings of FSE
2005, volume 3557 of LNCS, pages 299(cid:21)319.
Springer- Verlag, 2005.

[8] Z. Wadia, M. Marinschek, Hazem Saleh, and
Dennis Byrne. Antipatterns and Pitfalls.
In
The De(cid:28)nitive Guide to Apache MyFaces and
Facelets, pages 229-269. Apress, 2008

We hope that this research has convinced you that
rolling your own crypto is extremely risky, and should
be avoided. After all, the padding oracle attack
has been known in crypto academic community since
2002. After 8 years, however, we still have a large
number of systems vulnerable to this attack. What
is even more surprising is the fact that we were the
(cid:28)rst to identify this vulnerability in popular technolo-
gies like JavaServer Faces.

Since August 2009 we have been carrying out a re-
search in which we test-run a number of identi(cid:28)ed
practical crypto attacks on random widely-used soft-
ware systems. To our surprise, most, if not all, can be
attacked by one or more of well-known crypto bugs.
This case is just one example. We hope that publish-
ing this vulnerability and other future results from
our research would encourage the security commu-
nity in taking a more serious look at crypto bugs in
software system which is as pervasive as SQL Injec-
tion or XSS in early 2000.

We hope you enjoy reading this paper as much as we
enjoyed writing it.

Acknowledgements We would like to thank
Huong L. Nguyen, Agustin Azubel, Thomas Ptacek,
rd, Gunther, Bruce Leidl, and Alex Sotirov for read-
ing and editing the draft of this paper.

References

[1] J. Black and H. Urtubia. Side-Channel Attacks
on Symmetric Encryption Schemes: The Case for
Authenticated Encryption. In Proceedings of the
11th USENIX Security Symposium, San Fran-
cisco, CA, USA, August 5-9, 2002, pages 327(cid:21)338.
USENIX, 2002.

[2] D. Byrne. (cid:16)Multiplatform View State Tampering
Vulnerabilities(cid:17). Trustwave’s SpiderLabs. 8 Feb.
2009. Trustwave.

[3] B. Canvel, A. Hiltgen, S. Vaudenay, and M. Vuag-
noux. Password Interception in a SSL/TLS Chan-

9



=== Content from seclists.org_d70edde7_20250125_212354.html ===

[![](/shared/images/nst-icons.svg#menu)](#menu)
![](/shared/images/nst-icons.svg#close)
[![Home page logo](/images/sitelogo.png)](/)
[Nmap.org](https://nmap.org/)
[Npcap.com](https://npcap.com/)
[Seclists.org](https://seclists.org/)
[Sectools.org](https://sectools.org)
[Insecure.org](https://insecure.org/)

![](/shared/images/nst-icons.svg#search)

[![oss-sec logo](/images/oss-sec-logo.png)](/oss-sec/)
## [oss-sec](/oss-sec/) mailing list archives

[![Previous](/images/left-icon-16x16.png)](356)
[By Date](date.html#357)
[![Next](/images/right-icon-16x16.png)](358)

[![Previous](/images/left-icon-16x16.png)](351)
[By Thread](index.html#357)
[![Next](/images/right-icon-16x16.png)](406)

![](/shared/images/nst-icons.svg#search)

# Re: CVE request: padding oracle attack: ruby on rails 2.3, owasp esapi

---

*From*: Josh Bressers <bressers () redhat com>

*Date*: Tue, 14 Sep 2010 15:36:53 -0400 (EDT)

---

```
I've assgiend two. The details are quite vague unfortunately.

CVE-2010-3299 padding oracle attack: ruby on rails 2.3
CVE-2010-3300 padding oracle attack: owasp esapi

Thanks.

--
    JB

----- "Thomas Biege" <thomas () suse de> wrote:

```
> ```
> Hi,
> the paper [1], about practical padding oracle attacks
> mentions some programming frameworks as vulnerable (section 5):
> - Ruby On ails 2.3
> - OWASP ESAPI
>
> I think they both need a CVE-ID. Thanks.
>
> Cheers
> Thomas
>
> [1] <http://usenix.org/events/woot10/tech/full_papers/Rizzo.pdf>
>
>
> --
>  Thomas Biege <thomas () suse de>, SUSE LINUX, Security Support &
> Auditing
>  SUSE LINUX Products GmbH, GF: Markus Rex, HRB 16746 (AG Nuernberg)
> --
>   Wer aufhoert besser werden zu wollen, hoert auf gut zu sein.
>                             -- Marie von Ebner-Eschenbach
>
> ```

```

```

---

[![Previous](/images/left-icon-16x16.png)](356)
[By Date](date.html#357)
[![Next](/images/right-icon-16x16.png)](358)

[![Previous](/images/left-icon-16x16.png)](351)
[By Thread](index.html#357)
[![Next](/images/right-icon-16x16.png)](406)

### Current thread:

* [CVE request: padding oracle attack: ruby on rails 2.3, owasp esapi](351) *Thomas Biege (Sep 14)*
  + **Re: CVE request: padding oracle attack: ruby on rails 2.3, owasp esapi** *Josh Bressers (Sep 14)*
    - [Re: CVE request: padding oracle attack: ruby on rails 2.3, owasp esapi](406) *Thomas Biege (Sep 21)*
      * [Re: CVE request: padding oracle attack: ruby on rails 2.3, owasp esapi](413) *Michael Koziarski (Sep 21)** [Re: CVE request: padding oracle attack: ruby on rails 2.3, owasp esapi](414) *Steven M. Christey (Sep 21)** [Re: CVE request: padding oracle attack: ruby on rails 2.3, owasp esapi](415) *Michael Koziarski (Sep 21)*

![](/shared/images/nst-icons.svg#search)

## [Nmap Security Scanner](https://nmap.org/)

* [Ref Guide](https://nmap.org/book/man.html)* [Install Guide](https://nmap.org/book/install.html)* [Docs](https://nmap.org/docs.html)* [Download](https://nmap.org/download.html)* [Nmap OEM](https://nmap.org/oem/)

## [Npcap packet capture](https://npcap.com/)

* [User's Guide](https://npcap.com/guide/)* [API docs](https://npcap.com/guide/npcap-devguide.html#npcap-api)* [Download](https://npcap.com/#download)* [Npcap OEM](https://npcap.com/oem/)

## [Security Lists](https://seclists.org/)

* [Nmap Announce](https://seclists.org/nmap-announce/)* [Nmap Dev](https://seclists.org/nmap-dev/)* [Full Disclosure](https://seclists.org/fulldisclosure/)* [Open Source Security](https://seclists.org/oss-sec/)* [BreachExchange](https://seclists.org/dataloss/)

## [Security Tools](https://sectools.org)

* [Vuln scanners](https://sectools.org/tag/vuln-scanners/)* [Password audit](https://sectools.org/tag/pass-audit/)* [Web scanners](https://sectools.org/tag/web-scanners/)* [Wireless](https://sectools.org/tag/wireless/)* [Exploitation](https://sectools.org/tag/sploits/)

## [About](https://insecure.org/)

* [About/Contact](https://insecure.org/fyodor/)* [Privacy](https://insecure.org/privacy.html)* [Advertising](https://insecure.org/advertising.html)* [Nmap Public Source License](https://nmap.org/npsl/)

[![](/shared/images/nst-icons.svg#twitter)](https://twitter.com/nmap "Visit us on Twitter")
[![](/shared/images/nst-icons.svg#facebook)](https://facebook.com/nmap "Visit us on Facebook")
[![](/shared/images/nst-icons.svg#github)](https://github.com/nmap/ "Visit us on Github")
[![](/shared/images/nst-icons.svg#reddit)](https://reddit.com/r/nmap/ "Discuss Nmap on Reddit")


