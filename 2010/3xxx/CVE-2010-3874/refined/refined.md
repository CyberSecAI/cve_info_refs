```
{
  "cveId": "CVE-2010-3874",
  "description": "A minor heap overflow in the CAN network module was fixed. Due to nature of the memory allocator it is likely not exploitable.",
  "vulnerabilityDetails": [
    {
      "source": "lists.opensuse.org_af1c7398_20250125_180411.html",
      "details": "A minor heap overflow in the CAN network module was fixed. Due to nature of the memory allocator it is likely not exploitable."
    },
    {
      "source": "www.spinics.net_cd4eac7a_20250125_180420.html",
       "details": "On 64-bit platforms the ASCII representation of a pointer may be up to 17 bytes long. This patch increases the length of the buffer accordingly.\n\nThe vulnerability is a minor heap overflow in the Controller Area Network (CAN) implementation in the Linux kernel, specifically within the `bcm_connect()` function in `net/can/bcm.c`. The `procname` buffer, intended to store the pointer as an ASCII string, is only 9 bytes long while on 64-bit systems, the pointer representation may be 17 bytes long. This causes a heap overflow during the `sprintf` operation to copy the pointer into the buffer. The allocated memory is larger due to the way the memory allocator works so it's unlikely exploitable."
    },
      {
      "source": "lists.opensuse.org_75ddeb99_20250125_180412.html",
      "details": "A minor heap overflow in the CAN network module was fixed. Due to nature of the memory allocator it is likely not exploitable."
    },
    {
        "source": "www.debian.org_9dc02099_20250125_180416.html",
        "details": "Dan Rosenberg discovered an issue in the Control Area Network (CAN) subsystem on 64-bit systems. Local users may be able to cause a denial of service (heap corruption)."
    },
    {
      "source": "openwall.com_091fce77_20250125_180414.html",
       "details": "The previously mentioned heap overflow is a semantic overflow only. Because the field that is being overflowed is the last field in a struct that is always allocated in a chunk significantly larger than the struct itself, the overflow will never result in any kind of corruption, so it has essentially no security impact."
    },
    {
      "source": "openwall.com_cb7b6981_20250125_180414.html",
      "details": "The overflow does not affect any decision-making, bypass protection logic, or cause a DoS. If the last field happens to be a bank account balance, or a flag stating whether a user has some kind of special privilege, then that's a security issue even without memory corruption."
    },
     {
      "source": "openwall.com_0b08f2c4_20250125_180414.html",
      "details": "Nothing is being overflowed except the boundary defined by the structure's declaration.  The last field of the structure corresponds to the name of a /proc entry, and is sized at 9 bytes.  On x86-64, up to 17 bytes can be copied into this field, but since there's nothing after the field but empty space in the heap chunk, nothing bad happens."
    },
      {
      "source": "bugzilla.redhat.com_5c08b98c_20250125_180422.html",
      "details": "In bcm_connect() (in net/can/bcm.c), there is the following code:\n\tsprintf(bo->procname, \"%p\", sock);\n\"procname\" is a 9-byte char array. On 64-bit platforms, up to 17 bytes may be copied into the buffer. Fortunately, structure padding will most likely prevent this from being a problem, except for the trailing NULL byte, which may overwrite the first byte of the next heap object."
    },
       {
      "source": "www.spinics.net_64f539f5_20250125_180420.html",
      "details": "In bcm_connect() (in net/can/bcm.c), I noticed the following code:\n\tsprintf(bo->procname, \"%p\", sock);\n\"procname\" is a 9-byte char array. This code is wrong on two levels.\nFirst, leaking a kernel address via a /proc filename is bad. Secondly, on 64-bit platforms, up to 17 bytes may be copied into the buffer. Fortunately, structure padding will most likely prevent this from being a problem, except for the trailing NULL byte, which may overwrite the first byte of the next heap object."
    },
       {
      "source": "lists.opensuse.org_c31a71a6_20250125_180411.html",
      "details": "A minor heap overflow in the CAN network module was fixed. Due to nature of the memory allocator it is likely not exploitable."
    }
  ],
  "affectedComponents": [
    "CAN network module",
    "net/can/bcm.c"
  ],
  "rootCause": "The `procname` buffer in `net/can/bcm.c` is too small to hold the full ASCII representation of a pointer on 64-bit systems. The `sprintf` function attempts to write the pointer's address into a fixed-size buffer leading to an overflow.",
  "vulnerabilities": [
    "Heap overflow"
  ],
  "impact": "While the overflow is technically present, it's considered non-exploitable, because the memory allocator in the kernel assigns memory in large chunks, and the overflow is contained within this larger chunk due to padding.",
  "attackVectors": [
    "Local"
  ],
  "attackerCapabilities": "Local user",
  "affectedProducts": [
    "openSUSE 11.2",
    "SUSE Linux Enterprise Real Time 11 SP1",
    "openSUSE 11.3",
    "SUSE Linux Enterprise High Availability Extension 11 SP1",
    "SUSE Linux Enterprise Desktop 11 SP1",
    "SUSE Linux Enterprise Server 11 SP1",
    "Red Hat Enterprise Linux 6"
    "MRG for RHEL-5",
   	 "Debian Linux 2.6.26"

  ]
}
```