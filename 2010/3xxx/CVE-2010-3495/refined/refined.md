```
Message-ID: <Pine.GSO.4.64.1009241357250.5338@faron.mitre.org>
Date: Fri, 24 Sep 2010 14:08:01 -0400 (EDT)
From: "Steven M. Christey" <coley@...us.mitre.org>
To: oss-security@...ts.openwall.com
cc: David Malcolm <dmalcolm@...hat.com>,
        "Steven M. Christey" <coley@...us.mitre.org>
Subject: Re: CVE Request -- Python -- accept() implementation
 in async core is broken => more subcases

On Wed, 22 Sep 2010, Josh Bressers wrote:

> Any update on this Steve?

This was a weird one to deal with.  There are a couple different
approaches.

We don't capture API "design limitations" in CVE (it would basically be
like assigning a CVE to "strcpy can be called with parameters that are
longer than the output buffer" or "setuid requires that the programmer
must check the return code to ensure that privileges were dropped.")

In this case, there is a "proper" way to handle the accept() behavior;
i.e. by catching the appropriate exceptions and accounting for an unusual
return value, the programmer can use the API safely.  That would argue for
treating it like strcpy/setuid/etc. design limitations, and holding
application programmers "responsible" for using it incorrectly.

However, there isn't some security-relevant documentation about these
specific API limitations.  So, a CVE could be assigned for the missing
documentation; alternately, we could treat it as "undocumented behavior"
in the API.  (This wouldn't be the first CVE related to documentation.)

Then, individual programs that happen to use the unpatched/older Pythons
can be held responsible for not accounting for this; similar to how we
"blame" applications for allowing XSS due to some non-standard
implementations within Internet Explorer, or Firefox, etc.

So:

CVE-2010-3492 - Python poor documentation of accept() behavior

CVE-2010-3493 - smtpd.py not catching errors generated by handle_accept

CVE-2010-3494 - pyftpdlib not catching errors generated by handle_accept

CVE-2010-3495 - ZODB not catching errors generated by handle_accept

- Steve
```
Based on the provided content, here's a breakdown of the CVE-2010-3495 vulnerability:

**Root Cause:**
- The root cause is in the Python `asyncore` module's `accept()` implementation. It can return a `None` value or raise exceptions such as `ECONNABORTED` or `EAGAIN` under certain conditions, such as when a client closes a connection abruptly during the handshake.
- This behavior was not properly documented.
- ZODB and other applications using `asyncore`'s `accept()` did not properly handle these errors.

**Weaknesses/Vulnerabilities:**
- Improper error handling of the `accept()` method in the ZODB application, specifically not catching `None` return value from `accept()`.
- Race condition that allows an attacker to cause `accept()` to return `None`, by sending a TCP RST packet close to the initial TCP handshake.

**Impact of Exploitation:**
- Denial of Service (DoS). The ZODB server stops accepting new connections when `accept()` returns `None` and the error is not handled gracefully.

**Attack Vectors:**
- Network-based. An attacker can trigger the vulnerability by sending a TCP RST packet close to the initial TCP handshake during the accept process.

**Required Attacker Capabilities/Position:**
- The attacker needs to be able to send network packets to the vulnerable server.
- The attacker does not require prior authentication.

**Additional Details:**
- The issue was originally found in the context of the ZODB application and was caused by the underlying behavior of the `asyncore` module, which failed to provide a robust and predictable way to handle incoming connections.
- Patches and workarounds involved modifying the applications to catch the error conditions returned by `accept()`.
- The python patch involved modifying `accept()` to explicitly return `None` and making it clear in documentation.
- A new `handle_accepted()` method was added to the `dispatcher` class in python's `asyncore` to allow for better error handling.

This issue highlights a case where the root cause is not a coding error in the affected applications directly, but rather a design flaw and documentation issue in the underlying framework (`asyncore`).