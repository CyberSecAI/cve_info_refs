Here's a breakdown of the information regarding CVE-2010-4529:

**Root Cause of Vulnerability:**

*   Integer underflow in the `irda_getsockopt` function within the Linux kernel's IrDA subsystem (`net/irda/af_irda.c`).

**Weaknesses/Vulnerabilities Present:**

*   The `irda_getsockopt` function, when handling `IRLMP_ENUMDEVICES` `getsockopt` calls, calculates an offset into the device list structure. If the user-provided length (`len`) argument is smaller than the calculated offset, an integer underflow occurs during the subsequent `copy_to_user()` operation.
*   The code does not check if `len` is less than the offset before performing copy_to_user operation resulting in `copy_to_user()` being called with a very large size value.

**Impact of Exploitation:**

*   **Information Leak:** On architectures other than x86, this can lead to a leak of potentially sensitive information from the kernel heap to user-space, as the `copy_to_user()` may read past the intended buffer.
*   The vulnerability does not cause a security issue on x86 because it is caught by the `access_ok()` check on that architecture.

**Attack Vectors:**

*   **Local User:** The vulnerability is exploitable by a local user who can make `getsockopt` calls with a crafted length value on a socket that is using the IrDA protocol.
*   Specifically, this involves making an `IRLMP_ENUMDEVICES` `getsockopt` call with a `len` value smaller than the offset for the start of the device list.

**Required Attacker Capabilities/Position:**

*   The attacker needs to be a local user with the ability to execute code on the affected system.
*   The attacker needs to be able to open a socket of the IrDA family and make `getsockopt` calls.

**Technical Details:**

*   The `IRLMP_ENUMDEVICES` getsockopt call is handled in the `irda_getsockopt` function.
*   The offset is calculated using: `sizeof(struct irda_device_list) - sizeof(struct irda_device_info)`.
*   The vulnerable code copies the total list length using: `copy_to_user(optval, &list, sizeof(struct irda_device_list) - sizeof(struct irda_device_info))`
*   The fix adds a check: `if (len < offset) { err = -EINVAL; goto out; }` which validates the user-provided length.

**Additional Notes:**

*   The vulnerability only impacts systems that have IrDA support enabled in the Linux kernel.
*   The vulnerability is not considered critical on x86 architectures, because of the access_ok() check which prevents out-of-bounds memory reads in the kernel.
*   The fix for the vulnerability involves adding a check to ensure the user-provided length is at least equal to the offset before proceeding with the copy to user operation.

This information is more detailed than the official CVE description, providing context, code locations, the specifics of the vulnerability, and attack vector information.