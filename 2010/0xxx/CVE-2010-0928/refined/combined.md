=== Content from www.eecs.umich.edu_86b3d2e3_20250125_043305.html ===
Fault Based Attack of RSA Authentication

Andrea Pellegrini, Valeria Bertacco and Todd Austin
University of Michigan
{apellegrini, valeria, austin}@umich.edu

ABSTRACT
For any computing system to be secure, both hardware and soft-
ware have to be trusted. If the hardware layer in a secure system
is compromised, not only it would be possible to extract secret in-
formation about the software, but it would also be extremely hard
for the software to detect that an attack is underway. In this work
we detail a complete end-to-end fault-attack on a microprocessor
system and practically demonstrate how hardware vulnerabilities
can be exploited to target secure systems. We developed a theo-
retical attack to the RSA signature algorithm, and we realized it
in practice against an FPGA implementation of the system under
attack. To perpetrate the attack, we inject transient faults in the tar-
get machine by regulating the voltage supply of the system. Thus,
our attack does not require access to the victim system’s internal
components, but simply proximity to it.

The paper makes three important contributions: ﬁrst, we develop
a systematic fault-based attack on the modular exponentiation al-
gorithm for RSA. Second, we expose and exploit a severe ﬂaw on
the implementation of the RSA signature algorithm on OpenSSL, a
widely used package for SSL encryption and authentication. Third,
we report on the ﬁrst physical demonstration of a fault-based secu-
rity attack of a complete microprocessor system running unmodi-
ﬁed production software: we attack the original OpenSSL authen-
tication library running on a SPARC Linux system implemented
on FPGA, and extract the system’s 1024-bit RSA private key in
approximately 100 hours.

1.

INTRODUCTION

Public-key cryptography schemes (Figure 1.a) are widely adopted
wherever there is a need to secure or authenticate conﬁdential data
on a public communication network. When deployed with sufﬁ-
ciently long keys, these algorithms are believed to be unbreakable.
Strong cryptographic algorithms were ﬁrst introduced to secure
communications among high performance computers that required
elevated conﬁdentiality guarantees. Today, advances in semicon-
ductor technology and hardware design have made it possible to
execute these algorithms in reasonable time even on consumer sys-
tems, thus enabling the mass-market use of strong encryption to
ensure privacy and authenticity of individuals’ personal communi-
cations. Consequently, this transition has enabled the proliferation
of a variety of secure services, such as online banking and shop-
ping. Examples of consumer electronics devices that routinely rely
on high-performance public key cryptography are Blu-ray play-
ers, smart phones, and ultra-portable devices.
In addition, low-
cost cryptographic engines are mainstream components in laptops,
servers and personal computers. A key requirement for all these
hardware devices is that they must be affordable. As a result, they
commonly implement a straightforward design architecture that en-
tails a small silicon footprint and low-power proﬁle.

Our research focuses on developing an effective attack on mass-
market crypto-chips. Speciﬁcally, we demonstrate an effective way
to perpetrate fault-based attacks on a microprocessor system in or-
der to extract the private key from the cryptographic routines that
it executes. Our work builds on a theoretical fault-based attack

proposed in [6], and extends it to stronger implementations of the
RSA-signature algorithm. In addition, we demonstrate the attack
in practice by generating a number of transient faults on an FPGA-
based SPARC system running Linux, using simple voltage manipu-
lation, and applying our proposed algorithm to the incorrectly com-
puted signatures collected from the system under attack. This at-
tack model is not uncommon since many embedded systems, for
cost reasons, are not protected against enviromental manipulations.
Our fault-based attack can be successfully perpetrated also on sys-
tems adopting techniques such as hardware self-contained keys and
memory/bus encryption.

The attack requires only limited knowledge of the victim sys-
tem’s hardware. Attackers do not need access to the internal com-
ponents of the victim chip, they simply collect corrupted signature
outputs from the system while subjecting it to transient faults. Once
a sufﬁcient number of corrupted messages have been collected, the
private key can be extracted through ofﬂine analysis.

Private key
(d)

Message  (m)

Public key
(e,n)

Client

System under
attack

Signature
(s=md mod n)

Authentication
(m == se mod n)

a) Public-key authentication

Private key
(d)

hardware fault

Message  (m)

Public key
(e,n)

Client

System under
attack

Broken signature (ŝ)

Private key extraction
< m, ŝ >

b) The proposed fault-based attack

Figure 1: Overview of public key authentication and our fault
based attack. a) in public key authentication, a client sends a
unique message m to a server, which signs it with its private key d.
Upon receiving the digital signature s, the client can authenticate
the identity of the server using the public key (n, e) to verify that s
will produce the original message m. b) Our fault based attack can
extract a server’s private key by injecting faults in the server’s hard
ware, which produces intermittent computational errors during the
authentication of a message. We then use our extraction algorithm
to compute the private key d from several unique messages m and
their corresponding erroneous signatures ˆs.

Occurrence of hardware faults. Current silicon manufacturing
technology has reached such extreme small scales that the occur-
rence of transient hardware failures is a natural phenomenon, caused
by environmental alpha particles or neutrons striking switching tran-
sistors. Similarly, occasional transient errors can be induced by
forcing the operative conditions of a computer system. A system-
atic vulnerability to these attacks can also be introduced during the
manufacturing process, by making some components in the system
more susceptible to transient faults than others.

Several consumer electronic products, such as ultra-mobile com-
puters, mobile phones and multimedia devices are particularly sus-

ceptible to fault-based attacks:
it is easy for an attacker to gain
physical access to such systems. Furthermore, even a legitimate
user of a device could perpetrate a fault-based attack on it to ex-
tract conﬁdential information that a system manufacturer intended
to keep secure (as, for instance, in the case of multimedia players).
Contributions of this work. This paper presents a fault-based
technique to perpetrate an attack on RSA authentication by ex-
ploiting microarchitectural or circuit-level vulnerabilities in digi-
tal hardware devices. It makes three key contributions: ﬁrst, we
extend the theoretical work proposed by Boneh et al., in [6] and
develop a novel RSA authentication attack (see also Figure 1.b),
which extracts a server’s RSA private key by extracting informa-
tion through perturbing the ﬁxed-width modular exponentiation al-
gorithm used in the popular OpenSSL library [1]. OpenSSL is an
open-source secure sockets layer (SSL) implementation of RSA
authentication [13], widely deployed in internet and web security
applications, including the Apache web server, BIND DNS server
and the OpenSSH secure shell. The second contribution is the dis-
covery of a severe vulnerability in the software implementation of
RSA authentication in OpenSSL, which can be expoited to perform
fault-based attacks.

Finally, we apply our technique to demonstrate the fault-based
attack on a SPARC-based microprocessor system, implemented on
FPGA and running Linux. We inject faults into the system through
by simply manipulating the voltage supply, resulting in occasional
transient faults in the SPARC processor’s multiplier. The injected
faults create computation errors in the system’s RSA authentication
routines, which we exploit to extract the private key. The attack is
perpetrated on an unmodiﬁed OpenSSL (version 0.9.8i).
In our
experiment we show that we can fully extract the server’s 1024-bit
private key in approximately 100 hours. Once the machine’s private
key is acquired, it becomes possible for the attacker to pose as the
compromised server to unsuspecting clients.

It is worth noting that this attack is immune to protection mech-
anisms such as system bus and/or memory encryption, and that it
does not damage the device, thus no tamper evidence is left to in-
dicate that a system has been compromised.

2. RELATED WORK

Several algorithms have been proposed to implement the ex-
ponentiation of large numbers, including techniques based on the
Chinese Remainder Theorem (CRT). This algorithm is particularly
prone to fault attacks, and several of them have been suggested as
reported in the literature [6, 10, 15]. Other algorithms for exponen-
tiation, such as square-and-multiply and right-to-left binary expo-
nentiation, are also susceptible to fault-based attacks [6]. Each uses
an ad-hoc fault model, ranging from altering the private exponent
stored in the system [3], to injecting single-bit errors into those reg-
isters storing partial exponentiation results [6], to carefully timing
fault-injections to corrupt a speciﬁc operation within the exponen-
tiation, as theorized in [7]. Our theoretical contribution adopts the
same single-bit ﬂip fault model proposed in [6].

The OpenSSL library quickly computes RSA private key signa-
tures using a CRT-based algorithm, and then checks the correctness
of the generated result (detecting potential attacks) by verifying it
with the public key and comparing the result with the original mes-
sage. If a mismatch is observed, it resorts to the more time con-
suming left-to-right squaring as a safety measure, since this latter
algorithm is considered resilient to security attacks. In our work
we rely on single-bit faults to attack precisely left-to-right squar-
ing (shown in Figure 2), since this algorithm is considered a “safe
back-up” in the OpenSSL library. While left-to-right squaring is
algorithmically similar to right-to-left repeated squaring, single-

bit faults have a distinctly different impact on the computational
results. This paper presents the ﬁrst systematic approach to fault-
based attacks of the left-to-right squaring algorithm, used in the
popular OpenSSL cryptographic library. We will refer to the par-
ticular implementation of the left-to-right exponentiation deployed
in OpenSSL as Fixed Window Exponentiation (FWE).

A theoretical example of a similar attack is presented in [5],
where functional errors in the hardware executing the exponenti-
ation algorithm are used to break RSA and other strong crypto-
graphic systems. In that work, the authors indicate how a functional
bug in the multiplier of a microprocessor can be exploited to this
end. Note, however, that the attack proposed is viable only if the
needed bug was to escape the hardware veriﬁcation phase, which is
a highly improbable proposition, given the extreme effort dedicated
to modern designs’ validation [9].

The number of reports that detail actual physical implementa-
tions of these attacks perpetrated through erroneous computation
in the hardware layer is very scarce. Recently, an attack on a phys-
ical implementation of the square-and-multiply algorithm running
on a microcontroller was demonstrated in [14]. Faults injected in
the microcontroller were used to control the program counter of
the victim, so that the program executing the exponentiation algo-
rithm would some speciﬁc instructions. Additionally, a few other
theoretical attacks have been physically demonstrated on simple
microcontroller-based systems and smart cards [2, 4]. One of our
key contributions in this paper is the ﬁrst physical demonstration
of a fault-based attack on a complete microprocessor-based sys-
tem, running unmodiﬁed software, including the Linux operating
system and a current version of the OpenSSL library.

3. AUTHENTICATION WITH RSA

RSA is a commonly adopted public key cryptography algorithm
[13]. Since it was introduced in 1977, RSA has been widely used
for establishing secure communication channels and for authenti-
cating the identity of service providers over insecure communica-
tion mediums. In the authentication scheme, the server implements
public key authentication with clients by signing a unique message
from the client with its private key, thus creating what is called a
digital signature. The signature is then returned to the client, which
veriﬁes it using the server’s known public key (see also Figure 1.a).
The procedure for implementing public key authentication re-
quires the construction of a suitable pair of public key (n, e) and
private key (n, d). Here n is the product of two distinct big prime
numbers, and e and d are computed such that, for any given mes-
sage m, the following identity holds true: m ≡ (md)e mod n ≡
(me)d mod n. To authenticate a message m, the server attaches
a signature s to the original message and transmits the pair. The
server generates s from m using its private key with the following
computation: s ≡ md mod n. Anyone who knows the public key
associated with the server can then verify that the message m and
its signature s were authentic by checking that: m ≡ se mod n.

3.1 Fixed window modular exponentiation

Modular exponentiation (md mod n) is a central operation in
public key cryptography. Many cryptographic schemes, including
RSA, ElGamal, DSA and Difﬁe-Hellman key exchange, heavily
rely on modular exponentiation for their algorithms. Several algo-
rithms that implement modular exponentiation are available [11].
In this paper we focus on the ﬁxed window exponentiation (FWE)
algorithm ([11] - chapter 14). This algorithm, used in OpenSSL-
0.9.8i, is guaranteed to compute the modular exponentiation func-
tion in constant time, and its performance depends only on the
length of the exponent. Because of this reason, the algorithm is

impervious to timing-based attacks [8].

The ﬁxed-window modular exponentiation algorithm is very sim-
ilar to square-and-multiply [14], but instead of examining each in-
dividual bit of the exponent, it deﬁnes a window, w bits wide,
and partitions the exponent in groups of w bits. Conceptually, the
length of the algorithm’s window may be either variable or ﬁxed.
However, using variable window lengths makes the computation
susceptible to timing-based attacks. To avoid these attacks, thus
OpenSSL utilizes a ﬁxed window size.

The FWE algorithm operates by computing the modular expo-
nentiation for each window of w bits of the exponent and accumu-
lating the partial results. Since w typically comprises just a few
bits, the exponent is correspondingly a small number, between 0
and (2w − 1), leading to a practical computation time. Figure 2
reports the pseudo-code for the algorithm, where an accumulator
register acc stores the partial results. The algorithm starts from
the most signiﬁcant bits of the exponent d and, during each itera-
tion, the bits of d corresponding to the window under consideration
are extracted and used to compute md[win idx] mod n (lines 7-9).
In addition, the bits of the window of d under consideration must
be shifted by w positions. Since d is the exponent of the message,
shifting d to the left by one position corresponds to squaring the
base. Shifting is thus accomplished by squaring the accumulator w
times (lines 5-6). Once all windows of size w have been considered,
the accumulator contains the ﬁnal value of md mod n. Note that,
in practice, the powers of m from 0 to 2w −1 are pre-computed and
stored aside, so that line 9 in the code reduces to a simple lookup
and multiplication. By leveraging the pre-computed powers of m,
the algorithm only requires a constant number of multiplications.

It is possible to reduce the window size w down to 1, in which
case the FWE algorithm degrades into square-and-multiply. How-
ever, using larger values of w brings noticeable beneﬁts to the com-
putation time, because of the smaller number of multiplications re-
quired. Finally, if we deﬁne k as the ratio between the number of
bits in d and w: k = #bits(d)/w, the general expression computed
by the FWE algorithm is:

s = (· · (mdk−1 )2w
= mdk−12w (k−1)

) · · · mdi )2w
· · · mdi2w i

) · · · md1 )2w
· · · md12w

)md0 mod n

md0 mod n

(1)

1
2
3
4
5
6
7
8
9
10

FWE(m, d, n, win size)

num win = #bits(d) / win size
acc = 1
for(win idx in [num win-1..0] )

for(sqr iter in [0..win size-1] )
acc = (acc * acc) mod n

d[win idx] =

bits(d, win idx*win size,win size)

acc = (acc * mˆd[win idx]) mod n

return acc

Figure 2: Fixed window exponentiation. The algorithm com
putes md mod n. For performance, the exponent d is partitioned in
num win windows of win size bits. Moreover, to ensure a constant
execution time, independent from the speciﬁc value of the exponent
d, a table containing all the powers of m from 0 to 2win size − 1 is
precomputed and stored aside.

4. HARDWARE FAULT MODEL

The fault-based attack that we developed in this work exploits
hardware faults injected at the server side of a public key authenti-
cation (see Figure 1.b). Speciﬁcally, we assume that an attacker can
occasionally inject faults that affecting the result of a multiplication
computed during the execution of the ﬁxed-window exponentiation
algorithm. Consequently, we assume that the system is subjected to

a battery of infrequent short-duration transient faults, that is, faults
whose duration is less than one clock cycle, so that they impact
at most one multiplication during the entire execution of the expo-
nentiation algorithm. Moreover, we only consider hardware faults
that produce a multiplication result differing from the correct one
in only one bit position, and simply disregard all others.

To make this attack possible, faults with the characteristics de-
scribed must be injected in the attacked microprocessor. For this
purpose, we exploit a circuit-level vulnerability common in micro-
processor design: multiplier circuits tend to be fairly complex, and
much effort has been dedicated to developing high performance
multipliers, that is, multipliers with short critical path delays. Even
so, often the critical path of a microprocessor system goes through
the multiplier circuit [12].
If environmental conditions (such as
high temperatures or voltage manipulation by an attacker) slow
down the signal propagation in the system, it is possible that signals
through the critical path do not reach their corresponding registers
or latches before the next clock cycle begins. In such situations,
one of the ﬁrst units to fail in computing correct results tends to
be the multiplier, because its “margin” of delay is minimal. Note
that not all multiplications would be erroneous, only those which
required values generated through the critical path.

In order to perpetrate our attack, we collect several pairs of mes-
sages m and their corrupted signatures ˆs, where ˆs has been sub-
jected to only one transient fault with the characteristics described.
In Section 6.1 we show how we could inject faults with the proper
characteristics in the authenticating machine. Moreover, while our
attack requires a single fault placed in the exponentiation multipli-
cation operation, it is resilient to multiple errors and errors placed
in other operations; however, those will not yield any useful infor-
mation about the private key.

4.1 FWE in presence of transient faults

The ﬁxed-window exponentiation algorithm in the OpenSSL li-
brary does not validate the correctness of the signature produced
before sending it to the client, a vulnerability that we exploit in our
attack. We now analyze the impact of a transient fault on the output
of the FWE algorithm (see Section 3.1). As mentioned above, the
software-level perception of the fault is a single-bit ﬂipped in one of
the multiplications executed during FWE. With reference to Figure
2, during FWE, multiplications are computed executing during ac-
cumulator squaring (line 6), message window exponentiation (line
9). For sake of simplicity, in this analysis we only consider mes-
sages that have been hit by a fault during any of the accumulator
squaring multiplications of line 6, the reasoning extends similarly
for faults affecting the multiplications of line 9.

Since the error manifests as a single-bit ﬂip, the corrupted result
will be modiﬁed by ±2f , where f is the position of the bit ﬂipped
in the partial result, that is, the location of the corrupted bit f is
in the range 0 ≤ f < #bits(acc). The error amount is added or
subtracted, depending on the transition induced by the ﬂip: if the
fault modiﬁed a bit from 1 to 0, the error is subtracted, otherwise it
is added. Thus, with reference to Eq. (1), showing the computation
executed by the FWE algorithm, if a single-bit ﬂip fault hits the
server during the pth squaring operation in the computation for the
ith window of the exponent d, the system will generate a corrupted
signature ˆs as follows (the mod n notation has been omitted):
ˆs = (· · (mdk−1 )2w
or, equivalently,

) · · · md1 )2w

) · · · mdi )2p

± 2f )2w−p

)md0 (2)

ˆs =

(

k−1

j=i+1
Y

mdj 2(j−i)w

)mdi2p

± 2f

2iw−p

i−1

!

j=0
Y

mdj 2jw

(3)

5. FAULT BASED ATTACK TO FWE

In this section we show how to extract the private key in a pub-
lic key authentication system from a set of messages m and their
erroneously signed counterpart ˆs, which have been collected by in-
jecting transient faults at the server.

We developed an algorithm whose complexity is only polyno-
mial on the size of the private key in bits. The algorithm proceeds
by attempting to recover one window of w bits of the private key
d at a time, starting from the most signiﬁcant set of bits. When
the ﬁrst window has been recovered, it moves on to the next one,
and so on. While working on a window i, it considers all message-
corrupted signature pairs, < m, ˆs >, one at a time, and attempts to
use them to extract the bits of interests. Pairs for which a fault has
been injected in a bit position within the window i can be effective
in revealing those key’s bits. All other pairs will fail at the task,
they will be discarded and used again when attempting to recover
the next windows of private key bits. The core procedure in the
algorithm, applied to one speciﬁc window of bits i and one spe-
ciﬁc < m, ˆs > pair, is a search among all possible fault locations,
private key window values and timing of the fault, with the goal of
ﬁnding a match for the values of the private key bits under study. In
the next section we present the details of the extraction algorithm.

5.1 Algorithm for private key recovery

THEOREM 5.1. Given a public key authentication system,
< n, d, e > where n and e are known and d is not known, and
for which the signature with the private key d of length N is com-
puted using the ﬁxed-window exponentiation (FWE) algorithm with
a window size w, we call k the number of windows in the private
key d, that is, k = N/w. Let us call ˆs a corrupted signature of
the message m computed with the private key d. Assume that a
single-bit binary value change has occurred at the output of any of
the squaring operations in FWE during the computation of ˆs. An
attacker that can collect at least S = k · ln(2k) different pairs
< m, ˆs > has a probability pr = 1/2 to recover the private key d
of N bits in polynomial time - O(2wN 3S).

The proof of Theorem 5.1 is presented in Appendix A. We de-
veloped an algorithm based on the construction presented there that
iterates through all the windows, starting from the one correspond-
ing to the most signiﬁcant bits. For each window, it considers one
message - signature < m, ˆs > pair at a time, discarding all of those
that lead to 0 or more than one solution for the triplet < di, f, p >.
As soon as a signature is found that provides a unique solution,
the value di can be determined, and the algorithm can advance to
recover the next window of bits.

already guessed
d3
*

d:

What is the value of d2?
[0..2w -1]
d2

d1

win_size/w
                  (4bits)
d0

In which squaring iteration p
did the fault occur? [0..3]

Which is the flipped-bit
location f ? [#bits(d)]
ŝ = (···(md3)2)2)2)2) md2)2)2±2f)2)2) md1)2··· md0

Figure 3: Example of our private key recovery. The schematic
shows a situation where the private key d to be recovered has size
16 bits, and each window is 4 bits long. Key recovery proceeds
by determining ﬁrst the 4 most signiﬁcant bits in d, d3. Then in
attempting to recover d2, all possible values for d2, p and f must be
checked to evaluate if they correspond to the signature ˆs. d2 may
assume values [0, 15], p [0, 3] and f [0, 15].

As an example, consider a window w of size 4, and m and d of
16 bits. Figure 3 illustrates this scenario. Assume that the most
signiﬁcant window has already been identiﬁed to be the 4-bit value
∗
3. In the inductive step we must search for an appropriate value of
d
d2, f and p that satisfy Eq. (10) in the Appendix. The ﬁgure shows
how the three components of the triplets correspond to different
variable aspects of the faulty signature ˆs.

The core function of the algorithm considers one message and its
corresponding signature, and it attempts to determine a valid triplet
satisfying Eq. (10). The function is illustrated in the pseudo-code
of Figure 4.

window search (m, s, e, win size, win idx)

found = 0;
for(d[win idx] in [0..2ˆwin size-1];
sqr iter in [0..win_size-1];
fault in [0..#bits(d)-1] )

found += test_equation 10( m, s, e,

win idx, d[win idx], sqr iter, fault loc)

if (found == 1) return d[win idx]
else return -1

Figure 4: Private key window search. The core function of the pri
vate key recovery algorithm considers one message signature pair
and scans through all possible values in the window d[win idx],
the fault location fault and the squaring iteration sqr iter. If one
and only one solution is found that satisﬁes Eq. (10), the function
returns the value determined for d[win idx].

The private key recovery algorithm invokes window search()
several times: for each window of the private key d, this core func-
tion is called using different < m, ˆs > pairs, until a successful
di is obtained. Figure 5 shows the pseudo-code for the overall al-
gorithm. Note that it is possible that no < m, ˆs > pair leads to
revealing the bits of the window under consideration. In this sit-
uation, the algorithm can still succeed by moving on to the next
window and doubling the window size. This is a backup measure
with signiﬁcant impact on the computation time. Alternatively it is
also possible to collect more < m, ˆs > pairs.

The private key extraction algorithm may be optimized in several
ways. It is possible to parallelize the computation by distributing
the search for a given window over several processes, each attempt-
ing to validate the same triplets of values over different signatures.
In addition, it is also possible to distribute different values for the
candidate triplets over different machines.

private key recovery ( array<m,s>, e, win size)

num win = #bits(d) / win size
for(win idx in [num win-1..0] )
for (<m,s> in array<m,s>)

d[win idx] = window_search(m,s,e,

win size, win idx)

if (d[win idx] >= 0) break

if (d[win idx] < 0) double win size

Figure 5: Private key recovery algorithm. The recovery algo
rithm sweeps all the windows of the private key, from the most
signiﬁcant to the least one. For each windows it determines the cor
responding bits of the private key d by calling window search()
until a successful value is returned. If no signature s can be used
to reveal the value of d[win idx], the window size is doubled for
the next iteration.

6. EXPERIMENTAL RESULTS

In this section we detail the physical attack that we performed
on a SPARC-based Linux system, and analyze the behavior of the
system under attack. The device under attack is a complete sys-
tem mapped on a ﬁeld-programmable gate array (FPGA) device.

The hardware consists of a SPARC-based Leon3 SoC from Gaisler
Research, which is representative of an off-the-shelf commericial
embedded device. In our experiments, the unmodiﬁed VHDL of
the Leon3 was mapped on a Xilinx Virtex2Pro FPGA. The system
runs a Debian/GNU distribution with Linux Kernel version 2.6.21
and OpenSSL version 0.9.8i

6.1 Induced fault rate

As we mentioned in Section 4, voltage regulation is critical to
an efﬁcient implementiation of a fault-based attack. If the voltage
is too high, the rate of faults is too low, and it will require a long
time to gather a sufﬁcient number of faulty digital signatures. If the
voltage is too low, the fault rate increases, causing system instabil-
ity and multiple bit errors for each FWE algorithm invocation, thus
yielding no private key information.

Figure 6 shows the injected fault rate as a function of the supply
voltage. We studied the behavior of the hardware system comput-
ing the functions used in the OpenSSL library while being sub-
jected to supply voltage manipulation.
In particular, we studied
the behavior of the routine that computes the multiplication using
10,000 randomly generated operand pairs of 1,024 bits in length.

)

%

(

s
t
l
u
a
f

t
i
b

l

e
g
n
S

i

Single bit faults

Faulty multiplications

60

50

40

30

20

10

0

s
t
l
u
a
f

f
o

r
e
b
m
u
N

1650

1375

1100

825

550

275

0

1.28

1.29

1.30

1.25

1.24

1.23

1.27
1.26
Voltage [V]
Figure 6: Sensitivity of multiplications executed in OpenSSL
to voltage manipulations. The graph plots the behavior of the
system under attack computing a set of 10,000 multiplications with
randomly selected input operands at different supply voltages. The
number of faults increases exponentially as the voltage drops. The
graph also reports the percentage of erroneous products that mani
fest only a single bit ﬂip.

As expected, the number of faults grows exponentially with de-
creasing voltage. In the graph of Figure 6 we also plotted the frac-
tion of FWE erroneous computations that incurred only a single-bit
fault, as it is required to extract private key information effectively.
Note that, with decreasing voltage, eventually the fraction of single
fault events begins to decrease as the FWE algorithm experiences
multiple faults more frequently. The ideal voltage is the one at
which the rate of single bit fault injections is maximized, 1.25V for
our experiment. The error rate introduced at that voltage is consis-
tent with the computational characteristics of FWE, which requires
1,261 multiplications to compute the modular exponentiation of a
1,024-bit key. Thus, the attacker should target a multiplication fault
rate of about 1 in 1,261 multiplications (0.079%). Using this par-
ticular voltage during the signature routine we found that 88% of
all FWE invocations led to a corrupt signature.

6.2 Faulty signature collection

In our experiments, we gathered 10,000 digital signatures com-
puted using a 1024-bit private RSA key. Once collected, signatures
were ﬁrst tested to check if they were faulty (by verifying them
with the victim machine’s public key). Once a faulty signature was
identiﬁed, it was sent to a distributed analysis framework that im-

plemented the algorithm outlined in Section 5.1. By setting the
supply voltage at 1.25V, we found that 8,800 of the 10,000 signa-
tures were incorrect. Within this set, only 12% (1,015 in total) had
incurred a single-bit fault in the result of only one multiplication
during the computation of the FWE algorithm, leading to useful
corrupted signatures for our private key recovery routine. The sub-
set of corrupted signatures that conforms to our fault model is not
known a priori, thus all the 8,800 collected signatures had to be
analyzed with our algorithm.

The analysis was run on a 81-machine cluster of 2.4 GHz Intel
Pentium4-based systems, running Linux. The distributed algorithm
was implemented using the OpenMPI libraries and followed a clas-
sic master-slave computing paradigm, with one machine acting as
a master and 80 as slaves. The master distributed approximately
110 messages to each slave for checking. Individual slaves could
check a message against a single potential window value and all
fault locations and squaring iterations in about 2.5 seconds. During
the analysis, the master directed all slaves to check their own mes-
sages for a particular single-bit fault in a particular window of the
FWE computation. To reduce the time for synchronizing slaves,
we divided their messages into 4 equal-size groups, and processed
these groups serially until the value of the key window was found.

d
e
r
e
v
o
c
e
r

y
e
k
e
a
v
i
r
p

t

f

o

%

100

80

60

40

20

0

0

100

200

300

400

500

600

700

Number of corrupted signatures processed

Figure 7: Cumulative percentage of private key bits recovered.
To recover the private key in the shortest amount of time, we need
to collect at least one corrupted signature for each of the exponent
windows. The graph shows the percent of key bits recovered as a
function of the number of faulty signatures analyzed.

Figure 7 shows the percentage of the total private key bits re-
covered, as a function of single-bit faulty signatures processed. As
shown in the graph, the full key is recovered after about 650 single-
bit faulty signatures are processed. Figure 8 shows the number of
single-bit corrupted signatures available for each bit position within
the 1024-bit FEW multiplication. We found that the bit errors were
skewed towards the most-signiﬁcant bits of the processor’s 32-bit
datapath (due to the longer circuit paths used to compute these bits),
thus by searching for bit errors in these bit positions ﬁrst, we could
signiﬁcantly speed up the search process. With our distributed anal-
ysis system, our computer cluster was able to recover the private
key of the attacked system in 104 hours, for a total of about one
year of CPU time. We expect the overall performance of the dis-
tributed application to scale linearly with the number of workers in
the cluster.

7. CONCLUSIONS

In this work we described an end-to-end attack to a RSA au-
thentication scheme on a complete FPGA-based SPARC computer
system. We theorized and implemented a novel fault-based attack
to the ﬁxed-window exponentiation algorithm and applied it to the
well known and widely used OpenSSL libraries. In doing so we
discovered and exposed a major vulnerability to fault-based attacks
in a current version of the libraries and demonstrated how this at-
tack can be perpetrated even with limited computational resources.

256

384

768
512
Position of corrupted bit [0-1023]

640

896

1024

ˆs = (mdk−12p

± 2f )2w(k−1)−p

k−2

Y
j=0

mdj 2jw

(4)

80

70

60

50

40

30

20

10

0

s
e
r
u
t
a
n
g
s

i

#

0

128

Figure 8: Single bit fault locations in the corrupted signatures.
Due to the implementation of the OpenSSL functions and the mul
tiplier used in the processor, the number of locations that might
be corrupted in our experiment was limited to only a few locations.
This signiﬁcantly reduced the computational time needed to recover
the key, since only a few fault locations have to be tested before the
correct result is recovered.

To demonstrate the effectiveness of our attack, we subjected a
SPARC Linux system to a fault injection campaign, implemented
through simple voltage manipulation. The system attacked was
running an unmodiﬁed version of the OpenSSL library. Using our
attack technique, we were able to successfully extract the server’s
1024-bit RSA private key in 104 hours. The work presented in this
paper further underscores the potential danger that systems face due
to fault-based attacks and exposes a severe weakness to fault-based
attacks in the OpenSSL libraries.

Acknowledgments
The authors acknowledge the support of the National Science Foun-
dation and the Gigascale Systems Research Center.

8. REFERENCES
[1] OpenSSL: The Open Source toolkit for SSL/TLS. http://www.openssl.org.
[2] C. Aum¨uller, P. Bier, W. Fischer, P. Hofreiter, and J.-P. Seifert. Fault attacks on
RSA with CRT: Concrete results and practical countermeasures. In Proc. of the
Workshop on Cryptographic Hardware and Embedded Systems, Aug 2003.
[3] F. Bao, R. Deng, Y. Han, A. Jeng, D. Narasimhalu, and T.-H. Ngair. Breaking
public key cryptosystems on tamper resistant devices in the presence of
transient faults. In Proc. of the Workshop on Security Protocols, Apr 1998.

[4] H. Bar-El, H. Choukri, D. Naccache, M. Tunstall, and C. Whelan. The

sorcerer’s apprentice guide to fault attacks. Proc. of the IEEE, Feb 2006.
[5] E. Biham, Y. Carmeli, and A. Shamir. Bug Attacks. In Proc. of Advances in

Cryptology, Aug 2008.

[6] D. Boneh, R. Demillo, and R. Lipton. On the importance of eliminating errors

in cryptographic computations. Journal of Cryptology, Dec 2001.

[7] M. Boreale. Attacking right-to-left modular exponentiation with timely random

faults. In Proc. of the Workshop of Fault Diagnosis and Tolerance in
Cryptography, Oct 2006.

[8] D. Brumley and D. Boneh. Remote timing attacks are practical. In Proc. of

USENIX Security Symposium, Jun 2003.

[9] K. Hamaguchi, A. Morita, and S. Yajima. Efﬁcient construction of binary

moment diagrams for verifying arithmetic circuits. In Proc. of the International
Conference on Computer-Aided Design, Nov 1995.

[10] M. Joye, A. Lenstra, and J.-J. Quisquater. Chinese remaindering based

cryptosystems in the presence of faults. Journal of Cryptology, Dec 1999.

[11] A. Menezes, P. V. Oorschot, and S. Vanstone. Handbook of Applied

Cryptography. CRC Press, Oct. 1996.

[12] J. Rabaey, A. Chandrakasan, and B. Nikolic. Digital Integrated Circuits.

Prentice Hall, 2 edition, Jan 2003.

[13] R. Rivest, A. Shamir, and L. Adleman. A method for obtaining digital

signatures and public-key cryptosystems. Communications of the ACM, Feb
1978.

[14] J. Schmidt and C. Herbst. A practical fault attack on square and multiply. In

Proc. of the Workshop of Fault Diagnosis and Tolerance in Cryptography, Aug
2008.

[15] D. Wagner. Cryptanalysis of a provably secure CRT-RSA algorithm. In Proc. of

the Conference on Computer and communications security, Oct 2004.

Appendix A   Proof of Theorem 5.1
From here on, all expressions are implicitly assumed to be modn, we omit the no-
tation for reasons of space. Deﬁne k as the ratio between the number of bits in the
private key d and the number of bits w in the window size: k = #bits(d)/w. The
proof proceeds by induction. For the base case, we show that the value of the private
key in the most signiﬁcant window, indexed k − 1, can be recovered. For the inductive
step, we show that, if the value of the private key for windows i + 1 to k − 1 is known,
then we can recover the value for window i.
Base case. We consider one of the < m, ˆs > pairs and we assume that the fault in the
corrupted signature ˆs was injected during the pth squaring iteration, with 1 ≤ p ≤ w.
Hence, from Eq. (3), ˆs will have the form:

The value of dk−1 is bound by: 0 ≤ dk−1 < 2w. The fault location f can
assume any value in 0 ≤ f < #bits(d). Finally the squaring iteration p satisﬁes
0 ≤ p < w. Assume that the correct values for dk−1, f and p were known to be
∗
(the correct values for di, 0 ≤ i ≤ k − 2 are not known). Then
k−1, f
d
k−12w(k−1)

we can multiply both sides of Eq. (4) by m

and obtain:

and p

d

∗

∗

∗

d

∗

k−1 2w(k−1)

ˆs · m

∗

d

∗
k−12p

± 2f

∗

)2w(k−1)−p

∗

· md

= (m

If we raise both sides to the known public exponent e, we obtain:

(ˆs · m(d

∗

k−1 )2w(k−1)

)e = (m

∗

d

∗
k−12p

± 2f

∗

)e2(w(k−1)−p

∗

)

mde

ˆse · m

e(d

∗

k−1)2w(k−1)

∗

d

∗
k−12p

± 2f

∗

)e2(w(k−1)−p

∗

)

m

= (m

(5)

(6)

(7)

It is now possible to search for all triplets < d
> that satisfy Eq. (7), by
varying each value within the legal range speciﬁed above and checking if the identity
holds. Three situations may arise:

, p

∗
k−1, f

∗

∗

1. No

, p

is
∗

found.

solution
∗
∗
k−1, f

triplet
> exists that satisﬁes the equation. In this case, the pair
< d
< m, ˆs > is discarded and another one is considered. This situation may
arise, for instance, if the corrupted signature ˆs was subjected to a fault during
an iteration outside the analyzed window.

possible

that

no

is

It

2. Exactly one solution. If only one set of values for d

satisﬁes
Eq. (7), then the value of the private key in the (k − 1)th window has been
found.

and p

∗
k−1, f

∗

∗

3. More than one solution.

In this case, one of the triplets include the correct
∗
k−1 value, while the others correspond to other set of values that still satisfy
d
Eq. (7), but do not correspond to the correct private key d on the server side. In
this case, the pair < m, ˆs > should also be discarded.

Inductive step. The value of the private key d for windows indexed i + 1 to k − 1
is known. We want to ﬁnd the value di. We proceed similarly to the base step. From
Eq. (3), ˆs will now have the form:

ˆs = 0
(
@

k−1

Y
j=i+1

mdj 2(j−i)w

)mdi2p

2iw−p

± 2f 1
A

i−1

Y
j=0

mdj 2jw

(8)

∗
We want to identify a triplet < d
i is the value we are
, p
searching for. The ranges for the three values are 0 ≤ di < 2w, 0 ≤ f < #bits(d)
and 0 ≤ p < k. To this end, we ﬁrst assume that we have found such triplet and we

> for which d

∗
i , f

∗

∗

multiply Eq. (8) by

k−1

j=i mdj 2jw

Q

:

ˆs ·

k−1

Y
j=i

mdj 2jw

= md 0
(
@

k−1

Y
j=i+1

mdj 2(j−i)w

)md

∗

∗
i 2p

and then raise it to the exponent e to obtain:

ˆse

k−1

Y
j=i

medj 2jw

= m 0
(
@

k−1

Y
j=i+1

mdj 2(j−i)w

)md

∗

∗
i 2p

∗

2iw−p

∗ 1

± 2f

A

(9)

e2iw−p

∗

∗ 1

± 2f

A

(10)

Note that all values dj for i ≤ j < k are known. There are again three possible
outcomes in the search for a triplet satisfying Eq. (10): we only accept < m, ˆs >
pairs that lead to one and only one satisfying solution.

In conclusion, given a sufﬁcient number of < m, ˆs > pairs, it is always possible
to ﬁnd a subset of cardinality k that allows to determine all di for 0 ≤ i < k. By
concatenating the di, we obtain the private key d. 2

In practice, the situation where more than one solution to Eq. (7) or Eq. (10) is
found has extremely low probability and never occurred in our experiments. Com-

plexity and success probability of our attack can be inferred from [6], which targets a
different exponentiation algorithm but proposes a similar attack.



=== Content from www.theregister.co.uk_aa8c8867_20250125_043306.html ===


[![](/design_picker/ae01b183a707a7db8cd5f2c947715ed56d335138/graphics/std/user_icon_white_extents_16x16.png)
![](/design_picker/ae01b183a707a7db8cd5f2c947715ed56d335138/graphics/std/user_icon_white_filled_extents_16x16.png)
Sign in / up](https://account.theregister.com/register/)

[![The Register® — Biting the hand that feeds IT](/design_picker/fa16d26efb42e6ba1052f1d387470f643c5aa18d/graphics/std/reg_logo_no_strapline.png)](https://www.theregister.com/)

[![](/design_picker/ae01b183a707a7db8cd5f2c947715ed56d335138/graphics/std/magnifying_glass_white_extents_16x16.png)](https://search.theregister.com/)

![](/design_picker/ae01b183a707a7db8cd5f2c947715ed56d335138/graphics/icon/burger_menu_white_16x16.png)
![](/design_picker/ae01b183a707a7db8cd5f2c947715ed56d335138/graphics/icon/burger_menu_white_close_16x16.png)

## Topics

[Security](#subnav-box-nav-security)
## [Security](#subnav-box-nav-security)

[All Security](https://www.theregister.com/security/)[Cyber-crime](https://www.theregister.com/security/cyber_crime/)[Patches](https://www.theregister.com/security/patches/)[Research](https://www.theregister.com/security/research/)[CSO](https://www.theregister.com/security/cso/)
[(X)](#masthead)

[Off-Prem](#subnav-box-nav-off_prem)
## [Off-Prem](#subnav-box-nav-off_prem)

[All Off-Prem](https://www.theregister.com/off_prem/)[Edge + IoT](https://www.theregister.com/off_prem/edge_iot/)[Channel](https://www.theregister.com/off_prem/channel/)[PaaS + IaaS](https://www.theregister.com/off_prem/paas_iaas/)[SaaS](https://www.theregister.com/off_prem/saas/)
[(X)](#masthead)

[On-Prem](#subnav-box-nav-on_prem)
## [On-Prem](#subnav-box-nav-on_prem)

[All On-Prem](https://www.theregister.com/on_prem/)[Systems](https://www.theregister.com/on_prem/systems/)[Storage](https://www.theregister.com/on_prem/storage/)[Networks](https://www.theregister.com/on_prem/networks/)[HPC](https://www.theregister.com/on_prem/hpc/)[Personal Tech](https://www.theregister.com/on_prem/personal_tech/)[CxO](https://www.theregister.com/on_prem/cxo/)[Public Sector](https://www.theregister.com/on_prem/public_sector/)
[(X)](#masthead)

[Software](#subnav-box-nav-software)
## [Software](#subnav-box-nav-software)

[All Software](https://www.theregister.com/software/)[AI + ML](https://www.theregister.com/software/ai_ml/)[Applications](https://www.theregister.com/software/applications/)[Databases](https://www.theregister.com/software/databases/)[DevOps](https://www.theregister.com/software/devops/)[OSes](https://www.theregister.com/software/oses/)[Virtualization](https://www.theregister.com/software/virtualization/)
[(X)](#masthead)

[Offbeat](#subnav-box-nav-offbeat)
## [Offbeat](#subnav-box-nav-offbeat)

[All Offbeat](https://www.theregister.com/offbeat/)[Debates](https://www.theregister.com/Debates/)[Columnists](https://www.theregister.com/offbeat/columnists/)[Science](https://www.theregister.com/offbeat/science/)[Geek's Guide](https://www.theregister.com/offbeat/geeks_guide/)[BOFH](https://www.theregister.com/offbeat/bofh/)[Legal](https://www.theregister.com/offbeat/legal/)[Bootnotes](https://www.theregister.com/offbeat/bootnotes/)[Site News](https://www.theregister.com/offbeat/site_news/)[About Us](https://www.theregister.com/offbeat/about_us/)
[(X)](#masthead)

[Special Features](#subnav-box-nav-special_features)
## Special Features

[All Special Features](https://www.theregister.com/special_features)
[The Future of the Datacenter](https://www.theregister.com/special_features/future_of_the_datacenter)
[Cybersecurity Month](https://www.theregister.com/special_features/cybersecurity_month)
[VMware Explore](https://www.theregister.com/special_features/vmware_explore)
[Cloud Infrastructure Month](https://www.theregister.com/special_features/cloud_infrastructure_month)

## Vendor Voice

[Vendor Voice](#subnav-box-nav-tag-vendor-voice)
## [Vendor Voice](#subnav-box-nav-tag-vendor-voice)

[All Vendor Voice](https://www.theregister.com/VendorVoice/)
[Amazon Web Services (AWS) New Horizon in Cloud Computing](https://www.theregister.com/VendorVoice/aws_new_horizon_financial_services/)
[Pure Storage](https://www.theregister.com/VendorVoice/pure_storage_portworx/)
[Kilka Tech](https://www.theregister.com/VendorVoice/aws_klika_tech/)
[HERE and AWS](https://www.theregister.com/VendorVoice/aws_here/)
[Vonage](https://www.theregister.com/VendorVoice/aws_vonage/)
[GE Vernova with AWS](https://www.theregister.com/VendorVoice/aws_ge_vernova_manufacturing/)
[Google Cloud Data Transformation](https://www.theregister.com/VendorVoice/google_cloud_data_transformation/)
[Google Gemini](https://www.theregister.com/VendorVoice/google_gemini/)
[(X)](#masthead)

[Resources](#subnav-box-nav-resources)
## Resources

[Whitepapers](https://whitepapers.theregister.com/)
[Webinars & Events](https://whitepapers.theregister.com/events/list/)
[Newsletters](https://account.theregister.com/edit/newsletter/)

[![](https://pubads.g.doubleclick.net/gampad/ad?co=1&iu=/6978/reg_security/front&sz=300x50%7C300x100%7C300x250%7C300x251%7C300x252%7C300x600%7C300x601&tile=2&c=2Z5RpgtJudNbAEDmQc2xXFAAAAAU&t=ct%3Dns%26unitnum%3D2%26raptor%3Dcondor%26pos%3Dtop%26test%3D0)](https://pubads.g.doubleclick.net/gampad/jump?co=1&iu=/6978/reg_security/front&sz=300x50%7C300x100%7C300x250%7C300x251%7C300x252%7C300x600%7C300x601&tile=2&c=2Z5RpgtJudNbAEDmQc2xXFAAAAAU&t=ct%3Dns%26unitnum%3D2%26raptor%3Dcondor%26pos%3Dtop%26test%3D0)

#### [Security](/security/)

[**62**
![comment bubble on white](/design_picker/f5daacc84b9722c1e31ba85f836c37e4ad993fc4/graphics/icons/bubble_comment_white.png)](https://forums.theregister.com/forum/all/2010/03/04/severe_openssl_vulnerability/ "View comments on this article")

This article is more than **1 year old**

# 'Severe' OpenSSL vuln busts public key crypto

[**62**
![comment bubble on white](/design_picker/f5daacc84b9722c1e31ba85f836c37e4ad993fc4/graphics/icons/bubble_comment_white.png)](https://forums.theregister.com/forum/all/2010/03/04/severe_openssl_vulnerability/ "View comments on this article")

## Private keys pilfered through power supply

![icon](/design_picker/d518b499f8a6e2c65d4d8c49aca8299d54b03012/graphics/icon/vulture_red.svg)
[Dan Goodin](/Author/Dan-Goodin "Read more by this author")

Thu 4 Mar 2010  //
21:00 UTC

![](/design_picker/d2e337b97204af4aa34dda04c4e5d56d954b216f/graphics/icons/social_share_icon.svg)

Computer scientists say they've discovered a "severe vulnerability" in the world's most widely used software encryption package that allows them to retrieve a machine's secret cryptographic key.

The bug in the OpenSSL cryptographic library is significant because the open-source package is used to protect sensitive data in [countless](http://www.openssl.org/related/kits.html) [applications](http://www.openssl.org/related/apps.html) and [operating systems](http://www.openssl.org/related/misc.html) throughout the world. Although the attack technique is difficult to carry out, it could eventually be applied to a wide variety of devices, particularly media players and smartphones with anti-copying mechanisms.

"Wherever you need to verify the origin of a piece of software or a piece of information, those building blocks come in handy," said Karsten Nohl, an independent security researcher. Nohl has in unrelated attacks broken encryption in widely used [smartcards](https://www.theregister.com/2008/03/12/mifare_classic_smartcard_crack/) and [cordless phones](https://www.theregister.com/2010/02/08/dect_phone_encryption_cracked/). "The OpenSSL library provides much more than just SSL."

[![](https://pubads.g.doubleclick.net/gampad/ad?co=1&iu=/6978/reg_security/front&sz=300x50%7C300x100%7C300x250%7C300x251%7C300x252%7C300x600%7C300x601&tile=2&c=2Z5RpgtJudNbAEDmQc2xXFAAAAAU&t=ct%3Dns%26unitnum%3D2%26raptor%3Dcondor%26pos%3Dtop%26test%3D0)](https://pubads.g.doubleclick.net/gampad/jump?co=1&iu=/6978/reg_security/front&sz=300x50%7C300x100%7C300x250%7C300x251%7C300x252%7C300x600%7C300x601&tile=2&c=2Z5RpgtJudNbAEDmQc2xXFAAAAAU&t=ct%3Dns%26unitnum%3D2%26raptor%3Dcondor%26pos%3Dtop%26test%3D0)

The scientists, from the University of Michigan's electrical engineering and computer science departments, said the bug is easily fixed by applying cryptographic "salt" to an underlying error-checking algorithm. The additional randomization would make the attack unfeasible.

[![](https://pubads.g.doubleclick.net/gampad/ad?co=1&iu=/6978/reg_security/front&sz=300x50%7C300x100%7C300x250%7C300x251%7C300x252%7C300x600%7C300x601&tile=4&c=44Z5RpgtJudNbAEDmQc2xXFAAAAAU&t=ct%3Dns%26unitnum%3D426raptor%3Dfalcon%26pos%3Dmid%26test%3D0)](https://pubads.g.doubleclick.net/gampad/jump?co=1&iu=/6978/reg_security/front&sz=300x50%7C300x100%7C300x250%7C300x251%7C300x252%7C300x600%7C300x601&tile=4&c=44Z5RpgtJudNbAEDmQc2xXFAAAAAU&t=ct%3Dns%26unitnum%3D4%26raptor%3Dfalcon%26pos%3Dmid%26test%3D0)

[![](https://pubads.g.doubleclick.net/gampad/ad?co=1&iu=/6978/reg_security/front&sz=300x50%7C300x100%7C300x250%7C300x251%7C300x252%7C300x600%7C300x601&tile=3&c=33Z5RpgtJudNbAEDmQc2xXFAAAAAU&t=ct%3Dns%26unitnum%3D3%26raptor%3Deagle%26pos%3Dmid%26test%3D0)](https://pubads.g.doubleclick.net/gampad/jump?co=1&iu=/6978/reg_security/front&sz=300x50%7C300x100%7C300x250%7C300x251%7C300x252%7C300x600%7C300x601&tile=3&c=33Z5RpgtJudNbAEDmQc2xXFAAAAAU&t=ct%3Dns%26unitnum%3D3%26raptor%3Deagle%26pos%3Dmid%26test%3D0)

An OpenSSL official, who asked that his name not be published, said engineers are in the process of pushing out a patch and stressed the attack is difficult to carry out in real-world settings.

The university scientists found that they could deduce tiny pieces of a private key by injecting slight fluctuations in a device's power supply as it was processing encrypted messages. In a little more than 100 hours, they fed the device enough "transient faults" that they were able to assemble the entirety of its 1024-bit key.

[![](https://pubads.g.doubleclick.net/gampad/ad?co=1&iu=/6978/reg_security/front&sz=300x50%7C300x100%7C300x250%7C300x251%7C300x252%7C300x600%7C300x601&tile=4&c=44Z5RpgtJudNbAEDmQc2xXFAAAAAU&t=ct%3Dns%26unitnum%3D426raptor%3Dfalcon%26pos%3Dmid%26test%3D0)](https://pubads.g.doubleclick.net/gampad/jump?co=1&iu=/6978/reg_security/front&sz=300x50%7C300x100%7C300x250%7C300x251%7C300x252%7C300x600%7C300x601&tile=4&c=44Z5RpgtJudNbAEDmQc2xXFAAAAAU&t=ct%3Dns%26unitnum%3D4%26raptor%3Dfalcon%26pos%3Dmid%26test%3D0)

"This is probably not as much of a threat to a server system as it is to a consumer device," said Todd Austin, one of the scientists who devised the attack. "The place where this would be more applicable would be if you want to attack a Blu-ray player (where) you have an environment where someone is giving you a device that has a private key to protect intellectual property and you have physical access to the device."

Servers, by contrast, would be much harder to attack because they are generally located in places that prevent people from manipulating their power supply. But that doesn't mean they're immune to such exploits. In events where a machine was overheating or otherwise experiencing power fluctuations, the vulnerability will cause servers to leak secret data that could be intercepted by attackers.

The scientists are also experimenting with the possibility of exploiting the bug using lasers or natural radiation sources, they said.

[![](https://pubads.g.doubleclick.net/gampad/ad?co=1&iu=/6978/reg_security/front&sz=300x50%7C300x100%7C300x250%7C300x251%7C300x252%7C300x600%7C300x601&tile=3&c=33Z5RpgtJudNbAEDmQc2xXFAAAAAU&t=ct%3Dns%26unitnum%3D3%26raptor%3Deagle%26pos%3Dmid%26test%3D0)](https://pubads.g.doubleclick.net/gampad/jump?co=1&iu=/6978/reg_security/front&sz=300x50%7C300x100%7C300x250%7C300x251%7C300x252%7C300x600%7C300x601&tile=3&c=33Z5RpgtJudNbAEDmQc2xXFAAAAAU&t=ct%3Dns%26unitnum%3D3%26raptor%3Deagle%26pos%3Dmid%26test%3D0)

The attack is enabled by what the researchers described as a "severe vulnerability" in the OpenSSL innards that carry out authentication based on the RSA public key encryption algorithm. It resides in the so-called fixed window exponentiation algorithm of the open-source crypto library, which is used when errors arise. By triggering a single-bit error in a multiplication operation, the scientists were able to force OpenSSL to divulge 4 bits of the secret key.

Once they gathered about 8,800 malformed messages from the targeted device, they fed the data into an 81-machine cluster of 2.4 GHz Pentium-4 systems running a custom-designed algorithm. They applied the technique to an embedded hardware device consisting of a Sparc processor running a Linux operating system and were able to extract its 1024-bit private key in 104 hours.

The researchers said it may be possible to apply the method to other crypto libraries, such as one offered by the Mozilla Foundation.

The other two scientists working on the project were Valeria Bertacco and Andrea Pellegrini. Their [paper (pdf)](http://www.eecs.umich.edu/~valeria/research/publications/DATE10RSA.pdf) will be presented next week in Dresden at the Design Automation and Test in Europe conference. ®

**Get our** [Tech Resources](https://whitepapers.theregister.com/)

![](/design_picker/d2e337b97204af4aa34dda04c4e5d56d954b216f/graphics/icons/social_share_icon.svg)
Share

#### More about

* [OpenSSL](/Tag/OpenSSL/)

More like these

×
### More about

* [OpenSSL](/Tag/OpenSSL/)

#### More about

![](/design_picker/d2e337b97204af4aa34dda04c4e5d56d954b216f/graphics/icons/social_share_icon.svg)
Share

[**62**
![comment bubble on white](/design_picker/f5daacc84b9722c1e31ba85f836c37e4ad993fc4/graphics/icons/bubble_comment_white.png)
COMMENTS](https://forums.theregister.com/forum/all/2010/03/04/severe_openssl_vulnerability/ "View comments on this article")

#### More about

* [OpenSSL](/Tag/OpenSSL/)

More like these

×
### More about

* [OpenSSL](/Tag/OpenSSL/)

#### TIP US OFF

[Send us news](https://www.theregister.com/Profile/contact/)

---

### Other stories you might like

[#### OpenSSL 1.1.1 reaches end of life for all but the well-heeled

$50k to breathe new life into its corpse. The rest of us must move on to OpenSSL 3.0
Security12 Sep 2023 | 3](/2023/09/12/openssl_111_end_of_life/?td=keepreading)

[#### Why AI builds best on private clouds

AI projects under pressure to show real value in the tightest of timeframes might be worth keeping on-premises
Sponsored Feature](/2024/10/29/why_ai_builds_best_on/?td=keepreading)

The Register ![icon](/design_picker/d518b499f8a6e2c65d4d8c49aca8299d54b03012/graphics/icon/vulture_white.png) Biting the hand that feeds IT

#### About Us

* [Contact us](https://www.theregister.com/Profile/contact/)
* [Advertise with us](https://www.theregister.com/AdvertiseWithUs/)
* [Who we are](https://www.theregister.com/Profile/about_the_register/)

#### Our Websites

* [The Next Platform](https://www.nextplatform.com/)
* [DevClass](https://devclass.com/)
* [Blocks and Files](https://blocksandfiles.com/)

#### Your Privacy

* [Cookies Policy](https://www.theregister.com/Profile/cookies/)
* [Privacy Policy](https://www.theregister.com/Profile/privacy/)
* [Ts & Cs](https://www.theregister.com/Profile/terms_and_conditions_of_use/)

[![Situation Publishing](/design_picker/d2e337b97204af4aa34dda04c4e5d56d954b216f/graphics/std/sitpublogo_2022.png)](https://situationpublishing.com/)

Copyright. All rights reserved © 1998–2025

![no-js](/Design/graphics/std/transparent_pixel.png)



=== Content from rdist.root.org_78f2012f_20250125_043302.html ===

[Skip to content](#content)

[rdist](https://rdist.root.org/)

Embedded security, cryptography, software protection

Menu

* [Introduction to rdist](https://rdist.root.org/about/)

# Attacking RSA exponentiation with fault injection

[March 8, 2010](https://rdist.root.org/2010/03/08/attacking-rsa-exponentiation-with-fault-injection/) ~ [Nate Lawson](https://rdist.root.org/author/rdist/)

A new paper, “Fault-Based Attack of RSA Authentication” ([pdf](http://www.eecs.umich.edu/~valeria/research/publications/DATE10RSA.pdf)) by Pellegrini et al, is making the [rounds](http://www.theregister.co.uk/2010/03/04/severe_openssl_vulnerability/). The general idea is that an attacker can disrupt an RSA private key operation to cause an invalid signature to be returned, then use that result to extract the private key. If you’re new to fault injection attacks on RSA, I previously wrote an [intro that should help](https://rdist.root.org/2008/03/10/advances-in-rsa-fault-attacks/).

The main concept to grasp is that public key crypto is brittle. In the case of RSA’s CRT operation, a single bit error in one multiplication result is enough to fully compromise your private key. We’ve [known this](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.24.7407) since 1997. The solution is simple: validate every signature with the public key before returning it to the caller.

The authors noticed something curious. OpenSSL does verify signatures it generates before returning them, but if it detects a problem, it does not just return an error. It then tries again using a different exponentiation process, and then returns that signature *without validating it*.

Think about this for a moment. What conditions could cause an RSA private key operation to compute an invalid answer? An innocent possibility is cosmic radiation, bad RAM, etc. In this case, all computations should be considered unreliable and any retried operation should be checked very carefully. The other and more likely possibility is that the system is under attack by someone with physical proximity. In this case, OpenSSL should generate a very obvious log message and the operation should not be retried. If it is, the result should be checked very carefully.

For whatever reason, the OpenSSL programmers decided to retry with fixed-window exponentiation and trust that since there were no published fault attacks for it, they didn’t have to validate its result. This is a foolhardy attitude — not something you want to see in your crypto library. There had been many other fault injection attacks against various components or implementation approaches for RSA, [including right-to-left exponentiation](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.108.989). There was no reason to consider left-to-right exponentiation invulnerable to this kind of attack.

Fixed-window exponentiation is a form of [sliding window exponentiation](http://en.wikipedia.org/wiki/Exponentiation_by_squaring#Sliding_Window_Method). This is just a table-based optimization, where a window (say, 3 bits wide) is moved across the exponent, computing the final result incrementally. While this may be resistant to some timing attacks (but not [cache timing or branch prediction attacks](https://rdist.root.org/2009/12/30/side-channel-attacks-on-cryptographic-software/)), there is nothing that would prevent fault injection attacks.

Indeed, it turns out to be vulnerable. The authors generate a few thousand signatures with single bit-flips in some window of the signature. Then they compare the faulty signatures to a correct signature over the same message. They compute the value for that portion of the private exponent since there are only 2w possibilities for that location if *w* is the window size in bits. This is repeated until enough of the private key is known.

The method they used to create the faulty signatures was a bit artificial. They built a SPARC system on an FPGA running Linux and OpenSSL. They then decreased the power supply voltage until multiplies started to fail. Since multiplication logic is a relatively long chain, it is often one of the first things to fail. However, a more interesting hardware result would be to attempt this kind of attack on an actual server because FPGAs work differently than ASICs. It might require careful targeting of the right power pins on the CPU. Since power pins are numerous in modern systems, this may be more effective than only modulating the system power supply.

This was a nice attack but nothing earth-shattering. The only thing I was floored by (yet again), was the willingness of crypto implementers to perform unsafe operations in the face of an almost certain attack. Shame on OpenSSL.

### Share this:

* [Facebook](https://rdist.root.org/2010/03/08/attacking-rsa-exponentiation-with-fault-injection/?share=facebook "Click to share on Facebook")
* [X](https://rdist.root.org/2010/03/08/attacking-rsa-exponentiation-with-fault-injection/?share=x "Click to share on X")
Like Loading...
### *Related*

Posted in [Crypto](https://rdist.root.org/category/security/crypto/), [Embedded](https://rdist.root.org/category/security/embedded/), [Hardware](https://rdist.root.org/category/hardware/), [Network](https://rdist.root.org/category/security/network/), [Protocols](https://rdist.root.org/category/protocols/), [Security](https://rdist.root.org/category/security/)

## Post navigation

[‹ PreviousNext Baysec: March 2 at Kate O’Briens](https://rdist.root.org/2010/02/22/next-baysec-march-2-at-kate-obriens/)[Next ›Why digital logic is different than analog](https://rdist.root.org/2010/03/12/why-digital-logic-is-different-than-analog/)

## 2 thoughts on “Attacking RSA exponentiation with fault injection”

1. ![](https://1.gravatar.com/avatar/7b34211350ff567970974e1e2b98d319a601969e74fd1a957bc889b8332d00eb?s=60&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G) **Dave** says:
   [March 14, 2010 at 7:58 pm](https://rdist.root.org/2010/03/08/attacking-rsa-exponentiation-with-fault-injection/#comment-5754)

   I agree that the method used in this attack was a bit artificial, but it’s also been used in a more realistic attack on a commercial ARM9 CPU (specifically the widely-used ARM926EJ-S) running Linux, see <http://eprint.iacr.org/2010/130> (although as with the FPGA-CPU attack, they also disabled blinding and signature-verification in their attack).

   1. ![](https://0.gravatar.com/avatar/615dd7260e92ea61430509f809c6326768ef5f259235ffcd89134847eddbce8d?s=60&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G) **[Nate Lawson](http://www.rootlabs.com/)** says:
      [March 15, 2010 at 7:16 pm](https://rdist.root.org/2010/03/08/attacking-rsa-exponentiation-with-fault-injection/#comment-5755)

      Yeah, that’s a slightly more realistic environment. It’s crazy how close these papers were in timing (pun intended).

Comments are closed.

Search for:

# Recent Posts

* [Rebooting](https://rdist.root.org/2022/11/17/rebooting/)
* [In Which You Get a Chance to Save Democracy](https://rdist.root.org/2017/12/06/in-which-you-get-a-chance-to-save-democracy/)
* [Was the past better than now?](https://rdist.root.org/2014/12/01/was-the-past-better-than-now/)
* [Thought experiment on protocols and noise](https://rdist.root.org/2014/11/04/thought-experiment-on-protocols-and-noise/)
* [Timing-safe memcmp and API parity](https://rdist.root.org/2014/06/24/timing-safe-memcmp-and-api-parity/)
* [In Defense of JavaScript Crypto](https://rdist.root.org/2014/06/23/in-defense-of-javascript-crypto/)
* [Catching up on recent crypto developments](https://rdist.root.org/2014/05/26/catching-up-on-recent-crypto-developments/)
# Archives

Archives
Select Month
 November 2022  (1)
 December 2017  (1)
 December 2014  (1)
 November 2014  (1)
 June 2014  (2)
 May 2014  (1)
 January 2014  (1)
 December 2013  (1)
 September 2013  (2)
 May 2013  (1)
 January 2013  (1)
 December 2012  (1)
 September 2012  (1)
 August 2012  (1)
 June 2012  (2)
 February 2012  (1)
 January 2012  (4)
 December 2011  (1)
 November 2011  (1)
 September 2011  (2)
 June 2011  (3)
 May 2011  (2)
 April 2011  (3)
 March 2011  (1)
 February 2011  (3)
 January 2011  (3)
 December 2010  (1)
 November 2010  (4)
 October 2010  (1)
 September 2010  (6)
 August 2010  (5)
 July 2010  (2)
 June 2010  (3)
 May 2010  (4)
 April 2010  (1)
 March 2010  (3)
 February 2010  (3)
 January 2010  (4)
 December 2009  (4)
 November 2009  (2)
 October 2009  (5)
 September 2009  (2)
 August 2009  (4)
 July 2009  (3)
 June 2009  (4)
 May 2009  (4)
 April 2009  (2)
 March 2009  (4)
 February 2009  (2)
 January 2009  (2)
 December 2008  (2)
 November 2008  (2)
 October 2008  (3)
 September 2008  (6)
 August 2008  (6)
 July 2008  (6)
 June 2008  (3)
 May 2008  (6)
 April 2008  (4)
 March 2008  (8)
 February 2008  (7)
 January 2008  (5)
 December 2007  (3)
 November 2007  (2)
 October 2007  (5)
 September 2007  (3)
 August 2007  (2)
 July 2007  (5)
 June 2007  (3)
 May 2007  (9)
 April 2007  (9)
 March 2007  (8)

# RSS

* [Register](https://wordpress.com/start?ref=wplogin)
* [Log in](https://rdist.wordpress.com/wp-login.php)
* [Entries feed](https://rdist.root.org/feed/)
* [Comments feed](https://rdist.root.org/comments/feed/)
* [WordPress.com](https://wordpress.com/ "Powered by WordPress, state-of-the-art semantic personal publishing platform.")
# Email delivery

* [Subscribe to rdist](http://www.feedburner.com/fb/a/emailverifySubmit?feedId=808515)

[Create a website or blog at WordPress.com](https://wordpress.com/?ref=footer_custom_svg "Create a website or blog at WordPress.com")

* Reblog
* Subscribe
  Subscribed

  + [![](https://rdist.root.org/wp-content/uploads/2022/11/cropped-root_labs_symbol.png?w=50) rdist](https://rdist.root.org)

  Join 119 other subscribers

  Sign me up

  + Already have a WordPress.com account? [Log in now.](https://wordpress.com/log-in?redirect_to=https%3A%2F%2Fr-login.wordpress.com%2Fremote-login.php%3Faction%3Dlink%26back%3Dhttps%253A%252F%252Frdist.root.org%252F2010%252F03%252F08%252Fattacking-rsa-exponentiation-with-fault-injection%252F)
* Privacy
* + [![](https://rdist.root.org/wp-content/uploads/2022/11/cropped-root_labs_symbol.png?w=50) rdist](https://rdist.root.org)
  + Subscribe
    Subscribed
  + [Sign up](https://wordpress.com/start/)
  + [Log in](https://wordpress.com/log-in?redirect_to=https%3A%2F%2Fr-login.wordpress.com%2Fremote-login.php%3Faction%3Dlink%26back%3Dhttps%253A%252F%252Frdist.root.org%252F2010%252F03%252F08%252Fattacking-rsa-exponentiation-with-fault-injection%252F)
  + [Copy shortlink](https://wp.me/p3KqR-8u)
  + [Report this content](https://wordpress.com/abuse/?report_url=https://rdist.root.org/2010/03/08/attacking-rsa-exponentiation-with-fault-injection/)
  + [View post in Reader](https://wordpress.com/read/blogs/893473/posts/526)
  + [Manage subscriptions](https://subscribe.wordpress.com/)
  + Collapse this bar

%d

![](https://pixel.wp.com/b.gif?v=noscript)


