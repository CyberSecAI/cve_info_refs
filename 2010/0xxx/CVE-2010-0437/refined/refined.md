```
Message-ID: <1144883865.3498301267744058110.JavaMail.root@zmail01.collab.prod.int.phx2.redhat.com>
Date: Thu, 4 Mar 2010 18:07:38 -0500 (EST)
From: Josh Bressers <bressers@...hat.com>
To: oss-security@...ts.openwall.com
Cc: "Steven M. Christey" <coley@...us.mitre.org>
Subject: Re: CVE request - kernel: ip6_dst_lookup_tail() NULL
 pointer dereference

----- "Eugene Teo" <eugene@...hat.com> wrote:

> ipv6: Fix OOPS in ip6_dst_lookup_tail().
>
> This fixes kernel bugzilla 11469: "TUN with 1024 neighbours:
> ip6_dst_lookup_tail NULL crash"
>
> dst->neighbour is not necessarily hooked up at this point in the
> processing path, so blindly dereferencing it is the wrong thing to do.
>
> This NULL check exists in other similar paths and this case was just
> an
> oversight.
>
> Also fix the completely wrong and confusing indentation here while
> we're
> at it.
>
> References:
> <http://bugzilla.kernel.org/show_bug.cgi?id=11469>
> <https://bugzilla.redhat.com/show_bug.cgi?id=563781>
>
> Upstream patch:
> <http://git.kernel.org/linus/e550dfb0c2c31b6363aa463a035fc9f8dcaa3c9b>
>

Please use CVE-2010-0437 for this.

Thanks.

--
    JB
```

```
Message-ID: <4B7390C1.7020609@redhat.com>
Date: Thu, 11 Feb 2010 13:08:17 +0800
From: Eugene Teo <eugene@...hat.com>
To: oss-security@...ts.openwall.com
CC: "Steven M. Christey" <coley@...us.mitre.org>
Subject: CVE request - kernel: ip6_dst_lookup_tail() NULL pointer dereference

ipv6: Fix OOPS in ip6_dst_lookup_tail().

This fixes kernel bugzilla 11469: "TUN with 1024 neighbours:
ip6_dst_lookup_tail NULL crash"

dst->neighbour is not necessarily hooked up at this point in the
processing path, so blindly dereferencing it is the wrong thing to do.
This NULL check exists in other similar paths and this case was just an
oversight.

Also fix the completely wrong and confusing indentation here while we're
at it.

References:
<http://bugzilla.kernel.org/show_bug.cgi?id=11469>
<https://bugzilla.redhat.com/show_bug.cgi?id=563781>

Upstream patch:
<http://git.kernel.org/linus/e550dfb0c2c31b6363aa463a035fc9f8dcaa3c9b>

Thanks, Eugene
--
Eugene Teo / Red Hat Security Response Team
```

```
## VMSA-2011-0003.2
...
CVE numbers:       --- COS Kernel ---
                   CVE-2010-1084 CVE-2010-2066 CVE-2010-2070
                   CVE-2010-2226 CVE-2010-2248 CVE-2010-2521
                   CVE-2010-2524 CVE-2010-0008 CVE-2010-0415
                   CVE-2010-0437 CVE-2009-4308 CVE-2010-0003
...
j. ESX third party update for Service Console kernel
...
    The Common Vulnerabilities and Exposures project (cve.mitre.org)
    has assigned the names CVE-2010-1084, CVE-2010-2066, CVE-2010-2070,
    CVE-2010-2226, CVE-2010-2248, CVE-2010-2521, CVE-2010-2524,
    CVE-2010-0008, CVE-2010-0415, CVE-2010-0437, CVE-2009-4308,
```

```
[**Bug 563781**](show_bug.cgi?id=563781)
(CVE-2010-0437)
- [CVE-2010-0437](https://access.redhat.com/security/cve/CVE-2010-0437) kernel: ipv6: fix ip6\_dst\_lookup\_tail() NULL pointer dereference

[Summary:](page.cgi?id=fields.html#short_desc "The bug summary is a short sentence which succinctly describes what the bug is about.")
CVE-2010-0437 kernel: ipv6: fix ip6\_dst\_lookup\_tail() NULL pointer dereference
...
[Description](show_bug.cgi?id=563781#c0)  Eugene Teo (Security Response)    2010-02-11 05:03:09 UTC  
```
```
 Description of problem: ipv6: Fix OOPS in ip6_dst_lookup_tail().

This fixes kernel bugzilla 11469: "TUN with 1024 neighbours: ip6_dst_lookup_tail NULL crash"

dst->neighbour is not necessarily hooked up at this point in the processing path, so blindly dereferencing it is the wrong thing to do.

This NULL check exists in other similar paths and this case was just an oversight.

Also fix the completely wrong and confusing indentation here while we're at it.

Based upon a patch by Evgeniy Polyakov.

References: <http://bugzilla.kernel.org/show_bug.cgi?id=11469>

Upstream patch: <http://git.kernel.org/linus/e550dfb0c2c31b6363aa463a035fc9f8dcaa3c9b>
```

```
Kernel.org Bugzilla – Bug 11469
TUN with 1024 neighbours: ip6\_dst\_lookup\_tail NULL crash
...
[Description](show_bug.cgi?id=11469#c0)  R    2008-08-31 09:44:35 UTC  
```
```
 Latest working kernel version: none known
Earliest failing kernel version: none tested
Distribution: Debian
Hardware Environment: Intel(R) Pentium(R) 4 CPU 2.80GHz, HyperThreaded
Software Environment: SMT kernel, Debian glibc 2.7
Problem Description:
When an IFF_TUN (/dev/net/tun) device has more than 1023 IPv6 neighbors, a process context crash occurs.
Backtrace follows:

BUG: unable to handle kernel NULL pointer dereference at 0000001d
IP: [<f8b375bf>] :ipv6:ip6_dst_lookup_tail+0x95/0x15a
*pde = 00000000
Oops: 0000 [#14] SMP
Modules linked in: ipx p8022 psnap llc p8023 i915 drm tun cpufreq_ondemand binfmt_misc fuse nf_conntrack_ftp nf_conntrack_ipv6 nf_conntrack_ipv4 nf_conntrack ipv6 snd_intel8x0 snd_ac97_codec ac97_bus snd_pcm_oss snd_mixer_oss snd_pcm snd_seq_oss snd_seq_midi snd_rawmidi snd_seq_midi_event snd_seq snd_timer snd_seq_device snd intel_agp psmouse soundcore agpgart button processor snd_page_alloc parport_pc parport iTCO_wdt evdev pcspkr dm_mirror dm_log dm_snapshot dm_mod sg sr_mod cdrom e100 mii ehci_hcd uhci_hcd usbcore unix
Pid: 9950, comm: tunload Tainted: G      D   (2.6.26.3 #8)
EIP: 0060:[<f8b375bf>] EFLAGS: 00210246 CPU: 0
EIP is at ip6_dst_lookup_tail+0x95/0x15a [ipv6]
EAX: 00000000 EBX: 00000000 ECX: ef4abdac EDX: 00000000
ESI: ef4abd3c EDI: ef64ca00 EBP: ef4abcb8 ESP: ef4abc64
DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068
Process tunload (pid: 9950, ti=ef4aa000 task=f7d45320 task.ti=ef4aa000)
Stack: ef4abd58 ef4abdac f7cc0c00 ef4abc80 f8b36918 00000000 ef673e40 ef4abcc0
       f8b381b2 00000002 f7cc0c00 ef7c3e00 f7cc0e24 00000000 ef4abca8 ef4abca8
       c030bcfa ef4abcc0 00000000 ef4abed4 00000000 ef4abcc0 f8b377d5 ef4abdbc
Call Trace:
 [<f8b36918>] ? ip6_cork_release+0x2e/0x52 [ipv6]
 [<f8b381b2>] ? ip6_push_pending_frames+0x1c9/0x3d9 [ipv6]
 [<c030bcfa>] ? _spin_unlock_bh+0xd/0xf
 [<f8b377d5>] ? ip6_dst_lookup+0xe/0x10 [ipv6]
 [<f8b4c2b2>] ? rawv6_sendmsg+0x25d/0xc08 [ipv6]
 [<c0151022>] ? filemap_fault+0x203/0x3d5
 [<c02e8de0>] ? inet_sendmsg+0x2e/0x50
 [<c02a24b8>] ? sock_sendmsg+0xcc/0xf0
 [<c01365f5>] ? autoremove_wake_function+0x0/0x3a
 [<c0136799>] ? remove_wait_queue+0x30/0x34
 [<f8a08fbe>] ? tun_chr_aio_read+0x298/0x31f [tun]
 [<c0211d67>] ? copy_from_user+0x2a/0x114
 [<c02a2790>] ? sys_sendto+0xa5/0xc5
 [<c02b3713>] ? neigh_periodic_timer+0x0/0x17a
 [<c01365f5>] ? autoremove_wake_function+0x0/0x3a
 [<c02a348f>] ? sys_socketcall+0x141/0x262
 [<c0102f99>] ? sysenter_past_esp+0x6a/0x91
=======================
Code: 22 83 fb 9b 74 37 8b 4d b0 8b 01 e8 35 96 77 c7 8b 45 b0 c7 00 00 00 00 00 89 d8 83 c4 48 5b 5e 5f 5d c3 8b 4d b0 8b 39 8b 47 2c <f6> 40 1d de 74 23 31 db 89 d8 83 c4 48 5b 5e 5f 5d c3 64 a1 04
EIP: [<f8b375bf>] ip6_dst_lookup_tail+0x95/0x15a [ipv6] SS:ESP 0068:ef4abc64
---[ end trace 1035c8e1d028e84b ]---
Steps to reproduce:

Test case available at: <http://www.remlab.net/files/divers/tunload.c>
```

Based on the provided information, here's a breakdown of the vulnerability:

**Root Cause:**
The vulnerability lies in the `ip6_dst_lookup_tail()` function within the Linux kernel's IPv6 networking stack. Specifically, the code attempts to dereference the `dst->neighbour` pointer without first ensuring that the pointer is not NULL. This dereference occurs in the context of Optimistic Duplicate Address Detection (DAD) when a destination entry is looked up and the source address is marked as OPTIMISTIC.

**Weaknesses/Vulnerabilities Present:**
*   **NULL Pointer Dereference:** The core vulnerability is a classic NULL pointer dereference. The `dst->neighbour` pointer can be NULL under specific conditions, particularly when a TUN device has a large number of IPv6 neighbors or when the neighbor entry is not yet fully established.
*  **Missing NULL Check:** The code lacks a necessary check to verify that `dst->neighbour` is not NULL before attempting to access its members via `->nud_state`.

**Impact of Exploitation:**
*   **Kernel Panic/Crash:** Dereferencing a NULL pointer results in a kernel panic, leading to a denial-of-service (DoS) condition. The system will crash, disrupting all services.
* **Process Context Crash:** The crash occurs in process context.

**Attack Vectors:**
*   **Triggering the Vulnerable Code Path:** The primary attack vector involves creating a network configuration that triggers the vulnerable code path in `ip6_dst_lookup_tail()`. This can be achieved by:
    *   Using an IFF\_TUN device with more than 1023 IPv6 neighbors.
    *   Sending IPv6 packets where a route lookup results in a destination without a corresponding neighbour entry.

**Required Attacker Capabilities/Position:**
*   **Ability to create network interfaces:** The attacker needs the ability to create and configure network interfaces, specifically IFF\_TUN interfaces. This usually requires root privileges or the ability to create network namespaces.
*   **Network traffic generation:** The attacker needs to be able to send network traffic to trigger the specific code path in the kernel, requiring the ability to craft IPv6 packets.

**Additional Notes:**
*   The vulnerability exists in the `ip6_dst_lookup_tail` function, specifically within the optimistic DAD code block.
*   A patch was developed that introduces a null check before accessing the neighbour member. The patch also corrected indentation issues within the code block.
*   The issue is related to how the Linux kernel handles neighbor discovery and route lookups for IPv6, particularly in scenarios involving TUN devices or incomplete neighbor entries.
*   The vulnerability can lead to a system crash if exploited.

This information provides a clear picture of the vulnerability, its root cause, and how it can be exploited. The fix was a simple NULL check combined with style correction in the kernel code.