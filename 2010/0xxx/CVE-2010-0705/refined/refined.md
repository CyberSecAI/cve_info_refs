```
{
  "CVE-2010-0705": {
    "related": true,
    "information": [
      {
        "type": "vulnerability_details",
        "content": "The kernel driver aavmker4.sys shipped with avast! 4.8 and 5.0 contains a vulnerability in the code that handles IOCTL requests. Exploitation of this vulnerability can result in:\n1) local denial of service attacks (system crash due to a kernel panic), or\n2) local execution of arbitrary code at the kernel level (complete system compromise)\nThe issue can be triggered by sending a specially crafted IOCTL request.\nNo special user rights are required to exploit the vulnerability."
      },
      {
        "type": "technical_details",
        "content": "The IOCTL call 0xb2d60030 of the aavmker4.sys kernel driver shipped with avast! 4.8 and 5.0 accepts user supplied input that doesn't get validated enough. In consequence it is possible to overwrite arbitrary kernel space and user space memory addresses with arbitrary values. This can be exploited to control the kernel execution flow and to execute arbitrary code at the kernel level.\n\nDisassembly of aavmker4.sys (avast! 4.8, file version 4.8.1356.0):\n[..]\n.text:00010E46 [1] cmp eax, 0B2D60030h ; vulnerable IOCTL\n.text:00010E4B jz loc\_10EEF\n[..]\n.text:00010EEF loc\_10EEF:\n.text:00010EEF cmp byte\_1262C, 0\n.text:00010EF6 jz short loc\_10F0C\n[..]\n.text:00010F0C loc\_10F0C:\n.text:00010F0C [2] mov edi, [ebx+0Ch]\n.text:00010F0F [3] cmp esi, 878h ; InputBufferSize == 0x878?\n.text:00010F15 jz short loc\_10F21\n[..]\n[1] Vulnerable IOCTL\n[2] EDI now points to user controlled IOCTL input data\n[3] The size of the IOCTL input data must be equal to 0x878\n[..]\n.text:00010F21 loc\_10F21:\n.text:00010F21 and [ebp+var\_4], 0\n.text:00010F25 cmp dword ptr [edi], 0\n.text:00010F28 jz loc\_10FC5\n.text:00010F2E [4] mov esi, [edi+870h]\n.text:00010F34 mov [ebp+v34\_uc], esi\n.text:00010F37 mov eax, ds:MmUserProbeAddress\n.text:00010F3C [5] cmp esi, [eax] ; user space or kernel space?\n.text:00010F3E jnb short loc\_10F46\n[..]\n[4] If the input size equals 0x878 a pointer value gets extracted from the user supplied IOCTL input data and saved in ESI\n[5] It is checked if ESI points into user space or kernel space\n[..]\n.text:00010F46 loc\_10F46:\n.text:00010F46 push esi ; VirtualAddress\n.text:00010F47 [6] call ds:MmIsAddressValid\n.text:00010F4D test al, al\n.text:00010F4F jz short loc\_10F5F\n.text:00010F51 lea eax, [esi+8]\n.text:00010F54 push eax ; VirtualAddress\n.text:00010F55 [7] call ds:MmIsAddressValid\n.text:00010F5B test al, al\n.text:00010F5D jnz short loc\_10F65\n[..]\n[6] + [7] If ESI points to an address in kernel space it is checked if ESI and ESI+8 are pointing to valid memory addresses\n[..]\n.text:00010F65 loc\_10F65:\n.text:00010F65 [8] mov eax, [esi]\n.text:00010F67 mov [ebp+v32\_uc], eax\n.text:00010F6A [9] mov esi, [esi+4]\n.text:00010F6D mov [ebp+var\_4C], esi\n.text:00010F70 [10] xor [ebp+v32\_uc], 55667788h\n.text:00010F77 [11] xor esi, 11223344h\n.text:00010F7D mov [ebp+var\_4C], esi\n.text:00010F80 mov eax, dword\_125E8\n.text:00010F85 [12] cmp eax, [ebp+v32\_uc] ; check pattern1\n.text:00010F88 jnz short loc\_10F93\n.text:00010F8A mov eax, dword\_125EC\n.text:00010F8F [13] cmp eax, esi ; check pattern2\n.text:00010F91 jz short loc\_10F99\n[..]\n[8] + [9] If the addresses are valid, EAX and ESI are filled with data from the user defined kernel space address (pointed to by ESI)\nThe first value (EAX) is xor'ed with 0x55667788 (see [10]) and then compared with the value 0x85B8DA8F found at dword\_125E8 (see [12]).\n.data:000125E8 dword\_125E8 dd 85B8DA8Fh\nThe second value (ESI) is xor'ed with 0x11223344 (see [11]) and then compared with the value 0x198E3FE found at dword\_125EC (see [13]).\n.data:000125EC dword\_125EC dd 198E3FEh\nIf both patterns match, the following code gets executed:\n[..]\n.text:00010F99 loc\_10F99:\n.text:00010F99 xor edx, edx\n.text:00010F9B mov eax, [ebp+v34\_uc]\n.text:00010F9E mov [eax], edx\n.text:00010FA0 mov [eax+4], edx\n.text:00010FA3 lea esi, [edi+4] ; src\n.text:00010FA6 mov ecx, 21Ah ; len\n.text:00010FAB mov edi, [eax+18h] ; dst\n.text:00010FAE [14] rep movsd ; memcpy\n[..]\nThe memcpy function at [14] gets called with the following parameters:\nmemcpy (EDI, ESI, ECX);\nEDI (dst): this value is extracted from a user defined kernel space address\nESI (src): points to user controlled IOCTL input data\nECX (len): 0x21A"
      },
      {
        "type": "vulnerability",
        "content": "If an attacker were able to (temporarily) store user controlled data at a user defined address in kernel space, the check at [5] could be passed and the memcpy() call would lead to an exploitable memory corruption condition.\nUnfortunately, the aavmker4.sys driver supports at least one IOCTL that allows an unprivileged user to temporarily store arbitrary data at a known kernel space address."
      },
      {
        "type": "exploitation",
        "content": "STEP 1: Use one of the IOCTLs supported by aavmker4.sys to temporarily store arbitrary data at a known kernel space address (e.g. the IOCTL 0xb2d6001c). This data has to start with the two patterns that are checked at [12] and [13].\nSTEP 2: Send a request to the vulnerable IOCTL. Store a pointer at offset 0x870 of the IOCTL data that points to the kernel space address of STEP 1."
      },
       {
        "type": "affected_software",
        "content": "avast! 4.8 <= 4.8.1368.0\navast! 5.0 < 5.0.418.0"
      },
        {
        "type": "solution",
         "content": "Update to avast! 5.0 >= 5.0.418."
      },
        {
        "type": "attack_vector",
        "content": "Local"
      },
        {
        "type": "required_capabilities",
         "content": "No special user rights are required to exploit the vulnerability."
       },
        {
        "type": "impact",
        "content": "local denial of service attacks (system crash due to a kernel panic), or local execution of arbitrary code at the kernel level (complete system compromise)"
      }
    ]
  }
}
```