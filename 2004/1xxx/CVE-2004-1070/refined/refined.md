```
{
  "CVE-2004-1070": {
    "description": "Insufficient input sanitising in the load_elf_binary() function may lead to privilege escalation.",
    "additional_details": [
      {
        "type": "debian.org_8163fb55",
        "data": "Insufficient input sanitising in the load_elf_binary() function may lead to privilege escalation."
      },
      {
        "type": "debian.org_263a3738",
         "data": "Insufficient input sanitising in the load_elf_binary() function may lead to privilege escalation."
      },
      {
        "type":"debian.org_d7d88598",
        "data":"Insufficient input sanitising in the load_elf_binary() function may lead to privilege escalation."
      },
      {
        "type": "debian.org_fa5653c3",
        "data":"Insufficient input sanitising in the load_elf_binary() function may lead to privilege escalation."
      },
      {
        "type": "isec.pl_d9388b7e",
         "data": "Numerous bugs have been found in the Linux ELF binary loader while handling setuid binaries.\n\n1) wrong return value check while filling kernel buffers (loop to scan the binary header for an interpreter section):\n\nstatic int load_elf_binary(struct linux_binprm * bprm, struct pt_regs * regs)\n{\nsize = elf_ex.e_phnum * sizeof(struct elf_phdr);\nelf_phdata = (struct elf_phdr *) kmalloc(size, GFP_KERNEL);\nif (!elf_phdata)\ngoto out;\n477: retval = kernel_read(bprm->file, elf_ex.e_phoff, (char *) elf_phdata, size);\nif (retval < 0)\ngoto out_free_ph;\nThe above code looks good on the first glance, however checking the return value of kernel_read (which calls file->f_op->read) to be non-negative is not sufficient since a read() can perfectly return less than the requested buffer size bytes. This bug happens also on lines 301, 523, 545 respectively.\n\n2) incorrect on error behaviour, if the mmap() call fails (loop to mmap binary sections into memory):\n645: for(i = 0, elf_ppnt = elf_phdata; i < elf_ex.e_phnum; i++, elf_ppnt++) {\n684: error = elf_map(bprm->file, load_bias + vaddr, elf_ppnt, elf_prot, elf_flags);\nif (BAD_ADDR(error))\ncontinue;\n\n3) bad return value vulnerability while mapping the program interpreter into memory:\n301: retval = kernel_read(interpreter,interp_elf_ex->e_phoff,(char *)elf_phdata,size);\nerror = retval;\nif (retval < 0)\ngoto out_close;\neppnt = elf_phdata;\nfor (i=0; ie_phnum; i++, eppnt++) {\nmap_addr = elf_map(interpreter, load_addr + vaddr, eppnt, elf_prot, elf_type);\n322: if (BAD_ADDR(map_addr))\ngoto out_close;\nout_close:\nkfree(elf_phdata);\nout:\nreturn error;\n}\n4) the loaded interpreter section can contain an interpreter name string without the terminating NULL:\n508: for (i = 0; i < elf_ex.e_phnum; i++) {\n518: elf_interpreter = (char *) kmalloc(elf_ppnt->p_filesz, GFP_KERNEL);\nif (!elf_interpreter)\ngoto out_free_file;\nretval = kernel_read(bprm->file, elf_ppnt->p_offset, elf_interpreter, elf_ppnt->p_filesz);\nif (retval < 0)\ngoto out_free_interp;\n\n5) bug in the common execve() code in exec.c: vulnerability in open_exec() permitting reading of non-readable ELF binaries, which can be triggered by requesting the file in the ELF PT_INTERP section:\n541: interpreter = open_exec(elf_interpreter);\nretval = PTR_ERR(interpreter);\nif (IS_ERR(interpreter))\ngoto out_free_interp;\nretval = kernel_read(interpreter, 0, bprm->buf, BINPRM_BUF_SIZE);"
      }
    ],
    "root_cause": "Insufficient input sanitizing in the `load_elf_binary()` function.",
    "vulnerabilities": [
        "Improper input sanitization.",
         "Incorrect return value check.",
         "Incorrect error handling.",
         "Missing null termination."
    ],
    "impact": "Privilege escalation.",
    "attack_vectors": [
      "Crafted ELF binaries with malformed headers.",
       "Setuid binaries."
    ],
    "required_capabilities": "Local user."
  }
}
```