=== Content from libreswan.org_789539dc_20250126_073759.html ===

# Index of /security/CVE-2013-2052/

---

```
<../>
<7d0ca355.patch>                                     13-May-2013 22:31               12476
<CVE-2013-2052.txt>                                  10-Dec-2013 23:08                5640

```

---



=== Content from libreswan.org_752bb2cc_20250125_084718.html ===
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
Release date: Mon May 13, 2013
Subject: CVE-2013-2052 Libreswan remote buffer overflow in atodn()
URL: http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2013-2052
This alert (and any possible updates) is available at the following URLs:
https://libreswan.org/security/CVE-2013-2052/
See also: Openswan atodn() CVE-2013-2053, Strongswan atodn() CVE-2013-2054
An audit of code from The Libreswan Project revealed a remote buffer overflow
in the atodn() function used by both libreswan, openswan, and older versions
of strongswan and superfreeswan when called from atoid()
Vulnerable versions: libreswan 3.0 and 3.1
Not vulnerable : libreswan 3.2 and 3.3
Vulnerability information
- -------------------------
When enabling Opportunistic Encryption ("OE") using oe=yes (default is
'no') the IKE daemon pluto requests DNS TXT records to obtain public
RSA keys of itself and its peers. These records can contain an IPsec
gateway specification containing an fully qualified hostname which is
passed to a function atoid().
When X.509 support was added to FreeS/WAN, ASN.1 parsing was added to
the function atoid() which converts an ASCII ID representation into an
internal struct id representation using a static buffer via the function
temporary\_cyclic\_buffer()
While DNS TXT records cannot contain ASN.1 representations, the code
mistakenly checked for such interpretation if the DNS TXT FQDN contained
an '=' symbol. Since DNS TXT buffers can be larger than what the ASN.1
parsing code expected, parsing such a record can trigger a buffer overflow
leading to remote execution of code, specifically when overflowing into
the struct kernel\_ops which is a table of function pointers.
Exploitation
- ------------
This exploit can only be triggered when the ipsec.conf configuration
file enables Opportunistic Encryption via the option 'oe=yes'. If this
option is not present, it defaults to 'no'.
Configurations that enable "OE" without preconfiguring their own public
RSA key in DNS will be under severe connectivity problems leaving the
machine with 30 second delay for each outgoing connection - a deployment
scenario that is extremely unlikely to appear in the wild.
In the unlikely event that machines are configured as such, this
vulnerability can only be exploited by a local attacker controlling
the reverse DNS entry for the IP address of the targetted host. If the
machine is properly configured for OE, an attacker only needs to trigger
a connection to an IP address for which they control the reverse DNS
zone where they can place the malicious DNS record.
Workaround
- ----------
If you cannot upgrade to libreswan version 3.2 or 3.3, the following patch
addresses the vulnerability:
https://libreswan.org/security/CVE-2013-2052/7d0ca355.patch
Alternatively, the following patch can be used to permanently disable the
oe=yes option:
diff --git a/lib/libipsecconf/keywords.c b/lib/libipsecconf/keywords.c
index b69d5e1..d7ca5a5 100644
- --- a/lib/libipsecconf/keywords.c
+++ b/lib/libipsecconf/keywords.c
@@ -381,7 +381,7 @@ struct keyword\_def ipsec\_conf\_keywords\_v2[]={
{"plutofork", kv\_config, kt\_bool, KBF\_PLUTOFORK,NOT\_ENUM},
{"perpeerlog", kv\_config, kt\_bool, KBF\_PERPEERLOG,NOT\_ENUM},
{"perpeerlogdir", kv\_config, kt\_dirname, KSF\_PERPEERDIR,NOT\_ENUM},
- - {"oe", kv\_config, kt\_bool, KBF\_OPPOENCRYPT,NOT\_ENUM},
+ {"oe", kv\_config, kt\_obsolete, KBF\_WARNIGNORE,NOT\_ENUM},
{"fragicmp", kv\_config, kt\_bool, KBF\_FRAGICMP,NOT\_ENUM},
{"hidetos", kv\_config, kt\_bool, KBF\_HIDETOS,NOT\_ENUM},
{"uniqueids", kv\_config, kt\_bool, KBF\_UNIQUEIDS,NOT\_ENUM},
Related
- -------
These functions are also used in other freeswan derivatives - openswan 1.x to 2.6.38,
strongswan 1.x to 4.3.4 and superfreeswan.
For full information regarding openswan, see CVE-2013-2053
For full information regarding strongswan, see CVE-2013-2054
Credits
- -------
This vulnerability was found by Florian Weimer of the Red Hat Product
Security Team (https://access.redhat.com/security/team/)
About libreswan (https://libreswan.org/)
- ----------------------------------------
Libreswan is a free implementation of the Internet Protocol Security
(IPsec) suite and Internet Key Exchange (IKE) protocols. It is a
descendant (fork) of openswan 2.6.38.
IPsec uses strong cryptography to provide both authentication and
encryption services. These services allow you to build secure tunnels
through untrusted networks. Everything passing through the untrusted
network is encrypted by the IPsec gateway machine, and decrypted by
the gateway at the other end of the tunnel. The resulting tunnel is a
virtual private network (VPN).
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.13 (GNU/Linux)
iQIcBAEBCAAGBQJRkWg1AAoJEIX/S0OzD8b5vHsP/1iUfVRVa1MolK7LzOYeBLH1
9Pt43kgu8aemov8S50bTC7KheGkVh7d4bdEfzsARz2aA/E2G8nlZNJlH4CbBlv/f
AfQ+Aa8RIbhOGYzuXaHaOyR/c7QgEry9XFRExd0FU+R0i2O4zINempu5BpBaSZZo
8lo/Y4SBEszJduZ1mYGeU60ilUu/9NTIzJLIqaXz81feYIkL6Q/YwBPvNYbnwe/S
k/7Yof5Xsjb/vt0HOWWUNIHx0oTSuo9CG/hNed38v/0ea1IruPdXQkK/Dw3uewjl
pLXPNqYCwbp/mYDrFBe5IC4+/GJaRK4u6oippes24EYujZfEm7DPP/F2mxnzSNM4
hTJE/Y2B16Ltwe28odFT30Dfgf36sbD0WwiDrSkRZXweZEs9H3nx4nmp2AWT4aWe
540Q9iy60hylUjSbScXszhAae8qRaoaXKY8Hzfmk/d1W6Xf0k9fedr6/HoFmQgGl
DFARY1uAMwy75XkGMsGv+mCqMs7N8p/yfSco1fqD4xEXWDIcQViF7dNBDQXk4cBJ
n7dp7FZ66rk20ae148/V9EusyH8htlf4R5Ku36tY+rqa7bmsR+0lRozYCbt3urbn
aCouUy0+Y93/oc+a1DoLXwgdjam44fvHYCJO5JxBTINg7MwN1CKm7KM2TOf+Ylkv
uvwqEHY+Lrr4F1aSmCFv
=usGY
-----END PGP SIGNATURE-----


=== Content from libreswan.org_12c059e2_20250126_073759.html ===
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
commit 7d0ca355a5c7f8337130d4b0b3e7686f2fa4d4c2
Author: Paul Wouters
Date: Thu Apr 25 12:44:55 2013 -0400
\* security: atodn() / atoid() buffer overflow
lib/libswan/x509dn.c:atodn() does not perform any length checking
whatsoever on the output buffer.
Affected:
- Libreswan 3.0 and 3.1 (3.2 disabled the oe= option)
- Openswan versions up to and including 2.6.38
- Possibly certain strongswan 3.x/4.x versions
This overflow is exposed (pre-authentication) only in opportunistic
encryption mode. When it is called via receiving a certificate
via IKEv1 or IKEv2, and when it is loaded from disk, the buffers
passed to atodn() are big enough.
This means this vulnerability can only be triggered when:
- Opportunistic Encryption is enabled (oe=yes)
- The attacker is local in the same network and adds a malicious
reverse DNS record to the client's IP, or
- The attacker can trigger an OE DNS lookup to a client fully
configured with OE and their own key.
Libreswan and openswan versions do not enable Opportunistic Encryption
per default. Most distributions like RHEL, Fedora, Debian and Ubuntu
also do not enable OE per default.
This patch addresses the vulnerability in atodn() and further limits the
atoid() call not to traverse into the ASN1 case when triggered by non-cert
cases such as opportunistic encryption.
Vulnerability discoverd by Florian Weimer  of the
Red Hat Product Security Team.
Patch by D. Hugh Redelmeier  and Paul Wouters
diff --git a/include/asn1.h b/include/asn1.h
index d69ebf9..b812488 100644
- --- a/include/asn1.h
+++ b/include/asn1.h
@@ -84,8 +84,10 @@ typedef enum {
#define ASN1\_BODY 0x20
#define ASN1\_RAW 0x40
- -#define ASN1\_INVALID\_LENGTH 0xffffffff
+#define ASN1\_INVALID\_LENGTH (~(size\_t) 0) /\* largest size\_t \*/
+#define ASN1\_MAX\_LEN (1U << (8\*3)) /\* don't handle objects with length greater than this \*/
+#define ASN1\_MAX\_LEN\_LEN 4 /\* no coded length takes more than 4 bytes. \*/
/\* definition of an ASN.1 object \*/
diff --git a/include/id.h b/include/id.h
index d1825b4..b440a11 100644
- --- a/include/id.h
+++ b/include/id.h
@@ -47,7 +47,7 @@ extern const struct id \*resolve\_myid(const struct id \*id);
extern void set\_myFQDN(void);
extern void free\_myFQDN(void);
- -extern err\_t atoid(char \*src, struct id \*id, bool myid\_ok);
+extern err\_t atoid(char \*src, struct id \*id, bool myid\_ok, bool oe\_only);
extern void iptoid(const ip\_address \*ip, struct id \*id);
extern unsigned char\* temporary\_cyclic\_buffer(void);
extern int idtoa(const struct id \*id, char \*dst, size\_t dstlen);
diff --git a/lib/libswan/id.c b/lib/libswan/id.c
index 4442971..31ca7e5 100644
- --- a/lib/libswan/id.c
+++ b/lib/libswan/id.c
@@ -58,27 +58,29 @@ temporary\_cyclic\_buffer(void)
/\* Convert textual form of id into a (temporary) struct id.
\* Note that if the id is to be kept, unshare\_id\_content will be necessary.
+ \* This function should be split into parts so the boolean arguments can be
+ \* removed -- Paul
\*/
err\_t
- -atoid(char \*src, struct id \*id, bool myid\_ok)
+atoid(char \*src, struct id \*id, bool myid\_ok, bool oe\_only)
{
err\_t ugh = NULL;
\*id = empty\_id;
- - if (myid\_ok && streq("%myid", src))
+ if (!oe\_only && myid\_ok && streq("%myid", src))
{
id->kind = ID\_MYID;
}
- - else if (streq("%fromcert", src))
+ else if (!oe\_only && streq("%fromcert", src))
{
id->kind = ID\_FROMCERT;
}
- - else if (streq("%none", src))
+ else if (!oe\_only && streq("%none", src))
{
id->kind = ID\_NONE;
}
- - else if (strchr(src, '=') != NULL)
+ else if (!oe\_only && strchr(src, '=') != NULL)
{
/\* we interpret this as an ASCII X.501 ID\_DER\_ASN1\_DN \*/
id->kind = ID\_DER\_ASN1\_DN;
@@ -112,7 +114,7 @@ atoid(char \*src, struct id \*id, bool myid\_ok)
{
if (\*src == '@')
{
- - if (\*(src+1) == '#')
+ if (!oe\_only && \*(src+1) == '#')
{
/\* if there is a second specifier (#) on the line
\* we interprete this as ID\_KEY\_ID
@@ -123,7 +125,7 @@ atoid(char \*src, struct id \*id, bool myid\_ok)
ugh = ttodata(src+2, 0, 16, (char \*)id->name.ptr
, strlen(src), &id->name.len);
}
- - else if (\*(src+1) == '~')
+ else if (!oe\_only && \*(src+1) == '~')
{
/\* if there is a second specifier (~) on the line
\* we interprete this as a binary ID\_DER\_ASN1\_DN
@@ -134,7 +136,7 @@ atoid(char \*src, struct id \*id, bool myid\_ok)
ugh = ttodata(src+2, 0, 16, (char \*)id->name.ptr
, strlen(src), &id->name.len);
}
- - else if (\*(src+1) == '[')
+ else if (!oe\_only && \*(src+1) == '[')
{
/\* if there is a second specifier ([) on the line
\* we interprete this as a text ID\_KEY\_ID, and we remove
diff --git a/lib/libswan/secrets.c b/lib/libswan/secrets.c
index 6e9466b..8ff80e0 100644
- --- a/lib/libswan/secrets.c
+++ b/lib/libswan/secrets.c
@@ -1223,7 +1223,7 @@ lsw\_process\_secret\_records(struct secret \*\*psecrets, int verbose,
}
else
{
- - ugh = atoid(flp->tok, &id, FALSE);
+ ugh = atoid(flp->tok, &id, FALSE, FALSE);
}
if (ugh != NULL)
diff --git a/lib/libswan/x509dn.c b/lib/libswan/x509dn.c
index 61407e5..7731856 100644
- --- a/lib/libswan/x509dn.c
+++ b/lib/libswan/x509dn.c
@@ -472,7 +472,7 @@ static const x501rdn\_t x501rdns[] = {
{"TCGID" , {oid\_TCGID, 12}, ASN1\_PRINTABLESTRING}
};
- -#define X501\_RDN\_ROOF 24
+#define X501\_RDN\_ROOF elemsof(x501rdns)
/\* Maximum length of ASN.1 distinquished name \*/
#define ASN1\_BUF\_LEN 512
@@ -775,11 +775,11 @@ atodn(char \*src, chunk\_t \*dn)
UNKNOWN\_OID = 4
} state\_t;
- - u\_char oid\_len\_buf[3];
- - u\_char name\_len\_buf[3];
- - u\_char rdn\_seq\_len\_buf[3];
- - u\_char rdn\_set\_len\_buf[3];
- - u\_char dn\_seq\_len\_buf[3];
+ u\_char oid\_len\_buf[ASN1\_MAX\_LEN\_LEN];
+ u\_char name\_len\_buf[ASN1\_MAX\_LEN\_LEN];
+ u\_char rdn\_seq\_len\_buf[ASN1\_MAX\_LEN\_LEN];
+ u\_char rdn\_set\_len\_buf[ASN1\_MAX\_LEN\_LEN];
+ u\_char dn\_seq\_len\_buf[ASN1\_MAX\_LEN\_LEN];
chunk\_t asn1\_oid\_len = { oid\_len\_buf, 0 };
chunk\_t asn1\_name\_len = { name\_len\_buf, 0 };
@@ -797,7 +797,7 @@ atodn(char \*src, chunk\_t \*dn)
err\_t ugh = NULL;
- - u\_char \*dn\_ptr = dn->ptr + 4;
+ u\_char \*dn\_ptr = dn->ptr + 1 + ASN1\_MAX\_LEN\_LEN; /\* leave room for prefix \*/
state\_t state = SEARCH\_OID;
@@ -885,25 +885,37 @@ atodn(char \*src, chunk\_t \*dn)
code\_asn1\_length(rdn\_set\_len, &asn1\_rdn\_set\_len);
/\* encode the relative distinguished name \*/
- - \*dn\_ptr++ = ASN1\_SET;
- - chunkcpy(dn\_ptr, asn1\_rdn\_set\_len);
- - \*dn\_ptr++ = ASN1\_SEQUENCE;
- - chunkcpy(dn\_ptr, asn1\_rdn\_seq\_len);
- - \*dn\_ptr++ = ASN1\_OID;
- - chunkcpy(dn\_ptr, asn1\_oid\_len);
- - chunkcpy(dn\_ptr, x501rdns[pos].oid);
- - /\* encode the ASN.1 character string type of the name \*/
- - \*dn\_ptr++ = (x501rdns[pos].type == ASN1\_PRINTABLESTRING
- - && !is\_printablestring(name))? ASN1\_T61STRING : x501rdns[pos].type;
- - chunkcpy(dn\_ptr, asn1\_name\_len);
- - chunkcpy(dn\_ptr, name);
- -
- - /\* accumulate the length of the distinguished name sequence \*/
- - dn\_seq\_len += 1 + asn1\_rdn\_set\_len.len + rdn\_set\_len;
- -
- - /\* reset name and change state \*/
- - name = empty\_chunk;
- - state = SEARCH\_OID;
+ if (IDTOA\_BUF < dn\_ptr - dn->ptr
+ + 1 + asn1\_rdn\_set\_len.len /\* set \*/
+ + 1 + asn1\_rdn\_seq\_len.len /\* sequence \*/
+ + 1 + asn1\_oid\_len.len + x501rdns[pos].oid.len /\* oid len, oid \*/
+ + 1 + asn1\_name\_len.len + name.len /\* type name \*/
+ ) {
+ /\* no room! \*/
+ ugh = "DN is too big";
+ state = UNKNOWN\_OID;
+ /\* I think that it is safe to continue (but perhaps pointless) \*/
+ } else {
+ \*dn\_ptr++ = ASN1\_SET;
+ chunkcpy(dn\_ptr, asn1\_rdn\_set\_len);
+ \*dn\_ptr++ = ASN1\_SEQUENCE;
+ chunkcpy(dn\_ptr, asn1\_rdn\_seq\_len);
+ \*dn\_ptr++ = ASN1\_OID;
+ chunkcpy(dn\_ptr, asn1\_oid\_len);
+ chunkcpy(dn\_ptr, x501rdns[pos].oid);
+ /\* encode the ASN.1 character string type of the name \*/
+ \*dn\_ptr++ = (x501rdns[pos].type == ASN1\_PRINTABLESTRING
+ && !is\_printablestring(name))? ASN1\_T61STRING : x501rdns[pos].type;
+ chunkcpy(dn\_ptr, asn1\_name\_len);
+ chunkcpy(dn\_ptr, name);
+
+ /\* accumulate the length of the distinguished name sequence \*/
+ dn\_seq\_len += 1 + asn1\_rdn\_set\_len.len + rdn\_set\_len;
+
+ /\* reset name and change state \*/
+ name = empty\_chunk;
+ state = SEARCH\_OID;
+ }
}
break;
case UNKNOWN\_OID:
@@ -911,9 +923,9 @@ atodn(char \*src, chunk\_t \*dn)
}
} while (\*src++ != '\0');
- - /\* complete the distinguished name sequence\*/
- - code\_asn1\_length(dn\_seq\_len, &asn1\_dn\_seq\_len);
- - dn->ptr += 3 - asn1\_dn\_seq\_len.len;
+ /\* complete the distinguished name sequence: prefix it with ASN1\_SEQUENCE and length \*/
+ code\_asn1\_length((size\_t)dn\_seq\_len, &asn1\_dn\_seq\_len);
+ dn->ptr += ASN1\_MAX\_LEN\_LEN + 1 - 1 - asn1\_dn\_seq\_len.len;
dn->len = 1 + asn1\_dn\_seq\_len.len + dn\_seq\_len;
dn\_ptr = dn->ptr;
\*dn\_ptr++ = ASN1\_SEQUENCE;
diff --git a/programs/pluto/connections.c b/programs/pluto/connections.c
index e8d326b..f08521b 100644
- --- a/programs/pluto/connections.c
+++ b/programs/pluto/connections.c
@@ -911,7 +911,7 @@ extract\_end(struct end \*dst, const struct whack\_end \*src, const char \*which)
}
else
{
- - err\_t ugh = atoid(src->id, &dst->id, TRUE);
+ err\_t ugh = atoid(src->id, &dst->id, TRUE, FALSE);
if (ugh != NULL)
{
diff --git a/programs/pluto/dnskey.c b/programs/pluto/dnskey.c
index 5525d12..78f1d0a 100644
- --- a/programs/pluto/dnskey.c
+++ b/programs/pluto/dnskey.c
@@ -277,8 +277,12 @@ decode\_iii(char \*\*pp, struct id \*gw\_id)
if (\*p == '@')
{
/\* gateway specification in this record is @FQDN \*/
- - err\_t ugh = atoid(p, gw\_id, FALSE);
+ if(strspn(p,' ') >= IDTOA\_BUF) {
+ return builddiag("malformed FQDN in TXT " our\_TXT\_attr\_string ": ID too large for IDTOA\_BUF");
+ }
+
+ err\_t ugh = atoid(p, gw\_id, FALSE, TRUE); /\* only run OE related parts of atoid() \*/
if (ugh != NULL)
return builddiag("malformed FQDN in TXT " our\_TXT\_attr\_string ": %s"
, ugh);
diff --git a/programs/pluto/myid.c b/programs/pluto/myid.c
index bdd0e12..2e92f25 100644
- --- a/programs/pluto/myid.c
+++ b/programs/pluto/myid.c
@@ -103,7 +103,7 @@ set\_myid(enum myid\_state s, char \*idstr)
if (idstr != NULL)
{
struct id id;
- - err\_t ugh = atoid(idstr, &id, FALSE);
+ err\_t ugh = atoid(idstr, &id, FALSE, FALSE);
if (ugh != NULL)
{
diff --git a/programs/pluto/rcv\_whack.c b/programs/pluto/rcv\_whack.c
index 1725357..7d5072c 100644
- --- a/programs/pluto/rcv\_whack.c
+++ b/programs/pluto/rcv\_whack.c
@@ -259,7 +259,7 @@ static void
key\_add\_request(const struct whack\_message \*msg)
{
struct id keyid;
- - err\_t ugh = atoid(msg->keyid, &keyid, FALSE);
+ err\_t ugh = atoid(msg->keyid, &keyid, FALSE, FALSE);
if (ugh != NULL)
{
diff --git a/programs/showhostkey/showhostkey.c b/programs/showhostkey/showhostkey.c
index c9fe9cf..bf87080 100644
- --- a/programs/showhostkey/showhostkey.c
+++ b/programs/showhostkey/showhostkey.c
@@ -203,7 +203,7 @@ struct secret \*pick\_key(struct secret \*host\_secrets
struct secret \*s;
err\_t e;
- - e = atoid(idname, &id, FALSE);
+ e = atoid(idname, &id, FALSE, FALSE);
if(e) {
printf("%s: key '%s' is invalid\n", progname, idname);
exit(4);
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.13 (GNU/Linux)
iQIcBAEBCAAGBQJRkWmnAAoJEIX/S0OzD8b5EZIP+wb5LyvL4jXGYJzvalkCjWL3
1cZp5H672jGdVvW/G3bJ5unhjpRt9ASxebHR/4LfWZuWG5U4gdPRjcz1YcuNwVnB
xOXZ4ELWYRFFblkkHz+GO5rSRwmWhFnyGvDdN5Oh6VBcmegHvaKk6uVLPXZJpVdg
2U1+s+x3EkrcP6IJyTa9pyhZiDWcdYVn3seyHcFCNa3R/Xkwefi3HwA2w8+L18NX
NvIMUx2aXj70cBE5VAg+XJWIZ2Rrlf2zHDM96GUUfGIIH1mzpuxYCFbpGqISmOYI
AAumQ9I4kQGy0ZkWn41Et3ppJvcRFoMlAz70Ay+nbZ/+eqQH9B3KfplfX2UrsXAn
SVvMPypkMfjhUbPG8AWr//6+a0uZxa0PyibNXhhdr+3ocANaZ8ty+ehFmVl0DIBM
rc582erQ8s4Bj8v+4vy1TzkR5HXWhwWhCjD0EnU8zGGjZ2u+1BAYgzTUG4Nqo+/Q
ziJdc71vy+OqyLXTFMdekUuRl40BXuFHHUv6jWeslgIh2/1Z/A0NZzxs2sMFCkEW
anTG32ridJSCqQhSXZ4xW07O5F45csH6qgze2jQdYEizATYsDqeKazEZhmakUsow
v5gj85f5VYGWjoYjKr/HbrueEbeGpV3Twf4tZ6XyCxAjJEt6N8XWidSiMeL3gNIm
cgXmYH+ak4nDLJGyaYDt
=5y9o
-----END PGP SIGNATURE-----

