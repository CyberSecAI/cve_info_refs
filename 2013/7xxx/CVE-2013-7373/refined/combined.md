=== Content from emboss.github.io_3fea3080_20250125_161957.html ===


[martinboßlet](/)

* [blog](/blog/archives/)
* services
  + [development](/services/development/)
  + [consulting](/services/consulting/)
  + [workshops](/services/workshops/)
* [cv](/cv/)
* [contact](/contact/)

# OpenSSL PRNG Is Not (Really) Fork-safe

Aug 21st, 2013

## The Android SecureRandom incident

When the [patch](http://android-developers.blogspot.de/2013/08/some-securerandom-thoughts.html)
for Android’s SecureRandom was released last week, I was a little surprised.
In addition to fixing the Apache Harmony implementation of SecureRandom, the
patch also contained

> Applies the fix for OpenSSL PRNG having low entropy. Does nothing if the fix is not needed.

What was that all about? I understood that the problem with the Harmony
implementation was a reaction to [this paper](http://www.nds.rub.de/media/nds/veroeffentlichungen/2013/03/25/paper_2.pdf)
published earlier this year and was more or less an implementation issue,
but what about OpenSSL? Newer versions of Android use a version of [OpenSSL](https://android.googlesource.com/platform/external/openssl/%2B/master)
internally and there is a [Java bridge](https://android.googlesource.com/platform/libcore/%2B/master/crypto/src/main/java/org/conscrypt/NativeCrypto.java)
that exposes, among other things, access to OpenSSL’s Pseudo-Random Number
Generator (PRNG). What caught my attention is that the Android patch
explicitly seeds the OpenSSL PRNG using more or less predictable data
and then it mixes in additional entropy from /dev/urandom. This seemed
weird at first, since the OpenSSL PRNG [seeds itself](https://github.com/openssl/openssl/blob/902efde1cca5910703af57cfc9b5e0fb7980f5b6/crypto/rand/md_rand.c#L408-L412)
from /dev/urandom [on systems where it is available](https://github.com/openssl/openssl/blob/902efde1cca5910703af57cfc9b5e0fb7980f5b6/crypto/rand/rand_unix.c#L153)
before it will return any random data. Why would there be the need to
do that manually then?

## Zygote, Ruby and forking OpenSSL

> UPDATE: Eric has asked me to additionally credit Alexander Dymo for
> [bringing up this issue](http://bogomips.org/unicorn.git/patch?id=1107ede716461049033d6a5b311e14c742c9363a)!

Then I found out about how Android heavily relies on forking processes
using [Zygote](https://android.googlesource.com/platform/frameworks/base.git/%2B/master/core/java/com/android/internal/os/ZygoteInit.java)
and I now suspect that this is the reason for patching OpenSSL. I was
immediately reminded of a problem that was brought up on the Ruby mailing
list [a while ago](https://bugs.ruby-lang.org/issues/4579). Eric Wong had
discovered that Ruby’s SecureRandom implementation would serve exactly the
same ‘random’ byte sequence when forked in a child process as soon as the
PIDs (process identifiers) start to wrap around. Typically PIDs start with
0 again after exhausting PID number 32768 - this may vary, to be sure you
may find out the exact value using

Retrieving the maximum possible PID

| ``` 1  ``` | ```   cat /proc/sys/kernel/pid_max  ``` |
| --- | --- |

While this was fixed for SecureRandom (more on that later), you may still
observe the same behavior with OpenSSL::Random today - as Ruby’s OpenSSL
extension is meant to be a mere wrapper around OpenSSL itself we try to
avoid adding custom behavior when possible. To try it out, we simply have
to replace ‘SecureRandom’ with ‘OpenSSL::Random’ in Eric’s script:

Predictable OpenSSL::Random

| ``` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  ``` | ``` require "openssl" OpenSSL::Random.random_bytes(4) pid = fork do   p [ $$, OpenSSL::Random.random_bytes(4) ] end Process.waitpid2(pid) loop do   xpid = fork do     p [ $$, OpenSSL::Random.random_bytes(4) ] if $$ == pid   end   Process.waitpid2(xpid)   break if xpid == pid end  ``` |
| --- | --- |

The script takes a while to run, but it is well worth the surprise. At the
time, we discussed whether this is an OpenSSL-internal issue or not and Eric
also posted to the [OpenSSL mailing list](http://marc.info/?l=openssl-dev&m=130289811108150).
The OpenSSL devs did not want to solve this internally, as they would like
to stay agnostic to OS specifics as much as possible. The argument that
‘fork’ may not be the only way to perform process bifurcation is certainly
correct. The recommendation was to mix in something unique every time a
child process is forked so that the initially equivalent state is sufficiently
altered. This is also what we did for [SecureRandom](https://github.com/ruby/ruby/blob/4c661094c9d2c6800a7f43f41b812fa4aee18634/lib/securerandom.rb#L53-L63)
eventually.

The key of why Eric’s script works is that the OpenSSL PRNG must be initialized
in the parent before we fork the child processes. This way, every child process
starts out with exactly the same internal PRNG state, and the PID is the only
thing process-specific that is fed to the PRNG algorithm when requesting
random bytes. Let’s have a look at ssleay\_rand\_bytes, the function
responsible for generating pseudo-random bytes:

md\_rand.c: ssleay\_rand\_bytes

| ``` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110  ``` | ``` static int ssleay_rand_bytes(unsigned char *buf, int num, int pseudo)   {            /* Leaving out some details and adding comments of my own */         ...         /* Since the PRNG was initialized in the parent process, initialized          * will be set to 1 already and this is skipped          */   if (!initialized)       {       RAND_poll();       initialized = 1;       }         /* This is also 1 and skipped */   if (!stirred_pool)       do_stir_pool = 1;         /* We have enough entropy because the PRNG is already initialized */   ok = (entropy >= ENTROPY_NEEDED);   if (!ok)       {               /* Not executed */                     ...           }   if (do_stir_pool)       {           /* Not executed */                     ...       }         /* These are identical for every forked child */   st_idx=state_index;   st_num=state_num;   md_c[0] = md_count[0];   md_c[1] = md_count[1];   memcpy(local_md, md, sizeof md);   state_index+=num_ceil;   if (state_index > state_num)       state_index %= state_num;   md_count[0] += 1;   while (num > 0)       {       j=(num >= MD_DIGEST_LENGTH/2)?MD_DIGEST_LENGTH/2:num;       num-=j;       if (!MD_Init(&m))           goto err;                 /* This is actually the only child process-specific value */       if (curr_pid)           {           if (!MD_Update(&m,(unsigned char*)&curr_pid,sizeof curr_pid))               goto err;           curr_pid = 0;           }       if (!MD_Update(&m,local_md,MD_DIGEST_LENGTH))           goto err;       if (!MD_Update(&m,(unsigned char *)&(md_c[0]),sizeof(md_c)))           goto err; #ifndef PURIFY       /* VERY interesting, more on that in a minute. For now, assume it's the                  * same in each child process       */       if (!MD_Update(&m,buf,j))           goto err; #endif       k=(st_idx+MD_DIGEST_LENGTH/2)-st_num;       if (k > 0)           {           if (!MD_Update(&m,&(state[st_idx]),MD_DIGEST_LENGTH/2-k))               goto err;           if (!MD_Update(&m,&(state[0]),k))               goto err;           }       else           if (!MD_Update(&m,&(state[st_idx]),MD_DIGEST_LENGTH/2))               goto err;       if (!MD_Final(&m,local_md))           goto err;       for (i=0; i<MD_DIGEST_LENGTH/2; i++)           {           state[st_idx++]^=local_md[i];           if (st_idx >= st_num)               st_idx=0;           if (i < j)               *(buf++)=local_md[i+MD_DIGEST_LENGTH/2];                         /* This is where the output is generated. Everything that                          * was fed to local_md is exactly the same for each child                          * except for the PID.                          */           }       }   /* The rest is not relevant for our observation */         ...   }  ``` |
| --- | --- |

Because the child process PID is the only thing specific to each child process,
we will eventually see exactly the same random bytes once PID values start to
recycle. This means that while adding the PID to the message digest makes for
some fork safety, it is not enough when we consider that PIDs are not
incremented infinitely but will wrap eventually. I could very well imagine
that this is somehow related to the Android OpenSSL patch and their extensive
use of forking…

## It works in Ruby, so how about C?

Eric Wong did post a C example along with his post to the OpenSSL mailing list,
which was essentially a C version of the Ruby code that we already saw:

C version of Eric Wong’s proof of concept

| ``` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  ``` | ``` #include <sys/types.h> #include <sys/wait.h> #include <unistd.h> #include <stdio.h> #include <openssl/rand.h> static void dump_random(void) {   int i;   unsigned char buf[4];   RAND_bytes(buf, sizeof(buf));   printf("pid=%d ", getpid());   for (i = 0; i < sizeof(buf); i++) {             printf("\\x%02x", buf[i]);         }   puts(""); } int main(void) {   pid_t pid, xpid;   /* PRNG needs to be initialized in original process to reproduce */   RAND_bytes((unsigned char *)&pid, sizeof(pid));   pid = fork();   if (pid == 0) {       dump_random();       return 0;   } else if (pid > 0) {       wait(NULL);       do {           xpid = fork();           if (xpid == 0) {               if (getpid() == pid)                   dump_random();               return 0;           } else if (xpid > 0) {               wait(NULL);           } else {               perror("fork");           }       } while (pid != xpid);   } else {       perror("fork");       return 1;   }   return 0; }  ``` |
| --- | --- |

I ran this to see if maybe the problem had been fixed somehow in OpenSSL in the
meantime. Much to my surprise, I could reproduce the repeated ‘random’ numbers
on my laptop (running Linux Mint) but I could not when running it on my desktop
(running Fedora). What the? I downloaded sources for both distributions and I
compared them to the official OpenSSL 1.0.1e. Fedora was using the same code as
in 1.0.1e and consequently I couldn’t reproduce the behavior with 1.0.1e either.

## It’s me again, the Debian OpenSSL bug

So was it fixed there but it somehow wasn’t in the Mint version of OpenSSL?! I
couldn’t spot any difference until I finally simply used the diff command. There.
Just one single difference between Fedora/the official OpenSSL versions and the
Mint version:

The difference in ssleay\_rand\_bytes

| ``` 1 2 3 4 5 6 7 8 9 10 11 12  ``` | ``` #ifndef PURIFY /* purify complains */ #if 0       /* The following line uses the supplied buffer as a small        * source of entropy: since this buffer is often uninitialised        * it may cause programs such as purify or valgrind to        * complain. So for those builds it is not used: the removal        * of such a small source of entropy has negligible impact on        * security.        */       MD_Update(&m,buf,j); #endif #endif  ``` |
| --- | --- |

There’s an ‘#if 0’ around the line that I marked as ‘interesting’ before. And then
it clicked. Mint uses Ubuntu packages which again uses Debian packages. This is
actually the Debian version of OpenSSL! The ‘#if 0’ is actually a remainder of the
famous Debian OpenSSL ‘patch’ that severely crippled the PRNG’s entropy a couple of
years ago! If you haven’t heard about it, here is a mean but precise [article](http://www.gergely.risko.hu/debian-dsa1571.en.html)
describing what went wrong there. While one part of the patch had to be removed,
this gem was actually sanctioned to stay in there. But how can this have any impact
when the OpenSSL devs clearly state that it should have little to no impact on the
overall security? The reason is uninitialized memory. The official version (without
the ‘#if 0’) does something dubious: it adds the user-provided buffer to the hash
calculation in the hope that most users would not have initialized the buffer at
this point. If uninitialized, the buffer could(!) contain unpredictable values and
would contribute a little entropy.

This now works with Eric Wong’s example code because we do not initialize the buffer
there, and this is why the final behavior is different when compared to 1.0.1e/Fedora.
But this can be easily ‘fixed’ by initializing the buffer - and voilà, random bytes
are repeated again, regardless of the OpenSSL version in use:

‘Fixed’ version for predictable output regardless of OpenSSL version

| ``` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  ``` | ``` #include <sys/types.h> #include <sys/wait.h> #include <unistd.h> #include <stdio.h> #include <string.h> #include <openssl/rand.h> static void dump_random(void) {     int i;     unsigned char buf[4];     /* does the 'trick' */     memset(buf, 0, sizeof(buf));     RAND_bytes(buf, sizeof(buf));     printf("pid=%d ", getpid());     for (i = 0; i < sizeof(buf); i++) {         printf("\\x%02x", buf[i]);     }     puts(""); } int main(void) {    /* as before */ }  ``` |
| --- | --- |

## So is it fixed or not or what?!

Now you may also realize why the Ruby code sample worked regardless of the
OpenSSL version while in the C example we needed to explicitly initialize
the memory first: the solution is that the C code behind
Ruby’s OpenSSL::Random actually [does initialize](https://github.com/ruby/ruby/blob/4c661094c9d2c6800a7f43f41b812fa4aee18634/ext/openssl/ossl_rand.c#L95-107)
the buffer first. Considering a user-provided value as your safety net
is never a good idea, but it’s even worse in this case: not only does the
dubious practice of relying on uninitialized values cause problems with
tools such as valgrind (which ironically were the reason for the Debian
disaster) but it also masks the problem at hand while contributing little
to none to security. This cannot be regarded as the solution to the
problem, I would be very much in favor of removing this confusing line
completely.

Anyhow, the question seems to be much more if we may consider this ‘PID
wrapping issue’ a problem of OpenSSL itself or if this must be marked
as ‘the developer has to take care of this’. Now those who know me also
know that for me, there can be only one definitive answer to
this question. Sure, developers could take care of this and handle it
properly on their own, but we have striking examples now for how often
this will *not* happen in reality. The first time I saw this was when Eric
brought it up on bugs.ruby-lang.org, but it has now most likely bitten the
Android developers and some research brought up that it has also
affected [Postgres](http://www.postgresql.org/message-id/E1UKzBn-0006c2-Cy%40gemulon.postgresql.org)
developers. Now even if you don’t trust us Ruby developers, I’m pretty
sure we can all agree that Android and Postgres developers are fairly good at what
they’re doing. Still they overlooked this. And honestly - who of us would
have thought about this when forking a process? Funny anecdote: A long time
ago, this was a valid concern for OpenSSL devs as well- as this
[ancient commit](https://github.com/openssl/openssl/commit/62ac2938015939e2ef30f12295f0ee59ff79c11b#crypto/rand)
clearly shows.

## How to fix this for good?

We cannot keep on adding ‘best practice’ after ‘best practice’ to what
developers need to keep in the back of their heads when writing everyday
code. This approach must fail eventually and the only reliable solution
is to fix problems like this at the root - and this is clearly in the
library providing the functionality itself. A quick fix like already
proposed on the OpenSSL mailing list might be to mix in the current
time in addition to the PID. Even if we add a predictable value like that
an attacker hopefully cannot observe enough of the internal PRNG state
to make any use of the predictable values to find out more about the
internal state. To exploit the repeated random numbers we had to rely on
the internal PRNG state being exactly the same in different child processes
while nothing was actually revealed about the internal state. Simply changing the
internal state, even with predictable values, seems to be enough at this point.

This is the fix that had been applied to Ruby’s SecureRandom, but there
are several reasons why I’m still not too happy with OpenSSL’s PRNG. The
biggest issue for me is that it’s more or less an ad-hoc design that
doesn’t follow an official standard or recommendation. There is for example
[Fortuna](http://en.wikipedia.org/wiki/Fortuna_%28PRNG%29) or
[NIST SP 800-90A](http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf),
[B](http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf)
and [C](http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90c.pdf),
and interestingly enough OpenSSL uses one of the NIST designs for its FIPS
version. People analyzing the OpenSSL PRNG security have complained many times
that the source code is complicated and hard to grasp (see the Debian issue),
and it is therefore so much harder to assess its general security. I would
appreciate a more standardized design. Markku-Juhani O. Saarinen discovered
a flaw in the PRNG [more than a decade ago](http://mjos.fi/doc/secadv_prng.txt).
Because of the ad-hoc design, who is to say that this has been fixed for
good?

The easiest way out is probably to completely rely on /dev/urandom where
available. Sure it comes with its own [baggage](http://eprint.iacr.org/2006/086.pdf)
and there’s the problem with availability and different behavior on different
platforms, but after all, it has a fairly [good reputation](http://eprint.iacr.org/2012/251.pdf).
Most of all, it is not affected by any forking issues.

## What’s the impact of all of this?

To be fair, the issue with forking demonstrated here should have little
impact in everyday software (other than *cough*, Android that is). Even
if you are developing a Rails app using a forking web server like Unicorn
with Resque background jobs and OpenSSL::Random instead of SecureRandom,
you should not be affected. Most software that I can think of allocates a
pool of ‘worker processes’, so it is probably unlikely that you would ever
run into the problem of wrapping PIDs. Still, we consider a cipher broken even
if the attack is impractical in reality - if only the attack involves less
work than trying brute force. In this sense, the OpenSSL PRNG is broken in its
current state because we have found a way to predict its output other
than by brute force. I hope the OpenSSL team will fix this internally
and make our lives easier by not having to think about these issues
when working on our everyday projects.

If you are on Ruby and you think that you might be affected you might
try adding additional entropy to OpenSSL::Random after a fork:

Adding entropy to OpenSSL::Random after a fork

| ``` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  ``` | ``` require 'openssl' module OpenSSL::Random   class << self     old_rand = instance_method(:random_bytes)     define_method :random_bytes do |n=nil|       n = n ? n.to_int : 16       @pid = 0 unless defined?(@pid)       pid = $$       unless @pid == pid # detect a fork and modify PRNG state         add_predictable(pid)         add_urandom         @pid = pid       end       old_rand.bind(self).call(n)     end     private     def add_predictable(pid)       now = Time.now       ary = [now.to_i, now.nsec, @pid, pid]       OpenSSL::Random.random_add(ary.join('').to_s, 0.0)     end     def add_urandom       begin         OpenSSL::Random.load_random_file('/dev/urandom')       rescue OpenSSL::Random::RandomError         # probably not available, reraise if mandatory for you       end     end   end end  ``` |
| --- | --- |

‘add\_predictable’ is basically the same as the SecureRandom fix. It’s
enough to make the repeated random numbers go away, but the truly
paranoid will also want to use ‘add\_urandom’ as it refreshes OpenSSL’s
PRNG internal state using random data gathered from /dev/urandom.
OpenSSL::Random.load\_random\_file causes the OpenSSL PRNG to gather
[2048](https://github.com/openssl/openssl/blob/902efde1cca5910703af57cfc9b5e0fb7980f5b6/crypto/rand/randfile.c#L149)
bytes of entropy that are then mixed in to its internal state.
Because 2048 is quite a bit larger than the internal state, this ensures
that every single state byte is updated by the data read from /dev/urandom.
This reflects the fix proposed in the Android SecureRandom patch.
The same principle might of course be applied in C code as well.

## Lessons learned

Random numbers are absolutely essential for a crypto library, if they
suck we don’t even have to get started with encryption or anything else,
because it all collapses to something trivially deterministic and
therefore predictable. I very much like the idea of using /dev/urandom
as sole Random Number Generator for cryptographic purposes, mostly
because this would give us a single construct that research could
focus on and it provides more flexibility to mix in data generated
by hardware RNGs.

Also, this is again a perfect example for how confusing code can cause
a lot of trouble. There is so much code shared between ssleay\_rand\_bytes
and ssleay\_rand\_add that it’s really hard to spot the differences. This
was probably a major reason for the Debian disaster. A little bit of
refactoring would do wonders here - move shared parts to separate
functions and give them expressive meaningful names. Template Method
Pattern for the win. To be fair, the [Kernel code](https://github.com/torvalds/linux/blob/fd3930f70c8d14008f3377d51ce039806dfc542e/drivers/char/random.c)
implementing /dev/urandom is also no beauty. But if clarity, expressiveness
and the DRY principle in general are good practice for everyday coding, their
value is doubled for security-critical code.

Thanks to Eric Wong again for all his work, not just on this issue!

Source code accompanying this post can be found [here](https://github.com/emboss/openssl-prng).

Posted by Martin Boßlet
Aug 21st, 2013
[Cryptography](/blog/categories/cryptography/), [OpenSSL](/blog/categories/openssl/), [Random Number Generation](/blog/categories/random-number-generation/), [Security](/blog/categories/security/)

[Tweet](http://twitter.com/share)
[Follow @\_emboss\_](http://twitter.com/_emboss_)

* [« E-Mail made in Germany - Really??](/blog/2013/08/11/e-mail-made-in-germany-really/ "Previous Post:
          E-Mail made in Germany - Really??")
* [Blog Archives](/blog/archives)

## recent posts

* [OpenSSL PRNG is not (really) fork-safe](/blog/2013/08/21/openssl-prng-is-not-really-fork-safe/)
* [E-Mail made in Germany - Really??](/blog/2013/08/11/e-mail-made-in-germany-really/)
* [We need to sign Ruby Gems! But how?](/blog/2013/02/15/we-need-to-sign-ruby-gems-but-how/)
* [Breaking Murmur: Hash-flooding DoS reloaded](/blog/2012/12/14/breaking-murmur-hash-flooding-dos-reloaded/)
* [krypt - The next level of Ruby cryptography](/blog/2012/12/02/krypt-the-next-level-of-ruby-cryptography/)

## github repos

* status updating...

[@emboss](https://github.com/emboss) on GitHub

[Martin Boßlet](/), 2013.



=== Content from android-developers.blogspot.com.au_7bc11e16_20250125_161956.html ===


![](https://ad.doubleclick.net/ddm/activity/src=2542116;type=gblog;cat=googl0;ord=1?)

[![hero android logo](https://developer.android.com/static/images/logos/android.svg)](https://android-developers.googleblog.com)
 ☰
[Android Developers Blog](https://android-developers.googleblog.com)

The latest Android and Google Play news for app and game
developers.

 🔍
![](data:image/png;base64...)

[Android Developers →](https://developer.android.com/)

[Jetpack](https://developer.android.com/jetpack)
[Kotlin](https://developer.android.com/kotlin)
[Docs](https://developer.android.com/docs)
[News](https://developer.android.com/news)

![](data:image/png;base64...)
[Platform](https://developer.android.com/about)
[Android Studio](https://developer.android.com/studio)
[Google Play](https://developer.android.com/distribute)
[Jetpack](https://developer.android.com/jetpack)
[Kotlin](https://developer.android.com/kotlin)
[Docs](https://developer.android.com/docs)
[News](https://developer.android.com/news)
[![Android Developers Site](https://developer.android.com/static/images/logos/android.svg)](https://developer.android.com/ "Android Developers Site")
[![Android Developers on YouTube](https://www.gstatic.com/images/icons/material/system/2x/video_youtube_grey600_24dp.png)](https://www.youtube.com/user/androiddevelopers "Android Developers on YouTube")
[![Android Developers on LinkedIn](https://www.pagetraffic.com/blog/wp-content/uploads/2022/09/linkedin-black-white-logo.png)](https://www.linkedin.com/showcase/androiddev/ "Android Developers on LinkedIn")
[![Android Developers on Medium](data:image/png;base64...)](https://medium.com/androiddevelopers "Android Developers on Medium")
[![Follow Android Developers on X](https://developers.google.com/static/homepage-assets/images/x.svg)](https://x.com/androiddev "Follow Android Developers on X")

[![Google Play Site](https://developer.android.com/static/images/logos/google-play.svg)](https://developer.android.com/distribute/ "Google Play Site")
[![Google Play Apps & Games on LinkedIn](https://www.pagetraffic.com/blog/wp-content/uploads/2022/09/linkedin-black-white-logo.png)](https://www.linkedin.com/company/googleplaybiz/ "Google Play Apps & Games on LinkedIn")
[![Google Play Apps & Games on Medium](data:image/png;base64...)](https://medium.com/googleplaydev "Google Play Apps & Games on Medium")
[![Follow GooglePlayBiz on X](https://developers.google.com/static/homepage-assets/images/x.svg)](https://x.com/GooglePlayBiz "Follow GooglePlaydBiz on X")

[Platform](https://developer.android.com/about)

[Android Studio](https://developer.android.com/studio)

[Google Play](https://developer.android.com/distribute)

[Jetpack](https://developer.android.com/jetpack)

[Kotlin](https://developer.android.com/kotlin)

[Docs](https://developer.android.com/docs)

[News](https://developer.android.com/news)

More
![](data:image/png;base64...)

[![Android Developers Site](https://developer.android.com/static/images/logos/android.svg)](https://developer.android.com/ "Android Developers Site")
[![Android Developers on YouTube](https://www.gstatic.com/images/icons/material/system/2x/video_youtube_grey600_24dp.png)](https://www.youtube.com/user/androiddevelopers "Android Developers on YouTube")
[![Android Developers on LinkedIn](https://www.pagetraffic.com/blog/wp-content/uploads/2022/09/linkedin-black-white-logo.png)](https://www.linkedin.com/showcase/androiddev/ "Android Developers on LinkedIn")
[![Android Developers on Medium](data:image/png;base64...)](https://medium.com/androiddevelopers "Android Developers on Medium")
[![Follow Android Developers on X](https://developers.google.com/static/homepage-assets/images/x.svg)](https://X.com/androiddev "Follow Android Developers on X")

|
[![Google Play Site](https://developer.android.com/static/images/logos/google-play.svg)](https://developer.android.com/distribute/ "Google Play Site")
[![Google Play Apps & Games on LinkedIn](https://www.pagetraffic.com/blog/wp-content/uploads/2022/09/linkedin-black-white-logo.png)](https://www.linkedin.com/company/googleplaybiz/ "Google Play Apps & Games on LinkedIn")
[![Google Play Apps & Games on Medium](data:image/png;base64...)](https://medium.com/googleplaydev "Google Play Apps & Games on Medium")
[![Follow GooglePlayBiz on X](https://developers.google.com/static/homepage-assets/images/x.svg)](https://X.com/GooglePlayBiz "Follow GooglePlaydBiz on X")

14 August 2013

# Some SecureRandom Thoughts

---

Share this post
[![Share on LinkedIn](https://www.gstatic.com/dgc_blog/images/ic_linkedin_black.svg)
LinkedIn](https://www.linkedin.com/shareArticle?mini=true&url=https://android-developers.googleblog.com/2013/08/some-securerandom-thoughts.html&title=Some SecureRandom Thoughts)
[![Share on X](https://developers.google.com/static/homepage-assets/images/x.svg)
Twitter](https://x.com/share?text=Android Developers Blog: Some SecureRandom Thoughts&url=https://android-developers.googleblog.com/2013/08/some-securerandom-thoughts.html&via=google)
[![Share on Facebook](https://www.gstatic.com/dgc_blog/images/ic_facebook_black.svg)
Facebook](https://www.facebook.com/sharer.php?u=https://android-developers.googleblog.com/2013/08/some-securerandom-thoughts.html)
![Share in mail](https://www.gstatic.com/dgc_blog/images/ic_mail.svg)
Email
![Copy link](https://www.gstatic.com/dgc_blog/images/ic_link.svg)
Copy link

Link copied to clipboard

*Posted by Alex Klyubin, Android Security Engineer*

The Android security team has been investigating the root cause of the compromise of a bitcoin transaction that led to [the update of multiple Bitcoin applications](http://bitcoin.org/en/alert/2013-08-11-android) on August 11.

We have now determined that applications which use the Java Cryptography Architecture (JCA) for key generation, signing, or random number generation may not receive cryptographically strong values on Android devices due to improper initialization of the underlying PRNG. Applications that directly invoke the system-provided OpenSSL PRNG without explicit initialization on Android are also affected. Applications that establish TLS/SSL connections using the `HttpClient` and `java.net` classes are not affected as those classes do seed the OpenSSL PRNG with values from `/dev/urandom`.

Developers who use JCA for key generation, signing or random number generation should update their applications to explicitly initialize the PRNG with entropy from `/dev/urandom` or `/dev/random`. A suggested implementation is provided at the end of this blog post. Also, developers should evaluate whether to regenerate cryptographic keys or other random values previously generated using JCA APIs such as `SecureRandom`, `KeyGenerator`, `KeyPairGenerator`, `KeyAgreement`, and `Signature`.

In addition to this developer recommendation, Android has developed patches that ensure that Android’s OpenSSL PRNG is initialized correctly. Those patches have been provided to OHA partners and have been checked into the Android tree. Applications which run exclusively on Android KitKat (4.4) or above do not need to take any special action to work around this bug.

We would like to thank Soo Hyeon Kim, Daewan Han of ETRI and Dong Hoon Lee of Korea University who notified Google about the improper initialization of OpenSSL PRNG.

**Update**: the original code sample below crashed on a small fraction of Android devices due to `/dev/urandom` not being writable. We have now updated the code sample to handle this case gracefully.

```
/*
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will Google be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, as long as the origin is not misrepresented.
 */

import android.os.Build;
import android.os.Process;
import android.util.Log;

import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.security.NoSuchAlgorithmException;
import java.security.Provider;
import java.security.SecureRandom;
import java.security.SecureRandomSpi;
import java.security.Security;

/**
 * Fixes for the output of the default PRNG having low entropy.
 *
 * The fixes need to be applied via {@link #apply()} before any use of Java
 * Cryptography Architecture primitives. A good place to invoke them is in the
 * application's {@code onCreate}.
 */
public final class PRNGFixes {

    private static final int VERSION_CODE_JELLY_BEAN = 16;
    private static final int VERSION_CODE_JELLY_BEAN_MR2 = 18;
    private static final byte[] BUILD_FINGERPRINT_AND_DEVICE_SERIAL =
        getBuildFingerprintAndDeviceSerial();

    /** Hidden constructor to prevent instantiation. */
    private PRNGFixes() {}

    /**
     * Applies all fixes.
     *
     * @throws SecurityException if a fix is needed but could not be applied.
     */
    public static void apply() {
        applyOpenSSLFix();
        installLinuxPRNGSecureRandom();
    }

    /**
     * Applies the fix for OpenSSL PRNG having low entropy. Does nothing if the
     * fix is not needed.
     *
     * @throws SecurityException if the fix is needed but could not be applied.
     */
    private static void applyOpenSSLFix() throws SecurityException {
        if ((Build.VERSION.SDK_INT < VERSION_CODE_JELLY_BEAN)
                || (Build.VERSION.SDK_INT > VERSION_CODE_JELLY_BEAN_MR2)) {
            // No need to apply the fix
            return;
        }

        try {
            // Mix in the device- and invocation-specific seed.
            Class.forName("org.apache.harmony.xnet.provider.jsse.NativeCrypto")
                    .getMethod("RAND_seed", byte[].class)
                    .invoke(null, generateSeed());

            // Mix output of Linux PRNG into OpenSSL's PRNG
            int bytesRead = (Integer) Class.forName(
                    "org.apache.harmony.xnet.provider.jsse.NativeCrypto")
                    .getMethod("RAND_load_file", String.class, long.class)
                    .invoke(null, "/dev/urandom", 1024);
            if (bytesRead != 1024) {
                throw new IOException(
                        "Unexpected number of bytes read from Linux PRNG: "
                                + bytesRead);
            }
        } catch (Exception e) {
            throw new SecurityException("Failed to seed OpenSSL PRNG", e);
        }
    }

    /**
     * Installs a Linux PRNG-backed {@code SecureRandom} implementation as the
     * default. Does nothing if the implementation is already the default or if
     * there is not need to install the implementation.
     *
     * @throws SecurityException if the fix is needed but could not be applied.
     */
    private static void installLinuxPRNGSecureRandom()
            throws SecurityException {
        if (Build.VERSION.SDK_INT > VERSION_CODE_JELLY_BEAN_MR2) {
            // No need to apply the fix
            return;
        }

        // Install a Linux PRNG-based SecureRandom implementation as the
        // default, if not yet installed.
        Provider[] secureRandomProviders =
                Security.getProviders("SecureRandom.SHA1PRNG");
        if ((secureRandomProviders == null)
                || (secureRandomProviders.length < 1)
                || (!LinuxPRNGSecureRandomProvider.class.equals(
                        secureRandomProviders[0].getClass()))) {
            Security.insertProviderAt(new LinuxPRNGSecureRandomProvider(), 1);
        }

        // Assert that new SecureRandom() and
        // SecureRandom.getInstance("SHA1PRNG") return a SecureRandom backed
        // by the Linux PRNG-based SecureRandom implementation.
        SecureRandom rng1 = new SecureRandom();
        if (!LinuxPRNGSecureRandomProvider.class.equals(
                rng1.getProvider().getClass())) {
            throw new SecurityException(
                    "new SecureRandom() backed by wrong Provider: "
                            + rng1.getProvider().getClass());
        }

        SecureRandom rng2;
        try {
            rng2 = SecureRandom.getInstance("SHA1PRNG");
        } catch (NoSuchAlgorithmException e) {
            throw new SecurityException("SHA1PRNG not available", e);
        }
        if (!LinuxPRNGSecureRandomProvider.class.equals(
                rng2.getProvider().getClass())) {
            throw new SecurityException(
                    "SecureRandom.getInstance(\"SHA1PRNG\") backed by wrong"
                    + " Provider: " + rng2.getProvider().getClass());
        }
    }

    /**
     * {@code Provider} of {@code SecureRandom} engines which pass through
     * all requests to the Linux PRNG.
     */
    private static class LinuxPRNGSecureRandomProvider extends Provider {

        public LinuxPRNGSecureRandomProvider() {
            super("LinuxPRNG",
                    1.0,
                    "A Linux-specific random number provider that uses"
                        + " /dev/urandom");
            // Although /dev/urandom is not a SHA-1 PRNG, some apps
            // explicitly request a SHA1PRNG SecureRandom and we thus need to
            // prevent them from getting the default implementation whose output
            // may have low entropy.
            put("SecureRandom.SHA1PRNG", LinuxPRNGSecureRandom.class.getName());
            put("SecureRandom.SHA1PRNG ImplementedIn", "Software");
        }
    }

    /**
     * {@link SecureRandomSpi} which passes all requests to the Linux PRNG
     * ({@code /dev/urandom}).
     */
    public static class LinuxPRNGSecureRandom extends SecureRandomSpi {

        /*
         * IMPLEMENTATION NOTE: Requests to generate bytes and to mix in a seed
         * are passed through to the Linux PRNG (/dev/urandom). Instances of
         * this class seed themselves by mixing in the current time, PID, UID,
         * build fingerprint, and hardware serial number (where available) into
         * Linux PRNG.
         *
         * Concurrency: Read requests to the underlying Linux PRNG are
         * serialized (on sLock) to ensure that multiple threads do not get
         * duplicated PRNG output.
         */

        private static final File URANDOM_FILE = new File("/dev/urandom");

        private static final Object sLock = new Object();

        /**
         * Input stream for reading from Linux PRNG or {@code null} if not yet
         * opened.
         *
         * @GuardedBy("sLock")
         */
        private static DataInputStream sUrandomIn;

        /**
         * Output stream for writing to Linux PRNG or {@code null} if not yet
         * opened.
         *
         * @GuardedBy("sLock")
         */
        private static OutputStream sUrandomOut;

        /**
         * Whether this engine instance has been seeded. This is needed because
         * each instance needs to seed itself if the client does not explicitly
         * seed it.
         */
        private boolean mSeeded;

        @Override
        protected void engineSetSeed(byte[] bytes) {
            try {
                OutputStream out;
                synchronized (sLock) {
                    out = getUrandomOutputStream();
                }
                out.write(bytes);
                out.flush();
            } catch (IOException e) {
                // On a small fraction of devices /dev/urandom is not writable.
                // Log and ignore.
                Log.w(PRNGFixes.class.getSimpleName(),
                        "Failed to mix seed into " + URANDOM_FILE);
            } finally {
                mSeeded = true;
            }
        }

        @Override
        protected void engineNextBytes(byte[] bytes) {
            if (!mSeeded) {
                // Mix in the device- and invocation-specific seed.
                engineSetSeed(generateSeed());
            }

            try {
                DataInputStream in;
                synchronized (sLock) {
                    in = getUrandomInputStream();
                }
                synchronized (in) {
                    in.readFully(bytes);
                }
            } catch (IOException e) {
                throw new SecurityException(
                        "Failed to read from " + URANDOM_FILE, e);
            }
        }

        @Override
        protected byte[] engineGenerateSeed(int size) {
            byte[] seed = new byte[size];
            engineNextBytes(seed);
            return seed;
        }

        private DataInputStream getUrandomInputStream() {
            synchronized (sLock) {
                if (sUrandomIn == null) {
                    // NOTE: Consider inserting a BufferedInputStream between
                    // DataInputStream and FileInputStream if you need higher
                    // PRNG output performance and can live with future PRNG
                    // output being pulled into this process prematurely.
                    try {
                        sUrandomIn = new DataInputStream(
                                new FileInputStream(URANDOM_FILE));
                    } catch (IOException e) {
                        throw new SecurityException("Failed to open "
                                + URANDOM_FILE + " for reading", e);
                    }
                }
                return sUrandomIn;
            }
        }

        private OutputStream getUrandomOutputStream() throws IOException {
            synchronized (sLock) {
                if (sUrandomOut == null) {
                    sUrandomOut = new FileOutputStream(URANDOM_FILE);
                }
                return sUrandomOut;
            }
        }
    }

    /**
     * Generates a device- and invocation-specific seed to be mixed into the
     * Linux PRNG.
     */
    private static byte[] generateSeed() {
        try {
            ByteArrayOutputStream seedBuffer = new ByteArrayOutputStream();
            DataOutputStream seedBufferOut =
                    new DataOutputStream(seedBuffer);
            seedBufferOut.writeLong(System.currentTimeMillis());
            seedBufferOut.writeLong(System.nanoTime());
            seedBufferOut.writeInt(Process.myPid());
            seedBufferOut.writeInt(Process.myUid());
            seedBufferOut.write(BUILD_FINGERPRINT_AND_DEVICE_SERIAL);
            seedBufferOut.close();
            return seedBuffer.toByteArray();
        } catch (IOException e) {
            throw new SecurityException("Failed to generate seed", e);
        }
    }

    /**
     * Gets the hardware serial number of this device.
     *
     * @return serial number or {@code null} if not available.
     */
    private static String getDeviceSerialNumber() {
        // We're using the Reflection API because Build.SERIAL is only available
        // since API Level 9 (Gingerbread, Android 2.3).
        try {
            return (String) Build.class.getField("SERIAL").get(null);
        } catch (Exception ignored) {
            return null;
        }
    }

    private static byte[] getBuildFingerprintAndDeviceSerial() {
        StringBuilder result = new StringBuilder();
        String fingerprint = Build.FINGERPRINT;
        if (fingerprint != null) {
            result.append(fingerprint);
        }
        String serial = getDeviceSerialNumber();
        if (serial != null) {
            result.append(serial);
        }
        try {
            return result.toString().getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("UTF-8 encoding not supported");
        }
    }
}
```
[Join the discussion on](https://plus.google.com/108967384991768947849/posts/YxWzeNQMJS2)

[+Android Developers](https://plus.google.com/108967384991768947849/posts/YxWzeNQMJS2)[![](https://ssl.gstatic.com/images/icons/gplus-32.png)](https://plus.google.com/108967384991768947849/posts/YxWzeNQMJS2)

---

[Android](https://android-developers.googleblog.com/search/label/Android?max-results=12)
[archive](https://android-developers.googleblog.com/search/label/archive?max-results=12)
[Security](https://android-developers.googleblog.com/search/label/Security?max-results=12)

[Newer post](https://android-developers.googleblog.com/2013/08/google-play-services-32.html "Newer Post")
[Older post](https://android-developers.googleblog.com/2013/08/actionbarcompat-and-io-2013-app-source.html "Older Post")

## Google developers blog

[Google Developers Blog](https://developers.googleblog.com)

## Connect

[![Android Developers Site](https://developer.android.com/static/images/logos/android.svg)](https://developer.android.com/ "Android Developers Site")Android Developers
[![Android Developers on YouTube](https://www.gstatic.com/images/icons/material/system/2x/video_youtube_grey600_24dp.png)](https://www.youtube.com/user/androiddevelopers "Android Developers on YouTube")
[![Android Developers on LinkedIn](https://www.pagetraffic.com/blog/wp-content/uploads/2022/09/linkedin-black-white-logo.png)](https://www.linkedin.com/showcase/androiddev/ "Android Developers on LinkedIn")
[![Android Developers on Medium](data:image/png;base64...)](https://medium.com/androiddevelopers "Android Developers on Medium")
[![Follow Android Developers on X](https://developers.google.com/static/homepage-assets/images/x.svg)](https://x.com/androiddev "Follow Android Developers on X")

[![Google Play Site](https://developer.android.com/static/images/logos/google-play.svg)](https://developer.android.com/distribute/ "Google Play Site")Google Play
[![Google Play Apps & Games on LinkedIn](https://www.pagetraffic.com/blog/wp-content/uploads/2022/09/linkedin-black-white-logo.png)](https://www.linkedin.com/company/googleplaybiz/ "Google Play Apps & Games on LinkedIn")
[![Google Play Apps & Games on Medium](data:image/png;base64...)](https://medium.com/googleplaydev "Google Play Apps & Games on Medium")
[![Follow GooglePlayBiz on X](https://developers.google.com/static/homepage-assets/images/x.svg)](https://x.com/GooglePlayBiz "Follow GooglePlaydBiz on X")

## Subscribe

[![](https://www.gstatic.com/images/icons/material/system/1x/rss_feed_grey600_24dp.png)
## Feed](https://android-developers.blogspot.com/atom.xml "Subscribe to our feed")
[![](https://www.gstatic.com/images/icons/material/system/2x/news_grey600_24dp.png)
## Newsletter](https://developer.android.com/newsletter/index.html)

[* Privacy](https://policies.google.com/privacy)
|
[* License](https://developer.android.com/license)
|
[* Brand guidelines](https://developer.android.com/distribute/marketing-tools/brand-guidelines)
[Get news and tips by email](https://developer.android.com/newsletter/#subscribe)



=== Content from marc.info_8df5aa36_20250125_161958.html ===

```
[[prev in list](?l=openssl-dev&m=130277267303586&w=2)] [[next in list](?l=openssl-dev&m=130298304903422&w=2)] [prev in thread] [[next in thread](?l=openssl-dev&m=130298304903422&w=2)]
List:       [openssl-dev](?l=openssl-dev&r=1&w=2)
Subject:    [recycled pids causes PRNG to repeat](?t=130289823800003&r=1&w=2)
From:       [Eric Wong <normalperson () yhbt ! net>](?a=103533689100003&r=1&w=2)
Date:       [2011-04-15 19:59:06](?l=openssl-dev&r=1&w=2&b=201104)
Message-ID: [20110415195906.GA29353 () dcvr ! yhbt ! net](?i=20110415195906.GA29353%20()%20dcvr%20!%20yhbt%20!%20net)
[Download RAW [message](?l=openssl-dev&m=130289811108150&q=mbox) or [body](?l=openssl-dev&m=130289811108150&q=raw)]

Hello,

I'm not very knowledgeable about OpenSSL internals, but it appears
RAND_bytes() is seeded with the pid of each process, and since pids get
recycled, it's possible for two processes sharing a common parent to get
the same random sequence over time if the common parent used the PRNG.

This could arguably be a bug in every program using fork() + RAND_*()
and they could use pthread_atfork() to call RAND_cleanup(), but I think
OpenSSL should deal with it internally to make life easier for
application authors :)

I have a trivial test program to illustrate the issue.  It's been
tested with 0.9.8e-12.el5_4.6 on CentOS and 0.9.8g-15+lenny11 and
1.0.0d-2 on Debian.

also downloadable here: <http://yhbt.net/test_openssl_prng_fork.c>
-------------------------------- 8< ------------------------------
/*
 * test program to demonstrate recycled PIDs can cause the PRNG to
 * generate the same byte sequence.  This should output 2 identical
 * lines after running for a while.
 */
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>
#include <openssl/rand.h>

static void dump_random(void)
{
	int i;
	unsigned char buf[[4]](#4);

	RAND_bytes(buf, sizeof(buf));
	printf("pid=%d ", getpid());
	for (i = 0; i < sizeof(buf); i++)
		printf("\\x%02x", buf[i]);
	puts("");
}

int main(void)
{
	pid_t pid, xpid;

	/* PRNG needs to be initialized in original process to reproduce */
	RAND_bytes((unsigned char *)&pid, sizeof(pid));

	pid = fork();
	if (pid == 0) {
		dump_random();
		return 0;
	} else if (pid > 0) {
		wait(NULL);

		do {
			xpid = fork();
			if (xpid == 0) {
				if (getpid() == pid)
					dump_random();
				return 0;
			} else if (xpid > 0) {
				wait(NULL);
			} else {
				perror("fork");
			}
		} while (pid != xpid);
	} else {
		perror("fork");
		return 1;
	}

	return 0;
}
--
Eric Wong
______________________________________________________________________
OpenSSL Project                                 <http://www.openssl.org>
Development Mailing List                       openssl-dev@openssl.org
Automated List Manager                           majordomo@openssl.org
[[prev in list](?l=openssl-dev&m=130277267303586&w=2)] [[next in list](?l=openssl-dev&m=130298304903422&w=2)] [prev in thread] [[next in thread](?l=openssl-dev&m=130298304903422&w=2)]

```

[Configure](?q=configure) |
[About](?q=about) |
[News](?q=news) |
Add a list |
Sponsored by [KoreLogic](http://www.korelogic.com/)



=== Content from www.reddit.com_69d69054_20250125_162001.html ===

[Skip to main content](#main-content)

### We value your privacy

Reddit and its partners use cookies and similar technologies to provide you with a better experience. By accepting all cookies, you agree to our use of cookies to deliver and maintain our services and site, improve the quality of Reddit, personalize Reddit content and advertising, and measure the effectiveness of advertising. By rejecting non-essential cookies, Reddit may still use certain cookies to ensure the proper functionality of our platform.
For more information, please see our
[Cookie Notice](https://reddit.com/en-us/policies/cookies)
and our
[Privacy Policy](https://reddit.com/en-us/policies/privacy-policy).

Open menu

Open navigation
Go to Reddit Home

r/Android

A chip

A close button

Get App

Get the Reddit app

[Log In](https://www.reddit.com/login/)Log in to Reddit

Expand user menu
Open settings menu

close

# Don’t miss a thing from Reddit!

I agree to get emails about cool stuff on Reddit

Continue

close

# Log In

By continuing, you agree to our
[User Agreement](https://www.redditinc.com/policies/user-agreement)
and acknowledge that you understand the
[Privacy Policy](https://www.redditinc.com/policies/privacy-policy).

Continue with phone number

---

OR

---

Email or username

Password

Forgot password?

New to Reddit?
Sign Up

Log In

back

# Enter the 6-digit code from your authenticator app

You’ve set up two-factor authentication for this account.

Verification code

Lost access to your authenticator?
Use a backup code

Check code

back

# Enter a 6-digit backup code

You’ve set up two-factor authentication for this account.

Backup code

Don’t have access to your backup code?
Use a code from an authenticator app

Check code

close

# Sign Up

By continuing, you agree to our
[User Agreement](https://www.redditinc.com/policies/user-agreement)
and acknowledge that you understand the
[Privacy Policy](https://www.redditinc.com/policies/privacy-policy).

I agree to get emails about cool stuff on Reddit

Email

Already a redditor?
Log In

Continue

back

Skip

# Verify your email

Enter the 6-digit code we sent to

Verification code

Didn't get an email?
Resend

Continue

back

# Create your username and password

Reddit is anonymous, so your username is what you’ll go by here. Choose wisely—because once you get a name, you can’t change it.

Username

Password

Continue

close

# Sign Up

By continuing, you agree to our
[User Agreement](https://www.redditinc.com/policies/user-agreement)
and acknowledge that you understand the
[Privacy Policy](https://www.redditinc.com/policies/privacy-policy).

I agree to get emails about cool stuff on Reddit

Continue with phone number

---

OR

---

Email

Already a redditor?
Log In

Continue

back

Skip

# Verify your email

Enter the 6-digit code we sent to

Verification code

Didn't get an email?
Resend

Continue

back

# Create your username and password

Reddit is anonymous, so your username is what you’ll go by here. Choose wisely—because once you get a name, you can’t change it.

Username

Password

Continue

close

back

# Reset your password

Enter your email address or username and we’ll send you a link to reset your password

Email or username

[Need help?](https://reddithelp.com/hc/sections/360008917491-Account-Security)

Reset password

close

back

# Check your inbox

An email with a link to reset your password was sent to the email address associated with your account

Didn't get an email?

Resend

close

# Choose a Reddit account to continue

back

close

# Reset your password

New password

Confirm new password

Resetting your password will log you out on all devices.

Continue


