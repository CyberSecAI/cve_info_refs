=== Content from www.python.org_1e1707c6_20250126_104042.html ===

Following system colour scheme

Selected dark colour scheme

Selected light colour scheme

# Python Enhancement Proposals

* [Python](https://www.python.org/ "The Python Programming Language") »
* [PEP Index](../pep-0000/) »
* PEP 456

Toggle light / dark / auto colour theme

# PEP 456 – Secure and interchangeable hash algorithm

Author:
Christian Heimes <christian at python.org>
BDFL-Delegate:
Alyssa Coghlan
Status:
Final
Type:
Standards Track
Created:
27-Sep-2013
Python-Version:
3.4
Post-History:
06-Oct-2013, 14-Nov-2013, 20-Nov-2013
Resolution:
[Python-Dev message](https://mail.python.org/pipermail/python-dev/2013-November/130400.html)

---

Table of Contents

* [Abstract](#abstract)
* [Rationale](#rationale)
* [Requirements for a hash function](#requirements-for-a-hash-function)
* [Current implementation with modified FNV](#current-implementation-with-modified-fnv)
* [Examined hashing algorithms](#examined-hashing-algorithms)
  + [SipHash](#siphash)
  + [MurmurHash](#murmurhash)
  + [CityHash](#cityhash)
  + [DJBX33A](#djbx33a)
  + [Other](#other)
  + [Conclusion](#conclusion)
* [Small string optimization](#small-string-optimization)
* [C API additions](#c-api-additions)
  + [hash secret](#hash-secret)
  + [hash function definition](#hash-function-definition)
  + [autoconf](#autoconf)
  + [hash function selection](#hash-function-selection)
* [Python API addition](#python-api-addition)
  + [sys module](#sys-module)
* [Necessary modifications to C code](#necessary-modifications-to-c-code)
  + [\_Py\_HashBytes() (Objects/object.c)](#py-hashbytes-objects-object-c)
  + [bytes\_hash() (Objects/bytesobject.c)](#bytes-hash-objects-bytesobject-c)
  + [memory\_hash() (Objects/memoryobject.c)](#memory-hash-objects-memoryobject-c)
  + [unicode\_hash() (Objects/unicodeobject.c)](#unicode-hash-objects-unicodeobject-c)
  + [generic\_hash() (Modules/\_datetimemodule.c)](#generic-hash-modules-datetimemodule-c)
* [Performance](#performance)
  + [Hash value distribution](#hash-value-distribution)
  + [Typical length](#typical-length)
  + [Grand Unified Python Benchmark Suite](#grand-unified-python-benchmark-suite)
* [Backwards Compatibility](#backwards-compatibility)
* [Alternative counter measures against hash collision DoS](#alternative-counter-measures-against-hash-collision-dos)
* [Discussion](#discussion)
  + [Pluggable](#pluggable)
  + [Non-aligned memory access](#non-aligned-memory-access)
  + [ASCII str / bytes hash collision](#ascii-str-bytes-hash-collision)
* [References](#references)
* [Copyright](#copyright)

## [Abstract](#abstract)

This PEP proposes SipHash as default string and bytes hash algorithm to properly
fix hash randomization once and for all. It also proposes modifications to
Python’s C code in order to unify the hash code and to make it easily
interchangeable.

## [Rationale](#rationale)

Despite the last attempt [[issue13703]](#issue13703) CPython is still vulnerable to hash
collision DoS attacks [[29c3]](#c3) [[issue14621]](#issue14621). The current hash algorithm and
its randomization is not resilient against attacks. Only a proper
cryptographic hash function prevents the extraction of secret randomization
keys. Although no practical attack against a Python-based service has been
seen yet, the weakness has to be fixed. Jean-Philippe Aumasson and Daniel
J. Bernstein have already shown how the seed for the current implementation
can be recovered [[poc]](#poc).

Furthermore, the current hash algorithm is hard-coded and implemented multiple
times for bytes and three different Unicode representations UCS1, UCS2 and
UCS4. This makes it impossible for embedders to replace it with a different
implementation without patching and recompiling large parts of the interpreter.
Embedders may want to choose a more suitable hash function.

Finally the current implementation code does not perform well. In the common
case it only processes one or two bytes per cycle. On a modern 64-bit processor
the code can easily be adjusted to deal with eight bytes at once.

This PEP proposes three major changes to the hash code for strings and bytes:

* SipHash [[sip]](#sip) is introduced as default hash algorithm. It is fast and small
  despite its cryptographic properties. Due to the fact that it was designed
  by well known security and crypto experts, it is safe to assume that its
  secure for the near future.
* The existing FNV code is kept for platforms without a 64-bit data type. The
  algorithm is optimized to process larger chunks per cycle.
* Calculation of the hash of strings and bytes is moved into a single API
  function instead of multiple specialized implementations in
  `Objects/object.c` and `Objects/unicodeobject.c`. The function takes a
  void pointer plus length and returns the hash for it.
* The algorithm can be selected at compile time. FNV is guaranteed to exist
  on all platforms. SipHash is available on the majority of modern systems.

## [Requirements for a hash function](#requirements-for-a-hash-function)

* It MUST be able to hash arbitrarily large blocks of memory from 1 byte up
  to the maximum `ssize_t` value.
* It MUST produce at least 32 bits on 32-bit platforms and at least 64 bits
  on 64-bit platforms. (Note: Larger outputs can be compressed with e.g.
  `v ^ (v >> 32)`.)
* It MUST support hashing of unaligned memory in order to support
  hash(memoryview).
* It is highly RECOMMENDED that the length of the input influences the
  outcome, so that `hash(b'\00') != hash(b'\x00\x00')`.

The internal interface code between the hash function and the tp\_hash slots
implements special cases for zero length input and a return value of `-1`.
An input of length `0` is mapped to hash value `0`. The output `-1`
is mapped to `-2`.

## [Current implementation with modified FNV](#current-implementation-with-modified-fnv)

CPython currently uses a variant of the Fowler-Noll-Vo hash function
[[fnv]](#fnv). The variant is has been modified to reduce the amount and cost of hash
collisions for common strings. The first character of the string is added
twice, the first time with a bit shift of 7. The length of the input
string is XOR-ed to the final value. Both deviations from the original FNV
algorithm reduce the amount of hash collisions for short strings.

Recently [[issue13703]](#issue13703) a random prefix and suffix were added as an attempt to
randomize the hash values. In order to protect the hash secret the code still
returns `0` for zero length input.

C code:

```
Py_uhash_t x;
Py_ssize_t len;
/* p is either 1, 2 or 4 byte type */
unsigned char *p;
Py_UCS2 *p;
Py_UCS4 *p;

if (len == 0)
    return 0;
x = (Py_uhash_t) _Py_HashSecret.prefix;
x ^= (Py_uhash_t) *p << 7;
for (i = 0; i < len; i++)
    x = (1000003 * x) ^ (Py_uhash_t) *p++;
x ^= (Py_uhash_t) len;
x ^= (Py_uhash_t) _Py_HashSecret.suffix;
return x;

```

Which roughly translates to Python:

```
def fnv(p):
    if len(p) == 0:
        return 0

    # bit mask, 2**32-1 or 2**64-1
    mask = 2 * sys.maxsize + 1

    x = hashsecret.prefix
    x = (x ^ (ord(p[0]) << 7)) & mask
    for c in p:
        x = ((1000003 * x) ^ ord(c)) & mask
    x = (x ^ len(p)) & mask
    x = (x ^ hashsecret.suffix) & mask

    if x == -1:
        x = -2

    return x

```

FNV is a simple multiply and XOR algorithm with no cryptographic properties.
The randomization was not part of the initial hash code, but was added as
counter measure against hash collision attacks as explained in oCERT-2011-003
[[ocert]](#ocert). Because FNV is not a cryptographic hash algorithm and the dict
implementation is not fortified against side channel analysis, the
randomization secrets can be calculated by a remote attacker. The author of
this PEP strongly believes that the nature of a non-cryptographic hash
function makes it impossible to conceal the secrets.

## [Examined hashing algorithms](#examined-hashing-algorithms)

The author of this PEP has researched several hashing algorithms that are
considered modern, fast and state-of-the-art.

### [SipHash](#siphash)

SipHash [[sip]](#sip) is a cryptographic pseudo random function with a 128-bit seed
and 64-bit output. It was designed by Jean-Philippe Aumasson and Daniel J.
Bernstein as a fast and secure keyed hash algorithm. It’s used by Ruby, Perl,
OpenDNS, Rust, Redis, FreeBSD and more. The C reference implementation has
been released under CC0 license (public domain).

Quote from SipHash’s site:

> SipHash is a family of pseudorandom functions (a.k.a. keyed hash
> functions) optimized for speed on short messages. Target applications
> include network traffic authentication and defense against hash-flooding
> DoS attacks.

siphash24 is the recommend variant with best performance. It uses 2 rounds per
message block and 4 finalization rounds. Besides the reference implementation
several other implementations are available. Some are single-shot functions,
others use a Merkle–Damgård construction-like approach with init, update and
finalize functions. Marek Majkowski C implementation csiphash [[csiphash]](#csiphash)
defines the prototype of the function. (Note: `k` is split up into two
uint64\_t):

```
uint64_t siphash24(const void *src, unsigned long src_sz, const char k[16])

```

SipHash requires a 64-bit data type and is not compatible with pure C89
platforms.

### [MurmurHash](#murmurhash)

MurmurHash [[murmur]](#murmur) is a family of non-cryptographic keyed hash function
developed by Austin Appleby. Murmur3 is the latest and fast variant of
MurmurHash. The C++ reference implementation has been released into public
domain. It features 32- or 128-bit output with a 32-bit seed. (Note: The out
parameter is a buffer with either 1 or 4 bytes.)

Murmur3’s function prototypes are:

```
void MurmurHash3_x86_32(const void *key, int len, uint32_t seed, void *out)

void MurmurHash3_x86_128(const void *key, int len, uint32_t seed, void *out)

void MurmurHash3_x64_128(const void *key, int len, uint32_t seed, void *out)

```

The 128-bit variants requires a 64-bit data type and are not compatible with
pure C89 platforms. The 32-bit variant is fully C89-compatible.

Aumasson, Bernstein and Boßlet have shown [[sip]](#sip) [[ocert-2012-001]](#ocert-2012-001) that
Murmur3 is not resilient against hash collision attacks. Therefore, Murmur3
can no longer be considered as secure algorithm. It still may be an
alternative if hash collision attacks are of no concern.

### [CityHash](#cityhash)

CityHash [[city]](#city) is a family of non-cryptographic hash function developed by
Geoff Pike and Jyrki Alakuijala for Google. The C++ reference implementation
has been released under MIT license. The algorithm is partly based on
MurmurHash and claims to be faster. It supports 64- and 128-bit output with a
128-bit seed as well as 32-bit output without seed.

The relevant function prototype for 64-bit CityHash with 128-bit seed is:

```
uint64 CityHash64WithSeeds(const char *buf, size_t len, uint64 seed0,
                           uint64 seed1)

```

CityHash also offers SSE 4.2 optimizations with CRC32 intrinsic for long
inputs. All variants except CityHash32 require 64-bit data types. CityHash32
uses only 32-bit data types but it doesn’t support seeding.

Like MurmurHash Aumasson, Bernstein and Boßlet have shown [[sip]](#sip) a similar
weakness in CityHash.

### [DJBX33A](#djbx33a)

DJBX33A is a very simple multiplication and addition algorithm by Daniel
J. Bernstein. It is fast and has low setup costs but it’s not secure against
hash collision attacks. Its properties make it a viable choice for small
string hashing optimization.

### [Other](#other)

Crypto algorithms such as HMAC, MD5, SHA-1 or SHA-2 are too slow and have
high setup and finalization costs. For these reasons they are not considered
fit for this purpose. Modern AMD and Intel CPUs have AES-NI (AES instruction
set) [[aes-ni]](#aes-ni) to speed up AES encryption. CMAC with AES-NI might be a viable
option but it’s probably too slow for daily operation. (testing required)

### [Conclusion](#conclusion)

SipHash provides the best combination of speed and security. Developers of
other prominent projects have came to the same conclusion.

## [Small string optimization](#small-string-optimization)

Hash functions like SipHash24 have a costly initialization and finalization
code that can dominate speed of the algorithm for very short strings. On the
other hand, Python calculates the hash value of short strings quite often. A
simple and fast function for especially for hashing of small strings can make
a measurable impact on performance. For example, these measurements were taken
during a run of Python’s regression tests. Additional measurements of other
code have shown a similar distribution.

| bytes | hash() calls | portion |
| --- | --- | --- |
| 1 | 18709 | 0.2% |
| 2 | 737480 | 9.5% |
| 3 | 636178 | 17.6% |
| 4 | 1518313 | 36.7% |
| 5 | 643022 | 44.9% |
| 6 | 770478 | 54.6% |
| 7 | 525150 | 61.2% |
| 8 | 304873 | 65.1% |
| 9 | 297272 | 68.8% |
| 10 | 68191 | 69.7% |
| 11 | 1388484 | 87.2% |
| 12 | 480786 | 93.3% |
| 13 | 52730 | 93.9% |
| 14 | 65309 | 94.8% |
| 15 | 44245 | 95.3% |
| 16 | 85643 | 96.4% |
| Total | 7921678 |  |

However a fast function like DJBX33A is not as secure as SipHash24. A cutoff
at about 5 to 7 bytes should provide a decent safety margin and speed up at
the same time. The PEP’s reference implementation provides such a cutoff with
`Py_HASH_CUTOFF`. The optimization is disabled by default for several
reasons. For one the security implications are unclear yet and should be
thoroughly studied before the optimization is enabled by default. Secondly
the performance benefits vary. On 64 bit Linux system with Intel Core i7
multiple runs of Python’s benchmark suite [[pybench]](#pybench) show an average speedups
between 3% and 5% for benchmarks such as django\_v2, mako and etree with a
cutoff of 7. Benchmarks with X86 binaries and Windows X86\_64 builds on the
same machine are a bit slower with small string optimization.

The state of small string optimization will be assessed during the beta phase
of Python 3.4. The feature will either be enabled with appropriate values
or the code will be removed before beta 2 is released.

## [C API additions](#c-api-additions)

All C API extension modifications are not part of the stable API.

### [hash secret](#hash-secret)

The `_Py_HashSecret_t` type of Python 2.6 to 3.3 has two members with either
32- or 64-bit length each. SipHash requires two 64-bit unsigned integers as
keys. The typedef will be changed to a union with a guaranteed size of 24
bytes on all architectures. The union provides a 128 bit random key for
SipHash24 and FNV as well as an additional value of 64 bit for the optional
small string optimization and pyexpat seed. The additional 64 bit seed ensures
that pyexpat or small string optimization cannot reveal bits of the SipHash24
seed.

memory layout on 64 bit systems:

```
cccccccc cccccccc cccccccc  uc -- unsigned char[24]
pppppppp ssssssss ........  fnv -- two Py_hash_t
k0k0k0k0 k1k1k1k1 ........  siphash -- two PY_UINT64_T
........ ........ ssssssss  djbx33a -- 16 bytes padding + one Py_hash_t
........ ........ eeeeeeee  pyexpat XML hash salt

```

memory layout on 32 bit systems:

```
cccccccc cccccccc cccccccc  uc -- unsigned char[24]
ppppssss ........ ........  fnv -- two Py_hash_t
k0k0k0k0 k1k1k1k1 ........  siphash -- two PY_UINT64_T (if available)
........ ........ ssss....  djbx33a -- 16 bytes padding + one Py_hash_t
........ ........ eeee....  pyexpat XML hash salt

```

new type definition:

```
typedef union {
    /* ensure 24 bytes */
    unsigned char uc[24];
    /* two Py_hash_t for FNV */
    struct {
        Py_hash_t prefix;
        Py_hash_t suffix;
    } fnv;
#ifdef PY_UINT64_T
    /* two uint64 for SipHash24 */
    struct {
        PY_UINT64_T k0;
        PY_UINT64_T k1;
    } siphash;
#endif
    /* a different (!) Py_hash_t for small string optimization */
    struct {
        unsigned char padding[16];
        Py_hash_t suffix;
    } djbx33a;
    struct {
        unsigned char padding[16];
        Py_hash_t hashsalt;
    } expat;
} _Py_HashSecret_t;
PyAPI_DATA(_Py_HashSecret_t) _Py_HashSecret;

```

`_Py_HashSecret_t` is initialized in `Python/random.c:_PyRandom_Init()`
exactly once at startup.

### [hash function definition](#hash-function-definition)

Implementation:

```
typedef struct {
    /* function pointer to hash function, e.g. fnv or siphash24 */
    Py_hash_t (*const hash)(const void *, Py_ssize_t);
    const char *name;       /* name of the hash algorithm and variant */
    const int hash_bits;    /* internal size of hash value */
    const int seed_bits;    /* size of seed input */
} PyHash_FuncDef;

PyAPI_FUNC(PyHash_FuncDef*) PyHash_GetFuncDef(void);

```

### [autoconf](#autoconf)

A new test is added to the configure script. The test sets
`HAVE_ALIGNED_REQUIRED`, when it detects a platform, that requires aligned
memory access for integers. Must current platforms such as X86, X86\_64 and
modern ARM don’t need aligned data.

A new option `--with-hash-algorithm` enables the user to select a hash
algorithm in the configure step.

### [hash function selection](#hash-function-selection)

The value of the macro `Py_HASH_ALGORITHM` defines which hash algorithm is
used internally. It may be set to any of the three values `Py_HASH_SIPHASH24`,
`Py_HASH_FNV` or `Py_HASH_EXTERNAL`. If `Py_HASH_ALGORITHM` is not
defined at all, then the best available algorithm is selected. On platforms
which don’t require aligned memory access (`HAVE_ALIGNED_REQUIRED` not
defined) and an unsigned 64 bit integer type `PY_UINT64_T`, SipHash24 is
used. On strict C89 platforms without a 64 bit data type, or architectures such
as SPARC, FNV is selected as fallback. A hash algorithm can be selected with
an autoconf option, for example `./configure --with-hash-algorithm=fnv`.

The value `Py_HASH_EXTERNAL` allows 3rd parties to provide their own
implementation at compile time.

Implementation:

```
#if Py_HASH_ALGORITHM == Py_HASH_EXTERNAL
extern PyHash_FuncDef PyHash_Func;
#elif Py_HASH_ALGORITHM == Py_HASH_SIPHASH24
static PyHash_FuncDef PyHash_Func = {siphash24, "siphash24", 64, 128};
#elif Py_HASH_ALGORITHM == Py_HASH_FNV
static PyHash_FuncDef PyHash_Func = {fnv, "fnv", 8 * sizeof(Py_hash_t),
                                     16 * sizeof(Py_hash_t)};
#endif

```

## [Python API addition](#python-api-addition)

### [sys module](#sys-module)

The sys module already has a hash\_info struct sequence. More fields are added
to the object to reflect the active hash algorithm and its properties.

```
sys.hash_info(width=64,
              modulus=2305843009213693951,
              inf=314159,
              nan=0,
              imag=1000003,
              # new fields:
              algorithm='siphash24',
              hash_bits=64,
              seed_bits=128,
              cutoff=0)

```

## [Necessary modifications to C code](#necessary-modifications-to-c-code)

### [\_Py\_HashBytes() (Objects/object.c)](#py-hashbytes-objects-object-c)

`_Py_HashBytes` is an internal helper function that provides the hashing
code for bytes, memoryview and datetime classes. It currently implements FNV
for `unsigned char *`.

The function is moved to Python/pyhash.c and modified to use the hash function
through PyHash\_Func.hash(). The function signature is altered to take
a `const void *` as first argument. `_Py_HashBytes` also takes care of
special cases: it maps zero length input to `0` and return value of `-1`
to `-2`.

### [bytes\_hash() (Objects/bytesobject.c)](#bytes-hash-objects-bytesobject-c)

`bytes_hash` uses `_Py_HashBytes` to provide the tp\_hash slot function
for bytes objects. The function will continue to use `_Py_HashBytes`
but without a type cast.

### [memory\_hash() (Objects/memoryobject.c)](#memory-hash-objects-memoryobject-c)

`memory_hash` provides the tp\_hash slot function for read-only memory
views if the original object is hashable, too. It’s the only function that
has to support hashing of unaligned memory segments in the future. The
function will continue to use `_Py_HashBytes` but without a type cast.

### [unicode\_hash() (Objects/unicodeobject.c)](#unicode-hash-objects-unicodeobject-c)

`unicode_hash` provides the tp\_hash slot function for unicode. Right now it
implements the FNV algorithm three times for `unsigned char*`, `Py_UCS2`
and `Py_UCS4`. A reimplementation of the function must take care to use the
correct length. Since the macro `PyUnicode_GET_LENGTH` returns the length
of the unicode string and not its size in octets, the length must be
multiplied with the size of the internal unicode kind:

```
if (PyUnicode_READY(u) == -1)
    return -1;
x = _Py_HashBytes(PyUnicode_DATA(u),
                  PyUnicode_GET_LENGTH(u) * PyUnicode_KIND(u));

```

### [generic\_hash() (Modules/\_datetimemodule.c)](#generic-hash-modules-datetimemodule-c)

`generic_hash` acts as a wrapper around `_Py_HashBytes` for the tp\_hash
slots of date, time and datetime types. timedelta objects are hashed by their
state (days, seconds, microseconds) and tzinfo objects are not hashable. The
data members of date, time and datetime types’ struct are not `void*` aligned.
This can easily by fixed with memcpy()ing four to ten bytes to an aligned
buffer.

## [Performance](#performance)

In general the [PEP 456](../pep-0456/ "PEP 456 – Secure and interchangeable hash algorithm") code with SipHash24 is about as fast as the old code
with FNV. SipHash24 seems to make better use of modern compilers, CPUs and
large L1 cache. Several benchmarks show a small speed improvement on 64 bit
CPUs such as Intel Core i5 and Intel Core i7 processes. 32 bit builds and
benchmarks on older CPUs such as an AMD Athlon X2 are slightly slower with
SipHash24. The performance increase or decrease are so small that they should
not affect any application code.

The benchmarks were conducted on CPython default branch revision b08868fd5994
and the PEP repository [[pep-456-repos]](#pep-456-repos). All upstream changes were merged
into the `pep-456` branch. The “performance” CPU governor was configured and
almost all programs were stopped so the benchmarks were able to utilize
TurboBoost and the CPU caches as much as possible. The raw benchmark results
of multiple machines and platforms are made available at [[benchmarks]](#benchmarks).

### [Hash value distribution](#hash-value-distribution)

A good distribution of hash values is important for dict and set performance.
Both SipHash24 and FNV take the length of the input into account, so that
strings made up entirely of NULL bytes don’t have the same hash value. The
last bytes of the input tend to affect the least significant bits of the hash
value, too. That attribute reduces the amount of hash collisions for strings
with a common prefix.

### [Typical length](#typical-length)

Serhiy Storchaka has shown in [[issue16427]](#issue16427) that a modified FNV
implementation with 64 bits per cycle is able to process long strings several
times faster than the current FNV implementation.

However, according to statistics [[issue19183]](#issue19183) a typical Python program as
well as the Python test suite have a hash ratio of about 50% small strings
between 1 and 6 bytes. Only 5% of the strings are larger than 16 bytes.

### [Grand Unified Python Benchmark Suite](#grand-unified-python-benchmark-suite)

Initial tests with an experimental implementation and the Grand Unified Python
Benchmark Suite have shown minimal deviations. The summarized total runtime
of the benchmark is within 1% of the runtime of an unmodified Python 3.4
binary. The tests were run on an Intel i7-2860QM machine with a 64-bit Linux
installation. The interpreter was compiled with GCC 4.7 for 64- and 32-bit.

More benchmarks will be conducted.

## [Backwards Compatibility](#backwards-compatibility)

The modifications don’t alter any existing API.

The output of `hash()` for strings and bytes are going to be different. The
hash values for ASCII Unicode and ASCII bytes will stay equal.

## [Alternative counter measures against hash collision DoS](#alternative-counter-measures-against-hash-collision-dos)

Three alternative countermeasures against hash collisions were discussed in
the past, but are not subject of this PEP.

1. Marc-Andre Lemburg has suggested that dicts shall count hash collisions. In
   case an insert operation causes too many collisions an exception shall be
   raised.
2. Some applications (e.g. PHP) limit the amount of keys for GET and POST
   HTTP requests. The approach effectively leverages the impact of a hash
   collision attack. (XXX citation needed)
3. Hash maps have a worst case of O(n) for insertion and lookup of keys. This
   results in a quadratic runtime during a hash collision attack. The
   introduction of a new and additional data structure with O(log n)
   worst case behavior would eliminate the root cause. A data structures like
   red-black-tree or prefix trees (trie [[trie]](#trie)) would have other benefits,
   too. Prefix trees with stringed keyed can reduce memory usage as common
   prefixes are stored within the tree structure.

## [Discussion](#discussion)

### [Pluggable](#pluggable)

The first draft of this PEP made the hash algorithm pluggable at runtime. It
supported multiple hash algorithms in one binary to give the user the
possibility to select a hash algorithm at startup. The approach was considered
an unnecessary complication by several core committers [[pluggable]](#id26). Subsequent
versions of the PEP aim for compile time configuration.

### [Non-aligned memory access](#non-aligned-memory-access)

The implementation of SipHash24 were criticized because it ignores the issue
of non-aligned memory and therefore doesn’t work on architectures that
requires alignment of integer types. The PEP deliberately neglects this
special case and doesn’t support SipHash24 on such platforms. It’s simply
not considered worth the trouble until proven otherwise. All major platforms
like X86, X86\_64 and ARMv6+ can handle unaligned memory with minimal or even
no speed impact. [[alignmentmyth]](#alignmentmyth)

Almost every block is properly aligned anyway. At present bytes’ and str’s
data are always aligned. Only memoryviews can point to unaligned blocks
under rare circumstances. The PEP implementation is optimized and simplified
for the common case.

### [ASCII str / bytes hash collision](#ascii-str-bytes-hash-collision)

Since the implementation of [PEP 393](../pep-0393/ "PEP 393 – Flexible String Representation"), bytes and ASCII text have the same
memory layout. Because of this the new hashing API will keep the invariant:

```
hash("ascii string") == hash(b"ascii string")

```

for ASCII string and ASCII bytes. Equal hash values result in a hash collision
and therefore cause a minor speed penalty for dicts and sets with mixed keys.
The cause of the collision could be removed by e.g. subtracting `2` from
the hash value of bytes. `-2` because `hash(b"") == 0` and `-1` is
reserved. The PEP doesn’t change the hash value.

## [References](#references)

* Issue 19183 [[issue19183]](#issue19183) contains a reference implementation.

[[29c3](#id2)]
<http://events.ccc.de/congress/2012/Fahrplan/events/5152.en.html>
[[fnv](#id6)]
<http://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function>
[sip] *([1](#id5), [2](#id9), [3](#id12), [4](#id15))*
<https://131002.net/siphash/>
[[ocert](#id8)]
<http://www.nruns.com/_downloads/advisory28122011.pdf>
[[ocert-2012-001](#id13)]
<http://www.ocert.org/advisories/ocert-2012-001.html>
[[poc](#id4)]
<https://131002.net/siphash/poc.py>
[issue13703] *([1](#id1), [2](#id7))*
<http://bugs.python.org/issue13703>
[[issue14621](#id3)]
<http://bugs.python.org/issue14621>
[[issue16427](#id20)]
<http://bugs.python.org/issue16427>
[issue19183] *([1](#id21), [2](#id25))*
<http://bugs.python.org/issue19183>
[[trie](#id22)]
<http://en.wikipedia.org/wiki/Trie>
[[city](#id14)]
<http://code.google.com/p/cityhash/>
[[murmur](#id11)]
<http://code.google.com/p/smhasher/>
[[csiphash](#id10)]
<https://github.com/majek/csiphash/>
[[aes-ni](#id16)]
<http://en.wikipedia.org/wiki/AES_instruction_set>
[[pluggable](#id23)]
<https://mail.python.org/pipermail/python-dev/2013-October/129138.html>
[[alignmentmyth](#id24)]
<http://lemire.me/blog/archives/2012/05/31/data-alignment-for-speed-myth-or-reality/>
[[pybench](#id17)]
<http://hg.python.org/benchmarks/>
[[benchmarks](#id19)]
<https://bitbucket.org/tiran/pep-456-benchmarks/src>
[[pep-456-repos](#id18)]
<http://hg.python.org/features/pep-456>

## [Copyright](#copyright)

This document has been placed in the public domain.

---

Source: <https://github.com/python/peps/blob/main/peps/pep-0456.rst>

Last modified: [2023-10-11 12:05:51 GMT](https://github.com/python/peps/commits/main/peps/pep-0456.rst)

## Contents

* [Abstract](#abstract)
* [Rationale](#rationale)
* [Requirements for a hash function](#requirements-for-a-hash-function)
* [Current implementation with modified FNV](#current-implementation-with-modified-fnv)
* [Examined hashing algorithms](#examined-hashing-algorithms)
  + [SipHash](#siphash)
  + [MurmurHash](#murmurhash)
  + [CityHash](#cityhash)
  + [DJBX33A](#djbx33a)
  + [Other](#other)
  + [Conclusion](#conclusion)
* [Small string optimization](#small-string-optimization)
* [C API additions](#c-api-additions)
  + [hash secret](#hash-secret)
  + [hash function definition](#hash-function-definition)
  + [autoconf](#autoconf)
  + [hash function selection](#hash-function-selection)
* [Python API addition](#python-api-addition)
  + [sys module](#sys-module)
* [Necessary modifications to C code](#necessary-modifications-to-c-code)
  + [\_Py\_HashBytes() (Objects/object.c)](#py-hashbytes-objects-object-c)
  + [bytes\_hash() (Objects/bytesobject.c)](#bytes-hash-objects-bytesobject-c)
  + [memory\_hash() (Objects/memoryobject.c)](#memory-hash-objects-memoryobject-c)
  + [unicode\_hash() (Objects/unicodeobject.c)](#unicode-hash-objects-unicodeobject-c)
  + [generic\_hash() (Modules/\_datetimemodule.c)](#generic-hash-modules-datetimemodule-c)
* [Performance](#performance)
  + [Hash value distribution](#hash-value-distribution)
  + [Typical length](#typical-length)
  + [Grand Unified Python Benchmark Suite](#grand-unified-python-benchmark-suite)
* [Backwards Compatibility](#backwards-compatibility)
* [Alternative counter measures against hash collision DoS](#alternative-counter-measures-against-hash-collision-dos)
* [Discussion](#discussion)
  + [Pluggable](#pluggable)
  + [Non-aligned memory access](#non-aligned-memory-access)
  + [ASCII str / bytes hash collision](#ascii-str-bytes-hash-collision)
* [References](#references)
* [Copyright](#copyright)

[Page Source (GitHub)](https://github.com/python/peps/blob/main/peps/pep-0456.rst)



=== Content from www.openwall.com_acd30df6_20250125_173734.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Hash Suite - Windows password security audit tool. GUI, reports in PDF.](https://hashsuite.openwall.net) | | --- | |
| --- | --- |

[[<prev]](2) [[next>]](4) [[thread-next>]](13) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <52A552CB.10808@redhat.com>
Date: Mon, 09 Dec 2013 15:19:07 +1000
From: Nick Coghlan <ncoghlan@...hat.com>
To: oss-security@...ts.openwall.com
Subject: CPython hash secret can be recoved remotely

Software: CPython
Vendor: Python Software Foundation
Vulnerability: remote target-specific CPU usage DOS

This is a followup to CVE-2012-1150 (hash table collision CPU usage DOS
in CPython)

<http://bugs.python.org/issue14621> points out that the hash secret in
CPython can be recovered remotely, so while the original fix addressed
the "blind DOS" problem (of being able to DOS any Python based service
with a single prepared payload), it didn't completely eliminate the
potential for remote DOS attacks based on hash collisions.
(<http://bugs.python.org/issue14621#msg173455> has the details)

Python 3.4+ will use SipHash by default
(<http://www.python.org/dev/peps/pep-0456>), which should resolve the
vulnerability completely.

Regards,
Nick.

--
Nick Coghlan
Red Hat Hosted & Shared Services
Software Engineering & Development, Brisbane

Testing Solutions Team Lead
Beaker Development Lead (<http://beaker-project.org/>)

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from support.apple.com_3776f211_20250125_173734.html ===


* [Apple](https://www.apple.com/)
* + [Store](https://www.apple.com/us/shop/goto/store)
  + [Mac](https://www.apple.com/mac/)
  + [iPad](https://www.apple.com/ipad/)
  + [iPhone](https://www.apple.com/iphone/)
  + [Watch](https://www.apple.com/watch/)
  + [Vision](https://www.apple.com/apple-vision-pro/)
  + [AirPods](https://www.apple.com/airpods/)
  + [TV & Home](https://www.apple.com/tv-home/)
  + [Entertainment](https://www.apple.com/entertainment/)
  + [Accessories](https://www.apple.com/us/shop/goto/buy_accessories)
  + [Support](https://support.apple.com/?cid=gn-ols-home-hp-tab)
* 0+

# About the security content of OS X Yosemite v10.10.5 and Security Update 2015-006

This document describes the security content of OS X Yosemite v10.10.5 and Security Update 2015-006.

For the protection of our customers, Apple does not disclose, discuss, or confirm security issues until a full investigation has occurred and any necessary patches or releases are available. To learn more about Apple Product Security, see the [Apple Product Security](https://www.apple.com/support/security/) website.

For information about the Apple Product Security PGP Key, see [How to use the Apple Product Security PGP Key](https://support.apple.com/kb/HT201601).

Where possible, [CVE IDs](http://cve.mitre.org/about/) are used to reference the vulnerabilities for further information.

To learn about other security updates, see [Apple security updates](https://support.apple.com/kb/HT201222).

## OS X Yosemite v10.10.5 and Security Update 2015-006

* **apache**

  Available for: OS X Mavericks v10.9.5, OS X Yosemite v10.10 to v10.10.4

  Impact: Multiple vulnerabilities existed in Apache 2.4.16, the most serious of which may allow a remote attacker to cause a denial of service.

  Description: Multiple vulnerabilities existed in Apache versions prior to 2.4.16. These were addressed by updating Apache to version 2.4.16.

  CVE-ID

  CVE-2014-3581

  CVE-2014-3583

  CVE-2014-8109

  CVE-2015-0228

  CVE-2015-0253

  CVE-2015-3183

  CVE-2015-3185

* **apache\_mod\_php**

  Available for: OS X Mavericks v10.9.5, OS X Yosemite v10.10 to v10.10.4

  Impact: Multiple vulnerabilities existed in PHP 5.5.20, the most serious of which may lead to arbitrary code execution.

  Description: Multiple vulnerabilities existed in PHP versions prior to 5.5.20. These were addressed by updating Apache to version 5.5.27.

  CVE-ID

  CVE-2015-2783

  CVE-2015-2787

  CVE-2015-3307

  CVE-2015-3329

  CVE-2015-3330

  CVE-2015-4021

  CVE-2015-4022

  CVE-2015-4024

  CVE-2015-4025

  CVE-2015-4026

  CVE-2015-4147

  CVE-2015-4148

* **Apple ID OD Plug-in**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A malicious application may be able change the password of a local user

  Description: In some circumstances, a state management issue existed in password authentication. The issue was addressed through improved state management.

  CVE-ID

  CVE-2015-3799 : an anonymous researcher working with HP's Zero Day Initiative

* **AppleGraphicsControl**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A malicious application may be able to determine kernel memory layout

  Description: An issue existed in AppleGraphicsControl which could have led to the disclosure of kernel memory layout. This issue was addressed through improved bounds checking.

  CVE-ID

  CVE-2015-5768 : JieTao Yang of KeenTeam

* **Bluetooth**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A local user may be able to execute arbitrary code with system privileges

  Description: A memory corruption issue existed in IOBluetoothHCIController. This issue was addressed through improved memory handling.

  CVE-ID

  CVE-2015-3779 : Teddy Reed of Facebook Security

* **Bluetooth**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A malicious application may be able to determine kernel memory layout

  Description: A memory management issue could have led to the disclosure of kernel memory layout. This issue was addressed with improved memory management.

  CVE-ID

  CVE-2015-3780 : Roberto Paleari and Aristide Fattori of Emaze Networks

* **Bluetooth**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A malicious app may be able to access notifications from other iCloud devices

  Description: An issue existed where a malicious app could access a Bluetooth-paired Mac or iOS device's Notification Center notifications via the Apple Notification Center Service. The issue affected devices using Handoff and logged into the same iCloud account. This issue was resolved by revoking access to the Apple Notification Center Service.

  CVE-ID

  CVE-2015-3786 : Xiaolong Bai (Tsinghua University), Luyi Xing (System Security Lab of Indiana University), Tongxin Li (Peking University), XiaoFeng Wang (Indiana University)

* **Bluetooth**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: An attacker with privileged network position may be able to perform denial of service attack using malformed Bluetooth packets

  Description: An input validation issue existed in parsing of Bluetooth ACL packets. This issue was addressed through improved input validation.

  CVE-ID

  CVE-2015-3787 : moony li of Trend Micro

* **Bluetooth**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A local attacker may be able to cause unexpected application termination or arbitrary code execution

  Description: Multiple buffer overflow issues existed in blued's handling of XPC messages. These issues were addressed through improved bounds checking.

  CVE-ID

  CVE-2015-3777 : mitp0sh of [PDX]

* **bootp**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: An attacker may be able to determine Wi-Fi networks a device has previously accessed

  Description: Upon connecting to a Wi-Fi network, MAC addresses of previously accessed networks may have been broadcast. This issue was addressed by broadcasting only MAC addresses associated with the current SSID.

  CVE-ID

  CVE-2015-3778 : Piers O'Hanlon of Oxford Internet Institute, University of Oxford (on the EPSRC Being There project)

* **CloudKit**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A malicious application may be able to access the iCloud user record of a previously signed in user

  Description: A state inconsistency existed in CloudKit when signing out users. This issue was addressed through improved state handling.

  CVE-ID

  CVE-2015-3782 : Deepkanwal Plaha of University of Toronto

* **CoreMedia Playback**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Viewing a maliciously crafted movie file may lead to an unexpected application termination or arbitrary code execution

  Description: Memory corruption issues existed in CoreMedia Playback. These were addressed through improved memory handling.

  CVE-ID

  CVE-2015-5777 : Apple

  CVE-2015-5778 : Apple

* **CoreText**

  Available for: OS X Mountain Lion v10.8.5, OS X Mavericks v10.9.5, OS X Yosemite v10.10 to v10.10.4

  Impact: Processing a maliciously crafted font file may lead to an unexpected application termination or arbitrary code execution

  Description: A memory corruption issue existed in the processing of font files. This issue was addressed through improved input validation.

  CVE-ID

  CVE-2015-5761 : John Villamil (@day6reak), Yahoo Pentest Team

* **CoreText**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Processing a maliciously crafted font file may lead to an unexpected application termination or arbitrary code execution

  Description: A memory corruption issue existed in the processing of font files. This issue was addressed through improved input validation.

  CVE-ID

  CVE-2015-5755 : John Villamil (@day6reak), Yahoo Pentest Team

* **curl**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Multiple vulnerabilities in cURL and libcurl prior to 7.38.0, one of which may allow remote attackers to bypass the Same Origin Policy.

  Description: Multiple vulnerabilities existed in cURL and libcurl prior to 7.38.0. These issues were addressed by updating cURL to version 7.43.0.

  CVE-ID

  CVE-2014-3613

  CVE-2014-3620

  CVE-2014-3707

  CVE-2014-8150

  CVE-2014-8151

  CVE-2015-3143

  CVE-2015-3144

  CVE-2015-3145

  CVE-2015-3148

  CVE-2015-3153

* **Data Detectors Engine**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Processing a sequence of unicode characters can lead to an unexpected application termination or arbitrary code execution

  Description: Memory corruption issues existed in processing of Unicode characters. These issues were addressed through improved memory handling.

  CVE-ID

  CVE-2015-5750 : M1x7e1 of Safeye Team (www.safeye.org)

* **Date & Time pref pane**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Applications that rely on system time may have unexpected behavior

  Description: An authorization issue existed when modifying the system date and time preferences. This issue was addressed with additional authorization checks.

  CVE-ID

  CVE-2015-3757 : Mark S C Smith

* **Dictionary Application**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: An attacker with a privileged network position may be able to intercept users' Dictionary app queries

  Description: An issue existed in the Dictionary app, which did not properly secure user communications. This issue was addressed by moving Dictionary queries to HTTPS.

  CVE-ID

  CVE-2015-3774 : Jeffrey Paul of EEQJ, Jan Bee of the Google Security Team

* **DiskImages**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Processing a maliciously crafted DMG file may lead to an unexpected application termination or arbitrary code execution with system privileges

  Description: A memory corruption issue existed in parsing of malformed DMG images. This issue was addressed through improved memory handling.

  CVE-ID

  CVE-2015-3800 : Frank Graziano of the Yahoo Pentest Team

* **dyld**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A local user may be able to execute arbitrary code with system privileges

  Description: A path validation issue existed in dyld. This was addressed through improved environment sanitization.

  CVE-ID

  CVE-2015-3760 : beist of grayhash, Stefan Esser

* **FontParser**

  Available for: OS X Mountain Lion v10.8.5, OS X Mavericks v10.9.5, OS X Yosemite v10.10 to v10.10.4

  Impact: Processing a maliciously crafted font file may lead to an unexpected application termination or arbitrary code execution

  Description: A memory corruption issue existed in the processing of font files. This issue was addressed through improved input validation.

  CVE-ID

  CVE-2015-3804 : Apple

  CVE-2015-5775 : Apple

* **FontParser**

  Available for: OS X Mountain Lion v10.8.5, OS X Mavericks v10.9.5, OS X Yosemite v10.10 to v10.10.4

  Impact: Processing a maliciously crafted font file may lead to an unexpected application termination or arbitrary code execution

  Description: A memory corruption issue existed in the processing of font files. This issue was addressed through improved input validation.

  CVE-ID

  CVE-2015-5756 : John Villamil (@day6reak), Yahoo Pentest Team

* **groff**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Multiple issues in pdfroff

  Description: Multiple issues existed in pdfroff, the most serious of which may allow arbitrary filesystem modification. These issues were addressed by removing pdfroff.

  CVE-ID

  CVE-2009-5044

  CVE-2009-5078

* **ImageIO**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Processing a maliciously crafted TIFF image may lead to an unexpected application termination or arbitrary code execution

  Description: A memory corruption issue existed in the processing of TIFF images. This issue was addressed through improved bounds checking.

  CVE-ID

  CVE-2015-5758 : Apple

* **ImageIO**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Visiting a maliciously crafted website may result in the disclosure of process memory

  Description: An uninitialized memory access issue existed in ImageIO's handling of PNG and TIFF images. Visiting a malicious website may result in sending data from process memory to the website. This issue is addressed through improved memory initialization and additional validation of PNG and TIFF images.

  CVE-ID

  CVE-2015-5781 : Michal Zalewski

  CVE-2015-5782 : Michal Zalewski

* **Install Framework Legacy**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A malicious application may be able to execute arbitrary code with root privileges

  Description: An issue existed in how Install.framework's 'runner' binary dropped privileges. This issue was addressed through improved privilege management.

  CVE-ID

  CVE-2015-5784 : Ian Beer of Google Project Zero

* **Install Framework Legacy**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A malicious application may be able to execute arbitrary code with system privileges

  Description: A race condition existed in Install.framework's 'runner' binary that resulted in privileges being incorrectly dropped. This issue was addressed through improved object locking.

  CVE-ID

  CVE-2015-5754 : Ian Beer of Google Project Zero

* **IOFireWireFamily**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A local user may be able to execute arbitrary code with system privileges

  Description: Memory corruption issues existed in IOFireWireFamily. These issues were addressed through additional type input validation.

  CVE-ID

  CVE-2015-3769 : Ilja van Sprundel

  CVE-2015-3771 : Ilja van Sprundel

  CVE-2015-3772 : Ilja van Sprundel

* **IOGraphics**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A malicious application may be able to execute arbitrary code with system privileges

  Description: A memory corruption issue existed in IOGraphics. This issue was addressed through additional type input validation.

  CVE-ID

  CVE-2015-3770 : Ilja van Sprundel

  CVE-2015-5783 : Ilja van Sprundel

* **IOHIDFamily**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A local user may be able to execute arbitrary code with system privileges

  Description: A buffer overflow issue existed in IOHIDFamily. This issue was addressed through improved memory handling.

  CVE-ID

  CVE-2015-5774 : TaiG Jailbreak Team

* **Kernel**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A malicious application may be able to determine kernel memory layout

  Description: An issue existed in the mach\_port\_space\_info interface, which could have led to the disclosure of kernel memory layout. This was addressed by disabling the mach\_port\_space\_info interface.

  CVE-ID

  CVE-2015-3766 : Cererdlong of Alibaba Mobile Security Team, @PanguTeam

* **Kernel**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A malicious application may be able to execute arbitrary code with system privileges

  Description: An integer overflow existed in the handling of IOKit functions. This issue was addressed through improved validation of IOKit API arguments.

  CVE-ID

  CVE-2015-3768 : Ilja van Sprundel

* **Kernel**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A local user may be able to cause a system denial of service

  Description: A resource exhaustion issue existed in the fasttrap driver. This was addressed through improved memory handling.

  CVE-ID

  CVE-2015-5747 : The Brainy Code Scanner (m00nbsd)

* **Kernel**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A local user may be able to cause a system denial of service

  Description: A validation issue existed in the mounting of HFS volumes. This was addressed by adding additional checks.

  CVE-ID

  CVE-2015-5748 : Maxime Villard of m00nbsd

* **Kernel**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A malicious application may be able to execute unsigned code

  Description: An issue existed that allowed unsigned code to be appended to signed code in a specially crafted executable file. This issue was addressed through improved code signature validation.

  CVE-ID

  CVE-2015-3806 : TaiG Jailbreak Team

* **Kernel**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A specially crafted executable file could allow unsigned, malicious code to execute

  Description: An issue existed in the way multi-architecture executable files were evaluated that could have allowed unsigned code to be executed. This issue was addressed through improved validation of executable files.

  CVE-ID

  CVE-2015-3803 : TaiG Jailbreak Team

* **Kernel**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A local user may be able to execute unsigned code

  Description: A validation issue existed in the handling of Mach-O files. This was addressed by adding additional checks.

  CVE-ID

  CVE-2015-3802 : TaiG Jailbreak Team

  CVE-2015-3805 : TaiG Jailbreak Team

* **Kernel**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Parsing a maliciously crafted plist may lead to an unexpected application termination or arbitrary code execution with system privileges

  Description: A memory corruption existed in processing of malformed plists. This issue was addressed through improved memory handling.

  CVE-ID

  CVE-2015-3776 : Teddy Reed of Facebook Security, Patrick Stein (@jollyjinx) of Jinx Germany

* **Kernel**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A local user may be able to execute arbitrary code with system privileges

  Description: A path validation issue existed. This was addressed through improved environment sanitization.

  CVE-ID

  CVE-2015-3761 : beist of grayish

* **Libc**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Processing a maliciously crafted regular expression may lead to an unexpected application termination or arbitrary code execution

  Description: Memory corruption issues existed in the TRE library. These were addressed through improved memory handling.

  CVE-ID

  CVE-2015-3796 : Ian Beer of Google Project Zero

  CVE-2015-3797 : Ian Beer of Google Project Zero

  CVE-2015-3798 : Ian Beer of Google Project Zero

* **Libinfo**

  Available for: OS X Mountain Lion v10.8.5, OS X Mavericks v10.9.5, OS X Yosemite v10.10 to v10.10.4

  Impact: A remote attacker may be able to cause unexpected application termination or arbitrary code execution

  Description: Memory corruption issues existed in handling AF\_INET6 sockets. These were addressed by improved memory handling.

  CVE-ID

  CVE-2015-5776 : Apple

* **libpthread**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A malicious application may be able to execute arbitrary code with system privileges

  Description: A memory corruption issue existed in handling syscalls. This issue was addressed through improved lock state checking.

  CVE-ID

  CVE-2015-5757 : Lufeng Li of Qihoo 360

* **libxml2**

  Available for: OS X Mountain Lion v10.8.5, OS X Mavericks v10.9.5, OS X Yosemite v10.10 to v10.10.4

  Impact: Multiple vulnerabilities existed in libxml2 versions prior to 2.9.2, the most serious of which may allow a remote attacker to cause a denial of service

  Description: Multiple vulnerabilities existed in libxml2 versions prior to 2.9.2. These were addressed by updating libxml2 to version 2.9.2.

  CVE-ID

  CVE-2014-0191 : Felix Groebert of Google

* **libxml2**

  Available for: OS X Mavericks v10.9.5, OS X Yosemite v10.10 to v10.10.4

  Impact: Parsing a maliciously crafted XML document may lead to disclosure of user information

  Description: A memory access issue existed in libxml2. This was addressed by improved memory handling

  CVE-ID

  CVE-2014-3660 : Felix Groebert of Google

* **libxml2**

  Available for: OS X Mountain Lion v10.8.5, OS X Mavericks v10.9.5, OS X Yosemite v10.10 to v10.10.4

  Impact: Parsing a maliciously crafted XML document may lead to disclosure of user information

  Description: A memory corruption issue existed in parsing of XML files. This issue was addressed through improved memory handling.

  CVE-ID

  CVE-2015-3807 : Apple

* **libxpc**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A malicious application may be able to execute arbitrary code with system privileges

  Description: A memory corruption issue existed in handling of malformed XPC messages. This issue was improved through improved bounds checking.

  CVE-ID

  CVE-2015-3795 : Mathew Rowley

* **mail\_cmds**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A local user may be able to execute arbitrary shell commands

  Description: A validation issue existed in the mailx parsing of email addresses. This was addressed by improved sanitization.

  CVE-ID

  CVE-2014-7844

* **Notification Center OSX**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A malicious application may be able to access all notifications previously displayed to users

  Description: An issue existed in Notification Center, which did not properly delete user notifications. This issue was addressed by correctly deleting notifications dismissed by users.

  CVE-ID

  CVE-2015-3764 : Jonathan Zdziarski

* **ntfs**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A local user may be able to execute arbitrary code with system privileges

  Description: A memory corruption issue existed in NTFS. This issue was addressed through improved memory handling.

  CVE-ID

  CVE-2015-5763 : Roberto Paleari and Aristide Fattori of Emaze Networks

* **OpenSSH**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Remote attackers may be able to circumvent a time delay for failed login attempts and conduct brute-force attacks

  Description: An issue existed when processing keyboard-interactive devices. This issue was addressed through improved authentication request validation.

  CVE-ID

  CVE-2015-5600

* **OpenSSL**

  Available for: OS X Mountain Lion v10.8.5, OS X Mavericks v10.9.5, OS X Yosemite v10.10 to v10.10.4

  Impact: Multiple vulnerabilities existed in OpenSSL versions prior to 0.9.8zg, the most serious of which may allow a remote attacker to cause a denial of service.

  Description: Multiple vulnerabilities existed in OpenSSL versions prior to 0.9.8zg. These were addressed by updating OpenSSL to version 0.9.8zg.

  CVE-ID

  CVE-2015-1788

  CVE-2015-1789

  CVE-2015-1790

  CVE-2015-1791

  CVE-2015-1792

* **perl**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Parsing a maliciously crafted regular expression may lead to disclosure of unexpected application termination or arbitrary code execution

  Description: An integer underflow issue existed in the way Perl parsed regular expressions. This issue was addressed through improved memory handling.

  CVE-ID

  CVE-2013-7422

* **PostgreSQL**

  Available for: OS X Mountain Lion v10.8.5, OS X Mavericks v10.9.5, OS X Yosemite v10.10 to v10.10.4

  Impact: An attacker may be able to cause unexpected application termination or gain access to data without proper authentication

  Description: Multiple issues existed in PostgreSQL 9.2.4. These issues were addressed by updating PostgreSQL to 9.2.13.

  CVE-ID

  CVE-2014-0067

  CVE-2014-8161

  CVE-2015-0241

  CVE-2015-0242

  CVE-2015-0243

  CVE-2015-0244

* **python**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Multiple vulnerabilities existed in Python 2.7.6, the most serious of which may lead to arbitrary code execution

  Description: Multiple vulnerabilities existed in Python versions prior to 2.7.6. These were addressed by updating Python to version 2.7.10.

  CVE-ID

  CVE-2013-7040

  CVE-2013-7338

  CVE-2014-1912

  CVE-2014-7185

  CVE-2014-9365

* **QL Office**

  Available for: OS X Mountain Lion v10.8.5, OS X Mavericks v10.9.5, OS X Yosemite v10.10 to v10.10.4

  Impact: Parsing a maliciously crafted Office document may lead to an unexpected application termination or arbitrary code execution

  Description: A memory corruption issue existed in parsing of Office documents. This issue was addressed through improved memory handling.

  CVE-ID

  CVE-2015-5773 : Apple

* **QL Office**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Parsing a maliciously crafted XML file may lead to disclosure of user information

  Description: An external entity reference issue existed in XML file parsing. This issue was addressed through improved parsing.

  CVE-ID

  CVE-2015-3784 : Bruno Morisson of INTEGRITY S.A.

* **Quartz Composer Framework**

  Available for: OS X Mountain Lion v10.8.5, OS X Mavericks v10.9.5, OS X Yosemite v10.10 to v10.10.4

  Impact: Parsing a maliciously crafted QuickTime file may lead to an unexpected application termination or arbitrary code execution

  Description: A memory corruption issue existed in parsing of QuickTime files. This issue was addressed through improved memory handling.

  CVE-ID

  CVE-2015-5771 : Apple

* **Quick Look**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Searching for a previously viewed website may launch the web browser and render that website

  Description: An issue existed where QuickLook had the capability to execute JavaScript. The issue was addressed by disallowing execution of JavaScript.

  CVE-ID

  CVE-2015-3781 : Andrew Pouliot of Facebook, Anto Loyola of Qubole

* **QuickTime 7**

  Available for: OS X Mountain Lion v10.8.5, OS X Mavericks v10.9.5, OS X Yosemite v10.10 to v10.10.4

  Impact: Processing a maliciously crafted file may lead to an unexpected application termination or arbitrary code execution

  Description: Multiple memory corruption issues existed in QuickTime. These issues were addressed through improved memory handling.

  CVE-ID

  CVE-2015-3779

  CVE-2015-5753 : Apple

  CVE-2015-5779 : Apple

* **QuickTime 7**

  Available for: OS X Mountain Lion v10.8.5, OS X Mavericks v10.9.5, OS X Yosemite v10.10 to v10.10.4

  Impact: Processing a maliciously crafted file may lead to an unexpected application termination or arbitrary code execution

  Description: Multiple memory corruption issues existed in QuickTime. These issues were addressed through improved memory handling.

  CVE-ID

  CVE-2015-3765 : Joe Burnett of Audio Poison

  CVE-2015-3788 : Ryan Pentney and Richard Johnson of Cisco Talos

  CVE-2015-3789 : Ryan Pentney and Richard Johnson of Cisco Talos

  CVE-2015-3790 : Ryan Pentney and Richard Johnson of Cisco Talos

  CVE-2015-3791 : Ryan Pentney and Richard Johnson of Cisco Talos

  CVE-2015-3792 : Ryan Pentney and Richard Johnson of Cisco Talos

  CVE-2015-5751 : WalkerFuz

* **SceneKit**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Viewing a maliciously crafted Collada file may lead to arbitrary code execution

  Description: A heap buffer overflow existed in SceneKit's handling of Collada files. This issue was addressed through improved input validation.

  CVE-ID

  CVE-2015-5772 : Apple

* **SceneKit**

  Available for: OS X Mountain Lion v10.8.5, OS X Mavericks v10.9.5, OS X Yosemite v10.10 to v10.10.4

  Impact: A remote attacker may be able to cause unexpected application termination or arbitrary code execution

  Description: A memory corruption issue existed in SceneKit. This issue was addressed through improved memory handling.

  CVE-ID

  CVE-2015-3783 : Haris Andrianakis of Google Security Team

* **Security**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A standard user may be able to gain access to admin privileges without proper authentication

  Description: An issue existed in handling of user authentication. This issue was addressed through improved authentication checks.

  CVE-ID

  CVE-2015-3775 : [Eldon Ahrold]

* **SMBClient**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: A remote attacker may be able to cause unexpected application termination or arbitrary code execution

  Description: A memory corruption issue existed in the SMB client. This issue was addressed through improved memory handling.

  CVE-ID

  CVE-2015-3773 : Ilja van Sprundel

* **Speech UI**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Parsing a maliciously crafted unicode string with speech alerts enabled may lead to an unexpected application termination or arbitrary code execution

  Description: A memory corruption issue existed in handling of Unicode strings. This issue was addressed by improved memory handling.

  CVE-ID

  CVE-2015-3794 : Adam Greenbaum of Refinitive

* **sudo**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Multiple vulnerabilities existed in sudo versions prior to 1.7.10p9, the most serious of which may allow an attacker access to arbitrary files

  Description: Multiple vulnerabilities existed in sudo versions prior to 1.7.10p9. These were addressed by updating sudo to version 1.7.10p9.

  CVE-ID

  CVE-2013-1775

  CVE-2013-1776

  CVE-2013-2776

  CVE-2013-2777

  CVE-2014-0106

  CVE-2014-9680

* **tcpdump**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Multiple vulnerabilities existed in tcpdump 4.7.3, the most serious of which may allow a remote attacker to cause a denial of service.

  Description: Multiple vulnerabilities existed in tcpdump versions prior to 4.7.3. These were addressed by updating tcpdump to version 4.7.3.

  CVE-ID

  CVE-2014-8767

  CVE-2014-8769

  CVE-2014-9140

* **Text Formats**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Parsing a maliciously crafted text file may lead to disclosure of user information

  Description: An XML external entity reference issue existed with TextEdit parsing. This issue was addressed through improved parsing.

  CVE-ID

  CVE-2015-3762 : Xiaoyong Wu of the Evernote Security Team

* **udf**

  Available for: OS X Yosemite v10.10 to v10.10.4

  Impact: Processing a maliciously crafted DMG file may lead to an unexpected application termination or arbitrary code execution with system privileges

  Description: A memory corruption issue existed in parsing of malformed DMG images. This issue was addressed through improved memory handling.

  CVE-ID

  CVE-2015-3767 : beist of grayhash

OS X Yosemite v10.10.5 includes the security content of [Safari 8.0.8](https://support.apple.com/kb/HT205033).

Information about products not manufactured by Apple, or independent websites not controlled or tested by Apple, is provided without recommendation or endorsement. Apple assumes no responsibility with regard to the selection, performance, or use of third-party websites or products. Apple makes no representations regarding third-party website accuracy or reliability. [Contact the vendor](https://support.apple.com/103190) for additional information.

Published Date: November 03, 2023

Helpful?

Yes

No

Character limit:
250

Maximum character limit is 250.

Please don’t include any personal information in your comment.
Submit

Thanks for your feedback.

## Apple Footer

[
Apple](https://www.apple.com)

1. [Support](https://support.apple.com)
2. About the security content of OS X Yosemite v10.10.5 and Security Update 2015-006

[United States](https://support.apple.com/en-us/103491/localeselector "Choose your country or region")

Copyright © 2025 Apple Inc. All rights reserved.
 [Privacy Policy](https://www.apple.com/legal/privacy/en-ww/) [Terms of Use](https://www.apple.com/legal/internet-services/terms/site.html) [Sales and Refunds](https://www.apple.com/shop/goto/help/sales_refunds) [Site Map](https://www.apple.com/sitemap/)



=== Content from www.openwall.com_d6fa3ecb_20250125_173733.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Follow @Openwall on Twitter for new release announcements and other news](https://twitter.com/openwall) | | --- | |
| --- | --- |

[[<prev]](12) [[next>]](14) [[<thread-prev]](3) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-Id: <201312092341.rB9NfQ6j028967@linus.mitre.org>
Date: Mon, 9 Dec 2013 18:41:26 -0500 (EST)
From: cve-assign@...re.org
To: ncoghlan@...hat.com
Cc: cve-assign@...re.org, oss-security@...ts.openwall.com
Subject: Re: CPython hash secret can be recoved remotely

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

> This is a followup to CVE-2012-1150 (hash table collision CPU usage DOS
> in CPython)
>
> <http://bugs.python.org/issue14621> points out that the hash secret in
> CPython can be recovered remotely, so while the original fix addressed
> the "blind DOS" problem (of being able to DOS any Python based service
> with a single prepared payload), it didn't completely eliminate the
> potential for remote DOS attacks based on hash collisions.
> (<http://bugs.python.org/issue14621#msg173455> has the details)
>
> Python 3.4+ will use SipHash by default
> (<http://www.python.org/dev/peps/pep-0456>), which should resolve the
> vulnerability completely.

Use CVE-2013-7040.

- --
CVE assignment team, MITRE CVE Numbering Authority
M/S M300
202 Burlington Road, Bedford, MA 01730 USA
[ PGP key available through <http://cve.mitre.org/cve/request_id.html> ]
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.14 (SunOS)

iQEcBAEBAgAGBQJSplDSAAoJEKllVAevmvmsnusH+wZ4KrZq+VgroTsISAbCqcCH
2KVHnCwsVsbfpdFP8J4TLrRKfueFR53lqgGAi5TbMV9LbT7PYmp3PhVnepjG0h9c
1hbcBNnOcex6Nv/t0gEzOpoW7mMAJ5NkkrLa5zQdqpAox5Oa0G5WJWCgUIrCXhsd
xaAJtXC72rWH2iDqvZB8gxVnMAjhbcM+QB5RYHymBh647yTWEm/wY2tuSWGZmmM2
68cof3jY+L0f/UbhpVGKrRKFPVnfqD2TQTwJCYkC0bsAgYf/MVLi7Tw7K0ihi4x0
w5Epxc5dOiN/im1JJq/bnQZmt+JXbenQdKYhnyw1PlHQwG/yJj/8Pboqpu53SGY=
=F0rN
-----END PGP SIGNATURE-----

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from bugs.python.org_661bde4d_20250125_173731.html ===

# [homepage](.)

open

all

* [Python Home](https://www.python.org/ "Go to the Python homepage")
* [About](https://www.python.org/about/ "About The Python Language")
* [News](https://www.python.org/blogs/)
* [Documentation](https://www.python.org/doc/)
* [Downloads](https://www.python.org/downloads/)
* [Community](https://www.python.org/community/)
* [Foundation](https://www.python.org/psf/ "Python Software Foundation")
* [Developer's Guide](https://devguide.python.org/ "Python Developer's Guide")
* [Issue Tracker](. "Python Issue Tracker")
  + **Issues**
    - [Search](issue?@template=search&status=1)
    - [Random Issue](issue?@action=random)
  + **Summaries**
    - [Issues with patch](issue?status=1&@sort=-activity&@columns=id%2Cgithub%2Cactivity%2Ctitle%2Ccreator%2Cstatus&@dispname=Issues%20with%20patch&@startwith=0&@group=priority&keywords=2&@action=search&@filter=&@pagesize=50)
    - [Easy issues](issue?status=1&@sort=-activity&@columns=id%2Cgithub%2Cactivity%2Ctitle%2Ccreator%2Cstatus&@dispname=Easy%20issues&@startwith=0&@group=priority&keywords=6&@action=search&@filter=&@pagesize=50)
    - [Stats](issue?@template=stats)
  + **User**
    - Login

      Remember me?
    - [Lost your login?](user?@template=forgotten)
  + **Administration**
    - [User List](user?@sort=username)
    - [Committer List](user?iscommitter=1&@action=search&@sort=username&@pagesize=300)
  + **Help**
    - [Tracker Documentation](http://docs.python.org/devguide/triaging.html)
    - [Tracker Development](http://wiki.python.org/moin/TrackerDevelopment)
    - [Report Tracker Problem](https://github.com/python/psf-infra-meta/issues)

Issue14621

![](@@file/python-logo-small.png)
➜
[![](@@file/gh-icon.png)](https://github.com/python/cpython/issues)

This issue tracker **has been migrated to [GitHub](https://github.com/python/cpython/issues)**,
and is currently **read-only**.

For more information, [see the GitHub FAQs in the Python's Developer Guide.](https://devguide.python.org/gh-faq/ "GitHub FAQs")

[![](@@file/gh-icon.png)

This issue has been migrated to GitHub:
https://github.com/python/cpython/issues/58826](https://github.com/python/cpython/issues/58826)

classification

| [Title](http://docs.python.org/devguide/triaging.html#title): | Hash function is not randomized properly | | |
| --- | --- | --- | --- |
| [Type](http://docs.python.org/devguide/triaging.html#type): | security | [Stage](http://docs.python.org/devguide/triaging.html#stage): | resolved |
| [Components](http://docs.python.org/devguide/triaging.html#components): |  | [Versions](http://docs.python.org/devguide/triaging.html#versions): | Python 3.3, Python 2.7 |

process

| [Status](http://docs.python.org/devguide/triaging.html#status): | closed | [Resolution](http://docs.python.org/devguide/triaging.html#resolution): | fixed |
| --- | --- | --- | --- |
| [Dependencies](http://docs.python.org/devguide/triaging.html#dependencies): |  | [Superseder](http://docs.python.org/devguide/triaging.html#superseder): |  |
| [Assigned To](http://docs.python.org/devguide/triaging.html#assigned-to): | christian.heimes | [Nosy List](http://docs.python.org/devguide/triaging.html#nosy-list): | Arfrever, Bob.Ziuchkovski, Giovanni.Bajo, PaulMcMillan, ReneSac, Vlado.Boza, alex, arigo, benjamin.peterson, bkabrda, camara, christian.heimes, cvrebert, dmalcolm, dstufft, editor-buzzfeed, gregory.p.smith, iElectric, isoschiz, koniiiik, lemburg, mark.dickinson, ncoghlan, pconnell, sbermeister, serhiy.storchaka, vstinner, Łukasz.Rekucki |
| [Priority](http://docs.python.org/devguide/triaging.html#priority): | normal | [Keywords](http://docs.python.org/devguide/triaging.html#keywords): | patch |

Created on **2012-04-19 17:58** by **Vlado.Boza**, last changed **2022-04-11 14:57** by **admin**. This issue is now **closed**.

| Files | | | | |
| --- | --- | --- | --- | --- |
| File name | Uploaded | Description | Edit |
| [find\_hash\_collision.py](file25281/find_hash_collision.py) | vstinner, 2012-04-19 23:26 |  |  |
| [hash.py](file25375/hash.py) | vstinner, 2012-04-26 22:58 |  |  |
| [hash-attack-3.patch](file27917/hash-attack-3.patch) | lemburg, 2012-11-07 08:34 |  |  |
| [\_Py\_Hash\_Sip24.S](file27919/_Py_Hash_Sip24.S) | serhiy.storchaka, 2012-11-07 11:51 |  |  |

| Repositories containing patches | | | |
| --- | --- | --- | --- |
| <http://hg.python.org/sandbox/cheimes> |  |  |  |

| Messages (89) | | | |
| --- | --- | --- | --- |
| [msg158736](#msg158736) - [(view)](msg158736) | Author: Vlado Boza (Vlado.Boza) | Date: 2012-04-19 17:58 |
| ``` Fix of this <http://bugs.python.org/issue13703> is broken.  tl;dr: There only 256 different hash functions (compare it to size of _Py_HashSecret prefix and suffix). And whether keys collide or not depends only on the last 8 bits of prefix.   Problem with current randomization of hash function is following: Suffix does not influence whether two keys have some hash or not (it is xor-ed after everything).  Everything except last 8 bits in prefix does not influence it also. Try adding 0x474200 to prefix and see what happens (it will add 0x474200 to resulting hash).   To make a DoS attack, attacker must do the following: Generate sets of colliding keys for every 256 possible combinations of last 8 bits. Try each one of these sets - one will have significantly bigger response time, and then repeat this one. ``` | | | |
| [msg158744](#msg158744) - [(view)](msg158744) | Author: Vlado Boza (Vlado.Boza) | Date: 2012-04-19 20:40 |
| ``` E.g this strings collide for every prefix ending on 0xcd: 0x27fd5a18, 0x26fe78fa ``` | | | |
| [msg158759](#msg158759) - [(view)](msg158759) | Author: Dave Malcolm (dmalcolm) (Python committer) | Date: 2012-04-19 21:31 |
| ``` Thanks for filing this bug report.  I'm not seeing the equal hashes you describe.  I'm using this recipe to hardcode a specific prefix and print the hashes using it: $ gdb --eval-command="break _PyRandom_Init" --eval-command="run" --eval-command="print _Py_HashSecret" --eval-command="set _Py_HashSecret.prefix=0xcdcdcdcd" --eval-command="print _Py_HashSecret" --eval-command="continue" -eval-command="continue" --args python -c "a='\x27\xfd\x5a\x18'; b='\x26\xfe\x78\xfa'; print(hash(a)); print(hash(b))"   On a 32-bit build of Python 2.7.3 (i686), if I set _Py_HashSecret.prefix=0xcdcdcdcd, I get non-equal hashes for the data you specify (output trimmed somewhat for conciseness):    $1 = {prefix = 0, suffix = 0}   $2 = {prefix = -842150451, suffix = 0}   Continuing.   -121255142   -1199906326  Similarly, on a 64-bit build of Python 2.7.3 (x86_64), I get non-equal hashes:   $1 = {prefix = 0, suffix = 0}   $2 = {prefix = [3452816845](https://hg.python.org/lookup/3452816845), suffix = 0}   -3992804574342296806   -8147489705433570838  Did I misunderstand the report?  Thanks. ``` | | | |
| [msg158773](#msg158773) - [(view)](msg158773) | Author: STINNER Victor (vstinner) \* (Python committer) | Date: 2012-04-19 23:26 |
| ``` I don't understand this issue: can you write a short script to test a collision?   "E.g this strings collide for every prefix ending on 0xcd"  Do you mean that prefix & 0xff == 0xcd?  "0x27fd5a18, 0x26fe78fa"  Is it a byte string or an Unicode string? b'\x27\xfd\x5a\x18' and b'\x26\xfe\x78\xfa'?  --  Using PYTHONHASHSEED environment variable, it's easy to find two values generating the same _Py_HashSecret. Just one example:  PYTHONHASHSEED=3035016679: * _Py_HashSecret = {0xcd5192eff3fd4d58, 0x3926b1431b200720} PYTHONHASHSEED=4108758503: *  _Py_HashSecret = {0xcd5192eff3fd4d58, 0x3926b1431b200720}  --  I wrote find_hash_collision.py to try to compute a collision, but the programs fail with: --- Fail to generate a new seed! # seeds = 65298 --- So it fails to generate a new random seed after testing 65298 different seeds. I ran the script with a function generating a seed, a seed generate a prefix "ending with 0xDC".  See attached program: it generates a random seed. Uncomment "seed = generate_seed_0xCD()" if the prefix must ends with 0xCD byte. ``` | | | |
| [msg158778](#msg158778) - [(view)](msg158778) | Author: Vlado Boza (Vlado.Boza) | Date: 2012-04-19 23:53 |
| ``` My bad (I checked only function in C++, not result in python). This should work on 32bit: Prefix: anything ending on 0x00 Suffix: anything Strings: "\x00\xcf\x0b\x96\x19", "\x00\x6d\x29\x45\x18" ``` | | | |
| [msg158780](#msg158780) - [(view)](msg158780) | Author: Vlado Boza (Vlado.Boza) | Date: 2012-04-19 23:58 |
| ``` For example take this script (on 32bit): ha = hash("\x00\xcf\x0b\x96\x19") hb = hash("\x00\x6d\x29\x45\x18") if ha == hb:   print "collision"  And run following: for i in `seq 0 25`; do echo $i; for j in `seq 0 100`; do ./python -R x.py; done; done;  It gives collison too many times (around 9 out of 2500). ``` | | | |
| [msg158781](#msg158781) - [(view)](msg158781) | Author: Dave Malcolm (dmalcolm) (Python committer) | Date: 2012-04-19 23:59 |
| ``` $ gdb --eval-command="break _PyRandom_Init" --eval-command="run" --eval-command="print _Py_HashSecret" --eval-command="set _Py_HashSecret.prefix=0xcdcdcd00" --eval-command="print _Py_HashSecret" --eval-command="continue" -eval-command="continue" --args python -c 'a="\x00\xcf\x0b\x96\x19"; b="\x00\x6d\x29\x45\x18"; print(hash(a)); print(hash(b))'  On 32-bit: $1 = {prefix = 0, suffix = 0} $2 = {prefix = -842150656, suffix = 0} [1220138288](https://hg.python.org/lookup/1220138288) [1220138288](https://hg.python.org/lookup/1220138288)  On 64-bit: $1 = {prefix = 0, suffix = 0} $2 = {prefix = [3452816640](https://hg.python.org/lookup/3452816640), suffix = 0} Continuing. 4087671194599937328 -1679444439011306192 ``` | | | |
| [msg158783](#msg158783) - [(view)](msg158783) | Author: STINNER Victor (vstinner) \* (Python committer) | Date: 2012-04-20 00:05 |
| ``` > For example take this script (on 32bit): (...) > It gives collison too many times (around 9 out of 2500).  I tried this script on Linux 32 bits and Linux 64 bits: I didn't see any collision. What is your operating system and the version of your operating system please? ``` | | | |
| [msg158784](#msg158784) - [(view)](msg158784) | Author: Michal Petrucha (koniiiik) | Date: 2012-04-20 00:08 |
| ``` @dmalcolm: As for the gdb example, you need to add --eval-command="set _Py_HashSecret_Initialized=1", otherwise _Py_HashSecret will get overwritten immediately after it is set by gdb, either to 0 if run without the -R switch, or to a random value.  With the fresh pair of values Vlado provided, I managed to reproduce the collisions on Python 2.7.3, i686 (output trimmed like you did):  for __PREFIX in 0x0 0x4700 0xdead00 0xcafe00; do gdb --eval-command="break _PyRandom_Init" --eval-command="run" --eval-command="print _Py_HashSecret" --eval-command="set _Py_HashSecret.prefix=${__PREFIX}" --eval-command="set _Py_HashSecret_Initialized=1" --eval-command="print _Py_HashSecret" --eval-command="continue" -eval-command="continue" --args ./python -c "a='\x00\xcf\x0b\x96\x19'; b='\x00\x6d\x29\x45\x18'; print(hash(a)); print(hash(b))"; done  $1 = {prefix = 0, suffix = 0} $2 = {prefix = 0, suffix = 0} Continuing. [1220138288](https://hg.python.org/lookup/1220138288) [1220138288](https://hg.python.org/lookup/1220138288)   $1 = {prefix = 0, suffix = 0} $2 = {prefix = 18176, suffix = 0} Continuing. -1483212240 -1483212240   $1 = {prefix = 0, suffix = 0} $2 = {prefix = 14593280, suffix = 0} Continuing. -972665808 -972665808   $1 = {prefix = 0, suffix = 0} $2 = {prefix = 13303296, suffix = 0} Continuing. [1003122480](https://hg.python.org/lookup/1003122480) [1003122480](https://hg.python.org/lookup/1003122480) ``` | | | |
| [msg158785](#msg158785) - [(view)](msg158785) | Author: Vlado Boza (Vlado.Boza) | Date: 2012-04-20 00:21 |
| ``` >I tried this script on Linux 32 bits and Linux 64 bits: I didn't see any >collision. What is your operating system and the version of your >operating system please?  uname -a Linux 3.0.0-17-generic #30-Ubuntu SMP Thu Mar 8 20:45:39 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux   Anyway you should be able to do following (in 32bits): - generate two colliding keys (with some random seed) - try these keys with different random seeds and they will collide ~1 out of 256 times ``` | | | |
| [msg158790](#msg158790) - [(view)](msg158790) | Author: STINNER Victor (vstinner) \* (Python committer) | Date: 2012-04-20 00:43 |
| ``` hash.py: Python implementation of the 32-bit version of hash(bytes). Ok, I now see that only the lower 8 bits are really mixed with the input string. ``` | | | |
| [msg158860](#msg158860) - [(view)](msg158860) | Author: Vlado Boza (Vlado.Boza) | Date: 2012-04-20 17:44 |
| ``` One possible fix: Look for StringHasher in google v8 code (<http://code.google.com/p/v8/source/search?q=stringhasher&origq=stringhasher&btnG=Search+Trunk>). Main loop looks like this: raw_running_hash_ += c;                                                                        raw_running_hash_ += (raw_running_hash_ << 10);                                                raw_running_hash_ ^= (raw_running_hash_ >> 6);    It seems not to have same collisions with many different hash seeds. ``` | | | |
| [msg159430](#msg159430) - [(view)](msg159430) | Author: STINNER Victor (vstinner) \* (Python committer) | Date: 2012-04-26 22:47 |
| ``` > One possible fix: ... > Main loop looks like this: ..  Well, it was decided to not impact performances to workaround one specific class of attack, whereas there are many other ways to DoS Python. So we chose to keep the main loop unchanged. Randomizing the hash is not a fix for the hash DoS, it only makes the attacker harder. ``` | | | |
| [msg159431](#msg159431) - [(view)](msg159431) | Author: STINNER Victor (vstinner) \* (Python committer) | Date: 2012-04-26 22:58 |
| ``` Oops, I attached the wrong "hash.py" file. ``` | | | |
| [msg159433](#msg159433) - [(view)](msg159433) | Author: Benjamin Peterson (benjamin.peterson) \* (Python committer) | Date: 2012-04-26 23:08 |
| ``` We should see if more security can be gained without sacrificing speed. ``` | | | |
| [msg159434](#msg159434) - [(view)](msg159434) | Author: STINNER Victor (vstinner) \* (Python committer) | Date: 2012-04-26 23:10 |
| ``` > Problem with current randomization of hash function > is following: Suffix does not influence whether two keys > have some hash or not (it is xor-ed after everything).  Yes, the suffix is used to "protect" the secret. Without the suffix, it would be too simple to compute the prefix: getting a single hash value of a known string would leak the prefix.  > Suffix does not influence whether two keys have some hash > or not (...). Everything except last 8 bits in prefix does > not influence it also.  I don't know if we can do better and/or if it is a critical issue. ``` | | | |
| [msg173185](#msg173185) - [(view)](msg173185) | Author: Christian Heimes (christian.heimes) \* (Python committer) | Date: 2012-10-17 16:53 |
| ``` I've modified unicodeobject's unicode_hash() function. V8's algorithm is about 55% slower for a 800 MB ASCII string on my box.  Python's current hash algorithm for bytes and unicode:     while (--len >= 0)         x = (_PyHASH_MULTIPLIER * x) ^ (Py_uhash_t) *P++;  $ ./python -m timeit -s "t = 'abcdefgh' * int(1E8)" "hash(t)" 10 loops, best of 3: 94.1 msec per loop   V8's algorithm:      while (--len >= 0) {         x += (Py_uhash_t) *P++;         x += ((x + (Py_uhash_t)len) << 10);         x ^= (x >> 6);     }  $ ./python -m timeit -s "t = 'abcdefgh' * int(1E8)" "hash(t)" 10 loops, best of 3: 164 msec per loop ``` | | | |
| [msg173455](#msg173455) - [(view)](msg173455) | Author: Armin Rigo (arigo) \* (Python committer) | Date: 2012-10-21 15:28 |
| ``` Just to make it extra clear: Vlado showed that the "-R" switch of Python can easily be made fully pointless, with only a bit of extra work.  Here is how:  * Assume you have an algo that gives you as many strings with colliding hashes as you want, provided you know the last 8 bits of the secret prefix.  * Say you want to attack a web server.  You send it 256 requests, each with 100 strings that have identical hash for one of the 256 possible values.  You measure which one is significantly slower than the others.  * From there you are back in the original situation: you know which of the 256 values to pick, so you can make the web server crawl by sending it a large number of strings that have identical hashes for this particular value.  It's interesting to note how this whole -R discussion made very long threads on python-dev, and python-dev has subsequently ignored (for the past 6 months!) the fact that their "fix" can be worked around in a matter of minutes.  (For information, I'm sure that if the algorithm is improved to depend on all 32 or 64 bits of the prefix, it would still be easy to crack it.  You don't actually need to send 2**32 or 2**64 requests to the web server: with careful design you can send only 32 or 64 requests that each leak one bit of information.  Doing that requires a bit more research, but once the recipe is known, it can be freely reused, which seems to defeat the original point.) ``` | | | |
| [msg173457](#msg173457) - [(view)](msg173457) | Author: Armin Rigo (arigo) \* (Python committer) | Date: 2012-10-21 15:35 |
| ``` For reference, the above means that we can implement -R support for PyPy as a dummy ignored flag, and get "security" that is very close to CPython's.  :-) ``` | | | |
| [msg173458](#msg173458) - [(view)](msg173458) | Author: Benjamin Peterson (benjamin.peterson) \* (Python committer) | Date: 2012-10-21 15:39 |
| ``` That doesn't make it any easy CPython issue. :) ``` | | | |
| [msg173461](#msg173461) - [(view)](msg173461) | Author: Christian Heimes (christian.heimes) \* (Python committer) | Date: 2012-10-21 16:33 |
| ``` As far as my understanding goes the issue can't be solved with our current hash algorithm. We'd have to use a crypto hash function or at least a hash algorithm that has an increased avalanche effect on the outcome. The current hash algorithm is designed and optimized for speed and not for security. Any other algorithm is going to slow down hashing.  Small strings and strings with lots of NUL bytes may leak too many information, too. ``` | | | |
| [msg173488](#msg173488) - [(view)](msg173488) | Author: STINNER Victor (vstinner) \* (Python committer) | Date: 2012-10-21 21:42 |
| ``` > It's interesting to note how this whole -R discussion made very long threads on python-dev, and python-dev has subsequently ignored (for the past 6 months!) the fact that their "fix" can be worked around in a matter of minutes.  No, this issue has no been ignored. Nobody proposed anything to fix this issue, but we are still working on it (sometimes in private).  In my opinion, we cannot solve this issue without slowing down python. Or I don't know yet.a.fast and secure hash algorithm. I don't really want to slow down Python for one specific issue whereas there are so many other ways to DoS a (web) server.  How do other languages (say Perl, Ruby, PHP, Javascript) handle this issue? ``` | | | |
| [msg173491](#msg173491) - [(view)](msg173491) | Author: Serhiy Storchaka (serhiy.storchaka) \* (Python committer) | Date: 2012-10-21 22:46 |
| ``` > $ ./python -m timeit -s "t = 'abcdefgh' * int(1E8)" "hash(t)"  I got another numbers (32-bit Linux, AMD Athlon 64 X2 4600+).  Python's current hash algorithm: 10 loops, best of 3: 343 msec per loop  V8's algorithm: 10 loops, best of 3: 244 msec per loop ``` | | | |
| [msg173498](#msg173498) - [(view)](msg173498) | Author: Marc-Andre Lemburg (lemburg) \* (Python committer) | Date: 2012-10-22 06:48 |
| ``` On 21.10.2012 23:42, STINNER Victor wrote: >  > STINNER Victor added the comment: >  >> It's interesting to note how this whole -R discussion made very long > threads on python-dev, and python-dev has subsequently ignored (for the > past 6 months!) the fact that their "fix" can be worked around in a matter > of minutes. >  > No, this issue has no been ignored. Nobody proposed anything to fix this > issue, but we are still working on it (sometimes in private). >  > In my opinion, we cannot solve this issue without slowing down python. Or I > don't know yet.a.fast and secure hash algorithm. I don't really want to > slow down Python for one specific issue whereas there are so many other > ways to DoS a (web) server.  Well, I did propose a different approach to the whole problem to count collisions. That would have avoided the usability issues you have with the randomization approach, made it possible for the application to detect the attack and not have introduced any significant runtime overhead for applications not being attacked.  The proposal was shot down with the argument that it wouldn't fix the problem.  It should also be noted that the randomization only applies to strings/bytes, dictionaries with other colliding keys are not protected at all.  Perhaps it's time to revisit the collision counting idea ?  It would work in much the same way as the stack recursion limit we have in Python.  --  Marc-Andre Lemburg eGenix.com  Professional Python Services directly from the Source  (#1, Oct 22 2012) >>> Python Projects, Consulting and Support ...   <http://www.egenix.com/> >>> mxODBC.Zope/Plone.Database.Adapter ...       <http://zope.egenix.com/> >>> mxODBC, mxDateTime, mxTextTools ...        <http://python.egenix.com/> ________________________________________________________________________ 2012-09-27: Released eGenix PyRun 1.1.0 ...       <http://egenix.com/go35> 2012-09-26: Released mxODBC.Connect 2.0.1 ...     <http://egenix.com/go34> 2012-09-25: Released mxODBC 3.2.1 ...             <http://egenix.com/go33> 2012-10-23: Python Meeting Duesseldorf ...                      tomorrow     eGenix.com Software, Skills and Services GmbH  Pastor-Loeh-Str.48     D-40764 Langenfeld, Germany. CEO Dipl.-Math. Marc-Andre Lemburg            Registered at Amtsgericht Duesseldorf: HRB 46611                <http://www.egenix.com/company/contact/> ``` | | | |
| [msg174964](#msg174964) - [(view)](msg174964) | Author: Armin Rigo (arigo) \* (Python committer) | Date: 2012-11-06 14:10 |
| ``` Benjamin: oups, sorry.  I don't remember setting the "easy" keyword, my mistake.  Fwiw I'm +1 on Marc-Andre's solution.  Make it a tunable setting, e.g. with sys.setcollisionlimit().  Defaults to sys.maxint on existing Pythons and some smaller value (70?) on new Pythons.  It has the same benefits as the recursion limit: it's theoretically bad, but most of the time very useful.  It would also crash on bad usages of custom __hash__() methods: e.g. if you put a lot of keys in a dict, all with a custom __hash__() that returns 42.  I imagine that it can be considered a good thing to raise in this case rather than silently degrade performance forever. ``` | | | |
| [msg174973](#msg174973) - [(view)](msg174973) | Author: Benjamin Peterson (benjamin.peterson) \* (Python committer) | Date: 2012-11-06 15:04 |
| ``` Here's the message that helped convince us to go against collision counting originally: <http://mail.python.org/pipermail/python-dev/2012-January/115726.html> ``` | | | |
| [msg174986](#msg174986) - [(view)](msg174986) | Author: John M Camara (camara) | Date: 2012-11-06 15:44 |
| ``` How about using a secure hash algorithm that's implemented in HW when available.  It doesn't eliminate the issue on systems that lack this support but at least it limits the scope of the problem.  Of course some testing would need to be done to make sure the hardware hashing doesn't have a significant impact on performance. ``` | | | |
| [msg174987](#msg174987) - [(view)](msg174987) | Author: Christian Heimes (christian.heimes) \* (Python committer) | Date: 2012-11-06 15:54 |
| ``` Our hash randomization will always leak some information about the randomization keys. The only way to properly secure our secrets is a cryptographic secure algorithms, for example a crypto hashing function in combination with a message authentication code like HMAC. I don't have to explain how that is going to hurt performance ...  We can try to make it harder to guess the secret parts with a slightly modified algorithm like e.g. V8's hash but that's never going to be 100% secure. But might be secure enough to make an attack too hard. ``` | | | |
| [msg174989](#msg174989) - [(view)](msg174989) | Author: Christian Heimes (christian.heimes) \* (Python committer) | Date: 2012-11-06 16:08 |
| ``` I deem hash randomization and collision counting as a poor man's workaround for the actual issue. Perhaps we shouldn't try too hard to fix an unsuitable data type. Hash maps have a known worst case complexity of O(n). A O(log n) algorithm should be used to parses and malicious key/value pairs.  How about Python grows a additional btree implementation in its collections module? I know that it's not going to fix existing code. However in the long run it's the best safeguard against hash collision attacks. I'm thinking about a simple, self balancing btree like red-black-tree. A quick search on Wikipedia also revealed Scapegoat and Splay tree with interesting properties. ``` | | | |
| [msg174990](#msg174990) - [(view)](msg174990) | Author: Giovanni Bajo (Giovanni.Bajo) | Date: 2012-11-06 16:29 |
| ``` Christian, there are good semi-crypto hash functions that don't leak as bad as Python's own modified FNV hash, without going all the way to HMAC.  SipHash has very good collision resistance and doesn't leak anything: <https://www.131002.net/siphash/> (notice: they distribute a python program to recover python's seed)  It's obviously slower than Python's FNV, but it's hard to beat a sum+multiplication per character. ``` | | | |
| [msg174994](#msg174994) - [(view)](msg174994) | Author: Christian Heimes (christian.heimes) \* (Python committer) | Date: 2012-11-06 16:49 |
| ``` Thanks!  SipHash looks interesting. It's using a XOR + ROT approach with a seed. And it's written by DJB which is usually a good sign. He writes secure code with good quality. Just his coding style tends to be ... unique. :)  I'm going to try the algorithm. ``` | | | |
| [msg174998](#msg174998) - [(view)](msg174998) | Author: Christian Heimes (christian.heimes) \* (Python committer) | Date: 2012-11-06 17:10 |
| ``` I modified crypto_auth() a bit:  Py_uhash_t crypto_auth(const unsigned char *in, unsigned long long inlen)   ...   u64 k0 = _Py_HashSecret.prefix;   u64 k1 = _Py_HashSecret.suffix;   ...   return (Py_uhash_t)b;  and replaced the loop in _Py_HashBytes() with a call to crypto_auth(). For large strings SipHash is as faster as our current algorithm on my 64bit box. That was to be expected as SipHash works on blocks of 8 bytes while the default algorithm can't be optimized with SIMD instructions.  Current hashing algorithm: $ ./python -m timeit -s "x = b'a' * int(1E7)" "hash(x)" 1000000 loops, best of 3: 0.39 usec per loop  SipHash: $ ./python -m timeit -s "x = b'a' * int(1E7)" "hash(x)" 1000000 loops, best of 3: 0.381 usec per loop ``` | | | |
| [msg174999](#msg174999) - [(view)](msg174999) | Author: Giovanni Bajo (Giovanni.Bajo) | Date: 2012-11-06 18:26 |
| ``` For short strings, you might want to have a look at the way you fetch the final partial word from memory.  If the string is >= 8 bytes, you can fetch the last partial word as an unaligned memory fetch followed by a shift, instead of using a switch like in the reference code. ``` | | | |
| [msg175000](#msg175000) - [(view)](msg175000) | Author: Christian Heimes (christian.heimes) \* (Python committer) | Date: 2012-11-06 19:11 |
| ``` We can explore the various optimization options later. Also unaligned memory address is not allowed on some architectures like SPARC.  If somebody likes to play with the algorithm: <http://hg.python.org/sandbox/cheimes/shortlog/2cb7e97ca8d0> ``` | | | |
| [msg175007](#msg175007) - [(view)](msg175007) | Author: Serhiy Storchaka (serhiy.storchaka) \* (Python committer) | Date: 2012-11-06 20:12 |
| ``` $ ./python -m timeit -s "x = b'a' * int(1E7)" "hash(x)"  Note that hash calculated only once.  Add -n 1 option and use a larger data.  > If somebody likes to play with the algorithm:  $ ./python -m timeit -n 1 -s "t = 'abcdefgh' * 10**8"  "hash(t)" 1 loops, best of 3: 4.86 sec per loop  Current hash algorithm runs 3.43 sec, V8's algorithm runs 2.44 sec.  With simple optimization I got 3.62 sec, only 6% slower than the current.    #define U8TO64_LE(p) ((u64)((u32 *)(p))[0] | ((u64)((u32 *)(p))[1] << 32)) ``` | | | |
| [msg175038](#msg175038) - [(view)](msg175038) | Author: Christian Heimes (christian.heimes) \* (Python committer) | Date: 2012-11-07 00:52 |
| ``` Thanks to Snakebit I was able to tests the code on a 32bit BSD installation with GCC 4.2. The ASCII unicode and bytes performance is about 8% slower, UCS2 unicode is about 37% slower. There might be room for improvements, though.  % ./python -m timeit -r20 -n1000000 -s "h = hash; x = 'a' * 10**7" -- "h(x)" Current: 1000000 loops, best of 20: 0.109 usec per loop SipHash: 1000000 loops, best of 20: 0.118 usec per loop  % ./python -m timeit -r20 -n1000000 -s "h = hash; x = 'ä' * 10**7" -- "h(x)" Current: 1000000 loops, best of 20: 0.119 usec per loop SipHash: 1000000 loops, best of 20: 0.163 usec per loop ``` | | | |
| [msg175040](#msg175040) - [(view)](msg175040) | Author: Christian Heimes (christian.heimes) \* (Python committer) | Date: 2012-11-07 01:27 |
| ``` Serhiy's trick  #define U8TO64_LE(p) ((u64)((u32 *)(p))[0] | ((u64)((u32 *)(p))[1] << 32))  gives a nice speedup. Now UCS2 is down to 0.133 usec (12% slower than the current algorithm) and ASCII down to 0.105 usec (3% faster). ``` | | | |
| [msg175047](#msg175047) - [(view)](msg175047) | Author: Serhiy Storchaka (serhiy.storchaka) \* (Python committer) | Date: 2012-11-07 06:49 |
| ``` % ./python -m timeit -r20 -n1000000 -s "h = hash; x = 'a' * 10**7" -- "h(x)"  Here is only one hash calculation and 999999 cached calls. ``` | | | |
| [msg175048](#msg175048) - [(view)](msg175048) | Author: Serhiy Storchaka (serhiy.storchaka) \* (Python committer) | Date: 2012-11-07 07:40 |
| ``` I tested different kind of strings.  $ ./python -m timeit -n 1 -s "t = b'a' * 10**8"  "hash(t)" $ ./python -m timeit -n 1 -s "t = 'a' * 10**8"  "hash(t)" $ ./python -m timeit -n 1 -s "t = '\u0100' * 10**8"  "hash(t)" $ ./python -m timeit -n 1 -s "t = '\U00010000' * 10**8"  "hash(t)"         current   SipHash  bytes  181 msec  453 msec  2.5x UCS1   429 msec  453 msec  1.06x UCS2   179 msec  897 msec  5x UCS4   183 msec  1.79 sec  9.8x ``` | | | |
| [msg175050](#msg175050) - [(view)](msg175050) | Author: Marc-Andre Lemburg (lemburg) \* (Python committer) | Date: 2012-11-07 08:34 |
| ``` Here's a demo patch (against Python 2.7) which counts hash value collisions and slot collisions. I had posted that in the original ticket where we discussed the hash problem (<http://bugs.python.org/issue14621>).  This avoids issues like attack 1 mentioned in <http://mail.python.org/pipermail/python-dev/2012-January/115726.html>  Attack 2 in that email can easily be worked around by reducing the collision limit to a smaller number.  Even better: An application could even dynamically adjust the maximum collision counts by catching the exception and setting a new upper limit depending on its knowledge of the field of application - warning the sysadmin of a potential problem and allowing her to take action. That way the application could start with a low safe maximum collision number of say 100 and then raise the limit in a controlled way.  BTW: When trying out new hash functions, you need to look not only at the performance of the hash function, but also (and more importantly) at the effect on dictionaries.  Just as reminder: The integer key problem is still open. Using the demo script <http://bugs.python.org/file24300/integercollision.py>, it's easy to keep Python going for minutes without any major effort.  I don't understand why we are only trying to fix the string problem and completely ignore other key types. Strings are easy to send to a web server, yes, but there are other applications out there which take input data from other sources/formats as well (e.g. csv files). And it's not unusual to convert input strings to integers to use them as dictionary keys, say item IDs or counts. So while the string keys may not cause a problem, the integer keys still might. ``` | | | |
| [msg175052](#msg175052) - [(view)](msg175052) | Author: Marc-Andre Lemburg (lemburg) \* (Python committer) | Date: 2012-11-07 08:41 |
| ``` On 07.11.2012 09:34, Marc-Andre Lemburg wrote: >  > Here's a demo patch (against Python 2.7) which counts hash value collisions and slot collisions. I had posted that in the original ticket where we discussed the hash problem (<http://bugs.python.org/issue14621>).  Sorry, wrong URL. The correct one is <http://bugs.python.org/issue13703>  --  Marc-Andre Lemburg eGenix.com  Professional Python Services directly from the Source  (#1, Nov 07 2012) >>> Python Projects, Consulting and Support ...   <http://www.egenix.com/> >>> mxODBC.Zope/Plone.Database.Adapter ...       <http://zope.egenix.com/> >>> mxODBC, mxDateTime, mxTextTools ...        <http://python.egenix.com/> ________________________________________________________________________  ::: Try our new mxODBC.Connect Python Database Interface for free ! ::::     eGenix.com Software, Skills and Services GmbH  Pastor-Loeh-Str.48     D-40764 Langenfeld, Germany. CEO Dipl.-Math. Marc-Andre Lemburg            Registered at Amtsgericht Duesseldorf: HRB 46611                <http://www.egenix.com/company/contact/> ``` | | | |
| [msg175053](#msg175053) - [(view)](msg175053) | Author: Giovanni Bajo (Giovanni.Bajo) | Date: 2012-11-07 08:44 |
| ``` Until it's broken with a yet-unknown attack, SipHash is a pseudo-random function and as such it does uniformly distribute values across the output space, and never leak any information on the key (the randomized seed). Being designed by cryptographers, it is likely that it doesn't turn out to be a "fail" like the solution that was just released (no offense intended, but it's been a large-scale PR failure).  As long as we don't introduce bias while reducing SipHash's output to fit the hash table size (so for instance, usage of modulus is not appropriate), then the hash function should behave very well.  Any data type can be supplied to SipHash, including numbers; you just need to take their (platform-dependent) memory representation and feed it to SipHash. Obviously it will be much much slower than the current function which used to be hash(x) = x (before randomization), but that's the price to pay to avoid security issues. ``` | | | |
| [msg175080](#msg175080) - [(view)](msg175080) | Author: Armin Rigo (arigo) \* (Python committer) | Date: 2012-11-07 11:05 |
| ``` Marc-André: estimating the risks of giving up on a valid query for a truly random hash, at an overestimated one billion queries per second, in a 2/3 full dictionary:  * for 1000: 4E159 years between mistakes  * for 100: 12.9 years between mistakes  * for 150: 8E9 years between mistakes  * for 200: 5E18 years between mistakes  So while it seems that 100 might be a bit too small, using 150 to 200 is perfectly safe (and that's "perfect" in the sense that a computer will encounter random hardware errors at a higher rate than that). ``` | | | |
| [msg175081](#msg175081) - [(view)](msg175081) | Author: Marc-Andre Lemburg (lemburg) \* (Python committer) | Date: 2012-11-07 11:19 |
| ``` On 07.11.2012 12:06, Armin Rigo wrote: >  > Armin Rigo added the comment: >  > Marc-André: estimating the risks of giving up on a valid query for a truly random hash, at an overestimated one billion queries per second, in a 2/3 full dictionary: >  > * for 1000: 4E159 years between mistakes >  > * for 100: 12.9 years between mistakes >  > * for 150: 8E9 years between mistakes >  > * for 200: 5E18 years between mistakes >  > So while it seems that 100 might be a bit too small, using 150 to 200 is perfectly safe (and that's "perfect" in the sense that a computer will encounter random hardware errors at a higher rate than that).  I used the 1000 limit only as example. In tests Victor and I ran (see the original ticket from a few months ago), 200 turned out to be a reasonable number for the default maximum hash collision value.  I'm not sure about the slot collision limit. We'd have to run more tests on those. ``` | | | |
| [msg175082](#msg175082) - [(view)](msg175082) | Author: Giovanni Bajo (Giovanni.Bajo) | Date: 2012-11-07 11:26 |
| ``` Il giorno 07/nov/2012, alle ore 08:40, Serhiy Storchaka <report@bugs.python.org> ha scritto:  > Serhiy Storchaka added the comment: >  > I tested different kind of strings. >  > $ ./python -m timeit -n 1 -s "t = b'a' * 10**8"  "hash(t)" > $ ./python -m timeit -n 1 -s "t = 'a' * 10**8"  "hash(t)" > $ ./python -m timeit -n 1 -s "t = '\u0100' * 10**8"  "hash(t)" > $ ./python -m timeit -n 1 -s "t = '\U00010000' * 10**8"  "hash(t)" >  >       current   SipHash >  > bytes  181 msec  453 msec  2.5x > UCS1   429 msec  453 msec  1.06x > UCS2   179 msec  897 msec  5x > UCS4   183 msec  1.79 sec  9.8x  Hi Serhiy,  can you please attach the generated assembly code for the siphash function with your compiler and your optimization flags (that is, the one that produces the above results)?  Thanks! --  Giovanni Bajo ``` | | | |
| [msg175083](#msg175083) - [(view)](msg175083) | Author: Serhiy Storchaka (serhiy.storchaka) \* (Python committer) | Date: 2012-11-07 11:51 |
| ``` > can you please attach the generated assembly code for the siphash function with your compiler and your optimization flags (that is, the one that produces the above results)?  GCC (Ubuntu 4.4.3-4ubuntu5.1) options:  -pthread -c -Wno-unused-result -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes   -I. -IInclude -I./Include    -DPy_BUILD_CORE  32-bit Linux on AMD Athlon(tm) 64 X2 Dual Core Processor 4600+. ``` | | | |
| [msg175085](#msg175085) - [(view)](msg175085) | Author: Christian Heimes (christian.heimes) \* (Python committer) | Date: 2012-11-07 11:53 |
| ``` Serhiy, the performance of hash() for long strings isn't very relevant for the general performance of a Python program. Short strings dominate. I've modified the timeit to create a new string object every time.  for I in 5 10 15 20 30 40 50 60; do echo -ne "$I\t"; ./python -m timeit -n100000 -r30 -s "h = hash; x = 'ä' * $I" -- "h(x + 'a')" | awk '{print $6}' ; done  ASCII: #       SIP        FNV 5       0.112      0.0979 10      0.115      0.103 15      0.12       0.107 20      0.124      0.112 30      0.126      0.127 40      0.136      0.142 50      0.142      0.147 60      0.146      0.159  UCS-2: #       SIP        FNV 5       0.114      0.0977 10      0.117      0.0988 15      0.12       0.11 20      0.126      0.109 30      0.13       0.122 40      0.14       0.132 50      0.144      0.147 60      0.152      0.157  For short strings the additional round and setup costs make hash() about 10% slower. For long strings SIP is faster as it processes 8 bytes at once instead of 1 to 4 bytes. ``` | | | |
| [msg175086](#msg175086) - [(view)](msg175086) | Author: Mark Dickinson (mark.dickinson) \* (Python committer) | Date: 2012-11-07 11:55 |
| ``` [MAL] > I don't understand why we are only trying to fix the string problem > and completely ignore other key types.  [Armin] > estimating the risks of giving up on a valid query for a truly random > hash, at an overestimated one billion queries per second ...  That's fine in principle, but if this gets extended to integers, note that our current integer hash is about as far from 'truly random' as you can get:      Python 3.4.0a0 (default:f02555353544, Nov  4 2012, 11:50:12)      [GCC 4.2.1 (Apple Inc. build 5664)] on darwin     Type "help", "copyright", "credits" or "license" for more information.     >>> [hash(i) for i in range(20)]     [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]  Moreover, it's going to be *very* hard to change the int hash while preserving the `x == y implies hash(x) == hash(y)` invariant across all the numeric types (int, float, complex, Decimal, Fraction, 3rd-party types that need to remain compatible). ``` | | | |
| [msg175088](#msg175088) - [(view)](msg175088) | Author: Marc-Andre Lemburg (lemburg) \* (Python committer) | Date: 2012-11-07 11:59 |
| ``` On 07.11.2012 12:55, Mark Dickinson wrote: >  > Mark Dickinson added the comment: >  > [MAL] >> I don't understand why we are only trying to fix the string problem >> and completely ignore other key types. >  > [Armin] >> estimating the risks of giving up on a valid query for a truly random >> hash, at an overestimated one billion queries per second ... >  > That's fine in principle, but if this gets extended to integers, note that our current integer hash is about as far from 'truly random' as you can get: >  >     Python 3.4.0a0 (default:f02555353544, Nov  4 2012, 11:50:12)  >     [GCC 4.2.1 (Apple Inc. build 5664)] on darwin >     Type "help", "copyright", "credits" or "license" for more information. >     >>> [hash(i) for i in range(20)] >     [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] >  > Moreover, it's going to be *very* hard to change the int hash while preserving the `x == y implies hash(x) == hash(y)` invariant across all the numeric types (int, float, complex, Decimal, Fraction, 3rd-party types that need to remain compatible).  Exactly. And that's why trying to find secure hash functions isn't going to solve the problem. Together with randomization they may make things better for strings, but they are no solution for numeric types, and they also don't allow detecting possible attacks on your systems.  But yeah, I'm repeating myself :-) ``` | | | |
| [msg175089](#msg175089) - [(view)](msg175089) | Author: Mark Dickinson (mark.dickinson) \* (Python committer) | Date: 2012-11-07 12:06 |
| ``` And I'm probably repeating myself too, but: the predictability of (and difficulty of changing of) hashing for numeric types is why I'm strongly opposed to hash collision / slot collision limits:  they'd end up disallowing reasonably natural looking Python numeric sets (e.g. {2**k for k in range(n)} for smallish n).  I don't think core Python should be solving this issue at all---I think that's a job for the web frameworks.  Christian's idea of providing more suitable types in the std. lib. sounds like the right direction to me. ``` | | | |
| [msg175091](#msg175091) - [(view)](msg175091) | Author: Marc-Andre Lemburg (lemburg) \* (Python committer) | Date: 2012-11-07 12:19 |
| ``` On 07.11.2012 13:06, Mark Dickinson wrote: >  > Mark Dickinson added the comment: >  > And I'm probably repeating myself too, but: the predictability of (and difficulty of changing of) hashing for numeric types is why I'm strongly opposed to hash collision / slot collision limits:  they'd end up disallowing reasonably natural looking Python numeric sets (e.g. {2**k for k in range(n)} for smallish n).  I don't think core Python should be solving this issue at all---I think that's a job for the web frameworks.  Christian's idea of providing more suitable types in the std. lib. sounds like the right direction to me.  I definitely agree on that last sentence. Having more suitable data types in Python (like e.g. tries, b-trees or red-black-trees) would certainly be a better solution than trying to build everything into dictionaries.  Nice comparison: <http://en.wikipedia.org/wiki/Trie> ``` | | | |
| [msg175094](#msg175094) - [(view)](msg175094) | Author: Serhiy Storchaka (serhiy.storchaka) \* (Python committer) | Date: 2012-11-07 12:40 |
| ``` See [issue16427](issue16427 "[closed] Faster hash implementation"). ``` | | | |
| [msg175096](#msg175096) - [(view)](msg175096) | Author: Armin Rigo (arigo) \* (Python committer) | Date: 2012-11-07 12:54 |
| ``` I won't try to influence the outcome of this discussion, but I'd like to correct myself: in the measures I posted, "true randomness" is not needed at all.  The exact criterion might be hard to pin down, but as a first approximation, we get the same answers as long as most keys have different hashes, as all the bits of the hash are used by the dict lookup in only a few iterations.  No two small ints have the same hash, by construction.  You can build a sequence of (long) integers that have all exactly the same hash, but doing that is not as easy as "2**k". ``` | | | |
| [msg175097](#msg175097) - [(view)](msg175097) | Author: Serhiy Storchaka (serhiy.storchaka) \* (Python committer) | Date: 2012-11-07 12:55 |
| ``` > Serhiy, the performance of hash() for long strings isn't very relevant for the general performance of a Python program.  It exposes the raw speed of hashing algorithm.  It is good as a first estimate, because more real cases require more sophisticated measurements.  > Short strings dominate. I've modified the timeit to create a new string object every time.  timeit is absolutely not suitable for this.  Need to write a C program that uses the Python C API.  > for I in 5 10 15 20 30 40 50 60; do echo -ne "$I\t"; ./python -m timeit -n100000 -r30 -s "h = hash; x = 'ä' * $I" -- "h(x + 'a')" | awk '{print $6}' ; done  Please, do not be fooled by the wrong measurements. You measure the height of the building together with the hill, on which it stands. Use "-n1" and you will see a  completely different numbers. ``` | | | |
| [msg175098](#msg175098) - [(view)](msg175098) | Author: Armin Rigo (arigo) \* (Python committer) | Date: 2012-11-07 13:02 |
| ``` Wrong, sorry.  On a 32-bit Python 2.7, "(2**32-1)*n" has the same hash -2, for any value of n.  Of course if you build a dict containing thousands of such integers as keys, then right now you get unexpectedly bad performance.  I wonder if I should open another bug report about that --- the hash of longs should be slightly more random-looking... ``` | | | |
| [msg175099](#msg175099) - [(view)](msg175099) | Author: Mark Dickinson (mark.dickinson) \* (Python committer) | Date: 2012-11-07 13:03 |
| ``` [Armin] > You can build a sequence of (long) integers that have all exactly the > same hash, but doing that is not as easy as "2**k".  Sure it is.  The hash for integers is (by design) repeated modulo a number of the form 2**n - 1:  we use 2**61 - 1 on 64-bit systems and 2**31 - 1 on 32-bit.  So in {2**k for k in range(n)} you get at most 61 distinct hash values. ``` | | | |
| [msg175100](#msg175100) - [(view)](msg175100) | Author: Giovanni Bajo (Giovanni.Bajo) | Date: 2012-11-07 13:16 |
| ``` Il giorno 07/nov/2012, alle ore 12:59, Marc-Andre Lemburg <report@bugs.python.org> ha scritto:  >  > Marc-Andre Lemburg added the comment: >  > On 07.11.2012 12:55, Mark Dickinson wrote: >>  >> Mark Dickinson added the comment: >>  >> [MAL] >>> I don't understand why we are only trying to fix the string problem >>> and completely ignore other key types. >>  >> [Armin] >>> estimating the risks of giving up on a valid query for a truly random >>> hash, at an overestimated one billion queries per second ... >>  >> That's fine in principle, but if this gets extended to integers, note that our current integer hash is about as far from 'truly random' as you can get: >>  >>    Python 3.4.0a0 (default:f02555353544, Nov  4 2012, 11:50:12)  >>    [GCC 4.2.1 (Apple Inc. build 5664)] on darwin >>    Type "help", "copyright", "credits" or "license" for more information. >>>>> [hash(i) for i in range(20)] >>    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] >>  >> Moreover, it's going to be *very* hard to change the int hash while preserving the `x == y implies hash(x) == hash(y)` invariant across all the numeric types (int, float, complex, Decimal, Fraction, 3rd-party types that need to remain compatible). >  > Exactly. And that's why trying to find secure hash functions isn't > going to solve the problem. Together with randomization they may > make things better for strings, but they are no solution for numeric > types, and they also don't allow detecting possible attacks on your > systems. >  > But yeah, I'm repeating myself :-) >   I don't see how it follows. Python has several hash functions in its core, one of which is the string hash function; it is currently severely broken from a security standpoint; it also happens to be probably the most common case for dictionaries in Python, and the ones that it is more easily exploited in web frameworks.   If we can manage to fix the string hash function (eg: through SipHash) we will be one step further in mitigating the possible attacks.  Solving collisions and mitigating attacks on numeric types is a totally different problem because it is a totally different function. I suggest we keep different discussions and different bugs for it. For instance, I'm only personally interested in mitigating attacks on the string hash function. --  Giovanni Bajo ``` | | | |
| [msg175192](#msg175192) - [(view)](msg175192) | Author: Sasha B (sbermeister) | Date: 2012-11-08 21:58 |
| ``` Ruby uses the Murmur hash for some types (string & integer at least): <http://murmurhash.googlepages.com/> src: <http://stackoverflow.com/a/3270836/1332819>  The Perl hash implementation: <http://cpansearch.perl.org/src/NWCLARK/perl-5.8.8/hv.c>  PHP5 hash implementation: <http://lxr.php.net/xref/PHP_5_4/ext/hash/hash.c>  The Probe() function for V8's Javascript implementation is HW-specific: Hash functions: <http://code.google.com/searchframe#W9JxUuHYyMg/trunk/src/hashmap.h&q=Probe%20package:v8%5C.googlecode%5C.com&l=134> Probe() function: <http://code.google.com/searchframe#search%26q%3DProbe%20package%3Av8%5C.googlecode%5C.com> ``` | | | |
| [msg175196](#msg175196) - [(view)](msg175196) | Author: Christian Heimes (christian.heimes) \* (Python committer) | Date: 2012-11-08 22:10 |
| ``` I considered MurMur a year ago, too. Nowadays I don't think it's an option anymore. JPA and DJB have released a C++ program that is able to generate lots of collisions:  <https://www.131002.net/siphash/> C++ program to find universal (key-independent) multicollisions for MurmurHash3 ``` | | | |
| [msg175198](#msg175198) - [(view)](msg175198) | Author: Christian Heimes (christian.heimes) \* (Python committer) | Date: 2012-11-08 22:16 |
| ``` From the header of murmurcollisions.cc:   * multicollisions for MurmurHash3  *  * MurmurHash3 C++ implementation is available at   * <http://code.google.com/p/smhasher/wiki/MurmurHash3>  *  * the function Murmur3Multicollisions finds many different inputs  * hashing to the same 32-bit value (multicollision)  *   * example output:  * 32-bit seed 7a0e823a  * 4-multicollision  * 16-byte inputs  * MurmurHash3_x86_32( bdd0c04b5c3995827482773b12acab35 ) = 94d7cf1b  * MurmurHash3_x86_32( 652fa0565c3946be7482773b12acab35 ) = 94d7cf1b  * MurmurHash3_x86_32( bdd0c04b5c399582cc23983012ac5c71 ) = 94d7cf1b  * MurmurHash3_x86_32( 652fa0565c3946becc23983012ac5c71 ) = 94d7cf1b  *  * the multicollisions found are "universal": they work for any seed/key  *  * authors:  * Jean-Philippe Aumasson, Daniel J. Bernstein  I consider MurMur3 busted and unsuitable for our purpose. ``` | | | |
| [msg175299](#msg175299) - [(view)](msg175299) | Author: Gregory P. Smith (gregory.p.smith) \* (Python committer) | Date: 2012-11-10 22:23 |
| ``` People have been posting micro-benchmarks (often run wrong) rather than actual useful benchmarks.  Running our real world benchmarks would be more interesting. ``` | | | |
| [msg175318](#msg175318) - [(view)](msg175318) | Author: Chris Rebert (cvrebert) \* | Date: 2012-11-11 04:56 |
| ``` What about CityHash? (<http://code.google.com/p/cityhash/> ; unofficial C port: <http://code.google.com/p/cityhash-c/> ) It's good enough for Google... ``` | | | |
| [msg175342](#msg175342) - [(view)](msg175342) | Author: STINNER Victor (vstinner) \* (Python committer) | Date: 2012-11-11 10:09 |
| ``` Did qomeone start to write a PEP? Le 11 nov. 2012 05:56, "Chris Rebert" <report@bugs.python.org> a écrit :  > > Chris Rebert added the comment: > > What about CityHash? (<http://code.google.com/p/cityhash/> ; unofficial C > port: <http://code.google.com/p/cityhash-c/> ) > It's good enough for Google... > > ---------- > nosy: +cvrebert > > _______________________________________ > Python tracker <report@bugs.python.org> > <<http://bugs.python.org/issue14621>> > _______________________________________ > ``` | | | |
| [msg175345](#msg175345) - [(view)](msg175345) | Author: Giovanni Bajo (Giovanni.Bajo) | Date: 2012-11-11 11:14 |
| ``` Il giorno 11/nov/2012, alle ore 05:56, Chris Rebert <report@bugs.python.org> ha scritto:  >  > Chris Rebert added the comment: >  > What about CityHash? (<http://code.google.com/p/cityhash/> ; unofficial C port: <http://code.google.com/p/cityhash-c/> ) > It's good enough for Google...  It's good enough for Google in a context that does not require protection against collision attacks. If you have a look at SipHash' page, you will find a program to generate collisions to CityHash. --  Giovanni Bajo  My Blog: <http://giovanni.bajo.it> ``` | | | |
| [msg176680](#msg176680) - [(view)](msg176680) | Author: Łukasz Rekucki (Łukasz.Rekucki) | Date: 2012-11-30 07:53 |
| ``` Note that a few weeks ago, Ruby has switched from Murmur to SipHash for this exact reason:  <http://www.ruby-lang.org/en/news/2012/11/09/ruby19-hashdos-cve-2012-5371/> ``` | | | |
| [msg176697](#msg176697) - [(view)](msg176697) | Author: René (ReneSac) | Date: 2012-11-30 18:12 |
| ``` Christian Heimes: It has always been trivial to artificially generate collisions for fast hashes designed for hash tables, like MurmurHash. I wouldn't call Murmurhash3 "busted" because of that, as this was never a design goal. It is a known propriety of this type of hash: you do that basically running them backwards. You can't even call that cryptanalysis.   Of course, you need the seed to search those collisions, but from this thread it seems very difficult, if not impossible, not to leak the random seed to the attacker.   I see the various collision counting alternatives proposed as the less intrusive and definitive solution for this problem. It also has the benefit that it can work for any type of key. Some pseudo code:  hash as always, with a fast hash. if reprobes > initial_threshold:     if the table has only one key type AND it has a robust comparison method:         store the collisions in a O(log n) worst case structure (tree).     elif the object has a secondary slow secure hash:         try searching/inserting the key again with the new secure hash.         It works like a double hashing reprobing hash table.     elif collisions > max_threshold:         raise Exception("Under attack or the object is using a crappy hash, with no fallback.")  The first option, the O(log n) structure, can be ignored as unnecessary complication (even though there is already a path implementing that), but I suspect it may be faster than a secure hash. If not, then there is really no point in this option, except if the secure hash proves to be not so secure. ``` | | | |
| [msg176704](#msg176704) - [(view)](msg176704) | Author: Christian Heimes (christian.heimes) \* (Python committer) | Date: 2012-11-30 19:20 |
| ``` No, Murmur3 *is* busted. Some clever people have found a way to perform a universal multicollision attack, that's a key independent attack. An attacker doesn't need to know the seed for an attack.  Collision counting as not a solution for the issue, just a workaround. It has been proofed for decades that a tree data structure is not vulnerable to this kind of collision attacks. A hash function with crypto properties is the second best solution. ``` | | | |
| [msg176705](#msg176705) - [(view)](msg176705) | Author: Serhiy Storchaka (serhiy.storchaka) \* (Python committer) | Date: 2012-11-30 19:39 |
| ``` However a tree data structure is vulnerable to sorted data.  May be worth it to have the two hash functions (switchable by interpreter option or environment variable), strong for applications which can be attacked, and fast for applications which run in safe environment? ``` | | | |
| [msg176709](#msg176709) - [(view)](msg176709) | Author: René (ReneSac) | Date: 2012-11-30 20:01 |
| ``` Serhiy Storchaka: I said a O(log n) data structure, so I was referring to balanced trees, like AVL, RBT or B+-tree. They are not vulnerable to sorted data. The downside is that they need the keys to provide robust comparison methods (like, if z < y < x, then z < x).   Christian Heimes: Right, the seed indeed doesn't provides protection...  But the collision counting is compatible with your two suggestions, and solves the problem. The only difference is that you don't get the performance hit if not under attack. ``` | | | |
| [msg176710](#msg176710) - [(view)](msg176710) | Author: Serhiy Storchaka (serhiy.storchaka) \* (Python committer) | Date: 2012-11-30 20:06 |
| ``` René, a balanced tree requires rebalancing on every (or almost every) item for some special (sorted) data sequences. ``` | | | |
| [msg176713](#msg176713) - [(view)](msg176713) | Author: Michal Petrucha (koniiiik) | Date: 2012-11-30 20:33 |
| ``` On Fri, Nov 30, 2012 at 08:06:32PM +0000, Serhiy Storchaka wrote: > René, a balanced tree requires rebalancing on every (or almost > every) item for some special (sorted) data sequences.  That's perfectly true and it holds for most unsorted sequences as well -- that's why they are balanced. The fact that the tree is always balanced guarantees that each rebalance takes at most O(log n) operations. ``` | | | |
| [msg176714](#msg176714) - [(view)](msg176714) | Author: Marc-Andre Lemburg (lemburg) \* (Python committer) | Date: 2012-11-30 20:34 |
| ``` On 30.11.2012 21:06, Serhiy Storchaka wrote: >  > Serhiy Storchaka added the comment: >  > René, a balanced tree requires rebalancing on every (or almost every) item for some special (sorted) data sequences.  Sure, but that's still O(N*log N) for an attack scenario, not O(N^2).  I think the main point here is that using hash tables or dictionaries for these things without any size limit is simply a wrong development approach.  Developers need to be made aware of the problem and given data structures that they can use more safely to store the data and instead of trying to hide away the problem using some crypto approach, it's better to offer methods that allow developers to gain control over the problem (e.g. via an exception) rather than hoping for few hash collisions.  If a developer has to build a lookup table from untrusted data, she should be able to say:  try:     mapping = insert_untrusted_data(source) except UnderAttackError:     return 'no thank you'  instead of:  # Hmm, let's hope this doesn't bomb... mapping = insert_untrusted_data(source)  At the moment, the best thing you can do is insert the data in chunks and measure the time it takes for each chunk. If it takes too long, you raise the UnderAttackError.  If we make the collision counting limit a per-dictionary adjustable limit with some global default limit, the above could be written as:  try:     mapping = {}     mapping.max_collisions = 100     mapping.update(source) except CollisionLimitError:     return 'no thank you'  Aside: It's better to know you worst case and program for it, rather than to ignore the problem and hope an attacker won't find your secret key. In the above case, if you know what the worst-case timing is for a 100-item dictionary, you can safely deal with it, possibly adjusting the limit to more suitable value for your application.  --  Marc-Andre Lemburg eGenix.com  Professional Python Services directly from the Source  (#1, Nov 30 2012) >>> Python Projects, Consulting and Support ...   <http://www.egenix.com/> >>> mxODBC.Zope/Plone.Database.Adapter ...       <http://zope.egenix.com/> >>> mxODBC, mxDateTime, mxTextTools ...        <http://python.egenix.com/> ________________________________________________________________________ 2012-11-28: Released eGenix mx Base 3.2.5 ...     <http://egenix.com/go36> 2013-01-22: Python Meeting Duesseldorf ...                 53 days to go  ::: Try our new mxODBC.Connect Python Database Interface for free ! ::::     eGenix.com Software, Skills and Services GmbH  Pastor-Loeh-Str.48     D-40764 Langenfeld, Germany. CEO Dipl.-Math. Marc-Andre Lemburg            Registered at Amtsgericht Duesseldorf: HRB 46611                <http://www.egenix.com/company/contact/> ``` | | | |
| [msg176715](#msg176715) - [(view)](msg176715) | Author: René (ReneSac) | Date: 2012-11-30 20:35 |
| ``` Serhiy Storchaka: Yes, but it is still O(log n) worst case. Even in the worst case rebalancing, you only need to walk up/down rotating/spliting every node in your path. As the tree height is guaranteed to be x * log n (x from 1 to 2, depending on the algorithm), the rebalancing operation is aways limited by O(log n). ``` | | | |
| [msg176720](#msg176720) - [(view)](msg176720) | Author: Serhiy Storchaka (serhiy.storchaka) \* (Python committer) | Date: 2012-11-30 21:25 |
| ``` > Serhiy Storchaka: Yes, but it is still O(log n) worst case. Even in the > worst case rebalancing, you only need to walk up/down rotating/spliting > every node in your path. As the tree height is guaranteed to be x * log n > (x from 1 to 2, depending on the algorithm), the rebalancing operation is > aways limited by O(log n).  Agree. However I think that for large enough data a balanced tree is slower  than a hashtable with any slow hash. ``` | | | |
| [msg176721](#msg176721) - [(view)](msg176721) | Author: Serhiy Storchaka (serhiy.storchaka) \* (Python committer) | Date: 2012-11-30 21:27 |
| ``` > try: >     mapping = {} >     mapping.max_collisions = 100 >     mapping.update(source) > except CollisionLimitError: >     return 'no thank you'  May be use a more general solution?  try:     with run_with_timeout(timeout=100, timer=collisions_count):         mapping = insert_untrusted_data(source) except TimeoutError:     return 'no thank you'  (You can can use different measurement for timeout: user time, real time, ticks  count, collisions count, or even a user defined timer). ``` | | | |
| [msg176725](#msg176725) - [(view)](msg176725) | Author: Marc-Andre Lemburg (lemburg) \* (Python committer) | Date: 2012-11-30 22:51 |
| ``` On 30.11.2012 22:27, Serhiy Storchaka wrote: >  > Serhiy Storchaka added the comment: >  >> try: >>     mapping = {} >>     mapping.max_collisions = 100 >>     mapping.update(source) >> except CollisionLimitError: >>     return 'no thank you' >  > May be use a more general solution? >  > try: >     with run_with_timeout(timeout=100, timer=collisions_count): >         mapping = insert_untrusted_data(source) > except TimeoutError: >     return 'no thank you' >  > (You can can use different measurement for timeout: user time, real time, ticks  > count, collisions count, or even a user defined timer).  Sure, as long as there's a way to break into the execution, any such method would do.  The problem is that you'd have to check for the timeout at some point and the .update() call is running completely in C, so the only way to break into execution is either by explicitly adding a runtime check to the code, or use a signal (which is a can of worms better avoided :-)).  Collision counting is one such method of detecting that something is likely not working according to plan, but it's really only another way of implementing the explicit runtime check. Using other counters or timers would work just as well.  As long as you know that there are places in your code that can produce CPU time overloads, you can address those issues.  The dictionary implementation is one such place, where you can run into the problem, but there are usually many other such areas in more complex applications as well, e.g. calculations that enter endless loops for some parameters, deadlocks, I/O operations that take unusually long (e.g. due to disk errors), poorly written drivers of all sorts, etc. etc.  If there's a way to solve all these things in general and without explicit runtime checks, I'd like to know :-) ``` | | | |
| [msg176808](#msg176808) - [(view)](msg176808) | Author: Bob Ziuchkovski (Bob.Ziuchkovski) | Date: 2012-12-02 20:47 |
| ``` Why not redefine -R to mean "use secure hashing algorithms for built-in types"?  When specified, use hashing algorithms that are secure against denial-of-service and other known attacks, at the possible expense of performance.  When not specified, use whatever hashing algorithms provide the most sensible defaults for every-day use (basically hash the way python currently hashes).  Secure hashing would apply not just to strings but to numeric and other types as well.  This would break the invariant of `x == y implies hash(x) == hash(y)` for numeric types that Mark mentioned.  However, that seems like an implementation detail that python users shouldn't rely upon. ``` | | | |
| [msg178784](#msg178784) - [(view)](msg178784) | Author: Domen Kožar (iElectric) | Date: 2013-01-01 23:20 |
| ``` According to talk at 29c3: <http://events.ccc.de/congress/2012/Fahrplan/events/5152.en.html>  Quote: We also describe a vulnerability of Python's new randomized hash, allowing an attacker to easily recover the 128-bit secret seed. As a reliable fix to hash-flooding, we introduce SipHash, a family of cryptographically strong keyed hash function competitive in performance with the weak hashes, and already adopted in OpenDNS, Perl 5, Ruby, and in the Rust language. ``` | | | |
| [msg178798](#msg178798) - [(view)](msg178798) | Author: Christian Heimes (christian.heimes) \* (Python committer) | Date: 2013-01-02 05:52 |
| ``` Thanks for the information! I'm working on a PEP for the issue at hand. ``` | | | |
| [msg178800](#msg178800) - [(view)](msg178800) | Author: Alyssa Coghlan (ncoghlan) \* (Python committer) | Date: 2013-01-02 07:08 |
| ``` Bob, the hash invariant isn't a mere implementation detail, it is critical to making hash based data structures work properly - if two equal objects (say the integer zero and the float zero) ever end up in different hash bins, then the uniqueness property of dictionary keys and sets breaks down.  The three proposed mitigation strategies (using SipHash for string hashing, a tunable collision counting hash map and providing a non-hash based mapping container in the standard library) are all reasonable approaches to the problem and, most importantly, they're *orthogonal* approaches to the problem. There's nothing stopping us doing all three if someone is willing and able to provide the code. ``` | | | |
| [msg178808](#msg178808) - [(view)](msg178808) | Author: Giovanni Bajo (Giovanni.Bajo) | Date: 2013-01-02 10:02 |
| ``` Il giorno 02/gen/2013, alle ore 00:20, Domen Kožar <report@bugs.python.org> ha scritto:  >  > Domen Kožar added the comment: >  > According to talk at 29c3: <http://events.ccc.de/congress/2012/Fahrplan/events/5152.en.html> >  > Quote: We also describe a vulnerability of Python's new randomized hash, allowing an attacker to easily recover the 128-bit secret seed. As a reliable fix to hash-flooding, we introduce SipHash, a family of cryptographically strong keyed hash function competitive in performance with the weak hashes, and already adopted in OpenDNS, Perl 5, Ruby, and in the Rust language.  That is exactly the vulnerability that was previously mentioned in the context of this bug. SipHash is currently the only solution for a collision-resistant fast-enough hash.  --  Giovanni Bajo ``` | | | |
| [msg178809](#msg178809) - [(view)](msg178809) | Author: Giovanni Bajo (Giovanni.Bajo) | Date: 2013-01-02 10:15 |
| ``` Il giorno 02/gen/2013, alle ore 06:52, Christian Heimes <report@bugs.python.org> ha scritto:  >  > Christian Heimes added the comment: >  > Thanks for the information! I'm working on a PEP for the issue at hand.  Since you're collecting ideas on this, I would like to stress that, in the Python 3 transition, it was deemed acceptable to switch all objects to use unicode strings for attribute names, making the hash computation of such attributes (in the context of the instance dictionary) at least twice as slow than it used to be (the 'at least' refers to the fact that longer strings might have even worse effects because of a higher number of cache misses). SipHash isn't twice as slow as the current hash function, not even for short strings.  So there is a precedent in slowing down the hash computation time in a very important use case, and it doesn't look like hell froze over. --  Giovanni Bajo ``` | | | |
| [msg178814](#msg178814) - [(view)](msg178814) | Author: Benjamin Peterson (benjamin.peterson) \* (Python committer) | Date: 2013-01-02 14:49 |
| ``` 2013/1/2 Giovanni Bajo <report@bugs.python.org>: > > Giovanni Bajo added the comment: > > Il giorno 02/gen/2013, alle ore 06:52, Christian Heimes <report@bugs.python.org> ha scritto: > >> >> Christian Heimes added the comment: >> >> Thanks for the information! I'm working on a PEP for the issue at hand. > > Since you're collecting ideas on this, I would like to stress that, in the Python 3 transition, it was deemed acceptable to switch all objects to use unicode strings for attribute names, making the hash computation of such attributes (in the context of the instance dictionary) at least twice as slow than it used to be (the 'at least' refers to the fact that longer strings might have even worse effects because of a higher number of cache misses). SipHash isn't twice as slow as the current hash function, not even for short strings. > > So there is a precedent in slowing down the hash computation time in a very important use case, and it doesn't look like hell froze over.  It's probably not to bad for attribute names because a) they're short b) they're interned c) the hash is cached. ``` | | | |
| [msg178836](#msg178836) - [(view)](msg178836) | Author: Christian Heimes (christian.heimes) \* (Python committer) | Date: 2013-01-02 18:51 |
| ``` Giovanni, why do you think that hashing of unicode strings is slower than byte strings?   First of all ASCII only unicode strings are packed and use just one byte per char. CPython's FNV implementation processes one element in each cycle, that is one byte for bytes and ASCII unicode, two bytes for UCS-2 and four bytes for UCS-4. Bytes and UCS-4 strings require the same amount of CPU instructions. ``` | | | |
| [msg178837](#msg178837) - [(view)](msg178837) | Author: Giovanni Bajo (Giovanni.Bajo) | Date: 2013-01-02 18:56 |
| ``` Il giorno 02/gen/2013, alle ore 19:51, Christian Heimes <report@bugs.python.org> ha scritto:  >  > Christian Heimes added the comment: >  > Giovanni, why do you think that hashing of unicode strings is slower than byte strings?  >  > First of all ASCII only unicode strings are packed and use just one byte per char. CPython's FNV implementation processes one element in each cycle, that is one byte for bytes and ASCII unicode, two bytes for UCS-2 and four bytes for UCS-4. Bytes and UCS-4 strings require the same amount of CPU instructions.  Ah sorry, I stand corrected (though packing wasn't there in 3.0, was it? I was specifically referred to the 2.x -> 3.0 transition). --  Giovanni Bajo  My Blog: <http://giovanni.bajo.it> ``` | | | |
| [msg178842](#msg178842) - [(view)](msg178842) | Author: Serhiy Storchaka (serhiy.storchaka) \* (Python committer) | Date: 2013-01-02 19:42 |
| ``` See microbenchmark results in [issue16427](issue16427 "[closed] Faster hash implementation"). Really hashing of ASCII/UCS1 strings more than 2x slower than bytes hashing. ``` | | | |
| [msg203506](#msg203506) - [(view)](msg203506) | Author: Christian Heimes (christian.heimes) \* (Python committer) | Date: 2013-11-20 16:50 |
| ``` The issue has been solved for Python 3.4 with the integration of [PEP 456](https://www.python.org/dev/peps/pep-0456/). ``` | | | |
| [msg205758](#msg205758) - [(view)](msg205758) | Author: Alyssa Coghlan (ncoghlan) \* (Python committer) | Date: 2013-12-10 00:29 |
| ``` This issue has belatedly had a CVE assigned: CVE-2013-7040 ("CPython hash secret can be recovered remotely")  3.4 is not affected (due to [PEP 456](https://www.python.org/dev/peps/pep-0456/)), but 3.3 and 2.7 are still affected. ``` | | | |
| [msg205759](#msg205759) - [(view)](msg205759) | Author: Benjamin Peterson (benjamin.peterson) \* (Python committer) | Date: 2013-12-10 00:34 |
| ``` I think that's just WONTFIX at this point. ``` | | | |

| History | | | |
| --- | --- | --- | --- |
| Date | User | Action | Args |
| 2022-04-11 14:57:29 | admin | set | github: 58826 |
| 2016-04-22 09:23:46 | serhiy.storchaka | set | messages: - <msg263978> |
| 2016-04-22 08:47:35 | SilentGhost | set | nosy: + [lemburg](user4), [arigo](user43), [gregory.p.smith](user252), [mark.dickinson](user1118), [ncoghlan](user1309), [vstinner](user2377), [christian.heimes](user3108), [benjamin.peterson](user4455), [iElectric](user5869), [Arfrever](user9138), [alex](user9612), [cvrebert](user10148), [dmalcolm](user11193), [Giovanni.Bajo](user13455), [PaulMcMillan](user15320), [serhiy.storchaka](user15623), [bkabrda](user15772), [Vlado.Boza](user15865), [koniiiik](user15867), [sbermeister](user16021), [camara](user16834), [pconnell](user16854), [Łukasz.Rekucki](user16928), [ReneSac](user16930), [Bob.Ziuchkovski](user16942), [dstufft](user17248), [isoschiz](user17606) |
| 2016-04-22 07:48:56 | editor-buzzfeed | set | nosy: + [editor-buzzfeed](user23805), - [lemburg](user4), [arigo](user43), [gregory.p.smith](user252), [mark.dickinson](user1118), [ncoghlan](user1309), [vstinner](user2377), [christian.heimes](user3108), [benjamin.peterson](user4455), [iElectric](user5869), [Arfrever](user9138), [alex](user9612), [cvrebert](user10148), [dmalcolm](user11193), [Giovanni.Bajo](user13455), [PaulMcMillan](user15320), [serhiy.storchaka](user15623), [bkabrda](user15772), [Vlado.Boza](user15865), [koniiiik](user15867), [sbermeister](user16021), [camara](user16834), [pconnell](user16854), [Łukasz.Rekucki](user16928), [ReneSac](user16930), [Bob.Ziuchkovski](user16942), [dstufft](user17248), [isoschiz](user17606)messages: + <msg263978> |
| 2013-12-10 00:34:45 | benjamin.peterson | set | status: open -> closedresolution: fixedmessages: + <msg205759> |
| 2013-12-10 00:29:54 | ncoghlan | set | status: pending -> openversions: + Python 2.7, Python 3.3nosy: + [bkabrda](user15772)messages: + <msg205758> |
| 2013-11-20 16:50:12 | christian.heimes | set | status: open -> pendingmessages: + <msg203506>stage: resolved |
| 2013-06-01 19:43:58 | dstufft | set | nosy: + [dstufft](user17248) |
| 2013-04-20 13:29:54 | isoschiz | set | nosy: + [pconnell](user16854), [isoschiz](user17606) |
| 2013-01-02 19:42:48 | serhiy.storchaka | set | messages: + <msg178842> |
| 2013-01-02 18:56:26 | Giovanni.Bajo | set | messages: + <msg178837> |
| 2013-01-02 18:51:52 | christian.heimes | set | messages: + <msg178836> |
| 2013-01-02 14:49:30 | benjamin.peterson | set | messages: + <msg178814> |
| 2013-01-02 10:15:43 | Giovanni.Bajo | set | messages: + <msg178809> |
| 2013-01-02 10:02:31 | Giovanni.Bajo | set | messages: + <msg178808> |
| 2013-01-02 07:08:20 | ncoghlan | set | nosy: + [ncoghlan](user1309)messages: + <msg178800> |
| 2013-01-02 05:52:45 | christian.heimes | set | assignee: [christian.heimes](user3108)messages: + <msg178798> |
| 2013-01-01 23:20:26 | iElectric | set | nosy: + [iElectric](user5869)messages: + <msg178784> |
| 2012-12-02 20:47:31 | Bob.Ziuchkovski | set | nosy: + [Bob.Ziuchkovski](user16942)messages: + <msg176808> |
| 2012-11-30 22:51:28 | lemburg | set | messages: + <msg176725> |
| 2012-11-30 21:27:24 | serhiy.storchaka | set | messages: + <msg176721> |
| 2012-11-30 21:25:54 | serhiy.storchaka | set | messages: + <msg176720> |
| 2012-11-30 20:35:39 | ReneSac | set | messages: + <msg176715> |
| 2012-11-30 20:34:37 | lemburg | set | messages: + <msg176714> |
| 2012-11-30 20:33:04 | koniiiik | set | messages: + <msg176713> |
| 2012-11-30 20:06:32 | serhiy.storchaka | set | messages: + <msg176710> |
| 2012-11-30 20:01:02 | ReneSac | set | messages: + <msg176709> |
| 2012-11-30 19:39:20 | serhiy.storchaka | set | messages: + <msg176705> |
| 2012-11-30 19:20:28 | christian.heimes | set | messages: + <msg176704> |
| 2012-11-30 18:12:10 | ReneSac | set | nosy: + [ReneSac](user16930)messages: + <msg176697> |
| 2012-11-30 07:53:28 | Łukasz.Rekucki | set | nosy: + [Łukasz.Rekucki](user16928)messages: + <msg176680> |
| 2012-11-11 11:14:30 | Giovanni.Bajo | set | messages: + <msg175345> |
| 2012-11-11 10:09:31 | vstinner | set | messages: + <msg175342> |
| 2012-11-11 04:56:29 | cvrebert | set | nosy: + [cvrebert](user10148)messages: + <msg175318> |
| 2012-11-10 22:23:39 | gregory.p.smith | set | nosy: + [gregory.p.smith](user252)messages: + <msg175299> |
| 2012-11-08 22:16:06 | christian.heimes | set | messages: + <msg175198> |
| 2012-11-08 22:10:04 | christian.heimes | set | messages: + <msg175196> |
| 2012-11-08 21:58:55 | sbermeister | set | nosy: + [sbermeister](user16021)messages: + <msg175192> |
| 2012-11-07 13:16:40 | Giovanni.Bajo | set | messages: + <msg175100> |
| 2012-11-07 13:03:05 | mark.dickinson | set | messages: + <msg175099> |
| 2012-11-07 13:02:05 | arigo | set | messages: + <msg175098> |
| 2012-11-07 12:55:50 | serhiy.storchaka | set | messages: + <msg175097> |
| 2012-11-07 12:54:59 | arigo | set | messages: + <msg175096> |
| 2012-11-07 12:40:26 | serhiy.storchaka | set | messages: + <msg175094> |
| 2012-11-07 12:19:34 | lemburg | set | messages: + <msg175091> |
| 2012-11-07 12:06:04 | mark.dickinson | set | messages: + <msg175089> |
| 2012-11-07 11:59:56 | lemburg | set | messages: + <msg175088> |
| 2012-11-07 11:55:11 | mark.dickinson | set | nosy: + [mark.dickinson](user1118)messages: + <msg175086> |
| 2012-11-07 11:53:11 | christian.heimes | set | messages: + <msg175085> |
| 2012-11-07 11:51:34 | serhiy.storchaka | set | files: + [\_Py\_Hash\_Sip24.S](file27919)messages: + <msg175083> |
| 2012-11-07 11:26:19 | Giovanni.Bajo | set | messages: + <msg175082> |
| 2012-11-07 11:19:16 | lemburg | set | messages: + <msg175081> |
| 2012-11-07 11:06:00 | arigo | set | messages: + <msg175080> |
| 2012-11-07 08:44:41 | Giovanni.Bajo | set | messages: + <msg175053> |
| 2012-11-07 08:41:38 | lemburg | set | messages: + <msg175052> |
| 2012-11-07 08:34:26 | lemburg | set | files: + [hash-attack-3.patch](file27917)keywords: + [patch](keyword2)messages: + <msg175050> |
| 2012-11-07 07:40:30 | serhiy.storchaka | set | messages: + <msg175048> |
| 2012-11-07 06:49:21 | serhiy.storchaka | set | messages: + <msg175047> |
| 2012-11-07 01:27:11 | christian.heimes | set | messages: + <msg175040> |
| 2012-11-07 00:52:07 | christian.heimes | set | messages: + <msg175038> |
| 2012-11-06 20:12:40 | serhiy.storchaka | set | messages: + <msg175007> |
| 2012-11-06 19:11:36 | christian.heimes | set | hgrepos: + hgrepo159messages: + <msg175000> |
| 2012-11-06 18:26:07 | Giovanni.Bajo | set | messages: + <msg174999> |
| 2012-11-06 17:10:45 | christian.heimes | set | messages: + <msg174998> |
| 2012-11-06 16:49:04 | christian.heimes | set | messages: + <msg174994> |
| 2012-11-06 16:29:19 | Giovanni.Bajo | set | nosy: + [Giovanni.Bajo](user13455)messages: + <msg174990> |
| 2012-11-06 16:08:03 | christian.heimes | set | messages: + <msg174989> |
| 2012-11-06 15:54:14 | christian.heimes | set | messages: + <msg174987> |
| 2012-11-06 15:44:59 | alex | set | nosy: + [alex](user9612) |
| 2012-11-06 15:44:42 | camara | set | nosy: + [camara](user16834)messages: + <msg174986> |
| 2012-11-06 15:04:42 | benjamin.peterson | set | messages: + <msg174973> |
| 2012-11-06 14:10:27 | arigo | set | messages: + <msg174964> |
| 2012-10-22 06:48:48 | lemburg | set | nosy: + [lemburg](user4)messages: + <msg173498> |
| 2012-10-21 22:46:31 | serhiy.storchaka | set | nosy: + [serhiy.storchaka](user15623)messages: + <msg173491> |
| 2012-10-21 21:42:53 | vstinner | set | messages: + <msg173488> |
| 2012-10-21 16:33:51 | christian.heimes | set | messages: + <msg173461> |
| 2012-10-21 15:39:43 | benjamin.peterson | set | keywords: - [easy](keyword6)messages: + <msg173458> |
| 2012-10-21 15:35:29 | arigo | set | keywords: + [easy](keyword6)messages: + <msg173457> |
| 2012-10-21 15:28:08 | arigo | set | nosy: + [arigo](user43)messages: + <msg173455> |
| 2012-10-17 16:53:31 | christian.heimes | set | messages: + <msg173185> |
| 2012-10-11 23:14:36 | christian.heimes | set | nosy: + [christian.heimes](user3108) |
| 2012-04-26 23:10:43 | vstinner | set | messages: + <msg159434> |
| 2012-04-26 23:08:55 | benjamin.peterson | set | nosy: + [benjamin.peterson](user4455)messages: + <msg159433> |
| 2012-04-26 22:58:42 | vstinner | set | files: + [hash.py](file25375)messages: + <msg159431> |
| 2012-04-26 22:58:24 | vstinner | set | files: - [hash.py](file25282) |
| 2012-04-26 22:47:54 | vstinner | set | messages: + <msg159430> |
| 2012-04-20 17:44:06 | Vlado.Boza | set | messages: + <msg158860> |
| 2012-04-20 00:52:15 | Arfrever | set | nosy: + [Arfrever](user9138) |
| 2012-04-20 00:43:36 | vstinner | set | files: + [hash.py](file25282)messages: + <msg158790> |
| 2012-04-20 00:21:15 | Vlado.Boza | set | messages: + <msg158785> |
| 2012-04-20 00:08:30 | koniiiik | set | messages: + <msg158784> |
| 2012-04-20 00:05:56 | vstinner | set | messages: + <msg158783> |
| 2012-04-19 23:59:47 | dmalcolm | set | messages: + <msg158781> |
| 2012-04-19 23:58:15 | Vlado.Boza | set | messages: + <msg158780> |
| 2012-04-19 23:53:19 | Vlado.Boza | set | messages: + <msg158778> |
| 2012-04-19 23:26:32 | vstinner | set | files: + [find\_hash\_collision.py](file25281)messages: + <msg158773> |
| 2012-04-19 22:40:48 | pitrou | set | nosy: + [PaulMcMillan](user15320) |
| 2012-04-19 21:31:07 | dmalcolm | set | messages: + <msg158759> |
| 2012-04-19 21:23:32 | pitrou | set | nosy: + [vstinner](user2377) |
| 2012-04-19 21:07:35 | koniiiik | set | nosy: + [koniiiik](user15867) |
| 2012-04-19 20:44:58 | dmalcolm | set | nosy: + [dmalcolm](user11193) |
| 2012-04-19 20:40:35 | Vlado.Boza | set | messages: + <msg158744> |
| 2012-04-19 17:58:09 | Vlado.Boza | create |  |

Supported by [The Python Software Foundation](https://python.org/psf-landing/ "The Python Software Foundation"),

Powered by [Roundup](http://roundup.sourceforge.net "Powered by the Roundup Issue Tracker")

Copyright © 1990-2022, [Python Software Foundation](http://python.org/psf)


