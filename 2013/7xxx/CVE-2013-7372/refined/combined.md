=== Content from bitcoin.org_4ce1245f_20250125_062933.html ===

![Close](/img/icons/ico_close.svg?1736694469)

Bitcoin.org is a community funded project, donations are appreciated and used to improve the website.

Make a donation

Bitcoin.org needs your support!

Ã

Donate to Bitcoin.org

Use this QR code or address below

bc1qx3u4njquj0ux63030r4nat8awqrlm0x2zlt96h

$50.00
(... BTC)

$100.00
(... BTC)

$200.00
(... BTC)

[![Bitcoin](/img/icons/logotop.svg?1736694469)](/en/)

* Introduction
  + [Individuals](/en/bitcoin-for-individuals)
  + [Businesses](/en/bitcoin-for-businesses)
  + [Developers](https://developer.bitcoin.org/)
  + [Getting started](/en/getting-started)
  + [How it works](/en/how-it-works)
  + [White paper](/en/bitcoin-paper)
* Resources
  + [Resources](/en/resources)+ [Exchanges](/en/exchanges)
    + [Community](/en/community)
    + [Documentation](https://developer.bitcoin.org/)
    + [Vocabulary](/en/vocabulary)
    + [Events](/en/events)
    + [Bitcoin Core](/en/bitcoin-core/)
* [Innovation](/en/innovation)
* Participate
  + [Support Bitcoin](/en/support-bitcoin)+ [Buy Bitcoin](/en/buy)
    + [Running a full node](/en/full-node)
    + [Development](/en/development)
* [FAQ](/en/faq)

* English
  + - [Bahasa Indonesia](/id/)
    - [CatalÃ](/ca/)
    - [Dansk](/da/)
    - [Deutsch](/de/)
    - [English](/en/)
    - [EspaÃ±ol](/es/)
    - [FranÃ§ais](/fr/)
    - [Italiano](/it/)
    - [Magyar](/hu/)
    - [Nederlands](/nl/)
    - [Polski](/pl/)
    - [PortuguÃªs Brasil](/pt_BR/)
    - [RomÃ¢nÄ](/ro/)
    - [SlovenÅ¡Äina](/sl/)
    - [Srpski](/sr/)
    - [Svenska](/sv/)
  + - [TÃ¼rkÃ§e](/tr/)
    - [ÎÎ»Î»Î·Î½Î¹ÎºÎ¬](/el/)
    - [Ð±ÑÐ»Ð³Ð°ÑÑÐºÐ¸](/bg/)
    - [Ð ÑÑÑÐºÐ¸Ð¹](/ru/)
    - [Ð£ÐºÑÐ°ÑÐ½ÑÑÐºÐ°](/uk/)
    - [ÕÕ¡ÕµÕ¥ÖÕ¥Õ¶](/hy/)
    - [Ø§ÙØ¹Ø±Ø¨ÙØ©](/ar/)
    - [ÙØ§Ø±Ø³Û](/fa/)
    - [×¢××¨××ª](/he/)
    - [à¤¹à¤¿à¤¨à¥à¤¦à¥](/hi/)
    - [íêµ­ì´](/ko/)
    - [ááááá](/km/)
    - [æ¥æ¬èª](/ja/)
    - [ç®ä½ä¸­æ](/zh_CN/)
    - [ç¹é«ä¸­æ](/zh_TW/)

Bahasa Indonesia
CatalÃ
Dansk
Deutsch
English
EspaÃ±ol
FranÃ§ais
Italiano
Magyar
Nederlands
Polski
PortuguÃªs Brasil
RomÃ¢nÄ
SlovenÅ¡Äina
Srpski
Svenska
TÃ¼rkÃ§e
ÎÎ»Î»Î·Î½Î¹ÎºÎ¬
Ð±ÑÐ»Ð³Ð°ÑÑÐºÐ¸
Ð ÑÑÑÐºÐ¸Ð¹
Ð£ÐºÑÐ°ÑÐ½ÑÑÐºÐ°
ÕÕ¡ÕµÕ¥ÖÕ¥Õ¶
Ø§ÙØ¹Ø±Ø¨ÙØ©
ÙØ§Ø±Ø³Û
×¢××¨××ª
à¤¹à¤¿à¤¨à¥à¤¦à¥
íêµ­ì´
ááááá
æ¥æ¬èª
ç®ä½ä¸­æ
ç¹é«ä¸­æ

Language: en

[Network alerts history](/en/alerts)
|
[![rss](/img/icons/header_rss.svg?1736694469) Subscribe to RSS feed](/en/rss/alerts.rss)
|
[Post history](https://github.com/bitcoin-dot-org/bitcoin.org/commits/master/_alerts/2013-08-11-android.html)
|
[Report issue](https://github.com/bitcoin-dot-org/bitcoin.org/issues/new?body=Source%20File%3A%20_alerts/2013-08-11-android.html%0A%0A)

# Android Security Vulnerability

11 August 2013

## What happened

We recently learned that a component of Android responsible for generating secure random numbers contains [critical weaknesses](http://android-developers.blogspot.com.au/2013/08/some-securerandom-thoughts.html), that render all Android wallets generated to date vulnerable to theft. Because the problem lies with Android itself, this problem will affect you if you have a wallet generated by any Android app. An incomplete list would be [Bitcoin Wallet](https://play.google.com/store/apps/details?id=de.schildbach.wallet), [blockchain.info](https://play.google.com/store/apps/details?id=piuk.blockchain.android) wallet, [BitcoinSpinner](https://play.google.com/store/apps/details?id=com.miracleas.bitcoin_spinner) and [Mycelium Wallet](https://play.google.com/store/apps/details?id=com.mycelium.wallet). Apps where you don't control the private keys at all are not affected. For example, exchange frontends like the Coinbase or Mt Gox apps are not impacted by this issue because the private keys are not generated on your Android phone.

## What has been done

Updates have been prepared for the following wallet apps:

* **[Bitcoin Wallet](https://play.google.com/store/apps/details?id=de.schildbach.wallet)**: Update 3.15 can be installed from [Google Play](https://play.google.com/store/apps/details?id=de.schildbach.wallet) or [Google Code](https://code.google.com/p/bitcoin-wallet/downloads/list). Key rotation will occur automatically soon after you upgrade. The old addresses will be marked as insecure in your address book. You will need to make a fresh backup.
* **[BitcoinSpinner](https://play.google.com/store/apps/details?id=com.miracleas.bitcoin_spinner)**: Update 0.8.3b can be installed from [Google Play](https://play.google.com/store/apps/details?id=com.miracleas.bitcoin_spinner) or [Google Code](https://code.google.com/p/bitcoinspinner/downloads/list). On startup it will advise you on how to proceed.
* **[Mycelium Bitcoin Wallet](https://play.google.com/store/apps/details?id=com.mycelium.wallet)**: Update 0.7.0 can be installed from [Google Play](https://play.google.com/store/apps/details?id=com.mycelium.wallet) or [mycelium.com](http://mycelium.com/). A wizard will guide you through the process of moving your bitcoins to newly generated addresses, and put the old keys into archive mode.
* **[blockchain.info](https://play.google.com/store/apps/details?id=piuk.blockchain.android)**: Update 3.54 can be installed from [Google Play](https://play.google.com/store/apps/details?id=piuk.blockchain.android). Version 3.54 and above includes an automatic re-keying wizard. Simply update to the latest version and follow the onscreen instructions. Please make a fresh wallet backup after the process completes.

## What you should do

In order to re-secure existing wallets, key rotation is necessary. This involves generating a new address with a repaired random number generator and then sending all the money in your wallet back to yourself. If you use an Android wallet then we strongly recommend you to upgrade to the latest version available in the Play Store as soon as one becomes available. Once your wallet is rotated, you will need to contact anyone who has stored addresses generated by your phone and give them a new one.

If you can't update your Android app, alternatively, you can send your bitcoins to a Bitcoin wallet on your computer until your
Android app can be updated. You should make sure not to send back your bitcoins to your old insecure addresses.

*This notice last updated: Tue, 13 Aug 2013 13:51:00 UTC*

[![Bitcoin](/img/icons/logo-footer.svg?1736694469)](/en/)
Support Bitcoin.org:
Donate

bc1qx3u4njquj0ux63030r4nat8awqrlm0x2zlt96h

Introduction:

* [Individuals](/en/bitcoin-for-individuals)
* [Businesses](/en/bitcoin-for-businesses)
* [Developers](https://developer.bitcoin.org/)
* [Getting started](/en/getting-started)
* [How it works](/en/how-it-works)
* [You need to know](/en/you-need-to-know)
* [White paper](/en/bitcoin-paper)

Resources:

* [Resources](/en/resources)* [Exchanges](/en/exchanges)
  * [Community](/en/community)
  * [Vocabulary](/en/vocabulary)
  * [Events](/en/events)
  * [Bitcoin Core](/en/bitcoin-core/)

Participate:

* [Support Bitcoin](/en/support-bitcoin)* [Buy Bitcoin](/en/buy)
  * [Running a full node](/en/full-node)
  * [Development](/en/development)

Other:

[Avoid Scams](/en/scams)
[Legal](/en/legal)
[Privacy Policy](/en/privacy)
[Press](/en/press)
[About bitcoin.org](/en/about-us)
[Blog](/en/blog)

Â© Bitcoin Project 2009-2025 Released under the [MIT license](http://opensource.org/licenses/mit-license.php)
[Network Status](/en/alerts)

* English
  + - [Bahasa Indonesia](/id/)
    - [CatalÃ](/ca/)
    - [Dansk](/da/)
    - [Deutsch](/de/)
    - [English](/en/)
    - [EspaÃ±ol](/es/)
    - [FranÃ§ais](/fr/)
    - [Italiano](/it/)
    - [Magyar](/hu/)
    - [Nederlands](/nl/)
    - [Polski](/pl/)
    - [PortuguÃªs Brasil](/pt_BR/)
    - [RomÃ¢nÄ](/ro/)
    - [SlovenÅ¡Äina](/sl/)
    - [Srpski](/sr/)
    - [Svenska](/sv/)
  + - [TÃ¼rkÃ§e](/tr/)
    - [ÎÎ»Î»Î·Î½Î¹ÎºÎ¬](/el/)
    - [Ð±ÑÐ»Ð³Ð°ÑÑÐºÐ¸](/bg/)
    - [Ð ÑÑÑÐºÐ¸Ð¹](/ru/)
    - [Ð£ÐºÑÐ°ÑÐ½ÑÑÐºÐ°](/uk/)
    - [ÕÕ¡ÕµÕ¥ÖÕ¥Õ¶](/hy/)
    - [Ø§ÙØ¹Ø±Ø¨ÙØ©](/ar/)
    - [ÙØ§Ø±Ø³Û](/fa/)
    - [×¢××¨××ª](/he/)
    - [à¤¹à¤¿à¤¨à¥à¤¦à¥](/hi/)
    - [íêµ­ì´](/ko/)
    - [ááááá](/km/)
    - [æ¥æ¬èª](/ja/)
    - [ç®ä½ä¸­æ](/zh_CN/)
    - [ç¹é«ä¸­æ](/zh_TW/)

Bahasa Indonesia
CatalÃ
Dansk
Deutsch
English
EspaÃ±ol
FranÃ§ais
Italiano
Magyar
Nederlands
Polski
PortuguÃªs Brasil
RomÃ¢nÄ
SlovenÅ¡Äina
Srpski
Svenska
TÃ¼rkÃ§e
ÎÎ»Î»Î·Î½Î¹ÎºÎ¬
Ð±ÑÐ»Ð³Ð°ÑÑÐºÐ¸
Ð ÑÑÑÐºÐ¸Ð¹
Ð£ÐºÑÐ°ÑÐ½ÑÑÐºÐ°
ÕÕ¡ÕµÕ¥ÖÕ¥Õ¶
Ø§ÙØ¹Ø±Ø¨ÙØ©
ÙØ§Ø±Ø³Û
×¢××¨××ª
à¤¹à¤¿à¤¨à¥à¤¦à¥
íêµ­ì´
ááááá
æ¥æ¬èª
ç®ä½ä¸­æ
ç¹é«ä¸­æ

en



=== Content from www.nds.rub.de_5143a48a_20250125_062932.html ===
Randomly Failed!
The State of Randomness in Current Java
Implementations

Kai Michaelis, Christopher Meyer, and J¨org Schwenk
{kai.michaelis, christopher.meyer, joerg.schwenk}@rub.de

Horst G¨ortz Institute for IT-Security, Ruhr-University Bochum

Abstract. This paper investigates the Randomness of several Java Run-
time Libraries by inspecting the integrated Pseudo Random Number
Generators. Signiﬁcant weaknesses in diﬀerent libraries including An-
droid, are uncovered.

1

Introduction

With a market share of 33-50% [1], [2], [3] Android is currently the most
popular mobile OS. Each of the 331-400 million sold devices (cf. [3])
is able to run Java applications written in Java. Java provides inter-
faces for diﬀerent Pseudo Random Number Generators (PRNGs), such
as SecureRandom, which is intended for use by cryptographic schemes.
But, only the API is speciﬁed - each library implements own algorithms.
Designing secure and reliable PRNGs is a hard and complicated task [4],
as well as implementing these algorithms correctly. One of the worst ideas
is to implement own unproved PRNG constructs.

This paper examines the quality of the random numbers generated by
common Java libraries. In detail, the PRNGs, intended for use in cryp-
tographic environments, of Apache Harmony1, GNU Classpath2, Open-
JDK3 and BouncyCastle4 are inspected. It is shown that the over-all
entropy of the Android PRNG can be reduced to 64 bits. Beyond this,
multiple weaknesses of entropy collectors are revealed. However, some of
these weaknesses only occur under special conditions (e.g., unavailable
/dev/{u}random device). We clearly point out that we are not going to
discuss the quality of random numbers generated by PRNGs shipped with
Operating Systems (OS). Discussions of OS provided (P)RNG facilities
can be found at e.g.,

[5], [6], [7].

1 http://harmony.apache.org/
2 http://www.gnu.org/software/classpath/
3 http://openjdk.java.net/
4 http://www.bouncycastle.org/

2 Related Work

Problems related to weak pseudo random number generators (PRNGs)
have been topic of several previously published papers. In 2012 Argyros
and Kiayias investigated in [8] the state of PRNGs in PHP5 and out-
lined ﬂaws leading to attack vectors. Their results are based on insecure
constructions of PRNGs introduced by custom algorithms.

Kopf outlined in [9] multiple cryptographic and implementational
ﬂaws in widespread Content Management Systems (CMS). These obser-
vations focused weak cryptographic constructs and pecularities of PHP.
The resulting bugs are not caused by weak PRNGs, but by vulnerable
custom algorithms in combination with implementational ﬂaws.

Meyer and Somorovsky [10] uncovered a vulnerable use of Secure-
Random in WSS4J6. A function responsible for nonce generation, used at
various places in the framework, suﬀered from weak PRNG seeding.

Problems related to PRNGs are also topic of multiple CWEs (Com-
mon Weakness Enumeration)7 that deal with the misuse or use of weak
pseudo random number generators (cf. CWE 330-343).

In [11]) Lenstra et al. inspected millions of public keys of diﬀerent
types (RSA, DSA, ElGamal and ECDSA) and found keys violating basic
principles for secure cryptographic parameters. According to the authors
these weak keys could be a result of poorly seeded PRNGs.

More alarming results concerning key quality are presented by Heninger
et al. in [7] pointing out that ”Randomness is essential for modern cryp-
tography”. Missing entropy was identiﬁed as a root cause for many weak
and vulnerable keys. Additionally, the authors identiﬁed weak entropy
problems under certain conditions in the Linux RNG.

A more theory based cryptanalytic set of attacks on PRNGs can be

found at e.g., [12].

2.1 Contribution

The results of this paper focus on PRNG implementations of Java core
libraries. Even thus all libraries implement the same functionality - gener-
ating (pseudo) random numbers - based on the same API, the algorithms
for random number generation diﬀer from library to library.

5 http://www.php.net
6 http://ws.apache.org/wss4j/
7 http://cwe.mitre.org

The main contribution is an analysis of algorithms implemented in
most commonly used SecureRandom generators. For this analysis tests
provided by the Dieharder [13] and STS [14] testsuites are used to check
for cryptographic weaknesses. Additionally manual code analysis uncov-
ered algorithmical and implementational vulnerabilities.

3

Implementations & Algorithms

In Java, random numbers are derived from an initial seed. Two instances
of a PRNG seeded with equal values always generate equal random se-
quences. The cryptographic strong PRNGs are accessed via the Secure-
Random interface which is part of the Java Cryptography Architecture.

3.1 Apache Harmony - Android’s version of SecureRandom

Apache Harmony, introduced in 2005 as an open source implementation
of the Java Core Libraries published under the Apache License8, became
obsolete with the publication of SUN Microsystems’ reference implemen-
tation in 2006. Although discontinued since 2011, the project is further
devleoped as part of Google’s Android platform.

1 // require cnt: counter >= 0, state: seed bytes and iv: previous output
2 iv = sha1(iv,concat(state ,cnt)) ;
3 cnt = cnt + 1;
4 return iv;

Listing 1.1. Apache Harmony’s SecureRandom

The PRNG shipped with Android uses the SHA-1 [15] hash algorithm
to generate pseudo random sequences and is ideally seeded by the random
devices provided by the OS. Random numbers are generated by calculat-
ing hash sums of an internal state concatenated with a 64 bit integer
counter and a padding (algorithm in Listing 1.1). The counter is, starting
at zero, incremented each run of the algorithm. Additionally, a padding
is required to ﬁll remaining bits of a 85 bytes buﬀer. This padding fol-
lows the SHA-1 padding scheme: The last 64 bits hold the length len of
the values to be hashed in bits. Any space between the end of the values
and the length ﬁeld is ﬁlled with a single ’1’ bit followed by zeros. The
resulting hash sums are returned as pseudo random sequence. Figure 1
illustrates the state buﬀer.

8 http://www.apache.org/licenses/

20 byte seed ( 5 * 32 bit words)

8 byte counter

57 byte padding

i.

ii.

s0

s0

s1

s1

s2

s2

s3

s3

s4

s4

0 · · · 0

cnt0

cnt1

10 · · · 0

len

Fig. 1. The seed bytes s0, .., s4 in row i concatenated with a 64 bit counter c0, c1 (two
32bit words), padding bits and the length len as in row ii are hashed repeatedly to
generate a stream of pseudorandom bytes.

3.2 GNU Classpath

The GNU Classpath project started in 1998 as the ﬁrst open source im-
plementation of Java’s core libraries. The library is licensed under GPL 9
and is e.g., partly used by the IcedTea 10 project.

1 // require state : <= 512 bit buﬀer, iv : current Initialzation Vector
2 byte[] output = sha1(iv,state) ;
3 state = concat(state,output);
4 if (state .length > 512) {
5
6
7
8 }
9 return output;

iv = sha(iv,state [0:512]) ;
state = state[512:−1];
output = sha1(iv,state) ;

// in bits
// ﬁrst 512 bits
// rest

Listing 1.2. GNU Classpath’s SecureRandom

The SecureRandom implementation (algorithm in Listing 1.2) of GNU
Classpath is powered by a class MDGenerator that is parameterized with
an arbitrary hash algorithm. A new SecureRandom instance is seeded with
32 bytes yielding an internal state as shown in row i of Figure 2. Based
on this start value a digest is computed. The resulting hash (e.g. 160 bit
in case of SHA-1) is returned as pseudo random value r0. r0 in turn is
concatenated with the former seed forming the new state in row ii.
These bytes are hashed again yielding the second output r1. Finally, the
seed concatenated with the previous two hash values form the new state
(c.f. row iii) whose digest is the third output value r3. r3 is again appended
to the previous state resulting in the state illustrated in row iv. Each
fourth ri values a block overﬂow happens causing the implementation to
hash the full block and use this hash as initialization vector (IV) for the
new block. The only unknown value is the 32 byte long initial seed. All
other information are known (as they are parts of former ri value).

9 http://www.gnu.org/licenses/
10 http://icedtea.classpath.org/wiki/Main_Page

Block 1 (64 byte)

Block 2 (64 byte)

i.

ii.

iii.

iv.

seed

seed

seed

seed

pad

r0

r0

r0

pad

r1h

r1h

r1l

r1l

pad

r2

pad

Fig. 2. Hashing the previous pseudo random bytes concatenated with the fomer seed
produces the next output value.

GNU Classpath includes a “backup” seeding facility (algorithm in
Listing 1.3) for Unix-like operating systems. The VMSecureRandom class
is able to harvest entropy from the OS’ process scheduler. Every call to
the seeding facility starts 8 threads, each one incrementing a looped one
byte counter. The parent thread waits until at least one of the 8 threads is
picked up by the scheduler. The seed value is calculated by XORing each
of the one byte counters. This forms the ﬁrst seed byte. Accordingly, the
next seed byte is generated the same way. When the requested amount
of seeding material is gathered the threads are stopped.

1 int n = 0
2 byte[] S = new byte[8];
3 byte[] output = new byte[32];
4
5 for(int i = 0; i < 8; i++) {
6
7
8 }
9

S[ i ] = start thread(n); // ‘‘ spinner ’’ incrementing a counter starting at n
n = (2∗n) % pow(2,32);

output[i ] = 0;

10 while(!spinners running())
11
wait() ;
12
13 for(int i = 0; i < 32; i++) {
14
15
16
17
18 }
19
20 for(int i = 0; i < 8; i++)
21
22
23 return output;

stop thread(S[ i ]) ;

for(int j = 0; j < 8; j++)

output[i ] = output[i] ˆ counter(S[j ]) ;

Listing 1.3. GNU Classpath’s entropy collector

3.3 OpenJDK

As the direct successor of the Java Development Kit (JDK), OpenJDK 11
provides not only Java core libraries, but additionally a Java compiler
and a virtual machine. OpenJDK is the oﬃcial reference implementation
of Java and open source licensed under GPL. The project is supported
by major vendors such as IBM or SAP.

1 // require state : seed bytes , iv : SHA−1 standard IV
2 byte[] output = sha1(iv,state) ;
3 byte[] new state = (state + output + 1) % pow(2,160);
4
5 if (state == new state)
6
7 else
8
9

state = (new state + 1) % pow(2,160);

state = new state;

10 return output;

Listing 1.4. OpenJDK’s SecureRandom

OpenJDK uses the OS’ PRNG in conjunction with a similar scheme
as the previously mentioned libraries (algorithm in Listing 1.4). An initial
160 bit seed value is hashed using SHA-1. The result is XORed with the
output of the OS speciﬁc PRNG and returned as pseudo random bytes.
This output is added to the initial seed plus 1 modulo 2160. An additional
check compares the new seed to the old one preventing the function from
getting trapped in a ﬁxed state where si + SHA-1(si) + 1 ≡ si mod 2160.

Fig. 3. SecureRandom of OpenJDK. In each step the current state (seed) si is com-
pressed yielding output oi. The sum of oi, si−1 and 1 give new state si+1.

The integrated entropy collector (cf. Listing 1.5) uses multiple threads
to gather randomness. In contrast to GNU Classpath, only one thread
increments a counter. Subsequently, new threads are started suspending
ﬁve times for 50ms to keep the scheduler busy. Before continuing the
lower 8 bits of the current counter value pass an S-Box. The XOR sum of
all 5 counters is returned as random byte. The entropy collector enforces
mandatory runtime (250ms) and counter value (64000). Even after enough

11 http://openjdk.java.net/

seed is produced the entropy collector continues to run. The seed bytes
are hashed together with entries of System.properties and the result is
used as seed.

start thread () // loops 5 times, sleeping 50ms each
latch = 0;
t = time();

// repeat for 250ms

1 counter = 0;
2 quanta = 0;
3 v = 0;
4
5 while(counter < 64000 && quanta < 6) {
6
7
8
9
10
11
12
13
14
15
16 }
17
18 return v;

counter = counter + latch;
v = v ˆ SBox[latch % 255];
quanta = quanta + 1;

while(time() − t < 250ms)
latch = latch + 1;

Listing 1.5. OpenJDK’s entropy collector

3.4 The Legion of Bouncy Castle

Bouncy Castle is not a complete core library, but a security framework for
the Java platform. This includes a SecurityProvider as well as crypto-
graphic APIs for standalone usage. The project provides enhanced func-
tionality, as well as support for a broader range of cryptographic algo-
rithms compared to default OpenJDK. Bouncy Castle implements var-
ious pseudo random generators as well as a threaded entropy collector
akin of the one in OpenJDK.

The DigestRandomGenerator (cf. Listing 1.6) uses a cryptographic
hash algorithm to generate a pseudorandom sequence by hashing an
internal secret state of 160 bits with a 64 bit state counter producing
160 bits of pseudorandom output at once. After each hash operation the
state counter is incremented. The initial secret state is received from a
seeding facility. Every tenth hash operation on the state, a 64 bit seed
counter is incremented and a new secret state is generated by hashing
the current state concatenated with the seed counter. This new secret
state replaces the old one, where the state counter remains at its pre-
vious value. When another pseudorandom value is requested from the
DigestRandomGenerator instance, this new secret state is hashed with
the state counter, producing a cryptographic checksum to be returned to
the caller as random byte array.

1 // require seedBuﬀer: 160bit seed , stateBuﬀer : 160bit array, seedCounter and

stateCounter: 64bit integers

stateBuﬀer = sha1(iv,concat(seedBuﬀer,seedCounter));
seedCounter += 1;

2
3 if (stateCounter % 10 == 0) {
4
5
6 }
7
8 byte[] output = sha1(iv,concat(stateBuﬀer,stateCounter));
9 stateCounter++;

10
11 return output;

Listing 1.6. DigestRandomGenerator

The VMPCRandomGenerator is based on Bartosz Zoltak’s Variable Mod-

iﬁed Permutation Composition one-way function [16].

The ThreadedSeedGenerator implements a threaded entropy collec-
tor scheme. Only two threads are used: one thread increments a counter
in a loop, whereas the other waits 1ms until the counter has changed.
The new value is appended to an output array. The incrementing thread
is teared down after all random bytes are collected. The generator oﬀers
two modes of operation: a) “slow” mode where only the least signiﬁcant
bit of every byte is used and b) “fast” mode where the whole byte is used.

1 // require count: number of seed bytes needed, fast : enable ”fast” mode
2 byte[] output = byte[count];
3 t = start thread() // increments a counter in a loop
4 int last = 0;
5
6 // use bits in ”slow” mode
7 if (! fast )
8
9

count ∗= 8;

last = counter(t);
if ( fast )

10 for(int i = 0; i < count; i++) {
while(counter(t) == last)
11
12
sleep (1) ;
13
14
15
16
17
18
19
20 }
21 stop thread(t) ;
22 return output;

else

output[i ] = (byte)last;

output[i/8] = (last % 2) | (output[i/8] << 1);

Listing 1.7. ThreadedSeedGenerator

4 Methodology

Manual code review was performed for each of the introduced PRNGs.
During code review the code was checked for implementation ﬂaws and
obvious bugs. Aside from code review blackbox tests on the output were
preformed to grade the entropy. For this the Dieharder test suite [13] for
(pseudo) random number generators was used, as well as Monobit, Runs,
and Serial tests from the STS [14] suite.

While these tests can not replace cryptanalysis they still uncover bias
and dependency in the pseudo random sequence. For every test exists
an expected distribution of outcomes. Test runs produce a value that is
compared to the theoretical outcome. A p-value, describing the proba-
bility that a real RNG would produce this outcome, between 0 and 1 is
computed. A p-value below a ﬁxed signiﬁcance level α = 0.001 indicates
a failure of the PRNG with probability 1 − α. Dieharder diﬀers from this
methodology as it relies on multiple p-values to evaluate the quality of a
PRNG. It is possible (and expected) for a good RNG to produce “failing”
p-values. Instead of grading a single outcome, 100 p-values are computed
and the distribution of these values is compared to an uniform one. This
generates a ﬁnal p-value grading the quality of the PRNG.

No cryptanalysis was performed - we analyzed the algorithms and
evaluated the quality of randomness by using special purpose testsuites.

5 Results

This section highlights prospective weaknesses of the implementations
and evaluates the quality of generated randomness. Due to space limita-
tions, only conditions targeting the observed weaknesses are regarded -
the statistical graphs can be found in the Appendix in Section 7.

Striking about all implementations of SecureRandom is the limited
state size. In OpenJDK and GNU Classpath adding more entropy (>
160bit) to an instance will not enhance security. This limitation is alarm-
ing, since it renders the PRNGs useless for key generation > 160 bit (as
e.g., in AES’ case). Only Apache Harmony relies on a 512 bit buﬀer.

5.1 Apache Harmony

Apache Harmony revealed multiple weaknesses caused by implementation
bugs. As a part of Android a plethora of cryptographic functions [17] rely
on this PRNG. One of the bugs addresses directly the Android platform,
where as the second one only targets Apache Harmony.

Weaknesses. FIRST - When creating a self seeding SecureRandom
instance (by calling the constructor without arguments and subsequent
setSeed() call), the code fails to adjust the byte oﬀset (a pointer into the
state buﬀer) after inserting a start value. This causes the 64 bit counter
and the beginning of the padding (a 32 bit word) to overwrite parts of the
seed instead of appending to it. The remaining 64 bits of entropy render
the PRNG useless for cryptographic applications12.

20 byte seed (== 5 * 32 bit words)

8 byte counter

57 byte padding

ii.

s0

s1

s2

iii.

cnt0

cnt1 10 · · · 0

s3

s3

s4

s4

cnt0

cnt1

10 · · · 0

0 · · · 0

len

len

Fig. 4. Instead of appending (c.f. row ii), the counter and the succeeding padding
overwrite a portion of the seed, yielding row iii.

SECOND 13 - When running under a Unix-like OS a new SecureRandom
instance is seeded with 20 bytes from the urandom or random device. If
both are unaccessible the implementation provides a fall-back seeding fa-
cility (cf. Listing 1.8): seed is gathered from the random() PRNG of the
GNU C library, which is seeded it via srandom() with the UNIX-time,
processor time and the pointer value of a heap-allocated buﬀer. After
seeding, random() is used to generate seed bytes for SecureRandom. Be-
fore these bytes are returned the most signiﬁcant bit is set to zero ( mod
128) - this behavior is neither documented, expected nor explained.

1 char ∗seed = malloc(20);
2 srandom(clock() ∗ time() ∗ malloc()) % pow(2,31));
3 for(int i = 0; i < 20; i++)
4
5
6 return seed;

seed[ i ] = random() % 128;

Listing 1.8. Apache Harmony’s getUnixSystemRandom

The missing entropy is not compensated (e.g., by requesting > 20
bytes). As a consequence, the eﬀective seed of a SecureRandom instance
is only 7/8 for each requested byte, degrading security (of only 64 bits
due to the ﬁrst bug) by another 8 bits to 56 bits (s3 and s4 are 2 * 32 bit
words == 8 byte). Even worse, the argument of srandom() in the GNU
C library is of type unsigned int while Harmony reduces the argument
modulo INT MAX (deﬁned in limits.h) - the maximum value for signed ints.
This limits the entropy of a single call to the seeding facility to 31 bits.

12 The bug was communicated to the Google Security Team.
13 This bug is not part of the Android Source

Quality of entropy collectors. Generating 10MiB of seed - two
consecutive bytes are interpreted as a single point - lead to the chart in
Figure 9. It shows a lack of values above 127 in each direction. This test
targets the second bug. The ﬁrst bug limits the security to 64/56 bit,
depending on the seeding source. This seed space of only 264 elements is
within reach of Brute-Force attacks utilizing GPGPUs/FPGAs (cf. [15]).

5.2 GNU Classpath

The library’s entropy collector revealed inconsistencies regarding normal
distribution of the output bits which could result in vulnerabilities.

Weaknesses. - The implementation of GNU Classpath contains a
signiﬁcant weakness related to internal states. As long as a new generated
random value concatenated with the previous state does not overﬂow the
current block, all hash computations are done with the same IV. States
in rows i and ii from Figure 2 are both hashed with the SHA-1 standard
IV. The obtained state in row iii overﬂows the ﬁrst block - the hash value
of this ﬁrst block is used as input for the hash of the second block in row
iii and as IV for the succeeding computation of r1l|r2 concatenated with
r3. The state is reduced from 32 bytes seed to only 20 unkown IV bytes.

Fig. 5. Schematic view of a single SHA-1 iteration. Values in the dotted boxes are
known when used in the SecureRandom class from GNU Classpath.

The IV is the only unknown value. To break the algorithm an attacker
has to discover the IV for a known message producing a known checksum.
While no such attack on SHA-1 has been published yet, this scenario is
diﬀerent from a preimage attack (c.f., [18], [19]). The compression function
in SHA-1, ignoring the ﬁnal 32 bit additions is invertible(c.f.,
[20]) for a
given message. Thus, the addition of the secret IV (see Figure 5) remains
the only hurdle in breaking the implementation.

Quality of entropy collectors. The seeding facility harvests entropy
from multiple threads competing for CPU time. While the behaviour of
the scheduler is diﬃcult to predict it is possible to inﬂuence it. Only one
of eight threads is expected to be scheduled. During seed extraction this
precondition is not checked, enabling an attacker to ﬁll (parts) of the
output array with identical values by preventing threads to run (e.g., by
creating high process load).

To test this construction under worst conditions, 11GiB of seed val-
ues were generated. To simulate high load 8 processes were run simulta-
neously. Each process queried for 16384 bytes while iterating in a loop.
At ﬁrst inspection, the resulting random seed revealed large (up to 2800
bytes) “holes” where random bytes were equal. As a result, the algorithm
did not pass any blackbox tests. While the test conditions were extreme,
they still expose a weakness in this entropy harvester.

The ﬁrst 10MiB of seed are sampled on a graph (c.f., Figures 10). As
can be seen, Classpath was unable to ﬁll the whole space, leaving 64 by
64 large patches in the second and forth quadrant, as well as 32 by 32
along the diagonal when running under heavy load. In contrast, under
normal conditions the entropy collector produced a well-balanced pane.

5.3 OpenJDK

The overall impression of SecureRandom’s reference implementation sug-
gests a thoughtful and mature implementation.

Weaknesses. Code review bared no obvious weaknesses. Still, if an
attacker is able to learn any internal state (si in Figure 3) all following
states sj ∀j > i and outputs oj = SHA-1(sj) can be predicted if the OS
PRNG (/dev/{u,}random) is unavailable14.

Quality of entropy collectors. OpenJDK’s strategy for seed gen-
eration in abstance of OS support is similar to VMSecureRandom of GNU
Classpath. OpenJDK supplements the threaded entropy collector by en-
forcing minimal limits on runtime before extracting bytes and adding a
substitution box. The unhashed15 seed bytes were evaluated. The imple-
mentation revealed to be magnitudes slower, resulting in only 20MiB of
seed generated by 8 processes running simultaneously. From the 114 black-
box tests only 30 were passed, whereas 12 failed with a p-value < 0.05
and 72 with p-value < 10−6. The random bytes had grave diﬃculties
with the STS tests, failing Monobit, Runs and the ﬁrst eight Serial tests.
This indicates poor variance in single bits and tuples up to eight bits.
Nevermind, the resulting graph is ﬁlled very balanced (cf. Figure 11).

5.4 The Legion of Bouncy Castle

Bouncy Castle’s implementation is also a hash-based algorithm (Digest-
RandomGenerator). No obvious bugs were found during code review. In
contrast, the entropy collector ThreadedSeedGenerator revealed diﬃcul-
ties to generate suﬃcient random bytes.

14 until the user manually reseeds the SecureRandom instance
15 before hashing with additional System.properties values

Weaknesses. In DigestRandomGenerator the seed is modiﬁed every
tenth call (cf. Section 3.4). This may increase the period of the PRNG
and hinders an attacker aware of the secret state to calculate previous
outputs. Predicting all succeeding outputs is still possible as the counter
values can be guessed by observing the amount of values produced yet.

The VMPC function used in VMPCRandomGenerator is known to be

vulnerable to multiple distinguishing attacks (cf.

[21],

[22],

[23]).

Quality of entropy collectors. The entropy collector checks if a
counter incremented in another thread has changed. Under heavy load
the counter often diﬀers only about 1 incrementation.

The seed generator running in “fast” mode passed most of the STS
tests including Monobit, Runs and Serial up to eight bit tuple size. In
“slow” mode, long sequences of ones and zeros caused to fail the Runs
test, as well as the Serial test for 2-bit blocks. Both modes were still able
to ﬁll the pane after 10MiB of one byte samples (c.f., Figure 12).

5.5 Vulnerabilities Summary

The Tables depitcted in Figures 6, 7, 8 ﬁnally summarize our results16.

Library

Apache Harmony
GNU Classpath
OpenJDK

Security when seeded from

OS PRNG
64 bit
160 bit
160 bit

integrated source
31 bit
dubious(see text)
dubious(see text)

Fig. 6. Summary of the results from SecureRandom audits.

Library

Source of entropy

Apache Harmony UNIX-time, processor time, heap pointer
GNU Classpath
OpenJDK

Thread scheduler
Thread scheduler, System.properties

Passed Blackbox
tests
0/114
0/114(see text)
30/114

Fig. 7. Summary of the integrated seed generators.

6 Conclusion

The SecureRandom PRNG is the primary source of randomness for Java
and is used e.g., by cryptographic operations. This underlines its impor-
tance regarding security. Some of fallback solutions of the investigated

16 Bouncy Castle is partly missing since it ships with replacements for SecureRandom

and conﬁgurable entropy collectors. And is thus not directly comparable

Library

Component

Vulnerability

Apache Harmony
Apache Harmony

SecureRandom
SecureRandom

Gnu Classpath

SecureRandom

Gnu Classpath

Entropy Collector

Bouncy Castle

VMPCRandomGenerator

Entropy limited to 64bit.
Entropy limited to 31bit.
Possibly predictable if later
IVs are known.
Suggestible by other
threads.
Vulnerable to distinguishing
attacks.

only if OS
PRNG
unavail.

X

X

Fig. 8. Overall summary of all uncovered vulnerabilities.

implementations revealed to be weak and predict- or capable of being in-
ﬂuenced. Very alarming are the defects found in Apache Harmony, since
it is partly used by Android. Long update intervals and missing pre-OS-
release patching of device manufacturers in the past (c.f., [24]) may cause
this bug to remain in the Android ecosystem for months or even years.
Although, some libraries provide acceptable randomness, the use of hard-
ware RNGs instead of PRNGs is recommended for critical purposes.

References

1. Gupta, A., Cozza, R., Nguyen, T.H., Milanesi, C., Shen, S., Vergne, H.J.D.L.,
Zimmermann, A., Lu, C., Sato, A., Glenn, D.: Market Share: Mobile Devices,
Worldwide, 1Q12. Technical report, Garnter, Inc. (May 2012)

2. Nielsen: Two Thirds of New Mobile Buyers Now Opting For Smartphones. Tech-

nical report, The Nielsen Company (June 2012)

3. Bennett, J.: Android Smartphone Activations Reached 331 Million in Q1’2012 Re-
veals New Device Tracking Database from Signals and Systems Telecom . Technical
report, Signals and Systems Telecom (May 2012)

4. Goldreich, O., Goldwasser, S., Micali, S.: How to construct random functions. J.

ACM (August 1986)

5. Gutterman, Z., Pinkas, B., Reinman, T.: Analysis of the Linux Random Number

Generator. In: IEEE Symposium on Security and Privacy. (2006)

6. Dorrendorf, L., Gutterman, Z., Pinkas, B.: Cryptanalysis of the windows ran-
dom number generator. In: ACM Conference on Computer and Communications
Security. (2007)

7. Heninger, N., Durumeric, Z., Wustrow, E., Halderman, J.A.: Mining Your Ps and
Qs: Detection of Widespread Weak Keys in Network Devices. In: Proceedings of
the 21st USENIX Security Symposium. (August 2012)

8. Agyros, G., Kiayias, A.: I forgot your password: Randomness attacks against PHP
applications. In: Proceedings of the 21st USENIX Security Symposium, USENIX
Association (2012)

9. Kopf, G.: Non-Obvious Bugs by Example.

http://gregorkopf.de/slides_

berlinsides_2010.pdf (2010)

10. Meyer, C., Somorovsky, J.: Why seeding with System.currentTimeMillis()
http://armoredbarista.blogspot.de/2012/01/

is not
why-seeding-with-systemcurrenttimemilli.html (January 2012)

good idea...

a

11. Lenstra, A., Hughes, J., Augier, M., Bos, J., Kleinjung, T., Wachter, C.: Public
Keys. In: Advances in Cryptology – CRYPTO 2012. Lecture Notes in Computer
Science. Springer Berlin Heidelberg (2012)

12. Kelsey, J., Schneier, B., Wagner, D., Hall, C.: Cryptanalytic Attacks on Pseudoran-
dom Number Generators. In: FSE. Lecture Notes in Computer Science, Springer
(1998)

13. Brown, R.G., Eddelbuettel, D., Bauer, D.: Dieharder: A Random Number Test

Suite. Technical report, Duke University (2012)

14. Rukhin, A., Soto, J., Nechvatal, J., Smid, M., Barker, E., Leigh, S., Levenson, M.,
Vangel, M., Banks, D., Heckert1, A., Dray, J., Vo, S., III, L.E.B.: A Statistical
Test Suite for the Validation of Random Number Generators and Pseudo Random
Number Generators for Cryptographic Applications. Technical report, National
Institute of Standards and Technology (NIST) (April 2010)

15. Lee, E.H., Lee, J.H., Park, I.H., Cho, K.R.: Implementation of high-speed SHA-1

architecture. IEICE Electronics Express (2009)

16. Zoltak, B.: VMPC One-Way Function and Stream Cipher.

In: Fast Software
Encryption, 11th International Workshop, FSE 2004, Delhi, India, February 5-7,
2004, Revised Papers. Lecture Notes in Computer Science, Springer (2004)

17. Google Inc.: javax.crypto — Android Developers. (July 2012)
18. McDonald, C., Hawkes, P., Pieprzyk, J.: Diﬀerential Path for SHA-1 with com-

plexity O(2ˆ52). IACR Cryptology ePrint Archive (2009)

19. Wikipedia: Preimage attack — Wikipedia, The Free Encyclopedia (2012) [Online;

accessed 24-August-2012].

20. Handschuh, H., Knudsen, L., Robshaw, M.: Analysis of SHA-1 in Encryption
In: Topics in Cryptology — CT-RSA 2001. Lecture Notes in Computer

Mode.
Science. Springer Berlin / Heidelberg (2001)

21. Tsunoo, Y., Saito, T., Kubo, H., Shigeri, M., Suzaki, T., Kawabata, T.: The Most

Eﬃcient Distinguishing Attack on VMPC and RC4A (2005)

22. Maximov, A.: Two Linear Distinguishing Attacks on VMPC and RC4A and Weak-

ness of RC4 Family of Stream Ciphers (Corrected). (2007)

23. Shunbo Li, Yupu Hu, Y.Z.Y.W.:

Improved cryptanalysis of the vmpc stream

cipher. Jurnal of Computational Information Systems (2012)

24. Sverdlove, H., Brown, D., Cilley, J., Munro, K.: Orphan Android: Top Vulnerable

Smartphones 2011. Technical report, Bit9, Inc. (November 2011)

7 Appendix

Fig. 9. Distribution of 2-tuples from Apache Harmonys integrated seeding facility.

(a) heavy

(b) normal

Fig. 10. Distribution of 2-tuples from VMSecureRandom under heavy (a) and normal (b)
workload as implemented in GNU Classpath.

Fig. 11. Distribution of 2-tuples from the entropy collector in OpenJDK.

(a) slow

(b) fast

Fig. 12. Distribution of 2-tuples from the ThreadedSeedGenerator in Bouncy Castle’s
lightweight crypto library for Java running on “slow” (a) and “fast” (b)



=== Content from android-developers.blogspot.com.au_7bc11e16_20250125_062930.html ===


![](https://ad.doubleclick.net/ddm/activity/src=2542116;type=gblog;cat=googl0;ord=1?)

[![hero android logo](https://developer.android.com/static/images/logos/android.svg)](https://android-developers.googleblog.com)
 ☰
[Android Developers Blog](https://android-developers.googleblog.com)

The latest Android and Google Play news for app and game
developers.

 🔍
![](data:image/png;base64...)

[Android Developers →](https://developer.android.com/)

[Jetpack](https://developer.android.com/jetpack)
[Kotlin](https://developer.android.com/kotlin)
[Docs](https://developer.android.com/docs)
[News](https://developer.android.com/news)

![](data:image/png;base64...)
[Platform](https://developer.android.com/about)
[Android Studio](https://developer.android.com/studio)
[Google Play](https://developer.android.com/distribute)
[Jetpack](https://developer.android.com/jetpack)
[Kotlin](https://developer.android.com/kotlin)
[Docs](https://developer.android.com/docs)
[News](https://developer.android.com/news)
[![Android Developers Site](https://developer.android.com/static/images/logos/android.svg)](https://developer.android.com/ "Android Developers Site")
[![Android Developers on YouTube](https://www.gstatic.com/images/icons/material/system/2x/video_youtube_grey600_24dp.png)](https://www.youtube.com/user/androiddevelopers "Android Developers on YouTube")
[![Android Developers on LinkedIn](https://www.pagetraffic.com/blog/wp-content/uploads/2022/09/linkedin-black-white-logo.png)](https://www.linkedin.com/showcase/androiddev/ "Android Developers on LinkedIn")
[![Android Developers on Medium](data:image/png;base64...)](https://medium.com/androiddevelopers "Android Developers on Medium")
[![Follow Android Developers on X](https://developers.google.com/static/homepage-assets/images/x.svg)](https://x.com/androiddev "Follow Android Developers on X")

[![Google Play Site](https://developer.android.com/static/images/logos/google-play.svg)](https://developer.android.com/distribute/ "Google Play Site")
[![Google Play Apps & Games on LinkedIn](https://www.pagetraffic.com/blog/wp-content/uploads/2022/09/linkedin-black-white-logo.png)](https://www.linkedin.com/company/googleplaybiz/ "Google Play Apps & Games on LinkedIn")
[![Google Play Apps & Games on Medium](data:image/png;base64...)](https://medium.com/googleplaydev "Google Play Apps & Games on Medium")
[![Follow GooglePlayBiz on X](https://developers.google.com/static/homepage-assets/images/x.svg)](https://x.com/GooglePlayBiz "Follow GooglePlaydBiz on X")

[Platform](https://developer.android.com/about)

[Android Studio](https://developer.android.com/studio)

[Google Play](https://developer.android.com/distribute)

[Jetpack](https://developer.android.com/jetpack)

[Kotlin](https://developer.android.com/kotlin)

[Docs](https://developer.android.com/docs)

[News](https://developer.android.com/news)

More
![](data:image/png;base64...)

[![Android Developers Site](https://developer.android.com/static/images/logos/android.svg)](https://developer.android.com/ "Android Developers Site")
[![Android Developers on YouTube](https://www.gstatic.com/images/icons/material/system/2x/video_youtube_grey600_24dp.png)](https://www.youtube.com/user/androiddevelopers "Android Developers on YouTube")
[![Android Developers on LinkedIn](https://www.pagetraffic.com/blog/wp-content/uploads/2022/09/linkedin-black-white-logo.png)](https://www.linkedin.com/showcase/androiddev/ "Android Developers on LinkedIn")
[![Android Developers on Medium](data:image/png;base64...)](https://medium.com/androiddevelopers "Android Developers on Medium")
[![Follow Android Developers on X](https://developers.google.com/static/homepage-assets/images/x.svg)](https://X.com/androiddev "Follow Android Developers on X")

|
[![Google Play Site](https://developer.android.com/static/images/logos/google-play.svg)](https://developer.android.com/distribute/ "Google Play Site")
[![Google Play Apps & Games on LinkedIn](https://www.pagetraffic.com/blog/wp-content/uploads/2022/09/linkedin-black-white-logo.png)](https://www.linkedin.com/company/googleplaybiz/ "Google Play Apps & Games on LinkedIn")
[![Google Play Apps & Games on Medium](data:image/png;base64...)](https://medium.com/googleplaydev "Google Play Apps & Games on Medium")
[![Follow GooglePlayBiz on X](https://developers.google.com/static/homepage-assets/images/x.svg)](https://X.com/GooglePlayBiz "Follow GooglePlaydBiz on X")

14 August 2013

# Some SecureRandom Thoughts

---

Share this post
[![Share on LinkedIn](https://www.gstatic.com/dgc_blog/images/ic_linkedin_black.svg)
LinkedIn](https://www.linkedin.com/shareArticle?mini=true&url=https://android-developers.googleblog.com/2013/08/some-securerandom-thoughts.html&title=Some SecureRandom Thoughts)
[![Share on X](https://developers.google.com/static/homepage-assets/images/x.svg)
Twitter](https://x.com/share?text=Android Developers Blog: Some SecureRandom Thoughts&url=https://android-developers.googleblog.com/2013/08/some-securerandom-thoughts.html&via=google)
[![Share on Facebook](https://www.gstatic.com/dgc_blog/images/ic_facebook_black.svg)
Facebook](https://www.facebook.com/sharer.php?u=https://android-developers.googleblog.com/2013/08/some-securerandom-thoughts.html)
![Share in mail](https://www.gstatic.com/dgc_blog/images/ic_mail.svg)
Email
![Copy link](https://www.gstatic.com/dgc_blog/images/ic_link.svg)
Copy link

Link copied to clipboard

*Posted by Alex Klyubin, Android Security Engineer*

The Android security team has been investigating the root cause of the compromise of a bitcoin transaction that led to [the update of multiple Bitcoin applications](http://bitcoin.org/en/alert/2013-08-11-android) on August 11.

We have now determined that applications which use the Java Cryptography Architecture (JCA) for key generation, signing, or random number generation may not receive cryptographically strong values on Android devices due to improper initialization of the underlying PRNG. Applications that directly invoke the system-provided OpenSSL PRNG without explicit initialization on Android are also affected. Applications that establish TLS/SSL connections using the `HttpClient` and `java.net` classes are not affected as those classes do seed the OpenSSL PRNG with values from `/dev/urandom`.

Developers who use JCA for key generation, signing or random number generation should update their applications to explicitly initialize the PRNG with entropy from `/dev/urandom` or `/dev/random`. A suggested implementation is provided at the end of this blog post. Also, developers should evaluate whether to regenerate cryptographic keys or other random values previously generated using JCA APIs such as `SecureRandom`, `KeyGenerator`, `KeyPairGenerator`, `KeyAgreement`, and `Signature`.

In addition to this developer recommendation, Android has developed patches that ensure that Android’s OpenSSL PRNG is initialized correctly. Those patches have been provided to OHA partners and have been checked into the Android tree. Applications which run exclusively on Android KitKat (4.4) or above do not need to take any special action to work around this bug.

We would like to thank Soo Hyeon Kim, Daewan Han of ETRI and Dong Hoon Lee of Korea University who notified Google about the improper initialization of OpenSSL PRNG.

**Update**: the original code sample below crashed on a small fraction of Android devices due to `/dev/urandom` not being writable. We have now updated the code sample to handle this case gracefully.

```
/*
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will Google be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, as long as the origin is not misrepresented.
 */

import android.os.Build;
import android.os.Process;
import android.util.Log;

import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.security.NoSuchAlgorithmException;
import java.security.Provider;
import java.security.SecureRandom;
import java.security.SecureRandomSpi;
import java.security.Security;

/**
 * Fixes for the output of the default PRNG having low entropy.
 *
 * The fixes need to be applied via {@link #apply()} before any use of Java
 * Cryptography Architecture primitives. A good place to invoke them is in the
 * application's {@code onCreate}.
 */
public final class PRNGFixes {

    private static final int VERSION_CODE_JELLY_BEAN = 16;
    private static final int VERSION_CODE_JELLY_BEAN_MR2 = 18;
    private static final byte[] BUILD_FINGERPRINT_AND_DEVICE_SERIAL =
        getBuildFingerprintAndDeviceSerial();

    /** Hidden constructor to prevent instantiation. */
    private PRNGFixes() {}

    /**
     * Applies all fixes.
     *
     * @throws SecurityException if a fix is needed but could not be applied.
     */
    public static void apply() {
        applyOpenSSLFix();
        installLinuxPRNGSecureRandom();
    }

    /**
     * Applies the fix for OpenSSL PRNG having low entropy. Does nothing if the
     * fix is not needed.
     *
     * @throws SecurityException if the fix is needed but could not be applied.
     */
    private static void applyOpenSSLFix() throws SecurityException {
        if ((Build.VERSION.SDK_INT < VERSION_CODE_JELLY_BEAN)
                || (Build.VERSION.SDK_INT > VERSION_CODE_JELLY_BEAN_MR2)) {
            // No need to apply the fix
            return;
        }

        try {
            // Mix in the device- and invocation-specific seed.
            Class.forName("org.apache.harmony.xnet.provider.jsse.NativeCrypto")
                    .getMethod("RAND_seed", byte[].class)
                    .invoke(null, generateSeed());

            // Mix output of Linux PRNG into OpenSSL's PRNG
            int bytesRead = (Integer) Class.forName(
                    "org.apache.harmony.xnet.provider.jsse.NativeCrypto")
                    .getMethod("RAND_load_file", String.class, long.class)
                    .invoke(null, "/dev/urandom", 1024);
            if (bytesRead != 1024) {
                throw new IOException(
                        "Unexpected number of bytes read from Linux PRNG: "
                                + bytesRead);
            }
        } catch (Exception e) {
            throw new SecurityException("Failed to seed OpenSSL PRNG", e);
        }
    }

    /**
     * Installs a Linux PRNG-backed {@code SecureRandom} implementation as the
     * default. Does nothing if the implementation is already the default or if
     * there is not need to install the implementation.
     *
     * @throws SecurityException if the fix is needed but could not be applied.
     */
    private static void installLinuxPRNGSecureRandom()
            throws SecurityException {
        if (Build.VERSION.SDK_INT > VERSION_CODE_JELLY_BEAN_MR2) {
            // No need to apply the fix
            return;
        }

        // Install a Linux PRNG-based SecureRandom implementation as the
        // default, if not yet installed.
        Provider[] secureRandomProviders =
                Security.getProviders("SecureRandom.SHA1PRNG");
        if ((secureRandomProviders == null)
                || (secureRandomProviders.length < 1)
                || (!LinuxPRNGSecureRandomProvider.class.equals(
                        secureRandomProviders[0].getClass()))) {
            Security.insertProviderAt(new LinuxPRNGSecureRandomProvider(), 1);
        }

        // Assert that new SecureRandom() and
        // SecureRandom.getInstance("SHA1PRNG") return a SecureRandom backed
        // by the Linux PRNG-based SecureRandom implementation.
        SecureRandom rng1 = new SecureRandom();
        if (!LinuxPRNGSecureRandomProvider.class.equals(
                rng1.getProvider().getClass())) {
            throw new SecurityException(
                    "new SecureRandom() backed by wrong Provider: "
                            + rng1.getProvider().getClass());
        }

        SecureRandom rng2;
        try {
            rng2 = SecureRandom.getInstance("SHA1PRNG");
        } catch (NoSuchAlgorithmException e) {
            throw new SecurityException("SHA1PRNG not available", e);
        }
        if (!LinuxPRNGSecureRandomProvider.class.equals(
                rng2.getProvider().getClass())) {
            throw new SecurityException(
                    "SecureRandom.getInstance(\"SHA1PRNG\") backed by wrong"
                    + " Provider: " + rng2.getProvider().getClass());
        }
    }

    /**
     * {@code Provider} of {@code SecureRandom} engines which pass through
     * all requests to the Linux PRNG.
     */
    private static class LinuxPRNGSecureRandomProvider extends Provider {

        public LinuxPRNGSecureRandomProvider() {
            super("LinuxPRNG",
                    1.0,
                    "A Linux-specific random number provider that uses"
                        + " /dev/urandom");
            // Although /dev/urandom is not a SHA-1 PRNG, some apps
            // explicitly request a SHA1PRNG SecureRandom and we thus need to
            // prevent them from getting the default implementation whose output
            // may have low entropy.
            put("SecureRandom.SHA1PRNG", LinuxPRNGSecureRandom.class.getName());
            put("SecureRandom.SHA1PRNG ImplementedIn", "Software");
        }
    }

    /**
     * {@link SecureRandomSpi} which passes all requests to the Linux PRNG
     * ({@code /dev/urandom}).
     */
    public static class LinuxPRNGSecureRandom extends SecureRandomSpi {

        /*
         * IMPLEMENTATION NOTE: Requests to generate bytes and to mix in a seed
         * are passed through to the Linux PRNG (/dev/urandom). Instances of
         * this class seed themselves by mixing in the current time, PID, UID,
         * build fingerprint, and hardware serial number (where available) into
         * Linux PRNG.
         *
         * Concurrency: Read requests to the underlying Linux PRNG are
         * serialized (on sLock) to ensure that multiple threads do not get
         * duplicated PRNG output.
         */

        private static final File URANDOM_FILE = new File("/dev/urandom");

        private static final Object sLock = new Object();

        /**
         * Input stream for reading from Linux PRNG or {@code null} if not yet
         * opened.
         *
         * @GuardedBy("sLock")
         */
        private static DataInputStream sUrandomIn;

        /**
         * Output stream for writing to Linux PRNG or {@code null} if not yet
         * opened.
         *
         * @GuardedBy("sLock")
         */
        private static OutputStream sUrandomOut;

        /**
         * Whether this engine instance has been seeded. This is needed because
         * each instance needs to seed itself if the client does not explicitly
         * seed it.
         */
        private boolean mSeeded;

        @Override
        protected void engineSetSeed(byte[] bytes) {
            try {
                OutputStream out;
                synchronized (sLock) {
                    out = getUrandomOutputStream();
                }
                out.write(bytes);
                out.flush();
            } catch (IOException e) {
                // On a small fraction of devices /dev/urandom is not writable.
                // Log and ignore.
                Log.w(PRNGFixes.class.getSimpleName(),
                        "Failed to mix seed into " + URANDOM_FILE);
            } finally {
                mSeeded = true;
            }
        }

        @Override
        protected void engineNextBytes(byte[] bytes) {
            if (!mSeeded) {
                // Mix in the device- and invocation-specific seed.
                engineSetSeed(generateSeed());
            }

            try {
                DataInputStream in;
                synchronized (sLock) {
                    in = getUrandomInputStream();
                }
                synchronized (in) {
                    in.readFully(bytes);
                }
            } catch (IOException e) {
                throw new SecurityException(
                        "Failed to read from " + URANDOM_FILE, e);
            }
        }

        @Override
        protected byte[] engineGenerateSeed(int size) {
            byte[] seed = new byte[size];
            engineNextBytes(seed);
            return seed;
        }

        private DataInputStream getUrandomInputStream() {
            synchronized (sLock) {
                if (sUrandomIn == null) {
                    // NOTE: Consider inserting a BufferedInputStream between
                    // DataInputStream and FileInputStream if you need higher
                    // PRNG output performance and can live with future PRNG
                    // output being pulled into this process prematurely.
                    try {
                        sUrandomIn = new DataInputStream(
                                new FileInputStream(URANDOM_FILE));
                    } catch (IOException e) {
                        throw new SecurityException("Failed to open "
                                + URANDOM_FILE + " for reading", e);
                    }
                }
                return sUrandomIn;
            }
        }

        private OutputStream getUrandomOutputStream() throws IOException {
            synchronized (sLock) {
                if (sUrandomOut == null) {
                    sUrandomOut = new FileOutputStream(URANDOM_FILE);
                }
                return sUrandomOut;
            }
        }
    }

    /**
     * Generates a device- and invocation-specific seed to be mixed into the
     * Linux PRNG.
     */
    private static byte[] generateSeed() {
        try {
            ByteArrayOutputStream seedBuffer = new ByteArrayOutputStream();
            DataOutputStream seedBufferOut =
                    new DataOutputStream(seedBuffer);
            seedBufferOut.writeLong(System.currentTimeMillis());
            seedBufferOut.writeLong(System.nanoTime());
            seedBufferOut.writeInt(Process.myPid());
            seedBufferOut.writeInt(Process.myUid());
            seedBufferOut.write(BUILD_FINGERPRINT_AND_DEVICE_SERIAL);
            seedBufferOut.close();
            return seedBuffer.toByteArray();
        } catch (IOException e) {
            throw new SecurityException("Failed to generate seed", e);
        }
    }

    /**
     * Gets the hardware serial number of this device.
     *
     * @return serial number or {@code null} if not available.
     */
    private static String getDeviceSerialNumber() {
        // We're using the Reflection API because Build.SERIAL is only available
        // since API Level 9 (Gingerbread, Android 2.3).
        try {
            return (String) Build.class.getField("SERIAL").get(null);
        } catch (Exception ignored) {
            return null;
        }
    }

    private static byte[] getBuildFingerprintAndDeviceSerial() {
        StringBuilder result = new StringBuilder();
        String fingerprint = Build.FINGERPRINT;
        if (fingerprint != null) {
            result.append(fingerprint);
        }
        String serial = getDeviceSerialNumber();
        if (serial != null) {
            result.append(serial);
        }
        try {
            return result.toString().getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("UTF-8 encoding not supported");
        }
    }
}
```
[Join the discussion on](https://plus.google.com/108967384991768947849/posts/YxWzeNQMJS2)

[+Android Developers](https://plus.google.com/108967384991768947849/posts/YxWzeNQMJS2)[![](https://ssl.gstatic.com/images/icons/gplus-32.png)](https://plus.google.com/108967384991768947849/posts/YxWzeNQMJS2)

---

[Android](https://android-developers.googleblog.com/search/label/Android?max-results=12)
[archive](https://android-developers.googleblog.com/search/label/archive?max-results=12)
[Security](https://android-developers.googleblog.com/search/label/Security?max-results=12)

[Newer post](https://android-developers.googleblog.com/2013/08/google-play-services-32.html "Newer Post")
[Older post](https://android-developers.googleblog.com/2013/08/actionbarcompat-and-io-2013-app-source.html "Older Post")

## Google developers blog

[Google Developers Blog](https://developers.googleblog.com)

## Connect

[![Android Developers Site](https://developer.android.com/static/images/logos/android.svg)](https://developer.android.com/ "Android Developers Site")Android Developers
[![Android Developers on YouTube](https://www.gstatic.com/images/icons/material/system/2x/video_youtube_grey600_24dp.png)](https://www.youtube.com/user/androiddevelopers "Android Developers on YouTube")
[![Android Developers on LinkedIn](https://www.pagetraffic.com/blog/wp-content/uploads/2022/09/linkedin-black-white-logo.png)](https://www.linkedin.com/showcase/androiddev/ "Android Developers on LinkedIn")
[![Android Developers on Medium](data:image/png;base64...)](https://medium.com/androiddevelopers "Android Developers on Medium")
[![Follow Android Developers on X](https://developers.google.com/static/homepage-assets/images/x.svg)](https://x.com/androiddev "Follow Android Developers on X")

[![Google Play Site](https://developer.android.com/static/images/logos/google-play.svg)](https://developer.android.com/distribute/ "Google Play Site")Google Play
[![Google Play Apps & Games on LinkedIn](https://www.pagetraffic.com/blog/wp-content/uploads/2022/09/linkedin-black-white-logo.png)](https://www.linkedin.com/company/googleplaybiz/ "Google Play Apps & Games on LinkedIn")
[![Google Play Apps & Games on Medium](data:image/png;base64...)](https://medium.com/googleplaydev "Google Play Apps & Games on Medium")
[![Follow GooglePlayBiz on X](https://developers.google.com/static/homepage-assets/images/x.svg)](https://x.com/GooglePlayBiz "Follow GooglePlaydBiz on X")

## Subscribe

[![](https://www.gstatic.com/images/icons/material/system/1x/rss_feed_grey600_24dp.png)
## Feed](https://android-developers.blogspot.com/atom.xml "Subscribe to our feed")
[![](https://www.gstatic.com/images/icons/material/system/2x/news_grey600_24dp.png)
## Newsletter](https://developer.android.com/newsletter/index.html)

[* Privacy](https://policies.google.com/privacy)
|
[* License](https://developer.android.com/license)
|
[* Brand guidelines](https://developer.android.com/distribute/marketing-tools/brand-guidelines)
[Get news and tips by email](https://developer.android.com/newsletter/#subscribe)



=== Content from android.googlesource.com_b15b567e_20250125_062933.html ===
LyoKICogIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmUgb3IgbW9yZQogKiAgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoCiAqICB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuCiAqICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byBZb3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMAogKiAgKHRoZSAiTGljZW5zZSIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGgKICogIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CiAqCiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKICoKICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgogKi8KCgpwYWNrYWdlIG9yZy5hcGFjaGUuaGFybW9ueS5zZWN1cml0eS5wcm92aWRlci5jcnlwdG87CgppbXBvcnQgZGFsdmlrLnN5c3RlbS5CbG9ja0d1YXJkOwppbXBvcnQgamF2YS5pby5GaWxlOwppbXBvcnQgamF2YS5pby5GaWxlSW5wdXRTdHJlYW07CmltcG9ydCBqYXZhLmlvLklPRXhjZXB0aW9uOwppbXBvcnQgamF2YS5pby5PYmplY3RJbnB1dFN0cmVhbTsKaW1wb3J0IGphdmEuaW8uT2JqZWN0T3V0cHV0U3RyZWFtOwppbXBvcnQgamF2YS5pby5TZXJpYWxpemFibGU7CmltcG9ydCBqYXZhLnNlY3VyaXR5LkludmFsaWRQYXJhbWV0ZXJFeGNlcHRpb247CmltcG9ydCBqYXZhLnNlY3VyaXR5LlByb3ZpZGVyRXhjZXB0aW9uOwppbXBvcnQgamF2YS5zZWN1cml0eS5TZWN1cmVSYW5kb21TcGk7CmltcG9ydCBsaWJjb3JlLmlvLlN0cmVhbXM7CmltcG9ydCBsaWJjb3JlLnV0aWwuRW1wdHlBcnJheTsKCmltcG9ydCBzdGF0aWMgb3JnLmFwYWNoZS5oYXJtb255LnNlY3VyaXR5LnByb3ZpZGVyLmNyeXB0by5TSEExQ29uc3RhbnRzLio7CgovKioKICogVGhpcyBjbGFzcyBleHRlbmRzIHRoZSBTZWN1cmVSYW5kb21TcGkgY2xhc3MgaW1wbGVtZW50aW5nIGFsbCBpdHMgYWJzdHJhY3QgbWV0aG9kcy4KICoKICogPHA+VG8gZ2VuZXJhdGUgcHNldWRvLXJhbmRvbSBiaXRzLCB0aGUgaW1wbGVtZW50YXRpb24gdXNlcyB0ZWNobmlxdWUgZGVzY3JpYmVkIGluCiAqIHRoZSAiUmFuZG9tIE51bWJlciBHZW5lcmF0b3IgKFJORykgYWxnb3JpdGhtcyIgc2VjdGlvbiwgQXBwZW5kaXggQSwKICogSmF2YVRNIENyeXB0b2dyYXBoeSBBcmNoaXRlY3R1cmUsIEFQSSBTcGVjaWZpY2F0aW9uICYgUmVmZXJlbmNlLgogKi8KcHVibGljIGNsYXNzIFNIQTFQUk5HX1NlY3VyZVJhbmRvbUltcGwgZXh0ZW5kcyBTZWN1cmVSYW5kb21TcGkgaW1wbGVtZW50cyBTZXJpYWxpemFibGUgewoKICAgIHByaXZhdGUgc3RhdGljIGZpbmFsIGxvbmcgc2VyaWFsVmVyc2lvblVJRCA9IDI4MzczNjc5NzIxMjE1OTY3NUw7CgogICAgcHJpdmF0ZSBzdGF0aWMgRmlsZUlucHV0U3RyZWFtIGRldlVSYW5kb207CiAgICBzdGF0aWMgewogICAgICAgIHRyeSB7CiAgICAgICAgICAgIGRldlVSYW5kb20gPSBuZXcgRmlsZUlucHV0U3RyZWFtKG5ldyBGaWxlKCIvZGV2L3VyYW5kb20iKSk7CiAgICAgICAgfSBjYXRjaCAoSU9FeGNlcHRpb24gZXgpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFeGNlcHRpb24oZXgpOwogICAgICAgIH0KICAgIH0KCiAgICAvLyBjb25zdGFudHMgdG8gdXNlIGluIGV4cHJlc3Npb25zIG9wZXJhdGluZyBvbiBieXRlcyBpbiBpbnQgYW5kIGxvbmcgdmFyaWFibGVzOgogICAgLy8gRU5EX0ZMQUdTIC0gZmluYWwgYnl0ZXMgaW4gd29yZHMgdG8gYXBwZW5kIHRvIG1lc3NhZ2U7CiAgICAvLyAgICAgICAgICAgICBzZWUgImNoLjUuMSBQYWRkaW5nIHRoZSBNZXNzYWdlLCBGSVBTIDE4MC0yIgogICAgLy8gUklHSFQxICAgIC0gc2hpZnRzIHRvIHJpZ2h0IGZvciBsZWZ0IGhhbGYgb2YgbG9uZwogICAgLy8gUklHSFQyICAgIC0gc2hpZnRzIHRvIHJpZ2h0IGZvciByaWdodCBoYWxmIG9mIGxvbmcKICAgIC8vIExFRlQgICAgICAtIHNoaWZ0cyB0byBsZWZ0IGZvciBieXRlcwogICAgLy8gTUFTSyAgICAgIC0gbWFzayB0byBzZWxlY3QgY291bnRlcidzIGJ5dGVzIGFmdGVyIHNoaWZ0IHRvIHJpZ2h0CgogICAgcHJpdmF0ZSBzdGF0aWMgZmluYWwgaW50W10gRU5EX0ZMQUdTID0geyAweDgwMDAwMDAwLCAweDgwMDAwMCwgMHg4MDAwLCAweDgwIH07CgogICAgcHJpdmF0ZSBzdGF0aWMgZmluYWwgaW50W10gUklHSFQxID0geyAwLCA0MCwgNDgsIDU2IH07CgogICAgcHJpdmF0ZSBzdGF0aWMgZmluYWwgaW50W10gUklHSFQyID0geyAwLCA4LCAxNiwgMjQgfTsKCiAgICBwcml2YXRlIHN0YXRpYyBmaW5hbCBpbnRbXSBMRUZUID0geyAwLCAyNCwgMTYsIDggfTsKCiAgICBwcml2YXRlIHN0YXRpYyBmaW5hbCBpbnRbXSBNQVNLID0geyAweEZGRkZGRkZGLCAweDAwRkZGRkZGLCAweDAwMDBGRkZGLAogICAgICAgICAgICAweDAwMDAwMEZGIH07CgogICAgLy8gSEFTSEJZVEVTX1RPX1VTRSBkZWZpbmVzICMgb2YgYnl0ZXMgcmV0dXJuZWQgYnkgImNvbXB1dGVIYXNoKGJ5dGVbXSkiCiAgICAvLyB0byB1c2UgdG8gZm9ybSBieXRlIGFycmF5IHJldHVybmluZyBieSB0aGUgIm5leHRCeXRlcyhieXRlW10pIiBtZXRob2QKICAgIC8vIE5vdGUsIHRoYXQgdGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIG1vcmUgYnl0ZXMgdGhhbiBpdCBpcyBkZWZpbmVkCiAgICAvLyBpbiB0aGUgYWJvdmUgc3BlY2lmaWNhdGlvbi4KICAgIHByaXZhdGUgc3RhdGljIGZpbmFsIGludCBIQVNIQllURVNfVE9fVVNFID0gMjA7CgogICAgLy8gdmFsdWUgb2YgMTYgZGVmaW5lZCBpbiB0aGUgIlNFQ1VSRSBIQVNIIFNUQU5EQVJEIiwgRklQUyBQVUIgMTgwLTIKICAgIHByaXZhdGUgc3RhdGljIGZpbmFsIGludCBGUkFNRV9MRU5HVEggPSAxNjsKCiAgICAvLyBtaXNjZWxsYW5lb3VzIGNvbnN0YW50cyBkZWZpbmVkIGluIHRoaXMgaW1wbGVtZW50YXRpb246CiAgICAvLyBDT1VOVEVSX0JBU0UgLSBpbml0aWFsIHZhbHVlIHRvIHNldCB0byAiY291bnRlciIgYmVmb3JlIGNvbXB1dGluZyAibmV4dEJ5dGVzKC4uKSI7CiAgICAvLyAgICAgICAgICAgICAgICBub3RlLCB0aGF0IHRoZSBleGFjdCB2YWx1ZSBpcyBub3QgZGVmaW5lZCBpbiBTVEFOREFSRAogICAgLy8gSEFTSENPUFlfT0ZGU0VUICAgLSBvZmZzZXQgZm9yIGNvcHkgb2YgY3VycmVudCBoYXNoIGluICJjb3BpZXMiIGFycmF5CiAgICAvLyBFWFRSQUZSQU1FX09GRlNFVCAtIG9mZnNldCBmb3IgZXh0cmEgZnJhbWUgaW4gImNvcGllcyIgYXJyYXk7CiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGFzIHRoZSBleHRyYSBmcmFtZSBmb2xsb3dzIHRoZSBjdXJyZW50IGhhc2ggZnJhbWUsCiAgICAvLyAgICAgICAgICAgICAgICAgICAgIEVYVFJBRlJBTUVfT0ZGU0VUIGlzIGVxdWFsIHRvIGxlbmd0aCBvZiBjdXJyZW50IGhhc2ggZnJhbWUKICAgIC8vIEZSQU1FX09GRlNFVCAgICAgIC0gb2Zmc2V0IGZvciBmcmFtZSBpbiAiY29waWVzIiBhcnJheQogICAgLy8gTUFYX0JZVEVTIC0gbWF4aW11bSAjIG9mIHNlZWQgYnl0ZXMgcHJvY2Vzc2luZyB3aGljaCBkb2Vzbid0IHJlcXVpcmUgZXh0cmEgZnJhbWUKICAgIC8vICAgICAgICAgICAgIHNlZSAoMSkgY29tbWVudHMgb24gdXNhZ2Ugb2YgInNlZWQiIGFycmF5IGJlbG93IGFuZAogICAgLy8gICAgICAgICAgICAgKDIpIGNvbW1lbnRzIGluICJlbmdpbmVOZXh0Qnl0ZXMoYnl0ZVtdKSIgbWV0aG9kCiAgICAvLwogICAgLy8gVU5ERUZJTkVEICAtIHRocmVlIHN0YXRlcyBvZiBlbmdpbmU7IGluaXRpYWxseSBpdHMgc3RhdGUgaXMgIlVOREVGSU5FRCIKICAgIC8vIFNFVF9TRUVEICAgICBjYWxsIHRvICJlbmdpbmVTZXRTZWVkIiAgc2V0cyB1cCAiU0VUX1NFRUQiIHN0YXRlLAogICAgLy8gTkVYVF9CWVRFUyAgIGNhbGwgdG8gImVuZ2luZU5leHRCeXRlIiBzZXRzIHVwICJORVhUX0JZVEVTIiBzdGF0ZQoKICAgIHByaXZhdGUgc3RhdGljIGZpbmFsIGludCBDT1VOVEVSX0JBU0UgPSAwOwoKICAgIHByaXZhdGUgc3RhdGljIGZpbmFsIGludCBIQVNIQ09QWV9PRkZTRVQgPSAwOwoKICAgIHByaXZhdGUgc3RhdGljIGZpbmFsIGludCBFWFRSQUZSQU1FX09GRlNFVCA9IDU7CgogICAgcHJpdmF0ZSBzdGF0aWMgZmluYWwgaW50IEZSQU1FX09GRlNFVCA9IDIxOwoKICAgIHByaXZhdGUgc3RhdGljIGZpbmFsIGludCBNQVhfQllURVMgPSA0ODsKCiAgICBwcml2YXRlIHN0YXRpYyBmaW5hbCBpbnQgVU5ERUZJTkVEID0gMDsKCiAgICBwcml2YXRlIHN0YXRpYyBmaW5hbCBpbnQgU0VUX1NFRUQgPSAxOwoKICAgIHByaXZhdGUgc3RhdGljIGZpbmFsIGludCBORVhUX0JZVEVTID0gMjsKCiAgICBwcml2YXRlIHN0YXRpYyBTSEExUFJOR19TZWN1cmVSYW5kb21JbXBsIG15UmFuZG9tOwoKICAgIC8vIFN0cnVjdHVyZSBvZiAic2VlZCIgYXJyYXk6CiAgICAvLyAtICAwLTc5IC0gd29yZHMgZm9yIGNvbXB1dGluZyBoYXNoCiAgICAvLyAtIDgwICAgIC0gdW51c2VkCiAgICAvLyAtIDgxICAgIC0gIyBvZiBzZWVkIGJ5dGVzIGluIGN1cnJlbnQgc2VlZCBmcmFtZQogICAgLy8gLSA4Mi04NiAtIDUgd29yZHMsIGN1cnJlbnQgc2VlZCBoYXNoCiAgICBwcml2YXRlIHRyYW5zaWVudCBpbnRbXSBzZWVkOwoKICAgIC8vIHRvdGFsIGxlbmd0aCBvZiBzZWVkIGJ5dGVzLCBpbmNsdWRpbmcgYWxsIHByb2Nlc3NlZAogICAgcHJpdmF0ZSB0cmFuc2llbnQgbG9uZyBzZWVkTGVuZ3RoOwoKICAgIC8vIFN0cnVjdHVyZSBvZiAiY29waWVzIiBhcnJheQogICAgLy8gLSAgMC00ICAtIDUgd29yZHMsIGNvcHkgb2YgY3VycmVudCBzZWVkIGhhc2gKICAgIC8vIC0gIDUtMjAgLSBleHRyYSAxNiB3b3JkcyBmcmFtZTsKICAgIC8vICAgICAgICAgICBpcyB1c2VkIGlmIGZpbmFsIHBhZGRpbmcgZXhjZWVkcyA1MTItYml0IGxlbmd0aAogICAgLy8gLSAyMS0zNiAtIDE2IHdvcmQgZnJhbWUgdG8gc3RvcmUgYSBjb3B5IG9mIHJlbWFpbmluZyBieXRlcwogICAgcHJpdmF0ZSB0cmFuc2llbnQgaW50W10gY29waWVzOwoKICAgIC8vIHJlYWR5ICJuZXh0IiBieXRlczsgbmVlZGVkIGJlY2F1c2Ugd29yZHMgYXJlIHJldHVybmVkCiAgICBwcml2YXRlIHRyYW5zaWVudCBieXRlW10gbmV4dEJ5dGVzOwoKICAgIC8vIGluZGV4IG9mIHVzZWQgYnl0ZXMgaW4gIm5leHRCeXRlcyIgYXJyYXkKICAgIHByaXZhdGUgdHJhbnNpZW50IGludCBuZXh0QkluZGV4OwoKICAgIC8vIHZhcmlhYmxlIHJlcXVpcmVkIGFjY29yZGluZyB0byAiU0VDVVJFIEhBU0ggU1RBTkRBUkQiCiAgICBwcml2YXRlIHRyYW5zaWVudCBsb25nIGNvdW50ZXI7CgogICAgLy8gY29udGFpbnMgaW50IHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gZW5naW5lJ3MgY3VycmVudCBzdGF0ZQogICAgcHJpdmF0ZSB0cmFuc2llbnQgaW50IHN0YXRlOwoKICAgIC8vIFRoZSAic2VlZCIgYXJyYXkgaXMgdXNlZCB0byBjb21wdXRlIGJvdGggImN1cnJlbnQgc2VlZCBoYXNoIiBhbmQgIm5leHQgYnl0ZXMiLgogICAgLy8KICAgIC8vIEFzIHRoZSAiU0hBMSIgYWxnb3JpdGhtIGNvbXB1dGVzIGEgaGFzaCBvZiBlbnRpcmUgc2VlZCBieSBzcGxpdHRpbmcgaXQgaW50bwogICAgLy8gYSBudW1iZXIgb2YgdGhlIDUxMi1iaXQgbGVuZ3RoIGZyYW1lcyAoNTEyIGJpdHMgPSA2NCBieXRlcyA9IDE2IHdvcmRzKSwKICAgIC8vICJjdXJyZW50IHNlZWQgaGFzaCIgaXMgYSBoYXNoICg1IHdvcmRzLCAyMCBieXRlcykgZm9yIGFsbCBwcmV2aW91cyBmdWxsIGZyYW1lczsKICAgIC8vIHJlbWFpbmluZyBieXRlcyBhcmUgc3RvcmVkIGluIHRoZSAwLTE1IHdvcmQgZnJhbWUgb2YgdGhlICJzZWVkIiBhcnJheS4KICAgIC8vCiAgICAvLyBBcyBmb3IgY2FsY3VsYXRpbmcgIm5leHQgYnl0ZXMiLAogICAgLy8gYm90aCByZW1haW5pbmcgYnl0ZXMgYW5kICJjdXJyZW50IHNlZWQgaGFzaCIgYXJlIHVzZWQsCiAgICAvLyB0byBwcmVzZXJ2ZSB0aGUgbGF0dGVyIGZvciBmb2xsb3dpbmcgInNldFNlZWQoLi4pIiBjb21tYW5kcywKICAgIC8vIHRoZSBmb2xsb3dpbmcgdGVjaG5pcXVlIGlzIHVzZWQ6CiAgICAvLyAtIHVwb24gZ2V0dGluZyAibmV4dEJ5dGVzKGJ5dGVbXSkiIGludm9rZWQsIHNpbmdsZSBvciBmaXJzdCBpbiByb3csCiAgICAvLyAgIHdoaWNoIHJlcXVpcmVzIGNvbXB1dGluZyBuZXcgaGFzaCwgdGhhdCBpcywKICAgIC8vICAgdGhlcmUgaXMgbm8gbW9yZSBieXRlcyByZW1haW5pbmcgZnJvbSBwcmV2aW91cyAibmV4dCBieXRlcyIgY29tcHV0YXRpb24sCiAgICAvLyAgIHJlbWFpbmluZyBieXRlcyBhcmUgY29waWVkIGludG8gdGhlIDIxLTM2IHdvcmQgZnJhbWUgb2YgdGhlICJjb3BpZXMiIGFycmF5OwogICAgLy8gLSB1cG9uIGdldHRpbmcgInNldFNlZWQoYnl0ZVtdKSIgaW52b2tlZCwgc2luZ2xlIG9yIGZpcnN0IGluIHJvdywKICAgIC8vICAgcmVtYWluaW5nIGJ5dGVzIGFyZSBjb3BpZWQgYmFjay4KCiAgICAvKioKICAgICAqICBDcmVhdGVzIG9iamVjdCBhbmQgc2V0cyBpbXBsZW1lbnRhdGlvbiB2YXJpYWJsZXMgdG8gdGhlaXIgaW5pdGlhbCB2YWx1ZXMKICAgICAqLwogICAgcHVibGljIFNIQTFQUk5HX1NlY3VyZVJhbmRvbUltcGwoKSB7CgogICAgICAgIHNlZWQgPSBuZXcgaW50W0hBU0hfT0ZGU0VUICsgRVhUUkFGUkFNRV9PRkZTRVRdOwogICAgICAgIHNlZWRbSEFTSF9PRkZTRVRdID0gSDA7CiAgICAgICAgc2VlZFtIQVNIX09GRlNFVCArIDFdID0gSDE7CiAgICAgICAgc2VlZFtIQVNIX09GRlNFVCArIDJdID0gSDI7CiAgICAgICAgc2VlZFtIQVNIX09GRlNFVCArIDNdID0gSDM7CiAgICAgICAgc2VlZFtIQVNIX09GRlNFVCArIDRdID0gSDQ7CgogICAgICAgIHNlZWRMZW5ndGggPSAwOwogICAgICAgIGNvcGllcyA9IG5ldyBpbnRbMiAqIEZSQU1FX0xFTkdUSCArIEVYVFJBRlJBTUVfT0ZGU0VUXTsKICAgICAgICBuZXh0Qnl0ZXMgPSBuZXcgYnl0ZVtESUdFU1RfTEVOR1RIXTsKICAgICAgICBuZXh0QkluZGV4ID0gSEFTSEJZVEVTX1RPX1VTRTsKICAgICAgICBjb3VudGVyID0gQ09VTlRFUl9CQVNFOwogICAgICAgIHN0YXRlID0gVU5ERUZJTkVEOwogICAgfQoKICAgIC8qCiAgICAgKiBUaGUgbWV0aG9kIGludm9rZXMgdGhlIFNIQTFJbXBsJ3MgInVwZGF0ZUhhc2goLi4pIiBtZXRob2QKICAgICAqIHRvIHVwZGF0ZSBjdXJyZW50IHNlZWQgZnJhbWUgYW5kCiAgICAgKiB0byBjb21wdXRlIG5ldyBpbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZSBpZiB0aGUgZnJhbWUgaXMgZnVsbC4KICAgICAqCiAgICAgKiBBZnRlciB0aGF0IGl0IGNvbXB1dGVzIGEgbGVuZ3RoIG9mIHdob2xlIHNlZWQuCiAgICAgKi8KICAgIHByaXZhdGUgdm9pZCB1cGRhdGVTZWVkKGJ5dGVbXSBieXRlcykgewoKICAgICAgICAvLyBvbiBjYWxsOiAgICJzZWVkIiBjb250YWlucyBjdXJyZW50IGJ5dGVzIGFuZCBjdXJyZW50IGhhc2g7CiAgICAgICAgLy8gb24gcmV0dXJuOiAic2VlZCIgY29udGFpbnMgbmV3IGN1cnJlbnQgYnl0ZXMgYW5kIHBvc3NpYmx5IG5ldyBjdXJyZW50IGhhc2gKICAgICAgICAvLyAgICAgICAgICAgIGlmIGFmdGVyIGFkZGluZywgc2VlZCBieXRlcyBvdmVyZmlsbCBpdHMgYnVmZmVyCiAgICAgICAgU0hBMUltcGwudXBkYXRlSGFzaChzZWVkLCBieXRlcywgMCwgYnl0ZXMubGVuZ3RoIC0gMSk7CgogICAgICAgIHNlZWRMZW5ndGggKz0gYnl0ZXMubGVuZ3RoOwogICAgfQoKICAgIC8qKgogICAgICogQ2hhbmdlcyBjdXJyZW50IHNlZWQgYnkgc3VwcGxlbWVudGluZyBhIHNlZWQgYXJndW1lbnQgdG8gdGhlIGN1cnJlbnQgc2VlZCwKICAgICAqIGlmIHRoaXMgYWxyZWFkeSBzZXQ7CiAgICAgKiB0aGUgYXJndW1lbnQgaXMgdXNlZCBhcyBmaXJzdCBzZWVkIG90aGVyd2lzZS4gPEJSPgogICAgICoKICAgICAqIFRoZSBtZXRob2Qgb3ZlcnJpZGVzICJlbmdpbmVTZXRTZWVkKGJ5dGVbXSkiIGluIGNsYXNzIFNlY3VyZVJhbmRvbVNwaS4KICAgICAqCiAgICAgKiBAcGFyYW0KICAgICAqICAgICAgIHNlZWQgLSBieXRlIGFycmF5CiAgICAgKiBAdGhyb3dzCiAgICAgKiAgICAgICBOdWxsUG9pbnRlckV4Y2VwdGlvbiAtIGlmIG51bGwgaXMgcGFzc2VkIHRvIHRoZSAic2VlZCIgYXJndW1lbnQKICAgICAqLwogICAgcHJvdGVjdGVkIHN5bmNocm9uaXplZCB2b2lkIGVuZ2luZVNldFNlZWQoYnl0ZVtdIHNlZWQpIHsKCiAgICAgICAgaWYgKHNlZWQgPT0gbnVsbCkgewogICAgICAgICAgICB0aHJvdyBuZXcgTnVsbFBvaW50ZXJFeGNlcHRpb24oInNlZWQgPT0gbnVsbCIpOwogICAgICAgIH0KCiAgICAgICAgaWYgKHN0YXRlID09IE5FWFRfQllURVMpIHsgLy8gZmlyc3Qgc2V0U2VlZCBhZnRlciBOZXh0Qnl0ZXM7IHJlc3RvcmluZyBoYXNoCiAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoY29waWVzLCBIQVNIQ09QWV9PRkZTRVQsIHRoaXMuc2VlZCwgSEFTSF9PRkZTRVQsCiAgICAgICAgICAgICAgICAgICAgRVhUUkFGUkFNRV9PRkZTRVQpOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IFNFVF9TRUVEOwoKICAgICAgICBpZiAoc2VlZC5sZW5ndGggIT0gMCkgewogICAgICAgICAgICB1cGRhdGVTZWVkKHNlZWQpOwogICAgICAgIH0KICAgIH0KCiAgICAvKioKICAgICAqIFJldHVybnMgYSByZXF1aXJlZCBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzLiA8QlI+CiAgICAgKgogICAgICogVGhlIG1ldGhvZCBvdmVycmlkZXMgImVuZ2luZUdlbmVyYXRlU2VlZCAoaW50KSIgaW4gY2xhc3MgU2VjdXJlUmFuZG9tU3BpLiA8QlI+CiAgICAgKgogICAgICogQHBhcmFtCiAgICAgKiAgICAgICBudW1CeXRlcyAtIG51bWJlciBvZiBieXRlcyB0byByZXR1cm47IHNob3VsZCBiZSA+PSAwLgogICAgICogQHJldHVybgogICAgICogICAgICAgYnl0ZSBhcnJheSBjb250YWluaW5nIGJpdHMgaW4gb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0CiAgICAgKiBAdGhyb3dzCiAgICAgKiAgICAgICBJbnZhbGlkUGFyYW1ldGVyRXhjZXB0aW9uIC0gaWYgbnVtQnl0ZXMgPCAwCiAgICAgKi8KICAgIHByb3RlY3RlZCBzeW5jaHJvbml6ZWQgYnl0ZVtdIGVuZ2luZUdlbmVyYXRlU2VlZChpbnQgbnVtQnl0ZXMpIHsKCiAgICAgICAgYnl0ZVtdIG15Qnl0ZXM7IC8vIGJ5dGVbXSBmb3IgYnl0ZXMgcmV0dXJuZWQgYnkgIm5leHRCeXRlcygpIgoKICAgICAgICBpZiAobnVtQnl0ZXMgPCAwKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBOZWdhdGl2ZUFycmF5U2l6ZUV4Y2VwdGlvbihJbnRlZ2VyLnRvU3RyaW5nKG51bUJ5dGVzKSk7CiAgICAgICAgfQogICAgICAgIGlmIChudW1CeXRlcyA9PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBFbXB0eUFycmF5LkJZVEU7CiAgICAgICAgfQoKICAgICAgICBpZiAobXlSYW5kb20gPT0gbnVsbCkgewogICAgICAgICAgICBteVJhbmRvbSA9IG5ldyBTSEExUFJOR19TZWN1cmVSYW5kb21JbXBsKCk7CiAgICAgICAgICAgIG15UmFuZG9tLmVuZ2luZVNldFNlZWQoZ2V0UmFuZG9tQnl0ZXMoRElHRVNUX0xFTkdUSCkpOwogICAgICAgIH0KCiAgICAgICAgbXlCeXRlcyA9IG5ldyBieXRlW251bUJ5dGVzXTsKICAgICAgICBteVJhbmRvbS5lbmdpbmVOZXh0Qnl0ZXMobXlCeXRlcyk7CgogICAgICAgIHJldHVybiBteUJ5dGVzOwogICAgfQoKICAgIC8qKgogICAgICogV3JpdGVzIHJhbmRvbSBieXRlcyBpbnRvIGFuIGFycmF5IHN1cHBsaWVkLgogICAgICogQml0cyBpbiBhIGJ5dGUgYXJlIGZyb20gbGVmdCB0byByaWdodC4gPEJSPgogICAgICoKICAgICAqIFRvIGdlbmVyYXRlIHJhbmRvbSBieXRlcywgdGhlICJleHBhbnNpb24gb2Ygc291cmNlIGJpdHMiIG1ldGhvZCBpcyB1c2VkLAogICAgICogdGhhdCBpcywKICAgICAqIHRoZSBjdXJyZW50IHNlZWQgd2l0aCBhIDY0LWJpdCBjb3VudGVyIGFwcGVuZGVkIGlzIHVzZWQgdG8gY29tcHV0ZSBuZXcgYml0cy4KICAgICAqIFRoZSBjb3VudGVyIGlzIGluY3JlbWVudGVkIGJ5IDEgZm9yIGVhY2ggMjAtYnl0ZSBvdXRwdXQuIDxCUj4KICAgICAqCiAgICAgKiBUaGUgbWV0aG9kIG92ZXJyaWRlcyBlbmdpbmVOZXh0Qnl0ZXMgaW4gY2xhc3MgU2VjdXJlUmFuZG9tU3BpLgogICAgICoKICAgICAqIEBwYXJhbQogICAgICogICAgICAgYnl0ZXMgLSBieXRlIGFycmF5IHRvIGJlIGZpbGxlZCBpbiB3aXRoIGJ5dGVzCiAgICAgKiBAdGhyb3dzCiAgICAgKiAgICAgICBOdWxsUG9pbnRlckV4Y2VwdGlvbiAtIGlmIG51bGwgaXMgcGFzc2VkIHRvIHRoZSAiYnl0ZXMiIGFyZ3VtZW50CiAgICAgKi8KICAgIHByb3RlY3RlZCBzeW5jaHJvbml6ZWQgdm9pZCBlbmdpbmVOZXh0Qnl0ZXMoYnl0ZVtdIGJ5dGVzKSB7CgogICAgICAgIGludCBpLCBuOwoKICAgICAgICBsb25nIGJpdHM7IC8vIG51bWJlciBvZiBiaXRzIHJlcXVpcmVkIGJ5IFNlY3VyZSBIYXNoIFN0YW5kYXJkCiAgICAgICAgaW50IG5leHRCeXRlVG9SZXR1cm47IC8vIGluZGV4IG9mIHJlYWR5IGJ5dGVzIGluICJieXRlcyIgYXJyYXkKICAgICAgICBpbnQgbGFzdFdvcmQ7IC8vIGluZGV4IG9mIGxhc3Qgd29yZCBpbiBmcmFtZSBjb250YWluaW5nIGJ5dGVzCiAgICAgICAgZmluYWwgaW50IGV4dHJhYnl0ZXMgPSA3Oy8vICMgb2YgYnl0ZXMgdG8gYWRkIGluIG9yZGVyIHRvIGNvbXB1dGVyICMgb2YgOCBieXRlIHdvcmRzCgogICAgICAgIGlmIChieXRlcyA9PSBudWxsKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBOdWxsUG9pbnRlckV4Y2VwdGlvbigiYnl0ZXMgPT0gbnVsbCIpOwogICAgICAgIH0KCiAgICAgICAgbGFzdFdvcmQgPSBzZWVkW0JZVEVTX09GRlNFVF0gPT0gMCA/IDAKICAgICAgICAgICAgICAgIDogKHNlZWRbQllURVNfT0ZGU0VUXSArIGV4dHJhYnl0ZXMpID4+IDMgLSAxOwoKICAgICAgICBpZiAoc3RhdGUgPT0gVU5ERUZJTkVEKSB7CgogICAgICAgICAgICAvLyBubyBzZWVkIHN1cHBsaWVkIGJ5IHVzZXIsIGhlbmNlIGl0IGlzIGdlbmVyYXRlZCB0aHVzIHJhbmRvbWl6aW5nIGludGVybmFsIHN0YXRlCiAgICAgICAgICAgIHVwZGF0ZVNlZWQoZ2V0UmFuZG9tQnl0ZXMoRElHRVNUX0xFTkdUSCkpOwogICAgICAgICAgICBuZXh0QkluZGV4ID0gSEFTSEJZVEVTX1RPX1VTRTsKCiAgICAgICAgICAgIC8vIHVwZGF0ZVNlZWQoLi4uKSB1cGRhdGVzIHdoZXJlIHRoZSBsYXN0IHdvcmQgb2YgdGhlIHNlZWQgaXMsIHNvIHdlCiAgICAgICAgICAgIC8vIGhhdmUgdG8gcmVhZCBpdCBhZ2Fpbi4KICAgICAgICAgICAgbGFzdFdvcmQgPSBzZWVkW0JZVEVTX09GRlNFVF0gPT0gMCA/IDAKICAgICAgICAgICAgICAgICAgICA6IChzZWVkW0JZVEVTX09GRlNFVF0gKyBleHRyYWJ5dGVzKSA+PiAzIC0gMTsKCiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSBTRVRfU0VFRCkgewoKICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShzZWVkLCBIQVNIX09GRlNFVCwgY29waWVzLCBIQVNIQ09QWV9PRkZTRVQsCiAgICAgICAgICAgICAgICAgICAgRVhUUkFGUkFNRV9PRkZTRVQpOwoKICAgICAgICAgICAgLy8gcG9zc2libGUgY2FzZXMgZm9yIDY0LWJ5dGUgZnJhbWU6CiAgICAgICAgICAgIC8vCiAgICAgICAgICAgIC8vIHNlZWQgYnl0ZXMgPCA0OCAgICAgIC0gcmVtYWluaW5nIGJ5dGVzIGFyZSBlbm91Z2ggZm9yIGFsbCwgOCBjb3VudGVyIGJ5dGVzLAogICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAsIGFuZCA4IHNlZWRMZW5ndGggYnl0ZXM7IG5vIGV4dHJhIGZyYW1lIHJlcXVpcmVkCiAgICAgICAgICAgIC8vIDQ4IDwgc2VlZCBieXRlcyA8IDU2IC0gcmVtYWluaW5nIDkgYnl0ZXMgYXJlIGZvciAweDgwIGFuZCA4IGNvdW50ZXIgYnl0ZXMKICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBleHRyYSBmcmFtZSBjb250YWlucyBvbmx5IHNlZWRMZW5ndGggdmFsdWUgYXQgdGhlIGVuZAogICAgICAgICAgICAvLyBzZWVkIGJ5dGVzID4gNTUgICAgICAtIGV4dHJhIGZyYW1lIGNvbnRhaW5zIGJvdGggY291bnRlcidzIGJ5dGVzCiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgYXQgdGhlIGJlZ2lubmluZyBhbmQgc2VlZExlbmd0aCB2YWx1ZSBhdCB0aGUgZW5kOwogICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIG5vdGUsIHRoYXQgYmVnaW5uaW5nIGV4dHJhIGJ5dGVzIGFyZSBub3QgbW9yZSB0aGFuIDgsCiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCBpcywgb25seSAyIGV4dHJhIHdvcmRzIG1heSBiZSB1c2VkCgogICAgICAgICAgICAvLyBubyBuZWVkIHRvIHNldCB0byAiMCIgMyB3b3JkcyBhZnRlciAibGFzdFdvcmQiIGFuZAogICAgICAgICAgICAvLyBtb3JlIHRoYW4gdHdvIHdvcmRzIGJlaGluZCBmcmFtZQogICAgICAgICAgICBmb3IgKGkgPSBsYXN0V29yZCArIDM7IGkgPCBGUkFNRV9MRU5HVEggKyAyOyBpKyspIHsKICAgICAgICAgICAgICAgIHNlZWRbaV0gPSAwOwogICAgICAgICAgICB9CgogICAgICAgICAgICBiaXRzID0gKHNlZWRMZW5ndGggPDwgMykgKyA2NDsgLy8gdHJhbnNmb3JtaW5nICMgb2YgYnl0ZXMgaW50byAjIG9mIGJpdHMKCiAgICAgICAgICAgIC8vIHB1dHRpbmcgIyBvZiBiaXRzIGludG8gdHdvIGxhc3Qgd29yZHMgKDE0LDE1KSBvZiAxNiB3b3JkIGZyYW1lIGluCiAgICAgICAgICAgIC8vIHNlZWQgb3IgY29waWVzIGFycmF5IGRlcGVuZGluZyBvbiB0b3RhbCBsZW5ndGggYWZ0ZXIgcGFkZGluZwogICAgICAgICAgICBpZiAoc2VlZFtCWVRFU19PRkZTRVRdIDwgTUFYX0JZVEVTKSB7CiAgICAgICAgICAgICAgICBzZWVkWzE0XSA9IChpbnQpIChiaXRzID4+PiAzMik7CiAgICAgICAgICAgICAgICBzZWVkWzE1XSA9IChpbnQpIChiaXRzICYgMHhGRkZGRkZGRik7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBjb3BpZXNbRVhUUkFGUkFNRV9PRkZTRVQgKyAxNF0gPSAoaW50KSAoYml0cyA+Pj4gMzIpOwogICAgICAgICAgICAgICAgY29waWVzW0VYVFJBRlJBTUVfT0ZGU0VUICsgMTVdID0gKGludCkgKGJpdHMgJiAweEZGRkZGRkZGKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgbmV4dEJJbmRleCA9IEhBU0hCWVRFU19UT19VU0U7IC8vIHNraXBwaW5nIHJlbWFpbmluZyByYW5kb20gYml0cwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IE5FWFRfQllURVM7CgogICAgICAgIGlmIChieXRlcy5sZW5ndGggPT0gMCkgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgfQoKICAgICAgICBuZXh0Qnl0ZVRvUmV0dXJuID0gMDsKCiAgICAgICAgLy8gcG9zc2libHkgbm90IGFsbCBvZiBIQVNIQllURVNfVE9fVVNFIGJ5dGVzIHdlcmUgdXNlZCBwcmV2aW91cyB0aW1lCiAgICAgICAgbiA9IChIQVNIQllURVNfVE9fVVNFIC0gbmV4dEJJbmRleCkgPCAoYnl0ZXMubGVuZ3RoIC0gbmV4dEJ5dGVUb1JldHVybikgPyBIQVNIQllURVNfVE9fVVNFCiAgICAgICAgICAgICAgICAtIG5leHRCSW5kZXgKICAgICAgICAgICAgICAgIDogYnl0ZXMubGVuZ3RoIC0gbmV4dEJ5dGVUb1JldHVybjsKICAgICAgICBpZiAobiA+IDApIHsKICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShuZXh0Qnl0ZXMsIG5leHRCSW5kZXgsIGJ5dGVzLCBuZXh0Qnl0ZVRvUmV0dXJuLCBuKTsKICAgICAgICAgICAgbmV4dEJJbmRleCArPSBuOwogICAgICAgICAgICBuZXh0Qnl0ZVRvUmV0dXJuICs9IG47CiAgICAgICAgfQoKICAgICAgICBpZiAobmV4dEJ5dGVUb1JldHVybiA+PSBieXRlcy5sZW5ndGgpIHsKICAgICAgICAgICAgcmV0dXJuOyAvLyByZXR1cm4gYmVjYXVzZSAiYnl0ZXNbXSIgYXJlIGZpbGxlZCBpbgogICAgICAgIH0KCiAgICAgICAgbiA9IHNlZWRbQllURVNfT0ZGU0VUXSAmIDB4MDM7CiAgICAgICAgZm9yICg7OykgewogICAgICAgICAgICBpZiAobiA9PSAwKSB7CgogICAgICAgICAgICAgICAgc2VlZFtsYXN0V29yZF0gPSAoaW50KSAoY291bnRlciA+Pj4gMzIpOwogICAgICAgICAgICAgICAgc2VlZFtsYXN0V29yZCArIDFdID0gKGludCkgKGNvdW50ZXIgJiAweEZGRkZGRkZGKTsKICAgICAgICAgICAgICAgIHNlZWRbbGFzdFdvcmQgKyAyXSA9IEVORF9GTEFHU1swXTsKCiAgICAgICAgICAgIH0gZWxzZSB7CgogICAgICAgICAgICAgICAgc2VlZFtsYXN0V29yZF0gfD0gKGludCkgKChjb3VudGVyID4+PiBSSUdIVDFbbl0pICYgTUFTS1tuXSk7CiAgICAgICAgICAgICAgICBzZWVkW2xhc3RXb3JkICsgMV0gPSAoaW50KSAoKGNvdW50ZXIgPj4+IFJJR0hUMltuXSkgJiAweEZGRkZGRkZGKTsKICAgICAgICAgICAgICAgIHNlZWRbbGFzdFdvcmQgKyAyXSA9IChpbnQpICgoY291bnRlciA8PCBMRUZUW25dKSB8IEVORF9GTEFHU1tuXSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHNlZWRbQllURVNfT0ZGU0VUXSA+IE1BWF9CWVRFUykgewogICAgICAgICAgICAgICAgY29waWVzW0VYVFJBRlJBTUVfT0ZGU0VUXSA9IHNlZWRbRlJBTUVfTEVOR1RIXTsKICAgICAgICAgICAgICAgIGNvcGllc1tFWFRSQUZSQU1FX09GRlNFVCArIDFdID0gc2VlZFtGUkFNRV9MRU5HVEggKyAxXTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgU0hBMUltcGwuY29tcHV0ZUhhc2goc2VlZCk7CgogICAgICAgICAgICBpZiAoc2VlZFtCWVRFU19PRkZTRVRdID4gTUFYX0JZVEVTKSB7CgogICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShzZWVkLCAwLCBjb3BpZXMsIEZSQU1FX09GRlNFVCwgRlJBTUVfTEVOR1RIKTsKICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoY29waWVzLCBFWFRSQUZSQU1FX09GRlNFVCwgc2VlZCwgMCwKICAgICAgICAgICAgICAgICAgICAgICAgRlJBTUVfTEVOR1RIKTsKCiAgICAgICAgICAgICAgICBTSEExSW1wbC5jb21wdXRlSGFzaChzZWVkKTsKICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoY29waWVzLCBGUkFNRV9PRkZTRVQsIHNlZWQsIDAsIEZSQU1FX0xFTkdUSCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY291bnRlcisrOwoKICAgICAgICAgICAgaW50IGogPSAwOwogICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgRVhUUkFGUkFNRV9PRkZTRVQ7IGkrKykgewogICAgICAgICAgICAgICAgaW50IGsgPSBzZWVkW0hBU0hfT0ZGU0VUICsgaV07CiAgICAgICAgICAgICAgICBuZXh0Qnl0ZXNbal0gPSAoYnl0ZSkgKGsgPj4+IDI0KTsgLy8gZ2V0dGluZyBmaXJzdCAgYnl0ZSBmcm9tIGxlZnQKICAgICAgICAgICAgICAgIG5leHRCeXRlc1tqICsgMV0gPSAoYnl0ZSkgKGsgPj4+IDE2KTsgLy8gZ2V0dGluZyBzZWNvbmQgYnl0ZSBmcm9tIGxlZnQKICAgICAgICAgICAgICAgIG5leHRCeXRlc1tqICsgMl0gPSAoYnl0ZSkgKGsgPj4+IDgpOyAvLyBnZXR0aW5nIHRoaXJkICBieXRlIGZyb20gbGVmdAogICAgICAgICAgICAgICAgbmV4dEJ5dGVzW2ogKyAzXSA9IChieXRlKSAoayk7IC8vIGdldHRpbmcgZm91cnRoIGJ5dGUgZnJvbSBsZWZ0CiAgICAgICAgICAgICAgICBqICs9IDQ7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIG5leHRCSW5kZXggPSAwOwogICAgICAgICAgICBqID0gSEFTSEJZVEVTX1RPX1VTRSA8IChieXRlcy5sZW5ndGggLSBuZXh0Qnl0ZVRvUmV0dXJuKSA/IEhBU0hCWVRFU19UT19VU0UKICAgICAgICAgICAgICAgICAgICA6IGJ5dGVzLmxlbmd0aCAtIG5leHRCeXRlVG9SZXR1cm47CgogICAgICAgICAgICBpZiAoaiA+IDApIHsKICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkobmV4dEJ5dGVzLCAwLCBieXRlcywgbmV4dEJ5dGVUb1JldHVybiwgaik7CiAgICAgICAgICAgICAgICBuZXh0Qnl0ZVRvUmV0dXJuICs9IGo7CiAgICAgICAgICAgICAgICBuZXh0QkluZGV4ICs9IGo7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmIChuZXh0Qnl0ZVRvUmV0dXJuID49IGJ5dGVzLmxlbmd0aCkgewogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9CgogICAgcHJpdmF0ZSB2b2lkIHdyaXRlT2JqZWN0KE9iamVjdE91dHB1dFN0cmVhbSBvb3MpIHRocm93cyBJT0V4Y2VwdGlvbiB7CgogICAgICAgIGludFtdIGludERhdGEgPSBudWxsOwoKICAgICAgICBmaW5hbCBpbnQgb25seV9oYXNoID0gRVhUUkFGUkFNRV9PRkZTRVQ7CiAgICAgICAgZmluYWwgaW50IGhhc2hlc19hbmRfZnJhbWUgPSBFWFRSQUZSQU1FX09GRlNFVCAqIDIgKyBGUkFNRV9MRU5HVEg7CiAgICAgICAgZmluYWwgaW50IGhhc2hlc19hbmRfZnJhbWVfZXh0cmEgPSBFWFRSQUZSQU1FX09GRlNFVCAqIDIgKyBGUkFNRV9MRU5HVEgKICAgICAgICAgICAgICAgICogMjsKCiAgICAgICAgb29zLndyaXRlTG9uZyhzZWVkTGVuZ3RoKTsKICAgICAgICBvb3Mud3JpdGVMb25nKGNvdW50ZXIpOwogICAgICAgIG9vcy53cml0ZUludChzdGF0ZSk7CiAgICAgICAgb29zLndyaXRlSW50KHNlZWRbQllURVNfT0ZGU0VUXSk7CgogICAgICAgIGludCBuUmVtYWluaW5nID0gKHNlZWRbQllURVNfT0ZGU0VUXSArIDMpID4+IDI7IC8vIGNvbnZlcnRpbmcgYnl0ZXMgaW4gd29yZHMKICAgICAgICAvLyByZXN1bHQgbWF5IGJlIDAKICAgICAgICBpZiAoc3RhdGUgIT0gTkVYVF9CWVRFUykgewoKICAgICAgICAgICAgLy8gZWl0aGVyIHRoZSBzdGF0ZSBpcyBVTkRFRklORUQgb3IgcHJldmlvdXMgbWV0aG9kIHdhcyAic2V0U2VlZCguLikiCiAgICAgICAgICAgIC8vIHNvIGluICJzZWVkW10iIHRvIHNlcmlhbGl6ZSBhcmUgcmVtYWluaW5nIGJ5dGVzIChzZWVkWzAtblJlbWFpbmluZ10pIGFuZAogICAgICAgICAgICAvLyBjdXJyZW50IGhhc2ggKHNlZWRbODItODZdKQoKICAgICAgICAgICAgaW50RGF0YSA9IG5ldyBpbnRbb25seV9oYXNoICsgblJlbWFpbmluZ107CgogICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHNlZWQsIDAsIGludERhdGEsIDAsIG5SZW1haW5pbmcpOwogICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHNlZWQsIEhBU0hfT0ZGU0VULCBpbnREYXRhLCBuUmVtYWluaW5nLAogICAgICAgICAgICAgICAgICAgIEVYVFJBRlJBTUVfT0ZGU0VUKTsKCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgLy8gcHJldmlvdXMgbWV0aG9kIHdhcyAibmV4dEJ5dGVzKC4uKSIKICAgICAgICAgICAgLy8gc28sIGRhdGEgdG8gc2VyaWFsaXplIGFyZSBhbGwgdGhlIGFib3ZlICh0d28gZmlyc3QgYXJlIGluICJjb3BpZXMiIGFycmF5KQogICAgICAgICAgICAvLyBhbmQgY3VycmVudCB3b3JkcyBpbiBib3RoIGZyYW1lIGFuZCBleHRyYSBmcmFtZSAoYXMgaWYpCgogICAgICAgICAgICBpbnQgb2Zmc2V0ID0gMDsKICAgICAgICAgICAgaWYgKHNlZWRbQllURVNfT0ZGU0VUXSA8IE1BWF9CWVRFUykgeyAvLyBubyBleHRyYSBmcmFtZQoKICAgICAgICAgICAgICAgIGludERhdGEgPSBuZXcgaW50W2hhc2hlc19hbmRfZnJhbWUgKyBuUmVtYWluaW5nXTsKCiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGV4dHJhIGZyYW1lIGlzIHVzZWQKCiAgICAgICAgICAgICAgICBpbnREYXRhID0gbmV3IGludFtoYXNoZXNfYW5kX2ZyYW1lX2V4dHJhICsgblJlbWFpbmluZ107CgogICAgICAgICAgICAgICAgaW50RGF0YVtvZmZzZXRdID0gc2VlZFtGUkFNRV9MRU5HVEhdOwogICAgICAgICAgICAgICAgaW50RGF0YVtvZmZzZXQgKyAxXSA9IHNlZWRbRlJBTUVfTEVOR1RIICsgMV07CiAgICAgICAgICAgICAgICBpbnREYXRhW29mZnNldCArIDJdID0gc2VlZFtGUkFNRV9MRU5HVEggKyAxNF07CiAgICAgICAgICAgICAgICBpbnREYXRhW29mZnNldCArIDNdID0gc2VlZFtGUkFNRV9MRU5HVEggKyAxNV07CiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShzZWVkLCAwLCBpbnREYXRhLCBvZmZzZXQsIEZSQU1FX0xFTkdUSCk7CiAgICAgICAgICAgIG9mZnNldCArPSBGUkFNRV9MRU5HVEg7CgogICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGNvcGllcywgRlJBTUVfTEVOR1RIICsgRVhUUkFGUkFNRV9PRkZTRVQsIGludERhdGEsCiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LCBuUmVtYWluaW5nKTsKICAgICAgICAgICAgb2Zmc2V0ICs9IG5SZW1haW5pbmc7CgogICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGNvcGllcywgMCwgaW50RGF0YSwgb2Zmc2V0LCBFWFRSQUZSQU1FX09GRlNFVCk7CiAgICAgICAgICAgIG9mZnNldCArPSBFWFRSQUZSQU1FX09GRlNFVDsKCiAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoc2VlZCwgSEFTSF9PRkZTRVQsIGludERhdGEsIG9mZnNldCwKICAgICAgICAgICAgICAgICAgICBFWFRSQUZSQU1FX09GRlNFVCk7CiAgICAgICAgfQogICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgaW50RGF0YS5sZW5ndGg7IGkrKykgewogICAgICAgICAgICBvb3Mud3JpdGVJbnQoaW50RGF0YVtpXSk7CiAgICAgICAgfQoKICAgICAgICBvb3Mud3JpdGVJbnQobmV4dEJJbmRleCk7CiAgICAgICAgb29zLndyaXRlKG5leHRCeXRlcywgbmV4dEJJbmRleCwgSEFTSEJZVEVTX1RPX1VTRSAtIG5leHRCSW5kZXgpOwogICAgfQoKICAgIHByaXZhdGUgdm9pZCByZWFkT2JqZWN0KE9iamVjdElucHV0U3RyZWFtIG9pcykgdGhyb3dzIElPRXhjZXB0aW9uLAogICAgICAgICAgICBDbGFzc05vdEZvdW5kRXhjZXB0aW9uIHsKCiAgICAgICAgc2VlZCA9IG5ldyBpbnRbSEFTSF9PRkZTRVQgKyBFWFRSQUZSQU1FX09GRlNFVF07CiAgICAgICAgY29waWVzID0gbmV3IGludFsyICogRlJBTUVfTEVOR1RIICsgRVhUUkFGUkFNRV9PRkZTRVRdOwogICAgICAgIG5leHRCeXRlcyA9IG5ldyBieXRlW0RJR0VTVF9MRU5HVEhdOwoKICAgICAgICBzZWVkTGVuZ3RoID0gb2lzLnJlYWRMb25nKCk7CiAgICAgICAgY291bnRlciA9IG9pcy5yZWFkTG9uZygpOwogICAgICAgIHN0YXRlID0gb2lzLnJlYWRJbnQoKTsKICAgICAgICBzZWVkW0JZVEVTX09GRlNFVF0gPSBvaXMucmVhZEludCgpOwoKICAgICAgICBpbnQgblJlbWFpbmluZyA9IChzZWVkW0JZVEVTX09GRlNFVF0gKyAzKSA+PiAyOyAvLyBjb252ZXJ0aW5nIGJ5dGVzIGluIHdvcmRzCgogICAgICAgIGlmIChzdGF0ZSAhPSBORVhUX0JZVEVTKSB7CgogICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG5SZW1haW5pbmc7IGkrKykgewogICAgICAgICAgICAgICAgc2VlZFtpXSA9IG9pcy5yZWFkSW50KCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBFWFRSQUZSQU1FX09GRlNFVDsgaSsrKSB7CiAgICAgICAgICAgICAgICBzZWVkW0hBU0hfT0ZGU0VUICsgaV0gPSBvaXMucmVhZEludCgpOwogICAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgaWYgKHNlZWRbQllURVNfT0ZGU0VUXSA+PSBNQVhfQllURVMpIHsKCiAgICAgICAgICAgICAgICAvLyByZWFkaW5nIG5leHQgYnl0ZXMgaW4gc2VlZCBleHRyYSBmcmFtZQogICAgICAgICAgICAgICAgc2VlZFtGUkFNRV9MRU5HVEhdID0gb2lzLnJlYWRJbnQoKTsKICAgICAgICAgICAgICAgIHNlZWRbRlJBTUVfTEVOR1RIICsgMV0gPSBvaXMucmVhZEludCgpOwogICAgICAgICAgICAgICAgc2VlZFtGUkFNRV9MRU5HVEggKyAxNF0gPSBvaXMucmVhZEludCgpOwogICAgICAgICAgICAgICAgc2VlZFtGUkFNRV9MRU5HVEggKyAxNV0gPSBvaXMucmVhZEludCgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vIHJlYWRpbmcgbmV4dCBieXRlcyBpbiBzZWVkIGZyYW1lCiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRlJBTUVfTEVOR1RIOyBpKyspIHsKICAgICAgICAgICAgICAgIHNlZWRbaV0gPSBvaXMucmVhZEludCgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vIHJlYWRpbmcgcmVtYWluaW5nIHNlZWQgYnl0ZXMKICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuUmVtYWluaW5nOyBpKyspIHsKICAgICAgICAgICAgICAgIGNvcGllc1tGUkFNRV9MRU5HVEggKyBFWFRSQUZSQU1FX09GRlNFVCArIGldID0gb2lzLnJlYWRJbnQoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICAvLyByZWFkaW5nIGNvcHkgb2YgY3VycmVudCBoYXNoCiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRVhUUkFGUkFNRV9PRkZTRVQ7IGkrKykgewogICAgICAgICAgICAgICAgY29waWVzW2ldID0gb2lzLnJlYWRJbnQoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICAvLyByZWFkaW5nIGN1cnJlbnQgaGFzaAogICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEVYVFJBRlJBTUVfT0ZGU0VUOyBpKyspIHsKICAgICAgICAgICAgICAgIHNlZWRbSEFTSF9PRkZTRVQgKyBpXSA9IG9pcy5yZWFkSW50KCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIG5leHRCSW5kZXggPSBvaXMucmVhZEludCgpOwogICAgICAgIFN0cmVhbXMucmVhZEZ1bGx5KG9pcywgbmV4dEJ5dGVzLCBuZXh0QkluZGV4LCBIQVNIQllURVNfVE9fVVNFIC0gbmV4dEJJbmRleCk7CiAgICB9CgogICAgcHJpdmF0ZSBzdGF0aWMgYnl0ZVtdIGdldFJhbmRvbUJ5dGVzKGludCBieXRlQ291bnQpIHsKICAgICAgICBpZiAoYnl0ZUNvdW50IDw9IDApIHsKICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigiVG9vIGZldyBieXRlcyByZXF1ZXN0ZWQ6ICIgKyBieXRlQ291bnQpOwogICAgICAgIH0KCiAgICAgICAgQmxvY2tHdWFyZC5Qb2xpY3kgb3JpZ2luYWxQb2xpY3kgPSBCbG9ja0d1YXJkLmdldFRocmVhZFBvbGljeSgpOwogICAgICAgIHRyeSB7CiAgICAgICAgICAgIEJsb2NrR3VhcmQuc2V0VGhyZWFkUG9saWN5KEJsb2NrR3VhcmQuTEFYX1BPTElDWSk7CiAgICAgICAgICAgIGJ5dGVbXSByZXN1bHQgPSBuZXcgYnl0ZVtieXRlQ291bnRdOwogICAgICAgICAgICBTdHJlYW1zLnJlYWRGdWxseShkZXZVUmFuZG9tLCByZXN1bHQsIDAsIGJ5dGVDb3VudCk7CiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfSBjYXRjaCAoRXhjZXB0aW9uIGV4KSB7CiAgICAgICAgICAgIHRocm93IG5ldyBQcm92aWRlckV4Y2VwdGlvbigiQ291bGRuJ3QgcmVhZCAiICsgYnl0ZUNvdW50ICsgIiByYW5kb20gYnl0ZXMiLCBleCk7CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgQmxvY2tHdWFyZC5zZXRUaHJlYWRQb2xpY3kob3JpZ2luYWxQb2xpY3kpOwogICAgICAgIH0KICAgIH0KfQo=
