```
Message-ID: <1417903381.3720301228339030908.JavaMail.root@zmail01.collab.prod.int.phx2.redhat.com>
Date: Wed, 3 Dec 2008 16:17:10 -0500 (EST)
From: Josh Bressers <bressers@...hat.com>
To: oss-security <oss-security@...ts.openwall.com>
Cc: coley@...re.org
Subject: CVE Request (zaptel)

Hi Steve,

I ran across this Debian bug:
<http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=507459>

The upstream report is here:
<http://bugs.digium.com/view.php?id=13954>

As best as I can tell, it's for real.

Thanks.

--
    JB
```

```
Package: zaptel
Version: 1.4.11~dfsg-3
Severity: grave
Tags: pending security

Impact: local privileges escalation
Version: all versions (Now fixed in SVN, rev 4588)
Upstream issue: <http://bugs.digium.com/view.php?id=13954>

Fix for Etch version: attached dpatch
Fix for Lenny version: <http://svn.debian.org/viewsvn/pkg-voip?rev=6507&view=rev>

Some older Zaptel drivers do not apply input validation on the sync
field from the ioctl ZT_SPANCONFIG . This is sent on /dev/zap/ctl ,
which in Debian is writable to the group dialout.

In Zaptel this ioctl is mostly handled by the specific spanconfig
function of the low-level driver. Thus this will not have any impact
unless someone has the matching hardware.

* torisa.c is a driver for the old ISA dual-span T1 card, which I believe
  nobody actually uses.
* tor2.c is the driver for the Zapata Telephony Tormenta 2 card quad
  T1/E1 card. Still sold today.

Those two drivers use one specific field from the ioctl struct as an
array index and write there, assuming it is between 0 and 1 (torisa) or
3 (tor2). So we have a nice way to write over many places in kernel
space. The value to write, though, is not easy to control and can't even
be 0.

* wct1xxp.c is the driver for Digium's earlier single-span E1 cards
  (now deprecated: E100P and T100P.
* wcte11xp is the driver for Digium's TE110P, which was was slightly
  better, but replaced is now EOL.

The issue with those two is that the value from this field is written to
a register, while we only wanted to get its first bit. I'm still not
sure if it has any interesting impact for the user, but it is definetly
misbehaving.

Analog cards do not have a spanconfig method. Our package also includes
several other drivers for digital cards that do have a spanconfig method
(cwain, qozap, zaphfc, vzaphfc and ztgsm in Etch, and in Lenny: also
ds1x1f) but none of them seem to have this problem.
```

Based on the provided information, here's a breakdown of the vulnerability:

**Root Cause:** Insufficient input validation in the `sync` field of the `ZT_SPANCONFIG` ioctl in some Zaptel drivers.

**Vulnerabilities:**
*   **Out-of-bounds write:** The `torisa.c` and `tor2.c` drivers use the `sync` field as an array index without proper validation, leading to out-of-bounds writes in kernel space.
*   **Incorrect register access:** The `wct1xxp.c` and `wcte11xp` drivers write the value of the `sync` field directly to a register, while only the first bit was intended to be used, resulting in misbehavior, potentially exploitable.

**Impact of Exploitation:**
*   **Local privilege escalation:** The vulnerability in `torisa.c` and `tor2.c` allows for arbitrary memory writes in kernel space, leading to potential local privilege escalation. The potential impact of the register issue in `wct1xxp.c` and `wcte11xp` isn't explicitly defined, but is stated to be misbehaving.

**Attack Vectors:**
*   The `ZT_SPANCONFIG` ioctl is sent to `/dev/zap/ctl`.
*   The `/dev/zap/ctl` device file in Debian is writable by the `dialout` group.

**Required Attacker Capabilities/Position:**
*   The attacker must have local access to the system.
*   The attacker must be a member of the `dialout` group.
*   The attacker needs to have the specific vulnerable hardware.
*   Knowledge of how to craft the ioctl with a malicious sync field.

The provided information provides more detail than a typical CVE description, specifically identifying the vulnerable drivers (`torisa.c`, `tor2.c`, `wct1xxp.c`, `wcte11xp`) and the specific issue in each one.