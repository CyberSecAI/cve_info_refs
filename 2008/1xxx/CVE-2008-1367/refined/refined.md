```
{
  "cve": "CVE-2008-1367",
  "description": "It was discovered that the Linux kernel handled string operations in the opposite way to the GNU Compiler Collection (GCC). This could allow a local unprivileged user to cause memory corruption.",
  "affected_software": [
    {
      "name": "Red Hat Enterprise Linux",
      "versions": ["4"]
    },
    {
      "name": "SUSE Linux Enterprise Desktop",
       "versions": ["10 SP1"]
    },
    {
       "name": "openSUSE",
      "versions": ["10.2", "10.3"]
    },
     {
      "name": "Debian Linux",
      "versions": ["2.6.18.dfsg.1-10", "2.6.18.dfsg.1-19", "2.6.24-5"]
    },
    {
      "name": "Linux Kernel",
      "versions": [
        "2.6.18",
         "2.6.22",
         "2.6.24"
      ]
    }
  ],
  "vulnerability_details": {
    "root_cause": "The Linux kernel does not clear the direction flag (DF) before calling a signal handler, while the x86/x86-64 ABI requires that the DF flag be clear upon function entry. This discrepancy, coupled with a change in GCC 4.3.0 which assumes that the DF flag is cleared, can lead to incorrect memory operations and potential memory corruption. Prior versions of GCC would emit a `cld` instruction before memory operations, but this is no longer the case in 4.3.0.",
    "weaknesses": [
      "The kernel signal handler does not clear the DF bit, which can lead to inconsistent behavior when string operations are performed in signal handlers."
    ],
    "impact": "A local, unprivileged user may be able to cause memory corruption or code execution due to incorrect memory operations when a signal handler is called while the direction flag is set. This could potentially lead to other vulnerabilities due to corrupted memory.",
    "attack_vectors": [
      "A local user can exploit this by triggering a signal while the DF flag is set via string operations, such as `movs`, `stos`.",
      "A local attacker may be able to trigger the execution of a signal handler while a program has the direction flag set."
    ],
    "required_capabilities": [
      "The attacker needs to be able to execute code locally.",
      "The attacker needs a means to trigger a signal, while a thread has the direction flag set (e.g., through an application that performs string operations)."
    ]
  },
  "additional_notes": [
    "This issue arises due to a change in GCC 4.3 which stopped emitting `cld` instructions before string operations, relying on the ABI. It is important to note that while the kernel was non compliant with the ABI in terms of DF, prior versions of GCC did emit a cld instruction making the kernel functional.",
    "The vulnerability is triggered by the kernel not clearing the direction flag before calling a signal handler, combined with the GCC optimization which eliminates the 'cld' instruction and assumes that the direction flag is clear upon function entry. This can result in a memory operation performed within the handler to write in the opposite direction.",
    "The vulnerability can occur on x86 and x86-64 architectures. The affected kernel versions are pre-2.6.25, which require a backported patch to resolve the issue.",
     " The bug was found when building Steel Bank Common Lisp (SBCL) using the new compiler.",
        "Older GCCs would add cld just in case, whenever it used some string instruction (movs*/stos*/loads*/cmps* etc.), GCC 4.3.0 relies on the ABI guarantee.",
    "GCC developer says it's the job of the kernel."
  ]
}
```